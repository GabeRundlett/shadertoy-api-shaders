{
    "Shader": {
        "info": {
            "date": "1462248963",
            "description": " Testing 128-bit multi-color spites which are packed into ivec4s utilizing all 32 bits of each integer component. Each sprite is 8x8 (64 pixels) and has 2 bits per pixel allowing for 4 colors per sprite pixel.",
            "flags": 0,
            "hasliked": 0,
            "id": "4d3SWs",
            "likes": 25,
            "name": "128-Bit 4-Color Sprites",
            "published": 3,
            "tags": [
                "sprite",
                "bit",
                "integer"
            ],
            "usePreview": 0,
            "username": "Flyguy",
            "viewed": 1350
        },
        "renderpass": [
            {
                "code": "//128-bit, 4-Color sprites stored in ivec4s\n//This is very hacky and required alot of debugging just to get consistent results \n//between ANGLE and OpenGL on the same machine.\n//This only works on GPUs that support 32-bit integers in shaders.\n\n//Constants\n//Bits per pixel\n#define BPP 2\n//Bits per int\n#define BPI 32\n#define SPR_SIZE vec2(8, 8)\n\n//Derived constants\n#define PIXELS_PER_INT (BPI / BPP)\n\n//Macros\n//Define a 32-bit integer from high and low 16-bit parts.\n#define U32(h,l) (h*0x10000+l)\n\n//Define a sprite row by row.\n#define SPRITE(r0,r1,r2,r3,r4,r5,r6,r7) uvec4(U32(r0,r1),U32(r2,r3),U32(r4,r5),U32(r6,r7))\n\n//Sprite data (Generated with a custom image converter)\n//Pixel layout:\n/*\nBlock sprite:\n\n   Row:0      1      2      3      4      5      6      7 \nSPRITE(0xFFFE,0xEAA9,0xE569,0xE6B9,0xE6B9,0xEBF9,0xEAA9,0x9555)\n         ^                                                   ^\n         Top Left                                            Bottom Right\n\nEach hex digit defines 4 bits which defines 2 pixels @ 2 BPP.\nex.\n0xEAA9\nE    A    A    9\n1110 1010 1010 1001\n\n11 10 10 10 10 10 10 01\n|/ |/ |/ |/ |/ |/ |/ |/\n3  2  2  2  2  2  2  1  <- Pixel values/palette indexes.\n*/\n#define block   SPRITE(0xFFFE,0xEAA9,0xE569,0xE6B9,0xE6B9,0xEBF9,0xEAA9,0x9555)\n#define brckl   SPRITE(0x6FFF,0xBAAA,0xEAAA,0xEAAA,0xEAAA,0xAAAA,0x6AAA,0x5555)\n#define brckr   SPRITE(0xFFE5,0xAAA9,0xAAA9,0xAAA9,0xAAA9,0xAAA9,0xAAA5,0x5555)\n#define ball_01 SPRITE(0x0002,0x006A,0x019A,0x066A,0x1599,0x196A,0x1599,0x5966)\n#define ball_11 SPRITE(0x8000,0xAF00,0xBBC0,0xAFF0,0xBBFC,0xAEEC,0xABB8,0xAAAA)\n#define ball_00 SPRITE(0x5559,0x1596,0x1565,0x1559,0x0555,0x0155,0x0055,0x0001)\n#define ball_10 SPRITE(0x99AA,0x6AA8,0x9998,0x6664,0x5590,0x9940,0x5500,0x4000)\n#define ball_sm SPRITE(0x0AA0,0x26B8,0x5AFE,0x66BA,0x59AA,0x5666,0x1598,0x0550)\n\nfloat tau = atan(1.0)*8.0;\n\n//Blends 'b' with 'a' using b's alpha.\nvec4 blend(vec4 a, vec4 b)\n{\n\treturn mix(a, b, b.a);   \n}\n\n//Extract pixel 'p' from a 32-bit integer 'n'\n//Returns a normalized value (0-1) within the pixel's range (2^BPP - 1).\nfloat pixel(uint n, int p)\n{\n    if(p >= 0 && p < PIXELS_PER_INT)\n    {   \n        uint range = (1u << BPP) - 1u;\n        \n        n = (n >> (p * BPP)) & range;\n        \n        return float(n) / float(range);\n    }\n    return 0.0;\n}\n\n//8x8 Sprite\nfloat sprite8(uvec4 data, vec2 uv)\n{\n    uv = floor(uv);    \n    uv.x = SPR_SIZE.x - 1.0 - uv.x;\n    \n  \t//Calculate which pixel to extract & which component its in.\t  \n\tint idx = int(uv.y * SPR_SIZE.x + uv.x);\n    int com = idx / PIXELS_PER_INT;\n    idx = idx % PIXELS_PER_INT;\n    \n  \t//Clipping bounds  \n    float clip = float(all(greaterThan(uv, vec2(-1))) && all(lessThan(uv, SPR_SIZE)));\n    \n    return pixel(data[3 - com], idx) * clip;\n}\n\n//16x16 Sprite (4 8x8 sprites)\n//Data layout:\n//d2,d3\n//d0,d1\nfloat sprite16(uvec4 d0, uvec4 d1, uvec4 d2, uvec4 d3, vec2 uv)\n{\n\tvec2 uvt = floor(uv / SPR_SIZE);\n    vec2 uvs = mod(uv, SPR_SIZE);\n    \n    uvec4 cdata = (uvt == vec2(0,0)) ? d0 :\n\t\t\t\t  (uvt == vec2(1,0)) ? d1 :\n    \t\t\t  (uvt == vec2(0,1)) ? d2 :\n    \t\t\t  (uvt == vec2(1,1)) ? d3 : uvec4(0);\n    \n    return sprite8(cdata, uvs);\n}\n\n//4-Color custom palette.\nvec4 pal_0(float x)\n{\n     vec4 a = vec4(0.00, 0.00, 0.00, 0.00);\n     vec4 b = vec4(0.20, 0.20, 0.20, 1.00);\n     vec4 c = vec4(0.40, 0.40, 0.40, 1.00);\n     vec4 d = vec4(0.60, 0.60, 0.60, 1.00);\n    \n\t return (x < 0.25) ? a : \n         \t(x < 0.50) ? b : \n    \t\t(x < 0.75) ? c : \n    \t\t(x < 1.00) ? d : d; \n}\n\n//4-Color 'shade' palette. \nvec4 pal_sh(float x, vec3 col)\n{\n     vec4 a = vec4(0);\n     vec4 b = vec4(col * 0.33, 1.00);\n     vec4 c = vec4(col * 0.66, 1.00);\n     vec4 d = vec4(col * 0.50 + 0.50, 1.00);\n    \n\t return (x < 0.25) ? a : \n         \t(x < 0.50) ? b : \n    \t\t(x < 0.75) ? c : \n    \t\t(x < 1.00) ? d : d; \n}\n\n//Background tiles\nvec4 background(vec2 uv, vec2 res)\n{\n    vec2 uvt = floor(uv / SPR_SIZE);\n    vec2 uvs = mod(uv, SPR_SIZE);\n    \n    uvec4 data = uvec4(0);\n    \n    //Checkerboard of left/right brick sprites making a staggered brick pattern.\n    data = (mod(uvt.x + uvt.y, 2.0) == 0.0) ? brckl : brckr;\n    \n    res /= SPR_SIZE;\n    \n    //Border\n    if(uvt.x <= 1.0 || uvt.y <= 1.0 || uvt.x >= res.x - 2.0 || uvt.y >= res.y - 2.0)\n    {\n     \tdata = block;\n    }\n    \n    return pal_0(sprite8(data, uvs));\n}\n\n//Moving sprites\nvec4 sprites(vec2 uv, vec2 res)\n{\n    float idx = 0.0;\n    vec4 c = vec4(0);\n    \n    vec2 uvs = uv;\n    vec2 off = vec2(0);\n    uvs -= floor(res/2.0);\n    uvs += 8.5;\n    \n    float a = iTime * 2.0;\n    float rad = 32.0;\n    \n    //Red ball\n    off = floor(vec2(cos(a),sin(a)) * rad);\n    \n    idx = sprite16(ball_00, ball_10, ball_01, ball_11, uvs - off);\n    c = blend(c, pal_sh(idx, vec3(1,0,0)));\n\t\n    //Green ball\n    a -= tau / 3.0;\n    off = floor(vec2(cos(a),sin(a)) * rad);\n    \n    idx = sprite16(ball_00, ball_10, ball_01, ball_11, uvs - off);\n    c = blend(c, pal_sh(idx, vec3(0,1,0)));\n    \n    //Blue ball\n    a -= tau / 3.0;\n    off = floor(vec2(cos(a),sin(a)) * rad);\n    \n    idx = sprite16(ball_00, ball_10, ball_01, ball_11, uvs - off);\n    c = blend(c, pal_sh(idx, vec3(0,0.5,1)));\n    \n    //Yellow ball\n    idx = sprite8(ball_sm, uvs - 4.0);\n    c = blend(c, pal_sh(idx, vec3(1,1,0)));\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    uv = floor(uv / 2.0);\n    vec2 res = iResolution.xy / 2.0;\n      \n    vec4 back = background(uv, res);\n    vec4 spri = sprites(uv, res);\n    \n    vec4 c = mix(back, spri, spri.a);\n    \n\tfragColor = vec4(c);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}