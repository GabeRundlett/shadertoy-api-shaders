{
    "Shader": {
        "info": {
            "date": "1573161709",
            "description": "Codevember 2019",
            "flags": 0,
            "hasliked": 0,
            "id": "wdtXDl",
            "likes": 2,
            "name": "Codevember #7 - Mandelmonster",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "codevember"
            ],
            "usePreview": 0,
            "username": "desertsky",
            "viewed": 375
        },
        "renderpass": [
            {
                "code": "void pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\n// Formula for original MandelBulb from http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n// also see https://www.shadertoy.com/view/4tGXWd\nfloat MandelBulb(vec3 pos, const int limitIterations)\n{\n    const int Iterations = 12;\n    const float Bailout = 8.0;\n    float Power = 5.0 + cos(iTime*0.325);\n\n    vec3 z = pos;\n    float dr = 1.0;\n    float r = 0.0;\n    for (int i = 0; i < Iterations; i++)\n    {\n        r = length(z);\n        if (r > Bailout || i == limitIterations) break;   // TODO: test if better to continue loop and if() rather than break?\n\n        // convert to polar coordinates\n        float theta = acos(z.z/r);\n        float phi = atan(z.y,z.x);\n        dr = pow(r, Power-1.0)*Power*dr + iTime/10000.;\n\n        // scale and rotate the point\n        float zr = pow(r,Power);\n        theta = theta*Power;\n        phi = phi*Power;\n\n        // convert back to cartesian coordinates\n        z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z += pos;\n    }\n    return 0.5*log(r)*r/dr;\n}\n\nfloat map(vec3 p) \n{\n    \n    float planeDist = p.y;\npR(p.xy, -90.);  \n    pR(p.yz,iTime/7.4);\n    float mm= MandelBulb(p-vec3(-2.,-.5,-.3),13);\n\n    return (mm);\n}\n\n\nfloat RM(vec3 ro, vec3 rd) \n{\n    float t = 0.;\n\n    for (int i = 0; i < 100; i++) \n    {\n    \tvec3 pos = ro + rd * t;\n    \tfloat h = map(pos);\n        \n        if(h<.001) break;\n        \n        t+=h;\n        \n        if(t>40.0) {\n            t=-1.0;\n            break;\n        }\n  \n    }\n    \n    return t;\n}\n\nvec3 GetNormal(vec3 p) \n{\n\tvec2 e = vec2(.01,0);\n    float d = map(p);\n    \n    vec3 pointNormal = d- vec3(\n    \tmap(p-vec3(e.xyy)),\n        map(p-vec3(e.yxy)),\n        map(p-vec3(e.yyx))  \n    );\n    \n    return normalize(pointNormal);\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.,0.2*uv.y,0.2*uv.y+.3);\n\n    vec3 ro = vec3(1.3,1.7,-2.);\n    vec3 rd = normalize(vec3(uv,1.));\n    \n    float t = RM(ro,rd);\n    \n    if(t>0.0) \n    {\n\tcol = vec3(.2*sin(iTime*3.),.3*cos(iTime*4.)+uv.x,sin(iTime*3.));\n\n    vec3 pos = ro + t * rd;\n\tvec3 nor = GetNormal(pos);\n    vec3 sun_dir = normalize(vec3(2.5,2.,-1.5));\n    float sun_sha = step(RM(pos+nor*.001,sun_dir),0.);\n    float sun_dif = (clamp(dot(nor,sun_dir),.0,1.));\n    \n        \n    //shadows\n        \n    col+=vec3(.9)*sun_dif;\n    //col = mix(col,col*0.2,shadow);\n    }\n\n    \n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}