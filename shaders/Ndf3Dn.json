{
    "Shader": {
        "info": {
            "date": "1615755971",
            "description": "First 1024 base-4 digits of pi, computed using the Bailey–Borwein–Plouffe formula: [url]https://en.wikipedia.org/wiki/Bailey%E2%80%93Borwein%E2%80%93Plouffe_formula[/url] and using the code linked there from David H. Bailey,\n\nMouse changes perspective.",
            "flags": 32,
            "hasliked": 0,
            "id": "Ndf3Dn",
            "likes": 7,
            "name": "Digits of Pi",
            "published": 3,
            "tags": [
                "pi",
                "digits"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 472
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n// Digits of pi, in base 4. mla, 2021\n////////////////////////////////////////////////////////////////////////////////\n// A straight port of David H. Bailey's code at:\n// http://www.experimentalmath.info/bbp-codes/\n// Uses 32-bit floats which severely reduces the number of digits\n// that can be generated, but still good for up to 512 hex digits.\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  return p;\n}\n\nvec3 color(int i) {\n  if (i == 0) return vec3(1,0,0);\n  if (i == 1) return vec3(0,1,0);\n  if (i == 2) return vec3(0,0,1);\n  if (i == 3) return vec3(1,1,0);\n  return vec3(1,0,1);\n}\n\nvec3 image(vec2 uv ) {\n  uv = 0.5*(uv+1.0);\n  uv *= vec2(16,32);\n  int d = int(texelFetch(iChannel0,ivec2(uv),0).x);\n  vec3 col = fract(uv.x) > 0.5 ? color(d%4) : color(d/4);\n  uv.x *= 2.0;\n  uv = fract(uv);\n  uv = min(uv,1.0-uv);\n  col *= smoothstep(0.0,0.1,min(uv.x,uv.y));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 r = vec3((2.0*fragCoord-iResolution.xy)/iResolution.y,2);\n    r.y = -r.y;\n    vec3 p = vec3(0,0,-2);\n    p = transform(p);\n    r = transform(r);\n    r = normalize(r);\n    // (p+kr).z = 0 => kr.z = -p.z\n    float k = -p.z/r.z;\n    fragColor = vec4(0);\n    vec2 uv = p.xy+k*r.xy;\n    if (abs(uv.x) > 1.0) return;\n    if (abs(uv.y) > 1.0) return;\n    fragColor = vec4(image(uv),1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n// Digits of pi, in base 4. mla, 2021\n////////////////////////////////////////////////////////////////////////////////\n// A straight port of David H. Bailey's code at:\n// http://www.experimentalmath.info/bbp-codes/\n// Uses 32-bit floats which severely reduced the number of digits\n// that can be generated, but it's good for up to 512 hex digits.\n////////////////////////////////////////////////////////////////////////////////\n\nfloat tp[] = float[]( 1.0,2.0,4.0,8.0,16.0,32.0,64.0,128.0,256.0,512.0,1024.0 );\nconst int ntp = tp.length();\n\n/*  expm = 16^p mod ak.  This routine uses the left-to-right binary \n    exponentiation scheme. */\n\nfloat expm (float p, float ak) {\n  int i, j;\n  float p1, pt, r;\n  if (ak == 1.0) return 0.;\n\n  /*  Find the greatest power of two less than or equal to p. */\n  for (i = 0; i < ntp; i++) if (tp[i] > p) break;\n\n  pt = tp[i-1];\n  p1 = p;\n  r = 1.;\n\n  /*  Perform binary exponentiation algorithm modulo ak. */\n\n  for (j = 1; j <= i; j++){\n    if (p1 >= pt){\n      r = 16. * r;\n      r = r - floor(r / ak) * ak;\n      p1 = p1 - pt;\n    }\n    pt = 0.5 * pt;\n    if (pt >= 1.){\n      r = r * r;\n      r = r - floor(r / ak) * ak;\n    }\n  }\n\n  return r;\n}\n\nfloat series (int m, int id)\n\n/*  This routine evaluates the series  sum_k 16^(id-k)/(8*k+m) \n    using the modular exponentiation technique. */\n\n{\n  float ak, eps, p, s, t;\n  s = 0.;\n\n  /*  Sum the series up to id. */\n  for (int k = 0; k < id; k++){\n    ak = float(8 * k + m);\n    p = float(id - k);\n    t = expm (p, ak);\n    s = s + t / ak;\n    s = fract(s);\n  }\n\n  /*  Compute id term. */\n  ak = float(8 * id + m);\n  t = 1.0 / ak;\n  s = s + t;\n  s = fract(s);\n  return s;\n}\n\nint digit(int id) {\n  float s1 = series (1, id);\n  float s2 = series (4, id);\n  float s3 = series (5, id);\n  float s4 = series (6, id);\n  float pid = 4.0 * s1 - 2.0 * s2 - s3 - s4;\n  pid = fract(pid) + 1.0;\n  pid = abs(pid);\n  return int(16.0 * fract(pid));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  ivec2 ix = ivec2(fragCoord);\n  fragColor = texelFetch(iChannel0,ix,0);\n  if (ix.x >= 16 || ix.y >= 32) return;\n  if (iFrame != 0 && fragColor.a == iResolution.x) return;\n  int id = ix.x+ix.y*16;\n  int d = digit(id);\n  fragColor = vec4(d,0,0,iResolution.x);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}