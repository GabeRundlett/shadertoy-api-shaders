{
    "Shader": {
        "info": {
            "date": "1503598194",
            "description": "mouse.xy sets one point of a line +vec2(0)\nmouse.y also sets circle radius, you set 3 parameters with 2 domains.\nfrom that it calculates a tangential circle for a wedge.\nto improve on the *Round*() union functions of hg_sdf;\nand voronoi-borders...",
            "flags": 0,
            "hasliked": 0,
            "id": "4tfcz4",
            "likes": 18,
            "name": "rounded road railway wedge",
            "published": 3,
            "tags": [
                "round",
                "gradient",
                "road",
                "rounded",
                "tangent",
                "corner",
                "bend",
                "glyph",
                "bisymmetry",
                "wegde",
                "rails"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1194
        },
        "renderpass": [
            {
                "code": "//self: https://www.shadertoy.com/view/4tfcz4\n//2d bisymmetry rounded road corner wedge rounded inner 2\n\n/*\nReturn distance to 2 surfaces, at ny angle, with a rounded iner corner.\nRounded outer corners are easier, they have the circle center at vec2(0)\nThis wedge requires calculating a lineline intersection, if only for one offset.\n\nMouse.xy sets one point of a diagonal line +vec2(0)\nMouse.y also sets circle radius, you set 3 parameters with 2 domains.\n\nThe other line is horizontal, for simplicity.\nFrom that it calculates a tangential circle for a wedge.\n\nThis has many contexts/vriants that I may not have though of by now, \n...Therefore I leave it in a rather raw state.\nI want this to be used for better \"rounded voronoi corners\" as in \nhttps://www.shadertoy.com/view/lsSfz1\n\nIts main purpose is to improve on the *Round*() union functions of hg_sdf;\nThey are good fast upper bounds for 3d distance field marching, \nBut their gradients are not so good got 2d texturing:\n...\n//fOpUnionSoft() is better near 180deg angles, worse near 90deg angles.\nfloat fOpUnionSoft(float a,float b,float r){float e=max(r-abs(a-b),0.);return min(a,b)-e*e*.25/r;}\n//gets slanted, is bad neat 180deg, otherwise is VERY good.\nv0 mav(v1 a){return max(a.y,a.x);}\nv0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a) -maxv(-a)\nfloat fOpRoundMin(vec2 a,float r){return min(-r,mav(a))+length(max(r+a,0.));}\nfloat fOpRoundMax(vec2 a,float r){return -fOpRoundOr(-a,r);}\nfloat fOpRoundD(vec2 a,float r){return fOpRoundMin(vec2(a.x,-a.y),r);}\nfloat fOpRoundE(vec2 a,float r){return fOpRoundMin(vec2(-a.x,a.y),r);}\n#define fOpRoundMax(a,r) -fOpRoundOr(-a,r)\n#define fOpRoundD(a,r) fOpRoundMin(vec2(a.x,-a.y),r)\n#define fOpRoundE(a,r) fOpRoundMin(vec2(-a.x,a.y),r)\n//beware that these are good close to 90deg but rather bad near 180deg.\n//float fOpUnionRound(float a,float b,float r){vec2 u=max(vec2(r-a,r-b),0.);return max(r,min(a,b))-length(u);}\n//float fOpIntersectionRound(float a,float b,float r){vec2 u=max(vec2(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\n//float fOpDifferenceRound(float a,float b,float r){return fOpIntersectionRound(a,-b,r);}\n..\nSo i made this one:\nwhich has perfect gradients for 2 STRAIGHT intersecting lines, at any angle.\n*/\n\n/*\ntiny framework 2017-08 : https://www.shadertoy.com/view/MdSBDd\nI use \"bisymmetry\" as shorthand for \"gradient from symmetry to assymmetry\"\n*/\n\n/* end__.Head\n   start.Parameters\n*/\n\n//transform distance field to 2 rails\n#define Rails 1    \n//#define Rails 2  //Rails oscillate\n\n//show some construction lines and dots\n#define showStart\n\n//show the composed distance field\n#define showEnd\n\n//zoom of view Frame\n#define ViewZoom 8.\n\n//one extra step to round the gradient of a box.\n//#define RoundBox\n/*note how hg_sdf differnetiates this with 2 functions:\n//non-rounded border, underestimates distance\n  float fBoxCheap(vec3 p,vec3 b){vec3 q=(abs(p)-b);return max(max(q.x,q.y),q.z);}\n//rounded border exact distance  \nfloat fBox(vec3 p,vec3 b){vec3 q,d=abs(p)-b;q=min(d,0.);return length(max(d,0.))+max(max(q.x,q.y),q.z);}\n//where RoundBox uses;\nc.g=fBoxCheap();\n//...and an additional function that modifies fBoxCheap() into fBox();\nc.g+=.5*(sign(c.g)+1.)*(length(mStretchP(u,m.xy))-c.g)\n//yes, above line adds the EXACT amount of underestimated distance.\n// (which is neglible for most cases)\n// (for a  main-axis-aligned box)\n//and i got this via the \"bisymmetry principle\".\n*/\n\n/* end__.Parameters\n   start.Static\n*/\n//for WorkSafe <-> rather having a discontinuity near 0, than diving by /0\n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define u2(a) (a*2.-1.)\n#define u5(a) (a*.5+.5)\nv0 circleY(v1 u){return u.y-sqrt(1.-(u.x*u.x));}//i keep forgetting this one\nconst float tiny=1e-7;//smallest denormalNumber>0_16bit_float is pow(2,-24)\n\n/*\n//if(u==0.) return a, else return 0.;\nfloat ifu0b(float u,float a){return a*(1.-sign(u)*sign(u));}\nfloat ifu0b(vec2 u){return ifu0b(u.x,u.y);}\n//below ai and aiB function do return 0 for u==0 ! this defeats most of their purpose!\n//to make them return something else for u==0, you MUST add +=ifu0b(u.x,m.y) above\n//for WorkSafe <-> rather having a discontinuity near 0, than diving by /0\n//aiB() and ai() return \"almost identity\",\"0-skipping identity\":\n// https://iquilezles.org/articles/functions\n//to enfoce no divisions by /0 by smoothly skipping over y=f(u)=0\n//m.y= abs(minimum), never return anything smaller than abs(m.y)\n//exists in a general case where..\n//m.x= threshold.x (cubic only exists within <abs(m.x) )\n//[aifs] is optional constrain to general case; keeps sign of first drivative constant.\n#define aifs m.x=max(m.x,m.y*1.5)\n#define aif (2.*(m.y*(t-1.5)+m.x)-u)*t*t+m.y\nfloat aiB(float u,vec2 m){aifs;float t=u/m.x;if(u<m.x)return aif;return u;}\n//special case where m.y is minimal, and m.x becomes u.y for speed.\nfloat aiB(vec2 u){u.y=max(u.y,tiny);if(u.x<u.y*1.5){\n float a=u.y;u*=u*u;return a*(u.x/u.y/6.75+1.);}return u.x;}\nfloat aiB(float u,float a){return aiB(vec2(u,a));}\nfloat ai(float u,vec2 m){aifs;float t=u/m.x;return u+.5*(aif-u)*(1.-sign(u-m.x));}\n//special case where m.y is minimal, and m.x becomes u.y for speed.\n//is undefined for a=0. its trivial case AND purpose of this function\nfloat ai(float u,float a){a=max(a,tiny);float b=u/a;//... therefore a=max(a,tiny)\n return u+(.5*(u*(b*b/6.75-1.)+a))*(1.-sign(u-a*1.5));}\nfloat ai(vec2 u){return ai(u.x,u.y);}\nfloat ai(float u){float b=u/tiny;return u+(.5*(u*(b*b/6.75-1.)+tiny))*(1.-sign(u-tiny*1.5));}\n//use case examples:\n  //c.g=-ai(u.x,m.y)+u.y;if(u.x<0.)c.g=u.y-m.y;\n  c.r=-sign(u.x)*ai(abs(u.x),m.y)+u.y; \n  //c.r=-sign(u.x)*ai(abs(u.x),m.xy)+u.y;//show more general function\n  vec2 p=vec2(m.x,sign(m.x)*ai(abs(m.x),m.y));//uuse m.y to \"ride\" on the special case\n  p.y+=ifu0b(p.y,m.y);//making m.x case non-zero;\n  c.g=length(u-p)-.5;\n*/\n\n\n//almostIdentity\n#define if0(a) if(a==0.) a=tiny\n//Almost_Identity of: https://iquilezles.org/articles/functions\n\n//m.x= threshold.x (cubic [aic] only exists within <abs(m.x) )\n//m.y= abs(minimum), never return anything smaller than abs(m.y)\n//[aifs] is optional constraint; keeps sign of first drivative constant.\n#define aifs m.x=max(m.x,m.y*1.5)\n#define aifi aifs;float t=u/m.x\n#define aic (2.*(m.y*(t-1.5)+m.x)-u)*t*t+m.y\n//branching , with less mults\nfloat almostIdentityB(float u,vec2 m){aifi;if(u<m.x)return aic;return u;}\n//branchless, with less mults\nfloat almostIdentity(float u,vec2 m){aifi;return u+.5*(aic-u)*(1.-sign(u-m.x));}\n\n//set viewFrame for 2d modelling\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define u2(a) (a*2.-1.)\n#define u5(a) (a*.5+.5)\n#define dd(a) dot(a,a)\n//perpendicular dot() used for line intersections.\n#define dotp(a,b) dot(vec2(-a.y,a.x),b)\nv0 miv(v1 a){return min(a.y,a.x);}//return max domain of vector.\nv0 miv(v2 a){return min(a.z,miv(a.xy));}\nv0 miv(v3 a){return min(miv(a.zw),miv(a.xy));}\n#define mav(a) -miv(-a)\n//making a triangle wave;\n#define fr(a) fract(a)\n#define ss2t(a) a=abs(a*2.-1.)\n//mirror p at half rotated axis == cheap SINGLE 2d rotation.\n#define rs(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n#define sat(a) clamp(a,0.,1.)\n//a generalization of clamp(a,0.,1.); for m=vec2(1)\nv0 sat2(v0 a,v1 m){a=.5*(sign(a)+m.x)*a+m.y;a=(sign(2.-a)+1.)*(a-2.)+2.;return a*.5;}\n//return distance of [u] from segment, from [a] to [b]\nv0 segment(v1 p,v1 a,v1 b){p-=a;b-=a;return length(p-b*sat(dot(p,b)/dd(b)));}\n#define grid(u) mav(abs(u2(fr(u))))\n//#define mStretch(c,m) v=mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch      ; centric, most commonly used, therefore atomic\n#define mStretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus; positive values do not change\n#define mStretchM(u,m) mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u= u+m;return  mStretch(u,m);}\n//stretch plus ; negative values do not change\n#define mStretchP(u,m) mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m) mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n\n//float circleY(vec2 u){return u.y-sqrt(1.-(u.x*u.x));}//i keep forgetting this one.\n\n//these branchless comparators compare [c] with [0.0] to return [a]==true or [b]==false;\n//based on \n//  https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n//(c> 0)?a:b\n#define greater(a,b,c)   mix(a,b,step(c,0.))\n//(c< 0)?a:b\n#define less(a,b,c)      mix(a,b,step(0.,c))\n//(c==0)?a:b\n#define equals(a,b,c)    mix(b,a,step(c,0.)+step(0.,c)-1.)\n//----------- mirror symmetry mirror == swap outputs--------------------\n//(c!=0)?a:b\n#define unequal(a,b,c)   mix(a,b,step(c,0.)+step(0.,c)-1.)\n//(a>=0)?a:b   \"unless   \"=not less   ==greater OR equal\n#define unless(a,b,c)    mix(b,a,step(0.,c))\n//(c<=0)?a:b   \"ungreater\"=not greater==less    OR equal\n#define ungreater(a,b,c) mix(b,a,step(c,0.))\n\n/* end__.Static\n   start.Implicit\n*/\n\n\n//fast good monochrome distance field visualization.\n//blue is grid, red and green are distance fields\nv2 rg(v2 c,v1 u){v0 fsaa=1./min(iResolution.x,iResolution.y);\n return vec3(c.rg=mix(fract(c.rg*4.),smoothstep(fsaa,-fsaa,c.rg),\n  .5+(atan(c.rg))/acos(-1.)),grid(u));}\n//return intersection from line (a b) and line (c d).\nvec2 gLLxX( vec2 A, vec2 B, vec2 C, vec2 D ){\n vec2 b=B-A,d=D-C,c=C-A;\n float dotperp=b.x*d.y-b.y*d.x;\n if0(dotperp);\n float t=(c.x*d.y-c.y*d.x)/dotperp;\n return vec2 (A.x+t*b.x, A.y+t*b.y);}//second life wiki geometry\n\n//rectangle from v1(0) to v1(m)\nv0 rect(v1 u,v3 m){return mav(abs(u*2.-m.xy)-m.xy)*.5;}\n//for a \"class\" of ring/arc shapes.\nv1 arc(v1 u,v3 m){return v1(m.x-abs(m.y),dd(u));}\n /**/\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n v1 u=fra(U);\n v2 c=v2(0);\n v3 m=v3(fra(iMouse.xy),fra(iMouse.zw));\n if(iMouse.z<=.0)m.xy=3.*vec2(cos(iTime),sin(iTime*.61));\n //m.xy=abs(m.xy);//mouse is always positive.\n  \n /*main*/\n\n vec2 a=vec2(1,0);\n c.r=segment(u,a*6.,-a*6.)-.1;\n c.r=min(c.r,segment(u,m.xy*6.,-m.xy*6.)-.1);\n    \n \n float ang=acos(dot((a),normalize(m.xy)));\n ang*=sign(m.y);//signed angle \n a*=rs(ang*.5);\n vec4 hor=vec4(m.xy,m.x-1.,m.y);\n vec2 i=gLLxX(hor.xy,hor.zw,vec2(0),a);//line line intersection\n vec2 tang=normalize(m.xy)*i.x;//the other circle tangent touching point\n #ifdef showStart\n  c.r=min(c.r,segment(u,a*6.,-a*6.)-.1);//half angle line\n  c.r=min(c.r,abs(u.y-m.y)-.1);//horizontal line for intersection\n  c.r=min(c.r,abs(length(u-i)-abs(m.y))-.1);//circle ring\n  //c.g=min(c.g,length(u-i)-abs(m.y));//circle filled in\n  c.r=min(c.r,length(u-tang       )-.2);//tangent point diagonal/left\n  c.r=min(c.r,length(u-vec2(i.x,0))-.2);//tangent point horizontal\n #endif\n //above shows geometry construction.\n //below uses these points to construct a distance field.\n #ifdef showEnd\n  vec2 it=i-tang;\n  //c.r=min(c.r,length(u-it)-.2); //[tangent point diagonal/left +i] \n  //if(ba)c.r=segment(u,m.xy*6.,-m.xy*6.)-.1;\n    \n  //This can possibly be optimized in many ways, \n  //but that depends on context, so i leave it at its initial state...\n  float j=it.y/it.x;\n  bool ba=(((u.x-tang.x)*j-u.y+tang.y)*sign(m.y)>0.);//segmenting booleans:\n  bool bb=(u.x<i.x);//ba and bb return the side of u,relative to self=segmenting_line.\n  //these 2 segmenting lines go trough the circle-center \n  //and one of each tangent-touch-point (small brown dots)\n  if(m.y!=0.){//non-trivial case:\n   if(ba&&bb)c.g=abs(m.y)-length(u-i);//flip any sign in this line to see the segments\n   else c.g=min(u.y*sign(m.y),dotp(u,normalize(tang))*sign(m.y));\n   c.g*=sign(m.y);\n  }else c.g=u.y;//VERY trivial case sadly is not included in the non-trivial case.\n    \n  #if Rails>0\n   #if Rails>1\n    c.g+=cos(sin(iTime*2.))*3.-2.3;\n   #endif\n   c.g=abs(abs(c.g)-.6)-.1;\n   //the circle center must be outside of the rails, or they cease to be round.\n  #endif\n #endif\n    \n \n \n /*O*/\n c=rg(c,u);//show as gradient\n c.b=c.b*4.-3.;//scale grid gradient\n c*=mat3(.5,.1,.0,\n         .2,.7,.0,\n         .3,.2,.9);//sprinkling a little bulue into red and green, making them browner\n //this is better for color-blindness?\n return c;}\n \n//#define mainImage(O,U)O=vec4(c(U),1);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfragColor=vec4(c(fragCoord),1)\n//    fragColor = vec4(0.0,0.0,1.0,1.0);\n;}\n\n/* end__.Main\n   start.Tail\n*/\n/*\nthe BISYMETRY PRINCIPLE: v3\n- In a quest to increase symmetry for performance and modular shaders. (in contextual biases)\n- - utilize  https://en.wikipedia.org/wiki/List_of_planar_symmetry_groups\n- - utilize linear-algebra-deformed mirror borders that define branches.\n- - Only write atomic special cases and transformations, \n- - ...to construct general functions from.\n- - Instead of writing a general function, \n- - ...to be fed with a lot of parameters set to 0 or 1 to turn them into \"special cases\"\n- - this way general functions can be made into special \"shortcut\" functions more easily.\n- - this way special functions can more easily be extended, generalized.\n...\n- it appears the \"ideal bisymmetrically optimized function looks something like this:\nfloat demo(vec2 u,vec4 m){//u= uv fragment position; m=iMouse.xyzw both likely transformed\n u.x=abs(u.x-1.); u.y=-u.y*.5; //symmetry modifiers are likely \"outsourced\"\n float a=sign(m.x-1.)+1.;\n float b=sign(m.y+1.)+u.x;\n float c=sign(m.z+m.x)-m.y;\n float c=-sign(m.z-u.x);\n //above are all sign-factors, below is the final binomial, both rarely are shared subroutines.\n return u.x*(a+b)*(c+2.)*d*0.5-u.y//the *.5 and -u-y can likely be \"outsourced\"\n}\n- how you transform binomials and branches depends on the bias from your context.\n- in general, it makes sense to delay sqrt() or length() as much as possible.\n- ... while also keeping brnches that are shortcuts \n- ... eg: usually abs(length()) begs to be a shortcut.\n...\n- this whole PRINCIPLE screams FRACTAL and SUPERPRIM ! \n- - https://www.shadertoy.com/results?query=superprim\n- this PRINCIPLE more easily delays sqrt() or length() till the end of a function, \"outsource\"able\n\nHOW TO\n- rearrange your branches so that sqrt() or length() is delayed as much as possible.\n- abs(length()) can not be delayed, therefore it may as well be treated as a shortcut.\n- ... meaning, if(your shape contains abs(length())) that branch stays as if() branch!\n- all other brahcnes usually end up being equally omplex trees of equally complex branches.\n- in that case, an openCL coders eyes open to reveal how to make long pipelines:\n- Substitute functions with identities to reveal their underlying bisymmetries.\n- - substitute max() to if()then() to mix(step)) to mix(sign()) to sums of sign()\n- - - for details on identities see - https://www.shadertoy.com/view/ldBfzc\n- - because there is often a lot of symmetry performance \"lost\" in if-branches, or max()=-min(-)\n- End up precalculating the specifics of a function, \n- Get a sum that you can easily modify \n- transform the sum into binominals of precalculated variabls, that make sense in the context.\n- - this is \"ultimate code golf\", as the best soluion depends on the functions context.\n- Modify underliing partial simple bisymmetries of the functions \"specifics\"\n- Bisymmetry turns out to be mostly about (mutually exclusive matrices of) Binimials.\n...\n- Using only fullRotation*N/24 , makes it more likely that terms cancel each other out.\n- if (symmetry) 2 symmetric subroutine-values tend to cancel factors out, \n- ... down to sign(a)*sign(a)=1.\n- Your function(s) turns into a \"family of bisymmetrical functions\" \n- ... that are more easily generalized or specialized.\n- ... that are more easily made work-save against undefineds like: \n- ... a=atan(0.,0.)*tan(acos(.0))*log2(0.)*pow(0,0)*a/0.\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}