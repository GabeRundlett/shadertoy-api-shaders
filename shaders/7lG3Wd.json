{
    "Shader": {
        "info": {
            "date": "1638519009",
            "description": "more in comments",
            "flags": 0,
            "hasliked": 0,
            "id": "7lG3Wd",
            "likes": 14,
            "name": "Voronoi Ubung #5",
            "published": 3,
            "tags": [
                "voronoi"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 363
        },
        "renderpass": [
            {
                "code": "/* \nThis Voronoi Shader is based on:\n\n1. An article by IQ: \n    https://iquilezles.org/articles/voronoilines\n2. tomkh's drawing helped it click: \n    https://www.shadertoy.com/view/llG3zy\n3.Shane's Rounded border shader:\n    https://www.shadertoy.com/view/ll3GRM\n*/\n\n\n#define pi acos(-1.)\n#define eps 8./iResolution.y\n\n#define maxPoints 16.\n#define screenSize 4.\n\n#define bg (0.5+0.5*sin(vec3(iTime,iTime*3.+403.,iTime*1.3+902.)))\n#define fg (0.5+0.5*sin(vec3(-iTime*2.1,-iTime*0.9+403.,-iTime+902.)))\n\nvec2 rnd2(vec2 id){\n    return vec2(fract(sin(dot(id,vec2(14.27,74.97)))*54329.34),\n           fract(sin(dot(id+912.35,vec2(49.27,102.74)))*54329.34));\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin2(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\nfloat point(vec2 uv, float r){\n    return smoothstep(r+eps,r-eps,length(uv));\n}\n\nfloat ring(vec2 uv, float r){\n    return smoothstep(eps+0.03, 0., abs(length(uv)-r+0.03));\n}\n\nfloat line(vec2 P, vec2 A, vec2 B, float r){\n    vec2 PA = P-A;\n    vec2 AB = B-A;\n    //dot(AB,P-P3) = 0\n    //dot(AB,P-AB*t)\n    float t = clamp(dot(PA,AB)/dot(AB,AB),0.,1.);\n    return smoothstep(r+eps,r-eps,length(PA-AB*t));\n   \n}\n\n//we are in \"not world/object space\" \n//because we use length on vectors from vec2(0,0.)\n//to get distances\nvec4 voronoi(vec2 uv){\n\n    vec2 st = fract(uv);\n    vec2 stFL = floor(uv);\n    vec2 d = vec2(10.);\n    vec2 A, B=vec2(100.);\n    \n    vec2 mind;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(c < d.x){\n            d.x = c;\n            d.y = rnd2(stFL+id).y;\n            A = coords;\n            }\n        }\n    }\n    mind = d;\n    \n    d = vec2(10.);\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(length(A-coords) > 0.00){\n            //d.x = c;\n            //d.y = rnd2(stFL+id).y;\n            B.x = smin2(B.x, dot( 0.5*(A+coords), \n                       normalize(coords-A) ), 0.2 );\n            }\n        }\n    }\n    B.y = B.x;\n    return vec4(mind,smoothstep(0.,1.,0.5+0.35*(sin(pow(max(B.x*32.,0.9)-.2,1./2.)))\n    ),B.y);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    vec3 light = vec3(1.,0.,2.);\n    vec3 ldir = normalize(vec3(0.)-light);\n    \n    vec3 light2 = vec3(2.,1.,1.);\n    vec3 ldir2 = normalize(vec3(0.)-light2);\n    \n    // Time varying pixel color\n    //vec3(0.1,1.4,2.)\n    uv*=3.;\n    uv.x+=iTime;\n    vec4 voronoXY = voronoi(uv);\n    //float edges = smoothstep(0.00,0.01,abs(voronoXY.x-voronoXY.z));\n    //vec3 col = 0.5+0.5*sin(vec3(1., 2., 3.)/1.2+ voronoXY.y*pi*200.);\n    vec3 col = 0.5+0.5*sin(vec3(0., 2., 3.)/1.2+ voronoXY.y*pi*20.);\n    col.zy *= rot(.1);\n    \n   // col = mix(col, vec3(voronoXY.y,0., voronoXY.y)/4., smoothstep(0.08,0.05,voronoXY.x));\n  //  col += sin(voronoXY.x*40.);\n    //col += vec3(fract(voronoXY.x*8.));\n    //col = mix(col, vec3(0.), smoothstep(0.14,0.13,voronoXY.z));\n   //col = mix(col, vec3(1.), smoothstep(0.05,0.,voronoXY.z));\n   // col -= sin(voronoXY.z*90.)/10.;\n    //col = mix(col, vec3(0.), 1.-smoothstep(0.5,0.4,voronoXY.x*1.));\n    col = mix(col, vec3(.9,0.6,0.0), smoothstep(0.3,.5,voronoXY.z)*0.3 );\n    // Output to screen\n    \n    vec3 n = vec3(\n                  voronoi(uv-vec2(eps,0.)).x-voronoi(uv+vec2(eps,0.)).x,\n                  voronoi(uv-vec2(eps,0.).yx).x-voronoi(uv+vec2(eps,0.).yx).x,\n                  voronoi(uv-vec2(eps,0.)).z\n                  -voronoi(uv+vec2(eps,0.).yy).z\n                  );\n         n = normalize(n);//smoothstep(vec3(-1.),vec3(1.),;\n         \n    float diff = max(dot(ldir,n),0.);\n    \n    float spec = pow( max(\n                 dot( reflect(-ldir,n),vec3(0.,0.,1.)),0.),5.);\n    col += diff*0.6+vec3(0.9,0.5,0.1)*spec;\n    \n    \n    \n    float diff2 = max(dot(ldir,n),0.);\n    \n    float spec2 = pow( max(\n                 dot( reflect(-ldir2,n),vec3(0.,0.,1.)),0.),5.);\n    col += diff2*0.8+vec3(0.1,0.5,0.9)*spec2;\n    \n \n    col = mix(col, vec3(0.), smoothstep(0.04,0.025,voronoXY.w));\n    col = mix(col, vec3(1.,0.4,0.)/4., smoothstep(0.04,0.0,voronoXY.w));\n    col += smoothstep(0.05,0.03,voronoXY.w)*(0.5+0.5*sin(voronoXY.w*10.))/1.5;\n    \n    col /= 1.5;\n    col= pow(col, vec3(1.4));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}