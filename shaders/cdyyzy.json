{
    "Shader": {
        "info": {
            "date": "1697620597",
            "description": "I made this spheremapping function to map a 2D texture onto a sphere without edges and even pixel density using only 2 texture sampels. This uses the SDF of a tennis ball to merge the two samples.",
            "flags": 0,
            "hasliked": 0,
            "id": "cdyyzy",
            "likes": 7,
            "name": "Tennis ball mapping",
            "published": 3,
            "tags": [
                "3d",
                "uv",
                "sphere",
                "normal",
                "mapping",
                "seamless",
                "seamless",
                "tennis",
                "spheremap",
                "tennisball",
                "tbn"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 236
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nI created this algorithm to seamlessly tile a texture over a sphere \nwith little distortions and no edges. It uses only 2 texture lookups.\n\nThis works by having 2 spheremappings. One is rotated so the edges of the \nspheremapping do not meet. I created a mask the blend between the edges\nthat has the same pattern as a tennisball. This mapping includes normals \ntoo. The blend region is currently hidden by the glue-line, but you can \nmake it visible by enabling SHOWBLEND. \n\nThere are several global constants below to enable debug views of the\nmapping and mouse controls to look around.\n\nSee also my demo for tangent space matrix of spheremaps:\nhttps://www.shadertoy.com/view/ctXfDS\n*/\n\n// enables debug grid where the two mappings blend with each other\n// Green and Red are the upper and lower bounds of the weights\n// Blue and White is the edge where one tiling breaks\n//#define SHOWBLEND\n#define LINETHICKNESS 0.02\n\n// 1 no contrast, higher values increase contrast\n#define CONTRAST 16.0\n\n// enable to show the alpha/weights otherwise shows textures\n//#define SHOWALPHA\n\n// Signed distance function of a tennis ball, the glueline would be at 0.5\n#define TWO_OVER_PI 0.6366197724 // 2. / PI\nfloat tennisballSDF (vec3 normal) {   \n    // Prevent floating point errors\n    normal = clamp(normal, -1., 1.);\n    \n    // combine halfs of SDF\n    float tennisballSDF;\n    if (normal.x > 0.) {\n        // poles\n        tennisballSDF = 1.- acos(abs(normal.z)) * TWO_OVER_PI; \n    } else {\n        // seam of the edge between poles\n        tennisballSDF = acos(abs(normal.y)) * TWO_OVER_PI; \n    }\n    return tennisballSDF;    \n}\n\n//Spherical mapping\nvec2 sphereMap(vec3 normal) {\n    // merkator projection\n    float u = 0.5 + atan(normal.y, normal.x) / (2.*3.1415);\n    float v = 0.5 + asin(normal.z) / 3.1415;\n    return vec2(u, v);\n}\n\n// TBN Matrix for the spheremapping above\nmat3 sphereTBNMatrix(vec3 normal) {\n    // vec3 poleAxis = vec3(0,0,1.);\n    // vec3 tangent = normalize(cross(poleAxis, normal));\n    vec3 tangent = safeNormalize(vec3(-normal.y, normal.x, 0.), vec3(1,0,0));\n    vec3 bitangent = cross(normal, tangent);\n    return mat3(tangent, bitangent, normal);\n}\n\n// simple spheremap texture sampler\nmaterialVal sphereMapSample(sampler2D tex, vec3 normal, float scale) {\n    // sample spheremap\n    vec2 uv = sphereMap(normal);\n    \n    // so UVs are ~equal scale, as X is circumfrence, but Y is only half\n    uv.x *= 2.; \n    \n    // apply scale\n    uv *= scale;    \n    \n    // sample tbn matrix\n    mat3 tbn = sphereTBNMatrix(normal);  \n    \n    // sample texture, since we hide the seam we can ignore mips\n    vec3 color = texture(tex, uv).xyz;\n\n    // sample normal, if you can obviously use a normal texture instead\n    vec3 tsNormal = HeightToNormal(tex, uv, iChannelResolution[0].xy, 4.0);\n    // translate normals to world space\n    vec3 wsNormal = tbn * tsNormal;\n\n    // pack everything into a struct\n    return materialVal(color, wsNormal, 0.);\n}\n\nmaterialVal tennisballmap(sampler2D tex, vec3 normal, float scale, float contrast) {    \n    // rotated spheremap to align with tennisball other side\n    vec3 rotatedNormal = vec3(-normal.x, normal.z, normal.y); \n\n    // sample textures\n    materialVal sphereA = sphereMapSample(tex, normal, scale);\n    materialVal sphereB = sphereMapSample(tex, rotatedNormal, scale);\n\n    // sample blend weight\n    float alpha = tennisballSDF(normal);\n    \n    // increase contrast of tennisball mask\n    float contrastAlpha = straightContrast(alpha, contrast);\n\n    #ifdef SHOWALPHA\n        // show alpha/weights with best colormap for better readability\n        vec3 col = viridis(contrastAlpha);\n    #else    \n        // interpolate between mappings to remove edges and poles\n        vec3 col = mix(sphereA.color, sphereB.color, contrastAlpha);\n    #endif\n        \n    // since sphere B is rotated its normals need to be rotated as well\n    vec3 wsNormalB = vec3(-sphereB.normal.x, sphereB.normal.z, sphereB.normal.y);\n    \n    // interpolate normals, Slerp may be better, but I can't tell the differene\n    vec3 wsNormal = normalize(mix(sphereA.normal, wsNormalB, contrastAlpha));\n    \n    #ifdef SHOWBLEND\n        // overlaying the edges of the alpha mask\n        vec2 blend = step(abs(vec2(contrastAlpha, 1.-contrastAlpha)-0.1), vec2(LINETHICKNESS));\n\n        // edge of the mappings\n        float edgeA = step(alpha, LINETHICKNESS);;\n        float edgeB = step(tennisballSDF(rotatedNormal), LINETHICKNESS);\n\n        // join color\n        col = max(max(col, vec3(blend, edgeA)), vec3(edgeB));\n    #endif\n    \n    // pack everything into a struct\n    return materialVal(col, wsNormal, alpha);\n}\n\n// samples tennisball textures and applies tennis ball colors\nmaterialVal tennisball(sampler2D tex, vec3 normal, float scale, float contrast) {\n    // sample textures\n    materialVal ball = tennisballmap(tex, normal, scale, contrast);\n   \n    // center the mask on the line at 0.5\n    float line = abs(ball.mask-0.5)*2.;\n    \n    // calculate a little dark line around the glue edge\n    float glueWidth = 0.08;\n    float tintWidth = 0.04;\n    float tint = smoothstep(glueWidth + tintWidth, glueWidth - tintWidth, line);\n    \n    // define ball colors\n    vec3 glueColor = vec3(0.824,0.827,0.749) * tint;\n    vec3 feltColor = vec3(0.937,0.953,0.086) - (ball.color * 0.5);\n    \n    // caluclate smoothstep for weight between glue and felt\n    float stepWidth = 0.02;\n    float alpha = smoothstep(glueWidth - stepWidth,glueWidth + stepWidth, line);\n    \n    // blend colors\n    vec3 color = mix(glueColor, feltColor, alpha);\n    \n    // interpolate normals, Slerp may be better, but I can't tell the differene\n    vec3 wsNormal = normalize(mix(normal, ball.normal, alpha));\n    \n    return materialVal(color, wsNormal, ball.mask);\n}\n\n// _____________________________3D Section_____________________________\n// https://www.shadertoy.com/view/4sjXW1 by nimitz (twitter: @stormoid)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nvec2 iSphere(in vec3 ro, in vec3 rd) {\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    //if(h <0.0) return vec2(-1.);\n    return vec2(-b - sqrt(h), h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n\tum.x *= iResolution.x/iResolution.y;\n    p*= 1.5;\n\t\n    //camera\n\tvec3 ro = vec3(0.,0.,2.4);\n    vec3 rd = normalize(vec3(p,-1.5));\n    mat2 mx;\n    mat2 my;\n    vec2 cursor;\n    if(iMouse.x > 0.0)\t{    \n        mx = mm2(um.x*5.);\n        my = mm2(um.y*5.);\n        \n                // scale mouse coords to 0-1 range of screen\n        vec2 mouse = iMouse.xy / iResolution.y;\n        vec2 coords = fragCoord / iResolution.y;\n        \n        // Generate Mouse coursor, x = mouse color, y = mouse weight \n        float mouseSize = 0.02;\n        float mouseDist = length(coords - mouse); \n        float aa = fwidth(mouseDist); // cheap anti-aliasing factor\n        cursor.x = smoothstep(mouseSize*0.5 + aa, mouseSize*0.5 - aa, mouseDist);\n        cursor.y = smoothstep(mouseSize + aa, mouseSize - aa, mouseDist);\n        \n    } else {\n        mx = mm2(-iTime*.5+um.x*5.);\n        my = mm2(iTime*0.2+um.y*5.);\n    }\n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    vec2 t = iSphere(ro,rd);\n    \n    vec3 lightDir = normalize(vec3(1,0,1));\n  \n    // alternate between backgroudn and sphere mapping\n    vec3 colorA;\n    if (t.x > 0.) {\n        // Sphere mapping\n    \tvec3 normal = ro+rd*t.x;\n                \n        #if defined(SHOWBLEND) || defined(SHOWALPHA)\n            // sample albedo textures\n            materialVal cube = tennisballmap(iChannel0, normal, 5., CONTRAST);\n        \n            colorA = cube.color;\n        #else\n            // sample albedo textures\n            materialVal cube = tennisball(iChannel0, normal, 5., CONTRAST);\n            \n            // Apply lighting to show the normals too\n            colorA = phongLighting(cube.color, cube.normal, ro, lightDir);\n        #endif\n        \n    } \n    \n    // Background mapping\n    vec3 normal = rd;\n\n    // make tennisball sdf\n    float alpha = tennisballSDF(normal);\n\n    // increase contrast a bit\n    alpha = straightContrast(1.-alpha, 1.5);\n\n    // apply best colormap\n    vec3 albedo = viridis(alpha);\n    \n    #if defined(SHOWBLEND) || defined(SHOWALPHA)\n        // make color a bit darker for better contrast with sphere\n        vec3 colorB = pow(albedo, vec3(1.5));\n        \n    #else\n        // simple sun with halo\n        vec3 sun = sun(normal, lightDir);\n\n        // combine albedo and sunlight\n        vec3 colorB  = albedo + sun;\n    #endif\n    \n    // Smooth blending of ball with background\n    vec3 color = mix(colorA, colorB, smoothstep(0.02, 0.0, t.y));\n    \n    // Add mouse cursor\n    color = mix(color, vec3(cursor.x), cursor.y);\n    \n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "//_________________________GENERIC FUNCTIONS_____________________________________\n#define SUN_COLOR vec3(0.894,0.702,1.000)\n\n// Struct to hold material values\nstruct materialVal {\n    vec3 color;\n    vec3 normal;\n    float mask;\n};\n\n// Phong lighting model\nvec3 phongLighting(vec3 albedo, vec3 normal, vec3 cameraDir, vec3 lightDir) {\n    // Ambient\n    float ambientStrength = 0.35;\n    vec3 ambient = ambientStrength * albedo;\n\n    // Diffuse \n    float diff = clamp(dot(normal, lightDir), 0.0, 1.0);\n    vec3 diffuse = diff * albedo;\n\n    // Specular\n    float specularStrength = 1.5;\n    vec3 viewDir = normalize(cameraDir);\n    vec3 reflectDir = reflect(-lightDir, normal);  \n    float spec = pow(clamp(dot(viewDir, reflectDir), 0.0, 1.0), 16.0);\n    vec3 specular = specularStrength * spec * SUN_COLOR;  \n\n    // Combine results\n    return ambient + diffuse + specular;\n}\n\n// This function creates a simple sun with a halo effect.\n#define ONE_OVER_PI 0.3183098861836\nvec3 sun(vec3 normal, vec3 lightDir) {\n    // Compute the dot product of the normal and light direction.\n    float NdotL = dot(normal, lightDir);\n    \n    // Prevent Nan errors with fron acos\n    NdotL = clamp(NdotL, -1., 1.);\n    \n    // Compute the angle between the normal and light direction.\n    float angle = acos(NdotL) * ONE_OVER_PI;\n\n    // Compute an intensity based on the angle.\n    float intensity = pow(1.0 - angle, 50.0) * 3.0;\n\n    // Generate a color based on the intensity and the sun's color.\n    return intensity * SUN_COLOR;\n}\n\n// Linearly increases contrast of Alpha\n// See: https://www.desmos.com/calculator/hs1nsjb32q\nfloat straightContrast(float alpha, float contrast) {\n    return clamp(contrast * (alpha - 0.5) + 0.5, 0., 1.);\n}\n\n// makes viridis colormap with polynimal 6\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// Safe Normalization avoiding division by zero with alternate\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec3 safeNormalize(vec3 vector, vec3 alternate) {\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(vector, vector);\n    \n    // Check if the squared length is greater than a tiny threshold\n    if (lenSq > SMALLESTFLOAT) {\n        // If so, normalize the vector resuing the squared length\n        return vector / sqrt(lenSq);\n        \n    } else {\n        // Otherwise, return a alternate vector\n        return alternate;\n    }\n}\n\n// Function for generating normals using 3 texture samples.\n// Original source: https://www.shadertoy.com/view/3sSSW1\nvec3 HeightToNormal(sampler2D tex, vec2 uv, vec2 res, float strength) {\n    vec2 s = 1.0 / res;\n    \n    float textureOffset = 1.0;\n    \n    float p = texture(tex, uv).x;\n    float h1 = texture(tex, uv + s * vec2(textureOffset,0)).x;\n    float v1 = texture(tex, uv + s * vec2(0,textureOffset)).x;\n       \n   \tvec2 xy = (p - vec2(h1, v1));\n    \n    return safeNormalize(vec3(xy * strength, 1.0), vec3(0,0,1));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}