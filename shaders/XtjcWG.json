{
    "Shader": {
        "info": {
            "date": "1509989057",
            "description": "shape generalization from [url]https://www.shadertoy.com/view/lljSDy[/url].\nSee also the tri-tree version [url]https://www.shadertoy.com/view/Mt2XDc[/url],\nbinary-tree version [url]https://www.shadertoy.com/view/MtlyRH[/url].\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XtjcWG",
            "likes": 11,
            "name": "quadtree 6 - \"any\" shape",
            "published": 3,
            "tags": [
                "short",
                "quadtree"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 679
        },
        "renderpass": [
            {
                "code": "// shape generalization from https://www.shadertoy.com/view/lljSDy\n// NB: the distance-to-shape evaluated at tile center is quite naive and easy to break.\n// try #if 0  ( but too conservative )\n\nfloat shape(vec2 P, float r) {\n    switch( int(iTime)%5 ) {\n      case 0: return length(P)/r - 1.;                                    // disk\n      case 1: P = abs(P); return max(P.x,P.y)/r - 1.;                     // square\n      case 2: P = abs(P*mat2(1,-1,1,1)/1.4); return max(P.x,P.y)/r - 1.;  // diamond\n      case 3: return length(P)/r + .1*sin(10.*atan(P.y,P.x)) -1.;         // gear\n      case 4: return length(P)/r - cos(3.14/3.)/cos(mod(atan(P.y,P.x)-iTime,6.28/3.)-3.14/3.); // triangle\n      case -1: return length(P)/r + .3*sin(10.*atan(P.y,P.x)) -1.;         // gear 2\n    }\n}\n\nvoid mainImage( out vec4 o,  vec2 U )\n{\n    o -= o;\n    float r=.1, t=iTime, H = iResolution.y;\n    U /=  H;                              // object : disc(P,r)\n    vec2 P = .5+.5*vec2(cos(t),sin(t*.7)), fU;  \n    U*=.5; P*=.5;                         // unzoom for the whole domain falls within [0,1]^n\n    \n    o.b = .25;                            // backgroud = cold blue\n    \n    for (int i=0; i<7; i++) {             // to the infinity, and beyond ! :-)\n        fU = min(U,1.-U); if (min(fU.x,fU.y) < 3.*r/H) { o--; break; } // cell border\n#if 1\n        if (shape(P-.5, r) > .7/r) break; // cell is out of the shape (eval at tile center)\n#else\n        if (min( min(shape(P          ,r), shape(P-vec2(1,0),r)),\n                 min(shape(P-vec2(0,1),r), shape(P-vec2(1,1),r))\n                )  > .7/r) break;         // cell is out of the shape (eval at tile corners)\n#endif\n                // --- iterate to child cell\n        fU = step(.5,U);                  // select child\n        U = 2.*U - fU;                    // go to new local frame\n        P = 2.*P - fU;  r *= 2.;\n        \n        o += .13;                         // getting closer, getting hotter\n    }\n               \n\to.gb *= smoothstep(-.1,.0,shape(P-U,r)); // draw object\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}