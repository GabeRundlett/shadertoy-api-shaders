{
    "Shader": {
        "info": {
            "date": "1662614406",
            "description": "analytic ray tracing rather than SDF-based raymarching.",
            "flags": 32,
            "hasliked": 0,
            "id": "slcfzr",
            "likes": 17,
            "name": "ray tracing refraction",
            "published": 3,
            "tags": [
                "refraction",
                "ice",
                "fresnel",
                "schlick",
                "queue"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 359
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 RGBA, in vec2 XY) {\n\n    ivec2 IJ = ivec2(XY);\n    \n    RGBA.r = texelFetch(iChannel0, IJ, 0).r;\n    RGBA.g = texelFetch(iChannel1, IJ, 0).g;\n    RGBA.b = texelFetch(iChannel2, IJ, 0).b;\n    \n    RGBA.a = 1.0;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nconst vec3  v0 = vec3(0.0);\nconst vec3  v1 = vec3(1.0);\nconst vec3  vX = vec3(1.0, 0.0, 0.0);\nconst vec3  vY = vec3(0.0, 1.0, 0.0);\nconst vec3  vZ = vec3(0.0, 0.0, 1.0);\nconst float pi = 3.14159265359;\n\n\n//--------------------------------------------------------------------------------\nconst float ior_air     = 1.0003;\nconst float ior_aerogel = 1.03;\nconst float ior_ice     = 1.309;\nconst float ior_water   = 1.333;\nconst float ior_quartz  = 1.46;\nconst float ior_diamond = 2.42;\nconst float ior_shiny1  = 2.756;    // ad hoc\nconst float ior_mirror1 = 7.0;      // ad hoc\n\n// wavelengths in nm\nconst float wl_red = 612.0;\nconst float wl_grn = 549.0;\nconst float wl_blu = 464.0;\n\n\n//--------------------------------------------------------------------------------\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENMTATION.\n// this is a basic ringbuffer.\n// NO ERROR CHECKING\n// orion elenzil 2022.\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nuint QCount() {                                    \\\n\tif (gQHead >= gQTail) {                        \\\n\t\treturn gQHead - gQTail;                    \\\n\t}                                              \\\n\telse {                                         \\\n\t\treturn gQNumSlots - (gQTail - gQHead);     \\\n\t}                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n\treturn gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n\treturn QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n\treturn QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint QEnqueueIndex() {                             \\\n\tgQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint QDequeueIndex() {                             \\\n\tgQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n\tgQ[QEnqueueIndex()] = item;                    \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n\treturn gQ[QDequeueIndex()];                    \\\n}\n////////////////////////////////////////////////////\n\n\n//--------------------------------------------------------------------------------\n\n\n// returns false if there are no real roots.\n// returns true if there are one or two real roots.\n// roots.x <= roots.y.\nbool solveQuadratic(in vec3 coeffs, out vec2 roots) {\n    const uint A = 0u;\n    const uint B = 1u;\n    const uint C = 2u;\n    \n    // (-B +- sqrt(BB - 4AC)) / 2A\n    \n    float disc = (coeffs[B] * coeffs[B]) - (4.0 * coeffs[A] * coeffs[C]);\n    \n    if (disc < 0.0) {\n        return false;\n    }\n    \n    float sqrt_disc = sqrt(disc);\n    \n    roots.x = (-coeffs[B] - sqrt_disc) / (2.0 * coeffs[A]);\n    roots.y = (-coeffs[B] + sqrt_disc) / (2.0 * coeffs[A]);\n    \n    if (roots.y < roots.x) {\n        roots.xy = roots.yx;\n    }\n    \n    return true;\n}\n\n\n\n//--------------------------------------------------------------------------------\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins. https://www.shadertoy.com/view/4djSRW\n//  1 out, 2 in...\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n\n\n\n//--------------------------------------------------------------------------------\n// @Gijs\n// https://www.shadertoy.com/view/7dSSzy Basic : Less Simple Atmosphere\n\nvec3  SUN_COLOR = vec3(1.0,1.0,1.0);\nvec3  SKY_SCATTERING = vec3(0.1, 0.3, 0.7);\n// vec3  SUN_VECTOR;\nfloat SUN_ANGULAR_DIAMETER = 0.1;\nfloat CAMERA_HEIGHT = -0.3;\n\n\n// Consider an atmosphere of constant density & isotropic scattering \n// Occupying, in the y axis, from -infty to 0\n// This shaders ``solves'' that atmosphere analytically.\n\nfloat atmosphereDepth(vec3 pos, vec3 dir)\n{\n    return max(-pos.y, 0.0)/ max(dir.y, 0.0);\n}\n\nvec3 transmittance(float l)\n{\n    return exp(-l * SKY_SCATTERING);\n}\n\nvec3 simple_sun(vec3 dir, vec3 lightDir)\n{\n    //sometimes |dot(dir, SUN_VECTOR)| > 1 by a very small amount, this breaks acos\n    float a = acos(clamp(dot(dir, lightDir),-1.0,1.0));\n    float t = 0.005;\n    float e = smoothstep(SUN_ANGULAR_DIAMETER*0.5 + t, SUN_ANGULAR_DIAMETER*0.5, a);\n    return SUN_COLOR * e;\n}\n\nvec3 simple_sky(vec3 p, vec3 d, vec3 lightDir)\n{\n    float l = atmosphereDepth(p, d);\n    vec3 sun = simple_sun(d, lightDir) * transmittance(l);\n    float f = 1.0 - d.y / lightDir.y;\n    float l2 = atmosphereDepth(p, lightDir);\n    vec3 sk = simple_sun(lightDir, lightDir) * transmittance(l2) / f * (1.0 - transmittance(f*l));\n    return clamp(sun + sk, 0.0, 1.0);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// https://en.wikipedia.org/wiki/Schlick%27s_approximation\nfloat schlickR0(in float n1, in float n2) {\n    // same if n1 and n2 are swapped.\n    float q  = (n1 - n2) / (n1 + n2);\n    float q2 = q * q;\n    return q2;\n}\nfloat schlick(in float R0, in float cosTheta) {\n    float q  = 1.0 - cosTheta;\n    float q5 = q * q * q * q * q;\n    return R0 + ((1.0 - R0) * q5);\n}\n\n\n// https://en.wikipedia.org/wiki/Cauchy%27s_equation\nfloat cauchyN(in float invWavelengthMicrometersSquared, in float A) {\n    // I can't find a table of Cauchy coefficients,\n    // so just going with something.\n    const float B = 0.015;\n    return A + B * invWavelengthMicrometersSquared;\n}\n\n\n//--------------------------------------------------------------------------------\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Fork of \"water crystals 2\" by elenzil. https://shadertoy.com/view/ftVyzK\n// 2022-09-07 03:51:17\n\n// Fork of \"water crystals 1\" by elenzil. https://shadertoy.com/view/7lVyWw\n// 2022-08-30 04:23:52\n\n#define RES    (iResolution.xy)\n#define MINRES min(RES.x, RES.y)\n\nfloat wavelengthNM = wl_red;\n\n\n// globals\nfloat gT;\nconst float gMinRayContribution =   0.05;\nconst uint  gMaxRays            =  10u;\nconst float gSurfaceEpsilon     =   0.001;\n\n// utils\nmat2 rot(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n\nstruct ray3_t {\n    vec3  ro;\n    vec3  rd;\n    float contribution;\n    float side;           // 1 = external -1 = internal\n};\n\n// ringbuffer of rays\n#define Q_TYPE ray3_t\n#define Q_MAX_ENTRIES 10u\nQ_IMPLEMENTATION\n\n\n/////////////////////////////////////////////\n\n\n// business\n\nstruct hit_t {\n    bool  hit;\n    vec3  pnt;\n    vec3  nrm;\n    uint  mtl;\n    float t;    // distance along ray\n    float originSide;\n};\n\nstruct mtl_t {\n    float ior;\n    float diffVsTrns; // 0 = diffuse 1 = transparent, modulo reflection\n    \n    // reflect            = Schlick()\n    // transmit + diffuse = 1 - reflect\n    // transmit           = difVsTrans * (1 - reflect)\n    // diffuse            = (1 - difVsTrans) * (1 - reflect)\n    //                    = 1 - difVsTrans - reflect + difVsTrans * reflect\n};\n\nconst uint mtl_ball1 = 0u;\nconst uint mtl_ball2 = 1u;\nconst uint mtl_ball3 = 2u;\nconst uint mtl_ball4 = 3u;\nconst uint mtl_floor = 4u;\n\nconst mtl_t materials[] = mtl_t[](\n    mtl_t(ior_aerogel, 0.6),\n    mtl_t(ior_water  , 1.0),\n    mtl_t(ior_diamond, 1.0),\n    mtl_t(ior_mirror1, 0.0),\n    mtl_t(ior_shiny1 , 0.0)\n);\n\n\nvec3 gDebugColor = v0;\n\nvoid rayVsSphere(in ray3_t ray, in vec3 c, float r, uint mtl, inout hit_t hit) {\n    \n    vec3 ro = ray.ro - c;\n    vec3 rd = ray.rd;\n\n    float A = dot(rd, rd);\n    float B = dot(ro, rd) * 2.0;\n    float C = dot(ro, ro) - (r * r);\n    \n    vec2 roots;\n    if (!solveQuadratic(vec3(A, B, C), roots)) {\n        return;\n    }\n    \n    if (roots.y < 0.0) {\n        // both hits are before the start of the ray\n        return;\n    }\n    \n    if (roots.x > 0.0) {\n        if (roots.x > hit.t) {\n            return;\n        }\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.x;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n    \n    hit.originSide = -1.0;\n    \n    if (roots.y < hit.t) {\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.y;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n}\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvoid rayVsPlane(in ray3_t ray, in vec3 n, in float d, uint mtl, inout hit_t hit) {\n    float t = -(dot(ray.ro, n) + d) / (dot(ray.rd, n));\n    if (t > 0.0 && t < hit.t) {\n        hit.hit = true;\n        hit.t   = t;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = n;\n    }    \n}\n\nvec2 ballPosXY(in float t) {\n    return vec2(cos(t * 3.0) * 3.0, sin(t * 6.0)) * 1.5;\n}\n\n// hit normal is oriented towards \"outside\"\nhit_t rayVsScene(in ray3_t ray) {\n    hit_t hit;\n    hit.t   = 1e9;\n    hit.hit = false;\n    hit.originSide = 1.0;\n    \n    float bR = 0.3;\n    vec3  bP = vec3(ballPosXY(gT), bR + 0.001).xzy;\n    \n    float bt1 = fract(gT * 1.02 + 0.5) * 2.0 - 1.0;\n    float bt2 = fract(gT * 3.0 / pi  ) * 2.0 - 1.0;\n    float bt3 = fract(gT * 1.18 + 0.5) * 2.0 - 1.0;\n    \n    rayVsSphere(ray, -vX * 2.3 + vY * (2.0 - bt1 * bt1), 1.0, mtl_ball1 , hit);\n    rayVsSphere(ray,  vX * 0.0 + vY * (2.0 - bt2 * bt2), 1.0, mtl_ball2 , hit);\n    rayVsSphere(ray,  vX * 2.3 + vY * (2.0 - bt3 * bt3), 1.0, mtl_ball3 , hit);\n    rayVsSphere(ray,  bP                               , bR , mtl_ball4 , hit);\n    rayVsPlane (ray,  vY                               , 0.0, mtl_floor, hit);\n    \n    return hit;\n}\n\nfloat pointSide(in vec3 p) {\n    ray3_t r;\n    r.ro = p;\n    r.rd = vY;\n    hit_t hit = rayVsScene(r);\n    return hit.originSide;\n}\n\n\nvec3 gSunDir;\n\nvec3 sky(ray3_t ray) {\n    return simple_sky(-vY, ray.rd, -gSunDir);\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n\n    gT = iTime * 0.3;\n    \n    float zoom   = 3.0;\n    vec2  xy     = vec2(XY - RES/2.0) / MINRES * 2.0 / zoom;\n    \n    vec2  m      = dot(iMouse.xy, iMouse.xy) > 2000.0 ? iMouse.xy : iResolution.xy * 0.5;\n    vec2  mn     = (m - iResolution.xy/2.0) / iResolution.xy * 2.0;\n    \n    vec3 camPos;\n    camPos.y     = max(0.05, 3.1 - mn.y * 6.0 + 2.0 * sin(gT * 0.231));\n    camPos.xz    = vec2(sin(-gT - mn.x * pi * 1.1), cos(-gT - mn.x * pi * 1.1)) * 6.0;\n    vec3  trgPos = vec3(0.0, 1.4, 0.0);\n    \n    vec3 otherTrgPos = vec3(ballPosXY(gT - 0.05), 0.5).xzy;\n    vec3 otherCamPos = vec3(ballPosXY(gT + 0.2),  0.5).xzy;\n    otherCamPos = otherTrgPos + normalize(otherTrgPos - otherCamPos) * 1.5;\n    otherCamPos.y = 0.5;\n    float camMix = smoothstep(0.7, 0.9, sin(gT * 0.21));\n    \n    camPos = mix(camPos, otherCamPos, camMix);\n    trgPos = mix(trgPos, otherTrgPos, camMix);\n    \n    \n    vec3  camFw  = normalize(trgPos - camPos);\n    vec3  camRt  = normalize(cross(camFw, vY) - camMix * vY * camPos.x * 0.05);\n    vec3  camUp  = cross(camRt, camFw);\n    vec3  rd     = normalize(camFw + camRt * xy.x + camUp * xy.y);\n    \n    float lt     = gT * 0.231 - 2.0;\n    gSunDir      = normalize(vec3(cos(lt) * 20.0, -3.0, sin(lt) * 4.0));\n    \n    vec3  col    = vec3(0.0);\n    \n    ray3_t r0;\n    r0.ro           = camPos;\n    r0.rd           = rd;\n    r0.contribution = 1.0;\n    r0.side         = pointSide(camPos);\n    \n    float invWavelengthMicrometersSquared = 1.0 / (wavelengthNM * wavelengthNM * 1e-6);\n    \n    QEnqueue(r0);\n    \n    \n    uint rayCount = 0u;\n    \n    while (!QIsEmpty()) {\n        ray3_t ray = QDequeue();\n        \n        hit_t hit = rayVsScene(ray);\n        \n        if (!hit.hit) {\n            col += ray.contribution * sky(ray);\n            continue;\n        }\n        \n        vec3 hitFacingNormal = hit.nrm * ray.side;\n        \n        mtl_t mtl     = materials[hit.mtl];\n        float ior     = cauchyN(invWavelengthMicrometersSquared, mtl.ior);\n        float R0      = schlickR0(ior, ior_air);\n        float reflAmt = schlick  (R0, dot(ray.rd, -hitFacingNormal));\n        float trnsAmt = mtl.diffVsTrns * (1.0 - reflAmt);\n        float diffAmt = (1.0 - mtl.diffVsTrns) * (1.0 - reflAmt);\n        \n        reflAmt *= ray.contribution;\n        trnsAmt *= ray.contribution;\n        diffAmt *= ray.contribution;\n        \n        \n        if (diffAmt > gMinRayContribution) {\n            \n            vec3 albedo = v1;\n            if (hit.mtl == mtl_floor) {\n                float q = 1.0;\n                \n                q *= smoothstep(-0.05, 0.05, sin((hit.pnt.x - 0.5) * pi));\n                q *= smoothstep(-0.05, 0.05, sin((hit.pnt.z - 0.5) * pi));\n                \n                albedo *= 0.2 + 0.8 * (1.0 - q);\n            }\n        \n            // shadow\n            ray3_t shadowRay;\n            shadowRay.ro = hit.pnt + hit.nrm * 0.01;\n            shadowRay.rd = -gSunDir;\n            hit_t shadowHit = rayVsScene(shadowRay);\n            float lightAmt = shadowHit.hit ? 0.1 : 1.0;\n\n            col += lightAmt * albedo * diffAmt * max(0.0, dot(hit.nrm, -gSunDir));\n        }\n        \n        bool keepGoing = true;\n        \n        keepGoing = keepGoing && (QSpaceLeft() >= 2u);\n        keepGoing = keepGoing && (rayCount < gMaxRays);\n        keepGoing = keepGoing && ((ray.contribution - diffAmt) > gMinRayContribution);\n        if (!keepGoing) {\n            continue;\n        }\n        \n        rayCount += 1u;\n                \n        if (mtl.diffVsTrns > 0.001) {\n            float eta = ior_air / ior;\n            if (ray.side < 0.0) {\n                eta = 1.0 / eta;\n            }\n            vec3 transmtRd       = refract(ray.rd, hitFacingNormal, eta);\n            // we don't check total internal because it's not possible\n            // for a ray which was originally outside the sphere.\n            if (trnsAmt > gMinRayContribution) {\n                ray3_t transmtRay        = ray;\n                transmtRay.contribution  = trnsAmt;\n                transmtRay.rd            = transmtRd;\n                transmtRay.side         *= -1.0;\n                transmtRay.ro            = hit.pnt - hitFacingNormal * gSurfaceEpsilon;\n                QEnqueue(transmtRay);\n            }\n        }\n\n        if (reflAmt > gMinRayContribution) {\n            ray3_t reflectRay;\n            reflectRay.contribution  = reflAmt;\n            reflectRay.ro            = hit.pnt + hitFacingNormal * gSurfaceEpsilon;\n            reflectRay.rd            = reflect(ray.rd, hit.nrm);\n            reflectRay.side          = ray.side;\n            QEnqueue(reflectRay);\n        }\n    }\n\n    // boost darker colors\n    col = pow(col, vec3(1.0/1.7));\n     \n    // col = col + gDebugColor;\n \n    RGBA = vec4(vec3(col), float(rayCount));\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Fork of \"water crystals 2\" by elenzil. https://shadertoy.com/view/ftVyzK\n// 2022-09-07 03:51:17\n\n// Fork of \"water crystals 1\" by elenzil. https://shadertoy.com/view/7lVyWw\n// 2022-08-30 04:23:52\n\n#define RES    (iResolution.xy)\n#define MINRES min(RES.x, RES.y)\n\nfloat wavelengthNM = wl_grn;\n\n\n// globals\nfloat gT;\nconst float gMinRayContribution =   0.05;\nconst uint  gMaxRays            =  10u;\nconst float gSurfaceEpsilon     =   0.001;\n\n// utils\nmat2 rot(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n\nstruct ray3_t {\n    vec3  ro;\n    vec3  rd;\n    float contribution;\n    float side;           // 1 = external -1 = internal\n};\n\n// ringbuffer of rays\n#define Q_TYPE ray3_t\n#define Q_MAX_ENTRIES 10u\nQ_IMPLEMENTATION\n\n\n/////////////////////////////////////////////\n\n\n// business\n\nstruct hit_t {\n    bool  hit;\n    vec3  pnt;\n    vec3  nrm;\n    uint  mtl;\n    float t;    // distance along ray\n    float originSide;\n};\n\nstruct mtl_t {\n    float ior;\n    float diffVsTrns; // 0 = diffuse 1 = transparent, modulo reflection\n    \n    // reflect            = Schlick()\n    // transmit + diffuse = 1 - reflect\n    // transmit           = difVsTrans * (1 - reflect)\n    // diffuse            = (1 - difVsTrans) * (1 - reflect)\n    //                    = 1 - difVsTrans - reflect + difVsTrans * reflect\n};\n\nconst uint mtl_ball1 = 0u;\nconst uint mtl_ball2 = 1u;\nconst uint mtl_ball3 = 2u;\nconst uint mtl_ball4 = 3u;\nconst uint mtl_floor = 4u;\n\nconst mtl_t materials[] = mtl_t[](\n    mtl_t(ior_aerogel, 0.6),\n    mtl_t(ior_water  , 1.0),\n    mtl_t(ior_diamond, 1.0),\n    mtl_t(ior_mirror1, 0.0),\n    mtl_t(ior_shiny1 , 0.0)\n);\n\n\nvec3 gDebugColor = v0;\n\nvoid rayVsSphere(in ray3_t ray, in vec3 c, float r, uint mtl, inout hit_t hit) {\n    \n    vec3 ro = ray.ro - c;\n    vec3 rd = ray.rd;\n\n    float A = dot(rd, rd);\n    float B = dot(ro, rd) * 2.0;\n    float C = dot(ro, ro) - (r * r);\n    \n    vec2 roots;\n    if (!solveQuadratic(vec3(A, B, C), roots)) {\n        return;\n    }\n    \n    if (roots.y < 0.0) {\n        // both hits are before the start of the ray\n        return;\n    }\n    \n    if (roots.x > 0.0) {\n        if (roots.x > hit.t) {\n            return;\n        }\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.x;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n    \n    hit.originSide = -1.0;\n    \n    if (roots.y < hit.t) {\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.y;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n}\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvoid rayVsPlane(in ray3_t ray, in vec3 n, in float d, uint mtl, inout hit_t hit) {\n    float t = -(dot(ray.ro, n) + d) / (dot(ray.rd, n));\n    if (t > 0.0 && t < hit.t) {\n        hit.hit = true;\n        hit.t   = t;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = n;\n    }    \n}\n\nvec2 ballPosXY(in float t) {\n    return vec2(cos(t * 3.0) * 3.0, sin(t * 6.0)) * 1.5;\n}\n\n// hit normal is oriented towards \"outside\"\nhit_t rayVsScene(in ray3_t ray) {\n    hit_t hit;\n    hit.t   = 1e9;\n    hit.hit = false;\n    hit.originSide = 1.0;\n    \n    float bR = 0.3;\n    vec3  bP = vec3(ballPosXY(gT), bR + 0.001).xzy;\n    \n    float bt1 = fract(gT * 1.02 + 0.5) * 2.0 - 1.0;\n    float bt2 = fract(gT * 3.0 / pi  ) * 2.0 - 1.0;\n    float bt3 = fract(gT * 1.18 + 0.5) * 2.0 - 1.0;\n    \n    rayVsSphere(ray, -vX * 2.3 + vY * (2.0 - bt1 * bt1), 1.0, mtl_ball1 , hit);\n    rayVsSphere(ray,  vX * 0.0 + vY * (2.0 - bt2 * bt2), 1.0, mtl_ball2 , hit);\n    rayVsSphere(ray,  vX * 2.3 + vY * (2.0 - bt3 * bt3), 1.0, mtl_ball3 , hit);\n    rayVsSphere(ray,  bP                               , bR , mtl_ball4 , hit);\n    rayVsPlane (ray,  vY                               , 0.0, mtl_floor, hit);\n    \n    return hit;\n}\n\nfloat pointSide(in vec3 p) {\n    ray3_t r;\n    r.ro = p;\n    r.rd = vY;\n    hit_t hit = rayVsScene(r);\n    return hit.originSide;\n}\n\n\nvec3 gSunDir;\n\nvec3 sky(ray3_t ray) {\n    return simple_sky(-vY, ray.rd, -gSunDir);\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n\n    gT = iTime * 0.3;\n    \n    float zoom   = 3.0;\n    vec2  xy     = vec2(XY - RES/2.0) / MINRES * 2.0 / zoom;\n    \n    vec2  m      = dot(iMouse.xy, iMouse.xy) > 2000.0 ? iMouse.xy : iResolution.xy * 0.5;\n    vec2  mn     = (m - iResolution.xy/2.0) / iResolution.xy * 2.0;\n    \n    vec3 camPos;\n    camPos.y     = max(0.05, 3.1 - mn.y * 6.0 + 2.0 * sin(gT * 0.231));\n    camPos.xz    = vec2(sin(-gT - mn.x * pi * 1.1), cos(-gT - mn.x * pi * 1.1)) * 6.0;\n    vec3  trgPos = vec3(0.0, 1.4, 0.0);\n    \n    vec3 otherTrgPos = vec3(ballPosXY(gT - 0.05), 0.5).xzy;\n    vec3 otherCamPos = vec3(ballPosXY(gT + 0.2),  0.5).xzy;\n    otherCamPos = otherTrgPos + normalize(otherTrgPos - otherCamPos) * 1.5;\n    otherCamPos.y = 0.5;\n    float camMix = smoothstep(0.7, 0.9, sin(gT * 0.21));\n    \n    camPos = mix(camPos, otherCamPos, camMix);\n    trgPos = mix(trgPos, otherTrgPos, camMix);\n    \n    \n    vec3  camFw  = normalize(trgPos - camPos);\n    vec3  camRt  = normalize(cross(camFw, vY) - camMix * vY * camPos.x * 0.05);\n    vec3  camUp  = cross(camRt, camFw);\n    vec3  rd     = normalize(camFw + camRt * xy.x + camUp * xy.y);\n    \n    float lt     = gT * 0.231 - 2.0;\n    gSunDir      = normalize(vec3(cos(lt) * 20.0, -3.0, sin(lt) * 4.0));\n    \n    vec3  col    = vec3(0.0);\n    \n    ray3_t r0;\n    r0.ro           = camPos;\n    r0.rd           = rd;\n    r0.contribution = 1.0;\n    r0.side         = pointSide(camPos);\n    \n    float invWavelengthMicrometersSquared = 1.0 / (wavelengthNM * wavelengthNM * 1e-6);\n    \n    QEnqueue(r0);\n    \n    \n    uint rayCount = 0u;\n    \n    while (!QIsEmpty()) {\n        ray3_t ray = QDequeue();\n        \n        hit_t hit = rayVsScene(ray);\n        \n        if (!hit.hit) {\n            col += ray.contribution * sky(ray);\n            continue;\n        }\n        \n        vec3 hitFacingNormal = hit.nrm * ray.side;\n        \n        mtl_t mtl     = materials[hit.mtl];\n        float ior     = cauchyN(invWavelengthMicrometersSquared, mtl.ior);\n        float R0      = schlickR0(ior, ior_air);\n        float reflAmt = schlick  (R0, dot(ray.rd, -hitFacingNormal));\n        float trnsAmt = mtl.diffVsTrns * (1.0 - reflAmt);\n        float diffAmt = (1.0 - mtl.diffVsTrns) * (1.0 - reflAmt);\n        \n        reflAmt *= ray.contribution;\n        trnsAmt *= ray.contribution;\n        diffAmt *= ray.contribution;\n        \n        \n        if (diffAmt > gMinRayContribution) {\n            \n            vec3 albedo = v1;\n            if (hit.mtl == mtl_floor) {\n                float q = 1.0;\n                \n                q *= smoothstep(-0.05, 0.05, sin((hit.pnt.x - 0.5) * pi));\n                q *= smoothstep(-0.05, 0.05, sin((hit.pnt.z - 0.5) * pi));\n                \n                albedo *= 0.2 + 0.8 * (1.0 - q);\n            }\n        \n            // shadow\n            ray3_t shadowRay;\n            shadowRay.ro = hit.pnt + hit.nrm * 0.01;\n            shadowRay.rd = -gSunDir;\n            hit_t shadowHit = rayVsScene(shadowRay);\n            float lightAmt = shadowHit.hit ? 0.1 : 1.0;\n\n            col += lightAmt * albedo * diffAmt * max(0.0, dot(hit.nrm, -gSunDir));\n        }\n        \n        bool keepGoing = true;\n        \n        keepGoing = keepGoing && (QSpaceLeft() >= 2u);\n        keepGoing = keepGoing && (rayCount < gMaxRays);\n        keepGoing = keepGoing && ((ray.contribution - diffAmt) > gMinRayContribution);\n        if (!keepGoing) {\n            continue;\n        }\n        \n        rayCount += 1u;\n                \n        if (mtl.diffVsTrns > 0.001) {\n            float eta = ior_air / ior;\n            if (ray.side < 0.0) {\n                eta = 1.0 / eta;\n            }\n            vec3 transmtRd       = refract(ray.rd, hitFacingNormal, eta);\n            // we don't check total internal because it's not possible\n            // for a ray which was originally outside the sphere.\n            if (trnsAmt > gMinRayContribution) {\n                ray3_t transmtRay        = ray;\n                transmtRay.contribution  = trnsAmt;\n                transmtRay.rd            = transmtRd;\n                transmtRay.side         *= -1.0;\n                transmtRay.ro            = hit.pnt - hitFacingNormal * gSurfaceEpsilon;\n                QEnqueue(transmtRay);\n            }\n        }\n\n        if (reflAmt > gMinRayContribution) {\n            ray3_t reflectRay;\n            reflectRay.contribution  = reflAmt;\n            reflectRay.ro            = hit.pnt + hitFacingNormal * gSurfaceEpsilon;\n            reflectRay.rd            = reflect(ray.rd, hit.nrm);\n            reflectRay.side          = ray.side;\n            QEnqueue(reflectRay);\n        }\n    }\n\n    // boost darker colors\n    col = pow(col, vec3(1.0/1.7));\n     \n    // col = col + gDebugColor;\n    \n    RGBA = vec4(vec3(col), float(rayCount));\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Fork of \"water crystals 2\" by elenzil. https://shadertoy.com/view/ftVyzK\n// 2022-09-07 03:51:17\n\n// Fork of \"water crystals 1\" by elenzil. https://shadertoy.com/view/7lVyWw\n// 2022-08-30 04:23:52\n\n#define RES    (iResolution.xy)\n#define MINRES min(RES.x, RES.y)\n\nfloat wavelengthNM = wl_blu;\n\n\n// globals\nfloat gT;\nconst float gMinRayContribution =   0.05;\nconst uint  gMaxRays            =  10u;\nconst float gSurfaceEpsilon     =   0.001;\n\n// utils\nmat2 rot(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n\nstruct ray3_t {\n    vec3  ro;\n    vec3  rd;\n    float contribution;\n    float side;           // 1 = external -1 = internal\n};\n\n// ringbuffer of rays\n#define Q_TYPE ray3_t\n#define Q_MAX_ENTRIES 10u\nQ_IMPLEMENTATION\n\n\n/////////////////////////////////////////////\n\n\n// business\n\nstruct hit_t {\n    bool  hit;\n    vec3  pnt;\n    vec3  nrm;\n    uint  mtl;\n    float t;    // distance along ray\n    float originSide;\n};\n\nstruct mtl_t {\n    float ior;\n    float diffVsTrns; // 0 = diffuse 1 = transparent, modulo reflection\n    \n    // reflect            = Schlick()\n    // transmit + diffuse = 1 - reflect\n    // transmit           = difVsTrans * (1 - reflect)\n    // diffuse            = (1 - difVsTrans) * (1 - reflect)\n    //                    = 1 - difVsTrans - reflect + difVsTrans * reflect\n};\n\nconst uint mtl_ball1 = 0u;\nconst uint mtl_ball2 = 1u;\nconst uint mtl_ball3 = 2u;\nconst uint mtl_ball4 = 3u;\nconst uint mtl_floor = 4u;\n\nconst mtl_t materials[] = mtl_t[](\n    mtl_t(ior_aerogel, 0.6),\n    mtl_t(ior_water  , 1.0),\n    mtl_t(ior_diamond, 1.0),\n    mtl_t(ior_mirror1, 0.0),\n    mtl_t(ior_shiny1 , 0.0)\n);\n\n\nvec3 gDebugColor = v0;\n\nvoid rayVsSphere(in ray3_t ray, in vec3 c, float r, uint mtl, inout hit_t hit) {\n    \n    vec3 ro = ray.ro - c;\n    vec3 rd = ray.rd;\n\n    float A = dot(rd, rd);\n    float B = dot(ro, rd) * 2.0;\n    float C = dot(ro, ro) - (r * r);\n    \n    vec2 roots;\n    if (!solveQuadratic(vec3(A, B, C), roots)) {\n        return;\n    }\n    \n    if (roots.y < 0.0) {\n        // both hits are before the start of the ray\n        return;\n    }\n    \n    if (roots.x > 0.0) {\n        if (roots.x > hit.t) {\n            return;\n        }\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.x;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n    \n    hit.originSide = -1.0;\n    \n    if (roots.y < hit.t) {\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.y;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n}\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvoid rayVsPlane(in ray3_t ray, in vec3 n, in float d, uint mtl, inout hit_t hit) {\n    float t = -(dot(ray.ro, n) + d) / (dot(ray.rd, n));\n    if (t > 0.0 && t < hit.t) {\n        hit.hit = true;\n        hit.t   = t;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = n;\n    }    \n}\n\nvec2 ballPosXY(in float t) {\n    return vec2(cos(t * 3.0) * 3.0, sin(t * 6.0)) * 1.5;\n}\n\n// hit normal is oriented towards \"outside\"\nhit_t rayVsScene(in ray3_t ray) {\n    hit_t hit;\n    hit.t   = 1e9;\n    hit.hit = false;\n    hit.originSide = 1.0;\n    \n    float bR = 0.3;\n    vec3  bP = vec3(ballPosXY(gT), bR + 0.001).xzy;\n    \n    float bt1 = fract(gT * 1.02 + 0.5) * 2.0 - 1.0;\n    float bt2 = fract(gT * 3.0 / pi  ) * 2.0 - 1.0;\n    float bt3 = fract(gT * 1.18 + 0.5) * 2.0 - 1.0;\n    \n    rayVsSphere(ray, -vX * 2.3 + vY * (2.0 - bt1 * bt1), 1.0, mtl_ball1 , hit);\n    rayVsSphere(ray,  vX * 0.0 + vY * (2.0 - bt2 * bt2), 1.0, mtl_ball2 , hit);\n    rayVsSphere(ray,  vX * 2.3 + vY * (2.0 - bt3 * bt3), 1.0, mtl_ball3 , hit);\n    rayVsSphere(ray,  bP                               , bR , mtl_ball4 , hit);\n    rayVsPlane (ray,  vY                               , 0.0, mtl_floor, hit);\n    \n    return hit;\n}\n\nfloat pointSide(in vec3 p) {\n    ray3_t r;\n    r.ro = p;\n    r.rd = vY;\n    hit_t hit = rayVsScene(r);\n    return hit.originSide;\n}\n\n\nvec3 gSunDir;\n\nvec3 sky(ray3_t ray) {\n    return simple_sky(-vY, ray.rd, -gSunDir);\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n\n    gT = iTime * 0.3;\n    \n    float zoom   = 3.0;\n    vec2  xy     = vec2(XY - RES/2.0) / MINRES * 2.0 / zoom;\n    \n    vec2  m      = dot(iMouse.xy, iMouse.xy) > 2000.0 ? iMouse.xy : iResolution.xy * 0.5;\n    vec2  mn     = (m - iResolution.xy/2.0) / iResolution.xy * 2.0;\n    \n    vec3 camPos;\n    camPos.y     = max(0.05, 3.1 - mn.y * 6.0 + 2.0 * sin(gT * 0.231));\n    camPos.xz    = vec2(sin(-gT - mn.x * pi * 1.1), cos(-gT - mn.x * pi * 1.1)) * 6.0;\n    vec3  trgPos = vec3(0.0, 1.4, 0.0);\n    \n    vec3 otherTrgPos = vec3(ballPosXY(gT - 0.05), 0.5).xzy;\n    vec3 otherCamPos = vec3(ballPosXY(gT + 0.2),  0.5).xzy;\n    otherCamPos = otherTrgPos + normalize(otherTrgPos - otherCamPos) * 1.5;\n    otherCamPos.y = 0.5;\n    float camMix = smoothstep(0.7, 0.9, sin(gT * 0.21));\n    \n    camPos = mix(camPos, otherCamPos, camMix);\n    trgPos = mix(trgPos, otherTrgPos, camMix);\n    \n    \n    vec3  camFw  = normalize(trgPos - camPos);\n    vec3  camRt  = normalize(cross(camFw, vY) - camMix * vY * camPos.x * 0.05);\n    vec3  camUp  = cross(camRt, camFw);\n    vec3  rd     = normalize(camFw + camRt * xy.x + camUp * xy.y);\n    \n    float lt     = gT * 0.231 - 2.0;\n    gSunDir      = normalize(vec3(cos(lt) * 20.0, -3.0, sin(lt) * 4.0));\n    \n    vec3  col    = vec3(0.0);\n    \n    ray3_t r0;\n    r0.ro           = camPos;\n    r0.rd           = rd;\n    r0.contribution = 1.0;\n    r0.side         = pointSide(camPos);\n    \n    float invWavelengthMicrometersSquared = 1.0 / (wavelengthNM * wavelengthNM * 1e-6);\n    \n    QEnqueue(r0);\n    \n    \n    uint rayCount = 0u;\n    \n    while (!QIsEmpty()) {\n        ray3_t ray = QDequeue();\n        \n        hit_t hit = rayVsScene(ray);\n        \n        if (!hit.hit) {\n            col += ray.contribution * sky(ray);\n            continue;\n        }\n        \n        vec3 hitFacingNormal = hit.nrm * ray.side;\n        \n        mtl_t mtl     = materials[hit.mtl];\n        float ior     = cauchyN(invWavelengthMicrometersSquared, mtl.ior);\n        float R0      = schlickR0(ior, ior_air);\n        float reflAmt = schlick  (R0, dot(ray.rd, -hitFacingNormal));\n        float trnsAmt = mtl.diffVsTrns * (1.0 - reflAmt);\n        float diffAmt = (1.0 - mtl.diffVsTrns) * (1.0 - reflAmt);\n        \n        reflAmt *= ray.contribution;\n        trnsAmt *= ray.contribution;\n        diffAmt *= ray.contribution;\n        \n        \n        if (diffAmt > gMinRayContribution) {\n            \n            vec3 albedo = v1;\n            if (hit.mtl == mtl_floor) {\n                float q = 1.0;\n                \n                q *= smoothstep(-0.05, 0.05, sin((hit.pnt.x - 0.5) * pi));\n                q *= smoothstep(-0.05, 0.05, sin((hit.pnt.z - 0.5) * pi));\n                \n                albedo *= 0.2 + 0.8 * (1.0 - q);\n            }\n        \n            // shadow\n            ray3_t shadowRay;\n            shadowRay.ro = hit.pnt + hit.nrm * 0.01;\n            shadowRay.rd = -gSunDir;\n            hit_t shadowHit = rayVsScene(shadowRay);\n            float lightAmt = shadowHit.hit ? 0.1 : 1.0;\n\n            col += lightAmt * albedo * diffAmt * max(0.0, dot(hit.nrm, -gSunDir));\n        }\n        \n        bool keepGoing = true;\n        \n        keepGoing = keepGoing && (QSpaceLeft() >= 2u);\n        keepGoing = keepGoing && (rayCount < gMaxRays);\n        keepGoing = keepGoing && ((ray.contribution - diffAmt) > gMinRayContribution);\n        if (!keepGoing) {\n            continue;\n        }\n        \n        rayCount += 1u;\n                \n        if (mtl.diffVsTrns > 0.001) {\n            float eta = ior_air / ior;\n            if (ray.side < 0.0) {\n                eta = 1.0 / eta;\n            }\n            vec3 transmtRd       = refract(ray.rd, hitFacingNormal, eta);\n            // we don't check total internal because it's not possible\n            // for a ray which was originally outside the sphere.\n            if (trnsAmt > gMinRayContribution) {\n                ray3_t transmtRay        = ray;\n                transmtRay.contribution  = trnsAmt;\n                transmtRay.rd            = transmtRd;\n                transmtRay.side         *= -1.0;\n                transmtRay.ro            = hit.pnt - hitFacingNormal * gSurfaceEpsilon;\n                QEnqueue(transmtRay);\n            }\n        }\n\n        if (reflAmt > gMinRayContribution) {\n            ray3_t reflectRay;\n            reflectRay.contribution  = reflAmt;\n            reflectRay.ro            = hit.pnt + hitFacingNormal * gSurfaceEpsilon;\n            reflectRay.rd            = reflect(ray.rd, hit.nrm);\n            reflectRay.side          = ray.side;\n            QEnqueue(reflectRay);\n        }\n    }\n\n    // boost darker colors\n    col = pow(col, vec3(1.0/1.7));\n     \n    // col = col + gDebugColor;\n    \n    RGBA = vec4(vec3(col), float(rayCount));\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}