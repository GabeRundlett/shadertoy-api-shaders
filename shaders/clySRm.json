{
    "Shader": {
        "info": {
            "date": "1686227697",
            "description": "Using integers in this octree to make it more robust.\n2d testing [url]https://www.shadertoy.com/view/DtyXRK[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "clySRm",
            "likes": 8,
            "name": "rolling rush",
            "published": 3,
            "tags": [
                "3d",
                "octree"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 183
        },
        "renderpass": [
            {
                "code": "#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nint vec3_min_index(vec3 a)\n{\n    if (a.x < a.y)\n        if (a.x < a.z)\n            return 0;\n        else\n            if (a.y < a.z)\n                return 1;\n            else\n                return 2;\n    else\n        if (a.y < a.z)\n            return 1;\n        else\n            if (a.x < a.z)\n                return 0;\n            else\n                return 2;\n}\n\nfloat map(vec3 p)\n{\n    float len = length(p.xy);\n    p.xy *= rot(p.z*0.05+len*0.04);\n    \n    float l = (3.0-abs(p.y));\n    //float l = 10000000.0;\n    \n    p.x += iTime*5.0;\n    p.y = mod(p.y, 4.0)-2.0;\n    p.xz = mod(p.xz, 10.0)-5.0;\n    l = min(l, length(p)-1.0);\n\n    return l*0.8;\n}\n\nvec3 get_color(vec3 p, vec3 n)\n{\n    float len = length(p.xy);\n    p.xy *= rot(p.z*0.05+len*0.04);\n    \n    float l = (3.0-abs(p.y));\n    \n    p.x += iTime*5.0;\n    p.y = abs(p.y)-2.0;\n    \n    vec3 p2 = p;\n    \n    p.xz = mod(p.xz, 10.0)-5.0;\n    l = max(length(p)-1.0,0.0);\n    \n    n.xz *= rot(p2.x);\n    n.xy *= rot(p2.z);\n    \n    vec3 c = vec3(1, 0.5, 0.8)+n*0.1;\n    \n    return c/(l*l+1.0);\n}\n\nint get_voxel(ivec3 id, float size)\n{\n    vec3 p = vec3(id)*size+size*0.5;\n    \n    // sqrt(1^2+1^2+1^2) distance from cube center to cube corner\n    size *= sqrt(3.0)*0.5;\n    \n    float d = map(p);\n    \n    if (d > size)\n        return 1;\n    if (d < -size)\n        return 2;\n    return 3;\n}\n\nvec3 shoot_ray(const vec3 ro, const vec3 rd)\n{\n    ivec3 id = ivec3(floor(ro));\n    \n    vec3 ird = 1.0/abs(rd);\n    \n    ivec3 isrd = ivec3(greaterThan(rd, vec3(0)));\n    \n    vec3 frp = fract(ro);\n    \n    float size = 1.0;\n    \n    vec3 p = ro;\n    float d = 0.0;\n    \n    vec3 dists = ird*(step(0.0,rd)-sign(rd)*fract(ro));\n    \n    \n    int depth = 0;\n    int j = 0;\n    \n    bool exit = false;\n    \n    for (int i = 0; i < 100; i++)\n    {\n        if (exit)\n        {\n            ivec3 grid = id&1;\n            frp += vec3(grid)*size;\n            id >>= 1;\n            depth--;\n            \n            grid = grid ^ isrd;\n            dists += ird*size*vec3(grid);\n            \n            size *= 2.0;\n            \n            exit = (id[j]&1) != isrd[j] && depth > 0;\n            \n            continue;\n        }\n    \n        int vox_stat = get_voxel(id, size);\n        if (vox_stat == 2)\n            break;\n        \n        if (vox_stat == 3)\n        {\n            if (depth >= 3) break;\n            size /= 2.0;\n            id <<= 1;\n            depth++;\n            \n            bvec3 grid = greaterThan(frp, vec3(size));\n            bvec3 look = lessThan(rd, vec3(0));\n            \n            id += ivec3(grid);\n            frp -= vec3(grid)*size;\n            dists -= ird*size*vec3(equal(grid, look));\n            \n            continue;\n        }\n    \n        j = vec3_min_index(dists);\n        \n        d = dists[j];\n        \n        dists[j] += ird[j]*size;\n        id[j] += isrd[j]*2-1;\n        \n        frp += ro+rd*d-p;\n        frp[j] -= sign(rd[j])*size;\n        \n        exit = (id[j]&1) != isrd[j] && depth > 0;\n\n        p = ro+rd*d;\n    }\n    \n    vec3 col = frp;\n    \n    vec3 n = vec3(0);\n    n[j] = 1.0;\n    n *= sign(rd);\n    col = get_color(p, n);\n    \n    col *= 1.0/(d*d*d*0.0005+1.0);\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    \n    if (length(iMouse.xy) < 10.0)\n        muv = vec2(0.5);\n\n    vec3 ro = vec3(0, 0, iTime);\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    rd.yz *= rot(muv.y*3.14-3.14*0.5);\n    rd.xz *= rot(muv.x*3.14*4.0);\n    \n    vec3 col = shoot_ray(ro, rd);\n    \n    //some gamma stuff\n    col = pow(col, vec3(1.0/2.2));\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}