{
    "Shader": {
        "info": {
            "date": "1606185596",
            "description": "This was fun!\nCheck this out for more info and similar stuff:\nhttps://isohedral.ca/swirled-series/",
            "flags": 0,
            "hasliked": 0,
            "id": "3dcBWX",
            "likes": 13,
            "name": "checkerboard spiral",
            "published": 3,
            "tags": [
                "spiral",
                "checkerboard",
                "checkerboardspiral"
            ],
            "usePreview": 0,
            "username": "teadrinker",
            "viewed": 423
        },
        "renderpass": [
            {
                "code": "//\n// More stuff like this:\n// https://isohedral.ca/swirled-series/\n// \n// by teadrinker / Martin Eklund 2020\n// https://creativecommons.org/licenses/by-nc-sa/4.0/\n//\n\n\n\n#define pi 3.141592653589793\n\n\n\n// Map normal 2D space to a spiral 2D space, \n// cornerSize = pi/4 should be most correct for animating a spiral\n// (derivative of output x, along the center-line of the spiral should have constant magnitude)\n//\n// however, to align with checkerboard, we need to use cornerSize = 1.0\n//\n//   (0,0) of input space is the center of the spiral (or (0.5,0) if judged by centerpoint)\n//\n//   output x: distance to center along the spiral (space can be warped, depending on cornerSize)\n//   output y: orthogonal to x (0 to 1, for corners 0 to sqrt(2))\n\nvec2 spiral_square_gradient(vec2 U, float cornerSize) { \n\n    vec2 floorU = floor(U);\n    ivec2 i = ivec2(floorU);\n    vec2 fractU = U - floorU;\n    float x = fractU.x;\n    float y = fractU.y;\n\n    if(i.x == 0 && i.y == 0) \n        return vec2(cornerSize * atan(y, x) * 2. / pi, length(fractU));\n\n    int rad = max(abs(i.x), abs(i.y));\n    int prevRad = rad - 1;\n    float spiralDist = max(0., float(4 * prevRad * prevRad));  // straight segments\n    spiralDist += float(prevRad * 4 + 1) * cornerSize;         // corners\n\n    if(i.x == -rad && i.y == rad - 1) \n        return vec2(spiralDist + cornerSize * atan(1.-x, y) * 2. / pi, length(vec2(1.-x, y)));\n    else\n        spiralDist += cornerSize;\n\n    if(i.x == -rad && (i.y < rad - 1 && i.y > -rad)) \n        return vec2(spiralDist + float(max(0,(rad-1)-i.y-1)) + (1.-y), 1.-x);\n    else if(rad*2 > 2)\n        spiralDist += float(rad*2 - 2);\n\n    if(i.x == -rad && i.y == -rad) \n        return vec2(spiralDist + cornerSize * atan(1.-y,1.-x) * 2. / pi, length(vec2(1.-y,1.-x)));\n    else\n        spiralDist += cornerSize;\n\n    if(i.y == -rad && (i.x < rad && i.x > -rad)) \n        return vec2(spiralDist + float(max(0,i.x-(-rad)-1)) + x, 1.-y);\n    else\n        spiralDist += float(rad*2 - 1);\n\n    if(i.x == rad && i.y == -rad) \n        return vec2(spiralDist + cornerSize * atan(x,1.-y) * 2. / pi, length(vec2(x,1.-y)));\n    else\n        spiralDist += cornerSize;\n\n    if(i.x == rad && (i.y < rad && i.y > -rad)) \n        return vec2(spiralDist + float(max(0,i.y-(-rad)-1)) + y, x);\n    else\n        spiralDist += float(rad*2 - 1);\n\n    if(i.x == rad && i.y == rad) \n        return vec2(spiralDist + cornerSize * atan(y,x) * 2. / pi, length(vec2(y,x)));\n    else\n        spiralDist += cornerSize;\n\n    if(i.y == rad && i.x < rad) \n        return vec2(spiralDist + float(max(0,rad-i.x-1)) + (1.-x), y);\n\n\n\treturn vec2(666., 0.); // can this happen?\n}  \n\n\n\n\n\n\nfloat smoothpowstep(float a, float b, float x, float expo)\t \n{\n\tif( x<a ) return 0.;\n\tif( x>b ) return 1.;\n\tfloat y = (x-a)/(b-a);\n\tif(y < 0.5)\n        return 0.5*pow(y*2., expo);\n\treturn 1.-0.5*pow((1.-y)*2., expo);\n}\n\nfloat smoothpowercycle(float x, float expo) {\n\tx = fract(x);\n    if(x<0.5) return smoothpowstep(0., 0.5, x, expo);\n    return 1.0 - smoothpowstep(0.5, 1.0, x, expo);\n}\n\nfloat linstep(float a, float b, float x) { \n\treturn clamp((x - a) / (b - a), 0.0, 1.0); \n}\n\n\n\n\n\n\n\nfloat anim1(float t, float spiral, float range, inout float aa)\t \n{\n    float width = 130.;\n    float anim = smoothpowstep(t*(range+width) - width, t*(range+width), spiral, 4.);\n    aa = 1.0 * (0.5 - abs(0.5 - anim));    \n    return spiral + 8. * anim;\n}\n\nfloat anim2(float t, float spiral, float range, inout float aa)\t \n{\n    t = 0.9 * (1.0 - 2.0 * abs(0.5 - t));\n    \n    float width = 130.;\n    float anim = 1. - smoothpowstep(t*(range+width) - width, t*(range+width), spiral, 6.);\n    aa = 0.4 * (0.5 - abs(0.5 - anim));\n    return spiral + 1.0 * anim;\n}\n\nfloat anim3(float t, float spiral, float range, inout float aa)\t \n{\n    aa = 0.01;  \n    float midpos = 0.5;\n    if(t>0.5)\n        midpos=0.5-0.125+0.25;\n\n    float amount =  1.0;\n    float anim = smoothpowercycle(t, 5.);\n    aa = 0.02 * (1. - 2.*abs(anim - 0.5)) * abs(spiral - midpos*range);\n    return range*midpos + (spiral-range*midpos) * (1. + amount * anim);\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{  \n    O-=O; \n\n    float size = 8.;\n    \n    vec2 R = iResolution.xy,\n         U = u *= size / R.y, V;\n    \n    if (U.x > size) { O += .5; return; } // out of board\n\n    float t = fract(iTime / 3.6);\n    int it = int(floor(iTime / 3.6));\n\n    \n    float range = 56.5 + 7.5;\n    vec2 spiralSpace = spiral_square_gradient(vec2(size/2. - U.x, U.y - size/2. ), 1.);\n    float spiral = 64. - spiralSpace.x;\n\tfloat aa = 0.;\n    \n    float gray = 0.;\n    if(it%3 == 0)\n\t\tgray = anim1(t, spiral, range, aa);\n    else if(it%3 == 1)\n\t\tgray = anim2(t, spiral, range, aa);\n    else\n\t\tgray = anim3(t, spiral, range, aa);\n        \n    gray = linstep(0.5-aa, 0.5+aa, 2.*abs(0.5 - fract(gray*0.5+0.25)));\n\n    if(it%6 >= 3)\n\t\tif(spiralSpace.y > sqrt(2.) - 0.7 * smoothpowstep(0.,1.,1.-2.*abs(t-0.5), 2.))\n\t\t\tgray = 0.07; // make snake appear by adding background\n       \n   \tgray = pow(gray, 1./2.2); // gamma\n    \n    O = vec4(vec3(gray),1);\n\n    //O = vec4((spiralSpace * vec2(1./64., 1.)).yyy, 1.);\n    //O = vec4((spiralSpace * vec2(1./64., 1.)).xxx, 1.);\n    //O = vec4(spiral / 56.5,spiral / 56.5,gray,1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}