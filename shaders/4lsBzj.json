{
    "Shader": {
        "info": {
            "date": "1514164100",
            "description": "A portrait of a road with post processed rain included.\nSome simple fog in the background. Pleased with how this one turned out.",
            "flags": 32,
            "hasliked": 0,
            "id": "4lsBzj",
            "likes": 10,
            "name": "London Landscape",
            "published": 3,
            "tags": [
                "procedural",
                "sdf",
                "landscape",
                "postprocess",
                "road",
                "rain",
                "city",
                "pretty"
            ],
            "usePreview": 0,
            "username": "BeardThings",
            "viewed": 987
        },
        "renderpass": [
            {
                "code": "// From: https://www.shadertoy.com/view/lslGzl\nvec3 ToneMapping(vec3 color)\n{\n\tfloat exposure = 1.;\n\tcolor = clamp(exposure * color, 0., 1.);\n\tcolor = pow(color, vec3(1. / 2.2));\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 screenSpace = uv * 2.0 - 1.0;\n\n    vec4 bufA = texture(iChannel1, uv);\n    float depth = bufA.a;\n    fragColor = mix(bufA, vec4(0.1, 0.1, 0.1, 1.0), pow(depth, 3.5));\n    //fragColor = bufA;\n    \n    fragColor.rgb = ToneMapping(fragColor.rgb);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float Rand(in vec2 n) \n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec3 NormMap(in sampler2D channel, in vec2 uv, in float strength)\n{\n    vec2 size = vec2(strength, 0.0);\n\tconst ivec3 off = ivec3(-1,0,1);\n\n    vec4 height = texture(channel, uv);\n    float s11 = height.x;\n    float s01 = textureOffset(channel, uv, off.xy).x;\n    float s21 = textureOffset(channel, uv, off.zy).x;\n    float s10 = textureOffset(channel, uv, off.yx).x;\n    float s12 = textureOffset(channel, uv, off.yz).x;\n    vec3 va = normalize(vec3(size.xy,s21-s01));\n    vec3 vb = normalize(vec3(size.yx,s12-s10));\n    return cross(va,vb);\n}\n\nmat3 RotateX(in float theta)\n{\n    return mat3(vec3(1.0, 0, 0), vec3(0, cos(theta), sin(theta)), vec3(0, -sin(theta), cos(theta)));\n}\n\nfloat Cylinder(in vec3 p, in float r, in float h)\n{\n    return max((length(p.xz) - r), abs(p.y) - h);\n}\n\nfloat Box(in vec3 p, in vec3 b)\n{\n    vec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat Plane(in vec3 p, in vec3 n, in float dist)\n{\n    return abs(dot(p, n) - dist);\n}\n\nfloat Capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat GroundSDF(in vec3 p)\n{\n    float g = Plane(p, vec3(0,1.0,0), -1.0);\n    float s = Box(p - vec3(7.6, -0.95, 0.0), vec3(5.0, 0.075, 10.0)) - 0.03;\n    \n    return min(g,s);\n}\n\nfloat BuildingsSDF(in vec3 p)\n{\n    float b = Box(p - vec3(16.4, 5.0, -1.0), vec3(10.0, 10.0, 9.0));\n\tb = min(b, Box(p - vec3(0.0, 5.0, 25.0), vec3(10.0, 10.0, 3.0)));\n    \n    vec3 repeat = p;\n    repeat.z = mod(repeat.z - 2.5, 5.0) - 2.5;\n    float doors = Box(repeat - vec3(6.3, 0.0, -1.0), vec3(0.65, 2.0, 0.6)) - 0.01;\n    doors = min(doors, Box(repeat - vec3(5.0, 2.7, -1.0), vec3(2.0, 0.5, 0.6)) - 0.01);\n    doors = max(doors, Box(p - vec3(6.4, 5.0, -1.0), vec3(10.0, 10.0, 8.0)));\n    \n    float edge = Box(repeat - vec3(6.4, 0.0, -1.0), vec3(0.05, 3.4, 0.7)) - 0.03;\n    edge = max(edge, Box(p - vec3(6.4, 5.0, -1.0), vec3(10.0, 10.0, 8.0)));\n    \n    return max(-doors, min(edge, b));\n}\n\nfloat PillarsSDF(in vec3 p)\n{   \n    vec3 repeat = p;\n    repeat -= vec3(-2.0, -0.5, 1.0);\n    repeat.z = mod(repeat.z, 2.0) - 1.0;\n    float pillar = Capsule(repeat, vec3(0.0, -1.0, 0.0), vec3(0.0, 0.75, 0.0), 0.05);\n    \n    vec3 capsule = p;\n    capsule -= vec3(-2.0, 0.1, 1.0);\n    capsule.z = mod(capsule.z, 2.0) - 1.0;\n    pillar = min(pillar, Capsule(capsule, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.001, 0.0), 0.065));\n    \n    float boundingBox = Box(p - vec3(-2.0, 0.0, -1.0), vec3(3.0, 5.0, 6.0));\n    \n    return max(pillar, boundingBox);\n}\n\n#define Norm(SDF, p) normalize(vec3(SDF(p + vec3(0.001, 0, 0)\t) - SDF(p - vec3(0.001, 0, 0)),SDF(p + vec3(0, 0.001, 0)\t) - SDF(p - vec3(0, 0.001, 0)),SDF(p + vec3(0, 0, 0.001)\t) - SDF(p - vec3(0, 0, 0.001))))\n\nvec4 Sample(in vec3 o, in vec3 direction, in vec3 forward)\n{\n    vec4 fc = vec4(1.0);\n    \n    vec3 ld = vec3(-cos(3.1415 / 2.5), sin(3.1415 / 2.5), 0.0);\n    \n    float d = 0.0;\n    // Draw the ground\n    for(float i = 0.; i < 64.; ++i)\n    {\n        vec3 p = o + direction * d;\n\n        float sdf = GroundSDF(p);\n        // We can go further with the ground sdf since it's simple\n        d += sdf * (i / 16.);\n        \n        const float EPSILON = 0.01;\n        if(sdf < EPSILON)\n        {\n            vec3 roadColor = vec3(1.0);\n\t\t\tvec3 tiling = p;\n            \n            mat3 groundBasis = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0));\n            vec3 norm = groundBasis * NormMap(iChannel1, p.xz, 20.0);\n            \n            float evenTile = mod(floor(tiling.z / 0.3), 2.0);\n            \n            tiling.z = mod(tiling.z, 0.3) / 0.3;\n            tiling.x = mod(tiling.x + 0.4 * evenTile, 0.8) / 0.8;\n            \n            vec2 tileUV = tiling.xz;\n            vec2 shiftUV = tileUV * 2.0 - 1.0;\n            \n            float inTile = smoothstep(0.0, 0.05, length(max(abs(shiftUV) - vec2(0.9), 0.0)) - 0.055);\n            \n            float reflectionAmount = 0.3;\n            vec3 reflectionColor = pow(texture(iChannel0, reflect(direction, norm)).rgb, vec3(2.2)) * reflectionAmount;            \n            vec3 tileColor = vec3(0.03, 0.02, 0.01) + reflectionColor;\n            \n            vec2 tileIndex = vec2(floor((p.x + 0.4 * evenTile) / 0.8) + 3.0, floor(p.z / 0.3));\n            float tileSpec = pow(1.0 - ((1.0 - tileUV.x) * tileUV.y), 70.0) * step(0.8, Rand(tileIndex));\n            tileColor += vec3(tileSpec * pow(texture(iChannel1, p.xz * 2.0).r, 2.0) * 2.0);\n            \n            float distToWall = min(BuildingsSDF(p),1.0);\n            float shadow = max(distToWall, 0.3);\n            \n            float distToPillars = min(PillarsSDF(p),1.0);\n            shadow *= 1.0 - pow(1.0 - distToPillars, 15.0) * 0.8;\n            \n            roadColor = mix(tileColor, vec3(0.01, 0.01, 0.0), inTile);\n            \n            \n            fc.rgb = roadColor * max(dot(Norm(GroundSDF, p), ld), 0.0) *shadow;\n            fc.a = min((dot(p, forward) - dot(o, forward)) / 20.0, 1.0);\n            break;\n        }\n    }\n    \n    d = 0.0;\n    // Draw the buildings\n    for(float i = 0.; i < 32.; ++i)\n    {\n        vec3 p = o + direction * d;\n\n        float sdf = BuildingsSDF(p);\n        d += sdf;\n        \n        float depth = min((dot(p, forward) - dot(o, forward)) / 20.0, 1.0);\n        \n        if(depth > fc.a)\n        {\n            break;\n        }\n        \n        const float EPSILON = 0.01;\n        if(sdf < EPSILON)\n        {\n            mat3 buildingBasis = mat3(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0), vec3(-1.0, 0.0, 0.0));\n            \n            vec3 bottomTex = texture(iChannel2, p.zy / 3.0).r * vec3(0.25);\n            \n            float tileDist = mod(p.y, 0.5) / 0.5;\n            tileDist = 1.0 - pow(max(abs((tileDist * 2.0 - 1.0)), 0.0), 10.0);\n            \n            vec3 topTex = vec3(0.25, 0.15, 0.1) * tileDist;\n            float isTop = step(4.5, p.y);\n            \n            vec3 bottomNorm = Norm(BuildingsSDF, p);\n            vec3 topNorm = buildingBasis * NormMap(iChannel1, p.zy, 10.0);\n            vec3 norm = mix(bottomNorm, topNorm, isTop);\n            \n            float distToGround = pow(min(GroundSDF(p) + 0.75,1.0), 4.0);\n            float shadow = max(distToGround, 0.3);\n            \n            float isBack = step(6.5, p.x);\n            vec3 backDoor = vec3(0.1, 0.1, 0.1) * texture(iChannel0,reflect(norm, direction)).rgb;\n            \n\t\t\tfc.rgb = mix(mix(bottomTex, topTex, isTop), backDoor, isBack) * max(dot(norm, ld), 0.05) * shadow;\n            fc.a = depth;\n            break;\n        }\n    }\n    \n    d = 0.0;\n    // Draw the pillars\n    for(float i = 0.; i < 32.; ++i)\n    {\n        vec3 p = o + direction * d;\n\n        float sdf = PillarsSDF(p);\n        d += sdf;\n        \n        float depth = min((dot(p, forward) - dot(o, forward)) / 20.0, 1.0);\n        \n        if(depth > fc.a)\n        {\n            break;\n        }\n        \n        const float EPSILON = 0.001;\n        if(sdf < EPSILON)\n        {\n            vec3 norm = Norm(PillarsSDF, p);\n            vec3 pillarColor = vec3(0.1,0.1,0.1) *texture(iChannel3, p.xy).rgb;\n            vec3 goldColor = vec3(0.7, 0.6, 0.0);\n            \n            vec3 reflection = pow(texture(iChannel0, reflect(direction, norm)).rgb, vec3(2.2));\n            vec3 color = mix(goldColor * reflection, pillarColor,step(0.045, abs(p.y - 0.1)));\n            \n            float distToGround = pow(min(GroundSDF(p) + 0.75,1.0), 4.0);\n            float shadow = max(distToGround, 0.3);\n            \n\t\t\tfc.rgb = color * (max(dot(ld, norm), 0.0) + pow(dot(norm, normalize(-direction + ld)), 20.0) * 3.0) * shadow;\n            fc.a = depth;\n            break;\n        }\n    }\n\n    return fc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 screenSpace = uv * 2.0 - 1.0;\n\t\n    const float height = 0.5;\n    vec3 o = vec3(-2.2,height,-3.0);\n    vec3 t = vec3(1.0, 0.0, 0.0);\n    \n    vec3 f = normalize(t - o);\n    vec3 u = vec3(0,1,0);\n    vec3 r = normalize(cross(f, u));\n    \n    vec3 direction = normalize(f * 1.15 + \n                     r * screenSpace.x * (iResolution.x / iResolution.y) +\n                     u * screenSpace.y);\n\n    vec4 fc = Sample(o, direction, f);\n    \n    fragColor = fc;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float Rand(in vec2 n) \n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat Cylinder(in vec3 p, in float r, in float h)\n{\n    return max((length(p.xz) - r), abs(p.y) - h);\n}\n\n\nmat3 RotateZ(in float theta)\n{\n    return mat3(vec3(cos(theta), sin(theta), 0.0), vec3(-sin(theta), cos(theta),0.0),vec3(0.0, 0.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 screenSpace = uv * 2.0 - 1.0;\n    vec4 bufA = texture(iChannel0, uv);\n    float depth = bufA.a;\n    \n    const float height = 0.5;\n    vec3 o = vec3(-2.2,height,-3.0);\n    vec3 t = vec3(1.0, 0.0, 0.0);\n    \n    vec3 f = normalize(t - o);\n    vec3 u = vec3(0,1,0);\n    vec3 r = normalize(cross(f, u));\n    \n    vec3 direction = normalize(f * 1.15 + \n                     r * screenSpace.x * (iResolution.x / iResolution.y) +\n                     u * screenSpace.y);\n    \n    vec3 wp = direction / direction.z * depth * 20.0 + o;\n    \n    vec4 fc = vec4(0.0);\n    float a = 0.0;\n    \n    float d = 0.0;\n    for(float i = 0.0; i < 16.0; i+=1.0)\n    {\n        vec3 p = o + direction * d;\n        \n        float depth = min((dot(p, f) - dot(o, f)) / 20.0, 1.0);\n        \n        vec3 repeat = p;\n        repeat.xz = mod(repeat.xz, vec2(0.1)) - vec2(0.05);\n        \n        float sdf = Cylinder(repeat, 0.01, 50.0);\n        d += sdf;\n        if(sdf < 0.01)\n        {\n            vec2 index = floor(p.xz / vec2(0.1));\n            float offset = Rand(index) * 100.0;\n            \n            float rainHeight = iTime * 50.0  + offset;\n            float distanceToRain = pow(max(1.0 - distance(-mod(rainHeight, 50.0) + 40.0, p.y), 0.0), 2.0);\n            \n            if(bufA.a > depth)\n            {\n\t\t\t\tfc = vec4(vec3(0.1, 0.1, 0.15) * distanceToRain, depth);\n                a = distanceToRain * 0.5;\n            }\n            break;\n        }\n    }\n    \n    fragColor = vec4(mix(bufA.rgb, fc.rgb, a), bufA.a);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}