{
    "Shader": {
        "info": {
            "date": "1554959387",
            "description": "Me pretending to have been (or be) part of the demoscene :) Maybe I will be after attending Revision 2019 next week.",
            "flags": 64,
            "hasliked": 0,
            "id": "3sjSDK",
            "likes": 21,
            "name": "Retro cube on raster-display",
            "published": 3,
            "tags": [
                "2d",
                "retro",
                "sdf",
                "cube",
                "lines",
                "box",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 4165
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Retro cube - mimic a vectors-cube on an old CRT-display\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst vec3 red = vec3 (1.0, 0.0, 0.0);\nconst vec3 green = vec3 (0.0, 1.0, 0.0);\nconst vec3 blue = vec3 (0.0, 0.0, 1.0);\nconst vec3 white = vec3 (1.0);\nconst vec3 orange = vec3 (1.0, 0.4, 0.125);\nconst vec3 black = vec3 (0.2, 0.3, 0.2);\nconst vec3 cyan = vec3 (0.0, 1.0, 1.0);\nconst vec3 magenta = vec3 (1.0, 0.0, 1.0);\nconst vec3 yellow = vec3 (1.0, 1.0, 0.0);\nconst float SIZE = .003;\n\nfloat distLine (vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp ( dot (pa, ba) / dot (ba, ba), .0, 1.);\n    return length (pa - ba*t);\n}\n\nfloat lineMask (vec2 uv, vec2 a, vec2 b) {\n    float d = distLine (uv, a, b);\n    float thickness = SIZE;\n    return smoothstep (thickness, .125*thickness, d);\n}\n\nvec3 glowLine (vec2 uv, vec2 a, vec2 b, vec3 rgbGlow) {\n    float m = lineMask (uv, a, b);\n    float dist = distLine (uv, a, b);\n    float brightness = SIZE/pow (.085 + 2.*dist, 2.);\n    vec3 color = m*vec3 (.7);\n    color += rgbGlow*brightness;\n\treturn color;\n}\n\nstruct boxType {vec4 p[8];};\n\nmat4 trans (vec3 t)\n{\n    mat4 mat = mat4 (vec4 (1., .0, .0, .0),\n                     vec4 (.0, 1., .0, .0),\n                     vec4 (.0, .0, 1., .0),\n                     vec4 (t.x, t.y, t.z, 1.));\n    return mat;\n}\n\nmat4 rotX (float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (1., .0, .0, .0),\n                     vec4 (.0,   c,   s, .0),\n                     vec4 (.0,  -s,   c, .0),\n                     vec4 (.0, .0, .0, 1.));\n\n    return mat;\n}\n\nmat4 rotY (float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (  c, .0,  -s, .0),\n                     vec4 (.0, 1., .0, .0),\n                     vec4 (  s, .0,   c, .0),\n                     vec4 (.0, .0, .0, 1.));\n\n    return mat;\n}\n\nmat4 rotZ (float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (  c,   s, .0, .0),\n                     vec4 ( -s,   c, .0, .0),\n                     vec4 (.0, .0, 1.0, .0),\n                     vec4 (.0, .0, .0, 1.));\n\n    return mat;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord/iResolution.xy)* 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 1. + .4*length(uv);\n    uv.x += .0035*cos(40.*uv.y + 2.*iTime);\n\n    boxType box;\n    box.p[0] = vec4 ( 0.1,  0.1,  0.1, 1.0);\n    box.p[1] = vec4 ( 0.1, -0.1,  0.1, 1.0);\n    box.p[2] = vec4 (-0.1, -0.1,  0.1, 1.0);\n    box.p[3] = vec4 (-0.1,  0.1,  0.1, 1.0);\n    box.p[4] = vec4 ( 0.1,  0.1, -0.1, 1.0);\n    box.p[5] = vec4 ( 0.1, -0.1, -0.1, 1.0);\n    box.p[6] = vec4 (-0.1, -0.1, -0.1, 1.0);\n    box.p[7] = vec4 (-0.1,  0.1, -0.1, 1.0);\n\n    float t = 8. + 14.*iTime;\n    mat4 rot3d = rotX (-4.*t)*rotY (3.*t)*rotZ (2.*t);\n    mat4 model = trans (vec3 (.0, .0, -.275))*rot3d;\n    box.p[0] = model * box.p[0];\n    box.p[1] = model * box.p[1];\n    box.p[2] = model * box.p[2];\n    box.p[3] = model * box.p[3];\n    box.p[4] = model * box.p[4];\n    box.p[5] = model * box.p[5];\n    box.p[6] = model * box.p[6];\n    box.p[7] = model * box.p[7];\n\n    vec3 boxCol = glowLine (uv, box.p[0].xy / box.p[0].z, box.p[1].xy / box.p[1].z, red);\n    boxCol += glowLine (uv, box.p[1].xy / box.p[1].z, box.p[2].xy / box.p[2].z, green);\n    boxCol += glowLine (uv, box.p[2].xy / box.p[2].z, box.p[3].xy / box.p[3].z, orange);\n    boxCol += glowLine (uv, box.p[3].xy / box.p[3].z, box.p[0].xy / box.p[0].z, cyan);\n    boxCol += glowLine (uv, box.p[4].xy / box.p[4].z, box.p[5].xy / box.p[5].z, blue);\n    boxCol += glowLine (uv, box.p[5].xy / box.p[5].z, box.p[6].xy / box.p[6].z, red);\n    boxCol += glowLine (uv, box.p[6].xy / box.p[6].z, box.p[7].xy / box.p[7].z, yellow);\n    boxCol += glowLine (uv, box.p[7].xy / box.p[7].z, box.p[4].xy / box.p[4].z, green);\n    boxCol += glowLine (uv, box.p[0].xy / box.p[0].z, box.p[4].xy / box.p[4].z, blue);\n    boxCol += glowLine (uv, box.p[1].xy / box.p[1].z, box.p[5].xy / box.p[5].z, cyan);\n    boxCol += glowLine (uv, box.p[2].xy / box.p[2].z, box.p[6].xy / box.p[6].z, green);\n    boxCol += glowLine (uv, box.p[3].xy / box.p[3].z, box.p[7].xy / box.p[7].z, magenta);\n\n    boxCol = boxCol / (1. + boxCol);\n    boxCol = sqrt (boxCol);\n    boxCol *= mix (1., .5, .5 + .5*cos (500.*uv.y));\n\n    fragColor = vec4(boxCol, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 18321,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/demoscenemusic/fff-keygen-intro"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}