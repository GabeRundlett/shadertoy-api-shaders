{
    "Shader": {
        "info": {
            "date": "1725457140",
            "description": "Draw planar Coxeter group given by generators. When the angles are an integral part of pi we get a finite group. If that yields a hexagon, a square, or an equilateral triangle, we get an infinite group. Otherwise it's just a fancy kaleidoscope.",
            "flags": 0,
            "hasliked": 0,
            "id": "lfjfRd",
            "likes": 3,
            "name": "Coxeter",
            "published": 3,
            "tags": [
                "tesselation",
                "maths"
            ],
            "usePreview": 0,
            "username": "Refurio",
            "viewed": 94
        },
        "renderpass": [
            {
                "code": "////////////////////////////////\n// view port\n////////////////////////////////\nvec2 center = vec2(0.,0.);\nfloat radius = 25.;\nfloat angle = radians(0.);\n\n////////////////////////////////\n// complex arithmetic\n////////////////////////////////\nconst float pi = radians(180.);\nfloat arg(vec2 z) {\n  return atan(z.y, z.x);\n}\nvec2 cmul(vec2 a, vec2 b) {\n  return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n// see my \"Lambert w\" shader for the full set.\n\n////////////////////////////////\n// coloring functions:\n////////////////////////////////\n// https://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl\nvec3 hsv(in vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 hsv(float h, float s, float v) {\n  return hsv(vec3(h, s, v));\n}\nvec3 phase(vec2 z) {\n  return hsv(vec3(arg(z)/pi, 1., 1.));\n}\nvec3 axies(vec2 z) {\n  float t = arg(z)/pi;\n  float a = mod(2.*t+2., 2.)-1.;\n  a = abs(2.*a)-1.;\n  a = asin(a)/pi+.5;\n  return vec3(a,a,a);\n}\nvec3 white = vec3(1.,1.,1.);\nvec3 red = vec3(1.,0.,0.);\nvec3 blue = vec3(0.3,0.3,1.);\nvec3 orange = vec3(1.,.7,.2);\n\n// convert pixel coordinate to complex plane coordinate\nvec2 p2c(vec2 p) {\n  vec2 wh2 = iResolution.xy/2.;\n  float pr = min(wh2.x, wh2.y);\n  vec2 c = (p - wh2)/pr;\n  vec2 r = radius * vec2(cos(angle), sin(angle));\n  return cmul(r,c) + center;\n}\n\n\n////////////////////////////////\n// tesselation\n////////////////////////////////\n\n// generators:\n// number of generators\nconst int l = 3;\n// normal\nvec2[] n = vec2[](\n  vec2(-3,-4.),\n  vec2(0,1),\n  vec2(1,0)\n);\n// distance from origin\nfloat[] d = float[](\n  1., 1., 1.\n);\n\n// I got these from https://bulatov.org/math/180110/index.html\n// reflect\nvec2 refl(vec2 A, vec2 N, float d) {\n  return A - 2.*dot(A - d*N, N)*N;\n}\n// signed distance\nfloat dist(vec2 A, vec2 N, float d) {\n  return dot(A, N) - d;\n}\n\nint depth = 20;\nvec3 f(vec2 z) {\n  float a = (sin(iTime/5.)+1.)*pi/4.;\n  n[0] = -vec2(sin(a),cos(a));\n  int i, k;\n  for(k = 0; k < l; ++k) {\n    n[k] = normalize(n[k]);\n  }\n//  depth = int(iTime);\n//  depth = int((1.+sin(iTime*3.))*float(depth)/2.+1.);\n  for(i = 0; i < depth; ++i) {\n    for(k = 0; k < l; ++k) {\n      float r = dist(z, n[k], d[k]);\n      if(r > 0.) {\n        z = refl(z, n[k], d[k]);\n        break;\n      }\n    }\n    if(k == l)\n      break;\n  }\n  if(i == depth)\n    return white;\n//  return phase(z);\n//  return axies(z);\n  // domain coloring\n  if((i % 2) == 0)\n    return orange;\n  return blue;\n}\n\nconst float linewidth = 3.; // in pixels\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 z = p2c(fragCoord);\n  fragColor = vec4(f(z), 1.);\n  \n  float pixelwidth = min(iResolution.x,iResolution.y)/2./radius;\n  for(int k = 0; k < l; ++k) {\n    float d = abs(dist(z,n[k],d[k]));\n    float w = clamp(d/linewidth*pixelwidth, 0., 1.);\n    fragColor = w*fragColor + (1.-w)*vec4(red, 1.);\n  }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}