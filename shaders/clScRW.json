{
    "Shader": {
        "info": {
            "date": "1691878358",
            "description": "Test",
            "flags": 0,
            "hasliked": 0,
            "id": "clScRW",
            "likes": 5,
            "name": "Advanced Smoke Shader",
            "published": 3,
            "tags": [
                "test"
            ],
            "usePreview": 0,
            "username": "Oman395",
            "viewed": 272
        },
        "renderpass": [
            {
                "code": "/* Advanced Smoke Shader\nMade by Oran RH\nOman395 on shadertoy and github\n\nThis is based around how I think the CS2 smoke grenade effects work. Inspired by Acerola's work on replicating CS2 smoke grenades (video below but link is long). Relatively\nsimple, essentially the gist is that it figures out each cube that a pixel's ray passes through (and the depth that the ray travels), then adjusts the depth based\non some noise, as well as circularifying it. The bullet effect is achieved by simply adding another depth modifier to the entrance and exit, then adjusting incoming\nlight based on an approximation of the depth into the tube.\n\nTODOS:\nBetter rayBox function\nSupport for more shapes\nBetter lighting\n- Actually implementing mie scattering (or a better approximation)\n- Phong illumination\n - Normal function\n*/\n\n\n// #define SHOW_RAW\n\n// Rotate 3d vector by pitch and yaw. Not ideal but works for the camera\nvec3 rotate(vec3 vec, vec2 angles) {\n    angles = angles.yx;\n    vec = vec3(\n        vec.x,\n        vec.y * cos(angles.x) - vec.z * sin(angles.x),\n        vec.y * sin(angles.x) + vec.z * cos(angles.x)\n    );\n    vec = vec3(\n        vec.x * cos(angles.y) + vec.z * sin(angles.y),\n        vec.y,\n        -vec.x * sin(angles.y) + vec.z * cos(angles.y)\n    );\n    return vec;\n}\n\n// Rotates camera position about (0,0)\nvec3 camPos(float iTimse, vec2 iMouse) {\n    return rotate(CAM, iMouse * vec2(PI, -PI));\n}\n\n// Get camera pitch and yaw based on mouse position\nvec2 camDir(float iTime, vec2 iMouse) {\n    return iMouse * vec2(PI, -PI);\n}\n\n// Checks if a distance results in a point that is within the bounds of the target square\nbool validateDistance(float dist, vec2 r0, vec2 rd, vec2 boundMin, vec2 boundMax) {\n    vec2 np = dist * rd + r0;\n    vec2 s = step(boundMin, np) - step(boundMax, np);\n    return dist >= 0.0 && s.x * s.y > 0.0;\n}\n\n// horrible rayBox function but oh well lmao\n// Literally just checks for intersection with the 6 sides of a box\nvec2 rayBox(vec3 r0, vec3 rd, vec3 boundMin, vec3 boundMax) {\n    vec3 dMin = boundMin - r0;\n    vec3 dMax = boundMax - r0;\n    float distTop = dMax.y / rd.y;\n    float distBottom = dMin.y / rd.y;\n    float distRight = dMax.x / rd.x;\n    float distLeft = dMin.x / rd.x;\n    float distBack = dMax.z / rd.z;\n    float distFront = dMin.z / rd.z;\n    float minimum = 10000.0;\n    float maximum = 0.0;\n    if(validateDistance(distTop, r0.xz, rd.xz, boundMin.xz, boundMax.xz)) minimum = min(minimum, distTop), maximum = max(maximum, distTop);\n    if(validateDistance(distBottom, r0.xz, rd.xz, boundMin.xz, boundMax.xz)) minimum = min(minimum, distBottom), maximum = max(maximum, distBottom);\n    if(validateDistance(distRight, r0.yz, rd.yz, boundMin.yz, boundMax.yz)) minimum = min(minimum, distRight), maximum = max(maximum, distRight);\n    if(validateDistance(distLeft, r0.yz, rd.yz, boundMin.yz, boundMax.yz)) minimum = min(minimum, distLeft), maximum = max(maximum, distLeft);\n    if(validateDistance(distBack, r0.xy, rd.xy, boundMin.xy, boundMax.xy)) minimum = min(minimum, distBack), maximum = max(maximum, distBack);\n    if(validateDistance(distFront, r0.xy, rd.xy, boundMin.xy, boundMax.xy)) minimum = min(minimum, distFront), maximum = max(maximum, distFront);\n    return vec2(minimum, maximum);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Used for the bullet hole\nfloat sdTube(vec3 p) {\n    return distance(p.xy, vec2(0, -0.5)) - TUBE_RAD - cnoise(p * 10.0) * 0.03;\n}\n\n// How much the depth at the entrance, OR the exit, of a cube should be adjusted by\nfloat depthOffsetSingle(vec3 p) {\n    #ifndef SHOW_RAW\n    float off = -cnoise(p) * CUTOUT_WEIGHT * 0.7; // Smoke noise layer 1\n    off -= pow(cnoise(3.0 * (p + 4.0)), 2.0) * CUTOUT_WEIGHT * 0.2;\n    off -= pow(cnoise(3.0 * (p + 8.0)), 4.0) * CUTOUT_WEIGHT * 0.1;\n    off +=  (1.0 - distance(p, CENTER)); // Makes everything more \"sphere-like\"\n    // Note: This could be used to allow for more complex shapes; I just don't really feel like worrying about that right now\n    return off;\n    #else\n    return 0.0;\n    #endif\n}\n\n// How much the depth at the entrance, AND the exit should be adjusted by\nfloat depthOffset(vec3 pos, vec2 iD, vec3 rayDir) {\n    return depthOffsetSingle(pos + iD.x * rayDir) + depthOffsetSingle(pos + iD.y * rayDir);\n}\n\n// Used to scale up the cubes bc I was too lazy to actually change the values of the cubes xd\nvec3 scaleBoundMin(vec3 bound) {\n    bound -= 0.6;\n    return bound;\n}\n\nvec3 scaleBoundMax(vec3 bound) {\n    bound += 0.6;\n    return bound;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Set up camera\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvN = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uvN.x *= iResolution.x / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = (mouse - 0.5) * 2.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec3 pos = camPos(iTime, mouse);\n    pos.y -= 0.4;\n    vec2 dir = camDir(iTime, mouse);\n    vec3 rayDir = normalize(vec3(uvN, FOCUS));\n    rayDir = rotate(rayDir, dir);\n    \n    vec4 col = vec4(0.7);\n    vec2 iD = vec2(100000, -1); // Intercept data\n    int closestBox = -1;\n    \n    for(int i = 0; i < boxes.length(); i += 2) {\n        vec3 boundMin = scaleBoundMin(boxes[i]);\n        vec3 boundMax = scaleBoundMax(boxes[i + 1]);\n        vec2 sID = rayBox(pos, rayDir, boundMin, boundMax); // Single intercept data\n        if(sID.x > sID.y || sID.x < 0.0 || sID.y < 0.0 || depthOffset(pos, sID, rayDir) > abs(sID.y - sID.x)) continue;\n        if(iD.x > sID.x) {\n            iD.x = sID.x;\n            closestBox = i;\n        }\n        iD.y = max(sID.y, iD.y);\n        iD.y = max(sID.x, iD.y);\n    }\n    \n    // Normalize the entrance and exit points to a sphere (cut off by the floor)\n    vec3 enterPos = normalize(iD.x * rayDir + pos) * RAD;\n    vec3 exitPos = normalize(iD.y * rayDir + pos) * RAD;\n    iD.x = distance(enterPos, pos);\n    iD.y = distance(exitPos, pos);\n    \n    // Depth is reduced, then depthOffset adds to it. I found that this gave better results than just subtracting from the depth :P\n    float depth = max((iD.y - iD.x) - 0.35 + depthOffset(pos, iD, rayDir), 0.0);\n    \n    float distTubeEn = sdTube(enterPos);\n    float distTubeEx = sdTube(exitPos);\n    float enteredExternalLight = 0.0;\n    \n    if(distTubeEn < 0.0 && distTubeEx < 0.0) {\n        depth = 0.0;\n    } else if(distTubeEn < 0.0 && depth > 0.0) {\n        // Emulates how it would look to partially see through the tube\n        depth -= distTubeEn / length(rayDir.xy);\n        enteredExternalLight = 1.0 / (abs(distTubeEn * 10.0) + 1.0);\n        if(abs(distTubeEx) <= TUBE_RAD / 2.0) {\n            // A little bit of fade at the exit, I find it looks better :P\n            depth *= min(max(abs(distTubeEx / (TUBE_RAD / 2.0)), 0.0), 1.0);\n        }\n    } else {\n        enteredExternalLight = 1.0;\n    }\n    float depthMult = min(max(depth / MAX_DIST, 0.0), 1.0);\n    float heightAcc = 0.0;\n    float averageHeight = iD.x * rayDir.y * 0.5 + iD.y * rayDir.y * 0.5 + pos.y;\n    // Assumption is that more light will scatter in when height is lower (assuming the light is always on top)\n    float light = 0.0;\n    // This is NOT accurate _at all_. TODO: Figure out how mie scattering works\n    float inScatterLight = min(max((averageHeight + LIGHT_DIST * 0.5 - depth / LIGHT_DIST) / (LIGHT_DIST), 0.0), 1.0);\n    light += inScatterLight;\n    light += enteredExternalLight * 0.1; // Ambient light\n    // TODO: Normal function, actual phong illumination\n    vec4 smokeCol = SMOKE_COL_LIT * min(max(light, 0.0), 1.0) + SMOKE_COL_BASE * (1.0 - min(max(light, 0.0), 1.0));\n    smokeCol *= depthMult;\n    fragColor = vec4(0.7) * (1.0 - depthMult) + smokeCol;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec3 CAM = vec3(0,0,-5);\nconst float PI = 3.14159265;\nconst float FOCUS = 3.0;\nconst vec2 EPSILON = vec2(0.000001, 0);\n// Colors from https://www.schemecolor.com/volcano-smoke-color-scheme.php\nconst vec4 SMOKE_COL_BASE = vec4(88, 84, 83, 255) / 255.0;\nconst vec4 SMOKE_COL_LIT = vec4(172, 166, 150, 255) / 255.0;\nconst float MAX_DIST = 0.1;\nconst float LIGHT_DIST = 2.0;\nconst vec3 LIGHT = vec3(0, 1, 0);\nconst float CUTOUT_WEIGHT = 0.3;\nconst vec3 CENTER = vec3(0, -1.25, 0);\nconst float TUBE_RAD = 0.1;\nconst float RAD = 1.75;\n\n\nconst vec3 boxes[] = vec3[](\n    vec3(-0.25),\n    vec3(0.25),\n    vec3(-0.25, 0.25, -0.25),\n    vec3(0.25,0.75,0.25),\n    vec3(-0.25, -0.75, -0.25),\n    vec3(0.25,-0.25,0.25),\n    vec3(-0.75, -0.25, -0.25),\n    vec3(-0.25, 0.25, 0.25),\n    vec3(0.25, -0.25, -0.25),\n    vec3(0.75, 0.25, 0.25),\n    vec3(0.25, 0.25, -0.25),\n    vec3(0.75, 0.75, 0.25),\n    vec3(-0.75, 0.25, -0.25),\n    vec3(-0.25, 0.75, 0.25),\n    vec3(0.25, -0.75, -0.25),\n    vec3(0.75, -0.25, 0.25),\n    vec3(-0.75, -0.75, -0.25),\n    vec3(-0.25, -0.25, 0.25),\n    \n    vec3(-0.25, -0.25, 0.25),\n    vec3(0.25, 0.25, 0.75),\n    vec3(-0.25, 0.25, 0.25),\n    vec3(0.25,0.75,0.75),\n    vec3(-0.25, -0.75, 0.25),\n    vec3(0.25,-0.25,0.75),\n    vec3(-0.75, -0.25, 0.25),\n    vec3(-0.25, 0.25, 0.75),\n    vec3(0.25, -0.25, 0.25),\n    vec3(0.75, 0.25, 0.75),\n    vec3(0.25, -0.75, 0.25),\n    vec3(0.75, -0.25, 0.75),\n    vec3(-0.75, -0.75, 0.25),\n    vec3(-0.25, -0.25, 0.75),\n    \n    vec3(-0.25, -0.25, -0.75),\n    vec3(0.25, 0.25, -0.25),\n    vec3(-0.25, 0.25, -0.75),\n    vec3(0.25,0.75,-0.25),\n    vec3(-0.25, -0.75, -0.75),\n    vec3(0.25,-0.25,-0.25),\n    vec3(-0.75, -0.25, -0.75),\n    vec3(-0.25, 0.25, -0.25),\n    vec3(0.25, -0.25, -0.75),\n    vec3(0.75, 0.25, -0.25),\n    vec3(0.25, -0.75, -0.75),\n    vec3(0.75, -0.25, -0.25),\n    vec3(-0.75, -0.75, -0.75),\n    vec3(-0.25, -0.25, -0.25),\n    \n    vec3(-1.25, -0.75, -0.25),\n    vec3(-0.75, -0.25, 0.25),\n    \n    vec3(0.75, -0.75, -0.25),\n    vec3(1.25, -0.25, 0.25),\n    \n    vec3(-0.25, -0.75, -1.25),\n    vec3(0.25, -0.25, -0.75),\n    \n    vec3(-0.25, -0.75, 0.75),\n    vec3(0.25, -0.25, 1.25),\n    \n    vec3(-0.75, -0.75, -1.25),\n    vec3(-0.25, -0.25, -0.75),\n    \n    vec3(0.25, -0.75, -1.25),\n    vec3(0.75, -0.25, -0.75),\n    \n    vec3(-0.75, -0.75, 0.75),\n    vec3(-0.25, -0.25, 1.25),\n    \n    vec3(0.25, -0.75, 0.75),\n    vec3(0.75, -0.25, 1.25),\n    \n    vec3(-1.25, -0.75, -0.75),\n    vec3(-0.75, -0.25, -0.25),\n    \n    vec3(0.75, -0.75, -0.75),\n    vec3(1.25, -0.25, -0.25),\n    \n    \n    vec3(-1.25, -0.75, 0.25),\n    vec3(-0.75, -0.25, 0.75),\n    \n    vec3(0.75, -0.75, 0.25),\n    vec3(1.25, -0.25, 0.75),\n    \n    vec3(-1.25, -0.25, -0.25),\n    vec3(-0.75, 0.25, 0.25),\n    \n    vec3(0.75, -0.25, -0.25),\n    vec3(1.25, 0.25, 0.25),\n    \n    vec3(-0.25, -0.25, -1.25),\n    vec3(0.25, 0.25, -0.75),\n    \n    vec3(-0.25, -0.25, 0.75),\n    vec3(0.25, 0.25, 1.25)\n);\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//  https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}