{
    "Shader": {
        "info": {
            "date": "1505944037",
            "description": "Compressing normals by octahedral projection, and comparing storage space between 2 and 32 bits. See [url]http://www.vis.uni-stuttgart.de/~engelhts/paper/vmvOctaMaps.pdf[/url]. Compare to Fibonacci: [url]https://www.shadertoy.com/view/4t2XWK[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "Mtfyzl",
            "likes": 48,
            "name": "Normals Compression - Octahedron",
            "published": 3,
            "tags": [
                "3d",
                "normals",
                "compression"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 3289
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Compressing normals by octahedral projection. The number on the top\n// right is the number of bits used to store the hole normal, not each\n// component. In this case anything above 18 bits looks pretty decent!\n// See http://www.vis.uni-stuttgart.de/~engelhts/paper/vmvOctaMaps.pdf\n//\n// Compare to Fibonacci: https://www.shadertoy.com/view/4t2XWK\n\n\n\n// copy sign of s into value x\nvec2 copysign(float x, vec2 s)\n{\n    uint ix = floatBitsToUint(x)&0x7fffffffu;\n    return vec2( uintBitsToFloat((floatBitsToUint(s.x)&0x80000000u)|ix),\n                 uintBitsToFloat((floatBitsToUint(s.y)&0x80000000u)|ix) );\n}\n// same as above, if we know x is non-negative\nvec2 copysignp(float x, vec2 s)\n{\n    uint ix = floatBitsToUint(x);\n    return vec2( uintBitsToFloat((floatBitsToUint(s.x)&0x80000000u)|ix),\n                 uintBitsToFloat((floatBitsToUint(s.y)&0x80000000u)|ix) );\n}\n\n\nuint octahedral_32( in vec3 nor, uint sh )\n{\n    nor /= ( abs( nor.x ) + abs( nor.y ) + abs( nor.z ) );\n    nor.xy = (nor.z >= 0.0) ? nor.xy : (1.0-abs(nor.yx))*sign(nor.xy);\n    vec2 v = 0.5 + 0.5*nor.xy;\n\n    uint mu = (1u<<sh)-1u;\n    uvec2 d = uvec2(floor(v*float(mu)+0.5));\n    return (d.y<<sh)|d.x;\n}\n\nvec3 i_octahedral_32( uint data, uint sh )\n{\n    uint mu =(1u<<sh)-1u;\n    \n    uvec2 d = uvec2( data, data>>sh ) & mu;\n    vec2 v = vec2(d)/float(mu);\n    \n    v = -1.0 + 2.0*v;\n#if 0\n    // Rune Stubbe's version, much faster than original\n    vec3 nor = vec3(v, 1.0 - abs(v.x) - abs(v.y));\n    float t = max(-nor.z,0.0);\n    nor.x += (nor.x>0.0)?-t:t;\n    nor.y += (nor.y>0.0)?-t:t;\n#endif\n#if 1\n    // is there was a copysign() in GLSL...\n    vec3 nor = vec3(v, 1.0 - abs(v.x) - abs(v.y));\n    nor.xy -= copysignp(max(-nor.z,0.0),nor.xy);\n#endif\n#if 0\n    // original\n    vec3 nor;\n    nor.z = 1.0 - abs(v.x) - abs(v.y);\n    nor.xy = (nor.z>=0.0) ? v.xy : (1.0-abs(v.yx))*sign(v.xy);\n#endif    \n    return normalize( nor );\n}\n\n//=================================================================================================\n// digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n//=================================================================================================\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt( in vec2 uv, in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0+ceil(.01+log2(value)/log2(10.0));\n\tfloat digitID = floor(uv.x);\n\tif( digitID>0.0 && digitID<maxDigits )\n\t{\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n\t}\n\n\treturn res;\t\n}\n\n//=================================================================================================\n// all iq code below\n//=================================================================================================\n\nfloat map( vec3 p )\n{\n    p.xz *= 0.8;\n    p.xyz += 1.000*sin(  2.0*p.yzx );\n    p.xyz -= 0.500*sin(  4.0*p.yzx );\n    float d = length( p.xyz ) - 1.5;\n\treturn d * 0.25;\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 7.0;\n\n\tfloat precis = 0.001;\n    float h = 1.0;\n    float t = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n        if( (h<precis) || (t>maxd) ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\treturn t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    // from Paul Malin (4 samples only in a tetrahedron\t\n    vec2 e = vec2(1.0,-1.0)*0.002;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n\tvec2 q = fragCoord/iResolution.xy;\n\t\n    //-----------------------------------------------------\n\n    float ti = mod( 0.25*iTime, 8.0 );\n    float am = clamp( ti/3.0, 0.0, 1.0 ) - clamp( (ti-4.0)/3.0, 0.0, 1.0 );\n    uint precis = 1u + uint(floor(15.0*am));\n    \n    //-----------------------------------------------------\n\t\n\tfloat an = 4.0 + 0.1*iTime*2.0;\n    \n\tvec3 ro = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    vec3 ta = vec3(0.0,0.0,0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = normalize( ca * vec3(p,-1.5) );\n\n    //-----------------------------------------------------\n    \n\tvec3 col = vec3(0.07)*clamp(1.0-length(q-0.5),0.0,1.0);\n\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n        vec3 sor = nor;\n        \n        // compress normal\n        uint id = octahedral_32( nor, precis );\n        \n        // decompress normal\n        nor = i_octahedral_32( id, precis);\n        \n        nor = (p.x>0.0) ? nor : sor;\n\n        // material\n\t\tcol = vec3(0.2);\n        col *= 1.0 + 0.5*nor;\n        \n\t\t// lighting\n        float sky = 0.5 + 0.5*nor.y;\n        float fre = clamp( 1.0 + dot(nor,rd), 0.0, 1.0 );\n        float spe = pow(max( dot(-rd,nor),0.0),32.0);\n\t\t// lights\n\t\tvec3 lin  = vec3(0.0);\n\t\t     lin += 3.0*vec3(0.7,0.80,1.00)*sky;\n        \t lin += 8.0*vec3(0.7,0.8,1.00)*smoothstep(0.0,0.2,ref.y)*(0.1+0.9*pow(fre,5.0))*sky;\n             lin += 1.0*fre*vec3(1.0,0.90,0.80);\n        col = col * lin;\n        col += 0.50*spe;\n        col += 0.15*spe*spe*spe;\n\t}\n\n\tcol = sqrt(col);\n    \n    col += PrintInt( (q-vec2(0.75,0.8))*12.0*vec2(1.0,iResolution.y/iResolution.x), float(2u*precis) );\n\n    col *= smoothstep( 0.003,0.004,abs(q.x-0.5) );\n\n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}