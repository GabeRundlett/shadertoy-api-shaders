{
    "Shader": {
        "info": {
            "date": "1465543441",
            "description": "Planarity clone made in GLSL. Goal: move blue circles so that there are no intersections (no red lines). When a graph is solved you can move to the next level by clicking a button in bottom right corner. Graphs are difficult but guaranteed to be solvable.",
            "flags": 32,
            "hasliked": 0,
            "id": "XdKSRV",
            "likes": 46,
            "name": "glslanarity",
            "published": 3,
            "tags": [
                "2d",
                "game",
                "puzzle",
                "planarity"
            ],
            "usePreview": 0,
            "username": "w23",
            "viewed": 1923
        },
        "renderpass": [
            {
                "code": "const float C_LINE_STATE = 0.;\nconst float C_LINE_NODES = 1.;\nconst float C_LINE_EDGES = 2.;\nconst float C_MAX_NODES = 64.;\nconst float C_MAX_EDGES = 256.;\nconst float C_NODE_RADIUS = .04;\n\n#define g_aspect (iResolution.x / iResolution.y)\nfloat g_level_button_r = .1;\n#define g_next_button_pos vec2(g_aspect - g_level_button_r * 1.5, - 1. + g_level_button_r * 1.5)\n#define g_prev_button_pos vec2(-g_aspect + g_level_button_r * 1.5, - 1. + g_level_button_r * 1.5)\n\nvec4 readGameState(float line, float index) {\n    return texture(iChannel0, (vec2(line, index) + .5) / iChannelResolution[0].xy, -20.);\n}\n\n#define pixelsize (1. / min(iResolution.x, iResolution.y))\n\nfloat dCircle(vec2 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat dLine(vec2 p, vec2 a, vec2 b, float r) {\n    vec2 d = b - a;\n    float l2 = dot(d, d);\n    if (l2 == 0.) return length(a - p);\n    float t = max(0., min(1., dot(p - a, d) / l2));\n    return length(a + t * d - p) - r;\n}\n\nfloat aa(float d) { return smoothstep(4.*pixelsize, 0., d); }\n\nvec4 cNode(vec2 p, vec2 c) {\n   \tp -= c;\n    \n    vec4 color = vec4(0.);\n    color = mix(color, vec4(.2,.2,.2,1.), aa(dCircle(p, C_NODE_RADIUS)));\n    color = mix(color, vec4(.3,.3,1.,1.), aa(dCircle(p, C_NODE_RADIUS-.01)));\n    return color;\n}\n\nvec4 cArrowButton(vec2 p) {\n    vec4 color = vec4(0.);\n    color = mix(color, vec4(.0,.0,.0,1.), aa(dCircle(p, g_level_button_r)));\n    color = mix(color, vec4(1.,1.,1.,1.), aa(dCircle(p, g_level_button_r-.02)));\n    color = mix(color, vec4(.4,.8,.4,1.), aa(dLine(p, vec2(g_level_button_r*.4, 0.), vec2(-g_level_button_r*.3,g_level_button_r*.4), .01)));\n    color = mix(color, vec4(.4,.8,.4,1.), aa(dLine(p, vec2(g_level_button_r*.4, 0.), vec2(-g_level_button_r*.3,-g_level_button_r*.4), .01)));\n    return color;\n}\n\nvec2 mapToWorld(vec2 screen) {\n\treturn (screen / iResolution.xy * 2. - 1.) * vec2(g_aspect, 1.);\n}\n\nconst float\n    C_A = 434073., C_B = 497559., C_C = 397590., C_D = 498071.,\n\tC_E = 988959., C_F = 988945., C_G = 400790., C_H = 630681.,\n\tC_I = 467495., C_J = 467491., C_K = 611161., C_L = 69919.,\n\tC_M = 653721., C_N = 638361., C_O = 432534., C_P = 497425.,\n\tC_Q = 432606., C_R = 497497., C_S = 923271., C_T = 991778.,\n\tC_U = 629142., C_V = 629075., C_W = 646615., C_X = 628377.,\n\tC_Y = 628292., C_Z = 1016879., C_1 = 291919., C_2 = 493087.,\n\tC_3 = 495239., C_4 = 630408., C_5 = 988807., C_6 = 272278.,\n\tC_7 = 1016900., C_8 = 431766., C_9 = 433730., C_0 = 433590.,\n    C_dot = 1024.;\n\nfloat gB(in float g, in vec2 gp){\n    return (gp.x<4.&&gp.y<5.) ? mod(floor(g / pow(2., gp.y*4. + gp.x)), 2.) : 0.;\n}\n\n#define PUTC(g) if(pc.x==lx){col=gB(g,pg);}lx+=1.\n\nfloat diGlyph(in float di) {\n    if (di == 0.) return C_0;\n    if (di == 1.) return C_1;\n    if (di == 2.) return C_2;\n    if (di == 3.) return C_3;\n    if (di == 4.) return C_4;\n    if (di == 5.) return C_5;\n    if (di == 6.) return C_6;\n    if (di == 7.) return C_7;\n    if (di == 8.) return C_8;\n    if (di == 9.) return C_9;\n    return C_E;\n}\n\nvoid printInt(in float num, in vec2 pg, in vec2 pc, inout float lx, inout float col) {\n    /*if (num < 0.) {\n        PUTC(C_N);\n        num *= -1.;\n    } else {\n    \tPUTC(diGlyph(mod(floor(num/1000.),10.)));\n    }*/\n    if (num >= 1000.) { PUTC(diGlyph(mod(floor(num/1000.),10.))); }\n    if (num >= 100.) { PUTC(diGlyph(mod(floor(num/100.),10.))); }\n    if (num >= 10.) { PUTC(diGlyph(mod(floor(num/10.),10.))); }\n    PUTC(diGlyph(mod(floor(num),10.)));\n}\n\nfloat printText(in vec2 p, in float level, in float time, in float intersections) {\n#define PIXSZ 2.\n    p = floor(p / PIXSZ);\n    vec2 pc = floor(p / vec2(5.,6.));\n    vec2 pg = mod(p, vec2(5.,6.));\n    float lx = 1.;\n    float col = 0.;\n\n#define PUTN(n) printInt(n,pg,pc,lx,col)\n    if (pc.y == 2.) {\n    \tPUTC(C_L);PUTC(C_E);PUTC(C_V);PUTC(C_E);PUTC(C_L);PUTC(0.);PUTN(level);\n    //} else if (pc.y == 2.) {\n    //\tPUTC(C_T);PUTC(C_I);PUTC(C_M);PUTC(C_E);PUTC(0.);PUTN(time);PUTC(C_dot);PUTN(fract(time)*100.);\n    } else if (pc.y == 1.) {\n        PUTC(C_I);PUTC(C_N);PUTC(C_T);PUTC(C_E);PUTC(C_R);\n        PUTC(C_S);PUTC(C_E);PUTC(C_C);PUTC(C_T);PUTC(C_I);\n        PUTC(C_O);PUTC(C_N);PUTC(C_S);PUTC(0.);PUTN(intersections);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tfloat t = iTime;\n    vec2 p = mapToWorld(fragCoord);\n    \n    vec4 game_state = readGameState(C_LINE_STATE, 0.);\n    float nodes = game_state.y;\n    float edges = game_state.z;\n    \n    vec3 color = vec3(1.);\n    \n    vec4 mouse = readGameState(C_LINE_STATE, 1.);\n    \n    for (float i = 0.; i < C_MAX_EDGES; ++i) {\n        if (i >= edges) break;\n        vec4 edge = readGameState(C_LINE_EDGES, i);\n        vec2 n1 = readGameState(C_LINE_NODES, edge.x).xy;\n        vec2 n2 = readGameState(C_LINE_NODES, edge.y).xy;\n        vec3 linecolor = (edge.w > 0.) ? vec3(1.,0.,0.) : vec3(0.);\n        color = mix(color, linecolor, aa(dLine(p, n1, n2, .0001/*2. * pixelsize*/)));\n    }\n    \n    for (float i = 0.; i < C_MAX_NODES; ++i) {\n        if (i >= nodes) break;\n        vec4 node = readGameState(C_LINE_NODES, i);\n        vec4 node_color = cNode(p, node.xy);\n        color = mix(color, node_color.rgb, node_color.a);\n    }\n    \n    vec4 bcolor = cArrowButton(p - g_next_button_pos);\n    color = mix(color, bcolor.rgb, bcolor.a*((game_state.x < 15. && game_state.w == 1.) ? .8 : .1));\n    //bcolor = cArrowButton((p - g_prev_button_pos)*vec2(-1.,1));\n    //color = mix(color, bcolor.rgb, bcolor.a*(game_state.x > 1. ? .8 : .1));\n    \n    color = mix(color, vec3(0.), printText(fragCoord, game_state.x, iTime, (game_state.w - 1.)/2.));\n\n\tfragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float C_PI = 3.1415926;\nconst float C_LINE_STATE = 0.;\nconst float C_LINE_NODES = 1.;\nconst float C_LINE_EDGES = 2.;\nconst float C_MAX_NODES = 64.;\nconst float C_MAX_EDGES = 256.;\nconst float C_NODE_RADIUS = .04;\n\n#define g_aspect (iResolution.x / iResolution.y)\nfloat g_level_button_r = .1;\n#define g_next_button_pos vec2(g_aspect - g_level_button_r * 1.5, - 1. + g_level_button_r * 1.5)\n#define g_prev_button_pos vec2(-g_aspect + g_level_button_r * 1.5, - 1. + g_level_button_r * 1.5)\nvec4 readGameState(in float line, in float index) {\n    return texture(iChannel0, (vec2(line, index) + .5) / iChannelResolution[0].xy, -20.);\n}\n\nfloat cross2(in vec2 a, in vec2 b) { return a.x * b.y - b.x * a.y; }\nfloat orient(in vec2 a, in vec2 b, in vec2 c) { return cross2(b - a, c - b); } \nbool lineSegmentIntersect(in vec2 a1, in vec2 a2, in vec2 b1, in vec2 b2) {\n    // HACK: do not intersect at nodes\n    vec2 da = 1e-5 * normalize(a2 - a1); a1 += da; a2 -= da;\n    vec2 db = 1e-5 * normalize(b2 - b1); b1 += db; b2 -= db;\n    return sign(orient(a1, a2, b1)) != sign(orient(a1, a2, b2))\n        && sign(orient(b1, b2, a1)) != sign(orient(b1, b2, a2));\n}\n\nfloat g_level = 0.;\nfloat g_level_nodes = 0.;\nfloat g_level_edges = 0.;\n\nbool g_mouse_up = false;\nbool g_mouse_down = false;\nvec2 g_mouse_pos = vec2(0.);\nvec2 g_mouse_move = vec2(0.);\n\nvec4 generateNode(float index) {\n    // make initial circle edges less regular\n    index = mod(index*89., g_level_nodes);\n    \n    // distribute nodes evenly on a circle\n    float a = index / g_level_nodes * C_PI * 2.;\n    float r = .8 + .1 * sin(a * g_level);\n   \treturn vec4(r * cos(a), r * sin(a), 0., 0.);\n}\n\n// make a planar graph in purely functional way\n// edges are made so that it would correspond to an already planarized graph.\n// to make things simple for an (almost) arbitrary number of nodes, i use\n// a structure of nested squares. calculating nodes indexes is simple for it.\nvec4 generateEdge(float index) {\n    // zero layer is a special quad\n    if (index < 4.) return vec4(index, mod(index + 1., 4.), 1., 1.);\n    index -= 4.;\n\n    // make nested layers interconnections\n    // each node is connected to the next one in current layer\n    // and to two nodes in previous layer: its counterpart and to next counterpart\n    \n    // pick connection based on current index\n    float mode = mod(index, 3.);\n    float node = 4. + floor(index / 3.);\n    \n    // connect to this node counterpart in previous layer\n\tif (mode == 0.) return vec4(node, node - 4., 1., 1.);\n\n    // dark magic! :D\n    float layer = floor(index / 12.) + 1.;\n    float layer_base = layer * 4.;\n    float layer_node = node - layer_base;\n    float next_node = mod(layer_node + 1., 4.);\n    \n    // connect to next counterpart in previous layer\n    if (mode == 1.) return vec4(node, layer_base - 4. + next_node, 1., 1.);\n    \n    // connect to next in this layer\n    return vec4(node, layer_base + next_node, 1., 1.);\n}\n\nvec4 processNode(vec4 prev, float index) {\n    if (g_mouse_down) {\n        prev.z = step(length(prev.xy - g_mouse_pos), C_NODE_RADIUS); // selecte\n    }\n    // move selected\n    if (prev.z > 0.) {\n        prev.xy += g_mouse_move;\n    }\n    return prev;\n}\n\nvec4 processEdge(vec4 prev, float index) {\n    if (prev.z != 1.) return vec4(0.);\n    prev.w = 0.;\n    vec2 n1 = readGameState(C_LINE_NODES, prev.x).xy;\n    vec2 n2 = readGameState(C_LINE_NODES, prev.y).xy;\n    \n    // find and count intersections\n    for (float i = 0.; i < C_MAX_EDGES; ++i) {\n        if (i >= g_level_edges) break;\n        if (i == index) continue;\n        vec4 edge = readGameState(C_LINE_EDGES, i);\n        if (edge.z != 1.) continue;\n        vec2 on1 = readGameState(C_LINE_NODES, edge.x).xy;\n        vec2 on2 = readGameState(C_LINE_NODES, edge.y).xy;\n        prev.w += lineSegmentIntersect(n1, n2, on1, on2) ? 1. : 0.;\n    }\n    return prev;\n}\n\nvec2 mapToWorld(vec2 screen) {\n\treturn (screen / iResolution.xy * 2. - 1.) * vec2(g_aspect, 1.);\n}\n\nfloat levelAdvancePressed() {\n    if (g_mouse_down) {\n    \tif (length(g_mouse_pos - g_next_button_pos) < g_level_button_r) return 1.;\n    \t//if (length(g_mouse_pos - g_prev_button_pos) < g_level_button_r) return -1.;\n    }\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n\n    float line = floor(fragCoord.x);\n    float index = floor(fragCoord.y);\n\n    vec4 prev_state = readGameState(C_LINE_STATE, 0.);\n    vec4 prev_mouse = readGameState(C_LINE_STATE, 1.);\n    \n    bool should_generate = false;\n    \n    if (iFrame == 0 || prev_state.w == 0.) {\n        prev_state = prev_mouse = vec4(0.);\n        should_generate = true;\n    }\n\n    vec2 mouse_pos = mapToWorld(iMouse.xy);\n    bool clicked = iMouse.z > 0.;\n\n    g_mouse_down = clicked && prev_mouse.z == 0.;\n    g_mouse_up = !clicked && prev_mouse.z == 1.;\n    g_mouse_pos = mouse_pos;\n    g_mouse_move = prev_mouse.z * (mouse_pos - prev_mouse.xy);\n    \n    g_level = prev_state.x;\n    g_level_nodes = prev_state.y;\n    g_level_edges = prev_state.z;\n\n    float intersections = 0.;\n    for (float i = 0.; i < C_MAX_EDGES; ++i) {\n        if (i >= g_level_edges) break;\n       \tvec4 edge = readGameState(C_LINE_EDGES, i);\n        if (edge.z != 1.) continue;\n        intersections += edge.w;\n    }\n\n    float level_advance = levelAdvancePressed();\n    if (intersections != 0. && level_advance > 0.) level_advance = 0.;\n\n    if (line == C_LINE_STATE && index == 1.) {\n        fragColor = vec4(mouse_pos, clicked ? 1. : 0., 0.);\n    } else if (should_generate || level_advance != 0.) {\n        g_level = clamp(1., prev_state.x + level_advance, 15.);\n        g_level_nodes = min(4. + g_level * 4., C_MAX_NODES);\n        g_level_edges = min(4. + (g_level_nodes - 4.) * 3., C_MAX_EDGES);\n\n\t\tif (line == C_LINE_NODES && index < g_level_nodes) {\n            fragColor = generateNode(index);\n        } else if (line == C_LINE_EDGES && index < g_level_edges) {\n            fragColor = generateEdge(index);\n        }\n    } else {\n        fragColor = readGameState(line, index);\n\n        if (line == C_LINE_NODES && index < g_level_nodes) {\n            fragColor = processNode(fragColor, index);\n        } else if (line == C_LINE_EDGES && index < g_level_edges) {\n            fragColor = processEdge(fragColor, index);\n        }\n    }\n    if (line == C_LINE_STATE && index == 0.) {\n        fragColor = vec4(g_level, g_level_nodes, g_level_edges, 1. + intersections);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}