{
    "Shader": {
        "info": {
            "date": "1670452330",
            "description": "Day 16 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou",
            "flags": 0,
            "hasliked": 0,
            "id": "DdjSzm",
            "likes": 3,
            "name": "Codevember #16 Vasarely",
            "published": 3,
            "tags": [
                "motion",
                "vasarely",
                "codevember"
            ],
            "usePreview": 0,
            "username": "Etidou",
            "viewed": 112
        },
        "renderpass": [
            {
                "code": "// Inspiration : https://www.shadertoy.com/view/WllcWj\n\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n\n#define DIVS 20.0\n#define SMOOTH 0.02\n\nvec2 r2d (vec2 v, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy-.5;\n    uv.x*= iResolution.x / iResolution.y;\n    \n    // space is divided into a grid\n    vec2 div = uv * DIVS;\n    vec2 sq = fract(div) - .35;\n    vec2 id = floor(div);\n    \n    // rotation of some squares given their distance to 2 moving points\n    float rot = 0.;\n    \n    vec2 p1 = vec2(cos(iTime*1.) * sin(iTime*1.4) * .2, sin(iTime*1.) * .5);\n    vec2 dr = p1 - id/DIVS;\n    float lp1 = smoothstep(0.4, -.01, abs(dr.x));\n    lp1*= smoothstep(0.4, -.1, abs(dr.y));\n    rot+= lp1 * cos(iTime) * cos(iTime*2.+4.) * cos(iTime*8.-0.2) * 8.;\n    \n    \n    vec2 p2 = vec2(cos(iTime*1.3 + 2.) * cos(iTime*.2+6.) * .3, sin(iTime*2. + 1.) * .35);\n    dr = p2 - id/DIVS;\n    float lp2 = smoothstep(0.4, -.01, abs(dr.x));\n    lp2*= smoothstep(0.4, -.1, abs(dr.y));\n    rot+= lp2 * cos(iTime) * cos(iTime*1.+4.6) * cos(iTime*12.+.7) * 4.;\n\n    \n    // rotate some of the divs\n    sq = r2d((sq - 0.15), rot);\n    \n    // the inner rectangle\n    vec2 asq = abs(sq + 0.25);\n    float s = sqrt(2. * pow(.5*.65, 2.));\n    float rect = smoothstep(s+SMOOTH, s-SMOOTH, (asq.x + 0.15)) * smoothstep(s+SMOOTH, s-SMOOTH, (asq.y + 0.15));\n    \n\n    // half is inverted\n    // rect = mix(rect, 1. - rect, sign(p2.y) * sign(p1.y) * sign(uv.y)*.5+.5);\n    vec3 col = vec3(rect, rect, rect);\n    \n    // we step on x to only have a visible square\n    float visible = step(uv.x, .5) * step(-.5, uv.x);\n    // and the outer cells\n    visible*= step(abs(id.x), DIVS*.5);\n    visible*= step(abs(id.y+.5), DIVS*.5);\n    \n    col*= visible;\n    \n    // // the background\n    // col+= 1. - visible;\n    // col*= clamp(pow(max(0., (1.-length(uv))), .2)* 1.1, .2, 1.) + visible;\n\n    col.b*= 0.12;\n    \n    \n    // we add the dots\n    // col.r+= smoothstep(0.4, 0.015, (length(p1 - uv) + 0.2));\n    // col.r+= smoothstep(0.4, 0.015, (length(p2 - uv) + 0.2));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}