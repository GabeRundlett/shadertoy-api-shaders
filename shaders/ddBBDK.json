{
    "Shader": {
        "info": {
            "date": "1690137271",
            "description": "CC0: Avoiding overestimation \nInspired by: https://www.shadertoy.com/view/WtXcWB\n\nWatched blackie's youtube on the estimating the distance field of grid\nwhere each object in the cell is differently sized which typically leads\nto artifacts\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ddBBDK",
            "likes": 13,
            "name": "Avoiding overestimation ",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 341
        },
        "renderpass": [
            {
                "code": "// CC0: Avoiding overestimation \n// Inspired by: https://www.shadertoy.com/view/WtXcWB\n\n// Watched blackie's youtube on the estimating the distance field of grid\n// where each object in the cell is differently sized which typically leads\n// to artifacts (or fine tuning of the step size).\n\n// I thought I try adapt the approach to also utilize the ray direction as\n// I figured that it's only in the ray direction we have to make sure not\n// to over estimate\n\n// Like blackie I try to compute the nearest neighbour but with the twist \n// to only consider cells in the ray direction.\n\n// In addition, it turned out that I needed to also consider the cells that \n// touch the corner to not overestimate when I get in the corner near the edges\n\n// My hope is that this also eliminates artifacts as well as being cheap enough\n// to be useful\n\n// I thought it was rather interesting to do so sharing in case some find \n// something useful in the idea.\n\n#define TIME_MULT   0.0\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define SCA(a)      vec2(sin(a), cos(a))\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat pie( in vec2 p, in vec2 c, in float r ) {\n  p.x = abs(p.x);\n  float l = length(p) - r;\n  float m = length(p-c*clamp(dot(p,c),0.0,r)); // c=sin/cos of aperture\n  return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b ) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nconst float z = 0.2;\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  co += 123.4;\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec2 g_thing_edge    = vec2(0.0);\nvec2 g_thing_ird    = vec2(0.0);\nvec3 g_thing_step   = vec3(0.0);\nmat2 g_thing_rot    = mat2(1.0);\nvec2 g_ro     = vec2(0.0);\nvec2 g_la     = vec2(0.0);\nmat2 g_pie_rot= mat2(1.0);\n\nfloat dobj(vec2 p, float h) {\n  float w = 0.45*mix(0.1, 1.0, h);\n  //return box(p, vec2(w-0.1))-0.1;\n  return length(p)-w;\n}\n\nfloat drep(vec2 p) {\n  p -= 0.5;\n\n  // Compute the the object in the current cell\n  vec2 c0   = round(p);\n  float h0  = hash(c0);\n  vec2 p0   = p-c0;\n\n  // Let's figure out the which adjacent cell that is the nearest with respect to the ray direction\n  vec2 t1   = (g_thing_edge-p0)*g_thing_ird;\n  vec2 c1   = c0 + (t1.x < t1.y ? g_thing_step.xz : g_thing_step.zy); \n  float h1  = hash(c1);\n  vec2 p1   = p-c1;\n\n  // Also consider the diagonal cell for those cases when we step past the adjacent cell\n  vec2 c2 = c0 + g_thing_step.xy;\n  float h2  = hash(c2);\n  vec2 p2   = p-c2;\n\n  float d0 = dobj(p0, h0);\n  float d1 = dobj(p1, h1);\n  float d2 = dobj(p2, h2);\n  \n  float d = d0;\n  d = min(d, d1);\n  d = min(d, d2);\n  return d;\n}\n\nfloat dthing(vec2 p) {\n  p *= g_thing_rot;\n  float d0 = drep(p/z)*z;\n  float d1 = box(p, vec2(4.0*z));\n  float d = d0;\n  d = max(d, d1);\n  return d;\n}\n\nvec4 df(vec2 p) {\n  const vec2 cone = SCA(PI/4.0);\n  float d0 = dthing(p);\n  float r1 = dthing(g_ro);\n  float d1 = pie(g_pie_rot*(p-g_ro), cone, r1);\n  float d2 = length(p-g_la)-0.1;\n  d2 = abs(d2) - 0.005;\n  float d3 = segment(p, g_ro, g_la)-0.005;\n  vec4 d = vec4(d0, d1, d2, d3);\n  return d;\n}\n\nvec3 effect(vec2 p) {\n  float aa      = 4.0/RESOLUTION.y;\n  float tm      = TIME_MULT*TIME;\n  mat2 rot      = ROT(sin(tm)+tm);\n\n  vec2 rd       = (normalize(g_la-g_ro));\n\n  g_pie_rot     = ROT(PI/2.0)*transpose(mat2(rd.x, rd.y, -rd.y, rd.x));\n  rd *= rot;\n  vec2 srd      = sign(rd);\n\n  g_thing_rot   = rot;\n  g_thing_edge  = srd*vec2(0.5);\n  g_thing_step  = vec3(srd, 0.0)*vec3(1.0, 1.0, 0.0);\n  g_thing_ird   = 1.0/rd;\n\n  vec4 d = df(p);\n  vec3 col = vec3(0.0);\n  const vec3 bcol = vec3(1.0, 0.125, 0.25); \n  vec3 gcol = mix(sqrt(bcol), sqrt(bcol).yzx, 0.5*(sign(-d.x)+1.0));\n  col += gcol*mix(0.125, 1.0, smoothstep(-0.5, 0.5, sin(TAU*d.x/(3.0*aa))))*mix(0.125, 1.0, exp(-20.0*abs(d.x)));\n  col = mix(col, bcol.xxx, smoothstep(0.0, -aa, abs(d.x)-aa));\n  col = mix(col, bcol.yzx, smoothstep(0.0, -aa, d.w));\n  col = mix(col, bcol.zxy, smoothstep(0.0, -aa, d.z));\n  col = mix(col, bcol.xzy, smoothstep(0.0, -aa, d.y));\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  float r = RESOLUTION.x/RESOLUTION.y; \n  p.x *= r;\n  g_ro = (-1.0+2.0*iMouse.xy/RESOLUTION.xy)*vec2(r, 1.0);\n  vec3 col = effect(p);\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}