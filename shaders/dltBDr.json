{
    "Shader": {
        "info": {
            "date": "1701163286",
            "description": "Entirely inspired by Keenan Crane et al. ACM SIGGRAPH paper \"Winding Numbers on Discrete Surfaces\"\n\nI know my implementation is buggy. I wrote it in 1 night.\n\n[url]https://www.youtube.com/watch?v=3undxB8rcvE[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "dltBDr",
            "likes": 4,
            "name": "Winding Numbers: Stokes' Theorem",
            "published": 3,
            "tags": [
                "windingnumber",
                "swn",
                "stokestheorem"
            ],
            "usePreview": 0,
            "username": "cmarangu",
            "viewed": 194
        },
        "renderpass": [
            {
                "code": "// Winding Numbers: Stokes' Theorem\n// Chase Marangu 2023 11 28 2:41am ET\n//    Updated to try to include subtended angle algorithm which turned out to not work 2023 12 03 9:03pm ET\n// The program computes the \"winding number\" of the path g around each point in the shader\n//\n// Made for algorithms class final assignment\n// It's a long story, but the Generalized Stokes' Theorem (more rightfully\n// called the Fundamental Theorem of Multivariable Calculus (FTMC)) shows up\n// in so many fields from topology to multivariable calc to physics and engineering\n// where it solves everything from magnetic field of a wire to division by zero in complex analysis\n//\n//\n// This was entirely inspired by Keenan Crane et al. ACM SIGGRAPH paper \"Winding Numbers on Discrete Surfaces\"\n// - https://doi.org/10.1145/3592401\n// - https://dl.acm.org/doi/10.1145/3592401\n// - https://dl.acm.org/doi/pdf/10.1145/3592401\n// - \n// - https://www.youtube.com/watch?v=3undxB8rcvE\n// //\n// Specifically, Figure \n//\n//\n// Some Abbreviations / Acronyms: Surface Winding Numbers (SWN), Generalized Winding Numbers (GWN)\n// \n//\n// anyways, down to coding.\n\n\n\n// Physical constants. Pi is more a mathematical constant but I don't care\n#define PI 3.14159265358979323\n\n// Mode - added 2023 December 3rd\n// 0 - uses line integral in magnetic B-field divided by current in wire\n// 1 - uses subtended angle\n#define mode 0\n// 0 - counter clockwise (CCW) / anticlockwise circle\n// 1 - figure eight\n// 2 - triple figure eight thing\n#define whichcurve 1\n// n is the number of iterations for Euler Integration throughout this program\n#define n 100.\n\n\nvec3 B (vec3 s) {\n    return (1./length(s))*cross(vec3(0., 0., 1.), normalize(s) );\n}\n\n// g:R -> R^2 is our path that gets \"doodled\" to the screen.\nvec2 g2 (float t) {\n    // adding animation using iTime uniform\n    t *= .505 - .495*sin( (iTime+.5) *PI*.2);\n    // make t spend extra time at 1\n    //t = clamp(t*2.2, 0., 1.);\n    t *= 2.*PI;\n    #if whichcurve == 0\n    return vec2( cos(t), sin(t) );\n    #elif whichcurve == 1\n    return vec2( cos(t*2.+PI*.5), sin(t) )*.8;\n    #else\n    return vec2( cos(t*3.), sin(t) )*.8;\n    #endif\n}\n\nvec3 g (float t) {\n    // I know the redundant calling g(t) is inefficient but I don't care, this still runs 60FPS\n    // for this project, code readability > efficiency (since it still runs 60FPS)\n    return vec3(g2(t).x, g2(t).y, 0.);\n}\n\n\nfloat SDF (vec3 p) {\n    // start at infinity\n    float SDFi = 1e9; // SDFi because like subscript i indicates it's index i in our minimizing algorithm, not the final value\n    // calculate n-ary minimum. This inspired by\n    // \"Parametric SDF L1, L2, Linf\" by @Envy24\n    for (float i=0.; i<n; ++i) {\n        float t = i/n;\n        vec3 s = g(t);\n        SDFi = min( SDFi, length(s-p) );\n    }\n    return SDFi;\n}\n\n#if mode == 0\nfloat windingNum (vec3 p) {\n    // given a point p on the screen,\n    // outputs the winding number of the path g(t):[0,1)->R^3 around an \"upwards\" line through s.\n    // equivalently, the winding number of g2(t):[0,1)->R^2 around the point (s.x, s.y) in R^2\n    // Clockwise is positive to match\n    // with conventions in Stokes' Theorem and numerous other places where x=cos(t) y=sin(t) t>=0 etc.\n    float w = 0.;\n    for (float i=0.; i<n; ++i) {\n        float t = i/n;\n        float deltaT = 1./n;\n        vec3 s = g(t); // g:R->R^3 is a function. s is a point in R^3. R^n is the nth Cartesian Power of R.\n        vec3 deltaS = g(t + deltaT)-g(t); // delta is the unicode U+2206 Increment Operator.\n                                          // Related to Generalized Stokes' Theorem.\n        w += dot( B(s - p), deltaS );\n    }\n    return w/(2.*PI);\n}\n#else\nfloat windingNum (vec3 p) {\n    vec2 p2 = p.xy;\n    float w = 0.;\n    for (float i=0.; i<n; ++i) {\n        float t = i/n;\n        float t2 = (i+1.)/n;\n        vec2 s = g2(t);\n        vec2 s2 = g2(t2);\n        float theta = atan(s.y-p.y,s.x-p.x);\n        float theta2 = atan(s2.y-p.y, s2.x-p.x);\n        //w += mod(PI*2.*900. + theta2-theta, PI*2.);\n        float theSign = 1.;\n        if (theta2 - theta < 0.) { theSign = -1.; }\n        w += length(normalize(s2 - p2) - normalize(s - p2)) * theSign;\n    }\n    return w/(2.*PI);\n}\n#endif\n\n\n// lerp = abbreviation of \"linear interpolation\"\n// used for the colorFunction to make it look nice\nvec3 lerp (vec3 a, vec3 b, float t) { return a + (b-a)*t; }\n\n// color function\n// inputs: w = winding number of g(t):[0,1)->R^3 around h\nvec3 colorFunction (float w) {\n    // help from https://www.shadertoy.com/view/MsjyWR to learn how to use arrays\n    // ncs is the number of colors\n    #if 1\n    #define ncs 3.\n    vec3 cs[int(ncs)];\n    cs[0] = vec3(0., 0., 0.);\n    cs[1] = vec3(0., 0., 1.);\n    cs[2] = vec3(0., 1., 1.);\n    #else\n    // make it go in increments of 0.5 instead of 1\n    w *= 2.;\n    #define ncs 6.\n    vec3 cs[int(ncs)];\n    cs[0] = vec3(0., 0., 0.);\n    cs[1] = vec3(0., 1., 0.); // wont get shown if w is whole number\n    cs[2] = vec3(0., 1., 1.);\n    cs[3] = vec3(1., 0., 0.); // wont get shown if w is whole number\n    cs[4] = vec3(0., 0., 1.);\n    cs[5] = vec3(1., 0., 1.); // wont get shown if w is whole number\n    #endif\n    float i = floor(w);\n    // the +ncs*999 is a hack to make sure it works with negative values of w as well\n    vec3 c1 = cs[int(mod(i+ncs*999., ncs))];\n    vec3 c2 = cs[int(mod(i+1.+ncs*999., ncs))];\n    //c1 = vec3(0.); c2 = vec3(1., 0., 0.);\n    //\n    return lerp( c1, c2, mod(w+999., 1.) );\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec3 p = vec3(\n        fragCoord.x-iResolution.x/2.,\n        fragCoord.y-iResolution.y/2.,\n        0.\n    )/min(iResolution.x, iResolution.y)*2.;\n    fragColor.rgb = vec3(.0);\n    //fragColor.r = windingNum(p);\n    fragColor.rgb = colorFunction(windingNum(p));\n    // fragColor.r = sin( length(B(p)) );\n    //fragColor.rgb = B(p);\n    //fragColor.rgb = p;\n    //if (length(p.xy)>1.) {fragColor.g = .5; } else { fragColor.g = 0.; }\n    //if (p.x>.0) {fragColor.r = 1.; } else { fragColor.r = 0.; }\n    //if (p.y>.0) {fragColor.b = 1.; } else { fragColor.b = 0.; }\n    //\n    //if (SDF(p) < .05) { fragColor.rgb *= .8; }\n    //\n    fragColor.a = 1.;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}