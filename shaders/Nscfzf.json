{
    "Shader": {
        "info": {
            "date": "1656882809",
            "description": "An experiment in raymarching using a cube map to store an SDF.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "Nscfzf",
            "likes": 37,
            "name": "Own World",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "planet"
            ],
            "usePreview": 0,
            "username": "Dave_Hoskins",
            "viewed": 688
        },
        "renderpass": [
            {
                "code": "// Own World. \n\n// Shadertoy version of my NFT in WebGL 1.0 using p5 java-script.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 1.0 Unported License.\n// By David Hoskins, 2022. AKA Flandish - https://twitter.com/Flandish_Art\n\n\n#define FAR 10.\n\n#define planetSizeSQR .6*.6\nconst vec3 seaColour = vec3(0,.0,.05);\nvec3 landColour = vec3(.4,.1,.1);\nconst vec2 planetRotate = vec2(.15, -.195);\nconst vec3 sunRay = normalize(vec3(-9.,8.0, 9.0));\nconst vec3 backlightRay = normalize(vec3(6.,-1.0, -4.0));\nmat3 rotMat;\n\n//----------------------------------------------------------------------------------------\nmat2 rot2D(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\n\n//----------------------------------------------------------------------------------------------------------\nfloat sphere( in vec3 ro, const in vec3 rd, const in float s )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - s;\n\tfloat h = b * b - c;\n\tif(h < 0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n//----------------------------------------------------------------------------------------------------------\nfloat map(vec3 p)\n{\n    p = rotMat * p;\n    float t = texture(iChannel1, p).x + SEA_LEVEL;\n    return length(p) - t;\n}\n\n//----------------------------------------------------------------------------------------------------------\nvec3 mapNormal(vec3 p)\n{\n    p = rotMat * p;\n    return  (texture(iChannel1, p).yzw*2.0) - 1.0;\n    \n}\n\n//----------------------------------------------------------------------------------------------------------\nfloat rayMarch(const in vec3 ro, const in vec3 rd, in float d)\n{\n    //d -= hash12(ro.yz)*.5;\n    for (int i = 0; i < 80 && d < FAR; i++)\n    {\n        vec3 p = ro+rd*d;\n        float m = map(p);\n        if (abs(m) < eps) break;\n        d += m*.37;\n    }\n \n    return d;\n}\n\n//----------------------------------------------------------------------------------------------------------\nfloat shadow(const in vec3 ro, const in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.;\n    for(int i = 0; i < 35; i++ )\n    {\n\t\tfloat h = map(ro + rd*t);\n\n\n        res = min( res, 6.*h/t );\n        if (res < .1) break;\n        t += h*.35;\n    }\n\n    return clamp( res, 0.1, 1.0 );\n}\n//----------------------------------------------------------------------------------------------------------\nvec3 getNormal(const in vec3 p, const in float ep)\n{\n\n    vec2 e = vec2(-1, 1)*ep;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) ); \n}\n\n//----------------------------------------------------------------------------------------------------------\nvec3 background(const in vec2 st)\n{\n  float s = .1/dot(st, st);\n  s = s*s*8.;\n  vec3 col = vec3(s*.7, s*.85, s);\n \n  // Dither over several bands for super smooth gradient...\n  vec3 m = col * 64.0;\n  vec3 h = hash32(st*40.0+2000.0);\n  col = (m + h) / 64.0;\n  return clamp(col, 0.0, 1.0);\n}\n\nvoid changeColours(int i)\n{\n    float rand = float((iFrame>>10))*23.+41.;\n    landColour = hash31(rand*43.+47.)*vec3(.3, .3, .1) + vec3(.2, .1, .1);\n}\n\n\n\n//----------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (2.0*(fragCoord+.5)-iResolution.xy) / iResolution.y;\n    const vec3 camPos = vec3(0,0,6);\n    vec3 rayDir = normalize( vec3(st*.08, -1.));\n    vec3 col;\n    \n    // Amimate...\n    rotMat = rotateMat3(iTime * planetRotate.x,  iTime * planetRotate.y);\n    \n\n    changeColours(iFrame);\n\n\n    // Firstly project the ray to the bounding sphere,\n    // which means I don't have to march from the camera.\n    float inter = sphere(camPos, rayDir, planetSizeSQR);\n    if (inter > 0.0)\n    {\n        // Raymarch from shell point to discover planet below...\n        float dist = rayMarch(camPos, rayDir, inter);\n        if (dist < FAR)\n        {\n            vec3 p = camPos + rayDir * dist;\n            vec3 up = normalize(p);\n            float dep = length(p);\n            vec3 norm =  inverse(rotMat) * mapNormal(p);\n        \n            // Compare stored normal to the acquired normal.\n            //if ((iFrame & 64) == 0) norm = getNormal(p, eps);\n\n\n            float refLight = max(dot( reflect(rayDir, norm), sunRay), 0.0);\n            float sh = shadow(p+norm*.0005, sunRay);\n          \n            \n            // Under water merge flatness...\n            float sea = smoothstep(SEA_LEVEL+0.02,  SEA_LEVEL+.006, dep);\n            //if (dep < SEA_LEVEL+4.) sea = 1.0;\n            norm = mix(norm, up, sea);\n            \n            vec3 mat = landColour;\n            // Grassy flats...\n            float slope = max(dot(up, norm), 0.0);\n            slope = pow(slope, 20.);\n            if (sea == 0.) mat = mix(mat, vec3(0.,.25,0), slope);\n            \n            // Snow colour...\n            float snow = smoothstep(SNOW_LEVEL-.06,  SNOW_LEVEL, dep);\n            mat =  mix(mat, vec3(.9), snow);\n\n            mat =  mix(mat, seaColour, sea);\n            // Sunlight...\n            float bri = sh*max(dot(norm, sunRay),0.0);\n            // Specular\n            col = mat * bri+.05;\n            col += vec3(1.,.8, .7)*pow(refLight, 10.0)*.4*sh;\n            // Blue side light\n            col += max(dot(norm, backlightRay),0.0)*vec3(.0, .1, .2);\n        }else\n        {\n            col = background(st);\n        }\n    }else\n    {\n        col = background(st);\n    }\n    //col = clamp(col*1.4, 0.0, 1.0);\n    col =  (col*col*(3.0-2.0*col));\n    fragColor = vec4(sqrt(col),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SEA_LEVEL .34\n#define SNOW_LEVEL .51\n\n#define eps .0005\n\n// Swap m1 and m2 declaration around to break Angle!\nmat3 rotateMat3(float x, float y)\n{\n    mat3 m2 = mat3(cos(y),-sin(y), 0,\n                   sin(y), cos(y), 0,\n                   0, 0, 1);\n    mat3 m1 = mat3(cos(x),0,sin(x),\n                   0, 1, 0,\n                   -sin(x),0, cos(x));\n    return m2*m1;\n}\n\n\nmat2 rotMat2d(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\nvec3 mod289(vec3 x)\n{\n        return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n   return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t)\n{\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n   \nfloat pnoise(vec3 P)\n{\n   vec3 Pi0 = floor(P);\n    vec3 Pi1 = Pi0 + vec3(1.0);\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); \n    vec3 Pf1 = Pf0 - vec3(1.0);\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 1.99 * n_xyz;\n} \n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Own World - make the planets in this tab\n// License Creative Commons Attribution-NonCommercial-ShareAlike 1.0 Unported License.\n// By David Hoskins, 2022.\n\n// The planet is stored in the environment map.\n// Which means you can't have any holes in it\n// unless you play around with four different values xyzw as spans.\n// But that would not be fast enough for me so I only store one height, in x.\n// yzw stores the normal.\n\n//----------------------------------------------------------------------------------------\n\nmat3 rotMat;\nfloat rand;\nvec2 details;\nfloat frequency;\nfloat adder;\n\n//---------------------------------------------------------------------------------------- \nfloat height( in vec3 q)\n{\n\n    vec3 p = (q+adder)*frequency;\n\n    float d = 0.0, a = .3;\n    for (int i = 0; i < 12; i++)\n    {\n        float n = 1.0-abs(pnoise(p));\n        n = pow(n, 1.5);\n        n += pnoise(p*1.35)*a*.3;\n\n        d += a * n;\n        a *= 0.43;\n        p = rotMat * p;\n    }\n    float r = clamp(d - SEA_LEVEL, 0.0, 1.0);\n    if (r < .002) r = r + d*.02;\n\n    return r;\n}\n\n//----------------------------------------------------------------------------------------\nfloat map(in vec3 p)\n{\n    float f = height(p);\n    return length(p)-f;\n}\n\n\n\n// The normal looks different from calculating it on the fly, but\n// I think it's more precise to use the actual SDF to grab the normals, instead of the cubemap,\n// because of the pixel density change across the cubemapped pixels giving uneven results?\n \nvec3 getNormal(in vec3 p, in float ep)\n{\n\n    vec2 e = vec2(-1, 1)*ep;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) ); \n \n}\n\n//----------------------------------------------------------------------------------------\nvoid mainCubemap( out vec4 C, in vec2 Coor, in vec3 rayOri, in vec3 rayDir )\n{\n   // Occasionally re-render the cubemap,\n   // Note, I have to do 2 frames because I think ALL the buffer objects are double.\n\n    int i = iFrame;\n    int doit = i & 1023;\n    if(doit > 1) discard;\n  \n    float rand = float((i>>2)&1023) +99.;\n    details = hash21(rand+13.0);\n\n    \n    frequency = .5 + hash11(rand*99.)*.4;\n    adder = hash11(rand*19.+5.)*1400.;\n\n\n    rotMat = rotateMat3(-1.11, 1.31) * 2.0;\n   \n    float f = height(rayDir);\n    f = clamp(f, 0.0, 1.0);\n    \n    \n    vec3 norm =  getNormal(rayDir, eps*.5);\n\n    norm = clamp(norm, -1.0, 1.0);\n    \n    C = vec4(f, (norm + 1.0)*.5);\n}\n\n//----------------------------------------------------------------------------------------",
                "description": "",
                "inputs": [],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}