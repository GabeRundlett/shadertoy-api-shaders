{
    "Shader": {
        "info": {
            "date": "1643649511",
            "description": "I made changes to the raymarching code to simulate a Kerr metric rotating black hole. (https://en.wikipedia.org/wiki/Kerr_metric)\nCould be improved by better redshift, since the current redshift doesn't take the frame-dragging into account.",
            "flags": 0,
            "hasliked": 0,
            "id": "sdjcWm",
            "likes": 28,
            "name": "Rotating black hole",
            "published": 3,
            "tags": [
                "warping",
                "distortion",
                "blackhole",
                "rotating",
                "lensing",
                "kerr"
            ],
            "usePreview": 1,
            "username": "A_Toaster",
            "viewed": 1249
        },
        "renderpass": [
            {
                "code": "#define AA 2  //change to 1 to increase performance\n\n#define _Speed 3.0  //disk rotation speed\n\n#define _Steps  12. //disk texture layers\n#define _Size 0.3//size of BH\n\n\n\nfloat hash(float x){ return fract(sin(x)*152754.742);}\nfloat hash(vec2 x){\treturn hash(x.x + hash(x.y));}\n\nfloat value(vec2 p, float f) //value noise\n{\n    float bl = hash(floor(p*f + vec2(0.,0.)));\n    float br = hash(floor(p*f + vec2(1.,0.)));\n    float tl = hash(floor(p*f + vec2(0.,1.)));\n    float tr = hash(floor(p*f + vec2(1.,1.)));\n    \n    vec2 fr = fract(p*f);    \n    fr = (3. - 2.*fr)*fr*fr;\t\n    float b = mix(bl, br, fr.x);\t\n    float t = mix(tl, tr, fr.x);\n    return  mix(b,t, fr.y);\n}\n\nvec4 background(vec3 ray)\n{\n    vec2 uv = ray.xy;\n    \n    if( abs(ray.x) > 0.5)\n        uv.x = ray.z;\n    else if( abs(ray.y) > 0.5)\n        uv.y = ray.z;\n\n        \n    float brightness = value( uv*3., 100.); //(poor quality) \"stars\" created from value noise\n    float color = value( uv*2., 20.); \n    brightness = pow(brightness, 256.);\n  \n    brightness = brightness*100.;\n    brightness = clamp(brightness, 0., 1.);\n    \n    vec3 stars = brightness * mix(vec3(1., .6, .2), vec3(.2, .6, 1), color);\n\n    vec4 nebulae = texture(iChannel0, (uv*1.5 ));\n    nebulae.xyz += nebulae.xxx + nebulae.yyy + nebulae.zzz; //average color\n    nebulae.xyz *= 0.25;\n    \n    nebulae*= nebulae;\n    nebulae*= nebulae;\n    nebulae*= nebulae;\n    nebulae*= nebulae;\n \n\tnebulae.xyz += stars;\n\treturn nebulae;\n}\n\nvec4 raymarchDisk(vec3 ray, vec3 zeroPos)\n{\n    //return vec4(1.,1.,1.,0.); //no disk\n    \n\tvec3 position = zeroPos;      \n    float lengthPos = length(position.xz);\n    float dist = min(1., lengthPos*(1./_Size) *0.5) * _Size * 0.4 *(1./_Steps) /( abs(ray.y) );\n\n    position += dist*_Steps*ray*0.5;     \n\n    vec2 deltaPos;\n    deltaPos.x = -zeroPos.z*0.01 + zeroPos.x;\n    deltaPos.y = zeroPos.x*0.01 + zeroPos.z;\n    deltaPos = normalize(deltaPos - zeroPos.xz);\n    \n    float parallel = dot(ray.xz, deltaPos);\n    parallel /= sqrt(lengthPos);\n    parallel *= 0.5;\n    float redShift = parallel +0.3;\n    redShift *= redShift;\n\n    redShift = clamp(redShift, 0., 1.);\n    \n    float disMix = clamp((lengthPos - _Size * 2.)*(1./_Size)*0.24, 0., 1.);\n    vec3 insideCol =  mix(vec3(1.0,0.8,0.0), vec3(0.5,0.13,0.02)*0.2, disMix);\n    \n    insideCol *= mix(vec3(0.4, 0.2, 0.1), vec3(1.6, 2.4, 4.0), redShift);\n\tinsideCol *= 1.25;\n    redShift += 0.12;\n    redShift *= redShift;\n\n    vec4 o = vec4(0.);\n\n    for(float i = 0. ; i < _Steps; i++)\n    {                      \n        position -= dist * ray ;  \n\n        float intensity =clamp( 1. - abs((i - 0.8) * (1./_Steps) * 2.), 0., 1.); \n        float lengthPos = length(position.xz);\n        float distMult = 1.;\n\n        distMult *=  clamp((lengthPos -  _Size * 0.75) * (1./_Size) * 1.5, 0., 1.);        \n        distMult *= clamp(( _Size * 10. -lengthPos) * (1./_Size) * 0.20, 0., 1.);\n        distMult *= distMult;\n\n        float u = lengthPos + iTime* _Size*0.3 + intensity * _Size * 0.2;\n\n        vec2 xy ;\n        float rot = mod(iTime*_Speed, 8192.);\n        xy.x = -position.z*sin(rot) + position.x*cos(rot);\n        xy.y = position.x*sin(rot) + position.z*cos(rot);\n\n        float x = abs( xy.x/(xy.y));         \n\t\tfloat angle = 0.02*atan(x);\n  \n        const float f = 70.;\n        float noise = value( vec2( angle, u * (1./_Size) * 0.05), f);\n        noise = noise*0.66 + 0.33*value( vec2( angle, u * (1./_Size) * 0.05), f*2.);     \n\n        float extraWidth =  noise * 1. * (1. -  clamp(i * (1./_Steps)*2. - 1., 0., 1.));\n\n        float alpha = clamp(noise*(intensity + extraWidth)*( (1./_Size) * 10.  + 0.01 ) *  dist * distMult , 0., 1.);\n\n        vec3 col = 2.*mix(vec3(0.3,0.2,0.15)*insideCol, insideCol, min(1.,intensity*2.));\n        o = clamp(vec4(col*alpha + o.rgb*(1.-alpha), o.a*(1.-alpha) + alpha), vec4(0.), vec4(1.));\n\n        lengthPos *= (1./_Size);\n   \n        o.rgb+= redShift*(intensity*1. + 0.5)* (1./_Steps) * 100.*distMult/(lengthPos*lengthPos);\n    }  \n \n    o.rgb = clamp(o.rgb - 0.005, 0., 1.);\n    return o ;\n}\n\n\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\n\nvoid mainImage( out vec4 colOut, in vec2 fragCoord )\n{\n    colOut = vec4(0.);;\n    \n    vec2 fragCoordRot;\n    fragCoordRot.x = fragCoord.x*0.985 + fragCoord.y * 0.174;\n    fragCoordRot.y = fragCoord.y*0.985 - fragCoord.x * 0.174;\n    fragCoordRot += vec2(-0.06, 0.12) * iResolution.xy;\n    \n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        //setting up camera\n        vec3 ray = normalize( vec3((fragCoordRot-iResolution.xy*.5  + vec2(i,j)/(float(AA)))/iResolution.x, 1 )); \n        vec3 pos = vec3(0.,0.05,-(20.*iMouse.xy/iResolution.y-10.)*(20.*iMouse.xy/iResolution.y-10.)*.05); \n        vec2 angle = vec2(iTime*0.1,.2);      \n        angle.y = (2.*iMouse.y/iResolution.y)*3.14 + 0.1 + 3.14;\n        float dist = length(pos);\n        Rotate(pos,angle);\n        angle.xy -= min(.3/dist , 3.14) * vec2(1, 0.5);\n        Rotate(ray,angle);\n\n        vec4 col = vec4(0.); \n        vec4 glow = vec4(0.); \n        vec4 outCol =vec4(100.);\n\n        for(int disks = 0; disks< 256; disks++) //steps\n        {\n\n            for (int h = 0; h < 6; h++) //reduces tests for exit conditions (to minimise branching)\n            {\n                float dotpos = dot(pos,pos);\n                float invDist = inversesqrt(dotpos); //1/distance to BH\n                float centDist = dotpos * invDist; \t//distance to BH\n                \n                \n                // stepDist was originally abs(pos.y /(ray.y)) * 0.9\n                // the min(dotpos * 0.2,...) was added to maintain shorter step distances when far from the disk.\n                float stepDist = min(dotpos * 0.2, abs(pos.y /(ray.y)) * 0.9);  //conservative distance to disk (y==0), but clamped to a max for more accurate frame dragging (the light could escape the BH with too large of steps)\n                float farLimit = centDist * 0.5; //limit step size far from to BH\n                float closeLimit = centDist*0.1 + 0.05*centDist*centDist*(1./_Size); //limit step size closse to BH\n                stepDist = min(stepDist, min(farLimit, closeLimit));\n\t\t\t\t\n                float invDistSqr = invDist * invDist;\n                float bendForce = stepDist * invDistSqr * _Size * 0.625;  //bending force\n                \n                // Frame dragging computation below:\n                // Compute a vector in the direction of the BH's rotation\n                vec3 pos_cross_pole_axis = cross(vec3(0., 1., 0.), pos);\n                // Compute sin^2(latitude) of the current ray position\n                float sin2_colatitude = length(pos_cross_pole_axis)/length(pos);\n                sin2_colatitude = sin2_colatitude * sin2_colatitude;\n                \n                // the frame dragging rate is approximately proportional to 1/(r^2 * sin^2(colatitude)) (See: https://en.wikipedia.org/wiki/Frame-dragging)\n                vec3 frameDragForce = normalize(pos_cross_pole_axis) * invDistSqr * sin2_colatitude * 0.012; \n                \n                \n                ray =  normalize(ray - (bendForce * invDist)*pos);  //bend ray towards BH\n                pos += stepDist * (ray - frameDragForce) ; // Move the ray in the ray direction and move it according to frame dragging\n                // This could be acheived more accurately by computing a rotation matrix and using it to rotate the ray position & direction.\n                \n                glow += vec4(1.2,1.1,1, 1.0) *(0.01*stepDist * invDistSqr * invDistSqr *clamp( centDist*(2.) - 1.2,0.,1.)); //adds fairly cheap glow\n            }\n\n            float dist2 = length(pos);\n\n            if(dist2 < _Size * 0.5) //ray sucked in to BH\n            {\n                outCol =  vec4( col.rgb * col.a + glow.rgb *(1.-col.a ) ,1.) ;\n                break;\n            }\n\n            else if(dist2 > _Size * 1000.) //ray escaped BH\n            {                   \n                vec4 bg = background (ray);\n                outCol = vec4(col.rgb*col.a + bg.rgb*(1.-col.a)  + glow.rgb *(1.-col.a    ), 1.);       \n                break;\n            }\n\n            else if (abs(pos.y) <= _Size * 0.0005 ) //ray hit accretion disk\n            {                             \n                vec4 diskCol = raymarchDisk(ray, pos);   //render disk\n                //pos.y = 0.;\n                pos += abs(_Size * 0.001 /ray.y) * ray;  // skip over disk (keeps rays from getting trapped inside disk)\n                col = vec4(diskCol.rgb*(1.-col.a) + col.rgb, col.a + diskCol.a*(1.-col.a));\n            }\t\n        }\n   \n        //if the ray never escaped or got sucked in\n        if(outCol.r == 100.)\n            outCol = vec4(col.rgb + glow.rgb *(col.a +  glow.a) , 1.);\n\n        col = outCol;\n        col.rgb =  pow( col.rgb, vec3(0.6) );\n        \n        colOut += col/float(AA*AA);\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}