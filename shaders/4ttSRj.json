{
    "Shader": {
        "info": {
            "date": "1480781405",
            "description": "Using various cheap methods to produce a detailed, albeit rudimentary, looking scene without the extra cost.",
            "flags": 0,
            "hasliked": 0,
            "id": "4ttSRj",
            "likes": 50,
            "name": "Endless Passageway",
            "published": 3,
            "tags": [
                "raymarching",
                "map",
                "bump",
                "columns",
                "corridor"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 2041
        },
        "renderpass": [
            {
                "code": "/*\n\n\tEndless Passageway\n\t------------------\n\t\n    Combining techniques like normal-based edging, bump mapping and bump-based edging to produce \n\ta detailed looking surface without the high cost. I'm using concepts from my \"Twisted Geometry\"\n\texample, but applying them to a less abstract setting... Although, an endless corridor with \n\tdubious lighting and shadows is hardly realistic. :)\n\n\tI'd orginally started with a nice, ornate, carved-timber scene, then for some inexplicable reason \n\tdecided that a grungey, slightly mystical, pseudo-metallic-marble Islamic look was the order of \n\tthe day. I put it in the weird, but interesting category. :)\n\n\tThe distance function is very basic. It's possible to create a much more interesting setting,\n\tbut I wanted to keep the base geometry simple in order to achieve decent frame rates.\t\n\n\tAnyway, it's just a simple artsy example. Not to be taken seriously. I'll put up something more\n\tinteresting later.\n\n\t\n\t// Related example.\n\n\t// A room with columns example using much nicer distance function geometry and atmosphere.\n\tCatacombs - IQ\n\thttps://www.shadertoy.com/view/lsf3zr\n\n\t// Gorgeous example.\n    Castle Tunnel - Hamneggs\n\thttps://www.shadertoy.com/view/Xs3Xzn\n\n\n*/\n\n// Maximum ray distance.\n#define FAR 50.\n\n// Comment this out to omit the detailing. Basically, the bump mapping won't be included.\n#define SHOW_DETAILS\n\n// The edges give it subtle detail. Not entirely necessary, but adds just a little more depth.\n#define SHOW_EDGES\n\nfloat objID; // Structure object ID.\nfloat bObjID; // Bump map detail ID.\n\n// 2D rotation. Always handy. Angle vector, courtesy of Fabrice.\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) - th); return mat2(a, -a.y, a.x); }\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n  \n    //return vec3(0, 0, t); // Straight path.\n    \n    // Curvy path. Weaving around the columns.\n    float a = sin(t * 3.14159265/24. + 1.5707963);\n    float b = cos(t * 3.14159265/32.);\n    \n    return vec3(a*4.35, b*a, t);    \n}\n\n\n// Smooth minimum. Courtesy of IQ.\nfloat sminP( float a, float b, float smoothing ){\n\n    float h = clamp((b-a)/smoothing*.5 + .5, 0., 1.);\n    return mix(b, a, h) - smoothing*h*(1. - h);\n}\n\n// Smooth tiles. There are better ways, but it works.\nfloat tiles(vec2 p){\n\n    p = fract(p);\n    \n    float s = pow( 16.*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.125);\n    \n    return smoothstep(0., 1., s);\n\n}\n\n// Standard lattice variation, of which there are infinitely many. This is only called by the \n// bump mapping function to add some detail to the structure. You could certainly incorporate it\n// into the distance function, but it would slow it down considerably.\nfloat lattice(vec3 p){\n \n\n    // Repeat field entity one, which is just some square tubes repeated in all directions every \n    // two units, then combined with a minimum function. Otherwise known as a lattice.\n    p = abs(mod(p, 2.) - 1.);\n\tfloat x1 = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - .32;//.5 + p.y*.1;// - .32;\n    \n\n    // Repeat field entity two, which is just an abstract object repeated every half unit. \n    p = abs(mod(p,  .5) - .25);\n    float x2 = min(p.x, min(p.y, p.z));\n    \n    bObjID = step(x2, x1);\n    \n    \n\n    // Combining the two entities above.\n    return max(x1, x2) - .08;    \n    \n}\n\n// Standard lattice variation, of which there are infinitely many.\nfloat columns(vec3 p){\n    \n    // Repeat field entity one, which is just some square tubes repeated in all directions every \n    // four units.\n    p = abs(mod(p, 4.) - 2.);\n\t\n    float x1 = max(p.x, p.z)- .32; //Columns.\n\t//float x1 = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - .32; // Lattice, for comparison.\n    \n    float bl = max(max(p.x - .5, p.z - .5), p.y + .1); // Column header and footer. Boxes.\n    \n    \n    x1 = min(x1, bl); // Column with header and footer.\n    \n\n    // Repeat field entity two, which is just an abstract object repeated every half unit. \n    p = abs(mod(p,  .5) - .25);\n    float x2 = min(p.x, min(p.y, p.z)); // Carving out the columns with a repeat object.\n    \n    objID = step(x1, x2-.05); // ID, to give the column two different materials.\n\n    // Combining the two entities above.\n    return max(x1, x2) - .05;   \n    \n    \n}\n\n// Nothing more than some columns enclosed with a floor, ceiling and walls. Pretty simple.\nfloat map(vec3 p){\n    \n    \n    float d =  columns(p); // Repeat columns.\n    \n    float fl = p.y + 2.5; // Floor.\n\n    p = abs(p);\n    \n    d = sminP(d, -(p.y - 2.5 - d*.75), 1.5); // Add a smooth ceiling.\n    \n    d = min(d, -(p.x - 5.85)); // Add the Walls.\n    \n    d = sminP(d, fl, .25); // Smoothly combine the floor.\n     \n    return d*.75;\n}\n\n// Raymarching. Pretty standard. Nothing fancy.\nfloat trace(vec3 ro, vec3 rd){\n\n    float t = 0., d;\n    for (int i=0; i<80; i++){\n\n        d = map(ro + rd*t);\n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;\n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.yz).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n\n// The bump mapping function.\nfloat bumpFunction(in vec3 p){\n    \n   \n    // A reproduction of the lattice at higher frequency. Obviously, you could put\n    // anything here. Noise, Voronoi, other geometrical formulas, etc.\n    //return min(abs(columns(p*4.)*.34 + lattice(p*4.)*.66)*1.6, 1.);\n    float c = 0.;\n    \n    // The logic is simple, but a little messy.\n    if(p.y>2.15) c = min(abs(lattice(p*3.))*1.6, 1.); // Ceiling.\n    else if(p.y>-2.15) c = min(abs(lattice(p*4.))*1.6, 1.); // Columns.\n    else c = max(tiles(p.xz + .5) - min(abs(lattice(p*2.))*1.6, 1.), 0.)*.5; // Floor.\n    \n    return c;  \n   \n}\n\n// Standard function-based bump mapping function with some edging thrown into the mix.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge){\n    \n    // Resolution independent sample distance... Basically, I want the lines to be about\n    // the same pixel with, regardless of resolution... Coding is annoying sometimes. :)\n    vec2 e = vec2(3./iResolution.y, 0); \n    \n    float f = bumpFunction(p); // Hit point function sample.\n    \n    float fx = bumpFunction(p - e.xyy); // Nearby sample in the X-direction.\n    float fy = bumpFunction(p - e.yxy); // Nearby sample in the Y-direction.\n    float fz = bumpFunction(p - e.yyx); // Nearby sample in the Y-direction.\n    \n    float fx2 = bumpFunction(p + e.xyy); // Sample in the opposite X-direction.\n    float fy2 = bumpFunction(p + e.yxy); // Sample in the opposite Y-direction.\n    float fz2 = bumpFunction(p+ e.yyx);  // Sample in the opposite Z-direction.\n    \n     \n    // The gradient vector. Making use of the extra samples to obtain a more locally\n    // accurate value. It has a bit of a smoothing effect, which is a bonus.\n    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*2.);  \n    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.\n\n\n    // Using the above samples to obtain an edge value. In essence, you're taking some\n    // surrounding samples and determining how much they differ from the hit point\n    // sample. It's really no different in concept to 2D edging.\n    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);\n    edge = smoothstep(0., 1., edge/e.x);\n    \n    // Some kind of gradient correction. I'm getting so old that I've forgotten why you\n    // do this. It's a simple reason, and a necessary one. I remember that much. :D\n    grad -= n*dot(n, grad);          \n                      \n    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.\n\t\n}\n\n// The normal function with some edge detection rolled into it. Sometimes, it's possible to get away\n// with six taps, but we need a bit of epsilon value variance here, so there's an extra six.\nvec3 nr(vec3 p, inout float edge, float t){ \n\t\n    vec2 e = vec2(3./iResolution.y, 0); // Larger epsilon for greater sample spread, thus thicker edges.\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\t// The hit point itself - Doubled to cut down on calculations. See below.\n     \n    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    // curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    // do that is up to you. This is what I came up with for now, but I might tweak it later.\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\t\n    // Redoing the calculations for the normal with a more precise epsilon value.\n    e = vec2(.005*min(1. + t, 5.), 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx); \n    \n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n){\n\t\n    float sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 20; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    //float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        dist += clamp(h, 0.01, 0.2);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.2, 1.0); \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    float speed = 3.;\n    vec3 ro = camPath(iTime*speed); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*speed + .1);  // \"Look At\" position.\n    //vec3 lp = camPath(iTime*speed + 4.); // Light position, somewhere near the moving camera.\n\tvec3 lp = vec3(0, 0, iTime*speed) + vec3(0, .5, 3.5);//\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; ///3. FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    //vec3 rd = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    \n    // Mild lens distortion. The sheer straight edged geometry is was getting to me. :) \n    vec3 rd = fwd + FOV*(u.x*rgt + u.y*up);\n    rd = normalize(vec3(rd.xy, (rd.z - length(rd.xy)*.125)*.75));\n    \n    // Swiveling the camera from left to right when turning corners.\n    rd.xy = rot(-camPath(lk.z).x/32. )*rd.xy;\n    \n    \n    // Raymarch.\n    float t = trace(ro, rd);\n    float svObjID = objID;\n    \n    // Surface hit point.\n    vec3 sp = ro + rd*t;\n    \n    // Normal with edge component.\n    float edge;\n    vec3 sn = nr(sp, edge, t);\n    \n    //float svObjID = objID;\n    \n    // Shadows and ambient self shadowing.\n    float sh = softShadow(sp, lp, 16.); // Soft shadows.\n    float ao = cao(sp, sn); // Ambient occlusion.\n    \n    // Light direction vector setup and light to surface distance.\n    lp -= sp;\n    float lDist = max(length(lp), .0001);\n    lp /= lDist;\n    \n    // Attenuation.\n    float atten = 1. / (1.0 + lDist*lDist*.15);\n    \n    \n    // More fake lighting. This was just a bit of trial-and-error to produce some repetitive,\n    // slightly overhead, spotlights throughout the space. Cylinder in XY, sine repeat\n    // in the Z direction over three rows... Something like that.\n    vec3 spl = sp;\n    spl.x = mod(spl.x, 2.) - 1.;\n    float spot = max(4. - length(spl.xy - vec2(0, 2.)), 0.)*(sin((spl.z + 1.)*3.14159/2.)*.5+.5);\n    spot = smoothstep(0.25, 1., spot); \n        \n\n   \n    // Heavy bump. We do this after texture lookup, so as not to disturb the normal too much.\n    float edge2 = 0.;\n    float svBObjID = 0.;\n    #ifdef SHOW_DETAILS\n    sn = doBumpMap(sp, sn, .15/(1. + t/FAR), edge2); \n    svBObjID = bObjID;\n    #endif    \n    \n    \n    // Diffuse, specular and Fresnel.\n    float dif = max(dot(lp, sn), 0.);\n    //dif = pow(dif, 4.)*0.66 + pow(dif, 8.)*0.34; // Ramping up the diffuse to make it shinier.\n    float spe = pow(max(dot(reflect(rd, sn), lp), 0.), 6.);\n    float fre = pow(clamp(dot(rd, sn) + 1., 0., 1.), 4.);\n    \n    \n    \n    // Texturing the object. I'm not a fan of this messy logic, epspecially the nesting, but it \n    // doesn't have a great impact on the speed, plus it's easy enough to follow.\n    vec3 tx;\n    if(sp.y>2.25) { // && sp.y<2.25\n        tx = tex3D(iChannel0, sp/2., sn)*1.; //Ceiling.\n    }\n    else if((sp.y)>1.88) {\n        tx = tex3D(iChannel1, sp/1., sn); // Top column footers.\n        tx = smoothstep(0.025, .7, tx);\n\n    }\n    else if(sp.y>-1.88) {\n        \n        // Columns.        \n        if(svObjID>.5) { \n        \ttx = tex3D(iChannel1, sp/1., sn);\n        \ttx = smoothstep(0.025, .7, tx);\n        }\n        else tx = tex3D(iChannel0, sp/4. + .5, sn)*1.; \n\n    }\n    else if((sp.y)>-2.25) {\n        tx = tex3D(iChannel1, sp/1., sn); // Bottom column footers.\n        tx = smoothstep(0.025, .7, tx);\n\n    }\n    else {\n        tx = tex3D(iChannel0, sp/4. + .5, sn); // Floor.\n        tx = smoothstep(-.15, .9, tx);\n        if (svBObjID>.5) tx *= 2./1.25; // Slighty lighten part of the bumped pattern.\n    }\n\n    \n    \n    #ifdef SHOW_EDGES\n    // Applying the normal-based and bump mapped edges.\n    tx *= (1.-edge*.7)*(1.-edge2*.7);\n    #endif\n    \n    \n    \n    // Combining the terms above to produce the final color.\n    vec3 fc = tx *(dif + .25 + vec3(.5, .7, 1)*fre*4.) + vec3(1, .7, .3)*spe*3. + spot*tx*3.;\n    fc *= atten*sh*ao;\n    \n    // Mixing in a bright sunny... distant light. Not really sure what it is. :) Setting\n    //  \"bg\" to black gives it a different, probably more realistic look, but is a bit dull.\n    vec3 bg = mix(vec3(1, .5, .3), vec3(1, .9, .5), rd.y*.5+.5);    \n    //bg /= 300.; \n    fc = mix(fc, bg*1.25, smoothstep(0., .9, t/FAR)); //1./(1. + t*t*.002)\n   \n    // Post processing.\n    fc = fc*.65 + vec3(1.2, 1.05, .9)*pow(max(fc, 0.), vec3(1, 1.2, 1.5))*.35; // Contrast, coloring.\n    \n\n    // Vignette.\n    u = fragCoord/iResolution.xy;\n    fc = min(fc, 1.)*pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .125);    \n \n\n    //fc = vec3(ao); // Uncomment this to see the AO and the scene without the bump detailing.\n    \n    // Approximate gamma correction.\n\tfragColor = vec4(sqrt(clamp(fc, 0., 1.)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}