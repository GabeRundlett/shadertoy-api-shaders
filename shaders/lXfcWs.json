{
    "Shader": {
        "info": {
            "date": "1726773003",
            "description": "A pathtracing raymarching shader done in MaterialMaker for a local demoscene event flyer\nCode manualy simplified and organized for humans :)\nYou can use mouse to change objects rotations",
            "flags": 32,
            "hasliked": 0,
            "id": "lXfcWs",
            "likes": 31,
            "name": "Momentum  #16",
            "published": 3,
            "tags": [
                "pathtracing",
                "materialmaker"
            ],
            "usePreview": 0,
            "username": "PauloFalcao",
            "viewed": 466
        },
        "renderpass": [
            {
                "code": "// Momentum #16\n//\n// By https://twitter.com/paulofalcao\n//\n// Generated in Material Maker\n// Source here https://www.materialmaker.org/material?id=1016\n//\n// Code manualy simplified and organized for humans :)\n//\n// This version uses MFSDF vec4 -> material struct\n//\n// Made it to compare with the original version MFSDF vec4 -> vec4\n// https://www.shadertoy.com/view/l3fcWs\n//\n// Used in a flyer for a local demoscene event\n// https://x.com/inerciaparty/status/1825519203203322286\n// \n\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 color = texture(iChannel0, fragCoord / iResolution.xy);\n    color.xyz=ACESFilm(color.xyz/color.w);\n    fragColor = vec4(pow(color.xyz,vec3(1.0/2.2)), 1.0f);\n     \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Momentum #16\n//\n// By https://twitter.com/paulofalcao\n//\n// Generated in Material Maker\n// Source here https://www.materialmaker.org/material?id=1016\n//\n// Code manualy simplified and organized for humans :)\n//\n// This version uses MFSDF vec4 -> material struct\n//\n// Made it to compare with the original version MFSDF vec4 -> vec4\n// https://www.shadertoy.com/view/l3fcWs\n//\n// Used in a flyer for a local demoscene event\n// https://x.com/inerciaparty/status/1825519203203322286\n// \n\n//Utils start\n\nconst float PI=3.14159265359;\n\nstruct Material {\n    float sdf;\n    vec3 color;\n    float roughness;\n    float metallic;\n    float specular;\n    float emission;\n};\n\nfloat sphere3d(vec3 uv, float s) {\n\treturn length(uv)-s;\n}\n\nfloat box3d(vec3 uv, vec3 s) {\n\tvec3 q = abs(uv) - s;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdf3d_smooth_union(float d1, float d2, float a) {\n\tfloat h = clamp(.5 + .5 * (d2 - d1) / a, 0., 1.);\n\treturn mix(d2, d1, h) - a * h * (1. - h);\n}\n\nvec3 rotate3d(vec3 p, vec3 a) {\n\tfloat c = cos(a.x);\n\tfloat s = sin(a.x);\n\tvec3 rv;\n\trv.x = p.x;\n\trv.y = p.y * c + p.z * s;\n\trv.z = -p.y * s + p.z * c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x * c + rv.z * s;\n\tp.y = rv.y;\n\tp.z = -rv.x * s + rv.z * c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x * c + p.y * s;\n\trv.y = -p.x * s + p.y * c;\n\trv.z = p.z;\n\treturn rv;\n}\n\nfloat sdf3d_union(float a, float b) {\n    return min(a, b);\n}\n\nvec3 opRepLim(vec3 p, vec3 c, vec3 l) {\n\tp += c * l / 2.;\n\treturn p - c * clamp(floor(p / c + .5), vec3(0), l);\n}\n\nvec2 sdf_smoothRot(vec2 p,float s) {\n\ts *= .5;\n\tfloat x = asin(sin(atan(p.x, p.y) * s) / (0. + 1.)) / s;\n\treturn vec2(sin(x) * length(p), cos(x) * length(p) - 1.);\n}\n\n// https://www.shadertoy.com/view/XsX3zB\n//\n// The MIT License\n// Copyright Â© 2013 Nikita Miropolskiy\n// \nvec3 XsX3zB_oct_random3(vec3 c) {\n\tfloat j = 4096. * sin(dot(c, vec3(17, 59.4, 15)));\n\tvec3 r;\n\tr.z = fract(512. * j);\n\tj *= .125;\n\tr.x = fract(512. * j);\n\tj *= .125;\n\tr.y = fract(512. * j);\n\treturn r - .5;\n}\n\nfloat XsX3zB_oct_simplex3d(vec3 p) {\n\tvec3 s = floor(p + dot(p, vec3(.3333333)));\n\tvec3 x = p - s + dot(s, vec3(.1666667));\n\tvec3 e = step(vec3(0), x - x.yzx);\n\tvec3 i1 = e * (1. - e.zxy);\n\tvec3 i2 = 1. - e.zxy * (1. - e);\n\tvec3 x1 = x - i1 + .1666667;\n\tvec3 x2 = x - i2 + 2. * .1666667;\n\tvec3 x3 = x - 1. + 3. * .1666667;\n\tvec4 w, d;\n\tw.x = dot(x, x);\n\tw.y = dot(x1, x1);\n\tw.z = dot(x2, x2);\n\tw.w = dot(x3, x3);\n\tw = max(.6 - w, 0.);\n\td.x = dot(XsX3zB_oct_random3(s), x);\n\td.y = dot(XsX3zB_oct_random3(s + i1), x1);\n\td.z = dot(XsX3zB_oct_random3(s + i2), x2);\n\td.w = dot(XsX3zB_oct_random3(s + 1.), x3);\n\tw *= w;\n\tw *= w;\n\td *= w;\n\treturn dot(d, vec4(52));\n}\n\nfloat fbm(vec3 coord, float persistence) {\n\tfloat normalize_factor = 0.;\n\tfloat value = 0.;\n\tfloat scale = 1.;\n\tfloat size = 1.;\n\tfor (int i = 0; i < 7; i++) {\n\t\tvalue += XsX3zB_oct_simplex3d(coord * size) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.;\n\t\tscale *= persistence;\n\t}\n\n\treturn value / normalize_factor;\n}\n\nvec2 twist_rot(vec2 v, float a) {\n\ta *= .01745329;\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(vec2(c, -s), vec2(s, c)) * v;\n}\n\n\nfloat smooth_union(float a, float b, float k) {\n\tfloat h = max(k - abs(a - b), 0.) / k;\n\treturn min(a, b) - h * h * k * .25;\n}\n\nMaterial mfsdf_union(Material a, Material b) {\n    if (a.sdf < b.sdf)\n        return a;\n    else\n        return b;\n}\n\nMaterial mfsdf_smooth_union(Material a, Material b, float k) {\n\tk = max(k, .001);\n\tfloat h = smooth_union(a.sdf, b.sdf, k);\n\tvec2 n = normalize(\n        vec2(smooth_union(a.sdf + .001, b.sdf, k) - smooth_union(a.sdf - .001, b.sdf, k),\n             smooth_union(a.sdf, b.sdf + .001, k) - smooth_union(a.sdf, b.sdf - .001, k)));\n\n    float mv=atan(abs(n.y), abs(n.x))/ (PI / 2.);\n\n\treturn Material(\n        h,//sdf\n        mix(a.color, b.color, mv),//color\n        mix(a.roughness, b.roughness, mv),//roughness\n        mix(a.metallic, b.metallic, mv),//metallic\n        mix(a.specular, b.specular, mv),//specular\n        mix(a.emission, b.emission, mv)//emission\n    );\n}\n\nvoid Onb(vec3 N, inout vec3 T, inout vec3 B) {\n\tT = normalize(cross(abs(N.z) < .999 ? vec3(0, 0, 1) : vec3(1, 0, 0), N));\n\tB = cross(N, T);\n}\n\n//from https://www.reedbeta.com/blog/hash-functions-for-gpu-rendering/\nuint rand_pcg(inout uint seed) {\n\tuint state = seed;\n\tseed = seed * uint(747796405) + uint(2891336453);\n\tuint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\n\treturn (word >> uint(22)) ^ word;\n}\n\nfloat RandomFloat01(inout uint state) {\n\tuint r = rand_pcg(state);\n\tr &= uint(0x007FFFFF);\n\tr |= uint(0x3F800000);\n\treturn uintBitsToFloat(r) - 1.;\n}\n\nvec3 constSampleSphere(float r1, float r2) {\n\tfloat z = 1. - 2. * r1;\n\tfloat r = sqrt(max(0., 1. - z * z));\n\tfloat phi = PI * 2.0 * r2;\n\treturn vec3(r * cos(phi), r * sin(phi), z);\n}\n\nvec3 cosineSampleHemissphere(inout uint state, vec3 n) {\n\treturn normalize(n + constSampleSphere(RandomFloat01(state), RandomFloat01(state)));\n}\n\n// Adapted from \"Sampling the GGX Distribution of Visible Normals\",\n// http://jcgt.org/published/0007/04/01/\nvec3 SampleGGXVNDF(inout uint state, vec3 Ve, float alpha_x, float alpha_y) {\n\tfloat U1 = RandomFloat01(state);\n\tfloat U2 = RandomFloat01(state);\n\tvec3 Vh = normalize(vec3(alpha_x * Ve.x, alpha_y * Ve.y, Ve.z));\n\tvec3 T1;\n\tvec3 T2;\n\tOnb(Vh, T1, T2);\n\tfloat r = sqrt(U1);\n\tfloat phi = 2. * PI * U2;\n\tfloat t1 = r * cos(phi);\n\tfloat t2 = r * sin(phi);\n\tfloat s = .5 * (1. + Vh.z);\n\tt2 = (1. - s) * sqrt(1. - t1 * t1) + s * t2;\n\tvec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0., 1. - t1 * t1 - t2 * t2)) * Vh;\n\treturn normalize(vec3(alpha_x * Nh.x, alpha_y * Nh.y, max(0., Nh.z)));\n}\n\nfloat schlickWeight(float cosTheta) {\n\tfloat m = clamp(1. - cosTheta, 0., 1.);\n\tfloat m2 = m * m;\n\treturn m2 * m2 * m;\n}\n\nfloat brightness_contrast(float f,float contrast, float brightness) {\n\treturn f*contrast+brightness+0.5-contrast*0.5;\n}\n\n\n//Utils end\n\n\n//Scene start\n\n//wall\nfloat wall_sdf3d(vec3 p) {\n\tp.xyz -= vec3(0, -1, 0);\n    return sdf3d_smooth_union(\n            box3d(p, vec3(6.1, .47, 6.76)) - .01,\n            box3d(p - vec3(0, 0, -3.77), vec3(6.22, 5.59, .37)) - .01,\n            2.35\n        );\n}\n\nMaterial MFSDF_wall(vec4 uv) {\n\tfloat sdf = wall_sdf3d(uv.xyz);\n\n    return Material(\n        sdf,//sdf\n        vec3(0.37),//color\n        1.,//roughness\n        0.,//metallic\n        0.,//specular\n        0.//emission\n    );\n}\n\n\n//lights\nfloat lights_sdf3d(vec3 p) {\n    return sdf3d_union(\n        box3d(p - vec3(0, 3.23, 0), vec3(.89, .05, .81)) - 1.,\n        box3d(\n            rotate3d(\n                vec3(abs(p.x), p.yz) - vec3(2.95, 1.36, 1.36),\n                -vec3(0, -39, 65) * .01745329\n            ) - vec3(0, 3.23, 0),\n            vec3(.89, .05, .81)\n        ) - 1.\n    );\n}\n\nMaterial MFSDF_lights(vec4 uv) {\n\tfloat sdf = lights_sdf3d(uv.xyz);\n    \n    return Material(\n        sdf,//sdf\n        vec3(0),//color\n        0.,//roughness\n        0.,//metallic\n        0.,//specular\n        4.521//emission\n    );\n}\n\n//cubes\nfloat cubes_sdf3d(vec3 p) {\n\treturn box3d(opRepLim(p, vec3(.05) * 2., vec3(8. - 1., 8. - 1., 8. - 1.)), vec3(.03)) - .005;\n}\n\nMaterial MFSDF_cubes(vec4 uv) {\n\n    float my=(iMouse.y/iResolution.y)*4.0;\n    \n    float scale=2.889;\n\tuv.xyz = rotate3d(uv.xyz - vec3(0, .578, 0), (vec3(.027, .107, .048)+my*0.1) * PI * 2.0) / scale;\n\tfloat sdf = cubes_sdf3d(uv.xyz) * scale;\n    \n    return Material(\n        sdf,//sdf\n        vec3(1., 0., 0.),//color\n        0.,//roughness\n        0.,//metallic\n        .884,//specular\n        0.//emission\n    );\n}\n\n//gold\nfloat gold_sdf_0(vec3 p) {\n    p.xz=sdf_smoothRot(p.xz,18.0);\n    return sphere3d(p, .16);\n}\n\nvec3 gold_dist_tex3d(vec3 p) {\n\n    float my=(iMouse.y/iResolution.y)*4.0;\n    \n\treturn vec3(brightness_contrast(fbm(p * 5.8635 + vec3(10.24+my, 0, 0),0.308) * .5 + .5,2.,0.));\n}\n\nfloat gold_dist(vec3 uv) {\n\tfloat d = gold_sdf_0(uv);\n    if (d <= 0.3) return d - gold_dist_tex3d(uv).x*.096;\n\treturn d;\n}\n\nfloat gold_sdf(vec3 p) {\n\tp -= vec3(0, .68, 0);\n    p /= 2.075;\n    p.xz = twist_rot(p.xz, p.y * 103.133);\n\treturn gold_dist(p) / 1.75;\n}\n\nMaterial MFSDF_gold(vec4 uv) {\n\tfloat sdf = gold_sdf(uv.xyz) * 2.075;\n    \n    return Material(\n        sdf,//sdf\n        vec3(1, .73725497, .203922),//color\n        .195,//roughness\n        1.,//metallic\n        .834,//specular\n        0.//emission\n    );\n}\n\n\n//scene\nMaterial MFSDF(vec4 p) {\n    float mx=(iMouse.x/iResolution.x)*4.0;\n\tMaterial wall = MFSDF_wall(p);\n\tMaterial lights = MFSDF_lights(p);\n\tMaterial wall_lights = mfsdf_union(wall, lights);\n    float cubes_gold_scale=.545;\n    vec4 t=vec4(rotate3d(p.xyz, vec3(0.0,mx,0.0)) / cubes_gold_scale,p.w);\n\tMaterial cubes = MFSDF_cubes(t);\n\tMaterial gold = MFSDF_gold(t);\n\tMaterial cubes_gold = mfsdf_smooth_union(cubes, gold,0.43);\n    cubes_gold.sdf*=cubes_gold_scale;\n\treturn mfsdf_union(wall_lights, cubes_gold);\n}\n\n//Camera\nconst vec3 cam=vec3(2.24, 26.747, 46.293);\nconst float camDistance=.082;\nconst float fov=60.0;\nconst vec3 lookAt=vec3(0, .236, 0);\n\n//Environment\nconst vec3 backgroundColor=vec3(0.05);\n\n//Render quality\n#define maxReflections 5\n#define maxRaymarchIterations 128\n#define maxDistance 200.0\n#define sdfPrecision 0.0001\n\n//Scene end\n\n\nvec3 MFSDF_normal(vec3 p) {\n\tconst vec3 e = vec3(.001, -.001, 0);\n\tfloat v1 = MFSDF(vec4(p + e.xyy, 0)).sdf;\n\tfloat v2 = MFSDF(vec4(p + e.yyx, 0)).sdf;\n\tfloat v3 = MFSDF(vec4(p + e.yxy, 0)).sdf;\n\tfloat v4 = MFSDF(vec4(p + e.xxx, 0)).sdf;\n\treturn normalize(vec3(v4 + v1 - v3 - v2, v3 + v4 - v1 - v2, v2 + v4 - v3 - v1));\n}\n\nvoid raymarch(vec3 o, vec3 v, out vec3 p, inout float d) {\n\tfloat s;\n\tfor (int i = 0; i < maxRaymarchIterations; i++) {\n\t\tp = o + v * d;\n\t\ts = MFSDF(vec4(p, 0)).sdf;\n\t\tif (abs(s) < sdfPrecision) break;\n\t\td += s;\n\t\tif (d > maxDistance) break;\n\t}\n}\n\n\nvec3 pathtracing(uint rngState, vec2 uv) {\n\tconst vec3 o = cam * camDistance;\n\tvec3 c = normalize(lookAt - o);\n\tvec3 cx = normalize(cross(vec3(0, 1, 0), c));\n\tvec3 cy = normalize(cross(cx, c));\n\tvec3 v = normalize(c * 90.0/fov + cx * uv.x + cy * uv.y);\n\tvec3 p;\n\tfloat d = .01;\n\tvec3 rgb = vec3(1);\n\tvec3 io = o;\n\tint i;\n\n\tfor (i = 0; i < maxReflections; i++) {\n\t\traymarch(io, v, p, d);\n\t\tvec3 n = MFSDF_normal(p);\n\t\tvec3 ot;\n\t\tvec3 ob;\n\t\tOnb(n, ot, ob);\n\t\tvec3 vt = vec3(dot(-v, ot), dot(-v, ob), dot(-v, n));\n\t\tif (d < maxDistance) {\n            Material mat=MFSDF(vec4(p, 1.0));\n\n\t\t\tif (mat.emission > .001) {\n\t\t\t\trgb = mat.emission * rgb;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfloat s = RandomFloat01(rngState);\n\t\t\t\tif (s > mat.specular * mat.specular) {\n\t\t\t\t\trgb = (mat.color - mat.color * mat.metallic) * rgb;\n\t\t\t\t\tv = cosineSampleHemissphere(rngState, n);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfloat r2 = mat.roughness * mat.roughness;\n\t\t\t\t\tvec3 vndf = SampleGGXVNDF(rngState, vt, r2, r2);\n\t\t\t\t\tvec3 nv = reflect(-vt, vndf);\n\t\t\t\t\tnv = nv.x * ot + nv.y * ob + nv.z * n;\n\t\t\t\t\trgb = mix(mix(vec3(mat.specular * .08), mat.color, mat.metallic), vec3(1), schlickWeight(dot(n, nv))) * rgb;\n\t\t\t\t\tv = nv;\n\t\t\t\t}\n\n\t\t\t\tio = p;\n\t\t\t\td = .01;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\trgb = backgroundColor;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == 5) rgb = vec3(0);\n\treturn rgb;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\n    // Initialize random number generator state\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + \n                         uint(fragCoord.y) * uint(9277) + \n                         uint(iFrame) * uint(26699)) | uint(1);\n\n    // Calculate jittered pixel coordinates\n    vec2 xy = fragCoord + vec2(RandomFloat01(rngState), RandomFloat01(rngState));\n\n    // Calculate UV coordinates\n    vec2 UV=(xy-iResolution.xy/2.0)/iResolution.y;\n    UV.y=-UV.y;\n\n    // Perform path tracing\n    vec3 rgb = pathtracing(rngState, UV);\n\n    // Set fragment color based on mouse input\n    if (iMouse.z < 0.1) {\n        // Accumulate new sample with previous frame\n        fragColor = vec4(texture(iChannel0, fragCoord / iResolution.xy) + vec4(rgb, 1));\n    } else {\n        // Use only the current sample\n        fragColor = vec4(rgb, 1);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}