{
    "Shader": {
        "info": {
            "date": "1462745761",
            "description": "Get ready for the movie! :)",
            "flags": 0,
            "hasliked": 0,
            "id": "ldKXRz",
            "likes": 42,
            "name": "AngryBird",
            "published": 3,
            "tags": [
                "bird",
                "angry"
            ],
            "usePreview": 0,
            "username": "kuvkar",
            "viewed": 5122
        },
        "renderpass": [
            {
                "code": "mat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\n\n\n//////////////\n// distance functions from from https://iquilezles.org/articles/distfunctions\n/////////////\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec3 bend(vec3 p, float angle)\n{\n\tfloat c = cos(angle*p.z);\n    float s = sin(angle*p.z);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.yz,p.x);\n}\n\n///////////////////////////\n///////////////////////////\n///////////////////////////\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nconst float BODY = 1.0;\nconst float BROW = 2.0;\nconst float BEAK = 3.0;\nconst float EYES = 4.0;\n\nvec3 lightDir = normalize(vec3(4.0, .2, 5.0));\n\n\nfloat sdToes( vec3 p, vec2 h )\n{\n  p.x += sin(p.x * 40.0) * 0.007;\n  p.x += cos(p.y * 600.0) * 0.001;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBeak( vec3 p, float l, float dir )\n{\n  float x = abs(p.x * 1.5) - l;\n  float y = abs(p.y * 1.5) - l;\n  float z = abs(p.z * 1.0) - l;\n  return max(-p.y * dir, max(z, (x + y) * .5 - p.z));\n}\n\nfloat sdCrown(vec3 rp, vec3 cpos, float rotation, float scale, float x)\n{\n    vec3 crownpos = rp + cpos;\n    crownpos = rotz(rotation + sin(iTime * .0) * 0.02) * crownpos;\n    crownpos = roty(1.) * crownpos;\n\tcrownpos.x /= cos(max(crownpos.y, -1.0) * x) * 1.;\n\tcrownpos.z /= cos(max(crownpos.y, -1.0) * x) * .6;\n    return sdBox(crownpos, vec3(0.015,0.04, 0.01) * scale);\n}\n\nfloat eye_left;\nfloat eye_right;\nfloat eyey = -0.08;\nfloat eyex = 0.039;\nfloat eyesize = 0.03;\nvec3 eye_morph = vec3(1.0, 1.2, 2.4);\n\n\nvec4 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    vec4 c1 = texture(tex, p.xy);\n    vec4 c2 = texture(tex, p.yz);\n    vec4 c3 = texture(tex, p.xz);\n    \n    vec4 color = abs(dot(n, vec3(0.0, 0.0, 1.0))) * c1;\n    color += abs(dot(n, \tvec3(1.0, 0.0, 0.0))) * c2;\n    color += abs(dot(n, \tvec3(0.0, 1.0, 0.0))) * c3;\n    return clamp(color, 0.0, 1.0);\n}\n\n\nvec2 map(in vec3 rp)\n{\n    vec3 rp_real = rp;\n\trp.x = -abs(rp.x); // most of the stuff is just mirrored\n    \n    // body\n    float body_top = length((rp + vec3(0.0, -0.1, 0.0)) * vec3(.75, .9, 1.)) - 0.095;\n    float body_bottom = length( (rp + vec3(0.0, 0.1, 0.0)) * vec3(.83, 1., 1.2)) - 0.095;\n    float bdy = smin(body_top, body_bottom, 0.2);\n    \n\t// \"crown\"    \n    float crown = sdCrown(rp_real, vec3(-0.02, -0.23, 0.0), -.9, 1.2, 25.0);\n    float crown2 = sdCrown(rp_real, vec3(-0.04, -0.22, 0.0), -1.2, 1., 35.0);\n    crown = min(crown, crown2);\n    float body = smin(bdy, crown, 0.01);\n\n    // legs\n    vec3 legpos = vec3(0.09, 0.2, 0.0);\n    float left_leg =  length((rp + legpos) * vec3(1.7, 1., 2.)) - 0.05;\n\n    // feet\n    vec3 footpos = vec3(0.0, 0.078, 0.01);\n    \n    float stem     =  sdToes( (rp + legpos + vec3(0.0, -0.03, -0.01) + footpos), vec2(0.012, 0.02));\n    float leftFoot =  sdToes( rotx (0.4) * bend(rp + legpos + vec3(0.015, -0.02, 0.02) + footpos, 12.0), vec2(0.009, 0.03));\n    float leftFoot1 = sdToes( bend (rp + legpos + vec3(0.0, -0.02, 0.01) + footpos, 4.0), vec2(0.01, 0.045));\n    float leftFoot2 = sdToes( rotx (-0.4) * bend(rp + legpos + vec3(-0.015, -0.02, 0.02) + footpos, 12.0), vec2(0.009, 0.03));\n    \n    float feet = smin(leftFoot, leftFoot1, 0.013);\n    feet = smin(feet, leftFoot2, 0.013);\n    feet = smin(stem, feet, 0.01);\n\n    // hands\n    vec3 handpos = vec3(0.15, 0.05, 0.0);\n    vec3 handp = rotz(-0.5) * (rp + handpos);\n    \n    float left_hand = length(handp * vec3(1.4, .45, 1.4 * (1. + rp.y * 2.))) - 0.04;\n    float thumb = sdSphere(  (rp + vec3(0.15, 0.115, 0.0)), 0.01);\n    left_hand = smin(thumb, left_hand, 0.02);\n    \n    float f = smin(body_top, left_hand, 0.11);\n    body = min(body, f);\n    \n    // eye sockets\n    float eye_socket_left = length(rp + vec3(eyex, eyey, .08)) - eyesize;\n    body = max(body, -eye_socket_left);\n    body = smin(body, left_leg, 0.1);\n    \n    // eyes\n    eye_left = length   (  roty(0.3) * (rp + vec3(eyex + 0.01, eyey, .092))  * eye_morph ) - eyesize;\n    float eyes = eye_left;\n    \n    //eyebrows\n    vec3 brow = vec3(0.04, -0.11, 0.098);\n    vec3 browshape = vec3(0.035, 0.014, 0.01);\n    float leftbrow =  sdBox( roty(0.3) * rotz(-0.32) * (rp + brow) * vec3(1.0, 1.0 + rp.x * 3., 1.0), browshape);\n    \n    // beak\n    vec3 beakpos = vec3(0.0, -0.03, 0.12);\n    float beakTop =    sdBeak(             (rp + beakpos) * vec3(1.2, 1., 1.) , 0.02, 1.0);\n    float beakBottom = sdBeak(rotx(-0.4) * (rp + beakpos + vec3(0.0, 0.005, 0.0)) * vec3(1.6, 1.8, 1.0), 0.02, -1.0);\n    float beak = smin(beakTop, beakBottom, 0.014);\n    \n    \n    bool dofeet = feet < body && feet < eyes && feet < leftbrow;\n    bool doeyes = eyes < body && eyes < beak && eyes < leftbrow;\n    bool dobeak = beak < body && beak < leftbrow;\n    bool dobrows = leftbrow < body;\n    \n    if(dofeet)\n    {\n        return vec2(BEAK, feet);\n    }\n    else if(doeyes)\n    {\n        return vec2(EYES, eyes);\n    }\n    else if(dobeak)\n    {\n        return vec2(BEAK, beak);\n    }\n    else if(dobrows)\n    {\n        return vec2(BROW, leftbrow);\n    }else\n    {\n\t    return vec2(BODY, body);\n    }\n}\n\n\nvec3 grad(in vec3 rp)\n{\n    vec2 off = vec2(0.005, 0.0);\n    vec3 g = vec3(map(rp + off.xyy).y - map(rp - off.xyy).y,\n                  map(rp + off.yxy).y - map(rp - off.yxy).y,\n                  map(rp + off.yyx).y - map(rp - off.yyx).y);\n    return normalize(g);\n}\n\nvec3 _rd;\nvec2 _uv;\n\nfloat ao(vec3 rp, vec3 norm)\n{\n    float d = 0.04;\n    rp += norm * d;\n    return mix(1.0, clamp(map(rp).y / d, 0.0, 1.0), 0.6);\n}\n\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    vec3 ro = rp;\n    rp += length(rp) * rd * 0.85;\n  \t  \n    bool hit = false;\n    vec2 hitdata;\n    float mindist = 999.0;\n    vec3 closestpoint;\n    vec2 closesthitdata;\n\n    // BG Colors\n    vec4 bgcol2 = vec4(0.25, 0.25, 0.4, 0.0) * length(_uv - vec2(1.0));\n    bgcol2 = clamp(bgcol2, 0.0, 1.0);\n    vec4 bgcol1 = vec4(0.2, 0.2, 0.15, 0.0) * length(_uv);\n    bgcol1 = clamp(bgcol1, 0.0, 1.0);\n    vec4 bgcol = bgcol2 + bgcol1;\n    \n    for (int i = 0; i < 450; ++i)\n    {\n        hitdata = map(rp);\n        float dist = hitdata.y;\n        \n        if(dist < mindist)\n        {\n            mindist = dist;\n            closestpoint = rp;\n            closesthitdata = hitdata;\n        }\n        \n        if(dist < 0.0)\n        {\n            hit = true;\n            break;\n        }\n        rp += rd * max(dist, 0.001) * 0.07;\n        if(length(ro - rp) > 1.5) break;\n    }\n    \n    float hair_margin = 0.001;\n    vec3 g = grad(closestpoint);\n    \n    // ugly bumpmapping \"hack\", good enuf though! and fast.\n    vec3 uvm = (rp * vec3(.7, 0.2, 1.0) * 2.);\n    vec4 texcol = tex3D(iChannel0, uvm, g);\n    texcol += tex3D(iChannel0, uvm * 0.5, g) * 0.5;\n        \n    if(hitdata.x != BEAK && hitdata.x != EYES)\n    {\n        g = mix(g, g * texcol.rgb, 0.4);\n        g = normalize(g);\n    }\n    //////\n    \n    rp = closestpoint;\n    if(!hit && closesthitdata.x == BODY)\n    {\n        hair_margin = 0.01;\n        mindist += texture(iChannel1, (_rd.xy / _rd.z) * 6.0).r * hair_margin;\n    }\n    \n    if(mindist < hair_margin)\n    {\n        color = vec4(.7, 0.01 ,0.01, 0.0);\n        \n        if(hitdata.x == BODY && g.z < 0.0)\n        {\n\t        //belly\n            float belly =.18;\n            float l = belly - length( (rp + vec3(0.0, 0.06, 0.0)).xy);\n            l += texcol.r * 0.014;\n            l = clamp(l / belly , 0., 1.);\n            l = smoothstep(0.3, .8, l) * 1.;\n            color = mix(color, vec4(1., .22, .15, 0.0), l);\n            \n    \t\t//eye surrounding colors        \n            float socket =.09;\n            l = socket - length( (rp + vec3(0.06, -0.085, 0.0)).xy);\n            l += texcol.r * 0.014;\n            l = clamp(l / socket , 0., 1.);\n            l = smoothstep(-0., .6, l) * 1.;\n            color = mix(color, vec4(.5, .0, .0, 0.0), l);\n\n            l = socket - length( (rp + vec3(-0.06, -0.085, 0.0)).xy);\n            l += texcol.r * 0.014;\n            l = clamp(l / socket , 0., 1.);\n            l = smoothstep(.4, .7, l) * 1.;\n            color = mix(color, vec4(.5, .0, .0, 0.0), l);\n            color = clamp(color, 0.0, 1.0);\n        }\n        else if (hit && hitdata.x == BROW)\n        {\n            color = vec4(0.0);\n        } \n        else if (hit && hitdata.x == BEAK)\n        {\n            color = vec4(1.0, .2, 0.0, 0.0);\n        }\n        else if (hit && hitdata.x == EYES)\n        {\n            float l = abs(eye_left) / 0.01;\n            color.rgb = vec3(smoothstep(0.5, 1.0, l));\n            color.rgb *= smoothstep(1.1, 0.94, l);\n            color = clamp(color, 0.0, 1.0);\n        }\n        \n        color = clamp(color, 0.0, 1.0);\n        \n        vec3 H = normalize(lightDir -rd);\n        float d = dot(g, H);\n        \n        float wrap = 0.3;\n        d = (d + wrap) / (1.0 + wrap);\n        d = smoothstep(-0.2, 1., d);\n        color = mix(color * d, color, 0.1);\n        \n        // light from left side\n        vec3 lightleft = normalize(vec3(-1.0, .4, -.6));\n        vec4 colorleft = vec4(.5, 0.5, .9, 0.0);\n        \n        vec3 HL = normalize(lightleft - rd);\n        float leftl = 1.0 - dot(g, -rd);\n        leftl *= dot(lightleft, g) * 1.;\n        leftl = clamp(leftl, 0.0, 1.0);\n        leftl = pow(leftl, 4.0) * 1.3;\n        \n        color = mix(color, colorleft, leftl * 1.);\n        color *= ao(rp, g);\n\t\tcolor.xyz *= vec3(0.4,0.3,0.6) + vec3(0.6,0.7,0.4)*clamp( (0.28+rp.y)*3.5, 0.0, 1.0 );        \n        color *= 1.1;\n        color.rgb = pow(color.rgb, vec3(1.0 / 2.2));\n        \n    }\n    \n    // fake ground shadows\n    if(!hit && rd.y < 0.0)\n    {\n        \n        float a = dot(vec3(0.0, -.27, 0.0) -ro, vec3(0.0, 1.0, 0.0));\n        float b = dot(rd, vec3(0.0, 1.0, 0.0));\n        float t = a / b;\n        vec3 p = ro + rd * t;\n\t\tbgcol *= smoothstep(-0.1, 0.2, length(p.xz + vec2(0.08, 0.0)));\n\t\tbgcol *= smoothstep(-0.1, 0.2, length(p.xz + vec2(-0.08, 0.0)));\n    }\n    \n    color = mix(bgcol, color, smoothstep(hair_margin, 0.0, mindist));\n    // some wignetting\n    color *= smoothstep(-0.35, 0.2, _uv.y);\n    color *= smoothstep(-0.35, 0.2, 1.0 - _uv.y);\n    color *= smoothstep(-0.35, 0.2, _uv.x);\n    color *= smoothstep(-0.35, 0.2, 1.0 - _uv.x);\n}\n\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    \n    mat3 m;\n    m[0] = r;\n    m[1] = u;\n    m[2] = f;\n    return m;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    _uv = uv;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n\n    fragColor = vec4(0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    _rd = rd;\n    \n    vec3 rp = vec3(0.0, 0.0, -1.2);\n    \n    vec2 im = iMouse.xy / iResolution.xy;\n    im -= vec2(0.5);\n    if(iMouse.z > 0.0)\n    {\n        rp = roty(im.x * 2.0 ) * rp;\n        rp = rotx(im.y * 0.45) * rp;\n    }\n    else\n    {\n        float t = iTime * 0.5;\n        rp = roty(0.8 + sin(t) * 0.1) * rp;\n        rp = rotx(cos(t) * 0.1) * rp;\n        rp.z += sin(t) * 0.1;\n        \n    }\n    \n    rd = lookat(rp, vec3(0.0)) * rd;\n    trace(rp, rd, fragColor);\n    \n    fragColor += (rand(_uv) + rand(_uv) - 0.5) * 0.015;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}