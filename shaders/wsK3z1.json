{
    "Shader": {
        "info": {
            "date": "1569813259",
            "description": "raymarching and reflections",
            "flags": 0,
            "hasliked": 0,
            "id": "wsK3z1",
            "likes": 2,
            "name": "Reflective Orbs",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "atsn",
            "viewed": 329
        },
        "renderpass": [
            {
                "code": "mat3 objSphere(vec3 p,float r){\n    vec3 n = normalize(p);\n\treturn mat3(\n        0.2,0.4,0.2,\n        n.x,n.y,n.z,\n       .31,.02,length(p)-r\n    );\n}\nmat3 objPlane(vec3 p){\n    float rad = 10.;\n    float d = length(vec2(p.x,p.z));\n    \n\treturn mat3(\n        .5,.5,.5 ,\n        0.,1.,0.,\n        //n.x,n.y,n.z,\n        .1,0.3,p.y\n    );\n}\n\nvec3 rotZ(vec3 p,float rad){\t\n    float angle = atan(p.y,p.x)+rad;\n    mat3 rot = mat3(cos(angle),sin(angle),0.,-sin(angle),cos(angle),0.,0.,0.,1.);\n    return p * rot;\n}\n\nvec3 rotY(vec3 p,float rad){\t\n    float angle = atan(p.z,p.x)+rad;\n    mat3 rot = mat3(cos(angle),0.,sin(angle),0.,1.,0.,-sin(angle),0.,cos(angle));\n    return p * rot;\n}\nvoid add(inout mat3 ret, mat3 obj){\n\tif(obj[2][2]<ret[2][2]){\n    \tret = obj;\n    }\n}\n\nmat3 map(vec3 p){\n    \n    //return objSphere(rotY(p+vec3(0.,0.,1.),iTime*5.));\n    \n    mat3 ret = mat3(100.);\n    float amt = 15.;\n    for(float i=0.;i<amt;i++){\n        float ang = (i/amt)*3.1415*2. + iTime*.1;\n        mat3 o = objSphere(\n            p +\n            vec3(cos(ang),sin(ang)*-.5 + sin(iTime*1.+ang*10.)*.01,4.+sin(ang)),.1\n        );\n       \tadd(ret,o);\n        \n    }\n    add(ret,objSphere(\n        p +\n        vec3(0.,0. + sin(iTime*.5)*.05,4.),.4\n    ));\n    \n    //add(ret,objPlane(p+vec3(0.,.7,0.)));\n    add(ret,objSphere(\n        p + vec3(0.,10.5,10.),\n        10.\n    ));\n    return ret;\n}\n\nvec3 normal(vec3 p){\n    vec3 dx = vec3(0.02,0.,0.);\n    vec3 dy = vec3(0.,0.02,0.);\n    vec3 dz = vec3(0.,0.,0.02);\n \treturn normalize(vec3(\n    \tmap(p+dx)[2][2],\n        map(p+dy)[2][2],\n        map(p+dz)[2][2]\n    ));\n}\n\nvec3 fuzz(vec3 p,float amt){\n    vec3 dx = vec3(amt,0.,0.);\n    vec3 dy = vec3(0.,amt,0.);\n    vec3 dz = vec3(0.,0.,amt);\n \treturn normalize(vec3(\n    \tmap(p+dx)[2][2],\n        map(p+dy)[2][2],\n        map(p+dz)[2][2]\n    ));\n}\n\nvec3 lighting(vec3 dir){\n    float t = iTime*1.1;\n\treturn max(\n\t\t(\n            //pow(max(0.,dot(dir,vec3(1.,1.,1.))),1.)*vec3(2.,.3,0.2) +\n            //pow(max(0.,dot(dir,vec3(-1.,1.,1.))),1.)*vec3(0.2,.2,.3)+\n            pow(max(0.,1.+dot(dir,vec3(0.,5.,0.))),1.)*vec3(0.8+sin(iTime*.21)*.5,.8+sin(iTime*.32+103.)*.5,.8+sin(iTime*.4+53.)*.5)\n        ),\n\t\tvec3(0.4,0.4,0.4)\n\t);\n}\nvec3 rayMarch(vec3 start,vec3 dir,int maxSteps,float minDist,float maxDist){\n    float closest = 100.;\n    float dist = 0.;\n    float influence = 1.;\n    vec3 moved = vec3(0.);\n    \n    mat3 hit = mat3(0.);\n    int bounces = 0;\n    \n    vec3 c = vec3(.0);\n    \n    float give = 0.0;\n    \n    while(maxSteps-->0){\n        //give += sin(iTime)*.01+.01;\n        \n        hit = map(start+moved);\n        dist = hit[2][2];\n        give += dist*.001;\n        \n        if(dist<minDist+give){\n            give = 0.;\n            \n            \n            //vec3 n = normal(start+moved,dir);\n            //n += vec3(hit[1][0],hit[1][1],hit[1][2]);\n            \n            vec3 n = vec3(hit[1][0],hit[1][1],hit[1][2]);\n            //return n;\n            \n            \n            //float fg = 8.+sin(iTime)*5.;\n            //n = floor(n*fg)/fg;\n            \n            //Normal map\n            //return n;\n            \n            //calc fresnel\n            float fresnel = pow(1.-dot(-dir,n),1.45);\n            //return vec3(fresnel);\n            \n            \n            //bounce the light\n            bounces++;\n            //n.x += cos(hit[2][1]);\n            \n            //c += influence * max(0.,n.y) * vec3(0.8,0.1,0.1);\n            \n            float alignment = -dot(dir,n);\n            \n            //return vec3(alignment);\n            dir = normalize(alignment*n + (1.-alignment)*dir);\n            moved += dir;\n            \n            c += influence *\n                vec3(hit[0][0],hit[0][1],hit[0][2]) *\n                lighting(dir);\n            \n            \n            influence *= max(hit[2][0],fresnel*hit[2][1]);\n            \n            if(influence<0.01) break;\n            \n        }\n        closest = min(closest,dist);\n        if(dist>maxDist){\n            break;\n\t\t}\n        moved += dir*dist;\n    }\n    \n    //Sun\n    //c += influence*dot(dir,vec3(sin(iTime),1.,0.))*vec3(1.,0.,0.);\n    //Ambient\n    //c += influence*lighting(dir);\n    c += influence*lighting(dir);\n    if(bounces==0){\n        //return c*.5;\n    }\n\t\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\t\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.);\n   \t\n    vec3 cpos = vec3(0.,0.,-4.);\n    \n    \n    float xAng = atan(cpos.z,uv.x-cpos.x);\n    float yAng = atan(cpos.z,uv.y-cpos.y);\n    vec3 off = normalize(vec3(\n        cos(xAng),\n        cos(yAng),\n        cpos.z\n    ));\n    \n    vec3 pix = rayMarch(vec3(uv.x,uv.y,0.),off,80,0.001,3.1);\n    \n\n\tcol = vec3(pix.r,pix.g,pix.b);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}