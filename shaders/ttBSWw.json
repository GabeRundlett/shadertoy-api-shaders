{
    "Shader": {
        "info": {
            "date": "1566031843",
            "description": "Deltoid Zebra",
            "flags": 0,
            "hasliked": 0,
            "id": "ttBSWw",
            "likes": 8,
            "name": "Deltoid Zebra",
            "published": 3,
            "tags": [
                "noise",
                "waves",
                "triangle"
            ],
            "usePreview": 0,
            "username": "1GR3",
            "viewed": 514
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926536\n#define TWO_PI 6.2831853072\n#define time iTime\n\n// --- Config ---\n#define totalT 5.0\n#define spread 0.5\n// Triangle\n#define triRadius 0.45\n\nmat2 rotMat2 (in float a);\nfloat vfbmWarp(in vec2 p);\n\nvec3 pattern (in vec2 uv) {\n  vec3 color = vec3(0);\n\n  float modT = mod(time, totalT);\n  float cosT = TWO_PI / totalT * modT;\n\n  // --- Space warp ---\n  vec2 qW = uv;\n  qW += vec2(0.3, -0.1);\n  qW += 0.050 * cos(3.0 * qW.yx + cosT);\n  qW += 0.025 * cos(5.0 * qW.yx + cosT);\n  qW *= 1.075 * vfbmWarp(vec2(0.05) * qW);\n\n  const float edge = 0.2;\n  const float thickness = 0.5;\n  vec2 axis = vec2(0, 1);\n\n  // --- Rotate axis over time ---\n  axis *= rotMat2(PI * 0.0625 * sin(TWO_PI * (modT / totalT + 0.5 * dot(qW, vec2(1)))));\n  axis *= rotMat2(PI * 0.25 * sin(TWO_PI * (modT / totalT - 0.5 * length(qW))));\n\n  // --- Render lines ---\n  float n = smoothstep(thickness, thickness + edge, sin(TWO_PI * 24.0 * dot(qW, axis)));\n  color.r = n;\n  n = smoothstep(thickness, thickness + edge, sin(TWO_PI * 24.0 * dot(qW, axis) + 0.5 * spread));\n  color.g = n;\n  n = smoothstep(thickness, thickness + edge, sin(TWO_PI * 24.0 * dot(qW, axis) + spread));\n  color.b = n;\n\n  // --- Triangle crop ---\n  vec2 q = uv;\n  const float cropEdge = 0.01;\n  const vec2 point1 = vec2(0, triRadius * 1.414214);\n  const vec2 point2 = vec2(0.5 * triRadius, 0);\n  // Point 3 is created via horizontal mirror\n  q.x = abs(q.x);\n\n  // Height adjustment (Number is tan(30ยบ))\n  q.y += 0.5 * triRadius * 0.5773502692;\n  q.y += triRadius * 0.333333; // Manual adjustment\n\n  float m = 1.0; // Start w/ everything included\n  m *= smoothstep(point2.y - cropEdge, point2.y, q.y); // Bottom edge\n  vec2 midPoint = 0.5 * (point1 + point2);\n  float d = length(midPoint);\n\n  // Find Perpendicular vector pointing outward\n  vec2 midPointPerpendicular = vec2(0, 1) * rotMat2(-0.333333 * PI);\n\n  m *= smoothstep(d, d - cropEdge, dot(q, midPointPerpendicular));\n  color *= m;\n\n  return color;\n}\n\n// --- Utility functions & noise ---\nmat2 rotMat2 (in float a ) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, -s, s, c);\n}\n\n\n// source: https://www.shadertoy.com/view/4d3fWf\nfloat noise( in vec2 x ) {\n  return sin(1.52*x.x)*sin(1.48*x.y);\n}\n\nfloat vfbm4 (vec2 p) {\n  float f = 0.0;\n  float a = PI * 0.173;\n  mat2 m = rotMat2(a);\n\n  f += 0.500000 * noise( p ); p *= m * 2.02;\n  f += 0.250000 * noise( p ); p *= m * 2.03;\n  f += 0.125000 * noise( p ); p *= m * 2.01;\n  f += 0.062500 * noise( p ); p *= m * 2.025;\n\n  return f * 0.9875;\n}\n\nfloat vfbm6 (vec2 p) {\n  float f = 0.0;\n  float a = 1.123;\n  mat2 m = rotMat2(a);\n\n  f += 0.500000 * (0.5 + 0.5 * noise( p )); p *= m * 2.02;\n  f += 0.250000 * (0.5 + 0.5 * noise( p )); p *= m * 2.03;\n  f += 0.125000 * (0.5 + 0.5 * noise( p )); p *= m * 2.01;\n  f += 0.062500 * (0.5 + 0.5 * noise( p )); p *= m * 2.025;\n  f += 0.031250 * (0.5 + 0.5 * noise( p )); p *= m * 2.011;\n  f += 0.015625 * (0.5 + 0.5 * noise( p )); p *= m * 2.0232;\n\n  return f * 0.9875;\n}\n\nfloat vfbmWarp (vec2 p, out vec2 q, out vec2 s, vec2 r) {\n  const float scale = 4.0;\n  const float angle = 0.01 * PI;\n  const float si = sin(angle);\n  const float c = cos(angle);\n  const mat2 rot = mat2(c, si, -si, c);\n\n  q = vec2(\n        vfbm4(p + vec2(0.0, 0.0)),\n        vfbm4(p + vec2(3.2, 34.5)));\n  q *= rot;\n\n  s = vec2(\n        vfbm4(p + scale * q + vec2(23.9, 234.0)),\n        vfbm4(p + scale * q + vec2(7.0, -232.0)));\n  s *= rot;\n\n  return vfbm6(p + scale * s);\n}\n\n// Overload for 1 argument\nfloat vfbmWarp (vec2 p) {\n  vec2 q = vec2(0);\n  vec2 s = vec2(0);\n  vec2 r = vec2(0);\n\n  return vfbmWarp(p, q, s, r);\n}\n\n// --- Render ---\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize to [-1, -1] -> [1, 1]\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n\n    // Output to screen\n    fragColor = vec4(pattern(uv),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}