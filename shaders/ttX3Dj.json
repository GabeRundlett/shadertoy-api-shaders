{
    "Shader": {
        "info": {
            "date": "1557701356",
            "description": "mouse.x=pattern\nmouse.y=zoom\nhttps://en.wikipedia.org/wiki/Frieze_group\nhttps://en.wikipedia.org/wiki/Wallpaper_group\nwith uniform relative scaling",
            "flags": 0,
            "hasliked": 0,
            "id": "ttX3Dj",
            "likes": 5,
            "name": "FriezeGroup+WallpaperGroup",
            "published": 3,
            "tags": [
                "tiles",
                "lattice",
                "skew",
                "wallpapergroup",
                "wallpapergroup",
                "p6m",
                "p31m",
                "p3m1",
                "p1",
                "p2",
                "frieze",
                "cmm",
                "pmm",
                "p4g",
                "p4m",
                "pmg",
                "pg"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 698
        },
        "renderpass": [
            {
                "code": "/*\nmouse.x=pattern\nmouse.y=zoom\n\nTags:\nWallpaper,Frieze,cmm,pmm,p1,p2,p4g,p4m,pmg,pg,p3m1,p31m,p6m,11g,1m1,tiles,lattice,skew\n\nhttps://en.wikipedia.org/wiki/Frieze_group\nhttps://en.wikipedia.org/wiki/Wallpaper_group\ngive examples how to use this for\n;wallpapers,FbmNoise/textures,weaves\n,fenches,pavement,brickwork,carpet,tablecloth,decor\n,complexTransformations,SphereInversions,MoebiusTransformations\n\nfull frieze and wallpaper group wizt; \n- uniform tile size        ,all tile side lengths are the same\n- uniform first derivative ,all f-shapes are the same size\n- somewhat centric         ,all f-shapes are in the center of the segment\n- - lets you (fractally) define patterns of patterns:\n\ncompromises:\n- wallpaper group tileID is not calculated\n- wallpaper group parity is not calculated\n- frieze    group parity is not shown \n- frieze11m behaves like its WallpaperGroup (modulo along .y)\n- frieze2mm behaves like its WallpaperGroup (modulo along .y)\n- p3m1 tiles poorly along .y\n- p6   tiles poorly along .y\n\na more barycentric  with more tileID and symmetry is being developed: \nhttps://www.shadertoy.com/view/tts3D2\n\ncontent shaders are:\nparent Frieze   : https://www.shadertoy.com/view/MdGfRc\nparent wallpaper: https://www.shadertoy.com/view/WtXGWj\nparent skew     : https://www.shadertoy.com/view/lltcR7\nparent glide    : https://www.shadertoy.com/view/XsfBDH\nparent triCoords: https://www.shadertoy.com/view/4dKXR3\nrecipe          : https://twitter.com/ollj/status/112690634711778508\ntwitter image   : https://twitter.com/ollj/status/1127276851171418112\nparent UIcontext: https://www.shadertoy.com/view/lt3fDS\n- Shader: 2dProceduralPattern.glsl  by gPlatl\n- A collection of 2d procedural pattern types\n-  tags:   procedural, pattern, 2d, basic, texture, collection\n- references:\n- Procedural Patterns         http://slideplayer.com/slide/6400090/\n- Antialiasing Proc. Textures http://www.yaldex.com/open-gl/ch17lev1sec4.html\n\nmodified to return a vec4\n\ntheres an upcoming flood of fixed wallpapers:\n\np1  : https://www.shadertoy.com/view/tlsGD2\nP2  : https://www.shadertoy.com/view/tllGD2\np31m: https://www.shadertoy.com/view/tts3D2\n\n/**/\n\n#define patternCount 25.0\n\nbool ANIMATE = true;   // false if mousePressed\n\n//uniformed wallpaper and frieze\n//[u*   ]==uniform uv\n//[*f*  ]==frieze\n//[*p*  ]==wallpaper (should be *g*)\n//[ *NNN]==tile notation\nvec4 tree64(vec2 u,int q){vec4 p=vec4(0)\n    /**/\n ;if(q== 0)return uf11m(u)//known to tile poorly along .y\n ;if(q== 1)return uf2mm(u)//known to tile poorly along .y\n ;if(q== 2)return uf2mg(u)\n ;if(q== 3)return uf11g(u)\n ;if(q== 4)return uf2  (u)\n ;if(q== 5)return uf1  (u)\n ;if(q== 6)return uf1m1(u)\n     \n ;if(q== 7)return up2  (u) \n     /**/\n ;if(q== 8)return ucm  (u) \n ;if(q== 9)return up1  (u)\n ;if(q==10)return upg  (u)  \n ;if(q==11)return upm  (u) \n ;if(q==12)return upmg (u)   /*  */          \n ;if(q==13)return upmm (u) /**/\n ;if(q==14)return ucmm (u)\n ;if(q==15)return up4m (u) \n ;if(q==16)return up4  (u)\n ;if(q==17)return up4g (u)/**/\n\n ;if(q==18)return upgg (u)       /**/\n ;if(q==19)return up3m1(u*3./2.)*3./2.// *2/3 scaling fixes .y repeats\n\n   ;if(q==20)return up31m(u)\n ;if(q==21)return up3  (u)\n     \n ;if(q==24)return hex2 (u)\n     \n ;if(q==22)return up6  (u*2./3.)*3./2.// *2/3 scaling fixes .y repeats\n ;if(q==23)return up6m (u) \n ;if(q==25)return vec4(cos(iTime))\n     //return v3(p4m (u)    -a*v1( 2,1),0,1)\n    /*\n ;     if(q== 0)return vec4(hexBorder(u*1.25)) \n ;else if(q== 1)return vec4(hexBorder(u*1.25)) //HexagonalGrid2() is just BAD, skewed and discontinuous\n ;else if(q== 2)return vec4(hexId3Hues(u*2.0))\n ;else if(q== 3)return vec4(hexTruchet(u*3.))\n ;else if(q== 4)return vec4(CheckerSignMuFract(u))\n ;else if(q== 5)return vec4(Checker1ByMuSin(u*8.0))\n     /*\n ;else if(q== 6)return vec4(TrianglePattern(u))\n ;else if(q== 7)return vec4(RhombStar(u))\n ;else if(q== 8)return vec4(TartanKaro(u))\n ;else if(q== 9)p=vec4(TartanSquare(u))\n ;else if(q==10)p=vec4(SquareHolePattern(u)) \n ;else if(q==11)p=vec4(sinePattern(u))\n ;else if(q==12)p=vec4(Grid(u))\n ;else if(q==13)p=vec4(BrickPattern(u))\n ;else if(q==14)p=vec4(GearPattern(u, 1.5, 12, iTime * 6.5))\n ;else if(q==15)p=vec4(QCirclePattern(u))\n ;else if(q==16)p=vec4(StarPattern(u))\n ;else if(q==17)p=vec4(weave(u))\n ;else if(q==18)p=vec4(weave(u,2.))\n ;else if(q==19)p=vec4(weave(u,3.))\n ;else if(q==20)p=vec4(weave(u,4.))\n ;else if(q==21)p=vec4(truchetTiny70s(u,iTime*0.1))\n ;else if(q==22)p=vec4(weaveInt(u))*/\n\n/*\nvec2 pmm(vec2 u){return     mh(mh (pmod2(u).yx).yx);}//swivel gallore.\nvec2 p1 (vec2 u){return           (pmod2(u));}\nvec2 p2 (vec2 u){return        gd0(pmod2(u));}\nvec2 p4 (vec2 u){return        p4S(pmod2(u));}\nvec2 p4g(vec2 u){return       p4gs(pmod2(u));}\nvec2 pmg(vec2 u){return       pmgs(pmod2(u/2.)*2.);}//pmg is a special snowflake\nvec2 pgg(vec2 u){return       pggs(pmod2(u   )*2.);}\nvec2 pg (vec2 u){return        gh (pmod2(u));}\nvec2 p4m(vec2 u){return mh(md1(md0(pmod2(u))));}\n     /**/\n     \n ;else return vec4(0)\n ;return p;}\n\nvoid mainImage(out vec4 fragColor,vec2 u\n){float t=iTime\n ;vec3 r=iResolution.xyz\n ;float aspect=r.y/r.x\n ;vec2 v=u\n ;vec2 m=iMouse.xy/r.y\n ;u=u.xy/r.y-.5\n ;ANIMATE=iMouse.z<1.\n ;int pType=int(m.x*patternCount*aspect)\n ;if (u.y<-0.4//menu bar\n ){pType=int(v.xy/r.y*patternCount*aspect);\n  u*=28.\n ;}else{//big frame\n  ;u*=(.2+m.y)*4.\n  ;if(ANIMATE\n  ){u*=r2(t*.12)         //rotate\n   ;u*=(1.2+.3*sin(.5*t))//scale\n  ;}}\n ;vec4 p=tree64(u,pType)\n ;vec2 q=(p.xy+.5)//fract(p.xy*3.)\n ;p.xy+=cs(t)*+.2*(cos(t*1.61)*.5+.5)//aperiodic spirograph\n ;vec2 id=p.yz\n ;//p.xy+=p.w\n  \n ;vec2 K=(vec2(1,4)+u5(vec2(.5,2)*cs(iTime*8.)))//wiggly j-shape proportions\n ;p.xyz=vec3(smoothFf((p.xy)*2.,K))\n ;id*=vec2(1,.16)*mix(19.,9.,-cos(t*.2)*.5+.5)\n ;p.y+=fract(id.y+id.y)\n     \n ;p.xz+=q\n //;else if (pType ==19) p = DiamondPattern(u)    //is just a distorted grid()\n //;else if (pType ==20) p = triRosettePattern(u) //disqualified, for looping a wallpaper-group:\n //;else if (pType ==13) p = BrickPattern2(u)//is just a much worse variant of BrickPattern()\n ;fragColor = p\n ;}\n\n/*\n\n//disqualified, for looping a wallpaper-group: https://en.wikipedia.org/wiki/Wallpaper_group\n//i haver standards, and looping trough a kifs is WAY below that.\n#define DumbEnoughToLoopAWallpaperGroup(U) .004/abs(length(mod(U,d+d)-d)-d.x)\nfloat triRosettePattern(vec2 p//https://www.shadertoy.com/view/4lGyz3\n){vec2 d=vec2(sqrt(3.),3)/3.\n ;vec4 O=vec4(0)\n ;for(; O.a++ < 4.; O += DumbEnoughToLoopAWallpaperGroup(p) +DumbEnoughToLoopAWallpaperGroup(p += d*.5))p.x+=d.x\n ;return O.x;}\n\n\n//---------------------------------------------------------\n// return antialiased hexagonal grid color\n//---------------------------------------------------------\n/* //this one is just lazy and bad!\nfloat HexagonalGrid2 (in vec2 position)\n{\n  vec2 pos = position ;\n  pos.x *= 1.1;\n  pos.y += 0.5 * mod(floor(pos.x), 2.0);\n  pos = abs(fract(pos) - 0.5);\n  float d = abs(max(pos.x*2.5 + pos.y, pos.y*3.0) - 1.0);\n  return smoothstep(0.30, .1, d);\n;}\n*/\n\n/*\n// return brick wall pattern\nfloat BrickPattern2(in vec2 p){//brickpattern2 is just a the dumb cousin of BrickPattern()\n    const float vSize = 0.30;\n  const float hSize = 0.05;\n  p.y *= 2.5;    // scale y\n  if(mod(p.y, 2.0) < 1.0) p.x += 0.5;\n  p = p - floor(p);\n  if((p.x+hSize) > 1.0 || (p.y < vSize)) return 1.0;\n  return 0.0;\n}*/\n\n/*\nfloat DiamondPattern(vec2 u//https://www.shadertoy.com/view/lsVczV\n){u=abs(fract(u)-.5)\n ;return (ma(u));}//without distortions and cosine/smoothstep/scaling, this is just a grid()\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi acos(-1.)\n//float TAU=6.28318530718;\n\n#define dd(a) dot(a,a)\n\n#define aA(z) (z/min(iResolution.x,iResolution.y))\n\n\n\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y//usually first function of mainImage(),not typecast.\n\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define ss(a,u)smoothstep(a,-a,u)\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\nv0 ad(v3 a){return dot(v3(1),a);}\nv0 ad(v2 a){return dot(v2(1),a);}\nv0 ad(v1 a){return a.x+a.y;}//aka suv()\nv0 ma(v1 a){return max(a.y,a.x);}\nv0 ma(v2 a){return max(a.z,ma(a.xy));}\nv0 ma(v3 a){return max(ma(a.zw),ma(a.xy));}\nv0 mu(v1 a){return a.x*a.y;}\nv0 su(v1 a){return a.x-a.y;}\nv0 sq2(v0 a){return a*a;}\n#define mi(a)-ma(-a)\n\n#define mStretch(u,m).5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n\n//vec2 c2p(vec2 u){return vec2(length(u),atan(u.y,u.x));}\n//vec2 p2c(vec2 u){return cs(u.y)*u.x;}\nvec2 cs(vec2 a){return vec2(cos(a.x),sin(a.y));}\nvec2 cs(float a){return vec2(cos(a),sin(a));}\nmat2 r2(float a){vec2 s=cs(a);return mat2(s,-s.y,s.x);}\n\n#define mad(a,b,c)((a)*(b)+(c))\n#define ab012(a,b)mad(vec3(0,1,2),b,a)\n#define c11(a,b)clamp(a/b,-1.,1.)*b\n\n#define rs3 sqrt(3.)\n#define rs5 sqrt(5.)\n#define u2(a)((a)*2.-1.)\n#define u3(a)((a)*2.+1.)\n#define u4(a)((a)*.5-.5)\n#define u5(a)((a)*.5+.5)\n#define phi u4(rs5)\n#define Phi u5(rs5)\n//(reciprocal) [skewConstant] arithmetic:   [rs*]==[reciprocal square of *]\n// ske==.36602540378;//==sqrt(3.)*.5-.5\n#define   ske u4(rs3)\n//reSke=.21132486540;//==(sqrt(3.)*.5-.5)/sqrt(3.)==.5-.5/sqrt(3.)\n#define reSke u4(rs3)/rs3\n//enter [0.366025] or [.2113248654] in search engines and be amazed by peoplewho use values without knowing them\nvec2   skew(vec2 u){return u+ad(u)*ske;}\nvec2 unskew(vec2 u){return u-ad(u)*reSke;}\n\n\n#define doublestretch\nfloat jj(vec2 u,vec2 m){u+=m*.5//parametric j-shape m sets limb lengths.\n ;if(!(u.y-1.>0.||u.x+1.<0.))return abs(length(u-vec2(-1,1))-2.)//<-bottom right curve;\n ;m=abs(m)\n ;vec2 b=vec2(u.x-1.,mStretch((u.y-1.),m.y))//<-top right straight has priority\n ;u.y+=1.\n #ifdef doublestretch\n  ;u.x=mStretch(u.x,(m.x+1.));//bottom left straight STRETCH is optional here\n #else\n  ;u.x+=1.\n #endif \n ;vec2 c=u*sign(u.x+u.y+2.001)//<-bottom left straight,includes uncanny reflection\n ;u.y=sign(u.y-1.)+1.\n ;c=.5*u.y*(b+c)-c//c=mix(c,b,sign(u.y-1.)*.5+.5)\n ;return length(c);}\n\nfloat ff(vec2 u,vec2 m//parametric f-shape m sets limb lengths.\n){vec2 v=u\n ;v.x=abs(abs(v.x-.75)-1.)+1.//-.2\n ;//v.x/=2.\n ;//u.x=abs(u.x+2.)\n ;float a=length(v-m+vec2(0,4))\n ;return min(a,jj(-u,m))\n ;}\n\n\nfloat smoothFf(vec2 U,vec2 K){\n ;return smoothstep(.1,-.1,abs(ff(U*19.,K)-.6)-.3);}\n\n\n//you might want to pause time at iTime==0\n\n//https://en.wikipedia.org/wiki/Wallpaper_group\n//gices examples how to use this for\n//wallpapers,FbmNoise/textures,weaves,fenches,pavement,brickwork,carpet,tablecloth,decor\n//...,complexTransformations,SphereInversions,MoebiusTransformations\n//this is the 2d extension to [frieze]:\n//https://www.shadertoy.com/results?query=frieze\n\n//[skewIt] skew()ing barely makes sense for most cases, especially not for the 5of17 hex-tilings, but it is not completely useless.\n//#define skewIt\n\n//2d zoom\n//#define ViewZoom mix(1.,29.,-cos(iTime*.3)*.5+.5)\n#define ViewZoom 6.\n\n/*\n2 lines of code for editing are named:\n- [[17 of 17 wallpaper group function names]]\n- [[change function name here              ]]\n\n\n\n\nself         : https://www.shadertoy.com/view/WtXGWj\nparent skew  : https://www.shadertoy.com/view/lltcR7\nparent glide : https://www.shadertoy.com/view/XsfBDH\nrecipe       : https://twitter.com/ollj/status/112690634711778508\ntwitter image: https://twitter.com/ollj/status/1127276851171418112\n\nis still missing some fine tuning\np6m and p3m1 have a scaleablility bug. sloppy hex-modulo.\n\nis still full of older parent code (mostly evacuated to commonRab)\n*/\n\n\n//below are subroutines for WallpaperGroup\n\nvec2 md0(vec2 u//mirror diagonally slash\n){if(u.x<u.y)u=u.yx//*vec2(1,-1)\n ;return u;}\n\nvec2 md1(vec2 u//mirror diagonally backslash\n){u.y=-u.y\n ;u=md0(u)\n ;u.y=-u.y\n ;return u;}\n\nvec2 mh(vec2 u//glideReflect horizontally\n){u.y=abs(u.y)\n ;return u;}\n\n\nvec2 gh(vec2 u//glideReflect horizontally\n){if(u.y<0.)u.x=-u.x\n ;u.y=abs(u.y)\n ;return u;}\n\nvec2 gd0(vec2 u//glideReflect diagonally slash\n){if(u.x<u.y)u.xy=-u.xy\n ;u=md0(u)\n ;return u;}\n\nvec2 gd1(vec2 u//glideReflect diagonally backslash\n){u.y=-u.y\n ;u=gd0(u)\n ;u.y=-u.y  \n ;return u;}\n\nvec2 pmgs(vec2 u//pmg is a special snowflake\n){if(u.x<.0)return vec2(u.x,abs(u.y))\n ;return vec2(0,1.)-abs(u);}\n\n//*s functions are subsets, without modulo-context.\n//they are scaling.-oblivious, as this is to be defined by the context!\n\nvec2 p4S(vec2 u){//p4, you are so odd, but i crunched you!\n       /* ;     if(!((u.x>0.||u.y<0.)&&(u.x<0.||u.y>0.)))*/\n ;if(sign(u.x)!=sign(u.y))u=u.yx*vec2(-1,1) \n   // ;else if(u.x>0.&&u.y<0.)u=u.yx*vec2(-1,1)\n  //  ;     if(u.x<0.&&u.y>0.)u=u.yx*vec2(-1,1) \n   // ;else if(u.x>0.&&u.y<0.)u=u.yx*vec2(-1,1) \n;return gh(u);}\n\nvec2 p4gs(vec2 u){return md1(p4S(u)*2.-.5)/2.;}//what an offset!\n\nvec2 pggs(vec2 u//tricky bastard!\n){u=gh(u)\n ;vec2 d=vec2(u.x,-u.x)+u.y-1.;\n ;d.x=max(d.x,d.y)\n ;if(d.x>0.)return mix(vec2(1)-gd1(u),gd0(u)+vec2(-1,1),step(u.x,0.))\n ;return u;}\n/* //THAT tricky:\nvec2 pggsbackup(vec2 u){//this one was hard, this was my first sucess to getting pggs()\n ;u=gh(u)\n ;if(u.x+u.y-1.>0.)return (gd1(u)*vec2(-1,-1)+vec2(1,-1)*vec2(-1,-1))+vec2(2,0)\n ;if(u.x-u.y+1.<0.)return gd0(u)+vec2(-1,1)\n ;return u;}*/\n\n//see mercury.sexy/hg.sdf\nvec2 pmod2(vec2 u){return fract(u-.5)-.5;}//no floor returned\n\n//below are beta-wrappers of the above\n//i have not yet decided on how to unify them \n//as scaling are a bit off between a few of them\n\nfloat pModPolar(inout vec2 p, float repetitions// mercury.sexy/hg.sdf\n){float angle = 2.*pi/repetitions\n ;float a = atan(p.y, p.x) + angle/2.\n ;float r = length(p)\n ;float c = floor(a/angle)\n ;a = mod(a,angle) - angle/2.\n ;p = vec2(cos(a), sin(a))*r\n ; // For an odd number of repetitions, fix cell index of the cell in -x direction // (cell index would be e.g. -5 and 5 in the two halves of the cell): \n ;//if (abs(c) >= (repetitions/2.)) c = abs(c); \n ;return c;}\n\nvec2 p3m1S(vec2 u//confirmed, is p3m1, a simple one\n){float g=pModPolar(u,6.)\n ;u-=vec2(sqrt(3.)*2./6.,0.)\n ;float yy=mod(g,2.)\n ;if(yy>0.)u=vec2(u.x,-u.y)//needed for p3m1\n ;return u;}\n\nvec2 p3S(vec2 u//p3 looks strange in its star form, but thisis indeed [p3]\n){float g=pModPolar(u,6.)\n ;u-=vec2(sqrt(3.)*2./6.,0.)\n ;float yy=mod(g,2.)\n ;g=pModPolar(u,3.)\n ;if(yy>0.)u=vec2(-u.x+.575,-u.y)\n ;return u;}\n\nvec2 p6S(vec2 u//confirmed, is p6 (each triangle rotates the same angle)\n){float g=pModPolar(u,6.)\n ;u-=vec2(sqrt(3.)*2./6.,0.)\n ;float yy=mod(g,2.)\n ;g=pModPolar(u,3.)\n ;return -u;}//-u is an arbitiary sign flip, if only to distinguish it by making it blue!\n\nvec2 p31mS(vec2 u//confirmed, is p31m, triangle rotation oscillates, so there is mirror symmetry at triangle borders.\n){float g=pModPolar(u,6.)\n ;u-=vec2(sqrt(3.)*2./6.,0.)\n ;float yy=mod(g,2.)\n ;g=pModPolar(u,3.)\n ;if(yy>0.)u=vec2(u.x,-u.y)\n ;return u;}\n\nvec2 p6mS(vec2 u//confirmed is p6m\n){float g=pModPolar(u,6.)\n ;//u-=vec2(sqrt(3.)*2./6.,0.)//not essential, but shows hex borders\n ;u.y=abs(u.y)//this abs() is p6m specific\n ;u=u.yx//not needed, but you may want to sqivel uv to make the [f]-shape fit.\n ;return u;}\n\n//theres a lot to optimize \n//as the aviove 5 functions are pretty similar:\n\n/*\n//barycentric to carthesian,carthesian is weighted average of barycentrics.\nvec2 b2c(vec3 l,vec2 a,vec2 b,vec2 c){//Barycentric2Carthesian\n ;return vec2(ad(vec3(a.x,b.x,c.x)*l),ad(vec3(a.y,b.y,c.y)*l))\n//;mat3 m=matrixCompMult(transpose(mat3(a,0,b,0,c,0)),mat3(l,l,0,0,0));return vec2(suv(m[0]),suv(m[1]))\n ;}\n//carthesian to barycentric\nvec3 c2b(vec2 u,vec2 a,vec2 b,vec2 c//there are more elegant versions of this with inverse()of the right matrix.\n){u-=c;b.y-=c.y;a.x-=c.x;c.x-=b.x;b.x=b.y*a.x+c.x*(a.y-c.y)//determinant\n ;vec3 r=vec3(ad(u*vec2(b.y,c.x)),ad(u*vec2(c.y-a.y,a.x)),0);r.z=ad(r.xy);r/=b.x;r.z=1.-r.z ;return r;}\n/**/\n\nvec4 hex2(vec2 u//https://www.shadertoy.com/view/4lt3DX\n){const float w=1.53,q=w*.5\n ;//vec2 v=iResolution.xy\n// ,//u=i=(i-v/2.)/v.y*5.*q //center\n ;u/=2. //sqrt(3.)\n ;vec2 i=u\n ;u*=mat2(1.,-1./w,0.,2./w)\n ;vec3 g=vec3(u,1.-u.xy)//to hex\n ;u=floor(g).xy*mat2(1.,.5,0.,q)//cell id\n ;vec2 a=u+vec2(1,0)\n      ,b=u+vec2(.5,q)\n      ,c=u+vec2(1.5,q)\n ;//4 SQUARED screenspace distances to nodes:\n ;vec4 f=vec4(dd(b-i),dd(a-i),dd(u-i),dd(c-i))\n ;f.w=mi(f)//set .w to shortest of 4 distances  \n ;vec2 m=vec2(1)//iMouse.xy/iResolution.xy\n ;//if(iMouse.z<=0.)m.xy=cs(iTime)*.5+.5\n #ifdef KeyholeCircles\n ;f.w=exp2(-23.)//optional cheap keyhole-circles\n #endif\n ;if(f.w!=0.&&m.x!=0.)f.w=pow(abs(f.w),m.x)//not busting a NaN!\n ;else f.w=.5\n ;f.xyz=step(vec3(0),f.w-f.xyz)\n ;b=(b-c)*f.x\n ;a=(a-c-b)*f.y \n ;c=c+b+a\n ;vec2 t=mix(c,u,f.z) //c+(u-c)*l.z   \n ;u=i-t \n ;return vec4(u,t)//unformatted output\n ;}\n\n\n\nvec2 pmodHexB(vec2 u\n){//this one is a sloppy patch for 2 bad cases:\n  \n ;float s=sqrt(3.)\n     /*\n ;vec4 a=hex2(u);\n ;return a.xy\n ;return u;\n     /**/\n ;u.x=(fract(u.x/s-.5)-.5)*s\n ;u=r2(pi/3.)*u\n    \n ;u.x=(fract(u.x/s-.5)-.5)*s \n ;u=r2(pi/3.)*u\n ;u.x=(fract(u.x/s-.5)-.5)*s \n ;u=r2(pi/3.)*u     \n ;u.x=(fract(u.x/s-.5)-.5)*s \n ;u=r2(pi/3.)*u\n ;u.x=(fract(u.x/s-.5)-.5)*s \n ;u=r2(pi/3.)*u\n ;u.x=(fract(u.x/s-.5)-.5)*s \n ;u=r2(pi/3.)*u\n ;u.x=(fract(u.x/s-.5)-.5)*s\n     /**/\n // thereare never enough iterations for this, this is a BAD patch\n  ;return u;}\n//p3m1 does not play nice in pmodHex()\n//p6m does not placx nice in pmodHex()\n//really, these need to do a full rotation, and more?\n//sloppy work, but its a first semi-working draft!\n\nvec2 pmodHex(vec2 u\n){return pmodHexB(u)\n ;float s=sqrt(3.)\n ;vec4 a=hex2(u);\n ;return a.xy\n ;return u;\n;}\n\n//[[17 of 17 wallpaper group function names]]\nvec2 p3m1(vec2 u){return p3m1S(pmodHex(u));}\nvec2 p31m(vec2 u){return p31mS(pmodHex(u));}\nvec2 p3  (vec2 u){return   p3S(pmodHex(u));}\nvec2 p6  (vec2 u){return   p6S(pmodHex(u));}\nvec2 p6m (vec2 u){return  p6mS(pmodHexB(u));}\n//above are barycentric (need a hexagonal lattice)\n//below are carthesia, (need a rectangle|square-lattice)\nvec2 cmm(vec2 u){return    md1(md0(pmod2(u)));}\nvec2 cm (vec2 u){return        md0(pmod2(u));}\nvec2 pm (vec2 u){return        mh (pmod2(u));}\nvec2 pmm(vec2 u){return     mh(mh (pmod2(u).yx).yx);}//swivel gallore.\nvec2 p1 (vec2 u){return           (pmod2(u));}\nvec2 p2 (vec2 u){return        gd0(pmod2(u));}\nvec2 p4 (vec2 u){return        p4S(pmod2(u));}\nvec2 p4g(vec2 u){return       p4gs(pmod2(u));}\nvec2 pmg(vec2 u){return       pmgs(pmod2(u)*2.)/2.;}//pmg is a special snowflake\nvec2 pgg(vec2 u){return       pggs(pmod2(u   )*2.);}\nvec2 pg (vec2 u){return        gh (pmod2(u));}\nvec2 p4m(vec2 u){return mh(md1(md0(pmod2(u))));}\n//skew() and unskew() kinda work on both types, but not too well.\n\n/*\nvoid all5Hexos(float t,inout vec2 u,inout vec2 m,float s){\n #ifdef skewIt\n ;u=mix(u,skew(u),s)\n ;m=mix(m,skew(m),s)\n #endif\n ;if(length(u+cs(t))<ViewZoom*.3 //central circle\n  ){u=  p3  (u)  \n   ;m=  p3  (m)  \n ;}else{                      //4 corners  \n   if(u.y-sin(u.x+t)*.5>0.\n   ){if(u.x-sin(u.y+t)*.5>0. //top right\n    ){u=  p6  (u)  \n     ;m=  p6  (m)\n    ;}else{                    //top left\n     ;u=  p3m1  (u)\n     ;m=  p3m1  (m)  \n     ;}  \n   ;}else{\n    ;if(u.x-sin(u.y+t)*.5>0.//bottom right\n    ){u=  p31m  (u)  \n     ;m=  p31m  (m)\n    ;}else{                   //bottom left\n     \n     ;u=  p6m  (u)  \n     ;m=  p6m  (m)  \n         ;}}} \n #ifdef skewIt\n ;u=mix(u,unskew(u),s)\n ;m=mix(m,unskew(m),s) \n #endif \n ;}\n*/\n\n//full friezeGroup: https://www.shadertoy.com/view/MdGfRc\nstruct v111{vec2 a;vec2 b;vec2 c;};//uvInner,id=outerTileID,parity=innerTileId\n//vec2 cy0(vec2 u){return vec2(u.x,clamp(u.y-1.,-.5,.5));}//explicit clamping is not worth it!\nv111 f2d(vec2 u){//u.y=clamp(u.y-1.,-.5,.5)\n    ;v111 r;r.a=vec2(fract(u.x),u.y+.5)\n           ;r.b=vec2(floor(u))\n           ;r.c=mod(r.b,2.);return r;}//tisx makes frieze NOT act like wallpaper\nv111 f2dB(vec2 u){//u.y=clamp(u.y-1.,-.5,.5)\n    ;v111 r;r.a=vec2(fract(u.x),fract(u.y))//but f2d() ffails for 2of7, so the original is still needed.\n           ;r.b=floor(u)\n           ;r.c=mod(r.b,2.);return r;}\n//Flip odd-numbered tiles.a by p;\nvec2 flip(vec2 t,vec2 p){return mix(t,1.-t,p);}//tile,parity\nv111 flip(v111 t,vec2 p){t.a=flip(t.a,p);return t;}//tile,parity\n//All 7 freezie-group patterns can be generated from the above rules\nv111 frezP1  (v111 t){return t;}//No additional symmetry\nv111 frezP11g(v111 t){return flip(t,t.c.xx*vec2(0,1));}//Flip   odd vertically to simulate a glide reflection.\nv111 frezP1m1(v111 t){return flip(t,t.c.xx*vec2(1,0));}//Mirror odd horizontally.\nv111 frezP2  (v111 t){return flip(t,t.c.xx);}//Flip   odd both horizontally min vertically\n//Subdivide the tile horizontally min rotate around the center.also flip horizontally.\nv111 frezP2mg(v111 t){v111 s=f2d(vec2(2,1)*flip(t.a,vec2(1,0)*t.c.xx));t=flip(t,vec2(1,0)*t.c.xx);t.a=flip(s.a,s.c.xx);return t;}\n//Subdivide the tile min flip vertically.\nv111 frezP11m(v111 t){v111 s=f2dB(vec2(2,2)*t.a);t.a=flip(s.a,vec2(0,1)*s.c.yy);return t;}//less hacky more stretched is;tile_2D(t.a,vec2(1,2))\n//Subdivide the tile min flip in both directions.\nv111 frezP2mm(v111 t){v111 s=f2dB(vec2(2,2)*t.a);t.a=flip(s.a,s.c);return t;}\nvec4 f1  (vec2 u){v111 a=f2d(u);a=frezP1  (a);return vec4(a.a,a.b);}\nvec4 f2  (vec2 u){v111 a=f2d(u);a=frezP2  (a);return vec4(a.a,a.b);}\nvec4 f2mg(vec2 u){v111 a=f2d(u);a=frezP2mg(a);return vec4(a.a,a.b);}\nvec4 f2mm(vec2 u){v111 a=f2d(u);a=frezP2mm(a);return vec4(a.a,a.b);}\nvec4 f11g(vec2 u){v111 a=f2d(u);a=frezP11g(a);return vec4(a.a,a.b);}\nvec4 f1m1(vec2 u){v111 a=f2d(u);a=frezP1m1(a);return vec4(a.a,a.b);}\nvec4 f11m(vec2 u){v111 a=f2d(u);a=frezP11m(a);return vec4(a.a,a.b);}\n\n//uniformed wallpaper and frieze\n//[u*   ]==uniform uv\n//[*f*  ]==frieze\n//[*p*  ]==wallpaper (should be *g*)\n//[ *NNN]==tile notation\nvec4 uf11m(vec2 u){return f11m(u)*.5-vec4(2)/8.;}//known to not be much of a frieze\nvec4 uf2mm(vec2 u){return f2mm(u)*.5-.25;}//known to not be much of a frieze\nvec4 uf2mg(vec2 u){return (f2mg(u)*v3(4,8,1,1)-v3(2,4,1,1))/8.;}\nvec4 uf2  (vec2 u){return f2  (u)   -.5;}\nvec4 uf1  (vec2 u){return f1  (u)   -.5;}\nvec4 uf11g(vec2 u){return f11g(u)   -.5;}\nvec4 uf1m1(vec2 u){return f1m1(u)   -.5;}\nvec4 up3m1(vec2 u){return vec4(p3m1(u)               ,0,1);}\nvec4 up31m(vec2 u){return vec4(p31m(u)   -v1( 1,0)/8.,0,1);}\nvec4 up3  (vec2 u){return vec4(p3  (u)   -v1( 2,0)/8.,0,1);}\nvec4 up6  (vec2 u){return vec4(p6  (u)   -v1(-1,0)/8.,0,1);}\nvec4 up6m (vec2 u){return vec4(p6m (u)   -v1( 2,6)/8.,0,1);}\nvec4 ucmm (vec2 u){return vec4(cmm (u)   -v1( 2,0)/8.,0,1);}\nvec4 ucm  (vec2 u){return vec4(cm  (u)   +v1(-2,2)/8.,0,1);}\nvec4 upm  (vec2 u){return vec4(pm  (u)   -v1( 0,2)/8.,0,1);}\nvec4 upmm (vec2 u){return vec4(pmm (u)   -      2./8.,0,1);}\nvec4 up1  (vec2 u){return vec4(p1  (u)               ,0,1);}\nvec4 up2  (vec2 u){return vec4(p2  (u)   +v1(-2,2)/8.,0,1);}\nvec4 up4  (vec2 u){return vec4(p4  (u)   -      2./8.,0,1);}\nvec4 up4g (vec2 u){return vec4(p4g (u)   -      1./8.,0,1);}\nvec4 upmg (vec2 u){return vec4(pmg (u)   -v1(-2,2)/8.,0,1);}\nvec4 upgg (vec2 u){return vec4(pgg (u)*.5-v1( 0,2)/8.,0,1);}\nvec4 upg  (vec2 u){return vec4(pg  (u)   -v1( 0,2)/8.,0,1);}\nvec4 up4m (vec2 u){return vec4(p4m (u)   -v1( 2,1)/8.,0,1);}\n\n/*\n//generalized \"rainbow\" by ollj\n//return y of f(u.x)which is a triangle wave,slanted sideways by u.x that is also sinusoidial continuity,but not for:0.!=u.y!=1.\n//looks best if u.y=clamp(m.x,0.,1.)-15./iResolution.y;,for a \"smoothstepSine()wihin 1/15 subpixel.\nfloat sawCos(vec2 u){u.x=fract(u.x);u+=(1.-2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0.,1.)*pi)*.5+.5;}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a,vec3 r){return sawCos(a,1.-15./r.y);}\n\nvec3 sawCos(vec3 a,vec3 b){a=fract(a);vec3 s=step(b,a);return u5(cos(sat(1.-(a-u2(a)*s)/(b-u2(b)*s))*pi));}//b range [0..1]\n//c=sawCos(vec3(u.x*10.),vec3(.25,.5,.75))\n\n/*\nvec3 rainbow(float a,float b){return abs(u2(fract(ab012(a,b))));}//tri rainbow with offsets\nvec3 rainbow2(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//cos rainbow with offsets\n//getting sawcos to generallygo from purple to purple is a challenge that i refuse for now.\nvec3 rainbow3(float a,float b){return (sawCos(ab012(a+.5,b),vec3(.75)));}//sawCos rainbow with offsets\n\n/*\n//good rainbow-gradients ALWAYS center green|white and border purple|black\n//m.x sets saturation==transition by shifting blue|red rang[-.1,.5]\n//m.y sets \"flimmer\",range [-.159 ...159]\n//p is a flimmer-phase that modulates the shorter subwave of red (green)blue;try;p=1.+vec3(-1,0,1)*cos(iGlobalTime*.001)\nvec3 rainbowN(float t,vec2 u,vec2 m,vec3 p,vec3 r\n){vec3 c=vec3(1)//;m=vec2(0)//simple case\n//;c=sawCos(vec3(u.x*10.),vec3(.25,.5,.75))\n ;m.x=c11(-m.x,.5)//good optional bounds,sign negation for utility.\n ;m.y=c11(m.y,.159)//decent optional bounds to stay in visible range\n ;m.y=m.y*pi+.5\n ;m.y=u5(m.y)\n ;c=rainbow3(u.x-m.x*.5,fract(m.x*.6))//the .mx/2 ensures that white/green stays centred and purple stys bordered;\n//;c=mix(c*m.y,c,cos(u.x*p*iResolution.x/4.))\n ;c=mix(c*m.y,c,sawCos(u.x*p*r.x/4.,vec3(.8)))\n ;vec2 v=u\n ;u.x*=m.y\n ;float g=cos(t)//;g=.1//a 3rd domain as time for demoing,whould actually be constant\n//;c=gradVis(c,u,v)//a graph plotter,not included here.\n ;return c;}\nvec3 rainbowN11(float t,vec2 u,vec3 r){return rainbowN(t,u,vec2(1),vec3(1),r);}\n*/\n\n/*\n//do 3x3 taps for a shape with kerning (it repeats AND overlaps skewing AND rotating tile borders)\n#define doNeighborhood\n\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define aa (min(iResolution.x,iResolution.y)/ViewZoom)\n\n\n//color of outlined shape (bound by tile borders)\n#define cOutlined vec3(0,0,0)\n\n//color of cursor\n#define cCursor vec3(u5(cos(iTime*2.)))\n\n\n\n\n\nfloat TinyDith(vec2 a){;if(fract(a.x*a.y)>.5)return 1.;return 0.;}\n\n\nvec4 greyBorderCoss(vec2 U,vec4 o){\n ;U=abs(U)\n ;return smoothstep(.5,-.5,min(U.x,U.y)-1.)*(vec4(.5,.5,.5,1.)-o)+o;}\n\nfloat neighborhood(vec4 o,float t,vec2 u,mat2 r,vec2 m,vec2 U,vec2 K\n#ifndef doNeighborhood\n){return 0.;}           \n#else\n){float d=0.\n ;for (float i=-1.;i<2.;i++){for (float j=-1.;j<2.;j++ //[kerning] 3x3 neighborhood\n ){vec2 a=u-m+vec2(i,j)\n  ;if(U.y<0.)a=mix(a,unskew(a),t)\n  ;a=r*a\n  ;d+=smoothstep(.01,-.01,ff(a*19.,K)-.3)\n  ;}};return d;;}\n#endif\n\n\nvec4 cursor(vec2 U,vec2 M,vec2 K,vec4 o,vec3 c\n){U=(U-M)/iResolution.xy\n ;U.y*=iResolution.y/iResolution.x\n ;U*=3.*iResolution.x/vec2(512.) //very hacky     \n ;o.xyz=mix(o.xyz\n           ,c\n           ,smoothstep(.1,-.1\n                       ,abs(ff(U*19.,K)-.6)-.3))\n ;return o;}\n\n\n\n\n\n//I know this is sloppy, all good prototypes are designed to learn from experimental failures:\n//parent shader was an older semi mess, but full of useful subroutines\nvec4 parent(vec4 o,vec2 u\n){float td=TinyDith(u)//basic dithering of 2 complemenraty,usually alternating complemenraty colors,avoids a mixing to grey.\n ;u     =u        -.5*iResolution.xy\n ;vec2 m=iMouse.xy-.5*iResolution.xy\n ;vec2 U=u\n ;vec2 M=m;\n ;mat2 r=mat2(1)\n ;if(u.x>0.)r=r2(iTime*.1)\n ;u*=r\n ;m*=r\n ;float t=cos(iTime+pi)*.5+.5\n ;o=vec4(1)\n ;u/=164.;m/=164.\n ;if(U.y<0.\n ){u=mix(u,skew(u),t)//t*skew(u)+(1.-t)*u\n  ;m=mix(m,skew(m),t);}\n ;vec2 a=u-fract(u+.5)//fract,with offset\n ;u=u-floor(u+.5)//floor,with offset\n ;m=m-floor(m+.5)//floor,with offset \n #ifdef MirrorTest\n ;if(td>.5){//additional symmetry is ghosted\n  ;if(u.x<.0)u.x=-u.x//works but is not super pretty (the mirror is skewed badly)\n  ;//if(u.x<u.y)u=-u//works but is not pretty (more issues)\n  ;//if(u.y<.0)u.y=-u.y//works but is is dumb and doesnt fo gell with a j-shape (more issues)\n ;}\n #endif\n ;vec2 k=(vec2(1,4)+u5(vec2(.5,2)*cs(iTime*8.+a.x*4.-a.y*sqrt(5.))))//wiggly j-shape proportions tile dependent\n ;vec2 K=(vec2(1,4)+u5(vec2(.5,2)*cs(iTime*8.                    )))//wiggly j-shape proportions\n //uniting both would require to calculate the above wiggle 9 times,witzhin the O(n*n)loop below,not doing that\n ;o.xyz=rainbowN11((a+a.yx)*vec2(phi,.5))//base tile color\n ;o.xyz-=smoothstep(.1,-.1,u.x-u.y)*u2(o.xyz)//changes diagonal half to complementary color.\n ;//if(u.x>u.y)o.xyz=1.-o.xyz//grey line over diagonal instead of complemenraty color on other half.     \n ;float                                 e=neighborhood(o,t,u,r,m,U,K)\n ;o.xyz=mix(o.xyz,vec3(u5(cos(U*.1)),1),e)\n ;if(U.y<0.)u=mix(u,unskew(u),t)//if(lower half of screen) unskew()\n ;//u=r*u //optional rotate of hollow repeated shape\n ;o.xyz=mix(o.xyz\n           ,cOutlined\n           ,smoothstep(.1,-.1\n                       ,abs(ff((u-r*vec2(0,0))*19.,k)-.361)-.1))\n ;o=greyBorderCoss(U,o)\n ;o=cursor(U,M,K,o,cCursor)\n ;return o;}\n\n\n/**/\n\n//lots of residual code:\n\n/*\n//i think gears are a VERY special thing, too complex for this SIMPLE patter ncollection\n//gears must be seperate collection because\n//- gears logically overlap, on a lattice this means: https://www.shadertoy.com/results?query=halfspace\n//- polar coordinates invite complex transdorms, including sphere inversion\n//- gears (due to polar complex numbers) quickly extend into 3d and 4d)\nfloat GearPattern(in vec2 uv     // coordinates\n                 ,in float wn    // vertical wheel count\n                 ,in int tn      // tooth count\n                 ,in float time) // rotation time\n{float g = (step(1.0, uv.x * wn) - 0.5) * time;\n  uv = fract(uv * wn) - 0.5;\n  float r = clamp(0.48, 0.4, 0.45 + 0.12*sin(atan(uv.x,uv.y) * float(tn) + g));\n  return smoothstep(r, r + 0.01, 1.1*length(uv));}\n/**/\n/*\nfloat CheckerSignMuFract(vec2 u){return sign(mu(.5-fract(u)));}\n*/\n\n/*\n//sat(sin()) or mu(sin()) is pretty lame/inconsistent for patterns\nfloat CheckerSatMuSin(vec2 u){return sat(88.*mu(sin(u*8.)));}//rounded white checkerboard\nfloat Checker1ByMuSin(vec2 u){return 1./mu(sin(u));}\nfloat TartanKaro(  vec2 u){return .5*ad(sat(10.*sin(u)));}\nfloat TartanSquare(vec2 u){return 4.*mu(sat(10.*sin(u)));}\n\nfloat SquareHolePattern(vec2 u\n){u.x=mu(sin(u*2.))\n ;return smoothstep(.1,.0, sq2(u.x)*2.5);}\n*/\n\n/*\nfloat Grid( vec2 u){\n ;//return ad(abs(fract(u)-.5))//initially was mu(), without -.5 offset, but thats just too trivial\n ;return mi(abs(fract(u)-.5))//, and BrickPattern() without shift\n ;}\nbool fuckme(vec2 a){float b=(1.-a.y)*.5// return hexagonal gridID pattern with 3 colors\n ;return a.y>1.&&(abs(b-a.x+a.y)>-b);}\nbool fuckus(vec2 p){ return 1.>ma(p-p.yx)&&max(-mi(p),ma(p)-2.)<0.;}\nfloat hexId3Hues(in vec2 p\n){p =toTri(p)\n ;p = mod(p,vec2(3))\n ;     if(fuckus(p))return .0\n ;else if(fuckme(p))return .5\n ;else              return 1.\n ;}\n*/\n\n/*\nfloat BrickPattern(vec2 p\n){//p*=vec2 (1,2)  // scale\n ;vec2 f=floor(p)\n ;p.x-=step(f.y,2.*floor(f.y*.5))*.5// brick shift\n ;p=abs (fract (p + 0.5) - 0.5)\n ;//p=smoothstep (0.03, 0.08, p)\n ;return min(p.x,p.y)\n ;}*/\n/*\nvec2 toTri(vec2 u){return vec2(u.x,(u.y*sqrt(3.)+u.x)*.5);}\n*/\n/*\nfloat TrianglePattern(vec2 u){return step(su(fract(toTri(u))),0.);}//non-homogeneous doesnt smoothstep()\n\n\nfloat RhombStar(vec2 u\n){u.x=sq2(su(fract(toTri(u))))\n ;return step(.25,u.x)//this is less silly\n ;//return smoothstep(.5,.0,u.x)//rather silly (optical illusion) //doesnt mix well with above line)\n ;}*/\n/*\nfloat hexBorder(vec2 u//subroutine of HexagonalGrid()\n){u.x*=sqrt(3.)*2./3.\n ;u.y+= 0.5 * mod(floor(u.x), 2.0)\n ;u = abs(fract(u)-.5)\n ;return abs(max(u.x*1.5+u.y,u.y*2.)-1.)\n ;}//return smoothstep(0., gridThickness,d);\n*/\n\n/*\nfloat hexTruchet(vec2 p//https://www.shadertoy.com/view/Xdt3D8 \n){float s=sqrt(3.)\n ;vec2 h=p+vec2(s,.45)*p.y/3.//hex skew\n ;vec2 f=fract(h);h=floor(h)//fractFloor\n ;float v=fract(ad(h)/3.)//+offsetFract\n ;h+=mix(vec2(step(.3,v)),step(f.yx,f),step(.6,v))//(v<.6)?(v<.3)?h:h++:h+=step(f.yx,f)\n ;p+=vec2(1,2.-sqrt(3.))*h.y*.5-h\n ;v=sign(cos(1234.*cos(h.x+9.*h.y)))//v is -1 or 1, appears a bit random\n ;vec3 a=vec3(dd(p-v*vec2(-2, 0)*.5)\n             ,dd(p-v*vec2( 1, s)*.5)\n             ,dd(p-v*vec2( 1,-s)*.5))\n ;v=(.5-sqrt(mi(a)))*v//all below lines are optional modifiers, each line can be commented out individually\n ;//v*=.5\n ;//v=v+.25 \n ;v=abs(v)\n ;v=1.-(1.-v*2.)\n ;float z=8.\n ;return smoothstep(aA(z),-aA(z),v-(cos(iTime)*(.5-aA(z))+.5))\n ;return v\n ;}*/\n\n\n//vec2 cs(vec2 u){return vec2(cos(u.x),sin(u.y));}\n/*\nfloat sinePattern(vec2 p){return sin(p.x*20.+cos(p.y*12.));}//trivial elegance, not normalized, but not noticable\nfloat SinePatternCrissCross(vec2 p){return .5+sinePattern(p)*sinePattern(p.yx);}\n*/\n\n/*\n//euclidean length has p=2, this allows for other p.\nfloat lengthP(in vec2 u, in float p){return pow(pow(abs(u.x),p)+pow(abs(u.y),p),1./p);}\n\n//cute small silly noneuclidean squared-circle, whos corners are dark.\nfloat QCirclePattern(vec2 u){return sin(lengthP(fract(u*4./2.)*2.-1.,4.)*16.);}\n\nfloat StarPattern(vec2 p//ttps://www.shadertoy.com/view/4sKXzy \n){p= abs(fract(p*1.5)-.5)//adorable stars, smoothstep() of it is nice, too.\n ;return max(ma(p),mi(p)*2.);}\n*/\n/*\nfloat weaveSub(vec2 u,float p){return step(.2,abs(fract(u.x)))*(.65+.35*sin(p*(u.y-ceil(u.x))));}\nfloat weave(vec2 u,float r//https://www.shadertoy.com/view/ltXcDn \n){float a=weaveSub(u,pi/r)//step(.2,abs(fract(u.x)))*(.65 +.35*sin(pi*.5*(u.y-ceil(u.x))))\n ;u=u.yx;u.y++ //flip//offset\n ;float b=weaveSub(u,pi/r) //step(.2,abs(fract(u.x)))*(.65 +.35*sin(pi*.5*(u.y-ceil(u.x))))\n ;return max (a,b);}\nfloat weave(vec2 u){return weave(u,1.);}\n\nfloat truchetTiny70s(vec2 p,float time// https://www.shadertoy.com/view/ls33DN by Shane\n){p.x*=sign(cos(length(ceil(p))*time))\n ;return cos(min(length(p=fract(p)),length(--p))*44.);}\n\n\nfloat xof(float a,float b){return float(int(a)^int(b));}//typecasting, not doing type float bitwise xor!\nfloat anf(float a,float b){return float(int(a)&int(b));}//typecasting, not doing type float bitwise and!\nfloat anf(int   a,float b){return float(int(a)&int(b));}//typecasting, not doing type float bitwise and!\n\n/*\n//https://www.shadertoy.com/view/XtcBWH\nfloat weaveInt(vec2 coord// https://www.shadertoy.com/view/XttBWn\n){ivec2 uv=ivec2(floor(coord*5.))//type float as much as possible by ollj, to lerp.\n ;float a=floor(mod(iTime,7.))*4.\n ;float bg  =.0//backdrop\n ;float warp=.5//horizontal\n ;float weft=1.//vertical      \n ;vec2 f=floor(vec2(uv.xy)*.5)\n ;a=anf(uv.x^uv.y,a)\n ;vec2 h=vec2(xof(float(uv.x),f.x),xof(float(uv.y),f.y))\n ;h=fract(h/2.)*2.\n ;vec3 i=smoothstep(1.,0.,vec3(a,h.xy))//if only these booleans where floats.\n ;float d=mix(weft,bg,i.z)\n ;float e=mix(warp,bg,i.y)\n ;float c=mix(d,e,i.x)//trilin mix\n ;//c=mix(1.,0.,i.x-(i.z+i.y)*.5)//many other options feasible...\n ;return c;}//https://en.wikipedia.org/wiki/Striation         ==ridged\n//likely needs a bokeh-ed soerpinsky: https://www.shadertoy.com/view/MlcfDB\n\nfloat demo(vec2 u){\n   ;return weaveInt(u)\n   ;// return smoothstep(-.1,.1,StarPattern(u)-cos(iTime)*.5-.5)\n        ;}\n/**/\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}