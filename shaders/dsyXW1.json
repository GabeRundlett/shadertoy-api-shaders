{
    "Shader": {
        "info": {
            "date": "1681027536",
            "description": "Livecoded in 60 minutes or so during h0ffman DJ set",
            "flags": 96,
            "hasliked": 0,
            "id": "dsyXW1",
            "likes": 7,
            "name": "Revision 2023 jam entry",
            "published": 3,
            "tags": [
                "revision",
                "jam",
                "livecode"
            ],
            "usePreview": 0,
            "username": "kostik1337",
            "viewed": 261
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat hash(float t) {return fract(sin(t) * 24535.365);}\nfloat hash(vec2 t) {return hash(dot(t, vec2(34.646,43.66442)));}\nfloat hash(vec3 t) {return hash(dot(t, vec3(34.646,43.66442, 12.544)));}\n\n#define INF (1e10)\n#define time iTime\n#define mr(t) (mat2(cos(t),sin(t),-sin(t),cos(t)))\n#define sat(t) (clamp(t, 0.,1.))\n\n#define BPM 130.\n#define beat (time * BPM/60.)\n\nfloat ffts(float t) {return texture(iChannel0, vec2(t, 0.)).r;}\nfloat ffti(float t) {return 0.;}\nvec4 prev(vec2 p) {return texture(iChannel1, p);}\n\nfloat box(vec3 p, vec3 s) {\n  p = abs(p)-s;\n  return max(p.x, max(p.y, p.z));\n}\n\nfloat beatstep(float b, float x) {return floor(b) + smoothstep(.0, .3, fract(b)); }\n\nfloat noise(float t) {\n  return mix(hash(floor(t)), hash(floor(t+1.)), smoothstep(0.,1.,fract(t)));\n}\n\nfloat boxs = .4;\n\nfloat map(vec3 p) {\n  //p.yz *= mr(1.5*beatstep(beat/8., .1));\n  p.xy *= mr(.2*sin(beat*.2));\n  p.xz *= mr(.2*sin(beat*.3));\n  p.yz *= mr(ffti(.1)*.3);\n  p.xz *= mr(ffti(.13)*.5);\n  \n  float off = .005;\n  vec3 s = vec3(boxs);\n  float m, i;\n  for(i=0.;i<3.;++i) {\n    s /= 2.;\n    vec3 sig = sign(p);\n    p = abs(p)-s-off;\n    float bb = beat/4.;\n    float thresh = fract(bb);\n    thresh = mix(1., .5, smoothstep(.0, .1, thresh) * (1.-smoothstep(.9, 1., thresh)));\n    if (hash(sig + floor(bb)) < thresh) break;\n  }\n  m = box(p, s - off*i);\n  return m;\n}\n\nvec3 pal(float t, float p) {\n  return vec3(pow(t, 5.)) + vec3(.2, .1, 1.) * pow(t, .5);\n}\n\n#define quant(x,t) (floor(x/t)*t)\n\nvec3 bg(vec2 p) {\n  vec3 c = vec3(0.);\n  p.y += noise(p.x/4.+.3*time);\n  p.y += noise(p.x/6.3+.1*time);\n  vec2 op=p;\n  float h = .05;\n  float ycid = floor(p.y/h);\n  p.y = fract(p.y/h);\n  float I=8.;\n  float hh = ffts(hash(ycid));\n  for (float i=0.; i<I;++i) {\n    vec2 p1 = p;\n    float xdiv = mix(1.4, 3., hash(ycid+i*.35));\n    p1.x -= mix(.3, 1., hash(ycid+i*.88)) * quant(beat, .25);\n    p1.x += hash(op.y)*.5;\n    p1.x = fract(p1.x / xdiv);\n    c += pal(p1.x, mix(5., 1., sat(5.*hh)));\n  }\n  c *= mix(1., 5., hh);\n  return c / I;\n}\n\nvec3 norm(vec3 p) {\n  vec2 E = vec2(.001, .0);\n  return normalize(vec3(\n    map(p+E.xyy),\n    map(p+E.yxy),\n    map(p+E.yyx)\n  )-map(p));\n}\n\nfloat raymarch(vec3 O, vec3 D, out float i, out bool hit) {\n  float d = 0.;\n  for (i=0.; i<64.; ++i) {\n    vec3 p = O+D*d;\n    float m = map(p);\n    d += m;\n    if(m < .001*d) {\n      hit = true;\n      return d;\n    }\n  }\n  hit = false;\n  return INF;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 O = vec3(0., 0., -2.), D = normalize(vec3(uv, 1.));\n  vec2 rot = vec2(0.);\n  rot.x += .2*sin(time)+.4*sin(.3*beatstep(beat/4., .2));\n  rot.y += .3*sin(time)+.4*sin(.2*beatstep(beat/4., .3));\n  O.xz *= mr(rot.x);\n  D.xz *= mr(rot.x);\n  O.yz *= mr(rot.y);\n  D.yz *= mr(rot.y);\n  \n  vec3 c = vec3(0.);\n  bool hit;\n  float i;\n  float d = raymarch(O, D, i, hit);\n  vec3 n;\n  if (hit) {\n    vec3 p = O+D*d;\n    n = norm(p);\n    vec3 D1 = reflect(D, n);\n    float d1;\n    if(D1.z > 0.) d1 = (1.-p.z)/D1.z;\n    else d1 = (-2.-p.z)/D1.z;\n    vec3 p1 = p+D1*d1;\n    \n    c += bg(p.xy) * exp(-d*1.1) * exp(-i/8.)*.6;\n    c += bg(p1.xy) * dot(D1, n) * exp(-d1*2.)*3.;\n  } else {\n    float d1 = (1.-O.z)/D.z;\n    vec3 p = O+D*d1;\n    float shad = raymarch(p, vec3(0.,0.,-1.), i, hit);\n    shad = step(20., shad);\n    c += bg(p.xy)*shad * exp(-d1/8.);\n  }\n\n  uv = fragCoord/iResolution.xy;\n  if (hit) {\n    vec4 pr = prev(uv + .03*n.xy);\n    c += pr.rgb * pow(abs(n.z), 2.) * .9;\n  }\n\tfragColor = vec4(c, (hit?1.:0.) * d);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 32970,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/paulosborn/i-find-it-hard-to-let-go-sometimes-neanderpaul-gnotek-idm"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}