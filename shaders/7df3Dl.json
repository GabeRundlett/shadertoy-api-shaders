{
    "Shader": {
        "info": {
            "date": "1616843988",
            "description": "As nice a bit of maths as you are likely to see today: drawing conic sections through three points and tangent to two lines (or through two points and tangent to three lines).",
            "flags": 0,
            "hasliked": 0,
            "id": "7df3Dl",
            "likes": 9,
            "name": "Conics through Five Elements",
            "published": 3,
            "tags": [
                "conic",
                "projective"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 402
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Conics through 3 points and 2 lines. mla, 2021\n//\n// A conic through three given points and tangent to two given lines,\n// must satisfy a quartic equation, and thus there are four solutions\n// (taking due account of multiple roots), though the points of tangency\n// may not be real. A lovely geometric solution is given by Heinrich\n// Dörrie in 100 Great Problems of Elementary Mathematics, making use\n// of Desargues' Involution Theorem (though Apollonius had a thing or\n// two to say about all this as well).\n//\n// https://archive.org/details/100GreatProblemsOfElementaryMathematicsDoverHeinrichDrrie/page/n281/\n//\n// The white conics pass through the three red points and are tangent to\n// the green lines, the blue conics are tangent to the three red lines\n// (dual to the red points) and pass through the green points (dual to\n// the green lines).\n//\n// In the default configuration (see code), one of the green lines is\n// the line at infinity, so cannot be seen and the white conics are all\n// parabolas, with the dual blue conics all appearing as ellipses (I'll\n// leave why that is so as a puzzle).\n//\n// The mouse sets the position of the green line. For some positions there is\n// no (real) solution for the conic - I'll leave the criteria for that as\n// another puzzle.\n//\n// A nice video from CodeParade on all this & more:\n// https://www.youtube.com/watch?v=X83vac2uTUs who has some nice code here\n// (this shader uses a similar solution but was developed independently):\n// https://github.com/HackerPoet/Conics\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\nint configuration = 2;\n\nfloat lwidth = 0.015;\nfloat pwidth = 0.05;\nconst float scale = 2.5;\n\nconst vec3 background = vec3(0);//vec3(1,1,0.5);\nconst vec3 pcolor0 = vec3(1,0,0);\nconst vec3 pcolor1 = vec3(0,1,0);\nconst vec3 pcolor2 = vec3(1,1,0);\nconst vec3 pcolor3 = vec3(0,1,1);\nconst vec3 lcolor0 = pcolor0;\nconst vec3 lcolor1 = pcolor1;\nconst vec3 lcolor2 = pcolor2;\nconst vec3 ccolor0 = 0.8*vec3(1,1,1);\nconst vec3 ccolor1 = vec3(0,0,1);\n\n// Represent a projective conic as a 3x3 matrix:\n//\n// M = (a,d,e,\n//      d,b,f,\n//      e,f,c)\n//\n// is: axx + byy + czz + 2(dxy + exz + fyz) = 0\n// calculated as pMp for p = (x,y,z).\n//\n// We can treat this as a distance field, scaled by the\n// (x,y) derivative in order to get correct line widths.\n\n// With this representation, the dual conic is just the inverse;\n// if the determinant is zero then there is no dual and the\n// conic is degenerate (what about adjugate?).\n\n// The triangle of reference (ToR subsequently) is the three\n// points with homogeneous coordinates (1,0,0),(0,1,0),(0,0,1)\n// The ToR is mapped to any three points p,q,r by the matrix\n// mat3(p,q,r) (with the usual glsl column major convention) and\n// so the inverse matrix maps p,q,r to the ToR, and we can solve\n// many problems more easily by first mapping selected points to\n// the ToR, solving a simpler problem, and mapping back at the end.\n//\n// A conic through the ToR is represent by a matrix with the form\n//\n// C = mat3(0,d,e,\n//          d,0,f,\n//          e,f,0)\n//\n// which represents the conic with equation:\n//\n// dxy + ezx + fyz = 0\n//\n// and this can be thought of as a constraint on d,e,f for it to\n// pass through the point (x,y,z)\n//\n// The inverse of C gives the line equation form of the conic,\n// ie. vec3(l,m,n)*inverse(C)*vec3(l,m,n) = 0 just when the line\n// (l,m,n) is tangent to the conic.\n//\n// For a conic through the ToR, the requirement that the conic is\n// tangent to a line (l,m,n) simplifies to:\n//\n// 4mnef = (me+nf-ld)²,\n//\n// a quadratic constraint, so there will be 0,1, or 2 ways it can\n// be satisfied in general. This constraint may be simplified if,\n// for example, the line passes through a vertex of the ToR, in which\n// case one of l,m,n are zero and the constraint becomes linear (if\n// two are zero, then the line is a side of the ToR and the problem\n// becomes even simpler).\n//\n// The most difficult situation is for three points and two general\n// lines (or dually, three lines and two points), with two quadratic\n// constraints, giving rise to a quartic equation.\n//\n// In this case, there is a simpler way to proceed using the\n// Desargues Involution Theorem, for details see Dörrie, but\n// briefly, the two tangent lines meet the conic at two points,\n// with the tangent chord between, and the sides of the ToR meet\n// the tangent chord at the fixpoints of a certain involution of\n// the line (an involution is a self-inverse projective\n// transformation, with t mapping to t' with tt' + b(t+t') + d = 0),\n// the involution on BC, for example, takes (0,1,0) to (0,0,1) and\n// (0,-n,m) to (0,-N,M) where (l,m,n) and (L,M,N) are the two lines.\n// In fact, for our involutions, b = 0 and d = mM/nN for BC\n// with the fixpoint being (0,1,sqrt(d)) (with no solution if d < 0)\n// and similarly on AC (it's easy to see there are either 3 real\n// fixpoints or 1, so we only need to calculate for two lines).\n\nmat3 pointconic(vec3 p, vec3 P) {\n  // Construct matrix for conic through vertices of ToR\n  // (so diagonal is zero) and through p and P\n  //float x = p[0], y = p[1], z = p[2];\n  //float X = P[0], Y = P[1], Z = P[2];\n  // Solve the homogeneous linear system\n  // dxy+exz+fyz = 0\n  // dXY+eXZ+fYZ = 0\n  // This is just the intersection of two lines, so:\n  vec3 l0 = p.xzy*p.yxz; //vec3(x*y,z*x,y*z);\n  vec3 l1 = P.xzy*P.yxz; //vec3(X*Y,Z*X,Y*Z);\n  vec3 def = cross(l0,l1);\n  float d = def[0], e = def[1], f = def[2];\n  return mat3(0,d,e,\n              d,0,f,\n              e,f,0);\n}\n\nbool lineconicparams(out vec2 res, vec3 a, vec3 A) {\n  float l = a[0], m = a[1], n = a[2];\n  float L = A[0], M = A[1], N = A[2];\n  float lL = l*L, mM = m*M, nN = n*N;\n  // sqrt(d) and sqrt(D) are fixpoints of the involutions\n  // as described above.\n  if (lL == 0.0 || mM == 0.0 || nN == 0.0) return false;\n  float d = mM/nN;\n  if (d < 0.0) return false;\n  float D = nN/lL;\n  if (D < 0.0) return false;\n  res = vec2(sqrt(d),sqrt(D));\n  return true;\n}\n\nmat3 cofactor(mat3 m) {\n  // Cofactor matrix of m, ie. the transpose of the adjugate\n  // (determinant is dot(m[0],cross(m[1],m[2])) and matrix\n  // multiplication is dot products of rows and columns)\n  return mat3(cross(m[1],m[2]),\n              cross(m[2],m[0]),\n              cross(m[0],m[1]));\n}\n\nvec3 join(vec3 p, vec3 q) {\n  // Return either intersection of lines p and q\n  // or line through points p and q, r = kp + jq\n  return cross(p,q);\n}\n\n// Screen coords to P2 coords\nvec3 map(vec2 p) {\n  return vec3(scale*(2.0*p - iResolution.xy) / iResolution.y, 1);\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(vec3 p) {\n  float t = iTime;\n  p.y -= 0.1;\n  p.xy = rotate(p.xy,0.2*t);\n  p.y += 0.1;\n  if (false) p.yz = rotate(p.yz,0.1618*t);\n  return p;\n}\n\nfloat dwidth;\n\nfloat pointdist(vec3 p, vec3 q) {\n  if (p.z == 0.0 || q.z == 0.0) return 1.0;\n  p /= p.z; q /= q.z; // Normalize\n  return smoothstep(0.75*pwidth,max(pwidth,0.75*pwidth+dwidth),distance(p,q));\n}\n\nfloat conicdist(vec3 p, mat3 m) {\n  float d = dot(p,m*p);\n  vec3 dd = 2.0*m*p;\n  d = abs(d/(p.z*length(dd.xy))); // Normalize for Euclidean distance\n  return smoothstep(0.5*lwidth,max(lwidth,0.5*lwidth+dwidth),d);\n}\n\nfloat linedist(vec3 p, vec3 l) {\n  float k = p.z*length(l.xy);\n  if (k == 0.0) return 1.0;\n  float d = abs(dot(p,l)/k);\n  return smoothstep(0.5*lwidth,max(lwidth,0.5*lwidth+dwidth),d);\n}\n\nvec3 cmix(vec3 color0, vec3 color1, float level) {\n  return mix(color0,color1,1.0-level);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 pos = map(fragCoord.xy);\n  dwidth = fwidth(pos.x/pos.z);\n\n  vec3 p0,p1,p2,l0,L0;\n  if (configuration == 0) {\n    p0 = vec3(1,0,0); p1 = vec3(0,1,0); p2 = vec3(0,0,1);\n    l0 = vec3(1,1,1); L0 = vec3(1.4,0.5,1);\n  } else if (configuration == 1) {\n    p0 = vec3(0,0,1); p1 = vec3(1,0,1); p2 = vec3(0,1,1);\n    l0 = vec3(1,1,1); L0 = vec3(1.5,0.5,1);\n  } else if (configuration == 2) {\n    p0 = vec3(0,1,1); p1 = vec3(0.866,-0.5,1); p2 = vec3(-0.866,-0.5,1);\n    l0 = vec3(0,0,1); L0 = vec3(-0.8,0,1);\n  } else {\n    p0 = vec3(1,0,1);  p1 = vec3(0,1,1); p2 = vec3(-1,0,1);\n    l0 = vec3(1,1,0); L0 = vec3(1.5,0.618,1);\n  }\n  p0 = transform(p0); p1 = transform(p1); p2 = transform(p2);\n  //l0 = transform(l0); L0 = transform(L0);\n  if (iMouse.x != 0.0) L0 = map(iMouse.xy);\n\n  vec3 p01 = join(p0,p1);\n  vec3 p02 = join(p0,p2);\n  vec3 p12 = join(p1,p2);\n\n  vec3 color = background;\n  \n  // The diagonal lines of the quadrangle\n  color = cmix(color,lcolor2,linedist(pos,p01));\n  color = cmix(color,lcolor2,linedist(pos,p02));\n  color = cmix(color,lcolor2,linedist(pos,p12));\n\n  // The tangent lines\n  color = cmix(color,lcolor1,linedist(pos,l0));\n  color = cmix(color,lcolor1,linedist(pos,L0));\n\n  // The lines of the ToR\n  color = cmix(color,lcolor0,linedist(pos,p0));\n  color = cmix(color,lcolor0,linedist(pos,p1));\n  color = cmix(color,lcolor0,linedist(pos,p2));\n\n  mat3 m = mat3(p0,p1,p2); // Map from ToR to (p0,p1,p2)\n  if (determinant(m) != 0.0) {\n    // m must be invertible\n    vec3 l1 = l0*m, L1 = L0*m; // Map the lines\n    m = inverse(m); // And invert for point mapping\n    vec2 t;\n    if (lineconicparams(t,l1,L1)) {  // Find involution fixpoints\n      for (int i = -1; i <= 1; i += 2) {\n        for (int j = -1; j <= 1; j += 2) {\n          // Each involution has two fixpoints ±t\n          // so there are 4 combinations possible\n          vec3 p = vec3(0,1,float(i)*t[0]);\n          vec3 P = vec3(float(j)*t[1],0,1);\n          vec3 l = cross(p,P);  // Line though p and P\n          vec3 q = cross(l,l1); // Intersect with tangents to give points on conic\n          vec3 Q = cross(l,L1);\n          mat3 c = pointconic(q,Q); // Find conic through ToR, q and Q\n          c = transpose(m)*c*m; // Conjugate with map to ToR\n          // And draw conic and dual\n          color = cmix(color,ccolor0,conicdist(pos,c));\n          // For the dual, just use the cofactor matrix\n          color = cmix(color,ccolor1,conicdist(pos,cofactor(c)));\n        }\n      }\n    }\n  }\n\n  color = cmix(color,pcolor2,pointdist(pos,p01));\n  color = cmix(color,pcolor2,pointdist(pos,p02));\n  color = cmix(color,pcolor2,pointdist(pos,p12));\n\n  color = cmix(color,pcolor1,pointdist(pos,l0));\n  color = cmix(color,pcolor1,pointdist(pos,L0));\n\n  color = cmix(color,pcolor0,pointdist(pos,p0));\n  color = cmix(color,pcolor0,pointdist(pos,p1));\n  color = cmix(color,pcolor0,pointdist(pos,p2));\n\n  fragColor = vec4(pow(color,vec3(0.4545)),1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}