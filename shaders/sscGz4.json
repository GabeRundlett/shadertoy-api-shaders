{
    "Shader": {
        "info": {
            "date": "1629223976",
            "description": "Source for Aberration Creations production - 4KB intro \"Exodus\", published at MAGFest Demoparty 2019. 3rd place in combined demo competition.\n\nCode: Angelo\nMusic: Argasek\n\nWatch the full production here: www.youtube.com/watch?v=HJA1xIevGl0",
            "flags": 0,
            "hasliked": 0,
            "id": "sscGz4",
            "likes": 8,
            "name": "exodus",
            "published": 3,
            "tags": [
                "intro",
                "source"
            ],
            "usePreview": 0,
            "username": "unjello",
            "viewed": 304
        },
        "renderpass": [
            {
                "code": "/// Exodus / Aberration Creations, a 4k intro\n/// 3rd place @ MAGFest 2019\n/// License: CC0\n///\n/// Effects inspired by:\n/// Octahedral Voxel Tracing / fizzer: https://www.shadertoy.com/view/4lcfDB\n/// Swirly Strands / Plento: https://www.shadertoy.com/view/MtKfWy\n/// InFX.1 / patu: https://www.shadertoy.com/view/llSSRm\n///\n/// Soundtrack: https://soundcloud.com/argasek/exodus-video\n/// Video: www.youtube.com/watch?v=HJA1xIevGl0\n///\n\n\nfloat MIN_DIST = 0.0;\nfloat MAX_DIST = 120.0;\nfloat EPSILON = 0.0001;\nvec3 K_a = vec3(1.);\nvec3 K_d = vec3(.6);\nvec3 K_s = vec3(0.5, 1.0, 0.5);\nvec3 lp = vec3(0.0, 1.0, -0.5);\nvec3 zero3 = vec3(0.);\n\nint MAX_STEPS = 80;\nint MODE_CROSS_CENTER = 1;\nint MODE_CROSS_JUMPING = 2;\nint MODE_METABALLS_CENTER = 3;\nint MODE_SWIRLS_CENTER = 5;\nint MODE_SWIRLS_SIDE = 6;\n\n// random took from\n// https://thebookofshaders.com/11/\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return 0.4*(mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y);\n}\n\nfloat sdfSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdfCubeCheap(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    return max(d.x, max(d.y, d.z));\n}\n\nfloat sdfOpUnion(float a, float b) {\n\treturn min(a,b);\n}\n\nvec3 sdfOpMod(vec3 p, vec3 size) {\n    vec3 halfsize = size * 0.5;\n    p = mod(p + halfsize, size) - halfsize;\n    return p;\n}\n\nvec3 opTwist( vec3 p, float r ) {\n    float  c = cos(r * p.y + r);\n    float  s = sin(r * p.y + r);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat opBlob(float d1, float d2, float d3, float d4, float d5, float d6) {\n    float k = 2.0;\n\treturn -log(exp(-k*d1)+exp(-k*d2)+exp(-k*d3)+exp(-k*d4)+exp(-k*d5)+exp(-k*d6))/k;\n}\n\n\n// https://www1.udel.edu/biology/rosewc/kaap427627/notes/matrices_rotations.pdf\nmat3 fullRotate(vec3 theta) {\n    float sx=sin(theta.x);\n    float cx=cos(theta.x);\n    float sy=sin(theta.y);\n    float cy=cos(theta.y);\n    float sz=sin(theta.z);\n    float cz=cos(theta.z);\n    return mat3(\n        vec3(cy*cz, -cy*sz, sy),\n        vec3(sx*sy*cz+cx*sz, -sx*sy*sz+cx*cz, -sx*cy),\n        vec3(-cx*sy*cz+sx*sz, cx*sy*sz+sx*cz, cx*cy)\n        );\n}\n\nfloat sdf_metaballs(vec3 p) {\n    float t = iTime / 4.;\n\tfloat p1 = sdfSphere(0.5*(p + vec3(cos(t*0.5),sin(t*0.3),cos(t))), 1.+0.5*cos(t*6.0));\n    float p2 = sdfSphere(2.0*(p + 3.0 * vec3(cos(t*1.1),cos(t*1.3),cos(t*1.7))), 3.+2.*sin(t))/2.0;\n    float p3 = sdfSphere(2.0*(p + 5.0 * vec3(cos(t*0.7),cos(t*1.9),cos(t*2.3))), 3.)/2.0;\n    float p4 = sdfSphere(2.0*(p + 3.0 * vec3(cos(t*0.3),cos(t*2.9),sin(t*1.1))), 3.+2.*sin(t))/2.0;\n    float p5 = sdfSphere(2.0*(p + 6.0 * vec3(sin(t*1.3),sin(t*1.7),sin(t*0.7))), 3.0+1.5*cos(t))/2.0;\n    float p6 = sdfSphere(2.0*(p + 3.0 * vec3(sin(t*2.3),sin(t*1.9),sin(t*2.9))), 3.0)/2.0;\n    return opBlob(p1, p2, p3, p4, p5, p6);\n}\n\nfloat sdf_swirls(vec3 p, int mode) {\n   p -= vec3(1.0, -0.25, 4.0);   \n   p *= fullRotate(vec3(\n       0.0,\n       0.0, \n       mode == MODE_SWIRLS_CENTER ? p.z*0.06+0.2*sin(iTime) : p.z*.06+iTime*0.25\n   ));\n   p.y += sin(p.z + iTime + p.x*1.0)*0.2;\n   p.x += cos(p.y - p.z * 2.0 + iTime)*0.3;\n   p = sdfOpMod(p, vec3(1.5, 1.5, 0.5+0.3*sin(iTime)));\n   \n   return sdfCubeCheap(p, vec3(0.033, 0.033, 2.0));\n}\n\nfloat sdfCross(vec3 p, float w ) {\n  float da = sdfCubeCheap(p.xyz,vec3(20., w, w));\n  float db = sdfCubeCheap(p.yzx,vec3(w, 20., w));\n  float dc = sdfCubeCheap(p.zxy,vec3(w, w , 20.));\n  return sdfOpUnion(sdfOpUnion(sdfOpUnion(db,dc), da), da);\n} \n\nfloat sdf_cross(vec3 p) {\n    float t = iTime / 4.;\n    float w = 1.7 - length(p) / 10.;\n   p = opTwist(p, 0.1*sin(iTime*0.02))*fullRotate(vec3(iTime*0.01, 0.0, iTime*0.02));\n   p *= fullRotate(vec3(sin(iTime*0.1), 0.0, cos(iTime*0.02)));\n   float res = sdfOpUnion(\n       \t\t\t\tsdfCross(p, w),\n       \t\t\t\tsdfCross(p * fullRotate(vec3(3.14/4.0, 0.0, 3.14/4.0)), w));\n   res = sdfOpUnion(res, sdfCross(p * fullRotate(vec3(3.14, 3.14/4.0, 3.14)), w));\n   return res;\n}\n\n\nvec2 render_raymarch(vec3 eye, vec3 dir, int mode) {\n    float dist = MIN_DIST;\n    float glow = 0.0;\n    float minDist = MAX_DIST;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 v = eye + dist * dir;\n        float step = 0.0;\n        if (mode == MODE_METABALLS_CENTER) {\n            step = sdf_metaballs(v);\n        }\n        if (mode == MODE_CROSS_CENTER || mode == MODE_CROSS_JUMPING) {\n        \tstep = sdf_cross(v);\n        }\n        if (mode == MODE_SWIRLS_CENTER || mode == MODE_SWIRLS_SIDE) {\n\t\t\tstep = sdf_swirls(v, mode);\n        }\n        \n        if (abs(step) < EPSILON) {\n        \treturn vec2(dist, glow);\n        }\n\n        dist += step;\n                \n        minDist = min(minDist, step * 4.);\n        glow = pow( 1. / minDist, 0.4);  \n\n        if (dist >= MAX_DIST) {\n            return vec2(dist, glow);\n        }\n    }\n\treturn vec2(dist, glow);\n}\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n// http://learnwebgl.brown37.net/09_lights/lights_attenuation.html\nvec3 getSunLightColor(vec3 eye, vec3 dir, vec3 p, vec3 lp) {\n    vec3 sun_pos = eye;\n\tvec3 L = sun_pos - p;\n    float d = max(length(L), EPSILON);\n    float atten = 1.0 / (1.0 + d*0.2 + d*d*0.1); \n    vec3 c = (K_a + K_d + K_s)*atten;\n\treturn c;\n}\n\nvec3 getFoggyColor(vec3 eye, float d, vec3 dir, vec3 lightPosition) {\n\t    vec3 p = eye + d * dir;\n        vec3 c = getSunLightColor(eye, dir, p, lightPosition);\n        \n        float fog = smoothstep(0.0, 0.68, d*0.005);\n        return mix(c, zero3, fog);\n}   \n\nvec4 effect_swirls(vec2 fragCoord, int mode) {\n        vec2 uv = vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n        vec3 eye = vec3(mode == MODE_SWIRLS_CENTER ? 0.0 : 0.0, 0.0, (mode == MODE_SWIRLS_CENTER ? -17.0 : 2.0)*iTime); \n    \tvec3 viewDir = rayDirection(mode == MODE_SWIRLS_CENTER ? 45.0 : 25.0, iResolution.xy, mode == MODE_SWIRLS_CENTER ? fragCoord : fragCoord.yx);//normalize(vec3(uv,2.0));\n\n        float d = render_raymarch(eye, viewDir, mode).x;\n\n        if (d >= MAX_DIST) {\n            return vec4(0.0);\n        } else {\n            return vec4(getFoggyColor(eye, d, viewDir, lp), 1.0);\n        }\n}\n\nvec4 effect_raymarch(vec2 fragCoord, int mode) {\n    float k = (iTime+150.)/ 2.0;\n    vec3 eye = vec3(\n        mode == MODE_METABALLS_CENTER ? 30. : sin(k) * 40.,\n        1. , \n        mode == MODE_METABALLS_CENTER ? -5.+sin(k) :cos(k) * -20.);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\tvec3 tt = vec3(10.,\n                   mode == MODE_CROSS_CENTER ? 0. : 20.\n                   , 0.);\n\n    if (mode == MODE_METABALLS_CENTER) {\n        tt.x/=2.;\n        tt.y = 2.5+sin(k);\n    }\n  \t\n    vec2 uv = fragCoord.xy / iResolution.xy - 1.0;\n    vec3 cc = vec3(1.0);\n    if (mode == MODE_CROSS_CENTER) {\n        uv.y += noise(uv)*sin(k*noise(uv*cos(k)));\n\t    uv.x -= sin(k*noise(uv*sin(k)));\n        float n = (ceil(uv.x * uv.y));\n\n        if (abs(n) < EPSILON) {\n        tt.y += 2.0 * sin(iTime);\n        cc = vec3(0.65);\n        }\n    } else {\n        float n, n2, n3;\n        float div = mode == MODE_CROSS_JUMPING ? 1. : -1.;\n        n = (ceil(uv.x*2.5 + div*uv.y*2.5 + div*2.0 - div*sin(k+noise(uv))));\n        n2 = (ceil(uv.x*2.5 + div*uv.y*2.5 +  2.0*sin(k)));\n        n3 = (ceil(uv.x*2.5 + div*uv.y*2.5 + div*2.0 - div*sin(k)*cos(k)));\n\t\t\n        vec3 cc = vec3(1.0);\n  \n        if (abs(n) < EPSILON) {\n            tt.y += 2.0 * sin(iTime);\n        }\n        if (abs(n2) < EPSILON) {\n            tt.y += 3.0 * cos(iTime);\n        }\n        if (abs(n3) < EPSILON) {\n            tt.y += 4.0 * cos(iTime);\n        }\n        cc = vec3(0.65);\n    }\n    \n    \n    vec3 up = vec3(0.2, 0.2, -1.);\n    if (mode == MODE_CROSS_JUMPING) {\n        up.z = -50.*cos(k);\n    } else if (mode == MODE_CROSS_CENTER) {\n        up.y = sin(k*5.);\n        up.z = cos(k*5.);\n    }\n    \n    mat4 viewToWorld = viewMatrix(eye, tt, up);\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    vec2 dd = render_raymarch(eye, worldDir, mode);\n    float d = dd.x;\n    float glow = dd.y;\n\n    vec3 c = zero3;\n    if (d >= MAX_DIST) {\n        float g = glow*glow;\n        c += K_s*glow*0.2 + K_d*g;\n    } else {\n        c = getFoggyColor(eye, d, worldDir, mode == 4 ? vec3(0.0, -10., -15.) : lp);\n    }\n    return vec4(c*cc, 1.0);\n}\n\n\nvec4 intro(vec2 fragCoord) {\n    if (iTime <= 4.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 9.6) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 16.1) {\n\t\treturn effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 19.1) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 25.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 28.7) {\n        return effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 33.7) {\n\t\treturn effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 38.3) {\n        return effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 43.1) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 47.9) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 57.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 76.8) {\n        return  effect_raymarch(fragCoord, MODE_CROSS_CENTER);\n    } else {\n        return  effect_swirls(fragCoord, MODE_SWIRLS_CENTER);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy)/ iResolution.xy;\n    fragColor = intro(fragCoord);\n    // Vignette\n    fragColor.rgb *= 1. - (pow(abs(uv.x), 5.) + pow(abs(uv.y), 5.)) * .4;    \n    // Tonemapping\n    fragColor.rgb /= (fragColor.rgb + vec3(.5)) * .7;\n    // Gamma\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n\n    if (iTime > 94.0) {\n        fragColor /= (-93.9+iTime)*6.;\n    }\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}