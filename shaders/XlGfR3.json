{
    "Shader": {
        "info": {
            "date": "1543289431",
            "description": "To see the change, replay the shader from 0s\nI don't know what the texelFetch exactly do...\ncan somebody explain it to me plz... : )\nSee the magic sun there? I think this texelFetch somehow cause it.....",
            "flags": 32,
            "hasliked": 0,
            "id": "XlGfR3",
            "likes": 6,
            "name": "Sunrise doesn't last all morning",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "EricClapton",
            "viewed": 763
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    fragColor = vec4(sqrt(data.rgb/data.w),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 randState;\n\n#define DIFFUSE 1\n#define METAL 2\n#define GLASS 3\n\nstruct Material{\n    int type;\n    vec3 albedo;\n    float fuzz;\n    float index;\n};\n    \nstruct hitRec{\n    vec3 p;\n    vec3 n;\n    float t;\n    Material mat;\n};\n    \nstruct Ray{\n    vec3 origin;\n    vec3 dir;\n};\n    \nstruct sphere{\n    vec3 center;\n    float R;\n    Material mat;\n};\n    \nfloat rand2D()\n{\n    randState.x = fract(sin(dot(randState.xy + iTime, vec2(12.9898, 78.233))) * 43758.5453);\n    randState.y = fract(sin(dot(randState.xy + iTime, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    return randState.x;\n}\n\nvec3 random_in_unit_sphere()\n{\n    float phi = 2.0 * 3.14159265359 * rand2D();\n    float cosTheta = 2.0 * rand2D() - 1.0;\n    float u = rand2D();\n\n    float theta = acos(cosTheta);\n    float r = pow(u, 1.0 / 3.0);\n\n    float x = r * sin(theta) * cos(phi);\n    float y = r * sin(theta) * sin(phi);\n    float z = r * cos(theta);\n\n    return vec3(x, y, z);\n}\n\nsphere SP[5];\n\nfloat schlick(float cosine, float ref_idx) {\n    float r0 = (1.0 - ref_idx) / (1.0 + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);\n}\n\nbool scatter(inout Ray ray, hitRec rec){\n    if(rec.mat.type == DIFFUSE){\n        ray.origin = rec.p;\n        ray.dir = normalize(rec.n + random_in_unit_sphere());\n        return true;\n    }\n    else if(rec.mat.type == METAL){\n        Ray xray;\n        xray.origin = rec.p;\n        xray.dir = reflect(ray.dir, rec.n) + rec.mat.fuzz * random_in_unit_sphere();\n        ray = xray;\n        return (dot(ray.dir, rec.n) > 0.0);\n    }\n    else if(rec.mat.type == GLASS){\n        vec3 outward_normal;\n        vec3 reflected = reflect(ray.dir, rec.n);\n        float ni_over_nt;\n        float idx = rec.mat.index;\n        float cosine;\n        float reflected_prob;\n\n        if (dot(ray.dir, rec.n) > 0.0) {\n            outward_normal = - rec.n;\n            ni_over_nt = rec.mat.index;\n            cosine = idx * dot(normalize(ray.dir), rec.n);\n        } \n        else {\n            outward_normal = rec.n;\n            ni_over_nt = 1.0 / rec.mat.index;\n            cosine = -idx * dot(normalize(ray.dir), rec.n);\n        }\n        vec3 refracted = refract(normalize(ray.dir), outward_normal, ni_over_nt);\n        //canRefract(ray.dir, outward_normal, ni_over_nt)\n        if(refracted.x != 0.0 && refracted.y != 0.0 && refracted.z != 0.0){\n            reflected_prob = schlick(cosine, idx);\n        }\n        else{\n            reflected_prob = 1.0;\n        }\n        if(rand2D() < reflected_prob)\n            ray = Ray(rec.p, reflected);\n        else\n            ray = Ray(rec.p, refracted);\n        return true;\n    }\n    return false;\n}\n\nbool hit_sphere(float t_min, float t_max, sphere sph, Ray ray, out hitRec rec){\n    \n    vec3 ac = ray.origin - sph.center;\n    float b = 2.0 * dot(ray.dir, ac);\n    float a = dot(ray.dir, ray.dir);\n    float c = dot(ac, ac) - pow(sph.R, 2.0);\n    float det = b*b - 4.0*a*c;\n    \n    bool isHit = false;\n    \n    if(det > 0.0){\n        \n        float temp = (-b - sqrt(det)) / (2.0 * a);\n        if (temp > t_min && temp < t_max) {\n            isHit = true;\n            rec.t = temp;\n            rec.p = ray.origin + temp * ray.dir;\n            rec.n = normalize(rec.p - sph.center);\n            rec.mat = sph.mat;\n            return isHit;\n        }\n\n        temp = (-b + sqrt(det)) / (2.0 * a);\n        if (temp > t_min && temp < t_max) {\n            isHit = true;\n            rec.t = temp;\n            rec.p = ray.origin + temp * ray.dir;\n            rec.n = normalize(rec.p - sph.center);\n            rec.mat = sph.mat;\n            return isHit;\n        }\n             \n}\n    return isHit;\n      \n}\n\nbool insectWorld(float t_min, float t_max, Ray ray, out hitRec rec){\n    bool isHit = false;\n\n    for (int i = 0; i < SP.length(); i++) {\n        bool isCurrHit = false;\n        hitRec currRec;\n        isCurrHit = hit_sphere(t_min, t_max, SP[i], ray, currRec);\n        if (isCurrHit) {\n            isHit = true;\n            t_max = currRec.t;\n            rec = currRec;\n        }\n    }\n\n    return isHit;\n}\n\nvec3 color(Ray ray, float t_min, float t_max, vec2 uv){\n    \n    const int Maxcount = 20;\n    int count = 0;\n    hitRec rec;\n    bool isHit = insectWorld(t_min, t_max, ray, rec);\n    \n    vec3 scale = vec3(1.0, 1.0, 1.0);\n    \n    \n    bool isScatter;\n    \n    while(count < Maxcount && isHit){\n        count++;\n        isScatter = scatter(ray, rec);\n        \n        if (!isScatter) return vec3(0.0, 0.0, 0.0);\n        \n        scale *= rec.mat.albedo;\n        \n        isHit = insectWorld(t_min, t_max, ray, rec);\n    }\n    \n    float t = (normalize(ray.dir).y + 1.0) * 0.5;\n    \n\n        return scale * ( (1.0-t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0)) * pow(0.8, float(count));\n    //return ( (0.8 -t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0)) * pow(0.5, float(count-1));\n    \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0);\\\n        \n    if (ivec2(fragCoord) == ivec2(0)) {\n        fragColor = iResolution.xyxy;\n        return;\n    }  \n    //randState = fragCoord.xy / iResolution.xy;\n\n\n    Ray newRay;\n    newRay.origin = vec3(0.5*iResolution.x/iResolution.y, 0.5, 1.0);\n    newRay.dir = vec3(uv, 0.0) - newRay.origin;\n    \n    /*SP[0].center = vec3(1.4, 0.25, -0.2);\n    SP[0].R = 0.2;\n    SP[0].mat.type = DIFFUSE;\n    SP[0].mat.albedo = vec3(0.5, 0.8, 0.8);\n    SP[1].center = vec3(1.0, -2.2, -0.0);\n    SP[1].R = 2.3;\n    SP[1].mat.type = DIFFUSE;\n    SP[1].mat.albedo = 0.6 * vec3(0.8, 0.8, 0.0);\n    SP[2].center = vec3(0.5, 0.25, -0.2);\n    SP[2].R = 0.2;\n    SP[2].mat.type = METAL;\n    SP[2].mat.fuzz = 0.0;\n    SP[2].mat.albedo = vec3(0.9);\n    SP[3].center = vec3(0.95, 0.3, -0.2);\n    SP[3].R = 0.2;\n    SP[3].mat.type = GLASS;\n    SP[3].mat.index = 1.5;\n    SP[3].mat.albedo = vec3(0.9);*/\n    SP[0].center = vec3(1.4, 0.25, -0.2);\n    SP[0].R = 0.2;\n    SP[0].mat.type = GLASS;\n    SP[0].mat.albedo = vec3(0.9);\n    SP[0].mat.index = 1.0;\n    SP[1].center = vec3(1.0, -2.2, -0.0);\n    SP[1].R = 2.3;\n    SP[1].mat.type = DIFFUSE;\n    SP[1].mat.albedo = 0.6 * vec3(0.8, 0.8, 0.0);\n    SP[2].center = vec3(0.5, 0.25, -0.2);\n    SP[2].R = 0.2;\n    SP[2].mat.type = METAL;\n    SP[2].mat.fuzz = 0.0;\n    SP[2].mat.albedo = vec3(0.9);\n    SP[3].center = vec3(0.95, 0.3, -0.2);\n    SP[3].R = 0.2;\n    SP[3].mat.type = DIFFUSE;\n    SP[3].mat.index = 1.0;\n    SP[3].mat.albedo = vec3(0.5, 0.8, 0.8);\n    SP[4].center = vec3(3.2, -2.0+0.2*sin(iTime), -4.3);\n    SP[4].R = 2.0;\n    SP[4].mat.type = GLASS;\n    SP[4].mat.albedo = vec3(1.0, 0.2706, 0.5*cos(iTime));\n    SP[4].mat.index = 1.5;\n    \n    vec3 col = color(newRay, 0.01, 100.0, uv);\n    //col = sqrt(col);\n    if (texelFetch(iChannel0, ivec2(0),0).xy == iResolution.xy) {        \n        fragColor = vec4(col,1) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n    } else {        \n        fragColor = vec4(col,1);\n    }\n    \n    //fragColor = vec4(col,1.0);    \n    //fragColor = vec4(0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}