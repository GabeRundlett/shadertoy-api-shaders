{
    "Shader": {
        "info": {
            "date": "1673384845",
            "description": "drag mouse for camera rotation\n\nmusic: der Schamane - \"The Cube\" \nsubstance reference: 2C-B",
            "flags": 64,
            "hasliked": 0,
            "id": "mls3zj",
            "likes": 7,
            "name": "The Root of Reality",
            "published": 3,
            "tags": [
                "3d",
                "tunnel",
                "transparent"
            ],
            "usePreview": 0,
            "username": "derSchamane",
            "viewed": 342
        },
        "renderpass": [
            {
                "code": "//                  = The Root of Reality =         \n//               by Maximilian Knape ·∑>| 2023            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n#define MAX_STEPS 500\n#define MAX_DIST 350.\n#define MIN_DIST 20.\n#define STEP_FAC 1.1\n\n#define SURF_DIST .03\n#define SURF_MUL 500.\n#define SURF_EXP 12.\n\n#define PP_CONT 1.4\n#define PP_VIGN 2.0\n\n#define iTime iTime*1.3\n#define PI 3.14159265358979\n#define TAU 6.28318530717958\n#define S(x,y,t) smoothstep(x,y,t)\n\nfloat smin( float a, float b, float k ) //iq\n{\n    float h = max(k-abs(a-b),0.);\n    return min(a, b) - h*h*.25/k;\n}\n\nvec2 Map(vec3 p) \n{    \n    float d = MAX_DIST, col = 0.85;\n    vec3 pos = p;\n\n    if (length(p - 100. + vec3(pow(sin(iTime*3./4.5), 3.)*20.)) < 50.)\n        for(float i = 0.; i < 5.; i++)\n        {\n            float t = (iTime + 2.*pow(sin(iTime/23.),3.))*3. - i*.8;\n            p = pos - 100. + vec3(pow(sin(t/4.5), 3.)*20. + i);\n            float s = length(p + sin(t / vec3(4.1,6.3,2.2)) * vec3(11,19,8));\n            s -= (4. / (i*i*.1 + 1.)); \n            d = smin(s *.6, d, 3. - i*.5);\n        }\n    \n    pos = pos + vec3(iTime*10. + pow(sin(iTime/15.), 3.));\n    p = pos / 12.;\n    \n    float n1 = length(dot(sin(p/2.5), cos(p*1.8))) + .2 + 1./(iTime/2.+.01);\n    col = mix(col, 1.0, step(n1, d));\n    d = min(n1, d);\n    \n    p =  pos / 72. + pow(sin(iTime/124.), 3.)*10.;\n    float n2 = length(dot(sin(p/14.5), cos(p))) - (.3 + sin(iTime/13.)*.1);\n    col = mix(col, 2.0, step(n2, d));\n    d = min(n1, d);\n   \n    \n    return vec2(d, col);\n}\n\nvec3 Palette(int index)\n{\n    switch (index)\n    {\n        case 0: return vec3(1., 1., 1.);\n        case 1: return vec3(.85, .15, .3);\n        case 2: return vec3(.3, .65, 1.);\n        case 3: return vec3(1., .8, .3);\n    }\n    return vec3(0.);\n}\n\nvec3 RTM(vec3 ro, vec3 rd) \n{\n    int steps;\n    float sum = 0.;\n\tfloat s = 1.;\n    float d = MIN_DIST;\n    const float a = 1. / float(MAX_STEPS); \n    vec3 p = vec3(0), col = vec3(1);\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {    \n        float sd = (SURF_DIST * (pow(d/MAX_DIST, SURF_EXP)*SURF_MUL + 1.));\n        if (s < sd || d > MAX_DIST) break;\n        \n        steps = i;\n        p = ro + rd*d;\n        \n        vec2 map = Map(p);\n        col = mix(col, Palette(int(floor(map.y))), .02 * (1.-sum));\n        \n        s = max(abs(map.x), 2. * sd);\n        d += s * STEP_FAC * (1.1 - fract(map.y));\n        \n        sum += a;\n    }\n    \n    col *= sum - pow(1. - (length(ro - p) / MAX_DIST), SURF_EXP);\n    \n    return col;\n}\n\nmat2 Rot(in float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 R(in vec2 uv, in vec3 p, in vec3 l, in float z)\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec4 PP(vec3 col, vec2 uv)\n{\n    col = mix(col, S(vec3(0.), vec3(1.), col), PP_CONT);    \n    col *= S(PP_VIGN,-PP_VIGN/5., dot(uv,uv)); \n    col = pow(col, vec3(.9)); //vec3(.4545)\n    \n    return vec4(col, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5 * iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n    if (length(m) <= 0.) m = vec2(.5);\n\n    vec3 ro = vec3(-1);\n    ro.yz *= Rot(-PI/2. + PI*.5);\n    ro.xz *= Rot(-m.x * PI*2. - PI);\n    vec3 rd = R(uv, ro, vec3(0), .8);\n    \n    vec3 col = RTM(ro, rd);\n    \n    float dr = dot(rd, vec3(.57735));\n    col += pow(max(dr, 0.), 100.+sin(iTime*.9)*20.)*Palette(3)*.65;\n    col *= pow(dr*.5+.5, .5+sin(iTime/5.)*.2)*S(0., 1., iTime);\n    col -= S(1.-1e-3, 1., dr)*.2*sin(iTime/5.);\n    col += S(1.-5e-5, 1., dr)*.3;\n    \n    col += .2 * S(0., 10., iTime) * ((S(-1., 1., dr) - S(0.99, 1., dr)) *\n           S(0.3, 3., length(sin(10.*normalize(vec2(-abs(rd.z-rd.x), abs(rd.y-rd.x)) * Rot(iTime/31.))))));  \n\n    fragColor = PP(col, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 31961,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/derschamane/der-wurfel"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}