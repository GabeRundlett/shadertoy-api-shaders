{
    "Shader": {
        "info": {
            "date": "1675075441",
            "description": "A mashup of [url=https://www.shadertoy.com/view/WsBfWt]Crystal Tetrahedron[/url] and [url=https://www.shadertoy.com/view/WlKyzW]Buckyball Fracture[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "mllXRj",
            "likes": 18,
            "name": "Fork Fork Fract manivel 419",
            "published": 3,
            "tags": [
                "refraction",
                "explode",
                "dispersion",
                "bluenoise",
                "polyhedra"
            ],
            "usePreview": 1,
            "username": "manivel",
            "viewed": 464
        },
        "renderpass": [
            {
                "code": "/*\n\n    Fractured Orb\n    -------------\n\n    A mashup of 'Crystal Tetrahedron' https://www.shadertoy.com/view/WsBfWt\n    and 'Buckyball Fracture' https://www.shadertoy.com/view/WlKyzW\n\n*/\n\n\n// http://tuxedolabs.blogspot.com/2018/05/bokeh-depth-of-field-in-single-pass.html\n\nvec2 uPixelSize; //The size of a pixel: vec2(1.0/width, 1.0/height)\nfloat uFar = 1.; // Far plane\n\nconst float GOLDEN_ANGLE = 2.39996323;\nconst float MAX_BLUR_SIZE = 10.;\nconst float RAD_SCALE = 1.; // Smaller = nicer blur, larger = faster\n\nfloat getBlurSize(float depth, float focusPoint, float focusScale) {\n    float coc = clamp((1.0 / focusPoint - 1.0 / depth)*focusScale, -1.0, 1.0);\n    return abs(coc) * MAX_BLUR_SIZE;\n}\n\nvec3 depthOfField(vec2 texCoord, float focusPoint, float focusScale) {\n    vec4 centerTex = texture(iChannel0, texCoord);\n    float centerDepth = centerTex.a * uFar;\n    float centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\n    vec3 color = centerTex.rgb;\n    \n    #ifdef DISABLE_DOF\n    \treturn color;\n    #endif\n\n    float tot = 1.0;\n\n    float radius = RAD_SCALE;\n    for (float ang = 0.; ang < 10000.; ang += GOLDEN_ANGLE) {\n        if (radius >= MAX_BLUR_SIZE) break;\n\n        vec2 tc = texCoord + vec2(cos(ang), sin(ang)) * uPixelSize * radius;\n        vec4 sampleTex = texture(iChannel0, tc);\n        vec3 sampleColor = sampleTex.rgb;\n        float sampleDepth = sampleTex.a * uFar;\n        float sampleSize = getBlurSize(sampleDepth, focusPoint, focusScale);\n        //if (sampleSize < centerSize) break;\n        if (sampleDepth > centerDepth) {\n            sampleSize = clamp(sampleSize, 0.0, centerSize*2.0);\n        }\n        float m = smoothstep(radius-0.5, radius+0.5, sampleSize);\n        color += mix(color/tot, sampleColor, m);\n        tot += 1.0;\n        radius += RAD_SCALE/radius;\n        \n        // modification: exit early when we're in focus\n       // if (centerDepth < uFar / 3. && m == 0.) break;\n    }\n    return color /= tot;\n}\n\n\n// http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 tonemap2(vec3 texColor) {\n    texColor /= 2.;\n   \ttexColor *= 16.;  // Hardcoded Exposure Adjustment\n   \tvec3 x = max(vec3(0),texColor-0.004);\n   \treturn (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uPixelSize = vec2(.002) / (iResolution.xy / iResolution.y);\n\n    //fragColor = vec4(texture(iChannel0, uv).rgb, 1); return;\n\n    vec3 col = depthOfField(uv, .65, 1.);\n\n    col = pow(col, vec3(1.25)) * 2.5;\n    col = tonemap2(col);\n\n    fragColor = vec4(col, 1);    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//#define WOBBLE\n\n//#define DARK_MODE\n\n\n#if HW_PERFORMANCE==1\n    const float MAX_DISPERSE = 5.;\n    const float MAX_BOUNCE = 10.;\n#else\n    const float MAX_DISPERSE = 3.;\n    const float MAX_BOUNCE = 4.;\n#endif\n\n\n#define PI 3.14159265359\n#define PHI 1.618033988749895\n\n\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n#define saturate(x) clamp(x, 0., 1.)\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smax(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Rotate on axis\n// blackle https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat range(float vmin, float vmax, float value) {\n  return clamp((value - vmin) / (vmax - vmin), 0., 1.);\n}\n\nmat3 rotX(float a) {\n\treturn mat3(1, 0, 0, 0, cos(a), -sin(a), 0, sin(a), cos(a));\n}\n\nmat3 rotY(float a) {\n\treturn mat3(cos(a), 0, sin(a), 0, 1, 0, -sin(a), 0, cos(a));\n}\n\nmat3 rotZ(float a) {\n\treturn mat3(cos(a), -sin(a), 0, sin(a), cos(a), 0, 0, 0, 1);\n}\n\n// Spectrum palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n// https://iquilezles.org/articles/functions\nfloat expImpulse( float x, float k )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\n\n//========================================================\n// Modelling\n//========================================================\n\nfloat boolSign(float v) {\n    return max(0., sign(v)) * 2. - 1.;\n}\n\nvec3 boolSign(vec3 v) {\n    return max(vec3(0), sign(v)) * 2. - 1.;\n}\n\n// Closest icosahedron vertex\n#if 0\nvec3 icosahedronVertex(vec3 p) {\n    vec3 ap, v, v2, v3;\n    ap = abs(p);\n    v = vec3(PHI, 1, 0);\n    v2 = v.yzx;\n    v3 = v2.yzx;\n    if (distance(ap, v2) < distance(ap, v)) v = v2;\n    if (distance(ap, v3) < distance(ap, v)) v = v3;\n    return normalize(v) * boolSign(p);\n}\n#else\n// with removed roots from iq\nvec3 icosahedronVertex(vec3 p) {\n    vec3 ap = abs(p);\n    vec3                           v = vec3(PHI,1,0);\n    if (ap.x+ap.z*PHI > dot(ap,v)) v = vec3(1,0,PHI);\n    if (ap.z+ap.y*PHI > dot(ap,v)) v = vec3(0,PHI,1);\n    return v*0.52573111*boolSign(p);\n}\n#endif\n\n// Closest dodecahedron vertex\n#if 0\nvec3 dodecahedronVertex(vec3 p) {\n    vec3 ap, v, v2, v3, v4;\n    ap = abs(p);\n    v = vec3(PHI);\n\tv2 = vec3(0, 1, PHI + 1.);\n\tv3 = v2.yzx;\n    v4 = v3.yzx;\n    if (distance(ap, v2) < distance(ap, v)) v = v2;\n    if (distance(ap, v3) < distance(ap, v)) v = v3;\n    if (distance(ap, v4) < distance(ap, v)) v = v4;\n    return normalize(v) * boolSign(p);\n}\n#else\n// with removed roots from iq\nvec3 dodecahedronVertex(vec3 p) {\n    vec3 ap = abs(p);\n    vec3 v = vec3(PHI);\n    vec3 v2 = vec3(0, 1, PHI + 1.);\n    vec3 v3 = v2.yzx;\n    vec3 v4 = v2.zxy;\n    if (dot(ap,v2) > dot(ap,v)) v = v2;\n    if (dot(ap,v3) > dot(ap,v)) v = v3;\n    if (dot(ap,v4) > dot(ap,v)) v = v4;\n    return v*0.35682209*boolSign(p);\n}\n#endif\n\n\nfloat OUTER = .35;\nfloat INNER = .24;\n\nfloat object(vec3 p) {\n    float d = length(p) - OUTER;\n    d = max(d, -d - (OUTER - INNER));\n    return d;\n}\n\nfloat animT;\nfloat time;\n\nvec2 map(vec3 p) {\n\n    float scale = 2.5;\n    p /= scale;\n\n    float outerBound = length(p) - OUTER;\n\n    #ifdef WOBBLE\n        float bound = outerBound - .05;\n        bound *= scale;\n        if (bound > .002) {\n            return vec2(bound, 0.);\n        }\n    #endif\n\n    #ifdef WOBBLE\n        float spin = time * (PI*2.) * (1./5.);\n        mat3 trs = rotX(atan(1./PHI)) * rotY(-spin);\n        p = trs * p;\n    #else\n        float spin = time * (PI/2.) - .15;\n        pR(p.xz, spin);\n    #endif\n\n\n\n    // Buckyball faces\n    // ---------------\n\n    // Four closest vertices of a spherical pentakis dodecahedron\n    // or, four closest faces of a buckyball\n    \n    vec3 va = icosahedronVertex(p);\n    vec3 vb = dodecahedronVertex(p);\n\n    // Second closest dodecahedron vertex\n    float side = boolSign(dot(p, cross(va, vb)));\n    float r = PI * 2. / 5. * side;\n    vec3 vc = erot(vb, va, r);\n\n    // Third closest dodecahedron vertex\n    vec3 vd = erot(vb, va, -r);\n    \n    \n    \n    float d = 1e12;\n    vec3 pp = p;\n    \n    // Render the nearest four fragments to get\n    // a clean distance estimation\n\n    for (int i = 0; i < 4; i++) {\n\n        // Offset space\n        #ifdef WOBBLE\n            vec3 dir = normalize(vec3(1,1,0));\n            dir = dir * transpose(trs);\n            float sp = 2.;\n            float t = mod((time - dot(va, dir) / (.5 * sp)), 1.);\n            float anim = sin(t * PI * 1. * sp) * .5 + .5;\n            anim = mix(.0, .05, anim);\n            p -= va * anim;\n        #else\n            float t = mod(time * 2./3. + .25 - dot(va.xy, vec2(1,-1)) / 30., 1.);\n            float t2 = clamp(t * 5. - 1.7, 0., 1.);\n            float explode = 1. - pow(1. - t2, 10.); // expand\n            explode *= 1. - pow(t2, 5.); // contract\n            explode += (smoothstep(.32, .34, t) - smoothstep(.34, .5, t)) * .05;\n            explode *= 1.4;\n            t2 = max(t - .53, 0.) * 1.2;\n            float wobble = sin(expImpulse(t2, 20.) * 2.2 + pow(3. * t2, 1.5) * 2. * PI * 2. - PI) * smoothstep(.4, .0, t2) * .2;\n            float anim = wobble + explode;\n            p -= va * anim / 2.8;\n        #endif       \n\n        // Build boundary edge of face\n        float edgeA = dot(p, normalize(vb - va));\n        float edgeB = dot(p, normalize(vc - va));\n        float edgeC = dot(p, normalize(vd - va));\n        float edge = max(max(edgeA, edgeB), edgeC);\n        #ifndef WOBBLE\n            edge -= .005;\n        #endif\n        \n        // Intersect with object\n        d = min(d, smax(object(p), edge, .002));\n        \n        // Reset space for next iteration\n        p = pp;\n        \n        // Cycle faces for next iteration\n        vec3 va2 = va;\n        va = vb;\n        vb = vc;\n        vc = vd;\n        vd = va2;\n    }\n    \n    #ifndef WOBBLE\n        // Slow down ray as we approach non-exploded object\n        float bound = outerBound - .002;\n        if (bound * scale > .002) {\n            d = min(d, bound);\n        }\n    #endif\n    \n    return vec2(d * scale, 1.);\n}\n\n\n//========================================================\n// Lighting\n//========================================================\n\nvec3 BGCOL = vec3(.9,.83,1);\n\nfloat intersectPlane(vec3 rOrigin, vec3 rayDir, vec3 origin, vec3 normal, vec3 up, out vec2 uv) {\n    float d = dot(normal, (origin - rOrigin)) / dot(rayDir, normal);\n  \tvec3 point = rOrigin + d * rayDir;\n\tvec3 tangent = cross(normal, up);\n\tvec3 bitangent = cross(normal, tangent);\n    point -= origin;\n    uv = vec2(dot(tangent, point), dot(bitangent, point));\n    return max(sign(d), 0.);\n}\n\nmat3 envOrientation;\n\nvec3 light(vec3 origin, vec3 rayDir) {\n    origin = -origin;\n    rayDir = -rayDir;\n\n    origin *= envOrientation;\n    rayDir *= envOrientation;\n\n    vec2 uv;\n    vec3 pos = vec3(-6);\n    float hit = intersectPlane(origin, rayDir, pos, normalize(pos), normalize(vec3(-1,1,0)), uv);\n    float l = smoothstep(.75, .0, fBox(uv, vec2(.5,2)) - 1.);\n    l *= smoothstep(6., 0., length(uv));\n\treturn vec3(l) * hit;\n}\n\nvec3 env(vec3 origin, vec3 rayDir) {    \n    origin = -(vec4(origin, 1)).xyz;\n    rayDir = -(vec4(rayDir, 0)).xyz;\n\n    origin *= envOrientation;\n    rayDir *= envOrientation;\n\n    float l = smoothstep(.0, 1.7, dot(rayDir, vec3(.5,-.3,1))) * .4;\n   \treturn vec3(l) * BGCOL;\n}\n\n\n\n//========================================================\n// Marching\n//========================================================\n\n#define ZERO (min(iFrame,0))\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal( in vec3 pos )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e).x;\n    }\n    return normalize(n);\n}\n\nstruct Hit {\n    vec2 res;\n    vec3 p;\n    float len;\n    float steps;\n};\n\nHit march(vec3 origin, vec3 rayDir, float invert, float maxDist, float understep) {\n    vec3 p;\n    float len = 0.;\n    float dist = 0.;\n    vec2 res = vec2(0.);\n    vec2 candidate = vec2(0.);\n    float steps = 0.;\n\n    for (float i = 0.; i < 300.; i++) {\n        len += dist * understep;\n        p = origin + len * rayDir;\n        candidate = map(p);\n        dist = candidate.x * invert;\n        steps += 1.;\n        res = candidate;\n        if (dist < .001) {\n            break;\n        }\n        if (len >= maxDist) {\n            len = maxDist;\n            res.y = 0.;\n            break;\n        }\n    }   \n\n    return Hit(res, p, len, steps);\n}\n\nmat3 sphericalMatrix(vec2 tp) {\n    float theta = tp.x;\n    float phi = tp.y;\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float duration = 10./3.;\n    #ifdef WOBBLE\n        duration = 2.;\n    #endif\n    time = mod(iTime / duration, 1.);\n    \n    #ifndef DARK_MODE\n        envOrientation = sphericalMatrix(((vec2(81.5, 119) / vec2(187)) * 2. - 1.) * 2.);\n    #else\n        envOrientation = sphericalMatrix((vec2(0.7299465240641712,0.3048128342245989) * 2. - 1.) * 2.);\n    #endif\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    Hit hit, firstHit;\n    vec2 res;\n    vec3 p, rayDir, origin, sam, ref, raf, nor, camOrigin, camDir;\n    float invert, ior, offset, extinctionDist, maxDist, firstLen, bounceCount, wavelength;\n    \n    vec3 col = vec3(0);\n    float focal = 3.8;\n    bool refracted;\n\n    vec3 bgCol = BGCOL * .22;\n\n    invert = 1.;\n    maxDist = 15.; \n    \n\tcamOrigin = vec3(0,0,9.5);\n   \tcamDir = normalize(vec3(uv * .168, -1.));\n\n\n    firstHit = march(camOrigin, camDir, invert, maxDist, .8);\n    firstLen = firstHit.len;\n\n    float steps = 0.;\n    \n    for (float disperse = 0.; disperse < MAX_DISPERSE; disperse++) {\n        invert = 1.;\n    \tsam = vec3(0);\n\n        origin = camOrigin;\n        rayDir = camDir;\n\n        extinctionDist = 0.;\n        wavelength = disperse / MAX_DISPERSE;\n\t\tfloat rand = texture(iChannel0, (fragCoord + floor(iTime * 60.) * 10.) / iChannelResolution[0].xy).r;\n        wavelength += (rand * 2. - 1.) * (.5 / MAX_DISPERSE);\n        \n\t\tbounceCount = 0.;\n\n        for (float bounce = 0.; bounce < MAX_BOUNCE; bounce++) {\n\n            if (bounce == 0.) {\n                hit = firstHit;\n            } else {\n                hit = march(origin, rayDir, invert, maxDist / 2., 1.);\n            }\n            \n            steps += hit.steps;\n            \n            res = hit.res;\n            p = hit.p;\n            \n            if (invert < 0.) {\n\t            extinctionDist += hit.len;\n            }\n\n            // hit background\n            if ( res.y == 0.) {\n                break;\n            }\n\n            vec3 nor = normal(p) * invert;            \n            ref = reflect(rayDir, nor);\n            \n            // shade\n            sam += light(p, ref) * .5;\n            sam += pow(max(1. - abs(dot(rayDir, nor)), 0.), 5.) * .1;\n            sam *= vec3(.85,.85,.98);\n\n            // refract\n            float ior = mix(1.2, 1.8, wavelength);\n            ior = invert < 0. ? ior : 1. / ior;\n            raf = refract(rayDir, nor, ior);\n            bool tif = raf == vec3(0); // total internal reflection\n            rayDir = tif ? ref : raf;\n            offset = .01 / abs(dot(rayDir, nor));\n            origin = p + offset * rayDir;\n            //invert = tif ? invert : invert * -1.;\n            invert *= -1.; // not correct but gives more interesting results\n\n            bounceCount = bounce;\n        }\n\n        #ifndef DARK_MODE\n            sam += bounceCount == 0. ? bgCol : env(p, rayDir);\t\n        #endif\n\n        if (bounceCount == 0.) {\n            // didn't bounce, so don't bother calculating dispersion\n            col += sam * MAX_DISPERSE / 2.;\n            break;\n        } else {\n            vec3 extinction = vec3(.5,.5,.5) * .0;\n            extinction = 1. / (1. + (extinction * extinctionDist));\t\n            col += sam * extinction * spectrum(-wavelength+.25);\n        }\n\t}\n    \n    // debug\n \t//fragColor = vec4(spectrum(steps / 2000.), 1); return;\n    //fragColor = vec4(vec3(bounceCount / MAX_BOUNCE), 1); return;\n    //fragColor = vec4(vec3(firstHit.steps / 100.), 1); return;\n\n    col /= MAX_DISPERSE;\n        \n    fragColor = vec4(col, range(4., 12., firstLen));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}