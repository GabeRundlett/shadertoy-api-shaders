{
    "Shader": {
        "info": {
            "date": "1538580534",
            "description": "Linear(Nonlinear) programming",
            "flags": 0,
            "hasliked": 0,
            "id": "Mt3fz8",
            "likes": 2,
            "name": "Linear(Nonlinear) programming",
            "published": 3,
            "tags": [
                "linear",
                "programming",
                "nonlinear"
            ],
            "usePreview": 0,
            "username": "hk_shao",
            "viewed": 500
        },
        "renderpass": [
            {
                "code": "#define LINE_SIZE 2.0\n#define GRID_LINE_SIZE 1.0\n#define GRID_AXIS_SIZE 3.0\n#define GRID_LINES 1.0\n#define GRAD_OFFS vec2(0.0001 * ZOOM, 0.0)\n#define GRAD(f, p) (vec2(f(p) - f(p + GRAD_OFFS.xy), f(p) - f(p + GRAD_OFFS.yx)) / GRAD_OFFS.xx)\n#define PLOT(f, c, d, p) d = mix(c(d, p), d, smoothstep(0.0, (LINE_SIZE / iResolution.y * ZOOM), abs(f(p) / length(GRAD(f,p)))))\n\n#define PI (atan(1.0) * 4.0)\n#define ZOOM 10.0\n\nfloat Func(vec2 p)\n{\n\treturn float(!(\n\t\t(p.y > 1.0) &&\n\t\t(p.y - p.x * p.x > 0.0) &&\n\t\t(p.y < 5.0)\n\t));\n}\n\nfloat Target(vec2 p)\n{\n\treturn p.x * p.x * p.x + p.y * p.y;\n}\n\nvec3 Color(vec3 d, vec2 p)\n{\n\treturn d * 0.8 * (clamp(10.0 - abs(tan(iTime)) * Target(p), 0.0, 1.0)) + vec3(1, 0, 1);\n}\n\n// table properties\nconst int columns = 5;\nconst int rows = 6;\nconst int tableCol = 6;\nconst int[] table = int[](\n14, 17, 25, 21, 19, 14, // 0\n14,  4,  4,  4, 12,  4, // 1\n31,  8,  4,  2, 17, 14, // 2\n14, 17,  1,  6,  1, 31, // 3\n 2, 31, 18, 10,  6,  2, // 4\n14, 17,  1, 30, 16, 31, // 5\n14, 17, 17, 30, 16, 14, // 6\n 4,  4,  4,  2,  1, 31, // 7\n14, 17, 17, 14, 17, 14, // 8\n14,  1, 15, 17, 17, 14, // 9\n12, 12,  0,  0,  0,  0, // .\n 0,  0, 31,  0,  0,  0, // -\n 4,  4, 31,  4,  4,  0);// +\n\nvec2 uvmap(vec2 uv){\n    return (2.*uv-iResolution.xy)/iResolution.y;\n}\n\n//print(uv, center, width, height, index)\nfloat print(vec2 uv, vec2 c, float w, float h, int ind)\n{\n    float r = 0.;\n    vec2 wh = vec2(w/float(columns),h/float(rows));\n    vec2 o =  vec2(w,h)/2.; // origin\n    vec2 bmin=c-o, bmax=c+o; // min and max boundaries\n    \n    // no need to render ouside boundaries.\n    if(uv.x<bmin.x||uv.y<bmin.y|| \n       uv.x>bmax.x||uv.y>bmax.y) return 0.;\n    \n    c = bmin; // move center to the origin\n    for(int row=0;row<rows;row++){\n        int map = table[ind*tableCol+row];\n        for(int col=0;col<columns;col++){\n            vec2 p0 = c+wh*vec2(col,row), p1 = p0+wh;\n            vec2 lb = step(p0,uv);\n            vec2 ub = 1.-step(p1,uv);\n            \n            int shift = columns-col-1;\n            if(((map&(1<<shift))>>shift)==1) \n                r += lb.x*lb.y*ub.x*ub.y;\n        }\n    }\n    return r;\n}\n\nfloat printNumber(vec2 uv, vec2 c, float w, float h, float num, int decN, float spacing, bool center)\n{\n    w*=iResolution.y/iResolution.x; // keep aspect ratio\n    spacing*=iResolution.y/iResolution.x;\n    \n    float r = 0.;\n    bool neg = num<0.; num=abs(num);\n    float cd = float(decN);\n    float cn = max(ceil(log(num)/log(10.)),1.);\n    float dec = fract(num)*pow(10., 6.0);\n    \n    if(center) // move to origin\n    {\n        c.x += (cn+cd-1.)*(w+spacing)/2.;\n        if(decN>0) c.x+=spacing;\n        if(neg)c.x+=(w+spacing)/2.;\n    }\n    else\n    {\n        c.x += (cn+cd-1.)*(w+spacing)+w;        \n        if(decN>0) c.x+=spacing*2.;\n        if(neg)c.x+=w+spacing;\n    }\n        \n    // print fractions\n    for(int i=0;i<decN;i++,dec/=10.){\n        int val = int(mod(dec,10.));\n        r += print(uv, c, w, h, val);\n        c.x-=w+spacing; // move left\n    }\n    if(decN>0) // print dot separator\n    {\n        c.x+=spacing;\n        r += print(uv, c, w, h, 10);\n        c.x-=w;\n    }\n    // print whole part\n    for(int i=0;i<int(cn);i++,num/=10.){\n        int val = int(mod(num,10.));\n        r += print(uv, c, w, h, val);\n        c.x-=w+spacing; // move left\n    }\n    if(neg) r+=print(uv, c, w, h, 11); // print sign\n    return r;\n}\n\nfloat grid(vec2 p)\n{\n\tvec2 uv = mod(p,1.0 / GRID_LINES);\n\n\tfloat halfScale = 1.0 / GRID_LINES / 2.0;\n\n\tfloat gridRad = (GRID_LINE_SIZE / iResolution.y) * ZOOM;\n\tfloat grid = halfScale - max(abs(uv.x - halfScale), abs(uv.y - halfScale));\n\tgrid = smoothstep(0.0, gridRad, grid);\n\n\tfloat axisRad = (GRID_AXIS_SIZE / iResolution.y) * ZOOM;\n\tfloat axis = min(abs(p.x), abs(p.y));\n\taxis = smoothstep(axisRad - 0.05, axisRad, axis);\n\n\treturn min(grid, axis);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = ((gl_FragCoord.xy - iMouse.xy) / iResolution.y) * ZOOM;\n\n\tvec3 col = vec3(grid(uv) * 0.45 + 0.55);\n\n\t\tPLOT(Func, Color, col, uv);\n    \n    vec2 xx = fragCoord.xy / iResolution.y +\n\t\tvec2((iResolution.y - iResolution.x) /\n\t\t\t(2.0 * iResolution.y), 0.0);\n\n\tif (any(lessThan(abs(xx - 0.5), vec2(0.002))) &&\n\t\t((distance(vec2(0.5), xx) < 0.02))) {\n\t\t\tcol *= 0.4;\n\t}\n    \n    float px = ((iResolution.x / 2.0 - iMouse.x) / iResolution.y) * ZOOM;\n    col -= printNumber(uvmap(fragCoord.xy), vec2(-0.5, -0.90), 0.1, 0.1, px, 6, 0.1, true);\n    float py = ((iResolution.y / 2.0 - iMouse.y) / iResolution.y) * ZOOM;\n    col -= printNumber(uvmap(fragCoord.xy), vec2(0.5, -0.90), 0.1, 0.1, py, 6, 0.1, true);\n    \n\tfragColor = vec4(col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}