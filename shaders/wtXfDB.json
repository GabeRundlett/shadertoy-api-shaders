{
    "Shader": {
        "info": {
            "date": "1599766782",
            "description": "Parses & displays the data file from the \"ST-NICCC 2000\" Atari-ST demo by Oxygene.\nCheats using a custom texture to load the 640kB data file, see the code comments for details on how to load it.\n",
            "flags": 32,
            "hasliked": 0,
            "id": "wtXfDB",
            "likes": 9,
            "name": "GLSL-NICCC 2000",
            "published": 3,
            "tags": [
                "demo",
                "polygon",
                "ngon",
                "niccc"
            ],
            "usePreview": 0,
            "username": "Flyguy",
            "viewed": 699
        },
        "renderpass": [
            {
                "code": "/*\n\nParses & displays the data file from the \"ST-NICCC 2000\" Atari-ST demo by Oxygene.\nThe data is packed into an RGBA texture to load it into the shader but is otherwise unmodified.\n\nDetails on the data file format:\nhttp://arsantica-online.com/st-niccc-competition/\n\nOriginal ST demo:\nhttps://www.youtube.com/watch?v=nqVJWFNpTqA\nhttp://www.pouet.net/prod.php?which=1251\n\nTo load the data file, do the following:\n1) Copy the following:\n\ngShaderToy.SetTexture(1, {\nmSrc:'https://media.discordapp.net/attachments/744639380035076208/744639443398426644/scene1.png', \nmType:'texture', mID:1,\nmSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }\n});\n\n2) Go to the \"Buffer A\" tab.\n3) Open the developer console in your browser. (Ctrl+Shift+J Chrome, Ctrl+Shift+K Firefox)\n4) Paste what your copied and hit Enter.\n5) Reset the shader.\n\n*/\n\n/*\nDebug bar graphs\nColumn 0 -> Palette\nColumn 1 -> Vertex count (mark every 20 vertices)\nColumn 2 -> Polygon count (mark every 10 vertices)\nColumn 3 -> Average # of vertices per polygon (mark every 1 vertex, min 3/max 15) \n*/\n#define DEBUG 0\n#define WIREFRAME 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord - vec2((iResolution.x - (4.0*iResolution.y/3.0))/2.0,0);\n    pos /= (iResolution.y*vec2(4.0/3.0,1));\n    \n    //Get frame state (vertex count & polygon count).\n    vec4 state = texelFetch(iChannel0, idx2uv(STATE_PTR, DECODE_RES.x),0);\n    int vert_count = int(state.z);\n    int poly_count = int(state.a);\n\n    int poly_vert_ptr = VERTEX_PTR;\n    vec3 col = vec3(0,0,0);\n\tfloat d = 1e6;\n    \n    for(int i = 0;i < poly_count;i++)\n    {\n        //Get first vertex, color, and # of vertices.\n        vec4 vtx0 = texelFetch(iChannel0, idx2uv(poly_vert_ptr, DECODE_RES.x), 0);\n        vec3 poly_col = STtoRGB(int(vtx0.z));\n        int poly_vert_count = int(vtx0.w);\n\t\t\n        //Even-Odd / Raycasting N-gon filler\n        int n = 0; //Number of intersections\n        vec2 p0 = vtx0.xy; //First vertex of edge\n        for(int j = 1;j <= poly_vert_count;j++)\n        {\n            //Second vertex of edge (wraps back to first vertex to close the polygon).\n            int vert_offs = j % poly_vert_count;\n            vec2 p1 = texelFetch(iChannel0, idx2uv(poly_vert_ptr + vert_offs, DECODE_RES.x), 0).xy;\n            \n            //Bounding box of edge\n            vec2 bb_mins = min(p0, p1);\n            vec2 bb_maxs = max(p0, p1);           \n\t\t\t\n            //If pos.y is outside Y min/max, ray cannot intersect.\n            //If pos.x is less than X minimum, ray cannot intersect.\n            if(pos.y >= bb_mins.y && pos.y < bb_maxs.y && pos.x >= bb_mins.x)\n            {\n                //If pos.x is greater than X maximum, ray intersected.\n                if(pos.x >= bb_maxs.x)\n                {\n                    n++;\n                }\n                else //pos.xy is inside the edge bounds, check intersection with line. \n                {\n                    float slope = (p1.x - p0.x)/(p1.y - p0.y);\n                    n += int(pos.x-p0.x > (pos.y-p0.y)*slope);\n                }\n            }\n\t\t\t\n            #if(WIREFRAME == 1)\n            d = min(d,dfLine(p0,p1,pos));\n            #endif\n            \n            p0 = p1;\n        }\n\n        poly_vert_ptr += poly_vert_count;\n\n        col = mix(col, poly_col, float(n & 1)); //Mix in polygon color if n is odd.\n    }\n    \n    fragColor = vec4(col,1);\n    \n    #if(WIREFRAME == 1)\n    \tfloat ps = 1.0/iResolution.y;\n    \tfragColor *= 1.-smoothstep(1.0*ps,0.,d);\n    #endif\n\t\n    #if(DEBUG == 1)\n    \tvec2 uv = fragCoord.xy/iResolution.xy;\n    \tfloat bar = floor(uv.x/0.03);\n       \tif(bar == 0.0)\n        {\n            int pal_idx = int(floor(uv.y*16.0));\n        \tfragColor.rgb = texelFetch(iChannel0,idx2uv(PALETTE_PTR+pal_idx, DECODE_RES.x),0).rgb;   \n        }\n    \tif(bar == 1.0)\n        {\n            float marks = float(MAX_VERTICES)/20.0;\n        \tfragColor.r = 1.-step(float(vert_count)/float(MAX_VERTICES), uv.y);\n            fragColor.r *= smoothstep(0.0,0.3,abs(sin(3.14159*uv.y*marks)));\n        }\n    \tif(bar == 2.0)\n        {\n            float marks = float(MAX_POLYS)/10.0;\n        \tfragColor.g = 1.-step(float(poly_count)/float(MAX_POLYS), uv.y);\n            fragColor.g *= smoothstep(0.0,0.3,abs(sin(3.14159*uv.y*marks)));\n        }\n        if(bar == 3.0)\n        {\n            float marks = 15.0; //Max # of vertices per poly (4-bit, 1111).\n        \tfragColor.b = 1.-step(float(vert_count)/float(poly_count)/15.0, uv.y);\n            fragColor.b *= smoothstep(0.0,0.2,abs(sin(3.14159*uv.y*marks)));\n        }\n\n    #endif\n    //Print \"Load Data File\" message if data file isn't loaded.\n    //Check if texture width is > 1 (passed from Buf A in y at 0,0).\n    if(state.y <= 1.)\n    {\n        ivec4 message = ivec4(0x4C6F6164,0x20446174,0x61204669,0x6C650000);\n        vec2 uv = fragCoord.xy/iResolution.y;\n        uv.x -= (iResolution.x/iResolution.y - StrSize(message).x)/2.;\n    \tfragColor += PrintStr(message,iChannel2, uv).rrrr;   \n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_POLYS 256\n#define MAX_VERTICES 640\n#define PALETTE_SIZE 16\n#define END_OF_FRAME 0xFF\n#define END_OF_BLOCK 0xFE\n#define END_OF_STREAM 0xFD\n\n#define DECODE_RES ivec2(32, 32)\n#define STATE_PTR 0\n#define PALETTE_PTR (STATE_PTR + 1)\n#define VERTEX_PTR (PALETTE_PTR + PALETTE_SIZE)\n#define MAX_ADDR (VERTEX_PTR + MAX_VERTICES)\n\n//1st frame from the demo for the thumbnail.\nint thumbnail[] = int[](\n    0x077F8005,0x200FF006,0x3004100F,0x50074003,0x000FFFD8,0xE352F058,0xEE53EC58,0xEE5AEA5A,0xEF60F665,0xF460F165, \n    0xF467EF67,0xF66FFE75,0xFB6FD35D,0xCF51C950,0xBB5ABF57,0xB957B55A,0xF479FB77,0xEE77E779,0xDF53DA56,0xDC66D661, \n    0xD551D152,0xB14EC055,0xBF4FBA54,0xF275D779,0xDE77D365,0xCD67DF79,0xE577BE68,0xC365BD65,0xB868E775,0xDA51BC5D, \n    0xC463C25E,0x98579B54,0x98539657,0xE175CB79,0xD177C551,0xC154D379,0xD977BE63,0x9E51A552,0xA14E9A4B,0x995F9D5B, \n    0xA35FA75C,0x9950934D,0xD575DB75,0x9F59A859,0x90508E52,0x914EC16E,0xCA75C86E,0xC379C977,0xB777B279,0xAE4FAA52, \n    0xA95F9E5F,0xA1639C66,0x9F639B5F,0x9F669C71,0xA06F9B68,0xBA75765E,0x785B7A4B,0x794FA279,0xA577A474,0xA076A879, \n    0xAC778E71,0x916E8B56,0xAD75A36F,0xA671A875,0x9E6F9378,0x97769C7A,0xA078936C,0xA2767168,0x72656949,0x684E514C, \n    0x50475253,0x5257785F,0x7C4A744A,0x74497A78,0x76787179,0x7D797877,0x77777E64,0x854C844A,0x7E669974,0x604D6049, \n    0x5B5B5B5F,0x74636B48,0x7A777F77,0x5F475959,0x56465157,0x56484E46,0x72777677,0x2A50274C,0x234B2650,0x505B3046, \n    0x2E44334C,0x364E4658,0x455A4445,0x43467474,0x7E752648,0x25412048,0x1A426179,0x61775377,0x54795F74,0x51675064, \n    0x4B774D79,0x11493852,0x306C336F,0x54743C77,0x3E794974,0x2D6A1A6D,0x1E703D74,0x26762A79,0x1E6C1978,0x1E7B2474, \n    0x166C0C76,0x12790669,0x17750A74,0x23000102,0x23030100,0x34040103,0x05230607,0x08230907,0x06340A07,0x090B230C, \n    0x0D0E230F,0x10114412,0x13141574,0x16171819,0x4419181A,0x1B230F1C,0x10441D1C,0x1E1F2320,0x21222323,0x21204413, \n    0x21231423,0x03002423,0x06032423,0x09062423,0x0C092423,0x0C240D44,0x170D2418,0x34182400,0x1A442526,0x27287429, \n    0x2A262544,0x2B2C2D2E,0x232F1E1C,0x231E2F30,0x23313233,0x44343536,0x3723382F,0x1C230F38,0x1C342638,0x0F27442A, \n    0x2F382644,0x393A3B3C,0x743D3E3A,0x39233F32,0x31442C32,0x3F2D2340,0x41422340,0x42434444,0x45353444,0x46474544, \n    0x23484043,0x23484349,0x44354048,0x36230F11,0x4A343A4A,0x113B443E,0x4B4A3A23,0x0F4A4B23,0x404C4114,0x454C4035, \n    0x44474D4C,0x4523414C,0x4D234849,0x4E344F4E,0x49502351,0x52537454,0x55565744,0x57565859,0x235A5B5C,0x145D5E5B, \n    0x5F44605C,0x5E5D235C,0x5B5E4461,0x62606323,0x23206423,0x31236423,0x3F316423,0x513F6423,0x51645244,0x55526456, \n    0x34566420,0x58446566,0x67684469,0x6A6B6C74,0x6D6E6A69,0x446F704F,0x7123725A,0x5C146273,0x5C602374,0x5C732375, \n    0x725C2374,0x755C446A,0x75746B44,0x6E72756A,0x2376484E,0x74777870,0x6F44797A,0x78772376,0x4E7B1470,0x7B4E4F23, \n    0x7C747323,0x7C737634,0x6B747C7A,0x447D7E7F,0x80148182,0x83843466,0x85866754,0x87888566,0x14898A8B,0x8C348D8E, \n    0x8A89238F,0x86855490,0x918F9223,0x868F9123,0x937C7623,0x93767B44,0x78937B70,0x147A7C93,0x78149495,0x96972385, \n    0x88982398,0x8F85347E,0x98997F23,0x98889944,0x9A898C9B,0x54959C9D,0x96239E9D,0x9C239D9E,0x9F34839F,0x9EA05482, \n    0xA19F8374,0x8BA27E7D,0x448AA3A2,0x8B44A4A5,0xA6A723A8,0x9D9F84A9,0xAAABAC23,0x9FA1AD23,0xA89FAD34,0xAEADAFB0, \n    0x23ADA1AF,0x2398B18F,0x14A2B198,0x7E449BB2,0xB1A2238F,0xB1B223B3,0xABAA23B3,0xAAB423B5,0xB3B423B5,0xB4B634A5, \n    0xB3B5A674,0xB7B8B9BA,0x64969DBB,0xB844BCBD,0xBEBF23C0,0xB5B634C1,0xACC2C323,0xA8C49D14,0xB9C4A8BD,0x44B8BBC4, \n    0xB9239DC4,0xBB74BFBE,0xC5C623AD,0xC7A864BD,0xA8C7BE54,0xACABC8C2,0x44A7A6C9,0xCA14C5CB,0xADAE44BE,0xC7CBC523, \n    0xC7ADCB14,0xC3C2CCCD,0x23B3CEAB,0x23C8ABCE,0x14CDCCCF,0xD023D1C8,0xCE64C2C8,0xD1CC23C0,0xD2B554A6,0xB5D2C944, \n    0xD0CFD3D4,0x23C0D5D2,0x23D6D1CE,0x34CCD1D6,0xCF23D7D6,0xCE23D7CE,0xD223D5D7,0xD214CFD6,0xD7D3FD00,0x00000000 \n);\n\n//Misc utility functions\n\n//Linear address to 2D coordinate.\nivec2 idx2uv(int idx, int width)\n{ \n    return ivec2(idx % width, idx / width);\n}\n\n//2D coordinate to linear address.\nint uv2idx(ivec2 uv, int width)\n{\n\treturn uv.x + uv.y*width;    \n}\n\n//Check if bit 'b' is set in value 'v'.\nbool bitSet(int v, int b)\n{\n    return ((v>>b)&1) == 1;\n}\n\n//High 4 bits of a byte 'v'.\nint hiNibble(int v)\n{\n    return (v >> 4) & 0x0F;\n}\n\n//Low 4 bits of a byte 'v'.\nint loNibble(int v)\n{\n    return v & 0x0F;\n}\n\n//Convert 16-bit Atari-ST color format to normalized RGB vector.\nvec3 STtoRGB(int STcol)\n{\n    //00000RRR0GGG0BBB\n    return vec3((ivec3(STcol) >> ivec3(8,4,0)) & 0x7) / 7.0;\n}\n\n//Distance to line segment p0,p1 from point p \nfloat dfLine(vec2 p0, vec2 p1, vec2 p)\n{  \n\tvec2 line = p1 - p0;\n\tfloat frac = dot(p - p0,line) / dot(line,line);\n\treturn distance(p0 + line * clamp(frac, 0.0, 1.0), p);\n}\n\n//Sting printing functions\n\n//Constants\n#define CHARS_PER_IVEC4 16\n#define FONT_COLUMNS 16.0\n\n//Special characters\n#define NUL 0x00\n#define LF 0x0A\n#define SPACE 0x20\n\nvec2 charSize = vec2(0.090, 0.2);\n\n/*\nReturns the specified byte in an ivec4 (16 max)\nIndex is from left to right as typed.\ni: 0..                                  ..15\n  /|                                     /|\n0x00112233,0x44556677,0x8899AABB,0xCCDDEEFF\n*/\n\nint ivec4byte(ivec4 v4, int i)\n{\n    return (v4[i/4] >> 8*(3 - i%4)) & 0xFF;\n}\n\n//Ascii code to uv coord in the font texture.\nvec2 AsciiToUV(int ascii)\n{\n\treturn vec2(ascii & 0x0F,int(FONT_COLUMNS-1.0) - (ascii >> 4))/FONT_COLUMNS;   \n}\n\n//Return the max width/height of the string.\nvec2 StrSize(ivec4 str)\n{\n    int maxw = 0;\n    ivec2 cursor = ivec2(0);\n    \n\tfor(int i = 0;i < CHARS_PER_IVEC4;i++)\n    {\n        int char = ivec4byte(str,i); \n        \n        if(char == NUL){ break; }\n        if(char == LF)\n        {   \n            maxw = (cursor.x > maxw) ? cursor.x : maxw;   \n            cursor.x = 0;\n        \tcursor.y--;  \n        }\n        else\n        {\n        \tcursor.x++; \n            maxw = (cursor.x > maxw) ? cursor.x : maxw; \n        } \t   \n    }\n    \n    return vec2(maxw, -cursor.y+1) * charSize;\n}\n\n//Prints a null-terminated 16 character string.\nvec4 PrintStr(ivec4 str, sampler2D font, inout vec2 uv)\n{\n\tivec2 grid = ivec2(floor(uv / charSize)); //Pixel location on char grid\n    ivec2 cursor = ivec2(0); //Grid location of the printed char\n    vec2 chuv = fract(uv / charSize)/(charSize.y/charSize); //Char local UVs \n    chuv.x += (charSize.y-charSize.x)/charSize.y / 2.; //Center char in cell\n    vec2 choffs = AsciiToUV(SPACE);\n    \n    for(int i = 0;i < CHARS_PER_IVEC4;i++)\n    {\n        int char = ivec4byte(str,i);\n        \n        if(char == NUL){ break; } //Stop at NUL (0x00)\n        if(char == LF) //New line on line-feed (0x0A)\n        {\n            cursor.x = 0;\n        \tcursor.y--;   \n        }\n        else\n        {  \n            if(cursor == grid)\n            {\n                choffs = AsciiToUV(char);\n            }\n            \n        \tcursor.x++; \n        }\n    }\n    \n    //Set UVs to end of string (allow chaining of prints)\n    uv -= vec2(cursor)*charSize; \n    \n\treturn textureLod(font, (chuv/FONT_COLUMNS)+choffs, 0.0);   \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*\n\nParser\n\nExtracts the vertices, polygons, and palette colors from the data file\nand outputs them in a simplified format for rendering.\n\nTo load the data file do the following:\n1) Copy the following:\n\ngShaderToy.SetTexture(1, \n{mSrc:'https://media.discordapp.net/attachments/744639380035076208/744639443398426644/scene1.png', \nmType:'texture', mID:1,\nmSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n2) Go to the \"Buffer A\" tab.\n3) Open the developer console in your browser.\n4) Paste what your copied and hit Enter.\n5) Reset the shader.\n\n*/\n\n//Read an 8-bit byte and increment the pointer.\n//Texture has 4 bytes/pixel, the pixel is cached to reduce texture reads.\nvec4 cache = vec4(0);\nint cache_loc = -1;\nint readByte(inout int ptr)\n{\n    if(textureSize(iChannel1,0).x > 1) //If the data file texture is loaded, read from it.\n    {\n        int px_ptr = ptr/4;\n        if(px_ptr != cache_loc)\n        {\n            cache = texelFetch(iChannel1,ivec2(px_ptr%512,px_ptr/512),0);\n            cache_loc = px_ptr;\n        }\n\n        int val = int(cache[ptr % 4]*255.0);\n        ptr++;\n        return val;\n    }\n    else //If the data file texture is not loaded, read the thumbnail data. \n    {\n        int tmp_ptr = ptr;\n        ptr++;\n        return (thumbnail[tmp_ptr/4] >> (3-(tmp_ptr%4))*8 ) & 0xFF;\n    }\n}\n\n//Read a 16-bit big-endian word and increment the pointer.\nint readWord(inout int addr)\n{\n    int hi = readByte(addr);\n    int lo = readByte(addr);\n    return hi*256 + lo;\n}\n\n//Decoder\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(any(greaterThanEqual(ivec2(fragCoord),DECODE_RES)))\n    {\n        fragColor = vec4(0); \n        return; \n    }\n    \n    //Linear address of the current pixel.\n    int pixel_addr = uv2idx(ivec2(fragCoord), DECODE_RES.x);\n\n    //Read data pointer data back from previous frame.\n    int data_ptr = int(texelFetch(iChannel0, idx2uv(STATE_PTR, DECODE_RES.x), 0).x);\n\t\n    //Read palette back from previous frame.\n    int palette[PALETTE_SIZE];\n    for(int i = 0;i < PALETTE_SIZE;i++)\n    {\n        palette[i] = int(texelFetch(iChannel0, idx2uv(PALETTE_PTR+i, DECODE_RES.x), 0).a);\n    }\n\n    //Read frame flags\n    int flags = readByte(data_ptr);\n    bool clear   = bitSet(flags, 0);\n    bool paldata = bitSet(flags, 1);\n    bool indexed = bitSet(flags, 2);\n\n    //If there's palette data, read the bitmask.\n    //If the bit corresponding to a color in the palette is set, update that color.\n    //Bitmask is in reverse order (i.e. bit 0 -> color 15).\n    if(paldata)\n    {\n        int bitmask = readWord(data_ptr);\n        for(int i = 0;i < PALETTE_SIZE;i++)\n        {\n            if(bitSet(bitmask, PALETTE_SIZE-1-i))\n            {\n                palette[i] = readWord(data_ptr);\n            }\n        }\n    }\n\n    int total_polys = 0;\n    int total_verts = 0;\n    int vert_buf_ptr = 0;\n    vec4 vert_out = vec4(0);\n\n    //If indexed mode, save pointer to vertex buffer & skip to polygons.\n    if(indexed) \n    {\n        int vtx_buf_size = readByte(data_ptr);\n        vert_buf_ptr = data_ptr;\n        data_ptr += vtx_buf_size*2; //2 bytes per vertex.\n    }\n\n    for(int i = 0;i < MAX_POLYS;i++)\n    {\n        int poly_desc = readByte(data_ptr);\n        int poly_pal_index = hiNibble(poly_desc);\n        int poly_vert_count = loNibble(poly_desc);\n\n        //Goto next frame.\n        if(poly_desc == END_OF_FRAME ){ break; }\n        //Goto next frame in next 64k block.\n        if(poly_desc == END_OF_BLOCK ){ data_ptr = (data_ptr&0xFFFF0000)+0x10000; break; }\n        //End of the demo (restart).\n        if(poly_desc == END_OF_STREAM){ data_ptr = 0; break;}\n\t\t\n\t\t//Offset of the current vertex from the data pointer.\n        int vert_offset = pixel_addr - (VERTEX_PTR + total_verts);\n        \n        //Copy polygon vertices from data file in parallel (based on pixel address). \n        if(vert_offset >= 0 && vert_offset < poly_vert_count)\n        {\n            if(indexed) \n            {\n                int tmp_ptr = data_ptr + vert_offset; //1 byte per vertex index\n                int vtx_ptr = vert_buf_ptr + readByte(tmp_ptr)*2;\n                \n                vert_out = vec4(\n                    readByte(vtx_ptr),\n                    readByte(vtx_ptr), \n                    poly_pal_index,\n                    poly_vert_count\n                );\n            }\n            else\n            {\n                int tmp_ptr = data_ptr + vert_offset*2; //2 bytes per vertex (non-indexed).\n                \n                vert_out = vec4(\n                    readByte(tmp_ptr),\n                    readByte(tmp_ptr),\n                    poly_pal_index,\n                    poly_vert_count\n                );\n            }\n        }\n        \n        //Increment data pointer based on # of vertices.\n        data_ptr += indexed ? poly_vert_count : poly_vert_count*2;\n        \n        //Increment total # of vertices / polygons.\n        total_verts += poly_vert_count;\n        total_polys++;\n    }\n\t\n    //Save palette for next frame\n    if(pixel_addr >= PALETTE_PTR && pixel_addr < PALETTE_PTR + PALETTE_SIZE)\n    {\n        int st_col = palette[pixel_addr - PALETTE_PTR];\n        \n        fragColor = vec4(STtoRGB(st_col), st_col);\n        return;\n    }\n\t\n    //Save frame state\n    if(pixel_addr == STATE_PTR)\n    {\n        fragColor = vec4(\n            data_ptr, //Save data pointer for next frame.\n            textureSize(iChannel1,0).x, //Save data file texture width to detect when it's loaded.\n            total_verts, //Save total # of vertices in frame.\n            total_polys //Save total number of polygons in frame.\n        );\n        return;\n    }\n\t\n    //Save vertices\n    if(pixel_addr >= VERTEX_PTR && pixel_addr < MAX_ADDR)\n    {\n        vert_out.xy /= vec2(255,199); //Normalize vertex locations.\n        vert_out.y = 1.0 - vert_out.y; //Flip Y axis.\n        vert_out.z = float(palette[int(vert_out.z)]); //Get palette color\n        \n\t\tfragColor = vert_out;\n        return;\n    }\n    \n    //Initialize to 0\n    if(iFrame == 0){ fragColor = vec4(0); }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}