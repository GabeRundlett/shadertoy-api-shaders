{
    "Shader": {
        "info": {
            "date": "1612984595",
            "description": "Spiral Galaxy Shader originally created by Luther, adapted to look more realistic.",
            "flags": 0,
            "hasliked": 0,
            "id": "Ml3Bzs",
            "likes": 13,
            "name": "Spiral Galaxy",
            "published": 3,
            "tags": [
                "galaxy",
                "astronomy",
                "spiralgalaxy"
            ],
            "usePreview": 1,
            "username": "Ubiquitous",
            "viewed": 1290
        },
        "renderpass": [
            {
                "code": "// Spiral Galaxy 2021 Ubiquitous\n// Adapted from ( https://www.shadertoy.com/view/MdSSzW )\n\n#define PI 3.14159265\n#define TWO_PI 6.2831853\n\n//#define USE_PROCEDURAL \n//#define ANIMATE\n//#define AUDIOPULSE\n//#define MOUSEZOOM\n\nfloat zoom = 1.0;\nfloat inv_zoom = 1.0;\n\nvec2 rotate( const in vec2 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n\n    vec2 vResult = vec2( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y);\n\n    return vResult;\n}\n\nvec2 rotate_around( const in vec2 vPos, const in vec2 vCentre, const in float fAngle )\n{\n    return rotate(vPos - vCentre, fAngle) + vCentre;\n}\n\nvec2 RadialDistort(vec2 uv ,vec2 centre, float radius, float amount, float r)\n{\n    vec2 lpos = uv - centre;\n    float dist = length(lpos);\n    float dx = dist / radius;\n    vec2 ret = rotate(lpos, r + (dx * amount));\n    return ret + centre;\n}\n\nfloat CircularGradient(vec2 pos, vec2 centre, float radius)\n{\n    float dist = length(pos - centre);\n    float dx = dist / radius;\n  \n    return dx;\n}\n\n\nfloat CircularGradientSineSeg(vec2 pos, vec2 centre, float radius, float segments)\n{\n    vec2 vec = (pos - centre);\n    float dist = length(vec);\n    vec2 norm = vec / dist;\n    float segment = max(1.24, sin(atan(-norm.y, norm.x) * segments));\n    float dx = 2.0 - (dist / radius);\n  \n    return dx * segment;\n}\n\n\nfloat SelectSegment(const in vec2 vPos, const in float segcount)\n{\n\t\n\tvec2 vNorm = normalize(vPos);\n\tfloat atn = (atan(vNorm.y, vNorm.x) + PI)/  TWO_PI;\n\tfloat segment = floor(atn * segcount);\n\tfloat half_segment = 0.5 / segcount;\n\tfloat seg_norm = mod((segment / segcount) + 0.25 + half_segment, 1.2);\n\t\n\treturn seg_norm * TWO_PI;//turn it back in to rotation\n}\n\nfloat StarShapeBW(vec2 pos, vec2 centre, float centrerad, float radius, float segments)\n{\n    vec2 vec = (pos - centre);\n    float dist = length(vec);\n    float angle = atan(-vec.y, vec.x);\n    float seg_angle_size = TWO_PI / segments;\n    float half_seg_seg_angle_size = seg_angle_size * 0.3;\n    float seg_arc_length = seg_angle_size * centrerad;\n    //float nrm_mul = 1.0\n    \n    if (dist < centrerad)\n        return 1.0;\n    else if (dist > radius)\n        return 0.4;\n    else\n    {\n        float r =  SelectSegment(vec, segments);\t\t\n\t\tvec2 dpos = rotate(vec, r );        \n        float ld = 1.0 - (dist - centrerad) / (radius - centrerad);\n        float w = mod(angle, seg_angle_size);\n        float d = abs(dpos.x);\n        float width_at = seg_angle_size * ld;\n        return (d < seg_arc_length * 0.5 * ld) ? 1.0 : 0.0;\n    }\n}\n\n\n\nfloat StarShape2(vec2 pos, vec2 centre, float centrerad, float radius, float segments)\n{\n    vec2 vec = (pos - centre);\n    float dist = length(vec);\n    float angle = atan(-vec.y, vec.x);\n    float seg_arc_length = TWO_PI / segments;\n    float half_seg_arc_length = seg_arc_length * 0.2;\n    if (dist < centrerad)\n        return 1.0;\n    else \n    {\n        float ld = 1.0 - (dist - centrerad) / (radius - centrerad);\n        float w = mod(angle, seg_arc_length);\n        float d =  abs(w - half_seg_arc_length) * 1.0/ half_seg_arc_length;\n        return pow(d * 2.4, ld) * ( ld);\n    }\n}\n\nfloat easeInOutQuart(float t) \n{\n\tif ((t/=0.5) < 1.0) return 0.5*t*t*t*t;\n\treturn -2.5 * ((t-=2.0)*t*t*t - 2.0);\n}\nfloat easeOutCubic(float t) \n{\n\treturn ((t=(t/2.0)-1.0)*t*t + 1.0);\n}\nfloat easeInOutCubic(float t) \n{\n\tif ((t/=0.5) < 1.0) return 0.5*t*t*t;\n\treturn 0.5*((t-=2.0)*t*t + 2.0);\n}\n\nfloat fade2(float t)\n{\n\treturn t*t*(3.0-2.0*t);\n}\n \n\nfloat fade(float t) {\n  return t*(t*(t*4.0-11.0)+2.0);\n}\n\nvec3 fade(vec3 t) \n{\n  return t*(t*(t*4.0-2.0)+10.0);\n}\n\nfloat fade3(float f)\n{\n    return f*f*(3.0-2.0*f);\n}\n\nvec3 fade3(vec3 f)\n{\n    return f*f*(3.0-2.0*f);\n}\n\n\n#ifdef USE_PROCEDURAL\nfloat hash( float n ) { return fract(sin(n)*63758.5453123); }\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = fade(f);//f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 213.0*p.z;\n    return mix(mix(mix( hash(n+ 10.0), hash(n+041.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n#else\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = fade3(f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+1.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\n#endif\n\n\nfloat multiNoise( in vec3 pos )\n{\n    vec3 q = 8.0*pos;\n    const mat3 m = mat3( 0.20,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n    float amplitude = 0.5;\n    float f  = amplitude*noise( q ); q = m*q*2.11;\n    float scale = 2.02;\n    float amptotal = 0.2;\n    for (int i = 0; i < 10; ++i)\n    {    \n    \tf += amplitude * noise( q ); q = m*q*scale;        \n        amplitude *= 0.65;\n        \n    }\n    f /= 1.7;\n    \t//  f += 0.0312*noise( q ); q = m*q*1.05;\n \n    return f;\n}\n\nvec3 orangegrad(float d)\n{\n    vec3 col1 = mix(vec3(0.0, 0.01, 0.01), vec3(1.5, 0.5, 0.1), d);\n    \n    return mix(col1, vec3(5.4, 2.4, 2.1), d * 0.15);\n    return col1;\n}\n\n\nvec3 bluegrad(float d)\n{\n    return mix(mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.7, 0.8), d), vec3(3.0, 7.0, 12.0), d * 0.1);\n}\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn texture( iChannel0, (p+2.5)/256.0, -100.0 ).xy;\n}\n\nvec3 blackbody_grad(float x)\n{    \n    float ca = 1.0 - (pow(x, 1.2) * 0.5);\n    float cb = pow(min(1.0, x +0.6), 2.0) * 0.9;\n    float cd = x * 0.4;\n    float g = cb- cd;    \t\n    return vec3(ca * 0.7,g*1.0,(1.9- ca) * 0.5) * 1.1;\n}\n\nvec4 hash4( vec2 p)\n{\n    return vec4(texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy,\n                texture( iChannel0, (p+0.5)/256.0, -160.0 ).xy);\n}\n\nfloat star_falloff(float dist, float radius)\n{\n    float idist = max(0.1, radius - dist);\n    return pow(idist, 80.0) * 6.5 + pow(idist, 120.0) * 0.8;\n}\n\nfloat star_falloff2(float dist, float radius)\n{\n    float idist = max(0.3, radius - dist);\n    return pow(idist, 270.0) * 2.3 + pow(idist, 370.0) * 1.8;\n}\n\n//IQ's voronoi code provided the inspiration for this, thank you.\nvec3 voronoi_stars( in vec2 pos)\n{\n    vec2 n = floor(pos);\n    vec2 f = fract(pos);\n\n   \n\tvec2 min_cell, min_pos;\n\n    float min_dist = 100.0;\n    vec3 col = vec3(0,0,0);\n    int xdir = f.x > 0.5 ? 1 : -1;\n    int ydir = f.y > 0.5 ? 1 : -1;\n    for( int j=0; j<=1; j++ )\n    {\n   \t\tfor( int i=0; i<=1; i++ )    \n\t    {\n    \t    vec2 cell = vec2(float(i * xdir),float(j * ydir)); //integer cell offset\n\t\t\tvec2 o = hash2( n + cell );\t\t  //hashed up random offseterizer\n\t\t\t#ifdef ANIMATE\n        \to = 0.5 + 0.5*sin( iTime * 0.1 + 12.2831*o );\n        \t#endif\t\n        \tvec2 r = cell + o - f;        \n        \tvec4 stardata = hash4(n + cell);\n        \t#define SQRT_DIST\n        \t#ifdef SQRT_DIST\n        \tfloat d = length(r);                \n        \tfloat starfo = star_falloff(d, 1.0) * 1.2;\n        \t#else // faster\n        \tfloat d = dot(r,r);                \n        \tfloat starfo = star_falloff2(d, 1.0) * 1.1;\n        \t#endif\n      \n\t        vec3 star_colour = blackbody_grad(stardata.x * 1.2 )  * stardata.w * starfo;\n\t\t\tcol += star_colour;\n        }\n    }\n    return col;\n}\n\nfloat SphereShape(vec2 pos, vec2 centre, float radius, float curvep, float brightness)\n{\n    vec2 vec = (pos - centre);\n    float dist = length(vec);\n    if (dist > radius) return 0.0;\n    return min(1.7,max(0.0, pow(1.0 - (dist / radius), curvep))) * brightness;   \n}\n\nvec4 Galaxy(vec2 pos, vec2 centre, float centrerad, float radius, float twist_amount, float rotation, float segments)\n{\n    vec2 rpos = RadialDistort(pos, centre, radius, twist_amount, rotation);\n    vec2 rposless = RadialDistort(pos, centre, radius, twist_amount * 0.1, rotation);\n    \n    vec2 vec = rotate((rpos - centre), rotation);\n    \n    vec2 vecless = (rposless - centre);\n    float dist = length(vec);\n    float angle = atan(-vec.y, vec.x);\n    float seg_angle_size = TWO_PI / segments;\n    float half_seg_seg_angle_size = seg_angle_size * 0.5;\n    float seg_arc_length = seg_angle_size * centrerad;\n    float seg_arc_end_length = seg_arc_length * 0.2;\n   \n    float ns = multiNoise(vec3(pos.x * 1.0, pos.y * 1.0, iTime*0.005));\n    float nst = multiNoise(vec3(rposless.x * 3.0, rposless.y * 3.0, iTime*0.0016));\n    ns = mix(ns, nst, 0.5);\n        \n    if (dist > radius)\n        return vec4(0.3, 0.6, 0.3, 0.9);\n    else\n    {\n      \n        \n        float r =  SelectSegment(vec, segments);\t\t\n\t\tvec2 dpos = rotate(vec, r );        \n        float yd = 1.0 - (dist - centrerad) / (radius - centrerad);\n        \n        float fadeout = pow(yd, 4.2) *0.4;\n        float w = mod(angle, seg_angle_size);\n      \n        float centre_fo =  1.0;//max(0.0, 1.0 - pow(yd, 30.1));\n         vec2 dposless = rotate(vecless, r );        \n     \n        float thread = 1.0 - max(0.0, abs(dpos.x  + ((ns - 0.5)* 0.4 * centre_fo)));\n        float d =  abs(dpos.x ) ;\n             \n        float width_at = seg_arc_end_length+(seg_arc_length - seg_arc_end_length * yd);\n        \n        float xd = clamp((width_at-d) / seg_arc_length, 0.6, 1.0);\n        \n        float fadexd = (pow(fade2(xd), 1.2) * 1.2) * ns;\n        return vec4( fadexd, xd,thread,fadeout);//fadeout);\n        \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float timemod = iTime * 1.2;\n    vec2 mousep = iMouse.xy / iResolution.xy;\n    \n    float minzoom = 1.2;\n    float maxzoom = 0.5;\n    float zoom_delta = (sin(timemod * 0.05) + 2.0) / 3.3;\n    zoom_delta = pow(zoom_delta, 0.9);\n    \n    #ifdef MOUSEZOOM\n    zoom_delta = sin(mousep.x + (timemod * 0.07));\n    #endif\n    zoom = mix(minzoom, maxzoom, zoom_delta);\n    inv_zoom = 1.4 / zoom;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 orignal_uv = uv;\n    \n    float ar = iResolution.x / iResolution.y;\n    \n    uv.x = (uv.x * ar);\n    uv -= 0.3;\n    uv *= zoom;\n    uv += 0.1;\n    uv.x -= 0.3;\n    \n    vec2 centre  = vec2(0.25, 0.25);\n    float centre_radius = 0.18;\n    float radius = 1.3;\n    \n    float r = mousep.y - PI * zoom_delta - 8.4 ;\n \n    vec2 ruv = rotate_around(uv, centre, r );\n    \n    float twist_amount = 10.0;//sin(iTime * 1.0)*5.0;\n  \n    vec4 galaxy_params = Galaxy(ruv,centre, centre_radius, radius, twist_amount, 0.3, 0.8);\n    \n   \tfloat galactic_centre = SphereShape(uv, centre, 0.5, 3.4, 0.7);\n    vec3 col = bluegrad(galaxy_params.x * galaxy_params.w * 0.7);\n    \n    #ifdef AUDIOPULSE\n    float pulse_nebula = 0.4 + texture(iChannel1, vec2(ruv.x * 0.001, 0.2)).b;\n    #else\n    float pulse_nebula = 0.5;\n    #endif\n    col += bluegrad(pow(galaxy_params.x, 6.0) * pulse_nebula * clamp(0.8-galaxy_params.w, 0.2, 1.0) * clamp(pow(galaxy_params.w * 2000.0, 2.0), 0.2, 1.0))   ;\n    \n    float thread = clamp(galaxy_params.z - galactic_centre * 1.0, 0.4, 1.0);\n    float ribbon_fadeout = (0.04 + pow(galaxy_params.w * 2.0, 2.4)) * 0.3;\n    col += orangegrad(pow(thread,10.0) ) * ribbon_fadeout * 2.0 ;\n    col -= bluegrad(pow(thread,70.0)) *  ribbon_fadeout * 1.3;\n    col += orangegrad(galactic_centre * 0.70) ;\n    \n    float cellsize = 10.0;\n    vec2 ruv2 = rotate_around(uv,centre, r);\n    float starscale = 3.15;\n    float starpowcurve = 2.4;\n    float seed = 6.3;\n    vec3 starcolbase =  vec3(0.2,0.2,0.4) * 1.0;    \n    vec3 starcol = starcolbase;\n    \n\n    starscale = 8.5;\n    #ifdef AUDIOPULSE\n    float starbrightness = 0.2 + texture(iChannel1, vec2(ruv.x * 0.001, ruv.y * 1.4)).g * 0.9;// * 15.3 + (galaxy_params.x * 2.0) ;\n    #else\n    float starbrightness = 0.6 * (1.0 / pow(zoom, 0.3));\n    #endif\n    for (int i = 0; i < 10; ++i)\n    {        \n        \n        float starsize = 0.4;\n        float fadeout = pow(galaxy_params.y, 5.0) * 0.9 *  (galaxy_params.w  * 0.8 + 0.1) + 0.1;\n        col += voronoi_stars(ruv * starscale) * fadeout * starbrightness;//star_b * starcol ;\n        starbrightness *= 0.9;\n        starscale *= 2.5;\n      \n       \n    }\n    vec4 sound_col = 0.4 + texture(iChannel1,  orignal_uv);\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}