{
    "Shader": {
        "info": {
            "date": "1665015501",
            "description": "The search for truth in an infinite reality of apparent chaos...\n\nDrag mouse for camera movement.\nYou can play around with the scene parameters (line 33-35)\n\nsubstance reference: Kratom",
            "flags": 0,
            "hasliked": 0,
            "id": "styBW1",
            "likes": 24,
            "name": "The Determined Sphere",
            "published": 3,
            "tags": [
                "raymarching",
                "sphere",
                "endless",
                "heightmap",
                "infinite",
                "sand",
                "desert",
                "rolling"
            ],
            "usePreview": 0,
            "username": "derSchamane",
            "viewed": 447
        },
        "renderpass": [
            {
                "code": "//                  = The Determined Sphere =         \n//                by Maximilian Knape ·∑>| 2022            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n\n//   = Raymarching =\n\n#define MAX_STEPS 160\n#define STEP_FAC 0.9\n#define MAX_DIST 300.\n#define MIN_DIST 20.\n\n#define SURF_DIST .001\n#define SURF_MUL 400.\n#define SURF_EXP 1.8\n\n//  = Postprocessing = \n\n#define GAMMA vec3(.4545)\n#define GLOW_INT 0.18\n#define PP_CONT 1.0\n#define PP_VIGN 1.8\n#define AO_OCC 0.2\n#define AO_SCA 0.5\n\n#define AA_ENAB false\n#define AA_THRE .1\n\n// = Scene Parameters =\n\n#define SPH_SIZE 8.     //1..25\n#define SPH_SPEED 13.   //5..50\n#define TER_HEIGHT 3.   //1..5\n\n// --------------------\n\n#define iTime iTime*1.0\n#define PI 3.14159265358979\n#define TAU PI*2.\n#define S(x,y,t) smoothstep(x,y,t)\n#define ROT(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define SLOPE sin(atan(1.,2.2))\n#define TERSIZE 10000.\n\nfloat tOffset = 0.;\nfloat tang = 0.;\n\n\nmat2 Rot(float a) //2D\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n#define Rot2D(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 Rot(vec3 p, vec3 r) //3D - las\n{\n    Rot2D(p.xz, r.y);\n    Rot2D(p.yx, r.z);\n    Rot2D(p.zy, r.x);\n    return p;\n}\n\nfloat hash(float n) { return fract(sin(n)*43758.5453123); } //iq\n\nfloat noise(in vec2 x) //iq\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n    float res = mix(mix(hash(n+  0.0), hash(n+  1.0), f.x),\n                    mix(hash(n+ 57.0), hash(n+ 58.0), f.x), f.y);\n    return res;\n}\n\nfloat noise(in vec3 x) //iq\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix(hash(n+  0.0), hash(n+  1.0), f.x),\n                        mix(hash(n+ 57.0), hash(n+ 58.0), f.x), f.y),\n                    mix(mix(hash(n+113.0), hash(n+114.0), f.x),\n                        mix(hash(n+170.0), hash(n+171.0), f.x), f.y), f.z);\n    return res;\n}\n\nfloat SdBoxFrame( vec3 p, vec3 b, float e ) //iq\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec2 MirrorBox(in vec2 p, const float size) { return mod(abs(-mod(p - size, 4.*size) + 2.*size), 4.*size) - size; }\n\nvec2 Dist(vec3 p) \n{       \n    float d, t = iTime*SPH_SPEED + tOffset;\n    \n    //position\n    vec2 coor = MirrorBox(p.xz - vec2(t), TERSIZE);\n    float dis = length(p.xz) / MAX_DIST;\n    \n    //trail\n    float depth = S(SPH_SIZE, 0., max(0., abs(p.x - p.z))) * step(-SPH_SIZE / 2.5, min(p.x, p.z));\n    depth += min((length(p.xz + SPH_SIZE*.1) - SPH_SIZE*.9), 0.) * S(.8, 0., sqrt(depth));\n    float height = min(-depth * SPH_SIZE / 20., SPH_SIZE/TER_HEIGHT);\n    \n    //terrain\n    height += noise(coor / 100.) * 10.;\n    height += noise(coor /  10.) *  1.;\n    height += noise(coor /   1.) *  0.1 * max(-1., 1.-abs(depth));\n    height += S(.2, .1, dis) * noise(MirrorBox(p.xz - vec2(t), 10.) * 10.) * .01 * max(-.5, 1.5-abs(depth));\n    \n    //heightmap\n    d = max(p.y - height*TER_HEIGHT + SPH_SIZE*2., 0.) * SLOPE;\n    \n    //sphere height\n    vec2 sCoor = MirrorBox(-vec2(t), TERSIZE);\n    height  = noise(sCoor / 100.) * 10.;\n    height += noise(sCoor / 10.) * 1.;\n    height -= SPH_SIZE / 16.;\n    \n    //sphere\n    vec3 pos = p - vec3(0., height*TER_HEIGHT - SPH_SIZE, 0.);\n    float sphere = length(pos) - SPH_SIZE;\n    \n    //roll\n    pos = Rot(pos, vec3(length(vec2(iTime*SPH_SPEED + tOffset)) / SPH_SIZE, -PI/4., 0.));\n    \n    //pattern\n    const float ps = 2.;\n    float pat = length((mod(pos,ps)/ps - .5));\n    sphere -= pat * 0.1; \n    \n    //color + material\n    float col = sphere < d ? 2.1 + pat*2.0 : -1.95;\n    d = min(sphere, d);\n\n    /*\n    //ancient ruins\n    vec2 size = vec2(200.);\n    p.xz = MirrorBox(coor, 200.);//mod(abs(-mod(coor, 4.*size) + 2.*size), 4.*size) - size/2.;\n    p = Rot(p, PI*vec3(.015,-0.1,0.01));\n    float box = SdBoxFrame(p-vec3(30., 30., 25.), vec3(130.), 10.);\n    col = mix(0.7, col, step(d, box));\n    d = min(box, d);\n    */\n   \n    return vec2(d, col);\n}\n\nvec3 Normal(vec3 p) \n{\n    vec2 e = vec2(.01, 0);\n    return normalize(Dist(p).x - vec3(Dist(p-e.xyy).x, Dist(p-e.yxy).x,Dist(p-e.yyx).x));\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) \n{\n    float col = 0.;\n\tfloat dO = MIN_DIST;\n    int steps = 0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {\n        steps = i;\n        \n    \tvec3 p = ro + rd*dO;\n        vec2 dS = Dist(p);\n        col = dS.y;\n        dO += dS.x * mix(STEP_FAC, 1., dO/MAX_DIST);\n        \n        if (dO > MAX_DIST || dS.x < (SURF_DIST * (pow(dO/MAX_DIST, SURF_EXP)*SURF_MUL+1.))) break;\n    }\n    \n    return vec3(dO, steps, col);\n}\n\nfloat SoftShadow(vec3 ro, vec3 lp, float k) //Shane\n{\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro;\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end / float(maxIterationsShad);\n    \n    rd /= end;\n\n    for (int i = 0; i < maxIterationsShad; i++)\n    {\n\n        float h = Dist(ro + rd*dist).x;\n        shade = min(shade, smoothstep(0., 1., k*h/dist));\n        dist += clamp(h, .02, .25);\n        \n        if (h < .0 || dist > end) break;\n    }\n\n    return min(max(shade, 0.08) + .1, 1.); \n}\n\n\nfloat GetLight(vec3 p, vec3 n, vec3 lP, vec3 rd , float shine) \n{\n    vec3 l = normalize(lP - p);\n    float dif = S(-0., 1., dot(n, l)*.5+.5) * max(1.-max(-shine, 0.), 0.);\n    if (shine > 0.) dif = mix(dif+.2, dif*.1 + pow(max(dot(l, reflect(rd, n)), 0.), shine*20.), shine);\n    return dif;\n}\n\nfloat CalcAO(const in vec3 p, const in vec3 n) //iq\n{\n    float occ = AO_OCC;\n    float sca = AO_SCA;\n\n    for( int i = 0; i < 5 ; i++ )\n    {\n        float h = .001 + .150 * float(i) / 4.0;\n        float d = Dist(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= .95;\n    }\n    return S(.0, 1. , 1. - 1.5 * occ);    \n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 hsv2rgb_smooth( in vec3 c ) //iq\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.0)-1., 0., 1.);\n\trgb = rgb*rgb*(3.0-2.*rgb);\n    \n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 Palette(int index)\n{\n    switch (index)\n    {\n        case 0: return vec3(.5, .5, .5);\n        case 1: return vec3(1., .72, .5);\n        case 2: return vec3(.4, .6, 1.);\n        case 3: return hsv2rgb_smooth(vec3(fract(iTime*TAU/420.+.62), .7, 1.));\n        case 4: return vec3(1., 0.5, .2);\n    }\n    return vec3(0.);\n}\n\nvoid Render( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5 * iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n    if (length(m) <= 0.) m = vec2(.5);\n\n    //cam\n    float t = iTime*SPH_SPEED + tOffset;\n    float xos = -sin(iTime*TAU / 100.) * 20.;\n    vec3 ro = vec3(xos, 30., -SPH_SIZE-40.);\n    ro.yz *= Rot(min(1.5, (m.y+.3)*.3) * PI + PI*.5);\n    ro.xz *= Rot(-m.x * TAU - PI);\n    float height = noise(MirrorBox(vec2(-t), TERSIZE) / 100.) * 10. * TER_HEIGHT;\n    ro.y += height + pow(1.-m.y, 2.) * SPH_SIZE * 8.;\n    vec3 rd = R(uv, ro, vec3(xos, 5. + height, 0.), 1.);\n    \n    //light\n    vec3 lPos = vec3(8, 6, -2) * 1000.;\n    vec3 bg =  Palette(2) * .5;\n    bg = min(bg + pow(1. / (1. + 3.*S(1., -1., dot(normalize(lPos), rd))), 4.)*vec3(1) * .3, 1.); //sky\n    bg += pow(S(.999, 1., dot(normalize(lPos), rd)), 2.); //sun\n    vec3 col = bg;\n    \n    //speed variation\n    tang = mix((noise(MirrorBox(vec2(SPH_SIZE/1. - t), TERSIZE) / 100.) *10.*TER_HEIGHT) - height, tang, .85);\n    tOffset = mix(tOffset - ((tang * SPH_SPEED*.9)), tOffset, 0.1 + SPH_SPEED/50.);\n    \n    vec3 rmd = RayMarch(ro, rd);    \n    \n    if(rmd.x < MAX_DIST) \n    {\n        vec3 p = ro + rd * rmd.x;\n        vec3 n = Normal(p);\n        \n        col = Palette(int(floor(abs(rmd.z))));\n        col *= GetLight(p, n, lPos, rd, fract(rmd.z)*abs(rmd.z)/rmd.z);\n        col *= SoftShadow(p + n*.05, lPos, 2.0);\n        col *= CalcAO(p, n);\n        col = mix(col, bg, pow(rmd.x / MAX_DIST, SURF_EXP));\n    }\n    \n    col += rmd.y / float(MAX_STEPS) * GLOW_INT * sqrt(min(rmd.x, MAX_DIST) / MAX_DIST);\n    \n    fragColor = vec4(col,1.0);\n}\n\nvec4 PP(vec3 col, vec2 uv)\n{\n    //contrast\n    col = mix(col, S(vec3(0.), vec3(1.), col), PP_CONT);    \n    //ACES color\n    col =  clamp((col * (2.51f * col + 0.03f)) / (col * (2.43f * col + 0.59f) + 0.14f), 0.0f, 1.0f);\n    //Vignette\n    col *= S(PP_VIGN,-PP_VIGN/5., dot(uv,uv)); \n    //gamma correction\n    col = pow(col, GAMMA);\n    \n    return vec4(col, 1.);\n}\n\nvoid mainImage(out vec4 O, vec2 U) //Fabrice\n{\n    Render(O,U);\n    \n    if (AA_ENAB && fwidth(length(O)) > AA_THRE)\n    {\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { Render(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n        //O.r++; //Show sampled area\n    }\n    \n    O = PP(vec3(O), (U-.5 * iResolution.xy) / iResolution.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}