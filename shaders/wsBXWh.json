{
    "Shader": {
        "info": {
            "date": "1553566664",
            "description": "mouse input needed for context\nhold down left mouse\nmouse.z sets period\nmouse.x sets StartTime=offset\nmouse.y sets EndTime",
            "flags": 0,
            "hasliked": 0,
            "id": "wsBXWh",
            "likes": 2,
            "name": "max volume envelope",
            "published": 3,
            "tags": [
                "envelope",
                "fmsynthesis",
                "continuity",
                "bandfilter",
                "pianoroll"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 433
        },
        "renderpass": [
            {
                "code": "\n//A (piano roll) note has a start and an end, and a wavelength/period\n//Full periods/wavelengths rarely fit perfectly into [end-start]\n//where ever they do not fit, speakers will create VERY short very high noise\n//(unless they have a lowPass filter that filters that out)\n\n//A [maximum volume envelope] shortens [end] to fit into full periods/wavelengths\n//and then such a filter is not needed.\n\n//This is made for simple sums of simple intervals (sines)\n//to ALWAYS end a summand/wave after a full interval/period\n//but piano-roll slots may be longer than that.\n//the solution is if(floor(a)<b) within the correct offsets.\n//to shorten/mask a pianoRoll to perfectly match the wavelength\n//and it has to do that for each wavelength that an instrument generates.\n\n//A simplification trick is to define a subroutine-sheet function\n//, that loops over a midi sequence, foreach instrument foreach frequency\n//,to return the DISTANCE TO the start AND end of a note of any (rasterized) pitch.\n//this reduces audiovisual stuff AND envelope functions to the same logic/culling as signedDistanceFields.\n//which is simple, and which lets us reuse subroutines.\n\n\n\n//c0env() is a [maximum volume envelope] visualization\n//u.x=time, we actually only care for u.x=0\n//, but we visualize a timeline over u.x for clarity\n//u.x=0 is highlighted in green as \"now\" (null latency moment)\n//u.y is standing-wave-domain for the sake of showing c0 continuity of this function.\n//m.x sets timeNow-timeStart_OfNNoteOnPianoRoll == offset\n//m.y sets timeNow-timeEnd___OfNNoteOnPianoRoll\n//m.z sets interval/period , but HERE this just normalizes [u.x] and [m]\n//so that m.z==1\n//there are 3 if() cases, all of them should return 0 if this was used as envelope\n//and the final return should be =1.\n\n//important, c0env() asserts a normalized interval of 1\n//its inputs must be scaled to match that inverval;\n// u.x/=wavelength\n// m/=wavelength\n\n\n//checkerboard by https://www.shadertoy.com/view/4tG3Wh\nfloat checkerBool(vec2 h){h=fract(h);return float(h.x>.5==h.y>.5);}\n\n#define viewZoom 8.\nfloat aA(vec2 r){return max(r.x,r.y);}\n#define Aa(r) 1./aA(r)\nfloat ss(float a,float b){return smoothstep(b,-b,a);}\n\nvec2 fra(vec2 u,vec2 r){u*=viewZoom/r; u-=.5*viewZoom; u.x*=r.x/r.y;return u;}\n\n\n//4 cases are \n//- timeNow is before noteStart -> silence\n//- timenow is after  noteEnd   -> silence\n//- (floor(m.y)<u.x) == timeNow is too close to the end of the note\n//   , where a full interval does not fit in -> silence\n//- else -> full volume\n\n//c0env*() asserts normalizedTime, so that a period is ==1.\nfloat c0env(vec2 u,vec4 m\n){m.y-=m.x//offset by start\n ;u.x-=m.x//offset by start\n ;if(u.x<0.)return ss(-2.-u.y,.01)//left  of envelope multiply by *0\n ;if(u.x>m.y)return ss(-2.-u.y,.01)//right of envelope multiply by *0 \n ;if(floor(m.y)<u.x)return ss(-u.y,.01)//right of full wave multiply by *0\n ;//return *1 full volume\n ;float y=sin(u.x*acos(-1.)*2.)-u.y\n ;return ss(y,.01);}\n//below is non.-visualizing envelope variant of above, u.y is not needed\n//u.y is the scalar to multiply this function by, outside of c0env0()\nfloat c0env0(vec2 u,vec4 m\n){m.y-=m.x//offset by m.x=DitanceToStart\n ;u.x-=m.x//offset by m.x=DitanceToStart\n ;if(u.x<0.)return 0.\n ;if(u.x>m.y)return 0.\n ;if(floor(m.y)<u.x)return 0.\n ;return 1.\n ;}\n\nvoid mainImage(out vec4 o,vec2 u\n){u=fra(u,iResolution.xy)\n ;vec4 m=vec4(fra(iMouse.xy,iResolution.xy),fra(iMouse.zw,iResolution.xy))\n ;float now=1.-ss(.1,u.x)\n ;//m.z=cos(-1.)*.5+.6\n ;float c=checkerBool(u)\n ;float wavelength=abs(m.z)\n ;u.x/=wavelength\n ;m/=wavelength\n ;float g=c0env(u,m)\n ;//o=vec4(fract(iDate.w)+i.x/iResolution.x)\n ;o=vec4(g,now,c,1);}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}