{
    "Shader": {
        "info": {
            "date": "1507978853",
            "description": "Using a hexagonal grid and some basic 2D geometry to produce a commonly seen random isometric block pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltSczW",
            "likes": 58,
            "name": "Random Isometric Blocks",
            "published": 3,
            "tags": [
                "2d",
                "grid",
                "hexagon",
                "isometric",
                "pattern",
                "block"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 3927
        },
        "renderpass": [
            {
                "code": "/*\n\n\tRandom Isometric Blocks\n\t-----------------------\n\n\tI love looking at those geometric grid-based images that the procedural art and\n\tgraphic design crowd like to post on the internet. Many are isometric in nature, \n\tso tend to be created by applying simple hexagonal grid trickery - usually \n\tflipping some cleverly designed tiles in a random - or calculated - way.\n\n    In order to produce one, all you need to do is convert screen coordinates to a \n\thexagonal grid coordinate with corresponding cell ID, then use your imagination... \n\tor if you're like me and you don't have one, just reference one of the countless \n\tpatterns on the internet. :D\n\n\tAnyway, here's a simple example that I'm sure most have seen around. I'll put up a \n\tmore interesting one that involves interlacing next. Hopefully, some people on\n\tShadertoy will post others.\n\n\tBy the way, if you're not quite familiar with hexagonal grids, I've produced a \n\tbasic example to accompany this. The link is below.\n\n\t// Simpler hexagonal grid example that attempts to explain the grid setup used\n\t// to produce the pattern here.\n\t//\n\tMinimal Hexagonal Grid - Shane\n\thttps://www.shadertoy.com/view/Xljczw\n\n\t// You can't do a hexagonal grid example without referencing this. :) Very stylish.\n\tHexagons - distance - iq\n\thttps://www.shadertoy.com/view/Xd2GR3\n\n*/\n\n// I think it looks more interesting with the holes in the cubes, but if you're more\n// of a purist, comment out the following:\n#define CUBE_HOLES\n\n// Leave some cube faces solid - Abje's suggestion. I like it because it breaks things\n// up a bit.\n#define SOME_SOLID \n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\nconst vec2 s = vec2(1, 1.7320508);\n\n// Standard vec2 to float hash - Based on IQ's original.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.13, 289.97)))*43758.5453); }\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// A diamond of sorts - Stretched in a way so as to match the dimensions of a\n// cube face in an isometric scene.\nfloat isoDiamond(in vec2 p){\n    \n    p = abs(p);\n    \n    // Below is equivalent to:\n    //return p.x*.5 + p.y*.866025; \n    \n    return dot(p, s*.5); \n\n}\n\n/*\n// The 2D hexagonal isosuface function: If you were to render a horizontal line and one that\n// slopes at 60 degrees, mirror, then combine them, you'd arrive at the following.\nfloat hex(in vec2 p){\n    \n    p = abs(p);\n    \n    // Below is equivalent to:\n    //return max(p.x*.5 + p.y*.866025, p.x); \n\n    return max(dot(p, s*.5), p.x); // Hexagon.\n    \n}\n*/\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID - in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything - in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec4 getHex(vec2 p){\n    \n    // The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    // the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    // center we'll eventually use will depend upon which is closest to the current point. Since \n    // the central hexagon point is unique, it doubles as the unique hexagon ID.\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    \n    // Nearest hexagon center (with respect to p) to the current point. In other words, when\n    // \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID -\n    // in the form of the hexagonal central point. Note that a random constant has been added to \n    // \"hC.zw\" to further distinguish it from \"hC.xy.\"\n    //\n    // On a side note, I sometimes compare hex distances, but I noticed that Iomateron compared\n    // the Euclidian (squared) version, which seems neater, so I've adopted that.\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + vec2(.5, 1));\n    \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Screen coordinate.\n    float res = clamp(iResolution.y, 300., 600.);\n\tvec2 u = (fragCoord - iResolution.xy*.5)/res;\n    \n\n    // Scaling, translating, then converting it to a hexagonal grid cell coordinate and\n    // a unique coordinate ID. The resultant vector contains everything you need to produce a\n    // pretty pattern, so what you do from here is up to you.\n    vec4 h = getHex(u*6. + s.yx*iTime/4.);\n   \n    \n    // Storing the relative hexagonal position coordinates in \"p,\" just to save some writing. :)\n    vec2 p = h.xy;\n    \n    // Relative squared distance from the center.\n    float d = dot(p, p)*1.5;\n    \n    \n    // Using the idetifying coordinate - stored in \"h.zw,\" to produce a unique random number\n    // for the hexagonal grid cell.    \n    float rnd = hash21(h.zw);\n    rnd = sin(rnd*6.283 + iTime)*.5 + .5;\n    // It's possible to control the randomness to form some kind of repeat pattern.\n    //rnd = mod(h.z + h.w, 4.);\n    \n\n\n    \n    // Initiate the background to white.\n    vec3 col = vec3(1);    \n\n\n    // Using the random number associated with the hexagonal grid cell to provide some color\n    // and some smooth blinking. The coloring was made up, but it's worth looking at the \n    // \"blink\" line which smoothly blinks the cell color on and off.\n    //\n    float blink = smoothstep(0., .125, rnd - .75); // Smooth blinking transition.\n    float blend = dot(sin(u*3.14159*2. - cos(u.yx*3.14159*2.)*3.14159), vec2(.25)) + .5; // Screen blend.\n    col = max(col - mix(vec3(0, .4, .6), vec3(0, .3, .7), blend)*blink, 0.); // Blended, blinking orange.\n    col = mix(col, col.xzy, dot(sin(u*5. - cos(u*3. + iTime)), vec2(.3/2.)) + .3); // Orange and pink mix.\n    \n    // Uncomment this if you feel that greener shades are not being fairly represented. :)\n    //col = mix(col, col.yxz, dot(cos(u*6. + sin(u*3. - iTime)), vec2(.35/2.)) + .35); // Add some green.\n\n\n    \n    // Tile flipping - If the unique random ID is above a certain threshold, flip the Y coordinate, which\n    // is effectively the same as rotating by 180 degrees. Due to the isometric lines, this gives the\n    // illusion that the cube has been taken away. To build upon the illusion, the shading (based on \n    // distance to the cell center) is inverted also, which gives a fake kind of ambient occlusion effect.\n    //\n    if(rnd>.5) {\n        \n        p.xy = -p.xy;\n        col *= max(1.25 - d, 0.);\n    }\n    else col *= max(d + .55, 0.);    \n \n    \n    // Cube face ID - not to be confused with the hexagonal cell ID. Basically, this partitions space\n    // around the horizontal and two 30 degree sloping lines. The face ID will be used for a couple of\n    // things, plus some fake face shading.\n    float id = (p.x>0. && -p.y*s.y<p.x*s.x)? 1. : (p.y*s.y<p.x*s.x)? 2. : 0.;\n \n    \n    // Decorating the cube faces:\n    //\n    // Distance field stuff - There'd be a heap of ways the render the details on the cube faces,\n    // and I'd imagine more elegant ways to get it done. Anyway, on the spot I decided to render three \n    // rotated diamonds on the hexagonal face, and do a little shading, etc. All of this is only called \n    // once, so whatever gets the job done, I guess. For more elaborate repeat decoration, I'd probably\n    // use the \"atan(p.y, p.x)\" method. By the way, if someone can come up with a more elegant solution, \n    // feel free to let me know.\n    //\n    // Three rotated diamonds to represent the face borders.\n    float di = isoDiamond((p - vec2(0, -.5)/s));\n    di = min(di, isoDiamond(r2(3.14159/3.)*p - vec2(0, .5)/s));\n\tdi = min(di, isoDiamond(r2(-3.14159/3.)*p - vec2(.0, .5)/s));\n    di -= .25;\n    \n    // Face borders - or dark edges, if you prefer.\n    float bord = max(di, -(di + .01));  \n    \n    // The cube holes. Note that with just the solid cubes, the example becomes much simpler,\n    // and the code footprint decreases considerably.\n    #ifdef CUBE_HOLES\n    // Smaller diamonds for the holes and hole borders.\n    float hole = di + .15;  \n    #ifdef SOME_SOLID\n    if(abs(rnd - .55)>.4) hole += 1e5;\n    #endif\n    float holeBord = max(hole, -(hole + .02));\n    \n    // The lines through the holes for that hollow cube look... Yeah, there'd definitely be\n    // a better way to achive this. :)\n    holeBord = min(holeBord, max(abs(p.x) - .01, hole));\n    holeBord = min(holeBord, max(abs(p.x*s.x + p.y*s.y) - .02, hole));\n    holeBord = min(holeBord, max(abs(-p.x*s.x + p.y*s.y) - .02, hole));\n    \n    // All the borders.\n    bord = min(bord, holeBord);\n    \n    // Shading inside the holes - based on some isometric line stepping. It works fine,\n    // but I coded it without a lot of forethought, so it looks messy... Needs an overhaul.\n    float shade;\n    if(id == 2.) shade = .8 -  step(0., -sign(rnd - .5)*p.x)*.2;\n    else if(id == 1.) shade = .7 -  step(0., -sign(rnd - .5)*dot(p*vec2(1, -1), s))*.4;\n    else shade = .6 -  step(0., -sign(rnd - .5)*dot(p*vec2(-1, -1), s))*.3;\n    \n    // Applying the cube face edges, shading, etc. \n    //\n    col = mix(col, vec3(0), (1. - smoothstep(0., .01, hole))*shade); // Hole shading.\n    #endif\n    col = mix(col, vec3(0), (1. - smoothstep(0., .01, bord))*.95); // Dark edges.\n    col = mix(col, col*2., (1. - smoothstep(0., .02, bord - .02))*.3); // Edge highlighting.\n    // Subtle beveled edges... just for something to do. :)\n    col = mix(col, vec3(0), (1. - smoothstep(0., .01, max(di + .045, -(di  + .045 + .01))))*.5);\n   \n    // Cube shading, based on ID. Three different shades for each face of the cube.\n    col *= id/2. + .1;\n    \n\n\n   //////\n    \n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((u.x*s.x - u.y*s.y)*3.14159*120.)*2. + .5, 0., 1.); // Diagonal lines.\n    float hRnd = hash21(floor(p/6.*240.) + .73);\n    if(hRnd>.66) hatch = hRnd; // Slight, randomization of the diagonal lines.  \n    col *= hatch*.25 + .75; // Combining the background with the lines.\n\n    \n    // Subtle vignette.\n    u = fragCoord/iResolution.xy;\n    col *= pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .125)*.75 + .25;\n    // Colored variation.\n    //col = mix(pow(min(vec3(1.5, 1, 1)*col, 1.), vec3(1, 3, 16)).zyx, col, \n             //pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .125)*.5 + .5);    \n     \n  \n    // Rough gamma correction and screen presentation.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}