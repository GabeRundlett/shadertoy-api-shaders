{
    "Shader": {
        "info": {
            "date": "1642691001",
            "description": "If you have a map function that returns the surface and light distance it only takes 2 extra calls to determine the normal and light direction.",
            "flags": 8,
            "hasliked": 0,
            "id": "ssfyWj",
            "likes": 10,
            "name": "faster SoC with DEL",
            "published": 3,
            "tags": [
                "soc",
                "del"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 364
        },
        "renderpass": [
            {
                "code": "// faster SoC with DEL by eiffie (adding Distance Estimated Light to the Sphere of Confusion renderer)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//SoC is sampling the cone of confusion\n//DEL is distance estimated lights\n//This faster version uses only 2 extra distance estimates to calculate\n//the normal and light direction.\n\n//uncomment for a test scene\n//#define TEST_SPHERE\n\n#define time iTime\n#define size iResolution\n\nfloat pixelSize,focalDistance,aperture,fudgeFactor=0.6;//,shadowCone=0.5;\n\nvec3 mcol=vec3(0);\nmat2 rmx;\nconst vec4 p0=vec4(0.0,0.0,4.0,1.0);\nconst vec3 rc=vec3(6.633,0.033,6.133);\nvec2 DE(in vec3 z0){//amazing box by tglad\n#ifdef TEST_SPHERE\n if(mcol.x>0.)mcol+=vec3(1);\n return vec2(length(z0)-.75,length(vec3(sin(time),vec2(cos(time)))-z0));\n#else\n vec4 z = vec4(z0,1.0);float r2=10.0;\n for (int n = 0; n < 5; n++) {\n  z.xzy=clamp(z.xyz, -1.0, 1.0) *2.0-z.xyz;\n  z*=-2.0/clamp(dot(z.xyz,z.xyz),0.1,1.0);\n  z+=p0;\n  if(n==1)r2=length(z.xyz)/z.w;//distance to light\n  z.xy=z.xy*rmx;\n }\n z=abs(z);\n if(mcol.x>0.)mcol+=sin(z.xyz)*.5+.5;\n z.xyz=max(z.xyz-rc,vec3(0.0));\n return vec2((length(z.xyz)-0.1)/z.w,r2);//returns distance to surface and light\n#endif\n}\n\nfloat CircleOfConfusion(float t){//calculates the radius of the circle of confusion at length t\n return max(abs(focalDistance-t)*aperture,pixelSize*(1.0+t));\n}\nmat3 lookat(vec3 fw,vec3 up){\n fw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\nfloat linstep(float a, float b, float t){return clamp((t-a)/(b-a),0.,1.);}// i got this from knighty and/or darkbeam\n//random seed and generator\nvec2 randv2;\nfloat rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n randv2+=vec2(1.0,1.0);\n return fract(sin(dot(randv2 ,vec2(12.9898,78.233))) * 43758.5453);\n}\n//not used\nfloat FuzzyShadow(vec3 ro, vec3 rd, float lightDist, float coneGrad, float rCoC){\n float t=0.01,d=1.0,s=1.0;\n for(int i=0;i<4;i++){\n  if(t>lightDist)continue;\n  float r=rCoC+t*coneGrad;//radius of cone\n  d=DE(ro+rd*t).x+r*0.66;\n  s*=linstep(-r,r,d);\n  t+=abs(d)*(0.8+0.2*rand2());\n }\n return clamp(s,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(100.0,100.0))+vec2(time)*10.0)*1000.0);\n pixelSize=1.0/size.y;\n float tim=time*0.25;//camera, lighting and object setup\n float ct=cos(tim),st=sin(tim);\n rmx=mat2(ct,-st,st,ct);\n float z=cos(tim*0.3)*5.0;\n#ifdef TEST_SPHERE\n vec3 ro=vec3(0,0,-2);\n#else\n vec3 ro=vec3(vec2(ct,st)*(abs(z)+0.1)*(1.0+sin(tim*0.1)),z);\n#endif\n focalDistance=min(length(ro)+0.001,1.0);\n aperture=0.007*focalDistance;\n vec3 rd=lookat(-ro,vec3(0.0,1.0,0.0)-sin(ro)*0.1)*normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,2.0));\n vec3 rt=normalize(cross(vec3(0,1,0),rd)),up=cross(rd,rt);//just need to be perpendicular\n vec3 lightColor=vec3(1.0,0.5,0.25)+rd*.4;\n vec4 col=vec4(0.0);//color accumulator, .w=alpha\n vec2 D;\n float t=0.0,mld=100.0,od,d=1.,old,ld=100.,dt=0.,ot;//distance traveled, minimum light distance\n for(int i=1;i<72;i++){//march loop\n  if(col.w>0.9 || t>15.0)break;//bail if we hit a surface or go out of bounds\n  float rCoC=CircleOfConfusion(t);//calc the radius of CoC\n  od=D.x;old=D.y,dt=t-ot;ot=t;//save old distances for normal, light direction calc\n  D=DE(ro+rd*t);\n  d=D.x+0.33*rCoC;\n  ld=D.y;//the distance estimate to light\n  mld=min(mld,ld);//the minimum light distance along the march\n  if(d<rCoC){//if we are inside the sphere of confusion add its contribution\n   vec3 p=ro+rd*(t-dt);//back up to previos checkpoint\n   mcol=vec3(0.01);//collect color samples with normal deltas\n   vec2 Drt=DE(p+rt*dt),Dup=DE(p+up*dt);\n   vec3 N=normalize(rd*(D.x-od)+rt*(Drt.x-od)+up*(Dup.x-od));\n   if(N!=N)N=-rd;//if no gradient assume facing us\n   vec3 L=-normalize(rd*(D.y-old)+rt*(Drt.y-old)+up*(Dup.y-old));\n   float lightStrength=1.0/(1.0+ld*ld*20.0);\n   vec3 scol=mcol*(0.2+0.4*(1.0+dot(N,L)))*lightStrength;//average material color * diffuse lighting * attenuation\n   scol+=pow(max(0.0,dot(reflect(rd,N),L)),8.0)*lightColor;//specular lighting\n   mcol=vec3(0);//clear the color accumulator before shadows\n   //scol*=FuzzyShadow(p,L,ld,shadowCone,rCoC);//now stop the shadow march at light distance\n   col.rgb+=lightColor/(1.0+mld*mld*5000.0)*(1.0-col.w);//add a bloom around the light\n   mld=100.0;//clear the minimum light distance for the march\n   float alpha=fudgeFactor*(1.0-col.w)*linstep(-rCoC,rCoC,-d);//calculate the mix like cloud density\n   col=vec4(col.rgb+scol*alpha,clamp(col.w+alpha,0.0,1.0));//blend in the new color \n  }//move the minimum of the object and light distance\n  d=abs(fudgeFactor*min(d,ld+0.33*rCoC)*(0.8+0.2*rand2()));//add in noise to reduce banding and create fuzz\n  t+=d;\n }//mix in background color and remaining bloom\n col.rgb+=lightColor/(1.0+mld*mld*5000.0)*(1.0-col.w);\n fragColor = vec4(clamp(col.rgb,0.0,1.0),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define bps 6.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n= 0.0; \n  else if(n<2.0)n= 2.0; \n  else if(n<3.0)n= -5.0; \n  else if(n<4.0)n= 5.0; \n  else if(n<5.0)n= -4.0; \n  else if(n<6.0)n= 4.0; \n  else if(n<7.0)n= 0.0; \n  else n=2.0;\n  return vec2(n,r); \n}\nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100;//pentatonic minor\n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//blues  \n //if((n2==1.)||(n2==2.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//country \n //if((n2==1.)||(n2==4.)||(n2==7.)||(n2==10.))note=-100.;//diminished whole/half \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//pentatonic major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//harmonic minor \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//melodic minor ascending \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//whole tone \n //if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian   \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//dorian \n if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==10.))note=-100.;//lydian   \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian Major \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//locrian \n //if((n2==2.)||(n2==4.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//lydian dominant \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//double harmonic \n //if((n2==2.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.))note=-100.;//enigmatic \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//neapolitan  \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//neapolitan minor \n //if((n2==1.)||(n2==4.)||(n2==5.)||(n2==9.)||(n2==10.))note=-100.;//hungarian minor \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n));\n} \nvec2 mainSound(int samps, float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(50.0,0.05,1.5,0.1,1.5,0.001);//silly fm synth instruments \n instr sitar=instr(10.0,1.,8.0,0.0,0.5,0.0025); \n //instr bassdrum=instr(500.0,1.0,4.0,0.76,1.0,0.5); \n instr stick=instr(100.0,30.0,10.5,0.0,2.3131,1000.0); \n //instr pluckbass=instr(500.0,2.0,1.5,0.0,0.125,0.005); \n instr bass=instr(20.0,0.2,2.0,0.0,0.5,0.005); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=vec2(0.0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.25)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+60.0,time,t0,sitar)*n0.y/(1.+abs(n0.x)*.25);\n   //if(mod(i,1.)<1.)a+=I(n0.x+93.0,time+Sin(t0*272.0),t0,stick)*n0.y;  \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i;\n     //a+=I(n1.x+67.0,time,t1,epiano)*n1.y;\n     a+=I(n1.x+64.,time,t1,epiano)*n1.y*.125; \n     a+=I(n1.x+60.,time,t1,epiano)*n1.y*.125; \n     //a+=I(n1.x+36.0,time,t1,pluckbass)*n1.y*4.0;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+48.0,time,t2,bass)*n2.y;\n       a+=I(n2.x+52.0,time,t2,bass)*n2.y;\n       a+=I(93.0,time+Sin(t2*272.0),t2,stick)*n2.y*.5;\n       //a+=I(n2.x+32.0,t2/bps+0.008*sin(t2*5.0),t2,bassdrum)*12.0;\n       //a+=I(n2.x+31.0,t2/bps+0.008*sin(t2*6.0),t2,bassdrum)*12.0;\n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/48.0,-1.,1.); \n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}