{
    "Shader": {
        "info": {
            "date": "1688842892",
            "description": "Glyphs from TOH\nhttps://theowlhouse.fandom.com/wiki/Glyph_Magic",
            "flags": 0,
            "hasliked": 0,
            "id": "mdsfD7",
            "likes": 4,
            "name": "TOH Glyph SDFs",
            "published": 3,
            "tags": [
                "sdf",
                "glyphs",
                "owlhouse",
                "toh"
            ],
            "usePreview": 0,
            "username": "fishy",
            "viewed": 125
        },
        "renderpass": [
            {
                "code": "#define csgInit() float r = 1e30\n#define csgEnd() return r\n#define csgUnion(d) r = min(r, d)\n#define csgMirrorX(p) vec2(abs(p.x), p.y)\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdRing(vec2 p, vec2 o, float r)\n{\n    return abs(distance(p, o) - r);\n}\n\nfloat sdPoint(vec2 p, vec2 o)\n{\n    return distance(p, o);\n}\n\nfloat sdPointedEggRing(vec2 p, vec2 o, float r, float h)\n{\n    return abs(p.y - o.y > 0.0? length(vec2(abs(p.x), p.y) - o + vec2(h, 0.0)) - (r+h) : length(p - o) - r);\n}\n\nfloat sdCubicBezier(vec2 uv, vec2 s, vec2 c1, vec2 c2, vec2 e, float res)\n{\n    float r = 1e20;\n    float st = 1./res;\n    vec2 prev = s;\n    for(float i = 0.; i < 1.; i += st)\n    {\n        float j = 1.-i;\n        vec2 point = j*j*j*s+3.*j*j*i*c1+3.*j*i*i*c2+i*i*i*e;\n        r = min(r, sdSegment(uv, prev, point));\n        prev = point;\n    }\n    r = min(r, sdSegment(uv, prev, e));\n    return r;\n}\n\nfloat sdGlpyh(vec2 uv, int type)\n{\n    csgInit();\n    csgUnion(sdRing(uv, vec2(0), 1.0));\n    switch(type)\n    {\n        case 0:\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, 1), vec2(0.15, 0.7)));\n            csgUnion(sdRing(uv, vec2(0, 0.66), 0.154));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, 0.506), vec2(0.953, -0.3)));\n            csgUnion(sdSegment(uv, vec2(0.953, -0.3), vec2(-0.953, -0.3)));\n            csgUnion(sdSegment(uv, vec2(0, 0.506), vec2(0, -1)));\n            csgUnion(sdSegment(uv, vec2(-0.1, 0), vec2(0.1, 0.1)));\n            csgUnion(sdSegment(uv, vec2(-0.1, -0.1), vec2(0.1, 0)));\n            csgEnd();\n        case 1:\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, 1), vec2(0.4, 0.6)));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0.4, 0.6), vec2(0.0, -0.3)));\n            csgUnion(sdSegment(uv, vec2(0.953, -0.3), vec2(-0.953, -0.3)));\n            csgUnion(sdCubicBezier(csgMirrorX(uv), vec2(0.0, 0.2), vec2(0.2, 0.2), vec2(0.6, 0.1), vec2(0.97, -0.2), 8.0));\n            csgUnion(sdSegment(uv, vec2(0, 1), vec2(0, -0.3)));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, -0.3), vec2(0.15, -0.45)));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0.15, -0.45), vec2(0, -0.6)));\n            csgEnd();\n        case 2:\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, -0.2), vec2(0.25, 0.05)));\n            csgUnion(sdRing(uv, vec2(0, -0.5), 0.3));\n            csgUnion(sdPoint(uv, vec2(0, -0.5)));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, 0.4), vec2(0.25, 0.65)));\n            csgUnion(sdSegment(uv, vec2(0.1, 0.5), vec2(-0.1, 0.5)));\n            csgUnion(sdSegment(uv, vec2(-0.25, 0.65), vec2(0.25, 0.65)));\n            csgUnion(sdSegment(uv, vec2(0, -0.2), vec2(0, 0.4)));\n            csgEnd();\n        case 3:\n            csgUnion(sdPointedEggRing(uv, vec2(0.0, -0.5), 0.5, 0.95));\n            csgUnion(sdRing(uv, vec2(0.0, -0.5), 0.5));\n            csgUnion(sdPoint(uv, vec2(0.0, -0.5)));\n            csgUnion(sdPointedEggRing(uv, vec2(0.0, 0.3), 0.3, 0.65));\n            csgUnion(sdRing(uv, vec2(0.0, 0.3), 0.3));\n            csgEnd();\n    }\n        \n}\n\nfloat map(vec2 uv)\n{\n    return sdGlpyh(uv, int(iTime) % 4);\n}\n\nvec3 colorSdf(vec2 uv, vec4 m)\n{\n    #define PERIOD 200.\n    #define STR 0.2\n    #define STROKE_WIDTH 0.01\n    #define MOUSE_WIDTH 0.005\n    float d = map(uv);\n    float px = fwidth(d);\n    float md = abs(map(m.xy));\n    vec3 col = mix(vec3(0.094,0.494,0.988), vec3(1.000,0.082,0.980), sign(d)*0.5+0.5);\n    col *= smoothstep(-px*PERIOD, px*PERIOD, cos(d*PERIOD))*STR+1.-STR;\n    col = mix(col, vec3(1), smoothstep(STROKE_WIDTH+px, STROKE_WIDTH-px, abs(d)));\n    if(m.z > 0.)\n    {\n        float mdc = smoothstep(px, -px, min(abs(distance(m.xy, uv)-md+MOUSE_WIDTH)-MOUSE_WIDTH, distance(m.xy, uv)-MOUSE_WIDTH*2.));\n        col = mix(col, vec3(1.000,0.875,0.000), mdc);\n    }\n    col /= d+1.;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec4 m = vec4((iMouse.xy*2.-iResolution.xy)/iResolution.y, iMouse.zw);\n    float px = 2.0/iResolution.y;\n\n    vec3 col = vec3(colorSdf(uv*1.2, m*1.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}