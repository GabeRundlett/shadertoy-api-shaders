{
    "Shader": {
        "info": {
            "date": "1455792197",
            "description": " application of Fourier workflow  https://www.shadertoy.com/view/4dGGz1\nLook in full screen ! ",
            "flags": 32,
            "hasliked": 0,
            "id": "4dG3zd",
            "likes": 35,
            "name": "electric flare",
            "published": 3,
            "tags": [
                "fft",
                "fourier",
                "dft"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1646
        },
        "renderpass": [
            {
                "code": "// application of https://www.shadertoy.com/view/4dGGz1\n\n\n#define SIZE (iResolution.x/2.-30.) //Size must be changed in each tab.\n\nvoid mainImage( out vec4 O,  vec2 U )\n{    \n    vec2 R = iResolution.xy;\n    U = ( U - R/2.);\n    vec2 uv = mod(U,SIZE)/ R;\n    O = length(texture(iChannel2, uv).xy) *vec4(1.3,.5,.3,0); // indeed, is abs(texture.x)\n    O /= length (U/R.y);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// do your operation in spectral domain here\n\n#define SIZE (iResolution.x/2.-30.) //Size must be changed in each tab.\n\nfloat rand(vec2 uv) { return fract(1e5*sin(dot(uv,vec2(17.4,123.7)))); }     // point -> rnd [0,1[\nfloat gauss(float x) { return exp(-.5*x*x); }\n#define ang(a)  vec2(cos(a), sin(a))                         // used to set the complex exp(i.a)\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } // complex a*exp(i.b)\n\nfloat _x;\n#define tri(x) min(_x=mod(x,2.), 2.-_x)\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{    \n    vec2 R = iResolution.xy;\n    U -= .5;  // freq 0 must exist\n    \n    U = 2.*U-SIZE;\n    vec2 X = U/SIZE, T,\n         M = 2.*iMouse.xy/R-1.;\n    float I=1., l = length(X), F, s = sign(-X.x); // s to help making a symmetric spectrum (phases included !)\n    \n    \n    // --- your custom Fourier-space function here ------------\n#define PROF  32 // spectrum profile ( = Fourier modulus)\n#define PHASE 3  // spectrum phases\n    \n#if 0 // 0:  scale shape at zoom    1: scale fourier at zoom\n    X *= SIZE/256.;  l *= SIZE/256., I *= SIZE/256.; \n#endif    \n    \n                                     // --- modulus profile here\n#if PROF==0\n    F = 1.;                                     // flat\n#elif PROF==1\n    F = gauss(l/.05)*10.;                       // gauss\n#elif PROF==2\n    float l1 = length(X-vec2(.07,0)),\n          l2 = length(X+vec2(.07,0));  \n    F = ( gauss(l1/.02)+gauss(l2/.02) )*10.;    // bi-lobe\n  //l1 = length(X-vec2(.1,.05)),\n  //l2 = length(X+vec2(.1,.05)); \n  //F += ( gauss(l1/.015)+gauss(l2/.015) )*5.;  // additionnal bi-lobe\n#elif PROF==3\n    F = gauss(abs(l-.12)/.005)*10.;             // ring (blue noise)\n#elif PROF==31\n    F = gauss(abs(l-.22)/.002)*10.;             // variant\n#elif PROF==32\n    F = gauss(abs(l-.32-.1*tri(.05*iTime))/.002)*10.;             // variant\n#elif PROF==4\n    F = gauss(abs(l-.12)/.007)*10.*gauss(length(X*vec2(.1,1))/.03)*3.;  \n#endif\n \n                                     // --- phases here\n  //vec2 P = ang(6.2832*rand(U));               // default: random phases\n    vec2 P = ang(6.2832*rand(X*s)*s);           // with phase symmetry\n#if PHASE==0\n    T = vec2(1,0);                              // no phases ( all 0 )\n#elif PHASE==1\n    T = P;                                      // random phases\n#elif PHASE==20\n    T = ang(6.2832*length(30.*X));              // correlated phase: linear \n#elif PHASE==21\n    T = ang(6.2832*length(sin(30.*X)));         // correlated phase\n#elif PHASE==212\n    T = ang(6.2832*length(sin(100.*M*X)));          // variant with mouse gain\n#elif PHASE==3\n    T = cmul(P,2.*iTime*s);               // phase shift with time   \n#endif\n    \n    \n    O = vec4(T*F,0,0)*sqrt(I); //  *SIZE;  \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// invFourier transform \n\n// Horizontal + Vertical Discrete Fourier Transform of the input \n// 2 passes pipelined : in -> buf.zw -> buf.xy -> out\n// ( adapted from  Flyguy's https://www.shadertoy.com/view/MscGWS# )\n\n\n#define SIZE (iResolution.x/2.-30.) //Size must be changed in each tab.\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x)*vec2(cos(b), sin(b)); } // complex a*exp(i.b)\n#define W(uv)   mod(uv+SIZE/2.,SIZE)                    // wrap [-1/2,1/2] to [0,1]\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O-=O; \n    \n    if(U.x > SIZE || U.y > SIZE) return;\n\n    for(float n = 0.; n < 1000.; n++)  {\n        if (n>=SIZE) break;\n        float m = W(n);       // W to warp 0,0 to mid-window.\n        vec2 xn = texture(iChannel0, vec2(m+.5, U.y) / iResolution.xy).xy,\n             yn = texture(iChannel1, vec2(U.x, m+.5) / iResolution.xy).zw,\n             a =  6.2831853 *  W(U-.5) * n/SIZE;\n        \n        O.zw += cmul(xn, a.x);\n        O.xy += cmul(yn, a.y);\n    }\n    \n    O.zw /= SIZE;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}