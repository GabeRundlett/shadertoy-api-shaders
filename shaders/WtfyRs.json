{
    "Shader": {
        "info": {
            "date": "1592737336",
            "description": "A mod of TGlad's SphereTree fractal based on a mclarekin frag.",
            "flags": 0,
            "hasliked": 0,
            "id": "WtfyRs",
            "likes": 12,
            "name": "SphereTreeBulb",
            "published": 3,
            "tags": [
                "spheretree"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 380
        },
        "renderpass": [
            {
                "code": "//TGlad's SphereTree fractal mod by eiffie of a mclarekin DE\n#define rez iResolution.xy\nvec3 mcol=vec3(0.0);\n#define dot2(a) dot(a,a)\nfloat InvSc=.4,FF=0.95;\nbool bOutChk=false;\n// a mod of a mod of tglad's sphereTree distance estimation function from mclarekin then I simplified some \nfloat DE(vec3 p0) { \n  vec3 orbitTrap=vec3(1000);\n  vec4 p=vec4(p0,1.);\n  const float root3 = 1.732050807, root3d2 = 0.8660254, t = 0.53333334, M=2.15;  \n  const vec2 t1 = vec2(root3d2, -0.5), t2 = vec2(-root3d2, -0.5);\n  const mat2 mx=mat2(.8660254,.5,-.5,.8660254);//cos(sqrt(.75)) or pi/6\n  p.z=abs(p.z)+0.1725;//more sphere than tree now\n  for (int i = 0; i < 7; i++) {  \n    if(bOutChk){vec3 pC = p.xyz-vec3(0,0,t); if (dot(pC, pC) > t*t) break;} // definitely outside \n    float invSC = InvSc / dot(p.xyz,p.xyz); \n    p *= invSC;\n    p.z -= 1.0; \n    p.z *= -1.0;\n    p *= root3;\n    p.z=abs(p.z+.5)+.5;\n    p.xy=mx*p.xy;//rotate\n    // now modolu the space so we move to being in just the central hexagon, inner radius 0.5  \n    vec2 p2=mod(vec2(dot(p.xy,-t1.yx),dot(p.xy,-t2.yx))*M/root3,1.0); \n    if (p2.x + p2.y > 1.0) p2=vec2(1.)-p2; \n    p.xy = p2.x*t1 - p2.y*t2;\n    // fold the space to be in a kite \n    float l0 = dot2(p.xy), l1 = dot2(p.xy-t1), l2 = dot2(p.xy+t2); \n    if (l1 < min(l0,l2)) p.xy -= t1 * (2.0*dot(t1, p.xy) - 1.0); \n    else if (l2 < min(l0,l1)) p.xy -= t2 * (2.0 * dot(p.xy, t2) + 1.0); \n    p.z *= InvSc;\n    orbitTrap = min(orbitTrap, abs(p.xyz)); \n  }\n  if(mcol.x>0.)mcol+=vec3(1.0)+3.*(orbitTrap.zzx+orbitTrap.zyx);\n  float d = (length(p.xyz-vec3(0,0,0.4)) - 0.4); // the 0.4 is slightly more averaging than 0.5 \n  d = (sqrt(d + 1.0) - 1.) * 2.0; \n  return FF*d / p.w; \n} \n\nvec3 normal(vec3 p, float d){//from dr2\n  vec2 e=vec2(d,-d);vec4 v=vec4(DE(p+e.xxx),DE(p+e.xyy),DE(p+e.yxy),DE(p+e.yyx));\n  return normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w));\n}\nvec3 sky(vec3 rd, vec3 L){\n  float d=max(0.,0.4+0.6*dot(rd,L));\n  return pow(vec3(d*d*d*d,d*d*0.5,d-pow(d*d,10.0)),vec3(.2));\n}\nfloat rnd=0.;\nfloat rand(){rnd=fract((rnd+1.62340)*342.123);return rnd;}\nvoid randomize(in vec2 p){rnd=fract(float(iTime)+sin(dot(p,vec2(13.34,117.71)))*4231.76);}\n\nfloat ShadAO(in vec3 ro, in vec3 rd){\n float t=0.01*rand(),s=1.0,d,mn=0.01;\n for(int i=0;i<6;i++){\n  d=max(DE(ro+rd*t)*1.5,mn);\n  s=min(s,d/t+t*0.5);\n  t+=d;\n }\n return s;\n}\nvec3 scene(vec3 ro, vec3 rd){\n  float t=DE(ro)*rand(),d,od=1.,px=1.0/rez.y;\n  vec4 edge=vec4(0,0,-1,-1);\n  for(int i=0;i<199;i++){\n    d=DE(ro+rd*t);\n    if(d<px*t*t*.5 && d>od){if(edge.x<0.){edge=vec4(edge.yzw,t);break;}else {edge=vec4(edge.yzw,t);t+=px*t*t;}}\n    t+=d;od=d;\n    if(t>10.0)break;\n  }\n  if(d<px*t*t*.5)edge=vec4(edge.yzw,t);\n  vec3 L=vec3(0,0,1);\n  vec3 col=sky(rd,L);\n  for(int i=0;i<4;i++){\n    if(edge.w>0.){//valid distance, color back to front\n      mcol=vec3(0.01);\n      float d=DE(ro+rd*edge.w);\n      if(d<0.)d*=2.;\n      vec3 so=ro+rd*(edge.w+d);\n      vec3 N=normal(so,px*edge.w);\n      vec3 scol=mcol*0.2;\n      float dif=0.5+0.5*dot(N,L);\n      float vis=clamp(dot(N,-rd),0.05,1.0);\n      float fr=pow(1.-vis,5.0);\n      float shad=ShadAO(so,L);\n      col=mix((scol*dif+fr*sky(reflect(rd,N),L))*shad,col,clamp(0.8*d/(px*edge.w*edge.w*.5),0.,1.));\n    }\n    edge=edge.wxyz;\n  }\n  return col;\n}\nmat3 lookat(vec3 fw){fw=normalize(fw);vec3 up=vec3(0,0,1);vec3 rt=normalize(cross(fw,up));\n  return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage(out vec4 O, in vec2 U){\n  vec2 uv=vec2(U-0.5*rez)/rez.x;\n  randomize(U);\n  float t=iTime;\n  vec3 ro=vec3(cos(t),sin(t*1.1),0.5+0.5*sin(t*.7));\n  vec3 rd=lookat(-ro)*normalize(vec3(uv.xy,1.0));\n  t=mod(t,60.);\n  if(t<20.){InvSc=.5;FF=0.75;bOutChk=true;}\n  else if(t<40.){InvSc=1.;FF=0.45;bOutChk=true;}\n  O=vec4(scene(ro,rd),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}