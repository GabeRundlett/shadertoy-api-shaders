{
    "Shader": {
        "info": {
            "date": "1551726388",
            "description": "rotation of twisted space without tangling up.\nsaw this on twitter (i guess paul dirac invented it for describing electron spin)\nhttps://twitter.com/lexfridman/status/1101871948664049664",
            "flags": 0,
            "hasliked": 0,
            "id": "WdfXz2",
            "likes": 37,
            "name": "spinor rotation",
            "published": 3,
            "tags": [
                "rotation",
                "spin",
                "dirac"
            ],
            "usePreview": 0,
            "username": "flockaroo",
            "viewed": 1157
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//...saw this on twitter and had to give it a try on shadertoy.\n// https://twitter.com/lexfridman/status/1101871948664049664\n// original author of the above video seems to be Jason Hise\n// https://en.wikipedia.org/wiki/File:Belt_Trick.ogv\n\n//rotation of locally twisted space without tangling up.\n//i guess paul dirac invented it for describing electron spin\n//needs 720 degrees!!! for one full period\n\n#define PI2 6.28318530718\n\n// inigo quilez's box distance\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nvoid ROT(float ang,inout vec2 v) \n{ \n    vec2 cs=sin(vec2(1.6,0)+ang); \n    v=mat2(cs,cs.yx*vec2(-1,1))*v;\n}\n\nfloat getDist(vec3 p)\n{\n    float d=10000.;\n    //float falloff=clamp(1./(1.+.025*max(0.,dot(p,p))),0.,1.);\n    float falloff=1.-(smoothstep(1.,15.,length(p)));\n    \n    //float ang=(iMouse.xy/iResolution.xy*PI2).x;\n    float ang=iTime;\n    \n    // those 3 lines are the core part\n    // ...remove them and you'll just have 3 boring sticks and a cube ;-)\n    ROT(-ang,p.xy);             // globally rotate around z\n    ROT(PI2*.5*falloff,p.yz);   // locally rotate around x by 180 degrees\n    ROT(ang,p.xy);              // globally rotate back around z \n\n    d=min(d,sdBox(p,vec3(1)));\n    d=min(d,sdBox(p,vec3(.1,.8,100)));\n    d=min(d,sdBox(p,vec3(100,.1,.8)));\n    d=min(d,sdBox(p,vec3(.8,100,.1)));\n    return d;\n}\n\nvec3 getGradDist(vec3 pos,float eps)\n{\n    vec3 d=vec3(eps,0,0);\n    return vec3(\n        getDist(pos+d.xyz)-getDist(pos-d.xyz),\n        getDist(pos+d.zxy)-getDist(pos-d.zxy),\n        getDist(pos+d.yzx)-getDist(pos-d.yzx)\n        )/eps/2.;\n}\n\nbool march(inout vec3 pos, inout vec3 dir)\n{\n    float eps = .0001;\n    float mat=-1.;\n    for(int i=0;i<250;i++)\n    {\n        float d=getDist(pos);\n        pos+=dir*d*.25;\n        if(d<eps) { return true; }\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float camDist=60.;\n    vec3 camDir = vec3(0,1,0);\n    vec3 dir = normalize(camDir+vec3((fragCoord-.5*iResolution.xy)/iResolution.x,0).xzy);\n    vec2 ang = vec2(.4,-.2);\n    //if(iMouse.x<.5) ang += vec2(iTime,iTime*.3);\n    ang += iMouse.xy/iResolution.xy*PI2;\n    ROT(ang.y,camDir.yz);\n    ROT(ang.x,camDir.xy);\n    ROT(ang.y,dir.yz);\n    ROT(ang.x,dir.xy);\n    vec3 pos=-camDir*camDist;\n    vec3 camPos = -camDir*10.;\n    bool hit=march(pos,dir);\n    vec3 n = getGradDist(pos,.001);\n    fragColor=vec4(n*.5+.5,1);\n    if (!hit) fragColor=vec4(.1,.2,.3,1);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}