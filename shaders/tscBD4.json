{
    "Shader": {
        "info": {
            "date": "1606924504",
            "description": "A shader to accompany this beautiful song from Thomas Barrandon\nhttps://youtu.be/OhLHmHP4Gv8",
            "flags": 96,
            "hasliked": 0,
            "id": "tscBD4",
            "likes": 8,
            "name": "Clip - Thomas Barrandon - Fledge",
            "published": 3,
            "tags": [
                "music",
                "retrowave"
            ],
            "usePreview": 0,
            "username": "z0rg",
            "viewed": 434
        },
        "renderpass": [
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat songDuration = 314.;\nfloat fadeInOut = 2.;\n\nvec3 dirBlur(vec2 uv, float lvl)\n{\n    vec3 col;\n    int cnt = 8;\n    float fcnt = float(cnt);\n    float acc;\n    for (int i = 0; i < cnt; ++i)\n    {\n        float fi = float(i);\n   \t\tfloat pct = sat(fi/fcnt);\n        float k = (1.-pct);\n        \n        vec3 rgb = texture(iChannel0, (uv-.5)*(1.+lvl*pct)+.5).xyz;\n        \n        col += rgb*k;\n        acc +=k;\n    }\n    return col/acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n    float beat = sin(iTime*PI*16.);\n    float blur = 0.04;\n    if (iTime> 82.5 && iTime < 256.)\n        blur *= beat;\n    \n    col = dirBlur(uv, blur);\n    \n    col *= sat((iTime)/fadeInOut);\n\tcol *= 1.-sat((iTime-310.)/fadeInOut);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// https://youtu.be/OhLHmHP4Gv8\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0., 1., 0.)));\n    vec3 u = normalize(cross(r, rd));\n    \n    return normalize(rd + r* uv.x + u *uv.y); \n}\n\nvec2 add(vec2 a, vec2 b)\n{\n    return (a.x < b.x ? a : b);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 rep = vec2(.7);\n     vec2 sdUv = p.xz;\n    p.xz = mod(sdUv+rep*.5, rep)-rep*.5;\n    ivec2 ip = ivec2(((sdUv+rep*.5) / rep));\n    \n    float sz = 0.15*(sin(float(ip.x))*.2+.5);\n\n    \n    float ht = .5*texelFetch(iChannel0, ivec2(int(length(vec2(ip))*20.), 0), 0).x+.2*(1.+length(vec2(ip)*.15))+(1.+length(vec2(ip.xy))*.2)*2.*abs(sin(10.*sin(float(ip.x))*float(ip.y)+5.*float(ip.x*5)+iTime)*0.1);\n    vec2 ground = vec2(p.y, -1.0);\n    vec2 buildings = vec2(sdBox(p, vec3(sz, ht, sz)), sat(ht));\n    vec2 buildings2 = vec2(sdBox(p, vec3(sz, ht, sz)), sat(ht));\n    return add(ground, add(buildings, buildings2));\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy).x - map(p-h.xyy).x,\n                           map(p+h.yxy).x - map(p-h.yxy).x,\n                           map(p+h.yyx).x - map(p-h.yyx).x ) );\n}\n\nvec3 rdr(vec2 uv, vec3 ro, vec3 rd)\n{\n\tvec3 col;\n\n    float lightAcc;\n    float d = 0.0001;\n    vec3 p;\n    for (int i = 0; i < 200 && d < 50.; ++i)\n    {\n        p = ro+rd*d;\n        vec2 res = map(p);\n\t\t//lightAcc += res.x*.1;\n        if (abs(res.x) < 0.0001*d)\n        {\n            vec3 n = calcNormal(p);\n            //col += n*.5+.5;\n\n            vec3 lPos = vec3(1.*sin(iTime),2.,2.*cos(iTime*.5));\n            float power = 1.-sat(distance(lPos, p)/10.);\n            vec3 lDir = normalize(lPos-p);\n            col += vec3(.9,.7,.3)*pow(sat(dot(lDir, n)), 5.)*power; // diffuse\n            vec3 h = normalize(lDir-rd);\n            col += vec3(.5,.2,.8)*pow(sat(dot(h, n)), 5.)*2.*power;\n            \n                   col += /*lightAcc**/vec3(.2,.3,.4)*d*.01;\n            if (dot(n, vec3(0.,1.,0.)) > 0.)\n            col += 5.5*vec3(.2,.1,.7)*(1.-sat(2.*sin(2.*-iTime+length(p.xz*.5))));\n\t\t\tcol *= 1.-sat(d/20.);\n            col += 2.*(n*.5+.5)*(1.-sat(p.y/res.y));\n            float gridSp = 25.;\n            float gridSz = .8;\n \t\t\tif (res.y < 0.)\n                col = col.zxy * (.5+sat((sin(p.x*gridSp)-gridSz)*400.)*sat((sin(p.z*gridSp)-gridSz)*400.));\n            break;\n        }\n        \n        d+= res.x * .8;\n    }\n    col = col.zxy;\n    col *= vec3(.5)*(1.-sat(d/20.));\n    col += (rd.y*.5)*vec3(.1,.45,.32);\n    col += (1.-sat(abs(rd.y*5.)))*vec3(0.4,0.2,0.5)*1.5*(1.-sat(abs(rd.x)));\n    col += (1.-sat(abs(rd.x*3.)))*vec3(0.4,0.2,0.5);\n    col *= 1.-sat((lenny(uv)-.5)*5.);\n    col = vec3(sat(col.x),sat(col.y), sat(col.z));\n    col += vec3(.1,.12,.2)*.5*pow(sat(d/20.),.6);\n    col += (1.-sat(lenny(uv*.2)))*texelFetch(iChannel0, ivec2(5,0),0).x*vec3(.5,.3,.6);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    uv.y *= cos(uv.x*3.14159265*.5);\n\tvec3 acc;\n    float accV;\n\n    int aaLvl = 5;\n    for (int i = 0; i<aaLvl; ++i)\n    {\n    \tfloat dist = mix(2., 20., sin(iTime*.2)*.5+.5);\n    \tfloat spinSpd = 0.2;\n        float off = float(i)*0.001*length(uv*5.);\n\n            // Time\n            if (iTime > 9.3) spinSpd *= -1.;\n        \tif (iTime > 27.5) spinSpd *= -1.;\n        \tif (iTime > 45.8) spinSpd *= -1.;\n\tif (iTime > 68.7) spinSpd *= -1.;\n            if (iTime > 73.5) spinSpd *= -1.;\n        if (iTime > 78.) spinSpd *= -1.;\n        \n        if (iTime > 96.) spinSpd *= -1.;\n        if (iTime > 101.) spinSpd *= -1.;\n        \n        if (iTime > 114.) spinSpd *= -1.;\n        if (iTime > 119.) spinSpd *= -1.;\n        if (iTime > 155.5) spinSpd *= 0.;\n        if (iTime > 165.) spinSpd = 0.2;\n        if (iTime > 183.) spinSpd *= -1.;\n        if (iTime > 192.) spinSpd *= -1.;\n        if (iTime > 196.5) spinSpd *= -1.;\n        if (iTime > 201.) spinSpd *= -1.;\n        if (iTime > 210.5) spinSpd *= -1.;\n        if (iTime > 224.) spinSpd *= -2.;\n        if (iTime > 229.) spinSpd *= -2.;\n        if (iTime > 233.) spinSpd *= -2.;\n        if (iTime > 238.) spinSpd = 0.2;\n        if (iTime > 256.) spinSpd *= 0.;\n        if (iTime > 270.) spinSpd = 0.1;\n        if (iTime > 274.5) spinSpd *= -1.;\n        if (iTime > 279.) spinSpd *= -1.;\n        if (iTime > 283.5) spinSpd *= -1.;\n        if (iTime > 288.) spinSpd *= -1.;\n            //\n    \tvec3 ro = vec3(dist*sin(spinSpd*iTime+off), mix(1.,3.,sat(sin(iTime*spinSpd)*.5+.5)), dist*cos(spinSpd*iTime+off));\n    \tvec3 ta = vec3(0., 1., 0.);\n    \tvec3 rdo = normalize(ta-ro);\n    \tvec3 rd = getCam(rdo, uv);//+aa[i]/(iResolution.xx));\n    \tfloat aaV = 1.;//1.-sat(length(uv)*.5);\n    \tvec3 col = rdr(uv, ro, rd)*aaV;\n        //vec3 rd2 = getCam(rdo, uv*(1.-float(i)/400.));\n        vec3 colBlur = col*aaV*3.;//rdr(uv, ro, rd2)*aaV*3.;\n        accV+= aaV*2.;\n\t\tacc += col+colBlur;\n    }\n    vec3 col =acc/accV;\n    \n    vec3 col2 = mix(fwidth(length(col))*col, col, 1.-sat(lenny(uv*vec2(3.,1.))));\n    col2 = pow(col2,vec3(1.15));\n    \n    float sndVal = texelFetch(iChannel0, ivec2(int((uv.x+.5)*15.),0),0).x;\n    if (iTime > 82.7)\n    col2 = mix(col2.yzx, col2,sat(sndVal*2.-1.));\n    fragColor = vec4(col2,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 24562,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/thomasbarrandon/fledge"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\nfloat lenny(vec2 v)\n{\n\treturn abs(v.x) + abs(v.y);    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}