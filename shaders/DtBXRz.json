{
    "Shader": {
        "info": {
            "date": "1675630347",
            "description": "My first shader which uses a buffer to do some post processing. Applying some sobel and gaussian effects to a warped repeated geometry.",
            "flags": 32,
            "hasliked": 0,
            "id": "DtBXRz",
            "likes": 2,
            "name": "Edgy Hallway",
            "published": 3,
            "tags": [
                "raymarching",
                "postprocessing",
                "edge",
                "repeatinggeometry"
            ],
            "usePreview": 0,
            "username": "frettini",
            "viewed": 182
        },
        "renderpass": [
            {
                "code": "#define AA 2\n\n// Post Processing Kernels ----------------------------------------\nmat3 sobelY = mat3(-1.,0.,1.,\n                   -2.,0.,2.,\n                   -1.,0.,1.);\n                  \nmat3 sobelX = mat3(-1.,-2.,-1.,\n                    0.,0.,0.,\n                    1.,2.,1.);\n\nmat3 gaussian = 0.0625 * mat3(1.,2.,1.,\n                              2.,4.,2.,\n                              1.,2.,1.);\n                             \n// Post Processing Functions --------------------------------------                      \nfloat SobelFilter(vec2 fragCoord)\n{\n    float sumX = 0.;\n    float sumY = 0.;\n    float sumNormX = 0.;\n    float sumNormY = 0.;\n \n\n    for(int i = -1; i <= 1; i++)\n    for(int j = -1; j <= 1; j++)\n    {\n        vec2 uvOffset = (fragCoord + vec2(i , j))/iResolution.xy;\n        sumX += sobelX[i+1][j+1] * texture(iChannel0, uvOffset).r;\n        sumY += sobelY[i+1][j+1] * texture(iChannel0, uvOffset).r;\n        sumNormX += dot( sobelX[i+1][j+1] * texture(iChannel0, uvOffset).gba, vec3(1.,1.,1.) );\n        sumNormY += dot( sobelY[i+1][j+1] * texture(iChannel0, uvOffset).gba, vec3(1.,1.,1.) );\n    }\n    \n    float filteredValue = step(1.-sqrt(sumX*sumX + sumY*sumY),0.3);\n    filteredValue = step(1.-sqrt(sumNormX*sumNormX + sumNormY*sumNormY),0.3);\n    return filteredValue;\n}\n\nfloat GaussianFilter(vec2 fragCoord)\n{\n    float sumGaussian = 0.;\n    \n    for(int i = -1; i <= 1; i++)\n    for(int j = -1; j <= 1; j++)\n    {\n        vec2 uvOffset = (fragCoord + vec2(i , j))/iResolution.xy;\n        sumGaussian += gaussian[i+1][j+1] * texture(iChannel0, uvOffset).r, vec3(1.,1.,1.);\n    }\n    \n    return sumGaussian;\n}\n// ----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 result = vec3(0.);\n    \n#if AA>1\n    for(int hOffset = 0; hOffset < AA; hOffset++)\n    for(int vOffset = 0; vOffset < AA; vOffset++)\n    {\n\n        vec2 pixelOffset = vec2(float(hOffset), float(vOffset)) / float(AA) - 0.5;\n        // Normalized pixel coordinates (from -1.0 to 1.0)\n        vec2 uv = ((fragCoord + pixelOffset)*2.0 - iResolution.xy)/iResolution.y;\n#else\n        vec2 uv = (fragCoord*2.0 - iResolution.xy)/iResolution.y;\n#endif\n      \n        vec3 chromaOffset = vec3(-2.5 + cos(uv.y*1.+iTime*3.)*2. + sin(uv.y+iTime*5.)*0.8, \n                            cos(uv.y+iTime*3.)*1. + sin(uv.y+iTime*5.)*0.8, \n                            2.5 + sin(uv.y*4.+iTime*1.)*1.5 - cos(uv.x*1.+iTime*4.)*1.) ;\n\n        vec3 col = vec3(0.);\n        \n        // Apply post processing filters\n        col.x = GaussianFilter( fragCoord * vec2(1.01,1.) + vec2(chromaOffset.x, 0.) );\n        col.y = SobelFilter( fragCoord + vec2(chromaOffset.y, 0.) );\n        col.z = GaussianFilter( fragCoord * vec2(1.01,1.) + vec2(chromaOffset.z, 0.) );\n\n        float gaussFactor = abs(col.x-col.z);\n        float sobelFactor = col.y; \n        col = vec3(6. * gaussFactor * vec3(0.6, 0.8, 1.) + 0.04 * sobelFactor * vec3(1., 1.,1.));\n        \n        result += col;\n#if AA>1\n    }\n    result /= float(AA*AA);\n#endif\n        \n    // Output to screen\n    fragColor = vec4(result,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define RAYMARCHSTEPS 100\n\n#define MATERIAL1 1\n#define MATERIAL2 2\n\n#define MINDIST 0.5\n#define MAXDIST 30.0\n\n#define AA 2\n\nstruct Hit\n{\n    float rayDist;\n    int matID;\n};\n\nmat3 LookAt(vec3 pos, vec3 target)\n{\n    vec3 forward = normalize(target - pos);\n    vec3 right = normalize(cross(forward,vec3(0.,1.,0.)));\n    vec3 up = normalize(cross(right, forward));\n        \n    return mat3(right,\n                up,\n                forward);\n}\n\n// OPERATIONs ----------------------------------------------------\nHit Union(Hit hit1, Hit hit2)\n{\n    if(hit1.rayDist < hit2.rayDist){ return hit1; }\n    else{ return hit2; }\n}\n\nHit Substract(Hit hit1, Hit hit2)\n{\n    if(-hit1.rayDist > hit2.rayDist){ return  Hit( -hit1.rayDist, hit1.matID ); }\n    else{ return hit2; };\n}\n\nHit Intersect(Hit hit1, Hit hit2)\n{\n    if(hit1.rayDist > hit2.rayDist){ return  hit1; }\n    else{ return hit2; };\n}\n\n\nHit SmoothUnion( Hit hit1, Hit hit2, float k ) \n{\n    Hit result;\n    float h = clamp( 0.5 + 0.5*(hit2.rayDist-hit1.rayDist)/k, 0.0, 1.0 );\n    result.rayDist = mix( hit2.rayDist, hit1.rayDist, h ) - k*h*(1.0-h); \n    result.matID = hit1.matID; // TODO : this s a simplification for now\n    return result;\n}\n\nHit SmoothIntersect( Hit hit1, Hit hit2, float k ) \n{\n    Hit result;\n    float h = clamp(0.5-0.5*(hit2.rayDist - hit1.rayDist)/k, 0.0, 1.0);\n    result.rayDist = mix(hit2.rayDist, hit1.rayDist, h) + k*h*(1.0-h);\n    result.matID = hit1.matID; // TODO : this is a simplification for now\n    return result;\n}\n\n// ---------------------------------------------------------------\n\n// SDFs ----------------------------------------------------------\n\nfloat SDPlane(vec3 pos, vec3 planeNormal, float planeHeight)\n{\n    // planeNormal must be normalized\n    return dot(pos, planeNormal) + planeHeight;\n}\n\nfloat SDSphere(vec3 pos, vec3 spherePos, float sphereRadius)\n{\n    return length(pos - spherePos) - sphereRadius;\n}\n\nfloat SDRoundedCube(vec3 pos, vec3 cubeOrigin, vec3 cubeExtent, float cubeRadius)\n{\n    vec3 q = abs(pos - cubeOrigin)  - cubeExtent;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - cubeRadius;\n}\n\nfloat SDRoundedPillar(vec3 pos, vec3 cubeOrigin, vec3 cubeExtent, float cubeRadius)\n{\n    vec3 q = abs(pos - cubeOrigin)  - cubeExtent;\n    return length(max(vec2(q.xz),0.0)) + min(max(q.x,q.z),0.0) - cubeRadius;\n}\n\nfloat SDSemiRingXY(vec3 pos, vec3 ringOrigin, float ringRadius, float ringThickness)\n{\n    vec3 localPos = pos - ringOrigin;\n    float dist =  abs(length( pos.xy - ringOrigin.xy ) - ringRadius) - ringThickness;\n    return max(-localPos.y,max(abs(localPos.z)-0.1, dist));\n}\n\nfloat SDSemiRingYZ(vec3 pos, vec3 ringOrigin, float ringRadius, float ringThickness)\n{\n    vec3 localPos = pos - ringOrigin;\n    float dist =  abs(length( pos.yz - ringOrigin.yz ) - ringRadius) - ringThickness;\n    return max(-localPos.y,max(abs(localPos.x)-0.1, dist));\n}\n\n// ---------------------------------------------------------------\n\n// from the position, return the distance and material of the closest object\nHit GetDistance(vec3 pos)\n{\n    // add vertical deformation\n    pos += sin(min(pos.y*1.5,10.) + iTime*0.4 )*0.1 * pos.y + cos(pos.x*pos.y)*0.1;\n     \n    // Geometry Definition \n    vec3 cubeOrigin = vec3(0., 0., 0.);\n    vec3 cubeExtent = vec3( 0.12, 0.1, 0.12);\n    float cubeRadius = 0.01;\n    \n    vec3 ringOriginXY =  vec3(0.5,0.75,0.);\n    vec3 ringOriginYZ =  vec3(0.,-0.25,0.5);\n    float ringRadius = 0.4;\n    float ringThickness = 0.075;\n    \n    vec3 planeNormal = vec3(0., 1., 0.);\n    float planeHeight = 0.;\n    \n    \n    // Repeat Coordinates\n    vec3 repeat1 = vec3(1., 0.0, 1.);\n    vec3 repeatCoord1 = mod(pos+0.5*repeat1,repeat1)-0.5*repeat1;\n    \n    vec3 repeat2 = vec3(2., 2.5, 2.);\n    vec3 repeatCoord2 = mod(pos+0.5*repeat2,repeat2)-0.5*repeat2;\n    \n    // SDF calculation starts here\n    Hit rayHit = Hit(MAXDIST,-1);\n    rayHit = Union( Hit(SDRoundedCube(repeatCoord1, cubeOrigin, vec3(0.15,0.05,0.15), cubeRadius), MATERIAL2), rayHit);\n    rayHit = SmoothUnion( Hit(SDRoundedPillar(repeatCoord1, cubeOrigin, cubeExtent, cubeRadius), MATERIAL2), rayHit,0.05);\n    \n    rayHit = Union( Hit(SDSemiRingXY(repeatCoord2, ringOriginXY, ringRadius, ringThickness), MATERIAL2), rayHit);\n    rayHit = Union( Hit(SDSemiRingXY(repeatCoord2, ringOriginXY*vec3(-1.,1.,1.), ringRadius, ringThickness), MATERIAL2), rayHit);\n    \n    rayHit = Union( Hit(SDSemiRingYZ(repeatCoord2, ringOriginYZ , ringRadius, ringThickness), MATERIAL2), rayHit);\n    rayHit = Union( Hit(SDSemiRingYZ(repeatCoord2, ringOriginYZ*vec3(1.,1.,-1.), ringRadius, ringThickness), MATERIAL2), rayHit);\n    \n    \n    rayHit = Union( Hit(SDPlane(pos, planeNormal, planeHeight), MATERIAL1), rayHit);\n    \n    return rayHit;\n}\n\n// using the specified ray, step through the ray and check against the SDF until the distance is small\n// enough to say that we have hit something.\nvoid Raymarch(vec3 rayOrigin, vec3 rayDirection, out Hit resultHit)\n{\n    float tmin = MINDIST;\n    float tmax = MAXDIST;\n    \n    float t = tmin;\n    for(int i = 0; i < RAYMARCHSTEPS && t < tmax; i++)\n    {\n        vec3 testPos = rayOrigin + rayDirection * t;\n        \n        Hit rayHit = GetDistance(testPos);\n        \n        // if distance is smaller than a given threshold, consider that a Hit\n        if(abs(rayHit.rayDist) < 0.001*t )\n        {\n            // return the distance along the ray and the material ID of what we Hit\n            resultHit = Hit(t, rayHit.matID);\n            break;\n        }\n        \n        t += rayHit.rayDist;\n    }\n}\n\n// from : https://iquilezles.org/articles/normalsSDF/\n// tetrahedon method to get the normal of a SDF\nvec3 GetNormal(vec3 pos)\n{\n    // trick the compiler to avoid inlining the Map function\n    #define ZERO (min(0, iFrame))\n    \n    float eps = 0.0001;\n    \n    vec3 normal = vec3(0.);\n    \n    for(int i = ZERO; i < 4 ; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        normal += e*GetDistance(pos+e*eps).rayDist;\n    }\n    \n    return normalize(normal);\n}\n\n\n// Once we know what we hit, we can start material calculations\nvec4 GetColour(vec3 rayOrigin, vec3 rayDirection, Hit rayHit)\n{\n    vec3 backgroundCol = vec3(0.15);\n    vec3 col = backgroundCol;\n    vec3 normal = vec3(0.);\n    \n    if(rayHit.matID > 0)\n    {\n        vec3 pos = rayOrigin + rayDirection * rayHit.rayDist;\n        \n        // PLANE\n        if(rayHit.matID == 1)\n        {\n            ivec2 gridCoord = ivec2(floor(mod(pos.xz, 2.)));\n            col =  gridCoord.x == gridCoord.y ? vec3(0.2) : vec3(0.6);\n            normal = vec3(0.,1.,0.);\n            \n        }\n        // MATERIAL2\n        else if(rayHit.matID == 2)\n        {\n            normal = GetNormal(pos);\n            vec3 reflect = reflect(rayDirection, normal);\n            \n            \n            col = vec3((normal + 1.0)/2.0);\n            \n            // some kind of lighting\n            vec3 dirLightCol = vec3( 0.99,0.95,0.1);\n            vec3 dirLightDir = normalize(vec3(-0.5, -1.0,0.));\n            float dirLightIntensity = 4.0;\n            col *= dot(normal, -dirLightDir) * dirLightCol;   \n        }\n        \n#if 0\n        float absorptionCoef = 0.08;\n        float transmittance = exp( - absorptionCoef * rayHit.rayDist);\n        col = (1.0 - transmittance) * backgroundCol + transmittance * col;\n#else  \n        // smooth out things in the background ( could use beer lambert law but makes everything a bit darker)\n        float normDist = rayHit.rayDist / MAXDIST;\n        float smoothDist = smoothstep(0.2,1.0, normDist);\n        col = mix(col, backgroundCol, smoothDist);\n#endif\n    }\n    \n    float luminance = dot(col,vec3(0.2126, 0.7152, 0.0722));\n    \n    // IMPORTANT : we are not returning a color, encoding grayscale and Normal instead\n    return vec4(luminance, normal);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float modTime = -mod( iTime*0.2,50.);\n    float focalDistance = 1.5;\n    vec3 rayOrigin = vec3(0.5,0.2,2.0 + modTime);\n    vec3 rayTarget = vec3(0.5 + cos(iTime*0.2)*0.9 + cos(iTime*0.09), \n                          sin(0.7*iTime)*0.1 + 0.5, \n                          0.7+modTime + cos(iTime*0.1 + 3.)*1.);\n    \n    mat3 lookAt = LookAt(rayOrigin, rayTarget);  \n    \n    vec4 result = vec4(0.);\n    \n#if AA>1\n    for(int hOffset = 0; hOffset < AA; hOffset++)\n    for(int vOffset = 0; vOffset < AA; vOffset++)\n    {\n\n        vec2 pixelOffset = vec2(float(hOffset), float(vOffset)) / float(AA) - 0.5;\n        // Normalized pixel coordinates (from -1.0 to 1.0)\n        vec2 uv = ((fragCoord + pixelOffset)*2.0 - iResolution.xy)/iResolution.y;\n#else\n        vec2 uv = (fragCoord*2.0 - iResolution.xy)/iResolution.y;\n#endif\n      \n        // Get the ray direction by building the ray in camera space and transforming it using the lookAt matrix\n        vec3 cameraRayDir =  normalize( vec3(uv, focalDistance) );\n        vec3 rayDirection = normalize(lookAt * cameraRayDir);\n\n        Hit rayHit = Hit(MAXDIST, -1);\n        Raymarch( rayOrigin, rayDirection, rayHit);\n        vec4 data = GetColour(rayOrigin, rayDirection, rayHit);\n        \n        result += data;\n#if AA>1\n    }\n    result.x /= float(AA*AA);\n    result.gba = normalize(result.gba);\n#endif\n    \n    \n    // Output to screen\n    fragColor = result;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}