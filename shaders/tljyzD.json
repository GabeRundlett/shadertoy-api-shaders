{
    "Shader": {
        "info": {
            "date": "1593944555",
            "description": "Thanks to spalmer, who find cause of CE",
            "flags": 32,
            "hasliked": 0,
            "id": "tljyzD",
            "likes": 1,
            "name": "Path",
            "published": 3,
            "tags": [
                "procedural",
                "2d"
            ],
            "usePreview": 0,
            "username": "Arseny",
            "viewed": 289
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    //fragColor = vec4(col.rgb, 1.);\n    fragColor = col;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define eps (0.003)\n\n\n#define red (vec4(1., 0., 0., 1.))\n#define green (vec4(0., 1., 0., 1.))\n#define blue (vec4(0., 0., 1., 1.))\n#define pi (acos(-1.))\n\n\nfloat k = 2.; // chage scale\nfloat parts = 6.;\nfloat lineWidth = 0.02; // no more than 0.02 with k * parts > 8 else some artefacts\n\n//----------https://www.shadertoy.com/view/4djSRW\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n    p *= 532.152;\n    p += 50.;\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#define flr(x, a) (floor((x) * (a)) / (a))\n\n#define frct(x, a) (fract((x) * (a)) / (a))\n\nvec4 get(vec2 uv){\n    return texture(iChannel0, uv);\n}\n\nvec2 to01(vec2 uv){\n    return (uv * iResolution.y) / iResolution.xy / 2. + 0.5;\n}\n\nvec2 PathId(vec2 uv, vec2 pathType){\n    float ansy = flr(uv.y, parts * k);\n    float ansx = flr(uv.x + pathType.x * pathType.y * (uv.y - flr(uv.y, parts * k) - 0.5 / parts / k) / 2.41, parts * k );\n    ansy = flr(uv.y + pathType.y * pathType.x * (uv.x - flr(uv.x, parts * k) - 0.5 / parts / k) / 2.41, parts * k );\n    return vec2(ansx, ansy) * parts * k;\n}\n\nvec2 IdToCenter(vec2 id){\n    return (id + 0.5) / parts / k;\n    //return (id + vec2(id.y * 5. / 8.)) / parts / k;\n}\n\nvec2 IdToLeftCntr(vec2 id){\n    return (id + vec2(0., 0.5)) / parts / k;\n}\n\nbool lesseq(vec2 ida, vec2 idb){\n    return (ida.x <= idb.x && ida.y <= idb.y);\n}\n\nvec2 to(vec2 id, vec2 beg, vec2 end){\n    vec2 sz = abs(end - id);\n    vec2 pathType = sign(end - beg);\n    float edge = sz.x / (sz.x + sz.y);\n    float pathHash = hash12(vec2(hash12(beg), hash12(end)));\n    float dir = step(edge, hash12(vec2(pathHash, hash12(id) + floor(iTime / 2.) * 0.162)));\n    vec2 ans = (dir < 0.5) ? vec2(pathType.x, 0.) : vec2(0., pathType.y);\n    return ans;\n}\n\nbool is_good(vec2 id, vec2 beg, vec2 end){\n    return get(to01(IdToCenter(id))).a > 1. - eps;\n}\n\nfloat crs(vec2 a, vec2 b){\n    return a.x * b.y - a.y * b.x;\n}\n\n// https://iquilezles.org/articles/distfunctions\nvec4 sdCapsule( vec2 p, vec2 a, vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    //float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float h = dot(pa,ba)/dot(ba,ba);\n    vec4 ans;\n    ans.z = 1. - length( pa - ba*h ) / r;\n    ans.y = length( pa - ba*h ) / r * sign(crs(pa, ba));\n    ans.x = h * length(ba) / r;\n    // temp\n    //ans.xy *= r;\n    ans.a = 1.;\n    return ans;\n}\n\nvec4 make_line(vec2 id, vec2 uv, vec2 from, vec2 to_){\n    vec2 cntr = IdToCenter(id);\n    //vec2 or = IdToLeftCntr(id);\n    //float hlf = (cntr - or).x;\n    float hlf = abs(IdToCenter(id).x - IdToCenter(id + from).x) / 2.;\n    vec2 beg = cntr + hlf * from;\n    vec2 end = cntr + hlf * to_;\n    vec4 tmp = sdCapsule(uv, beg, end, lineWidth);\n    //tmp.x += get(to01(beg + hlf * from * eps)).x;\n    //tmp.x = get(to01(beg)).a;\n    \n    //tmp.xy = beg + normalize(beg - end) * eps * 2.;\n    tmp.x /= 2.;\n    cntr = IdToCenter(id + from);\n    vec2 ch = cntr + to(id + from, beg, end) * (hlf - 0.005);\n    //tmp.x += get(to01(ch)).r + length(ch - beg);\n    tmp.xy = ch;\n    tmp.zw = beg;\n    return tmp;\n}\n\nvoid Path(in vec2 uv, in vec2 beg, in vec2 end, inout vec4 col){\n    vec2 pathType = sign(end - beg);\n    beg = PathId(beg, pathType);\n    end = PathId(end, pathType);\n    vec2 id = PathId(uv, pathType);\n    if (lesseq(id, max(end, beg)) && lesseq(min(end, beg), id)){\n        \n        vec2 from = vec2(0.);\n        vec2 checkId = id + vec2(-pathType.x, 0.);\n        bool hor = is_good(checkId, beg, end) && checkId + to(checkId, beg, end) == id;\n        from = (hor) ? vec2(-pathType.x, 0.) : from;\n        \n        checkId = id + vec2(0, -pathType.y);\n        bool ver = is_good(checkId, beg, end) && checkId + to(checkId, beg, end) == id;\n        from = (ver) ? vec2(0, -pathType.y) : from;\n        \n        col.a = (hor || ver) ? 1. : col.a;\n        \n        // making mask\n        vec4 line = (hor || ver) ? make_line(id, uv, from, to(id, beg, end)) : vec4(0.);\n        //col.rgb = (hor || ver) ? vec3(line.xx / 10., 0.) : col.rgb;\n        \n        //col.rgb = vec3(smoothstep(0., 0.01, length(line.xy * lineWidth)));\n        \n        //col = (hor || ver) ? vec4(vec3(length(line.xy - uv) < 0.03), float((hor || ver))) : col;\n        //line.x /= 10.;\n        col = (hor || ver) ? vec4(line.xxx / 2., line.w) : col;\n    }\n    vec2 cntr = IdToCenter(id);\n    vec2 or = IdToLeftCntr(id);\n    float hlf = (cntr - or).x;\n    vec4 tmp = sdCapsule(uv, cntr, cntr + hlf * to(id, beg, end), lineWidth);\n    tmp.z = (tmp.x < 0.) ? 0. : tmp.z;\n    //col.a = (id == beg) ? 1. : col.a;\n    col = (id == beg) ? vec4(tmp.xxx / 2., tmp.w) : col;\n    col = (length(tmp.xy - tmp.zw) > eps * 4.) ? vec4(0., 0., 1., 0.) : col;\n    //col = (length(tmp.zw - uv) < 0.3) ? vec4(0., 1., 0., 0.) : col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1 by y bx proportional)\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y * 2.;\n    vec4 col = vec4(0.);\n    float T = floor(iTime) / 20. * pi;\n    vec2 beg = vec2(cos(T), sin(T)) * 0.8;\n    vec2 end = vec2(cos(pi + T), sin(pi + T)) * 0.8;\n    \n    vec2 pathType = sign(end - beg);\n    vec2 id = PathId(uv, pathType);\n    col =  vec4(id / 10., 0., 0.);\n    Path(uv, beg, end, col);\n    //col.xyz = pow(col.xyz, vec3(0.4545)); // don't know how it works but gamma correction\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}