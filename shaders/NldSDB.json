{
    "Shader": {
        "info": {
            "date": "1639722934",
            "description": "It's just some random shader, and you're not a dolt. You're a nice person.",
            "flags": 0,
            "hasliked": 0,
            "id": "NldSDB",
            "likes": 0,
            "name": "eindacor_oscillationfun",
            "published": 3,
            "tags": [
                "something"
            ],
            "usePreview": 0,
            "username": "Eindacor_DS",
            "viewed": 39
        },
        "renderpass": [
            {
                "code": "\n#define CYAN vec3(0., 1., 1.)\n#define MAGENTA vec3(1., 0., 1.)\n#define YELLOW vec3(1., 1., 0.)\n#define RED vec3(1., 0., 0.)\n#define GREEN vec3(0., 1., 0.)\n#define BLUE vec3(0., 0., 1.)\n#define ORANGE vec3(1., .75, .25)\n#define PINK vec3(1., .25, .75)\n#define WHITE vec3(1.)\n#define BLACK vec3(0.)\n\nvec3 getRandomColor(float seed) {\n    seed = clamp(seed, 0., 1.);\n    float colorCount = 6.;\n    float colorIncrement = 1.f / colorCount;\n    float seedFloor = floor(seed / colorIncrement) * colorIncrement;\n    float lerpVal = smoothstep(seedFloor, seedFloor + colorIncrement, seed);\n\n    if (seed <= colorIncrement * 1.) {\n        return mix(RED, YELLOW, lerpVal);\n    } else if (seed <= colorIncrement * 2.) {\n        return mix(YELLOW, GREEN, lerpVal);\n    } else if (seed <= colorIncrement * 3.) {\n        return mix(GREEN, CYAN, lerpVal);\n    } else if (seed <= colorIncrement * 4.) {\n        return mix(CYAN, BLUE, lerpVal);\n    } else if (seed <= colorIncrement * 5.) {\n        return mix(BLUE, MAGENTA, lerpVal);\n    } else {\n        return mix(MAGENTA, vec3(1.), lerpVal);\n    }\n}\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n    float val = sin(dot(p, vec2(12.9898f, 78.233f))) * 43758.5453f;\n    return val - floor(val);\n}\n\nfloat getHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    float holdTime = 0.;\n    float transitionTime = 12.;\n    \n    float pRadius = .08;\n    float AA = .002;\n    \n    float divisions = 24.;\n    \n    float timeOffset = (-transitionTime / divisions * 2.) * sin(iTime);\n    timeOffset = getHoldTransitionValue(-1., 1., 5., 3., iTime);\n    fragColor = vec4(0.);\n    \n    int count = int(divisions);\n    float localAA = .02;\n    float bounceCoeff = .1;\n    \n    float yLower = .2;\n    float yUpper = .8;\n    for (int i=0; i<count; ++i) {\n        float offsetTime = float(i) * timeOffset;\n        float radius = pRadius * (1. - uv.y);\n        float leftSide = (aspectRatio - 1.) / 2.;\n        float xVal = getHoldTransitionValue(.2 * aspectRatio, .8 * aspectRatio, holdTime, transitionTime, iTime + offsetTime + (holdTime + transitionTime) / 2.);\n        float yVal = getHoldTransitionValue(yLower, yUpper, holdTime, transitionTime, iTime + offsetTime);\n        vec2 p = vec2(xVal, yVal);\n        \n        float pointVal = smoothstep(radius + AA, radius - AA, distance(uv, p));\n        fragColor += vec4(vec3(getRandomColor(hash(vec2(float(i))))), 1.) * pointVal;\n        \n        if (uv.y > mix(yLower, yUpper, .5)) {\n            if (uv.x < aspectRatio * .5) {\n                float leftEdge = .2 * aspectRatio + radius;\n                float leftVal = smoothstep(leftEdge, leftEdge + localAA, uv.x);\n                fragColor = mix(fragColor, vec4(0.), leftVal);\n            } else {\n                float rightEdge = .8 * aspectRatio - radius;\n                float rightVal = smoothstep(rightEdge - localAA, rightEdge, uv.x);\n                fragColor = mix(vec4(0.), fragColor, rightVal);\n            }\n        }  \n    }\n \n    yLower = .35;\n    yUpper = .8;\n    for (int i=0; i<count; ++i) {\n        float offsetTime = float(i) * timeOffset;\n        float radius = pRadius * (1. - uv.y);\n        float leftSide = (aspectRatio - 1.) / 2.;\n        float xVal = getHoldTransitionValue(.2 * aspectRatio, .8 * aspectRatio, holdTime, transitionTime, iTime + offsetTime + (holdTime + transitionTime) / 2.);\n        float yVal = getHoldTransitionValue(yLower, yUpper, holdTime, transitionTime, iTime + offsetTime);\n        vec2 p = vec2(xVal, yVal);\n        \n        float pointVal = smoothstep(radius + AA, radius - AA, distance(uv, p));\n        fragColor += vec4(vec3(getRandomColor(hash(vec2(float(i))))), 1.) * pointVal;\n        \n        if (uv.y > mix(yLower, yUpper, .5)) {\n            if (uv.x < aspectRatio * .5) {\n                float leftEdge = .2 * aspectRatio + radius;\n                float leftVal = smoothstep(leftEdge, leftEdge + localAA, uv.x);\n                fragColor = mix(fragColor, vec4(0.), leftVal);\n            } else {\n                float rightEdge = .8 * aspectRatio - radius;\n                float rightVal = smoothstep(rightEdge - localAA, rightEdge, uv.x);\n                fragColor = mix(vec4(0.), fragColor, rightVal);\n            }\n        }  \n    }\n    \n    yLower = .5;\n    yUpper = .8;\n    for (int i=0; i<count; ++i) {\n        float offsetTime = float(i) * timeOffset;\n        float radius = pRadius * (1. - uv.y);\n        float leftSide = (aspectRatio - 1.) / 2.;\n        float xVal = getHoldTransitionValue(.2 * aspectRatio, .8 * aspectRatio, holdTime, transitionTime, iTime + offsetTime + (holdTime + transitionTime) / 2.);\n        float yVal = getHoldTransitionValue(yLower, yUpper, holdTime, transitionTime, iTime + offsetTime);\n        vec2 p = vec2(xVal, yVal);\n        \n        float pointVal = smoothstep(radius + AA, radius - AA, distance(uv, p));\n        fragColor += vec4(vec3(getRandomColor(hash(vec2(float(i))))), 1.) * pointVal;\n        \n        if (uv.y > mix(yLower, yUpper, .5)) {\n            if (uv.x < aspectRatio * .5) {\n                float leftEdge = .2 * aspectRatio + radius;\n                float leftVal = smoothstep(leftEdge, leftEdge + localAA, uv.x);\n                fragColor = mix(fragColor, vec4(0.), leftVal);\n            } else {\n                float rightEdge = .8 * aspectRatio - radius;\n                float rightVal = smoothstep(rightEdge - localAA, rightEdge, uv.x);\n                fragColor = mix(vec4(0.), fragColor, rightVal);\n            }\n        } \n        \n    }\n    fragColor *= pow(.95, smoothstep(.2, .8, uv.y) * 20.);\n    //fragColor *= 1. - smoothstep(.2, .9, uv.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}