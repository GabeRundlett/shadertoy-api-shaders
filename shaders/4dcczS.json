{
    "Shader": {
        "info": {
            "date": "1519813831",
            "description": "Minimal ray-traced bubble, with multiple bounces of reflected and refracted rays\n(one ray shot per pixel)\nDone by ray-tracing two spheres of almost similar diameter,\ntaking into account refractive index",
            "flags": 0,
            "hasliked": 0,
            "id": "4dcczS",
            "likes": 2,
            "name": "Minimal bubble",
            "published": 3,
            "tags": [
                "raytracing",
                "texture",
                "bubble",
                "minimal",
                "small",
                "golf"
            ],
            "usePreview": 0,
            "username": "ABizard",
            "viewed": 543
        },
        "renderpass": [
            {
                "code": "/*\n\nMinimal ray-traced bubble, with multiple bounces of reflected and refracted rays\n(one ray shot per pixel)\nDone by ray-tracing two spheres of almost similar diameter,\ntaking into account refractive index\n\nCreated by ABizard\nThanks to Fabrice Neyret for the help from 795->759 !\n\n*/\n\n// Number max of stored rays at bounce i is Fibonnacci(i)\n// Arrays size must be at least Sum_i:1->bounces_(Fibonnacci(i))\n// Here 32 for 6 bounces or 19 for 5 bounces\n\nvec3 p,\t\t\t// intersection point\n     r,\t\t\t// origin of the ray / refracted ray\n     u,\t\t\t// ray\n     n,\t\t\t// normal at p\n\t O[19],\t\t// array of origins\n\t U[19];\t\t// array of rays\n\nbool l=0>1,\t\t// layer : true iff between the 2 spheres\n     L[19],\t\t// array of layers\n     t;\t\t\t// are we heading towards the center or the exterior ?\n\nfloat c=1.,\t\t// current coefficient (to be updated inversly with f)\n      C[19],\t// array of coefficients\n      f,\t\t// Fresnel coefficient & utility for #I\n\t  d,\t\t// utility for #I & #R\n\t  g;\t\t// utility for #R\n\n// ## I : Ray-sphere intersection (sphere centered on origin), R = radius^2\n    // Implicit args :\n    // o : origin of the ray\n    // u : direction of the ray\n    // out p : point of intersection\n#define I(R)\t\t\t\t\t\\\n    (d = -dot(u,r),\t\t\t\t\\\n    f = R+d*d - dot(r,r),\t\t\\\n    f = f>0. ? sqrt(f) : 0.,\t\\\n    d += d-f<.01 ? f : -f,\t\t\\\n    n = normalize(p = r + u*d),\t\\\n\tf*d>.01)\n\n// ## E : Environment at direction D\n#define E w = texture(iChannel0\n// 2D texture version\n//#define E(D) texture(iChannel0,vec2(atan(D.x,D.z),acos(D.y))/3.14);\n\n\n// ## G : Position of the center of the sphere at time T\n#define G(T) vec3(cos(T),0,sin(T))\n\nvoid mainImage( out vec4 w, vec2 i )\n{\n    r = iResolution;\n    i = (i+i-r.xy)/r.y;\t\t// normalized and centered pixel coords\n    r = G(g=.05*iTime);\t\t// camera position\n    //p = r.zyy-r.yyx;\t\t// global camera direction in world coordinates\n    \n    // camera direction (for this pixel)\n\t// u = normalize(i.x*(r.zyy-r.yyx) vec3(0,i.y,0) - r - r);\n\t// u = i.x*(r.zyy-r.yyx) - r - r;\n    u = i.x*G(g-33.)-r-r;\n    u.y+=i.y;\n    \n    // Move the origin of the first ray according to the bubble,\n    // so we can suppose it is centered on origin\n    r = r*4.-G(g/.05);\n    \n    E,u/=length(u)); // color\n\n    // Intersect with the bubble\n    if I(c){\t// c=1. here\n\n        int i=0, // index of insertion\n            x=0, // index of extraction\n            b=0, // bounce\n            j;\n        \n        // ## R : update refracted ray (r) and Fresnel coefficient (f)\n        // \t\t\taccording to refractive index E\n        #define R(E) r = refract(u,n, 1./E),\t\t\t\t\t\t\t\t\\\n        \t\t\t f = dot(-u,n),\t\t\t\t\t\t\t\t\t\t\t\\\n                     d = sqrt(E*E-1.+f*f),\t\t\t\t\t\t\t\t\t\\\n                     g = (-d+f)/(d+f),\t\t\t\t\t\t\t\t\t\t\\\n                     d = 1.-2.*d/(d+f*E*E),\t\t\t\t\t\t\t\t\t\\\n                     /* Substract Fresnel coefficient to current coeff */\t\\\n        \t\t\t c -= f = r==-r\t\t\t\t\t\t\t\t\t\t\t\\\n                         \t? c \t\t\t/*There is no refracted ray*/\t\\\n                         \t: (g*g+d*d)*.5*c,\t\t/*Eveything's fine*/\n        \n        // Compute refracted ray and Fresnel coefficient\n        R(1.5)\n        \n        // color\n        E,reflect(u,n)) * f;\n        \n        // ## A : add refracted ray (r) to arrays\n\t\t#define A \tC[i] = c,\t\\\n                \tL[i] = !l,\t\\\n        \t\t\tO[i] = p,\t\\\n            \t\tU[i++] = r\n\n        // Next bounces : we're either inside the soap layer, or inside the bubble\n        for(A;b++<6;)\n            // Compute each ray stored from the previous step\n            for(j=i;x<j; L[i++] = l)\n                // Extract the ray\n                c = C[x],\n                l = L[x],\n                r = O[x],\n                u = U[x++],\n\n                // Compute the intersection with internal or external sphere\n                //(t=I(.9)) || I(1.);\t// <- doesnt work on Windows\n                //if(!(t=I(.9)))\n                //   I(1.);\n                t=I(.9),\n                !t ? I(1.) : t,\n\n                // Compute the normal\n                n = l&&t ? n : -n,\n\n                // Compute refracted ray and Fresnel coefficient\n                R((l ? .67 : 1.5))\n                \n                // Update color and add rays to arrays\n                !l||t ?\n                    // Keep boucing\n                    // Add the refracted ray\n                    A,\n                   \tw\t// So that this has type vec4\n                :\n                    // Intersecting the external sphere\n                    // Update color with refracted ray\n                    E,r)*c + w,\n                \n                // Add the reflected ray\n                O[i] = p,\n                U[i] = reflect(u,n),\n                C[i] = f;\n\t}\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}