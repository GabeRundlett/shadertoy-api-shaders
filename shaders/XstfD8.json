{
    "Shader": {
        "info": {
            "date": "1525193076",
            "description": "Basic raytracing with reflection.\nThe code is really easy to modify, you can just change the createScene function to build your own scene.",
            "flags": 8,
            "hasliked": 0,
            "id": "XstfD8",
            "likes": 5,
            "name": "Raytracing Balls",
            "published": 3,
            "tags": [
                "raytracingtestreflectionsphereplane"
            ],
            "usePreview": 0,
            "username": "paulbaron",
            "viewed": 737
        },
        "renderpass": [
            {
                "code": "\nconst float infinity = 10000.0f;\nconst vec3 backgroundColor = vec3(0, 0, 0.1);\n\nconst float camNearPlane = 0.2f;\nconst float camScreenDimension = 0.1f;\nconst float camDist = 10.0f;\nconst float camMaxHeight = 7.0f;\nconst float camMinHeight = 0.0f;\nconst float camHeightSpeed = 1.5f;\nconst float camSpeed = 1.0f;\n\nconst float specularAngle = 0.5f; // Smaller is bigger specular\nconst float specularExp = 10.0f;\n\nconst float ambientLight = 0.2f;\n\n// OBJ to raytrace\n#define SPHERE_COUNT \t\t6\n#define PLANE_COUNT \t\t3\n#define TOTAL_OBJ_COUNT \tSPHERE_COUNT + PLANE_COUNT\n\n// Lights\n#define LIGHT_COUNT \t\t3\n\nstruct \tSCamera\n{\n    vec3 \tm_Position;\n    vec3 \tm_Side;\n    vec3 \tm_Forward;\n    vec3 \tm_Up;\n};\n    \nstruct \tSSphere\n{\n    vec3 \tm_Position;\n    float \tm_Radius;\n    float \tm_UvScale;\n    float \tm_Reflection;\n    int \tm_TextureId;\n};\n\nstruct SPlane\n{\n    vec3 \tm_Position;\n    vec3 \tm_Normal;\n    vec3 \tm_Tangent;\n    float \tm_UvScale;\n    float \tm_Reflection;\n    int \tm_TextureId;\n};\n    \nstruct \tSLight\n{\n    vec3 \tm_Position;\n    vec3 \tm_Color;\n\tfloat \tm_Intensity;\n\tfloat \tm_Range;\n};\n\nstruct \tSRayHit\n{\n    float \tm_Distance;\n\tvec3 \tm_Position;\n    vec3 \tm_Normal;\n    vec2 \tm_Uv;\n    int \tm_TextureId;\n    float \tm_Reflection;\n};\n    \nstruct \tSScene\n{\n    SCamera \tm_Camera;\n    SSphere\t \tm_Spheres[SPHERE_COUNT];\n    SPlane \t\tm_Planes[PLANE_COUNT];\n    \n    SLight \t\tm_Lights[LIGHT_COUNT];\n    \n    SRayHit\t\tm_Hits[TOTAL_OBJ_COUNT];\n};\n    \nSCamera\tbuildLookAt(vec3 position, vec3 toLookAt, vec3 up)\n{\n    SCamera\tcam;\n        \n    cam.m_Position = position;\n    cam.m_Forward = normalize(toLookAt - position);\n    cam.m_Side = normalize(cross(up, cam.m_Forward));\n    cam.m_Up = cross(cam.m_Forward, cam.m_Side);\n    return cam;\n}\n\nSScene \tcreateScene()\n{\n    SScene \tscene;\n    \n\tfloat camHeight = (cos(iTime * camHeightSpeed) * 0.5 + 0.5) * (camMaxHeight - camMinHeight) + camMinHeight;\n    vec3 camPos = vec3(cos(iTime * camSpeed) * camDist, camHeight, sin(iTime * camSpeed) * camDist);\n\n    scene.m_Camera = buildLookAt(camPos, vec3(0, 0, 0), vec3(0, 1, 0));\n    for (int i = 0; i < SPHERE_COUNT; ++i)\n    {            \n        scene.m_Spheres[i].m_Position = vec3((i -SPHERE_COUNT / 2) * 2, cos(iTime * 2.0f + float(i)) * 2.0f + 2.0f, 0);\n        scene.m_Spheres[i].m_Radius = 0.8f;\n        scene.m_Spheres[i].m_UvScale = 1.0f;\n        scene.m_Spheres[i].m_TextureId = 1;\n        scene.m_Spheres[i].m_Reflection = float(i) / float(SPHERE_COUNT - 1);\n    }\n\n    for (int i = 0; i < PLANE_COUNT; ++i)\n    {\n        if (i == 0)\n        {\n\t\t\tscene.m_Planes[i].m_Position = vec3(0, -1, 0);\n        \tscene.m_Planes[i].m_Normal = vec3(0, 1, 0);\n        \tscene.m_Planes[i].m_Tangent = vec3(0, 0, 1);\n\t        scene.m_Planes[i].m_TextureId = 0;\n    \t    scene.m_Planes[i].m_Reflection = 0.0f;\n        }\n        else if (i == 1)\n        {\n\t\t\tscene.m_Planes[i].m_Position = vec3(0, 0, -10);\n        \tscene.m_Planes[i].m_Normal = vec3(0, 0, 1);\n        \tscene.m_Planes[i].m_Tangent = vec3(0, 1, 0);\n\t        scene.m_Planes[i].m_TextureId = 2;\n    \t    scene.m_Planes[i].m_Reflection = 0.3f;\n        }\n        else if (i == 2)\n        {\n\t\t\tscene.m_Planes[i].m_Position = vec3(15, 0, 0);\n        \tscene.m_Planes[i].m_Normal = vec3(-1, 0, 0);\n        \tscene.m_Planes[i].m_Tangent = vec3(0, 1, 0);\n\t        scene.m_Planes[i].m_TextureId = 2;\n    \t    scene.m_Planes[i].m_Reflection = 0.3f;\n        }\n        scene.m_Planes[i].m_UvScale = 0.2f;\n    }\n\n    for (int i = 0; i < LIGHT_COUNT; ++i)\n    {\n        scene.m_Lights[i].m_Position = vec3((i - LIGHT_COUNT / 2) * 5, 7.0f, 0);\n        scene.m_Lights[i].m_Color = vec3(1, 1, 1);\n        scene.m_Lights[i].m_Intensity = 0.8f;\n        scene.m_Lights[i].m_Range = 50.0f;\n    }\n    return scene;\n}\n\nfloat \tremap(float value, float curMin, float curMax, float newMin, float newMax)\n{\n\treturn newMin + (value - curMin) * (newMax - newMin) / (curMax - curMin);\n}\n\nvec3 \tuvToWorldSpace(SCamera cam, vec2 uv, float nearDist, float aspectRatio, float verticalOpening)\n{\n    // Now we convert this in world space\n    vec3 nearPlaneCenter = cam.m_Position + (cam.m_Forward * nearDist);\n\tvec3 worldSpaceUv = nearPlaneCenter +\n        \t\t\t\t(uv.x * cam.m_Side * aspectRatio * verticalOpening) +\n        \t\t\t\t(uv.y * cam.m_Up * verticalOpening);\n\treturn worldSpaceUv;\n}\n\nSRayHit \thitPlane(SPlane plane, vec3 rayOrigin, vec3 rayDirection)\n{\n    SRayHit \thit;\n    \n    float denom = dot(plane.m_Normal, rayDirection);\n    float solution = dot(plane.m_Position - rayOrigin, plane.m_Normal) / denom;\n    vec3 planeBiTan = cross(plane.m_Normal, plane.m_Tangent);\n    \n\thit.m_Distance = solution < 0.0f ? infinity : solution;\n    \n    if (hit.m_Distance != infinity)\n    {\n   \t \thit.m_Position = rayOrigin + solution * rayDirection;\n   \t \thit.m_Normal = plane.m_Normal;\n\n    \tvec3 originToIntersect = hit.m_Position - plane.m_Position;\n\n    \thit.m_Uv = vec2(dot(plane.m_Tangent, originToIntersect), dot(planeBiTan, originToIntersect));\n    \thit.m_Uv *= plane.m_UvScale;\n    \thit.m_Uv.x = abs(hit.m_Uv.x) > 1.0f ? fract(hit.m_Uv.x) : hit.m_Uv.x;\n    \thit.m_Uv.y = abs(hit.m_Uv.y) > 1.0f ? fract(hit.m_Uv.y) : hit.m_Uv.y;\n    \thit.m_TextureId = plane.m_TextureId;\n\t\thit.m_Reflection = plane.m_Reflection;\n    }        \n    return hit;\n}\n\nSRayHit \thitSphere(SSphere sphere, vec3 rayOrigin, vec3 rayDirection)\n{\n    SRayHit \thit;\n\n    // To sphere space ray origin\n    rayOrigin -= sphere.m_Position;\n\n    vec3 \tsquareDir = rayDirection * rayDirection;\n\tvec3 \tsquareOri = rayOrigin * rayOrigin;\n\tfloat \tsquareRadius = sphere.m_Radius * sphere.m_Radius;\n    \n    float \ta = dot(rayDirection, rayDirection);\n    float \tb = 2.0f * rayOrigin.x * rayDirection.x + \n      \t  \t\t2.0f * rayOrigin.y * rayDirection.y + \n       \t\t\t2.0f * rayOrigin.z * rayDirection.z;\n    float \tc = dot(rayOrigin, rayOrigin) - squareRadius;\n        \n    float delta = b * b - 4.0f * a * c;\n\n    // To World space ray origin\n\trayOrigin += sphere.m_Position;\n    \n    if (delta >= 0.0f)\n    {\n        float deltaSqrt = delta == 0.0f ? 0.0f : sqrt(delta);\n        \n\t    float solution1 = (-b + deltaSqrt) / (2.0f * a);\n    \tfloat solution2 = (-b - deltaSqrt) / (2.0f * a);\n        \n        float closest = min(solution1, solution2);\n        \n        hit.m_Distance = closest < 0.0f ? infinity : closest;\n\n        if (hit.m_Distance != infinity)\n    \t{\n        \thit.m_Position = rayOrigin + rayDirection * closest;\n        \thit.m_Normal = normalize(hit.m_Position - sphere.m_Position);\n\n        \tfloat dotNormX = (dot(hit.m_Normal, vec3(1, 0, 0))) * 0.5 + 0.5f; // between 0 and 0.5\n        \tfloat dotNormY = (dot(hit.m_Normal, vec3(0, 1, 0))) * 0.5f + 0.5f; // between 0 and 0.5\n        \tfloat dotNormZ = dot(hit.m_Normal, vec3(0, 0, 1));\n        \n        \thit.m_Uv.x = dotNormX;\n        \thit.m_Uv.y = dotNormY;\n\t\t\thit.m_TextureId = sphere.m_TextureId;\n\t\t\thit.m_Reflection = sphere.m_Reflection;\n        }\n        return hit;\n    }\n    hit.m_Distance = infinity;\n    return hit;\n}\n\nvoid computePointLight(SLight light, vec3 surfPos, vec3 surfNormal,\n                        vec3 camPos, vec3 rayDirection, out vec3 diffuse, out float spec)\n{\n    vec3 surfToLight = light.m_Position - surfPos;\n    float squareDist = dot(surfToLight, surfToLight) / light.m_Range + 1.0f;\n\n    float diffuseIntensity = max(0.0f, dot(normalize(surfToLight), surfNormal));\n    diffuseIntensity = diffuseIntensity * light.m_Intensity / squareDist;\n\n    diffuse += light.m_Color * diffuseIntensity;\n    \n    vec3 reflectedRay = reflect(rayDirection, surfNormal);\n    float collinearity = dot(normalize(surfToLight), normalize(reflectedRay));\n\n    float \tspecIntensity = remap(max(specularAngle, collinearity), specularAngle, 1.0f, 0.0f, 1.0f);\n    specIntensity = pow(specIntensity, specularExp);\n    specIntensity = specIntensity * light.m_Intensity / squareDist;\n\n    spec += specIntensity;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    SScene scene = createScene();\n    \n    float  aspectRatio = iResolution.x / iResolution.y;\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 screenUv = (fragCoord / iResolution.xy) * 2.0f - 1.0f;\n    \n\tvec3 worldSpaceUv = uvToWorldSpace(scene.m_Camera, screenUv, camNearPlane, aspectRatio, camScreenDimension);\n\n    vec3 rayOrigin = worldSpaceUv;\n    vec3 rayDirection = worldSpaceUv - scene.m_Camera.m_Position;\n\n\tSRayHit closestHit;\n\n    // We start with a distance != infinity\n    closestHit.m_Distance = 0.0f;\n\n    float\tcolorToCreate = 1.0f; // At the begining we need to create 100% of the color\n    vec3 \taccumColor = vec3(0.0f);\n    \n\n    for (int rayi = 0; rayi < 4 && closestHit.m_Distance != infinity && colorToCreate > 0.0f; ++rayi)\n    {\n        // First we intersect all the scene objects\n        int obji = 0;\n        \n        for (int spherei = 0; spherei < SPHERE_COUNT; ++spherei)\n        {    \n    \t\tscene.m_Hits[obji] = hitSphere(scene.m_Spheres[spherei], rayOrigin, rayDirection);\n            ++obji;\n        }\n        for (int planei = 0; planei < PLANE_COUNT; ++planei)\n        {    \n    \t\tscene.m_Hits[obji] = hitPlane(scene.m_Planes[planei], rayOrigin, rayDirection);\n            ++obji;\n        }\n\n        // Then we gather the \"best\" result (closest object we hit)\n        closestHit.m_Distance = infinity;\n        \n        for (int hiti = 0; hiti < TOTAL_OBJ_COUNT; ++hiti)\n        {    \n            if (scene.m_Hits[hiti].m_Distance < closestHit.m_Distance)\n            {\n                closestHit = scene.m_Hits[hiti];\n            }\n        }\n        \n        // If we find that there was a hit, then we compute the color for this fragment\n\t\tif (closestHit.m_Distance != infinity)\n        {\n            vec3 \tobjectColor;\n            \n            // First we sample the diffuse texture for this obj\n            if (closestHit.m_TextureId == 0)\n            {\n        \t\tobjectColor = texture(iChannel0, closestHit.m_Uv).rgb;\n            }\n            else if (closestHit.m_TextureId == 1)\n            {\n        \t\tobjectColor = texture(iChannel1, closestHit.m_Uv).rgb;\n            }\n            else\n            {\n        \t\tobjectColor = texture(iChannel2, closestHit.m_Uv).rgb;\n            }\n            \n            // Then we compute the light influence on this object\n\t\t\tvec3 \tdiffuse = vec3(0.0f);\n            float \tspec = 0.0f;\n\n            for (int lighti = 0; lighti < LIGHT_COUNT; ++lighti)\n            {\n\t\t\t\tcomputePointLight(scene.m_Lights[lighti],\n \t\t\t\t\t\t\t\tclosestHit.m_Position, closestHit.m_Normal,\n            \t            \trayOrigin, rayDirection,\n                \t      \t\tdiffuse, spec);\n            }\n\n            // We compute what is left of the color to compute\n            float \tnextColorToCreate = colorToCreate * closestHit.m_Reflection;\n\n            // We then compute how much the current surface absorbs\n\t\t\tfloat \tcolorContrib = colorToCreate - nextColorToCreate; \n            \n            colorToCreate = nextColorToCreate;\n            \n            // Then we compute the final color and accumulate it\n\t\t    accumColor += colorContrib * ((diffuse + ambientLight) * objectColor + spec);\n\n            rayOrigin = closestHit.m_Position + closestHit.m_Normal * 0.001f;;\n    \t    rayDirection = reflect(rayDirection, closestHit.m_Normal);\n        }\n        else\n        {\n            vec3 \tenvColor = texture(iChannel3, normalize(rayDirection)).rgb;\n            \n\t        accumColor += colorToCreate * envColor;\n            colorToCreate = 0.0f;\n        }\n    }\n\n    // Output to screen\n\tfragColor = vec4(accumColor, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n\nvec2 mainSound( in int samp, float time )\n{\n    float \tbaseFrequency = 6.2831 * 440.0 * time; // 440 Hz\n    vec2 \twave = vec2(0, 0);\n    \n    wave += sin(baseFrequency) * 0.5 + 0.5;\n    return wave * 0.0f;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}