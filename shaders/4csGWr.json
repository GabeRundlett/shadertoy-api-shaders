{
    "Shader": {
        "info": {
            "date": "1702950471",
            "description": "A star map, sort of a proof of concept as it can be improved in many ways.",
            "flags": 0,
            "hasliked": 0,
            "id": "4csGWr",
            "likes": 16,
            "name": "A concept for starmap",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "sun",
                "star",
                "sky",
                "map",
                "ellipse",
                "quadtree",
                "milkyway",
                "gaz",
                "nigthsky"
            ],
            "usePreview": 0,
            "username": "Cewein",
            "viewed": 801
        },
        "renderpass": [
            {
                "code": "// Shader made by Maximilien \"Cewein\", december 2023\n//\n// This is a 2D star field, this use a probabilistic quad tree [1]\n// to make the star, the version it was based on was nice but still very\n// bloated, therefore was cleaned here. Use fractal brownian motion [2] from\n// perlin noise [3] to generate the \"space dust\". star brigthness is a poor's man\n// black body radiation approximation [4][5]\n//\n//\n// Possible improvement :\n// \t\t- Anti-Aliasing (but heave on perf)\n//\t\t- in the quadtree perform neighbour check\n//      - better control of the star size, color, brigthness and blinking periode\n//      - better control for the gaz clouds\n//\n// sources : \n// [1]: https://ciphrd.com/2020/04/02/building-a-quadtree-filter-in-glsl-using-a-probabilistic-approach/\n// [2]: https://www.esaim-proc.org/articles/proc/pdf/1998/03/proc-Vol5.7.pdf\n// [3]: https://mrl.cs.nyu.edu/~perlin/paper445.pdf\n// [4]: https://www.atnf.csiro.au/outreach//education/senior/cosmicengine/stars_colour.html\n// [5]: https://en.wikipedia.org/wiki/Planck%27s_law\n\n// Constants for quadtree division and iteration counts\n#define MIN_DIVISIONS 10.0\n#define MAX_ITERATIONS 4\n#define SAMPLES_PER_ITERATION 5\n\n// Function to calculate color variation for a quad division in space\n// Computes the average and variance of color components from random samples\nfloat colorVariation(in vec2 center, in float size, vec2 a, vec2 b) \n{\n    vec3 avg = vec3(0);\n    vec3 var = vec3(0);\n\n    // Sampling for color calculation\n    for (int i = 0; i < SAMPLES_PER_ITERATION; i++) {\n        vec2 r = hash22(center.xy + vec2(float(i))) - 0.5;\n        float d = -sdEllipse(center + r * size, a, b);\n        d = smoothstep(-.3, 2.0, d);\n        vec3 sp = vec3(d);\n        avg += sp;\n        var += sp * sp;\n    }\n    \n    // Calculate average and variance\n    avg /= float(SAMPLES_PER_ITERATION);\n    var = var / float(SAMPLES_PER_ITERATION) - avg * avg;\n    \n    return dot(var, vec3(1.0, 1.0, 1.0)) / 3.0;\n}\n\n// Main function for rendering\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;;\n    \n    // Threshold for quad variance\n    float threshold = 1.5e-5;  \n\n    // Number of space divisions\n    float divs = MIN_DIVISIONS;\n\n    // Initialize ellipses parameters\n    vec2 a = vec2(sin(2.5) * 0.1 + 0.5, 0);\n    vec2 b = vec2(0, sin(1.5) * 0.1 + 0.5);\n\n    for (int i = 0; i < MAX_ITERATIONS; i++) \n    {\n    \n        //probabilistic quadtree information\n        // Center of the active quad and length of a side of the active quad\n        vec2 quadCenter = (floor(uv * divs) + 0.5) / divs;\n        float quadSize = 1.0 / divs;\n        \n        // Calculate color variation \n        float quadAvgVar = colorVariation(quadCenter, quadSize, a * rot(0.5) * 2.2, b * rot(0.75) * 0.05);\n        \n        // Check if variance is below threshold\n        if (quadAvgVar < threshold) break;\n        \n        // Divide the space again\n        divs *= 2.0;\n    }\n    \n    // Coordinates inside the quad\n    vec2 nUv = fract(uv * divs);\n    vec2 id = floor(uv * divs);\n    \n    // Random position and color\n    vec2 randPos = hash22(id);\n    vec3 col = hash32(id);\n    float randNum = hash12(id);\n    \n    //distance to the \"star\"\n    float d = 1.0 - smoothstep(distance(randPos, nUv), 0.0001 * divs, 0.002 * divs);\n    vec4 color = vec4(d);\n\n    // Perform blinking effect between two colors\n    // and fake black body radiation\n    // the blinking is slow and just for a pure \"artistic\" vision\n    // and the brigthness as a poorman's version of the Planck's law\n    float blinkFactor = clamp(sin(100.0 * cos(randNum) + .50 * iTime * randNum),0.,1.0);\n    float brigthness = smoothstep(0.1, 1.0, randNum * 0.7 + 0.3);\n    \n    //brigth star are \"white blue\" and dim stars are \"fire orange\"\n    vec4 brightColor = vec4(0.859, 0.914, 0.957,1.0); // White-blue color\n    vec4 dimColor = vec4(0.70, 0.27, 0.0,1.0); // Fire orange color\n    vec4 blendedColor = mix(dimColor, brightColor,randNum);\n    color *= brigthness * blinkFactor * blendedColor; \n    \n    // Apply ellipses with different parameters and update color each time\n    color = applyEllipse(uv, a, b, vec2(2.2, 0.5), vec2(0.25, 0.75), vec3(2.0, 0.9, 0.7), color, 0.75, vec4(1.0, 0.4, 0.6, 1.0));\n    color = applyEllipse(uv, a, b, vec2(0.75, 0.5), vec2(0.5, 0.65), vec3(2.5, 0.8, 0.7), color, 0.5, vec4(1.0, 0.8, 0.4, 1.0));\n    color = applyEllipse(uv, a, b, vec2(2.25, 0.5), vec2(0.75, 0.75), vec3(1.0, 0.7, 0.6), color, 0.1, vec4(.0, 0.2, 0.9, 1.0));\n    \n    // Create lines from the UV coordinates\n    vec2 lWidth = vec2(1.0 / iResolution.x, 1.0 / iResolution.y);\n    vec2 uvAbs = abs(nUv - 0.5);\n    float s = step(0.5 - uvAbs.x, lWidth.x * divs) + step(0.5 - uvAbs.y, lWidth.y * divs);\n    \n    // Output to screen\n    fragColor = color;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//A define to create a 2D rotation matrix based on an angle.\n//The angle must be in radian\n#define rot(t) mat2(cos(t), -sin(t), sin(t), cos(t))\n\n///// SDF FUNCTION - MOSTLY 2D /////\n\n// for visualization purposes only\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\n// Function to compute the signed distance from a 2D point 'p' to an ellipse defined by two radii 'a' and 'b'\n// The function utilizes Newton's method for root finding to determine the distance\n// See https://www.shadertoy.com/view/4sS3zz for more details on this method\nfloat sdEllipse(vec2 p, vec2 a, vec2 b) \n{\n    // Perform transformations and calculate the minor/major radii\n    float la = length(a);\n    float lb = length(b);\n    p *= mat2(a / la, b / lb);\n    vec2 ab = vec2(la, lb);\n    \n    // Code beyond this point by Inigo Quilez (iq)\n    \n    // Ensure symmetry\n    p = abs(p);\n\n    // Find root with Newton's solver\n    vec2 q = ab * (p - ab);\n    float w = (q.x < q.y) ? 1.570796327 : 0.0;\n    for (int i = 0; i < 4; i++) {\n        vec2 cs = vec2(cos(w), sin(w));\n        vec2 u = ab * vec2(cs.x, cs.y);\n        vec2 v = ab * vec2(-cs.y, cs.x);\n        w = w + dot(p - u, v) / (dot(p - u, u) + dot(v, v));\n    }\n    \n    // Compute final point and distance\n    float d = length(p - ab * vec2(cos(w), sin(w)));\n    \n    // Return signed distance\n    return (dot(p / ab, p / ab) > 1.0) ? d : -d;\n}\n\n///// RANDOMNESS - PART ONE: HASH /////\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n/// 2 out, 2 in... made for perlin noise and use a sinusoid\n/// work well with small value or hit floating point precision error\nvec2 hashNoise22(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n///// RANDOMNESS - PART TWO: PERLIN NOISE AND FRACTAL BROWNIAN MOTION /////\n\n// From https://www.shadertoy.com/view/4tdSWr\n// Function to generate Perlin noise at a 2D coordinate 'p' using Perlin's algorithm\n// The noise function produces smooth, continuous noise values based on the input coordinate\nfloat noise(in vec2 p) \n{\n    // Constants used in the Perlin noise calculation\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n    vec2 i = floor(p + (p.x + p.y) * K1);\n    vec2 a = p - i + (i.x + i.y) * K2;\n    vec2 o = (a.x > a.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0 * K2;\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hashNoise22(i + 0.0)), dot(b, hashNoise22(i + o)), dot(c, hashNoise22(i + 1.0)));\n    return dot(n, vec3(70.0));\n}\n\n// Function to generate fractal Brownian motion (FBM) using Perlin noise from a point \"n\"\n// with the two parametre (I.E : lacunarity and Persistance )\nfloat fbm(vec2 n, float amplitude, float resiliation) \n{\n    // Initialize the total value to accumulate noise\n    float total = 0.0; \n    \n    // Define a transformation matrix 'm', it provide rotation and scaling to avoid repetion\n    // without this matrix the fbm will stack every octave on top of on and each other and become uniform\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n\n    // Iterate through multiple octaves to compute the final noise value\n    for (int i = 0; i < 7; i++) {\n        // Accumulate noise values with varying amplitudes\n        total += (0.1 + noise(n)) * amplitude;\n        \n        // Apply the transformation matrix 'm' to 'n' for the next octave\n        n = m * n;\n        \n        // Decrease the amplitude for the next octave\n        amplitude *= resiliation;\n    }\n    \n    // Return the absolute accumulated noise value\n    return abs(total);\n}\n\n\n/* Function to calculate the distance to an elliptical shape and perform color blending at a given UV coordinate\nParameter explanantion :\nvec2 uv,           // 2D coordinates of the point on the surface\nvec2 a,            // First axis of the ellipse\nvec2 b,            // Second axis of the ellipse\nvec2 factorA,      // Factors to modify the first axis: [scale, rotation]\nvec2 factorB,      // Factors to modify the second axis: [scale, rotation]\nvec3 fbmParam,     // Parameters for the fractal Brownian motion (scale, octaves, persistence)\nvec4 color,        // Original color to be mixed\nfloat intensity,   // Mixing factor\nvec4 gazColor      // Color for blending\n*/\nvec4 applyEllipse(vec2 uv, vec2 a, vec2 b, vec2 factorA, vec2 factorB, vec3 fbmParam, vec4 color, float intensity, vec4 gazColor) \n{\n    // Compute the distance from the current UV to the ellipse\n    float d = -sdEllipse(uv, a * rot(factorA.y) * factorA.x, b * rot(factorB.y) * factorB.x);\n    \n    // smooth out the distance from the ellipse and clamp it between 0. and 1.\n    d = smoothstep(-0.1, 0.4, d);\n    \n    // use d as a mask for the fractal Brownian motion and blend the two color with the value given from the mask * fbm\n    color = mix(color, gazColor, intensity * d * fbm(uv * fbmParam.x, fbmParam.y, fbmParam.z));\n    \n    // Return the modified color\n    return color;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}