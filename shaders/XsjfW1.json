{
    "Shader": {
        "info": {
            "date": "1500398829",
            "description": "Started a day exercising my shader karate on voronoi : https://thebookofshaders.com/12/",
            "flags": 0,
            "hasliked": 0,
            "id": "XsjfW1",
            "likes": 1,
            "name": "Voroday",
            "published": 3,
            "tags": [
                "raymarching",
                "voronoi"
            ],
            "usePreview": 0,
            "username": "Palliaci",
            "viewed": 510
        },
        "renderpass": [
            {
                "code": "/* By Palliaci\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n */\n#define I_MAX\t20 // Should be at least 50 but my computer is old...\n#define FAR\t\t5.\n#define E\t\t.02 // Could also be switched to 0.002\n#define SCALE\t28.\n#define LIGHTS\n#define REFL_I\t.5\n\nfloat st;\nmat3\trotX( float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat3( 1, 0, 0, 0, c, -s, 0, s, c );\n}\nmat3\trotY( float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat3( c, 0, s, 0, 1, 0, -s, 0, c );\n}\nmat3\trotZ(float a) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat3( c, s, 0, -s, c, 0, 0, 0, 1.0 );\n}\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3\tvoronoi(vec2 uv)\n{\n    // Scaling\n    uv *= SCALE;\n    // Space tiling\n    vec2 i_uv = floor(uv);\n    uv = fract(uv);\n\n    float mdist = 1.;\n    vec2 mpt;\n    for (int y = -1; y <= 1; y++)\n    {\n        for (int x = -1; x <= 1; x++)\n        {\n            vec2 neighbor = vec2(float(x), float(y));\n            vec2 pt = random2(i_uv + neighbor);\n            pt = .5 + .5 * sin(iTime + 6.28*pt);\n            vec2 diff = neighbor + pt - uv;\n            float dist = length(diff);\n            if (dist < mdist)\n            {\n\t            mdist = dist;\n                mpt = pt;\n            }\n        }\n    }\n    return vec3(mdist, mpt);\n}\n\n// Sphere uv mapping from aiekick : https://www.shadertoy.com/view/MtS3DD\nvec3\tvoronoi_sphere_map(vec3 p)\n{\n    //vec2 uv = vec2( atan(n.x, n.z), acos(n.y) );\n    vec2 uv;\n    uv.x = 0.5 + atan(p.z, p.x) / (2.*3.14159);\n    uv.y = 0.5 - asin(p.y) / 3.14159;\n    return voronoi(uv);\n}\n\nfloat\tmap(vec3 p)\n{\n    p *= rotX(.127*iTime) * rotY(.127*iTime);\n    vec3 ret = voronoi_sphere_map(normalize(p));\n//    return length(p) - .5;\n\treturn length(p) - .5 - .05*ret.x;\n//    return length(p) - .5-.05*(1.-ret.x);\n//    return length(p) - .5-.05*ret.x*ret.y*ret.z;\n}\n\nfloat\tmarch(vec3 pos, vec3 dir)\n{\n    float d = 0.;\n    float prec = E;\n    for (int i = -1; i < I_MAX; i++)\n    {\n        prec = map(pos + dir * d);\n        d += prec;\n        if (d < E || d > FAR)\n            break;\n    }\n    return d;\n}\n\nvec3\tcamera(vec2 uv) {\n    float fov = 1.;\n    vec3 forw = vec3( 0.0, 0.0, 1.0 );\n    vec3 right = vec3( 1.0, 0.0, 0.0) ;\n    vec3 up = vec3( 0.0, 1.0, 0.0) ;\n    return ( normalize((uv.x-1.)*right + (uv.y-.5)*up + fov*forw) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    st = sin(.5*iTime);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 pos = vec3(.2, .0, -.85+.08*st)*rotX(iTime*.3);\n    vec3 dir = camera(uv)*rotX(iTime*.3-.1);\n    vec3 col = vec3(.942, .732, .523);\n    \n\tfloat d = march(pos, dir);\n    if (d < FAR)\n    {\n\t\tvec3 p = pos + dir * d;\n        col += voronoi_sphere_map(normalize(p*rotX(.127*iTime) * rotY(.127*iTime)));\n#ifdef LIGHTS\n        vec2 e = vec2(-1., 1.)*0.005;\n        vec3 n = normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );\n\t\tvec3 ev = normalize( p - pos );\n\t\tvec3 ref_ev = reflect( ev, n );\n        vec3 refl_cube = texture(iChannel1, ref_ev).rgb * REFL_I;\n        col *= clamp(refl_cube, .15, 1.);\n        vec3 light_pos = pos + vec3(st, 0., -.1);\n\n        vec3 vl = normalize( light_pos - p );\n\t\tfloat diffuse  = max( 0.001, dot( vl, n ) );\n\t\tfloat specular = pow( max( 0.001, dot( vl, ref_ev ) ), 1. );\n        float\tbrdf = (diffuse + specular) * .5 + .5;\n        col *=  brdf;\n#endif\n    }\n    else\n        col = texture(iChannel1, dir).rgb;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}