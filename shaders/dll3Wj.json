{
    "Shader": {
        "info": {
            "date": "1672462390",
            "description": "Wow, it took some teeth pulling, but this code is nearly completely from chatGPT. I only had to port some of the syntax and Shadertoy specific things to make it work. That and it had a difficult time normalizing the fragment coordinates. ",
            "flags": 0,
            "hasliked": 0,
            "id": "dll3Wj",
            "likes": 0,
            "name": "ChatGPT's Sphere",
            "published": 3,
            "tags": [
                "raymarching",
                "sphere",
                "chatgpt"
            ],
            "usePreview": 0,
            "username": "FoobarBigTime",
            "viewed": 206
        },
        "renderpass": [
            {
                "code": "// Define a function that calculates the signed distance from a point to a sphere\nfloat sphereSDF(vec3 point, vec3 sphereCenter, float sphereRadius) {\n  return length(point - sphereCenter) - sphereRadius;\n}\n\n// Define the main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n  \n  // Define the position and radius of the sphere\n  vec3 sphereCenter = vec3(0, 0, 0);\n  float sphereRadius = 1.0;\n\n  // Define the camera position and field of view\n  vec3 cameraPosition = vec3(0, 0, -2);\n  float fieldOfView = 90.0;\n\n  // Normalize the fragment coordinates\n  vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n  \n  float z = tan(radians(fieldOfView) / 2.0);\n  \n  // Calculate the direction of the ray from the camera to the fragment\n  vec3 rayDirection = normalize(vec3(uv, z));\n\n  // Define the maximum number of iterations\n  int maxIterations = 100;\n\n  // Define the distance from the ray origin to the nearest point on the ray that intersects with the sphere\n  float dist = 0.001; // Initialize the distance to a small value\n\n  // Iterate until the ray intersects with the sphere or the maximum number of iterations is reached\n  for (int i = 0; i < maxIterations; i++) {\n    // Calculate the current position of the ray\n    vec3 rayPosition = cameraPosition + dist * rayDirection;\n\n    // Calculate the signed distance from the current position to the sphere\n    float sdf = sphereSDF(rayPosition, sphereCenter, sphereRadius);\n\n    // Check if the distance to the surface of the sphere is smaller than the threshold\n    if (sdf < 0.001){\n      // The distance to the surface of the sphere is smaller than the threshold, so we can calculate the point of intersection and the surface normal\n      vec3 intersectionPoint = rayPosition;\n      vec3 surfaceNormal = normalize(intersectionPoint - sphereCenter);\n\n      // Use the surface normal to shade the pixel corresponding to the point of intersection\n      fragColor = vec4(surfaceNormal, 1);\n      return;\n    }\n\n    // The distance to the surface of the sphere is larger than the threshold, so we can move the ray along its direction by the distance to the surface of the sphere\n    dist += sdf;\n  }\n\n  // The ray does not intersect with the sphere within the maximum number of iterations, so we can return a background color\n  fragColor = vec4(0, 0, 0, 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}