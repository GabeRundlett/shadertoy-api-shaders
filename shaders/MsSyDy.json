{
    "Shader": {
        "info": {
            "date": "1493762768",
            "description": "Nothing special about it",
            "flags": 0,
            "hasliked": 0,
            "id": "MsSyDy",
            "likes": 9,
            "name": "Wasted land",
            "published": 3,
            "tags": [
                "terrain"
            ],
            "usePreview": 0,
            "username": "Karambit",
            "viewed": 1550
        },
        "renderpass": [
            {
                "code": "#define Scale vec3(.8, .8, .8)\n#define K 19.19\n\n\nconst vec3 BlueSky = normalize(vec3(50.0,119.0,223.0));\nconst vec3 Orange = normalize(vec3(180.0,100.0,36.0))*0.8;\n\nvec3 hash(vec3 p3)\n{\n\tp3 = fract(p3 * Scale);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec3 noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nvec3 fbm(in vec3 q)\n{\n            vec3 f  = 0.5000*noise( q ); q = m*q*2.01;\n            f += 0.2500*noise( q ); q = m*q*2.02;\n            f += 0.1250*noise( q ); q = m*q*2.03;\n            f += 0.0625*noise( q ); q = m*q*2.01; \n            //f += 0.03125*noise( q ); q = m*q*2.01; \n    return vec3(f);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  p.y *= pow(sin(fbm(p*0.3).y), 2.0); \n  return dot(p,n.xyz) + n.w;\n}\n\nfloat map(vec3 p)\n{\n    return sdPlane(p, vec4(0.0, 1.0, 0.0, 1.0));\n}\n\nfloat intersect(in vec3 ro, in vec3 rd)\n{\n    const int ITERATIONS = 80;\n    const float maxD = 60.0;\n    const float minD = 0.0001;\n    float h = 1.0;\n    float t = 0.0;\n    \n    for (int i = 0; i < ITERATIONS; ++i)\n    {\n        if(h < minD || t > maxD)\n            break;\n        \n        h = map(ro+rd*t);\n        t += h;\n    }\n    \n    if(t > maxD) t = -1.0;\n    \n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nvec3 lighting(vec3 p, vec3 ro, vec3 rd)\n{\n    vec3 n = normalize(calcNormal(p));\n    vec3 l = -normalize(ro + vec3(20.,20.0, 2.0) - p );\n    float d = max(dot(-l, n), 0.0);\n    \n    float s = pow(max(dot(reflect(-l, n), rd), 0.0), 2.0);\n    \n    float a = 1.0 / length(ro - p);\n    \n    return vec3(s+d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(sin(iTime*0.05)*10.0, sin(iTime)*0.2, 2.0 - iTime*0.3);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    float t = intersect(ro, rd);\n    \n    vec3 color;\n    vec3 pos = ro+rd*t;\n    vec3 normal = calcNormal(pos);\n    \n    vec3 t1= texture(iChannel1, vec2(pos.x, pos.z)*0.2).rgb;\n    vec3 t2= texture(iChannel0, vec2(pos.x, pos.z)*0.2).rgb;\n    vec3 c = mix(t2, t1, max(dot(normal, vec3(0.0, 1.0, 0.0)), -1.0));\n    \n    c *= lighting(pos, ro, rd)*t2;\n    \n    /**Sky*/\n    vec3 FBM = fbm(vec3(vec2(uv.x, uv.y*2.0), 1.0)*2.0+iTime*0.1);\n    \n    float scatteringFactor = uv.y+0.3;\n    \n    vec3 gradient = mix(normalize(vec3(148, 235, 233)), BlueSky, uv.y/2.0 - 0.5);\n    \n    vec3 SkyColor = mix(Orange, gradient, scatteringFactor);\n    \n    vec3 fgc = mix(vec3(2.0), vec3(0.5), smoothstep(0.0, 1.0, length(uv-vec2(0.0, 1.0))));\n    color = mix(SkyColor*fgc, vec3(0.8), (pow(FBM.x, 3.0))+uv.y);\n    \n    \n    /*------------------------------------------------------*/\n    c = mix(c, color, smoothstep(0.4, 0.8, t/20.0));\n    if(t > 0.0)\n    {\n        color = vec3(c);\n    }\n    \n\tfragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}