{
    "Shader": {
        "info": {
            "date": "1454321222",
            "description": "When the airbags deployed the mission controllers thought they could breath easy but quickly realized they had underestimated one variable... slipperiness.",
            "flags": 32,
            "hasliked": 0,
            "id": "MdVGWh",
            "likes": 23,
            "name": "Mission to Pluto",
            "published": 3,
            "tags": [
                "verlet"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 984
        },
        "renderpass": [
            {
                "code": "//Mission to Pluto by eiffie - I was really just building a landscape for DE 2 DE collision\n//but then tested it with spheres first and got this.\n\n//I have no idea how this performs at different FPS - could be a mess\n\n#define PI 3.14159\n\n//now who did I steal these from ??\n#define inside(a) (fragCoord.y-a.y == 0.5 && fragCoord.x-a.x == 0.5)\n#define load(a) texture(iChannel0,(vec2(a,0.0)+0.5)/iResolution.xy)\n#define save(a,b) if(inside(vec2(a,0.0))){fragColor=b;return;}\n\n#define MASSES 4\n#define RADIUS 0.08\n\n// From IQ's original 3D noise function. Ripped from Desert Canyon by Shane: https://www.shadertoy.com/view/Xs33Df\nfloat noise3D(in vec3 p){\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);p -= ip;p = p*p*(3. - 2.*p);\n\tvec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\nfloat fbm(in vec3 p){\n\tp*=vec3(1.0,0.1,0.75);\n\tfloat g=(sin(p.x+sin(p.z*1.7))+sin(p.z+sin(p.x*1.3)))*0.2;\n\treturn g+noise3D(p)*0.5+noise3D(p*2.3)*0.29;\n}\n\nfloat DE(in vec3 p){\n\tfloat dG=p.y+1.0-fbm(p);\n\treturn dG;\n}\nvec4 mcol=vec4(0.0);\nfloat CE(in vec3 p){\n\tfloat dG=p.y+1.0-fbm(p);\n\tfloat n=1.0-0.7*texture(iChannel1,p.xz).r-0.3*texture(iChannel1,p.xz*2.7).r;//noise3D(p*27.0);\n\tmcol+=vec4(vec3(0.6+n*0.4)*(1.0+p.y*0.5),n);\n\tdG-=n*0.01;\n\treturn dG;\n}\n\nstruct Hit{float t,s; vec3 n;}; //distance, shadow, normal\n\nvoid Sphere( in vec3 ro, in vec3 rd, in vec3 p, in float r, inout Hit H)\n{//intersect a sphere - based on iq's\n\tp=ro-p;\n\tfloat b=dot(p,rd);\n\tfloat h=b*b-dot(p,p)+r*r;\n\tfloat t=-b-sqrt(max(h,0.0));\n\tif(h>0.0 && t>0.0 && t<H.t){\n\t\tH.t=t;\n\t\tH.n=p+rd*t;\n\t}\n\tif(t>0.0)H.s=min(H.s,3.0*max(sqrt(max(0.0,r*r-h))-r,0.0)/t+t*0.25); \n}\n\n#define MAX_DEPTH 100.0\nvoid Intersect(in vec3 ro, in vec3 rd, inout Hit H){\n\tH.t=MAX_DEPTH;H.s=1.0;\n\tfor(int i=0;i<MASSES;i++){//beads\n\t\tvec3 p1=load(i).xyz;\n\t\tSphere(ro,rd,p1,RADIUS,H);\n\t}\n}\n\nfloat ShadAO(in vec3 ro, in vec3 rd){//like iq's with added sphere soft shad from iq\n\tfloat t=0.01,s=1.0,d,mn=t;\n\tfor(int i=0;i<12;i++){\n\t\td=max(DE(ro+rd*t)*1.2,mn);\n\t\ts=min(s,d/t+t*0.25);\n\t\tt+=d;\n\t}\n\tHit H;\n\tIntersect(ro,rd,H);\n\ts=min(s,H.s);\n\treturn 0.3+0.7*s;\n}\n\nvec3 scene(vec3 ro, vec3 rd){\n\tfloat t=0.0,d,px=1.0/iResolution.y;\n\tfor(int i=0;i<64;i++){\n\t\tt+=d=DE(ro+rd*t);\n\t\tif(t>MAX_DEPTH || d<px*t)break;\n\t}\n\tt=min(t,MAX_DEPTH);\n\tvec3 col=vec3(0.9,0.95,1.0)*max(0.0,0.5-abs(rd.y)),N,L=normalize(vec3(0.4,0.8,-0.5));\n    col+=vec3(1.0)*pow(max(0.0,dot(rd,L)),500.0);\n\tHit H;\n\tIntersect(ro,rd,H);\n\tif(H.t<t){\n\t\tro+=rd*(H.t-px);\n\t\tN=normalize(H.n);\n\t\tmcol=vec4(0.6-dot(N,rd)*0.3,0.6,0.5,1.0);\n\t\tt=H.t;\n\t\td=0.0;\n\t}else if(d<20.0*px*t){\n\t\td=DE(ro+rd*t);if(d<0.0)t+=d*2.0;\n\t\tro+=rd*t;\n\t\tvec2 v=vec2(px*t,0.0);\n\t\tN=normalize(vec3(CE(ro+v.xyy)-CE(ro-v.xyy),CE(ro+v.yxy)-CE(ro-v.yxy),CE(ro+v.yyx)-CE(ro-v.yyx)));\n\t\tmcol/=6.0;\n\t\td=0.0;\n\t}\n\tif(d==0.0){//hit\n\t\tfloat dif=max(0.0,dot(N,L));\n\t\tfloat shad=(dif>0.0?ShadAO(ro,L):0.0);\n\t\tfloat spc=pow(max(0.0,dot(reflect(rd,N),L)),5.0);\n\t\tfloat fre=1.0+dot(rd,N);\n\t\tfloat amb=max(0.0,-N.y);\t\n\t\tvec3 scol=mcol.rgb*clamp(0.3+dif*(1.0-0.5*fre)*shad+mcol.a*spc*fre+amb*0.1,0.0,1.0);\n\t\tfloat ct=iTime;\n\t\tfor(int i=0;i<8;i++){\n\t\t\tro-=rd*0.1;\n\t\t\tfloat n=(1.0-0.6*noise3D((ro+vec3(0.0,0.0,ct))*3.0)-0.4*noise3D((ro+vec3(ct,0.0,ct))*9.0));\n\t\t\tscol+=vec3(0.4)*clamp(-0.25-ro.y,0.0,1.0)*n*n;\n\t\t}\n\t\tcol=mix(col,scol,exp(-t*0.08));\n\t}\n\treturn col;\n}\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec3 ro=load(MASSES*2).xyz;\n    vec3 tg=load(MASSES*2+1).xyz;\n\tvec3 bl=load(0).xyz;\n\tvec3 rd=normalize(vec3((2.0*fragCoord-iResolution.xy)/iResolution.y,1.0));\n\trd=lookat(0.2*(bl-ro)+(ro-tg)-vec3(0.0,1.0,0.0))*rd;\n\tfragColor=vec4(scene(ro,rd),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159\n\n#define inside(a) (fragCoord.y-a.y == 0.5 && fragCoord.x-a.x == 0.5)\n#define load(a) texture(iChannel0,(vec2(a,0.0)+0.5)/iResolution.xy)\n#define save(a,b) if(inside(vec2(a,0.0))){fragColor=b;return;}\n\n\n//the verlet routines\n#define AIR_RESISTANCE 0.4\n#define SURFACE_HARDNESS 0.99\n#define GLOBAL_FORCE vec3(0.0,-0.1,-0.05)\n// Radius of particles (the connections DO NOT interact with the surface)\n#define RADIUS 0.08\n// Number of particles\n#define MASSES 4\n#define REST_LENGTH 0.1414\n\n// From IQ's original 3D noise function. Ripped from Desert Canyon by Shane: https://www.shadertoy.com/view/Xs33Df\nfloat noise3D(in vec3 p){\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);p -= ip;p = p*p*(3. - 2.*p);\n\tvec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\nfloat fbm(in vec3 p){\n\tp*=vec3(1.0,0.1,0.75);\n\tfloat g=(sin(p.x+sin(p.z*1.7))+sin(p.z+sin(p.x*1.3)))*0.2;\n\treturn g+noise3D(p)*0.5+noise3D(p*2.3)*0.29;\n}\n\nfloat DE(in vec3 p){\n\tfloat dG=p.y+1.0-fbm(p);\n\treturn dG;\n}\n\nvoid StickConstraint(inout vec3 cp, in vec3 cp2){\n\tvec3 delta=cp2-cp;\n\tfloat deltaLength=length(delta),offset=deltaLength-REST_LENGTH;\n\tcp+=delta*0.2*offset/deltaLength;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tif(fragCoord.y>1.0 || fragCoord.x>float(MASSES*2)+2.0)discard;\n\tvec4 state=vec4(-2.0,1.0,0.0,iTime);//x=last tick,y=total\n    vec4 lstate=state*1.1;\n\tif(iFrame>0){\n\t\tstate=load(MASSES*2);\n        lstate=lstate*0.7+state*0.3;\n\t\tvec3 tg=load(0).xyz+vec3(0.0,0.25,0.0)-state.xyz;\n\t\tstate.xyz+=tg*0.1;\n\t}\n\tfloat deltaTime=iTime-state.w;\n\tstate.w=iTime;\n\tsave(MASSES*2,state);\n    save(MASSES*2+1,lstate);\n\t\n\tif(fragCoord.x<float(MASSES*2)){\n\t\tvec3 cp,pp;//current position, previous position\n\t\tfloat i=mod(floor(fragCoord.x),4.0);\n\t\tif(iFrame==0){//initialize\n\t\t\tif(i<0.5)cp=vec3(0.0,1.1,0.0);\n\t\t\telse if(i<1.5)cp=vec3(0.0,1.0,0.1);\n\t\t\telse if(i<2.5)cp=vec3(0.071,1.0,-0.071);\n\t\t\telse cp=vec3(-0.071,1.0,-0.071);\n\t\t\tpp=cp-GLOBAL_FORCE*iTimeDelta;\n\t\t}else{//load\n\t\t\tcp=load(i).xyz;pp=load(i+4.0).xyz;\n\t\t\tfloat visc=1.0-AIR_RESISTANCE*deltaTime;\n\t\t\t\n\t\t\t//add forces\n\t\t\tvec3 G=(GLOBAL_FORCE+vec3(sin(iTime+2.4*sin(iTime*0.23))*0.01,0.0,0.0));\n\t\t\tcp+=G*deltaTime;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t//satisfy DE constraint\n\t\t\tfloat d=DE(cp);\n\t\t\tif(d<RADIUS){\n\t\t\t\tvec2 v=vec2(RADIUS,0.0);\n\t\t\t\tvec3 N=normalize(vec3(DE(cp+v.xyy)-DE(cp-v.xyy),DE(cp+v.yxy)-DE(cp-v.yxy),DE(cp+v.yyx)-DE(cp-v.yyx)));\n\t\t\t\tvec3 vel=cp-pp;//the velocity\n\t\t\t\tif(dot(N,vel)<0.0)vel=reflect(vel,N)*SURFACE_HARDNESS;//if moving toward surface bounce\n\t\t\t\tcp+=N*(RADIUS-d);\n\t\t\t\tpp=cp-vel;//*visc;\n\t\t\t}\n\t\t\t\n\t\t\t//satisfy stick constraints\n\t\t\tfor(float j=1.0;j<4.0;j+=1.0){\n\t\t\t\tvec3 cp2=load(mod(i+j,4.0)).xyz;\n\t\t\t\tStickConstraint(cp,cp2);\n\t\t\t}\n\t\t\t\n\t\t\t//innertia\n\t\t\tvec3 tmp=cp;\n\t\t\tcp+=(cp-pp)*visc;\n\t\t\tpp=tmp;\n\t\t\t\n\t\t}\n\t\tsave(i,vec4(cp,0.0));\n\t\tsave(i+4.0,vec4(pp,0.0));\n\t}\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}