{
    "Shader": {
        "info": {
            "date": "1568130222",
            "description": "Could be more concise with the code but this is just a test to see how it'll look like.\n\nI did not trace all the rays according to fresnel, but just the first bounce and the internal refractions. Figured that's all it needs to look realistic.",
            "flags": 0,
            "hasliked": 0,
            "id": "wstGR7",
            "likes": 5,
            "name": "Cube Red Glass",
            "published": 3,
            "tags": [
                "cube",
                "glass",
                "beer",
                "fresnel"
            ],
            "usePreview": 0,
            "username": "JuliaPoo",
            "viewed": 468
        },
        "renderpass": [
            {
                "code": "const float END = 10.;\nconst float ep = 0.001;\n\nmat3 rot3(float a, float b, float c){\n    \n    float s_, c_;\n    s_ = sin(a);\n    c_ = cos(a);\n\tmat3 A = mat3(vec3(c_,s_,0.), vec3(-s_,c_,0.), vec3(0.,0.,1.));\n    s_ = sin(a);\n    c_ = cos(a);\n\tmat3 B = mat3(vec3(c_,0.,s_), vec3(0.,1.,0.), vec3(-s_,0.,c_));\n    s_ = sin(a);\n    c_ = cos(a);\n\tmat3 C = mat3(vec3(1.,0.,0.), vec3(0.,c_,s_), vec3(0.,-s_,c_));\n    \n    return A*B*C;\n}\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat hash3(vec3 p){\n\treturn fract(12345.6789 * sin(dot(p, vec3(12.34, 56.78, 91.01))));\n}\n\nfloat smoothmin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smoothmax(float a, float b, float k){\n\treturn -smoothmin(-a, -b, k);\n}\n\nfloat cube(vec3 p, float b, float r){\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) - r + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sphere(vec3 p, float r){\n \treturn length(p) - r;  \n}\n\nfloat SDscene(vec3 p){\n\tfloat k = .6;\n    vec3 shake = 0.1*vec3(sin(iTime*3.), cos(iTime*2.), sin(iTime*4.));\n    p = ((p + shake)/k);\n    p *= rot3(0., iTime, .0);\n    \n    float d;\n    \n    //d = max(cube(p*rot3(iTime, 0., 0.)), cube(p*rot3(-iTime, 0., 0.)))*k;\n    \n    //float sphere1 = sphere(p + shake * -13., .5);\n    //d = smoothmin(cube(p*rot3(iTime*0.3, 0., 0.)), sphere1, 1.);\n    \n\tfloat cube = cube(p*rot3(iTime*.3, 0., 0.), 1., 1.);\n    d = cube;\n    \n    return d*k;\n}\n\nvec3 SDnormal(vec3 p){\n    \n    //Calculates the normal vector of SDscene\n    \n    return normalize(vec3(\n    SDscene(vec3(p.x+ep,p.y,p.z))-SDscene(vec3(p.x-ep,p.y,p.z)),\n    SDscene(vec3(p.x,p.y+ep,p.z))-SDscene(vec3(p.x,p.y-ep,p.z)),\n    SDscene(vec3(p.x,p.y,p.z+ep))-SDscene(vec3(p.x,p.y,p.z-ep))\n    ));\n}\n\nfloat depth(vec3 ro, vec3 rd, float sig){\n    \n    //Returns depth from ro given raydirection\n    \n    int max=300;\n    \n    float dist=0., d;\n    for (int i=0; i<max; i++){\n    \td = SDscene(ro + dist*rd)*sig;\n    if (d<ep){\n        return dist;\n    }\n    dist += d;\n    if (dist > END){\n        return END;\n    }\n  }\n}\n\nvoid reflection(vec3 ro, vec3 rd, out vec3 col){\n    \n    float d;\n    int Nmax = 8, count = 0;\n    while (d < END && count < Nmax){\n        rd = normalize(reflect(-rd, SDnormal(ro)));\n        d = depth(ro, rd, 1.);\n        ro += d*rd;\n        count += 1;\n    }\n    \n    //vec3 tintcol = vec3(.99, 1., .99), tint = vec3(1.);\n    //for (int i=0; i<=count; i++){tint *= tintcol;}\n    \n    col = texture(iChannel0, ro).rgb;\n}\n\nvoid refraction(vec3 ro, vec3 rd, out vec3 col){\n    \n    float d, D;\n    int Nmax = 8, count = 0, count2 = 0;\n    vec3 p, rd_;\n    while (d<END && count < Nmax){\n        \n        //Go into glass\n        ro += rd * ep*10.;\n        rd = normalize(refract(rd, SDnormal(ro), 0.6));\n        d = depth(ro, rd, -1.);\n        ro += rd * d;\n    \tD += d;\n        \n        //internal refraction\n    \trd_ = refract(-rd, -SDnormal(ro), 1.5);\n       \twhile (length(rd_) < 0.0000001 && count2 < Nmax){\n            rd = normalize(reflect(-rd, -SDnormal(ro)));\n            d = depth(ro, rd, -1.);\n            ro += d*rd;\n            D += d;\n            rd_ = refract(-rd, -SDnormal(ro), 1.5);\n            count2 += 1;\n        }\n  \n        if (length(rd_) > 0.0000001){rd = normalize(rd_);}\n        ro += rd * ep*10.;\n        d = depth(ro, rd, 1.);\n        ro += rd * d;\n      \t\n\t\tcount += 1;\n    }\n    \n    //float k = .5;\n    vec3 tint = vec3(exp(D*-0.05),exp(D*-0.7),exp(D*-0.7));\n    \n    col = texture(iChannel0, ro).rgb * tint;\n}\n\nvoid fresnel(vec3 ro, vec3 rd, out float refl, out float refr){\n \t   \n   \tfloat b = ((1. - 1.5)/(1. + 1.5));\n    float r0 = b*b;\n    refl = r0 + (1. - r0)*pow((1. - abs(dot(SDnormal(ro), normalize(rd)))), 5.);\n    refr = 1.-refl;\n    //refl = .5; refr = .5;\n}\n\nvoid render(in vec2 uv, out vec3 col){\n    \n    \n    //Camera\n    float ScreenSize = 4.;\n    float shake = 0.3*sin(.3*iTime);\n    \n    float zoom = 2.;\n    float k = 0.4;\n  \tvec3 ro = 3.*vec3(sin(k*iTime), shake, cos(k*iTime));\n  \tvec3 lookat = vec3(0,0,0);\n    \n    \n  \tvec3 fw = normalize(lookat - ro);\n  \tvec3 r = normalize(cross(vec3(0,1.,0), fw));\n  \tvec3 up = normalize(cross(fw,r));\n  \tvec3 scrC = ro + (zoom)*fw;\n  \tvec3 scrP = scrC + (uv.x*r + uv.y*up) * ScreenSize;\n  \tvec3 rd = normalize(scrP - ro);\n    \n    float d = depth(ro, rd, 1.);\n    ro += d*rd;\n    \n    //hits background\n    if (d == END){col = texture(iChannel0, ro).rgb;}\n    \n\t//hit obj\n    if (SDscene(ro) < ep){\n        //col = vec3(1.);\n        vec3 col_refract, col_reflect;\n        refraction(ro, rd, col_refract);\n        reflection(ro, rd, col_reflect);\n        \n        float refl, refr;\n        fresnel(ro, rd, refl, refr);\n            \n        col = refr*col_refract + refl*col_reflect;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //Shader setup\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord / R-.5;\n    uv.y *= R.y/R.x;\n    \n    vec3 col;\n    render(uv, col);\n    fragColor = vec4(col, 1.);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}