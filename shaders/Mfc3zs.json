{
    "Shader": {
        "info": {
            "date": "1712286922",
            "description": "Relatively basic ~~effective reupload of a couple people's work~~ shader made to look somewhat satisfying :3 kinda sorta based on those satisfying animations all over youtube. I could definitely make it a *lot* smaller but ehhhhh I don't rlly feel like it",
            "flags": 0,
            "hasliked": 0,
            "id": "Mfc3zs",
            "likes": 11,
            "name": "Satisfying tubes",
            "published": 3,
            "tags": [
                "raymarching",
                "softshadows",
                "infinite",
                "satisfying"
            ],
            "usePreview": 0,
            "username": "Oman395",
            "viewed": 153
        },
        "renderpass": [
            {
                "code": "const vec3 CAM = vec3(7, 1, -1);\nconst float PI = 3.14159265;\nconst float FOCUS = 2.5;\n\nconst vec3 BG_COLOR = vec3(240, 198, 198) / 255.0;\nconst vec3 OBJECT_COLOR = vec3(145, 215, 227) / 255.0;\n\nvec3 rotate(vec3 vec, vec2 angles) {\n    angles = angles.yx;\n    vec = vec3(\n        vec.x,\n        vec.y * cos(angles.x) - vec.z * sin(angles.x),\n        vec.y * sin(angles.x) + vec.z * cos(angles.x)\n    );\n    vec = vec3(\n        vec.x * cos(angles.y) + vec.z * sin(angles.y),\n        vec.y,\n        -vec.x * sin(angles.y) + vec.z * cos(angles.y)\n    );\n    return vec;\n}\n\nvec3 camPos(float iTime, vec2 iMouse) {\n    return CAM;\n}\n\nvec2 camDir(float iTime, vec2 iMouse) {\n    return vec2(-PI * 0.6, PI * 0.02);\n}\n\n// Most ray marching code \"borrowed\" from https://www.shadertoy.com/view/Xds3zN, \n// https://iquilezles.org/articles/distfunctions/, and\n// https://iquilezles.org/articles/rmshadows/\n// Inigo Quilez is the absolute most based person in existence tbh\nfloat sdPlane( vec3 p, vec3 n, float h ) {\n  // n must be normalized\n  return dot(p,n) + h;\n}\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\n\nfloat sdCylinder( vec3 p, vec2 h ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 map(vec3 p) {\n    float theta = 0.5 * PI * iTime;\n    theta += 0.05 * PI * floor((p.z + 0.5 * iTime) / 2.5);\n    theta *= -1.0;\n    theta += PI * 1.2;\n    p.z = mod(p.z + 0.5 * iTime, 2.5) - 1.25;\n    float cd = sdTorus(p.yzx - vec3(-1.5, 0, -4), vec2(4, 0.5));\n    cd = max(-sdPlane(p - vec3(-4, -1.5, 0), vec3(cos(theta), sin(theta), 0), 0.0), cd);\n    cd = min(sdCylinder(p.yxz - vec3(2.5,-5,0), vec2(0.5, 1.01)), cd);\n    float d = cd;\n    int inter = 0;\n    cd = max(-sdCylinder(p, vec2(0.5, 5.0)), -sdBox(p - vec3(19, 10.5, 0), vec3(22, 11, 50)) + 1.0);\n    if(cd < d) {\n        inter = 1;\n        d = cd;\n    }\n    return vec2(d, inter);\n}\n\nvec2 march( in vec3 ro, in vec3 rd, float mint, float maxt) {\n    float t = mint;\n    int mostRecent = -1;\n    for(int i=0; i<256 && t<maxt; i++) {\n        vec2 ma = map(ro + t*rd);\n        float h = ma.x;\n        mostRecent = int(ma.y);\n        t += h;\n        if(t>maxt ) {\n            return vec2(t, -1);\n        }\n        if(h < mint) break;\n    }\n    return vec2(\n        t,\n        mostRecent\n    );\n}\n\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float w ) {\n    float res = 1.0;\n    float t = mint;\n    int mostRecent = -1;\n    for(int i=0; i<256 && t<maxt; i++) {\n        float h = map(ro + t*rd).x;\n        res = min( res, h/(w*t) );\n        t += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>maxt ) break;\n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n}\n\n// Based on code found on a discord server lmfao\nfloat ao(vec3 ro, vec3 norm, float stepSize, int stepCount) {\n\tfloat res = 0.0;\n\tvec3 rp;\n\t// TBH I like vaguely understand how this works but not enough to explain it\n\tfor(int i = 1; i< stepCount; i++) {\n\t\trp = ro + stepSize * float(i) * norm;\n\t\tres += (1.0/pow(2.0,float(i)))*(stepSize*float(i)-(map(rp).x));\n\t}\n\tif(res >= 0.0) {\n\t\treturn 1.0 - clamp(1.0 - stepSize / res, 0.0, 1.0);\n\t}\n    else return 1.0;\n}\n\n\nvec3 normal( in vec3 p ) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n}\n\n// https://github.com/glslify/glsl-specular-beckmann/blob/master/distribution.glsl\nfloat beckmannDistribution(float x, float roughness) {\n  float NdotH = max(x, 0.0001);\n  float cos2Alpha = NdotH * NdotH;\n  float tan2Alpha = (cos2Alpha - 1.0) / cos2Alpha;\n  float roughness2 = roughness * roughness;\n  float denom = 3.141592653589793 * roughness2 * cos2Alpha * cos2Alpha;\n  return exp(tan2Alpha / roughness2) / denom;\n}\n\nfloat cookTorranceSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.0);\n  float VdotH = max(dot(viewDirection, H), 0.000001);\n  float x = 2.0 * NdotH / VdotH;\n  float G = min(1.0, min(x * VdotN, x * LdotN));\n  \n  //Distribution term\n  float D = beckmannDistribution(NdotH, roughness);\n\n  //Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\n  //Multiply terms and done\n  return  G * F * D / max(3.14159265 * VdotN * LdotN, 0.000001);\n}\n\n\n// https://github.com/glslify/glsl-diffuse-oren-nayar/blob/master/index.glsl\nfloat orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / PI;\n}\n\n// https://github.com/dmnsgn/glsl-tone-map/blob/main/aces.glsl\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvN = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uvN.x *= iResolution.x / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = (mouse - 0.5) * 2.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec3 pos = camPos(iTime, mouse);\n    vec2 dir = camDir(iTime, mouse);\n    vec3 rayDir = normalize(vec3(uvN, FOCUS));\n    rayDir = rotate(rayDir, dir);\n    vec3 light = CAM + vec3(0,0,5);\n    vec2 impactData = march(pos, rayDir, 0.01, 20.0);\n    float energy = 1.0;\n    if(impactData.y >= 0.0) {\n        vec3 color;\n        float roughness, diffuseAlbedo;\n        vec3 specular;\n        if(impactData.y == 0.0) {\n            color = OBJECT_COLOR;\n            roughness = 0.1;\n            diffuseAlbedo = 1.0;\n            specular = vec3(1);\n        } else {\n            color = BG_COLOR;\n            roughness = 1.0;\n            diffuseAlbedo = 1.0;\n            specular = vec3(0);\n        }\n        vec3 impactPos = pos + rayDir * impactData.x;\n        vec3 impactNormal = normal(impactPos);\n        vec3 impactToLight = normalize(light - impactPos);\n        vec3 incomingLight = color * orenNayarDiffuse(impactToLight, normalize(pos - impactPos), impactNormal, roughness, diffuseAlbedo); // kd\n        incomingLight += specular * cookTorranceSpecular(impactToLight, normalize(pos - impactPos), impactNormal, roughness, 0.5); // ks\n        incomingLight *= softShadow(impactPos, impactToLight, 0.1, distance(impactPos, light), 0.3);\n        incomingLight /= pow(distance(impactPos, light) / 10.0, 2.0);\n        incomingLight *= energy;\n        \n        incomingLight += 0.8 * color * (0.7 + 0.3 * pow(ao(impactPos, impactNormal, 0.2, 6), 0.5)); // ka\n        fragColor = vec4(aces(incomingLight), 1);\n    } else fragColor = vec4(0);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}