{
    "Shader": {
        "info": {
            "date": "1688468066",
            "description": "water direction",
            "flags": 0,
            "hasliked": 0,
            "id": "dssfR8",
            "likes": 0,
            "name": "water direction",
            "published": 3,
            "tags": [
                "waterdirection"
            ],
            "usePreview": 0,
            "username": "tianluo970922",
            "viewed": 204
        },
        "renderpass": [
            {
                "code": "// Found this on GLSL sandbox. I really liked it, changed a few things and made it tileable.\n// :)\n// by David Hoskins.\n// Original water turbulence effect by joltz0r\n\n\n// Redefine below to see the tiling...\n//#define SHOW_TILING\nconst vec2 target_resolution = vec2(940, 86);\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat time = iTime * .5 + 23.0;\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n    uv += .5;\n    uv.y -= 0.5/r - 0.5; \n    \n    vec2 uv0 = uv; \n    uv0.x *= 3.;\n    //uv0.x += iTime * 0.3;\n    uv0.y *= 1.;\n    uv0.y -= iTime * 0.1;\n  \n    \n    vec2 p = mod(uv0*TAU, TAU) - 250.0;\n    \n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .009;\n    \n    //通过算法测算出water的pattern，通过增大tiling的值可以增大pattern的密度\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (1.0 - (2.5/ float(n+1)));\n        float t1= time * .2;\n\t\ti = p + vec2(cos(t1 - i.x) + sin(t + i.y), sin(t - i.y) + cos(t1 + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+ t1)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n    \n\tc /= float(MAX_ITER);\n    \n    //1.12 可以调整白色的对比度，数值越高，对比度越高\n    //1. 1可以调整蓝色的深浅,数值越高，蓝色越浅，白色越多且会过曝\n\tc = 1.2 - pow(c, 1.1);\n    \n    //7.5可以调整蓝色的深浅，数值越高，蓝色越深，但不会影响白色的细节\n\tvec3 colour = vec3(pow(abs(c), 10.5));\n    colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\n    \n\t#ifdef SHOW_TILING\n\t// Flash tile borders...\n\tvec2 pixel = 2.0 / iResolution.xy;\n\tuv *= 2.0;\n\tfloat f = floor(mod(iTime*.5, 2.0)); \t// Flash value.\n\tvec2 first = step(pixel, uv) * f;\t\t   \t// Rule out first screen pixels and flash.\n\tuv  = step(fract(uv), pixel);\t\t\t\t// Add one line of pixels per tile.\n\tcolour = mix(colour, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y); // Yellow line\n\t#endif\n    \n    float timeMotion = smoothstep(0.0, 1.0, sin(iTime) * 0.5 + 0.5 + sin(iTime * 0.2) * 0.5);\n    //float timeMotion = sin(iTime) * 0.5 + 0.5;\n    \n    //headColor\n    vec3 headColor = vec3(1.000,1.000,1.000); \n\t//headColor *= pow(uv.y,  3.5) ; //起始\n    //headColor *= pow(uv.y,  10.5) ; //结束\n    headColor *= pow(uv.y, mix(3.5, 10.5, timeMotion));\n    colour *= mix(1.0, 0.8, timeMotion);\n    fragColor = vec4(colour + headColor, 1.0);\n    \n    //endColor\n    vec3 endColor = vec3(0.000,0.118,0.200); \n    float endColorMask1 = smoothstep(0.0, 0.2,uv.y);\n    float endColorMask2 = smoothstep(0.1, 0.9,uv.y);\n    //fragColor.rgb = mix(endColor, fragColor.rgb, endColorMask1); //起始\n    //fragColor.rgb = mix(endColor, fragColor.rgb, endColorMask2); //结束\n    fragColor.rgb = mix(endColor, fragColor.rgb, mix(endColorMask1,endColorMask2, timeMotion));\n    \n    //结尾的mask\n    float mask = pow(uv.y, 1.0);\n    //0.492的值越小，黑色边缘越硬\n    mask = smoothstep(0.0,0.472,uv.y);\n    \n    //fragColor *= (mask);\n    //fragColor = vec4(endColor, 1.0);\n    //fragColor = vec4(mask);\n    \n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}