{
    "Shader": {
        "info": {
            "date": "1711981059",
            "description": "CC0: Attempt at VDJ effects\nInspired by the Revision VDJ:ng I wanted to try something similar.\n\nMusic by the great Neon Workout - We are the Robots Baby: \nSoundcloud: https://soundcloud.com/no-om-uo-n/we-are-the-robots-baby\n",
            "flags": 64,
            "hasliked": 0,
            "id": "XctGzf",
            "likes": 31,
            "name": "Attempt at VDJ effects",
            "published": 3,
            "tags": [
                "vdj"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 565
        },
        "renderpass": [
            {
                "code": "// CC0: Attempt at VDJ effects\n//   Inspired by the Revision VDJ:ng I wanted to try something similar.\n\n// If nothing happens try hitting pause and play to trigger the audio to load.\n\n\n#define TIME        (iChannelTime[0])\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define BPM         60.\n\n\n#define NONE        0\n\n#define COMPUTER    1\n#define FREQ1       2\n#define FREQ2       3\n\n#define EFFECT0     1\n#define EFFECT1     2\n#define EFFECT2     3\n#define EFFECT3     4\n#define EFFECT4     5\n\n#define FLASH       1\n\n#define SCRIPT(a,b,c) ((a << 3)+(b<<1)+c)\n\nconst int g_scriptCount = 29;\n\nconst int[] g_script = int[g_scriptCount](\n    SCRIPT(NONE   , COMPUTER, NONE)\n  , SCRIPT(EFFECT0, FREQ1   , FLASH)\n  , SCRIPT(EFFECT4, FREQ1   , FLASH)\n  , SCRIPT(EFFECT1, FREQ1   , FLASH)\n  , SCRIPT(EFFECT1, FREQ1   , FLASH)\n  , SCRIPT(EFFECT4, FREQ2   , FLASH)\n  , SCRIPT(EFFECT4, FREQ2   , FLASH)\n  , SCRIPT(EFFECT0, COMPUTER, FLASH)\n  , SCRIPT(EFFECT0, COMPUTER, FLASH)\n  , SCRIPT(EFFECT4, COMPUTER, FLASH)\n  , SCRIPT(EFFECT4, COMPUTER, FLASH)\n  , SCRIPT(EFFECT1, FREQ1   , FLASH)\n  , SCRIPT(EFFECT1, FREQ1   , FLASH)\n  , SCRIPT(EFFECT4, FREQ2   , FLASH)\n  , SCRIPT(EFFECT3, FREQ2   , FLASH)\n  , SCRIPT(EFFECT2, FREQ2   , FLASH)\n  , SCRIPT(EFFECT2, FREQ2   , FLASH)\n  , SCRIPT(EFFECT1, FREQ2   , FLASH)\n  , SCRIPT(EFFECT1, FREQ2   , FLASH)\n  , SCRIPT(EFFECT4, FREQ1   , FLASH)\n  , SCRIPT(EFFECT0, FREQ1   , FLASH)\n  , SCRIPT(EFFECT3, COMPUTER, FLASH)\n  , SCRIPT(EFFECT3, COMPUTER, FLASH)\n  , SCRIPT(EFFECT2, FREQ2   , FLASH)\n  , SCRIPT(EFFECT2, FREQ2   , FLASH)\n  , SCRIPT(EFFECT1, FREQ2   , FLASH)\n  , SCRIPT(EFFECT1, FREQ2   , FLASH)\n  , SCRIPT(NONE   , COMPUTER, NONE )\n  , SCRIPT(NONE   , COMPUTER, NONE )\n  );\n\nint g_mainEffect;\nint g_flash;\n\nfloat g_ntime;\nfloat g_ftime;\nfloat g_btime;\nmat2 g_rot0;\nmat2 g_rot1;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3 lightDir0    = normalize(vec3(-1.,-1., 0.));\nconst vec3 lightCol0    = HSV2RGB(vec3(0.6, .2, 1E-2));\nconst vec3 lightDir1    = normalize(vec3(1.,1., -1.));\nconst vec3 lightCol1    = HSV2RGB(vec3(0.6, 0.2, 2E-3));\nconst vec3 bottomBoxCol = HSV2RGB(vec3(0.7, 0.5, 0.25));\nconst vec3 topBoxCol    = HSV2RGB(vec3(0.6, 0.2, 0.95));\nconst vec3 sbase        = HSV2RGB(vec3(0.0, 0.9, 1.));\nconst vec3 seye         = HSV2RGB(vec3(0.03, 0.75, 16.));\nconst vec3 sbase4       = HSV2RGB(vec3(0.6, 0.6, 1.));\nconst vec3 glowCol      = HSV2RGB(vec3(0.0, 0.9, 1E-3));\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n\n}\n\n// License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = 2.*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.)) c = abs(c);\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sphere(vec3 p, float t) {\n  return length(p)-t;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat circle4(vec2 p, float r) {\n  p *= p;\n  return pow(dot(p, p), 0.25) - r;\n}\n\nfloat plane(vec2 p, vec3 pp) {\n  return dot(p, pp.xy)+pp.z;\n}\n\nfloat segmenty(vec2 p, float h, float w) {\n  float hh = 0.5*h;\n  p.y = abs(p.y);\n  p.y -= hh;\n  float d0 = length(p);\n  float d1 = abs(p.x);\n  float d = p.y > 0.0 ? d0 : d1;\n  d -= w;\n  return d; \n}\n\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors/\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n \nfloat dfeffect0(vec2 p, vec2 pp) {\n  float csz = 0.3;\n  csz /= 1.-0.5*length(pp)*sqrt(0.5)*(g_ftime*g_ftime*g_ftime);\n  float sm = csz+.4*csz;\n  vec2 dp = p;\n  vec2 dn = mod2(dp, vec2(csz));\n  float ddots = length(dp);\n  vec2 adp = abs(dp);\n  float dgrid = min(adp.x, adp.y);\n  float tm = sqrt(0.5)*g_btime;\n  float dblobs = 1E3;\n  for (float i = 0.; i < 5.; ++i) {\n    vec2 a = vec2(1., sqrt(0.5))*tm+vec2(i, i*i);\n    vec2 o = csz*vec2(sin(a))*4.;\n    float dd = circle(p-o, csz*0.5);\n    dblobs = pmin(dblobs, dd, sm);\n  }\n\n  float d = 1E6;\n  d = min(d, ddots);\n  d = pmin(d, (dblobs), sm);\n  return d;\n}\n\n// From Evil Ryu Mandelbox - https://www.shadertoy.com/view/XdlSD4\n\nconst float fixed_radius2 = 1.9;\nconst float min_radius2   = 0.5;\nconst float folding_limit = 1.0;\nconst float scale         = -2.8;\n\nvec3 pmin(vec3 a, vec3 b, vec3 k) {\n  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n        float temp = (fixed_radius2 / min_radius2);\n        z *= temp;\n        dz *= temp;\n    } else if(r2 < fixed_radius2) {\n        float temp = (fixed_radius2 / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvoid box_fold(inout vec3 z, inout float dz) {\n  const float k = 0.05;\n  // Soft clamp after suggestion from ollij\n  vec3 zz = sign(z)*pmin(abs(z), vec3(folding_limit), vec3(k));\n  // Hard clamp\n  // z = clamp(z, -folding_limit, folding_limit);\n  z = zz * 2.0 - z;\n}\n\n\nfloat mb(vec3 z) {\n    vec3 offset = z;\n    float dr = 1.0;\n    float fd = 0.0;\n    for(int n = 0; n < 5; ++n) {\n        box_fold(z, dr);\n        sphere_fold(z, dr);\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 1.0;        \n        float r1 = sphere(z, 5.0);\n        float r2 = torus(z, vec2(8.0, 1));\n        r2 = abs(r2) - 0.25;\n        float r = n < 4 ? r2 : r1;        \n        float dd = r / abs(dr);\n        if (n < 3 || dd < fd) {\n          fd = dd;\n        }\n    }\n    return (fd);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat dfeffect1(vec2 p, vec2 pp) {\n  const float s = sqrt(.5);\n  p /= s;\n  float rep = 20.0;\n  float ss = 0.05*6.0/rep;\n  vec3 p3 = vec3(p.x, p.y, 0.5+g_ftime*g_ftime);\n  p3.xz*=g_rot0;\n  p3.yz*=g_rot1;\n  float n = smoothKaleidoscope(p3.xy, ss, rep);\n  float d = mb(p3)*s;\n  return abs(d);\n}\n\n\nfloat apollonian(vec3 p, float s) {\n  vec3 op = p;\n  float scale = 1.;\n  float sc = 0.55*s;\n  float tsc = sc;\n  float ssc = 1.;\n  for(int i=0; i < 5; ++i) {\n    p = -1.0 + 2.0*fract(0.5*p+0.5);\n    float r2 = tanh(dot(p,p)/tsc)*tsc;\n    float k  = s/r2;\n    p       *= k;\n    scale   *= k;\n  }\n  \n  vec3 ap = abs(p/scale);\n#define X1  \n#if defined(X0)  \n  float d = ap.x;\n  d = min(d, length(ap.yz));\n#elif defined(X1)\n  float d = ap.x;\n  d = min(d, abs(length(ap.yz-0.08*(g_ftime))-0.0025));\n#else\n  float d = ap.x;\n  d = min(d, ap.y);\n  d = min(d, ap.z);\n#endif\n  return d;\n}\n\nfloat dfeffect2(vec2 p, vec2 pp) {\n  float fz = mix(0.75, 1., smoothstep(-0.9, 0.9, cos(TAU*TIME/33.0)));\n  float z = 2.*fz;\n  p /= z;\n  vec3 p3 = vec3(p,0.1);\n  p3.xz*=g_rot0;\n  p3.yz*=g_rot1;\n  float ifz = 1.0/fz;\n  float d = apollonian(p3, ifz);\n  d *= z;\n  return d-5E-4;\n}\n\nfloat dsegmentx(vec2 p, vec2 dim) {\n  p.x = abs(p.x);\n  float o = 0.5*max(dim.x-dim.y, 0.0);\n  if (p.x < o) {\n    return abs(p.y) - dim.y;\n  }\n  return length(p-vec2(o, 0.0))-dim.y;\n}\n\nconst int[16] digits = int[16](\n  0x7D // 0\n, 0x50 // 1\n, 0x4F // 2\n, 0x57 // 3\n, 0x72 // 4\n, 0x37 // 5\n, 0x3F // 2\n, 0x51 // 7\n, 0x7F // 8\n, 0x77 // 9\n, 0x7B // A\n, 0x3E // B\n, 0x2D // C\n, 0x5E // D\n, 0x2F // E\n, 0x2B // F\n); \n\nfloat digit(vec2 p, float n) {\n  const vec2 dim = vec2(0.75, 0.075);\n  const float eps = 0.001;\n  vec2 ap = abs(p);\n  if (ap.x > (1.+dim.y+eps)) return 1E3;\n  if (ap.y > (1.5+dim.y+eps)) return 1E3;\n  float m = mod(floor(n), 16.0);\n  int digit = digits[int(m)];\n\n  vec2 cp = (p-0.5);\n  vec2 cn = round(cp);\n\n  vec2 p0 = p;\n  p0.y -= 0.5;\n  p0.y = p0.y-0.5;\n  float n0 = round(p0.y);\n  p0.y -= n0;\n  float d0 = dsegmentx(p0, dim);\n\n  vec2 p1 = p;\n  vec2 n1 = sign(p1); \n  p1 = abs(p1);\n  p1 -= 0.5;\n  p1 = p1.yx;\n  float d1 = dsegmentx(p1, dim);\n  \n  vec2 p2 = p;\n  p2.y = abs(p.y);\n  p2.y -= 0.5;\n  p2 = abs(p2);\n  float d2 = dot(normalize(vec2(1.0, -1.0)), p2);\n\n  float d = d0;\n  d = min(d, d1);\n\n  float sx = 0.5*(n1.x+1.0) + (n1.y+1.0);\n  float sy = -n0;\n  float s  = d2 > 0.0 ? (3.0+sx) : sy;\n  // Praying bit shift operations aren't TOO slow\n  return ((digit & (1 << int(s))) == 0) ? 1E3 : d;\n}\n\nfloat dfeffect3(vec2 p, vec2 pp) {\n  float d = 1E3;\n  float nb = mod(g_ntime-1., 4.0);\n  float sc =  0.33*mix(0.25, 1., nb/3.);\n  p *= ROT(1.5*(hash(g_ntime)-0.5)*(nb-3.)/3.);\n  sc /= 1.-0.5*length(pp)*sqrt(0.5)*sin(g_btime*PI);\n  vec2 p0 = p;\n  p0 /= sc;\n  p0.x -= 3.;\n  float nx = mod1(p0.x, 3.);\n  float sx = 1.-2.*mod(nx, 2.0);\n  p0.y += sx*(g_ntime+pow(g_ftime, 4.))*12.;\n  float ny = sx*mod1(p0.y, 3.);\n  vec2 n2 = vec2(nx, ny);\n  float n = (-n2.x+n2.y);\n  float sdig = mod(n, 4.);\n  n = abs(120.-floor(n/4.));\n  float dig0 = mod(n, 10.);\n  float dig1 = mod(n/10., 10.);\n  float dig2 = mod(n/100., 10.);\n  float dig = dig0;\n  if (sdig == 1.) dig = dig1;\n  if (sdig == 2.) dig = dig2;\n  float d0 = digit(p0, dig);\n  if (sdig == 3.) d0 = abs(length(p0)-0.5)-0.01;\n  d0 *= sc;\n  d = pmax(d, -(d0-0.01), 0.01);\n  d = min(d, d0);\n  return d;\n}\n\n// Carefully fine tuned. No thinking involved.\nconst float ExpBy   = log2(4.1);\nconst float Radius  = 0.3;\n  \nfloat forward(float l) {\n  return exp2(ExpBy*l);\n}\n\nfloat reverse(float l) {\n  return log2(l)/ExpBy;\n}\n\nfloat dfeffect4(vec2 p, vec2 pp) {\n  float ppf = 0.4*dot(pp, pp);\n  p /= 1.+ppf;\n  float tm = 0.5*g_btime;\n  mat2 rot0 = ROT(-tm-ppf*(g_ftime*g_ftime*g_ftime));\n  float py = p.y;\n  \n  float h = 10.0/RESOLUTION.y;\n  mod1(py, h);\n  \n  float d = 1E3;\n  for (float i = 0.0; i < 2.0; ++i) {\n    float ltm = tm+0.5*i;\n    mat2 rot1 = ROT(i*0.5*TAU/8.0);\n    float mtm = fract(ltm);\n    float ntm = floor(ltm);\n    float zz = forward(mtm);\n  \n    vec2 p0 = p;\n    p0 *= rot0;\n    p0 *= rot1;\n    p0 /= zz;\n  \n    float l0 = length(p0);\n    \n    float n0 = ceil(reverse(l0));\n    float r0 = forward(n0);\n    float r1 = forward(n0-1.0);\n    float r = (r0+r1)/2.0;\n    float w = r0-r1;\n    float nn = n0;\n    n0 -= ntm;\n    vec2 p1 = p0;\n    float n1 = modPolar(p1, 8.0);\n    p1.x -= r;\n  \n    float a = 0.5*ltm+n1/8.0;\n    a = fract(a);\n    float d1 = length(p1)-Radius*w;\n    float d2 = length(p1)-Radius*w*smoothstep(0.0, 0.45, mod(a, 0.5));\n    d1 *= zz;\n    d2 *= zz;\n    if (a >= 0.5) {\n      d1 = max(d1, -d2);\n      d = min(d, d1);\n    } else {\n      d = min(d, d2);\n    }\n  }\n  return d;\n}\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  \n  const vec4 pp0 = vec4(normalize(vec3(0.0, -1.0, 0.0)), -5.0);\n  const vec4 pp1 = vec4(normalize(vec3(-2., 2.0, 1.0)), -6.);\n  float tp0  = rayPlane(ro, rd, pp0);\n  float tp1  = rayPlane(ro, rd, pp1);\n\n  if (tp0 > 0.0) {\n    vec3 bcol = bottomBoxCol*exp(-0.5*(1.+length((ro + tp0*rd).xz)));\n    bcol /=  0.05*(tp0*tp0);;    \n    col += bcol;\n  }\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(8.0, 1.))-2.;\n    vec3 tcol = vec3(0.);    \n    tcol += topBoxCol*smoothstep(0.25, 0.0, db);\n    col += 0.2*topBoxCol*exp(-max(db, 0.0));\n//    tcol += 0.25*(topBoxCol)*max(-db, 0.0);\n    tcol /= 0.025*(tp1*tp1);\n    col += tcol;\n  }\n\n  col += lightCol0/(1.0090-dot(lightDir0, rd));\n  col += lightCol1/(1.0025-dot(lightDir1, rd));\n  return clamp(col, 0., 10.); \n}\n\nvoid sphere(vec2 p, float r, out vec3 sp, out vec3 sn) {\n  float z2 = (r*r-dot(p, p));\n  if (z2 > 0.0) {\n    float z = sqrt(z2);\n    vec3 cp = vec3(p, z);\n    vec3 cn = normalize(cp);\n    sp = cp;\n    sn = cn;\n  } else {\n    sp = vec3(p, 0.);\n    sn = vec3(0.);\n  }\n  \n}\n\nvoid sphere4(vec2 p, float r, out vec3 sp, out vec3 sn) {\n  vec2 p2 = p;\n  p2 *= p;\n  float z4 = (r*r*r*r-dot(p2, p2));\n  if (z4 > 0.0) {\n    float z = pow(z4, 0.25);\n    vec3 cp = vec3(p, z);\n    vec3 cn = normalize(cp);\n    sp = cp;\n    sn = cn;\n  } else {\n    sp = vec3(p, 0.);\n    sn = vec3(0.);\n  }\n  \n}\n\nvec4 dthecomputer(vec2 p, float f) {\n  const float sm = 0.015;\n  const vec3 pp = vec3(normalize(vec2(1., 1.)), -0.1);\n  float d0 = circle4(p, 0.48);\n  float d1 = plane(p, pp);\n  float d2 = circle(p, 0.225);\n  float d3 = abs(d2-0.05-f*4.)-0.02;\n  d3 = abs(d3-f*2.)-0.01;\n  d3 = abs(d3-f);\n  float d4 = d1;\n  float d5 = abs(d0-0.015);\n  d1 = abs(d1)-0.2;\n  d1 = abs(d1)-0.1;\n  float d = d0;\n  d =  pmax(d, -d1, sm);\n  d2 = max(d2, d4);\n  d3 = max(d3, d4);\n  d2 = pmax(d2, -(d-0.01), sm);\n  d3 = pmax(d3, -(d-0.01), sm);\n  d = min(d, d2);\n  d = min(d, d5);\n  \n  return vec4(d, d2, d0, min(d5, d3)); \n}\n\nvec3 thecomputer(vec3 col, vec2 p, vec2 pp) {\n  float voice = 0.;\n  const float vc = 4.0;\n  for (float i = 0.; i<vc;++i) {\n    voice += max((texture(iChannel0, vec2(0.05+0.05*i, 0.25)).x-0.3), 0.0);\n  }\n  voice *= 1./vc;\n  voice *= voice;\n  voice = smoothstep(0.0, 0.2, voice);\n  float ntime = g_ntime;\n  float ftime = g_ftime;\n  float time = ntime+ftime;\n  // HARDCODED TIMING - LOVE EM!\n  float va = \n         smoothstep(3., 2., time)\n      +  step(8., time)\n      -  step(168., time)\n      +  step(172., time)\n      ;\n  voice *= va;\n              \n  \n  float aa = sqrt(2.)/RESOLUTION.y;\n  \n  vec4 d = dthecomputer(p, 0.025*voice);\n  const vec3 ro = vec3(0., 0., 8.);\n  vec3 sn;\n  vec3 sp;\n  sphere(p, 0.225, sp, sn);\n  vec3 srd  = normalize(sp-ro);\n  vec3 sr   = reflect(srd, sn);\n  vec3 srcol= render0(sp, sr);\n  float sfre= 1.+dot(srd, sn);\n  sfre *= sfre;\n  vec3 sfre3 = mix(2.*sbase, vec3(2.), sfre);\n  vec3 scol = vec3(0.);\n  scol = srcol*sfre3;\n  scol += pow(-dot(srd,sn), 10.)*sbase;\n  scol += pow(-dot(srd,sn), mix(20., 10., voice))*seye*(voice);\n\n  vec3 scol4 = vec3(0.);\n  vec3 sn4;\n  vec3 sp4;\n  sphere4(p, 0.48, sp4, sn4);\n  \n  vec3 srd4  = normalize(sp4-ro);\n  vec3 sr4   = reflect(srd4, sn4);\n  vec3 srcol4= render0(sp4, sr4);\n  float sfre4= 1.+dot(srd4, sn4);\n  sfre4 *= sfre4;\n  vec3 sfre34 = mix(2.*sbase4, vec3(2.), sfre4);\n\n  scol4 += srcol4*sfre34;\n  vec3 gcol = 0.0001*sbase/(1.00003+dot(srd, vec3(0.0, 0.0, 1.)))*smoothstep(aa, -aa, d.z);\n//  gcol += srcol4*sqrt(sbase)*sfre4*0.5;\n  \n  vec3 ccol = gcol;\n\n  ccol = mix(ccol, scol4, smoothstep(aa, -aa, d.x));\n  ccol = mix(ccol, scol, smoothstep(aa, -aa, d.y));\n  ccol -= 6E-2*vec3(2.,3.,1.)*dot(p, p);\n  col *= 1.-exp(-50.*max(d.z*d.z, 0.));\n  col = mix(col, ccol, smoothstep(aa, -aa, d.z));  \n  col += glowCol/max(d.w, 1E-3);\n  col += 2E-3*seye*(pow(voice, 3.))/max((dot(p,p)), 1E-1);\n  return col;\n}\n\nfloat df(vec2 p, vec2 pp) {\n  switch(g_mainEffect) {\n  case EFFECT0:\n    return dfeffect0(p, p);\n  case EFFECT1:\n    return dfeffect1(p, p);\n  case EFFECT2:\n    return dfeffect2(p, p);\n  case EFFECT3:\n    return dfeffect3(p, p);\n  case EFFECT4:\n    return dfeffect4(p, p);\n  default:\n    return 1E3;\n  }\n}\n\nfloat dfreq(vec2 p, float off) {\n  vec2 p3 = p;\n  p3.y = abs(p3.y);\n  p3.y -= off;\n  const float cw = 0.1;\n  float n3 = mod1(p3.x, cw);\n  n3 = abs(n3);\n  n3 += 3.0;\n  float fft = texture(iChannel0, vec2(0.02*n3, 0.25)).x;\n  fft -= 0.3;\n  fft = max(fft, 0.0);\n  fft *= fft;\n  fft *= 3.;\n  float d3 = segmenty(p3, fft, 0.4*cw);\n  float d = d3;\n  return d;\n}\n\nvec3 freq(vec3 col, vec2 p, vec2 pp, float off) {\n  float ftime = g_ftime;\n  float aa = sqrt(2.)/RESOLUTION.y;\n  float df = dfreq(p, off);\n  float sy = sign(p.y);\n  vec3 fcol = 2.*(1.5+0.5*sy)*(0.5+0.5*sin(vec3(0.,1.,2.)+abs(p.x)+TIME+0.125*sy));\n  col = mix(col, mix(fcol, col, ftime*ftime*ftime), smoothstep(aa, -aa, df));\n  return col;\n}\n\nvec3 mainEffect(vec3 col, vec2 p, vec2 pp) {\n  const vec3 glowCol  = HSV2RGB(vec3(0.55, 0.7, 1E-3));\n  float ftime         = g_ftime;\n\n  float d = df(p, pp);\n  col += glowCol/max(d, 1E-4);\n  float sy = sign(p.y);\n  \n  if (g_flash == 1) {\n    col += smoothstep(0.25, 0., ftime)*2E5*glowCol*glowCol/max(dot(p, p), 1E-2);\n  }\n\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  const float off          = 16.;\n  float beat  = (BPM/60.)*(TIME);\n  float ntime = floor(beat);\n  float ftime = fract(beat);\n  float btime = (TIME+(ntime+log2(1.+(off-1.)*ftime)/log2(off)));\n  g_ntime = ntime;\n  g_ftime = ftime;\n  g_btime = btime;\n  int script    = g_script[int(ntime/8.)];\n  int vis       = (script>>1)&0x3;\n  g_flash       = script&0x1;\n  g_mainEffect  = script>>3;\n/*\n  // HARDCODED TIMING - LOVE EM!\n  if (ntime == 39.) {\n    g_mainEffect = EFFECT2;\n    g_flash      = FLASH;\n    vis          = FREQ1;\n  }\n  */\n\n  float t = TAU*btime;\n  float a = t*TAU/107.0;\n  g_rot0 = ROT(a); \n  g_rot1 = ROT(1.234*a);\n\n\n  vec3 col;\n  col = mainEffect(col, p, pp);\n  col *= smoothstep(1.5, sqrt(0.5), length(pp));\n  switch(vis) {\n  case COMPUTER:\n    col = thecomputer(col, p, pp);\n    break;\n  case FREQ1:\n    col = freq(col, p, pp, 0.);\n    break;\n  case FREQ2:\n    col = freq(col, p, pp, 1.);\n    break;\n  default:\n    break;\n  }\n\n  col = aces_approx(col);  \n  // HARDCODED TIMING - LOVE EM!\n  float ca = step(ntime, 117.)+step(120.,ntime);\n  col *= ca;\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n\n  fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 37036,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/no-om-uo-n/we-are-the-robots-baby?si=8ceba28d1071484db5a5793855faf888&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}