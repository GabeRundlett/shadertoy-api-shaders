{
    "Shader": {
        "info": {
            "date": "1720133513",
            "description": "Some quads falling...",
            "flags": 0,
            "hasliked": 0,
            "id": "MXVXRG",
            "likes": 1,
            "name": "Falling Quads",
            "published": 3,
            "tags": [
                "colors"
            ],
            "usePreview": 0,
            "username": "BigETI",
            "viewed": 108
        },
        "renderpass": [
            {
                "code": "//#define SCREENSHOT_MODE\n\nstruct Cell\n{\n    vec4 color;\n    float movementSpeedMultiplier;\n};\n\nconst Cell cells[] =\n    Cell[]\n    (\n        Cell(vec4(0.0, 0.0, 1.5, 1.0), 0.3),\n        Cell(vec4(0.0, 1.5, 0.0, 1.0), 0.4),\n        Cell(vec4(0.0, 0.0, 1.5, 1.0), 0.2),\n        Cell(vec4(0.0, 1.5, 0.0, 1.0), 0.5),\n        Cell(vec4(0.0, 0.0, 1.5, 1.0), 0.1)\n    );\n\nconst float startingHue = 1.0 - 0.0625;\n\nconst float minimalGridAxisCellCount = 5.0;\n\nconst float cellGlowSize = 0.0625;\n\nconst float cellGlowBoost = 1.5;\n\nconst float cellHueOffset = 0.05;\n\nconst vec3 topSkyColor = vec3(0.0, 0.0, 0.75);\n\nconst vec3 bottomSkyColor = vec3(0.0, 0.0, 0.25);\n\nconst float loopTimeInSeconds = 10.0;\n\nconst float hueShiftTimeInSeconds = 100.0;\n\nconst float e = 0.577215664901532860606512090082402431042159335;\n\n#if defined SCREENSHOT_MODE\nconst float screenshotTime = e * 2.0;\n#endif\n\nvec4 AlphaBlendColors(const vec4 baseColor, const vec4 appendColor)\n{\n    vec3 color = mix(baseColor.rgb, appendColor.rgb, appendColor.a);\n    return vec4(color.x, color.y, color.z, baseColor.a + ((1.0 - baseColor.a) * appendColor.a));\n}\n\nvec3 GetHSVFromRGB(vec3 rgb)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, K.wz), vec4(rgb.gb, K.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 GetRGBFromHSV(vec3 hsv)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(hsv.xxx + K.xyz) * 6.0 - K.www);\n    return hsv.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), hsv.y);\n}\n\nvec3 GetNormalizedRGB(vec3 rgb)\n{\n    vec3 hsv = GetHSVFromRGB(rgb);\n    return (hsv.z > 1.0) ? GetRGBFromHSV(vec3(hsv.x, hsv.y / (hsv.z * hsv.z), 1.0)) : rgb;\n}\n\nvec4 DrawCell(const vec2 uv, vec4 emissiveColor, float glowSize, float glowBoost)\n{\n    vec4 ret;\n    float left = uv.y * 0.25;\n    float right = 0.75 + (uv.y * 0.25);\n    if\n    (\n        (uv.x >= (left - glowSize)) &&\n        (uv.x <= (right + glowSize)) &&\n        (uv.y >= -glowSize) &&\n        (uv.y <= 1.0)\n    )\n    {\n        float intensity =\n            (\n                (uv.x < left) ?\n                    (1.0 - ((left - uv.x) / glowSize)) :\n                    (\n                        (uv.x > right) ?\n                            (1.0 - ((uv.x - right) / glowSize)) :\n                            1.0\n                    )\n            ) *\n            (\n                (uv.y < 0.0) ?\n                    (1.0 - (-uv.y / glowSize)) :\n                    (\n                        (uv.x < left) ?\n                            1.0 :\n                            (\n                                (uv.x > right) ?\n                                    1.0 :\n                                    (uv.y / glowBoost)\n                            )\n                    )\n            ) * glowBoost;\n        vec3 color = GetNormalizedRGB(emissiveColor.rgb * emissiveColor.a * intensity);\n        ret.rgba = vec4(color.r, color.g, color.b, intensity * emissiveColor.a * (1.0 - uv.y));\n    }\n    return ret;\n}\n\nvoid mainImage(out vec4 fragmentColor, in vec2 fragmentCoordinates)\n{\n#if defined SCREENSHOT_MODE\n    const float hue = startingHue;\n#else\n    float hue = startingHue + (iTime / hueShiftTimeInSeconds);\n#endif\n    vec2 uv = (fragmentCoordinates.xy - (iResolution.xy * 0.5)) / ((iResolution.x > iResolution.y) ? iResolution.y : iResolution.x);\n    vec3 sky_hsv = GetHSVFromRGB(mix(bottomSkyColor, topSkyColor, uv.y));\n    vec4 sky_color = vec4(GetRGBFromHSV(vec3(sky_hsv.x + hue, sky_hsv.y, sky_hsv.z)), 1.0);\n    vec4 color = vec4(clamp(sky_color.r, 0.0, 1.0), clamp(sky_color.g, 0.0, 1.0), clamp(sky_color.b, 0.0, 1.0), 1.0);\n#if defined SCREENSHOT_MODE\n    float y_movement = mod(screenshotTime, loopTimeInSeconds);\n#else\n    float y_movement = mod(iTime * 0.5, loopTimeInSeconds);\n#endif\n    float x_movement = y_movement * 0.25;\n    for (int cell_index = 0, x; cell_index < cells.length(); cell_index++)\n    {\n        Cell cell = cells[cell_index];\n        for (x = 0; x < 6; x++)\n        {\n            vec3 cell_hsv = GetHSVFromRGB(cell.color.rgb);\n            vec4 cell_color = vec4(GetRGBFromHSV(vec3(cell_hsv.x + hue + cellHueOffset, cell_hsv.y, cell_hsv.z)), cell.color.a);\n            color = AlphaBlendColors(color, DrawCell(vec2((uv.x + x_movement * cell.movementSpeedMultiplier) * minimalGridAxisCellCount + (4.0 - float(cell_index) * 2.0) + 0.75 * 0.5 - (minimalGridAxisCellCount * 0.25) * float(x), (uv.y + y_movement * cell.movementSpeedMultiplier) * minimalGridAxisCellCount + (-1.5 + float(cell_index)) - minimalGridAxisCellCount * float(x)), cell_color, cellGlowSize, cellGlowBoost));\n        }\n    }\n    fragmentColor = vec4(GetNormalizedRGB(color.rgb), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}