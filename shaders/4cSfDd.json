{
    "Shader": {
        "info": {
            "date": "1725629324",
            "description": " originals https://glslsandbox.com/e#53510.2 https://glslsandbox.com/e#61181.0",
            "flags": 0,
            "hasliked": 0,
            "id": "4cSfDd",
            "likes": 2,
            "name": "cosmic cube",
            "published": 3,
            "tags": [
                "stars",
                "originals"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 83
        },
        "renderpass": [
            {
                "code": "#define time iTime\n#define resolution iResolution.xy\nmat2 rotate(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n\n}\n\nfloat box(vec2 p) {return 1.-max(abs(p.x), abs(p.y));}\n\nfloat grid(in vec2 p){ p = abs(fract(p+.5)-.5); return 2. * min(p.x, p.y); }\n\nvec2 cInv(vec2 p, vec2 o, float r) {\n    return (p-o) * r * r / dot(p-o, p-o) + o;\n}\n\nfloat drawLine (in vec2 p, in vec2 a, in vec2 b, in float r) {\n\tp -= a;\n\tb -= a;\n\tfloat d = length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n    return d;\n\t//return smoothstep (r + 0.01, r, d); // antialiased\n//\treturn step (d, r); // binary\n}\n\nfloat map(vec2 p) {\n    float f;\n    vec3 o = vec3(-1., 0., 1.);\n    \n    // head\n    f = length(p-o.yz*1.3) - .5;\n    \n    // arms\n    f = min(f, drawLine(p, vec2(-.25, .5), vec2(-1.5, .85), 1.)-.2 );\n    f = min(f, drawLine(p, vec2(.25, .5), vec2(1.5, .85), 1.)-.2 );\n    \n    // legs\n    f = min(f, drawLine(p, vec2(-.25, -.5), vec2(-.5, -1.95), 1.)-.2 );\n    f = min(f, drawLine(p, vec2(.25, -.5), vec2(.5, -1.95), 1.)-.2 );\n    \n    // torso, neck\n    f = min(f, drawLine(p, vec2(0., .25), vec2(0., -.25), 1.)-.4 );\n    f = min(f, drawLine(p, vec2(0., .25), vec2(0., .75), 1.)-.2 );\n    \n    return 1.-f;\n}\n#define T time\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(443.8975, 397.2973, 491.1871) // uv range\n//#define MOD3 vec3(.1031, .11369, .13787) // int range\nfloat hash11(float p) {\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//  1 out, 3 in...\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\nvec2 hash23(vec3 p3) {\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat dots(vec3 p) {\n    float r = .03;\n    vec2 rv = r+(1.-2.*r)*hash23(floor(p));\n    return max(0., 1.-length(fract(p.xy)-rv)/r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (2. * gl_FragCoord.xy - resolution) / resolution.y;\n\n\tuv *= 5.;\n\tvec3 col = vec3(0.);\n\t\t\n\tfloat k = 6.28 / 360.;\n    vec4 O=fragColor;\n    vec2 u = fragCoord;\n float l=length(u=9.*(2.*u-iResolution.xy)/iResolution.y);\n    O = .5+.5*normalize(vec3(u*cos(l-iTime),l)).xyzz;\n\tfloat t = 1.;\n    uv *= rotate(k * iTime*0.1 * 360.);\n\tfloat s = 1.;\n\tfor (int i = 0; i < 30; i++) {\n\t\tuv = abs(uv * s) - t;\n\t\tuv *= rotate(k * iTime*0.0 * 360.);\n\t\tt *= .75;\n\t\ts *= 1.01;\n\t}\n\t vec2 res = resolution.xy;\n\tvec2 p = (gl_FragCoord.xy-res/2.) / res.y;\n    \n    p *= 3.;\n    \n    float blueBox = max(0., 1.-abs(box(p))/.025);\n    \n    vec2 o = .2*vec2(sin(.1*T), cos(.07462*T));\n\n    \n    //p *= 1.+dot(o, o);\n    \n    vec2 pinAt = vec2(0.);\n    \n    p -= pinAt;\n    p = p / dot(p, p) - o;\n    p = p / dot(p, p);\n    p += pinAt;\n    \n    float f=0.;\n    \n    //f = max(box(p), .1*grid(p));\n    \n    vec3 cpos = vec3(0., 0., 0.);\n\tvec3 cdir = vec3(p, 1.);\n    \n\n    cdir.z= tan(T*0.3101);\n    \n    const float I = 26.;\n    for(float i=1.; i<=I; i++){\n        \n        vec3 hit = cpos + i * cdir;\n    \tf += dots(vec3(hit)) * (1.-i/I);\n    }\n    \n\t//f = map(p);\n    float aa = 4.*fwidth(f);\n   \n   \n\t\n\tfloat d = length(uv);\n\t\n\tcol += smoothstep(.2, .02, d);\n\tcol *= .5 + .5 * cos(d * 100. + time + vec3(23, 21, 0));\n\t\n\tfragColor = vec4(col+O.xyz, 1.); \n     fragColor*= vec4(vec3(f*O.xyz)*vec3(10.05, 10., 10.2)*col, 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}