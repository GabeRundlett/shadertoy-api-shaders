{
    "Shader": {
        "info": {
            "date": "1582744288",
            "description": "fork of my last sound shader",
            "flags": 8,
            "hasliked": 0,
            "id": "wtGSDD",
            "likes": 9,
            "name": "Day 69",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 450
        },
        "renderpass": [
            {
                "code": "// Fork of \"Day 32 - Fruit Salad\" by jeyko. https://shadertoy.com/view/wlKGR3\n// 2020-02-26 13:03:10\n\n// so\n\nfloat message(vec2 uv) { // to alter in the icon\n    uv-=vec2(1.,10.); if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}    \n   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}\n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.8+0.5*sin(iTime),1.0);\n\n}   ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// i_____ = instrument\n// g_____ = generator\n// e_____ = effect\n// c_____ = channel\n\n// toolchain goes i > g > e > c\n\n#define Y true\n#define N false\nfloat tGlobal;              \n\nbool[16] pattA = bool[](Y,N,N,N,Y,N,Y,N,N,N,Y,N,Y,N,Y,N);\n\nconst float base = 12.;           \nvec2[] scaleA = vec2[8](\n\tvec2(base,0),\n\tvec2(base + 2.,0),      \n\tvec2(base + 3.,0),\n\tvec2(base + 5.,0),                  \n\tvec2(base + 7.,0),\n\tvec2(base + 7.,0),   \n\tvec2(base + 10.,0),\n\tvec2(base + 12.,0)\n);\n\nvec4[4] chords = vec4[](\n    vec4(f(12. - 0.), f(12. + 10.), f(12. + 7.) , f(24. + 3.) ),\n    vec4(f(24. - 3.), f(12. + 10. - 3.), f(12. + 7. - 3.) , f(24. + 3. - 3.) ),\n    vec4(f(26. + 5.), f(12. + 10. + 5.), f(12. + 7. + 5.) , f(12. + 3. + 5.) ),\n    vec4(f(24. - 5.), f(12. + 10. - 5.), f(12. + 7. - 5.) , f(24. + 3. - 5.) )\n);\n\nfloat arpA(float t,vec2[8] scale, float period, float rep, float seed){\n\tfloat n = 0. ;\n    float r = r11( mod( floor(t/period), rep) + seed);\n    r *= 7.  ;\n    r = floor(r)   ;\n    n = note(scaleA[int(r)].x, scaleA[int(r)].y);\n    return n;\n}\n\n\n\nfloat arpC(float t,vec4[8] scale, float period, float rep, float seed){\n\tfloat n = 0. ;\n    float r = r11( mod( floor(t/period), rep) + seed);\n    r *= 7.  ;\n    r = floor(r)   ;\n    n = note(scaleA[int(r)].x, scaleA[int(r)].y);\n    return n;\n}\n\n// ------------ GENERATORS ------------ //\n  \nvec2 gKick(float t){\n    vec2 s = vec2(0);\n\tt = mod(t, hbeat);\n    vec2 introK = iKick(t);\n    s += iKick(t);\n\treturn s;\n}\n\n\nvec2 gCymbal(float t){\n\tvec2 s = vec2(0);\n    \n    t -= hbeat*0.5;\n    t = mod(t, beat);\n    float env = exp(-t*1.);\n    s += iCymbal(t, 0. )*env;\n        \n    //t = step(t, hbeat);\n    \n    \n    return s;\n}\nvec2 gCymbalB(float time){\n    //if (time < measure*2.) return vec2(0);\n    \n    time = mod(time, qbeat);\n    if (mod(time, hmsr) < 0.25){\n//    \ttime = mod(time, qbeat*8.) - hbeat/2.;\n    } else {\n//    \ttime = mod(time, qbeat*4.) - hbeat/2.;\n    }\n\t\n\tfloat s;\n    \n    int t = int(time*iSampleRate/7.);\n    t = int(time*iSampleRate);\n        \n    \tt = t % ((t >>3) % t*2);\n        s =float(t & 0xff - 128)/ 128.;\n        s *= pow(exp(-mod(time,qbeat*20.)), 30.);\n        s = (s + (s*noise(time * mod(time, 0.1)*1.))*3.*exp(-time));\n    \ts *= exp(-time*20.);\n        s *= 3.;\n    \n    s = clamp(s, -1., 1.);\n\treturn vec2(s);\n}\n\n\nvec2 gHats(float t){\n\tvec2 s;\n    float currentMeasure = floor(t/(measure));\n    \n    s += iHatsA(mod(t, qbeat))*0.4;\n    //s += iHatsB(mod(t + 0.08, qbeat))*0.4;\n    Q(measure*4.){\n        Q(measure*2.){\n            //s += iHatsC(mod(t , bar) + 0.001);\n            QL(measure*1.){\n                //s += iHatsC(mod(t + hbar*0.99, bar) + 0.001)*0.6;\n            }\n        } else {\n            //s += iHatsC(mod(t, hbar)*2. + 0.001)*2.;\n            QL(measure*3.){\n            \t//s += iHatsC(mod(t + hbar*0.5, hbar)*2. + 0.001)*2.;\n            }\n        }\n        \n    }else {\n        \n    }\n    return s;\n}\n\n\nvec2 gPads(float t){\n    vec2 s = vec2(0);\n    \n    #define padInstr iTriFMPad\n    \n    float repLen = bar;\n    t= mod(t,repLen*4.);\n    float lT = mod(t, repLen);\n    float env = exp(-mod(t, repLen)*0.4);  \n\t//if()    \n    Q(repLen){\n        playChordVec(chords[0],padInstr, env, mod(t,repLen),s, -12.);   \n    } else Q(repLen*2.){\n    \tplayChordVec(chords[1],padInstr, env, mod(t,repLen),s,-12.);   \n    } else Q(repLen*3.){\n    \tplayChordVec(chords[2],padInstr, env, mod(t,repLen),s,-12.);   \n    } else Q(repLen*4.){\n    \tplayChordVec(chords[3],padInstr, env, mod(t,repLen),s,-12.);   \n    }\n    s *= 0.9;\n    \n\treturn s;\n}\n\n\nvec2 gBass(float t){\n\tsInit;\n \n    int idx = int(floor(t/(bar)));\n    //s += sin(200.*tau*t);\n    \n    float mult = 2.;\n    \n    QL(measure){\n        t = mod(t, measure);\n            Q(bar){\n                t = mod(t, beat);\n                //s += sin(TT*chords[1].x*2.);\n                s += iBassFM(t,note(0.,1.))*1.;\n                //s += iSawLP(t,chords[1].x*2., 0.7 + exp(-t*14.)*1., 0.)*4.;\n            } else Q(bar*2.){   \n                t = mod(t, beat);\t\n                s += iBassFM(t,chords[0].x*4.)*1.;\n            } else Q(bar*3.){\n                t = mod(t, beat);\n                s += iBassFM(t,chords[0].y*2.)*1.;\n                //s += iSawLP(t,chords[idx].y*2., 0.4 + exp(-t*05.)*3., 0.)*4.;\n            } else Q(bar*4.){\n                t = mod(t, beat);\n                s += iBassFM(t,note(12. - 7.,0.))*1.;\n                //s += iSawLP(t,chords[3].x*2., 0. + exp(-t*01.)*3., 20.)*2.;\n            }\n        Q(measure){\n\n        }\n    \n    }\n    //s = sat(s, 1.);\n    s *= 4.;\n\n    //s += iSawLP(400.,200., 200., 2.);\n    return s;\n}\n\nvec2 gLead(float t){\n\tsInit;\n    float tB = t;\n    float rep = beat;\n    float freq = arpA(t, scaleA,hbeat, 14., 19.);\n    \n    if(pattA[int( mod(floor(16.*t/bar), 16.))] == true){\n    \tt = mod(t, qbeat);\n    \tfreq *= 2.;\n        s += iPlucky(t,freq);\n    \t//eChorus(t, iPlucky,freq, 10.,20., s, 1.);\n    }\n    \n    t = mod(t,rep);\n    \n\n    //s = eLofi(s, 4.);\n    s *= 0.5;\n\treturn s;\n} \n\n\nvec2 gIntroDrone(float t, float i){\n\tsInit;\n\n    QL(measure*2.) return vec2(0);\n    \n    float freqA = note(12., 0.);\n    float freqB = note(3., 1.);\n    float freqC = note(12. + 7., 1.);\n    float scale = 0.1;\n    float iters = 6.;\n    for (float i = 0.; i < iters; i++) {\n    \n        s.x += sin(tau*t*freqA    )*scale * 0.5;\n        s.x += sin(tau*t*freqB    )*scale * 0.5;\n        s.x += sin(tau*t*freqC  + smoothstep(0.,1.,sin(t) * noise(vec2(t))*0.5)  )*scale * 0.4;\n    \tfreqA *= 2.002 +noise(i)*0.3 + sin(t + i)*0.002;\n    \tfreqC *= 2.002 +noise(i)*0.3 + sin(t + i)*0.002;\n    \tfreqB *= 1.501;\n        scale *= 0.2 + smoothstep(0.,1., t*0.2)*0.3 + cos(t * 0.2)*0.1;\n    }\n    s.y = s.x;\n    \n    return s;\n}\n\n\nvec2 gSnare(float t){\n\tvec2 s = vec2(0);\n    vec2 s1 = iSnareGhidra(mod(t + beat, beat));\n    QL(measure){\n        s += s1;\n    }\n    \n    return s;\n}\n// ------------ CHANNELS ------------ //\n\nvec2 cSpringReverb(float t){\n\tsInit;\n    float iters = 10.;\n    float st = 7./iSampleRate;\n    for(float i = 0.; i < iters; i++){\n        float offs = r11(i)*0.02; // electronic\n    \ts += gPads(t - st*i - offs)*(1. - i/iters);\n    \ts += gHats(t - st*i - offs*0.2)*(1. - i/iters)*2.;\n    }\n\n    s /= iters;\n    s *= 2.;\n    //s = sat(s, 2.);\n    //s = clamp(s, -1., 1.);\n    //s /= 2.;\n    return s;\n}\n\nvec2 cEchoInput(float t){\n\treturn gLead(t);\n}\nvec2 cEcho(float t) {\n\tsInit;\n    float fb = 0.34, tm = qbeat*1.5, cf = 0.9, ct = tm;\n    // tap 1 \n    s += cEchoInput(t) * cf; cf *= fb; \n    // tap 2\n    s += cEchoInput(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 3\n    s += cEchoInput(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 4\n    s += cEchoInput(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 5\n    //s += cEchoInput(t - ct) * cf; cf *= fb; ct += tm;\n    \n    return s;\n}\n\n// ------------ MAIN ------------ //\n\n\n\nvec2 wavetable( float freq, float time, float speed, float offset ) {\n  if ( time < 0.0 ) { return vec2( 0.0 ); }\n  float p = iTri(time,freq ).x;\n  return vec2(noise( p * speed + offset ));\n}\n\nvec2 clap( float _phase ) {\n  if ( _phase < 0.0 ) { return vec2( 0.0 ); }\n  float amp = exp( -14.0 * _phase );\n  amp *= mix(\n    smoothstep( 0.5, 0.4, sin( 500.0 * _phase ) ),\n    1.0,\n    smoothstep( 0.04, 0.05, _phase )\n  );\n  vec2 wave = wavetable( 1.2, _phase, 1.0, 0.0 );\n  return lofir( amp * wave, 0.25 );\n}\n\nvec2 mainSound( in int samp, float t )\n{\n    #ifdef tOffset\n    t += tOffset;\n    #endif\n\tsInit;\n    tGlobal = t;\n    \n    // drums\n    vec2 kick = gKick(t);\n    vec2 bass = gBass(t);\n    vec2 snare = gSnare(t);\n    //vec2 iirKick; eIIR(t, gKick, 6., 10., iirKick); \n    //vec2 cym1bal = gCymbal(t);\n    //vec2 cymbalB = gCymbalB(t);\n    vec2 kickR = gKickR(t + measure);\n    vec2 hats = gHats(t);\n    vec2 clap = clap(t);\n    \n    // synths\n    vec2 pads = gPads(t);\n    //vec2 introDrone = gIntroDrone(t,0.)/3.;\n    vec2 lead = gLead(t);   \n    vec2 reverb = cSpringReverb(t);\n    vec2 echo = cEcho(t);\n   \t        \n    \n    // mixer\n\t//pads *= sideChain(t);\t\n    //reverb *= sideChain(t);\t\n    s += kickR*0.9;\n    s += snare*0.28;\n    //s += clap*0.1;\n    s += bass*0.12;\n    s += pads*1.1;   \n    //s += lead*0.8;   \n    //s += gBass( t)*0.3;\n    //s += introDrone*2.;\n\n    s += reverb*0.2;\n    s += hats*0.1;\n    s += echo*0.5;\n\n    s *= 0.4;\n    //s = clamp(s, -1., 1.);\n    //s = sat(s, 1.7);\n    return s;\n    //return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "//#define tOffset 0. + measure*1.75\n\n\n#define sInit vec2 s = vec2(0)\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define TT tau*t\n  \n#define tempo 124.\n#define hbeat ((60./tempo)/1.)\n#define qnote (hbeat/2.)\n#define beat  (hbeat*2.)\n#define qbeat  (beat/4.)\n#define measure  (beat*4.*4.)\n#define hmsr  (measure*0.5)\n#define bar (0.5*hmsr)\n#define hbar (0.5*bar)\n\n#define P(x) t/measure < x\n#define PL(x) t/measure > x\n   \n#define E else\n#define sStep (1./iSampleRate)\n\n#define f(x) float(x)\n#define sat(x, amt) clamp(x*amt, -1., 1.)\n#define Q(period)  \\\n\tif (t < period)\n#define QL(period)  \\\n\tif (t > period)\n\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\n\nfloat r11(float i){\n\treturn fract(sin(i*742.62412)*1535.52156);\n}\n\n#define rT(i) texture(iChannel0, vec2(i)).x\nfloat noise( vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.1);\n}\n\nfloat noise(float t){\n    float n = 0.;\n    n = fract(r11(t)*r11(t*2.41));\n    vec2 p = vec2(fract(r11(t*14.11)),fract(r11(t*124.1)*r11(t*3.15)));\n    vec2 q = vec2(fract(r11(t*14.124)*r11(t*41.15)), n*0.15);\n    n = fract(dot(p,q));\n\treturn n;\n}   \n\nfloat lpNoise(float t){\n\tfloat a = floor(t);\n\tfloat b = floor(t) + 1.;\n    return mix(noise(a), noise(b),fract(t));\n}\nfloat notVeryRandom(float st){\n    return fract(sin(st*451.5524));\n}\n\n// ------------ EFFECTS ------------ //\n\n#define lofi(i,m) (floor((i)/(m))*(m))\n#define lofir(i,m) (floor((i)/(m)+0.5)*(m))\n\n#define eIIR(t, instr, stSz, iters, varName) \\\n\t{\t\t\t\t\t\t\t\t\t\t \\\n    \tvarName = vec2(0);\t\t\t\t     \\\n        float st = stSz/iSampleRate;\t\t     \\\n        for(float i = 0.; i < iters; i++){\t \\\n            varName += instr(t - st*i);      \\\n        }\t\t\t\t\t\t\t\t     \\\n        varName /= iters;        \t\t\t \\\n    }\n\n#define eChorus(t, instr,freq, iters,stepSz, varName, outAmp) \\\n\t{\t\t\t\t\t\t\t\t\t\t \t\t  \\\n    \tvarName = vec2(0);\t\t\t\t     \t\t  \\\n        float st = stepSz/iSampleRate;\t\t \t\t  \\\n        float n = noise(t); \t\t\t\t          \\\n        for(float i = 0.; i < iters; i++){\t   \t\t  \\\n            varName += instr(t - st*i*sign(mod(i, 3.) - 1.), freq)*outAmp;      \\\n        }\t\t\t\t\t\t\t\t     \t\t  \\\n        varName /= iters;        \t\t\t          \\\n    }\n\n// ------------ DRUMS ------------ //\n\nvec2 iKick(float t){\n    vec2 s = vec2(0);\n    float envA = exp(-t*20.);\n    float envB = exp(-t*50.);\n    s += sin(tau*t*(40. + sin(t*90.)*1. +envB*1000.))*envA;\n    return s;\n}\nvec2 iKickB(float t){\n    vec2 s = vec2(0);\n    float envA = exp(-t*20.);\n    float envB = exp(-t*50.);\n    s += sin(tau*t*(10. + sin(t*90.)*1. +envB*400.))*envA;\n    s = sat(s, 2.);\n    return s;\n}\nvec2 iKickA(float t){\n    vec2 s = vec2(0);\n    float env = exp(-t*10.);\n    s.x += sin( (140. * env+ 10. ) *tau*t) * env ;\n    s.y = s.x;\n\treturn s;\n}\nvec2 iSnareA(float t){\n\tvec2 s = vec2(0);\n\n    float envA = exp(-t*30.);\n    float envB = exp(-t*37.);\n    float envC = exp(-t*90.);\n    //float envC = exp(smoothstep(1.,0.,(t - 1.)) );\n    s += sin( t*tau*(200. + envA * 190.) + noise(t)*(1. - envC))*envB;\n    \n    \n    s = sat(s, 1.3);\n    return s;\n}\nvec2 iSnareGhidra(float t){\n    vec2 s = vec2(0);\n    float hit = mod(t + beat/2.,beat);\n\n    float n = 15.; \n    s += sin(tau*note(n+ 1.6*exp(-hit*46.) ,2.))*exp(-hit*20.)*0.2;    \t\n    s += sin(tau*note(n+ 1.6*exp(-hit*46.) ,1.))*exp(-hit*20.)*0.8;    \t\n\n    float satAmt = 0.2;\n    s = s*(1.-satAmt) +  (s / (0.99 -abs(s)))*satAmt;\n    //s *= 0.7;\n    s = (s + noise(t + noise(t))*s*8.)/2.; \n\treturn s*1.;\n}\n\nvec2 iHatsA (float t) {\n\tvec2 s = vec2(0);;\n    float env = exp(-t*20.);\n    float r = r11(t);\n    //float r = lpNoise(t*4000.);\n    s.x = sin(770.*t*tau + sin(2040.*t*tau + r*4500.)*4. + r*200.*env ) * env;\n    s.y = s.x;\n    s *= 0.2;\n    return s;\n}\nvec2 iHatsB (float t) {\n\tvec2 s = vec2(0);\n    float env = exp(-t*50.);\n    float r = r11(t);\n    s.x = sin(570.*t*tau + sin(2040.*t*tau + r*1500.)*4. + r*4. ) * env;\n    s.y = s.x;\n    s *= 0.5;\n    return s;\n}\nvec2 iHatsC(float time){\n\tfloat s;\n    \n    //time = mod(time, beat*2.);\n    //time = mod(time, beat);\n    int t = int(time*iSampleRate/7.);\n    t = int(time*iSampleRate*2.);\n    t = t % ((t >>3) % t*4);\n    s =float(t & 0xff - 128)/ 128.;\n    s *= pow(exp(-time), 1.);\n    s = (s + (s*noise(time * mod(time, 0.001)*300.))*2.*exp(-time));\n    s *= 3.;\n    return vec2(float(s));\n}\n\nvec2 iCymbal(float t, float freq){\n\tvec2 s = vec2(0);\n    \n    float n = noise(t)*clamp(exp( (t- 1.)*1.), 0., 1.);\n    //s += n;\n    float fund = 1000.;\n    //s += sin(fund*t*tau + sin(t*tau*fund*12.)*5.* exp(-t*5.) + n*600.) * exp(-t*10.);\n    s += sin(fund*t*tau + sin(t*tau*fund*49.001)*5.* exp(-t*5.) ) * exp(-t*16.);\n    \n    \n    s = abs(s);\n    \n    s = clamp(s, -1., 1.);\n    \n\treturn s;\n}\nvec2 hats (float t) {\n\tvec2 s = vec2(0);\n\n    t = mod(t, hbeat);\n    float env = exp(-t*20.);\n    float r = r11(t);\n    s.x = sin(470.*t*tau + sin(2040.*t*tau + r*4500.)*4. + r*7.*env ) * env;\n    s.y = s.x;\n    return s;\n}\n\nvec2 hatsTwo (float t) {\n\tvec2 s = vec2(0);\n\n    t = mod(t, hbeat/2.);\n    float env = exp(-t*50.);\n    \n    float r = r11(t);\n    s.x = sin(570.*t*tau + sin(2040.*t*tau + r*1500.)*4. + r*4. ) * env;\n    s.y = s.x;\n    \n    return s;\n\n}\n\n\n// ------------ INSTRUMENTS ------------ //\n\n\nvec2 iSineWide(float t, float freq){\n\tvec2 s = vec2(0);\n    t += noise(t)*0.00004;\n    s.x = sin(freq*tau*t);\n    s.y = sin(freq*tau*t + 5.);\n    return s;\n}\nvec2 iPiano(float t, float freq){\n\tvec2 s = vec2(0);\n    t += noise(t)*0.00004;\n    float envA = exp(-t*3.);\n    s.x = sin(freq*tau*t + sin(freq*tau*t*1.)*envA*1.);\n    s.y = sin(freq*tau*t + sin(freq*tau*t*1.)*envA*1.+ 5.);\n    return s;\n}\nvec2 iOrganLead(float t, float freq){\n    vec2 s = vec2(0);\n    float env = exp(-t*9.);\n    freq *= 4.;\n    float iterations = 3.;\n    float scale = 1.;\n    for (float i = 0.; i < iterations; i++) {\n        float r = r11(i)*10.;\n    \ts.x += sin((freq + r)*tau*t )*env*scale;\n    \ts.x += sin(freq*tau*(t + 0.05) )*env*scale;\n    \ts.x += sin(0.5*freq*tau*(t + 0.06) )*env*scale;\n        scale *= 0.8;\n        s.x * 0.33;\n        freq *= 2.01;\n    }\n    s.x /= iterations;\n    s.y = s.x;\n    return s;\n}\nvec2 iPlucky(float t, float freq){\n\tvec2 s = vec2(0);\n    freq *= 2.;\n\tfloat r = r11(t)*0.01;\n    float envA = exp(-t*6.);\n    float envB = exp(-t*20.);\n\ts.x += sin((freq + r)*tau*t + sin((4.*freq + r)*tau*t )*envB*0.5 + lpNoise(t*1000.)*1. )*envA;\n    t += 0.02;\n\ts.y += sin((freq + r)*tau*t + sin((4.*freq + r)*tau*t )*envB*0.5 + lpNoise(t*1000.)*1. )*envA;\n\t//s.x -= sin((freq + r)*tau*t + sin((8.*freq + r)*tau*t )*envB*0.5  )*envA*0.4;\n    //s.y = s.x;\n    return s;\n}\n\nvec2 iSawLP(float t, float freq, float cutoff, float res){\n\tsInit;\n    for(float i = 1.; i < 20.; i++){\n    \ts += sin(freq*tau*t*i) / (i) * smoothstep(0.,1.,length(i/32. - cutoff)) * (1. + exp(-length(i/32. - cutoff)*4.) *res);\n    }\n    s *= 0.1;\n    s = sat(s, 2.);\n    s *= 2.;\n    return s;\n}\nvec2 iBassFM(float t, float freq){\n\treturn vec2(sin(TT*freq + exp(-t*7.)*sin(TT*freq*4.)*1.));\n}\n\nvec2 iSawAChorused(float t, float freq){\n\tvec2 s = vec2(0);\n    eChorus(t, iPiano,freq*2.,10., 1., s, 1.);\n    //s *= exp(-t);\n    //s.x /= 6.;\n    return s;\n}\nvec2 iSawA(float t, float freq){\n\tvec2 s = vec2(0);\n    s.x = fract(freq*tau*t + sin(t)*9. + r11(t)*0.1*exp(-t*200.))*0.2;\n    s.y = s.x;\n    return s;\n}\nvec2 iTri(float t, float freq){\n\tvec2 s = vec2(0);\n    s.x = abs(fract(freq*tau*t) - 0.5)*0.2;\n    s.y = s.x;\n    return s;\n}\nvec2 iTriFMPad(float t, float freq){\n\tvec2 s = vec2(0);\n    \n    \n    for(float j = 1.; j < 3.; j++){\n        for(float i = 0.; i< 4.; i++){\n            t += i *0.09;\n            //s += sin(4.*freq*tau*t + sin(8.*freq*tau*t)*0.8*exp(-t*4.) + lpNoise(t*20.)*5.7)*0.3;\n            s += sin(4.*freq*TT\n                     + sin(4.*freq*TT)*0.8*exp(-t*20.) \n                     + sin(2.*freq*TT + sin(2.*freq*TT))*0.8*exp(-TT*2.) \n                     + sin(t*15.)*0.5 )*0.07/j;\n            //s += sin(6.*freq*tau*t )*0.1;\n\n        }\n    \tfreq *= 2.;\n    }\n    //s = iTri(t, freq);\n    return s;\n}\nvec2 iSuperSaw(float t,float freq){\n\tvec2 s = vec2(0);\n    //float n = noise(t);\n    t += r11(t)*0.00009;\n    float detuneAmt = 1.;\n    //t += noise(t)*0.0004;\n    s += iSawA(t, freq);\n    s += iSawA(t, freq*(1. - 0.02*detuneAmt));\n    s += iSawA(t, freq*(1. + 0.015*detuneAmt));\n    s /= 3.;\n    return s;\n}\nvec2 iAmbG(float t, float freq){\n\tvec2 s = vec2(0);\n    freq *= 3.;\n    t = mod(t, hmsr);\n    float iters = 3. + clamp( exp(-t/2.)*5., 0., 30.);\n    for (float i = 1.;i < iters; i++){\n    \ts += sin(t*tau*freq*i)/i;\n    }\n    \n    float n = noise(t);\n    vec2 sOrig = s;\n    float tMod = sin(t*8.)*(1. + exp(t/2.- 1.)*0.3);\n    float tMod2 = cos(t*2.)*0.5;\n    s = sOrig*sin(freq*4.*t*tau + n*0.4  + tMod          );\n    s += sOrig*sin(freq*2.*t*tau + n*0.4 + tMod2        );\n    s += sOrig*(fract(freq*8.*t*tau + n*0.4 -tMod + tMod2  ));\n\n    s /= 8.;\n    \n    return s;\n}\n\n\n// ------------ GENERATORS ------------ //\n\nvec2 gKickR(float t) {\n    vec2 s = vec2(0);\n    \n    vec2 k = iKick(t);\n    \n        s += k;\n    Q(measure*4.){\n        //return vec2(0);\n    } else QL (measure*4.){\n    }\n    float period = hbeat;\n    t = mod(t + beat*4.,beat*8.);\n\tfloat r = noise(floor(t/period) + 1.);\n\tfloat rB = noise(floor(t/period) + 2.);\n    \n    if (rB < 0.1){\n    \tr = floor(r* 3.99);\n    \tfloat offs = (period/1.)*r;\n        float mT = mod(t, period) - offs;\n        if (mT > 0.){\n            eIIR(mT, iKickB, 6., 10., s);\n        }\n    }\n    s = sat(s, 1.2);\n    //s.y = s.x;\n\treturn s;\n}\n\n// ------------ OTHER STUFF ------------ //\n\n\n#define addChord(array,arraysize,arrayname) \t\t\t\t\\\n\t{arrayname = float[]array;\t\t\t\t\t\t\t\t\\\n    }\n#define playChord(array, arraysize, synth,env,t,sound)  \t\\\n        for (int i = 0; i < int(arraysize); i++){\t\t\t\\\n            sound += vec2( synth(t, note(chord[i],0.)) )*env;\\\n        }\n#define playChordVec(chord, synth,env,t,sound,offs)  \t\\\n        {\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n            sound += vec2( synth(t, note(chord.x+offs,0.)) )*env;\\\n            sound += vec2( synth(t, note(chord.y+offs,0.)) )*env;\\\n            sound += vec2( synth(t, note(chord.z+offs,0.)) )*env;\\\n            sound += vec2( synth(t, note(chord.w+offs,0.)) )*env;\\\n        }\t\t\t\t\t\t\t\t\t\t\t\t\t\n\nfloat sideChain(float t){\n    float s;\n\n    t = mod(t, hbeat);\n    //s = exp(pow( (t*1.- 1.)*0.5, 2.));\n    s = pow(sqrt(t ), 0.8);\n    \n    return s;\n}\n\nvec2 eLofi(vec2 s, float amt){\n    float st = (1./(pow(2.,amt)));\n    s = st * floor( s/st + 0.5 );\n    return s;\n}\n\n// ------------ VAULT ------------ //\n\n/*\nvec2 echoChannel(float t) {\n\tvec2 s = vec2(0);\n\n    float fb = 0.85, tm = qbeat*1.5, cf = 0.9, ct = tm;\n    // tap 1 \n    s += lead(t) * cf; cf *= fb; \n    \n    s += lead(t) * cf; cf *= fb; \n    // tap 2\n    s += lead(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 3\n    s += lead(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 4\n    s += lead(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 5\n    s += lead(t - ct) * cf; cf *= fb; ct += tm;\n    \n    return s;\n}*/\n\n/*\n#define eReverb(t, instr, iters, stSz, varName)\n{\n    vec2 ls = vec2(0);\n    float st = stSz/iSampleRate;\n    st = 0.008;\n    for(float i = 0.; i < iters; i++){\n        float offs = noise(i)*0.8;\n    \tls += instr(t - st*i - offs)*1.*(1. - i/iters);\n    }\n\n    ls /= iters;\n    ls = clamp(s, -1., 1.);\n    varName += ls;\n}*/\n\n\n\n\n/*\nvec2 cHipass(float t){\n    float f = 900.4;\n    float r = 0.9; // 0.1 to sqrt(2)\n\n    float c = tan(pi * f / iSampleRate);\n\n    float a1 = 1.0 / ( 1.0 + r * c + c * c);\n    float a2 = -2.*a1;\n    float a3 = a1;\n    float b1 = 2.0 * ( c*c - 1.0) * a1;\n    float b2 = ( 1.0 - r * c + c * c) * a1;\n    \n    //vec2 s = a1 * gKick(t) + a2 * gKick(t - sStep) + a3 * gKick(t - sStep*2.) - b1*out(n-1) - b2*out(n-2);\n    vec2 sC = a1 * gKick(t) + a2 * gKick(t - sStep) + a3 * gKick(t - sStep*2.);\n    vec2 sB = a1 * gKick(t - sStep*1.) + a2 * gKick(t - sStep*2.) + a3 * gKick(t - sStep*3.);\n    vec2 sBB = a1 * gKick(t - sStep*2.) + a2 * gKick(t - sStep*3.) + a3 * gKick(t - sStep*4.);\n    vec2 s = sC - b1*sB - b2*sBB;\n    //vec2 s = a1 * gKick(t - sStep*2.) + a2 * gKick(t - sStep*3.) + a3 * gKick(t - sStep*4.);\t    \n  //out(n) = \n\treturn s;\n}*/\n\n\n/*\nvec2 cReverb(float t){\n\tvec2 s = vec2(0);\n    float iters = 100.;\n    float st = 1./iSampleRate;\n    st = 0.008;\n    for(float i = 0.; i < iters; i++){\n        float offs = noise(i)*0.8;\n    \ts += gSawA(t - st*i - offs)*3.*(1. - i/iters);\n        //s += gCymbal(t - st*i + offs*0.4)*0.1*(1. - i/iters) ;\n        \n        //s += gCymbalB(t - st*i + offs*0.06)*0.3*(1. - i/iters) ;\n    }\n\n    s /= iters;\n    s = clamp(s, -1., 1.);\n    //s /= 2.;\n    return s;\n}*/\n// The awesome IRR bass is from https://www.shadertoy.com/view/XljSD3\nfloat Hash( float n )\n{\n\treturn fract( (1.0 + cos(n)) * 415.92653);\n}\n\n//we can use jitter for analog driftness\nfloat genSaw(float time, float freq, bool useJitter)\n{\n    float jitter1 = 0.0;\n    float jitter2 = 0.0;\n/*\n    if(useJitter)\n    {\n      jitter1 = texture(iChannel0, vec2(time,0.2)*0.01).x;\n      jitter2 = texture(iChannel0, vec2(time-0.01,0.2)*0.01).x;\n    }*/\n    \n    float val = fract(time*(freq + (jitter1+jitter2)*0.2));\n    return val;\n}\n\nfloat genNiceSaw(float time, float freq, bool useJitter)\n{\n    return (genSaw(time,freq,useJitter) - 0.5) * 2.0;\n}\n#define maxTaps 20\n/* Reso lowpass saw... truncated IIR #yoloswag */\nfloat resoLpSaw(float time, float freq, float fa)\n{\n    \n    fa= sqrt(fa);\n\tfloat reso = 0.2;   \n    float c = pow(0.5, (128.0-fa*128.0)   / 16.0);\n  \tfloat r = pow(0.5, (reso*128.0+24.0) / 16.0);\n    \n    float v0,v1;\n    v0 = 0.0;\n    v1 = 0.0;\n    \n    for(int i = 0; i < maxTaps; i++)\n    {\n          float history = float(maxTaps-i)*(1.0/44100.0);\n\n          float t = time - history;\n          float inp = genNiceSaw(t,freq,false);\n          v0 =  (1.0-r*c)*v0  -  (c)*v1  + (c)*inp;\n  \t\t  v1 =  (1.0-r*c)*v1  +  (c)*v0;\n    }\n    \n    return v1;\n}\n/*\nvec2 gBass(float t){\n    vec2 s = vec2(0);\n    float tB = t;\n    float freq = arpA(t, scaleA,qnote, 4., 9.);\n    t = mod(t,qnote);\n    float env = exp(-t*2.);\n    float scale = 0.7;\n    s += resoLpSaw(t, freq, 0.2) * env * scale ;\n\treturn s;\n} */\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}