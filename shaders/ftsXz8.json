{
    "Shader": {
        "info": {
            "date": "1625143773",
            "description": "Representing subpixel coverage as transparency for antialiasing assumes that background subpixels are covered independently. In the extreme case (left circle), the covered foreground subpixels exactly match the covered background subpixels.",
            "flags": 0,
            "hasliked": 0,
            "id": "ftsXz8",
            "likes": 2,
            "name": "Naive AA vs Exact blend",
            "published": 3,
            "tags": [
                "antialiasing"
            ],
            "usePreview": 0,
            "username": "pyBlob",
            "viewed": 288
        },
        "renderpass": [
            {
                "code": "const float pi = radians(180.);\n\nvec4 rainbow(vec2 U)\n{\n    float a = atan(U.y, U.x);\n    vec3 c = cos(vec3(a) - vec3(0, 2, 4)) * .5 + .5;\n    return vec4(c, 1);\n}\n\nbool aa, withcolor;\nvoid blend(inout vec4 O, vec2 R, vec2 U)\n{\n    float d = step(length(U), .12*R.y);\n    if (aa)\n    {\n        float f = 1.2;\n        d = smoothstep(f, 0., length(U) - .12*R.y + f / 2.);\n    }\n\n    vec4 C = vec4(1) * d;\n    if (withcolor)\n        C = rainbow(U) * d;\n\n    O = O * (1. - d) + C;\n}\n\nvec4 image(vec2 R, vec2 U)\n{\n    vec4 O = vec4(0);\n    int N = 20;\n    for (int i=0 ; i<N ; ++i)\n    {\n        float a = (float(i) + .5) / float(N);\n        vec2 M = R/2. + R/4. * cos((a - vec2(0, .25)) * 2. * pi);\n        blend(O, R, U - M);\n    }\n    int M = 20;\n    for (int i=0 ; i<M ; ++i)\n    {\n        blend(O, R, U - vec2(.1, .2) * R);\n        blend(O, R, U - vec2(.1, 1.-.2) * R);\n\n        float y = (float(i) + .5) / float(N);\n        y = mix(.15, .25, y);\n        blend(O, R, U - vec2(.9, y) * R);\n        blend(O, R, U - vec2(.9, 1.-y) * R);\n    }\n    return O;\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    withcolor = u.y > iResolution.y/2.;\n    //aa = u.x < iResolution.x/2.;\n    aa = u.x / iResolution.x < .5 + .5 * sin(iTime * 1.);\n\n    int zoom = 4;\n    vec2 R = iResolution.xy / float(zoom);\n    vec2 U = vec2(ivec2(u) / zoom) + .5;\n\n    O = vec4(0);\n    if (aa)\n        O = image(R, U);\n    else\n    {\n        const int N = 10;\n        for (ivec2 x=ivec2(0) ; x.y<N ; ++x.y)\n        for (x.x=0 ; x.x<N ; ++x.x)\n            O += image(R, U - .5 + (vec2(x) + .5) / float(N));\n        O /= float(N * N);\n    }\n\n    O.xyz = pow(O.xyz, vec3(.45));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}