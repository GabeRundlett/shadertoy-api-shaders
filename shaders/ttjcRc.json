{
    "Shader": {
        "info": {
            "date": "1595682030",
            "description": "Inspired by visuals from 'Blender Guru' (https://youtu.be/nb6rSMAooDs), I was aiming for some realistic (by my standards!) lighting and atmosphere.\nI could do more, but alas my GPU can't handle it.\nAny visual or performance tips welcome!",
            "flags": 0,
            "hasliked": 0,
            "id": "ttjcRc",
            "likes": 63,
            "name": "Subway",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "glow",
                "subway"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 1022
        },
        "renderpass": [
            {
                "code": "// 'Subway'\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq and a bunch of others\n// for sharing their knowledge!\n//\n// Comment-out 'MY_GPU_CAN_TAKE_IT' if your graphics card struggles.\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MY_GPU_CAN_TAKE_IT  // Enable reflections.\n#define ZERO min(iTime, 0.0)\n#define MIN_DIST 0.0015\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h,r);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdLink(vec3 p, float le, float r1, float r2) {\n  vec3 q = vec3(p.x, max(abs(p.y) - le, 0.0), p.z);\n  return length(vec2(length(q.xy) - r1, q.z)) - r2;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec2 cappedMod(vec2 p, float c, vec2 l1, vec2 l2) {\n    return p - c * clamp(round(p / c), -l1, l2);\n}\n\nvec3 mirrorX(vec3 p, float d) {\n    p.x = abs(p.x) - d;\n    return p;\n}\n\nvec3 repeatXZ(vec3 p, float c, vec2 l1, vec2 l2) {\n    p.xz = cappedMod(p.xz, c, l1, l2);\n    return p;\n}\n\nfloat sdTactileSlab(vec3 p) {\n    p.z -= 0.4;\n    \n    // Main slab - ISO standard 40x40cm ! :)\n    const float gap = 0.015;\n    float d = sdBox(p, vec3(0.40 - gap, 0.05, 0.4 - gap));\n    \n    // Add the dimples.\n    p.y -= 0.01;\n    p.xz = cappedMod(p.xz + vec2(0.06666), 0.06666 * 2.0, vec2(2.), vec2(3.));\n    return min(d, sdCylinder(p, 0.0225, 0.05));\n}\n\nfloat sdTactileSlabStrip(vec3 p) {\n    p.xz = cappedMod(p.xz, 0.8, vec2(3.0, 0.0), vec2(4.0, 0.0));\n    return sdTactileSlab(p);\n}\n\nfloat sdPavingSlab(vec3 p) {\n    const float gap = 0.015;\n    return sdBox(p, vec3(0.5 - gap, 0.05, 0.5 - gap));\n}\n\nfloat sdThinPavingSlab(vec3 p) {\n    const float gap = 0.015;\n    return sdBox(p - vec3(0.0, 0.0, 0.2), vec3(0.5 - gap, 0.05, 0.2 - gap));\n}\n\nconst vec2 stepToStep = vec2(0.36, 0.66);\nconst float centerToWall = 0.4 * 7.0;\nconst float ceilingHeight = 6.0;\n\nconst vec3 lightPos1 = vec3(0.0, 4.5, 4.3);\nconst vec3 lightPos2 = vec3(0.0, 4.5, -0.6);\n\nfloat glow = 0.0;\nfloat flicker = 1.0;\n\n#define WALL_ID          1.5\n#define RAIL_ID          2.5\n#define STAIR_STRIP_ID   3.5\n#define MARBLE_ID        4.5\n#define TACTILE_TILE_ID  5.5\n#define FLOOR_TILE_ID    6.5\n\nvec2 sdStep(vec3 p) {\n    const float gap = 0.015;\n    \n    // Top edge.\n    float d1 = sdBox(p, vec3(1.4, 0.02, 0.02));\n   \n    if (d1 > 1.0)\n        return vec2(d1, STAIR_STRIP_ID); // Too far away from the step to bother rendering further.\n    \n    // Front facing surface.\n    p.y += 0.16 + 0.02;\n    float d2 = sdBox(p, vec3(1.4 - gap, 0.16 - gap, 0.02));\n    \n    // Vertical grout.\n    d1 = min(d1, sdBox(p - vec3(0.0, 0.0, gap), vec3(1.4, 0.16, 0.02)));\n    \n    // Horizontal surface.\n    p.yz += vec2(0.16 + 0.02, 0.32);\n    d2 = min(d2, sdBox(p, vec3(1.4 - gap, 0.02, 0.32 - gap)));\n\n    // Horizontal grout.\n    d1 = min(d1, sdBox(p + vec3(0.0, gap, 0.0), vec3(1.4, 0.02, 0.32 - gap)));\n    \n    return min2(vec2(d1, STAIR_STRIP_ID), vec2(d2, MARBLE_ID));\n}\n\nvec2 sdSteps(vec3 p) {\n    float i = max(0.0, floor(-p.z / stepToStep.y));\n    return sdStep(p + i * vec3(0.0, stepToStep));\n}\n\nfloat sdRailHolder(vec3 p) {\n    p.x -= 0.35;\n    return max(sdLink(p.yxz, 0.1, 0.25, 0.06), p.y);\n}\n\nvec2 sdWalls(vec3 p) {\n    const float gap = 0.015;\n    \n    vec3 op = p;\n\n    // Wall tiles.\n    p.yz = mod(p.yz, vec2(0.16, 0.22));\n    float d = sdBox(mirrorX(p, centerToWall), vec3(0.02, 0.16 - gap, 0.22 - gap)) - gap;\n\n    // Hand rails.\n    vec3 pp = mirrorX(op, centerToWall);\n    pp.xy -= vec2(-0.3, 1.3);\n    float d2 = 1e10;\n    \n    if (pp.y < 3.0) { // Skip stair rails if point is too far away.\n        d2 = sdCapsule(pp, vec3(0.0, 0.0, 1.0), vec3(0.0), 0.1);\n        d2 = smin(d2, sdRailHolder(pp - vec3(0.0, 0.0, 0.75)), 0.025);\n        pp.yz *= rot(-atan(stepToStep.x / stepToStep.y));\n        d2 = smin(d2, sdRailHolder(pp - vec3(0.0, 0.0, -0.75)), 0.0255);\n        d2 = min(d2, sdCapsule(pp, vec3(0.0), vec3(0.0, 0.0, -length(stepToStep * 11.0)), 0.1));\n        d2 = smin(d2, sdRailHolder(pp - vec3(0.0, 0.0, -length(stepToStep * 11.0) + 0.75)), 0.025);\n    }\n\n    if (p.x > 0.0) {\n        // Remove the parts of the right wall.\n        const float nearEndZ = -stepToStep.y * 12.0;\n        float farEndZ = 2.9;\n        float middleZ = mix(nearEndZ, farEndZ, 0.5);\n        float depthToInclude = farEndZ - nearEndZ;\n        pp = op;\n        pp.z -= middleZ;\n        d = max(d, sdBox(pp, vec3(3.0, 1000.0, depthToInclude / 2.0)));\n    }\n    \n    return min2(vec2(d, WALL_ID), vec2(d2, RAIL_ID));\n}\n\nvec2 sdCorridorSection(vec3 p) {\n    // Walls.\n    vec2 d1 = sdWalls(p);\n    if (p.y > 2.0)\n        return d1; // Too far away from the floor to bother rendering further.\n    \n    // Steps.\n    vec2 d2 = sdSteps(repeatXZ(p, 2.8, vec2(1.0, 0.0), vec2(1.0, 0.0)));\n\n    // Pre-stairs half strip.\n    float d = sdThinPavingSlab(repeatXZ(p, 1.0, vec2(3.0, 0.0), vec2(3.0, 0.0)));\n\n    // Tactile slabs.\n    p.z -= 0.4;\n    float d3 = sdTactileSlabStrip(p);\n    d3 -= 0.006 * mix(0.8, 1.0, texture(iChannel0, p.xz * 1.7).r);\n\n    // Floor.\n    d = min(d, sdPavingSlab(repeatXZ(p - vec3(0.0, 0.0, 0.8 + 0.5), 1.0, vec2(3.0, 0.0), vec2(3.0, 5.0))));\n    \n    return min2(vec2(d, FLOOR_TILE_ID), min2(d1, min2(d2, vec2(d3, TACTILE_TILE_ID))));\n}\n\nvec2 map(vec3 p, bool useGlow) {\n    // Side wire cover.\n    float d = sdBox(p - vec3(centerToWall - 0.1, 0.0, 1.8), vec3(0.07, 10.0, 0.07)) - 0.01;\n\n    // Overhead beam.\n    d = min(d, sdBox(p - vec3(0.0, ceilingHeight - 1.0, 1.8), vec3(centerToWall, 1.0, 0.07)) - 0.01);\n    \n    // Overhead pipe.\n    vec3 v = vec3(centerToWall - 1.0, ceilingHeight - 1.5, 0.0);\n    d = min(d, sdCapsule(p, v + vec3(0.0, 0.0, 2.9), v - vec3(0.0, 0.0, 100.0), 0.18));\n    d = min(d, sdCapsule(p, v + vec3(0.0, 0.0, 2.0), v + vec3(0.0, 0.0, 1.6), 0.22));\n    \n    // Overhead pipe clamps.\n    vec3 pp = p;\n    pp.z = abs(p.z - 1.8);\n    d = min(d, sdLink(pp - vec3(centerToWall - 1.0, ceilingHeight - 1.3, 0.9), 0.2, 0.2, 0.015));\n    d = min(d, sdLink(p - vec3(centerToWall - 1.0, ceilingHeight - 1.3, -2.0), 0.2, 0.2, 0.015));\n\n    // Ceiling lights.\n    pp -= vec3(0.0, ceilingHeight - 1.0, 2.5);\n    float lightFrame = max(sdBox(pp, vec3(1.0, 0.25, 0.06)), -sdBox(pp + vec3(0.0, 0.3, 0.0), vec3(0.95, 0.2, 0.1)));\n    d = min(d, lightFrame);\n    \n    // Only apply glow when marching, not calculating normals.\n    if (useGlow) {\n        float endFade = 1.0 - clamp((abs(p.x) - 0.8) / 0.2, 0.0, 1.0);\n        pp.y += 0.2;\n        float gd = sdCylinder(pp.yxz, 0.05, 0.92);\n        glow += endFade * 0.001 / (0.001 + gd * gd * 0.3) * mix(0.01, 1.0, p.z < 0.0 ? 1.0 : flicker);\n    }\n    \n    // Ceiling.\n    pp = p;\n    pp.xz *= rot(-3.1415 / 4.0);\n    float bump = texture(iChannel0, p.xz * 0.8).r * 0.01;\n    d = min(d, sdBox(pp - vec3(0.0, ceilingHeight, -20.0), vec3(10.0, 1.0, 20.0 + stepToStep * 12.0)) - bump);\n\n    // Base corridor.\n    vec2 d2 = sdCorridorSection(p);\n    \n    // Upper corridor.\n    p.yz -= stepToStep * 12.0;\n    p.z -= 9.0;\n    p.xz *= rot(-3.14159 / 4.0);\n    p.x -= 9.08;\n    \n    d2 = min2(d2, sdCorridorSection(p));\n    \n    return min2(vec2(d, WALL_ID), d2);\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0001;\n    return normalize(e.xyy * map(p + e.xyy, false).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx, false).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy, false).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx, false).x);\n}\n\nfloat calcAO(vec3 p, vec3 n, float d) {\n    return clamp(map(p + n * d, false).x / d, 0.0, 1.0);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos) {\n    float d = distance(p, lightPos);\n    \n    float shadow = 1.0;\n    vec3 st = (lightPos - p) / 30.0 * 0.8;\n    float std = length(st);\n    p += normalize(lightPos - p) * 0.01;\n    for (float i = ZERO; i < 30.0; i++) {\n        p += st;\n        shadow = min(shadow, max(map(p, false).x, 0.0) / (std * i));\n    }\n    \n    float falloff = pow(d / 20.0 + 1.0, 2.0);\n    return shadow / falloff;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvec3 getMaterial(vec3 p, vec3 rd, vec3 n, float id) {\n    vec3 lightDir1 = normalize(lightPos1 - p);\n    vec3 lightDir2 = normalize(lightPos2 - p);\n    vec3 lightCol = vec3(1.0, 1.0, 1.1);\n\n    float spec = pow(\n        max(\n            max(\n                dot(reflect(lightDir1, n), rd) * flicker,\n                dot(reflect(lightDir2, n), rd)\n            ),\n            0.0\n        ),\n        50.0);\n\n    vec3 mat;\n    if (id == STAIR_STRIP_ID) {\n        mat = vec3(0.1);\n    } else if (id == MARBLE_ID) {\n        mat = vec3(smoothstep(0.0, 0.6, texture(iChannel0, (abs(n.y) < 0.1 ? p.xy : p.xz) * 1.4125).r));\n    } else if (id == TACTILE_TILE_ID) {\n        mat = vec3(0.9, 0.75, 0.21); // Yellow.\n        spec *= 0.8; // Reduce specular contribution.\n    } else if (id == FLOOR_TILE_ID) {\n        mat = vec3(mix(0.3, 0.5, texture(iChannel0, p.xz * 1.743).r));\n    } else mat = vec3(1.0); // White (Tiles, etc)\n\n    // Diffuse color.\n    float diff = max(max(0.0, dot(lightDir1, n) * flicker), dot(lightDir2, n));\n\n    // Fake ambient occlusion.\n    float occ = min(1.0, 0.2 + calcAO(p, n, 0.15) * calcAO(p, n, 0.05));\n\n    // Shadows from two light sources.\n    float sha = (calcShadow(p, lightPos1) * flicker + calcShadow(p, lightPos2)) / 2.0;\n\n    vec3 col = mat * lightCol * ((diff + spec) * sha + occ * 0.025);\n    \n    // Global 'glow' variable accumulates color as the\n    // scene is marched.\n    return col + min(glow, 1.0);\n}\n\nvoid march(vec3 ro, vec3 rd, out vec3 p, out vec2 h) {\n    float d = 0.01;\n    for (float steps = ZERO; steps < 60.0; steps++) {\n        p = ro + rd * d;\n        h = map(p, true);\n        \n        if (abs(h.x) < MIN_DIST * d) break; // We've hit a surface - Stop.\n        d += h.x * 0.9; // No hit, so keep marching.\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    flicker = step(0.25, sin(iTime) * texture(iChannel0, vec2(iTime * 0.1)).r);\n\n    // Camera.\n    float ft = fract(iTime / 5.0);\n    float phase = mod(floor(iTime / 5.0), 3.0);\n    \n    vec3 ro;\n    vec3 lookAt = vec3(0.0, 1.0, 0.0);\n    \n    if (phase == 0.0) {\n        ro = vec3(mix(0.0, -0.5, ft) * -3.0 - 1.0,\n                  -1.0 + -6.0 * mix(0.5, 0.4, ft),\n                  -10.0);\n    } else if (phase == 1.0) {\n        ro = vec3(-3.0 * mix(0.0, 0.5, ft) - 1.0, 3.0, -4.0);\n        lookAt = lightPos2;\n    } else if (phase == 2.0) {\n        ro = vec3(0.5, -1.0 + -6.0 * (mix(0.25, 0.0, ft) - 0.5), -1.0);\n        lookAt = lightPos1 - mix(vec3(5.0, 3.5, -1.0), vec3(0.0), ft);\n    }\n    \n    vec3 rd = getRayDir(ro, lookAt, uv);\n    \n    // Raymarch.\n    vec2 h;\n    vec3 p;\n\tmarch(ro, rd, p, h);\n\n    // Materials and lighting.\n\tvec3 n = calcNormal(p);\n    vec3 col = getMaterial(p, rd, n, h.y);\n\n#ifdef MY_GPU_CAN_TAKE_IT\n    // Reflect on hand rails.\n    if (h.y == RAIL_ID) {\n        rd = reflect(rd, n);\n        march(p, rd, p, h);\n        col = mix(col, getMaterial(p, rd, n, h.y), 0.75);\n    }\n#endif\n    \n    // Fog.\n    col *= exp(-pow(distance(ro, p) / 30.0, 3.0) * 5.0);\n    \n    // Output to screen.\n    col = vignette(pow(col, vec3(0.4545)), fragCoord);\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}