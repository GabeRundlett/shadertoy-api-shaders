{
    "Shader": {
        "info": {
            "date": "1562938268",
            "description": "Applying Wang tile concepts to a double simplex weave.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "tl2GWz",
            "likes": 28,
            "name": "Double Simplex Wang Weave",
            "published": 3,
            "tags": [
                "triangle",
                "bezier",
                "simplex",
                "truchet",
                "pattern",
                "tile",
                "wang",
                "weave"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1093
        },
        "renderpass": [
            {
                "code": "/*\n\n\n\tDouble Simplex Wang Weave\n\t-------------------------\n\n\tI don't know if I'd strictly refer to this as a Wang tile example, rather than \n\tapplying Wang tile concepts to BigWIngs's double simplex weave notion. Either way, \n\tthe resultant pattern is pretty unique.\n\n\tIn an overly general sense, modern Truchet tiling relies on rotational symmetry\n    (the original right triangle pattern did not), and as such require that any edge of \n\tone tile matches or connects with all edges of another. Wang tiles, on the other \n\thand, are edge specific (some edges don't match others), which allows for more \n\tinteresting variations.\n\n\tI'm sure most have heard of Wang tiles before. If not, they're well worth looking \n\tinto, since it's possible to do so many cool things with them. Almost all examples \n\tyou see involve quads rather than triangles. I'm not sure why, but I guess triangles \n\tare a little more difficult to work with, plus there'd be fewer edge combinations.\n\n\tHowever, if you make use of BigWIngs's double edge concept, you can increase the \n\tnumber of triangle edge combinations to create a visually rich weave pattern, but\n\twith haphazard sparse regions that are common to Wang tiling.\n\n\tIf you take a look at a double simplex Truchet weave (uncomment the NO_EDGE_MATCHING\n    define below), you'll see that every triangular tile is filled in and all contain\n\tthe same number of Bezier cords, resulting in a tight, dense pattern. However, when \n\tedge matching is applied, the number of Bezier cords vary from three to zero, thus \n    allowing regions of variable density and gaps to form, which breaks up the space.\n\n\tUltimately, applying the principles in this example to a 3D grid block would create \n\ta pretty crazy structure, and I'd definitly like to try that at some stage, but \n\tthis 2D pattern\twill have to suffice for now.\n\t\n\tAnyway, this is just one of so many different variations. The quad version would be\n\teasier to code up and, in my opinion, would look better -- I only went the simplex \n\troute because I wanted to provide code for a novel example that wouldn't be readily \n\taccessible. I also have some more traditional Wang related patterns that I intend \n\tto post at some stage, which should be much easier to digest.\n\n\n\t\n\tAdapted from:\n\n\tDouble Simplex Truchet Weave\n\thttps://www.shadertoy.com/view/3lB3Rc - Shane\n\n\tWhich was based on the following:\n\n\tDouble Triangle Truchet Doodle - BigWIngs\n\thttps://www.shadertoy.com/view/Ml2yzD\n\n\tLinks:\n\n\t// I searched high and low for a triangle-based Wang tile image, but couldn't find\n    // one, until Fabrice linked to something he did many years ago. Fabrice Neyret's\n    // name often pops up on papers when I'm looking for imagery. :)\n    //\n\t// https://hal.inria.fr/inria-00537511\n\n\n*/\n\n\n// Show the Wang edge connected lines. Not that exciting, but it's does illustrate the\n// most basic simplex Wang pattern.\n#define SHOW_WANG_EDGE_CONNECTIONS\n\n\n// Displaying the two color Wang regions for the simplex grid: Note that triangles on \n// neighboring edges share the same regional edge color. By the way, there are tri color, \n// quad color, etc, versions as well.\n//#define SHOW_WANG_REGIONS\n\n\n// Just the normal Truchet variation. In fact, if you compared it to my previous \n// Truchet version, the pattern should look exactly the same.\n//#define NO_EDGE_MATCHING\n\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Standard vec2 to float hash - Based on IQ's original.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.213, 289.197)))*43758.5453); }\n\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 a, vec2 b){\n     \n\tb = a - b;\n\tfloat h = clamp(dot(a, b)/dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n\n\n// IQ's signed distance to a 2D triangle.\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p ){\n\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  //p *= p*p*(p*(p*6. - 15.) + 10.);\n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n// Each triangle shares a unique edge midpoint with its neighbor, which means the \n// generated random number will be the same for that edge in either triangle. This\n// is important when connecting edge patterns in Wang tiles, etc.\nvec3 edges(vec2 id0, vec2 id1, vec2 id2){\n\n    // Return a unique random number for the midpoint of each triangle edge.\n    return vec3(hash21(mix(id0, id1, .5)), hash21(mix(id1, id2, .5)), hash21(mix(id2, id0, .5)));\n\n}\n\n// IQ's signed distance to a quadratic Bezier. Like all of IQ's code, it's quick \n// and reliable. :) Having said that, I've cut it down to suit this particular\n// example, so if you need the proper function, you should look at the original.\n//\n// Quadratic Bezier - 2D Distance - IQ\n// https://www.shadertoy.com/view/MlKcDD\n//\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){\n  \n    // p(t)    = (1 - t)^2*p0 + 2(1 - t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0 - 2*p1 + p2) + 2*(p1 - p0)\n    // p'(0)   = 2*(p1 - p0)\n    // p'(1)   = 2*(p2 - p1)\n    // p'(1/2) = 2*(p2 - p0)\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.*B + C;\n    vec2 c = a * 2.;\n    vec2 d = A - pos;\n\n    // If I were to make one change to IQ's function, it'd be to cap off the value \n    // below, since I've noticed that the function will fail with straight lines.\n    float kk = 1./max(dot(b,b), 1e-6); // 1./dot(b,b);\n    float kx = kk*dot(a,b);\n    float ky = kk*(2.*dot(a,a) + dot(d,b))/3.;\n    float kz = kk*dot(d,a);      \n\n    float res = 0.;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.*kx*kx - 3.*ky) + kz;\n    float h = q*q + 4.*p3;\n    \n    h = max(h, 0.);\n\n    //if(h >= 0.0){ \n     \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1./3.));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0., 1.);\n        //tm = t;\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    \n    /*}\n    else {\n    \n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n        \n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n        \n        //tm = res;//min(min(t.x, t.y), t.z);\n\n        res = sqrt( res );\n        \n        tm = res;\n    }\n    */\n    return res;\n}\n\n\n\n// Rendering the smooth Bezier segment. The idea is to calculate the midpoint\n// between \"a.xy\" and \"b.xy,\" then offset it by the average of the combined normals\n// at \"a\" and \"b\" multiplied by a factor based on the length between \"a\" and \"b.\"\n// At that stage, render a Bezier from \"a\" to the midpoint, then from the midpoint\n// to \"b.\" I hacked away to come up with this, which means there'd have to be a more\n// robust method out there, so if anyone is familiar with one, I'd love to know.\nfloat doSeg(vec2 p, vec4 a, vec4 b, float r){\n    \n    // Mid way point.\n    vec2 mid = (a.xy + b.xy)/2.; // mix(a.xy, b.xy, .5);\n    \n    // The length between \"a.xy\" and \"b.xy,\" multiplied by... a number that seemed\n    // to work... Worst coding ever. :D\n    float l = length(b.xy - a.xy)*1.732/6.; // (1.4142 - 1.)/1.4142;\n \n    // Points on the same edge each have the same normal, and segments between them\n    // require a larger arc. There was no science behind the decision. It's just \n    // something I noticed and hacked a solution for. Comment the line out, and you'll \n    // see why it's necessary. By the way, replacing this with a standard semicircular \n    // arc would be even better, but this is easier.\n    if(abs(length(b.zw - a.zw))<.01) l = r; \n  \n    // Offsetting the midpoint between the exit points \"a\" and \"b\"\n    // by the average of their normals and the line length factor.\n    mid += (a.zw + b.zw)/2.*l;\n\n    // Piece together two quadratic Beziers to form the smooth Bezier curve from the\n    // entry and exit points. The only reliable part of this method is the quadratic\n    // Bezier function, since IQ wrote it. :D\n    float b1 = sdBezier(p, a.xy, a.xy + a.zw*l, mid);\n    float b2 = sdBezier(p, mid, b.xy + b.zw*l, b.xy);\n\n    \n    // Return the minimum distance to the smooth Bezier arc.\n    return min(b1, b2);\n}\n\n\n// vec4 swap.\nvoid swap(inout vec4 a, inout vec4 b){ vec4 tmp = a; a = b; b = tmp; }\n\n// A swap without the extra declaration -- It works fine on my machine, but I'm\n// not game  enough to use it, yet. :)\n//void swap(inout vec4 a, inout vec4 b){ a = a + b; b = a - b; a = a - b; }\n\n\n// To be more succinct, it's a double simplex edge-matched weave pattern.\nvec3 pattern(vec2 p){\n    \n    \n    // Scaling constant.\n    const float gSc = 4.;\n    p *= gSc;\n    \n\t// Sampling and mixing one the textures, just for something to do.\n    //\n    // By the way, I wouldn't quote me on this, but I believe textures are stored in sRGB \n    // format -- I've never found this particularly helpful, but it is what it is. Anyway, \n    // this means the texels need to be converted to linear space (squaring the values is a \n    // rough appoximation) before working with them. The original texture values are restored \n    // to sRGB during gamma correction at the end (roughly taking the square root) before \n    // presenting to the screen.\n    //\n    vec3 tx = texture(iChannel0, p/gSc).xyz; tx *= tx;\n    vec3 tx2 = texture(iChannel0, p.yx/gSc*2.).xyz; tx2 *= tx2;\n    tx = mix(tx, tx2, .5);\n    \n    // Resolution based smoothing factor.\n    float sf = 1.5/iResolution.y*gSc;\n    \n    \n    // SIMPLEX GRID SETUP\n    \n    \n    vec2 s = floor(p + (p.x + p.y)*.36602540378); // Skew the current point.\n    \n    p -= s - (s.x + s.y)*.211324865; // Use it to attain the vector to the base vertex (from p).\n    \n    // Determine which triangle we're in. Much easier to visualize than the 3D version.\n    float i = p.x < p.y? 1. : 0.; // Apparently, faster than: i = step(p.y, p.x);\n    vec2 ioffs = vec2(1. - i, i);\n    \n    float dir = i<.5? -1.: 1.;\n    \n    // Vectors to the other two triangle vertices.\n    vec2 ip0 = vec2(0), ip1 = ioffs - .2113248654, ip2 = vec2(.577350269);\n    vec2 id0 = s, id1 = s + ioffs, id2 = s + 1.;\n    \n    // Make the vertices match up.\n    if(i>.5) { \n        vec2 tmp = ip0; ip0 = ip2; ip2 = tmp;\n        tmp = id0; id0 = id2; id2 = tmp;\n    }\n    \n    \n    // Centralize everything, so that vec2(0) is in the center of the triangle.\n    vec2 ctr = (ip0 + ip1 + ip2)/3.; // Centroid.\n    //\n    ip0 -= ctr; ip1 -= ctr; ip2 -= ctr; p -= ctr;\n    \n    \n    \n    \n    // Displaying the 2D simplex grid. Basically, we're rendering lines between\n    // each of the three triangular cell vertices to show the outline of the \n    // cell edges.\n    float tri = min(min(distLine(p - ip0, p - ip1), distLine(p - ip1, p - ip2)), \n                  distLine(p - ip2, p - ip0));\n    \n    /*\n    float div = 1e5;\n    div = min(div, distLine(p, p - mix(ip0, ip1, .5)));\n    div = min(div, distLine(p, p - mix(ip1, ip2, .5)));\n    div = min(div, distLine(p, p - mix(ip2, ip0, .5)));\n    */\n    \n    // The unique cell ID.\n    //vec2 uID = (s*3. + ioffs + 1.)/3.;\n    \n \n    // Obtaining a random number for each cell edge. It's important to to pass the \n    // vertex IDs to the \"edges\" function and not the vertex points like I did. :)\n    vec3 edge = edges(id0, id1, id2);\n    \n  \n     \n    #ifdef NO_EDGE_MATCHING\n    // A negative threshold means all curves and points are rendered.\n    const float tRnd = -1.; \n    #else\n    // This means there's a 30% chance that an edge will be empty, and thus,\n    // not used.\n    const float tRnd = .3;\n    #endif\n    \n    \n    // The cell edges ID.\n    float id = 0.;\n    \n    // This is a standard way to encode binary information into decimal form.\n    // If the random edge value is over a specific threshold, encode the correct\n    // binary digit.\n    if(edge.x>tRnd) id += 1.;\n    if(edge.y>tRnd) id += 2.;\n    if(edge.z>tRnd) id += 4.;\n    \n    // Decode each binary digit.\n    vec3 bits = mod(floor(id/vec3(1, 2, 4)), 2.);\n\n    \n    // Connecting points around the triangles. Two for each side. I should probably\n    // use a bit of trigonometry and hard code these, but I was feeling lazy. :)\n    const float offs = .204124; // Approx: length(ip0 - ip1)/4., or sqrt(1./24.);\n    vec2 m01s = mix(ip0, ip1, .5 + offs);\n    vec2 m01t = mix(ip0, ip1, .5 - offs);\n    vec2 m12s = mix(ip1, ip2, .5 + offs);\n    vec2 m12t = mix(ip1, ip2, .5 - offs);\n    vec2 m20s = mix(ip2, ip0, .5 + offs);\n    vec2 m20t = mix(ip2, ip0, .5 - offs);\n    \n    // The boundary normals for each point. I should probably hardcode these as well.\n    vec2 n01 = -normalize(mix(ip0, ip1, .5));\n    vec2 n12 = -normalize(mix(ip1, ip2, .5));\n    vec2 n20 = -normalize(mix(ip2, ip0, .5));\n\n        \n   \n    // Line variable. One for each edge.\n    vec3 rLn = vec3(1e5);\n  \n    \n    // Array index. It increases by two for every extra Bezier segment and pair of \n    // end points needed. See below.\n    int index = 0;\n    \n    // The actual points: The idea is to only add the necessary points to the array, \n    // depending on how many edges line up, which would be 0, 1, 2, or all 3. \n    // However, just in case my logic isn't up to scratch, I'll zero them all out, \n    // just to be on the safe side.\n    //\n    // Each edge corresponds to two entry and exit points. These have to be shuffled\n    // to produce the random weave you see, so it's necessary to keep track of the\n    // the maximum array count. Variable array counts are possible in WebGL 2.0, but\n    // I'd like to try to keep things backward compatible, etc.\n    vec4[6] pnt = vec4[6](vec4(0), vec4(0), vec4(0), vec4(0), vec4(0), vec4(0));\n    \n    // If the first binary digit is flagged (one, not zero), fill in the point \n    // information for the first two array spots, construct an edge, then increase the \n    // index by two.\n    if(bits.x>.5){\n        \n        // Adding the point and normal information for this particular edge, to be\n        // shuffled first, then passed to the Bezier cord construction formula.\n        pnt[index] = vec4(m01s, n01);\n        pnt[index + 1] = vec4(m01t, n01);\n        index += 2;\n        \n        // If the digit is a one, construct an edge from the cell's center to\n        // the corresponding edge midpoint.\n        rLn.x = min(rLn.x, distLine(p, p - mix(ip0, ip1, .5)));\n        \n    }    \n    \n    // Do the same for the second binary digit.\n    if(bits.y>.5){\n        \n        pnt[index] = vec4(m12s, n12);\n        pnt[index + 1] = vec4(m12t, n12);\n        index += 2;\n        \n        rLn.y = min(rLn.y, distLine(p, p - mix(ip1, ip2, .5)));\n        \n    }\n    \n    // Third binary digit.\n    if(bits.z>.5){\n        \n        pnt[index] = vec4(m20s, n20);\n        pnt[index + 1] = vec4(m20t, n20);\n        index += 2;\n        \n        rLn.z = min(rLn.z, distLine(p, p - mix(ip2, ip0, .5)));\n        \n    }\n    \n    // Combine all edges, and give it a thickness.\n    float ln = min(min(rLn.x, rLn.y), rLn.z) - .02;\n    \n    \n    // If lines need to be rendered, render a circle in the middle of the cell,\n    // for decorative purposes.\n    if(index>0) ln = min(ln, abs(length(p) - .05) - .02);\n    \n    // Shuffling the variable array of points and normals -- Six is the maximum. I think this \n    // is the Fisherâ€“Yates method, but don't quote me on it. It's been a while since I've used \n    // a shuffling algorithm, so if there are inconsistancies, etc, feel free to let me know.\n    //\n    // For various combinatorial reasons, some non overlapping tiles will probably be \n    // rendered more often, but generally speaking, the following should suffice.\n    //\n    for(int i = 5; i>0; i--){\n        \n        // For less than three edges, skip the upper array positions.\n        if(i >= index) continue;\n        \n        // Using the cell ID and shuffle number to generate a unique random number.\n        float fi = float(i);\n        \n        // Random number for each triangle: The figure \"s*3 + ioffs + 1\" is unique for\n        // each triangle... I can't remember why I felt it necessary to divide by 3,\n        // but I'll leave it in there. :)\n        float rs = hash21((s*3. + ioffs + 1.)/3. + fi/float(index));\n        \n        // Other array point we're swapping with.\n        //int j = int(floor(mod(rs*float(index)*1e6, fi + 1.)));\n        // I think this does something similar to the line above, but if not, let us know.\n        int j = int(floor(rs*(fi + .9999)));\n        swap(pnt[i], pnt[j]);\n        \n    } \n    \n    // Constructing the Bezier cords for the cell, and the exit and entry points\n    // for each cord.\n    vec3 d = vec3(1e5), pnts = vec3(1e5);\n    \n    for(int i = 0; i<3; i++){\n        \n        // Skip when the index isn't high enough. In other words, if there are\n        // only two points for the cell (one cord), break after the first \n        // iteration, etc.\n        if(index<(i*2+1)) break;\n        \n        // Marking the exit and entry points with some dots, for illustrative\n        // and decorative purposes.\n        pnts[i] = min(pnts[i], length(p - pnt[i*2].xy));\n        pnts[i] = min(pnts[i], length(p - pnt[i*2 + 1].xy));\n        \n        // Contruct the Bezier segment between the two random edge points.\n        d[i] =  doSeg(p,  pnt[i*2], pnt[i*2 + 1], offs);\n       \n    }\n    \n    // Give the end points and Bezier segments some width.\n    pnts -= .045;\n    d -= .1;\n    \n    \n    \n    // Initiate the scene color to the Shadertoy texture.\n    vec3 col = tx;\n     \n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, tri - .0025)));\n\n    // Concentric triangular pattern, for decorative purposes. \n    // The following are interesting too: min(tri, div), max(tri, div).\n    float pat = sin(tri*6.2831*24. + 3.14159*.75)*.5 + 1.2; \n\n    \n    // Blurred connecting cell lines for fake shadows. Uncomment to see what it does.\n    col *= smoothstep(0., sf*12., ln - .15)*.2 + .8;\n\n    // Using the connecting lines to fade the concentric triangular pattern -- The step is\n    // not important, and just something I made up on the spot. A few days from now, even\n    // I wouldn't know that it does. :D\n    pat = max(pat, smoothstep(0., sf*12., ln - .15)*.75);\n    //\n    // Blending in the pattern. I think it's shorthand for the line below:\n    // col = mix(col, vec3(0), (1. - pat));\n    col *= pat;  \n   \n    \n    \n    // Bezier line color.\n    vec3 lCol = tx*4.;\n    \n    // Bezier stripe color.\n    vec3 stCol = mix(lCol, vec3(1.3, 1, .7), .75);\n\n    // Saving the background color for later usage.\n    vec3 tmp = col;\n    \n    \n\t#ifdef SHOW_WANG_REGIONS\n    \n    d += 1e5; // A hacky way to take away the weave pattern.\n    pnts += 1e5; // Same for the Bezier curve end points.\n    \n    //vec3 eRnd = vec3(hash21(mix(id0, id1, .5)), hash21(mix(id1, id2, .5)), hash21(mix(id2, id0, .5)));\n    //vec3 edgeDot = vec3(length(p - mix(ip0, ip1, .5)), length(p - mix(ip1, ip2, .5)), \n    //                    length(p - mix(ip2, ip0, .5)) );   \n    //edgeDot -= .06;\n\n    \n    // Using IQ's 2D triangle formula to construct the triangular edge region.\n    vec3 wTri = vec3(sdTriangle(vec2(0), ip0, ip1, p), sdTriangle(vec2(0), ip1, ip2, p), \n                       sdTriangle(vec2(0), ip2, ip0, p));   \n    // Shrinking the triangle a bit.\n    wTri += .005;\n    \n     \n    for(int i = 0; i<3; i++){\n        \n        // Random colored dots. Not used here.\n        //vec3 dCol = 1.-vec3(1, 1. - eRnd[i], eRnd[i]*.25).zyx;\n        \n        // Brown regions represent empty regions, and green regions \n        // represent regions where connections are rendered.\n        vec3 fCol = mix(tmp, vec3(1, .8, 0), .75);\n        if(bits[i]>.5) fCol = mix(tmp, vec3(.5, 1, .1), .75);//\n    \n\n        // Render the colored Wang region for this particular edge.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*3., wTri[i] - .02))*.5);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, wTri[i] - .02)));\n        col = mix(col, fCol*fCol*1.8, (1. - smoothstep(0., sf, wTri[i])));\n        \n        /*   \n        // Edge dots: Not used here.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*6., edgeDot[i] - .02))*.5);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, edgeDot[i] - .02)));\n        col = mix(col, fCol, (1. - smoothstep(0., sf, edgeDot[i])));\n        */\n    }\n    \n    \n    \n    // Render the white triangular cell edges.    \n    tri -= .02;\n    \n    float vrts = min(min(length(p - ip0), length(p - ip1)), length(p - ip2)); // Vertices.\n    tri = min(tri, abs(vrts - .06) - .02);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*6., tri - .02))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, tri - .02)));\n    col = mix(col, mix(tmp*2., vec3(1.25), .75), (1. - smoothstep(0., sf, tri + .0025)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, tri + .02)));\n \n    #endif\n    \n   \n    #ifdef SHOW_WANG_EDGE_CONNECTIONS\n    // Lay down the edge connections. I made them blue to contrast with the brown.\n    vec3 cCol = mix(tmp*2., vec3(.3, .8, 1.25), .75);\n    //cCol = cCol.xzy; // Green, etc.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*6., ln - .02))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, ln - .02)));\n    col = mix(col, cCol, (1. - smoothstep(0., sf, ln + .0025)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, ln + .02)));\n    #endif\n    \n    #ifndef SHOW_WANG_REGIONS\n    for(int i = 0; i<3; i++){\n        \n        // Only render as many edge connecting points, Beziers, etc, as needed. It's not\n        // absolutely necessary, but I guess it'd save a few cycles... Although, on GPUs,\n        // it'd difficult to know for sure. :)\n        if(i>=index/2) break;\n        \n        // Save the underlying color.\n        tmp = col;\n      \n        // Shading. Not used.\n        //float sh = max(-(d[i]+.02)*64., 0.);\n        \n        // Render the Bezier shadows, edges, etx.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*6., d[i] - .02))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, d[i]));\n        col = mix(col, lCol, 1. - smoothstep(0., sf, d[i]+.02));\n         \n        // The white stripe down the center.\n        float divLn = d[i] + .06; // max(d[i] - .01, tri - .03);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., divLn))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, divLn));\n        col = mix(col, mix(tmp, stCol*1.5, .75), (1. - smoothstep(0., sf, divLn + .02)));\n        \n        // Render some rivets at the cell boundary end points of the Beziers, for\n        // illustrative and decorative purposes.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., pnts[i] - .01))*.35);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnts[i]));\n        col = mix(col, mix(lCol, vec3(1), .65), 1. - smoothstep(0., sf, pnts[i] + .02));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(pnts[i] + .035) - .005));\n     \n    }\n    #endif\n   \n    \n    // Return the pattern color.\n    return col;\n    \n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates. Setting a minumum resolution on the\n    // fullscreen setting in an attempt to keep things relatively crisp.\n    float res = min(iResolution.y, 700.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/res;\n \n    // Rotation and translation of the scene.\n    vec2 p = rot2(3.14159/12.)*uv + vec2(1, .5)*iTime/10.;\n\n    // The double simplex Wang weave pattern.\n    vec3 col = pattern(p);\n    \n    // A bit of subtle noise-based color to break up the brown a little.\n    col = mix(col, col.xzy, (n2D(p*4.)*.67 + n2D(p*8.)*.33)*.5);\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n    // Colored variation.\n    //col = mix(col.xzyw, col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625));\n\n\n    // Rough gamma correction, then output to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}