{
    "Shader": {
        "info": {
            "date": "1653579015",
            "description": "This is a clasic shader from my library, \n\nPress click and use the mouse to control the fractal. \n\nIt uses feedback to create the fractal",
            "flags": 32,
            "hasliked": 0,
            "id": "fscyRS",
            "likes": 5,
            "name": "PolySuperFractal",
            "published": 3,
            "tags": [
                "shader",
                "feedback"
            ],
            "usePreview": 0,
            "username": "jpupper",
            "viewed": 220
        },
        "renderpass": [
            {
                "code": "float STfeed = 0.971;\nfloat STspeed = 0.81;\n\n#define time iTime\n#define resolution iResolution\n#define mouse iMouse\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat poly(vec2 uv,vec2 p, float s, float dif,int N,float a){\n    \n    // Remap the space to -1. to 1.\n    \n    vec2 st = p - uv ;\n    \n    \n    // Angle and radius from the current pixel\n    float a2 = atan(st.x,st.y)+a;\n    float r = TWO_PI/float(N);\n    \n    float d = cos(floor(.5+a2/r)*r-a2)*length(st);\n    float e = 1.0 - smoothstep(s,dif,d);\n      \n    return e;\n}\n\n\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.56222123);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\n\nfloat noise (in vec2 st,float fase) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float fase2 = fase;\n    // Four corners in 2D of a tile\n    float a = sin(random(i)*fase2);\n    float b =  sin(random(i + vec2(1.0, 0.0))*fase2);\n    float c =  sin(random(i + vec2(0.0, 1.0))*fase2);\n    float d =  sin(random(i + vec2(1.0, 1.0))*fase2);\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(1);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y) ;\n    return 20.0 * dot(m, g);\n}\n\n/*************************************************/\n\n// TODAS LAS FUNCIONES DE BLENDING SACADAS DE  https://github.com/jamieowen/glsl-blend\n\n\n///SOFT LIGHT\n#define ADD 1 \n#define\tAVERAGE 2\n#define\tCOLOR_BURN 3\n#define\tCOLOR_DODGE 4\n#define\tDARKEN 5\n#define\tDIFFERENCE 6\n#define\tEXCLUSION 7\n#define\tGLOW 8\n#define\tHARD_LIGHT 9\n#define\tHARD_MIX 10\n#define\tLIGHTEN 11\n#define\tLINEAR_BURN 12\n#define\tLINEAR_DODGE 13\n#define\tLINEAR_LIGHT 14\n#define\tMULTIPLY 15\n#define\tNEGATION 16\n#define\tNORMAL 17\n#define\tOVERLAY 18\n#define\tPHOENIX 19\n#define\tPIN_LIGHT 20\n#define\tREFLECT 21\n#define\tSCREEN 22\n#define\tSOFT_LIGHT 23\n#define\tSUBTRACT 24\n#define\tVIVID_LIGHT 25\n\n\nfloat blendSoftLight(float base, float blend) {\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n//ADD : \nfloat blendAdd(float base, float blend) {\n\treturn min(base+blend,1.0);\n}\n\nvec3 blendAdd(vec3 base, vec3 blend) {\n\treturn min(base+blend,vec3(1.0));\n}\n\nvec3 blendAdd(vec3 base, vec3 blend, float opacity) {\n\treturn (blendAdd(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendAverage(vec3 base, vec3 blend) {\n\treturn (base+blend)/2.0;\n}\n\nvec3 blendAverage(vec3 base, vec3 blend, float opacity) {\n\treturn (blendAverage(base, blend) * opacity + base * (1.0 - opacity));\n}\n  \nfloat blendColorBurn(float base, float blend) {\n\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend) {\n\treturn vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendColorDodge(float base, float blend) {\n\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend) {\n\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendDarken(float base, float blend) {\n\treturn min(blend,base);\n}\n\nvec3 blendDarken(vec3 base, vec3 blend) {\n\treturn vec3(blendDarken(base.r,blend.r),blendDarken(base.g,blend.g),blendDarken(base.b,blend.b));\n}\n\nvec3 blendDarken(vec3 base, vec3 blend, float opacity) {\n\treturn (blendDarken(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendDifference(vec3 base, vec3 blend) {\n\treturn abs(base-blend);\n}\n\nvec3 blendDifference(vec3 base, vec3 blend, float opacity) {\n\treturn (blendDifference(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendExclusion(vec3 base, vec3 blend) {\n\treturn base+blend-2.0*base*blend;\n}\n\nvec3 blendExclusion(vec3 base, vec3 blend, float opacity) {\n\treturn (blendExclusion(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendLighten(float base, float blend) {\n\treturn max(blend,base);\n}\n\nvec3 blendLighten(vec3 base, vec3 blend) {\n\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\n}\n\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearBurn(float base, float blend) {\n\t// Note : Same implementation as BlendSubtractf\n\treturn max(base+blend-1.0,0.0);\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendSubtract\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearDodge(float base, float blend) {\n\t// Note : Same implementation as BlendAddf\n\treturn min(base+blend,1.0);\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendAdd\n\treturn min(base+blend,vec3(1.0));\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearLight(float base, float blend) {\n\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend) {\n\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendMultiply(vec3 base, vec3 blend) {\n\treturn base*blend;\n}\n\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\n\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendNegation(vec3 base, vec3 blend) {\n\treturn vec3(1.0)-abs(vec3(1.0)-base-blend);\n}\n\nvec3 blendNegation(vec3 base, vec3 blend, float opacity) {\n\treturn (blendNegation(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nvec3 blendNormal(vec3 base, vec3 blend) {\n\treturn blend;\n}\n\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) {\n\treturn (blendNormal(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendOverlay(float base, float blend) {\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend) {\n\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendPhoenix(vec3 base, vec3 blend) {\n\treturn min(base,blend)-max(base,blend)+vec3(1.0);\n}\n\nvec3 blendPhoenix(vec3 base, vec3 blend, float opacity) {\n\treturn (blendPhoenix(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendPinLight(float base, float blend) {\n\treturn (blend<0.5)?blendDarken(base,(2.0*blend)):blendLighten(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendPinLight(vec3 base, vec3 blend) {\n\treturn vec3(blendPinLight(base.r,blend.r),blendPinLight(base.g,blend.g),blendPinLight(base.b,blend.b));\n}\n\nvec3 blendPinLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendPinLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendReflect(float base, float blend) {\n\treturn (blend==1.0)?blend:min(base*base/(1.0-blend),1.0);\n}\n\nvec3 blendReflect(vec3 base, vec3 blend) {\n\treturn vec3(blendReflect(base.r,blend.r),blendReflect(base.g,blend.g),blendReflect(base.b,blend.b));\n}\n\nvec3 blendReflect(vec3 base, vec3 blend, float opacity) {\n\treturn (blendReflect(base, blend) * opacity + base * (1.0 - opacity));\n}\n  \nfloat blendScreen(float base, float blend) {\n\treturn 1.0-((1.0-base)*(1.0-blend));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend) {\n\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\n\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendSubstract(float base, float blend) {\n\treturn max(base+blend-1.0,0.0);\n}\n\nvec3 blendSubstract(vec3 base, vec3 blend) {\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\n}\n\nvec3 blendSubstract(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSubstract(base, blend) * opacity + blend * (1.0 - opacity));\n}\nfloat blendVividLight(float base, float blend) {\n\treturn (blend<0.5)?blendColorBurn(base,(2.0*blend)):blendColorDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendVividLight(vec3 base, vec3 blend) {\n\treturn vec3(blendVividLight(base.r,blend.r),blendVividLight(base.g,blend.g),blendVividLight(base.b,blend.b));\n}\n\nvec3 blendVividLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendVividLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendHardLight(vec3 base, vec3 blend) {\n\treturn blendOverlay(blend,base);\n}\n\nvec3 blendHardLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendHardLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendGlow(vec3 base, vec3 blend) {\n\treturn blendReflect(blend,base);\n}\n\nvec3 blendGlow(vec3 base, vec3 blend, float opacity) {\n\treturn (blendGlow(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendHardMix(float base, float blend) {\n\treturn (blendVividLight(base,blend)<0.5)?0.0:1.0;\n}\n\nvec3 blendHardMix(vec3 base, vec3 blend) {\n\treturn vec3(blendHardMix(base.r,blend.r),blendHardMix(base.g,blend.g),blendHardMix(base.b,blend.b));\n}\n\nvec3 blendHardMix(vec3 base, vec3 blend, float opacity) {\n\treturn (blendHardMix(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendMode( int mode, vec3 base, vec3 blend ){\n\tif( mode == 1 ){\n\t\treturn blendAdd( base, blend );\n\t}else\n\tif( mode == 2 ){\n\t\treturn blendAverage( base, blend );\n\t}else\n\tif( mode == 3 ){\n\t\treturn blendColorBurn( base, blend );\n\t}else\n\tif( mode == 4 ){\n\t\treturn blendColorDodge( base, blend );\n\t}else\n\tif( mode == 5 ){\n\t\treturn blendDarken( base, blend );\n\t}else\n\tif( mode == 6 ){\n\t\treturn blendDifference( base, blend );\n\t}else\n\tif( mode == 7 ){\n\t\treturn blendExclusion( base, blend );\n\t}else\n\tif( mode == 8 ){\n\t\treturn blendGlow( base, blend );\n\t}else\n\tif( mode == 9 ){\n\t\treturn blendHardLight( base, blend );\n\t}else\n\tif( mode == 10 ){\n\t\treturn blendHardMix( base, blend );\n\t}else\n\tif( mode == 11 ){\n\t\treturn blendLighten( base, blend );\n\t}else\n\tif( mode == 12 ){\n\t\treturn blendLinearBurn( base, blend );\n\t}else\n\tif( mode == 13 ){\n\t\treturn blendLinearDodge( base, blend );\n\t}else\n\tif( mode == 14 ){\n\t\treturn blendLinearLight( base, blend );\n\t}else\n\tif( mode == 15 ){\n\t\treturn blendMultiply( base, blend );\n\t}else\n\tif( mode == 16 ){\n\t\treturn blendNegation( base, blend );\n\t}else\n\tif( mode == 17 ){\n\t\treturn blendNormal( base, blend );\n\t}else\n\tif( mode == 18 ){\n\t\treturn blendOverlay( base, blend );\n\t}else\n\tif( mode == 19 ){\n\t\treturn blendPhoenix( base, blend );\n\t}else\n\tif( mode == 20 ){\n\t\treturn blendPinLight( base, blend );\n\t}else\n\tif( mode == 21 ){\n\t\treturn blendReflect( base, blend );\n\t}else\n\tif( mode == 22 ){\n\t\treturn blendScreen( base, blend );\n\t}else\n\tif( mode == 23 ){\n\t\treturn blendSoftLight( base, blend );\n\t}else\n\tif( mode == 24 ){\n\t\treturn blendSubstract( base, blend );\n\t}else\n\tif( mode == 25 ){\n\t\treturn blendVividLight( base, blend );\n\t}\n\treturn vec3(0.0);\n}\nvec3 blendMode( int mode, vec3 base, vec3 blend ,float opacity){\n\tif( mode == 1 ){\n\t\treturn blendAdd( base, blend ,opacity);\n\t}else\n\tif( mode == 2 ){\n\t\treturn blendAverage( base, blend ,opacity);\n\t}else\n\tif( mode == 3 ){\n\t\treturn blendColorBurn( base, blend ,opacity);\n\t}else\n\tif( mode == 4 ){\n\t\treturn blendColorDodge( base, blend ,opacity);\n\t}else\n\tif( mode == 5 ){\n\t\treturn blendDarken( base, blend ,opacity);\n\t}else\n\tif( mode == 6 ){\n\t\treturn blendDifference( base, blend ,opacity);\n\t}else\n\tif( mode == 7 ){\n\t\treturn blendExclusion( base, blend,opacity );\n\t}else\n\tif( mode == 8 ){\n\t\treturn blendGlow( base, blend ,opacity);\n\t}else\n\tif( mode == 9 ){\n\t\treturn blendHardLight( base, blend ,opacity);\n\t}else\n\tif( mode == 10 ){\n\t\treturn blendHardMix( base, blend,opacity );\n\t}else\n\tif( mode == 11 ){\n\t\treturn blendLighten( base, blend ,opacity);\n\t}else\n\tif( mode == 12 ){\n\t\treturn blendLinearBurn( base, blend ,opacity);\n\t}else\n\tif( mode == 13 ){\n\t\treturn blendLinearDodge( base, blend,opacity );\n\t}else\n\tif( mode == 14 ){\n\t\treturn blendLinearLight( base, blend ,opacity);\n\t}else\n\tif( mode == 15 ){\n\t\treturn blendMultiply( base, blend ,opacity);\n\t}else\n\tif( mode == 16 ){\n\t\treturn blendNegation( base, blend ,opacity);\n\t}else\n\tif( mode == 17 ){\n\t\treturn blendNormal( base, blend ,opacity);\n\t}else\n\tif( mode == 18 ){\n\t\treturn blendOverlay( base, blend ,opacity);\n\t}else\n\tif( mode == 19 ){\n\t\treturn blendPhoenix( base, blend ,opacity);\n\t}else\n\tif( mode == 20 ){\n\t\treturn blendPinLight( base, blend ,opacity);\n\t}else\n\tif( mode == 21 ){\n\t\treturn blendReflect( base, blend ,opacity);\n\t}else\n\tif( mode == 22 ){\n\t\treturn blendScreen( base, blend ,opacity);\n\t}else\n\tif( mode == 23 ){\n\t\treturn blendSoftLight( base, blend ,opacity);\n\t}else\n\tif( mode == 24 ){\n\t\treturn blendSubstract( base, blend ,opacity);\n\t}else\n\tif( mode == 25 ){\n\t\treturn blendVividLight( base, blend ,opacity);\n\t}\n\treturn vec3(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = gl_FragCoord.xy/resolution.xy;\n  \n   /* vec4 prev = texture(iChannel0,uv);\n     prev*= 1.- texture(iChannel1,uv);\n     */\n     \n   vec3 fl = texture(iChannel0,uv).rgb;\n   \n   vec2 puv = uv;\n   \n   puv+=length(fl)*.08;\n   puv.y = 1.-puv.y;\n   vec3 textoloco = texture(iChannel1,puv).rgb;\n     \n        // textoloco = vec3(textoloco.r);\n         //  textoloco=mix(textoloco,fl,textoloco);\n        //textoloco=mix(textoloco,fl,textoloco)*2.1;\n   \n   vec3 fin = fl;\n        fin+=textoloco;\n   fragColor = vec4(fin,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float STfeed = 0.971;\nfloat STspeed = 0.81;\n\n#define time iTime\n#define resolution iResolution\n#define mouse iMouse\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat poly(vec2 uv,vec2 p, float s, float dif,int N,float a){\n    \n    // Remap the space to -1. to 1.\n    \n    vec2 st = p - uv ;\n    \n    \n    // Angle and radius from the current pixel\n    float a2 = atan(st.x,st.y)+a;\n    float r = TWO_PI/float(N);\n    \n    float d = cos(floor(.5+a2/r)*r-a2)*length(st);\n    float e = 1.0 - smoothstep(s,dif,d);\n      \n    return e;\n}\n\n\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.56222123);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\n\nfloat noise (in vec2 st,float fase) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float fase2 = fase;\n    // Four corners in 2D of a tile\n    float a = sin(random(i)*fase2);\n    float b =  sin(random(i + vec2(1.0, 0.0))*fase2);\n    float c =  sin(random(i + vec2(0.0, 1.0))*fase2);\n    float d =  sin(random(i + vec2(1.0, 1.0))*fase2);\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(1);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y) ;\n    return 20.0 * dot(m, g);\n}\n\n/*************************************************/\n\n// TODAS LAS FUNCIONES DE BLENDING SACADAS DE  https://github.com/jamieowen/glsl-blend\n\n\n///SOFT LIGHT\n#define ADD 1 \n#define\tAVERAGE 2\n#define\tCOLOR_BURN 3\n#define\tCOLOR_DODGE 4\n#define\tDARKEN 5\n#define\tDIFFERENCE 6\n#define\tEXCLUSION 7\n#define\tGLOW 8\n#define\tHARD_LIGHT 9\n#define\tHARD_MIX 10\n#define\tLIGHTEN 11\n#define\tLINEAR_BURN 12\n#define\tLINEAR_DODGE 13\n#define\tLINEAR_LIGHT 14\n#define\tMULTIPLY 15\n#define\tNEGATION 16\n#define\tNORMAL 17\n#define\tOVERLAY 18\n#define\tPHOENIX 19\n#define\tPIN_LIGHT 20\n#define\tREFLECT 21\n#define\tSCREEN 22\n#define\tSOFT_LIGHT 23\n#define\tSUBTRACT 24\n#define\tVIVID_LIGHT 25\n\n\nfloat blendSoftLight(float base, float blend) {\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n//ADD : \nfloat blendAdd(float base, float blend) {\n\treturn min(base+blend,1.0);\n}\n\nvec3 blendAdd(vec3 base, vec3 blend) {\n\treturn min(base+blend,vec3(1.0));\n}\n\nvec3 blendAdd(vec3 base, vec3 blend, float opacity) {\n\treturn (blendAdd(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendAverage(vec3 base, vec3 blend) {\n\treturn (base+blend)/2.0;\n}\n\nvec3 blendAverage(vec3 base, vec3 blend, float opacity) {\n\treturn (blendAverage(base, blend) * opacity + base * (1.0 - opacity));\n}\n  \nfloat blendColorBurn(float base, float blend) {\n\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend) {\n\treturn vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendColorDodge(float base, float blend) {\n\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend) {\n\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendDarken(float base, float blend) {\n\treturn min(blend,base);\n}\n\nvec3 blendDarken(vec3 base, vec3 blend) {\n\treturn vec3(blendDarken(base.r,blend.r),blendDarken(base.g,blend.g),blendDarken(base.b,blend.b));\n}\n\nvec3 blendDarken(vec3 base, vec3 blend, float opacity) {\n\treturn (blendDarken(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendDifference(vec3 base, vec3 blend) {\n\treturn abs(base-blend);\n}\n\nvec3 blendDifference(vec3 base, vec3 blend, float opacity) {\n\treturn (blendDifference(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendExclusion(vec3 base, vec3 blend) {\n\treturn base+blend-2.0*base*blend;\n}\n\nvec3 blendExclusion(vec3 base, vec3 blend, float opacity) {\n\treturn (blendExclusion(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendLighten(float base, float blend) {\n\treturn max(blend,base);\n}\n\nvec3 blendLighten(vec3 base, vec3 blend) {\n\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\n}\n\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearBurn(float base, float blend) {\n\t// Note : Same implementation as BlendSubtractf\n\treturn max(base+blend-1.0,0.0);\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendSubtract\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearDodge(float base, float blend) {\n\t// Note : Same implementation as BlendAddf\n\treturn min(base+blend,1.0);\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendAdd\n\treturn min(base+blend,vec3(1.0));\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearLight(float base, float blend) {\n\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend) {\n\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendMultiply(vec3 base, vec3 blend) {\n\treturn base*blend;\n}\n\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\n\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendNegation(vec3 base, vec3 blend) {\n\treturn vec3(1.0)-abs(vec3(1.0)-base-blend);\n}\n\nvec3 blendNegation(vec3 base, vec3 blend, float opacity) {\n\treturn (blendNegation(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nvec3 blendNormal(vec3 base, vec3 blend) {\n\treturn blend;\n}\n\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) {\n\treturn (blendNormal(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendOverlay(float base, float blend) {\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend) {\n\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendPhoenix(vec3 base, vec3 blend) {\n\treturn min(base,blend)-max(base,blend)+vec3(1.0);\n}\n\nvec3 blendPhoenix(vec3 base, vec3 blend, float opacity) {\n\treturn (blendPhoenix(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendPinLight(float base, float blend) {\n\treturn (blend<0.5)?blendDarken(base,(2.0*blend)):blendLighten(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendPinLight(vec3 base, vec3 blend) {\n\treturn vec3(blendPinLight(base.r,blend.r),blendPinLight(base.g,blend.g),blendPinLight(base.b,blend.b));\n}\n\nvec3 blendPinLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendPinLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendReflect(float base, float blend) {\n\treturn (blend==1.0)?blend:min(base*base/(1.0-blend),1.0);\n}\n\nvec3 blendReflect(vec3 base, vec3 blend) {\n\treturn vec3(blendReflect(base.r,blend.r),blendReflect(base.g,blend.g),blendReflect(base.b,blend.b));\n}\n\nvec3 blendReflect(vec3 base, vec3 blend, float opacity) {\n\treturn (blendReflect(base, blend) * opacity + base * (1.0 - opacity));\n}\n  \nfloat blendScreen(float base, float blend) {\n\treturn 1.0-((1.0-base)*(1.0-blend));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend) {\n\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\n\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendSubstract(float base, float blend) {\n\treturn max(base+blend-1.0,0.0);\n}\n\nvec3 blendSubstract(vec3 base, vec3 blend) {\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\n}\n\nvec3 blendSubstract(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSubstract(base, blend) * opacity + blend * (1.0 - opacity));\n}\nfloat blendVividLight(float base, float blend) {\n\treturn (blend<0.5)?blendColorBurn(base,(2.0*blend)):blendColorDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendVividLight(vec3 base, vec3 blend) {\n\treturn vec3(blendVividLight(base.r,blend.r),blendVividLight(base.g,blend.g),blendVividLight(base.b,blend.b));\n}\n\nvec3 blendVividLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendVividLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendHardLight(vec3 base, vec3 blend) {\n\treturn blendOverlay(blend,base);\n}\n\nvec3 blendHardLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendHardLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendGlow(vec3 base, vec3 blend) {\n\treturn blendReflect(blend,base);\n}\n\nvec3 blendGlow(vec3 base, vec3 blend, float opacity) {\n\treturn (blendGlow(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendHardMix(float base, float blend) {\n\treturn (blendVividLight(base,blend)<0.5)?0.0:1.0;\n}\n\nvec3 blendHardMix(vec3 base, vec3 blend) {\n\treturn vec3(blendHardMix(base.r,blend.r),blendHardMix(base.g,blend.g),blendHardMix(base.b,blend.b));\n}\n\nvec3 blendHardMix(vec3 base, vec3 blend, float opacity) {\n\treturn (blendHardMix(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendMode( int mode, vec3 base, vec3 blend ){\n\tif( mode == 1 ){\n\t\treturn blendAdd( base, blend );\n\t}else\n\tif( mode == 2 ){\n\t\treturn blendAverage( base, blend );\n\t}else\n\tif( mode == 3 ){\n\t\treturn blendColorBurn( base, blend );\n\t}else\n\tif( mode == 4 ){\n\t\treturn blendColorDodge( base, blend );\n\t}else\n\tif( mode == 5 ){\n\t\treturn blendDarken( base, blend );\n\t}else\n\tif( mode == 6 ){\n\t\treturn blendDifference( base, blend );\n\t}else\n\tif( mode == 7 ){\n\t\treturn blendExclusion( base, blend );\n\t}else\n\tif( mode == 8 ){\n\t\treturn blendGlow( base, blend );\n\t}else\n\tif( mode == 9 ){\n\t\treturn blendHardLight( base, blend );\n\t}else\n\tif( mode == 10 ){\n\t\treturn blendHardMix( base, blend );\n\t}else\n\tif( mode == 11 ){\n\t\treturn blendLighten( base, blend );\n\t}else\n\tif( mode == 12 ){\n\t\treturn blendLinearBurn( base, blend );\n\t}else\n\tif( mode == 13 ){\n\t\treturn blendLinearDodge( base, blend );\n\t}else\n\tif( mode == 14 ){\n\t\treturn blendLinearLight( base, blend );\n\t}else\n\tif( mode == 15 ){\n\t\treturn blendMultiply( base, blend );\n\t}else\n\tif( mode == 16 ){\n\t\treturn blendNegation( base, blend );\n\t}else\n\tif( mode == 17 ){\n\t\treturn blendNormal( base, blend );\n\t}else\n\tif( mode == 18 ){\n\t\treturn blendOverlay( base, blend );\n\t}else\n\tif( mode == 19 ){\n\t\treturn blendPhoenix( base, blend );\n\t}else\n\tif( mode == 20 ){\n\t\treturn blendPinLight( base, blend );\n\t}else\n\tif( mode == 21 ){\n\t\treturn blendReflect( base, blend );\n\t}else\n\tif( mode == 22 ){\n\t\treturn blendScreen( base, blend );\n\t}else\n\tif( mode == 23 ){\n\t\treturn blendSoftLight( base, blend );\n\t}else\n\tif( mode == 24 ){\n\t\treturn blendSubstract( base, blend );\n\t}else\n\tif( mode == 25 ){\n\t\treturn blendVividLight( base, blend );\n\t}\n\treturn vec3(0.0);\n}\nvec3 blendMode( int mode, vec3 base, vec3 blend ,float opacity){\n\tif( mode == 1 ){\n\t\treturn blendAdd( base, blend ,opacity);\n\t}else\n\tif( mode == 2 ){\n\t\treturn blendAverage( base, blend ,opacity);\n\t}else\n\tif( mode == 3 ){\n\t\treturn blendColorBurn( base, blend ,opacity);\n\t}else\n\tif( mode == 4 ){\n\t\treturn blendColorDodge( base, blend ,opacity);\n\t}else\n\tif( mode == 5 ){\n\t\treturn blendDarken( base, blend ,opacity);\n\t}else\n\tif( mode == 6 ){\n\t\treturn blendDifference( base, blend ,opacity);\n\t}else\n\tif( mode == 7 ){\n\t\treturn blendExclusion( base, blend,opacity );\n\t}else\n\tif( mode == 8 ){\n\t\treturn blendGlow( base, blend ,opacity);\n\t}else\n\tif( mode == 9 ){\n\t\treturn blendHardLight( base, blend ,opacity);\n\t}else\n\tif( mode == 10 ){\n\t\treturn blendHardMix( base, blend,opacity );\n\t}else\n\tif( mode == 11 ){\n\t\treturn blendLighten( base, blend ,opacity);\n\t}else\n\tif( mode == 12 ){\n\t\treturn blendLinearBurn( base, blend ,opacity);\n\t}else\n\tif( mode == 13 ){\n\t\treturn blendLinearDodge( base, blend,opacity );\n\t}else\n\tif( mode == 14 ){\n\t\treturn blendLinearLight( base, blend ,opacity);\n\t}else\n\tif( mode == 15 ){\n\t\treturn blendMultiply( base, blend ,opacity);\n\t}else\n\tif( mode == 16 ){\n\t\treturn blendNegation( base, blend ,opacity);\n\t}else\n\tif( mode == 17 ){\n\t\treturn blendNormal( base, blend ,opacity);\n\t}else\n\tif( mode == 18 ){\n\t\treturn blendOverlay( base, blend ,opacity);\n\t}else\n\tif( mode == 19 ){\n\t\treturn blendPhoenix( base, blend ,opacity);\n\t}else\n\tif( mode == 20 ){\n\t\treturn blendPinLight( base, blend ,opacity);\n\t}else\n\tif( mode == 21 ){\n\t\treturn blendReflect( base, blend ,opacity);\n\t}else\n\tif( mode == 22 ){\n\t\treturn blendScreen( base, blend ,opacity);\n\t}else\n\tif( mode == 23 ){\n\t\treturn blendSoftLight( base, blend ,opacity);\n\t}else\n\tif( mode == 24 ){\n\t\treturn blendSubstract( base, blend ,opacity);\n\t}else\n\tif( mode == 25 ){\n\t\treturn blendVividLight( base, blend ,opacity);\n\t}\n\treturn vec3(0.0);\n}\n\n// ↙\n//  ↙\n//   ↙\n// https://youtu.be/dQw4w9WgXcQ\n\n// compare algorithm performance, comment out line below to see previous performance:\n#define ANOTHER_ALGORITHM      // runs slower on ARM, so comment this out if mobile phone performance is priority\n\nvec2 uv;\n\n#define time iTime\n#define resolution iResolution\n\nconst vec2 ch_size  = vec2(1.0, 2.0) * 0.6;              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.5, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -5., 1.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\n//      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)\n//const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n// split 16 Bit int into two 8 Bit int for mobile phones with ridiculous 1-byte int\n#define n0 ddigit(0x22,0xFF);\n#define n1 ddigit(0x02,0x81);\n#define n2 ddigit(0x11,0x77);\n#define n3 ddigit(0x11,0xE7);\n#define n4 ddigit(0x55,0x08);\n#define n5 ddigit(0x11,0xEE);\n#define n6 ddigit(0x11,0xFE);\n#define n7 ddigit(0x22,0x06);\n#define n8 ddigit(0x11,0xFF);\n#define n9 ddigit(0x11,0xEF);\n\n#define A ddigit(0x11,0x9F);\n#define B ddigit(0x92,0x7E);\n#define C ddigit(0x00,0x7E);\n#define D ddigit(0x44,0xE7);\n#define E ddigit(0x10,0x7E);\n#define F ddigit(0x10,0x1E);\n#define G ddigit(0x80,0x7E);\n#define H ddigit(0x11,0x99);\n#define I ddigit(0x44,0x66);\n#define J ddigit(0x44,0x36);\n#define K ddigit(0x92,0x18);\n#define L ddigit(0x00,0x78);\n#define M ddigit(0x0A,0x99);\n#define N ddigit(0x88,0x99);\n#define O ddigit(0x00,0xFF);\n#define P ddigit(0x11,0x1F);\n#define Q ddigit(0x80,0xFF);\n#define R ddigit(0x91,0x1F);\n#define S ddigit(0x88,0x66);\n#define T ddigit(0x44,0x06);\n#define U ddigit(0x00,0xF9);\n#define u ddigit(0x00,0xF0);\n#define V ddigit(0x22,0x18);\n#define W ddigit(0xA0,0x99);\n#define w ddigit(0xA0,0x90);\n#define X ddigit(0xAA,0x00);\n#define Y ddigit(0x4A,0x00);\n#define Z ddigit(0x22,0x66);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0,0);\n#define s_minus   ddigit(0x11,0x00);\n#define s_plus    ddigit(0x55,0x00);\n#define s_greater ddigit(0x28,0x00);\n#define s_less    ddigit(0x82,0x00);\n#define s_sqrt    ddigit(0x0C,0x02);\n#define s_sw      ddigit(0x55,0xAA);\n#define s_pow     ddigit(0x02,0x01);\n#define upper_u   ddigit(0x11,0x09);\n#define s_bra    ddigit(0x00,0x3C);\n#define s_ket    ddigit(0x00,0xC3);\n#define s_quotl    ddigit(0x04,0x01);\n#define s_quotr    ddigit(0x04,0x08);\n#define s_degrees    ddigit(0x05,0x03);\n#define s_ast    ddigit(0xFF,0x00);\n#define s_question ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x41,0x07);\n#define s_exclam   ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x44,0x00);\n#define s_comma   ch_pos-=vec2(.45); ddigit(0x20,0x00); ch_pos+=vec2(.45);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n\n#ifdef ANOTHER_ALGORITHM\nfloat dseg1(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x-(uv.y*.5-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\nfloat dseg2(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x+(uv.y*.5-.9-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n#else\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n}\n#endif\nfloat dsegH(vec2 p0, vec2 p1) // avoiding matric ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n\treturn distance(cp, vec2(clamp(cp.x, 0., p1.x-p0.x), 0.) );\n}\nfloat dsegV(vec2 p0, vec2 p1) // avoiding matrix ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(0, distance(p0, p1))));\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n\nbool bit(int n)\n{\n\treturn (n/2)*2 != n;\n}\n\nfloat d = 1e6;\n\n#ifdef ANOTHER_ALGORITHM\t\t// Intel skylake GPU seems to prefer this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n\tvec2 cp = uv - ch_pos;\n\t// better performance in this order, on Intel Iris 550 skylake  (WHY does order matter??)\n\tif (n == 0 && nn==0)     v = min(v, dsegH(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/4)) v = min(v, dsegH(vec2( -0.438,  1.000), vec2(-0.063, 1.000)));\n\tif (bit(nn/2)) v = min(v, dsegH(vec2(0.063,  1.000), vec2(0.438,  1.000)));\n\tif (bit(nn/32)) v = min(v, dsegH(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dsegH(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n/1)) v = min(v, dsegH(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/16)) v = min(v, dsegH(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(nn/1)) v = min(v, dsegV(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/128)) v = min(v, dsegV(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/4)) v = min(v, dsegV(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/64)) v = min(v, dsegV(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(nn/8)) v = min(v, dsegV(vec2(-0.500,  0.063), vec2(-0.500,  0.937)));\n\tif (bit(nn/16)) v = min(v, dsegV(vec2(-0.500, -0.938), vec2(-0.500, -0.063)));\n\t// matrix ops last\n\tif (bit(n/2)) v = min(v, dseg1(vec2( 0.063,  0.063), vec2( 0.063,  0.938)));\n\tif (bit(n/8)) v = min(v, dseg2(vec2(-0.963,  0.063), vec2(-1.338,  0.938)));\n\tif (bit(n/32)) v = min(v, dseg1(vec2(-0.963, -0.938), vec2(-0.963, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg2(vec2( 0.063, -0.938), vec2( 0.063, -0.063)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#else\t\t// some GPU's may run faster with this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n    vec2 cp = uv - ch_pos;\n    if (n == 0 && nn == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/1)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/2)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(nn/4)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(nn/8)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(nn/16)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(nn/32)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(nn/128)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/1)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/2)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n/4)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/8)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n/16)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n/32)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n/64)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#endif\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvec3 fractalLoco(){\n    vec2 uv = gl_FragCoord.xy/resolution.xy;\n    \n    uv = fract(uv);\n    //float n = snoise(vec2(uv.x*STnoise,uv.y*STnoise-time*5))*0.5+0.5;\n    \n    vec2 coords = uv;\n    \n    coords -= vec2(0.5);\n    coords = rotate2d(STspeed) * coords;\n    coords += vec2(0.5);\n    \n    vec4 spec2 = vec4(1.0);\n    coords = fract(coords*1.05); \n    vec4 prev = texture(iChannel0,coords);\n    \n\n    int cant = 3;\n    vec3 dib = vec3(0.);\n    \n    vec2 mov = vec2(0.);\n    \n    if(mouse.z > 0.){\n        mov.x = mouse.x/resolution.x;\n        mov.y = mouse.y/resolution.y;\n    }else{\n    \n    \n        mov.x = sin(time)*.4+.5+cos(time*2.)*.2;\n        mov.y = cos(time)*.4+.5+sin(time*2.)*.2;\n    }\n    float e =  poly(\n       uv,\n       mov\n       ,0.08*sin(uv.x*100.+sin(uv.y*30.+time*2.))\n            ,0.08,\n            3\n            ,0.) ;\n    dib+=e;\n       /*  e +=     \n       vec4(poly(\n       uv,\n       vec2(mouse.x,1.-mouse.y)\n       ,0.08*sin(uv.x*100.+sin(uv.y*30.+time*2.))\n            ,0.08,\n            3\n            ,0.));*/\n\n\n        dib.g *= noise(uv,PI/2.)*sin(uv.x*30.);\n        dib.b *= noise(uv,PI);\n        dib.r *= noise(uv,PI/17.)*3.;\n    \n    vec2 p = vec2(0.5) -uv;\n    float r = length(p);\n    //dib = vec3(e);\n    \n    vec3 fin = dib*4.+prev.rgb*0.9;\n    return fin ;\n}\nvec3 generarTextoLoco(){\n     vec3 fractalloco = fractalLoco();\n    //fragColor = vec4(fractalLoco();,1.);\n    //fragColor = vec4(vec3(1.0,0.0,0.0),1.);\n    vec2 aspect = resolution.xy / resolution.y;\n\tuv = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\n\tfloat _d =  1.0-length(uv);\n\tuv *= 24.0 ;\n\tuv -= vec2(-10., 4.);\n    //uv *= rotate(time+uv.x*0.05);\n\n\tuv.x+=3. + sin(uv.y*1.5+time*3.)*.15;\n\tch_pos = ch_start;\n\n\t\t\tnl2\n\t   \t\t_ _ _ _ _ _ _ F U N K Y _ B E A T _ _ _ _ _\n    float a = smoothstep(0.6,0.1,d);\n    float b = smoothstep(0.5,0.4,d) * .8;\n  \tvec3 ch_color = hsv2rgb_smooth(vec3(time*0.4+uv.y*0.1,0.5,1.0));\n    vec3 col=ch_color*a;\n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec3 col=fractalLoco();\n         //col+=fractalLoco();\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float STfeed = 0.971;\nfloat STspeed = 0.81;\n\n#define time iTime\n#define resolution iResolution\n#define mouse iMouse\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat poly(vec2 uv,vec2 p, float s, float dif,int N,float a){\n    \n    // Remap the space to -1. to 1.\n    \n    vec2 st = p - uv ;\n    \n    \n    // Angle and radius from the current pixel\n    float a2 = atan(st.x,st.y)+a;\n    float r = TWO_PI/float(N);\n    \n    float d = cos(floor(.5+a2/r)*r-a2)*length(st);\n    float e = 1.0 - smoothstep(s,dif,d);\n      \n    return e;\n}\n\n\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.56222123);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\n\nfloat noise (in vec2 st,float fase) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float fase2 = fase;\n    // Four corners in 2D of a tile\n    float a = sin(random(i)*fase2);\n    float b =  sin(random(i + vec2(1.0, 0.0))*fase2);\n    float c =  sin(random(i + vec2(0.0, 1.0))*fase2);\n    float d =  sin(random(i + vec2(1.0, 1.0))*fase2);\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(1);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y) ;\n    return 20.0 * dot(m, g);\n}\n\n/*************************************************/\n\n// TODAS LAS FUNCIONES DE BLENDING SACADAS DE  https://github.com/jamieowen/glsl-blend\n\n\n///SOFT LIGHT\n#define ADD 1 \n#define\tAVERAGE 2\n#define\tCOLOR_BURN 3\n#define\tCOLOR_DODGE 4\n#define\tDARKEN 5\n#define\tDIFFERENCE 6\n#define\tEXCLUSION 7\n#define\tGLOW 8\n#define\tHARD_LIGHT 9\n#define\tHARD_MIX 10\n#define\tLIGHTEN 11\n#define\tLINEAR_BURN 12\n#define\tLINEAR_DODGE 13\n#define\tLINEAR_LIGHT 14\n#define\tMULTIPLY 15\n#define\tNEGATION 16\n#define\tNORMAL 17\n#define\tOVERLAY 18\n#define\tPHOENIX 19\n#define\tPIN_LIGHT 20\n#define\tREFLECT 21\n#define\tSCREEN 22\n#define\tSOFT_LIGHT 23\n#define\tSUBTRACT 24\n#define\tVIVID_LIGHT 25\n\n\nfloat blendSoftLight(float base, float blend) {\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n//ADD : \nfloat blendAdd(float base, float blend) {\n\treturn min(base+blend,1.0);\n}\n\nvec3 blendAdd(vec3 base, vec3 blend) {\n\treturn min(base+blend,vec3(1.0));\n}\n\nvec3 blendAdd(vec3 base, vec3 blend, float opacity) {\n\treturn (blendAdd(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendAverage(vec3 base, vec3 blend) {\n\treturn (base+blend)/2.0;\n}\n\nvec3 blendAverage(vec3 base, vec3 blend, float opacity) {\n\treturn (blendAverage(base, blend) * opacity + base * (1.0 - opacity));\n}\n  \nfloat blendColorBurn(float base, float blend) {\n\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend) {\n\treturn vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendColorDodge(float base, float blend) {\n\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend) {\n\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendDarken(float base, float blend) {\n\treturn min(blend,base);\n}\n\nvec3 blendDarken(vec3 base, vec3 blend) {\n\treturn vec3(blendDarken(base.r,blend.r),blendDarken(base.g,blend.g),blendDarken(base.b,blend.b));\n}\n\nvec3 blendDarken(vec3 base, vec3 blend, float opacity) {\n\treturn (blendDarken(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendDifference(vec3 base, vec3 blend) {\n\treturn abs(base-blend);\n}\n\nvec3 blendDifference(vec3 base, vec3 blend, float opacity) {\n\treturn (blendDifference(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendExclusion(vec3 base, vec3 blend) {\n\treturn base+blend-2.0*base*blend;\n}\n\nvec3 blendExclusion(vec3 base, vec3 blend, float opacity) {\n\treturn (blendExclusion(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendLighten(float base, float blend) {\n\treturn max(blend,base);\n}\n\nvec3 blendLighten(vec3 base, vec3 blend) {\n\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\n}\n\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearBurn(float base, float blend) {\n\t// Note : Same implementation as BlendSubtractf\n\treturn max(base+blend-1.0,0.0);\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendSubtract\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearDodge(float base, float blend) {\n\t// Note : Same implementation as BlendAddf\n\treturn min(base+blend,1.0);\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendAdd\n\treturn min(base+blend,vec3(1.0));\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearLight(float base, float blend) {\n\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend) {\n\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendMultiply(vec3 base, vec3 blend) {\n\treturn base*blend;\n}\n\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\n\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendNegation(vec3 base, vec3 blend) {\n\treturn vec3(1.0)-abs(vec3(1.0)-base-blend);\n}\n\nvec3 blendNegation(vec3 base, vec3 blend, float opacity) {\n\treturn (blendNegation(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nvec3 blendNormal(vec3 base, vec3 blend) {\n\treturn blend;\n}\n\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) {\n\treturn (blendNormal(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendOverlay(float base, float blend) {\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend) {\n\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendPhoenix(vec3 base, vec3 blend) {\n\treturn min(base,blend)-max(base,blend)+vec3(1.0);\n}\n\nvec3 blendPhoenix(vec3 base, vec3 blend, float opacity) {\n\treturn (blendPhoenix(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendPinLight(float base, float blend) {\n\treturn (blend<0.5)?blendDarken(base,(2.0*blend)):blendLighten(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendPinLight(vec3 base, vec3 blend) {\n\treturn vec3(blendPinLight(base.r,blend.r),blendPinLight(base.g,blend.g),blendPinLight(base.b,blend.b));\n}\n\nvec3 blendPinLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendPinLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendReflect(float base, float blend) {\n\treturn (blend==1.0)?blend:min(base*base/(1.0-blend),1.0);\n}\n\nvec3 blendReflect(vec3 base, vec3 blend) {\n\treturn vec3(blendReflect(base.r,blend.r),blendReflect(base.g,blend.g),blendReflect(base.b,blend.b));\n}\n\nvec3 blendReflect(vec3 base, vec3 blend, float opacity) {\n\treturn (blendReflect(base, blend) * opacity + base * (1.0 - opacity));\n}\n  \nfloat blendScreen(float base, float blend) {\n\treturn 1.0-((1.0-base)*(1.0-blend));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend) {\n\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\n\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendSubstract(float base, float blend) {\n\treturn max(base+blend-1.0,0.0);\n}\n\nvec3 blendSubstract(vec3 base, vec3 blend) {\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\n}\n\nvec3 blendSubstract(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSubstract(base, blend) * opacity + blend * (1.0 - opacity));\n}\nfloat blendVividLight(float base, float blend) {\n\treturn (blend<0.5)?blendColorBurn(base,(2.0*blend)):blendColorDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendVividLight(vec3 base, vec3 blend) {\n\treturn vec3(blendVividLight(base.r,blend.r),blendVividLight(base.g,blend.g),blendVividLight(base.b,blend.b));\n}\n\nvec3 blendVividLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendVividLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendHardLight(vec3 base, vec3 blend) {\n\treturn blendOverlay(blend,base);\n}\n\nvec3 blendHardLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendHardLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendGlow(vec3 base, vec3 blend) {\n\treturn blendReflect(blend,base);\n}\n\nvec3 blendGlow(vec3 base, vec3 blend, float opacity) {\n\treturn (blendGlow(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendHardMix(float base, float blend) {\n\treturn (blendVividLight(base,blend)<0.5)?0.0:1.0;\n}\n\nvec3 blendHardMix(vec3 base, vec3 blend) {\n\treturn vec3(blendHardMix(base.r,blend.r),blendHardMix(base.g,blend.g),blendHardMix(base.b,blend.b));\n}\n\nvec3 blendHardMix(vec3 base, vec3 blend, float opacity) {\n\treturn (blendHardMix(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendMode( int mode, vec3 base, vec3 blend ){\n\tif( mode == 1 ){\n\t\treturn blendAdd( base, blend );\n\t}else\n\tif( mode == 2 ){\n\t\treturn blendAverage( base, blend );\n\t}else\n\tif( mode == 3 ){\n\t\treturn blendColorBurn( base, blend );\n\t}else\n\tif( mode == 4 ){\n\t\treturn blendColorDodge( base, blend );\n\t}else\n\tif( mode == 5 ){\n\t\treturn blendDarken( base, blend );\n\t}else\n\tif( mode == 6 ){\n\t\treturn blendDifference( base, blend );\n\t}else\n\tif( mode == 7 ){\n\t\treturn blendExclusion( base, blend );\n\t}else\n\tif( mode == 8 ){\n\t\treturn blendGlow( base, blend );\n\t}else\n\tif( mode == 9 ){\n\t\treturn blendHardLight( base, blend );\n\t}else\n\tif( mode == 10 ){\n\t\treturn blendHardMix( base, blend );\n\t}else\n\tif( mode == 11 ){\n\t\treturn blendLighten( base, blend );\n\t}else\n\tif( mode == 12 ){\n\t\treturn blendLinearBurn( base, blend );\n\t}else\n\tif( mode == 13 ){\n\t\treturn blendLinearDodge( base, blend );\n\t}else\n\tif( mode == 14 ){\n\t\treturn blendLinearLight( base, blend );\n\t}else\n\tif( mode == 15 ){\n\t\treturn blendMultiply( base, blend );\n\t}else\n\tif( mode == 16 ){\n\t\treturn blendNegation( base, blend );\n\t}else\n\tif( mode == 17 ){\n\t\treturn blendNormal( base, blend );\n\t}else\n\tif( mode == 18 ){\n\t\treturn blendOverlay( base, blend );\n\t}else\n\tif( mode == 19 ){\n\t\treturn blendPhoenix( base, blend );\n\t}else\n\tif( mode == 20 ){\n\t\treturn blendPinLight( base, blend );\n\t}else\n\tif( mode == 21 ){\n\t\treturn blendReflect( base, blend );\n\t}else\n\tif( mode == 22 ){\n\t\treturn blendScreen( base, blend );\n\t}else\n\tif( mode == 23 ){\n\t\treturn blendSoftLight( base, blend );\n\t}else\n\tif( mode == 24 ){\n\t\treturn blendSubstract( base, blend );\n\t}else\n\tif( mode == 25 ){\n\t\treturn blendVividLight( base, blend );\n\t}\n\treturn vec3(0.0);\n}\nvec3 blendMode( int mode, vec3 base, vec3 blend ,float opacity){\n\tif( mode == 1 ){\n\t\treturn blendAdd( base, blend ,opacity);\n\t}else\n\tif( mode == 2 ){\n\t\treturn blendAverage( base, blend ,opacity);\n\t}else\n\tif( mode == 3 ){\n\t\treturn blendColorBurn( base, blend ,opacity);\n\t}else\n\tif( mode == 4 ){\n\t\treturn blendColorDodge( base, blend ,opacity);\n\t}else\n\tif( mode == 5 ){\n\t\treturn blendDarken( base, blend ,opacity);\n\t}else\n\tif( mode == 6 ){\n\t\treturn blendDifference( base, blend ,opacity);\n\t}else\n\tif( mode == 7 ){\n\t\treturn blendExclusion( base, blend,opacity );\n\t}else\n\tif( mode == 8 ){\n\t\treturn blendGlow( base, blend ,opacity);\n\t}else\n\tif( mode == 9 ){\n\t\treturn blendHardLight( base, blend ,opacity);\n\t}else\n\tif( mode == 10 ){\n\t\treturn blendHardMix( base, blend,opacity );\n\t}else\n\tif( mode == 11 ){\n\t\treturn blendLighten( base, blend ,opacity);\n\t}else\n\tif( mode == 12 ){\n\t\treturn blendLinearBurn( base, blend ,opacity);\n\t}else\n\tif( mode == 13 ){\n\t\treturn blendLinearDodge( base, blend,opacity );\n\t}else\n\tif( mode == 14 ){\n\t\treturn blendLinearLight( base, blend ,opacity);\n\t}else\n\tif( mode == 15 ){\n\t\treturn blendMultiply( base, blend ,opacity);\n\t}else\n\tif( mode == 16 ){\n\t\treturn blendNegation( base, blend ,opacity);\n\t}else\n\tif( mode == 17 ){\n\t\treturn blendNormal( base, blend ,opacity);\n\t}else\n\tif( mode == 18 ){\n\t\treturn blendOverlay( base, blend ,opacity);\n\t}else\n\tif( mode == 19 ){\n\t\treturn blendPhoenix( base, blend ,opacity);\n\t}else\n\tif( mode == 20 ){\n\t\treturn blendPinLight( base, blend ,opacity);\n\t}else\n\tif( mode == 21 ){\n\t\treturn blendReflect( base, blend ,opacity);\n\t}else\n\tif( mode == 22 ){\n\t\treturn blendScreen( base, blend ,opacity);\n\t}else\n\tif( mode == 23 ){\n\t\treturn blendSoftLight( base, blend ,opacity);\n\t}else\n\tif( mode == 24 ){\n\t\treturn blendSubstract( base, blend ,opacity);\n\t}else\n\tif( mode == 25 ){\n\t\treturn blendVividLight( base, blend ,opacity);\n\t}\n\treturn vec3(0.0);\n}\n\n// ↙\n//  ↙\n//   ↙\n// https://youtu.be/dQw4w9WgXcQ\n\n// compare algorithm performance, comment out line below to see previous performance:\n#define ANOTHER_ALGORITHM      // runs slower on ARM, so comment this out if mobile phone performance is priority\n\nvec2 uv;\n\n#define time iTime\n#define resolution iResolution\n\nconst vec2 ch_size  = vec2(1.0, 2.0) * 0.6;              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.5, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -5., 1.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\n//      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)\n//const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n// split 16 Bit int into two 8 Bit int for mobile phones with ridiculous 1-byte int\n#define n0 ddigit(0x22,0xFF);\n#define n1 ddigit(0x02,0x81);\n#define n2 ddigit(0x11,0x77);\n#define n3 ddigit(0x11,0xE7);\n#define n4 ddigit(0x55,0x08);\n#define n5 ddigit(0x11,0xEE);\n#define n6 ddigit(0x11,0xFE);\n#define n7 ddigit(0x22,0x06);\n#define n8 ddigit(0x11,0xFF);\n#define n9 ddigit(0x11,0xEF);\n\n#define A ddigit(0x11,0x9F);\n#define B ddigit(0x92,0x7E);\n#define C ddigit(0x00,0x7E);\n#define D ddigit(0x44,0xE7);\n#define E ddigit(0x10,0x7E);\n#define F ddigit(0x10,0x1E);\n#define G ddigit(0x80,0x7E);\n#define H ddigit(0x11,0x99);\n#define I ddigit(0x44,0x66);\n#define J ddigit(0x44,0x36);\n#define K ddigit(0x92,0x18);\n#define L ddigit(0x00,0x78);\n#define M ddigit(0x0A,0x99);\n#define N ddigit(0x88,0x99);\n#define O ddigit(0x00,0xFF);\n#define P ddigit(0x11,0x1F);\n#define Q ddigit(0x80,0xFF);\n#define R ddigit(0x91,0x1F);\n#define S ddigit(0x88,0x66);\n#define T ddigit(0x44,0x06);\n#define U ddigit(0x00,0xF9);\n#define u ddigit(0x00,0xF0);\n#define V ddigit(0x22,0x18);\n#define W ddigit(0xA0,0x99);\n#define w ddigit(0xA0,0x90);\n#define X ddigit(0xAA,0x00);\n#define Y ddigit(0x4A,0x00);\n#define Z ddigit(0x22,0x66);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0,0);\n#define s_minus   ddigit(0x11,0x00);\n#define s_plus    ddigit(0x55,0x00);\n#define s_greater ddigit(0x28,0x00);\n#define s_less    ddigit(0x82,0x00);\n#define s_sqrt    ddigit(0x0C,0x02);\n#define s_sw      ddigit(0x55,0xAA);\n#define s_pow     ddigit(0x02,0x01);\n#define upper_u   ddigit(0x11,0x09);\n#define s_bra    ddigit(0x00,0x3C);\n#define s_ket    ddigit(0x00,0xC3);\n#define s_quotl    ddigit(0x04,0x01);\n#define s_quotr    ddigit(0x04,0x08);\n#define s_degrees    ddigit(0x05,0x03);\n#define s_ast    ddigit(0xFF,0x00);\n#define s_question ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x41,0x07);\n#define s_exclam   ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x44,0x00);\n#define s_comma   ch_pos-=vec2(.45); ddigit(0x20,0x00); ch_pos+=vec2(.45);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n\n#ifdef ANOTHER_ALGORITHM\nfloat dseg1(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x-(uv.y*.5-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\nfloat dseg2(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x+(uv.y*.5-.9-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n#else\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n}\n#endif\nfloat dsegH(vec2 p0, vec2 p1) // avoiding matric ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n\treturn distance(cp, vec2(clamp(cp.x, 0., p1.x-p0.x), 0.) );\n}\nfloat dsegV(vec2 p0, vec2 p1) // avoiding matrix ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(0, distance(p0, p1))));\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n\nbool bit(int n)\n{\n\treturn (n/2)*2 != n;\n}\n\nfloat d = 1e6;\n\n#ifdef ANOTHER_ALGORITHM\t\t// Intel skylake GPU seems to prefer this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n\tvec2 cp = uv - ch_pos;\n\t// better performance in this order, on Intel Iris 550 skylake  (WHY does order matter??)\n\tif (n == 0 && nn==0)     v = min(v, dsegH(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/4)) v = min(v, dsegH(vec2( -0.438,  1.000), vec2(-0.063, 1.000)));\n\tif (bit(nn/2)) v = min(v, dsegH(vec2(0.063,  1.000), vec2(0.438,  1.000)));\n\tif (bit(nn/32)) v = min(v, dsegH(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dsegH(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n/1)) v = min(v, dsegH(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/16)) v = min(v, dsegH(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(nn/1)) v = min(v, dsegV(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/128)) v = min(v, dsegV(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/4)) v = min(v, dsegV(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/64)) v = min(v, dsegV(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(nn/8)) v = min(v, dsegV(vec2(-0.500,  0.063), vec2(-0.500,  0.937)));\n\tif (bit(nn/16)) v = min(v, dsegV(vec2(-0.500, -0.938), vec2(-0.500, -0.063)));\n\t// matrix ops last\n\tif (bit(n/2)) v = min(v, dseg1(vec2( 0.063,  0.063), vec2( 0.063,  0.938)));\n\tif (bit(n/8)) v = min(v, dseg2(vec2(-0.963,  0.063), vec2(-1.338,  0.938)));\n\tif (bit(n/32)) v = min(v, dseg1(vec2(-0.963, -0.938), vec2(-0.963, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg2(vec2( 0.063, -0.938), vec2( 0.063, -0.063)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#else\t\t// some GPU's may run faster with this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n    vec2 cp = uv - ch_pos;\n    if (n == 0 && nn == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/1)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/2)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(nn/4)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(nn/8)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(nn/16)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(nn/32)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(nn/128)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/1)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/2)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n/4)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/8)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n/16)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n/32)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n/64)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#endif\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvec3 generarTextoLoco(){\n   \n    //fragColor = vec4(fractalLoco();,1.);\n    //fragColor = vec4(vec3(1.0,0.0,0.0),1.);\n    vec2 aspect = resolution.xy / resolution.y;\n\tuv = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\n\tfloat _d =  1.0-length(uv);\n    \n    \n    uv-=vec2(0.5);\n    uv*=scale(vec2(1.0));\n    uv+=vec2(0.5);\n    \n\tuv *= 40.0 ;\n\t\n    uv -= vec2(-8., 4.);\n    //uv *= rotate(time+uv.x*0.05);\n\n\t//uv.x+=4. + sin(uv.y*1.5+time*3.)*.15;\n\tch_pos = ch_start;\n\n\t\t\tnl2\n\t   \t\t_ _ _ _ _ _ _ J P U P P E R _ _ _ _ _\n    float a = smoothstep(0.6,0.1,d);\n    float b = smoothstep(0.5,0.4,d) * .8;\n  \tvec3 ch_color = hsv2rgb_smooth(vec3(time*0.4+uv.y*0.1,0.5,1.0));\n    vec3 col=ch_color*a;\n    return col;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec3 col=generarTextoLoco();\n       //  col+=texto;\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}