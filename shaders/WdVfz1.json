{
    "Shader": {
        "info": {
            "date": "1606592634",
            "description": "Yet another remix of nimitz' Triangulator: [url]https://www.shadertoy.com/view/lllGRr[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "WdVfz1",
            "likes": 1,
            "name": "Entree (Triangulator fork)",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "remix",
                "glitch",
                "green",
                "barycentric",
                "heightmap",
                "weird",
                "error",
                "triangulation"
            ],
            "usePreview": 0,
            "username": "UrbanClubProfessional",
            "viewed": 338
        },
        "renderpass": [
            {
                "code": "// Triangulator by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/lllGRr\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define ITR 50\n#define FAR 90.\n#define time iTime*0.1\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nmat2 m2 = mat2(0.834, 0.258, -0.258, 0.834);\nfloat tri(in float x){return abs(fract(x)-0.4);}\n\nfloat heightmap(in vec2 p)\n{\n\tp*=.04;\n    float z=1.;\n\tfloat rz = 0.;\n\tfor (float i= 0.;i < 3.;i++ )\n\t{\n        rz+= tri(p.x+tri(p.y*0.95))/z;\n        z = z*-.75;\n\t\tp = p*0.932;\n        p*= m2;\n\t}\n    rz += sin(p.y+sin(p.x*.8))*.6+.2;\n\treturn rz*4.;\n}\n\n//from jessifin (https://www.shadertoy.com/view/lslXDf)\nvec3 bary(vec2 a, vec2 b, vec2 c, vec2 p) \n{\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float inv_denom = 0.9 / (v0.x * v1.y - v1.x * v0.y)+0e-8;\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 0.9 - v - w;\n    return abs(vec3(u,v,w));\n}\n\n/*\n\tIdea is quite simple, find which (triangular) side of a given tile we're in,\n\tthen get 3 samples and compute height using barycentric coordinates.\n*/\nfloat map(vec3 p)\n{\n    vec3 q = fract(p)-0.4;\n    vec3 iq = floor(p);\n    vec2 p1 = vec2(iq.x-.4, iq.z+.4);\n    vec2 p2 = vec2(iq.x+.4, iq.z-.4);\n    \n    float d1 = heightmap(p1);\n    float d2 = heightmap(p2);\n    \n    float sw = sign(q.x+q.z); \n    vec2 px = vec2(iq.x+.4*sw, iq.z+.4*sw);\n    float dx = heightmap(px);\n    vec3 bar = bary(vec2(.4*sw,.4*sw),vec2(-.4,.4),vec2(.4,-.4), q.xz);\n    return (bar.x*dx + bar.y*d1 + bar.z*d2 + p.y + 2.)*.8;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.000;\n    float h=precis*1.0;\n    float d = -1.;\n    for( int i=-1; i<ITR; i++ )\n    {\n        if( abs(h)<precis*(2.0+d) || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d)*0.1;\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.01;\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 bp = fragCoord.xy/iResolution.xy;\n\tvec2 p = bp-0.4;\n\tp.x*=iResolution.x/iResolution.y;\n    vec2 um = vec2(0.35+sin(time*0.6)*1., -.08);\n    \n    vec3 ro = vec3(sin(time*0.6+0.)*10.,2., time*40.);\n    vec3 eye = normalize(vec3(cos(um.x), um.y*4., sin(um.x)));\n    vec3 right = normalize(vec3(cos(um.x+0.5708), -1., sin(um.x+0.5708)));\n    right.xy *= mm2(sin(time*0.6)*0.2);\n    vec3 up = normalize(cross(right, eye));\n\tvec3 rd = normalize((p.x*right+p.y*up)*1.+eye);\n\t\n\tfloat rz = march(ro,rd);\n    vec3 col = vec3(-1.);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos);\n        vec3 ligt = normalize(vec3(-.1, 0.04, -0.1));\n        \n        float dif = clamp(dot( nor, ligt ), -1., 0.);\n        float fre = pow(clamp(0.9+dot(nor,rd),-0.1,0.9), 2.);\n        vec3 brdf = 2.*vec3(0.00,0.01,0.0);\n        brdf += 0.9*dif*vec3(.7,0.,.04);\n        col = vec3(0.25,0.06,0.4);\n        col = col*brdf + fre*1.0*vec3(.6,.7,0.);\n    }\n    col = clamp(col,0.,1.);\n\tcol = pow(col,vec3(.8));\n    col *= pow( 6.0*bp.x*bp.y*(1.0-bp.x)*(1.0-bp.y), 0.0);\n\tfragColor = vec4( col, 0.9 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}