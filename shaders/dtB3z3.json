{
    "Shader": {
        "info": {
            "date": "1673604742",
            "description": "Was actually surprisingly easy.",
            "flags": 0,
            "hasliked": 0,
            "id": "dtB3z3",
            "likes": 6,
            "name": "Temple Anaglyph",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "anaglyph"
            ],
            "usePreview": 0,
            "username": "FifthStateOfMatter",
            "viewed": 178
        },
        "renderpass": [
            {
                "code": "//Takes 5 seconds on average to compile, then runs at a steady 60+ FPS for me.\nconst float eyeDist = 0.5;\nconst bool delag = false;\n\n//Light, neutral colors seem to work best.\nconst vec3 fogColor = vec3(0.8);\n\n//The smaller the number, the less reflective the surface.\nconst float reflectiveness = 0.3;\n\n//Dave_Hoskins' Hash Without Sine\nfloat random3(vec3 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.zyx + 31.32);\n    return (fract((p.x + p.y)*p.z)*2.0) - 1.0;\n}\n\nfloat perlinNoise(vec3 p){\n    vec3 cellPos = floor(p);\n    vec3 cellFract = fract(p);\n    vec3 cellMix = cellFract*cellFract*(3.0 - 2.0*cellFract);\n    float value;\n\n    vec3 blf = vec3(random3((cellPos + vec3(0, 0, 0))*1.0));\n    vec3 brf = vec3(random3((cellPos + vec3(1, 0, 0))*1.0));\n    vec3 trf = vec3(random3((cellPos + vec3(1, 1, 0))*1.0));\n    vec3 tlf = vec3(random3((cellPos + vec3(0, 1, 0))*1.0));\n\n    vec3 blb = vec3(random3((cellPos + vec3(0, 0, 1))*1.0));\n    vec3 brb = vec3(random3((cellPos + vec3(1, 0, 1))*1.0));\n    vec3 trb = vec3(random3((cellPos + vec3(1, 1, 1))*1.0));\n    vec3 tlb = vec3(random3((cellPos + vec3(0, 1, 1))*1.0));\n\n    value = mix(\n        mix(\n            mix(dot(cellFract - vec3(0, 0, 0), blf), dot(cellFract - vec3(1, 0, 0), brf), cellMix.x),\n            mix(dot(cellFract - vec3(0, 1, 0), tlf), dot(cellFract - vec3(1, 1, 0), trf), cellMix.x),\n            cellMix.y\n        ),\n        mix(\n            mix(dot(cellFract - vec3(0, 0, 1), blb), dot(cellFract - vec3(1, 0, 1), brb), cellMix.x),\n            mix(dot(cellFract - vec3(0, 1, 1), tlb), dot(cellFract - vec3(1, 1, 1), trb), cellMix.x),\n            cellMix.y\n        ),\n        cellMix.z\n    );\n    //Should I have to add 0.5 to this? I would think not but it looks weird otherwise.\n    return value;\n}\n\nstruct material{\n    vec3 col;\n    int type;\n};\n\nstruct SDF{\n    float dist;\n    material mat;\n};\n\nSDF sphereSDF(vec3 p, float r, material mat){\n    return SDF(length(p) - r, mat);\n}\n\nSDF boxSDF(vec3 p, vec3 s, material mat){\n    vec3 q = abs(p) - s;\n    return SDF(length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0), mat);\n}\n\nSDF infiniteSpherePatternSDF(vec3 p, vec3 c, material mat){\n    vec3 q = mod(p + 0.5*c, c) - 0.5*c;\n    return sphereSDF(q, 0.25, mat);\n}\n\nSDF infiniteBoxPatternSDF(vec3 p, vec3 c, material mat){\n    vec3 q = mod(p + 0.5*c, c) - 0.5*c;\n    return boxSDF(q, vec3(0.25), mat);\n}\n\nSDF yPlaneSDF(vec3 p, float y, material mat){\n    return SDF(p.y - y, mat);\n}\n\nSDF cylinderSDF(vec3 p, float h, float r, material mat){\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return SDF(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)), mat);\n}\n\nSDF finiteCylinderPatternSDF(in vec3 p, in float c, in vec3 l, material mat){\n    vec3 q = p - c*clamp(round(p/c), -l, l);\n    return cylinderSDF(q, 2.0, 0.4, mat);\n}\n\n//https://www.shadertoy.com/view/Nld3DB\nSDF triPrismSDF(vec3 p, vec3 s, material mat){\n    p.x = abs(p.x);\n    p.xy -= vec2(s.x, -s.y);\n    vec2 e = vec2(-s.x, s.y*2.0);\n    vec2 se = p.xy - e*clamp(dot(p.xy, e)/dot(e, e), 0.0, 1.0);\n    float d1 = length(se);\n    if(max(se.x, se.y) < 0.0){\n        d1 = -min(d1, p.y);\n    }\n    float d2 = abs(p.z) - s.z;\n    return SDF(length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0), mat);\n}\n\nSDF sceneSDF(vec3 p){\n    float xr = 0.0;\n    float yr = iTime*0.3 + (3.1415926535/4.0)*1.0;\n    \n    float sxr = sin(xr);\n    float syr = sin(yr);\n    float cxr = cos(xr);\n    float cyr = cos(yr);\n    \n    mat3 xRot;\n    xRot[0] = vec3(1, 0, 0);\n    xRot[1] = vec3(0, cxr, -sxr);\n    xRot[2] = vec3(0, sxr, cxr);\n    \n    mat3 yRot;\n    yRot[0] = vec3(cyr, 0, -syr);\n    yRot[1] = vec3(0, 1, 0);\n    yRot[2] = vec3(syr, 0, cyr);\n    \n    //SDF ground = yPlaneSDF(p, -1.5, material(vec3(1), 1));\n    //ground.dist -= perlinNoise((p - vec3(0, 0, 10))*yRot)*0.15;\n    //SDF s1 = infiniteSpherePatternSDF(p - vec3(0), vec3(2, 0, 2), material(vec3(1), 0));\n    //SDF s1 = sphereSDF(p - vec3(sin(iTime*0.5)*3.0, 0, cos(iTime*0.5)*3.0 + 5.0), 0.25, material(vec3(1), 0));\n    //SDF b1 = infiniteBoxPatternSDF((p - vec3(0, 0, 0))*xRot*yRot, vec3(2), material(vec3(0, 1, 0), 0));\n    //SDF b1 = boxSDF((p - vec3(0, 0, 5))*yRot*xRot, vec3(0.5, 2, 0.5), material(vec3(0, 0, 0.5), 0));\n    SDF pillars = finiteCylinderPatternSDF((p - vec3(0, 0, 10))*yRot, 2.0, vec3(2, 0, 2), material(vec3(0.6), 0));\n    SDF base1 = boxSDF((p - vec3(0, -1.0, 10))*yRot, vec3(4.5, 0.25, 4.5), material(vec3(0.6), 0));\n    SDF base2 = boxSDF((p - vec3(0, -1.55, 10))*yRot, vec3(5, 0.5, 5), material(vec3(0.6), 0));\n    SDF roof1 = boxSDF((p - vec3(0, 2.0, 10))*yRot, vec3(4.75, 0.25, 4.75), material(vec3(0.6), 0));\n    SDF roof2 = triPrismSDF((p - vec3(0, 3.25, 10))*yRot, vec3(4.75, 1.0, 4.75), material(vec3(0.6), 0));\n    SDF inter = boxSDF((p - vec3(0, 0, 10))*yRot, vec3(4.4, 2.0, 2.75), material(vec3(0.6), 0));\n    float closest = min(/*ground.dist, min(*/pillars.dist, min(base1.dist, min(base2.dist, min(roof1.dist, min(roof2.dist, inter.dist)))))/*)*/;\n    if(closest == base1.dist){\n        return base1;\n    }else if(closest == base2.dist){\n        return base2;\n    }else if(closest == pillars.dist){\n        return pillars;\n    }else if(closest == roof1.dist){\n        return roof1;\n    }else if(closest == roof2.dist){\n        return roof2;\n    }else/* if(closest == inter.dist)*/{\n        return inter;\n    }/*else{\n        return ground;\n    }*/\n    //return b1;\n}\n\nbool raymarch(vec3 o, vec3 d, out float t, out material mat, int ms, float eps){\n    t = 0.0;\n    for(int i = 0; i < ms && t < 30.0; i++){\n        SDF s = sceneSDF(o + d*t);\n        t += s.dist;\n        if(s.dist < eps && t >= 0.0){\n            //Gets rid of some strange artifacts\n            t -= s.dist;\n            \n            mat = s.mat;\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 getNormal(vec3 h){\n    return normalize(vec3(\n        sceneSDF(vec3(h.x + 0.01, h.yz)).dist - sceneSDF(vec3(h.x - 0.01, h.yz)).dist,\n        sceneSDF(vec3(h.x, h.y + 0.01, h.z)).dist - sceneSDF(vec3(h.x, h.y - 0.01, h.z)).dist,\n        sceneSDF(vec3(h.xy, h.z + 0.01)).dist - sceneSDF(vec3(h.xy, h.z - 0.01)).dist\n    ));\n}\n\nfloat getLighting(vec3 h, vec3 lpos){\n    vec3 n = getNormal(h);\n    vec3 lRay = normalize(lpos - h);\n    float c = dot(n, lRay);\n    float lt;\n    material mat;\n    bool rl = raymarch(h + n*0.01, lRay, lt, mat, 30, 0.001);\n\n    if(rl){\n        c -= 0.4;\n    }else{\n        c = dot(n, lRay);\n    }\n    return c;\n}\n\nvec3 reflectRay(vec3 h, vec3 d){\n    vec3 n = getNormal(h);\n    return d - 2.0*n*dot(n, d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 col = vec3(0);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 lPos = vec3(10, 10, -10.0 + iTime*0.0);\n    vec3 o = vec3(0, 0.6, iTime*0.0 - 3.0);\n    vec3 d = normalize(vec3(uv, 1));\n    //https://www.shadertoy.com/view/XslGWn{\n    bool red = mod(fragCoord.xy.x, 2.0) > 0.5;\n    mod(fragCoord.xy.y, 2.0) > 0.5 ? red = !red : red = red;\n    //}\n    \n    if(delag){\n        if(red){\n            float tl;\n            material matl;\n            vec3 ol = o - vec3(eyeDist/2.0, 0, 0);\n            bool rl = raymarch(ol, d, tl, matl, 100, 0.01);\n\n            if(rl){\n                float cl = getLighting(ol + d*tl, lPos);\n                if(matl.type != 1){\n                    float rtl;\n                    material rmatl;\n                    bool rrl = raymarch(ol + d*tl + getNormal(ol + d*tl)*0.01, normalize(reflectRay(ol + d*tl, d)), rtl, rmatl, 30, 0.01);\n                    if(rrl){\n                        float rcl = getLighting(ol + d*tl + getNormal(ol + d*tl)*0.01 + normalize(reflectRay(ol + d*tl, d))*rtl, lPos);\n                        col.r += mix(\n                            mix(matl.col.r, rmatl.col.r*max(rcl, 0.1), reflectiveness)*max(cl, 0.1),\n                            fogColor.r,\n                            min(tl/20.0, 1.0)\n                        );\n                    }else{\n                        col.r += mix(\n                            mix(matl.col.r, 1.0, reflectiveness)*max(cl, 0.1),\n                            fogColor.r,\n                            min(tl/20.0, 1.0)\n                        );\n                    }\n                }else{\n                    col.r += mix(matl.col.r*max(cl, 0.1), fogColor.r, min(tl/20.0, 1.0));\n                }\n            }else{\n                col.r = fogColor.r;\n            }\n        }else{\n            float tr;\n            material matr;\n            vec3 or = o + vec3(eyeDist/2.0, 0, 0);\n            bool rr = raymarch(or, d, tr, matr, 100, 0.01);\n\n            if(rr){\n                float cr = getLighting(or + d*tr, lPos);\n                if(matr.type != 1){\n                    float rtr;\n                    material rmatr;\n                    bool rrr = raymarch(or + d*tr + getNormal(or + d*tr)*0.01, normalize(reflectRay(or + d*tr, d)), rtr, rmatr, 30, 0.01);\n                    if(rrr){\n                        float rcr = getLighting(or + d*tr + getNormal(or + d*tr)*0.01 + normalize(reflectRay(or + d*tr, d))*rtr, lPos);\n                        col.gb += mix(\n                            mix(matr.col.gb, rmatr.col.gb*max(rcr, 0.1), reflectiveness)*max(cr, 0.1),\n                            fogColor.gb,\n                            min(tr/20.0, 1.0)\n                        );\n                    }else{\n                        col.gb += mix(\n                            mix(matr.col.gb, fogColor.gb, reflectiveness)*max(cr, 0.1),\n                            fogColor.gb,\n                            min(tr/20.0, 1.0)\n                        );\n                    }\n                }else{\n                    col.gb += mix(matr.col.gb*max(cr, 0.1), fogColor.gb, min(tr/20.0, 1.0));\n                }\n            }else{\n                col.gb = fogColor.gb;\n            }\n        }\n    }else{\n        float tl;\n        material matl;\n        vec3 ol = o - vec3(eyeDist/2.0, 0, 0);\n        bool rl = raymarch(ol, d, tl, matl, 100, 0.01);\n        \n        if(rl){\n            float cl = getLighting(ol + d*tl, lPos);\n            if(matl.type != 1){\n                float rtl;\n                material rmatl;\n                bool rrl = raymarch(ol + d*tl + getNormal(ol + d*tl)*0.01, normalize(reflectRay(ol + d*tl, d)), rtl, rmatl, 50, 0.01);\n                if(rrl){\n                    float rcl = getLighting(ol + d*tl + getNormal(ol + d*tl)*0.01 + normalize(reflectRay(ol + d*tl, d))*rtl, lPos);\n                    col.r += mix(\n                        mix(matl.col.r, rmatl.col.r*max(rcl, 0.1), reflectiveness)*max(cl, 0.1),\n                        fogColor.r,\n                        min(tl/20.0, 1.0)\n                    );\n                }else{\n                    col.r += mix(\n                        mix(matl.col.r, fogColor.r, reflectiveness)*max(cl, 0.1),\n                        fogColor.r,\n                        min(tl/20.0, 1.0)\n                    );\n                }\n            }else{\n                col.r += mix(matl.col.r*max(cl, 0.1), fogColor.r, min(tl/20.0, 1.0));\n            }\n        }else{\n            col.r = fogColor.r;\n        }\n\n        float tr;\n        material matr;\n        vec3 or = o + vec3(eyeDist/2.0, 0, 0);\n        bool rr = raymarch(or, d, tr, matr, 100, 0.01);\n\n        if(rr){\n            float cr = getLighting(or + d*tr, lPos);\n            if(matr.type != 1){\n                float rtr;\n                material rmatr;\n                bool rrr = raymarch(or + d*tr + getNormal(or + d*tr)*0.01, normalize(reflectRay(or + d*tr, d)), rtr, rmatr, 50, 0.01);\n                if(rrr){\n                    float rcr = getLighting(or + d*tr + getNormal(or + d*tr)*0.01 + normalize(reflectRay(or + d*tr, d))*rtr, lPos);\n                    col.gb += mix(\n                        mix(matr.col.gb, rmatr.col.gb*max(rcr, 0.1), reflectiveness)*max(cr, 0.1),\n                        fogColor.gb,\n                        min(tr/20.0, 1.0)\n                    );\n                }else{\n                    col.gb += mix(\n                        mix(matr.col.gb, fogColor.gb, reflectiveness)*max(cr, 0.1),\n                        fogColor.gb,\n                        min(tr/20.0, 1.0)\n                    );\n                }\n            }else{\n                col.gb += mix(matr.col.gb*max(cr, 0.1), fogColor.gb, min(tr/20.0, 1.0));\n            }\n        }else{\n            col.gb = fogColor.gb;\n        }\n    }\n    fragColor = vec4(pow(col, vec3(1.0/2.2)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}