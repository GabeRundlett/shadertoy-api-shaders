{
    "Shader": {
        "info": {
            "date": "1578739306",
            "description": "Grass test, fullscreen doesn't look good.",
            "flags": 0,
            "hasliked": 0,
            "id": "WlVGzR",
            "likes": 51,
            "name": "GrassTest",
            "published": 3,
            "tags": [
                "noise",
                "fbm",
                "grass",
                "terrian"
            ],
            "usePreview": 0,
            "username": "EvilRyu",
            "viewed": 2228
        },
        "renderpass": [
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Based on kuvkar's Windyplains: https://www.shadertoy.com/view/ltXXRM\n\n#define GRASS_ENV 0.2\n#define FREQ 340.\n#define PI 3.1415926535\n\nfloat hash11(float p)\n{\n    vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n    return fract(p2.x * p2.y * 95.4337)*0.5+0.5;\n}\n\nvec3 hash33(float n) { return fract(sin(vec3(n,n+7.3,n+13.7))*1313.54531); }\nvec3 noise(float x)\n{\n    float p=floor(x);\n    float f=fract(x);\n    f=f*f*(3.0-2.0*f);\n    return mix(hash33(p+0.0), hash33(p+1.0), f);\n}\n\nfloat noise(vec2 x)\n{\n    vec2 p=floor(x);\n    vec2 f=fract(x);\n    f=f*f*(3.0-2.0*f);\n    float n=p.x + p.y*57.0;\n    return mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),\n               mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\n}\n\nfloat fbm(vec2 p)\n{\n    float f=0.0;\n    f+=.5*noise(p); p=p*2.01;\n    f+=.25*noise(p); p=p*2.1;\n    f+=.125*noise(p); p=p*2.03;\n    return f;\n}\n\nfloat terrain(vec2 p) \n{\n    float w=0.;\n    float s=1.;\n    p.x*=20.;\n    w+=sin(p.x*.3521)*4.;\n    for (int i=0; i<5; i++) \n    {\n        p.x*=1.53562;\n        p.x+=7.56248;\n        w+=sin(p.x)*s;      \n        s*=.5;\n    }\n    w=w*.5+.5;\n    return smoothstep(0.,0.05,p.y-w*.01-0.02);\n}\n\nvec3 renderTerrian(vec3 ro, vec3 rd, vec3 col)\n{\n    col=mix(col,vec3(0.05,0.1,0.2)*2.7, 1.-terrain(rd.xy));\n\t\n    return col;\n}\n\nfloat mapTerrian(vec3 p)\n{\n    vec2 q=p.xz*1.1-vec2(2.3,0.);\n    float f=0.0;\n    f+=.56*noise(q); q=q*2.01;\n    f+=.25*noise(q); q=q*2.1;\n    //f+=.125*noise(q); q=q*2.03;\n    return f-0.3;\n}\n\nfloat traceTerrian(vec3 ro, vec3 rd)\n{\n    float t=0.01,d,h;\n    float tPrev=t;\n    vec3 p;\n    float grassMint=100.;\n    for(int i=0;i<200;++i)\n    {\n        p=ro+t*rd;\n        h=mapTerrian(p);    \n        d=p.y-h;\n        \n        if(p.y-h-GRASS_ENV < 0.001 && grassMint>99.)\n        {\n\t\t\tgrassMint=tPrev;   \n            break;\n        }\n       \n        if(t>=100.0) { break;}\n        \n        tPrev=t;\n        t+=d;\n    }\n \n    return grassMint;\n}\n\nfloat blades[8];\n    \nvoid rotate(float v)\n{\n    blades[7]=blades[6]; blades[6]=blades[5]; blades[5]=blades[4];\n    blades[4]=blades[3]; blades[3]=blades[2]; blades[2]=blades[1];\n    blades[1]=blades[0]; blades[0]=v;\n}\n\nbool useAA=false;\nfloat oldD=0.;\n\nfloat shear(vec3 p, float t)\n{\n    return sin(t+p.x*3.+p.z*(2.))*.3*(p.y)*(1.-smoothstep(-1.5, 2., p.z));\n}\n\nfloat grassNoise(vec2 p)\n{\n    vec2 l=floor(p);\n    vec2 f=fract(p);\n    f=f*f*(3.-2.*f);\n    float n=l.x+l.y*57.;\n    float d=mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\n    return d;\n}\n\nfloat mapGrass(vec3 p)\n{\n    vec3 q=p;\n    // Shear\n    p.xy=vec2(p.x+shear(p,0.)+.02*shear(p,iTime*2.), p.y);\n    float d=grassNoise(p.xz*FREQ);\n    d*=mix(1.,grassNoise(p.xz*30.),0.6);\n    \n    #if 1\n    if(useAA)\n    {\n        rotate(d);\n        d = (blades[0]+blades[1]+blades[2]+blades[3]\n            +blades[4]+blades[5]+blades[6]+blades[7])*0.125;\n    }\n    #else\n    if(useAA&&oldD>0.)\n    {\n        d=(oldD+d)*.5;\n    }\n    oldD=d;\n    #endif\n    \n    d*=GRASS_ENV;\n    return d;\n}\n\nfloat occlusion(vec3 p)\n{\n    // 1 cell backwards\n \tfloat w=1./FREQ;\n    // check the difference of height\n    float d=p.y-mapGrass(p-vec3(0,0,w))-mapTerrian(p);\n    // normalize\n    return clamp(d/GRASS_ENV, 0.0, 1.0);\n}\n\nfloat bisect(vec3 ro, vec3 rd, float near, float far)\n{\n    float mid=0.;\n    vec3 p=ro+near*rd;\n    float sgn=sign(p.y-mapGrass(p)-mapTerrian(p));\n    for (int i=0; i<6; i++)\n    { \n        mid=(near+far)*.5;\n        p=ro+mid*rd;\n        float d=p.y-mapGrass(p)-mapTerrian(p);\n        if(abs(d)<0.001)break;\n        d*sgn<0. ? far=mid : near=mid;\n    }\n    return (near+far)*.5;\n}\n\nvec4 renderGrass(vec3 ro, vec3 rd, float mint)\n{\n\tfloat t=mint;//((ro.y-GRASS_ENV)/abs(rd.y));\n\n    vec3 p=ro+t*rd;\n    float d=p.y-mapGrass(p)-mapTerrian(p);\n\tfloat sgn=sign(d);\n    float told=0.;\n\tbool doBisect=false;\n\n    useAA=true;\n    \n    for(int i=0;i<500;++i)\n    {\n        d=p.y-mapGrass(p)-mapTerrian(p);\n        if (sign(d)!=sgn)\n        {\n            doBisect=true;\n            break;\n        }\n        \n        if(d<0.003||t>=50.0)\n        {\n            break;\n        }\n        \n        told=t;\n        \n\t    d=max(1e-4, 0.04*d*exp(t*.2));\n        p+=d*rd;\n        t+=d;\n    }\n    if (doBisect)t=bisect(ro,rd,told,t);\n    \n    useAA=false;\n    vec3 col=vec3(0.1,0.5,1.)*3.5;\n    col=renderTerrian(ro,rd,col);\n\n    if(t<50.)\n    {\n        vec3 ld0=normalize(vec3(5., 5.0, 0.));\n        col=vec3(0.1,0.2,0.05)*10.;\n        col=mix(col,vec3(0.12,0.1,0.05)*10.,fbm(p.xz*2.));       \n        col*=smoothstep(GRASS_ENV*0.45,GRASS_ENV*2.,p.y-mapTerrian(p));\n        col*=pow(smoothstep(0.,1.,fbm(p.xz)),2.);\n \n        col*=.7*smoothstep(0.3,0.5,p.y)+.3;\n \n        col*=.8*occlusion(p)+.2;\n        \n        col*=20.;\n    \tcol=mix(col,vec3(0.05,0.1,0.2)*2.7, 1.0-exp(-0.01*t*t));\n    }\n    \n    return vec4(col,t);\n}\n\nvec3 tonemap(vec3 x) \n{\n    const float a=2.51, b=0.03, c=2.43, d=0.59, e=0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 firecolor(float f)\n{\n\tf=f*f*(3.-2.*f);\n    return min(vec3(f+.8, f*f*1.4+.1, f*f*f*.7)*f, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n\tif(abs(p.y)-0.85>0.) { fragColor.xyz=vec3(0); return; }\n    \n    vec3 lookat=vec3(0.0, 0., 0.0);\n\tvec3 ro=vec3(0., .8,-2.5);\n    ro.xy+=vec2(0.04,0.01)*noise(iTime*0.5).xy;\n    \n    vec3 forward=normalize(lookat-ro);\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up=normalize(cross(right, forward));\n    \n    vec3 rd=normalize(p.x*right + p.y*up + 1.6*forward);\n    \n    vec3 col=vec3(0.1,0.5,1.)*0.1;\n\t\n    float grassMint=traceTerrian(ro,rd);\n\tvec4 res=renderGrass(ro,rd,grassMint);\n    col=res.xyz;\n    col+=firecolor(0.5)*pow(clamp(dot(normalize(vec3(.0, 1., 2.)),rd), 0.0, 1.0),10.);\n    col=tonemap(col);\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    col=col*0.6+0.4*col*col*(3.0-2.0*col);\n    //col=pow(col,vec3(0.85,0.9,1.));\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2);\n    fragColor.xyz=col;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}