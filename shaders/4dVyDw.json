{
    "Shader": {
        "info": {
            "date": "1522269046",
            "description": "Generator of Herringbone patterns, with plenty of tuning parameters\n (autodemo doesn't touch brick size, ratio and grad direction)\n\nref: [url]https://forum.allegorithmic.com/index.php?topic=3638.0[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "4dVyDw",
            "likes": 10,
            "name": "Herringbone pattern",
            "published": 3,
            "tags": [
                "2d",
                "pattern",
                "brick",
                "mz"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 719
        },
        "renderpass": [
            {
                "code": "// shapes group variant here: https://www.shadertoy.com/view/ldGcWG\n\n#define MM 0\nfloat CELL = 20.,                  // grid size vertically -> cell size\n      RATIO = 4.,                  // brick length / brick width\n      ROT0 = 0.,                   // brick fix rotation ( degrees )\n      ROT1 = 0.,                   // brick random rotation amplitude (degrees)\n      ROUND = 1./4.;               // radius of round corners\nvec2  BEVEL = vec2(1)/4.,          // bevel width ( cell %  )\n      GAP  = vec2(2,.5)/8.;        // inter brick gap ( cell % )\nbool  BUMP = false;                // color or bump\nint   RAND = 0,                    // 0: white bricks. 1: random B&W. 2: random col\n      TEXT = 2,                    // 0: plein 1: one texture 2: two textures\n      GRAD = 0;                    // gradient through bricks\nvec2  grad = vec2(1,0);            // grad direction & strength\nfloat grad_randA = 1.,             // spread in amplitude ( amp * [1/A,A] )\n      grad_randD = 0.;             // spread in direction ( degrees )\n\n// std int hash, inspired from https://www.shadertoy.com/view/XlXcW4\nvec3 hash3( uvec3 x ) \n{\n#   define scramble  x = ( (x>>8U) ^ x.yzx ) * 1103515245U // GLIB-C const\n    scramble; scramble; scramble; \n    return vec3(x) / float(0xffffffffU) + 1e-30; // <- eps to fix a windows/angle bug\n}\n#define rot(a) mat2(sin(radians(a) + vec4(1,0,2,1)*1.5707))\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy; U /= R.y;          // normalized coordinates \n    demo( floor(U.x-iTime-.2*sin(4.*U.y-3.*iTime)) ); // demo mode\n    O -= O;\n    U *= CELL;\n    vec2 V = floor(U), W = vec2(RATIO,1);       // normalize in cells units\n    \n    float w =  mod( V.x+V.y, 2.*RATIO ) - RATIO;// where are we ?\n    bool vert = w<0.;\n    if (vert) U = U.yx, w += RATIO, V=V.yx;     // vertical brick -> swap x,y\n    ivec2 H = ivec2((V+V.y)/W);                 // vec2 tile id\n    vec2 S = vec2(w,0)+fract(U) - W/2.;         // centered coords in a brick\n\n    float dir = ROT0 + ROT1 * (-1.+2.*hash3(uvec3(H,1)).x); // brick rotation\n    S *= rot(dir);\n\n    vec2 A = W/2.-GAP - abs(S),                 // coords from borders \n         B  = A * 2. / BEVEL;                   // coords in bevel\n        float m = min(B.x,B.y);                 // in bevel if [0,1]\n    if (A.x<ROUND && A.y<ROUND)                 // round edges\n        m = (ROUND-length(ROUND-A)) *2./dot(BEVEL,normalize(ROUND-A));\n#if !MM    \n    if (BUMP) {                                 // bump map\n        B = B.x<B.y ? vec2(m,-1) : vec2(-1,m);\n        B = step(0.,B) * step(B,vec2(1)) * sign(S);\n        if (B==vec2(0)) B++;                    // for flat areas\n        O += .5 + .5* vec3( B, 0 ).xzyz;\n    } else \n#endif\n        O += clamp( m ,0.,1.);                  // mask\n    if (GRAD>0) {\n        vec3 R = -1.+2.*hash3(uvec3(H,3));      // rand grad variation\n        grad *= rot(grad_randD/2.*R.x) * pow(grad_randA,R.y);\n        O.rgb *= .5 + dot(grad,S);              // lum gradient across brick\n    }\n#if !MM\n    if (RAND>0) {                               // color bricks\n        vec3 R = hash3(uvec3(H,2));             // brick seed\n        O.rgb *= RAND==1 ? R.xxx : R;\n    }\n    if (TEXT>0) {                               // texture mapped on brick\n        vec4 T = texture(iChannel0, S);\n        if (TEXT==2 && vert) T = texture(iChannel1, S);\n        O *= T;\n    }\n#else\n // O-=O;\n    O.r = hash3(uvec3(H,2)).r;                 // tile id\n // O.g = O.g;                                 // image(height)\n    O.b = (vert ? 90. : 0.) + dir;             // direction (degrees)\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// autodemo touches all parameters but brick size, ratio and grad direction\n\n#define demo(t) {                                    \\\n    vec3 h1 = hash3(uvec3(t*vec3( 1  , 7.2,-3.1))),  \\\n         h2 = hash3(uvec3(t*vec3( 7.2,-3.1, 9.7  ))),\\\n         h3 = hash3(uvec3(t*vec3(-3.1,-9.9, 7.2))),  \\\n         h4 = hash3(uvec3(t*vec3(11.1, 1.3,-7.5)));  \\\n   BEVEL = vec2(h1.xy)/2.;                           \\\n    GAP  = vec2(h2.xy)/2.;                           \\\n   ROUND = h1.z/2.;                                  \\\n    BUMP = bool(h2.z>.8);                            \\\n    RAND = int(h3.x*3.);                             \\\n    TEXT = int(h3.y*3.);                             \\\n    GRAD = int(h3.z*2.);                             \\\n    ROT0 = h4.x*h4.x*10.;                            \\\n    ROT1 = h4.y*h4.y*10.;                            \\\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}