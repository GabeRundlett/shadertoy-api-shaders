{
    "Shader": {
        "info": {
            "date": "1485681208",
            "description": "Minimal animated Voronoi triangle metric.",
            "flags": 0,
            "hasliked": 0,
            "id": "MlVXzd",
            "likes": 34,
            "name": "Fast Minimal Animated Blocks",
            "published": 3,
            "tags": [
                "voronoi",
                "triangle",
                "cellular",
                "block",
                "minimal"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 2300
        },
        "renderpass": [
            {
                "code": "/*\n\n\tFast, Minimal Animated Blocks\n\t-----------------------------\n\n\tEmulating the Voronoi triangle metric - the one that looks like blocks - with wrappable, \n\trotated tiles. \n\n\tI've slimmed the code down a little bit, but mainly to get the point across that this \n\tapproach requires far fewer instructions than the regular, random-offset-point grid setup. \n\tThe main purpose of the exercise was efficiency... and to a lesser degree, novelty. :)\n\n\tFor an instruction count comparison, take a look at a few of the Voronoi block - or \n\tstandard - Voronoi examples on here.\n\n\tRelevant Examples:\n\t\n\t// About as minimal as it gets. Whoever made this had way too much time on his hands. :D\n\tOne Tweet Cellular Pattern - Shane\n\thttps://www.shadertoy.com/view/MdKXDD\n\n    // Awesome. Also good for an instruction count comparison.\n\tBlocks -IQ\n    https://www.shadertoy.com/view/lsSGRc\n\n    // Similar code size, but very different instruction count.\n    Triangular Voronoi Lighted - Aiekick\n\thttps://www.shadertoy.com/view/ltK3WD\n\n*/\n\n// Distance metric. A slightly rounded triangle is being used, but the usual distance\n// metrics all work.\nfloat s(vec2 p){\n    \n    p = fract(p) - .5;   \n    //return max(abs(p.x)*.866 + p.y*.5, -p.y); // Regular triangle.\n    //return (length(p)*1.5 + .25)*max(abs(p.x)*.866 + p.y*.5, -p.y);\n    return (dot(p, p)*2. + .5)*max(abs(p.x)*.866 + p.y*.5, -p.y);\n    //return dot(p, p)*2.;\n    //return length(p);\n    //return max(abs(p.x), abs(p.y)); // Etc.\n    \n    //return max(max(abs(p.x)*.866 + p.y*.5, -p.y), -max(abs(p.x)*.866 - p.y*.5, p.y) + .2);\n}\n\n// Very cheap wrappable cellular tiles. This one produces a block pattern on account of the\n// metric used, but other metrics will produce the usual patterns.\n//\n// Construction is pretty simple: Plot two points in a wrappble cell and record their distance. \n// Rotate by a third of a circle then repeat ad infinitum. Unbelievably, just one rotation \n// is needed for a random looking pattern. Amazing... to me anyway. :)\n//\n// Note that there are no random points at all, no loops, and virtually no setup, yet the \n// pattern appears random anyway.\nfloat m(vec2 p){    \n    \n    // Offset - used for animation. Put in as an afterthough, so probably needs more\n    // tweaking, but it works well enough for the purpose of this demonstration.\n    vec2 o = sin(vec2(1.93, 0) + iDate.w)*.166;\n    \n    // The distance to two wrappable, moving points.\n    float a = s(p + vec2(o.x, 0)), b = s(p + vec2(0, .5 + o.y));\n    \n    // Rotate the layer (coordinates) by 120 degrees. \n    p = -mat2(.5, -.866, .866, .5)*(p + .5);\n    // The distance to another two wrappable, moving points.\n    float c = s(p + vec2(o.x, 0)), d = s(p + vec2(0, .5 + o.y)); \n    \n    // Return the minimum distance among the four points. If adding the points below,\n    // be sure to comment the following line out.\n    return min(min(a, b), min(c, d))*2.;\n    \n \n    // One more iteration. Gives an even more random pattern. With this, it's \n    // still a very cheap process. Be sure to comment out the return line above.\n\t/*\n    // Rotate the layer (coordinates) by 120 degrees.\n    p = -mat2(.5, -.866, .866, .5)*(p + .5);\n    // The distance to yet another two wrappable, moving points.\n    float e = s(p + vec2(o.x, 0)), f = s(p + vec2(0, .5 + o.y)); \n\n    // Return the minimum distance among the six points.\n    return min(min(min(a, b), min(c, d)),  min(e, f))*2.;\n    */\n    \n}\n\nvoid mainImage(out vec4 o, vec2 p){\n\t \n    // Screen coordinates.\n    p /= iResolution.y/3.;\n    \n    // The function value.\n    o = vec4(1)*m(p);\n\n    // Cheap highlighting.\n    vec4 b = vec4(.8, .5, 1, 0)*max(o - m(p + .02), 0.)/.1;\n    \n    // Colorize, add the highlighting and do some rough gamma correction.\n    o = sqrt(pow(vec4(1.5, 1, 1, 0)*o, vec4(1, 3.5, 16, 0))  + b*b*(.5 + b*b));\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}