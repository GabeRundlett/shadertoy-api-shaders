{
    "Shader": {
        "info": {
            "date": "1586700105",
            "description": "This is a basic digital clock that shows hours, minutes and seconds.",
            "flags": 0,
            "hasliked": 0,
            "id": "3djcDh",
            "likes": 1,
            "name": "Digital Uhr",
            "published": 3,
            "tags": [
                "clock",
                "uhr"
            ],
            "usePreview": 0,
            "username": "Janniboy",
            "viewed": 371
        },
        "renderpass": [
            {
                "code": "#define red vec3(1.0,0.0,0.0)\n#define green vec3(0.0,1.0,0.0)\n#define blue vec3(0.0,0.0,1.0)\n#define yellow vec3(1.0,1.0,0.0)\n\nconst bool gradient = true; //if the lines should have rounded edges\n\nvec4 BG(vec2 fragCoord) {\n\tvec4 rgi = mix(vec4(vec3(1.0,0.0,0.0),1.0), vec4(vec3(0.0,1.0,0.0),1.0), fragCoord.x/iResolution.x);\n    vec4 byi = mix(vec4(vec3(0.0,0.0,1.0),1.0), vec4(vec3(1.0,1.0,0.0),1.0), fragCoord.x/iResolution.x);\n    return mix(rgi, byi, fragCoord.y/iResolution.y);\n}\n\nvec4 CombineLayers(vec4 topl, vec4 bottoml) {\n\treturn mix(bottoml, topl, topl.a);\n}\n\nfloat DistLinePoint(vec2 P1, vec2 P2, vec2 P0) {\n\treturn abs((P2.y-P1.y)*P0.x-(P2.x-P1.x)*P0.y+P2.x*P1.y-P1.x*P2.y)/sqrt(pow((P2.y-P1.y), 2.0)+pow((P2.x-P1.x),2.0));\n}\n\nfloat Line(vec2 L1, vec2 L2, float width, vec2 fragCoord) {\n    float outval = 1.0;\n    float lengthL = distance(L1, L2);\n    \n    float deltax = L1.x-L2.x;\n    float deltay = L1.y-L2.y;\n    \n    vec2 borderPoint1 = vec2(L1.x+deltay, L1.y-deltax);\n    vec2 borderPoint2 = vec2(L2.x+deltay, L2.y-deltax);\n    \n    if (max(DistLinePoint(L1, borderPoint1, fragCoord), DistLinePoint(L2, borderPoint2, fragCoord)) > lengthL) {\n    \toutval = min(distance(L1, fragCoord), distance(L2, fragCoord)) / width;\n    } else {\n    \toutval = DistLinePoint(L1, L2, fragCoord) / width;\n    }\n    if (gradient) {\n    \treturn min(1.0, 1.0 - outval);\n    } else {\n        if (1.0 - outval >= 0.5) {\n        \treturn 1.0;\n        } else {\n        \treturn 0.0;\n        }\n    }\n}\nfloat Dot(float r, float width, vec2 fragCoord) {\n\tif (gradient) {\n    \treturn min(1.0, 1.0 - ( distance(iResolution.xy/2.0, fragCoord) - r ) / width);\n    } else {\n        if (1.0 - ( distance(iResolution.xy/2.0, fragCoord) - r ) / width >= 0.5) {\n        \treturn 1.0;\n        } else {\n        \treturn 0.0;\n        }\n    }\n}\nfloat Circle(float r, float width, vec2 fragCoord) {\n    if (gradient) {\n    \treturn min(1.0, 1.0 - abs( distance(iResolution.xy/2.0, fragCoord) - r ) / width);\n    } else {\n        if (1.0 - abs( distance(iResolution.xy/2.0, fragCoord) - r ) / width >= 0.5) {\n        \treturn 1.0;\n        } else {\n        \treturn 0.0;\n        }\n    }\n    \n}\nfloat CircleLine(float r, float angle, float width, vec2 fragCoord) {\n    float deltax = sin(radians(angle))*r;\n\tfloat deltay = cos(radians(angle))*r;\n    vec2 P2 = vec2((iResolution.xy/2.0).x+deltax, (iResolution.xy/2.0).y+deltay);\n    return Line(iResolution.xy/2.0, P2, width, fragCoord);\n}\nfloat CircleLineSegment(float r1, float r2, float angle, float width, vec2 fragCoord) {\n\tfloat deltax1 = sin(radians(angle))*r1;\n\tfloat deltay1 = cos(radians(angle))*r1;\n    vec2 P1 = vec2((iResolution.xy/2.0).x+deltax1, (iResolution.xy/2.0).y+deltay1);\n    \n    float deltax2 = sin(radians(angle))*r2;\n\tfloat deltay2 = cos(radians(angle))*r2;\n    vec2 P2 = vec2((iResolution.xy/2.0).x+deltax2, (iResolution.xy/2.0).y+deltay2);\n    \n    return Line(P1, P2, width, fragCoord);\n}\n\nfloat getHours() {\n\treturn floor(iDate[3]/3600.0);\n}\nfloat getMinutes() {\n\treturn floor((iDate[3]-getHours()*3600.0)/60.0);\n}\nfloat getSeconds() {\n\treturn floor(iDate[3]-getHours()*3600.0-getMinutes()*60.0);\n}\n\nfloat HourHand(vec2 fragCoord) {\n\treturn CircleLine(min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)/2.0, mod(30.0*getHours(), 360.0), min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*4.0/150.0, fragCoord);\n}\nfloat MinuteHand(vec2 fragCoord) {\n\treturn CircleLine(min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*2.0/3.0, getMinutes()*6.0, min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*4.0/150.0, fragCoord);\n}\nfloat SecondHand(vec2 fragCoord) {\n\treturn CircleLine(min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*22.0/30.0, getSeconds()*6.0, min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*2.0/150.0, fragCoord);\n}\n\nfloat HourMarks(vec2 fragCoord) {\n    float maxVal = 0.0;\n    for (int i = 0; i < 12; i++) {\n    \tmaxVal = max(maxVal, CircleLineSegment(min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*13.0/15.0, min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0), float(i)*30.0, min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*3.0/150.0, fragCoord));\n    }\n\treturn maxVal;\n}\nfloat MinuteMarks(vec2 fragCoord) {\n\tfloat maxVal = 0.0;\n    for (int i = 0; i<60; i++) {\n        if (mod(float(i), 5.0) != 0.0) {\n        \tmaxVal = max(maxVal, CircleLineSegment(min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*13.0/15.0, min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*27.0/30.0, float(i)*6.0, min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*3.0/150.0, fragCoord));\n        }\n    }\n    return maxVal;\n}\n\nfloat Dial(vec2 fragCoord) {\n\tfloat circ = Circle(min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0), min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*3.0/150.0, fragCoord);\n    float HourMarks = HourMarks(fragCoord);\n    float MinuteMarks = MinuteMarks(fragCoord);\n    float MiddleAxis = Dot(min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)/150.0, min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*4.0/150.0, fragCoord);\n    return max(circ, max(HourMarks, max(MinuteMarks, MiddleAxis)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float HourH = HourHand(fragCoord);\n    float MinuteH = MinuteHand(fragCoord);\n    float SecondH = SecondHand(fragCoord);\n    float Dial = Dial(fragCoord);\n    \n    float mask = max(Dial, max(HourH, max(MinuteH, SecondH)));\n    \n    float circle = float(distance(iResolution.xy/2.0, fragCoord) < min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0));\n    \n    fragColor = CombineLayers(vec4(mask), BG(fragCoord)*(1.0-circle)+BG(fragCoord)*0.7*circle);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}