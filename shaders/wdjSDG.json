{
    "Shader": {
        "info": {
            "date": "1554898021",
            "description": "I decided to turn [url=https://www.shadertoy.com/view/Md3yzH]my 2D sci-fi buildings[/url] into 3D.",
            "flags": 0,
            "hasliked": 0,
            "id": "wdjSDG",
            "likes": 17,
            "name": "Sci-fi Building Shapes",
            "published": 3,
            "tags": [
                "procedural",
                "raymarching",
                "architecture"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 656
        },
        "renderpass": [
            {
                "code": "// Sci-fi Building Shapes\n// by Hazel Quantock 2019\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n// reduce this to improve frame rate in windowed mode (0 disables anti-aliasing)\n#define AA_QUALITY 3\n\n// allow a little bleed between pixels - I think this looks more photographic, but blurrier\n#define AA_ROUND false\n#define AA_ROUND_RADIUS 0.7071\n\n\nconst float phi = 1.6180339887498948;\nconst float tau = 6.2831853071795865;\n\n// from here: https://www.shadertoy.com/view/4dVBzz\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 (1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) ((p)*M1)\n#define coord2(p) ((p).x*M1^(p).y*M2)\n#define coord3(p) ((p).x*M1^(p).y*M2^(p).z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\n\nuint seed = 1u;\n\nfloat Polygon( vec2 uv, float h )\n{\n    vec4 rand1 = hash4(coord3(uvec3(h*2.,0,seed)));\n    vec4 rand2 = hash4(coord3(uvec3(h*2.,1,seed)));\n    \n    float mid = (rand1.x-.5)*exp2(-h*2.);\n    float f = abs(uv.y-rand1.y+.5)-rand1.z-2.; //2.*mix(1.,rand(),.5+.5*h); // so 1.+rand->2.*rand\n    f = max(f,abs(uv.x-mid)-rand1.w-.5+h*.4); //1.5*mix(1.,rand(),.7+.3*h);\n    f = max(f,abs(dot(uv,vec2(1,1)/sqrt(2.))-rand2.x+.5)-rand2.y-1.);\n    f = max(f,abs(dot(uv,vec2(1,-1)/sqrt(2.))-rand2.z+.5)-rand2.w-1.);\n    \n    // support-stalk\n    //f = min(f,max(uv.y,abs(uv.x-mid)-.1));\n    \n    return f;\n}\n\n\nfloat BevelMax( float a, float b, float bevelSize )\n{\n    return max(max(a,b), dot(vec2(a,b),normalize(vec2(.5,1))) + bevelSize );\n}\n\nfloat SDF( vec3 p )\n{\n\t// octahedral, but with random distances so some planes won't be seen\n    float a = Polygon( p.zy-vec2(0,0), 0. );\n    float b = Polygon( p.zy-vec2(0,2), .5 );\n    float c = Polygon( p.zy-vec2(0,4), 1. );\n\n/*    vec3 f = vec3(a,min(a,b),min(min(a,b),c));\n    f = max( f, vec3(abs(p.x)-.2) );\n    return min( f.z, p.y+.5 ); // ground*/\n    \n    float w = abs(p.x);\n\n    vec3 rand = hash3(coord1(seed^0x1999u));\n    \n    float ground = p.y+.5;\n    \n    return min(min(min(BevelMax(a,w-rand.x,.1),BevelMax(b,w-rand.y,.03)),BevelMax(c,w-rand.z,.1)),ground);\n}\n\n\n\n// higher precision trace function canibalised from one of my other shaders - not sure if this is the best version but it's good enough\nconst float epsilon = .0004;\nfloat Trace( vec3 rayStart, vec3 rayDirection )\n{\n    float t = 0.;\n    \n    float h = 0.;\n    float lasth = 0.;\n    float bestt = 0.;\n    float bestDist = 1e30;\n    float sdf = 0.;\n    for ( int i=0; i < 200; i++ )\n    {\n        lasth = h;\n        sdf = SDF( rayDirection*t+rayStart );\n        h = sdf + epsilon*.5;\n\t\tt += h;\n        if ( sdf < bestDist ) { bestt = t; bestDist = sdf; } // not sure if all these conditionals will compile well, could flip to use step and mix\n        if ( h < epsilon ) break;\n    }\n\n    if ( sdf == bestDist )\n    {\n        // improve precision\n\t\tfloat lastt = t-epsilon;\n\t\tfloat lastsdf = SDF( rayDirection*lastt+rayStart );\n\t\tfloat sdf = SDF( rayDirection*t+rayStart );\n       \tt = mix( lastt, t, (0.-lastsdf)/(sdf-lastsdf) );\n    }\n    else if ( t < bestt*2. )\n    {\n        // use the closest sample we had, to avoid sampling back-sides and things\n        t = bestt;\n\t\t// this can add a fringe, but maybe better than the alternative\n    }\n    \n    return t;\n}\n\n\nvec3 GetNormal( vec3 p )\n{\n    vec2 d = vec2(-1,1)*epsilon;\n    return normalize(\n        \tSDF(p+d.xxx)*d.xxx +\n        \tSDF(p+d.yyx)*d.yyx +\n        \tSDF(p+d.yxy)*d.yxy +\n        \tSDF(p+d.xyy)*d.xyy\n        );\n}\n\n\nvoid mainImage2( out vec4 fragColour, in vec2 fragCoord )\n{\n    seed = uint(iTime/2.);\n    \n    vec3 camPos = vec3(-5,1,-3);\n    float a = iTime*.1;\n    if ( iMouse.z > 0. )\n    {\n        camPos.y = 12.*iMouse.y/iResolution.y+.000001;\n        a += .5*tau*(iMouse.x/iResolution.x-.5);\n    }\n    camPos.xz = camPos.xz*cos(a)+vec2(1,-1)*sin(a)*camPos.zx;\n    vec3 camK = normalize(vec3(0,3,0) - camPos);\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n#if 1\n    // architectural projection (non-orthographic)\n    camJ = vec3(0,1./sqrt(camJ.y),0);  // (0,1,0) works too, but causes more vertical stretching at steep angles\n#endif\n    \n    vec3 ray = vec3( (fragCoord-iResolution.xy*.5)/iResolution.y, .8 );\n    ray = ray.x*camI + ray.y*camJ + ray.z * camK;\n    ray = normalize( ray );\n    \n    float t = Trace( camPos, ray );\n    vec3 pos = camPos+t*ray;\n    \n    if ( t < 1e3 && SDF(pos) < 10. )\n    {\n//    \tfragColour.rgb = fract(pos);\n        \n        vec3 normal = GetNormal(pos);\n\n        vec3 toLight = normalize(vec3(-1,2,3));\n\n        if ( Trace( pos+toLight*.001-normal*SDF(pos), toLight ) > 1e2 )\n        {\n        \tfragColour.rgb = vec3(.9,.8,.7)*max( dot(normal,toLight), 0. );\n        }\n        \n        float aoStep = 1.;\n        float ao = smoothstep(-1.,1.,SDF(pos+normal*aoStep)/aoStep);\n        aoStep = .4;\n        ao = mix( ao, smoothstep(-1.,1.,SDF(pos+normal*aoStep)/aoStep), .5 );\n        aoStep = .15;\n        ao = mix( ao, smoothstep(-1.,1.,SDF(pos+normal*aoStep)/aoStep), .4 );\n        \n        fragColour.rgb += ao*mix( vec3(.3), vec3(.2,.3,.4), (.5+.5*normal.y) );\n    }\n    else\n    {\n        fragColour.rgb = vec3(.5,.7,1);\n    }\n    \n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n    fragColour.a = 1.;\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n#if ( AA_QUALITY == 0 )\n    mainImage2( fragColour, fragCoord );\n#else\n    int numSamples = max( 1, int((1920.*1080.*float(AA_QUALITY)*.2) / (iResolution.x*iResolution.y)) );\n\n    vec4 colSum = vec4(0);\n    for ( int i=0; i < numSamples; i++ )\n    {\n        uvec2 quasi2 = uvec2(0xC13FA9A9u,0x91E10DA5u);\n        uint seed = uint(i);\n        //seed += uint(iFrame*numSamples); // randomize per frame - causes shimmering\n        //seed += uint(fragCoord.x)*quasi2.x+uint(fragCoord.y)*quasi2.y; // randomize per pixel - this looks bad at low sample counts (and at high counts it's less important)\n        vec2 jitter = vec2( quasi2 * seed ) / exp2(32.);\n\n        if ( AA_ROUND )\n        {\n            // circle of confusion slightly bigger than a pixel - should look more photographic\n            jitter.x *= 6.283185;\n            jitter = AA_ROUND_RADIUS*(1.-jitter.y*jitter.y)*vec2(cos(jitter.x),sin(jitter.x));\n        }\n        else\n        {\n            jitter -= .5;\n        }\n        \n        vec4 col;\n        mainImage2( col, fragCoord + jitter );\n        colSum += col;\n    }\n   \n    fragColour = colSum/float(numSamples);\n#endif\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}