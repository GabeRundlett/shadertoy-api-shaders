{
    "Shader": {
        "info": {
            "date": "1573022541",
            "description": "A 2d particle solver with temporally-accumulated motion trails. (Used to simulate rain drops on a frosted window at night) \n\nSet DEBUG to 1 for more info under Common.",
            "flags": 96,
            "hasliked": 0,
            "id": "tstXRj",
            "likes": 72,
            "name": "Rain Drips at Night",
            "published": 3,
            "tags": [
                "particles",
                "surface",
                "history",
                "wet",
                "buffers"
            ],
            "usePreview": 0,
            "username": "granito",
            "viewed": 3906
        },
        "renderpass": [
            {
                "code": "#define heightMap iChannel0\n#define heightMapResolution iChannelResolution[0]\n#define textureOffset 1.0\n#define pixelToTexelRatio (iResolution.xy/heightMapResolution.xy)\n\nfloat bnoise (vec2 uv)\n{\n    return texture(iChannel3, uv).x * 2. - 1.;\n}\n\nvec2 texNormalMap(in vec2 uv)\n{\n    vec2 s = 1.0/heightMapResolution.xy;\n    \n    float p = texture(heightMap, uv).z;\n    float h1 = texture(heightMap, uv + s * vec2(textureOffset,0)).z;\n    float v1 = texture(heightMap, uv + s * vec2(0,textureOffset)).z;\n       \n   \treturn (p - vec2(h1, v1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 invres = 1.0/res; \n    vec2 uv = fragCoord/res;\n    uv = ((uv - 0.5) * (0.85 + sin(iTime*0.33) * 0.05)) + 0.5;\n    vec2 uvoffset = vec2(sin(iTime * 0.2), cos(iTime * 0.4)) * 0.02;\n    uvoffset += vec2(cos(iTime * 0.5), sin(iTime * 0.3)) * 0.01;\n    uv += uvoffset;\n    float noise = bnoise(fragCoord / vec2(1024.));\n    vec4 bufB = texture(iChannel0, uv);\n    bufB.xy *= -1.0;\n   \n    vec2 bguv = ((fragCoord/res - 0.5) * 0.85  + 0.5) ;\n    \n    //setup passes\n    \n    vec2 windowN = texNormalMap(uv) / (invres.x * 2000.) ;\n    \n    vec3 drops = texture(iChannel1, bguv + bufB.xy * -.1 + windowN, 2.).xyz; //drops on glass\n\n    vec3 hazyglass = multisample( iChannel1, bguv  + windowN, (1.- bufB.w ) * 5., 0.05 + 0.0006 * noise).xyz; //hazy glass\n    \n    float spec = saturate( dot( normalize(vec3( -vec2(bufB.xy * -.1 + windowN)*10., 1.0)) , normalize(vec3((uv-vec2(sin(iTime*0.3)*2.+0.5,.2))*vec2(1.0,0.5),1.)) ));\n    spec = pow(smoothstep(0.9,1.,spec),bufB.w * 100. + 60.);\n    spec *= bufB.w + 0.1;\n    \n    //hazyglass *= (1.0-smoothstep(0.3, 0.5, bufB.w)) * 0.2 + .8; //highlight streaks\n\n    if ( DEBUG != 1 ) //Output\n    {\n        float vignette = distance(fragCoord/res, vec2(0.5)) * 2.0 + 0.5;\n    \tfragColor.rgb = pow( mix(hazyglass, drops, smoothstep(0.8, 0.9, bufB.w) ), vec3(1.2,1.3,2.5) * vignette  ); //put passes together\n        fragColor.rgb += spec*vec3(0.5,0.,0.);\n    }\n    else //Debug views\n    {\n        float time = fract(iTime * 0.25);\n        if (time < 0.25)\n        {\n        \tfragColor.rgb = buildnormalz(bufB.xy) * vec3(0.5) + vec3(0.5);\n        }\n        else if (time < 0.5)\n        {\n            fragColor.rgb = buildnormalz(texture(iChannel2, uv).xy) * vec3(0.5) + vec3(0.5);\n        }\n        else if (time < 0.75)\n        {\n\t\t\tfragColor.rgb = vec3(bufB.w);\n        }\n        else\n        {\n            fragColor.rgb = vec3(texture(iChannel2, uv).w);        \n        }      \n    }\n    //fragColor.rgb = vec3(spec);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define DEBUG 0\n\n//some basic controls\nconst int COUNT = 256;\nconst float GRAVITY = 0.01;\nconst float DROPSIZE = 0.5;\nconst float DROPJITTER = 0.2;\nconst int LIFETIME = 300;\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nuint baseHash(uint p)\n{\n    p = 1103515245U*((p >> 1U)^(p));\n    uint h32 = 1103515245U*((p)^(p>>3U));\n    return h32^(h32 >> 16);\n}\n\nvec2 hash21(int x)\n{\n    uint n = baseHash(uint(x));\n    uvec2 rz = uvec2(n, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec2 hash21f(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash11(int x)\n{\n    uint n = baseHash(uint(x));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec3 buildnormalz(vec2 normal)\n{\n    return vec3(normal, sqrt(1. - normal.x*normal.x - normal.y*normal.y));\n}\n\nvec4 multisample( sampler2D tex, vec2 uv, float mip, float offset)\n{\n\tvec4 outcol;\n    outcol += texture( tex, uv + vec2(    0.0, 0.0), mip);\n    outcol += texture( tex, uv + vec2( offset, offset), mip);\n    outcol += texture( tex, uv + vec2(-offset, offset), mip);\n    outcol += texture( tex, uv + vec2( offset,-offset), mip);\n    outcol += texture( tex, uv + vec2(-offset,-offset), mip);\n    return outcol * 0.2;\n}\n\n/*\nvec4 multisample( sampler2D tex, vec2 uv, float mip, float offset)\n{\n\tvec4 outcol;\n    outcol += texture( tex, uv + vec2(    0.0, 0.0), mip);\n    outcol += texture( tex, uv + vec2( offset, 0.0), mip);\n    outcol += texture( tex, uv + vec2(-offset, 0.0), mip);\n    outcol += texture( tex, uv + vec2( 0.0, offset), mip);\n    outcol += texture( tex, uv + vec2( 0.0,-offset), mip);\n    return outcol * 0.2;\n}\n*/\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec2 writePos (int i, vec2 fragCoord, vec2 res, vec2 value)\n{\n    if (fragCoord.x == float(i))\n    {\n\t\treturn value;\n    } \n    else {return vec2(0);}\n}\n\nfloat writeLife (int i, vec2 fragCoord, vec2 res, float value)\n{\n    if (fragCoord.x == float(i))\n    {\n\t\treturn value;\n    } \n    else {return 0.;}\n}\n\nfloat loadLife(int index) \n{ \n    return texture( iChannel0, vec2((float(index)+0.5) / iChannelResolution[0].x, 0.), -100.0 ).z; \n}\n\nvec4 loadData(int index) \n{ \n    return texture( iChannel0, vec2((float(index)+0.5) / iChannelResolution[0].x, 0.), -100.0 ); \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = fragCoord/res;\n    vec2 inv = vec2(1., res.x / res.y); \n    \n    vec2 pos;\n    vec4 col;\n    float radius = DROPSIZE * 0.005;\n    float life01 = 1. / float(LIFETIME);\n    float life;\n    \n    if (fragCoord.y < 2.) //update particle values (stored on 1st pixel row of buffer A)\n    {\n        for (int i = 0; i < COUNT-1; ++i)\n        {\n            float perinstancerandom = hash11(i);\n            float perinstancelife = life01 * (perinstancerandom + 0.5);\n            if (iFrame == 0) //re-init particles\n            {\n                pos += writePos(i, floor(fragCoord), res, hash21f(float(i)+iDate.x+iDate.y+iDate.z+iDate.w) ); //randomize position at index\n                life += writeLife(i, floor(fragCoord), res, perinstancerandom * 121.317 );\n\n            }\n            else //increment \n            {\n                float rndgrav = -GRAVITY * pow( 0.7 + 0.3 * sin(perinstancerandom * 15. + iTime * 0.05), 2. );\n                pos += writePos(i, floor(fragCoord), res, (hash21(i*COUNT+int(iTime*60.)) * 2. - 1.) * DROPJITTER * inv * rndgrav + vec2(0., rndgrav )   );\n            \tlife += writeLife(i, floor(fragCoord), res, life01 / abs(pos.y * 10.) * 0.01 );\n            }\n        }\n        float vel = pos.y; \n        pos = fract(texture(iChannel0,uv).xy + pos);\n        life = fract(texture(iChannel0,uv).z + life);\n    \tfragColor = vec4(pos, life, vel);\n    }\n    else //draw results to buffer A\n    {\n        for (int i = 0; i < COUNT-1; ++i) \n        {\n            vec4 get = loadData(i);\n            vec2 uvscale = (uv-get.xy) / vec2(2,4) + get.xy; \n            float mask = 1. - saturate( (distance(get.xy, uvscale) / radius) );\n            mask *= smoothstep( 0.9, 0.95, get.z);\n            vec2 normal = normalize(get.xy - uvscale) *(1. - mask)*ceil(mask);\n            mask = ceil(mask);\n            col.xy += normal;\n            col.w = max(col.w,mask) ;\n        }\n        fragColor = col;  \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 29002,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/acousticnature/binaural-rain-on-window-wcrickets-field-recording"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = fragCoord/res;\n    vec2 inv = vec2(1., res.y / res.x); \n    vec4 bufA = multisample( iChannel0, uv, 0., 0.0005); //bufer A input\n    vec2 uvoffset = (texture(iChannel2, uv * inv * 0.5).xy * 2. - 1.) * 0.00005; //distortion offset\n    vec4 bufB = multisample( iChannel1, uv + uvoffset, 0., 0.001); //history buffer\n    fragColor = mix( bufB * 0.98, bufA, bufA.w); //mix history buffer behind\n    fragColor.z = dot(texture(iChannel3,uv * vec2(9.0, 6.0)).xyz, vec3(0.3,0.6,0.1)) * 0.5; //glass texture\n    fragColor.z += smoothstep(0.,1.0,abs(sin(uv.x * 120.0))) * 0.2;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}