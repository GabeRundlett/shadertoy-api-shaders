{
    "Shader": {
        "info": {
            "date": "1666425709",
            "description": "Shadertoy adaptation of my old project from here: https://github.com/podgorskiy/KeplerOrbits\nThe shader shows the real-time position of celestial bodies in the sky for an observer at any given latitude and longitude.\nClick the planets!\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ftdfWj",
            "likes": 11,
            "name": "KeplerOrbits",
            "published": 3,
            "tags": [
                "2d",
                "planets",
                "orbits",
                "kepler"
            ],
            "usePreview": 1,
            "username": "Pidhorskyi",
            "viewed": 368
        },
        "renderpass": [
            {
                "code": "// This shader displays the planets' position (visible from the observer on Earth) in real-time.\n\n\n// Please specify your GMT here (the one that is set in the system clock, does not have to be the real one):\n#define GMT  -4\n\n\n// Please specify your geo coordinates here. You can find the coordinates of your city using this tool: https://www.latlong.net/\n#define LAT 40.440624\n#define LONG -79.995888\n\n\n// QA. \n// Q: Why is East on the left and West on the right?\n// A: This is a view of the sky, e.i. from Earth's surface upward, unlike a map with a top-down view. Thus, things are flipped.\n//\n// Q: What is the yellow curve?\n// A: Ecliptic. The ecliptic is the plane of Earth's orbit around the Sun. Since the solar system is mostly flat, most of the planets\n//    are nearby the yellow curve.\n//\n// Q: Why are some planets outside the circle?\n// A: They are below the horizon and not visible.\n\n// Stanislav Pidhorskyi - 2022\n// Original link for citation: https://www.shadertoy.com/view/ftdfWj\n// Shadertoy adaptation of my old project from here: https://github.com/podgorskiy/KeplerOrbits\n\n// For printing text, ints, and floats this shader is using utils by FabriceNeyret2: https://www.shadertoy.com/view/llySRh\n\n////////////////////////////////////////////////////////////////////////////////////\n#define M_PI 3.14159265359\n#define TO_RAD(x) (x / 180.0 * M_PI)\n#define TO_GRD(x) (x * 180.0 / M_PI)\n\nconst float k_obliquityOfTheEcliptic = 23.439281 / 180.0 * M_PI;\nconst float k_GMT = float(GMT);\nvec2 geoCoordinates = vec2(float(LAT) / 180.0 * M_PI, float(LONG) / 180.0 * M_PI);\n\n\n// Data\n////////////////////////////////////////////////////////////////////////////////////\n\n// Struct that keeps info about celestial bodies, in particular Keplerian oribital elements.\nstruct Body\n{\n\tfloat semimajorAxis;\n\tfloat eccentricity;\n\n\tfloat inclination;\n\tfloat longitudeOfAscendingNode;\n    \n\tfloat longitudeOfPerihelion;\n\tfloat meanLongitude;\n    int epoch;\n    float siderealOrbitPeriod;\n    \n    vec3 color;\n    \n    int name[9];\n    int name_length;\n};\n\n\n// UPDATE: Replaced an array with function returning the Body instance as was suggested by morimea\n// Sun, planets, and few smaller bodies\nBody get_bodies_by_id(int idx){\n// do not use switch/case because ANGLE broken\nif(idx==0) return Body(0., 0., TO_RAD(0.), TO_RAD(0.), TO_RAD(0.), TO_RAD(0.), 2451545, 1., vec3(0xFF, 0xFF, 0x00), int[9](83, 117, 110, 0, 0, 0, 0, 0, 0), 3); // Sun\nif(idx==1) return Body(0.38709893, 0.20563069, TO_RAD(7.00487), TO_RAD(48.33167), TO_RAD(77.45645), TO_RAD(252.25084), 2451545, 87.969, vec3(0xFF, 0x00, 0xAA), int[9](77, 101, 114, 99, 117, 114, 121, 0, 0), 7); // Mercury\nif(idx==2) return Body(0.72333199, 0.00677323, TO_RAD(3.39471), TO_RAD(76.68069), TO_RAD(131.53298), TO_RAD(181.97973), 2451545, 224.701, vec3(0x92, 0x6D, 0xAA), int[9](86, 101, 110, 117, 115, 0, 0, 0, 0), 5); // Venus\nif(idx==3) return Body(1.00000011, 0.01671022, TO_RAD(0.00005), TO_RAD(-11.26064), TO_RAD(102.94719), TO_RAD(100.46435), 2451545, 365.256, vec3(0x00, 0xB6, 0xFF), int[9](69, 97, 114, 116, 104, 0, 0, 0, 0), 5); // Earth\nif(idx==4) return Body(1.52366231, 0.09341233, TO_RAD(1.85061), TO_RAD(49.57854), TO_RAD(336.04084), TO_RAD(355.45332), 2451545, 686.980, vec3(0xFF, 0x24, 0x00), int[9](77, 97, 114, 115, 0, 0, 0, 0, 0), 4);  // Mars\nif(idx==5) return Body(5.203363011, 0.04839266, TO_RAD(1.30530), TO_RAD(100.55615), TO_RAD(14.75385), TO_RAD(34.40438), 2451545, 4332.589, vec3(0xFF, 0x92, 0x00), int[9](74, 117, 112, 105, 116, 101, 114, 0, 0), 7); // Jupiter\nif(idx==6) return Body(9.53707032, 0.05415060, TO_RAD(2.48446), TO_RAD(113.71504), TO_RAD(92.43194), TO_RAD(49.94432), 2451545, 10759.22, vec3(0xFF, 0xFF, 0x55), int[9](83, 97, 116, 117, 114, 110, 0, 0, 0), 6); // Saturn\nif(idx==7) return Body(19.19126393, 0.04716771, TO_RAD(0.76986), TO_RAD(74.22988), TO_RAD(170.96424), TO_RAD(313.23218), 2451545, 30685.4, vec3(0x24, 0xFF, 0xAA), int[9](85, 114, 97, 110, 117, 115, 0, 0, 0), 6); // Uranus\nif(idx==8) return Body(30.06896348, 0.00858587, TO_RAD(1.76917), TO_RAD(131.72169), TO_RAD(44.97135), TO_RAD(304.88003), 2451545, 60189., vec3(0x6D, 0xB6, 0xFF), int[9](78, 101, 112, 116, 117, 110, 101, 0, 0), 7); // Neptune\nif(idx==9) return Body(39.48168677, 0.24880766, TO_RAD(17.14175), TO_RAD(110.30347), TO_RAD(224.06676), TO_RAD(238.92881), 2451545, 90465., vec3(0x6D, 0x6D, 0xFF), int[9](80, 108, 117, 116, 111, 0, 0, 0, 0), 5); // Pluto\nif(idx==10) return Body(544.0690504866262, 0.8598045771920355, TO_RAD(11.92819679107613), TO_RAD(144.4217446113967), TO_RAD(455.3715618630623), TO_RAD(813.5892172541679), 2456200, 4635317.206254945, vec3(0x6D, 0x6D, 0xAA), int[9](83, 101, 100, 110, 97, 0, 0, 0, 0), 5); // Sedna\nif(idx==11) return Body(17.8341442925537, 0.967142908462304, TO_RAD(162.262690579161), TO_RAD(58.42008097656843), TO_RAD(169.75256608108613), TO_RAD(208.13683055752493), 2449400, 27509.1290731861, vec3(0x00, 0x49, 0xFF), int[9](49, 80, 47, 72, 97, 108, 108, 101, 121), 9); // 1P/Halley\n}\n\n\n\n// Time utils\n////////////////////////////////////////////////////////////////////////////////////\n\n// Julian day. vec2 is used to boost precision a bit, x component keeps integer part, and y component keeps fractional part\n// The result is current Julian day minus 2451545 (again for precision). \nvec2 getjd()\n{\n\tint mon = int(iDate.y + 0.5) + 1;\n\tint year = int(iDate.x + 0.5);\n\tint a = (14 - mon) / 12;\n\tint y = year + 4800 - a;\n\tint m = mon + 12 * a - 3;\n\tint jd = int(iDate.z + 0.5) + (153 * m + 2) / 5 + 365 * y + y / 4 - y / 100 + y / 400 - 32045;\n    jd -= 2451545;\n    float fr = (iDate.w - k_GMT * 60.0 * 60.0) / 86400.0 - 0.5;\n    if (fr < 0.)\n    {\n        jd -= 1;\n        fr += 1.;\n    }\n    else if (fr > 1.)\n    {\n        jd += 1;\n        fr -= 1.;\n    }\n\treturn vec2(float(jd), fr);\n}\n\nfloat GetGMST(vec2 jd)\n{   \n    // The code below really computes this: x = fract((18.697374558 + 24.06570982441908 * jd) / 24.) * 24.;\n    // but with much higher float point precision becouse it utilizes the fact that jd.x is integer and\n    // jd.y is fractional\n\tfloat x = 0.77905727325 + 0.00273790935 * jd.x + 1.00273790935 * jd.y;\n\treturn fract(x) * 24.;\n}\n\n\nfloat getlha(float alpha, float lambda, vec2 jd)\n{\n\tfloat gmst = GetGMST(jd);\n\treturn gmst / 12. * M_PI + lambda - alpha;\n}\n\n\n// Orbital utils\n////////////////////////////////////////////////////////////////////////////////////\n\nfloat GetMeanAnomaly(const Body b)\n{\n\treturn b.meanLongitude - b.longitudeOfPerihelion;\n}\n\nfloat GetTSE(const Body b, vec2 jd)\n{\n\treturn (jd.x - float(b.epoch - 2451545)) + jd.y;\n}\n\nfloat GetEccentricAnomaly(const Body b, float m)\n{\n    // Iteratively solves M = E - e \\sin E for E\n\tfloat e = 0.0;\n\tfloat lastDelta = 2.0;\n\tfor (float delta = 1., e_ = m; delta < lastDelta;)\n\t{\n\t\te = b.eccentricity * sin(e_) + m;\n\t\tlastDelta = delta;\n\t\tdelta = abs(e_ - e);\n\t\te_ = e;\n\t}\n\treturn e;\n}\n\nfloat GetRadius(const Body b, float eccentricAnomaly)\n{\n\treturn b.semimajorAxis * (1. - b.eccentricity * cos(eccentricAnomaly));\n}\n\nfloat GetArgumentOfPeriapsis(const Body b)\n{\n\treturn b.longitudeOfPerihelion - b.longitudeOfAscendingNode;\n}\n\nfloat GetTrueAnomaly(const Body b, float eccentricAnomaly)\n{\n\treturn 2.0 * atan(\n\t\tsqrt(1.0 + b.eccentricity) * sin(eccentricAnomaly / 2.0),\n\t\tsqrt(1.0 - b.eccentricity) * cos(eccentricAnomaly / 2.0)\n\t);\n}\n\n\n// Coordinate system conversions\n////////////////////////////////////////////////////////////////////////////////////\n\n\nvec3 Euler2Cartesian(vec4 e) // vec4: phi, theta, psi, r\n{\n\treturn e.w * vec3(\n        cos(e.x) * cos(e.y) - sin(e.x) * cos(e.z) * sin(e.y),\n        sin(e.x) * cos(e.y) * cos(e.z) + cos(e.x) * sin(e.y),\n        sin(e.x) * sin(e.z)\n    );\n}\n\nvec2 Cartesian2Ecliptik(vec3 p)\n{\n\tfloat lambda = atan(p.y, p.x);\n\tif (lambda < 0.)\n\t{\n\t\tlambda = lambda + 2. * M_PI;\n\t}\n    return vec2(lambda, atan(p.z, length(p.xy)));\n}\n\nvec2 Ecliptik2Equatorial(vec2 p)\n{\n\n\tfloat alpha = atan(\n\t\tsin(p.x)*cos(k_obliquityOfTheEcliptic) - tan(p.y)*sin(k_obliquityOfTheEcliptic),\n\t\tcos(p.x)\n\t);\n\tif (alpha < 0.)\n\t{\n\t\talpha = alpha + 2. * M_PI;\n\t}\n\n\tfloat delta = asin(\n\t\tsin(p.y) * cos(k_obliquityOfTheEcliptic) +\n\t\tcos(p.y) * sin(k_obliquityOfTheEcliptic) * sin(p.x)\n\t);\n\n\treturn vec2(alpha, delta);\n}\n\nvec2 Equatorial2Horizontal(vec2 e, vec2 observer, vec2 jd)\n{\n\tfloat h = getlha(e.x, observer.y, jd);\n\tif (h < 0.)\n\t{\n\t\th = h + 2. * M_PI;\n\t}\n\tfloat azimuth = atan(\n\t\tsin(h), \n\t\tcos(h) * sin(observer.x) - tan(e.y) * cos(observer.x)\n\t) + TO_RAD(180.);\n\tfloat altitude = asin(sin(observer.x) * sin(e.y) + cos(observer.x) * cos(e.y) * cos(h));\n    return vec2(azimuth, altitude);\n}\n\nvec2 Horizontal2Polar(vec2 h)\n{\n\treturn vec2(\n\t\t-sin(h.x) * (M_PI / 2.0 - h.y),\n\t\tcos(h.x) * (M_PI / 2.0 - h.y)\n\t);\n}\n\n\n// Compute Eulaer Angles from Julian day and orbital elements.\n////////////////////////////////////////////////////////////////////////////////////\n\nvec4 GetEulaerAnglesFromEccentricAnomaly(const Body b, float eccentricAnomaly)\n{\n\tfloat trueAnomaly = GetTrueAnomaly(b, eccentricAnomaly);\n\tfloat argumentOfPeriapsis = GetArgumentOfPeriapsis(b);\n\n\tfloat psi = trueAnomaly + argumentOfPeriapsis;\n\n\tfloat r = GetRadius(b, eccentricAnomaly);\n\treturn vec4(\n\t\tpsi, \n\t\tb.longitudeOfAscendingNode,\n\t\tb.inclination,\n\t\tr\n   );\n}\n\nvec4 GetEulaerAnglesFromJulianDay(const Body b, vec2 jd)\n{\n\tfloat meanMotion = 2.0 * M_PI / b.siderealOrbitPeriod;\n\tfloat currentMeanAnomaly = GetMeanAnomaly(b) + meanMotion * GetTSE(b, jd);\n\n\tfloat eccentricAnomaly = GetEccentricAnomaly(b, currentMeanAnomaly);\n\n\treturn GetEulaerAnglesFromEccentricAnomaly(b, eccentricAnomaly);\n}\n\n\n// Render text and print floats, https://www.shadertoy.com/view/llySRh\n////////////////////////////////////////////////////////////////////////////////////\n\nvoid mix_layer(inout vec4 c, float d, vec3 color, float w){ \n    float anti = fwidth(d) * w;\n    c.rgb = mix(c.rgb, color, smoothstep(anti, -anti, d));\n}\nvoid mix_layer(inout vec4 c, float d, vec4 color, float w){ \n    float anti = fwidth(d) * w;\n    c.rgb = mix(c.rgb, color.rgb, color.a * smoothstep(anti, -anti, d));\n}\n#define over(d, color) mix_layer(fragColor, d, color, 1.)\n\nvoid char(vec2 p, int c, inout vec4 fragColor) {\n    int char_id = -1; vec2 char_pos; \n    vec2 dfdx = dFdx(p/16.), dfdy = dFdy(p/16.);\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ){ // thighly y-clamped to allow dense text\n        vec4 r = textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                       dfdx, dfdy );\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0), r.x);\n    }\n}\nvoid pInt(vec2 p, float n, float d, inout vec4 fragColor) {\n    if (n < 0.){\n        char(p - vec2(-.5,0), 45, fragColor);\n        n = -n;\n    }\n    for (float i = d; i>=0.; i--) {\n        n /=  10.0;\n        char(p - .5*vec2(i,0), 48+ int(fract(n)*10.), fragColor);\n    }\n}\nvoid pInt(vec2 p, float n, inout vec4 fragColor) {\n    if (n < 0.) {\n        char(p - vec2(-.5,0), 45, fragColor);\n        n = -n;\n    }\n    for (float i = 3.; i>=0.; i--){\n        n /=  9.999999; // 10., // for windows :-(\n        char(p - .5*vec2(i,0), 48+ int(fract(n)*10.), fragColor);\n    }\n}\n// --- display float8.4\nvoid pFloat(vec2 p, float n, inout vec4 fragColor) {\n    if (n < 0.){ char(p - vec2(-.5,0), 45, fragColor); n = -n; }\n    float upper = floor(n);\n    float lower = fract(n)*1e4 + .5;  // mla fix for rounding lost decimals\n    if (lower >= 1e4) { lower -= 1e4; upper++; }\n    pInt(p,upper, fragColor); p.x -= 2.;\n    char(p, 46, fragColor);   p.x -= .5;\n    pInt(p,lower, fragColor);\n}\n#define C(c) char(p, c, fragColor);p.x -= .5;\n\n\n// Draw planets and ecliptic\n////////////////////////////////////////////////////////////////////////////////////\n\nbool draw_planet(Body b, vec2 jd, vec3 observer_pos, vec2 uv, inout vec4 fragColor)\n{\n    vec2 meq = Ecliptik2Equatorial(Cartesian2Ecliptik(Euler2Cartesian(GetEulaerAnglesFromJulianDay(b, jd)) - observer_pos));\n    vec2 mp = Horizontal2Polar(Equatorial2Horizontal(meq, geoCoordinates, jd));\n    over(length(mp - uv ) - 14. / iResolution.y, b.color / 255.);\n    \n    vec2 p = (uv - mp) * 12. / 675.* iResolution.y;\n    for (int i =0; i < b.name_length; ++i)\n    {\n        char(p, b.name[i], fragColor);   p.x -= .5;\n    }\n    \n    vec2 m = (iMouse.xy-0.5*iResolution.xy)/iResolution.y * M_PI;\n    return length(m - mp) < 30. / iResolution.y;\n}\n\nvoid draw_planet_info(Body b, vec2 jd, vec3 observer_pos, vec2 uv, inout vec4 fragColor)\n{\n    vec2 meq = Ecliptik2Equatorial(Cartesian2Ecliptik(Euler2Cartesian(GetEulaerAnglesFromJulianDay(b, jd)) - observer_pos));\n    vec2 mh = Equatorial2Horizontal(meq, geoCoordinates, jd);\n    vec2 mp = Horizontal2Polar(mh);\n    vec2 s = vec2(0.44, 0.85 - 1.) * 675. / iResolution.y;\n    float r = 0.05 * 675. / iResolution.y;\n    over(length(max(abs(uv - mp - s - vec2(r, -r))-abs(s),0.0))-r, vec4(mix(vec3(0.6), b.color / 255., 0.3), 0.9));\n    vec2 p = (uv - mp) * 12. / 675.* iResolution.y;\n    p.y += 1.7;\n    p.x -= 0.5;\n    float start_x = p.x;\n    for (int i =0; i < b.name_length; ++i)\n    {\n        char(p / 1.3, b.name[i], fragColor); p.x -= .5 * 1.3;\n    }\n    p.x = start_x; p.y += 1.3;\n    C(65)C(108)C(116)C(105)C(116)C(117)C(100)C(101)C(58)C(32)\n    pFloat(p, TO_GRD(mh.y), fragColor); p.x -= 4.5; char(p, 176, fragColor);\n    p.x = start_x; p.y += 1.0;\n    C(65)C(122)C(105)C(109)C(117)C(116)C(104)C(58)C(32)C(32)\n    pFloat(p, TO_GRD(mh.x), fragColor); p.x -= 4.5; char(p, 176, fragColor);\n}\n\nfloat d_ecliptic(float a, vec2 jd, vec2 uv)\n{\n    vec2 meq = Ecliptik2Equatorial(vec2(a, 0.));\n    vec2 mh = Equatorial2Horizontal(meq, geoCoordinates, jd);\n    vec2 mp = Horizontal2Polar(mh);\n    return length(mp - uv);\n}\n\n// Grid search to solve for ecliptic is not ideal...\n// Not sure how to improve, too lazy to compute Jacobians and solve with the Newton's method\nvoid draw_ecliptic(vec2 jd, vec2 uv, vec3 color, inout vec4 fragColor)\n{\n    float min_d = 1.0e6;\n    float min_a = 0.0;\n    float prev_a = min_a;\n    float d = 1.0;\n    for (int k =0; k < 7; ++k)\n    {\n        d *= 4.0;\n        for (int i = -3; i < 3; i++)\n        {\n            float a = prev_a + float(i) / d * 2.0 * M_PI;\n            float nd = d_ecliptic(a, jd, uv);\n            if (nd < min_d)\n            {\n                min_d = nd;\n                min_a = a;\n            }\n        }\n        // Early exit. We are too far from ecliptic, no sense to refine a.\n        if (min_d * 2.0 > d)\n            return;\n        prev_a = min_a;\n    }\n    over(min_d - 3. / iResolution.y, color);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y * 2.0;    \n    \n    vec2 jd = getjd();\n    vec3 observer_pos = Euler2Cartesian(GetEulaerAnglesFromJulianDay(get_bodies_by_id(3), jd));\n    \n    fragColor = vec4(vec3(0.), 1.0);\n    over(length(uv) - 1., vec3(1.0, 1.0, 1.0) * 0.1);\n    over(max(min(min(abs(uv.x), abs(uv.y)), min(min(abs(uv.x - uv.y), abs(uv.x + uv.y)) * 0.707, abs(length(uv) - 0.5))), length(uv) - 1.) - 1.5 / iResolution.y, vec3(1.0, 1.0, 1.0) * 0.6);\n    \n    char(uv * 12. + vec2(0.5, -11.), 78, fragColor);\n    char(uv * 12. + vec2(-11., 0.5), 87, fragColor);\n    char(uv * 12. + vec2(12., 0.5), 69, fragColor);\n    char(uv * 12. + vec2(0.5, 12), 83, fragColor);\n    \n    vec2 p = (uv * 12. + vec2(0., 0.5)) * 1.5 + vec2(1.5, 0.3);\n    char(p, 48 + 9, fragColor);  p.x -= .5; char(p, 48 + 0, fragColor);  p.x -= .5; char(p, 176, fragColor);\n    p = (uv * 12. + vec2(6., 0.5)) * 1.5 + vec2(1.0, 0.3);\n    char(p, 48 + 4, fragColor);  p.x -= .5; char(p, 48 + 5, fragColor);  p.x -= .5; char(p, 176, fragColor);\n    p = (uv * 12. + vec2(12., 0.5)) * 1.5 + vec2(1.0, 0.3);\n    char(p, 48 + 0, fragColor);  p.x -= .5; char(p, 176, fragColor);\n    draw_ecliptic(jd, uv * (M_PI / 2.), vec3(1.0, 1.0, 0.0), fragColor);\n    \n    int info = -1;\n    for (int i = 0; i < 12; ++i)\n        if (i != 3) // Don't draw Earth\n            info = draw_planet(get_bodies_by_id(i), jd, observer_pos, uv * (M_PI / 2.), fragColor) ? i : info;\n    if (info != -1)    \n        draw_planet_info(get_bodies_by_id(info), jd, observer_pos, uv * (M_PI / 2.), fragColor);\n    \n    p = fragCoord/iResolution.y * 2.0 * 16.;\n    p.y -= 1.0;\n    float start_x = p.x;\n    C(74)C(117)C(108)C(105)C(97)C(110)C(32)C(100)C(97)C(121)C(58)C(32)\n    pInt(p, jd.x + 2451545.5, 6., fragColor); p.x -= 3.5;\n    char(p, 46, fragColor);   p.x -= .5;\n    pInt(p, jd.y * 1000000., 5., fragColor); \n    p.x = start_x;\n    p.y += 1.0;\n    C(71)C(77)C(83)C(84)C(58)p.x -= 3.5;\n    pFloat(p, GetGMST(jd), fragColor);     \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}