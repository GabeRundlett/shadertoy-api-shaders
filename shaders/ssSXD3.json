{
    "Shader": {
        "info": {
            "date": "1621134579",
            "description": "a shader I wrote while live coding among friends",
            "flags": 0,
            "hasliked": 0,
            "id": "ssSXD3",
            "likes": 49,
            "name": "hehe - a typography shader",
            "published": 3,
            "tags": [
                "letters",
                "hehe",
                "words"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 928
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat corner(vec2 p) {\n  return length(max(p,0.))+min(0.,max(p.x,p.y));\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat h_(vec2 p) {\n  float l1 = linedist(p, vec2(0,-.75), vec2(0,-10)) - 1.5;\n  float l2 = linedist(p, vec2(0,-.5), vec2(0,-10)) - .5;\n  float l3 = linedist(p, vec2(-1,10), vec2(-1,-10)) - .5;\n  float ud = abs(p.y)-2.5;\n  return corner(vec2(ud,min(max(l1,-l2),l3)));\n}\n\nfloat e_(vec2 p) {\n  float l1 = linedist(p, vec2(0,-.75), vec2(0,-1.)) - 1.5;\n  float l2 = linedist(p, vec2(0,-.5), vec2(0,-1.25)) - .5;\n  float l3 = linedist(p, vec2(-1,-.65), vec2(1,-.65)) - .25;\n  float ho = linedist(p, vec2(.45,-1.05), vec2(10,-1.05)) - .15;\n  return corner(vec2(min(max(l1,-l2),l3),-ho));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat profile(vec2 p, float stronch) {\n  return corner(vec2(abs(p.x)-stronch-.3,p.y+.05))-.05;\n}\n\nvec3 gploc;\nfloat letter(vec3 p, bool e, float off) {\n  p.z += sin(iTime*3.+off)*.2;\n  p = erot(p,vec3(0,1,0),cos(iTime*4.+off)*.1);\n  p = erot(p,vec3(0,0,1),sin(iTime*4.+off)*.1);\n  p.x += sin(iTime*4.7+off);\n  \n  float x = iTime*(5.+sin(off)*.5)+off;\n  float stronch = (sin(x)*.5+.5+sin(x*3.)*.2)*3.;\n  \n  gploc = p * vec3(1./(stronch+.35),1,1);\n  vec2 h = vec2(p.x,e ? e_(p.yz) : h_(p.yz));\n  return profile(h, stronch);\n}\n\nint gid;\nvec3 ggploc;\nfloat scene(vec3 p) {\n  p -= vec3(0,-1.2,0);\n  float h1 = letter(p-vec3(1,-3,0),false,.4);\n  ggploc = gploc;\n  gid = 0;\n  float e1 = letter(p,true,2.9);\n  if (e1 < h1) {\n    \n  ggploc = gploc;\n    gid = 1;\n    h1 = e1;\n  }\n  float e2 = letter(p-vec3(0,6,0),true,5.9);\n  if (e2 < h1) {\n    gid = 2;\n  ggploc = gploc;\n    h1 = e2;\n  }\n  float h2 = letter(p-vec3(1,3,0),false,4.2);\n  if (h2 < h1) {\n    gid = 3;\n  ggploc = gploc;\n    h1 = h2;\n  }\n  return h1;\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p) - mat3(0.001);\n  return normalize(scene(p) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n  bool ise =  sin(iTime*5.)>0.;\n  \n  vec3 cam = normalize(vec3(2,uv));\n  vec3 init = vec3(-18.+sin(iTime*3.5)*3.,0,0);\n  \n  float yrot = sin(iTime)*.4;\n  float zrot = cos(iTime*5.5)*.4;\n  float xrot = sin(iTime*2.)*.3;\n  cam = erot(cam,vec3(1,0,0),xrot);\n  init = erot(init,vec3(0,1,0),yrot);\n  cam = erot(cam,vec3(0,1,0),yrot);\n  init = erot(init,vec3(0,0,1),zrot);\n  cam = erot(cam,vec3(0,0,1),zrot);\n  init.z += sin(iTime*5.)*.4;\n  \n  vec3 p = init;\n  bool hit = false;\n  bool inside = false;\n  float trigdist = .05;\n  for (int i = 0; i < 150 && !hit; i++) {\n    float dist = scene(p);\n    p += cam*dist;\n    hit = dist*dist < 1e-6;\n    if (dist < trigdist) { \n      inside = true;\n    }\n    if (inside && dist > trigdist) break;\n    if (distance(p,init) > 50.) break;\n  }\n  vec3 ploc = ggploc;\n  float id = float(gid);\n  vec3 n = norm(p);\n  vec3 r = reflect(cam,n);\n  float fact = length(sin(r*4.2)*.5+.5)/sqrt(3.);\n  float diff = length(sin(n*2.9)*.4+.6)/sqrt(3.);\n  float fres = 1. - abs(dot(cam,n))*.98;\n  float spec = (fact*.05 + pow(fact,8.)*2.)*fres;\n  vec3 diffcol = vec3(0.7,.1,.05);\n  diffcol = erot(diffcol,n,.2);\n  diffcol = erot(diffcol,normalize(sin(n*6.)),.2);\n  diffcol = min(max(erot(diffcol,normalize(vec3(1,2,3)),id+floor(iTime*3.))*.8+.5,0.05),.9);\n  if (dot(sin(erot(ploc,normalize(vec3(1,1,1)),.6*id)*20.),vec3(1)) > 0.5) diffcol = pow(fact,4.)*diffcol*10.;\n  vec3 col = diff*diffcol+spec*mix(diffcol,vec3(1),.5);\n  float ang = atan(uv.x,uv.y);\n  float bg = sin(ang*10.+iTime*2.);\n  ang += iTime;\n  vec3 rainbow = vec3(sin(ang),sin(ang+3.14/3.),sin(ang+3.14*2./3.))*.4+.6;\n  bg = smoothstep(fwidth(bg),0.,bg);\n  float circ = length(uv)-.4;\n  circ = smoothstep(fwidth(circ),0.,circ);\n  vec3 bgcol = vec3(mix(rainbow,vec3(1),bg));\n  \n  vec3 fancycol = vec3(0.7,.1,.05);\n  fancycol = min(max(erot(fancycol,normalize(vec3(1,2,3)),9.+floor(iTime*3.)*1.3)*.8+.5,0.05),.9);\n  bgcol = mix(bgcol,fancycol,circ);\n  fragColor.xyz = hit ? col : bgcol;\n  if (inside && !hit) fragColor.xyz = vec3(0);\n  fragColor *= 1.-dot(uv,uv)*.3;\n  fragColor = sqrt(fragColor);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}