{
    "Shader": {
        "info": {
            "date": "1521577619",
            "description": "Reverse engineering [url=https://www.shadertoy.com/view/llcGDS]iq's awesome shader[/url]. Decided to add mouse interactivity for fun.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldycWR",
            "likes": 4,
            "name": "Another Collatz Fractal",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "collatz"
            ],
            "usePreview": 0,
            "username": "Ebanflo",
            "viewed": 595
        },
        "renderpass": [
            {
                "code": "//The Collatz sequence diverges for most of the complex plane\n//So how about look at the direction that it diverges in?\n//That's how this fractal is constructed\n\n#define derivative\n//#define ratio\n\n#define interactive\n#define sensitivity 2.0\n//#define grid\n#define gridThickness 0.001\n\n#define scale 1.0//exp(-5.5 - 5.5*sin(0.1*iTime))\n#define yShift 0.0\n#define xShift 0.0\n\n#define AA 2\n#define fractalIters 55\nconst float pi = 3.14159;\n\nvec2 cexp(vec2 z){return exp(z.x)*vec2(cos(z.y), sin(z.y));}\nvec2 cexpj(vec2 z){return exp(-z.y)*vec2(cos(z.x), sin(z.x));}\nvec2 cmul(vec2 a, vec2 b){return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x );}\n\nvec2 m(float t){\n    return iMouse.xy == vec2(0) ? -0.25*vec2(cos(t), 1.0 - sin(t))\n    : sensitivity*(2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n}\n\nvec2 collatz(vec2 z){\n    #ifdef interactive\n    return 1.75*z + 2.0*m(iTime) - cmul(cexpj(pi*z), 1.25*z + vec2(0.5, 0));\n    #else\n    return 1.75*z + vec2(0.5, 0) - cmul(cexpj(pi*z), 1.25*z + vec2(0.5, 0));    \n    #endif\n}\n\nvec2 dCollatz(vec2 z){\n    return vec2(1.75, 0) - cmul(1.25*pi*vec2(-z.y, z.x) + vec2(1.25, 0) + vec2(0.5*pi, 0), cexpj(pi*z));\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 render(vec2 xy){\n    #ifdef grid\n    vec2 f = fract(xy);\n    if(f.x < gridThickness || f.y < gridThickness) return vec3(0);\n    #endif\n    vec2 z = xy;\n    vec2 dz = vec2(1, 0);\n    for(int i = 0; i < fractalIters; i++){\n        dz = cmul(dz, dCollatz(z));\n        z = collatz(z);\n    }\n    #ifdef ratio\n    return vec3(length(z)/length(dz));\n    #endif\n    #ifdef derivative\n    float arg = atan(dz.y, dz.x);\n    #else\n    float arg = atan(z.y, z.x);\n    #endif\n    //return vec3(z == z);\n    //return vec3(abs(arg - 0.25*pi));\n    return hsv2rgb(0.5 + 0.5*sin(arg - vec3(0, 0.666666*pi, 1.333333*pi))).bgr;\n}    \n\nvec2 rect(vec2 frag){\n    return scale*(2.0*frag - iResolution.xy)/iResolution.y + vec2(xShift, yShift);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 px = rect(fragCoord + vec2(m, n)/float(AA));\n    \tcol += render(px);    \n    }\n    col /= float(AA*AA);\n#else\n        \n    col = render(rect(fragCoord));\n#endif            \n    \n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}