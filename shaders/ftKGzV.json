{
    "Shader": {
        "info": {
            "date": "1638016751",
            "description": "Heaven",
            "flags": 0,
            "hasliked": 0,
            "id": "ftKGzV",
            "likes": 10,
            "name": "3D truchet - Bonus Stage",
            "published": 3,
            "tags": [
                "truchet"
            ],
            "usePreview": 0,
            "username": "IWBTShyGuy",
            "viewed": 308
        },
        "renderpass": [
            {
                "code": "// Copyright Â© 2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n#if HW_PERFORMANCE!=0\n// If defined, activate anti-aliasing, level: 2 or 3\n#define AA 2\n#endif\n\n// Apply anti-aliasing to objects below this distance.\n#define AA_FAR 1.5\n\n// ----------------------- Config ----------------------- //\n// The larger these values, the greater the visual impact.\n// It also increases the load on the GPU.\n\n// Farthest distance to draw\nconst float FAR = 4.0;\n\n// the number of coins in one line\nconst int LINE_COIN = 3;\n\n// -------------------- Visual Config ------------------- //\nconst vec3 SUN_SHINE = normalize(vec3(1, -1, -1));\nconst float PIPE_SIZE = 0.075;\nconst float COIN_SIZE = 0.03;\n\n// --------------------- Basic SDF --------------------- //\n// https://iquilezles.org/articles/distfunctions\nfloat sdCylinder(in vec3 p, in float r, in float h) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdStar5(in vec2 p, in float r, in float rf) {\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\n// ----------------------- PIPE ----------------------- //\n// sdf\nfloat sdPipe(in vec3 p) {\n    p /= PIPE_SIZE;\n    float dist0 = sdCylinder(p, 0.5, 0.51);\n    float dist1 = sdCylinder(\n        p - vec3(0, 0.3, 0),\n        0.55, 0.15\n    ) - 0.06;\n    return min(dist0, dist1) * PIPE_SIZE;\n}\n\n// normal\nvec3 normalPipe(in vec3 p) {\n    const vec2 h = vec2(0.0001,0);\n    return normalize(vec3(\n        sdPipe(p+h.xyy) - sdPipe(p-h.xyy),\n        sdPipe(p+h.yxy) - sdPipe(p-h.yxy),\n        sdPipe(p+h.yyx) - sdPipe(p-h.yyx)\n    ));\n}\n\n// albedo\nvec3 albPipe(in vec3 p) {\n    float c = length(p.zx) / PIPE_SIZE;\n    c = smoothstep(0.0, 1.0, (c - 0.42) / 0.01);\n    return vec3(0, c, 0);\n}\n\n// radiance without distance decay\nfloat radPipe(in vec3 normal, in vec3 dir) {\n    float c0 = microfacet(\n        normal,\n        dir,\n        dir,\n        0.0,\n        0.5\n    );\n    float c1 = microfacet(\n        normal,\n        dir,\n        SUN_SHINE,\n        0.9,\n        0.5\n    );\n    return c0 * 0.2 + c1 * 0.8;\n}\n\n// ----------------------- COIN ----------------------- //\n// sdf\nfloat sdCoin(in vec3 p) {\n    p /= COIN_SIZE;\n    float dist = sdCylinder(p, 0.98, 0.08) - 0.02;\n    return dist * COIN_SIZE;\n}\n\nconst vec3 COIN_ALBEDO = vec3(241, 208, 12) / 255.0;\n\n// normal mapping\nvec3 normalCoin(in vec3 p) {\n    float r = 0.98 * COIN_SIZE;\n    float h = 0.08 * COIN_SIZE;\n    vec2 e = vec2(0.0001,0);\n    vec3 base = normalize(vec3(\n        sdCoin(p + e.xyy) - sdCoin(p - e.xyy),\n        sdCoin(p + e.yxy) - sdCoin(p - e.yxy),\n        sdCoin(p + e.yyx) - sdCoin(p - e.yyx)\n    ));\n    if (abs(p.y) < h - 0.001) {\n        return base;\n    } else {\n        vec2 uv = p.zx / r;\n        float r0 = length(uv) - 0.7;\n        float c0 = min(\n            max(0.0, r0 - 0.05),\n            max(0.0, 0.15 - r0)\n        ) * 20.0;\n        vec2 tmp = normalize(p.zx);\n        vec3 n0 = vec3(tmp.y, 0, tmp.x);\n        vec2 e = vec2(0.00001, 0);\n        float r1 = sdStar5(uv, 0.6, 0.4);\n        float c1 = -min(\n            max(0.0, r1 + 0.025),\n            max(0.0, 0.025 - r1)\n        ) * 20.0;\n        vec3 n1 = normalize(vec3(\n            sdStar5(uv+e.yx, 0.6, 0.4) - sdStar5(uv-e.yx, 0.6, 0.4),\n            0,\n            sdStar5(uv+e.xy, 0.6, 0.4) - sdStar5(uv-e.xy, 0.6, 0.4)\n        ));\n        return normalize(base - c0 * n0 - c1 * n1);\n    }\n}\n\n// radiance without distance decay\nfloat radCoin(in vec3 normal, in vec3 dir) {\n    float c0 = microfacet(\n        normal,\n        dir,\n        dir,\n        0.0,\n        0.5\n    );\n    float c1 = microfacet(\n        normal,\n        dir,\n        SUN_SHINE,\n        0.9,\n        0.5\n    );\n    return c0 * 0.2 + c1 * 0.8;\n}\n\n// ----------------------- SDF ----------------------- //\n#define rotate3D(n, t) mat3( \\\n    cos(t) + n.x * n.x * (1.0 - cos(t)), \\\n    n.x * n.y * (1.0 - cos(t)) + n.z * sin(t), \\\n    n.z * n.x * (1.0 - cos(t)) - n.y * sin(t), \\\n    n.x * n.y * (1.0 - cos(t)) - n.z * sin(t), \\\n    cos(t) + n.y * n.y * (1.0 - cos(t)), \\\n    n.y * n.z * (1.0 - cos(t)) + n.x * sin(t), \\\n    n.z * n.x * (1.0 - cos(t)) + n.y * sin(t), \\\n    n.y * n.z * (1.0 - cos(t)) - n.x * sin(t), \\\n    cos(t) + n.z * n.z * (1.0 - cos(t))  \\\n)\n\nconst mat3 T0 = rotate3D(normalize(vec3(0, 1, -1)), PI);\nconst mat3 T1 = rotate3D(normalize(vec3(1, 0, 1)), PI);\nconst mat3 T2 = rotate3D(normalize(vec3(0, 1, 1)), PI);\n\n// hexahedron group\nconst mat3[] S = mat3[](\n    mat3(1, 0, 0, 0, 1, 0, 0, 0, 1),\n    T2,\n    T1,\n    T2 * T1,\n    T1 * T2,\n    T2 * T1 * T2,\n    T0,\n    T2 * T0,\n    T1 * T0,\n    T2 * T1 * T0,\n    T1 * T2 * T0,\n    T2 * T1 * T2 * T0,\n    T0 * T1,\n    T2 * T0 * T1,\n    T1 * T0 * T1,\n    T2 * T1 * T0 * T1,\n    T1 * T2 * T0 * T1,\n    T2 * T1 * T2 * T0 * T1,\n    T0 * T1 * T2,\n    T2 * T0 * T1 * T2,\n    T1 * T0 * T1 * T2,\n    T2 * T1 * T0 * T1 * T2,\n    T1 * T2 * T0 * T1 * T2,\n    T2 * T1 * T2 * T0 * T1 * T2\n);\n\nstruct MarchingOutput {\n    float dist;\n    int shape;\n    mat3 mat;\n    vec3 p;\n};\n\n// cell-wise sdf\n// This time, the objects are sparse, so we don't need to think about the other cells.\nMarchingOutput sDist(in vec3 p, in float t) {\n    int index = int(hash13(floor(p) + 0.23) * 24.0);\n    p = fract(p);\n    \n    MarchingOutput op, op0;\n    \n    // ----------------- PIPE ----------------- //\n    op0.shape = 0;\n    \n    op0.mat = mat3(1);\n    op0.p = p - vec3(0.5, 0.5 * PIPE_SIZE, 0.5);\n    op0.dist = sdPipe(op0.p);\n    op = op0;\n    \n    op0.mat = rotate3D(vec3(1, 0, 0), PI);\n    op0.p = op0.mat * (p - vec3(0.5, 1.0 - 0.5 * PIPE_SIZE, 0.5));\n    op0.dist = sdPipe(op0.p);\n    if (op0.dist < op.dist) op = op0;\n    \n    op0.mat = rotate3D(vec3(0, 0, 1), PI/2.0);\n    op0.p = op0.mat * (p - vec3(0.5 * PIPE_SIZE, 0.5, 0.5));\n    op0.dist = sdPipe(op0.p);\n    if (op0.dist < op.dist) op = op0;\n    \n    op0.mat = rotate3D(vec3(0, 0, 1), -PI/2.0);\n    op0.p = op0.mat * (p - vec3(1.0 - 0.5 * PIPE_SIZE, 0.5, 0.5));\n    op0.dist = sdPipe(op0.p);\n    if (op0.dist < op.dist) op = op0;\n\n    op0.mat = rotate3D(vec3(1, 0, 0), -PI/2.0);\n    op0.p = op0.mat * (p - vec3(0.5, 0.5, 0.5 * PIPE_SIZE));\n    op0.dist = sdPipe(op0.p);\n    if (op0.dist < op.dist) op = op0;\n    \n    op0.mat = rotate3D(vec3(1, 0, 0), PI/2.0);\n    op0.p = op0.mat * (p - vec3(0.5, 0.5, 1.0 - 0.5 * PIPE_SIZE));\n    op0.dist = sdPipe(op0.p);\n    if (op0.dist < op.dist) op = op0;\n\n    // ----------------- COIN ----------------- //\n    op0.shape = 1;\n    op0.mat = rotate3D(vec3(0, 0, 1), -PI / 2.0) * rotate3D(vec3(0, 1, 0), -t);\n\n    for (int i = 0; i < LINE_COIN; i++) {\n        float k = float(i) / float(LINE_COIN);\n        vec3 disp = vec3(0.5, fract(t * 0.1 + k), 0.5);\n        disp = fract(S[index] * (disp - 0.5) + 0.5);\n        op0.p = op0.mat * (p - disp);\n        op0.dist = sdCoin(op0.p);\n        if (op0.dist < op.dist) op = op0;\n    }\n    \n    for (int i = 0; i < LINE_COIN; i++) {\n        float k = float(i) / float(LINE_COIN);\n        float theta = (fract(t * 0.1 + k) - 0.05) * PI * 0.55;\n        vec2 disp2d = vec2(cos(theta), sin(theta)) * (0.5 - PIPE_SIZE) + PIPE_SIZE;\n        vec3 disp = vec3(disp2d.y, 0.5, disp2d.x);\n        disp = fract(S[index] * (disp - 0.5) + 0.5);\n        op0.p = op0.mat * (p - disp);\n        op0.dist = sdCoin(op0.p);\n        if (op0.dist < op.dist) op = op0;\n    }\n\n    for (int i = 0; i < LINE_COIN; i++) {\n        float k = float(i) / float(LINE_COIN);\n        float theta = (fract(t * 0.1 + k) - 0.05) * PI * 0.55;\n        vec2 disp2d = vec2(cos(theta), sin(theta)) * (0.5 - PIPE_SIZE) + PIPE_SIZE;\n        disp2d = 1.0 - disp2d;\n        vec3 disp = vec3(disp2d.y, 0.5, disp2d.x);\n        disp = fract(S[index] * (disp - 0.5) + 0.5);\n        op0.p = op0.mat * (p - disp);\n        op0.dist = sdCoin(op0.p);\n        if (op0.dist < op.dist) op = op0;\n    }\n\n    return op;\n} \n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 theta = vec2(0.15, 0.25) * iTime;\n    theta.y = sin(theta.y) * 0.5;\n    Camera camera = newCamera(\n        vec3(sin(iTime * 0.1) * 0.1, -iTime * 0.1, cos(iTime * 0.1) * 0.1),\n        vec3(cos(theta.x) * cos(theta.y), sin(theta.y), sin(theta.x) * cos(theta.y)),\n        vec3(0, 1, 0),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, fragCoord / iResolution.xy);\n\n    vec3 p = ray.origin;\n    float dist = 0.0;\n    MarchingOutput op;\n    for (int _i = 0; _i < 100; _i++) {\n        op = sDist(p, iTime);\n        if (op.dist < 0.00001 || dist >= FAR) break;\n        dist += op.dist;\n        p = ray.origin + dist * ray.direction;\n    }\n\n    const vec3 BLUE0 = vec3(160, 216, 234) / 255.0;\n    const vec3 BLUE1 = vec3(108, 155, 210) / 255.0;\n    float y = (1.0 + ray.direction.y) * 0.5;\n    vec3 col = pow((1.0 - y) * BLUE0 + y * BLUE1, vec3(2.2));\n    if (dist < FAR) {\n        float decay = smoothstep(0.0, 1.0, dist / FAR);\n        decay *= decay;\n        if (op.shape == 0) { // pipe\n            vec3 normal = transpose(op.mat) * normalPipe(op.p);\n            float rad = radPipe(normal, ray.direction);\n            vec3 albedo = albPipe(op.p);\n            col = (1.0 - decay) * rad * albedo + decay * col;\n        } else { // coin\n            vec3 normal = transpose(op.mat) * normalCoin(op.p);\n            float rad = radCoin(normal, ray.direction);\n            col = (1.0 - decay) * rad * COIN_ALBEDO + decay * col;\n        }\n    }\n\n    fragColor = vec4(pow(col, vec3(0.4545)), clamp(dist, 0.0, FAR));\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    \n// smart anti-aliasing\n// reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n// If defined, visualize anti-aliased pixels.\n//#define VISUALIZE_AA\n#ifdef AA\n    if (fwidth(length(O.xyz)) > 0.2 && O.w < AA_FAR) {\n\n        O.xyz = pow(O.xyz, vec3(2.2));\n        vec4 o;\n#if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              mainImage0(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 5.0;\n#elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 9.0;\n#endif\n#ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n#endif\n        O.xyz = pow(O.xyz, vec3(0.4545));\n    }\n#endif\n    O.w = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nCamera newCamera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\nfloat microfacet(vec3 normal, vec3 cameraDir, vec3 lightDir, float metal, float roughness) {\n    vec3 middle = normalize(cameraDir + lightDir);\n    float dotCN = clamp(-dot(cameraDir, normal), 0.0, 1.0);\n    float dotLN = clamp(-dot(lightDir, normal), 0.0, 1.0);\n    float dotNM = -dot(normal, middle);\n    float dotCM = dot(cameraDir, middle);\n    float alpha = roughness * roughness;\n    \n    // diffuse BRDF\n    float diffuse = 1.0 - metal;\n    \n    // microfacet distribution\n    float alpha2 = alpha * alpha;\n    float tmp = 1.0 - dotNM * dotNM * (1.0 - alpha2);\n    float distribution = alpha2 / (tmp * tmp);\n\n    // schlick approxy & geometric decay\n    float alp = alpha * 0.5;\n    float sal = dotLN / (dotLN * (1.0 - alp) + alp);\n    float sac = dotCN / (dotCN * (1.0 - alp) + alp);\n    float decay = sal * sac;\n\n    // fresnel\n    float c = 1.0 - dotCM;\n    c = c * c * c * c * c;\n    float fresnel = metal + (1.0 - metal) * c;\n\n    // specular BRDF\n    tmp = 4.0 * dotCN * dotLN;\n    float specular = distribution * decay / tmp * fresnel;\n    if (tmp < 0.0001) specular = 0.0;\n    \n    return (diffuse + specular) * dotLN;\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}