{
    "Shader": {
        "info": {
            "date": "1688462305",
            "description": "Homework 1",
            "flags": 32,
            "hasliked": 0,
            "id": "dsfBRr",
            "likes": 6,
            "name": "SDF Teapot",
            "published": 3,
            "tags": [
                "test"
            ],
            "usePreview": 0,
            "username": "KZubatov",
            "viewed": 199
        },
        "renderpass": [
            {
                "code": "#define DIZERING 1\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    #if DIZERING\n        fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n    #else\n        fragColor = texture(iChannel0, uv);\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define DIZERING 1\n#define MAX_STEPS 300\nconst float PI = 3.14159265359;    \n\nconst vec3 lightPos   = vec3(2, 2, 1);\nconst vec4 lightColor = vec4(1.5, 1, 1, 1) * .7;\n\nconst vec4 ambientColor = vec4(1, 1, 1, 1) * 0.1;\n\nconst float MAX_DIST = 6.0;\nconst float EPS = 0.001;\n\nmat3 rotationX(float a) {\n    return mat3(1, 0, 0,\n                0, cos(a), -sin(a),\n                0, sin(a), cos(a));\n}\n\nmat3 rotationY(float a) {\n    return mat3(cos(a), 0, sin(a),\n            0, 1, 0,\n            -sin(a), 0, cos(a));\n}\n\nmat3 rotationZ(float a) {\n    return mat3(cos(a), -sin(a), 0,\n            sin(a), cos(a), 0,\n            0, 0, 1);\n}\n\nfloat smoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h); \n}\n\nfloat smoothSubtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h); \n}\n\nfloat smoothIntersection(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h); \n}\n\nfloat rand(float frame) {\n    return fract(sin(dot(vec3(frame), vec3(12.9898,78.233,45.5432))) * 43758.5453);\n}\n\nfloat sdf_sphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat sdf_capped_cone(vec3 p, float h, float r1, float r2) {\n    vec2 q = vec2(length(p.xz), p.y);\n    vec2 k1 = vec2(r2, h);\n    vec2 k2 = vec2(r2 - r1, 2.0 * h);\n    vec2 ca = vec2(q.x - min(q.x, q.y < 0.0 ? r1 : r2), abs(q.y) - h);\n    vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdf_torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdf_cut_sphere(vec3 p, float r, float h) {\n    float w = sqrt(r * r - h * h);\n    vec2 q = vec2(length(p.xz), p.y);\n    float s = max((h - r) * q.x * q.x + w * w * (h + r - 2.0 * q.y), h * q.x - w * q.y);\n    return s < 0.0 ? length(q) - r : q.x < w ? h - q.y : length(q - vec2(w, h));\n}\n\nfloat sdf_cylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r,h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat length_n(vec2 t, float n) {\n    return pow(pow(abs(t.x), n) + pow(abs(t.y), n), 1.0 / n);\n}\n\nfloat sdf_torus(vec3 p, vec2 t, float n, float m) {\n    vec2 q = vec2(length_n(p.xz, n) - t.x, p.y);\n    return length_n(q, m) - t.y;\n}\n\nfloat sdf_round_cone(vec3 p, float r1, float r2, float h) {\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n    vec2 q = vec2(length(p.xz), p.y);\n    float k = dot(q, vec2(-b, a));\n    if (k < 0.0) \n        return length(q) - r1;\n    if (k > a * h) \n        return length(q - vec2(0.0, h)) - r2;\n    return dot(q, vec2(a,b)) - r1;\n}\n\nfloat sdf_plane(vec3 p, vec3 n, float h) {\n    return dot(p, n) + h;\n}\n\nfloat sdf(vec3 p) {\n    float dTorus = sdf_torus(p - vec3(0, 0.2, 0), vec2(0.31, 0.02));\n    float dCappedCone = sdf_capped_cone(p, 0.2, 0.5, 0.35);\n    float dCutSphereUp = sdf_cut_sphere(p + vec3(0, 0.55, 0), 0.8, 0.75);\n    float subtraction1 = smoothSubtraction(dTorus, dCappedCone, 0.02);\n    float union1 = smoothUnion(subtraction1, dCutSphereUp, 0.03);\n    float dCutSphereDown = sdf_cut_sphere(p * vec3(1, -1, 1), sqrt(0.29), 0.2);\n    float union2 = min(union1, dCutSphereDown);\n    float dInvisibleCylinder = sdf_cylinder(p + vec3(0, sqrt(0.29) - 0.05, 0), 0.19, 0.45);\n    float subtraction2 = max(union2, -dInvisibleCylinder);\n    float dVisibleCylinder = sdf_cylinder(p + vec3(0, sqrt(0.29) - 0.22, 0), 0.01, 0.45);\n    float union3 = smoothUnion(subtraction2, dVisibleCylinder, 0.03);\n    float dTorus42 = sdf_torus((p - vec3(0, 0.22, 0)) * rotationX(PI / 2.0), vec2(0.1, 0.02), 4.0, 2.0);\n    float union4 = smoothUnion(union3, dTorus42, 0.03);\n    float dTorus24 = sdf_torus((p + vec3(0.5, 0, 0)) * rotationX(PI / 2.0), vec2(0.14, 0.035), 2.0, 4.0);  \n    float union5 = smoothUnion(union4, dTorus24, 0.05);\n    float dRoundCone = sdf_round_cone(rotationZ(-PI / 4.0) * (p - vec3(0.46, -0.1, 0)), 0.1, 0.04, 0.35);\n    float union6 = smoothUnion(union5, dRoundCone, 0.05);\n    float dInvisibleSphere = sdf_sphere(p, vec3(0.73, 0.17, 0), 0.025);\n    float subtraction3 = smoothSubtraction(dInvisibleSphere, union6, 0.03);\n    float dPlane = sdf_plane(p, vec3(0, 1, 0), 0.34);\n    return min(subtraction3, dPlane);\n}\n\nvec3 generateNormal(vec3 p) {\n    float dx1 = sdf(p + vec3(EPS, 0, 0));\n    float dx2 = sdf(p - vec3(EPS, 0, 0));\n    float dy1 = sdf(p + vec3(0, EPS, 0));\n    float dy2 = sdf(p - vec3(0, EPS, 0));\n    float dz1 = sdf(p + vec3(0, 0, EPS));\n    float dz2 = sdf(p - vec3(0, 0, EPS));\n    \n    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));\n}\n\nfloat ambientOcclusion(vec3 p, vec3 normal) {\n    const float stepSize = 0.03;\n    \n    float occ = 0.0;\n    float sca = 1.0;\n    \n    float h = 0.01;\n    for (int i = 0; i < 10; ++i) {\n        float d = sdf(p + h * normal);\n        occ += (h - d) * sca;\n        sca *= 0.95;\n\n        if (occ > 0.35) \n            break;\n        \n        h += stepSize;\n    }\n\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0) * (0.3 + 0.5 * normal.y + 0.8 * normal.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    #if DIZERING\n        vec3 CAMERA_POS = vec3(0, 1, 3);\n        vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n        vec2 uv = (fragCoord - 0.5 * iResolution.xy + (randVals.xy - 0.5)) / iResolution.x;\n    #else \n        vec3 CAMERA_POS = vec3(3.0 * cos(iTime), 1, 3.0 * sin(iTime));\n        vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    #endif\n    \n    vec3 forward = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    \n    vec3 rayDir = normalize(forward + uv.x * right + uv.y * up);\n    \n    vec3 p = CAMERA_POS;\n    float totalDist = 0.0;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        float dist = sdf(p);\n        \n        if (abs(dist) < EPS) {\n            if (abs(dist - sdf_plane(p, vec3(0, 1, 0), 0.34)) < EPS) {\n                fragColor = vec4(0.357, 0.631, 0.6, 1);\n            } else {\n                fragColor = vec4(0.867, 0.749, 0.667, 1);\n            }\n            vec3 normal = generateNormal(p);\n            vec3 towardLight = normalize(lightPos - p);\n            fragColor *= max(0.0, dot(towardLight, normal)) * lightColor + ambientOcclusion(p, normal) * ambientColor;\n            fragColor += pow(max(0.0, dot(reflect(towardLight, normal), normalize(p - CAMERA_POS))), 128.0) * lightColor;\n            break;\n        }\n        \n        totalDist += dist;\n        if (totalDist > MAX_DIST) {\n            fragColor = vec4(0.733, 0.776, 0.784, 1);\n            break;\n        }\n        \n        p += rayDir * dist;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define DIZERING 1\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    #if DIZERING\n        fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n    #else\n        fragColor = texture(iChannel0, uv);\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}