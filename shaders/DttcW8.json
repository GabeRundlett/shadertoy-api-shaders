{
    "Shader": {
        "info": {
            "date": "1699312324",
            "description": "Simple ambient occlusion computation on a heightfield.\nHold LMB to reset accumulation (if enabled).\nVarious options are in \"Common\"",
            "flags": 32,
            "hasliked": 0,
            "id": "DttcW8",
            "likes": 4,
            "name": "Heightmap Ambient Occlusion",
            "published": 3,
            "tags": [
                "ambientocclusion"
            ],
            "usePreview": 0,
            "username": "AshenFlowersFalling",
            "viewed": 271
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //fragColor = texture(iChannel0, uv);\n    //fragColor = texture(iChannel0, uv).yyyy*texture(iChannel0, uv).xxxx/64.0;\n    fragColor = texture(iChannel0, uv).yyyy;\n    //fragColor = texture(iChannel0, uv).xxxx/H_SCALE;\n    //fragColor = texture(iChannel0, uv).yyyy*texture(iChannel1, uv);\n    \n    //fragColor = vec4(LOGARITHMIC_MAX_STEPS(256) / 256.0);\n    //fragColor = vec4(LOGARITHMIC_RADIUS(20))/5.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SQUARE_WIDTH 64.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h_scale = H_SCALE;\n    \n    // Needed to get accurate float values in mipmaps\n    // texture\n    fragColor = texture(iChannel0, ZOOM_FACTOR * fragCoord.xy/iResolution.xy);\n    fragColor.z = texelFetch(iChannel1, ivec2(0), 0).z;\n    \n    if (iMouse.z > 0.0)\n        fragColor.z = intBitsToFloat(iFrame);\n        \n    return;\n    \n    // sphere and raised plane\n    fragColor.x = (1.0 - min(length(iResolution.xy/2.0 - fragCoord)/128.0, 1.0));\n    if (fragCoord.x < iResolution.x/2.0)\n        fragColor.x += 0.0;\n    else\n        fragColor.x = max(fragColor.x, 0.25);\n        \n    return;\n    \n    // square\n    vec2 off = abs(fragCoord.xy - iResolution.xy/2.0);\n    if ((off.x < SQUARE_WIDTH) && (off.y < SQUARE_WIDTH))\n        fragColor.x = H_SCALE;\n    else\n        fragColor.x = 0.0;\n        \n    return;\n    \n    // sine wave\n    off = vec2(0.0, iResolution.y/2.0 + 32.0*sin(fragCoord.x / 32.0));\n    vec2 diff = abs(fragCoord.xy - off);\n    if ((diff.y < 32.0) && (diff.x > 64.0) && (diff.x < iResolution.x - 64.0))\n        fragColor.x = H_SCALE;\n    else\n        fragColor.x = 0.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define INFINITE_ACCUMULATE 1                // just accumulate forever\n#define LUMINANCE_SIGMA 0.25                 // fall-off rate for gaussian in luminance\n#define PLANAR_DISTANCE_SIGMA 3.0            // fall-off rate for gaussian in distance\n#define ZOOM_FACTOR 0.25                     // how much to zoom in on the texture\n#define SIMPLE_BILATERAL_FILTER 0            // use a simple box-filter\n#define BILATERAL_FILTER_HWIDTH 8            // half-width of bilateral filter\n#define MAX_ACCUMULATE_STEPS 8               // maximum frames to accumulate\n#define ACCUMULATE_STEP_SPACING 15           // frames between updating accumulation\n#define BILATERAL_FILTER 1                   // blur the result with a bilateral filter\n#define ACCUMULATE 1                         // set to 0 to perform computation in a single-pass\n#define MODE_LOGARITHMIC 0                   // set to 1 to perform variable-size steps in the tracer\n#define LINEAR_AXIS_DIRECTIONS 4             // number of axis directions to trace per frame, must be >4 for logarithmic mode\n#define LOGARITHMIC_AXIS_DIRECTIONS 64       // number of axis directions to trace per frame, must be >4 for logarithmic mode\n#define LINEAR_STEPS 256                     // steps that the linear solver performs on each ray\n#define H_SCALE 128.0                        // vertical scale\n#define RANDOMISED_DIRECTIONS 1              // set to 0 to use fixed ray directions every frame. This MUST be set to 1 if ACCUMULATE != 0\n\n#define LOG2 log2\n#define LOGARITHMIC_STEP_ANGLE ((360.0 / float(LOGARITHMIC_AXIS_DIRECTIONS)) * 0.01745329251994329576923690768489)\n#define LOGARITHMIC_MAX_STEPS(width) (1.0 + log2(float(width)) / log2((1.0 + sin(LOGARITHMIC_STEP_ANGLE)) / (1.0 - sin(LOGARITHMIC_STEP_ANGLE))))\n#define LOGARITHMIC_DIST(n) pow(((1.0 + sin(LOGARITHMIC_STEP_ANGLE)) / (1.0 - sin(LOGARITHMIC_STEP_ANGLE))), float(n) - 1.0)\n#define LOGARITHMIC_RADIUS(n) (LOGARITHMIC_DIST(n) * sin(LOGARITHMIC_STEP_ANGLE))\n\n// high-quality hash, modified version of old version of XXHash32 from https://github.com/Cyan4973/xxHash (BSD license)\n\nstruct vec5\n{\n\tfloat v[5];\n};\nstruct uvec5\n{\n\tuint v[5];\n};\nstruct vec6\n{\n\tfloat v[6];\n};\nstruct uvec6\n{\n\tuint v[6];\n};\n\nuvec6 touvec6(uvec5 x) { uvec6 x6;    x6.v[0] = x.v[0]; x6.v[1] = x.v[1]; x6.v[2] = x.v[2]; x6.v[3] = x.v[3]; x6.v[4] = x.v[4]; x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uvec4 x) { uvec6 x6;    x6.v[0] = x.x;    x6.v[1] = x.y;    x6.v[2] = x.z;    x6.v[3] = x.w;    x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uvec3 x) { uvec6 x6;    x6.v[0] = x.x;    x6.v[1] = x.y;    x6.v[2] = x.z;    x6.v[3] = uint(0);x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uvec2 x) { uvec6 x6;    x6.v[0] = x.x;    x6.v[1] = x.y;    x6.v[2] = uint(0);x6.v[3] = uint(0);x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uint  x) { uvec6 x6;    x6.v[0] = x;      x6.v[1] = uint(0);x6.v[2] = uint(0);x6.v[3] = uint(0);x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\n\n#define PRIME32_1\t2654435761U\n#define PRIME32_2\t2246822519U\n#define PRIME32_3\t3266489917U\n#define PRIME32_4\t668265263U\n#define PRIME32_5\t374761393U\n\nuint rotl32(uint x, int shift)\n{\n\treturn (x << shift) | (x >> (32 - shift));\n}\nvoid XXH32_InitV(inout uint v[4], uint seed)\n{\n    v[0] = seed + PRIME32_1 + PRIME32_2;\n    v[1] = seed + PRIME32_2;\n    v[2] = seed + uint(0);\n    v[3] = seed - PRIME32_1;\n}\nvoid XXH32_Inner(const uint p[4], inout uint v[4])\n{\n    v[0] += p[0] * PRIME32_2;\n    v[0] = rotl32(v[0], 13);\n    v[0] *= PRIME32_1;\n\n    v[1] += p[1] * PRIME32_2;\n    v[1] = rotl32(v[1], 13);\n    v[1] *= PRIME32_1;\n\n    v[2] += p[2] * PRIME32_2;\n    v[2] = rotl32(v[2], 13);\n    v[2] *= PRIME32_1;\n\n    v[3] += p[3] * PRIME32_2;\n    v[3] = rotl32(v[3], 13);\n    v[3] *= PRIME32_1;\n}\n\nuint XXHash32_32(uint input_s[8])\n{\n    uint h32;\n\tuint v[4];\n\n\tXXH32_InitV(v, uint(0));\n\n\tXXH32_Inner(uint[4](input_s[0], input_s[1], input_s[2], input_s[3]), v);\n    XXH32_Inner(uint[4](input_s[4], input_s[5], input_s[6], input_s[7]), v);\n\n    h32 = rotl32(v[0], 1) + rotl32(v[1], 7) + rotl32(v[2], 12) + rotl32(v[3], 18);\n\n    h32 += uint(32);\n\n    h32 ^= h32 >> 15;\n    h32 *= PRIME32_2;\n    h32 ^= h32 >> 13;\n    h32 *= PRIME32_3;\n    h32 ^= h32 >> 16;\n\n    return h32;\n}\n\nuint hash(uvec6 x, uint seed) \n{\n    uint inputs[8] = uint[8](x.v[0], x.v[1], x.v[2], x.v[3], x.v[4], x.v[5], uint(0), uint(seed));\n    \n    return XXHash32_32(inputs);\n}\nuint hash(uvec5 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uvec4 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uvec3 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uvec2 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uint x, uint seed)  { return hash(touvec6(x), seed);}\nuint hash(uvec6 x) \n{\n    uint inputs[8] = uint[8](x.v[0], x.v[1], x.v[2], x.v[3], x.v[4], x.v[5], uint(0), uint(0));\n    \n    return XXHash32_32(inputs);\n}\nuint hash(uvec5 x) { return hash(touvec6(x));}\nuint hash(uvec4 x) { return hash(touvec6(x));}\nuint hash(uvec3 x) { return hash(touvec6(x));}\nuint hash(uvec2 x) { return hash(touvec6(x));}\nuint hash(uint x)  { return hash(touvec6(x));}\n\nuint lzcnt(uint x)\n{\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    \n    uint c;\n    \n    x = x - ((x >> 1) & uint(0x55555555));                    \n    x = (x & uint(0x33333333)) + ((x >> 2) & uint(0x33333333));\n    c = ((x + (x >> 4) & uint(0xF0F0F0F)) * uint(0x1010101)) >> 24;\n\n    return uint(32) - c;\n}\n\n// random float that uses the full range from [0, 1)\n\nfloat floatrandhq(uvec6 x) \n{\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint mantissabits = uint(23);\n    const uint exponentbits = uint(8);\n    const uint hashbits     = uint(32);\n    const uint hashbitslg2  = uint(5);\n    uint current;\n    uint cnt;\n    uint pw2;    \n    // ceil((2^(ebits - 1) - 2) / 2^hashbits)\n    uint maxrec = (uint(1 << (exponentbits - uint(1))) - uint(2) + hashbits - uint(1)) >> hashbitslg2;\n    uint m;\n    uint i;\n    \n    current = hash(x, uint(0));\n    cnt = lzcnt(current);\n    pw2 = cnt;\n\n    for (i = uint(1); (i < maxrec) && (cnt == hashbits); i++)\n    {\n        current = hash(x, i +  uint(1));\n        cnt = lzcnt(current);\n        pw2 += cnt;\n    }\n    \n    // if less than 23 bits left, we need to generate a new hash to fill the mantissa\n    if ((int(hashbits) - int(cnt) - 1) < int(mantissabits))\n        current = hash(x, i +  uint(1));\n    \n    if (pw2 < uint(1 << (exponentbits - uint(1))) - uint(2))\n        m = (uint(1 << (exponentbits - uint(1))) - uint(2) - pw2) << mantissabits;\n    else // subnormal\n        m = uint(0);\n        \n    m |= ieeeMantissa & current;\n    \n    return uintBitsToFloat( m );\n}\n\nuvec5 floatBitsToUint2(vec5 v)\n{\n    uvec5 u;\n\n    u.v[0] = floatBitsToUint(v.v[0]);\n    u.v[1] = floatBitsToUint(v.v[1]);\n    u.v[2] = floatBitsToUint(v.v[2]);\n    u.v[3] = floatBitsToUint(v.v[3]);\n    u.v[4] = floatBitsToUint(v.v[4]);\n\n    return u;\n}\n\nfloat random( float x ) { return floatrandhq(touvec6(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatrandhq(touvec6(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatrandhq(touvec6(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatrandhq(touvec6(floatBitsToUint(v))); }\nfloat random( vec5  v ) { return floatrandhq(touvec6(floatBitsToUint2(v))); }\nfloat random( vec6  v ) \n{ \n    return floatrandhq(\n            uvec6(uint[6](\n                floatBitsToUint(v.v[0]),\n                floatBitsToUint(v.v[1]),\n                floatBitsToUint(v.v[2]),\n                floatBitsToUint(v.v[3]),\n                floatBitsToUint(v.v[4]),\n                floatBitsToUint(v.v[5])\n                ))\n        );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h_scale = H_SCALE;\n#if MODE_LOGARITHMIC\n    int axis_count = LOGARITHMIC_AXIS_DIRECTIONS;\n    int steps = int(min(ceil(LOGARITHMIC_MAX_STEPS(2.0*max(iResolution.x, iResolution.y))), float(LINEAR_STEPS)));\n#else\n    int axis_count = LINEAR_AXIS_DIRECTIONS;\n    int steps = LINEAR_STEPS;\n#endif\n    vec2 initial_pos = fragCoord.xy;\n    float h_initial;\n    float total_fov = 0.0;\n    float dist_scale = 1.0 / sin(3.141592653 / float(axis_count));\n    int base_frame;\n    int actual_frame;\n    \n    fragColor = vec4(0.0);\n    \n    ivec2 offset = ivec2(0, 0);\n\n#if ACCUMULATE\n    offset.x = int(hash(uint(iFrame/1)) & uint(0x7FFFFFFF));\n    offset.y = int(hash(hash(uint(iFrame/1)) & uint(0x7FFFFFFF)) & uint(0x7FFFFFFF));\n#endif\n    h_initial = texture(iChannel0, (initial_pos)/iResolution.xy).x * h_scale;\n    base_frame = floatBitsToInt(texelFetch(iChannel0, ivec2(0), 0).z);\n    \n    actual_frame = (iFrame-base_frame) / ACCUMULATE_STEP_SPACING;\n    \n// this makes the following loop VERY slow\n#if RANDOMISED_DIRECTIONS\n    float angle_noise = texelFetch(iChannel1, (ivec2(fragCoord) + offset) % ivec2(iChannelResolution[1].xy), 0).x; // slow, great quality\n    // float angle_noise = float(int(hash(uvec3(iFrame,fragCoord.xy)) & uint(0x7FFFFFFF)) % 1024)/1024.0; // slow, good quality\n    // float angle_noise = float(int(hash(uint(iFrame)) & uint(0x7FFFFFFF)) % 1024)/1024.0; // fast, garbage quality\n#else\n   float angle_noise = 0.0;\n#endif\n\n#if ACCUMULATE\n    if ((actual_frame > MAX_ACCUMULATE_STEPS && (INFINITE_ACCUMULATE == 0)) || (((iFrame-base_frame)%ACCUMULATE_STEP_SPACING) != 0))\n    {\n        fragColor = texture(iChannel2, (initial_pos)/iResolution.xy);\n        return;\n    }\n#endif\n    \n    if ((ACCUMULATE==0) || (((iFrame-base_frame)%ACCUMULATE_STEP_SPACING) == 0) || (INFINITE_ACCUMULATE != 0))\n    for (int i = 0; i < axis_count; i++)\n    {\n        vec2 dir;\n        float maxslope = 0.0;\n        \n        dir.x = sin(2.0 * 3.141592653 * ((float(i) + angle_noise)/float(axis_count)));\n        dir.y = cos(2.0 * 3.141592653 * ((float(i) + angle_noise)/float(axis_count)));\n        \n        for (int j = 1; j < steps; j++)\n        {\n            vec2 pos;\n            float h_current;\n            float width;\n            float dist = float(j);\n            \n#if MODE_LOGARITHMIC\n            dist = LOGARITHMIC_DIST(j);\n            width = LOGARITHMIC_RADIUS(j) * 2.0;\n#else\n            width = 1.0;\n#endif\n            pos.x = initial_pos.x + dir.x*dist;\n            pos.y = initial_pos.y + dir.y*dist;\n            \n            h_current = textureLod(iChannel0, (pos)/iResolution.xy, log2(width)).x * h_scale;\n            \n            maxslope = max(maxslope, (h_current - h_initial) / dist);\n        }\n        total_fov += 1.0 - maxslope / sqrt(maxslope*maxslope + 1.0);\n    }\n    total_fov /= float(axis_count);\n \n    fragColor.x = h_initial;\n#if ACCUMULATE\n    fragColor.y = float(actual_frame) * texelFetch(iChannel2, ivec2(fragCoord.xy), 0).y / float(actual_frame + 1) + total_fov / float(actual_frame + 1);\n#else\n    fragColor.y = total_fov;\n#endif\n    fragColor.z = texelFetch(iChannel1, ivec2(fragCoord) % ivec2(iChannelResolution[1].xy), 0).x;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 centre = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 accum = centre;\n    float weight;\n    \n#if BILATERAL_FILTER\n#if SIMPLE_BILATERAL_FILTER\n    weight = 0.0;\n    accum.y = 0.0;\n    // box filter\n    for (int y = -BILATERAL_FILTER_HWIDTH; y <= BILATERAL_FILTER_HWIDTH; y++)\n        for (int x = -BILATERAL_FILTER_HWIDTH; x <= BILATERAL_FILTER_HWIDTH; x++)\n        {\n            ivec2 coord = (ivec2(fragCoord) + ivec2(x, y)) % ivec2(iResolution.xy);\n            float local_weight;\n            if (coord.x < 0)\n                coord.x += int(iResolution.x);\n            if (coord.y < 0)\n                coord.y += int(iResolution.x);\n            coord %= ivec2(iResolution.xy);\n            vec4 p = texelFetch(iChannel0, coord, 0);\n            \n            local_weight = pow(1.0 - abs(p.y - centre.y), 4.0);\n            \n            accum.y += local_weight * p.y;\n            weight += local_weight;\n        }\n#else\n    weight = 0.0;\n    accum.y = 0.0;\n    // gaussian filter\n    for (int y = -BILATERAL_FILTER_HWIDTH; y <= BILATERAL_FILTER_HWIDTH; y++)\n        for (int x = -BILATERAL_FILTER_HWIDTH; x <= BILATERAL_FILTER_HWIDTH; x++)\n        {\n            ivec2 coord = (ivec2(fragCoord) + ivec2(x, y)) % ivec2(iResolution.xy);\n            float local_weight;\n            if (coord.x < 0)\n                coord.x += int(iResolution.x);\n            if (coord.y < 0)\n                coord.y += int(iResolution.x);\n            coord %= ivec2(iResolution.xy);\n            vec4 p = texelFetch(iChannel0, coord, 0);\n            \n            float c = exp(-0.5 * pow((length(vec2(x,y))) / PLANAR_DISTANCE_SIGMA, 2.0));\n            float s = exp(-0.5 * pow((abs(p.y - centre.y)) / LUMINANCE_SIGMA, 2.0));\n            \n            local_weight = c*s;\n            \n            accum.y += local_weight * p.y;\n            weight += local_weight;\n        }\n#endif\n#else\n    weight = 1.0;\n#endif\n    fragColor = accum;\n    fragColor.y = accum.y / weight;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define SQUARE_WIDTH 64.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h_scale = H_SCALE;\n    \n    // Needed to get accurate float values in mipmaps\n    // texture\n    fragColor = texture(iChannel0, ZOOM_FACTOR * fragCoord.xy/iResolution.xy);\n    fragColor.z = texelFetch(iChannel1, ivec2(0), 0).z;\n    \n    if (iMouse.z > 0.0)\n        fragColor.z = intBitsToFloat(iFrame);\n        \n    return;\n    \n    // sphere and raised plane\n    fragColor.x = (1.0 - min(length(iResolution.xy/2.0 - fragCoord)/128.0, 1.0));\n    if (fragCoord.x < iResolution.x/2.0)\n        fragColor.x += 0.0;\n    else\n        fragColor.x = max(fragColor.x, 0.25);\n        \n    return;\n    \n    // square\n    vec2 off = abs(fragCoord.xy - iResolution.xy/2.0);\n    if ((off.x < SQUARE_WIDTH) && (off.y < SQUARE_WIDTH))\n        fragColor.x = H_SCALE;\n    else\n        fragColor.x = 0.0;\n        \n    return;\n    \n    // sine wave\n    off = vec2(0.0, iResolution.y/2.0 + 32.0*sin(fragCoord.x / 32.0));\n    vec2 diff = abs(fragCoord.xy - off);\n    if ((diff.y < 32.0) && (diff.x > 64.0) && (diff.x < iResolution.x - 64.0))\n        fragColor.x = H_SCALE;\n    else\n        fragColor.x = 0.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define INFINITE_ACCUMULATE 1                // just accumulate forever\n#define LUMINANCE_SIGMA 0.25                 // fall-off rate for gaussian in luminance\n#define PLANAR_DISTANCE_SIGMA 3.0            // fall-off rate for gaussian in distance\n#define ZOOM_FACTOR 0.25                     // how much to zoom in on the texture\n#define SIMPLE_BILATERAL_FILTER 0            // use a simple box-filter\n#define BILATERAL_FILTER_HWIDTH 8            // half-width of bilateral filter\n#define MAX_ACCUMULATE_STEPS 8               // maximum frames to accumulate\n#define ACCUMULATE_STEP_SPACING 15           // frames between updating accumulation\n#define BILATERAL_FILTER 1                   // blur the result with a bilateral filter\n#define ACCUMULATE 1                         // set to 0 to perform computation in a single-pass\n#define MODE_LOGARITHMIC 0                   // set to 1 to perform variable-size steps in the tracer\n#define LINEAR_AXIS_DIRECTIONS 4             // number of axis directions to trace per frame, must be >4 for logarithmic mode\n#define LOGARITHMIC_AXIS_DIRECTIONS 64       // number of axis directions to trace per frame, must be >4 for logarithmic mode\n#define LINEAR_STEPS 256                     // steps that the linear solver performs on each ray\n#define H_SCALE 128.0                        // vertical scale\n#define RANDOMISED_DIRECTIONS 1              // set to 0 to use fixed ray directions every frame. This MUST be set to 1 if ACCUMULATE != 0\n\n#define LOG2 log2\n#define LOGARITHMIC_STEP_ANGLE ((360.0 / float(LOGARITHMIC_AXIS_DIRECTIONS)) * 0.01745329251994329576923690768489)\n#define LOGARITHMIC_MAX_STEPS(width) (1.0 + log2(float(width)) / log2((1.0 + sin(LOGARITHMIC_STEP_ANGLE)) / (1.0 - sin(LOGARITHMIC_STEP_ANGLE))))\n#define LOGARITHMIC_DIST(n) pow(((1.0 + sin(LOGARITHMIC_STEP_ANGLE)) / (1.0 - sin(LOGARITHMIC_STEP_ANGLE))), float(n) - 1.0)\n#define LOGARITHMIC_RADIUS(n) (LOGARITHMIC_DIST(n) * sin(LOGARITHMIC_STEP_ANGLE))\n\n// high-quality hash, modified version of old version of XXHash32 from https://github.com/Cyan4973/xxHash (BSD license)\n\nstruct vec5\n{\n\tfloat v[5];\n};\nstruct uvec5\n{\n\tuint v[5];\n};\nstruct vec6\n{\n\tfloat v[6];\n};\nstruct uvec6\n{\n\tuint v[6];\n};\n\nuvec6 touvec6(uvec5 x) { uvec6 x6;    x6.v[0] = x.v[0]; x6.v[1] = x.v[1]; x6.v[2] = x.v[2]; x6.v[3] = x.v[3]; x6.v[4] = x.v[4]; x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uvec4 x) { uvec6 x6;    x6.v[0] = x.x;    x6.v[1] = x.y;    x6.v[2] = x.z;    x6.v[3] = x.w;    x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uvec3 x) { uvec6 x6;    x6.v[0] = x.x;    x6.v[1] = x.y;    x6.v[2] = x.z;    x6.v[3] = uint(0);x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uvec2 x) { uvec6 x6;    x6.v[0] = x.x;    x6.v[1] = x.y;    x6.v[2] = uint(0);x6.v[3] = uint(0);x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uint  x) { uvec6 x6;    x6.v[0] = x;      x6.v[1] = uint(0);x6.v[2] = uint(0);x6.v[3] = uint(0);x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\n\n#define PRIME32_1\t2654435761U\n#define PRIME32_2\t2246822519U\n#define PRIME32_3\t3266489917U\n#define PRIME32_4\t668265263U\n#define PRIME32_5\t374761393U\n\nuint rotl32(uint x, int shift)\n{\n\treturn (x << shift) | (x >> (32 - shift));\n}\nvoid XXH32_InitV(inout uint v[4], uint seed)\n{\n    v[0] = seed + PRIME32_1 + PRIME32_2;\n    v[1] = seed + PRIME32_2;\n    v[2] = seed + uint(0);\n    v[3] = seed - PRIME32_1;\n}\nvoid XXH32_Inner(const uint p[4], inout uint v[4])\n{\n    v[0] += p[0] * PRIME32_2;\n    v[0] = rotl32(v[0], 13);\n    v[0] *= PRIME32_1;\n\n    v[1] += p[1] * PRIME32_2;\n    v[1] = rotl32(v[1], 13);\n    v[1] *= PRIME32_1;\n\n    v[2] += p[2] * PRIME32_2;\n    v[2] = rotl32(v[2], 13);\n    v[2] *= PRIME32_1;\n\n    v[3] += p[3] * PRIME32_2;\n    v[3] = rotl32(v[3], 13);\n    v[3] *= PRIME32_1;\n}\n\nuint XXHash32_32(uint input_s[8])\n{\n    uint h32;\n\tuint v[4];\n\n\tXXH32_InitV(v, uint(0));\n\n\tXXH32_Inner(uint[4](input_s[0], input_s[1], input_s[2], input_s[3]), v);\n    XXH32_Inner(uint[4](input_s[4], input_s[5], input_s[6], input_s[7]), v);\n\n    h32 = rotl32(v[0], 1) + rotl32(v[1], 7) + rotl32(v[2], 12) + rotl32(v[3], 18);\n\n    h32 += uint(32);\n\n    h32 ^= h32 >> 15;\n    h32 *= PRIME32_2;\n    h32 ^= h32 >> 13;\n    h32 *= PRIME32_3;\n    h32 ^= h32 >> 16;\n\n    return h32;\n}\n\nuint hash(uvec6 x, uint seed) \n{\n    uint inputs[8] = uint[8](x.v[0], x.v[1], x.v[2], x.v[3], x.v[4], x.v[5], uint(0), uint(seed));\n    \n    return XXHash32_32(inputs);\n}\nuint hash(uvec5 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uvec4 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uvec3 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uvec2 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uint x, uint seed)  { return hash(touvec6(x), seed);}\nuint hash(uvec6 x) \n{\n    uint inputs[8] = uint[8](x.v[0], x.v[1], x.v[2], x.v[3], x.v[4], x.v[5], uint(0), uint(0));\n    \n    return XXHash32_32(inputs);\n}\nuint hash(uvec5 x) { return hash(touvec6(x));}\nuint hash(uvec4 x) { return hash(touvec6(x));}\nuint hash(uvec3 x) { return hash(touvec6(x));}\nuint hash(uvec2 x) { return hash(touvec6(x));}\nuint hash(uint x)  { return hash(touvec6(x));}\n\nuint lzcnt(uint x)\n{\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    \n    uint c;\n    \n    x = x - ((x >> 1) & uint(0x55555555));                    \n    x = (x & uint(0x33333333)) + ((x >> 2) & uint(0x33333333));\n    c = ((x + (x >> 4) & uint(0xF0F0F0F)) * uint(0x1010101)) >> 24;\n\n    return uint(32) - c;\n}\n\n// random float that uses the full range from [0, 1)\n\nfloat floatrandhq(uvec6 x) \n{\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint mantissabits = uint(23);\n    const uint exponentbits = uint(8);\n    const uint hashbits     = uint(32);\n    const uint hashbitslg2  = uint(5);\n    uint current;\n    uint cnt;\n    uint pw2;    \n    // ceil((2^(ebits - 1) - 2) / 2^hashbits)\n    uint maxrec = (uint(1 << (exponentbits - uint(1))) - uint(2) + hashbits - uint(1)) >> hashbitslg2;\n    uint m;\n    uint i;\n    \n    current = hash(x, uint(0));\n    cnt = lzcnt(current);\n    pw2 = cnt;\n\n    for (i = uint(1); (i < maxrec) && (cnt == hashbits); i++)\n    {\n        current = hash(x, i +  uint(1));\n        cnt = lzcnt(current);\n        pw2 += cnt;\n    }\n    \n    // if less than 23 bits left, we need to generate a new hash to fill the mantissa\n    if ((int(hashbits) - int(cnt) - 1) < int(mantissabits))\n        current = hash(x, i +  uint(1));\n    \n    if (pw2 < uint(1 << (exponentbits - uint(1))) - uint(2))\n        m = (uint(1 << (exponentbits - uint(1))) - uint(2) - pw2) << mantissabits;\n    else // subnormal\n        m = uint(0);\n        \n    m |= ieeeMantissa & current;\n    \n    return uintBitsToFloat( m );\n}\n\nuvec5 floatBitsToUint2(vec5 v)\n{\n    uvec5 u;\n\n    u.v[0] = floatBitsToUint(v.v[0]);\n    u.v[1] = floatBitsToUint(v.v[1]);\n    u.v[2] = floatBitsToUint(v.v[2]);\n    u.v[3] = floatBitsToUint(v.v[3]);\n    u.v[4] = floatBitsToUint(v.v[4]);\n\n    return u;\n}\n\nfloat random( float x ) { return floatrandhq(touvec6(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatrandhq(touvec6(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatrandhq(touvec6(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatrandhq(touvec6(floatBitsToUint(v))); }\nfloat random( vec5  v ) { return floatrandhq(touvec6(floatBitsToUint2(v))); }\nfloat random( vec6  v ) \n{ \n    return floatrandhq(\n            uvec6(uint[6](\n                floatBitsToUint(v.v[0]),\n                floatBitsToUint(v.v[1]),\n                floatBitsToUint(v.v[2]),\n                floatBitsToUint(v.v[3]),\n                floatBitsToUint(v.v[4]),\n                floatBitsToUint(v.v[5])\n                ))\n        );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h_scale = H_SCALE;\n#if MODE_LOGARITHMIC\n    int axis_count = LOGARITHMIC_AXIS_DIRECTIONS;\n    int steps = int(min(ceil(LOGARITHMIC_MAX_STEPS(2.0*max(iResolution.x, iResolution.y))), float(LINEAR_STEPS)));\n#else\n    int axis_count = LINEAR_AXIS_DIRECTIONS;\n    int steps = LINEAR_STEPS;\n#endif\n    vec2 initial_pos = fragCoord.xy;\n    float h_initial;\n    float total_fov = 0.0;\n    float dist_scale = 1.0 / sin(3.141592653 / float(axis_count));\n    int base_frame;\n    int actual_frame;\n    \n    fragColor = vec4(0.0);\n    \n    ivec2 offset = ivec2(0, 0);\n\n#if ACCUMULATE\n    offset.x = int(hash(uint(iFrame/1)) & uint(0x7FFFFFFF));\n    offset.y = int(hash(hash(uint(iFrame/1)) & uint(0x7FFFFFFF)) & uint(0x7FFFFFFF));\n#endif\n    h_initial = texture(iChannel0, (initial_pos)/iResolution.xy).x * h_scale;\n    base_frame = floatBitsToInt(texelFetch(iChannel0, ivec2(0), 0).z);\n    \n    actual_frame = (iFrame-base_frame) / ACCUMULATE_STEP_SPACING;\n    \n// this makes the following loop VERY slow\n#if RANDOMISED_DIRECTIONS\n    float angle_noise = texelFetch(iChannel1, (ivec2(fragCoord) + offset) % ivec2(iChannelResolution[1].xy), 0).x; // slow, great quality\n    // float angle_noise = float(int(hash(uvec3(iFrame,fragCoord.xy)) & uint(0x7FFFFFFF)) % 1024)/1024.0; // slow, good quality\n    // float angle_noise = float(int(hash(uint(iFrame)) & uint(0x7FFFFFFF)) % 1024)/1024.0; // fast, garbage quality\n#else\n   float angle_noise = 0.0;\n#endif\n\n#if ACCUMULATE\n    if ((actual_frame > MAX_ACCUMULATE_STEPS && (INFINITE_ACCUMULATE == 0)) || (((iFrame-base_frame)%ACCUMULATE_STEP_SPACING) != 0))\n    {\n        fragColor = texture(iChannel2, (initial_pos)/iResolution.xy);\n        return;\n    }\n#endif\n    \n    if ((ACCUMULATE==0) || (((iFrame-base_frame)%ACCUMULATE_STEP_SPACING) == 0) || (INFINITE_ACCUMULATE != 0))\n    for (int i = 0; i < axis_count; i++)\n    {\n        vec2 dir;\n        float maxslope = 0.0;\n        \n        dir.x = sin(2.0 * 3.141592653 * ((float(i) + angle_noise)/float(axis_count)));\n        dir.y = cos(2.0 * 3.141592653 * ((float(i) + angle_noise)/float(axis_count)));\n        \n        for (int j = 1; j < steps; j++)\n        {\n            vec2 pos;\n            float h_current;\n            float width;\n            float dist = float(j);\n            \n#if MODE_LOGARITHMIC\n            dist = LOGARITHMIC_DIST(j);\n            width = LOGARITHMIC_RADIUS(j) * 2.0;\n#else\n            width = 1.0;\n#endif\n            pos.x = initial_pos.x + dir.x*dist;\n            pos.y = initial_pos.y + dir.y*dist;\n            \n            h_current = textureLod(iChannel0, (pos)/iResolution.xy, log2(width)).x * h_scale;\n            \n            maxslope = max(maxslope, (h_current - h_initial) / dist);\n        }\n        total_fov += 1.0 - maxslope / sqrt(maxslope*maxslope + 1.0);\n    }\n    total_fov /= float(axis_count);\n \n    fragColor.x = h_initial;\n#if ACCUMULATE\n    fragColor.y = float(actual_frame) * texelFetch(iChannel2, ivec2(fragCoord.xy), 0).y / float(actual_frame + 1) + total_fov / float(actual_frame + 1);\n#else\n    fragColor.y = total_fov;\n#endif\n    fragColor.z = texelFetch(iChannel1, ivec2(fragCoord) % ivec2(iChannelResolution[1].xy), 0).x;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 centre = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 accum = centre;\n    float weight;\n    \n#if BILATERAL_FILTER\n#if SIMPLE_BILATERAL_FILTER\n    weight = 0.0;\n    accum.y = 0.0;\n    // box filter\n    for (int y = -BILATERAL_FILTER_HWIDTH; y <= BILATERAL_FILTER_HWIDTH; y++)\n        for (int x = -BILATERAL_FILTER_HWIDTH; x <= BILATERAL_FILTER_HWIDTH; x++)\n        {\n            ivec2 coord = (ivec2(fragCoord) + ivec2(x, y)) % ivec2(iResolution.xy);\n            float local_weight;\n            if (coord.x < 0)\n                coord.x += int(iResolution.x);\n            if (coord.y < 0)\n                coord.y += int(iResolution.x);\n            coord %= ivec2(iResolution.xy);\n            vec4 p = texelFetch(iChannel0, coord, 0);\n            \n            local_weight = pow(1.0 - abs(p.y - centre.y), 4.0);\n            \n            accum.y += local_weight * p.y;\n            weight += local_weight;\n        }\n#else\n    weight = 0.0;\n    accum.y = 0.0;\n    // gaussian filter\n    for (int y = -BILATERAL_FILTER_HWIDTH; y <= BILATERAL_FILTER_HWIDTH; y++)\n        for (int x = -BILATERAL_FILTER_HWIDTH; x <= BILATERAL_FILTER_HWIDTH; x++)\n        {\n            ivec2 coord = (ivec2(fragCoord) + ivec2(x, y)) % ivec2(iResolution.xy);\n            float local_weight;\n            if (coord.x < 0)\n                coord.x += int(iResolution.x);\n            if (coord.y < 0)\n                coord.y += int(iResolution.x);\n            coord %= ivec2(iResolution.xy);\n            vec4 p = texelFetch(iChannel0, coord, 0);\n            \n            float c = exp(-0.5 * pow((length(vec2(x,y))) / PLANAR_DISTANCE_SIGMA, 2.0));\n            float s = exp(-0.5 * pow((abs(p.y - centre.y)) / LUMINANCE_SIGMA, 2.0));\n            \n            local_weight = c*s;\n            \n            accum.y += local_weight * p.y;\n            weight += local_weight;\n        }\n#endif\n#else\n    weight = 1.0;\n#endif\n    fragColor = accum;\n    fragColor.y = accum.y / weight;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}