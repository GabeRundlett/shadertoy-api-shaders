{
    "Shader": {
        "info": {
            "date": "1659443883",
            "description": "CC0: Time for some inner reflections\nAn evolution of: https://www.shadertoy.com/view/7dKBDt\nAfter a tip from shane found knighty's shader: https://www.shadertoy.com/view/MsKGzw\nKnighty's shaders allows one to experiment with many cool polyhedras\n",
            "flags": 0,
            "hasliked": 0,
            "id": "sl3yRM",
            "likes": 48,
            "name": "Time for some inner reflections",
            "published": 3,
            "tags": [
                "3d",
                "reflections"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 663
        },
        "renderpass": [
            {
                "code": "// CC0: Time for some inner reflections\n// An evolution of: https://www.shadertoy.com/view/7dKBDt\n// After a tip from shane found knighty's shader: https://www.shadertoy.com/view/MsKGzw\n// Knighty's shaders allows one to experiment with many cool polyhedras\n\n// Original inspiration from:https://www.youtube.com/watch?v=qNoQXF2dKBs\n\n// ------------------------------------------------------------------------------------\n// Here are some parameters to experiment with\n\n#define INNER_SPHERE\n//#define GOT_BEER\n\nconst float poly_U        = 1.0;  // [0, inf]\nconst float poly_V        = 1.0;  // [0, inf]\nconst float poly_W        = 2.0;  // [0, inf]\nconst int   poly_type     = 3;    // [2, 5]\n\nconst float zoom = 3.0;\n// ------------------------------------------------------------------------------------\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  20.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.001\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define MAX_BOUNCES     6\n\n// License: Unknown, author: knighty, found: https://www.shadertoy.com/view/MsKGzw\nconst float poly_cospin   = cos(PI/float(poly_type));\nconst float poly_scospin  = sqrt(0.75-poly_cospin*poly_cospin);\nconst vec3  poly_nc       = vec3(-0.5, -poly_cospin, poly_scospin);\nconst vec3  poly_pab      = vec3(0., 0., 1.);\nconst vec3  poly_pbc_     = vec3(poly_scospin, 0., 0.5);\nconst vec3  poly_pca_     = vec3(0., poly_scospin, poly_cospin);\nconst vec3  poly_p        = normalize((poly_U*poly_pab+poly_V*poly_pbc_+poly_W*poly_pca_));\nconst vec3  poly_pbc      = normalize(poly_pbc_);\nconst vec3  poly_pca      = normalize(poly_pca_);\n\nconst float initt = 0.125; \n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: Unknown, author: knighty, found: https://www.shadertoy.com/view/MsKGzw\nvoid poly_fold(inout vec3 pos) {\n  vec3 p = pos;\n\n  for(int i = 0; i < poly_type; ++i){\n    p.xy  = abs(p.xy);\n    p    -= 2.*min(0., dot(p,poly_nc)) * poly_nc;\n  }\n  \n  pos = p;\n}\n\nfloat poly_plane(vec3 pos) {\n  float d0 = dot(pos, poly_pab);\n  float d1 = dot(pos, poly_pbc);\n  float d2 = dot(pos, poly_pca);\n  float d = d0;\n  d = max(d, d1);\n  d = max(d, d2);\n  return d;\n}\n\nfloat poly_corner(vec3 pos) {\n  float d = length(pos) - .1;\n  return d;\n}\n\nfloat dot2(vec3 p) {\n  return dot(p, p);\n}\n\nfloat poly_edge(vec3 pos) {\n  float dla = dot2(pos-min(0., pos.x)*vec3(1., 0., 0.));\n  float dlb = dot2(pos-min(0., pos.y)*vec3(0., 1., 0.));\n  float dlc = dot2(pos-min(0., dot(pos, poly_nc))*poly_nc);\n  return sqrt(min(min(dla, dlb), dlc))-0.025;\n}\n\nfloat poly_planes(vec3 pos, out vec3 pp) {\n  poly_fold(pos);\n  pos -= poly_p;\n\n  pp = pos;\n  return poly_plane(pos);\n}\n\nfloat poly_edges(vec3 pos, out vec3 pp) {\n  poly_fold(pos);\n  pos -= poly_p;\n\n  pp = pos;\n  return poly_edge(pos);\n}\n\n\nfloat blobs(vec2 p) {\n  // Generates a grid of dots\n  vec2 bp = p;\n  vec2 bn = mod2(bp, vec2(3.0));\n\n  vec2 dp = p;\n  vec2 dn = mod2(dp, vec2(0.25));\n  float ddots = length(dp);\n  \n  // Blobs\n  float dblobs = 1E6;\n  for (int i = 0; i < 5; ++i) {\n    float dd = circle(bp-1.0*vec2(sin(TIME+float(i)), sin(float(i*i)+TIME*sqrt(0.5))), 0.1);\n    dblobs = pmin(dblobs, dd, 0.35);\n  }\n\n  float d = 1E6;\n  d = min(d, ddots);\n  // Smooth min between blobs and dots makes it look somewhat amoeba like\n  d = pmin(d, dblobs, 0.35);\n  return d;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 gcol = HSV2RGB(vec3(0.45, 0.6, 1.0));\n  vec3 col = clamp(vec3(0.0025/abs(rd.y))*gcol, 0.0, 1.0);\n  \n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n  if (tp > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    const float fz = 0.25;\n    const float bz = 1.0/fz;\n    vec2 bpos = pos.xz/bz;\n    float db = blobs(bpos)*bz;\n    db = abs(db);\n    vec2 pp = pos.xz*fz;\n    float m = 0.5+0.25*(sin(3.0*pp.x+TIME*2.1)+sin(3.3*pp.y+TIME*2.0));\n    m *= m;\n    m *= m;\n    pp = fract(pp+0.5)-0.5;\n    float dp = pmin(abs(pp.x), abs(pp.y), 0.125);\n    dp = min(dp, db);\n    vec3 hsv = vec3(0.4+mix(0.15,0.0, m), tanh_approx(mix(50.0, 10.0, m)*dp), 1.0);\n    vec3 pcol = 1.5*hsv2rgb(hsv)*exp(-mix(30.0, 10.0, m)*dp);\n    \n    float f = 1.0-tanh_approx(0.1*length(pos.xz));\n    col = mix(col, pcol , f);\n  }\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(6.0, 9.0))-1.0;\n    \n    col += vec3(2.0)*gcol*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*gcol*exp(-0.5*max(db, 0.0));\n  }\n\n\n  return col;\n}\n\nfloat dfExclusion(vec3 p, out vec3 pp) {\n  return -poly_edges(p/zoom, pp)*zoom;\n}\n\nfloat shape(vec3 p) {\n  vec3 pp;\n  return poly_planes(p/zoom, pp)*zoom;\n}\n\nfloat df0(vec3 p) {\n  float d0 = shape(p);\n  float d = d0;\n  return d;\n}\n\nfloat df1(vec3 p) {\n  float d0 = -shape(p);\n  float d = d0;\n#if defined(INNER_SPHERE)\n  float d1 = length(p) - 2.;\n  d = min(d, d1);\n#endif\n  return d;\n}\n\nvec3 normal1(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df1(pos+eps.xyy) - df1(pos-eps.xyy);\n  nor.y = df1(pos+eps.yxy) - df1(pos-eps.yxy);\n  nor.z = df1(pos+eps.yyx) - df1(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch1(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  for (int i = 0; i < MAX_RAY_MARCHES; i++) {\n    if (t > MAX_RAY_LENGTH) {\n      t = MAX_RAY_LENGTH;    \n      break;\n    }\n    float d = df1(ro + rd*t);\n    if (d < TOLERANCE) {\n      break;\n    }\n    t  += d;\n  }\n  return t;\n}\n\nvec3 normal0(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df0(pos+eps.xyy) - df0(pos-eps.xyy);\n  nor.y = df0(pos+eps.yxy) - df0(pos-eps.yxy);\n  nor.z = df0(pos+eps.yyx) - df0(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch0(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  for (int i = 0; i < MAX_RAY_MARCHES; i++) {\n    if (t > MAX_RAY_LENGTH) {\n      t = MAX_RAY_LENGTH;    \n      break;\n    }\n    float d = df0(ro + rd*t);\n    if (d < TOLERANCE) {\n      break;\n    }\n    t  += d;\n  }\n  return t;\n}\n\nvec3 render1(vec3 ro, vec3 rd) {\n  vec3 agg = vec3(0.0, 0.0, 0.0);\n  float tagg = initt;\n  vec3 ragg = vec3(1.0);\n\n  for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce) {\n    float mragg = max(max(ragg.x, ragg.y), ragg.z);\n    if (mragg < 0.1) break;\n    float st = rayMarch1(ro, rd);\n    tagg += st;\n    vec3 sp = ro+rd*st;\n    vec3 spp;\n    float de = dfExclusion(sp, spp);\n    vec3 sn = normal1(sp);\n    \n    float si = cos(5.0*TAU*zoom*spp.z-0.5*sp.y+TIME);\n    const vec3 lcol = vec3(1.0, 1.5, 2.0)*0.8;\n    float lf = mix(0.0, 1.0, smoothstep(0., 0.9, si));\n    \n    vec3 gcol = ragg*lcol*exp(8.0*(min(de-0.2, 0.0)));\n    // Will never miss\n    if (de < 0.0) {\n      agg += gcol;\n      ragg *= vec3(0.5, 0.6,0.8);\n    } else {\n      agg += gcol*lf;\n      agg += ragg*lcol*1.5*lf;\n      ragg = vec3(0.0);\n    }\n    \n    rd = reflect(rd, sn);\n    ro = sp+initt*rd;\n    tagg += initt;\n  }\n#if defined(GOT_BEER)\n  return agg*exp(-.5*vec3(0.3, 0.15, 0.1)*tagg);\n#else  \n  return agg;\n#endif\n}\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 skyCol = skyColor(ro, rd);\n\n  vec3 col = skyCol;\n\n  float st = rayMarch0(ro, rd);\n  vec3 sp = ro+rd*st;\n  vec3 sn = normal0(sp);\n    vec3 spp;\n  float de = dfExclusion(sp, spp);\n  float ptime = mod(TIME, 30.0);\n  if (st < MAX_RAY_LENGTH) {\n    float sfre = 1.0+dot(rd, sn);\n    sfre *= sfre;\n    sfre = mix(0.1, 1.0, sfre); \n    vec3 sref   = reflect(rd, sn);\n    vec3 srefr  = refract(rd, sn, 0.9);\n    vec3 ssky = sfre*skyColor(sp, sref);\n\n    if (de > 0.0) {\n      col = ssky;\n    } else {\n      col = 0.5*sfre*ssky;\n      vec3 col1 = (1.0-sfre)*render1(sp+srefr*initt, srefr);\n      col += col1;\n    }\n    \n  }\n\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  vec3 ro = 0.8*vec3(0.0, 4.0, 5.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n  float a = 0.5*(-0.5+0.5*sin(0.123*TIME));\n  float b = 0.1*TIME;\n  if (iMouse.x > 0.0) {\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    // Get angle from mouse position\n    a =-2.0*m.y;\n    b =-2.0*m.x;\n  }\n  ro.yz *= ROT(a);\n  ro.xz *= ROT(b);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  float fov = tan(TAU/6.0);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render0(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = aces_approx(col); \n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}