{
    "Shader": {
        "info": {
            "date": "1634401326",
            "description": "I know its not perfect, but I had fun mainking, still learing Shadertoy and all it's functions.",
            "flags": 0,
            "hasliked": 0,
            "id": "ssGXzw",
            "likes": 2,
            "name": "Buityfull Triangle",
            "published": 3,
            "tags": [
                "triangle",
                "color",
                "buityfull"
            ],
            "usePreview": 0,
            "username": "MrNissenDK",
            "viewed": 247
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //debug = true;\n    uv =  ((fragCoord - .5 * iResolution.xy) / (iResolution.y/res)); //within Common\n    pixelSize = res / iResolution.x; //within Common\n\n    float TriAngle = TAU / 3.;\n    float TriAngle1 = iTime + TriAngle * 1.;\n    float TriAngle2 = iTime + TriAngle * 2.;\n    float TriAngle3 = iTime + TriAngle * 3.;\n    \n    vec2 p1 = vec2(sin(TriAngle1), cos(TriAngle1));\n    vec2 p2 = vec2(sin(TriAngle2), cos(TriAngle2));\n    vec2 p3 = vec2(sin(TriAngle3), cos(TriAngle3));\n    \n    vec3 col1 = vec3(cos(uv),sin(TriAngle1));\n    vec3 col2 = vec3(cos(uv),sin(TriAngle2));\n    vec3 col3 = vec3(cos(uv),sin(TriAngle3));\n    \n    //point(p1, col1);\n    //point(p2, col2);\n    //point(p3, col3);\n    \n    line(p1, p2, col1, col2);\n    line(p2, p3, col2, col3);\n    line(p3, p1, col3, col1);\n    \n    DebugLines();\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float PI = 3.14159265359;\nfloat TAU = 6.28318530718;\nvec2 uv;\nvec3 col = vec3(0);\n\nbool debug = false;\n\nfloat debugLineSize = 2.;\nfloat pointSize = 5.;\nfloat pixelSize;\n\nfloat res = 3.;\n\nvoid DebugLines(){\n    vec2 cv = fract(uv);\n    if(\n        debug\n    &&  (\n                cv.x / pixelSize < debugLineSize / 2.\n        || (1.- cv.x)/ pixelSize < debugLineSize / 2.\n        ||      cv.y / pixelSize < debugLineSize / 2.\n        || (1.- cv.y)/ pixelSize < debugLineSize / 2.\n        )\n    ) col = 1. - col;\n}\n\nvoid cirkle(vec2 pos, float size, vec3 color){\n    col += smoothstep(0.5, 0.485, length(pos - uv) / size) * color;\n}\n\nvoid cirkle(vec2 pos, float size){\n    cirkle(pos, size, vec3(1));\n}\n\nvoid point(vec2 pos, vec3 color){\n    cirkle(pos, pixelSize * pointSize, color);\n}\nvoid point(vec2 pos){\n    cirkle(pos, pixelSize * pointSize);\n}\n\nbool inBound(vec2 p1, vec2 p2, vec2 pos){\n    vec2 start = vec2(min(p1.x, p2.x), min(p1.y, p2.y));\n    vec2 end = vec2(max(p1.x, p2.x), max(p1.y, p2.y));\n    return\n            start.x <= pos.x\n        &&  end.x   >= pos.x\n        &&  start.y <= pos.y\n        &&  end.y   >= pos.y;\n}\n\nvec3 _projection(vec2 pos, vec2 v1, vec2 v2){\n    vec2 e1 = v2 - v1;\n    vec2 e2 = pos - v1;\n    \n    float dPro = dot(e1, e2);\n    \n    float l1 = length(e1);\n    float l2 = length(e2);\n    \n    float ang = dPro / (l1 * l2);\n    \n    float pLength = ang * l2;\n    \n    vec2 pro = v1 + (pLength * e1) / l1;\n    \n    if(!inBound(v1,v2,pro)) {\n        float l3 = length(v2 - pos);\n        float _min = min(l3, l2);\n        if(_min == l3) pro = v2;\n        else pro = v1;\n    }\n    \n    return vec3(pro, pLength/l1);\n}\n\nvec2 _lineDist(vec2 v1, vec2 v2, float size){\n    vec3 pro = _projection(uv, v1, v2);\n    return vec2(1.-smoothstep(0.8,1.,length(uv - pro.xy) / (size / 2.)), pro.z);\n}\n\nvoid line(vec2 v1, vec2 v2, float size, vec3 col1, vec3 col2){\n    vec2 lineD = _lineDist(v1, v2, size);\n    col += vec3(lineD.x) * mix(col1, col2, lineD.y);\n}\n\nvoid line(vec2 v1, vec2 v2, float size, vec3 col1){\n    col += vec3(_lineDist(v1, v2, size).x) * col1;\n}\n\nvoid line(vec2 v1, vec2 v2, float size){\n    col += vec3(_lineDist(v1, v2, size).x);\n}\n\n\nvoid line(vec2 v1, vec2 v2){\n    col += vec3(_lineDist(v1, v2, pixelSize * pointSize).x);\n}\n\nvoid line(vec2 v1, vec2 v2, vec3 col1){\n    col += vec3(_lineDist(v1, v2, pixelSize * pointSize).x) * col1;\n}\n\nvoid line(vec2 v1, vec2 v2, vec3 col1, vec3 col2){\n    vec2 lineD = _lineDist(v1, v2, pixelSize * pointSize);\n    col += vec3(lineD.x) * mix(col1, col2, lineD.y);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}