{
    "Shader": {
        "info": {
            "date": "1620736162",
            "description": "Raycast thru a grid with overlapping cell to create contiguous and interconnected set of chalets.\n\nMouse available\n\nChange SEED line 37 to create new village.\n\nMore infos in Image header.\n",
            "flags": 64,
            "hasliked": 0,
            "id": "ss2Xz3",
            "likes": 48,
            "name": "Bonneval-sur-Arc",
            "published": 3,
            "tags": [
                "grid",
                "raycasting",
                "fake",
                "city",
                "village",
                "overlapping"
            ],
            "usePreview": 1,
            "username": "ocb",
            "viewed": 961
        },
        "renderpass": [
            {
                "code": "/***************************************************************************************/\n// Title: Bonneval-sur-Arc\n// author: ocb\n//\n// No copyright on code\n//\n// The purpose of this shader is to create structures using grid with overlapping cells. \n// Interconnections of randomly positionned objects create meta-structures, less\n// geometrical and then more natural or unexpected.\n//\n// I also tried myself with fake 3D. (windows, doors, inside lights).\n// Code is still little messy.\n// \n// Mouse is usable to explore village.\n// Push the mouse forward to go inside, explore narrow passages, hidden squares, secret corners.\n// The aiming point is always the village center.\n// No anti-collision functions. If you go thru the chalets, artifacts will appear.\n// It's a limited tool, as the objective is not a game.\n// Put back the mouse on left edge of the shader image to go back to auto-flight cam.\n//\n//\n// Change the SEED at the first line of the code (line 37) to create new village.\n//\n//\n// Thanks to:\n// iq for the Sphere4 raycasting primitive used for the snowy roof.\n// See iq's article and demo shader:\n// https://www.shadertoy.com/view/3tj3DW\n//\n// Dave_Hoskins for the very good hash functions:\n// https://www.shadertoy.com/view/4djSRW\n//\n/***************************************************************************************/\n\n/* If High Resolution screen */\n//#define HiRes\n\n/* set any SEED (float) to create new village */\n#define SEED 0.1\n\n/* smaller chalets or bigger chalets */\n//#define DEN >.8\n#define DEN <1.2\n\n// Max camera distance from center\n#define CamDist 12.\n\n// Max size of the grid - village\n#define MaxRad 11.\n\n// try to comment this if compilation troubles\n#define WITH_CHURCH\n\n#define PI 3.141592653589793\n#define PIdiv2 1.57079632679489\n#define TwoPI 6.283185307179586\n#define INFINI 1000000.\n//#define ti iTime\n//#define ti iMouse.x/iResolution.x*200.\n\n#define SKY 0\n#define GND 1\n#define BODY 2\n#define ROOF 3\n#define CEIL 4\n#define BALCON 5\n#define CHEM 6\n#define TORCH 7\n#define TOWER 8\n#define STEEP 9\n#define CHURCH 10\n#define NEF 11\n\n#define TOPSFC 2.5\n#define maxCell 30\n\n#define RVAL 1000.\n#define TOP 1000.\n  \n#define ZERO min(0,iFrame)\n \n/*******************************************************/\n/*                       Globals                       */\n/*******************************************************/\nint hitObj = SKY;\n\nvec3 boxCtr = vec3(INFINI);\nvec3 boxSze = vec3(0.);\nfloat boxH = 0.;\nmat2 boxRot = mat2(1,0,0,1);\nvec2 boxCell = vec2(0);\nfloat t = INFINI;\nvec3 n = vec3(0,1,0);\n/*******************************************************/\n/*                         Basic                       */\n/*******************************************************/\n//Dave_Hoskins's hash functions\n\nfloat H12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 H22(vec2 p)\n{\n    p += vec2(15.456,21.0985);\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 H33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\nvec3 dither(in vec3 p){\n    return vec3(H33(floor(5000.*p))-.5);\n}\n\n\n/*******************************************************/\n/*                 Raycast primitives                  */\n/*******************************************************/\n\nfloat gnd(float py, float ry, float h){\n    float t = (h-py)/ry;\n    if(t<0.) t = INFINI;\n    return t;\n}\n\n// IQ's box function modified\nvec4 iBox( in vec3 p, in vec3 ray, in vec3 box) \n{\n    // ray-box intersection in box space\n    vec3 sg = sign(ray);\n    vec3 t1 = -(p+sg*box)/ray;\n    vec3 t2 = -(p-sg*box)/ray;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF <= 0. || tN <= 0.) return vec4(INFINI);\n    \n    vec3 nor = -sign(ray)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec4(nor,tN);\n}\n\n// IQ's iSphere4D function !!\n// modified to get the second solution and cut off the roof\nvec4 iSphere4( in vec3 ro, in vec3 rd, in float ra)\n{   \n    // -----------------------------\n    // solve quartic equation\n    // -----------------------------\n    float r2 = ra*ra;\n    \n    vec3 d2 = rd*rd; vec3 d3 = d2*rd;\n    vec3 o2 = ro*ro; vec3 o3 = o2*ro;\n\n    float ka = 1.0/dot(d2,d2);\n\n    float k3 = ka* dot(ro,d3);\n    float k2 = ka* dot(o2,d2);\n    float k1 = ka* dot(o3,rd);\n    float k0 = ka*(dot(o2,o2) - r2*r2);\n\n    // -----------------------------\n    // solve cubic\n    // -----------------------------\n\n    float c2 = k2 - k3*k3;\n    float c1 = k1 + 2.0*k3*k3*k3 - 3.0*k3*k2;\n    float c0 = k0 - 3.0*k3*k3*k3*k3 + 6.0*k3*k3*k2 - 4.0*k3*k1;\n\n    float p = c2*c2 + c0/3.0;\n    float q = c2*c2*c2 - c2*c0 + c1*c1;\n    \n    float h = q*q - p*p*p;\n\n    // -----------------------------\n    // skip the case of three real solutions for the cubic, which involves four\n    // complex solutions for the quartic, since we know this objcet is convex\n    // -----------------------------\n    if( h<0.0 ) return vec4(INFINI);\n    \n    // one real solution, two complex (conjugated)\n    float sh = sqrt(h);\n\n    float s = sign(q+sh)*pow(abs(q+sh),1.0/3.0); // cuberoot\n    float t = sign(q-sh)*pow(abs(q-sh),1.0/3.0); // cuberoot\n    vec2  w = vec2( s+t,s-t );\n\n    // -----------------------------\n    // the quartic will have two real solutions and two complex solutions.\n    // we only want the real ones\n    // -----------------------------\n\n    vec2  v = vec2( w.x+c2*4.0, w.y*1.73205081 )*0.5;   // sqrt(3.0)\n    float r = length(v);\n    float a = abs(v.y)/sqrt(r+v.x);\n    float b = c1/r + k3;\n    float t1 = -a-b;\n    if(t1 <= 0.) return vec4(INFINI);\n    \n    // ocb modified part to shape the roof\n    float t2 = a-b;\n    \n    vec3 pos = ro + t1*rd;\n    vec3 norm = normalize(pos*pos*pos);\n\n    float sn = .6*ra; // snow thickness\n    if(pos.y<sn && pos.z<sn){\n        pos = ro + t2*rd;\n        if(pos.y<sn && pos.z<sn) return vec4(INFINI);\n        \n        vec2 tt = vec2((sn-ro.y)/rd.y, (sn-ro.z)/rd.z); \n        if(pos.y<sn) t1 =  tt.y;\n        else if(pos.z<sn) t1 = tt.x;\n        else t1=min(tt.x, tt.y);\n        \n        if(t1 == tt.y) norm = vec3(0,0,-1);\n        else norm = vec3(0,-1,0);\n    }\n    return vec4(norm,t1);\n}\n\nvec2 cylinder(in vec2 pos, in vec2 ray, in vec2 O, in float R){\n    float t1 = INFINI, t2 = INFINI;\n    vec2 op = pos - O;\n\n    float a = dot(ray,ray);\n    float b = dot(op, ray);\n    float c = dot(op,op) - R*R;\n    float d = b*b - a*c;\n    \n    if (d >= 0.){\n        float Vd = sqrt(d);\n        t1 = (-b - Vd)/a;\n        t2 = (-b + Vd)/a;\n    }\n    \n\treturn vec2(t1,t2);\n}\n\nvec2 sphere(in vec3 p, in vec3 ray, in vec3 O, in float r){\n    vec2 t = vec2(INFINI);\n    vec3 d = O - p;\n    float b = dot(d, ray);\n    \n    float c = dot(d,d) - r*r;\n    float D = b*b - c;\n    if (D >= 0.){\n        float VD = sqrt(D);\n        t = vec2(b-VD, b+VD);\n        if(t.x<=0.) t.x = INFINI;\n        if(t.y<=0.) t.y = INFINI;\n    }\n    return t;\n}\n\n\nvec4 curvgnd(in vec3 pos, in vec3 ray, in float f){\n\n    float t = sphere(pos, ray, vec3(0.,RVAL,0.), RVAL).y;\n    vec3 p = pos + t*ray;\n    vec3 n = normalize(vec3(-p.x,RVAL-p.y,-p.z));\n    vec2 a = vec2(abs(atan(p.x,p.z)));\n    float h = .1\n                +.1*texture(iChannel0,.04*a).x\n                +.3*texture(iChannel0,.02*a).x\n                +.6*texture(iChannel0,.005*a).x;\n    if(p.y > TOP*h) t = INFINI;\n    return vec4(n,t);\n}\n\n\nvec4 bellTower(in vec3 p, in vec3 ray,  in vec3 box)\n{\n    vec3 sg = sign(ray);\n    vec3 t1 = -(p+sg*box)/ray;\n    vec3 t2 = -(p-sg*box)/ray;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF <= 0. || tN <= 0.) return vec4(INFINI);\n    \n    vec3 nor;\n    p += tN*ray;\n    if(p.y+min(1.2,3.*(abs(fract(p.z)-.5)+abs(fract(p.x)-.5))) <= box.y){\n        nor = -sign(ray)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n        return vec4(nor,tN);\n    }\n    \n    p += (tF-tN)*ray;\n    if(p.y+min(1.2,3.*(abs(fract(p.z)-.5)+abs(fract(p.x)-.5))) <= box.y){\n        nor = -sign(ray)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy);\n        return vec4(nor,tF);\n    }    \n    return vec4(INFINI);\n}\n\n\nvec4 steeple(in vec3 p, in vec3 ray, in vec3 size)\n{\n    vec3 np = vec3(.986393923832144,.164398987305357,.0);        // normalize(vec3(6,1.,0));\n    vec3 n = np;\n    float t = INFINI, t2 = INFINI;\n    vec2 pp;\n    \n    float f = dot(ray,np);\n    if(f<=0.){\n        t = -(dot(p,np)-.6575)/f;    // 4./3. x 0.4931 = cos(atan(n.y,n.x))\n        pp = p.zy+t*ray.zy;\n        if(pp.y+6.*abs(pp.x)>= 4. || pp.y <2.) t = INFINI;\n    }\n\n    np.x = -np.x;\n    f = dot(ray,np);\n    if(f<=0.){\n        t2 =-(dot(p,np)-.6575)/f;\n        pp = p.zy+t2*ray.zy;\n        if(pp.y+6.*abs(pp.x)>= 4. || pp.y <2.) t2 = INFINI;\n    }\n    if(t2<t){\n        t=t2;\n        n = np;\n    }\n    \n    np = np.zyx;\n    f = dot(ray,np);\n    if(f<=0.){\n        t2 = -(dot(p,np)-.6575)/f;\n        pp = p.xy+t2*ray.xy;\n        if(pp.y+6.*abs(pp.x)>= 4. || pp.y <2.) t2 = INFINI;\n    }\n    if(t2<t){\n        t=t2;\n        n = np;\n    }\n\n    np.z = -np.z;\n    f = dot(ray,np);\n    if(f<=0.){\n        t2 = -(dot(p,np)-.6575)/f;\n        pp = p.xy+t2*ray.xy;\n        if(pp.y+6.*abs(pp.x)>= 4. || pp.y <2.) t2 = INFINI;\n    }\n    if(t2<t){\n        t=t2;\n        n = np;\n    }\n\n    if(t<=0.) t = INFINI;\n    return vec4(n,t);\n}\n\n/*******************************************************/\n/*                     Grid process                    */\n/*******************************************************/\n\n// finding next cell on the grid\nvec2 getNextCell(in vec2 p, in vec2 v, in vec2 cell){\n    vec2 d = sign(v);\n\tvec2 dt = (cell+d*.5-p)/v;\n    d *= vec2( step(dt.x-0.02,dt.y) , step(dt.y-0.02,dt.x) );\t\t// -0.02 to avoid cell change for epsilon inside\n    return cell+d;\n}\n\n// cell information (center and size of the chalet, if there is.)\nvec2 getBox(in vec2 cell)\n{\n\n#ifdef WITH_CHURCH\n    if(abs(cell.x) <= 1. && abs(cell.y)<=1.) return vec2(-1.);   // Empty spaces for the church\n#endif\n    if(length(cell)>= MaxRad-1.5) return vec2(-1.);\n    vec2 h = H22(cell+SEED);\n    if(h.x+h.y DEN) return vec2(-1.);\n\n    return h;\n}\n\n// raycasting one cell\nvoid checkCell(in vec3 pos, in vec3 ray, in vec2 cell)\n{\n    vec2 h = getBox(cell);\n    if(h.x < -0.1) return;\n    \n    h-=.5;\n    vec3 ctr = vec3(cell.x+h.x,RVAL-sqrt(RVAL*RVAL-cell.x*cell.x-cell.y*cell.y),cell.y+h.y);\n    h = abs(h);\n    float r = (1.5-max(h.x,h.y))*.61;\n    vec3 sze = vec3(r, 1.8*(h.x+h.y)+.4, r );    \n    float ang =  h.x*PI;\n    \n    // convert from ray to box space\n    float c = cos(ang), s = sin(ang);\n    mat2 rotY = mat2(c,-s,s,c);\n    mat2 derotY = mat2(c,s,-s,c);\n    \n    // roof 45 deg\n    // 0.7071 = sin or cos PI/4\n    mat3 rot45 = mat3(1,0,0,  0,.7071,-.7071,  0,.7071,.7071);\n    mat3 derot45 = mat3(1,0,0,  0,.7071,.7071,  0,-.7071,.7071);\n\n\n\tray.xz *= rotY;\n    pos -= ctr;\n\tpos.xz *= rotY;\n    \n    // Main body\n    vec4 res = iBox( pos, ray, sze);\n    vec3 p = pos + res.w*ray;\n    if(res.w<t && p.y+abs(p.z) <= sze.y){\n        t = res.w;\n        n = res.xyz;\n        n.xz*=derotY;\n        hitObj = BODY;\n        boxCtr = ctr;\n        boxSze = sze;\n        boxH = h.x;\n        boxRot = rotY;\n    }    \n    \n    // Chimney\n    pos.z -= .4;\n    res = iBox( pos, ray, vec3(.1,sze.y+.2,.1) );\n    if(res.w<t){\n        t = res.w;\n        n = res.xyz;\n        n.xz*=derotY;\n        hitObj = CHEM;\n        boxCtr = ctr;\n        boxSze = sze;\n        boxH = h.x;\n        boxRot = rotY;\n    }\n    pos.z += .4;\n    \n    // Torch\n    float sx = sze.x+.01;\n    sx *= sign(mod(cell.x,2.)-.5)*sign(mod(cell.y,2.)-.5);\n    pos -= vec3(sx, .35, sx);\n    res = iBox( pos, ray, vec3(.01,.03,.01) );\n    if(res.w<t){\n        t = res.w;\n        n = res.xyz;\n        n.xz*=derotY;\n        hitObj = TORCH;\n        boxCtr = ctr;\n        boxSze = sze;\n        boxH = h.x;\n        boxRot = rotY;\n        boxCell = cell;\n    }\n    pos += vec3(sx, .35, sx);\n\n    // Balcony\n    if(sze.y>1.6){\n        pos.y -= .7;\n        res = iBox( pos, ray, vec3(1.2*sze.x, .1,.7*sze.x) );\n        vec3 pb = pos + res.w*ray;\n        if(res.w<t && res.y!=1. && ( abs(fract(15./sze.x*(pb.z+pb.x))-.5)>.25 || abs(pb.y)>.07) && pb.y<.09+.01*cos(20.*(pb.z+3.*pb.x))){\n            t = res.w;\n            n = res.xyz;\n            n.xz*=derotY;\n            hitObj = BALCON;\n            boxCtr = ctr;\n            boxSze = sze;\n            boxH = h.x;\n            boxRot = rotY;\n        }\n        pos.y += .7;\n    }\n        \n    // Chimney snow cap\n    vec3 O = vec3(0.,sze.y+.2,.4);\n    float u = sphere(pos, ray, O, .13).x;\n    if(u<t){\n        t = u;\n        n = normalize(pos+u*ray - O);\n        n.xz*=derotY;\n        hitObj = ROOF;\n        boxCtr = ctr;\n        boxSze = sze;\n        boxH = h.x;\n        boxRot = rotY;\n    }    \n    \n    \n    pos.y -= sze.y-1.1*sze.x;\n    \n    ray *= rot45;\n    pos *= rot45;\n\n    // Snowy roof\n    res = iSphere4(pos, ray, 1.3*sze.x);\n    if(res.w<t){\n        t = res.w;\n        n = res.xyz*derot45;\n        n.xz*=derotY;\n        if(res.y+res.z == -1.) hitObj = CEIL;\n        else hitObj = ROOF;\n        boxCtr = ctr;\n        boxSze = sze;\n        boxH = h.x;\n        boxRot = rotY;\n    }\n\n    return;\n}\n\n/*******************************************************/\n/*                Main process thru grid               */\n/*******************************************************/\n\nvoid runGrid(in vec3 pos, in vec3 ray){\n\n    vec2 cell, outCell;\n    \n    // first step getting boundary of interesting areas    \n    // Entry and exit point of the voxel run(te and tx)\n    vec3 pe = pos;\n    float te = INFINI, tx = 0.;\n\n    vec2 tc = cylinder(pos.xz, ray.xz, vec2(0.), MaxRad);\n    float th = gnd(pos.y,ray.y,TOPSFC);\n    vec4 res = curvgnd(pos, ray, 1.);\n    float tg = res.w;\n    n = res.xyz;\n\n    if(pos.y>=TOPSFC){\n        te = min(max(tc.x,th),tc.y);\n        tx = min(tg,tc.y);\n    }\n    else{\n        te = tc.x*step(0.,tc.x)+INFINI*step(th,tc.x);\n        tx = min(min(tg,tc.y),th);\n    }\n    \n    \n    // MAIN PROCESS\n    // going thru the grid checking for existing object in each cell\n   \n    t = tg;\n    if(t<INFINI) hitObj = GND;\n    \n    cell = floor(pos.xz+te*ray.xz + .5);\n    outCell = getNextCell(pos.xz, ray.xz, floor(pos.xz+tx*ray.xz + .5));\n\n    int endCheck = 0;\n    const vec3 e = vec3(1,0,-1);\n     \n    for(int i=ZERO; i<maxCell;i++){\n        \n        if(cell == outCell) break;\n                \n        checkCell(pos, ray, cell);\n        checkCell(pos, ray, cell+e.xy);    // 3x3 overlaping\n        checkCell(pos, ray, cell+e.zy);\n        checkCell(pos, ray, cell+e.yx);\n        checkCell(pos, ray, cell+e.yz);\n        \n        checkCell(pos, ray, cell+e.xx);\n        checkCell(pos, ray, cell+e.zz);\n        checkCell(pos, ray, cell+e.xz);\n        checkCell(pos, ray, cell+e.zx);\n        \n        \n        if(endCheck==2) break;\n        \n        if(hitObj >= 2) endCheck += 1;\n        \n        cell = getNextCell(pos.xz,ray.xz,cell);\n    } \n\n\n    return;\n}\n\n/*******************************************************/\n/*                  raycasting Church                  */\n/*******************************************************/\n\n// checking if ray goes in center cell (dim = 1.36 x 1.36)\nbool inChurchBound(in vec2 p, in vec2 r)\n{\n    vec2 s = sign(r);\n    vec2 t1 = -(p+s*1.36)/r;\n    vec2 t2 = -(p-s*1.36)/r;\n\n\tfloat tN = max( t1.x, t1.y );\n\tfloat tF = min( t2.x, t2.y );\n\t\n\tif( tN > tF || tF <= 0.) return false;\n    else return true;\n}\n\n// raycasting whole church\nvoid checkChurch(in vec3 pos, in vec3 ray)\n{\n    vec3 sze = vec3(.9,1.8,.9);\n    vec4 res = iBox( pos, ray, sze);\n    vec3 p = pos + res.w*ray;\n    if(res.w<t && p.y+abs(p.z) <= sze.y){\n        t = res.w;\n        n = res.xyz;\n        hitObj = CHURCH;\n    }\n    \n    res.w = cylinder(pos.xz, ray.xz, vec2(.5,0.), .8).x;\n    p = pos + res.w*ray;\n    if(res.w<t && p.y+abs(.3*p.x) <= .8){\n        t = res.w;\n        n = vec3(p.x-.6,0,p.z);\n        hitObj = NEF;\n    }\n    \n    res.w = sphere(pos, ray, vec3(.5,.25,0), .85).x;\n    p = pos + res.w*ray;\n    if(res.w<t && p.y+abs(.3*p.x) > .75){\n        t = res.w;\n        n = normalize(p - vec3(.5,.3,0));\n        hitObj = ROOF;\n    }\n    \n    pos.xz -= vec2(.4,1.);\n    res = bellTower(pos,ray,vec3(.35,3.5,.35));\n    if(res.w<t){\n        t = res.w;\n        n = res.xyz;\n        hitObj = TOWER;\n    }       \n   \n    res = steeple( pos, ray, vec3(.5,3.,.5));\n    if(res.w<t){\n        t = res.w;\n        n = res.xyz;\n        hitObj = STEEP;\n    }\n    pos.xz += vec2(.4,1.);\n    \n    // roof\n    pos.y -= sze.y-1.1*sze.x;\n    ray *= mat3(1,0,0,  0,.7071,-.7071,  0,.7071,.7071);\n    pos *= mat3(1,0,0,  0,.7071,-.7071,  0,.7071,.7071);\n\n    res = iSphere4(pos, ray, 1.15*sze.x);\n    if(res.w<t){\n        t = res.w;\n        n = res.xyz*mat3(1,0,0,  0,.7071,.7071,  0,-.7071,.7071);\n        if(res.y+res.z == -1.) hitObj = CEIL;\n        else hitObj = ROOF;\n    }\n\n    return;\n}\n\n/*******************************************************/\n/*                 Textures and colors                 */\n/*******************************************************/\nvec3 sky(in float x, in float y)\n{\n    x = .5*x+.5;          \n    return vec3(2.-3.*y, 1.2-1.4*y, .8-.6*y)*x*x+vec3(.0,.05,.1);\n}\n\nfloat snowGlitt(in vec3 p,in vec3 ray)\n{\n    #ifdef HiRes\n    return .6*min(1., step(.9995, H33(floor(2000.*p)+floor(5.*ray)).x ));\n    #else\n    return 0.;\n    #endif\n}\n\n\nvec3 stonewall(in vec2 uv)\n{\n    uv *= vec2(20.,20.);\n\n    vec2 i = floor(uv);\n    uv += vec2(.5,.3)*H22(i);\n    vec2 f = abs(fract(uv)-.5);\n    \n    float h = H12(floor(uv));\n    float tex = texture(iChannel0,.3*(uv+h)).x;\n    vec3 col = .1+ .3*vec3(h);\n    col += .6*tex;\n    col -= .3*(smoothstep(.45+.1*tex,.5,f.x)+smoothstep(.35+.1*tex,.45,f.y));\n\n    return max(vec3(0.),col);\n}\n\nvec3 woodwall(in vec2 p)\n{\n    vec3 col = vec3(.3,.225,.15);\n    col *= 1.-texture(iChannel0,.05*p.yx).x;\n    p*=15.;\n    col -= .4*smoothstep(.34+.2*texture(iChannel0,.01*p.xy).x,.5,abs(fract(p.x)-.5)) ;\n    col *= 1.-.5*H12(floor(p.xx));\n\n    return col;\n}\n\n/************************************************/\n/*               Doors and windows              */\n/************************************************/\n\n/******************** door *******************/\nfloat doorMask(in vec3 p, in vec3 ray, in float pzctr)\n{\n    float apz = abs(pzctr);\n    float m = 1.\n              - smoothstep(.143,.135,apz)*step(p.y,.44)\n              - smoothstep(.205,.20,apz)*smoothstep(.027,.020,abs(p.y-.425));\n    m = max(m,0.);\n    return m;\n}\n\nvec3 door2D(in vec3 p, in vec3 ray, in float pzctr)\n{\n    vec3 tex = vec3(.3,.225,.15)*(.1+texture(iChannel0,3.*p.yz).x);\n    float apz = abs(pzctr);\n    \n    // wood framing\n    vec3 col = tex*smoothstep(.023,.015,abs(p.y-.425))*smoothstep(.2,.19,apz);\n    col += tex*smoothstep(.02,.01,abs(apz-.12))*smoothstep(.40,.398,p.y);\n\n    // door with fake 3D shadows\n    float cy = sign(n.x)*(ray.x*n.z-ray.z*n.x); // cross(ray,n)  \n    float top = step(p.y,.37*(1.-clamp(ray.y,-.08,0.)));\n    if(pzctr < min(.1+.05*cy,.1) && pzctr > max(-.1+.05*cy,-.1)) col += top*woodwall(3.*p.zy);\n    \n    return col;\n}\n\n/******************** window *******************/\n\nfloat winMask(in vec3 apw, in vec3 ray)\n{\n    return 1.-smoothstep(.25,.23,apw.z)*smoothstep(.08,.07,apw.y);\n}\n\nfloat lightWinMask(in vec3 apw)\n{\n    return smoothstep(.18,.16,apw.z)*smoothstep(.055,.05,apw.y);\n}\n\nvec3 window2D(in vec3 pw, in vec3 ray, in float lm, in float h)\n{\n    vec3 tex = vec3(.3,.225,.15)*(.1+texture(iChannel0,pw.zy).x);\n    vec3 col = tex*smoothstep(.24,.22,abs(pw.z))*smoothstep(.075,.07,abs(pw.y));\n;\n    \n    // background light with fake3D light source  \n    vec3 litcol = vec3(.05+.02*h,.03-.01*h,.0)*(2.+.5/(length(vec2(pw.z+.2*(ray.x+ray.z),pw.y+.04+.1*ray.y))+.01));\n    col += 1.5*lm*litcol;\n    \n    // framing with fake 3D shade\n    float cy = sign(n.x)*(ray.x*n.z-ray.z*n.x); // cross(ray,n)  \n    vec2 ctr = vec2(.1*sign(pw.z)*cy ,-.05*sign(pw.y)*ray.y );\n    float mask = lm*smoothstep(.18,.16,abs(pw.z)-ctr.x)*smoothstep(.055,.05,abs(pw.y)-ctr.y);\n    col *= 1.-mask;\n    col += mask*litcol;\n    \n    return col;\n}\n\n/**************** balcony window door ***************/\nvec3 windoorFrame(in vec3 p)\n{\n    vec3 tex = vec3(.3,.225,.15)*(.1+texture(iChannel0,3.*p.yz).x);\n    return tex*smoothstep(.095,.085,abs(p.z))*smoothstep(.19,.17,abs(p.y));\n}\n\n\nfloat wdMask(in vec3 apw)\n{\n    return 1.-smoothstep(.1,.09,apw.z)*smoothstep(.2,.18,apw.y);\n}\n\nfloat lightWDMask(in vec3 apw)\n{\n    return smoothstep(.038,.033,abs(apw.z-.045))*smoothstep(.16,.15,apw.y);\n}\n\nvec3 windoor2D(in vec3 p, in vec3 ray, in float lm, in float h)\n{\n    vec3 col = windoorFrame(p)*(1.-lm); \n    col += lm*vec3(.04,.025-.01*h,.01)*(2.+1./(length(vec2(p.z+.2*(ray.x+ray.z),p.y+.05+.1*ray.y))+.02));\n\n    return col;\n}\n\n/******************** Church windows ********************/\n\n// fake 3D //\nvec2 fake3D(in vec3 ray, in vec2 po)\n{\n    vec3 cr = cross(ray,n);\n    vec2 c = vec2(n.x*cr.z-n.z*cr.x, cr.y);   // face selection\n    return vec2(.1*c.y*sign(po.x)*sign(-n.x+n.z),.1*c.x*sign(po.y));\n}\n\nfloat bellWindow(in vec2 ap, in vec2 poa)\n{\n    float wm = smoothstep(.12,.1,ap.x)*smoothstep(.16,.14,ap.y);\n    wm += smoothstep(.12,.1,length(poa));\n    return min(1.,wm);\n}\n\nfloat churchWindow(in vec2 ap, in vec2 poa)\n{\n    float wm = smoothstep(.07,.06,ap.x)*smoothstep(.05,.04,ap.y);\n    wm += smoothstep(.07,.06,length(poa));\n    return min(1.,wm);\n}\n\n\n\n/*******************************************************/\n/*                       Shadows                       */\n/*******************************************************/\n\n/********************* Fake 3D shadow ******************/\nfloat calcShad(in vec2 cell, in vec2 p, in vec2 lit)\n{    \n    vec2 h= getBox(cell);\n    if(h.x < -0.1 && cell != vec2(0)) return 0.;\n        \n    h-=.5;\n    vec3 ctr = vec3(cell.x+h.x,RVAL-sqrt(RVAL*RVAL-cell.x*cell.x-cell.y*cell.y),cell.y+h.y);\n    h = abs(h);\n    float r = (1.5-max(h.x,h.y))*.61;\n    vec3 sze = vec3(r, 1.8*(h.x+h.y)+.4, r );    \n    float ang =  h.x*PI;\n    \n    float co = cos(ang), si = sin(ang);\n    p -= ctr.xz;\n\n    float da = abs(ang-atan(lit.x,lit.y));\n    float sd = sign(dot(lit,vec2(co,-si)));\n    float sina = sin(da);\n    \n    vec2 ps = p * mat2(lit.x,lit.y,-lit.y,lit.x);\n    p *= mat2(co,-si,si,co);\n    \n    float sh = .5*step(sd*p.x,sze.x)*step(p.y,sze.x)*(1.-step(-sze.x+.01,sd*p.x)*step(-sze.x+.01,p.y))*smoothstep(3.,0.,abs(ps.x))*smoothstep(0.15, -.02*abs(ps.x-sze.x), abs(ps.y)-(1.+.414*sina)*sze.x);\n    \n    lit *= mat2(co,-si,si,co);\n    vec2 s =sign(lit);\n\n    float occ = .5*smoothstep(sze.x+.3,sze.x-.1,abs(p.x)) * smoothstep(sze.x+.3,sze.x-.1,abs(p.y));\n    \n    return sh+occ;\n}\n\n\nfloat fakeShade(in vec2 p, in vec2 lit)\n{\n    vec2 cell = floor(p+.5);\n    float shad = 0.;\n    \n    for(float e=-1.; e<=3.; e++){\n        for(float f=-1.; f<=2.; f++){\n            shad = max(shad,calcShad(cell+vec2(e,f), p, lit));\n        }\n    }\n  \n    return 1.-shad;\n}\n/********************* End of fake 3D shadow ******************/\n\n\n\n/************************* 3D shadow **************************/\n\n/*********** simplified checkCell raycast ************/\nfloat shadCheckCell(in vec3 pos, in vec3 ray, in vec2 cell)\n{\n    float t = INFINI;\n    vec2 h = getBox(cell);\n    if(h.x < -.1) return INFINI;\n    \n    h-=.5;\n    vec3 ctr = vec3(cell.x+h.x,RVAL-sqrt(RVAL*RVAL-cell.x*cell.x-cell.y*cell.y),cell.y+h.y);\n    h = abs(h);\n    float r = (1.5-max(h.x,h.y))*.61;\n    vec3 sze = vec3(r, 1.8*(h.x+h.y)+.4, r );    \n    float ang =  h.x*PI;\n    \n    // convert from ray to box space\n    float c = cos(ang), s = sin(ang);\n    mat2 rotY = mat2(c,-s,s,c);\n    \n    // roof 45 deg\n    mat3 rot45 = mat3(1,0,0,  0,.7071,-.7071,  0,.7071,.7071);\n\n\tray.xz *= rotY;\n    pos -= ctr;\n\tpos.xz *= rotY;\n    \n    // Main body\n    vec4 res = iBox( pos, ray, sze);\n    vec3 p = pos + res.w*ray;\n    if(p.y+abs(p.z) <= sze.y) t = min(t,res.w);\n\n    // Chimney\n    pos.z -= .4;\n    res = iBox( pos, ray, vec3(.1,sze.y+.2,.1) );\n    t = min(t,res.w);\n    pos.z += .4;\n        \n    // Chimney snow cap\n    vec3 O = vec3(0.,sze.y+.2,.4);\n    t = min(t, sphere(pos, ray, O, .13).x);\n\n    \n    pos.y -= sze.y-1.1*sze.x;\n    \n    ray *= rot45;\n    pos *= rot45;\n\n    // Snowy roof\n    res = iSphere4(pos, ray, 1.3*sze.x);\n    t = min(t, res.w);\n\n    return t;\n}\n\n\n/****************** shadows on ground ******************/\nfloat gndShad(in vec3 p, in vec3 lit){\n    vec2 cell = floor(p.xz+.5);\n    p.y+=.001;             // be sure p is above ground surface to avoid ground interception\n    p.xz -= .015*lit.xz;   // to remove some artifacts due to rotation accuracy issue with building\n    float tsh = INFINI;\n    lit -= .1*dither(p);//+.05*n+.1*lit;\n    for(float e=-0.; e<=4.; e++){            // due to fix ambiant light direction\n        for(float f=-1.; f<=2.; f++){        // only checking limited grid area\n            tsh = min(tsh, shadCheckCell(p, lit, cell+vec2(e,f)));\n        }\n    }    \n    return min(.3*tsh+.4,1.);\n}\n\n/********* local shade, for ambiant occlusion *******/\nfloat locShad(in vec3 p, in vec3 lit){\n    vec2 cell = floor(p.xz+.5);\n    float tsh = INFINI;\n    for(float e=-1.; e<=2.; e++){\n        for(float f=-1.; f<=2.; f++){ \n            tsh = min(tsh, shadCheckCell(p, lit, cell+vec2(e,f)));\n        }\n    }    \n\nreturn min(2.*tsh,1.);\n}\n\n/*********************************************************/\n/*                       Lighting                        */\n/*********************************************************/\n\nfloat torch( in vec2 cell, in vec3 p)\n{\n    vec2 h= getBox(cell);\n    if(h.x < 0.) return INFINI;\n    \n    h-=.5;\n    vec3 ctr = vec3(cell.x+h.x,RVAL-sqrt(RVAL*RVAL-cell.x*cell.x-cell.y*cell.y),cell.y+h.y);\n    h = abs(h);\n    float r = (1.5-max(h.x,h.y))*.61;\n    vec3 sze = vec3(r, 1.8*(h.x+h.y)+.4, r );    \n    float ang =  h.x*PI;\n\n    float sx = sze.x+.01;\n    sx *= sign(mod(cell.x,2.)-.5)*sign(mod(cell.y,2.)-.5);  // to change corner side every other one\n\n    vec3 torPos = vec3(sx, .35, sx);\n\n    float c = cos(ang), s = sin(ang);\n    torPos.xz *= mat2(c,s,-s,c);\n    torPos.xz += ctr.xz;\n\n    vec3 u = torPos-p;\n    \n    float l = INFINI;\n    \n    float dt = dot(normalize(u),n);\n    l = length(u)/smoothstep(-.2,0.2,dt);\n\n    return l;\n}\n\nvec3 torchLight(in vec3 p)\n{\n    vec2 cell = floor(p.xz+.5);\n    float d = INFINI;\n    //p -= .1*dither(p)+.05*n;\n    for(float e=-3.; e<=3.; e++){\n        for(float f=-3.; f<=3.; f++){\n            d = min(d,torch(cell+vec2(e,f), p));\n        }\n    }\n    return vec3(.5,.3,.1)*max(0.,(1./(d*d+.1)-.1));\n}\n\n/******************************************************************/\n/*                        CAM functions                          */\n/******************************************************************/\n \nvec3 getCamPos(out vec3 camTarget)\n{\n    vec3 p;\n    if(iTime < 30.){\n        float r = 15.;//+3.*cos(.1*iTime);\n        float a = -.075*iTime-2.5;\n        p = vec3(r*cos(a),.25,r*sin(a));\n        camTarget = .5*p;    \n    }\n    else if(iTime < 52.){\n        float ti = iTime-30.;\n        camTarget.y = 1.;\n        p.y = .25;\n        float tiA = .7*ti;\n        float tiB = .4*ti;\n        float tr = smoothstep(15.,20.,ti);\n        tiA = -.1*tiA+2.8;\n        tiB -= 17.;\n        p.xz = mix(11.*vec2(cos(tiA), sin(tiA)), vec2(.15*tiB+1.4, -tiB), tr);\n        camTarget.xz = mix(vec2(.35,7.), vec2(0), tr);\n    }\n    else if(iTime<94.){\n        p.y = .25;\n        float tiA = .4*(iTime-30.);\n        float tiB = .05*(iTime-30.)+6.3;\n        tiA -= 17.+smoothstep(58.,64.,iTime);\n        float tr = smoothstep(59.,63.,iTime);\n        float s = smoothstep(65.,72.,iTime);\n        float sf = smoothstep(82.,90.,iTime);\n        float r = 5.-1.8*s-1.*sf;\n        p.xz = mix(vec2(.15*tiA+1.4, -tiA), r*vec2(cos(tiB),sin(tiB)), tr);\n        camTarget = vec3(-3.*s+4.*sf, 1.+.6*sf, -3.*s+4.*sf);\n    }\n    else if(iTime<120.){\n        float ti = iTime-94.;\n        float s = smoothstep(12.,27.,ti);\n        float rot = smoothstep(16.,27.,ti);\n        float ey = smoothstep(13.,18.,ti);\n        ti= .3*ti-8.;\n        camTarget = (1.-s)*vec3(-ti,.25+ey*.7,-1.73*ti-6.1+.13*sin(ti+1.))+vec3(0,s*1.5,0);\n        ti -= .1;\n        p = mix(vec3(-ti,.23+s*2.3,-1.73*ti-6.1), vec3(4.*cos(-.5*ti-2.5),2.3,4.*sin(-.5*ti-2.5)), rot);\n    }\n    else{\n        float ti = iTime-94.;\n        ti= -.15*ti+1.55;\n        float tr = smoothstep(121.,140.,iTime);\n        float r = 10.+5.*sin(.4*ti);\n        p = vec3(r*cos(.7*ti),2.5,r*sin(.7*ti));\n        p = mix(vec3(4.*cos(ti),2.3,4.*sin(ti)), p, tr);\n        p.y -= 2.1*smoothstep(9.,13.,length(p.xz));\n        camTarget = mix(vec3(0,1.5,0), .5*p, tr);\n    }\n    \n/*    float ti = -.2*iTime+4.;\n    float r = 10.+5.*sin(.4*ti);\n    p = vec3(r*cos(.7*ti),2.5,r*sin(.7*ti));\n    p.y -= 2.1*smoothstep(9.,13.,length(p.xz));\n    camTarget = .8*p;\n    */\n    return p;\n}\n\n// used for cam path equation setting\nvec3 laserBeam(in vec3 p)\n{\n    vec3 c = vec3(0);\n    c.r += smoothstep(.02,0.,abs(1.73*p.x-p.z-6.1));\n    c.r += smoothstep(.02,.0,abs(length(p.xz)-11.)) + smoothstep(.02,0.,abs(p.x+.15*p.z-1.4)) + smoothstep(.02,.0,abs(length(p.xz)-5.1));\n    return c;\n}\n\nvec3 mouseCam(in vec3 camTarget)\n{\n    float \trau = 12.,\n            alpha = iMouse.x/iResolution.x*4.*PI,\n            theta = (iMouse.y+.001)/iResolution.y*PI+ (PI/2.0001);\t// +0.001 to avoid black horizontal line\n \n    return rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha))+camTarget;\n}\n\n\n/******************************************************************/\n/*                        MAIN functions                          */\n/******************************************************************/\n\nvec3 getRay(in vec2 st, in vec3 pos, in vec3 camTarget){\n    float \tfocal = 1.5;\n    vec3 ww = normalize( camTarget - pos);\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\treturn normalize( st.x*uu + st.y*vv + focal*ww );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    vec3 lit = vec3(.9759,.09759,.19518);   // light dir = (1.,.1,.2)\n    vec3 camTarget = vec3(0), pos = vec3(15.,1.,15.);\n   \n    if(iMouse.x > 2.){\n        camTarget = vec3(0.,1.,0.);\n        pos = mouseCam(camTarget);\n        pos.y = max(.1+RVAL-sqrt(RVAL*RVAL-pos.x*pos.x-pos.z*pos.z),pos.y);\n    }\n    else{\n        pos = getCamPos(camTarget); \n    }\n    \n    vec3 ray = getRay(st, pos,camTarget);\n    \n    \n    runGrid(pos,ray);\n\n#ifdef WITH_CHURCH\n    checkChurch(pos,ray);\n#endif\n\n    vec3 p = pos;\n    if(t<INFINI) p += t*ray; \n    \n    vec3 outp = p+.0001*n;\n    float lm = 0., lm2 = 0., dm = 0.;               // light mask\n    \n    // GROUND with shadows\n    if(hitObj == GND){\n        ray.y = abs(ray.y);\n        float df = texture(iChannel0,.5*p.xz).x-texture(iChannel0,.5*p.xz+vec2(.001)).x;\n        vec2 e = vec2(.001*length(p.xz),.3*atan(p.z,abs(p.x)));\n        col += .6+snowGlitt(p,ray)+.1*df+.4*(texture(iChannel0,.0005*p.xz).x-texture(iChannel0,.0005*p.xz+vec2(.00001*t)).x);   // gnd snow \n        col *= smoothstep(600.,0.,t);                           // fading to the mountains\n        col += min(.3,.0042*p.y*texture(iChannel0,e).x);        // snow and rocks over mountains\n        col += p.y*vec3(0.,.00015,.0002)*ray.x;   // color correction, magenta over exposed top\n        col *= .4+.6*dot(n,lit);\n        col *= fakeShade(p.xz, lit.xz);    // fake shadows (smooth and fast) \n        col *= 1.-.5*smoothstep(2.2,0.,abs(p.x+.4))*smoothstep(1.,0.,abs(p.z-.9))*step(.9,p.z)*smoothstep(.85,.75,p.x);    // towerbell correction        \n        //col *= gndShad(p,lit);               // more real (3D sahdows) slower and need dithering\n    }\n    // BODY bulding with windows and doors\n    else if(hitObj == BODY){\n        p -= boxCtr;\n        p.xz *= boxRot;\n        \n        col += .3*stonewall(p.zy+p.xy);\n         \n        // windows\n        float dctr = 1.6*boxH-.4;    // door center\n        vec3 pw = vec3(p.x, p.y-.3,fract(3.*p.z)-.5);\n        vec3 apw = abs(pw);\n        float fpz = floor(3.*p.z);\n        if(fpz+1.<dctr-.15 || fpz>dctr+.15){\n            lm = lightWinMask(apw);\n            col *= winMask(apw, ray);\n            col += window2D(pw, ray, lm, boxH); // fake 3D window\n        }\n        // window for level2 no balcony\n        if( boxSze.y<1.6 ){\n            pw = vec3(p.x, p.y-.8,fract(4.*p.z+.5)*mod(floor(4.*p.z+.5),2.)-.5);\n            apw = abs(pw);\n            lm2 = lightWinMask(apw);\n            col *= winMask(apw, ray);\n            col += window2D(pw, ray,lm2, boxH);\n        }\n        // balcony door\n        else{\n            pw = vec3(p.x, p.y-.85, p.z);\n            apw = abs(pw);\n            lm2 = lightWDMask(apw);\n            col *= wdMask(apw);\n            col += windoor2D(pw, ray, lm2, boxH);\n        }\n\n        // door\n        float pzCtr = p.z-dctr;   // pos from door center\n        dm = doorMask(p, ray, pzCtr);\n        col *= dm;\n        col += door2D(p, ray, pzCtr);      // fake 3D door\n        \n        // shading and lights\n        float rf = .65*(p.y+abs(p.z))/boxSze.y;    // roof occlusion\n        rf *= rf*rf*rf;\n        col -= rf*(1.-lm2);\n        \n        float gi = .6+.4*dot(n,lit);    // gen. illuminitaion\n        \n        float ls = 1.;\n        if(dot(n,lit)>0.) ls = locShad(outp,lit);\n        lm += lm2;\n        lm *= dm;\n        col *= lm+(1.-lm)*ls*gi;     // removing window mask to avoid erroneous shade on windows light     \n    }\n    // CHIMNEY\n    else if(hitObj == CHEM){\n        p -= boxCtr;\n        p.xz *= boxRot;\n        col += .3*stonewall(p.zy+p.xy);\n        col *= .6+.4*dot(n,lit);\n    }\n    // BALCONY\n    else if(hitObj == BALCON){\n        p -= boxCtr;\n        p.xz *= boxRot;\n        if(p.y > .77) col += .3;\n        else col += woodwall(10.*n.x*p.zy + 2.*n.y*p.xz);\n        col *= .6+.4*dot(n,lit);\n    }\n    // snowy ROOF\n    else if(hitObj == ROOF){\n        p -= boxCtr;\n        p.xz *= boxRot;\n        col += .4;\n        col += snowGlitt(p,ray);\n        col *= .6+.4*dot(n,lit);\n        if(dot(n,lit)>0.) col *= .6+.4*locShad(outp,lit);     \n    }\n    // wooden CEILING below roof\n    else if(hitObj == CEIL){\n        p -= boxCtr;\n        p.xz *= boxRot;\n        col += .3*woodwall(2.5*p.xy);\n        p.z*=8.;\n        col -= .1*(smoothstep(.2+.3*texture(iChannel0,.1*p.xz).x,.4,abs(fract(p.z)-.5)));\n        col *= .5+.5*dot(-ray,lit);\n    }\n    // TORCH street light\n    else if(hitObj == TORCH){\n        p -= boxCtr;\n        p.xz *= boxRot;\n        float sx = boxSze.x+.01;\n        sx *= sign(mod(boxCell.x,2.)-.5)*sign(mod(boxCell.y,2.)-.5);\n        p -= vec3(sx, .35, sx);\n        float l = length(p);\n        col += vec3(.00024,.00012,.00004)/(l*l);\n        col *= step(abs(p.x),.007)+step(abs(p.y),.027)+step(abs(p.z),.007);\n    }\n    \n#ifdef WITH_CHURCH\n\n    // CHURCH\n    else if(hitObj == CHURCH){\n        col += .4*stonewall(p.zy+p.xy);\n        col  *= .6+.4*dot(n,lit); \n        p += .001*n;                   // proximity occlusion\n        if(dot(n,lit)>0.) col *= locShad(p,lit);     \n        \n        \n        /** lateral windows **/\n        vec2 po = vec2(fract(1.7*p.x-.3)-.5, p.y-.35);\n        vec2 ap = abs(po);           // center of the window\n        vec2 poa = po-vec2(0.,.05);  // center of the arche\n        \n        // window mask\n        float wm = churchWindow(ap,poa);\n        \n        // moving center for the black mask (fake 3D)\n        vec2 ctr = .7*fake3D(ray,po);\n               \n        // black mask. same as window mask but with shifted center\n        ap = abs(ap-ctr);\n        poa -= sign(po)*ctr;\n        float bm = churchWindow(ap,poa);\n                \n        ap*=vec2(20.,5.);\n        ap.x = fract(ap.x)-.5;\n        vec3 litcol = vec3(.05,.04,.02)*(1.+2./length(ap));\n\n        // adding texture with brighter color on window mask (sides)\n        col += wm*vec3(.3,.24,.12);\n        // removing shifted hole part (black), in respect of window limits.\n        col *= 1.-wm*bm;\n        \n        po -= sign(po)*ctr;\n        po *= 30.;\n        col += bm*wm*litcol*(.3+.7*H12(floor(vec2(po.x+po.y,po.x-po.y))+floor(1.7*p.x-.3)+12.34));   // inside lights        \n        col *= 1.-wm*bm*(smoothstep(.9,1.,fract(po.x+po.y))+smoothstep(.9,1.,fract(po.x-po.y)));  // window grid\n        \n        \n        /** top round windows **/\n        poa = vec2(p.z, p.y-1.1);\n        wm = smoothstep(.1,.09,length(poa));\n        ctr = .7*fake3D(ray,poa);\n        poa -= sign(poa)*ctr;\n        float lpoa = length(poa);\n        bm =smoothstep(.1,.09,lpoa);\n        float ang = 2.*atan(poa.y,poa.x);\n        litcol = vec3(.04,.032,.016)/(lpoa+.02)*(.5+.5*H12(vec2(floor(ang))))*(1.-smoothstep(.8,1.,fract(ang)));\n        col += wm*vec3(.3,.24,.12);\n        col *= 1.-wm*bm;\n        col += bm*wm*litcol;\n        \n    }    \n    else if(hitObj == NEF){\n        vec2 a = vec2(atan(p.z,p.x),2.*p.y);\n        col += .4*stonewall(a);\n        col  *= .6+.4*dot(n,lit); \n        p += .001*n;                   // proximity occlusion\n        if(dot(n,lit)>0.) col *= locShad(p,lit);   \n        \n        \n        /** slot windows **/\n        vec2 po = vec2(fract(2.5*a.x-.5)-.5, a.y-.55);\n        vec2 ap = abs(po);           // center of the window\n         \n        float wm = smoothstep(.03,.02,ap.x)*smoothstep(.07,.06,ap.y);\n        vec2 ctr = .7*fake3D(ray,po);\n        ap = abs(ap-ctr);\n        float bm = smoothstep(.03,.02,ap.x)*smoothstep(.07,.06,ap.y);\n       \n        ap.y-=.1;\n        vec3 litcol = vec3(.05,.04,.02)*(.4/length(ap));\n        col += wm*vec3(.4,.32,.16);\n        col *= 1.-wm*bm;\n        col += bm*wm*litcol;\n        \n    }\n    else if(hitObj == TOWER){\n        //vec3 o = vec3(.4,1.8,1.);  // center of bell tower for memory\n        vec3 an = abs(n);\n        vec2 po = an.x*(p.zy-vec2(1.,1.8))+an.z*(p.xy-vec2(.4,1.8));   // face selection\n        vec2 ap = abs(po);           // center of the window\n        vec2 poa = po-vec2(0.,.16);  // center of the arche\n        \n        // window mask\n        float wm = bellWindow(ap,poa);\n        \n        // moving center for the black mask (fake 3D)\n        vec2 ctr = fake3D(ray,po);\n               \n        // black mask. same as window mask but with shifted center\n        ap = abs(ap-ctr);\n        poa -= sign(po)*ctr;\n        float bm = bellWindow(ap,poa);\n\n        // adding texture with darker color on window mask (sides)\n        col += (.4-.2*wm)*stonewall(2.*po);\n        // removing shifted hole part (black), in respect of window limits.\n        col *= 1.-bm*wm;\n        \n        col  *= .6+.4*dot(n,lit); \n        p += .001*n;                   // proximity occlusion\n        if(dot(n,lit)>0.) col *= locShad(p,lit);     \n    }\n    else if(hitObj == STEEP){\n        float f = smoothstep(.0,.15,(3.5-p.y)*texture(iChannel0,n.z*p.yx+n.x*p.yz).x);\n        col += (1.-f)*vec3(.43,.4,.37)*stonewall(vec2(.5*(p.z+p.x),.3*p.y));\n        col += .4*f;\n        col  *= .6+.4*dot(n,lit); \n    }\n    \n#endif\n\n    // SKY\n    else col += sky(ray.x, ray.y);\n    \n    // Overall illumination by torch\n    if(hitObj != SKY) col *= 1.+(1.-step(0.05,lm))*torchLight(outp)/(.6+.4*dot(n,lit));\n\n    //if(hitObj == GND) col += laserBeam(p);\n\n    fragColor = vec4(col,1.0);\n}\n\n \n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 27115,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/desert-trax/carbon-based-lifeforms-rca"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}