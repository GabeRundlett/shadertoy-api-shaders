{
    "Shader": {
        "info": {
            "date": "1653059439",
            "description": "A simple fractal bounded in a cube.",
            "flags": 32,
            "hasliked": 0,
            "id": "ssccR4",
            "likes": 11,
            "name": "fractal box",
            "published": 3,
            "tags": [
                "raymarching",
                "occlusion",
                "3dfractal"
            ],
            "usePreview": 0,
            "username": "me_123",
            "viewed": 391
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);//vec4(0.0,0.0,1.0,1.0);\n    fragColor /= fragColor.w;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int it = 10;\nconst float eps = 0.001;\n\nvec3 getRay(in vec3 cameraDir, in vec2 uv) { //get camear ray direction\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n}\nvec3 hash33(vec3 p3)\n{ //by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nvec3 rus(in vec3 seed) {\n    return normalize(hash33(seed)-0.5);\n}\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nvec3 transform(in vec3 p) {\n    float r = 0.4;\n    mat2 rot = mat2(cos(r), -sin(r), sin(r), cos(r));\n    for (int i = 0; i < it; i += 1) {\n        p = abs(p);\n        p *= 2.0;\n        p -= 0.5;\n        p.xy *= rot;\n        p.zx *= rot;\n        p.zy *= rot;\n    }\n    return p;\n}\nfloat sdf(in vec3 p) { //signed distance function - vorinoi inside a sphere\n    vec3 tp = transform(p);\n\treturn max((length(tp)-0.5)*pow(2., -float(it)), box(p, vec3(0.5)));\n}\nvec3 normal( vec3 p)\n{\n    const float h = eps;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy * sdf(p + k.xyy * h) +\n                     k.yyx * sdf(p + k.yyx * h) +\n                     k.yxy * sdf(p + k.yxy * h) +\n                     k.xxx * sdf(p + k.xxx * h));\n}\nstruct hit {\n    vec3 p;\n    vec3 n;\n    float d;\n};\nhit trace(in vec3 ro, in vec3 rd) {\n\tfloat d0 = 0.0;\n    vec3 p;\n    int i;\n    for (i = 0; i < 1000; i += 1) {\n    \tp = ro+rd*d0;\n        float d = sdf(p);\n        d0 += d;\n        if (d < eps || d0 > 100.) break;\n    }\n    if (d0 > 100.) return hit(vec3(-1), vec3(-1), -1.);\n    return hit(p, normal(p), d0);\n}\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    hit t = trace(ro, rd);\n    if (t.d == -1.0) return vec3(0);\n    vec3 np = t.p+t.n*eps*1.25;\n    vec3 nd = normalize(rus(vec3(iFrame))+t.n);\n    hit nt = trace(np, nd);\n    return (nt.d>0.0?vec3(0):vec3(abs(nd)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord+hash33(vec3(fragCoord.xy, iTime)).xy) - 0.5 * iResolution.xy) / iResolution.y;\n    \n    //camera\n    vec2 m = iMouse.z>0.0?((iMouse.xy)/iResolution.xy) * vec2(6.28, 3.14159263):vec2(0.7, 1.0);\n        \n    vec3 ro = vec3(sin(m.y) * cos(-m.x), sin(m.y) * sin(-m.x), cos(m.y))*1.8;\n    vec3 rd = getRay(-normalize(ro), uv);\n    \n    //render\n    vec3 color = getColor(ro, rd);\n    vec4 old = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    \n    //super sample\n    if (iMouse.z > 0.0) {\n        fragColor = vec4(color, 1);\n        return;\n    };\n    fragColor = vec4(color, 1)+old;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}