{
    "Shader": {
        "info": {
            "date": "1675923380",
            "description": "left side = ray marched\nright side = ray traced\nexcept the plane is ray-traced in both cases.",
            "flags": 0,
            "hasliked": 0,
            "id": "ctjSzR",
            "likes": 7,
            "name": "refraction tracing vs. marching",
            "published": 3,
            "tags": [
                "optics",
                "bakeoff"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 213
        },
        "renderpass": [
            {
                "code": "\n\nconst uint mtl_0       = 0u;\nconst uint mtl_clear1  = 1u;\nconst uint mtl_clear2  = 2u;\nconst uint mtl_pink    = 3u;\nconst uint mtl_chrome  = 4u;\nconst uint mtl_floor   = 5u;\nconst uint mtl_count   = 6u;\n\nconst mtl_t materials[mtl_count] = mtl_t[](\n    mtl_t(1.0        , 1.0 , v1),                   // sky\n    mtl_t(ior_water  , 0.98, v1),                   // clear1\n    mtl_t(ior_aerogel, 0.94, v1),                   // clear2\n    mtl_t(1.2        , 0.0 , vec3(0.0, 0.8, 1.0)),  // pink\n    mtl_t(1e2        , 0.0 , v1),                   // chrome\n    mtl_t(1.0        , 0.0 , v1)                    // floor\n);\n\nconst float cPixelize  = 1.0;\n\nconst float cMinRayAmt = .004;\nconst uint  cMaxRays   = 11u;\nconst float cSurfEps   = 0.01;\n\nconst int   cMaxMarchSteps    = 100;\nconst float cWSEps            =   0.005;\n      float gUnderStepFactor  =   1.0;\n\n\n\n#define Q_TYPE        ray_t\n#define Q_MAX_ENTRIES 6u\nQ_IMPLEMENTATION\n\n\nvec2 viewportFromScreen(in vec2 p) {\n    return (p * 2.0 - RES) / MINRES;\n}\n\nfloat gT;\nfloat gSmoothEps;\nvec3  gSunDir;\nvec3  gBallPos1;\nvec3  gBallPos2;\nvec3  gBallPos3;\nfloat gLemA;\nvec3  gRGB;\n\nfloat unitBounce(in float t) {\n    t = fract(t) * 2.0 - 1.0;\n    t *= t;\n    return 1.0 - t;\n}\n\nvoid setupScene() {\n    const float br12    = 1.0;\n    const float spacing = 1.5;\n    \n    gBallPos1 = vec3( spacing, 1.01 + unitBounce(gT * 2.31), 0.0);\n    gBallPos2 = vec3(-spacing, 1.01 + unitBounce(gT * 2.52), 0.0);\n    gSunDir   = normalize(v1);\n    \n    float t3 = gT * 2.3;\n    gLemA = (spacing + br12 * 1.5);\n    gBallPos3.xz = vec2(cos(t3), sin(t3) * cos(t3));\n    gBallPos3.xz *= gLemA  / (1.0 + sin(t3) * sin(t3));\n    gBallPos3.z  *= 1.2;\n    gBallPos3.y  = 0.301;// + unitBounce(t3 * 3.543) * 0.2;\n}\n\nvoid rayVsScene_trace(in ray_t r, inout hit_t h) {\n    rayVsSphere(r, gBallPos1, 1.0, mtl_clear1, h);\n    rayVsSphere(r, gBallPos2, 1.0, mtl_clear2, h);\n    rayVsSphere(r, gBallPos3, 0.3, mtl_pink  , h);\n    rayVsPlane (r, vY, 0.0, mtl_floor, h);\n}\n\nmapSample_t map(in vec3 p) {\n    mapSample_t ret = mapSample_t(1e9, mtl_0);\n    \n    opUnion(ret, sdSphere  (p - gBallPos1, 1.0), mtl_clear1);\n    opUnion(ret, sdSphere  (p - gBallPos2, 1.0), mtl_clear2);\n//  opUnion(ret, sdBoxFrame(p - gBallPos2, vec3(1.0), 0.1) - 0.05, mtl_clear2);\n    opUnion(ret, sdSphere  (p - gBallPos3, 0.3), mtl_pink  );\n    \n    return ret;\n}\n\n\n// Tetrahedral normal technique with a loop to avoid inlining getSDF()\n// This should improve compilation times\n// https://iquilezles.org/articles/normalsSDF\nvec3 mapNormal(vec3 p){\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*cWSEps).dist;\n    }\n    return normalize(n);\n}\n\n\nvoid rayVsScene_march(in ray_t r, inout hit_t h) {\n    float t = 0.0;\n    \n    for (int n = 0; n < cMaxMarchSteps && t < 1e2; ++n) {\n        vec3 p = r.ro + r.rd * t;\n        mapSample_t ms = map(p);\n        if (ms.dist * r.side < cWSEps) {\n            h.hit = true;\n            h.t   = t;\n            h.pnt = p;\n            h.nrm = mapNormal(p);\n            h.mtl = ms.mtl;\n            return;\n        }\n\n        t += r.side * ms.dist * gUnderStepFactor;\n    }\n\n    rayVsPlane (r, vY, 0.0, mtl_floor, h);\n}\n\n\nbool gUseMarching;\nvoid rayVsScene(in ray_t r, inout hit_t h) {\n    if (gUseMarching) {\n        rayVsScene_march(r, h);\n    }\n    else {\n        rayVsScene_trace(r, h);\n    }\n}\n\n//------------------------------------------------------------------\n\nconst float blankSkyTone = 0.01;\n\nvec3 toneSky(in ray_t r) {\n    return simple_sky(r.ro, r.rd, gSunDir);\n}\n\nvec3 toneFloor(in vec2 p) {\n#if 0\n    const float width2 = 0.03;\n          float width1 = width2 * mix(0.1, 0.9, smoothstep(10.0, 1.0, length(p)));\n    p *= 0.25;\n    float q = 1.0;\n    q *= smoothstep(width1, width2, abs(fract(p.x) - 0.5));\n    q *= smoothstep(width1, width2, abs(fract(p.y) - 0.5));\n    q *= smoothstep(width1, width2, abs(length(p) / 1.5 - 1.0) * 1.5);\n    q  = 1.0 - 0.95 * q;\n    q = mix(q, blankSkyTone, smoothstep(2.0, 10.0, length(p)));\n#else\n    float q = 0.006;\n#endif\n    \n    vec3 rgb = v1 * q;\n    \n    float lemL = dot(p, p) * dot(p, p);\n    float lemR = gLemA * gLemA * (p.x * p.x - p.y * p.y / (1.2 * 1.2));\n    float lemD = lemL - lemR;\n    if (dot(p, p) < 10.0) {\n        const vec3 lemC = vec3(0.4, 0.01, 0.01);\n        rgb = mix(rgb, lemC, smoothstep(gSmoothEps * 80.0, 0.0, abs(lemD) - 0.9));\n        rgb = mix(rgb, vX + vY, smoothstep(gSmoothEps * 2.0, 0.0, length(p) - 0.15));\n    }\n    \n    return rgb;\n}\n\nvec3 tone(in ray_t r, in hit_t h) {\n    switch (h.mtl) {\n        case mtl_0:\n            return toneSky(r);\n        case mtl_clear1:\n        case mtl_clear2:\n        case mtl_pink:\n        case mtl_chrome:\n            return materials[h.mtl].color;\n        case mtl_floor:\n            return toneFloor(h.pnt.xz);\n    }\n}\n\n//------------------------------------------------------------------\n\nuint gRayCount;\nvoid runRays() {\n\n    // accumulates in gRGB.\n    \n    // process the queue until it's empty.\n    // careful you don't get an infinite loop here.\n    \n    gRayCount = 0u;\n    \n    while (!QIsEmpty()) {\n        gRayCount += 1u;\n        ray_t r = QDequeue();\n\n        hit_t h = newHit();\n        h.mtl = mtl_0;\n        rayVsScene(r, h);\n        \n        if (!h.hit) {\n            // no hit\n            gRGB += r.amt * tone(r, h);\n        }\n        else {\n            // a hit!\n            // \"nrm\" here is the hit-facing normal,\n            // while h.nrm is the \"outward\" facing normal.\n            \n            mtl_t m = materials[h.mtl];\n            \n            vec3  nrm     = h.nrm * r.side;\n            float R0      = schlickR0(m.ior, ior_air);\n            float reflAmt = schlick  (R0, dot(r.rd, -nrm));            \n            float trnsAmt = m.diffVsTrns * (1.0 - reflAmt);\n            float diffAmt = (1.0 - m.diffVsTrns) * (1.0 - reflAmt);\n                        \n            reflAmt *= r.amt;\n            trnsAmt *= r.amt;\n            diffAmt *= r.amt;\n\n            if (diffAmt > cMinRayAmt) {\n                // diffuse lighting at surfaces.\n                // cast a ray for shadows.\n                ray_t shdRay;\n                shdRay.ro         = h.pnt + h.nrm * cSurfEps;\n                shdRay.rd         = gSunDir;\n                shdRay.amt        = diffAmt;\n                shdRay.side       = 1.0;\n                hit_t shdHit      = newHit();\n                \n                float sunDot      = max(0.0, dot(gSunDir, h.nrm));\n                \n                rayVsScene(shdRay, shdHit);\n                float lit = 1.0 - float(shdHit.hit);\n                                \n                vec3 diff = lit * diffAmt * sunDot * tone(r, h);\n                                \n                gRGB += diff;\n            }\n\n            // moving on to transmission and then reflection.\n            \n            if (QSpaceLeft() < 2u)    continue;\n            if (gRayCount >= cMaxRays) continue;\n            \n            if (trnsAmt > cMinRayAmt) {\n                float eta = ior_air / m.ior;\n                if (r.side < 0.0) {\n                    eta = 1.0 / eta;\n                }\n                vec3 trnRayDir = refract(r.rd, nrm, eta);\n                if (dot(trnRayDir, trnRayDir) < 0.001) {\n                    // total internal reflection.\n                    // this is theoretically impossible for a ray that entered a sphere,\n                    // but keeping it in here anyhow for more exotic scenarios.\n                    reflAmt += trnsAmt;\n                }\n                else {\n                    ray_t trnRay;\n                    trnRay.ro   = h.pnt - nrm * cSurfEps;\n                    trnRay.rd   = trnRayDir;\n                    trnRay.side = -r.side;\n                    trnRay.amt  = trnsAmt;\n                    \n                    QEnqueue(trnRay);\n                }\n            }\n\n            if (reflAmt > cMinRayAmt) {\n                ray_t rflRay;\n                rflRay.ro   = h.pnt + nrm * cSurfEps;\n                rflRay.rd   = reflect(r.rd, nrm);\n                rflRay.side = r.side;\n                rflRay.amt  = reflAmt;\n\n                QEnqueue(rflRay);\n            }\n        }\n    }\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    gT         = iTime * 0.2;\n    gSmoothEps = 4.0 / MINRES;\n    setupScene();\n    \n    // pixelate\n    vec2 XY2 = XY - fract(XY / cPixelize) * cPixelize;\n    \n    vec2 xy = viewportFromScreen(XY2);\n    vec2 m  = viewportFromScreen(iMouse.xy);\n    \n    gUseMarching = XY.x < RES.x / 2.0;\n        \n    // setup camera\n    float theta     = (length(iMouse.xy) < 40.0 ? gT : 0.0) - m.x * pi;\n    vec3  lookTo    = vY * 1.5;\n    vec3  lookFrom  = vec3(cos(theta), 0.8 - 1.0 * m.y, sin(theta)) * 4.0;\n    // don't let camera go below the floor\n    lookFrom.y = max(0.1, lookFrom.y);\n    \n    // configure our initial ray for this pixel\n    ray_t r0;\n    r0.ro   = lookFrom;\n    r0.rd   = matLookTo(lookFrom, lookTo) * normalize(vec3(xy, -2.0));\n    r0.amt  = 1.0;\n    r0.side = 1.0;\n    QEnqueue(r0);\n    \n    gRGB = v0;\n    runRays();\n    \n    gRGB = pow(gRGB, vec3(1.0/2.2));\n    \n    // uncomment to view # of rays per pixel\n    // rgb = v1 * float(gRayCount) / float(cMaxRays);\n    \n    gRGB = mix(gRGB, vec3(0.4), 0.5 - 0.5 * step(3.0, abs(XY.x - RES.x/2.0)));\n\n    RGBA = vec4(gRGB, 1.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n#define ZERO   (0)\n\nconst float pi = 3.14159265359;\nconst vec3  v1 = vec3(1.0);\nconst vec3  v0 = vec3(0.0);\nconst vec3  vX = vec3(1.0, 0.0, 0.0);\nconst vec3  vY = vec3(0.0, 1.0, 0.0);\nconst vec3  vZ = vec3(0.0, 0.0, 1.0);\n\n//--------------------------------------------------------------------------------\n\nstruct ray_t {\n    vec3  ro;\n    vec3  rd;\n    float amt;   // [0, 1] amount of light left in the ray\n    float side;  // -1 = inside, 1 = outside.\n};\n\nstruct hit_t {\n    bool  hit;\n    float t;\n    vec3  pnt;\n    vec3  nrm;\n    uint  mtl;\n};\n\nstruct mapSample_t {\n    float dist;\n    uint mtl;\n};\n\nstruct mtl_t {\n    float ior;\n    float diffVsTrns;\n    vec3  color;\n};\n\nhit_t newHit() {\n    hit_t ret;\n    ret.hit = false;\n    ret.t   = 1e9;\n    return ret;\n}\n\n//--------------------------------------------------------------------------------\n\nconst float ior_air     =  1.0003;\nconst float ior_aerogel =  1.03;\nconst float ior_ice     =  1.309;\nconst float ior_water   =  1.333;\nconst float ior_quartz  =  1.46;\nconst float ior_diamond =  2.42;\nconst float ior_shiny1  =  4.0;    // ad hoc\nconst float ior_mrr     =  1e2;    // ad hoc\n\n\n//--------------------------------------------------------------------------------\n//  David Hoskins\n//  https://www.shadertoy.com/view/4djSRW\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// fifo queue.\n// This is a basic ringbuffer.\n// NO ERROR CHECKING\n//\n// usage:\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENTATION.\n// (Q_MAX_ENTRIES is a uint)\n//\n// for example:\n// #define Q_TYPE        ray_t\n// #define Q_MAX_ENTRIES 16u\n// Q_IMPLEMENTATION\n//\n// orion elenzil 2022.\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nuint QCount() {                                    \\\n    if (gQHead >= gQTail) {                        \\\n        return gQHead - gQTail;                    \\\n    }                                              \\\n    else {                                         \\\n        return gQNumSlots - (gQTail - gQHead);     \\\n    }                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n    return gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n    return QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n    return QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint QEnqueueIndex() {                             \\\n    gQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint QDequeueIndex() {                             \\\n    gQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n    gQ[QEnqueueIndex()] = item;                    \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n    return gQ[QDequeueIndex()];                    \\\n}\n////////////////////////////////////////////////////\n\n\n//--------------------------------------------------------------------------------\n\nmat3 matLookTo(in vec3 lookFrom, in vec3 lookTo) {\n    vec3 fw = -normalize(lookTo - lookFrom);\n    vec3 rt =  normalize(cross(fw, vY));\n    vec3 up =  cross(rt, fw);\n    \n    return mat3(rt, up, fw);\n}\n\nmat2 matRot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// returns false if there are no real roots.\n// returns true if there are one or two real roots.\n// roots.x <= roots.y.\nbool solveQuadratic(in vec3 coeffs, out vec2 roots) {\n    const uint A = 0u;\n    const uint B = 1u;\n    const uint C = 2u;\n    \n    // (-B +- sqrt(BB - 4AC)) / 2A\n    \n    float disc = (coeffs[B] * coeffs[B]) - (4.0 * coeffs[A] * coeffs[C]);\n    \n    if (disc < 0.0) {\n        return false;\n    }\n    \n    float sqrt_disc = sqrt(disc);\n    \n    roots.x = (-coeffs[B] - sqrt_disc) / (2.0 * coeffs[A]);\n    roots.y = (-coeffs[B] + sqrt_disc) / (2.0 * coeffs[A]);\n    \n    if (roots.y < roots.x) {\n        roots.xy = roots.yx;\n    }\n    \n    return true;\n}\n\n//--------------------------------------------------------------------------------\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvoid rayVsPlane(in ray_t ray, in vec3 n, in float d, uint mtl, inout hit_t hit) {\n    float t = -(dot(ray.ro, n) + d) / (dot(ray.rd, n));\n    if (t > 0.0 && t < hit.t) {\n        hit.hit = true;\n        hit.t   = t;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = n;\n    }\n}\n\n//--------------------------------------------------------------------------------\n\nvoid rayVsSphere(in ray_t ray, in vec3 c, float r, uint mtl, inout hit_t hit) {\n    \n    vec3 ro = ray.ro - c;\n    vec3 rd = ray.rd;\n\n    float A = dot(rd, rd);\n    float B = dot(ro, rd) * 2.0;\n    float C = dot(ro, ro) - (r * r);\n    \n    vec2 roots;\n    if (!solveQuadratic(vec3(A, B, C), roots)) {\n        return;\n    }\n    \n    if (roots.y < 0.0) {\n        // both hits are before the start of the ray\n        return;\n    }\n    \n    if (roots.x > 0.0) {\n        if (roots.x > hit.t) {\n            return;\n        }\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.x;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n    \n    if (roots.y < hit.t) {\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.y;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n}\n\n//--------------------------------------------------------------------------------\n\n// https://en.wikipedia.org/wiki/Schlick%27s_approximation\nfloat schlickR0(in float n1, in float n2) {\n    // same if n1 and n2 are swapped.\n    float q  = (n1 - n2) / (n1 + n2);\n    float q2 = q * q;\n    return q2;\n}\n\nfloat schlick(in float R0, in float cosTheta) {\n    float q  = 1.0 - cosTheta;\n    float q5 = q * q * q * q * q;\n    return R0 + ((1.0 - R0) * q5);\n}\n\n\n//--------------------------------------------------------------------------------\n// @Gijs\n// https://www.shadertoy.com/view/7dSSzy Basic : Less Simple Atmosphere\n\nvec3  SUN_COLOR = vec3(1.0,1.0,1.0);\nvec3  SKY_SCATTERING = vec3(0.1, 0.3, 0.7);\n// vec3  SUN_VECTOR;\nfloat SUN_ANGULAR_DIAMETER = 0.08;\nfloat CAMERA_HEIGHT = -0.3;\n\n\n// Consider an atmosphere of constant density & isotropic scattering \n// Occupying, in the y axis, from -infty to 0\n// This shaders ``solves'' that atmosphere analytically.\n\nfloat atmosphereDepth(vec3 pos, vec3 dir)\n{\n    return max(pos.y, 0.1)/ max(dir.y, 0.0);\n}\n\nvec3 transmittance(float l)\n{\n    return exp(-l * SKY_SCATTERING);\n}\n\nvec3 simple_sun(in vec3 dir, in vec3 lightDir)\n{\n    //sometimes |dot(dir, SUN_VECTOR)| > 1 by a very small amount, this breaks acos\n    float a = acos(clamp(dot(dir, lightDir),-1.0,1.0));\n    float t = 0.005;\n    float e = smoothstep(SUN_ANGULAR_DIAMETER*0.5 + t, SUN_ANGULAR_DIAMETER*0.5, a);\n    return SUN_COLOR * e;\n}\n\nvec3 simple_sky(in vec3 p, in vec3 d, in vec3 lightDir)\n{\n    float l = atmosphereDepth(p, d);\n    vec3 sun = simple_sun(d, lightDir) * transmittance(l);\n    float f = 1.0 - d.y / lightDir.y;\n    float l2 = atmosphereDepth(p, lightDir);\n    vec3 sk = simple_sun(lightDir, lightDir) * transmittance(l2) / f * (1.0 - transmittance(f*l));\n    return clamp(sun + sk, 0.0, 1.0);\n}\n\n///////////////////////////////////////////////////////\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame(in vec3 p, in vec3 b, in float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\nvoid opUnion(inout mapSample_t ms, float dist, uint mtl) {\n    if (dist < ms.dist) {\n        ms.dist = dist;\n        ms.mtl  = mtl;\n    }\n}\n\nvoid opUnion(inout float distA, float dist) {\n    distA = min(distA, dist);\n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}