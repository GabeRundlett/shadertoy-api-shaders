{
    "Shader": {
        "info": {
            "date": "1718345326",
            "description": "logo",
            "flags": 0,
            "hasliked": 0,
            "id": "lXK3W3",
            "likes": 3,
            "name": "coorp logo ",
            "published": 3,
            "tags": [
                "logo",
                "print",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 253
        },
        "renderpass": [
            {
                "code": "\n/*sourses https://www.shadertoy.com/view/stsXDl# https://www.shadertoy.com/view/lsBfRc and others*/\n\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\n\nconst int N = 6;\n\nfloat sdPoly( in vec2[N] v, in vec2 p )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n// Spectrum palette, iq https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return 1. - pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n#define PI 3.14159265359\n\n\n// MATRIX\n\nmat3 trs(vec2 t) {\n\treturn mat3(1, 0, t.x, 0, 1, t.y, 0, 0, 1);\n}\n\nmat3 rot(float a) {\n\treturn mat3(cos(a), -sin(a), 0, sin(a), cos(a), 0, 0, 0, 1);\n}\n\nmat3 scl(vec2 s) {\n\treturn mat3(s.x, 0, 0, 0, s.y, 0, 0, 0, 1);\n}\n\nfloat decomposeScale(mat3 m) {\n\tvec3 a = vec3(0) * m;\n\tvec3 b = vec3(1,0,0) * m;\n    return distance(a, b);\n}\n\n\n// MAIN\n\nfloat getCircle(vec2 p, vec2 rp){\n\tp *= vec2(iResolution.x, iResolution.y);\n    p /= max(iResolution.x, iResolution.y);\n    \n    return step(distance(p, rp), 0.1);\n}\nconst int count = 11;\nmat3 tiles[count];\n\nfloat h = sqrt(2.) / 2.;\n\nfloat sdTile(vec2 p) {\n    vec2[] poly = vec2[](\n    \tvec2(1., 0.),\n        vec2(2.5, 0),\n        vec2(1.5 - .25, -h / 2.),\n        vec2(1.5 - .25, -h / 2.),\n        vec2(1., -h),\n        vec2(.5, -h)\n    );\n\treturn sdPoly(poly, p);\n}\n\n//#define LOOP\n\nvec3 shadeTile(float d, float s, int i, int iteration) {\n    d = -d;\n    d *= iResolution.y * 2. / s;\n    d += .011 * iResolution.y;\n    //d += (.002 / s + .0008)  * iResolution.y;\n    d = clamp(d, 0., 1.) / 4.;\n    float t = float(i);\n    #ifdef LOOP\n        float time = mod(iTime / 3., 1.);\n        if (iteration > 0) {\n            t /= float(count);\n        } else {\n            t /= 3.;\n        }\n    \t//t *= 1.666;\n        t += time;\n    #else\n        if (iteration > 0) {\n            t /= float(count);\n            t = t * mix(1., 10., cos(iTime / 10.) * .5 + .5);\n        } else {\n            t /= 3.;\n        }\n        t += iTime / 3.;\n    #endif\n    vec3 col = d * spectrum(t);\n    return col;\n}\n\nbool drawTiles(inout vec2 p, inout vec3 col, inout float scale, int iteration) {\n    \n\tfloat scaleOut;\n    vec2 pOut;\n    bool hit = false;\n    \n    vec2 p2 = p;\n    float scale2 = scale;\n\n    for(int i = 0; i < count; i++ )\n    {\n        mat3 txm = tiles[i];\n        p = (vec3(p2, 1) * txm).xy;\n        scale = scale2 * decomposeScale(txm);\n\n        float d = sdTile(p);\n        col -= shadeTile(d, scale, i, iteration);\n\n        if (d < 0.) {\n            pOut = p;\n\t\t\tscaleOut = scale;\n            hit = true;\n        }\n        \n        if (iteration == 0 && i == 2) {\n        \tbreak;\n        }\n    }\n    \n    p = pOut;\n    scale = scaleOut;\n\n    return hit;\n}\n\nvec3 render(vec2 p) {\n\n    float scale = 1.;\n    vec3 col = vec3(1);\n\n    // recurse\n    for(int i = 0; i < 3; i++) {\n        if ( ! drawTiles(p, col, scale, i)) {\n            if (i == 0) {\n            \tcol = vec3(.8);\n            }\n            break;\n        }\n    }\n    \n    return col;\n}\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n\n    vec3 n1,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(g*.1),.8)*1./e/8e3\n    )\n    {\n        n1=g*d;\n       \n        a=30.;\n        n1=mod(n1-a,a*2.)-a;\n        s=2.;\n        for(int i=0;i++<8;){\n            n1=.3-abs(n1);\n            n1.x<n1.z?n1=n1.zyx:n1;\n            n1.z<n1.y?n1=n1.xzy:n1;\n            s*=e=1.4+sin(iTime*.1)*.1;\n            n1=abs(n1)*e-\n                vec3(\n                    5.+sin(iTime*.3+.5*sin(iTime*.3))*3.,\n                    70,\n                    4.+cos(iTime*.5)*5.\n                 );\n         }\n         g+=e=length(n1.xy)/s;\n    }\n          vec2 p = (2. * C - iResolution.xy) / iResolution.y;\n\tp *= .55;\n    p *= vec2(1,-1);\n    p -= vec2(-.5,h/2.);\n     vec2 uv =C/ vec2(iResolution.x, iResolution.y);\n    vec3 circle = getCircle(uv, vec2(0.5, 0.25)) * vec3(30.0, 12.0, 2.0) * 2.0;\n    // prepare matrices\n    \n    // tri\n    mat3 triOrigin = trs(vec2(-.5, sqrt(3.) / 6.)) * scl(vec2(3));\n    tiles[0] = triOrigin * trs(vec2(1., -h));\n    tiles[1] = triOrigin * rot(PI / 1.5) * trs(vec2(1., -h));\n    tiles[2] = triOrigin * rot(PI / -1.5) * trs(vec2(1., -h));\n    \n    // long\n    mat3 rect = trs(vec2(-3.5, h)) * scl(vec2(-1));\n    mat3 longOrigin = scl(vec2(3. / 1.5)) * trs(vec2(-5, 0)) * scl(vec2(-1, 1));\n    tiles[3] = longOrigin;\n    tiles[4] = tiles[3] * rect;\n    \n    // box\n    mat3 boxOrigin = trs(vec2(-.5, h)) * scl(vec2(1.5 / .25));\n    tiles[5] = boxOrigin * rot(PI / -3.);\n    tiles[6] = tiles[5] * rect*O.x;\n    tiles[7] = boxOrigin * trs(vec2(-1, 0)) * rot(PI / -3.);\n    tiles[8] = tiles[7] * rect*O.y;\n    tiles[9] = boxOrigin * trs(vec2(-2, 0)) * rot(PI / -3.);\n    tiles[10] = tiles[9] * rect*O.z;\n\n    \n    // draw\n    \n   \tvec3 col = render(p.xy);\n    col = pow(col, vec3(1./2.2)+circle);\n    O=vec4(col,1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}