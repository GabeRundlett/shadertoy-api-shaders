{
    "Shader": {
        "info": {
            "date": "1726355447",
            "description": "Empirical demo of  https://www.youtube.com/watch?v=ga9Qk38FaHM&t=1s .\nThanks Jonathan for pointing this out!\nThe surprising thing is that max(R1, R2) === sqrt(R). (in [0, 1])\nmouse.X => iterations per frame [1, 1000]\nmouse.Y => histogram bins [1, 201]",
            "flags": 32,
            "hasliked": 0,
            "id": "M3lcRS",
            "likes": 16,
            "name": "max(R1, R2) === sqrt(R)",
            "published": 3,
            "tags": [
                "random"
            ],
            "usePreview": 1,
            "username": "elenzil",
            "viewed": 228
        },
        "renderpass": [
            {
                "code": "/*\n\nEmpirical exploration of  https://www.youtube.com/watch?v=ga9Qk38FaHM&t=1s .\nThanks Jonathan for pointing this out!\nThe surprising thing is that max(R1, R2) === sqrt(R).\nmouse.X => iterations per frame [1, 1000]\nmouse.Y => histogram bins [1, 201]\n\n\nCommon  : Hash function/s, configuration, and utilities.\nBuffer A: Simulation.\nImage   : Rendering.\n\n*/\n\n\n// declarations for text-rendering\nfloat text_dist0(vec2);\nfloat text_dist1(vec2);\nfloat text_dist2(vec2);\nfloat text_dist3(vec2);\n\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    // IJ.x = histogram bin\n    // IJ.y = distribution index\n    ivec2 IJ  = ivec2(XY * vec2(float(BIN_COUNT)/RES.x, float(_DST_COUNT)/RES.y));\n    \n    vec4 buf = texelFetch(iChannel0, IJ, 0);\n    \n    \n    // Iterate over all bins in this histogram,\n    // finding the bin with the maximum count.\n    // We use this so that the bin with the maximum count\n    // is always at the top of the graph.\n    // This makes each distribution nicely visible,\n    // but does distort the overall probabilities when\n    // comparing one distribution to another.\n    // We also keep track of the sum of all the counts\n    // so that we can normalize the cumulative distribution.\n    \n    float maxCount = -1e9;\n    float sumCount = 0.0;\n    for (uint n = 0u; n < BIN_COUNT; ++n) {\n        ivec2 ij        = ivec2(n, IJ.y);\n        float binCount  = texelFetch(iChannel0, ij, 0).x;\n        maxCount        = max(maxCount, binCount);\n        sumCount       += binCount;\n    }\n    \n    // amount in the regular bin normalized to bin with the most\n    float normalizedCount_Dst = buf.x / maxCount;\n    \n    // amount in the CDF\n    float normalizedCount_CDF = buf.y / sumCount;\n\n    // Pixel Height of each distribution\n    float distHgt = RES.y / float(_DST_COUNT);\n    \n    // Bottom and Top pixels of this distribution\n    float distBot = distHgt * float(IJ.y    );\n    float distTop = distHgt * float(IJ.y + 1);\n        \n    // the maximum of each graph only goes to this percent of the full height\n    // of this distribution's section.\n    float margin = 0.8;\n    \n    // \"Y\" position of this pixel within its distribution\n    float normalizedPixelHeight  = xim(XY.y      , distBot, distTop) / margin;\n    // And a slightly higher one. this is used for the green caps.\n    float normalizedPixelHeight2 = xim(XY.y + 3.0, distBot, distTop) / margin;\n    \n    // Is the pixel above the bin's value ?\n    bool  pAbv1 = normalizedCount_Dst < normalizedPixelHeight;\n    \n    // Is is the pixel a little bit up above the bin's value ?\n    bool  pAbv2 = normalizedCount_Dst < normalizedPixelHeight2;\n    \n    // Start by coloring this pixel to be the gray bar.\n    RGBA.rgb = vec3(normalizedCount_Dst) * 0.3;\n    \n    // If the pixel is above the value, color it black\n    if (pAbv1) {\n        RGBA.rgb *= 0.0;\n    }\n    // Otherwise, what about the pixel a little further up ?\n    // If that one _is_ above the value, then we're at the top of the bar,\n    // give it a little green cap.\n    else if (pAbv2) {\n        RGBA.rgb = vec3(0.8, 1.0, 0.0) * 0.7;\n    }\n    \n    // dashed line at the peak of the chart.\n    // Same approach - if the pixel location is just right, draw the line.\n    float normalizedPixelHeight3 = xim(XY.y + 1.0, distBot, distTop) / margin;\n    if (normalizedPixelHeight3 >= 1.0 && normalizedPixelHeight < 1.0) {\n        if ((int(XY.x) / 10) % 2 == 0) {\n            RGBA.rgb = vec3(1) * 0.3;\n        }\n    }\n\n    \n    // draw purple CDF graph\n    bool  cdfIn1  = normalizedPixelHeight   < normalizedCount_CDF;\n    bool  cdfIn2 = normalizedPixelHeight2  < normalizedCount_CDF;\n    if (cdfIn1) {\n        float s = 0.2;\n        if (!cdfIn2) {\n            s = 0.8;\n        }\n        RGBA.rgb += vec3(0.3, 0.2, 0.4) * s;\n    }\n    \n    // frame around the edges\n    const float fw = 3.0;\n    vec3 frameColor = vec3(0.4, 0.8, 0.9) * 0.6;\n    vec2 xy = abs(XY - RES/2.0) * 2.0;\n    if (min(RES.x - xy.x, RES.y - xy.y) < fw * 2.0 || normalizedPixelHeight < fw * float(_DST_COUNT) / RES.y) {\n        RGBA.rgb = frameColor;\n    }\n    \n    //---------------------------------------------\n    // text labels\n    // This is the first time i've used text in a shader.\n    // Kishimisu's resource is pretty straight-forward to use!\n    \n    // create UV values for text\n    float normalizedPixelDist = xim(XY.x, 0.0, distHgt);   \n    vec2 textUV = vec2(normalizedPixelDist, normalizedPixelHeight);\n    textUV *= 0.2 * vec2(1.0, 0.8);\n    textUV += vec2(-0.01, 0.005);\n    textUV -= fw / RES.x;\n    \n    vec2 shadUV = textUV;\n    shadUV.x += -0.005 + sin(XY.y / RES.y * 99.0 + iTime) * 0.002;\n\n    float text;\n    int dist = int(XY.y / distHgt);\n    switch (dist) {\n        case 0: text = text_dist0(shadUV); break;\n        case 1: text = text_dist1(shadUV); break;\n        case 2: text = text_dist2(shadUV); break;\n        case 3: text = text_dist3(shadUV); break;\n    }\n    \n    RGBA.rgb = mix(RGBA.rgb, RGBA.rgb * 0.4, text);\n\n    vec2 tuv = textUV;\n    tuv.x += -0.005 + sin(XY.y / RES.y * 99.0 + iTime + 1.0) * 0.002;\n    tuv -= vec2(-1, 1) * 6.0 / RES.x;\n    switch (dist) {\n        case 0: text = text_dist0(tuv); break;\n        case 1: text = text_dist1(tuv); break;\n        case 2: text = text_dist2(tuv); break;\n        case 3: text = text_dist3(tuv); break;\n    }\n    RGBA.rgb = mix(RGBA.rgb, vec3(0.7), text);\n    \n    \n\n    // vignette\n    RGBA.rgb *= 1.0 - pow(LENGTHSQR(XY/RES - 0.5) * 1.5, 3.0);\n    \n    RGBA.a   = 1.0;\n}\n\n\n// crazy macros for text rendering.\nmakeStr(text_dist0) _U _n _i _f _o _r _m _end\nmakeStr(text_dist1) _R _1 __ _ADD __ _R _2 _end\nmakeStr(text_dist2) _m _a _x _LPR _R _1 _COM __ _R _2 _RPR _end\nmakeStr(text_dist3) _s _q _r _t _LPR _R _RPR _end\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\nCommon  : Hash function/s, configuration, and utilities.\nBuffer A: Simulation.\nImage   : Rendering.\n\n*/\n\n\n// true iff the given float falls within the given histogram bin.\nbool isInBin(float x, uint bin) {\n    float binEdgeLft = float(bin + 0u) * _BIN_WIDTH;\n    float binEdgeRgt = float(bin + 1u) * _BIN_WIDTH;\n    return x >= binEdgeLft && x < binEdgeRgt;\n    return x < binEdgeRgt;\n}\n\n// true iff the given float falls within or to the left of the given histogram bin.\nbool isInOrBelowBin(float x, uint bin) {\n    float binEdgeRgt = float(bin + 1u) * _BIN_WIDTH;\n    return x < binEdgeRgt;\n}\n\n//---------------------------------------------------------------------\n// mainImage() produces a texture output where:\n// * columns represent bins a histogram counting the number of times\n//   the distribution has landed in the bin.\n// * rows are the different distributions.\n// * .x component is count of times the random value landed in this bin.\n// * .y component is count of times the random value landed in this bin or lower.\n//   this is the \"CDF\" or \"cumulative distribution function\".\n//\n// so we only have data in the lower-left BIN_COUNT x _DST_COUNT pixels.\n//\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    uvec2 IJ = uvec2(XY);\n    \n    // what distribution and histogram bin does this pixel belong to ?\n    uint dst = IJ.y;\n    uint bin = IJ.x;\n\n    // do no work for pixels outside our range\n    if (dst >= _DST_COUNT) { discard; }\n    if (bin >= BIN_COUNT) { discard; }\n    \n\n    if (iFrame == 0 || iMouse.z > 1.0) {\n        // Reset at shader launch or if mouse is pressed\n        RGBA = vec4(0.0);\n    }\n    else {\n        // Load previous data\n        RGBA = texelFetch(iChannel0, ivec2(IJ), 0);\n    }\n\n    \n    // We generate a random number by hashing a value\n    // which is dependent on Time and Iteration.\n    // It's not really a PRNG 'seed', but it's similar.\n    uint seedCommon = uint(fract(iTime * 0.2) * 1e5);\n    \n    for (uint n = 0u; n < ITERS_PER_FRAME; ++n) {\n        uint seedIter = n * 1111u;\n        uint seed     = seedCommon ^ seedIter;\n\n        // three uniformly distributed random variables\n        float R1 = xxhash32f(seed ^ 12345u);\n        float R2 = xxhash32f(seed ^ 54321u);\n        float R3 = xxhash32f(seed ^ 76543u);\n        \n        // R will be out final random variable\n        float R;\n        \n        switch(dst) {\n            case 0u:\n                // Uniform distribution.\n                // like rolling one die.\n                R = R3;\n                break;\n            case 1u:\n                // Sum of two R's.\n                // This is similar to rolling two dice and summing.\n                R = (R1 + R2) / 2.0;\n                break;\n            case 2u:\n                // Larger of two R's.\n                // Roll two dice and choose the better one.\n                R = max(R1, R2);\n                break;\n            case 3u:\n                // Square root of R\n                // Roll one die and take the square root\n                R = sqrt(R3);\n                break;\n        }\n\n        // build the two histograms\n        \n        // increment .x if value lands in this bin\n        RGBA.x += float(isInBin       (R, bin));\n\n        // increment .y if value lands in this bin or lower\n        RGBA.y += float(isInOrBelowBin(R, bin));\n        \n        // increment count.\n        // this isn't really needed, because it === iFrame * ITERS_PER_FRAME.\n     //   RGBA.w += 1.0;    \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\nCommon  : Hash function/s, configuration, and utilities.\nBuffer A: Simulation.\nImage   : Rendering.\n\n*/\n\n\n//--------------------------------------------------------------\n// Knobs\n\n// Number of bins in histogram\n// mouse.Y => [1, 201] (always odd)\n#define BIN_COUNT ( uint(mUV.y * 201.0) / 2u * 2u + 1u )\n\n// Number of iterations per frame.\n// This can go fairly high because there are a lot of discard's.\n// mouse.X => [1, 1000]\n#define ITERS_PER_FRAME ( uint(mix(1.0, 1000.0, mUV.x)) )\n\n\n//--------------------------------------------------------------\n// Constants\n\n// how many different distributions we're doing\nconst uint  _DST_COUNT = 4u;\n// const float _BIN_WIDTH = 1.0 / float(BIN_COUNT);\n#define _BIN_WIDTH ( 1.0 / float(BIN_COUNT) )\n\n\n#define RES ( iResolution.xy )\n#define mXY ( length(iMouse.xy) > 50.0 ? iMouse.xy : vec2(RES/2.0) )\n#define mUV ( mXY / RES )\n\n//--------------------------------------------------------------\n\n// Convert a uint to a float in [0, 1].\n// Loses information.\nfloat U2F(uint a) {\n    return float(a) / float(0xffffffffu);\n}\n\n//--------------------------------------------------------------\n// Hash functions\n// From https://www.jcgt.org/published/0009/03/02/\n// xxhash (https://github.com/Cyan4973/xxHash)\n//   From https://www.shadertoy.com/view/Xt3cDn\nuint xxhash32(uint p)\n{\n\tconst uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n\tuint h32 = p + PRIME32_5;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\n// From https://www.jcgt.org/published/0009/03/02/\n// xxhash (https://github.com/Cyan4973/xxHash)\n//   From https://www.shadertoy.com/view/Xt3cDn\nuint xxhash32(uvec2 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n    uint h32 = p.y + PRIME32_5 + p.x*PRIME32_3;\n    h32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\n//--------------------------------------------------------------\n// Utilities\n\nfloat xxhash32f(uint p) {\n    return U2F(xxhash32(p));\n}\n\n// Inverse of mix()\nfloat xim(float x, float min, float max) {\n    return (x - min) / (max - min);\n}\n\n#define LENGTHSQR(a) ( dot((a), (a)) )\n\n\n\n//-----------------------------------------------------------------------\n// Everything below here is for text rendering.\n// TY Kishimisu ! https://www.shadertoy.com/user/kishimisu\n\n\n// From Kishimisu's \"Better Text in Shaders\"\n// https://www.shadertoy.com/view/43t3WX\n\n/*** Settings ***/\n\n#define FONT_TEXTURE iChannel3 // Set to the iChannel containing the alphabet texture\n\n#define FONT_SPACING 2.        // Horizontal character spacing [1 - 2.5]\n\n\n/* ### How to use this shader ? ###\n   \n   === Setup ===\n   \n   0. Copy the content of the \"Common\" tab inside your shader\n   1. Make sure the FONT_TEXTURE #define is set to the iChannel \n      containing the alphabet texture\n      \n      Also make sure the texture filter type is set to \"linear\"  \n      (not \"mipmap\", which creates horizontal lines between the characters)\n   \n   === Declare String ===\n   \n   2. Use makeStr to declare a new string (needs to be done outside any function)\n   3. Write your text using _ before each char, and __ for spaces\n   4. Finish your string with the _end keyword\n   \n       makeStr(printExample) _A _n _o _t _h _e _r __ _E _x _a _m _p _l _e    _end\n          \n   === Print String ===\n   \n   5. Call the new function by passing it your uvs. It returns a grayscale value.\n   \n       finalCol += printExample(uv);\n   \n   - Note that you are responsible for scaling/offsetting the uvs \n     to control the text placement before calling the function.\n   \n   - If you want to print float or integer variables, see below.\n   \n   \n   ###### Printing variables ######\n   \n   In order to print int & float variables, you can call two other functions instead of makeStr:\n   \n     - makeStrI (for integers) & makeStrF (for floats).\n     \n   [ IMPORTANT ]: When using makeStrI or makeStrF, you MUST use _endNum instead of _end \n                  to terminate a string.\n                  \n                  If you're seeing many errors when trying to compile, it's probably\n                  because you're using the wrong terminator for the current string type (_end/_endNum)\n   \n   === Declare Strings ===\n   \n   - In both cases, the variable will be displayed at the position of the _num_ keyword:\n   \n       makeStrI(print_my_int)   _M _y __ _I _n _t _e _g _e _r       _num_            _endNum\n       makeStrF(print_my_float) _F _l _o _a _t  _num_  _A _d _d _i _t _i _o _n _a _l _endNum\n   \n    - print_my_int   will be (vec2 uv, int num)\n    - print_my_float will be (vec2 uv, float num, int number_of_decimals)\n      \n   === Print Strings ===\n\n       print_my_int(uv, 42);          // will print \"My Integer 42\"\n       print_my_float(uv, 42.123, 2); // will print \"Float 42.12 Additional\"\n       \n    - A limitation of this version compared to the previous one is that you can only display\n      one variable per string definition (so only one _num_ keyword is allowed per string).\n   \n   === Debug variables without makeStr ===\n  \n   A handy thing you can do in your Image tab is to create \n   the following debugInt & debugFloat helpers:\n  \n       makeStrF(debugFloat) _num_ _endNum\n       makeStrI(debugInt) _num_ _endNum\n       \n   Defining these two helpers allow to quickly debug int/float variables, \n   without the need to create a full string definition every time using makeStr().\n \n      color += debugInt(uv, 42);\n      color += debugFloat(uv, 3.14, 2);\n \n \n   ### Characters available ###\n   \n   uppercase: _A _B _C ...\n   lowercase: _a _b _c ...\n   digits   : _0 _1 _2 ...\n   special  : _ADD _SUB _DOT ... (see \"Special Characters\" below)\n   \n   \n   ### Javascript string generator helper ###\n    \n    Even if this framework allow for easier string editing, it can still be a bit tedious to create\n    long strings with special characters, so I've also made a javascript function that you can run\n    in your developer console to easily create strings:\n\n    function createString(str) {\n        const special_chars = {\n            \" \": \"_\", \"!\": \"EX\", \"\\\"\":\"DBQ\", \"#\": \"NUM\", \"$\": \"DOL\", \"%\": \"PER\",  \"&\": \"AMP\", \n            \"\\'\":\"QT\", \"(\": \"LPR\", \")\": \"RPR\", \"*\": \"MUL\", \"+\": \"ADD\", \",\": \"COM\", \"-\": \"SUB\", \n            \".\": \"DOT\", \"/\": \"DIV\", \":\": \"COL\", \";\": \"SEM\", \"<\": \"LES\", \"=\": \"EQ\", \">\": \"GE\", \n            \"?\": \"QUE\", \"@\": \"AT\", \"[\": \"LBR\", \"\\\\\": \"ANTI\", \"]\": \"RBR\",  \"_\": \"UN\", \n        };\n        const num = str.indexOf('_num_');\n        const end = num == -1 ? ' _end' : ' _endNum';\n        str = str.replace('_num_', '').split('').map(e =>  '_' + (special_chars[e] || e));\n        if (num != -1) str = str.slice(0, num).concat( '_num_', str.slice(num));\n        return str.join(' ') + end;\n    }\n\n    Usage (static): \n        > createString(\"Hello World!\") \n        '_H _e _l _l _o __ _W _o _r _l _d _EX _end'\n           \n    Usage (variable): \n        > createString(\"My Number is _num_!\")\n        '_M _y __ _N _u _m _b _e _r __ _i _s __ _num_ _EX _endNum'\n*/\n\n// Special characters\n#define __    32,\n#define _EX   33, // \" ! \"\n#define _DBQ  34, // \" \" \"\n#define _NUM  35, // \" # \"\n#define _DOL  36, // \" $ \"\n#define _PER  37, // \" % \"\n#define _AMP  38, // \" & \"\n#define _QT   39, // \" ' \"\n#define _LPR  40, // \" ( \"\n#define _RPR  41, // \" ) \"\n#define _MUL  42, // \" * \"\n#define _ADD  43, // \" + \"\n#define _COM  44, // \" , \"\n#define _SUB  45, // \" - \"\n#define _DOT  46, // \" . \"\n#define _DIV  47, // \" / \"\n#define _COL  58, // \" : \"\n#define _SEM  59, // \" ; \"\n#define _LES  60, // \" < \"\n#define _EQ   61, // \" = \"\n#define _GE   62, // \" > \"\n#define _QUE  63, // \" ? \"\n#define _AT   64, // \" @ \"\n#define _LBR  91, // \" [ \"\n#define _ANTI 92, // \" \\ \"\n#define _RBR  93, // \" ] \"\n#define _UN   95, // \" _ \"\n\n// Digits\n#define _0 48,\n#define _1 49,\n#define _2 50,\n#define _3 51,\n#define _4 52,\n#define _5 53,\n#define _6 54,\n#define _7 55,\n#define _8 56,\n#define _9 57,\n// Uppercase\n#define _A 65,\n#define _B 66,\n#define _C 67,\n#define _D 68,\n#define _E 69,\n#define _F 70,\n#define _G 71,\n#define _H 72,\n#define _I 73,\n#define _J 74,\n#define _K 75,\n#define _L 76,\n#define _M 77,\n#define _N 78,\n#define _O 79,\n#define _P 80,\n#define _Q 81,\n#define _R 82,\n#define _S 83,\n#define _T 84,\n#define _U 85,\n#define _V 86,\n#define _W 87,\n#define _X 88,\n#define _Y 89,\n#define _Z 90,\n// Lowercase\n#define _a 97,\n#define _b 98,\n#define _c 99,\n#define _d 100,\n#define _e 101,\n#define _f 102,\n#define _g 103,\n#define _h 104,\n#define _i 105,\n#define _j 106,\n#define _k 107,\n#define _l 108,\n#define _m 109,\n#define _n 110,\n#define _o 111,\n#define _p 112,\n#define _q 113,\n#define _r 114,\n#define _s 115,\n#define _t 116,\n#define _u 117,\n#define _v 118,\n#define _w 119,\n#define _x 120,\n#define _y 121,\n#define _z 122,\n\n// ======  utils  ======\n\n#define print_char(i) \\\n    texture(FONT_TEXTURE, u + vec2(float(i)-float(x)/FONT_SPACING + FONT_SPACING/8., 15-(i)/16) / 16.).r\n\n// ======  makeStr()  ======\n\n// Function start\n#define makeStr(func_name)                               \\\n    float func_name(vec2 u) {                            \\\n        if (u.x < 0. || abs(u.y - .03) > .03) return 0.; \\\n        const int[] str = int[](                         \\\n\n// Function end\n#define _end  0);                                        \\\n    int x = int(u.x * 16. * FONT_SPACING);               \\\n    if (x >= str.length()-1) return 0.;                  \\\n    return print_char(str[x]);                           \\\n}\n\n\n// -------------------------------------------------------------------\n//    If you only plan to display static characters (no variables) \n//    you don't need to include anything below this disclaimer\n// -------------------------------------------------------------------\n\n// ======  makeStrFloat() & makeStrInt() ======\n\n#define log10(x) int(ceil(.4342944819 * log(x + x*1e-5)))\n#define _num_ 0); const int[] str2 = int[]( \n\n// makeStrFloat() start\n#define makeStrF(func_name)                              \\\n    float func_name(vec2 u, float num, int dec) {        \\\n        if (u.x < 0. || abs(u.y - .03) > .03) return 0.; \\\n        const int[] str1 = int[](\n\n// makeStrInt() start\n#define makeStrI(func_name)                              \\\n    float func_name(vec2 u, int num_i) {                 \\\n        if (u.x < 0. || abs(u.y - .03) > .03) return 0.; \\\n        float num = float(num_i);                        \\\n        const int dec = -1;                              \\\n        const int[] str1 = int[](\n\n// makeStrFloat & makeStrInt end\n#define _endNum  0);                            \\\n    const int l1 = str1.length() - 1;           \\\n    int x = int(u.x * 16. * FONT_SPACING);      \\\n    if (x < l1) return print_char(str1[x]);     \\\n    int neg = 0;                                \\\n    if (num < 0.) {                             \\\n        if (x == l1) return print_char(45);     \\\n        num = abs(num);                         \\\n        neg = 1;                                \\\n    }                                           \\\n    int pre = neg + max(1, log10(num));         \\\n    int s2 = l1 + pre + dec + 1;                \\\n    if (x >= s2) {                              \\\n        if (x >= s2+str2.length()-1) return 0.; \\\n        int n2 = str2[x - s2];                  \\\n        return print_char(n2);                  \\\n    }                                           \\\n    float d = float(l1 + pre - x);              \\\n    if (d == 0.) return print_char(46);         \\\n    d = pow(10., d < 0.  ? ++d : d);            \\\n    int n = 48 + int(10.*fract(num/.999999/d)); \\\n    return print_char(n);                       \\\n}\n\n/* === Curious about how makeStrI() and makeStrF() work ? ===\n\nHere is a broken-down and commented version of the following syntax:\n\n    makeStrF(print_string_with_float) _H _e _l _l _o _num_ _W _o _r _l _d _endNum\n    \nThis will translate exactly to the following code:\n\nfloat print_string_with_float(vec2 u, float num, int decimals) \n{\n    if (u.x < 0. || abs(u.y - .03) > .03) return 0.;\n    \n    // The number (num) will be displayed between these two strings.\n    // The separation is handled by the #define \"_num_\"\n    const int[] str1 = int[]( _H _e _l _l _o  0);\n    const int[] str2 = int[]( _W _o _r _l _d  0);\n    \n    const int str1_length = str1.length() - 1;\n    \n    int x = int(u.x * 16. * SPACING);\n    \n    // Print char from 1st string (before number)\n    if (x < str1_length) {\n        int n1 = str1[x];\n        return print_char(n1);\n    }\n    \n    // Handle negative numbers\n    int is_negative = 0;\n    if (num < 0.) {        \n        // Print a minus sign\n        if (x == str1_length) return print_char(45);\n        \n        num = abs(num);\n        is_negative = 1;\n    }\n        \n    int digit_count = is_negative + max(1, log10(num)); // Number of characters before decimal point\n    int num_length  = digit_count + decimals + 1;       // Total number of characters for the number\n    int str2_start  = str1_length + num_length;\n    \n    // Print char from 2nd string (after number)\n    if (x >= str2_start) {\n        const int str2_length = str2.length() - 1;\n        int n2 = str2[x - str2_start];\n        if (x >= str2_start + str2_length) return 0.; // right bound\n        return print_char(n2);\n    }\n        \n    // Print the decmial separator (dot)\n    if (x == str1_length + digit_count) {\n        return print_char(46);\n    }\n    \n    // Get current digit\n    int digit_index = x - str1_length;\n    if (digit_index > digit_count) {\n        // Offset by 1 for digits located after the decimal point\n        digit_index--;\n    }\n    float exponent = float(digit_count - digit_index);\n    int n = 48 + int(10.*fract(num/.999999/pow(10., exponent)));\n        \n    // Print digit\n    return print_char(n);\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}