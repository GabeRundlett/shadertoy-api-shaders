{
    "Shader": {
        "info": {
            "date": "1532079817",
            "description": "ulasm",
            "flags": 0,
            "hasliked": 0,
            "id": "MldcRM",
            "likes": 4,
            "name": "ulam primes spiral",
            "published": 3,
            "tags": [
                "ulam"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 464
        },
        "renderpass": [
            {
                "code": "\n//heavily optimized by ollj\n//only does a sieve, and not even to a full sqrt(n) sieve.\n\nfloat mi(vec2 a,float b){return mix(a.x,a.y,b);}\n\nfloat extract_bit(float n,float b\n){vec2 m=floor(vec2(n,b))\n ;return float(mod(floor(m.x/pow(2.,m.y)),2.)==1.);}\n\n\nfloat sprite(float n,vec2 p\n){p=floor(p)\n ;float bounds=float(all(lessThan(p,vec2(3,5)))&&all(greaterThan(p,vec2(-1))))//frame\n ;return extract_bit(n,(2.-p.x)+3.*p.y)*bounds;}\n\nfloat digitN(float n\n){if(n<4.){if(n<2.){return mix(31599.,9362.,step(1.,n));\n }else{return mix(29671.,29391.,step(3.,n));\n }}else{if(n<6.){return mix(23497.,31183.,step(5.,n));\n }else{if(n<8.){return mix(31215.,29257.,step(7.,n));\n }else{return mix(31727.,31695.,step(9.,n));\n }}}return 0.;}\n\nfloat digit(float n,vec2 p){return sprite(digitN(mod(floor(n),10.)),p);}\n\n\nfloat print_index(float a,vec2 b//index,position\n){float r=0.\n ;if(a<0.)r+=sprite(24.,b+vec2(4.,0.))\n ;for(float i=0.;i<8.;i++\n ){float place=pow(10.,i)\n  ;if(a >=place || i<1.){r+=digit(abs(a/place),b);b.x+=4.;}\n }return r;}\n\nfloat ulam_spiral(vec2 p\n){vec2 s=abs(p)\n ;float q=step(s.x,s.y)\n ;s.x=mix(s.x,s.y,q)\n ;s=vec2(s.x*2.,abs(p.x-p.y*(q*2.-1.))+4.*s.x*s.x+1.)\n ;vec3 b=mix(vec3(-s.x*2.,0,p.x),vec3(-s.x,s.x,p.y),q)\n ;return s.y+mi(b.xy,step(b.z,0.))\n ;}\n\nfloat sieveN(float n,float N\n){bool r=n!=0.\n ;for(float i=2.; i<N; i++\n ){if(r)r=(sqrt(2.+n)<=i||mod(n,i)>0.);}return float(r);}\n\nfloat little_sieve(float n){return sieveN(n,32.);}//good for primes up to 2048?\nfloat sieve(float n){return sieveN(n,sqrt(n));}\n\nvoid mainImage(out vec4 O,vec2 u\n){vec2 coordinate=u.xy-iResolution.xy*.5\n ;//ulam spiral\n ;float scale=16.\n ;vec2 field=floor(coordinate/scale)\n ;float ulam=ulam_spiral(field)\n //fun opt\n /*\n ;vec2 mouse_coordinate=floor((iMouse.xy*iResolution.xy-iResolution.xy*.5)/scale)\n ;float mouse_ulam=ulam_spiral(field-mouse_coordinate)\n ;ulam=floor(abs(ulam+mouse_ulam));\n /**/\n ;float offset=0.;\n //;offset=abs(floor(mod(iTime*8.,2048.))-ulam)*4.\n ;ulam+=offset\n ;ulam--\n ;offset=abs(floor(mod(iTime*8.,2048.))-ulam)\n ;float grid=float(mod(coordinate.x,scale)<1.)+ float(mod(coordinate.y+.5,scale)<1.)\n ;bvec4 quadrant=bvec4(false)\n ;quadrant.x=field.x>=max( 1.,abs(field.y)*sign(field.x))//>=max( 0.,abs(field.y)/sign(field.x))//division by sign is not a good idea!\n ;quadrant.y=field.y>=max( 0.,abs(field.x)*sign(field.y)+1.)\n ;quadrant.z=field.x<=min(-1.,abs(field.y)*sign(field.x))\n ;quadrant.w=field.y<=min(-1.,abs(field.x)*sign(field.y)-1.)\n ;vec2 print_coordinate=coordinate\n ;print_coordinate.x=mod(print_coordinate.x,scale)\n ;print_coordinate.y=mod(print_coordinate.y,scale)\n ;print_coordinate-=scale*.5\n ;vec3 print=vec3(print_index(ulam,print_coordinate-vec2(4.,-2.)))\n ;float seive=.5+little_sieve(ulam)\n ;//combined results for display\n ;vec4 result=vec4(0)\n ;result.xyz=vec3(quadrant.xyz)\n ;result.xy+=float(quadrant.w)\n ;result+=grid/4.\n //;if(offset<1.)result+=1.\n ;result.xyz+=print\n ;result*=seive\n ;result*=.5\n ;O=result\n //;O.w=1.\n ;}//sphinx\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}