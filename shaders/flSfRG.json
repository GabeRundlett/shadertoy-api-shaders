{
    "Shader": {
        "info": {
            "date": "1652345209",
            "description": "A simple test of reverse bilinear interpolation",
            "flags": 0,
            "hasliked": 0,
            "id": "flSfRG",
            "likes": 4,
            "name": "Quad interpolation test",
            "published": 3,
            "tags": [
                "quadinterpolation"
            ],
            "usePreview": 0,
            "username": "Suslik",
            "viewed": 357
        },
        "renderpass": [
            {
                "code": "vec2 SolveQuadratic(float A, float B, float C)\n{\n    float D = B * B - 4.0f * A * C;\n    if(D < 1e-5f) return vec2(-1.0f);\n    float sqrtD = sqrt(D);\n    return (vec2(-B) + vec2(-sqrtD, sqrtD)) / (2.0f * A);\n}\n\nvec2 SolveQuadraticOrLinear(float A, float B, float C)\n{\n    if(abs(A) > 1e-5f) return SolveQuadratic(A, B, C);\n    if(abs(B) > 1e-5f) return vec2(-C / B);\n    return vec2(-1.0f);\n}\n\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n//solves either of the two (depending which k[] is better)\n//c[0] + k[0] * x = 0;\n//c[1] + k[1] * x = 0;\nfloat SolveBestLinear(vec2 c, vec2 k)\n{\n    return abs(k[0]) > abs(k[1]) ? (-c[0] / k[0]) : (-c[1] / k[1]);\n}\n\n\n//solves system:\n//c[0] + mx[0] * rx + my[0] * ry + mxy[0] * rx * ry = 0;\n//c[1] + mx[1] * rx + my[1] * ry + mxy[1] * rx * ry = 0;\nvec2 SolveQuadratic2(\n    vec2 c, vec2 mx, vec2 my, vec2 mxy)\n{\n    vec2 rx = SolveQuadraticOrLinear(cross2(mxy, mx), cross2(mxy, c) + cross2(my, mx), cross2(my, c));\n    \n    vec2 uv;\n    uv.x = rx.x;\n    uv.y = SolveBestLinear(c + mx * uv.x, my + mxy * uv.x);\n    \n    //this part is stolen from iq's: https://www.shadertoy.com/view/lsBSDm\n    //as i simply gave up on the part that figures out which root to use\n    if(!(uv.x > 0.0f && uv.x < 1.0f && uv.y > 0.0f && uv.y < 1.0f))\n    {\n        uv.x = rx.y;\n        uv.y = SolveBestLinear(c + mx * uv.x, my + mxy * uv.x);\n    }\n    \n    return uv;\n}\n\n//p00 -- lower left, p01 -- lower right, p10 -- upper left, p11 -- upper right\nvec2 GetQuadInterpWeights(vec3 p00, vec3 p01, vec3 p10, vec3 p11, vec3 p)\n{\n    vec3 c = p00 - p;\n    vec3 mx = p01 - p00;\n    vec3 my = p10 - p00;\n    vec3 mxy = p00 - p01 + p11 - p10;\n    \n    vec3 proj0 = mx / (1e-7f + dot(mx, mx)); //these are arbitrary vectors hopefully not perpendicular to mx/my\n    vec3 proj1 = my / (1e-7f + dot(my, my)); //so might as well scale them to produce normalized products\n    \n    return SolveQuadratic2(\n        vec2(dot(c, proj0), dot(c, proj1)),\n        vec2(dot(mx, proj0), dot(mx, proj1)),\n        vec2(dot(my, proj0), dot(my, proj1)),\n        vec2(dot(mxy, proj0), dot(mxy, proj1)));\n}\n\nvec2 LoopBouncingBox(vec2 coord, vec2 box_size)\n{\n    vec2 phase2f = coord / box_size;\n    vec2 ratio = fract(phase2f);\n    vec2 phase_mirroring = floor(fract(phase2f * 0.5f) + 0.5f); //0.0f or 1.0f depending whether this period is mirrored\n    \n    return mix(ratio, vec2(1.0f) - ratio, phase_mirroring) * box_size;\n}\n\nfloat LineSdf(vec2 p0, vec2 p1, vec2 p)\n{\n    float dist = length(p0 - p);\n    dist = min(dist, length(p1 - p));\n    \n    vec2 delta = p1 - p0;\n    float sqrlen = dot(delta, delta);\n    float proj = dot(p - p0, delta);\n    \n    if(proj > 0.0f && proj < sqrlen)\n    {\n        vec2 proj_pos = p0 + delta * (proj / sqrlen);\n        dist = min(dist, length(proj_pos - p));\n    }\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 p00 = vec3(LoopBouncingBox(vec2(100.0f, 105.0f) + vec2(10.0f, 50.0f) * iTime, iResolution.xy), 0.0f);\n    vec3 p01 = vec3(LoopBouncingBox(vec2(100.0f, 105.0f) + vec2(90.0f, 40.0f) * iTime, iResolution.xy), 0.0f);\n    vec3 p10 = vec3(LoopBouncingBox(vec2(100.0f, 105.0f) + vec2(30.0f, 10.0f) * iTime, iResolution.xy), 0.0f);\n    vec3 p11 = vec3(LoopBouncingBox(vec2(100.0f, 105.0f) + vec2(150.0f, 50.0f) * iTime, iResolution.xy), 0.0f);\n    \n    /*p00 = vec3(100.0f, 100.0f, 0.0f);\n    p01 = vec3(410.0f, 100.0f, 0.0f);\n    p11 = vec3(400.0f, 200.0f, 0.0f);\n    p10 = vec3(100.0f, 200.0f, 0.0f);*/\n    \n    vec2 r = GetQuadInterpWeights(p00, p01, p10, p11, vec3(fragCoord, 0.0f));\n    \n    fragColor = vec4(0.5f);\n\n    if(r.x >= 0.0f && r.x <= 1.0f && r.y >= 0.0f && r.y <= 1.0f)\n        fragColor = vec4(fract(r), 0.0f, 1.0f);\n        \n    if(LineSdf(p00.xy, p01.xy, fragCoord.xy) < 2.0f) fragColor.rgb += vec3(0.5f);\n    if(LineSdf(p01.xy, p11.xy, fragCoord.xy) < 2.0f) fragColor.rgb += vec3(0.5f);\n    if(LineSdf(p11.xy, p10.xy, fragCoord.xy) < 2.0f) fragColor.rgb += vec3(0.5f);\n    if(LineSdf(p10.xy, p00.xy, fragCoord.xy) < 2.0f) fragColor.rgb += vec3(0.5f);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}