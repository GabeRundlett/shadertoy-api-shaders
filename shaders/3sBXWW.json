{
    "Shader": {
        "info": {
            "date": "1554021352",
            "description": "attractive & repulsive forces.\n\"GUI\" Slider Controls:\nL = Num\nR = Attr.\nT = Grav\nB = Wind",
            "flags": 32,
            "hasliked": 0,
            "id": "3sBXWW",
            "likes": 31,
            "name": "n^2 implicit collusion",
            "published": 3,
            "tags": [
                "collision",
                "simulation",
                "particles",
                "forces"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 759
        },
        "renderpass": [
            {
                "code": "// Implicit Collusion.\n// Orion Elenzil 2019\n// Collisions w/ attractive & repulsive forces.\n// Inspired by \"Particle Scattering\" by dr2.\n// https://www.shadertoy.com/view/wsjSW1\n// to re-make an ancient simulation.\n// Controls:\n// Left   = Num Particles\n// Right  = Attraction\n// Top    = Gravity\n// Bottom = A Spooky Wind\n\n#define bigF (10000000.0)\n#define VORONI_AMT 0.4\n\nconst float lineW    = 1.5;\nconst float partRad1 = partRad - (lineW);\nconst float partRad2 = partRad + (lineW);\n      float myTime;\n\nvoid mainImage( out vec4 fragColor, in vec2 XY )\n{\n    vec2 xy = XY.xy;\n    \n    vec4 params = texelFetch(iChannel0, ivec2(0, 0), 0);\n    float num = params.x;\n\n    vec3 rgb = vec3(0.0);\n    const vec3 fOff = vec3(0.0, 0.333, 0.666) * TWOPI;\n    \n    float dist = bigF;\n    for (float n = 0.0; n < num; n += 1.0) {\n        vec4 p = fetchParticle(n);\n        p.xy += iResolution.xy / 2.0;\n        float d = length(xy - p.xy);\n        if (d < dist) {\n            dist = d;\n            float f = n / num * TWOPI;\n            rgb = sin(vec3(f) + fOff) * 0.25 + 0.75;\n        }\n    //  dist = min(d, dist);\n    }\n    \n    float bright = 0.0;\n    bright = 0.4 * smoothstep(partRad2, partRad1, dist);\n    vec3 col = rgb * bright;\n    \n    float dOut = dist-partRad;\n    bright = 0.8 * smoothstep(lineW, 0.0, abs(dOut));\n    col = mix(col, vec3(1.0), bright);\n\n    float f = smoothstep(partRad * 10.0, 0.0, abs(dOut));\n    col = col + rgb * f * VORONI_AMT;\n\n    // now draw the \"UI\"\n    float uiVal;\n    float paramVal;\n    if (XY.x < GUTTER_WIDTH) {\n        col.bg += max(vec2(0.3, 0.2), col.bg);\n        paramVal = (params.x - MIN_PARTS) / (MAX_PARTS - MIN_PARTS);\n        paramVal = sqrt(clamp(paramVal, 0.0, 1.0)) * iResolution.y;\n        dist = abs(xy.y - paramVal);\n//        col  = mix(knobColor, col, );\n        col *= 1.0 + smoothstep(3.0, 1.0, dist);\n    }\n    else if (XY.x > iResolution.x - GUTTER_WIDTH) {\n        col.bg += max(vec2(0.3, 0.2), col.bg);\n        paramVal = (params.y - PULL_MIN) / (PULL_MAX - PULL_MIN);\n        paramVal *= iResolution.y;\n        dist = abs(xy.y - paramVal);\n        col *= 1.0 + smoothstep(3.0, 1.0, dist);\n    }\n    else if (XY.y < GUTTER_WIDTH) {\n        col.gb += max(vec2(0.3, 0.2), col.bg);\n        if (iMouse.z > GUTTER_WIDTH && iMouse.z < (iResolution.x - GUTTER_WIDTH) && iMouse.w < GUTTER_WIDTH) {\n\t        dist  = abs(XY.x - iMouse.x);\n            dist /= WIND_WIDTH;\n            dist  = 1.0 - (1.0 - dist) * (1.5 - XY.y /  GUTTER_WIDTH);\n\t        col *= 1.0 + smoothstep(1.0, 0.0, dist);\n        }\n    }\n    else if (XY.y > iResolution.y - GUTTER_WIDTH) {\n        col.r += max(0.3, col.b);\n        dist = abs(params.z - normToGrav(XY.x / iResolution.x));\n        dist /= abs(GRAV_MAX);\n        float f = 1.0;\n        if (abs(params.z) <= 0.01) {\n            f *= 0.3;\n        }\n        col *= 1.0 + f * smoothstep(3.0 / iResolution.x, 1.0 / iResolution.x, dist);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI         (3.14159265359)\n#define TWOPI      (2.0 * PI)\n\n#define PART_START_ROW 1\n#define GUTTER_WIDTH   25.0\n\nconst float partRad  = 5.0;\n\n#define fetchParticle(n) (texelFetch(iChannel0, ivec2(n, PART_START_ROW), 0))\n\n#define MIN_PARTS   3.0\n#define MAX_PARTS 500.0\n\n// attractive force\n#define PULL_MIN             0.0\n#define PULL_MAX           100.0\n#define PULL_FALLOFF_POWER   2.0\n\n// repulsive force\n#define PUSH           3000000.0\n#define PUSH_FALLOFF_POWER   5.0\n\n// friction coefficient (less is more)\n#define FRIC             0.98\n\n// gravity\n#define GRAV_MAX        -3.0\n\n// wind\n#define WIND_WIDTH     120.0\n#define WIND_STRENGTH    3.0\n\n#define NOISE_AMT                0.01\n#define INITIAL_CIRCLE_RAD       0.1\n\n\n\n\nfloat normToGrav(in float norm) {\n    return clamp(mix(1.0, GRAV_MAX, norm), GRAV_MAX, 0.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Implicit Collusion.\n// Orion Elenzil 2019\n// Collisions w/ attractive & repulsive forces.\n// Inspired by \"Particle Scattering\" by dr2.\n// https://www.shadertoy.com/view/wsjSW1\n// to re-make an ancient simulation.\n// Controls:\n// Left   = Num Particles\n// Right  = Attraction\n// Top    = Gravity\n// Bottom = A Spooky Wind\n\n\n// this is a hack for stability,\n// but it gives rise to lots of unrealistic behavior\n#define MAX_SPEED        2.0\n\nfloat gPull = 40.0;\nint   gNum  = 20;\nfloat gGrav = 0.0;\n\nvec2 rand(in vec2 co){\n    float sd1 = sin(dot(co.xy ,vec2(12.9898,78.233)));\n    float sd2 = sin(dot(co.yx ,vec2(52.9898,98.233)));\n    return fract(vec2(sd1, sd2) * 43758.5453);\n}\n\nvec2 calcAcc(in vec2 self, in vec2 other) {\n    vec2  vSO = other - self;\n    float dSO = length(vSO);\n    dSO = clamp(dSO, 0.001, 1e20);\n    float f = 0.0;\n    f += gPull / pow(dSO, PULL_FALLOFF_POWER);\n    f -= PUSH / pow(dSO, PUSH_FALLOFF_POWER);\n    return f * vSO / dSO;\n}\n\n\nvec2 calcAcc(int skip, in vec2 pos) {\n    vec2 ret = vec2(0.0);\n    \n    for (int n = 0; n < skip; ++n) {\n        ret += calcAcc(pos, fetchParticle(n).xy);\n    }\n    for (int n = skip + 1; n < gNum; ++n) {\n        ret += calcAcc(pos, fetchParticle(n).xy);\n    }\n    \n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 XY )\n{\n    ivec2 IJ      = ivec2(XY);\n    \n    if (IJ.y > 1) {\n        discard;\n    }\n\n    vec4 p = texelFetch(iChannel0, ivec2(0, 0), 0);\n    gNum   = int(p.x);\n    gPull  = p.y;\n    gGrav  = p.z;\n\n    // this is my first time storing stuff like parameters in a buffer,\n    // and also with implementing a \"UI\" of any sort.\n    // .. at least i hope that's why this code is so gruesome!\n    \n    p = texelFetch(iChannel0, IJ, 0);\n    bool doPhysics = true;\n    bool doClamp   = true;\n    \n    if (iFrame == 0 || iMouse.z > 0.0) {\n        if (iFrame == 0 || iMouse.z < GUTTER_WIDTH) {\n            // re-init particles\n\t        doPhysics = false;\n\n            float num = 19.0;\n            if (iMouse.z > 0.0) {\n                float f = iMouse.y / iResolution.y;\n                f = f * f;\n                num = floor(mix(MIN_PARTS, MAX_PARTS, f));\n            }\n\n            if (IJ == ivec2(0, 0)) {\n                p.x = num;\n                if (iFrame == 0) {\n                    p.y = 40.0;\n                    p.z = 0.0;\n                }\n            }\n            else {\n                float f      = XY.x / num;\n                float theta  = f * TWOPI;\n                p.xy         = vec2(cos(theta), sin(theta)) * 0.5 * iResolution.xy;\n                p.xy        *= INITIAL_CIRCLE_RAD;\n                p.x         *= iResolution.y / iResolution.x;\n                p.wz         = vec2(0.0);\n            }\n        }\n        else if (iMouse.z > iResolution.x - GUTTER_WIDTH) {\n            // attractive force\n            if (IJ == ivec2(0, 0)) {\n                p.y = mix(PULL_MIN, PULL_MAX, iMouse.y / iResolution.y);\n            }\n        }\n        else if (   iMouse.z > GUTTER_WIDTH\n                 && iMouse.z < iResolution.x - GUTTER_WIDTH\n                 && iMouse.w > iResolution.y - GUTTER_WIDTH) {\n            // gravity\n            if (IJ == ivec2(0, 0)) {\n                p.z = normToGrav(iMouse.x/iResolution.x);\n            }\n        }\n        else if (iMouse.w > GUTTER_WIDTH && IJ == ivec2(0, 1)) {\n            // drag around particle zero\n            p.xy = iMouse.xy - iResolution.xy * 0.5;\n            p.wz = vec2(0.0);\n            doClamp = false;\n        }\n    }\n    \n    doPhysics = doPhysics && IJ.y > 0;\n    doPhysics = doPhysics && IJ.x < gNum;\n    \n    if (doPhysics) {\n        \n        // wind\n        vec2 wind = vec2(0.0);\n        if (iMouse.z > GUTTER_WIDTH && iMouse.z < iResolution.x - GUTTER_WIDTH && iMouse.w > 0.0 && iMouse.w < GUTTER_WIDTH) {\n            float d = abs((iMouse.x - iResolution.x / 2.0) - p.x);\n            d = max(0.0, WIND_WIDTH - d) / WIND_WIDTH;\n            wind.y = d * WIND_STRENGTH;\n        }\n\n        // a little noise for lubrication\n        vec2 noise = (1.0 - 2.0 * rand(p.xy + iTime + p.wz)) * NOISE_AMT;\n        \n        vec2 acc = calcAcc(IJ.x, p.xy);\n        p.wz += acc;\n        // clamp speed due to acc.\n        float speed = length(p.wz) + 0.0001;\n        p.wz *= min(speed, MAX_SPEED) / speed;\n        \n        p.z  += gGrav;\n        p.wz += noise;\n        p.wz *= FRIC;\n        p.xy += wind;\n        \n        p.xy += p.wz;\n        \n        if (doClamp) {\n            p.xy  = max(iResolution.xy * -0.5 + partRad * 2.0, p.xy);\n            p.xy  = min(iResolution.xy *  0.5 - partRad * 2.0, p.xy);\n        }\n        \n        /*\n        // not sure where the NaN is coming from,\n        // but at least we can fix it.\n        if (isnan(p.x + p.y + p.w + p.z)) {\n            p.xy = vec2(XY.x / 500.0 - 0.5);\n            p.zw = vec2(0.0);\n        }\n\t\t*/\n    }\n    \n    fragColor = p;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}