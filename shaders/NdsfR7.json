{
    "Shader": {
        "info": {
            "date": "1644631105",
            "description": "i was inspired from this gif https://twitter.com/incre_ment/status/1492288142258282496\n(the uncolored version is a perfect loop every 4 seconds)",
            "flags": 0,
            "hasliked": 0,
            "id": "NdsfR7",
            "likes": 5,
            "name": "bouncing balls",
            "published": 3,
            "tags": [
                "marching",
                "loop",
                "analyticalbouncing"
            ],
            "usePreview": 0,
            "username": "xnio94",
            "viewed": 304
        },
        "renderpass": [
            {
                "code": "#define pi 3.14\n\n#ifdef HW_PERFORMANCE\n    #if HW_PERFORMANCE==0\n    #define AA 1.\n    #else\n    #define AA 2.   // make this 2 or 3.. for better antialiasing\n    #endif\n#else\n#define AA 1.\n#endif\n\nconst float MAXD = 100.;\nconst float MAXSHD = 4.5;\nconst float MAXRD = 15.;\nfloat t;\n// 2d rotation\nvec2 rot(vec2 p, float r) {\n\tfloat c = cos(r), s = sin(r);\n\treturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}\nfloat dcube( vec3 p, float b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n//dh hight\n//a phase 0 to 1\nfloat bounce(float dh,float a)\n{\n    if (dh==0.) return 0.;\n    float g=10.;\n    float v0 = sqrt(dh*4.*g);\n    float t = mod(iTime + a*v0/g+ 0.*v0/g,v0/g); \n    return -g*t*t+v0*t;\n}\nvec4 opu(vec4 a,vec4 b){ return (a.x<b.x) ? a : b;}\nvec4 map(vec3 p)\n{\n    vec3 blue = vec3(.7,.7,.9); //normalize(vec3(.3,.4,.8));\n    vec3 pink = vec3(1.,.8,.9);\n    vec3 q=p;\n    p.x=mod(p.x,4.)-2.;\n    float s = (q.x-p.x)/4.-.5;\n\tvec3 u = p;   \n    float x = mod(iTime*4. ,4.);\n    float r = 1.;\n\n\n    vec4 plan = vec4(p.y,blue-.1);\n    vec4 cube = vec4(10., blue*.3-.1 +.5*vec3(1.,sin(s*77.+49.)*.5+.5,sin(s*33.)*.5+.5)*.3+.7 ) ;\n    cube.x = dcube(p - vec3(0., .65, 0.),.65);\n    \n    \n    float h = bounce(10./4.,.5); //period =1.\n    \n    \n    vec4 ball = vec4(0. ,pink);\n    ball.x = length(p - vec3(x,r+h,0.))-r;\n    \n    vec4 ball2 = vec4(0. ,pink);\n    ball2.x = length(p - vec3(x-4.,r+h,0.))-r;\n        \n\n    \n    vec4 o = opu(ball, ball2);\n    o = opu(o, plan);\n    o = opu(o, cube);\n    \n    \n    //o.yzw = vec3(1.,.8,.9); //color \n    \n    return o;//vec4(d,1.,0.,0.);\n}\n//simple raymarch\nvec4 rayMarch(vec3 rO, vec3 rD)\n{   \n    float d = 0.;\n    vec4 D;\n    for (int i = 0; i<130 &&  d < MAXD; i++)\n    {\n        D = map(rO + rD * d);\n        //d += D.x;\n        if (D.x > .5)  d += D.x*.5;   else d += D.x;\n        if (D.x < 3e-4)  break;\n    }\n    return vec4(d, D.yzw);\n}\n\n//to learn about normal using sdf\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p)\n{\n    vec2 N = vec2(0., 1e-2);\n    return normalize(vec3(map(p-N.yxx).x, map(p-N.xyx).x, map(p-N.xxy).x));\n}\nvec3 simpleSky(vec3 p){   \n    return vec3(.5,.6,1.-p.y);\n}\n// you can learn more about soft shadows in this article https://iquilezles.org/articles/rmshadows\nfloat shadows(vec3 or, vec3 lD)\n{\n    const float k = 1.5;\n    float res = 1.;\n    float t = 0.;\n    for (int i = 0; i < 40; i++)\n    {\n        float d = map(or + lD*t).x;\n        res = min(res, .5 + d * k / t);\n        if (res < .01|| t > MAXSHD) break;\n        t += d;\n    }\n    res = max(res, 0.);\n    return smoothstep(.3, 1., res);\n}\nvec4 render(in vec2 fragCoord )\n{\n    float fov = iResolution.x;\n    vec2 uv = fragCoord - iResolution.xy / 2.;\n    uv = uv - .5;\n    uv /= fov;\n    float ww=1.+ t*.05;\n    vec3 dis = vec3(iTime,2.,0.);\n    vec3 or = vec3(-1.,.5, 1.)*16.+dis;\n    //or.y = 20.;\n    //or.y-=17.5;\n    vec3 w = normalize(vec3(0.,0.,0.)-or+dis);\n    vec3 u = normalize(cross(w, vec3(0., 1., 0.)));\n    vec3 v = cross(u, w);\n    vec3 rD = normalize(w*1.5+uv.x*u+uv.y*v);\n\t   \n    vec4 d = rayMarch(or, rD);\n    vec3 col = vec3(0,0,0);\n    \n    if (d.x < MAXD)\n    {\n        vec3 p = or + d.x * rD;\n    \tvec3 nrm = normal(p);\n        vec3 sun = -normalize(vec3(.4, 2., .8));\n        \n        col = vec3(dot(sun,nrm)) *d.yzw;\n        //col *= d.yzw; //colloring\n        col *= vec3(shadows(p - sun * 0.01, -sun));\n\n    }\n    else \n    {\n        col = simpleSky(rD);\n    }\n    \n    return vec4(col,1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n    t = iTime*2.25; // globale time\n    for(float a=0.;a<AA;a++)\n        fragColor += render(fragCoord + a/AA);\n    fragColor /=AA;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}