{
    "Shader": {
        "info": {
            "date": "1718306558",
            "description": "Click on the screen to override the incident point animation. Play around with any parametric function without worrying about derivatives.",
            "flags": 0,
            "hasliked": 0,
            "id": "M3GGD3",
            "likes": 8,
            "name": "Differential Geometry 2",
            "published": 3,
            "tags": [
                "parametric",
                "sms",
                "differential",
                "catacaustic",
                "evolute",
                "orthotomic",
                "mnee"
            ],
            "usePreview": 0,
            "username": "KylBlz",
            "viewed": 137
        },
        "renderpass": [
            {
                "code": "\n/*\n\nThis one is fully numerical, feel free to play around inside any_fn()\nNotice there is no reflect() or any ray tracing in here.\n\nThe green shape is your input function\nThe blue shape is the orthotomic of the function and incident point.\nThe orange shape is the catacaustic, the envelope of all reflections\n\nNumerical instabilities are cropping up but they don't look too bad\nLooking into Paniq's Dual Automatic Differentiation shader\n\n*/\n\n\n\n// start with any explicit parametric function\nfloat tMin = -1.0;\nfloat tMax = 1.0;\n\nvec2 any_fn(in float t) {\n    // lets play around near the focus of a parabola\n    return vec2(\n        t*t,\n        (2.0 - EPS)*t\n    );\n}\n\n// draw any parametric function using numerical evaluation\nfloat density = 20.0;\n\nvec3 graphAnyFunction(in vec3 col, in vec2 ndc, in float lm, in float lw, in vec2 p) {\n\n    // draw this many bundle rays and line segments\n    float tStep = (tMax - tMin - EPS) / density;\n\n    //*/ draw tangent bundles\n    for (float t = tMin; t < tMax; t += tStep) {\n        \n        // 7 taps!\n        vec2 tm3 = any_fn(t-3.0*EPS);\n        vec2 tm2 = any_fn(t-2.0*EPS);\n        vec2 tm1 = any_fn(t-EPS);\n        vec2 t_0 = any_fn(t);\n        vec2 tp1 = any_fn(t+EPS);\n        vec2 tp2 = any_fn(t+2.0*EPS);\n        vec2 tp3 = any_fn(t+3.0*EPS);\n        \n        // use our explicit parametric function as input\n        vec2 any_fn_0t = t_0;\n        // numerically calculate d/dt fn(t) using finite difference\n        vec2 any_fn_1t = fn_d1(tm1, tp1);\n        // numerically calculate evolute of our explicit parametric function\n        vec2 any_fn_evolute_0t = evolute(tm1, t_0, tp1);\n        // numerically calculate d/dt evolute(t) using finite difference\n        vec2 any_fn_evolute_1t = fn_d1(\n            evolute(tm2, tm1, t_0), \n            evolute(t_0, tp1, tp2)\n        );\n        // numerically calculate orthotomic of our explicit parametric function\n        vec2 any_fn_orthotomic_0t = orthotomic(tm1, t_0, tp1, p);\n        // numerically calculate the catacaustic\n        vec2 any_fn_catacaustic_0t = evolute(\n            orthotomic(tm2, tm1, t_0, p),\n            orthotomic(tm1, t_0, tp1, p),\n            orthotomic(t_0, tp1, tp2, p)\n        );\n        // numerically calculate catacaustic first derivative\n        vec2 any_fn_catacaustic_1t = fn_d1(\n            evolute(\n                orthotomic(tm3, tm2, tm1, p),\n                orthotomic(tm2, tm1, t_0, p),\n                orthotomic(tm1, t_0, tp1, p)\n            ),\n            evolute(\n                orthotomic(tm1, t_0, tp1, p),\n                orthotomic(t_0, tp1, tp2, p),\n                orthotomic(tp1, tp2, tp3, p)\n            )\n        );\n\n        // graph function tangent bundle\n        //col = mix(vec3(0.0, 0.6, 0.0), col, 0.8 + 0.2 * smoothstep(lm, lw, sd_line( ndc, any_fn_1t, any_fn_0t )));\n        // graph evolute tangent bundle\n        //col = mix(vec3(1.0, 0.0, 0.0), col, 0.8 + 0.2 * smoothstep(lm, lw, sd_line( ndc, any_fn_evolute_1t, any_fn_evolute_0t )));\n        // graph incident bundle\n        col = mix(vec3(1.0, 0.5, 0.7), col, 0.6 + 0.4 * smoothstep(lm, lw, sd_line( ndc, any_fn_0t - p, p )));\n        // graph orthotomic envelope of curvatures\n        col = mix(vec3(0.0, 0.0, 1.0), col, 0.8 + 0.2 * smoothstep(lm, lw, sd_circle( ndc, any_fn_0t, distance(any_fn_0t, p) )));\n        // graph catacaustic tangent bundle where the dot is positive with the evolute\n        col = mix(vec3(1.0, 0.7, 0.5), col, 0.6 + 0.4 * smoothstep(lm, lw, sd_line( ndc, any_fn_catacaustic_1t, any_fn_catacaustic_0t )));\n        \n    }//*/\n    \n    float lastT = tMin;\n    // 5 taps!\n    vec2 fm2 = any_fn(lastT-2.0*EPS);\n    vec2 fm1 = any_fn(lastT-EPS);\n    vec2 f_0 = any_fn(lastT);\n    vec2 fp1 = any_fn(lastT+EPS);\n    vec2 fp2 = any_fn(lastT+2.0*EPS);\n    \n    // begin point of envelope line segment\n    vec2 last_any_fn = f_0;\n    vec2 last_any_fn_evolute = evolute(fm1, f_0, fp1);\n    vec2 last_any_fn_orthotomic = orthotomic(fm1, f_0, fp1, p);\n    vec2 last_any_fn_catacaustic = evolute(\n        orthotomic(fm2, fm1, f_0, p),\n        orthotomic(fm1, f_0, fp1, p),\n        orthotomic(f_0, fp1, fp2, p)\n    );\n    \n    //*/ draw envelopes\n    for (float t = tMin; t < tMax; t += tStep) {\n        \n        // 5 taps!\n        vec2 tm2 = any_fn(t-2.0*EPS);\n        vec2 tm1 = any_fn(t-EPS);\n        vec2 t_0 = any_fn(t);\n        vec2 tp1 = any_fn(t+EPS);\n        vec2 tp2 = any_fn(t+2.0*EPS);\n        \n        // use our explicit parametric function as input\n        vec2 any_fn_0t = t_0;\n        // numerically calculate the evolute of our explicit parametric function\n        vec2 any_fn_evolute_0t = evolute(tm1, t_0, tp1);\n        // numerically calculate the orthotomic of our explicit parametric function\n        vec2 any_fn_orthotomic_0t = orthotomic(tm1, t_0, tp1, p);\n        // numerically calculate the catacaustic\n        vec2 any_fn_catacaustic_0t = evolute(\n            orthotomic(tm2, tm1, t_0, p),\n            orthotomic(tm1, t_0, tp1, p),\n            orthotomic(t_0, tp1, tp2, p)\n        );\n        \n        // graph function envelope a little bolder\n        col = mix(vec3(0.0, 0.6, 0.0), col, smoothstep(lm * 2.0, lw * 2.0, sd_segment( ndc, last_any_fn, any_fn_0t )));\n        // graph evolute function envelope\n        //col = mix(vec3(1.0, 0.0, 0.0), col, smoothstep(lm, lw, sd_segment( ndc, last_any_fn_evolute, any_fn_evolute_0t )));\n        // graph orthotomic function envelope\n        col = mix(vec3(0.0, 0.0, 1.0), col, smoothstep(lm, lw, sd_segment( ndc, last_any_fn_orthotomic, any_fn_orthotomic_0t )));\n        // graph catacaustic function envelope, lazily filter out the discontinuity (it's supposed to be there)\n        if (distance(last_any_fn_catacaustic, any_fn_catacaustic_0t) < 10.0)\n            col = mix(vec3(1.0, 0.6, 0.0), col, smoothstep(lm, lw, sd_segment( ndc, last_any_fn_catacaustic, any_fn_catacaustic_0t )));\n\n        last_any_fn = any_fn_0t;\n        last_any_fn_evolute = any_fn_evolute_0t;\n        last_any_fn_orthotomic = any_fn_orthotomic_0t;\n        last_any_fn_catacaustic = any_fn_catacaustic_0t;\n        \n    }//*/\n    \n    return col;\n}\n\n\n\n// aspect, zoom, etc\nvec2 setupViewport(in vec2 fragCoord, in float zoom) {\n    // ndc with aspect\n    vec2 ndc = fragCoord/iResolution.xy * 2.0 - 1.0;\n    ndc.x *= iResolution.x / iResolution.y;\n    // graph zoom\n    return ndc * zoom;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // set up viewport\n    float zoom = PI;\n    vec2 ndc = setupViewport(fragCoord, zoom);\n\n    // AA line width\n    float px = zoom / iResolution.x;\n    float lw = 5.0 * px;\n    float lm = max(lw - px * 5.0, 0.0);\n    \n    // blank canvas\n    vec3 col = vec3(1.0);\n    \n    // graph axes\n    col = min(col, smoothstep(lm, lw, distance( ndc, ndc*vec2(1.0, 0.0) )));\n    col = min(col, smoothstep(lm, lw, distance( ndc, ndc*vec2(0.0, 1.0) )));\n    // graph lighter grid lines\n    col = min(col, 0.8 + 0.2 * smoothstep(lm * 2.0, lw * 2.0, fract(distance( ndc, ndc*vec2(1.0, 0.0) ))));\n    col = min(col, 0.8 + 0.2 * smoothstep(lm * 2.0, lw * 2.0, fract(distance( ndc, ndc*vec2(0.0, 1.0) ))));\n\n    // incident point P animation\n    vec2 p = vec2(2.0 + cos(iTime), sin(iTime) * 0.5);\n    // input from user mouse\n    if (iMouse.z > 0.0 || iMouse.w > 0.0) {\n        p = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n        p.x *= iResolution.x / iResolution.y;\n        p *= zoom;\n    }\n    \n    col = graphAnyFunction(col, ndc, lm, lw, p);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float EPS = (1.0 / 128.0);\nconst float PI =  3.141592;\nconst float TAU = 6.283185;\n\nfloat wedge(in vec2 a, in vec2 b) {\n    return a.x*b.y - b.x*a.y;\n}\n\n// drawing utilities\n\nfloat sd_segment(vec2 xy, vec2 pt1, vec2 pt2) {\n    vec2 a = pt2 - pt1;\n\tvec2 b = xy - pt1;\n\tfloat h = dot(b, a) / dot(a, a);\n\treturn length(b - clamp(h, 0.0, 1.0) * a);\n}\n\nfloat sd_line(vec2 xy, vec2 m, vec2 b) {\n    vec2 c = xy - b;\n    float h = dot(c, m) / dot(m, m);\n    return length(c - h * m);\n}\n\nfloat sd_circle(vec2 xy, vec2 c, float r) {\n    return abs(distance(xy, c) - r);\n}\n\n// differential geometry toolkit\n\n// finite difference degree 1, fn_i should be fn(t - EPS), fn_f should be fn(t + EPS)\nvec2 fn_d1(in vec2 fn_i, in vec2 fn_f) {\n    return 0.5 * (fn_i - fn_f) / EPS;\n}\n\n// finite difference degree 2, fn_i should be fn(t - EPS), fn should be fn(t), fn_f should be fn(t + EPS)\nvec2 fn_d2(in vec2 fn_i, in vec2 fn, in vec2 fn_f) {\n    return (((fn_i - fn) / EPS) - ((fn - fn_f) / EPS)) / EPS;\n}\n\n// Evolute curve: locus of centers of curvature (sitches between envelopes of tangents and normals), is its own inverse.\n// implementation started from here: https://mathworld.wolfram.com/Evolute.html\n// https://resources.wolframcloud.com/FunctionRepository/resources/EvoluteCurve\n\n// this version takes derivatives explicitly\nvec2 _evolute(in vec2 d0, in vec2 d1, in vec2 d2) {\n    float d1s = dot(d1, d1);\n    float norm = 1.0 / wedge(d1, d2);\n    return d0 + vec2(-d1s, d1s) * d1.yx * norm;\n}\n\n// this version numerically differentiates given 3 taps of the function.\nvec2 evolute(in vec2 fn_i, in vec2 fn, in vec2 fn_f) {\n    return _evolute(fn, fn_d1(fn_i, fn_f), fn_d2(fn_i, fn, fn_f));\n}\n\n// Orthotomic curve: locus of reflections from point source illuminating parametric curve.\n// Implementation derived starting from here: https://mathworld.wolfram.com/PedalCurve.html\n// https://resources.wolframcloud.com/FunctionRepository/resources/Orthotomic\n// WARNING, INCORRECT SOURCE: https://mathworld.wolfram.com/Orthotomic.html\n\n// this version takes derivatives and incident point P\nvec2 _orthotomic(in vec2 d0, in vec2 d1, in vec2 p) {\n    vec2 d1s = d1 * d1;\n    vec2 d1yx = d1.yx * d1;\n    float norm = 1.0 / (d1s.x + d1s.y);\n    vec2 petal = p * d1s + d0 * d1s.yx + (p.yx - d0.yx) * d1yx;\n    return 2.0 * petal * norm - p;\n}\n\n// this version numerically differentiates given 3 taps of the function.\nvec2 orthotomic(in vec2 fn_i, in vec2 fn, in vec2 fn_f, in vec2 p) {\n    return _orthotomic(fn, fn_d1(fn_i, fn_f), p);\n}\n\n// Inverse Orthotomic Curve: takes envelope of reflections and point source, reconstructs reflecting surface\n// Same as above, start here: https://mathworld.wolfram.com/NegativePedalCurve.html\n// https://resources.wolframcloud.com/FunctionRepository/resources/NegativePedalCurve\n\n// this version takes derivatives and incident point P\nvec2 _inverseOrthotomic(in vec2 d0, in vec2 d1, in vec2 p) {\n    vec2 pd = d0 - p;\n    vec2 N = d0 - p*d1;\n    float norm = N.x - N.y;\n    vec2 iPetal =  ((pd*pd).yx - pd*d0) * d1.yx + (2.0*d0 - p) * pd.yx * d1;\n    return 0.5 * (vec2(-1.0, 1.0) * ( iPetal / norm ) + p);\n}\n\n// this version numerically differentiates given 3 taps of the function.\nvec2 _inverseOrthotomic(in vec2 fn_i, in vec2 fn, in vec2 fn_f, in vec2 p) {\n    return _inverseOrthotomic(fn, fn_d1(fn_i, fn_f), p);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}