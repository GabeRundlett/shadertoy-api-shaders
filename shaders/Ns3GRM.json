{
    "Shader": {
        "info": {
            "date": "1629413088",
            "description": "Draws a star shape onto the torus surface using local uv coordinates (orange) and onto the screen (black). When the conformal map is used, the pointy ends of the triangles match exactly. Bottom left shows inside, top right shows outside of torus.",
            "flags": 0,
            "hasliked": 0,
            "id": "Ns3GRM",
            "likes": 7,
            "name": "Conformal Torus Stars",
            "published": 3,
            "tags": [
                "torus",
                "conformal"
            ],
            "usePreview": 0,
            "username": "pyBlob",
            "viewed": 310
        },
        "renderpass": [
            {
                "code": "/*\nhttps://en.wikipedia.org/wiki/Conformal_map\n    \"In mathematics, a conformal map is a function that locally preserves angles\"\n    \"The transformation is conformal whenever the Jacobian at each point is\n        a positive scalar times a rotation matrix.\"\n\nIdea:\n    The two vectors of the jacobian of a torus parameterized using uv angles\n    are orthogonal. It remains to scale one of them to arrive at a scaled rotation\n    matrix.\n\nMouse:\n    - conformal (default) vs naive (click)\n\nStars:\n    - Black: fixed screen coordinates\n    - Orange: local uv on torus surface\n\nSymmetries:\n    - Rotation along y axis (-> only sample uv.u = 0)\n    - Mirror along xz plane (-> only sample uv.v > 0)\n\nDerivation of exact conformal warp formula at end of common tab.\n\nUsing 4-space:\n    mla: https://www.shadertoy.com/view/tdGfzz\n\nSimilar formula using atan:\n    FabriceNeyret2: https://www.shadertoy.com/view/sdd3R4\n\n*/\n\nfloat warp(float b, vec2 torus)\n{\n    float rm = torus.x / torus.y;\n    float fp = sqrt(rm + 1.);\n    float fn = sqrt(rm - 1.);\n    \n    return 2. * atan(fn * tan(b / 2.), fp) / (fn * fp);\n}\n\nbool star(vec2 uv, float r, float s)\n{\n    float w = fract(atan(uv.y, uv.x) / tau * 8.);\n    bool star = any(lessThan(vec2(w, 1.-w), vec2(s))) && length(uv) < r;\n    return star;\n}\n\nvoid slice(inout vec4 C, in vec2 O, float a)\n{\n    vec2 torus = vec2(5., 1.5);\n\n    vec3 rd = normalize(vec3(O * f, 1.));\n    vec3 ro = vec3(0, 0, -torus.r);\n    \n    rd.yz *= R(a);\n    ro.yz *= R(a);\n    \n    ro.y += torus.x;\n\n    float t = mTorus(ro, rd, torus);\n    if (t > 0.)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 normal = nTorus(pos, torus);\n        float light = clamp(.2 + dot(normal, -rd), 0., 1.);\n        float fog = smoothstep(1. + 2. * torus.x, 1., t);\n\n        vec2 v1 = pos.xy;\n        vec2 v2 = vec2(pos.z, length(pos.xy) - torus.x);\n        vec2 ab = vec2(atan(v1.x, v1.y), atan(v2.x, v2.y));\n\n        // cmod and wmod moves uv origin to screen center\n        vec2 uv_naive = vec2(\n            ab.x,\n            cmod(ab.y - (a - radians(90.)), tau)\n        ) * vec2(20., 5.5) / tau;\n\n        vec2 uv_conformal = vec2(\n            ab.x,\n            wmod(warp(ab.y, torus), warp(a - radians(90.), torus), torus)\n        ) * 20. / tau;\n        \n        vec2 uv;\n        uv = uv_naive;\n        if (iMouse.z <= 0.)\n            uv = uv_conformal;\n\n        bvec2 bchecker = lessThan(fract(uv), vec2(.5));\n        bool checker = bchecker.x != bchecker.y;\n        C = vec4(1) * fog * light * mix(.2, .4, checker);\n\n        if (star(uv, .5, .1))\n            C = vec4(1, .5, 0, 1);\n        if (star(O, .2 * res.y, .05))\n            C = vec4(0, 0, 0, 1);\n    }\n}\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    vec2 N = vec2(6, 3);\n    float a = N.x * N.y, b = N.y;\n    res = iResolution.xy / N;\n    f = 1. / res.y;\n\n    vec2 view = floor(O / res);\n    O = mod(O, res);\n    float id = (view.x / a + view.y / b) * (a + 1.) / a;\n\n    if (any(lessThan(vec4(O, res - O), vec4(1))))\n    {\n        C = vec4(0);\n        return;\n    }\n\n    C = vec4(0);\n    float AA = 4.;\n    for (vec2 x=vec2(0) ; x.y<AA ; ++x.y)\n    for (x.x=0. ; x.x<AA ; ++x.x)\n    {\n        vec4 c = vec4(.2, .5, 1, 1);\n        slice(c, O - res / 2. + x / AA - .5, radians(mix(-90., 90., id)));\n        C += c;\n    }\n    C /= AA * AA;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float f;\nvec2 res;\n\nconst float pi = radians(180.);\nconst float tau = 2. * pi;\n\nfloat cmod(float x, float f)\n{\n    if (x < -f / 2.)\n        x += tau;\n    if (x > f / 2.)\n        x -= tau;\n    return x;\n}\n\nfloat halfwarp(vec2 torus)\n{\n    float rm = torus.x / torus.y;\n    float fp = sqrt(rm + 1.);\n    float fn = sqrt(rm - 1.);\n\n    return pi / (fn * fp);\n}\n\nfloat wmod(float a, float shift, vec2 torus)\n{\n    float hw = halfwarp(torus);\n    a -= shift;\n    if (a > hw)\n        a -= 2.*hw;\n    if (a < -hw)\n        a += 2.*hw; \n    return a;\n}\n\nmat2 R(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat mTorus(in vec3 ro, in vec3 rd, in vec2 tor)\n{\n    float t = 0.;\n    for (int i=0 ; i<100 ; ++i)\n    {\n        vec3 p = ro + t * rd;\n        float d = length(vec2(length(p.xy) - tor.x, p.z)) - tor.y;\n        t += d;\n        if (t > 10. * tor.x)\n            return -1.;\n    }\n    return t;\n}\n\nfloat iTorus(in vec3 ro, in vec3 rd, in vec2 tor)\n{\n    // f(x) = (|x|² + R² - r²)² - 4·R²·|xy|² = 0\n    // https://www.shadertoy.com/view/4sBGDy\n    float po = 1.0;\n    \n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n\t\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n\n    // bounding sphere\n    {\n        float h = n*n - m + (tor.x+tor.y)*(tor.x+tor.y);\n        if( h<0.0 ) return -1.0;\n        //float t = -n-sqrt(h); // could use this to compute intersections from ro+t*rd\n    }\n    \n\t// find quartic equation\n    float k = (m - ra2 - Ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*rd.z*rd.z + k;\n    float k1 = k*n + Ra2*ro.z*rd.z;\n    float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    #if 1\n    // prevent |c1| from being too close to zero\n    if( abs(k3*(k3*k3 - k2) + k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n\t#endif\n\n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n\t\n    float h = R*R - Q*Q*Q;\n    float z = 0.0;\n    if( h < 0.0 )\n    {\n    \t// 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );\n    }\n    else\n    {\n        // 2 intersections\n        float sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n        z = sign(R)*abs( sQ + Q/sQ );\n    }\t\t\n    z = c2 - z;\n\t\n    float d1 = z   - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    if( abs(d1) < 1.0e-4 )\n    {\n        if( d2 < 0.0 ) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if( d1 < 0.0 ) return -1.0;\n        d1 = sqrt( d1/2.0 );\n        d2 = c1/d1;\n    }\n\n    //----------------------------------\n\t\n    float result = 1e20;\n\n    h = d1*d1 - z + d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=t1; \n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    h = d1*d1 - z - d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=min(result,t1);\n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    return result;\n}\n\nvec3 nTorus(in vec3 pos, vec2 tor)\n{\n    // df(x)/dx\n    // https://www.shadertoy.com/view/4sBGDy\n\treturn normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\n/*\nDerivation of the warp function:\n\nParametric torus (+x-zero, xz-plane, y-up):\n\n    R a = mat2 (cos a) (-sin a)\n               (sin a) ( cos a)\n    \n    mat3_xz f (mat2 xx xz\n                    zx zz) = mat3 xx 0 xz\n                                   0 f  0\n                                  zx 0 zz\n    \n    torus u v =\n            (vec3 r_inner 0 0 * R_v + vec3 r_outer 0 0) * R_u\n        where\n            R_u = mat3_xz 1 (R u)\n            R_v = mat3_xy 1 (R v)\n\nTangents:\n\n    W a = D 0 R a\n        = mat2 (-sin a) (-cos a)\n               ( cos a) (-sin a)\n\n    d0 u v\n        = D 0 torus u v\n        = (vec3 r_inner 0 0 * R_v + vec3 r_outer 0 0) * W_u\n        where\n            W_u = mat3_xz 0 (W u)\n\n    d1 u v\n        = D 1 torus u v\n        = vec3 r_inner 0 0 * W_v * R_u\n        where\n            W_v = mat3_xy 0 (W v)\n\nTangents rotated by \"inverse R_u\":\n\n    T = W u * inverse (R u)\n      = mat2 (-sin u) (-cos u)\n             ( cos u) (-sin u) * mat2 ( cos u) (sin u)\n                                      (-sin u) (cos u)\n      = mat2 0 (-1)\n             1   0\n\n    d0' u v\n        = D 0 torus u v                                     * inverse R_u\n        = (vec3 r_inner 0 0 * R_v + vec3 r_outer 0 0) * W_u * inverse R_u\n        = (vec3 r_inner 0 0 * R_v + vec3 r_outer 0 0) * mat3_xz T\n        =  vec3     (r_inner * cos v + r_outer) (r_inner * sin v) 0 * mat3_xz T\n        =  vec3 0 0 (r_inner * cos v + r_outer)\n\n    d1' u v\n        = D 1 torus u v                * inverse R_u\n        = vec3 r_inner 0 0 * W_v * R_u * inverse R_u\n        = vec3 r_inner 0 0 * W_v\n        = vec3 (-r_inner * sin v) (r_inner * cos v) 0\n\n    -- good: d0' and d1' are trivially orthogonal\n    dot (d0' u v) (d1' u v)\n        = dot (vec3 0 0 _) (vec3 _ _ 0)\n        = 0\n    \n    -- bad: d0' and d1' have different lengths in most places\n    length (d0' u v) = r_inner * cos v + r_outer\n    length (d1' u v) = r_inner\n    \n    --> naive map is not conformal\n\nConformal warp function:\n\n    conformal_torus u V =\n            (vec3 r_inner 0 0 * R_v + vec3 r_outer 0 0) * R_u\n        where\n            R_u = mat3_xz 1 (R u)\n            R_v = mat3_xy 1 (R v)\n            v = unwarp V\n\n    -- d0' does not change when warping v\n    conformal_d0' u V = d0' u (unwarp V)\n    \n    -- d1' scales when warping v\n    conformal_d1' u V = d1' u (unwarp V) * D 0 unwarp V\n\n    length (conformal_d0' u V) = r_inner * cos (unwarp V) + r_outer\n    length (conformal_d1' u V) = r_inner * D 0 unwarp V\n    \n    -- solve for derivative of unwarp using equal lengths\n    D 0 warp V = r_outer / r_inner + cos (unwarp V)\n    \n    -- we have this function:\n    unwarp V = v\n    \n    -- but texturing needs this:\n    warp v = V\n    \n    -- when r_outer > r_inner, unwarp is inverse of warp:\n    unwarp (warp v) = v\n\n    -- when r_outer > r_inner, derivatives are related by reciprocal:\n    D 0 warp v = 1 / D 0 unwarp (warp v)\n               = 1 / (r_outer / r_inner + cos (unwarp (warp v)))\n               = 1 / (r_outer / r_inner + cos v)\n\nFinally integrate (D 0 warp v) from 0..v:\n\n    d_warp a v = 1 / (a + cos v)\n    \n    -- by lookup in clever program\n    integrate 0 (d_warp a) 0 v =\n            2 * atan (fn * tan (v / 2) / fp) / (fn * fp)\n        where\n            fn = sqrt (a - 1)\n            fp = sqrt (a + 1)\n\n    warp v = integrate 0 (D 0 warp) 0 v\n           = integrate 0 (d_warp (r_outer / r_inner)) 0 v\n\nSome warp evaluations:\n\n    unwarp 0 = 0\n    D 0 unwarp 0 = r_outer / r_inner + cos (unwarp 0)\n                 = r_outer / r_inner + 1\n    warp 0 = 0\n    warp pi = pi / (fn * fp)\n    warp -pi = -pi / (fn * fp)\n\n*/\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}