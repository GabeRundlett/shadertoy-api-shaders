{
    "Shader": {
        "info": {
            "date": "1455764060",
            "description": "See if you can herd the sheep into a tight circle in the middle of the field. I saw a dog do it once. You're better than a dog right?",
            "flags": 48,
            "hasliked": 0,
            "id": "XsG3Rd",
            "likes": 34,
            "name": "Shepherd Drone",
            "published": 3,
            "tags": [
                "sheep"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 2370
        },
        "renderpass": [
            {
                "code": "//Shepherd Drone by eiffie\n//This shader has bugs left but you get the gist. I wanted to march thru 100s of autonomous\n//creatures without testing the distance to each one individually.\n//It was inspired by various works...\n//This MV uses a cut scene of sheep, i guess i found it cute https://www.youtube.com/watch?v=4OrCA1OInoo\n//Iapafoto's Interactive Fish Shoal https://www.shadertoy.com/view/ldd3DB\n//Cellular Automata Particle Field by alleycatsphinx https://www.shadertoy.com/view/MdGGzG\n//There was also a shader (i think by Dave Hoskins) of ants. (can't find it now)\n//I used ideas from each. As long as the sheep aren't forced onto the same pixel it works fine.\n\n//needs more march steps\n#define MARCH_STEPS 16\n#define PI 3.14159\n//quad and capsule by iq\nfloat Quadric(in vec3 p,in vec4 r){return (dot(p*r.xyz,p)-r.w)/length(2.0*r.xyz*p);}\nfloat CapsuleY(in vec3 p, vec3 r){return length(vec3(p.x,p.y-clamp(p.y,r.x,r.y),p.z))-r.z;}\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\n\nfloat DE(in vec3 p, in vec2 c, in vec4 o){\n\tp.xz-=c+o.xy;\n\tfloat a=atan(o.z,o.w);\n\tp.xz=rotate(p.xz,PI-a);\n\to.zw=normalize(o.zw);\n\tfloat langle=sin(dot(o.zw,o.xy)*4.0*PI)*0.5; //leg angle NOT CORRECT!\n\tp*=5.0;\n\tfloat d1=length(p)-1.0;\n\tp.z-=1.0+langle*0.2;\n\td1=min(d1,length(p-vec3(langle*0.2,0.55,0.88))-0.1);\n\tfloat d2=length(p)-1.0;\n\tp.z+=1.75+langle*0.1;\n\tp.y-=0.9+langle*0.1;\n\td2=min(d2,Quadric(p,vec4(1.0,1.0,0.5,0.25)));\n\tp.x=abs(p.x)-0.5;\n\tfloat d3=length(p-vec3(0.0,0.3,0.3))-0.05;\n\tp.z-=1.25;\n\tp.y+=1.5;\n\tp.z=abs(p.z)-0.9;\n\tp.zy=rotate(p.zy,langle);\n\td3=min(d3,CapsuleY(p,vec3(-1.0,0.0,0.15)));\n\tfloat k=8.0;\n\tfloat d=-log(exp(-k*d1)+exp(-k*d2)+exp(-k*d3))/k;\n\treturn d/5.0;\n}\n\nfloat DEShad(in vec3 p, in vec2 c, in vec4 o){\n\tp.xz-=c+o.xy;\n\tfloat a=atan(o.z,o.w);\n\tp.xz=rotate(p.xz,PI-a);\n\tp*=5.0;\n\tfloat d1=length(p)-1.0;\n\tp.z-=1.0;\n\tfloat d2=length(p)-1.0;\n\tfloat k=8.0;\n\tfloat d=-log(exp(-k*d1)+exp(-k*d2))/k;\n\treturn d/5.0;\n}\n\nvec2 bx_cos(vec2 a){return clamp(abs(mod(a,8.0)-4.0)-2.0,-1.0,1.0);}//chebyshev rotation kekeke\nvec2 bx_cossin(float a){return bx_cos(vec2(a,a-2.0));}\nfloat bx_length(vec2 p){return max(abs(p.x),abs(p.y));}\nbool exists(vec4 c){return (c.x>-1.5);}\n#define T(x) texture(iChannel0,(x)/iResolution.xy)\nfloat minp(float x,float y){return (x<0.0?y:min(x,y));}\nfloat abox(vec2 p, vec2 rd, vec2 s){//distance to inside of box\n\tvec2 t0=(-s-p)/rd,t1=(s-p)/rd;\n\treturn minp(t0.x,minp(t0.y,minp(t1.x,minp(t1.y,1000.0))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv=(fragCoord-iResolution.xy*0.5)/iResolution.x;\n\tvec4 st=texture(iChannel0,vec2(103.5)/iResolution.xy); //state of camera \n\tfloat h=sin(iTime+sin(iTime*0.7));\n\tvec3 ro=vec3(st.x,4.0+h,st.y);\n\tvec3 rd=vec3(uv.x,-1.0,uv.y);\n\trd.yz=rotate(rd.yz,1.1-h*0.1);\n\trd.xz=rotate(rd.xz,st.z+sin(iTime*0.9)*0.1);\n\trd=normalize(rd);\n\t\n\tfloat maxt=(-0.36-ro.y)/rd.y,mint=(0.4-ro.y)/rd.y;\n\tfloat t=mint,d,od=1.0,md=1.0;\n\tfloat ft=abox(ro.xz-vec2(50.0),rd.xz,vec2(50.0));\n\t\n\tfor(int i=0;i<MARCH_STEPS;i++){\n\t\tvec3 p=ro+rd*t;\n\t\tvec2 c=floor(p.xz);\n\t\tfloat e=abox(fract(p.xz)-vec2(0.5),rd.xz,vec2(0.5));\n\t\tc+=vec2(0.5);\n\t\tvec4 o=T(c);\n\t\td=e+0.5;\n\t\tif(o.x>-2.5 && max(abs(p.x-50.0),abs(p.z-50.0))<50.0){\n\t\t\tif(exists(o))d=min(d,DE(p,c,o));\n\t\t\tfor(float i=0.0;i<8.0;i+=1.0){//rotate around a box with 'radius' 1\n\t\t\t\tvec2 v=bx_cossin(i); //direction to check\n\t\t\t\tvec4 n=T(c+v); //the sheep in that direction\n\t\t\t\tif(exists(n))d=min(d,DE(p,c+v,n));//like voronoi sheep\n\t\t\t}\n\t\t}\n\t\tt+=d;\n\t\tmd=min(md,d);\n\t\tif(d<0.002 || t>maxt)break;\n\t\tod=d;\n\t}\n\tt=min(t,maxt);\n\tvec3 p=ro+rd*(maxt-0.06);\n\tvec3 col=texture(iChannel1,p.xz*0.001).rgb*0.5+texture(iChannel1,p.xz*0.01).rgb*vec3(0.6,0.5,0.2)+vec3(0.0,0.2,0.0);\n\tvec3 c2=texture(iChannel1,p.xz*0.2).rgb;\n\tp=ro+rd*(maxt-0.03);\n\tc2+=texture(iChannel1,p.xz*0.2).rgb;\n\tp=ro+rd*maxt;\n\tc2+=texture(iChannel1,p.xz*0.2).rgb;\n\tcol+=c2*0.2;\n\tcol*=vec3(0.4)*clamp(md*56.0,0.0,1.0);\n\tif(maxt>ft){\n\t\tvec3 p2=ro+rd*ft;\n\t\tif(p2.y<0.4){\n\t\t\tp2.xz=abs(fract(p2.xz*0.5)*2.0-0.5);\n\t\t\tp2.y=abs(abs(p2.y)-0.2);\n\t\t\tcol=mix(vec3(0.9),col,smoothstep(0.0,0.04,p2.y-0.05));\n\t\t\tcol=mix(vec3(0.6),col,smoothstep(0.0,0.04,min(p2.x,p2.z)-0.05));\n\t\t}\n\t}\n\t//cheap?? shadow\n\tvec2 c=floor(p.xz)+vec2(0.5);\n\tvec4 o=T(c);\n\tfloat d2=100.0;\n\tif(o.x>-2.5 && max(abs(p.x-50.0),abs(p.z-50.0))<50.0){\n\t\tif(exists(o))d2=min(d2,DEShad(p,c,o));\n\t\tfor(float i=0.0;i<8.0;i+=1.0){//rotate around a box with 'radius' 1\n\t\t\tvec2 v=bx_cossin(i); //direction to check\n\t\t\tvec4 n=T(c+v); //the sheep in that direction\n\t\t\tif(exists(n))d2=min(d2,DEShad(p,c+v,n));//like voronoi sheep\n\t\t}\n\t}\n\tcol*=clamp(d2*d2*17.0,0.0,1.0);\n//to debug \"exists\" red=no sheep within 1st shell, blue=there is, green=a sheep here (still buggy)\n#if 0\n\tif(o.x<-2.5)col=vec3(1.0,0.0,0.0);\n\telse if(o.x<-1.5)col=vec3(0.0,0.0,1.0);\n\telse if(max(abs(o.x),abs(o.y))>0.5)col=vec3(1.0,0.0,1.0);\n#endif\n\tif(d<0.002){\n\t\tcol=vec3(clamp(1.0-abs(d/od),0.0,1.0));\n\t}\n\tfragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define ACCEL_RATE 0.5*iTimeDelta\n#define TURN_RATE 2.0*iTimeDelta\n\n#define KEY_UP 38\n#define KEY_DOWN 40\n#define KEY_LEFT 37\n#define KEY_RIGHT 39\n\n#define PI 3.14159\nbool KeyDown(in int key){\n\treturn (texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x>0.5);\n}\nvec2 bx_cos(vec2 a){return clamp(abs(mod(a,8.0)-4.0)-2.0,-1.0,1.0);}\nvec2 bx_cossin(float a){return bx_cos(vec2(a,a-2.0));}\nfloat bx_length(vec2 p){return max(abs(p.x),abs(p.y));}\nbool exists(vec4 c){return (c.x>-1.5);}\nvec4 T(vec2 u){return (min(u.x,u.y)<0.5 || max(u.x,u.y)>99.5?vec4(0.5,0.5,0.0,0.0):texture(iChannel0,u/iResolution.xy));}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tif(max(abs(fragCoord.x-103.5),abs(fragCoord.y-103.5))<0.5){//flight controls\n\t\tvec4 st=vec4(50.0,50.0,0.0,0.0);\n        if(iFrame>1){\n            st=texture(iChannel0,fragCoord/iResolution.xy);\n\t\t\tif(KeyDown(KEY_UP))st.w+=ACCEL_RATE;\n\t\t\tif(KeyDown(KEY_DOWN))st.w-=ACCEL_RATE;\n\t\t\tif(KeyDown(KEY_LEFT))st.z-=TURN_RATE;\n\t\t\tif(KeyDown(KEY_RIGHT))st.z+=TURN_RATE;\n\t\t\tif(length(iMouse.xy)<3.0){//autopilot\n\t\t\t\tst.w=max(st.w,ACCEL_RATE*4.0);\n\t\t\t\tst.z+=TURN_RATE*0.1;\n\t\t\t}\n\t\t\tst.xy+=vec2(sin(st.z),cos(st.z))*st.w;\n\t\t\tst.xy=clamp(st.xy,0.25,99.75);\n        }\n\t\tfragColor=st;\n\t\treturn;\n\t}\n\tif(fragCoord.x>100.0 || fragCoord.y>100.0)discard;\n\tif(iFrame==0){//else sheep \n\t\tif(fract(sin(dot(vec2(13.14,115.19),fragCoord))*4432.641)>0.9)fragColor=vec4(0.0,0.0,fract((fragCoord.x+fragCoord.y)*.139)*0.1-0.05,fract((fragCoord.x-0.9*fragCoord.y)*.139)*0.1-0.05);\n\t\telse fragColor=vec4(-2.0);\n\t\treturn;\n\t}\n\tvec2 heli=texture(iChannel0,vec2(103.5)/iResolution.xy).xy;\n\n\tvec4 o=T(fragCoord);\n\to.xy+=o.zw;\n\tbool bExists=exists(o);\n\tif(bExists){if(bx_length(o.xy)>.5){bExists=false;o=vec4(-2.0);}}else o=vec4(-3.0);//{o=vec4(-0.9);bClose=true;}\n\tif(bExists){//calculate the new velocity\n\t\to.zw*=0.95;\n\t\tvec2 f=fragCoord+o.xy-heli;\n\t\tfloat ln=length(f);\n\t\to.zw+=(f/ln)/(1.0+50.0*ln);\n        for(float i=0.0;i<16.0;i+=0.5){\n\t\t\tvec2 v=2.0*bx_cossin(i); //outer 'shell'\n\t\t\tvec4 c=T(fragCoord+v); \n\t\t\tif(exists(c)){\n\t\t\t\tf=o.xy-v-c.xy; \n\t\t\t\tln=bx_length(f);\n\t\t\t\to.zw+=(c.zw*0.25+f/ln)/(1.0+500.0*ln);\n\t\t\t}\n\t\t}\t\n    }\n\tfor(float i=0.0;i<8.0;i+=1.0){//inner shell\n\t\tvec2 v=bx_cossin(i); //direction to check, FINALLY HAD A USE FOR CHEBYSHEV ROTATION :)\n\t\tvec4 c=T(fragCoord+v); //the sheep in that direction\n\t\tif(exists(c)){\n        \tif(bExists){\n\t\t\t\tvec2 f=o.xy-v-c.xy; //difference to this sheep\n\t\t\t\tfloat ln=bx_length(f);\n\t\t\t\to.zw+=(c.zw*0.5+f/ln)/(1.0+500.0*ln);\n                }else{\n                    v=v+c.xy+c.zw;\n\t\t\t\tfloat ln=bx_length(v);\n\t\t\t\tif(ln<0.5){\n\t\t\t\t\to=vec4(v,c.zw);\n\t\t\t\t\tbreak;\n\t\t\t\t}else o=vec4(-2.0);\n            }\n\t\t}\n\t}\n\n\tif(length(o.zw)<0.00001)o.zw*=10.0;//try to maintain a direction\n\tfragColor=o;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}