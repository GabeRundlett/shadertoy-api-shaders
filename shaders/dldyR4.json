{
    "Shader": {
        "info": {
            "date": "1698956629",
            "description": "my first shader toy",
            "flags": 0,
            "hasliked": 0,
            "id": "dldyR4",
            "likes": 2,
            "name": "Portal VFX",
            "published": 3,
            "tags": [
                "portal"
            ],
            "usePreview": 0,
            "username": "trooper905",
            "viewed": 176
        },
        "renderpass": [
            {
                "code": "// Fork of \"\" by None. https://shadertoy.com/view/-1\n// 2023-10-29 22:14:00\n\n// cosine based palette, 4 vec3 params\n//This fuction is explained here\n//https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n\n    //Palette Created app\n    //http://dev.thi.ng/gradients/\n    vec3 a = vec3(0.158, 1.102, 0.468);\n    vec3 b = vec3(0.502,0.502,1.000);\n    vec3 c = vec3(0.428, 1.000, 1.008);\n    vec3 d = vec3(0.000, 0.538, 0.312);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec2 uv2 = uv;\n    vec2 uv3 = uv;\n    vec2 uv4 = uv;\n    \n    vec3 finalColor = vec3(0.0);\n    vec3 mask = vec3(0.0);\n\n    uv = fract(uv * 1.) - 0.5;\n    vec3 col;\n    float size = .5;\n    float sizeB = .8;\n    float f = 0.;\n    float d = 0.;\n    float sq = abs(sin(sizeB + iTime*.3)/2.5);\n    \n    float bounds = sdBox(uv0,vec2(sizeB,sizeB));\n    //bounds = (pow(.02/ bounds, 1.));\n    //bounds = abs(bounds);\n    bounds = smoothstep(0.05,0.,bounds);\n    //inverts the colors\n    //bounds = .02/bounds;\n    \n    \n    for(float i = 0.0; i < 4.0; i++)\n    {\n        uv = fract(uv * 1.4) - 0.5;\n        uv2 = fract(uv2 *2.) - 0.5;\n        uv2.x = fract(uv2.x -(iTime*.1)) - 0.5;\n        uv3 = fract(uv3 *1.-(iTime*.1)) - 0.5;\n        \n        uv4 = fract(uv4 * .5) - 0.5;\n        \n        float d = sdBox(uv,vec2(.1,.1));\n        float f = sdBox(uv3,vec2(size,size));\n        float e = sdBox(uv0,vec2(size-.2,size-.2));\n        \n        float y = sdBox(uv3,vec2(sq,sq));\n        float z = sdBox(uv4,vec2(sq,sq));\n        \n        \n        z = abs(z);\n        z = smoothstep(0.,.1,z);\n        z = (.02/z);\n        \n        y = abs(y);\n        y = smoothstep(0.,.1,y);\n        y = .005/y;\n        \n        d += length(d) * exp(length(uv0));\n        //f += length(uv*.25) * exp(length(uv0));\n        \n        e += length(f) * exp(length(uv0));\n        e += d* exp(length(uv0));\n        \n        f = length(f);\n        \n        float tri = sdEquilateralTriangle(uv0,.7);\n        float di = sdRhombus(uv0,vec2(sq*2.,sq*2.));\n        \n        di = abs(di);\n        di = smoothstep(0.,.1,di);\n        di = .01/di;\n        \n        d = sin(d*6. + iTime)/3.;\n        d = abs(d);\n        d = pow(0.06 / d, 1.0);\n        \n        float g =(pow(0.03/ f, 2.));\n        f = asin(pow(0.01/ f, 1.));\n        //f = exp(f);\n        \n        e = (pow(0.03/ e, 1.));\n\n        vec3 col = palette(length(uv0) + iTime*.5);\n        //col -= palette(length(z));\n       \n\n        float final = (.01/(d/z)+di);\n        //float final = z;\n       \n        mask += final;\n        finalColor += (col* final)*bounds;\n    }\n    \n  \n    //fragColor = vec4(mask,1.0);\n    fragColor = vec4(finalColor,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}