{
    "Shader": {
        "info": {
            "date": "1583017696",
            "description": "Painting is something I did in Unity. \nWanted to see if I can recreate the similar tool in here. TODO: Brightness && Saturation picker.",
            "flags": 32,
            "hasliked": 0,
            "id": "WtKSzG",
            "likes": 11,
            "name": "Playtime Painter",
            "published": 3,
            "tags": [
                "game",
                "interactive",
                "painting"
            ],
            "usePreview": 0,
            "username": "quizcanners",
            "viewed": 1021
        },
        "renderpass": [
            {
                "code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = texture(iChannel0, uv);\n\n  \n    \n    uv -= .5;\n    \n     vec3 mixing = col.gbr+col.brg;\n    \n    col.rgb+= mixing * mixing * 0.1;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x*= aspect;\n    \n     vec4 bg = texture(iChannel1, uv * 4.6);\n    \n    uv *= 12.;\n    \n   \n    \n  \tuv = floor(uv) * 0.5; // For Grid\n    \n    vec3 bgCol = (0.6 + bg.rgb *0.2 + mod(uv.x - uv.y, 1.) * 0.1);\n    \n    col.rgb =  (col.rgb  + (length(bg.rgb) - 0.4) * (1.1- col.a) * .5  ) * col.a + \n                        bgCol  * (1.-col.a);\n    \n    \n  \n    fragColor = vec4(col.rgb,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\nbool isStoreArea( in vec2 savePos, in vec2 fragCoord)\n{\n    vec2 r = savePos - fragCoord;\n    return length(r) < (1./200.);\n}\n\n\nvoid storeValue( in vec2 savePos, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 r = savePos - fragCoord;\n    fragColor = ( length(r) < (1./200.)) ? va : fragColor;\n}\n\nvec4 loadValue( in vec2 savePos )\n{\n    return texture( iChannel0, savePos);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 MousePos = iMouse.xy/iResolution.xy;\n    \n    \n    const float SAMPLER_AREA = 0.9;\n    const float BRIGHNESS_AREA = 0.85;\n    const float PERSIST_AREA = 0.99;\n    \n    // PERSISTENCE\n    vec2 persistanceUV = uv;\n   \n    const vec2 PRST_SIZE = vec2(800., 450.);\n    \n    const vec2 P_MOUSEPOS = (vec2(0., 449.) + 0.5) / PRST_SIZE;\n    const vec2 BRUSH_COLOR = (vec2(10., 449.) + 0.5) / PRST_SIZE;\n    const vec2 BRUSH_BRIGHTNESS = (vec2(20., 449.) + 0.5) / PRST_SIZE;\n    const vec2 P_MOUSEVEC = (vec2(30., 449.) + 0.5) / PRST_SIZE;\n    \n    vec4 prevM = loadValue(P_MOUSEPOS);\n   \n    prevM.xy -= 0.5;\n    float force = prevM.z; \n    float thickness = prevM.w;\n    \n   \n    vec4 prevM_Vec = loadValue(P_MOUSEVEC);\n    prevM_Vec.xy -= 0.5;\n    float prevThickness = prevM_Vec.w;\n    float prevLineLength = prevM_Vec.z;\n    \n    vec4 brushHUE = loadValue(BRUSH_COLOR);\n    vec4 brushColor = brushHUE;\n    brushColor.a = 1.;\n    \n    vec4 colorUE = loadValue(BRUSH_BRIGHTNESS);\n    \n    float brushBrightness = colorUE.x;\n    float brushContrast = colorUE.y;\n    \n \t// COLOR MGMT\n    uv -= .5;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    vec2 realM = MousePos - .5;\n    \n    uv.x *= aspect;\n    \n    realM.x *= aspect;\n   \n    vec2 M = realM;// + prevM_Vec.xy * force;\n    \n    float lineLength = length(M-prevM.xy);\n    \n    if (persistanceUV.y<SAMPLER_AREA)\n    {\n          \n        brushColor = mix(vec4(1.), brushHUE, brushContrast) *  brushBrightness;\n        brushColor.a = 1.;\n          \n        if (persistanceUV.x < BRIGHNESS_AREA)\n        {\n          \n            // PAINTING\n\n            vec4 col = texture(iChannel0, persistanceUV);\n\n            float distToNext = length(uv - M);\n\n            float t = mix(thickness,prevThickness , clamp(distToNext/lineLength ,0.,1.)) + 0.0001;\n\n            //M += (M-prevM.xy)*0.25;\n\n            float minD = DistToLine(uv, M,prevM.xy);//  min(d0, d1);\n\n            const float DIST_COEF = 0.005;\n\n            float maxDist = DIST_COEF * 4. * t - minD;\n\n\n            if (maxDist>0.) {\n\n\n                const float SHARPNESS = 920.;\n\n                vec2 direction = M - prevM.xy; \n\n                float lineLength = length(direction);\n\n                float dist = \n                    lineLength > t *0.01 \n                    ? DistToCurve(prevM.xy, prevM.xy+prevM_Vec.xy * lineLength * 0.3, M  , uv)\n                    : DistToLine(uv, M,prevM.xy)\n                        ; \n\n\n                float smudgeStep = floor(iTime * 2. );\n\n                vec2 ruv = Rotate(uv,  smudgeStep * 123.456);\n                float mask = texture(iChannel1, ruv + smudgeStep*0.123).b;\n\n                //mask*= mask;\n\n                float soft = (.001/dist);\n\n                float toBlur =  max(0.,DIST_COEF * (1. + mask * 5.) * (t) -dist - lineLength\n                                   ) * force * 15.;\n\n                float toPaint = \n\n                    // NEON BRUSH:\n                               // (.003/dist));\n\n                    // NORMAL BRUSH:\n                                max(0., (DIST_COEF * t * (1. + toBlur * .3) -dist)* SHARPNESS / t  * force //* min(1., 0.5 + lineLength*10.)\n                                   ) ;\n\n                float alpha = clamp(toPaint, 0., 1.);\n                float rgbAlpha = clamp((alpha*2.+soft * maxDist * max(0., 1.-col.a))/(col.a + alpha), 0., 1.);\n                vec4 maskb = vec4(rgbAlpha,rgbAlpha,rgbAlpha, alpha);\n\n                // Pixel Offset For Blur\n                vec2 off= (1./iResolution.xy)*0.5; // To sample area between pixels(Bilinear filtering would work as 4 blurring 4 pixels)\n\n                vec2 blurUv = persistanceUV - prevM_Vec.xy * prevLineLength * lineLength * 400. * toBlur * maxDist;\n\n                vec4 up = texture(iChannel0, blurUv + off);\n                vec4 down = texture(iChannel0, blurUv + vec2(off.x,-off.y));\n                vec4 left = texture(iChannel0, blurUv + vec2(-off.x, off.y)); \n                vec4 right = texture(iChannel0, blurUv - off);\n                float total = up.a + down.a + left.a + right.a + 0.01;\n                vec4 blurred = (up*up.a+down*down.a+left*left.a+right*right.a) / total;\n\n                col = mix(col, blurred, min(1.,toBlur));\n                \n                \n                \n                fragColor = max(vec4(0.,0.,0.,0.), mix(col, brushColor, maskb));\n                //fragColor.rgb = sqrt(fragColor.rgb);\n\n               // fragColor.rgb = vec3(ruv*20.,0.);\n            } else {\n                fragColor = col;\n            }\n            \n         } else \n         {\n            float brightness = persistanceUV.y * SAMPLER_AREA;\n            float contrast = (persistanceUV.x - BRIGHNESS_AREA) / (1. - BRIGHNESS_AREA);\n            fragColor = mix(vec4(1.), brushHUE, contrast) *  brightness;\n            fragColor.a = 1.;\n            \n            float dist = length(iResolution.yx * vec2(SAMPLER_AREA, 1. - BRIGHNESS_AREA ) * 0.02 * vec2(brushBrightness - brightness, brushContrast -contrast ));\n            \n            fragColor.rgb = mix(fragColor.rgb, vec3(1.), smoothstep(0.03, 0., abs(dist - 0.1)) );\n            \n        }\n        \n    } else {\n        \n    \t// TOP PART\n\n        float x = persistanceUV.x;\n\n        float down = clamp(iMouse.z * 800., 0. , 1.);\n    \n        float click = down * max(0.,1. - force*100.); // Not down previous frame\n           \n    \tforce = clamp(down*iTimeDelta * 5. + force, 0. , 1.) * down;\n        \n        if (persistanceUV.y>PERSIST_AREA)\n        {\n            // STORING DATA\n\n            realM = M;\n            float path = length(prevM.xy - realM.xy);\n            storeValue(P_MOUSEVEC, vec4(\n                (lineLength>0.001 \n                ? normalize(realM-prevM.xy)\n                : vec2(0.,0.)) + 0.5,\n                lineLength, thickness), fragColor, persistanceUV);\n            \n            thickness = mix(thickness, 1./(path*5. + .1) + 0.5, min(0.3,path*5.)) * down;\n            \n            storeValue(P_MOUSEPOS, vec4(realM + 0.5, force, thickness), fragColor, persistanceUV);\n           \n            if (isStoreArea(BRUSH_COLOR, persistanceUV))\n            {\n\n                float inSamplingArea = clamp((MousePos.y - SAMPLER_AREA) * 100., 0., 1.);\n                \n                fragColor = mix(brushColor, GetColorPalette(MousePos.x), click * inSamplingArea );\n                \n            } else if (isStoreArea(BRUSH_BRIGHTNESS, persistanceUV))\n            {\n                float hueSampler = clamp((MousePos.y - SAMPLER_AREA) * 100., 0., 1.);\n            \n                float inBrightnessArea = (1. - hueSampler) * clamp((MousePos.x - BRIGHNESS_AREA) * 1000., 0., 1.);\n\n                brushBrightness = mix(brushBrightness, MousePos.y * SAMPLER_AREA, click * inBrightnessArea);\n                brushContrast = mix(brushContrast, (MousePos.x - BRIGHNESS_AREA) / (1. - BRIGHNESS_AREA) , click * inBrightnessArea);\n                \n                fragColor = vec4(brushBrightness, brushContrast, 0, 0);\n            }\n            \n        } else {\n            // PALETTE\n            fragColor = GetColorPalette(x);\n            \n            float dist = length(brushColor.rgb - fragColor.rgb);\n            \n            fragColor.rgb = mix(fragColor.rgb, vec3(1.), smoothstep(0.01, 0., dist));\n            \n        }\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n * Analytic Spline Distance\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst vec2 k = vec2(1.,0.);\nconst float pi = acos(-1.);\n\nfloat dist(vec2 p_0,vec2 p_1,vec2 p_2,vec2 x,float t)\n{\n    return length(x-pow(1.-t,2.)*p_0-2.*(1.-t)*t*p_1-t*t*p_2);\n}\n\nfloat DistToCurve(vec2 p_0,vec2 p_1,vec2 p_2, vec2 uv)\n{\n\t//coefficients for 0 = t^3 + a * t^2 + b * t + c\n    vec2 E = uv-p_0;\n    vec2 F = p_2-2.*p_1+p_0;\n    vec2 G = p_1-p_0;\n    vec3 coeff = vec3(3.*dot(G,F), 2.*dot(G,G)-dot(E,F), -dot(E,G))/dot(F,F);\n\n    float a = coeff.x;\n    float b = coeff.y;\n    float c = coeff.z;\n\n\t//discriminant and helpers\n    float p = b-a*a/3.;\n    float q = 2.*a*a*a/27.-a*b/3.+c;\n    float dis = q*q/4.+p*p*p/27.;\n    float tau = a/3.;\n    \n    //solution with cardan formula\n    float sqrtDis = sqrt(dis);\n    float k1 = -.5*q+sqrtDis;\n    float k2 = -.5*q-sqrtDis;\n    float u = sign(k1)*pow(abs(k1), 1./3.);\n    float v = sign(k2)*pow(abs(k2), 1./3.);\n    \n    float t_min = 1.;\n    \n    if(dis > 0.)\n    {\n        t_min = u+v-tau;\n        t_min = clamp(t_min, 0.,1.);\n    }\n    else if(dis < 0.)\n    {\n      \n        \n        float fac = sqrt(-4./3.*p);\n        float arg = -.5*q*sqrt(-27./p/p/p);\n        float acosArg = acos(arg)/3.;\n        \n           float t1 = -fac*cos(acosArg+pi/3.)-tau,\n            t2 = fac*cos(acosArg)-tau,\n            t3 = -fac*cos(acosArg-pi/3.)-tau;\n        t1 = clamp(t1,0.,1.);\n        t2 = clamp(t2,0.,1.);\n        t3 = clamp(t3,0.,1.);\n        float b1 = dist(p_0,p_1,p_2,uv,t1),\n            b2 = dist(p_0,p_1,p_2,uv,t2),\n            b3 = dist(p_0,p_1,p_2,uv,t3);\n        t_min = mix(mix(t1, t2, step(b2, b1)), t3, step(b3, min(b1, b2)));\n    } \n    \n    return dist(p_0,p_1,p_2,uv,t_min);\n}\n\n// *************************************** \n\nvec2 Rotate(in vec2 uv, in float angle)\n{\n\n\tfloat si = sin(angle);\n\tfloat co = cos(angle);\n\tfloat tx = uv.x;\n\tfloat ty = uv.y;\n\tuv.x = (co * tx) - (si * ty);\n\tuv.y = (si * tx) + (co * ty);\t\n\n    return uv;\n}\n\nfloat DistToLine(vec2 pos, vec2 a, vec2 b) {\n\t\tvec2 pa = pos - a;\n\t\tvec2 ba = b - a;\n\t\tfloat t = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n\t\treturn length(pa - ba * t);\n\t}\n\nvec4 GetColorPalette(in float x)\n{\n    float r = smoothstep(0.33, 0., x) + smoothstep(0.66, 1., x);\n    float g = smoothstep(0., 0.33, x)* smoothstep(0.66, 0.33, x);\n    float b = smoothstep(0.33, 0.66, x)* smoothstep(1., 0.66, x);\n    \n    vec3 col = sqrt(vec3(r,g,b)); // not sure about this\n    \n\treturn vec4(col, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}