{
    "Shader": {
        "info": {
            "date": "1583573926",
            "description": "I was experimenting with replicating geometric art. I thought the result was interesting so I thought I share even though it is a very simple distance field function.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lySDV",
            "likes": 6,
            "name": "Simple geometric 2D art",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 476
        },
        "renderpass": [
            {
                "code": "// License CC0: mrange\n// I was experimenting with replicating geometric art. I thought the result was interesting \n// so I thought I share even though it is a very simple distance field function.\n// \n\n// Experiment with these parameters for variants\nconst float size  = 1.0 ;\nconst float off   = 0.15;\nconst float width = 0.01;\nconst int   rep   = 13  ;\n\n#define PHI (.5*(1.+sqrt(5.)))\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\nconst vec3 plnormal = normalize(vec3(1, 1, -1));\nconst vec3 n1 = normalize(vec3(-PHI,PHI-1.0,1.0));\nconst vec3 n2 = normalize(vec3(1.0,-PHI,PHI+1.0));\nconst vec3 n3 = normalize(vec3(0.0,0.0,-1.0));\n\nfloat dodec(in vec3 z) {\n  float t;\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n\n  float dmin=dot(z-vec3(size,0.,0.),plnormal);\n        \n  dmin = abs(dmin) - width;\n//  dmin = abs(dmin) - width*0.5;\n        \n  return dmin;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat df(vec2 p) {\n  float d = 100000.0;\n  for (int i = 0; i < rep; ++i) {\n    vec2 ip = p;\n    rot(ip, float(i)*TAU/float(rep));\n    ip -= vec2(size, 0.0);\n    float id = dodec(vec3(ip, off*size));\n    d = min(d, id);\n  }\n  return d;\n}\n\nvec3 postProcess(in vec3 col, in vec2 q) \n{\n  //col = saturate(col);\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 uv = 2.0*(q - 0.5);\n  uv.x *= iResolution.x/iResolution.y;\n    \n  float d = df(uv);\n\n  float fuzzy = 0.001;\n    \n  vec3 col = mix(vec3(0.3), vec3(1.0), smoothstep(-fuzzy, fuzzy, d));\n  \n  col = postProcess(col, q);\n    \n  fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}