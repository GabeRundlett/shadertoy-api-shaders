{
    "Shader": {
        "info": {
            "date": "1475436360",
            "description": "A new (to my knowledge, at least) ease curve which is useful for showing bidirectional \"tweaks\" to positions or parameters. See this curve in use at [url]https://www.shadertoy.com/view/XtyGzV[/url].",
            "flags": 0,
            "hasliked": 0,
            "id": "XlG3RV",
            "likes": 8,
            "name": "wiggle curves",
            "published": 3,
            "tags": [
                "curve",
                "wiggle"
            ],
            "usePreview": 0,
            "username": "mattz",
            "viewed": 1104
        },
        "renderpass": [
            {
                "code": "/* wiggle curves, by mattz.\n   License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   A \"wiggle curve\" is an ease curve f(t) which has the following properties:\n\n     - f(0) = 0 and f(1) = 0; that is, the position is zero at the endpoints.\n\n     - f'(0) = 0 and f'(1) = 0; that is, the velocity is zero at the endpoints.\n\n     - the position hits its extrema of +/- 1 symmetrically about the midpoint\n\n     - the magnitude of the velocity is maximized at the midpoint\n\n   Such a curve can be easily defined two different ways: \n\n     1) start with a sinusoid and re-time it to both start up and finish slowly \n        (i.e. transform time by the \"smoothstep\" function).\n\n     2) design a cubic spline for the [0, 0.5] interval that obeys the constraints\n        for the left half, and mirror it to obtain the right.\n\n   The first is slightly easier to code; the second is probably more efficient to execute.\n   Update: can also use iq's \"impulse\" function (see comments)\n\n   See http://easings.net/ for examples of many other ease curves!\n\n*/\n\n\nfloat w(float u) {\n    return 27.0*(1.0 - 2.0*u)*u*u; \n}\n\nfloat wiggle_cheap(float u) {\n    return u < 0.5 ? w(u) : -w(1.0-u);\n}\n\nfloat wiggle_trig(float u) {\n    u = (3.0 - 2.0*u)*u*u;\n    return sin(6.283185307179586*u);\n}\n\n// from https://iquilezles.org/articles/functions\nfloat impulse( float k, float x ) {\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat wiggle_impulse(float u) {\n    const float k = 14.0;\n    return u < 0.5 ? impulse(k, 0.5-u) : -impulse(k, u-0.5);\n}\n\nfloat function_dist(float dist) {\n\tdist /= length(vec2(dFdx(dist), dFdy(dist)));\n    return smoothstep(0.5, 1.5, abs(dist));\n}\n\nvec2 grid_fract(vec2 x, vec2 i) {\n    return (fract(x/i+0.5)-0.5)*i;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspect = 2.25;\n    \n    uv.y = uv.y * aspect - 0.5*aspect;\n    \n    vec2 scl = iResolution.xy / vec2(1.0, aspect);\n    \n    float dc = function_dist(uv.y - wiggle_cheap(uv.x));\n    float dt = function_dist(uv.y - wiggle_trig(uv.x));\n    float di = function_dist(uv.y - wiggle_impulse(uv.x));\n    \n    vec2 grid = abs(grid_fract(uv, vec2(0.125, 0.5)))*scl;\n    float dg = smoothstep(0.0, 1.0, min(grid.x, grid.y));\n    \n\tvec3 color = vec3(1.0);\n    \n    color = mix(vec3(0.8), color, dg);\n    color = mix(vec3(1.0, 0, 0), color, dt);\n    if (iMouse.z > 0.0) {\n        color = mix(vec3(0, 0.7, 0), color, di);\n    }\n    color = mix(vec3(0, 0, 1.0), color, dc);\n    \n    fragColor = vec4(color, 1.0);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}