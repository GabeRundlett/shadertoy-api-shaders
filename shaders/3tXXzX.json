{
    "Shader": {
        "info": {
            "date": "1563656551",
            "description": "Volumetric rendering for fractals defined by boolean functions, here a Mandelbulb",
            "flags": 0,
            "hasliked": 0,
            "id": "3tXXzX",
            "likes": 93,
            "name": "Volumetric Mandelbulb",
            "published": 3,
            "tags": [
                "fractal",
                "mandelbulb",
                "volumetric"
            ],
            "usePreview": 1,
            "username": "loicvdb",
            "viewed": 3115
        },
        "renderpass": [
            {
                "code": "#define Pi 3.14159265359\n#define ViewStart 1.6\n#define ViewEnd 4.4\n\n\n//#define HQ\n\n\n#ifdef HQ\nint CameraRaySteps = 255;\nint ShadowRaySteps = 64;\nfloat MaxTransparency = .95;\n#else\nint CameraRaySteps = 128;\nint ShadowRaySteps = 16;\nfloat MaxTransparency = .7;\n#endif\n\n\n\nvec3 DirCam = normalize(vec3(-1, 0, 0));\nvec3 PosCam = vec3(3.0, 0, .0);\nfloat FocalLength = 1.0;\n\nvec3 LightColor = vec3(1.5);\nvec3 LightPos;\n\nfloat Density = 25.0;\nfloat Anisotropy = .25;\nvec3 VolumeColor = vec3(.1, .15, .2);\n\nfloat Power;\n\n\n\nvec3 powV(vec3 v, float p){\n    return vec3(pow(v.x, p), pow(v.y, p), pow(v.z, p));\n}\n\nfloat maxV(vec3 v){\n    return max(max(v.x, v.y), v.z);\n}\n\nbool insideShape(vec3 pos) {\n\tvec3 z = pos;\n\tfloat r;\n\tfloat zr;\n    float sinTheta;\n    float phi;\n    float theta;\n\tfor(int i = 0; i < 4; i++) {\n\t\tr = length(z);\n\t\tif(r>1.3) break;\n\t\ttheta = acos(z.z/r)*Power;\n\t\tphi = atan(z.y,z.x)*Power;\n        sinTheta = sin(theta);\n\t\tz = pow(r,Power)*vec3(sinTheta*vec2(cos(phi), sin(phi)), cos(theta)) + pos;\n\t}\n\treturn r < 1.0 && r > .65;\n}\n\nfloat henyeyGreenstein(vec3 pos, vec3 dir){\n\tfloat cosTheta = dot(dir, normalize(LightPos-pos));\n \treturn Pi/4.0 * (1.0-Anisotropy*Anisotropy) / pow(1.0 + Anisotropy*Anisotropy - 2.0*Anisotropy*cosTheta, 3.0/2.0);\n}\n\nvec3 lightReceived(vec3 pos, float headStart){\n    \n    float LightDist = length(LightPos-pos);\n    vec3 LightDir = normalize(LightPos-pos);\n    \n    float stepSize = LightDist / float(ShadowRaySteps);\n    vec3 absorption = vec3(1.0);\n    \n    pos += headStart * LightDir * stepSize;\n    \n    for(int i = 0; i < ShadowRaySteps; i++){\n        if(insideShape(pos)){\n            absorption *= powV(vec3(1)-VolumeColor, stepSize*Density);\n        }\n        pos += LightDir * stepSize;\n    }\n    return absorption*LightColor / (LightDist*LightDist);\n}\n\n\nvec3 rotateZ(vec3 p, float angle){\n    return vec3(cos(angle) * p.x + sin(angle) * p.y,\n                -sin(angle) * p.x + cos(angle) * p.y,\n                p.z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //quick animation ...\n    DirCam = rotateZ(DirCam, -iTime/3.0);\n    PosCam = rotateZ(PosCam, -iTime/3.0);\n    Power = abs(cos(iTime/5.0)) * 7.0 + 1.0;\n    LightPos = vec3(cos(iTime/2.0), -sin(iTime/2.0), cos(iTime/1.0)) * 1.25;\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy/2.0)/iResolution.y;\n    \n    vec3 camX = vec3(-DirCam.y, DirCam.x, 0);\n\tvec3 camY = cross(camX, DirCam);\n\tvec3 sensorX = camX * (uv.x/length(camX));\n\tvec3 sensorY = camY * (uv.y/length(camY));\n\tvec3 centerSensor = PosCam - DirCam * FocalLength;\n\tvec3 posOnSensor = centerSensor + sensorX + sensorY;\n\tvec3 dir = normalize(PosCam - posOnSensor);\n\t\n    vec3 pos = PosCam + dir*ViewStart;\n    float hg = henyeyGreenstein(pos, dir);\n    vec3 color;\n    \n    float stepSize = (ViewEnd-ViewStart) / float(CameraRaySteps);\n    vec3 absorption = vec3(1.0);\n    \n    float headStart = texture(iChannel0, fragCoord/vec2(1024)).a;\n    \n    pos += headStart * dir * stepSize;\n    \n    for(int i = 0; i < CameraRaySteps; i++){\n        if(length(LightPos-pos) <.05){\n            color += 10.0*absorption*LightColor;\n            break;\n        }\n        if(insideShape(pos)){\n            color += VolumeColor*absorption*lightReceived(pos, headStart)*hg*stepSize*Density;\n            absorption *= powV(vec3(1)-VolumeColor, stepSize*Density);\n        }\n        pos += dir * stepSize;\n        if(maxV(absorption) < 1.0-MaxTransparency) break;\n    }\n    \n\tfragColor = vec4(log(color + vec3(1.0)), 1.0);\t//reduces clipping and desaturates bright colors\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}