{
    "Shader": {
        "info": {
            "date": "1625671429",
            "description": "Wanted to try and make a cool weapon. I think i made it too shiny, lol.",
            "flags": 0,
            "hasliked": 0,
            "id": "stsSD8",
            "likes": 6,
            "name": "Fantasy Axe",
            "published": 3,
            "tags": [
                "axe"
            ],
            "usePreview": 0,
            "username": "intrakits",
            "viewed": 322
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\n#define AA 1\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\nfloat getDisp(vec2 uv){\n\n    vec2 p = 0.5 - 0.5*sin(vec2(1.01,1.71) );\n    p = vec2(1.0, 1.0);\n\t\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\t\n\tfloat f = iqnoise(24.0*uv, p.x, p.y);\n\t\n\treturn f;\n}\nvec2 GetDist(vec3 p){\n    //ground\n    vec2 res = vec2(p.y+10.,0);\n    float e = 2.71828182846;\n    float offs = (pow(e,cos(p.y))/pow(e,sin(p.y*p.y*10.))*.03);\n    vec2 blade = vec2(sdCapsule(p-vec3(0,0,clamp(abs(p.x-.5)*.5,0.,.7)), vec3(0,0,0), vec3(1,0,0), 1.),1);\n    float mask = dBox(p-vec3(0,0,0), vec3(4,1,.1));\n    \n    blade = max(blade,mask);\n    blade= max(blade,1.-length(p-vec3(.5,1,0))-.1);\n    blade= max(blade,1.-length(p-vec3(.5,-1.4,0))-.1);\n    res= colMin(res,blade);\n    \n    vec2 pole = vec2(sdCylinder(p-vec3(.5,0,0), vec3(0,-5,0), vec3(0,1,0), .2),2);\n    vec2 uv = vec2(atan(p.x,p.z)/(3.14159*2.),p.y/5.)+.5;\n    \n    float disp = 0.1*iqnoise( 30.0*uv, 1., .1 );\n    pole.x-=disp*.1;\n    mask = dBox(p-vec3(.5,0,-.1), vec3(.1,1,.5));\n    pole.x = opSmoothSubtraction(mask,pole.x,.2);\n    res= colMin(res,pole);\n    \n    vec2 socket = vec2(sdCylinder(p-vec3(.5,-.15,0), vec3(0,0,.2), vec3(0,0,-.2), .3),3);\n    res= colMin(res,socket);\n    mask = sdCylinder(p-vec3(.5,-.15,0), vec3(0,0,.2), vec3(0,0,-.2), .1);\n    res.x = opSmoothSubtraction(mask,res.x,.1);\n    \n    vec2 dec1 = vec2(sdCylinder(p-vec3(.5,-.7,0), vec3(0,0,.2), vec3(0,0,-.2), .2),4);\n    vec2 dec2 = vec2(sdCylinder(p-vec3(.5,-.7,0), vec3(.3,0,0), vec3(-.3,0,0), .2),4);\n    dec1 = min(dec1,dec2);\n    vec2 dec3 = vec2(sdCylinder(p-vec3(.5,-.9,0), vec3(0,0,0), vec3(0,-.1,0), .25),4);\n    dec1 = min(dec1,dec3);\n    \n    vec2 dec4 = vec2(sdCylinder(p-vec3(.5,-1.2,0), vec3(0,0,.2), vec3(0,0,-.24), .2),4);\n    vec2 dec5 = vec2(sdCylinder(p-vec3(.5,-1.2,0), vec3(.3,0,0), vec3(-.3,0,0), .2),4);\n    dec1 = min(dec1,dec4);\n    dec1 = min(dec1,dec5);\n    vec2 dec6 = vec2(sdCylinder(p-vec3(.5,-1.4,0), vec3(0,0,0), vec3(0,-.1,0), .25),4);\n    dec1 = min(dec1,dec6);\n    res= colMin(res,dec1);\n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p);\n        //move origin to new point\n        dO+=ds.x;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(0,5,-5);\n    \n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= 0.1;\n    }\n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvec3 axeCol(vec3 p, vec3 n, vec3 rd){\n        vec3 colXZ = texture(iChannel1, p.xz*.5+.5).rgb;\n        vec3 colXY = texture(iChannel1, p.xy*.5+.5).rgb;\n        vec3 colYZ = texture(iChannel1, p.yz*.5+.5).rgb;\n        \n        vec3 refl = texture(iChannel2, rd).rgb;\n        refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n        vec3 metal = colXZ*abs(n.y) + colXY*abs(n.z) + colYZ*abs(n.x);\n        metal*=smoothstep(0.1,.4,metal.b)*refl*5.;\n        return metal;\n\n}\nvec3 decCol(vec3 p, vec3 n, vec3 rd){\n        vec3 colXZ = texture(iChannel0, p.xz*.5+.5).rgb;\n        vec3 colXY = texture(iChannel0, p.xy*.5+.5).rgb;\n        vec3 colYZ = texture(iChannel0, p.yz*.5+.5).rgb;\n        \n        vec3 refl = texture(iChannel2, rd).rgb;\n        refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n        vec3 metal = colXZ*abs(n.y) + colXY*abs(n.z) + colYZ*abs(n.x);\n        metal= mix(smoothstep(0.7,.8,metal.r)*refl*5.,metal,.7);\n        return metal;\n\n}\nvec3 poleCol(vec3 p, vec3 n, vec3 rd){\n        vec3 colXZ = texture(iChannel3, p.xz*.5+.5).rgb;\n        vec3 colXY = texture(iChannel3, p.xy*.5+.5).rgb;\n        vec3 colYZ = texture(iChannel3, p.yz*.5+.5).rgb;\n        \n        vec3 refl = texture(iChannel2, rd).rgb;\n        refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n        vec3 metal = colXZ*abs(n.y) + colXY*abs(n.z) + colYZ*abs(n.x);\n        //metal= mix(smoothstep(0.7,.8,metal.r)*refl*5.,metal,.7);\n        return metal;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ta = vec3( 0.5, -1, .5);\n    vec3 ro = ta + vec3( 4.5*cos(7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(7.0*mo.x) );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    //------------------\n    vec2 d = RayMarch(ro,rd);\n    \n    // position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n    \n    //get diffuse lighting\n    float diff = GetLight(p);\n    vec3 col = vec3(0);\n    col = vec3(diff)*2.;\n    \n    vec3 n = GetNormal(p);\n    \n    if(d.y == 1.){\n        col *= axeCol(p, n, rd);\n    }\n    else if(d.y==2.){\n        col *= poleCol(p,n,rd);\n    }\n    else if(d.y==3.){\n        col*=decCol(p, n, rd)*vec3(0,0.6,.9);\n    }\n    else if(d.y==4.){\n        col*=decCol(p, n, rd)*vec3(1,1,0);\n    }\n    else{\n    col *=texture(iChannel2, rd).rgb * 5.;\n    }\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}