{
    "Shader": {
        "info": {
            "date": "1623991446",
            "description": "Extracting the major and minor axes from an ellipse in the general quadric form. There are two versions, one that uses trig and one that doesn't. The one with trig is simpler but I'm unsure in terms of performance.",
            "flags": 0,
            "hasliked": 0,
            "id": "stS3Ww",
            "likes": 3,
            "name": "Ellipse Extraction",
            "published": 3,
            "tags": [
                "2d",
                "quadric",
                "ellipse",
                "conversion",
                "extraction"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 205
        },
        "renderpass": [
            {
                "code": "// See the desmos graphs where I worked most of this out:\n// Computing major and minor axes: https://www.desmos.com/calculator/12t322u7xa\n// Converting ellipse with center and axes to a general quadric: https://www.desmos.com/calculator/tialwuz5wh\n// I was thinking of using this to parametrize the intersection\n// between a plane and an ellipsoid\n\n// Drawing utility\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// Main stuff\nstruct Quadric { float a; float b; float c; float d; float e; float f; };\nstruct Ellipse { vec2 center; mat2 axes; };\n\nfloat evalQuadric(in vec2 p, in Quadric q) {\n    return q.a * p.x * p.x + q.b * p.y * p.y + q.c * p.x * p.y +\n           q.d * p.x + q.e * p.y + q.f;\n}\n\nvec2 evalQuadricPrime(in vec2 p, in Quadric q) {\n    return vec2(2.0 * q.a * p.x + q.c * p.y + q.d,\n                2.0 * q.b * p.y + q.c * p.x + q.e);\n}\n\n#if 0 // Trig version\nEllipse parametrizeEllipse(in Quadric q) {\n    float cx = 2.0 * q.b * q.d - q.c * q.e, cy = 2.0 * q.a * q.e - q.c * q.d;\n    float s = q.c * q.c - 4.0 * q.a * q.b;\n\n    float g = ((q.a * cx * cx + q.b * cy * cy + q.c * cx * cy) / s +\n                q.d * cx + q.e * cy) / s + q.f;\n\n    float a = 0.5 * atan(q.b - q.a, q.c);\n    vec2 k = vec2(cos(a), sin(a));\n    float i = k.x - k.y, j = k.x + k.y;\n\n    float ii = i * i, jj = j * j, ij = q.c * i * j;\n    vec2 u = vec2( i, j) * sqrt(-g / (q.a * ii + q.b * jj + ij));\n    vec2 v = vec2(-j, i) * sqrt(-g / (q.a * jj + q.b * ii - ij));\n\n    return Ellipse(vec2(cx, cy) / s, mat2(u, v));\n}\n\n#else // Trigless version\nEllipse parametrizeEllipse(in Quadric q) {\n    float cx = 2.0 * q.b * q.d - q.c * q.e, cy = 2.0 * q.a * q.e - q.c * q.d;\n    float s = q.c * q.c - 4.0 * q.a * q.b;\n\n    float g = ((q.a * cx * cx + q.b * cy * cy + q.c * cx * cy) / s +\n                q.d * cx + q.e * cy) / s + q.f;\n\n    float ba = q.b - q.a, r = ba / q.c;\n    float ca = 0.5 * sign(q.c) / sqrt(1.0 + r * r);\n    float ch = sqrt(0.5 + ca), sh = sqrt(0.5 - ca) * sign(ba);\n    float i = ch - sh, j = ch + sh;\n\n    float ii = i * i, jj = j * j, ij = q.c * i * j;\n    vec2 u = vec2( i, j) * sqrt(-g / (q.a * ii + q.b * jj + ij));\n    vec2 v = vec2(-j, i) * sqrt(-g / (q.a * jj + q.b * ii - ij));\n\n    return Ellipse(vec2(cx, cy) / s, mat2(u, v));\n}\n#endif\n\nQuadric implicitizeEllipse(in Ellipse e) {\n    mat2 inv = inverse(e.axes);\n    vec2 ce = inv * e.center;\n    return Quadric(dot(inv[0], inv[0]),\n                   dot(inv[1], inv[1]),\n                   2.0 * dot(inv[0], inv[1]),\n                   -2.0 * dot(inv[0], ce),\n                   -2.0 * dot(inv[1], ce),\n                   dot(ce, ce) - 1.0);\n}\n\n// SDFs\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float m = length(v); vec2 n = v / m;\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));\n    return min(sdVerticalLine(p, m) - 0.05, sdIsosceles(p - vec2(0.0, m), 0.2, 0.35));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 8.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 8.0;\n    vec3 color = vec3(0.15);\n    float unit = 16.0 / iResolution.y;\n\n    // Ellipse position and axes for testing\n    vec2 pos = vec2(3.0 * cos(iTime), sin(2.0 * iTime));\n    vec2 ab = vec2(2.0 + cos(iTime), 2.0 + sin(iTime));\n    float rot = iTime - 2.0 * sin(0.5 * iTime);\n\n    // Rotate and scale\n    vec2 u = vec2(cos(rot), sin(rot));\n    vec2 v = vec2(-u.y, u.x) * ab.y;\n    u *= ab.x;\n\n    // Add some shear\n    u.y += 0.5 + cos(iTime);\n    v.x += 0.5 - sin(iTime);\n\n    // Implicitize the ellipse and then extract the center and axes\n    // This makes it possible to make an identity check\n    Quadric q = implicitizeEllipse(Ellipse(pos, mat2(u, v)));\n    Ellipse e = parametrizeEllipse(q);\n\n    // Grid\n    float spacing = 0.5, hSpacing = 0.5 * spacing;\n    drawSDF(abs(mod(uv.x + hSpacing, spacing) - hSpacing) - 0.001, vec3(0.5));\n    drawSDF(abs(mod(uv.y + hSpacing, spacing) - hSpacing) - 0.001, vec3(0.5));\n\n    drawSDF(abs(uv.x) - 0.01, vec3(0.6, 0.0, 0.0));\n    drawSDF(abs(uv.y) - 0.01, vec3(0.0, 0.0, 0.6));\n\n    // Quadric\n    drawSDF(evalQuadric(uv, q) / length(evalQuadricPrime(uv, q)), vec3(0.0, 0.0, 1.0));\n\n    // Draw an outline using the extracted ellipse parameters\n    uv -= e.center;\n    float tStep = 0.2;\n    float coStep = cos(tStep), siStep = sin(tStep);\n    mat2 stepMat = mat2(coStep, siStep, -siStep, coStep);\n    vec2 prev = vec2(1.0, 0.0);\n    for (float t=0.0; t < 6.28; t += tStep) {\n        vec2 cur = stepMat * prev;\n        drawSDF(sdLine(uv, e.axes * prev, e.axes * cur) - 0.01, vec3(1.0));\n        prev = cur;\n    }\n\n    // Original axes\n    drawSDF(abs(dot(uv, normalize(vec2(-u.y, u.x)))) - 0.02, vec3(1.0, 0.0, 0.0));\n    drawSDF(abs(dot(uv, normalize(vec2(-v.y, v.x)))) - 0.02, vec3(0.0, 1.0, 0.0));\n\n    // Computed axes and center\n    drawSDF(sdVectorArrow(uv, e.axes[0]), vec3(1.0, 0.5, 0.0));\n    drawSDF(sdVectorArrow(uv, e.axes[1]), vec3(0.8, 1.0, 0.0));\n    drawSDF(length(uv) - 0.1, vec3(1.0, 0.8, 0.0));\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}