{
    "Shader": {
        "info": {
            "date": "1633714239",
            "description": "Based on the virtual meadow tutorial by Nusan: https://www.youtube.com/watch?v=vpwukN_FUa8&t=4924s&ab_channel=AntoineZanuttini\nThis looks really bad on firefox... [Fixed]\n30 fps AVG Secure Browser | 5 fps google chrome",
            "flags": 0,
            "hasliked": 0,
            "id": "7stSzf",
            "likes": 44,
            "name": "Grass Scene #1 [Griar]",
            "published": 3,
            "tags": [
                "terrain",
                "grass",
                "glow",
                "moon",
                "night",
                "snow",
                "scene"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 1496
        },
        "renderpass": [
            {
                "code": "/////////////////////////////////////////////////////////////\n//                                                         //\n// Author:Yusef28                                          //\n// Start Date: 08-10-2021                                  //\n// Status: On Going                                        //\n// Topic: Grass / Scene Creation                           //\n// Sources: Nusan Tutorial                                 //\n//          https://www.youtube.com/watch?v=vpwukN_FUa8    //\n// Listening to: Fallen - Night Lovell Type Beat \"GREY FIRE\"                                          //\n// License: Creative Commons NonCommercial license (CC NC) //\n//                                                         // \n/////////////////////////////////////////////////////////////\n\n//If anyone has tips on how to deal with the aliasing around the \n//pillars, without things getting too slow, I'd appreciate it.\n\n/*\nmusic that goes well with this:\n\nAbandoned pools - The remedy\nCelldweller - Afraid this time\nFallen - Night Lovell Type Beat \"GREY FIRE\"\n*/\n\n// I named this Griar based on grey + fire and I guess grass + briar\n\n      ////////////////////////////////////////////\n      //                                       //\n////////      CONSTANTS                      //\n      //                                   //\n      /////////////////////////////////////\n      \n#define far 110.\n#define pi acos(-1.)\n#define BLADE_NUM 5.\n#define BLADE_HEIGHT 3.\n#define BLADE_VAR_HEIGHT 1.\n#define TRACE_MAX 100.\n#define TRACE_ADD_AMOUNT 0.55\n#define TERRAIN_HEIGHT 10.\n#define WIND_SPEED 4. //2\n#define PILLAR_ROW_DEPTH -2.\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n      ////////////////////////////////////////////\n      //                                       //\n////////     ANIMATED TIME FUNCTIONS         //\n      //                                   //\n      /////////////////////////////////////\n      \n#define ats 4.\n//first create stairs \n#define stairs floor(iTime*atScale)*4.\n//or modstairs\n#define modStairs mod(iTime, 4.);\n//then create a swoop for each stair \n#define swoop pow(fract(iTime*atScale),8.)\n//or a smoothstep\n#define smooth smoothstep(3.5,4.,fract(iTime*atScale)*4.)\n//animation time constant?\n#define at iTime*0.9\n//or a sinwave\n#define sn iTime*8. + sin(iTime*2.)*2.+2.\n//then add the swooping stairs to time\n//or instead just do the right thing\n#define rightThing floor( at/4. )*ats + pow( fract( at/4. ) , 20. )*ats + at/4.\n#define animatedTime rightThing\n//mix(stairs,stairs+4.,fract(iTime*atScale)*4.+sin(iTime*atScale)*4.)\n//+ smoothstep(2.,4.,( 1.-abs( sin(iTime/4.) ))*20.)\n\nfloat noise(vec2 uv){\n\n    vec3 p3  = fract(vec3(uv.xyx) * .1831);\n    p3 += dot(p3, p3.yzx + 339.33);\n    return fract((p3.x + p3.y) * p3.z);\n  //return fract(sin(dot(uv,  vec2(23.,9341.)))*35342.);\n}\n\nfloat hash11(float x){\n    return fract(sin(x*43.)*21340.);\n}\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,-sa,sa,ca);\n}\n\nfloat noise1d(float x){\n    float init = hash11(floor(x));\n    float next = hash11(floor(x) + 1.);\n    float f = smoothstep(0.,1.,fract(x));\n    return mix(init, next, f);\n    \n}\nfloat noise2d(vec2 uv){\n  return texture(iChannel0,uv/64.).x;\n  \n  //This was fine at home but compile time\n  //on shadertoy doesn't like it\n  /*\n  vec2 id2d = floor(uv);\n  vec2 f2d = fract(uv);\n  \n  float a = noise(id2d);\n  float b = noise(id2d + vec2(1.,0.));\n  float c = noise(id2d + vec2(0.,1.));\n  float d = noise(id2d + vec2(1.,1.));\n  \n  vec2 smoothFract2d = smoothstep(0.,1.,f2d);\n  \n  float ab = mix(a,b,smoothFract2d.x);\n  float cd = mix(c,d,smoothFract2d.x);\n  return mix(ab,cd,smoothFract2d.y);*/\n  \n}\n\nmat2 rot45 = mat2(0.707,-0.707,0.707,0.707);\nfloat fbm(vec2 p){\n  float s = 0.5;\n    float f = s*noise2d(p); s/=2.; p *= 2.;\n  f += s*noise2d(p); s/=2.; p*=rot45; p *= 2.;\n  f += s*noise2d(p); s/=2.; p*=rot45; p *= 2.; \n  f += s*noise2d(p); s/=2.; p*=rot45; p *= 2.;\n  f += s*noise2d(p); s/=2.; p*=rot45; p *= 2.;\n  f += s*noise2d(p); s/=2.; p*=rot45; p *= 2.; \n    return f;\n}\n\n//ended up being just noise\nfloat fbm1(vec2 p){\n  float s = 0.5;\n    float f = s*noise2d(p); s/=2.; p *= 2.;\n\n    return f;\n}\n//ended up being just an fmb\nfloat warpedfbm(vec2 p){\n    \n  return  fbm(p/4.);\n\n}\n\nfloat sphere(vec3 p, float r){\n    return length(p)-r;\n}\n\nfloat cube(vec3 p, vec3 d){\n      p = abs(p) - d;\n  return length(max(vec3(0.),p)) + min(0.,max(p.x,max(p.y, p.z)));\n}\n\nfloat cylinder(vec3 p, float r, float h){\n    return max(length(p.xz) - r, -(h-abs(p.y)) );\n}\n\n//plane height\nfloat planeHohe = 0.4;\nfloat plane(vec3 p){\n    return p.y + planeHohe;\n}\n\nfloat id = 0.;\nfloat glow = 0.;\n\n\n\n      ////////////////////////////////////////////\n      //                                       //\n////////             MODELLING               //\n      //                                   //\n      /////////////////////////////////////\n      \n//make the snow/wisps\n  \nfloat wisps(vec3 p, float f){\n    vec3 sp = p;\n  sp.y += animatedTime*80.;\n  float scale = 24.;\n  vec3 wID = hash33(floor(sp/scale))*2.-1.;\n  vec3 wispOff = wID*(scale/4.9);\n  sp = mod(sp, vec3(scale)) - scale/2.;\n  float wispy = length(sp - wispOff) - 0.03;\n  f = min(f, wispy);\n  if(wispy == f) glow += 0.01/pow(wispy,2.);\n  return f;\n}\n\n//the grass field function, I use three of these\n//shited a bit each time \n//to get a more random grass pattern. I could have also rotated\n//but it worked out\n      \nfloat feld( vec3 p , float FID){\n  \n  vec3 wind = vec3(\n                  vec2(\n                        sin( animatedTime*WIND_SPEED + p.xz / 6. - cos( animatedTime*1. - p.xz / 14. )) * 0.2 ), 0. ).xzy\n                      * step( 0. , p.y + 0.4 ) * ( 3. * p.y);\n  p += wind;\n  vec2 id = floor(p.xz/4.);\n  float rndID = noise(id);\n  float rndID14 = floor(rndID*3.999)+1.;\n  float piTeil = 2.*pi/rndID14;\n  p.xz = mod(p.xz,4.)-2.;\n  p.xz*= rot(piTeil+0.);\n\n  //I can have the initial height as high as I want with\n  //zero issue.\n  //grass height\n  float grassHohe = BLADE_HEIGHT+FID*0.5;\n  //artifacts when hoheVar is higher, \n  //it's something probably to do with what blackle\n  //made a video on but I'm not doing instancing so \n  //it's weird. I just make random numbers in a for\n  //loop so why can't they be bigger allowing for more\n  //height?\n  float hoheVar = BLADE_VAR_HEIGHT;\n  float th = 0.075;\n  float f = 9999.;\n  float bladeNum = BLADE_NUM;//5 min\n  vec3 pos;\n  float waveAmount = 0.0 ;\n  float spread = 1.5;\n  \n  for(float i = 1.; i < bladeNum+1.; i++){\n    \n    float bladeNum01 = i/bladeNum;\n    float xn11 = bladeNum01*2.-1.;\n    \n    //I definitly can't have an id based\n    //on the instance id p.xz above the loop.\n    //that is the instancing Sin and it's \n    //unforgivable.\n    //th = max(0.1,pow(sin(th + i + FID)*0.1+0.1,1.3));\n    \n    float y = noise(vec2(i+FID,i+45.9));\n    float zn11 = y*2.-1.;\n    float endHohe = grassHohe+y*hoheVar*2.;\n    th = 0.2 - p.y/endHohe/5.;\n    pos = vec3(xn11*spread + cos(p.y+i)*waveAmount,\n                0.,\n               zn11*spread-sin(p.y+i*8.)*waveAmount);\n    f = min(f,cube( p - pos, vec3( th,endHohe,th) ));\n    //f = min(f, length(p - pos - vec3(0.,endHohe,0.))-0.2);\n  }\n  \n \n  return f;\n  \n}\n\n//pillar function makes the rows of pillars and\n//two oddly placed pillars\n//pillats are just cyliners here, defored by a polar\n//map of the xz axis through sin so it's an atan(z,x) thing\n//plus boxes on top and bottom\n\nfloat pillar(vec3 p){\n  \n  //rows of pillars\n  p.xz *= rot(1.+pi/2.);\n  vec3 pp = p + vec3(0., PILLAR_ROW_DEPTH,0.);\n  //pp.z += 70.;\n  pp.z = abs(pp.z)-70.;\n  pp.x = mod(pp.x,8.)-4.;\n  float cyl = cylinder(pp,2.5+abs(sin(atan(pp.x,pp.z)*10.))*0.1, 8.);\n  //top and bottoms of pillars\n  float cap = cube(vec3(pp.x,abs(pp.y)-8.,pp.z),\n                   vec3(2.8,1.,2.8)) - 0.3;\n  cyl = min(cyl,cap);    \n\n\n//position of single pillar 1 behind  \n  pp = p + vec3(45., 3.9, 13.);\n  //pp*=2.;\n  pp.yz *= rot(.8);\n  cyl = min(cyl, cylinder(pp,2.5+abs(sin(atan(pp.x,pp.z)*10.))*0.1, 8.));\n  cyl = min(cyl,cube(vec3(pp.x,abs(pp.y)-8.,pp.z),\n                   vec3(2.8,1.,2.8)) - 0.3);\n  \n  \n  //position of single pillar 2\n  pp = p + vec3(25., 3.5, -33.);\n  //pp*=2.;\n  pp.yz *= rot(pi/2.);\n  cyl = min(cyl, cylinder(pp,2.5+abs(sin(atan(pp.x,pp.z)*10.))*0.1, 8.));\n  cyl = min(cyl,cube(vec3(pp.x,abs(pp.y)-8.,pp.z),\n                   vec3(2.8,1.,2.8)) - 0.3);\n\n  //cube to subtract from one of the row pillars\n  pp = p + vec3(20., -12.5-PILLAR_ROW_DEPTH, 70.);\n  pp.yz *= rot(0.9);\n  cyl = max(cyl, -cube(pp,vec3(5.,20.,5.)) - 0.3);\n  \n  //float bridge = cube(p-vec3(0.,5.,0.), vec3(1000.,1.,5.))-0.2;\n // cyl = min(cyl, bridge);\n  return cyl;\n}\n\n//distance field where we put it all together\n\nfloat map( vec3 p ){\n  \n  //I get a few artifacts with this probably because it's\n  //adjusting the height of everything in the scene\n  //before instancing. So it's kind of like the unforgivable sin.\n   vec3 terrainHohe = vec3(0.,warpedfbm(p.xz/4.)*\n                              TERRAIN_HEIGHT,0.);\n  \n   //field id for moe randomness between feilds\n   float feldID = 0.;\n   //first field\n   float f =  feld(p + terrainHohe, feldID);\n   f = min( f, plane( p + terrainHohe ) );\n   \n   //shift p.xz\n   vec3 shift = vec3( 1.9, 0., 1.9 );\n   //increment field id\n   feldID++;\n   f = min( f, feld(  p + terrainHohe + shift, feldID));\n   //one more time\n   shift = vec3( -1.9, 0., 3.9 );\n   feldID++;\n   f = min( f, feld(  p + terrainHohe + shift, feldID));\n\n //add pillars\n  f = min(f,pillar(p) );\n  //add wisps\n  f = wisps(p,f);\n  \n   return f;\n   \n  }\n  \n  \n      ////////////////////////////////////////////\n      //                                       //\n////////   IMPORTANT TRACE/LIGHT FUNCTIONS   //\n      //                                   //\n      /////////////////////////////////////\n      \n      \n/*\nvec3 normal(vec3 p){\n   vec2 eps = vec2(0.001,0.);\n   return normalize(\n           vec3(\n           map(p-eps.xyy) - map(p+eps.xyy), \n           map(p-eps.yxy) - map(p+eps.yxy),\n           map(p-eps.yyx) - map(p+eps.yyx))\n           );\n}\n*/\n\n//fast normal\nvec3 normal(vec3 p)\n{\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.001*e);\n    }\n    return normalize(n);\n    }\n    \nfloat sss(vec3 p, vec3 ldir, float distToTravel){\n  \n  //Here is my basic understanding:\n  //step out form the hit point a bit in the direction of the sun\n  //find dist from map\n  //whne map dist is equal to step dist w have a/b = 1.\n  //when map dist is smaller we have a/b < 1.\n\n\n  return smoothstep(0.,1.,map(p + ldir*distToTravel)/distToTravel);\n  \n}\nfloat trace( vec3 ro, vec3 rd){\n    float t = 0., d;\n\n  \n  for(float i = 0.; i < TRACE_MAX; ++i){\n    \n    d = map(ro+rd*t);\n    \n    if( abs(d) < 0.001 ||  t > far) break;\n    \n    t += d * TRACE_ADD_AMOUNT;\n  }\n    return t;\n  }\n\n//create a ray based on ray origin and view target (ta)\nvec3 ray(vec2 uv, vec3 ro, vec3 ta){\n  \n    vec3 fwd = normalize(ta - ro);\n    vec3 uu = vec3(0.,1.,0.);\n    vec3 ri = normalize(cross(uu,fwd));\n    vec3 up = normalize(cross(fwd,ri));\n  \n    \n    return normalize(uv.x*ri + uv.y*up + fwd*0.9);\n}\n\n\n\n      ////////////////////////////////////////////\n      //                                       //\n////////              MAIN                   //\n      //                                   //\n      /////////////////////////////////////\n      \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n  vec2 uv = vec2(fragCoord.x / iResolution.x,      \n                 fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  //the black bars at the end\n  //and it adusts the focal length! A happy accident I almost\n  //didn't realize I was doing.\n  //it adjusts the focal length because calculating rd \n  //a bit further down will depend on uv\n  \n  uv *= (sin(animatedTime)*0.3+1.01);\n  \n      ////////////////////////////////////////////\n      //                                       //\n////////          CAMERA WORK                //\n      //                                   //\n      /////////////////////////////////////\n      \n  vec3 ro = vec3(cos(animatedTime*.05)*20.5, 10., -10.);\n  //ro = vec3(cos(iTime*0.3)*20., 10. + 1.*sin(iTime), - 20.+sin(iTime*0.3)*20.);\n  \n  //ro.xz *= rot(.9 +iTime*0.3);\n  //ro+=4;\n  //ro.yz *= rot(iTime*0.71);\n  vec3 ta = ro + vec3(0., -.05, 1.);\n  vec3 rd = ray(uv, ro, ta);\n  rd.xz *= rot(5.45 + sign(sin(iTime/6.))*(animatedTime*.2)*.5);// sin(iTime*0.1)*.5);//iTime*0.13);//sin(iTime*0.3)*1.4);\n  vec3 col = vec3(0.);\n  \n      ////////////////////////////////////////////\n      //                                       //\n////////      TRACE AND LIGHT CALCS          //\n      //                                   //\n      /////////////////////////////////////\n      \n  vec3 lightDir = normalize(vec3(1.,.1,1.));\n  \n  float t = trace(ro, rd);\n  vec3 p = ro + rd*t;\n  vec3 n = normal(p);\n  \n  \n  \n  if(t < far){\n    \n      float steps = 5.;\n      float ss = 0.;\n      for(float i = 1.; i <= steps; i++){\n      //this sss shadow function comes from nusan and it\n      //ended up being very important for this shader\n      //because it does lighting ans shadow at the same time\n          ss += sss(p,normalize(vec3(1.,1.,1.)),i*8./steps);\n      }\n        \n        //*max(0.5,dot(lightDir,n))*diff);//+spec*1.;\n        // mix(col, vec3(1.), );\n      //col = (vec3(0.5,0.,0.) + (n*0.2+0.2) ) + max((p.y+4.)/4.,2.);//+spec*1.;\n     //col = (vec3(0.5,0.,0.) + (n*0.2+0.2) ) * max((p.y+4.)/2.,1.);//+spec*1.;\n        \n      \n      float diff = max(0.,dot(lightDir,n));\n        float spec = pow(max(dot(reflect(-lightDir,n),-rd),0.),4.);\n        \n        //original baseColor was:\n        //vec3(0.7,0.,0.) + (n*0.2+0.);\n        //but the faster normal function washes it out so I \n        //hacked it a bit to get the richness back\n      vec3 baseColor = vec3(0.8,0.,0.) + (n*0.2-0.1);\n      //baseColor.xz *= rot(-0.1);\n      \n      //call pillars one more time and if hit point is close\n      //enough to them, color with their material\n      if(pillar(p) < 0.005){\n        baseColor = vec3(0.1);// + n*0.1+0.1;\n        col = baseColor + diff*0.6 + spec*0.2;\n      }\n      //otherwise color based on grass (and wisps will also be\n      //initially coloed based on grass but it wont matter because\n      //the glow is all that matters. Glow is all that ever matters.\n      else{\n      //all the colors\n      //baseColor.xz *= rot(-.3);\n      col = mix( baseColor, vec3(1.,1.2,1.5), min(pow(max(p.y+.4,1.),3.)/40., 1.)*2.);\n      }\n      ss/=(steps/2.);\n      \n      //This first line is critical to the\n      //color of the scene. Everything is\n      //being shaded based on accumulated \n      //distances ffrm hit point light direction\n      //it's from Nusan's tutorial on youtube\n      col *= clamp(ss,0.,1.);\n      col += clamp(ss*0.1,0.,1.)*2.5;\n      //this is where th magic happends\n      col += pow(clamp(ss*0.1,0.,1.)*9.,8.)*(0.5+0.5*max(0.,dot(lightDir,rd)));\n  }\n  float ende = t;\n\n\n      ////////////////////////////////////////////\n      //                                       //\n////////      SKY SKY SKY SKY SKY            //\n      //                                   //\n      /////////////////////////////////////\n      \n  //col = vec3(pow(1.-abs(fbm(uv*8.)*2.-1.),8.));\n  //col = vec3(warpedfbm(uv*20.));\n  vec3 sky = vec3(0.);\n  float moonTextureCut = smoothstep(0.999,0.9995,dot(lightDir,rd));\n  float moonTexture = pow(fbm(rd.xy*70.+4.),4.)*1.5;\n  moonTexture *= moonTextureCut;\n  \n  //fbm(rd.xy*100.);\n // moonTexture = step(pow(max(0.,dot(lightDir,rd)),2000.),moonTexture);\n  //;\n  //moone\n  //moonlight calc \n  float moonValue = max(0.,dot(lightDir,rd));\n  float moonCircle = pow(moonValue,2000.)*5.;\n  moonCircle = clamp(moonCircle,0.,1.);\n  moonCircle -= moonTexture;\n  sky = mix(sky, vec3(0.95,0.95,1.),moonCircle); \n  //light\n  sky = mix(sky, vec3(0.2,0.95,1.), pow(moonValue,100.)*0.1);\n  //less light\n  sky = mix(sky, vec3(0.5,0.5,1.), pow(moonValue,20.)*0.1);\n  \n  //horizon under moon\n // sky = mix(sky, vec3(0.95,0.3,.2)*0.3, max(0.,pow(0.5-uv.y,2.5))*4.*0.);\n  sky = mix(sky, vec3(0.2,0.6,.8), max(0.,pow(0.5-rd.y+0.,3.5)));\n  \n  sky = mix(sky, vec3(0.6,0.2,.2), pow(max(0.,dot(-lightDir-vec3(0.,.4,0.),rd)),20.)*0.3*step(0.,rd.y+0.13));\n  \n  sky = mix(sky, vec3(0.2,0.6,1.), smoothstep(0.,1.,pow(max(0.,rd.y-0.1),30.))*0.5);\n  \n  /*\n   vec2 st = rd.xy;\n  //st.x += x;\n  st.y = mod( st.y + iTime*0.1 , 1. );\n  st.y += sin(iTime*0.1)*.3;\n  float comet = length((st.xy-vec2(0.0,0.03))*100.)-0.4;\n \n  st.y-=0.1;\n  float tail = max(abs(st.x*200)-0.1,abs(st.y*12.)-0.3+st.y*3.);\n  tail = smoothstep(0.,1.,tail);\n  comet = min(comet,max(tail,0.));\n  comet = 1.-smoothstep(0.2,1.,comet);\n  sky = mix(sky, vec3(1.), comet*step(0.,rd.z));\n  */\n  //float noiseforMoonAndStars = noise2d(rd.xy*350.);\n  //rotating the rd vector around xz to get away from\n  //the screen stretching that happsens to either side\n  //of x\n  vec2 rrdxy = vec2((rd.xz *rot(1.5)).x,rd.y);\n  vec2 starCoord = mod(rd.xy*500.,20.)-10.;\n  float starID = noise(floor(rd.xy*500.));\n  float stars = length(starCoord+starID*100.)-0.01;\n  sky = mix(sky, vec3(1.), max(0.,1.0-stars)*smoothstep(0.0,0.3,rd.y));\n  \n  starCoord = mod(rrdxy*200.,20.)-10.;\n  starID = noise(floor(rrdxy*200.));\n  stars = length(starCoord+starID*100.+5.)-0.1;\n  //sky = mix(sky, vec3(1.), max(0.,1.0-stars)*smoothstep(0.0,.3,rd.y));\n  //sky = mix(sky, vec3(1.), pow(noiseforMoonAndStars,200.)*4.);\n  sky = mix(sky, vec3(0.2,0.6,1.), \n        pow(\n        max(0.,\n        fbm( rd.xy*vec2(3.,8.)))*moonValue*1.6,12.)*0.2\n        *smoothstep(0.95,0.,abs(rd.x)));\n        \n   \n  sky = mix(sky, vec3(0.2,0.6,1.), \n        pow(max(0.,\n        fbm( (rrdxy)*4.))-0.2,2.)*0.2\n        *smoothstep(0.95,0.,abs(rrdxy.x)));\n  \n  float fog = pow(clamp((t)/(far-0.),0.,1.),7.);\n  col = mix(col, sky, fog);\n  //col = mix(col, vec3(0.2,0.8,1.), \n  //      pow(max(0.,\n  //      fog*fbm( vec2(atan(rd.x,rd.z)*pi*2.,rd.y*8.) + vec2(iTime,0.)))-0.2,2.));\n  \n  \n      ////////////////////////////////////////////\n      //                                       //\n////////      POST PROCESS AND GLOW          //\n      //                                   //\n      /////////////////////////////////////\n      \n  col = pow(col,vec3(0.79));\n  col += glow;\n  //col = vec3(moonTexture);\n  col *= smoothstep(0.001,0.0,abs(uv.y)-0.4);\n  fragColor = vec4(col, 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}