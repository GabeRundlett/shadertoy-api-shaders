{
    "Shader": {
        "info": {
            "date": "1499416181",
            "description": "Professor Rahul Narain noticed that under the y=smoothstep(x) inversion ([url]https://www.shadertoy.com/view/MsSBRh[/url]) one gets cos(acos(v)/3) = cos(u/2), for uv = 2xy-1. Use the mouse to move the contruction.",
            "flags": 0,
            "hasliked": 0,
            "id": "MsBfR1",
            "likes": 9,
            "name": "Trisection in Smoothstep",
            "published": 3,
            "tags": [
                "2d",
                "acos",
                "smothstep",
                "trivision"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 984
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// The inverse function of the smoothstep y(x) = x²(3-2x) has analytic inverse of the form\n//\n//    y = 0.5 - sin(asin(1-2*x)/3)\n//\n// Professor Rahul Narain noticed that if uv = 2xy-1, then\n//\n//    asin(v)/3 = asin(u/2)\n//\n// which means that \n//\n//    cos( acos(v)/3 ) = u/2\n//\n// This shader shows the geometric construction behind this fact (the smoothstep is in xy and the circle is in uv)\n//\n// 1. We pick a value for v (with the mouse, orange point)\n// 2. We project vertically into the smoothstep\n// 3. We project horizontally into the unit circle\n// 4. We take tha angle produced\n// 5. We trisect it\n// 6. We project horizontally to get the green point\n// 7. The length of the green segment is half of the red segment\n\n\nconst int[] font = int[](0x75557, 0x22222, 0x74717, 0x74747, 0x11574, 0x71747, 0x71757, 0x74444, 0x75757, 0x75747);\nconst int[] powers = int[](1, 10, 100, 1000, 10000, 100000, 1000000);\n\nint PrintInt( in vec2 uv, in int value, const int maxDigits )\n{\n    if( abs(uv.y-0.5)<0.5 )\n    {\n        int iu = int(floor(uv.x));\n        if( iu>=0 && iu<maxDigits )\n        {\n            int n = (value/powers[maxDigits-iu-1]) % 10;\n            uv.x = fract(uv.x);//(uv.x-float(iu)); \n            ivec2 p = ivec2(floor(uv*vec2(4.0,5.0)));\n            return (font[n] >> (p.x+p.y*4)) & 1;\n        }\n    }\n    return 0;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float px = 1.0/iResolution.y;\n    vec2  uv = (-iResolution.xy+2.0*fragCoord)/iResolution.y;\n    \n    float  u = clamp( (-iResolution.x+2.0*iMouse.x)/iResolution.y, -1.0, 1.0 );\n\tif( iMouse.z<0.001 ) u = 0.98*sin(iTime*0.5);\n    vec3 col = vec3(0.0);\n    \n    if( uv.x>-1.0 && uv.x<1.0 )\n    {\n        // grid\n        col = vec3( 0.2 ) + 0.01*mod(floor(uv.x*10.0)+floor(uv.y*10.0),2.0);\n        // smoothstep\n        vec2 xy = uv*0.5 + 0.5;\n        float y1 = smoothstep( 0.0, 1.0, xy.x );\n        col = mix( col, vec3(0.0,0.4,0.7), 1.0-smoothstep( 0.0, 2.0*px, abs(xy.y-y1) ) );\n\t\t// circle\n        col = mix( col, vec3(0.0,0.0,0.0), 1.0-smoothstep( 0.0, 2.0*px, abs(length(uv)-1.0) ) );\n\t\t// axes\n        col = mix( col, vec3(0.0,0.0,0.0), 1.0-smoothstep( 0.0, 2.0*px, abs(uv.x) ) );\n        col = mix( col, vec3(0.0,0.0,0.0), 1.0-smoothstep( 0.0, 2.0*px, abs(uv.y) ) );\n\n\n        // compute geometry\n        \n        vec2 p0 = vec2(0.0,1.0);\n        // project vertically\n        vec2 p1 = vec2(u,1.0); \n        // project into smoothstep\n        vec2 p2 = vec2(u,(3.0*u-u*u*u)/2.0); // x²(3-2x) becomes (3u-u^3)/2 under -1..1 normalization\n        // project into circle\n        vec2 p3 = vec2(sqrt(1.0-p2.y*p2.y),p2.y);\n        // trisection\n        float an = asin(p2.y);\n        vec2 p4 = vec2(cos(an*(2.0/3.0)),sin(an*(2.0/3.0)));\n        vec2 p5 = vec2(cos(an*(1.0/3.0)),sin(an*(1.0/3.0)));\n        // project horizontally\n        vec2 p6 = vec2(1.0,p5.y);\n        vec2 p7 = vec2(1.0,0.0);\n        vec2 p9 = vec2(0.0,0.0);\n\n        col = mix( col, vec3(1.0,0.3,0.0), 1.0-smoothstep( 0.0, 2.0*px, sdSegment(uv, p0, p1) ) );\n        col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep( 0.0, 2.0*px, sdSegment(uv, p1, p2) ) );\n        col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep( 0.0, 2.0*px, sdSegment(uv, p2, p3) ) );\n        col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep( 0.0, 2.0*px, sdSegment(uv, p9, p3) ) );\n        col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep( 0.0, 2.0*px, sdSegment(uv, p9, p4) ) );\n        col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep( 0.0, 2.0*px, sdSegment(uv, p9, p5) ) );\n        col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep( 0.0, 3.0*px, sdSegment(uv, p5, p6) ) );\n        col = mix( col, vec3(0.0,0.7,0.3), 1.0-smoothstep( 0.0, 3.0*px, sdSegment(uv, p6, p7) ) );\n        col = mix( col, vec3(1.0,0.3,0.0), 1.0-smoothstep( 0.0, 2.0*px, length(uv-p1)-9.0*px ) );\n        col = mix( col, vec3(0.0,0.7,0.3), 1.0-smoothstep( 0.0, 2.0*px, length(uv-p6)-9.0*px ) );\n\n        col += vec3(1.0,0.3,0.0)*float( PrintInt( (uv-vec2(0.5,-0.80))*10.0, int(round(abs(10000.0*p1.x))), 5 ) );\n        col += vec3(0.0,0.7,0.3)*float( PrintInt( (uv-vec2(0.5,-0.95))*10.0, int(round(abs(10000.0*p6.y))), 5 ) );\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}