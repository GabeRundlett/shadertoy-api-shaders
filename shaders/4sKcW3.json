{
    "Shader": {
        "info": {
            "date": "1523554996",
            "description": "endless road",
            "flags": 0,
            "hasliked": 0,
            "id": "4sKcW3",
            "likes": 1,
            "name": "\"Off-white\" ver1",
            "published": 3,
            "tags": [
                "demo"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 482
        },
        "renderpass": [
            {
                "code": "#define SPEED 5.0\n\nvec3 lineTex(vec2 uv)\n{\n    return vec3(tan((uv.x+uv.y+(-iTime/10.0))*10.0)*10.0,tan((uv.x+uv.y+(-iTime/10.0))*10.0)*10.0,tan((uv.x+uv.y+(-iTime/10.0))*10.0)*10.0);\n}\n\nfloat noise(float x) {\n    return fract(sin(dot(vec2(x), vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// Tunnel pattern studied from shane & shau\n// i.e. https://www.shadertoy.com/view/4tKXzV\nvec2 path(float t) {\n    float a = sin(t*.2 + 1.5), b = sin(t*.2);\n    return vec2(a*2., a*b);\n}\n\nvec3 camera(vec3 ro, vec2 uv, vec3 ta) {\n    vec3 fwd = normalize(ta - ro);\n    vec3 left = cross(vec3(0, 1, 0), fwd);\n    vec3 up = cross(fwd, left);\n    return normalize(fwd + uv.x*left + up*uv.y);\n}\n\nfloat sdSphere (vec3 p, float r) {\n    return length(p)-r; \n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) return val1;\n    return val2;\n}\n\nvec4 map(vec3 p) {\n    vec3 lTex = lineTex(p.xy);\n    \n    p.xy -= path(p.z)*0.1;\n    float t = 100.0;\n    float w = 0.0;\n\n    float n = floor(p.z/0.5);\n\n    vec3 oldp = p;\n    p.z = mod(p.z, 1.0)-0.5;\n\n    w = sdBox(p-vec3(0.0,-1.2,0.0),vec3(0.03, 0.01, 0.3));\n    t = min(t, w);\n\n    w = 0.1 + dot(oldp, vec3(0, 0.0, 0.0));\n    t = min(t, w);\n\n\n    vec4 temp1 = vec4(0.0,0.0,0.0, t);\n \tvec4 temp2 = vec4(0.8,0.8,0.1, sdBox(p-vec3(0.0,-1.21,0.0),vec3(1.0, 0.01, 1.0)));\n    \n    p.y += noise(n)*1.0+sin(2.0)*0.1;\n    p.x += noise(n)*0.3-0.15;\n\t\n   \n    vec4 temp3 = vec4(lTex, sdBox(p+vec3(0.8,0.0,0.0),vec3(0.2, 1.0, 0.3)));\n    vec4 temp4 = vec4(lTex, sdBox(p+vec3(-0.8,0.0,0.0),vec3(0.2, 1.0, 0.3)));\n\n    vec4 res1 = combine(temp1,temp2);\n    vec4 res2 = combine(temp3,temp4);\n    vec4 res3 = combine(res1,res2);\n\n    return res3;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n    vec3  dir;\n\n    vec3 pos = vec3(0.0, 0.0, iTime*SPEED);\n\n    float dt = iTime * 6.;\n    vec3 ro = vec3(0, 0, -4. + dt);\n    vec3 ta = vec3(0, -2, dt);\n    vec3 rd;\n\n    ro.xy += path(ro.z);\n    ta.xy += path(ta.z);\n\n    dir = camera(ro, uv, ta);\n\n    float t = 0.0;\n    vec3 modelCl;\n    for(int i = 0 ; i < 50; i++) {\n        vec4 temp = map(t * dir + pos);\n        modelCl = temp.xyz;\n        if(temp.w < 0.01) break;\n        t += temp.w * 1.0;\n    }\n\n    vec3 ip = pos + dir * t;\n    vec4 cl = vec4(t * 0.01) * map(ip - 0.02) + t * 0.3;\n\n    fragColor = cl+vec4(modelCl,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}