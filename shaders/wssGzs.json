{
    "Shader": {
        "info": {
            "date": "1547258706",
            "description": "Basic CMYK Halftoning with varying screen angles.\nMouse Y - Detail\nMouse X - DJing\nhttps://en.wikipedia.org/wiki/Halftone\nhttps://en.wikipedia.org/wiki/Screen_angle",
            "flags": 0,
            "hasliked": 0,
            "id": "wssGzs",
            "likes": 2,
            "name": "Halftoned London",
            "published": 3,
            "tags": [
                "texture",
                "dither",
                "halftone",
                "cmyk",
                "printing"
            ],
            "usePreview": 0,
            "username": "Blokatt",
            "viewed": 1011
        },
        "renderpass": [
            {
                "code": "/*\nHalftoned London\nBy Blokatt (@blokatt | blokatt.net)\n17/01/2019\n*/\n\n#define MOTION_BLUR_LENGTH 0.025\n#define MOTION_BLUR_SAMPLES 10.0\n#define TIME_OFFSET (26.5 + 5. * (iMouse.x / iResolution.x - .5))\n#define GRID_SIZE (2. + 1.5 * (iMouse.y / iResolution.y))\n\nconst float MOTION_BLUR_FALOFF = 1.0 - (1.0 / (1. + MOTION_BLUR_SAMPLES * 0.3));\nconst float MOTION_BLUR_LENGTH_OFFSET = MOTION_BLUR_LENGTH / MOTION_BLUR_SAMPLES;\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a),\n        \t\tsin(a), cos(a));\n}\n\nvec4 vec4Smoothstep(vec4 a, vec4 b, float v){\n\treturn vec4(\n        \tsmoothstep(a.r, b.r, v),\n        \tsmoothstep(a.g, b.g, v),\n        \tsmoothstep(a.b, b.b, v),\n    \t\tsmoothstep(a.a, b.a, v));\n}\n\nvec3 contrast(vec3 col, float v){\n\treturn (col - .5) * v + .5;\n}\n\nfloat sharpOsc(float x, float n){\n    float p = sign(((mod(x * .5, 2.) * .5) - .5));\n    return (1. - pow(1. - mod(x, 2.), n)) * p;\n}\n\n\n//RGV->CMYK conversion\n//https://www.rapidtables.com/convert/color/rgb-to-cmyk.html\nvec4 cmyk(vec3 rgb){\n    float a = 1. - max(rgb.r, max(rgb.g, rgb.b));    \n    return vec4((1. - rgb - a)  / (1. - a), a);\n}\n\nvec4 halftone(float grid, float angle, vec2 uv){                \n    uv *= rot(angle); //Screen rotation\n    \n    //Cell position\n    float cellSize = 1. / grid;\n    vec2 dotPos;\n    dotPos.y = floor(uv.y * grid) / grid + cellSize / 2.;    \n    float off = floor(mod(dotPos.y * grid, 2.)); //odd offset\n    dotPos.x = floor(uv.x * grid - off * .5) / grid + cellSize / 2.;\t\n    dotPos.x += off * cellSize / 2.;\n\t\n    //Texture\n    vec2 texelPos = dotPos * rot(-angle); //Fetch texel, compensate for screen angle\n    texelPos.x *= iResolution.y / iResolution.x; //Denormalise\n\n    //RGB->CMYK->4 radii\n    vec4 cmyk = cmyk(vec3(texture(iChannel0, texelPos + .5).rgb)) * cellSize;     \n    return vec4(vec4Smoothstep(cmyk * .5, cmyk * .3, distance(dotPos, uv))); \n\n}\n\nvec4 image(vec2 uv, float t){\n    t *= .3;\n    \n    //Camera shenanigans\n    float _z = sharpOsc(t * .5 - .5, 8.);\n    float zoom = 1.75 + 3. * (.5 + .5 * _z);\n    uv.x += (.5 * (zoom - 1.)) * sharpOsc(t * .5 + .5, 8.);\n    uv.y += (-.28 * (zoom - 1.)) * sharpOsc(t * .25 + .25, 8.) + .17 * (zoom - 1.) ;    \n\tuv *= 1. / zoom;\n    vec2 normUv = uv;\n    uv.x *= iResolution.x / iResolution.y;    \n    \n    float grid = iResolution.x * .15 * GRID_SIZE;       \n    float tt = t * .05;\n    vec3 col = vec3(.9) - vec3(.1, 0., 0.) * halftone(grid, radians(15.) + tt, uv).r\n        \t\t\t\t- vec3(0., 1., 0.) * halftone(grid, radians(75.) + tt, uv).g\n        \t\t\t\t- vec3(0., 0., 1.) * halftone(grid, \t\t\t   tt, uv).b\n        \t\t\t\t- \t\t\t\t\t halftone(grid, radians(45.) + tt, uv).a;\n    col *= 1. - .05 * contrast(texture(iChannel1, uv * 20.).rrr, 1.5);\n   \n    return mix(texture(iChannel0, normUv + .5), vec4(col, 1.0), clamp(0., 1., _z * .5 + .8));\n}\n\nvec4 trail(vec2 uv, float t){\n    t += TIME_OFFSET;\n\tvec4 col = image(uv, t);\n    float factor = .5;\n    for (float i = 1.; i < MOTION_BLUR_SAMPLES; i += 1.){\n    \tcol = mix(col, image(uv, t - i * MOTION_BLUR_LENGTH_OFFSET), 1. * factor);\n        factor *= MOTION_BLUR_FALOFF;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n  \tvec2 uv = fragCoord/iResolution.xy - .5;  \n    fragColor = trail(uv, iTime) - smoothstep(.5, 1.75, 2.5 * length(uv * .7));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}