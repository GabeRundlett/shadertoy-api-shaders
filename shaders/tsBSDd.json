{
    "Shader": {
        "info": {
            "date": "1555326176",
            "description": "Made hairs before in JS canvas with lines https://avin.github.io/sketches/018_hair.html\nNow it's time to make something like that in GLSL :)\n",
            "flags": 0,
            "hasliked": 0,
            "id": "tsBSDd",
            "likes": 37,
            "name": "Hairs on your body ;)",
            "published": 3,
            "tags": [
                "lines",
                "hairs",
                "stubble",
                "beard"
            ],
            "usePreview": 0,
            "username": "avin",
            "viewed": 1230
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926\n#define HAIR_LEN 4.\n#define SKIN_COL vec3(226,204,190)/255.\n#define HAIR_COL vec3(35,33,28)/255.\n\n// Simplex noise from https://www.shadertoy.com/view/4sdGD8\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}\n\nfloat rand(vec2 co) { \n    return fract(sin(dot(co.xy , vec2(12.9898, 78.233))) * 43758.5453);\n} \n\nfloat hairLine(vec2 p, float len, float thickness, float blur, float bendFactor){    \n        \n    p.x += sin(p.y*3. + iTime*10. + bendFactor)*.025;\n    float result = smoothstep(thickness, thickness - blur, abs(p.x));    \n    result *= (1. - step(.0, p.y));\n    \n    // Limit length\n    float d = length(p);\n    result*= (1. - step(len, d));\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.x;\n    vec2 ouv = uv;\n    \n    float SIZE = floor(iResolution.x/15.);\n    \n    float sm = 1./iResolution.y * SIZE*0.80;\n       \n    \n    uv *= SIZE;\n    vec2 id = floor(uv);\n    uv = fract(uv);           \n          \n    float mask = 0.;\n    vec3 col = vec3(0.);\n    for(float y=-3.; y<=3.; y+=1.){\n        for(float x=-3.; x<=3.; x+=1.){\n            \n            vec2 rid = id;\n            rid.x-=x;\n            rid.y-=y;\n            \n            vec2 orid = rid;\n            \n            // Random thickness for realistic\n            float thickness = rand(rid)*0.015 + 0.05;\n            float ra = rand(rid);\n            float ra2 = rand(rid+1.);\n            \n            rid/=SIZE;\n            rid.x+=iTime*0.2;\n                                    \n            float a = snoise(rid*2.)*PI; // not 2*PI for one side rotation only            \n            a+=ra*0.40;                       \n            \n            vec2 ruv = uv;            \n            ruv.x+=x + (ra - .5)*.5; //+some randomness\n            ruv.y+=y + (ra2 - .5)*.5;             \n            \n            float rotaDir = (floor(mod(orid.x+orid.y, 2.))*2.-1.);\n            float rotaForce = rand(orid)*1.0;\n            float rota = a+(length(ruv*0.1)*0.8)*rotaDir*rotaForce;\n            \n            float ca = cos(rota);\n            float sa = sin(rota);\n            mat2 rot = mat2(ca, -sa, sa, ca);                       \n                                   \n            ruv *= rot;\n                        \n            float hairLen = HAIR_LEN + ((ra + ra2)*0.5 - 0.5); //+some randomness\n            float bendFactor = id.x+id.y;\n    \t\tmask += hairLine(ruv, hairLen, thickness, sm, bendFactor);\n            \n            col = mix(SKIN_COL, HAIR_COL, mask);\n            \n            // Make light depending angle\n            col += a*0.03;\n        }\n    }\n                         \n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}