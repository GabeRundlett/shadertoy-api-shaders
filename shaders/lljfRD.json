{
    "Shader": {
        "info": {
            "date": "1516448535",
            "description": "This was a study on circles inpired by this [url=http://www.dailymail.co.uk/news/article-1236380/Worlds-largest-artwork-etched-desert-sand.html]artwork[/url] . You can play circle inversion with your mouse...",
            "flags": 0,
            "hasliked": 0,
            "id": "lljfRD",
            "likes": 164,
            "name": "It's a Question of Time",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "circle",
                "apollonian"
            ],
            "usePreview": 0,
            "username": "rigel",
            "viewed": 17435
        },
        "renderpass": [
            {
                "code": "// Author: Rigel rui@gil.com\n// licence: https://creativecommons.org/licenses/by/4.0/\n// link: https://www.shadertoy.com/view/lljfRD\n\n\n/*\nThis was a study on circles, inspired by this artwork\nhttp://www.dailymail.co.uk/news/article-1236380/Worlds-largest-artwork-etched-desert-sand.html\n\nand implemented with the help of this article\nhttp://www.ams.org/samplings/feature-column/fcarc-kissing\n\nThe structure is called an apollonian packing (or gasket)\nhttps://en.m.wikipedia.org/wiki/Apollonian_gasket\n\nThere is a lot of apollonians in shadertoy, but not many quite like the image above.\nThis one by klems is really cool. He uses a technique called a soddy circle. \nhttps://www.shadertoy.com/view/4s2czK\n\nThis shader uses another technique called a Descartes Configuration. \nThe only thing that makes this technique interesting is that it can be generalized to higher dimensions.\n*/\n\n\n// a few utility functions\n// a signed distance function for a rectangle\nfloat sdfRect(vec2 uv, vec2 s) {vec2 auv = abs(uv); return max(auv.x-s.x,auv.y-s.y); }\n// a signed distance function for a circle\nfloat sdfCircle(vec2 uv, vec2 c, float r) { return length(uv-c)-r; }\n// fills an sdf in 2d\nfloat fill(float d, float s, float i) { return abs(smoothstep(0.,s,d) - i); }\n// makes a stroke of an sdf at the zero boundary\nfloat stroke(float d, float w, float s, float i) { return abs(smoothstep(0.,s,abs(d)-(w*.5)) - i); }\n// a simple palette\nvec3 pal(float d) { return .5*(cos(6.283*d*vec3(2.,2.,1.)+vec3(.0,1.4,.0))+1.);}\n// 2d rotation matrix\nmat2 uvRotate(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n// circle inversion\nvec2 inversion(vec2 uv, float r) { return (r*r*uv)/vec2(dot(uv,uv)); }\n// seeded random number\nfloat hash(vec2 s) { return fract(sin(dot(s,vec2(12.9898,78.2333)))*43758.5453123); }\n\n// this is an algorithm to construct an apollonian packing with a descartes configuration\n// remaps the plane to a circle at the origin and a specific radius. vec3(x,y,radius)\nvec3 apollonian(vec2 uv) {\n    // the algorithm is recursive and must start with a initial descartes configuration\n    // each vec3 represents a circle with the form vec3(centerx, centery, 1./radius)\n    // the signed inverse radius is also called the bend (refer to the article above)\n    vec3 dec[4];\n    // a DEC is a configuration of 4 circles tangent to each other\n    // the easiest way to build the initial one it to construct a symetric Steiner Chain.\n    // http://mathworld.wolfram.com/SteinerChain.html\n\tfloat a = 6.283/3.;\n\tfloat ra = 1.+sin(a*.5);\n\tfloat rb = 1.-sin(a*.5);\n\tdec[0] = vec3(0.,0.,-1./ra);\n    float radius = .5*(ra-rb);\n\tfloat bend = 1./radius;\n    for (int i=1; i<4; i++) {\n        dec[i] = vec3(cos(float(i)*a),sin(float(i)*a),bend);\n        // if the point is in one of the starting circles we have already found our solution\n        if (length(uv-dec[i].xy) < radius) return vec3(uv-dec[i].xy,radius);\n    }\n    \n    // Now that we have a starting DEC we are going to try to \n    // find the solution for the current point\n    for(int i=0; i<7; i++) {\n        // find the circle that is further away from the point uv, using euclidean distance\n        int fi = 0;\n        float d = distance(uv,dec[0].xy)-abs(1./dec[0].z);\n        // for some reason, the euclidean distance doesn't work for the circle with negative bend\n        // can anyone with proper math skills, explain me why? \n        d *= dec[0].z < 0. ? -.5 : 1.; // just scale it to make it work...\n        for(int i=1; i<4; i++) {\n            float fd = distance(uv,dec[i].xy)-abs(1./dec[i].z);\n            fd *= dec[i].z < 0. ? -.5: 1.;\n            if (fd>d) {fi = i;d=fd;}\n        }\n        // put the cicle found in the last slot, to generate a solution\n        // in the \"direction\" of the point\n        vec3 c = dec[3];\n        dec[3] = dec[fi];\n        dec[fi] = c;\n        // generate a new solution\n        float bend = (2.*(dec[0].z+dec[1].z+dec[2].z))-dec[3].z;\n        vec2 center = vec2((2.*(dec[0].z*dec[0].xy\n                               +dec[1].z*dec[1].xy\n                               +dec[2].z*dec[2].xy)\n                               -dec[3].z*dec[3].xy)/bend);\n\n\t\tvec3 solution = vec3(center,bend);\n\t\t// is the solution radius is to small, quit\n\t\tif (abs(1./bend) < 0.01) break;\n\t\t// if the solution contains the point return the circle\n    \tif (length(uv-solution.xy) < 1./bend) return vec3(uv-solution.xy,1./bend);\n    \t// else update the descartes configuration,\n    \tdec[3] = solution;\n    \t// and repeat...\n\t}\n\t// if nothing is found we return by default the inner circle of the Steiner chain\n\treturn vec3(uv,rb);\n}\n\n\nvec3 scene(vec2 uv, vec4 ms) {\n    \n\tvec2 ci = vec2(.0);\n\n    // drag your mouse to apply circle inversion\n    if (ms.y != -2. && ms.z > -2.) {\n        uv = inversion(uv,cos(radians(60.)));\n        ci = ms.xy;\n    }    \n\n    // remap uv to appolonian packing\n    vec3 uvApo = apollonian(uv-ci);\n    \n    float d = 6.2830/360.;\n    float a = atan(uvApo.y,uvApo.x);\n    float r = length(uvApo.xy);\n\n    float circle = sdfCircle(uv,uv-uvApo.xy,uvApo.z);\n\t\n    // background\n\tvec3 c = length(uv)*pal(.7)*.2;\n    \n    // drawing the clocks\n    if (uvApo.z > .3) {\n    \tc = mix(c,pal(.75-r*.1)*.8,fill(circle+.02,.01,1.)); // clock \n    \tc = mix(c,pal(.4+r*.1),stroke(circle+(uvApo.z*.03),uvApo.z*.01,.005,1.));// dial\n\n        float h = stroke(mod(a+d*15.,d*30.)-d*15.,.02,0.01,1.);\n    \tc = mix(c,pal(.4+r*.1),h*stroke(circle+(uvApo.z*.16),uvApo.z*.25,.005,1.0));// hours\n\n        float m = stroke(mod(a+d*15.,d*6.)-d*3.,.005,0.01,1.);\n    \tc = mix(c,pal(.45+r*.1),(1.-h)*m*stroke(circle+(uvApo.z*.15),uvApo.z*.1,.005,1.0));// minutes, \n    \t\n    \t// needles rotation\n    \tvec2 uvrh = uvApo.xy*uvRotate(sign(cos(hash(vec2(uvApo.z))*d*180.))*d*iTime*(1./uvApo.z*10.)-d*90.);\n    \tvec2 uvrm = uvApo.xy*uvRotate(sign(cos(hash(vec2(uvApo.z)*4.)*d*180.))*d*iTime*(1./uvApo.z*120.)-d*90.);\n    \t// draw needles \n    \tc = mix(c,pal(.85),stroke(sdfRect(uvrh+vec2(uvApo.z-(uvApo.z*.8),.0),uvApo.z*vec2(.4,.03)),uvApo.z*.01,0.005,1.));\n    \tc = mix(c,pal(.9),fill(sdfRect(uvrm+vec2(uvApo.z-(uvApo.z*.65),.0),uvApo.z*vec2(.5,.002)),0.005,1.));\n    \tc = mix(c,pal(.5+r*10.),fill(circle+uvApo.z-.02,0.005,1.)); // center\n    // drawing the gears\n    } else if (uvApo.z > .05) {\n    \tvec2 uvrg = uvApo.xy*uvRotate(sign(cos(hash(vec2(uvApo.z+2.))*d*180.))*d*iTime*(1./uvApo.z*20.));\n        float g = stroke(mod(atan(uvrg.y,uvrg.x)+d*22.5,d*45.)-d*22.5,.3,.05,1.0);\n        vec2 size = uvApo.z*vec2(.45,.08);\n        c = mix(c,pal(.55-r*.6),fill(circle+g*(uvApo.z*.2)+.01,.001,1.)*fill(circle+(uvApo.z*.6),.005,.0));\n        c = mix(c,pal(.55-r*.6),fill(min(sdfRect(uvrg,size.xy),sdfRect(uvrg,size.yx)),.005,1.));\n    // drawing the screws\n    } else { \n \t    vec2 size = uvApo.z * vec2(.5,.1);\n \t    c = mix(c, pal(.85-(uvApo.z*2.)), fill(circle + 0.01,.007,1.));\n \t    c = mix(c, pal(.8-(uvApo.z*3.)), fill(min(sdfRect(uvApo.xy,size.xy),sdfRect(uvApo.xy,size.yx)), .002, 1.));\n    }\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n\tvec4 ms = (iMouse - iResolution.xyxy * .5 ) / iResolution.y ;\n\tfragColor = vec4(scene(uv*4., ms*4.),1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}