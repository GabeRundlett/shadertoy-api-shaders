{
    "Shader": {
        "info": {
            "date": "1688126749",
            "description": "A (better) cel shading shader applied to a rotating donut rendered using ray marching.",
            "flags": 32,
            "hasliked": 0,
            "id": "csjyDy",
            "likes": 6,
            "name": "(Better) cel-shaded donut",
            "published": 3,
            "tags": [
                "raymarching",
                "celshading",
                "donut",
                "doughnut"
            ],
            "usePreview": 0,
            "username": "Sumsar86",
            "viewed": 223
        },
        "renderpass": [
            {
                "code": "#define ENABLE_CEL_SHADING 1\n#define ENABLE_COLOR 1\n#define ENABLE_OUTLINE 1\n\nconst float N = 6.0;\nconst float INVERSE_N = 1.0 / N;\n\n\nvec3 torusColor = vec3(0.80, 0.45, 0.38);\nvec3 outlineColor = vec3(0.0);\nvec3 backgroundColor = vec3(0.8, 0.8, 0.8);\n\nvec3 lightPos = vec3(2.0, -5.0, 3.0);\nvec3 lightColor = vec3(1.0);\nfloat ambientIntensity = 0.2;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 normal = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    float lightIntensity = texelFetch(iChannel0, ivec2(fragCoord), 0).a;\n    \n    if (lightIntensity == -1.0)\n    {\n        fragColor = vec4(backgroundColor, 0.0);\n    }\n    else\n    {\n        float difference = mod(lightIntensity, INVERSE_N);\n#if ENABLE_CEL_SHADING\n        lightIntensity = lightIntensity - difference + INVERSE_N;\n#endif\n\n        vec3 color = vec3(0.0);\n#if ENABLE_COLOR\n        color = vec3(torusColor * lightColor * lightIntensity);\n#else\n        color = vec3(lightIntensity);\n#endif\n\n        float outlineIntensity = dot(texelFetch(iChannel1, ivec2(fragCoord), 0).rgb, vec3(1.0));\n#if ENABLE_OUTLINE\n        if (outlineIntensity > 0.0)\n            color = outlineColor;\n#endif\n\n        fragColor = vec4(color, 0.0);\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define FLAT_COLORS 0\n\nconst vec3 BACKGROUND_NORMAL = vec3(0.0);\n\nstruct Torus\n{\n    float r;\n    float s;\n};\n\nstruct Light\n{\n    vec3 pos;\n    float ambientIntensity;\n};\n\nTorus t1 = Torus(0.5, 0.25);\nLight l1 = Light(vec3(2.0, -5.0, 3.0), 0.2);\n\n\nmat4 translate(vec3 v) {\n    return mat4(\n        1, 0, 0, -v.x, \n        0, 1, 0, -v.y, \n        0, 0, 1, -v.z, \n        0, 0, 0, 1\n    );\n}\n\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(\n        1, 0, 0, 0,\n        0, c, -s, 0,\n        0, s, c, 0,\n        0, 0, 0, 1\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(\n        c, 0, s, 0, \n        0, 1, 0, 0, \n        -s, 0, c, 0, \n        0, 0, 0, 1\n    );\n}\n\nfloat torusSDF(in vec3 p)\n{\n    float h = length(p.xz);\n    return length(vec2(h-t1.r,p.y))-t1.s;\n}\n\nvec3 calculateNormal(in vec3 pos)\n{\n    const vec3 smallStep = vec3(0.001, 0.0, 0.0);\n\n    float gradientX = torusSDF(pos + smallStep.xyy) - torusSDF(pos - smallStep.xyy);\n    float gradientY = torusSDF(pos + smallStep.yxy) - torusSDF(pos - smallStep.yxy);\n    float gradientZ = torusSDF(pos + smallStep.yyx) - torusSDF(pos - smallStep.yyx);\n\n    vec3 normal = vec3(gradientX, gradientY, gradientZ);\n\n    return normalize(normal);\n}\n\nvec4 rayMarch(in vec3 rayOrigin, in vec3 rayDir) // returns normal map + light intensity\n{\n    float totalDistTraveled = 0.0;\n    const int NUMBER_OF_STEPS = 256;\n    const float MINIMUM_HIT_DIST = 0.001;\n    const float MAXIMUM_TRACE_DIST = 5.0;\n    \n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {        \n        if (totalDistTraveled >= MAXIMUM_TRACE_DIST)\n            break;\n            \n        vec4 currentPos = vec4(rayOrigin + totalDistTraveled * rayDir, 1.0);\n        currentPos *= translate(vec3(0.0, 0.0, 0.0)) * rotateY(iTime) * rotateX(1.0);\n\n        float smallestDist = torusSDF(currentPos.xyz);\n\n        if (smallestDist <= MINIMUM_HIT_DIST)\n        {\n            vec3 normal = calculateNormal(currentPos.xyz);\n            \n            l1.pos = vec3(vec4(l1.pos, 0.0) * rotateY(iTime));\n            vec3 lightDir = normalize(currentPos.xyz - l1.pos);\n            float diffuseIntensity = max(l1.ambientIntensity, dot(normal, lightDir));\n            \n            return vec4(normal, diffuseIntensity);\n        }\n            \n        totalDistTraveled += smallestDist;\n    }\n    \n    return vec4(BACKGROUND_NORMAL, -1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    // convert from (0 to 1) to (-1 to 1)\n    uv = uv * 2.0 - 1.0;\n    // rescale\n    uv.x *= iResolution.x / iResolution.y;\n    \n\n    vec3 rOrigin = vec3(0.0, 0.0, -1.2);\n    vec3 rDir = vec3(uv, 1.0);\n    vec4 normalMap = rayMarch(rOrigin, rDir);\n    \n    // Output to buffer A\n    fragColor = normalMap;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define ENABLE_CEL_SHADING 1\n\nconst float N = 6.0;\nconst float INVERSE_N = 1.0 / N;\n\nconst float sobelX[9] = float[](\n    1.0, 0.0, -1.0, \n    2.0, 0.0, -2.0, \n    1.0, 0.0, -1.0\n);\n\nconst float sobelY[9] = float[](\n    1.0, 2.0, 1.0, \n    0.0, 0.0, 0.0, \n    -1.0, -2.0, -1.0\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float horizontal = 0.0, vertical = 0.0;\n    \n    for (float y = 0.0; y <= 2.0; y++)\n    {\n        for (float x = 0.0; x <= 2.0; x++)\n        {\n            ivec2 newFragCoord = ivec2(fragCoord + vec2(x - 1.0, y - 1.0));\n            float lightIntensity = texelFetch(iChannel0, newFragCoord, 0).a;\n            \n            float difference = mod(lightIntensity, INVERSE_N);\n            float greyScale = lightIntensity;\n#if ENABLE_CEL_SHADING\n            greyScale = lightIntensity - difference + INVERSE_N;\n#endif\n            \n            int index = int(x + 3.0 * y);\n            horizontal += greyScale * sobelX[index];\n            vertical += greyScale * sobelY[index];\n        }\n    }\n    \n    float edge = sqrt(dot(horizontal, horizontal) + dot(vertical, vertical));\n    fragColor = vec4(vec3(edge), 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float STRONG_THRESHOLD = 0.7;\nconst float WEAK_THRESHOLD = 0.2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = floor(fragCoord.x), y = floor(fragCoord.y);\n    float prevIndex = x + iResolution.x * y - 1.0;\n    ivec2 prevFragCoord = ivec2(mod(prevIndex, iResolution.x), floor(prevIndex / iResolution.x));\n    \n    float nextIndex = x + iResolution.x * y + 1.0;\n    ivec2 nextFragCoord = ivec2(mod(nextIndex, iResolution.x), floor(nextIndex / iResolution.x));\n    \n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    float colorIntensity = dot(color, vec3(1.0));\n    float prevColorIntensity = dot(texelFetch(iChannel0, prevFragCoord, 0).rgb, vec3(1.0));\n    float nextColorIntensity = dot(texelFetch(iChannel0, nextFragCoord, 0).rgb, vec3(1.0));\n\n    fragColor = vec4(0.0);\n    if (nextFragCoord.y == int(fragCoord.y) && floor(fragCoord.y) != iResolution.y - 1.0)\n    {\n        if (colorIntensity >= WEAK_THRESHOLD && colorIntensity >= prevColorIntensity && colorIntensity >= nextColorIntensity)\n        {\n            fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, 0.1);\n            if (colorIntensity >= STRONG_THRESHOLD)\n            {\n                fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, 1.0);\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgba;\n    float sum = 0.0;\n    for (float y = -1.0; y <= 1.0; y++)\n    {\n        for (float x = -1.0; x <= 1.0; x++)\n        {\n            if (x != 0.0 && y != 0.0)\n            {\n                ivec2 newFragCoord = ivec2(fragCoord + vec2(x, y));\n                vec4 neighbour = texelFetch(iChannel0, newFragCoord, 0).rgba;\n                sum += neighbour.a;\n            }\n        }\n    }\n    \n    fragColor = vec4(color.rgb, 0.0);\n    if (sum >= 1.0)\n        fragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}