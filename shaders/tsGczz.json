{
    "Shader": {
        "info": {
            "date": "1602105422",
            "description": "simply functional deterministic integer noise",
            "flags": 0,
            "hasliked": 0,
            "id": "tsGczz",
            "likes": 3,
            "name": "Deterministic Integer Noise",
            "published": 3,
            "tags": [
                "noise",
                "random",
                "deterministic"
            ],
            "usePreview": 0,
            "username": "pyBlob",
            "viewed": 429
        },
        "renderpass": [
            {
                "code": "// https://www.shadertoy.com/view/llGSzw\nuint hash1(uint n)\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\n// https://www.shadertoy.com/view/llGSzw\nuint hash1r(uint n)\n{\n    // integer hash copied from Hugo Elias\n\tn = (n >> 13U) ^ n; // shift-right behaves better on repeated application\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nfloat extract(uint n)\n{\n    return float(n & 0x7fffffffU)/float(0x7fffffff);\n}\n\nuint next(uint n)\n{\n    //return hash1(n); // hash != random number sequence, it will converge in less than 30 iterations\n    \n    // https://en.wikipedia.org/wiki/Linear_congruential_generator\n    return n * 134775813U + 1U; // Pascal 32-bit\n}\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    // perturb sequence\n    uint seed = 0u;\n    if (O.y < iResolution.y / 2.)\n    {\n        // bottom: original hash\n        seed = hash1(seed + uint(iFrame));\n        seed = hash1(seed + uint(O.x));\n        seed = hash1(seed + uint(O.y));\n\n        // left: repeated applications\n        if (O.x < iResolution.x/2.)\n            for( int i=0; i<30/*000*/ ; i++ ) seed = hash1(seed); // see the convergence in action\n    }\n    else\n    {\n        // top: hash with right-shift\n        seed = hash1r(seed + uint(iFrame));\n        seed = hash1r(seed + uint(O.x));\n        seed = hash1r(seed + uint(O.y));\n\n        // left: repeated applications\n        if (O.x < iResolution.x/2.)\n            for( int i=0; i<30/*000*/ ; i++ ) seed = hash1r(seed);\n    }\n\n    // extract value\n    float r = extract(seed);\n\n    // advance generator\n    seed = next(seed);\n\n    // more values\n    float g = extract(seed);\n    seed = next(seed);\n    float b = extract(seed);\n    seed = next(seed);\n\n    C = vec4(r, g, b, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}