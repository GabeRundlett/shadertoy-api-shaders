{
    "Shader": {
        "info": {
            "date": "1671706259",
            "description": "Thanks to poisson for the cornell box: www.shadertoy.com/view/mdX3Wn",
            "flags": 0,
            "hasliked": 0,
            "id": "mtsGW8",
            "likes": 15,
            "name": "Not a Ray Marching",
            "published": 3,
            "tags": [
                "ray"
            ],
            "usePreview": 0,
            "username": "Ric3cir121",
            "viewed": 432
        },
        "renderpass": [
            {
                "code": "// not meant to be read\n\n// random functions\n\n#define mit 10\n#define off .005\n#define inf 99999999.\n\n#define rb1 1.1943\n#define rb2 1.5910\n#define rc1 2948.49\n#define rc2 1329.87\n#define rc3 9187.18\n#define rc4 3273.39\n#define rc5 1435.98\n\nfloat randm(float x,float y){\n    return fract(sin(dot(mod(vec2(x,y),vec2(rc2,rc3))+vec2(rc4,-rc5),vec2(rb1,rb2)))*rc1);\n}\nfloat randm(float x,float y,float z,float w,float s){return randm(randm(randm(x,y),z),randm(w,s));}\nfloat read(float x){return fract(x);}\nvec3 hash3(vec2 a,vec3 b){\n    float x = read(randm(a.x,a.y,b.x,b.y,b.z));\n    float y = read(randm(a.y,b.y,b.z,a.x,b.x));\n    float z = read(randm(b.z,b.y,a.x,b.x,a.y));\n    return vec3(x,y,z)-.5;\n}\nvec2 hash2(vec2 a,float b){\n    float x = read(randm(randm(a.x,a.y),b  ));\n    float y = read(randm(randm(b  ,a.x),a.y));\n    return vec2(x,y)-.5;\n}\nfloat hash1f(vec2 a,vec3 b){\n    return read(randm(a.y,a.x,b.z,b.x,b.y));\n}\n\n// rotation\n\nmat2 rotate(float p){return mat2(cos(p),sin(p),-sin(p),cos(p));}\nvec3 rotate(vec3 c,float p){return vec3(c.xz*rotate(p),c.y).xzy;}\n\n// it's not ray marching\n\nfloat plane(vec3 p,vec3 c,float h){\n    return (c.y*sign(-p.y+h)>0.)?(sqrt(pow(length(c.xz),2.)+pow(c.y,2.))/c.y*(-p.y+h)):inf;\n}\nfloat cutplane(vec3 p,vec3 c,float h,vec2 a,vec2 b,float r,inout vec3 nor){\n    float dis = sqrt(dot(c.xz,c.xz)+c.y*c.y)/c.y*(-p.y+h);\n    vec2 d = dis*c.xz;\n    if(d.x<a.x-p.x||d.x>b.x-p.x||d.y<a.y-p.z||d.y>b.y-p.z)return inf;\n    float res = c.y*sign(-p.y+h)>0.?dis:inf;\n    if(res<r)nor = vec3(0,p.y>h?1.:-1.,0);\n    return res;\n}\n\nfloat cube(vec3 p,vec3 c,vec3 a,vec3 b,float r,inout vec3 nor){\n    vec3 siz = abs(a-b)/2.;\n    vec3 d = (a+b)/2.;\n    return min(min(min(inf,cutplane(p    ,c    ,-sign(c.y)*siz.y+d.y,a.xz,b.xz,r,nor)),\n                           cutplane(p.yzx,c.yzx,-sign(c.z)*siz.z+d.z,a.yx,b.yx,r,nor.yzx)),\n                           cutplane(p.zxy,c.zxy,-sign(c.x)*siz.x+d.x,a.zy,b.zy,r,nor.zxy));\n}\n\nfloat sphere(vec3 p,vec3 c,vec3 a,float s,float r,inout vec3 nor){\n    float mx = dot(a-p,c);\n    float d = length((a-p)-c*mx);\n    if(d<s){\n        if(length(normalize(p-a)-c)<1.414213562373)return inf;\n        float res = length(c*mx)-sqrt(1.-(d/s)*(d/s))*s*(length(p-a)-s<0.?-1.:1.);\n        if(res<r)nor = normalize((p+res*c)-a);\n        return res;\n    }\n    return inf;\n}\n\n// distance function, given position and camera returns the distance to a point in space where there's an object\n\nfloat d(vec3 p,vec3 c,inout vec3 nor){\n    /*\n        The reason for 'nor = normalize(nor*1.00001);'\n        is because it does some magics that fixes a bug\n        on chrome android, some gpus\n    */\n    float r = inf;\n    nor = vec3(0);\n    r = min(r,cutplane(p,c,5.,vec2(-5),vec2(5),r,nor));\n    r = min(r,cutplane(p,c,-5.,vec2(-5),vec2(5),r,nor));\n    r = min(r,cutplane(p.yzx,c.yzx,5.,vec2(-5),vec2(5),r,nor.yzx));\n    r = min(r,cutplane(p.yzx,c.yzx,-5.,vec2(-5),vec2(5),r,nor.yzx));\n    r = min(r,cutplane(p.zxy,c.zxy,5.,vec2(-5),vec2(5),r,nor.zxy));\n    nor = normalize(nor*1.00001);\n    r = min(r,cube(p,c,vec3(-.8,-.8,-1)*5.,vec3(.2,.2,-.98)*5.,r,nor));\n    nor = normalize(nor*1.00001);\n    r = min(r,sphere(p,c,vec3(0,-.6,-.4)*5.,.4*5.,r,nor));\n    nor = normalize(nor*1.00001);\n    r = min(r,sphere(p,c,vec3(0,-.7, .5)*5.,.3*5.,r,nor));\n    nor = normalize(nor*1.00001);\n    r = min(r,sphere(p,c,vec3(.5,-.7,-.4)*5.,.3*5.,r,nor));\n    return r;\n}\n\n// sky box, object color and material\n\nvec3 sky(vec3 pos){\n    return vec3(0);\n    // you might want to use a skybox\n    //return vec3(50000.*clamp(1.-10.*length(pos-normalize(vec3(-.7,1,-.7))),0.,1.));\n}\n\nvec3 getcolor(vec3 pos){\n    vec3 col = vec3(0);\n    col = vec3(.99);\n    if(pos.z+off>5.)col = vec3(.99,.05,.05);\n    if(pos.z-off<-5.)col = vec3(.05,.05,.99);\n    if(length(pos-vec3(.5,-.7,-.4)*5.)<=.3*5.+off)col = vec3(10,5,3);\n    float r = .628;\n    vec2 rp = pos.xz*mat2(cos(r),sin(r),-sin(r),cos(r))*.6;\n    if(max(abs(pos.x),abs(pos.z))<4.5){\n        if(max(abs(pos.y-4.9)*5.,max(abs(rp.y),abs(rp.x)))<1.)col = vec3(10,5,3);\n        if(max(abs(pos.y-4.9)*5.,max(abs(rp.y+2.8),abs(rp.x-.45)))<1.)col = vec3(5,3,10);\n        if(max(abs(pos.y-4.9)*5.,max(abs(rp.y-2.8),abs(rp.x+.45)))<1.)col = vec3(10,3,5);\n        if(max(abs(pos.y-4.9)*5.,max(abs(rp.y+.45),abs(rp.x+2.8)))<1.)col = vec3(5,10,3);\n        if(max(abs(pos.y-4.9)*5.,max(abs(rp.y-.45),abs(rp.x-2.8)))<1.)col = vec3(3,5,10);\n    }\n    return col;\n}\n\nint getmaterial(vec3 pos){\n    int mat = 1;\n    if(length(pos-vec3(0,-.6,-.4)*5.)<=.4*5.+off)mat = 0;\n    if(length(pos-vec3(0,-.7, .5)*5.)<=.3*5.+off)mat = 2;\n    if(length(pos-vec3(.5,-.7,-.4)*5.)<=.3*5.+off)mat = 1;\n    if(all(lessThan(abs(pos+vec3(1.5,1.5,.99*5.))/(vec3(2.5,2.5,.05)+off),vec3(1))))mat = 0;\n    return mat;\n}\n\n// render function\n\nvec4 render(vec2 u){\n    vec4 o = vec4(0);\n    vec2 uv = (u*2.-iResolution.xy)/iResolution.yy/2.;\n    vec2 mouse = iMouse.xy;\n    if(floor(iMouse.xy)==vec2(0))mouse = iResolution.xy/2.;\n    vec2 dir = vec2(mouse/iResolution.xy*3.1415*vec2(2,-1));\n    vec3 cam = rotate(rotate(normalize(vec3(uv,1)).zxy,-dir.y).zxy,-dir.x);\n    vec3 pos = -rotate(rotate(normalize(vec3(0,0,1)).zxy,-dir.y).zxy,-dir.x)*15.;\n    vec3 beg = pos;\n    int i;\n    vec3 col = vec3(1);\n    vec3 end = pos;\n    bool refr = true;\n    bool sca = false;\n    int frame = iFrame;\n    for(i=0;i<mit;i++){\n        pos += cam*off;\n        vec3 nor;\n        pos += d(pos,cam,nor)*cam-cam*off;\n        if(i==0)end=pos;\n        if(length(pos)>20.)break;\n        vec3 newcol = getcolor(pos);\n        col *= newcol;\n        if(dot(newcol,vec3(1))>=3.)break;\n        int mat = getmaterial(pos);\n        if(mat==2)if(hash1f(u,vec3(-1,frame,i))>.75)mat=0;\n        if(mat==1){\n            if(!sca){\n                sca = true;\n                const int ks = 16;\n                vec2 bucket = vec2(0);\n                vec3 bv = vec3(0);\n                for(int k=0;k<ks;k++){\n                    vec3 scam = normalize(hash3(u,vec3(k,frame,i)));\n                    if(length(scam-nor)>1.414213562373)scam *= -1.;\n\n                    int l = 0;\n                    vec3 spos = pos+scam*off;\n                    vec3 snor;\n                    spos += d(spos,scam,snor)*scam;\n                    float light = dot(getcolor(spos),vec3(1))/3.;\n                    if(length(spos)>20.)light = dot(sky(normalize(spos)),vec3(1))/3.;\n                    float weight = light;\n                    weight += .3;\n                    float noise = hash1f(u,vec3(k,frame,i));\n                    if(noise<weight/(weight+bucket.y)||k==0){\n                        bv = scam;\n                        bucket.x = weight;\n                    }\n                    bucket.y += weight;\n                }\n                col *= vec3(bucket.y/float(ks))/bucket.x;\n                cam = bv;\n            }else{\n                cam = normalize(hash3(u,vec3(0,frame-1,i)));\n            }\n        }\n        if(mat==2){\n            pos+=cam*off*4.;\n            if(refr)cam = normalize(refract(cam,nor,0.));\n            refr = refr^^true;\n        }else\n        if(length(cam-nor)>1.414213562373)cam = normalize(reflect(cam,nor));\n    }\n    vec3 lastcol = getcolor(pos);\n    if(dot(lastcol,vec3(1))<9.&&i!=mit)col*=sky(normalize(pos));\n    if(i==mit)col*=0.;\n    o = vec4(col,length(beg-end));\n    return o;\n}\n\n// main\n\nvoid mainImage(out vec4 o,vec2 u){\n    vec2 uv = (u*2.-iResolution.xy)/iResolution.yy/2.;\n    vec2 mouse = iMouse.xy;\n    if(floor(iMouse.xy)==vec2(0))mouse = iResolution.xy/2.;\n    vec2 dir = vec2(mouse/iResolution.xy*3.1415*vec2(2,-1));\n    if(floor(u/2.)==vec2(0)){o = vec4(dir,0,0);return;}\n    vec3 cam = rotate(rotate(normalize(vec3(uv,1)).zxy,-dir.y).zxy,-dir.x);\n    vec3 pos = -rotate(rotate(normalize(vec3(0,0,1)).zxy,-dir.y).zxy,-dir.x)*15.;\n    \n    vec3 col = render(u).xyz;\n    \n    o = pow(vec4(col/5.,1.),vec4(1./2.2));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}