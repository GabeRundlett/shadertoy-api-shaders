{
    "Shader": {
        "info": {
            "date": "1531101828",
            "description": "A glass sphere, not using raymarching.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdVfDd",
            "likes": 31,
            "name": "Glass sphere refraction",
            "published": 3,
            "tags": [
                "ray",
                "sphere",
                "glass",
                "reflect",
                "refract",
                "cast"
            ],
            "usePreview": 0,
            "username": "0xAA55",
            "viewed": 2361
        },
        "renderpass": [
            {
                "code": "\nfloat PI = 3.1415926535897932384626;\nfloat glass_eta = 1.458;\nvec3 glass_color = vec3(.1);\nfloat glass_impurity = .01;\n\nstruct sphere_t\n{\n    vec3 p;\n\tfloat radius;\n    mat3 r;\n};\n\nmat3 rot_x(float ang)\n{\n    float sang = sin(ang);\n    float cang = cos(ang);\n    return mat3\n    (\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cang,-sang),\n        vec3(0.0, sang, cang)\n    );\n}\n\nmat3 rot_y(float ang)\n{\n    float sang = sin(ang);\n    float cang = cos(ang);\n    return mat3\n    (\n        vec3( cang, 0.0, sang),\n        vec3(  0.0, 1.0, 0.0),\n        vec3(-sang, 0.0, cang)\n    );\n}\n\nmat3 rot_z(float ang)\n{\n    float sang = sin(ang);\n    float cang = cos(ang);\n    return mat3\n    (\n        vec3( cang, sang, 0.0),\n        vec3(-sang, cang, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n}\n\nmat3 rot_axis(vec3 v, float ang)\n{\n    float sang = sin(ang);\n    float cang = cos(ang);\n    return mat3\n    (\n        vec3\n        (\n            (1.0 - cang) * v.x * v.x + cang,\n            (1.0 - cang) * v.x * v.y - sang * v.z,\n            (1.0 - cang) * v.x * v.z + sang * v.y\n        ),\n        vec3\n        (\n            (1.0 - cang) * v.y * v.x + sang * v.z,\n            (1.0 - cang) * v.y * v.y + cang,\n            (1.0 - cang) * v.y * v.z - sang * v.x\n        ),\n        vec3\n        (\n            (1.0 - cang) * v.z * v.x - sang * v.y,\n            (1.0 - cang) * v.z * v.y + sang * v.x,\n            (1.0 - cang) * v.z * v.z + cang\n        )\n    );\n}\n    \nmat3 rot_yaw_pitch_roll(vec3 ypr)\n{\n    return rot_z(ypr.z) * rot_x(ypr.y) * rot_y(ypr.x);\n}\n\nbool sphere_raycast(sphere_t sphere, vec3 orig, vec3 dir, out vec3 castpoint, out vec3 normal, out vec2 uv, out float intersect_dist, inout bool isfrominside)\n{\n\tvec3 o = orig;\n\tvec3 d = dir;\n\tvec3 c = sphere.p;\n\tfloat r = sphere.radius;\n    float rsq = r * r;\n    mat3 rot_mat = sphere.r;\n\t\n\tbool isinside = false;\n\n    vec3 o2c = c - o;\n    float distsq = dot(o2c, o2c);\n    float o2cdp = dot(o2c, d);\n    float c2raysq = max(0., distsq - o2cdp * o2cdp);\n    if(c2raysq > rsq) return false;\n    float foo = sqrt(rsq - c2raysq);\n    float dist1 = o2cdp - foo;\n    float dist2 = o2cdp + foo;\n    if(distsq < rsq) isinside = true;\n\tif(isinside && !isfrominside) return false;\n\n    if(isinside || isfrominside) intersect_dist = dist2;\n    else intersect_dist = dist1;\n    \n    if(!isfrominside && intersect_dist < 0.) return false;\n    \n\tcastpoint = o + d * intersect_dist;\n    vec3 nor = (castpoint - c) / r;\n    normal = nor;\n    if(isfrominside) normal = -normal;\n\tisfrominside = isinside;\n\t\n    vec3 uvn = nor * rot_mat;\n\tuv.x = (atan(uvn.z, uvn.x) / PI) * .5 + .5;\n\tuv.y = (atan(uvn.y, length(uvn.xz)) / PI) * .5 + .5;\n    return true;\n}\n\n// Can change this function to render some featured environment\nvec4 sky_sample(vec3 ray)\n{\n    return texture(iChannel0, ray);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    \n    vec2 mouse_rotation = ((iMouse.xy / iResolution.y) * 2. -1.) * PI;\n    if(length(iMouse.xy) < 0.000001) mouse_rotation = vec2(0);\n    \n\tvec2 yawpitch = vec2(mouse_rotation.x, -mouse_rotation.y) + vec2(iTime * .3, sin(iTime * .5) * .25);\n    mat3 viewmat = rot_yaw_pitch_roll(vec3(yawpitch, 0));\n    \n    mat3 rot_m = rot_yaw_pitch_roll(vec3(0));\n    \n    vec3 ray = normalize(vec3(xy, 1)) * viewmat;\n    vec3 eyepos = vec3(0., 0., -5.) * viewmat;\n    \n    sphere_t sph = sphere_t(vec3(0, 0, 0), 1.414, rot_m);\n    \n    vec3 trace_org = eyepos;\n    vec3 trace_ray = ray;\n    \n    vec4 color = vec4(0);\n    \n    vec3 castpnt, castnormal;\n    vec2 castuv;\n    float castdist;\n\tbool isfrominside;\n    \n\t// Surface reflect color\n\tvec4 surface_color = vec4(0);\n    \n    isfrominside = false;\n    if(sphere_raycast(sph, trace_org, trace_ray, castpnt, castnormal, castuv, castdist, isfrominside))\n\t{\n        color = vec4(0);\n        float inside_distance = 0.;\n\t\t\n\t\tif(!isfrominside)\n\t\t{\n\t\t\ttrace_org = castpnt;\n\t\t\ttrace_ray = refract(trace_ray, castnormal, 1. / glass_eta);\n\t\t\tsurface_color = sky_sample(reflect(ray, castnormal)) * (1. - abs(dot(ray, castnormal)));\n\t\t}\n        \n\t\t// If I use uint type, or use \"for(iter = xx\", it may not compatible for iPhone X\n        for(float iter = 0.0; iter < 16.; iter ++)\n        {\n            bool frominside = true;\n            sphere_raycast(sph, trace_org, trace_ray, castpnt, castnormal, castuv, castdist, frominside);\n            \n            inside_distance += castdist;\n            \n            float k;\n            float eta = glass_eta;\n            float dot_ni = dot(castnormal, trace_ray);\n            \n            k = 1. - eta * eta * (1. - dot_ni * dot_ni);\n            if(k >= 0.)\n            {\n                trace_org = castpnt;\n        \t\ttrace_ray = eta * trace_ray - (eta * dot_ni + sqrt(k)) * castnormal;\n                color = mix(sky_sample(trace_ray) * dot(-trace_ray, castnormal),\n                            vec4(glass_color, 1.),\n                            clamp(glass_impurity * inside_distance, 0., 1.));\n                break;\n            }\n            \n\t\t\t// Total reflect\n            trace_ray = reflect(trace_ray, castnormal);\n            trace_org = castpnt;\n        }\n\t\tcolor += surface_color;\n\t}\n    else\n    {\n        color = sky_sample(trace_ray);\n    }\n    \n\tfragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}