{
    "Shader": {
        "info": {
            "date": "1665654955",
            "description": "Find the normals to a sine curve y = sin(x) from a point (a,b) by finding the zeros of a related function g(a,b,x). The zeros are always in the highlighted area and we find them with a simple bisection process.\n\nMouse sets point (a,b).",
            "flags": 0,
            "hasliked": 0,
            "id": "css3R8",
            "likes": 11,
            "name": "Normals to Sine Curve",
            "published": 3,
            "tags": [
                "sine",
                "curve",
                "normal"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 266
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Normals to Sine Curve, mla, 2022\n//\n// Find the normals from a point (a,b) to the curve y = sin(x) by finding\n// the zeros of a related function.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat scale = 6.0;\nfloat lwidth = 0.02;  // Line width\nfloat pwidth = 0.1;  // Point width\nfloat eps = 1.0/32.0; // For numerical derivative\nfloat N = 8.0;        // 2N bisection intervals\n\n// Zeros of g are the x coordinates of feet of normals from (a,b) to y = sin(x)\nfloat g(float a, float b, float x) {\n  return x - a + sin(x)*cos(x) - b*cos(x);\n}\n\nfloat h(float a, float b, float x) {\n  return 0.5*distance(vec2(a,b),vec2(x,sin(x)));\n}\n\n// Plots a function of x based on three consecutive values.\n// This is basically (y-f(x))/|(f'(x),1)|, using an approximate derivative.\nfloat graphdist(float y,float eps, float f0, float f1, float f2){\n  return abs(y-f1)/length(vec2((f2-f0)/(2.0*eps),1.0));\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  //h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nvec2 map(vec2 coords) {\n  vec2 uv = (2.0*coords - iResolution.xy)/iResolution.y;\n  uv.y += 0.5;\n  uv *= scale;\n  return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = map(fragCoord);\n  float t = 0.4*iTime;\n  vec2 mouse = vec2(6.5*sin(t),4.5*cos(t)+2.0);\n  if (iMouse.z > 0.0) mouse = map(iMouse.xy);\n  float x = uv.x, y = uv.y;\n  float px = fwidth(x);\n  float a = mouse.x, b = mouse.y;\n\n  vec3 col = vec3(0.5);\n  // Now find roots of g(a,b) - simple bisection method\n  float pdist = 1e8, ldist = 1e8, ldist2 = 1e8; // minimum distances\n  // g(a,b,x) can only have a zero in range aÂ±(abs(b)+0.5)\n  float span = abs(b)+0.5;\n  float x0 = a-span;\n  float y0 = g(a,b,x0);\n  // Find roots - split feasible range into 2N intervals\n  // and look for a bracketed root in each interval.\n  // We might miss close pairs of roots - maybe better\n  // to find roots of derivative.\n  for (float i = -N; i < N; i++) {\n    float x1 = a+span/N*(i+1.0);\n    float y1 = g(a,b,x1);\n    if (y0*y1 <= 0.0) {\n      // Bracketed, so now bisect\n      for (int j = 0; j < 6; j++) {\n        float x2 = 0.5*(x0+x1);\n        float y2 = g(a,b,x2);\n        if (y0*y2 <= 0.0) { x1 = x2; y1 = y2; }\n        else { x0 = x2; y0 = y2; }\n      }\n      vec2 zero = vec2(x0,0);\n      vec2 foot = vec2(x0,sin(x0));\n      pdist = min(pdist,distance(uv,zero));\n      pdist = min(pdist,distance(uv,foot));\n      pdist = min(pdist,distance(uv,vec2(x0,h(a,b,x0))));\n      ldist2 = min(ldist2,line(uv,zero,foot));\n      ldist = min(ldist,segment(uv,mouse,foot));\n    }\n    x0 = x1; y0 = y1;\n  }\n  col = mix(vec3(0.6),col,smoothstep(0.0,px,abs(ldist2)-0.5*lwidth));\n\n  col = mix(vec3(0.1),col,smoothstep(0.0,px,abs(y)-0.75*lwidth)); // Axes\n  float d = graphdist(y,eps,g(a,b,x-eps),g(a,b,x),g(a,b,x+eps));\n  col = mix(vec3(1,1,0),col,smoothstep(0.0,px,d-lwidth)); // normal curve\n  d = graphdist(y,eps,h(a,b,x-eps),h(a,b,x),h(a,b,x+eps));\n  col = mix(vec3(0,0,1),col,smoothstep(0.0,px,d-lwidth)); // distance curve\n  {\n#define F(x) (sin(x))\n    float y0 = F(a);\n    float y1 = F(a-eps);\n    float y2 = F(a+eps);\n    y1 -= y0; y2 -= y0; // Rebase\n    float A = 0.5*(y2+y1)/(eps*eps);\n    float B = 0.5*(y2-y1)/eps;\n    float x0 = x-a-eps;\n    float x1 = x-a;\n    float x2 = x-a+eps;\n    float f0 = A*x0*x0+B*x0;\n    float f1 = A*x1*x1+B*x1;\n    float f2 = A*x2*x2+B*x2;\n    float d = graphdist(y-y0,eps,f0,f1,f2);\n    col = mix(vec3(0),col,smoothstep(0.0,px,d-0.66*lwidth));\n#undef F\n  }\n  d = graphdist(y,eps,sin(x-eps),sin(x),sin(x+eps));\n  col = mix(vec3(1,0,0),col,smoothstep(0.0,px,d-lwidth)); // sine\n\n  col = mix(vec3(0.25),col,smoothstep(0.0,px,abs(ldist)-0.5*lwidth));\n  //col = mix(vec3(0.4),col,smoothstep(0.0,px,abs(ldist2)-0.5*lwidth));\n  col = mix(vec3(0.0),col,smoothstep(0.0,px,abs(pdist)-pwidth));\n  vec2 xseg0 = vec2(0.2,0);\n  vec2 xseg1 = xseg0.yx;\n  d = min(segment(uv,mouse+xseg0,mouse-xseg0),\n          segment(uv,mouse+xseg1,mouse-xseg1));\n  col = mix(vec3(0),col,smoothstep(0.0,px,d-lwidth));\n  if (x < a-span || x > a+span) col *= 0.8; // Highlight feasible region\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}