{
    "Shader": {
        "info": {
            "date": "1726495663",
            "description": ":):)",
            "flags": 0,
            "hasliked": 0,
            "id": "M3lyRH",
            "likes": 16,
            "name": "Mengerverse",
            "published": 3,
            "tags": [
                "menger"
            ],
            "usePreview": 0,
            "username": "ShadeWhizz",
            "viewed": 201
        },
        "renderpass": [
            {
                "code": "const float PI = 3.14159265358979323846264;\nconst int MAX_PRIMARY_RAY_STEPS = 256; //decrease this number if it runs slow on your computer\nconst float L2 = 0.69314718056;\nfloat iters = 0.0;\nfloat last_distance = 0.0;\n\n// cream and dark red tho\n\nvec2 rot(vec2 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c)*X;\n}\n\nfloat hash2D(vec2 uv)\n{\n \tvec2 suv = sin(uv);\n    suv = rot(suv, uv.x);\n    return fract(mix(suv.x*13.13032942, suv.y*12.01293203924, dot(uv, suv)));\n}\n\nfloat repeat(float x, float t) {\n    return mod(x, t) - t/2.; \n}\nfloat repeat_even(float x, float t) {\n    return t*(fract(x/2. + 0.5) - 0.5); \n}\nvec2 kaleidoscope(vec2 p, float r) {\n    // cart2pol\n    //repeat x\n    // pol2cart\n    return vec2(0.0);\n}\n\n\nfloat maxcomp(vec2 a) {\n    return max(a.x, a.y);\n}\n\nmat2 rotmat(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n\n    return mat2(\n        cosAngle, -sinAngle,\n        sinAngle,  cosAngle\n    );\n}\n\nvec3 my_stereo_inv(vec2 p)\n{\n    float den = dot(p,p)+1.0;\n    return vec3(\n        2.0*p.x / den,\n        2.0*p.y / den,\n        (den-2.0)/den\n    );\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat sdCross( in vec3 p )\n{\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.zx));\n  return min(da,min(db,dc))-1.0;\n}\n\nfloat distanceField(vec3 p) {\n    //p = mod(p, 3.0) - 1.5;\n    //p.xy *= rotmat(iTime);\n   p.xy = rot(p.xy, p.z);\n   p.z = repeat_even(p.z, 1.5);\n   p.x = repeat_even(p.x, 1.5);\n   p.y = repeat_even(p.y, 1.5);\n   \n   float d = sdBox(p,vec3(1.0));\n\n   float s = 1.0;\n   for( int m=0; m<4; m++ )\n   {\n      vec3 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = 1.0 - 3.0*abs(a);\n\n      float c = sdCross(r)/s;\n      d = max(d,c);\n   }\n\n   return d;\n}\nfloat dfc(vec3 p) {\n    return max(distanceField(p), 0.);\n}\n\nfloat get_ao(vec3 p, vec3 n) {\n    float thing = -dfc(p+0.05*n)\n        -dfc(p+0.05*n)*3.0 \n        -dfc(p+0.1*n)*4.0\n        -dfc(p+0.15*n)*3.0\n        -dfc(p+0.2*n)*2.0\n        -dfc(p+0.25*n)*1.0\n        -dfc(p+0.4*n)*1.0\n        -dfc(p+0.8*n)*2.0\n        ;\n    return 1.0 - exp(thing / 2.0);\n}\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(0.00001, 0.0);\n    float rd = distanceField(p);\n    return normalize(vec3(\n        rd - distanceField(p - e.xyy),\n        rd - distanceField(p - e.yxy),\n        rd - distanceField(p - e.yyx)\n    ));\n}\n\nvec3 calcNormala(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        distanceField(p + e.xyy) - distanceField(p - e.xyy),\n        distanceField(p + e.yxy) - distanceField(p - e.yxy),\n        distanceField(p + e.yyx) - distanceField(p - e.yyx)\n    ));\n}\n\n\nvec3 castRay(vec3 pos, vec3 dir, float threshold) {\n\tfor (int i = 0; i < MAX_PRIMARY_RAY_STEPS; i++) {\n\t\t\tfloat dist = distanceField(pos);\n\t\t\tif (abs(dist) < threshold) break;\n            last_distance = dist;\n\t\t\tpos += dist * dir * 1.0;\n            iters = float(i);\n\t}\n\treturn pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 wh = vec2(320.0, 180.0)/2.;\n    //uv = floor(uv*wh)/wh;\n    float angle = iTime * 0.25;\n    float radius = 0.0;\n    vec4 v = vec4(cos(iTime), 0.0, sin(iTime), 1.0);\n    vec3 ro = radius*v.yyy;\n    ro -= vec3(0.0, 0.0, 0.25*iTime);\n    uv = uv * rotmat(-iTime * 0.2);\n    vec3 rd = normalize(my_stereo_inv(uv));\n\tvec3 rayPos = castRay(ro, rd, 0.0001);\n    //float ao = 1.0 - (iters / 64.0);\n    float itersf = iters; // would love to know how to use last distance to smooth this out\n    //exp(-0.02725*(itersf));\n    //float ao = 1.0 - (itersf/40.0);\n    //ao = 1.0;\n    // yea the ao is cooked oh i should dither it\n    // should dither iters\n    vec3 normal = calcNormal(rayPos);\n    float ao = get_ao(rayPos, normal);\n    vec3 sun_dir = normalize(vec3(0.1, 0.8, 0.6));\n    float d = (max(dot(sun_dir, normal), 0.0)+0.5)/1.5;\n    //d *= ao;\n    //d = pow(d, 0.99);\n    d *= ao;\n    vec3 col = mix(vec3(0.3, 0.0, 0.0), vec3(0.7, 0.6, 0.5), d*3.0);\n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}