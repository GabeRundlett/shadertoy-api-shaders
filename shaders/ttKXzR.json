{
    "Shader": {
        "info": {
            "date": "1582105336",
            "description": "Uniform area sampling vs Visible area with importance sampling",
            "flags": 0,
            "hasliked": 0,
            "id": "ttKXzR",
            "likes": 12,
            "name": "Sampling cylindrical light",
            "published": 3,
            "tags": [
                "illumination",
                "light",
                "sampling",
                "cylinder"
            ],
            "usePreview": 0,
            "username": "koiava",
            "viewed": 589
        },
        "renderpass": [
            {
                "code": "#define PIXEL_SAMPLES \t\t1\t\t\t//Increase for higher quality\n#define LIGHT_SAMPLES\t\t1\t\t\t//Increase for higher quality\n\n#define GAMMA \t\t\t\t2.2\t\t\t//\n#define SHADOWS\n#define LIGHT_CLIPPING\n#define STRATIFIED_SAMPLING\nconst vec3 backgroundColor = vec3( 0.0 );\n\n#define SAMPLE_TOTAL_AREA\t\t0\n#define SAMPLE_VISIBLE_AREA_IS\t1\n#define SAMPLE_NONE\t\t\t\t2\nint samplingTechnique;\n\n//used macros and constants\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.0001 \n#define EQUAL_FLT(a,b,eps)\t(((a)>((b)-(eps))) && ((a)<((b)+(eps))))\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n//********************************************\n\n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n//////////////////////////////////////////////////////////////////////////\n// Converting PDF from Solid angle to Area\nfloat PdfWtoA( float aPdfW, float aDist2, float aCosThere ){\n    if( aDist2 < EPSILON )\n        return 0.0;\n    return aPdfW * abs(aCosThere) / aDist2;\n}\n\n// Converting PDF between from Area to Solid angle\nfloat PdfAtoW( float aPdfA, float aDist2, float aCosThere ){\n    float absCosTheta = abs(aCosThere);\n    if( absCosTheta < EPSILON )\n        return 0.0;\n    \n    return aPdfA * aDist2 / absCosTheta;\n}\n//////////////////////////////////////////////////////////////////////////\n\nvec3 toVec3( vec4 v ) {\n    if( IS_ZERO( v.w ) ) {\n        return v.xyz;\n    }\n    \n    return v.xyz*(1.0/v.w);\n}\n\nvec3 sphericalToCartesian(\tin float rho,\n                          \tin float phi,\n                          \tin float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvoid cartesianToSpherical( \tin vec3 xyz,\n                         \tout float rho,\n                          \tout float phi,\n                          \tout float theta ) {\n    rho = sqrt((xyz.x * xyz.x) + (xyz.y * xyz.y) + (xyz.z * xyz.z));\n    phi = asin(xyz.y / rho);\n\ttheta = atan( xyz.z, xyz.x );\n}\n\nmat3 mat3Inverse( in mat3 m ) {\n    return mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n\t\t\t\t\tvec3( m[0][1], m[1][1], m[2][1] ),\n                    vec3( m[0][2], m[1][2], m[2][2] ) );\n}\n\n//fast inverse for orthogonal matrices\nmat4 mat4Inverse( in mat4 m ) {\n    mat3 rotate_inv = mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n                          \tvec3( m[0][1], m[1][1], m[2][1] ),\n                          \tvec3( m[0][2], m[1][2], m[2][2] ) );\n    \n    return mat4(\tvec4( rotate_inv[0], 0.0 ),\n                \tvec4( rotate_inv[1], 0.0 ),\n                \tvec4( rotate_inv[2], 0.0 ),\n              \t\tvec4( (-rotate_inv)*m[3].xyz, 1.0 ) );\n}\n    \n\n      \nstruct SurfaceHitInfo {\n    vec3 position_;\n\tvec3 normal_;\n    vec3 tangent_;\n    vec2 uv_;\n    int material_id_;\n};\n\n\n#define MTL_LIGHT \t\t0\n#define MTL_DIFFUSE\t\t1\n    \n\n#define OBJ_PLANE\t\t0\n#define OBJ_SPHERE\t\t1\n#define OBJ_CYLINDER\t2\n#define OBJ_AABB\t\t3\n    \nstruct Object {\n    int type_;\n    int mtl_id_;\n    mat4 transform_;\n    mat4 transform_inv_;\n    \n    float params_[6];\n};\n    \nstruct Ray { vec3 origin; vec3 dir; };\nstruct Camera {\n    mat3 rotate;\n    vec3 pos;\n    float fovV;\n};\n    \n// ************ SCENE ***************\nObject objects[7];\nCamera camera;\n//***********************************\nvoid createAABB( mat4 transform, vec3 bound_min, vec3 bound_max, int mtl, out Object obj) {\n    vec3 xAcis = normalize( vec3( 0.9, 0.0, 0.2 ) );\n    vec3 yAcis = vec3( 0.0, 1.0, 0.0 );\n    obj.type_ = OBJ_AABB;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = bound_min.x;\n    obj.params_[1] = bound_min.y;\n    obj.params_[2] = bound_min.z;\n    obj.params_[3] = bound_max.x;\n    obj.params_[4] = bound_max.y;\n    obj.params_[5] = bound_max.z;\n}\n\nvoid createPlane(mat4 transform, float minX, float minY, float maxX, float maxY, int mtl, out Object obj) {\n    obj.type_ = OBJ_PLANE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = minX;\t\t\t//radius\n    obj.params_[1] = minY;\t\t\t//min z\n    obj.params_[2] = maxX;\t\t\t//max z\n    obj.params_[3] = maxY;\t\t\t//max phi\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createSphere(mat4 transform, float r, int mtl, out Object obj) {\n    obj.type_ = OBJ_SPHERE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = r*r;\t\t//radius^2\n    obj.params_[2] = 0.0;\t\t//not used\n    obj.params_[3] = 0.0;\t\t//not used\n    obj.params_[4] = 0.0;\t\t//not used \n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createCylinder(mat4 transform, float r, float minZ, float maxZ, float maxTheta, int mtl, out Object obj) {\n    obj.type_ = OBJ_CYLINDER;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = minZ;\t\t//min z\n    obj.params_[2] = maxZ;\t\t//max z\n    obj.params_[3] = maxTheta;\t//max phi\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nmat4 createCS(vec3 p, vec3 z, vec3 x) {\n    z = normalize(z);\n    vec3 y = normalize(cross(z,x));\n    x = cross(y,z);\n    \n    return mat4(\tvec4( x, 0.0 ), \n    \t\t\t \tvec4( y, 0.0 ),\n    \t\t\t\tvec4( z, 0.0 ),\n    \t\t\t\tvec4( p, 1.0 ));\n}\n\nvoid initScene() {\n    float time = iTime;\n    \n    //init lights\n    float r = 0.1;\n    \n    vec3 z = sphericalToCartesian(1.0,sin(iTime),cos(iTime));\n    vec3 x = z.x<0.8?vec3(1.0,0.0,0.0):vec3(0.0,0.0,1.0);\n    vec3 y = normalize(cross(z,x));\n    x = cross(y,z);\n    mat4 trans = mat4( \tvec4( x, 0.0 ), \n    \t\t\t\t\tvec4( y, 0.0 ),\n    \t\t\t\t\tvec4( z, 0.0 ),\n    \t\t\t\t\tvec4( 0.0, 4.0, -3.0, 1.0 ));\n    createCylinder(trans, 0.1, 0.0, 7.0, TWO_PI, MTL_LIGHT, objects[0]);\n    \n    \n    //plane 1\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 0.0, 5.0, -10.0, 1.0 ));\n    createPlane(trans, -10.0, -2.0, 10.0, 4.0, MTL_DIFFUSE, objects[1]);\n   \n    //plane 2\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, -1.0, 0.0 ),\n                    vec4( 0.0, -1.0, 0.0, 0.0 ),\n                    vec4( 0.0, -1.0, -4.0, 1.0 ));\n    createPlane(trans, -10.0, -4.0, 10.0, 2.0, MTL_DIFFUSE, objects[2]);\n \n    //Cylinder\n    trans = mat4(\tvec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( -0.0, 3.0, -6.0, 1.0 ));\n    createCylinder(trans, 4.0, -10.0, 10.0, PI/2.0, MTL_DIFFUSE, objects[3] );\n    \n    //sphere 1\n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 2.5, 0.0, -2.0, 1.0 ));\n\n    createSphere(trans, 1.0, MTL_DIFFUSE, objects[4] );\n    \n    //sphere 2\n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( -1.0, 0.0, -5.0, 1.0 ));\n\n    createSphere(trans, 1.0, MTL_DIFFUSE, objects[5] );\n    \n    //box\n    trans = createCS(\tvec3(-1.5, -1.0, -3.0),\n                     \tvec3(0.0, 1.0, 0.0),\n                     \tvec3(0.2, 0.0, -0.7));\n    createAABB( trans, -vec3(0.5, 0.5, 0.0), vec3(0.5, 0.5, 2.5), MTL_DIFFUSE, objects[6]);\n}\n\n// ************************  INTERSECTION FUNCTIONS **************************\nbool solveQuadratic(float A, float B, float C, out float t0, out float t1) {\n\tfloat discrim = B*B-4.0*A*C;\n    \n\tif ( discrim <= 0.0 )\n        return false;\n    \n\tfloat rootDiscrim = sqrt( discrim );\n    \n    float t_0 = (-B-rootDiscrim)/(2.0*A);\n    float t_1 = (-B+rootDiscrim)/(2.0*A);\n    \n    t0 = min( t_0, t_1 );\n    t1 = max( t_0, t_1 );\n    \n\treturn true;\n}\n\nbool rayAABBIntersection( in Ray ray, float minX, float minY, float minZ, float maxX, float maxY, float maxZ, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    vec3 boxMin = vec3( minX, minY, minZ );\n    vec3 boxMax = vec3( maxX, maxY, maxZ );\n    \n    vec3 OMIN = ( boxMin - ray.origin ) / ray.dir;\n    vec3 OMAX = ( boxMax - ray.origin ) / ray.dir;\n    vec3 MAX = max ( OMAX, OMIN );\n    vec3 MIN = min ( OMAX, OMIN );\n    float t1 = min ( MAX.x, min ( MAX.y, MAX.z ) );\n    t = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) );\n    \n    if ( t1 <= t )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        \n        if( EQUAL_FLT( isect.position_.x, minX, EPSILON ) ) {\n            isect.normal_ =  vec3( -1.0, 0.0, 0.0 );\n            isect.tangent_ \t\t= vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.x, maxX, EPSILON ) ) {\n            isect.normal_ =  vec3( 1.0, 0.0, 0.0 );\n            isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.y, minY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, -1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.y, maxY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.z, minZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, -1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.z, maxZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, 1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        }\n        \n        isect.uv_ /= 2.0;\n    }\n    \n    return true;\n}\n\n\nbool raySphereIntersection( in Ray ray, in float radiusSquared, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    float t0, t1;\n    vec3 L = ray.origin;\n    float a = dot( ray.dir, ray.dir );\n    float b = 2.0 * dot( ray.dir, L );\n    float c = dot( L, L ) - radiusSquared;\n    \n    if (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n    \n    if( t0 > 0.0 ) {\n    \tt = t0;\n    } else {\n        if ( t1 > 0.0 ) {\n            t = t1;\n        } else {\n            return false;\n        }\n    }\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        isect.normal_ = normalize( isect.position_ );\n\n        float rho, phi, theta;\n        cartesianToSpherical( isect.normal_, rho, phi, theta );\n        isect.uv_.x = phi/PI;\n        isect.uv_.y = theta/TWO_PI;\n\n        isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n        vec3 tmp = cross( isect.normal_, isect.tangent_ );\n        isect.tangent_ = normalize( cross( tmp, isect.normal_ ) );\n    }\n\t\n\treturn true;\n}\n\n\nbool rayAAPlaneIntersection( in Ray ray, in float min_x, in float min_y, in float max_x, in float max_y, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    if ( IS_ZERO( ray.dir.z ) )\n    \treturn false;\n    \n    t = ( -ray.origin.z ) / ray.dir.z;\n    \n    isect.position_ = ray.origin + ray.dir*t;\n    \n    if( (isect.position_.x < min_x) ||\n       \t(isect.position_.x > max_x) ||\n      \t(isect.position_.y < min_y) ||\n      \t(isect.position_.y > max_y) )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.uv_.x \t\t= (isect.position_.x - min_x)/(max_x - min_x);\n        isect.uv_.y \t\t= (isect.position_.y - min_y)/(max_y - min_y);\n        isect.normal_ \t\t= vec3( 0.0, 0.0, 1.0 );\n        isect.tangent_ \t\t= vec3( 1.0, 0.0, 0.0 );\n    }\n    \n    return true;\n}\n\nbool rayCylinderIntersection( in Ray r, in float radius, in float minZ, in float maxZ, in float maxPhi, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n\tfloat phi;\n\tvec3 phit;\n    \n\t// Compute quadratic cylinder coefficients\n\tfloat a = r.dir.x*r.dir.x + r.dir.y*r.dir.y;\n\tfloat b = 2.0 * (r.dir.x*r.origin.x + r.dir.y*r.origin.y);\n\tfloat c = r.origin.x*r.origin.x + r.origin.y*r.origin.y - radius*radius;\n \n\t// Solve quadratic equation for _t_ values\n\tfloat t0, t1;\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n\n    if ( t1 < 0.0 )\n        return false;\n    \n\tt = t0;\n    \n\tif (t0 < 0.0)\n\t\tt = t1;\n\n\t// Compute cylinder hit point and $\\phi$\n\tphit = r.origin + r.dir*t;\n\tphi = atan(phit.y,phit.x);\n    phi += PI;\n    \n\tif (phi < 0.0)\n        phi += TWO_PI;\n \n\t// Test cylinder intersection against clipping parameters\n\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) ) {\n\t\tif (t == t1)\n            return false;\n\t\tt = t1;\n\t\t// Compute cylinder hit point and $\\phi$\n\t\tphit = r.origin + r.dir*t;\n\t\tphi = atan(phit.y,phit.x);\n        phi += PI;\n\n\t\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) )\n\t\t\treturn false;\n\t}\n    \n    if( !forShadowTest ) {\n        isect.position_ = phit;\n        isect.uv_.x = (phit.z - minZ)/(maxZ - minZ);\n        isect.uv_.y = phi/maxPhi;\n        isect.normal_ = normalize( vec3( phit.xy, 0.0 ) );\n        isect.tangent_ = vec3( 0.0, 0.0, 1.0 );\n    }\n    \n\treturn true;\n}\n\nbool rayObjectIntersect( in Ray ray, in Object obj, in float distMin, in float distMax, in bool forShadowTest, out SurfaceHitInfo hit, out float dist ) {\n    bool hitResult = false;\n    float t;\n    SurfaceHitInfo currentHit;\n\n    //Convert ray to object space\n    Ray rayLocal;\n    rayLocal.origin = toVec3( obj.transform_inv_*vec4( ray.origin, 1.0 ) );\n    rayLocal.dir \t= toVec3( obj.transform_inv_*vec4( ray.dir   , 0.0 ) );\n\n    if( obj.type_ == OBJ_PLANE ) {\n        hitResult = rayAAPlaneIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_SPHERE ) {\n        hitResult = raySphereIntersection( \trayLocal, obj.params_[1], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_CYLINDER ) {\n        hitResult = rayCylinderIntersection(rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_AABB ) {\n        float t1;\n        hitResult = rayAABBIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], obj.params_[4], obj.params_[5], forShadowTest, t, currentHit );\n    }\n\n    if( hitResult && ( t > distMin ) && ( t < distMax ) ) {\n        //Convert results to world space\n        currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );\n        currentHit.normal_   = toVec3( obj.transform_*vec4( currentHit.normal_  , 0.0 ) );\n        currentHit.tangent_  = toVec3( obj.transform_*vec4( currentHit.tangent_ , 0.0 ) );\n\n        dist = t;\n        hit = currentHit;\n        hit.material_id_ = obj.mtl_id_;\n\n        if( dot( ray.dir, hit.normal_ ) > 0.0 )\n            hit.normal_ *= -1.0;\n        \n        return true;\n    }\n    \n    return false;\n}\n\n#define CHECK_OBJ( obj ) { SurfaceHitInfo currentHit; float currDist; if( rayObjectIntersect( ray, obj, distMin, nearestDist, forShadowTest, currentHit, currDist ) && ( currDist < nearestDist ) ) { nearestDist = currDist; hit = currentHit; } }\nbool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {\n    nearestDist = 10000.0;\n    for(int i=0; i<7; i++) {\n        CHECK_OBJ(objects[i]);\n    }\n    return ( nearestDist < 1000.0 );\n}\n// ***************************************************************************\n\n \n// Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(Xi1);\n    float theta = Xi2*TWO_PI;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvec3 localToWorld( in vec3 localDir, in vec3 normal )\n{\n    vec3 binormal = normalize( ( abs(normal.x) > abs(normal.z) )?vec3( -normal.y, normal.x, 0.0 ):vec3( 0.0, -normal.z, normal.y ) );\n\tvec3 tangent = cross( binormal, normal );\n    \n\treturn localDir.x*tangent + localDir.y*binormal + localDir.z*normal;\n}\n\nvec3 sampleHemisphereCosWeighted( in vec3 n, in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return localToWorld( sphericalToCartesian( 1.0, phi, theta ), n );\n}\n\nvec3 randomHemisphereDirection( const vec3 n, in float Xi1, in float Xi2 ) {\n    vec2 r = vec2(Xi1,Xi2)*TWO_PI;\n\tvec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n\treturn dot(dr,n) * dr;\n}\n\nvec3 randomDirection( in float Xi1, in float Xi2 ) {\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n\n///////////////////////////////////////////////////////////////////////\nvoid initCamera( \tin vec3 pos,\n                \tin vec3 target,\n                \tin vec3 upDir,\n                \tin float fovV\n               ) {\n\tvec3 back = normalize( pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n    camera.fovV = fovV;\n    camera.pos = pos;\n}\n\nvoid updateCamera( int strata ) {\n    float strataSize = 1.0/float(PIXEL_SAMPLES);\n    float r1 = strataSize*(float(strata)+rnd());\n    //update camera pos\n    float cameraZ = 4.0;\n    vec3 upDir = vec3( 0.0, 1.0, 0.0 );\n    vec3 pos1, pos2;\n    pos1 = vec3( sin(iTime*0.154)*2.0, 2.0 + sin(iTime*0.3)*2.0, cameraZ + sin(iTime*0.8) );\n\n    camera.pos = pos1;\n    \n    vec3 target = vec3( sin(iTime*0.4)*0.3, 1.0, -5.0 );\n    \n\tvec3 back = normalize( camera.pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n}\n\nRay genRay( in vec2 pixel, in float Xi1, in float Xi2 ) {\n    Ray ray;\n\tvec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    ray.origin = camera.pos;\n    ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n\treturn ray;\n}\n\nbool intersectPlane(vec3 plane_n, vec3 plane_p, vec3 ray_o, vec3 ray_d, out float t) { \n    // assuming vectors are all normalized\n    float denom = dot(plane_n, ray_d); \n    if (abs(denom) > 1e-7) { \n        vec3 vec = plane_p - ray_o; \n        t = dot(vec, plane_n) / denom; \n        return (t >= 0.0); \n    } \n \n    return false; \n}\n\nvec2 angular_to_cartesian(float phi) {\n    return vec2(cos(phi), sin(phi));\n}\n\nfloat cartesian_to_angular(vec2 w) {\n\treturn atan(float(-w.y), float(-w.x)) + PI;\n}\n\nvoid sampleLine2(\tvec3 p,\t\t\t\t//shading point position\n                \tvec3 n,\t\t\t\t//normal at shadint point\n                    vec3 line_p0,\t\t//Endpoint of the light segment\n                    vec3 line_dir,\t\t//direction of light segment\n                    float line_len,\t\t//length of the light segment\n                    float Xi,\t\t\t//uniform random number\n                    out float t,\t\t//sampled t parameter on the light segment\n                    out float tPdfL ) {\t//corresponding pdf\n    vec3 p0p = line_p0 - p;\n    float ap = length(p0p);\n\tp0p = normalize(line_p0 - p);\n    line_dir = normalize(line_dir);\t//ensure that line dir is normalized\n    vec3 line_p1 = line_p0 + line_dir * line_len;\n    vec3 p1p = normalize(line_p1 - p);\n    \n    float angle_kap = acos(dot(line_dir, -p0p));\n    \n    vec3 plane_z = normalize(cross(p0p, p1p));\n    //vec3 plane_y = normalize(cross(plane_z,cross(normal, plane_z)));\n    vec3 plane_y = normalize(n - plane_z * dot(n, plane_z));\n    vec3 plane_x = cross(plane_y, plane_z);\n    \n    mat3 trans = mat3(plane_x, plane_y, plane_z);\n    mat3 trans_inv = mat3Inverse( trans );\n    \n    vec3 p0p_local = trans_inv * p0p;\n    vec3 p1p_local = trans_inv * p1p;\n    float thetaA = cartesian_to_angular(p0p_local.xy);\n    float thetaB = cartesian_to_angular(p1p_local.xy);\n    float theta = mix(thetaA, thetaB, Xi);\n    \n    float angle_apk = abs(thetaA - theta);\n    float angle_akp = PI - angle_apk - angle_kap;\n    \n    //sin theorem\n    float ak = abs((ap * sin(angle_apk)) / sin(angle_akp));\n    t = ak;\n    float kp = abs((ap * sin(angle_kap)) / sin(angle_akp));\n    float dist = abs(kp);\n    float cosTheta = cos(0.5*PI - angle_akp);\n    float tPdfW = 1.0 / (abs(thetaB - thetaA));\n    tPdfL = PdfWtoA(tPdfW, dist, cosTheta);\n}\n\n//Equiangular sampling of line segment\n//returns:\n// t - parametter on line\n// tPdf - pdf in length measure\nvoid sampleLine(vec3 pos,\n                vec3 normal,\n                vec3 line_p0,\n                vec3 line_dir,\n                float line_len,\n                float Xi,\n               \tout float t,\n                out float tPdfL ) {\n    \n    \n\tfloat t_fix = 0.0;\n    \n#ifdef LIGHT_CLIPPING\n    // clipping line segment\n    float line_len_max;\n    if(intersectPlane(normal, pos, line_p0, line_dir, line_len_max)) {\n        \n        //line_len = 0.0;//line_len_max;\n        if(line_len > line_len_max) {\n        \n            if(dot(line_dir, normal) > 0.0) {\n                line_p0 += line_dir*line_len_max;\n                line_len -= line_len_max;\n              \tt_fix = line_len_max;\n            } else {\n                line_len = line_len_max;\n            }\n        }\n    }\n#endif\n    \n    // project shading point on line and calculate length\n    float delta = dot(pos - line_p0, line_dir);\n\n    // distance from pos to line\n    float D = length(line_p0 + delta*line_dir - pos);\n\n    // get angle of endpoints\n    float thetaA = atan(0.0 - delta, D);\n    float thetaB = atan(line_len - delta, D);\n    float theta = mix(thetaA, thetaB, Xi);\n\n    // take sample\n    float delta1 = D*tan(theta);\n    float cosTheta = cos(theta);\n    float dist = D/cosTheta;\n    t = (delta1 + delta);\n    t += t_fix;\n    float tPdfW = 1.0 / (thetaB - thetaA);\n    tPdfL = PdfWtoA(tPdfW, dist, cosTheta);\n}\n\nvoid sampleDirectLight( vec3 pos,\n                       \tvec3 normal,\n                        float Xi1,\n                        float Xi2, \n                       \tout vec3 dir,\n                       \tout float pdf ) {\n    float height = objects[0].params_[2] - objects[0].params_[1];\n    float r = objects[0].params_[0];\n    float pdfA;\n    float d2;\n    float aCosThere;\n    float theta;\n    float thetaPdf;\n    float h;\n    float hPdf;\n    \n    //convert position to object space\n    pos = toVec3( objects[0].transform_inv_*vec4(pos, 1.0) );\n    normal = toVec3( objects[0].transform_inv_*vec4(normal, 0.0) );\n    \n    if(samplingTechnique == SAMPLE_TOTAL_AREA){\n        theta = Xi1*TWO_PI;\n        thetaPdf = 1.0/TWO_PI;\n        h = objects[0].params_[1] + Xi2*height;\n        hPdf = 1.0/height;\n        \n        vec3 n = vec3(cos(theta), sin(theta), 0.0);\n        vec3 p = n*r;\n        p.z = h;\n        dir = p - pos;\n        d2 = dot(dir,dir);\n        dir /= sqrt(d2);\n        aCosThere = max(0.0,dot(-dir,n));\n\n        pdfA = thetaPdf*hPdf*(1.0/r);\n        pdf = PdfAtoW( pdfA, d2, aCosThere );\n    } else {\n        vec3 cylinderPos = vec3(0.0, 0.0, objects[0].params_[1]);\n        vec3 cylinderVec = vec3(0.0, 0.0, 1.0);\n        \n        float dc_2 = dot(pos.xy,pos.xy);\n        float dc = sqrt(dc_2);\n        vec2 dirToPos = (-pos.xy)/dc;\n        float alphaMax = acos(r/dc);\n        float thetaMax = 0.5*PI - alphaMax;\n        theta = mix(0.0,thetaMax, Xi1);\n        float sinTheta = sin(theta);\n        float sin2Theta = sinTheta*sinTheta;\n        float cosTheta = sqrt(1.0-sin2Theta);\n        \n    \tfloat ds = dc * cosTheta - sqrt(max(0.0, r*r - dc_2 * sin2Theta));\n    \tfloat cosAlpha = (dc * dc + r*r - ds*ds) / (2.0 * dc * r);\n        \n        float alpha = acos(cosAlpha);\n        \n        //convert alpha to global angle\n        float baseAngle = atan(dirToPos.y,dirToPos.x) + PI;\n        float sign;\n        if(Xi2<0.5) {\n            sign =  1.0;\n            //normalize Xi\n            Xi2 /= 0.5;\n        } else {\n            sign = -1.0;\n            //normalize Xi\n            Xi2 = (Xi2 - 0.5) / 0.5;\n        }\n        \n        float alphaGlobal = baseAngle + alpha*sign;\n       \n        thetaPdf = 1.0/(2.0*thetaMax);// In angle measure\n        thetaPdf = PdfWtoA(thetaPdf, ds, cos(alpha+theta));\n        \n        vec3 n = vec3(cos(alphaGlobal), sin(alphaGlobal), 0.0);\n    \tvec3 p = n*r;\n        \n        //Sampling h\n        //We do equiangular sampling from shading point\n        {\n      \t\tsampleLine( pos, normalize(normal), p, normalize(cylinderVec), height, Xi2, h, hPdf );\n        }\n        \n        p.z = cylinderPos.z + h;\n        dir = p - pos;\n        d2 = dot(dir,dir);\n        dir /= sqrt(d2);\n        aCosThere = max(0.0,dot(-dir,n));\n\n        pdfA = thetaPdf*hPdf;\n        pdf = PdfAtoW( pdfA, d2, aCosThere );\n    }\n    \n    //convert dir to world space\n    dir = toVec3( objects[0].transform_*vec4(dir,0.0) );\n}\n\nbool isLightVisible( Ray shadowRay ) {\n    float distToHit;\n    SurfaceHitInfo tmpHit;\n    \n    raySceneIntersection( shadowRay, EPSILON, true, tmpHit, distToHit );\n    \n    return ( tmpHit.material_id_ == MTL_LIGHT );\n}\n\n\nvec3 Radiance( in Ray ray, float Xi ) {\n    vec3 L = vec3(25.0);\n    vec3 Lo = vec3( 0.0 );\n    \n    vec3 Wo = ray.dir*(-1.0);\n    SurfaceHitInfo hit;\n    float dist = 1000.0;\n\n    if( raySceneIntersection( ray, 0.0, false, hit, dist ) ) {\n        if( hit.material_id_ == MTL_LIGHT ) {\n            Lo = L;\n        } else {\n            for(int i=0; i<LIGHT_SAMPLES; i++){\n                vec3 Wi;\n                float pdfWi;\n                \n            \tfloat Xi1 = rnd();\n            \tfloat Xi2 = rnd();\n#ifdef STRATIFIED_SAMPLING\n                float strataSize = 1.0 / float(LIGHT_SAMPLES);\n                Xi2 = strataSize * (float(i) + Xi2);\n#endif\n                \n                sampleDirectLight( hit.position_, hit.normal_, Xi1, Xi2, Wi, pdfWi );\n                float dotNWi = dot( Wi, hit.normal_ );\n\n                if ( (pdfWi > EPSILON) && (dotNWi > 0.0) ) {\n                    bool visible = true;\n#ifdef SHADOWS\n                    Ray shadowRay = Ray( hit.position_ + hit.normal_*EPSILON, Wi );\n                    if ( !isLightVisible( shadowRay ) ) {\n                        visible = false;\n                    }\n#endif\n                    if(visible) {\n                        float brdf_pdf;\n\n                        vec3 brdf = vec3(1.0/PI);\n\t\t\t\t\t\tvec3 Li = L/pdfWi;\n                        Lo += (brdf*Li*abs(dotNWi));\n                    }\n                }\n            }\n            Lo *= 1.0/float(LIGHT_SAMPLES);\n            \n        }\n    }\n        \n    return Lo;\n}\n\nvoid initSamplingTechnique(float p) {\n    float split = iMouse.x;\n    float k = iMouse.x/iResolution.x;\n    float split1 = iMouse.x*k;\n    float split2 = iMouse.x + (iResolution.x-iMouse.x)*k;\n    \n    if(p < split-1.0) {\n        samplingTechnique = SAMPLE_TOTAL_AREA;\n    } else if(p > split+1.0){\n        samplingTechnique = SAMPLE_VISIBLE_AREA_IS;\n    } else {\n        samplingTechnique = SAMPLE_NONE;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = /*iTime +*/ iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    initSamplingTechnique(fragCoord.x);\n\n    if(samplingTechnique == SAMPLE_NONE) {\n        fragColor = vec4( 1.0 );\n    } else {\n        float fov = radians(45.0);\n        initCamera( vec3( 0.0, 0.0, 0.0 ),\n                    vec3( 0.0, 0.0, 0.0 ),\n                    vec3( 0.0, 1.0, 0.0 ),\n                    fov\n                    );\n\n        initScene();\n\n        vec3 accumulatedColor = vec3( 0.0 );\n        float oneOverSPP = 1.0/float(PIXEL_SAMPLES);\n        float strataSize = oneOverSPP;\n        Ray ray;\n\n        for( int si=0; si<PIXEL_SAMPLES; ++si ){\n            updateCamera( si );\n\n            vec2 screenCoord = fragCoord.xy + vec2( strataSize*( float(si) + rnd() ), rnd() );\n            ray = genRay( screenCoord, rnd(), rnd() );\n\n            if( length( ray.dir ) < 0.2 ) {\n                accumulatedColor = vec3( 0.0 );\n            } else {\n                accumulatedColor += Radiance( ray, strataSize*( float(si) + rnd() ) );\n            }\n        }\n\n        //devide to sample count\n        accumulatedColor = accumulatedColor*oneOverSPP;\n\n        //gamma correction\n        accumulatedColor = pow( accumulatedColor, vec3( 1.0 / GAMMA ) );\n\n\n        fragColor = vec4( accumulatedColor,1.0 );\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}