{
    "Shader": {
        "info": {
            "date": "1642529793",
            "description": "Mouse controls, camera.  \nCyclical variant of https://shadertoy.com/view/sdscRr\n\nreference: https://twitter.com/akira2768922/status/1475077131151769613\nhttps://www.reddit.com/r/desmos/comments/ry7zo8/production_line_manufacturing_boxes_d/",
            "flags": 0,
            "hasliked": 0,
            "id": "ssscWn",
            "likes": 52,
            "name": "box factory 2",
            "published": 3,
            "tags": [
                "origami",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 633
        },
        "renderpass": [
            {
                "code": "// cyclical variant of https://shadertoy.com/view/sdscRr\n\n#define rot(a)          mat2(cos(a+vec4(0,11,33,0)))                       // axial rotation\n#define rot3(P,A,a)   ( mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A) ) // 3D rotation\n//#define D(u)          vec4( smoothstep( 0., .1 ,  .5 - max(u.xxx,u.y) ), 1 ) // tile decoration\n//#define D(u)          texture( iChannel0, u )                            \n  #define D(u)          vec4( smoothstep( 0., .1 ,  .5 - max(u.xxx,u.y) ) *(.5+texture( iChannel0, u ).r), 1. ) * vec4(1,.9,.7,1)\n#define L(p)          ( Z = p, I<2 == D.y<0. ? i : Z.y=-Z.y, I%2>0 == D0.z>0. ? Z.z=-Z.z-3. : i, \\\n                        Z.xz *= rot(-M.x), Z.yz*=rot(-M.y), exp(-.05*(Z.z+6.)) )     // fog\n\nvoid mainImage(out vec4 O, vec2 U)\n{ \n    vec4  C;\n    vec3  R = iResolution, c,A, Z,\n          D = normalize(vec3(U+U-R.xy, 5.*R.y)), D0,      // ray direction\n          p = vec3(0,0,-40), p0, q,                       // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(10,6,0)/1e2*cos(.5*iTime+vec3(0,11,0))+vec3(0,.12,0);\n    M = vec3(0,.5,0) - 6.3*M;  \n    p.yz *= rot(M.y),                                     // camera rotations\n    p.xz *= rot(M.x); \n    D.yz *= rot(M.y),         \n    D.xz *= rot(M.x);\n    p.z += 5.5;\n    float T = mod(iTime,2.), T0,n,i,t,a,s, N=8.;\n    O-=O;\n    p0 = p, D0 = D, T0 = T;\n    \n  for( int I=0; I<4; I++ ) { // ---- 4 copies of the base unfolding pattern with spacetime symmetries \n    p = p0, D = D0, T = T0;  // everything drawn front to back.\n    if ( I<2 == D.y<0. ) p.z += T - 7., p.y -= 2.; \n    else        p.z += -5.-T, T = 2.-T, p.y += 3., D.y=-D.y, p.y=-p.y;    // bottom/up symmetry\n    if ( I%2>0 == D.z>0. )    T = 2.-T,            D.z=-D.z, p.z=-p.z-1.; // front/rear symmetry\n    \n    for ( i=0.; i<=N; i++ ) {                  // --- folded parts ----------------\n        n = D.z > 0. ? N-i : i;                          // parse front to back\n        t = mod(T+n,6.), a = 1.57*fract(t);\n        vec2 CS = .707*sin(a+1.57/2.+vec2(1.57,0));\n        if (T<1.) c = vec3(3.,  0, -2.5), c.xy += CS, A = vec3( 0,0,1); // even roll\n        else      c = vec3(2.5, 0, -3. ), c.zy += CS, A = vec3(-1,0,0); // odd roll\n        c.xz -= floor(t/2.); c.z -= n;\n        if (mod(n,2.)>0.) c.x = -c.x, int(t)%2>0 ? c.x++ : c.z++, A.z = -A.z; // left side\n        if ( (T>1. && n>3. ) || n>5. ) // n<5 : forming cubes. n>=5 : inter-levels cubes\n            c = .5-vec3(0, n>4.?T+n-6.:0., n<6. ? 10-int(t)%2 : 5+int(n) ), // a = 0.;\n            A = vec3(-1,0,0), n!=6.-floor(T) ? a=0.: a;   // inter-cubes don't roll but first\n        if (n==N && T>1.) continue;\n     // if (n+floor(T)==N) c.z += fract(T);               // extreme cube in column\n     // if (n==N && T>0. ) c.z += fract(T), a = 1.57*fract(t); // extreme cube rotate\n        q = p-c; // if (I<2) continue;                    // for debug\n     // if ( dot(q,q) - dot(q,D)*dot(q,D) < 1.  ) {\n            vec3 Pr = rot3(q,A,a), Dr = rot3(D,A,a),      // cube frame  \n                  v = (-.5*sign(Dr) - Pr ) / Dr ,P;       // intersection with cube planes\n     // if ( dot(Pr,Pr) - dot(Pr,Dr)*dot(Pr,Dr) < 1.  ) { // Bbox. why not working ?\n            int j;                                        // draw cube faces corresponding to folds\n            #define inter(i,s) P = abs(Pr + v[i]*Dr);                   \\\n                         j = int[](1,3,2,5,0,4)[ s Dr[i]>0.?3+i:i ];    \\\n                         if( v[i]>0. && max(P.x,max(P.y,P.z)) < .501 )  \\\n                        /**/ if( j <= int(T)+int(n/2.)*2 ) /**/         \\\n                          /**/  { int t = n<6. ? int(T):1; O += D( vec2( P[(i+1+t)%3], P[(i+2-t)%3] ) )*L(c); break;} /**/ \\\n                            //  { O[j%3] =j<3?.5:1.; O.a++; break; }   // attempt of time-consistant colors\n                            //  { O[i] =.5+step(s Dr[i],0.); return; } // debug : draw color cube\n            s = sign(c.x-.5);                             // left side \n            inter(0, s*); inter(1,); inter(2,);           // front cube faces\n            v = ( .5*sign(Dr) - Pr ) / Dr ,P;             // rear cube faces\n            inter(0,-s*); inter(1,-); inter(2,-);\n     // }\n    } //if (n==8.) { O.g=0.; if (T<1.) O.b=0.; }          // for debug\n  //}\n    if ( O.a > 0. && ( D.y < 0. && n+T<6. || D.z>0. && n+T > 6. ) ) return;\n     \n    q = p;                                     // --- unfolded tiling -------------               \n    t = -q.y/D.y; q += t*D;                               // intersection with plane y=0\n    if (t > 0.) C = D( abs( fract(q.zx) -.5) )*L(q-vec3(0,0,T));  // color = tiles decoration + mask\n    c = floor(q); if (3.*abs(c.x)-c.z > 10.+step(c.x,0.) ) C-=C;  // trim cells left by rolling cubes\n    if ( T > 1. &&  abs(c.x)<=2. && c.z == -9.+3.*abs(c.x)-step(c.x,0.) )  C-=C;\n    q.x += mod(ceil(q.z),2.);                             // offset\n    if  ( q.x < -2. || q.x > 4. || q.z < -10. || q.z > 0. ) C-=C; // tiling limits\n    \n    if (C.a > 0.) O = C;\n    if (O.a > 0.) return;\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}