{
    "Shader": {
        "info": {
            "date": "1714677044",
            "description": "Use the mouse to look around :)",
            "flags": 0,
            "hasliked": 0,
            "id": "4cGSzR",
            "likes": 15,
            "name": "Confused Ant",
            "published": 3,
            "tags": [
                "3d",
                "ray",
                "raymarch",
                "rays",
                "marching",
                "ant",
                "ants"
            ],
            "usePreview": 1,
            "username": "ianertson",
            "viewed": 122
        },
        "renderpass": [
            {
                "code": "#define R iResolution.xy\n#define T (iTime)\n#define M_PI 3.14159265358979323846264338327950288\n#define TAU (M_PI*2.0)\n#define FUI floatBitsToUint\n#define ZERO min(0, iFrame)\n#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 86\n#define AMBIENT 0.25\n\n#define rgb(X, Y, Z) vec3(float(X) / 255.0, float(Y) / 255.0, float(Z) / 255.0)\n\n\nmat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, s, -s, c); }\nvec3 aces(vec3 x) { return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.0,1.0); }\nfloat smin(float a, float b, float k) {float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0); return mix(a, b, h) - k*h*(1.0-h); }\nfloat smax(float a, float b, float k) {return smin(a, b, -k); }\nfloat sabs(in float v, in float k) {return smax(-v, v, k);}\nfloat sgt(in float a, in float b, in float s) {float h = clamp(0.5 + 0.5 * (a - b) / s, 0.0, 1.0); return mix(0.0, 1.0, h*h*(3.0-2.0*h));}\nfloat slt(in float a, in float b, in float s) {float h = clamp(0.5 + 0.5 * (b - a) / s, 0.0, 1.0); return mix(0.0, 1.0, h*h*(3.0-2.0*h));}\nfloat ssign(float x, float k) { float s = smoothstep(-k, k, x); return mix(s, sign(x), 0.5*clamp(max(0.0, 1.0-(abs(s)*2.5))*max(0.0, 1.0-k), 0.0, 1.0));}\n\nvec3 pointRot(vec3 p, vec3 r) { p.yz *= rot(r.z); p.xz *= rot(r.y); p.xy *= rot(r.x); return p; }\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nfloat onCycle(float from, float to, float time, float nrSteps, float transTime, float frame) {\n    float cycle = mod(time, nrSteps + transTime);\n    return mix(from, to, smoothstep(frame - transTime, frame + transTime, cycle));\n}\n\nvec3 onCycle(vec3 from, vec3 to, float time, float nrSteps, float transTime, float frame) {\n    float cycle = mod(time, nrSteps + transTime);\n    return mix(from, to, smoothstep(frame - transTime, frame + transTime, cycle));\n}\n\n\nvec3 thash(vec2 p, float seed) {\n    return textureLod(iChannel0, ((p  + seed) / 256.0), 0.0).xyz;\n}\n\nvec3 tnoise(vec2 p, float s) {\n  p += 3.3828714;\n  vec2 id = floor(p); vec2 lv = fract(p);lv = lv*lv*(3.0-2.0*lv);\n  return mix(mix(thash(id+vec2(0,0),s),thash(id+vec2(1,0),s),lv.x),\n             mix(thash(id+vec2(0,1),s),thash(id+vec2(1,1),s),lv.x),lv.y);\n}\n\nvec3 tnoise(vec2 p, float s, float freq, float warp, const in int oct) {\n  vec3 n = vec3(0.0);\n  float div = 0.0;\n  float amp = 1.0;\n  vec2 tx = vec2(0.0);\n  for (int i = ZERO; i < oct; i++) {\n    n += amp*tnoise((p+tx)*freq,s);\n    div += amp;\n    amp *= 0.5;\n    freq *= 2.0;\n    tx += warp * vec2(sin(n.x*6.28), cos(n.y*6.28));\n\n  }\n  return n / div;\n}\n\n\nfloat hash21(vec2 ip, float seed) {\n  uvec2 p = FUI(ip); uint s = FUI(seed); uvec2 k = ~p + ~s;\n  p ^= p << 17U; p ^= p >> 13U; p ^= p << 5U;\n  p += (p ^ k) + p * k; p *= 1013U; p ^= (p >> 4U);\n  return float(p.x * k.y + p.y + p.y * k.x + k.y) / float(0xFFFFFFFFU);\n}\n\nfloat noise(vec2 p, float s) {\n  p += 3.3828714;\n  vec2 id = floor(p); vec2 lv = fract(p);lv = lv*lv*(3.0-2.0*lv);\n  return mix(mix(hash21(id+vec2(0,0),s),hash21(id+vec2(1,0),s),lv.x),\n             mix(hash21(id+vec2(0,1),s),hash21(id+vec2(1,1),s),lv.x),lv.y);\n}\n\nfloat noise(vec2 p, float s, float freq, float dec, float warp, const in int oct) {\n  float n = 0.0;\n  float div = 0.0;\n  float amp = 1.0;\n  vec2 tx = vec2(0.0);\n  for (int i = ZERO; i < oct; i++) {\n    n += amp*noise((p+tx)*freq,s);\n    div += amp;\n    amp *= dec;\n    freq *= exp(dec*1.386294401);\n    tx += warp * vec2(sin(n*6.28), cos(n*6.28));\n\n  }\n  return n / div;\n}\n\nstruct Light {\n  vec3 p;\n  vec3 dir;\n  vec3 color;\n  float strength;\n  int type;\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIRECTIONAL 2\n\nvec3 getLightDir(Light light, vec3 p) {\n  switch (light.type) {\n    case LIGHT_AMBIENT: return normalize(light.p); break;\n    case LIGHT_POINT: return normalize(light.p - p); break;\n    case LIGHT_DIRECTIONAL: return normalize(-light.dir); break;\n    default: return normalize(vec3(1, 2, 3)); break;\n  }\n}\n\nvec3 getLightAtt(Light light, vec3 p, vec3 N) {\n  vec3 L = getLightDir(light, p);\n  float NdotL = max(AMBIENT, dot(N, L));\n  switch (light.type) {\n    case LIGHT_AMBIENT: return NdotL * light.strength * light.color; break;\n    case LIGHT_POINT: return pow(NdotL * light.strength * light.color, vec3(2.0)) / max(0.0000353, pow(distance(light.p, p), 2.0));\n    case LIGHT_DIRECTIONAL: {\n      return light.color * light.strength * NdotL * smoothstep(0.8, 1.0, dot(\n        normalize(light.p - p),\n        L\n      )); break;\n    }\n  }\n\n  return vec3(0.5);\n}\n\nstruct Material {\n  float rough;\n  float spec;\n  float z;\n};\n\n#define NEW_MATERIAL Material(0.0, 0.0, 0.0)\n\nstruct Object {\n  int id;\n  vec3 p;\n  vec3 q;\n  vec3 s;\n};\n\n#define NEW_OBJECT Object(-1, vec3(0.0), vec3(0.0), vec3(0, 0, 0))\n\n\nvec3 translate(vec3 p, Object o) {\n    return (pointRot(p  - o.p, o.q));\n}\n\nstruct Data {\n  vec3 p;\n  vec3 n;\n  float d;\n  Object o;\n  Material m;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, NEW_OBJECT, NEW_MATERIAL)\n\n\n\n\n\nfloat boxSDF(vec3 p, vec3 s) {\n    return length(max(abs(p)-s, 0.0));\n}\n\nfloat lineSDF(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - h * ba)-r;\n}\n\nfloat dirSDF(vec3 p, vec3 dir, float len, float r) {\n    vec3 a = vec3(0.0);\n    vec3 b = a + len * dir;\n    return lineSDF(p, a, b, r);\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\n#define SAMPLE(OBJ, DIST) if (DIST < dist) { dist = DIST; o = OBJ; }\n\n#define ID_GROUND 0\n#define ID_ANT 1\n#define ID_ANT_HEAD 2\n#define ID_ANT_BODY 3\n#define ID_ANT_LEG 4\n#define ID_ANT_BUTT 5\n#define ID_ANT_ANTENNA 6\n#define ID_ANT_EYE 7\n\nfloat groundSDF(vec3 p) {\n    return p.y;\n}\n\n\n/// <ant>\n\nfloat antennaSDF(vec3 p) {\n    vec3 dir1 = normalize(vec3(0.2, 0.5, 0.9));\n    vec3 rootPos = vec3(0.25, 0, 0);\n    float baseLen = 0.8;\n    float base = dirSDF(p - rootPos, dir1, baseLen, 0.05);\n    float tip = dirSDF(p - (rootPos + baseLen * dir1), normalize(vec3(0.6, 0.5, 0.9)), 1.0, 0.025);\n    \n    return smin(base, tip, 0.1) * 0.5;\n}\n\nfloat antHeadSDF(vec3 p, float r, Object oHead, Object oAntenna, Object oEye, inout Object o) {\n    \n    p = translate(p, oHead);\n    float dist = FAR;\n    \n    float back = slt(abs(p.x), 0.1, 0.2) * slt(p.z, -0.2, 0.3);\n    float head = (sphereSDF(p * vec3(1.2, 1.2, 1), r)+0.4*back)*0.7;\n    \n    float antenna = antennaSDF(translate(vec3(abs(p.x), p.y, p.z), oAntenna));\n    \n    float mouthShape = mix(0.05, 0.12, sgt(p.z, r*1.4, 0.1));\n    \n    float mouth = lineSDF(p, vec3(0, 0, r), vec3(0, 0, r*1.4), mouthShape);\n    \n    float eye = sphereSDF(vec3(abs(p.x), p.y, p.z) - vec3(r*0.5, 0, r*0.9), 0.1);\n    \n    head = min(head, mouth);\n    \n    SAMPLE(oHead, head);\n    SAMPLE(oAntenna, antenna);\n    SAMPLE(oEye, eye);\n    \n    return dist;\n}\n\nfloat antBodySDF(vec3 p, float len, Object o) {\n    p = translate(p, o);\n    \n    float r = mix(0.5, 0.2, slt(p.z, 0.3, 0.3));\n    \n    return sphereSDF(p * vec3(1, 1, 1.0/len), r);\n}\n\nfloat antLegFrontSDF(vec3 p, float len, Object o) {\n    p = translate(p, o);\n   \n    \n    vec3 endBase = vec3(len*0.45, len*0.25, 1.0);\n    float base = lineSDF(p, vec3(0, 0, 0), endBase, 0.1);\n    float tip = lineSDF(p, endBase, endBase+vec3(0, -len*0.5, len*0.5), 0.075);\n    \n    return smin(base, tip, 0.1);\n    \n    //dirSDF(p, normalize(dir), len, 0.1);\n}\n\nfloat antLegBackSDF(vec3 p, float len, Object o) {\n    p = translate(p, o);\n   \n    \n    vec3 endBase = vec3(len, len*0.25, -len*0.5);\n    float base = lineSDF(p, vec3(0, 0, 0), endBase, 0.1);\n    float tip = lineSDF(p, endBase, endBase+vec3(0, -len*0.56, -len*0.5), 0.076);\n    \n    return smin(base, tip, 0.1);\n    \n    //dirSDF(p, normalize(dir), len, 0.1);\n}\n\nfloat antLegMiddleSDF(vec3 p, float len, Object o) {\n    p = translate(p, o);\n   \n    \n    vec3 endBase = vec3(len*0.45, len*0.25, 0.0);\n    float base = lineSDF(p, vec3(0, 0, 0), endBase, 0.1);\n    float tip = lineSDF(p, endBase, endBase+vec3(len*0.25, -len*0.5, 0), 0.075);\n    \n    return smin(base, tip, 0.1);\n    \n    //dirSDF(p, normalize(dir), len, 0.1);\n}\n\nfloat antButtSDF(vec3 p, float r, Object o) {\n    p = translate(p, o);\n    float bulge = sgt(p.y, 0.0, 0.2) * slt(abs(p.x), r*0.5, 0.2) * sgt(p.z, r*0.1, 0.4);\n    r = mix(r, r*1.3, bulge);\n    r = mix(r, r*0.9, max(0.0, 1.0-(bulge*bulge)));\n    return sphereSDF(p * vec3(1.5, 1, 1), r);\n}\n\nfloat antSDF(vec3 p, inout Object oAnt, inout Data data) {\n    float dist = FAR;\n    Object o = NEW_OBJECT;\n    \n    float height = 1.5;\n    float len = 2.5;\n    float legLen = len*0.9;\n    float headR = 0.5;\n    float buttR = headR*1.1;\n    \n    \n    float moveSpeed = 1.6;\n    \n    float legSign = ssign(p.x, 0.1);\n    float leg1Time = (T+legSign)*2.5*moveSpeed;\n    float leg2Time = (T-legSign)*2.5*moveSpeed;\n    float leg3Time = (T+legSign+0.1*leg2Time)*2.5*moveSpeed;\n    float antennaTime = (T+3.0*legSign);\n    float headTime = (T+0.31923)*0.5;\n    \n    vec3 headRot = vec3(0, cos(headTime)*0.25, 0);\n    vec3 antennaRot = vec3(0, sin(antennaTime)*0.15, cos(antennaTime)*0.1);\n    vec3 leg1Rot = vec3(0, (sin(leg1Time)-0.5*legSign)*0.25, 0);\n    vec3 leg2Rot = vec3(0, (sin(leg2Time)-0.5*legSign)*0.25, 0);\n    vec3 leg3Rot = vec3(0, (sin(leg3Time)-0.5*legSign)*0.25, (sin(leg3Time)-0.5*legSign)*0.1);\n    \n    Object oHead = Object(ID_ANT_HEAD, vec3(0, height, 0), headRot, vec3(1.0));\n    Object oAntenna = Object(ID_ANT_ANTENNA, vec3(0, 0, 0), antennaRot, vec3(1.0));\n    Object oEye = Object(ID_ANT_EYE, vec3(0, 0, 0), vec3(0, 0, 0), vec3(1.0));\n    Object oHeadComp = oHead;\n    float antHead = antHeadSDF(p, headR, oHead, oAntenna, oEye, oHeadComp);\n    SAMPLE(oHeadComp, antHead);\n    \n    Object oBody = Object(ID_ANT_BODY, vec3(0, height*0.8, -0.5*len), vec3(0, 0, 0), vec3(1.0));\n    float body = antBodySDF(p, len, oBody);\n    SAMPLE(oBody, body);\n    \n    Object oLeg1 = Object(ID_ANT_LEG, vec3(0, height*0.64, -len*0.25), leg1Rot, vec3(1.0));\n    float leg1 = antLegFrontSDF(vec3(abs(p.x), p.y, p.z), legLen, oLeg1);\n    SAMPLE(oLeg1, leg1);\n    \n    Object oLeg2 = Object(ID_ANT_LEG, vec3(0, height*0.64, -len*0.35), leg2Rot, vec3(1.0));\n    float leg2 = antLegMiddleSDF(vec3(abs(p.x), p.y, p.z), legLen, oLeg2);\n    SAMPLE(oLeg2, leg2);\n    \n    Object oLeg3 = Object(ID_ANT_LEG, vec3(0, height*0.53, -len*0.5), leg3Rot, vec3(1.0));\n    float leg3 = antLegBackSDF(vec3(abs(p.x), p.y, p.z), legLen*0.45, oLeg3);\n    SAMPLE(oLeg3, leg3);\n    \n    Object oButt = Object(ID_ANT_BUTT, vec3(0, height*0.64, -len*0.8), vec3(0, 0, 0), vec3(1.0));\n    float butt = antButtSDF(p, buttR, oButt);\n    SAMPLE(oButt, butt);\n    \n    o.p += oAnt.p;\n    o.q = oAnt.q;\n    \n    data.o = o;\n    oAnt = o;\n    return dist;\n}\n\nvec4 getAntPos(float time) {\n    time *= 2.0;\n    float nrSteps = 11.0;\n    float transTime = 0.9;\n    float frame = 1.0;\n    \n    vec3 originalP = vec3(0, -0.37, 0);\n    float originalA = 0.0;\n    \n    float a = originalA;\n    vec3 p = originalP;\n    \n    #define CREATE_FRAME(POS, ANGLE)\\\n    {\\\n        p = onCycle(p, (POS), time, nrSteps, transTime, frame);\\\n        a = onCycle(a, (ANGLE), time, nrSteps, transTime, frame);\\\n        frame += 1.0;\\\n    }\n   \n\n    CREATE_FRAME(originalP + vec3(0, 0, 1), 0.0);\n    CREATE_FRAME(originalP + vec3(1, 0, 2), -1.0);\n    CREATE_FRAME(originalP + vec3(2, 0, 3), -1.6);\n    CREATE_FRAME(originalP + vec3(3, 0, 3.6), -2.0);\n    CREATE_FRAME(originalP + vec3(3, 0, 2), -3.145);\n    CREATE_FRAME(originalP + vec3(4, 0, 2), -4.145);\n    CREATE_FRAME(originalP + vec3(3, 0, 1.5), -4.5);\n    CREATE_FRAME(originalP + vec3(3, 0, 1), -5.0);\n    CREATE_FRAME(originalP + vec3(2, 0, -0.5), -5.6);\n    CREATE_FRAME(originalP + vec3(0, 0, 0), -TAU);\n    CREATE_FRAME(originalP, -TAU);\n   \n   \n  \n\n\n   \n    \n    #undef CREATE_FRAME\n    \n    return vec4(p, a);\n}\n\n\n// </ant>\n\n\nfloat sdf(vec3 p, inout Data data) {\n  float dist = FAR;\n  Object o = NEW_OBJECT;\n\n  Object oGround = Object(ID_GROUND, vec3(0.0), vec3(0.0), vec3(1.0));\n  float ground = groundSDF(p);\n  SAMPLE(oGround, ground);\n  \n  vec4 antPos = getAntPos(T);\n  float antAngle = antPos.w;\n  \n  Object oAnt = Object(ID_ANT, antPos.xyz, vec3(0, antAngle, 0), vec3(1.0));\n  float ant = antSDF(translate(p, oAnt), oAnt, data);\n  SAMPLE(oAnt, ant);\n\n  data.o = o;\n\n  return dist;\n}\n\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n  float d = 0.0;\n\n  for (int i = ZERO; i < STEPS; i++) {\n    vec3 p = ro+rd*d;\n    float next = sdf(p, data);\n    float anext = abs(next);\n    if (anext >= FAR) return false;\n    if (anext <= (NEAR * (1.0 + anext))) break;\n    d += next;\n  }\n\n  vec3 p = ro+rd*d;\n  vec2 e = vec2(NEAR, 0.0);\n  vec3 n = normalize(sdf(p, data) - vec3(\n    sdf(p - e.xyy, data),\n    sdf(p - e.yxy, data),\n    sdf(p - e.yyx, data)\n  ));\n\n  data.p = p;\n  data.n = n;\n  data.d = d;\n\n  return true;\n}\n\nfloat getShadow(Light light, vec3 ro, vec3 n) {\n    vec3 L = getLightDir(light, ro);\n    float NdotL = dot(n, L);\n    if (NdotL <= 0.00003) return AMBIENT;\n    vec3 rd = L;\n    \n    vec3 offset = thash((ro.xz * 14.9323 + 8.0*ro.y)*16., 4.49128);\n    \n    Data data = NEW_DATA;\n    \n    float d = NEAR*3.0 + (offset.x*0.06);\n    float s = 0.0;\n    \n   \n    for (int i = ZERO; i < 24; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(p, data);\n        float acc = clamp(next, 0.005, 0.5);\n        \n        s += next;\n        d += acc;\n        \n        \n    }\n    s = abs(s);\n    s = (s / (1.0 + s));\n    s = s*s*s;\n    \n    s = smoothstep(0.25, 1.0, s);\n  \n    return clamp(s, AMBIENT, 1.0);\n}\n\n\n\n//#define DEBUG_TEXTURE getAlbedoGround\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec3 p = data.p;\n    vec2 uv = p.xz;\n    \n    vec3 c1 = rgb(47, 81, 18);\n    vec3 c2 = rgb(103, 152, 42);\n    vec3 c3 = rgb(107, 121, 40);\n    vec3 c4 = rgb(139, 137, 58);\n    \n    vec3 hf1 = tnoise(uv, 5.48238, 16.0, 0.1, 4);\n    vec3 lf1 = tnoise(uv, 0.031298, 1.0, 0.1, 3);\n    \n    col = mix(c1, c2, hf1.x*smoothstep(0.4, 0.7, lf1.x));\n    col = mix(col, c3, hf1.y);\n    col = mix(col, c4, hf1.z);\n    col = mix(col, col*col, lf1.y*lf1.z);\n    \n    return col;\n}\n\nvec3 getAlbedoAntButt(inout Data data) {\n    vec3 col = vec3(0.0);\n    \n    vec3 p = pointRot(data.n, data.o.q);\n    float u = acos(p.y);\n    float v = atan(p.x, p.z);    \n    u = 0.5 - u / M_PI;\n    v = 0.5 + v / M_PI;\n    vec2 uv = vec2(v,u);\n    \n    \n    vec3 bright1 = rgb(104, 95, 80);\n    vec3 dark1 = rgb(27, 12, 8);\n    \n    vec2 lv = fract(uv*4.0);\n    vec2 alv = abs(lv*2.0-1.0);\n    \n    float stripes = smoothstep(0.4, 0.2, alv.y);\n    \n    vec3 n1 = thash(uv*32.0, 2.323123);\n    float ra = 0.4;\n    float fe = ra*0.5;\n    float fuzz = smoothstep(ra+fe, ra-fe, length(fract(uv*24.0)*2.0-1.0));\n    fuzz *= smoothstep(0.4, 0.7, n1.x);\n    \n    data.m.spec =fuzz;\n    col = bright1;\n    col = mix(col, dark1, stripes);\n    col = col*col*col;\n    col = mix(col, bright1*bright1, fuzz);\n    return col;\n    \n}\n\nvec3 getAlbedoAntBody(inout Data data) {\n    vec3 col = vec3(0.0);\n    \n    vec3 p = pointRot(data.n, data.o.q);\n    float u = acos(p.y);\n    float v = atan(p.x, p.z);    \n    u = 0.5 - u / M_PI;\n    v = 0.5 + v / M_PI;\n    vec2 uv = vec2(v,u);\n    \n    vec3 c1 = rgb(215, 138, 95);\n    vec3 c2 = rgb(119, 43, 2);\n    vec3 c3 = rgb(177, 95, 50);\n    vec3 c4 = rgb(131, 70, 46);\n    \n    vec3 lf1 = tnoise(uv, 3.29123, 9.0, 0.0, 4);\n    \n    col = mix(c1, c2, lf1.x);\n    col = mix(col, c3, lf1.y);\n    col = mix(col, c4, lf1.z);\n    col = mix(col, col*col, smoothstep(0.4, 0.7, lf1.z));\n    \n    return col;\n}\n\n\nvec3 getAlbedoAntHead(inout Data data) {\n    vec3 col = vec3(0.0);\n    \n    vec3 p = translate(data.p, data.o);\n    vec3 n = pointRot(data.n, data.o.q);\n    float u = acos(n.y);\n    float v = atan(n.x, n.z);    \n    u = 0.5 - u / M_PI;\n    v = 0.5 + v / M_PI;\n    vec2 uv = vec2(v,u);\n    \n    vec3 c1 = rgb(80, 70, 54);\n    vec3 c2 = rgb(110, 49, 25);\n    \n    vec3 lf1 = tnoise(uv, 3.29123, 9.0, 0.0, 4);\n     \n    vec3 buttCol = getAlbedoAntButt(data);\n \n    col = mix(c1, c2, lf1.x);\n    col = col*col;\n    \n    col = mix(col, buttCol, slt(p.z, 0.1, 0.2));\n    \n    return col;\n}\n\nvec3 getAlbedoAntLeg(inout Data data) {\n    vec3 col = vec3(0.0);\n    \n    vec3 p = pointRot(data.n, data.o.q);\n    float u = acos(p.y);\n    float v = atan(p.x, p.z);    \n    u = 0.5 - u / M_PI;\n    v = 0.5 + v / M_PI;\n    vec2 uv = vec2(v,u);\n    \n    vec3 c1 = rgb(72, 47, 33);\n    vec3 c2 = rgb(94, 59, 38);\n    vec3 c3 = rgb(66, 55, 50);\n    vec3 c4 = vec3(0.0);\n    \n    vec3 lf1 = tnoise(uv*0.5, 3.29123, 3.0, 0.0, 1);\n    \n    col = mix(c1, c2, lf1.x);\n    col = mix(col, c3, lf1.y);\n    col = mix(col, c4, 0.5*lf1.z);\n    col = mix(col, col*col, smoothstep(0.4, 0.7, lf1.z));\n    \n    return col;\n}\n\nvec3 getAlbedoAntEye(inout Data data) {\n    return vec3(0.0);\n}\n\nvec3 getAlbedo(inout Data data) {\n  switch (data.o.id) {\n    case ID_GROUND: return getAlbedoGround(data); break;\n    case ID_ANT_BUTT: return getAlbedoAntButt(data); break;\n    case ID_ANT_BODY: return getAlbedoAntBody(data); break;\n    case ID_ANT_HEAD: return getAlbedoAntHead(data); break;\n    case ID_ANT_LEG: return getAlbedoAntLeg(data); break;\n    case ID_ANT_ANTENNA: return getAlbedoAntLeg(data); break;\n    case ID_ANT_EYE: return getAlbedoAntEye(data); break;\n  }\n\n  return vec3(0.93);\n}\n\nvec3 forEachLight(Light light, vec3 ro, vec3 rd, Data data, vec3 diffuse) {\n  vec3 p = data.p;\n  vec3 N = data.n;\n  vec3 L = getLightDir(light, p);\n  vec3 att = getLightAtt(light, p, N);\n  vec3 ref = reflect(N, L);\n  float VdotR = max(0.0, dot(rd, ref));\n  float spec = data.m.spec * pow(VdotR, 24.0);\n  float shadow = getShadow(light, data.p, data.n);\n  return ((diffuse + spec) * att) * shadow;\n}\n\nvec3 getSky(in vec3 ro, in vec3 rd) {\n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    vec3 col = vec3(0.0);\n    \n    \n    vec3 c1 = rgb(88, 171, 217);\n    if (ro.y <= 0.0) return c1;\n    \n    vec3 c2 = rgb(13, 69, 153);\n    \n    vec2 uv = rd.xz / rd.y;\n    \n    col = c1;\n    col = mix(col, c2, clamp(dotup*1.2, 0.0, 1.0));\n    \n    vec2 shift = vec2(cos(T*0.2), sin(T*0.2));\n  \n    vec3 lf = tnoise(uv + shift, 3.33321, 1.5, 0.0, 2);\n    \n    \n    float time = T;\n    float nrSteps = 3.0;\n    float transTime = 0.9;\n    float frame = 1.0;\n    \n    float low = lf.x;\n    \n    low = onCycle(low, lf.y, time, nrSteps, transTime, frame); frame += 1.0;\n    low = onCycle(low, lf.z, time, nrSteps, transTime, frame); frame += 1.0;\n    low = onCycle(low, lf.x, time, nrSteps, transTime, frame); frame += 1.0;\n    \n    low = pow(low, 2.2);\n    \n    vec3 hf = tnoise(uv - shift, 3.33321, 10.5, 0.0, 2);\n    float high = hf.x;\n    \n    frame = 1.0;\n    \n    high = onCycle(high, hf.y, time, nrSteps, transTime, frame); frame += 1.0;\n    high = onCycle(high, hf.z, time, nrSteps, transTime, frame); frame += 1.0;\n    high = onCycle(high, hf.x, time, nrSteps, transTime, frame); frame += 1.0;\n    \n    high = pow(high, 2.2);\n    \n    float clouds = low + high;\n    \n    col = mix(col, vec3(1.0), clouds);\n    \n    return col;\n}\n\nvec3 scene(vec3 ro, vec3 rd) {\n  #define NUM_LIGHTS 1\n\n  Light lights[NUM_LIGHTS] = Light[](\n    Light(vec3(1, 2, -3), vec3(0.0, 1, 1), vec3(0.97, 0.79, 0.69), 4.0, LIGHT_AMBIENT)\n  );\n\n  vec3 col = vec3(0.0);\n  Data data = NEW_DATA;\n\n  if (march(ro, rd, data)) {\n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    for (int i = ZERO; i < NUM_LIGHTS; i++) {\n      Light light = lights[i];\n      col += forEachLight(light, ro, rd, data, diffuse);\n    }\n  } else {\n      col += getSky(ro, rd);\n  }\n\n  return col;\n}\n\nvoid getRay(vec2 uv, vec4 m, inout vec3 ro, inout vec3 rd) {\n  float Y = 0.5;\n  ro = vec3(0.0, Y, -6.0);\n  rd = normalize(vec3(uv, 1.0));\n\n  if (m.z > 0.01) {\n    ro.yz *= rot(m.y*TAU);\n    ro.xz *= rot(m.x*TAU);\n    rd.yz *= rot(m.y*TAU);\n    rd.xz *= rot(m.x*TAU);\n  } else {\n    ro.y += 1.0 + 2.0*(0.5+0.5*sin(T));\n    ro.x += 2.0*cos(T);\n    ro.z += 2.0*sin(T);\n    vec3 lookPos = getAntPos(T).xyz;\n    rd = look(uv, lookPos, ro);\n  }\n\n  ro.y = max(ro.y, Y);\n}\n\n////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 o, in vec2 fc) {\n  vec3 col = vec3(0.0);\n  vec2 uv = (fc-0.5*R.xy)/R.y;\n  vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y,iMouse.zw);\n\n  vec3 ro = vec3(0.0);\n  vec3 rd = vec3(0.0);\n  getRay(uv, m, ro, rd);\n\n  #ifdef DEBUG_TEXTURE\n  Data data = NEW_DATA;\n  data.p = (fc.xy / R.y).xyy;\n  col += DEBUG_TEXTURE(data);\n  #else\n  col += scene(ro, rd);\n  #endif\n  col = aces(col);\n  col = pow(col, vec3(1.0 / 2.2));\n\n  o = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}