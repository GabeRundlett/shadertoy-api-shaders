{
    "Shader": {
        "info": {
            "date": "1616688771",
            "description": "ray marching ",
            "flags": 0,
            "hasliked": 0,
            "id": "sds3WX",
            "likes": 9,
            "name": "ray marching - v5 (reflections)",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "jezersek",
            "viewed": 304
        },
        "renderpass": [
            {
                "code": "#define NUMBER_OF_STEPS 1000\n#define MAX_DISTANCE 40.0\n#define FOG_DISTANCE 30.0\n#define FOG_DENSITY 0.2\n#define COLLISION_THRESHOLD 0.001\n#define MAX_STEP_SIZE 10000000.0\n#define EPSILON 0.001\n\n#define SHAPE_BLEND 0.9\n#define COLOR_BLEND 0.9\n\nfloat f = 1.; // focal length\nvec3 light1 = normalize(-vec3(1,-1,1));\nvec3 light2 = normalize(-vec3(-0.5,-1,0.9));\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat safe_distance(vec3 ray, out vec3 color, out float shininess, out float reflectance){\n    float d = MAX_STEP_SIZE; // min safe distance\n\n\n    float d1 = box(rotate(ray-vec3(0,0,9), vec3(1,1,0), iTime), vec3(0.0,1.4,1.), 0.3);\n    float d2 = box(rotate(ray - vec3(5.+sin(iTime*.7)*0.5,sin(iTime*0.3)*.5+1.,9), vec3(-1,10,0),-0.5), vec3(1,2,1), 0.1);\n    float d3 = sphere(ray - vec3(-5,1,12), 4.) + smoothstep(1.,0.,sin(ray.y*5.+iTime))*.2;\n    float d4 = sphere(vec3(ray.x, ray.y*( 1.-(1.+sin(iTime*5.))*.04 ), ray.z) - vec3(3,2,20), 7.);\n    d1 = min(min(d1, d2), min(d3, d4));\n    float d0 = plane(ray-vec3(0,-2,6), normalize(vec3(0,1,0)));\n    d = min(d1, d0);\n    \n    if(d1 < d0){\n        if(d1 < d2 && d1 < d3 && d1 < d4){\n            color = vec3(.9,.5,.1);\n        }\n        else{\n            color = vec3(.5,.0,.9);\n        }\n    }\n    else{\n        color = vec3(.04,.04,.04);\n    }\n    shininess = .9;\n    return d;\n}\n\nfloat safe_distance(vec3 ray){\n    vec3 c = vec3(0);\n    float s = 0.;\n    float r = 0.;\n    return safe_distance(ray, c, s, r);\n}\n\nvec3 normal(vec3 ray){\n    vec3 epsilon = vec3(EPSILON, 0, 0);\n\n    vec3 n = vec3(safe_distance(ray)) - vec3(\n        safe_distance(ray - epsilon.xyy),\n        safe_distance(ray - epsilon.yxy),\n        safe_distance(ray - epsilon.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat shadow(vec3 pos, vec3 ray, float k){\n    float d = 0.1;\n    float val = 1.;\n    for(int j=0; j<NUMBER_OF_STEPS; j++){\n        float h = safe_distance(pos+ray*d);\n        if(h < COLLISION_THRESHOLD){ // collision\n            return 0.;\n        }\n        val = min(val, k*h/d);\n        \n        d += h;\n        \n        if(d > MAX_DISTANCE){ // decay\n           break;\n        }\n    }\n    return val;\n}\n\nvec3 ray_march(vec3 ray_dir){\n    vec3 total_color = vec3(0);\n    float shininess = 0.;\n    float reflectance = 0.;\n    vec3 body_color = vec3(0);\n    int reflections = 0;\n    //float d = 0.; // ray length\n    vec3 ray = vec3(0.);\n    float min_distance = 100000.; // infty\n    for(int j=0; j<NUMBER_OF_STEPS; j++){\n        float step_size = safe_distance(ray, body_color, shininess, reflectance);\n        \n        if(step_size < COLLISION_THRESHOLD){ // collision\n            vec3 color = vec3(0);\n        \n            vec3 n = normal(ray);\n            float l1 = max(dot(n, light1), 0.);\n            float l2 = max(dot(n, light2), 0.);\n            \n            \n            // shadow\n            /*float s = shadow(ray, light1, 5.5);\n            l1 = max(l1 - (1.-s)*.2, 0.);*/\n            \n            //color = (l1 * vec3(.9,0,0.5) + l2 * vec3(.0,.5,.7));\n            //color = -n*0.5+0.5; // normal color\n            color = body_color*0.1; // ambient\n            color += body_color*l1 + body_color*l2; // difuse light\n            color += (vec3(0.5)*pow(l1, 30.) + vec3(.0)*pow(l2, 100.))*shininess; // specular light            \n            \n            // fog in the distance\n            color /= (exp((length(ray)-FOG_DISTANCE)*FOG_DENSITY)+1.);\n            \n            total_color = mix(color, total_color, float(reflections)*0.8);\n            \n            // reflection\n            if(++reflections < 2){\n                ray_dir = -normalize(2. * dot(n, ray_dir) * n - ray_dir);\n                //ray_dir = normalize(ray_dir*(1.-1./dot(ray_dir, n)));\n                ray += ray_dir*0.1;\n            }\n            else{\n                break;\n            }\n        }\n        \n        if(step_size < min_distance) min_distance = step_size;\n        \n        ray += ray_dir*step_size;\n        \n        if(length(ray) > MAX_DISTANCE){ // decay\n           break;\n        }\n    }\n    \n    // glow\n    //color = vec3(1.,.6,.3)*pow(max(1.-min_distance,0.),10.);\n    \n    return total_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mind = min(iResolution.y, iResolution.x);\n    vec2 uv = (fragCoord-iResolution.xy/2.)/mind;\n    fragColor = vec4(ray_march(normalize(vec3(uv, f))),1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// SHAPES\n// pos is vector from center of the sphere to ray\nfloat octahedron(vec3 pos, float r){\n    return (dot(abs(pos), vec3(1)) - r) *0.57735027;\n}\n\nfloat sphere(vec3 pos, float r){\n    return length(pos) - r; // + sin(pos.x*20.)*0.05;\n}\n\nfloat pipe(vec3 pos, vec3 dir, float r){\n    return length(pos - dir*dot(pos, dir))-r;\n}\n\nfloat pipe_wave(vec3 pos, vec3 dir, float r){\n    return length(pos - dir*dot(pos, dir))-r + r*0.02*cos(length(dir*dot(pos,dir))*10.);\n}\n\nfloat box(vec3 pos, vec3 size, float r){\n    pos = abs(pos)-size;\n    return length(max(pos, 0.)) + min(max(max(pos.x, pos.y),pos.z),0.) - r;\n}\n\nfloat plane(vec3 pos, vec3 n){\n    return dot(pos, n);\n}\n\n// BLENDING\nfloat smooth_min( float d1, float d2, float s ) {    \n    float t = tanh((d1-d2)*s);\n    return ((1.+t)*d2 + (1.-t)*d1)/2.;\n}\n\nvec4 smooth_min_color(vec4 c1, vec4 c2, float s){ // c_.w component is distance\n    float d1 = c1.w, d2 = c2.w;\n    float t = tanh((d1-d2)*s);\n    return ((1.+t)*c2 + (1.-t)*c1)/2.;\n}\n\n// QUATERNION ROTATION\nvec4 rotation_q(vec3 u, float t){ // rotation axis - normalized, rotation angle / 2\n    return vec4(u * sin(t), cos(t));\n}\nvec3 rotate(vec3 v, vec4 q){ // vector to rotate, rotation quaternion\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\nvec3 rotate(vec3 v, vec3 u, float t){\n    vec4 q = rotation_q(normalize(u), t);\n    return rotate(v, q);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}