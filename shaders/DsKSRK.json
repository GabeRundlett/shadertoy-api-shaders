{
    "Shader": {
        "info": {
            "date": "1681320061",
            "description": "RT shader that has 2 refraction events for a sphere SDF",
            "flags": 2,
            "hasliked": 0,
            "id": "DsKSRK",
            "likes": 1,
            "name": "double event refraction RT",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "natet",
            "viewed": 145
        },
        "renderpass": [
            {
                "code": "Sphere sphere1 = Sphere(2.5,1.0,64.0,vec3(0.9,0.9,0.0),vec3(0.0,0.0,8.0));\n\nLight light = Light(vec3(0.8,0.5,0.8),vec3(20.0,40.0,-30.0));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //Move stuff around\n    sphere1.pos = vec3(cos(iTime*1.25)*6.0+2.0,sin(iTime*1.25)*2.0,8.0 +(sin(45.17+iTime*1.25)*4.0));\n    //light.pos = vec3(sin(iTime)*50.0,(cos(iTime)*40.0)+30.0,-30.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Make a value to correct for the aspect ratio. If the screen was always square this wouldnt be necessary. \n    float xCorrect = max(iResolution.x, iResolution.y) / min(iResolution.x, iResolution.y);\n    \n    //make a 2D vector of the current pixel's position, normalized to 0-1 and shifted on the X so that the world is centered (also dont know why this is necessary), and scale the X values so that it corrects for the aspect\n    //ratio distortion. \n    vec2 normalizedPosition = vec2(map(fragCoord.x-(iResolution.x/4.5),0.0,iResolution.x,0.0,1.0)*xCorrect,map(fragCoord.y,0.0,iResolution.y,0.0,1.0));\n\n    //Make the current lookVector for this pixel by converting the normalized pixel position we just made to be between -0.5 and 0.5 for x and y (this is because im not doing anything with camera projection or parameters.\n    //The camera view is always looking straight ahead (toward +ve z in world space) and the FoV is set by the screen resolution.)\n    vec3 lookVector = vec3(normalizedPosition.x-0.5, normalizedPosition.y-0.5, 1.0);\n\n    //Set the ray origin vector\n    vec3 origin = vec3(0,0,0);\n    \n    //calculate the distance along the ray of the first and second intersctions with the sphere\n\tfloat t0 = SphereIntersection(origin, lookVector, sphere1.pos, sphere1.radius, false);\n\tfloat t1 = SphereIntersection(origin, lookVector, sphere1.pos, sphere1.radius, true);\n    \n    vec2 offset = vec2(0.5+mod(iTime*0.075,1.0),0.0);\n    vec2 scale = vec2(2.0,1.0);\n    \n    \n    // Output to screen\n    if(t0 > 0.0){\n        vec4 col = calcReflection(origin, lookVector, sphere1.pos, t0, offset, scale, iChannel0);\n        col = (col*0.5) + 0.5*calcRefraction(origin, lookVector, sphere1.pos, sphere1.radius, t0, offset, scale, 2.3, iChannel0);\n        fragColor = col;\n        //fragColor = calcReflection(origin, lookVector, sphere1.pos, t0, offset, scale, iChannel0);\n        //fragColor = calcRefraction(origin, lookVector, sphere1.pos, t0, offset, scale, 1.1, iChannel0);\n    } else {\n        fragColor = calcEnv(lookVector, offset, vec2(scale.x,scale.y*-1.0), iChannel0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/presets/webcam.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.1415926538\n\nstruct Sphere\n{\n    float radius;\n    float ID;\n    float shininess;\n    vec3 col;\n    vec3 pos;\n};\n\nstruct Light\n{\n    vec3 col;\n    vec3 pos;\n};\n\n//https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9 glsl map function\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n//Based on https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\nfloat SphereIntersection(vec3 O, vec3 D, vec3 C, float R, bool backfacing){\n\t//I'll try to comment how this function works but its been so long since I wrote it for my terrible CPU oF raytracer that I don't really remember, but it is based on the analytical solution from the above URL.\n\t//Analytical algebra is not something I was ever taught (atleast properly) at school, so I'm not quick at it at the best of times, let alone when it's being used with vectors. \n\t//O = origin\n\t//D = look/ray direction\n\t//C = sphere position\n\t//R = sphere radius\n\t//Calculate the origin of this ray relative to the location of the sphere\n\tvec3 newOrigin = O - C;\n\n\t//Define the values for the analytical solution based on the geometric parameters of the ray and the sphere. \n\tfloat a = dot(D,D);\n\tfloat b = 2.0 * dot(newOrigin,D);\n\tfloat c = dot(newOrigin,newOrigin) - (R*R);\n\n\t//Calculate the discriminant for the components of the quadratic function outline in the linked article that we just calculated above\n\tfloat delta = (b * b -  4.0 * a * c);\n\n\tfloat t0;\n\tfloat t1;\n\n\t//If the discriminant (delta) is < 0 then the ray hasn't intersected anything (there is no root of the quadratic equation)\n\t//First Interesction Logic:\n\tif(delta < 0.0){\n\t\t//For actual rendering, t should be set to -1 so that it makes the returned vector 0:\n\t\tt0 = -1.0;\n\t} \n\t//if delta > 0 then there is atleast one root to the equation, so the ray has intersected something, so we want to output the distance along the ray that this has happened. \n\telse {\n\t\t\n\t\t//Calculate the numerator of the quadratic for the -sqrt(delta) root.\n\t\tfloat numerator = (-1.0 * b - sqrt(delta)) / (2.0 * a);\n\n\t\t//if this numerator is >= 0 then its the right root and we can write it to the t0 variable, for the first intersection. If not, make t0 the +sqrt(delta) root.\n\t\tif (numerator >= 0.0){\n\t\t\tt0 = numerator;\n\t\t}\n\t\telse {\n\t\t\tt0 = (-1.0 * b + sqrt(delta)) / (2.0 * a);\n\t\t}\n\t}\n\n\t//Second Intersection Logic: \n\tif (delta < 0.0) {\n\t\tt1 = -1.0;\n\n\t}\n\telse {\n\n\t\t//Calculate the numerator of the quadratic for the -sqrt(delta) root.\n\t\tfloat numerator = (-1.0 * b - sqrt(delta)) / (2.0 * a);\n\n\t\t//if this numerator is *NOT* >= 0 then its the right root and we can write it to the t1 variable, for the first intersection. If not, make t1 the +sqrt(delta) root.\n\t\tif (!(numerator >= 0.0)) {\n\t\t\tt1 = numerator;\n\t\t}\n\t\telse {\n\t\t\tt1 = (-1.0 * b + sqrt(delta)) / (2.0 * a);\n\t\t}\n\n\t}\n\n\tif (!backfacing) {\n\t\t//Return the first intersection\n\t\treturn t0;\n\t}\n\telse {\n\t\t//Return the second intersection\n\t\treturn t1;\n\t}\n}\n\n//Also based on https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection , see the \"Computing the Normal at the Intersection Point\" section\nvec3 getSphereNormal(vec3 O, vec3 D, vec3 C, float T){\n\t//O = ray origin\n\t//D = look/ray direction\n\t//C = sphere centre position\n\t//T = distance along the ray of intersection, so either t0 or t1 in this usecase\n\t//Calculate the vector for the point on the sphere that our ray hit\n\tvec3 P = O + T * D;\n\t//Calculate the normal of this point by subtracting the sphere's location from the location of the ray hit\n\tvec3 N = P - C;\n\treturn normalize(N);\n}\n\nvec4 calcReflection(vec3 O, vec3 D, vec3 C, float T, vec2 offset, vec2 scale, sampler2D tex) {\n    //ray hitpoint\n    vec3 surfacePosition = O + T * D;\n    //Normal at hitpoint\n    vec3 normal = getSphereNormal(O,D,C,T);\n    // Compute direction from eye to the surface position\n    // Note: eye is at (0,0,0) in view space\n    vec3 eyeDir = normalize(surfacePosition);\n\n    // Compute reflection direction\n    vec3 reflDir = reflect(eyeDir, normal);\n\n    vec3 worldSpaceReflDir = normalize(reflDir);\n    \n    // Calculate direction of reflection in polar coordinates\n    float theta = atan(worldSpaceReflDir.z, worldSpaceReflDir.x);\n    float phi = asin(worldSpaceReflDir.y);\n    // Use polar coordinates to calculate the texture co-ordinates to lookup from the environment map\n    vec2 envLookupCoords = vec2(0.5 * theta / PI + 0.5, 0.5 - phi / PI);\n\n    // Lookup the color from the reflection map\n    return texture(tex, fract((envLookupCoords+offset)*scale));\n}\n\nvec4 calcEnv(vec3 D, vec2 offset, vec2 scale, sampler2D tex) {\n\n    // Calculate direction of environment in polar coordinates\n    float theta = atan(D.z, D.x);\n    float phi = asin(D.y);\n    // Use polar coordinates to calculate the texture co-ordinates to lookup from the environment map\n    vec2 envLookupCoords = vec2(0.5 * theta / PI + 0.5, 0.5 - phi / PI);\n\n    // Lookup the color from the reflection map\n    return texture(tex, fract((envLookupCoords+offset)*scale));\n\n}\n\nvec4 calcRefraction(vec3 O, vec3 D, vec3 C, float R, float T, vec2 offset, vec2 scale, float ior, sampler2D tex) {\n\t//O = ray origin\n\t//D = look/ray direction\n\t//C = sphere centre position\n\t//T = distance along the ray of intersection, so either t0 or t1 in this usecase\n    //ray at hitpoint\n    vec3 surfacePosition = O + T * D;\n    //Normal at hitpoint\n    vec3 normal = getSphereNormal(O,D,C,T);\n    \n    \n    float eta = 1.0/ior;\n\n    // Compute direction from eye to the surface position\n    // Note: eye is at (0,0,0) in view space\n    vec3 eyeDir = normalize(surfacePosition);\n\n    // Compute refraction direction for the first intersection (front of sphere)\n    vec3 refrDir = refract(eyeDir, normal, eta);\n    \n    //Ray trace from the refraction direction to hit the back of the sphere\n    float newHit = SphereIntersection(surfacePosition, refrDir, C, R, false);\n    \n    if(newHit < 0.0){\n        vec3 newHitPos = surfacePosition + newHit * eyeDir;\n        vec3 newNormal = getSphereNormal(surfacePosition, eyeDir, C, newHit);\n        vec3 newEyeDir = normalize(newHitPos);\n        vec3 newRefrDir = refract(newEyeDir, newNormal, eta);\n        vec3 worldSpaceReflDir = normalize(newRefrDir);\n        // Calculate direction of refraction in polar coordinates\n        float theta = atan(worldSpaceReflDir.z, worldSpaceReflDir.x);\n        float phi = asin(worldSpaceReflDir.y);\n        // Use polar coordinates to calculate the texture co-ordinates to lookup from the environment map\n        vec2 envLookupCoords = vec2(0.5 * theta / PI + 0.5, 0.5 - phi / PI);\n\n        // Lookup the color from the environment map\n        return texture(tex, fract((envLookupCoords+offset)*scale));\n    } else {\n\n        vec3 worldSpaceReflDir = normalize(refrDir);\n\n        // Calculate direction of refraction in polar coordinates\n        float theta = atan(worldSpaceReflDir.z, worldSpaceReflDir.x);\n        float phi = asin(worldSpaceReflDir.y);\n        // Use polar coordinates to calculate the texture co-ordinates to lookup from the environment map\n        vec2 envLookupCoords = vec2(0.5 * theta / PI + 0.5, 0.5 - phi / PI);\n\n        // Lookup the color from the environment map\n        return texture(tex, fract((envLookupCoords+offset)*scale));\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}