{
    "Shader": {
        "info": {
            "date": "1527269087",
            "description": "Two light-sources, hard shadows, reflections, (fake) fresnel, blinn-phong, basic material-system... and polka-dots :) For a non-PBR scene it looks solid I guess. This is basically now my goto-scene for starting new tests.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdtfDs",
            "likes": 4,
            "name": "pseudo-realistic base scene",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "reflection",
                "phong",
                "shadow",
                "lighting",
                "spheretracing",
                "blinn",
                "fresnel"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 689
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// pseudo-realistic base scene \n//\n// Copyright 2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int MAX_ITER = 48;\nconst float EPSILON = .001;\nconst float STEP_BIAS = .95;\n\nmat2 r2d (in float a) {\n\tfloat c = cos (radians (a));\n    float s = sin (radians (a));\n    return mat2 (c, s, -s, c);\n}\n\nfloat sdBox (in vec3 p, in vec3 size, in float r)\n{\n  vec3 d = abs(p) - size;\n  return min (max (d.x, max (d.y,d.z)), .0) + length (max (d, .0)) - r;\n}\n\nfloat sdTerrain (in vec3 p, in float height)\n{\n    float h = .5*texture (iChannel0, .1*p.xz).r;\n    h += .25*texture (iChannel0, .2*p.xz).r;\n    h += .125*texture (iChannel0, .4*p.xz).r;\n    h += .0625*texture (iChannel0, .8*p.xz).r;\n    h /= (.5 + .25 + .125 + .0625);\n    h += height;\n    return p.y - .0625*h*.25;\n}\n\nfloat sdTorus (in vec3 p, in vec2 t)\n{\n    vec2 q = vec2 (length (p.xz) - t.x, p.y);\n    return length (q) - t.y;\n}\n\nstruct HitResult {\n\tfloat dist;\n\tint id;\n};\n\nHitResult scene (in vec3 p) {\n    vec3 boxCenter = p + vec3 (1.5, -1., .0);\n    boxCenter.xz *= r2d (12.*iTime);\n    boxCenter.zy *= r2d (-16.*iTime);\n    boxCenter.xy *= r2d (8.*iTime);\n    boxCenter.xy += .02*sin (10.*p.y + 5.*iTime);\n    boxCenter.yz += .02*cos (20.*p.y + 4.*iTime);\n    boxCenter.zy += .02*sin (15.*p.y + 6.*iTime);\n    float box = sdBox (boxCenter, vec3(.75), .1);\n\n    float ground = sdTerrain (p, -1.);\n    vec3 torusCenter = p + vec3 (-1.5, -1., .0);\n    torusCenter.xy *= r2d (80.*(.5+.5*cos(iTime))*torusCenter.z);\n    float torus = sdTorus (torusCenter, vec2 (.75, .3));\n\n\tHitResult result = HitResult (.0, -1);\n\tresult.dist = min (torus, min (ground, box));\n\tresult.id = result.dist == torus ? 0 : (result.dist == ground ? 1 : (result.dist == box ? 2 : -1));\n\n    return result;\n}\n\nHitResult raymarch (in vec3 ro, in vec3 rd) {\n    float d = .0;\n\tfloat t = .0;\n\tHitResult result;\n    for (int i = 0; i < MAX_ITER; ++i) {\n        result = scene (ro + t*rd);\n        d = result.dist;\n        if (abs (d) < EPSILON * (1. + .125*d)) break;\n        t += d*STEP_BIAS;\n    }\n\n\tresult.dist = t;\n    return result;\n}\n\nvec3 normal (in vec3 p, in float epsilon) {\n    float d = scene (p).dist;\n    vec2 e = vec2 (epsilon, .0);\n    return normalize (vec3 (scene (p + e.xyy).dist,\n                            scene (p + e.yxy).dist,\n                            scene (p + e.yyx).dist) - d);\n}\n\nfloat shadow (in vec3 p, in vec3 n, in vec3 lPos) {\n    float lDist = distance (p, lPos);\n    vec3 lDir = normalize (lPos - p);\n    float dist = raymarch (p + .01*n, lDir).dist;\n    return dist < lDist ? .1 : 1.;\n}\n\nvec3 diffSpecTerm (in vec3 ro,\n                   in vec3 rd,\n                   in float d,\n                   in vec3 lPos,\n                   in vec3 diffColor,\n                   in float attenuationDamping,\n                   in vec3 specColor,\n\t\t\t\t   in float shininess) {\n    vec3  p = ro + d*rd;\n    vec3  n = normal (p, d*EPSILON);\n    vec3  lDir = normalize (lPos - p);\n    float lDist = distance (lPos, p);\n    float diff = max (dot (lDir, n), .0);\n    float sha = shadow (p, n, lPos);\n    float attenuation = attenuationDamping / (lDist*lDist);\n    vec3  diffTerm = sha*attenuation*diff*diffColor;\n    vec3  h = normalize (lDir - rd);\n    float spec = pow (max (dot (n, h), .0), shininess);\n    vec3  specTerm = (sha > .1) ? attenuation*spec*specColor : vec3 (.0);\n\n    return diffTerm + specTerm;\n}\n\nstruct Material {\n\tvec3 color;\n\tfloat shininess;\n};\n\nMaterial[3] materials = Material[3] (Material (vec3 (1., .5, .2), 10.),\n\t\t\t\t\t\t\t         Material (vec3 (.5, 1., .2), 50.),\n\t\t\t\t\t\t\t         Material (vec3 (.2, .5, 1.), 150.));\n\nvec3 shade (in vec3 ro, in vec3 rd, in float d, in int matId) {\n    vec3 p = ro + d*rd;\n    vec3 n = normal (p, d*EPSILON);\n    vec3 amb = vec3 (.15);\n\tvec3 color = matId == 1 ? mix (vec3 (.9),\n                                   vec3 (1., .1, .1),\n                                   smoothstep (.475, .5, cos(2.*p.x)*cos (2.*p.z))) :\n                              materials[matId].color;\n\tfloat mask = mix (1., .0, smoothstep (.3, .5, (.5+.5*sin (60.*p.x))*(.5+.5*sin(60.*p.y))));\n\tfloat shininess = matId == 0 ? mix (20., 60., mask) : materials[matId].shininess;\n    vec3 term1 = diffSpecTerm (ro, rd, d,\n                              vec3 (2.*cos (2.*iTime), 3., -1. + 2.*sin (1.5*iTime)),\n                              color, 5., vec3 (1.), shininess);\n\n    vec3 term2 = diffSpecTerm (ro, rd, d,\n                              vec3 (1. + 2.*cos (2.*iTime), 3., -1. + 2.*sin (2.*iTime)),\n                              color, 4., vec3 (1.), shininess);\n\n    return amb + term1 + term2;\n}\n\nvec3 camera (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom) {\n    vec3 camForward = normalize (vec3 (aim - ro));\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (worldUp, camForward));\n    vec3 camUp = normalize (cross (camForward, camRight));\n    vec3 camCenter = ro + camForward * zoom;\n\n    return normalize (camCenter + uv.x * camRight + uv.y * camUp - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinate-normalization, aspect-correction\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvRaw = uv;\n\tuv = uv * 2. - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    // \"camerea\"/view setup\n    float dist = -2.75;\n    vec3 ro = vec3 (.0 + 3.*cos (iTime), 3., .5 + 3.*sin (iTime));\n    vec3 aim = vec3 (.0);\n    float zoom = 1.;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    // primary/view-ray\n    HitResult result = raymarch (ro, rd);\n    float d = result.dist;\n    float fog = 1. / (1. + d*.025);\n    vec3 p = ro + d*rd;\n    vec3 n = normal (p, d*EPSILON);\n    vec3 col = shade (ro, rd, d, result.id);\n\n    // secondary/1st reflection-ray\n    vec3 refl = normalize (reflect (rd, n));\n    result = raymarch (p + .01*n, refl);\n    float refd = result.dist;\n    vec3 refp = p + refd*refl;\n    vec3 refn = normal (refp, refd*EPSILON);\n    vec3 refcol = shade (p, refl, refd, result.id);\n\n    // ternary/2st reflection-ray\n    vec3 refl2 = normalize (reflect (refl, refn));\n    result = raymarch (refp + .01*refn, refl2);\n    float refd2 = result.dist;;\n    vec3 refp2 = refp + refd2*refl2;\n    vec3 refcol2 = shade (refp, refl2, refd2, result.id);\n\n    // restricting reflections to grazing view-angles\n\tfloat fakeFresnel = pow (1. - max (dot (n, -rd), .0), 1.25);\n  \tcol += fakeFresnel*.85*refcol;\n   \tcol += fakeFresnel*.85*refcol2;\n\n    // fog, \"horizon\", tint, tone-mapping, gamma-correction, vignette\n    col *= fog;\n    col = mix (col, vec3 (.65, .75, .85), pow (1. - 1. / d, 30.));\n    col *= vec3 (.9, .8, .7);\n    col = col / (1. + col);\n    col = .3 * col + .7 * sqrt (col);\n    col *= .3 + .7 * pow (16. * uvRaw.x * uvRaw.y * (1. - uvRaw.x) * (1. - uvRaw.y), .2);\n\n    fragColor = vec4 (col, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}