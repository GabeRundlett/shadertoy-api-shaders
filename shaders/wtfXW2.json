{
    "Shader": {
        "info": {
            "date": "1564311339",
            "description": "Golden-ratio polar-coordinate distribution of points gives really uniform coverage for any number of points. Created this to test if it would make a good sampling pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtfXW2",
            "likes": 35,
            "name": "phi radial distribution",
            "published": 3,
            "tags": [
                "2d",
                "voronoi",
                "distribution"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 1434
        },
        "renderpass": [
            {
                "code": "const int n = 800;\nconst float rate = 7.;\nconst float lineThickness = 2.2;\nconst float colours = 0.05; // proportion of cells to colour in\nconst bool zoom = true;\n\nconst float phi = 1.6180339887498948;\nconst float tau = 6.2831853071795865;\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    float penOut = lineThickness/iResolution.y;\n    float penIn = (lineThickness-2.8)/iResolution.y;\n\n    float t = iTime*rate;\n    \n    fragColour = vec4(0,0,0,1);\n\n    float scale = sqrt(float(n));\n    if ( zoom ) scale = min( scale, pow((iTime+7.)*rate*.5,.6) ); // keep the edgemost points in shot as we zoom\n    \n    float closest = 1e38;\n    float closest2 = 1e38;\n    for ( int i=0; i < n; i++ )\n    {\n        float f = float(i);\n        f += fract(t);\n        float r = sqrt(f/128.);\n        r *= 13./scale;\n        float a = fract((f-t)*phi)*tau;\n        vec2 pos = r*vec2(sin(a),cos(a));\n        \n        vec3 col = sin(vec3(3,1,6)*(float(i)-floor(t)))*.5+.5;\n        if ( fract(col.y*64.) > colours ) col = vec3(1);\n\n        float l = length(pos-uv);\n\n        // add a ring to help me track size (so it doesn't look like we're zooming out)\n        //col *= smoothstep(penIn,penOut,abs(l/scale-.001)*scale);\n\t\t\n        if ( i == 0 ) l += smoothstep(1.,0.,fract(t))*1.2/scale; // grow the new point\n\t\tif ( l < closest )\n        {\n            if ( closest < closest2 ) closest2 = closest;\n            closest = l;\n\t\t\tfragColour.rgb = col; // *(1.-l*sqrt(float(n)));\n        }\n        else if ( l < closest2 )\n        {\n            closest2 = l;\n        }\n        fragColour.rgb = mix(fragColour.rgb,vec3(0),smoothstep(penOut,penIn,length(pos-uv)));\n    }\n    \n    // cell borders\n    fragColour.rgb *= smoothstep(penIn,penOut,(closest2-closest));//*scale);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}