{
    "Shader": {
        "info": {
            "date": "1631280439",
            "description": "Based on some of Shane's functions",
            "flags": 0,
            "hasliked": 0,
            "id": "sdK3Rw",
            "likes": 11,
            "name": "RayMarching : colors",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "klemek",
            "viewed": 430
        },
        "renderpass": [
            {
                "code": "#define PI 3.1416\n#define FAR 50.0\n#define MAX_RAY 92\n#define MAX_REF 16\n#define FOV 1.57\n#define OBJ_MIN_D 0.01\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat rand(float seed) {\n    float v = pow(seed, 6.0 / 7.0);\n    v *= sin(v) + 1.;\n    return v - floor(v);\n}\n\nvec3 col(float x) {\n    return vec3(\n        .5 * (sin(x * 2. * PI) + 1.),\n        .5 * (sin(x * 2. * PI + 2. * PI / 3.) + 1.),\n        .5 * (sin(x * 2. * PI - 2. * PI / 3.) + 1.)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat sphere(vec3 q, vec3 p, float r) {\n    return length(q - p) - r;\n}\n\nfloat plane(vec3 q, vec3 d, float offset) {\n    return dot(d, q) + offset;\n}\n\nfloat capsule(vec3 q, vec3 p1, vec3 p2, float r) {\n    vec3 ab1 = p2 - p1;\n    vec3 ap1 = q - p1;\n    float t1 = dot(ap1, ab1) / dot(ab1, ab1);\n    t1 = clamp(t1, 0., 1.);\n    vec3 c1 = p1 + t1 * ab1;\n    return length(q - c1) - r;\n}\n\nfloat torus(vec3 q, vec3 p, float r1, float r2) {\n    q -= p;\n    float x = length(q.xz) - r1;\n    return length(vec2(x, q.y)) - r2;\n}\n\nfloat box(vec3 q, vec3 p, vec3 s) {\n    return length(max(abs(q - p) - s, 0.));\n}\n\nfloat cyl(vec3 q, vec3 p1, vec3 p2, float r) {\n    vec3 ab2 = p2 - p1;\n    vec3 ap2 = q - p1;\n    float t2 = dot(ap2, ab2) / dot(ab2, ab2);\n    vec3 c2 = p1 + t2 * ab2;\n    float d = length(q - c2) - r;\n    float y = (abs(t2 - .5) - .5) * length(ab2);\n    float e = length(max(vec2(d, y), 0.));\n    float i = min(max(d, y), 0.);\n    return e + i;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n\n#define OBJ_COUNT 6\n\nfloat objects[OBJ_COUNT] = float[](FAR, FAR, FAR, FAR, FAR, FAR);\nvec3 objectsColor[OBJ_COUNT] = vec3[](vec3(1.), vec3(1.), vec3(1.), vec3(1.), vec3(1.), vec3(1.));\nconst float objectsRef[OBJ_COUNT] = float[](.1,.1,.1,.1,.1,.1);\n\nvoid setObjects(vec3 q) {\n\n    vec3 pos = vec3(.0, .0, -iTime * 2.);\n    \n    q -= pos;\n\n    float seed = abs(floor(q.x)) + abs(floor(q.y)) * 100. + abs(floor(q.z)) * 1000.;\n    float diff = rand(seed) * 2. * PI;\n\n    objects[0] = sphere(mod(q, 1.), .5 + vec3(cos(iTime + diff + PI) * .1, .1, sin(iTime + diff + PI) * .1), .1);\n    objects[1] = box(mod(q - vec3(cos(iTime + diff) * .1, -.1, sin(iTime + diff) * .1), 1.), vec3(.5), vec3(.15));\n    objects[2] = plane(q, vec3(.0, 1., .0), 1.5);\n    objects[3] = plane(q, vec3(.0, -1., .0), 1.5);\n    objects[4] = plane(q, vec3(1., .0, .0), 1.5);\n    objects[5] = plane(q, vec3(-1., .0, .0), 1.5);\n}\n\nvoid setObjectColors(vec3 q) {\n\n    vec3 pos = vec3(.0, .0, -iTime * 2.);\n    \n    q -= pos;\n    \n    float seed = abs(floor(q.x)) + abs(floor(q.y)) * 100. + abs(floor(q.z)) * 1000.;\n\n    objectsColor[0] =  col(rand(seed++));\n    objectsColor[1] =  col(rand(seed++));\n    objectsColor[2] =  col(rand(seed++));\n    objectsColor[3] =  col(rand(seed++));\n    objectsColor[4] =  col(rand(seed++));\n    objectsColor[5] =  col(rand(seed++));\n}\n\nfloat map(vec3 q) {\n    float d = FAR;\n    \n    setObjects(q);\n    \n    for(int i = 0; i < OBJ_COUNT; i++)\n        d = min(d, objects[i]);\n    \n    return d;\n}\n\nvec3 mapColor(vec3 q) {\n    setObjects(q);\n    setObjectColors(q);\n    \n    vec3 c = vec3(.0);\n    float mind = FAR;\n    \n    for(int i = 0; i < OBJ_COUNT; i++) {\n        if(objects[i] < OBJ_MIN_D && objects[i] < mind){\n             c = objectsColor[i];\n             mind = objects[i];\n        }\n    }\n\n    return c;\n}\n\nfloat mapRef(vec3 q) {\n    setObjects(q);\n    \n    float ref = .0;\n    float mind = FAR;\n    \n    for(int i = 0; i < OBJ_COUNT; i++) {\n        if(objects[i] < OBJ_MIN_D && objects[i] < mind){\n             ref = objectsRef[i];\n             mind = objects[i];\n        }\n    }\n\n    return ref;\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd, int max_d) {\n    float t = 0., h;\n    for(int i = 0; i < max_d; i++){\n        h = map(ro + rd * t);\n        if(abs(h) < .001 * (t * .25 + 1.) || t > FAR)  break;\n        t += h * .8;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p) {\n    const vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 5; i++) {\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nvec4 getHitColor(vec3 ro, vec3 rd, float t, vec3 lightPos) {\n    vec3 hit = ro + rd * t;\n    vec3 norm = normal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1./(1.0 + lightDist*0.125 + lightDist*lightDist*.05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.)*2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    \n    vec3 color = mapColor(hit + rd * OBJ_MIN_D) * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    \n    return vec4(color, atten * occ);\n}\n\nvec3 getColor(vec2 uv, vec3 ro, vec3 dir, vec3 lightPos) {\n    vec3 fwd = normalize(dir - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x));\n    vec3 up = (cross(fwd, rgt));\n    \n    vec3 rd = normalize(fwd + FOV*(uv.x*rgt + uv.y*up));\n    \n    float t = rayMarch(ro, rd, MAX_RAY);\n    \n    vec3 outColor = vec3(.0);\n    \n    if(t < FAR) {\n        vec3 hit = ro + rd * t;\n        vec3 norm = normal(hit);\n        vec4 color = getHitColor(ro, rd, t, lightPos);\n        \n        vec3 ref = reflect(rd, norm);\n        float refQ = mapRef(hit + rd * OBJ_MIN_D);\n        float t2 = rayMarch(hit + ref * .1, ref, MAX_REF);\n        vec4 color2 = getHitColor(hit + ref * .1, ref, t2, lightPos);\n    \n        outColor = (color.xyz * (1. - refQ) + refQ * color2.xyz * color2.w) * color.w;\n    }\n    \n    outColor = mix(min(outColor, 1.), vec3(0), 1.-exp(-t*t/FAR/FAR*20.));\n    \n    return outColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 pos = vec3(.0, .0, .0);\n    vec3 dir = vec3(.0, .0, 1.);\n    vec3 light = pos + vec3(.0, .0, 1.);\n    \n    vec3 c = getColor(uv, pos, dir, light);\n    \n    fragColor = vec4(sqrt(c),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}