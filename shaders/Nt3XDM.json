{
    "Shader": {
        "info": {
            "date": "1639188467",
            "description": "A remake of my old shader \"La calanque\" with everything I learned since this time.. :)!\n\nDepending on your GPU, you can switch to low or high quality in the Common tab.",
            "flags": 32,
            "hasliked": 0,
            "id": "Nt3XDM",
            "likes": 89,
            "name": "Niolon",
            "published": 3,
            "tags": [
                "raymarching",
                "water",
                "ao",
                "caustic",
                "rock",
                "softshadow"
            ],
            "usePreview": 1,
            "username": "XT95",
            "viewed": 3142
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------\n// Compositing pass\n// ---------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = fragCoord * invRes;\n\n    // Chromatic aberration\n    vec2 offset = (uv*2.-1.)/iResolution.xy*0.5;\n    vec4 col = vec4(0.);\n    col.r = texture(iChannel0, uv/SCALE_FACTOR+offset).r;\n    col.g = texture(iChannel0, uv/SCALE_FACTOR-offset).g;\n    col.b = texture(iChannel0, uv/SCALE_FACTOR-offset).b;\n\n    // Light scattering\n    col += texture(iChannel1,uv*.5);\n\n    // Vignetting\n    col *= (pow( uv.x * uv.y * (1.-uv.x) * (1.-uv.y)*100., .2 ));\n    \n    // Gamma correction\n    fragColor = pow(col*2., vec4(1./2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ---------------------------------------------------------------------------------\n// Switch to high quality if you have no fear!\n// ---------------------------------------------------------------------------------\n//#define HIGH_QUALITY\n#define MEDIUM_QUALITY\n//#define LOW_QUALITY\n\n#ifdef HIGH_QUALITY\n    #define SCALE_FACTOR 1. \n    #define RAYTRACED_WATER 1 \n#endif\n\n#ifdef MEDIUM_QUALITY\n    #define SCALE_FACTOR 1. \n    #define RAYTRACED_WATER 0\n#endif\n\n#ifdef LOW_QUALITY\n    #define SCALE_FACTOR 2. \n    #define RAYTRACED_WATER 0 \n#endif\n\n\n\n\n#define saturate(x) clamp(x,0.,1.)\n#define PI 3.141592653589\n#define GOLDEN_RATIO 0.61803398875\n#define time iTime\n#define frame iFrame\n\nvec3 sundir = normalize( vec3(.5,1.,-2.) );\n\n\n\n// ---------------------------------------------------------------------------------\n// Maths toolbox\n// ---------------------------------------------------------------------------------\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nvec3 hash3(vec3 p) {\n    uvec3 x = uvec3(p*100000.+1000.);\n    const uint k = 1103515245U; \n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec3 cosineDirection( vec3 p, in vec3 n)\n{\n    vec3 rnd = hash3(p+11.);\n\n    float a = 6.2831853 * rnd.y;\n    rnd.x = 2.0*rnd.x - 1.0;\n    return normalize( n + vec3(sqrt(1.0-rnd.x*rnd.x) * vec2(cos(a), sin(a)), rnd.x) );\n\n}\n\n// Still the same noise function from \"La calanque\"\n//Thx to Las^Mercury\nfloat noise(vec3 p)\n{\n    vec3 i = floor(p);\n    vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n    vec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n    a = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n    a.xy = mix(a.xz, a.yw, f.y);\n    return mix(a.x, a.y, f.z)*.5+.5;\n}\n\n\n// ---------------------------------------------------------------------------------\n// Triplanar mapping + bump mapping! \n// clever code taken from Shane\n// https://www.shadertoy.com/view/MscSDB\n// ---------------------------------------------------------------------------------\nvec3 tex3D( sampler2D tex, vec3 p, vec3 n )\n{\n    n = abs(n);\n    vec4 col = texture(tex, p.yz)*n.x + texture(tex, p.xz)*n.y + texture(tex, p.xy)*n.z;\n    return pow(col.rgb,vec3(2.2));\n}\nvec3 bumpMapping( sampler2D tex, vec3 p, vec3 n, float bf )\n{\n    const vec2 e = vec2(0.001, 0);\n    \n    mat3 m = mat3( tex3D(tex, p - e.xyy, n).rgb,\n                   tex3D(tex, p - e.yxy, n).rgb,\n                   tex3D(tex, p - e.yyx, n).rgb);\n    \n    vec3 g = vec3(0.299, 0.587, 0.114) * m;\n    g = (g - dot( tex3D(tex,  p , n).rgb, vec3(0.299, 0.587, 0.114)) )/e.x;\n    g -= n * dot(n, g);\n                      \n    return normalize( n + g*bf );\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------\n// Water heightmap + caustic pass\n// I don't remember from where this code from... it's not mine for sure!\n// ---------------------------------------------------------------------------------\n\n#define DRAG_MULT 0.048\n\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n    float x = dot(direction, position) * frequency + timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\nfloat getwaves(vec2 position, int iterations, float weight, float speed){\n    float iter = 0.0;\n    float phase = 6.0;\n    float w = 0.0;\n    float ws = 0.0;\n    for(int i=0;i<iterations;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        vec2 res = wavedx(position, p, speed, phase, time);\n        position += normalize(p) * res.y * weight * DRAG_MULT;\n        w += res.x * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2);\n        phase *= 1.18;\n        speed *= 1.07;\n    }\n    return w / ws;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = fragCoord * invRes;\n    \n    float wave = getwaves(uv*15.,10,1., 0.5);\n    float caustic = pow(getwaves(uv*15.,10, 5., 1.), 5.);\n    fragColor = vec4(wave, caustic, 0., 0.);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------\n// Raytracing pass\n// ---------------------------------------------------------------------------------\n\n\n\n\n// ---------------------------------------------------------------------------------\n// Signed Distance Field\n// ---------------------------------------------------------------------------------\nfloat terrain(vec3 p) {\n    \n    float d = length(abs(p.xy)+vec2(-220.,50.))-200.;\n    d = min(d, length(p.zy-vec2(-10.,60.))-50.+cos(p.x*.04)*10.);\n    d = min(d, length(p.zy-vec2(-400.,0.))-150.);\n    d = min(d, length(p.zy-vec2(400.,0.))-150.);\n    d = d*.2  + noise(p*.04-.9)*10. - noise(p*.2)*0.9+.5;\n    d = min(d, p.y*.5 + d);\n    return d;\n}\nfloat water(vec3 p) {\n#if RAYTRACED_WATER\n    return p.y - texture(iChannel2,p.xz*.01-.5).r;\n#else\n    return p.y;\n#endif\n}\n\nfloat map(vec3 p) {\n    float d1 = terrain(p);\n    float d2 = water(p);\n    float d = min(d1,d2);\n    return d;\n    \n}\n\n\n// ---------------------------------------------------------------------------------\n// Raytracing toolbox\n// ---------------------------------------------------------------------------------\n#define ZERO (min(iFrame,0)) // skip unroll loop\n\nvec3 raymarch(vec3 ro, vec3 rd, const vec2 nf) {\n    vec3 p = ro + rd * nf.x;\n    float l = 0.;\n    for(int i=ZERO; i<180; i++) {\n        float d = map(p)*2.;\n        l += d;\n        p += rd * d;\n        \n        if(abs(d)<.05 || l > nf.y)\n            break;\n    }\n    \n    return p;\n}\n\nvec3 normal( vec3 p )\n{\n    const float h = 0.1;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h);\n    }\n    return normalize(n);\n}\n\n\nvec3 raymarchUnderwater(vec3 ro, vec3 rd, const vec2 nf) {\n    vec3 p = ro + rd * nf.x;\n    float l = 0.;\n    for(int i=ZERO; i<64; i++) {\n        float d = terrain(p)*2.;\n        l += d;\n        p += rd * d;\n        \n        if(abs(d)<.05 || l > nf.y)\n            break;\n    }\n    \n    return p;\n}\n// Simplified version of https://www.shadertoy.com/view/4sdGWN - http://www.aduprat.com/portfolio/?page=articles/hemisphericalSDFAO\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n    const int nbIte = 6;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv;\n    \n    float ao = 0.0;\n    \n    for( int i=ZERO+1; i<nbIte; i++ )\n    {\n        float l = float(i)/float(nbIte)*maxDist;\n        vec3 rd = cosineDirection(p,n)*l;\n        \n        ao += (l - max(terrain( p + rd ),0.)) / maxDist * falloff;\n    }\n    \n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n// iq Soft Shadow - https://iquilezles.org/articles/rmshadows\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = terrain(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n// ---------------------------------------------------------------------------------\n// Shading\n// ---------------------------------------------------------------------------------\nvec3 sky( in vec3 rd )\n{\n    return mix(vec3(1.), vec3(0.2,.6,1.)*.5, 1.-exp(-rd.y*3.));\n}\n\nvec3 shade(vec3 ro, vec3 rd, vec3 p, vec3 n) {\n    float d = map(p);\n    \n    if (d > 3.) return sky(rd);\n    \n    vec3 albedo = tex3D(iChannel1,p*0.05,n)*.5;\n    //albedo = mix(albedo, vec3(1.)*sqrt(dot(albedo,albedo)), 0.2);\n    albedo *= mix(vec3(1.), vec3(1.,1.,0.3), smoothstep(0.6,1.,n.y)*smoothstep(0.0,2.,p.y));\n    n = bumpMapping(iChannel1,p*.05,n,.08);\n\n    // inspired by https://iquilezles.org/articles/outdoorslighting\n    float shad = shadow(p,sundir, .5,150., 50.);\n    float ao = pow(ambientOcclusion(p,n, 40.,2.7),1.25);\n    \n    vec3 diff = vec3(1.,.7,.3) * max(dot(n,sundir),0.) * pow(vec3(shad),vec3(1.0,1.2,1.7));\n    vec3 skyl = vec3(0.1,0.2,0.3) * (n.y*.5+.5) * ao;\n    vec3 bounce = vec3(1.,.7,.3) * max(dot( n, normalize(sundir*vec3(-1.0,0.0,-1.0))), 0.0) * ao;\n    vec3 caustic = vec3(1.) * texture(iChannel2,p.xz*0.02).g * smoothstep(50.,0.,p.y) * smoothstep(-.5,-1.,n.y) *(ao*.5+.5);\n    \n    return albedo * (diff*3. + skyl*6. + bounce*1. + caustic*2.);\n}\n\nvec3 calcPixel(vec3 ro, vec3 rd, float seed, inout vec3 firstP) {\n    \n    // Raytracing primary ray\n    vec3 p = raymarch(ro,rd, vec2(.1,600.));\n    firstP = p;\n    vec3 n = normal(p);\n    float d = map(p);\n    \n    \n    vec3 col;\n    if (terrain(p) == d) {\n        col = shade(ro,rd, p, n);\n    } else {\n    \n#if !RAYTRACED_WATER\n        n = bumpMapping(iChannel2, p*0.01-.7, n, 0.5/length(ro-p));\n#endif\n        \n        // Reflection\n        vec3 rro = p;\n        vec3 rrd = reflect(rd,n);\n        rrd = normalize(hash3(p+rand())*2.-1.+reflect(rd,n)*3000.);\n        \n        vec3 rp = raymarch(rro,rrd, vec2(.1,600.));\n        vec3 rn = normal(p);\n\n        vec3 reflectedCol = shade(rro,rrd, rp, rn);\n        \n        // Refraction\n        rro = p;\n        rrd = refract(rd,n, 1./1.33);\n        \n        rp = raymarchUnderwater(rro,rrd, vec2(.1,500.));\n        rn = normal(p);\n        vec3 refractedCol = shade(rro,rrd, rp, rn);\n        refractedCol += vec3(0.5) * pow(texture(iChannel2,rp.xz*0.02).g,2.) * smoothstep(0.,-30.,rp.y);// Add more fake caustics\n        refractedCol *= exp( -vec3(1.,.2,.1) * length(rp-p)*0.2); // Beer law for absorption! great blog post -> https://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n        \n        // Mix it with fresnel\n        float fre = pow( saturate( 1.0 + dot(n,rd)), 8.0 );\n        col = mix(refractedCol, reflectedCol , fre);\n    }\n    \n    return col;\n}\n\n// ---------------------------------------------------------------------------------\n// Entrypoint\n// ---------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = fragCoord * invRes * SCALE_FACTOR;\n    \n    if(uv.x>1. || uv.y>1. )\n    {\n        fragColor = vec4(0.);\n        return;\n    } \n    \n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    vec2 jitt = vec2(0.);\n    jitt = vec2(rand()-.5, rand()-.5) * invRes;\n    vec2 v = -1.0+2.0*(uv+jitt);\n    v.x *= iResolution.x/iResolution.y;\n    \n    \n    // Camera ray\n    vec3 ro = vec3(0.,10.,185.-time*0.1);\n    vec3 rd = normalize( vec3(v.x, v.y, -4.) );\n    \n    // Depth of field\n    float focusDistance = 80.3;\n    float blurAmount = 0.1;\n    vec3 go = blurAmount*vec3( vec2(rand(),rand())*2.-1., 0.0 );\n    vec3 gd = normalize( rd*focusDistance - go );\n    vec3 uu = vec3(1.,0.,0.);\n    vec3 vv = vec3(0.,1.,0.);\n    ro += go.x*uu + go.y*vv;\n    rd += gd.x*uu + gd.y*vv;\n    \n    // Comput color\n    vec3 p;\n    vec3 col = calcPixel(ro, rd, seed, p);\n    \n    \n    // Output with temporal accumulation\n    vec4 lastCol = texture(iChannel0,uv/SCALE_FACTOR);\n    fragColor = mix(lastCol, vec4(saturate(col), length(ro-p)), .15);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------\n// Light scattering pass\n// ---------------------------------------------------------------------------------\n\n\n// ---------------------------------------------------------------------------------\n// Signed Distance Field\n// ---------------------------------------------------------------------------------\nfloat terrain(vec3 p) {\n    \n    float d = length(abs(p.xy)+vec2(-220.,50.))-200.; // 2 cylinders \n    d = min(d, length(p.zy-vec2(-10.,60.))-50.+cos(p.x*.04)*10.);\n    d = min(d, length(p.zy-vec2(-400.,0.))-150.);\n    d = min(d, length(p.zy-vec2(400.,0.))-150.);\n    d = d*.2  + noise(p*.04-.9)*10. - noise(p*.2)*0.9+.5;\n    d = min(d, p.y*.5 + d);\n    return d;\n}\n// iq Soft Shadow - https://iquilezles.org/articles/rmshadows\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = terrain(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n// ---------------------------------------------------------------------------------\n// Scattering phase\n// ---------------------------------------------------------------------------------\nfloat phaseFunction(float lightDotView)\n{\n    const float k = .9;\n\tfloat v = 1.0 - k * k;\n\tv /= (4.0 * PI * pow(1.0 + k * k - (2.0 * k)*lightDotView, 1.5));\n\treturn v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    \n    // early exit (half resolution here)\n    vec2 uv = fragCoord * invRes * 2.;\n\tfloat l = texture(iChannel1, uv/SCALE_FACTOR).a;\n    if(uv.x>1. || uv.y>1. )\n    {\n        fragColor = vec4(0.);\n        return;\n    } \n    \n    // camera ray\n    vec2 v = -1.0+2.0*(uv);\n    v.x *= iResolution.x/iResolution.y;\n    vec3 ro = vec3(0.,10.,185.-time*0.1);\n    vec3 rd = normalize( vec3(v.x, v.y, -2.) );\n    \n    \n    \n    // blue noise jittering\n    const float eps = 0.1;\n    float jitt = fract(texture(iChannel2, fragCoord/1024.).r + float(frame)*GOLDEN_RATIO) * eps;\n    \n    // scatter loop\n    float phase = phaseFunction(dot(sundir,rd));\n    vec3 scattering = vec3(0.);\n    for(float i=jitt; i<1.; i+=eps) {\n       vec3 p = ro+rd*l*i;\n       float d = shadow(p,sundir, 2.,200., 500.);\n       scattering += d * phase;\n    }\n    \n    fragColor = mix(texture(iChannel0,uv*.5), vec4(vec3(1.,.7,.5)*scattering*.15, l), .15);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}