{
    "Shader": {
        "info": {
            "date": "1653684785",
            "description": "Integration over a single step",
            "flags": 0,
            "hasliked": 0,
            "id": "NsccRj",
            "likes": 0,
            "name": "Integration over a single step",
            "published": 3,
            "tags": [
                "integration"
            ],
            "usePreview": 0,
            "username": "Mytino",
            "viewed": 37
        },
        "renderpass": [
            {
                "code": "// From forked shader:\n// Subpixels antialiased arrow fields\n// Nicolas P. Rougier (http://www.loria.fr/~rougier)\n// Released under BSD license.\n//\n// Inspired by by \"2D vector field visualization\" by Morgan McGuire\n// (https://www.shadertoy.com/view/4s23DG)\n\n// ARROW VISUALS BEGIN\n#define ROWS 16.0\n#define COLS 16.0\nvec4 filled(float distance, float linewidth, float antialias, vec4 fill) {\n    vec4 frag_color;\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n\n    // Within linestroke\n    if( border_distance < 0.0 )\n        frag_color = fill;\n    // Within shape\n    else if( signed_distance < 0.0 )\n        frag_color = fill;\n    else\n        // Outside shape\n        if( border_distance > (linewidth/2.0 + antialias) )\n            frag_color = vec4(0.0);\n        else // Line stroke exterior border\n            frag_color = vec4(fill.rgb*alpha, 1.0);\n\n    return frag_color;\n}\nfloat segment_distance(vec2 p, vec2 p1, vec2 p2) {\n    vec2 center = (p1 + p2) * 0.5;\n    float len = length(p2 - p1);\n    vec2 dir = (p2 - p1) / len;\n    vec2 rel_p = p - center;\n    float dist1 = abs(dot(rel_p, vec2(dir.y, -dir.x)));\n    float dist2 = abs(dot(rel_p, dir)) - 0.5*len;\n    return max(dist1, dist2);\n}\nvec4 circle_from_2_points(vec2 p1, vec2 p2, float radius)\n{\n    float q = length(p2-p1);\n    vec2 m = (p1+p2)/2.0;\n    vec2 d = vec2( sqrt(radius*radius - (q*q/4.0)) * (p1.y-p2.y)/q,\n                   sqrt(radius*radius - (q*q/4.0)) * (p2.x-p1.x)/q);\n    return  vec4(m+d, m-d);\n}\nfloat arrow_curved(vec2 texcoord,\n                   float body, float head,\n                   float linewidth, float antialias)\n{\n    float w = linewidth/2.0 + antialias;\n    vec2 start = -vec2(body/2.0, 0.0);\n    vec2 end   = +vec2(body/2.0, 0.0);\n    float height = 0.5;\n\n    vec2 p1 = end - head*vec2(+1.0,+height);\n    vec2 p2 = end - head*vec2(+1.0,-height);\n    vec2 p3 = end;\n\n    // Head : 3 circles\n    vec2 c1  = circle_from_2_points(p1, p3, 1.25*body).zw;\n    float d1 = length(texcoord - c1) - 1.25*body;\n    vec2 c2  = circle_from_2_points(p2, p3, 1.25*body).xy;\n    float d2 = length(texcoord - c2) - 1.25*body;\n    vec2 c3  = circle_from_2_points(p1, p2, max(body-head, 1.0*body)).xy;\n    float d3 = length(texcoord - c3) - max(body-head, 1.0*body);\n\n    // Body : 1 segment\n    float d4 = segment_distance(texcoord, start, end - vec2(linewidth,0.0));\n\n    // Outside (because of circles)\n    if( texcoord.y > +(2.0*head + antialias) )\n         return 1000.0;\n    if( texcoord.y < -(2.0*head + antialias) )\n         return 1000.0;\n    if( texcoord.x < -(body/2.0 + antialias) )\n         return 1000.0;\n    if( texcoord.x > c1.x ) //(body + antialias) )\n         return 1000.0;\n\n    return min( d4, -min(d3,min(d1,d2)));\n}\n// ARROW VISUALS END\n\n// Velocity field function\nvec2 getVelocity(vec2 pos, vec2 res) {\n    pos = 6.0 * (pos / res - 0.5) * vec2(res.x / res.y, 1.0);\n    pos /= length(pos);\n    return vec2(-pos.y, pos.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    const float M_PI = 3.14159265358979323846;\n    const float SQRT_2 = 1.4142135623730951;\n    const float linewidth = 2.0;\n    const float antialias =  1.0;\n\n    vec2 res = iResolution.xy;\n    float body = min(iResolution.x/COLS, iResolution.y/ROWS) / SQRT_2;\n    vec2 texcoord = fragCoord.xy;\n    vec2 size   = iResolution.xy / vec2(COLS,ROWS);\n    vec2 center = (floor(texcoord/size) + vec2(0.5,0.5)) * size;\n    texcoord -= center;\n\n    vec2 vR = getVelocity(center, res);\n    vR.y *= -1.0;\n    texcoord = vec2(vR.x*texcoord.x - vR.y*texcoord.y,\n                    vR.y*texcoord.x + vR.x*texcoord.y);\n    float d = arrow_curved(texcoord, body, 0.25*body, linewidth, antialias);\n\n    fragColor = filled(d, linewidth, antialias, vec4(1,1,1,1));\n    fragColor.rgb *= 0.35;\n    \n    //// NEW STUFF:\n    \n    float dt = 50.0;\n    float flip = float(iMouse.z <= 0.5) * 2.0 - 1.0;\n    dt *= mod(iTime, 10.0) * flip;\n    vec2 delta = iResolution.xy * vec2(-0.1, 0.25);\n    vec2 forwardPos = vec2(iResolution.xy * 0.5 + delta);\n    vec2 pos = forwardPos;\n    \n    vec2 s1 = pos;\n    vec2 v1 = getVelocity(s1, res);\n    vec2 s2 = pos + 0.5 * v1 * dt;\n    vec2 v2 = getVelocity(s2, res);\n    vec2 s3 = pos + 0.5 * v2 * dt;\n    vec2 v3 = getVelocity(s3, res);\n    vec2 s4 = pos + v3 * dt;\n    vec2 v4 = getVelocity(s4, res);\n    \n    vec2 posEuler = pos + v1 * dt;\n    vec2 posMidpoint = pos + v2 * dt;\n    vec2 posRk4 = pos + ((v1 + 2.0 * v2 + 2.0 * v3 + v4) / 6.0) * dt;\n    \n    float dist = length(res*0.5 - fragCoord.xy);\n    fragColor = mix(fragColor, vec4(1, 1, 0, 1.0)*0.4, float(dist > length(delta) - 0.5 && dist < length(delta) + 0.5));\n    \n    if (iMouse.z > 0.5) {\n        \n        pos = fragCoord.xy;\n        \n        s1 = pos;\n        v1 = getVelocity(s1, res);\n        s2 = pos + 0.5 * v1 * dt;\n        v2 = getVelocity(s2, res);\n        s3 = pos + 0.5 * v2 * dt;\n        v3 = getVelocity(s3, res);\n        s4 = pos + v3 * dt;\n        v4 = getVelocity(s4, res);\n        \n        posEuler = pos + v1 * dt;\n        posMidpoint = pos + v2 * dt;\n        posRk4 = pos + ((v1 + 2.0 * v2 + 2.0 * v3 + v4) / 6.0) * dt;\n    \n        // Visualize flow map VFX\n        if (iMouse.x/res.x > 0.75) {\n            fragColor.r += texture(iChannel0, posEuler.xy / res).r * 0.5;\n            fragColor.gb += texture(iChannel0, posRk4.xy / res).gg * 1.0;\n        } else if (iMouse.x/res.x > 0.5) {\n            fragColor.rgb += texture(iChannel0, posRk4.xy / res).rgb * 0.5;\n        } else if (iMouse.x/res.x > 0.25) {\n            fragColor.rgb += texture(iChannel0, posMidpoint.xy / res).rgb * 0.5;\n        } else {\n            fragColor.rgb += texture(iChannel0, posEuler.xy / res).rgb * 0.5;\n        }\n        \n        // Show how the start positions appear to move when this backward approach is used.\n        fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 1.0), float(length(posEuler - forwardPos) < 7.0));\n        fragColor = mix(fragColor, vec4(0.0, 1.0, 0.0, 1.0), float(length(posMidpoint - forwardPos) < 7.0));\n        fragColor = mix(fragColor, vec4(0.0, 0.3, 1.0, 1.0), float(length(posRk4 - forwardPos) < 7.0));\n        \n    } else {\n    \n        fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 1.0), float(length(posEuler - fragCoord.xy) < 7.0));\n        fragColor = mix(fragColor, vec4(0.0, 1.0, 0.0, 1.0), float(length(posMidpoint - fragCoord.xy) < 7.0));\n        fragColor = mix(fragColor, vec4(0.0, 0.3, 1.0, 1.0), float(length(posRk4 - fragCoord.xy) < 7.0));\n\n        if (iMouse.x > res.x / 3.0) {\n            fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 1.0), float(length(s1 - fragCoord.xy) < 3.0));\n            fragColor = mix(fragColor, vec4(0.0, 1.0, 0.0, 1.0), float(length(s2 - fragCoord.xy) < 3.0));\n            fragColor = mix(fragColor, vec4(0.0, 0.0, 0.6, 1.0), float(length(s3 - fragCoord.xy) < 3.0));\n            fragColor = mix(fragColor, vec4(0.0, 0.3, 1.0, 1.0), float(length(s4 - fragCoord.xy) < 3.0));\n\n            if (iMouse.x > res.x / 3.0 * 2.0) {\n                fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 1.0), float(abs(length(s1 + v1*dt - fragCoord.xy) - 6.0) < 2.0));\n                fragColor = mix(fragColor, vec4(0.0, 1.0, 0.0, 1.0), float(abs(length(s2 + v2*dt - fragCoord.xy) - 6.0) < 2.0));\n                fragColor = mix(fragColor, vec4(0.0, 0.0, 0.6, 1.0), float(abs(length(s3 + v3*dt - fragCoord.xy) - 6.0) < 2.0));\n                fragColor = mix(fragColor, vec4(0.0, 0.3, 1.0, 1.0), float(abs(length(s4 + v4*dt - fragCoord.xy) - 6.0) < 2.0));\n            }\n\n        }\n    }\n    \n    //fragColor = vec4(fragCoord.xy / iResolution.xy, 0.0, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}