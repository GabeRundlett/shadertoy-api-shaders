{
    "Shader": {
        "info": {
            "date": "1528584751",
            "description": "Click and drag to rotate camera",
            "flags": 0,
            "hasliked": 0,
            "id": "MdyBzw",
            "likes": 18,
            "name": "Columns and Arches",
            "published": 3,
            "tags": [
                "raytracing",
                "architecture",
                "interior"
            ],
            "usePreview": 0,
            "username": "ChrisK",
            "viewed": 722
        },
        "renderpass": [
            {
                "code": "//quick hack to loop every 16 seconds (fix problems occuring when shader runs for several minutes)\n#define iTime mod(iTime, 16.0)\n\n#define PI\t\t\t3.14159265359\n#define HALF_PI\t\t1.57079632679\n#define TAU     \t6.28318530718\n\n#define FAST_TRACE\n\n#define CEILING_HEIGHT\t\t\t5.0\n#define COLUMN_DIST\t\t\t\t7.5\n#define MAT_COL\t\t\t\t\tvec3(0.5, 0.4, 0.35)\n\n#define FOV\t\t\t\t\t\tHALF_PI\n#define CAMERA_HEIGHT\t\t\t2.0\n#define Z_OFFSET\t\t\t\tiTime*COLUMN_DIST*0.25\n\n#define DRAW_LIGHT\n#define LIGHT_POSITION\t\t\tvec3( sin(iTime*PI*0.125)*COLUMN_DIST*2.0, 2.0, 20.0+Z_OFFSET )\n#define SHADOW_HARDNESS\t\t\t50.0\n\n#define FOG_NEAR\t\t\t\t50.0\n#define FOG_COL\t\t\t\t\tvec3(0.02, 0.03, 0.04)\n\n#define MAX_STEPS_PER_RAY   \t200\n#define MAX_RAY_LENGTH     \t\t150.0\n#define EPSILON\t\t\t\t\t0.00001\n#define SHADOW_ERROR\t\t\t0.05\n\n//#define DEBUG\n\n\n///////////////////////////////////////////////////////////////////////////////////////\n//\tMODEL\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t\t \t\t //\n///////////////////////////////////////////////////////////////////////////////////////\n\n//displacements (use in place of 'p' in distance function)\nvec3 repeat ( vec3 p, vec3 d ) {\n    return mod(p+d*0.5,d)-d*0.5;\n}\n\n\n//primatives\nfloat ubox ( vec3 p, vec3 l ) {\n    return length(max(abs(p)-l,0.0));\n}\n\n\nfloat ybar ( vec3 p, vec2 l ) {\n    vec2 d=abs(p.xz)-l;\n    return min(max(d.x,d.y),0.0)+length(max(d,0.0));\n}\n\n\nfloat ycylinder ( vec3 p, float r, float l ) {\n    return max(length(p.xz)-r,abs(p.y)-l);\n}\n\n\nfloat torus ( vec3 p, float ra, float rb ) {\n    return length(vec2(length(p.xz)-ra, p.y))-rb;\n}\n\n\n//scene (low quality to accelerate casting with FAST_TRACE)\nfloat modellq ( vec3 p ) {\n    p.x+=COLUMN_DIST*0.5;\n    vec3 pr = repeat( p, vec3(COLUMN_DIST,0.0,COLUMN_DIST) );\n    return min( ybar(pr,vec2(0.7)), min( CEILING_HEIGHT-p.y, p.y ));\n}\n\n\n//scene\nfloat model ( vec3 p ) {\n    float hr = COLUMN_DIST*0.5;\n    p.x+=hr;\n    \n    //pillars\n    vec3 pr = repeat( p, vec3(COLUMN_DIST,0.0,COLUMN_DIST) );\n    float pillar = ycylinder( pr, 0.5, CEILING_HEIGHT );\n    pillar = min( pillar, \t   ubox( pr-vec3(0.0,CEILING_HEIGHT-0.25,0.0), vec3(0.6,0.25,0.6) )-0.01 );\n    pillar = min( pillar, \t   ubox( pr-vec3(0.0,CEILING_HEIGHT-0.05,0.0), vec3(0.6,0.0,0.6) )-0.05 );\n    pillar = min( pillar, ycylinder( pr-vec3(0.0,CEILING_HEIGHT-0.65,0.0), 0.55, 0.2 ) );\n    pillar = min( pillar, \t  torus( pr-vec3(0.0,CEILING_HEIGHT-0.55,0.0), 0.55, 0.05 ) );\n    pillar = max( pillar, \t -torus( pr-vec3(0.0,CEILING_HEIGHT-0.70,0.0), 0.55, 0.05 ) );\n    pillar = min( pillar, ubox( pr, vec3(0.55,0.4,0.55) )-0.01 );\n    pillar = min( pillar, ubox( pr, vec3(0.65,0.2,0.65) )-0.01 );\n    pillar = min( pillar, ubox( pr+vec3(0.0,-0.45,0.0), vec3(0.55,0.0,0.55) )-0.05 );\n    pillar = min( pillar, ycylinder( pr+vec3(0.0,-0.6,0.0), 0.55, 0.2 ) );\n    pillar = min( pillar, torus( pr+vec3(0.0,-0.7,0.0), 0.55, 0.05 ) );\n    pillar = max( pillar, -torus( pr+vec3(0.0,-0.6,0.0), 0.55, 0.05 ) );\n    \n    //ceiling\n    float ch = p.y-CEILING_HEIGHT+1.0;\t\t\t//ceiling arch center height\n    float pxr = mod(p.x,COLUMN_DIST)-hr;\n    float pzr = mod(p.z,COLUMN_DIST)-hr;\n    float ceiling = COLUMN_DIST*0.7-0.4-sqrt( ch*ch + min( pzr*pzr, pxr*pxr ) );\n    float archestrim = max( ceiling-COLUMN_DIST*0.2, -ybar( vec3(pxr,p.y,pzr), vec2(hr-0.4)) );\n    ceiling = min( ceiling, archestrim );\n    ceiling = max( ceiling, CEILING_HEIGHT-p.y );\n\n    return min( min( ceiling, pillar ), p.y );\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n//\tMATH\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 xrotate (vec3 p, float r) { return vec3( p.x, p.y*cos(r)-p.z*sin(r), p.y*sin(r)+p.z*cos(r) ); }\nvec3 yrotate (vec3 p, float r) { return vec3( p.x*cos(r)+p.z*sin(r), p.y, -p.x*sin(r)+p.z*cos(r) ); }\nvec3 zrotate (vec3 p, float r) { return vec3( p.x*cos(r)-p.y*sin(r), p.x*sin(r)+p.y*cos(r), p.z ); }\n\n\nfloat calcintersection ( vec3 ro, vec3 rd ) {\n\t//use sphere tracing to advance along ray\n\tfloat h = 100.0;\n\tfloat d = 0.0;\n    int i = 0;\n    \n    #ifdef FAST_TRACE\n    while ( i<MAX_STEPS_PER_RAY/2 && h>EPSILON*50.0 && d<MAX_RAY_LENGTH ) {\n\t\th = modellq( ro+rd*d );\n        d += h;\n        i++;\n\t}\n    h = 100.0;\n    #endif\n    \n    while ( i<MAX_STEPS_PER_RAY && h>EPSILON && d<MAX_RAY_LENGTH ) {\n\t\th = model( ro+rd*d );\n        d += h;\n        i++;\n\t}\n\treturn d<MAX_RAY_LENGTH ? d : -1.0;\n}\n\n\nfloat lightintersection( vec3 ro, vec3 rd, float rad ) {\n\tvec3 oc = ro - LIGHT_POSITION;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\treturn h<0.0 ? -1.0 : -b-sqrt(h);\n}\n\n\nfloat softshadow( vec3 ro, vec3 rd, float ldist ) {  \n    float res = 1.0;\n    float dmin = SHADOW_ERROR;\n    for( float t=dmin; t<ldist-dmin; ) {\n        float h = model(ro + rd*t);\n        if( h<SHADOW_ERROR*0.001 )\n            return 0.0;\t\t\t\t//full shadow - break early\n        res = min( res, SHADOW_HARDNESS*h/t );\n        t += h;\n    }\n    return res*res*(3.0-2.0*res);\n}\n\n\nvec3 getdata ( vec3 ro, vec3 rd ) {\n\tfloat h = 100.0;\n\tfloat d = 0.0;\n    int steps = 0;\n    \n    #ifdef FAST_TRACE\n    while ( steps<MAX_STEPS_PER_RAY/2 && h>EPSILON*50.0 && d<MAX_RAY_LENGTH ) {\n\t\th = modellq( ro+rd*d );\n        d += h;\n        steps++;\n\t}\n    h = 100.0;\n    #endif\n    \n    while ( steps<MAX_STEPS_PER_RAY && h>EPSILON && d<MAX_RAY_LENGTH ) {\n\t\th = model( ro+rd*d );\n        d += h;\n        steps++;\n\t}\n    \n\treturn vec3(d<MAX_RAY_LENGTH ? d : -1.0, steps, h);\n}\n\n\nvec3 getnormal ( vec3 p ) {\n\tconst float e = EPSILON*10.0;  //should be larger for smooth curves, smaller for fine geometric details\n\tvec3 nor = vec3( model( p - vec3(e,0.0,0.0) ),\n\t\t\t\t\t model( p - vec3(0.0,e,0.0) ),\n\t\t\t\t\t model( p - vec3(0.0,0.0,e) ) );\n\treturn normalize( vec3(model(p)) - nor );\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n//\tRENDERING\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 getrendersample ( vec3 ro, vec3 rd ) {\n    \n    float rl = calcintersection( ro, rd );\n    \n    #ifdef DRAW_LIGHT\n    float ll = lightintersection(ro, rd, 0.25);\n    if (ll>-0.5 && (ll<rl || rl<-0.5) ) return vec3(100.0);\t\t\t\t\t\t\t//draw light source\n    #endif\n    \n    if ( rl > -0.5 ) {\n        //draw object\n\t\tvec3 xyz = ro + rd*rl;\n\t\tvec3 nor = getnormal( xyz );\n        \n        vec3 ld = normalize(LIGHT_POSITION-xyz);\n        float ldist = distance(xyz,LIGHT_POSITION);\n        float li = 100.0/(ldist*ldist);\n\n        float diff = max(dot(ld,nor),0.0);\t\t\t\t\t\t\t\t\t\t\t//Lambertian diffuse\n        \n        vec3 hv = normalize(ld-rd);\n        float m = 0.3;\n        float a = acos(dot(nor,hv));\n        float ta = tan(a);\n        float ca = cos(a);\n        float spec = exp(-(ta*ta)/(m*m))/(PI*m*m*ca*ca*ca*ca);\t\t\t\t\t\t//Beckmann specular\n        //float spec = max( pow( dot(nor,hv), 50.0 ), 0.00001 );\t\t\t\t\t\t//Blinn-Phong specular\n        \n        vec3 c = mix( diff*MAT_COL, vec3(spec), 0.05)*li;\n        if(c.r>0.0)\n            c *= softshadow(xyz, ld, ldist);\t\t\t\t\t\t\t\t\t\t//soft shadows\n        \n        c += MAT_COL*MAT_COL*100.0/((ldist+COLUMN_DIST*2.0)*(ldist+COLUMN_DIST*2.0));\t\t//first light bounce approximation\n        c += MAT_COL*MAT_COL*MAT_COL*100.0/((ldist+COLUMN_DIST*4.0)*(ldist+COLUMN_DIST*4.0));\t//second light bounce approximation\n        \n        c += pow(1.0-dot(nor,-rd),3.0) * 0.2 * mix(FOG_COL,MAT_COL,min(li,1.0));\t//add fresnel / rim light\n        \n        //basic fog\n        float fog = clamp( (rl-FOG_NEAR)/(MAX_RAY_LENGTH-FOG_NEAR), 0.0, 1.0);\n        c = mix(c, FOG_COL, fog);\n        \n        //c *= clamp(model(ro)*2.0, 0.0, 1.0);\t\t\t\t\t\t\t\t\t\t//fade to black when near geometry\n        \n        return c;\n\t} else {\n\t\treturn FOG_COL;\n\t}\n}\n\n\nvec3 getheatmap ( vec3 ro, vec3 rd ) {\n    vec3 gd = getdata(ro, rd);\n    \n    float steps = gd.y/float(MAX_STEPS_PER_RAY);\n    \n    if ( gd.x > -0.5 ) {\n\t\tvec3 xyz = ro + rd*gd.x;\n        vec3 ld = normalize( LIGHT_POSITION-xyz );\n        vec3 ldata = getdata( LIGHT_POSITION, -ld );\n        \n        float lightsteps = ldata.y/float(MAX_STEPS_PER_RAY);\n        float error = float(gd.z>EPSILON) + float(ldata.z>EPSILON);\n        return vec3( steps, error*0.5, lightsteps );\n\t} else {\n\t\treturn vec3( steps, 0.0, 0.0 );\n\t}\n}\n\n\nvec3 filmictonemapping( vec3 col ) {\n    float lwp = 7.0;\t\t\t//linear white point\n    float a = 0.20;\t\t\t\t//shoulder strength\n    float b = 0.30;\t\t\t\t//linear strength\n    float c = 0.85;\t\t\t\t//linear angle\n    float d = 0.15;\t\t\t\t//toe strength\n    float e = 0.02;\t\t\t\t//toe numerator\n    float f = 0.20;\t\t\t\t//toe denominator\n    \n    col = ((col*(a*col+c*b)+d*e)/(col*(a*col+b)+d*f))-e/f;\n    col/= ((lwp*(a*lwp+c*b)+d*e)/(lwp*(a*lwp+b)+d*f))-e/f;\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy*2.0 - 1.0;\t//camera-space position (-1 => 1)\n    uv.y *= iResolution.y/iResolution.x;\n    \n    float d = 1.0/tan(FOV/2.0);\t\t\t\t\t\t\t//distance from aperture/lens to picture plane\n    vec3 campos = vec3(0.0,CAMERA_HEIGHT,Z_OFFSET );\n    vec3 camray = normalize( vec3(uv,d) );\n    \n    if (iMouse.z>0.0) {\n    \tcamray = xrotate(camray, HALF_PI-iMouse.y/iResolution.y*PI);\n    \tcamray = yrotate(camray, PI+iMouse.x/iResolution.x*TAU);\n    }\n    \n    #ifdef DEBUG\n    vec3 col = getheatmap( campos, camray );\n    #else\n    vec3 col = getrendersample( campos, camray );\n    col = filmictonemapping(col);\n    #endif\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}