{
    "Shader": {
        "info": {
            "date": "1606330361",
            "description": "A 2D Light renderer that only uses 2 samples per light source (i know i lied) to create soft shadows",
            "flags": 0,
            "hasliked": 0,
            "id": "WsdfDS",
            "likes": 7,
            "name": "Sampleless lights 2D",
            "published": 3,
            "tags": [
                "light"
            ],
            "usePreview": 0,
            "username": "Daizuukee",
            "viewed": 464
        },
        "renderpass": [
            {
                "code": "struct light {\n\tvec2 sp, ep;\n    vec4 col;\n    float strength;\n};\n//constructor for lights\nlight lightc(vec2 sp, vec2 ep, vec4 col, float strength) {\n    light outp;\n    outp.sp = sp;\n    outp.ep = ep;\n    outp.col = col;\n    outp.strength = strength;\n    return outp;\n    \n}    \n//constructor for walls\n//(walls have the same properties as lights so it doesnt matter that we use struct light)\nlight lightc(vec2 sp, vec2 ep, vec4 col) {\n    light outp;\n    outp.sp = sp;\n    outp.ep = ep;\n    outp.col = col;\n    outp.strength = 1.;\n    return outp;\n    \n}\n\nbool intersects(vec2 p1, vec2 p2, vec2 p3, vec2 p4) {\n    float det, gamma, lambda;\n  det = (p2.x - p1.x) * (p4.y - p3.y) - (p4.x - p3.x) * (p2.y - p1.y);\n  if (det != 0.) {\n    lambda = ((p4.y - p3.y) * (p4.x - p1.x) + (p3.x - p4.x) * (p4.y - p1.y)) / det;\n    gamma = ((p1.y - p2.y) * (p4.x - p1.x) + (p2.x - p1.x) * (p4.y - p1.y)) / det;\n    return (-0. <= lambda && lambda <= 1.) && (-0.0003 <= gamma && gamma <= 1.0003);\n  }\n    return false;\n}\n\nvec2 intersection(vec2 p1, vec2 n1, vec2 p2, vec2 n2) {\n    float x, y;\n    float slopex1 = n1.y / n1.x;\n    float slopex2 = n2.y / n2.x;\n    float offy1 = p1.y - slopex1 * p1.x;\n    float offy2 = p2.y - slopex2 * p2.x;\n    x = -(offy1 - offy2) / (slopex1 - slopex2);\n    //anti infinity\n    if(n1.x == 0.)\n        x = p1.x;\n    if(n2.x == 0.)\n        x = p2.x;\n    \n    //we cannot use x here since x could be infinity\n    float slopey1 = n1.x / n1.y;\n    float slopey2 = n2.x / n2.y;\n    float offx1 = p1.x - slopey1 * p1.y;\n    float offx2 = p2.x - slopey2 * p2.y;\n    y = -(offx1 - offx2) / (slopey1 - slopey2);\n    //anti infinity\n    if(n1.y == 0.)\n        y = p1.y;\n    if(n2.y == 0.)\n        y = p2.y;\n    return vec2(x,y);\n\t\n}\n//from https://www.shadertoy.com/view/tt23WW\nfloat linedist(vec2 p, vec2 p1, vec2 p2) {\n    vec2 v = p1, w = p2;\n    \n    float l2 = pow(distance(w, v), 2.);\n    if(l2 == 0.0) return distance(p, v);\n    \n    float t = clamp(dot(p - v, w - v) / l2, 0., 1.);\n    vec2 j = v + t * (w - v);\n    \n    return distance(p, j);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //light lines, make sure they DONT overlap with walls\n    int lightcount = 3;\n\tlight lights[3];\n    lights[0] = lightc(vec2(0.1 + sin(iTime) / 5.,0.4 + cos(iTime) / 4.),vec2(-0.0,0.2),vec4(0,0.5,0,0),2.);\n    lights[1] = lightc(vec2(0.5 + sin(iTime) / 5.,-0.4 + cos(iTime) / 4.),vec2(0.5,-0.6),vec4(0.5,0,0,0),2.);\n    lights[2] = lightc(vec2(-0.5 + sin(iTime) / 5.,-0.4 + cos(iTime) / 4.),vec2(-0.5,-0.6),vec4(0,0,0.5,0),2.);\n    //walls, make sure they DONT overlap with lights\n    int wallcount = 2;\n    light walls[2];\n    walls[0] = lightc(vec2(-0.2,0.1),vec2(0.2,0.),vec4(1.));\n    walls[1] = lightc(vec2(-0.5,0.1),vec2(-0.4,0.5),vec4(0.4,1.,0.4,1.));\n    //color enhance (its weird but can look quite cool\n    /*\n    walls[0] = lightc(vec2(-0.2,0.1),vec2(0.2,0.),vec4(-1.));\n    walls[1] = lightc(vec2(-0.5,0.1),vec2(-0.4,0.5),vec4(-20,-4.,-2,1.));\n    */\n    //standard uv\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5;\n    //zoom (who could have guessed)\n    uv *= 5.;\n    \n    for(int i = 0; i < lightcount; i++) {\n        vec2 lsp = lights[i].sp;\n        vec2 lep = lights[i].ep;\n        vec4 col = lights[i].col * (lights[i].strength - linedist(uv,lsp,lep)) / lights[i].strength;\n        \n        for(int o = 0; o < wallcount; o++) {\n        \tvec2 wsp = walls[o].sp;\n            vec2 wep = walls[o].ep;\n            \n            vec2 bound1 = min(lsp,lep);\n            vec2 bound2 = max(lsp,lep);\n            \n            //intersections from uv to the wall edges on the light line\n            vec2 inters1 = intersection(uv,normalize(wsp-uv),lsp,normalize(lep-lsp));\n            vec2 inters2 = intersection(uv,normalize(wep-uv),lsp,normalize(lep-lsp));\n            \n            //cannot get bigger shadows than there is a light\n            vec2 p1 = clamp(inters1,bound1,bound2);\n            vec2 p2 = clamp(inters2,bound1,bound2);\n            float dist = distance(p1,p2);\n            \n            //space of light covered by a wall\n            float mult = (1. - (dist) / distance(lep,lsp));\n            \n            //honestly have no idea why this is necessary but it is\n            if(intersects(uv,uv+normalize(lsp-lep)*900.,wsp,wep) || intersects(uv,uv+normalize(lsp-lep)*-900.,wsp,wep))\n                mult = 1.-mult;\n            \n            //no walls hit\n            if(!intersects(uv,p1,wsp,wep) && !intersects(uv,p2,wsp,wep))\n                mult = 1.;\n            col *= 1.-(1.-mult) * walls[o].col;\n            \n            //light line visualization\n            if(linedist(uv,lsp,lep) < 0.01)\n                fragColor += lights[i].col;\n            \n        }\n        fragColor += col;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}