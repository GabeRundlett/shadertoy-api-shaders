{
    "Shader": {
        "info": {
            "date": "1640977302",
            "description": "the",
            "flags": 0,
            "hasliked": 0,
            "id": "NtySR1",
            "likes": 5,
            "name": "mile-long piano",
            "published": 3,
            "tags": [
                "the"
            ],
            "usePreview": 0,
            "username": "CubeyTheCube",
            "viewed": 276
        },
        "renderpass": [
            {
                "code": "#define aces_input mat3(0.59719, 0.35458, 0.04823,0.07600, 0.90834, 0.01566,0.02840, 0.13383, 0.83777)\n#define aces_output mat3(1.60475, -0.53108, -0.07367, -0.10208, 1.10813, -0.00605, -0.00327, -0.07276, 1.07602)\n#define object(sd, mat) dist = sd; if (dist < minDist) { minDist = dist; material = mat; }\n\n#define anti_aliasing 2\n\nstruct Material {\n  vec3 albedo;\n  float ior;\n};\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat sdPlane (vec3 p, vec3 n, float h) {\n  return dot(p, n) + h;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat scene ( vec3 pos, inout Material material ) {\n  float minDist = 1e10;\n  float dist;\n  vec3 col;\n  object(sdBox(pos.xyz - vec3(-1.0, 0.0, 0.0), vec3(0.5, 0.7, 1e10)), Material(vec3(0.5, 0.3, 0.0), 1.5));\n  object(sdBox(pos.xyz - vec3(-0.5, 0.0, 0.0), vec3(0.5, 0.0, 1e10)), Material(vec3(0.2), 1.0));\n  object(sdBox(vec3(pos.xy - vec2(-0.5, 0.05), mod(pos.z, 0.05) - 0.025), vec3(0.4, 0.05, 0.02)) - 0.005, Material(vec3(2.0), 2.5));\n  object(sdBox(vec3(pos.xy - vec2(-0.4, 0.15), mod(pos.z + 0.0125, 0.35) - 0.1), vec3(0.2, 0.03, 0.01)), Material(vec3(0.0), 3.5));\n  object(sdBox(vec3(pos.xy - vec2(-0.4, 0.15), mod(pos.z + 0.0625, 0.35) - 0.1), vec3(0.2, 0.03, 0.01)), Material(vec3(0.0), 3.5));\n  object(sdBox(vec3(pos.xy - vec2(-0.4, 0.15), mod(pos.z + 0.1625, 0.35) - 0.1), vec3(0.2, 0.03, 0.01)), Material(vec3(0.0), 3.5));\n  object(sdBox(vec3(pos.xy - vec2(-0.4, 0.15), mod(pos.z + 0.2125, 0.35) - 0.1), vec3(0.2, 0.03, 0.01)), Material(vec3(0.0), 3.5));\n  object(sdBox(vec3(pos.xy - vec2(-0.4, 0.15), mod(pos.z + 0.2625, 0.35) - 0.1), vec3(0.2, 0.03, 0.01)), Material(vec3(0.0), 3.5));\n  object(sdPlane(pos, vec3(0.0, 1.0, 0.0), .5), Material(int(mod(pos.x, 0.3) < 0.15) + int(mod(pos.z, 0.3) < 0.15) == 1 ? vec3(0.0) : vec3(1.0), 1.5));\n  object(sdPlane(pos, vec3(0.0, -1.0, 0.0), 3.0), Material(vec3(0.4), 1.2));\n  return minDist;\n}\n\nvec2 raymarch ( vec3 ro, vec3 rd, inout Material material ) {\n  float t = 0.0005;\n  float dist;  \n  for (int i = 0; i < 250; i++) {\n    dist = scene(ro + rd * t, material);\n    if (dist < 0.0001) {\n      break;\n    }\n    t += dist;\n  }\n  \n  return vec2(t, dist);\n}\n\nfloat raymarchShadow ( vec3 ro, vec3 rd, float maxt, float k ) {\n  float res = 1.0;\n  Material tmp;\n  for (float t = 0.0005; t < maxt; ) {\n    float h = scene(ro + rd * t, tmp);\n    if (h < 0.0001) {\n      return 0.0;\n    }\n    res = min(res, k * h / t);\n\n    t += h;\n  }\n  \n  return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)* 0.0001;\n    Material material;\n    return normalize( e.xyy*scene( pos + e.xyy, material ) + \n\t\t\t\t\t  e.yyx*scene( pos + e.yyx, material ) + \n\t\t\t\t\t  e.yxy*scene( pos + e.yxy, material ) + \n\t\t\t\t\t  e.xxx*scene( pos + e.xxx, material ) );\n}\n\nvec3 aces(in vec3 c) {\n    vec3 v = c * aces_input; // ref https://64.github.io/tonemapping/\n    vec3 b = v * (v + 0.0245786) - 0.000090537;\n    vec3 d = v * (0.983729 * v + 0.4329510) + 0.238081;\n    v = b/d;\n    return v * aces_output;\n}\n\nfloat ggxDist( in float roughness, in float cosine) {\n  float a2 = roughness * roughness * roughness * roughness;\n  float cosine2 = cosine * cosine;\n  float den = cosine2 * (a2 - 1.0) + 1.0;\n  return (a2 * (cosine > 0.0 ? 1.0 : 0.0)) / (3.14159265 * den * den);\n}\n\nfloat ggxGeometrySchlick (float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat ggxGeometrySmith(vec3 n, vec3 v, vec3 l, float roughness)\n{\n    float NdotV = max(dot(n,v), 0.0);\n    float NdotL = max(dot(n, l), 0.0);\n    float ggx2  = ggxGeometrySchlick(NdotV, roughness);\n    float ggx1  = ggxGeometrySchlick(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\n\nfloat fresnelSchlick (float ior, float cosine) {\n  float r0 = (1.0 - ior) / (1.0 + ior);\n  r0 *= r0;\n  return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);\n}\n\n\nfloat cookTorrance(vec3 toLight, vec3 normal, vec3 halfway, vec3 v, float roughness, float ior) {\n  float NDF = ggxDist(roughness, dot(normal, halfway));\n  float G = ggxGeometrySmith(normal, v, toLight, roughness);\n  float F = fresnelSchlick(ior, dot(halfway, v));\n  float numerator = NDF * G * F;\n  float denominator = 4.0 * max(dot(normal, v), 0.0) * max(dot(normal, toLight), 0.0) + 0.0001;\n  \n  return clamp(numerator / denominator, 0.0, 1.0);\n}\n\nvec3 bg(vec3 ro, vec3 rd) {\n  return vec3(0.4);\n}\n\nvec3 getCol(vec3 ro, vec3 rd, float t, Material mat, inout vec3 normal) {\n  vec3 col;\n  vec3 pos = ro + rd * t;\n  normal = calcNormal(pos);\n  vec3 light = vec3(2.0, 2.0, -1.0);\n  vec3 toLight = normalize(light - pos);\n  float shade = max(0.0, dot(normal, toLight));\n  col = shade * mat.albedo;\n  vec3 halfway = normalize(normalize(light - pos) - rd);\n  col += vec3(1.0) * vec3(cookTorrance(toLight, normal, halfway, -rd, 0.1, mat.ior));\n  \n  float shadow = raymarchShadow(pos, toLight, length(light - pos), 5.);\n  col *= shadow;\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float AA = float(anti_aliasing);\n    vec3 finalCol = vec3(0.0);\n    mat4 rot = rotationMatrix(vec3(1.0, 0.0, 0.0), 0.) * rotationMatrix(vec3(0.0, 1.0, 0.0), 0.4);\n    \n    for (float i = 0.0; i < 1.0; i += 1.0 / AA) {\n    for (float j = 0.0; j < 1.0; j += 1.0 / AA) {\n    float aspectRatio = iResolution.x / iResolution.y;\n    float fov = 89.0;\n    float Px = (2. * ((fragCoord.x + i + 0.5) / iResolution.x) - 1.) * tan(fov / 2. * 3.1415 / 180.) * aspectRatio; \n    float Py =  2. * ((fragCoord.y + j + 0.5) / iResolution.y) * tan(fov / 2. * 3.1415 / 180.0) - 1.0; \n    \n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    \n    vec3 rd = normalize((rot * vec4(Px, Py, 1.0, 1.0)).xyz);\n    vec3 ro = vec3(iMouse.xy / iResolution.xy, -2.0);\n    \n    Material material;\n    vec2 result = raymarch(ro, rd, material);\n    float t = result.x;\n    \n    vec3 col;\n    if (result.y < 0.0001) {\n      vec3 normal;\n      col = getCol(ro, rd, t, material, normal);\n      if (material.ior != 1.0) {\n        vec3 ref = reflect(rd, normal);\n        float fresnel = fresnelSchlick(material.ior, dot(ref, normal));\n        Material reflectedMaterial;\n        vec2 reflected = raymarch(ro + rd * t, ref, reflectedMaterial);\n        vec3 reflectedCol = reflected.y >= 0.0001 ? bg(ro + rd * t, ref) : getCol(ro + rd * t, ref, reflected.x, reflectedMaterial, normal);\n        col = mix(col, reflectedCol, fresnel);\n      }\n      col = aces(col);\n      col = pow(col, vec3(0.454545));\n    } else {\n      col = bg(ro, rd);\n    }\n    finalCol += col / (AA * AA);\n    }\n    }\n    \n    \n    fragColor = vec4(finalCol, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}