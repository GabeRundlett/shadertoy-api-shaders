{
    "Shader": {
        "info": {
            "date": "1614510850",
            "description": "The 'Single Rotation Rule' using a 1:1 pixel ratio by encoding/decoding the block phase and state information\nhttp://dmishin.blogspot.com/2013/11/the-single-rotation-rule\nhttps://www.reddit.com/user/slackermanz/\nhttps://www.reddit.com/r/cellular_automata\n",
            "flags": 32,
            "hasliked": 0,
            "id": "tlKBWm",
            "likes": 5,
            "name": "Packed Single Rotation Rule",
            "published": 3,
            "tags": [
                "2d",
                "simulation",
                "diffusion",
                "automata",
                "cellular",
                "rotation",
                "conway",
                "gameoflife",
                "cellularautomata",
                "single",
                "cgol",
                "singlerotation"
            ],
            "usePreview": 0,
            "username": "SlackermanzCA",
            "viewed": 575
        },
        "renderpass": [
            {
                "code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tNAME:Packed Single Rotation Rule\n//\tTYPE:Encoded Margolus Neighbourhood Block Cellular Automata\n//\tRULE:Single Rotation Rule\n//\t\thttp://dmishin.blogspot.com/2013/11/the-single-rotation-rule-remarkably.html\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 bufA = texture(iChannel0, uv);\n\n    // Output to screen\n    fragColor = bufA;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tNAME:Packed Single Rotation Rule\n//\tTYPE:Encoded Margolus Neighbourhood Block Cellular Automata\n//\tRULE:Single Rotation Rule\n//\t\thttp://dmishin.blogspot.com/2013/11/the-single-rotation-rule-remarkably.html\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define tex0_in (iChannel0)\n#define tex_size (iResolution.xy)\n\nfloat gdv(float x, float y, int v, float div) {\n//\tGet Div Value: Return the value of a specified pixel\n//\t\tx, y : \tRelative integer-spaced coordinates to origin [ 0.0, 0.0 ]\n//\t\tv\t :\tColour channel [ 0, 1, 2 ]\n//\t\tdiv\t :\tInteger-spaced number of toroidal divisions of the surface/medium\n\tvec4\tfc \t\t= gl_FragCoord;\n\tvec2 \tdm \t\t= vec2(iResolution.x, iResolution.y);\n    float \tdivx\t= dm[0] / div;\n\tfloat \tdivy\t= dm[1] / div;\n\tfloat \tpxo \t= 1.0 / dm[0];\n\tfloat \tpyo \t= 1.0 / dm[1];\n\tfloat \tfcxo \t= fc[0] + x;\n\tfloat \tfcyo \t= fc[1] + y;\n\tfloat \tfcx \t= (mod(fcxo,divx) + floor(fc[0]/divx)*divx ) * pxo;\n\tfloat \tfcy \t= (mod(fcyo,divy) + floor(fc[1]/divy)*divy ) * pyo;\n    vec4 \tpxdata \t= texture( tex0_in, vec2(fcx, fcy) );\n\treturn pxdata[v];\n}\n\nvec3 nhd( vec2 nbhd, vec2 ofst, float psn, float thr, int col, float div ) {\n//\tNeighbourhood: Return information about the specified group of pixels\n\tfloat dist \t\t= 0.0;\n\tfloat cval \t\t= 0.0;\n\tfloat c_total \t= 0.0;\n\tfloat c_valid \t= 0.0;\n\tfloat c_value \t= 0.0;\n\tfor(float i = -nbhd[0]; i <= nbhd[0]; i += 1.0) {\n\t\tfor(float j = -nbhd[0]; j <= nbhd[0]; j += 1.0) {\n\t\t\tdist = round(sqrt(i*i+j*j));\n\t\t\tif( dist <= nbhd[0] && dist > nbhd[1] && dist != 0.0 ) {\n\t\t\t\tcval = gdv(i+ofst[0],j+ofst[1],col,div);\n\t\t\t\tc_total += psn;\n\t\t\t\tif( cval > thr ) {\n\t\t\t\t\tc_valid += psn;\n\t\t\t\t\tcval = psn * cval;\n\t\t\t\t\tc_value += cval-fract(cval); } } } } \n\treturn vec3( c_value, c_valid, c_total );\n}\n\nfloat get_xc(float x, float y, float xmod) {\n//\tUsed to reseed the surface with noise\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0);\n}\nfloat shuffle(float x, float y, float xmod, float val) {\n//\tUsed to reseed the surface with noise\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val));\n}\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n//\tUsed to reseed the surface with noise\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc);\n}\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n//\tUsed to reseed the surface with noise\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf;\n}\nfloat reseed() {\n//\tUsed to reseed the surface with noise\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1], 2.0, 19.0 + mod(iDate[3],17.0), 23.0 + mod(iDate[3],43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 24.0, 13.0 + mod(iDate[3],29.0), 17.0 + mod(iDate[3],31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1], 8.0, 13.0 + mod(iDate[3],11.0), 51.0 + mod(iDate[3],37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0);\n}\nfloat margo() {\n\tfloat\tstates\t\t= 15.0;\n\tfloat\tblock_phase\t= mod(float(iFrame), 2.0);\n\n//\tGet the values of the Red Channel pixels that contain the encoded substates for the Margolus Neighbourhood\n\tfloat[4] block_neighbourhood = float[4]\n\t(\tround(gdv(-1.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv( 0.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv(-1.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv( 0.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states)\t);\n\n//\tContainers for the substates\n\tfloat[4] neighbour_0_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_1_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_2_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_3_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tDecode the substates (binary representation) of the neighbourhood pixels' values\n\tfloat m = states + 1.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tneighbour_0_substates[i] = round( mod( (block_neighbourhood[0]), m ) / (m-1.0) );\n\t\tneighbour_1_substates[i] = round( mod( (block_neighbourhood[1]), m ) / (m-1.0) );\n\t\tneighbour_2_substates[i] = round( mod( (block_neighbourhood[2]), m ) / (m-1.0) );\n\t\tneighbour_3_substates[i] = round( mod( (block_neighbourhood[3]), m ) / (m-1.0) );\n\t\tm = m / 2.0; }\n\n//\tContainer for the new/recombined substate\n\tfloat[4] new_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tGet the relevant substates\n\tnew_substates[0] = neighbour_0_substates[3];\n\tnew_substates[1] = neighbour_1_substates[2];\n\tnew_substates[2] = neighbour_2_substates[1];\n\tnew_substates[3] = neighbour_3_substates[0];\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tApply the 'Single Rotation Rule' transition\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tIf the current-phased block of substates contains only one value ...\n\tfloat sum\t= new_substates[0] \n\t\t\t\t+ new_substates[1] \n\t\t\t\t+ new_substates[2] \n\t\t\t\t+ new_substates[3];\n\n//\tContainer for the transformed substates\n    float[4] final_substates;\n        final_substates[0] = new_substates[0];\n        final_substates[1] = new_substates[1];\n        final_substates[2] = new_substates[2];\n        final_substates[3] = new_substates[3];\n\n//\tIf the condition is met, apply the transformation, remapping the substates within the block\n    if(sum == 1.0) {\n        final_substates[0] = new_substates[1];\n        final_substates[1] = new_substates[3];\n        final_substates[2] = new_substates[0];\n        final_substates[3] = new_substates[2]; }\n\n//\tAdditional transition / SRR variant\n    if(sum == 3.0) {\n        final_substates[0] = new_substates[1];\n        final_substates[1] = new_substates[3];\n        final_substates[2] = new_substates[0];\n        final_substates[3] = new_substates[2]; }\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPack the pixel from the final substate data\n\tfloat res\t= 0.0;\n\tfloat n \t= (states + 1.0) / 2.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tres = res + final_substates[i] * n;\tn = n / 2.0; }\n\tres = res / states;\n\n//\tReturn the encoded pixel value\n\treturn res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tInitilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPrecision\n\tfloat \tpsn\t\t= 250.0;\n    \n//\tMinimum Precision Value : (1.0 / psn);\n\tfloat \tmnp\t\t= 0.004;\n\n//\tGet the reference frame's origin pixel values\n\tfloat\tres_r\t= gdv( 0.0, 0.0, 0, 1.0 );\n\tfloat\tres_g\t= gdv( 0.0, 0.0, 1, 1.0 );\n\tfloat\tres_b\t= gdv( 0.0, 0.0, 2, 1.0 );\n\n//\tIntended rate of change\n\tfloat \ts \t\t= mnp * 12.0;\n\n//\tOutput value\n\tres_r = margo();\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tPresentation Filtering\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\tvec3 \tn0r \t= nhd( vec2( 4.0, 0.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, 1.0 );\n\tfloat \tn0rw \t= n0r[0] / n0r[2];\n\tres_g = (res_r > 0.0) ? res_g + mnp * 2.0 : (mod(float(iFrame),32.0) == 0.0) ? res_g - mnp * 2.0 : res_g;\n\tres_g = (n0rw > 0.06) ? res_g - mnp * 4.0 : res_g;\n\tres_b = (res_r > 0.0) ? 1.0 : res_b - mnp * 2.0;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tFragment Shader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n    \n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 24.0) { res_r = mod(float(iFrame),2.0); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 112.0) { res_r = reseed(); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 96.0) { res_r = 0.0; }\n    fragColor=vec4(clamp(res_r,0.0,1.0),clamp(res_g,0.0,1.0),clamp(res_b,0.0,1.0),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tNAME:Packed Single Rotation Rule\n//\tTYPE:Encoded Margolus Neighbourhood Block Cellular Automata\n//\tRULE:Single Rotation Rule\n//\t\thttp://dmishin.blogspot.com/2013/11/the-single-rotation-rule-remarkably.html\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define tex0_in (iChannel0)\n#define tex_size (iResolution.xy)\n\nfloat gdv(float x, float y, int v, float div) {\n//\tGet Div Value: Return the value of a specified pixel\n//\t\tx, y : \tRelative integer-spaced coordinates to origin [ 0.0, 0.0 ]\n//\t\tv\t :\tColour channel [ 0, 1, 2 ]\n//\t\tdiv\t :\tInteger-spaced number of toroidal divisions of the surface/medium\n\tvec4\tfc \t\t= gl_FragCoord;\n\tvec2 \tdm \t\t= vec2(iResolution.x, iResolution.y);\n    float \tdivx\t= dm[0] / div;\n\tfloat \tdivy\t= dm[1] / div;\n\tfloat \tpxo \t= 1.0 / dm[0];\n\tfloat \tpyo \t= 1.0 / dm[1];\n\tfloat \tfcxo \t= fc[0] + x;\n\tfloat \tfcyo \t= fc[1] + y;\n\tfloat \tfcx \t= (mod(fcxo,divx) + floor(fc[0]/divx)*divx ) * pxo;\n\tfloat \tfcy \t= (mod(fcyo,divy) + floor(fc[1]/divy)*divy ) * pyo;\n    vec4 \tpxdata \t= texture( tex0_in, vec2(fcx, fcy) );\n\treturn pxdata[v];\n}\n\nvec3 nhd( vec2 nbhd, vec2 ofst, float psn, float thr, int col, float div ) {\n//\tNeighbourhood: Return information about the specified group of pixels\n\tfloat dist \t\t= 0.0;\n\tfloat cval \t\t= 0.0;\n\tfloat c_total \t= 0.0;\n\tfloat c_valid \t= 0.0;\n\tfloat c_value \t= 0.0;\n\tfor(float i = -nbhd[0]; i <= nbhd[0]; i += 1.0) {\n\t\tfor(float j = -nbhd[0]; j <= nbhd[0]; j += 1.0) {\n\t\t\tdist = round(sqrt(i*i+j*j));\n\t\t\tif( dist <= nbhd[0] && dist > nbhd[1] && dist != 0.0 ) {\n\t\t\t\tcval = gdv(i+ofst[0],j+ofst[1],col,div);\n\t\t\t\tc_total += psn;\n\t\t\t\tif( cval > thr ) {\n\t\t\t\t\tc_valid += psn;\n\t\t\t\t\tcval = psn * cval;\n\t\t\t\t\tc_value += cval-fract(cval); } } } } \n\treturn vec3( c_value, c_valid, c_total );\n}\n\nfloat get_xc(float x, float y, float xmod) {\n//\tUsed to reseed the surface with noise\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0);\n}\nfloat shuffle(float x, float y, float xmod, float val) {\n//\tUsed to reseed the surface with noise\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val));\n}\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n//\tUsed to reseed the surface with noise\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc);\n}\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n//\tUsed to reseed the surface with noise\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf;\n}\nfloat reseed() {\n//\tUsed to reseed the surface with noise\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1], 2.0, 19.0 + mod(iDate[3],17.0), 23.0 + mod(iDate[3],43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 24.0, 13.0 + mod(iDate[3],29.0), 17.0 + mod(iDate[3],31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1], 8.0, 13.0 + mod(iDate[3],11.0), 51.0 + mod(iDate[3],37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0);\n}\nfloat margo() {\n\tfloat\tstates\t\t= 15.0;\n\tfloat\tblock_phase\t= mod(float(iFrame), 2.0);\n\n//\tGet the values of the Red Channel pixels that contain the encoded substates for the Margolus Neighbourhood\n\tfloat[4] block_neighbourhood = float[4]\n\t(\tround(gdv(-1.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv( 0.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv(-1.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv( 0.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states)\t);\n\n//\tContainers for the substates\n\tfloat[4] neighbour_0_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_1_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_2_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_3_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tDecode the substates (binary representation) of the neighbourhood pixels' values\n\tfloat m = states + 1.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tneighbour_0_substates[i] = round( mod( (block_neighbourhood[0]), m ) / (m-1.0) );\n\t\tneighbour_1_substates[i] = round( mod( (block_neighbourhood[1]), m ) / (m-1.0) );\n\t\tneighbour_2_substates[i] = round( mod( (block_neighbourhood[2]), m ) / (m-1.0) );\n\t\tneighbour_3_substates[i] = round( mod( (block_neighbourhood[3]), m ) / (m-1.0) );\n\t\tm = m / 2.0; }\n\n//\tContainer for the new/recombined substate\n\tfloat[4] new_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tGet the relevant substates\n\tnew_substates[0] = neighbour_0_substates[3];\n\tnew_substates[1] = neighbour_1_substates[2];\n\tnew_substates[2] = neighbour_2_substates[1];\n\tnew_substates[3] = neighbour_3_substates[0];\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tApply the 'Single Rotation Rule' transition\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tIf the current-phased block of substates contains only one value ...\n\tfloat sum\t= new_substates[0] \n\t\t\t\t+ new_substates[1] \n\t\t\t\t+ new_substates[2] \n\t\t\t\t+ new_substates[3];\n\n//\tContainer for the transformed substates\n    float[4] final_substates;\n        final_substates[0] = new_substates[0];\n        final_substates[1] = new_substates[1];\n        final_substates[2] = new_substates[2];\n        final_substates[3] = new_substates[3];\n\n//\tIf the condition is met, apply the transformation, remapping the substates within the block\n    if(sum == 1.0) {\n        final_substates[0] = new_substates[1];\n        final_substates[1] = new_substates[3];\n        final_substates[2] = new_substates[0];\n        final_substates[3] = new_substates[2]; }\n\n//\tAdditional transition / SRR variant\n    if(sum == 3.0) {\n        final_substates[0] = new_substates[1];\n        final_substates[1] = new_substates[3];\n        final_substates[2] = new_substates[0];\n        final_substates[3] = new_substates[2]; }\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPack the pixel from the final substate data\n\tfloat res\t= 0.0;\n\tfloat n \t= (states + 1.0) / 2.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tres = res + final_substates[i] * n;\tn = n / 2.0; }\n\tres = res / states;\n\n//\tReturn the encoded pixel value\n\treturn res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tInitilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPrecision\n\tfloat \tpsn\t\t= 250.0;\n    \n//\tMinimum Precision Value : (1.0 / psn);\n\tfloat \tmnp\t\t= 0.004;\n\n//\tGet the reference frame's origin pixel values\n\tfloat\tres_r\t= gdv( 0.0, 0.0, 0, 1.0 );\n\tfloat\tres_g\t= gdv( 0.0, 0.0, 1, 1.0 );\n\tfloat\tres_b\t= gdv( 0.0, 0.0, 2, 1.0 );\n\n//\tIntended rate of change\n\tfloat \ts \t\t= mnp * 12.0;\n\n//\tOutput value\n\tres_r = margo();\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tPresentation Filtering\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\tvec3 \tn0r \t= nhd( vec2( 4.0, 0.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, 1.0 );\n\tfloat \tn0rw \t= n0r[0] / n0r[2];\n\tres_g = (res_r > 0.0) ? res_g + mnp * 2.0 : (mod(float(iFrame),32.0) == 0.0) ? res_g - mnp * 2.0 : res_g;\n\tres_g = (n0rw > 0.06) ? res_g - mnp * 4.0 : res_g;\n\tres_b = (res_r > 0.0) ? 1.0 : res_b - mnp * 2.0;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tFragment Shader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n    \n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 24.0) { res_r = mod(float(iFrame),2.0); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 112.0) { res_r = reseed(); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 96.0) { res_r = 0.0; }\n    fragColor=vec4(clamp(res_r,0.0,1.0),clamp(res_g,0.0,1.0),clamp(res_b,0.0,1.0),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tNAME:Packed Single Rotation Rule\n//\tTYPE:Encoded Margolus Neighbourhood Block Cellular Automata\n//\tRULE:Single Rotation Rule\n//\t\thttp://dmishin.blogspot.com/2013/11/the-single-rotation-rule-remarkably.html\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define tex0_in (iChannel0)\n#define tex_size (iResolution.xy)\n\nfloat gdv(float x, float y, int v, float div) {\n//\tGet Div Value: Return the value of a specified pixel\n//\t\tx, y : \tRelative integer-spaced coordinates to origin [ 0.0, 0.0 ]\n//\t\tv\t :\tColour channel [ 0, 1, 2 ]\n//\t\tdiv\t :\tInteger-spaced number of toroidal divisions of the surface/medium\n\tvec4\tfc \t\t= gl_FragCoord;\n\tvec2 \tdm \t\t= vec2(iResolution.x, iResolution.y);\n    float \tdivx\t= dm[0] / div;\n\tfloat \tdivy\t= dm[1] / div;\n\tfloat \tpxo \t= 1.0 / dm[0];\n\tfloat \tpyo \t= 1.0 / dm[1];\n\tfloat \tfcxo \t= fc[0] + x;\n\tfloat \tfcyo \t= fc[1] + y;\n\tfloat \tfcx \t= (mod(fcxo,divx) + floor(fc[0]/divx)*divx ) * pxo;\n\tfloat \tfcy \t= (mod(fcyo,divy) + floor(fc[1]/divy)*divy ) * pyo;\n    vec4 \tpxdata \t= texture( tex0_in, vec2(fcx, fcy) );\n\treturn pxdata[v];\n}\n\nvec3 nhd( vec2 nbhd, vec2 ofst, float psn, float thr, int col, float div ) {\n//\tNeighbourhood: Return information about the specified group of pixels\n\tfloat dist \t\t= 0.0;\n\tfloat cval \t\t= 0.0;\n\tfloat c_total \t= 0.0;\n\tfloat c_valid \t= 0.0;\n\tfloat c_value \t= 0.0;\n\tfor(float i = -nbhd[0]; i <= nbhd[0]; i += 1.0) {\n\t\tfor(float j = -nbhd[0]; j <= nbhd[0]; j += 1.0) {\n\t\t\tdist = round(sqrt(i*i+j*j));\n\t\t\tif( dist <= nbhd[0] && dist > nbhd[1] && dist != 0.0 ) {\n\t\t\t\tcval = gdv(i+ofst[0],j+ofst[1],col,div);\n\t\t\t\tc_total += psn;\n\t\t\t\tif( cval > thr ) {\n\t\t\t\t\tc_valid += psn;\n\t\t\t\t\tcval = psn * cval;\n\t\t\t\t\tc_value += cval-fract(cval); } } } } \n\treturn vec3( c_value, c_valid, c_total );\n}\n\nfloat get_xc(float x, float y, float xmod) {\n//\tUsed to reseed the surface with noise\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0);\n}\nfloat shuffle(float x, float y, float xmod, float val) {\n//\tUsed to reseed the surface with noise\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val));\n}\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n//\tUsed to reseed the surface with noise\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc);\n}\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n//\tUsed to reseed the surface with noise\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf;\n}\nfloat reseed() {\n//\tUsed to reseed the surface with noise\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1], 2.0, 19.0 + mod(iDate[3],17.0), 23.0 + mod(iDate[3],43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 24.0, 13.0 + mod(iDate[3],29.0), 17.0 + mod(iDate[3],31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1], 8.0, 13.0 + mod(iDate[3],11.0), 51.0 + mod(iDate[3],37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0);\n}\nfloat margo() {\n\tfloat\tstates\t\t= 15.0;\n\tfloat\tblock_phase\t= mod(float(iFrame), 2.0);\n\n//\tGet the values of the Red Channel pixels that contain the encoded substates for the Margolus Neighbourhood\n\tfloat[4] block_neighbourhood = float[4]\n\t(\tround(gdv(-1.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv( 0.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv(-1.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv( 0.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states)\t);\n\n//\tContainers for the substates\n\tfloat[4] neighbour_0_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_1_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_2_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_3_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tDecode the substates (binary representation) of the neighbourhood pixels' values\n\tfloat m = states + 1.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tneighbour_0_substates[i] = round( mod( (block_neighbourhood[0]), m ) / (m-1.0) );\n\t\tneighbour_1_substates[i] = round( mod( (block_neighbourhood[1]), m ) / (m-1.0) );\n\t\tneighbour_2_substates[i] = round( mod( (block_neighbourhood[2]), m ) / (m-1.0) );\n\t\tneighbour_3_substates[i] = round( mod( (block_neighbourhood[3]), m ) / (m-1.0) );\n\t\tm = m / 2.0; }\n\n//\tContainer for the new/recombined substate\n\tfloat[4] new_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tGet the relevant substates\n\tnew_substates[0] = neighbour_0_substates[3];\n\tnew_substates[1] = neighbour_1_substates[2];\n\tnew_substates[2] = neighbour_2_substates[1];\n\tnew_substates[3] = neighbour_3_substates[0];\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tApply the 'Single Rotation Rule' transition\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tIf the current-phased block of substates contains only one value ...\n\tfloat sum\t= new_substates[0] \n\t\t\t\t+ new_substates[1] \n\t\t\t\t+ new_substates[2] \n\t\t\t\t+ new_substates[3];\n\n//\tContainer for the transformed substates\n    float[4] final_substates;\n        final_substates[0] = new_substates[0];\n        final_substates[1] = new_substates[1];\n        final_substates[2] = new_substates[2];\n        final_substates[3] = new_substates[3];\n\n//\tIf the condition is met, apply the transformation, remapping the substates within the block\n    if(sum == 1.0) {\n        final_substates[0] = new_substates[1];\n        final_substates[1] = new_substates[3];\n        final_substates[2] = new_substates[0];\n        final_substates[3] = new_substates[2]; }\n\n//\tAdditional transition / SRR variant\n    if(sum == 3.0) {\n        final_substates[0] = new_substates[1];\n        final_substates[1] = new_substates[3];\n        final_substates[2] = new_substates[0];\n        final_substates[3] = new_substates[2]; }\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPack the pixel from the final substate data\n\tfloat res\t= 0.0;\n\tfloat n \t= (states + 1.0) / 2.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tres = res + final_substates[i] * n;\tn = n / 2.0; }\n\tres = res / states;\n\n//\tReturn the encoded pixel value\n\treturn res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tInitilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPrecision\n\tfloat \tpsn\t\t= 250.0;\n    \n//\tMinimum Precision Value : (1.0 / psn);\n\tfloat \tmnp\t\t= 0.004;\n\n//\tGet the reference frame's origin pixel values\n\tfloat\tres_r\t= gdv( 0.0, 0.0, 0, 1.0 );\n\tfloat\tres_g\t= gdv( 0.0, 0.0, 1, 1.0 );\n\tfloat\tres_b\t= gdv( 0.0, 0.0, 2, 1.0 );\n\n//\tIntended rate of change\n\tfloat \ts \t\t= mnp * 12.0;\n\n//\tOutput value\n\tres_r = margo();\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tPresentation Filtering\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\tvec3 \tn0r \t= nhd( vec2( 4.0, 0.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, 1.0 );\n\tfloat \tn0rw \t= n0r[0] / n0r[2];\n\tres_g = (res_r > 0.0) ? res_g + mnp * 2.0 : (mod(float(iFrame),32.0) == 0.0) ? res_g - mnp * 2.0 : res_g;\n\tres_g = (n0rw > 0.06) ? res_g - mnp * 4.0 : res_g;\n\tres_b = (res_r > 0.0) ? 1.0 : res_b - mnp * 2.0;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tFragment Shader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n    \n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 24.0) { res_r = mod(float(iFrame),2.0); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 112.0) { res_r = reseed(); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 96.0) { res_r = 0.0; }\n    fragColor=vec4(clamp(res_r,0.0,1.0),clamp(res_g,0.0,1.0),clamp(res_b,0.0,1.0),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tNAME:Packed Single Rotation Rule\n//\tTYPE:Encoded Margolus Neighbourhood Block Cellular Automata\n//\tRULE:Single Rotation Rule\n//\t\thttp://dmishin.blogspot.com/2013/11/the-single-rotation-rule-remarkably.html\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define tex0_in (iChannel0)\n#define tex_size (iResolution.xy)\n\nfloat gdv(float x, float y, int v, float div) {\n//\tGet Div Value: Return the value of a specified pixel\n//\t\tx, y : \tRelative integer-spaced coordinates to origin [ 0.0, 0.0 ]\n//\t\tv\t :\tColour channel [ 0, 1, 2 ]\n//\t\tdiv\t :\tInteger-spaced number of toroidal divisions of the surface/medium\n\tvec4\tfc \t\t= gl_FragCoord;\n\tvec2 \tdm \t\t= vec2(iResolution.x, iResolution.y);\n    float \tdivx\t= dm[0] / div;\n\tfloat \tdivy\t= dm[1] / div;\n\tfloat \tpxo \t= 1.0 / dm[0];\n\tfloat \tpyo \t= 1.0 / dm[1];\n\tfloat \tfcxo \t= fc[0] + x;\n\tfloat \tfcyo \t= fc[1] + y;\n\tfloat \tfcx \t= (mod(fcxo,divx) + floor(fc[0]/divx)*divx ) * pxo;\n\tfloat \tfcy \t= (mod(fcyo,divy) + floor(fc[1]/divy)*divy ) * pyo;\n    vec4 \tpxdata \t= texture( tex0_in, vec2(fcx, fcy) );\n\treturn pxdata[v];\n}\n\nvec3 nhd( vec2 nbhd, vec2 ofst, float psn, float thr, int col, float div ) {\n//\tNeighbourhood: Return information about the specified group of pixels\n\tfloat dist \t\t= 0.0;\n\tfloat cval \t\t= 0.0;\n\tfloat c_total \t= 0.0;\n\tfloat c_valid \t= 0.0;\n\tfloat c_value \t= 0.0;\n\tfor(float i = -nbhd[0]; i <= nbhd[0]; i += 1.0) {\n\t\tfor(float j = -nbhd[0]; j <= nbhd[0]; j += 1.0) {\n\t\t\tdist = round(sqrt(i*i+j*j));\n\t\t\tif( dist <= nbhd[0] && dist > nbhd[1] && dist != 0.0 ) {\n\t\t\t\tcval = gdv(i+ofst[0],j+ofst[1],col,div);\n\t\t\t\tc_total += psn;\n\t\t\t\tif( cval > thr ) {\n\t\t\t\t\tc_valid += psn;\n\t\t\t\t\tcval = psn * cval;\n\t\t\t\t\tc_value += cval-fract(cval); } } } } \n\treturn vec3( c_value, c_valid, c_total );\n}\n\nfloat get_xc(float x, float y, float xmod) {\n//\tUsed to reseed the surface with noise\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0);\n}\nfloat shuffle(float x, float y, float xmod, float val) {\n//\tUsed to reseed the surface with noise\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val));\n}\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n//\tUsed to reseed the surface with noise\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc);\n}\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n//\tUsed to reseed the surface with noise\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf;\n}\nfloat reseed() {\n//\tUsed to reseed the surface with noise\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1], 2.0, 19.0 + mod(iDate[3],17.0), 23.0 + mod(iDate[3],43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 24.0, 13.0 + mod(iDate[3],29.0), 17.0 + mod(iDate[3],31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1], 8.0, 13.0 + mod(iDate[3],11.0), 51.0 + mod(iDate[3],37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0);\n}\nfloat margo() {\n\tfloat\tstates\t\t= 15.0;\n\tfloat\tblock_phase\t= mod(float(iFrame), 2.0);\n\n//\tGet the values of the Red Channel pixels that contain the encoded substates for the Margolus Neighbourhood\n\tfloat[4] block_neighbourhood = float[4]\n\t(\tround(gdv(-1.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv( 0.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv(-1.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv( 0.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states)\t);\n\n//\tContainers for the substates\n\tfloat[4] neighbour_0_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_1_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_2_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_3_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tDecode the substates (binary representation) of the neighbourhood pixels' values\n\tfloat m = states + 1.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tneighbour_0_substates[i] = round( mod( (block_neighbourhood[0]), m ) / (m-1.0) );\n\t\tneighbour_1_substates[i] = round( mod( (block_neighbourhood[1]), m ) / (m-1.0) );\n\t\tneighbour_2_substates[i] = round( mod( (block_neighbourhood[2]), m ) / (m-1.0) );\n\t\tneighbour_3_substates[i] = round( mod( (block_neighbourhood[3]), m ) / (m-1.0) );\n\t\tm = m / 2.0; }\n\n//\tContainer for the new/recombined substate\n\tfloat[4] new_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tGet the relevant substates\n\tnew_substates[0] = neighbour_0_substates[3];\n\tnew_substates[1] = neighbour_1_substates[2];\n\tnew_substates[2] = neighbour_2_substates[1];\n\tnew_substates[3] = neighbour_3_substates[0];\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tApply the 'Single Rotation Rule' transition\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tIf the current-phased block of substates contains only one value ...\n\tfloat sum\t= new_substates[0] \n\t\t\t\t+ new_substates[1] \n\t\t\t\t+ new_substates[2] \n\t\t\t\t+ new_substates[3];\n\n//\tContainer for the transformed substates\n    float[4] final_substates;\n        final_substates[0] = new_substates[0];\n        final_substates[1] = new_substates[1];\n        final_substates[2] = new_substates[2];\n        final_substates[3] = new_substates[3];\n\n//\tIf the condition is met, apply the transformation, remapping the substates within the block\n    if(sum == 1.0) {\n        final_substates[0] = new_substates[1];\n        final_substates[1] = new_substates[3];\n        final_substates[2] = new_substates[0];\n        final_substates[3] = new_substates[2]; }\n\n//\tAdditional transition / SRR variant\n    if(sum == 3.0) {\n        final_substates[0] = new_substates[1];\n        final_substates[1] = new_substates[3];\n        final_substates[2] = new_substates[0];\n        final_substates[3] = new_substates[2]; }\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPack the pixel from the final substate data\n\tfloat res\t= 0.0;\n\tfloat n \t= (states + 1.0) / 2.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tres = res + final_substates[i] * n;\tn = n / 2.0; }\n\tres = res / states;\n\n//\tReturn the encoded pixel value\n\treturn res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tInitilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPrecision\n\tfloat \tpsn\t\t= 250.0;\n    \n//\tMinimum Precision Value : (1.0 / psn);\n\tfloat \tmnp\t\t= 0.004;\n\n//\tGet the reference frame's origin pixel values\n\tfloat\tres_r\t= gdv( 0.0, 0.0, 0, 1.0 );\n\tfloat\tres_g\t= gdv( 0.0, 0.0, 1, 1.0 );\n\tfloat\tres_b\t= gdv( 0.0, 0.0, 2, 1.0 );\n\n//\tIntended rate of change\n\tfloat \ts \t\t= mnp * 12.0;\n\n//\tOutput value\n\tres_r = margo();\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tPresentation Filtering\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\tvec3 \tn0r \t= nhd( vec2( 4.0, 0.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, 1.0 );\n\tfloat \tn0rw \t= n0r[0] / n0r[2];\n\tres_g = (res_r > 0.0) ? res_g + mnp * 2.0 : (mod(float(iFrame),32.0) == 0.0) ? res_g - mnp * 2.0 : res_g;\n\tres_g = (n0rw > 0.06) ? res_g - mnp * 4.0 : res_g;\n\tres_b = (res_r > 0.0) ? 1.0 : res_b - mnp * 2.0;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tFragment Shader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n    \n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 24.0) { res_r = mod(float(iFrame),2.0); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 112.0) { res_r = reseed(); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 96.0) { res_r = 0.0; }\n    fragColor=vec4(clamp(res_r,0.0,1.0),clamp(res_g,0.0,1.0),clamp(res_b,0.0,1.0),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}