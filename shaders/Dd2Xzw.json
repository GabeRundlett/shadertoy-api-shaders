{
    "Shader": {
        "info": {
            "date": "1670076965",
            "description": "Another F# windows terminal shader\nRevisiting an old shader to see if it fits as a terminal background\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "Dd2Xzw",
            "likes": 22,
            "name": "Another F# windows terminal",
            "published": 3,
            "tags": [
                "2d",
                "complex"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 263
        },
        "renderpass": [
            {
                "code": "// Another F# windows terminal shader\n//  Revisiting an old shader to see if it fits as a terminal background\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define DOT2(x)     dot(x, x)\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define SCA(a)      vec2(sin(a), cos(a))\n\n\nconst int max_iter = 5;\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec2 pmin(vec2 a, vec2 b, float k) {\n  vec2 h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvec2 pabs(vec2 a, float k) {\n  return -pmin(-a, a, k);\n}\nfloat ref(inout vec2 p, vec2 r) {\n  float d = dot(p, r);\n  p -= r*min(0.0, d)*2.0;\n  return d < 0.0 ? 0.0 : 1.0;\n}\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedX(vec2 p, float w, float r) {\n  p = abs(p);\n  return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nvec2 dfsharp(vec2 p) {\n  vec2 p0 = p;\n  vec2 p1 = p;\n  vec2 p3 = p;\n  const float sm = 0.03;\n  p0 = pabs(p0, sm);\n  const vec2 n = normalize(vec2(1.0));\n  float d0 = abs(dot(n, p0)-0.38)-0.12;\n  float d1 = abs(p1.x)-0.025;\n  float d2 = dot(n, p0)-0.19;\n  float d3 = -p3.x-0.025;\n  d2 = pmax(d2, -d3, sm);\n  float d = d0;\n\n  d = pmax(d, -d1, sm);\n  d = min(d,  d2);\n  return vec2(d, p.x > 0.0 ? 1.0 : 0.0);\n}\n\nconst mat2 rot45 = ROT(PI/4.0);\nconst mat2 irot45 = transpose(rot45);\nconst mat2 rot = ROT(-1.22);\nvec2 dfsharpWeekly(vec2 p, vec2 off) {\n  const vec2 refN = SCA(-PI/4.0);\n  const float r = 0.125;\n  const float rr = 2.0*r*sqrt(2.0);\n  vec2 p0 = p;\n  vec2 p1 = p-off;\n  p0 = abs(p0);\n  ref(p0, refN);\n  p0.y -= rr;\n  float d0 = roundedX(p0, rr, r);\n  float d1 = segment(p1, rr*vec2(-1.0, 0.0), rr*vec2(0.0, 1.0))-r;\n  float d2 = segment(p1, rr*vec2(0.5, -0.5), rr*vec2(0.0, -1.0))-r;\n  float d3 = segment(p1, rr*vec2(-1.0, 0.0), rr*vec2(0.5, -1.5))-r;\n  float d = d0;\n  float dd = d1;\n  dd = min(dd, d2);\n  dd = min(dd, d3);\n  \n  return vec2(d, dd);\n}\n\nvec2 cell(vec2 p, float w) {\n  p *= irot45;\n  float z = 1.8*w;\n  p /= z;\n  vec2 d2 = dfsharp(p);\n  return vec2(d2.x*z, d2.y);;\n}\n\nfloat shape(vec2 p) {\n  const float z =2.8;\n  p *= rot;\n  p /= z;\n  vec2 off = vec2(-0.75,-0.35);\n  vec2 d2 = dfsharpWeekly(p+0.5*off, off)*z;\n  float d = d2.x;\n  d = min(d, d2.y);\n  return d;\n}\n\nfloat df(vec2 p, float zz, out int ii, out bool inside, out bool side) {\n  p /= zz;\n  const float or = 10.0;\n  vec2 off = sin(0.125*vec2(1.0, sqrt(0.5))*TIME/or)*or;\n  p += off;\n  p *= rot45;\n\n  float sz = 0.9;\n  vec2 pp = p;\n\n  float r = 0.0;\n\n  ii = max_iter;\n  for (int i=0; i<max_iter; ++i) {\n    pp = p;\n    vec2 nn = mod2(pp, vec2(sz));\n  \n    vec2 cp = nn*sz;\n    float d = shape(cp-off*rot45);\n    \n    r = sz*0.5; \n\n    if (abs(d) > 0.5*sz*sqrt(2.0)) {\n      ii = i;\n      inside = d < 0.0;\n      break;\n    }\n\n    sz /= 3.0;\n  }\n  \n  float w = 0.9*r;\n  vec2 d2 = cell(pp, w);\n  side = d2.y > 0.0;\n  return d2.x*zz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  const float r = 25.0;\n  float a = 0.05*TAU*TIME/r;\n  const float z = 1.0;\n  p /= z;\n  int i;\n  bool inside;\n  float zz = 1.0-0.5;\n\n  bool side;\n  float d = df(p, zz, i, inside, side)*z;\n  float ii = float(i)/float(max_iter);\n\n//  if (!inside) d = abs(d)-0.0075*smoothstep(1.0, 0.0, sqrt(ii));\n\n  vec3 col = vec3(0.0);\n\n  vec3 bcol0 = vec3(1.0, 0.0, 0.5).yzx;\n  vec3 bcol1 = sqrt(bcol0);\n  vec3 bcol = side ? bcol1 : bcol0;\n  if (!inside) bcol = 0.1*bcol.yyy;\n  bcol *= smoothstep(1.0, 0.125, ii);\n\n  col = mix(col, bcol, smoothstep(aa, -aa, d));\n  \n  col *= 1.*smoothstep(1.5, 0., length(pp));\n\n  col = sqrt(col);\n\n  fragColor = vec4(col, 1.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}