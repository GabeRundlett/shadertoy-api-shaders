{
    "Shader": {
        "info": {
            "date": "1565434843",
            "description": "I found out - while Googling for reference images - that the steel ball desk toy is called a \"Newton's Cradle\".\nThis scene would have made more sense in a small room, with a desk instead of a table, but I didn't get around to that.",
            "flags": 1,
            "hasliked": 0,
            "id": "3l2XRm",
            "likes": 7,
            "name": "Desk toy",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "sdf"
            ],
            "usePreview": 0,
            "username": "tmulgrew",
            "viewed": 687
        },
        "renderpass": [
            {
                "code": "// A little SDF ray-marching \"framework\".\n// Much of the techniques are copied from IQ's demos and articles.\n\n#define AA 1\n#define ZERO (min(iFrame,0))\n// Pinched from \"Happy Jumping\"\n//#define DEBUGSTEPS\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Constants\n\nconst float tmin = 0.01;\t\t\t\t\t\t\t\t// Ray minimum distance\nconst float tmax = 500.0;\t\t\t\t\t\t\t\t\nconst int raySteps = 100;\t\t\t\t\t\t\t\t// Max iterations when resolving a ray\nconst int shadowSteps = 50;\t\t\t\t\t\t\t\t// Max iterations when resolving a shadow ray\nconst float limit = 0.0005;\t\t\t\t\t\t\t\t// Convergence to surface limit when ray tracing\nconst float screenDist = 0.5;\t\t\t\t\t\t\t// Screen distance as a fraction of screen width\nconst vec3 light = normalize(vec3(-1.0, -0.75, -0.52));\t// Light direction\nconst float ambient = 0.3;\t\t\t\t\t\t\t\t// Ambient light\nconst int bounces = 2;\t\t\t\t\t\t\t\t\t// Max reflection bounces (actually bounces + 1, as includes initial ray)\nconst int shadowBounces = 1;\t\t\t\t\t\t\t// Bounces during which shadow rays are cast.\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Data structures\n\nstruct lightingParams {\n \tfloat diffuse;\n    float specular;\n    float shiny;\n};\n\nstruct material {\n    vec3 col;\t\t\t\t\t\t\t\t\t\t\t// Surface colour\n    lightingParams lighting;\n    float reflective;\t\t\t\t\t\t\t\t\t// Reflectiveness. 0 = not reflective. 1 = completely reflective (e.g. mirror).\n};\n    \nstruct rayInfo {\n    vec3 origin;\n    vec3 dir;\n};\n    \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Functions (implemented at the bottom)\n    \n// Get camera ray for specified pixel\nrayInfo getRay(in vec2 fragCoord);\n\n// Get VR ray\nrayInfo getVRRay(in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir);\n\n// Get sample point.\n// Format is vec4:\n//\tx,y\t\t= Material parameter (e.g. uv)\n//\tz\t\t= Distance to nearest surface\n//\tw\t\t= Material index (will be passed to getMaterial())\nvec4 map(in vec3 p);\n\n// Get material properties by index\nmaterial getMaterial(float index, vec2 uv, vec3 p);\n\n// Get colour for ray that misses\nvec3 getRayMissCol(in rayInfo ray);\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Trig\n\nconst float PI = 3.14159265;\n\nvec3 rotatex(in vec3 p, float a) {\n\treturn vec3(p.x,\n                cos(a) * p.y - sin(a) * p.z,\n                cos(a) * p.z + sin(a) * p.y);\n}\n\nvec3 rotatey(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotatez(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nvec3 rotate(in vec3 p, in vec3 euler) {\n \treturn rotatey(rotatex(rotatez(p, euler.z), euler.x), euler.y);   \n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Helper functions\n\nbool checkerboard(in vec2 p) {\n\tfloat x = mod(p.x, 2.0);\n    if (x < 0.0) x += 2.0;\n    float y = mod(p.y, 2.0);\n    if (y < 0.0) y += 2.0;\n    return (x < 1.0) == (y < 1.0);\n}\n\n// Pinched from: https://iquilezles.org/articles/smin\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Combining shapes\n//\n// Sample format is vec3:\n//\tx,y\t\t= Material parameter (e.g. texture coordinates)\n//\tz\t\t= Distance\n\n// Union of two shapes\nvec3 combine(in vec3 p1, in vec3 p2) { \n    return p1.z < p2.z ? p1 : p2;\n}\n\n// Smoothed union of two shapes\nvec3 combine(in vec3 p1, in vec3 p2, float k) {\n    return vec3(p1.z < p2.z ? p1.xy : p2.xy, sminCubic(p1.z, p2.z, k));\n}\n\n// Subtract shape p2 from p1\nvec3 carve(in vec3 p1, in vec3 p2) { \n    return p1.z > -p2.z ? p1 : vec3(p2.xy, -p2.z);\n}\n\nvec3 carve(in vec3 p1, in vec3 p2, float k) {\n \treturn vec3(p1.z > -p2.z ? p1.xy : p2.xy, -sminCubic(-p1.z, p2.z, k));   \n}\n\n// Intersection of two shapes\nvec3 intersect(in vec3 p1, in vec3 p2) { \n    return p1.z > p2.z ? p1 : p2;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Shape primitives\n\nvec3 sphere(in vec3 p, in vec3 center, float rad) { \n    p -= center;\n    return vec3(atan(p.x, p.y) * rad, atan(length(p.xy), p.z) * rad, length(p) - rad); \n}\nvec3 box(in vec3 p, in vec3 center, in vec3 size) {\n    p -= center;\n    vec3 o = abs(p) - size;\t\t\t\t\t\t// Distance inside/outside each side\n    float d = max(o.x, max(o.y, o.z));   \t\t// Negative distance to nearest wall if inside box\n    if (d > 0.0) {\t\t\t\t\t\t\t\t// Refine distance if outside box\n\t    vec3 n = min(o, vec3(0));\t\t\t\t// Clamp to box boundaries to get nearest point. (Could be edge/corner).\n        d = length(o - n);\n    }\n    vec3 a = abs(o);\t\t\t\t\t\t\t// Nearest wall determines texture coordinates\n    vec2 uv = a.x < a.y && a.x < a.z ? p.yz\t\t\n    \t\t: a.y < a.z \t\t\t ? p.xz\n            :                          p.xy;\n    return vec3(uv, d);\n}\nvec3 planeBottom(in vec3 p, float y)\t\t\t\t{ return vec3(p.xz, y-p.y); }\nvec3 planeTop(in vec3 p, float y) \t\t\t\t\t{ return vec3(p.xz, p.y-y); }\nvec3 cylinder(in vec3 p, in vec3 center, float radius, float height) { \n    p -= center;\n    vec3 tube = vec3(atan(p.x, p.z) * radius, p.y, length(p.xz) - radius);\n    vec3 top = planeTop(p, height);\n    vec3 bottom = planeBottom(p, -height);\n    return intersect(tube, intersect(top, bottom));\n}\nvec3 torus(in vec3 p, in vec3 center, float radius, float thickness) { \n    p -= center;\n    vec2 circleOffs = vec2(length(p.xz) - radius, p.y);\n    return vec3(atan(p.x, p.z) * radius, atan(circleOffs.x, circleOffs.y) * thickness, length(circleOffs) - thickness);\n}\nvec3 line(in vec3 p, in vec3 from, in vec3 to, float thickness) {\n\t\n    vec3 d = to - from;\n    vec3 n = normalize(d);\n    float l = length(d);\n    \n    float proj = dot(p - from, n);\n    proj = clamp(proj, 0.0, l);\n    vec3 pt = from + n * proj;\n    return vec3(0, 0, length(p - pt) - thickness);    \n}\n\n// Creating and combining full sample including material index\nvec4 makes(in vec3 d, float material) {\n    // Like a distance sample, but with w = material index.\n    // Specifically:\n    //\tx,y\t= material parameter (e.g. texture coord)\n    //\tz\t= distance\n    //\tw\t= material index\n \treturn vec4(d, material);   \n}\n\nvec4 merges(in vec4 result, in vec3 d, float material) {\n \treturn d.z < result.z ? makes(d, material) : result;\n}\n\nvec4 merge(in vec4 result, in vec4 d) {\n \treturn d.z < result.z ? d : result;   \n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Rendering\n\n// Calculate ray direction for a given pixel\nvec3 screenRay(in vec2 s) {\n    s -= iResolution.xy / 2.0;\n    return vec3(s / (screenDist * iResolution.x), 1);\n}\n\n// Simple lighting\nfloat shading(in vec3 e, in vec3 n, in lightingParams p) {\n    \n    // Diffuse term\n    float d = dot(n, -light) * p.diffuse;\n    \n    // Specular term\n    vec3 h = -(normalize(e) + light) / 2.0;\n    float s = pow(dot(n, h), p.shiny) * p.specular;\n\n    return max(d + s, 0.0);\n}\n\n// Calculate normal at a point\nvec3 normal(in vec3 p, float t) {\n    \n\t// Calculate pixel size at point distance. \n    // This will be the distance of the normal samples from the original point.\n    float s = 0.1 / t;\n    \n    // Sample relative distance along each axis\n    float d = map(p).z;\t\t\t// Need original distance to compare it to\n    vec3 r = vec3(\n        map(p + vec3(s,0,0)).z - d,\n        map(p + vec3(0,s,0)).z - d,\n        map(p + vec3(0,0,s)).z - d);\n    \n    return normalize(r);\n}\n\n// Cast regular ray\nvec4 raycast(in vec3 from, in vec3 dir) {\n    \n    float t = tmin;\n    vec4 d;\n    int i;\n    for (i = 0; i < raySteps && t < tmax; i++) {\n        vec3 p = from + dir * t;\n        d = map(p);\n        if (abs(d.z) <= limit * t) {\n            d.z = t;\n#ifdef DEBUGSTEPS\n            d.x = float(i) / float(raySteps);\n#endif            \n            return d;\n        }\n        t += d.z;\n    }    \n    \n    // Avoid flicker when polygons are edgewise to the camera.\n    // In this case the ray cannot quite find the surface and runs out of steps.\n    // Just return the last sample point.\n    if (t < tmax) {\n#ifdef DEBUGSTEPS\n        d.x = float(i) / float(raySteps);\n#endif            \n        d.z = t;\n        return d;\n    }\n    \n#ifdef DEBUGSTEPS\n    return vec4(float(i) / float(raySteps),0,-1.0,0);\n#else    \n    return vec4(0,0,-1.0,0);\n#endif    \n}\n\n// Cast shadow ray\nfloat shadow(in vec3 from, in vec3 dir, float k) {\n    float res = 1.0;\n    float t = tmin;    \n    for (int i = 0; i < shadowSteps && t < tmax; i++) {\n     \tvec3 p = from + dir * t;\n        float d = map(p).z;\n        if (d <= 0.0)\n            return 0.0;\n        res = min(res, k*d/t);\n        t += d;\n    }\n    \n    return res;\n}\n\nvec3 drawPixel(in rayInfo ray) {\n    ray.dir = normalize(ray.dir);\n\n    // Sum up reflection bounces    \n    vec3 sumCol = vec3(0);\n    float alpha = 1.0;\n    for (int bounce = 0; alpha > 0.0002; bounce++) {\n    \n\t    // Ray cast\n\t    vec4 r = bounce < bounces \n            ? raycast(ray.origin, ray.dir) \n            : vec4(0,0,-1,0);\t\t\t\t\t// Last ray always misses\n    \n#ifdef DEBUGSTEPS        \n        sumCol = vec3(r.x*16.0 - floor(r.x*16.0), r.x*4.0 - floor(r.x*4.0), r.x);\n        break;\n#endif        \n        \n        // Distance is returned in r.z\n\t    // Miss?\n\t    if (r.z == -1.0)\n\t    {\n            vec3 missCol = getRayMissCol(ray);\n            sumCol += missCol * alpha;\n\t        break;\n\t    }\n        \n\t    // Position and normal\n\t    vec3 p = ray.origin + r.z * ray.dir;\n\t    vec3 n = normal(p, r.z);\n\n        // Get material info\n        material mat = getMaterial(r.w, r.xy, p);\n        \n        // Apply lighting\n        float i = shading(ray.dir, n, mat.lighting);\n        if (i > 0.0 && bounce < shadowBounces) \n            i *= shadow(p, -light, 16.0);    \n        i = clamp(i + ambient, 0.0, 1.0);\n        mat.col *= i;\n\n        // Add to sum of colours\n        mat.col *= (1.0 - mat.reflective);\n        sumCol += mat.col * alpha;\n        alpha *= mat.reflective;\n        \n        // Calculate reflection vector\n        ray.origin = p;\n        ray.dir = normalize(reflect(ray.dir, n));\n    }    \n    \n    return sumCol;\n}\n\n// Main entrypoints\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if AA > 1    \n    vec3 col = vec3(0);\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n\t    rayInfo ray = getRay(fragCoord + vec2(m,n) / vec2(AA));\n\t    col += drawPixel(ray) / (float(AA) * float(AA));\n\t    fragColor = vec4(col, 1);\n    }\n#else    \n    rayInfo ray = getRay(fragCoord);\n    vec3 col = drawPixel(ray) / (float(AA) * float(AA));\n    fragColor = vec4(col, 1);\n#endif    \n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir) \n{\n \trayInfo ray = getVRRay(fragCoord, fragRayOri, fragRayDir);\n    vec3 col = drawPixel(ray);\n    fragColor = vec4(col, 1);\n}\n\n//-----------------------------------------------------------------------------------------------------------------------------------\n\n//#define DONUT\n//#define COFFEE\n\nrayInfo getRay(in vec2 fragCoord) {    \n    rayInfo ray;    \n    vec3 ang = vec3(0.5 + sin(iTime * 0.03 - PI*0.5) * 0.2, iTime * 0.1, 0);\n    \n    //ang.y = iMouse.x / iResolution.x * 2. * PI;\n    //ang.x = (1. - iMouse.y / iResolution.y) * PI - PI/2.;\n    \n    ray.origin = vec3(0,0,0) + rotate(vec3(0, 0, -20), ang);\n    ray.dir = rotate(screenRay(fragCoord), ang);\n    return ray;\n}\n\nrayInfo getVRRay(in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir) {\n \trayInfo ray;\n    ray.origin = rotatey(fragRayOri * 40.0 + vec3(0,28,10), PI*0.5);\n    ray.dir = rotatey(fragRayDir, PI*0.5);\n    return ray;\n}\n\nvec3 getRayMissCol(in rayInfo ray) {\n    vec3 col = texture(iChannel2, ray.dir).xyz;\n    if (ray.dir.y < 0.001) {\n        float floordy = -40.0 - ray.origin.y;\n    \tvec2 floorPos = ray.origin.xz + ray.dir.xz * floordy / ray.dir.y;\n        vec3 floorCol = texture(iChannel3, floorPos * 0.025).xxx;\n        float f = clamp(length(floorPos) / 300.0, 0.0, 1.0);\n        col = mix(floorCol, col, f);        \n    }\n    return col;\n}\n\n// Material types.\n// Returned by map(). Then passed into getMaterial() to get colour, lighting etc.\nconst float wireMat\t\t= 1.0;\nconst float woodMat\t\t= 2.0;\nconst float steelMat\t= 3.0;\nconst float ballMat\t\t= 4.0;\nconst float tableMat \t= 5.0;\nconst float cupMat      = 6.0;\nconst float plateMat\t= 7.0;\nconst float donutMat    = 8.0;\nconst float icingMat    = 9.0;\nconst float coffeeMat   = 10.0;\nconst float toppingMat  = 11.0;\n\n// Lookup material colour etc\nmaterial getMaterial(float matType, vec2 uv, vec3 p) {\n    \n    // Set defaults\n    material mat;\n    mat.lighting.diffuse = 0.8;\n    mat.lighting.specular = 0.6;\n    mat.lighting.shiny = 64.0;\n    mat.reflective = 0.0001;\n    \n    if (matType == wireMat) {\n        mat.col = vec3(0.8);\n    }\n    else if (matType == woodMat) {\n        mat.col = texture(iChannel0, uv * 0.1).xyz * 0.4;\n        mat.reflective = 0.2;\n    }\n    else if (matType == steelMat) {\n        mat.col = vec3(0.7,0.7,0.5);\n        mat.reflective = 0.5;\n    }\n    else if (matType == ballMat) {\n     \tmat.col = vec3(0.95);\n        mat.reflective = 0.75;\n    }\n    else if (matType == tableMat) {\n     \tmat.col = texture(iChannel1, uv * 0.05).xyz * vec3(0.8, 0.9, 1.0);\n        mat.reflective = 0.1;\n    }\n    else if (matType == cupMat) {\n        mat.reflective = 0.1;        \n\t    mat.lighting.specular = 0.8;\n        mat.col = mix(vec3(0.9,0.9,0.875), vec3(0.7, 0.7, 0.75), sin(p.y * 10.0) * 0.5 + 0.5);\n    }\n    else if (matType == plateMat) {\n     \tmat.col = vec3(0.9,0.9,0.875);\n        mat.reflective = 0.1;        \n\t    mat.lighting.specular = 0.8;\n    }\n    else if (matType == donutMat) {\n        mat.col = texture(iChannel0, uv * 0.1).xyz * 0.7 + vec3(0.4);        \n    }\n    else if (matType == icingMat) {\n     \tmat.col = vec3(1,0.9,0.85);\n        mat.reflective = 0.02;\n        mat.lighting.specular = 0.5;\n    }\n    else if (matType == coffeeMat) {\n        mat.col = vec3(.3,.2,.1);\n        mat.reflective = 0.1;\n    }\n    else if (matType < toppingMat + 1.) {\n     \tfloat f = fract(matType * 7.) * 2. * PI;        \n        mat.col = vec3(sin(f), sin(f + PI * 0.666), sin(f + PI * 1.333)) * 0.3 + vec3(0.2);\n        mat.reflective = 0.25;\n        mat.lighting.specular = 0.1;\n    }\n    \n    return mat;\n}\n\nvec3 frame(in vec3 p, in vec3 center, in vec2 dim, float corner, float radius) {\n    p -= center;\n    vec2 nx = vec2(sign(p.x) * dim.x, clamp(p.y, -dim.y, dim.y));\n    vec2 ny = vec2(clamp(p.x, -dim.x, dim.x), sign(p.y) * dim.y);\n    float dx = length(p.xy - nx);\n    float dy = length(p.xy - ny);    \n    float d = min(dx,dy);\n    if (abs(p.x) < dim.x && abs(p.y) < dim.y)\n        d += corner;\n    else \n        d -= corner;\n    d = abs(d);\n    return vec3(0, 0, length(vec2(d,p.z)) - radius);\n}\n\nconst float toyBallSize = 1.25;\nconst float toyWireLength = 6.0;\nconst vec3 toyDimensions = vec3(8,6,4);\nconst float toyFrameRounding = 1.25;\nconst float toyFrameRadius = 0.2;\nconst float toyPeriod = 2.0;\nconst float toyArc = 0.5;\nconst vec3 toyBaseDimensions = vec3(12.5,1.5,5.5);\nconst float toyWireThickness = 0.015;\n\nvec3 getWireTopPos(int i) {\n\treturn vec3(float(i-2) * toyBallSize, toyDimensions.y + toyFrameRounding, 0);   \n}\n\nvec3 getBallPos(int i) {    \n    float angle = sin(iTime * PI*2.0 / toyPeriod) * toyArc;\n    if (i < 2)\n        angle = min(angle, 0.0);\n    else if (i > 2)\n        angle = max(angle, 0.0);\n    //else\n    //    angle = 0.0;\n    \n    // Position is relative to top of wire\n    return vec3(sin(angle) * toyWireLength, cos(angle) * -toyWireLength, 0);\n}\n\nvec4 desktoy(in vec3 p, in vec3 center) {\n    p -= center;\n    \n    float d = length(p - vec3(0, 2.25, 0));\n    if (d > 7.75)\n        return vec4(0,0,d - 7.25, 0);\n\n    vec4 r = makes(box(p, vec3(0, -toyBaseDimensions.y*0.5, 0), toyBaseDimensions*0.5), woodMat);\n    \n    vec3 f1 = frame(p, vec3(0,0, toyDimensions.z*0.5), vec2(toyDimensions.x*0.5,toyDimensions.y), toyFrameRounding, toyFrameRadius);\n    vec3 f2 = frame(p, vec3(0,0,-toyDimensions.z*0.5), vec2(toyDimensions.x*0.5,toyDimensions.y), toyFrameRounding, toyFrameRadius);\n    vec3 f = combine(f1, f2);\n    f = carve(f, planeTop(p, 0.0));\n    \n    r = merges(r, f, steelMat);\n    \n    for (int i = 0; i < 5; i++) {\n        vec3 topPos = getWireTopPos(i);\n        vec3 ballPos = topPos + getBallPos(i);\n     \tr = merges(r, sphere(p, ballPos, toyBallSize*0.5), ballMat);\n        r = merges(r, line(p, topPos + vec3(0, 0, toyDimensions.z*0.5-toyFrameRadius), ballPos, toyWireThickness), wireMat);\n        r = merges(r, line(p, topPos + vec3(0, 0,-toyDimensions.z*0.5+toyFrameRadius), ballPos, toyWireThickness), wireMat);\n    }\n   \n    return r;\n}\n\nvec4 coffeeCup(in vec3 p, in vec3 center) {\n    \n    // Create a vec3 distance sample by combining distance samples for primative shapes.    \n\tp -= center;\n    \n    float d = length(p - vec3(0, 2.25, 0.4));\n    if (d > 3.5) \n        return vec4(0,0,d - 3.0, cupMat);    \n    \n    // Component primatives\n    vec3 base = sphere(p, vec3(0, 2.75, 0), 3.0);\n    //base = intersect(base, planeTop(p, 1.0));        \n    base = intersect(base, planeBottom(p, 0.0));\n    vec3 body = cylinder(p, vec3(0, 1.75, 0), 2.0, 1.75);    \n    vec3 hole = cylinder(p, vec3(0, 4.1, 0), 1.8, 2.8);    \n    vec3 rim = torus(p, vec3(0, 3.5, 0), 1.9, 0.1);    \n    vec3 handle = torus(p.zxy, vec3(2.2, 0, 2.2), 0.7, 0.2);\n\n    // Cup\n    vec3 cupShape = combine(carve(combine(intersect(base, body), handle, 0.5), hole), rim);\n    vec4 cup = makes(cupShape, cupMat);\n    \n#ifdef COFFEE    \n    vec3 liquidSurface = planeTop(p, 2.3);\n    vec3 liquidShape = intersect(hole, liquidSurface);\n    vec4 liquid = makes(liquidShape, coffeeMat);    \n    \n    // Combine together\n    return merge(cup, liquid);\n#else\n    return cup;\n#endif        \n}\n\nvec3 plate(in vec3 p, in vec3 center) {\n    p -= center;\n\n    float d = length(p - vec3(0, 0.0, 0.0));\n    if (d > 5.0) \n        return vec3(0,0,d - 4.5);    \n    \n    vec3 bottom = sphere(p, vec3(0, 10, 0), 10.0);\n    vec3 top = sphere(p, vec3(0, 11.8, 0), 11.5);\n    vec3 clip = cylinder(p, vec3(0), 4.0, 10.0);\n    vec3 base = torus(p, vec3(0,0.2,0), 1.5, 0.15);\n    vec3 rim = torus(p, vec3(0,0.94,0), 4.0, 0.075);\n    return combine(combine(intersect(carve(bottom, top), clip), base, 0.5), rim, 0.5);\n}\n\nvec4 topping(in vec3 p, in vec3 center, float radius, float thickness) {\n    p -= center;\n    \n    float ang = atan(p.x, p.z);\n    float spacing = (2. * PI) / 11.;\n    ang = round(ang / spacing) * spacing;\n    vec3 nearest = vec3(sin(ang) * radius, thickness, cos(ang) * radius);\n    p -= nearest;\n    p.y *= 2.;\n    return makes(sphere(p, vec3(0), 0.35), toppingMat + ang / (2. * PI));\n}\n\nvec4 donut(in vec3 p) {\n    vec4 r = makes(torus(p, vec3(0), 2.0, 0.8), donutMat);\n    \n    vec3 icingMain = torus(p, vec3(0,0.1,0), 2.0, 0.875);\n    vec3 icingClip = planeTop(p, -0.05);\n    vec3 icing = carve(icingMain, icingClip, 0.4);\n    \n    return merges(r, icing, icingMat);\n    \n    //vec4 toppings = topping(p, vec3(0,0.165,0), 2.0, 0.875);\n    \n    //return merge(merges(r, icing, icingMat), toppings);    \n}\n\nvec4 map(in vec3 p) {\n    \n    p = rotatey(p,PI*0.35);\n    \n    // Toy\n    vec3 toyp = p - vec3(-4, 0, 5);\n    toyp = rotatey(toyp, 0.3);\n    vec4 r = desktoy(toyp, vec3(0));\n    \n    // Cup\n    vec3 cupp = p - vec3(5, -toyBaseDimensions.y, -4);\n    cupp = rotatey(cupp, 2.5);\n    r = merge(r, coffeeCup(cupp, vec3(0)));\n    \n    // Plate\n    r = merges(r, plate(p, vec3(-1, -toyBaseDimensions.y, -7)), plateMat); \n    \n    // Donut\n#ifdef DONUT    \n    float dnSize = 0.7;\n    vec4 dn = donut(rotatez(p - vec3(0,-0.3,-7.6), 0.06) / dnSize);\n    dn.z *= dnSize;\n    r = merge(r, dn);\n#endif\n    \n    // Tabletop\n    r = merges(r, cylinder(p, vec3(0, -toyBaseDimensions.y - 0.15, 0), 13.0, 0.3), tableMat);\n    \n    return r;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}