{
    "Shader": {
        "info": {
            "date": "1683266820",
            "description": "Base64 encode and decode in a shader? Why???\n\nBuffers A and B do sorta kinda contiguous packing & unpacking. The Image buffer does a RGB->RGBA hack.\n\nYou could use Buffer A for fast (30 GB/s) data URI creation. Need to add last-three-bytes handling tho.",
            "flags": 32,
            "hasliked": 0,
            "id": "dtt3WX",
            "likes": 1,
            "name": "base64",
            "published": 3,
            "tags": [
                "hack",
                "compute",
                "base64"
            ],
            "usePreview": 0,
            "username": "kig",
            "viewed": 203
        },
        "renderpass": [
            {
                "code": "int enc(int c) {\n    int off = 65;\n    if (c > 25) off = 71;\n    if (c > 51) off = -4;\n    if (c == 62) off = 43 - c;\n    if (c == 63) off = 47 - c;\n    return c + off;\n}\n\nint dec(int c) {\n    int off = 65;\n    if (c > 96) off = 71;\n    if (c < 58) off = -4;\n    if (c == 43) off = c - 62;\n    if (c == 47) off = c - 63;\n    if (c == 61) off = c;\n    return c - off;\n}\n\nivec4 base64_encode(ivec3 triplet) {\n    return ivec4(\n        enc(triplet.x >> 2),\n        enc(((triplet.x & 3) << 4) | (triplet.y >> 4)),\n        enc(((triplet.y & 15) << 2) | (triplet.z >> 6)),\n        enc(triplet.z & 63)\n    );\n}\n\nivec4 base64_encode(ivec2 triplet) {\n    return ivec4(\n        enc(triplet.x >> 2),\n        enc(((triplet.x & 3) << 4) | (triplet.y >> 4)),\n        enc(((triplet.y & 15) << 2)),\n        61\n   );\n}\n\nivec4 base64_encode(int triplet) {\n    return ivec4(\n        enc(triplet >> 2),\n        enc((triplet & 3) << 4),\n        61,\n        61\n   );\n}\n\n\nivec3 base64_decode(ivec4 quad) {\n    quad = ivec4(\n        dec(quad.x),\n        dec(quad.y),\n        dec(quad.z),\n        dec(quad.w)\n    );\n    return ivec3(\n        (quad.x << 2) | (quad.y >> 6),\n        ((quad.y << 4) | (quad.z >> 2)) & 0xff,\n        ((quad.z << 6) | quad.w) & 0xff\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec3 triplet = ivec3(255.0 * texelFetch(iChannel0, ivec2(fragCoord), 0).rgb);\n    ivec4 encoded = base64_encode(triplet);\n\n    // Output to screen\n    if (fragCoord.x > iResolution.x * (0.75 + 0.25*sin(iTime))) fragColor = vec4(triplet, 255.0) / 255.0;\n    if (fragCoord.x < iResolution.x * (0.75 + 0.25*sin(iTime))) fragColor = vec4(base64_decode(encoded), 255.0) / 255.0;\n    if (fragCoord.x < iResolution.x * (0.5 + 0.25*sin(iTime))) fragColor = vec4(encoded) / 255.0;\n    if (fragCoord.x < iResolution.x * (0.25 + 0.25*sin(iTime))) fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0) / 255.0;\n    if (abs(fragCoord.x - iResolution.x * (0.25 + 0.25*sin(iTime))) < 2.0) fragColor = vec4(1.0, 1.0, 0.0, 1.0);\n    if (abs(fragCoord.x - iResolution.x * (0.5 + 0.25*sin(iTime))) < 2.0) fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    if (abs(fragCoord.x - iResolution.x * (0.75 + 0.25*sin(iTime))) < 2.0) fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// How fast is it?\n// Set this to 500 or something and calculate:\n// BENCHMARK_ITERATIONS * width * height * 4 * fps / 1e9 = gigabytes per second\n//\n// On an M2 Macbook Air, around 30 GB/s encode.\n// (YMMV with real data, especially if you need to truck the data over the PCIe bus.)\n//\n// A proper compute shader implementation should be a bit faster still.\n//\n// For comparison, Chrome's btoa runs at about 500-600 MB/s.\n// I got a JavaScript implementation to run at about 300 MB/s.\n//\n// I don't know who needs a memory-speed btoa but there you have it.\n//\n#define BENCHMARK_ITERATIONS 0\n\n\nint enc(int c) {\n    int off = 65;\n    if (c > 25) off = 71;\n    if (c > 51) off = -4;\n    if (c == 62) off = 43 - c;\n    if (c == 63) off = 47 - c;\n    return c + off;\n}\n\nivec4 base64_encode(ivec3 triplet) {\n    return ivec4(\n        enc(triplet.x >> 2),\n        enc(((triplet.x & 3) << 4) | (triplet.y >> 4)),\n        enc(((triplet.y & 15) << 2) | (triplet.z >> 6)),\n        enc(triplet.z & 63)\n    );\n}\n\nivec2 quadIndexToTexCoord(int quadIndex, int width) {\n    return ivec2(quadIndex % width, quadIndex / width);\n}\n\nvec4 readVec4(int byteIndex, int width) {\n    int quadIndex = byteIndex / 4;\n    ivec2 texCoord1 = quadIndexToTexCoord(quadIndex, width);\n    ivec2 texCoord2 = quadIndexToTexCoord(quadIndex + 1, width);\n    vec4 quad1 = texelFetch(iChannel0, texCoord1, 0);\n    vec4 quad2 = texelFetch(iChannel0, texCoord2, 0);\n    vec4 result = quad1;\n    int byteOffset = byteIndex % 4;\n    if (byteOffset == 1) result = vec4(quad1.yzw, quad2.x);\n    if (byteOffset == 2) result = vec4(quad1.zw, quad2.xy);\n    if (byteOffset == 3) result = vec4(quad1.w, quad2.xyz);\n    return result;\n}\n\nivec4 base64EncodeTexture(in vec2 fragCoord) {\n    // Fetch the triplet of bytes corresponding to the current pixel and encode it into a quad.\n    int w = int(iChannelResolution[0].x);\n    int h = int(iChannelResolution[0].y);\n    int byteIndex = ((int(fragCoord.y) * int(iResolution.x) + int(fragCoord.x)) * 3) % (w * h * 4);\n    ivec3 triplet = ivec3(readVec4(byteIndex, w).xyz * 255.0);\n    return base64_encode(triplet);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(base64EncodeTexture(fragCoord));\n    for (int i = 0; i < BENCHMARK_ITERATIONS; i++) {\n      fragColor += vec4(base64EncodeTexture(fragCoord + vec2(float(i*37), float(i*17))));\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// How fast is it?\n// Set this to 500 or something and calculate:\n// BENCHMARK_ITERATIONS * width * height * 4 * fps / 1e9 = gigabytes per second\n//\n// On an M2 Macbook Air, around 30 GB/s decode.\n// (YMMV with real data, especially if you need to truck the data over the PCIe bus.)\n//\n// A proper compute shader implementation should be a bit faster still.\n//\n// For comparison, Chrome's atob runs at about 700 MB/s.\n//\n// I don't know who needs a memory-speed atob either, but there you have it.\n//\n#define BENCHMARK_ITERATIONS 0\n\nint dec(int c) {\n    int off = 65;\n    if (c > 96) off = 71;\n    if (c < 58) off = -4;\n    if (c == 43) off = c - 62;\n    if (c == 47) off = c - 63;\n    if (c == 61) off = c;\n    return c - off;\n}\n\nivec3 base64_decode(ivec4 quad) {\n    quad = ivec4(\n        dec(quad.x),\n        dec(quad.y),\n        dec(quad.z),\n        dec(quad.w)\n    );\n    return ivec3(\n        (quad.x << 2) | (quad.y >> 6),\n        ((quad.y << 4) | (quad.z >> 2)) & 0xff,\n        ((quad.z << 6) | quad.w) & 0xff\n    );\n}\n\nivec2 quadIndexToTexCoord(int quadIndex, int width) {\n    return ivec2(quadIndex % width, quadIndex / width);\n}\n\nvec4 readVec4(int byteIndex, int width) {\n    int quadIndex = byteIndex / 4;\n    ivec2 texCoord1 = quadIndexToTexCoord(quadIndex, width);\n    ivec2 texCoord2 = quadIndexToTexCoord(quadIndex + 1, width);\n    vec4 quad1 = texelFetch(iChannel0, texCoord1, 0);\n    vec4 quad2 = texelFetch(iChannel0, texCoord2, 0);\n    vec4 result = quad1;\n    int byteOffset = byteIndex % 4;\n    if (byteOffset == 1) result = vec4(quad1.yzw, quad2.x);\n    if (byteOffset == 2) result = vec4(quad1.zw, quad2.xy);\n    if (byteOffset == 3) result = vec4(quad1.w, quad2.xyz);\n    return result;\n}\n\nivec4 base64DecodeTexture(in vec2 fragCoord, int width) {\n    // Convert the fragCoord to the byte index in the decoded string.\n    // Convert the decoded byte index to the encoded byte index for the triplet.\n    //\n    // byteIndex 8.\n    //            V\n    // [AAAB|BBCC|CDDD]\n    //\n    // encoded 12 . = (byteIndex / 3) * 4 = tripletByteIndex\n    //            V\n    // [aaaa|bbbb|cccc|dddd]\n    //\n    // Grab the two triplets from encoded.\n    //\n    // [cccc|dddd] = tripletByteIndex, tripletByteIndex + 4\n    //\n    // Decode the encoded triplets.\n    //\n    // [CCC|DDD]\n    //\n    // Extract the wanted bytes.\n    //     V = byteIndex % 3 = 8 % 3 = 2\n    // [CC|CDDD] \n\n    int byteIndex = (int(fragCoord.y) * width + int(fragCoord.x)) * 4;\n    int tripletByteIndex = (byteIndex / 3) * 4;\n\n    int w = int(iChannelResolution[0].x);\n\n    ivec4 encodedTriplet1 = ivec4(readVec4(tripletByteIndex, w));\n    ivec4 encodedTriplet2 = ivec4(readVec4(tripletByteIndex + 4, w));\n\n    ivec3 triplet1 = base64_decode(encodedTriplet1);\n    ivec3 triplet2 = base64_decode(encodedTriplet2);\n\n    int byteOffset = byteIndex % 3;\n\n    ivec4 quad = ivec4(triplet1.xyz, triplet2.x);\n    if (byteOffset == 1) quad = ivec4(triplet1.yz, triplet2.xy);\n    if (byteOffset == 2) quad = ivec4(triplet1.z, triplet2.xyz);\n\n    return quad;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(base64DecodeTexture(fragCoord, 512)) / 255.0;\n    for (int i = 0; i < BENCHMARK_ITERATIONS; i++) {\n      fragColor += vec4(base64DecodeTexture(fragCoord + vec2(float(i*37), float(i*17)), 512));\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}