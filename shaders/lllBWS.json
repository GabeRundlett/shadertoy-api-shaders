{
    "Shader": {
        "info": {
            "date": "1513187612",
            "description": "Draw massive amount of particles while avoiding the cost of systematic splat ( N*R.x*R.y )\nBy first registering particles in tiles LxL (4 slots per tiles) then deferred rendering.\nSome collisions are treated, but statistically not all.\n-> speed-up ~ L² ",
            "flags": 32,
            "hasliked": 0,
            "id": "lllBWS",
            "likes": 20,
            "name": "display massive particles",
            "published": 3,
            "tags": [
                "2d",
                "sprites",
                "splatting"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1451
        },
        "renderpass": [
            {
                "code": "// === draw massive amount of particles while avoiding the cost of systematic splat ( N*R.x*R.y )\n// By first registering particles in tiles LxL (4 slots per tiles) then deferred rendering.\n// Note that the structure can also be used to cheaply compute particle interactions.\n    \n#define L 8.                                      // tile size\n\n#define T(U)     texelFetch(iChannel0, ivec2(U), 0)\n#define shape(P) vec4( clamp( L/2. - length(P.xy-U), 0., 1. ) ) * hue(P.z)\n#define hue(h)  ( .6 + .6 * cos( 6.3 * (h)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 O,  vec2 U )\n{   \n    O -= O;\n    vec4 T = T(U/L);  \n    \n    int s, _s=0, Rx = int(iResolution.x);\n\n# if 1                                  // opt: seek neighboor tiles to correct truncated collisions\n  for (int c=0; c<9; c++) { T = T(U/L + vec2(c%3-1,c/3-1)); // (we should avoid redrawing sames)\n#else\n  {\n#endif\n    for (int i=0; i<4; i++) {           // test all slots of tile map of resolution R/L\n        s = int(T[i]);                  // particles id \n        if (s > 0 && s!= _s) {          // a particle is there, not duplicated\n            O += (1.-O) * shape( texelFetch(iChannel1, ivec2(s%Rx,s/Rx), 0) ); // draw particle\n            _s = s;\n        }\n    }\n  }\n    \n#if 0                                   // display tile grid\n    T = sign(T); O += (1.-O) * dot(T,T)/4.;\n    U = mod(U-.5,L); if ( U.x*U.y == 0.) O++; \n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// --- simulates particles\n\n#define rnd(p) fract( 3758.5453 * sin( (p) * mat2( 127.1,311.7, 269.5,183.3 )))\n\nvoid mainImage( out vec4 O,  vec2 U )\n{   \n    vec2 R = iResolution.xy;\n    float t = iTime*512./R.x,\n          N = R.x*R.y/400.; // 5000.;                     // number of particles to simulate\n    \n    U -= .5;\n    if (U==vec2(0)) \n        O.x = N;                                          // store N in (0,0)\n    else if (U.x * R.x * U.y < N ) {                      // for each particles:\n        O.zw = rnd(U+.5);                                 // store attributes\n        t -= O.w*6.28;\n        O.xy = ( rnd(U) + .1*vec2(cos(t),sin(t)) ) * R;   // store position\n       }\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// --- register particles id in tiles ( 4 slots availables to reduce collisions )\n//     by splating Bbox at window resolution R/L ( L² times less costly )\n//     We can't insert in slots, so we use random slot registration strategy.\n\n#define L 8.                                      // tile size\n\n#define  rnd(p)          fract( 3758.5453 * sin( dot( p, vec2 ( 127.1,311.7 ))))\n#define irnd(p) int( 4.* fract( 3758.5453 * sin( (p) * 78.233 )))\n\n#define T(i,j)  texelFetch(iChannel0, ivec2(i,j), 0)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U *= L;\n    if ( U.x > R.x || U.y > R.y ) return;\n    O -= O;\n    \n    int Rx = int(R.x), \n        N = int( T(0,0).x );                      // number of particles\n    float ofs = rnd(U/L) * float(N);\n    \n    for (int i=1; i<=N; i++) {                    // test every particles\n        vec2 D = abs( T(i%Rx,i/Rx).xy - U );      // particle pos\n        if ( max(D.x,D.y) < L ) {                 // Bbox of particle falls in tile\n            float p = float(i);\n            O[irnd(p+U)]    = p;                  // store particle id at random slot\n#if 1                                             // strategy: store in 2 random slots over 4\n            O[irnd(p+U+.5)] = p;                  // ( proba 2-collision = 1/6 )\n#endif\n        }\n    }   \n }",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}