{
    "Shader": {
        "info": {
            "date": "1610224884",
            "description": "Trying to learn raymarching, so wrote a mini hill climb racing version.\n\nLearned a lot from examples around shadertoy, so thanks to everyone!\n\nShader originally written to fit into a \"playable\" 4k executable and then transferred here",
            "flags": 0,
            "hasliked": 0,
            "id": "3ldcWs",
            "likes": 4,
            "name": "Mini Hill Climb Racing",
            "published": 3,
            "tags": [
                "raymarching",
                "mini",
                "hcr",
                "hillclimbracing"
            ],
            "usePreview": 1,
            "username": "tonifing",
            "viewed": 422
        },
        "renderpass": [
            {
                "code": "/*\nA learning experience into shaders and raymarching.\n\nOriginally written to fit into a \"playable\" 4k executable.\n\nLots of things learned and copy pasted from: https://iquilezles.org/\nAlso used Leviathan 2.0 for the 4k, there's a lot learned from it and some code present: https://github.com/armak/Leviathan-2.0\n*/\n\nvec4 m;\nvec2 v;\n\nvec3 jeep;\nvec3 frontWheelOffset = vec3(0.9, -0.4, -0.7);\nvec3 rearWheelOffset = vec3(-0.9, -0.4, -0.7);\n\n//These are used as constants\nvec3 cFrontWheelOffset = vec3(0.9, -0.25, -0.7);\nvec3 cRearWheelOffset = vec3(-0.9, -0.25, -0.7);\n\nvec3 lightPos;\n\nfloat PI = 3.1416;\n\nfloat hash(float c){return fract(sin(dot(c, 12.9898)) * 43758.5453);}\n\n//Rotation\nmat3 rx(float a){return mat3(1.0,0.0,0.0,0.0,cos(a),-sin(a),0.0,sin(a),cos(a));}\nmat3 ry(float a){return mat3(cos(a),0.0,sin(a),0.0,1.0,0.0,-sin(a),0.0,cos(a));}\nmat3 rz(float a){return mat3(cos(a),-sin(a),0.0,sin(a),cos(a),0.0,0.0,0.0,1.0);}\n\n//Smoothmin, can be used to \"blend\" 2 distancefields together smoothly\nfloat opSmoothMin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nvec2 opUnion(vec2 d1, vec2 d2)\n{\n\t//min(d1,d2);\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opSubtract(vec2 d1, vec2 d2)\n{\n\t//max(-d1,d2);\n\treturn ((-d1.x)>d2.x) ? -d1 : d2;\n}\n\nvec2 opIntersect(vec2 d1, vec2 d2)\n{\n\t//max(d1,d2);\n\treturn (d1.x>d2.x) ? d1 : d2;\n}\n\n\n//Slightly simplified original equation for HCR1: Countryside\nfloat heightAt(float x)\n{\n\tx*=1.5;\n    x+=10.0;\n\treturn (cos(x/10.0)*2.0 +\n\t\t    +(cos(x+(sin(x*0.25)))*0.2*min(x*0.0015, 1.0f))\n\t        +(cos(x*0.17+(sin(x*0.25)))*2.0*min(x*0.00075, 1.0f))\n\t        +(cos(x*0.0952+(sin(x*0.15)))*2.0*min(x*0.00275, 1.0f))\n\t\t    +(-1.0 + sin(x/30.0+cos(x/32.14))*4.0*min(x*0.00075, 1.0f)))\n\t\t\t*(0.5+x/2000.0);\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n\treturn max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinderXZ( vec3 p, float h, float r )\n{\n  //p.x += 1.0-sin(PI*0.5-(r + p.y)*m.y*0.1);\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCircle2D(vec2 p, vec2 c, float r)\n{\n\tfloat m = 0.1+max(dot(normalize(p-c), normalize(vec2(1, -1))), 0.0)*1.9;\n\treturn clamp(1.0-pow(1.0-(length(p-c)-r)*2.5, 0.075*m), 0.0, 1.0);\n}\n\nvec3 getMaterialColor(vec3 p, float material)\n{\n\tint c=int(material);\n\tif (c==0) return mix(vec3(36.0, 212.0, 255.0)/255.0, vec3(161.0, 236.0, 255.0)/255.0, v.y); //Skycolor \n\tif (c==1) return mix(vec3(98.0, 169.0, 0.0) / 255.0, vec3(173.0, 234.0, 81.0) / 255.0, pow(1.0-clamp(abs(p.z-4.0)/1.9, 0.0, 1.0), 0.1));\t//Surface color\n\tif (c==2) return vec3(98.0 , 169.0, 0.0  ) / 255.0; //Guess I forgot to use this\n\tif (c==3) //Terrain (underground part)\n\t{\n\t\t//Texture some circles for this material\n\t\tvec2 q = mod(p.xy*0.5+0.5*5.0,5.0)-0.5*5.0;\n\t\t\n\t\tfloat d = sdCircle2D(q, vec2(0.1, 0.5), 0.3);\n\t\td = max(d, sdCircle2D(q, vec2(1.5, -0.5), 0.25));\n\t\td = max(d, sdCircle2D(q, vec2(-0.5, -1.5), 0.17));\n\t\td = max(d, sdCircle2D(q, vec2(2.0, 1.5), 0.08));\n\t\td = max(d, sdCircle2D(q, vec2(-2.0, 0), 0.05));\n\t\t\n\t\t//Repeat a few circle on edge of texture to simulate tiling\n\t\td = max(d, sdCircle2D(q, vec2(0.5, -2.7), 0.08));\n\t\td = max(d, sdCircle2D(q, vec2(0.5, 2.3), 0.08));\n\t\t\n\t\td = max(d, sdCircle2D(q, vec2(2.8, -2.0), 0.08));\n\t\td = max(d, sdCircle2D(q, vec2(-2.2, -2.0), 0.08));\n\t\treturn vec3(63.0 , 50.0 , 34.0 ) / 255.0*(2.0-d);\n\t}\n\tif (c==4) return vec3(168.0, 0.0  , 0.0  ) / 255.0; //Jeep chassis\n\tif (c==5) return vec3(50.0 , 50.0 , 50.0 ) / 255.0; //Jeep tires\n\tif (c==6) return vec3(150.0, 150.0, 150.0) / 255.0; //Jeep rims\n\tif (c==7) return vec3(192.0, 74.0 , 81.0 ) / 255.0; //Bill: Clothes red\n\tif (c==8) return vec3(207.0, 191.0, 168.0) / 255.0*1.1; //Bill: Head\n\tif (c==9) return vec3(225.0, 211.0, 196.0) / 255.0*1.2; //Bill: Eyes\n\n\treturn vec3(0,1,0);\n}\n\nfloat getMaterialReflectivity(float material)\n{\n\tif (material==1.0) return 0.1; //Terrain, just a little to see the jeep from the ground\n\tif (material==4.0) return 0.2; //Jeep chassis\n\tif (material==6.0) return 0.4; //Jeep rims\n\treturn 0.0;\n}\n\nfloat getMaterialSpecular(float material)\n{\n\tif (material == 1.0) return 0.0; //No specular on terrain surface\n\tif (material >= 7.0) return 0.05; //Only minimal specular on bill\n\t\n\treturn 1.0;\n}\n\nfloat materialAmbient(float material)\n{\n\tif (material==3.0) return 0.65; //Terrain\n\tif (material==4.0) return 0.4; //Jeep chassis\n\tif (material==5.0) return 0.3; //Jeep tires\n\treturn 0.2;\n}\n\n//This defines our whole scene content, it returns distance to a point in the world\nvec2 map(vec3 p, bool shadowPass)\n{\n\tvec2 d = vec2(100.0, 0.0);\n\t\n\t//Terrain\n\tif (!shadowPass)\n\t{\n\t\t//Terrain\n\t\td = opIntersect(vec2(p.y - heightAt(p.x), 1.0),\n\t\t\t\t\t    vec2(-sdPlane(p, vec3(0.0, 0.0, 1.0), -2.0), 3.0));\n\t\t\n\t\t//Sky plane\n\t\td = opIntersect(d, vec2(-sdPlane(p, vec3(0.0, 0.0, -1.0), 6.0), 3.0));\n\t}\n\n\tvec2 dfJeep = opUnion(vec2(100.0, 0.0),\n\t\t\t\t\tvec2(\n\t\t\t\t\t\topSmoothMin(\n\t\t\t\t\t\t\topSmoothMin(\n\t\t\t\t\t\t\t\topSmoothMin(\n\t\t\t\t\t\t\t\t\tsdRoundBox((p-jeep)*rz(m.z), vec3(1.6, 0.3, 0.8),0.1), //Chassis\n\t\t\t\t\t\t\t\t\tsdRoundBox((p-(jeep + vec3(0.45, 0.6, 0.0)*rz(-m.z)))*rz(m.z-0.3), vec3(0.05, 0.25, 0.7),0.03), //Windscreen\n\t\t\t\t\t\t\t\t\t0.1),\n\t\t\t\t\t\t\t\tsdRoundBox((p-jeep-vec3(-1.65,0.37,0)*rz(-m.z))*rz(m.z+0.7), vec3(0.1, 0.02, 0.65),0.065), //Spoiler\n\t\t\t\t\t\t\t\t0.12),\n\t\t\t\t\t\t\tsdRoundBox((p-jeep-vec3(1.05,0.4,0)*rz(-m.z))*rz(m.z-0.15), vec3(0.2, 0.1, 0.25),0.035), 0.05),\t//Scoop\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t4.0)\n\t\t\t\t\t); \n\t//dfJeep = opSmoothMin(dfJeep, vec2(sdRoundBox((p-jeep-vec3(1.2,0.45,0)*rz(-m.z))*rz(m.z-0.2), vec3(0.2, 0.1, 0.25),0.035), 4.0); //Scoop\n\t\t\t\t\t\t\n\t//Jeep: Interior\n\tdfJeep = opIntersect(dfJeep, vec2(-sdBox((p-jeep-vec3(-0.2,0.1,0)*rz(-m.z))*rz(m.z), vec3(0.6, 0.5, 0.7)), 5.0));\n\t\n\t//Bumper\n\tdfJeep = opUnion(dfJeep, vec2(sdRoundBox((p-jeep-vec3(0.0,-0.3,0)*rz(-m.z))*rz(m.z), vec3(1.7, 0.05, 0.85),0.1), 5.0));\n\t\n\t//Car wheels\n\t{\n\t\tvec3 q = p;\n\t\t//Wheels\n\t\tq.z = abs(q.z-jeep.z)+2.4;\n\t\tdfJeep = opIntersect(dfJeep, vec2(-sdCappedCylinder((q-(jeep + cFrontWheelOffset*rz(-m.z)))*rz(m.z-0.3), 0.55, 0.2), 5.0));\n\t\tdfJeep = opIntersect(dfJeep, vec2(-sdCappedCylinder((q-(jeep + cRearWheelOffset*rz(-m.z)))*rz(m.z-0.3), 0.55, 0.2), 5.0));\n\t\t\n\t\t//Wheel covers\n\t\tq.z = abs(p.z-jeep.z)+2.5;\n\t\tdfJeep = opUnion(dfJeep, vec2(sdCappedCylinder((q-(jeep + frontWheelOffset*rz(-m.z)))*rz(m.z-0.3), 0.5,0.2), 5.0));\n\t\tdfJeep = opUnion(dfJeep, vec2(sdCappedCylinder((q-(jeep +  rearWheelOffset*rz(-m.z)))*rz(m.z-0.3), 0.5,0.2), 5.0));\n\t\t\n\t\t//Rims\n\t\tdfJeep = opUnion(dfJeep, vec2(sdCappedCylinder((q-(jeep + frontWheelOffset*rz(-m.z)))*rz(m.z-0.3), 0.3,0.21), 6.0));\n\t\tdfJeep = opUnion(dfJeep, vec2(sdCappedCylinder((q-(jeep +  rearWheelOffset*rz(-m.z)))*rz(m.z-0.3), 0.3,0.21), 6.0));\n\t}\n\t\n\t//Seat\n\tdfJeep = opUnion(dfJeep, vec2(sdRoundBox((p-jeep-vec3(-0.6,0.15,0)*rz(-m.z))*rz(m.z-0.2), vec3(0.05, 0.4, 0.5),0.1), 5.0));\n\t\n\t//Now put together with scene\n\td = opUnion(d, dfJeep);\n\t\n\t//Antenna\n\td = opUnion(d, vec2(sdCappedCylinderXZ((p-(jeep + vec3(-1.2, 1.2, 0.4)*rz(-m.z)))*rz(m.z), 0.075,0.8), 5.0));\n\t\n\t//Bill himself\n\t//Torso\n\tfloat fd = opSmoothMin(\n\t\t\t\t\tsdRoundBox((p-jeep-vec3(-0.15,0.3,0)*rz(-m.z))*rz(m.z-0.2), vec3(0.1, 0.45, 0.35),0.1),\n\t\t\t\t\tsdSphere((p-jeep-vec3(-0.15,0.3,0)*rz(-m.z))*rz(m.z), 0.55),\n\t\t\t\t\t0.2);\n\tfd = opSmoothMin(fd, sdSphere((p-jeep-vec3(0.05,0.67,-0.2)*rz(-m.z))*rz(m.z), 0.15), 0.1);\n\tfd = opSmoothMin(fd, sdSphere((p-jeep-vec3(0.05,0.67,0.2)*rz(-m.z))*rz(m.z), 0.15), 0.1);\n\td = opUnion(d, vec2(fd, 7.0));\n\t\t\n\t//Head\n\td = opUnion(d, vec2(sdSphere((p-jeep-vec3(-0.35,1.2,0)*rz(-m.z))*rz(m.z), 0.35), 8.0));\n\t\t\n\t//Nose\n\td = opUnion(d, vec2(sdSphere((p-jeep-vec3(-0.05,1.2,0)*rz(-m.z))*rz(m.z), 0.125), 8.0));\n\t\t\n\t//Eyes\n\td = opUnion(d, vec2(sdSphere((p-jeep-vec3(-0.125,1.3,0.12)*rz(-m.z))*rz(m.z), 0.12), 9.0));\n\td = opUnion(d, vec2(sdSphere((p-jeep-vec3(-0.125,1.3,-0.12)*rz(-m.z))*rz(m.z), 0.12), 9.0));\n\t\t\n\td = opUnion(d, vec2(sdSphere((p-jeep-vec3(-0.0,1.32,0.12)*rz(-m.z))*rz(m.z), 0.04), 5.0));\n\td = opUnion(d, vec2(sdSphere((p-jeep-vec3(-0.0,1.32,-0.12)*rz(-m.z))*rz(m.z), 0.04), 5.0));\n\t\t\n\t//Hat\n\tvec2 dHat = opIntersect(vec2(sdSphere((p-jeep-vec3(-0.38,1.25,0)*rz(-m.z))*rz(m.z), 0.35), 7.0),\n\t\t\t\t\t        vec2(sdPlane((p-jeep-vec3(-0.38,1.25,0)*rz(-m.z))*rz(m.z), normalize(vec3(0.6,-1.0,0.0)), 0.1), 7.0));\n\t\t\n\tfloat hatCurve = min(pow(abs(4.0-p.z), 2.0), 1.0);\n\tdHat.x = opSmoothMin(dHat.x, sdRoundBox((p-jeep-vec3(-0.8+hatCurve,1.2-hatCurve*0.6,0)*rz(-m.z))*rz(m.z-0.5), vec3(0.2, 0.02, 0.24),0.02),0.07);\n\td = opUnion(d,dHat);\n\treturn d;\n}\n\nvec3 rhs(vec3 dir, float i)\n{\n\tvec2 rnd = vec2(hash(i+1.), hash(i+2.));\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\tvec3 v = vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n\treturn v * sign(dot(v, dir));\n}\n\nfloat ao( vec3 p, vec3 n, float maxDist, float falloff)\n{\n\tfloat ao = 0.0;\n\tfor( int i=0; i<10; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = normalize(n+rhs(n, l )*0.95)*l;\n\t\tao += (l - map( p + rd, false).x) / pow(1.+l, falloff);\n\t}\n\treturn clamp(1.-ao*0.1,0.0,999.0);\n}\n\nvec3 normal(vec3 p)\n{\n    // Copy from iq shader.\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.0005*e, false).x;\n    }\n    return normalize(n);\n}\n\n//Raymarch soft shadows\nfloat softshadow( vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n    float res = maxt;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t, true).x;\n        if( h<0.001 )\n            return 0.0;\n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h*0.5+0.01;\n    }\n    return res;\n}\n\n//This goes forward until close enough to a surface\nvec3 raymarch( vec3 ro, vec3 rd, out float material, const int iterationCount, const float step)\n{\n\tvec3 p = ro;\n\tvec2 d;\n\tfloat t = .0;\n\tfor(int i=0; i<iterationCount; i++)\n\t{\n\t\td = map(p, false);\n\t\tif( d.x < 0.01)\n\t\t{\n\t\t\tmaterial = d.y;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (t > 100.0)\n\t\t{\n\t\t\tmaterial = 0.0;\n\t\t\treturn p;\n\t\t}\n\t\t\n\t\tt += d.x*step;\n\t\tp += rd*d.x*step;\n\t}\n\tmaterial = d.y;\n\treturn p;\n}\n\nvec3 shade(vec3 p, vec3 n, vec3 rd, float material)\n{\n\tfloat light = 1.0;\n\t\n\tif (material > 0.0)\n\t{\n\t\tvec3 lightDir = normalize(lightPos-p);\n\t\tfloat lightPower = 1.0-length(lightPos-p)*0.0005;\n\n\t\t//Calculate shadows into our lighting\n\t\tfloat shadowMul = 0.5;\n\t\tif (material != 3.0)\n\t\t\tshadowMul = softshadow(p, normalize(lightPos-p), 0.1, 20.0 , 12.0);\n\t\t\t\t\n\t\tlightPower = lightPower*0.5f + shadowMul*0.5;\n\t\tlightPower = max(min(lightPower, 1.0), 0.0);\n\t\t\n\t\tfloat ambient = materialAmbient(material);\n\t\t\n\t\t//Calculate diffuse and specular light and ambient occlusion (specular only on jeep)\n\t\tfloat lightDiff = ambient + max(dot(n, lightDir), 0.0) * lightPower * 1.0 * ao(p, n, 2.0, 2.0)*0.7;\n\t\t\n\t\tfloat lightSpec = pow(max(dot(reflect(rd, n), lightDir), 0.0), 8.0) * getMaterialSpecular(material);\n\t\tlight = (lightDiff + lightSpec);\n\t}\n\treturn getMaterialColor(p, material) * light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n\tvec2 v = -1.0+2.0*q;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\t//Scale our input vector back to float\n\tm.x = iTime*5.0;// = vec4(inVec) / 44100.0;\n    m.y = heightAt(m.x)+1.0;\n    m.z = atan(heightAt(m.x-0.7) - heightAt(m.x+0.7));\n    m.w = iTime*5.0;\n\t\n\t//Set jeep position from our input data\n\tjeep = vec3(m.x, m.y, 4.0);\n\t\n\t//Wheel suspension \"simulation\"\n\tvec3 wp = jeep + frontWheelOffset*rz(-m.z);\n\tif (heightAt(wp.x) < wp.y) frontWheelOffset.y = clamp(heightAt(wp.x) - wp.y, -0.8, -0.35) + 0.1;\n\twp = jeep + rearWheelOffset*rz(-m.z);\n\tif (heightAt(wp.x) < wp.y) rearWheelOffset.y = clamp(heightAt(wp.x) - wp.y, -0.8, -0.35) + 0.1;\n\n\t//Camera position\n\tfloat zoom = 0.5+pow(abs(m.x - m.w)*0.07,1.7);\n\tvec3 ro = vec3(m.w,23.0*zoom,-30.0*zoom);\n\t\n\t//Camera rotation\n\tmat3 rot = rx(0.5)*ry(clamp((m.x - m.w)/30.0, -0.5, 0.5));\n\t\n\t//Calculate average terrain height to offset camera\n\tfloat h = 0.0;\n\tfor (int i = 0; i < 20; i++)\n\t{\n\t\th +=heightAt(-5.0+ro.x+float(i)*1.0);\n\t}\n\th/=20.0;\n\tro.y += h;\n\tro += vec3( v.x, v.y, 0) * rot;\n\tvec3 rd = normalize(vec3(v.x, v.y, 7.0-abs(m.x - m.w)/4.0))*rot;\n\t\n\t//Define light position\n\tlightPos = vec3(ro.x+20.0, ro.y+20.0, 3.0);\t\t\n\n\tfloat material;\n\tvec3 p = raymarch(ro, rd, material, 80, 0.7);\n\t\t\n\tvec3 col = getMaterialColor(p, material);\n\tvec3 n = normal(p);\n\t\n\t//Calculate Lighting with a single point light (only on pixels that are not sky or terrain)\n\tif (material > 0.0)\n\t{\n\t\tcol = shade(p, n, rd, material);\n\t\t\n\t\tfloat refl = getMaterialReflectivity(material);\n\t\t//Add reflection\n\t\tif (refl > 0.0)\n\t\t{\t\n\t\t\tfloat rMaterial;\n\t\t\tvec3 rrd = reflect(rd, n);\n\t\t\tvec3 rp = raymarch(p + n*0.05, rrd, rMaterial, 60, 1.0);\n\t\t\tvec3 rn = normal(rp.xyz);\n\t\t\tvec3 rColor = shade(rp, rn, rrd, rMaterial);\n\t\t\t\n\t\t\tcol += rColor*refl;// * max(pJeep, pSurface*1.5);\t\t\t\n\t\t}\n\t}\n\n\tfragColor = vec4(col, 1);\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}