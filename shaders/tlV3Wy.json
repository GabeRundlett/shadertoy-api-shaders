{
    "Shader": {
        "info": {
            "date": "1579807574",
            "description": "Emissive Effect with Japanease traditional textile",
            "flags": 0,
            "hasliked": 0,
            "id": "tlV3Wy",
            "likes": 12,
            "name": "Emissive Effect",
            "published": 3,
            "tags": [
                "reflection",
                "emission"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 527
        },
        "renderpass": [
            {
                "code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 25.\n#define SURF_DIST .01\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) 1.0-smoothstep(b,antialiasing(1.0),d)\n\nfloat dBox2d(vec2 p, vec2 b) {\n    return max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n// Try to add a glow color to the model, depending on the world position.\nvec3 emitColor(vec3 p, vec3 emitPos, vec3 emitColor, float radius, float softness, float brightness) {\n    float c = smoothstep(-softness,softness,-(length(p-emitPos)-radius));\n    emitColor = (emitColor*c)*brightness;\n    return emitColor;\n}\n\nfloat linear(float t) {\n  return t;\n}\n\n// A smart way to control the animation. function is from \"http://qiita.com/gaziya5/items/29a51b066cb7d24983d6\"\nfloat animscene(in float t, float w, float s) {\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nvec4 Layer1(vec3 p,  float z, float speed, float dir, mat3 rot) {\n    p.z += iTime*3.0;\n    p.z += z;\n    p.z = mod(p.z,9.0)-4.5;\n    \n    p *= rot*matRotateX(radians(30.0*dir))*matRotateY(radians(40.0*dir));\n    p.y+=1.25;\n    \n    float y = 0.25;\n    \n    // box\n    float b = sdBox(p-vec3(0.0,1.0+y,0.0),vec3(1.5,2.5,0.2));\n    float b2 = sdBox(p-vec3(0.0,1.0+y,0.0),vec3(1.2,2.2,0.3));\n\n    float animTime = mod(iTime,speed*4.0);\n    float ey = 0.0;\n    ey += linear(animscene(animTime, 0.0, speed))*5.0;\n    ey += linear(animscene(animTime, speed*2.0, speed))*-5.0;\n    \n    float ex = 0.0;\n    ex += linear(animscene(animTime, speed, speed))*2.6;\n    ex += linear(animscene(animTime, speed*3.0, speed))*-2.6;\n    \n    vec3 emitPos = vec3((1.3*dir)-(ex*dir),1.25+(2.5-ey),0.0);\n    vec3 ecol = emitColor(p,emitPos, vec3(0.0,0.7,0.8),0.02,0.9,5.0);\n    \n    float d = max(-b2,b);\n    if(dir == 1.0){\n    \tp *= matRotateZ((z == 6.0) ?radians(30.0):radians(-30.0));\n\t\td = (z == 6.0) ?max(-p.y+0.5,max(-b2,b)):max(p.y-1.5,max(-b2,b));\t\n    }\n    \n    vec4 res = vec4(vec3(0.8)+ecol,d);\n    return res;\n}\n\nvec4 GetDist(vec3 p) {\n    vec3 prevP = p;\n    float _floor = p.y;\n    \n    vec4 layer1 = Layer1(p,0.0,0.5,1.0,matRotateZ(radians(iTime*50.0)));\n    vec4 layer2 = Layer1(p,3.0,1.0,-1.0,matRotateZ(radians(iTime*-60.0)));\n    vec4 layer3 = Layer1(p,6.0,1.5,1.0,matRotateZ(radians(iTime*70.0)));\n\tvec4 layers = combine(layer1,combine(layer2,layer3));\n\n    return layers;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = GetDist(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\nfloat GetAmbientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - RayMarch(p + n*d,n).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,8,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n\n    float ao = GetAmbientOcclusion(p,n);\n    \n    float lambert = max(.0, dot( n, l))*0.1;\n    \n    float shadow = shadowMap(p + n * 0.001, l);\n    \n    return vec2((lambert+dif*ao),max(0.9, shadow)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nfloat typoNine(vec2 p) {\n    float c0 = sdUnevenCapsule(p*Rot(radians(90.0)),0.15,0.15,0.14);\n    float c1 = sdUnevenCapsule(p*Rot(radians(90.0)),0.07,0.07,0.14);\n    float cut0 = dBox2d((p+vec2(-0.26,-0.04))*Rot(radians(20.0)),vec2(0.08,0.08));\n    float cut1 = dBox2d(p+vec2(-0.32,0.1),vec2(0.2,0.1));\n    float c2 = length(p+vec2(-0.12,0.11))-0.04;\n    float topC = min(max(-cut1,max(-cut0,max(-c1,c0))),c2);\n    \n    vec2 btmP = vec2(0.1,0.11);\n    c0 = sdUnevenCapsule((p+btmP)*Rot(radians(90.0)),0.15,0.15,0.22);\n    c1 = sdUnevenCapsule((p+btmP)*Rot(radians(90.0)),0.07,0.07,0.22);\n    c2 = length(p+btmP+vec2(-0.1,-0.11))-0.04;\n    cut0 = dBox2d((p+vec2(-0.05,0.2)),vec2(0.08,0.08));\n    float btmC = max(-cut0,min(max(-p.x-btmP.x+0.1,max(-c1,c0)),c2));\n    \n    return min(topC,btmC);\n}\n\nvec3 jpTraditionalTex(vec2 p, vec3 col, vec3 lcol) {\n    p.y -= iTime*0.1;\n    p*=1.5;\n    p = mod(p,0.4)-0.2;\n\n    \n    float len = 0.2;\n    float len2 = 0.15;\n    float l = sdLine(p,vec2(-len,-len),vec2(len,len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(-len,len),vec2(len,-len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(0.0,len),vec2(0.0,-len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(-len,0.0),vec2(len,0.0));\n\tcol = mix(col,lcol,S(l,0.0));\n    \n\tl = sdLine(p,vec2(-len*0.3,-len2),vec2(len*0.3,len2));\n\tcol = mix(col, lcol,S(l,0.0));\n\tl = sdLine(p,vec2(-len*0.7,-len2*0.4),vec2(len*0.7,len2*0.4));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(-len*0.3,len2),vec2(len*0.3,-len2));\n\tcol = mix(col, lcol,S(l,0.0));    \n    l = sdLine(p,vec2(-len*0.7,len2*0.4),vec2(len*0.7,-len2*0.4));\n\tcol = mix(col,lcol,S(l,0.0));\n    \n\tl = sdLine(p,vec2(0.0,len),vec2(len*0.3,len2));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(0.0,len),vec2(-len*0.3,len2));\n\tcol = mix(col, lcol,S(l,0.0));\n\tl = sdLine(p,vec2(0.0,-len),vec2(len*0.3,-len2));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(0.0,-len),vec2(-len*0.3,-len2));\n\tcol = mix(col, lcol,S(l,0.0));\n    \n\tl = sdLine(p,vec2(len,0.0),vec2(len*0.7,len2*0.4));\n\tcol = mix(col, lcol,S(l,0.0));\n\tl = sdLine(p,vec2(len,0.0),vec2(len*0.7,-len2*0.4));\n\tcol = mix(col, lcol,S(l,0.0));\n\tl = sdLine(p,vec2(-len,0.0),vec2(-len*0.7,len2*0.4));\n\tcol = mix(col, lcol,S(l,0.0));\n\tl = sdLine(p,vec2(-len,0.0),vec2(-len*0.7,-len2*0.4));\n\tcol = mix(col, lcol,S(l,0.0));\n    \n    l = sdLine(p,vec2(len*0.3,len2),vec2(len,len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(len*0.7,len2*0.4),vec2(len,len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(-len*0.3,-len2),vec2(-len,-len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(-len*0.7,-len2*0.4),vec2(-len,-len));\n\tcol = mix(col, lcol,S(l,0.0));    \n    \n\tl = sdLine(p,vec2(-len*0.3,len2),vec2(-len,len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(-len*0.7,len2*0.4),vec2(-len,len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(len*0.3,-len2),vec2(len,-len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(len*0.7,-len2*0.4),vec2(len,-len));\n\tcol = mix(col, lcol,S(l,0.0));      \n    \n    return col;\n}\n\nvec3 bg(vec2 p){\n    float d = smoothstep(0.0,0.2,p.y-sin(iTime*0.5)*0.5);\n  \tvec3 col = vec3(d);\n\tcol = mix(vec3(0.0,0.2,0.3), vec3(0.0,0.05,0.1),d);\n    \n\tcol = jpTraditionalTex(p,col,vec3(0.5));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec2 uvref = uv;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, -5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.xz *= Rot(radians(iTime*20.0));\n    ro.yz *= Rot(radians(-20.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n    \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 refl = bg(r.xy);\n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*d.xyz+refl;\n        col *= dif.y;\n    } else {\n        // background\n        col = bg(uv);\n    }\n    \n    uv*=0.45;\n\t\n    float nine = typoNine(uv+vec2(0.05,-0.055));\n    col = mix( col, jpTraditionalTex(uvref,col,vec3(0.0,1.3,0.5))-vec3(0.8), S(nine,0.005) );\n        \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}