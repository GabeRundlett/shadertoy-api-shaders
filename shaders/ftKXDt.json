{
    "Shader": {
        "info": {
            "date": "1642448040",
            "description": "This was mostly an experiment, so I'm probably not doing any of the mathematically correct techniques.\n\nLinks to sources for learning in code.",
            "flags": 0,
            "hasliked": 0,
            "id": "ftKXDt",
            "likes": 1,
            "name": " Awkward Mushroom",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 1,
            "username": "prishainabox",
            "viewed": 157
        },
        "renderpass": [
            {
                "code": "const float EPSILON = 0.001;\nconst float MAX_DIST = 60.0;\nconst int AA = 3;\nconst float FRESNEL_POWER = 5.0;\n\n//*******************************************************//\n\n// SDF MUSHROOM\n\nfloat sdMushroom(in vec3 pt, out Material mat) {\n\n\t// distance to closest object\n\tfloat res;\n\t\n\t// default\n\tmat = defaultMaterial();\n    mat.amb = 0.05;\n    \n    float ang = atan(pt.z, pt.x);\n    vec3 q = pt - vec3(0, 5, 0);\n    \n    // mushroom stalk\n    {\n        float stalk;\n        // cylinder\n        stalk = length(q.xz) - 1.6; \n        stalk = smoothmax(stalk, abs(pt.y - 5.0) - 3.0, 0.7);\n        // ellipsoid mushroom body\n        float r2 = 2.2 + sin(ang * 2.0) * 0.4;\n        stalk = smoothmin(stalk, sdEllipsoid(q - vec3(0, -3, 0), vec3(r2, 2.9, r2)), 4.0);\n        // ellipsoid top part that connects to head\n        float r3 = 3.6 + sin(ang*20.0) * 0.04;\n        stalk = smoothmin(stalk, sdEllipsoid(q - vec3(0, 3.5, 0), vec3(r3, 0.5, r3)), 1.5); \n        stalk += sin(ang * 15.0) * 0.2;\n    \n        // stalk\n        res = stalk;\n        mat.id = 1;\n        mat.fresnel = 0.5;\n   \n    }\n\n    // mushroom head\n    {\n        float head;\n        vec3 h = q - vec3(0, 2.2, 0);\n        float r1 = 5.6;\n        h.y -= 2.7 * smoothstep(r1, r1*0.2, length(h.xz));\n        head = sdEllipsoid(h, vec3(r1, 3, r1));\n        head = smoothmin(head, sdEllipsoid(h - vec3(4.0, 1, 0), vec3(1.8, 1.5, 4.0)), 2.5); // right\n        head = smoothmin(head, sdEllipsoid(h - vec3(-4.0, 1, -1), vec3(2.0, 1.0, 3.0)), 2.0); // left\n        head = smoothmax(head, -h.y, 0.8); // cut off bottom\n        head = smoothmax(head, -(length(h - vec3(0, -3, 0)) - r1*0.5), 0.7); // subtract a sphere on inside\n        head += pow((sin(ang*25.0)+1.0) * 0.5, 6.0) * 0.2 * smoothstep(12.0, 5.0, pt.y); // ridges\n\n        if (head < res) {\n            res = head;\n            mat.id = 2;\n            mat.spec = 1.0;\n            mat.shininess = 20.0;\n            // mushroom texture and color\n            mat.clr = vec3(0.04, 0.01, 0.02);\n            mat.clr += 0.1 * texture(iChannel1, pt.xy * 0.45).rgb;\n            // spots\n            vec2 section = vec2(ang * 13.0, length(pt.xz) * 0.7); // create a \"grid\" based on angle and radius (polar)\n            vec2 i = floor(section); // integer part\n            vec2 f = fract(section); // fractional part\n            float r = random(i); // random number\n            res -= mat.clr.r * 0.8; // bumpy texture\n            if (r > 0.6) {\n                float l = distance(f, vec2(0.5));\n                float c = smoothstep(0.5, 0.0, l); // for circle based on distance from center of \"grid cell\"\n                vec3 spotClr = 2.8 * vec3(0.055, 0.03, 0.011) * (0.5 + 0.5*random(floor(section*0.3)));\n                mat.clr = mix(mat.clr, spotClr, c); // mix red mushroom color and spot clr\n                // little depressions where spots are\n                float depressions = c * 0.28 * smoothstep(0.9, 0.7, l) * smoothstep(15.5, 10.0, pt.y); \n                res += depressions;\n            }\n        }\n    }\n      \n\treturn res;\n    \n}\n\n// MAIN SD FUNCTION\n\nfloat sdf(in vec3 pt, out Material mat) {\n    \n    // distance to closest object\n    float res;\n    \n    mat = defaultMaterial();\n    \n    // ground\n    vec3 groundClr = vec3(0.34, 0.2, 0.5) * 0.15 + 0.1*texture(iChannel2, pt.xz*0.04).rgb;\n    {\n        res = pt.y;\n        float ang = atan(pt.z,pt.x);\n        res -= smoothstep(15.0, 30.0, length(pt.xz)) * (5.0  + 4.0*fractalNoise(ang, 3));\n        res -= 0.2*noise(pt.xz) + 0.1*noise(pt.xz*2.0);\n        mat.id = 0;\n        mat.spec = 0.0;\n        mat.clr = groundClr;\n    }\n    \n    // the mushroom\n    if (length(pt - vec3(0, 6, 0)) < 10.0 && pt.y > 0.25) {\n        Material mushroomMat;\n        float mushroom = sdMushroom(pt, mushroomMat);\n        if (mushroom < res) {\n            res = mushroom;\n            mat = mushroomMat;\n        }\n        \n    }\n    \n    mat.groundBounceClr = groundClr * 3.0;\n    \n    return res;\n\n}\n\n//*******************************************************//\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pt) {\n\tvec2 h = vec2(EPSILON, 0);\n\tMaterial m;\n\t// central difference sdf(pt + EPSILON) - sdf(pt - EPSILON)    \n\treturn normalize(vec3(\n\t\tsdf(pt + h.xyy, m) - sdf(pt - h.xyy, m),\n\t\tsdf(pt + h.yxy, m) - sdf(pt - h.yxy, m),\n\t\tsdf(pt + h.yyx, m) - sdf(pt - h.yyx, m)\n\t));\n}\n\n//*******************************************************//\n\nfloat castRay(in vec3 ro, in vec3 rd, out Material mat) {\n\n\t// total distance traveled\n\tfloat td = 0.0;\n\t\n\tfor (int i = 0; i < 100; i++) {\n\t\tfloat h = sdf(ro + td*rd, mat);\n\t\t// if distance is really close, break\n\t\tif (abs(h) < (0.0001*td)) break;\n\t\t// add to total distance\n\t\ttd += h;\n\t\t// if too far, break\n\t\tif (td >= MAX_DIST) {\n\t\t\tmat.id = -1;\n\t\t\tmat.ref = vec3(0.0);\n\t\t\tmat.fresnel = 0.0;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn td;\n    \n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softShadow(in vec3 ro, in vec3 rd, in float k) {\n\tfloat res = 1.0; // result\n\tfloat td = 0.05; // total distance traveled\n\tfor (int i = 0; i < 200 && td < MAX_DIST; i++) {\n\t\tMaterial m;\n\t\tfloat d = sdf(ro + td*rd, m);\n\t\tif (d < 0.001) {\n\t\t\t// intersection, so return shadow\n\t\t\treturn 0.0;\n\t\t}\n\t\tres = min(res, k*d/td);\n\t\ttd += d;\n\t}\n\t// if no intersection -> shadow 0.0 to light 1.0\n\treturn res;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\n// ambient occlusion\nfloat calcOcc(in vec3 pt, in vec3 nor) {\n\n\tfloat occ = 0.0;\n\tfloat scl = 1.0;\n\t\n\tMaterial m; // placeholder\n\t\n\tfor (int i = 0; i < 5; i++) {\n\t\tfloat h = 0.01 + 0.11 * 0.25 * float(i);\n\t\tfloat d = sdf(pt + h * nor, m);\n\t\tocc += (h-d)*scl;\n\t\tscl *= 0.95;\n\t}\n\t\n\treturn uclamp(1.0 - 2.0 * occ);\n    \n}\n\n//*******************************************************//\n\nvec3 calcLighting(in vec3 pt, in vec3 rd, in vec3 nor, in Light light, in Material mat) {\n\n\t// diffuse\n\tfloat dif = uclamp(dot(nor, light.dir)) * mat.dif;\n\t\n\t// shadow\n\tfloat shadow = light.isPointLight ? 1.0 : softShadow(pt, light.dir, light.shadowSoftness);\n\t\n\t// specular\n\tvec3 ref = reflect(light.dir, nor);\n\tfloat spec = pow(uclamp(dot(rd, ref)), mat.shininess) * mat.spec;\n\n\t// return dif * clr * shadow * spec + dif * clr * shadow; \n\treturn light.brightness * light.clr * shadow * dif * (spec + 1.0);\n    \n}\n\n// https://iquilezles.org/articles/fog\nvec3 applyFog(in vec3 rd, in float d, in vec3 clr, in vec3 sunClr, in vec3 sunDir, in vec3 skyClr) {\n    // mix sun clr with sky clr to get fog clr\n\tvec3 fogClr = mix( skyClr, sunClr, pow(max(dot(rd, sunDir), 0.0), 15.0) );\n    // mix pixel clr with fog clr\n\treturn mix(clr, fogClr, 1.0 - exp(-0.00002 * d * d * d));\n}\n\n//*******************************************************//\n\nvec3 calcClr(in vec3 ro, in vec3 rd, in float d, in vec3 nor, inout Material mat) {\n\n\tvec3 pt = ro + rd * d;\n\n\t// COLORS\n\tvec3 skyClr = vec3(0.45, 0.4, 0.2) * 0.5;\n\t\n\t// LIGHTS\n    Light sky = createLight(pt, false, 1.0, 2.0, normalize(vec3(0, 1,  0)), skyClr);\n    Light sun = createLight(pt, false, 1.0, 25.0, normalize(vec3(-2, 0.1, -5)), vec3(10.0, 8.0, 3.7));\n\t\n\t// background color\n\tvec3 clr = skyClr;\n\n\t// return background if too far (id is -1.0)\n\tif (mat.id == -1) {\n\t\t// sun\n\t\tclr = mix(skyClr, sun.clr * 0.15, pow(max(dot(rd, sun.dir), 0.0), 10.0));\n\t\treturn clr;\n\t}\n    \n    // materials\n    \n    // stalk\n    if (mat.id == 1) {\n        mat.spec = 0.5;\n        mat.shininess = 5.0;\n        // stalk texture and color\n        mat.clr = vec3(0.07, 0.07, 0.045) * 1.15;\n        mat.clr += vec3(0.03) * sin(30.0 * atan(pt.z, pt.x)) * smoothstep(5.0, 8.0, pt.y);\n        mat.clr += texture(iChannel1, pt.xy * vec2(0.25, 0.15)).r * 0.06;\n        mat.clr -= (0.04 + 0.05 * smoothstep(4.0, -1.0, pt.y)) * texture(iChannel0, pt.yx * 0.3 + 0.1*sin(pt.z)).rgb;\n   }\n    \n    // mushroom fresnel\n    if (mat.id == 1 || mat.id == 2) {\n        mat.fresnel = 1.0 * -dot(vec3(0, -1, 0), nor);\n    }\n    \n    // material id is not -1.0, so we hit an obj\n\tclr = mat.clr;\n\t\n\t// LIGHTS\n\t\n\t// CALCULATE COLOR\n\tfloat occ = calcOcc(pt, nor); // ambient occlusion\n\tvec3 light = vec3(mat.amb); // ambient\n    light += calcLighting(pt, rd, nor, sky, mat); // sky diffuse\n    light += calcLighting(pt, rd, nor, sun, mat); // sun light\n    \n    // point lights\n    {\n        for (float r = 6.0; r < 20.0; r+=3.0) {\n            for (float i = 0.0; i < 6.0; i++) {\n                float ang = r + i + 2.0*random(r);\n                vec3 lpos = vec3(r * cos(ang), pt.y + 1.2, r * sin(ang));\n                vec3 lclr = vec3(50.0 + 20.0*random(fract(sin(i)*121.0)), 40.0 + 20.0*random(ang), 10.0 + 20.0*random(i*r*ang)) * (0.2 + 0.05*random(ang*r*i));\n                Light ptLight = createLight(pt, true, 2.0 + 1.5*fract(21.0*sin(r+i*20.0)), 5.9, lpos, lclr);\n                light += calcLighting(pt, rd, nor, ptLight, mat);\n            }\n        }\n    }\n    \n\tlight += (uclamp(dot(nor, vec3(0, -1, 0)))*0.8 + 0.2) * mat.groundBounceClr; // ground diffuse\n\n\tclr *= light * occ;\n\n\tclr = applyFog(rd, d, clr, sun.clr * 0.1, sun.dir, skyClr);\n\t\n\treturn clr;\n\n}\n\n//*******************************************************//\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    \n\tMaterial mat;\n\n\tfloat d = castRay(ro, rd, mat); // distance to point on object in scene\n\tvec3 nor = calcNormal(ro + rd*d); // surface normal\n\t\n\t// calculate color of the pixel\n\tvec3 clr = calcClr(ro, rd, d, nor, mat);\n\t\n\tbool willReflect = mat.ref.r > 0.0 || mat.ref.g > 0.0 || mat.ref.b > 0.0;\n\tif (mat.fresnel > 0.0 || willReflect) {\n\t\n\t\tint bounces = 1;\n\t\tvec3 ref = vec3(0.0);\n\t\tfloat fresnel = 0.5 * uclamp(pow(1.0 - dot(nor, -rd), FRESNEL_POWER));\n\t\t\n\t\t// if the material will reflect\n\t\tif (willReflect) {\n\t\t\tbounces = 3;\n\t\t\t// if reflective and doesn't have fresnel\n\t\t\tif (mat.fresnel == 0.0) ref = mat.ref;\n\t\t\t// if reflective with fresnel\n\t\t\telse ref = fresnel * mat.ref;\n\t\t} else {\n\t\t\tref = vec3(fresnel);\n\t\t}\n\t\t\n\t\t// bouncing around for fresnel and reflection\n\t\tvec3 fil = vec3(1.0);\n\t\tfor (int i = 0; i < bounces; i++) {\n\t\t\tfil *= ref;\n\t\t\t// to intersection point and reflect\n\t\t\tro += rd*d + nor*EPSILON*3.0;\n\t\t\trd = reflect(rd, nor);\n\t\t\t// find new point\n\t\t\td = castRay(ro, rd, mat);\n\t\t\tnor = calcNormal(ro + rd*d);\n\t\t\t// add color\n\t\t\tclr += fil * calcClr(ro, rd, d, nor, mat);\n\t\t\tif (mat.id == -1) break;\n\t\t}\n\t\t\t\n\t}\n\t\n\tclr = pow(clr, vec3(1.0 / 2.2)); // gamma correction\n\treturn clr;\n    \n}\n\n//*******************************************************//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    if (iFrame != 0) discard;\n\n\tvec2 res = iResolution.xy;\n    // float time = iTime * 0.5;\n\t\n\t// target\n\tvec3 target = vec3(0, 4.8, 0);\n\t// ray origin\n    vec3 ro = vec3(0, 4.2, 13);\n\t\n\t// accumulate color\n\tvec3 clr = vec3(0.0);\n\t\n\tfor (int i = 0; i < AA; i++) {\n\t\tfor (int j = 0; j < AA; j++) {\n\t\t\t// Normalized pixel coordinates\n\t\t\tvec2 f = gl_FragCoord.xy + vec2(float(i), float(j)) / float(AA);\n\t\t\tvec2 uv = (2.0*f - res) / min(res.x, res.y);\n\t\t\tvec3 rd = setCamera(uv, ro, target);\n\t\t\t// calculate color based on distance, etc\n\t\t\tclr += render(ro, rd);\n\t\t}\n\t}    \n\t\n\tclr /= float(AA*AA);\n\n\t// Output to screen\n\tfragColor = vec4(clr, 1.0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//*******************************************************//\n\n// Structs\n\n// Light struct\nstruct Light {\n    bool isPointLight;\n    vec3 clr;\n    float shadowSoftness; // higher number -> crisper shadows\n    // if isPointLight, set position, else set direction\n    vec3 pos;\n    vec3 dir;\n    float brightness;\n};\n\n// create a light\nLight createLight(in vec3 pt, in bool isPointLight, in float fadeAdjust, in float shadowSoftness, in vec3 dirOrPos, in vec3 clr) {\n\n    Light light;\n    light.clr = clr;\n    light.shadowSoftness = shadowSoftness;\n\n    if (isPointLight) {\n        // point light\n        light.pos = dirOrPos;\n        light.isPointLight = true;\n        // calculate brightness and direction\n        float d = distance(pt, light.pos);\n        d = pow(d, fadeAdjust);\n        light.brightness = 1.0 / (d * d);\n        light.dir = normalize(light.pos - pt);\n    } else {\n\t\t// directional light\n        light.brightness = 1.0;\n        light.dir = dirOrPos;\n    }\n\n    return light;\n\n}\n\n// Material struct\nstruct Material {\n    vec3 clr; // color\n    float amb; // ambient\n    float dif; // diffuse\n    float spec; // specular\n    float shininess;\n    vec3 ref; // reflect clr\n    float fresnel; // multiply fresnel calculated by float between 0.0 and 1.0\n    vec3 groundBounceClr; // bounce color from ground\n    int id; // unique identifier\n};\n\n// return a nondescript material\nMaterial defaultMaterial() {\n    Material mat;\n    mat.amb = 0.05;\n    mat.clr = vec3(0.05);\n    mat.dif = 1.0;\n    mat.spec = 1.0;\n    mat.shininess = 10.0;\n    mat.ref = vec3(0.0);\n    mat.fresnel = 0.0;\n    mat.groundBounceClr = vec3(0.0);\n    mat.id = -1;\n    return mat;\n}\n\n//*******************************************************//\n\n// clamp value from 0 to 1\nfloat uclamp(float val) {\n    return clamp(val, 0.0, 1.0);\n}\n\n// SMOOTH MIN from Inigo Quilez\n// https://iquilezles.org/articles/smin\n\nfloat smoothmin(in float a, in float b, in float k) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n\treturn mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smoothmax\nfloat smoothmax( float a, float b, float k ) {\n\tfloat h = max(k-abs(a-b),0.0);\n\treturn max(a, b) + h*h*0.25/k;\n}\n\n// Smooth min for distance and color\n// returns rgb and d in vec4\nvec4 smoothmin(in float a, in float b, in vec3 clr1, in vec3 clr2, in float k) {\n\tfloat h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n\t// distance\n\tfloat d = mix(b, a, h) - k*h*(1.0-h);\n\t// color\n\tvec3 c = mix(clr2, clr1, h);\n\treturn vec4(c, d);\n}\n\n// return points for finite and infinite repetition\n\nvec3 infRep(in vec3 pt, in vec3 period) {\n\treturn mod(pt + 0.5 * period, period) - 0.5 * period;\n}\n\nvec3 finRep(in vec3 pt, in vec3 period, in vec3 minLim, in vec3 maxLim) {\n\treturn pt - period * clamp(round(pt/period), minLim, maxLim);\n}\n\nvec3 finRep(in vec3 pt, in vec3 period, in vec3 lim) {\n\treturn pt - period * clamp(round(pt/period), -lim, lim);\n}\n\n\n//*******************************************************//\n\n// random and noise\n\n// https://thebookofshaders.com/10/\nfloat random(in float v) {\n\treturn fract(15465.1327854 * sin(v * 231.72));\n}\n\nfloat random(in vec2 v) {\n\treturn fract(15465.1327854 * sin(dot(v, vec2(173.93422, 102.5165))));\n}\n\nfloat random(in vec3 v) {\n\treturn fract(15465.1327854 * sin(dot(v, vec3(173.93422, 102.5165, 23.1234))));\n}\n\nfloat noise(in float v) {\n    float fid = fract(v); // fraction part\n    fid = fid * fid * (3.0 - 2.0 * fid);\n    float id = floor(v); // integer part\n    return mix(random(id), random(id + 1.0), fid);\n}\n\nfloat noise(in vec2 uv) {\n    \n\tvec2 fid = fract(uv); // fraction part of uv -> where in the grid\n\tfid = fid * fid * (3.0 - 2.0 * fid);\n\tvec2 id = floor(uv); // integer part of uvw -> which grid\n\t\n\t// corners of square\n\tfloat bl = random(id + vec2(0, 0));\n\tfloat br = random(id + vec2(1, 0));\n\tfloat tl = random(id + vec2(0, 1));\n\tfloat tr = random(id + vec2(1, 1));\n\t\n\t// interpolate between corner\n\tfloat b = mix(bl, br, fid.x);\n\tfloat t = mix(tl, tr, fid.x);\n\treturn mix(b, t, fid.y);\n    \n}\n\nfloat noise(in vec3 uvw) {\n\n\tvec3 f = fract(uvw); // fraction part of uvw -> where in the grid cell\n\tf = f * f * (3.0 - 2.0 * f);\n\tvec3 i = floor(uvw); // integer part of uvw -> which grid cell\n\t\n\t// lerp bottom face\n\tfloat bf = mix(random(i + vec3(0, 0, 0)), random(i + vec3(1, 0, 0)), f.x);\n\tfloat bb = mix(random(i + vec3(0, 0, 1)), random(i + vec3(1, 0, 1)), f.x);\n\tfloat b = mix(bf, bb, f.z);\n\n\t// lerp top face\n\tfloat tf = mix(random(i + vec3(0, 1, 0)), random(i + vec3(1, 1, 0)), f.x);\n\tfloat tb = mix(random(i + vec3(0, 1, 1)), random(i + vec3(1, 1, 1)), f.x);\n\tfloat t = mix(tf, tb, f.z);\n\t\n\treturn mix(b, t, f.y);\n\t\n}\n\nfloat fractalNoise(in float u, in int iter) {\n    float s1 = 1.0, s2 = 4.0;\n    float c = 0.0;\n    for (int i = 0; i < iter; i++) {\n        c += s1 * noise(u * s2);\n        s1 *= 0.5;\n        s2 *= 2.0;\n    }\n    c /= 2.0;\n    return c;\n}\n\nfloat fractalNoise(in vec3 uvw) {\n\tfloat c = noise(uvw * 4.0);\n\tc += 0.5 * noise(uvw * 8.0);\n\tc += 0.25 * noise(uvw * 16.0);\n\tc += 0.125 * noise(uvw * 32.0);\n\tc += 0.0625 * noise(uvw * 64.0);\n\tc /= 2.0;\n\treturn c;\n}\n\n//*******************************************************//\n\n// SDFs\n\nfloat sdSphere(in vec3 pt, in float rad) {\n\treturn length(pt) - rad;\n}\n\nfloat sdEllipsoid(in vec3 pt, in vec3 rad) {\n\tfloat k0 = length(pt/rad);\n\tfloat k1 = length(pt/(rad*rad));\n\treturn k0 * (k0-1.0)/k1;\n}\n\n// https://www.youtube.com/watch?v=PMltMdi1Wzg\nfloat sdCapsule(in vec3 pt, in vec3 a, in vec3 b, in float r) {\n\tvec3 apt = pt - a;\n\tvec3 ab = b - a;\n\tfloat t = clamp(dot(apt, ab) / dot(ab, ab), 0.0, 1.0);\n\treturn length( apt - ab * t ) - r;\n}\n\n// https://www.youtube.com/watch?v=62-pRVZuS5c\nfloat sdBox(vec3 pt, vec3 b) {\n\tvec3 q = abs(pt) - b;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n//*******************************************************//\n\nvec3 setCamera(in vec2 uv, in vec3 ro, in vec3 target) {\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, forward));\n    // ray direction\n    vec3 rd = normalize(uv.x * right + uv.y * up + 1.2 * forward);\n    return rd;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}