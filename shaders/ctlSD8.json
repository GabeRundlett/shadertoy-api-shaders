{
    "Shader": {
        "info": {
            "date": "1674701358",
            "description": "Experimenting with volumetric fog.",
            "flags": 0,
            "hasliked": 0,
            "id": "ctlSD8",
            "likes": 5,
            "name": "Volumetric Lighting V1",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "FifthStateOfMatter",
            "viewed": 342
        },
        "renderpass": [
            {
                "code": "const vec3 densityCoefficient = vec3(0.02, 0.021, 0.023);\n\nvec3 rotate2D(vec3 p, vec2 t){\n    float stx = sin(t.x);\n    float ctx = cos(t.x);\n    float sty = sin(t.y);\n    float cty = cos(t.y);\n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, ctx, -stx);\n    xRotation[2] = vec3(0, stx, ctx);\n    \n    mat3 yRotation;\n    yRotation[0] = vec3(cty, 0, -sty);\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sty, 0, cty);\n    return p*xRotation*yRotation;\n}\n\n//Dave_Hoskins' Hash Without Sine\nfloat random3(vec3 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.zyx + 31.32);\n    return (fract((p.x + p.y)*p.z)*2.0) - 1.0;\n}\n\nfloat random2(vec2 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.yx + 31.32);\n    return (fract(p.x + p.y)*2.0) - 1.0;\n}\n\nfloat noise3(vec3 p){\n    vec3 fc = floor(p);\n    vec3 frc = fract(p);\n    frc = frc*frc*(3.0 - 2.0*frc);\n    \n    float tlf = random3(fc + vec3(0, 1, 0));\n    float trf = random3(fc + vec3(1, 1, 0));\n    float blf = random3(fc + vec3(0, 0, 0));\n    float brf = random3(fc + vec3(1, 0, 0));\n    float tlb = random3(fc + vec3(0, 1, 1));\n    float trb = random3(fc + vec3(1, 1, 1));\n    float blb = random3(fc + vec3(0, 0, 1));\n    float brb = random3(fc + vec3(1, 0, 1));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    float lerpTopBack = mix(tlb, trb, frc.x);\n    float lerpBottomBack = mix(blb, brb, frc.x);\n    \n    float lerpFront = mix(lerpBottomFront, lerpTopFront, frc.y);\n    float lerpBack = mix(lerpBottomBack, lerpTopBack, frc.y);\n    \n    return mix(lerpFront, lerpBack, frc.z);\n}\n\nfloat noise2(vec2 p){\n    vec2 fc = floor(p);\n    vec2 frc = fract(p);\n    frc = frc*frc*(3.0 - 2.0*frc);\n    \n    float tlf = random2(fc + vec2(0, 1));\n    float trf = random2(fc + vec2(1, 1));\n    float blf = random2(fc + vec2(0, 0));\n    float brf = random2(fc + vec2(1, 0));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    return (mix(lerpBottomFront, lerpTopFront, frc.y) + 1.0)/2.0;\n}\n\nfloat fbm(vec3 p){\n    float f = 1.0;\n    float r = radians(57.0);\n    float h = 1.0;\n    float n = noise3(p*f)*h;\n    for(int i = 0; i < 2; i++){\n        f *= 2.0;\n        r += radians(57.0);\n        h /= 2.0;\n        n += noise3(rotate2D(p, vec2(0, r))*f)*h;\n    }\n    return n/1.0;\n}\n\nfloat fbm2(vec3 p){\n    float f = 1.0;\n    float r = radians(57.0);\n    float h = 1.0;\n    float n = noise2(p.xz*f)*h;\n    for(int i = 0; i < 8; i++){\n        f *= 2.0;\n        r += radians(57.0);\n        h /= 2.0;\n        n += noise2(rotate2D(p, vec2(0, r)).xz*f)*h;\n    }\n    return n/1.0;\n}\n\nfloat sphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat plane(vec3 p, float h, vec3 n){\n    return length((p - h)*n);\n}\n\nfloat spherePattern(vec3 p, vec3 c){\n    vec3 q = mod(p + 0.5*c, c) - 0.5*c;\n    return sphere(q, 1.0);\n}\n\nfloat scene(vec3 p){\n    //return min(spherePattern(p - vec3(2, 0, 5), vec3(4, 0, 4)), plane(p, -1.0, vec3(0, 1, 0)));\n    //return min(sphere(p - vec3(0, 0, 5.0 + iTime), 1.0), plane(p, -1.0, vec3(0, 1, 0)));\n    return (plane(p, -1.0, vec3(0, 1, 0)) - fbm2(p*0.07)*5.0)*0.9;\n}\n\nfloat raymarch(vec3 o, vec3 d, out bool hit, int ms, float md){\n    float t = 0.0;\n    hit = false;\n    for(int i = 0; i < ms && t < md && !hit; i++){\n        float s = scene(o + d*t);\n        t += s;\n        if(abs(s) <= 0.001*t && t >= 0.0){\n            hit = true;\n        }\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 h){\n    vec2 eps = vec2(0.01, 0);\n    return normalize(vec3(\n        scene(h + eps.xyy) - scene(h - eps.xyy),\n        scene(h + eps.yxy) - scene(h - eps.yxy),\n        scene(h + eps.yyx) - scene(h - eps.yyx)\n    ));\n}\n\nfloat G_SCATTERING = 2.0;\n\nfloat ComputeScattering(float lightDotView){\n    float result = 1.0 - G_SCATTERING*G_SCATTERING;\n    result /= (4.0*3.1415926535*pow(1.0 + G_SCATTERING*G_SCATTERING - (2.0*G_SCATTERING)*lightDotView, 1.5));\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float seed = iTime;\n    float hardness = 1.0;\n    vec3 outCol = vec3(0);\n    vec3 lPos = vec3(10, 10, -10.0 + iTime*3.0);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 o = vec3(0, 8, iTime*3.0);\n    vec3 d = normalize(rotate2D(vec3(uv, 1), vec2(radians(15.0), iTime*0.5)));\n    bool hit;\n    float density;\n    float t = raymarch(o, d, hit, 200, 200.0);\n    vec3 h = o + d*t;\n    if(!hit) t = 500.0;\n    for(int j = 0; j <= 0; j++){\n        seed += float(j);\n        //vec3 l = normalize(lPos - (h + vec3(random3(h*203824.42743 + seed*20834.842)*hardness, random3(h*334284.82372 + seed*22147.243)*hardness, random3(h*182037.28347 + seed*21382.428)*hardness)));\n        vec3 lRay = normalize(lPos - h);\n        vec3 l = -normalize(vec3(-10, -10, 10));\n        vec3 skycol = mix(vec3(0.9), vec3(1, 1, 0.9), smoothstep(0.0, 1.0, clamp(pow(dot(d, -lRay), 200000.0), 0.0, 1.0)));\n        //vec3 skycol = vec3(0.9);\n        vec3 col = skycol;\n        vec3 n = getNormal(h);\n        float ny = n.y - 0.25;\n        vec3 mat = mix(vec3(0.2, 0.15, 0.1), vec3(0.3, 0.5, 0.2), smoothstep(0.6, 0.7, ny));\n        float c = dot(n, l);\n        bool lhit;\n        float lt = raymarch(h + n*0.01, l, lhit, 30, 30.0);\n        lhit ? c *= 0.4 : c = dot(n, l);\n        vec3 testPos = o;\n        float cRayRes = 50.0;\n        float stepLength = t/cRayRes;\n        vec3 Step = d*stepLength;\n        density = 0.0;\n        for(int i = 0; i < int(cRayRes); i++){\n            testPos += Step;\n            //bool chit;\n            //float ct = raymarch(testPos + n*0.01, l, chit, 50, 50.0);\n            //if(!chit){\n                density += stepLength + fbm((testPos + vec3(0, -iTime*0.0, 0))*1.0)*2.0*stepLength;\n            //}else{\n                //density += (stepLength + fbm((testPos + vec3(0, -iTime*0.5, 0))*3.0)*stepLength + ComputeScattering(dot(d, l))*stepLength)*0.0;\n            //}\n        }\n        //density /= cRayRes;\n        if(hit){\n            col = mix(mat*clamp(c, 0.0, 1.0), vec3(0.9), vec3(1.0 - exp(-density*densityCoefficient)));\n        }else{\n            col = skycol;\n        }\n        //outCol = mix(outCol, col, 1.0/float(j + 1));\n        outCol = col;\n    }\n    fragColor = vec4(pow(outCol, vec3(1.0/2.2)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}