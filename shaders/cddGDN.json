{
    "Shader": {
        "info": {
            "date": "1677277131",
            "description": "Forked from Ohanami Stipple, which is a port of the code from the \"Ohanami\" 4kb demo: https://www.pouet.net/prod.php?which=71888\n\nUse mouse Y to change camera tilt.",
            "flags": 0,
            "hasliked": 0,
            "id": "cddGDN",
            "likes": 10,
            "name": "Trees and grass",
            "published": 3,
            "tags": [
                "clouds",
                "grass",
                "tree"
            ],
            "usePreview": 0,
            "username": "guil",
            "viewed": 277
        },
        "renderpass": [
            {
                "code": "\nfloat col=5.,col2=1e3,col3=1e3;\n\n\n// Signed distance field function.\nfloat f(vec3 p)\n{\n    float ter = fbm(p.xz+4.)*.1; // Ground\n    col3=p.y-ter;\n    p.y-=ter;\n    float d=max(col3,p.y);\n    \n    \n    if(length(p)<10.)p.xz = mod(p.xz+2.,5.)-3.;// Multiply trees\n      \n    float s=1.,s1=s,g=1.6,g1=1.7;\n       \n    mat2 m1 = r2D(2.2);\n    mat2 m2 = r2D(1.05);\n    mat2 m3 = r2D(-.1);\n\n    int j=7;\n    float h=3.;\n    float scale=.6;\n    p/=scale;\n    \n    //float a = length(p-vec3(0,h/2.,0))-h/2.;\n    //if(a>2.)return min(d, a); \n    \n    \n    // Evaluate the tree \n    d=min(d,scale*max(p.y-h,max(-p.y,length(p.xz)-.1/(p.y+.7)))/s);// trunc \n    for(int k=0;k<int(h);k++){\n      vec3 q=p;\n      s=s1;\n      // Evaluate the tree branches\n      for(int i=0;i<j;\n        q.x=abs(q.x),\n        q.z=(i==0)?q.z:abs(q.z), \n        q.y-=1.,\n        q.xz *= m2,\n        q.xy *= m1,\n        q.xz *= m3,\n        q*=g,\n        s*=g,\n        d=min(d,scale*max(q.y-1.,max(-q.y,length(q.xz)-.1/(q.y+.7)))/s),\n        ++i);\n      // Leaves\n      q.y-=1.;      \n      float l = (length(q*vec3(.6,.3,1.))-.3)/s;\n      if(l<d)col=max(0.,l), d=l;      \n      // return to trunc\n      p.y-=1.5;\n      p.xz *= -m1,\n      s1*=g1;\n      p*=g1;\n      j -=1;}\n    \n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy -.5;\n    uv.x*=iResolution.x/iResolution.y;\n\n\n    float zoom=1.;\n   \n    // Set up camera and primary ray.\n    vec3 ro=vec3(-2.5+cos(iTime/4.),1.5+ iMouse.y/iResolution.y,3.5);\n    vec3 rd=normalize(vec3(uv.xy,zoom));\n    vec3 target=vec3(0,1.3,0);\n\n    vec3 w=normalize(target-ro);\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\n    vec3 v=normalize(cross(w,-u));\n\n    rd=mat3(u,v,w)*rd;\n    \n    // Sky\n    float y = max(rd.y,0.);\n    fragColor.rgb = mix(vec3(.1,.2,1.)*.7,vec3(1),fbm2(rd.xz/(.1+y)));\n    fragColor.rgb = mix(fragColor.rgb,vec3(.5,.5,.9),pow(1.-y,10.));\n    \n    \n    \n\n    // Signed distance field raymarch.\n    float t=0.,d=0.;\n    for(int i=0;i<100;++i)\n    {\n        d=f(ro+rd*t);\n        if(d<1e-3)break;\n        t+=d;\n        if(t>30.)return;\n    }\n\n    // Colourise ground, branch/trunk, or cherry blossom.\n    {\n        vec3 rp=ro+rd*t;\n        fragColor.rgb=vec3(.75,.6,.4)/1.5;//wood\n        //if(col<2e-3)fragColor.rgb=vec3(1.,.7,.8);//blossoms\n        //if(col<2e-3)fragColor.rgb=vec3(1.,.5,.1);//red leaves\n        if(col<2e-3)fragColor.rgb=vec3(.1,.5,.2);//green leaves\n        if(col3<1e-1||t>10.)//grass\n            fragColor.rgb=vec3(.6,1.,.6)/3.,\n            fragColor.rg +=fbm1(rp.xz)/8.;\n    }\n\n    // Lighting.\n    vec3 ld=normalize(vec3(1.,3.,1.));\n    float e=1e-2;\n    float d2=f(ro+rd*t+ld*e);\n    float l=max(0.,(d2-d)/e);\n\n    float d3=f(ro+rd*t+vec3(0,1,0)*e);\n    float l2=max(0.,.5+.5*(d3-d)/e);\n\n    vec3 rp=ro+rd*(t-1e-3);\n\n    // Directional shadow.\n    t=0.1;\n    float sh=1.;\n    for(int i=0;i<30;++i)\n    {\n        d=f(rp+ld*t)+.01;\n        sh=min(sh,d*50.+0.3);\n        if(d<1e-4)break;\n        t+=d;\n    }\n\n    fragColor.rgb*=1.5*sh*(.2+.8*l)*vec3(1.,1.,.9)*.7+l2*vec3(.85,.85,1.)*.4;\n    fragColor.rgb=clamp(fragColor.rgb,0.,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nmat2 r2D(float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(si, co, -co, si);\n}\n\nfloat fbm(vec2 p)//ground\n{\n    float s=1.;\n    mat2 m = r2D(3.7);\n    vec2 r= vec2(0.);\n    for(int i=0;i<5;i++)r+=sin(p)/s, p=m*(p*s+r),s*=1.3;\n    return r.x+r.y;\n}\n\nfloat fbm1(vec2 p)//grass\n{\n    float s=2.;\n    mat2 m = r2D(1.);\n    vec2 r= vec2(0.);\n    for(int i=0;i<8;i++)r+=(sin(p.yx+.5))/s, p=m*p*s+cos(r.yx*s), s*=1.02;\n    return (r.x+r.y)/s;\n}\n\n\nfloat fbm2(vec2 p)//clouds\n{\n    float s=1.5, r=0.;\n    mat2 m = r2D(1.);\n    vec2 f;\n    for(int i=0;i<7;i++)f=1.+.2*cos(p), p*=m, r+=abs(dot(sin(p*f*s)/s,vec2(1))),s*=1.5;\n    return clamp(r*.3,.3,1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}