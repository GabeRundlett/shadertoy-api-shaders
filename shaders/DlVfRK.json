{
    "Shader": {
        "info": {
            "date": "1702319173",
            "description": "Another experiment with animation/tweens. It's actually a pretty nice system to work with.",
            "flags": 0,
            "hasliked": 0,
            "id": "DlVfRK",
            "likes": 9,
            "name": "pentagram",
            "published": 3,
            "tags": [
                "animation"
            ],
            "usePreview": 0,
            "username": "LydianLights",
            "viewed": 187
        },
        "renderpass": [
            {
                "code": "const float loopTime = 4.5;\nconst float radius = 0.9;\nconst float lineWidth = 0.01;\n\nconst float tImpact = 2.25;\nconst float tActivate = tImpact + 0.15;\n\nfloat wiggle = 0.0; // calculated globally\n\n#define pentaPtAngle(i) i / 5.0 * 2.0 * PI + PI / 2.0\n#define pentaPt(i) vec2(radius * cos(pentaPtAngle(i)), radius * sin(pentaPtAngle(i)))\n\nconst vec2 pt1 = pentaPt(0.0);\nconst vec2 pt2 = pentaPt(1.0);\nconst vec2 pt3 = pentaPt(2.0);\nconst vec2 pt4 = pentaPt(3.0);\nconst vec2 pt5 = pentaPt(4.0);\n\nfloat tween(float t, float start, float duration) {\n    return saturate(map01(t, start, start + duration));\n}\n\nvoid calcWiggle(vec2 uv) {\n    float s = floor(mod(12.0 * iTime, 4.0));\n    wiggle = 0.004 * noise(uv, 5.0, s);\n}\n\nfloat drawLine(vec2 uv, float t, float startTime, float duration, vec2 p1, vec2 p2) {\n    if (t < startTime) return 99999.0;\n    float m = tween(t, startTime, duration); m = easeInOut(m, 8.0);\n    return sdSegment(uv, p1, mix(p1, p2, m)) - lineWidth + wiggle;\n}\n\nfloat drawCircle(vec2 uv, float t, float startTime, float duration) {\n    if (t < startTime) return 99999.0;\n    float m = tween(t, startTime, duration); m = easeInOut(m, 6.0);\n    const float a0 = pentaPtAngle(2.0);\n    float a = a0 - 2.0 * PI * m;\n    return sdArc(uv, radius, a, a0) - lineWidth + wiggle;\n}\n\nvec3 scene(vec2 uv, float t) {\n    float px = 2.0 / iResolution.y;\n    bool invert = false;\n    if (t > tImpact && t < tActivate) { invert = true; }\n    if (t > tActivate) { uv.y *= -1.0; }\n    \n    float d = drawLine(uv, t, 0.0, 0.4, pt3, pt1);\n    d = min(d, drawLine(uv, t, 0.3, 0.4, pt1, pt4));\n    d = min(d, drawLine(uv, t, 0.6, 0.4, pt4, pt2));\n    d = min(d, drawLine(uv, t, 0.9, 0.4, pt2, pt5));\n    d = min(d, drawLine(uv, t, 1.2, 0.6, pt5, pt3));\n    d = min(d, drawCircle(uv, t, 1.7, 0.7));\n    \n    d = smoothstep(0.0, 2.0 * px, d);\n    if (!invert) { d = 1.0 - d; }\n    \n    return vec3(d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    calcWiggle(uv);\n    float t = mod(iTime, loopTime);\n    \n    vec3 color = scene(uv, t);\n    \n    if (t > tActivate) {\n        float m = tween(t, tImpact + 0.15, 1.5);\n        float s = 1.0 + 1.2 * m;\n        float o = 0.5 * (1.0 - m);\n        vec3 afterimage = scene(uv / s, t);\n        color += o * afterimage;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.1415927\n\nfloat map01 (float t, float t0, float t1) {return (t - t0) / (t1 - t0); }\nfloat saturate (float x) { return min(max(x, 0.0), 1.0); }\nfloat dot2(vec2 v) { return dot(v,v); }\nfloat cro(vec2 a, vec2 b) { return a.x * b.y - a.y * b.x; }\n\n// thx iq, as always:\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdArc(in vec2 p, in float r, in float a1, in float a2) {\n    vec2 p1 = vec2(r * cos(a1), r * sin(a1));\n    vec2 p2 = vec2(r * cos(a2), r * sin(a2));\n    float c = cro(p1, p2);\n    float c1 = cro(p, p1);\n    float c2 = cro(p, p2);\n    float d1 = min(length(p - p1), length(p - p2));\n    float d2 = abs(length(p) - r);\n    if (a1 == a2) return d1;\n    return c > 0.0\n        ? c1 < 0.0 && c2 > 0.0 ? d2 : d1\n        : c1 < 0.0 || c2 > 0.0 ? d2 : d1;\n}\n\n// easing\nfloat easeIn(float x, float q) {\n    return pow(x, q);\n}\n\nfloat easeOut(float x, float q) {\n    return 1.0 - pow(1.0 - x, q);\n}\n\nfloat easeInOut(float x, float q) {\n    return x < 0.5\n        ? pow(2.0 * x, q) / 2.0\n        : 1.0 - pow(2.0 * (1.0 - x), q) / 2.0;\n}\n\n// Authors: Stefan Gustavson (stefan.gustavson@gmail.com)\n// and Ian McEwan (ijm567@gmail.com)\n// Version 2021-12-02\n// Copyright (c) 2021 Stefan Gustavson and Ian McEwan. Published under MIT license.\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient) {\n\tvec2 uv = vec2(x.x + x.y*0.5, x.y);\n\tvec2 i0 = floor(uv);\n\tvec2 f0 = fract(uv);\n\tfloat cmp = step(f0.y, f0.x);\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\n\tvec2 i1 = i0 + o1;\n\tvec2 i2 = i0 + vec2(1.0, 1.0);\n\tvec2 v0 = vec2(i0.x - i0.y * 0.5, i0.y);\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y * 0.5, v0.y + o1.y);\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n\tvec2 x0 = x - v0;\n\tvec2 x1 = x - v1;\n\tvec2 x2 = x - v2;\n\tvec3 iu, iv;\n\tvec3 xw, yw;\n\tif(any(greaterThan(period, vec2(0.0)))) {\n\t\txw = vec3(v0.x, v1.x, v2.x);\n\t\tyw = vec3(v0.y, v1.y, v2.y);\n\t\tif(period.x > 0.0)\n\t\t\txw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n\t\tif(period.y > 0.0)\n\t\t\tyw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n\t\tiu = floor(xw + 0.5*yw + 0.5);\n\t\tiv = floor(yw + 0.5);\n\t} else {\n\t\tiu = vec3(i0.x, i1.x, i2.x);\n\t\tiv = vec3(i0.y, i1.y, i2.y);\n\t}\n\tvec3 hash = mod(iu, 289.0);\n\thash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n\thash = mod((hash*34.0 + 10.0)*hash, 289.0);\n\tvec3 psi = hash * 0.07482 + alpha;\n\tvec3 gx = cos(psi);\n\tvec3 gy = sin(psi);\n\tvec2 g0 = vec2(gx.x,gy.x);\n\tvec2 g1 = vec2(gx.y,gy.y);\n\tvec2 g2 = vec2(gx.z,gy.z);\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n\tw = max(w, 0.0);\n\tvec3 w2 = w * w;\n\tvec3 w4 = w2 * w2;\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n\tfloat n = dot(w4, gdotx);\n\tvec3 w3 = w2 * w;\n\tvec3 dw = -8.0 * w3 * gdotx;\n\tvec2 dn0 = w4.x * g0 + dw.x * x0;\n\tvec2 dn1 = w4.y * g1 + dw.y * x1;\n\tvec2 dn2 = w4.z * g2 + dw.z * x2;\n\tgradient = 10.9 * (dn0 + dn1 + dn2);\n\treturn 10.9 * n;\n}\n\nfloat noise(vec2 x, float freq, float t) {\n    vec2 grad;\n    return psrdnoise(freq * (x + 0.621 * t), vec2(0.0), 0.0, grad);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}