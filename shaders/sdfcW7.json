{
    "Shader": {
        "info": {
            "date": "1642166553",
            "description": "Signed distance for a dog poop - NOT EXACT ;)",
            "flags": 0,
            "hasliked": 0,
            "id": "sdfcW7",
            "likes": 14,
            "name": "sdTurd",
            "published": 3,
            "tags": [
                "raymarch",
                "spiral",
                "poop"
            ],
            "usePreview": 0,
            "username": "Del",
            "viewed": 329
        },
        "renderpass": [
            {
                "code": "// poop - NOT EXACT ;)\n\n#define PI 3.14159265\n#define TAU 6.283185\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat smax(float a,float b,float k)\n{\n    k = -k;\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nmat2 rot(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat sdBox2D( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdHelix(vec3 p, float radius,float height, float coils, float pd,float ph)\n{\n    coils =  coils / (height/PI);\n    vec3 pp = vec3(normalize(p.xy)*radius, clamp(p.z, -height*0.5, height*0.5));\n    float d1 = distance(p, pp);\n\tfloat d2 = asin(sin(p.z*coils + 0.5*atan(p.x,p.y)))/coils;\n    float d=sdBox2D(vec2(d1,d2), vec2(pd,ph));\n    return d;\n}\n\nfloat sdTurd(vec3 pos)\n{\n    float radius = 2.5;\n    float height = 4.0;\n    float pd = radius-0.35;\n    float ph = 0.01f;\n    float coils = 4.0;    \n    float d1 = sdHelix(pos.xzy, radius,height, coils, pd, ph)-0.02;\n    float d2 = sdCappedCone(pos,(height)*0.5,radius,0.0)-0.03;\n    float d = smax(d2,-d1,0.45);\n    return d*0.95;\n}\n\nfloat map( in vec3 pos )\n{\n    pos.xz*=rot(fract(iTime*0.24)*6.28);\n    return sdTurd(pos);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\n\nmat3 lookAtMatrix(vec3 from, vec3 to) {\n    vec3 forward = normalize(to - from);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\nfloat raycast(vec3 rayOrigin, vec3 rayDirection) {\n    float maximumDistance = 30.0;\n    float t = 0.0;\n    for (int i = 0; i < 150; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = map(currentPosition);\n        if (d < 0.0001) {\n            return t;\n        }\n        t += d;\n    }\n    return 0.0;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat angle = PI*0.4;\n\tvec3 rayOrigin = vec3(6.0 * cos(angle), 3.0+(sin(iTime*0.1)*1.5), 6.0 * sin(angle));\n    vec3 targetPosition = vec3(0.0);\n    mat3 cameraTransform = lookAtMatrix(rayOrigin, targetPosition);\n    ivec2 sampleCount = ivec2(1.0, 1.0);\n\n    vec2 uv = fragCoord;\n    uv = uv / iResolution.xy;\n    uv = (uv * 2.0) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rayDirection = normalize(vec3(uv, 1.5));\n    rayDirection = cameraTransform * rayDirection;\n    float t = raycast(rayOrigin, rayDirection);\n    vec3 color = vec3((1.0-abs(uv.y))*0.1);\n    \n    if (t > 0.0)\n    {\n        vec3 position = rayOrigin + rayDirection * t;\n        vec3 n = calcNormal(position);\n        \n            vec3 mycol = vec3(0.48,0.21,0.04);\n            vec3 pos = rayOrigin + t*rayDirection;\n            vec3 nor = n;\n            \n            vec3 dir = normalize(vec3(1.0,0.7,0.0));\n\t        vec3 ref = reflect(rayDirection, nor);\n\t        float spe = max(dot(ref, dir), 0.0);\n\t        vec3 spec = vec3(1.0) * pow(spe, 64.);\n            float dif = clamp( dot(nor,dir), 0.05, 1.0 );\n            color =  mycol*dif;\n            color+=spec;\n    }\n\tfragColor = vec4(sqrt(color), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}