{
    "Shader": {
        "info": {
            "date": "1625600742",
            "description": "Inspired by Martijn's tutorial [url=https://www.youtube.com/watch?v=t4XnK50ocMk]https://www.youtube.com/watch?v=t4XnK50ocMk[/url]\nA bit late but I had to finish it still :)",
            "flags": 0,
            "hasliked": 0,
            "id": "flXSDH",
            "likes": 19,
            "name": "Independence Day Fireworks",
            "published": 3,
            "tags": [
                "flag",
                "fireworks",
                "shaderart",
                "american",
                "independence",
                "fourthofjuly"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 354
        },
        "renderpass": [
            {
                "code": "// Constants\n#define TAU 6.28318530718\n#define PI 3.14159265359\n#define RHO 1.57079632679\n\n// Utilities\n#define fillDraw(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n#define glowDraw(dist, col, glow) color += col / exp((glow) * (dist))\n#define remap01(x, a, b) ((x) - (a)) / ((b) - (a))\n\n// SDFs\nfloat sdDisk(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdStar5(in vec2 p, in float r, in float rf) {\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0 * max(dot(k1, p), 0.0) * k1;\n    p -= 2.0 * max(dot(k2, p), 0.0) * k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf * vec2(-k1.y, k1.x) - vec2(0.0, 1.0);\n    float h = clamp(dot(p, ba) / dot(ba, ba), 0.0, r);\n    return length(p - ba * h) * sign(p.y * ba.x - p.x * ba.y);\n}\n\n// Simple trajectory with an initial position, linear velocity and gravity\nvec2 posInTrajectory(in vec2 p0, in vec2 v0, in float g, in float t) {\n    vec2 p = p0 + v0 * t;\n    p.y -= 0.5 * g * t * t;\n    return p;\n}\n\nvec2 velInTrajectory(in vec2 p0, in vec2 v0, in float g, in float t) {\n    v0.y -= g * t;\n    return v0;\n}\n\n// I would try optimizing with a bbox check but unfortunately\n// the glow just doesn't work well with that :(\nvec2 sdTrajectory(in vec2 p, in vec2 p0, in vec2 v0, in float g, in float tStart, in float tEnd) {\n    vec2 q = p0 - p;\n    float t3 = 0.5 * g * g;\n    float t2 = -1.5 * g * v0.y;\n    float t1 = dot(v0, v0) - q.y * g;\n    float t0 = dot(q, v0);\n\n    t2 /= t3, t1 /= t3, t0 /= t3;\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = -2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0;\n        return vec2(length(p - posInTrajectory(p0, v0, g, clamp(root, tStart, tEnd))), root);\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = 2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0;\n        vec2 p1 = p - posInTrajectory(p0, v0, g, clamp(roots.x, tStart, tEnd));\n        vec2 p2 = p - posInTrajectory(p0, v0, g, clamp(roots.y, tStart, tEnd));\n        float d1 = dot(p1, p1), d2 = dot(p2, p2);\n        return  d1 < d2 ? vec2(sqrt(d1), roots.x) : vec2(sqrt(d2), roots.y);\n    }\n}\n\n// Modified hash from https://www.shadertoy.com/view/4djSRW\nfloat gSeed = 167.23;\nfloat random() {\n    float x = fract(gSeed++ * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvoid doFirework(inout vec3 color, in vec2 uv, in float time, in float seed) {\n    float timeFrame = floor(time / 3.0) * 3.0;\n    float fireTime = time - timeFrame;\n\n    // Generate random traits\n    gSeed = timeFrame + seed;\n    float angle = mix(0.4, 0.6, random()) * PI;\n    float speed = mix(2.0, 2.5, random());\n    vec3 sparkColor = normalize(vec3(random(), random(), random())) * 1.25;\n\n    // Compute start position, velocity, and gravity\n    vec2 p0 = vec2(0.0, 0.6);\n    vec2 v0 = vec2(cos(angle), sin(angle)) * speed;\n    float g = 1.0;\n\n    // Tracking\n    float tApogee = v0.y / g;\n    float t = tApogee * fireTime;\n    vec2 pos = posInTrajectory(p0, v0, g, t);\n\n    // Projectile and trail\n    vec3 fadeColor = sparkColor * (1.0 - fireTime / 3.0);\n    vec2 arc = sdTrajectory(uv, p0, v0, g, max(0.0, t - 2.0), t);\n    glowDraw(arc.x - 0.01, fadeColor * clamp(remap01(arc.y, t - 2.0, t), 0.0, 1.0), 15.0);\n    glowDraw(sdDisk(uv - pos, 0.02), fadeColor, 25.0);\n\n    // Cast a circle of sparks from the apogee (highest point in the trajectory)\n    if (t > tApogee) {\n        fireTime -= 1.0;\n        vec2 vApogee = velInTrajectory(p0, v0, g, tApogee);\n        p0 = posInTrajectory(p0, v0, g, tApogee);\n        for (float an=0.0; an < TAU; an += TAU / 25.0) {\n            // Tracking\n            v0 = vec2(cos(an), sin(an)) * (0.5 + random()) + vApogee;\n            t = tApogee * fireTime;\n            pos = posInTrajectory(p0, v0, g, t);\n\n            // Projectile with trail\n            vec3 fadeColor = sparkColor * (1.0 - 0.5 * fireTime);\n            vec2 arc = sdTrajectory(uv, p0, v0, g, 0.0, t);\n            glowDraw(arc.x - 0.01, fadeColor * clamp(remap01(arc.y, t - 1.0, t), 0.0, 1.0), 15.0);\n            glowDraw(sdDisk(uv - pos, 0.02), fadeColor, 25.0);\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - vec2(0.5 * iResolution.x, 0.0)) / iResolution.y * 4.0;\n    vec3 color = mix(vec3(1.0, 0.8, 0.0), vec3(0.5, 0.0, 0.0), 0.25 * (length(uv) - 0.25));\n    float unit = 8.0 / iResolution.y;\n\n    // Flagpole\n    fillDraw(sdBox(vec2(uv.x, uv.y - 1.75), vec2(0.035, 1.75)), vec3(0.0));\n\n    // Flag\n    vec2 flagUv = uv - vec2(0.845, 2.85);\n\n    // Wave and shear to make it look like its more in perspective\n    float x = uv.x - 0.035;\n    flagUv.x = 1.1 * flagUv.x + 0.08;\n    flagUv.y += 0.1 * x * sin(3.0 * (flagUv.x - iTime)) + 0.3 * x;\n\n    // Shadows to highlight the ripples\n    float shadow = 0.4 * sin(3.0 * (flagUv.x - iTime));\n    shadow *= shadow;\n\n    fillDraw(sdBox(flagUv, vec2(0.8, 0.64)), vec3(1.0) - shadow);\n\n    // Red and white stripes (one for each of the original 13 colonies)\n    vec2 stripesUv = flagUv;\n    stripesUv.y -= clamp(round(stripesUv.y * 5.0) * 0.2, -0.6, 0.6);\n    fillDraw(sdBox(stripesUv, vec2(0.8, 0.6 / 13.0)), vec3(0.78, 0.06, 0.18) - shadow);\n\n    // Blue background and stars (one star for each of the 50 current states)\n    // The stars are in staggered rows, 6 stars, 5 stars, repeat for 9 rows total\n    vec2 starsUv = flagUv - vec2(-0.38, 0.3);\n    fillDraw(sdBox(starsUv, vec2(0.425, 0.35)), vec3(0.0, 0.13, 0.41) - shadow);\n\n    vec2 repSize = vec2(0.85, 0.7) / vec2(6.0, 9.0);\n    float cy = floor(starsUv.y / repSize.y + 0.5) * repSize.y; // Cell y coordinate\n\n    float stagger = mod(floor(cy / repSize.y), 2.0) * 0.5;\n    float bx = 0.375 - stagger * repSize.x; // Repetition x bound (varied to create staggered rows)\n    float cx = (floor(starsUv.x / repSize.x + stagger) + abs(stagger - 0.5)) * repSize.x; // Cell x coordinate\n\n    starsUv -= clamp(vec2(cx, cy), -vec2(bx, 0.3), vec2(bx, 0.3));\n    fillDraw(sdStar5(starsUv, 0.02, 0.4), vec3(1.0) - shadow);\n\n    // Fireworks\n    vec2 fireUv = uv;\n    fireUv.x = abs(fireUv.x) - 2.0;\n\n    // Spouts\n    fillDraw(sdBox(vec2(fireUv.x, fireUv.y - 0.04), vec2(0.15, 0.04)), vec3(0.0));\n    fillDraw(sdBox(vec2(fireUv.x, fireUv.y - 0.3), vec2(0.06, 0.3)), vec3(0.0));\n\n    // Sparks\n    doFirework(color, vec2(uv.x - 2.0, uv.y), iTime, 394.438);\n    doFirework(color, vec2(uv.x + 2.0, uv.y), iTime + 1.0, 593.458);\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}