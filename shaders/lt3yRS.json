{
    "Shader": {
        "info": {
            "date": "1532970777",
            "description": "Just an exercise in volumetric raymarching.",
            "flags": 0,
            "hasliked": 0,
            "id": "lt3yRS",
            "likes": 5,
            "name": "Inner space",
            "published": 3,
            "tags": [
                "raymarching",
                "spheres",
                "cylinders"
            ],
            "usePreview": 0,
            "username": "liamegan",
            "viewed": 442
        },
        "renderpass": [
            {
                "code": "// A lot of this setup is borrowed from Shane - https://www.shadertoy.com/user/Shane\n// Many of the learnings come curtesy of Big Wings - https://www.shadertoy.com/user/BigWings\n// And of course the literally thousands of other people who have been developing these concepts over the years.\n// But this is an effort to more detailed understanding of the underlying principles.\n\n// movement variables\nvec3 movement = vec3(.0);\n\n// Gloable variables for the raymarching algorithm.\nconst int maxIterations = 256;\n\n// The world!\nfloat world_df(in vec3 p) {\n    float world = 10.;\n\n    p.x += cos(p.z * .3) * 3.;\n    p.y += sin(p.z * .3) * 3.;\n\n    vec3 _p = mod(p, 1.2) - .5;\n    vec3 _2p = p;\n    _2p.x += sin(_2p.z);\n    _2p.y += cos(_2p.z);\n    _2p = mod(_2p, 3.0) - 1.5;\n\n    world = min(length(_p)-.1, length(_2p.xy) - .01); // spheres and bendy cylinders\n\n    p = mod(p, 2.) - 1.;\n    world = min(world, length(p.xz) - .03); // larger, less bendy cylinders.\n\n    return world;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n\n    // movement\n    movement = vec3(iTime, 0., iTime * -4.);\n\n    vec3 lookAt = vec3(-.5, sin(iTime * .5) * 2., cos(iTime * .5) * 2.);\n    vec3 camera_position = vec3(0.2, 0.2, -1.0);\n\n    lookAt += movement;\n    camera_position += movement;\n\n    vec3 forward = normalize(lookAt-camera_position);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x ));\n    vec3 up = normalize(cross(forward,right));\n\n    // FOV - Field of view.\n    float FOV = 3.;\n\n    vec3 ro = camera_position; \n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n\n    float dist = 100.;\n    float field = 0.;\n    for ( int i = 0; i < maxIterations; i++ ) {\n      dist = world_df( ro + rd * field );\n      field += dist * .03;\n      if(field > 5.) break;\n    }\n\n    vec3 colour = vec3(field*field*.18, field*.28, sin(field)*.15 * length(uv) + sin(iTime) * .5);\n    colour *= colour;\n\n    fragColor = vec4(clamp(colour, 0.0, 1.0), smoothstep(7., 0., colour.r)*.3);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}