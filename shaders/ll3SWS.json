{
    "Shader": {
        "info": {
            "date": "1481360634",
            "description": "Kaleidoscopic folding combined with texture feedback.\n\nClick on screen and move around slowly to manipulate angle and scaling.",
            "flags": 32,
            "hasliked": 0,
            "id": "ll3SWS",
            "likes": 28,
            "name": "Kaleidoscopic Feedback Fractals",
            "published": 3,
            "tags": [
                "fractal",
                "feedback",
                "multipass"
            ],
            "usePreview": 0,
            "username": "ttg",
            "viewed": 1241
        },
        "renderpass": [
            {
                "code": "/*\n\nKaleidoscopic Feedback Fractals\nCopyright 2016 Theron Tarigo\n\nKaleidoscopic folding combined with texture feedback.\n\nClick on screen and move around slowly to manipulate angle and scaling.\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 1.;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor.a = 1.0;\n\tfragColor.rgb = vec3(2.,1.,3.)*texture(iChannel0, (uv-vec2(0.5))*zoom+vec2(0.5)).rgb;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\nKaleidoscopic Feedback Fractals\nCopyright 2016 Theron Tarigo\n\nKaleidoscopic folding combined with texture feedback.\n\nClick on screen and move around slowly to manipulate angle and scaling.\n\n*/\n\n#define pi 3.14159\n\nvec2 kld(vec2 v, vec2 v1) {\n    \n    float a = 2.*pi/3.;\n    mat2 t = mat2(cos(a),-sin(a),sin(a),cos(a));\n    vec2 v2 = t*v1;\n\n    vec2 o = vec2(1.,1.)*2./3.;\n    float mult = 1.0;\n    v1 = mult*v1;\n    v2 = mult*v2;\n    \n    vec2 x;\n    {\n        float r1 = mod(dot(v, v1)/dot(v1, v1)+o.x,3.);\n        float r2 = mod(dot(v, v2)/dot(v2, v2)+o.y,3.);\n\n        float s1 = 3.-abs(3.-(r1+r2));\n        float s2 = r1-r2;\n\n        r1 = 0.5*(s1+s2);\n        r2 = 0.5*(s1-s2);\n\n        vec3 c;\n        c.x = -(r1+r2)+2.;\n        c.y = r1-1.;\n        c.z = -c.x-c.y;\n\n        vec3 d = c;\n        if (c.x>1.) { d+=vec3(-2.,1.,1.); }\n        if (c.y>1.) { d+=vec3(1.,-2.,1.); }\n        if (c.z>1.) { d+=vec3(1.,1.,-2.); }\n        c = d;\n\n        x.x = 1.-max(max(abs(c.x),abs(c.y)),abs(c.z));\n    }\n    \n    {\n        float r1 = mod(dot(v, v1)/dot(v1, v1)+o.x,3.);\n        float r2 = mod(dot(v, v2)/dot(v2, v2)+1.+o.y,3.);\n\n        float s1 = 3.-abs(3.-(r1+r2));\n        float s2 = r1-r2;\n\n        vec3 c;\n        c.x = 0.5*(s1-s2)-1.;\n        c.y = 0.5*(s1+s2)-1.;\n        c.z = -c.x-c.y;\n\n        vec3 d = c;\n        if (c.x>1.) { d+=vec3(-2.,1.,1.); }\n        if (c.y>1.) { d+=vec3(1.,-2.,1.); }\n        if (c.z>1.) { d+=vec3(1.,1.,-2.); }\n        c = d;\n\n        x.y = 1.-max(max(abs(c.x),abs(c.y)),abs(c.z));\n    }\n\n    float mult2 = sqrt(3.)/3.;\n    vec2 v1r = vec2(-v1.y,v1.x)*mult2;\n    vec2 v2r = vec2(-v2.y,v2.x)*mult2;\n    return ( (x.x-1./3.)*(v2r)+(x.y-1./3.)*(v1r+v2r) )*2.;\n}\n\nvec3 read(vec2 uv) {\n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    vec2 uv = ( fragCoord.xy - 0.5*iResolution.xy ) / iResolution.yy;\n    vec2 m = ( iMouse.xy - 0.5*iResolution.xy ) / iResolution.yy;\n    float a = iTime*0.02;\n    if ( length(iMouse.xy)<2. ) { m = vec2(cos(a),sin(a))*0.28; }\n    vec3 uvh = vec3(uv,1.);\n    \n    float th1 = 0.1;\n    mat3 trans1 = 2.0*mat3(\n        cos(th1),sin(th1),0.,\n        -sin(th1),cos(th1),0.,\n        0.05, 0.02, 1.);\n    \n    float th2 = -0.53;\n    mat3 trans2 = 5.5*mat3(\n        cos(th2),-sin(th2),0.,\n        sin(th2),cos(th2),0.,\n        0., 0., 1.);\n    \n    mat3 clrtrans1 = 0.9*mat3(\n        1., -0.1, 0.1,\n        -0.1, 1.0, -0.1,\n        -0.1, 0.1, 1.0 );\n\n    float th4 = 1.*pi/2.;\n    \n    vec2 uvk = kld(uv,vec2(1.,0.));\n    mat2 mrot = 5.*mat2(m.x,-m.y,m.y,m.x);\n    vec2 uvk2 = kld(mrot*uvk+vec2(0.),vec2(0.7,0.0));\n    fragColor.rgb = clrtrans1*texture(iChannel0, uvk2*vec2(iResolution.y/iResolution.x,1.)+vec2(0.5)).rgb;\n    fragColor.rgb += 0.5*vec3(pow(max(0.,1.-abs(0.28+dot(vec2(cos(th4),sin(th4)),uvk))),50.));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Added, 2019, for compatibility with some devices.\n#define LINEAR_FILTER_CONFIG  true,true,true,true\n\n\n/* Linear Filtering Shim by Theron Tarigo, 2019.\n   https://www.shadertoy.com/view/tssXWf         */\nconst struct LINEARFILTER_T {\n  bool iChannel0, iChannel1, iChannel2, iChannel3;\n} LINEARFILTER = LINEARFILTER_T(LINEAR_FILTER_CONFIG);\n\nconst struct SAMPLERINDEX_T {\n  int iChannel0, iChannel1, iChannel2, iChannel3;\n} SAMPLERINDEX = SAMPLERINDEX_T(0,1,2,3);\n\nvec4 textureLinearPix (sampler2D sampler, vec2 U) {\n  return mix(mix(\n      texelFetch(sampler,ivec2(U)+ivec2(0,0),0),\n      texelFetch(sampler,ivec2(U)+ivec2(1,0),0),\n    fract((U).x)),mix(\n      texelFetch(sampler,ivec2(U)+ivec2(0,1),0),\n      texelFetch(sampler,ivec2(U)+ivec2(1,1),0),\n    fract((U).x)),fract((U).y));\n}\n\n#define textureLinear(sampler,P) textureLinearPix(sampler, \\\n    (P)*iChannelResolution[SAMPLERINDEX.sampler].xy-vec2(.5))\n\n#define texture(sampler,P) ( LINEARFILTER.iChannel0 ? \\\n    textureLinear(sampler,P) \\\n  : texture(sampler,P) )\n// End of Linear Filtering Shim\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}