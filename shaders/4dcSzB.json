{
    "Shader": {
        "info": {
            "date": "1459885292",
            "description": "Raymarching template to avoid always writing the same setup.",
            "flags": 0,
            "hasliked": 0,
            "id": "4dcSzB",
            "likes": 7,
            "name": "My Raymarching Template",
            "published": 3,
            "tags": [
                "raymarching",
                "template",
                "hgsdf"
            ],
            "usePreview": 0,
            "username": "Daedelus",
            "viewed": 905
        },
        "renderpass": [
            {
                "code": "/**\nSimple scene that displays a raymarched sphere on a floor at (0,0,0)\n\nIncludes \"Noise value 3D\" by IQ\n\nIncludes minified HG_SDF by Mercury (mercury.sexy/hg_sdf) \nto have all primitives & spatial operators without taking up too much space; \nomitted platonic solids because the original code uses arrays and I was lazy.\n\nSome functions are converted to macros because they would be even smaller when preprocessed.\n\nAnother macro, _M, is really filling up almost identical code as to make the result even smaller,\nthis breaks Shader_Minifier by CTRL_ALT_TEST, just so you know. \n\nAdditionally a lot of float constants are suffixed with '.' to support WebGL\n\nCntains a simple Gradient() function (without normalize, so only works on real linear SDF functions).\nas well as basic diffuse top light, distance fog and horizon gradient.\n\nUse in any way you like, I in no way can take any credit for this.\n\nI tried to be basic & brief, no lighting shadows ao or reflections, no functions where not necessary (texture, trace, shade).\n**/\n\n#define PI 3.14159265359\nconst float _1=.57735026919;\nconst vec2 _A=normalize(vec2(2.61803398875, 1));\nconst vec2 _B=normalize(vec2(1,1.61803398875));\nfloat fSphere(vec3 p,float r){return length(p)-r;}\nfloat fPlane(vec3 p,vec3 n,float d){return dot(p,n)+d;}\nfloat fBoxCheap(vec3 p,vec3 b){vec3 q=(abs(p)-b);return max(max(q.x,q.y),q.z);}\nfloat fBox(vec3 p,vec3 b){vec3 q,d=abs(p)-b;q=min(d,0.);return length(max(d,0.))+max(max(q.x,q.y),q.z);}\nfloat fBox2Cheap(vec2 p,vec2 b){vec2 q=abs(p)-b;return max(q.x,q.y);}\nfloat fBox2(vec2 p,vec2 b){vec2 q,d=abs(p)-b;q=min(d,0.);return length(max(d,0.))+max(q.x,q.y);}\nfloat fCorner(vec2 p){vec2 q=min(p,0.);return length(max(p,0.))+max(q.x,q.y);}\nfloat fBlob(vec3 p){p=abs(p);if(p.x<max(p.y,p.z))p=p.yzx;if(p.x<max(p.y,p.z))p=p.yzx;float l=length(p),b=max(max(max(dot(p,vec3(_1)),dot(p.xz,_A)),dot(p.yx,_B)),dot(p.xz,_B));return l-1.5-.15*cos(min(sqrt(1.01-b/l)*4.*PI,PI));}\nfloat fCylinder(vec3 p,float r,float h){return max(length(p.xz)-r,abs(p.y)-h);}\nfloat fCapsule(vec3 p,float r,float c){return mix(length(p.xz)-r,length(vec3(p.x,abs(p.y)-c,p.z))-r,step(c,abs(p.y)));}\nfloat fLineSegment(vec3 p,vec3 a,vec3 b){vec3 c=b-a;float t=clamp(dot(p-a,c)/dot(c,c),0.,1.);return length(c*t+a-p);}\nfloat fCapsule(vec3 p,vec3 a,vec3 b,float r){return fLineSegment(p,a,b)-r;}\nfloat fTorus(vec3 p,float i,float r){return length(vec2(length(p.xz)-r,p.y))-i;}\nfloat fCircle(vec3 p,float r){return length(vec2(p.y,length(p.xz)-r));}\nfloat fDisc(vec3 p,float r){float l=length(p.xz)-r;return l<0.?abs(p.y):length(vec2(p.y,l));}\nfloat fHexagonCircumcircle(vec3 p,vec2 h){vec3 q=abs(p);return max(q.y-h.y,max(q.x*0.866+q.z*.5,q.z)-h.x);}\nfloat fHexagonIncircle(vec3 p,vec2 h){return fHexagonCircumcircle(p,vec2(h.x*0.866,h.y));}\nfloat fCone(vec3 p,float r,float h){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=normalize(vec2(h,r));float j=dot(t,vec2(m.y,-m.x)),d=max(dot(t,m),-q.y);if(q.y>h&&j<0.)d=max(d,length(t));if(q.x>r&&j>length(vec2(h,r)))d=max(d,length(q-vec2(r,0.)));return d;}\nvoid pR(inout vec2 p,float a){p=cos(a)*p+sin(a)*vec2(p.y,-p.x);}\nvoid pR45(inout vec2 p){p=(p+vec2(p.y,-p.x))*sqrt(.5);}\nfloat pMod1(inout float p,float s){float c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModMirror1(inout float p,float s){float c=pMod1(p,s);p*=mod(c,2.)*2.-1.;return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);if(p>=0.)p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pMod1(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModPolar(inout vec2 p,float t){float g=6.28318530718/t,a=atan(p.y,p.x)+g*.5,r=length(p),c=floor(a/g);a=mod(a,g)-g*.5;p=vec2(cos(a),sin(a))*r;if(abs(c)>=t*.5)c=abs(c);return c;}\nvec2 pMod2(inout vec2 p,vec2 s){vec2 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pMod2(p,s);p*=mod(c,2.)*2.-1.;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size){vec2 c=floor((p+size*.5)/size);p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5;if(p.x>p.y)p.xy=p.yx;return floor(c*.5);}\nvec3 pMod3(inout vec3 p,vec3 s){vec3 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pMirror(inout float p,float d){float s=(p<0.)?-1.:1.;p=abs(p)-d;return s;}\nvec2 pMirrorOctant (inout vec2 p,vec2 dist){vec2 s=vec2((p.x<0.)?-1.:1.,(p.y<0.)?-1.:1.);pMirror(p.x,dist.x);pMirror(p.y,dist.y);if(p.y>p.x)p.xy=p.yx;return s;}\nfloat pReflect(inout vec3 p,vec3 n,float o){float t=dot(p,n)+o;if(t<0.){p=p-(t+t)*n;}return (t<0.)?-1.:1.;}\nfloat fOpUnionChamfer(float a,float b,float r){return min(min(a,b),(a-r+b)*sqrt(.5));}\nfloat fOpIntersectionChamfer(float a,float b,float r){return max(max(a,b),(a+r+b)*sqrt(.5));}\n#define fOpDifferenceChamfer(a,b,r) fOpIntersectionChamfer(a,-b,r)\nfloat fOpUnionRound(float a,float b,float r){vec2 u=max(vec2(r-a,r-b),0.);return max(r,min(a,b))-length(u);}\nfloat fOpIntersectionRound(float a,float b,float r){vec2 u=max(vec2(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\nfloat fOpDifferenceRound(float a,float b,float r){return fOpIntersectionRound(a,-b,r);}\n#define _M(S) (float a,float b,float r,float n){float c,m=min(a,b);if(a>r||b>r)return S*m;vec2 p=vec2(a,b);c=r*1.41421356237/(n*2.-0.58578643762);pR45(p);\nfloat fOpUnionColumns _M(1.)p.x+=0.70710678118*-r+c*1.41421356237;if(mod(n,2.)==1.)p.y+=c;pMod1(p.y,c*2.);return min(min(min(length(p)-c,p.x),a),b);}\nfloat fOpDifferenceColumns _M(-1.)p.y+=c;p.x-=0.70710678118*(r+c);if(mod(n,2.)==1.)p.y+=c;pMod1(p.y,c*2.);return-min(min(max(-length(p)+c,p.x),a),b);}\n#define fOpIntersectionColumns(a,b,r,n) fOpDifferenceColumns(a-b,r,n)\nfloat fOpUnionStairs(float a,float b,float r,float n){float s=r/n;float u=b-r;return min(min(a,b),.5*(u+a+abs(mod(u-a+s,2.*s)-s)));}\n#define fOpIntersectionStairs(a,b,r,n) -fOpUnionStairs(-a,-b,r,n)\n#define fOpDifferenceStairs(a,b,r,n) -fOpUnionStairs(-a,b,r,n)\nfloat fOpUnionSoft(float a,float b,float r){float e=max(r-abs(a-b),0.);return min(a,b)-e*e*.25/r;}\nfloat fOpPipe(float a,float b,float r){return length(vec2(a,b))-r;}\nfloat fOpEngrave(float a,float b,float r){return max(a,(a+r-abs(b))*sqrt(.5));}\nfloat fOpGroove(float a,float b,float ra,float rb){return max(a,min(a+ra,rb-abs(b)));}\nfloat fOpTongue(float a,float b,float ra,float rb){return min(a,max(a-ra,abs(b)-rb));}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fField(vec3 point, out float material)\n{\n    material = 0.0;\n    float distance = -fBox(point, vec3(5.0, 5.0, 10.0));\n    return distance;\n}\n\nfloat fField(vec3 point)\n{\n    float stub;\n\treturn fField(point, stub);\n}\n\nvec3 Gradient(vec3 intersection, float distance)\n{\n    vec2 epsilon = vec2(0.01, 0.0);\n    return (vec3(fField(intersection + epsilon.xyy),\n    fField(intersection + epsilon.yxy),\n    fField(intersection + epsilon.yyx))\n        - distance) / epsilon.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    const float FOV_BIAS = 0.35;\n    const int RAY_STEPS = 100;\n    const float NEAR_CLIP = 0.5;\n    const float FAR_CLIP = 100.0;\n    const vec3 SKY = vec3(0.1, 0.5, 1.0);\n    const vec3 HORIZON = vec3(1.0, 1.0, 0.8);\n    \n    vec3 normal, intersection, origin = vec3(0.0, 1.0, -10.0), direction = vec3(0.0, 0.0, 1.0);\n    pR(direction.xz, uv.x * FOV_BIAS);\n    pR(direction.yz, uv.y * FOV_BIAS + sin(iTime) * 0.1);\n    \n    float material, distance, totalDistance = NEAR_CLIP;\n    for(int i =0 ;  i < RAY_STEPS; ++i)\n    {\n        intersection = origin + direction * totalDistance;\n        distance = fField(intersection, material);\n        totalDistance += distance;\n        if(distance <= 0.0 || totalDistance >= FAR_CLIP)\n            break;\n    }\n    \n    normal = Gradient(intersection, distance);\n    vec3 color = vec3(1.0) * (normal.y * 0.5 + 0.5);\n    \n    float fog = min(totalDistance / FAR_CLIP, 1.0);\n    vec3 skyColor = mix(HORIZON, SKY, pow(abs(direction.y), 0.25));\n    \n\tfragColor = vec4(mix(color, skyColor, fog), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}