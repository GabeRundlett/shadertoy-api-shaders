{
    "Shader": {
        "info": {
            "date": "1575957679",
            "description": "Basic atmospheric scattering in a shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdK3zy",
            "likes": 10,
            "name": "Rayleigh Scattering",
            "published": 3,
            "tags": [
                "sky",
                "scattering",
                "rayleigh",
                "mie"
            ],
            "usePreview": 0,
            "username": "EvilTak",
            "viewed": 1463
        },
        "renderpass": [
            {
                "code": "\n// constants\n\n#define PI (3.14159265)\n#define EARTH_RADIUS (6370997.0)\n\nconst float kOuterRadius = EARTH_RADIUS * 1.025;\nconst float kOuterRadius2 = kOuterRadius * kOuterRadius;\nconst float kInnerRadius = EARTH_RADIUS;\nconst float kInnerRadius2 = kInnerRadius * kInnerRadius;\n\nconst float kScale = 1.0 / (kOuterRadius - kInnerRadius);\nconst float kScaleDepth = 0.25;\nconst float kScaleOverScaleDepth = kScale / kScaleDepth;\nconst float kCameraHeight = 0.0001;\n\nconst float kRAYLEIGH = 0.005;\nconst float kMIE = 0.01;\n\nconst float kR4PI = kRAYLEIGH * 4.0 * PI;\n\n// Wavelength factors for scattering\nconst vec3 k_lambda_variance = vec3(0.0, 0., 0.);\nconst vec3 k_lambda = vec3(0.65, .57, 0.475) - k_lambda_variance;\n\nconst float kM4PI = kMIE * 4.0 * PI;\n\nconst float mie_g = -0.99;\nconst float mie_g2 = mie_g * mie_g;\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate(vec3 x) {\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n\nfloat rayleigh_phase(float cos2) {\n    return 0.75 * (1.0 + cos2);\n}\n\nfloat mie_phase(float c, float cos2) {\n    float temp = 1.0 + mie_g2 - 2.0 * mie_g * c;\n    temp = smoothstep(0.0, 0.01, temp) * temp;\n    //temp = pow(temp, 1.5);\n    temp = max(temp, 0.0001);\n    return 1.5 * ((1.0 - mie_g2) / (2.0 + mie_g2)) * (1.0 + cos2) / temp;\n}\n\nfloat scale(float inCos) {\n    float x = 1.0 - inCos;\n    return 0.25 * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\nvec3 renderSky(in vec3 viewDir, in vec3 lightDir) {\n    \n    //lightDir = normalize(vec3(0., 0., 1.0));\n    viewDir = normalize(viewDir);\n    //viewDir = lightDir;\n    \n    float height = kInnerRadius + kCameraHeight;\n    vec3 cameraPos = vec3(0.0, height, 0.0);\n    \n    float depth = exp(kScaleOverScaleDepth * (-kCameraHeight));\n    // angle between eye ray and camera height\n    float startAngle = dot(viewDir, cameraPos) / height;\n    float startAngleScale = scale(startAngle);\n    float startOffset = depth * startAngleScale;\n    \n\t// Calculate the length of the \"atmosphere\"\n\tfloat far = sqrt(kOuterRadius2 + kInnerRadius2 * viewDir.y * viewDir.y - kInnerRadius2) - kInnerRadius * viewDir.y;\n\n\tvec3 pos = cameraPos + far * viewDir;\n    \n    // Initialize the scattering loop variables\n\tfloat sampleLength = far / 2.0;\n\tfloat scaledLength = sampleLength * kScale;\n\tvec3 sampleRay = viewDir * sampleLength;\n\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\n    \n    vec3 invLambda = pow(k_lambda, vec3(-4.0));\n    vec3 front = vec3(0.0);\n    \n    float brightness = 20.0;// = lightDir.y <= 0.0 ? 1.0 : 20.0;\n    const float range = 0.1;\n    /*\n    if(lightDir.y >= 0.0) {\n        brightness = 20.0;\n    \tif(lightDir.y <= range)\n        \tbrightness = mix(10.0, 20.0, saturate(lightDir.y / range));\n    }\n    else {\n        brightness = 1.0;\n        if(lightDir.y >= -range)\n            brightness = mix(10.0, 1.0, saturate(-lightDir.y / range));\n    }\n    \n    lightDir.y = abs(lightDir.y);\n    */\n    for (int i = 0; i < 1; ++i) {\n        float height = length(samplePoint);\n\t\tfloat depth = exp(kScaleOverScaleDepth * (kInnerRadius - height));\n        float lightAngle = dot(lightDir, samplePoint) / height;\n\t\tfloat cameraAngle = dot(viewDir, samplePoint) / height;\n\t\tfloat scatter = (startOffset + depth*(scale(lightAngle) - scale(cameraAngle)));\n        vec3 atten = exp(-clamp(scatter, 0.0, 50.0) * (invLambda * kR4PI + kM4PI));\n        \n        front += atten * (depth * scaledLength);\n        samplePoint += sampleRay;\n    }\n        \n    vec3 c1 = front * invLambda * kRAYLEIGH * brightness;\n    \n    vec3 c2 = front * kMIE * brightness;\n    \n    float eyeCos = -dot(viewDir, lightDir);\n    float eyeCos2 = eyeCos * eyeCos;\n    \n    float rayleigh = rayleigh_phase(eyeCos2);\n    float mie = mie_phase(eyeCos, eyeCos2);\n    \n    // mie = 0\n    \n    vec3 col = step(0.0, viewDir.y) * sqrt(rayleigh * c1 + mie * c2);\n    \n    return col;\n}\n\nvec3 rotateX(in vec3 v, in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    mat3 m = mat3(1., 0., 0.,\n                0., c, s,\n                0., -s, c);\n    \n    return m * v;\n}\n\nfloat sunAngle = 4.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //screen coords\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 v = -1.0+2.0*q;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\t//camera ray\n\tvec3 dir = normalize(vec3(v.x, v.y+.5, -1.5));\n    \n    //dir = cross(dir, vec3(1.0, 0.0, 0.0));\n    //dir = vec3(0.0, 0.8, 1.);\n    \n    sunAngle = -iTime * .3;\n    \n    //dir = rotateX(dir, PI * 1.9);\n    \n    vec3 sun = normalize(rotateX(vec3(0.0, 0.0, 1.0), sunAngle));\n    \n    vec3 sky = renderSky(dir, sun);\n    fragColor = vec4(sky, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}