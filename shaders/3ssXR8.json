{
    "Shader": {
        "info": {
            "date": "1550594860",
            "description": "Port of a rayglider script minus the audio reactive bits. Original here https://tinyurl.com/ybgfwulm",
            "flags": 0,
            "hasliked": 0,
            "id": "3ssXR8",
            "likes": 17,
            "name": "El Jardí de Catalunya",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "fbm",
                "mandelbulb"
            ],
            "usePreview": 0,
            "username": "wizgrav",
            "viewed": 868
        },
        "renderpass": [
            {
                "code": " \n #define PI 3.14159265359\n #define PI2 6.28318530718\n #define PHI 1.618033988749895\n \n #define saturate(x) clamp(x, 0., 1.)\n \n \n \n // exported https//tinyurl.com/y82cdk8k\n vec2  raygl_sdf_map_1( in vec3 p) ;\n \n \n // exported https//tinyurl.com/y82cdk8k\n const int  raygl_sdf_ray_steps_1 =  128 ;\n \n \n // exported https//tinyurl.com/y82cdk8k\n const float  raygl_sdf_max_dist_1 =  48. ;\n \n \n // exported sdf\n const float  raygl_sdf_min_dist_6 =  1. ;\n \n \n // exported sdf\n const int  raygl_sdf_shadow_steps_6 =  16 ;\n \n \n // exported color\n const bool  raygl_color_lut_clamp_7 =  true ;\n \n \n // exported color\n const bool  raygl_color_lut_flip_7 =  false ;\n \n \n // body color\n vec3 raygl_rgb2hsv_7(vec3 c){\n     vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n     vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n     vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n     float d = q.x - min(q.w, q.y);\n     float e = 1.0e-10;\n     return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n }\n vec3 raygl_hsv2rgb_7(vec3 c)\n {\n     vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n     vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n     return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n }\n\n \n // body sdf\n vec2 raygl_sdf_map_6(in vec3 p) {\n     return vec2(length(p)-3., 0.);\n }\n vec2 raygl_cast_6( in vec3 ro, in vec3 rd )\n {\n     float t = raygl_sdf_min_dist_6;\n     float m = -1.0;\n     for( int i=0; i < raygl_sdf_ray_steps_1; i++ )\n     {\n \t    float precis = 0.0005*t;\n \t    vec2 res = raygl_sdf_map_1( ro+rd*t );\n         if( res.x < precis || t > raygl_sdf_max_dist_1 ) break;\n         t += res.x;\n \t    m = res.y;\n     }\n     if( t > raygl_sdf_max_dist_1 ) m=-1.0;\n     return vec2( t, m );\n }\n vec3 raygl_norms_6( in vec3 pos )\n {\n     vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n     return normalize( e.xyy*raygl_sdf_map_1( pos + e.xyy ).x + \n \t\t\t\t\t  e.yyx*raygl_sdf_map_1( pos + e.yyx ).x + \n \t\t\t\t\t  e.yxy*raygl_sdf_map_1( pos + e.yxy ).x + \n \t\t\t\t\t  e.xxx*raygl_sdf_map_1( pos + e.xxx ).x );\n }\n vec3 raygl_normals_6( in vec3 pos )\n {\n     vec3 eps = vec3( 0.0005, 0.0, 0.0 );\n \tvec3 nor = vec3(\n \t    raygl_sdf_map_1(pos+eps.xyy).x - raygl_sdf_map_1(pos-eps.xyy).x,\n \t    raygl_sdf_map_1(pos+eps.yxy).x - raygl_sdf_map_1(pos-eps.yxy).x,\n \t    raygl_sdf_map_1(pos+eps.yyx).x - raygl_sdf_map_1(pos-eps.yyx).x );\n \treturn normalize(nor);\n }\n float raygl_shadow_6( in vec3 point, in vec3 rd, in float mint, in float tmax )\n {\n     vec3 ro = point;\n \tfloat res = 1.0;\n     float t = mint;\n     for( int i=0; i < raygl_sdf_shadow_steps_6; i++ )\n     {\n \t\tfloat h = raygl_sdf_map_1( ro + rd*t ).x;\n         res = min( res, 8.0*h/t );\n         t += clamp( h, 0.02, 0.10 );\n         if( h<0.001 || t>tmax ) break;\n     }\n     return clamp( res, 0.0, 1.0 );\n }\n float raygl_occlusion_6( vec3 pos, vec3 nor )\n {\n     float oc = 0.0;\n     float sca = 1.0;\n     for( int i=0; i<5; i++ )\n     {\n         float hr = 0.01 + 0.12*float(i)/4.0;\n         vec3 aopos =  nor * hr + pos;\n         float dd = raygl_sdf_map_1( aopos ).x;\n         oc += -(dd-hr)*sca;\n         sca *= 0.95;\n     }\n     return clamp( 1.0 - 3.0*oc, 0.0, 1.0 );    \n }\n \n // body noise/worley2D\n   // worley noise from glslify\n vec3 raygl_permute_5(vec3 x) {\n     return mod((34.0 * x + 1.0) * x, 289.0);\n   }\n\n vec3 raygl_dist_5(vec3 x, vec3 y,  bool manhattandistance) {\n\n     return manhattandistance ?  abs(x) + abs(y)  : (x * x + y * y);\n \n }\n   vec2 raygl_noise_5(vec2 P, float jitter, bool manhattandistance) {\n   float K= 0.142857142857; // 1/7\n   float Ko= 0.428571428571 ;// 3/7\n   \tvec2 Pi = mod(floor(P), 289.0);\n    \tvec2 Pf = fract(P);\n   \tvec3 oi = vec3(-1.0, 0.0, 1.0);\n   \tvec3 of = vec3(-0.5, 0.5, 1.5);\n   \tvec3 px = raygl_permute_5(Pi.x + oi);\n   \tvec3 p = raygl_permute_5(px.x + Pi.y + oi); // p11, p12, p13\n   \tvec3 ox = fract(p*K) - Ko;\n   \tvec3 oy = mod(floor(p*K),7.0)*K - Ko;\n   \tvec3 dx = Pf.x + 0.5 + jitter*ox;\n   \tvec3 dy = Pf.y - of + jitter*oy;\n   \tvec3 d1 = raygl_dist_5(dx,dy, manhattandistance); // d11, d12 and d13, squared\n   \tp = raygl_permute_5(px.y + Pi.y + oi); // p21, p22, p23\n   \tox = fract(p*K) - Ko;\n   \toy = mod(floor(p*K),7.0)*K - Ko;\n   \tdx = Pf.x - 0.5 + jitter*ox;\n   \tdy = Pf.y - of + jitter*oy;\n   \tvec3 d2 = raygl_dist_5(dx,dy, manhattandistance); // d21, d22 and d23, squared\n   \tp = raygl_permute_5(px.z + Pi.y + oi); // p31, p32, p33\n   \tox = fract(p*K) - Ko;\n   \toy = mod(floor(p*K),7.0)*K - Ko;\n   \tdx = Pf.x - 1.5 + jitter*ox;\n   \tdy = Pf.y - of + jitter*oy;\n   \tvec3 d3 = raygl_dist_5(dx,dy, manhattandistance); // d31, d32 and d33, squared\n   \t// Sort out the two smallest distances (F1, F2)\n   \tvec3 d1a = min(d1, d2);\n   \td2 = max(d1, d2); // Swap to keep candidates for F2\n   \td2 = min(d2, d3); // neither F1 nor F2 are now in d3\n   \td1 = min(d1a, d2); // F1 is now in d1\n   \td2 = max(d1a, d2); // Swap to keep candidates for F2\n   \td1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n   \td1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n   \td1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n   \td1.y = min(d1.y, d1.z); // nor in  d1.z\n   \td1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n   \treturn sqrt(d1.xy);\n   }\n \n // body phong\n struct raygl_Surface_4 {\n     vec3 normal;\n     vec3 diffuse;\n     vec3 specular;\n     float shiny;\n };\n vec3 raygl_direct_4( in raygl_Surface_4 s, in vec3 color, in vec3 dir ) \n {\n     vec3 halfDir = normalize( dir );\n     float dotNL = saturate( dot( s.normal, dir ) );\n \tfloat dotNH = saturate( dot( s.normal, halfDir ) );\n \tfloat dotLH = saturate( dot( dir, halfDir ) );\n     float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n \tvec3 F = ( 1.0 - s.specular ) * fresnel + s.specular;\n \t\n     vec3 L = (1. / PI) * s.diffuse * dotNL;\n \treturn color * (L + F * ( 0.25 * (1. / PI) * ( s.shiny * 0.5 + 1.0 ) * pow( dotNH, s.shiny ) ));\n }\n \n // body debug\n vec4 raygl_bars_3(vec4 m, vec2 uv) {\n     vec4 color = vec4(0.);\n     float inc = 1. / 4.;\n     for(float j=0.;j<4.;j++) {\n         float v = m.x;\n         m.xyzw = m.yzwx;\n         color.xyzw = color.yzwx;\n         if(uv.x < j * inc || uv.x >= (j + 1.) * inc) { \n             continue;\n         }\n         if(uv.y > v){ \n             color.w = 0.2;\n             continue;\n         }\n         color.w = 1.0;\n     }\n     if(color.a == 0.2) color.rgb = vec3(0.2);\n     else if(color.a == 1.0) color.rgb = vec3(1.);\n     color.a = 1.0;\n     return color;\n }\n \n // body camera\n mat3 raygl_lookAt_2( in vec3 ro, in vec3 ta, float cr )\n {\n \tvec3 cw = normalize(ta - ro);\n \tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n \tvec3 cu = normalize( cross(cw,cp) );\n \tvec3 cv = normalize( cross(cu,cw) );\n     return mat3( cu, cv, cw );\n }\n \n // body https//tinyurl.com/y82cdk8k\n // El Jardí de Catalunya\n // by wizgrav, just normals\n vec3 raygl_CMOD_1;\n vec2 raygl_BMOD_1 = vec2(0.5);\n vec4 raygl_rand_1(vec2 n) {\n   return fract( vec4(1.0, 255.0, 65025.0, 16581375.0) * fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453));\n }\n float raygl_smin_1( float a, float b, float k )\n {\n     float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n     return mix( b, a, h ) - k*h*(1.0-h);\n }\n vec2 raygl_sdf_map_1(in vec3 p) {\n   p.xyz = p.xzy;\n   vec3 c = raygl_CMOD_1;\n   vec3 q = mod(p,c)-0.5 * c;\n   vec3 z = q;\n   vec3 dz=vec3(0.0);\n   vec3 fl = floor((p-q) / raygl_CMOD_1) * raygl_CMOD_1;\n   vec4 r4 = raygl_rand_1( fl.xy );\n   float power = 8.0 + 2. * floor(4. * r4.x);\n   float r, theta, phi;\n   float dr = 1.0;\n   float t0 = 1.0;\n   for(int i = 0; i < 4; ++i) {\n     r = length(z);\n     if(r > 2.0) continue;\n     theta = atan(z.y / z.x) ;\n     phi = asin(z.z / r)  + iTime * 0.3  + 0.9 * mix(raygl_BMOD_1.x,1. - raygl_BMOD_1.y, 0.66 + r4.x * 0.33);\n     \n     dr = pow(r, power - 1.) * dr * power + 1. ;\n     r = pow(r, power);\n     theta = theta * power;\n     phi = phi * power;\n     z = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + q;\n     power +=  2. * floor(4. * r4.y) + r4.x * 0.5;\n     t0 = min(t0, r);\n     r4.xyzw = r4.yzwx;\n    }\n   float rz = 0.5 * log(r) * r / dr;\n   rz = raygl_smin_1(q.z , rz, 0.24);\n   return vec2(rz, mix( 0.1, t0, abs(q.z) * 0.96 ));\n }\n float raygl_shape_1(in vec2 fragCoord, out vec3 pt, out vec3 nor) {\n   raygl_CMOD_1 = vec3(2.9 ,2.9,0. );\n   vec3 ro = vec3(4. + iTime * 0.33, 1.7 , 2.9);\n   mat3 cam = raygl_lookAt_2(ro, ro + vec3(4.,-6. ,0.), 0.);\n   vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n   vec3 rd = cam * normalize( vec3(p.xy,1.0) );\n   vec2 res = raygl_cast_6(ro, rd);\n   pt = ro + res.x * rd;\n   nor = raygl_normals_6(pt);\n   return res.y;\n }\n void raygl_main_1(inout vec4 fragColor, vec2 fragCoord) {\n   vec3 pt;\n   vec3 nor;\n   raygl_shape_1(fragCoord, pt, nor);  \n   fragColor.rgb = nor;\n }\n \n // body \n // El Jardí de Catalunya\n // by wizgrav\n \n   \n float raygl_fbm_(vec2 uv) {\n     float amp = 1., freq = 6., asum = 0., res = 0.;\n     for(int i=0; i < 3; i++) {\n         res += raygl_noise_5(uv * freq , 1., false).x * amp;\n         asum += amp;\n         freq *= 2.;\n         amp *= 0.5;\n     }\n     return res / asum;\n }\n void mainImage(out vec4 fragColor, vec2 fragCoord) {\n   vec4 bms = vec4(1.);\n   raygl_BMOD_1 = bms.xy;\n   \n    \n   vec3 pt;\n   vec3 nor;\n   float m = raygl_shape_1(fragCoord, pt, nor);\n   raygl_Surface_4 s;\n   float z = 0.;\n   float mz = raygl_sdf_map_1(vec3( pt.x, 1.0, pt.z)).x;\n   float q = raygl_fbm_(pt.xz * 0.1);\n   z =  raygl_fbm_(pt.xz * 0.2 + vec2(0.01, 0.02) * iTime + vec2(0.2 * bms.y,0.2 * bms.z)  + q);\n   vec3 p = vec3(pt.x, 0.03 * z, pt.z );\n   vec3 nor2 = normalize(cross(dFdx(p),dFdy(p)));\n   float f = smoothstep(0., 0.1, pt.y);\n   nor = mix(nor2, nor, f);\n   s.diffuse = vec3(raygl_hsv2rgb_7(vec3(pow(m, 2.) ,   1. - m,  0.66 -  z * (1. - f)  )));\n   s.specular = vec3(0.9);\n   s.shiny = 32. * m;\n   s.normal = nor;\n   vec3 nv = normalize(vec3(2., 6., 2.));\n   float att = max(0.33, length(pow(bms,vec4(1.33))));\n   vec3 l = raygl_direct_4(s, vec3(att), nv);\n   float ao = raygl_occlusion_6(pt, nor);\n   vec3 col = mix(vec3(0.000, 0.067, 0.067), vec3(0.200, 0.196, 0.200) , s.normal.y) * ao * att + l * raygl_shadow_6( pt, nv, 0.1, 4.0 ); \n   col = pow(col, vec3(1./2.2));\n   fragColor = vec4(col,1.0);\n\n }\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}