{
    "Shader": {
        "info": {
            "date": "1626598207",
            "description": "Shadertoy port of AMD FidelityFX Super Resolution (FSR).  Other upscalers: https://www.shadertoy.com/playlist/WcKXWW\n",
            "flags": 32,
            "hasliked": 0,
            "id": "stXSWB",
            "likes": 40,
            "name": "AMD FidelityFX: Super Resolution",
            "published": 3,
            "tags": [
                "fsr"
            ],
            "usePreview": 1,
            "username": "goingdigital",
            "viewed": 6217
        },
        "renderpass": [
            {
                "code": "/*\n* FidelityFX Super Resolution scales up a low resolution\n* image, while adding fine detail.\n*\n* MIT Open License\n*\n* https://gpuopen.com/fsr\n*\n* Left: FSR processed\n* Right: Original texture, bilinear interpolation\n*\n* Mouse at top: Sharpness 0 stops (maximum)\n* Mouse at bottom: Sharpness 2 stops (minimum)\n*\n* It works in two passes-\n*   EASU upsamples the image with a clamped Lanczos kernel.\n*   RCAS sharpens the image at the target resolution.\n*\n* I needed to make a few changes to improve readability and\n* WebGL compatibility in an algorithm I don't fully understand.\n* Expect bugs.\n*\n* Shader not currently running for WebGL1 targets (eg. mobile Safari)\n*\n* There is kind of no point to using FSR in Shadertoy, as it renders buffers\n* at full target resolution. But this might be useful for WebGL based demos\n* running smaller-than-target render buffers.\n*\n* For sharpening with a full resolution render buffer,\n* FidelityFX CAS is a better option.\n* https://www.shadertoy.com/view/ftsXzM\n*\n* For readability and compatibility, these optimisations have been removed:\n*   * Fast approximate inverse and inversesqrt\n*   * textureGather fetches (not WebGL compatible)\n*   * Multiplying by reciprocal instead of division\n*\n* Apologies to AMD for the numerous slowdowns and errors I have introduced.\n*\n*/\n\n/***** RCAS *****/\n#define FSR_RCAS_LIMIT (0.25-(1.0/16.0))\n//#define FSR_RCAS_DENOISE\n\n// Input callback prototypes that need to be implemented by calling shader\nvec4 FsrRcasLoadF(vec2 p);\n//------------------------------------------------------------------------------------------------------------------------------\nvoid FsrRcasCon(\n    out float con,\n    // The scale is {0.0 := maximum, to N>0, where N is the number of stops (halving) of the reduction of sharpness}.\n    float sharpness\n){\n    // Transform from stops to linear value.\n    con = exp2(-sharpness);\n}\n\nvec3 FsrRcasF(\n    vec2 ip, // Integer pixel position in output.\n    float con\n)\n{\n    // Constant generated by RcasSetup().\n    // Algorithm uses minimal 3x3 pixel neighborhood.\n    //    b \n    //  d e f\n    //    h\n    vec2 sp = vec2(ip);\n    vec3 b = FsrRcasLoadF(sp + vec2( 0,-1)).rgb;\n    vec3 d = FsrRcasLoadF(sp + vec2(-1, 0)).rgb;\n    vec3 e = FsrRcasLoadF(sp).rgb;\n    vec3 f = FsrRcasLoadF(sp+vec2( 1, 0)).rgb;\n    vec3 h = FsrRcasLoadF(sp+vec2( 0, 1)).rgb;\n    // Luma times 2.\n    float bL = b.g + .5 * (b.b + b.r);\n    float dL = d.g + .5 * (d.b + d.r);\n    float eL = e.g + .5 * (e.b + e.r);\n    float fL = f.g + .5 * (f.b + f.r);\n    float hL = h.g + .5 * (h.b + h.r);\n    // Noise detection.\n    float nz = .25 * (bL + dL + fL + hL) - eL;\n    nz=clamp(\n        abs(nz)\n        /(\n            max(max(bL,dL),max(eL,max(fL,hL)))\n            -min(min(bL,dL),min(eL,min(fL,hL)))\n        ),\n        0., 1.\n    );\n    nz=1.-.5*nz;\n    // Min and max of ring.\n    vec3 mn4 = min(b, min(f, h));\n    vec3 mx4 = max(b, max(f, h));\n    // Immediate constants for peak range.\n    vec2 peakC = vec2(1., -4.);\n    // Limiters, these need to be high precision RCPs.\n    vec3 hitMin = mn4 / (4. * mx4);\n    vec3 hitMax = (peakC.x - mx4) / (4.* mn4 + peakC.y);\n    vec3 lobeRGB = max(-hitMin, hitMax);\n    float lobe = max(\n        -FSR_RCAS_LIMIT,\n        min(max(lobeRGB.r, max(lobeRGB.g, lobeRGB.b)), 0.)\n    )*con;\n    // Apply noise removal.\n    #ifdef FSR_RCAS_DENOISE\n    lobe *= nz;\n    #endif\n    // Resolve, which needs the medium precision rcp approximation to avoid visible tonality changes.\n    return (lobe * (b + d + h + f) + e) / (4. * lobe + 1.);\n} \n\n\nvec4 FsrRcasLoadF(vec2 p) {\n    return texture(iChannel0,p/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Set up constants\n    float con;\n    float sharpness = 0.2;\n    float division = 0.5+.3*sin(iTime*.3);\n    if (iMouse.z > 0.) {\n        sharpness = 2.-2.*pow( iMouse.y / iResolution.y,.25);\n        division = iMouse.x / iResolution.x;\n    }\n    FsrRcasCon(con,sharpness);\n\n    // Perform RCAS pass\n    vec3 col = FsrRcasF(fragCoord, con);\n    \n    // Source image\n    vec2 uv1;\n    \n    // Bilinear interpolation\n    uv1 = fragCoord/iResolution.xy;\n    \n    // Nearest pixel\n    //uv1 = (floor(vec2(textureSize(iChannel1,0))*fragCoord/iResolution.xy)+.5)/vec2(textureSize(iChannel1,0));\n    \n    vec3 col_orig = texture(iChannel1,uv1).xyz;\n    \n    // Comparison tool\n    if (fragCoord.x/iResolution.x > division) col = col_orig;\n    if (abs(fragCoord.x/iResolution.x - division)<.005) col = vec3(0);\n\n    fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/* EASU stage\n*\n* This takes a reduced resolution source, and scales it up while preserving detail.\n*\n* Updates:\n*   stretch definition fixed. Thanks nehon for the bug report!\n*/\n\nvec3 FsrEasuCF(vec2 p) {\n    return texture(iChannel0,p).rgb;\n}\n\n/**** EASU ****/\nvoid FsrEasuCon(\n    out vec4 con0,\n    out vec4 con1,\n    out vec4 con2,\n    out vec4 con3,\n    // This the rendered image resolution being upscaled\n    vec2 inputViewportInPixels,\n    // This is the resolution of the resource containing the input image (useful for dynamic resolution)\n    vec2 inputSizeInPixels,\n    // This is the display resolution which the input image gets upscaled to\n    vec2 outputSizeInPixels\n)\n{\n    // Output integer position to a pixel position in viewport.\n    con0 = vec4(\n        inputViewportInPixels.x/outputSizeInPixels.x,\n        inputViewportInPixels.y/outputSizeInPixels.y,\n        .5*inputViewportInPixels.x/outputSizeInPixels.x-.5,\n        .5*inputViewportInPixels.y/outputSizeInPixels.y-.5\n    );\n    // Viewport pixel position to normalized image space.\n    // This is used to get upper-left of 'F' tap.\n    con1 = vec4(1,1,1,-1)/inputSizeInPixels.xyxy;\n    // Centers of gather4, first offset from upper-left of 'F'.\n    //      +---+---+\n    //      |   |   |\n    //      +--(0)--+\n    //      | b | c |\n    //  +---F---+---+---+\n    //  | e | f | g | h |\n    //  +--(1)--+--(2)--+\n    //  | i | j | k | l |\n    //  +---+---+---+---+\n    //      | n | o |\n    //      +--(3)--+\n    //      |   |   |\n    //      +---+---+\n    // These are from (0) instead of 'F'.\n    con2 = vec4(-1,2,1,2)/inputSizeInPixels.xyxy;\n    con3 = vec4(0,4,0,0)/inputSizeInPixels.xyxy;\n}\n\n// Filtering for a given tap for the scalar.\nvoid FsrEasuTapF(\n    inout vec3 aC, // Accumulated color, with negative lobe.\n    inout float aW, // Accumulated weight.\n    vec2 off, // Pixel offset from resolve position to tap.\n    vec2 dir, // Gradient direction.\n    vec2 len, // Length.\n    float lob, // Negative lobe strength.\n    float clp, // Clipping point.\n    vec3 c\n)\n{\n    // Tap color.\n    // Rotate offset by direction.\n    vec2 v = vec2(dot(off, dir), dot(off,vec2(-dir.y,dir.x)));\n    // Anisotropy.\n    v *= len;\n    // Compute distance^2.\n    float d2 = min(dot(v,v),clp);\n    // Limit to the window as at corner, 2 taps can easily be outside.\n    // Approximation of lancos2 without sin() or rcp(), or sqrt() to get x.\n    //  (25/16 * (2/5 * x^2 - 1)^2 - (25/16 - 1)) * (1/4 * x^2 - 1)^2\n    //  |_______________________________________|   |_______________|\n    //                   base                             window\n    // The general form of the 'base' is,\n    //  (a*(b*x^2-1)^2-(a-1))\n    // Where 'a=1/(2*b-b^2)' and 'b' moves around the negative lobe.\n    float wB = .4 * d2 - 1.;\n    float wA = lob * d2 -1.;\n    wB *= wB;\n    wA *= wA;\n    wB = 1.5625*wB-.5625;\n    float w=  wB * wA;\n    // Do weighted average.\n    aC += c*w;\n    aW += w;\n}\n\n//------------------------------------------------------------------------------------------------------------------------------\n// Accumulate direction and length.\nvoid FsrEasuSetF(\n    inout vec2 dir,\n    inout float len,\n    float w,\n    float lA,float lB,float lC,float lD,float lE\n)\n{\n    // Direction is the '+' diff.\n    //    a\n    //  b c d\n    //    e\n    // Then takes magnitude from abs average of both sides of 'c'.\n    // Length converts gradient reversal to 0, smoothly to non-reversal at 1, shaped, then adding horz and vert terms.\n    float lenX = max(abs(lD - lC), abs(lC - lB));\n    float dirX = lD - lB;\n    dir.x += dirX * w;\n    lenX = clamp(abs(dirX)/lenX,0.,1.);\n    lenX *= lenX;\n    len += lenX * w;\n    // Repeat for the y axis.\n    float lenY = max(abs(lE - lC), abs(lC - lA));\n    float dirY = lE - lA;\n    dir.y += dirY * w;\n    lenY = clamp(abs(dirY) / lenY,0.,1.);\n    lenY *= lenY;\n    len += lenY * w;\n}\n\n//------------------------------------------------------------------------------------------------------------------------------\nvoid FsrEasuF(\n    out vec3 pix,\n    vec2 ip, // Integer pixel position in output.\n    // Constants generated by FsrEasuCon().\n    vec4 con0, // xy = output to input scale, zw = first pixel offset correction\n    vec4 con1,\n    vec4 con2,\n    vec4 con3\n)\n{\n    //------------------------------------------------------------------------------------------------------------------------------\n    // Get position of 'f'.\n    vec2 pp = ip * con0.xy + con0.zw; // Corresponding input pixel/subpixel\n    vec2 fp = floor(pp);// fp = source nearest pixel\n    pp -= fp; // pp = source subpixel\n\n    //------------------------------------------------------------------------------------------------------------------------------\n    // 12-tap kernel.\n    //    b c\n    //  e f g h\n    //  i j k l\n    //    n o\n    // Gather 4 ordering.\n    //  a b\n    //  r g\n    vec2 p0 = fp * con1.xy + con1.zw;\n    \n    // These are from p0 to avoid pulling two constants on pre-Navi hardware.\n    vec2 p1 = p0 + con2.xy;\n    vec2 p2 = p0 + con2.zw;\n    vec2 p3 = p0 + con3.xy;\n\n    // TextureGather is not available on WebGL2\n    vec4 off = vec4(-.5,.5,-.5,.5)*con1.xxyy;\n    // textureGather to texture offsets\n    // x=west y=east z=north w=south\n    vec3 bC = FsrEasuCF(p0 + off.xw); float bL = bC.g + 0.5 *(bC.r + bC.b);\n    vec3 cC = FsrEasuCF(p0 + off.yw); float cL = cC.g + 0.5 *(cC.r + cC.b);\n    vec3 iC = FsrEasuCF(p1 + off.xw); float iL = iC.g + 0.5 *(iC.r + iC.b);\n    vec3 jC = FsrEasuCF(p1 + off.yw); float jL = jC.g + 0.5 *(jC.r + jC.b);\n    vec3 fC = FsrEasuCF(p1 + off.yz); float fL = fC.g + 0.5 *(fC.r + fC.b);\n    vec3 eC = FsrEasuCF(p1 + off.xz); float eL = eC.g + 0.5 *(eC.r + eC.b);\n    vec3 kC = FsrEasuCF(p2 + off.xw); float kL = kC.g + 0.5 *(kC.r + kC.b);\n    vec3 lC = FsrEasuCF(p2 + off.yw); float lL = lC.g + 0.5 *(lC.r + lC.b);\n    vec3 hC = FsrEasuCF(p2 + off.yz); float hL = hC.g + 0.5 *(hC.r + hC.b);\n    vec3 gC = FsrEasuCF(p2 + off.xz); float gL = gC.g + 0.5 *(gC.r + gC.b);\n    vec3 oC = FsrEasuCF(p3 + off.yz); float oL = oC.g + 0.5 *(oC.r + oC.b);\n    vec3 nC = FsrEasuCF(p3 + off.xz); float nL = nC.g + 0.5 *(nC.r + nC.b);\n   \n    //------------------------------------------------------------------------------------------------------------------------------\n    // Simplest multi-channel approximate luma possible (luma times 2, in 2 FMA/MAD).\n    // Accumulate for bilinear interpolation.\n    vec2 dir = vec2(0);\n    float len = 0.;\n\n    FsrEasuSetF(dir, len, (1.-pp.x)*(1.-pp.y), bL, eL, fL, gL, jL);\n    FsrEasuSetF(dir, len,    pp.x  *(1.-pp.y), cL, fL, gL, hL, kL);\n    FsrEasuSetF(dir, len, (1.-pp.x)*  pp.y  , fL, iL, jL, kL, nL);\n    FsrEasuSetF(dir, len,    pp.x  *  pp.y  , gL, jL, kL, lL, oL);\n\n    //------------------------------------------------------------------------------------------------------------------------------\n    // Normalize with approximation, and cleanup close to zero.\n    vec2 dir2 = dir * dir;\n    float dirR = dir2.x + dir2.y;\n    bool zro = dirR < (1.0/32768.0);\n    dirR = inversesqrt(dirR);\n    dirR = zro ? 1.0 : dirR;\n    dir.x = zro ? 1.0 : dir.x;\n    dir *= vec2(dirR);\n    // Transform from {0 to 2} to {0 to 1} range, and shape with square.\n    len = len * 0.5;\n    len *= len;\n    // Stretch kernel {1.0 vert|horz, to sqrt(2.0) on diagonal}.\n    float stretch = dot(dir,dir) / (max(abs(dir.x), abs(dir.y)));\n    // Anisotropic length after rotation,\n    //  x := 1.0 lerp to 'stretch' on edges\n    //  y := 1.0 lerp to 2x on edges\n    vec2 len2 = vec2(1. +(stretch-1.0)*len, 1. -.5 * len);\n    // Based on the amount of 'edge',\n    // the window shifts from +/-{sqrt(2.0) to slightly beyond 2.0}.\n    float lob = .5 - .29 * len;\n    // Set distance^2 clipping point to the end of the adjustable window.\n    float clp = 1./lob;\n\n    //------------------------------------------------------------------------------------------------------------------------------\n    // Accumulation mixed with min/max of 4 nearest.\n    //    b c\n    //  e f g h\n    //  i j k l\n    //    n o\n    vec3 min4 = min(min(fC,gC),min(jC,kC));\n    vec3 max4 = max(max(fC,gC),max(jC,kC));\n    // Accumulation.\n    vec3 aC = vec3(0);\n    float aW = 0.;\n    FsrEasuTapF(aC, aW, vec2( 0,-1)-pp, dir, len2, lob, clp, bC);\n    FsrEasuTapF(aC, aW, vec2( 1,-1)-pp, dir, len2, lob, clp, cC);\n    FsrEasuTapF(aC, aW, vec2(-1, 1)-pp, dir, len2, lob, clp, iC);\n    FsrEasuTapF(aC, aW, vec2( 0, 1)-pp, dir, len2, lob, clp, jC);\n    FsrEasuTapF(aC, aW, vec2( 0, 0)-pp, dir, len2, lob, clp, fC);\n    FsrEasuTapF(aC, aW, vec2(-1, 0)-pp, dir, len2, lob, clp, eC);\n    FsrEasuTapF(aC, aW, vec2( 1, 1)-pp, dir, len2, lob, clp, kC);\n    FsrEasuTapF(aC, aW, vec2( 2, 1)-pp, dir, len2, lob, clp, lC);\n    FsrEasuTapF(aC, aW, vec2( 2, 0)-pp, dir, len2, lob, clp, hC);\n    FsrEasuTapF(aC, aW, vec2( 1, 0)-pp, dir, len2, lob, clp, gC);\n    FsrEasuTapF(aC, aW, vec2( 1, 2)-pp, dir, len2, lob, clp, oC);\n    FsrEasuTapF(aC, aW, vec2( 0, 2)-pp, dir, len2, lob, clp, nC);\n    //------------------------------------------------------------------------------------------------------------------------------\n    // Normalize and dering.\n    pix=min(max4,max(min4,aC/aW));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 c;\n    vec4 con0,con1,con2,con3;\n    \n    // \"rendersize\" refers to size of source image before upscaling.\n    vec2 rendersize = iChannelResolution[0].xy;\n    FsrEasuCon(\n        con0, con1, con2, con3, rendersize, rendersize, iResolution.xy\n    );\n    FsrEasuF(c, fragCoord, con0, con1, con2, con3);\n    fragColor = vec4(c.xyz, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}