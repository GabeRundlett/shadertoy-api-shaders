{
    "Shader": {
        "info": {
            "date": "1624050894",
            "description": "My unfinished attempt at #TechnicallyAChallange themed as Stained Glass",
            "flags": 0,
            "hasliked": 0,
            "id": "NljGRD",
            "likes": 8,
            "name": "Transparent Raymarching",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "paz7",
            "viewed": 548
        },
        "renderpass": [
            {
                "code": "#define maxRaymarchIterations 700\n#define minimumDistance .005\n#define minimumTransparentDistance .005\n#define maximumDistance 200.\n\n\nvec3 LightPos(){\n\treturn vec3(sin(iTime)*2.,2,cos(iTime)*2.+8.);\n}\n\nfloat GetDist(vec3 p){\n    //box\n    vec3 bp = p;\n    bp -= vec3(1.2,.5,9.);\t\t// translation\n    bp.xz *= Rot(iTime);\t\t// rotation\n    float box = sdBox(bp, vec3(.75));\n    \n    //sphere\n    vec3 sp = p;\n    sp -= vec3(-1.2,.5,9.);\n    float sphere = sdSphere(sp,0.75);\n    \n    //ground\n    vec3 gp = p;\n    gp -= vec3(0,-1.,0);\n    float ground = sdBox(gp,vec3(20,.1,20));\n    \n    float d = min(box,ground);\n    d = min(d,sphere);\n    \n    return d;\n}\n\nfloat GetTransparentDist(vec3 p){\n    vec3 bp = p;\n    bp -= vec3(0.,.5,7);\t\t// translation\n    bp.xz *= Rot(iTime*0.6431);\t\t// rotation\n    float box = sdBox(bp, vec3(1.1,1.1,0.1));\n    return box;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return  normalize(n);\n}\n\nfloat Lighting(vec3 p){    \n    vec3 l = normalize(LightPos()-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n,l),0.,1.);\n    return dif;\n}\n\nvec3 TransGetNormal(vec3 p){\n    float d = GetTransparentDist(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d - vec3(\n        GetTransparentDist(p-e.xyy),\n        GetTransparentDist(p-e.yxy),\n        GetTransparentDist(p-e.yyx));\n    \n    return  normalize(n);\n}\n\nfloat TransLighting(vec3 p){    \n    vec3 l = normalize(LightPos()-p);\n    vec3 n = TransGetNormal(p);\n    float dif = abs(dot(n,l));\n    return dif;\n}\n\nvec2 ShadowMarch(vec3 ro, vec3 rd){\n\tfloat d = 0.;\n    float mind = maximumDistance;    \n    int i = 0; \n    float ds = 0.;\n    for(;;i++){\n    \tvec3 p = ro+rd*d;\n        ds = GetDist(p);\n        if(ds<mind) mind = ds;\n        if(ds<minimumDistance){\n            break;}\n        if(d>maximumDistance) break;\n        if(i>maxRaymarchIterations) break;  \n            d+=ds;\n    }\n    return vec2(d,mind);\n}\n\nvec2 TransShadowMarch(vec3 ro, vec3 rd){\n\tfloat d = 0.;\n    float mind = maximumDistance;    \n    int i = 0; \n    float ds = 0.;\n    for(;;i++){\n    \tvec3 p = ro+rd*d;\n        ds = GetTransparentDist(p);\n        if(ds<mind) mind = ds;\n        if(ds<minimumDistance){\n            break;}\n        if(d>maximumDistance) break;\n        if(i>maxRaymarchIterations) break;  \n        d+=ds;\n    }\n    return vec2(d,mind);\n}\n\nvec3 SoftShadowsTrans(vec3 p,float k){\n    vec4 transCol = vec4(.9,0,0,.15);\n\n    vec3 dir = normalize(LightPos()-p);\n    vec3 n = GetNormal(p);\n    vec3 col = vec3(1,1,1);\n    vec3 transcol = vec3(1,1,1);\n    \n    vec3 ro = p + n * minimumDistance * 2.;\n    vec3 rd = dir;\n    int i = 0;\n    float d = 0.;\n    for(;;i++){\n       vec3 rp = ro+rd*d;\n       float ds = GetDist(rp);\n       float tds = GetTransparentDist(rp);\n       \n       if(tds < minimumTransparentDistance){//inside transparent\n           tds = minimumTransparentDistance;\n           transcol.rgb -= minimumTransparentDistance*(1.-transCol.rgb)*(transCol.a)*15.;\n       }\n       if(ds < minimumDistance){//inside solid\n           col = vec3(0,0,0);\n           break;\n       }\n       if(i>maxRaymarchIterations) {\n           col = vec3(0,1,0);\n           break;\n       }\n       if(d > maximumDistance) break;\n       \n       d += min(ds,tds);\n    }\n    transcol = clamp(transcol,vec3(0,0,0),vec3(1,1,1));\n    float alpha = (transcol.r+transcol.g+transcol.b)/3.;\n    vec3 final = 1.-col + 1.-transcol;\n    \n    return 1.-final;\n}\n\nvec3 SoftShadows(vec3 p,float k){\n\tvec3 l = normalize(LightPos()-p);\n    vec3 n = GetNormal(p);\n    float dif = 1.;\n    float sh = 1.;\n    float tsh = 1.;\n    vec2 d = ShadowMarch(p+n*minimumDistance*10.,l);\n    vec2 td = TransShadowMarch(p+n*minimumDistance*10.,l);\n    vec4 transCol = vec4(.9,0,0,iMouse.x/iResolution.x);\n\n    if(d.x<length(LightPos()-p)) sh = 0.;\n    \n    sh = min(sh,k*d.y/minimumDistance);\n    tsh = min(tsh,k*td.y/minimumTransparentDistance);   \n    \n    vec3 finalShadow = vec3(sh);\n    \n    return finalShadow;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd){// x = distance y = closest distance z = iterations\n\tfloat d = 0.;\n    float mind = maximumDistance;    \n    vec3 rayC = vec3(0,0,0);\n    vec4 transCol = vec4(.9,0,0,.15);\n    vec4 trans = vec4(0,0,0,1);\n    float transL = 1.;\n    int i = 0;\n    bool inside = false;\n    float alpha = 0.;\n    float ds = 0.;\n    for(;;i++){\n    \tvec3 p = ro+rd*d;\n        ds = GetDist(p);\n        float tds = GetTransparentDist(p);        \n        if(ds<minimumDistance){\n            rayC += Lighting(p);\n            break;}\n        if(d>maximumDistance) break;\n        if(i>maxRaymarchIterations) break;\n        if(tds<minimumTransparentDistance && inside == false){\n            transL = TransLighting(p);\n        }\n        if(tds<minimumTransparentDistance){\n            inside = true;\n            alpha -= transCol.a*tds;\n            tds=minimumTransparentDistance;\n        }else{\n            inside = false;            \n        }\n        if(ds<tds)\n            d+=ds;\n        else\n            d+=tds;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec3 shadows = SoftShadowsTrans(p,1.);\n    \n    trans.rgb = transCol.rgb;\n    alpha = clamp(alpha,0.,1.);\n    //trans.a = alpha;\n    rayC*=shadows;\n    vec3 finalCol = rayC * (1.-alpha) + trans.rgb * alpha;\n    \n    return vec4(finalCol,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0,1,0);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1) + vec3(0,-.15,0));\n    \n    vec4 r = RayMarch(ro,rd);//0-1\n\n    vec3 point = ro+rd*r.w;\n    \n    vec3 col = r.rgb;\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//SDFs\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdPlane(vec3 p,float y){\n    return abs(p.y-y);\n}\n\nfloat sdSphere(vec3 p, float r){\n    return length(p)-r;\n}\n\n//transformations\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}