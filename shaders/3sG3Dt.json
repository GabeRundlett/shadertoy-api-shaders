{
    "Shader": {
        "info": {
            "date": "1571156633",
            "description": "A ray-marching terrain shader created live on-stream at https://twitch.tv/codebasealpha. This is a work-in-progress; the intention is to add more features during the next episode of the stream - see CodebaseAlpha6 for those updates!",
            "flags": 0,
            "hasliked": 0,
            "id": "3sG3Dt",
            "likes": 12,
            "name": "CodebaseAlpha4",
            "published": 3,
            "tags": [
                "terrain"
            ],
            "usePreview": 0,
            "username": "codebasealpha",
            "viewed": 510
        },
        "renderpass": [
            {
                "code": "precision highp float;\n\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\n#define TOLERANCE       0.001\n#define MAX_ITER        100\n#define MIN_DISTANCE    0.1\n#define MAX_DISTANCE    30.0\n\nconst vec3 skyCol1 = vec3(0.35, 0.45, 0.6);\nconst vec3 skyCol2 = vec3(0.4, 0.7, 1.0);\nconst vec3 skyCol3 = pow(skyCol1, vec3(0.25));\nconst vec3 sunCol1 =  vec3(1.0,0.5,0.4);\nconst vec3 sunCol2 =  vec3(1.0,0.8,0.7);\n\nvoid rot(inout vec2 p, in float a)\n{\n  float c = cos(a);\n  float s = sin(a);\n  \n  p = vec2(p.x*c + p.y*s, -p.x*s + p.y*c);\n}\n\nfloat rand(in vec2 co)\n{\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 hash(in vec2 p)\n{\n  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n  return fract(sin(p)*18.5453);\n}\n\nvec4 voronoi(in vec2 x)\n{\n  vec2 n = floor(x);\n  vec2 f = fract(x);\n\n  vec4 m = vec4(8.0);\n  for(int j=-1; j<=1; j++)\n  for(int i=-1; i<=1; i++)\n  {\n    vec2  g = vec2(float(i), float(j));\n    vec2  o = hash(n + g);\n    vec2  r = g - f + o;\n    float d = dot(r, r);\n    if(d<m.x)\n    {\n      m = vec4(d, o.x + o.y, r);\n    }\n  }\n\n  return vec4(sqrt(m.x), m.yzw);\n}\n\nfloat globalHeight(float f, vec2 op)\n{\n    return (f *0.9 + (0.5 + 0.5 * cos(op.y *0.1)) * 0.4 - 0.3) * (0.7 + 0.3 *sin((0.5 + 0.25 * (1.0 + sin(op.y))) * op.x - 1.5));\n}\n\nfloat heightFunction(vec2 p)\n{\n    vec2 op = p;\n    p += 0.02;\n    p *= 0.0025;\n    float f = 0.0;\n    float amplitude = 1.0;\n    float period = 1.0;\n        \n    for (int i = 0; i < 7; i++)\n    {\n        f += amplitude * texture(iChannel0, period * p).x;\n        rot(p, 1.0);\n        amplitude *= 0.5;\n        period *= 2.0;\n    }\n    \n    return globalHeight(f, op);\n}\n\nfloat heightFunctionLo(vec2 p)\n{\n    vec2 op = p;\n    p += 0.02;\n    p *= 0.0025;\n    float f = 0.0;\n    float amplitude = 1.0;\n    float period = 1.0;\n        \n    for (int i = 0; i < 6; i++)\n    {\n        f += amplitude * texture(iChannel0, period * p).x;\n        rot(p, 1.0);\n        amplitude *= 0.5;\n        period *= 2.0;\n    }\n    \n    return globalHeight(f, op);\n}\n\nfloat heightFunctionHi(vec2 p)\n{\n    vec2 op = p;\n    p += 0.02;\n    p *= 0.0025;\n    float f = 0.0;\n    float amplitude = 1.0;\n    float period = 1.0;\n        \n    for (int i = 0; i < 11; i++)\n    {\n        f += amplitude * texture(iChannel0, period * p).x;\n        rot(p, 1.0);\n        amplitude *= 0.5;\n        period *= 2.0;\n    }\n    \n    return globalHeight(f, op);\n}\n\nvec3 getNormal(in vec2 p, in float d)\n{\n  vec2 eps = vec2(0.004*d, 0);\n  float dx = heightFunction(p - eps) - heightFunction(p + eps);\n  float dy = 2.0*eps.x;\n  float dz = heightFunction(p - eps.yx) - heightFunction(p + eps.yx);\n  return normalize(vec3(dx, dy, dz));\n}\n\nvec3 getNormalLo(in vec2 p, in float d)\n{\n  vec2 eps = vec2(0.004*d, 0);\n  float dx = heightFunctionLo(p - eps) - heightFunctionLo(p + eps);\n  float dy = 2.0*eps.x;\n  float dz = heightFunctionLo(p - eps.yx) - heightFunctionLo(p + eps.yx);\n  return normalize(vec3(dx, dy, dz));\n}\n\nvec3 getNormalHi(in vec2 p, in float d)\n{\n  vec2 eps = vec2(0.004*d, 0);\n  float dx = heightFunctionHi(p - eps) - heightFunctionHi(p + eps);\n  float dy = 2.0*eps.x;\n  float dz = heightFunctionHi(p - eps.yx) - heightFunctionHi(p + eps.yx);\n  return normalize(vec3(dx, dy, dz));\n}\n\nfloat march(in vec3 ro, in vec3 rd, out int max_iter)\n{\n  float dt = 0.1;\n  float d = MIN_DISTANCE;\n\n  for (int i = 0; i < MAX_ITER; ++i)\n  {\n    vec3 p = ro + d*rd;\n    float h = heightFunction(p.xz);\n    \n    if (d > MAX_DISTANCE) \n    {\n      max_iter = i;\n      return MAX_DISTANCE;\n    }\n\n    float hd = p.y - h;\n\n    if (hd < TOLERANCE)\n    {\n      return d;\n    }\n\n    dt = max(hd, TOLERANCE) + 0.001*d;\n    d += dt;\n  }\n  \n  max_iter = MAX_ITER;\n  return MAX_DISTANCE;\n}\n\nvec3 sunDirection()\n{\n  const vec3 sunDirection = normalize(vec3(-1.0, 0.2, -1.0));\n  vec3 sunDir = sunDirection;\n  rot(sunDir.xz, 2.0);\n  return sunDir;\n}\n\nvec3 skyColor(vec3 rd) {\n  vec3 sunDir = sunDirection();\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  vec3 final = vec3(0.0);\n  float angle = atan(rd.y, length(rd.xz))*2.0/PI;\n\n  final += mix(mix(skyCol1, skyCol2, max(0.0, angle)), skyCol3, clamp(-angle*2.0, 0.0, 1.0));\n  final += 0.5*sunCol1*pow(sunDot, 30.0);\n  final += 1.0*sunCol2*pow(sunDot, 600.0);\n    \n  return final;\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float ll, in float mint)\n{\n  float t = mint;\n  \n  for (int i=0; i<24; ++i)\n  {\n    vec3 p = ro + t*rd;\n    float h = heightFunction(p.xz);\n    float d = (p.y - h);\n    if (d < TOLERANCE) return 0.0;\n    if (t > ll) return 1.0;\n    t += max(0.1, 0.25*h);\n  }\n  \n  return 1.0;\n}\n\nvec3 getColor(vec3 ro, vec3 rd)\n{\n    int max_iter;\n    float d = march(ro, rd, max_iter);\n    vec3 sandColor =  1.3 * vec3(0.68, 0.4, 0.3);\n    vec3 surfaceColor = vec3(0.0);\n    vec3 skyCol = skyColor(rd);\n    \n    if (d < MAX_DISTANCE)\n    {\n        vec3 p = ro + d * rd;\n        \n        // diffuse lighting\n        vec3 sunDir = sunDirection();\n        float seaHeight = 0.0;\n        float dsea = (seaHeight - ro.y)/rd.y; \n        //vec3 amb = ambient(sunf, sunDir, rd); \n        if (d > dsea && dsea > 0.0)\n        {\n            vec3 normal = vec3(0.0, 1.0, 0.0);\n            vec3 psea = ro + dsea * rd;\n            \n            // specular lighting\n            vec3 refRay = reflect(rd,normal);\n            vec3 refSkyColor = skyColor(refRay);\n            float shad = shadow(psea, sunDir, 4.0, 0.5);\n            \n            return refSkyColor * shad * 0.125 + vec3(0.1, 0.2, 0.4);\n        }\n        else\n        {\n            // Mountain strata\n            float bandings = mix(50.0, 100.0, 0.5 + 0.5*sin(length(p.y)*10.0));\n            float bandingo = sin(length(p.xz) * 3.0);\n            float bandingf = pow(0.5 + 0.5 * sin(p.y*bandings + bandingo), 0.25);\n            float banding = mix(0.6, 1.0, bandingf);\n        \n            float heightLo = heightFunctionLo(p.xz + vec2(0.2));\n            float heightHi = heightFunctionHi(p.xz);\n            float heightRatio = heightHi / heightLo;\n            \n            vec3 normalLo = getNormalLo(p.xz, d);\n            vec3 normal = getNormal(p.xz, d);\n            vec3 normalHi = getNormalHi(p.xz, d);\n            surfaceColor = sandColor * banding;\n            float refFactor = 0.0;\n                        \n            float flatness = max(dot(normal, vec3(0.0, 1.0, 0.0)), 0.0);\n            float flatnessFactor = pow(flatness, 7.0);\n            \n            // Fog\n            float fogHeight = 0.2 + 0.2 * flatnessFactor;\n            float dfog = (fogHeight - ro.y)/rd.y;\n            float fogDepth = d > dfog && dfog > 0.0 ? d - dfog : 0.0;\n            float fogFactor = exp(-fogDepth);\n            \n            vec4 treePattern = voronoi(p.xz * 50.0);\n            vec4 patchPattern = voronoi(p.xz * 10.0);\n        \n            // Snow\n            if (p.y > 0.7 + 0.1 * sin(p.x + p.z) - 0.3 * flatnessFactor)\n            {\n                surfaceColor = vec3(1.0);\n                refFactor = 0.5;\n                normal = normalLo;\n            }\n            else if (p.y < 0.3 + 0.1 * flatnessFactor)\n            {\n                // Trees\n                surfaceColor = mix(vec3(0.2, 0.5, 0.0), vec3(0.5, 0.5, 0.0), patchPattern.y) * 1.3;\n                surfaceColor *= 1.0 - treePattern.x * 0.75;\n                vec3 normalOffset = vec3(treePattern.z, 0.0, treePattern.w);\n                normal = normalize(normalLo - normalOffset);\n            }\n            else\n            {\n                normal = normalHi;\n            }\n        \n            // specular lighting\n            vec3 refRay = reflect(rd,normal);\n            vec3 refSkyColor = skyColor(refRay);\n        \n            // shadows\n            float shad = shadow(p, sunDir, 4.0, 0.25); // Look into this\n            float dl = max(0.0, dot(normal, sunDir));\n            float grad = mix(0.2, 1.0, shad * dl);   \n            vec3 col = vec3(grad * surfaceColor +  refFactor * refSkyColor) * pow(heightRatio, 3.0);\n            \n            col = mix(skyCol, col, fogFactor);\n            \n            col = mix(col, skyCol, d/MAX_DISTANCE);\n        \n            return col;\n        }\n    }\n    else\n    {\n        return skyCol;\n    }\n}\n\nvec3 eyePos(float t)\n{\n    return vec3(sin(t * 0.1), 1.4-0.0, -2.0 + t * 1.0);\n}\n\nvec3 getSample(in vec2 p, in float time)\n{\n  float off = 1.0*time;\n  vec3 ro  = eyePos(time);\n  vec3 la  = eyePos(time + 0.1) + vec3(0.0, -0.02,  0.0);\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n  vec3 col = getColor(ro, rd);\n \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n  vec2 p = fragCoord/iResolution.xy - vec2(0.5);\n  p.x *= iResolution.x/iResolution.y;\n    \n  vec3 col = getSample(p, iTime);\n  fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}