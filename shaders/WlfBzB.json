{
    "Shader": {
        "info": {
            "date": "1597153871",
            "description": "A weaved reimagining of Fabrice's Gerdes Tchokwe sand drawing example, rendered in a faux 3D isometric hand drawn style.",
            "flags": 0,
            "hasliked": 0,
            "id": "WlfBzB",
            "likes": 30,
            "name": "Gerdes Tchokwe Lusona Pattern",
            "published": 3,
            "tags": [
                "truchet",
                "draw",
                "pattern",
                "tile",
                "sand",
                "faux",
                "gerdes",
                "lusona",
                "tchokwe"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 635
        },
        "renderpass": [
            {
                "code": "/*\n\n    Gerdes Tchokwe Sand Pattern\n    ---------------------------\n\n\tThis is a very basic African influenced Lusona pattern rendered in a \n\tpseudo 3D isometric fashion in the style of oldschool scrollers.\n\tFabrice Neyret often posts interesting snippets of code with visually\n\tsatisfying results. In fact, some are a little too interesting, because \n    one minute I'll be working on something I'm supposed to be doing, then\n\tthe next minute I'm coding up a basic Angolan Tchokwe Lusona pattern. :D\n\n\tThis particular pattern represents a very small subsection of a larger \n    body of work by mathematician and author Paulus Gerdes. In case it needs \n    to be said, African inspired mathematics as it pertains to Sona sand \n    drawings is not my area of expertise. :)\n\n    Algorithmically, the base pattern here is pretty simple to make: Create \n    a square or diamond grid, then randomly render crosses or opposite sided \n    arcs on each shared edge or vertex. From my perspective, the basic design \n    is just a standard two tiled Truchet pattern with some edge constraints. \n    In particular, you force any arc tile to have either a horizontal or \n    vertical orientation on an alternate checkered basis. Use the SHOW_GRID\n    define to show the individual tiles that make up the pattern.\n\n    Since Fabrice has already covered the algorithmic side of things, I \n\tdecided to focus on the rendering. I've mentioned before that I sometimes \n    enjoy producing pseudo 3D effects more than real ones, since faux 3D \n\teffects often requires finesse and inventiveness. This is just simple \n\tlayering effects that most Photoshop artists take for granted -- Drop \n    shadows, bevels, highlights, etc. For the cross tiles (a line on top of \n    another line), I went to the trouble to render Bezier curves to put a \n    little kink at the cross-over points to enhance the illusion. It's a \n    subtle difference that added a chunk of code, but I think it makes all \n    the difference.\n\n    As mentioned, this is the most basic of patterns. There are a wide range \n    of others out there. Fabrice has created a few extentions that are worth \n    looking at. In addition, a proper 3D version of this would be relatively \n    simple, as too would a Wang tile variation. I'm not positive, but I'm \n    pretty sure it'd be possible to create a multiscale version as well. With \n    restrictions on the line lengths, animation flow might be possible, but \n    I'll save variations for another time. :)\n\n\n    Links:\n\n    // Based on the imagery from the following.\n    P.Gerdes & Tchokwe sand drawing - FabriceNeyret2\n    https://www.shadertoy.com/view/wtsfWM\n\n    // A nice variation.\n    P.Gerdes & Tchokwe sand drawing5 - FabriceNeyret2\n    https://www.shadertoy.com/view/3llfRS\n\n\n\tInspiration from Angolan traditional designs - Paulus Gerdes\n\thttps://plus.maths.org/content/new-designs-africa\n\n    Lusona - Wikipedia\n    https://en.wikipedia.org/wiki/Lusona\n\n*/\n\n// Display the individual cell tiles. Note that in this particular case,\n// the entire coordinate system has been rotated by 45 degrees to look\n// like a diamond grid, but this still a square grid.\n//#define SHOW_GRID\n\n// Makes for a neater pattern, but looks less convincing.\n//#define STRAIGHT_LINES\n\n// This takes out the edge constrainst, which results in a standard\n// two-tiled random Truchet pattern.\n//#define RANDOM_TRUCHET\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(57.609, 27.483)))*43758.5453); }\n\n\n\n// IQ's signed distance to a quadratic Bezier. Like all of IQ's code, it's\n// quick and reliable. :)\n//\n// Quadratic Bezier - 2D Distance - IQ\n// https://www.shadertoy.com/view/MlKcDD\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){\n  \n    // p(t)    = (1 - t)^2*p0 + 2(1 - t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0 - 2*p1 + p2) + 2*(p1 - p0)\n    // p'(0)   = 2*(p1 - p0)\n    // p'(1)   = 2*(p2 - p1)\n    // p'(1/2) = 2*(p2 - p0)\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.*B + C;\n    vec2 c = a * 2.;\n    vec2 d = A - pos;\n\n    // If I were to make one change to IQ's function, it'd be to cap off the value \n    // below, since I've noticed that the function will fail with straight lines.\n    float kk = 1./max(dot(b, b), 1e-6); // 1./dot(b,b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.*dot(a, a) + dot(d, b))/3.;\n    float kz = kk * dot(d, a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.*kx*kx - 3.*ky) + kz;\n    float h = q*q + 4.*p3;\n\n    if(h >= 0.) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q)/2.;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1./3.));\n        float t = uv.x + uv.y - kx;\n        t = clamp(t, 0., 1.);\n\n        // 1 root.\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.))/3.;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m)*z - kx;\n        t = clamp(t, 0., 1.);\n\n        // 3 roots.\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos, qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos, qos);\n        res = min(res, dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos, qos);\n        res = min(res, dis);\n\n        res = sqrt(res);\n    }\n    \n    return res;\n}\n\n\n// This is a standard distance field setup for one, two or more\n// Truchet tiles with some minor additions. The tiles used are\n// overlapping crossed lines and the common double arc tile.\n//\n// There are two distance field value holders for line one or\n// line two in order to render one over the other, and two for\n// each arc, even though one would suffice, since there's no \n// overlap. The only other difference is that we're constructing\n// Bezier lines for the wavy line kinks instead of standard \n// straight ones.\n//\n// There is also a place holder for the central dots that you can\n// see and a final position to identify whether we've returned\n// a cross tile or a double arced one.\n//\nvec4 distField(vec2 p){\n\n    \n    // Offset field position for the central dots. See below.\n    vec2 q = p - .5;\n    \n   \n    // Standard square grid ID and local position.\n    vec2 ip = floor(p) + .5;\n    p -= ip;\n    \n    // Vertice and edge postions... Probably overkill for such a simple example,\n    // but it's a good habit to get into when dealing with more complex setups.\n    const vec2[4] v = vec2[4](vec2(-.5, .5), vec2(.5),  vec2(.5, -.5),  vec2(-.5));\n    const vec2[4] e = vec2[4](vec2(0, .5), vec2(.5, 0),  vec2(0, -.5),  vec2(-.5, 0));\n    \n    \n    \n    // Distance field place holder.\n    vec4 d = vec4(1e5);\n  \n    // Edge width.\n    float ew = .13;\n    \n   \n    // Using the cell ID for some unique random numbers.\n    float rnd = hash21(ip);\n    float rnd2 = hash21(ip + .37);\n    #ifdef RANDOM_TRUCHET\n    float rnd3 = hash21(ip + .73);\n    #endif\n    \n    // Checkered arrangement: The black and white chessboard arrangement comes up\n    // in so many different situations that it's worth committing to memory. In this\n    // case we are aligning all double arc tiles either horizontally or vertically,\n    // depending upon which checker we're on.\n    float check = mod(ip.x + ip.y, 2.);\n    \n    \n    // Render overlapping lined crosses on half the tiles. You could change the\n    // percentage, if you wanted.\n    if(rnd<.5){\n        \n        // X and Y nudge factors to produce the Bezier kinks.\n        #ifdef STRAIGHT_LINES\n        // No kind for the straight lines.\n        const vec2 ndgX = vec2(0);\n        vec2 ndgY = vec2(0);\n        #else\n        // Kink the horizontal lines up and the vertical lines\n        // to the left. If the tiles get rotated, they will switch\n        // to down and right, which makes sense.\n        const vec2 ndgX = vec2(-.075, 0);\n        vec2 ndgY = vec2(0, .075);\n        #endif\n        \n        // Randomly rotate some of the tiles: This has the effect of putting\n        // the top line on the bottom. The nudge factor has to be reversed\n        // to keep the line kinks pointing in the right direction.\n        if(rnd2<.5) {\n            p = rot2(3.14159/2.)*p;\n            ndgY *= -1.;\n        }  \n        \n         \n        // Rendering the Bezier lines, which aren't much different to normal lines, except there's\n        // an additional anchor point to give it a curved appearance. IQ wrote the Bezier algorithm\n        // itself, which wouldn't have been easy.\n        //\n        // Bottome line.... All of these join together at their end points.\n        d.x = min(d.x, sdBezier(p, e[2]*1., e[2] + vec2(0, .1), e[2] + vec2(0, .25) + ndgX/3.) - ew);\n        d.x = min(d.x, sdBezier(p, e[0] - vec2(0, .25) + ndgX/3., e[0] - vec2(0, .1), e[0]*1.) - ew);\n        d.x = min(d.x, sdBezier(p, e[0] - vec2(0, .25) + ndgX/3., ndgY, e[2] + vec2(0, .25) + ndgX/3.) - ew);\n        \n        // Top line.\n        d.y = min(d.y, sdBezier(p, e[3]*1., e[3] + vec2(.1, 0), e[3] + vec2(.25, 0) + ndgY/3.) - ew);\n        d.y = min(d.y, sdBezier(p, e[1] - vec2(.25, 0) + ndgY/3., e[1] - vec2(.1, 0), e[1]*1.) - ew);\n        d.y = min(d.y, sdBezier(p, e[1] - vec2(.25, 0) + ndgY/3., ndgY, e[3] + vec2(.25, 0) + ndgY/3.) - ew);\n        \n        // Tile ID: Zero for a cross.\n        d.w = 0.;\n    }\n    else {\n        \n        // The line here is the only difference between Paulus Gerdes's Tchokew inspired sand pattern\n        // arrangement and a regular double tiled Truchet pattern... If you look at the comments on\n        // Fabrice Neyret's original Shadertoy pattern you'll see that I'm kind of convinced of that,\n        // but I'm not positive... Either way, it's a pretty pattern, so whatever. :D\n        //\n        // As you can see, I've provided an option to randomly rotate tiles as well, which will \n        // produce the common double tiled pattern that you've probably seen all over the place.\n        //\n        #ifdef RANDOM_TRUCHET\n        if(rnd3<.5) p = rot2(3.14159/2.)*p; // Random rotation.\n        #else\n        if(check<.5) p = rot2(3.14159/2.)*p; // Checker pattern constained rotation.\n        #endif \n        \n        // The two quarter arcs: You could put an arc in each of \"d.x\" and \"d.y,\" however,\n        // we're joining both together in the top layer, just in case there's overlap.\n        //d.x = abs(length(p - v[0]) - .5) - ew;\n        //d.y = abs(length(p - v[2]) - .5) - ew;\n        \n        d.y = abs(length(p - v[0]) - .5) - ew;\n        d.y = min(d.y, abs(length(p - v[2]) - .5) - ew);\n        \n        // Tile ID: One for regular double arcs.\n        d.w = 1.; \n        \n    }\n    \n\n    // The distance field for the central black dots.\n    vec2 ip2 = floor(q) + .5;\n    q -= ip2;\n    if(mod(ip2.x + ip2.y, 2.)<.5){\n        d.z = min(d.z, length(q));\n        d.z -= ew*.8;\n\t}\n\n    \n    // Return the tile one and two, the central dots and ID.\n    return d;\n}\n\n\n// The grid cell borders.\nfloat gridField(vec2 p){\n    \n    vec2 ip = floor(p) + .5;\n    p = abs(p - ip);\n\n    return abs(max(p.x, p.y) - .5) - .015;\n   \n}\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p, float res){\n    \n  \n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n    // The pattern is resolution based, so needs to factor in screen resolution.\n    p *= res/16.;\n\n    // Slight randomization of the diagonal lines, but the trick is to do it with\n    // tiny squares instead of pixels.\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd; \n\n    return hatch;\n    \n}\n\n// Translating the camera about the XY plane.\nvec2 getCamTrans(float t){ return vec2(sin(t/8.)/16., t/1.); }\n\n// Rotating the camera about the XY plane.\nmat2 getCamRot(float t){\n    \n    //return rot2(0.);\n    return rot2(cos(t/4.)/16.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    \n    // Scaling, rotation and translation.\n    float gSc = 7.5;\n\t// Rotating and moving the canvas. A 2D \"to\" and \"from\" setup would be better, but this\n    // will do for the purpose of the demonstration.\n    vec2 cam = getCamTrans(iTime); // Translation.\n    mat2 camRot = getCamRot(iTime); // Rotation.\n    // Extra 45 degred rotation to give a diamond grid appearance.\n    vec2 p = rot2(3.14159/4.)*(uv*gSc)*camRot + rot2(3.14159/4.)*cam;    \n    \n    \n    // Transformed coordinate copy.\n    vec2 oP = p;\n\n     \n    // Four samples for various things. In this case, it's shadows, highlights,\n    // a pattern field, and the base distance field.\n    vec4 dSh = distField(p - vec2(-2, -1)*.07);\n    vec4 dHi = distField(p + vec2(-2, -1)*.04);\n    vec4 dp = distField(p*6.);\n    vec4 d = distField(p);\n    \n    \n    \n    float sf = 1./iRes*gSc;\n    \n    vec3 col = vec3(1, .9, .95);//vec3(.8, .6, .4);//vec3(1, .9, .95);//\n\n    vec3 lCol = vec3(1, .05, .1);//vec3(1, .05, .1);//vec3(1, .8, .6)/8.;//\n    \n    \n    \n    float pat = smoothstep(0., sf*6., min(dp.x, dp.y))*.5 + .5;\n\n    \n    #ifdef SHOW_GRID\n    // Display the individual cell tiles.\n    float grid = gridField(p);\n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, max(grid, -(d.z - .25)))));\n    col = mix(col, col*1.5, (1. - smoothstep(0., sf*2., grid - .01)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, grid)));\n    #endif\n    \n    vec2 iq = floor(p) + .5;\n    vec2 q = p - iq;\n\n    vec2 sh = max(.5 - d.xy/.15, 0.);\n    vec2 shHi = max(.5 - dHi.xy/.15, 0.);\n    \n    \n    // Thickening the base distance (the extruded walls).\n    d -= .03;\n  \n    // If it's a cross (overlapping line) tile, darken the shadow on the\n    // bottom and add high a highlight to the top line at the crossover point.\n    // It's a subtle effect, but it helps create the illusion.\n    if(d.w < .001){\n        sh.y *= max(1.5 - dot(q, q)*1.5, 1.);\n        shHi.y *= max(1.5 - dot(q, q)*1.5, 1.);\n        \n        sh.x *= min(.5 + dot(q, q)*4., 1.5);\n        shHi.x *= min(.5 + dot(q, q)*4., 1.5);\n    }\n      \n    \n    // Subtle effect to give the ground some shadowy perturbation.\n    col = mix(col, vec3(.3, .1, .2), (1. - smoothstep(0., sf*15., min(dSh.x, dSh.y) - .03))*.25);\n    \n    // Applying the bottom layer of the cell tile. In order is a shadow, fake AO, dark\n    // edge, extruded base layer, top dark edge, and upper hilighted layer. There's a few\n    // layers here, but it's still extremely cheap compared to raymarching.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., min(dSh.x, dSh.y) - .03*iRes/450.))*.55);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., min(d.x, d.y) - .03))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.x - .03)));\n    col = mix(col, lCol*sh.x, (1. - smoothstep(0., sf, d.x)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, dHi.x - .015))*.95);\n    col = mix(col, lCol*shHi.x*5.*pat, (1. - smoothstep(0., sf, dHi.x + .015)));\n\n    // A cheap environmental glaze.\n    col = mix(col, col.xzy*pat*1.5, (1. - smoothstep(0., sf*3., dHi.x + .12)));\n  \n    // Applying the intividual top layers of the cell tile.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., max(max(d.x, d.y - .15), dSh.y)))*.55);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., max(d.x - .03, d.y - .03*iRes/450.)))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.y - .03)));\n    col = mix(col, lCol*sh.y, (1. - smoothstep(0., sf, d.y)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, dHi.y - .015))*.95);\n    col = mix(col, lCol*shHi.y*5.*pat, (1. - smoothstep(0., sf, dHi.y + .015)));\n    \n    // A cheap environmental glaze.\n    col = mix(col, col.xzy*pat*1.5, (1. - smoothstep(0., sf*3., dHi.y + .12)));\n    \n    \n    // Putting some hacky patches on the center of the cell edges to account\n    // for some rendering overlay issues. It's one of the downsides to rendering\n    // layers on a grid. :)\n    q = oP;\n    iq = floor(q) + .5;\n    q -= iq;\n    q = abs(q) - .5;\n    float sq = max(abs(q.x + .5), abs(q.y));\n    sq = min(sq, max(abs(q.x), abs(q.y + .5))) - .25;\n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, max(sq, min(dHi.x, dHi.x)) - .015)));\n    col = mix(col, lCol*shHi.x*5.*pat, (1. - smoothstep(0., sf, max(sq, min(dHi.x, dHi.x)) + .015)));\n   \n \n    // The dark central circles.\n    col = mix(col, col*1.4, (1. - smoothstep(0., sf*8., dHi.z - .03)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.z)));\n    \n         \n    // Post processing.\n    //col = mix(col, col.xzy, dot(col, vec3(.299, .587, .114))/8.);\n    col *= vec3(.8, .75, .6);\n \n\n    \n    // Cheap hatch overlay to give it a very cheap hand drawn look.\n    float hatch = doHatch(rot2(-3.14159/4.)*oP/gSc, iResolution.y);\n    col *= hatch*.4 + .75;\n     \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}