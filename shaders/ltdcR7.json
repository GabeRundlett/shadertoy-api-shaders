{
    "Shader": {
        "info": {
            "date": "1540309820",
            "description": "drag mouse to define a ray for quadtree traversal\nfail:\n boolean cresscent shape is suboptimal for quadtree disrtance as defined here.\n- too many too small squares exist\n- needs a BSP-tree to fix too small max(a,-b)_gradients of quadtree traversal.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltdcR7",
            "likes": 15,
            "name": "quadtree traversal boolean fails",
            "published": 3,
            "tags": [
                "quadtree",
                "traversal",
                "crescent",
                "traverse"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 974
        },
        "renderpass": [
            {
                "code": "//shapes are not root solved, but instead contained in a quadtree\n//, whos box diameter approaches 0,\n//, good for taxicap distance\n//fun oin combination with https://www.shadertoy.com/view/MtcBDM\n//but the max(a,-b) boolean has cases\n//,where you need a BinarySspacePartition-tree and leafPortals\n//to constrain the underlying crescent gradients (of a [syllogism] partition)\n//or you will too often undersestimate distances.\n//https://www.shadertoy.com/results?query=syllogism\n//approaches solutions for this\n//(a BSP-tzree in a fragment shader (buffer) may not be the smartest idea)\n\n//self: https://www.shadertoy.com/view/Xs2czK\n//tile traverser QUADtree(lod)\n\n//keep traversing trough [v]-space.\n#define penetrate\n\n#define zoom 0.5\n\n//detail iterations are wrapped around step iterations:\n#define detail 6.\n#define steps 256\n\nvec2 ball;\n\n#define dd(a)dot(a,a)\n#define sat(a)clamp(a,0.,1.)\n\nfloat line(vec2 p,vec2 a,vec2 b){p-=a,b-=a;float h=sat(dot(p,b)/dd(b))\n    ;return length(p-b*h);}\n\n//https://www.shadertoy.com/view/Xs2czK ,modified by ollj\n//[s]size\n//bool isinbox(vec2 a,vec2 b,float s){return all(greaterThan(a,b        ))&&all(lessThan(a,b+s));}\n//bool isinbox(vec2 a,vec2 b,float s){return all(greaterThan(a-b,vec2(0)))&&all(lessThan(a-b,vec2(s)));}\n//bool isinbox(vec2 a,vec2 b,float s){return(a>b)&&(a<b+s);}\n//bool isinbox(vec2 a,vec2 b,float s){a-=b;return(a>0.)&&(a<s);}\n//bool isinbox(vec2 a,vec2 b,float s){return all(lessThan(a-b,vec2(0)))||all(greaterThan(a-b,vec2(s)));}//is oddly negated.\n//bool isinbox(vec2 a,vec2 b,float s){a-=b;return(a<0.)||(a>s);}\n\n//bool alt(vec3 a,vec3 b){return all(lessThan(a,b));}\n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n\nfloat mav(v1 a){return max(a.x,a.y);}\n\nbool alt(v0 a,v0 b){return(a<b);}\nbool alt(v1 a,v1 b){return all(lessThan(a,b));}\nbool alt(v1 a,v0 b){return all(lessThan(a,v1(b)));}\nbool alt(v2 a,v2 b){return all(lessThan(a,b));}\nbool alt(v2 a,v0 b){return all(lessThan(a,v2(b)));}\nbool alt(v3 a,v3 b){return all(lessThan(a,b));}\nbool alt(v3 a,v0 b){return all(lessThan(a,v3(b)));}\n\n\n\n//this should be fun on homogeneous projections!\n//actually,the classic homogeneous equilateral triangle is just the signed distance to a plane trough points(1,0,0),(0,1,0)and(0,0,1)?\n\n//return if [a] is framed within bounds of [0,s]\n#define isinbox(a,s)alt(abs(a-s*.5),s*.5)\n#define isinboxO(a,b,s)alt(abs(a-b-s*.5),s*.5)\n//bool isinbox(vec2 a,vec2 s){return all(lessThan(abs(a-s*.5),s*.5));}\n//bool isinbox(vec2 a,float s){return isinbox(a,vec2(s));}\n//return if(a)is framed within bounds of [b,b+s]\n//#define isinbox(a,b,c)isinbox((a)-(b),c)\n//bool isinbox(vec2 a,vec2 b,float s){return isinbox(a-b,vec2(s));}\n//bool isinbox(vec2 a,vec2 b,vec2 s){a-=b;s*=.5;return all(lessThan(abs(a-s),s));}\n\n/*\nvoid EnterTileSmaller(inout float s,inout float count,inout vec2 g,inout vec2 j,inout vec2 f){\n //if(ii==0)break;ii--;\n //ii--;//the workaround for niot being able to modify the loop counter is to modify a second int.\n //i--;//not too backwards compatible,and not too essential.\n //BUT without this decrement,you end up with the same issues as with the \"limes of thr harmonic series\"\n s*=.5;count++;\n g=(g-j)*2.;\n j=step(vec2(1.),g);\n f+=j*s;}\n\nvoid EnterTileLarger(inout float s,inout float count,inout vec2 g,inout vec2 j,inout vec2 f,in vec2 h,inout vec2 o){\n s*=2.;count--;\n f+=-j*s/2.+h*s;\n o+=.001*h;//looks like a LAME cheat,is needed to address the right tile. like,literally,the one to the upper right of a border crossing.\n g=mod(o/s-h,2.0)+h;\n j=floor(g);}\n */\n /*\nvoid enterTile(inout vec2 u,inout vec2 o,inout vec2 d,inout float s,inout vec2 g,inout vec2 j,inout vec2 f,inout vec2 mask,inout float raycol,inout float minxy){\n vec2 dists=abs((sign(d)*.5+.5)-(g-j))*1./abs(d);\n float m=min(dists.x,dists.y);\n mask=step(dists,vec2(m));\n //dist+=m*s;\n raycol=max(raycol,1.-minxy*line(u,o,o+m*d*s));//draw ray\n o+=m*d*s;//move ray to next grid border\n g+=m*d;\n j+=mask*sign(d);\n f +=mask*sign(d)*s;//moves to the next grid cell\n raycol=max(raycol,1.-abs(length(o-u)*minxy*.5-.1));//draw yellow circle around where the ray currently is\n}*/\n\n/* traverse quadtree\n[u]=fragment position(framed)\n[v]=qadtree deforming cicle center.(ininitely small quads at circle surface)\n[o]rayOrigin\n[d]rayDirection\n[raycol] is a brightness that paints the ray for fragment u.\n[O]   is \"fragColor\" output,color to set fragment [u] to.\n//a final color composition [O=max(O,vec4(raycol,raycol,0,1));] paints [raycol] in yellow on top of [O]\n*/\n\n//s is the size of a box\n\nfloat cboxc(vec2 p,float s){s*=.5;p+=s\n ;return max(-length(abs(p)+s)+.9,length(abs(p-vec2(.3,0))-s)-1.)\n ;}\n\n//this is horribly fractured design,because i fail to invert a circle,oh wait,i just did succeed\n//this is an inverse refracturing ,problem is that p and s are scaled to the whazoo,and this function just unscales them.\n//this is BAD here,instrerad a global gradient buffer may be nicer here\nfloat cboxc3(vec2 p,float s){s*=.5;p+=s*.5\n ;vec2 a=abs(p)+s\n ;return -length(a)+1.  //vec2(.1)offsets a circle s is needed in here for scaling,within offset,and thats pretty bad style\n //;return(length(max(vec2(0),abs(p)-s*.5)))\n ;}\n\n//this is an inverse refracturing ,problem is that p and s are scaled to the whazoo,and this function just unscales them.\n//this is BAD here,instrerad a global gradient buffer may be nicer here\nfloat cboxc2(vec2 p,float s){s*=.5;p+=s*.5\n ;vec2 a=abs(p+vec2(.1))-s\n ;return length(a)-1.  //vec2(.1)offsets a circle s is needed in here for scaling,within offset,and thats pretty bad style\n //;return(length(max(vec2(0),abs(p)-s)))\n ;}\n\nvoid LoopTraverse(inout vec2 u,inout vec2 v,inout vec2 o,inout vec2 d,inout float raycol,inout vec4 O\n){float s=1.\n ;float count=0.,dist=0.\n ;float minxy=min(iResolution.x,iResolution.y)*.1\n ;vec2 mask=vec2(0)\n ;vec2 f=floor(o)\n ;vec2 j=f//a LOCAL f;within [traversal loop]\n ;vec2 g=o //a LOCAL o;within [traversal loop]\n ;for(int i=0;i<steps;i++ //traversal loop\n ){bool len=cboxc(f-v,s)>0. \n //O-=vec4(step(cboxc(f-v,s),.0));//substract [v]object\n //O-=vec4(step(abs(length(v-u)-1.),.01));//substract [v]object\n //O-=vec4(smoothstep(.05,-.05,abs(length(v-u)-1.)));//substract [v]object\n  #ifndef penetrate\n  //;if(count>detail||dist>2.)break;//if(hit [v])or traversed many tiles.\n   ;if(count>detail)break\n  #endif\n  ;if(!isinbox(j+.5,2.)&&count>.5\n  ){vec2 h=mask*sign(d)//;EnterTileLarger(s,count,g,j,f,h,o)\n   ;count--\n   ;f+=-j*s+h*s*2.\n   ;o+=.001*h//looks like a LAME BAD hack,used to address the right tile. literally,the one to the upper right of a border crossing.\n   ;g=fract(o/s*.25-h*.5)*2.+h\n   ;s*=2.\n   ;j=floor(g)\n  ;}else if(!len&&count<=detail//EnterTileSmaller(s,count,g,j,f)\n  ){s*=.5\n   ;count++\n   ;g=(g-j)*2.\n   ;j=step(vec2(1),g)\n   ;f+=j*s\n  ;}else\n   {if(isinbox(u-f,s))O.r+=.3//coloring\n   //;enterTile(u,o,d,s,g,j,f,mask,raycol,minxy)\n   ;vec2 dists=abs((sign(d)*.5+.5)-(g-j))*1./abs(d)\n   ;float m=min(dists.x,dists.y)\n   ;mask=step(dists,vec2(m))\n   ;dist+=m*s//accumulative distance to initial origin\n   ;raycol=max(raycol,.75-minxy*line(u,o,o+m*d*s))//draw ray\n   ;o+=m*d*s//move rayOrigin to next grid border\n   ;g+=m*d\n   ;j+=mask*sign(d)\n   ;f+=mask*sign(d)*s//moves to the next grid cell\n   ;raycol=max(raycol,1.-abs(length(o-u)*minxy*.5-.1))//draw yellow circle around where the ray currently is\n;}}}\n\nvoid mainImage(out vec4 O,vec2 U){O=vec4(0);//time=iGlobalTime;\n vec2 u=(U*2.-iResolution.xy)/iResolution.y*3.*zoom;\n vec4 m=(abs(iMouse)*2.-iResolution.xyxy)/iResolution.y*zoom;\n float time0=0.;\n vec2 v=vec2(sin(time0),cos(time0))*(sin(time0*1.34));//sphere that sets quadtree size around it,with infinitisimal small quadtrees on its surface.\n vec2 f=floor(u),g=fract(u);//this seems necesary,and it limits the antiderivative iteration.\n float s=1.;//stepSize diminishes with tile size\n \n for(float i=0.;i<=detail;i++//detail loop \n){if(cboxc(f,s)>.0)break //this is some black magic about a circle intersecting a box.\n //above escape is a bad(often too laate)bound of an escape time,because it just does not measure every fragment in a box.\n  ;s*=.5\n  ;f+=floor(g*2.)*s\n  ;g =fract(g*2.)\n  ;O.y=i/detail//tint by tile size\n ;}//this detail-loop only visualizes the size of a quadtreebranch\n ;O.z=mav(abs(g-.5))*10.-4.;//paint blue quad-tile borders\n \n O.xyz+=.7*vec3(step(cboxc(f,s),.0));//substract [v]object\n //O-=vec4(step(abs(length(v-u)-1.),.01));//substract [v]object\n //O-=vec4(smoothstep(.05,-.05,abs(length(v-u)-1.)));//substract [v]object\n \n //if(m.y<-.9)m=vec4(sin(time),cos(time),0,0)+.5;\n \n int c;\n vec2 o=(m.zw)*3.,d=normalize(-(m.zw)+(m.xy));//[o]rayPos.origin [d]RayDirection\n float raycol=0.;\n LoopTraverse(u,v,o,d,raycol,O);\n O=max(O,vec4(raycol,raycol,0,1));//add yellow ray color to the screen\n //O+=step(detail,count)*.1;//if(ray hits something)add white color to the screen \n}\n \n ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}