{
    "Shader": {
        "info": {
            "date": "1672201370",
            "description": "Direct font → SDF rendering with hopefully correct handling of even-odd and non-zero fill rules, see useEvenOddRule bool for configuration, otherwise read the beginning code comment. \n\nBased on https://www.shadertoy.com/view/dls3Wr by mkeeter \n",
            "flags": 0,
            "hasliked": 0,
            "id": "dtX3W7",
            "likes": 10,
            "name": "Font with even-odd and non-zero",
            "published": 3,
            "tags": [
                "raycasting",
                "sdf",
                "bezier",
                "font",
                "quadratic",
                "windingrule",
                "evenodd",
                "nonzero",
                "fillrule",
                "intersectioncounting"
            ],
            "usePreview": 0,
            "username": "BeRo",
            "viewed": 420
        },
        "renderpass": [
            {
                "code": "// Using distance-to-quadratic and winding number to generate a closed-form\n// distance field of a font outline, which is specified as lines + quadratic\n// Bézier curves with correct handling of even-odd / non-zero rules by\n// pseudo-scanline-wise raycasting and counting the winding information,\n// where it does not matter how it is deformed or rotated at the end for the \n// display, because the main thing is that the winding number is correct, \n// regardless of the actual visual 2D projection.\n//\n// It's based on https://www.shadertoy.com/view/dls3Wr by mkeeter where I, \n// Benjamin 'BeRo' Rosseaux, have added the correct handling of the even-odd \n// and non-zero rules handling.\n//\n// It is admittedly still unoptimized, since at the moment all lines and \n// quadratic curves are still checked bruteforce-like with a pseudo-\n// scanline-wise raycasting check, instead of only the ones actually needed \n// for the current each fragment shader position including a preliminary \n// start winding value information for pseudo-scanline such-and-such in \n// quadtree cell or start-search-index-lookup-mip-map-texture such-and-such,\n// more or less like at Pathfinder 3, \"Random Access Vector Graphics\", and so on.  \n//\n// At least this should now serve as ground truth for further optimization and \n// for other better and more clever implementations as well. \n//\n// Quadratic solver is based on https://www.shadertoy.com/view/MlKcDD, which\n// includes the following copyright notice:\n//\n//      Copyright © 2018 Inigo Quilez\n//      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nbool useEvenOddRule = false; // true for even-odd rule, false for non-zero rule \n\n// Additional informations:\n//\n// Quadratic curve tangent is normalize(mix(q1, q2, t) - mix(q0, q1, t))\n//\n// +1 is added for each crossing where the Y coordinate is increasing\n// -1 is added for each crossing where the Y coordinate is decreasing        \n\n// Curves are baked by an external tool\n#define QUAD_COUNT 38\nconst vec2 QUADS[QUAD_COUNT * 3] = vec2[QUAD_COUNT * 3](\n    vec2(0.5758487, -4.5724106), vec2(0.5758487, -4.9204984), vec2(0.7176622, -5.221315),\n    vec2(0.7176622, -5.221315), vec2(0.8594757, -5.5221314), vec2(1.1216158, -5.758487),\n    vec2(0.7520412, -2.0842285), vec2(0.8594757, -1.6974645), vec2(1.0034379, -1.3859046),\n    vec2(0.86162436, -3.5904598), vec2(0.5758487, -3.9664803), vec2(0.5758487, -4.5724106),\n    vec2(1.0034379, -1.3859046), vec2(1.1474, -1.0743446), vec2(1.3837559, -0.8036098),\n    vec2(1.1216158, -5.758487), vec2(1.3708637, -5.9819508), vec2(1.7103566, -6.1087236),\n    vec2(1.3794585, -4.9591746), vec2(1.3794585, -4.563816), vec2(1.5642458, -4.3038244),\n    vec2(1.3837559, -0.8036098), vec2(1.6072196, -0.55006444), vec2(1.9058874, -0.3996562),\n    vec2(1.5642458, -4.3038244), vec2(1.7490331, -4.0438333), vec2(2.101418, -3.8762355),\n    vec2(1.6630855, -2.9823806), vec2(1.1474, -3.2144392), vec2(0.86162436, -3.5904598),\n    vec2(1.6673828, -5.599484), vec2(1.3794585, -5.337344), vec2(1.3794585, -4.9591746),\n    vec2(1.6974645, -0.0021486892), vec2(1.2892135, -0.12892136), vec2(0.99269444, -0.30941126),\n    vec2(1.7103566, -6.1087236), vec2(2.0498495, -6.235496), vec2(2.419424, -6.235496),\n    vec2(1.9058874, -0.3996562), vec2(2.2045553, -0.24924795), vec2(2.599914, -0.24924795),\n    vec2(2.101418, -3.8762355), vec2(2.4151268, -3.7258272), vec2(2.718092, -3.616244),\n    vec2(2.2862053, -2.7266867), vec2(1.9252255, -2.862054), vec2(1.6630855, -2.9823806),\n    vec2(2.363558, -5.8616242), vec2(1.9553072, -5.8616242), vec2(1.6673828, -5.599484),\n    vec2(2.419424, -6.235496), vec2(2.840567, -6.235496), vec2(3.173614, -6.106575),\n    vec2(2.5139663, 0.12462398), vec2(2.1057155, 0.12462398), vec2(1.6974645, -0.0021486892),\n    vec2(2.599914, -0.24924795), vec2(2.896433, -0.24924795), vec2(3.117748, -0.32660076),\n    vec2(2.718092, -3.616244), vec2(3.0210571, -3.506661), vec2(3.3046842, -3.382037),\n    vec2(2.9265146, -2.4795873), vec2(2.647185, -2.5913193), vec2(2.2862053, -2.7266867),\n    vec2(3.0167596, -5.7133646), vec2(2.7503223, -5.8616242), vec2(2.363558, -5.8616242),\n    vec2(3.117748, -0.32660076), vec2(3.3390632, -0.40395358), vec2(3.4765792, -0.54576707),\n    vec2(3.173614, -6.106575), vec2(3.506661, -5.9776535), vec2(3.781693, -5.8057585),\n    vec2(3.3046842, -3.382037), vec2(3.5625267, -3.270305), vec2(3.8010314, -3.1284916),\n    vec2(3.4679844, -5.315857), vec2(3.2831972, -5.565105), vec2(3.0167596, -5.7133646),\n    vec2(3.4765792, -0.54576707), vec2(3.6140952, -0.6875806), vec2(3.6807046, -0.8788139),\n    vec2(3.54104, -2.0004296), vec2(3.3347657, -2.316287), vec2(2.9265146, -2.4795873),\n    vec2(3.6807046, -0.8788139), vec2(3.747314, -1.0700473), vec2(3.747314, -1.3192952),\n    vec2(3.747314, -1.3192952), vec2(3.747314, -1.6845723), vec2(3.54104, -2.0004296),\n    vec2(3.775247, -4.7400084), vec2(3.657069, -5.0580144), vec2(3.4679844, -5.315857),\n    vec2(3.8010314, -3.1284916), vec2(4.039536, -2.9866781), vec2(4.2157283, -2.7975934),\n    vec2(3.9879673, -4.073915), vec2(3.893425, -4.4220023), vec2(3.775247, -4.7400084),\n    vec2(3.996562, -0.3996562), vec2(3.3992264, 0.12462398), vec2(2.5139663, 0.12462398),\n    vec2(4.2157283, -2.7975934), vec2(4.4091105, -2.5827246), vec2(4.501504, -2.3270304),\n    vec2(4.501504, -2.3270304), vec2(4.593898, -2.0713365), vec2(4.593898, -1.7318435),\n    vec2(4.593898, -1.7318435), vec2(4.593898, -0.92393637), vec2(3.996562, -0.3996562)\n);\n\n#define LINE_COUNT 8\nconst vec2 LINES[LINE_COUNT * 2] = vec2[LINE_COUNT * 2](\n    vec2(0.40395358, -2.0842285), vec2(0.7520412, -2.0842285),\n    vec2(0.46411687, 0.0042973785), vec2(0.40395358, -2.0842285),\n    vec2(0.80790716, 0.0042973785), vec2(0.46411687, 0.0042973785),\n    vec2(0.99269444, -0.30941126), vec2(0.80790716, 0.0042973785),\n    vec2(3.781693, -5.8057585), vec2(3.9578855, -6.09798),\n    vec2(3.9578855, -6.09798), vec2(4.301676, -6.09798),\n    vec2(4.301676, -6.09798), vec2(4.336055, -4.073915),\n    vec2(4.336055, -4.073915), vec2(3.9879673, -4.073915)\n);\n\nfloat cross2(vec2 lhs, vec2 rhs){\n  return (lhs.x * rhs.y) - (lhs.y * rhs.x);\n}\n\n#define MORE_OPTIMIZED\n\n#ifdef MORE_OPTIMIZED\n// signed distance to a line\nfloat sdLine(in vec2 pos, in vec2 A, in vec2 B) {   \n  vec2 pSubA = pos - A;\n  vec2 lineSegment = B - A;\n  float squaredLineLength = dot(lineSegment, lineSegment);\n  vec2 nearestPoint = mix(A, B, clamp(dot(pSubA, lineSegment) / squaredLineLength, 0.0, 1.0));\n  vec2 nearestVector = nearestPoint - pos;\n  return length(nearestVector) * sign(-cross2(nearestVector, lineSegment)); \n}\n\nfloat sdLine(in vec2 pos, in vec2 A, in vec2 B, inout int winding) {   \n  vec2 pSubA = pos - A;\n  vec2 lineSegment = B - A;\n  float squaredLineLength = dot(lineSegment, lineSegment);\n  vec2 nearestPoint = mix(A, B, clamp(dot(pSubA, lineSegment) / squaredLineLength, 0.0, 1.0));\n  vec2 nearestVector = nearestPoint - pos;\n  \n  // Pseudo-scanline-based winding code part by Benjamin 'BeRo' Rosseaux\n  // The following code calculates the winding number of a point (pos) relative to a\n  // line segment formed by two points A and B. It does so by simulating a horizontal line \n  // at the y-coordinate of the point (pos) and checking whether this line intersects the \n  // line segment. If the intersection occurs within the limits of the line segment, it\n  // increments or decrements the winding number by 1, depending on the orientation of\n  // the line segment. The winding number can be used to determine whether the point is \n  // inside or outside a polygon. If the line intersects the polygon an even number of times,\n  // the winding number is 0, indicating that the point is outside the polygon. If the line \n  // intersects the polygon an odd number of times, the winding number is either 1 (if the \n  // polygon is oriented counter-clockwise) or -1 (if the polygon is oriented clockwise).  \n  if(abs(lineSegment.y) > 1e-8){\n    float t = -(A.y - pos.y) / lineSegment.y;\n    winding += ((t >= 0.0) && (t <= 1.0) && (mix(A.x, B.x, t) <= pos.x)) ?\n                 ((B.y < A.y) ? -1 : 1) :\n                 0;\n  } \n  \n  return length(nearestVector) * sign(-cross2(nearestVector, lineSegment)); \n}\n\n// signed distance to a quadratic bezier\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p  = ky - kx * kx;\n    float q  = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float p3 = p * p * p;\n    float q2 = q * q;\n    float h  = q2 + 4.0 * p3;\n\n    if(h >= 0.0) { // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n\n        // When p≈0 and p<0, h - q has catastrophic cancelation. So, we do\n        // h=√(q² + 4p³)=q·√(1 + 4p³/q²)=q·√(1 + w) instead. Now we approximate\n        // √ by a linear Taylor expansion into h≈q(1 + ½w) so that the q's\n        // cancel each other in h - q. Expanding and simplifying further we\n        // get x=vec2(p³/q, -p³/q - q). And using a second degree Taylor\n        // expansion instead: x=vec2(k, -k - q) with k=(1 - p³/q²)·p³/q\n        if(abs(abs(h/q) - 1.0) < 0.0001) {\n            float k = (1.0 - p3 / q2) * p3 / q;  // quadratic approx\n            x = vec2(k, -k - q);\n        }\n\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0/3.0));\n        float t = clamp(uv.x + uv.y - kx, 0.0, 1.0);\n        vec2  q = d + (c + b * t) * t;\n        res = dot(q, q);\n        sgn = cross2(c + 2.0 * b * t, q);\n    } else { // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q / (p * z * 2.0)) / 3.0;\n        float m = cos(v);\n        float n = sin(v) * 1.732050808;\n        vec3  t = clamp(vec3(m + m, -n - m, n - m) * z - kx, 0.0, 1.0);\n        vec2  qx=d + (c + b * t.x) * t.x;\n        float dx = dot(qx, qx), sx = cross2(c + 2.0 * b * t.x, qx);\n        vec2  qy=d + (c + b * t.y) * t.y;\n        float dy = dot(qy, qy);\n        float sy = cross2(c + (2.0 * b * t.y), qy);\n        if (dx<dy) {\n            res=dx;\n            sgn=sx;\n        } else {\n            res=dy;\n            sgn=sy;\n        }\n    }\n\n    return sqrt(res) * sign(sgn);\n}\n\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C, inout int winding) {\n  vec2 a = B - A;\n  vec2 b = A - 2.0 * B + C;\n  vec2 c = a * 2.0;\n  vec2 d = A - pos;\n\n  float kk = 1.0 / dot(b, b);\n  float kx = kk * dot(a, b);\n  float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n  float kz = kk * dot(d, a);\n\n  float res = 0.0;\n  float sgn = 0.0;\n\n  float p  = ky - kx * kx;\n  float q  = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n  float p3 = p * p * p;\n  float q2 = q * q;\n  float h  = q2 + 4.0 * p3;\n\n  if(h >= 0.0) { // 1 root\n    h = sqrt(h);\n    vec2 x = (vec2(h, -h) - q) / 2.0;\n\n    // When p≈0 and p<0, h - q has catastrophic cancelation. So, we do\n    // h=√(q² + 4p³)=q·√(1 + 4p³/q²)=q·√(1 + w) instead. Now we approximate\n    // √ by a linear Taylor expansion into h≈q(1 + ½w) so that the q's\n    // cancel each other in h - q. Expanding and simplifying further we\n    // get x=vec2(p³/q, -p³/q - q). And using a second degree Taylor\n    // expansion instead: x=vec2(k, -k - q) with k=(1 - p³/q²)·p³/q\n    if(abs(abs(h/q) - 1.0) < 0.0001) {\n      float k = (1.0 - p3 / q2) * p3 / q;  // quadratic approx\n      x = vec2(k, -k - q);\n    }\n\n    vec2 uv = sign(x) * pow(abs(x), vec2(1.0/3.0));\n    float t = clamp(uv.x + uv.y - kx, 0.0, 1.0);\n    vec2  q = d + (c + b * t) * t;\n    res = dot(q, q);\n    sgn = cross2(c + 2.0 * b * t, q);\n  } else { // 3 roots\n    float z = sqrt(-p);\n    float v = acos(q / (p * z * 2.0)) / 3.0;\n    float m = cos(v);\n    float n = sin(v) * 1.732050808;\n    vec3  t = clamp(vec3(m + m, -n - m, n - m) * z - kx, 0.0, 1.0);\n    vec2  qx=d + (c + b * t.x) * t.x;\n    float dx = dot(qx, qx), sx = cross2(c + 2.0 * b * t.x, qx);\n    vec2  qy=d + (c + b * t.y) * t.y;\n    float dy = dot(qy, qy);\n    float sy = cross2(c + (2.0 * b * t.y), qy);\n    if (dx<dy) {\n      res=dx;\n      sgn=sx;\n    } else {\n      res=dy;\n      sgn=sy;\n    }\n  }\n  \n  // Pseudo-scanline-based winding code part by Benjamin 'BeRo' Rosseaux\n  // This following code calculates the winding number of a quadratic bezier curve at \n  // a given point. The winding number is a measure of how many times a curve wraps \n  // around a given point, and it is used in the implementation of the even-odd or \n  // non-zero rule for determining whether a point is inside or outside of a path. \n  // It does so by simulating a horizontal line at the y-coordinate of the point (pos) \n  // and checking whether this horizontal line intersects the quadratic curve. \n  // The code first calculates the coefficients of a quadratic equation in the form \n  // \"at^2 + bt + c = y\", where \"y\" is the y-coordinate of the given point, and \"t\" is a \n  // value that varies between 0 and 1. The coefficients are then used to solve the equation \n  // using the quadratic formula, which gives the values of \"t\" at which the curve intersects\n  // the given y-coordinate. These values of \"t\" are then used to calculate the x-coordinates\n  // of the intersections, and the winding number is incremented or decremented by 1,\n  // depending on the orientation of the quadratic curve by evaluating the quadratic curve \n  // tangents for the x-axis coordinates.\n  // Overall, the code is well-written and easy to understand. It effectively uses the quadratic \n  // formula to find the intersections of the curve with a given y-coordinate, and then checks with\n  // help of quadratic tangents at time \"t\" on which side of the given point these intersections are \n  // to determine the winding number.\n  { \n    float a = (A.y - (2.0 * B.y)) + C.y;\n    float b = (-2.0 * A.y) + (2.0 * B.y);\n    float d = (b * b) - (4.0 * a * (A.y - pos.y));\n    if (d > 0.0) {\n      vec2 t = (vec2(-b) + (vec2(-1.0, 1.0) * sqrt(d))) / (2.0 * a);\n      vec2 h = mix(mix(A.xx, B.xx, t), mix(B.xx, C.xx, t), t);  \n      winding += (((t.x >= 0.0) && (t.x <= 1.0)) && (h.x <= pos.x)) ?\n                   (((mix(B.y, C.y, t.x) - mix(A.y, B.y, t.x)) < 0.0) ? -1 : 1) : \n                   0;\n      winding += (((t.y >= 0.0) && (t.y <= 1.0)) && (h.y <= pos.x)) ? \n                   (((mix(B.y, C.y, t.y) - mix(A.y, B.y, t.y)) < 0.0) ? -1 : 1) : \n                   0;\n    }          \n  } \n  \n  return sqrt(res) * sign(sgn);\n}\n\nfloat getAccordingToFillRuleCorrectSignedDistance(const in vec2 p, const in bool evenOdd){\n  // Ray = Scanline segment = Line segment for counting of the winding intersections on\n  // the current pseudo-scanline of p.y\n  int w = 0;\n  float d = 1e+26;\n  for (int i = 0; i < QUAD_COUNT; i++) {\n    d = min(d, abs(sdBezier(p, QUADS[i * 3], QUADS[(i * 3) + 1], QUADS[(i * 3) + 2], w)));\n  }\n  for (int i = 0; i < LINE_COUNT; i++) {\n    d = min(d, abs(sdLine(p, LINES[i * 2], LINES[(i * 2) + 1], w)));\n  }\n  return abs(d) * ((evenOdd ? ((w & 1) != 0) /* even odd rule */ \n                            : (w != 0) /* non-zero rule */) ? -1.0 : 1.0);\n}\n\n#else\n\n// signed distance to a line\nfloat sdLine(in vec2 pos, in vec2 A, in vec2 B) {   \n  vec2 pSubA = pos - A;\n  vec2 lineSegment = B - A;\n  float squaredLineLength = dot(lineSegment, lineSegment);\n  vec2 nearestPoint = mix(A, B, clamp(dot(pSubA, lineSegment) / squaredLineLength, 0.0, 1.0));\n  vec2 nearestVector = nearestPoint - pos;\n  return length(nearestVector) * sign(-cross2(nearestVector, lineSegment)); \n}\n\n// signed distance to a quadratic bezier\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p  = ky - kx * kx;\n    float q  = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float p3 = p * p * p;\n    float q2 = q * q;\n    float h  = q2 + 4.0 * p3;\n\n    if(h >= 0.0) { // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n\n        // When p≈0 and p<0, h - q has catastrophic cancelation. So, we do\n        // h=√(q² + 4p³)=q·√(1 + 4p³/q²)=q·√(1 + w) instead. Now we approximate\n        // √ by a linear Taylor expansion into h≈q(1 + ½w) so that the q's\n        // cancel each other in h - q. Expanding and simplifying further we\n        // get x=vec2(p³/q, -p³/q - q). And using a second degree Taylor\n        // expansion instead: x=vec2(k, -k - q) with k=(1 - p³/q²)·p³/q\n        if(abs(abs(h/q) - 1.0) < 0.0001) {\n            float k = (1.0 - p3 / q2) * p3 / q;  // quadratic approx\n            x = vec2(k, -k - q);\n        }\n\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0/3.0));\n        float t = clamp(uv.x + uv.y - kx, 0.0, 1.0);\n        vec2  q = d + (c + b * t) * t;\n        res = dot(q, q);\n        sgn = cross2(c + 2.0 * b * t, q);\n    } else { // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q / (p * z * 2.0)) / 3.0;\n        float m = cos(v);\n        float n = sin(v) * 1.732050808;\n        vec3  t = clamp(vec3(m + m, -n - m, n - m) * z - kx, 0.0, 1.0);\n        vec2  qx=d + (c + b * t.x) * t.x;\n        float dx = dot(qx, qx), sx = cross2(c + 2.0 * b * t.x, qx);\n        vec2  qy=d + (c + b * t.y) * t.y;\n        float dy = dot(qy, qy);\n        float sy = cross2(c + (2.0 * b * t.y), qy);\n        if (dx<dy) {\n            res=dx;\n            sgn=sx;\n        } else {\n            res=dy;\n            sgn=sy;\n        }\n    }\n\n    return sqrt(res) * sign(sgn);\n}\n\nint sumWindingForLineCurveAtScanlineSegment(const in vec2 l0,\n                                            const in vec2 l1,\n                                            const in vec2 p0,\n                                            const in vec2 p1){\n  int w = 0;\n  float AX = (l1.x - l0.x);\n  float BX = l0.x;\n  float AY = (l1.y - l0.y);\n  float BY = l0.y;\n  float ax = (p1.x - p0.x);\n  float bx = p0.x;\n  float ay = (p1.y - p0.y);\n  float by = p0.y;\n  if (ax == 0.0) {\n    float t;\n    t = ax; ax = ay; ay = t;\n    t = bx; bx = by; by = t;\n    t = AX; AX = AY; AY = t;\n    t = BX; BX = BY; BY = t;\n  }\n  float r = ay / ax;\n  float a = (AY - r * AX);\n  float b = (BY - r * BX) - (by - r * bx);\n  float t = -b/a;\n  if (t >= 0.0 && t <= 1.0) {\n    float k = t * AX/ax + BX/ax - bx/ax;\n    if (k >= 0.0 && k <= 1.0){\n      w += (AY < 0.0) ? -1 : 1;\n    }\n  } \n  return w;\n}\n\nint sumWindingForQuadraticCurveAtScanlineSegment(const in vec2 q0,\n                                                 const in vec2 q1,\n                                                 const in vec2 q2,\n                                                 const in vec2 p0,\n                                                 const in vec2 p1){\n  int w = 0;\n  float AX = (q0.x - 2.0*q1.x + q2.x);\n  float BX = (-2.0*q0.x + 2.0*q1.x);\n  float CX = q0.x;\n  float AY = (q0.y - 2.0*q1.y + q2.y);\n  float BY = (-2.0*q0.y + 2.0*q1.y);\n  float CY = q0.y;\n  float ax = (p1.x - p0.x);\n  float bx = p0.x;\n  float ay = (p1.y - p0.y);\n  float by = p0.y;\n  if (ax == 0.0) {\n    float t;\n    t = ax; ax = ay; ay = t;\n    t = bx; bx = by; by = t;\n    t = AX; AX = AY; AY = t;\n    t = BX; BX = BY; BY = t;\n    t = CX; CX = CY; CY = t;\n  }\n  float r = ay / ax;\n  float a = (AY - r * AX);\n  float b = (BY - r * BX);\n  float c = (CY - r * CX) - (by - r * bx);\n  float d = b*b - 4.0*a*c;\n  if (d > 0.0) {\n    float sd = sqrt( d );\n    float t1 = (-b - sd) / (2.0*a);\n    float t2 = (-b + sd) / (2.0*a);\n    if (t1 >= 0.0 && t1 <= 1.0) {\n      float k1 = t1*t1 * AX/ax + t1 * BX/ax + CX/ax - bx/ax;\n      if (k1 >= 0.0 && k1 <= 1.0){\n        w += ((mix(q1.y, q2.y, t1) - mix(q0.y, q1.y, t1)) < 0.0) ? -1 : 1;\n      }\n    }\n    if (t2 >= 0.0 && t2 <= 1.0) {\n      float k2 = t2*t2 * AX/ax + t2 * BX/ax + CX/ax - bx/ax;\n      if (k2 >= 0.0 && k2 <= 1.0){\n        w += ((mix(q1.y, q2.y, t2) - mix(q0.y, q1.y, t2)) < 0.0) ? -1 : 1;\n      } \n    }\n  }          \n  return w;\n}\n\nfloat getAccordingToFillRuleCorrectSignedDistance(const in vec2 p, const in bool evenOdd){\n  // Ray = Scanline segment = Line segment for counting of the winding intersections on\n  // the current pseudo-scanline of p.y\n  vec2 p0 = p; // ray origin = p \n  vec2 p1 = p - vec2(65536.0, 0.0); // just shift as ray end vector p x-wise to a position far before the beginning of the pseudo-scanline of p.y   \n  int w = 0;\n  float d = 1e+26;\n  for (int i = 0; i < QUAD_COUNT; i++) {\n    vec2 q0 = QUADS[i * 3], q1 = QUADS[(i * 3) + 1], q2 = QUADS[(i * 3) + 2];\n    d = min(d, abs(sdBezier(p, q0, q1, q2)));\n    w += sumWindingForQuadraticCurveAtScanlineSegment(q0, q1, q2, p0, p1);\n  }\n  for (int i = 0; i < LINE_COUNT; i++) {\n    vec2 l0 = LINES[i * 2], l1 = LINES[(i * 2) + 1];\n    d = min(d, abs(sdLine(p, l0, l1)));\n    w += sumWindingForLineCurveAtScanlineSegment(l0, l1, p0, p1);\n  }\n  return abs(d) * ((evenOdd ? ((w & 1) != 0) /* even odd rule */ \n                            : (w != 0) /* non-zero rule */) ? -1.0 : 1.0);\n}\n\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    p = (p + vec2(0.5, 0.75)) * vec2(4.0, -4.0);\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    m = (m + vec2(0.5, 0.75)) * vec2(4.0, -4.0);\n\n    float d = getAccordingToFillRuleCorrectSignedDistance(p, useEvenOddRule); \n\n    // Apply a color based on signed distance\n    vec3 col = vec3(1.0) - vec3(0.1, 0.4, 0.7) * sign(d);\n    col *= 1.0 - exp(-4.0 * abs(d));\n    col *= 0.8 + 0.2 * cos(60.0 * d);\n    col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    // Draw the mouse stuff\n    if(iMouse.z > 0.001) {\n        float d = 1e10;\n        for (int i=0; i < QUAD_COUNT; i++) {\n            vec2 v0 = QUADS[i * 3];\n            vec2 v1 = QUADS[i * 3 + 1];\n            vec2 v2 = QUADS[i * 3 + 2];\n            d = min(d, abs(sdBezier(m, v0, v1, v2)));\n        }\n        for (int i=0; i < LINE_COUNT; i++) {\n            vec2 v0 = LINES[i * 2];\n            vec2 v1 = LINES[i * 2 + 1];\n            d = min(d, abs(sdLine(m, v0, v1)));\n        }\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - m) - abs(d)) - 0.01));\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(p - m) - 0.05));\n    }\n\n    { // Draw the skeleton of the Bezier curves\n        float d = 1e10;\n        for (int i=0; i < QUAD_COUNT; i++) {\n            vec2 v0 = QUADS[i * 3];\n            vec2 v1 = QUADS[i * 3 + 1];\n            vec2 v2 = QUADS[i * 3 + 2];\n            d = min(d, min(abs(sdLine(p, v0, v1)), abs(sdLine(p, v1, v2))));\n            d = min(d, length(p - v0) - 0.05);\n            d = min(d, length(p - v1) - 0.05);\n            d = min(d, length(p - v2) - 0.05);\n        }\n        for (int i=0; i < LINE_COUNT; i++) {\n            vec2 v0 = LINES[i * 2];\n            vec2 v1 = LINES[i * 2 + 1];\n            d = min(d, abs(sdLine(p, v0, v1)));\n            d = min(d, length(p - v0) - 0.05);\n            d = min(d, length(p - v1) - 0.05);\n        }\n        col = mix(col, vec3(1, 0, 0), 1.0 - smoothstep(0.0, 0.014, d));\n    }\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}