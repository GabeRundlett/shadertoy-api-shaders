{
    "Shader": {
        "info": {
            "date": "1635169950",
            "description": "simple demos of 1d perlin noise.\nupper left:   1d perlin noise curve\nupper right:  simple 2D terrain\nlower left:   hand drawn effect\nlower right:  2D water surface",
            "flags": 0,
            "hasliked": 0,
            "id": "NsySWG",
            "likes": 9,
            "name": "1D perlin waves",
            "published": 3,
            "tags": [
                "terrain",
                "perlinnoise",
                "water",
                "1d",
                "curve",
                "handdrawn"
            ],
            "usePreview": 0,
            "username": "rifke",
            "viewed": 731
        },
        "renderpass": [
            {
                "code": "//---------------------------------------------------------------------------\n//Rendering: four simple demos\n//upper left:   1d perlin noise curve\n//upper right:  simple 2D terrain\n//lower left:   hand drawn effect\n//lower right:  2D water surface\n//---------------------------------------------------------------------------\n#define FADE_SCALE 30.0\n\nvec4 circle(vec2 uv, vec2 center, float radius, vec3 color, bool isSolid) \n{\n\tfloat d = (length(uv - center) - radius) * FADE_SCALE;\n    d = isSolid ? d : abs(d);\n\treturn vec4(color, 1. - clamp(d, 0., 1.));\n}\n\nvec4 rect(vec2 uv, vec2 minV, vec2 maxV, vec3 color, bool isSolid)\n{\n\tfloat d = max(max(uv.x-maxV.x, minV.x-uv.x), max(uv.y-maxV.y, minV.y-uv.y)) * FADE_SCALE;\n    d = isSolid ? d : abs(d);\n\treturn vec4(color, 1. - clamp(d, 0., 1.));\n}\n\nvec4 renderLR(in vec2 uv)\n{\n    float noise = .06 * (fbm(uv.x, 4, .1) + fbm(uv.x + iTime, 4, .1));\n    float d = (uv.y + noise - 1.) * FADE_SCALE;\n\tfloat t = clamp(d, 0., 1.);\n    \n    vec3 skyColor = vec3(0., 0., 0.);\n    vec3 waterColor = vec3(.0, .3, .5) + .3 * uv.y;\n    return vec4(mix(waterColor, skyColor, t), 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n    float noise = .02 * fbm(uv.x + uv.y, 6, 1.);\n    \n    fragColor = renderLR(2.*uv+vec2(-aspect, 1.));  \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//---------------------------------------------------------------------------\n//1D Perlin noise implementation \n//---------------------------------------------------------------------------\n#define HASHSCALE 0.1031\n\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat fade(float t) { return t*t*t*(t*(6.*t-15.)+10.); }\n\nfloat grad(float hash, float p)\n{\n    int i = int(1e4*hash);\n\treturn (i) == 0 ? p : -p;\n}\n\nfloat perlinNoise1D(float p)\n{\n\tfloat pi = floor(p), pf = p - pi, w = fade(pf);\n    return mix(grad(hash(pi), pf), grad(hash(pi + 1.0), pf - 1.0), w) * 2.0;\n}\n\nfloat fbm(float pos, int octaves, float persistence) \n{\n    float total = 0., frequency = 1., amplitude = 1., maxValue = 0.;\n    for(int i = 0; i < 4; ++i) \n    {\n        total += perlinNoise1D(pos * frequency) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.;\n    }\n    return total / maxValue;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}