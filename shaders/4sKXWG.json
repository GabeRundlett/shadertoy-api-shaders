{
    "Shader": {
        "info": {
            "date": "1466408051",
            "description": "Quite happy with speed and look :)",
            "flags": 0,
            "hasliked": 0,
            "id": "4sKXWG",
            "likes": 11,
            "name": "KaliTrace",
            "published": 3,
            "tags": [
                "3d",
                "fractal",
                "kaliset",
                "environment",
                "bumpmap"
            ],
            "usePreview": 0,
            "username": "bergi",
            "viewed": 883
        },
        "renderpass": [
            {
                "code": "/** KaliTrace\n\thttps://www.shadertoy.com/view/4sKXWG\n\n\t(cc) 2016, stefan berke\n\n\tAnother attempt to ray-march the kali-set. \n\tQuite happy this time, not so much artefacts and good framerate. \n\t\n\tIt's quite inspired by Shane's general visual style,\n\tespecially bump-mapping and evironment-mapping.\n\tBoth drawn from the kaliset as well.\n\t\n\n*/\n\n\n// minimum distance to axis-aligned planes in kali-space\n// uses eiffie's mod (/p.w) https://www.shadertoy.com/view/XtlGRj\n// to keep the result close to a true distance function\nvec3 kali_set(in vec3 pos, in vec3 param)\n{\n    vec4 p = vec4(pos, 1.);\n    vec3 d = vec3(100.);\n    for (int i=0; i<9; ++i)\n    {\n        p = abs(p) / dot(p.xyz,p.xyz);\n        d = min(d, p.xyz/p.w);\n        p.xyz -= param;\n    }\n    return d;\n}\n\n\nfloat DE(in vec3 p, in vec3 param)\n{\n    // floor and ceiling\n    float d = min(p.y, -p.y+.2);\n\n    // displaced by kaliset\n\td -= kali_set(p*vec3(1,2,1), param).x;\n    \n    return d;\n}\n\nvec3 DE_norm(in vec3 p, in vec3 param)\n{\n    vec2 e = vec2(0.0001, 0.);\n    return normalize(vec3(\n        DE(p+e.xyy, param) - DE(p-e.xyy, param),\n        DE(p+e.yxy, param) - DE(p-e.yxy, param),\n        DE(p+e.yyx, param) - DE(p-e.yyx, param)));\n}\n\n\nconst float max_t = 1.;\n\n// common sphere tracing\n// note the check against abs(d) to get closer to surface\n// in case of overstepping\nfloat trace(in vec3 ro, in vec3 rd, in vec3 param)\n{\n    float t = 0.001, d = max_t;\n    for (int i=0; i<50; ++i)\n    {\n        vec3 p = ro + rd * t;\n        d = DE(p, param);\n        if (abs(d) <= 0.0001 || t >= max_t)\n            break;\n        t += d * .5; // above kali-distance still needs a lot of fudging\n    }\n    return t;\n}\n\n// \"Enhanced Sphere Tracing\"\n// Benjamin Keinert(1) Henry SchÃ¤fer(1) Johann KorndÃ¶rfer Urs Ganse(2) Marc Stamminger(1)\n// 1 University of Erlangen-Nuremberg, 2 University of Helsinki\n// \n// It was a try... disabled by default (see rayColor() below)\n// Obviously the algorithm does not like \"fudging\" which is needed for my distance field..\n// It renders more stuff close to edges but creates a lot of artifacts elsewhere\nfloat trace_enhanced(in vec3 ro, in vec3 rd, in vec3 param)\n{\n    float omega = 1.2; // overstepping\n    float t = 0.001;\n    float candidate_error = 100000.;\n    float candidate_t = t;\n    float previousRadius = 0.;\n    float stepLength = .0;\n    float signedRadius;\n    float pixelRadius = .012;\n    float fudge = 0.6;\n    for (int i = 0; i < 50; ++i) \n    {\n        signedRadius = DE(rd*t + ro, param);\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. && (radius + previousRadius) < stepLength;\n        if (sorFail) \n        {\n        \tstepLength -= omega * stepLength;\n        \tomega = 1.;\n        } \n        else \n        {\n        \tstepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) \n        {\n        \tcandidate_t = t;\n        \tcandidate_error = error;\n    \t}\n    \tif (!sorFail && error < pixelRadius || t > max_t)\n    \t\tbreak;\n    \tt += stepLength * fudge;\n    }\n    return (t > max_t || candidate_error > pixelRadius)\n        ? max_t : candidate_t;\n}\n\n// common ambient occlusion\nfloat traceAO(in vec3 ro, in vec3 rd, in vec3 param)\n{\n    float a = 0., t = 0.01;\n    for (int i=0; i<5; ++i)\n    {\n        float d = DE(ro+t*rd, param);\n        a += d / t;\n        t += d;\n    }\n    return min(1., a / 5.);\n}\n\n// environment map, also drawn from kaliset\nvec3 skyColor(in vec3 rd)\n{\n    //vec3 par = vec3(0.075, 0.565, .03);\n    vec3 par = vec3(1.2, 1.01, .71);\n    \n    vec3 c = kali_set(rd*2., par);\n    c = vec3(.9*c.x,.7,1.)*pow(vec3(c.x),vec3(.7,.5,.5));\n    \n    return clamp(c, 0., 1.);\n}\n\n// trace and color\nvec3 rayColor(in vec3 ro, in vec3 rd)\n{\n    // magic params for kali-set\n    vec3 par1 = vec3(1.),\t\t\t\t// scene geometry \n         par2 = vec3(.63, .55, .73);\t// normal/bump map\n    \n#if 1\n    float t = trace(ro, rd, par1);\n#else    \n    float t = trace_enhanced(ro, rd, par1);\n#endif    \n    vec3 p = ro + t * rd;\n    float d = DE(p, par1);\n    \n    vec3 col = vec3(0.);\n\n    // did ray hit?\n    if (d < 0.03) \n    // note, we always find a surface in this scene except for rays parallel to the \n\t// two enclosing planes. The 0.03 is quite large, just to remove the blackness\n    // close to edges\n    {\n        // surface normal\n        vec3 n = DE_norm(p, par1);\n        // normal displacement\n        n = normalize(n + min(p.y+0.05,.14)*DE_norm(p+.1*n, par2));\n        n = normalize(n + 0.04*DE_norm(sin(p*30.+n*10.), par2)); // micro-bumps\n        // reflected ray\n        vec3 rrd = reflect(rd,n);\n\t\t// normal towards light\n        vec3 ln = normalize(vec3(0.7,0.2,0) - p);\n\t\t// 1. - occlusion\n        float ao = traceAO(p, n, par1);\n        // surface color\n        vec3 surf = .1*mix(vec3(1,1.4,1), vec3(3,3,3), ao);\n\n        // lighting\n        surf += .25 * ao * max(0., dot(n, ln));\n        float d = max(0., dot(rrd, ln));\n        surf += ao * (.5 * d + .7 * pow(d, 8.));\n\n        // environment map\n        surf += .5 * ao * skyColor(rrd);\n    \n        // distance fog\n    \tcol = surf * (1.-t / max_t);\n    }\n    \n    return col;\n}\n\n// camera path\nvec3 path(in float ti)\n{\n    ti /= 7.;\n    vec3 p = vec3(sin(ti)*.5+.5, \n                  .05+.03*sin(ti*3.16), \n                  -.5*cos(ti));\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 suv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y * 2.;\n        \n    float ti = iTime+23.;\n    \n    vec3 ro = path(ti);\n    vec3 look = path(ti+1.+.5*sin(ti/2.3))+vec3(0,.02+.03*sin(ti/5.3),0);\n    float turn = sin(ti/6.1); \n        \n    // lazily copied from Shane\n    // (except the hacky turn param)\n    float FOV = .7; // FOV - Field of view.\n    vec3 fwd = normalize(look-ro);\n    vec3 rgt = normalize(vec3(fwd.z, turn, -fwd.x));\n    vec3 up = cross(fwd, rgt);\n    \n    vec3 rd = normalize(fwd + FOV*(uv.x*rgt + uv.y*up));\n    \n    \n    \n    //vec3 col = kali_set(vec3(uv, 0.), vec3(1.));\n    vec3 col = rayColor(ro, rd);\n    //col = skyColor(rd);\n    \n    \n    col *= pow(1.-dot(suv-.5,suv-.5)/.5, .6);\n    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}