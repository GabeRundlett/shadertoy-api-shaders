{
    "Shader": {
        "info": {
            "date": "1639116558",
            "description": "Playing around, exploring possible surface effects for a corner of the Subconscious UI.\n\nNo optimization pass has been done, please consider everything WIP.",
            "flags": 0,
            "hasliked": 0,
            "id": "7tcSW4",
            "likes": 2,
            "name": "Subconscious Orb",
            "published": 3,
            "tags": [
                "prototype"
            ],
            "usePreview": 0,
            "username": "cdata",
            "viewed": 318
        },
        "renderpass": [
            {
                "code": "precision highp float;\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n  // Precompute values for skewed triangular grid\n  const vec4 C = vec4(0.211324865405187,\n                      // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,\n                      // 0.5*(sqrt(3.0)-1.0)\n                      -0.577350269189626,\n                      // -1.0 + 2.0 * C.x\n                      0.024390243902439);\n                      // 1.0 / 41.0\n\n  // First corner (x0)\n  vec2 i  = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n\n  // Other two corners (x1, x2)\n  vec2 i1 = vec2(0.0);\n  i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n  vec2 x1 = x0.xy + C.xx - i1;\n  vec2 x2 = x0.xy + C.zz;\n\n  // Do some permutations to avoid\n  // truncation effects in permutation\n  i = mod289(i);\n  vec3 p = permute(\n          permute( i.y + vec3(0.0, i1.y, 1.0))\n              + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(\n                      dot(x0,x0),\n                      dot(x1,x1),\n                      dot(x2,x2)\n                      ), 0.0);\n\n  m = m*m ;\n  m = m*m ;\n\n  // Gradients:\n  //  41 pts uniformly over a line, mapped onto a diamond\n  //  The ring size 17*17 = 289 is close to a multiple\n  //      of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n  // Normalise gradients implicitly by scaling m\n  // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n  m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n  // Compute final noise value at P\n  vec3 g = vec3(0.0);\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n  return 130.0 * dot(m, g);\n}\n\n// Copyright 2021 Chris Joel\n// All works not covered by a license are CC-BY-NC\nfloat PHI = 1.61803398874989484820459;\n\nfloat turbulence(vec2 viewport_xy, float t) {\n  float scale = 3.0;\n  float x = snoise(viewport_xy * scale + t);\n  float y = snoise(viewport_xy.yx * scale - t);\n  float l = length(vec2(x, y));\n\n  float e = 1.0;\n  float s = 1.0 - smoothstep(0.500, e, l)/e;\n\n  float e2 = 2.000;\n  float s2 = 1.0 - smoothstep(0.15, e2, l)/e2;\n\n  return clamp(pow((s + s2) / 2.0, 4.0), 0.0, 1.0);\n}\n\nfloat soft_circle(vec2 viewport_xy, vec2 xy, float radius, float blur) {\n  float blur_half = blur / 2.0;\n  float d = distance(viewport_xy, xy);\n  return 1.0 - smoothstep(radius - blur_half, radius + blur_half, d);\n}\n\nvec4 rgb(float r, float g, float b) {\n  return vec4(r/255., g/255., b/255., 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = iResolution.x > iResolution.y \n        ? vec2(1.0, iResolution.y / iResolution.x) \n        : vec2(iResolution.x / iResolution.y, 1.0);\n\n    vec2 viewport_xy = fragCoord / iResolution.xy * aspect;\n    vec2 midpoint_xy = 0.5 * aspect;\n\n    vec4 purple = rgb(110., 90., 200.);\n    vec4 red = rgb(255., 110., 100.);\n    vec4 orange = rgb(255., 190., 100.);\n    vec4 green = rgb(110., 190., 90.);\n    vec4 blue = rgb(100., 140., 230.);\n\n    float p = turbulence(viewport_xy * 1., iTime/80.0);\n    float pp = clamp(abs(log(p)) / 10.0, 0.0, 1.0);\n\n    float t = turbulence(viewport_xy * 0.4 + pp/5., iTime/20.0);\n    float tt = turbulence(viewport_xy * 0.2 - pp/9., iTime/30.);\n\n    float t0 = smoothstep(0.0, 0.0045, t);\n    float t1 = smoothstep(0.06, 0.1, t);\n    float t2 = smoothstep(0.2, 0.4, t);\n    float t3 = smoothstep(0.3, 0.8, t);\n    float t4 = smoothstep(0.925, .985, t);\n\n    float l0 = (t0 - t1);\n    float l1 = (t1 - t2);\n    float l2 = (t2 - t3);\n    float l3 = (t3 - t4);\n    float l4 = t4;\n\n    float circle = soft_circle(viewport_xy, midpoint_xy, 0.1, 0.001);\n    float rot_time = PHI * iTime / 10.0;\n    vec2 glow_offset = vec2(cos(rot_time) * -0.015, sin(rot_time) * 0.015);\n    float inner_glow = soft_circle(viewport_xy, midpoint_xy - glow_offset, 0.095, 0.1);\n    float outer_glow = clamp(soft_circle(viewport_xy, midpoint_xy, 0.115, 0.15) - circle, 0.0, 1.0);\n\n    vec4 c0 = l0 * blue + l1 * purple + l2 * green + l3 * orange + l4 * red;\n    vec4 c1 = l0 * orange + l1 *green + l2 * blue  + l3 * purple + l4 * red;\n    vec4 cc = mix(c0, c1, tt) * mix(c0, c1, tt) * 0.85 + vec4(0.25);\n\n    cc = mix(cc, vec4(1.0), (1. - inner_glow) * 0.5) * circle + outer_glow * (t * .25 + tt * .05);\n\n    vec4 out_color = vec4(1.0) - (vec4(1.0) - cc);\n    \n    fragColor = out_color;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}