{
    "Shader": {
        "info": {
            "date": "1494347152",
            "description": "Hold down mouse.\nGets intersection from ray (that starts inside a triangle) with the triangle.\nAll tiles have a unique 2.5D address but every fragment only checks for 7 glyphs of a single tile to write its address.\nhexagonal tracking is all the rage now.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "lsBcDt",
            "likes": 4,
            "name": "020m triangular tiles collision",
            "published": 3,
            "tags": [
                "triangle",
                "intersection",
                "tiling",
                "tile",
                "tiles",
                "triangular",
                "mirrorcabinet"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 985
        },
        "renderpass": [
            {
                "code": "//self         = https://www.shadertoy.com/view/lsBcDt\n//better child = https://www.shadertoy.com/view/MdjcDd\n\n//timestamp or speed of time\n#define time iTime*.01\n#define frameZoom (3.+20.*(cos(time+3.7)*.5+.5))\n#define frameMove vec2(iTime*.01)\n\n/*\n3 numbers uniquely address ALL the triangle tiles.\nthe 3rd [.z] number distinguishes top from bottom triangles.\n\na bottom and a top triangle form a \"skewed square grid\", \nwhos [.xy] coordinates can be read as square grid coordinates.\n\n\nleft mouse button for intersection of ray with border.\n\n\nthis tarted as simpler shader that calculate \nthe (far side) intersection of a triangle\nwith ray that starts inside the triangle\nor on its border.\n\"far side\" means,\nif the ray starts on a border and is parallel to a border\nthen the intersection point \nwill (also) be on one of the OTHER two borders.\n\n\nthen i wanted to enumeratw any amount of visible triangular tiles\nwith a unique address. but looking up glyphs is rather slow, \nso i needed to make a pmod \"mirror cabinet\" for that.\n\nthis way every fragment only looks up 7 glyphs within the same tile,\nand not ALL the glyphs on the screen.\nnow that i did it, i know how to make it much simpler...\n*/\n\n\n//float pMod1(inout float p,float s){float c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pMod(float p,float s){return (fract((p/s)+.5)-.5)*s;}\nfloat pModN(float p,float s){return floor((p/s)+.5);}\n\n//return p, rotated by r;\n#define r(p,r) (cos(r)*p+sin(r)*vec2(-p.y,p.x))\n\n\n//a rather complicated take on\n//turning the screenspoace into a skered pmod() mirror cabinet...\nvec2 frame(vec2 p){p/=iResolution.xy;p-=.5; \n p+=frameMove;\n p.x*=iResolution.x/iResolution.y;p*=frameZoom;                  \n float s=1./(acos(-1.)/3.-.05);     \n float ys=1.75;\n p.x*=ys;                  \n p=vec2(p.x-p.y*s,p.y+p.x*s);\n float d=3.01;\n p.x=pMod(p.x,d);p.y=pMod(p.y,d);      \n p=vec2(p.x+p.y*s,p.y-p.x*s);  \n p.x/=ys;  \n p.y=abs(p.y);//mirror on y\n p.y-=1.;//shift on y\n p.y=-p.y;//flip on y\n  /**/\n return p;}\n\n//...that returns unique tile addresses\nvec3 frameN(vec2 p){p/=iResolution.xy;p-=.5; \n p+=frameMove;vec3 r=vec3(0);\n p.x*=iResolution.x/iResolution.y;p*=frameZoom;                  \n float s=1./(acos(-1.)/3.-.05);     \n float ys=1.75;             \n p.x*=ys;   \n p=vec2(p.x-p.y*s,p.y+p.x*s);\n float d=3.01;\n r.xy=vec2(pModN(p.x,d),pModN(p.y,d));\n p.x=pMod(p.x,d);p.y=pMod(p.y,d);    \n p=vec2(p.x+p.y*s,p.y-p.x*s);  \n p.x/=ys;  \n if(p.y>0.)r.z=1.;\n p.y=abs(p.y);//mirror on y\n p.y-=1.;//shift on y\n p.y=-p.y;//flip on y\n  /**/\n return r;}\n//the clear advantage of this \"mirror cabinet\" approach is\n//that it only looks up the glyphs for a single tile\n//to enumerate all visible tiles.\n\n\n//return distance of (p) to ray that starts at (0,0) and has direction (0,-1);\nfloat ils(vec2 p){return mix(abs(p.y),length(p),step(0.,p.x));}\n\n\n\n#define tau (acos(-1.)*2.)\n\n//sqrt(2.)=1.4142135623730950488016887242097=\n//...pow(2.,1./2.)= ; https://en.wikipedia.org/wiki/Square_root_of_2#Properties_of_the_square_root_of_two\n//#define p22 sqrt(2.)\n//eightRotation.y=eightRotation.x=cos(pi4)=sin(pi4)=\n//...pow(2.,1./2.)/2=sqrt(2.)/2.=p22/2.=1./p22 =sqrt(0.5)==0.70710678118654752440084436210485\n#define p222 sqrt(0.5) \n//(pow(2.,1./2.)*.5*.5)).5/p22\n#define p224 (p222*.5)\n//incircleHexagonTotalHeight=\n//pow(3.,1./2.)= 97./56. =1.73205080756887729352744634150587236694280525381038062805580=\n#define p32 sqrt(3.)\n//\"inCircleHexagonTotalHeight\"=\"equilateralTriangle.y\"=\"hexagon.y\"=sixth.y\"=.5=\"trivial\" || \"hexagon.x\"=\"sixth.x\"=\"tricky\"=\n//pow(3.,1./2.)/2.= 97./112. =\"sixth.x\"=\"hexagon.x\"=sin(asin(1.)*2./3.)=sin(acos(-1.)/3.)=.866=\n#define p322 (p32/2.)\n//pow(3.,1./2.)/3.= 97./168. =.57735026919=\"useful for hexagonal scaling?\"\n#define p323 (p32/3.)\n\nfloat fNgon(in vec2 p,float N){p=p*2.-1.;//centring\n float a=atan(p.x,p.y);//a=atan(p.x/p.y);//fast mirrored\n return cos(floor(.5+a*N/tau)*tau/N-a)*length(p);  \n return cos(floor(.5+a*N/tau)*tau/N-a)*dot(p,p); \n return cos(floor(.5+a*N/tau)*tau/N-a)*dot(p,p)*length(p);\n}//https://www.shadertoy.com/view/4ldXDn\n\n//get distance to intersection of plane along ray \n//Pn \tNormal of Plane (unit vector)\n//Pd \tDistance of Plane\n//O \tOrigin of Ray\n//D \tDirection of Ray \nfloat gPRdV(vec3 Pn,float Pd,vec3 O,vec3 D){\n return -((dot(Pn,O)+Pd)/dot(Pn,D));}\n\n//get distance vector along a ray to a plane\n//vec3 gPRdV(vector Pn,float Pd,vector O,vector D){\n//  return D * gPRxZ(Pn,Pd,O,D);}\n\nfloat oneOf3(vec3 n,float Pd,vec3 o,vec3 d){\n return gPRdV(n,Pd,o,d);}\n\n//should be somewhat like if(a==0.)return b; return c;\n#define ife(a,b,c) mix(c,b,step(0.,a)*step(a,0.));\n\n//handles \"looking direction\" and ALL cases where ray starts on line\nfloat apos(vec3 n,float Pd,vec3 o,vec3 d){\n float i=mix(gPRdV(n,Pd,o,d),4.,step(0.,dot(n,d)));//looking direction\n return ife(i,8.,i);}//\"ALL ray starts on plane\"-cases\n //return mix(i,8.,step(0.,i)*step(i,0.));\n //if (i==0.)return 4.;return i;\n\n//return untersection of ray from a triangle with (endless tirangle) prism.\nvec3 planeRay(vec3 p,vec3 o,vec3 d){d=normalize(d);\n const float aco3=acos(-1.)/3.;vec3 n=vec3(0,-1,0);\n float i=apos(  n              ,1.,o,d),//northern   \n j=apos(-vec3(r(n.xy, aco3),n.z),1.,o,d),//southeast\n k=apos(-vec3(r(n.xy,-aco3),n.z),1.,o,d);//southwest\n return o+d*min(min(i,j),k);\n}\n\nbool InTri(vec2 p){\n if(p.y>1.)return false;\n if(abs(p.x)-p.y*p323>1.175)return false;\n return true;\n}\n\n//== font handling ==\n\n#define FONT_SPACE 0.5\n\nconst vec2 vFontSize  = vec2(8.0, 15.0);  // multiples of 4x5 work best\n\n//----- access to the image of ascii code characters ------\n\n#define SPACE tp.x-=FONT_SPACE;\n\n#define S(a) c+=char(a);   tp.x-=FONT_SPACE;\n\n#define _note  S(10);   //\n#define _star  S(28);   // *\n#define _smily S(29);           \n#define _ tp.x-=FONT_SPACE;\n#define _exc   S(33);   // !\n#define _add   S(43);   // + \n#define _comma S(44);   // ,\n#define _sub   S(45);   // -\n#define _dot   S(46);   // .\n#define _slash S(47);   // /\n\n#define _0 S(48);\n#define _1 S(49);\n#define _2 S(50);\n#define _3 S(51);\n#define _4 S(52);\n#define _5 S(53);\n#define _6 S(54);\n#define _7 S(55);\n#define _8 S(56);\n#define _9 S(57);\n#define _ddot S(58);   // :\n#define _sc   S(59);   // ;\n#define _less S(60);   // <\n#define _eq   S(61);   // =\n#define _gr   S(62);   // >\n#define _qm   S(63);   // ?\n#define _at   S(64);   // at sign \n\n#define _A S(65);\n#define _B S(66);\n#define _C S(67);\n#define _D S(68);\n#define _E S(69);\n#define _F S(70);\n#define _G S(71);\n#define _H S(72);\n#define _I S(73);\n#define _J S(74);\n#define _K S(75);\n#define _L S(76);\n#define _M S(77);\n#define _N S(78);\n#define _O S(79);\n#define _P S(80);\n#define _Q S(81);\n#define _R S(82);\n#define _S S(83);\n#define _T S(84);\n#define _U S(85);\n#define _V S(86);\n#define _W S(87);\n#define _X S(88);\n#define _Y S(89);\n#define _Z S(90);\n\n#define _a S(97);\n#define _b S(98);\n#define _c S(99);\n#define _d S(100);\n#define _e S(101);\n#define _f S(102);\n#define _g S(103);\n#define _h S(104);\n#define _i S(105);\n#define _j S(106);\n#define _k S(107);\n#define _l S(108);\n#define _m S(109);\n#define _n S(110);\n#define _o S(111);\n#define _p S(112);\n#define _q S(113);\n#define _r S(114);\n#define _s S(115);\n#define _t S(116);\n#define _u S(117);\n#define _v S(118);\n#define _w S(119);\n#define _x S(120);\n#define _y S(121);\n#define _z S(122);\n\n#define tpp tp.x+=FONT_SPACE\n#define tpm tp.x-=FONT_SPACE\nvec2 tp=vec2(0);// text position\n//return number of decimal digits of [f], with [d]leading zeroes.\nint getNumberOfDigits(in int f,in int d){\n for(int n=0;n<10;n++){f/=10;if(f==0)break;d++;}return d;}\nfloat char(int ch){vec4 f=any(lessThan(vec4(tp,1,1),vec4(0,0,tp))) \n ?vec4(0):texture(iChannel0,.0625*(tp+vec2(ch-ch/16*16,15-ch/16)));  \n return f.x;}\n//display [f]fraction with [d]leadingZeros \nfloat drawFract(int d,float f){float c=0.;f=fract(f)*10.; \n for(int i=1;i<60;i++){c+=char(48+int(f));tpm; \n  d--;f=fract(f)*10.;if(d<=0||f==0.) break;\n }tpp*float(d);return c;}\n//draw [v]int with a minimum # of [m]glyphs\nfloat drawInt(int v,int m){float c=0.;\n if(v<0){v=-v;if(m<1)m=1;else m--; _sub}\n int f=v,d=1;d=getNumberOfDigits(f,d);//for(int n=0;n<10;n++){f/=10;if(f==0)break;d++;} \n d=max(m,d);tpm*float(d);\n for(int n=1;n<11;n++){tpp;c+=char(48+(v-((v/=10)*10)));if(n>=d)break;} \n tpm*float(d);return c;}//https://www.shadertoy.com/view/ldByDw\n\n//display [v]float with [p]decimalPrecision and [m]maxDigits\nfloat drawFloat(float v,int p,int m){float c=0.,tpx=tp.x-FONT_SPACE*float(m);\n if (v<0.){c=char(45);v=-v;}tp.x-=FONT_SPACE; //write \"-\"\n c+=drawInt(int(v),1);c+=char(46);SPACE;//write floor()+\".\"+fract()    \n c+=drawFract(p,fract(v));tp.x=min(tp.x,tpx);return c;}\n//shorter defaults\nfloat drawFloat(float v)      {return drawFloat(v,2,5);} \nfloat drawFloat(float v,int p){return drawFloat(v,p,2);} \nfloat drawInt(int v)          {return drawInt(v,1);}\nvec3 drawColor=vec3(1.);\nvoid SetGlyphColor(float r,float g,float b){drawColor=vec3(b,g,b);}\n\n//utility:\nvoid SetTextPosition(vec2 p,float x,float y){  //x=line, y=column\n tp=10.0*p;tp.x=tp.x+17.-x;tp.y=tp.y-9.4+y;}\n\nfloat glyphs(vec2 p,vec3 i){\n p*=.2;\n float px=16.1;\n float py=8.4;\n SetTextPosition(p,px,py);\n SetGlyphColor (0., 0., 0.);\n float r=0.;\n if(i.z>0.){\n  p.y=-p.y;\n  py+=1.;\n  SetGlyphColor (0.5, 0.5, 0.5);\n }\n    \n SetTextPosition(p,px,py);\n r+=drawInt(int(i.x),3);\n SetTextPosition(p,px,py+1.);\n r+=drawInt(int(i.y),3);\n SetTextPosition(p,px,py+2.);\n r+=drawInt(int(i.z),1);\n return r;\n}\n\nfloat hash22(vec2 p){//not the most convincing hash\n vec3 p3 = fract(vec3(p.xyx) / vec3(1,sqrt(5.),sqrt(2.)));\n p3 += dot(p3.zxy, p3.yxz+19.19);\n vec2 r=fract(vec2(p3.x * p3.y, p3.z*p3.x*(sqrt(5.)*.5+.5)));\n return r.y;\n}\n\n//return rgb of hue [h], input range[0..1]\nvec3 hue(float h){\n return clamp(abs(mod(h*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);}\n\n\nvoid mainImage(out vec4 Out, in vec2 In){\n  vec2 p=frame(In);\n vec2 m=frame(iMouse.xy);\n vec2 n=frame(iMouse.zw);\n vec3 tileId=frameN(In);\n float text=glyphs(p,tileId);\n //uncomment to debug some extreme cases:\n //n.y=1.;//overwrite to test entry from north\n //n=vec2(0,1);m=vec2(1,1);//overwrite to test ray along a triangle border.\n //m=n;//ray with nul direction tst;\n if(m==n){n=vec2(0,1);m=vec2(1,1);}\n if(!InTri(n))n=vec2(0);\n float ray=0.;\n float at =-atan(m.y-n.y,m.x-n.x);\n if(iMouse.z<0.){//if left mouse buton is up\n      ray=ils(r(p,acos(0.)));\n }else{//if left mouse buton is down\n  ray=ils(r((n-p),at));}\n ray=smoothstep(.0,.1,ray);\n vec2 q=((p*.5))+vec2(.5,.5);//-sqrt(1.25)*\n float tri=fNgon(q,3.)-1.;\n tri=smoothstep(.0,.1,abs(tri)); \n vec2 f=planeRay(vec3(p,0),vec3(m,0),vec3(m-n,0)).xy;\n float g=length(f-p);\n g=smoothstep(0.,.01,g-.1);\n vec3 r=vec3(ray,g,tri);\n float ii=.6;\n if(InTri(p))ii=1.;\n float h=hash22(tileId.xy);\n vec3 col=hue(h)*.2+.7;\n r=mix(col-r*.5,drawColor,text);\n Out=vec4(r*ii,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}