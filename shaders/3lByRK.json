{
    "Shader": {
        "info": {
            "date": "1594758165",
            "description": "analytic integral for fog with the density `pow(dot(sin(origin + x*dir), vec3(1), 2.);` currently have problems with divisions by zero\n\non the left is one component, on the right are 50 summed up",
            "flags": 0,
            "hasliked": 0,
            "id": "3lByRK",
            "likes": 8,
            "name": "Analytic Line Integral Fog",
            "published": 3,
            "tags": [
                "fog",
                "analytic",
                "integral",
                "lineintegral"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 528
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nvec3 div(vec3 a, vec3 b) {\n    b += vec3(equal(b,vec3(0)))*.01;\n    return a/b;\n}\n\nfloat antiderivative(float x, vec3 origin, vec3 dir) {\n    //antiderivative for pow(dot(sin(origin + x*dir), vec3(1), 2.);\n    mat3 A = mat3(1,1,0,-1,0,1,0,-1,-1);\n    mat3 B = mat3(1,1,0,1,0,1,0,1,1);\n    vec3 Q = origin + dir*x;\n    vec3 integral = div(sin(A*Q),(A*dir)) - div(sin(B*Q),(B*dir)) + div((2.*Q-sin(2.*Q)),(4.*dir));\n    return dot(integral, vec3(1));\n}\n\nfloat lineintegral(vec3 a, vec3 b) {\n    float len = distance(a, b);\n    vec3 dir = (b-a)/len;\n    return antiderivative(len,a,dir) - antiderivative(0.,a,dir);\n}\n\nfloat scene(vec3 p) {\n    p = asin(sin(p+1.));\n    return length(p)-1.;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nvec3 hash3(float a, float b) {\n    float s1 = hash(a, b);\n    float s2 = hash(s1, b);\n    float s3 = hash(s2, b);\n    return vec3(s1,s2,s3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1,uv));\n\tvec3 init = vec3(-4,0,0);\n    cam = erot(cam, vec3(0,1,0), .2);\n    init = erot(init, vec3(0,1,0), .2);\n    cam = erot(cam, vec3(0,0,1), iTime/5.);\n    init = erot(init, vec3(0,0,1), iTime/5.);\n    init.x += iTime;\n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 100 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += dist * cam;\n        if (distance(p,init)>50.) break;\n    }\n    vec3 a = p; vec3 b = init; float scale = 1.;\n    float fog = lineintegral(a,b)/20.;\n    \n    if (uv.x > 0.) {\n    \t//sum up multiple different versions of the fog\n    \tfor (int i = 0; i < 50; i++) {\n            //random rotation\n        \tvec3 ax = normalize(tan(hash3(float(i),14353.)));\n        \tfloat ro = hash(float(i),66123.)*10.;\n        \ta = erot(a,ax,ro);\n        \tb = erot(b,ax,ro);\n        \tfog += lineintegral(a*scale,b*scale)/sqrt(scale);\n       \t\tscale *= 1.06;\n    \t}\n\t\tfog /= 2500.;\n\t}\n\n    fragColor = sqrt(vec4(fog));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}