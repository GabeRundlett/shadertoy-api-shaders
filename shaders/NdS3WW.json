{
    "Shader": {
        "info": {
            "date": "1617371541",
            "description": "The Monolith",
            "flags": 0,
            "hasliked": 0,
            "id": "NdS3WW",
            "likes": 7,
            "name": "The Monolith, 1x4x9",
            "published": 3,
            "tags": [
                "raytracing3d"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 312
        },
        "renderpass": [
            {
                "code": "// License CC0: The monolith, 1x4x9\n\n#define TOLERANCE         0.0001\n#define TIME              iTime\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n#define L2(x)             dot(x, x)\n#define PCOS(x)           (0.5 + 0.5*cos(x))\n#define SKYCOLOR(ro, rd)  skyColor(ro, rd)\n\nconst float miss          = 1E4;\nconst float refrIndex     = 0.8;\nconst vec3  lightPos      = 2.0*vec3(1.5, 2.0, 1.0);\n\nconst vec3 skyCol1        = vec3(0.2, 0.4, 0.6);\nconst vec3 skyCol2        = vec3(0.4, 0.7, 1.0);\nconst vec3 sunCol         =  vec3(8.0,7.0,6.0)/8.0;\n\nconst vec3 boxDim         = vec3(1.0, 9.0, 4.0)/18.0;\nconst vec4 plane          = vec4(vec3(0.0, 1.0, 0.0), 0.5);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec4 s) {\n    vec3 ce = s.xyz;\n    float ra = s.w;\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(miss); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// IQ's ray box intersection\nvec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal )  {\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(miss); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p ) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 sunDir = normalize(lightPos);\n  float sunDot = max(dot(rd, sunDir), 0.0);  \n  vec3 final = vec3(0.);\n\n  final += mix(skyCol1, skyCol2, rd.y);\n  final += 0.5*sunCol*pow(sunDot, 20.0);\n  final += 4.0*sunCol*pow(sunDot, 400.0);    \n\n  float tp  = rayPlane(ro, rd, plane);\n  if (tp > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    vec3 ld   = normalize(lightPos - pos);\n    vec3 snor;\n    vec2 rb   = rayBox(pos, ld, boxDim, snor);\n    vec3 spos = pos + ld*rb.x;\n    float it  = rb.y - rb.x;\n    // Extremely fake soft shadows\n    float sha = rb.x == miss ? 1.0 : (1.0-1.0*tanh_approx(it*6.0/(0.1+rb.x)));\n    vec3 nor  = vec3(0.0, 1.0, 0.0);\n    vec3 icol = 1.5*skyCol1 + 4.0*sunCol*sha*dot(-rd, nor);\n    vec2 ppos = pos.xz*0.75+0.23;\n    ppos = fract(ppos+0.5)-0.5;\n    float pd  = min(abs(ppos.x), abs(ppos.y));\n    vec3  pcol= mix(vec3(0.4), vec3(0.3, 0.3, 0.3), exp(-60.0*pd));\n\n    vec3 col  = icol*pcol;\n    col = clamp(col, 0.0, 1.25);\n    float f   = exp(-10.0*(max(tp-10.0, 0.0) / 100.0));\n    return mix(final, col , f);\n  } else{\n    return final;\n  }\n}\n\n\nvec3 innerRender(vec3 ro, vec3 rd, vec3 enor) {\n  const float spr = 0.25;\n\n  vec3 spc = vec3(-enor*spr);\n  vec4 sp  = vec4(spc, spr);\n  vec2 rs = raySphere(ro,rd, sp);\n  vec3 bhsv = vec3(fract(0.05*TIME+dot(enor, rd)*2.0), 0.5, 1.0);\n  vec3 bcol = hsv2rgb(bhsv);\n\n  vec3 col = vec3(0.0);\n  \n  if (rs.x < miss) {\n    float t = rs.x;\n    vec3 pos = ro + rd*t;\n    vec3 nor = normalize(pos - sp.xyz);\n    vec3 ld   = normalize(lightPos - pos);\n    float dif = pow(max(dot(nor,ld),0.0), 2.0);\n    float l   = dif;\n    float lin = mix(0.005, 1.0, l);\n    float itd = rs.y - rs.x;\n    col += lin*bcol;\n    col = mix(col, vec3(0.0), tanh_approx(1E-3/(itd*itd)));\n  }\n\n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 skyCol = SKYCOLOR(ro, rd);\n  vec3 col = vec3(0.0);\n\n  float t   = 1E6;\n  vec3 nor;\n  vec2 rb = rayBox(ro, rd, boxDim, nor);  \n\n  if (rb.x < miss) {\n    t = rb.x;\n    float itd = rb.y - rb.x;\n    vec3 pos  = ro + t*rd;\n    vec3 anor = abs(nor);\n    vec2 tp   = anor.x == 1.0 ? pos.yz : (anor.y == 1.0 ? pos.xz : pos.xy);\n    vec2 bd   = anor.x == 1.0 ? boxDim.yz : (anor.y == 1.0 ? boxDim.xz : boxDim.xy);\n    vec3 refr = refract(rd, nor, refrIndex);\n    vec3 refl = reflect(rd, nor);\n    vec3 rcol = SKYCOLOR(pos, refl);\n    float fre = mix(0.0, 1.0, pow(1.0-dot(-rd, nor), 3.0));\n    vec3 ld   = normalize(lightPos - pos);\n    float dif = pow(max(dot(nor,ld),0.0), 3.0);\n    float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 50.);\n    float lin = mix(0.0, 1.0, dif);\n    vec3 lcol = 2.0*sqrt(sunCol);\n\n    col = innerRender(pos, refr, nor);\n\n    vec2 btp = (1.0*bd - abs(tp));\n    float bdd = pmin(btp.x, btp.y, 0.0125);    \n    float bddd = exp(-10000.0*bdd*bdd);\n//    col += vec3(0.5, 0.5, 1.0)*bddd*10;\n    col *= 1.0 - bddd;\n\n    vec3 diff = hsv2rgb(vec3(0.7, fre, 0.075*lin))*lcol;\n    col += fre*rcol+diff+spe*lcol;\n    if (refr == vec3(0.0)) {\n      // Not expected to happen as the refraction index < 1.0\n      col = vec3(1.0, 0.0, 0.0);\n    }\n    \n    col = mix(col, skyCol, tanh_approx(1E-5/(itd*itd)));\n  } else {\n    // Ray intersected sky\n    return skyCol;\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  const float mul = 0.05;\n  float mm = mix(0.25, 0.5, PCOS(TIME*mul*sqrt(3.0)));\n  vec3 ro = mm*vec3(2.0, 0, 0.2);\n  ro.xz *= ROT((TIME*mul));\n  ro.yz *= ROT(sin(TIME*mul*sqrt(0.5))*0.5);\n  ro += vec3(0.0, mm, 0.0);\n\n  vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  const float rdd = 2.00;\n  vec3 rd = normalize( p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}