{
    "Shader": {
        "info": {
            "date": "1651500293",
            "description": "A set of metallic torus rotating aroung a sphere in an interesting way.",
            "flags": 0,
            "hasliked": 0,
            "id": "NlsfWN",
            "likes": 15,
            "name": "Mesmerizing rings",
            "published": 3,
            "tags": [
                "torus",
                "specular",
                "metal",
                "rotating"
            ],
            "usePreview": 0,
            "username": "LongJohnny",
            "viewed": 415
        },
        "renderpass": [
            {
                "code": "// A set of metallic torus rotating aroung \n// a sphere in an interesting way.\n//\n// The effect comes from accumulating the rotations from the smallest\n// to the largest ring.\n// ----------------------------------------\n\n#define MAX_MARCH_STEPS 50\n#define MAX_MARCH_DIST 10.\n#define MIN_MARCH_DIST 0.01\n\n#define PI 3.14159265359\n#define COLOR vec3(227./255.,147./255.,64./255.)\n#define COLOR2 vec3(.01,0.01,.05)\n\nvec4 sdScene(vec3 p);\n\nvec4 rayMarch(vec3 ro, vec3 rd) {\n    \n    vec4 res = vec4(-1.); // color = xyz, distance = w \n    \n    float t = 0.001f;\n    for (int i = 0; i < MAX_MARCH_STEPS; ++i) {\n        \n        vec4 ds = sdScene(ro + rd*t);   \n        if(ds.w < MIN_MARCH_DIST) {\n            res = vec4(ds.xyz, t);\n            break;\n        }\n        \n        if (ds.w > MAX_MARCH_DIST) {\n            res = vec4(0.0, 0.0, 0.0, -1);\n            break;\n        }\n        \n        t += ds.w;\n    }\n    \n    return res;\n}\n\nvec4 sdScene(vec3 p) {\n     \n    float t = sdSphere(p, 1.);;\n    float ds;\n    \n    p.yz *= rot(PI/2.);\n    \n    float mrgs = 23.;\n    float rgs = floor((mrgs - 5.) / 2.);\n    \n    for (float i = 5.; i < mrgs; i++) {\n        \n        if (mod(i,2.) == 0.) {\n            p.xz *= rot(pow(sin(iTime * .07),2.) * sin(iTime * .01) * 10.);\n            ds = sdTorus(p, vec2(i * .3,.1 * min(3.,i/rgs))); if (ds < t) t = ds; \n        } else {\n            p.zy *= rot(pow(cos(iTime * .07),2.) * cos(iTime * .01) * 10.);\n        }\n    }\n        \n    return vec4(vec3(0.), t);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(vec3 p) // for function f(p)\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdScene( p + k.xyy*h ).w + \n                      k.yyx*sdScene( p + k.yyx*h ).w + \n                      k.yxy*sdScene( p + k.yxy*h ).w + \n                      k.xxx*sdScene( p + k.xxx*h ).w );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec3 origin = vec3(0.);\n    \n    vec3 ro = vec3(0., 0., -7.);\n    ro.z -= (sin(iTime) * .5 + .5) * 2.;\n    vec3 rd = rayDir(ro, origin, uv);\n    \n    vec4  obj = vec4(0.);\n    if (intersectSphere(ro, rd, vec3(0.), 6.93)) {\n        obj = rayMarch(ro, rd);\n    }\n    \n    vec3 col;\n    if (obj.w > 0.) {\n        \n        vec3 p = ro + rd*obj.w;\n        vec3 n = calcNormal(p);\n       \n        float R0 = pow((1. - 0.46094)/(1. + 0.46094),2.);        \n        \n        // Bottom Light\n        {\n            float dif = -n.y*.5 + .5;\n            float spe = -reflect(rd, n).y;\n           \n            spe = smoothstep(0.3,0.9, spe); \n            spe *= R0 + (1. - R0)*pow(1. - dot(rd, n), 5.) * 0.3;\n            \n            col += COLOR * dif * 0.02;\n            col += COLOR * spe * dif * .8;\n        }\n        \n        // Top Light\n        {\n            float dif = n.y*.5 + .5;\n            float spe = reflect(rd, n).y;\n            \n            spe = smoothstep(0.3,0.9, spe); \n            spe *= R0 + (1. - R0)*pow(1. - dot(rd, n), 5.) * 10.;\n            \n            col += COLOR2 * dif;\n            col += COLOR2 * spe * dif * .8;\n        }\n        \n        // Right Light\n        {\n            vec3 ld = normalize(vec3(1.0, -0.4, 0.3));\n            float dif = max(0., dot(n, ld));\n            \n            vec3 hlf = normalize(-rd + ld);\n            float spe = pow(max(0., dot(n, hlf)), 16.);\n            spe *= R0 + (1. - R0)*pow(1. - dot(rd, n), 5.);\n            \n            col += dif * COLOR * .5;\n            col += spe * COLOR * dif * .8;\n        }\n        \n        // Left Light\n        {\n            vec3 ld = normalize(-vec3(1.0, -0.7, 0.3));\n            float dif = max(0., dot(n, ld));\n            \n            vec3 hlf = normalize(-rd + ld);\n            float spe = pow(max(0., dot(n, hlf)), 16.);\n            spe *= R0 + (1. - R0)*pow(1. - dot(rd, n), 5.);\n            \n            col += dif * COLOR2 * .5;\n            col += spe * COLOR2 * dif * 6. * .8;\n        }\n        \n    } else {\n        col = COLOR2 * min(fragCoord.y/iResolution.y + .15, 1.);\n    }\n     \n    // Gamma correct ^(1/2.2)\n    col = pow(col, vec3(.4545));\n    \n    col = clamp(col, 0., 1.);\n    col = smoothstep(0., 1., col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 rayDir(vec3 ro, vec3 origin, vec2 uv) {\n    \n    vec3 d = normalize(origin - ro);\n    \n    vec3 r = normalize(cross(vec3(0.,1.,0.), d));\n    vec3 u = cross(d, r);\n    \n    return normalize(d + r*uv.x + u*uv.y); \n}\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nbool intersectSphere(vec3 ro, vec3 rd, vec3 p, float r) {\n    vec3 oc = ro - p;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - r*r;\n    float h = b*b - c;\n    if( h<0.0 ) return false;\n    return true;\n}\n\n/* ----- Distance functions ---------- */\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}