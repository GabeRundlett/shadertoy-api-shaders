{
    "Shader": {
        "info": {
            "date": "1687155893",
            "description": "Continuation of my experiments with different curve transformations/mappings. Here I'm warping coordinates into circle, then warping coordinate system into 3-string \"braid\" and then applying 4-string \"braid\" sdf to the resulting coordinate + fractal loop.",
            "flags": 0,
            "hasliked": 0,
            "id": "cdsyRl",
            "likes": 41,
            "name": "Knots portal",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "sdf",
                "curve",
                "knots",
                "braids"
            ],
            "usePreview": 0,
            "username": "AndrewB330",
            "viewed": 777
        },
        "renderpass": [
            {
                "code": "const float M_PI = 3.1415926535;\nconst vec3 LIGHT = normalize(vec3(0.0, 0.0, 1.0));\n\n//Sources: https://gist.github.com/yiwenl/745bfea7f04c456e0101\n// https://gist.github.com/sugi-cho/6a01cae436acddd72bdf\nvec3 hsv2rgb(vec3 c){\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,clamp(abs(fract(c.x+K.xyz)*6.-K.w)-K.x, 0., 1.),c.y);\n}\n\nvec3 point_on_curve(float t, int k, float phase, float stretch)\n{\n    float sn = sin(t + phase), \n          cs = cos(t + phase), \n          snk = sin(float(k) * (t + phase)) / float(k);\n    return vec3(cs, t * stretch, snk);\n}\n\nfloat dist_to_point_on_curve_dt(vec3 p, float t, int k, float phase, float stretch)\n{\n    float sn = sin(t + phase), cs = cos(t + phase), snk = sin(float(k) * (t + phase)), csk = cos(float(k) * (t + phase));\n    return 2.0 * (sn * (p.x - cs) - csk * (p.z - snk / float(k)) - stretch * (p.y - stretch * t));\n}\n\nfloat nearest_point_on_curve(vec3 p, int curve, float phase, float stretch)\n{\n    float t = p.y / stretch;\n    for (int i = 0; i < 2;i++)\n    {\n        float dt = dist_to_point_on_curve_dt(p, t, curve, phase, stretch);\n        t -= dt * 0.15;\n    }\n    return t;\n}\n\nfloat sd_curve(vec3 p, int k, float phase, float stretch, float radius)\n{\n    float t = nearest_point_on_curve(p, k, phase, stretch);\n    return (length(point_on_curve(t, k, phase, stretch) - p) - radius) * 0.7;\n}\n\nfloat sd_curve_multi(vec3 p, int k, int n, float phase, float stretch, float radius)\n{\n    float res = 1000.0;\n    for (float i = 0.0; i < float(n); i++)\n    {\n        res = min(res, sd_curve(p, k, M_PI * 2.0 * i / float(n) + phase, stretch, radius));\n    }\n    return res;\n}\n\nvec3 map_circle(vec3 p, float radius)\n{\n    return vec3(length(vec2(p.y, p.x)) - radius, atan(p.y, p.x) * radius, p.z);\n}\n\nfloat approximate_curve_length(float t, float phase, float stretch)\n{\n    // This tries to approximate curve length on the segment [0; t]\n    // But this formula is very inprecise.\n    return t * (pow(stretch * 2.2, 1.8) + 10.12)/10.0\n           - sin((t + phase) * 2.0) * 0.1 * ((0.95 - cos(2.0 * (t + phase))) * 0.83)\n           + sin(phase * 2.0) * 0.095;\n}\n\nvec3 map_curve(vec3 p, float phase, float stretch, float radius, float target_radius)\n{\n    float t = nearest_point_on_curve(p, 2, phase, stretch);\n    float l = approximate_curve_length(t, phase, stretch);\n    vec3 pp = point_on_curve(t, 2, phase, stretch);\n    \n    float sn = sin(t + phase);\n    float cs = cos(t + phase);\n    float csk = cos(3.0 * (t + phase));\n    \n    vec3 ny = normalize(vec3(-sn, stretch, csk));\n    vec3 nz = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 nx = normalize(cross(ny, nz));\n    nz = normalize(cross(nx, ny));\n    \n    float scale = (1.0 + target_radius) / radius;\n    return vec3(dot(p - pp, nx), l, dot(p - pp, nz)) * scale;\n}\n\nvec4 op(vec4 a, vec4 b)\n{\n    return a.w < b.w ? a : b;\n}\n\nvec4 map(vec3 p)\n{\n    vec4 res = vec4(0.0, 0.0, 0.0, 1000.0);\n    \n    \n    float scale = 1.0;\n    float t = iTime * 0.4;\n    \n    // Apply partial transform to the first portal ring for seamless transition\n    p.z -= 0.6 * fract(t);\n    p /= pow(1.7, fract(t));\n    scale *= pow(1.7, fract(t));\n    \n    for (int k = 0; k < 5; k++)\n    {\n        vec3 color = hsv2rgb(vec3((floor(t) + float(k)) * 0.1, 0.7, 0.8));\n        float side = 1.0 - 2.0 * float((k + int(floor(t))) % 2);\n        for (int i = 0; i < 3; i++)\n        {\n            vec3 pp = map_circle(p, 6.0);\n            \n            if (length(pp.xz) > 1.4)\n            {\n                res.w = min(res.w, scale * (length(pp.xz) - 1.1));\n                continue;\n            }\n            \n            pp = map_curve(pp, 2.0 * M_PI / 3.0 * float(i) + iTime * 0.5 * side, 2.0, 0.4, 0.4);\n            res = op(res, vec4(color, scale * sd_curve_multi(pp, 3, 4, 0.0 + iTime * 4.0 + sin(iTime + float(i) * M_PI * 0.5) * 4.0, 1.0, 0.3)));\n        }\n        \n        // Apply transform to the next portal ring\n        scale /= 1.7;\n        p *= 1.7;\n        p.z += 0.6;\n    }\n    \n    // Scale down sdf, because it is not really an sdf an we can miss surface.\n    res.w *= 0.35;\n    return res;\n}\n\nvec4 trace(vec3 origin, vec3 dir)\n{\n    float t = 0.;\n    for (int i = 0; i < 24; i++)\n    {\n        vec4 h = map(origin);\n        origin += dir * h.w;\n        t += h.w;\n        if (h.w < 0.01) return vec4(h.rgb, t);\n        if (origin.z < -6.0) break;\n    }\n\n    return vec4(-1.0);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.02;\n    return normalize(e.xyy*map(pos + e.xyy).w +\n\t\t\t\t\t e.yyx*map(pos + e.yyx).w +\n\t\t\t\t\t e.yxy*map(pos + e.yxy).w +\n\t\t\t\t\t e.xxx*map(pos + e.xxx).w);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    vec3   R = iResolution,\n         dir = normalize(vec3( fragCoord - .5* R.xy , -R.y )),\n      origin = vec3(0, 0, 8);\n    \n    vec4 res = trace(origin, dir);\n    if (res.w > 0.)\n    {\n        vec3 n = calcNormal(origin + res.w * dir);\n        float l = clamp(dot(LIGHT, n), 0., 1.) * 0.6 + 0.4;\n        l *= clamp((dir.z * res.w + origin.z) + 0.7, 0.0, 1.0);\n        fragColor = vec4(res.rgb * l, 1);\n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}