{
    "Shader": {
        "info": {
            "date": "1477833426",
            "description": "Rendering of quadratic curves with distance fields",
            "flags": 0,
            "hasliked": 0,
            "id": "lttSzn",
            "likes": 2,
            "name": "Quad. curve with distance fields",
            "published": 3,
            "tags": [
                "distancefields",
                "curves"
            ],
            "usePreview": 0,
            "username": "Madsy",
            "viewed": 1341
        },
        "renderpass": [
            {
                "code": "/**********************************************************************************\n**    Signed distance to quadratic curve                                         **\n**    Could be used for various things such as font rendering                    **\n**********************************************************************************/\n\nconst int NUM_ITERATIONS = 16; \t//Control how many iterations we perform with Newton-Raphson\n\t\t\t\t\t\t\t\t//Should never be less than 6, preferably higher than 8\n\n\nfloat cubic_eq(float t, float a, float b, float c, float d){\n  return a*t*t*t + b*t*t + c*t + d;\n}\n    \nfloat cubic_eq_deriv(float t, float a, float b, float c, float d){\n  return 3.0*a*t*t + 2.0*b*t + c;\n}\n\nfloat quadratic_curve(float t, float a, float b, float c)\n{\n    //f(x) := at^2 - 2bt^2 + ct^2 - 2at + 2bt + a\n    return a*t*t - 2.0*b*t*t + c*t*t - 2.0*a*t + 2.0*b*t + a;\n}\n\nfloat quadratic_curve_deriv(float t, float a, float b, float c){\n    //f(x) := at^2 - 2bt^2 + ct^2 - 2at + 2bt + a\n    //f'(x) := 2at - 4bt + 2ct - 2a + 2b\n    return 2.0*a*t - 4.0*b*t + 2.0*c*t - 2.0*a + 2.0*b;\n}\n\n\n\n/*\n\tPROBLEM: Find the distance between the closest point 'cp' on the quadratic curve and a point 'p' which is not in the curve (our pixel)\n\tWe first have to find the point on the curve, 'cp'. But the unknown we have to find is the 't' parameter.\n\tWe know that the line from 'cp' to 'p' is a straight line which is perpendicular to the tangent at that point.\n\tSo taking the dot product between ('p' - 'cp') and the tangent will always be zero at the point 'cp'.\n\tLet a:=v1.x, b:=v2.x, c:=v3.x, d:=v1.y, e:= v2.y, f:= v3.y, F(a,b,c) = the quadratic curve function,\n\tand F'(a,b,c) be the derivative of the quadratic curve function.\n\tWe then end up with this general equation:\n\n\t(F(a,b,c) - p.x) * F'(a,b,c) + (F(d,e,f) - p.y) * F'(d,e,f) = 0\n\n\tWhich expanded becomes:\n\t\n\t(a*t*t - 2.0*b*t*t + c*t*t - 2.0*a*t + 2.0*b*t + a - p.x) * (2.0*a*t - 4.0*b*t + 2.0*c*t - 2.0*a + 2.0*b) +\n \t(d*t*t - 2.0*e*t*t + f*t*t - 2.0*d*t + 2.0*e*t + d - p.x) * (2.0*d*t - 4.0*e*t + 2.0*f*t - 2.0*d + 2.0*e)  = 0\n\n\tFinal expansion and rewrite into a cubic equation:\n\n\t(2*a^2 - 8*a*b + 8*b^2 + (4*a - 8*b)*c + 2*c^2 + 2*d^2 - 8*d*e +8*e^2 + (4*d - 8*e)*f + 2*f^2)*t^3 +\n\t(-6*a^2 + 18*a*b - 12*b^2 + (6*b-6*a)*c - 6*d^2 + 18*d*e - 12*e^2 + (6*e - 6*d)*f)*t^2+\n\t(6*a^2 - 12*a*b + 4*b^2 + 2*a*c + 6*d^2 - 12*d*e + 4*e^2 + 2*d*f + (-2*c + 4*b - 2*a)*p.x + (-2*f + 4*e - 2*d)*p.y)*t +\n\t(2*d - 2*e)*p.y + (2*a - 2*b)*p.x + 2*d*e - 2*d^2 + 2*a*b - 2*a^2 = 0\n\n\tThen for the cubic equation we end up with these coefficients:\n\n\ta' = (2*a^2 - 8*a*b + 8*b^2 + (4*a - 8*b)*c + 2*c^2 + 2*d^2 - 8*d*e +8*e^2 + (4*d - 8*e)*f + 2*f^2)\n\tb' = (-6*a^2 + 18*a*b - 12*b^2 + (6*b-6*a)*c - 6*d^2 + 18*d*e - 12*e^2 + (6*e - 6*d)*f)\n\tc' = (6*a^2 - 12*a*b + 4*b^2 + 2*a*c + 6*d^2 - 12*d*e + 4*e^2 + 2*d*f + (-2*c + 4*b - 2*a)*p.x + (-2*f + 4*e - 2*d)*p.y)\n\td' = (2*d - 2*e)*p.y + (2*a - 2*b)*p.x + 2*d*e - 2*d^2 + 2*a*b - 2*a^2\n\n\tWe can now solve for t by solving a'*t*t*t + b'*t*t + c'*t + d' = 0\n*/\n\nbool closest_point_on_quadratic_curve(out float dist, in vec2 v1, in vec2 v2, in vec2 v3, in vec2 p)\n{    \n    float scale = 1.0;\n    \n    //Depending on your coordinate system, you might have to scale the coordinates to avoid astronomically huge numbers\n    //Everything works find in the [-1, 1] neighbourhood.\n    \n    v1 *= scale;\n    v2 *= scale;\n    v3 *= scale;\n    p *= scale;\n    \n    //Coefficients for our cubic equation\n    float a = (2.*v1.x*v1.x - 8.*v1.x*v2.x + 8.*v2.x*v2.x + (4.*v1.x - 8.*v2.x)*v3.x + 2.*v3.x*v3.x +\n               2.*v1.y*v1.y - 8.*v1.y*v2.y + 8.*v2.y*v2.y + (4.*v1.y - 8.*v2.y)*v3.y + 2.*v3.y*v3.y);\n    \n    float b = (-6.*v1.x*v1.x + 18.*v1.x*v2.x - 12.*v2.x*v2.x + (6.*v2.x - 6.*v1.x)*v3.x\n               -6.*v1.y*v1.y + 18.*v1.y*v2.y - 12.*v2.y*v2.y + (6.*v2.y - 6.*v1.y)*v3.y);\n    \n    float c = (6.*v1.x*v1.x - 12.*v1.x*v2.x + 4.*v2.x*v2.x + 2.*v1.x*v3.x + \n               6.*v1.y*v1.y - 12.*v1.y*v2.y + 4.*v2.y*v2.y + 2.*v1.y*v3.y + \n               (-2.*v3.x + 4.*v2.x - 2.*v1.x)*p.x + \n               (-2.*v3.y + 4.*v2.y - 2.*v1.y)*p.y);\n    \n    float d = (2.*v1.y - 2.*v2.y)*p.y +\n        \t  (2.*v1.x - 2.*v2.x)*p.x +\n        \t   2.*v1.y*v2.y - 2.*v1.y*v1.y +\n        \t   2.*v1.x*v2.x - 2.*v1.x*v1.x;\n    \n    \n    \n    float t = 0.0;\n    \n    //We have to change our initial guess for t based on which control point\n    //p is closest to. Or else the initial estimation will be very poor for some values\n    //and give us artifacts.\n\n    if(distance(v1, p) > distance(v3, p)){\n        //if p is closer to the last control point than the  first,\n        //reflect that by choosing another initial guess for t\n        t = 1.0;\n    }\n    \n    //Now we can solve the cubic equation with Newton-Raphson\n    \n    for(int i = 0; i < NUM_ITERATIONS; i++){\n       t = t - (cubic_eq(t, a, b, c, d) / cubic_eq_deriv(t, a, b, c, d));\n    }\n    \n    if(t < 0.0 || t >= 1.0){\n        dist = 65536.0;\n        return false;\n    }\n    \n    vec2 cp;\n    cp.x = quadratic_curve(t, v1.x, v2.x, v3.x);\n    cp.y = quadratic_curve(t, v1.y, v2.y, v3.y);\n    //unsigned distance\n    dist = distance(p, cp);\n    \n    //**********************************************************************************\n    //** This code below computes the sign of the distance to give us signed distance **\n    //** If you want unsigned distance, just return dist as it is above.              **\n    //**********************************************************************************\n    \n    /*\n\t\tThe equation we started with:\n\n\t\t(F(a,b,c) - p.x) * F'(a,b,c) + (F(d,e,f) - p.y) * F'(d,e,f) = 0\n\n\t\t..takes the dot product between 'p'-'cp' and the tangent at 'cp'. But the result is ambiguous as\n\t\tboth (p - cp) and -(p - cp) would give 0. If we want to differ between these two cases and compute a *signed* distance,\n\t\twe can find the sign by taking the dot product between the normal at 'cp' and p. The normal is perpendecular\n\t\tto the tangent and parallel to the line (p - cp), which makes it trivial to compute in the 2D case.\n\t\tIn the 3D case, you would need an extra vector, like an up-vector.\n\t*/\n    \n    //Compute the tangent of the quadratic curve\n    float dxdt = quadratic_curve_deriv(t, v1.x, v2.x, v3.x);\n    float dydt = quadratic_curve_deriv(t, v1.y, v2.y, v3.y);\n    vec2 tangent = vec2(dxdt, dydt);\n    //rotate by 90 degrees to get the normal\n    vec2 normal = vec2(tangent.y, -tangent.x);\n    //multiply distance with the sign of the dot product between the normal\n    //and (p - cp)\n    //this will give us signed distance where the distance is negative behind\n    //the curve\n\n    dist = dist * sign(dot(normal, p - cp));\n    return true;\n}\n\n\n//Show distance values in grayscale and pixels outside the t=[0, 1] range in blue.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 a = vec2(0.2, 0.2);\n    vec2 b = vec2(0.5, 0.7);\n    vec2 c = vec2(0.8, 0.2);\n\n    float aspect = iResolution.y / iResolution.x;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = uv.y * aspect;\n    float d = 0.0;\n    if(closest_point_on_quadratic_curve(d, a, b, c, uv)){\n        if(abs(d) < 0.02){\n            fragColor = vec4(1.- d + 0.02, 1.- d + 0.02, 1.- d + 0.02, 1.0);\n        } else {\n            fragColor = vec4(0.4, 0.4, 0.4, 1.0);\n        }\n    } else {\n    \tfragColor = vec4(0.0, 0.0, 0.4, 1.0);\n    }\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}