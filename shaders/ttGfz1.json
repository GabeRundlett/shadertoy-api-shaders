{
    "Shader": {
        "info": {
            "date": "1614521475",
            "description": "See the tutorial video for a walkthrough of each of these: [url]https://youtu.be/FilPE91ACOA[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "ttGfz1",
            "likes": 42,
            "name": "Quick Lighting Tech",
            "published": 3,
            "tags": [
                "lighting"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 1377
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat lighting(vec3 normal, int type) {\n    if (type == 0) {\n        //phong diffuse lighting\n        vec3 lightDir = normalize(vec3(1));\n        return max(dot(lightDir, normal), 0.);\n    }\n    if (type == 1) {\n        //hemispherical lighting\n        vec3 lightDir = normalize(vec3(1));\n        return dot(lightDir, normal) * .5 + .5;\n    }\n    if (type == 2) {\n        //\"leaky\" phong diffuse lighting\n        vec3 lightDir = normalize(vec3(1));\n        float shade = dot(lightDir, normal);\n        return mix(max(shade, 0.), shade * .5 + .5, .05);\n    }\n    if (type == 3) {\n        //axis lighting\n        return dot(max(normal, 0.), vec3(.4));\n    }\n    if (type == 4) {\n        //downward pointing axis lighting\n        normal = erot(normal, normalize(vec3(-1,1,0)), .96);\n        return dot(max(normal, 0.), vec3(.4));\n    }\n    if (type == 5) {\n        //image based lighting\n        return pow(textureLod(iChannel0, normal.xzy, 7.).x, 2.);\n    }\n    if (type == 6) {\n        //fake image based lighting (\"studio lighting\")\n        return pow(length(sin(normal*2.)*.5+.5)/sqrt(3.), 2.);\n    }\n    if (type == 7) {\n        //fake image based lighting (\"outdoor lighting\")\n        return length(sin(normal*2.)*.5+.5)/sqrt(3.)*smoothstep(-1.,1.,normal.z);\n    }\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    int type = int(mod(iTime/3.14159, 8.));\n    \n    if (fragCoord.x < iResolution.x/3. && fragCoord.y < iResolution.y/3.) {\n        vec2 uv = (vec2(1) - fragCoord/iResolution.xy*3.) * vec2(2., 1.) * 3.1415;\n        vec3 dir = vec3(sin(uv.y)*cos(uv.x), sin(uv.y)*sin(uv.x), cos(uv.y));\n        fragColor = sqrt(vec4(lighting(dir, type)));\n        return;\n    }\n\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 cam = normalize(vec3(1,uv));\n    vec3 init = vec3(-3,0,0);\n    \n    float zrot = iTime+3.14;\n    float yrot = .2;\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += cam*dist;\n        if (distance(p, init) > 10.) break;\n    }\n\n    vec3 n = norm(p);\n    \n    float shade = lighting(n, type);\n\n    fragColor = vec4(hit ? shade : 0.);\n    fragColor = sqrt(fragColor);\n    \n\n    float num = 1.-smoothstep(0.48, 0.51, char((uv+vec2(.85,-.3))*6.,48+type,iChannel1));\n    fragColor = max(fragColor, vec4(num));\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat torus(vec3 p, float r1, float r2) {\n    return length(vec2(length(p.xz)-r1, p.y)) - r2;\n}\n\nfloat super(vec3 x) {\n    return sqrt(length(x*x));\n}\n\nfloat box(vec3 p, vec3 d) {\n    p = abs(p) - d;\n    return super(max(p, 0.)) + min(0., max(max(p.x,p.y),p.z));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0., k-abs(b-a))/k;\n    return min(a,b) - h*h*h*k/6.;\n}\n\nfloat scene(vec3 p) {\n    vec3 p2 = abs(erot(p - vec3(0,0,.4), vec3(1,0,0), radians(45.)));\n    p2.yz = vec2(-smin(-p2.y,-p2.z, .1), smin(p2.y,p2.z,.1));\n    float bx = box(p2, vec3(.05, .75, .15))-.1;\n    float sph = length(p2) - .8;\n    float tor = torus(p - vec3(0,0,-.35), .78, .15);\n    return smin(tor, mix(bx, sph, .15), .1);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\n//////////////////////////////////////////\n//adapted from https://www.shadertoy.com/view/llySRh\nfloat char(vec2 p, int c, sampler2D sampler) {\n    if (p.x < .0 || p.x > 1. || p.y < 0. || p.y > 1.) return 1.;\n\treturn texture( sampler, p/16. + fract( vec2(c, 15-c/16) / 16. ) ).w;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}