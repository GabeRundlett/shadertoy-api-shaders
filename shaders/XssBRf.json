{
    "Shader": {
        "info": {
            "date": "1505579657",
            "description": "A PBR scene to test some lighting.",
            "flags": 0,
            "hasliked": 0,
            "id": "XssBRf",
            "likes": 3,
            "name": "PBR? Sortof...",
            "published": 3,
            "tags": [
                "procedural",
                "test",
                "sdf",
                "pbr"
            ],
            "usePreview": 0,
            "username": "BeardThings",
            "viewed": 692
        },
        "renderpass": [
            {
                "code": "vec3 RayDirection(in vec3 \tforward,\n                  in float \tfocalDistance,\n                  in vec3 \tright,\n                  in vec3 \tup,\n                  in vec2 \tscreenSpaceCoord,\n                  in float \taspectRatioXOverY)\n{\n    return normalize(forward * focalDistance + \n                     right * screenSpaceCoord.x * aspectRatioXOverY +\n                     up * screenSpaceCoord.y);\n}\n\nfloat Sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n\nfloat SDF(vec3 p)\n{\n    float sphereIntersect = Sphere(p, 1.0);\n    return sphereIntersect;\n}\n\nvec3 Norm(vec3 p)\n{\n    const float cEps = 0.01;\n \n\treturn normalize\n\t(\tvec3\n\t\t(\tSDF(p + vec3(cEps, 0, 0)\t) - SDF(p - vec3(cEps, 0, 0)),\n\t\t\tSDF(p + vec3(0, cEps, 0)\t) - SDF(p - vec3(0, cEps, 0)),\n\t\t\tSDF(p + vec3(0, 0, cEps)\t) - SDF(p - vec3(0, 0, cEps))\n\t\t)\n\t);\n}\n\nvec4 Sample(vec3 o, vec3 direction)\n{\n    vec4 fc;\n    \n    float d = 0.0;\n    for(float i = 0.; i < 32.; ++i)\n    {\n        vec3 pos = o + direction * d;\n\n        float sdf = SDF(pos);\n        d += sdf;\n        \n        fc = pow(texture(iChannel0, direction), vec4(2.2));\n        \n        const float EPSILON = 0.01;\n        const float IDEAL_EPSILON = 0.0001;\n        if(sdf < EPSILON)\n        {\n            fc = vec4(0.0);\n            vec3 n = Norm(pos);\n            vec3 albedo = texture(iChannel2,vec2(acos(n.y),atan(n.z,n.x))).rgb;\n\n            // Directional\n            {\n            \tvec3 lo = vec3(cos(1.0) * 3.0, 1.5, -sin(1.0) * 3.0);\n            \tvec3 ld = normalize(lo - pos);\n                float attenuation = 1.0/(1.0+distance(lo,pos));\n                \n                vec3 lightIntensity = vec3(10.0)*attenuation;\n                float lambertCosine = max(dot(n,ld),0.0);\n                vec3 li = lightIntensity*lambertCosine;\n            \n            \t// Specular\n                float spec = albedo.b*10.0;\n                float blinnPhongNormalization = (spec+2.)/(4.0*3.1415*(2.0-exp2(-spec/2.0)));\n                vec3 h=normalize(-direction+ld);\n            \tfloat specularAmount = pow(max(dot(h,n),0.0),spec)*blinnPhongNormalization;\n            \tfc.rgb+=li*specularAmount;\n                li=li*(1.0-specularAmount);\n                \n            \tvec3 lambertNormalized = albedo/vec3(3.1415);\n            \tfc.xyz += lambertNormalized * li;\n            }\n            \n            // Ambient\n            {\n            \tvec3 ambient = pow(textureLod(iChannel1,n,10.0).rgb,vec3(2.2));\n            \tfc.rgb += albedo/3.1415*ambient;\n            }\n            \n            break;\n        }\n        \n        if(d > 30.)\n        {\n            break;\n        }\n    }\n    \n    return fc;\n}\n\nvec3 simpleReinhardToneMapping(vec3 color)\n{\n\tfloat exposure = 1.0;\n\tcolor *= exposure/(1. + color / exposure);\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 screenSpace = uv * 2.0 - 1.0;\n\t\n    const float height = 0.0;\n    vec3 o = vec3(sin(iTime*0.5)*1.5,height,-1.5*cos(iTime*0.5));\n    \n    vec3 f = normalize(-o);\n    vec3 u = vec3(0,1,0);\n    vec3 r = normalize(cross(f, u));\n    \n    vec3 direction = RayDirection(f, \n                                  1.0, \n                                  r, \n                                  u, \n                                  screenSpace, \n                                  iResolution.x / iResolution.y);\n    \n    vec3 fc = Sample(o, direction).xyz;\n    \n    const float gamma = 2.2;\n    // reinhard tone mapping\n    vec3 mapped = simpleReinhardToneMapping(fc);\n    // gamma correction \n    mapped = pow(mapped, vec3(1.0 / gamma));\n    \n    fragColor = vec4(mapped, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}