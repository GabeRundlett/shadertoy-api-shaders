{
    "Shader": {
        "info": {
            "date": "1482017415",
            "description": "Polar and cartesian quasicrystals.\n\nBased on http://glslsandbox.com/e#6839.3 (which is in turn based on http://wealoneonearth.blogspot.co.uk/2011/10/animated-quasicrystals.html).",
            "flags": 0,
            "hasliked": 0,
            "id": "XldSDS",
            "likes": 5,
            "name": "Polar and cartesian crystals",
            "published": 3,
            "tags": [
                "2d",
                "quasicrystal",
                "polar",
                "cartesian",
                "crystal"
            ],
            "usePreview": 0,
            "username": "sheepmaster",
            "viewed": 1122
        },
        "renderpass": [
            {
                "code": "// Degree of symmetry.\nconst int K = 5;\n\n// Wave frequency.\nconst int NUM_STRIPES = 10;\n\n// Period in seconds.\nconst float PERIOD = 3.0;\n\n// Whether to use polar or cartesian coordinates.\nconst bool POLAR = false;\n\n// The slow phase shift results in apparent motion (even though\n// the animation is periodic over time), which can be compensated by shifting\n// the pattern. Because quasicrystals are aperiodic for degrees of symmetry\n// other than 2, 3, 4, and 6 (the ones for which the place can be periodically\n// tiled), motion compensation means the center of rotational symmetry moves\n// over time, so it is only enabled by default for polar coordinates, where\n// the apparent motion is a rotation and zoom.\nconst bool MOTION_COMPENSATION_IN_CARTESIAN = false;\n\n// Zoom effect when using polar coordinates.\n// 1.0 zooms in, -1.0 zooms out, 0.0 stays still.\nconst float POLAR_ZOOM = 0.0;\n\n// Scaling factor for r in polar coordinates.\nconst float POLAR_SCALING = 1.0;\n\n// Scaling factor for cartesian coordinates.\nconst float CARTESIAN_SCALING = 3.0;\n\n// Use sawtooth instead of cosine waves.\nconst bool SAWTOOTH = false;\n\n// Plot contours instead of absolute values.\nconst bool CONTOUR = false;\n\n// Line width when using contours.\nconst float CONTOUR_WIDTH = 16.;\n\n// Color the values with a radial rainbow gradient.\nconst bool RAINBOW_COLOR = false;\n\n// If not using rainbow colors, use this base color.\nconst vec3 BASE_COLOR = vec3(1.0, 0.0, 1.0);\n\nconst float PI = 4.0 * atan(1.0);\n\nfloat smoothe(float x) {\n    return x * x * (3.0 - 2.0 * x);\n}\n\nvec3 smoothe(vec3 x) {\n    return x * x * (3.0 - 2.0 * x);\n}\n\nvec3 hsv2rgbSmooth(float hue, float saturation, float value) {\n\tvec3 rgb = clamp(abs(mod(hue*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n\n\treturn value * mix(vec3(1.0), smoothe(rgb), clamp(saturation, 0.0, 1.0));\n}\n\nfloat roundToFraction(float x, int frac) {\n    return floor(x * float(frac) + 0.5) / float(frac);\n}\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nfloat sawtooth(float x) {\n    return 2. * abs(mod(x / PI, 2.) - 1.) - 1.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 xy = fragCoord.xy - iResolution.xy / 2.0;\n\tfloat phase = 2.0 * PI * iTime / PERIOD;\n\n    float k = float(K);\n\n    vec2 coords;\n    float scale;\n    if (POLAR) {\n        scale = POLAR_SCALING;\n        float theta = arg(xy);\n        float r = log(dot(xy, xy)) * scale;\n        coords = vec2(theta, r);\n    } else {\n        scale = CARTESIAN_SCALING * 2.0 / iResolution.x;\n    \tcoords = xy * scale;\n    }\n\tcoords *= float(NUM_STRIPES);\n    \n    // Compensate for apparent motion.\n    if (POLAR || MOTION_COMPENSATION_IN_CARTESIAN) {\n        float motionCompensation = phase;\n        coords.x -= motionCompensation / k * 2.;\n\n        if (POLAR) {\n            // Adjust the compensation for the y coordinate to give a\n            // zoom effect if desired. If POLAR_ZOOM is -1, the compensation is\n            // set to zero, which results in the natural apparent motion\n            // (zooming out).\n            motionCompensation *= POLAR_ZOOM + 1.0;\n        }\n        coords.y -= motionCompensation;\n    }\n\n\tfloat c = 0.0;\n    vec2 g;\n    if (SAWTOOTH) {\n        g = vec2(1);\n    } else {\n        g = vec2(0);\n    }\n\tfor (int t = 0; t < K; t++) {\n\t\tfloat tScaled = PI*float(t)/k;\n        vec2 omega = vec2(cos(tScaled), sin(tScaled));\n        if (POLAR) {\n            // When using polar coordinates, round to the nearest fraction of\n            // NUM_STRIPES to ensure the wave has a period of 2 pi.\n            omega.x = roundToFraction(omega.x, NUM_STRIPES);\n        }\n        float p = dot(coords, omega) + phase;\n        if (SAWTOOTH) {\n\t\t\tc += sawtooth(p);\n        } else {\n            c += cos(p);\n            g -= omega * sin(p);\n        }\n\t}\n    \n\tfloat val;\n    if (CONTOUR) {\n        float d = abs(c) / length(g);\n        val = 1. - smoothstep(0., CONTOUR_WIDTH * scale, d);\n    } else {\n        val = smoothe((c+k)/(k*2.0));\n    }\n   \n    vec3 color;\n    if (RAINBOW_COLOR) {\n        color = hsv2rgbSmooth(arg(xy) / (2. * PI), length(xy) / 25., val);\n    } else {\n    \tcolor = BASE_COLOR * val;\n    }\n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}