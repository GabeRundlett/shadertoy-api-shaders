{
    "Shader": {
        "info": {
            "date": "1597638499",
            "description": "Press 1, 2, 3 to change mode.\n1: Automatic camera.\n2: Control character. WASD to move. ARROW KEYS to turn. SHIFT to sprint. SPACE to jump.\n3: Fly freely. WASD to move. Same as 2, but SPACE/SHIFT control elevation. Hold C/V speed up/down.\nHold Q/E new seed",
            "flags": 48,
            "hasliked": 0,
            "id": "wlsBW7",
            "likes": 15,
            "name": "Mountainous Landscape",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "terrain",
                "generation"
            ],
            "usePreview": 0,
            "username": "vipiao",
            "viewed": 790
        },
        "renderpass": [
            {
                "code": "\nMOUNTAIN_FUNCTIONS\n\n// Water.\nconst float WATER_HEIGHT = -0.3;\nfloat waterFunction(in vec3 pos, in float time){\n\tconst int size = 6;\n    const float f = 75.;\n    const float m = 0.0005;\n    const vec3 vecs[size] = vec3[](\n        vec3( f*1.,  f*2.,  m*0.2),\n        vec3(f*0.5, f*0.5,  m*0.1),\n        vec3(f*-1., f*0.2,  m*0.1),\n        vec3( f*0.,f*-0.5,  m*0.5),\n        vec3( f*2., f*-2., m*0.01),\n        vec3(f*-2.,  f*5., m*0.01)\n    );\n    float waveHeight = 0.;\n    for(int i=0; i<size; i++) {\n        // The speed of waves on water is independent on amplitude and wavelength.\n    \twaveHeight += sin(pos.x*vecs[i].x+pos.z*vecs[i].y+0.01*time*length(vecs[i].xy))*vecs[i].z;\n    }\n    return waveHeight + WATER_HEIGHT;\n}\n\nfloat sdWater(in vec3 pos){\n    const float maxWaveHeight = (.2+.1+.1+.5+.01+.01)*.05;\n    const float maxWaterHeight = maxWaveHeight + WATER_HEIGHT; // See waterFunction(.).\n    if(pos.y - maxWaterHeight > maxWaveHeight){\n    \treturn pos.y - maxWaterHeight;\n    }\n    \n    float waveHeight = waterFunction(pos, iTime);\n    \n\tfloat heightDiff = pos.y - waveHeight;\n    const float maxSlope = 1.;\n    float nextDist = heightDiff/sqrt(maxSlope*maxSlope + 1.);\n    \n    return max(nextDist, pos.y-maxWaterHeight);\n}\n\nvoid sdWaterNormal(in vec3 pos, inout vec3 normal, inout float sd){\n\tsd = sdWater(pos);\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(CAMERA_POS, 0), 0).xyz;\n    float df = max(sqrt(length(cameraPos-pos)), 1.)*0.01;\n    vec2 e = vec2(df, 0.);\n    normal = normalize(sd - vec3(\n    \tsdWater(pos - e.xyy),\n    \tsdWater(pos - e.yxy),\n    \tsdWater(pos - e.yyx)\n    ));\n}\n\n// Ray marching.\n# define INTERSECTED 0\n# define TOO_FAR 1\n# define TOO_MANY_STEPS 2\nfloat finalRes;\nvoid marchWorld(\n    inout vec3 pos, inout vec3 dir,\n    out float dist, in float maxDist, in float minDist,\n    out int numSteps, in int maxNumSteps,\n    out vec3 color, out vec3 normal, out int returnCode\n){\n    dist = 0.;\n    float prevDist = dist;\n    numSteps = 0;\n    color = vec3(0);\n    vec3 prevPos = pos;\n    float prevSd;\n    float sd = 0.;\n    // Trace.\n    for(int i=0; i<maxNumSteps; i++) {\n        //\n        numSteps++;\n        # define log16(x) log(x)/log(16.)\n\t\t//float res = clamp(50./(dist+0.0001), 1., 3.);\n\t\tfloat res = clamp(log16(1000./(dist+0.0000001)), 1., 3.);\n        float f = fract(res);\n        res = floor(res) + f*f*(3.-2.*f);\n        //float res = 3.;\n        finalRes = res;\n        \n        // Calc sd.\n        prevSd = sd;\n        float sdMount = sdMountain(/*in vec3=*/pos, res, /*differentiable=*/false);\n        float sdWater = sdWater(/*in vec3=*/pos);\n        sd = min(sdMount, sdWater);\n        \n        if(dist + sd > maxDist){\n        \tsd = maxDist-dist;\n            dist += sd;\n            pos += dir*sd;\n            \n            color = vec3(0);\n            normal = vec3(0);\n            \n            returnCode = TOO_FAR;\n        \treturn;\n        }\n        if(sd <= minDist + dist*0.001){\n            // Linearly interpolate position.\n            float fac = (minDist + dist*0.001 - sd) / (prevSd - sd);\n            pos = mix(pos, prevPos, fac);\n            \n            if(sdMount < sdWater){\n                // Mountain.\n                sdMountainNormal(\n                    /*in vec3 pos=*/pos, /*out vec3 normal=*/normal, /*out float sd=*/sd,\n                    /*in float resolution=*/res+1., /*in float df=*/max(3./iResolution.x*dist, 0.00003)\n                );\n                // Gray dark.\n                //color = vec3(110., 116., 120.)/255.;\n                color = vec3(155., 155., 154.)/255.;\n                // Gray light.\n                color = mix(color, vec3(199., 194., 187.)/255., min(pow(normal.y+0.5, 8.), 1.));\n                // Grass.\n                float grassFactor = min(pow(normal.y+0.3, 8.), 1.);\n                color = mix(color, vec3(146., 116., 32.)/255., grassFactor);\n                // Sand.\n                float sandFactor = min(pow(normal.y+0.2, 8.), 1.);\n                sandFactor *= clamp(-pos.y*10.-2., 0., 1.);\n                color = mix(color, vec3(219., 209., 180.)/255., sandFactor);\n                // Snow.\n                float snowFactor = min(pow(normal.y+0.2, 8.), 1.);\n                snowFactor *= clamp(pos.y*10.-8.+sin(pos.x*2.)*3.*0., 0., 1.);\n                color = mix(color, vec3(235., 235., 255.)/255., snowFactor);\n                \n                returnCode = INTERSECTED;\n            \treturn;\n            } else {\n                // Water.\n                sdWaterNormal(/*in vec3 pos=*/pos, /*out vec3 normal=*/normal, /*out float sd=*/sd);\n                dir = reflect(dir, normal);\n                prevDist = dist;\n                dist += sd;\n                prevPos = pos;\n                pos += dir*sd;\n                \n                float diff = sdMount - sdWater;\n                if(diff + cos(diff*200000. - iTime*8.)*0.00002 < 0.00003 - dist*0.001){\n                \tcolor = vec3(0.8,0.8,1)*2.;\n                    \n                    returnCode = INTERSECTED;\n            \t\treturn;\n                }\n                \n                continue;\n            }\n            \n            //if(sd < 0.){\n            //\tcolor = vec3(1,0,0);\n            //}\n            \n            //color=vec3(1,1,0);\n\n            \n        }\n        \n        //\n        prevDist = dist;\n        dist += sd;\n        prevPos = pos;\n        pos += dir*sd;\n       \t\n    }\n    returnCode = TOO_MANY_STEPS;\n    return;\n}\n\nvoid marchWorldShaddow(\n    inout vec3 pos, inout vec3 dir,\n    out float dist, in float maxDist, in float minDist,\n    out int numSteps, in int maxNumSteps, out float shaddowFactor,\n    out int returnCode\n){\n    dist = 0.;\n    float prevDist = dist;\n    numSteps = 0;\n    float sd = 0.;\n    shaddowFactor = 1.;\n    // Trace.\n    for(int i=0; i<maxNumSteps; i++) {\n        //\n        numSteps++;\n        # define log16(x) log(x)/log(16.)\n\t\tfloat res = clamp(log16(100./(dist+0.0000001)), 1., 3.);\n        \n        // Calc sd.\n        float sdMount = sdMountain(/*in vec3=*/pos, res, /*differentiable=*/false);\n        sd = sdMount;\n        \n        // Soft shaddows inspired by https://iquilezles.org/articles/rmshadows.\n        shaddowFactor = min(shaddowFactor, 100.*sd/(dist+1e-6));\n        \n        if(dist + sd > maxDist){\n            returnCode = TOO_FAR;\n        \treturn;\n        }\n        if(sd <= minDist + dist*0.001){\n            returnCode = INTERSECTED;\n            return;\n        }\n        \n        //\n        dist += sd;\n        pos += dir*sd;\n       \t\n    }\n    returnCode = TOO_MANY_STEPS;\n    return;\n}\n\n// Render.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(CAMERA_POS, 0), 0).xyz;\n    vec3 forward = normalize(texelFetch(iChannel0, ivec2(CAMERA_DIRECTION, 0), 0).xyz);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = cross(right, forward);\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 camPos = vec3(cameraPos.x, cameraPos.y, cameraPos.z);\n    vec3 viewDir = normalize(forward*0.5 + right * uv.x + up * uv.y);\n    \n    vec3 pos = camPos;\n    vec3 dir = viewDir;\n    float dist = 0.;\n    float maxDist = 40.;\n    float minDist = 0.00001;\n    int numSteps;\n    int maxNumSteps = 200;\n    vec3 color;\n    vec3 normal;\n    int returnCode;\n    marchWorld(\n        /*inout vec3 pos=*/pos, /*inout vec3 dir=*/dir,\n        /*out float dist=*/dist, /*in float maxDist=*/maxDist, /*in float minDist=*/minDist,\n        /*out int numSteps=*/numSteps, /*in int maxNumSteps=*/maxNumSteps,\n        /*out vec3 color=*/color, /*out vec3 normal=*/normal, /*out int returnCode=*/returnCode\n    );\n    \n    vec3 lightDir = normalize(vec3(5.,-1,3.));\n    //float t = iTime*0.1 + 177.;\n    //vec3 lightDir = normalize(vec3(sin(t),cos(t),1.));\n    \n    float shaddowFactor;\n    if(returnCode == INTERSECTED){\n        vec3 shaddowPos = pos-lightDir*minDist*2.;\n        vec3 shaddowDir = -lightDir;\n        float shaddowDist;\n        float shaddowMaxDist = maxDist;\n        float shaddowMinDist = minDist;\n        int shaddowNumSteps;\n        int shaddowMaxNumSteps = maxNumSteps;\n        shaddowFactor;\n        int shaddowReturnCode;\n        marchWorldShaddow(\n            /*inout vec3 pos=*/shaddowPos, /*inout vec3 dir=*/shaddowDir,\n            /*out float dist=*/shaddowDist, /*in float maxDist=*/shaddowMaxDist, /*in float minDist=*/shaddowMinDist,\n            /*out int numSteps=*/shaddowNumSteps, /*in int maxNumSteps=*/shaddowMaxNumSteps, /*out float shaddowFactor=*/shaddowFactor,\n            /*out int returnCode=*/shaddowReturnCode\n        );\n        shaddowFactor *= max(shaddowDist / shaddowMaxDist, shaddowDist/shaddowMaxDist);\n    } else {\n    \tshaddowFactor = 1.;\n    }\n    \n    \n    // Ambient occlusion.\n    vec3 occlusionColor = vec3(0.,0.,0.);\n    float occlusionFactor = float(numSteps)/log(dist+10.) * max(dot(-viewDir, normal), 0.);\n    occlusionFactor = max(1.-occlusionFactor*0.025, 0.);\n    \n    float diff = max(dot(-lightDir, normal), 0.)*0.75;\n    \n    vec3 reflectDir = reflect(lightDir, normal); // reflect(I, N) = I - 2.0 * dot(N, I) * N.\n    float spec = pow(max(dot(reflectDir, -viewDir), 0.0), 8.) * 0.5;\n    \n    float ambient = 0.5*occlusionFactor;\n    \n    /*float sum = diff + spec + ambient;\n    if(sum > 1.){\n    \tdiff /= sum;\n    \tspec /= sum;\n    \tambient /= sum;\n    }*/\n    color = (color*diff*shaddowFactor + color*spec*shaddowFactor) + color*ambient;\n    \n    //float test = texelFetch( iChannel0, ivec2(DO_BUFFER_UPDATE,0), 0 ).x;\n    //color.r += test;\n    \n    // Mist.\n    vec3 mistColor = vec3(0.5,0.6,0.9);\n    float skyColorFactor = clamp(viewDir.y * 1., 0., 1.);\n    skyColorFactor = skyColorFactor*skyColorFactor*(3.-2.*skyColorFactor);\n    mistColor = mix(mistColor, vec3(0.3, 0.4, 0.9), skyColorFactor);\n    float mistFactor = max(float(numSteps)/float(maxNumSteps), float(dist)/float(maxDist));\n    mistFactor = pow(mistFactor, 1.);\n    color = mix(color, mistColor, mistFactor);\n    \n    // The sun.\n    float d = dist/maxDist * 2.*max(mistFactor*mistFactor*mistFactor-0.5, 0.)*min(pow(max(dot(dir, -lightDir), 0.), 1024.), 1.);\n    //float d = ;\n    color = min(color + vec3(d), 1.);\n    \n    /*float testF = 1073741824.;\n    int testI = int(testF);\n    if(testF == float(testI)){\n    \tcolor.g = 1.;\n    }*/\n    \n    /*float testF = texelFetch(iChannel0, ivec2(PRECISION_TEST, 0), 0).x;\n    if(int(testF) == PRECISION_NUMBER){\n    \tcolor.g = 1.;\n    }*/\n    \n    //color.r = ceil(finalRes-1.)/3.;\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// This buffer is used to store global variables, like camera position and such.\n\nMOUNTAIN_FUNCTIONS\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // Change movement mode.\n    if(ivec2(fragCoord) == ivec2(MOVEMENT_MODE,0)){\n        bool key1IsDown = texelFetch(iChannel2, ivec2(KEY_1,0), 0).x > 0.5;\n        bool key2IsDown = texelFetch(iChannel2, ivec2(KEY_2,0), 0).x > 0.5;\n        bool key3IsDown = texelFetch(iChannel2, ivec2(KEY_3,0), 0).x > 0.5;\n        if(key1IsDown){\n        \tprevColor.r = MOVE_MODE_AUTO;\n        }else if(key2IsDown){\n        \tprevColor.r = MOVE_MODE_WALK;\n        }else if(key3IsDown){\n        \tprevColor.r = MOVE_MODE_FREE;\n        }\n    }\n    float movementMode = texelFetch(iChannel0, ivec2(MOVEMENT_MODE, 0), 0).x;\n    \n    // Accelerate.\n    float sensitivity = texelFetch(iChannel0, ivec2(CAMERA_SENSITIVITY, 0), 0).x;\n    if(ivec2(fragCoord) == ivec2(CAMERA_SENSITIVITY,0)){\n        if(sensitivity == 0.){\n            sensitivity = 0.1;\n            prevColor.r = 0.1;\n        }\n        if(texelFetch( iChannel2, ivec2(KEY_C,0), 0 ).x > 0.5 && prevColor.r < 0.15){\n            prevColor.r *= 1.05;\n        }\n        if(texelFetch( iChannel2, ivec2(KEY_V,0), 0 ).x > 0.5 && prevColor.r > 0.001/10.){\n            prevColor.r /= 1.05;\n        }\n    }\n    \n    // Rotate.\n    vec3 forward = texelFetch(iChannel0, ivec2(CAMERA_DIRECTION, 0), 0).xyz;\n    if(length(forward) == 0.){\n        forward = vec3(0,0,-1);\n    }\n    forward = normalize(forward);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = cross(right, forward);\n    if(ivec2(fragCoord) == ivec2(CAMERA_DIRECTION,0)){\n        if(movementMode == MOVE_MODE_AUTO){\n            forward = vec3(\n                -sin((iTime + START_TIME)*AUTO_MOVEMENT_SPEED + 0.2),\n                -0.1,\n                -cos((iTime + START_TIME)*AUTO_MOVEMENT_SPEED + 0.2)\n            );\n        }else{\n            bool arrowRight = texelFetch( iChannel2, ivec2(KEY_RIGHT,0), 0 ).x > 0.5;\n            bool arrowLeft = texelFetch( iChannel2, ivec2(KEY_LEFT,0), 0 ).x > 0.5;\n            bool arrowUp = texelFetch( iChannel2, ivec2(KEY_UP,0), 0 ).x > 0.5;\n            bool arrowDown = texelFetch( iChannel2, ivec2(KEY_DOWN,0), 0 ).x > 0.5;\n            const float rotationSpeed = 0.04;\n            if(arrowRight){\n                forward = normalize(forward + right*rotationSpeed);\n            }\n            if(arrowLeft){\n                forward = normalize(forward - right*rotationSpeed);\n            }\n            if(arrowUp){\n                forward = normalize(forward + up*rotationSpeed);\n            }\n            if(arrowDown){\n                forward = normalize(forward - up*rotationSpeed);\n            }\n        }\n    \tvec3 right = normalize(cross(forward, vec3(0,1,0)));\n    \tvec3 up = cross(right, forward);\n        prevColor.xyz = normalize(forward);\n    }\n    \n    // Calculate collision.\n    vec3 pos;\n    vec3 cameraPos;\n    vec3 normal;\n    float sd;\n    if(ivec2(fragCoord) == ivec2(CAMERA_POS,0) || ivec2(fragCoord) == ivec2(VELOCITY,0)){\n        cameraPos = texelFetch(iChannel0, ivec2(CAMERA_POS, 0), 0).xyz;\n        pos = cameraPos - vec3(0, 0.001, 0);\n        normal;\n        sd;\n        sdMountainNormal(\n            /*in vec3 pos=*/pos, /*inout vec3 normal=*/normal, /*out float sd=*/sd,\n            /*in float resolution=*/3., /*in float df=*/0.00003\n        );\n    }\n    \n    // Translate.\n    if(ivec2(fragCoord) == ivec2(CAMERA_POS,0)){\n        bool dDown = texelFetch( iChannel2, ivec2(KEY_D,0), 0 ).x > 0.5;\n        bool aDown = texelFetch( iChannel2, ivec2(KEY_A,0), 0 ).x > 0.5;\n        bool spaceDown = texelFetch( iChannel2, ivec2(KEY_SPACE,0), 0 ).x > 0.5;\n        bool shiftDown = texelFetch( iChannel2, ivec2(KEY_SHIFT,0), 0 ).x > 0.5;\n        bool wDown = texelFetch( iChannel2, ivec2(KEY_W,0), 0 ).x > 0.5;\n        bool sDown = texelFetch( iChannel2, ivec2(KEY_S,0), 0 ).x > 0.5;\n        if(movementMode == MOVE_MODE_AUTO){\n            const float rad = 30.;\n            vec3 camPos = vec3(\n            \tcos((iTime + START_TIME)*AUTO_MOVEMENT_SPEED)*rad,\n                0.,\n                -sin((iTime + START_TIME)*AUTO_MOVEMENT_SPEED)*rad\n            );\n        \tprevColor.xyz = vec3(\n            \tcamPos.x,\n                //-sdMountain(camPos, 0., true)*3.+0.5,\n                1.269,\n                camPos.z\n            );\n        }else if(movementMode == MOVE_MODE_WALK){\n        \tvec3 velocity = texelFetch( iChannel0, ivec2(VELOCITY,0), 0 ).xyz;\n            prevColor.xyz += velocity;\n            if(sd < 0.){\n            \tprevColor.y += -sd - 0.00001;\n            }\n        } else if(movementMode == MOVE_MODE_FREE){\n            if(wDown){\n                prevColor.xyz += forward*sensitivity;\n            }\n            if(sDown){\n                prevColor.xyz -= forward*sensitivity;\n            }\n            if(dDown){\n                prevColor.xyz += right*sensitivity;\n            }\n            if(aDown){\n                prevColor.xyz -= right*sensitivity;\n            }\n            if(spaceDown){\n                prevColor.xyz += up*sensitivity;\n            }\n            if(shiftDown){\n                prevColor.xyz -= up*sensitivity;\n            }\n        }\n    }\n    \n    // Accelerate.\n    if(ivec2(fragCoord) == ivec2(VELOCITY,0)){\n        \n        if(movementMode == MOVE_MODE_WALK){\n            // Gravity.\n            //const float gravity = -0.000002;\n            const float gravity = -1.513888888888e-6 * 1.5; // 9.81m/s^2 * 1.5\n            prevColor.y += gravity;\n            \n        \t// Collision.\n            vec3 velocity = prevColor.xyz;\n            bool dDown = texelFetch( iChannel2, ivec2(KEY_D,0), 0 ).x > 0.5;\n            bool aDown = texelFetch( iChannel2, ivec2(KEY_A,0), 0 ).x > 0.5;\n            bool spaceDown = texelFetch( iChannel2, ivec2(KEY_SPACE,1), 0 ).x > 0.5;\n            bool shiftDown = texelFetch( iChannel2, ivec2(KEY_SHIFT,0), 0 ).x > 0.5;\n            bool wDown = texelFetch( iChannel2, ivec2(KEY_W,0), 0 ).x > 0.5;\n            bool sDown = texelFetch( iChannel2, ivec2(KEY_S,0), 0 ).x > 0.5;\n            vec3 flatForward = normalize(vec3(forward.x, 0, forward.z));\n            if(sd < 0. && dot(velocity, normal) < 0.){\n\t\t\t\t// Collision impulse.\n                //velocity = reflect(velocity, normal);\n                velocity.y = 0.;\n            }\n            if(sd < 0.0002){\n                float walkForce = 0.00001;\n                const float jumpForce = 0.00006;\n                if(shiftDown){\n                \twalkForce *= 2.;\n                }\n                // Walk force.\n                velocity.xz *= 0.8; // Walking friction.\n                vec3 walkForceVec = vec3(0);\n                if(wDown){\n                \twalkForceVec += flatForward*walkForce;\n                }\n                if(sDown){\n                    walkForceVec -= flatForward*walkForce;\n                }\n                if(dDown){\n                    walkForceVec += right*walkForce;\n                }\n                if(aDown){\n                    walkForceVec -= right*walkForce;\n                }\n            \tif(spaceDown){\n                    velocity.y = 0.;\n                    walkForceVec += up*jumpForce;\n                }\n                if(dot(normalize(walkForceVec), normal) > -0.75){\n\t                velocity += walkForceVec;\n                }\n            }\n            prevColor.xyz = velocity;\n        } else {\n        \tprevColor.xyz = vec3(0);\n        }\n    }\n    \n    // Check for screen resolution change.\n    if(ivec2(fragCoord) == ivec2(SCREEN_RESOLUTION,0)){\n        prevColor.xy = iResolution.xy;\n    }else if(ivec2(fragCoord) == ivec2(DO_BUFFER_UPDATE,0)){\n        bool qIsDown = texelFetch( iChannel2, ivec2(KEY_Q, 0), 0 ).x > 0.5;\n        bool eIsDown = texelFetch( iChannel2, ivec2(KEY_E, 0), 0 ).x > 0.5;\n        if(\n            texelFetch( iChannel0, ivec2(SCREEN_RESOLUTION, 0), 0 ).xy != iResolution.xy || qIsDown || eIsDown\n        ){\n        \tprevColor.x = 1.;\n        }else{\n        \tprevColor.x = 0.;\n        }\n    }\n    \n    // Check for screen resolution change.\n    if(ivec2(fragCoord) == ivec2(PRECISION_TEST,0)){\n        prevColor.x = PRECISION_NUMBER_F;\n        \n    }\n    \n    // Change seed.\n    bool qIsDown = texelFetch(iChannel2, ivec2(KEY_Q,0), 0).x > 0.5;\n    bool eIsDown = texelFetch(iChannel2, ivec2(KEY_E,0), 0).x > 0.5;\n    if(ivec2(fragCoord) == ivec2(CHANGE_SEED,0)){\n        if(qIsDown){\n        \tprevColor.r += 0.1;\n        }\n        if(eIsDown){\n        \tprevColor.r -= 0.1;\n        }\n    }\n    \n    //\n    fragColor = prevColor;\n}\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Math.\n# define PI 3.1415926538\n\n// Input.\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_SPACE  = 32;\nconst int KEY_W  = 87;\nconst int KEY_A = 65;\nconst int KEY_S  = 83;\nconst int KEY_D  = 68;\nconst int KEY_C  = 67;\nconst int KEY_V  = 86;\nconst int KEY_Q  = 81;\nconst int KEY_E  = 69;\nconst int KEY_R  = 82;\nconst int KEY_1  = 49;\nconst int KEY_2  = 50;\nconst int KEY_3  = 51;\n\n# define MAP_WIDTH 30.\nconst int CAMERA_POS = 0;\nconst int CAMERA_SENSITIVITY = 1;\nconst int CAMERA_DIRECTION = 2;\nconst int CHANGE_SEED = 3;\nconst int SCREEN_RESOLUTION = 4;\nconst int DO_BUFFER_UPDATE = 5;\n# define PRECISION_NUMBER 16777216\n# define PRECISION_NUMBER_F 16777216.\nconst int PRECISION_TEST = 6;\nconst int MOVEMENT_MODE = 7;\n# define MOVE_MODE_AUTO 0.\n# define MOVE_MODE_WALK 1.\n# define MOVE_MODE_FREE 2.\nconst int VELOCITY = 8;\n//2^24 = 16777216\n    \n// Auto parameters.\n# define AUTO_MOVEMENT_SPEED 0.04\n# define START_TIME 40.\n\n// --Hash function--\n/*\nInspired by Adam Smith.\nsource: https://groups.google.com/forum/#!msg/proceduralcontent/AuvxuA1xqmE/T8t88r2rfUcJ\n*/\n# define PRECISION 3\n// 2^32-1\n# define LARGEST_UINT 4294967295u\n# define LARGEST_UINT_AS_FLOAT 4294967295.\n// 2^31-1 = 2147483647\n# define LARGEST_INT 2147483647\n# define LARGEST_INT_AS_FLOAT 2147483647.\n# define SMALLEST_INT -2147483648\n# define SMALLEST_INT_AS_FLOAT -2147483648.\n// 2^32 = 4294967296\n# define LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT 4294967296.\n\nint rotate (int x, int b) {\n    return (x << b) ^ (x >> (32-b));\n}\n\nint pcg (int a) {\n    int b = a;\n    for (int i = 0; i < PRECISION; i++) {\n        a = rotate((a^0xcafebabe) + (b^0xfaceb00c), 23);\n        b = rotate((a^0xdeadbeef) + (b^0x8badf00d), 5);\n    }\n    return a^b;\n}\n\nfloat pcgUnit (int a) {\n    return (float(pcg(a))-SMALLEST_INT_AS_FLOAT) / LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT;\n}\n\nint pcg (int a, int b) {\n    for (int i = 0; i < PRECISION; i++) {\n        a = rotate((a^0xcafebabe) + (b^0xfaceb00c), 23);\n        b = rotate((a^0xdeadbeef) + (b^0x8badf00d), 5);\n    }\n    return a^b;\n}\n\nfloat pcgUnit (int a, int b) {\n    return (float(pcg(a,b))-SMALLEST_INT_AS_FLOAT) / LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT;\n}\n\nint pcg (int a, int b, int c) {\n    for (int i = 0; i < PRECISION; i++) {\n        a = rotate((a^0xcafebabe) + (b^0xfaceb00c) + (c^0xcabba6e5), 23);\n        b = rotate((a^0xdeadbeef) + (b^0x8badf00d) + (c^0x0b5e55ed), 5);\n        c = rotate((a^0x5eaf00d5) + (b^0xdecea5ed) + (c^0xba5eba11), 16);\n    }\n    // https://www.dcode.fr/words-containing\n    return a^b^c;\n}\n\nfloat pcgUnit (int a, int b, int c) {\n    return (float(pcg(a,b,c))-SMALLEST_INT_AS_FLOAT) / LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT;\n}\n\n// --Noise functions--\nfloat boxNoise(vec3 pos, int seed){\n\tivec3 ind = ivec3(floor(pos));\n    \n    vec3 f = fract(pos);\n    \n    vec3 u = f * f * (3.0 - 2.0 * f);\n    \n    //return mix(mix(mix( pcgUnit(ind.x+0, ind.y+0, ind.z+0), pcgUnit(ind.x+1, ind.y+0, ind.z+0), u.x),\n    //               mix( pcgUnit(ind.x+0, ind.y+1, ind.z+0), pcgUnit(ind.x+1, ind.y+1, ind.z+0), u.x), u.y),\n    //           mix(mix( pcgUnit(ind.x+0, ind.y+0, ind.z+1), pcgUnit(ind.x+1, ind.y+0, ind.z+1), u.x),\n    //               mix( pcgUnit(ind.x+0, ind.y+1, ind.z+1), pcgUnit(ind.x+1, ind.y+1, ind.z+1), u.x), u.y), u.z);\n    \n    // Optimized version.\n    // 15485863 and 179424673 are primes.\n    ivec2 yS = ivec2(ind.y*15485863, (ind.y+1)*15485863);\n    ivec2 zS = ivec2(ind.z*179424673, (ind.z+1)*179424673);\n    return mix(mix(mix( pcgUnit(ind.x + yS.x + zS.x, seed), pcgUnit(ind.x+1 + yS.x + zS.x, seed), u.x),\n                   mix( pcgUnit(ind.x + yS.y + zS.x, seed), pcgUnit(ind.x+1 + yS.y + zS.x, seed), u.x), u.y),\n               mix(mix( pcgUnit(ind.x + yS.x + zS.y, seed), pcgUnit(ind.x+1 + yS.x + zS.y, seed), u.x),\n                   mix( pcgUnit(ind.x + yS.y + zS.y, seed), pcgUnit(ind.x+1 + yS.y + zS.y, seed), u.x), u.y), u.z);\n}\nfloat boxNoise(vec3 pos){\n    return boxNoise(pos, 0);\n}\n\nfloat layeredBoxNoise(vec3 pos, int numLayers, int seed){\n    seed = pcg(seed);\n\tfloat result = 0.;\n    float scale = 1.;\n    float denominator = 0.;\n    for (int i = 0; i < numLayers; i++) {\n        result += scale * boxNoise(pos, ++seed);\n        denominator += scale;\n        pos *= 2.;\n        pos += PI*0.;\n        scale *= 0.5;\n    }\n    return result/denominator;\n}\n\nfloat perlinNoise(vec3 pos, int seed, int tileSize){\n    ivec3 ind = ivec3(floor(pos));\n    \n    vec3 f = fract(pos);\n    \n    vec3 u = f * f * (3.0 - 2.0 * f);\n    \n    f = f;\n    \n    // 2038074743 and 179424673 are primes.\n    //ivec2 yS = ivec2(ind.y*15485863, (ind.y+1)*15485863);\n    //ivec2 zS = ivec2(ind.z*179424673, (ind.z+1)*179424673);\n    // 7907 and 7919 are primes.\n    ivec3 modInd = ivec3(mod(vec3(ind), float(tileSize)));\n    ivec3 modIndP = ivec3(mod(vec3(ind+1), float(tileSize)));\n    modInd.y *= 7907;\n    modIndP.y *= 7907;\n    modInd.z *= 7919;\n    modIndP.z *= 7919;\n    \n    float nf = 2./float(0x3ff);\n    \n    int x0y0z0H = pcg(modInd.x + modInd.y + modInd.z, seed);\n    float x0y0z0 = dot(\n        vec3(\n            (float(0x000003ff & x0y0z0H)*nf-1.),\n            (float((0x000ffc00 & x0y0z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y0z0H) >> 20)*nf-1.)\n        ),\n        f\n    );\n    \n    int x1y0z0H = pcg(modIndP.x + modInd.y + modInd.z, seed);\n    float x1y0z0 = dot(\n        vec3(\n            (float(0x000003ff & x1y0z0H)*nf-1.),\n            (float((0x000ffc00 & x1y0z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y0z0H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y, f.z)\n    );\n    \n    int x0y1z0H = pcg(modInd.x + modIndP.y + modInd.z, seed);\n    float x0y1z0 = dot(\n        vec3(\n            (float(0x000003ff & x0y1z0H)*nf-1.),\n            (float((0x000ffc00 & x0y1z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y1z0H) >> 20)*nf-1.)\n        ),\n        vec3(f.x, f.y-1., f.z)\n    );\n    \n    int x1y1z0H = pcg(modIndP.x + modIndP.y + modInd.z, seed);\n    float x1y1z0 = dot(\n        vec3(\n            (float(0x000003ff & x1y1z0H)*nf-1.),\n            (float((0x000ffc00 & x1y1z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y1z0H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y-1., f.z)\n    );\n    \n    int x0y0z1H = pcg(modInd.x + modInd.y + modIndP.z, seed);\n    float x0y0z1 = dot(\n        vec3(\n            (float(0x000003ff & x0y0z1H)*nf-1.),\n            (float((0x000ffc00 & x0y0z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y0z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x, f.y, f.z-1.)\n    );\n    \n    int x1y0z1H = pcg(modIndP.x + modInd.y + modIndP.z, seed);\n    float x1y0z1 = dot(\n        vec3(\n            (float(0x000003ff & x1y0z1H)*nf-1.),\n            (float((0x000ffc00 & x1y0z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y0z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y, f.z-1.)\n    );\n    \n    int x0y1z1H = pcg(modInd.x + modIndP.y + modIndP.z, seed);\n    float x0y1z1 = dot(\n        vec3(\n            (float(0x000003ff & x0y1z1H)*nf-1.),\n            (float((0x000ffc00 & x0y1z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y1z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x, f.y-1., f.z-1.)\n    );\n    \n    int x1y1z1H = pcg(modIndP.x + modIndP.y + modIndP.z, seed);\n    float x1y1z1 = dot(\n        vec3(\n            (float(0x000003ff & x1y1z1H)*nf-1.),\n            (float((0x000ffc00 & x1y1z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y1z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y-1., f.z-1.)\n    );\n    \n    return mix(mix(mix( x0y0z0, x1y0z0, u.x),\n                   mix( x0y1z0, x1y1z0, u.x), u.y),\n               mix(mix( x0y0z1, x1y0z1, u.x),\n                   mix( x0y1z1, x1y1z1, u.x), u.y), u.z);\n}\n\nfloat layeredPerlinNoise(vec3 pos, int numLayers, int seed, int tileSize){\n    seed = pcg(seed);\n\tfloat result = 0.;\n    float scale = 1.;\n    float denominator = 0.;\n    for (int i = 0; i < numLayers; i++) {\n        result += scale * perlinNoise(pos, ++seed, tileSize);\n        tileSize *= 2;\n        denominator += scale;\n        pos *= 2.;\n        pos += PI*0.;\n        scale *= 0.5;\n    }\n    return result/denominator;\n}\n\n// --Signed distance functions. (SDF)--\nfloat sdSphere(in vec3 pos, in vec3 center, in float radius){\n   \treturn length(pos-center) - radius;\n}\nvoid sdSphereNormal(in vec3 pos, in vec3 center, in float radius, inout vec3 normal, inout float sd){\n\tsd = sdSphere(pos, center, radius);\n    vec2 e = vec2(0.01, 0.);\n    normal = normalize(sd - vec3(\n    \tsdSphere(pos - e.xyy, center, radius),\n    \tsdSphere(pos - e.yxy, center, radius),\n    \tsdSphere(pos - e.yyx, center, radius)\n    ));\n}\n\n# define MOUNTAIN_FUNCTIONS \\\nbool DisCallingNormal = false;\\\n/* Mountain.*/\\\nfloat getMountainHeight(vec2 pos){\\\n    vec2 uv = pos/MAP_WIDTH;\\\n\tuv.x *= iResolution.y/iResolution.x;\\\n    /* Tile texture.*/\\\n    vec2 coordinate = uv.xy*iResolution.xy;\\\n    const float roundingMargin = 0.00001;\\\n    coordinate.y = mod(coordinate.y, iResolution.y-roundingMargin);\\\n    coordinate.x = mod(coordinate.x, iResolution.y-roundingMargin);\\\n    vec4 samp = texelFetch(iChannel1, ivec2(coordinate), 0);\\\n    vec2 frac = fract(coordinate);\\\n    float h = mix(\\\n    \tmix(samp.x, samp.y, frac.x),\\\n    \tmix(samp.z, samp.w, frac.x),\\\n        frac.y\\\n    );\\\n    \\\n    return h;\\\n}\\\nfloat sdMountain(in vec3 pos, float resolution, bool differentiable){\\\n    vec2 flatPos = pos.xz;\\\n    \\\n    /* Share.*/\\\n    vec2 share = vec2(\\\n        cos(flatPos.x),\\\n        cos(flatPos.y)\\\n    );\\\n    vec2 sharedPos = flatPos + pos.y*share*1.2;\\\n    \\\n    /**/\\\n    float height = 0.;\\\n    float scale = 1.;\\\n    float heightDiff;\\\n    int numIte = int(ceil(resolution));\\\n    /* Rotation.*/\\\n    const float rotSin = sin(2.*PI*(1./16.));\\\n    const float rotCos = cos(2.*PI*(1./16.));\\\n    const mat2 rotMat = mat2(rotCos, -rotSin, rotSin, rotCos);\\\n    /**/\\\n    for(int i=0;i<numIte;i++){\\\n        /* Rotate.*/\\\n        sharedPos = rotMat*sharedPos;\\\n        flatPos = rotMat*flatPos;\\\n        /**/\\\n        sharedPos = mix(sharedPos, flatPos, 0.5);\\\n        float factor = min(resolution - float(i), 1.);\\\n        float h = getMountainHeight(sharedPos * scale);\\\n        h = h/scale * factor;\\\n    \theight += h;\\\n        scale *= 16.;\\\n        heightDiff = pos.y - height;\\\n        if(!differentiable && heightDiff > 4./scale && i < numIte-1){\\\n        \theightDiff = heightDiff - 2./scale;\\\n            break;\\\n        }\\\n    }\\\n    \\\n    heightDiff = pos.y - height;\\\n    \\\n    const float maxSlope = 3.;\\\n    float nextDist = heightDiff/sqrt(maxSlope*maxSlope + 1.);\\\n    \\\n    return nextDist;\\\n}\\\nvoid sdMountainNormal(in vec3 pos, out vec3 normal, out float sd, in float resolution, in float df){\\\n    DisCallingNormal = true;\\\n\tsd = sdMountain(pos, resolution, /*differentiable=*/true);\\\n    /*float df = 0.002;*/\\\n    vec2 e = vec2(df, 0.);\\\n    normal = normalize(sd - vec3(\\\n    \tsdMountain(pos - e.xyy, resolution, /*differentiable=*/true),\\\n    \tsdMountain(pos - e.yxy, resolution, /*differentiable=*/true),\\\n    \tsdMountain(pos - e.yyx, resolution, /*differentiable=*/true)\\\n    ));\\\n    DisCallingNormal = false;\\\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#pragma optionNV(unroll none)\n// This buffer is only changed on screen resolution change. When that happens, the mountain heightmap texture is refreshed once.\n\nfloat getHeight(vec2 pos){\n    float seed = texelFetch( iChannel0, ivec2(CHANGE_SEED, 0), 0 ).x * 0.02;\n#if 0\n    return layeredPerlinNoise(/*vec3 pos=*/vec3(pos*5., seed), /*int numLayers=*/8, /*int seed=*/0, /*int tileSize=*/5)*4.;\n#else\n    const int size = 4;\n    const int numLayers = 8;\n    float noiseX = layeredPerlinNoise(/*vec3 pos=*/vec3(pos*float(size), seed), /*int numLayers=*/numLayers, /*int seed=*/0, /*int tileSize=*/size);\n    float noiseY = layeredPerlinNoise(/*vec3 pos=*/vec3(pos*float(size), seed), /*int numLayers=*/numLayers, /*int seed=*/1, /*int tileSize=*/size);\n    pos += vec2(noiseX, noiseY)*0.2;\n    return layeredPerlinNoise(/*vec3 pos=*/vec3(pos*float(size), seed), /*int numLayers=*/numLayers, /*int seed=*/2, /*int tileSize=*/size)*4.;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevColor = texelFetch(iChannel1, ivec2(fragCoord), 0).xyzw;\n    if(texelFetch( iChannel0, ivec2(DO_BUFFER_UPDATE,0), 0 ).x > 0.5){\n        // Only run once every time the screen resolution or seed is changed.\n        vec2 uv = (fragCoord-0.5*iResolution.xy);\n        uv.x /= iResolution.y;\n        uv.y /= iResolution.y;\n\t\t\n        // Generate mountain noise.\n        vec2 e = vec2(0, 1./iResolution.y);\n        float noise[4];\n        vec2 positions[4] = vec2[](\n        \tuv, uv + e.yx, uv + e.xy, uv + e.yy\n        );\n        for(int i=0; i<4; i++){\n            noise[i] = getHeight(positions[i]);\n        }\n        \n        //\n        prevColor = vec4(noise[0], noise[1], noise[2], noise[3]);\n        \n    }\n    \n    fragColor = prevColor;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}