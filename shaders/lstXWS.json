{
    "Shader": {
        "info": {
            "date": "1462346634",
            "description": "Now if someone could just explain where the flashlight effect that shows up after 20 minutes comes from...\n",
            "flags": 8,
            "hasliked": 0,
            "id": "lstXWS",
            "likes": 48,
            "name": "hall of the mountain king",
            "published": 3,
            "tags": [
                "raymarching",
                "music",
                "pooperdoodlecrazy"
            ],
            "usePreview": 0,
            "username": "hubbe",
            "viewed": 1816
        },
        "renderpass": [
            {
                "code": "#define R 0.08\n#define CUTR (R/8.0)\n\nconst float pi = 3.1415926535;\n\n#define SAND\n\nfloat cutouts(vec3 p) {\n    p.x = abs(p.x);\n    p.z = abs(p.z);\n    if (p.z < p.x) {\n        p.xz = p.zx;\n    }\n    if (p.x > p.z / 2.0) {\n      p.xz -= vec2(sin(pi * 3.0 /16.0), cos(pi * 3.0 /16.0)) * (R + CUTR/3.0);\n    } else {\n      p.xz -= vec2(sin(pi/16.0), cos(pi/16.0)) * (R + CUTR/3.0);\n    }\n\n    vec3 tmp = vec3(0, clamp(p.y, -0.2, 0.4), 0);\n    return length(p - tmp) - CUTR;\n}\n\nvec2 pillars(vec3 p) {\n    // This makes everything below repeat infinitely.\n    p.xz = mod(p.xz, 0.6) - vec2(0.3);\n\n    // Distance to center of ball, squared.\n    float l2 = dot(p.xz, p.xz);\n    \n    // Fall back on a regular distance map.\n    float dist = max(sqrt(l2) - R, - cutouts(p));\n \n    if (p.y > 0.0) {\n        p.y -= 0.55;\n    } else {\n        p.y += 0.35;\n    }\n    \n    dist = min(dist, length(p - clamp(p, -R * 1.2, R * 1.2)));\n    \n    return vec2(dist);\n}\n\nvec2 the_floor(vec3 p) {\n    return vec2(p.y + 0.3, 10000.0);\n}\n\nvec2 sand(vec3 p) {\n    float depth = \n                sin(dot(p.xz, vec2(-0.4, 0.3))) / 17.0 +\n                sin(dot(p.xz, vec2(0.1, 0.02))) / 70.0 +\n                sin(dot(p.xz, vec2(5, 8))) / 250.0 +\n                sin(dot(p.xz, vec2(4, 3))) / 190.0;\n   depth = depth * 17.0 * depth * 25.0 * depth;\n   return vec2(the_floor(p).x + depth);\n}\n\nvec2 the_ceiling(vec3 p) {\n\treturn vec2(-p.y + 0.5, 10000.0);\n}\n\nvec2 erode(vec3 p, vec2 dist) {\n    float x = sin(dot(p.xz, vec2(2,3)))/8.0;\n    x += sin(dot(p.xz, vec2(3,5)/10.0))/8.0;\n    x += sin(dot(p.xz, vec2(35,52)))/100.0;\n    x += sin(dot(p.xz, vec2(7,67)))/100.0;\n\n    float y = cos(dot(p.xz, vec2(2.5,1.8)))/8.0;\n    y += sin(dot(p.xz, vec2(-3.2,5.4)/10.0))/8.0;\n    y += sin(dot(p.xz, vec2(38,47)))/100.0;\n    y += sin(dot(p.xz, vec2(3,77)))/100.0;\n\n    float tmp = min(-0.1 + p.y  + x, -p.y + y + 0.1);\n    #if 1\n    return max(dist, vec2(tmp, tmp * 0.5));\n    #else\n    if (tmp > dist) {\n        // Tmp is not a real distance map, so compensate for it by\n        // taking smaller steps.\n        return tmp * 0.5;\n    } else {\n        return dist;\n    }\n    #endif\n}\n\n\nvec3 twist(vec3 p) {\n    float angle = p.z * p.z / 15000.0;\n    float s = sin(angle);\n    float c = cos(angle);\n    p.xy = mat2(c, s, -s, c) * p.xy;\n    return p;\n}\n\n// Return actual distance, step\nvec2 map(vec3 p) {\n    vec2 dist = vec2(10000.0);\n    #ifdef SAND\n  dist = min(dist, sand(p));\n    #endif\n\n    p = twist(p);\n    dist = min(dist, erode(p, pillars(p)));\n    dist = min(dist, the_floor(p));\n    dist = min(dist, the_ceiling(p));\n    return dist;\n}\n\n// Cast a ray starting at \"from\" and keep going until we hit something or\n// run out of iterations.\nfloat ray(vec3 from, vec3 direction) {\n    // How far we travelled (so far)\n    float travel_distance = 0.0;\n    float last_travel_distance = 0.0;\n    bool hit = false;\n    for (int i = 0; i < 60; i++) {\n        // calculate the current position along the ray\n\t    vec3 position = from + direction * travel_distance;\n        vec2 tmp = map(position);\n\t    float distance_to_closest_object = tmp.x;\n        float step_size = hit ? tmp.x : tmp.y;\n\n        if (distance_to_closest_object < 0.001) {\n        \tif (distance_to_closest_object < 0.0) {\n                // We are inside of an object. Go back to the\n                // previous position and stop using tangent distances\n                // so that we can find the surface.\n            \thit = true;\n          \t    travel_distance = last_travel_distance;\n           \t    continue;\n            }\n            return travel_distance;\n        }\n        last_travel_distance = travel_distance;\n        \n        // We can safely advance this far since we know that the closest\n        // object is this far away. (But possibly in a completely different\n        // direction.)\n        travel_distance += step_size;\n    }\n    // We hit something, but then we ran out of iterations while\n    // finding the surface.\n    #if 1\n    return travel_distance;\n        #else\n    if (hit) return travel_distance;\n    // We walked 50 steps without hitting anything.\n    return 0.0;\n    #endif\n}\n\nfloat shade(vec3 from, vec3 light_pos) {\n    vec3 direction = light_pos - from;\n    float d2 = dot(direction, direction);\n    float dist = sqrt(d2);\n    direction /= dist;\n    \n    float small_step = 0.0005;\n    float dist_from_surface = map(from).x;\n    float dist_closer_to_light = map(from + small_step * direction).x;\n\n    float shading = max(0.0, (dist_closer_to_light - dist_from_surface) / small_step);\n//    float shading = max(0.0, (dist_from_surface - dist_closer_to_light) / small_step);\n    shading += 0.1;\n    shading = min(1.0, shading);\n    \n    float travel_distance = 0.01;\n    for (int i = 0; i < 60; i++) {\n        // calculate the current position along the ray\n\t    vec3 position = from + direction * travel_distance;\n        vec2 tmp = map(position);\n\t    float distance_to_closest_object = tmp.x;\n\n        if (travel_distance >= dist) {\n            break;\n        }\n        if (distance_to_closest_object < 0.001) {\n            return 0.0;\n        }\n        \n        shading = min(shading, 8.0 * distance_to_closest_object / travel_distance);\n        \n        // We can safely advance this far since we know that the closest\n        // object is this far away. (But possibly in a completely different\n        // direction.)\n        travel_distance += tmp.y;\n\n    }\n    return shading / (1.0 + d2 * 0.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.xx;\n\n    vec3 camera_position = vec3(0, 0, -1);\n    vec3 light_position = vec3(0.1, 0.1, 0.1);\n\n    // Animate\n   camera_position.z += iTime/2.0 + iTime * iTime / 200.0;\n //  camera_position.x += iTime/2.0;\n\n   light_position += camera_position;\n //   camera_position.x += iTime/7.0;\n    \n    // Note that ray_direction needs to be normalized.\n    // The \"1\" here controls the field of view.\n    float zoom = 0.9;\n    \n    // Uncomment this for a very funky zoom effect.\n    // float zoom = sin(iTime / 5.0) + 0.4;\n    vec3 ray_direction = normalize(vec3(uv, zoom));\n        \n    // Cast a ray, see if we hit anything.\n    float travel_distance = ray(camera_position, ray_direction);\n    \n    // If we didn't hit anything, go with black.\n    if (travel_distance == 0.0) {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    // Point in space where our ray intersects something.\n    vec3 hit_position = camera_position + ray_direction * travel_distance;\n\n    float light = shade(hit_position, light_position);\n       \n    float sunlight = shade(hit_position, light_position);\n\n     vec3 twisted_hit_pos = twist(hit_position);\n\n    float floor_dist = min(the_floor(twisted_hit_pos).x, the_ceiling(twisted_hit_pos).x);\n    float pillar_dist = erode(twisted_hit_pos, pillars(twisted_hit_pos)).x;\n    \n    if (pillar_dist < floor_dist) {\n      vec2 tpos = vec2(dot(twisted_hit_pos, vec3(0.1,1,0.5)), dot(hit_position, vec3(1,0.1,0.2)));\n      fragColor = texture(iChannel0, tpos);\n    } else {\n      fragColor = texture(iChannel1, twisted_hit_pos.xz * 1.4);\n    }\n\n    #ifdef SAND\n      float sand_dist = sand(hit_position).x;\n      vec2 tpos2 = vec2(dot(hit_position, vec3(0.1,1,0.5)), dot(hit_position, vec3(1,0.1,0.2))) / 40.0;\n      vec4 sand_color = vec4(237, 201, 175, 255) / 255.0;\n      // vec4 sand_color = texture(iChannel2, tpos2);\n      float c = smoothstep(0.0, 1.0, (min(floor_dist, pillar_dist) - sand_dist) * 200.0);\n      fragColor = mix(fragColor, sand_color, c);\n    #endif\n    fragColor = pow(fragColor * sunlight, vec4(1.0/2.2));\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float pi = 3.1415926536;\n\nfloat si(float i) { return sin(fract(i) * pi * 2.0); }\nfloat csi(float i) { return clamp(si(i), -0.707, 0.707); }\nfloat sq(float i) { return fract(i) > 0.5 ? -1.0 : 1.0; }\nfloat saw(float i) { return 2.0 * fract(i) - 1.0; }\nfloat organ(float time, int key) {\n    if (key == 0 || key >= 0xC0) return 0.0;\n    float frequency = 27.5 * pow(2.0, float(key) / 12.0);\n    float ret = 0.0;\n    for (int i = 1; i < 8; i++) {\n      float f = frequency * float(i);\n      ret += csi(f * time) * pow(0.6, float(i)); \n    }\n    ret *= (1.0 + si(time * 10.0)/8.0);\n    return ret * 5.0 / sqrt(frequency);\n}\n\nfloat tempo = 3.5;\nint N = 18;\n\nint imod(int x, int y) { return x - x/y * y; }\n\n#define DIGITS 2\n\nint select(float a, int n) {\n    int div = 0x100;\n    if (n == 1) div = 0x1;\n    return imod(int(a) / div, 0x100);\n}\n\nint select(vec4 a, int n) {\n    float ret;\n    if (n < DIGITS) ret = a.r;\n    else if (n < DIGITS * 2) ret = a.g;\n    else if (n < DIGITS * 3) ret = a.b;\n    else ret = a.w;\n    return select(ret, imod(n, DIGITS));\n}\n\nint select(mat4 m, int n) {\n    vec4 ret;\n    if (n < DIGITS * 4) ret = m[0];\n    else if (n < DIGITS * 8) ret = m[1];\n    else if (n < DIGITS * 12) ret = m[2];\n    else ret = m[3];\n    return select(ret, imod(n, DIGITS * 4));\n}\n\nint base_key(float t) {\n    int n = int(floor(t * tempo));\n    n = imod(n, 304);\n    \n    int key = N;\n    n-= 8;\n    if (n > 0) {\n        if (imod(n, 32) >= 24 && n/64 != 1) key += 3;\n        if (imod(n, 128) >= 64) key += 7;\n    }\n    if (n >= 32 * 6) {\n        if (n >= 32 * 8) return 0;\n        key = N + 7 +\n            select(mat4(0x00FF, 0xFFFF, 0x00FF, 0xFFFF,\n                        0x0007, 0x0007, 0x0707, 0x0000,\n                        0x0CFF, 0xFFFF, 0x0CFF, 0xFFFF,\n                        0x0C13, 0x0C13, 0x1313, 0x0C0C),\n                     imod(n/2, 32));\n    } else {\n        if (imod(n + 32, 2) == 1) key += 7;\n    }\n    return key;\n}\n\nint melody_key(float t) {\n    float n = floor(t * tempo);\n    n = mod(n, 304.0);\n    if (n < 8.0) return 0;\n    int key = N + 24;\n    \n    int note = int(n) - 8;\n\tint stanza = note / 32;\n\tmat4 tmp = mat4(\n        0x0002, 0x0305, 0x0703, 0x0707,\n        0x0602, 0x0606, 0x0501, 0x0505,\n        0x0002, 0x0305, 0x0703, 0x070C,\n        0x0A07, 0x0307, 0x0A0A, 0x0A0A);\n    if (stanza >= 2) {\n        key += 7;\n        if (stanza < 4) {\n            tmp = mat4(\n\t\t        0x0002, 0x0305, 0x0703, 0x0707,\n    \t\t    0x0805, 0x0808, 0x0703, 0x0707,\n      \t\t\t0x0002, 0x0305, 0x0703, 0x0707,\n\t\t        0x0805, 0x0808, 0x0707, 0x0707);\n        }\n    }\n    if (stanza >= 4) key += 5;\n    if (stanza >= 6)\n        tmp = mat4(\n            0xFFFF, 0x8080, 0xFFFF, 0xFFFF,\n            0xFFFF, 0x8080, 0xFFFF, 0xFFFF,\n            0x0002, 0x0305, 0x0703, 0x070C,\n            0x0B07, 0x0B0E, 0x8181, 0x8181);\n    if (stanza >= 7) key += 12;\n    if (stanza >= 8) return 0;\n    key += select(tmp, imod(note, 32));\n    return key;\n}\n\n#define FADE 0.01\n\nfloat melody(float t) {\n\tint key1 = melody_key(t - FADE);\n\tint key2 = melody_key(t);\n\tint key3 = melody_key(t + FADE);\n    float volume = 1.0;\n    if (key1 != key3) {\n        float snap = floor(t * tempo + 0.5) / tempo;\n        volume = abs(t - snap) / FADE;\n    }\n    if (key2 == N + 24 + 5 + 7 + 0x80) {\n        return (organ(t, N + 24 + 15) +\n                organ(t, N + 24 + 18) +\n                organ(t, N + 24 + 24)) * volume;\n    }\n    if (key2 == N + 24 + 5 + 7 + 0x81) {\n        return (/*organ(t, N + 24 + 15) + */\n                organ(t, N + 24 + 24)) * volume;\n    }\n    if (key2 == N + 24 + 12 + 5 + 7 + 0x80) {\n        return (organ(t, N + 24 + 12 + 15) +\n                organ(t, N + 24 + 12 + 18) +\n                organ(t, N + 24 + 12 + 24)) * volume;\n    }\n    if (key2 == N + 24 + 12 + 5 + 7 + 0x81) {\n        return (/* organ(t, N + 24 + 12 + 15) + */\n                organ(t, N + 24 + 12 + 24)) * volume;\n    }\n    return organ(t, key2) * volume;\n}\n\nfloat base(float t) {\n\tint key1 = base_key(t - FADE);\n\tint key2 = base_key(t);\n\tint key3 = base_key(t + FADE);\n    float volume = 1.0;\n    if (key1 != key3) {\n        float snap = floor(t * tempo + 0.5) / tempo;\n        volume = abs(t - snap) / FADE;\n    }\n    return organ(t, key2) * volume;\n}\n\nfloat sound(float time) {\n   float volume = 0.5;\n   float ret = base(time) + melody(time);\n   int note = int(floor(time * tempo)) - 8;\n   note = imod(note, 304);\n   int stanza = note / 32;\n   if (stanza >= 4) volume += 0.3;\n   if (stanza >= 6) volume += 0.3;\n   if (stanza >= 7) volume += 0.5;\n   if (note >= 296) volume = 0.5;\n   return ret * volume;\n}\n\nvec2 mainSound( in int samp,float time) {\n    tempo = 3.5 + time / 120.0;\n    vec2 ret = vec2(0);\n //  time += 55.0;\n    #if 1\n    const float delta = 0.1;\n    for (float i = 0.0; i < 5.0; i += delta) {\n        float i2 = i * i;\n        ret += vec2(sound(time - i2) * cos(i*i * 10.0) / pow(1.3, i2 * 10.0 / pi),\n                    sound(time - i2 + sin(i*7.0)/1000.0) * cos(i2 * 10.0) / pow(1.3, i2 * 10.0 / pi));\n    }\n    ret *= 0.2;\n    #else\n    ret += vec2(sound(time), sound(time+0.001)); \n   ret += vec2(sound(time - 0.201), sound(time - 0.2)) / 3.0; \n  ret += vec2(sound(time - 0.221), sound(time - 0.222)) / 4.0; \n   ret += vec2(sound(time - 0.451), sound(time - 0.45)) / 8.0; \n   ret += vec2(sound(time - 0.811), sound(time - 0.812)) / 11.0; \n    #endif\n    return ret;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 38
                    }
                ],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}