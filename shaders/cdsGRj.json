{
    "Shader": {
        "info": {
            "date": "1666439431",
            "description": "how do it recursive ?\nhow do procedural ?\nhttps://en.wikipedia.org/wiki/Gosper_curve\ngeneralizations: https://www.semanticscholar.org/paper/Generalized-Space-Filling-Gosper-Curves-and-Their-Spence-Werner/88441ef52c46e5d8f13e24466ce8b5218d30f83a/figure/6  ",
            "flags": 0,
            "hasliked": 0,
            "id": "cdsGRj",
            "likes": 24,
            "name": "Gosper curve",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "lsystem",
                "hilbert",
                "spacefilling",
                "templates",
                "peano",
                "eschergosper"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 468
        },
        "renderpass": [
            {
                "code": "                      // pi/3\n#define rot(a) mat2(cos(1.047*(a) + vec4(0,1.57,-1.57,0)))\n// --- draw line\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    p -= b* clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return dot(p,p);                        \n}\n// --- sort of L-system\n                  // .318  = (  pi/3 - atan(sqrt(3),2) ) / pi/3\nfloat p[] = float[](.318,-1.,-2.,1.,2.,0.,1.); // turn \nint   s[] =   int[](   1,-1 ,-1 ,1 ,1 ,1 ,-1); // draw seg: direct or reverse\n   // .333,D,  -pi/3.,iD,  -2pi/3,iD,  pi/3,D,  2pi/3,D,  0,D,  pi/3,iD\n\n#define Rec(draw,draw2)                                      \\\nfloat draw( vec2 U,vec2 P,vec2 _P ) {                        \\\n    vec2 D = _P - P;                                         \\\n    if ( length(U-(P+_P)/2.) > .88 * length(D) ) return 9.; /* optim inspired by mla https://www.shadertoy.com/view/dssGRf */ \\\n    float d=9.;                                              \\\n    for (int i=min(0,iFrame); i<p.length(); i++) {           \\\n        _P = P;                                              \\\n        D *= rot( p[i] );                                    \\\n        P += .378*D; /* 1./length(vec2(2,sqrt(3))) */        \\\n        d = min(d, s[i]>0 ? draw2(U,_P,P) : draw2(U,P,_P) ); \\\n    }                                                        \\\n    return d;                                                \\\n}\n// --- emulates recursion\n#define   draw5  line\nRec(draw4,draw5)  \nRec(draw3,draw4)  \nRec(draw2,draw3)\nRec(draw ,draw2)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y +vec2(.3,-.3), P = vec2(.6);\n    O = vec4( smoothstep(3./R.y,0., sqrt(draw(U, -P, P)) ) );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}