{
    "Shader": {
        "info": {
            "date": "1482067446",
            "description": "This shader toy sample is implemented based on the mini book by Peter Shirley called \"ray tracing in one weekend\".",
            "flags": 0,
            "hasliked": 0,
            "id": "4t3Xzl",
            "likes": 3,
            "name": "Path-tracing sample",
            "published": 3,
            "tags": [
                "materials",
                "specular",
                "lambertian",
                "dielectric",
                "defocusblur"
            ],
            "usePreview": 1,
            "username": "mmostajab",
            "viewed": 1216
        },
        "renderpass": [
            {
                "code": "//#define RENDER_WITH_SHADOWS\n//#define RENDER_WITH_LAMBERTIAN_MATERIALS\n//#define RENDER_WITH_METALIC_MATERIALS\n//#define RENDER_WITH_DIELECTRIC_MATERIALS\n#define RENDER_SCENE_DIFFERENT_MATERIALS\n\n#define DEPTH_OF_FIELD\n//#define FIXED_CAMERA\n\n// =======================================================\n// =======================================================\n// === Helper functions\n// =======================================================\n// =======================================================\n\n#define PI 3.141592\n\nvec3 noise3D( in vec3 x )\n{\n    vec3 ret;\n    \n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv * fract(iTime * 10.0) + 0.5)/256.0).yx;\n\tret.x = mix( rg.x, rg.y, f.z );\n    \n    uv = (p.xy+vec2(97.0,93.0)*p.z) + f.xy;\n    rg = texture( iChannel0, (uv * fract(iTime * 10.0) + 0.5)/256.0).yx;\n\tret.y = mix( rg.x, rg.y, f.z );\n    \n    uv = (p.xy+vec2(61.0,47.0)*p.z) + f.xy;\n    rg = texture( iChannel0, (uv * fract(iTime * 10.0)+ 0.5)/256.0).yx;\n\tret.z = mix( rg.x, rg.y, f.z );\n    \n    return ret;\n}\n\nfloat hash1( float n ){\n    float hash_res1 = fract(sin(n)*43758.5453123+22578.1459123);\n    float hash_res2 = 1.0;//fract(sin(iTime)*22578.1459123+19642.3490423);\n    return hash_res1 * hash_res2;\n}\n\nvec2 hash2( float n ){\n    vec2 hash3_res1 = fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n    vec2 hash3_res2 = vec2(1.0);//fract(sin(vec2(iTime / 173.0, iTime / 97.0))*vec2(22578.1459123,19642.3490423));\n    return normalize(hash3_res1 * hash3_res2);\n}\n\nvec3 hash3( float n ){\n    vec3 hash3_res1 = fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n    vec3 hash3_res2 = vec3(1.0);//fract(sin(vec3(iTime / 13.0, iTime / 173.0, iTime / 97.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n    return normalize(hash3_res1 * hash3_res2);\n}\n\nfloat rand1(vec3 p){\n    vec3 rand = noise3D(p);\n    return rand.x + rand.y + rand.z;\n    //float texCoord = hash1(p.x+p.y+p.z);\n    //return texture(iChannel0, vec2(texCoord, texCoord)).y;\n}\n\nvec3 rand3(vec3 p){\n    vec2 texCoord = hash2(p.x+p.y+p.z);\n    return texture(iChannel0, texCoord).xyz;\n}\n\n\nvec4 correctGamma(vec4 color){\n    float lambda = 5.2;\n    return vec4(pow(color.x, 1.0 / lambda), pow(color.y, 1.0 / lambda), pow(color.z, 1.0 / lambda), color.w);\n}\n\nbool refractFunc(in vec3 v, in vec3 n, in float ni_over_nt, out vec3 refracted){\n    float dt = dot(normalize(v), n);\n    float discreminant = 1.0 - ni_over_nt*ni_over_nt*(1.0-dt*dt);\n    if(discreminant > 0.0){\n        refracted = refract(v, n, ni_over_nt);\n        return true;\n    }\n    return false;\n}\n\nfloat schlick(float cosine, float ref_idx){\n    float r0 = (1.0 - ref_idx) / (1.0 + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1.0-r0) * pow((1.0-cosine), 5.0);\n}\n\nvec3 random_in_unit_disk(in vec2 subSamplePos){\n    return texture(iChannel0, subSamplePos).xyz;\n}\n\n// =======================================================\n// =======================================================\n// === Primitive structures\n// =======================================================\n// =======================================================\n\nstruct Sphere {\n    vec3  center;\n    float radius;\n};\n    \nstruct Plane {\n    vec3 P0;\n    vec3 N;\n};\n\nstruct Ray {\n    vec3  origin;\n    vec3  dir;\n    float t_min;\n    float t_max;\n};\n    \nstruct HitRecord {\n    int   mat_id;  // 0 : for background\n                   // 1 : lambertian\n                   // 2 : metal\n                   // 3 : dielectric\n    float t;\n    vec3 normal;\n    vec3 color;\n    vec3 hitPoint;\n};\n   \n// =======================================================\n// =======================================================\n// === Primitive intersection test functions\n// =======================================================\n// =======================================================\n\nbool intersect_sphere(inout Ray ray, in Sphere sphere, out HitRecord hitRecord){\n    \n    vec3 sphereCenter = sphere.center - ray.origin;\n    \n    float a = dot(ray.dir, ray.dir);\n\tfloat bPrime = -dot(sphereCenter, ray.dir);\n\tfloat c = dot(sphereCenter, sphereCenter) - sphere.radius * sphere.radius;\n\tfloat deltaPrime  = bPrime * bPrime - a * c;\n\n\tif(deltaPrime >= 0.0){\n\t\tfloat t = -bPrime - sqrt(deltaPrime);\n    \n        if(t >= ray.t_min && t <= ray.t_max){\n\t\t    vec3 intersect_point = t * ray.dir;\n\t\t    hitRecord.normal = normalize(intersect_point - sphereCenter);\n            ray.t_max = t;\n            \n            hitRecord.t = t;\n            \n            hitRecord.hitPoint = ray.origin + t * ray.dir;\n            \n            return true;\n        }\n        \n        t = -bPrime + sqrt(deltaPrime);\n    \n        if(t >= ray.t_min && t <= ray.t_max){\n\t\t    vec3 intersect_point = t * ray.dir;\n\t\t    hitRecord.normal = normalize(intersect_point - sphereCenter);\n            ray.t_max = t;\n            \n            hitRecord.t = t;\n            \n            hitRecord.hitPoint = ray.origin + t * ray.dir;\n            \n            return true;\n        }\n\t} \n    \n    return false;\n    \n}\n\nbool intersect_plane(inout Ray ray, in Plane plane, out HitRecord hitRecord) {\n   float t = dot(plane.N, plane.P0 - ray.origin) / dot(plane.N, ray.dir);\n    if(t >= ray.t_min && t <= ray.t_max){\n        ray.t_max = t;\n        hitRecord.t = t;\n        hitRecord.normal = plane.N;\n        hitRecord.hitPoint = ray.origin + t * ray.dir;\n        float distToPlaneCenter = length(plane.P0 - ray.origin + t * ray.dir);\n        int randColorBand = int(distToPlaneCenter);\n        if(randColorBand - 4 * (randColorBand / 4) == 0){\n            hitRecord.color = vec3(1, 1, 1) ;\n        } else {\n            hitRecord.color = vec3(0, 0, 0);\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// =======================================================\n// =======================================================\n// === Scene Description\n// =======================================================\n// =======================================================\n\nbool intersectScene(inout Ray ray, out vec4 color, out HitRecord hitRecord){\n    const vec3 objColor = vec3(0.5, 0.2, 0.4);\n    const vec3 groundColor = vec3(0.1, 0.8, 0.7);\n    const vec3 lightDir = normalize(vec3(1, 1, 1));\n    \n    bool intersect = false;\n    \n    float animLength = 6.14;\n    float t = iTime - float(int(iTime / animLength)) * animLength;\n      \n    Plane background;\n    background.P0 = - vec3(0, 0, 9000);\n    background.N = vec3(0, 0, 1);\n        \n    const int nSpheresDim = 5;\n    const float radius = 75.0;\n    vec3 sphereCenter = vec3(float(-nSpheresDim / 2 - 1) * 2.5 * radius, radius, float(-nSpheresDim / 2) * 2.5 * radius);\n    vec3 translationX = vec3(2.5 * radius, 0.0, 0.0);\n    vec3 translationZ = vec3(0.0, 0.0, 2.5 * radius);\n    \n    Sphere sphere;\n    sphere.center = sphereCenter;\n    sphere.radius = radius;\n    \n    Plane ground;\n    ground.P0 = sphereCenter - vec3(0.0, radius, 0.0);\n    ground.N = vec3(0, 1, 0);\n    \n    for(int j = 0; j < nSpheresDim; j++){\n        sphere.center = sphereCenter + float(j) * translationZ;\n    \tfor(int i = 0; i < nSpheresDim; i++){        \n            int mat_id = 3;\n\n            sphere.center = sphere.center + translationX;\n            if(i + j - 2 * ((i+j) / 2) == 1){\n                mat_id = 2;\n            }\n\n            if(intersect_sphere(ray, sphere, hitRecord)){\n               vec3 reflection_vec = reflect(hitRecord.normal, -lightDir);\n               hitRecord.mat_id = mat_id;\n               hitRecord.color = objColor;\n               //color = vec4(objColor * abs(dot(hitRecord.normal, lightDir)), 1.0);\n               //color = vec4(objColor, 1.0);\n               float ambient  = 0.4;                \n               float diffuse  = (dot(hitRecord.normal, -lightDir));\n               float specular = pow((dot(reflection_vec, -ray.dir)), 100.0);\n               color = vec4(objColor * clamp((diffuse + specular), ambient, 1.0), 1.0);\n               intersect = true;\n            }\n        }\n    }\n    \n    if(intersect_plane(ray, background, hitRecord)){\n        hitRecord.mat_id = 0;\n        hitRecord.color = (ray.dir + vec3(1.0)) / 2.0;\n        color = vec4((ray.dir + vec3(1.0)) / 2.0, 1.0) * vec4(hitRecord.color, 1.0);\n        intersect = true;\n    }\n    \n    if(intersect_plane(ray, ground, hitRecord)){\n        hitRecord.mat_id = 2;\n        hitRecord.color = groundColor;\n        color = vec4(groundColor * dot(hitRecord.color, lightDir), 1.0);\n        intersect = true;\n    }\n    \n    return intersect;\n\t//else fragColor = back_color(fragCoord2d);\n}\n\n    \n// =======================================================\n// =======================================================\n// === Material scattered ray calculation\n// =======================================================\n// =======================================================\n\nbool scatter_lambertian(in Ray rayIn, in HitRecord hitRecord, out Ray scattered_ray){\n    scattered_ray.origin = hitRecord.hitPoint;\n    scattered_ray.dir    = rand3(hitRecord.hitPoint);\n    scattered_ray.t_min  = 1.0;\n    scattered_ray.t_max  = 10000.0;\n    return true;\n}\n\nbool scatter_metalic(in Ray rayIn, in HitRecord hitRecord, in float fuzzy, out Ray scattered_ray){\n    \n    vec3 reflected = reflect(rayIn.dir, hitRecord.normal);\n    reflected += fuzzy * rand3(hitRecord.hitPoint);\n    \n    scattered_ray.origin = hitRecord.hitPoint;\n    scattered_ray.dir    = reflected;\n    scattered_ray.t_min  = 0.2;\n    scattered_ray.t_max  = 10000.0;\n    \n    return true;\n}\n\nbool scatter_dielectric(in Ray rayIn, in HitRecord hitRecord, in float ref_idx, out Ray scattered_ray){\n    \n    vec3 reflected = reflect(rayIn.dir, hitRecord.normal);\n    vec3 refracted;\n    \n    vec3 outward_normal;\n    float ni_over_nt;\n   \n    //attenuation = vec3(1.0);\n    \n    float reflection_prob;\n    float cosine;\n    \n    if(dot(rayIn.dir, hitRecord.normal) > 0.0){\n        outward_normal = -hitRecord.normal;\n        ni_over_nt = ref_idx;\n        cosine = ref_idx * dot(rayIn.dir, hitRecord.normal) / length(rayIn.dir);\n    } else {\n        outward_normal = hitRecord.normal;\n        ni_over_nt = 1.0 / ref_idx;\n        cosine = -dot(rayIn.dir, hitRecord.normal) / length(rayIn.dir);\n    }\n    if(refractFunc(rayIn.dir, outward_normal, ni_over_nt, refracted)){\n        reflection_prob = schlick(cosine, ref_idx);\n    } else {\n        reflection_prob = 1.0;\n    }\n    \n    scattered_ray.origin = hitRecord.hitPoint;\n    scattered_ray.t_min  = 0.2;\n    scattered_ray.t_max  = 10000.0;\n    if(rand1(hitRecord.hitPoint) > reflection_prob){\n        scattered_ray.dir = refracted;\n    } else {\n        scattered_ray.dir = reflected;\n    }\n    \n    return true;   \n}\n\n// =======================================================\n// =======================================================\n// === Different rendering modes\n// =======================================================\n// =======================================================\n\nvoid renderScene(inout Ray primaryRay, out vec4 fragColor){\n    const vec3 lightDir = normalize(vec3(1, 1, 1));\n    const int max_depth = 10;\n    \n    fragColor = vec4(1.0);\n    HitRecord hitRecord;    \n    Ray ray = primaryRay;\n    \n    float attenuation = 1.0;\n    float fuzzy = 0.1;\n    \n    for(int i = 0; i < max_depth; i++){\n\n        vec4 pathColor;\n        if(intersectScene(ray, pathColor, hitRecord) == false){\n            //fragColor *= pathColor;\n            break;\n        }\n\n        fragColor *= attenuation * pathColor;\n        \n        Ray nextRay;\n             if(hitRecord.mat_id == 0)  {} // reserved for background material\n        else if(hitRecord.mat_id == 1)  scatter_lambertian(ray, hitRecord, nextRay);\n        else if(hitRecord.mat_id == 2)  scatter_metalic(ray, hitRecord, fuzzy, nextRay);\n        else if(hitRecord.mat_id == 3)  scatter_dielectric(ray, hitRecord, 3.0, nextRay);\n        ray = nextRay;\n    }\n}\n\nvoid renderWithDiElectricMaterials(inout Ray primaryRay, out vec4 fragColor){\n    const vec3 lightDir = normalize(vec3(1, 1, 1));\n    const int max_depth = 10;\n    \n    fragColor = vec4(1.0);\n    HitRecord hitRecord;    \n    Ray ray = primaryRay;\n    \n    float attenuation = 1.0;\n    \n    for(int i = 0; i < max_depth; i++){\n\n        vec4 pathColor;\n        if(intersectScene(ray, pathColor, hitRecord) == false){\n            //fragColor *= pathColor;\n            break;\n        }\n\n        fragColor *= attenuation * pathColor;\n               \n        Ray nextRay;\n        scatter_dielectric(ray, hitRecord, 1.7, nextRay);\n        ray = nextRay;\n    }\n}\n\nvoid renderWithMetallicMaterials(inout Ray primaryRay, out vec4 fragColor){\n    const vec3 lightDir = normalize(vec3(1, 1, 1));\n    const int max_depth = 10;\n    \n    fragColor = vec4(1.0);\n    HitRecord hitRecord;    \n    Ray ray = primaryRay;\n    \n    float attenuation = 0.5;\n    float fuzzy = 0.1;\n    \n    for(int i = 0; i < max_depth; i++){\n\n        vec4 pathColor;\n        if(intersectScene(ray, pathColor, hitRecord) == false){\n            //fragColor *= pathColor;\n            break;\n        }\n\n        fragColor *= attenuation * pathColor;\n        \n        Ray nextRay;\n        scatter_metalic(ray, hitRecord, fuzzy, nextRay);\n        ray = nextRay;\n    }\n}\n\nvoid renderWithLambertianMaterials(inout Ray primaryRay, out vec4 fragColor){\n    const vec3 lightDir = normalize(vec3(1, 1, 1));\n    const int max_depth = 10;\n    const int numNewSampleForDiffuseMaterials = 1;\n    \n    \n    fragColor = vec4(1.0);\n    HitRecord hitRecord;    \n    Ray ray = primaryRay;\n    \n    vec4 accumColor = vec4(0.0);\n    for(int j = 0; j < numNewSampleForDiffuseMaterials; j++){\n        vec4 pathColor = vec4(1.0);\n        bool hit = false;\n        for(int i = 0; i < max_depth; i++){\n\n            vec4 bounceColor;\n            if(intersectScene(ray, bounceColor, hitRecord) == false){\n                //pathColor *= bounceColor;\n                //fragColor *= pathColor;\n                break;\n            }\n\n            pathColor *= bounceColor;\n\n            Ray nextRay;\n            scatter_lambertian(ray, hitRecord, nextRay);\n            ray = nextRay;\n            hit = true;\n        }\n        \n        if(hit) accumColor += pathColor;\n    }\n    \n    fragColor *= (accumColor / float(numNewSampleForDiffuseMaterials));\n}\n\nvoid renderWithShadow(inout Ray primaryRay, out vec4 fragColor){\n    const vec3 lightDir = normalize(vec3(1, 1, 1));\n    const int max_depth = 10;\n    \n    HitRecord hitRecord;    \n    Ray ray = primaryRay;\n\n    if(intersectScene(ray, fragColor, hitRecord) == false) return;\n    vec3 p = hitRecord.hitPoint;\n        \n    Ray shadowRay;\n    shadowRay.origin = p;\n    shadowRay.dir = lightDir;\n    shadowRay.t_min = 0.2;\n    shadowRay.t_max = 10000.0;\n        \n    HitRecord shadowRayHitRecord;\n    vec4 ShadowRayFragColor;\n    if(intersectScene(shadowRay, ShadowRayFragColor, shadowRayHitRecord) == true){\n       //fragColor = vec4(1, 1, 1, 1);\n       fragColor = vec4(0, 0, 0, 1);\n    }\n}\n\nvoid render(inout Ray primaryRay, out vec4 fragColor) {\n#ifdef RENDER_WITH_SHADOWS\n    renderWithShadow(primaryRay, fragColor);\n#elif defined  RENDER_WITH_LAMBERTIAN_MATERIALS\n    renderWithLambertianMaterials(primaryRay, fragColor);\n#elif defined  RENDER_WITH_METALIC_MATERIALS\n    renderWithMetallicMaterials(primaryRay, fragColor);\n#elif defined RENDER_WITH_DIELECTRIC_MATERIALS\n    renderWithDiElectricMaterials(primaryRay, fragColor);\n#elif defined RENDER_SCENE_DIFFERENT_MATERIALS\n    renderScene(primaryRay, fragColor);\n#endif\n    \n    // gamma correcting\n    fragColor = correctGamma(fragColor);\n}\n\n// =======================================================\n// =======================================================\n// === Main functions for fragment shaders for Image/VR\n// =======================================================\n// =======================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord2d )\n{\n    fragColor = vec4(0.0);\n    \n    \n    Ray ray;\n    ray.t_min = 0.0;\n    ray.t_max = 1000000.0; \n\n    vec3 origin = vec3(0.0, 300.0, 700.0);\n#ifdef FIXED_CAMERA\n    origin += vec3(450.0, 200.0, -100.0);\n#else\n    origin += vec3(500.0*sin(iTime), 0, 500.0*cos(iTime));\n#endif\n    vec3 lookat = vec3(0.0, 100.0, 0.0);\n    const float viewPlaneDistance = 1.0;\n    const float fov   = PI / 2.0;\n    float aspectRatio = float(iResolution.x) / float(iResolution.y);\n    float halfHeight = tan(fov / 4.0);\n    float halfWidth  = aspectRatio * halfHeight;\n\n    vec3 w = normalize(lookat - origin);\n    vec3 u = normalize(cross(vec3(0.0, 1.0, 0.0), w));\n    vec3 v = normalize(cross(w, u));\n    \n    float aperture    = 70.0;\n    float lens_radius = aperture / 2.0;\n    float focalDist   = 1.0 * length( lookat - origin );\n    \n    vec3 lowerLeftCorner = origin + vec3(focalDist) * (-halfWidth*u-halfHeight*v+viewPlaneDistance*w);\n        \n    const int numSubSampleX = 4;\n    const int numSubSampleY = 4;\n    \n    for(int i = 0; i < numSubSampleX; i++)\n        for(int j = 0; j < numSubSampleY; j++){\n            vec2 subSamplePos = vec2(float(i+1) / float(numSubSampleX+1), float(j+1) / float(numSubSampleY+1));\n            subSamplePos = 2.0 * subSamplePos - 1.0;\n\n            vec2 normalizedCoords = (fragCoord2d + subSamplePos) / iResolution.xy;\n            vec3 fragCoord = lowerLeftCorner + 2.0 * focalDist * (u * normalizedCoords.x * halfWidth + v * normalizedCoords.y * halfHeight);\n           \n#ifdef DEPTH_OF_FIELD\n            vec3 rd = lens_radius * random_in_unit_disk(subSamplePos);\n            vec3 offset = u * rd.x + v * rd.y;\n#else\n            vec3 offset = vec3(0.0);\n#endif\n            ray.origin = origin + offset;            \n    \t\tray.dir = normalize(fragCoord - ray.origin);\n            \n            vec4 sampleColor;\n            render(ray, sampleColor);\n            fragColor += sampleColor;\n        }\n    fragColor /= float(numSubSampleX * numSubSampleY);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}