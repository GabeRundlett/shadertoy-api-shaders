{
    "Shader": {
        "info": {
            "date": "1542235672",
            "description": "Coded live on twitch stream in Bonzomatic, and tidied/ported to shadertoy.\nUnedited Bonzomatic shader here: [url]https://gist.github.com/willkirkby/a29771548a7d7ca931b83c5c15bff83b[/url]\nMade in recognition of Desert Bus For Hope.",
            "flags": 0,
            "hasliked": 0,
            "id": "4tVBDz",
            "likes": 23,
            "name": "[twitch] Desert Bus",
            "published": 3,
            "tags": [
                "twitch",
                "desertbus"
            ],
            "usePreview": 0,
            "username": "yx",
            "viewed": 4764
        },
        "renderpass": [
            {
                "code": "const float pi = acos(-1.);\nconst float SPEED = 3.;\nconst float BUSSTOP_WAVELENGTH = 1000.;\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) - r\n        + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdCylinder(vec3 p, float r)\n{\n    return length(p.xy) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, float r, float h, float steer)\n{\n    p.xz = rotate(p.xz, steer);\n    return max(sdCylinder(p, r), abs(p.z)-h);\n}\n\nfloat bettersin(float a)\n{\n    return sin(a*pi*2.-.5*pi)*.5+.5;\n}\n\nvec2 steering(float time)\n{\n    time = mod(time, 8.);\n    float t;\n    if (time < 7.)\n        t = (time / 7.);\n    else\n        t = 1.-(time-7.);\n    return vec2(\n        smoothstep(0.,1.,t)*2.-1.,\n        time>7.?bettersin(t)*.5:0.\n    );\n}\n\nfloat shadowscene(vec3 p)\n{\n    vec2 steer = steering(iTime);\n\n    vec3 bp = p;\n    bp.y += sin(iTime*10.)*.03;\n    bp.z += steer.x;\n    float bus = sdRoundBox(bp-vec3(0,-.1,0), vec3(4.,.8,1)-.1, .3);\n\n    float ground = p.y + 1.5;\n    ground = max(ground, length(p+vec3(0,1.5,0))-7.);\n\n    return min(bus, ground);\n}\n\nvec2 scene(vec3 p)\n{\n    vec2 steer = steering(iTime);\n\n    vec3 bp = p;\n    bp.y += sin(iTime*10.)*.03;\n    bp.z += steer.x;\n    float bus = sdRoundBox(bp-vec3(0,-.1,0), vec3(4.,.8,1)-.1, .3);\n    bus = max(bus, -sdCylinder(bp - vec3(3,-1,0), .5));\n    bus = max(bus, -sdCylinder(bp - vec3(-3,-1,0), .5));\n    bus = max(bus, -sdCylinder(bp - vec3(-2,-1,0), .5));\n\n    vec3 wp = p;\n    wp.z += steer.x;\n    wp.z = abs(wp.z);\n    wp.z -= 1.;\n    float wheels = 1000.;\n    wheels = min(wheels, sdCappedCylinder(wp - vec3( 3,-1,0), .4, .2, steer.y));\n    wheels = min(wheels, sdCappedCylinder(wp - vec3(-3,-1,0), .4, .2, 0.));\n    wheels = min(wheels, sdCappedCylinder(wp - vec3(-2,-1,0), .4, .2, 0.));\n\n    float hubcaps = 1000.;\n    hubcaps = min(hubcaps, sdCappedCylinder(wp - vec3( 3,-1,0), .17, .3, steer.y));\n    hubcaps = min(hubcaps, sdCappedCylinder(wp - vec3(-3,-1,0), .17, .3, 0.));\n    hubcaps = min(hubcaps, sdCappedCylinder(wp - vec3(-2,-1,0), .17, .3, 0.));\n\n    float windows = sdRoundBox(bp - vec3(4,.1,0), vec3(.8,.3,.8), .1);\n    windows = min(windows, sdRoundBox(bp - vec3(2.8 +bp.y*.7,.1,0), vec3(.5,.3,2), .1));\n    windows = min(windows, sdRoundBox(bp - vec3(1.4 +bp.y*.7,.1,0), vec3(.5,.3,2), .1));\n    windows = min(windows, sdRoundBox(bp - vec3(     bp.y*.7,.1,0), vec3(.5,.3,2), .1));\n    windows = min(windows, sdRoundBox(bp - vec3(-1.4+bp.y*.7,.1,0), vec3(.5,.3,2), .1));\n    windows = min(windows, sdRoundBox(bp - vec3(-2.8+bp.y*.7,.1,0), vec3(.5,.3,2), .1));\n\n    float ground = p.y + 1.5;\n    ground = max(ground, length(p+vec3(0,1.5,0))-7.);\n\n    vec3 bsp = p;\n    float bst = mod(iTime*SPEED*5., BUSSTOP_WAVELENGTH)-BUSSTOP_WAVELENGTH*.5;\n    float busstop = sdCappedCylinder(bsp.xzy+vec3(bst,4.2,.5), .05, 1., 0.);\n    busstop = min(busstop, sdCappedCylinder(bsp.yzx+vec3(-.9,4.2,bst), .4, .05, 0.));\n    busstop = max(busstop, sdCylinder(bsp.xzy, 7.));\n\n    float mat = 0.;\n    float best = 1000.;\n    if (ground < best) { mat = 1.; best = ground; }\n    if (bus < best) { mat = 2.; best = bus; }\n    if (wheels < best) { mat = 3.; best = wheels; }\n    if (busstop < best) { mat = 5.; best = busstop; }\n\n    if (mat == 2. && windows < bus)\n        mat = 4.;\n\n    if (mat == 3. && hubcaps < wheels)\n        mat = 2.;\n\n    return vec2(\n        best,\n        mat\n    );\n}\n\nfloat sdCircle(vec2 uv, float r)\n{\n    return length(uv)-r;\n}\n\nfloat sceneLRR(vec2 uv)\n{\n    uv.y -= .3;\n    float circles = min(\n        min(\n            sdCircle(uv+vec2(.14,0), .033),\n            sdCircle(uv+vec2(.24,0), .033)\n        ),\n        min(\n            sdCircle(uv+vec2(.34,0), .033),\n            sdCircle(uv+vec2(-.03,0), .1)\n        )\n    );\n    uv.y = abs(uv.y);\n    float chevron = dot(vec3(uv,1),vec3(1,2.3,-.4));\n    chevron = max(.1-uv.x, chevron);\n    chevron = max(-sdCircle(uv+vec2(-.05,0), .15), chevron);\n\n    return min(chevron, circles);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-15);\n    vec3 dir = normalize(vec3(uv,1));\n\n    cam.yz = rotate(cam.yz, .3);\n    dir.yz = rotate(dir.yz, .3);\n\n    cam.xz = rotate(cam.xz, pi/3.);\n    dir.xz = rotate(dir.xz, pi/3.);\n\n    float t=0.;\n    vec2 k=vec2(0);\n    for(int i=0;i<100;++i)\n    {\n        k=scene(cam+dir*t);\n        t+=k.x;\n        if (k.x<.001)\n            break;\n    }\n    vec3 h = cam+dir*t;\n    vec2 o = vec2(.01, 0);\n    vec3 n = normalize(vec3(\n        scene(h+o.xyy).x-scene(h-o.xyy).x,\n        scene(h+o.yxy).x-scene(h-o.yxy).x,\n        scene(h+o.yyx).x-scene(h-o.yyx).x\n    ));\n    out_color.rgb = n*.5+.5;\n    //out_color.rgb = fract(h);\n\n    if (k.x > 1.)\n        k.y = 0.;\n\n    float fakeAO = shadowscene(h+n*.8)/.8;\n    fakeAO = clamp(fakeAO, 0., 1.) * .4 + .6;\n\n\n    vec3 albedo = vec3(1);\n    float mat = k.y;\n    if (mat == 0.)\n    { // sky\n        float d = sceneLRR(uv);\n        vec3 light = vec3(.4,.6,1);\n        vec3 dark  = vec3(.1,0,.6);\n        out_color.rgb = mix(light, dark, smoothstep(-.001, .001, d));\n        return;\n    }\n    else if (mat == 1.)\n    { // ground\n        h.z = abs(h.z);\n\n        albedo = vec3(.9, .6, 0);\n\n        if (h.z < 3.2 && h.y > -1.6)\n            albedo = vec3(.4);\n        else if (h.z < 4. && h.y > -1.6)\n            albedo = vec3(.6,.4,0);\n\n            if (h.z < .3 && fract(h.x*.2+iTime*SPEED) < .5 && h.y > -1.6)\n                albedo = vec3(1,.9,.2);\n            }\n    else if (mat == 2.)\n    { // bus\n        albedo = vec3(.7,.8,.9);\n    }\n    else if (mat == 3.)\n    { // wheels\n        albedo = vec3(.1);\n    }\n    else if (mat == 4.)\n    { // windows\n        albedo = vec3(.1);\n    }\n    else if (mat == 5.)\n    { // busstop\n        albedo = h.y > .5 ? vec3(1,0,0) : vec3(.8);\n    }\n\n    float light = dot(n, normalize(vec3(2,3,1)))*.5+.5;\n\n    out_color.rgb = albedo * light * fakeAO;\n\n    //out_color = vec4(step(screenUV.y, steering(screenUV.x * 8)));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}