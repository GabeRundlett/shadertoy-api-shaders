{
    "Shader": {
        "info": {
            "date": "1472237257",
            "description": "The cars accept speed only if safe space allows it.\nUse mouse to initiate a local traffic breaks, release, then observe jamming structures.\nNote that random tuning of cars (bufA flag)  also induces traffic fluctuations.\nNB: cars are twice too large.",
            "flags": 32,
            "hasliked": 0,
            "id": "XlcGWl",
            "likes": 21,
            "name": "traffic jam simulator",
            "published": 3,
            "tags": [
                "simulation",
                "circulation"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1840
        },
        "renderpass": [
            {
                "code": "// attention: change flags accordingly in BufA.\n\n#define NB_CARS (16.*S)       // number of cars per driving line\n#define  S   1.               // scale.    1: 1 pixel = 1m (for window height = 300), \n\n#define LINE0 30.             // first and last driving lines to display (every 10)\n#define LINE1 100.\n\nfloat VMAX = 130./3.6;        // maximum speed ( 130 km/h -> 130/3.6 )\n//#define sR 1.               // road shape (via scaling)\n#define sR vec2(2,1)\n\n#define T(x,y) texture(iChannel0,(.5+vec2(x,y))/R)              // car data\n\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    vec2 R = iResolution.xy,\n    M = (iMouse.xy-R/2.) * 300./R.y;\n    U = (U-R/2.)         * 300./R.y;\n    O -= O;\n  //O += smoothstep(1.,0.,abs(length(U/sR)-LINE0+5.));\n  \n    if ( iMouse.z>0. && length(U-M) < 50. ) O.x = .5;             // Mouse influence area\n\n    // --- splat vehicles\n    \n    float y = length(U/sR)+5.;                                    // driving line at U\n    if ( y<LINE0-1. || y > LINE1+1. ) return;\n    y = 10.*floor(y/10.);\n    {\n  //for (float y=LINE0; y<LINE1; y+=10.)  {                       // foreach line\n        for (float x=0.; x<NB_CARS; x++) {                        // foreach car on the line\n            vec2 C = T(x,y).xy,\n                 P = y * sin( C.x + vec2(1.57,0)) *sR;            // car position\n            float l = length(P-U)*S;\n            if (l<4.5) O +=  smoothstep(4.4,4., l)                // car sprite\n                      //   * (.5+.5*cos(x+y+vec4(0,2.1,-2.1,0))); // car color: random\n                           * vec4(1,vec3(C.y/VMAX));              // car color: speed\n        }\n        O += .5*smoothstep(1.,0.,abs(length(U/sR)-y-5.));         // borders of driving lines\n        O += .5*smoothstep(1.,0.,abs(length(U/sR)-y+5.));\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// attention: change flags accordingly in Image.\n\n#define NB_CARS (16.*S)\n#define  S   1.             // scale. 1: 1 pixel = 1m (for window height=300), \n\n#define RANDOM 1            // 1: each car has different A, VMAX and initPos\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n\nfloat \n  //DT = 1./60.,            // 1 frame = 1/60s\n    DT = iTimeDelta,\n    D0 = 5.,                // minimum distance\n    VMAX = 130./3.6,        // maximum speed ( 130 km/h -> 130/3.6 )\n    A = 100./3.6/9.,        // acceleration ( 0 to 100 km/h in 9\" -> 100/3.6/9 )\n    K3 = 1.66,              // safe space factor ( 10m at VMAX -> 10/sqrt(VMAX) )\n    mR = 50.;               // Mouse influence radius   \n#define sR vec2(2,1)        // road shape (via scaling). If circle, lR can simplifies.\n#define lR length( sin(O.x+vec2(1.57,0)) / sR )\n//#define lR 1.             // road shape (via scaling)\n\n#define T(i) texture(iChannel0,vec2(mod(U.x+i,NB_CARS),U.y)/R)\n#define PI 3.1415927\n\n    vec2 R = iResolution.xy;\n\n    if (iFrame==0) { // --- initialization of vehicles\n#if RANDOM\n        O = fract(4567.*sin(vec4(1234,-13.17,112, 1e5)*dot(U,vec2(1,.01754))));\n        O.x *= 6.283;       // O.x = angle; O.y = speed. U.y*R = radius. \n        O.y = 0.;\n        O.z = 1. + .1*(2.*O.z-1.); // O.z = acceleration fluctuation\n        O.a = 1. + .1*(2.*O.z-1.); // O.a = VMAX fluctuation\n#else\n        O.x = U.x/NB_CARS * 6.283;\n        O.y = 0.;\n        O.z = O.a = 1.;\n#endif\n        return; \n      }\n     \n    O = T(0.); // current car data\n    \n    // --- calc distance to closest obstacle\n    float d = 1e9, a;\n    for (float i=1.; i<NB_CARS; i++) { \n        a = T(i).x-O.x; if ( a < -PI ) a += 2.*PI; // ( accounts for angle wrapping\n        if ( a > 0. ) d = min(d,a);      \n    }\n    d *= U.y*lR*S; // convert angle to length\n    \n    // --- adjust speed to free space (different models)\n  // d -=  D0 + K1*O.y*O.y;  // compare to safe distance func(speed)\n  // d -=  D0 + K2*O.y; \n     d -=  D0 + K3*sqrt(O.y); \n    if ( d > 0. ) {    // enough space to accelerate\n        if (O.y < VMAX*O.a) O.y += DT * A*O.z;\n    }\n    else if ( d < 0. ) // too close: breaks (different models)\n         O.y *= pow(.9,DT*60.); // *= .9, adapted to other DT than 1/60\n      // O.y = max(0., O.y-A*DT);\n      // O.y = sqrt(-d/K); \n\n    // --- Mouse creates traffic jam\n    vec2 P = U.y * sin( O.x + vec2(1.57,0)) *sR,\n         M = (iMouse.xy-R/2.) * 300./R.y;\n\tif ( iMouse.z>0. && length(P-M) < 50. ) O.y *= .9;\n        \n    // --- moves     \n    O.x = mod (O.x + DT* O.y/(U.y*lR*S), 2.*PI);   // convert to angle and wrap\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}