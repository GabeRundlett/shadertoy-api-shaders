{
    "Shader": {
        "info": {
            "date": "1493824233",
            "description": "Doesn't do much...",
            "flags": 0,
            "hasliked": 0,
            "id": "ldScDV",
            "likes": 17,
            "name": "Machinery",
            "published": 3,
            "tags": [
                "raymarch",
                "raytrace",
                "machine"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 653
        },
        "renderpass": [
            {
                "code": "// \"Machinery\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrOBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrFlatCylAnDf (vec3 p, float b, float r, float w, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\n\nconst float pi = 3.14159;\n\n#define NBLK 12.\n\nvec3 lbPos, vnBlk;\nvec2 qBlk;\nfloat dstFar, tCur, bEdge, tCyc;\nint idObj;\nbool doSh;\nconst int idGr = 1, idPln = 2, idConv = 3, idSup = 4, idAx = 5, idBas = 6,\n   idWhl = 7, idSpl = 8, idBl = 9;\n\nfloat GearWlDf (vec3 p, float rad, float wlThk, float tWid, float nt, float aRot, \n   bool bev, float dMin)\n{\n  vec3 q;\n  float d, s;\n  q = p;\n  d = max (length (q.xy) - rad, abs (q.z) - wlThk);\n  if (d < dMin) {\n    q.xy = Rot2D (q.xy, aRot);\n    q.xy = Rot2D (q.xy, floor (nt * atan (q.y, - q.x) / (2. * pi) + 0.5) *\n       2. * pi / nt);\n    if (bev) q.xy *= 1.2 - 0.2 * q.z / wlThk;\n    s = q.x - 2. * clamp (1.5 * tWid + 0.5 * q.x * step (0., q.x) - abs (q.y),\n      0., tWid);\n    d = max (d, - rad - 0.95 * s);\n  }\n  return min (dMin, d);\n}\n\nvec4 BPos (float t)\n{\n  vec3 p;\n  float a;\n  t = mod (t, tCyc);\n  if (t < 5.) {\n    a = 0.;\n    p = vec3 (-1.018 + 2.118 * t / 5., bEdge, 0.);\n  } else if (t < 10.) {\n    a = 0.5 * pi * (t - 5.) / 5.;\n    p = vec3 (1.1, bEdge + 1. * sin (a), 1. - 1. * cos (a));\n  } else if ( t < 15.) {\n    a = 0.5 * pi;\n    p = vec3 (1.1 - 2.118 * (t - 10.) / 5., 1. + bEdge, 1.);\n  } else if (t < 17.5) {\n    a = 0.5 * pi;\n    p = vec3 (-1.018, 1. + bEdge, 1. - 1. * (t - 15.) / 2.5);\n  } else {\n    t -= 17.5;\n    a = -0.5 * pi * t;\n    p = vec3 (-1.018, 1. + bEdge - t * t, 0.);\n  }\n  return vec4 (p, a);\n}\n\nfloat GearDf (vec3 p)\n{\n  vec3 q;\n  float dMin, angRot, wlThk, tWid, nt, rad;\n  dMin = dstFar / 0.3;\n  angRot = 0.1 * pi * tCur;\n  rad = 0.3;\n  wlThk = rad / 7.;\n  tWid = rad / 10.;\n  nt = 20.;\n  dMin = GearWlDf (- (p - vec3 (-1.05, -0.21, 1.3)), rad, wlThk, tWid, nt,\n     angRot, true, dMin);\n  dMin = GearWlDf ((p - vec3 (-1.05 + 0.85 * rad, -0.21, 1.3 + 0.85 * rad)).yzx,\n     rad, wlThk, tWid, nt, angRot + pi / nt, true, dMin);\n  angRot = -0.1 * pi * tCur;\n  rad = 0.39;\n  wlThk = rad / 15.;\n  tWid = rad / 16.;\n  nt = 36.;\n  dMin = GearWlDf ((p - vec3 (0.1, bEdge, 1.)).yzx, rad, wlThk, tWid, nt,\n     angRot, false, dMin);\n  dMin = GearWlDf (- (p - vec3 (0.1, -0.21, 1.555)).zyx, rad * 2./3., wlThk, tWid,\n     nt * 2./3., angRot * 3./2., false, dMin);\n  return dMin * 0.3;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 a4;\n  vec3 q, bPos;\n  float dMin, d, angRot, r, a;\n  dMin = dstFar;\n  q = p - vec3 (1.13 + bEdge, bEdge, 1.);\n  r = length (q.yz);\n  q.yz = Rot2D (q.yz, -0.5 * pi * tCur / 5.);\n  a = (r > 0.) ? atan (q.z, - q.y) / (2. * pi) : 0.;\n  q.yz = Rot2D (q.yz, 2. * pi * (floor (8. * a + 0.5)) / 8.);\n  q.z = abs (q.z);\n  d = max (min (min (abs (r - 1.01) - 0.1, r - 0.3),\n     max (r - 1., dot (q.yz, vec2 (sin (0.8 * 2. * pi / 32.),\n     cos (0.8 * 2. * pi / 32.))))), abs (q.x) - 0.03);\n  if (d < dMin) { dMin = d;  idObj = idWhl; }\n  d = PrOBoxDf (p - vec3 (0., 0.98, 1.), vec3 (1.12, 0.02, 0.1));\n  d = min (d, PrOBoxDf (p - vec3 (-1.018, 0.98, 0.5), vec3 (0.1, 0.02, 0.5 - bEdge)));\n  if (d < dMin) { dMin = d;  idObj = idPln; }\n  d = PrFlatCylAnDf (p - vec3 (-0.05, -0.21, 0.), 1., 0.2, 0.01, 0.1);\n  if (d < dMin) { dMin = d;  idObj = idConv; }\n  q = p - vec3 (-0.05, -0.21, 0.);\n  q.x = abs (q.x) - 1.;\n  d = PrCylDf (q, 0.19, 0.12);\n  if (d < dMin) { dMin = d;  idObj = idSpl; }\n  q = p - vec3 (0.65, -0.14, 1.);\n  q.x = abs (q.x) - 0.3;\n  d = PrRoundBoxDf (q, vec3 (0.01, 1.08, 0.06), 0.02);\n  q = p - vec3 (-0.05, -0.68, 0.);\n  q.xz = abs (q.xz) - vec2 (1., 0.2);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.04, 0.55, 0.01), 0.02));\n  d = min (d, PrRoundBoxDf (p - vec3 (-1.05, -0.14, 1.),\n     vec3 (0.04, 1.08, 0.01), 0.02));\n  q = p - vec3 (-0.33, -0.68, 1.555);\n  q.x = abs (q.x) - 0.3;\n  d = min (d, PrRoundBoxDf (q, vec3 (0.01, 0.55, 0.04), 0.02));\n  if (d < dMin) { dMin = d;  idObj = idSup; }\n  q = p - vec3 (0.65, bEdge, 1.);\n  d = PrCylDf (q.yzx, 0.04, 0.62);\n  d = min (d, PrCylDf (p - vec3 (0.95, -0.21, 0.), 0.03, 0.27));\n  d = min (d, min (d, PrCylDf (p - vec3 (-1.05, -0.21, 0.55), 0.03, 0.82)));\n  d = min (d, PrCylDf ((p - vec3 (-0.36, -0.21, 1.555)).yzx, 0.03, 0.51));\n  if (d < dMin) { dMin = d;  idObj = idAx; }\n  d = PrOBoxDf (p - vec3 (0., -1.2, 0.9), vec3 (1.6, 0.05, 1.4));\n  if (d < dMin) { dMin = d;  idObj = idBas; }\n  if (! doSh) {\n    d = PrSphDf (p - lbPos, 0.04);\n    if (d < dMin) { dMin = d;  idObj = idBl; }\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat GearRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 250; j ++) {\n    d = GearDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 GearNf (vec3 p)\n{\n  const vec3 e = vec3 (0.0005, -0.0005, 0.);\n  vec4 v = vec4 (GearDf (p + e.xxx), GearDf (p + e.xyy),\n     GearDf (p + e.yxy), GearDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.0005, -0.0005, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat BlkHit (vec3 ro, vec3 rd)\n{\n  vec4 a4;\n  vec3 rm, rdm, u, v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  for (float k = 0.; k < NBLK; k ++) {\n    a4 = BPos (tCur + tCyc * k / NBLK);\n    rm = ro - a4.xyz;\n    rdm = rd;\n    rm.zy = Rot2D (rm.zy, a4.w);\n    rdm.zy = Rot2D (rdm.zy, a4.w);\n    v = rm / rdm;\n    tp = bEdge / abs (rdm) - v;\n    tm = - tp - 2. * v;\n    dn = max (max (tm.x, tm.y), tm.z);\n    df = min (min (tp.x, tp.y), tp.z);\n    if (df > 0. && dn < min (df, dMin)) {\n      dMin = dn;\n      vnBlk = - sign (rdm) * step (tm.zxy, tm) * step (tm.yzx, tm);\n      u = (v + dn) * rdm;\n      qBlk = vec2 (dot (u.zxy, vnBlk), dot (u.yzx, vnBlk));\n      vnBlk.zy = Rot2D (vnBlk.zy, - a4.w);\n    }\n  }\n  return dMin;\n}\n\nfloat BlkHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec4 a4;\n  vec3 rm, rdm, v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  for (float k = 0.; k < NBLK; k ++) {\n    a4 = BPos (tCur + tCyc * k / NBLK);\n    rm = ro - a4.xyz;\n    rdm = rd;\n    rm.zy = Rot2D (rm.zy, a4.w);\n    rdm.zy = Rot2D (rdm.zy, a4.w);\n    v = rm / rdm;\n    tp = bEdge / abs (rdm) - v;\n    tm = - tp - 2. * v;\n    dn = max (max (tm.x, tm.y), tm.z);\n    df = min (min (tp.x, tp.y), tp.z);\n    if (df > 0. && dn < min (df, dMin)) dMin = dn;\n  }\n  return smoothstep (0., rng, dMin);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 50; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.03 + 0.03 * d;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nfloat GearSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 30; j ++) {\n    h = GearDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.05;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nfloat GlowCol (vec3 ro, vec3 rd, float dstHit)\n{\n  vec3 ld;\n  float d, wGlow;\n  wGlow = 0.;\n  ld = lbPos - ro;\n  d = length (ld);\n  ld /= d;\n  if (d < dstHit) wGlow += pow (max (dot (rd, ld), 0.), 1024.);\n  return clamp (0.5 * wGlow, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 roo, ltDir, vn, col, q;\n  float dstObj, dstGear, dstBlk, spec, sh, s, r, a;\n  int idObjT;\n  bool isLit, isBg;\n  tCyc = 18.5;\n  bEdge = 0.08;\n  spec = 0.1;\n  doSh = false;\n  dstObj = ObjRay (ro, rd);\n  idObjT = idObj;\n  isLit = true;\n  isBg = false;\n  roo = ro;\n  dstGear = GearRay (ro, rd);\n  if (dstGear < min (dstObj, dstFar)) {\n    dstObj = dstGear;\n    idObj = idGr;\n  } else idObj = idObjT;\n  dstBlk = BlkHit (ro, rd);\n  if (dstBlk < min (dstObj, dstFar)) {\n    dstObj = dstBlk;\n    ro += rd * dstObj;\n    vn = vnBlk;\n    col = vec3 (1., 0., 0.);\n    qBlk = abs (qBlk);\n    if (max (qBlk.x, qBlk.y) > 0.8 * bEdge) {\n      col = vec3 (0.9);\n      spec = 0.5;\n    }\n  } else if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    idObjT = idObj;\n    if (idObj == idGr) vn = GearNf (ro);\n    else vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj == idWhl) {\n      col = vec3 (0.9, 0.7, 0.3);\n      q = ro - vec3 (1.1 + bEdge + 0.03, bEdge, 1.);\n      r = length (q.yz);\n      q.yz = Rot2D (q.yz, -0.5 * pi * tCur / 5.);\n      a = (r > 0.) ? atan (q.z, - q.y) / (2. * pi) : 0.;\n      a = mod (64. * a + 0.5, 1.);\n      if (r > 0.99) vn.yz = Rot2D (vn.yz, - sin (a - 0.5));\n      if (r > 0.92) col *= 0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.01, a);\n      spec = 0.5;\n    } else if (idObj == idGr) {\n      col = vec3 (0.8, 0.7, 0.3);\n      spec = 0.5;\n    } else if (idObj == idSpl) {\n      if (abs (ro.z) > 0.1) {\n        col = vec3 (0.8, 0.8, 0.85);\n        spec = 0.5;\n      } else col = vec3 (0.4, 0.4, 0.3);\n    } else if (idObj == idAx) {\n      col = vec3 (0.8, 0.8, 0.85);\n      spec = 0.5;\n    } else if (idObj == idPln) {\n      col = (abs (vn.y) > 0.99) ? vec3 (0.5, 0.7, 0.2) : vec3 (0.5, 0.2, 0.7);\n      spec = 0.;\n    } else if (idObj == idConv) {\n      q = ro - vec3 (-0.05, -0.21, 0.);\n      col = vec3 (0.8, 0.8, 0.2);\n      if (abs (q.x) < 1. && abs (vn.y) > 0.99 && sign (vn.y) != sign (q.y))\n         col *= 1. - 0.9 * SmoothBump (0.45, 0.55, 0.03,\n         mod (10. * (q.x - sign (q.y) * mod (tCur, 20.) * 2.1 / 5.), 1.));\n    } else if (idObj == idSup) {\n      col = vec3 (0.6, 0.4, 0.4);\n    } else if (idObj == idBas) {\n      q = ro;\n      q.z -= 0.9;\n      q.xz = abs (q.xz) - vec2 (1.55, 1.35);\n      col = (max (q.x, q.z) > 0.) ? vec3 (0.2, 0.1, 0.) : vec3 (0., 0.1, 0.05);\n      spec = 0.;\n    } else if (idObj == idBl) {\n      col = (0.7 + 0.5 * dot (rd, normalize (lbPos - ro))) * vec3 (1., 1., 0.7);\n      isLit = false;\n    }\n  } else isBg = true;\n  if (! isBg) {\n    if (isLit) {\n      ltDir = normalize (lbPos - ro);\n      doSh = true;\n      sh = min (ObjSShadow (ro, ltDir), GearSShadow (ro, ltDir));\n      sh = 0.5 + 0.5 * min (sh, BlkHitSh (ro + 0.01 * ltDir, ltDir, 5.));\n      col = col * (0.05 + 0.1 * max (vn.y, 0.) + 0.1 * max (- dot (vn, ltDir), 0.) +\n         0.9 * sh * max (dot (vn, ltDir), 0.)) +\n         spec * sh * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    } \n  } else col = vec3 (0., 0., 0.05) * (1. + 0.9 * rd.y);\n  col = mix (col, vec3 (0.7, 0.7, 0.4), GlowCol (roo, rd, dstObj));\n  col = pow (clamp (col, 0., 1.), vec3 (0.7));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 30.;\n  az = 0.;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  } else {\n    az += 3. * pi * sin (0.01 * pi * tCur);\n    el += 0.17 * pi * sin (0.07 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, 0.4 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 4.));\n  ro = vuMat * vec3 (0., 0., -8.);\n  ro.z += 0.9;\n  lbPos = vec3 (1.8 * cos (0.4 * tCur), 2.5 + 0.3 * sin (0.3 * tCur),\n     0.9 + 1.6 * sin (0.4 * tCur));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrOBoxDf (vec3 p, vec3 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylAnDf (vec3 p, float b, float r, float w, float h)\n{\n  p.x -= b * clamp (p.x / b, -1., 1.);\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}