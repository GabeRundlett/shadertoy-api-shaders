{
    "Shader": {
        "info": {
            "date": "1642433370",
            "description": "private test for montlhy art",
            "flags": 0,
            "hasliked": 0,
            "id": "ssfyzX",
            "likes": 4,
            "name": "Dancing lights",
            "published": 3,
            "tags": [
                "dancinglights"
            ],
            "usePreview": 0,
            "username": "fzy",
            "viewed": 230
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - iResolution.xy*0.5 ) / iResolution.y;\n    //uv /= iResolution.x;\n\n    float time = mod(iTime, 117.);\n\n    if (time < 22.)\n        fragColor = rosace(iResolution, uv, time);\n    else if (time < 41.)\n        fragColor = lines(iResolution, uv, time - 22.);\n    else\n        fragColor = circles(iResolution, uv, time - 41.);\n    //fragColor = circles(iResolution, uv, iTime);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Function to calculate distance\nfloat distance2(vec2 v1, vec2 v2)\n{\n    return pow(v2.x - v1.x, 2.) + pow(v2.y - v1.y, 2.);\n}\n\nfloat cross2(vec2 pc, vec2 p1, vec2 p2)\n{\n    float dxc = pc.x - p1.x;\n    float dyc = pc.y - p1.y;\n\n    float dxl = p2.x - p1.x;\n    float dyl = p2.y - p1.y;\n\n    return dxc * dyl - dyc * dxl;\n}\n\nconst int   count = 45;\n\nvec4 circles(vec3 iResolution, vec2 uv, float iTime)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // vec2 coord = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.3*cos(iTime+uv.xyx+vec3(0,2,4));\n\n\n\tvec2 center = iResolution.xy/2.;\n\n    // Time varying pixel color\n     vec3 color = vec3(0.0);\n\n    for(int i = 0; i < count; i++)\n    {\n       float originalRadius = iTime/10.;// * 3. / 200.;\n       float rad = radians(360.0 / float(count)) * float(i) + iTime;\n\n       if (iTime > 45.)\n       {\n           //radius = max(0., 60. - iTime) / 100.;\n       }\n\n       float flatness = 1.;\n       if (iTime > 25.)\n       {\n           flatness = max(0., (45. - iTime) / 20.);\n       }\n\n       //if (iTime > 45.)\n       //{\n       //   time = 60.- iTime;\n       //    if (flatness == 0.)\n       //        flatness = cos(rad);\n       //    flatness = flatness * min(1., (iTime - 45.) / 15.);\n       //}\n\n        for (int nbCircle = 0; nbCircle < 10; nbCircle++)\n        {\n            float time = iTime;\n           if (iTime > 45.)\n               time = 60.- iTime;\n            float radius = time / 100. * float(nbCircle);\n            rad *= -1.;\n            radius = mod(radius, 1.3);\n            float colorMult = 0.0007 * min(iTime, 1.);\n           if (iTime > 60.)\n           {\n               radius = 0.;\n               colorMult -= (iTime - 60.) * 0.00005;\n           }\n            color += col * colorMult / length(uv + vec2(radius * cos(rad), radius * sin(rad) * flatness));\n        }\n        //color += col * 0.001 / length(uv + vec2(radius * cos(rad), radius * sin(rad) * flatness));\n        //radius *= 0.2;\n        //rad *= -1.;\n        //color += col * 0.001 / length(uv + vec2(radius * cos(rad), radius * sin(rad) * flatness));\n\n        //color += col * 0.001 / length(uv + vec2(radius * sin(rad) * cos(rad), radius * flatness));\n    }\n\n    // Output to screen\n    return vec4(color,1.0);\n}\n\nconst float PI = 3.14159265359;\nvec4 rosace(vec3 iResolution, vec2 uv, float iTime)\n{\n    //uv = ( 2.*fragCoord - R ) / R.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    \n    float countMult = abs(sin(iTime/ 2.)) * 120.;\n    int count = int(countMult);\n    for(int i = 0; i < count; i++)\n    {\n        float percent = (float(i) / float(count));\n        percent = mod(percent + iTime / 5.,  1.);\n        float distanceToLine = abs(cross2(uv, vec2(0.), vec2(cos(percent * PI), sin(percent * PI))));\n        float maxDistToLine = 0.001;\n        maxDistToLine *= iTime * iTime / 9.;\n        if (distanceToLine < maxDistToLine)\n                col = col + vec3((1. - (distanceToLine / maxDistToLine)) * 0.5);\n        //col = col + vec3((1. - (distanceToLine * 10.)) * 0.2);\n    }\n    \n    return vec4(col,1.0);\n}\n\nfloat f[102] = float[102]( 0.4188,0.6803,0.8351,0.3931,0.1484,0.3489,0.1822,0.7921,0.5776,0.9585,0.4354,0.9094,0.5859,0.3453,0.4575,0.7487,0.5225,0.0288,0.6419,0.7387,0.8284,0.63,0.5873,0.1152,0.9798,0.8107,0.4874,0.5231,0.1614,0.4882,0.4668,0.6859,0.1536,0.8647,0.5416,0.6051,0.0466,0.5658,0.4728,0.4422,0.5758,0.4453,0.2487,0.0069,0.397,0.8259,0.7331,0.5653,0.7406,0.9684,0.8633,0.4285,0.3096,0.6653,0.0481,0.7099,0.2539,0.8341,0.293,0.6564,0.8789,0.6588,0.6868,0.7394,0.6775,0.3235,0.0148,0.7472,0.9446,0.8022,0.3768,0.1409,0.6058,0.6033,0.3116,0.5055,0.5784,0.461,0.3446,0.6589,0.4123,0.6917,0.3609,0.5184,0.4885,0.6628,0.3636,0.6953,0.2945,0.2809,0.1784,0.8433,0.3716,0.4287,0.8966,0.0248,0.2529,0.6683,0.9053,0.5581,0.0454,0.6303);\nvec4 lines(vec3 iResolution, vec2 uv, float iTime)\n{\n    vec3 col = vec3(0.);\n    \n    //float countMult = abs(sin(iTime / 2.)) * 120.;\n    int count = 100;//int(countMult);\n    for(int i = 0; i < count; i++)\n    {\n        float percent = f[i];\n        \n        float maxMod = 1.5;\n        float time = iTime;\n        if (iTime > 12.)\n        {\n            time -= 12.;\n            maxMod = 5.;\n        }\n        if (mod(float(i), 2.) > 0.)\n            percent = mod(percent * 1.5 + time / 4., maxMod) - 0.75;\n        else\n            percent = mod(percent * 1.5 - time / 4., maxMod) - 0.75;\n        float lineXPos = percent*3.;\n        float rotation = 1.;\n        if (iTime > 7.) // add rotation\n            rotation = cos(iTime-7.);// + 1.;\n        vec2 p1 = vec2(percent, 0.);\n        vec2 p2 = vec2(percent + (f[i + 1] * 2. - 1.) * rotation, 0.5);\n        \n        //float slope = (f[i + 1] * 2. - 1.) / 0.3;\n        vec2 perp = vec2(0.3, -(f[i + 1] * 2. - 1.));\n        perp *= percent;\n        \n        p1 += perp;\n        p2 += perp;\n        \n        if (iTime > 12.) // lining up\n            p2.x -= (p2.x - p1.x) * min((iTime - 13.) / 5., 1.);\n        \n        vec2 uv2 = uv;\n\n        float distanceToLine = abs(cross2(uv2, p1, p2));\n        float maxDistToLine = max(0.01, 0.1 - iTime / 30.);\n        if (distanceToLine < maxDistToLine)\n        {\n            if (false) // apply color\n                col = col + vec3(sin(iTime+uv.xyx+vec3(0,2,4)) * (1. - (distanceToLine / maxDistToLine)) * 0.5);\n            else\n                col = col + vec3((1. - (distanceToLine / maxDistToLine)) * 0.5);\n        }\n    }\n    \n    return vec4(col,1.0);\n}\n\n#define CS(a)  vec2(cos(a),sin(a))\n\nvec4 test(vec3 iResolution, vec2 uv, float iTime)\n{\n    vec2 R = iResolution.xy;\n\n    float PI = 3.14159,\n        phi = iTime*0.001 + 0.1, // or phi = (1. + sqrt(5.))/2.,\n          a = phi * 2.*PI,\n         i0 = ( length(uv) - .01 ) /.0015,\n         i1 = ( mod( atan(uv.y,uv.x) ,2.*PI) )/ a, // + k*2PI/a\n          k = floor( (i0-i1) / (2.*PI/a) ), \n          i, d = 1e9;\n    \n    for (float n = 0.; n < 2.; n++) {\n        i = round( i1 + k++ * 2.*PI/a );\n        vec2 p = ( .01+ 0.0015*i ) *CS(i*a);\n    \td = min( d, length(uv - p) - .001 );   \n    }\n  \n      vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    return vec4(smoothstep(3./iResolution.y, 0., d - .01) * col, 0.);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}