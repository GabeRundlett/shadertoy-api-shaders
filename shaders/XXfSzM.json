{
    "Shader": {
        "info": {
            "date": "1709232374",
            "description": "CC0: Crap Max Head Room Effect\n  I didn't really grow up with Max Head Room but I thought I make an attempt\n  Don't really know what I am doing...\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XXfSzM",
            "likes": 9,
            "name": "Crap Max Head Room Effect",
            "published": 3,
            "tags": [
                "max"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 229
        },
        "renderpass": [
            {
                "code": "// CC0: Crap Max Head Room Effect\n//  I didn't really grow up with Max Head Room but I thought I make an attempt\n//  Don't really know what I am doing...\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/noacos/\nmat3 rot(vec3 d, vec3 z) {\n  vec3  v = cross( z, d );\n  float c = dot( z, d );\n  float k = 1.0/(1.0+c);\n\n  return mat3( v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n               v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n               v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors/\nvec2 box(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal) {\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF)) ;  // ro inside the box\n    outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec3 mod3(inout vec3 p, vec3 size) {\n  vec3 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n\nfloat steps(float a, float b) {\n  float x = a/b;\n  float y = floor(x);\n  float z = fract(x);\n  return (y+z*z)*b;\n}\n\nvec3 effect(vec2 p) {\n  const vec3 upDir = vec3(0., 1., 0.);\n  vec3 ro = vec3(1.);\n  float a0 = 0.3*steps(TIME, 1E-1)+123.4;\n  float a1 = 0.4*steps(TIME, 1E-1)+12.34;\n  vec3 r0 = normalize(vec3(1., sin(sqrt(3.)*a0), sin(a0)));\n  vec3 r1 = normalize(vec3(sin(a1), sin(sqrt(2.)*a1), 1.));\n  ro *= rot(r0, r1);\n  vec3 la = vec3(0.);\n  vec3 ww = normalize(la-ro);\n  vec3 uu = normalize(cross(upDir, ww));\n  vec3 vv = cross(ww, uu);\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.*ww);\n  \n  vec3 bn;\n  vec2 bi = box(ro, rd, vec3(5.), bn); \n  vec3 abn = abs(bn);\n  vec3 col = vec3(0.);\n  if (bi.y > bi.x) {\n    vec3 p3 = ro+rd*bi.y;\n    const float lum = 5E-5;\n    const float mn = 1E-4;\n    const vec3 col0 = HSV2RGB(vec3(0.6, 0.85, lum));\n    const vec3 col1 = HSV2RGB(vec3(0.75 , 0.85, lum));\n    const vec3 col2 = HSV2RGB(vec3(0.65, 0.85, lum));\n    vec3 cp3 = p3;\n    vec3 np3 = mod3(cp3, vec3(0.25));\n    float a = steps(TIME, 1E-2);\n    cp3 += 0.1*sin(p3.yzx+a);\n    col += mix(0.1, 1.0, smoothstep(-0.7, 0.5, sin(0.123*np3.x+1.1*a)))*col0/max((cp3.x*cp3.x), mn)*step(abn.x, 0.)*step(abn.y, 0.);\n    col += mix(0.2, 1.0, smoothstep(-0.6, 0.5, sin(0.242*np3.y+0.7*a)))*col1/max((cp3.y*cp3.y), mn)*step(abn.y, 0.)*step(abn.z, 0.);\n    col += mix(0.1, 1.0, smoothstep(-0.9, 0.5, sin(0.07*np3.z+1.5*a)))*col2/max((cp3.z*cp3.z), mn)*step(abn.z, 0.)*step(abn.x, 0.);\n  }\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = -1.+2.*fragCoord/RESOLUTION.xy;\n\n    p.x *= RESOLUTION.x/RESOLUTION.y;\n    vec3 col = effect(p);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}