{
    "Shader": {
        "info": {
            "date": "1719317481",
            "description": "A letter cube for a little boy.\nI used this shader to generated a triangle mesh to 3D print it: https://github.com/WilstonOreo/sdf2mesh\nYou can generate this mesh using my sdf2mesh with:\nsdf2mesh --shadertoy-id DldfR7 --resolution 256 --mesh",
            "flags": 0,
            "hasliked": 0,
            "id": "DldfR7",
            "likes": 5,
            "name": "Letter Cube",
            "published": 3,
            "tags": [
                "sdf",
                "cube"
            ],
            "usePreview": 0,
            "username": "WilstonOreo",
            "viewed": 78
        },
        "renderpass": [
            {
                "code": "// Generate Mesh from SDF, (C) 2024 WilstonOreo\n//\n// I wrote a tool called `sdf2mesh` that can generate meshes from SDFs via dual contouring.\n// This means you can now write your shaders in ShaderToy and edit them in your favourite 3D software or \n// even 3D print them! \n// The repository is here: https://github.com/WilstonOreo/sdf2mesh\n//\n// The tool is written in Rust and uses WGPU for rendering.\n// If you run the tool with:\n//\n// cargo run --release -- --shadertoy-id DldfR7 --resolution 256 --mesh shadertoy.stl --bounds 5al\n// \n// It will render this very shader to a mesh and saves under file \"shadertoy.stl\"\n// Please see the README.md in the repository for more information.\n// Feedback is always welcome. I really look forward to see some 3D-printed shaders in the future!\n// \n\n\nconst float CUBE_WIDTH = 1.0;\nconst float LETTER_THICKNESS = 0.12;\nconst float SMOOTHNESS = 0.02;\n\nconst float C = CUBE_WIDTH;\n\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\nfloat sdHalfTorus(in vec3 p, in float ra, in float rb)\n{\n    p.xy = p.yx;\n    p.x = abs(p.x - C*0.2);\n    p.y += C*0.25;\n    vec3 h = vec3(0.0, C*0.15, 0.0);\n    vec3 q = p - clamp( p, -h, h );\n     vec2 sc = vec2(1.0, 0.0);\n\n    float k = (0.0 > sc.x*q.y) ? dot(q.xy,sc) : length(q.xy);\n    return sqrt( dot(q,q) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n\nfloat segment(vec3 p, vec3 a, vec3 b) {\n    return sdCapsule(p, a, b, LETTER_THICKNESS);\n}\n\n// Letter M Z+\nfloat letterM(vec3 p) {\n    return min(\n        min(\n            segment(p, vec3(-C*0.45, -C*0.5, C), vec3(-C*0.45, C*0.5, C)),\n            segment(p, vec3(-C*0.45, -C*0.5, C), vec3(0.0, 0.0, C))\n        ),\n        min(\n            segment(p, vec3(0.0, 0.0, C), vec3(C*0.45, -C*0.5, C)),\n            segment(p, vec3(C*0.45, -C*0.5, C), vec3(C*0.45, C*0.5, C))\n        )\n    );\n\n}\n\n// Letter A Z-\nfloat letterA(vec3 p) {\n    p = p.zyx;\n    p.xy = -p.yx;\n\n    return min(\n        min(\n            segment(p, vec3(0.0, -C*0.5, -C), vec3(-C*0.4, C*0.5, -C)),\n            segment(p, vec3(0.0, -C*0.5, -C), vec3( C*0.4, C*0.5, -C))\n        ),\n        segment(p, vec3(-C*0.2, C*0.1, -C), vec3(C*0.2, C*0.1, -C))\n    );\n}\n\n// Letter R Y+\nfloat letterR(vec3 p) {\n    p.x -= C*0.15;\n    return min(\n        sdHalfTorus(p.xzy - vec3(0.0, 0, C), C*0.3, LETTER_THICKNESS),\n        min(\n            segment(p, vec3(-C*0.4, C, C*0.5), vec3(-C*0.4, C, -C*0.5)),\n            segment(p, vec3(-C*0.15, C, -C*0.1), vec3( C*0.15, C, -C*0.5))\n        )\n    );\n}\n\n\n// Letter T X+\nfloat letterT(vec3 p) {\n    return min(\n        segment(p, vec3(C, 0.0, C*0.5), vec3(C, 0.0, -C*0.5)),\n        segment(p, vec3(C, -C*0.4, C*0.5), vec3(C, C*0.4, C*0.5))\n    );\n}\n\n\n// Letter I Z-\nfloat letterI(vec3 p) {\n    p = p.yxz;\n    return segment(p, vec3(-C, 0.0, C*0.5), vec3(-C, 0.0, -C*0.5));\n}\n\n\n// Letter N Y-\nfloat letterN(vec3 p) {\n\n    p = p.xzy;\n    p.x *= -1.0;\n\n    return min(\n        segment(p, vec3(-C*0.4, -C, C*0.5), vec3(-C*0.4, -C, -C*0.5)),\n        min(\n            segment(p, vec3( C*0.4, -C, C*0.5), vec3( C*0.4, -C, -C*0.5)),\n            segment(p, vec3( -C*0.4, -C, -C*0.5), vec3( C*0.4, -C, C*0.5))\n        )\n    );\n}\n\n\n\n\nmat3 lookAtMatrix(vec3 from, vec3 to) {\n    vec3 forward = normalize(to - from);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nmat3 rotationMatrixAxisAngle(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    vec3 column1 = axis * axis.x * (1.0 - c) + vec3(c, axis.z * s, -axis.y * s);\n    vec3 column2 = axis * axis.y * (1.0 - c) + vec3(-axis.z * s, c, axis.x * s);\n    vec3 column3 = axis * axis.z * (1.0 - c) + vec3(axis.y * s, -axis.x * s, c);\n    return mat3(column1, column2, column3);\n}\n\nfloat sdf(in vec3 p) { \n    \n    float cube = opSmoothIntersection(sdBox(p, vec3(CUBE_WIDTH, CUBE_WIDTH, CUBE_WIDTH)), sdSphere(p, CUBE_WIDTH * 1.40), SMOOTHNESS);\n    float letter = min(min(letterM(p), letterA(p)), \n                       min(min(letterR(p), letterT(p)), \n                       min(letterI(p), letterN(p))));\n    \n    return opSmoothSubtraction(letter, cube, SMOOTHNESS);\n\n}\n\nvec3 normal(vec3 position, float epsilon) {\n    vec3 gradient = vec3(\n        sdf(position + vec3(epsilon, 0, 0)) - sdf(position + vec3(-epsilon, 0, 0)),\n        sdf(position + vec3(0, epsilon, 0)) - sdf(position + vec3(0, -epsilon, 0)),\n        sdf(position + vec3(0, 0, epsilon)) - sdf(position + vec3(0, 0, -epsilon))\n    );\n    return normalize(gradient);\n}\n\n\nfloat raycast(vec3 rayOrigin, vec3 rayDirection) {\n    int stepCount = 256;\n    float maximumDistance = 10.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = sdf(currentPosition);\n        if (d < 0.0001) {\n            return t;\n        }\n        t += d;\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 targetPosition = vec3(0.0);\n    vec3 result = vec3(0.0);\n    ivec2 sampleCount = ivec2(3.0, 3.0);\n    for (int y = 0; y < sampleCount.y; y++) {\n        for (int x = 0; x < sampleCount.x; x++) {\n                        vec2 uv = (fragCoord-0.5*iResolution.xy + vec2(float(x),float(y)) / vec2(sampleCount))/iResolution.y;\n\n                vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-5.,0,0);\n    \n    float yrot = -1.25;\n    float zrot = -1.0; //iTime*.4;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n\n            vec3 rayDirection = cam;\n            \tvec3 rayOrigin = init;\n                \n            float t = raycast(init, cam);\n            vec3 color = vec3(0.0);\n            if (t > 0.0) {\n                // same style that Inigo Quilez uses in his shaders\n                vec3 position = rayOrigin + rayDirection * t;\n                \n                vec3 lightDirection = vec3(0.57735);\n                vec3 n = normal(position, 0.001);\n                vec3 nc = normal(position, 0.005);\n                \n                \n                float diffuseAngle = max(dot(n, normalize(rayOrigin)), 0.0);\n                \n                color = vec3(0.8, 0.8, 0.8);\n\n\n                color *= diffuseAngle;\n                // ambient\n                color += vec3(0.2, 0.2, 0.2);\n            }\n            // gamma        \n            color = sqrt(color);\n            result += color;\n        }\n    }\n    result /= float(sampleCount.x * sampleCount.y);\n\tfragColor = vec4(result, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}