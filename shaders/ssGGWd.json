{
    "Shader": {
        "info": {
            "date": "1683358435",
            "description": "Hyperbolic honeycombs projected from the hyperbolic boundary, and forming Apollonian circle packings. See code header for more.\n\nSee [url]http://www.hyperbolichoneycombs.org/[/url] for more on the maths.",
            "flags": 48,
            "hasliked": 0,
            "id": "ssGGWd",
            "likes": 20,
            "name": "Apollonian Circle Packings",
            "published": 3,
            "tags": [
                "circle",
                "apollonian",
                "packing",
                "hyperbolic"
            ],
            "usePreview": 1,
            "username": "mla",
            "viewed": 314
        },
        "renderpass": [
            {
                "code": "/////////////////////////////////////////////////////////////////////\n//\n// Apollonian Circle Packings, mla, 2023\n//\n// In fact, hyperbolic honeycombs, seen on the boundary of hyperbolic\n// space (eg. stereographically projected from the boundary sphere of\n// the Poincare ball).\n// \n// Generated by repeated reflection and inversion in two lines and two\n// circles intersecting at rational angles, representing the faces of\n// the generating hyperbolic tetrahedron.\n//\n// <up>/<down>: zoom in and out\n// <left>/<right>: select tetrahedron\n// i: invert at origin\n// j: invert at mouse position\n// m: monochrome\n// p: progressive folding\n// o: colour by iteration count\n// w,z: show generating lines & circles\n// (+ various other more esoteric key controls)\n//\n/////////////////////////////////////////////////////////////////////\n\n// If point on wrong side of line (p.n < 0), reflect in line\nint tryinvert(inout vec2 p, vec2 n, inout float scale) {\n  if (dot(p,n) < 0.0) {\n    p = reflect(p,n);\n    return 1;\n  }\n  return 0;\n}\n\n// If point in \"interior\" of circle, invert to \"exterior\"\nint tryinvert(inout vec2 p, vec3 c, inout float scale) {\n  if (sign(c.z)*(distance(p,c.xy)-abs(c.z)) < 0.0) {\n    p -= c.xy;\n    float k = c.z*c.z/dot(p,p);\n    p *= k;\n    scale *= k;\n    p += c.xy;\n    return 1;\n  }\n  return 0;\n}\n\nint solve2(vec2 p, float r, vec2 q, float s, int a, out vec2 k);\n\n// Given dihedral angles (P,Q,R),(S,T,U), find lines A,B and\n// circles C,D such that dihedral angles are:\n// AB: P; BC: Q; CA: R\n// AD: S; BD: T; CD: U\n//\n// Line through origin, normal n, and circle centre p, radius r,\n// have dihedral t where r cos t = c.n (draw a triangle),\n// so if (p,r) has dihedral t and u with n and m, we have:\n// r cos t = c.n and  r cos u = c.m  =>\n// c.n/c.m = cos t/cos u =>\n// c.n cos u - c.m cos t = 0 =>\n// c.(n cos u - m cos t) = 0\n// which is equation of a line & any point on the line is the centre\n// of a circle with the correct dihedral (for suitable radius).\n// For dihedral = PI/2, the circle centre is on the line itself,\n// so if both dihedrals are PI/2, the centre is at the origin.\n\nmat4x3 solve(ivec3 pqr, ivec3 stu) {\n  assert(pqr[0] != 0);\n  vec2 n = vec2(1,0);\n  vec2 m = vec2(-icos(pqr[0]),isin(pqr[0]));\n  // Confusing names here:\n  // pqr,stu are vectors of angles\n  // n,m are line normals\n  // p,r,q,s are centre and radius of circles\n\n  // Find point p on line with correct dihedral with n and m\n  vec2 p = mat2(0,-1,1,0)*(m*icos(pqr[2])-n*icos(pqr[1])*n);\n  //if (pqr[1] != 2 || pqr[2] != 2) p = normalize(p);\n  // Make sure cos(PI/2) = 0 is handled properly!\n  // If both, then origin is centre and radius can be arbitrary\n  float r =\n    pqr[1] != 2 ? dot(m,p)/icos(pqr[1]) \n    : pqr[2] != 2 ? dot(n,p)/icos(pqr[2])\n    : 1.0;\n\n  // Find point q on line with correct dihedral with n and m\n  vec2 q = mat2(0,1,-1,0)*(m*icos(stu[0])-n*icos(stu[1]));\n  float s =\n    stu[0] != 2 ? dot(n,q)/icos(stu[0])\n    : stu[1] != 2 ? dot(m,q)/icos(stu[1])\n    : -1.0;\n  // Now scale (q,s) to have correct dihedral with (p,r)\n  vec2 roots;\n  int nroots = solve2(p,r,q,s,stu[2],roots);\n  assert(nroots == 2); // Equation is usually solvable\n  // Default to larger root, this usually (always?) seems\n  // to be the correct thing to do.\n  vec3 C = vec3(p,r);\n  vec3 D = vec3(q,s);\n  D *= key(CHAR_0) ? roots[0] : roots[1]; // Flip roots\n  return mat4x3(vec3(n,0),vec3(m,0),C,D);\n}\n\n// Solve quadratic to find scaled circle (q,s) that has dihedral\n// angle PI/a with circle (p,r).\nint solve2(vec2 p, float r, vec2 q, float s, int a, out vec2 roots) {\n  roots = vec2(0);\n  // Use cosine law:\n  // |p-kq|² = p.p - 2kp.q + k²q.q = r²+k²s²-2krs.cos(a)\n  // If A == 0, then have linear solution plus \"infinity\"\n  // If C == 0, then have linear solution plus zero\n  // Solve Ak²-2Bk+C = 0\n  float A = dot(q,q)-s*s;\n  float B = dot(p,q)+r*s*icos(a);\n  float C = dot(p,p)-r*r;\n  if (abs(A) < 1e-3) {\n    // Problematic case - circle D passes through origin\n    // (which means triangle AB,BD,DA is Euclidean).\n    // -2Bx + C = 0\n    roots[0] = roots[1] = C/(2.0*B);\n    return 2;\n  }\n  if (abs(C) < 1e-3) {\n    // This case seems unproblematic\n    // Ax - 2B = 0\n    roots[0] = roots[1] = 2.0*B/A;\n    return 2;\n  }\n  float D = B*B-A*C;\n  if (D < 0.0) return 0;\n  roots[0] = (B + sqrt(D))/A;\n  roots[1] = (B - sqrt(D))/A;\n  return 2;\n}\n\n// We are really dealing with tetrahedral fundamental\n// domains in hyperbolic space, but just displaying\n// the boundary (as a stereographic projection to the\n// Euclidean plane).\n\n// Tetrahedron angles as (AB,BC,CA),(AD,BD,CD)\n// So for a standard linear Coxeter diagram:\n// AB,BC,CA,AD,BD,CD\n// P  Q  2  2  2  R\n// Q  R  2  P  2  2\n// Q  2  R  2  P  2\n\nconst ivec3 tetrahedra[] =\n  ivec3[](\n          //ivec3(4,4,4), ivec3(4,2,4), // Problem case: A = 0 in quadratic\n          ivec3(4,2,4), ivec3(4,4,4),\n          ivec3(1,0,0), ivec3(0,0,0),\n          ivec3(2,0,0), ivec3(0,0,0),\n          ivec3(3,0,0), ivec3(0,0,0),\n          ivec3(6,7,2), ivec3(2,2,20),\n          ivec3(7,6,2), ivec3(20,2,2),\n          ivec3(7,20,2), ivec3(6,2,2),\n          ivec3(3,3,3), ivec3(2,2,7),\n          ivec3(5,6,2), ivec3(2,2,5),\n          ivec3(6,5,2), ivec3(5,2,0),\n          ivec3(5,2,3), ivec3(2,2,0), // Nice recursive zoom\n          ivec3(3,5,2), ivec3(2,2,0),\n          ivec3(3,2,2), ivec3(2,5,4),\n          ivec3(5,3,2), ivec3(2,2,0),\n          ivec3(2,2,3), ivec3(0,3,2),\n          ivec3(5,3,2), ivec3(0,2,0),\n          ivec3(7,3,2), ivec3(2,2,0),\n          ivec3(3,3,3), ivec3(2,2,0),\n          ivec3(2,2,2), ivec3(3,3,0),\n          ivec3(2,3,5), ivec3(2,2,0),\n          ivec3(5,5,5), ivec3(5,5,0),\n          ivec3(4,2,4), ivec3(4,4,4),\n          ivec3(3,3,3), ivec3(0,0,0),\n          ivec3(6,6,6), ivec3(6,6,0),\n          ivec3(8,3,2), ivec3(2,2,0),\n          ivec3(3,2,8), ivec3(2,0,2),\n          ivec3(3,2,0), ivec3(2,7,0),\n          ivec3(3,7,2), ivec3(2,2,0),\n          ivec3(7,3,2), ivec3(0,2,2)\n          );\n\nvec3 getcol(vec2 p, float scale, vec2 mouse);\n\nvec2 A,B; // Lines\nvec3 C,D; // Circles\nvec3 O0,O1,O2,O3; // Orthogonal Circles\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 mouse = vec2(0);\n  if (iMouse.x > 0.0) mouse = (2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n\n  int ntetrahedra = tetrahedra.length()/2;\n  int tindex = keycount(KEY_RIGHT)-keycount(KEY_LEFT);\n  tindex %= ntetrahedra+1;\n  assert(tindex >= 0);\n  if (tindex != 0) tindex--;\n  else tindex = int(iTime)%(ntetrahedra);\n  ivec3 pqr = tetrahedra[2*tindex], stu = tetrahedra[2*tindex+1];\n  //if (stu.z == 0) stu.z = int(iTime);\n\n  mat4x3 ABCD = solve(pqr,stu);\n  A = vec2(ABCD[0]);\n  B = vec2(ABCD[1]);\n  C = ABCD[2];\n  D = ABCD[3];\n  if (key(CHAR_A) && iMouse.x != 0.0) D *= 2.0*mouse.x; // Set angle D from mouse\n\n  // Find orthogonal circles\n  // Any circle with centre (0,0) is orthogonal to A,B\n  O0 = vec3(0,0,sqrt(dot(C.xy,C.xy)-C.z*C.z)); // Orthogonal to A,B,C\n  O1 = vec3(0,0,sqrt(dot(D.xy,D.xy)-D.z*D.z)); // Orthogonal to A,B,D\n  {\n    // O2 orthogonal to A,C,D -> centre lies on A\n    // O3 orthogonal to B,C,D -> centre lies on B\n    vec2 e = (D.xy-C.xy);\n    float K = dot(C.xy,C.xy)-dot(D.xy,D.xy)+D.z*D.z-C.z*C.z;\n    vec2 p2 = vec2(A.y,-A.x), p3 = vec2(B.y,-B.x);\n    p2 *= -K/(2.0*dot(p2,e));\n    p3 *= -K/(2.0*dot(p3,e));\n    O2 = vec3(p2,sqrt(dot(C.xy-p2,C.xy-p2)-C.z*C.z));\n    O3 = vec3(p3,sqrt(dot(C.xy-p3,C.xy-p3)-C.z*C.z));\n  }\n\n  float zoom = 2.0;\n  // Try to scale so the main circle just fits on screen\n  if (O0.z > 0.001 || O1.z > 0.001) {\n    zoom = 1.0;\n    float k = 1.0/max(O0.z,O1.z);//O1.z;\n    C *= k; D *= k;\n    O0 *= k; O1 *= k; O2 *= k; O3 *= k;\n  }\n  \n  zoom *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n\n  bool dozoom = false;\n  //dozoom = !key(CHAR_I);\n  if (dozoom) zoom *= exp(10.0*mouse.y);\n  float AA = 2.0;\n  vec3 col = vec3(0);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 p = zoom*(2.0*(fragCoord.xy+vec2(i,j)/AA) - iResolution.xy)/iResolution.y;\n      col += getcol(p,zoom,mouse);\n    }\n  }\n  col /= AA*AA;\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}\n\nvec3 getcol(vec2 p, float scale, vec2 mouse) {\n  float maxscale = 200.0;\n  int loops = 20;\n  if (key(CHAR_P)) loops = min(loops,1+int(iTime)); // Progressive\n  if (key(CHAR_I)) {\n    // Invert at origin\n    float k = 1.0/dot(p,p);\n    p *= k;\n    scale *= k;\n  }\n  if (key(CHAR_J)) {\n    // Invert at mouse position\n    p -= 2.0*mouse;\n    float k = 1.0/dot(p,p);\n    p *= k;\n    scale *= k;\n    p += 2.0*mouse;\n  }\n  // Remember original coordinates & scale\n  // for drawing control circles & lines.\n  vec2 p0 = p;\n  float scale0 = scale;\n  vec3 col = vec3(0);\n  int i;\n  int steps = 0;\n  for (i = 0; i < loops; i++) {\n    // Apply mirrors first\n    for (int j = 0; j < 20; j++) {\n      int k = 0;\n      k += tryinvert(p,A,scale);\n      k += tryinvert(p,B,scale);\n      if (k == 0) break;\n    }\n    int k = 0;\n    // Then inversion circles\n    k += tryinvert(p,C,scale);\n    k += tryinvert(p,D,scale);\n    steps += k;\n    if (k == 0) break;\n  }\n  if (key(CHAR_O)) {\n    col = h2rgb(float(steps)/12.0); // Color by steps\n    col = 0.2+0.8*col;\n  } else if (!key(CHAR_M)) {\n    if (length(p) < O0.z) col = vec3(0,1,0);\n    if (length(p) > O1.z) col = vec3(1,1,0); // NB. O1 is \"inverted\"\n    if (length(p-O2.xy) < O2.z) col = vec3(0,0,1);\n    if (length(p-O3.xy) < O3.z) col = vec3(1,0,0);\n    col = 0.2+0.8*col;\n  }\n  if (key(CHAR_T)) col *= 0.6+0.4*texture(iChannel0,p).xyz;\n  float kk = 0.5;\n  if (length(p) < O0.z) kk /= O0.z;\n  else if (length(p) > O1.z) kk /= O1.z; // NB. O1 is \"inverted\"\n  else if (length(p-O2.xy) < O2.z) kk /= O2.z;\n  else if (length(p-O3.xy) < O3.z) kk /= O3.z;\n  if (key(CHAR_G)) kk *= 2.0;\n  if (key(CHAR_H)) kk *= 0.5;\n  if (length(p) > O1.z) {\n    // An adhoc correction to scale for the \"inverted\" circle O1.\n    if (key(CHAR_S)) assert(false);\n    vec2 p1 = p-O1.xy;\n    kk *= O1.z*O1.z/dot(p1,p1);\n  }\n  if (key(CHAR_D)) col *= 0.8;\n  float minwidth = 2.0*scale/iResolution.y;\n  float cdist = min(min(dist(p,A),dist(p,B)),\n                    min(dist(p,C),dist(p,D)));\n  if (!key(CHAR_X)) {\n    float cwidth = minwidth;\n    if (key(CHAR_F)) cwidth = max(0.0,0.01/kk);\n    vec3 ccol = vec3(1);\n    col = mix(ccol, col, 0.5+0.5*smoothstep(0.5*cwidth,cwidth,cdist));\n  }\n  if (key(CHAR_Y)) {\n    float cwidth = minwidth;\n    if (key(CHAR_F)) cwidth = max(0.0,0.005/kk);\n    vec3 ccol = vec3(0);\n    col = mix(ccol, col, 0.2+0.8*smoothstep(0.5*cwidth,cwidth,cdist));\n  }\n  if (!key(CHAR_U) && kk*scale > maxscale) col = vec3(0);\n  if (key(CHAR_W)){\n    vec3 ccol = vec3(1);\n    float d = 1e8;\n    float cwidth = 2.0*scale0/iResolution.y;\n    if (O0.z > 0.0) d = min(d,dist(p0,O0));\n    if (O1.z > 0.0) d = min(d,dist(p0,O1));\n    if (O2.z > 0.0) d = min(d,dist(p0,O2));\n    if (O3.z > 0.0) d = min(d,dist(p0,O3));\n    col = mix(ccol, col, smoothstep(0.0,cwidth,d-cwidth));\n  }\n  if (key(CHAR_Z)) {\n    float cwidth = 2.0*scale0/iResolution.y;\n    float cdist0 = min(min(dist(p0,A),dist(p0,B)),\n                       min(dist(p0,C),dist(p0,D)));\n    vec3 ccol = vec3(0);\n    col = mix(ccol, col, smoothstep(0.0,cwidth,cdist0-cwidth));\n  }\n  return col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n// Distance to line (through origin)\nfloat dist(vec2 p, vec2 l) {\n  return abs(dot(p,l));\n}\n\n// Distance to circle (z coord is radius, if negative then consider\n// the \"interior\" to be points x with |x - c.xy| > c.z\nfloat dist(vec2 p, vec3 c) {\n  return abs(distance(p,c.xy)-abs(c.z));\n}\n\nfloat COS[] =\n  // I don't trust cos on the GPU to be accurate enough: cos(PI/n) for n = 0..31\n  float[](1.0,-0.5,0.0,0.5,0.7071067812,0.8090169944,0.8660254038,\n          0.9009688679,0.9238795325,0.9396926208,0.9510565163,0.9594929736,\n          0.9659258263,0.9709418174,0.9749279122,0.9781476007,0.9807852804,\n          0.9829730997,0.984807753,0.9863613034,0.9876883406,0.9888308262,\n          0.9898214419,0.990685946,0.9914448614,0.9921147013,0.9927088741,\n          0.9932383577,0.9937122099,0.9941379572,0.9945218954,0.9948693234);\n\nfloat icos(int p) {\n  // cos(PI/p)\n  if (p < COS.length()) return COS[p];\n  if (p == 0) return 1.0;\n  return cos(PI/float(p));\n}\n\nfloat isin(int p) {\n  // sin(PI/p)\n  float t = icos(p);\n  return sqrt(1.0-t*t);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return rgb;\n}\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store((key),0).x))\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}