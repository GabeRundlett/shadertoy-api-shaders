{
    "Shader": {
        "info": {
            "date": "1631597675",
            "description": "All 50 cards from [url=https://patriciogonzalezvivo.github.io/PixelSpiritDeck]Pixel Spirit[/url].\n[b]Mouse click a card to see the bigger version![/b]\nDynamic version [url=https://www.shadertoy.com/view/fdK3DD]here![/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "Nsd3zn",
            "likes": 19,
            "name": "Pixel Spirit Deck, Original",
            "published": 3,
            "tags": [
                "sdf",
                "symbol",
                "cards",
                "icon",
                "pixelspirit"
            ],
            "usePreview": 0,
            "username": "chenglou",
            "viewed": 918
        },
        "renderpass": [
            {
                "code": "/* Original code from https://patriciogonzalezvivo.github.io/PixelSpiritDeck */\n\nconst float PI = 3.14159;\nconst float TAU = PI * 2.;\nconst float QTR_PI = PI / 4.;\n\n// === All the utils, with their original card numbers\n\nfloat stroke(float x, float s, float w) { // 04\n    float d = step(s, x + w / 2.) - step(s, x - w / 2.);\n    return clamp(d, 0., 1.);\n}\nfloat circleSDF(vec2 st) { // 08\n    return length(st - 0.5) * 2.;\n}\nfloat fill(float x, float size) { // 09\n    return 1. - step(size, x);\n}\nfloat rectSDF(vec2 st, vec2 s) { // 10\n    st = st * 2. - 1.;\n    return max(abs(st.x / s.x), abs(st.y / s.y));\n}\nfloat crossSDF(vec2 st, float s) { // 11\n    vec2 size = vec2(0.25, s);\n    return min(rectSDF(st, size.xy), rectSDF(st, size.yx));\n}\nfloat flip(float v, float pct) { // 12\n    return mix(v, 1. - v, pct);\n}\nfloat vesicaSDF(vec2 st, float w) { // 14\n    vec2 offset = vec2(w * .5, 0.);\n    return max(circleSDF(st - offset), circleSDF(st + offset));\n}\nfloat triSDF(vec2 st) { // 16\n    st = (2. * st - 1.) * 2.;\n    return max(abs(st.x) * 0.866025 + st.y * .5, -st.y * .5);\n}\nfloat rhombSDF(vec2 st) { // 17\n    return max(triSDF(st), triSDF(vec2(st.x, 1. - st.y)));\n}\nvec2 rotate(vec2 st, float a) { // 19\n    st = mat2(cos(a), -sin(a), sin(a), cos(a)) * (st - .5);\n    return st + .5;\n}\nfloat polySDF(vec2 st, int V) { // 26\n    st = st * 2. - 1.;\n    float a = atan(st.x, st.y) + PI;\n    float r = length(st);\n    float v = TAU / float(V);\n    return cos(floor(.5 + a / v) * v - a) * r;\n}\nfloat hexSDF(vec2 st) { // 27\n    st = abs(st * 2. - 1.);\n    return max(abs(st.y), st.x * 0.866025 + st.y * .5);\n}\nfloat starSDF(vec2 st, int V, float s) { // 28\n    st = st * 4. - 2.;\n    float a = atan(st.y, st.x) / TAU;\n    float seg = a * float(V);\n    a = ((floor(seg) + 0.5) / float(V) +\n        mix(s, -s, step(.5, fract(seg))))\n        * TAU;\n    return abs(dot(vec2(cos(a), sin(a)), st));\n}\nfloat raysSDF(vec2 st, int N) { // 30\n    st -= .5;\n    return fract(atan(st.y, st.x) / TAU * float(N));\n}\nfloat heartSDF(vec2 st) { // 34\n    st -= vec2(.5, .8);\n    float r = length(st) * 5.;\n    st = normalize(st);\n    return r -\n        ((st.y * pow(abs(st.x), 0.67)) /\n        (st.y + 1.5) - 2. * st.y + 1.26);\n}\nfloat bridge(float c, float d, float s, float w) { // 35\n    c *= 1. - stroke(d, s, w * 2.);\n    return c + stroke(d, s, w);\n}\nfloat spiralSDF(vec2 st, float t) { // 47\n    st -= .5;\n    float r = dot(st, st);\n    float a = atan(st.y, st.x);\n    return abs(sin(fract(log(r) * t + a * 0.159)));\n}\nvec2 scale(vec2 st, vec2 s) {\n    return (st - .5) * s + .5;\n}\nfloat flowerSDF(vec2 st, int N) {\n    st = st * 2. - 1.;\n    float r = length(st) * 2.;\n    float a = atan(st.y, st.x);\n    float v = float(N) * .5;\n    return 1. - (abs(cos(a * v)) * .5 + .5) / r;\n}\n\n// === Cards\n\nfloat draw(vec2 st, vec2 tileXY, vec2 count) {\n    // y is bottom to top, but we want to show things from top to bottom. Convert\n    int showID = int(tileXY.x + (-tileXY.y + count.y - 1.) * count.x);\n    float color = 0.;\n    \n    switch (showID) {\n    case 0: { // void\n        color = 0.;\n        break;\n    }\n    case 1: { // justice\n        color = step(0.5, st.x);\n        break;\n    }\n    case 2: { // strength\n        color = step(0.5 + cos(st.y * PI) * 0.25, st.x);\n        break;\n    }\n    case 3: { // death\n        color = step(0.5, (st.x + st.y) * 0.5);\n        break;\n    }\n    case 4: { // wall\n        color = stroke(st.x, 0.5, 0.15);  \n        break;\n    }\n    case 5: { // temperance\n        float offset = cos(st.y * PI) * 0.15;\n        color = stroke(st.x, .28 + offset, 0.1);\n        color += stroke(st.x, .5 + offset, 0.1);\n        color += stroke(st.x, .72 + offset, 0.1);\n        break;\n    }\n    case 6: { // branch\n        float offset = 0.5 + (st.x - st.y) * 0.5;\n        color = stroke(offset, 0.5, 0.1);\n        break;\n    }\n    case 7: { // the hanged man\n        float sdf = 0.5 + (st.x - st.y) * 0.5;\n        color = stroke(sdf, 0.5, 0.1);\n        float sdf_inv = (st.x + st.y) * 0.5;\n        color += stroke(sdf_inv, 0.5, 0.1);\n        break;\n    }\n    case 8: { // the high priestess\n        color = stroke(circleSDF(st), 0.5, 0.05);\n        break;\n    }\n    case 9: { // the moon\n        color = fill(circleSDF(st), 0.65);\n        vec2 offset = vec2(0.1, 0.05);\n        color -= fill(circleSDF(st - offset), 0.5);\n        break;\n    }\n    case 10: { // the emperor\n        float sdf = rectSDF(st, vec2(1.));\n        color = stroke(sdf, .5, .125);\n        color += fill(sdf, .1);\n        break;\n    }\n    case 11: { // the hierophant\n        float rect = rectSDF(st, vec2(1));\n        color = fill(rect, .5);\n        float cross = crossSDF(st, 1.);\n        color *= step(.5, fract(cross * 4.));\n        color *= step(1., cross);\n        color += fill(cross, .5);\n        color += stroke(rect, .65, .05);\n        color += stroke(rect, .75, .025);\n        break;\n    }\n    case 12: { // the tower\n        float rect = rectSDF(st, vec2(.5, 1.));\n        float diag = (st.x + st.y) * .5;\n        color = flip(fill(rect, .6), stroke(diag, .5, .01));\n        break;\n    }\n    case 13: { // merge\n        vec2 offset = vec2(.15, 0);\n        float left = circleSDF(st + offset);\n        float right = circleSDF(st - offset);\n        color = flip(stroke(left, .5, .05), fill(right, 0.525));\n        break;\n    }\n    case 14: { // hope\n        float sdf = vesicaSDF(st, .2);\n        color = flip(fill(sdf, .5), step((st.x + st.y) * .5, .5));\n        break;\n    }\n    case 15: { // the temple\n        st.y = 1. - st.y;\n        vec2 ts = vec2(st.x, .82 - st.y);\n        color = fill(triSDF(st), .7);\n        color -= fill(triSDF(ts), .36);\n        break;\n    }\n    case 16: { // the summit\n        float circle = circleSDF(st - vec2(.0, .1));\n        float triangle = triSDF(st + vec2(.0, .1));\n        color = stroke(circle, .5, .1);\n        color *= step(.55, triangle);\n        color += fill(triangle, .45);\n        break;\n    }\n    case 17: { // the diamond\n        float sdf = rhombSDF(st);\n        color = fill(sdf, .425);\n        color += stroke(sdf, .5, .05);\n        color += stroke(sdf, .6, .03);\n        break;\n    }\n    case 18: { // the hermit\n        color = flip(fill(triSDF(st), .5), fill(rhombSDF(st), .4));    \n        break;\n    }\n    case 19: { // intuition\n        st = rotate(st, radians(-25.));\n        float sdf = triSDF(st);\n        sdf /= triSDF(st + vec2(0., .2));\n        color = fill(abs(sdf), .56);\n        break;\n    }\n    case 20: { // the stone\n        st = rotate(st, radians(45.));\n        color = fill(rectSDF(st, vec2(1.)), .4);\n        color *= 1. - stroke(st.x, .5, .02);\n        color *= 1. - stroke(st.y, .5, .02);\n        break;\n    }\n    case 21: { // the mountain\n        st = rotate(st, radians(-45.));\n        float off = .12;\n        vec2 s = vec2(1.);\n        color = fill(rectSDF(st + off, s), .2);\n        color += fill(rectSDF(st - off, s), .2);\n        float r = rectSDF(st, s);\n        color *= step(.33, r);\n        color += fill(r, .3);\n        break;\n    }\n    case 22: { // the shadow\n        st = rotate(vec2(st.x, 1. - st.y), radians(45.));\n        vec2 s = vec2(1.);\n        color += fill(rectSDF(st - .025, s), .4);\n        color += fill(rectSDF(st + .025, s), .4);\n        color *= step(0.38, rectSDF(st + .025, s));\n        break;\n    }\n    case 23: { // opposite\n        st = rotate(st, radians(-45.));\n        vec2 s = vec2(1.);\n        float o = .05;\n        color += flip(\n            fill(rectSDF(st - o, s), .4), \n            fill(rectSDF(st + o, s), .4)\n        );\n        break;\n    }\n    case 24: { // the oak\n        st = rotate(st, radians(45.));\n        float r1 = rectSDF(st, vec2(1.));\n        float r2 = rectSDF(st + .15, vec2(1.));\n        color += stroke(r1, .5, .05);\n        color *= step(.325, r2);\n        color += stroke(r2, .325, .05) * fill(r1, .525);\n        color += stroke(r2, .2, .05);\n        break;\n    }\n    case 25: { // ripples\n        st = rotate(st, radians(-45.)) - .08;\n        for (int i = 0; i < 4; i++) {\n            float r = rectSDF(st, vec2(1.));\n            color += stroke(r, .19, .04);\n            st += .05;\n        }\n        break;\n    }\n    case 26: { // the empress\n        float d1 = polySDF(st, 5);\n        vec2 ts = vec2(st.x, 1. - st.y);\n        float d2 = polySDF(ts, 5);\n        color = fill(d1, .75) * fill(fract(d1 * 5.), .5);\n        color -= fill(d1, .6) * fill(fract(d2 * 4.9), .45);\n        break;\n    }\n    case 27: { // bundle\n        st = st.yx;\n        color = stroke(hexSDF(st), .6, .1);\n        color += fill(hexSDF(st - vec2(-.06, -.1)), .15);\n        color += fill(hexSDF(st - vec2(-.06, .1)), .15);\n        color += fill(hexSDF(st - vec2(.11, 0.)), .15);\n        break;\n    }\n    case 28: { // the devil\n        color += stroke(circleSDF(st), .8, .05);\n        st.y = 1. - st.y;\n        float s = starSDF(st.yx, 5, .1);\n        color *= step(.7, s);\n        color += stroke(s, .4, .1);\n        break;\n    }\n    case 29: { // the sun\n        float bg = starSDF(st, 16, .1);\n        color += fill(bg, 1.3);\n        float l = 0.;\n        for (float i = 0.; i < 8.; i++) {\n            vec2 xy = rotate(st, QTR_PI * i);\n            xy.y -= .3;\n            float tri = polySDF(xy, 3);\n            color += fill(tri, .3);\n            l += stroke(tri, .3, .03);\n        }\n        color *= 1. - l;\n        float c = polySDF(st, 8);\n        color -= stroke(c, .15, .04);\n        break;\n    }\n    case 30: { // the star\n        color = stroke(raysSDF(st, 8), .5, .15);\n        float inner = starSDF(st.xy, 6, .09);\n        float outer = starSDF(st.yx, 6, .09);\n        color *= step(.7, outer);\n        color += fill(outer, .5);\n        color -= stroke(inner, .25, .06);\n        color += stroke(outer, .6, .05);\n        break;\n    }\n    case 31: { // judgement\n        color = flip(\n            stroke(raysSDF(st, 28), .5, .2), \n            fill(st.y, .5)\n        );\n        float rect = rectSDF(st, vec2(1));\n        color *= step(.25, rect);\n        color += fill(rect, .2);\n        break;\n    }\n    case 32: { // wheel of fortune\n        float sdf = polySDF(st.yx, 8);\n        color = fill(sdf, .5);\n        color *= stroke(raysSDF(st, 8), .5, .2);\n        color *= step(.27, sdf);\n        color += stroke(sdf, .2, .05);\n        color += stroke(sdf, .6, .1);\n        break;\n    }\n    case 33: { // vision\n        float v1 = vesicaSDF(st, .5);\n        vec2 st2 = st.yx + vec2(.04, .0);\n        float v2 = vesicaSDF(st2, .7);\n        color = stroke(v2, 1., .05);\n        color += fill(v2, 1.) * stroke(circleSDF(st), .3, .05);\n        color += fill(raysSDF(st, 50), .2) *\n            fill(v1, 1.25) *\n            step(1., v2);\n        break;\n    }\n    case 34: { // the lovers\n        color = fill(heartSDF(st), .5);\n        color -= stroke(polySDF(st, 3), .15, .05);\n        break;\n    }\n    case 35: { // the magician\n        st.x = flip(st.x, step(.5, st.y));\n        vec2 offset = vec2(.15, .0);\n        float left = circleSDF(st + offset);\n        float right = circleSDF(st - offset);\n        color = stroke(left, .4, .075);\n        color = bridge(color, right, .4, .075);\n        break;\n    }\n    case 36: { // the link\n        st = st.yx;\n        st.x = mix(1. - st.x, st.x, step(.5, st.y));\n        vec2 o = vec2(.1, .0);\n        vec2 s = vec2(1.);\n        float a = radians(45.);\n        float l = rectSDF(rotate(st + o, a), s);\n        float r = rectSDF(rotate(st - o, -a), s);\n        color = stroke(l, .3, .1);\n        color = bridge(color, r, .3, .1);\n        color += fill(rhombSDF(abs(st.yx - vec2(.0, .5))), .1);\n        break;\n    }\n    case 37: { // holding together\n        st.x = mix(1. - st.x, st.x, step(.5, st.y));\n        vec2 o = vec2(.05, .0);\n        vec2 s = vec2(1.);\n        float a = radians(45.);\n        float l = rectSDF(rotate(st + o, a), s);\n        float r = rectSDF(rotate(st - o, -a), s);\n        color = stroke(l, .145, .098);\n        color = bridge(color, r, .145, .098);\n        break;\n    }\n    case 38: { // the chariot\n        float r1 = rectSDF(st, vec2(1.));\n        float r2 = rectSDF(rotate(st, radians(45.)), vec2(1.));\n        float inv = step(.5, (st.x + st.y) * .5);\n        inv = flip(inv, step(.5, .5 + (st.x - st.y) * .5));\n        float w = .075;\n        color = stroke(r1, .5, w) + stroke(r2, .5, w);\n        float bridges = mix(r1, r2, inv);\n        color = bridge(color, bridges, .5, w);\n        break;\n    }\n    case 39: { // the loop\n        float inv = step(.5, st.y);\n        st = rotate(st, radians(-45.)) - .2;\n        st = mix(st, .6 - st, step(.5, inv));\n        for (int i = 0; i < 5; i++) {\n            float r = rectSDF(st, vec2(1.));\n            float s = .25;\n            s -= abs(float(i) * .1 - .2);\n            color = bridge(color, r, s, .05);\n            st += .1;\n        }\n        break;\n    }\n    case 40: { // turning point\n        st = rotate(st, radians(-60.));\n        st.y = flip(st.y, step(.5, st.x));\n        st.y += .25;\n        float down = polySDF(st, 3);\n        st.y = 1.5 - st.y;\n        float top = polySDF(st, 3);\n        color = stroke(top, .4, .15);\n        color = bridge(color, down, .4, .15);\n        break;\n    }\n    case 41: { // trinity\n        st.y = 1. - st.y;\n        float s = .25;\n        float t1 = polySDF(st + vec2(.0, .175), 3);\n        float t2 = polySDF(st + vec2(.1, .0), 3);\n        float t3 = polySDF(st - vec2(.1, .0), 3);\n        color = stroke(t1, s, .08) +\n                stroke(t2, s, .08) +\n                stroke(t3, s, .08);\n        float bridges = mix(\n            mix(t1, t2, step(.5, st.y)),\n            mix(t3, t2, step(.5, st.y)),\n            step(.5, st.x)\n        );\n        color = bridge(color, bridges, s, .08);\n        break;\n    }\n    case 42: { // the cauldron\n        float n = 12.;\n        float a = TAU / n;\n        for (float i = 0.; i < n; i++) {\n            vec2 xy = rotate(st, a * i);\n            xy.y -= .189;\n            float vsc = vesicaSDF(xy, .3);\n            color *= 1. - stroke(vsc, .45, .1) * step(.5, xy.y);\n            color += stroke(vsc, .45, .05);\n        }\n        break;\n    }\n    case 43: { // the elders\n        float n = 3.;\n        float a = TAU / n;\n        for (float i = 0.; i < n * 2.; i++) {\n            vec2 xy = rotate(st, a * i);\n            xy.y -= .09;\n            float vsc = vesicaSDF(xy, .3);\n            color = mix(\n                color + stroke(vsc, .5, .1),\n                mix(color, bridge(color, vsc, .5, .1), step(xy.x, .5) - step(xy.y, .4)),\n                step(3., i)\n            );\n            \n        }\n        break;\n    }\n    case 44: { // the core\n        float star = starSDF(st, 8, .063);\n        color += fill(star, 1.22);\n        float n = 8.;\n        float a = TAU / n;\n        for (float i = 0.; i < n; i++) {\n            vec2 xy = rotate(st, 0.39 + a * i);\n            xy = scale(xy, vec2(1., .72));\n            xy.y -= .125;\n            color *= step(.235, rhombSDF(xy));\n        }\n        break;\n    }\n    case 45: { // inner truth\n        st -= .5;\n        float r = dot(st, st);\n        float a = atan(st.y, st.x) / PI;\n        vec2 uv = vec2(a, r);\n        vec2 grid = vec2(5., log(r) * 20.);\n        vec2 uv_i = floor(uv * grid);\n        uv.x += .5 * mod(uv_i.y, 2.);\n        vec2 uv_f = fract(uv * grid);\n        float shape = rhombSDF(uv_f);\n        color += fill(shape, .9) * step(.75, 1. - r);\n        break;\n    }\n    case 46: { // the world\n        color = fill(flowerSDF(st, 5), .25);\n        color -= step(.95, starSDF(rotate(st, 0.628), 5, .1));\n        color = clamp(color, 0., 1.);\n        float circle = circleSDF(st);\n        color -= stroke(circle, .1, .05);\n        color += stroke(circle, .8, .07);\n        break;\n    }\n    case 47: { // the fool\n        color = step(.5, spiralSDF(st, .13));\n        break;\n    }\n    case 48: { // enlightenment\n        color = 1.;\n        break;\n    }\n    case 49: { // elements. Added by me. Approximated\n        st = st.yx;\n        float d = .15;\n        color = fill(circleSDF(st - vec2(cos(TAU / 3.), sin(TAU / 3.)) * d), .3);\n        color += fill(circleSDF(st - vec2(cos(TAU / 3. * 2.), sin(TAU / 3. * 2.)) * d), .3);\n        color += fill(circleSDF(st - vec2(d, 0.)), .3);\n        st = st.yx;\n        st.y = 1. - st.y;\n        color = flip(color, fill(triSDF(st-vec2(0, .03)), .13));\n        color += stroke(circleSDF(st), .8, .08);\n        break;\n    }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float coordAspectRatio = iResolution.y / iResolution.x;\n    \n    vec2 count = vec2(10, 5);\n    float tileW = iResolution.x / count.x;\n    float tileH = iResolution.y / count.y;\n    float tileAspectRatio = tileH / tileW;\n    \n    vec2 tileXY = floor(uv * count);\n    // coordinates for each tile\n    vec2 st = vec2(\n        uv.x * count.x - tileXY.x, \n        (uv.y * count.y - tileXY.y - 0.5) * tileAspectRatio + .5\n    );\n\n    vec2 gridBars = clamp(cos(uv * TAU * count) * 10. - 9.8, 0., 1.); // ---^---^---\n    float grid = max(gridBars.x, gridBars.y);\n    \n    float color = draw(st, tileXY, count);\n    color = clamp(color + grid, 0., 1.);\n    \n    if (iMouse.z > 0.01) {\n        tileXY = floor(iMouse.xy / iResolution.xy * count);\n        st.x = (uv.x - .5) / coordAspectRatio + .5;\n        st.y = uv.y;\n        \n        color *= 0.15;\n        color += clamp(draw(st, tileXY, count), 0., .85);\n    }\n    \n    fragColor = vec4(color);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}