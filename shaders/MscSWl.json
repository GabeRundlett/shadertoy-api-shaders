{
    "Shader": {
        "info": {
            "date": "1462051742",
            "description": "Shows how you can build soft shadows and camera blur using a conetracer (raytracer with thickened rays) approach.\n\nJust a simple demo of the technique, not a production version. ",
            "flags": 1,
            "hasliked": 0,
            "id": "MscSWl",
            "likes": 24,
            "name": "Blurry Conetracer",
            "published": 3,
            "tags": [
                "raytracer",
                "antialiasing",
                "conetracer"
            ],
            "usePreview": 0,
            "username": "olawlor",
            "viewed": 1412
        },
        "renderpass": [
            {
                "code": "/*\nA toy GLSL demonstration of \"conetracing\", a raytracing variant\nthat uses thicker cones instead of thin rays, which gives us cheap:\n  - Single-sample soft shadows\n  - Antialiased object edges\n  - Camera blurring\n  - Blurry reflections\n\nThe scene is hardcoded here, and generally just a toy demo implementation.\n\nSee the original SIGGRAPH 1984 paper \"Ray Tracing with Cones\" by John Amanatides,\nor Cyril Crassin's Pacific Graphics 2011 \"Interactive Indirect Illumination Using Voxel Cone Tracing\".\n\nThis version by Dr. Orion Lawlor, lawlor@alaska.edu\nCodebase stretches back to the 1990's, this version 2016-04-30 \nCode released as Public Domain (though attribution is welcome!)\n*/\n/********************* Conetracer utilities ***************/\n\n/**\ncircleSliceArea:\nReturn the area of:\n\t the portion of a circle, centered at the origin with radius 1, \n\t which has x-coordinate greater than frac.\n\t -1<=frac<=1\n\ni.e. return the area in #'s:\n\n<pre>\n    y\n \n    ^\n    |<---- 1 ---->|\n_--------___\n    |       -_         \n    |        |\\_        \n    |        |##\\         \n    |        |###\\       \n    |        |####|       \n    |        |####|    \n----+--------+####+-----> x \n    |        |####| \n    |        |####|       \n    |        |###/       \n    |        |##/        \n    |        |/        \n_   |   ___--         \n -------\n -->|  frac  |<--\n</pre>\n\nThis value is also equal to the integral\n      / 1\n      |\n      | 2*sqrt(1-x^2) dx\n      |\n      / frac\n(multiply by r^2 to get the area for a non-unit circle)\n*/\nfloat circleSliceArea(float frac)\n{\n\tfloat half_pi=3.14159265358979/2.0;\n\treturn (\n\t\thalf_pi-\n\t\tfrac*sqrt((1.0-frac)*(1.0+frac))-\n\t\tasin(frac)\n\t\t);\n}\n\nstruct circleOverlap_t {\n\tfloat f1; // fraction of circle 1 overlapped by circle 2\n\tfloat f2; // fraction of circle 2 overlapped by circle 1\n};\n\n/*circleOverlap:\nGiven two circles with radii 1.0 and r2, \nwith centers separated by a distance d, return \nthe fraction f1 of circle 1 overlapped by circle 2, and \nthe fraction f2 of circle 2 overlapped by circle 1.\n*/\n//(Version with r1 not fixed to 1.0)\ncircleOverlap_t circleOverlap(float r1,float r2,float d)\n{\n\tcircleOverlap_t r;\n\tif (r1+r2<=d) //Circles do not overlap at all\n\t\t{r.f1=0.0; r.f2=0.0;}\n\telse if (d+r2<=r1) //Circle 2 entirely in circle 1\n\t\t{r.f1=r2*r2/(r1*r1); r.f2=1.0;}\n\telse if (d+r1<=r2) //Circle 1 entirely in circle 2\n\t\t{r.f1=1.0; r.f2=r1*r1/(r2*r2);}\n\telse {\n\t//Circles partially overlap, creating a crescent shape\n\t//Compute the area of the circles\n\t\tfloat pi=3.14159265358979;\n\t\tfloat area1=r1*r1*pi;\n\t\tfloat area2=r2*r2*pi;\n\t//Compute area of overlap region\n\t\tfloat alpha=(r1*r1+d*d-r2*r2)/(2.0*d);\n\t\tfloat beta=d-alpha;\n\t\tfloat area_overlap=r1*r1*circleSliceArea(alpha/r1)+\n\t\t                  r2*r2*circleSliceArea(beta/r2);\n\t\tr.f1=area_overlap/area1;\n\t\tr.f2=area_overlap/area2;\n\t}\n\treturn r;\n}\n\n\n/***************************** shared vertex/fragment code *********************/\nvec3 camera; // location of camera center\nvec3 L=normalize(vec3(0.8,-0.5,0.7)); // points toward light source\nfloat time; // time, in seconds\n\n\n/* Raytracer framework */\nconst float invalid_t=1.0e3; // far away\nconst float close_t=1.0e-3; // too close (behind head, self-intersection, etc)\n\n/* This struct describes a ray */\nstruct ray_t {\n\tvec3 C; // start point of ray (typically the camera, hence the name C)\n\tvec3 D; // direction of ray \n\t\n\tfloat r_start; // radius of cone at start of ray\n\tfloat r_per; // change in radius as a function of (unit) ray parameter T\n};\n\n/* Return the location along this ray at this t value. */\nvec3 ray_at(ray_t ray,float t) {\n\treturn ray.C+t*ray.D;\n}\n\n/* Return the radius of this ray at this t value. \n   The \"abs\" allows camera rays to narrow down, then expand again.\n*/\nfloat ray_radius(ray_t ray,float t) {\n\treturn ray.r_start + abs(t*ray.r_per);\n}\n\n\n\n/* This struct describes how a surface looks */\nstruct surface_hit_t {\n\tfloat shiny; /* 0: totally matte surface; 1: big phong highlight */\n\tvec3 reflectance; /* diffuse color */\n\tfloat mirror; /* proportion of perfect mirror specular reflection (0.0 for non-mirror) */\n\tfloat solid; /* if <1.0, object is emissive only */\n};\n\n\n/* This struct describes everything we know about a ray-object hit. */\nstruct ray_hit_t {\n\tvec3 P; /* world coords location of hit */\n\tvec3 N; /* surface normal of the hit */\n\tfloat t; /* ray t value at hit (or invalid_t if a miss) */\n\tfloat exit_t; /* where to continue world walk on a miss */\n\tfloat frac; /* fraction of ray that is covered by this object (0.0: none; 1.0: all)*/\n\tfloat shadowfrac; /* fraction of ray that is covered by all objects (0.0: none; 1.0: all)*/\n\tsurface_hit_t s;\n};\n\nvec3 calc_world_color(vec3 C,vec3 D);\n\n/* Return the t value where this ray hits \n    the sphere with this center and radius. */\nvoid sphere_hit(inout ray_hit_t rh,ray_t ray,   // ray parameters\n\t\tvec3 center,float r, // object parameters\n\t\tsurface_hit_t surface)  // shading parameters\n{\n\t// solve for ray-object intersection via quadratic equation:\n\t//   0 = a*t^2 + b*t + c\n\tfloat a=dot(ray.D,ray.D);\n\tfloat b=2.0*dot(ray.C-center,ray.D);\n\tfloat closest_t=-b/(2.0*a); // ray T value at closest approach point\n\tfloat ray_rad=ray_radius(ray,closest_t); // radius at closest approach\n\tfloat center_to_center=length(ray_at(ray,closest_t)-center); // distance between centers\n\tcircleOverlap_t overlap=circleOverlap(r,ray_rad,center_to_center);\n\tfloat rayFrac=min(overlap.f2,1.0);\n\tif (rayFrac==0.0) return; // ray misses completely\n\t\n\tfloat first_t, last_t;\n\tfirst_t=last_t=closest_t; // ray-object intersection point\n\tfloat c=dot(ray.C-center,ray.C-center)-r*r;\n\tfloat det=b*b-4.0*a*c;\n\tif (det>=0.0) { /* a real hit (not just a glancing edge hit) */\n\t\tfloat entr_t=(-b-sqrt(det))/(2.0*a); /* - intersection == entry point */\n\t\tfloat exit_t=(-b+sqrt(det))/(2.0*a); /* + intersection == exit point */\n\t\tif (entr_t>close_t) first_t=entr_t;\n\t\tif (exit_t>close_t) last_t=exit_t;\n\t}\n\t\n\tif (first_t<close_t) return; /* behind head */\n\t\n\t// Add shadow contribution regardless of sort order:\n\t//rh.shadowfrac=max(rh.shadowfrac,rayFrac);  // max shadows (weird voronoi look on boundaries)\n\trh.shadowfrac=min(1.0,rh.shadowfrac+rayFrac);  // sum shadows (still looks a little weird)\n\t\n\tif (first_t>rh.t) return; /* beyond another object */\n\t\n\tvec3 P=ray_at(ray,first_t); // ray-object hit point (world coordinates)\n\t\n\t/* If we got here, we're the closest hit so far. */\n\trh.s=surface;\n\trh.t=first_t; // hit location\n\trh.exit_t=last_t; /* continue walk from exit point */\n\trh.P=P;\n\trh.N=normalize(P-center); // sphere normal is easy!\n\trh.frac=rayFrac; \n\t\n}\n\n/* Return a ray_hit for this world ray.  Tests against all objects (in principle). */\nray_hit_t world_hit(ray_t ray,float is_shadowray)\n{\n\tray_hit_t rh; rh.t=invalid_t; rh.frac=rh.shadowfrac=0.0;\n\t\n// Intersect new ray with all the world's geometry:\n    if (is_shadowray<0.5) {\n        // The Sun\n        sphere_hit(rh,ray, L*100.0,10.0,\n             surface_hit_t(0.0,vec3(10.0),0.0,0.0));\n    }\n    \n\t// Black camera sphere\n\tsphere_hit(rh,ray, camera,0.2,\n\t\t surface_hit_t(1.0,vec3(0.0,0.0,0.0),0.0,1.0));\n\t\n\t// Big brown outer sphere\n\tsphere_hit(rh,ray, vec3(0.0,0.0,-115.0),105.0,\n\t\t surface_hit_t(1.0,vec3(0.4,0.3,0.2),0.0,1.0));\n\t\n\t// Big green outer sphere\n\tsphere_hit(rh,ray, vec3(0.0,0.0,-11.5),10.7,\n\t\t surface_hit_t(1.0,vec3(0.2,0.6,0.4),0.3,1.0));\n\n\t// Wavy lines of floating red spheres\n\tfor (float i=-2.0;i<=2.0;i+=1.0) \n\tfor (float j=-2.0;j<=2.0;j+=1.0) \n\t{\n\t\tvec2 loc=vec2(i*2.0,j*2.0);\n\t\t// float r=length(loc)/10.0; // around green sphere\n\t\tfloat z=0.0;\n\t\tsphere_hit(rh,ray, vec3(loc,abs(3.0*sin(i*j+time))-z),0.3+1.0*fract(0.3*i*j),\n\t\t\t surface_hit_t(1.0,vec3(0.8,0.4,0.4),0.2,1.0));\n\t}\n\t\n\treturn rh;\n}\n\n/* Compute the world's color looking along this ray */\nvec3 calc_world_color(ray_t ray) {\n\tvec3 skycolor=vec3(0.4,0.6,1.0);\n\tvec3 color=vec3(0.0);\n\tfloat frac=1.0; /* fraction of object light that makes it to the camera */\n\t\n\tfor (int bounce=0;bounce<8;bounce++) \n\t{\n\t\tray.D=normalize(ray.D);\n\t/* Intersect camera ray with world geometry */\n\t\tray_hit_t rh=world_hit(ray,0.0);\n\n\t\tif (rh.t>=invalid_t) {\n\t\t\tcolor+=frac*skycolor; // sky color\n\t\t\tbreak; // return color; //<- crashes my ATI\n\t\t}\n\n\t/* Else do lighting */\n\t\tif (rh.s.solid>0.5) { // solid surface \n\t\t\tif (dot(rh.N,ray.D)>0.01) rh.N=-rh.N; // flip normal to face right way\n            \n            /*\n            // Phong (crude hack, 'sun' sphere works better)\n\t\t\tvec3 H=normalize(L+normalize(-ray.D));\n            float specular=rh.s.shiny*pow(clamp(dot(H,rh.N),0.0,1.0),500.0);\n            */\n\t\t\tfloat diffuse=clamp(dot(rh.N,L),0.0,1.0);\n\n\t\t\t// check shadow ray \n\t\t\tray_t shadow_ray=ray_t(rh.P,L, ray_radius(ray,rh.t),0.01);\n\t\t\tray_hit_t shadow=world_hit(shadow_ray,1.0);\n\t\t\tif (shadow.t<invalid_t) {\n\t\t\t\tfloat illum=1.0-shadow.shadowfrac;\n\t\t\t\tdiffuse*=illum; \n\t\t\t\t//specular*=illum; \n\t\t\t}\n\n\t\t\tfloat ambient=0.05;\n\n\t\t\tvec3 curObject=(ambient+diffuse)*rh.s.reflectance; // +specular*vec3(1.0);\n\t\t\t\n\t\t\tcolor+=frac*rh.frac*curObject;\n\t\t\t//color=rh.N; // debug: show surface normal at hit\n        } else { // emissive object\n            color+=frac*rh.frac*rh.s.reflectance;\n        }\n\t\t\n\t/* Check for ray continuation */\n\t\tif (rh.frac<1.0) \n        { // partial hit--continue ray walk to composite background\n\t\t\tif (rh.s.mirror>0.0) { // uh oh, need two recursions\n\t\t\t\t// fake partial mirror using sky light\n\t\t\t\tcolor+=frac*rh.frac*rh.s.mirror*skycolor;\n\t\t\t\t//color+=vec3(1,0,0); \n\t\t\t}\n\t\t\t\n\t\t\tfrac*=(1.0-rh.frac);\n\t\t\t\n\t\t\tfloat t=rh.exit_t+0.1;\n\t\t\tray.r_start=ray_radius(ray,t);\n\t\t\tray.C=ray_at(ray,t);\n\t\t}\n\t\telse if (rh.s.mirror>0.0) { // mirror reflection\n\t\t\tfrac*=rh.s.mirror;\n\t\t\tfloat t=rh.t;\n\t\t\tray.r_start=ray_radius(ray,t);\n            float curvature=10.0; // HACK: should depend on radius\n            ray.r_per=curvature*ray.r_per; \n\t\t\tray.C=ray_at(ray,t);\n\t\t\t//color+=rh.s.mirror*calc_world_color(rh.P,reflect(D,rh.N));\n\t\t\tray.D=reflect(ray.D,rh.N); // bounce off normal\n\t\t}\n\t\telse break;\n\t\tif (frac<0.005) return color;\n\t} \n\t\n\treturn color;\n}\n\n/* \n// Old GLSL main \nuniform vec3 camera; // world coordinates of camera\nvarying vec4 myColor;\nvarying vec3 location; // world coordinates of our pixel\n\nvoid main(void) {\n\tvec3 C=camera; // origin of ray (world coords)\n\tvec3 D=location-camera; // direction of ray (world coords)\n\tray_t camera_ray=ray_t(C,D,0.0,2.0/768.0);\n\n\tgl_FragColor.rgb=calc_world_color(camera_ray);\n\tgl_FragColor.a=1.0; // opaque\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx-0.5;\n    vec2 mouse = iMouse.xy / iResolution.xy-0.5;\n    time=iTime;\n    camera=vec3(5.0*mouse.x,-10.0,5.0+5.0*mouse.y);\n    \n\tvec3 C=camera; // origin of ray (world coords)\n\tvec3 D=normalize(vec3(uv.x,1.0,uv.y-0.2)); // direction of ray (world coords)\n\n    float blur=abs(10.0*sin(0.5*time)); // wild time-dependent blurring\n   \t//float blur=1.3; // reasonable antialiasing\n    ray_t camera_ray=ray_t(C,D,0.1/iResolution.x,blur/iResolution.x);\n\n\tfragColor=vec4(calc_world_color(camera_ray),1.0);\n}\n\n\n// VR stuff is UNTESTED!\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float blur=1.3;\n    ray_t camera_ray=ray_t(fragRayOri+vec3(0.0,-10.0,0.0),fragRayDir,0.1/iResolution.x,blur/iResolution.x);\n\tfragColor=vec4(calc_world_color(camera_ray),1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}