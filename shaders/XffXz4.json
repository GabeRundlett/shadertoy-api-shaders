{
    "Shader": {
        "info": {
            "date": "1706616872",
            "description": "moving sphere in a box",
            "flags": 0,
            "hasliked": 0,
            "id": "XffXz4",
            "likes": 2,
            "name": "see the speed",
            "published": 3,
            "tags": [
                "raymarch",
                "spheretrace"
            ],
            "usePreview": 0,
            "username": "silica163",
            "viewed": 163
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265\n#define MAX 40.\n#define MIN .001\n#define STEP 256\n\nvec3 l = vec3(20,14,20);\nvec3 N,L,V,R;\nvec3 sp,nextp,movedir,ndir;\nmat3 rot;\nfloat speed;\n#define rotX(a) mat3(      1,      0,      0,      0, cos(a),-sin(a),      0, sin(a), cos(a))\n#define rotY(a) mat3( cos(a),      0, sin(a),      0,      1,      0,-sin(a),      0, cos(a))\n#define rotZ(a) mat3( cos(a),-sin(a),       0,sin(a), cos(a),      0,      0, 0,      1)\n#define rot2D(a) mat2(cos(a), sin(a), -sin(a),cos(a))\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nmat3 yToNormal(vec3 N){\n    const int S = 3;\n    vec3 s[S];\n    \n    s[0] = N;\n    s[1] = normalize(cross(normalize(s[0]+vec3(.1,0,0)),s[0]));\n    s[2] = normalize(cross(s[0],s[1]));\n    \n    return mat3(s[1],s[0],s[2]);\n}\n\n\n// transform matrix that rotate normal vector to Y \nmat3 normalToY(vec3 N){\n    return inverse(yToNormal(N));\n}\n\nfloat max3(vec3 n){\n    return max(n.x,max(n.y,n.z));\n}\n\nfloat cubeSDF(vec3 p,vec3 cp,vec3 cs){\n    vec3 c = abs(p-cp)-cs;\n    return length(max(c,0.)) + min(0.,max3(c));\n}\n\n\nfloat smin(float a, float b, float k){\n    float r = min(a,b) - pow(max(0.,k - abs(a - b)/k)*.5,2.);\n    return r;\n}\n\nfloat smax(float a, float b, float k){\n    float r = max(a,b) + pow(max(0.,k - abs(b - a)/k)*.5,2.);\n    return r;\n}\n\nfloat diffuse(vec3 N,vec3 L){\n\treturn max(dot(N,normalize(L)),0.);\n}\n\nfloat bPhong(vec3 N,vec3 L,vec3 V){\n\tfloat c = 0.;\n\tfloat d = diffuse(N,L);\n\t\n\tc += pow(max(dot(normalize(L+V),N),0.),16.) * d;\n\t\n\treturn c;\n}\n\n// phong\nfloat phong(vec3 N,vec3 L,vec3 V){\n    float c = 0.;\n    float d = diffuse(N,L);\n    vec3 lRef = reflect(-L,N);\n    \n    c = pow(max(dot(lRef,V),0.),32.) * d;    \n    return c;\n}\n\nfloat dot2(vec3 p){\n    return dot(p,p);\n}\n\nvec2 dist(vec3 p){\n    float d = MAX;\n    \n    float spl = (length(p-sp)-1.);\n    \n    float bbdisp = dot(p-sp,movedir)*.1;\n    float b1 = length(p-sp)-2.5- bbdisp;\n    float b2 = length(p-sp)-3.-bbdisp;\n    float b3 = length(p-sp)-3.5-bbdisp;\n    float b4 = length(p-sp)-4.-bbdisp;\n    float b5 = length(p-sp)-4.5-bbdisp;\n    \n    float bb = min(min(abs(b1),abs(b2)),min(abs(b3),abs(b4)))*.5;\n    //d = smax(-d,p.y-.1 - .2*sin(length(p.xz-sp.xz)*2.-1.-dot(p.xz-sp.xz,(sp.xz-nextp.xz)/.01)*.5),.5)*.7;\n    //d = min(d,b5);\n    //d = smax(-d,p.y,.5);\n    d = min(d,-cubeSDF(p,vec3(0),vec3(40,15,15)));\n    //spl = cubeSDF(p,sp,vec3(1));\n    d = min(d,spl);\n    d = min(bb,d);\n    float ll = length(p-l)-2.;\n    d = min(ll,d);\n    \n    float mat = 0.;\n    if(spl == d) mat = 1.;\n    if(bb == d) mat = 3.;\n    if(ll == d) mat = 2.;\n    \n    return vec2(d,mat);\n}\n\nvec3 sNormal(vec3 p){\n\tvec2 t = vec2(MIN,0);\n\tfloat d = abs(dist(p).x);\n\t\n\treturn normalize(d - vec3(\n\t\tdist(p-t.xyy).x,\n\t\tdist(p-t.yxy).x,\n\t\tdist(p-t.yyx).x\n\t));\n}\n\nfloat SSAO(vec3 p, vec3 N){\n    float sum = 0.;\n    \n    sum += max(dist(p+N*.01).x,0.);\n    \n    for(float i = 0.;i<2.;i++){\n        for(float j = 0.;j<8.;j++){\n        \n            mat3 sampleRot = rotY((PI/4.)*j)*rotX((PI/4.)*i);\n            vec3 dp = sampleRot*(vec3(0,1,0)*.01);\n            float d = max(dist(p+dp).x,0.);\n            \n            sum+=d;\n            /*if(d < 0.){\n                sum--;\n            }*/\n        }\n    }\n    \n    return clamp(sum+.7,0.,1.);\n}\n\nvec4 march(vec3 ro,vec3 rp,vec3 rd,inout int mat){\n    float rl = 0.;\n    for(int s = 0;s < STEP;s ++){\n        rp = ro + rd * rl;\n        vec2 _d = dist(rp);\n        float d = _d.x;\n        mat = int(_d.y);\n        if(d >= MAX){\n            rl = MAX+1.;\n            break;\n        }\n        if(d <= MIN)break;\n        rl += d;\n    }\n    return vec4(rp,rl);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy/iResolution.xy)*2.-1.;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.5;\n    vec3 c = vec3(0);\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    m *= vec2(.5,1);\n    m += vec2(0,-1.);\n    if(iMouse.z < 1.){\n        m.x = iTime*.05;\n        m.y = -.8;\n    }\n    vec3 ca = vec3(PI+m.y*PI/2.,PI/2.+m.x*PI/1.,0);\n\t\n\tmat3 rotX = mat3(\n\t\t1,         0,        0,\n\t\t0, sin(ca.x),cos(ca.x),\n\t\t0,-cos(ca.x),sin(ca.x)\n\t);\n\t\n\tmat3 rotY = mat3(\n\t\t sin(ca.y),0, cos(ca.y),\n\t\t0,         1,         0,\n\t\t-cos(ca.y),0, sin(ca.y)\n\t);\n    \n    vec3 ro = rotY*rotX*vec3(0,0,14);\n    vec3 rd = normalize(rotY*rotX*vec3(uv*5.,0)-ro);\n    float rl = 1.;\n    vec3 rp = ro + rl * rd;\n    int mat = 0;\n    \n    // ---------------\n    speed = iTime*2.;\n    float dt = .1;\n    sp = vec3(sin(speed/3.)*20.,1,cos(speed/5.)*3.);\n    nextp = vec3(sin((speed+dt)/3.)*20.,1,cos((speed+dt)/5.)*3.);\n    movedir = (sp-nextp)/dt;\n    //p.xz += sp.xz;\n    \n    //float spl = length(p-sp)-1.;  \n    ndir = normalize(movedir);\n    rot = yToNormal(ndir);\n    \n    // ---------------\n    \n    vec4 hit = march(ro,rp,rd,mat);\n    rp = hit.rgb;\n    rl = hit.w;\n    \n    V = -rd;\n    N = sNormal(rp);\n    L = normalize(l-rp);\n    R = reflect(rd,N);\n    \n    //float AO = SSAO(rp,N);\n    \n    c = vec3(clamp(dot(L,N),0.,1.))+.1;\n    //c += float(marchCount)/float(STEP);\n    //c *= vec3(AO);\n    //c += exp(-rl)+.1;\n    \n    c = N*.5+.5;\n    c = vec3(0.);\n    float f = 1.;\n\n    for(int i = 0;mat==3;i++){\n        //if(dist(rp).x >= MAX)f = 0.;\n        //if(rp.y >= MAX)f = 0.;\n        c += .01*dot2(movedir)*min(max(1./length((rp-sp)*rot+vec3(0,5,0)),0.1),1.);\n        //c+= N;\n        //c += .1*pow(max(dot(normalize(L+V),N),0.),32.);\n        rp = rp + rd*.1;\n        hit = march(rp,rp,rd,mat);\n        rp = hit.rgb;\n        rl += hit.w;\n        V = -rd;\n        N = sNormal(rp);\n        L = normalize(l-rp);\n        R = reflect(rd,N);\n        if(dist(rp).x > MAX)break;\n    }\n    \n    if(dist(rp).x >= MAX)f = 0.;\n    //if(rp.y >= 1.)f = 0.;\n    switch(mat){\n        case 0:\n            //rp += sp;\n            //c *= 0.;\n            vec3 oc = (N*.5+.5);\n            //oc = vec3(1);\n            c += clamp((ceil(cos(rp.x*.51*PI)*cos(rp.z*.51*PI)*cos(rp.y*.51*PI))+.5)*.5*f*oc+bPhong(N,L,V)*.5,0.,1.);\n            //c *= texture(iChannel0,R).rgb;\n            break;\n       case 1:\n            //c += .5*(N*.5+.5)+bPhong(N,L,V)*.5;\n            c += diffuse(L,N)*.5+bPhong(N,L,V)*.5;\n            break;\n       case 2:\n           c += 1.;\n           break;\n    }\n    \n    //c = vec3(rl/100.);\n    \n    //c = fract(rd*2.);\n    //c = fract(rp*.1);\n    //c = R*.5+.5;\n    \n    //c = vec3(dist(rp+rotX(PI/2.)*N*.1));\n    \n    //c *= 0.;\n    //c += length(uv - vec2(sin(iTime*2.),cos(iTime)));\n    \n    //if(length(rp) >= MAX)c = vec3(0.);\n    //c *= 0.;\n    //c *= 5./rl;\n    fragColor = vec4(c,1.0);\n    //fragColor = vec4(sin(rp+cos(rp.zxy)*.5+sin(rp.yzx)*2.),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}