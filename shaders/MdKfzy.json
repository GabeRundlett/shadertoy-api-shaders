{
    "Shader": {
        "info": {
            "date": "1552166418",
            "description": "looks pretty cool. needs numpad with num lock on.\ncontrols: arrow keys+shift+ctrl for xyz movement and 2+0 for w. mouse+1+3 for xyz rotation, and 4+7,5+8 and 6+9 for w.\ntry drawgrid",
            "flags": 48,
            "hasliked": 0,
            "id": "MdKfzy",
            "likes": 8,
            "name": "random hexadecitree 4d",
            "published": 3,
            "tags": [
                "3d",
                "tree",
                "4d",
                "hexadecitree"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 515
        },
        "renderpass": [
            {
                "code": "#define detail 5\n#define supersampling 1.0 //blurs together neighboring 4d slices (looks pretty bad)\n#define blurring 0.1\n#define steps 100\n#define time iTime*0.5\n#define maxdist 50.0\n\n//draw octree grid to see the subdivisions\n//#define drawgrid\n//#define borders\n#define blackborders\n#define objects\n\n#define rot(spin) mat2(sin(spin),cos(spin),cos(spin),-sin(spin))\n\n//random function from https://www.shadertoy.com/view/MlsXDf\nfloat rnd(vec4 v) { return fract(4e4*sin(dot(v,vec4(13.46,41.74,-73.36,14.24))+17.34)); }\n\n//0 is empty, 1 is subdivide and 2 is full\nint getvoxel(vec4 p, float size) {\n    /*if ((p.x==0.0||p.x==2.0)&&p.y==0.0) {\nreturn 0;\n}*/\n\n    float val = rnd(vec4(p+size*0.33));\n\n    if (val < 0.6) {\n        return 0;\n    } else if (val < 0.9) {\n        return 1;\n    } else {\n        return 2;\n    }\n\n    //return int(val*val*3.0);\n}\n\n//ray-cube intersection, on the inside of the cube\nvec4 voxel(vec4 ro, vec4 rd, float size)\n{\n    size *= 0.5;\n\n    vec4 hit = -(sign(rd)*(ro-size)-size)/max(abs(rd),0.001);\n\n    return hit;\n}\n\nvec4 memory(int i) {\n    return texelFetch(iChannel0,ivec2(i,0),0);\n}\n\nvoid mainImage( out vec4 fragColor,  vec2 fragCoord )\n{\n\n    fragColor = vec4(0.0);\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) /iResolution.y;\n\n\n    vec4 cam = memory(4);\n\n    mat4 rotation = mat4(\n        memory(0),\n        memory(1),\n        memory(2),\n        memory(3));\n\n    bool preview = dot(abs(cam-vec4(0.51)),vec4(1))<0.01 &&\n        rotation == mat4(1,0,0,0,\n                         0,1,0,0,\n                         0,0,1,0,\n                         0,0,0,1);\n\n    for (float j = -1.0+min(0.0,iTime); j <= 1.0; j+=2.0/max(supersampling-1.0,0.1)) {\n        vec4 ro = cam;\n        //ro.w += j*0.1;\n        vec4 rd = vec4(uv,j*blurring,1);\n\n        if (supersampling == 1.0)\n            rd.z = 0.0;\n        //    cam.z = 0.0;\n\n        rd = normalize(rd);\n        if (preview) {\n            rd.xy *= rot(iTime*0.1);\n            rd.xz *= rot(iTime*0.1);\n            rd.xw *= rot(iTime*0.1);\n            rd.yz *= rot(iTime*0.1);\n            rd.yw *= rot(iTime*0.1);\n            rd.zw *= rot(iTime*0.1);\n            ro = rd*0.5+sin(iTime*vec4(0.1,0.14,0.12,0.15))*(iTime*0.1+1.0);\n        } else {\n            rd *= transpose(rotation);\n        }\n\n        //if the mouse is in the bottom left corner, don't rotate the camera\n        /*if (length(iMouse.xy) > 40.0) {\n            rd.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            rd.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }*/\n        float size = 1.0;\n        vec4 lro = mod(ro,size);\n        vec4 fro = ro-lro;\n        vec4 mask;\n        bool exitoct = false;\n        int recursions = 0;\n        float dist = 0.0;\n        int i;\n        float edge = 1.0;\n\n        //the octree traverser loop\n        //each iteration i either:\n        // - check if i need to go up a level\n        // - check if i need to go down a level\n        // - check if i hit a cube\n        // - go one step forward if hypercube is empty\n        for (i = 0; i < steps; i++)\n        {\n            if (dist > maxdist) break;\n            int voxelstate = getvoxel(fro,size);\n\n            //i go up a level\n            if (exitoct)\n            {\n\n                vec4 newfro = floor(fro/size*0.5+0.25)*size*2.0;\n\n                lro += fro-newfro;\n                fro = newfro;\n\n                recursions--;\n                size *= 2.0;\n\n                exitoct = (recursions > 0) && (abs(dot(mod(fro/size+0.5,2.0)-1.0+mask*sign(rd)*0.5,mask))<0.1);\n            }\n            //subdivide\n            else if(voxelstate == 1&&recursions<=detail)\n            {\n                recursions++;\n                size *= 0.5;\n\n                //find which of the 16 voxels i will enter\n                vec4 mask2 = step(vec4(size),lro);\n                fro += mask2*size;\n                lro -= mask2*size;\n            }\n            //move forward\n            #ifdef objects\n            else if (voxelstate == 0||recursions > detail)\n                #else\n                else if (voxelstate == 0||voxelstate == 2||recursions > detail)\n                    #endif\n                {\n                    //raycast and find distance to nearest voxel surface in ray direction\n                    vec4 hit = voxel(lro, rd, size);\n                    if (hit.x < min(min(hit.y,hit.z),hit.w)) {\n                        mask = vec4(1,0,0,0);\n                    } else if (hit.y < min(hit.z,hit.w)) {\n                        mask = vec4(0,1,0,0);\n                    } else if (hit.z < hit.w) {\n                        mask = vec4(0,0,1,0);\n                    } else {\n                        mask = vec4(0,0,0,1);\n                    }\n                    float len = dot(hit,mask);\n\n                    //moving forward in ray direction, and checking if i need to go up a level\n                    dist += len;\n                    lro += rd*len-mask*sign(rd)*size;\n                    vec4 newfro = fro+mask*sign(rd)*size;\n                    exitoct = (floor(newfro/size*0.5+0.25)!=floor(fro/size*0.5+0.25))&&(recursions>0);\n                    fro = newfro;\n                }\n            else\n            {\n                break;\n            }\n            #ifdef drawgrid\n            vec4 q = abs(lro/size-0.5)*(1.0-mask);\n            edge = min(edge,-(max(max(max(q.x,q.y),q.z),q.w)-0.5)*80.0*size);\n            #endif\n        }\n\n        vec4 fc = vec4(0,0,0,1);\n\n        if(i < steps && dist < maxdist)\n        {\n            float val = fract(dot(fro,vec4(15.23,754.345,3.454,5.253)));\n            vec4 normal = -mask*sign(rd);\n            vec3 color = sin(val*vec3(39.896,57.3225,48.25))*0.5+0.5;\n            color *= dot(mask,vec4(0.9,0.8,1.0,0.85));\n\n            vec4 q = abs(lro/size-0.5)*(1.0-mask);\n            #ifdef borders\n            edge = clamp(-(max(max(max(q.x,q.y),q.z),q.w)-0.5)*20.0*size,0.0,edge);\n            #endif\n            #ifdef blackborders\n            color *= edge;\n            #else\n            color = 1.0-(1.0-color)*edge;\n            #endif\n            #ifdef fancy_lighting\n            vec3 light = vec3(2.5,0.5,time+2.0);\n\n\n\n            #endif\n            fc.rgb = color;\n        } else {\n            #ifdef blackborders\n            fc.rgb = vec3(edge);\n            #else\n            fc.rgb fragColor += vec3(1.0-edge);\n            #endif\n        }\n        fragColor += fc;\n        //fragColor += fc/(abs(j)*100.0+1.0);\n    }\n    fragColor /= fragColor.a;\n    fragColor = sqrt(fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MOVE_SPEED 1.0\n#define ROT_SPEED 0.5\n\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_FORW 38\n#define KEY_RIGHT 39\n#define KEY_LEFT 37\n#define KEY_BACK 40\n#define KEY_0 96\n#define KEY_1 97\n#define KEY_2 98\n#define KEY_3 99\n#define KEY_4 100\n#define KEY_5 101\n#define KEY_6 102\n#define KEY_7 103\n#define KEY_8 104\n#define KEY_9 105\n\n#define PLUS_X keys(KEY_RIGHT)\n#define PLUS_Y keys(KEY_SHIFT)\n#define PLUS_Z keys(KEY_2)\n#define PLUS_W keys(KEY_FORW)\n\n#define MINUS_X keys(KEY_LEFT)\n#define MINUS_Y keys(KEY_CTRL)\n#define MINUS_Z keys(KEY_0)\n#define MINUS_W keys(KEY_BACK)\n\n#define ROT_PLUS_0 keys(KEY_1)\n#define ROT_PLUS_1 keys(KEY_8)\n#define ROT_PLUS_3 keys(KEY_7)\n#define ROT_PLUS_5 keys(KEY_9)\n\n#define ROT_MINUS_0 keys(KEY_3)\n#define ROT_MINUS_1 keys(KEY_5)\n#define ROT_MINUS_3 keys(KEY_4)\n#define ROT_MINUS_5 keys(KEY_6)\n\nfloat keys(int i) {\n    return texelFetch(iChannel1,ivec2(i,0),0).x;\n}\n\nvec4 memory(int i) {\n    return texelFetch(iChannel0,ivec2(i,0),0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    if (int(fragCoord.y) == 0) {\n        int index = int(fragCoord.x);\n        if (index < 4) {\n            \n            vec4 lastm = memory(5);\n            \n            vec2 mouse = lastm.xy-iMouse.xy;\n            \n            if (lastm.z<0.0||iMouse.z<0.0) mouse = vec2(0.0);\n            \n            float[6] rot;\n            rot[0] = (ROT_PLUS_0-ROT_MINUS_0)*iTimeDelta*ROT_SPEED;\n            rot[1] = (ROT_PLUS_1-ROT_MINUS_1)*iTimeDelta*ROT_SPEED;\n            rot[2] = mouse.x*iTimeDelta*ROT_SPEED;\n            rot[3] = (ROT_PLUS_3-ROT_MINUS_3)*iTimeDelta*ROT_SPEED;\n            rot[4] = mouse.y*iTimeDelta*ROT_SPEED;\n            rot[5] = (ROT_PLUS_5-ROT_MINUS_5)*iTimeDelta*ROT_SPEED;\n            \n            \n            \n            \n            mat4 rotation = mat4(\n                memory(0),\n                memory(1),\n                memory(2),\n                memory(3));\n            \n            if (iFrame == 0) {\n                rotation = mat4(\n                    vec4(1,0,0,0),\n                    vec4(0,1,0,0),\n                    vec4(0,0,1,0),\n                    vec4(0,0,0,1));\n            }\n            \n            mat4 newrotation = rotation;\n            \n            newrotation[0] = (rotation[0]*cos(rot[0])+rotation[1]*sin(rot[0]));\n            newrotation[1] = (rotation[1]*cos(rot[0])-rotation[0]*sin(rot[0]));\n            \n            rotation = newrotation;\n            \n            newrotation[0] = (rotation[0]*cos(rot[1])+rotation[2]*sin(rot[1]));\n            newrotation[2] = (rotation[2]*cos(rot[1])-rotation[0]*sin(rot[1]));\n            \n            rotation = newrotation;\n            \n            newrotation[0] = (rotation[0]*cos(rot[2])+rotation[3]*sin(rot[2]));\n            newrotation[3] = (rotation[3]*cos(rot[2])-rotation[0]*sin(rot[2]));\n            \n            rotation = newrotation;\n            \n            newrotation[1] = (rotation[1]*cos(rot[3])+rotation[2]*sin(rot[3]));\n            newrotation[2] = (rotation[2]*cos(rot[3])-rotation[1]*sin(rot[3]));\n            \n            rotation = newrotation;\n            \n            newrotation[1] = (rotation[1]*cos(rot[4])+rotation[3]*sin(rot[4]));\n            newrotation[3] = (rotation[3]*cos(rot[4])-rotation[1]*sin(rot[4]));\n            \n            rotation = newrotation;\n            \n            newrotation[2] = (rotation[2]*cos(rot[5])+rotation[3]*sin(rot[5]));\n            newrotation[3] = (rotation[3]*cos(rot[5])-rotation[2]*sin(rot[5]));\n            \n            rotation = newrotation;\n            \n            fragColor = rotation[index];\n            \n            return;\n        }\n        if (index == 4) {\n            if (iFrame == 0) {\n                fragColor = vec4(0.51);\n                return;\n            }\n            \n            mat4 rotation = mat4(\n                memory(0),\n                memory(1),\n                memory(2),\n                memory(3));\n            \n            vec4 move = vec4(\n                PLUS_X-MINUS_X,\n                PLUS_Y-MINUS_Y,\n                PLUS_Z-MINUS_Z,\n                PLUS_W-MINUS_W)*iTimeDelta*MOVE_SPEED;\n            \n            fragColor += rotation*move;\n            \n            return;\n        }\n        if (index == 5) {\n            fragColor = iMouse;\n            return;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}