{
    "Shader": {
        "info": {
            "date": "1675203589",
            "description": "Best with music ",
            "flags": 64,
            "hasliked": 0,
            "id": "DtlXRl",
            "likes": 18,
            "name": "Pop Baby",
            "published": 3,
            "tags": [
                "2d",
                "music"
            ],
            "usePreview": 0,
            "username": "QuantumSuper",
            "viewed": 596
        },
        "renderpass": [
            {
                "code": "// PopBaby 0.76.230131\n// auto-vj bufferless\n//\n// - use with music in iChannel0 -\n\n\n#define PI 3.14159265359 \nfloat animTime;\nvec4 fft, ffts;\n\nvoid compressFft(){  \n\t// Sound (see shadertoy.com/view/Xds3Rr, assume? sound texture with 44.1kHz in 512 texels)\n    for (int n=1;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 86-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(2,8,7,4); ffts /= vec4(2,3,3,21); //normalize\n \n    //fft.x *= fft.x; //weaken weaker sounds, soft limit\n    //fft.x = smoothstep(.8,.9,fft.x); //weaken weaker sounds, semi hard limit\n    fft.x = step(.9,fft.x); //weaken weaker sounds, hard limit\n}\n\nfloat hash21(vec2 p){ //see The Art of Code on youtu.be/rvDo9LvfoVE\n    p = fract(p*vec2(13.81, 741.76));\n    p += dot(p, p+42.23);\n    return fract(p.x*p.y);\n}\n\nmat2 rotM(float deg){\n    deg /= 180./PI;\n    return mat2(cos(deg),-sin(deg),sin(deg),cos(deg));\n}\n\nfloat circ(vec2 p, float d){\n    return .05/abs(length(p)-d);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){ //a line between a and b in domain of p\n\tvec2 ab = b-a;\n\treturn .05/length(a+(ab)*clamp(dot(p-a,ab)/dot(ab,ab),0.,1.)-p);\n}\n\nfloat lines(vec2 p, vec2[4] coord, int maxCoord){ //maxCoord<=coord.length() (funs in glsl unfortunately dont take sizeless arrays)\n    float amp = 0.;\n    for (int n=0;n<maxCoord; n++){\n        amp += line(p, coord[n], coord[(n+1)%maxCoord]); //closed loop\n    }\n    return amp;\n}\n\nfloat particle(vec2 p){\n    return smoothstep(.1,.0,length(p)) * smoothstep(.1,.06,length(p-vec2(0.,.02)));\n}\n\nfloat dustLayer(vec2 p){\n    float id = hash21(floor(p));\n    return smoothstep(0.,1.,id)*particle((fract(p)-vec2(.5+.4*cos(id*animTime),.5+.4*sin(.8*id*animTime)))*rotM(id*360.)/vec2(cos(.5*id*animTime),1)); //...is there performance gain in doing this rather than via sub steps?\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){   \n    float maxRes = max(iResolution.x, iResolution.y);\n    vec2 uv = (2.*fragCoord-iResolution.xy) / maxRes; //-1..1 on longer side\n    vec3 col; float aFrac, amp = 0.; \n    animTime = 2.133333*iTime;\n    fft  = vec4(0), ffts = vec4(0);\n    compressFft();\n\n    // Dust layers \n    for (float n=0.;n<4.;n++){\n        aFrac = fract(-.05*animTime+.25*n)-.02*fft.w*fft.w*fft.w;\n        amp += 1.4*(.2+.8*fft.z)*dustLayer((uv+n*vec2(.1,.05))*25.*aFrac)*smoothstep(1.,.33,aFrac);\n    }\n    amp *= (.7+.5*length(uv)); //anti-vignette \n    \n    // Symbols\n    vec2[] myBox = vec2[](\n        vec2( 1, 1),\n        vec2( 1,-1),\n        vec2(-1,-1),\n        vec2(-1, 1)\n    );\n    vec2[] myTri = vec2[](\n        vec2(          0, 1),\n        vec2( cos(PI/6.), -sin(PI/6.)),\n        vec2(-cos(PI/6.), -sin(PI/6.)),\n        vec2(0)\n    );\n    aFrac = fract(.5*animTime+4.*cos(.04*animTime));\n    if (aFrac<1./3.){ //square\n        amp += fft.y*lines(5.*uv/(.8+.4*ffts.w), myBox, 4); //relative normalized to area h*w\n    } else if (aFrac<2./3.){ //triangle\n        amp += fft.y*lines(5.*sqrt((1.+sin(PI/6.))*cos(PI/6.)/4.)*uv*rotM(-5.*animTime)/(.8+.4*ffts.w), myTri, 3); //relative normalized to area h*l/2. = r2*(1.+sin(PI/6.))*cos(PI/6.)\n    } else {//circle\n        amp += fft.y*circ(5.*sqrt(PI/4.)*uv/(.8+.4*ffts.w), 1.); //relative normalized to area PI*r2\n    }\n    col = vec3(amp*amp); //light falloff correction\n    col *= vec3(ffts.x<=ffts.y,ffts.y<=ffts.z,ffts.z<=ffts.x); //colors\n    \n    // Flash bars\n    float maxY = (maxRes == iResolution.x) ? 1. : iResolution.y/maxRes;\n    amp = fft.x*.03/abs(abs(uv.y)-2.*maxY*fract(animTime));\n    col += amp*amp; //light falloff correction\n    \n    // Utility\n    //amp = dot(fft,vec4(step(.5,-uv.x),step(0.,-uv.x)*step(-uv.x,.5),step(0.,uv.x)*step(uv.x,.5),step(.5,uv.x))); //compression bars, fft\n    //amp = dot(ffts,vec4(step(.5,-uv.x),step(0.,-uv.x)*step(-uv.x,.5),step(0.,uv.x)*step(uv.x,.5),step(.5,uv.x))); //compression bars, ffts\n    //amp = hash21(uv); //noise function\n    //col = vec3(amp);\n    \n\tcol = pow(col, vec3(.4545)); //gamma correction\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 32168,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/darklightrec/fedde-le-grand-let-the-1"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}