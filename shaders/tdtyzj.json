{
    "Shader": {
        "info": {
            "date": "1601537732",
            "description": "This demos a 3d variant of \"Single Sample Bicubic Sampling\" https://www.shadertoy.com/view/wtByDt.\ncamera controls via mouse + shift key",
            "flags": 48,
            "hasliked": 0,
            "id": "tdtyzj",
            "likes": 37,
            "name": "Single Sample Tricubic Sampling",
            "published": 3,
            "tags": [
                "noise",
                "volume",
                "clouds",
                "volumetric",
                "filtering",
                "cubic",
                "tricubic"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 1228
        },
        "renderpass": [
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nThis demos a 3d variant of \"Single Sample Bicubic Sampling\" https://www.shadertoy.com/view/wtByDt.\n\nThe direct generalization from 2d to 3d of the bicubic sampling routine would require two samples since in 3d we need 7 partial derivatives\nto fully parametrized a tricubic patch (texture1:{df/dx, df/dy, df/dz, f} + texture2:{ddf/dydz, ddf/dxdz, ddf/dxdy, dddf/dxdydz}).\n\nTo keep the number of required trilinear lookups at one we simply ignore the 2nd and 3rd order partial derivatives here (i.e texture2).\nWhile doing so leads to obvious artifacts when rendering hard surfaces the loss in quality is usually barely noticeable in the case of (fluffy) volumes.\nIt also doesn't appear to be necessary to ensure C2 continuity to prevent artifacts in the lighting when rendering volumes.\nThis is actually a major advantage as that means that the derivatives can hold additional information thereby increasing the fidelity of the reconstruction.\nThis is not the case when the derivatives are computed from the function samples (as is necessary when one wants to ensure C2 continuity).\nIn the optimal case directly sampling the derivatives from the contiuous function alongside the function value increases the effective sampling resolution\nby a factor of 2 in each dimension (btw. on a grid of value + derivative samples a perfectly band-limited signal is reconstructed using sinc^2 instead of sinc). \nSince we throw out the 2nd and 3rd order partial derivatives here we loose a chunk of resolution in the diagonal directions but it is still a significant win.\n\nCommon   - settings (SAMPLE_TRILINEARLY, COMPUTE_DERIVATIVES_FROM_VALUE_SAMPLES, VOLUME_RES)\nBuffer D - camera controls\nBuffer A - render noise to flattened render target\nBuffer B - compute derivatives from value samples (optional)\nImage    - rendering\n\ncamera controls via mouse + shift key\n\nRelated:\n\n- https://www.shadertoy.com/view/3tfBzX | \"Cubic Reconstruction\"            (derivation of the ground truth bicubic reconstruction scheme)\n- https://www.shadertoy.com/view/WtsBDH | \"Bicubic C2 cont. Interpolation\"  (describes a pre-filtering approach to achieve C2 continuity)\n- https://www.shadertoy.com/view/wtByDt | \"Single Sample Bicubic Sampling\"  (2d version of the sampling approach described here)\n\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n\n// emulates trilinear lookups into the flattened 3d render target; in a practical setup one would use a proper volume render target\nvec4 SampleVolTexTrilinearly(sampler2D channel, vec3 tc)\n{\n    uint res = VOLUME_RES;\n    uint layersH = VOLUME_LAYERSH;\n    \n    vec3 uvw = tc * float(res);\n   \n   #if 1\n    uvw = clamp(uvw, 0.5, float(res) - 0.5);\n   #else\n    vec4 border = vec4(0.0, 0.0, 0.0, 16.0);\n   \n    if(uvw.x < 0.5 || uvw.x > float(res) - 0.5) return border;\n    if(uvw.y < 0.5 || uvw.y > float(res) - 0.5) return border;\n    if(uvw.z < 0.5 || uvw.z > float(res) - 0.5) return border;\n   #endif\n    \n    uvw.z -= 0.5;\n    \n    uint zI = uint(uvw.z);\n    float zF = uvw.z - float(zI);\n    \n    vec2 zuv = vec2(zI % layersH, zI / layersH);\n    \n    vec2 uvA = uvw.xy + zuv * float(res);\n    \n    bool cond = zuv.x == float(layersH) - 1.0;\n    vec2 uvB = uvw.xy + vec2(cond ? 0.0 : zuv.x + 1.0,\n                             cond ? zuv.y + 1.0 : zuv.y) * float(res);\n    \n    vec4 sA = textureLod(channel, uvA / iResolution.xy, 0.0);\n    vec4 sB = textureLod(channel, uvB / iResolution.xy, 0.0);\n    \n    return mix(sA, sB, zF);\n}\n\n// this is where the magic happens\nfloat SampleVolTexTricubically(sampler2D channel, vec3 tc)\n{\n    vec3 uvw = tc * float(VOLUME_RES) - 0.5;\n    \n    vec3 uvwi = floor(uvw);\n    vec3 uvwf = uvw - uvwi;\n\n    vec3 mo = uvwf - uvwf*uvwf;\n\n   #if 1\n    mo = (mo * -0.5 + 1.0) * mo;// use this if it improves quality\n   #endif\n    \n    uvwf = (uvwf - mo) / (1.0 - 2.0 * mo);// map modulator to s-curve\n    \n    uvw = uvwi + uvwf + vec3(0.5);\n\n    vec4 v = SampleVolTexTrilinearly(channel, uvw / float(VOLUME_RES));// replace this with native trilinear lookup\n    \n    mo *= fract(uvwi * 0.5) * 4.0 - 1.0;// flip modulator bump on every 2nd interval\n    \n    return dot(v, vec4(mo, 1.0));\n}\n\n\n// p [-0.5, 0.5]\nfloat Map(vec3 p)\n{\n    vec3 tc = p + 0.5;\n    \n  #ifdef COMPUTE_DERIVATIVES_FROM_VALUE_SAMPLES\n    #define CHANNEL iChannel2\n  #else\n    #define CHANNEL iChannel1\n  #endif\n    \n  #ifdef SAMPLE_TRILINEARLY\n    float r = SampleVolTexTrilinearly(iChannel1, tc).w;\n  #else\n    float r = SampleVolTexTricubically(CHANNEL, tc);\n  #endif\n    \n    return r;\n}\n\nvec4 RaymarchVolume(vec3 rp, vec3 rd, uvec2 uv, vec3 light)\n{\n    float toff;\n    {\n    \tuvec2 uv2 = uv + WellonsHash(floatBitsToUint(iTime), 0u).xy;\n    \tvec4 bnoise = texelFetch(iChannel3, ivec2(uv2 % 1024u), 0);\n    \n    \ttoff = bnoise.x - 0.5;\n    }\n    \n    vec3 p; float intervalLen;\n    {\n        float hsize = 0.5;\n        //hsize -= 1.0/float(VOLUME_RES);\n        \n\t\tvec2 tt;\n\t\tif(Intersect_Ray_Cube(rp, rd, vec3(0.0), vec3(hsize), tt) != 1.0) return vec4(vec3(0.0), 1.0);\n        \n    \tbool inside = tt.y < 0.0;\n            \n    \tp = inside ? rp : rp + rd * tt.x;\n            \n    \t//p += rd * 0.001;\n\n    \tintervalLen = inside ? tt.x : tt.y - tt.x;\n    }\n    \n    float stepSize  = 1.0/64.0;\n    float stepCount = ceil(min(intervalLen, 2.0) / stepSize);\n          //stepSize  = intervalLen / stepCount;\n    \n    float sigma = 0.0;// scattering coefficient\n    float tau   = 0.0;// optical depth\n    float T     = 1.0;// transmittance\n    \n    float r = 0.0;\n\tfloat t = 0.0;\n    \n    for(float i = 0.0; i < stepCount; ++i)\n    {\n        vec3 p0 = p + rd * (t + toff * stepSize);\t\t\t\t\n\n        float f = Map(p0);\n\n        if(f > 0.0)\n        {\n           #if 0\n        \tt += max(stepSize, f);// use this if f is a distance bound\n           #else\n            t += stepSize;\n           #endif\n            \n            sigma = 0.0;\n        }\n        else\n        {\n            //float sigma0 = sigma;\n            sigma  = -f * (1024.0*1.0);\n\t\t\t//float sigma2 = (sigma0 + sigma) * 0.5;// some basic filtering\n\n            float rad  = 1.0 - exp2(-sigma * 0.04);// limb darkening / cheap multi scatter approx\n                  rad *= 1.0 - Pow2(cubic(1.0-clamp01(p0.y + 0.5)));// vertical gradient\n\n            tau += sigma * stepSize;\n                        \n            float T0 = T;\n            T = exp2(-tau);\n                        \n            float prob = T0 - T;// scattering probability for current step (assuming constant sigma)\n            \n            r += rad * prob;\n            t += stepSize;\n        }\n        \n        if(t > intervalLen || T < 0.01) break;\n    }\n    \n    return vec4(vec3(r), T);\n}\n\n\n\n#define VarTex iChannel0\n#define OutChannel w\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = uv0.xy - 0.5;\n\n    int I = 0;\n    vec4 iMouse     = ReadVar4(I++, 0);\n    vec4 mouseAccu  = ReadVar4(I++, 0);\n    vec4 wasdAccu   = ReadVar4(I++, 0);\n    float frameAccu = ReadVar (I++, 0);\n    \n    vec2 lightAng = vec2(Pi * 0.6, Pi * 0.2);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    vec3 light = AngToVec(lightAng);\n    \n    vec2 ang = vec2(Pi * -0.4, -Pi * 0.2);\n    ang += mouseAccu.xy * 0.008;\n    \n    mat3 cmat;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        vec3 up    = vec3(-cosPhi * sinTheta,\n                                    cosTheta,\n                          -sinPhi * sinTheta);\n        \n        cmat = mat3(right, up, front);\n    }\n    \n    float cdist = exp2(-0.2 + mouseAccu.w * 0.02);\n    vec3 cpos = -cmat[2] * cdist;\n\n    float focalLen = 0.7;// = 0.5 * tan(Pi05 - fov * 0.5)\n\n    float txlSize = 1.0 / iResolution.x * 2.0;\n    vec2 tc = uv0.xy * txlSize - vec2(1.0, iResolution.y / iResolution.x);\n   \n\n    vec3 rd = normalize(cmat * vec3(tc, focalLen)); \n    \n    col = vec3(0.0119);\n    \n    #if 1\n    // background pattern\n    {\n        bvec2 a = bvec2(rd.y > 0.0, abs(rd.y) > 0.8);\n        \n        bool b = (rd.x > 0.0) != (rd.z > 0.0); \n        \n        col = b != a.y ? col * (a.x ? 1.0 : 0.75) : col * (a.x ? 1.5 : 1.0);\n    }\n   #endif\n    \n    // ray marching\n    {\n    \tvec4 c = RaymarchVolume(cpos, rd, uvec2(uv), light);\n        \n        col = col * c.w + c.rgb;\n    }\n    \n\toutCol = vec4(sRGB_EOTF(clamp01(col)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/* state presistence / camera controls */\n\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_SHIFT 0x10\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\n\n\n#define VarTex iChannel0\n#define OutCol col\n#define OutChannel w\n\n#define WRITEVAR(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WRITEVAR2(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1)}\n#define WRITEVAR3(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1) WRITEVAR(v.z, cx, cy + 2)}\n#define WRITEVAR4(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1) WRITEVAR(v.z, cx, cy + 2) WRITEVAR(v.w, cx, cy + 3)}\n\n#define WriteVar(v, x) {WRITEVAR(v, x, 0) ++x;}\n#define WriteVar2(v, x) {WRITEVAR2(v, x, 0) ++x;}\n#define WriteVar3(v, x) {WRITEVAR3(v, x, 0) ++x;}\n#define WriteVar4(v, x) {WRITEVAR4(v, x, 0) ++x;}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec2 ReadVar2(int cx, int cy) {return vec2(ReadVar(cx, cy), ReadVar(cx, cy + 1));}\nvec3 ReadVar3(int cx, int cy) {return vec3(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2));}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\nfloat ReadVar(inout int x) { return ReadVar(x++, 0); }\nvec2 ReadVar2(inout int x) { return ReadVar2(x++, 0); }\nvec3 ReadVar3(inout int x) { return ReadVar3(x++, 0); }\nvec4 ReadVar4(inout int x) { return ReadVar4(x++, 0); }\n\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    col = vec4(0.0);\n    vec2 uv = uv0 - 0.5;\n   \n    \n    //if(uv.y > 5.0) return;\n    \n    int I = 0;\n    vec4 iMouseLast     = ReadVar4(I);\n    vec4 iMouseAccuLast = ReadVar4(I);\n    vec4 wasdAccuLast   = ReadVar4(I);\n    float frameAccuLast = ReadVar (I);\n    float knobVal       = ReadVar (I);\n    \n    vec2 iMouseClick    = ReadVar2(I);\n    \n    \n    bool isClick = iMouseLast.z < 0.0 && iMouse.z >= 0.0;\n    \n    if(isClick) iMouseClick = iMouse.xy;\n    \n    bool shift = ReadKey(KEY_SHIFT) != 0.0;\n    \n    float kW = ReadKey(KEY_W);\n    float kA = ReadKey(KEY_A);\n    float kS = ReadKey(KEY_S);\n    float kD = ReadKey(KEY_D);\n    \n    float left  = ReadKey(KEY_LEFT);\n    float right = ReadKey(KEY_RIGHT);\n    float up    = ReadKey(KEY_UP);\n    float down  = ReadKey(KEY_DOWN);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool anyK = false;\n    \n    anyK = anyK || iMouse.z > 0.0;\n    anyK = anyK || shift;\n    anyK = anyK || kW != 0.0;\n    anyK = anyK || kA != 0.0;\n    anyK = anyK || kS != 0.0;\n    anyK = anyK || kD != 0.0;\n    anyK = anyK || left  != 0.0;\n    anyK = anyK || right != 0.0;\n    anyK = anyK || up    != 0.0;\n    anyK = anyK || down  != 0.0;\n    \n    \n    float frameAccu = frameAccuLast + 1.0;\n    //if(anyK) frameAccu = 0.0;\n    \n    \n    vec4 wasdAccu = wasdAccuLast;\n    wasdAccu += vec4(kW, kA, kS, kD);\n    wasdAccu += vec4(up, left, down, right);        \n    \n        \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    \n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n    \n\n    \n    int J = 0;\n    WriteVar4(iMouse,       J);\n    WriteVar4(iMouseAccu,   J);\n    WriteVar4(wasdAccu,     J);\n    WriteVar(frameAccu,     J);\n    WriteVar(knobVal,       J);\n\n    WriteVar2(iMouseClick,  J);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/* render noise to flattened render target */\n\n\n// https://www.shadertoy.com/view/wd3czs\nfloat Noise(sampler3D channel, vec3 uvw, float time)\n{\n    vec4 p4 = uvw.x * vec4(-0.5,-0.5, 0.5, 0.5) +\n              uvw.y * vec4( 0.5,-0.5,-0.5, 0.5) +\n              uvw.z * vec4(-0.5, 0.5,-0.5, 0.5);\n    \n    p4 += time;\n    \n    vec4 ip = floor(p4);\n    vec4 fp = p4 - ip;\n\n   #if 1\n    fp = (fp * fp * fp) * (10.0 + fp * (-15.0 + 6.0 * fp));\n   #else\n    fp = fp * fp * (3.0 - 2.0 * fp);\n   #endif\n\n\tconst float pi = 3.14159265359;\n    const float texDim = 32.0;\n    const float txlDim = 1.0 / texDim;\n    const vec3 phi = vec3(27.0, 21.0, 17.0);\n    const float o0 =        0.5  * txlDim;\n    const vec3  o1 = (phi + 0.5) * txlDim;\n\n    vec3 p3 = phi * ip.w + (ip.xyz + fp.xyz);\n    \n    vec4 n = mix(textureLod(channel, p3 * txlDim + o0, 0.0), \n                 textureLod(channel, p3 * txlDim + o1, 0.0), fp.w) * 2.0 - 1.0;\n\n    ///return dot(n, sin(p4 * pi)) / pi;\n    return dot(n, cos(p4 * pi)) / pi;// cos looks better here\n}\n\nvec4 Noise2(sampler3D channel, vec3 uvw, float time)\n{\n    vec4 p4 = uvw.x * vec4(-0.5,-0.5, 0.5, 0.5) +\n              uvw.y * vec4( 0.5,-0.5,-0.5, 0.5) +\n              uvw.z * vec4(-0.5, 0.5,-0.5, 0.5);\n    \n    p4 += time;\n    \n    vec4 ip = floor(p4);\n    vec4 fp = p4 - ip;\n\n   #if 1\n    fp = (fp * fp * fp) * (10.0 + fp * (-15.0 + 6.0 * fp));\n   #else\n    fp = fp * fp * (3.0 - 2.0 * fp);\n   #endif\n\n\tconst float pi = 3.14159265359;\n    const float texDim = 32.0;\n    const float txlDim = 1.0 / texDim;\n    const vec3 phi = vec3(27.0, 21.0, 17.0);\n    const float o0 =        0.5  * txlDim;\n    const vec3  o1 = (phi + 0.5) * txlDim;\n\n    vec3 p3 = phi * ip.w + (ip.xyz + fp.xyz);\n    \n    vec4 n = mix(textureLod(channel, p3 * txlDim + o0, 0.0), \n                 textureLod(channel, p3 * txlDim + o1, 0.0), fp.w) * 2.0 - 1.0;\n\n    return n;\n}\n\nfloat Map(vec3 p)\n{\n    //return length(p) - 0.45;\n    \n    float time = float(iTime) * (0.125*0.75);\n    \n    vec3 n = Noise2(iChannel3, p * 4.0 - vec3(0.0, 1.0, 0.0)*time*1.8, time*0.4).xyz * 0.5;\n    \n    float r = 0.0;\n    r += Noise(iChannel3, p *  4.0 + vec3( 1.0, 0.0,  1.0)*time*1.0+n, time*0.5)*1.0;\n    r += Noise(iChannel3, p * 12.0 + vec3(-1.0, 0.0,  1.0)*time*2.0+n, time    )*0.75;\n    r += Noise(iChannel3, p * 32.0 + vec3( 0.0, 1.0, -1.0)*time*4.0+n, time*2.0)*0.5;\n    \n   #if VOLUME_RES == 64u\n    r += Noise(iChannel3, p * 64.0 + vec3( 1.0, -1.0, 0.0)*time*8.0+n, time*1.5)*0.25;\n    r /= 1.0+0.75+0.5+0.25;\n   #else\n    r /= 1.0+0.75+0.5;\n   #endif\n    \n    r += p.y * 0.5;\n    \n    {\n    \tvec3 p2 = p * 2.0;\n    \t\n    \tvec3 m = max(vec3(0.0), 1.0 - p2 * p2);\n    \tr = mix(r, 1.0, min(pow(1.0 - m.x*m.y*m.z, 32.0), 1.0));\n    }\n    \n    return r;\n}\n\n\nuvec3 UVWFromUV(uvec2 uv)\n{\n    uint res = VOLUME_RES;\n    uint layersH = VOLUME_LAYERSH;\n\n    uvec2 uvF = uv % res;\n    uvec2 uvI = uv / res;\n\n    uvec3 uvw = uvec3(uvF, uvI.x + uvI.y * layersH);\n\n    if(uv.x >= res * layersH || uvw.z >= res)\n    {\n        discard;\n    }\n\n    return uvw;\n}\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{\n    uvec2 uv = uvec2(uv0 - 0.5);\n\n    uvec3 uvw = UVWFromUV(uv);\n\n    vec3 tc = vec3(uvw)/float(VOLUME_RES) + 0.5/float(VOLUME_RES);\n    \n    vec3 p = tc - 0.5;// [-0.5, 0.5]\n    \n    float v = 0.0;\n    \n   #ifdef SAMPLE_TRILINEARLY  \n    col = vec4(0.0, 0.0, 0.0, Map(p));\n    return;\n   #endif\n    \n   #ifdef COMPUTE_DERIVATIVES_FROM_VALUE_SAMPLES  \n    \n    col = vec4(0.0, 0.0, 0.0, Map(p));\n\t\n   #else\n    \n    col = vec4(0.0);\n    \n    float o = 1.0/float(VOLUME_RES*4u);\n    //float o = 1.0/1024.0;\n    #define ZERO (min(iTime, 0.0)) \n    vec3 e = vec3(1.0);\n\n    // https://iquilezles.org/articles/normalsSDF\n    for(float i = ZERO; i < 4.0; ++i)\n    {\n        float f = Map(p + e * o);\n        \n   \t\tcol.xyz += e * f;\n        col.w   +=     f;\n        \n        e = vec3(e.z, -e.yx);  \n    }\n    \n    col.xyz /= o * 4.0;\n    col.w   /=     4.0;\n    \n    if((uvw.x & 1u) == 0u) { col.x = -col.x; }\n    if((uvw.y & 1u) == 0u) { col.y = -col.y; }\n    if((uvw.z & 1u) == 0u) { col.z = -col.z; }\n    \n    col.xyz /= float(VOLUME_RES);\n    \n   #endif\n}\n\n\n\n\n/*\n\n    float o = 1.0/float(VOLUME_RES*4u);\n    //float o = 1.0/1024.0;\n    \n    float vx0 = Map(p - o * vec3(1.0, 0.0, 0.0));\n    float vx1 = Map(p + o * vec3(1.0, 0.0, 0.0));\n    \n    float vy0 = Map(p - o * vec3(0.0, 1.0, 0.0));\n    float vy1 = Map(p + o * vec3(0.0, 1.0, 0.0));\n    \n    float vz0 = Map(p - o * vec3(0.0, 0.0, 1.0));\n    float vz1 = Map(p + o * vec3(0.0, 0.0, 1.0));\n    \n    col = vec4(vec3(vx1 - vx0,\n                    vy1 - vy0,\n                    vz1 - vz0) / (2.0 * o), (vx0 + vx1 + vy0 + vy1 + vz0 + vz1) / 6.0);\n    \n    if((uvw.x & 1u) == 0u) { col.x = -col.x; }\n    if((uvw.y & 1u) == 0u) { col.y = -col.y; }\n    if((uvw.z & 1u) == 0u) { col.z = -col.z; }\n    \n    col.xyz /= float(VOLUME_RES);\n\nfloat Worley(vec3 x, uint seed)\n{\n\tvec3 ix = floor(x);\n\tvec3 fx = x - ix;\n    \n    float res = 1024.0;\n    \n\tfor (float i = 0.0; i < 3.0; ++i)\n\tfor (float j = 0.0; j < 3.0; ++j)\n\tfor (float k = 0.0; k < 3.0; ++k)\n\t{\n\t\tvec3 v = vec3(i, j, k);\n\t\tvec3 c = v - 0.5;\n\t\tvec3 vp = v + ix;\n        \n\t\tvec3 off = normalize(PhiHash11(vp, seed).xyz);\n        \n        c += off * 0.4;\n\n\t\tfloat d2 = dot(fx - c, fx - c);\n\n        res = min(res, d2);\n        \n\t}\n\n    return res;\n}\n\nfloat  ilerp(float  a, float  b, float  y) { return (y - a) / (b - a); }\nfloat  ilerp2(const float  a, const float  b, float  y) { return y * (1.0 / (b - a)) + (-a / (b - a)); }\n\nfloat WorleyE2(vec3 x, uint seed)\n{\n\tvec3 ix = floor(x);\n\tvec3 fx = x - ix;\n    \n    float res = 0.0;\n\tfor (float i = 0.0; i < 3.0; ++i)\n\tfor (float j = 0.0; j < 3.0; ++j)\n\tfor (float k = 0.0; k < 3.0; ++k)\n\t{\n\t\tvec3 v = vec3(i, j, k);\n\t\tvec3 c = v - 0.5;\n\t\tvec3 vp = v + ix;\n        \n\t\tvec3 off = normalize(PhiHash11(vp, seed).xyz);\n        \n        c += off * 0.4;\n\n\t\tfloat l = (1.0 - 0.64 * dot(fx - c, fx - c));\n        l = clamp(l, 0.0, 1.0);\n        \n        res += l;\n\t}\n\n    res = sqrt(res);\n\n    res = ilerp2(0.32, 2.75, res);\n    \n    return 1.0-res;\n}\n\nfloat Fbm(vec3 p)\n{\n    const float count = 4.0;\n\n    const float ang = Pi * (3.0 - sqrt(5.0));\n    const vec2 rot = vec2(cos(ang), sin(ang));\n\n    float scale = 1.0;\n    float res = 1024.0;\n    \n    uint h = 26450u;\n    \n    for(float i = 0.0; i < count; ++i)\n    {\n        //float v = (Worley(p, h)-0.) / (scale*scale);\n        float r = 0.4/scale;\n        float v = sqrt(Worley(p, h)-0.) / (scale) - r;\n        \n        if(i != 0.0) v = max(v, res-r*0.75);\n        \n        //if(i != count - 1.0)\n        res = min(res, v);\n        //else\n        //res = max(v, res);\n\n        //res = v;\n        \n        h = LCG(h);\n        \n        float s = 2.;\n        scale *= s;\n        p *= s;\n        p.xy = CmplxMul(p.xy, rot);\n        p = p.yzx;\n    }\n    \n    return res;\n}\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/* compute derivatives from value samples (optional) */\n\nvec4 SampleVolTex(uvec3 uvw)\n{\n    uint res = VOLUME_RES;\n    uint layersH = VOLUME_LAYERSH;\n       \n    uvec2 zuv = uvec2(uvw.z % layersH, uvw.z / layersH);\n    \n    uvec2 uv = uvw.xy + zuv * res;\n    \n\treturn texelFetch(iChannel0, ivec2(uv), 0); \n}\n\nfloat Fetch(uvec3 uvw)\n{\n   #if 1\n    if(uvw.x > 2147483647u) uvw.x = 0u;\n    if(uvw.y > 2147483647u) uvw.y = 0u;\n    if(uvw.z > 2147483647u) uvw.z = 0u;\n    \n    if(uvw.x >= VOLUME_RES) uvw.x = VOLUME_RES - 1u;\n    if(uvw.y >= VOLUME_RES) uvw.y = VOLUME_RES - 1u;\n    if(uvw.z >= VOLUME_RES) uvw.z = VOLUME_RES - 1u;\n   #else\n    float border = 2.0;\n    if(uvw.x >= VOLUME_RES) return border;\n    if(uvw.y >= VOLUME_RES) return border;\n    if(uvw.z >= VOLUME_RES) return border;\n   #endif\n    \n    return SampleVolTex(uvw).w;\n}\n\nuvec3 UVWFromUV(uvec2 uv)\n{\n    uint res = VOLUME_RES;\n    uint layersH = VOLUME_LAYERSH;\n\n    uvec2 uvF = uv % res;\n    uvec2 uvI = uv / res;\n\n    uvec3 uvw = uvec3(uvF, uvI.x + uvI.y * layersH);\n\n    if(uv.x >= res * layersH || uvw.z >= res)\n    {\n        discard;\n    }\n\n    return uvw;\n}\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n   #ifdef SAMPLE_TRILINEARLY\n    discard;\n   #endif\n    \n   #ifndef COMPUTE_DERIVATIVES_FROM_VALUE_SAMPLES\n    discard;\n   #endif\n    \n    uvec2 uv = uvec2(uv0 - 0.5);\n    \n    uvec3 uvw = UVWFromUV(uv);\n\n    vec4 col = vec4(0.0);\n    \n   #if 1\n    \n    // C2 interpolating cubic kernel\n    float kern[12];\n    kern[0] = 0.0         ; kern[1] = -0.803848    ; kern[ 2] = 0.21539      ; kern[ 3] = -0.0577137    ; \n    kern[4] = 0.0154643   ; kern[5] = -0.00414365  ; kern[ 6] = 0.00111029   ; kern[ 7] = -0.000297501  ; \n    kern[8] = 0.0000797152; kern[9] = -0.0000213596; kern[10] = 0.00000572329; kern[11] = -0.00000153355;\n            \n    int r = 4;//3 -> 19 tabs | 4 -> 25 tabs | 5 -> 31 tabs\n\n    // d/dx\n    for(int i = -r; i <  0; ++i) col.x += Fetch(uvw + uvec3(i, 0, 0)) * kern[-i]; \n    col.w = Fetch(uvw);\n    for(int i =  1; i <= r; ++i) col.x -= Fetch(uvw + uvec3(i, 0, 0)) * kern[ i];\n    \n    // d/dy\n    for(int i = -r; i <  0; ++i) col.y += Fetch(uvw + uvec3(0, i, 0)) * kern[-i];\n    for(int i =  1; i <= r; ++i) col.y -= Fetch(uvw + uvec3(0, i, 0)) * kern[ i];\n\n    // d/dz\n    for(int i = -r; i <  0; ++i) col.z += Fetch(uvw + uvec3(0, 0, i)) * kern[-i];\n    for(int i =  1; i <= r; ++i) col.z -= Fetch(uvw + uvec3(0, 0, i)) * kern[ i];\n\n   #else\n        \n    // C2 non-interpolating cubic kernel; using these doesnt help saving tabs when we dont compute 2nd and 3rd order partial derivatives\n    float kernD0[3];\n    float kernD1[3];\n    \n    // B-spline kernel\n    kernD0[0] = 2.0/3.0; kernD0[1] = 1.0/6.0; kernD0[2] = 0.0;\n    kernD1[0] =     0.0; kernD1[1] =    -0.5; kernD1[2] = 0.0;\n\n    int r = 1;// = 27 tabs\n    \n    #if 0\n    // add a pair of B-spline side lobes:\n    {\n    \tfloat sw = 0.25;// side lobes weight\n\n    \tkernD0[0] += 1.0 * sw; kernD0[1] += -1.0/3.0 * sw; kernD0[2] += -1.0/6.0 * sw;\n    \t\t                   kernD1[1] += -1.0     * sw; kernD1[2] +=  0.5     * sw;\n        \n        r = 2;// = 125 tabs\n    }\n\t#endif\n    \n    for(int k = -r; k <= r; ++k)\n    for(int j = -r; j <= r; ++j)\n    for(int i = -r; i <= r; ++i)\n    {\n    \tfloat f = Fetch(uvw + uvec3(i, j, k));\n        \n        int x = abs(i);\n        int y = abs(j);\n        int z = abs(k);\n        \n        float kAx = kernD0[x];\n        float kAy = kernD0[y];\n        float kAz = kernD0[z];\n        \n        float kBx = kernD1[x] * (i > 0 ? -1.0 : 1.0);\n        float kBy = kernD1[y] * (j > 0 ? -1.0 : 1.0);\n        float kBz = kernD1[z] * (k > 0 ? -1.0 : 1.0);\n        \n        col += f * vec4(kBx * kAy * kAz, \n                        kAx * kBy * kAz, \n                        kAx * kAy * kBz,\n                        kAx * kAy * kAz);\n    }\n   #endif\n    \n    if((uvw.x & 1u) == 0u) { col.x = -col.x; }\n    if((uvw.y & 1u) == 0u) { col.y = -col.y; }\n    if((uvw.z & 1u) == 0u) { col.z = -col.z; }\n    \n    outCol = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/* settings */\n\n // #define SAMPLE_TRILINEARLY\n // #define COMPUTE_DERIVATIVES_FROM_VALUE_SAMPLES\n\n#if 0\n\t#define VOLUME_RES 64u\n\t#define VOLUME_LAYERSH 11u\n#else\n\t#define VOLUME_RES 32u\n\t#define VOLUME_LAYERSH 8u\n#endif\n\n\n//=============================================================//\n\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\nvec2 CmplxMul(vec2 c0, vec2 c1)\n{\n    return vec2(c0.x*c1.x - c0.y*c1.y, c0.y*c1.x + c0.x*c1.y);\n}\n\nvec2 CmplxMul(vec2 c0, float ang)\n{\n    vec2 c1 = vec2(cos(ang), sin(ang));\n    \n    return vec2(c0.x*c1.x - c0.y*c1.y, c0.y*c1.x + c0.x*c1.y);\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat cubic(float x) { return x*x*(3.0-2.0*x); }\n\n\nfloat sRGB_EOTF(float c)\n{\n    return c > 0.0031308 ? pow(c, 1.0/2.4) * 1.055 - 0.055 : c * 12.92;\n}\n\nfloat sRGB_InvEOTF(float c)\n{\n    return c > 0.04045 ? pow(c / 1.055 + 0.055/1.055, 2.4) : c / 12.92;\n}\n\nvec3 sRGB_EOTF(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n\nvec3 sRGB_InvEOTF(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.04045)), pow(rgb / 1.055 + 0.055/1.055, vec3(2.4)), rgb / 12.92);\n}\n\n    \nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\nconst uint rPhi1  = 2654435761u;\n\nconst uint rPhi2a = 3242174893u;\nconst uint rPhi2b = 2447445397u;\n\nconst uint rPhi3a = 3518319149u;\nconst uint rPhi3b = 2882110339u;\nconst uint rPhi3c = 2360945581u;\n\nconst uint rPhi4a = 3679390609u;\nconst uint rPhi4b = 3152041517u;\nconst uint rPhi4c = 2700274807u;\nconst uint rPhi4d = 2313257579u;\n\nconst uvec2 rPhi2 = uvec2(rPhi2a, rPhi2b);\nconst uvec3 rPhi3 = uvec3(rPhi3a, rPhi3b, rPhi3c);\nconst uvec4 rPhi4 = uvec4(rPhi4a, rPhi4b, rPhi4c, rPhi4d);\n\nuint  Roberts(uint  off, uint n) { return off + rPhi1 * n; }\nuvec2 Roberts(uvec2 off, uint n) { return off + rPhi2 * n; }\nuvec3 Roberts(uvec3 off, uint n) { return off + rPhi3 * n; }\nuvec4 Roberts(uvec4 off, uint n) { return off + rPhi4 * n; }\n\n#define _SEED uvec4(0xCAF0FC2Eu, 0xEA18994Au, 0x4D86D399u, 0x10EB49F0u)\n\nuvec4 PhiHash(uint  v, uint seed) { return ((v   * rPhi2a)                                                    ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec2 v, uint seed) { return ((v.x * rPhi2a) ^ (v.y * rPhi2b)                                   ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec3 v, uint seed) { return ((v.x * rPhi3a) ^ (v.y * rPhi3b) ^ (v.z * rPhi3c)                  ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec4 v, uint seed) { return ((v.x * rPhi4a) ^ (v.y * rPhi4b) ^ (v.z * rPhi4c) ^ (v.w * rPhi4d) ^ (_SEED ^ uvec4(seed))) * rPhi1; }\n\nvec4 PhiHash01(float v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec2  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec3  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec4  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\n\nvec4 PhiHash11(float v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec2  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec3  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec4  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\n\nuint MixHash(uvec2 h)\n{\n    return ((h.x ^ (h.y >> 16u)) * rPhi2.x) ^ \n           ((h.y ^ (h.x >> 16u)) * rPhi2.y);\n}\n\nuint MixHash(uvec3 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi3.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.y << 15u)) * rPhi3.y) ^\n           ((h.z ^ (h.y >> 16u) ^ (h.x << 15u)) * rPhi3.z);\n}\n\nuint MixHash(uvec4 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi4.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.w << 15u)) * rPhi4.y) ^\n           ((h.z ^ (h.w >> 16u) ^ (h.x << 15u)) * rPhi4.z) ^\n           ((h.w ^ (h.x >> 16u) ^ (h.y << 15u)) * rPhi4.w);\n}\n\n// low bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\nuvec2 WellonsHash(uvec2 h) { return uvec2(WellonsHash(h.x), WellonsHash(h.y)); }\nuvec3 WellonsHash(uvec3 h) { return uvec3(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z)); }\nuvec4 WellonsHash(uvec4 h) { return uvec4(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z), WellonsHash(h.w)); }\n\nuvec4 WellonsHash(uint  v, uint seed) { return WellonsHash(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec2 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec3 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec4 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n// minimal bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\nuvec2 WellonsHash2(uvec2 h) { return uvec2(WellonsHash2(h.x), WellonsHash2(h.y)); }\nuvec3 WellonsHash2(uvec3 h) { return uvec3(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z)); }\nuvec4 WellonsHash2(uvec4 h) { return uvec4(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z), WellonsHash2(h.w)); }\n\nuvec4 WellonsHash2(uint  v, uint seed) { return WellonsHash2(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec2 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec3 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec4 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n#undef _SEED\n\n\n// https://en.wikipedia.org/wiki/Linear_congruential_generator\nuint LCG(uint x) { return x * 22695477u + 1u; }\n\nfloat Hash01(inout uint h)\n{\n    h = LCG(h);\n\n    return Float01(h * rPhi1);\n}\n\nfloat Hash11(inout uint h)\n{\n    h = LCG(h);\n\n    return Float11(h * rPhi1);\n}\n\nuint HashU(inout uint h)\n{\n    h = LCG(h);\n\n    return h * rPhi1;\n}\n\nvec2 Hash01x2(inout uint h) { return vec2(Hash01(h), Hash01(h)); }\nvec3 Hash01x3(inout uint h) { return vec3(Hash01(h), Hash01(h), Hash01(h)); }\nvec4 Hash01x4(inout uint h) { return vec4(Hash01(h), Hash01(h), Hash01(h), Hash01(h)); }\n\nvec2 Hash11x2(inout uint h) { return vec2(Hash11(h), Hash11(h)); }\nvec3 Hash11x3(inout uint h) { return vec3(Hash11(h), Hash11(h), Hash11(h)); }\nvec4 Hash11x4(inout uint h) { return vec4(Hash11(h), Hash11(h), Hash11(h), Hash11(h)); }\n\nuvec2 HashUx2(inout uint h) { return uvec2(HashU(h), HashU(h)); }\nuvec3 HashUx3(inout uint h) { return uvec3(HashU(h), HashU(h), HashU(h)); }\nuvec4 HashUx4(inout uint h) { return uvec4(HashU(h), HashU(h), HashU(h), HashU(h)); }\n\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}