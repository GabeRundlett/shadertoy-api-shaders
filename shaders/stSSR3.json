{
    "Shader": {
        "info": {
            "date": "1628193315",
            "description": "Messing around with some more sdf.\n8-5-2021- Added some specular",
            "flags": 0,
            "hasliked": 0,
            "id": "stSSR3",
            "likes": 5,
            "name": "Helix Cubes",
            "published": 3,
            "tags": [
                "sdf",
                "cube",
                "helix"
            ],
            "usePreview": 0,
            "username": "lambmeow",
            "viewed": 331
        },
        "renderpass": [
            {
                "code": "mat2 rot(float a)\n{\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c, -s ,s, c);\n}\n\n//https://www.shadertoy.com/view/Xds3zN\nfloat cube (vec3 p, vec3 s)\n{\n\tvec3 d = abs(p) - s;\n\treturn min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nfloat scene(vec3 p)\n{\n\t\n\tfloat z = p.z;\n\t\n\t//p.z += time;\n\t\n\tp.z = mod(p.z - 2., 4.) -2.;\n\tp.x = mod(p.x - 3., 6.) -3.;\n\tp.xy /= 12.;\n\tp.xy *= rot(iTime + p.x * .3 * sin(iTime + z));\n\tp.xy *= 12.;\n\tp.y = abs(p.y);\n\t//return cube( p, vec3(1));\n\treturn cube(p , vec3(abs(sin(iTime - p.z * 0.44 + z)), 0., 1.)) - .5;\n}\n\nmat3 cam(vec3 E, vec3 l)\n{\n\tvec3 ww = normalize(l - E);\n\tvec3 uu = normalize(cross(ww, vec3(0,1,0)));\n\tvec3 vv = cross(uu,ww);\n\t\n\treturn mat3(uu,vv, ww);\n}\n\n\n//https://www.shadertoy.com/view/Xds3zN\nvec3 norm(vec3 value)\n{\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * scene(value+0.0005*e);\n    }\n    return normalize(n);\n}\n\n\nvec4 rc(vec3 ro, vec3 rd)\n{\n\tfloat len = 0.;\n\tfloat closest = 50.;\n\tfor(int i = 0; i < 255; i ++)\n\t{\n\t\tvec3 pos = ro + rd * len;\n\t\tfloat dist = scene(pos);\n\t\t\t\tclosest = min(closest, dist);\n\t\tif(dist < .001)\n\t\t\treturn vec4(ro + rd * len, closest);\n\t\t\t\n\n\t\tlen += dist;\n\t\t\n\t\tif(len > 50.)\n\t\treturn vec4(0,0,0, closest);\n\t\t\n\t}\n\treturn vec4(0,0,0, closest);\n}\n\nvec3 color(vec4 pos, vec3 cam, vec2 uv)\n{\n\tvec3 n = norm(pos.xyz);\n\tvec3 amb = vec3(1.-uv.y) * 0.2 * vec3( .4, .4, .7);\n\tvec3 dis = normalize(cam - pos.xyz);\n\tvec3 diff = (dot(n ,dis)) * vec3(0.1, .6, .7);\n\tvec3 glow =  1./(1.+clamp(pos.w, 0.,1.) * 10.) * 0.6* vec3(.4,.4,.7);\n\tvec3 ref = 2.*dot(n, dis) * n  - dis;\n\tvec3 spec = pow(dot(dis, ref), 3.0) * vec3(0.1,.6,.7);\n\tspec = clamp ( spec , 0.,1.);\n\tif(dot (pos,pos) == 0.)\n\t\treturn amb + vec3(1.,1.,1.) ;\n\t\n\treturn diff * pos.x + amb + glow +spec;\n}\n\n\nvoid mainImage( out vec4 fc, in vec2 uv )\n{\n\tvec2 r = iResolution.xy, u = (uv * 2. - r)/r.y;\n\t\n\tvec3 ro = vec3(0.,10.,0.);\n\n\t//ro.xz *= rot(time);\n\t\n\tvec3 rd = cam(ro, vec3(1)) * normalize(vec3(u, 2.));\n\t\n\tvec4 pos = rc(ro,rd);\n\t\n\tfc = vec4(color(pos, ro, u), 1.) ;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}