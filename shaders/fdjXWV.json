{
    "Shader": {
        "info": {
            "date": "1621045539",
            "description": "I saw a couple of shaders that showed analytic maxnorm distances to shapes that are difficult or impossible to get exact euclidean distances to and thought why not use boxes instead of circles/spheres to raymarch them? I think it turned out pretty well!",
            "flags": 0,
            "hasliked": 0,
            "id": "fdjXWV",
            "likes": 25,
            "name": "Box Marching",
            "published": 3,
            "tags": [
                "raymarching",
                "distancefields",
                "ray",
                "box",
                "maxnorm",
                "boxmarching"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 531
        },
        "renderpass": [
            {
                "code": "// Utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// SDFs\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdInfLine(in vec2 p, in vec2 a, in vec2 b) {\n    return abs(dot(p - a, normalize(b - a).yx * vec2(-1.0, 1.0)));\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(0.0, max(q.x, q.y));\n}\n\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float m = length(v); vec2 n = v / m;\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));\n    return min(sdVerticalLine(p, m) - 0.025, sdIsosceles(p - vec2(0.0, m), 0.1, 0.15));\n}\n\nfloat mapScene(in vec2 p) {\n    vec2 v1 = vec2(-2.0, -2.0 + cos(iTime));\n    vec2 v2 = vec2(4.0, 2.0);\n    vec2 v3 = vec2(-4.0, 2.0);\n    vec2 v4 = vec2(2.0, -2.0 + sin(iTime));\n\n    vec2 a = v4 + 3.0 * (v2 - v3) - v1;\n    vec2 b = 3.0 * (v1 - 2.0 * v2 + v3);\n    vec2 c = 3.0 * (v2 - v1);\n    vec2 d = v1;\n\n    float loop = sdCubic(p, a, b, c, d, 0.1, 0.9, true) - 0.01;\n    float box = sdBox(p - vec2(2.0, 0.8), vec2(0.75, 0.35), iTime);\n    float line = sdLine(p, vec2(-2.0, 1.0 - 0.5 * cos(iTime)), vec2(-0.5, 1.5)) - 0.01;\n    float ellipse = sdEllipse(p - vec2(-2.0, -1.25), vec2(1.0 + 0.25 * cos(iTime), 0.35 + 0.2 * sin(iTime)));\n    float tanglesquare = sdTanglesquare((p - vec2(2.0, -0.9)) * 2.0, 16.0, -25.0, 8.0 + 10.0 * cos(iTime)) * 0.5;\n\n    return min(min(loop, min(box, min(line, ellipse))), tanglesquare);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Default before mouse interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec4(-1.75, 0.5 * sin(iTime), -2.5, 0.0);\n\n    // 2D ray\n    vec2 ro = mouse.zw;\n    vec2 rd = mouse.xy - mouse.zw;\n\n    // Draw the scene\n    float scene = mapScene(uv);\n    drawSDF(scene, vec3(0.0, 0.0, 1.0));\n    color += 0.125 + 0.125 * sin(scene * 100.0);\n\n    // Draw the ray\n    drawSDF(sdInfLine(uv, ro, ro + rd), vec3(1.0, 0.8, 0.0));\n    drawSDF(sdVectorArrow(uv - ro, rd * 0.75), vec3(1.0));\n\n    // Box march!\n    float t = 0.0;\n    rd /= max(abs(rd.x), abs(rd.y)); // Convert to maxnorm\n    for (int i=0; i < 50; i++) {\n        vec2 p = ro + rd * t;\n        float d = mapScene(p);\n        drawSDF(abs(sdBox(uv - p, vec2(abs(d)))), vec3(1.0, 0.0, 0.0)); // Draw bounding box\n        if (d < 0.001 || t > 10.0) break; // Break on hit or miss\n        t += d; // Step forward\n    }\n\n    // Output\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Line segment SDF\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a, s = sign(ba);\n    vec2 to = abs(pa - ba * clamp(dot(pa, s) / dot(ba, s), 0.0, 1.0));\n    return max(to.x, to.y);\n}\n\n// Oriented box SDF\n// https://www.shadertoy.com/view/stSGDh\nfloat sdBox(in vec2 p, in vec2 dims, in float rot) {\n    float u = cos(rot), v = sin(rot);\n\n    vec4 h = vec4(dims * u, dims * v);\n    vec2 a = vec2(h.x - h.w, h.z + h.y);\n    vec2 b = vec2(h.x + h.w, h.z - h.y);\n\n    vec2 qa = abs(mat2(u, -v, v, u) * p) - dims;\n    vec2 qb = abs(p) - max(abs(a), abs(b));\n\n    return max(max(qb.x, qb.y), max(qa.x, qa.y) / max(abs(u - v), abs(u + v)));\n}\n\n// Ellipse SDF\n// https://www.shadertoy.com/view/fljGDW\nfloat sdEllipse(in vec2 p, in vec2 ab) {\n    p = abs(p);\n    p = max(p, (p - ab).yx);\n    float ba = ab.y / ab.x, a = ba * ba + 1.0;\n    float b = p.y - p.x, bb = b * b;\n    return p.x - (sqrt(bb - (bb - ab.y * ab.y) * a) - b) / a;\n}\n\n// Tanglesquare SDF - analytical, no quartics!\n// https://www.shadertoy.com/view/st2SzK\nfloat sdTanglesquare(in vec2 p, in float a, in float b, in float c) {\n    p = abs(p); // Quadrant symmetry\n    if (p.y > p.x) p = p.yx; // Diagonal symmetry\n\n    // Upper-right critical point in the top right quadrant \n    vec2 crit = p - vec2(sqrt((-b + sqrt(2.0 * b * b - 4.0 * a * c)) / (2.0 * a)), sqrt(-b / (2.0 * a)));\n    float d = max(abs(crit.x), abs(crit.y));\n\n    // Lower critical point in the top right quadrant\n    if (abs((b * b) / (a * c) - 3.0) < 1.0) {\n        crit = p - vec2(sqrt(-b / (2.0 * a)), sqrt((-b - sqrt(2.0 * b * b - 4.0 * a * c)) / (2.0 * a)));\n        d = min(d, max(abs(crit.x), abs(crit.y)));\n    }\n\n    else {\n        crit = p - vec2(sqrt((-b + sqrt(b * b - 4.0 * a * c)) / (2.0 * a)), 0.0); // Rightmost middle critical point\n        d = min(d, max(abs(crit.x), abs(crit.y)));\n\n        float h = b * b - 4.0 * a * c;\n        if (h > 0.0) {\n            float x = (-b - sqrt(h)) / (2.0 * a);\n            if (x > 0.0) {\n                crit = p - vec2(sqrt(x), 0.0); // Next critical point to the left\n                d = min(d, max(abs(crit.x), abs(crit.y)));\n            }\n        }\n    }\n\n    // Diagonal ray intersection\n    vec2 p2 = p * p, p3 = p2 * p, p4 = p3 * p;\n    float sum1 = p.x + p.y, sum2 = p2.x + p2.y, sum4 = p4.x + p4.y;\n    float diff1 = p.x - p.y;\n\n    // (ux^2 + vx + w)^2 + t = 0 ---> ux^2 + vx + w = (+/-)sqrt(-t)\n    float u = sqrt(2.0 * a);\n    float v = sum1 * u;\n    float w = ((3.0 * sum2 - sum1 * sum1) * a + b) / u;\n    float t = sqrt(w * w - sum4 * a - sum2 * b - c);\n\n    // ux^2 + vx + w = +sqrt(-t)\n    float h = v * v - 4.0 * u * (w - t);\n    float k = 2.0 * u;\n    if (h > 0.0) {\n        h = sqrt(h);\n        d = min(d, min(abs(v - h), abs(v + h)) / k);\n    }\n\n    // ux^2 + vx + w = -sqrt(-t)\n    h = v * v - 4.0 * u * (w + t);\n    if (h > 0.0) {\n        h = sqrt(h);\n        d = min(d, min(abs(v - h), abs(v + h)) / k);\n    }\n\n    // Other diagonal ray intersection\n    v = diff1 * u;\n    w = ((3.0 * sum2 - diff1 * diff1) * a + b) / u;\n    t = sqrt(w * w - sum4 * a - sum2 * b - c);\n\n    // ux^2 + vx + w = +sqrt(-t)\n    h = v * v - 4.0 * u * (w - t);\n    if (h > 0.0) {\n        h = sqrt(h);\n        d = min(d, min(abs(v - h), abs(v + h)) / k);\n    }\n\n    // ux^2 + vx + w = -sqrt(-t)\n    h = v * v - 4.0 * u * (w + t);\n    if (h > 0.0) {\n        h = sqrt(h);\n        d = min(d, min(abs(v - h), abs(v + h)) / k);\n    }\n\n    return d * sign(sum4 * a + sum2 * b + c);\n}\n\n// Cubic curve SDF\n// https://www.shadertoy.com/view/ft2GRD\nvec3 solveQuadratic(in float a, in float b, in float c) {\n    float h = b * b - 4.0 * a * c;\n    if (h < 0.0) return vec3(0.0);\n    return vec3((vec2(-1.0, 1.0) * sqrt(h) - b) * 0.5 / a, 2.0);\n}\n\nconst vec2 eta = vec2(-0.5, sqrt(0.75));\nvec4 solveCubic(in float a, in float b, in float c, in float d) {\n    float h = 18.0 * a * b * c * d - 4.0 * b * b * b * d + b * b * c * c - 4.0 * a * c * c * c - 27.0 * a * a * d * d;\n\n    b /= a, c /= a, d /= a;\n    float d0 = b * b - 3.0 * c;\n    float d1 = (2.0 * b * b - 9.0 * c) * b + 27.0 * d;\n    float q = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n\n    vec2 C = q < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) + abs(C.y) < 1e-3) C = vec2(d1 - j, 0.0);\n    float t = atan(C.y, C.x) / 3.0, r = pow(0.25 * dot(C, C), 1.0 / 6.0);\n    C = vec2(cos(t), sin(t));\n\n    vec3 roots;\n    float w = -d0 / r - r;\n    roots.x = (C.x * w - b) / 3.0;\n    roots.y = (dot(vec2(C.x, -C.y), eta) * w - b) / 3.0;\n    if (h > 0.0) roots.z = (dot(C, eta) * w - b) / 3.0;\n    else if (abs(dot(C.yx, eta)) < abs(C.y)) roots.x = roots.y;\n\n    return vec4(roots, h < 0.0 ? 1 : 3);\n}\n\nfloat evalDist(in vec2 p, in float t, in float tmin, in float tmax, in bool limit, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    if (limit) t = clamp(t, tmin, tmax);\n    vec2 toCurve = p - (((a * t + b) * t + c) * t + d);\n    return max(abs(toCurve.x), abs(toCurve.y));\n}\n\nfloat sdCubic(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in float tmin, in float tmax, in bool limit) {\n    vec2 dp = d - p;\n\n    vec4 minMax1 = solveCubic(a.x - a.y, b.x - b.y, c.x - c.y, dp.x - dp.y);\n    vec4 minMax2 = solveCubic(a.x + a.y, b.x + b.y, c.x + c.y, dp.x + dp.y);\n\n    vec3 minMax3 = solveQuadratic(3.0 * a.x, 2.0 * b.x, c.x);\n    vec3 minMax4 = solveQuadratic(3.0 * a.y, 2.0 * b.y, c.y);\n\n    float dist = evalDist(p, minMax1[0], tmin, tmax, limit, a, b, c, d);\n    for (int n=1; n < int(minMax1.w); n++) dist = min(dist, evalDist(p, minMax1[n], tmin, tmax, limit, a, b, c, d));\n    for (int n=0; n < int(minMax2.w); n++) dist = min(dist, evalDist(p, minMax2[n], tmin, tmax, limit, a, b, c, d));\n    for (int n=0; n < int(minMax3.z); n++) dist = min(dist, evalDist(p, minMax3[n], tmin, tmax, limit, a, b, c, d));\n    for (int n=0; n < int(minMax4.z); n++) dist = min(dist, evalDist(p, minMax4[n], tmin, tmax, limit, a, b, c, d));\n\n    return dist;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}