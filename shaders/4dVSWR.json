{
    "Shader": {
        "info": {
            "date": "1463790392",
            "description": "Playing with https://www.shadertoy.com/view/lsV3RV and reduced trace iterations",
            "flags": 0,
            "hasliked": 0,
            "id": "4dVSWR",
            "likes": 20,
            "name": "Candy core",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "tdhooper",
            "viewed": 915
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n\n#define t iTime\n\n\n// HG_SDF\n\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n    return dot(p, n) + distanceFromOrigin;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\n\n// Knighty https://www.shadertoy.com/view/XlX3zB\n\nint Type=5;\n\nvec3 nc,pab,pbc,pca;\nvoid initIcosahedron() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n\tpab=vec3(0.,0.,1.);\n\tpbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n\tpca=vec3(0.,scospin,cospin);\n\tpbc=normalize(pbc);\tpca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n}\n\n// Barycentric to Cartesian \nvec3 bToC(vec3 A, vec3 B, vec3 C, vec3 barycentric) {\n\treturn barycentric.x * A + barycentric.y * B + barycentric.z * C;\n}\n\nvec3 pModIcosahedron(inout vec3 p, int subdivisions) {\n    p = abs(p);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    \n    if (subdivisions > 0) {\n\n        vec3 A = pbc;\n       \tvec3 C = reflect(A, normalize(cross(pab, pca)));\n        vec3 B = reflect(C, normalize(cross(pbc, pca)));\n       \n        vec3 n;\n\n        // Fold in corner A \n        \n        vec3 p1 = bToC(A, B, C, vec3(.5, .0, .5));\n        vec3 p2 = bToC(A, B, C, vec3(.5, .5, .0));\n        n = normalize(cross(p1, p2));\n        pReflect(p, n, 0.);\n        \n        if (subdivisions > 1) {\n\n            // Get corners of triangle created by fold\n\n            A = reflect(A, n);\n            B = p1;\n            C = p2;\n            \n            // Fold in corner A\n\n            p1 = bToC(A, B, C, vec3(.5, .0, .5));\n            p2 = bToC(A, B, C, vec3(.5, .5, .0));\n            n = normalize(cross(p1, p2));\n            pReflect(p, n, 0.);\n            \n\n            // Fold in corner B\n            \n\t\t\tp2 = bToC(A, B, C, vec3(.0, .5, .5));\n            p1 = bToC(A, B, C, vec3(.5, .5, .0));\n            n = normalize(cross(p1, p2));\n            pReflect(p, n, 0.);\n        }\n    }\n\n    return p;\n}\n\nvec3 pRoll(inout vec3 p) {\n    //return p;\n    float s = 5.;\n    float d = 0.01;\n    float a = sin(t * s) * d;\n    float b = cos(t * s) * d;\n    pR(p.xy, a);\n    pR(p.xz, a + b);\n    pR(p.yz, b);\n    return p;\n}\n\nvec3 lerp(vec3 a, vec3 b, float s) {\n\treturn a + (b - a) * s;\n}\n\nfloat face(vec3 p) {\n    // Align face with the xy plane\n\tvec3 rn = normalize(lerp(pca, vec3(0,0,1), 0.5));\n    p = reflect(p, rn);\n\treturn min(\n        fPlane(p, vec3(0,0,-1), -1.4),\n        length(p + vec3(0,0,1.4)) - 0.02\n    );\n}\n\nvec3 planeNormal(vec3 p) {\n    // Align face with the xy plane\n\tvec3 rn = normalize(lerp(pca, vec3(0,0,1), 0.5));\n    return reflect(p, rn);  \n}\n\n\n\n #define t1 t*1.5\n #define t2 t/2.\n #define t3 t/2.\n #define t4 t/2.\n #define t5 t/8. \n #define t6 t/16.\n\n\nfloat inner(vec3 p) {\n    p += vec3(0.,0.,2.);\n    pR(p.xy, t1);\n    pR(p.zy, t2);\n\treturn fBox(p, vec3(.5,.1,.2));\n}\n\nfloat exampleModelC(vec3 p) {\n    pR(p.xy, t3);\n    pR(p.yz, t4);\n\t pModIcosahedron(p, 2);\n     pR(p.xy, t5);\n     pR(p.yz, t6);\n\tpModIcosahedron(p, 1);\n    p = planeNormal(p);\n    float b = inner(p);\n    return b;\n}\n\nfloat exampleModel(vec3 p) {\n    //pRoll(p);\n\treturn exampleModelC(p);\n}\n\nvec3 doBackground(vec3 rayVec) {\n    return vec3(.13);\n}\n\n// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 200.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 10;\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n    return (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 p ){\n    vec2 res = vec2(exampleModel(p) ,1.); \n    return res;\n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n    float res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n        vec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse) {\n    \n    camPos = vec3(0.0,0.0,22.0);\n\n    camTar = vec3(0);\n}\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\n\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n   \n\n  vec3 color = doBackground(rd);\n  \n    if (res.y == 2.) {\n        return vec3(0.987,0.257,1.000);\n    }\n    \n  if( res.y > -.5 ){\n      \n    vec3 pos = ro + rd * res.x;\n    vec3 norm = calcNormal( pos );\n    vec3 ref = reflect(rd, norm);\n\tcolor = norm * 0.5 + 0.5;\n    float split = 1. - dot(pos, norm);\n    float light = dot(ref, normalize(vec3(0,1,1)));\n    light *= clamp((1.-split), 0., 1.);\n\tcolor *= split * 0.8;\n    color = clamp(color, vec3(0), vec3(1));\n    color += light * 0.5;\n\t//color = vec3(light);\n    \n  }\n   \n  return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    initIcosahedron();\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 ro = vec3( 0., 0., 2.);\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    // camera movement\n    doCamera(ro, ta, t, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,20.) ); // 2.0 is the lens length\n    vec2 res = calcIntersection( ro , rd  );\n\n    \n    vec3 color = render( res , ro , rd );\n    \n    fragColor = vec4(color,1.0);\n}\n\n//void main() {\n//    mainImage(gl_FragColor, gl_FragCoord.xy);\n//}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}