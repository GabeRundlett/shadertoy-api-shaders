{
    "Shader": {
        "info": {
            "date": "1518475355",
            "description": "Elastic spring system bouncing about in a distance function.\nOrthogonal components of the shape are used for the camera matrix..\n*attempt*",
            "flags": 32,
            "hasliked": 0,
            "id": "4stcz7",
            "likes": 3,
            "name": "Elastic Camera Rig (beta)",
            "published": 3,
            "tags": [
                "fractal",
                "kali",
                "spring",
                "system"
            ],
            "usePreview": 1,
            "username": "bergi",
            "viewed": 674
        },
        "renderpass": [
            {
                "code": "/** Elastic Camera Rig\n    https://www.shadertoy.com/view/4stcz7\n\t(cc) 2018, stefan berke\n\n\tIdea is to have a completely free floating camera\n\tby integrating a small spring system and use it as the camera matrix. \n\n    The \"Camera Rig\" is in Buf A\n\t\n    Distancefield and graphics based on \n\t\"Cave Quest\" https://www.shadertoy.com/view/XdGXD3\n*/\n\n\n// minimum distance to axis-aligned planes in kali-space\n// uses eiffie's mod (/p.w) https://www.shadertoy.com/view/XtlGRj\n// to keep the result close to a true distance function\nvec3 kali_set(in vec3 pos, in vec3 param)\n{\n    //const vec3 param = vec3(.9, .6, 1.);\n    vec4 p = vec4(pos, 1.);\n    vec3 d = vec3(100.);\n    for (int i=0; i<9; ++i)\n    {\n        p = abs(p) / dot(p.xyz,p.xyz);\n        d = min(d, p.xyz/p.w);\n        p.xyz = p.zxy - param;\n    }\n    return d;\n}\n\n\nfloat DE(in vec3 p)\n{\n    //p += sin(.1*p*vec3(3,5,7));\n    \n    vec3 mp = mod(p+.3, .6) - .3;\n    float d = length(mp) - .34;\n    d = - d;\n    // displacement\n    p *= .8;\n    vec3 k = kali_set(sin(p), vec3(.9, .6+.2*cos(p.x), 1.));\n    d += k.x+k.y+k.z;\n    return d;\n}\n\nvec3 DE_norm(in vec3 p, in float eps)\n{\n    vec2 e = vec2(eps, 0.);\n    return normalize(vec3(\n        DE(p+e.xyy) - DE(p-e.xyy),\n        DE(p+e.yxy) - DE(p-e.yxy),\n        DE(p+e.yyx) - DE(p-e.yyx)));\n}\n\n\n\n\n// average of all iterations in kali-set\nvec3 kali_set_av(in vec3 p, in vec3 param)\n{\n    vec3 d = vec3(0.);\n    for (int i=0; i<13; ++i)\n    {\n        p = abs(p) / dot(p,p);\n        d += exp(-p*8.);\n        p.xyz = p.zxy - param;\n    }\n    return d / 8.;\n}\n\n// endless texture  \nvec3 kali_tex(in vec3 p, in vec3 par)\n{\n    vec3 k = kali_set_av(sin(p*3.)*.3, par);\n    return 3.*k;\n}\n\n// endless texture normal\nvec3 kali_tex_norm(in vec3 p, in vec3 param, vec3 mask, float eps)\n{\n    vec2 e = vec2(eps, 0.);\n    return normalize(vec3(\n        dot(kali_tex(p+e.xyy, param),mask) - dot(kali_tex(p-e.xyy, param),mask),\n        dot(kali_tex(p+e.yxy, param),mask) - dot(kali_tex(p-e.yxy, param),mask),\n        dot(kali_tex(p+e.yyx, param),mask) - dot(kali_tex(p-e.yyx, param),mask)));\n}\n\n\n\nconst float max_t = 2.;\n\n// common sphere tracing\n// note the check against abs(d) to get closer to surface\n// in case of overstepping\nfloat trace(in vec3 ro, in vec3 rd)\n{\n    float t = 0.001, d = max_t;\n    for (int i=0; i<50 && t < max_t; ++i)\n    {\n        vec3 p = ro + rd * t;\n        d = DE(p);\n        if (abs(d) <= 0.00001 || t >= max_t)\n            break;\n        t += d * .5; // above kali-distance still needs a lot of fudging\n    }\n    return t;\n}\n\n// common ambient occlusion\nfloat traceAO(in vec3 ro, in vec3 rd)\n{\n    float a = 0., t = 0.01;\n    for (int i=0; i<5; ++i)\n    {\n        float d = DE(ro+t*rd);\n       \ta += d / t;\n        t += abs(d);\n    }\n    return clamp(a / 8., 0., 1.);\n}\n\n// environment map, also drawn from kaliset\nvec3 skyColor(in vec3 rd)\n{\n    //vec3 par = vec3(0.075, 0.565, .03);\n    vec3 par = vec3(.9, .81, .71);\n    \n    vec3 c = kali_set_av(sin(rd*6.), par);\n    c = pow(min(vec3(1.), c*2.+vec3(1.,.86,.6)), 1.+114.*c);\n    \n    return clamp(c, 0., 1.);\n}\n\n\n// trace and color\nvec3 rayColor(in vec3 ro, in vec3 rd)\n{\n    // magic params for kali-set\n    vec3 par2 = vec3(.63, .55, .73),\t\t\t\t// normal/bump map\n         par3 = vec3(1.02, 0.82, 0.77); \t\t\t// normal/texture\n    \n    float t = trace(ro, rd);\n    vec3 p = ro + t * rd;\n    float d = DE(p);\n    \n    vec3 col = vec3(0.);\n\n    // did ray hit?\n    if (d < 0.03) \n    {\n        float scr_eps = max(0.001, (t-0.1)*0.025);\n        // \"some\" texture values\n        vec3 kt = kali_tex(p, par3);\n        // surface normal\n        vec3 n = DE_norm(p, 0.5*scr_eps), nn = n;\n        // normal displacement\n        n = normalize(n + 0.3*kali_tex_norm(p, par3+0.1*n, vec3(1), scr_eps));\n        n = normalize(n + 0.3*DE_norm(sin(n*3.+kt), 2.*scr_eps)); // micro-bumps\n        // reflected ray\n        vec3 rrd = reflect(rd,n);\n\t\t// normal towards light\n        vec3 ln = normalize(vec3(1,2,3));\n\t\t// 1. - occlusion\n        float ao = pow(traceAO(p, n), 1.+3.*t);\n        // surface color\n        vec3 col1 = .45 * (vec3(.7,1.,.4) + kali_tex(p, par3));\n        vec3 col2 = vec3(1.,.8,.6) + .3 * vec3(1.,.7,-.6) * kali_tex(p, par3);\n        vec3 k = kali_set_av(sin(p*(1.+3.*ao))*.3, par3);\n        vec3 surf = (.1 + .9 * ao) \n            \t\t//* vec3(1.);\n            \t\t* mix(col1, col2, min(1., pow(ao*2.2-.8*kt.x,5.)));\n\t\t// desaturate\n        surf += .24 * (dot(surf,vec3(.3,.6,.1)) - surf);\n\n        // -- lighting --\n        \n        float fres = pow(max(0., 1.-dot(rrd, n)), 1.) / (1.+2.*t);\n\n        // phong\n        surf += .25 * ao * max(0., dot(n, ln));\n        // spec\n        float d = max(0., dot(rrd, ln));\n        surf += .4 * pow(ao*1.2,5.) * (.5 * d + .7 * pow(d, 8.));\n\n        // fresnel highlight\n        surf += clamp((t-.06)*8., 0.,1.6) * \n            \t(.2+.8*ao) * vec3(.7,.8,1.) * fres;\n        \n        // environment map\n        surf += .2 * (1.-fres) * ao * skyColor(rrd);\n    \n        // distance fog\n    \tcol = surf * pow(1.-t / max_t, 1.3);\n        //col = n;\n    }\n    \n    return col;\n}\n\nstruct Point {\n    vec3 pos;\n    vec3 vel;\n};\n\nstruct CameraRig {\n\tPoint p1, p2, p3, p4, p5;\n};\n\nCameraRig loadCameraRig() {\n    return CameraRig(\n        Point(texelFetch(iChannel0, ivec2(0, 0), 0).xyz,\n    \t\t  texelFetch(iChannel0, ivec2(1, 0), 0).xyz),\n        Point(texelFetch(iChannel0, ivec2(2, 0), 0).xyz,\n    \t\t  texelFetch(iChannel0, ivec2(3, 0), 0).xyz),\n        Point(texelFetch(iChannel0, ivec2(4, 0), 0).xyz,\n    \t\t  texelFetch(iChannel0, ivec2(5, 0), 0).xyz),\n        Point(texelFetch(iChannel0, ivec2(6, 0), 0).xyz,\n    \t\t  texelFetch(iChannel0, ivec2(7, 0), 0).xyz),\n        Point(texelFetch(iChannel0, ivec2(8, 0), 0).xyz,\n    \t\t  texelFetch(iChannel0, ivec2(9, 0), 0).xyz)\n        );\n}\n\nvoid getCamera(out vec3 ro, inout vec3 rd) {\n\t\n    CameraRig rig = loadCameraRig();\n    vec3 \n        up = normalize(rig.p3.pos - rig.p1.pos),\n        right = normalize(rig.p2.pos - rig.p1.pos),\n        fwd = normalize(rig.p5.pos - rig.p1.pos);\n    \n    // comment the lines to see the true\n\t// to see the true camera transform\n    // The spring system is quite wobbly\n    // and seldom has true orthonormals\n    \n    //fwd = normalize(cross(right, up));\n    right = normalize(cross(up, fwd));\n    up = normalize(cross(fwd, right));\n    \n    \n    mat3 mat = mat3(right, up, fwd);\n    \n    ro = rig.p1.pos;\n    rd = mat * rd;\n}\n\n\n// by iq\nfloat lineSeg(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 suv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y * 2.;\n        \n    float ti = (iTime-14.)/8.;\n    \n    vec3 ro, rd;\n    rd = normalize(vec3(uv, 1.2));\n    getCamera(ro, rd);\n    \n    \n    vec3 col = rayColor(ro, rd);\n    \n    // debug display camera rig \n    if (false && suv.x*iResolution.x/iResolution.y < .4 && suv.y < .4)\n    {\n        CameraRig rig = loadCameraRig();\n        rig.p2.pos -= rig.p1.pos;\n        rig.p3.pos -= rig.p1.pos;\n        rig.p4.pos -= rig.p1.pos;\n        rig.p5.pos -= rig.p1.pos;\n        rig.p1.pos -= rig.p1.pos;\n        uv = suv * vec2(iResolution.x/iResolution.y, 1.) / .5 - .35;\n        col *= 0.1;\n        col += smoothstep(.04, 0., length(rig.p1.pos.xy - uv));\n        col += smoothstep(.04, 0., length(rig.p2.pos.xy - uv));\n        col += smoothstep(.04, 0., length(rig.p3.pos.xy - uv));\n        col += smoothstep(.04, 0., length(rig.p4.pos.xy - uv));\n        col += smoothstep(.04, 0., length(rig.p5.pos.xy - uv));\n        col += smoothstep(.02, 0., lineSeg(uv, rig.p1.pos.xy, rig.p2.pos.xy));\n        col += smoothstep(.02, 0., lineSeg(uv, rig.p1.pos.xy, rig.p4.pos.xy));\n        col += smoothstep(.02, 0., lineSeg(uv, rig.p2.pos.xy, rig.p3.pos.xy));\n        col += smoothstep(.02, 0., lineSeg(uv, rig.p3.pos.xy, rig.p4.pos.xy));\n        col += smoothstep(.02, 0., lineSeg(uv, rig.p1.pos.xy, rig.p3.pos.xy));\n        col += smoothstep(.02, 0., lineSeg(uv, rig.p1.pos.xy, rig.p5.pos.xy));\n        col += smoothstep(.02, 0., lineSeg(uv, rig.p2.pos.xy, rig.p5.pos.xy));\n        col += smoothstep(.02, 0., lineSeg(uv, rig.p4.pos.xy, rig.p5.pos.xy));\n        col += smoothstep(.02, 0., lineSeg(uv, rig.p3.pos.xy, rig.p5.pos.xy));\n    }\n     \n    col *= pow(1.-dot(suv-.5,suv-.5)/.5, .7);\n    \n\tfragColor = vec4(pow(col,vec3(.8)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n    The rig looks like this:\n\n      back        right\n\n        p3         p3\n        +          +\n       /|\\         |\\\n      / | \\        | \\\n     /  |p5\\       |  \\\n    +---+---+      +---+\n   p4   p1  p2    p1    p5\n\n\n   p1-p5 points along the view direction\n   p1-p2 is the right-vector, and p1-p3 the up-vector\n*/\n\n\nstruct Point {\n    vec3 pos;\n    vec3 vel;\n};\n\nstruct CameraRig {\n\tPoint p1, p2, p3, p4, p5;\n};\n\n// distance between adjacent points\nconst float cam_size = 0.05;\n\nconst float friction_air = 4.5;\nconst float friction_surface = 10.5;\nconst float constant_thrust = 0.9;       // constantly move along p1-p5 \nconst float thrust_along_normal = .2;  // scene normal pushes on p5\n\n\nfloat DE(in vec3 p);\nvec3 DE_norm(in vec3 p, in float eps);\n\n\nvoid integratePoint(inout Point p, in float stepsize) {\n\t// advance by velocity\n    p.pos += stepsize * p.vel;\n    // air friction\n    p.vel *= 1. - stepsize * friction_air;\n    \n    float de = DE(p.pos);\n    \n    //p.vel += stepsize * DE_norm(p.pos, 0.1) * smoothstep(.2, .0, de) * thrust_along_normal;\n    \n    if (de < 0.) {\n    \t// move point to surface\n        for (int i=0; i<3; ++i) {\n        \tvec3 n = DE_norm(p.pos, 0.01);\n        \tp.pos += n * -de * .7;\n        }\n        vec3 n = DE_norm(p.pos, 0.01);\n        // reflect at surface\n        n = DE_norm(p.pos, 0.01);\n        p.vel = reflect(p.vel, n);\n        p.vel *= 1. - stepsize * friction_surface;\n    }\n}\n\nvoid integrateSpring(inout Point p1, inout Point p2, in float rest_length, in float stepsize)\n{\n    float dist = distance(p1.pos, p2.pos);\n    \n    float factor = clamp((rest_length - dist)/dist, -1., 1.);\n    \n    vec3 dir = (p1.pos - p2.pos) * factor * stepsize;\n    \n    p1.vel += dir;\n    p2.vel -= dir;\n}\n\nvoid integrateCameraRig(inout CameraRig rig, in float steps) {\n    float stepsize = steps;\n\tintegrateSpring(rig.p1, rig.p2, cam_size, stepsize);\n    integrateSpring(rig.p1, rig.p3, cam_size, stepsize);\n    integrateSpring(rig.p1, rig.p4, cam_size, stepsize);\n    integrateSpring(rig.p1, rig.p5, cam_size, stepsize);\n    \n    integrateSpring(rig.p3, rig.p2, sqrt(2.) * cam_size, stepsize);\n    integrateSpring(rig.p3, rig.p4, sqrt(2.) * cam_size, stepsize);\n    integrateSpring(rig.p3, rig.p5, sqrt(2.) * cam_size, stepsize);\n    \n    integrateSpring(rig.p5, rig.p2, sqrt(2.) * cam_size, stepsize);\n    integrateSpring(rig.p5, rig.p4, sqrt(2.) * cam_size, stepsize);\n    \n    float de = DE(rig.p1.pos);\n    rig.p5.vel += stepsize * DE_norm(rig.p5.pos, 0.1) * smoothstep(.7, .0, de) * thrust_along_normal;\n    \n    vec3 thrust = normalize(rig.p5.pos - rig.p1.pos) * constant_thrust * steps;\n    rig.p1.vel += thrust;\n    rig.p2.vel += thrust;\n    rig.p3.vel += thrust;\n    rig.p4.vel += thrust;\n    rig.p5.vel += thrust;\n    \n    stepsize = steps;\n    integratePoint(rig.p1, stepsize);\n    integratePoint(rig.p2, stepsize);\n    integratePoint(rig.p3, stepsize);\n    integratePoint(rig.p4, stepsize);\n    integratePoint(rig.p5, stepsize);\n}\n\nvoid resetCameraRig(inout CameraRig rig) {\n    const vec3 initpos = vec3(1.35,1,.5);\n    \n    \n\trig.p1.pos = vec3( 0,  0,  0) * cam_size + initpos;\n    rig.p2.pos = vec3( 1,  0,  0) * cam_size + initpos;\n    rig.p3.pos = vec3( 0,  1,  0) * cam_size + initpos;\n    rig.p4.pos = vec3(-1,  0,  0) * cam_size + initpos;\n    rig.p5.pos = vec3( 0,  0, -1) * cam_size + initpos;\n\n    rig.p1.vel = vec3(0);\n    rig.p2.vel = vec3(0);\n    rig.p3.vel = vec3(0);\n    rig.p4.vel = vec3(0);\n    rig.p5.vel = vec3(0);\n}\n\nCameraRig loadCameraRig() {\n    return CameraRig(\n        Point(texelFetch(iChannel0, ivec2(0, 0), 0).xyz,\n    \t\t  texelFetch(iChannel0, ivec2(1, 0), 0).xyz),\n        Point(texelFetch(iChannel0, ivec2(2, 0), 0).xyz,\n    \t\t  texelFetch(iChannel0, ivec2(3, 0), 0).xyz),\n        Point(texelFetch(iChannel0, ivec2(4, 0), 0).xyz,\n    \t\t  texelFetch(iChannel0, ivec2(5, 0), 0).xyz),\n        Point(texelFetch(iChannel0, ivec2(6, 0), 0).xyz,\n    \t\t  texelFetch(iChannel0, ivec2(7, 0), 0).xyz),\n        Point(texelFetch(iChannel0, ivec2(8, 0), 0).xyz,\n    \t\t  texelFetch(iChannel0, ivec2(9, 0), 0).xyz)\n        );\n}\n\nvoid saveCameraRig(in CameraRig rig, in vec2 fragCoord, inout vec4 fragColor) {\n\tint x = int(fragCoord.x);\n    switch (x) {\n        case 0: fragColor.xyz = rig.p1.pos; break;\n        case 1: fragColor.xyz = rig.p1.vel; break;\n        case 2: fragColor.xyz = rig.p2.pos; break;\n        case 3: fragColor.xyz = rig.p2.vel; break;\n        case 4: fragColor.xyz = rig.p3.pos; break;\n        case 5: fragColor.xyz = rig.p3.vel; break;\n        case 6: fragColor.xyz = rig.p4.pos; break;\n        case 7: fragColor.xyz = rig.p4.vel; break;\n        case 8: fragColor.xyz = rig.p5.pos; break;\n        case 9: fragColor.xyz = rig.p5.vel; break;\n    }\n}\n\n\n\n// minimum distance to axis-aligned planes in kali-space\n// uses eiffie's mod (/p.w) https://www.shadertoy.com/view/XtlGRj\n// to keep the result close to a true distance function\nvec3 kali_set(in vec3 pos, in vec3 param)\n{\n    //const vec3 param = vec3(.9, .6, 1.);\n    vec4 p = vec4(pos, 1.);\n    vec3 d = vec3(100.);\n    for (int i=0; i<9; ++i)\n    {\n        p = abs(p) / dot(p.xyz,p.xyz);\n        d = min(d, p.xyz/p.w);\n        p.xyz = p.zxy - param;\n    }\n    return d;\n}\n\n\nfloat DE(in vec3 p)\n{\n    //p += sin(.1*p*vec3(3,5,7));\n    \n    vec3 mp = mod(p+.3, .6) - .3;\n    float d = length(mp) - .34;\n    d = - d;\n    // displacement\n    p *= .8;\n    vec3 k = kali_set(sin(p), vec3(.9, .6+.2*cos(p.x), 1.));\n    d += k.x+k.y+k.z;\n    return d;\n}\n\n\nvec3 DE_norm(in vec3 p, in float eps)\n{\n    vec2 e = vec2(eps, 0.);\n    return normalize(vec3(\n        DE(p+e.xyy) - DE(p-e.xyy),\n        DE(p+e.yxy) - DE(p-e.yxy),\n        DE(p+e.yyx) - DE(p-e.yyx)));\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.y >= 1. || fragCoord.x >= 10.)\n        return;\n    \n    bool reset = iFrame < 1;\n    \n    CameraRig rig = loadCameraRig();\n    \n    \n    if (reset) {\n    \tresetCameraRig(rig);\n    }\n    \n    for (int i=0; i<10; ++i)\n    {\n        integrateCameraRig(rig, 1./60./10.);\n    }\n    \n    fragColor = vec4(0.);\n    saveCameraRig(rig, fragCoord, fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}