{
    "Shader": {
        "info": {
            "date": "1501008754",
            "description": "Made in a hurry today :-)",
            "flags": 0,
            "hasliked": 0,
            "id": "ls2fRG",
            "likes": 4,
            "name": "[SH17B] Run junior run !",
            "published": 3,
            "tags": [
                "sh17b"
            ],
            "usePreview": 0,
            "username": "VB",
            "viewed": 650
        },
        "renderpass": [
            {
                "code": "///////////////////////////////////////////////////////////////////////////////////////\nfloat udTorso( vec3 p, vec3 b, float r )\n{\n  b.x = b.x - 0.1*b.x * p.y;\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.w<d2.w) ? d1 : d2;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel2, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n///////////////////////////////////////////////////////////////////////////////////////\n\n#define PI \t\t(3.1415926535)\n\n#define HEAD_H  (0.3)\n#define LEGS_H  (HEAD_H * 4.0)\n\n#define TORSO_R (0.1)\n#define TORSO_H (HEAD_H * 2.7)\n#define TORSO_Y (LEGS_H + TORSO_H *0.5)\n\n#define NECK_H  (HEAD_H * 0.3)\n#define NECK_Y  (TORSO_Y + TORSO_H + TORSO_R + NECK_H)\n\n#define SLOPE \t\t(PI/12.0)\n#define CORRIDOR_W \t(3.4) \n#define SPEED \t\t(3.8)\n\n#define M_GROUND \t(vec3(-1.0))\n#define M_BOULDER \t(vec3(-2.0))\n\nvec3 calcNormal( in vec3 pos );\n\nvec3 triplanar(vec3 p, vec3 n, sampler2D tex, float scale)\n{   \n\tvec3 blending = abs( n );\n\tblending = normalize(max(blending, 0.00001));\n\tfloat b = (blending.x + blending.y + blending.z);\n\tblending /= vec3(b, b, b);\n        \n    vec3 xaxis = pow(texture( tex, p.yz*scale).rgb, vec3(2.2));\n\tvec3 yaxis = pow(texture( tex, p.xz*scale).rgb, vec3(2.2));\n\tvec3 zaxis = pow(texture( tex, p.xy*scale).rgb, vec3(2.2));\n\t\n\treturn xaxis * blending.x + yaxis * blending.y + zaxis * blending.z;\n}\n\nvec3 railOffset(float t)\n{\n    vec3 dir = vec3(0.0,-sin(SLOPE),cos(SLOPE));\n    return dir * t * SPEED;\n}\n\nvec4 mapGround(vec3 p)\n{\n    vec4 n = vec4(0.0,cos(SLOPE),sin(SLOPE),0.0);\n    float d = sdPlane(p, n);    \n    \n    vec4 n2 = vec4(-1.0, 0.0, 0.0, CORRIDOR_W);\n    d = min(d, sdPlane(p, n2));\n    \n    vec4 n3 = vec4(1.0, 0.0, 0.0, CORRIDOR_W);\n    d = min(d, sdPlane(p, n3));    \n    \n    return vec4(M_GROUND, d);\n}\n\nvec4 mapBoulder(vec3 p)\n{   \n    float t = iTime - (cos(iTime*3.5)*0.5+0.5)*0.7 - 1.55;\n    p -= railOffset(t);\n    p.y -= CORRIDOR_W;\n \n    mat3 mRx = rotateX(iTime*4.0);\n    p = mRx * p;     \n                                     \n    float d = sdSphere( p, CORRIDOR_W );\n    \n    float theta = acos(p.x / CORRIDOR_W);\n    float phi = atan(p.y, p.z);\n    \n    vec3 c = pow(0.3*texture(iChannel0, vec2(theta/(PI*2.0), phi/PI)).rgb, vec3(2.2));\n    return vec4(c, d);\n}\n\nvec4 mapHead(vec3 p)\n{\n    vec3 c_skin = 0.3 * pow(vec3(221.0,172.0,140.0)/255.0, vec3(2.2));\t\n    \n    // neck\n    vec4 res = vec4(c_skin, sdCappedCylinder(p - vec3(0.0, NECK_Y, 0.0), vec2(0.25, NECK_H)));\n    \n    // head\n    float y = NECK_Y + NECK_H*2.0 + HEAD_H*0.5;\n    res = opU(res, vec4(c_skin, sdCappedCylinder(p - vec3(0.0, y, 0.0), vec2(0.4, HEAD_H))));\n  \n    // hat\n    vec3 c_hat = 0.3*pow(vec3(87.0,44.0,24.0)/255.0, vec3(2.2));\t\n    float h = 0.01;\n    y += HEAD_H + h;\n    res = opU(res, vec4(c_hat, sdCappedCylinder(p - vec3(0.0, y, 0.0), vec2(0.8, h))));\n    y += h;\n    h = 0.2;\n    y += h;\n    res = opU(res, vec4(c_hat, sdCappedCylinder(p - vec3(0.0, y, 0.0), vec2(0.45, h))));\n    \n    return res;\n} \n\nvec4 mapChar(vec3 p)\n{\n    // position\n    vec3 pc = p - railOffset(iTime - (cos(iTime*3.5)*0.5+0.5)*0.2 + (cos(iTime*0.5)*0.5+0.5)*0.15);\n    pc.y += sin(iTime*14.0)*0.1;\n    \n    // torso\n    vec3 c_torso = 0.3 * pow(vec3(42.0,32.0,24.0)/255.0, vec3(2.2));\n    float d = udTorso(pc - vec3(0.0, TORSO_Y, 0.0), vec3(0.57,TORSO_H,0.25), TORSO_R);\n    vec4 res = vec4(c_torso, d);\n    \n    // head\n    res = opU(res, mapHead(pc));   \n    \n    return res;\n}\n\nvec4 map( in vec3 p )\n{\n    // env\n    vec4 res = mapGround(p);\n    \n    // boulder\n    res = opU(res, mapBoulder(p));\n        \n    // character\n    res = opU(res, mapChar(p));\n    \n    //\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).w + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).w + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).w + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).w );\n}\n\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 2.0;\n    float tmax = 30.0;   \n    float t = tmin;\n    vec3 c = vec3(0.0);\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec4 res = map( ro+rd*t );\n        if( res.w<precis || t>tmax) \n        {\n            c = res.xyz;\n            break;\n        }\n        t += res.w;  \n    }\n    if( t>tmax ) \n    {\n        c = vec3(1.0,0.0,1.0);\n        t = 99.0;\n    }\n    return vec4( c, t );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).w;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );    \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).w;\n        res = min( res, h /*8.0*h/t*/ );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.01 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    //\n    vec3 d = railOffset(iTime);\n    \n\t// camera    \n    float a = iTime * 0.15 * PI;\n    vec3 ro = vec3( 1.5, 1.5, 3.3);\n    vec3 ta = vec3( 0.0, 2.0, 0.0 );\n    \n    vec3 dir = vec3(0.0,-sin(SLOPE),cos(SLOPE));\n    ro += railOffset(iTime);\n    \n    // camera-to-world transformation\n    float camNoise1 = noise(d*d/10.0)*0.045;\n    float camNoise2 = noise(d*d*d/20.0)*0.015;\n    mat3 ca = setCamera( ro + vec3(camNoise1,camNoise2,camNoise2), ta, camNoise1);\n    \n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy, 1.3) );\n\n    vec3 bgColor = 0.1*vec3(108.0,148.0,147.0)/255.0;\n    vec3 col = bgColor;\n    \n    // render\n    vec4 res = castRay( ro, rd );\n    if (res.w < 50.0)\n    {\t\n        //\n        vec3 p = ro+rd*res.w;\n        \n        // normal\n        vec3 n = calcNormal(p);        \n        if (res.rgb == M_GROUND)\n        {\n\t\t\tres.rgb = 0.1 * triplanar(p, n, iChannel1, 0.25);\n        }\n        \n        vec3 albedo = res.rgb;        \n        vec3 ref = reflect( rd, n );\n        float ao = calcAO(p, n);\n        \n        // ambient\n        col = ao * albedo * 0.1;\n        \n        // light 1\n        vec3 l1_d = normalize(normalize(d)+vec3(10.0*camNoise1,0.0,0.4));\n        vec3 l1_col = vec3(noise(d)) * vec3(15.0) * vec3(255.0,209.0,118.0)/255.0;\n        vec3 l1_diff = l1_col * albedo * (dot(l1_d, n) * 0.5 + 0.5);\n        vec3 l1_spec = l1_diff * l1_col * pow(clamp( dot( ref, l1_d ), 0.0, 1.0 ), 16.0);        \n        float sh1 = 6.0*softshadow(p + n * 0.05, l1_d, 0.05, 50.0 );\n\t\tcol += ao * sh1 * (l1_diff + l1_spec);        \n\n        // light 2\n        vec3 l2_d = normalize(vec3(0.5, 1.0, 0.2));\n        vec3 l2_col = 0.8 * vec3(noise(d*0.5)) * vec3(4.0) * vec3(255.32,0.0,32.0)/255.0;\n        vec3 l2_diff = l2_col * albedo * (dot(l2_d, n) * 0.5 + 0.5);\n        vec3 l2_spec = l2_diff * l2_col * pow(clamp( dot( ref, l2_d ), 0.0, 1.0 ), 16.0);        \n        float sh2 = 8.0*softshadow(p + n * 0.05, l1_d, 0.05, 50.0 );\n\t\tcol += ao * sh2 * (l2_diff + l2_spec);        \n        \n        //col = vec3(sh1);\n        \n#if 0\n    \tcol = n*vec3(0.5)+vec3(0.5);\n#endif\n                \n        // fog\n        float t = res.w;\n        col = mix( col, bgColor, 1.0-exp( -0.0001*t*t*t ) );\n\n    }\n    \n    fragColor.rgb = pow(col, vec3(1.0/2.2));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}