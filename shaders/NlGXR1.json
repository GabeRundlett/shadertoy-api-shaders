{
    "Shader": {
        "info": {
            "date": "1640137502",
            "description": "shader about boucing animation, space transformation, easing functions, funny shape and colorful vibes.",
            "flags": 0,
            "hasliked": 0,
            "id": "NlGXR1",
            "likes": 9,
            "name": "happy bouncing variation 2",
            "published": 3,
            "tags": [
                "colorful",
                "animation"
            ],
            "usePreview": 0,
            "username": "leon",
            "viewed": 313
        },
        "renderpass": [
            {
                "code": "// Fork of \"happy bouncing variation 1\" by leon. https://shadertoy.com/view/ftGXR1\n// 2021-12-22 00:28:04\n\n// Fork of \"happy bouncing\" by leon. https://shadertoy.com/view/flyXRh\n// 2021-12-22 00:11:16\n\n// \"happy bouncing\"\n// shader about boucing animation, space transformation, easing functions,\n// funny shape and colorful vibes.\n// by leon denise (2021-12-21)\n// licensed under hippie love conspiracy\n\n// using Inigo Quilez works:\n// arc sdf from https://www.shadertoy.com/view/wl23RK\n// color palette https://iquilezles.org/articles/palettes\n\n// global variable\nvec3 rng;\nfloat bodySize = 0.2;\n\n// shape eyes\nvec2 size = vec2(.07, .05);\nfloat divergence = 0.06;\n\n// easing curves are below\nfloat jump(float);\nfloat walk(float);\nfloat stretch(float);\nfloat bounce(float);\nfloat swing(float);\n\n// list of transformation (fun to tweak)\nvec2 animation(vec2 p, float t)\n{\n    t = fract(t);\n    \n    p.y -= bodySize;\n    // sidebar\n    p.y -= 0.1;\n    p.y -= (jump(t))*.5;\n    //p.x += walk(t)*0.1;\n    \n    return p;\n}\n\nvec4 sdEyes (vec2 p, float t, vec3 tint, float sens)\n{\n    vec3 col = vec3(0);\n    float shape = 100.;\n    \n    // eyes positions\n    p = animation(p, t);\n    p *= rot(swing(t)*-.5);\n    p -= vec2(.03, bodySize+size.x*.2);\n    p.x -= divergence*sens;\n\n    // globe shape\n    float eyes = circle(p, size.x);\n    col = mix(col, tint, fill(eyes));\n    shape = min(shape, eyes);\n\n    // white eye shape\n    eyes = circle(p, size.y);\n    col = mix(col, vec3(1), fill(eyes));\n\n    // black dot shape\n    eyes = circle(p, 0.02);\n    col = mix(col, vec3(0), fill(eyes));\n    \n    return vec4(col, shape);\n}\n\nvoid mainImage( out vec4 color, in vec2 pixel )\n{\n    vec2 uv = pixel/iResolution.xy;\n    color = vec4(0,0,0,1);\n    \n    // ground\n    //color.rgb += mix(vec3(0.945,0.945,0.792), vec3(0.820,0.482,0.694), smoothstep(0.0,.2,uv.y-.2));\n    color.rgb += vec3(.25)*step(uv.y,0.1);\n    \n    // number of friends\n    const float buddies = 6.;\n    for (float i = 0.; i < buddies; ++i)\n    {\n        // usefull to dissociate instances\n        float ii = i/(buddies);\n        float iy = i/(buddies-1.);\n        \n        // translate\n        //ii = fract(ii+iTime*.2);\n        float iii = 1.-ii;\n        \n        // translate instances\n        vec2 pp = (pixel-vec2(0.5,0)*iResolution.xy)/iResolution.y;\n        pp.x += (iy*2.-1.)*.5;\n        pp *= 2.;\n        \n        // time\n        float t = fract(iTime*.5 + ii * .5);\n        \n        // there will be sdf shapes\n        float shape = 1000.;\n        vec2 p;\n        \n        // there will be layers\n        vec3 col = vec3(0);\n        \n        // color palette\n        // Inigo Quilez (https://iquilezles.org/articles/palettes)\n        vec3 tint = .5+.5*cos(vec3(0.,.3,.6)*6.28+i-length(animation(pp-vec2(0,.1),t))*3.);\n        \n        // body shape\n        p = animation(pp, t);\n        p.x *= stretch(t)*-0.2+1.;\n        float body = circle(p, bodySize);\n        col += tint*fill(body);\n        shape = min(shape, body);\n        \n        vec4 eyes = sdEyes(pp, t-.03, tint, -1.);\n        col = mix(col, eyes.rgb, step(eyes.a,0.));\n        shape = min(shape, eyes.a);\n        eyes = sdEyes(pp, t-.01, tint, 1.);\n        col = mix(col, eyes.rgb, step(eyes.a,0.));\n        shape = min(shape, eyes.a);\n        \n        // smile animation\n        float anim = cos(pow(t, 2.)*6.28)*.5+.5;\n        \n        // smile position\n        p = animation(pp, t-0.01);\n        p -= bodySize*vec2(.1, .6-1.*anim);\n        vec2 q = p;\n        \n        // arc (fun to tweak)\n        float smile = mix(0., 1., anim);//+(.5+.5*sin(ii*12.+iTime*12.*ii));\n        float thin = mix(0.05, 0.01, anim);//+0.04*(.5+.5*sin(ii*12.+iTime*22.*ii));\n        float d = sdArc(p,-3.14/2., smile, 0.1, thin);\n        \n        // black line\n        col = mix(col, tint*(fract(q.y*5.)*.7+.3), fill(d));\n        \n        // add buddy to frame\n        float ao = clamp(shape+.9,0.,1.);\n        color.rgb = mix(color.rgb * ao, col, step(shape, 0.));\n    }\n}\n\n// easing curves (not easy to tweak)\n// affect timing of transformations;\n\nfloat jump (float t)\n{\n    t = min(1., t*4.);\n    t = abs(sin(t*3.1415));\n    return pow(sin(t*3.14/2.), .5);\n}\n\nfloat walk (float t)\n{\n    t = mix(pow(t,.5), pow(t, 2.0), t);\n    return (cos(t*3.1415*2.));\n}\n\nfloat swing (float t)\n{\n    //t = pow(t, .5);\n    //t = t*2.;\n    //t = pow(t, .5);\n    t = sin(t*3.14*2.);\n    return t;\n}\n\nfloat stretch (float t)\n{\n    float tt = sin(pow(t, 2.)*10.);\n    return tt;\n}\n\nfloat bounce (float t)\n{\n    float tt = cos(pow(t, .5)*3.14);\n    return tt;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdArc( in vec2 p, in float ta, in float tb, in float ra, float rb )\n{\n    vec2 sca = vec2(sin(ta),cos(ta));\n    vec2 scb = vec2(sin(tb),cos(tb));\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p,scb) : length(p);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n// snippets\n#define fill(sdf) (smoothstep(.001, 0., sdf))\n#define repeat(p,r) (mod(p,r)-r/2.)\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat circle (vec2 p, float size)\n{\n    return length(p)-size;\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}