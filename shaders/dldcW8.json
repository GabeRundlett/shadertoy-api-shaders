{
    "Shader": {
        "info": {
            "date": "1699160734",
            "description": "twisted toroidal spherical regular dodecahedron",
            "flags": 0,
            "hasliked": 0,
            "id": "dldcW8",
            "likes": 8,
            "name": "twisted dodecahedron",
            "published": 3,
            "tags": [
                "3d",
                "sdf",
                "stereographic"
            ],
            "usePreview": 0,
            "username": "cyperus",
            "viewed": 311
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"twisted dodecahedron\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n// DOCUMENTATION:\n//  - https://people.maths.ox.ac.uk/trefethen/lightning.html\n// \n////////////////////////////////////////////////////////////////////////////////\n\n#define BG_CUBEMAP\n\n// ray casting bounding shape\nconst float CAM_DIST = 4.;\nconst float CAM_FLE = 1.3;\nconst float BBOX_RADIUS = 8.;\nconst float RAY_MIN_DIST = 0.;\nconst float RAY_MAX_DIST = CAM_DIST+1.1*BBOX_RADIUS;\n\n// ray march\nconst int MAX_MARCHING_STEPS = 700; // <1, 700, 2000>\nfloat RAY_STEP_FACTOR3 = 0.27755;   // <0.05, 0.27755 ,0.5>\nconst float RAY_PRECISION = 0.00001;\n\n// 4D rotation\nconst bool ROT_4D = false;\nfloat ROT_4D_t = 0.; \n\n// dodecahedron\nconst int PS_f = 12;\nconst int PS_e_f= 5;\nfloat PS_a0 = 8.;\n\n// torus\nfloat J1_sh_a0 = -1.0; // -1.0\nfloat J1_sh_a1 = -0.4; // -0.4\nint   J1_sh_f1 = 1*PS_e_f;\nfloat J1_sh_pa1 = 0.03;\nint   J1_to_c1 = 6*PS_e_f;\nint   J1_to_f1 = 2*PS_e_f;\nconst float J1_to_pa1 = 0.;\n\n// texture\n// 0: dodeca_cell_id <-> stripes, 1: stripes, 2: normal, 3: dodeca_cell_id, else: plain color\nconst int   TEX_MODE = 0;\nconst bool  TEX_UV_ON = false;\nconst float TEX_UV_SHARPNESS = 0.00000001;\nconst vec2  TEX_UV_SUBDIV = vec2(1*PS_e_f, 1*PS_e_f);\n\n// fog\nbool  FOG_ON = true;\nconst float FOG_DENSITY = 0.003;\n\nfloat map(in vec3 p, out vec4 mat) {   \n    //// sdf's\n    float rxy = 0., au = 0.0, av = 0.0;\n    float cell_id = 0., sr = 0.; //sig(sr): sens of rotation, abs(sr) : number edges per face\n    vec2 z = vec2(0.);\n    \n    // stereographic 4D, rotation\n    if(ROT_4D) p = rot4Dz( p, ROT_4D_t, sqrt(abs(PS_a0)));\n           \n    //// map platonic solid cells to one cell\n    vec3 pn = normalize(p); \n  \n    // projection from n cells to 1 cell. \n    pn = dodeca_cells(pn, cell_id, sr);\n    // invers stereographic projection\n    //if (pn.z < 0.) // north pol\n    {\n        z = pn.xy/(1.-pn.z);\n        z = cDodecaPolyArc2disk(z);\n    }\n\n    /// r-polygon-distribution\n    vec2 e = vec2(3., 0.5);\n    float en = 1.+( (PS_a0<0.?e.x:e.y)-1. )*smoothstep(1.,5., abs(PS_a0));        \n    float r = length(z); vec2 zn = z/r;\n    z = dist(r, en) * zn;   \n\n    /// stereograpic projection    \n    pn = sp(vec3(z,sr));\n\n    /// scale radius\n    p = length(p) * pn;\n    \n    float fracu = 1.0;\n    ////fractal level 0: Torus\n    au = atan(p.y, p.x);\n    rxy = length(p.xy); \n    z = vec2(rxy, p.z);\n    z = cmul(z,z); z.x -= PS_a0;\n    \n    ////fractal level 1: 2Djulia realaxis-translation,fraction,rotation\n    float sh1 = J1_sh_a0;\n    float to1 = au*float(J1_to_c1)/float(J1_to_f1);\n    sh1 += J1_sh_a1*(1.-pulsecollision(float(J1_sh_f1),au/PI, J1_sh_pa1, 0.5));\n    to1 += J1_to_pa1;  \n    z = crpt(z, to1, float(J1_to_f1), sh1);\n    fracu *= float(J1_sh_f1);\n\n    // distance estimation\n    float d = log(length(z));\n    \n    #if 0\n    st_assert( d != INF, 0 ); // Shows the +INF singularity as a sphere (floating point precision).\n    #else\n    if (d == INF) {d = 1.;} // step through the singularity\n    #endif\n    \n    mat.x = cell_id; mat.yz = z; mat.w = au *fracu; // platonic solid cell_id, metatorus complex plane, metatorus angle_u\n    return d;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, out vec4 rescol, in float px) {\n    float res = -1.0; // init no intersection\n    \n    // bounding shape BB\n    vec2 dis = isphere( ro, rd , abs(BBOX_RADIUS));\n    \n    if( dis.y<0.0 ) return -1.0; // check BB behind came\n\n    dis.x = max( dis.x, RAY_MIN_DIST ); // check min ray length\n    dis.y = min( dis.y, RAY_MAX_DIST ); // check max ray length\n\n    // raymarch signed distance field\n    vec4 trap; // data from surface intersection point\n    \n\tfloat fh = RAY_STEP_FACTOR3;\n    float t = dis.x; // ray starts at boundingbox\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) // max steps\n    { \n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t; //th = 0.0001; // minimal bound surface hit\n        float h = map( pos, trap );\n        if( t>dis.y || h<th ) break; // ray outside BB or hit.\n        t += h*fh; // distance\n    }\n    if( t<dis.y ) // ray inside BB\n    {\n        rescol = trap;\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec4 tmp; // dummie\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy,tmp) - map(p-e.xyy,tmp),\n\t\tmap(p+e.yxy,tmp) - map(p-e.yxy,tmp),\n\t\tmap(p+e.yyx,tmp) - map(p-e.yyx,tmp) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) {\n\t// camera transformation\n\tif (iMouse.x > 0.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n\treturn p.xyz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // slider mapping\n    RAY_STEP_FACTOR3 = (0.5-0.0001)* pow(RAY_STEP_FACTOR3, 3.) + 0.0001;\n    \n    // time modulation shape\n    const float time_periode = 30.; // 2.*2.*(1.5+3.+3.) in seconds\n    float ntime    = iTime/time_periode;\n    float ntime_id = floor(ntime);     // in {0., 1., 2., ... }\n    float ntime_fr = ntime - ntime_id; // in [ 0.,+1.]\n    ROT_4D_t = ntime;\n\n    PS_a0 *= sin(2.*PI*ntime); // in [-PS_a0, +PS_a0] in length units fractal level 0;\n\n    int sw0 = int(ntime_id) % 2;   \n    if (PS_a0 >= 0.) {\n        J1_sh_a0 = -1.0 * smoothstep( 2., 4., PS_a0);\n        J1_sh_a1 = -0.4 * smoothstep( 4., 6., PS_a0);\n        J1_sh_f1 = sw0*PS_e_f;\n        J1_sh_pa1 *= 30. * ntime; //\n        J1_to_c1 = (3 -4 * sw0) * 2 * PS_e_f; // \n        //J1_to_f1 = 2*PS_e_f;\n    }\n    else {\n        J1_sh_a0 = 2. *smoothstep( 2., 4., -PS_a0); // -2.\n        J1_sh_a1 = 0. *smoothstep( 4., 6., -PS_a0);\n        //J1_sh_f1 = 1*PS_e_f;\n        J1_sh_pa1 *= 0. * ntime;\n        J1_to_c1 = 0*PS_e_f;\n        J1_to_f1 = (sw0+1) *PS_e_f;    \n    }\n      \n    // normalized coords\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    // camera viewport --> worldspace\n    vec3 ro = vec3(0,0,-CAM_DIST);\n    vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n    \t ro = transform(ro,iTime);\n\t     rd = normalize(transform(rd,iTime));\n\n    // ray\n    vec4 mat = vec4(0.0); // material-data: vec4(float cell_id, vec2 complex plane, float angle-u)\n    float px = 2.0/( iResolution.y*CAM_FLE );\n    float t = intersect( ro, rd, mat, px ); // distance hit ray surface\n    \n    // color\n    vec3 col_sun = vec3(1.,1.,0.8);\n    vec3 col_sky = vec3(0.8,0.8,1.);\n    #ifdef BG_CUBEMAP\n    vec3 col_nebula = srgb2rgb(texture(iChannel0, rd).rgb);\n    // background-color\n    vec3 bg_col = col_sky * col_nebula;\n    #else\n    vec3 bg_col = vec3(0.9);    \n    #endif\n\n    vec3 col = vec3(0.3); // init, test-color\n    // no hit -> sky\n    if (t < 0.0) {\n        col = bg_col;\n    }\n    // hit -> object surface\n    else {\n    \t// surface properties\n        vec3 p = ro + rd * t;\n        vec3 n = calcNormal( p, 0.001);        \n        // object id\n        float obj_id = mat.x;\n        // uv-coords\n        vec2 mat_uv;\n        mat_uv.x = 0.5*mat.w/PI;\n        mat_uv.y = atan(mat.z,mat.y)/PI;\n        // uv-texture\n        col = (TEX_MODE == 0) ? mix( h2rgb(obj_id/float(PS_f)),h2rgb(abs(mat_uv.y)) ,smoothstep(1.,3., abs(PS_a0)) ) // dodeca_cell_id <-> stripes\n            : (TEX_MODE == 1) ? h2rgb(abs(mat_uv.y))       // stripes\n            : (TEX_MODE == 2) ? 0.6*n+vec3(0.4)            // normal\n            : (TEX_MODE == 3) ? h2rgb(obj_id/float(PS_f))  // dodeca_cell_id\n            : vec3(0.8);\n        \n        // uv-grid (TODO: not orthogonal!)\n        if(TEX_UV_ON) {\n            mat_uv *= PI*TEX_UV_SUBDIV;\n            col *= 0.5+ 0.5*smoothstep(-TEX_UV_SHARPNESS,TEX_UV_SHARPNESS, sin(mat_uv.x)*sin(mat_uv.y) );\n        }        \n        // lighting\n        // point_light\n        vec3 point_lo = vec3(0, -10000, 0);\n        vec3 point_ld = normalize(point_lo - p);\n        // cubemap light\n        #ifdef BG_CUBEMAP\n        vec3 col_spe = srgb2rgb(texture(iChannel0, reflect(rd, n)).rgb);\n        #endif\n        // Phong: ambient- diffuse- specular- light reflections\n        #ifdef BG_CUBEMAP        \n        col = 0.25  * col * col_sky\n            + 0.5   * col * col_sky * col_spe\n            + 0.125 * col * col_sun * clamp(dot(point_ld, n), 0., 1.)\n            + 0.125 * col * col_sun * pow(clamp(dot(reflect(point_ld, n), -rd), 0., 1.), 10.);\n        // fresnel\n        col += pow(clamp(1. - dot(n, -rd), 0., 1.), 5.) * 0.4 * bg_col;\n        #else\n        col = 0.5  * col\n            + 0.25 * col * col_sun * clamp(dot(point_ld, n), 0., 1.)\n            + 0.25 * col * col_sun * pow(clamp(dot(reflect(point_ld, n), -rd), 0., 1.), 10.);\n        #endif\n\n    }\n    // fog\n    if(FOG_ON) col = mix(col, bg_col, 1.0 - exp(-FOG_DENSITY * pow(t,3.)));\n    // gamma correction\n    fragColor = vec4(rgb2srgb(col),1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// consts\nconst float PI = abs(atan(0.,-1.));\nconst float PI_2 = PI/2.;\nconst float INF = abs(1./0.);\nconst float NAN = abs(0./0.);\n\n/// 1D transformations\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    /*\n    x  : periodic in [0,1]\n    x0 : offset\n    pw : pulse width in [0,1]\n    pf : pulse frequency \n    */\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5); // x_normalized triangle wave function moving in +x_direction\n    float ntriw_n = abs( fract( pf*(x + x0) )-0.5); // x_normalized triangle wave function moving in -x_direction\n    float pp = smoothstep( 0.5*pw, 0., ntriw_p );   // pulse moves in +x_direction\n    float pn = smoothstep( 0.5*pw, 0., ntriw_n );   // pulse moves in -x_direction\n    return (pp+pn);                                 // smooth superposition\n}\n\n/// 2D transformations\n/// complex\nvec2 cmul(vec2 za,vec2 zb){\n    return za*mat2(zb.x,-zb.y,zb.yx);}\n\nvec2 crot(vec2 z,float a){\n    return cmul(vec2(cos(a),sin(a)),z);}\n\nvec2 cinv(vec2 z){\n    return z*vec2(1,-1)/dot(z,z);}\n    \nvec2 cdiv(vec2 z, vec2 w){\n    return cmul(z,cinv(w));}\n\nvec2 cpow(vec2 z, float q){\n    float r=pow(length(z), q);\n\tfloat a=q*atan(z.y,z.x);\n    return vec2(r*cos(a),r*sin(a));}\n\nvec2 cpow(vec2 z, int n){\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));}\n\nvec2 crpt(vec2 z, float a, float p, float x0){\n  /* (z*e^ia)^p-x0 */\n  return cpow( cmul(z, vec2(cos(-a),sin(-a))),p) - vec2(x0, 0.);}\n\nvec2 cDodecaPolyArc2disk(vec2 z){\n    // https://people.maths.ox.ac.uk/trefethen/lightning.html\n    const int NUM_j = 25; // poles\n    const vec2[] rf = vec2[NUM_j]\n    (vec2(-0.8260, - 0.5637)\n    ,vec2( 0.8091, + 0.5877)\n    ,vec2(-0.3090, - 0.9511)\n    ,vec2(-0.3089, - 0.9511)\n    ,vec2( 0.8089, - 0.5879)\n    ,vec2(-1.0000, + 0.0000)\n    ,vec2(-1.0000, + 0.0001)\n    ,vec2(-0.3090, + 0.9511)\n    ,vec2(-0.3089, + 0.9511)\n    ,vec2( 0.9996, - 0.0294)\n    ,vec2( 0.9103, + 0.4140)\n    ,vec2( 0.2242, + 0.9746)\n    ,vec2( 0.3369, - 0.9415)\n    ,vec2(-0.8576, + 0.5143)\n    ,vec2(-0.4307, - 0.9025)\n    ,vec2(-0.3567, + 0.9342)\n    ,vec2(-0.9988, - 0.0485)\n    ,vec2( 0.7796, + 0.6263)\n    ,vec2( 0.7796, - 0.6263)\n    ,vec2(-0.2828, - 0.9592)\n    ,vec2(-0.3161, + 0.9487)\n    ,vec2(-1.0000, + 0.0075)\n    ,vec2(-0.2187, + 0.9758)\n    ,vec2( 0.8366, - 0.5479)\n    ,vec2( 0.8134, + 0.5817));\n\n    const vec2[] rw = vec2[NUM_j]\n    (vec2(-0.1213, - 0.0   )\n    ,vec2( 0.0028, + 0.0187)\n    ,vec2( 0.0000, - 0.0000)\n    ,vec2(-0.0010, + 0.0008)\n    ,vec2(-0.0017, - 0.0008)\n    ,vec2(-0.0000, - 0.0000)\n    ,vec2(-0.0041, - 0.0007)\n    ,vec2(-0.0000, - 0.0000)\n    ,vec2( 0.0219, - 0.0012)\n    ,vec2(-0.2767, - 0.2629)\n    ,vec2( 0.2548, - 0.3937)\n    ,vec2( 0.4733, + 0.0936)\n    ,vec2(-0.0954, - 0.0232)\n    ,vec2(-0.1703, + 0.0600)\n    ,vec2(-0.0347, - 0.0277)\n    ,vec2(-0.3617, + 0.0048)\n    ,vec2(-0.0493, + 0.0086)\n    ,vec2( 0.1573, + 0.1009)\n    ,vec2(-0.0406, - 0.0040)\n    ,vec2(-0.0118, - 0.0116)\n    ,vec2( 0.0485, + 0.1712)\n    ,vec2(-0.0014, + 0.0204)\n    ,vec2( 0.1498, + 0.3189)\n    ,vec2(-0.0419, - 0.0255)\n    ,vec2( 0.1042, - 0.0471));\n\n    const vec2[] rz = vec2[NUM_j]\n    (vec2(-0.2339, - 0.1614)\n    ,vec2( 0.2737, + 0.1982)\n    ,vec2(-0.1045, - 0.3217)\n    ,vec2(-0.1039, - 0.3216)\n    ,vec2( 0.2731, - 0.1991)\n    ,vec2(-0.3383, + 0.0   )\n    ,vec2(-0.3379, + 0.0006)\n    ,vec2(-0.1045, + 0.3217)\n    ,vec2(-0.1039, + 0.3216)\n    ,vec2( 0.2841, - 0.0069)\n    ,vec2( 0.2810, + 0.1078)\n    ,vec2( 0.0682, + 0.2764)\n    ,vec2( 0.0943, - 0.2680)\n    ,vec2(-0.2418, + 0.1502)\n    ,vec2(-0.1496, - 0.2698)\n    ,vec2(-0.1287, + 0.2944)\n    ,vec2(-0.3202, - 0.0306)\n    ,vec2( 0.2411, + 0.2130)\n    ,vec2( 0.2411, - 0.2130)\n    ,vec2(-0.0808, - 0.3165)\n    ,vec2(-0.1114, + 0.3141)\n    ,vec2(-0.3331, + 0.0088)\n    ,vec2(-0.0510, + 0.3095)\n    ,vec2( 0.2770, - 0.1635)\n    ,vec2( 0.2747, + 0.1886));\n    \n    // polynomial barycentric representation\n    vec2 zn = vec2(0.); vec2 zd = vec2(0.);       \n    for(int j = 0; j<NUM_j; j++)\n    {\n        vec2 zj = cdiv( rw[j], (z-rz[j]));\n        zd += zj; // sum denominator\n        zn += cmul(rf[j], zj); // sum nominator\n    }\n    return cdiv(zn, zd);\n}\n\n/// 4D transformation\nvec3 rot4Dz(in vec3 p, in float t, in float r_inv) {\n    float a = 2.*PI*t;    \n    p /= r_inv;\n    float rn = length(p);\n    float rn2 = dot(rn,rn);\n    vec2 zw = cmul(vec2(2.*p.z, rn2-1.),vec2(cos(a),sin(a)));\n    p = vec3(2.*p.xy,zw.x)/(rn2+1.-zw.y);   \n    return r_inv * p;\n}\n\n// map spherical platonic solid pyramidal-face-cells to one cell located at -z-axis.\nvec3 dodeca_cells(in vec3 p, out float cell_id, out float sr) {\n\t//// dodecaeder\n\tconst float gr0 = (1.+sqrt(5.))/2.; const float gr1 = 1./gr0; const float gr2 = gr0-gr1;\n\t// cell-wall-face-normals\n\tbool nx = dot(vec3( 1., 0., 0.),p)>=0.;\n\tbool ny = dot(vec3( 0., 1., 0.),p)>=0.;\n\tbool nz = dot(vec3( 0., 0., 1.),p)>=0.;\n\t//\n\tbool n0A = dot(vec3( gr2,-gr0, gr1),p)>=0.;\n\tbool n0B = dot(vec3( gr1, gr2,-gr0),p)>=0.;\n\tbool n0C = dot(vec3(-gr0, gr1, gr2),p)>=0.;\n\t//\n\tbool n1A = dot(vec3(-gr2,-gr0,-gr1),p)>=0.;\n\tbool n1B = dot(vec3(-gr1, gr2, gr0),p)>=0.;\n\tbool n1C = dot(vec3( gr0, gr1,-gr2),p)>=0.;\n\t//\n\tbool n2A = dot(vec3(-gr2, gr0, gr1),p)>=0.;\n\tbool n2B = dot(vec3(-gr1,-gr2,-gr0),p)>=0.;\n\tbool n2C = dot(vec3( gr0,-gr1, gr2),p)>=0.;\n\t//\n\tbool n3A = dot(vec3( gr2, gr0,-gr1),p)>=0.;\n\tbool n3B = dot(vec3( gr1,-gr2, gr0),p)>=0.;\n\tbool n3C = dot(vec3(-gr0,-gr1,-gr2),p)>=0.;\n\n\t// cells\n    float a = PI_2-atan((sqrt(5.)-1.)/2.);\n    float b = PI/10.; // 18°\n    float a_x = 0.; float a_y = 0.; float a_z = 0.;\n\t// ---------------------------------------------------------------\n\t//Fpxpy\n    if(ny && !n2B && n2C && !n0C && n0B)\t\n\t{\n\t\tcell_id = 0.;\n\t\ta_y = PI_2;\n        a_x = a-PI_2;\n\t\ta_z = b;\n\t}\n\t//Fnxny\n\telse if(!ny && n2B && !n2C && n0C && !n0B)\n\t{\n\t\tcell_id = 1.;\n\t\ta_y = PI_2;\n        a_x = a+PI_2;\n\t\ta_z = b;\n\t}\n\t// ---------------------------------------------------------------\n\t//Fpxny\n\telse if(ny && n1B && !n1C && n3C && !n3B)\n\t{\n\t\tcell_id = 2.;\n\t\ta_y = -PI_2;\n\t\ta_x =  a-PI_2;\n\t\ta_z =  b;\n\t}\n\t//Fnxpy\n\telse if(!ny && !n1B && n1C && !n3C && n3B)\n\t{\n\t\tcell_id = 3.;\n\t\ta_y = -PI_2;\n\t\ta_x =  a+PI_2;\n\t\ta_z =  b;\n\t}\n\t// ---------------------------------------------------------------\n\t//Fpypz\n\telse if(!nz && n3C && !n3A && n0A && !n0C)\n\t{\n\t\tcell_id = 4.;\n\t\ta_y =  0.;\n        a_x =  a;\n\t\ta_z =  b;\n\t}\n\t//Fnynz\n\telse if(nz && !n3C && n3A && !n0A && n0C)\n\t{\n\t\tcell_id = 5.;\n\t\ta_y =  0.; \n\t\ta_x =  a+PI;\n\t\ta_z =  b;\n\t}\n\n\t// ---------------------------------------------------------------\n\t//Fpynz\n\telse if(nz && n2C && !n2A && n1A && !n1C)\n\t{\n\t\tcell_id = 6.;\n\t\ta_y =  0.;\n        a_x = -a+PI;\n\t\ta_z = -b;        \n\t}\n\t//Fnypz\n\telse if(!nz && !n2C && n2A && !n1A && n1C)\n\t{\n\t\tcell_id = 7.;\n\t\ta_y =  0.;\n        a_x = -a;\n\t\ta_z = -b;       \n\t}\n\t// ---------------------------------------------------------------\n\t//Fpzpx\n\telse if(!nx && n1A && !n1B && n0B && !n0A)\n\t{\n\t\tcell_id = 8.;\n\t\ta_y =  a-PI_2;\n\t\ta_x =  0.;\n\t\ta_z =  0.;\n\t}\n\t//Fnznx\n\telse if( nx && !n1A && n1B && !n0B && n0A)\n\t{\n\t\tcell_id = 9.;\n\t\ta_y =  a+PI_2;\n\t\ta_x =  0.;\n\t\ta_z =  0.;\n\t}\n\t// ---------------------------------------------------------------\n\t//Fpznx\n\telse if(nx && n3A && !n3B && n2B && !n2A)\n\t{\n\t\tcell_id = 10.;\n\t\ta_y = -a+PI_2;\n\t\ta_x =  0.;\n\t\ta_z =  b+PI_2;\n\t}\n\t//Fnzpx\n\telse if(!nx && !n3A && n3B && !n2B && n2A )\n\t{\n\t\tcell_id = 11.;\n\t\ta_y = -a+PI_2;\n\t\ta_x =  PI;\n\t\ta_z =  b-PI_2;\n\t}\n\t// ---------------------------------------------------------------\n\t// cell orientation\n\tvec2 ei_y = vec2(cos(a_y),sin(a_y)); p.zx = cmul(p.zx,ei_y); // rotate around y-axis\n\tvec2 ei_x = vec2(cos(a_x),sin(a_x)); p.yz = cmul(p.yz,ei_x); // rotate around x-axis\n\tvec2 ei_z = vec2(cos(a_z),sin(a_z)); p.xy = cmul(p.xy,ei_z); // rotate around z-axis\n\t// non cyclic\n\tsr = 5.;\n    return p;\n}\n\n// stereographic projection \nfloat sig(float x) {\n    return x < 0. ? -1. : +1.; \n    }\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(sign(x)*x, abs(e)) );\n    //return sign(x)*abs( pow(abs(x), abs(e)) );\n    }\n   \nvec2 r_poly_dist(vec2 z, vec2 e, float sh_a) {   \n    /// r-polygon-distribution\n    float r = length(z); z = (r<0.)? vec2(0) : z/r; \n    float d0 = 0.5 *abs(e.y-e.x);\n    float e2 = e.x + d0 + d0 * (2.*smoothstep(-1., 1., -sh_a) - 1.);\n    return dist(r, e2) * z;\n}   \n\nvec3 sp(vec3 zsr){\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // stereopraphic projection (complex plane to unit sphere)\n    float zz = dot(z,z); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(2. * z.x,  2. * z.y, -1. + zz);\n        }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(2. * z.x, -2. * z.y,  1. - zz);\n        }\n    pn /= 1.+zz;\n    return pn;\n}\n\nvec3 spb(vec3 zsr) {\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // inverse stereograpic projection\n    float k = 2./(1.+dot(z,z)); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(k*z, k-1.); }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(k*z, -(k-1.)); }\n    return pn;\n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n    // https://iquilezles.org/\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// colorspace transformations\nvec3 rgb2hsv(vec3 col) {\n    // https://en.wikipedia.org/wiki/HSL_and_HSV\n    col = clamp(col, 0., 1.); \n    //\n    float m_max = max(col.r,max(col.g,col.b));\n    float m_min = min(col.r,min(col.g,col.b));\n    float d = m_max-m_min;\n    // hue\n    float h = 0.; // if(d == 0.) undefined\n    if(m_max==col.r) {h = (col.g-col.b)/d+0.;}\n    if(m_max==col.g) {h = (col.b-col.r)/d+2.;}\n    if(m_max==col.b) {h = (col.r-col.g)/d+4.;}\n    h = fract(h/6.); // periodic in[0.,1.]\n    // value\n    float v = m_max;\n    // saturation\n    float s = (v == 0.)?0.: d/v;\n    return vec3(h,s,v);\n}\n\nvec3 h2rgb(float h){\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); /* cubic smoothing */\n}\n\nvec3 hsv2rgb(float h, float s, float v){     \n    return v * mix( vec3(1.0), h2rgb(h), s); /* hue, saturation, value */\n}\n\n// srgb <--> rgb (linear)\nvec3 srgb2rgb(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}