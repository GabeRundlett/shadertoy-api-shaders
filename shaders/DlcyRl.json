{
    "Shader": {
        "info": {
            "date": "1699563460",
            "description": "Trying out the Shader Sorcerer https://chat.openai.com/g/g-6K1Oa7NEx-shader-sorcerer to create a \"Rainy Day\" shader, as it's raining outside today. \n\nThe full chat can be found here: https://chat.openai.com/share/9aa6063b-dd8c-44bf-aae5-4c60e42d0648",
            "flags": 0,
            "hasliked": 0,
            "id": "DlcyRl",
            "likes": 3,
            "name": "Rainy Day by Shader Sorcerer",
            "published": 3,
            "tags": [
                "noise",
                "rain",
                "openai",
                "gpt",
                "aigenerated",
                "gpt4",
                "agpl",
                "shadersorcerer"
            ],
            "usePreview": 0,
            "username": "TimPietrusky",
            "viewed": 140
        },
        "renderpass": [
            {
                "code": "/**\n * Rainy Day, generated with Shader Sorcerer by Tim Pietrusky\n * \n * License: AGPL-v3\n * \n * \"Shader Sorcerer\" is an AI Assistant based on OpenAI GPT-Builder using GPT-4-turbo,\n * which you can use via https://chat.openai.com/g/g-6K1Oa7NEx-shader-sorcerer\n * \n * I created the AI Assistant to help out with GLSL. \n * This is the first shader created by the AI Assistant, you can find the whole chat\n * via https://chat.openai.com/share/9aa6063b-dd8c-44bf-aae5-4c60e42d0648\n * The chat shows my whole process of interacting with the Shader Sorcerer to get the final \n * result. I only changed minor things in the code myself, almost everything was\n * generated by AI. \n *\n * It's important to create the shader step by step, adding only one feature at a time.\n * Otherwise the AI Assistant will be confused and produce bad results. \n *\n * What I also saw is, that some things are still wrong related to the knowledge of GPT,\n * so I have to add more information (like the correct implementation of cnoise)\n * into the assistant, so that it can just use the function when needed \n * and not come up with functions itself. \n */\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\n// Classic Perlin Noise\nfloat cnoise(vec2 P){\n\tvec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n\tvec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n\tPi = mod(Pi, 289.0);\n\tvec4 ix = Pi.xzxz;\n\tvec4 iy = Pi.yyww;\n\tvec4 fx = Pf.xzxz;\n\tvec4 fy = Pf.yyww;\n\n\tvec4 i = permute(permute(ix) + iy);\n\n\tvec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0;\n\tvec4 gy = abs(gx) - 0.5;\n\tvec4 tx = floor(gx + 0.5);\n\tgx = gx - tx;\n\n\tvec2 g00 = vec2(gx.x,gy.x);\n\tvec2 g10 = vec2(gx.y,gy.y);\n\tvec2 g01 = vec2(gx.z,gy.z);\n\tvec2 g11 = vec2(gx.w,gy.w);\n\n\tvec4 norm = 1.79284291400159 - 0.85373472095314 *\n\tvec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n\tg00 *= norm.x;\n\tg01 *= norm.y;\n\tg10 *= norm.z;\n\tg11 *= norm.w;\n\n\tfloat n00 = dot(g00, vec2(fx.x, fy.x));\n\tfloat n10 = dot(g10, vec2(fx.y, fy.y));\n\tfloat n01 = dot(g01, vec2(fx.z, fy.z));\n\tfloat n11 = dot(g11, vec2(fx.w, fy.w));\n\n\tvec2 fade_xy = fade(Pf.xy);\n\tvec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n\tfloat n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n\treturn 2.3 * n_xy;\n}\n\n\n// Function to calculate the Signed Distance Field for a circle\nfloat circleSDF(vec2 pos, vec2 center, float radius) {\n    return length(pos - center) - radius;\n}\n\n// Pseudo-random number generator\nfloat rand(vec2 co, float seed){\n    return fract(sin(dot(co.xy ,vec2(12.9898 + seed, 78.233 + seed))) * 43758.5453);\n}\n\n// Function to create a lightning effect\nfloat lightning(vec2 uv, float time) {\n    // Use a random factor based on the time to trigger lightning\n    float trigger = step(0.95, rand(vec2(floor(time * 10.0), 0.0), 0.0));\n    // Flash intensity based on a quick sin function to simulate lightning's abrupt onset and fade\n    float intensity = sin(time * 100.0) * trigger;\n    // Clamp the intensity between 0.0 and 1.0\n    return clamp(intensity, 0.0, 1.0);\n}\n\n// Function to calculate the Signed Distance Field for an elongated circle (ellipse)\nfloat elongatedCircleSDF(vec2 pos, vec2 center, vec2 radii) {\n    return length((pos - center) / radii) - 1.0;\n}\n\n// Function to draw rolling hills\nvec3 drawRollingHills(vec2 uv) {\n    float hill1 = sin(uv.x * 3.0 + iTime * 0.2) * 0.25 + 0.25;\n    float hill2 = sin(uv.x * 4.0 + iTime * 0.15 + 1.0) * 0.2 + 0.3;\n    float hill3 = sin(uv.x * 2.0 + iTime * 0.1 - 2.0) * 0.3 + 0.35;\n\n    float hillMask1 = smoothstep(hill1 - 0.02, hill1, -uv.y);\n    float hillMask2 = smoothstep(hill2 - 0.02, hill2, -uv.y);\n    float hillMask3 = smoothstep(hill3 - 0.02, hill3, -uv.y);\n\n    vec3 color = vec3(0.0);\n    vec3 hillColor1 = vec3(0.2, 0.8, 0.2);\n    vec3 hillColor2 = vec3(0.1, 0.7, 0.1);\n    vec3 hillColor3 = vec3(0.0, 0.6, 0.0);\n\n    color = mix(color, hillColor1, hillMask1);\n    color = mix(color, hillColor2, hillMask2);\n    color = mix(color, hillColor3, hillMask3);\n\n    return color;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalizing the UV coordinates so that (0,0) is the center of the screen\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    // Wind effect\n    float windStrength = sin(iTime * 0.5) * 0.5; // Oscillating wind strength over time\n    float windAngle = windStrength * 2.2; // Wind angle, you can adjust the multiplier for more or less slant\n    vec2 windDirection = vec2(windStrength, 0.0); // Wind direction (horizontal)\n\n    // Cloud definition\n    vec2 mainCircleCenter = vec2(0.0, 0.2);\n    float mainCircleRadius = 0.2;\n    vec2 leftCircleCenter = mainCircleCenter + vec2(-0.2, -0.05);\n    float leftCircleRadius = 0.15;\n    vec2 rightCircleCenter = mainCircleCenter + vec2(0.2, -0.065);\n    float rightCircleRadius = 0.12;\n    \n    // Calculate the noise value\n    float noiseScale = 0.5;\n    float noiseStrength = 0.2; // Control the amount of noise distortion\n    float noise = cnoise((uv + windDirection) * noiseScale) * noiseStrength;\n   \n    // Calculate the SDF for each cloud part and add noise\n    float mainDist = circleSDF(uv + windDirection, mainCircleCenter, mainCircleRadius);\n    float leftDist = circleSDF(uv + windDirection, leftCircleCenter, leftCircleRadius);\n    float rightDist = circleSDF(uv + windDirection, rightCircleCenter, rightCircleRadius);\n    float cloud = min(min(mainDist, leftDist), rightDist) + noise;\n    float cloudAlpha = 1.0 - smoothstep(0.0, 0.01, cloud);\n    \n    // Raindrops definition\n    float raindropRadius = 0.003;\n    float raindropSpeed = 0.5;\n    vec3 raindropColor = vec3(0.0, 0.0, 1.0);\n    float raindropAlpha = 0.0;\n    vec2 raindropCenter;\n    float raindropDist;\n    float closestRaindropDist = 1.0;\n    \n    float seed = iTime < 0.1 ? iTime : 0.1;\n\n    // Create multiple raindrops with random speeds and streaks\n    for (int i = 0; i < 60; ++i) {\n        vec2 n = vec2(float(i), seed);\n        float randomX = rand(n, seed) * 0.6 - 0.3 - windDirection.x; // Random X within the width of the cloud\n        float randomY = rand(n + vec2(1.0), seed) * mainCircleRadius; // Random Y within the cloud\n        float randomSpeed = raindropSpeed + rand(n + vec2(3.0), seed) * 0.1; // Random speed variation\n        float timeOffset = rand(n + vec2(2.0), seed); // Random time offset for each raindrop\n\n        // Use mod to loop the falling effect, reset to just below the cloud\n        float raindropOffset = mod(iTime * randomSpeed + timeOffset, 1.0);\n\n        // The y-coordinate is adjusted to start from within the main cloud circle\n        vec2 streakCenter = vec2(randomX, mainCircleCenter.y - randomY - raindropOffset);\n        \n        // Apply the wind effect by skewing the falling direction\n        float windOffset = raindropOffset * windAngle;\n        vec2 windEffect = vec2(windOffset, -raindropOffset);\n        \n        // Apply wind effect to the streak center\n        streakCenter += windEffect;\n        \n        // Make the raindrop elongated to create a streak\n        float streakLength = 0.02; // The length of the rain streak\n        vec2 raindropRadii = vec2(raindropRadius, raindropRadius + streakLength * randomSpeed);\n        \n        // Calculate the distance for the elongated circle SDF\n        raindropDist = elongatedCircleSDF(uv, streakCenter, raindropRadii);\n\n        // Raindrop gradient color from top (light blue) to bottom (darker blue)\n        vec3 topColor = vec3(0.5, 0.5, 1.0); // Light blue\n        vec3 bottomColor = vec3(0.0, 0.0, 0.5); // Darker blue\n        \n        // Calculate the relative position along the streak\n        float streakPosition = (uv.y - (streakCenter.y - raindropRadii.y)) / (2.0 * raindropRadii.y);\n        streakPosition = clamp(streakPosition, 0.0, 1.0); // Clamp the position to be between 0 and 1\n\n        // Interpolate the color along the streak\n        vec3 streakColor = mix(bottomColor, topColor, streakPosition);\n        \n        // Randomly decide if this raindrop will have a highlight color\n        float highlightChance = rand(n + vec2(4.0), seed);\n        bool isHighlight = highlightChance > 0.55; // 5% chance of being a highlight\n\n        // Define highlight colors\n        vec3 highlightColor1 = vec3(0.25, 0.25, 1.0);\n        vec3 highlightColor2 = vec3(0.75, 0.5, 1.0);\n        vec3 highlightColor3 = vec3(0.5, 0.75, 1.0);\n\n        // Choose the highlight color based on another random factor\n        int highlightColorIndex = int(mod(rand(n + vec2(5.0), seed) * 3.0, 3.0));\n        vec3 chosenHighlightColor = (highlightColorIndex == 0) ? highlightColor1 :\n                                    (highlightColorIndex == 1) ? highlightColor2 : highlightColor3;\n\n        // Use the highlight color if this raindrop is chosen to be highlighted\n        if (isHighlight) {\n            streakColor = mix(bottomColor, chosenHighlightColor, streakPosition);\n        }\n\n        // Raindrop is not visible when inside the cloud\n        if (streakCenter.y < mainCircleCenter.y - mainCircleRadius) {\n            // Determine the alpha for the closest raindrop (smallest distance)\n            if (raindropDist < closestRaindropDist) {\n                closestRaindropDist = raindropDist;\n                raindropAlpha = 1.0 - smoothstep(0.0, 0.005, raindropDist);\n                raindropColor = streakColor; // Use the gradient color for the raindrop\n            }\n        }\n    }\n\n    // Background color (darker grey)\n    vec3 backgroundColor = vec3(0.2);\n\n    // Determine final color\n    vec3 color = backgroundColor + (drawRollingHills(uv) * .5);\n\n\n    // If we are inside the cloud, render it as white\n    if (cloud < 0.0) {\n        color = vec3(1.0);\n    } else {\n        // If we are not inside the cloud, mix the background with the raindrop\n        // This assumes the cloud is the topmost layer\n        color = mix(color, raindropColor, raindropAlpha);\n        color = mix(color, vec3(1.0), cloudAlpha); // Mix cloud with the rest\n    }\n    \n    // Calculate the lightning effect\n    float lightIntensity = lightning(uv, iTime);\n    \n    // Apply the lightning effect by increasing the brightness\n    color += lightIntensity * vec3(1.0, 1.0, 1.0);\n    \n    // Fog effect\n    float fogIntensity = smoothstep(0.0, 0.2, uv.y - .01);\n    vec3 fogColor = vec3(0.8); // Light gray color for the fog\n    color = mix(color, fogColor, fogIntensity * (1.0 + cloudAlpha)); // Blend the fog based on cloud alpha\n\n    \n    // Setting the final color\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}