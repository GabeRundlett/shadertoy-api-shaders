{
    "Shader": {
        "info": {
            "date": "1644791334",
            "description": "Result after messing around on sunday night",
            "flags": 0,
            "hasliked": 0,
            "id": "7sXfDH",
            "likes": 20,
            "name": "CC0: Follow the light",
            "published": 3,
            "tags": [
                "fractal",
                "raymarch"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 405
        },
        "renderpass": [
            {
                "code": "// License CC0: Follow the light\n// Result after messing around on sunday night\n// Based on an old favorite: https://www.shadertoy.com/view/XsBXWt\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TOLERANCE       0.00001\n#define MAX_RAY_LENGTH  17.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.0001\n\n#define TWISTS\n\n#if defined(TWISTS)\n#define PATHA (0.75*vec2(0.1147, 0.2093))\n#define PATHB (0.5*vec2(13.0, 3.0))\nvec3 cam(float z)  {\n    return vec3(sin(z*PATHA)*PATHB, z);\n}\n\nvec3 dcam(float z)  {\n    return vec3(PATHA*PATHB*cos(PATHA*z), 1.0);\n}\n\nvec3 ddcam(float z)  {\n    return vec3(-PATHA*PATHA*PATHB*sin(PATHA*z), 0.0);\n}\n#else\nvec3 cam(float z)  {\n    return vec3(0.0, 0.0, z);\n}\n\nvec3 dcam(float z)  {\n    return vec3(0.0, 0.0, 1.0);\n}\n\nvec3 ddcam(float z)  {\n    return vec3(0.0);\n}\n#endif\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\n// \"Amazing Surface\" fractal\n// https://www.shadertoy.com/view/XsBXWt\nvec4 formula(vec4 p) {\n  p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n  p.y-=.25;\n  p.xy*=ROT(radians(30.0));\n  p=p*2.0/clamp(dot(p.xyz,p.xyz),0.24,1.0);\n  return p;\n}\n\nvec3  g_trap0 = vec3(0.0);\n\nfloat rail(vec3 pos) {\n  vec3 tpos =pos;\n  tpos.z    = abs(3.-mod(tpos.z, 6.));\n  vec4 p    = vec4(tpos,1.);\n  \n  vec3 trap0pos = vec3(-2., 0.2, -3.0);\n  vec3 trap0 = vec3(1E6);\n  \n  for (int i=0; i < 4; ++i) {\n    p = formula(p);\n    trap0 = min(trap0, abs(p.xyz-trap0pos));\n  }\n  g_trap0 = trap0;\n  \n  float fr=(length(max(vec3(0.),p.xyz-1.5))-1.0)/p.w;\n\n  return fr;\n}\n\nfloat df(vec3 p) {\n  // Space distortion found somewhere on shadertoy, don't remember where\n  vec3 wrap = cam(p.z);\n  vec3 wrapDeriv = normalize(dcam(p.z));\n  p.xy -= wrap.xy;\n  p -= wrapDeriv*dot(vec3(p.xy, 0), wrapDeriv)*0.5*vec3(1,1,-1);\n\n#if defined(TWISTS)\n  vec3 ddcam = ddcam(p.z);\n  p.xy *= ROT(-16.0*ddcam.x);\n#endif  \n\n  p.x -= 1.0;\n  p.y = -pabs(p.y, 1.5);\n  p.y -= -1.5;\n\n  float dr = rail(p); \n  return dr;  \n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  const vec3 bgcol  = vec3(2.0, 1.0, 0.75).zyx;\n  vec3 lightPos     = cam(ro.z+10.0);\n  \n  int iter    = 0;\n  float t     = rayMarch(ro, rd, iter);\n  vec3  trap0 = g_trap0;\n\n  float pulse = smoothstep(0.0, 1.0, sin(TAU*TIME*0.25));\n  float sr    = mix(2.0, 3.0, pulse);\n  float sd    = sphered(ro, rd, vec4(lightPos, sr), t);\n\n  vec3 gcol   = mix(1.0, 1.75, pulse)*sd*sd*bgcol;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return gcol;\n  }\n\n  vec3 pos  = ro + t*rd;\n  vec3 nor  = normal(pos);\n  vec3 refl = reflect(rd, nor);\n  float ii  = float(iter)/float(MAX_RAY_MARCHES);\n  vec3 ld   = normalize(lightPos - pos);\n  float fre = abs(dot(rd, nor));\n  fre *= fre;\n  fre *= fre;\n  float spe = fre*pow(max(dot(refl, ld), 0.), 10.);\n  float fo  = smoothstep(0.9, 0.4, t/MAX_RAY_LENGTH);\n  float ao  = 1.0-ii;\n\n  vec3 col = vec3(0.0);\n  col += pow(smoothstep(0.5, 1.0, trap0.x*0.25)*1.3, mix(6.0, 2.0, pulse))*0.5*bgcol*mix(0.5, 1.6, pulse);\n  col += smoothstep(0.7, 0.6, trap0.z)*smoothstep(0.4, 0.5, trap0.z)*ao*bgcol*mix(0.05, 0.4, pulse);\n  col += spe*bgcol*mix(0.66, 1.5, pulse);\n  col *= 1.0-sd*sd;\n  col *= fo;\n  col += gcol;\n  return col;\n}\n\nvec3 effect3d(vec2 p, vec2 q) {\n  float z   = TIME*2.5;\n  \n  vec3 cam  = cam(z);\n  vec3 dcam = dcam(z);\n  vec3 ddcam= ddcam(z);\n  \n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*4.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = 2.0/tanh(TAU/6.0);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );\n\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect3d(p, q);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}