{
    "Shader": {
        "info": {
            "date": "1579446990",
            "description": "raymarching volume light",
            "flags": 0,
            "hasliked": 0,
            "id": "Wty3z3",
            "likes": 6,
            "name": "RadioActivity_VolumeLight",
            "published": 3,
            "tags": [
                "raymarchvolumelight"
            ],
            "usePreview": 0,
            "username": "Honorfil",
            "viewed": 323
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 800\n#define MAX_DIST 100.\n#define LIGHT_VOLUME_STEP 0.05\n#define SURF_DIST 0.01\n#define PI 3.1415\n#define LIGHT_DENSITY 0.3\n#define LIGHT_POS vec3(0., 15., 1.3)\n#define LIGHT_DIR vec3(0., -1., 0.)\n\nfloat GetLightDist(vec3 p)\n{\n    vec3 base = LIGHT_POS;\n    base.y = 0.;\n    \n\treturn GetCone(p, base, LIGHT_POS, 2.9, 0.0);\n}\n\nfloat RayMarchLight(vec3 ro, vec3 rd)\n{\n    float d0 = 0.;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * d0;\n        float ds = abs(GetLightDist(p));\n        d0 += ds;\n\n        if (d0 > MAX_DIST || ds < SURF_DIST)\n        {\n            break;\n        }\n    }\n    \n    return step(d0, MAX_DIST / 2.) * d0;\n}\n\nfloat GetRadioEdge(vec3 p)\n{   \n    vec3 n = -vec3(0,0,1);\n    float leftPlane = dot(p, n * GetRot3dY(2. * PI / 6.));\n    float rightPlane = dot(p, n * GetRot3dY(-2. * PI / 6.));\n    \n    p -= vec3(0,0.0,1);\n    \n    float result = GetBox(p, vec3(1, .1, 1));\n    result = max(result, leftPlane);\n\tresult = max(result, rightPlane);\n                          \n    return result;\n}\n\nfloat GetRadioShape(vec3 p)\n{\n    float base = GetBox(p, vec3(10,1,20), vec3(0, -1, 0), vec3(0, 0, 0));\n    \n    float s1 = GetRadioEdge(p);\n    float s2 = GetRadioEdge(p * GetRot3dY(2. * PI / 3.));\n    float s3 = GetRadioEdge(p * GetRot3dY(-2. * PI / 3.));\n    \n    float outer = GetCylinder(p, vec3(0,-1,0), vec3(0,1,0), 2.);\n    float inner = GetCylinder(p, vec3(0,-1,0), vec3(0,1,0), .4);\n    float center = GetCylinder(p, vec3(0,-.05,0), vec3(0,.05,0), .2);\n    \n    float result = s1;\n    result = min(result, s2);\n    result = min(result, s3);\n    result = max(result, outer);\n    result = max(result, -inner);\n    result = min(result, center);\n    \n    return result;\n}\n\nfloat GetSpheres(vec3 p)\n{\n    vec3 s1Pos = vec3(0, 2.6, 1.3) + vec3(cos(-iTime * 0.3), 0, sin(-iTime * 0.3)) * 1.3;\n    vec3 s2Pos = vec3(0, 1.7, 1.3) + vec3(cos(iTime * 0.26), 0, sin(iTime * 0.26)) * 1.7;\n    \n    float s1 = GetSphere(p, s1Pos, .3);\n    float s2 = GetSphere(p, s2Pos, .3);\n    \n    return min(s1, s2);\n}\n\nfloat GetRoom(vec3 p)\n{\n    vec3 pFloor = p - vec3(0,0,0);\n    vec3 pCeil = p - vec3(0,4,0);\n        \n    float fl = GetBox(pFloor, vec3(5, .1, 5));\n    float ce = GetBox(pCeil, vec3(5, .1, 5));\n    float hole = GetCylinder(p - vec3(0,4,1.3), vec3(0,-1.,0), vec3(0,1.,0), 2.1);\n    \n    float result = ce;\n    result = max(result, -hole);\n    result = min(result, fl);\n    \n    return result;\n}\n\nfloat GetDistScene(vec3 p)\n{\n    vec3 pShape = p - vec3(0,4.05,1.27);\n    pShape *= GetRot3dY(iTime);\n    \n    float shape = GetRadioShape(pShape);   \n    float room = GetRoom(p);\n    \n    return min(room, shape);\n}\n\nfloat RayMarchScene(vec3 ro, vec3 rd)\n{\n    float d0 = 0.;\n        for (int i = 0; i < MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * d0;\n            float ds = abs(GetDistScene(p));\n            d0 += ds;\n            \n            if (abs(d0) > MAX_DIST || ds < SURF_DIST)\n            {\n                break;\n            }\n        }\n    \n    return min(d0, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p)\n{   \n    float d = GetDistScene(p);\n    vec2 e = vec2(0.01, .0);\n    \n    vec3 n = d - vec3(\n    \tGetDistScene(p - e.xyy),\n    \tGetDistScene(p - e.yxy),\n    \tGetDistScene(p - e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p, out vec3 n)\n{  \n    vec3 lightPos = LIGHT_POS;\n    vec3 lray = normalize(lightPos - p);\n    n = GetNormal(p);\n    float distToLight = length(lightPos - p);\n\n    float co = radians(10.0);\n    float coDel = radians(14.0);\n    float fall = clamp((dot(lray, -LIGHT_DIR) - cos(coDel)) / (cos(co) - cos(coDel)), 0.0, 1.0);\n    float diff = max(0.0, dot(lray, n));\n    \n    float shadow = 1.;\n    \n    float realDistToLight = RayMarchScene(p + n * .02, lray);\n    if (realDistToLight < distToLight)\n    {\n        shadow = 0.7;\n    }\n    \n    return diff * fall * shadow;\n}\n\nfloat GetLightDistance(vec3 ro, vec3 rd, out vec3 pIn, out vec3 pOut)\n{\n    vec3 roBack = ro + rd * 20.;\n\n    float dc = RayMarchLight(ro, rd);\n    float df = RayMarchLight(roBack, -rd);\n    \n    if (dc < 0.01 && df < 0.01)\n    {\n        return 0.;\n    }\n    \n    pIn = ro + rd * dc;\n    pOut = roBack - rd * df;\n    \n    return length(pIn - pOut);\n}\n\nfloat GetLightDensity(vec3 ro, vec3 rd, vec3 hitPoint)\n{\n    vec3 pIn;\n    vec3 pOut;\n    \n    float traverseDist = GetLightDistance(ro, rd, pIn, pOut);\n    if (traverseDist < 0.01 || length(ro - pIn) > length(ro - hitPoint))\n    {\n        return 0.;\n    }\n    \n    float distToHitPoint = length(pIn - hitPoint);\n    traverseDist = min(traverseDist, distToHitPoint);\n\n    vec3 singleStep = rd * LIGHT_VOLUME_STEP;\n    vec3 lSetVec = vec3(0);\n    float lightDensity = 0.;\n    \n    while (length(lSetVec) < traverseDist)\n    {\n        vec3 vlP = pIn + lSetVec;\n        vec3 lightDir = normalize(LIGHT_POS - vlP);\n        \n        float distToLight = length(vlP - LIGHT_POS);\n        float realDistLoLight = RayMarchScene(vlP, lightDir);\n        realDistLoLight = max(realDistLoLight, distToLight);\n\n        float distMult = smoothstep(1., 0.8, distToLight / LIGHT_POS.y);\n        lightDensity += LIGHT_VOLUME_STEP * LIGHT_DENSITY * distMult * (1. - step(realDistLoLight, distToLight));\n        \n        lSetVec += singleStep;\n    }\n    \n    return lightDensity * 0.4;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0, 1.5, -4.9);   \n    vec3 rd = normalize (vec3(uv.x, uv.y, 1));    \n    rd *= GetRot3dX(-.1);\n\n    float d = RayMarchScene(ro, rd);\n    \n    vec3 n;\n    vec3 p = ro + rd * d;\n    float dif = GetLight(p, n);\n    vec3 diffColor = vec3(1, 1, 0) * dif * 0.4;\n    \n    float lightDensity = GetLightDensity(ro, rd, p);\n    vec3 lightVolumeColor = lightDensity * vec3(1, 1, 0);\n\n    fragColor = vec4(diffColor + lightVolumeColor, 1.0);\n}\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//math help\n\nmat2 GetRot2d(float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    \n    return mat2(c, -s, s, c);\n}\n\nmat3 GetRot3dX(float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    \n    return mat3(vec3(1, 0, 0), vec3(0, c, -s), vec3(0, s, c));\n}\n\nmat3 GetRot3dY(float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    \n    return mat3(vec3(c, 0, s), vec3(0, 1, 0), vec3(-s, 0, c));\n}\n\nmat3 GetRot3dZ(float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    \n    return mat3(vec3(c, -s, 0), vec3(s, c, 0), vec3(0, 0, 1));\n}\n\n//Primitives\n\nfloat GetSphere(vec3 p, vec3 spherePos, float r)\n{\n    return length(p - spherePos) - r;\n}\n\nfloat GetCylinder(vec3 p, vec3 top, vec3 bottom, float radius)\n{\n    vec3 ab = bottom - top;\n    vec3 ap = p - top;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = top + t * ab;\n\n    float x = length(p - c) - radius;\n    float y = (abs(t - .5) - .5) * length(ab);\n    float exterior = length(max(vec2(x, y), 0.));\n    float interior = min(max(x, y), 0.);\n    \n    return exterior + interior;\n}\n\nfloat GetBox(vec3 p, vec3 s)\n{\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat GetBox(vec3 p, vec3 size, vec3 pos, vec3 rot)\n{   \n    p -= pos;    \n    p *= GetRot3dZ(rot.z) * GetRot3dY(rot.y) * GetRot3dX(rot.x);\n    \n    return GetBox(p, size);\n}\n\nfloat GetCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}