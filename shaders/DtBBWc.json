{
    "Shader": {
        "info": {
            "date": "1694540833",
            "description": "Fork of \"Point to line tangent to circle\" by jeyko. https://shadertoy.com/view/DtSBD3.\n\nLeft Top side: Original\nLeft Bot: ENDESGA\nRight: Mike Plot'z\n\nThis approach was suggested by Mike Plotz.\nIt uses a two sqrt()s and zero trig fn()'s.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "DtBBWc",
            "likes": 6,
            "name": "tangent to circle - Plotz",
            "published": 3,
            "tags": [
                "line",
                "intersection",
                "circle",
                "sampling"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 239
        },
        "renderpass": [
            {
                "code": "// Fork of \"Point to line tangent to circle\" by jeyko. https://shadertoy.com/view/DtSBD3\n// 2023-09-12 17:26:58\n\n/*\n    solve right triangle, formed by point (ro), circle center (C) and unknown point.\n    beta is the angle on ro.\n    \n    ro\n    rd\n    R\n    C\n\n\n    l = sqrt(dot(ro-C,ro-C))\n\n    l2 = R2 + u2\n\n    u = sqrt(l2 - r2)\n\n    sin(beta) = R/l\n    beta = asin(R/l)\n*/\n\n// From iq\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = (U - 0.5*iResolution.xy)/iResolution.y;\n    vec2 muv;\n    \n    float t = iTime * 0.3;\n    \n    if (length(iMouse.xy) < 30.0) {\n        muv.x = cos(t * 1.23 + 3.0);\n        muv.y = sin(t * 1.34 + 0.2);\n        muv *= 0.4;\n    }\n    else {\n        muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    }\n\n    vec3 col = vec3(0);\n    \n    vec2 ro = muv*1.;\n    if(iFrame == 0){\n        ro = vec2(0.4);\n    }\n    \n    float R = 0.25;\n    vec2 c = vec2(cos(t), sin(t)) * 0.2;\n    \n    float sd = 1000.0;\n    \n    sd = min(sd, length(ro - uv) - 0.02);\n    sd = min(sd, abs(length(uv - c) - R) - 0.001);\n    \n    vec2 tanPosA;\n    vec2 tanPosB;\n\n    bool hasTans;\n    \n    if (uv.x < 0.0) {\n        if (uv.y > 0.0) {\n            hasTans = CircleTangents(\n                c,\n                R,\n                ro,\n                tanPosA,\n                tanPosB);\n        }\n        else {\n            hasTans = CircleTangents_edg(\n                c,\n                R,\n                ro,\n                tanPosA,\n                tanPosB);\n        }\n    }\n    else {\n        hasTans = CircleTangents_Plotz(\n            c,\n            R,\n            ro,\n            tanPosA,\n            tanPosB);\n    }\n    \n        \n    if (hasTans) {\n        sd = min(sd, length(tanPosA - uv) - 0.01);\n        sd = min(sd,sdSegment( uv, ro, tanPosA ) - 0.004);\n        sd = min(sd, length(tanPosB - uv) - 0.01);\n        sd = min(sd,sdSegment( uv, ro, tanPosB ) - 0.004);\n    }\n\n    \n    col += smoothstep(fwidth(uv.y),0.,sd);\n    \n    col = 1.-col;\n    if (abs(U.x - iResolution.x / 2.0) <= 0.6) {\n        col = vec3(0.4);\n    }\n    if (U.x < iResolution.x / 2.0) {\n        if (abs(U.y - iResolution.y / 2.0) <= 0.7) {\n            col = vec3(0.4);\n        }\n    }\n    col = pow(col,vec3(0.454545));\n    C = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Original C# source code here:\n// https://github.com/elenzil/tangents/blob/master/tangents/Assets/Scripts/TangentCtlr.cs#L78C39-L102\n// thanks to Mike Plotz for suggesting this direction.\nbool CircleTangents_Plotz(in vec2 center, in float r, in vec2 p, out vec2 tanPosA, out vec2 tanPosB) {\n    p -= center;\n\n    float P = length(p);\n\n    // if p is inside the circle, there ain't no tangents.\n    if (P <= r) {\n      return false;\n    }\n\n    float a = r * r                       / P;    \n    float q = r * sqrt((P * P) - (r * r)) / P;\n\n    vec2 pN  = p / P;\n    vec2 pNP = vec2(-pN.y, pN.x);\n    vec2 va  = pN * a;\n\n    tanPosA = va + pNP * q;\n    tanPosB = va - pNP * q;\n\n    tanPosA += center;\n    tanPosB += center;\n\n    return true;\n}\n\n\n\nbool CircleTangents_edg(in vec2 c, in float R, in vec2 p, out vec2 tanPosA, out vec2 tanPosB)\n{\n  p -= c;\n  float t = dot(p,p)/(R*R);\n  if(t<1.) return false;\n  p = p/t;\n  vec2 n = vec2(-p.y,p.x) * sqrt(t-1.);\n  tanPosA = p+c+n;\n  tanPosB = p+c-n;\n  return true;\n}\n\n\n\n#define pi acos(-1.)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\nbool CircleTangents(in vec2 c, in float R, in vec2 p, out vec2 tanPosA, out vec2 tanPosB)\n{\n    float l = length(c - p);\n    float u = sqrt(l*l - R*R);\n    \n    float beta = asin(R/l);\n    float alpha = pi - pi/2.0 - beta;\n    \n    vec2 rd = normalize(c - p);\n    \n    rd *= rot(beta);\n    tanPosA = p + rd * u;\n    \n    rd *= rot(-beta*2.0);\n    tanPosB = p + rd * u;\n    \n    return true;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}