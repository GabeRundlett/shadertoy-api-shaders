{
    "Shader": {
        "info": {
            "date": "1659062618",
            "description": "spherical Fibonacci points",
            "flags": 48,
            "hasliked": 0,
            "id": "fl3yzn",
            "likes": 20,
            "name": "Fibonacci points on a sphere",
            "published": 3,
            "tags": [
                "sphere",
                "goldenratio",
                "fibonaccispiral",
                "orbitcamera"
            ],
            "usePreview": 0,
            "username": "dmemes",
            "viewed": 385
        },
        "renderpass": [
            {
                "code": "float stable_atan2(float y, float x) {\n\treturn x == 0.0 ? (y == 0.0 ? 0.0 : (y < 0.0 ? -PI/2.0 : PI/2.0)) : atan(y, x);\n}\nvec2 cartesian_to_spherical_uv(vec3 v) {\n\tfloat theta = stable_atan2(v[2], v[0]);\n\treturn vec2(theta/PI*.5 + .5, acos(clamp(v[1], -1.0, 1.0))/PI);\n}\nvec3 spherical_uv_to_cartesian(vec2 uv) {\n\tuv[0] = uv[0]*2.0 - 1.0;\n\tuv *= PI;\n\tfloat sinPhi = sin(uv[1]);\n\treturn vec3(sinPhi*cos(uv[0]), cos(uv[1]), sinPhi*sin(uv[0]));\n}\n\nfloat intersect_sphere(vec3 ro, vec3 rd, vec4 sph) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif (h < 0.0) return -1.0;\n\treturn -b - sqrt(h);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec3 dir = vec3(0,0,2.5);\n    dir.xy = (fragCoord + 0.5) / iResolution.xy * 2.0 - vec2(1);\n    dir.x *= iResolution.x / iResolution.y;\n    dir = normalize(dir);\n    \n    mat3 rot = euler_yx(load_camera(iChannel0).euler);\n    vec3 org = rot*vec3(0,0,-3);\n    dir = rot * dir;\n    \n    vec4 sph = vec4(0,0,0,1);\n    \n    float t = intersect_sphere(org, dir, sph);\n    if (t < 0.0) {\n        fragColor = vec4(0);\n    } else {\n        vec3 normal = normalize(org + dir*t - sph.xyz);\n        \n        vec2 q = floor(cartesian_to_spherical_uv(normal) * 32.0);\n        fragColor.rgb = vec3(mix(0.25, 0.5, mod(q.x + q.y, 2.0 )));\n        \n        float n = 16.0 + iTime*16.0;\n        float a = 0.0;\n        for (float i = 0.0; i < n; i++) {\n            vec3 f = fib_to_dir(i + 0.5, n);\n            f.y = -f.y;\n            \n            float c = cos(0.5*PI/sqrt(n));\n            float r = (max(0.0, dot(f, normal) - c)) / (1.0 - c);\n            a += r;\n        }\n        \n        fragColor.rgb = mix(fragColor.rgb, vec3(1,0.75,0.25), clamp(a*10.0, 0.0, 1.0));\n        \n        \n        // light\n        fragColor.rgb *= 0.1 + 0.9*max(0.0, dot(normal, normalize(vec3(0.75,1,-0.75))));\n    }\n    \n    \n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// spherical fibonacci from https://www.shadertoy.com/view/stVfWc\n\nconst float PI  = 3.1415926535897932384626433832795;\nconst float PHI = 1.6180339887498948482045868343656;\n\nfloat madfrac( float a,float b) { return a*b -floor(a*b); }\nvec2  madfrac( vec2  a,float b) { return a*b -floor(a*b); }\n\nfloat dir_to_fib(vec3 p, float n) {\n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI*PHI)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    \n    vec2 F = vec2( round(Fk), round(Fk * PHI) );\n\n    vec2 ka = -2.0*F/n;\n    vec2 kb = 2.0*PI*madfrac(F+1.0, PHI-1.0) - 2.0*PI*(PHI-1.0);    \n    mat2 iB = mat2( ka.y, -ka.x, -kb.y, kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n\n    vec2 c = floor( iB * vec2(phi, cosTheta - (1.0-1.0/n)));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float cosTheta = dot(ka, uv + c) + (1.0-1.0/n);\n        \n        cosTheta = clamp(cosTheta, -1.0, 1.0)*2.0 - cosTheta;\n        float i = floor(n*0.5 - cosTheta*n*0.5);\n        float phi = 2.0*PI*madfrac(i, PHI-1.0);\n        cosTheta = 1.0 - (2.0*i + 1.0)/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta);\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return j;\n}\nvec3  fib_to_dir(float i, float n) {\n    float phi = 2.0*PI*madfrac(i,PHI);\n    float cosTheta = 1.0 - 2.0*(i + 0.5)/n;\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta);\n}\n\n\n\n// Camera\n\nstruct Camera {\n    vec2 euler;\n    vec4 prev_mouse;\n};\nCamera load_camera(sampler2D channel) {\n    Camera camera;\n    vec4 p0 = texelFetch(channel, ivec2(0), 0);\n    camera.euler      = texelFetch(channel, ivec2(0,0), 0).xy;\n    camera.prev_mouse = texelFetch(channel, ivec2(1,0), 0);\n    return camera;\n}\n\nmat3 euler_yx(vec2 euler) {\n    vec2 sin_euler = sin(euler);\n    vec2 cos_euler = cos(euler);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, \n                     0.0,  cos_euler.x, sin_euler.x, \n                     0.0, -sin_euler.x, cos_euler.x);\n    mat3 rotY = mat3(cos_euler.y, 0.0, -sin_euler.y, \n                     0.0, 1.0, 0.0, \n                     sin_euler.y, 0.0,  cos_euler.y);    \n    return rotY * rotX;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Orbit camera\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 ipos = ivec2(fragCoord);\n    if (ipos.y == 0 && ipos.x < 2) {\n        Camera camera;\n        if (iFrame == 0) {\n            camera.euler = vec2(PI/4.0, 0);\n            camera.prev_mouse = iMouse;\n        } else\n            camera = load_camera(iChannel0);\n\n        if (iMouse.z > 0.0 && camera.prev_mouse.z > 0.0) {\n            vec2 d = ((iMouse.xy - camera.prev_mouse.xy) / iResolution.xy) * 1.5;\n            d.y = -d.y;\n            camera.euler += d.yx;\n        }\n        camera.prev_mouse = iMouse;\n        \n        if      (ipos.x == 0) fragColor = vec4(camera.euler, 0.0, 0.0);\n        else if (ipos.x == 1) fragColor = camera.prev_mouse;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}