{
    "Shader": {
        "info": {
            "date": "1587549024",
            "description": "a very simple scene, should run on most computers",
            "flags": 32,
            "hasliked": 0,
            "id": "WdjcDd",
            "likes": 26,
            "name": "Voxel path tracing",
            "published": 3,
            "tags": [
                "gi",
                "voxel",
                "dof",
                "pathtracing",
                "ao"
            ],
            "usePreview": 0,
            "username": "loicvdb",
            "viewed": 1223
        },
        "renderpass": [
            {
                "code": "vec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nmat3 gaussianFilter = mat3(41, 26, 7,\n                           26, 16, 4,\n                           7,  4,  1) / 273.;\n\nvec3 bloom(float scale, float threshold, vec2 fragCoord){\n    float logScale = log2(scale);\n    vec3 bloom = vec3(0);\n    for(int y = -2; y <= 2; y++)\n        for(int x = -2; x <= 2; x++)\n            bloom += gaussianFilter[abs(x)][abs(y)] * textureLod(iChannel0, (fragCoord+vec2(x, y)*scale)/iResolution.xy, logScale).rgb;\n    \n    return max(bloom - vec3(threshold), vec3(0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    Camera cam = getCam(iTime);\n    \n    vec4 col = vec4(0.);\n    \n    float frd = iResolution.y*cam.aperture*DoFClamping;\n    int rd = int(ceil(frd - .5));\n    for(int y = -rd; y <= rd; y++){\n        int ln = int(ceil(sqrt(frd*frd-float(y*y)) - .5));\n        for(int x = -ln; x <= ln; x++){\n            vec2 coords = clamp(fragCoord + vec2(x, y), vec2(0), iResolution.xy-1.);\n            vec4 p = texelFetch(iChannel0, ivec2(coords), 0);\n            float dof = min(abs(p.a-cam.focalDistance)/p.a, DoFClamping) * iResolution.y*cam.aperture;\n            col += vec4(p.rgb, 1.) * clamp((dof - length(vec2(x, y))) + .5, 0.0, 1.0) / (dof*dof+.1);\n    \t}\n    }\n    \n    col /= col.a;\n    \n    vec3 bloomSum = vec3(0.);\n    bloomSum += bloom(.05 * iResolution.y, .2, fragCoord) * .1;\n    \n    fragColor = vec4(ACESFilm(col.rgb + bloomSum), 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define IndirectSamples 4\n#define SamplesLimit 256\n#define Bounces 2\n\n#define Pi 3.14159265359\n#define Epsilon .00002\n\n#define MaxStepsDirect 8\n#define MaxStepsIndirect 5\n#define MaxStepsShadow 4\n\n#define SceneRadius 2.0\n\n#define PixelAcceptance 2.\n#define PixelCheckDistance .75\n\n#define DoFClamping .2\n\n\nvec3 LightDir = normalize(vec3(.2, -1.9, -1.));\nvec3 LightColor = vec3(.7, .5, .4) * 7.0;\n\nstruct Camera {\n    vec3 pos, rot;\n    float focalLength, focalDistance, aperture;\n};\n\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nCamera getCam(float time){\n    vec3 rot = vec3(.8, time*.3, 0.);\n    vec3 pos = vec3(.0, .0, -10.) * rotationMatrix(rot);\n    return Camera(pos, rot, 1.3, 8., .03);\n}\n\nvec3 uv2dir(Camera cam, vec2 uv){\n    return normalize(vec3(uv, cam.focalLength)) * rotationMatrix(cam.rot);\n}\n\nvec2 pos2uv(Camera cam, vec3 pos){\n    vec3 dir = normalize(pos - cam.pos) * inverse(rotationMatrix(cam.rot));\n    return dir.xy * cam.focalLength / dir.z;\n}\n\nvec3 dirFromUv(Camera cam, vec2 uv){\n    return normalize(vec3(uv, cam.focalLength)) * rotationMatrix(cam.rot);\n}\n\n\nbool isAir(in ivec3 voxel, out vec3 dc, out vec3 ec) {\n    if(voxel == ivec3(1, 0, -2)) {\n        dc = vec3(0.);\n        ec = vec3(1., 5., 15.);\n        return false;\n    }\n    if(voxel.x == -1 && voxel.y > -1) {\n        dc = vec3(1., .5, .2);\n        ec = vec3(0.);\n        return false;\n    }\n    if(voxel.y <= -1 || voxel.xz == ivec2(1, 1)) {\n        dc = vec3(1.);\n        ec = vec3(0.);\n        return false;\n    }\n    if(voxel.z == -1) {\n        dc = vec3(.2, 1., .2);\n        ec = vec3(0.);\n        return false;\n    }\n    return true;\n}\n\nivec3 closestVoxel(vec3 pos){\n    return ivec3(floor(pos));\n}\n\nivec3 nextVoxel(inout vec3 pos, vec3 dir){\n    \n    dir += (vec3(1.0)-abs(sign(dir)))*Epsilon; //prevent zeros\n    vec3 s = sign(dir);\n    vec3 l = (floor(pos + s*(.5+Epsilon) + .5) - pos) / dir;\n    float closest = min(min(l.x, l.y), l.z);\n    pos += dir*(closest+Epsilon);\n    return closestVoxel(pos);\n}\n\nbool isInScene(in vec3 pos, vec3 dir){\n    vec3 apos = abs(pos);\n    return max(max(apos.x, apos.y), apos.z) <= SceneRadius;\n}\n\nbool intersectScene(inout vec3 pos, in vec3 dir){\n    \n    dir += (vec3(1.0)-abs(sign(dir)))*Epsilon; //prevent zeros\n    \n    vec3 i1 = (-sign(dir)*(SceneRadius+2.*Epsilon)-pos) / dir;\n    float t = max(max(i1.x, i1.y), i1.z);\n    pos += dir*max(0., t);\n    return isInScene(pos+sign(dir)*4.*Epsilon, dir);\n}\n\nbool trace(inout vec3 ro, in vec3 rd, int maxSteps){\n    if(!intersectScene(ro, rd)) return false;\n    vec3 dc, ec;\n    for(int i = 0; i < maxSteps; i++){\n        if(!isAir(nextVoxel(ro, rd), dc, ec)){\n            ro -= rd*Epsilon*2.0;\n            return true;\n        }\n        if(!isInScene(ro, rd)) break;\n    }\n    return false;\n}\n\nvoid surfaceInfo(in vec3 pos, out vec3 normal, out vec3 dc, out vec3 ec){\n    vec3 d = fract(pos)-.5;\n    vec3 ad = abs(d);\n    float m = max(max(ad.x, ad.y), ad.z);\n    normal = (abs(sign(ad-m))-1.)*sign(d);\n    isAir(closestVoxel(pos-normal), dc, ec);\n}\n\nvec3 directLight(vec3 pos, vec3 normal){\n    vec3 dir = -LightDir;\n    float dotLight = dot(normal, dir);\n    if(dotLight < 0.0) return vec3(0);\n    return trace(pos, dir, MaxStepsShadow) ? vec3(0.) : LightColor * dotLight;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    Camera cam = getCam(iTime);\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    vec3 dir = uv2dir(cam, uv);\n    vec3 pos = cam.pos;\n    \n    fragColor = vec4(0.);\n    if(trace(pos, dir, MaxStepsDirect)) fragColor = vec4(pos, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float seed;\n\nfloat randomFloat(){\n    return fract(sin(seed++)*43758.54536156);\n}\n\nvec3 ortho(vec3 v) {\n  return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getCosineWeightedSample(vec3 dir) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = vec2(randomFloat(), randomFloat());\n\tr.x = r.x * 2.0 * Pi;\n\tr.y = pow(r.y, .5);\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\n\nvec3 background(vec3 dir){\n    vec3 col = texture(iChannel3, dir).rgb;\n    return col*col+col;\n}\n\nvec3 sampleIndirectLight(vec3 pos, vec3 normal){\n    vec3 dir;\n    vec3 abso = vec3(1.), light = vec3(0.), dc, ec;\n    for(int i = 0; i < Bounces; i++){\n        dir = getCosineWeightedSample(normal);\n        if(!trace(pos, dir, MaxStepsIndirect)) return light + abso*background(dir);\n        surfaceInfo(pos, normal, dc, ec);\n        light += abso * (ec + dc*directLight(pos, normal));\n        abso *= dc;\n    }\n    return light;\n}\n\nfloat distancePixel(vec2 prevFragCoord, vec4 hit){\n    if(  min(iResolution.xy, prevFragCoord) != prevFragCoord\n      && max(vec2(0.)      , prevFragCoord) != prevFragCoord) return SceneRadius;\n    vec4 prevPos = texture(iChannel2, prevFragCoord/iResolution.xy);\n    Camera cam = getCam(iTime);\n    return length(prevPos-hit);\n}\n\nvec4 previousSample(vec4 hit){\n    vec2 prevUv = pos2uv(getCam(iTime-iTimeDelta), hit.xyz);\n    vec2 prevFragCoord = prevUv * iResolution.y + iResolution.xy/2.0;\n    \n    vec2 pfc, finalpfc;\n    float dist, finaldist = SceneRadius;\n    for(int x = -1; x <= 1; x++){\n        for(int y = -1; y <= 1; y++){\n            pfc = prevFragCoord + PixelCheckDistance*vec2(x, y);\n            dist = distancePixel(pfc, hit);\n            if(dist < finaldist){\n                finalpfc = pfc;\n                finaldist = dist;\n            }\n    \t}\n    }\n    \n    Camera cam = getCam(iTime);\n    if(finaldist < PixelAcceptance*length(hit.xyz-cam.pos)/cam.focalLength/iResolution.y)\n        return texture(iChannel0, finalpfc/iResolution.xy);\n    return vec4(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    seed = cos(fragCoord.x+.25)+cos(fragCoord.y+.5)+cos(iTime+.75);\n    \n    Camera cam = getCam(iTime);\n    \n    vec4 hit = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    if(hit.a == 0.){\n        vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n        fragColor = vec4(background(uv2dir(cam, uv)), 1.);\n    } else {\n        \n        #if 0\n        fragColor = previousSample(hit);\n        fragColor.rgb = fragColor.a == 0. ? vec3(1., 0., 0.) : vec3(0., 1., 0.);\n        fragColor.a = 1.;\n        #else\n        vec3 normal, phdc, phec;\n        surfaceInfo(hit.xyz, normal, phdc, phec);\n        \n        vec3 iLight = vec3(0.);\n        for(int i = 0; i < IndirectSamples; i++)\n            iLight += sampleIndirectLight(hit.xyz, normal)/float(IndirectSamples);\n        \n        \n        fragColor = previousSample(hit);\n        fragColor.a += fragColor.a > float(SamplesLimit) ? 0. : float(IndirectSamples);\n        fragColor.rgb = mix(fragColor.rgb, iLight, 1.0/(fragColor.a/float(IndirectSamples)));\n        #endif\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float distancePixel(vec2 prevFragCoord, vec4 hit){\n    if(  min(iResolution.xy, prevFragCoord) != prevFragCoord\n      && max(vec2(0.)      , prevFragCoord) != prevFragCoord) return SceneRadius;\n    vec4 prevPos = texture(iChannel3, prevFragCoord/iResolution.xy);\n    Camera cam = getCam(iTime);\n    return length(prevPos-hit);\n}\n\nvec4 previousSample(vec4 hit){\n    vec2 prevUv = pos2uv(getCam(iTime-iTimeDelta), hit.xyz);\n    vec2 prevFragCoord = prevUv * iResolution.y + iResolution.xy/2.0;\n    \n    vec2 pfc, finalpfc;\n    float dist, finaldist = SceneRadius;\n    for(int x = -1; x <= 1; x++){\n        for(int y = -1; y <= 1; y++){\n            pfc = prevFragCoord + PixelCheckDistance*vec2(x, y);\n            dist = distancePixel(pfc, hit);\n            if(dist < finaldist){\n                finalpfc = pfc;\n                finaldist = dist;\n            }\n    \t}\n    }\n    \n    Camera cam = getCam(iTime);\n    if(finaldist < PixelAcceptance*length(hit.xyz-cam.pos)/cam.focalLength/iResolution.y)\n        return texture(iChannel2, finalpfc/iResolution.xy);\n    return vec4(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    Camera cam = getCam(iTime);\n    \n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 hit = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec3 finalPos = hit.rgb;\n    col.a = length(cam.pos-finalPos);\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    vec3 dir = uv2dir(cam, uv);\n    \n    if(hit.a != 0.) {\n        vec3 normal, dc, ec;\n        surfaceInfo(finalPos, normal, dc, ec);\n        col.rgb = ec + dc * (col.rgb + directLight(finalPos, normal));\n    }\n    \n    // TXAA\n    vec4 oldCol = previousSample(hit);\n    float factor = oldCol.a == 0. ? 0. : .9;\n    col = oldCol * factor + (1. - factor) * col;\n\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}