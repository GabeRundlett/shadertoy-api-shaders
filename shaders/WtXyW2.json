{
    "Shader": {
        "info": {
            "date": "1593036231",
            "description": "This shader simulates groups of pixels brawling and duplicating themselves, using a buffer. Best enjoyed in full screen.\n\nRobRob",
            "flags": 32,
            "hasliked": 0,
            "id": "WtXyW2",
            "likes": 7,
            "name": "Pixel Brawl",
            "published": 3,
            "tags": [
                "2d",
                "pixel",
                "rgb",
                "buffer",
                "swarm",
                "robrob",
                "brawl"
            ],
            "usePreview": 0,
            "username": "RobRob",
            "viewed": 425
        },
        "renderpass": [
            {
                "code": "// This work is licensed under the\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n// International License.\n\n// Created by RobRob for display on shadertoy.com.\n\n// This part of the code uses the r-component of every buffered pixel\n// to determine which colour to render.\n\nconst float PI = 3.14159265359;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Normalized pixel coordinates (from 0 to 1).\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Get the pixel value from buffer A set in the previous tab.\n    vec3 texel = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    // If the r-component is not set, the pixel is unpopulated and therefore black.\n    if (texel.r == 0.)  {\n        fragColor = vec4(0., 0., 0., 1.0);\n        return;\n    }\n    \n    // Map the r-component to full colours using a sine function.\n    vec3 col = sin(vec3(0, 2, 4) + texel.r) * .5 + .5;\n    \n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This work is licensed under the\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n// International License.\n\n// Created by RobRob for display on shadertoy.com.\n\n// The number of different colour groups.\nconst float groups = 30.;\n\n// The number of points each group starts with.\nconst float points = 4.;\n\n// Every pixel's minimum starting health.\nconst float baseHealth = 500.;\n\n// Every pixel's maximum health bonus.\nconst float healthBonus = 25.;\n\n// Arbitrarily defined cutoff for creation of new pixels.\nconst float cutOff = 37.5;\n\n// Every pixel's minimum attack.\nconst float baseAttack = 25.;\n\n// Every pixel's maximum attack bonus.\nconst float attackBonus = 25.;\n\n\nconst vec2[] neighbours = vec2[] (vec2(-1, 0), vec2(-1, 1), vec2(0, 1), vec2(1, 1),\n                                  vec2(1, 0), vec2(1, -1), vec2(0, -1), vec2(-1, -1));\nconst float numNeighbours = 8.;\n\nconst vec3 BLACK = vec3(0.);\nconst float PI = 3.14159265359;\n\n\n// Hash functions taken from https://www.shadertoy.com/view/ttc3zr\n// ===============================================================\n\nuint murmurHash13(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 3 inputs\nfloat hash13(vec3 src) {\n    uint h = murmurHash13(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuint murmurHash14(uvec4 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z; h *= M; h ^= src.w;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 4 inputs\nfloat hash14(vec4 src) {\n    uint h = murmurHash14(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuvec2 murmurHash23(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 2 outputs, 3 inputs\nvec2 hash23(vec3 src) {\n    uvec2 h = murmurHash23(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n// ===============================================================\n\n\n// Create a new pixel of the format vec4(colorIndex, health, attack, 1).\nvec4 createNewPixel(float attackerColour, float attackerHealth, vec3 seed) {    \n    vec2 randomVec2 = hash23(seed);\n    \n    // Create random health and attack values for the new pixel.\n    float health = baseHealth + randomVec2.x * healthBonus;\n    \n    // Note that the new pixel gets an additional 95% of its attacker's health surplus.\n    // Surplus meaning how much it was above the cutoff.\n    // Default cutoff was set by trial and error.\n    float reducedAttackerHealth = max(attackerHealth - cutOff, 0.);\n    float attack = baseAttack + randomVec2.y * attackBonus + reducedAttackerHealth * .95;\n    \n    return vec4(attackerColour, health, attack, 1.);\n}\n\n// This function executes once at frame 0 to populate the screen.\nvec4 populate(vec2 fragCoord, vec2 uv) {\n    // Uncomment this line to populate the screen with a rainbow spectrum.\n    //return createNewPixel(uv.x * 2. * PI, 0., vec3(iTime, uv));\n    \n    // Populate the screen with small, coloured dots.\n    \n    // Let all r-components fall in (0, 2 * PI] so that the sine in the next\n    // tab will not repeat colours.\n    float interval = 2. * PI / groups;\n    \n    for(float i = 0.; i < groups; i++) {\n        for(float j = 0.; j < points; j++) {\n            vec2 rand = hash23(vec3(iTime, i, j));\n            \n            if (distance(uv, rand) < 0.02) {\n                return createNewPixel((i + 1.) * interval, 0., vec3(iTime, uv));\n            }\n        }\n    }\n    \n    return vec4(BLACK, 1.0);\n}\n\n\n// This part of the code is responsible for filling the buffer.\n// Only the r-component is used for determining the final RGBA\n// colour. This happens in the image tab. The rest of the buffer\n// data is used to store pixels' 'attack' and 'health' values.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Normalised pixel coordinates (from 0 to 1).\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Populate the screen on the first frame.\n    if (iFrame == 0) {\n        fragColor = populate(fragCoord, uv);\n        return;\n    }\n    \n    // Choose a random index from the neighbours array.\n    int randomIndex = int(floor(hash13(vec3(uv, iTime)) * numNeighbours));\n    \n    // Fetch this pixel's colour and a random neighbour's.\n    vec4 colour = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 neighbourColour = texelFetch(iChannel0, ivec2(fragCoord + neighbours[randomIndex]), 0);\n    \n    // Only change this pixel if its neighbour has a different colour.\n    if (colour.r != neighbourColour.r) {\n        \n        if (colour.rgb == BLACK) {\n            // If this pixel is black, generate a new one with its neighbour's colour.\n            // Do not add additional attackerHealth so that newly coloured pixels can easily be conquered.\n        \tcolour = createNewPixel(neighbourColour.r, 0., vec3(iTime, uv));\n            \n        } else if (neighbourColour.rgb != BLACK) {\n            // If both pixels have (a different) colour, simulate an attack.\n            \n            // Subtract this pixel's 'health' by its neighbour's 'attack'.\n            colour.y = colour.y - neighbourColour.z;\n            \n            // If this pixel's health is below 0, replace it.\n            if (colour.y <= 0.) {                               \n                colour = createNewPixel(neighbourColour.r, neighbourColour.z, vec3(iTime, uv));\n            }\n        }\n    }\n   \n    fragColor = colour;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}