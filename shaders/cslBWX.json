{
    "Shader": {
        "info": {
            "date": "1689525990",
            "description": "Inspired by this video by Nils Berglund:\n\nhttps://www.youtube.com/watch?v=pN-gi_omIVE\n\nIn honor of Richard Courant, a pioneer of CFD. The wave speed is modulated by simplex noise.\n\n* mouse: emit wave\n* space: reset\n* shift: disable shadows",
            "flags": 48,
            "hasliked": 0,
            "id": "cslBWX",
            "likes": 24,
            "name": "Courant Noise",
            "published": 3,
            "tags": [
                "2d",
                "reflection",
                "wave",
                "simulation"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 340
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Inspired by this video by Nils Berglund:\n//\n//      https://www.youtube.com/watch?v=pN-gi_omIVE\n//\n//  One of the interesting things I learned from Mr. Berglund's video is that you can\n//  get some interesting effects with the wave equation by allowing the speed of wave\n//  propagation to vary spatially. My result looks very different from his, but I think\n//  it looks pretty interesting anyway.\n//\n//  I also learned that the constant that determine's the wave speed is called the\n//  Courant number:\n//\n//      https://www.idealsimulations.com/resources/courant-number-cfd/\n//\n//  I also learned that Richard Courant publushed a very early paper on computational\n//  fluid dynamics in 1928, \"Ãœber die partiellen Differenzengleichungen der mathematischen\n//  Physik\", along with some other guys named Friederich, and Lewy (CFL), so I'm naming\n//  this shader in his honor. Hopefully the name doesn't get confused for a type of\n//  noise, because I'm just using 3D simplex noise from iq:\n//\n//      https://www.shadertoy.com/view/XsX3zB\n//\n//  Click and drag the mouse to emit more waves! Space to reset.\n//\n//  The simualtion itself is substantially the same as my previous shader this is\n//  branched from. The absorbing walls are still the same, but their deficiencies\n//  are not as obvious with all the motion. Mainly I just modulated the Courant\n//  number and then added some lighting and color. Lighting-wise, the only really\n//  interesting thing is the depth-based shadows (disable with shift).\n//  \n//  There are a couple of alternate color schemes available: change COLOR_SCHEME\n//  below. I can't decide...which one is best?\n//\n// ---------------------------------------------------------------------------------------\n\n#define COLOR_SCHEME 0 // choose 0, 1, or 2\n\nvec2 gradient(vec2 fragCoord)\n{\n    if (fragCoord.y == iResolution.y - .5) return vec2(0);\n    \n    vec2 delta = vec2(1, 0);\n    float xGrad = texture(iChannel0, (fragCoord + delta.xy) / iResolution.xy).a - \n        texture(iChannel0, (fragCoord - delta.xy) / iResolution.xy).a;\n        \n    float yGrad = texture(iChannel0, (fragCoord + delta.yx) / iResolution.xy).a - \n        texture(iChannel0, (fragCoord - delta.yx) / iResolution.xy).a;\n\n    return vec2(xGrad, yGrad);\n}\n\nvec4 getColorFromHeight(float d)\n{\n#if COLOR_SCHEME == 0\n    vec4 c = sin(d * 800. * vec4(9, 2, 5, 0));\n    return c * .7 + vec4(.02,.02,.3,0);\n#elif COLOR_SCHEME == 1\n    int i = int(pow(abs(d), .49) * 80.);\n    if (i <= 0) return vec4(.02,.02,.3,0);\n    switch(i)\n    {\n        case 1: return vec4(1.0, 0.0, 0.0, 2.0);\n        case 2: return vec4(1.0, 0.5, 0.0, 3.0);\n        case 3: return vec4(1.0, 1.0, 0.0, 4.0);\n        case 4: return vec4(0.0, 1.0, 0.0, 5.0);\n        case 5: return vec4(0.0, 0.0, 1.0, 6.0);\n        case 6: return vec4(0.25, 0.0, 0.5, 7.0);\n        default: case 7: return vec4(0.5, 0.0, 0.7, 8.0);\n    }    \n#else\n    vec4 c = pow(abs(d), .5) * vec4(1, .4, .2, 0) * 70. + .2;\n    return c;\n#endif\n}\n\nfloat computeShadow(vec2 u, float pd)\n{\n    if (keyDown(KEY_SHIFT)) return 1.;\n    \n    vec2 del = vec2(-1, 1);\n    float sh = 1.;\n    for (float i = 0.; i < 20.; ++i)\n    {\n        u += del;\n        float nd = texelFetch(iChannel0, ivec2(u), 0).x;\n        sh *= smoothstep(nd + float(i) * 5e-7, nd + float(i) * 1e-6, pd);\n    }\n    \n    return sh;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 g = -gradient(u);\n    \n    const vec3 ld = normalize(vec3(-1, 1, 1)); // light dir\n    const vec3 vd = vec3(0, 0, 1); // view dir\n    \n    float wh = texelFetch(iChannel0, ivec2(u), 0).x; // wave height\n    float sh = computeShadow(u, wh); // shadow\n    vec3 n = normalize(vec3(g, .0001)); // normal\n    O = vec4(dot(n, ld)) * (sh * .5 + .5); // diffuse\n\n    O *= getColorFromHeight(wh); // colorize\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, true); // true for last parameter => update state, emit waves\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define U(u) texelFetch(prevBuffer, ivec2(u), 0) //\nconst float FOCUS_DIST = .45;\n\n// From iq's 3d simplex noise: https://www.shadertoy.com/view/XsX3zB\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c)\n{\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\n#define keyClick(ascii)   ( texelFetch(keyBuffer,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_SPACE 32\n\nconst float BOUND_GAMMA = .01; // damping factor for boundary\n\nvec2 initWave(vec2 u, vec2 c, vec2 R)\n{\n    vec2 delta = u - c;\n    float d2 = dot(delta, delta);\n\n    float df = sqrt(d2);\n    return 3. * R.x * vec2(sin(df), cos(df)) / (1. + d2 * 1e6);\n}\n\nvoid updateBuffer(out vec4 O, vec2 u, vec2 R, int iFrame, vec4 iMouse, sampler2D prevBuffer, sampler2D keyBuffer, bool bufferA)\n{\n    vec2 o = vec2(1, 0),\n         p = (u - .5 * R) / R.y;\n\n    vec4 state = texelFetch(prevBuffer, ivec2(0), 0);\n    \n    // handle persistent state\n    if (ivec2(u) == ivec2(0))\n    {\n        if (iFrame == 0 ||\n            state.w != R.x * R.y ||\n            keyClick(KEY_SPACE))\n        {\n            O = vec4(0);\n            O.w = R.x * R.y;\n            return;\n        }\n        \n        O = state;\n        \n        if (bufferA && ++O.z > 10.)\n            O.z = 0.;\n        \n        return;\n    }\n    \n    if (iFrame == 0 ||\n        state.w != R.x * R.y ||\n        keyClick(KEY_SPACE))\n    {\n        // init\n        O = vec4(0);\n        return;\n    }\n    else\n    {\n        float C = simplex3d_fractal(vec3(p * 10., float(iFrame) * .01)); // Courant\n        C = .5 * pow(C * .5 + .5, 4.);\n\n        O = U(u).xxyy; // copies the current value from x to y coordinate to record new previous, put current previous into z for us to use\n\n        if (int(u.y) < 5)\n            O.x = O.x - C * (O.x - U(u + o.yx).x) - BOUND_GAMMA*(O.x-O.z); // absorbing bottom boundary\n        else if (int(u.y) == int(R.y) - 1)\n            O.x = O.x - C * (O.x - U(u - o.yx).x) - BOUND_GAMMA*(O.x-O.z); // absorbing top boundary\n        else if (int(u.x) == 0)\n            O.x = O.x - C * (O - U(u + o)).x - BOUND_GAMMA*(O.x-O.z); // absorbing left boundary\n        else if (int(u.x) == int(R.x) - 1)\n            O.x = O.x - C * (O - U(u - o)).x - BOUND_GAMMA*(O.x-O.z); // absorbing right boundary\n        else\n            O.x = -O.z + 2.*O.x + C*(U(u + o) + U(u - o) + U(u + o.yx) + U(u - o.yx) - 4. * O).x; // apply wave equation\n    }\n\n    if (bufferA)\n    {\n        vec2 h = vec2(.5);\n        \n        // add disturbance at the center\n        if (state.z < 1. || iFrame == 0)\n            O.xy += initWave(u, h * R.xy, R);\n\n        // add disturbance for mouse click\n        if (iMouse.z > 0. && (state.z < 1. || iMouse.w > 0.))\n            O.xy += initWave(u, iMouse.xy, R);\n    }\n    \n    O *= .9995;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}