{
    "Shader": {
        "info": {
            "date": "1665427183",
            "description": "Compared to standard raymarching, all intersection tests lie on the same discrete concentric circles!\nEvery red dot represents an evaluation of the sdf.",
            "flags": 32,
            "hasliked": 0,
            "id": "ftyfWd",
            "likes": 15,
            "name": "Raymarching wavefront (Bintree)",
            "published": 3,
            "tags": [
                "raymarching",
                "visualization"
            ],
            "usePreview": 0,
            "username": "pyBlob",
            "viewed": 485
        },
        "renderpass": [
            {
                "code": "int lvl, seg;\nvoid init() { lvl = 0; seg = 0; }\nvoid up()   { --lvl; seg = seg>>1; }\nvoid near() { ++lvl; seg = seg<<1; }\nbool isfar() { return (seg & 1) == 1; }\nbool next() { while (isfar()) up(); ++seg; return lvl == 0; }\n\nfloat _r, _s; vec2 _p;\nbool close(vec2 ro, vec2 rd)\n{\n    rd *= exp2(-float(lvl));\n    _r = scene(_p = ro + rd * (float(seg) + .5));\n    float _s = length(rd) / 2.;\n    return _r < _s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setup(fragCoord, iResolution, iMouse);\n\n    float T = mod(.3*iTime/(2.*(2.+pi)), 2.);\n    float show_unrolled = demo ? smoothstep(1., 1.05, T) - smoothstep(1.95, 2., T) : 0.;\n    //show_unrolled = 1.; // Shows Buffer A\n\n    color = vec3(0);\n    blend(vec3(1), abs(scene(uv)) - .5 * f);\n\n    vec2 ro, rd;\n    ro = mouse.xy; rd = uv - ro;\n    if (demo)\n    {\n        float a = .3 * iTime;\n        float T=2.+pi, s=sign(T-mod(a, T+T)); a=mod(a, 2. + pi); ro=vec2(.5,0) + .5*(a<2. ? vec2(a-1., 0) : vec2(cos(a=s*(a-2.)), sin(a)));\n        //ro = vec2(.5, 0.) + .5 * vec2(cos(a), sin(a));\n        rd = uv - ro;\n    }\n    rd = normalize(rd) * 4.;\n\n    blend(vec3(1), abs(length(uv - ro) - 3. * f) - .5 * f);\n\n    init();\n    bool hit = false;\n    for (int i=0;i<64;++i)\n    {\n        if (close(ro, rd))\n        {\n            near();\n            if (lvl > 16) { hit = true; break; }\n        }\n        else if (next()) break;\n        blend(vec3(1,0,0), length(uv - _p));\n    }\n    if (hit) blend(vec3(0,1,0), length(uv - _p) - 1.*f);\n    else blend(vec3(lvl!=0,0,1), length(uv - _p) - 1.*f); // pink: loop limit exceeded, blue: no intersections\n    fragColor = vec4(sqrt(color), 1);\n    fragColor = mix(fragColor, texelFetch(iChannel0, ivec2(fragCoord), 0), show_unrolled);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float pi = radians(180.);\n\nfloat f; vec3 color;\nvoid blend(vec3 c, float r)\n{\n    color = mix(color, c, clamp(1. - r / f, 0., 1.));\n}\n\nvec2 uv;\nvec4 mouse;\nbool demo, down, click;\nvoid setup(vec2 fragCoord, vec3 iResolution, vec4 iMouse)\n{\n    f = 2. / iResolution.y;\n    uv = (fragCoord - iResolution.xy / 2.) * f;\n    mouse = (abs(iMouse) - iResolution.xyxy / 2.) * f;\n    demo = iMouse.z == 0.;\n    down = iMouse.z > 0.;\n    click = iMouse.w > 0.;\n}\n\nfloat sdBox(vec2 p,vec2 s)\n{\n    return length(max(p=abs(p)-s,0.))+min(max(p.x,p.y),0.);\n}\n\nfloat sdLine(vec2 p,vec2 a,vec2 b)\n{\n    return length(-clamp(dot(p-=a,b-=a)/dot(b,b),0.,1.)*b+p);\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    sca = normalize(sca);\n    scb = normalize(scb);\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x > scb.x*p.y) ? dot(p,scb) : length(p);\n    return sqrt(max(0., dot(p,p) + ra*ra - 2.0*ra*k)) - rb;\n}\n\nfloat side(float r, float h)\n{\n    return sqrt(r*r - h*h);\n}\n\nfloat sdArcTo(in vec2 p, in vec2 a, in vec2 b, float r)\n{\n    vec2 m = a + b;\n    float tb = dot(m, b) / length(m);\n    float arc = sdArc(p, vec2(m.y, -m.x), vec2(side(r, tb), tb), r, 0.);\n    //return min(min(length(p-a), length(p-b)), min(length(p-m), min(arc, length(p)))) -.01;\n    return arc;\n}\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat scene(vec2 p)\n{\n    // lara: Animated Marching Visualization https://www.shadertoy.com/view/ltyGRD\n    p.x += .5;\n    float ball = length(p - vec2(1, 0)) - .3;\n    float lens = length(p - vec2(.8, 0)) - .15;\n    float wire = abs(p.y) - .05;\n    vec2 q = p; q.y = abs(q.y);\n    float eye = max(max(ball,-lens),-wire);\n    float bx = (pow(.3,2.)-pow(.15,2.)+pow(.2,2.))/(2.*.2);\n    float bh = side(.3, bx);\n    float ballArc = sdArcTo(q - vec2(1, 0), vec2(-bx,bh), vec2(side(.3,.05), .05), .3);\n    float lensArc = sdArcTo(q - vec2(.8, 0), vec2(.2-bx,bh), vec2(side(.15,.05), .05), .15);\n    float wireLine = sdLine(q, vec2(.8+side(.15,.05), .05), vec2(1.+side(.3,.05), .05));\n    float eye1 = min(min(ballArc, lensArc), wireLine) * sign(eye);\n    float socket = min(\n        sdBox(vec2(p.x,abs(p.y))-vec2(1,.6),vec2(.3,.05)),\n        sdBox(vec2(p.x,abs(p.y))-vec2(1.25,.55),vec2(.05,.05))\n    );\n    //if (false)\n        return min(eye1, socket); // proper sdf\n    return min(eye, socket); // original sdf\n}\n\nvec3 palette(float h)\n{\n    // iq: Binary Search for SDFs https://www.shadertoy.com/view/wlGcWG\n    vec3 col =    vec3(0.0,0.3,1.0);\n    col = mix(col,vec3(1.0,0.8,0.0),smoothstep(0.33-0.2,0.33+0.2,h));\n    col = mix(col,vec3(1.0,0.0,0.0),smoothstep(0.66-0.2,0.66+0.2,h));\n    col.y += 0.5*(1.0-smoothstep(0.0,0.2,abs(h-0.33)));\n    col *= 0.5 + 0.5*h;\n    return col;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "int lvl, seg;\nvoid init() { lvl = 0; seg = 0; }\nvoid up()   { --lvl; seg = seg>>1; }\nvoid near() { ++lvl; seg = seg<<1; }\nbool isfar() { return (seg & 1) == 1; }\nbool next() { while (isfar()) up(); ++seg; return lvl == 0; }\n\nfloat _r, _s, _f; vec2 _p;\nbool close(vec2 ro, vec2 rd)\n{\n    _f = exp2(-float(lvl)) * (float(seg) + .5);\n    rd *= exp2(-float(lvl));\n    _r = scene(_p = ro + rd * (float(seg) + .5));\n    float _s = length(rd) / 2.;\n    return _r < _s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setup(fragCoord, iResolution, iMouse);\n\n    color = vec3(0);\n    //blend(vec3(1), abs(scene(uv)) - .5 * f);\n\n    vec2 ro = mouse.xy;\n    if (demo)\n    {\n        float a = .3 * iTime;\n        float T=2.+pi, s=sign(T-mod(a, T+T)); a=mod(a, 2. + pi); ro=vec2(.5,0) + .5*(a<2. ? vec2(a-1., 0) : vec2(cos(a=s*(a-2.)), sin(a)));\n        //ro = vec2(.5, 0.) + .5 * vec2(cos(a), sin(a));\n    }\n    blend(vec3(1), abs(length(uv - ro) - 3. * f) - .5 * f);\n    \n    color *= .5;\n    \n    f = 1. / iResolution.y;\n    float fcy = fragCoord.y * f;\n    float a = fragCoord.x / iResolution.x * 2. * pi;\n    vec2 rd = vec2(sin(a), cos(a)) * 4.;\n    float d = 1. * pi / iResolution.x; mat2 D = mat2(cos(d), sin(d), -sin(d), cos(d));\n\n    blend(vec3(1), abs(scene(ro + rd * fcy)) - .5 * f);\n    //blend(vec3(1), abs(scene(ro + D * rd * fcy)) - .5 * f);\n    //blend(vec3(1), abs(scene(ro + rd * D * fcy)) - .5 * f);\n\n    init();\n    bool hit = false;\n    for (int i=0;i<64;++i)\n    {\n        if (close(ro, rd))\n        {\n            near();\n            if (lvl > 16) { hit = true; break; }\n        }\n        else if (next()) break;\n        blend(vec3(1,0,0), abs(_f - fcy));\n    }\n    if (hit) blend(vec3(0,1,0), abs(_f - fcy));\n    else blend(vec3(lvl!=0,0,1), abs(_f - fcy)); // pink: loop limit exceeded, blue: no intersections\n    fragColor = vec4(sqrt(color), 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}