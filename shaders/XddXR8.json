{
    "Shader": {
        "info": {
            "date": "1457647967",
            "description": "An experiment mixing perspective and orthogonal projection.<br/><br/>Line #56 is responsible for the change. <br/><br/>I think i'm going to be sick.",
            "flags": 0,
            "hasliked": 0,
            "id": "XddXR8",
            "likes": 16,
            "name": "Perspective vs Orthogonal",
            "published": 3,
            "tags": [
                "3d",
                "example",
                "camera",
                "perspective",
                "ortho"
            ],
            "usePreview": 0,
            "username": "dine909",
            "viewed": 1579
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define MAX_DIST 200.\n#define MIN_DIST .00020\n#define precis 0.00001\n\n\n#define IF_EQ(a,b) step(abs(a-b),0.)\n#define REP(p,c) (mod(p,c)-0.5*c)\n#define mapMin(a,b) mix(a,b,step(b.x,a.x))\nconst  vec3 eps = vec3( 0.004, 0.0, 0.0 );\nstruct Ray{vec3 ro,rd;float tmin ,tmax;vec3 hit;vec3 nor;}T_Ray;\nRay newRay(vec3 ro,vec3 rd){return Ray(ro,rd,MIN_DIST,MAX_DIST,vec3(0.),vec3(0.));}\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n        length(max(d,0.0));\n}\nvec3 map(vec3 p)\n{\n    vec3 res=vec3(100.);\n    res=mapMin(res,vec3(p.y,1.,0.));\n    res=mapMin(res,vec3(sdBox(REP(p,vec3(05.,9.,5.)),vec3(1.,1.,1.)),5.,0.));\n    res=mapMin(res,vec3(p.z+10.,4.,0.));\n    return res;\n}\nvec3 calcNormal( in vec3 pos )\n{\n   \n    vec3 nor = vec3(map(pos+eps.xyy).x - map(pos-eps.xyy).x,map(pos+eps.yxy).x - map(pos-eps.yxy).x,map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\nvec3 castRay(inout Ray ray){\n    float t = ray.tmin;\n    vec3 res=vec3(0.);\n    ray.hit=vec3(0.);\n    for( int i=0; i<200; i++ )\n    {\n        ray.hit=ray.ro+ray.rd*t;\n        res = map( ray.hit );\n        if( res.x<precis || t>ray.tmax ) break;\n        t += res.x;\n    }\n    res.x=res.z;\n    res.z=t;\n    return res*=step(t,ray.tmax);\n}\n\nRay getCamera(vec2 p,in vec3 pos)\n{\n    //camera\n    float ort=0.5+0.5*sin(iTime*0.5);\n    Ray ray = newRay(vec3(0.),normalize(vec3(mix(p,vec2(0.,0.),ort),-1.)));\n\n    //adjustments for ortho\n    ray.ro.y+=mix(0.,10.-pos.y,ort);\n    ray.ro.xy+=(p)*20.*ort;\n\n    //eye position \n    ray.ro+=pos.xyz;\n\n    return ray;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float srat=iResolution.x/iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x*=srat;\n    \n    vec3 col=vec3(0.);\n\n    //initial view projection & sky\n    vec4 vPos=vec4(iTime,02.,20.,0.);\n\n    Ray ray=getCamera(uv-vec2(0.5*srat,0.5),vPos.xyz);\n\n    vec3 res=castRay(ray);\n\n    ray.nor = calcNormal( ray.hit );\n    vec3 bcol = ((vec3(0.1, 0.7, .90)+ray.rd.y*-0.8)) *0.5 ;\n\t\n    col += IF_EQ(5.,res.y) * (vec3(.5,.5,1.25) );\n\n    #define PlaneTex(p) max(smoothstep(0.97,1.,cos(p.x*PI)),smoothstep(0.97,1.,cos(p.y*PI))))\n\tcol += IF_EQ(1.,res.y) * (vec3(1.)* PlaneTex(ray.hit.xz) +.1;\n    col += IF_EQ(4.,res.y) * (vec3(1.)* PlaneTex(ray.hit.xy) +.1;\n\n\n    //lighting\n    #define MDiffCol \tvec3(1.,1.,1.) *1.\n    #define MSpecCol \tvec3(1.,1.,1.) *1.\n    #define LCol \t\tvec3(1.,1.,1.)\n    #define LPower \t\t30.\n    #define MAmbient\t \tvec3(1.) * 0.01\n\n    vec3 lcol=vec3(1.);\n\n    vec3 lig = (vec3(iTime-3.,07.,03.4));\n    vec3 ref = reflect( (lig), ray.nor );\n    float cosAlpha = clamp( dot( normalize(ray.rd),ref ), 0.,1. );\n    float dis=pow(distance(lig,(ray.hit)),2.);\n    lcol *= MAmbient + MDiffCol * LCol * LPower * clamp(dot( ray.nor,(lig) ),0.,1.) / dis;\n    //   lcol += MSpecCol * LCol * LPower * pow(cosAlpha,5.) / dis;\n\n    col=pow(col*lcol, vec3(1./2.2));\n\n       col = mix( col, vec3(0.8,0.9,1.0)*0.35, 1.-MAmbient*(0.9)-exp( -0.000425*pow(res.z,2.) ) );\n\n    fragColor = vec4(mix(col,bcol,IF_EQ(0.,res.y)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}