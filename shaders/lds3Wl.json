{
    "Shader": {
        "info": {
            "date": "1381981399",
            "description": "Quick mockup of a shader to generate gifs like those found in http://mathgifs.blogspot.co.uk/2013/10/rotations-through-translations.html\nAll the circles translate in a straight line, but the entire shape rotates.",
            "flags": 0,
            "hasliked": 0,
            "id": "lds3Wl",
            "likes": 24,
            "name": "Rotation through Translation",
            "published": 3,
            "tags": [
                "2d",
                "rotation",
                "translation"
            ],
            "usePreview": 0,
            "username": "Mx7f",
            "viewed": 3044
        },
        "renderpass": [
            {
                "code": "// Tweak these to get different results\nconst int   NUM_CIRCLES \t= 37;\nconst float TIME_MULTIPLIER = 3.0;\nconst float CIRCLE_RADIUS   = 0.04;\nconst float CONSTANT_N\t    = 3.0;\n\n// Uncomment to let N vary wildly instead of be CONSTANT_N \n// I recommend you use a large NUM_CIRCLES with this\n//#define LET_N_GO_NUTS\n\n// Uncomment to make the circles have color\n//#define COLORIZE \n\n// Comment out to get rid of the lines\n#define SHOW_LINES\n\n\nfloat N = CONSTANT_N;\n\n\n// Actual code below\n\n#define TWO_PI 6.28318530718\n#define TWO_THIRDS_PI 2.09439510239\n\nvec3 drawCircle(vec2 p, vec2 center, float radius, float edgeWidth, vec3 color) {\n\treturn color*(1.0-smoothstep(radius, radius+edgeWidth, length(p-center)));\n}\n\nvec3 drawLine(vec2 p, float angle, float thickness, float edgeWidth, vec3 color) {\n\treturn color*(1.0-smoothstep(thickness, thickness + edgeWidth, \n\t\t\t\t\t\t\t\t abs(sin(angle)*p.x+cos(angle)*p.y)));\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef LET_N_GO_NUTS\n\tfloat N = sin(iTime)*2.0 + 3.0; \n#endif\n    \n\t// Map coordinates into a small window around [-1, 1]\n\tvec2 uv = (fragCoord.xy*2.0 - iResolution.xy) / iResolution.y;\n\tuv *= 1.2;\n\t\n\tvec3 color = vec3(0.0);\n\tfloat angleIncrement = TWO_PI / float(NUM_CIRCLES);\n\tfor (int i = 0; i < NUM_CIRCLES; ++i) {\n\t\tfloat t = angleIncrement*(float(i));\n\t\tfloat r = sin(float(N)*t+iTime*TIME_MULTIPLIER);\n\t\tvec2 p = vec2(r*cos(t), r*sin(t));\n#ifdef COLORIZE\n\t\tvec3 circleColor = vec3(sin(t),\n\t\t\t\t\t\t\t\tsin(t+TWO_THIRDS_PI),\n\t\t\t\t\t\t\t\tsin(t+2.0*TWO_THIRDS_PI))*0.5+0.5;\n#else\n\t\tvec3 circleColor = vec3(1.0);\n\t\t\n#endif\n\t\tcolor += drawCircle(uv, p, CIRCLE_RADIUS, 0.01, circleColor);\n\t\t\n#ifdef SHOW_LINES \n\t\tcolor += drawLine(uv, t, 0.000, 0.01, vec3(1.0,0.0,0.0));\n#endif\n\t}\n\t\n\t\n\tfragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}