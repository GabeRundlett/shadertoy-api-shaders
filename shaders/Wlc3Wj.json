{
    "Shader": {
        "info": {
            "date": "1577523636",
            "description": "A sea mirrored by another sea above it for that surreal feel",
            "flags": 0,
            "hasliked": 0,
            "id": "Wlc3Wj",
            "likes": 4,
            "name": "Mirror Sea",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Simplyfire",
            "viewed": 448
        },
        "renderpass": [
            {
                "code": "//TODO\n// soft shadows https://www.shadertoy.com/view/Xds3zN\n// cheap fbm https://www.shadertoy.com/view/XslGRr\n\nprecision highp float;\n\nconst vec3 translate = vec3(0,5,0);\nconst vec3 lightDirection = vec3(0,50.,-500000);\nconst float diffuseMag = 1.;\nconst float specularMag = 1.;\nconst float distFOV = 1.;\nconst float rotate = 0.;\nconst float shininess = 88.99;\n\nconst int maxSteps = 80;\nconst float maxDist = 1000.;\nconst float surfaceDist = 0.00001;\nconst float normalOffset = 0.5;\n\n#define pi 3.14159265359\n\nstruct ray{\n    vec3 hit;\n    bool lit;\n    float hue;\n    float sat;\n    float distClosest;\n    float distSum;\n};\n\nstruct dist{\n    float d;\n    int maxRefractions;\n    bool lit;\n    float hue;\n    float sat;\n};\n\nfloat cubicPulse(float c, float w, float x){\n    x = abs(x - c);\n    if (x>w) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvec3 rgb(in vec3 hsb){\n    vec3 rgb = clamp(abs(mod(hsb.x*6.0+\n    vec3(0.0, 4.0, 2.0), 6.0)-3.0)-1.0, 0.0, 1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return hsb.z * mix(vec3(1.0), rgb, hsb.y);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) + k*h*(1.0-h); }\n\nfloat opUnion(float d1, float d2) { return min(d1, d2); }\n\nfloat opSubtraction(float d1, float d2) { return max(-d1, d2); }\n\nfloat opIntersection(float d1, float d2) { return max(d1, d2); }\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat value4D(vec4 P)\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Value4D.glsl\n\n    // establish our grid cell and unit position\n    vec4 Pi = floor(P);\n    vec4 Pf = P - Pi;\n\n    // clamp the domain\n    Pi = Pi - floor(Pi * (1.0 / 69.0)) * 69.0;\n    vec4 Pi_inc1 = step(Pi, vec4(69.0 - 1.5)) * (Pi + 1.0);\n\n    // calculate the hash\n    const vec4 OFFSET = vec4(16.841230, 18.774548, 16.873274, 13.664607);\n    const vec4 SCALE = vec4(0.102007, 0.114473, 0.139651, 0.084550);\n    Pi = (Pi * SCALE) + OFFSET;\n    Pi_inc1 = (Pi_inc1 * SCALE) + OFFSET;\n    Pi *= Pi;\n    Pi_inc1 *= Pi_inc1;\n    vec4 x0y0_x1y0_x0y1_x1y1 = vec4(Pi.x, Pi_inc1.x, Pi.x, Pi_inc1.x) * vec4(Pi.yy, Pi_inc1.yy);\n    vec4 z0w0_z1w0_z0w1_z1w1 = vec4(Pi.z, Pi_inc1.z, Pi.z, Pi_inc1.z) * vec4(Pi.ww, Pi_inc1.ww) * vec4(1.0 / 56974.746094);\n    vec4 z0w0_hash = fract(x0y0_x1y0_x0y1_x1y1 * z0w0_z1w0_z0w1_z1w1.xxxx);\n    vec4 z1w0_hash = fract(x0y0_x1y0_x0y1_x1y1 * z0w0_z1w0_z0w1_z1w1.yyyy);\n    vec4 z0w1_hash = fract(x0y0_x1y0_x0y1_x1y1 * z0w0_z1w0_z0w1_z1w1.zzzz);\n    vec4 z1w1_hash = fract(x0y0_x1y0_x0y1_x1y1 * z0w0_z1w0_z0w1_z1w1.wwww);\n\n    //\tblend the results and return\n    vec4 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = z0w0_hash + (z0w1_hash - z0w0_hash) * blend.wwww;\n    vec4 res1 = z1w0_hash + (z1w1_hash - z1w0_hash) * blend.wwww;\n    res0 = res0 + (res1 - res0) * blend.zzzz;\n    blend.zw = vec2(1.0 - blend.xy);\n    return dot(res0, blend.zxzx * blend.wwyy);\n}\n\nfloat fbm (vec4 p, float ampOffset) {\n    p += vec4(0);\n    float value = .0;\n    float amplitude = 0.8+ampOffset;\n    float frequency = 0.1;\n    for (int i = 0; i < 6; i++) {\n        float n = value4D(p*frequency);\n        value += amplitude * n;\n        frequency *= 2.8;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nfloat simplex(vec3 p){\n    //  https://github.com/BrianSharpe/Wombat/blob/master/SimplexPerlin3D.glsl\n\n    //  simplex math constants\n    const float SKEWFACTOR = 1.0/3.0;\n    const float UNSKEWFACTOR = 1.0/6.0;\n    const float SIMPLEX_CORNER_POS = 0.5;\n    const float SIMPLEX_TETRAHADRON_HEIGHT = 0.70710678118654752440084436210485;// sqrt( 0.5 )\n\n    //  establish our grid cell.\n    p *= SIMPLEX_TETRAHADRON_HEIGHT;// scale space so we can have an approx feature size of 1.0\n    vec3 Pi = floor(p + dot(p, vec3(SKEWFACTOR)));\n\n    //  Find the vectors to the corners of our simplex tetrahedron\n    vec3 x0 = p - Pi + dot(Pi, vec3(UNSKEWFACTOR));\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 Pi_1 = min(g.xyz, l.zxy);\n    vec3 Pi_2 = max(g.xyz, l.zxy);\n    vec3 x1 = x0 - Pi_1 + UNSKEWFACTOR;\n    vec3 x2 = x0 - Pi_2 + SKEWFACTOR;\n    vec3 x3 = x0 - SIMPLEX_CORNER_POS;\n\n    //  pack them into a parallel-friendly arrangement\n    vec4 v1234_x = vec4(x0.x, x1.x, x2.x, x3.x);\n    vec4 v1234_y = vec4(x0.y, x1.y, x2.y, x3.y);\n    vec4 v1234_z = vec4(x0.z, x1.z, x2.z, x3.z);\n\n    // clamp the domain of our grid cell\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * (1.0 / 69.0)) * 69.0;\n    vec3 Pi_inc1 = step(Pi, vec3(69.0 - 1.5)) * (Pi + 1.0);\n\n    //\tgenerate the random vectors\n    vec4 Pt = vec4(Pi.xy, Pi_inc1.xy) + vec2(50.0, 161.0).xyxy;\n    Pt *= Pt;\n    vec4 V1xy_V2xy = mix(Pt.xyxy, Pt.zwzw, vec4(Pi_1.xy, Pi_2.xy));\n    Pt = vec4(Pt.x, V1xy_V2xy.xz, Pt.z) * vec4(Pt.y, V1xy_V2xy.yw, Pt.w);\n    const vec3 SOMELARGEFLOATS = vec3(635.298681, 682.357502, 668.926525);\n    const vec3 ZINC = vec3(48.500388, 65.294118, 63.934599);\n    vec3 lowz_mods = vec3(1.0 / (SOMELARGEFLOATS.xyz + Pi.zzz * ZINC.xyz));\n    vec3 highz_mods = vec3(1.0 / (SOMELARGEFLOATS.xyz + Pi_inc1.zzz * ZINC.xyz));\n    Pi_1 = (Pi_1.z < 0.5) ? lowz_mods : highz_mods;\n    Pi_2 = (Pi_2.z < 0.5) ? lowz_mods : highz_mods;\n    vec4 hash_0 = fract(Pt * vec4(lowz_mods.x, Pi_1.x, Pi_2.x, highz_mods.x)) - 0.49999;\n    vec4 hash_1 = fract(Pt * vec4(lowz_mods.y, Pi_1.y, Pi_2.y, highz_mods.y)) - 0.49999;\n    vec4 hash_2 = fract(Pt * vec4(lowz_mods.z, Pi_1.z, Pi_2.z, highz_mods.z)) - 0.49999;\n\n    //\tevaluate gradients\n    vec4 grad_results = inversesqrt(hash_0 * hash_0 + hash_1 * hash_1 + hash_2 * hash_2) * (hash_0 * v1234_x + hash_1 * v1234_y + hash_2 * v1234_z);\n\n    //\tNormalization factor to scale the final result to a strict 1.0->-1.0 range\n    //\thttp://briansharpe.wordpress.com/2012/01/13/simplex-noise/#comment-36\n    const float FINAL_NORMALIZATION = 37.837227241611314102871574478976;\n\n    //  evaulate the kernel weights ( use (0.5-x*x)^3 instead of (0.6-x*x)^4 to fix discontinuities )\n    vec4 kernel_weights = v1234_x * v1234_x + v1234_y * v1234_y + v1234_z * v1234_z;\n    kernel_weights = max(0.5 - kernel_weights, 0.0);\n    kernel_weights = kernel_weights*kernel_weights*kernel_weights;\n\n    //\tsum with the kernel and return\n    return dot(kernel_weights, grad_results) * FINAL_NORMALIZATION;\n}\n\nfloat noise(vec2 P){\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Perlin2D.glsl\n\n    // establish our grid cell and unit position\n    vec2 Pi = floor(P);\n    vec4 Pf_Pfmin1 = P.xyxy - vec4(Pi, Pi + 1.0);\n\n    // calculate the hash\n    vec4 Pt = vec4(Pi.xy, Pi.xy + 1.0);\n    Pt = Pt - floor(Pt * (1.0 / 71.0)) * 71.0;\n    Pt += vec2(26.0, 161.0).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec4 hash_x = fract(Pt * (1.0 / 951.135664));\n    vec4 hash_y = fract(Pt * (1.0 / 642.949883));\n\n    // calculate the gradient results\n    vec4 grad_x = hash_x - 0.49999;\n    vec4 grad_y = hash_y - 0.49999;\n    vec4 grad_results = inversesqrt(grad_x * grad_x + grad_y * grad_y) * (grad_x * Pf_Pfmin1.xzxz + grad_y * Pf_Pfmin1.yyww);\n\n    // Classic Perlin Interpolation\n    grad_results *= 1.4142135623730950488016887242097;// scale things to a strict -1.0->1.0 range  *= 1.0/sqrt(0.5)\n    vec2 blend = Pf_Pfmin1.xy * Pf_Pfmin1.xy * Pf_Pfmin1.xy * (Pf_Pfmin1.xy * (Pf_Pfmin1.xy * 6.0 - 15.0) + 10.0);\n    vec4 blend2 = vec4(blend, vec2(1.0 - blend));\n    return dot(grad_results, blend2.zxzx * blend2.wwyy);\n}\n\nfloat fbm (vec2 p) {\n    float value = .0;\n    float amplitude = 1.5;\n    float frequency = 0.05;\n    for (int i = 0; i < 1; i++) {\n        float n = noise(p*frequency);\n        value += amplitude * n;\n        frequency *= 2.5;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nfloat sdOctahedron(vec3 p, float s){\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat sdCube(vec3 p, vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdTubularCube(vec3 p, vec2 s){\n    p = abs(p);\n    return max(p.x - s.x, p.y - s.y);\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r){\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdDoubleHelix(vec3 p){\n    float r = 2.;\n    float frq = 0.15;\n    float w = 0.5;\n    float helixA = sdTubularCube(vec3(p.x+r*sin(p.z*frq), p.y+r*cos(p.z*frq), p.z), vec2(w));\n    float helixB = sdTubularCube(vec3(p.x+r*sin(pi+p.z*frq), p.y+r*cos(pi+p.z*frq), p.z), vec2(w));\n    return min(helixA, helixB);\n}\n\nfloat sdCylinder(vec3 p, float w){\n    return length(p.xy) - w;\n}\n\nvec3 repeat(vec3 p, vec3 c){\n    return mod(p+0.5*c, c)-0.5*c;\n}\n\ndist getDistance(vec3 p){\n    bool lit = true;\n    if(p.y > 5.){\n        lit = false;\n    }\n    float plane = opSmoothUnion(p.y, 10.-p.y, 0.1);\n    float ampOffset = 0.5*pow(abs(sin((p.x*2.+p.z*2.5)*.1+iTime*1.5)), 3.);\n    float f = fbm(vec4(p, iTime*.7), ampOffset);\n    float d = plane-f;\n    float hue = .65-0.05*ampOffset;\n    float sat = .4;\n    return dist(d, 0, lit, hue, sat);\n}\n\n/*\ndist getDistance(vec3 p){\n    float d = sdSphere(p, 1);\n    bool lit = true;\n    float hue = .0;\n    float sat = .0;\n    return dist(d, 0, lit, hue, sat);\n}\n*/\n\nvec3 getNormal(vec3 p){\n    dist d0 = getDistance(p);\n    float d = d0.d;\n    vec2 offset = vec2(normalOffset, 0.);\n    dist d1 = getDistance(p-offset.xyy);\n    dist d2 = getDistance(p-offset.yxy);\n    dist d3 = getDistance(p-offset.yyx);\n    vec3 normal = d - vec3(d1.d, d2.d, d3.d);\n    return normalize(normal);\n}\n\nray raymarch(vec3 rayOrigin, vec3 dir, bool doRefract){\n    float distanceTraveled = 0.;\n    dist d;\n    vec3 p;\n    float distClosest = maxDist;\n    int refractions = 0;\n    for (int i = 0; i < maxSteps; i++){\n        p = rayOrigin+dir*distanceTraveled;\n        d = getDistance(p);\n        distClosest = min(distClosest, d.d);\n        if (d.d < surfaceDist && d.maxRefractions == 0){\n            break;\n        }\n        if (d.d < surfaceDist && refractions < d.maxRefractions){\n            vec3 n = getNormal(p);\n            dir = refract(normalize(dir), normalize(n), 0.5);\n            rayOrigin = p+dir;\n            refractions++;\n        }\n        if (distanceTraveled > maxDist){\n            break;\n        }\n        distanceTraveled += d.d;\n    }\n    return ray(p, d.lit, d.hue, d.sat, distClosest, distanceTraveled);\n}\n\nfloat getDiffuseLight(vec3 p, vec3 lightDir, vec3 normal, bool shadow){\n    float diffuseLight = max(dot(normal, -lightDir), 0.0);\n    return diffuseLight;\n}\n\nfloat getSpecularLight(vec3 p, vec3 lightDir, vec3 rayDirection, vec3 normal) {\n    vec3 reflectionDirection = reflect(-lightDir, normal);\n    float specularAngle = max(dot(reflectionDirection, rayDirection), 0.);\n    return pow(specularAngle, shininess);\n}\n\nray getShadow(vec3 p, vec3 normal, vec3 lightDir){\n    vec3 shadowOrigin = vec3(p.xyz)+normal;\n    vec3 shadowDirection = lightDir * -1.;\n    return raymarch(shadowOrigin, shadowDirection, false);\n}\n\nvec3 render(vec2 cv){\n    vec3 rayOrigin = vec3(translate.xyz);\n    rayOrigin.xz *= rotate2d(rotate);\n    vec3 rayDirection = normalize(vec3(cv.xy, distFOV));\n    rayDirection.xz *= rotate2d(rotate);\n    ray r = raymarch(rayOrigin, rayDirection, true);\n    vec3 normal = getNormal(r.hit);\n    vec3 lightDir = normalize(lightDirection);\n    lightDir.xz *= rotate2d(rotate);\n    vec3 col;\n    float diffuse;\n    float specular;\n    if(!r.lit){\n        lightDir.y = lightDir.y*-1.;\n    }\n    diffuse = getDiffuseLight(r.hit, lightDir, normal, true);\n    specular  = getSpecularLight(r.hit, lightDir, rayDirection, normal);\n    vec3 hsb = vec3(r.hue, r.sat, diffuse*diffuseMag + specular*specularMag);\n    vec3 light =\n    col = rgb(hsb);\n    col = step(r.distSum, maxDist*0.99)*col;\n    return col;\n}\n\nvec3 aarender(vec2 cv){\n    float off = (1./iResolution.x)/4.;\n    vec3 colA = render(cv+vec2(off, off));\n    vec3 colB = render(cv+vec2(-off, off));\n    vec3 colC = render(cv+vec2(off, -off));\n    vec3 colD = render(cv+vec2(-off, -off));\n    vec3 mixed = (colA+colB+colC+colD)/4.;\n    return mixed;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    fragColor = vec4(render(cv), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}