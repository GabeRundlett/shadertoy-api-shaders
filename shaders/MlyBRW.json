{
    "Shader": {
        "info": {
            "date": "1541945792",
            "description": "Just cubes and colors",
            "flags": 0,
            "hasliked": 0,
            "id": "MlyBRW",
            "likes": 8,
            "name": "Color Cubes",
            "published": 3,
            "tags": [
                "raymarching",
                "glow"
            ],
            "usePreview": 0,
            "username": "Tenderz",
            "viewed": 647
        },
        "renderpass": [
            {
                "code": "#define STEPS 128\n#define PREC_MULT 0.0001\n#define TMAX 150.0\n#define TMIN 1.0\n#define PI 3.14159265359\n\nvec3 mainLightDir;\nvec3 mainLightColor;\nvec3 ambientColor;\n\nvec3 FastHSL(vec3 hsl);\n\n// Unsigned cos [0,1]\nfloat ucos(float t) {\n    return cos(t) * 0.5 + 0.5;\n}\n\nvec2 rotate(vec2 axis, float angle) {\n    return vec2(\n        cos(angle) * axis.x + sin(angle) * axis.y,\n        -sin(angle) * axis.x + cos(angle) * axis.y\n    );\n}\n\nfloat roundBox( vec3 p, vec3 b, float r) {\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) - r + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat plane(vec3 p, vec3 n, float d) {\n    return dot(p, n)-d;\n}\n\nvec2 mat(float f, float m) {\n    return vec2(f, m);\n}\n\nvec2 un(vec2 a, vec2 b) {\n    if(a.x < b.x) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nvec3 matGlow(vec3 p) {\n    return FastHSL(vec3(mod(iTime*0.2+p.x*0.02+p.z*0.01, 1.0), 1,1));\n}\n\nvec3 matChecker(vec3 p) {\n    vec2 uv = p.xz;\n    vec2 grid = floor(mod(uv, 2.0));\n    vec3 baseColor;\n    if(grid.x == grid.y) {\n        baseColor = vec3(1,1,1);\n    } else {\n        baseColor = vec3(0,0,0);\n    }\n    baseColor = baseColor * 0.1 + vec3(1,1,1) * 0.1;\n    return baseColor;\n}\n\nvoid mapAll(vec3 p, inout vec2 base, inout float occ, inout vec3 light) {\n    light = vec3(0,0,0);\n    \n    vec3 boxp = p;\n    // boxp.xz *= 1+mod(mod(Time,1)+boxp.y, 1);\n    boxp = p-vec3(0.0,2.0+ucos(iTime)*2.0,0);\n    boxp.z = mod(boxp.z+4.0, 8.0)-4.0;\n    boxp.xz = rotate(boxp.xz, iTime+p.y);\n    float roundBoxd = roundBox(boxp, vec3(1.0 + mod(p.y*1.0+iTime*3.0,2.0) ,2.0+ucos(iTime),1.0) * 0.5, 0.3);\n    \n    float planei = abs(mod(p.x,2.0)-1.0);\n    float planes = floor(mod(p.x*0.5-0.5,2.0)) * 2.0 -1.0;\n    planei = pow(planei,0.2);\n    vec3 planep = p;\n    planep.y -= (planei*planes) * 0.2;\n    float planed = plane(planep, vec3(0,1,0), 0.0);\n    \n    light += pow(max(0.0, 1.0-roundBoxd / 5.0),4.0) * matGlow(p);\n    base = un(mat(planed, 0.0), mat(roundBoxd, 1.0));\n    occ = planed;\n}\n\nvec2 map(vec3 p) {\n    vec2 base;\n    float occ;\n    vec3 light;\n    mapAll(p, base, occ, light);\n    return base;\n}\n\n#define EPSILON 0.0001\nvec3 mapNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)).x - map(vec3(p.x - EPSILON, p.y, p.z)).x,\n        map(vec3(p.x, p.y + EPSILON, p.z)).x - map(vec3(p.x, p.y - EPSILON, p.z)).x,\n        map(vec3(p.x, p.y, p.z  + EPSILON)).x - map(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\nvec4 computeAO(vec3 pos, vec3 n) {\n    float occ = 0.0;\n\tvec3 light = vec3(0,0,0);\n    \n\tfor( int i=0; i<3; i++ )\n\t{\n\t\tvec3 aopos = pos + n*0.3*float(i);\n        \n        vec2 baseStep;\n        float occStep;\n        vec3 lightStep;\n        mapAll(aopos, baseStep, occStep, lightStep);\n\t\tocc += occStep;\n        light += lightStep;\n\t}\n    \n    float ao = clamp(occ, 0.0, 1.0);\n    \n\treturn vec4(light, ao);\n}\n\nvec3 shade(vec3 rayOrigin, vec3 rayDir, float t, float m) {\n    vec3 p = rayOrigin + rayDir * t;\n    vec3 n = mapNormal(p);\n    float nDotL = max(0.0, dot(n, -mainLightDir));\n    vec3 lightColor = ambientColor + nDotL * mainLightColor;\n    vec3 baseColor = vec3(1,1,1);\n    if(m == 0.) {\n        baseColor = matChecker(p);\n        vec4 ao = computeAO(p, n);\n        baseColor += ao.xyz;\n    } else if(m == 1.) {\n        baseColor = matGlow(p)*5.;\n    }\n    vec3 objColor = baseColor * lightColor;\n    return objColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    mainLightDir = normalize(vec3(-0.5,-1,-2));\n    mainLightColor = normalize(vec3(1.1,1.2,1)) * 0.5;\n    ambientColor = vec3(1,1,1) * 0.2;\n        \n    float ratio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 xy = (uv-.5) * vec2(ratio, 1);\n    \n    float yaw = iTime;\n    float pitch = -PI * 0.2;\n    vec3 lookAt = vec3(0,2,0);\n    vec3 lookDir = -normalize(vec3(0,0,1));\n    lookDir.zy = rotate(lookDir.zy, pitch);\n    lookDir.xz = rotate(lookDir.xz, yaw);\n    float lookDist = 8.0 + ucos(iTime) * 50.0;\n    vec3 camPos = lookAt - lookDir * lookDist;\n    vec3 o = camPos;\n    vec3 d = normalize(vec3(xy.x, xy.y,-1.5));\n    d.zy = rotate(d.zy, pitch);\n    d.xz = rotate(d.xz, yaw);\n    \n    float tmin = TMIN;\n    float tmax = TMAX;\n    float t = tmin;\n    vec2 trace;\n    float thres = 0.;\n    for(int i = 0; i < STEPS; i++) {\n\t    thres = PREC_MULT*t;\n        vec3 pos = o + d * t;\n        trace = map(pos);\n        float dist = trace.x;\n        if(dist < thres || t > tmax) {\n            break;\n        }\n        t += dist*0.6;\n    }\n    \n    vec3 c = vec3(0,0,0);\n    if(t < tmax) {\n        c = shade(o, d, t, trace.y);\n    }\n    \n    fragColor.xyz = c;\n    fragColor.a = 1.;\n}\n\n// https://github.com/hughsk/glsl-hsv2rgb\nvec3 FastHSL(vec3 hsl) {\n\tvec3 c = hsl;\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), c.y);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}