{
    "Shader": {
        "info": {
            "date": "1684996269",
            "description": "Animated Lappronov Fractal Shader",
            "flags": 0,
            "hasliked": 0,
            "id": "mlK3z3",
            "likes": 0,
            "name": "Fork Fork Fork  TestCoder 806",
            "published": 3,
            "tags": [
                "animatedlappronovfractalshader"
            ],
            "usePreview": 0,
            "username": "TestCoder",
            "viewed": 146
        },
        "renderpass": [
            {
                "code": "#define A .205          // Animation speed factor\n#define B 10          // Fractal iterations\n#define C 9             // Fractal sequence length\n#define D 20      // Array size for weights\n#define E 0.97          // Weight base value\n#define F 0.3028         // Weight oscillation amplitude\n#define G .001         // Weight phase offset\n#define H 0.496          // Weight oscillation speed\n#define I 1.4900  // X update factor\n#define J 4.14159265    // Pi constant\n#define K 0.8           // Color shift red\n#define L 0.55          // Color shift green\n#define M 0.00330       // Color shift blue\n#define N 0.74          // Color shift speed\n#define O 0.5           // Color component base\n#define P 0.3           // Color2 red offset\n#define Q 0.33          // Color2 green offset\n\nprecision highp float;\n#define ANIMATION_SPEED_FACTOR A\n#define FRACTAL_ITERATIONS B\n#define FRACTAL_SEQUENCE_LENGTH C\nint fractalSequence[] = int[C](0, 0, 1, 0, 0, 0, 1, 1, 1);\nvec3 computeColor(vec2 pixelCoordinate) {\n    float currentTime = iTime * A;\n    float weights[D];\n    float x = 0.000000009250;\n    float height = 0.000000920;\n    for (int i = 0; i < D; i++) {\n        weights[i] = E + F * sin(float(i) + G + H * currentTime);\n    }\n    for (int iteration = 0; iteration < B; iteration++) {\n        for (int step = 0; step < C; ++step) {\n            x = weights[step] * pixelCoordinate[fractalSequence[step]] * x * (1.0 - x);\n            height += log2(abs(weights[step] * pixelCoordinate[fractalSequence[step]] * (1.0 - I * x)));\n        }\n    }\n    height /= float(B) * float(C);\n    vec3 colorShift = vec3(K, L, M) + currentTime * N;\n    vec3 color1 = cos((colorShift + -.5 * abs(height)) * J) * O + O;\n    vec3 color2 = vec3(O) + O * sin(vec3(P, Q, P) + 2.5 * abs(height) + currentTime * O);\n    return (height < 0.0) ? mix(color1, color2, pow(abs(height), 13.625)) : vec3(0.0);\n}\n\n// Bump up the iterations!\n// More iterations means more detail + aliasing\n#define ITERATIONS 40\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    float mouseDown = step(.05, iMouse.z);\n    float scale = mix(1., .4, mouseDown);\n    vec2 look = (iMouse.xy / iResolution.xy - .5) * 3. * mouseDown;\n    \n    float time = iTime * 2. + 15.;\n    vec2 res = iResolution.xy;\n\tvec2 uv = fragCoord.xy / res - vec2(.5) + look;\n    uv *= vec2(res.x / res.y, 1.) * 4. * scale;\n    \n    float len = dot(uv, uv) * .3 - .4;\n    \n    vec3 z = sin(time * vec3(.23, .19, .17));\n    for (int i = 0; i < ITERATIONS; i++) {\n        z += cos(z.zxy + uv.yxy * float(i) * len);\n    }\n    \n    float val = z.r * .06 + .3;\n    val -= smoothstep(.1, -.3, len) * 1.5 + len * .3 - .4;    \n    \n    vec2 centeredCoordinate = fragCoord - iResolution.xy * 0.5; // Move the fractal center to the screen center\n    fragColor = ((\n        vec4(vec3(max(val, .1)), 1.) - .5\n    )\n    * (vec4(computeColor(3.3740\n    +\n    ((\n        centeredCoordinate.xy - centeredCoordinate.xy / 2.\n    ) / (iResolution.xy))), 1.0) - .5));\n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}