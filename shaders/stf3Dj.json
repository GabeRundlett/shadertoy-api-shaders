{
    "Shader": {
        "info": {
            "date": "1622860021",
            "description": "Based on \"2D Quadratic Bezier\" by demofox (shadertoy.com/view/MtS3Dy)\nand \"Reusable drag and drop\" by mhnewman (shadertoy.com/view/4dtSRn).\nMore info in comment below (sorry, characters limit).",
            "flags": 32,
            "hasliked": 0,
            "id": "stf3Dj",
            "likes": 13,
            "name": "2D Bezier: De Casteljau's",
            "published": 3,
            "tags": [
                "2d",
                "interactive",
                "bezier",
                "curve",
                "learning"
            ],
            "usePreview": 0,
            "username": "maras",
            "viewed": 564
        },
        "renderpass": [
            {
                "code": "/* \n Hi. I made this shader to make it easier to visualize Bezier curves and de Casteljau's algorithm.\n You can find more shaders to learn about Bezier curves\n on my playlist: https://www.shadertoy.com/playlist/X3XfWf (still WiP)\n Enjoy <3\n*/\n\n// changeable parameters (feel free to experiment!) \n\n#define BEZIER_CURVE_POINTS 5 // int, minimum = 2, maximum = 13\n\n// Remember to change BEZIER_CURVE_POINTS parameter in \"Buffer A\" too! (second tab, you can select it ot the top of this window)\n// After changing BEZIER_CURVE_POINTS peremeter you need to reset shader's time (button on the bottom of shader window)\n// PS: higher values can be imposible to compile if your GPU is weak. Sorry\n\n#define BACKWARDS_ANIMATION true // bool\n\n#define SLOW_DOWN 2.0 // float, need to be typed with decimal point (.)\n\n// sorry for naming the parameter \"SLOW_DOWN\" instead of \"SPEED\", but default speed is really fast\n// and it's easier for you to slow down things by an integer instead of speeding up by for example 0.25.\n// If you want to speed up the animation you can use a float lower than 1.0\n\n// Information on the parameters below is provided in the comment\n\n#define SHOW_RED_DOTS true // bool\n#define SHOW_BLUE_DOT true // bool\n#define SHOW_FINAL_DOT true // bool\n\n#define SHOW_BLACK_LINE true // bool\n#define SHOW_GREY_LINES true // bool\n\n#define ALWAYS_SHOW_BEZIER_CURVE false // bool\n\n#define CASTELJAUS_STEPS 50 // int, more than 1000 can really slow down your computer, be careful\n\n#define SHOW_1_SUPPORT_POINT true // bool\n#define SHOW_2_SUPPORT_POINT true // bool\n#define SHOW_3_SUPPORT_POINT true // bool\n#define SHOW_4_SUPPORT_POINT true // bool\n#define SHOW_5_SUPPORT_POINT true // bool\n#define SHOW_6_SUPPORT_POINT true // bool\n#define SHOW_7_SUPPORT_POINT true // bool\n#define SHOW_8_SUPPORT_POINT true // bool\n#define SHOW_9_SUPPORT_POINT true // bool\n#define SHOW_10_SUPPORT_POINT true // bool\n#define SHOW_11_SUPPORT_POINT true // bool\n\n#define SHOW_1_SUPPORT_LINE true // bool\n#define SHOW_2_SUPPORT_LINE true // bool\n#define SHOW_3_SUPPORT_LINE true // bool\n#define SHOW_4_SUPPORT_LINE true // bool\n#define SHOW_5_SUPPORT_LINE true // bool\n#define SHOW_6_SUPPORT_LINE true // bool\n#define SHOW_7_SUPPORT_LINE true // bool\n#define SHOW_8_SUPPORT_LINE true // bool\n#define SHOW_9_SUPPORT_LINE true // bool\n#define SHOW_10_SUPPORT_LINE true // bool\n#define SHOW_11_SUPPORT_LINE true // bool\n\n// non-changeable parameters (don't get me wrong, feel free to experiment with the entire code,\n// but you can screw something up :D )\n\n#define EDGE   0.005   // anti-aliasing\n#define SMOOTH 0.0025  // anti-aliasing \n\n#define BufA(x) texture(iChannel0, (vec2(x, 0.0) + 0.5) / iResolution.xy)\n\n\nconst int max_count = BEZIER_CURVE_POINTS;\nconst float radius = 20.0;\nconst float statePos = float(max_count);\n\nconst int factorials[13] = int[](\n                           1,\n                           1,\n                           2,\n                           6,\n                           24,\n                           120,\n                           720,\n                           5040,\n                           40320,\n                           362880,\n                           3628800,\n                           39916800,\n                           479001600);\n     \nconst vec3 support_lines_colors[11] = vec3[](\n                                      vec3(1.0, 0.839, 0.458),\n                                      vec3(1.0, 0.674, 0.478),\n                                      vec3(1.0, 0.658, 0.560),\n                                      vec3(1.0, 0.541, 0.788),\n                                      vec3(0.992, 0.380, 1.0),\n                                      vec3(0.788, 0.458, 1.0),\n                                      vec3(0.635, 0.541, 1.0),\n                                      vec3(0.380, 0.788, 1.0),\n                                      vec3(0.321, 1.0, 0.803),\n                                      vec3(0.807, 0.705, 0.592),\n                                      vec3(0.509, 0.482, 0.678));\n     \nconst vec3 support_points_colors[11]= vec3[](\n                                      vec3(0.992, 0.792, 0.325),\n                                      vec3(1.0, 0.639, 0.341),\n                                      vec3(1.0, 0.454, 0.301),\n                                      vec3(1.0, 0.039, 0.560),\n                                      vec3(0.807, 0.0, 0.819),\n                                      vec3(0.560, 0.0, 0.921),\n                                      vec3(0.333, 0.160, 1.0),\n                                      vec3(0.019, 0.662, 1.0),\n                                      vec3(0.0, 0.980, 0.694),\n                                      vec3(0.549, 0.443, 0.329),\n                                      vec3(0.270, 0.250, 0.392));                                       \n                                      \nconst vec3 final_dot_color = vec3(0.0,1.0,0.0);\n\nconst bool show_support_points[11] = bool[](\n                                     SHOW_1_SUPPORT_POINT,\n                                     SHOW_2_SUPPORT_POINT,\n                                     SHOW_3_SUPPORT_POINT,\n                                     SHOW_4_SUPPORT_POINT,\n                                     SHOW_5_SUPPORT_POINT,\n                                     SHOW_6_SUPPORT_POINT,\n                                     SHOW_7_SUPPORT_POINT,\n                                     SHOW_8_SUPPORT_POINT,\n                                     SHOW_9_SUPPORT_POINT,\n                                     SHOW_10_SUPPORT_POINT,\n                                     SHOW_11_SUPPORT_POINT);\n                                     \nconst bool show_support_lines[11] = bool[](\n                                    SHOW_1_SUPPORT_LINE,\n                                    SHOW_2_SUPPORT_LINE,\n                                    SHOW_3_SUPPORT_LINE,\n                                    SHOW_4_SUPPORT_LINE,\n                                    SHOW_5_SUPPORT_LINE,\n                                    SHOW_6_SUPPORT_LINE,\n                                    SHOW_7_SUPPORT_LINE,\n                                    SHOW_8_SUPPORT_LINE,\n                                    SHOW_9_SUPPORT_LINE,\n                                    SHOW_10_SUPPORT_LINE,\n                                    SHOW_11_SUPPORT_LINE);\n                                     \nint BinomialCoefficient(int n, int k) {\n    return factorials[n] / (factorials[k] * factorials[n-k]);\n}\n\nfloat DistanceToLineSegment(vec2 point, vec2 start, vec2 end) {\n    float A = point.x - start.x;\n    float B = point.y - start.y;\n    float C = end.x - start.x;\n    float D = end.y - start.y;\n\n    float dot1 = A * C + B * D;\n    float len_sq = C * C + D * D;\n    float param = -1.0;\n    if (len_sq != 0.0) {  param = dot1 / len_sq; }\n       \n    float xx, yy;\n\n    if (param < 0.0) {\n        xx = start.x;\n        yy = start.y;\n    }\n\n    else if (param > 1.0) {\n        xx = end.x;\n        yy = end.y;\n    }\n\n    else {\n        xx = start.x + param * C;\n        yy = start.y + param * D;\n    }\n\n    float dx = point.x - xx;\n    float dy = point.y - yy;\n    return sqrt(dx * dx + dy * dy);\n}\n\nfloat SDFCircle( in vec2 coords, in vec2 offset )\n{\n    coords -= offset;\n    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v / length(g); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 act_coord = ((fragCoord.xy / iResolution.xy) - vec2(0.25,0.5));\n    float aspectRatio = iResolution.x / iResolution.y;\n    act_coord.x *= aspectRatio;\n    \n    float dist;\n\n    vec2 control_points[max_count];\n    \n    vec4 state = BufA(statePos);\n    vec3 color = vec3(1.0,1.0,1.0);\n\n    for (int i = 0; i < max_count; ++i) {\n        float f = float(i);\n        if (f >= state.y) { break; }\n        \n        vec2 center = BufA(f).xy;\n        center = ((center.xy / iResolution.xy) - vec2(0.25,0.5));\n        center.x *= aspectRatio;\n\n        control_points[i] = center;\n    }\n    \n\n    float t = fract(iTime / SLOW_DOWN);\n\n    if (int(iTime / SLOW_DOWN) % 2 == 1 && BACKWARDS_ANIMATION) {\n        t = 1.0 - t;\n    }\n    \n    // draw bezier curve using de Casteljau's algorithm\n    if (SHOW_BLACK_LINE) {\n        vec2 prev_point = control_points[0];\n\n        float end_algorithm = t;\n\n        if(ALWAYS_SHOW_BEZIER_CURVE) { end_algorithm = 1.0; }\n\n        float increaser = end_algorithm / float(CASTELJAUS_STEPS);\n\n        end_algorithm += 0.001; // without it some small values of CASTELJAUS_STEPS couses ending curve before endpoint\n                                // (i don't know why)\n        \n        for (float i = 0.0; i <= end_algorithm; i += increaser) {\n            float i2 = 1.0 - i;\n            \n            vec2 point = vec2(0.0);\n            \n            for (int point_index = 0; point_index < max_count; ++point_index) {\n                point += float(BinomialCoefficient(max_count - 1, point_index)) \n                         * pow(i2, float(max_count - 1 - point_index)) \n                         * pow(i, float(point_index))\n                         * control_points[point_index];\n             }\n            \n            dist = DistanceToLineSegment(act_coord, prev_point, point) * 2.0;\n            \n            if (dist < EDGE + SMOOTH)\n            {\n                dist = max(dist, 0.0);\n                dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n                color *= vec3(dist);\n            }\n            \n            prev_point = point;\n        }\n    }\n    \n    // draw control points\n    for (int i = 1; i < max_count - 1; ++i) {\n        dist = SDFCircle(act_coord, control_points[i]);\n        if (dist < EDGE + SMOOTH && SHOW_RED_DOTS)\n        {\n            dist = max(dist, 0.0);\n            dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n            color *= mix(vec3(0.0,0.0, float(max_count - i) / float(max_count) ),vec3(1.0,1.0,1.0),dist);\n        }\n    }\n    \n    // draw start point\n    dist = SDFCircle(act_coord, control_points[0]);\n    if (dist < EDGE + SMOOTH && SHOW_RED_DOTS)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }\n        \n    // draw end point\n    dist = SDFCircle(act_coord, control_points[max_count-1]);\n    if (dist < EDGE + SMOOTH && SHOW_RED_DOTS)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }\n    \n    // draw lines between control points\n    if (SHOW_GREY_LINES) {\n        for (int i = 0; i < max_count - 1; ++i) {\n            dist = DistanceToLineSegment(act_coord, control_points[i], control_points[i + 1]) * 2.0;\n            if (dist < EDGE + SMOOTH && SHOW_GREY_LINES)\n            {\n                dist = max(dist, 0.0);\n                dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n                color *= mix(vec3(0.8),vec3(1.0,1.0,1.0),dist);\n            }\n        }\n    }\n    \n    // draw support lines and points\n    vec2 support_points[max_count] = control_points;\n    \n    for (int i = 0; i < max_count - 1; ++i) {\n        support_points[0] = support_points[0] + t * (support_points[1] - support_points[0]);\n        \n        for (int j = 1; j < max_count - i - 1; ++j) {\n            support_points[j] = support_points[j] + t * (support_points[j+1] - support_points[j]);\n            \n            dist = DistanceToLineSegment(act_coord, support_points[j-1], support_points[j]) * 2.0;\n            if (dist < EDGE + SMOOTH && show_support_lines[i])\n            {\n                dist = max(dist, 0.0);\n                dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n                color *= mix(support_lines_colors[i], vec3(1.0,1.0,1.0),dist);\n            }\n            \n            dist = SDFCircle(act_coord, support_points[j-1]);\n            if (dist < EDGE + SMOOTH && show_support_points[i])\n            {\n                dist = max(dist, 0.0);\n                dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n                color = mix(support_points_colors[i], vec3(1.0,1.0,1.0),dist);\n            }\n        }\n        \n        dist = SDFCircle(act_coord, support_points[max_count - i - 1]);\n        if (dist < EDGE + SMOOTH && i != 0  && show_support_points[i])\n        {\n            dist = max(dist, 0.0);\n            dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n            color = mix(support_points_colors[i-1], vec3(1.0,1.0,1.0),dist);\n        }\n    }\n    \n    vec2 point = vec2(0.0);\n    float t2 = (1.0 - t);\n            \n    for (int point_index = 0; point_index < max_count; ++point_index) {\n        point += float(BinomialCoefficient(max_count - 1, point_index)) \n                 * pow(t2, float(max_count - 1 - point_index)) \n                 * pow(t, float(point_index))\n                 * control_points[point_index];\n     }\n    \n    // draw final point\n    dist = SDFCircle(act_coord, point);\n    if (dist < EDGE + SMOOTH && SHOW_FINAL_DOT)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color = mix(final_dot_color, vec3(1.0,1.0,1.0),dist);\n    }\n    \n   \n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// this code is copied from https://www.shadertoy.com/view/4dtSRn (shader by mhnewman)\n\n#define BEZIER_CURVE_POINTS 5 // int, minimum = 2, maximum = 13\n// Remember to change BEZIER_CURVE_POINTS parameter in Image too! (second tab, you can select it ot the top of this window)\n// After changing BEZIER_CURVE_POINTS peremeter reset shader's time (button on the bottom of shader window)\n\nconst int maxCount = BEZIER_CURVE_POINTS;\nconst float radius = 20.0;\n\nconst vec4 deleteRect = vec4(0.0, 0.0, 40.0, 40.0);\n\nconst float statePos = float(maxCount);\nconst float offsetPos = float(maxCount + 1);\n\n#define addObject(xPos, yPos) { if (p.x == count) fragColor = vec4((xPos), (yPos), 0.0, 0.0); count += 1.0; }\n\nbool inRect(vec2 pos, vec4 rect) {\n    return pos.x >= rect.x && pos.y >= rect.y && pos.x < rect.z && pos.y < rect.w;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord - 0.5;\n    \n    if (p.y > 0.0 || p.x > offsetPos) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    if (iFrame == 0) {\n        float count = 0.0;\n\n        //\n        // Initial conditions\n        //\n        addObject(0.2 * iResolution.x, 0.2 * iResolution.y);  // start point\n        for(int i = 0; i < maxCount - 2; i++) {\n            addObject((0.1 + (float(i) / float(maxCount))) * iResolution.x,\n                      (0.8 - float(abs(i - maxCount / 2)) * 0.03) * iResolution.y); // control point\n        }\n        \n        addObject(0.8 * iResolution.x, 0.2 * iResolution.y); // end point\n        \n        if (p.x == statePos)\n            fragColor = vec4(2.0 * statePos, count, 0.0, 0.0);\n        return;\n    }\n    \n    vec4 state = texture(iChannel0, vec2(0.5 + statePos, 0.5) / iResolution.xy);\n    vec4 offset = texture(iChannel0, vec2(0.5 + offsetPos, 0.5) / iResolution.xy);\n\n    if (state.z <= 0.0 && iMouse.z > 0.0) {\n        float r = radius + 1.0;\n        for (int i = 0; i < maxCount; ++i) {\n            float f = float(i);\n            if (f >= state.y)\n                break;\n            vec4 center = texture(iChannel0, vec2(0.5 + f, 0.5) / iResolution.xy);\n            float d = distance(iMouse.xy, center.xy);\n            if (d < r * 5.0) {\n                r = d;\n                state.x = f;\n                offset = center - iMouse;\n            }\n        }\n        if (r > radius) {\n            if (state.y >= statePos) {\n            \tstate.x = 2.0 * statePos;\n            } else {\n    \t        state.x = state.y;\n        \t    state.y += 1.0;\n        \t}\n        }\n    } \n    state.z = iMouse.z;\n    \n    if (p.x == statePos) {\n        fragColor = state;\n        return;\n    }\n    \n    if (p.x == offsetPos) {\n        fragColor = offset;\n        return;\n    }\n\n    if (p.x == state.x && state.z > 0.0) {\n        fragColor = iMouse + offset;\n        return;\n    }\n    \n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}