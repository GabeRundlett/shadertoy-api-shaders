{
    "Shader": {
        "info": {
            "date": "1651402184",
            "description": "original street typo graffiti\n\n1. Learned how to draw the street graffiti by handwritten.\n2. Decided to use my first word for graffiti as the \"SHADER\".\n3. Added the bunch of radom elements around the word.",
            "flags": 0,
            "hasliked": 0,
            "id": "NllBDS",
            "likes": 25,
            "name": "digital street typo graffiti",
            "published": 3,
            "tags": [
                "cineshader",
                "typograffiti"
            ],
            "usePreview": 1,
            "username": "yasuo",
            "viewed": 2865
        },
        "renderpass": [
            {
                "code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL 0\n#define MATERIAL1 1\n#define MATERIAL2 2\n\n#define ZERO (min(iFrame,0))\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n    const vec3 s = vec3(27, 111, 57);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\n// noise and fbm function from https://www.shadertoy.com/view/Xd3GD4\n//-----------------------------------------------------------------------------\nvec2 hash( vec2 p ){\n    p = vec2( dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise2d( in vec2 p ){\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    \n    vec2 i = floor( p + (p.x+p.y)*K1 );\n    \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n    \n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    \n    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    \n    return dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv){\n    float f;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise2d( uv ); uv = m*uv;\n    f += 0.2500*noise2d( uv ); uv = m*uv;\n    f += 0.1250*noise2d( uv ); uv = m*uv;\n    f += 0.0625*noise2d( uv ); uv = m*uv;\n    f = 0.5 + 0.5*f;\n    return f;\n}\n\n\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\n\nfloat charS(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    float d = abs(length(p-vec2(-0.02,0.06))-0.06)-0.02;\n    float d2 = B(p-vec2(0.03,0.02),vec2(0.045,0.04));\n    d = max(-d2,d);\n    \n    d2 = abs(length(p-vec2(-0.02,-0.06))-0.06)-0.02;\n    float d3 = B(p-vec2(-0.06,-0.02),vec2(0.045,0.04));\n    d2 = max(-d3,d2);\n    \n    d = min(d,d2);\n    return d;\n}\n\nfloat charH(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    p.x = abs(p.x)-0.06;\n    float d = B(p,vec2(0.02,0.14));\n    p = prevP;\n    float d2 = B(p,vec2(0.08,0.02));\n    d = min(d,d2);\n    return d;\n}\n\nfloat charA(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    p.x = abs(p.x)-0.04;\n    p*=Rot(radians(-15.0));\n    float d = B(p,vec2(0.02,0.16));\n    p = prevP;\n    float d2 = B(p-vec2(0.0,-0.03),vec2(0.05,0.02));\n    d = min(d,d2);\n    d = max((abs(p.y)-0.09),d);\n    p = prevP;\n    p*=Rot(radians(22.0));\n    d2 =  B(p-vec2(-0.037,-0.12),vec2(0.019,0.12));\n    p*=Rot(radians(-21.0));\n    d2 = max(-p.y-0.2,d2);\n    d = min(d,d2);\n    return d;\n}\n\nfloat charD(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    float d = abs(sdBox(p,vec2(0.02,0.075))-0.04)-0.02;\n    d = max(-p.x-0.03,d);\n    float d2 = B(p-vec2(-0.05,0.0),vec2(0.02,0.135));\n    d = min(d,d2);\n    return d;\n}\n\nfloat charE(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    float d = B(p,vec2(0.065,0.13));\n    p.y = abs(p.y)-0.055;\n    float d2 = B(p-vec2(0.03,0.0),vec2(0.065,0.03));\n    d = max(-d2,d);\n    return d;\n}\n\nfloat charR(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    float d = abs(sdBox(p-vec2(0.0,0.05),vec2(0.02,0.025))-0.04)-0.02;\n    d = max(-p.x-0.03,d);\n    float d2 = B(p-vec2(-0.05,0.0),vec2(0.02,0.135));\n    d = min(d,d2);\n    p*=Rot(radians(-20.0));\n    d2 = B(p-vec2(0.02,-0.14),vec2(0.02,0.13));\n    p*=Rot(radians(20.0));\n    d2 = max(-p.y-0.2,d2);\n    \n    d = min(d,d2);\n    return d;\n}\n\nfloat arrow(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    \n    float d = B(p-vec2(0.0,-0.1),vec2(0.02,0.15));\n    float d2 = sdTriangleIsosceles(p-vec2(0.0,0.2),vec2(0.06,-0.2));\n    d = min(d,d2);\n    return d;\n}\n\nfloat trydent(vec2 p) {\n    vec2 prevP = p;\n    float d = B(p-vec2(0.0,-0.015),vec2(0.1,0.02));\n    \n    float d2 = sdTriangleIsosceles(p-vec2(0.0,0.095),vec2(0.035,-0.1));\n    d = min(d,d2);\n    \n    p.x = abs(p.x)-0.067;\n    p.y*=1.1;\n    d2 = sdTriangleIsosceles(p-vec2(0.0,0.095),vec2(0.035,-0.1));\n    d = min(d,d2);\n    return d;\n}\n\nfloat shaderText(vec2 p){\n    vec2 prevP = p;\n    p.y*=0.9;\n    float d = charS(p-vec2(-0.5,0.0));\n    float d2 = charH(p-vec2(-0.34,0.0));\n    d = min(d,d2);\n    d2 = charA(p-vec2(-0.14,0.0));\n    d = min(d,d2);\n    d2 = charD(p-vec2(0.05,0.0));\n    d = min(d,d2);\n    d2 = charE(p-vec2(0.22,0.0));\n    d = min(d,d2);\n    d2 = charR(p-vec2(0.38,0.0));\n    d = min(d,d2);\n    return d;\n}\n\nfloat typoGraphic(vec2 p, float option){\n    p.x-=0.06;\n    vec2 prevP = p;\n    \n    float d = length(p-vec2(0.22,0.1))-0.13;\n    float d2 = length(p-vec2(-0.3,-0.08))-0.05;\n    d = min(d,d2);\n    d2 = length(p-vec2(-0.4,0.1))-0.08;\n    d = min(d,d2);\n    d2 = sdRhombus(p-vec2(-0.05,0.0),vec2(0.05,0.2));\n    d = min(d,d2);\n        \n    p*=Rot(radians(-145.0));\n    d2 = arrow(p-vec2(0.5,0.47));\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(45.0));\n    d2 = arrow(p-vec2(0.25,0.53));\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(125.0));\n    d2 = arrow(p-vec2(0.0,0.3));\n    d = min(d,d2);   \n    \n    p = prevP;\n    p*=Rot(radians(-50.0));\n    d2 = arrow(p-vec2(-0.29,0.63));      \n    d = min(d,d2);\n    \n    p = prevP;\n    \n    p*=Rot(radians(180.0));\n    d2 = trydent(p-vec2(0.48,0.12));\n    d = min(d,d2);\n    \n    p = prevP;\n\n    d2 = shaderText(p);\n    d = min(d,d2);\n    \n    p.y = abs(p.y)-0.03;\n    float mask = B(p,vec2(2.0,0.012));\n    d = max(mask*option,d);\n    return d*0.3;\n}\n\nfloat circleArrow(vec2 p) {\n    vec2 prevP = p;\n    float d = abs(length(p)-0.3)-0.005;\n    \n    p*=Rot(radians(-40.0));\n    float d2 = B(p-vec2(0.0,0.2),vec2(0.17,0.2));\n    d = max(-d2,d);\n    \n    p = prevP;\n\n    p*=Rot(radians(90.0));\n    d2 = sdTriangleIsosceles(p-vec2(-0.3,-0.1),vec2(0.03,0.1));\n    d = min(d,d2);\n    return d;\n}\n\nvec2 GetDist(vec3 p) {\n\n    vec3 prevP = p;\n    \n    p = prevP;\n    p+=noise3d(p*300.0)*0.002;\n    float d = typoGraphic(p.xy,-1.0);\n    d = max((abs(p.z)-0.05),d);\n    \n    vec2 model = vec2(d,MATERIAL);\n    \n    p = prevP;\n    p.xz*=Rot(radians(30.0));\n    p.xy*=Rot(radians(-iTime*50.0));\n    d = circleArrow(p.xy);\n    d = max((abs(p.z)-0.01),d);\n    \n    vec2 model2 = vec2(d,MATERIAL1);\n    \n    p = prevP;\n    p*=0.8;\n    p.xz*=Rot(radians(-20.0));\n    p.xy*=Rot(radians(180.0-iTime*70.0));\n    p.yz*=Rot(radians(10.0));\n    d = circleArrow(p.xy);\n    d = max((abs(p.z)-0.01),d);\n    \n    vec2 model3 = vec2(d,MATERIAL1);\n    \n    model2 = combine(model2,model3);\n\n    return combine(model,model2);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,10,-10));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.)*occ; // spec\n        \n    return diffCol;\n}\n\nfloat randomSquare(vec2 p,float a,float startSize){\n    p*=a;\n    vec2 id = floor(p);\n    p = fract(p)-0.5;\n    vec2 n = hash(id);\n    \n    float d = B(p+(n*0.2),vec2(startSize+clamp(n.x,0.1,0.15)));\n    if(n.x<0.5){\n        d = 1.0;\n    }\n    return d;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL){\n        vec3 texCol = mix(vec3(0.0,0.5,1.0),vec3(0.8,0.2,0.2),smoothstep(0.3,-0.3,p.y));\n        float d = randomSquare(p.xy,100.0,0.2);\n        texCol = mix(texCol,vec3(0.5,0.7,0.9),S(d,0.0));\n        col = diffuseMaterial(n,rd,p,texCol);\n    } if(mat == MATERIAL1){\n        col = diffuseMaterial(n,rd,p,vec3(0.1,0.3,0.7));\n    } if(mat == MATERIAL2){\n        col = diffuseMaterial(n,rd,p,vec3(0.2));\n    }\n    return col;\n}\n\nvec3 drawGraphic(vec2 p, vec3 col){\n    vec2 prevP = p;\n    \n    float d = typoGraphic(p-vec2(0.015,-0.02),-1.0);\n    col = mix(col,vec3(0.3),S(d,0.0));    \n    \n    p.x-=0.06;\n    d = shaderText(p);\n    col = mix(col,vec3(0.9,0.8,0.0),S(d,0.0));\n    \n    p = prevP;\n    d = typoGraphic(p,-1.0);\n    col = mix(col,vec3(0.5,0.8,0.9),S(d,0.0));\n    \n    return col;\n}\n\nvec3 randomSquareBg(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    \n    p.y-=iTime*0.1;\n    p*=Rot(radians(45.0));\n    float d = randomSquare(p,7.0,0.01);\n    \n    vec2 id = floor(p);\n    vec2 n = hash(id)*0.1;\n    col = mix(col,vec3(0.8)+n.x,S(d,0.0));\n    \n    p = prevP;\n    p.y-=iTime*0.05;\n    p.x-=0.5;\n    p*=Rot(radians(-45.0));\n    d = randomSquare(p,5.0,0.01);\n\n    col = mix(col,vec3(0.9)+n.y,S(d,0.0));\n    \n    return col;\n}\n\nvec3 rhombusBg(vec2 p, vec3 col) {\n    p*=10.0;\n    p*=Rot(radians(65.0));\n    p.y-=iTime*0.5;\n    vec2 id = floor(p);\n    p = fract(p)-0.5;\n    vec2 n = hash(id);\n    \n    float d = sdRhombus(p,vec2(0.2,0.5));\n    if(n.x>-0.4){\n        d = abs(sdRhombus(p,vec2(0.2,0.5)))-0.02;\n    }\n    \n    col = mix(col,vec3(0.9)+n.y*0.5, S(d,0.0));\n    return col;\n}\n\nvec3 animationBg(vec2 p, vec3 col){\n        vec2 prevP = p;\n        \n        col = rhombusBg(p,col);\n        \n        col = randomSquareBg(p,col);\n        \n        p.x+=iTime*0.02;\n        p*=Rot(radians(20.0));\n        p.x = mod(p.x,0.016)-0.008;\n        \n        float border = abs(p.x)-0.005;\n        \n        p = prevP;\n        p*=fbm(p*2.5)*0.95;\n        \n        p.x*=0.5;\n        float d = length(p)-0.15;\n        \n        col = mix(col,vec3(0.85),S(d,0.0));\n        \n        p = prevP;\n        p*=fbm(p*2.8)*0.9;\n        \n        p.x*=0.5;\n        d = length(p)-0.13;\n        d = max(-border,d);\n        \n        col = mix(col,vec3(0.95),S(d,0.0));\n        return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -1.15);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.yz *= Rot(radians(-5.0));\n        ro.xz *= Rot(radians(sin(iTime)*5.0));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    } else {\n        col = animationBg(uv,col);\n        \n        uv*=0.98;\n        col = drawGraphic(uv,col);\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n\n    uv.x+=iTime*2.0;\n    col+=(hash(uv).x*3.0*hash(uv).y*3.0)*0.03;\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}