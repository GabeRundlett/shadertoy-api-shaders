{
    "Shader": {
        "info": {
            "date": "1469453384",
            "description": "portal clone\n\nporting works!\nplace portals: q/e\n\ndoing: portal gun (... sort of working)\ntodo: fix portal collision (jumping)\ntodo: material for stairs + portal border\ntodo: seperate rendering + game logic",
            "flags": 48,
            "hasliked": 0,
            "id": "4lt3DN",
            "likes": 24,
            "name": "Mondgestein",
            "published": 3,
            "tags": [
                "portal"
            ],
            "usePreview": 0,
            "username": "pyBlob",
            "viewed": 862
        },
        "renderpass": [
            {
                "code": "// minimum viewport resolution is set in Common.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * (res / iResolution.xy);\n    \n\tfragColor = texture(iChannel0, uv);\n    \n    uv = (fragCoord.xy - iResolution.xy/0.5) / iResolution.yy;\n    fragColor = mix(fragColor, vec4(1), clamp((0.2-length(uv))*iResolution.y, 0.0, 1.0));\n    \n    //fragColor = vec4(1.0);\n    //fragColor -= vec4(clamp(0.9 - 0.1*length(fragCoord.xy - iMouse.xy), 0.0, 1.0));\n    //fragColor -= vec4(clamp(0.8 - 0.05*length(fragCoord.xy - iMouse.zw), 0.0, 1.0));\n    //fragColor = iMouse.z<0.0 ? vec4(1.0) : vec4(0.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define AO\n\nconst float VK_LEFT  = 37.0;\nconst float VK_UP    = 38.0;\nconst float VK_RIGHT = 39.0;\nconst float VK_DOWN  = 40.0;\nconst float VK_A     = 65.0;\nconst float VK_W     = 87.0;\nconst float VK_D     = 68.0;\nconst float VK_S     = 83.0;\nconst float VK_E     = 69.0;\nconst float VK_Q     = 81.0;\n\nconst float var_base = res.y;\n\n#define var(v, x, y)  const vec2 v = vec2(x, y)+0.5;\nvar(GI_POS    , 3, var_base)\nvar(GI_LOOK   , 1, var_base)\nvar(GI_LOOKLOCK, 2, var_base)\nvar(GI_LASTPOS, 0, var_base)\nvar(GI_PORTAL1, 4, var_base)\nvar(GI_PORTAL2, 5, var_base)\n\nvec4 load(vec2 v)\n{\n    return texture(iChannel0, v / iChannelResolution[0].xy);\n}\n\nfloat keyDown(float key)\n{\n    return texture(iChannel1, vec2(key / 256.0, 0.2)).x;\n}\n\nbool test(float a, float b)\n{\n    return a-0.5 < b && a+0.5 > b;\n}\nbool test(vec2 a, vec2 b)\n{\n    return test(a.x, b.x);\n}\n\nmat3 setCamera(vec2 look)\n{\n    vec2 swap = vec2(1.0, -1.0);\n    vec4 cs1 = vec4(cos(look.x), sin(look.x), 0.0, 1.0);\n    vec4 cs2 = vec4(cos(look.y), sin(look.y), 0.0, 1.0);\n    \n    return\n         mat3(\n            cs2.xzy * swap.xxy,\n            cs2.zwz,\n            cs2.yzx\n        )\n        *\n        mat3(\n        \tcs1.wzz,\n            cs1.zxy,\n            cs1.zyx * swap.xyx\n        )\n        ;\n}\n\nvec4 sphere(vec3 pos, float radius)\n{\n    return vec4(\n        length(pos) - radius,\n        normalize(pos)\n    );\n}\n\nvec4 box(vec3 pos, vec3 size)\n{\n    vec3 d = abs(pos) - size;\n    return vec4(\n        min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)),\n        normalize(pos)\n    );\n}\n\nmat3 turn(vec3 t1, vec3 t2)\n{\n    return mat3(\n        t1,\n        t2,\n        cross(t1, t2)\n    );\n}\n\n#define union(a, b) if (b.x < a.x) a = b\n#define sect(a, b) if (b.x > a.x) a = b\n\nstruct Portal\n{\n    vec3 pos;\n    vec3 normal;\n    vec3 up;\n    vec3 right;\n};\n\nPortal p1, p2;\n\nmat3 warp1;\nmat3 warp2;\n\nint warpColor = 0;\nvec3 mapdir;\nvec3 mappos;\n\nbool loaded = false;\n\nvec4 mapRaw(vec3 pos)\n{\n    vec4 res = vec4(1000, 0, 0, 0);\n    \n    union(res, -box(pos - vec3(0,2,0), vec3(6,2,10)));\n    sect(res, -box(pos - vec3(16,2,0), vec3(6,2,10)));\n    sect(res, -box(pos - vec3(8,1,-5), vec3(3,1,1)));\n    sect(res, -box(pos - vec3(8,1,5), vec3(3,1,1)));\n    \n    union(res, sphere(pos - vec3(0,1,-4), 1.0));\n    union(res, box(pos - vec3(-3,1,4), vec3(1,1,1)));\n    union(res, box(pos - vec3(-3,1,7), vec3(3,1,3)));\n    \n    vec3 steps = pos - vec3(-3,0.9,1.0);\n    float offset = floor(steps.z/1.0+0.5)*1.0;\n    vec4 rstep = box(vec3(steps.x, steps.y - 0.5*offset - 0.1*(steps.z-offset), steps.z-offset), vec3(1,0.1,0.2));\n    \n    steps.z += 0.5;\n    offset = floor(steps.z/1.0+0.5)*1.0;\n    union(rstep, box(steps - vec3(0, 0.5*(offset-0.5) + 0.0*(steps.z-offset), offset), vec3(1,0.1,0.2)));\n    \n    steps.z -= 0.5;\n    sect(rstep, box(steps, vec3(1,1,2)));\n    \n    rstep.x *= 0.9;\n    union(res, rstep);\n    \n    if (loaded)\n    {\n        if (warpColor != 2)\n        {\n            vec3 delta = (pos - p1.pos) * warp1;\n            delta.z *= 2.0;\n            vec4 warpRes = vec4(length(vec2(delta.x, length(delta.yz)-0.9))-0.1, vec3(0.0));\n         \tunion(res, warpRes);\n            //union();\n            if (length(delta) < 1.0)\n            {\n                res = warpRes;\n                if (delta.x < 0.0)\n                {\n            \t\tdelta.z/=2.0;\n                    mappos = (warp2 * delta) + p2.pos;\n                    mapdir = warp2 * mapdir * warp1;\n                    warpColor = 1;\n                }\n            }\n            //union(res, sphere(delta, 1.0));\n        }\n        if (warpColor != 1)\n        {\n            vec3 delta = (pos - p2.pos) * warp2;\n            delta.z *= 2.0;\n            vec4 warpRes = vec4(length(vec2(delta.x, length(delta.yz)-0.9))-0.1, vec3(0.0));\n            union(res, warpRes);\n            if (length(delta) < 1.0)\n            {\n                res = warpRes;\n                if (length(delta) < 1.0 && delta.x > 0.0)\n                {\n            \t\tdelta.z/=2.0;\n                    mappos = (warp1 * delta) + p1.pos;\n                    mapdir = warp1 * mapdir * warp2;\n                    warpColor = 2;\n                }\n            }\n            //union(res, sphere(delta, 1.0));\n        }\n        //union(res, sphere(pos - p1.pos, 0.1));\n        //union(res, sphere(pos - p2.pos, 1.0));\n    }\n    \n    return res;\n}\n\nvec4 map(vec3 pos)\n{\n    warpColor = 0;\n    \n    return mapRaw(pos);\n}\n\nvec4 map2(vec3 pos)\n{\n    return mapRaw(pos);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    vec4 kk;\n    vec2 e = vec2(1.0,-1.0)*0.5773 * 1e-4;\n    return normalize(\n        e.xyy*map( pos + e.xyy ).x +\n        e.yyx*map( pos + e.yyx ).x +\n        e.yxy*map( pos + e.yxy ).x +\n        e.xxx*map( pos + e.xxx ).x\n    );\n}\n\nvec4 render(vec3 pos, vec3 dir)\n{\n    vec4 res = vec4(0);\n    float travel = 0.0;\n    \n    warpColor = 0;\n    for (int i=0 ; i<32 ; i++)\n    {\n        mappos = pos;\n        mapdir = dir;\n        res = map2(pos);\n        pos = mappos;\n        dir = mapdir;\n        \n        pos += dir * res.x;\n        travel += res.x;\n    }\n    \n    vec3 normal = getNormal(pos);\n    vec2 smap = vec2(0,0);\n    smap += vec2(dot(normal, vec3(pos.z,0,0)), 0.5*dot(normal, vec3(pos.y,0,0)));\n    smap += vec2(dot(normal, vec3(0,pos.x,0)), dot(normal, vec3(0,pos.z,0)));\n    smap += vec2(dot(normal, vec3(0,0,pos.x)), 0.5*dot(normal, vec3(0,0,pos.y)));\n    \n#ifdef AO\n    float ao = 0.0;\n    for (float i=-1.5 ; i<=1.5 ; i++)\n    {\n        for (float j=-1.5 ; j<=1.5 ; j++)\n        {\n            for (float k=-1.5 ; k<=1.5 ; k++)\n            {\n                vec3 v = 0.5*vec3(i,j,k);\n                ao += max(map(pos+v).x, 0.0) / 0.5;\n            }\n        }\n    }\n#else\n    float ao = 35.0;\n#endif\n    \n    float bias = -5.0+log(travel)/log(1.9);\n    vec3 color = texture(iChannel2, 0.2*smap, bias).xyz;\n    color = mix(color, vec3(1), 0.7);\n    vec2 coff = fract(smap);\n    \n    bias = 2.0 / (travel);\n    color = mix(color, vec3(0), (1.0-min(1.0, (35.0-2.0*travel)*min(min(coff.x, coff.y),min(1.0-coff.x, 1.0-coff.y))))*bias );\n    //color = ;\n    \n    return\n        mix(\n            //vec4((0.5+0.5*res.yz) / (1.0+0.3*travel), 0.0, 1.0),\n            vec4(clamp(ao/30.0,0.0, 1.0) * color, 1.0),\n            vec4(1.0),\n            clamp((travel - 2.0) / 25.0, 0.0, 1.0)\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y>=res.y+1.0)\n    {\n        return;\n    }\n    \n    vec3 playerPos = load(GI_POS).xyz;\n    vec3 lastPos = load(GI_LASTPOS).xyz;\n    \n    vec2 look = load(GI_LOOK).xy;\n    mat3 camera = setCamera(look);\n    \n    p1.pos = load(GI_PORTAL1).xyz;\n    p1.normal = getNormal(p1.pos);\n    p1.up = abs(p1.normal.y) > 0.5 ? vec3(1,0,0) : vec3(0,1,0);\n    p1.right = normalize(cross(p1.normal, p1.up));\n    warp1 = mat3(\n        p1.normal,\n        p1.up,\n        p1.right\n    );\n    \n    p2.pos = load(GI_PORTAL2).xyz;\n    p2.normal = -getNormal(p2.pos);\n    p2.up = abs(p2.normal.y) > 0.5 ? vec3(1,0,0) : vec3(0,1,0);\n    p2.right = normalize(cross(p2.normal, p2.up));\n    warp2 = mat3(\n        p2.normal,\n        p2.up,\n        p2.right\n    );\n    \n    loaded = true;\n    \n    if (test(fragCoord.y, var_base+0.5))\n    {\n        if (iFrame == 0)\n        {\n            playerPos = vec3(3.5,1.5,-4);\n            lastPos = playerPos;\n            look = vec2(0.0, -0.35);\n            \n            p1.pos = vec3(5.99,1,-0.5);\n            p2.pos = vec3(-1,1,3.99);\n        }\n        else if (fragCoord.x < 10.0)\n        {\n    \t\tvec2 lastMouse = load(GI_LOOK).zw;\n            \n            vec2 delta = (iMouse.yx - lastMouse.yx) / iResolution.yy;\n            if (length(delta) < 0.1)\n            {\n            \tlook += 3.0 * delta * vec2(-1,1);\n                look.x = clamp(look.x, -1.57, 1.57);\n            }\n            \n            vec2 move = 5.0 * iTimeDelta * vec2(\n                keyDown(VK_RIGHT)+keyDown(VK_D) - keyDown(VK_LEFT)-keyDown(VK_A),\n                keyDown(VK_UP)+keyDown(VK_W) - keyDown(VK_DOWN)-keyDown(VK_S)\n            );\n            \n            vec3 dir = (playerPos-lastPos) * pow(0.02, iTimeDelta);\n            vec3 walk = camera[0] * move.x + cross(camera[0], vec3(0,1,0)) * move.y;\n            dir.xz += 0.5 * (walk.xz-dir.xz);\n            dir += clamp(iTime, 0.0, 1.0) * vec3(0,-1,0) * iTimeDelta;\n            \n            playerPos += dir;\n            \n            mappos = playerPos;\n            mapdir = dir;\n            map(playerPos);\n            playerPos = mappos;\n            lastPos = playerPos - dir;\n            if (warpColor != 0)\n            {\n                vec3 dir = camera[2];\n                if (warpColor == 1)\n                {\n                    dir = warp2 * dir * warp1;\n                }\n                else\n                {\n                    dir = warp1 * dir * warp2;\n                }\n                look = vec2(\n                    atan(-dir.y, length(dir.xz)),\n                    atan(dir.x, dir.z)\n                    \n                );\n            }\n            \n            {\n            \tvec3 boundpos = playerPos + vec3(0,0.4,0);\n            \tvec3 normal = getNormal(boundpos);\n            \tplayerPos -= min(map(boundpos).x - 0.4, 0.0) * normal;\n            }\n            {\n            \tvec3 boundpos = playerPos + vec3(0,0.6,0);\n            \tvec3 normal = getNormal(boundpos);\n            \tplayerPos -= min(map(boundpos).x - 0.4, 0.0) * normal;\n            }\n        }\n        \n        if (test(fragCoord, GI_POS))\n        {\n            fragColor.xyz = playerPos;\n        }\n        else if (test(fragCoord, GI_LOOK))\n        {\n            fragColor = vec4(look, iMouse.xy);\n        }\n        else if (test(fragCoord, GI_LASTPOS))\n        {\n            fragColor.xyz = lastPos;\n        }\n        else if (test(fragCoord, GI_PORTAL1))\n        {\n            if (iTime > fragColor.w && keyDown(VK_Q)==1.0)\n            {\n                loaded = false;\n                fragColor.w = iTime + 1.0;\n                mappos = playerPos+vec3(0,1.5,0);\n                mapdir = camera[2];\n                for (int i=0 ; i<32 ; i++)\n                {\n                    vec4 x = map(mappos);\n                    mappos += mapdir * x.x;\n                }\n                p1.pos = mappos;\n                \n            }\n            fragColor.xyz = p1.pos;\n        }\n        else if (test(fragCoord, GI_PORTAL2))\n        {\n            if (iTime > fragColor.w && keyDown(VK_E)==1.0)\n            {\n                loaded = false;\n                fragColor.w = iTime + 1.0;\n                mappos = playerPos+vec3(0,1.5,0);\n                mapdir = camera[2];\n                for (int i=0 ; i<32 ; i++)\n                {\n                    vec4 x = map(mappos);\n                    mappos += mapdir * x.x;\n                }\n                p2.pos = mappos;\n                \n            }\n            fragColor.xyz = p2.pos;\n        }\n    }\n    else if (fragCoord.x < res.x)\n    {\n\t\tvec2 uv = (fragCoord.xy - res.xy*0.5) / res.yy;\n        \n        fragColor = render(playerPos+vec3(0,1.5,0), camera * normalize(vec3(uv,0.5)));\n\t\t//fragColor = vec4(vec3(clamp(length(5.0*uv-playerPos.xy),0.0,1.0)),1.0);\n        //fragColor = texture(iChannel2, uv*vec2(-1,1)+0.5);\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//const vec2 res = vec2(480, 270);\nconst vec2 res = vec2(420, 235);\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}