{
    "Shader": {
        "info": {
            "date": "1610127587",
            "description": "Publishing my old sound shaders.",
            "flags": 40,
            "hasliked": 0,
            "id": "4sVcDd",
            "likes": 7,
            "name": "Sequencing 2018-04-15",
            "published": 3,
            "tags": [
                "sound",
                "music",
                "sampleprecise"
            ],
            "usePreview": 0,
            "username": "ttg",
            "viewed": 359
        },
        "renderpass": [
            {
                "code": "/*\nStreaming Spectrogram v.4\nCopyright 2018 Theron Tarigo\n*/\n\n//#define POLAR\n\nvoid mainImage ( out vec4 f, in vec2 df ) {\n  ivec2 d = ivec2(df);\n  vec2 fsf = iResolution.xy;\n  ivec2 fs = ivec2(fsf);\n  int shift = int(fsf.x*timescale*(iTime))+1;\n\n  int rshift = 0;\n  //rshift = (shift)%fs.x;\n  f = texelFetch(iChannel0, ivec2((d.x+rshift)%fs.x,d.y), 0);\n  f = clamp(f,0.,2.);\n  f*=1.-exp(-2.*(-0.05+float((fs.x+d.x-(shift-rshift)%fs.x)%fs.x)/float(fs.x)));\n#ifdef POLAR\n  vec2 uv = (df-0.5*iResolution.xy)/iResolution.y*2.;\n  float r = length(uv);\n  float a = atan(uv.y, uv.x);\n  f = texture(iChannel0, vec2(a/6.2832+0.5, r));\n  if (r>1.) f*=0.;\n#endif\n  if (d.x<80) f = vec4(0.);\n  if (d.x<20) {\n    f = texelFetch(iChannel0, ivec2((shift-1)%fs.x,d.y), 0);\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nSound Experiment\nCopyright 2018 Theron Tarigo\n*/\n\nstruct stm {\n  int samp;\n  float frac;\n};\n\nstm stmtime (float t) {\n  float st = t*iSampleRate;\n  return stm(int(st),fract(st));\n}\n\nfloat timestm (stm a) {\n  float st = float(a.samp)+a.frac;\n  return st/iSampleRate;\n}\n\nstm add (stm a, stm b) {\n  float fracsum = a.frac+b.frac;\n  return stm(a.samp+b.samp+int(fracsum),fract(fracsum));\n}\n\nstm sub (stm a, stm b) {\n  float fracdif = a.frac-b.frac;\n  return stm(a.samp-b.samp+int(fracdif),fract(fracdif));\n}\n\nconst float pi = 3.141592653589793;\n\nfloat wave(float t) { return sin(2.*pi*fract(t)); }\n\nfloat sincstep(float x) {\n    return ( x<0.001 ? 0. : 1.0-sin(pi*x)/(pi*x) );\n}\n\nfloat intfract(int s, float n) {\n  //return fract(float(s)/n);\n  int sn = int(n);\n  float fn = fract(n);\n  return float(s%sn)/n+fract(float((s/sn)*sn)/n);\n  //return ((((s)%2)==0)?0.:0.5);\n    \n}\n\nfloat syntime;\nint synsamp;\n\nfloat pulse1(float freq, float decay, float reltime) {\n  float time = reltime+syntime;\n  //int synsamp = int(syntime*iSampleRate+0.25);\n  int relsamp = int(reltime*iSampleRate+0.5);\n  int samp = synsamp+relsamp;\n  if (samp<0) return 0.;\n  freq*=2.;\n  //int freqsamp = int(iSampleRate/freq);\n  //float freqfract = fract(iSampleRate/freq);\n  //float sinearg = (float(samp%freqsamp)+fract(freqfract))*freq/iSampleRate;\n  //float sinearg = (float(samp%freqsamp)+(freqfract*float(samp/freqsamp)))*freq/iSampleRate;\n  //float sinearg = time*freq;//(float(samp%freqsamp)+float((samp/freqsamp)*freqsamp))*freq/iSampleRate;\n  //float sinearg = float(samp%freqsamp)/float(freqsamp);\n  //float sinearg = time*freq;\n  float f = 1.-sin(2.*pi*intfract(samp, iSampleRate/freq/2.))/(pi*time*freq);\n  if (samp<40) f=0.;\n  //float f = sincstep(time*freq);\n  float f2 = cos(2.*pi*intfract(samp, iSampleRate/freq*2.));\n  //float f2 = cos(time*freq*pi);\n    // return sincstep(time*freq*2.)*exp(-time*decay)*cos(time*freq*2.*pi); ///////\n  //return 0.2*sincstep(time*freq)*exp(-time*decay)*cos(time*freq*pi);\n  return f*exp(-time*decay)*f2;\n}\n\n/*float synth2(float freq, float time, float maxtime) {\n  float v = 0.;\n  for (float n=1.0; n<18.; n+=1.0) {\n    v += pulse1(freq*n, pow(n,2.)*1., time)*exp(-n*0.3);\n  }\n  if (time < 0. || time > maxtime) return 0.;\n  v*=1.-exp((time/maxtime-1.)*8.);\n  return v;\n}*/\n\nfloat synth3(float freq, float reltime, float decay, float maxtime) {\n  float v = 0.;\n  float time = reltime+syntime;\n  for (float n=1.0; n<20.; n+=1.) {\n    if (freq*n>iSampleRate*0.4) break;\n    v += 0.05*pulse1(freq*n, 2.*pow(n,1.)*0.8*freq/400./decay, reltime)*exp(-n*0.5);\n  }\n  if (time < 0. || time > maxtime) return 0.;\n  v*=1.-exp((time/maxtime-1.)*8.);\n  //v*=1.-exp(-time*80.);\n  return v;\n}\n\nvoid play_synth3(inout float f, float ampl, float freq, float time, float decay, float maxtime) {\n  if ((syntime+time) < 0. || (syntime+time) > maxtime) return;\n  f += ampl*synth3(freq, time, decay, maxtime);\n}\n\nvoid play_seq1(inout float f, float ampl, float time, float clk) {\n  //if (time < 0. || time > clk*64.+10.) return;\n  //float ampl = 0.5;\n  float fbase = 256.;\n  for (int i = max(0,int((syntime+time)/clk)-20); i < int((syntime+time+10.)/clk)+2; i++) {\n  //for (int i = 0; i < int(2./clk); i++) {\n    float fmult = (float[](1.,2.,1.,1.,2.,1.,14./8.,2.,17./8.,1.,2.,1.,2.,2.,16./9.,2.))[(i^(i/4))%9];\n    int j = i;///2;\n    float r = (float[](1.,2.,1.,4.,1.,2.,1.,4.))[(j^(j/8))%8];\n    for (float j = 0.; j < 1.; j+=1./r) {\n      play_synth3(f, ampl, fbase*fmult, time-(float(i)+j)*clk, 1./r, 10./r);\n    }\n  }\n}\n\nvec2 smoothclip(vec2 f) {\n    float p = 3.;\n    f.x = pow(atan(pow(abs(f.x),p)*1.571)/1.571,1./p)*sign(f.x);\n    f.y = pow(atan(pow(abs(f.y),p)*1.571)/1.571,1./p)*sign(f.y);\n    return f;\n}\n\nvec2 mainSound(int sampin ) {\n  //float time = timein + 180.*0.;\n  synsamp = sampin;\n  float timein = float(synsamp)/iSampleRate;\n  syntime = timein;\n  vec2 v = vec2(0.);\n  float f = 0.;\n  float clk = 0.25;\n  //for (float i = 0.; i < 256.; i++) {\n  //  play_seq1(f, 0.5, time-16.*clk*i, 0.25);\n  //}\n  play_seq1(f, 0.5, -2.0, 0.25);\n  //play_seq1(f, 0.5, time, 0.125);\n  \n  v = vec2(f);\n  //v *= max(1.-exp(-0.5*(time+2.)),0.)*min(1.,exp(0.5*time));\n  //v *= max(1.-exp(-10.*(178.-timein)),0.);\n  //v*=0.6;\n  v = smoothclip(v);\n  return vec2(v);\n}\n\n\n\n// Spectrogram Config\n\nconst float timescale = 1./4.; // Screens per second\nconst float freqscale = 4000.;\nconst vec2 stereomix = vec2(1.,1.)*40.;\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*\nStreaming Spectrogram v.4\nCopyright 2018 Theron Tarigo\n*/\n\nconst float windowmax = 0.5;\n\nvec4 encode ( int i ) { return vec4((uvec4(i)>>ivec4(0,8,16,24))&0xFFu)/255.; }\nint decode ( vec4 f ) { uvec4 d = uvec4(f*255.)<<ivec4(0,8,16,24);\n  return int(d.x|d.y|d.z|d.w); }\n\nvoid mainImage ( out vec4 f, in vec2 pixf ) {\n  f = vec4(0.);\n  if (iFrame==0) return;\n  ivec2 pix = ivec2(pixf);\n  ivec2 res = ivec2(iChannelResolution[0].xy);\n  int center = res.x*res.y/2;\n  int offset = int(iTime*iSampleRate) - center;\n  int index = res.x*pix.y+pix.x;\n  int sampstart = decode(texelFetch(iChannel0, ivec2(1,0), 0));\n  bool start = (iFrame==1 || iTimeDelta>3.0);\n  //bool start = (iFrame==1);\n  if (index==1) {\n    // Fix Shadertoy's failure to synchronize iTime to audio\n    //if (start) sampstart = int(iSampleRate*(iTime-10.*iTimeDelta));\n    if (start) sampstart = int(iSampleRate*(iTime));\n    f = encode(sampstart);\n    return;\n  }\n  if (start) {\n    f = vec4(0.);\n  }\n  if (index==0) { f = encode(offset); return; }\n  int offsetlast = decode(texelFetch(iChannel0, ivec2(0), 0));\n  int cutoff = int(windowmax*iSampleRate);\n  if (abs(index-center) > cutoff) return;\n  int samp = index+offset;\n  int samplast = center+cutoff+offsetlast;\n  float time = (float(samp)-0.5)/iSampleRate;\n  if (samp <= offsetlast + center + cutoff) {\n    f.xy = texelFetch(iChannel0,\n      (ivec2(index+offset-offsetlast)/ivec2(1,res.x))%(res), 0).xy;\n  } else {\n    f.xy = mainSound(samp-sampstart);\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\nStreaming Spectrogram v.4\nCopyright 2018 Theron Tarigo\n*/\n\nconst float sgr_pi = 3.141592653589793;\n\nvec2 readsound ( int isamp ) {\n  ivec2 res = ivec2(iResolution.xy);\n  int offset = int(iTime*iSampleRate) - res.x*res.y/2;\n  int samp = isamp - offset;\n  ivec2 pix = ivec2(samp%res.x, (samp/res.x));\n  return texelFetch(iChannel1, pix, 0).xy;\n}\n\nvec2 spectrogram ( float windowtime, int isamp, float freq ) {\n  vec2 sum = vec2(0.);\n  int iwindow = int(windowtime*iSampleRate);\n  float window = float(iwindow)/iSampleRate;\n  window = windowtime;\n  for (int irel = -iwindow; irel <= iwindow; irel+=1) {\n    // Cosine window\n    float w = (0.5+0.5*cos(float(irel)/float(iwindow)*sgr_pi));\n    float samp = dot(stereomix,readsound(isamp+irel));\n    float a = fract(float(irel/**/+0*isamp/**/)*freq/iSampleRate)*2.*sgr_pi;\n    sum += w*vec2(cos(a),sin(a))*samp;\n  }\n  return sum/iSampleRate/window;\n}\n\n// Calibrated to ttg's hearing\n// Returns modulation frequency at which a tone at base frequency\n// transitions from sounding as beats to sounding as separate tones\nfloat timeratiofn ( float freq ) {\n  const float nparam = 58.5;\n  const float aparam = 950.;\n  return freq/nparam + exp(-freq/aparam)*aparam/nparam;\n}\n\nvoid mainImage ( out vec4 f, in vec2 df ) {\n  ivec2 d = ivec2(df);\n  vec2 fsf = iResolution.xy;\n  ivec2 fs = ivec2(fsf);\n  \n  int shift = int(fsf.x*timescale*(iTime));\n  int shiftlast = int(fsf.x*timescale*(iTime-iTimeDelta));\n  int delta = shift - shiftlast;\n\n  int x2 = (shift+(fs.x-d.x))%fs.x;\n  if (x2>delta) {\n    f = texelFetch(iChannel0,d,0);\n    //if (d.y>fs.y-32) f = vec4(0.5);\n    return;\n  }\n  float time = float(shift-x2)/timescale/fsf.x;\n  int isamp = int(time*iSampleRate);\n  float y = float(d.y);\n\n  float freq = freqscale * y / iResolution.y;\n  float windowfreq = timeratiofn(freq);\n  vec2 s = spectrogram(1./windowfreq, isamp, freq);\n  float ss = dot(s,s);\n  f.rgb = vec3(10.,3.2,1.)*ss*50.;\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2 mainSound(int samp, float _time){return mainSound(samp);}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}