{
    "Shader": {
        "info": {
            "date": "1648628827",
            "description": "Yet another iteration of my basic pathtracer, this time adding some pbr stuff like rougness and fresnel, alowing for all kinds of surfaces to be rendered like gold for example.",
            "flags": 32,
            "hasliked": 0,
            "id": "slfyDS",
            "likes": 6,
            "name": "Menger PT v4",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "gi",
                "path",
                "pbr"
            ],
            "usePreview": 0,
            "username": "El_Sargo",
            "viewed": 328
        },
        "renderpass": [
            {
                "code": "//The actual rendering is in buffer A\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv)/float(iFrame);\n    col = col*exp(vec4(1.1,1.05,1.2,1. ));\n    fragColor = smoothstep(-0.,1.2,col);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec3 sun = normalize(vec3(1.2,1.,1.)); // The direction of the sunlight\nconst vec3 suc = vec3(.99,0.7,0.4); // sunlight color\nconst float unIntersect = 0.001; // don't touch this\nconst int iter = 6; // number of GI bounces\nconst float bou_coef = 5.; // intensity of bounce light\nconst float sun_coef = 1.9; // intensity of sun light\nconst float amb_coef = 1.; // intensity of ambient light\nconst float r = .12;\nconst bool metalic = true;\n//Dosn't actually need an array, just makes it easer to use many materials\n// Pbr also wasn't implemented\nconst vec3[] colors = vec3[](vec3(0.),vec3(0.31,0.28,0.15));\n\n//ambient light color\nvec3 amb(vec3 rd){\n    return clamp(vec3(vec2(0.8,0.9)*(0.7+pow(.9-rd.y, 2.)*0.4),1.-rd.y*0.1),vec3(0.),vec3(1.));\n}\n\n//#define rotations\n\n//Heavy performance impact \n#define raymarchSteps 60\n\n#define ZERO min(iFrame, 0)\n\n//SDF stuff....\nconst float pi = 3.14159265359;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n// rotation matrix\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s,\n                -s, c);\n}\n\n\n\n// transfrom a point to from a fractal\nvec3 trans(vec3 p, float s){\n        //Mirror\n        p = abs(p)-1.*s;\n        p *= -1.;\n        //Reflect column\n        p.xy = ((p.x - p.y > 0.) ? p.yx : p.xy);  \n        p.zy = ((p.z - p.y > 0.) ? p.yz : p.zy);  \n\n        //construct column\n        p.y = (abs(p.y-0.5*s)-0.5*s);\n        \n        return p;\n}\n// distance to a fractal\n// yes you can use a loop, but I wanted controll over the rotations\nvec4 map(vec3 p) {\n\n    const float scale = 260.*3.;\n\n    p*= scale;\n    \n    #ifdef rotations\n    p = trans(p, 27.*9.);\n    p.xy *= rotate(2.2);\n    p = trans(p, 27.*3.);\n    p.zy *= rotate(5.2);\n    p = trans(p, 27.);\n    p.xz *= rotate(2.12);\n    p = trans(p, 9.);\n    p.yz *= rotate(1.512);\n    p = trans(p, 3.);\n    p.yz *= rotate(1.12);\n    p = trans(p, 1.);\n    p.zy*=rotate(0.1);\n    #else\n    p = trans(p, 27.*9.*3.);\n    p = trans(p, 27.*9.);\n    p = trans(p, 27.*3.);\n    p = trans(p, 27.);\n    p = trans(p, 9.);\n    p = trans(p, 3.);\n    p = trans(p, 1.);\n    \n    #endif\n\n    return vec4(sdBox(p, vec3(.5))/scale, p);\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.0001;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).x;\n    }\n    return normalize(n);\n}\n\n\n// For the fractal\nfloat intersection(vec3 ro, vec3 rd){\n    float dist;\n    float T;\n    for (int i = 0; i < raymarchSteps; i++){\n        dist = map(ro+rd*T).x;\n        T+=dist;\n        if (dist < 0.00001 || dist > 2.)\n            break;\n    }\n    \n    return T;\n\n}\n\n// Hash function\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\nvec3 hash3(vec3 p3)\n{\n    p3 += iTime*vec3(0.513, 1.134, -2.1245);\n \n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    p3 = fract((p3.xxy + p3.yxx)*p3.zyx);\n    \n    return normalize(p3-0.5);\n\n}\n/*\n//Random direction\nvec3 hash3( vec3 p )\n{\n    p+=iTime*vec3(0.8,0.5,-2.);\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn normalize(fract(sin(p)*43758.5453123)-0.5);\n}\n*/\n\nvec3 ranRef(vec3 rd, vec3 nor){\n    vec3 dir = hash3(rd-nor*r);\n         dir *= sign(dot(nor,dir));\n         \n    vec3 ref = reflect(rd, nor);\n    \n    if (hash3(rd+nor+r).x*.5+.5 > r){\n        dir = mix(ref, dir, r);\n    }\n    \n    return dir;\n}\n\nstruct world {\n    int  id;\n    vec3 pos;\n    vec3 nor;\n    float dis;\n};\n\nworld wolrdIntersect(vec3 ro, vec3 rd){\n    vec3 nor = vec3(0);\n    float d = 10e10;\n    int id = 0;\n    //fractal\n    {\n        float md = intersection(ro,rd);\n        if (map(ro+rd*md).x < 0.1 && md < d){\n            id = 1;\n            nor = calcNormal(ro+rd*md);\n            d = md;\n        }\n    }\n    /*//ball\n    {\n        vec3 ce = vec3(0,-0.32,-.97);\n        float bd = sphIntersect(ro, rd, ce, 0.05).x;\n        if (bd > -0.1 && bd < d){\n            id = 2;\n            nor = normalize(ce-ro+bd*rd)*-1.;\n            d = bd;\n        }\n    }*/\n    return world(id,ro+d*rd,nor, d);\n}\n\n//Trace a path away from the shape and return 1 if we hit nothing\nfloat getShadow(vec3 p, vec3 rd){\n    rd = normalize(rd+ hash3(rd+p)*0.1);\n    p+=unIntersect*rd;\n    return wolrdIntersect(p, rd).id == 0 ? 1. : 0.;\n}\n\n//Shadow ray in a random direction\nvec3 getAmbiance(vec3 dir, vec3 nor, vec3 p, int i, out vec3 amD){\n    vec3 rd = ranRef(dir,nor);\n    rd.y = .1+rd.y;\n    amD = rd;\n    return getShadow(p+unIntersect*rd,rd)*amb(rd);\n}\n\nstruct ligt {\n    vec3 scl;\n    vec3 nor;\n    float sha;\n    vec3 amb;\n    vec3 amD;\n    vec3 inc;\n    vec3 ref;\n\n};\n\nfloat calcFresnel(vec3 inc, vec3 ref){\n    return ((abs(dot(inc, ref)))*0.5+1.)*0.7;\n}\n\nvec3 render(vec3 ro, vec3 rd){\n    vec3 dir = rd;\n    vec3 p = ro;\n    vec3 inc = rd;\n    vec3 amD;\n    ligt[iter] lig;\n    //Get light\n    for (int i=0;i<iter;i++){\n\n        world w = wolrdIntersect(p+dir*.05, dir);\n        float sha = getShadow(w.pos, sun);\n\n        //Colors\n        if (w.id==0){\n            if (i==0)\n                //Sky\n                return 0.3*amb(dir);\n             else {\n                break;\n            }\n        }\n        \n        vec3 am = vec3(0.);\n        for(int a=0;a<1;a++){\n            am += getAmbiance(dir, w.nor, w.pos,a,amD)*2.;\n        }\n        \n        dir = ranRef(dir, w.nor);\n        lig[i] = ligt(colors[w.id], w.nor,sha*(dot(sun,w.nor)*.25+.75), am, amD, inc, dir);\n        /*\n        dir = hash3(p+w.pos+dir);\n        dir *= sign(dot(w.nor,dir));\n        */\n        inc = dir;\n        \n        p = w.pos;\n\n\n    }\n    vec3 col = vec3(0);\n    for (int i=iter-1;i>-1;i--) {\n    \n         vec3 scl = lig[i].scl;\n        float sha = lig[i].sha;\n         vec3 am  = lig[i].amb;\n         vec3 amD = lig[i].amD;\n         vec3 nor = lig[i].nor;\n         vec3 inc = lig[i].inc;\n         vec3 ref = lig[i].ref;\n         \n          //prevoius bounce\n          vec3 pre = col*scl*bou_coef;\n          vec3 hVec = normalize(mix(inc,sun,0.5));\n          col = + mix(pre, pre*calcFresnel(inc,ref), 1.-r)+\n                //sun light\n                 float(metalic==false)*scl*sha*suc*sun_coef+\n                 float(metalic)*pow(dot(nor,hVec)*.5+.5,5.)*sun_coef*sha*scl+\n                //ambient light\n                scl*am*amb_coef*calcFresnel(inc,amD);\n\n    }\n    \n    return col;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 o = hash3(vec3(uv, iTime)).xz/iResolution.xy*0.5;\n    vec3 rd = normalize(vec3(\n            (uv-0.5)*vec2(1.,iResolution.y/iResolution.x)+o,\n            1.));\n    rd.xz *= rotate(.2);\n    rd.yz *= rotate(0.);\n    \n    vec3 ro = vec3(-.1,0.05,-1.3);//vec3(0.,-0.3,-1.);\n\n    vec3 col = render(ro,rd);\n    \n    vec3 prev = texture(iChannel0, uv).xyz;\n    \n    col += prev;\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}