{
    "Shader": {
        "info": {
            "date": "1670333707",
            "description": "Casting a Mobius shadow pattern from a spinning loxodromic spherical spiral object.",
            "flags": 0,
            "hasliked": 0,
            "id": "Dd2SWh",
            "likes": 93,
            "name": "Loxodrome Spiral Projection",
            "published": 3,
            "tags": [
                "spiral",
                "sphere",
                "mobius",
                "projection",
                "glow",
                "loxodrome",
                "mercator",
                "rhumb"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1181
        },
        "renderpass": [
            {
                "code": "/*\n\n    Loxodrome Spiral Projection\n    ---------------------------    \n    \n    I don't have a lot to do with math these days, but I still get a kick out \n    of visual art demonstrations that convey mathematical ideas. Casting \n    shadows onto planes from spherical objects to illustrate various \n    projection patterns is one such example.\n    \n    In this case, an extruded dashed spherical loxodrome spiral path has been \n    light projected to a back plane to form a Mobius spiral shadow -- I think a \n    loxodrome is a form of Mobius transformation, so I guess that's not \n    surprising. At any rate, in various circles, it's a fairly common \n    demonstration, and there's already at least one such example on Shadertoy, \n    for whch I've provided a link to below.\n    \n    My first attempts some time ago involved mapping out a spiral onto a sphere \n    using standard spherical coordinates, which kind of produced a Mobius spiral \n    looking shadow, but wasn't what I was after. After inquiring into MLA's \n    mercator coordinate examples, I realized that I wasn't using an angle \n    preserving formula, so once I adjusted for that, everything came together. \n    By the way, if you're interested in spherical spiral mapping, I've provided \n    a link to one of MLA's examples below, which is written in a much nicer way.\n    \n    I did originally have a very simple spiral projected onto a plain background,\n    but since there were already a few of those on the internet, I applied some\n    CSG to create dashed lines, then got carried away with glow, etc. The idea to \n    give the inner sphere a different color to the outside came from Kamoshika's \n    \"Cubic Shell with Slits\" example, which is a interesting in its own right.\n    \n    I've seen some really nice spherical spiral imagery on the internet that \n    doesn't involve projection, and I'd like to make one of those at some point.\n    In regard to shadow projection, I intend to post one of the common polyhedral \n    to Poincare disk presentations. By the way Neozhaoliang has a beautiful \n    example along those lines that I'll provide a link to below.\n    \n    \n    \n\n    // Other examples:\n    \n    // A very cool shader. Unfortunately, I wrote most of the code to this\n    // before looking at MLA's example, which is written in a much nicer way. \n    // The one line I \"borrowed\" from it is the reason I got my example to \n    // work properly, so I'm thankful anyway. :)\n    Indexed Mercator Spiral - mla\n    https://www.shadertoy.com/view/NsdBzn\n    \n    // More of a classy rendering, and reminiscent of Paul Nylander's \n    // classic loxodrome projection image.\n    Loxodrome - fb39ca4\n    https://www.shadertoy.com/view/MsX3D2\n\n    // Beautiful example.\n    Hyperbolic Group Limit Set - Neozhaoliang\n    https://www.shadertoy.com/view/NstSDs\n    \n    // Nice and concise. Kamoshika's other examples are worth\n    // looking at too.\n    Cubic Shell with Slits - Kamoshika\n    https://www.shadertoy.com/view/ftj3WG\n    \n\n*/\n\n\n// Dashed lines. Commenting this out will display the more\n// traditional connected spiral arms.\n#define DASHED\n\n// Outer and inner glow colors.\n#define glowCol1 vec3(3, 1, .2)\n#define glowCol2 vec3(1, 3, .2) // vec3(.3, 2.5, 5)\n\n// Maximum ray distance.\n#define FAR 20.\n\n// Trying to stop the loop from unrolling to reduce compile times.\n#define ZERO min(iFrame, 0)\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(27.617, 57.643)))*43758.5453); }\n\n\n// IQ's vec2 to float hash.\nfloat hash31(vec3 p){  \n    return fract(sin(dot(p, vec3(113.619, 57.583, 27.897)))*43758.5453); \n}\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// The smooth maximum equivalent.\nfloat smax(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n/*\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(.8)); \n    //n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n*/\n\n// Global object ID and 2D line distance.\nfloat gOID, gLn;\n\n// Global lattitudinal and logitudinal (sphere surface) texture coordinates.\nvec2 gSUV;\n\n// Global glow and glow color variables.\nvec3 glow, lCol; \n\n\n// Loxodromic sphere scene.\nfloat map(vec3 p){\n\n    // Back plane.\n    float pln = -p.z + 2.;//abs(p.z - 2. + .01) - .01;\n    \n    // Sphere rotation.\n    p.xy *= rot2(3.14159/3.);\n    p.xz *= rot2(-iTime/2.);\n    //p.yz *= rot2(-iTime/4.);\n \n                    \n\n    // Sphere coordinates. \n    vec3 sphP = p;\n    // Coordinates for the polar caps. Note the abs(Y) to draw both poles with one call. \n    vec3 q = vec3(sphP.x, abs(sphP.y), sphP.z) - vec3(0, 1, 0);\n\n    // The X value controls the number of dashes per revolution and the Y value\n    // dictates the number of spiral arms.\n    const vec2 sSc = vec2(3, 3);\n    float ax = atan(sphP.z, sphP.x)/6.2831; // Longitudinal coordinate.\n    float ay = asin(sphP.y/length(sphP));// Or atan(sphP.y, length(sphP.xz)); // Latitude. \n    // The above are only spherical coordinates, which you can arrange to spiral around\n    // a sphere. However, to spiral along a spherical rhumb line in an angle preserving\n    // manner, the following adjustment needs to be applied. I knew something was necessary,\n    // but didn't know what it was. Thankfully, MLA did, so I was able to use his calculation. \n    // I usually prefer to derive these things myself, but I'm going to take it at face value. \n    // I'm guessing it'd be an application of differential surface geometry, or something \n    // along those lines.\n    // \n    // Indexed Mercator Spiral - mla\n    // https://www.shadertoy.com/view/NsdBzn\n    //\n    // The following are equivalent. I'm not sure which one the GPU likes best, \n    // but I'm going to go with the most concise one. :)\n    ay = asinh(tan(ay))/6.2831;\n    //ay = log(tan(3.14159265/4. + ay/2.))/6.2831; // Mercator\n    //ay = sign(ay)*acosh(1./cos(ay))/6.2831;// + .5;\n    \n    // The number of spirals per arm.\n    const float spirals = 5.; \n    // Spiral lines running perpendicular to one another. You can combine\n    // these to form objects, provide texture coordinates, etc.\n    vec2 spir = vec2(ax*spirals + ay, ax - ay*spirals);\n    \n    gSUV = spir*sSc;\n    \n    // Unique dash line UV. Not used here.\n    //vec2 ia = floor(gSUV)*sSc + .5;\n    \n    // Line thickness. The first line arranges for increased thickness near the poles.\n    float th = 1./(.001 + pow(length(sphP - sign(sphP)*vec3(0, 1, 0)), .5)*256.);\n    th += .04; // Constant thickness.\n    \n    // Divisor much be a factor of the scale (sSc) above.\n    vec2 ln = abs(mod(spir, 1./sSc) - .5/sSc) - th;\n\n    \n    \n    #ifdef DASHED\n    ln.x = smax(ln.y, -(ln.x - .01), .02); // Using the other spiral to cut out holes.\n    #else \n    ln.x = smax(ln.y, -(ln.x + .044), .015); // Closing the gaps.\n    //ln.x = ln.y; // The less interesting continuous spiral arms.\n    #endif\n    \n    // Smoothly blending in the polar caps.\n    ln.x = smin(ln.x, length(q) - .05, .1);\n      \n    // Saving the 2D dashed line (the rounded rectangle shape) object to a global\n    // to be used later.\n    gLn = ln.x;\n\n \n    // Unit sphere.\n    float sph = length(p) - 1.;\n    // Extruded dashed line distance one.\n    float d = max(ln.x, abs(sph) - .01);// + (abs(fract(oAx*64. + iTime*1.) - .5) + .1)*.01*0.\n    // Putting a frame around the dashed line.\n    float d2 = max(abs(ln.x) - .01, abs(sph) - .02);\n    \n    \n    // Object ID: Plane, extruded inner rectangle, extruded rectangle frame.\n    gOID = pln<d && pln<d2? 0. : d<d2? 1. : 2.;\n    \n    // Glow tubes.\n    lCol = vec3(0);\n    if((d2<.2 + hash31(p)*.1) && gOID>.5){\n       // Glow color. Reddish on the outside, and aqua on the inside.\n       vec3 gCol = sph>.0? glowCol1 : glowCol2;\n       \n       // Record the glow distance for this iteration. \"ln\" is just a\n       // tube running through the yellow inner rectangle in the direction\n       // of the normal.\n       lCol = gCol*clamp(-(ln.x +.01), 0., .5);\n    }\n    \n    \n    // Return the minimum distance.\n    return min(pln, min(d, d2));\n}\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    // Adding some jitter to the jump off point to alleviate banding.\n    float t = hash31(fract(ro/7.319 + iTime) + rd)*.1, d;\n    \n    glow = vec3(0);\n    \n    for(int i = ZERO; i<96; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        \n        // Accumulate the glow color.\n        glow += lCol;///(1. + t);\n        \n        // Note that the ray is capped (to .1). It's slower, but is necessary for the\n        // glow to work. I guess it could also help with overstepping the mark a bit.\n        t += min(d*.5, .1); //d*.5;// \n    }\n\n    return min(t, FAR);\n}\n\n\n// fb39ca4's inverse mix function.\n// Inverse mix takes a value between \"a\" and \"b\" and maps it to zero to one range.\nfloat invMix(float a, float b, float x) {\n\tx = (x - a)/(b - a);\n    return x*x; // Returning the square for darker tones... My tweak, and not correct.\n}\n\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k) {\n\t\n    // Use penumbra modifications.\n    #define PENUM\n \n\t// More would be nicer. More is always nicer, but not always affordable. :)\n    const int iter = 64; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.  \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.; // Initialize the shadow to 1., or no shadow.\n    float t = 0.;//hash31(fract(ro/7.319) + n)*.01; // Scene distance.\n    float maxD = max(length(rd), .0001); // Max light distance.\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= maxD; // Normalize.\n\t\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    // the lowest number to give a decent shadow is the best one to choose. \n\tfor (int i = ZERO; i<iter; i++) {\n \t \n\t\tfloat d = map(ro + rd*t); // Distance to the scene.\n        #ifdef PENUM\n        // This is a tweak I found in fb39ca4's Loxodrom example. It makes sense,\n        // but I'd need to investigate further. The shadows are more succint, but lighter.\n        // https://www.shadertoy.com/view/MsX3D2\n\t\tfloat penumbraDist = t/k;\n\t\tshade = min(shade, invMix(-penumbraDist, penumbraDist, d));\n\t\tt += min((d + penumbraDist)*.5, .2);\n        #else\n        // IQ's simpler calculation. If feel the shade itself is more constistant, but\n        // the shape isn't perfect. Emulating soft shadows isn't easy, if not impossible.\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*d/t)); // Thanks to IQ for this tidbit.\n        t += clamp(d, .005, .2);\n        #endif\n\t\t\n        // Early exit, and not exceeding the maximum light distance.\n        if(d<0. || t>maxD) break;\n\t}\n\t\n    #ifdef PENUM\n    // Another one of fb39ca4's additions. Penumbra stuff. :) \n    shade = max(shade, 0.)*2. - 1.;\n\treturn ((sqrt(1. - shade*shade)*shade + asin(shade)) + 3.14159265/2.)/3.14159265;\n    #else\n    return max(shade, 0.);\n    #endif\n    \n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 3., occ = 0.;\n    for( int i = ZERO; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        if(d>1e5) break; // Fake break.\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 norm(in vec3 p) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Pixel coordinates.\n    vec2 uv = (fragCoord  - iResolution.xy*.5)/iResolution.y;\n    \n    // Unit direction ray and ray origin.\n    vec3 rd = normalize(vec3(uv, .5));\n    vec3 ro = vec3(sin(iTime/2.)*.1, 0, -1.7);\n    \n    // The inner light. The shadow from this creates the Mobius shadow pattern.\n    // Where you place it depends on the shadow pattern you're after.\n    vec3 lp = vec3(0, 0, -.85);\n    // Outer light, just to light the spherical object a bit. Without this\n    // some things would be dark.\n    vec3 lp2 =  vec3(0, .5, -1.5);\n    \n    // Rotate the camera slightly.\n    rd.yz *= rot2(sin(iTime/2.)*.05);\n    \n    // Raymarch.\n    float t = trace(ro, rd);\n    \n    // Object ID. \n    float oID = gOID;\n    \n    // Saving the spherical texture coordinates, and 2D dashed line field.\n    vec2 sUV = gSUV;\n    float ln = gLn;\n    \n    // Scene color. Initialized to zero.\n    vec3 col = vec3(0);\n   \n    \n    if(t<FAR){\n        \n        // Surface hit point and normal.\n        vec3 p = ro + rd*t;\n        vec3 n = norm(ro);\n        \n        // Light distances.\n        float lDst = length(lp - p);\n        float lDst2 = length(lp2 - p);\n        \n        // Unit direction lights -- Inner and outer.\n        vec3 ld = (lp - p)/lDst;\n        vec3 ld2 = (lp2 - p)/lDst2;\n\n        float dif = max(dot(ld, n), 0.);\n        float dif2 = max(dot(lp2, n), 0.);\n        \n        \n        // Object color.\n        vec3 oCol;\n        \n        #ifndef DASHED\n        // If not dashed, tone the glow down a little.\n        glow *= .7;\n        #endif\n        \n        if(oID>0.){\n        \n            // Sphere object. \n            \n            if(oID == 1.){ \n            \n                // Inner face.\n            \n                // Inside and outside sphere colors.\n                if(length(p)<1.){ oCol = glowCol2 + glow/2.; }\n                else oCol = glowCol1 + glow/2.;\n            \n                // Dotted LED pattern on the face.\n                const float sc = 1./16.;\n                vec2 q = sUV + sc/2.;\n                if(mod(floor(q.y/sc), 2.)<.5) q.x += .5*sc;\n                vec2 iq = floor(q/sc) + .5;\n                q -= iq*sc;\n                \n                // Slight random colorization to each cell.\n                oCol = mix(oCol, oCol*vec3(2, .5, .5), hash21(iq + .2));\n                \n                // Cell edging and application.\n                float d = -(smax(abs(q.x), abs(q.y), .01) - .4*sc);\n                oCol = mix(oCol, oCol*.05, 1. - smoothstep(0., 2./iResolution.y, d)); \n            \n                // Dark edges on the frame using the saved 2D rectangle distance\n                // from the distance function.\n                oCol = mix(oCol, oCol*.1, 1. - smoothstep(0., .001, abs(ln + .01) - .0025));\n              \n            }\n            else {\n            \n                // Outer frame.\n                \n                // The purple outer frames with edging.\n                oCol = vec3(3, 1, .2).yzx/2.5 + glow;\n                oCol = mix(oCol, oCol*.1, 1. - smoothstep(0., .003, abs(ln - .0075) - .0025));\n                oCol = mix(oCol, oCol*.1, 1. - smoothstep(0., .003, abs(ln + .01) - .0025));\n                \n              \n            }\n            \n            // Texturing. Not necessary here.\n            //vec3 tx = tex3D(iChannel1, vec3(sUV + .5, length(p)), n);\n            //oCol *= tx*2. + .5;\n\n\n        }\n        else {\n        \n            // Backgournd plane.\n            \n            // Dark purple.\n            oCol = vec3(1, .2, 3)/3.5;\n            \n            // Apply a repeat hexagonal dot pattern.\n            vec2 sc = vec2(1./.8660254, 1)*1./7.;\n            vec2 q = p.xy;\n            if(mod(floor(q.y/sc.y), 2.)<.5) q.x -= .5*sc.x;\n            vec2 iq = floor(q/sc) + .5;\n            q -= iq*sc;\n            \n            // Subtle random coloring from cell to cell.\n            oCol = mix(oCol, vec3(1, .3, .05)/3.5, hash21(iq + .06)*.35);\n            \n            // The dot background edges and application.\n            float d = length(q) - .4*sc.y;\n            oCol = mix(oCol*.2, oCol, 1. - smoothstep(0., 1./sc.y/iResolution.y, d));\n            //oCol = mix(oCol, oCol*.5, 1. - smoothstep(0., 1./sc.y/iResolution.y, d + .15*sc.y));\n            \n            // Background texture. Not used.\n            //vec3 tx = texture(iChannel1, p.xy/8.).xyz; tx *= tx;\n            //oCol *= tx*3. + .2;\n           \n        \n        }\n        \n        \n\n        // Shadows and ambient self shadowing.\n        float sh = softShadow(p, lp, n, 128.);\n        float ao = calcAO(p, n);\n\n        // Inner and outer light attenuation.\n        float att = 1./(1. + lDst*lDst*.05);\n        float att2 = 1./(1. + lDst2*lDst2*.05);\n        \n        // Specular lighting.\n\t    float spe = pow(max(dot(reflect(ld, n), rd ), 0.), 16.); \n\t    float spe2 = pow(max(dot(reflect(ld2, n), rd ), 0.), 16.);\n        \n        // Specular reflection.\n        vec3 hv = normalize(-rd + ld2); // Half vector.\n        vec3 ref = reflect(rd, n); // Surface reflection.\n        vec3 refTx = texture(iChannel0, ref).xyz; refTx *= refTx;\n        refTx = (oCol*1.5 + .66)*refTx;//smoothstep(.2, .5, refTx);\n        float spRef = pow(max(dot(hv, n), 0.), 8.); // Specular reflection.\n        float rf = oID == 0.? oCol.z*.5 : oID == 1.? oCol.x : oCol.z;\n        \n        // Adding the specular reflection and glow for the inner light.\n        oCol += spRef*refTx*rf*.25;\n        oCol += glow/1.5;         \n\n        // Combining all terms for the inner light.\n        col = oCol*(dif*sh + vec3(1, .5, .8)*spe*sh + .2)*att*ao;\n        \n        // Placing another light on the outside of the sphere. Technically, there should\n        // be another shadow calculation, but it'd doesn't have much effect, so we're\n        // saving the extra calculations.\n        oCol += spRef*refTx*rf*.25; // Add more reflection to the outside.\n        col += oCol*((dif2*.15 + .05 + glow*2.) + vec3(1, .5, .8)*spe2*2.)*att2*ao;\n        \n       \n    \n    }\n    \n    fragColor = vec4(sqrt(max(col, 0.)), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}