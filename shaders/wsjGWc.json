{
    "Shader": {
        "info": {
            "date": "1550184352",
            "description": "Reference from IQ's knowledge of sdf and procedure techniques",
            "flags": 0,
            "hasliked": 0,
            "id": "wsjGWc",
            "likes": 6,
            "name": "Chinese Style Pavilion",
            "published": 3,
            "tags": [
                "3d",
                "raymarch"
            ],
            "usePreview": 0,
            "username": "whaoran",
            "viewed": 466
        },
        "renderpass": [
            {
                "code": "float EPSILON = 1e-6;\nfloat STEPSIZE = 0.5;\nfloat MIN_MARCH_LEN = 1e-2;\nfloat MAX_MARCH_LEN = 1e2;\nint   MAX_MARCH_ITER = 64;\n\nvec3 lightVec = normalize(vec3(-2, 0.7, 0.0));\nvec3 lightCol = vec3(1.0, 1.0, 1.15);\nvec3 skyLitCol = vec3(0.16, 0.20, 0.28) / 2.0;\nvec3 indLitCol = vec3(0.3, 0.28, 0.2) / 2.0;\nvec3 lanternPos = vec3(0.0, 9.0, 0.0);\nvec3 lanternCol = vec3(1.0, 0.0, 0.0);\nfloat ambientLit = 0.05;\nvec3 ambientCol = vec3(1);\n\n// Noise\n///////////////////////////////////////////////////////\nvec3 c_seed = vec3(0);\nfloat PI = 3.14159265;\nfloat PI_2 = 6.2831853;\nfloat random1( vec2 p , vec2 seed) { return fract(sin(dot(p + seed, vec2(127.1, 311.7))) * 43758.5453); }\nfloat random1( vec3 p , vec3 seed) { return fract(sin(dot(p + seed, vec3(987.654, 123.456, 531.975))) * 85734.3545); }\nvec2 random2( vec2 p , vec2 seed) { return fract(sin(vec2(dot(p + seed, vec2(311.7, 127.1)), dot(p + seed, vec2(269.5, 183.3)))) * 85734.3545); }\n\nfloat falloff(float t) {\n  t = t * t * t * (t * (t * 6. - 15.) + 10.);\n  return t;\n}\n\nvec2 randGrad(vec2 p, vec2 seed) {\n  float randDeg = random1(p, seed) * PI_2;\n  return vec2(cos(randDeg), sin(randDeg));\n}\n\nfloat PerlinNoise(vec2 p, float s) {\n    p /= s;\n    vec2 pCell = floor(p);\n    p -= pCell;\n    float dotGrad00 = dot(randGrad(pCell + vec2(0., 0.), c_seed.xz), p - vec2(0., 0.));\n    float dotGrad01 = dot(randGrad(pCell + vec2(0., 1.), c_seed.xz), p - vec2(0., 1.));\n    float dotGrad10 = dot(randGrad(pCell + vec2(1., 0.), c_seed.xz), p - vec2(1., 0.));\n    float dotGrad11 = dot(randGrad(pCell + vec2(1., 1.), c_seed.xz), p - vec2(1., 1.));\n\n    return mix(mix(dotGrad00, dotGrad10, falloff(p.x)), mix(dotGrad01, dotGrad11, falloff(p.x)), falloff(p.y)) * .5 + .5;\n}\n\nfloat FBMPerlin(vec2 p, float minCell, int maxIter) {\n  float sum = 0.;\n  float noise = 0.;\n  for (int i = 0; i < maxIter; i++) {\n      noise += PerlinNoise(p, minCell * pow(2., float(i))) / pow(2., float(maxIter - i));\n      sum += 1. / pow(2., float(maxIter - i));\n  }\n  noise /= sum;\n  return noise;\n}\n\nvec2 sampleInCell(vec2 p) {\n  return random2(p, c_seed.xz) + p;\n}\n\nfloat worleyNoise(vec2 p, float s) {\n    // Which cell p belongs to\n    p /= s;\n    vec2 pCell = floor(p);\n\n    float min_dist = 1.;\n    for (int i = -1; i <= 1 ; i++) {\n        for (int j = -1; j <= 1; j++) {\n          vec2 sampleNoise = sampleInCell(pCell + vec2(i, j));\n          min_dist = min(min_dist, distance(sampleNoise, p));\n        }\n    }\n    float noise = clamp(min_dist, 0., 1.);\n    return noise;\n}\n\nfloat worleyNoiseOutline(vec2 p, float s) {\n    // Which cell p belongs to\n    p /= s;\n    vec2 pCell = floor(p);\n\n    float min_dist = 1.;\n    float sec_dist = 1.;\n    for (int i = -1; i <= 1 ; i++) {\n        for (int j = -1; j <= 1; j++) {\n          vec2 sampleNoise = sampleInCell(pCell + vec2(i, j));\n          float dist = distance(sampleNoise, p);\n          if (dist < min_dist) { sec_dist = min_dist; min_dist = dist; }\n          else if (dist < sec_dist) { sec_dist = dist; }\n        }\n    }\n    float noise = clamp(sec_dist - min_dist, 0., 1.);\n    return noise;\n}\n\n// Transform Function\n///////////////////////////////////////////////////////\nvec3 rotX(vec3 p, float x) {\n  x = radians(x);\n  float c = cos(x);\n  float s = sin(x);\n  return vec3(p.x, c*p.y-s*p.z, s*p.y+c*p.z);\n}\n\nvec3 rotY(vec3 p, float y) {\n  y = radians(y);\n  float c = cos(y);\n  float s = sin(y);\n  return vec3(c*p.x+s*p.z, p.y, -s*p.x+c*p.z);\n}\n\nvec3 rotZ(vec3 p, float z) {\n  z = radians(z);\n  float c = cos(z);\n  float s = sin(z);\n  return vec3(c*p.x-s*p.y, s*p.x+c*p.y, p.z);\n}\n\n// SDF\n///////////////////////////////////////////////////////\nfloat opExtrussion(vec3 p, float sdf, float h )\n{\n  vec2 w = vec2( sdf, abs(p.z) - h );\n  return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nvec3 opCheapBendX(vec3 p, float w)\n{\n  float c = cos(w*p.y);\n  float s = sin(w*p.y);\n  mat2  m = mat2(c, s, -s, c);\n  return vec3(p.x, m * p.yz);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTriangleIsosceles( vec2 p, vec2 q )\n{\n    p.x = abs(p.x);\n    \n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat dot2( vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  \n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdRoundCone(vec3 p, float h, float r1, float r2)\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n  \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n      \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x), p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// UV Map\n///////////////////////////////////////////////////////\nvec3 uvCylinder(vec3 p, vec2 h) {\n  if (p.y > -h.y && p.y < h.y) {\n    return vec3(degrees(atan(p.z, p.x)) / 180.0, p.y / h.y, 0.5);\n  }\n  else {\n    return vec3(p.x / h.x, p.z / h.x, 0.0);\n  }\n}\n\nvec3 uvHexPrism( vec3 p, vec2 h ) {\n  if (p.z > -h.y && p.z < h.y) {\n    float a = degrees(atan(p.y, p.x));\n    vec2 _p = rotZ(vec3(p.xy, 0.0), -floor((a+120.0)/60.0) * 60.0).xy;\n    return vec3(1.732051 * _p.x / _p.y, p.z / h.y, 0.5);\n  }\n  else {\n    return vec3(p.x/h.x, p.y/h.x, 0.0);\n  }\n}\n\n// Map Function\n////////////////////////////////////////////////////////\nfloat mapCeiling(vec3 pos, out vec3 uvflag) {\n  float r = 0.3;\n  float l = 4.5;\n  float r0 = 0.25;\n  float l0 = 4.0;\n  float d = MAX_MARCH_LEN;\n  float halfWidth = 4.0;\n  float angle = degrees(asin(clamp(halfWidth / l * 0.866025, -1.0, 1.0)));\n\n  vec3 po = pos;\n  vec3 pCol;\n  int flag = -1;\n\n  float a = degrees(atan(po.z, po.x));\n  vec3 p1 = rotY(po, floor((a+120.0)/60.0) * 60.0);\n  p1 = rotX(p1, -angle) + vec3(0.0, l, 0.0);\n  p1 = rotZ(p1 + vec3(0.0, -l, r), 180.0) - vec3(0.0, 0.0, r + 0.2);\n  float d1 = opExtrussion(p1, sdTriangleIsosceles(p1.xy, vec2(halfWidth, l * 2.0)), 0.2);\n  float dis = abs(cos(p1.x * 5.0)) * 0.1;\n  if (p1.z < 0.0) { d1 = d1 - dis; }\n  if (d > d1) { d = d1; flag = 1; }\n  \n  vec3 p2 = rotY(po, floor((a+90.0)/60.0) * 60.0);\n  float len = sqrt(halfWidth * halfWidth * 0.25 + l * l);\n  vec3 p3 = rotX(rotY(p2, 30.0), -angle * 1.1) + vec3(0.0, len * 1.9, 0.0);\n  float d3 = sdRoundCone(p3, len * 1.9, 0.8 * r, r);\n  d3 = smin(d3, sdRoundCone(opCheapBendX(rotX(p3 + vec3(0.0, r, 0.0), -30.0), 0.5) + vec3(0.0, 2.0, 0.0), 2.0, 0.0, 0.8 * r), 15.0);\n  if (d > d3) { d = d3; flag = 2; }\n  \n  vec3 p4 = rotY(p2 + vec3(0.0, 9.0, 0.0), 30.0) + vec3(0.0, 0.0, 6.0);\n  float d4 = sdCylinder(p4, vec2(r0, l0));\n  if (d > d4) { d=d4; flag=3; }\n\n  switch(flag) {\n  case -1: break;\n  case 0: break;\n  case 1: uvflag = vec3(pos.x, pos.y, 1.0); break;\n  case 2: uvflag = vec3(pos.x, pos.y, 2.0); break;\n  case 3: uvflag = uvCylinder(p4, vec2(r, l)) + vec3(0.0, 0.0, 3.0); break;\n  }\n  return d;\n}\n\nfloat mapBase(vec3 pos, out vec3 uvflag) {\n  int flag = -1;\n  float d = MAX_MARCH_LEN;\n\n  vec3 p0 = rotX(pos, 90.0);\n  float r0 = 6.0;\n  float l0 = 1.0;\n  float d0 = sdHexPrism(p0, vec2(r0, l0));\n  if (d > d0) { d=d0; flag=0; }\n\n  switch(flag) {\n  case -1: break;\n  case 0: uvflag = uvHexPrism(p0, vec2(r0, l0)) + vec3(0.0, 0.0, 4.0);  break;\n  }\n  return d;\n}\n\nfloat mapWater(vec3 pos, out vec3 uvflag) {\n  vec2 q = vec2(FBMPerlin(pos.xz + vec2(iTime * 0.5,0.), 0.5, 4) + iTime * 0.1,\n                FBMPerlin(pos.xz + vec2(20., 5.), 0.5, 4));\n  float n = pow(FBMPerlin(pos.xz + 5.0 * q, 0.5, 4), 2.0);\n  uvflag = vec3(pos.x, pos.z, 5.0 + n);\n  return pos.y - n * 0.7;\n}\n\nfloat map(vec3 pos, bool lightVisible, out vec3 uvflag)\n{\n  vec3 p = pos;\n  vec3 uv;\n  float d = MAX_MARCH_LEN;\n  float d0 = mapCeiling(p - vec3(0.0, 13.0, 0.0), uv);\n  float ds = sdCylinder(p - vec3(0.0, 17.0, 0.0), vec2(10.0, 7.0));\n  d0 = opSubtraction(ds, d0);\n  if(d > d0) { d=d0; uvflag=uv; }\n  float d1 = opIntersection(ds, mapCeiling((p - vec3(0.0, 15.5, 0.0)) / 0.7, uv) * 0.7);\n  if(d > d1) { d=d1; uvflag=uv; }\n  float d2 = mapBase(p, uv);\n  if(d > d2) { d=d2; uvflag=uv; }\n  float d3 = mapWater(pos + vec3(0.0, 1.0, 0.0), uv);\n  if(d > d3) { d=d3; uvflag=uv; }\n  if (lightVisible) {\n    float d4 = sdSphere(pos - lanternPos, 1.0);\n    if(d > d4) { d=d4; uvflag=vec3(0.0, 0.0, 7.0); }\n  }\n  return d;\n}\n\n// Normal Calculation\n// Reference from https://iquilezles.org/articles/normalsSDF\n////////////////////////////////////////////////////////\n#define ZERO (min(iTime,0.0))\nvec3 calcNormal(vec3 pos, vec3 uv) {\n    const float h = 0.0001;\n    vec3 n = vec3(0.0);\n    for( int i=int(ZERO); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*h, false, uv);\n    }\n    return normalize(n);\n}\n\n\n// Ray Marching Funtion\n// Reference from https://www.shadertoy.com/view/4lyfzw\n////////////////////////////////////////////////////////\nbool rayMarch(in vec3 ori, in vec3 dir, out vec3 uvflag, out vec3 p, out float d) {\n  float t = 0.0;\n  for (int i = 0; i < MAX_MARCH_ITER; i++) {\n    p = ori + t * dir;\n    d = map(p, true, uvflag);\n    if (t > MAX_MARCH_LEN || d < MIN_MARCH_LEN * t) {\n      break;\n    }\n    t += d * STEPSIZE;\n  }\n  return t < MAX_MARCH_LEN;\n}\n\n// Visual Effect\n// Reference from https://iquilezles.org/articles/rmshadows\n////////////////////////////////////////////////////////\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n  float res = 1.0;\n  vec3 uv;\n  for( float t=mint; t < maxt; )\n  {\n    float h = map(ro + rd*t, false, uv);\n    if( h < MIN_MARCH_LEN * t )\n      return 0.0;\n    res = min( res, k*h/t );\n    t += h * STEPSIZE;\n  }\n  return res;\n}\n\n// Render\n///////////////////////////////////////////////////////\nvec3 render(vec3 pos, vec3 uvflag, out vec3 norm) {\n  vec3 color;\n  if (uvflag.z < 0.0 + EPSILON) {\n      return vec3(0.0);\n  }\n  else if(uvflag.z < 1.0 + EPSILON) {\n    color = vec3(69.0, 88.0, 82.0) / 255.0;\n  }\n  else if(uvflag.z < 2.0 + EPSILON) {\n    color = vec3(98.0, 113.0, 102.0) / 255.0;\n  }\n  else if(uvflag.z < 3.5 + EPSILON) {\n    color = vec3(174.0, 14.0, 14.0) / 255.0;\n  }\n  else if(uvflag.z < 4.0 + EPSILON) {\n    vec2 q = vec2(FBMPerlin(uvflag.xy + vec2(0.,0.), 0.05, 4),\n                  FBMPerlin(uvflag.xy + vec2(2.,5.), 0.05, 4));\n    float n = FBMPerlin(uvflag.xy + 5.0 * q, 0.05, 4);\n    vec3 c0 = vec3(200.0, 200.0, 216.0) / 300.0;\n    vec3 c1 = vec3(210.0, 202.0, 191.0) / 330.0;\n    vec3 c2 = vec3(230.0, 238.0, 250.0) / 300.0;\n    vec3 col;\n    if (n < 0.3) { col = mix(c0, c1, n / 0.3); }\n    else if (n < 0.7) { col = mix(c1, c2, (n - 0.3) / 0.4); }\n    else { col = mix( c2, c0, (n - 0.7) / 0.3); }\n    color = col;\n  }\n  else if(uvflag.z < 4.5 + EPSILON) {\n    vec3 c0 = vec3(161.0, 164.0, 154.0) / 550.0;\n    vec3 c1 = vec3(200.0, 200.0, 216.0) / 300.0;\n    vec3 col = c1;\n    if (abs(uvflag.y) < 0.8) {\n      float n = smoothstep(0.0, 1.0, worleyNoiseOutline(uvflag.xy * vec2(3.0, 1.0), 0.4)) * 0.5 + 0.5;\n      col = mix(c0, c1, n);\n      if (abs(uvflag.y) > 0.5) {\n        col *= mix(1.0, 0.7, (abs(uvflag.y) - 0.5) / 0.3);\n      }\n    }\n    color = col;\n  }\n  else if(uvflag.z < 6.0 + EPSILON) {\n    color = mix(vec3(3., 7., 15.) / 255., vec3(12., 19., 36.) / 255., uvflag.z - 5.0);\n  }\n  else if(uvflag.z < 7.0 + EPSILON) {\n    color = lanternCol;\n    return color;\n  }\n\n  vec3 uv;\n  norm = calcNormal(pos, uv);\n  // ambient light\n  vec3 assembleCol = ambientLit * ambientCol;\n\n  // sun light\n  float sunTerm = clamp(dot(norm, lightVec), 0.0, 1.0);\n  vec3 shadowRay = lightVec;\n  float shadowTerm = softshadow(pos, shadowRay, MIN_MARCH_LEN + EPSILON, MAX_MARCH_LEN, 16.0 );\n  assembleCol += pow(vec3(shadowTerm), vec3(1.5, 1.2, 1.0)) * sunTerm * lightCol;\n\n  // sky light\n  float skyTerm = clamp(0.5 + 0.5 * norm.y, 0.0, 1.0);\n  assembleCol += skyTerm * skyLitCol;\n\n  // indirect light\n  float indTerm = clamp(dot(norm, lightVec * vec3(-1.0, 0.0, -1.0)), 0.0, 1.0);\n  assembleCol += indTerm * indLitCol;\n\n  // lantern\n  vec3 lanternRay = lanternPos - pos;\n  float le = length(lanternRay);\n  float lanternTerm = pow(1.0 / le, 2.0) * smoothstep(-0.8, 1.0, dot(norm, normalize(lanternRay)));\n  lanternRay = normalize(lanternRay);\n  float lanternShadowTerm = softshadow(pos, lanternRay, MIN_MARCH_LEN + EPSILON, le - EPSILON, 32.0 );\n  assembleCol += lanternShadowTerm * clamp(lanternTerm * 200.0, 0.0, 1.0) * lanternCol;\n\n  return assembleCol * color;\n}\n\n// Ray Casting Funtion\n///////////////////////////////////////////////////////\nvec3 rayCast(vec2 p, vec3 eye, vec3 ref, vec3 up) {\n  vec3 focusVector = ref - eye;\n  vec3 Right = normalize(cross(focusVector, up)) * iResolution.x / iResolution.y;\n  float len = length(focusVector) * 0.7;\n  return normalize(focusVector + len * p.x * Right + len * p.y * up);\n}\n\n// Schlick's Approximation for Fresnel Reflection\n///////////////////////////////////////////////////////\nfloat fresnelReflect(float n1, float n2, float cosTheta) {\n  float R0 = pow((n1 - n2) / (n1 + n2), 2.0);\n  return R0 + (1.0 - R0) * pow(1.0 - cosTheta, 2.5); // 5.0 for origin equation\n}\n\n// Sky Ramp\n///////////////////////////////////////////////////////\nvec3 skyRamp(vec3 dir) {\n  float cosUp = dir.y;\n  vec3 col1 = vec3(49., 58., 83.)/255.;\n  vec3 col2 = vec3(20., 34., 77.)/255.;\n  vec3 col3 = vec3(12., 19., 36.)/255.;\n  vec3 col4 = vec3(3., 7., 15.)/255.;\n\n  vec3 col;\n  if (cosUp < 0.0) {\n    col = col1;\n  }\n  else if (cosUp < 0.2) {\n    col = mix(col1, col2, cosUp / 0.2);\n  }\n  else if (cosUp < 0.5) {\n    col = mix(col2, col3, (cosUp - 0.2)/0.3);\n  }\n  else {\n    col = mix(col3, col4, (cosUp - 0.5)/0.5);\n  }\n\n  float dotMoon = dot(dir, lightVec);\n  if (dotMoon > 0.988) {\n    col = vec3(1);\n  }\n  else {\n    col = mix(col, vec3(1), smoothstep(0.97, 0.995, dotMoon));\n  }\n\n  return col;\n}\n\n// fog\n///////////////////////////////////////////////////////\nvec3 applyFog(vec3 pos, vec3 rgb, float distance )\n{\n    float fogAmount = 1.0 - exp( -distance * 3.0);\n    vec3  fogColor  = vec3(53., 68., 90.)/255.;\n    return mix(rgb, fogColor, fogAmount * (1.0 - smoothstep(0.0, 35.0, pos.y)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 0.1;\n    float r = 14.0 + 10.0 * smoothstep(-0.5, 0.5, sin(speed * iTime));\n    vec3 eye = vec3(r * sin(speed * iTime), 4.8, r * cos(speed * iTime));\n  \tvec3 ref = vec3(0.0, 2.8, 0.0);\n  \tvec3 forward = normalize(ref - eye);\n  \tvec3 up = normalize(vec3(0.0, 1.0, 0.0)-forward.y * forward);\n\n  \tvec3 dir = rayCast(fragCoord/iResolution.xy * 2.0 - 1.0, eye, ref, up);\n  \tvec3 skyCol = skyRamp(dir);\n  \tvec3 uvflag;\n  \tvec3 pos;\n \tvec3 col;\n  \tvec3 norm;\n  \tfloat d;\n  \tif(rayMarch(eye, dir, uvflag, pos, d)) {\n    \tcol = render(pos, uvflag, norm);\n    \tif (uvflag.z > 4.5 + EPSILON && uvflag.z < 6.0 + EPSILON) {\n      \tdir = -2.0 * norm * dot(norm, dir) + dir;\n      \tvec3 ori = pos;\n      \tfloat R = fresnelReflect(1.0, 1.33, dot(norm, dir));\n      \tfloat dd;\n      \tif (rayMarch(ori, dir, uvflag, pos, dd)) {\n        \tcol = mix(col, render(pos, uvflag, norm), R);\n      \t}\n      \telse {\n        \tcol = mix(col, skyRamp(dir), R);\n      \t}\n    \t}\n  \t}\n  \telse {\n    \td = MAX_MARCH_LEN;\n    \tcol = skyCol;\n  \t}\n  \tcol = applyFog(eye + d * dir, col, d);\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}