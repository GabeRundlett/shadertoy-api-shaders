{
    "Shader": {
        "info": {
            "date": "1686582546",
            "description": "Knitted pattern with raymarching. The background was done with gyroid",
            "flags": 0,
            "hasliked": 0,
            "id": "mdfyz8",
            "likes": 22,
            "name": "Knitted Pattern raymarch",
            "published": 3,
            "tags": [
                "raymarch",
                "uv"
            ],
            "usePreview": 0,
            "username": "henrmota",
            "viewed": 526
        },
        "renderpass": [
            {
                "code": "float random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nmat2 rot(float angle) {\n    float c = cos(angle), s = sin(angle);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat pingpong(float x, float a, float p) {\n    return a/p * (p - abs(mod(x,(2.*p)) - p) );\n}\n\nfloat knittedPattern(vec2 uv) {\n     vec2 scale = vec2(1.5, 1.);\n    vec2 scaled = uv * scale;\n\n    scaled.y += pingpong(scaled.x, 1., 1.);\n    vec2 guv = fract(scaled) - 0.5;\n    \n    float d = smoothstep(1., 0., length(guv));\n    d -= .3 * smoothstep(.2, 0.1, abs(cos((guv.x - guv.y) * 40. + cos((uv.x + uv.y) * 100.)) * 0.5));\n    d = max(0., d);\n    \n    return d;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat arm(vec3 p, vec3 a, vec3 b, float rotation) {\n    \n    p.x = abs(p.x);\n    p.xy*=rot(rotation);\n   \n    float radius = mix(.15, 0.3, smoothstep(a.x, b.x, abs(p.x)));\n    radius *= mix(.9, 1., smoothstep(0., .3, abs(p.y - 0.25)));\n    radius *= mix(1., .7, smoothstep(2., 0.15, p.y));\n    radius += 0.015 * knittedPattern(vec2(atan(p.z, p.y), p.x) * 8.) - 0.05;\n    p.x = abs(p.x);\n   \n   \n    return sdCapsule(p, a, b, radius);\n}\n\nvec2 map(vec3 p) {\n    \n    p.xz *= rot(0.7 * iTime);\n    \n    //head\n    \n    float radius = 1.;\n    radius *= mix(.9, 1., smoothstep(0., .3, abs(p.y - 0.25)));\n    radius *= mix(1., .7, smoothstep(2., 0.15, p.y));\n    radius += 0.025 * knittedPattern(vec2(atan(p.z, p.x), p.y) * 8.) - 0.05;\n    float b = sdCapsule(p, vec3(0., 1., 0), vec3(0., -1., 0.), radius);\n   \n    float a = arm(p, vec3(0.5, 0., 0.1), vec3(1.5, 0.,0.2), 0.3);\n \n\n    float d = smin(b, a, 0.15); \n    \n    float l = arm(p, vec3(.5, -1., 0.), vec3(1.5, -1.5, 0.), 0.5);\n    \n    d = smin(d, l, 0.2); \n    \n    float bodyId = 1.;\n    \n    //eyes\n    vec3 q = p;\n    q.x = abs(q.x);\n    float eyeD = length(q-vec3(0.28, 1., .73)) - 0.2;\n    \n    \n    d = smin(d, eyeD + 0.1, 0.3);\n    d = min(d, eyeD);\n    if (d == eyeD) bodyId = 2.;\n    \n    \n    //nose\n    q = p;\n    q-=vec3(0., 0.6, .73);\n    q.y -= abs(q.x) * 2.;\n    float noseD = (length(q) - 0.2) * 0.4;\n    \n    d = smin(d, noseD + 0.1, 0.3);\n    d = min(d, noseD);\n    if (d == noseD) bodyId = 3.;\n    \n    return vec2(d, bodyId);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    float t = 0.;\n    float id = -1.;\n    for(int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        vec2 d = map(p);\n        t += d.x;\n        id = d.y; \n        if (d.x < 0.01 || t > 100.) break;\n    }\n    \n    return vec2(t, id);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    \n    \n    return normalize(vec3(\n        map(p + e.xyy).x - map(p - e.xyy).x,\n        map(p + e.yxy).x - map(p - e.yxy).x,\n        map(p + e.yyx).x - map(p - e.yyx).x\n    ));\n}\n\nvec3 getLight(vec3 p, vec3 n, vec3 rd, float specularFactor) {\n    vec3 light = vec3(1., 1., 1.) * 5.;\n    vec3 sky = vec3(0.1, 0.2, 0.8);\n    vec3 ground = vec3(0.4, 0.2, 0.4);\n    vec3 hemiMix = mix(ground, sky, smoothstep(-.5, .5, n.y)); \n    \n    vec3 lightDir = normalize(vec3(.5 , .5, .5));\n    \n    float diffusePower = max(0., dot(n, lightDir));\n    vec3 diffuse = diffusePower * light * 0.7;\n    \n    vec3 r = normalize(reflect(-lightDir, n));\n    float specularPower = pow(max(0., dot(rd, r)), 16.);\n    vec3 specular = specularPower * light * specularFactor;\n    \n    float fresnel = pow(1. - max(0., dot(rd, n)), 10.);\n    return 0.5 * fresnel * light + diffuse + specular ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(0., 0., 5.);\n    vec3 rd = normalize(vec3(uv, -1.));\n    vec2 di = rayMarch(ro, rd);\n    float d = di.x;\n    vec3 p = ro + d*rd; \n    if (d < 100.) {\n   \n        vec3 n = getNormal(p);\n        vec3 q = p;\n        q.xz *= rot(0.7 * iTime);\n        if(di.y == 1.) {\n            \n            \n            col += vec3(.3, 0.2, 0.2) * getLight(p, n, normalize(ro - p), 0.);\n            col -=  0.3 * noise(q.xy * 10.) * noise(q.xy * 20.);\n        }\n        \n         if(di.y == 2.) {\n         \n             col += fbm(q.xz * 50. - iTime) * vec3(0.1, 0.1, 0.1) * getLight(p, n, normalize(ro - p), 3.);\n            \n         }\n         \n          if(di.y == 3.) {\n         \n             col += vec3(.3, 0.05, 0.05) * getLight(p, n, normalize(ro - p), 3.);\n         }\n    } else {\n        p= fract(rd * 10.) - 0.5;\n        p.xy += iTime * 0.1;\n        p.z += 0.2 * iTime;\n        \n        vec3 color = vec3(\n             dot(cos(p * 10.), sin(p.zxy * 15.)) * 0.5 + 0.5\n        );\n        \n        \n        col = (0.1/abs(color) - .2);\n        col *= vec3(1., 1., 1.) * 0.1 * rd * rd;\n        col *= 0.5;\n    }\n    \n    col = pow(col, vec3(1./2.2));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}