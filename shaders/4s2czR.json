{
    "Shader": {
        "info": {
            "date": "1490640567",
            "description": "Even more books (use the mouse to look around, click in lower-right corner for b/w image)",
            "flags": 0,
            "hasliked": 0,
            "id": "4s2czR",
            "likes": 17,
            "name": "Ultimate Library",
            "published": 3,
            "tags": [
                "raymarch",
                "hexagon",
                "books"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 817
        },
        "renderpass": [
            {
                "code": "// \"Ultimate Library\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec2 HexCellId (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec3 RgbToHsv (vec3 c);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\n\nconst float pi = 3.14159;\nconst float sqrt3 = 1.73205;\n\nvec3 ltDir, lbPos;\nvec2 idCell, szGr, bsa1, bsa2;\nfloat dstFar, tCur, rdRm, htRm, wlThk, rdHol, spShf, htShf;\nint idObj;\nbool bwImg;\nconst int idRm = 1, idRal = 2, idBks = 3, idShlf = 4, idLt = 5, idBl = 6;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float d, dMin, r, a, dWid, wdShf;\n  dMin = dstFar;\n  dWid = 0.15 * szGr.x;\n  wdShf = 0.06 * rdRm;\n  q = p;\n  idCell = HexCellId (q.xz / szGr.x);\n  q.xz -= vec2 (2. * idCell.x + idCell.y, sqrt3 * idCell.y) * szGr.x;\n  r = length (q.xz);\n  a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  q.y = mod (q.y + szGr.y, 2. * szGr.y) - szGr.y;\n  qq = q;\n  q.xz = Rot2D (q.xz, 2. * pi * ((floor (6. * a + 0.5)) / 6.));\n  d = max (PrCylAnDf (q.xzy, rdRm, wlThk, htRm), dWid - abs (q.z));\n  d = min (d, max (htRm - abs (q.y), rdHol - 0.05 - r));\n  if (d < dMin) {dMin = d;  idObj = idRm; }\n  q = qq;  q.y -= - htRm + 0.6 * htRm;\n  d = PrTorusDf (q.xzy, 0.06, rdHol);\n  q = qq;  q.y -= - htRm + 0.3 * htRm;\n  q.y = abs (abs (q.y) - 0.1 * htRm);\n  d = min (d, PrTorusDf (q.xzy, 0.04, rdHol));\n  q = qq;  q.y -= - htRm + 0.3 * htRm;\n  q.xz = Rot2D (q.xz, 2. * pi * ((floor (18. * a) + 0.5) / 18.));\n  q.x += rdHol;\n  d = min (d, PrCylDf (q.xzy, 0.04, 0.3 * htRm));\n  if (d < dMin) { dMin = d;  idObj = idRal; }\n  q = qq;\n  q.xz = Rot2D (q.xz, 2. * pi * ((floor (6. * a) + 0.5) / 6.));\n  q.z = abs (q.z);\n  d = max (abs (r - rdRm + wlThk + 1. * wdShf) - 0.5 * wdShf, dot (q.xz, bsa2));\n  d = max (d, abs (q.y) - htRm);\n  if (d < dMin) {dMin = d;  idObj = idBks; }\n  d = max (abs (r - rdRm + wlThk + wdShf) - wdShf, dot (q.xz, bsa1));\n  d = max (d, min (abs (mod (q.y + 0.5 * spShf, spShf) - 0.5 * spShf) - htShf,\n     - dot (q.xz, bsa2)));\n  d = max (d, abs (q.y) - htRm);\n  if (d < dMin) {dMin = d;  idObj = idShlf; }\n  q.z = abs (q.z);\n  q -= vec3 (- 0.7 * rdRm, htRm - 0.04, 0.8);\n  d = PrCylDf (q.xzy, 0.3, 0.03);\n  if (d < dMin) {dMin = d;  idObj = idLt; }\n  d = PrSphDf (p - lbPos, 0.4);\n  if (d < dMin) { dMin = d;  idObj = idBl; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  float f;\n  p *= 4.;\n  f = dot (vec3 (Fbm2 (p.zy * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.xy * vec2 (1., 0.1))), abs (n));\n  return 0.8 * mix (vec3 (0.9, 0.5, 0.3), vec3 (0.55, 0.35, 0.1), f);\n}\n\nfloat GlowCol (vec3 ro, vec3 rd, float dstHit)\n{\n  vec3 ld;\n  float d, wGlow;\n  wGlow = 0.;\n  ld = lbPos - ro;\n  d = length (ld);\n  ld /= d;\n  if (d < dstHit) wGlow += pow (max (dot (rd, ld), 0.), 1024.);\n  return clamp (0.5 * wGlow, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 roo, col, vn, q, ld, bgCol;\n  vec2 gbRm, gbBk, g, bt;\n  float dstObj, r, a, bh, s, cRm, idFlr, lbCol, fr, spec;\n  bool isLit;\n  wlThk = 0.04 * szGr.x;\n  rdRm = szGr.x - 0.7 * wlThk;\n  rdHol = 0.5 * rdRm;\n  htRm = 0.93 * szGr.y;\n  spShf = htRm / 3.;\n  htShf = 0.05 * spShf;\n  bsa1 = vec2 (sin (1.2 * 2. * pi / 24.), cos (1.2 * 2. * pi / 24.));\n  bsa2 = vec2 (sin (1.16 * 2. * pi / 24.), cos (1.16 * 2. * pi / 24.));\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  isLit = true;\n  bgCol = (abs (rd.y) < 0.5) ? 0.5 * vec3 (0.7, 0.5, 0.) : ((rd.y > 0.) ?\n     vec3 (0.5, 0.5, 0.55) : vec3 (0., 0., 0.2));\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    q = ro;\n    q.xz -= vec2 (2. * idCell.x + idCell.y, sqrt3 * idCell.y) * szGr.x;\n    r = length (q.xz);\n    a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n    idFlr = floor (q.y / (2. * szGr.y) + 0.5);\n    gbRm = idCell + idFlr;\n    cRm = Noisefv2 (gbRm * vec2 (17., 11.));\n    q.y = mod (q.y + szGr.y, 2. * szGr.y) - szGr.y;\n    vn = ObjNf (ro);\n    spec = 0.1;\n    if (idObj == idRm) {\n      if (r < rdHol + 0.05) col = vec3 (0.6, 0.6, 0.7);\n      else if (vn.y < -0.99 && r < 0.99 * rdRm) col = vec3 (1.);\n      else if (r >= 0.99 * rdRm && vn.y <= 0.99) {\n        col = HsvToRgb (vec3 (Noisefv2 (vec2 (33. * idFlr + 1., 1.)), 0.4, 0.8));\n        if (abs (vn.y) < 0.01) col *= 0.6 + 0.3 * q.y / htRm;\n        isLit = false;\n      } else if (r > 0.99 * (rdRm - wlThk) ||\n          r >= 0.99 * rdRm && vn.y > 0.99) col = vec3 (0.7, 0.5, 0.);\n      else {\n        fr = (r - rdHol) / (rdRm - rdHol);\n        col = mix (vec3 (0.7), HsvToRgb (vec3 (cRm, 1., 1.)),\n           SmoothBump (0.1, 0.3, 0.05, mod (7. * fr, 1.))) * \n           (0.5 + 0.5 * smoothstep (0.1, 0.3, abs (0.5 - mod (6. * a - 0.5, 1.))) *\n           smoothstep (0.3, 0.6, fr));\n        g = vec2 (5. * (mod (6. * mod (a + 1./12., 1.), 1.) - 0.5), r - 0.835 * rdRm);\n        if (length (max (abs (g) - vec2 (0.5, 0.15), 0.)) < 0.1) {\n          col = vec3 (0.8);\n          if (ShowInt (vec2 (g.x - 0.5, g.y + 0.13),\n             vec2 (1., 0.25), 4., dot (mod (vec2 (42., 24.) + idCell, 100.),\n             vec2 (100., 1.))) != 0.) {\n            col = vec3 (0.1);\n            isLit = false;\n          }\n        }\n        g.y = r - 1.1 * rdHol;\n        if (length (max (abs (g) - vec2 (0.5, 0.15), 0.)) < 0.1) {\n          col = vec3 (0.8);\n          if (ShowInt (vec2 (g.x - 0.5, g.y + 0.12), vec2 (1., 0.25), 4.,\n             2048. + idFlr) != 0.) {\n            col = vec3 (0.1);\n            isLit = false;\n          }\n        }\n      }\n    } else if (idObj == idRal) {\n      col = vec3 (1.2, 1.2, 1.);\n      spec = 0.5;\n    } else if (idObj == idBks) {\n      bt = vec2 (5000. * a, 200. * q.y);\n      a = 52. * mod (6. * a + 0.5, 1.);\n      gbBk = floor (vec2 (q.y / spShf, a));\n      bh = (0.7 + 0.3 * Fbm2 ((gbRm + gbBk) * vec2 (19., 31.))) * spShf;\n      q.y = mod (q.y, spShf);\n      if (q.y < bh) {\n        q.xy = vec2 (2. * mod (a, 1.) - 1., q.y / bh - 0.5);\n        col = vec3 (HsvToRgb (vec3 (mod (cRm +\n           0.5 * (Fbm2 (gbBk * vec2 (17., 11.)) - 0.5), 1.), 1.,\n           SmoothBump (0.08, 0.92, 0.01, 0.55 + 0.45 * q.x))));\n        if (abs (abs (q.y) - 0.35) < 0.01 || abs (q.x) < 0.3 && abs (q.y) < 0.2 &&\n           Noisefv2 ((gbRm + gbBk) * vec2 (19., 31.) + floor (bt)) > 0.7) {\n          col *= 1.6;\n        } else {\n          spec = 0.3;\n          vn.xz = Rot2D (vn.xz, q.x);\n        }\n      } else {\n        col = vec3 (0.02);\n        isLit = false;\n      }\n    } else if (idObj == idShlf) {\n      q = vec3 (5. * (mod (6. * a, 1.) - 0.5), ro.y, r);\n      col = WoodCol (q, vn);\n    } else if (idObj == idLt) {\n      col = vec3 (1., 1., 0.7) * (0.5 - 0.5 * vn.y);\n      isLit = false;\n    } else if (idObj == idBl) {\n      col = (0.75 + 0.25 * dot (rd, normalize (lbPos - ro))) *\n         HsvToRgb (vec3 (0.14 + 0.02 * sin (4. * tCur), 1., 1.));\n      isLit = false;\n    }\n    if (idObj != idBl) {\n      ld = lbPos - ro;\n      s = length (ld);\n      ld /= s;\n      lbCol = 2. * clamp (dot (vn, ld), 0., 1.) / (1. + s * s);\n    }\n    if (isLit) col = col * (0.2 + 2. * lbCol +\n       0.5 * max (0., max (dot (vn, ltDir), 0.)) +\n       spec * pow (max (0., dot (ltDir, reflect (rd, vn))), 16.));\n  } else col = bgCol;\n  col = mix (col, bgCol, smoothstep (0.6, 1., min (dstObj / dstFar, 1.)));\n  if (bwImg && idObj != idBl) col = vec3 (1.) * pow (RgbToHsv (col).b, 1.5);\n  col = mix (col, vec3 (1., 1., 0.5), GlowCol (roo, rd, dstObj));\n  col = clamp (col, 0., 1.);\n  return col;\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  vec2 tp[7], td[6];\n  float dir, tc, tm;\n  tc = floor (t / 27.);\n  tm = mod (t, 27.);\n  p.y = 0.1 + 0.2 * sin (0.6 * t) + 2. * tc;\n  td[0] = vec2 (1., 0.);\n  tp[0] = vec2 (-0.5 + 2. * tc + step (13., tm), -0.5 * sqrt3);\n  if (tm < 26.) {\n    dir = -1. + 2. * step (13., tm);\n    tm = mod (tm, 13.);\n    if (tm < 12.) {\n      dir *= -1. + 2. * step (6., tm);\n      tm = mod (tm, 6.);\n      td[1] = vec2 (0.5, 0.5 * sqrt3 * dir);\n      td[2] = vec2 (-0.5, 0.5 * sqrt3 * dir);\n      td[3] = - td[0];\n      td[4] = - td[1];\n      td[5] = - td[2];\n      for (int k = 0; k < 6; k ++) tp[k + 1] = tp[k] + td[k];\n      if (tm < 1.)      p.xz = tp[0] + td[0] * tm;\n      else if (tm < 2.) p.xz = tp[1] + td[1] * (tm - 1.); \n      else if (tm < 3.) p.xz = tp[2] + td[2] * (tm - 2.); \n      else if (tm < 4.) p.xz = tp[3] + td[3] * (tm - 3.); \n      else if (tm < 5.) p.xz = tp[4] + td[4] * (tm - 4.); \n      else if (tm < 6.) p.xz = tp[5] + td[5] * (tm - 5.); \n    } else {\n      p.xz = tp[0] + td[0] * (tm - 12.);\n    }\n  } else {\n    p.xz = tp[0] + td[0];\n    p.y += 2. * (tm - 26.);\n  }\n  p.xz *= 4. * szGr.x;\n  p.y *= szGr.y;\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, fpF, fpB, vd;\n  vec2 uv, ori, ca, sa;\n  float el, az, spd;\n  uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  bwImg = false;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    if (mPtr.x > 0.4 && mPtr.y < -0.4) bwImg = true;\n    else {\n      az = az + 2. * pi * mPtr.x;\n      el = el + 0.95 * pi * mPtr.y;\n    }\n  }\n  szGr = vec2 (10., 3.3);\n  spd = 0.12;\n  lbPos = 0.5 * (TrackPath (spd * tCur + 0.4) + TrackPath (spd * tCur + 0.6));\n  fpF = TrackPath (spd * tCur + 0.1);\n  fpB = TrackPath (spd * tCur - 0.1);\n  ro = 0.5 * (fpF + fpB);\n  vd = fpF - fpB;\n  ori = vec2 (el, az + ((length (vd.xz) > 0.) ? atan (vd.x, vd.z) : 0.5 * pi));\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 1.6));\n  dstFar = 300.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 2.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec2 HexCellId (vec2 p)\n{\n  vec3 c, r, dr;\n  p.y *= (1./sqrt3);\n  c.xz = vec2 (0.5 * (p.x - p.y), p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (2., step (dr.yzx, dr) + step (dr.zxy, dr)) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec3 RgbToHsv (vec3 c)\n{\n  vec4 p, q;\n  float d;\n  const float e = 1.e-10;\n  p = mix (vec4 (c.bg, vec2 (-1., 2./3.)), vec4 (c.gb, vec2 (0., -1./3.)),\n     step (c.b, c.g));\n  q = mix (vec4 (p.xyw, c.r), vec4 (c.r, p.yzx), step (p.x, c.r));\n  d = q.x - min (q.w, q.y);\n  return vec3 (abs (q.z + (q.w - q.y) / (6. * d + e)), d / (q.x + e), q.x);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return step (abs (q.x), 0.12) * step (abs (q.y), 0.6);\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.5, 2.2);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.)) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (sgn < 0.) {\n      if (idChar == mxChar - nDig - 1.) s = ShowDig (q, -1);\n      else ++ v;\n    }\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}