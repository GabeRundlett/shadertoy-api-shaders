{
    "Shader": {
        "info": {
            "date": "1638574597",
            "description": "I stumbled on way more elegant and shorter easier to remember way to calculate ray-ray or even segment-segment intersections.\nhttps://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/565282#565282",
            "flags": 0,
            "hasliked": 0,
            "id": "sl3SRn",
            "likes": 12,
            "name": "Intersection rays/segments",
            "published": 3,
            "tags": [
                "intersection"
            ],
            "usePreview": 1,
            "username": "Yusef28",
            "viewed": 471
        },
        "renderpass": [
            {
                "code": "/////////////////////////////////////////////////////////////\n//                                                         //\n// Author:Yusef28                                          //\n// Start Date: 26-07-2021                                  //\n// Status: On Going                                        //\n// Topic: Line Segment Intersection                        //\n// Sources: http://paulbourke.net/geometry                 //\n// Listening to: Andromida - Hellscape (FULL ALBUM STREAM) //\n//                                                         // \n/////////////////////////////////////////////////////////////\n\n/*\nI found a way method of finding intersections between two\nsegments in a plane. \nby found I mean I found it on stackexchange\n\nhttps://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/565282#565282\n\nThe previous method I had (in the source of this fork) \nrequires way more calculation and if you want something you\ncan whip out of you back pocket in a pinch that isn't the \nthing you'll want.\n\nThis is way cooler.\n\nyou have teh intersection of two rays expressed as:\n\nro1 + rd1*t = ro2 + rd2*s (where s and t are the distances)\n\nYou can just eliminate one by taking the dot product\nof every vector in this equation by a vector perpendicular\nto one of either rd1 or rd2!\n\nBecause dot(rd1,perp_rd1) will be 0, \nyou eliminate that term including the t!\n\nBeautiful!\n\nWe just need to remember to repeat this for s so we can make\nsure we have a valid intersection (s and t both betwen the \nend ranges of the segments. Or in the case of rays, just >= 0)\n\n*/\n#define line1Col vec3(1.,.2,.5)\n#define line2Col vec3(1.,.3,.3)\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5,0.5)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////  BACKGROUND GRID DESIGN             //\n      //                                   //\n      /////////////////////////////////////\n      \n    vec2 st = uv;//save the unscaled uv\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    uv*=10.;\n    //graph background\n    vec3 col = vec3(0.1);\n    //center highlights\n    col = mix(col,vec3(0.16),1.0-length(uv/8.));\n    //dust \n    float specks = fract(sin(dot(uv,vec2(123.,16.)))*433413.);\n    \n    //nice soft texture \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.25),pow(tex,2.));\n    \n    //small grid lines\n    vec2 lines = fract(uv*5.);\n    lines = smoothstep(0.45,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.24),lines.x);\n    col = mix(col,vec3(0.24),lines.y);\n    \n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.47,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.5),lines.x);\n    col = mix(col,vec3(0.5),lines.y);\n    \n    //axis lines\n    lines = smoothstep(0.0,0.02,abs(uv));\n    col = mix(col,vec3(0.6),1.0-lines.x);\n    col = mix(col,vec3(0.6),1.-lines.y);\n    col = mix(col,vec3(0.1),step(0.1,specks)*0.2);\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////  LINE INTERSECTION CALCULATIONS     //\n      //                                   //\n      /////////////////////////////////////\n      \n    //Line Points\n    vec2 A1 = vec2(-3.4+sin(iTime),-2.4+sin(iTime+0.5));\n    vec2 B1 = vec2(3.4+sin(iTime+4.),3.4+sin(iTime+2.));\n    vec2 ro1 = A1;\n    vec2 rd1 = normalize(B1-A1);\n    float maxLength1 = length(B1-A1);\n    \n    vec2 A2 = vec2(-3.3+sin(iTime+1.4),-3.6+sin(iTime+3.));\n    vec2 B2 = vec2(2.3+sin(iTime+0.2),3.1+sin(iTime+0.3))*10.;\n    vec2 ro2 = A2;\n    vec2 rd2 = normalize(B2-A2);\n    float maxLength2 = length(B2-A2);\n    //we know that teh intersection of two rays is\n    // ro1+rd1*t = ro2+rd2*s\n    // There is a really elegant solution for this\n    // use dot everything by a perpendicualr vector\n    // to rd1 and its unknown will cancel out.\n    vec2 perpRD1 = rd1.yx*vec2(-1.,1.);\n    float s = (dot(ro1,perpRD1) - dot(ro2,perpRD1)) / dot(rd2,perpRD1);\n    \n    //we just need to repeat for the other side to check\n    //validity for both rays\n    \n    vec2 perpRD2 = rd2.yx*vec2(-1.,1.);\n    float t = (dot(ro2,perpRD2) - dot(ro1,perpRD2)) / dot(rd1,perpRD2);\n    \n    //when valid, either s or t will lead to the samer\n    // intersection point\n    \n    vec2 validPoint = ro1 + rd1*t;\n    \n\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////        DRAWING EVERYTHING           //\n      //                                   //\n      /////////////////////////////////////\n    \n        \n    //line 1\n    float f = 1.0-smoothstep(0.02,0.06,abs(distToLine(A1, B1, uv)));\n    col = mix(col, vec3(1.,.2,.5), f);//0.5\n    \n    //line 2\n    f = 1.0-smoothstep(0.02,0.06,abs(distToLine(A2, B2, uv)));\n    col = mix(col, vec3(1.,.3,.3), f);\n    \n    \n    //segment end points line 1\n    f = 1.-smoothstep(0.03,0.08,length(uv-A1)-0.02);\n    col = mix(col, line1Col, f);\n    //segment end points line 1\n    f = 1.-smoothstep(0.03,0.08,length(uv-B1)-0.02);\n    col = mix(col, line1Col, f);\n    \n    //segment end points line 2\n    f = 1.-smoothstep(0.03,0.08,length(uv-A2)-0.02);\n    col = mix(col, line2Col, f);\n    //segment end points line 2\n    f = 1.-smoothstep(0.03,0.08,length(uv-B2)-0.02);\n    col = mix(col, line2Col, f);\n    \n    \n    // if s and t are both between 0. and maxLength they are\n    // valid for both the linear interpolations we need.\n    // so show the intersection point.\n    if(s >= 0. && t >= 0. && t <= maxLength1 && s <= maxLength2){\n    \n    //intersection\n    f = 1.-smoothstep(0.02,0.04,abs(length(uv-validPoint)-0.15));\n    col = mix(col, vec3(1.,0.7,0.), f);\n    f = 1.-smoothstep(0.03,0.08,length(uv-validPoint)-0.015);\n    col = mix(col, vec3(1.,0.7,0.), f);\n    \n   }\n    \n    \n      ////////////////////////////////////////////\n      //                                       //\n////////          POST PROCESSING            //\n      //                                   //\n      /////////////////////////////////////\n        \n     \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    // Output to screen\n    fragColor = vec4(col*vig,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}