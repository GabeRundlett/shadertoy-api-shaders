{
    "Shader": {
        "info": {
            "date": "1499731706",
            "description": "This shows that smin-based rounded Voronoi edge function is discontinuous, even if associative smin is used. It is, however, continuous for positive values, which in many use-cases is enough.\n\n[url=http://polycu.be/edit/?h=mxHbaF]PolyCube version[/url].",
            "flags": 0,
            "hasliked": 0,
            "id": "MdSfzD",
            "likes": 4,
            "name": "Rounded Voronoi Edges Analysis",
            "published": 3,
            "tags": [
                "voronoi",
                "distance",
                "edges"
            ],
            "usePreview": 0,
            "username": "tomkh",
            "viewed": 808
        },
        "renderpass": [
            {
                "code": "#define ST_MODE\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// by Tomasz Dobrowolski' 2016\n\n// This is simlar to\n// https://www.shadertoy.com/view/lsSfz1 by Shane,\n// although I was using the same exact\n// smin-rounded distance to Voronoi edge way before,\n// just didn't post on ShaderToy so far.\n\n// I show multiple variants and discuss it's \n// properties and correctness.\n// Please read the description above every voronoi_*\n// function.\n\n// Time-wise, every second it oscillates between:\n//  4x4 search = faster (optimized) version, and\n//  5x5 search = always visiting the same set of potential neighbours.\n\n// Additionally, when you hold LMB it shows the\n// difference between commutative smin\n// and associative (and also commutative) smin function.\n\n// Associative function is either simple exp/log based on IQ article\n// https://iquilezles.org/articles/smin\n// or TinyTexel's weighting functions based on\n// https://www.shadertoy.com/view/MdByzD\n\n#define TINYTEXELS_SMIN 1\n// 0 = simple exp/log based on IQ's smin\n// 1 = TinyTexel's weighting function\n\n#define DIST_BASED_SMIN 0\n// 1 = enable distance based smin as in \n//     https://www.shadertoy.com/view/ld3yRn \"Rounder Voronoi Edge Distance\"\n\n//#define ANIMATE\n\n// How far cells can go off center during animation (must be <= .5)\n#define ANIMATE_D .5\n\n// Points cannot be closer than sqrt(EPSILON)\n#define EPSILON .00001\n\nvec2 hash2(vec2 p)\n{\n    #if 1\n       // Dave Hoskin's hash as in https://www.shadertoy.com/view/4djSRW\n       vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n       p3 += dot(p3, p3.yzx+19.19);\n       vec2 o = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n    #else\n       // Texture-based\n       vec2 o = texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n    #endif\n    #ifdef ANIMATE\n       o = 0.5 + ANIMATE_D*sin( iTime + o*6.2831853 );\n    #endif\n   return o;\n}\n\n// Commutative smin function taken\n// from Alex Evans aka Statix talk \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// credited to Dave Smith @media molecule\nfloat smin(float a, float b, float r)\n{\n   float f = max(0.,1.-abs(b-a)/r);\n   return min(a,b) - r*.25*f*f;\n}\n\nfloat sweight(float d, float s)\n{\n#if TINYTEXELS_SMIN\n    return 1.0 / (exp(d * s) - 1.0);\n#else\n    return exp(-d * s);\n#endif\n}\n\nfloat inv_sweight(float d, float s)\n{\n#if TINYTEXELS_SMIN\n    return log(1.0 / d + 1.0) / s;\n#else\n    return -log(d) / s;\n#endif\n}\n\n// TinyTexel's weighting functions\n// https://www.shadertoy.com/view/MdByzD\n\n// This is bullet-proof version of finding closest point\n// in 4x4 area around query point \"q\".\n// In fact 12 cells (4x4 without corners) would be enough,\n// but it's less elegant to implement.\n// We pass n=|q|, f=q-n, as an optimization.\nfloat closest( in vec2 n, in vec2 f, out vec2 mr, out vec2 mg )\n{\n    // take half-cell position\n    vec2 h = step(.5,f) - 2.;\n    vec2 n2 = n + h;\n    vec2 f2 = f - h;\n\n    float md = 8.0;\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash2( n2 + g );\n        vec2 r = g + o - f2;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n    mg += h; // return cell position relative to \"n\"\n    \n    return md;\n}\n\n// This is faster version that only visits\n// potential neighbours in 4x4 area around\n// query point \"x\".\n// It's not bullet-proof, but errors are very rare.\nvec3 voronoi( in vec2 x, in float s )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    vec2 h = step(.5,f) - 2.;\n    vec2 n2 = n + h;\n    vec2 f2 = f - h;\n\n    vec2 mr, mg;\n    float md = closest(n,f,mr,mg);\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash2( n2 + g );\n        vec2 r = g + o - f2;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        {\n           float d = dot( 0.5*(mr+r), normalize(r-mr) );\n#if DIST_BASED_SMIN\n           md = smin( md, d, 3.*s*d );\n#else\n           md = smin( md, d, s );\n#endif\n        }\n    }\n    return vec3( md, mr );\n}\n\n// This version visits always the same list\n// of potential neighbours in 5x5 area around\n// cell \"mg\" that contains the closest point.\n// This is still not bullet-proof, as sometimes\n// neighbour to closest point that defines\n// the closest edge to \"x\" might be in 7x7 area \n// around \"mg\".\nvec3 voronoi_const_neighbour( in vec2 x, in float s )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec2 mr, mg;\n    float md = closest(n,f,mr,mg);\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n        vec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        {\n           float d = dot( 0.5*(mr+r), normalize(r-mr) );\n#if DIST_BASED_SMIN\n           md = smin( md, d, 3.*s*d );\n#else\n           md = smin( md, d, s );\n#endif\n        }\n    }\n    return vec3( md, mr );\n}\n\n// This version is using associative (and commutative)\n// smin function:\n//  f(a,b) = -log(exp(-k*a) + exp(-k*b))/k\n// described by iq here:\n//  https://iquilezles.org/articles/smin\n// but it is really based on well-known Log-Sum-Exp function\n// https://en.wikipedia.org/wiki/LogSumExp\n// that generalizes minimum or maximum.\n// Note that it is associative, because:\n//  f(f(a,b),c) = -log(exp(+log(exp(-k*a) + exp(-k*b))) + exp(-k*c))\n//              = -log(exp(-k*a) + exp(-k*b) + exp(-k*c))\n//  f(a,f(b,c)) = -log(exp(-k*a) + exp(+log(exp(-k*b) + exp(-k*c))))\n//              = -log(exp(-k*a) + exp(-k*b) + exp(-k*c))\n// Therefore,\n//  f(f(a,b),c) = f(a,f(b,c))\n// As you can see the combination is equivalent to adding all exponents\n// and taking logarithm just once at the end - we utilize it here.\n// Additionally, as in previous \"voronoi\" function we only visit\n// potential neighbours in 4x4 area around query point \"x\".\n// Unfortunately, it is not a good optimization\n// in this case, as even inside the same Voronoi region\n// we are visiting different set of neighbours\n// (depending on half-cell position of \"x\").\nvec3 voronoi_associative( in vec2 x, in float s )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    vec2 h = step(.5,f) - 2.;\n    vec2 n2 = n + h;\n    vec2 f2 = f - h;\n\n    vec2 mr, mg;\n    float md = closest(n,f,mr,mg);\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 0.0;\n    float s2 = 3./s;\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash2( n2 + g );\n        vec2 r = g + o - f2;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        {\n           float d = dot( 0.5*(mr+r), normalize(r-mr) );\n           md += sweight(d, s2);\n        }\n    }\n    md = inv_sweight(md, s2);\n\n    return vec3( md, mr );\n}\n\n// This version is using associative (and commutative)\n// smin function:\n//  f(a,b) = -log(exp(-k*a) + exp(-k*b))/k\n// described by iq here:\n//  https://iquilezles.org/articles/smin\n// but it is really based on well-known Log-Sum-Exp function\n// https://en.wikipedia.org/wiki/LogSumExp\n// that generalizes minimum or maximum.\n// Note that it is associative, because:\n//  f(f(a,b),c) = -log(exp(+log(exp(-k*a) + exp(-k*b))) + exp(-k*c))\n//              = -log(exp(-k*a) + exp(-k*b) + exp(-k*c))\n//  f(a,f(b,c)) = -log(exp(-k*a) + exp(+log(exp(-k*b) + exp(-k*c))))\n//              = -log(exp(-k*a) + exp(-k*b) + exp(-k*c))\n// Therefore,\n//  f(f(a,b),c) = f(a,f(b,c))\n// As you can see the combination is equivalent to adding all exponents\n// and taking logarithm just once at the end - we utilize it here.\n// Additionally, this one, for every closest point,\n// always visits the same set of potential neighbours\n// in 5x5 area around cell \"mg\" that contains\n// this closest point.\n// Note that, the function is still not continuous :|\nvec3 voronoi_associative_const_neighbour( in vec2 x, in float s )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec2 mr, mg;\n    float md = closest(n,f,mr,mg);\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 0.0;\n    float s2 = 3./s;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n        vec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        {\n           float d = dot( 0.5*(mr+r), normalize(r-mr) );\n           md += sweight(d, s2);\n        }\n    }\n    md = inv_sweight(md, s2);\n\n    return vec3( md, mr );\n}\n\n#ifdef ST_MODE\n#define template_time iTime\n#define template_bstatus 1.-step(0.,-iMouse.z)\nvec3 plot( vec2 p, float ss )\n{\n#else\nvec3 plot( vec2 p )\n{\n    float ss = template_tr.z;\n#endif\n    const float s = .25;\n    float nb_mode = step(.5,fract(template_time*.5));\n    float as_mode = float(template_bstatus);\n    vec3 c = (as_mode < .5)\n       ? ((nb_mode < .5) ?\n          voronoi( p, s )\n         : voronoi_const_neighbour( p, s ))\n       : ((nb_mode < .5) ?\n          voronoi_associative( p, s )\n         : voronoi_associative_const_neighbour( p, s ));\n    \n    // Colors:\n    vec3 interior = vec3(.2,.7,1.);\n    vec3 border = vec3(1.,.7,0)*(nb_mode*.4+.8);\n    vec3 point = vec3(1.,.7,0);\n    \n    float d = length(c.yz);\n    vec3 col =\n        mix(\n            (abs(c.x)+.5)*(sin(c.x*120.)*.2+.8)*\n            mix(interior,\n                border,\n                smoothstep(.02,0.,c.x)*.5\n            )*min(1.,d*16.),\n            point,\n            smoothstep(.03+ss*1.5,.03,d)\n        );\n    return col;\n}\n\n#ifdef ST_MODE\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = step(512., iResolution.y)*2. + 2.; // scale differently for fullscreen\n    float ss = sc / iResolution.y; // size of 1 pixel\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5) * ss;\n    fragColor = vec4(plot(uv, ss), 1.);\n}\n#endif\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}