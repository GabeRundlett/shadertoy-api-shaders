{
    "Shader": {
        "info": {
            "date": "1574682770",
            "description": "Asteroid flythrough.\nUse the mouse; switch forward/backward views when mouse in small frame.",
            "flags": 0,
            "hasliked": 0,
            "id": "WsGSzt",
            "likes": 17,
            "name": "Dynamic Space Rocks",
            "published": 3,
            "tags": [
                "voronoi",
                "flight",
                "asteroid"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 585
        },
        "renderpass": [
            {
                "code": "// \"Dynamic Space Rocks\" by dr2 - 2019 \n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Asteroid flythrough\n// Use the mouse; switch forward/backward views when mouse in small frame.\n// Based on \"Asteroid Field\" with Voronoi displacements from \"Rainbow Cavern\".\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat Minv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3v3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 flMat, flyerMat;\nvec4 astV, astCs;\nvec3 bGrid, trkAx, trkAy, trkFx, trkFy, flPos, flyerPos, qHit, ltDir, cId, cHash;\nfloat tCur, dstFar, spd, szFacFl, astOcc;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkAx, cos (trkFx * t)), dot (trkAy, cos (trkFy * t)), t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (- dot (trkFx * trkAx, sin (trkFx * t)),\n     - dot (trkFy * trkAy, sin (trkFy * t)), 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (- dot (trkFx * trkFx * trkAx, cos (trkFx * t)),\n     - dot (trkFy * trkFy * trkAy, cos (trkFy * t)), 0.);\n}\n\nfloat VPoly (vec3 p)\n{\n  vec3 ip, fp, a, g, w;\n  ip = floor (p);\n  fp = fract (p);\n  a = vec3 (4.);\n  for (float gz = -1.; gz <= 1.; gz ++) {\n    for (float gy = -1.; gy <= 1.; gy ++) {\n      for (float gx = -1.; gx <= 1.; gx ++) {\n        g = vec3 (gx, gy, gz);\n        w = g + 0.7 * Hashv3v3 (ip + g) - fp;\n        a.z = dot (w, w);\n        if (a.z < a.x) a.xy = a.zx;\n        else a.y = min (a.z, a.y);\n      }\n    }\n  }\n  return sqrt (a.y - a.x);\n}\n\nvoid AstState ()\n{\n  float s, r;\n  cHash = Hashv3v3 (cId);\n  if (cHash.x > astOcc) {\n    s = fract (64. * length (cHash));\n    s *= s;\n    r = 0.5 * bGrid.x * min (0.8 + 0.3 * cHash.x * (1. - s) * abs (sin (3. * pi * cHash.y * (1. - s))), 1.);\n    astV = vec4 ((r - 1.1 * (0.15 - 0.07 * s)) * vec3 (sin ((cHash.z * tCur + cHash.x) +\n       vec2 (0.5 * pi, 0.)), 0.), 0.15 - 0.07 * s);\n    astCs = vec4 (sin (2. * pi * (cHash.x + 0.09 * cHash.z * tCur) + vec2 (0.5 * pi, 0.)),\n       sin (2. * pi * (cHash.y + 0.11 * cHash.z * tCur) + vec2 (0.5 * pi, 0.)));\n  }\n}\n\nvec3 AstRot (vec3 p)\n{\n  p.xy = Rot2Cs (p.xy, astCs.xy);\n  p.zy = Rot2Cs (p.zy, astCs.zw);\n  return p;\n}\n\nvec3 AstRotT (vec3 p)\n{\n  p.zy = Rot2Cs (p.zy, vec2 (astCs.z, - astCs.w));\n  p.xy = Rot2Cs (p.xy, vec2 (astCs.x, - astCs.y));\n  return p;\n}\n\nvec3 AstCell (vec3 p)\n{\n  cId.xy = floor (p.xy / bGrid.xy);\n  p.z += 0.2 * spd * tCur * Hashfv2 (cId.xy) * smoothstep (6., 10., length (cId.xy));\n  cId.z = floor (p.z / bGrid.z);\n  return p;\n}\n\nfloat AstDf (vec3 p)\n{\n  float d;\n  d = PrRoundBoxDf (p, 0.6 * astV.w * (1. - 0.5 * cHash), 0.4 * astV.w);\n  if (d < 0.07) d -= 0.04 * VPoly ((8. + 2. * cHash.y) * p);\n  return 0.7 *  d;\n}\n\nfloat AstRay (vec3 ro, vec3 rd)\n{\n  vec3 cIdP, p, s, rdi;\n  float dHit, d, da, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  cIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = 0; j < 80; j ++) {\n    p = ro + dHit * rd;\n    p = AstCell (p);\n    if (cId != cIdP) {\n      AstState ();\n      cIdP = cId;\n    }\n    s = (bGrid * (cId + step (0., rd)) - p) * rdi;\n    d = abs (Minv3 (s)) + eps;\n    if (cHash.x > astOcc && length (cId.xy - floor (TrackPath (bGrid.z * cId.z).xy / bGrid.xy)) >= 1.)\n       d = min (d, AstDf (AstRot (p - (bGrid * (cId + 0.5) + astV.xyz))));\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 AstNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.005, -0.005);\n  v = vec4 (- AstDf (p + e.xxx), AstDf (p + e.xyy), AstDf (p + e.yxy), AstDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 AstCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, p, col;\n  p = AstCell (ro);\n  AstState ();\n  p = AstRot (p - (bGrid * (cId + 0.5) + astV.xyz));\n  vn = AstNf (p);\n  vn = VaryNf (32. * (0.5 + 0.5 * cHash.x) * p, vn, 16. * (0.5 + 0.5 * cHash.y));\n  vn = AstRotT (vn);\n  col = HsvToRgb (vec3 (0.02 + 0.12 * cHash.x, 0.1 + 0.3 * cHash.y,\n     min (0.6 + 0.3 * cHash.z + 0.5 * Fbm3 (4. * p), 1.)));\n  col = col * (0.1 + 0.1 * max (- dot (vn, ltDir), 0.) + 0.8 * max (dot (vn, ltDir), 0.)) +\n     0.2 * vec3 (1.) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n  return col;\n}\n\nfloat FlyerEngDf (vec3 p)\n{\n  vec3 q;\n  float d;\n  p = flyerMat * (p - flyerPos) / szFacFl;\n  q = p - vec3 (0., 0.3, -0.6);\n  q.xz = abs (q.xz) - vec2 (1.6, 1.3);\n  q.xy = Rot2D (q.xy, -32. * tCur);\n  d = max (PrCylDf (q, 0.4, 0.4), 0.05 - min (abs (q.x), abs (q.y)));\n  return szFacFl * d;\n}\n\nfloat FlyerEngRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 50; j ++) {\n    d = FlyerEngDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat FlyerDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, h;\n  dMin = dstFar / szFacFl;\n  p = flyerMat * (p - flyerPos) / szFacFl;\n  q = p;\n  h = 0.5 - 0.05 * (q.z + 0.3) * (q.z + 0.3);\n  q.y -= h;\n  d = PrRoundBoxDf (q, vec3 (0.9 - 0.06 * (q.z + 0.5) * (q.z + 0.5), h, 2.7), 0.15);\n  q = p + vec3 (0., -0.3, 0.6);\n  qq = q;\n  qq.xz = abs (qq.xz) - vec2 (1.6, 1.3);\n  d = min (min (min (d, PrCylAnDf (qq, 0.44, 0.04 - 0.03 * (qq.z / 0.48) * (qq.z / 0.48), 0.48)),\n     PrCylDf (qq, 0.15 - 0.12 * (qq.z / 0.45) * (qq.z / 0.45), 0.45)),\n     PrRoundBoxDf (qq, vec3 (0.4, 0.01, 0.1), 0.01));\n  q = p;\n  q.y -= 0.3;\n  qq = q;\n  qq.z = abs (qq.z + 0.6) - 1.3;\n  d = SmoothMin (d, PrRoundBoxDf (qq, vec3 (1.15, 0.03 - 0.05 * abs (qq.z), 0.3), 0.01), 0.05);\n  DMINQ (1);\n  q = p;\n  q.yz -= vec2 (0.52, 0.5);\n  d = PrCapsDf (q, 0.6, 1.);\n  DMINQ (2);\n  return 0.7 * szFacFl * dMin;\n}\n\nfloat FlyerRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = FlyerDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 FlyerNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (- FlyerDf (p + e.xxx), FlyerDf (p + e.xyy), FlyerDf (p + e.yxy), FlyerDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 FlyerCol ()\n{\n  vec4 col4;\n  float ax;\n  col4 = vec4 (0.9, 1., 0.9, 0.3);\n  ax = abs (qHit.x);\n  if (idObj == 1) {\n    if (qHit.z > 2. && length (vec2 (ax - 0.2, qHit.y + 0.3)) < 0.12) {\n      if (length (vec2 (ax - 0.2, qHit.y + 0.3)) < 0.1) col4 = vec4 (1.1, 1.1, 0.8, -2.);\n      else col4 = vec4 (0.5, 0.5, 0.7, 0.3);\n    } else if (qHit.z < -2. && length (vec2 (abs (ax - 0.3) - 0.15, qHit.y + 0.1)) < 0.1) {\n      if (length (vec2 (abs (ax - 0.3) - 0.15, qHit.y + 0.1)) < 0.08)\n         col4 = vec4 (0.8 + 0.2 * sin (2. * pi * tCur), 0., 0., -2.);\n      else col4 = vec4 (0.5, 0.5, 0.7, 0.3);\n    } else if (abs (abs (qHit.z + 0.15) - 1.3) < 0.1 && length (vec2 (ax - 1.6, qHit.y)) < 0.2) {\n      col4 = vec4 (1., 0., 0., 0.3);\n    } else if (ax < 0.02 || qHit.z < -2.8 && mod (8. * qHit.x + 0.1, 1.) < 0.2 ||\n       qHit.z > 2.8 && mod (12. * qHit.y + 0.1, 1.) < 0.2 ||\n       abs (qHit.z + 1.3) < 0.9 && ax < 0.8 && mod (6. * qHit.x + 0.1, 1.) < 0.15 ||\n       abs (qHit.z + 0.7) < 0.5 && abs (qHit.y - 0.2) < 0.3 && mod (12. * qHit.y + 0.1, 1.) < 0.15) {\n      col4 = vec4 (0.6, 0.6, 0.6, 0.3);\n    } else if (abs (abs (qHit.z + 0.15) - 1.3) < 0.1 && ax > 1.12) {\n      col4 = vec4 (0.6, 0.6, 0.6, 0.3);\n    } else if (length (vec2 (abs (qHit.z + 0.6) - 1.3, ax - 1.6)) < 0.1 && abs (qHit.y) > 0.44) {\n       col4 = mix (0.8 * col4, vec4 (0., 1., 0., -2.), step (0.5, mod (0.5 * tCur, 1.)));\n    }\n  } else if (idObj == 2) {\n    if (min (ax, abs (qHit.z - 1.)) > 0.03) col4 = vec4 (0.1, 0.1, 0.2, -1.);\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstAst, dstFlyer, dstEng, refFac;\n  dstEng = FlyerEngRay (ro, rd);\n  dstFlyer = FlyerRay (ro, rd);\n  if (dstFlyer < dstEng) dstEng = dstFar;\n  dstAst = AstRay (ro, rd);\n  col = vec3 (0.1, 0.07, 0.03);\n  if (min (dstFlyer, dstAst) < dstFar) {\n    if (dstFlyer < dstAst) {\n      ro += dstFlyer * rd;\n      vn = FlyerNf (ro);\n      col4 = FlyerCol ();\n      col = col4.rgb;\n      refFac = 0.;\n      if (col4.a >= 0.) {\n        col = col * (0.2 + 0.1 * max (dot (vn, - ltDir), 0.) + 0.7 * max (dot (vn, ltDir), 0.)) +\n           col4.a *  pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n        refFac = 0.3;\n      } else if (col4.a == -1.) refFac = 0.7;\n      if (refFac > 0.) {\n        rd = reflect (rd, vn);\n        ro += 0.01 * rd;\n        dstAst = AstRay (ro, rd);\n        ro += dstAst * rd;\n        col = mix (col, AstCol (ro, rd), refFac);\n      }\n    } else if (dstAst < dstFar) {\n      ro += dstAst * rd;\n      col = AstCol (ro, rd);\n    }\n  }\n  col = mix (vec3 (0.1, 0.07, 0.03), col, \n     exp2 (- 10. * max (min (min (dstFlyer, dstAst), dstFar) / dstFar - 0.7, 0.)));\n  if (dstEng < min (dstAst, dstFar)) col = mix (col, vec3 (0.4, 0.6, 1.) *\n     (0.8 + 0.4 * Fbm1 (32. * tCur)), 0.7);\n  return clamp (col, 0., 1.);\n}\n\nvoid FlyerPM (float s, float rl, float vu)\n{\n  vec3 vel, ort, ca, sa;\n  float el, az;\n  flPos = TrackPath (s);\n  vel = normalize (TrackVel (s));\n  el = - asin (vel.y);\n  az = atan (vel.z, vel.x) - 0.5 * pi;\n  rl = clamp (rl - 3. * TrackAcc (s).x, -0.4 * pi, 0.4 * pi);\n  ort = (vu >= 0.) ? vec3 (el, az, rl) : vec3 (- el, az + pi, - rl);\n  ca = cos (ort);\n  sa = sin (ort);\n  flMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, ori, ca, sa;\n  vec2 canvas, uv, mMid, ut, mSize;\n  float el, az, rl, zmFac, asp, vuDir;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./6.) * vec2 (asp, 1.);\n  mMid = vec2 (1. / mSize.y, 1. / mSize.y - 1.) * mSize * vec2 (-1. + 1./6., 1.);\n  ut = abs (uv - mMid) - mSize;\n  vuDir = 1.;\n  if (max (ut.x, ut.y) < 0.) {\n    uv = (uv - mMid) / mSize.y;\n    vuDir = -1.;\n  }\n  szFacFl = 0.005;\n  spd = 1.;\n  astOcc = 0.5;\n  tCur = mod (tCur, 10800.) + 10.;\n  az = 0.;\n  el = 0.;\n  rl = 0.;\n  if (mPtr.z > 0.) {\n    if (mPtr.x > -0.5 + 1./6. || mPtr.y < 0.5 - 1./6.) {\n      az = 2. * pi * mPtr.x;\n      el = 0.6 * pi * mPtr.y;\n    } else vuDir *= -1.;\n  }\n  el += 0.005 * pi * (Fbm1 (0.1 * tCur) - 0.5);\n  az += 0.005 * pi * (Fbm1 (0.1 * tCur + 1.) - 0.5);\n  rl += 0.02 * pi * (Fbm1 (0.3 * tCur + 2.) - 0.5);\n  ori = vec3 (el, az, rl);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.);\n  bGrid = vec3 (1.);\n  trkAx = vec3 (0.7, 0.8, 1.2);\n  trkAy = vec3 (1., 1.1, 0.9);\n  trkFx = vec3 (0.43, 0.33, 0.23);\n  trkFy = vec3 (0.41, 0.31, 0.12);\n  FlyerPM (spd * tCur + ((vuDir > 0.) ? 0.5 + 0.45 * sin (0.2 * tCur) :\n     - (0.25 + 0.2 * sin (0.2 * tCur))), 0.03 * pi * (Fbm1 (1.3 * tCur) - 0.5), 0.);\n  flyerPos = flPos;\n  flyerMat = flMat;\n  FlyerPM (spd * tCur, 0., vuDir);\n  ro = flPos;\n  zmFac = 3.;\n  rd = normalize (vec3 (uv, zmFac));\n  rd = rd * flMat;\n  rd = vuMat * rd;\n  ltDir = normalize (vec3 (0., 1., -1.));\n  ltDir.xz = Rot2D (ltDir.xz, 0.2 * pi * sin (0.1 * pi * tCur));\n  ltDir.yz = Rot2D (ltDir.yz, 0.1 * pi * sin (0.06 * pi * tCur));\n  if (vuDir < 0.) ltDir *= -1.;\n  dstFar = 25.;\n  col = ShowScene (ro, rd);\n  if (max (ut.x, ut.y) < 0. && min (abs (ut.x), abs (ut.y)) * canvas.y < 2.)\n     col = vec3 (0.1, 0.5, 0.1);\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec3 Hashv3v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec3 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}