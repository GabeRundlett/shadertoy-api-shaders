{
    "Shader": {
        "info": {
            "date": "1668373184",
            "description": "Drawing a polygon, or anything else with dihedral symmetry.",
            "flags": 16,
            "hasliked": 0,
            "id": "md2GWd",
            "likes": 11,
            "name": "Dihedral Symmetry SDF",
            "published": 3,
            "tags": [
                "simple",
                "sdf",
                "polygon",
                "dihedral"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 225
        },
        "renderpass": [
            {
                "code": "// Dihedral Symmetry, mla, 2022\n// Started as a little exercise in drawing polygons, trying to\n// keep everything as simple as possible, but I couldn't resist\n// adding some bells & whistles.\n\nconst float PI = 3.141592654;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n// Signed distance from p segment qr. Positive distance for\n// points on the left of the line looking from q to r.\nfloat ssegment(vec2 p, vec2 q, vec2 r) {\n  p -= q; r -= q;\n  float k = dot(p,r)/dot(r,r);\n  k = clamp(k,0.0,1.0);\n  vec2 closestpoint = k*r;\n  float dist = distance(p,closestpoint);\n  vec2 normal = vec2(-r.y,r.x);\n  float s = dot(p,normal) >= 0.0 ? 1.0 : -1.0;\n  return s*dist;\n}\n\n\nfloat polydist(float N, vec2 p, inout float t) {\n    float phi = PI/N; // angle of half sector\n    float theta = atan(p.x,-p.y);// negative y-axis is theta = 0\n    theta = mod(theta+phi,2.0*phi)-phi;\n    //theta /= 2.0*phi; theta -= round(theta); theta *= 2.0*phi; // Equivalent\n    theta = abs(theta); // Mirror symmetry\n    // With dihedral symmetry, the closest point is always in the\n    // fundamental region, so can limit attention just to there\n    // for finding the SDF.\n    vec2 p1 = length(p)*vec2(cos(theta),sin(theta));\n    float k = 0.618; // Just a constant for drawing\n    //k = abs(tan(0.125*PI*iTime)); k *= k; t = 1.0; // Alternative animation\n    vec2 q0 = 1.0/k*vec2(cos(phi),sin(phi)), q1 = k*vec2(cos(phi),0);\n    return ssegment(p1,q0,mix(q0,q1,t));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 p = 2.0*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    //float N = iMouse.x <= 0.0 ? 7.0 : floor(10.0*iMouse.x/iResolution.x) + 3.0;\n    //float N = floor(mod(0.25*iTime,10.0)) + 3.0;\n    float t = fract(0.25*iTime);\n    t = 6.0*t;\n    float N = 0.25*iTime;\n    float N1 = N+1.0;\n    N = floor(mod(N,10.0))+3.0;\n    N1 = floor(mod(N1,10.0))+3.0;\n    if (t > 5.0) N = mix(N,N1,smoothstep(0.0,1.0,t-5.0));\n    t = min(t,6.0-t);\n    t = clamp(t-1.0,0.0,1.0);\n    t = smoothstep(0.0,1.0,t);\n    float d = polydist(N,p,t);\n    float px = fwidth(p.x);\n    vec3 col = vec3(0.75+0.25*cos(20.0*PI*abs(d)));\n    if (t == 1.0 && d < 0.0) col.b = 0.25;\n    col = mix(vec3(1,0,0),col,vec3(smoothstep(0.0,px,abs(d)-0.01)));\n    col = pow(col,vec3(0.4545));\n    if (alert) col.r = 1.0;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}