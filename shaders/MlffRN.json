{
    "Shader": {
        "info": {
            "date": "1511262979",
            "description": "Plants vs Herbivores simulation, with edibility determined by colour similarity: [url]http://robust.cs.unm.edu/doku.php?id=ulam:demos:coevolution[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "MlffRN",
            "likes": 33,
            "name": "HueGene",
            "published": 3,
            "tags": [
                "simulation",
                "diffusion",
                "automata",
                "alife"
            ],
            "usePreview": 0,
            "username": "davidar",
            "viewed": 1453
        },
        "renderpass": [
            {
                "code": "// 2017 David A Roberts <https://davidar.io>\n\nvoid mainImage(out vec4 c, in vec2 p) {\n    if(iFrame < 10 || iMouse.z > 0.) return;\n    c = texture(iChannel0,p/iResolution.xy);\n    c.w = c.w * 110. - 100.;\n    if(c.w > 0.) c.xyz *= c.w/10.;\n    if(c.w < 0.) c.xyz *= -c.w/100.;\n    c.w = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// 2017 David A Roberts <https://davidar.io>\n\n// hash functions from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n#define MAX_HEALTH 100.0\n#define HEALTH(o) (-(o).w)\n#define HERBIVORE(o) ((o).w < 0.)\n#define PLANT(o) ((o).w > 0.)\n\nvec4 lookup(vec2 p) {\n    vec4 c = texture(iChannel0, p / iResolution.xy);\n    c.w = c.w * (MAX_HEALTH + 10.) - MAX_HEALTH;\n    if(-1. < c.w && c.w < 1.) c = vec4(0); // fix rounding errors\n    return c;\n}\n\n// move herbivore from o to c at location p\nvec4 move(vec4 o, vec4 c, vec2 p) {\n    if(PLANT(c)) {\n        // try to eat plant\n        float sad = abs(c.x-o.x) + abs(c.y-o.y) + abs(c.z-o.z);\n        if(sad < 0.2 /* || hash13(vec3(p,iFrame)) < 0.2/sad */ )\n            // plant is edible, increase health\n            o.w = clamp(o.w - 6.*c.w, -MAX_HEALTH, 0.);\n    }\n    if(PLANT(c) || HEALTH(o) > HEALTH(c)) {\n        // move unless already occupied by healthier herbivore\n        c = o;\n        // transfer some health to offspring\n        //if(HEALTH(c) >= MAX_HEALTH-1.) c.w /= 2.;\n    }\n    return c;\n}\n\nvoid mainImage(out vec4 c, in vec2 p) {\n    // biogenesis of the mother tree\n    if(iFrame < 10 || iMouse.z > 0.) {\n        c = vec4(0);\n        if(length(p-0.5*iResolution.xy) < 2.) {\n            c.xyz = hash33(vec3(p,iFrame));\n        \tc.w = 10.;\n        }\n    \tc.w = (MAX_HEALTH + c.w) / (MAX_HEALTH + 10.); // scale to [0,1]\n        return;\n    }\n    \n    // randomly spawn herbivores\n    if(hash13(vec3(p,iFrame)) == 0. && int(p.x)%10==0 && int(p.y)%10==0) {\n        c = vec4(0);\n        c.xyz = hash33(vec3(p,iFrame));\n        c.w = -MAX_HEALTH/2.;\n    \tc.w = (MAX_HEALTH + c.w) / (MAX_HEALTH + 10.); // scale to [0,1]\n        return;\n    }\n    \n    c = lookup(p);\n    \n    vec4 n = lookup(p + vec2( 0, 1));\n    vec4 e = lookup(p + vec2( 1, 0));\n    vec4 s = lookup(p + vec2( 0,-1));\n    vec4 w = lookup(p + vec2(-1, 0));\n    \n    // which neighbour this cell wants to move to this turn\n    int dir = int(4.*hash13(vec3(p,iFrame)));\n    vec4 tgt;\n    if(dir == 0) tgt = s;\n    if(dir == 1) tgt = w;\n    if(dir == 2) tgt = n;\n    if(dir == 3) tgt = e;\n    \n    // are neighbouring cells wanting to move here?\n    bool nc = int(4.*hash13(vec3(p + vec2( 0, 1), iFrame))) == 0;\n    bool ec = int(4.*hash13(vec3(p + vec2( 1, 0), iFrame))) == 1;\n    bool sc = int(4.*hash13(vec3(p + vec2( 0,-1), iFrame))) == 2;\n    bool wc = int(4.*hash13(vec3(p + vec2(-1, 0), iFrame))) == 3;\n    \n    // move herbivore from neighbouring cell here\n    if     (nc && HERBIVORE(n)) c = move(n,c,p);\n    else if(ec && HERBIVORE(e)) c = move(e,c,p);\n    else if(sc && HERBIVORE(s)) c = move(s,c,p);\n    else if(wc && HERBIVORE(w)) c = move(w,c,p);\n    else if(HERBIVORE(c)) {\n        if(HEALTH(c) >= MAX_HEALTH-1.) {\n            // leave behind an offspring\n            c.xyz += (hash33(vec3(p,iFrame))-0.5)/10.; // mutation\n            c.w /= 2.;\n        } else if(HEALTH(c) > HEALTH(tgt)) {\n            // move away unless neighbour is healthier\n            c = vec4(0);\n        }\n    }\n    \n    // send seed to neighbouring empty land\n    if(c.w > 9.5 && tgt.w == 0.) c.w = 5.;\n    \n    if(c.w == 0.) { // empty land here\n        vec4 par = vec4(0);\n        if(nc && n.w > 9.5) par = n;\n        if(ec && e.w > 9.5) par = e;\n        if(sc && s.w > 9.5) par = s;\n        if(wc && w.w > 9.5) par = w;\n        if(par.w > 9.5) {\n            // plant seed here\n        \tc.xyz = par.xyz + (hash33(vec3(p,iFrame))-0.5)/16.; // mutation\n            c.w = 5.;\n        }\n    }\n    \n    // each turn herbivores expend health, plants grow\n    if(c.w != 0.) c.w += 1.;\n    \n    c.xyz = clamp(c.xyz, 0., 1.);\n    c.w = clamp(c.w, -MAX_HEALTH, 10.);\n    c.w = (MAX_HEALTH + c.w) / (MAX_HEALTH + 10.); // scale to [0,1]\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}