{
    "Shader": {
        "info": {
            "date": "1478864810",
            "description": "Inspired by [url=https://www.shadertoy.com/user/xorxor]xorxor[/url]'s work I recreated a [url=http://dvdp.tumblr.com/post/130583230673/150505]davidope[/url] gif in a shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "MtdSRM",
            "likes": 16,
            "name": "Zebra Drops",
            "published": 3,
            "tags": [
                "raymarch",
                "metaballs",
                "drop",
                "split",
                "dvdp"
            ],
            "usePreview": 0,
            "username": "s23b",
            "viewed": 935
        },
        "renderpass": [
            {
                "code": "#define AA 2.\n#define FAKE_AA 1\n#define MAX_STEPS 50\n\n#define NEAR .001\n#define FAR 10.\n\n#define FALL_SPEED 2.5\n#define BALL_SIZE .6\n#define FALL_FREQ 9.\n#define TEXTURE_SPEED 2.\n#define SMOOTH 1.\n\n#define PI 3.14159265359\n#define SQ2 1.41421356237\n\n#define saturate(x) clamp(x, 0., 1.)\n\nvoid tRotate(inout vec2 p, float angle) {\n    float s = sin(angle), c = cos(angle);\n\tp *= mat2(c, -s, s, c);\n}\n\nfloat tRepeat1(inout float p, float r) {\n    float id = floor((p + r * .5) / r);\n    p = mod(p + r * .5, r) - r * .5;\n    return id;\n}\n\nvec3 tFallRepeat(vec3 p, float angle) {\n    tRotate(p.xy, angle);\n    p.y += iTime * FALL_SPEED;\n    tRepeat1(p.y, FALL_FREQ);\n    return p;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat opSmoothUnion(float a, float b) {\n    float h = saturate(.5 + .5 * (b - a) / SMOOTH);\n    return mix(b, a, h) - SMOOTH * h * (1. - h);\n}\n\nfloat opSmoothIntersect(float a, float b) {\n    return -opSmoothUnion(-a, -b);\n}\n\nfloat map(vec3 p) {\n    float falling = opSmoothIntersect(sdSphere(tFallRepeat(p, 0.), BALL_SIZE), -p.y);\n    tRotate(p.yz, PI / 3.);\n    float split1 = opSmoothIntersect(sdSphere(tFallRepeat(p, -PI / 4.), BALL_SIZE), (p.y - p.x) * SQ2);\n    float split2 = opSmoothIntersect(sdSphere(tFallRepeat(p, PI / 4.), BALL_SIZE), (p.y + p.x) * SQ2);\n    float split = opSmoothUnion(split1, split2);\n    return opSmoothUnion(split, opSmoothUnion(sdSphere(p, 1.), falling));\n}\n\nfloat trace(vec3 o, vec3 r, out float steps) {\n\n    float t = 0.;\n    steps = 0.;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        float d = map(o + r * t);\n        t += d * 1.;\n        ++steps;\n        if (d < NEAR || t > FAR) break;\n    }\n    \n    return t;\n}\n\nvec3 render(vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 3.));\n    vec3 o = vec3(0, 0, -6.5);\n    \n    vec2 mouse = iMouse.z > 0. ? iMouse.xy / iResolution.xy * 2. : vec2(1., -.3);\n    mouse *= PI;\n    tRotate(r.yz, -mouse.y);\n    tRotate(r.xz, -mouse.x);\n    tRotate(o.yz, -mouse.y);\n    tRotate(o.xz, -mouse.x);\n    \n    float steps = 0.;\n    float f = trace(o, r, steps);\n    steps /= float(MAX_STEPS);\n    steps *= steps;\n    \n    vec3 p = o + f * r;\n    \n    float scroll = p.y * 5. - TEXTURE_SPEED * iTime;\n    \n    #if FAKE_AA\n    vec3 c = vec3(saturate(sin(scroll * PI * 2.) * 8. + .5));\n    #else\n    vec3 c = vec3(fract(scroll) < .5);\n    #endif\n    \n    c -= steps;\n\treturn f < FAR ? c : vec3(0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    \n    fragColor = vec4(0);\n    \n    for (float x = 0.; x < AA; ++x) {\n    \tfor (float y = 0.; y < AA; ++y) {\n            fragColor.rgb += render(fragCoord + vec2(x, y) / AA);\n        }\n    }\n        \n\tfragColor /= AA * AA;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}