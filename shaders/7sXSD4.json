{
    "Shader": {
        "info": {
            "date": "1618639678",
            "description": "intersecting circles with fake preservation of total area.\nwas watching kids play with soap bubbles.\nblue circle is twice the area of lavender.",
            "flags": 0,
            "hasliked": 0,
            "id": "7sXSD4",
            "likes": 7,
            "name": "the case of the missing area",
            "published": 3,
            "tags": [
                "bubbles"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 266
        },
        "renderpass": [
            {
                "code": "// Fork of \"boilerplate stuff\" by elenzil. https://shadertoy.com/view/7dX3R2\n// 2021-04-17 05:07:53\n\n\nfloat sdDisk(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdCircle(in vec2 p, in float r) {\n    return abs(sdDisk(p, r));\n}\n\nfloat sdAnnulus(in vec2 p, in float r1, in float r2) {\n    return abs(sdDisk(p, (r1 + r2) / 2.0)) - (r2 - r1) / 2.0;\n}\n\nvoid drawDisk(inout vec3 color, in vec3 colorNew, in vec2 p, in vec2 c, in float r) {\n    color = mix(color, colorNew, 0.2 * smoothstep(gSmoothEps, -gSmoothEps, sdDisk  (p - c, r)));\n    color = mix(color, colorNew,       smoothstep(gSmoothEps, -gSmoothEps, sdCircle(p - c, r)));\n}\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    setupCoords(iResolution.xy, 0.95);\n    setupTime(iTime);\n\n    // draw something\n    \n    vec2 p = worldFromScreen(XY);\n    vec2 m = worldFromScreen(iMouse.xy);\n    \n    const vec3 colBG  = vec3(0.2, 0.3, 0.4);\n    const vec3 colFG1 = vec3(1.0, 0.9, 1.0);\n    const vec3 colFG2 = vec3(0.8, 0.9, 0.6);\n    const vec3 colFG3 = vec3(0.4, 0.5, 0.6);\n    \n    float gutter = min(100.0, iResolution.x * 0.06);\n    \n    // c2 = the moving circle\n    vec2  c2 = iMouse.x <= gutter ? vec2(cos(gTime * 1.1), sin(gTime * 0.9)) * 0.7 : m;\n    float r2 = 0.3;\n    \n    // c1 = the stationary circle\n    vec2  c1 = vec2(0.0);\n    float r1 = 0.3;\n    float my = iMouse.y / iResolution.y * 3.0;\n    if (iMouse.x <= 1.0) {\n        r1 = r2;\n    }\n    else if (iMouse.x <= gutter) {\n        if (my < 1.0) {\n            r1 = mix(0.0, r2, my);\n        }\n        else if (my < 2.0) {\n            r1 = r2;\n        }\n        else {\n            r1 = mix(r2, 1.0 / sqrt(2.0), my - 2.0);\n        }\n        \n    }\n    \n    // c3 = same as c1, but twice the area and static.\n    vec2  c3 = c1;\n    float r3 = r1 * sqrt(2.0);\n    \n    // d = the distance from center to center\n    float d = length(c2 - c1);\n    \n    // R = r1 + r2\n    float R12 = r1 + r2;\n    \n    // i = gap between boundaries. (> 0 = apart, < 0 = overlap)\n    float i = d - R12;\n    i = max(i, -2.0 * min(r1, r2));\n    \n    // i1 = overlap contributed by truncated circle c1\n    // i2 = overlap contributed by truncated circle c2\n    // i1 + i2 = i.\n    float i1 = i * r2 / R12;\n    float i2 = i * r1 / R12;\n    \n    // a1 = overlap area from c1. (guessing at formula)\n    // a2 = overlap area from c2. (guessing at formula)\n    float a1 = PI * r1 * i1;\n    float a2 = PI * r2 * i2;\n    \n    a1 = min(0.0, a1);\n    a2 = min(0.0, a1);\n    \n    // adjust radii to account for additional area, if any.\n    r1 = sqrt((PI * r1 * r1 - a1) / PI);\n    r2 = sqrt((PI * r2 * r2 - a2) / PI);\n   \n    vec3 col = colBG;\n    if (XY.x < gutter) {\n        float tmp = iMouse.y;\n        if (iMouse.x > gutter || (iMouse.y / iResolution.y * 3.0 > 1.0 && iMouse.y / iResolution.y * 3.0 < 2.0)) {\n            tmp = iResolution.y / 2.0;\n        }\n        if (XY.y / iResolution.y * 3.0 < 1.0 || XY.y / iResolution.y * 3.0 > 2.0) {\n            col *= 1.1;\n        }\n        col *= 1.0 + 0.3 * smoothstep(2.5, -2.5, abs(XY.y - tmp));\n    }\n    col *= 1.0 + 0.3 * smoothstep(2.5, -2.5, abs(XY.x - gutter));\n    \n    if (sdDisk(p - c1, r1) < 0.0 && sdDisk(p - c2, r2) < 0.0) {\n        col *= 1.0 + (int(XY.y) % 10 < 3 ? 0.5 : 0.0);\n    }\n\n    // disk of twice r1, for reference.\n    drawDisk(col, colFG3, p, c3, r3);\n    \n    drawDisk(col, colFG1, p, c1, r1);\n    drawDisk(col, colFG2, p, c2, r2);\n    \n    \n    \n    RGBA = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI  = 3.14159265359;\nconst float TAO = PI * 2.0;\n\n// global time parameter\nfloat gTime;\n\nvec2  gCanvasRes;\nfloat gCanvasSmallRes;\nfloat gZoom;\nfloat gScreenFromWorldFac;\nfloat gWorldFromScreenFac;\nfloat gSmoothEps;\n\n// set up world coordinates where a unit circle fits\n// in the smallest dimension of the canvas, plus a zoom factor.\nvoid setupCoords(in vec2 canvasResolution, in float zoom) {\n\n    gCanvasRes = canvasResolution;\n\n    // the smallest dimension of the canvas\n    gCanvasSmallRes = min(canvasResolution.x, canvasResolution.y);\n    \n    // small = shrink\n    gZoom = zoom;\n    \n    // factor to get from world scale to screen scale\n    gScreenFromWorldFac = gZoom * gCanvasSmallRes / 2.0;\n    \n    // factor to get from screen scale to world scale\n    gWorldFromScreenFac = 1.0 / gScreenFromWorldFac;\n    \n    // pixel epsilon for smoothstep\n    gSmoothEps = gWorldFromScreenFac * 2.5;\n}\n\nvec2 worldFromScreen(in vec2 screenPt) {\n    return (screenPt - gCanvasRes / 2.0) * gWorldFromScreenFac;;\n    \n}\n\n// in case we want to speed or slow down things from iTime.\n// this needs to be called in each pass.\nvoid setupTime(in float time) {\n    gTime = time;\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}