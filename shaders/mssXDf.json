{
    "Shader": {
        "info": {
            "date": "1669712431",
            "description": "simple colorful particles system",
            "flags": 32,
            "hasliked": 0,
            "id": "mssXDf",
            "likes": 90,
            "name": "Particles Party",
            "published": 3,
            "tags": [
                "particles"
            ],
            "usePreview": 0,
            "username": "leon",
            "viewed": 1547
        },
        "renderpass": [
            {
                "code": "\n// Particles Party\n\n// simple colorful particles system\n// will try voronoi tracking next time\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    \n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    float rng = texture(iChannel1, fragCoord/1024.).r;\n    vec2 aspect = vec2(iResolution.y/iResolution.x, 1.);\n    \n    // data\n    vec4 data = texture(iChannel0, uv);\n    float shade = data.r;\n    float mat = data.g;\n    \n    // rainbow\n    color = .5+.5*cos(vec3(1,2,3)*4.9 + mat);\n    \n    // light\n    vec3 un = vec3(0.005*aspect, 0);\n    #define T(un) texture(iChannel0, uv+un).r\n    vec3 normal = normalize(vec3(T(un.xz)-T(-un.xz),T(un.zy)-T(-un.zy), .5));\n    float d = dot(normal, normalize(vec3(0,-2,1)))*.5+.5;\n    color += pow(d, 10.);\n    \n    // shadow\n    color *= smoothstep(.0,.01,shade);\n\n    fragColor = vec4(color, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nconst float count = 100.;\n\nfloat speed = .3;\nfloat friction = 3.;\nfloat fade = 0.1;\nfloat thin = 0.02;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // buffer\n    vec4 frame = texture(iChannel0, uv);\n    \n    // pixels are data (bottom left)\n    if (fragCoord.y < 1. && fragCoord.x < count)\n    {\n        float id = fragCoord.x;\n            \n        // init\n        if (iFrame < 1)\n        {\n            // random position and velocity\n            frame = vec4(hash41(id)*2.-1.);\n            frame.zw *= .01;\n        }\n        else\n        {\n            // coordinates\n            vec2 aspect = vec2(iResolution.x/iResolution.y, 1.);\n            vec2 p = frame.xy;\n            vec2 offset = vec2(0);\n            vec2 target = vec2(0);\n            \n            // respawn\n            float t = iTime * 10.;\n            float idd = id+floor(t) * count;\n            if (hash11(idd) > .95 && fract(t) < .1)\n            {\n                frame = hash41(idd)*2.-1.;\n                frame.xy *= aspect;\n                frame.zw *= .01;\n                fragColor = frame;\n                return;\n            }\n            \n            // interaction\n            if (iMouse.z > 0.)\n            {\n                target = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n            }\n            \n            // curl\n            float noise = fbm(vec3(p, length(p) + iTime));\n            float a = noise * 6.28;\n            offset += vec2(cos(a), sin(a));\n            \n            // target\n            offset += normalize(target.xy-p) * 2. * length(target.xy-p);\n            \n            // jitter\n            offset += (hash21(id)*2.-1.)*(.5+.5*sin(iTime));\n            \n            // inertia\n            vec2 velocity = frame.zw;\n            velocity = velocity * (1.-friction*iTimeDelta) + offset * speed * iTimeDelta;\n            \n            // apply\n            frame.xy += velocity;\n            frame.zw = velocity;\n        }\n    }\n    \n    // pixels are colors\n    else\n    {\n        float matID = 0.;\n        float dist = 100.;\n        float dither = texture(iChannel1, fragCoord/1024.).r;\n\n        for (float i = 0.; i < count; ++i)\n        {\n            // iterate pixel data\n            vec4 data = texelFetch(iChannel0, ivec2(i,0), 0);\n            \n            // circle shape (jitter blending with previous pos)\n            vec2 pos = data.xy - data.zw * dither;\n            float shape = length(pos-p);\n            matID = shape < dist ? i : matID;\n            dist = min(dist, shape);\n        }\n\n        // grayscale\n        float shade = smoothstep(thin,.0,dist);\n\n        // buffer\n        frame.r = max(frame.r - fade, shade);\n        \n        // material layer\n        if (dist < thin) frame.g = matID;\n    }\n    \n    fragColor = frame;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nfloat gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }\nfloat fbm (vec3 seed)\n{\n    float result = 0., a = .5;\n    for (int i = 0; i < 3; ++i, a/=2.)\n    {\n        result += (gyroid(seed/a))*a;\n    }\n    return result;\n}\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}