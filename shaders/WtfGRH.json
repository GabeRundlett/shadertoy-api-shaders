{
    "Shader": {
        "info": {
            "date": "1556045641",
            "description": "Cloned my sci-fi building a few times, added textures and lighting.\nReduce AA_QUALITY if your frame rate is bad.",
            "flags": 32,
            "hasliked": 0,
            "id": "WtfGRH",
            "likes": 19,
            "name": "Sunset Sci-Fi Skyline",
            "published": 3,
            "tags": [
                "raymarch",
                "sunset",
                "sdf",
                "light",
                "scifi",
                "atmosphere",
                "architecture",
                "mood"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 943
        },
        "renderpass": [
            {
                "code": "// Sci-fi Building Shapes\n// by Hazel Quantock 2019\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n\nconst float whiteSoftness = 0.15; // this mostly affects the diffuse light - rewind to recompute it!\n\n\nvec3 HDRtoLDR( vec3 col )\n{\n    // soft clamp to white (oh this is so good)\n    float w2 = whiteSoftness*whiteSoftness;\n    col += w2;\n    col = (1.-col)*.5;\n    col = 1. - (sqrt(col*col+w2) + col);\n    \n    col = clamp( col, 0., 1. );\n\n    // linear to sRGB (approx)\n    col = pow( col, vec3(1./2.2) );\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    fragColour = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n    \n\t// Apply Bloom\n    const int numBloomSamples = 100;\n    float a = 0.;\n    vec3 bloom = vec3(0);\n    float sumWeight = 0.;\n    for ( int i=0; i < numBloomSamples; i++ )\n    {\n        float r = float(i)/float(numBloomSamples-1);\n        float weight = 1.-r*r*r;\n\n        r *= .07;\n        vec2 uv = vec2( cos(tau*a), sin(tau*a) ) * r;\n\n\t    bloom += weight * texture( iChannel0, (fragCoord + uv*iResolution.y)/iResolution.xy ).rgb;\n        sumWeight += weight;\n        \n        a = fract(a+phi);\n    }\n    \n    bloom /= sumWeight;\n    fragColour.rgb = mix( fragColour.rgb, bloom, .2 );\n\n    fragColour.rgb = HDRtoLDR(fragColour.rgb);    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Sci-fi Building Shapes\n// by Hazel Quantock 2019\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\nconst float phi = 1.6180339887498948;\nconst float tau = 6.2831853071795865;\n\n// from here: https://www.shadertoy.com/view/4dVBzz\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 (1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) ((p)*M1)\n#define coord2(p) ((p).x*M1^(p).y*M2)\n#define coord3(p) ((p).x*M1^(p).y*M2^(p).z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\n\nconst vec3 sunDir = normalize(vec3(-1,.05,-3));\n\nvec3 GetFogColour( vec3 dir )\n{\n//    return mix( vec3(1.6,.8,.2), vec3(3,2,.2), pow(smoothstep(-1.,1.,dot(dir,sunDir)),20.) );\n//    return mix( vec3(1.6,.8,.2), vec3(3,2,.2), pow(max(0.,dot(dir,sunDir)),20000.) );\n    vec3 col = vec3(.1);//.8,.2,.08);\n\tcol = mix( col, vec3(1.6,.8,.13)*2., pow(max(0.,dot(dir,sunDir)),50.) );\n    \n    return col;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Sci-fi Building Shapes\n// by Hazel Quantock 2019\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n\n// cloud code actually not currently used, but I don't want to delete it because it looked nice!\nfloat Multifractal( vec3 pos )\n{\n    float rot = tau*1./3.;\n    float c = cos(rot);\n    vec2 s = sin(rot)*vec2(-1,1);\n    vec3 p = pos;\n    p.xy = p.xy*c + p.yx*s;\n    float f = 0.;\n    float strength = 1.;\n    for ( int octave=0; octave < 4; octave++ )\n    {\n        f += texture(iChannel0,p).r*strength;\n        // scale to next octave\n        p *= 2.;\n        strength *= .5;\n        // to hide the grid artefacts, rotate the coordinates\n        p.xyz = p.yzx;\n        p.x = -p.x;\n\t    p.xy = p.xy*c + p.yx*s;\n    }\n    \n    // normalize values into [0,1] range\n    f /= (2.-strength*2.); // e.g. (1+.5+.25) / (2.-.125*2.) = 1.\n    \n    return f;\n}\n\n\nfloat cloudSDF( vec3 pos )\n{\n    return Multifractal(pos/300.);\n}\n\n\nvoid mainCubemap( out vec4 fragColour, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    //if ( iFrame > 1 ) discard;\n    \n\t// i was planning to do a complicated volumetric cloud thing here but fake ones look fine.\n\n    // Ray direction as color\n    vec3 col;/* = mix( vec3(.5,.7,1), vec3(2), smoothstep(.3, 1., cloudSDF(rayDir*vec3(15,30,15)) ) );\n    col = mix( col, vec3(.2,.1,0), smoothstep(.3, 1., cloudSDF(rayDir*vec3(15,33,15)) ) );\n    \n    col = mix( col, vec3(.3,.35,.4), smoothstep( .0, -.02, rayDir.y ) );*/\n\n\tcol = GetFogColour(rayDir);\n\tcol = mix( col, vec3(100,8,.8), smoothstep(.99994,.99997,dot(rayDir,sunDir)) );//pow(max(0.,dot(rayDir,sunDir)),20000.) );\n    \n    // Output to cubemap\n    fragColour = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "// Sci-fi Building Shapes\n// by Hazel Quantock 2019\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n// reduce this to improve frame rate in windowed mode (0 disables anti-aliasing)\n#define AA_QUALITY 3\n\n// allow a little bleed between pixels - I think this looks more photographic, but blurrier\n#define AA_ROUND false\n#define AA_ROUND_RADIUS 0.7071\n\n\nfloat Polygon( vec2 uv, float h, uvec3 seed )\n{\n    vec4 rand1 = hash4(coord3(uvec3(seed.xy,seed.z+0u)));\n    vec4 rand2 = hash4(coord3(uvec3(seed.xy,seed.z+3u)));\n    \n    float mid = (rand1.x-.5)*exp2(-h*2.);\n    float f = abs(uv.y-rand1.y+.5)-rand1.z-2.; //2.*mix(1.,rand(),.5+.5*h); // so 1.+rand->2.*rand\n    f = max(f,abs(uv.x-mid)-rand1.w-.5+h*.4); //1.5*mix(1.,rand(),.7+.3*h);\n    f = max(f,abs(dot(uv,vec2(1,1)/sqrt(2.))-rand2.x+.5)-rand2.y-1.);\n    f = max(f,abs(dot(uv,vec2(1,-1)/sqrt(2.))-rand2.z+.5)-rand2.w-1.);\n    \n    // support-stalk\n    //f = min(f,max(uv.y,abs(uv.x-mid)-.1));\n    \n    return f;\n}\n\n\nfloat BevelMax( float a, float b, float bevelSize )\n{\n    return max(max(a,b), dot(vec2(a,b),normalize(vec2(.5,1))) + bevelSize );\n}\n\n\nvec3 ReflectSpace( vec3 p )\n{\n    // mirror - to make interesting shapes and break up grid\n    p.x = abs(p.x+7.)-7.;\n    float aa = .5;\n    p.xz = p.xz*cos(aa)+p.zx*sin(aa)*vec2(1,-1);\n    p.x = abs(p.x+1.)-1.; aa = -.5; p.xz = p.xz*cos(aa)+p.zx*sin(aa)*vec2(1,-1);\n    return p;\n}\n\nconst vec3 cellSize = vec3(3.,7.,4.);\n\nvec4 SDF( vec3 p )\n{\n    p = ReflectSpace(p);\n    \n    // wrap space into a grid, and take the grid cell index as a hash\n    p.xz = p.xz/cellSize.xz+.5;\n    \n    ivec2 gridCoord = ivec2(floor(p.xz));\n    uvec2 gridCoordHash = uvec2(gridCoord) + 1u;\n    p.xz = (fract(p.xz)-.5)*cellSize.xz;\n    \n    vec4 rand = hash4(coord2(gridCoordHash));\n    \n    // adjust building height randomly and radially\n    float h = mix( .1, 1., clamp( 1.2*pow(rand.w/(dot(vec2(gridCoord),vec2(gridCoord))*.004+1.),4.), 0., 1. ) );\n    \n\t// octahedral, but with random distances so some planes won't be seen\n    float a = Polygon( p.zy-vec2(0,3.5*h-3.5), 0., uvec3( gridCoordHash, 1u ) );\n    float b = Polygon( p.zy-vec2(0,4.5*h-2.5), .5, uvec3( gridCoordHash, 2u ) );\n    float c = Polygon( p.zy-vec2(0,5.5*h-1.5), 1., uvec3( gridCoordHash, 3u ) );\n\n/*    vec3 f = vec3(a,min(a,b),min(min(a,b),c));\n    f = max( f, vec3(abs(p.x)-.2) );\n    return min( f.z, p.y+.5 ); // ground*/\n    \n    float w = abs(p.x);\n\n    float ground = p.y+.5;\n    \n    float A = BevelMax(a,w-max(.02,rand.x),.1);\n    float B = BevelMax(b,w-max(.02,rand.y),.03);\n    float C = BevelMax(c,w-max(.02,rand.z),.1);\n    \n    float f = min(min(min(A,B),C),ground);\n    \n    // bounds - make sure we don't need to sample adjacent grid cells to get a valid SDF value\n    float bounds = max( .5 + p.y*.01, p.y-7. ); // n.b. don't let it be flat - it breaks the normals\n    f = min(f,bounds);\n    \n    float windowMask = min(min(max(a,w-rand.x+.2),max(max(max(b+.2,-abs(a-.05)+.15),-abs(c-.05)+.1),w-rand.y)),max(c,w-rand.z+.2));\n\n    // indent windows - doesn't work, flat spaces inside the window regions of the SDF\n    //f = max(f,-windowMask);//min(-windowMask,f+.01));\n    \n    return vec4(\n        f,\n        // mask for windows\n        windowMask,\n        // mask for stripes\n        max(min(a,c),-b)+.1,\n        0.);\n}\n\n\n\n// higher precision trace function canibalised from one of my other shaders - not sure if this is the best version but it's good enough\nconst float epsilon = .0004;\nfloat Trace( vec3 rayStart, vec3 rayDirection, float far )\n{\n    float t = 0.;\n    \n    float h = 0.;\n    float lasth = 0.;\n    float bestt = 0.;\n    float bestDist = 1e30;\n    float sdf = 0.;\n    for ( int i=0; i < 200; i++ )\n    {\n        lasth = h;\n        sdf = SDF( rayDirection*t+rayStart ).x;\n        h = sdf + epsilon*.5;\n\t\tt += h;\n        if ( t > far ) return 1e10;\n        if ( sdf < bestDist ) { bestt = t; bestDist = sdf; } // not sure if all these conditionals will compile well, could flip to use step and mix\n        if ( h < epsilon ) break;\n    }\n\n    if ( sdf == bestDist )\n    {\n        // improve precision\n\t\tfloat lastt = t-epsilon;\n\t\tfloat lastsdf = SDF( rayDirection*lastt+rayStart ).x;\n\t\tfloat sdf = SDF( rayDirection*t+rayStart ).x;\n       \tt = mix( lastt, t, (0.-lastsdf)/(sdf-lastsdf) );\n    }\n    else if ( t < bestt*2. )\n    {\n        // use the closest sample we had, to avoid sampling back-sides and things\n        t = bestt;\n\t\t// this can add a fringe, but maybe better than the alternative\n    }\n    \n    return t;\n}\n\n\nvec3 GetNormal( vec3 p )\n{\n    vec2 d = vec2(-1,1)*epsilon;\n    return normalize(\n        \tSDF(p+d.xxx).x*d.xxx +\n        \tSDF(p+d.yyx).x*d.yyx +\n        \tSDF(p+d.yxy).x*d.yxy +\n        \tSDF(p+d.xyy).x*d.xyy\n        );\n}\n\n\nvoid mainImage2( out vec4 fragColour, in vec2 fragCoord )\n{\n//    seed = uint(iTime/2.);\n    \n    vec3 camPos = vec3(3,2.5,10);//vec3(-10,2.5,-6);\n    vec3 camTarget = vec3(0,2.5,0);\n    float zoom = 5.0;//1.6;\n    \n    if ( iMouse.z > 0. )\n    {\n        camPos.y = 12.*iMouse.y/iResolution.y+.000001;\n        float a = .5*tau*(iMouse.x/iResolution.x-.5);\n\t    camPos.xz = camPos.xz*cos(a)+vec2(1,-1)*sin(a)*camPos.zx;\n    }\n    else\n    {\n\t    float a = 0.;//iTime*.1;\n\t    camPos.xz = camPos.xz*cos(a)+vec2(1,-1)*sin(a)*camPos.zx;\n\t    camPos += vec3(.8)*sin(iTime*vec3(1,.618,1.11)*.618*.5);\n\t    camTarget += vec3(.2,.15,.2)*(smoothstep(-.7,.7,sin(iTime*vec3(1,.618,1.11).zyx+2.))*2.-1.);\n\t    camTarget += vec3(.3,.0,.3)*(smoothstep(-.7,.7,sin(iTime*.5*vec3(1,.618,1.11).zyx))*2.-1.);\n\n        vec3 parallax = -vec3(4,0,-1)*sin(iTime/20.)*3.;\n        camPos += parallax;\n        camTarget += parallax*1.2;\n        \n        zoom = mix(zoom,3.5,smoothstep(-.5,1.,sin(iTime)+sin(iTime*.618)));\n    }\n    \n    vec3 camK = normalize(camTarget - camPos);\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n#if 1\n    // architectural projection (non-orthographic)\n    camJ = vec3(0,1./sqrt(camJ.y),0);  // (0,1,0) works too, but causes more vertical stretching at steep angles\n    camK *= sqrt(camJ.y);\n#endif\n    \n    vec3 ray = vec3( (fragCoord-iResolution.xy*.5)/iResolution.y, zoom );\n    ray = ray.x*camI + ray.y*camJ + ray.z * camK;\n    ray = normalize( ray );\n    \n    float t = Trace( camPos, ray, 64. );\n    vec3 pos = camPos+t*ray;\n    \n    if ( t < 1e10 && SDF(pos).x < .1 )\n    {\n        vec4 sdf = SDF(pos);\n        vec3 normal = GetNormal(pos);\n        vec3 uvw = ReflectSpace(pos);\n        vec3 tileuvw = (fract( uvw/cellSize + .5 ) - .5) * cellSize;\n        ivec2 gridCoord = ivec2(floor(uvw.xz/cellSize.xz+.5));\n        uvec2 gridCoordHash = uvec2(gridCoord) + 1u;\n        \n        // concrete\n/*        vec3 albedo = smoothstep(.6,.8,hash3(coord2(gridCoordHash)) - vec3(0));\n//        albedo = .05 + (albedo.x*vec3(.25,.45,.25) + albedo.y*vec3(.7,.2,0) + albedo.z*vec3(0,.3,.7))*.5;\n        albedo = .75 - albedo.x*vec3(.5,0,0) - albedo.y*vec3(.0,.5,0) - albedo.z*vec3(.2,.2,.7);*/\n        \n        vec4 rand = hash4(coord2(gridCoordHash));\n        \n        vec3 albedo = mix( vec3(.05),vec3(.5), smoothstep(.1,.4,rand.x) );\n        \n        // coloured stripes\n        if ( sdf.z < 0. )\n        {\n            vec3 stripeColour = vec3(1,.1,0)*step(rand.y,.9) + vec3(0,.3,1)*step(.7,rand.y);\n        \talbedo = mix( albedo, stripeColour, step( .0, max( .1-abs(tileuvw.z-.1), .03-abs(tileuvw.z+.06) ) ) );\n        }\n        \n        vec3 emission = vec3(0);\n        vec3 specularLevel = vec3(pow((1.4-1.)/(1.4+1.),2.)); // schlick\n        float specAmp = .5; // hack so I don't have to blur reflections for rough surfaces\n        \n        if ( pos.y < -.49)\n        {\n\t        // ground\n            vec2 uv = uvw.xz/cellSize.xz;\n            uv = fract( uv/2. )*2.;\n\n            vec2 roads = vec2(\n                    min( abs(uv.x-.5), abs(uv.x-1.5)-.08 ),\n                    min( abs(uv.y-.5), abs(uv.y-1.5)-.05 )\n                );\n\n            albedo = vec3(.1);\n\n            albedo = mix( albedo, vec3(.6), smoothstep( .0075, .0025, max(abs(roads.y-.0),(abs(fract(roads.x*5.-.3)-.5)-.25)/5.) ) );\n            albedo = mix( albedo, vec3(.6), smoothstep( .0075, .0025, max(abs(roads.x+.02),(abs(fract(roads.y*5.-.4)-.5)-.25)/5.) ) );\n\n            albedo = mix( albedo, vec3(1,0,0), smoothstep( .0075, .0025, min( abs(roads.x-.10), abs(roads.y-.10) ) ) );\n            vec2 kerb = min(roads-.09,0.);\n            albedo = mix( albedo, vec3(1), smoothstep( .006, .002, abs(length( kerb )-.035) ) );\n            albedo = mix( albedo, vec3(.3), smoothstep( .025, .02, length( kerb ) ) );\n        }\n        else\n        if ( sdf.y < .001 )\n        {\n            vec4 rand = hash4(coord3(uvec3(ivec3(uvw/vec3(.04,.06,.04)))));\n            \n            rand.x = (rand.x+iTime/65536.);\n            rand.x = rand.x-floor(rand.x); // for some reason the compiler was getting confused by fract\n            \n            // shiny glass\n            albedo = vec3(.001);\n            emission = .7*(vec3(2,1,0)*rand.z+vec3(1,1.5,2)*rand.y)*smoothstep(.8,.95,rand.x);\n            specularLevel = vec3(pow((1.4-1.)/(1.4+1.),2.)); // schlick\n            specAmp = 1.;\n            normal += (rand.yzw-.5)*.03;\n            normal = normalize(normal);\n        }\n        \n\n        if ( Trace( pos+sunDir*.001-normal*SDF(pos).x, sunDir, 20. ) > 1e2 )\n        {\n        \tfragColour.rgb = vec3(2,1.2,.2)*.7*max( dot(normal,sunDir), 0. );\n        }\n        \n        float aoStep = 1.;\n        float ao = smoothstep(-1.,1.,SDF(pos+normal*aoStep).x/aoStep);\n        aoStep = .4;\n        ao = mix( ao, smoothstep(-1.,1.,SDF(pos+normal*aoStep).x/aoStep), .5 );\n        aoStep = .15;\n        ao = mix( ao, smoothstep(-1.,1.,SDF(pos+normal*aoStep).x/aoStep), .4 );\n        \n        fragColour.rgb += ao*.5*mix( vec3(.1,.06,.03), vec3(.4,.25,.15), .5+.5*normal.y );\n\n//fragColour.rgb *= .4;\n        \n        vec3 fresnel = specAmp * mix( specularLevel, vec3(1.), pow( clamp(dot(normal,ray)+1.,0.,1.), 5. ) );\n        vec3 reflection = texture( iChannel0, reflect(ray,normal) ).rgb;\nreflection *= 0.;//.2;\n        \n        fragColour.rgb = mix( albedo*fragColour.rgb + emission, reflection, fresnel );\n        \n//fragColour.rgb = vec3( .5+.5*sdf.y/(abs(sdf.y)+.1) );        \n        \n        // fog\n        fragColour.rgb = mix( GetFogColour(ray), fragColour.rgb, exp2(-t*vec3(1.2,.2,.4)/50.) );\n    }\n    else\n    {\n        //fragColour.rgb = vec3(.5,.7,1);\n        fragColour.rgb = texture( iChannel0, ray ).rgb;\n    }\n    \n    // chop off colours so fog doesn't make things look so faint (i.e. increase contrast selectively)\n    fragColour.rgb -= vec3(.05);\n    fragColour.rgb = max(fragColour.rgb,0.);\n    \n    // exposure - let it fluctuate a little with the camera zooms to feel more real\n    fragColour.rgb *= mix(.6,.3,smoothstep(.0,1.,sin(iTime-.5)+sin(iTime*.618-.3)));\n    \n    fragColour.a = 1.;\n}\n\n\n// Anti-aliasing\n// this doesn't work perfectly because some of the values are brighter than white so they eat into the AA\n// bloom should cover this up pretty well\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n#if ( AA_QUALITY == 0 )\n    mainImage2( fragColour, fragCoord );\n#else\n    int numSamples = max( 1, int((1920.*1080.*float(AA_QUALITY)*.2) / (iResolution.x*iResolution.y)) );\n\n    vec4 colSum = vec4(0);\n    for ( int i=0; i < numSamples; i++ )\n    {\n        uvec2 quasi2 = uvec2(0xC13FA9A9u,0x91E10DA5u);\n        uint seed = uint(i);\n        //seed += uint(iFrame*numSamples); // randomize per frame - causes shimmering\n        //seed += uint(fragCoord.x)*quasi2.x+uint(fragCoord.y)*quasi2.y; // randomize per pixel - this looks bad at low sample counts (and at high counts it's less important)\n        vec2 jitter = vec2( quasi2 * seed ) / exp2(32.);\n\n        if ( AA_ROUND )\n        {\n            // circle of confusion slightly bigger than a pixel - should look more photographic\n            jitter.x *= 6.283185;\n            jitter = AA_ROUND_RADIUS*(1.-jitter.y*jitter.y)*vec2(cos(jitter.x),sin(jitter.x));\n        }\n        else\n        {\n            jitter -= .5;\n        }\n        \n        vec4 col;\n        mainImage2( col, fragCoord + jitter );\n        colSum += col;\n    }\n   \n    fragColour = colSum/float(numSamples);\n#endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}