{
    "Shader": {
        "info": {
            "date": "1692893524",
            "description": "poto",
            "flags": 32,
            "hasliked": 0,
            "id": "clsfW8",
            "likes": 28,
            "name": "Day 1344",
            "published": 3,
            "tags": [
                "pathtracing",
                "monochrome",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 527
        },
        "renderpass": [
            {
                "code": "// Fork of \"Day 60smth WIP\" by jeyko. https://shadertoy.com/view/7tjXWd\n// 2023-08-24 08:52:32\n\n// box intersection from IQ\n\nvoid mainImage( out vec4 C, in vec2 U){\n    vec2 uvn = U.xy/R;\n\n    C= max(texture(iChannel1,U/R),0.);\n    C = min(C,0.95);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R iResolution.xy\n#define T(u) texture(iChannel0,(u)/R)\n#define NO_INTERSECTION -1.123456\n\n#define Ta(u) texture(iChannel0,u)\n#define Tb(u) texture(iChannel1,u)\n#define Tc(u) texture(iChannel2,u)\n#define Td(u) texture(iChannel3,u)\n#define iTime (iTime + 25.)\n\nuint seed = 111425u;\n\nuint hash_u(uint _a) {\n   uint a = _a;\n   a ^= a >> 16;\n   a *= 0x7feb352du;\n   a ^= a >> 15;\n   a *= 0x846ca68bu;\n   a ^= a >> 16;\n   return a; \n}\n\nfloat hash_f(){ uint s = hash_u(seed); seed = s;return ( float( s ) / float( 0xffffffffu ) ); }\nvec2 hash_v2(){ return vec2(hash_f(), hash_f()); }\nvec3 hash_v3(){ return vec3(hash_f(), hash_f(), hash_f()); }\nvec4 hash_v4(){ return vec4(hash_f(), hash_f(), hash_f(), hash_f()); }\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv ){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up * uv.y);\n}\nvec3 tonemap_uchimura2(vec3 v)\n{\n    const float P = 4.;  // max display brightness\n    const float a = 2.5;  // contrast\n    const float m = 0.2; // linear section start\n    const float l = 0.;  // linear section length\n    const float c = 1.3; // black\n    const float b = 0.;  // pedestal\n\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    vec3 w0 = 1.0 - smoothstep(0.0, m, v);\n    vec3 w2 = step(m + l0, v);\n    vec3 w1 = 1.0 - w0 - w2;\n\n    vec3 T = m * pow(v / m, vec3(c)) + vec3(b);\n    vec3 S = P - (P - S1) * exp(CP * (v - S0));\n    vec3 L = m + a * (v - vec3(m));\n\n    return T * w0 + L * w1 + S * w2;\n}\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nfloat r11(float g){return fract(sin(g*12.5)*4.5);}\n\nvec3 temp_norm;\nfloat boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out bool inters_inside) {\n    //boxSize -= 0.004;\n    // convert from ray to box space\n\tvec3 rdd = (vec4(rd,0.0)).xyz;\n\tvec3 roo = (vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    \n    vec3 n = m*roo;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x,t1.y),t1.z);\n    float tF = min(min(t2.x,t2.y),t2.z);\n    \n    // no intersection\n\tif( tN>tF || tF<0.0 ) return NO_INTERSECTION;\n    \n    // use this instead if your rays origin can be inside the box\n    inters_inside = tN < 0.0;\n    vec4 res = !inters_inside ? vec4( tN, step(vec3(tN),t1)) :\n                          vec4( tF, step(t2,vec3(tF)));\n    //vec4 res = vec4(tN, step(tN,t1) );\n    \n    temp_norm = (vec4(-sign(rdd)*res.yzw,0.0)).xyz;\n\n    \n    return res.x;\n}\n\n\n#define pi acos(-1.0)\n#define tau (2.*pi) \n\n#define pmod(p,a) mod(p,a) - 0.5*a\n\nfloat hash_f_s(uint s){ s = hash_u(s); return ( float( s ) / float( 0xffffffffu ) ); }\n// vec2 hash_22_s(uvec2 s){ uint _s = hash_u(s.x) + hash_u(s.y); return vec2(hash_f_s(_s.x), hash_f_s(_s.y)); }\nfloat hash_21_s(ivec2 _s_){ \n  uvec2 s = uvec2(_s_ + 2000);\n  uint _s = hash_u(s.x + hash_u(s.y)) + hash_u(s.y + hash_u(s.x)); \n  return hash_f_s(_s); \n}\nfloat valueNoise( in vec2 p ){\n    p += 100.;\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\n    // cubic interpolant\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash_21_s( i + ivec2(0,0) ), \n                     hash_21_s( i + ivec2(1,0) ), u.x),\n                mix( hash_21_s( i + ivec2(0,1) ), \n                     hash_21_s( i + ivec2(1,1) ), u.x), u.y);\n}\n/*\nvoid mainImagea( out vec4 C, in vec2 U){\n    vec2 uvn = U.xy/R;\n\n    C = T(U);\n    C -= C;\n    vec2 uv = (U - 0.5*R)/R.y;\n    vec2 muv = (iMouse.xy - 0.5*R)/min(R.y,R.x);\n    \n    vec3 ro = vec3(\n        sin(muv.x*pi)*cos(muv.y*pi/1.),\n        cos(muv.y*pi/1.),\n        cos(muv.x*pi)*cos(muv.y*pi/1.)\n    )*0.4;\n    \n    vec3 rd = getRd(ro,vec3(0.0),uv);\n    const float bayer[] = float[64](\n         0./63., 32./63., 8./63., 40./63., 2./63., 34./63., 10./63., 42./63., \n        48./63., 16./63., 56./63., 24./63., 50./63., 18./63., 58./63., 26./63., \n        12./63., 44./63., 4./63., 36./63., 14./63., 46./63., 6./63., 38./63.,\n        60./63., 28./63., 52./63., 20./63., 62./63., 30./63., 54./63., 22./63., \n         3./63., 35./63., 11./63., 43./63., 1./63., 33./63., 9./63., 41./63., \n        51./63., 19./63., 59./63., 27./63., 49./63., 17./63., 57./63., 25./63.,\n        15./63., 47./63., 7./63., 39./63., 13./63., 45./63., 5./63., 37./63.,\n        63./63., 31./63., 55./63., 23./63., 61./63., 29./63., 53./63., 21./63.\n    );    \n\tvec2 buv = mod(floor(U.xy), 8.);\n\tfloat bay = bayer[int(buv.x) + int(buv.y)*8];\n    \n    //seed += uint(bay*64.);\n    \n    vec3 p = ro;\n    //rd = normalize(vec3(uv,0.5));\n    \n    float t = iTime + sin(iTime + 3.);\n    //rd.xz *= rot((t)*0.4);\n    //rd.xy *= rot((t)*0.4);\n    vec3 thr = vec3(1);\n    \n    vec3 em = vec3(0);\n    \n    for(float bnc = 0.; bnc < 1.; bnc++){\n        vec2 box = intersect(p,rd);\n        p = p + rd *  (box.x > 0. ? box.x : box.y);\n        vec4 c = get(p);\n        \n        thr *= c.xyz;\n        if(c.w > 0.1){\n            em += c.xyz*c.w;\n        }\n        \n        \n        float bncSubCnt = 1240.;\n        \n        p += n*0.002;\n        \n        vec3 subs = vec3(0);\n        for(float bncSub = 0.; bncSub < bncSubCnt; bncSub++){\n            vec3 brd = randomCosineHemisphere(n*1.);\n            \n            vec2 scene = intersect(p,brd);\n            \n            vec3 pp = p + brd * (scene.x > 0. ? scene.x : scene.y);\n            vec4 c = get(pp);\n            if(c.w > 0.03){\n                subs += thr * c.xyz / bncSubCnt;\n                em += c.w * thr * c.xyz / bncSubCnt;\n            }\n            \n            //att *= c;\n        \n            //vec2 \n        }\n        thr *= subs;\n    }\n    C.xyz += em;\n    \n    \n    if(iFrame == 0){\n        C = vec4(0,0,0,1);\n    }\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n\nfloat sdBox(vec2 p, vec2 sz){\n    p = abs(p) - sz;\n    return max(p.x,p.y);\n}\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    vec2 uvn = (U - 0.5*R.xy)/min(R.x,R.y);\n    C = vec4(0);\n    int F = iFrame % 120;\n    seed += uint(iFrame/120)*1000u;\n    if(F == 0){ \n        C = Ta(uv);\n        C.w = 1.0;\n    } else{\n        if(F == 1){\n            uv += step(valueNoise( uv*rot(5.5+ hash_f()*20.)*vec2(0.01,5.) ),0.5)*0.4;\n            C = Tb(uv); \n            if(sdBox(mod(uvn*rot(0.) - hash_v2()*1. - 0.5,4.), vec2(0.7,5.)) < 0.){\n                C.w = 15.;\n                C += 11.5;\n            }  \n        } else if (F == 2){\n            uv -= smoothstep(valueNoise( uv*rot(5.5 + hash_f()*20.)*vec2(0.01,5.) ),0.1,0.104)*0.4;\n            C = Tb(uv)*vec4(0.5,1.5,1,1.) - Ta(uv*14.).yyyy; \n            \n            if(length(fwidth(uv)) > 0.5){\n                C = vec4(1);\n            }\n        } else if (F == 3){\n            uv -= smoothstep(valueNoise( uv*rot(5.5+ hash_f()*20. + 3.14/2.)*vec2(0.01,5.) + 5. * hash_f() ),0.1,0.104)*0.4;\n            C = Tb(uv)*vec4(1,1,1,1.); \n            C = Tb(uv + 0.1 * float(C.w > 0.9))*vec4(1,1,1,1.); \n            \n            if(length(fwidth(uv)) > 0.42){\n                C = vec4(1);\n            }\n        } else {\n            C = Tb(uv);\n            \n            if(hash_f() > 0.5 || true){\n                C = Ta(uv*1.);\n                uv -= vec2(dFdx(C.y),dFdy(C.x))*0.41 * mix(0.,2.5,hash_f());\n                vec2 muv = (iMouse.xy - 0.5*R.xy)/min(R.x,R.y);\n                //C.xy += -15.*vec2(dFdx(C.y),dFdy(C.x))*0.41 * mix(7.,.5,hash_f());\n                //uv -= vec2(1)*rot(hash_f()*20.)*step(valueNoise( uv*rot(5.5+ hash_f()*20.)*vec2(0.01,5.) ),0.5)*0.001;\n                \n                C = Tb(uv);\n            }\n        }\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 29,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    vec2 uvn = (U - 0.5*R.xy)/min(R.x,R.y);\n    C = vec4(0);\n\n  const float bayer[] = float[64](\n     0./63., 32./63., 8./63., 40./63., 2./63., 34./63., 10./63., 42./63., /* 8x8 Bayer ordered dithering */\n    48./63., 16./63., 56./63., 24./63., 50./63., 18./63., 58./63., 26./63., /* pattern. Each input pixel */\n    12./63., 44./63., 4./63., 36./63., 14./63., 46./63., 6./63., 38./63., /* is scaled to the 0..63 range */\n    60./63., 28./63., 52./63., 20./63., 62./63., 30./63., 54./63., 22./63., /* before looking in this table */\n     3./63., 35./63., 11./63., 43./63., 1./63., 33./63., 9./63., 41./63., /* to determine the action. */\n    51./63., 19./63., 59./63., 27./63., 49./63., 17./63., 57./63., 25./63.,\n    15./63., 47./63., 7./63., 39./63., 13./63., 45./63., 5./63., 37./63.,\n    63./63., 31./63., 55./63., 23./63., 61./63., 29./63., 53./63., 21./63.\n  );    \n    \n    C = Ta(uv);\n    C = C + texture(iChannel0,uv,2. + mod(iTime*float(sin(iTime*5.)>0.),2.))*0.1;\n    vec4 oC = C;\n\t//vec2 fuv = floor((uv + 5.)/ sc) * sc;\n\t//vec2 buv = mod(fuv/sc, 8.);\n    \n    float luma = dot(C.xyz,C.xyz);\n    \n    seed = uint(iFrame/60);\n\n    vec2 bay_mult = vec2(1.0,4.);\n    \n    if(luma  < 0.42){\n        bay_mult *= 2.;\n    } else if(luma > 0.02){\n        bay_mult.y *= 1. + 1114442. * fwidth(oC.w);\n        if(fwidth(oC.x) > 0.07){\n            bay_mult *= 4.;\n        }\n    }\n    \n    \n\tvec2 buv = mod(floor(U.xy/bay_mult), 8.);\n    \n\tfloat bay = bayer[int(buv.x) + int(buv.y)*8];\n    if(C.w > 0.8){\n        if(luma > bay){\n            C = vec4(1);\n        } else {\n            C = vec4(0);\n        }\n    } else {\n        if(luma > 0.02){\n            C = vec4(1);\n        } else {\n            C = vec4(0);\n        }\n    }\n    //C = 1.-C;\n    C.x += dFdx(oC.w)*1.;\n    vec4 atten = 1.-vec4(hash_f(),1.- hash_f(),hash_f(),1)*50.;\n    for(int i = 0; i < 4; i++){\n        seed = uint(iFrame/60 + i);\n        C[i] += fwidth(oC.x * valueNoise( uvn*1. + 4.))*(\n            atten[i]\n        );\n    }\n    //C = pow(abs(C),vec4(14.4545));\n    C = clamp(C,0.,1.);\n    C = 1.-C;\n    //C -= 0.5;\n    //C = pow(abs(C),vec4(2.2,1.9,0.9,0.9));\n    if(C.x < 0.1){\n        C += 0.1;\n    }\n    C -= 0.05 * valueNoise( uvn*400.) + 0.02;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define pi acos(-1.0)\n//#define tau 2.*pi\n\n#define pmod(p,a) mod(p,a) - 0.5*a\nvec3 gp;\nvec3 norm;\nfloat id;\nfloat inside = -1.;\nvec4 get(vec3 p){\n    //return vec4(0.5,0.5,0.2,1.);\n    if(inside > 0.){\n        //return vec4(0.2,0.2,0.2,1.)*0.;\n    }\n    bool h = dot(norm,vec3(-1)) > 0.; \n    if(h){\n        p.xz = -p.xz/4.;\n    }\n    int im = (iFrame + int(id)*40) % 240;\n    vec4 c = vec4(texture(iChannel0,\n        im < 60 ? p.yy*0.2 : p.zx*.22\n        ,0.).xyz,1.0);\n    if(h){\n        c.w = 0.;\n        c.xyz = 1.-c.xyz;\n        c *= 0.3;\n        c = max(c,0.1);\n    }\n    //c = clamp(c,0.0,1.);\n    return c;\n}\n\nvec2 dmin(vec2 a, float b, float id){\n    if(abs(id - inside) < 0.002){\n        return a;\n    }\n    vec2 inters = a;\n    \n    if((b - NO_INTERSECTION) < 0.04){\n    } else if (\n        ( b < a.x) ||\n        a.x - NO_INTERSECTION < 0.02\n        ) {\n        inters = vec2(b, id);\n        norm = temp_norm;\n    }\n    return inters;\n}\nvec2 intersect(vec3 ro, vec3 rd){\n    vec2 ba = vec2(NO_INTERSECTION);\n    bool inters_inside;\n    ba = dmin(ba,boxIntersection(ro,rd,vec3(10.2,0.1,11.4),inters_inside),1.);\n    ba = dmin(ba,boxIntersection(ro +0.0*vec3(0,-1.5+ valueNoise(vec2(iTime*1.))*.5,0.),rd,vec3(0.4,.2,0.4),inters_inside),2.);\n    ba = dmin(ba,boxIntersection(ro - vec3(0,0,0),rd,vec3(0.1,0.3,0.1),inters_inside),0.1);\n    ba = dmin(ba,boxIntersection(ro + vec3(0,0,2.),rd,vec3(2.4,1.,0.4),inters_inside),4.);\n    //ba = dmin(ba,boxIntersection(ro + vec3(0,0,-1.),rd,vec3(10.4,0.1,0.4),inters_inside),5.);\n    \n    id = ba.y;\n    \n    \n    if(ba.x != NO_INTERSECTION && inside < 0.){\n        vec3 ro = ro + rd * ba.x + 1. + sin(floor(iTime));\n        vec2 md = vec2(1.5) + vec2(1,0)*mod(floor(iTime),2.)*0.6;\n        ivec2 id = ivec2(ro.xz/md);\n        ro.xz = mod(ro.xz,md) - 0.5*md;\n        \n        float s = hash_21_s(ivec2(id + iFrame/50));\n        float inters = boxIntersection(ro,rd,vec3(0.1,2.7,0.05)*s*md.xyx,inters_inside);\n        \n        if(inters != NO_INTERSECTION && inters_inside){\n            inside = ba.y;\n            ba.x = inters;\n            //ba = vec2(inters,2.);\n            norm = -temp_norm;\n            //norm = -norm;\n        }\n        //if()\n        //if()\n    \n    }\n    //ba = dmin(ba,boxIntersection(ro - vec3(0.2),rd,vec3(5.,0.2,5.)),1.);\n    return ba;\n}\n\n\n/*\nvec2 dmin(vec2 a, float id, vec4 b ){\n    if (a.x < b.x ||  b.x == NO_INTERSECTION){\n    \treturn a;\n    } else if (  m.w < 1. ){\n\t\tglow += shade(id,b.x,b.yzw);\n        return a;\n    } else {\n        N = b.yzw;\n        return vec2(b.x,id);\n    }\n    \n}\n*/\nvec3 rand_sphere_dfox(){\n    float z = hash_f() * 2.0f - 1.0f;\n    float a = hash_f() * tau;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nvec3 randomCosineHemisphere(vec3 n){\n    return normalize(rand_sphere_dfox() + n);\n}\n\nvoid mainImage( out vec4 C, in vec2 U){\n    vec2 uvn = U.xy/R;\n\n    C = T(U);\n    C = vec4(0);\n    vec2 uv = (U - 0.5*R)/R.y;\n    \n    vec2 muv = (iMouse.xy - 0.5*R)/min(R.y,R.x);\n    \n    vec3 ro = vec3(0.1);\n    vec3 rd = normalize(vec3(uv,0.5));\n    \n    muv = vec2(0.3,-0.1);\n    \n    muv.x += sin(iTime*0.4 + sin(iTime*0.6))*0.1;\n    muv.y += sin(iTime*0.7 + sin(iTime*0.4))*0.05;\n    float t = iTime + sin(iTime + 3.);\n    //rd.xz *= rot((t)*0.4);\n    vec3 lookat = vec3(0.0,-0.2,0);\n    \n    lookat += sin(vec3(0.5,0.2,0.6)*iTime)*0.1;\n    //rd.xy *= rot((muv.x)*1.4);\n    if(true){\n        ro = vec3(\n            sin(muv.x*pi)*cos(muv.y*pi/1.),\n            sin(muv.y*pi/1.),\n            cos(muv.x*pi)*cos(muv.y*pi/1.)\n        )*2.5 + vec3(0,-0.8,0);\n        rd = getRd(ro,lookat,uv*(0.35 + sin(iTime*0.2 + sin(iTime*0.3))*0.1));\n    }\n    vec2 buv = mod(floor(U.xy), 8.);\n    seed += uint(texelFetch(iChannel1,ivec2(buv),0)*64.0)*4u;\n\t//float bay = bayer[int(buv.x) + int(buv.y)*8];\n    \n    \n    vec3 p = ro;\n    vec3 thr = vec3(1);\n    \n    vec3 acc = vec3(0);\n    for(float bnc = 0.; bnc < 1.; bnc++){\n        vec2 res = intersect(p,rd);\n        if(abs(res.x - NO_INTERSECTION) > 0.02){\n            vec3 N = norm;\n            p = p + rd*res.x;\n            vec4 c = get(p);\n\n            thr *= c.xyz;\n            if(c.w > 0.2){\n                acc += c.xyz*c.w*0.5;\n            }\n\n\n            float bncSubCnt = 184.;\n\n            p += N*0.002;\n\n            vec3 subs = vec3(0);\n            for(float bncSub = 0.; bncSub < bncSubCnt + min(float(iFrame),0.); bncSub++){\n                vec3 brd = randomCosineHemisphere(N);\n\n                vec2 res = intersect(p,brd);\n                \n                vec3 pp = p + brd * res.x;\n                vec4 c = get(pp);\n                if(c.w > 0.02 && abs(res.x - NO_INTERSECTION) > 0.002){\n                    subs += thr * c.xyz / bncSubCnt;\n                    acc += c.w * thr * c.xyz / bncSubCnt;\n                } else {\n                    acc += .8*thr * vec3(0.2,0.2,0.2) * (0.4 + .6*float(0.4*mod(iTime,4.) < 1.)) / bncSubCnt;\n                \n                }\n\n                //att *= c;\n\n                //vec2 \n            }\n        } else {\n            acc += 1.0;\n        }\n    }\n    C.xyz += acc;\n    \n    \n    C.xyz = tonemap_uchimura2(C.xyz*4.5);\n    //C = C/(1.+C);\n    C*=1.1;\n    C = pow(C,vec4(.4545));\n    //C = clamp(C,0.,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// idk where this is from, copied from noby shader\n\nfloat FXAAamt = 0.5;\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec2 pp = 1. / iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3 luma = vec3(.299, 0.587, 0.114);\n    \n    float lumaNW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0/8.0)), (1.0/128.0));\n\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        fragColor = vec4(rgbA, color.w);\n    } else {\n        fragColor = vec4(rgbB, color.w);\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}