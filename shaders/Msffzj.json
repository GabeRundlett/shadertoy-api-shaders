{
    "Shader": {
        "info": {
            "date": "1497050585",
            "description": "Used as visuals in cooperation of polish demoscene musicians. \nReleased in wild compo at Decrunch copy party, 3 June 2017\n \nhttp://www.pouet.net/prod.php?which=70247",
            "flags": 64,
            "hasliked": 0,
            "id": "Msffzj",
            "likes": 20,
            "name": "â™« Power Packed Alliance 6",
            "published": 3,
            "tags": [
                "tunnel",
                "demoscene"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 947
        },
        "renderpass": [
            {
                "code": "/*\n\n\tTunnel6 a.k.a \"Polish up\"\n    for cooperation of polish demoscene musicians, called:\n    \n    \n    \"Power Packed Alliance\".\n    -----------------------------------\n\n\thttps://www.youtube.com/watch?v=_lSReW7eRI4\n    http://www.pouet.net/prod.php?which=70247\n\n\t\n    \n    also check my chrome extension for Shadertoy:\n    https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl?hl=pl\n\n*/\n\n#define getNormal getNormalHex\n\n#define INFINITY 1e32\n#define FAR 30.\n#define t iTime\n#define mt iTime * 1.2 \n#define FOV 90.0\n#define FOG .7\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nvec3 os;\n\nvec3 pal( in float ta, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){return a + b*cos( 6.28318*(c*ta+d) );}\n\n// \t3D noise function (IQ)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nfloat yC(float x) {\n \treturn cos(x * -.134) * 1. * sin(x * .13) * 15.+ noise(vec3(x * .01, 0., 0.) * 55.4);\n}\n\nfloat vol = 0.;\n\nvec3 light = vec3(0.0);\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nvec3 opS2( vec3 d1, vec3 d2 )\n{\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCross(vec3 p, vec3 size) {\n    float obj = fBox(p, size);\n    obj = opU2(obj, fBox(p, size.zxy));\n    obj = opU2(obj, fBox(p, size.yzx));               \n    return obj;\n}\n\nvec3 map(vec3 p) {\n    p.y -= yC(p.x);\n    vec3 \n        obj = vec3(FAR, 0.0, 0.0),\n        obj2 = obj,\n        obj3 = obj;\n    \n    vec3 orgP = p;\n    vec3 orgP3 = orgP;\n\n\torgP3 = p;\n    \n    vec3 pp = pMod3(orgP3, vec3(2.4));\n    p = orgP3;\n    \n    obj = vec3(\n        fBox(p, vec3(1.05)), \n        1.0, \n        1.0\n    );\n    \n    vec3 orgP2 = orgP;\n    \n    pR(orgP.zy, orgP.x / 12.);\n\t\n    vec3 size = vec3(0.725 , 1.5, 1.275);\n    \n    p = opRep(orgP, vec3(0.35, 0.1, .4) + size.x + size.y + size.z);\n    \n    obj = opS2(\n        obj, \n        vec3(                \n            fCross(p, size), \n            0.0, \n            1.0\n        )\n    );\n\t\n    size *= 1.2;\n    p = opRep(orgP, vec3(0.35, 0.5, 0.1) + size.x + size.x + size.z);\n    \n    obj = opS2(\n        obj, \n        vec3(                \n            fCross(p, size), \n            0.0, \n            1.0\n        )\n    );\n    p = orgP2;\n    float n = noise(p);\n  \tpR(p.yz, p.x * .8 + n * 7.);\n    p.y += .6;\n   \n    p = orgP2;\n\n    obj = opS2(obj, vec3(fCross(p, vec3(1e32, .6, .6) ), 1., 1.)); \n\n\tobj3.x = mix(-length(p.zy) + 1., obj3.x,  .6  *  n)- .1;\n    obj3 = opU2(obj, vec3(fBox(p, vec3(1.1))));\n\tos = p;\n    \n    return obj3;\n}\n\nvec3 trace(vec3 prp, vec3 scp) {\n    vec3 \n        tr = vec3(0., -1., 0.),\n        d;\n    \n    for (int i = 0; i < 164; i++) {\t\n        d = map(prp + scp * tr.x);\n        tr.x += d.x * .4;\n\n        if ((abs(d.x) < .0001) || (tr.x > FAR)) break;\n    }\n    \n    tr.yz = d.yz;\n\treturn tr;\n    \n}\nvec3 traceRef(vec3 ro, vec3 rd) {\n    vec3 \n        tr = vec3(0., -1., 0.),\n        d;\n    \n    for (int i = 0; i < 50; i++) {\n        d = map(ro + rd * tr.x);\n        tr.x += d.x;\n        \n        if (abs(d.x) < 0.0055 || tr.x> FAR) break;\n    }\n    \n    tr.yz = d.yz;\n    return tr;\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 12;\n    vec3 rd = (lp - ro); \n\n    float shade = .1;\n    float dist = 2.2;\n    float end = max(length(rd), 0.001);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).x;\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.), 1.0);\n}\n\n\n#define EPSILON .1\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).x;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).x-d,\n                map(pos+vec3(0,EPSILON,0)).x-d,\n                map(pos+vec3(0,0,EPSILON)).x-d \n        \t)\n    \t);\n}\n\nfloat getAO(in vec3 hitp, in vec3 normal)\n{\n    float dist = 0.2;\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).x;\n    return clamp(sdist / dist, 0.0, 1.0);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, inout vec2 mat) {\n    vec3 col = vec3(.4, 0.6, 1.);    \n\t\n    col = pal( p.x * 0.01, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n   \tcol *= 1.+ pow(noise( os * 5.) * noise(p * 3.2), 1.);\n    \n    return col;\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, inout vec2 mat) {\n\tvec3 sceneCol = vec3(0.0);\n    \n    vec3 ld = lp - sp; \n    float lDist = max(length(ld), 0.001); \n    ld /= lDist;\n\n    float atten = max(0.1, 2.0 / (1.0 + lDist * .525 + lDist * lDist * 1.05));\n    float diff = max(dot(sn, ld), .1);\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), .5), 2.0);\n   \n    vec3 objCol = getObjectColor(sp, sn, mat);\n    sceneCol += (objCol * (diff + 0.15) + vec3(.3, .4, .6) * spec * 1.) * atten;\n\n    return sceneCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n\tuv.x /= iResolution.y / iResolution.x;\n    \n    uv *= tan(radians (FOV) / 2.0);\n    \n    vol = texture(iChannel0, vec2(.0, .25)).r  * 1.; \n    \n    float \n        sk = sin(mt * .2) * 2.0,\n        ck = cos(mt * .3) * 2.0,\n        \n        mat = 0.;\n    \n    light = vec3(0., 0., 11.);        \n    \n    vec3 sceneColor = vec3(0.);\n    float camx = mt;\n    \n    vec3 \n        vuv = vec3(0., 1., 0.),\n    \tro = vec3(camx, yC(camx), 0.),\n    \tvrp =  vec3(camx + 1., yC(camx + 1.5), 0.),\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro);        \n\t\n    light = ro;\n    \n    vec3 lp = vrp;\n    \n\tvec3 orgRO = ro,\n         orgRD = rd;\n\t\n    vec3 tr = trace(ro, rd), otr;\n    \n    float fog = smoothstep(FAR * FOG, 0., tr.x * 1.);\n    \n    ro += rd * tr.x;\n    otr = ro;\n    \n    vec3 sn = getNormal(ro);\t\n    float ao = getAO(ro, sn);\n   \t\n    sceneColor += doColor(ro, rd, sn, lp, tr.yz);\n    \n    float dist = tr.x;\n    \n    rd = reflect(rd, sn);\n    tr = traceRef(ro + rd * .03, rd);\n    ro += rd * tr.x;\n    sn = getNormal(ro);\n    sceneColor += doColor(ro, rd, sn, lp, tr.yz) * .3;\n\n    fragColor = vec4(clamp(sceneColor * 1.3, 0.0, 1.0), tr.x / FAR);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 9942,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/decrunch/power-packed-alliance"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}