{
    "Shader": {
        "info": {
            "date": "1700531575",
            "description": "based on jt's xor https://www.shadertoy.com/view/ssG3WK#\n\nsmooth xor attempt--just an approximate distance field now..\n\nxor is pretty cool for 2d shapes, but in 3d will make it hollow :(\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ctyyzd",
            "likes": 6,
            "name": "Xor smooth",
            "published": 3,
            "tags": [
                "sdf",
                "xor"
            ],
            "usePreview": 0,
            "username": "Dain",
            "viewed": 187
        },
        "renderpass": [
            {
                "code": "// https://www.shadertoy.com/view/ssG3WK XOR SDF by jt\n// \n// Wrote this as a private test a while ago (found a backup from 2021-09-21)\n// switched to unlisted 2023-10-30 to ask iq about xor sdf exactness\n// made it public 2023-11-20 now that iq wrote an article about it :-)\n// Jakob Thomsen\n//\n// Related:\n//\n// The 2023-11-20 article https://iquilezles.org/articles/sdfxor/ by Inigo Quilez.\n// \n// https://www.shadertoy.com/view/3t33WH Interior Distance by iq\n// https://www.shadertoy.com/view/DdX3WH Interior Distance Detect Errors, jt\n//\n// Operators union, subtraction, intersection do NOT always give a valid sdf,\n// as iq explains in https://iquilezles.org/articles/interiordistance\n//\n// Does the symmetric difference always result in a valid signed distance field?\n// In the comments iq provided the following proof:\n// \"Yes, it is. You can see this by expanding the arithmetic of the four cases:\n//  1) a>0, b>0 --> xor(a,b) = max(min(a,b),-max(a,b)) =  min( a, b) =  min(a,b)\n//  2) a<0, b>0 --> xor(a,b) = max(min(a,b),-max(a,b)) =  max( a,-b) = -min(-a,b)\n//  3) a>0, b<0 --> xor(a,b) = max(min(a,b),-max(a,b)) =  max(-a, b) = -min(a,-b);\n//  4) a<0, b<0 --> xor(a,b) = max(min(a,b),-max(a,b)) = -max( a, b) =  min(-a,-b)\n// All four cases reduce to a min() of exterior distances (that is, to a min of two positive arguments),\n// which as we know is always exact. So the XOR(a,b) is exact.\"\n// Thanks! Shadertoy is a really wonderful project!\n\n// Licence: The xor function is public domain.\n\nconst float smooth_r = .1;//smooth radius(0 is invalid)\n\n//smin attempt:  adjusted for smooth xor so that it transitions between + and - space smoothly\n//the problem is smin with a and b both being 0 does not return 0\n//a and b need to be positive\n//https://www.desmos.com/calculator/udwbmuagmm\nfloat smin_xor(float a, float b, float r) {\n    float e = max(r - abs(a - b),0.0);\n    \n    float rcp_r = 1.0/r;\n    //a fade so we get smooth transition for sxor between + and - space\n    //..this might cause rate of change to be > 1-- oh well for now.. at least it is very close to surface\n    float f = min(min(a,b)*rcp_r,1.0);\n\n   //slow down the transition to hard \n    f = f+f -f*f;\n\n\n    return min(a, b)- e*e*rcp_r*.25 *f;\n\n}\n//has some issues when xor goes from + to - space--the distance value jumps--this is because \n//we don't get 0 when and a and b are both 0\nfloat smin(float a, float b, float r) {\n    float e = max(r - abs(a - b),0.0);\n    \n    return min(a, b)- e*e* (1.0/(r*4.0));\n\n}\n\nfloat sgn(float a){\n    return a >=0.0 ? 1.0 : -1.0;\n}\n//smooth xor\n//radius of 0 is invalid\nfloat sxor(float a, float b, float r){\n    //see IQ article: https://iquilezles.org/articles/sdfxor/\n    //where he shows it can be written this way\n     return sgn(a)*sgn(b)*smin_xor(abs(a), abs(b),r );\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) // https://iquilezles.org/articles/distfunctions\n{\n    vec2 q = abs(p) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat sdCircle( vec2 p, float r ) // https://iquilezles.org/articles/distfunctions\n{\n    return length(p) - r;\n}\n\n\n\n// It seems like xor does not have the problems explained in https://www.shadertoy.com/view/3t33WH Interior Distance by iq\n// Confirmed in this new article https://iquilezles.org/articles/sdfxor/ by iq\nfloat xor(float a, float b)\n{\n    // NOTE: XOR can be implemented via sign but sign is buggy on some platforms as spalmer found out.\n    return max(min(a, b), -max(a, b));\n}\n\nfloat map(vec2 p)\n{\n\n    \n    float m = abs(sin(iTime));\n\t//float a = sdBox(p-vec2(m,0), vec2(0.5));\n    float b = sdCircle(p+vec2(m,0), sqrt(0.5));\n    float a=  sdCircle(p-vec2(m,0), sqrt(0.5));\n    \n    float d = sxor(a, b,smooth_r); \n\n    float n = abs(cos(iTime*.9));\n    float c = sdCircle(p+vec2(0.0,n), sqrt(0.5));\n    float e = sdCircle(p-vec2(0.,n), sqrt(0.5));\n    \n    float f = sxor(c, e,smooth_r);\n    \n    d = sxor(d, f,smooth_r);\n\n    return d-.01;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    float d = map(p);\n    /*\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n    */\n    // iq's sdf coloring\n    vec3 col = (d<0.0) ? vec3(0.6,0.8,1.0) : vec3(0.9,0.6,0.3);\n    col *= 1.0 - exp(-9.0*abs(d));\n\tcol *= 1.0 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n        d = map(m);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}