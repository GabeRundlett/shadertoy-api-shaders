{
    "Shader": {
        "info": {
            "date": "1608221832",
            "description": "potato",
            "flags": 32,
            "hasliked": 0,
            "id": "wsGBWd",
            "likes": 30,
            "name": "Day 357",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 1029
        },
        "renderpass": [
            {
                "code": "\n// CHEAP NOISE FROM NIMITZ https://www.shadertoy.com/view/XtS3DD\n// RENDERING TECHNIQUE LEARNED FROM IQ'S \"CLOUDS\"\n#define iTime (iTime + iMouse.x/iResolution.x)\n\nfloat valueNoise(in vec3 p,float pw)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod( iChannel0, (tap+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rz.x, rz.y, fp.z );\n}\n\n\nfloat fbm(vec3 p){\n\n    vec3 op = p;\n    float n = 0.;\n    p *= 0.5;\n    p.y += iTime*0.5;\n    float fa = valueNoise(p,1.); \n    \n    p.y += fa*(1. + sin(op.z + iTime*0.2)*0.5);\n    p.x += iTime*.325;\n    p.y -= iTime*0.25;\n    \n    float fb = valueNoise(p*2.,1.);\n    \n    \n    p.x += fb*.2 + iTime*0.1;\n    p.z += fb*1.1 + iTime*0.02;\n    float fd = valueNoise(p*9.8,1.);\n    \n    float fc = valueNoise(p*4.2,1.);\n    \n    \n\n    n = fa*1. + fb*0.55 + fc*0.244 + fd*0.146*(0.6 - fa) /*fa*/;// + valueNoise(op*5.8,1.)*0.0;\n    \n    \n    //n*= 1.1;\n    \n    //n = smoothstep(0.,1.,n);\n    //n = pow(n,1. + fa*2.);\n    \n    \n    //n *= pow(valueNoise(op + 24.,4.),0.4)*3.;\n    \n    \n    n*= 0.6;\n    \n    n = smoothstep(0.,1.,n);\n    n = pow(n,1. + fa*1.5);\n    \n    n *= pow(valueNoise(op*0.3 + 1.,1.),0.4)*1.;\n    n *= 2.4;\n    return clamp( (1. - op.y*0.1 + abs(op.x)*0.4 - 3.0 + 2.*n) , 0.0, 1.0 );\n\n\treturn n;\n}\n\n//vec3 ro;\n\nfloat map(vec3 p){\n    float d = 10e5;\n    vec3 op = p;\n    \n    p.xy *= rot(p.z*0.14);\n    \n    \n    p.z += iTime;\n    p.y += sin(iTime)*0.2 + 0.;\n    //p.xy *= rot(p.z*0.1);\n    \n    p.xy *= rot(sin(p.z*0.2 + iTime*0.2)*0.4);\n    \n    d = fbm(p);\n    \n    \n    float dopop = dot(op,op);\n    \n    d *= smoothstep(0.,1., (length(p.xy)*0.6 - 2.4)*smoothstep(1.,0.,\n        dopop*.03) + smoothstep(0.,1., dopop*.01)\n        );\n    \n    \n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.12,0.14,0.14)*1.6;\n    col = vec3(0.14,0.14,0.12)*1.6;\n\n\n    col += sin(uv.xyx*0.2 + iTime*0.4)*0.1;\n    \n    \n    col += sin(uv.xyx*0.2 )*0.1;\n    \n    vec3 lightDir = normalize(vec3(-1.,1.,2.));\n\n    mat2 lightRot = rot(iTime*0.5); \n    \n    lightDir.xy *= lightRot;\n    vec3 ro = vec3(0);\n    vec3 rd = normalize(vec3(uv,0.9));\n    \n    rd.yz *= rot(sin(iTime*0.25)*0.2);\n    \n    vec3 p = ro;\n    \n    \n    float stSz = 0.1;\n    float dTotal = 0.;\n    vec3 accum = vec3(0);\n    \n    ro += 0.2*rd*hash13(vec3(uv*220.,1.+ iTime*4.));\n    \n    vec3 lightCol;\n    \n    \n    \n    float steps = 200.;\n    float i = 0.;\n    float t = 0.;\n    for(; i < steps; i++){\n        float dCurr = map(p);\n        float dOther = map(p + lightDir*.15 );\n        \n        lightCol = vec3(0.4 + sin(iTime*0.25 + p.z*0.0)*0.2,0.2,0.1);\n        vec3 colDiff = vec3(0.115,0.4,0.4)*0. + col*0.7 + 32.7*lightCol*clamp((dCurr - dOther*1.)*0.6,0.,1.); \n        vec3 colAbsorption = mix(vec3(0.47 + sin(iTime + p.z)*0. - 0.2,0.5,.65)*0.5, vec3(0.4,0.2,0.9)*0.2, smoothstep(0.,1.,dTotal)); \n        vec3 colFringe = clamp( (1. - dCurr*2.)*lightCol*vec3(0.8,0.9,.9 )*0.2, 0., 1.);\n        \n        if(dTotal > 1. || t > 20222.){\n            break;\n        }\n        \n        \n        float fade = pow(smoothstep(0.,1.,(p.z - ro.z)*0.03),0.75);\n        \n        vec3 colCurr = mix( (colDiff)*colAbsorption + colFringe*1.9 , col, fade);\n        dCurr *=  1. -fade;\n        accum += dCurr*colCurr*(1. - dTotal)*stSz;\n        dTotal += dCurr*stSz*(1. - dTotal);\n        t += max(stSz,i/steps*2.*stSz);\n        //p += rd*t;\n        p = ro + rd*t;\n    }\n\n\n    //lightCol = vec3(0.4 + sin(iTime*0.45)*0.2,0.2,0.1);\n        \n    \n    col = mix(col,accum*1.,pow(dTotal, 1.) );\n    col += smoothstep(1.,0.,length( (uv + vec2(0.7,-0.4)*lightRot) ) + 0.1)*lightCol*(0.2 + 0.*accum*accum*dTotal);\n    \n    \n    col = mix(col,smoothstep(0.,1.,col*1.7),0.7);\n    col = mix(col,smoothstep(0.,1.,col*1.6),1.);\n    \n    col *= smoothstep(1.,0.3,dot(uv,uv)*0.6 + 0.2);\n    col = pow(max(col,0.),vec3(0.45454));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\nmat2 rot(float angle){\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\nfloat hash13(vec3 p3){\n    p3 = fract((p3)*0.1031);\n    p3 += dot(p3, p3.yzx  + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\nfloat valueNoiseo(vec3 uv,float pw){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    fd = pow(fd,vec3(pw));\n    \n    float ibl = hash13(id + vec3(0,-1,0));\n    float ibr = hash13(id + vec3(1,-1,0));\n    float itl = hash13(id + vec3(0));\n    float itr = hash13(id + vec3(1,0,0));\n    \n    \n    float jbl = hash13(id + vec3(0,-1,1));\n    float jbr = hash13(id + vec3(1,-1,1));\n    float jtl = hash13(id + vec3(0,0, 1));\n    float jtr = hash13(id + vec3(1,0, 1));\n    \n    \n    float ibot = mix(ibl, ibr, fd.x); \n    float iup = mix(itl, itr, fd.x);\n    float jbot = mix(jbl, jbr, fd.x);\n    float jup = mix(jtl, jtr, fd.x);\n    \n    float i = mix(ibot, iup, fd.y);\n    float j = mix(jbot, jup, fd.y);\n    \n    return mix(i, j, fd.z); \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}