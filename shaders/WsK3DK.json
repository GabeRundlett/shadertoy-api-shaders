{
    "Shader": {
        "info": {
            "date": "1570985419",
            "description": "A flying dragon in the sky with people looking at it",
            "flags": 0,
            "hasliked": 0,
            "id": "WsK3DK",
            "likes": 3,
            "name": "Shadertober 12 Dragon",
            "published": 3,
            "tags": [
                "raymarching",
                "dragon",
                "inktober"
            ],
            "usePreview": 0,
            "username": "GreenChicken",
            "viewed": 371
        },
        "renderpass": [
            {
                "code": "\n#define VOLUME 0.001\n#define PI 3.14159\n\n////////////////////////////////////////////////////////////////////////////////\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat sat(float a) {return clamp(a, .0, 1.); }\n\nfloat opU(float s1, float s2) { return min(s1, s2);}\n\nvec2 opU2(vec2 d1, vec2 d2) { return (d1.x < d2.x) ? d1 : d2; }\n\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdGuy(vec3 p, float h)\n{\n    p.y -= h*.5;\n    float t = sdBox(p, vec3(.05, h*.5, .025));\n    t = opU(t, sdBox(p+vec3(0.0, -h*.5-.025, 0.0), vec3(.025, .025, .025)));\n    return t;\n}\n\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\n\n\n\nvec2 sdLine( vec3 p, vec3 a, vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length( pa - ba*h ), h );\n}\n\nfloat sdSphere(vec3 pos, float r)\n{\n    return length(pos)-r;\n}\n\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2( mix( b.x, a.x, h ) - k*h*(1.0-h), mix( b.y, a.y, h ) );\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\n\n// -------------------------------------------------------------------------\n\nvec2 map(vec3 pos)\n{\n    vec2 t = vec2(0.0, -1.0);\n    \n    // ground\n    t.x = pos.y;\n    \n    vec3 gp = pos + vec3(0.0, 0.0, 0.0);\n    float ground = udTriangle(gp,\n        vec3(-1.4, 0.0, 3.3),\n        vec3(0.0, 0.0, 5.0),\n        vec3(2.2, 0.0, 5.0));\n    \n    // guys\n    vec3 g1p = pos + vec3(0.0, 0.0, -4.1);\n    g1p.xz *= rot(PI/6.0);\n    float g1 = sdGuy(g1p, .2);\n    float g2 = sdGuy(g1p+vec3(-0.4, 0.0, -.9), .2);\n    float g3 = sdGuy(g1p+vec3(0.2, 0.0, -.5), .2);\n    \n    float guys = opU(g1, g2);\n    guys = opU(guys, g3);\n    \n    // dragon\n    vec3 d = pos + vec3(4.0, -1.0, 0.0);\n    d.y += sin(pos.x+iTime)*.5;\n    float dragonLine = sdLine(d, vec3(0.0), d + vec3(1.0, 0.0, 0.0)).x;\n    float dragon = dragonLine - .2;\n    \n    // legs\n    vec3 ep = pos + vec3(0.0, sin(iTime)*.5-.7, -1.0);\n    float leg = sdLine(ep, vec3(0.0), ep + vec3(0.2, -.2, 0.0)).x - .05;\n    ep = pos + vec3(2.0, sin(pos.x+iTime)*.5-1.0, -1.0);\n    leg = opU(leg, sdLine(ep, vec3(0.0), ep + vec3(-0.15, -.15, 0.0)).x - .02);\n    \n    // head\n    vec3 hp = pos + vec3(-1.4, sin(pos.x+iTime)*.5-1.0, -2.0);\n    float head = sdLine(hp, vec3(0.0), hp + vec3(0.2, -.2, 0.0)).x - .02;\n    \n    t = vec2(ground, 0.0);\n    t = opU2(t, vec2(guys, 1.0));\n    t = opU2(t, vec2(dragon, 2.0));\n    t = opU2(t, vec2(leg, 2.0));\n    //t = opU2(t, vec2(head, 3.0));\n    \n    return t;\n}\n\nfloat GetShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 01.;\n    float t = VOLUME*50.;\n    for (float i = 0.; i <= 1.; i += 1./15.) {\n        vec2 dist = map(pos + dir * t);\n        if (dist.x < VOLUME) return 0.;\n        f = min(f, k * dist.x / t);\n        t += dist.x;\n        if (t >= maxt) break;\n    }\n    return f;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<64 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(t, ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nvec3 GetNormal (vec3 p) \n{ \n    vec2 e = vec2(0.01, 0.0); \n    return normalize(vec3(\n        map(p+e.xyy).x-map(p-e.xyy).x,\n        map(p+e.yxy).x-map(p-e.yxy).x,\n        map(p+e.yyx).x-map(p-e.yyx).x\n        )); \n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = ro+rd*t.x;\n    vec3 col = vec3(0.0);\n    float depth = clamp(pos.z, 0.0, 1.0);\n    depth = 1.0 - sat(pos.z*.1);\n            \n    if(t.x == -1.0)\n    {        \n        col = vec3(0.0);\n        \n    }\n    else\n    {\n        float glp = clamp(length(pos)*.1, 0.0, 1.0);\n        vec3 N = GetNormal(ro+rd*t.x);\n        vec3 L = vec3(3.0, 10.0, 0.0);\n        float light = dot(N,normalize(L));\n        float shade = GetShadow(pos, L, 4.);\n        \n        if(t.y == -1.0) \n        {\n            col = vec3(.2+pos.z*.1);\n            col *= shade;\n        }\n        else if(t.y == 0.0) // ground\n        {\n            col = vec3(.5);\n            col *= light;\n            col += shade*.5;\n        }\n        else if(t.y == 1.0) // guys\n        {\n            col = vec3(0.0);\n            col += light*.3;\n        }\n        else if(t.y == 2.0) // dragon\n        {\n            col = vec3(1.0);\n        }\n        else if(t.y == 3.0) // tongue\n        {\n            col = vec3(1.0, 0.0, 0.0);\n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 1.0 * forward);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float time = iTime*.25;\n    \n    vec3 cp = vec3(0.0, 2.0, 6.0);\n    vec3 ct = vec3(0.0, 0.0, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = vec3(length(uv));\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    col = Render(cp, vd, uv);\n    col.z += screenUV.y*.5;\n    col -= random(screenUV) * .1;\n    col *= 1.0-length(uv)*.4;\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}