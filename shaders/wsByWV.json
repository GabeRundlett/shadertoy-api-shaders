{
    "Shader": {
        "info": {
            "date": "1587452922",
            "description": "my first shader.\nTHIS SHADER IS BASED ON  \"[SH16C] Voxel Game\" by fb39ca4  ",
            "flags": 48,
            "hasliked": 0,
            "id": "wsByWV",
            "likes": 308,
            "name": "Voxel game Evolution",
            "published": 3,
            "tags": [
                "mc"
            ],
            "usePreview": 1,
            "username": "kastorp",
            "viewed": 28112
        },
        "renderpass": [
            {
                "code": "/*---------------------------------------------------------\n\tTHIS SHADER IS BASED ON  \"[SH16C] Voxel Game\" by fb39ca4  \n  \t\n\twhen switching to full screen press L until you get better performance (K for higher resolution)\n\nCONTROLS:\n    drag mouse to move view and select blocks\n    WASD or arrows to move\n    Space to jump\n    Double-tap space to start flying, use space and shift to go up and down.\n\n    mouse double click to select/unselect a block (doesn't work well with low framerate\n    Q + mouse button to place block \n    E + mouse button to destroy blocks \n\tR + mouse button to change shape of a block \n\tF + mouse button to rotate a shape on z axis \n\tG + mouse button to rotate a shape on y axis\n\tC + mouse button to select multiple blocks (hold on \"C\" to clear selection)\n\tdestroy,place, shape,rotate also work on selected blocks, without mouse button\n\n    mouse click on inventory to select a block type\n\tM to toggle map\n\tI to toggle inventory (hidden, simple, full)\n\n\tO,P to decrease/increase speed of day/night cycles   \n    k,L to decrease/increase pixel sizes \n\tT to teleport to a random location\n    Page Up/Down to increase or decrease zoom \n\tF7 enable/disable torch light diffusion (flickering on some GPUs)\n\tF8 enable/disable water flow\n\nBLOCK MECHANICS:\n\n\t TORCH= light\n\t TREE= grows if placed\n\t DIAMOND= illumninated if close to GOLD or other illuminated diamonds\n\t RED BLOCK= mirror \n\t WATER= semtrasparent, flows downwards\n\t SAND = falls if in empty space or with 4 horizontal steps\n\t PINK MARBLE= infinite water source\n\nCONFIGURATION:\n\tsee #define settings in \"Common\" file \n\nBUFFERS:\n    \"BUFFER A\": actions, collisions, settings, material textures\n    \"BUFFER B\": voxel cache, nearest blocks full height \n    \"BUFFER C\": surface voxel cache (just one block for every xy position)\n    \"BUFFER D\": rendering, map\n    \"IMAGE\"   : gui, stats\n\nCREDITS:\n\tVoxel game: @fb39ca4 https://shadertoy.com/view/MtcGDH\n\tVoxel traversal: @Iq https://www.shadertoy.com/view/4dfGzs\n\tGLSL Number Printing:  @P_Malin https://www.shadertoy.com/view/4sBSWW\n\tTextures: @Reinder https://www.shadertoy.com/view/4ds3WS\n\tencoding/decoding: @Eiffie https://www.shadertoy.com/view/wsBfzW\n\tgrass: @W23 https://www.shadertoy.com/view/MdsGzS\n\tNoise: @Makio64 https://shadertoy.com/view/Xd3GRf\n\twater reflection:@Reinder https://www.shadertoy.com/view/MdXGW2\n\nCHANGELOG & TODO: \n\tsee bottom of the file\n\n//-----------------------------------------------------*/\n\n\n#ifdef STATS\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n#endif\n\n\nvec4 drawSelectionBox(vec2 c) {\n\tvec4 o = vec4(0.);\n    float d = max(abs(c.x), abs(c.y));\n    if (d > 6. && d < 9.) {\n        o.a = 1.;\n        o.rgb = vec3(0.9);\n        if (d < 7.) o.rgb -= 0.3;\n        if (d > 8.) o.rgb -= 0.1;\n    }\n    return o;\n}\n\nmat2 inv2(mat2 m) {\n  return mat2(m[1][1],-m[0][1], -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nvec4 drawInventory(vec2 c) {\n    \n    float h= (load(_inventory).r>1.?NUM_ITEM_ROWS:1.);\n\tfloat scale = floor(iResolution.y / 128.);\n    c /= scale;\n    vec2 r = iResolution.xy / scale;\n    vec4 o = vec4(0);\n    float xStart = (r.x - 16. * NUM_ITEMS) / 2.;\n    c.x -= xStart;\n    float selected = load(_selectedInventory).r;\n    vec2 p = (fract(c / 16.) - .5) * 3.;\n    vec2 u = vec2(sqrt(3.)/2.,.5);\n    vec2 v = vec2(-sqrt(3.)/2.,.5);\n    vec2 w = vec2(0,-1);\n    if (c.x < NUM_ITEMS * 16. && c.x >= 0. && c.y < 16.* h ) {\n        float slot = floor(c.x / 16.) + NUM_ITEMS*floor(c.y / 16.) ;\n    \to = getTexture(48., fract(c / 16.));\n        vec3 b = vec3(dot(p,u), dot(p,v), dot(p,w));\n        vec2 texCoord;\n        //if (all(lessThan(b, vec3(1)))) o = vec4(dot(p,u), dot(p,v), dot(p,w),1.);\n        float top = 0.;\n        float right = 0.;\n        if (b.z < b.x && b.z < b.y) {\n        \ttexCoord = inv2(mat2(u,v)) * p.xy;\n            top = 1.;\n        }\n        else if(b.x < b.y) {\n        \ttexCoord = 1. - inv2(mat2(v,w)) * p.xy;\n            right = 1.;\n        }\n        else {\n        \ttexCoord = inv2(mat2(u,w)) * p.xy;\n            texCoord.y = 1. - texCoord.y;\n        }\n        if (all(lessThanEqual(abs(texCoord - .5), vec2(.5)))) {\n            float id = getInventory(slot);\n            if (id == 3.) id += top;\n            o.rgb = getTexture(id, texCoord).rgb * (0.5 + 0.25 * right + 0.5 * top);\n            o.a = 1.;\n        }\n    }\n    vec4 selection = drawSelectionBox(c - 8. - vec2(16. * mod(selected,NUM_ITEMS), 16.* floor(selected/NUM_ITEMS)));\n    o = mix(o, selection, selection.a);\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float pixelSize = load(_pixelSize).r;\n    vec2 renderResolution = ceil(iResolution.xy / pixelSize); \n    fragColor = texture(iChannel3, fragCoord * renderResolution / iResolution.xy / iResolution.xy);\n    //fragColor = texture(iChannel3, fragCoord);\n    \n    if(load(_inventory).r>.0){   \n   \t     vec4 gui = drawInventory(fragCoord);\n   \t    fragColor = mix(fragColor, gui, gui.a);\n    }\n    \n#ifdef STATS    \n    //DISPLAY STATS IF F3 IS TOGGGLED\n    float stats = load(_stats).r;    \n    if (stats >0.5) {\n        vec3 pos = load(_pos).xyz;\n        \n\n        //POS\n        fragColor = mix( fragColor, vec2(1,.5).xyyx, PrintValue(fragCoord, vec2(0., iResolution.y - 20.), vec2(8,15), pos.x, 5.0, 5.0));\n        fragColor = mix( fragColor, vec2(1,.5).yxyx, PrintValue(fragCoord, vec2(0., iResolution.y - 40.), vec2(8,15), pos.y, 5.0, 5.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxyx, PrintValue(fragCoord, vec2(0., iResolution.y - 60.), vec2(8,15), pos.z, 5.0, 5.0));\n\n        //ANGLE\n        fragColor = mix( fragColor, vec2(1,.5).xyyx, PrintValue(fragCoord, vec2(0., iResolution.y -80.), vec2(8,15),  load(_angle).x, 5.0, 2.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxxx, PrintValue(fragCoord, vec2(50., iResolution.y -80.), vec2(8,15),  load(_angle).y, 5.0, 2.0)); \n \n        //TIME\n        fragColor = mix( fragColor, vec2(1,.5).xxxx , PrintValue(fragCoord, vec2(0., iResolution.y -100.), vec2(8,15), load(_time).r, 5.0, 2.0));\n\n\n        \n        //if (fragCoord.x < 20.) fragColor.rgb = mix(fragColor.rgb, texture(iChannel0, fragCoord / iResolution.xy).rgb, texture(iChannel0, fragCoord / iResolution.xy).a);\n        \n        //FRAMERATE, MEMORY RANGE, HEIGHT LIMIT, RAY DISTANCE\n        fragColor = mix( fragColor, vec2(1,.5).xxyx, PrintValue(fragCoord, vec2(0.0, 105.), vec2(8,15), load(_pixelSize).r, 5.0, 1.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxyx, PrintValue(fragCoord, vec2(0.0, 85.), vec2(8,15), 1./ iTimeDelta, 5.0, 1.0));\n\n#if SURFACE_CACHE>0\n        fragColor = mix( fragColor, vec2(1,.5).yxxx, PrintValue(fragCoord, vec2(0., 65.), vec2(8,15), calcLoadDist_C( iChannelResolution[2].xy), 5.0, 2.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxxx, PrintValue(fragCoord, vec2(0., 45.), vec2(8,15),  heightLimit_C, 5.0, 2.0));\n#endif\n        fragColor = mix( fragColor, vec2(1,.5).xxxx, PrintValue(fragCoord, vec2(0., 25.), vec2(8,15),  load(_rayDistMax).r, 5.0, 2.0));\n\n    }\n\t\n    // \"BUFFER C\" DUMP\n    if(load(_stats).g>.5) {               \n        vec3 offset = floor(vec3(load(_pos).xy, 0.));\n        vec4  color= texture(iChannel2,fragCoord / iResolution.xy);\n        fragColor = color;       \n    }\n    //\"BUFFER A\" DUMP\n\n    if(load(_stats).b>.5) fragColor= texture(iChannel0, fragCoord /iResolution.xy/3.);\n\n#endif\n}\n/*\nCHANGELOG \n\t- 20200425: added elevators\n\t            added repeated towers\n                20200425-1902: fixed map key\n\t- 20200426: new materials; voxel.value to store user actions and prevent override\n         \t    select from inventory with mouse\n    \t \t    more realistic elevator, stabilizing adaptive pixelSize and renderDistance\n                fix: when placing & destroying a block, it becomes invisible\n                fix: tree grows correctly when placed\n                water block not solid and semi-transparent \n    - 20200427: structures are placed randomly; water in caves and water swimming\n                added optional \"#define FAST_COMPILE\" (uncomment row32 of file common to reduce compilation time by half)\n                Pyramids\n                water flow downward\n    - 20200428: water refraction and waves\n\t            fog and clouds\n\t- 20200429: cut compilation time - removed duplicated call to render() in buffer D\n\t- 20200501: compilation optimization and fixed inventory bug\n\t \t\t    replaced voxel traversal algorithm with the one described in \"Voxel Edge Occlusion\" by Iq\n\t \t\t\tskeleton for subvoxels\n\t- 20200502: revised light diffusion and default\n\t- 20200503: added shapes (change shape with \"R\")\n\t            shape rotation ( with \"F\")\n\t- 20200504: shape vertical rotation ( with \"G\") ... not always working\n\t            disabled unecessary keys\n\t            multiselection with \"C\" \n\t- 20200505: shadows; working but unfinished\n\t            fixed shadows (#ifdef SHADOW);now working\n\t- 20200509: webgl 1.0 compatibility and compilation optimization\n\t            compilation optimization\n\t- 20200510: tree detail (can be disable)\n\t            optimization: discard if unused texels in buffer A & C\n\t            revised textures (need to refine) \n\t            refactoring - merged buffer A & buffer C with better performances\n\t- 20200511: refactoring in buffer B neightbour scan; grass prototype\n\t            grass rendering from https://www.shadertoy.com/view/MdsGzS\n\t- 20200512: configurable cloud density , grass height & pathway\n\t- 20200513: inventory toggle with \"I\" \n\t            proof of concept: electriciy with gold=source, diamond=wire\n\t- 20200514: lighing of unconnected blocks or sand with more than 4 horizontal steps\n\t            falling sand if  more than 4 horizontal steps\n\t- 20200515: demo mode at start\n\t- 20200518: minimalist mirror (red block)\n\t- 20200520: revised encode/decodeVoxel in order to exploit al 64 pixel bits\n\t- 20200522: refactoring calcOcclusion()\n\t- 20200523: mouse double click \n\t- 20200524: refactoring: reused raycasting in buffer D for mouse pointer\n\t- 20200526: added buffer C(surface cache) and other refactoring\n\t- 20200603: added water physics and water source (pink marble) - work in progress\n\t- 20200608: performance optimization and revised subvoxel rendering with SUBTEXTURE\n\t- 20200609: refactoring calcOcclusion (less code & reduced compilation time)\n\t            refactoring reflection (mirror block) and refraction (water)\n\t- 20200611: heightmap cache in buffer C (much faster and many new possibilities)\n\t            far trees (work in progress)\n\t- 20200612: fixed shadows & occlusion  for subvoxels\n                map view rotation, detailed buildings, configurable building distance\n\t- 20200625: variable water level (50% of the territory is flooded)\n\t- 20200704: more realistic water refraction and reflection (inspired by Venice shader)\n\t- 20200712: pseudo Fresnel reflection \n\t- 20200723: enable/disable torch(F7) and water flow (F8)\n\nTODO LIST:\n\t- substitute buffer B/C with cubemap  (done but not working https://www.shadertoy.com/view/3t2yWR)\n\t- more shapes and materials \n\t- more menus (shape, rotation, etc..) \n\t- circuits (wire, gate, flip-flop, sensor, etc...) --> in a fork\n\t- portals\n    - constructions: bridge, tower,wall, road\n\t- explosions\n\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/* ----------------------------------------------------------\n\tCONFIGURABLE SETTINGS\n//----------------------------------------------------------*/\n//  MAX_PICK_DISTANCE: distance for block selection with mouse (default = 10)\n#define MAX_PICK_DISTANCE 10.\n//  FAST_NOISE: use cheaper noise function \n#define FAST_NOISE\n//\tOCCLUSION: enable voxel occlusion\n#define OCCLUSION\n//  SUBVOXEL: enable shapes actions with keys R,F,G\n#define SUBVOXEL\n//\tSUBTEXTURE: apply texture scaled on subvoxels (more detailed but aliased)\n//#define SUBTEXTURE\n//\tTREE_DETAIL: if enabled, tree blocks are detailed with subvoxels \n#define TREE_DETAIL\n//\tTREE SIZE: height of the trees \n#define TREE_SIZE 3.\n//  GRASS_DETAIL: enable grass\n#define GRASS_DETAIL\n//  SHADOW 0.=disabled else shadow intensity\n#define SHADOW 1.\n//  CLOUDS 0.=disabled else cloud density (*)\n//#define CLOUDS 1.5\n//  FALLING_SAND: sand blocks fall if unstable \n//#define FALLING_SAND\n//  MAP: map rendering\n#define MAP\n//\tHIGHLIGHT 0.=disabled else higlight of  unconnected blocks, sand with 4+ horizontal steps, cascading diamonds connected to gold\n#define HIGHLIGHT 0.\n//\tSURFACE_CACHE:  secondary cache mode with buffer C (1=surface blocks,2=heightmap,0=disabled)\n#define SURFACE_CACHE 2\n//\tSTRUCTURES: build pyramids & towers; values 0=none, 1=basic, 2=detailed\n#define STRUCTURES 2 \n//  STATS: display debug info if F3,F4,F5 keys pressed \n//#define STATS\n//\tFLAT: flat world\n//#define FLAT\n//  XRAY_MODE: fly mode, with no collisions and transparent blocks (*)\n//#define XRAY_MODE\n// \tEXCLUDE_CACHE:view only mode, with disabled buffer B \n//#define EXCLUDE_CACHE\n//\tWATER_LEVEL: level of water (10.=caves, 55.= islands); 50% of the areas use WATER_LEVEL2\n#define WATER_LEVEL 12.\n#define WATER_LEVEL2 45.\n//\tWATER_FLOW: enable water flow (value= levelling distance)\n#define WATER_FLOW 250.\n//  BUILD_DISTANCE average distance between costructions\n#define BUILD_DISTANCE 160.\n\n//use 124 bits per texel (it's warking but not necessary yet)\n//#define ENCODE124\n// flickering light from fireflies at night\n#define FIREFLIES\n\n//WIP MARCHING CUBES\n//#define MC\n//------------------------------------------------------\n\n//SHARED VARIABLES\n#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\n#define load( coord)  texture(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[0].xy)) \n#define getTexture( id,  c) texture(iChannel0, 16. * (clamp(c,0.001,.999) + vec2(mod(id, 8.), floor(id / 8.)+2.)) / iChannelResolution[0].xy, 0.0)\n\n//shared variables are stored in buffer A where  y=0\nvar(_pos, 0, varRow);//_old _pos\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange_B, 4, varRow);\nvar(_loadRange_C, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);//_old _pick\nvar(_pickTimer, 8, varRow);  //_old _pickTimer\nvar(_renderScale, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_stats, 14, varRow);\nvar(_rayDistMax,15,varRow);\nvar(_loadDistLimit,16,varRow);\nvar(_rayLimit,17,varRow);\nvar(_map,18,varRow);\nvar(_pixelSize,19,varRow);\nvar(_inventory,20,varRow);\nvar(_demo,21,varRow);\nvar(_mouseBusy,22,varRow);\nvar(_torch,23,varRow);\nvar(_flow,24,varRow);\n//old value are stored in rows with y=n where n is the iFrame difference\nvar(_old, 0, 1); \n\n//BUFFER B\nconst int  BUFFER_B = 1;\nconst vec2 packedChunkSize_B = vec2(13,7);\nconst float heightLimit_B = packedChunkSize_B.x * packedChunkSize_B.y;\n\n//BUFFER C\n#if SURFACE_CACHE==1\nconst int  BUFFER_C = 2;\nconst float SURFACE_C=45.;\nconst vec2 packedChunkSize_C = vec2(7,4);\nconst float heightLimit_C = packedChunkSize_C.x * packedChunkSize_C.y ;\n#elif SURFACE_CACHE==2\nconst int  BUFFER_C = 2;\nconst vec2 packedChunkSize_C = vec2(1,1);\nconst float heightLimit_C = packedChunkSize_C.x * packedChunkSize_C.y ;\n#endif\n\n\n//INVENTORY ITEMS FOR EACH ROW\nconst float NUM_ITEMS=8.;\n//INVENTORY ROWS\nconst float NUM_ITEM_ROWS=2.;\n//\nconst float N_SUBVOXEL=5.;\n// USED BY FALLING SANDS\nconst float MAX_GROUND=45.;\n\n   \n// VOXEL CACHE FUNCTION\nvec2 unswizzleChunkCoord(vec2 storageCoord) {\n \tvec2 s = floor(storageCoord);\n    float dist = max(s.x, s.y);\n    float offset = floor(dist / 2.);\n    float neg = step(0.5, mod(dist, 2.)) * 2. - 1.;\n    return neg * (s - offset);\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float offset = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + offset;\n}\n\n\nfloat calcLoadDist_B(vec2 iResolutionxy) {\n    vec2  chunks = floor(iResolutionxy / packedChunkSize_B); \n    float gridSize = min(chunks.x, chunks.y);    \n    return floor((gridSize - 1.) / 2.);\n}\n\nvec4 calcLoadRange_B(vec2 pos,vec2 iResolutionxy, float border) {\n\tvec2 d = (calcLoadDist_B(iResolutionxy) - border)* vec2(-1,1);\n    return floor(pos).xxyy + d.xyxy;\n}\n\n#if SURFACE_CACHE>0\nfloat calcLoadDist_C(vec2 iResolutionxy) {\n    vec2  chunks = floor(iResolutionxy / packedChunkSize_C); \n    float gridSize = min(chunks.x, chunks.y);    \n    return floor((gridSize - 1.) / 2.);\n}\n\nvec4 calcLoadRange_C(vec2 pos,vec2 iResolutionxy, float border) {\n\tvec2 d = (calcLoadDist_C(iResolutionxy) - border)* vec2(-1,1);\n    return floor(pos).xxyy + d.xyxy;\n}\n#endif \n\nvec3 texToVoxCoord(vec2 textelCoord, vec3 offset,int bufferId) {\n#if SURFACE_CACHE>0\n    vec2 packedChunkSize= bufferId==1?packedChunkSize_B:packedChunkSize_C;\n#else\n    vec2 packedChunkSize= packedChunkSize_B;\n#endif\n\tvec3 voxelCoord = offset;\n    voxelCoord.xy += unswizzleChunkCoord(textelCoord / packedChunkSize);\n    voxelCoord.z += mod(textelCoord.x, packedChunkSize.x) + packedChunkSize.x * mod(textelCoord.y, packedChunkSize.y);\n    return voxelCoord;\n}\n\nvec2 voxToTexCoord(vec3 voxCoord,int bufferId) {\n#if SURFACE_CACHE>0\n    vec2 packedChunkSize= bufferId==1?packedChunkSize_B:packedChunkSize_C;\n#else\n    vec2 packedChunkSize= packedChunkSize_B;\n#endif\n    vec3 p = floor(voxCoord);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z / packedChunkSize.x));\n}\n\n\nstruct voxel {\n\tfloat id;\n    int value; //1=modified,2=selected,3=falling\n    vec2 light;\n    float life;\n    int shape;\n    float rotation;\n    float ground;\n    float surface;\n    int buffer;\n   \n     \n};\n#ifndef ENCODE124\n//from https://www.shadertoy.com/view/wsBfzW\nfloat gb(float c, float start, float bits){return mod(floor(c/pow(2.,start)),pow(2.,bits));}//get bits\n\n//lazy version:\n//#define sb(f,s,b,v) f+=(v-gb(f,s,b))*pow(2.,s)\n//strict version (use in case of strange behaviours):\n#define sb(f,s,b,v) f+=(clamp(floor(v+.5),0.,pow(2.,b)-1.)-gb(f,s,b))*pow(2.,s)\n//experimenting  124bit encode/decode functions from https://www.shadertoy.com/view/tsGBWy\n\nvoxel decodeVoxel(vec4 t) {\n\tvoxel o;\n    o.id        = gb(t.r,0., 6.);\n    o.value     = int(gb(t.r,6., 2.));\n    \n    o.light.s   = gb(t.g,0., 4.) ;\n    o.light.t   = gb(t.g,4., 4.);\n    o.life      = gb(t.g,8., 8.);\n    \n    o.shape     = int(gb(t.b,0., 4.));\n    o.rotation  = gb(t.b,4., 4.);\n    \n    o.ground    = gb(t.a,0., 8.);\n    o.surface   = gb(t.a,8., 8.);\n    return o;\n}\n\nvec4 encodeVoxel(voxel v) {\n\tvec4 t=vec4(0.);\n    sb(t.r,0.,6.,v.id);\n    sb(t.r,6.,2.,float(v.value));\n    \n    sb(t.g,0.,4.,v.light.s);\n    sb(t.g,4.,4.,v.light.t);\n    sb(t.g,8.,8.,v.life); \n    \n    sb(t.b,0.,4.,float(v.shape));\n    sb(t.b,4.,4.,v.rotation);\n    \n    sb(t.a,0.,8.,v.ground);\n    sb(t.a,8.,8.,v.surface);\n    return t;\n}\n#else\n#define BITS 32.\n#define MAXUINT  0xFFFFFFFFu \n\n\n// pixel is a 128 bit mask (0-31 -> x, 32-63 -> y, 64-95 -> z, 96-127 -> w)\nuint getBit(inout uvec4 bm, uint i)\n{\n    uint bv = i/uint(BITS),  bi= i%uint(BITS);\n       \n    return  (bm[bv]  &  (1u<<bi) )>0u?1u:0u;\n}\n\n//works only if n<=32u \nuint getBits(inout uvec4 bm, uint k, uint n){\n   \n    \n    uint bv = k/uint(BITS),  bi= k%uint(BITS);\n    if(n+bi<=32u){\n        //inside vec4 dimension\n        uint m = (1u<<n)-1u; \n        return (bm[bv] & (m<<bi) )>>bi;\n    }\n    else\n    {\n        //cross dimension\n        uint n1= 32u-bi, n2 = bi+n-32u;\n        uint m1 =(1u<<n1)-1u, m2= (1u<<n2)-1u;\n        return ((bm[bv] & (m1<<bi) )>>bi) \n             + ((bm[bv+1u] & m2 )<<n1);\n    }\n}\n\n// set bit value in a 128 bit mask \nvoid setBit(inout uvec4 bm, uint i, uint val){\n    uint bv = i/uint(BITS),  bi= i%uint(BITS);\n    bm[bv]  &= ( MAXUINT - (1u<<bi) );\n    if(val>0u)  bm[bv]  +=(1u<<bi);\n}\n\nvoid setBits(inout uvec4 bm, uint i, uint n, uint val){\n    val =clamp( val, 0u, (1u<<n)-1u) ;\n\n    //TODO REPLACE WITH A SINGLE EXPRESSION WITHOUT CYCLING\n    uint bv = i/uint(BITS),  bi= i%uint(BITS);\n    if(n+bi<=32u){\n        bm[bv]  &= ( MAXUINT - (((1u<<n)-1u ) <<bi) );\n        bm[bv]  +=(val<<bi);\n    }\n    else\n    {\n        for(uint j=0u; j<n;j++) \n        {\n            uint b = (val  &  (1u<<j) )>0u?1u:0u;\n            setBit(bm, i+j, b);\n        }\n    }\n}\n\nvoxel decodeVoxel(vec4 t) {\n\tvoxel o;\n    uvec4 iv =  floatBitsToUint(t);\n    o.id        = float(getBits(iv,0u,6u)); \n    o.value     = int(getBits(iv,6u,2u));   \n    o.light.s   = float(getBits(iv,8u, 4u) );\n    o.light.t   = float(getBits(iv,12u, 4u));\n    o.life      = float(getBits(iv,16u, 9u));\n    \n    o.shape     = int(getBits(iv,64u, 4u));\n    o.rotation  = float(getBits(iv,68u, 4u));\n    \n    o.ground    = float(getBits(iv,72u, 8u));\n    o.surface   = float(getBits(iv,80u, 8u));\n    return o;\n}\n\nvec4 encodeVoxel(voxel v) {\n\tuvec4 iv = uvec4(MAXUINT);\n    setBits(iv, 0u,6u,uint(v.id));\n    setBits(iv, 6u,2u,uint(v.value));    \n    setBits(iv,8u,4u,uint(v.light.s));\n    setBits(iv,12u,4u,uint(v.light.t));\n    setBits(iv,16u,9u,uint(v.life)); \n    iv.y=1u; //unused\n    setBits(iv,64u,4u,uint(v.shape));\n    setBits(iv,68u,4u,uint(v.rotation));\n    setBits(iv,72u,8u,uint(v.ground));\n    setBits(iv,80u,8u,uint(v.surface));\n    iv.w=1u; //unused\n    \n    uvec4 c = uvec4( getBits(iv,24u,7u),getBits(iv,56u,7u),getBits(iv,88u,7u),getBits(iv,120u,7u));\n    setBit(iv,31u,c.x==0u?1u:0u);setBit(iv,63u,c.y==0u?1u:0u);setBit(iv,95u,c.z==0u?1u:0u);setBit(iv,127u,c.w==0u?1u:0u);\n    \n    return uintBitsToFloat(iv);\n}\n#endif\n\nfloat lightDefault(float z){\n\tif(z>55.) return 15.;\n    else if(z>45.) return 14.; \n    else if(z>35.) return 11.; \n    else if(z>10.) return 8.;\n    else return 5.;\n}\n\nvoxel newVox(float z){\n    voxel vox;\n    vox.life=0.;\n    vox.rotation=0.;\n    vox.value=0;\n    vox.shape=0;\n    vox.ground=200.;\n    vox.surface=0.;\n\tvox.id=0.;\n    vox.light.t = z>10.? 0.:12.;\n    vox.light.s = lightDefault(z);\n \tvox.id=0.;\n    vox.buffer=0;\n    return vox;\n}\n\nvec4 readMapTex(vec2 pos, sampler2D iChannel,vec3 resolution) {\n    return texture(iChannel, (floor(pos) + 0.5) /  (floor (resolution.xy)), 0.0);   \n \n}\n\n\nvoxel getCachedVoxel(vec3 p,sampler2D iChannel,vec3 resolution,int bufferId) {\n    if(p.z>heightLimit_B || p.z<0.){voxel vox; vox.id=0.; return vox;}\n    voxel vox= decodeVoxel(readMapTex(voxToTexCoord(p, bufferId),iChannel,resolution));\n    vox.buffer=bufferId;\n    return vox;\n}\n\n\nfloat isSolidVoxel(voxel vox) {\n    \n    return (vox.id==0. || vox.id==12. ||vox.id==26.)?0.:1.;\n}\n\nfloat getInventory(float slot) {\n\treturn slot + 1. + step(2.5, slot);  \n}\n\n\n\n// WORLD GENERATION \n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nconst float PI = 3.14159265359;\n\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n    \nfloat hash2(in vec2 p) { return hash(dot(p, vec2(87.1, 313.7))); }\n\nvec2 hash22(in float p) {\n\tfloat x = hash(p);\n\treturn vec2(x, hash(p+x));\n}\n//vec2 hash22(in vec2 p) { return hash2(dot(p, vec2(87.1, 313.7))); }\n\n\nvec2 hash22( vec2 p ) \n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\n\n// Fork of \"Optimized Ashima SimplexNoise3D\" by Makio64. https://shadertoy.com/view/Xd3GRf\n// 2020-04-23 14:52:01\n\n// Optimized AshimaSimplexNoise by @makio64 https://www.shadertoy.com/view/Xd3GRf\n// Original : https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\n\n#ifndef FAST_NOISE\nlowp vec4 permute(in lowp vec4 x){return mod(x*x*34.+x,289.);}\nlowp float snoise(in mediump vec3 v){\n  const lowp vec2 C = vec2(0.16666666666,0.33333333333);\n  const lowp vec4 D = vec4(0,.5,1,2);\n  lowp vec3 i  = floor(C.y*(v.x+v.y+v.z) + v);\n  lowp vec3 x0 = C.x*(i.x+i.y+i.z) + (v - i);\n  lowp vec3 g = step(x0.yzx, x0);\n  lowp vec3 l = (1. - g).zxy;\n  lowp vec3 i1 = min( g, l );\n  lowp vec3 i2 = max( g, l );\n  lowp vec3 x1 = x0 - i1 + C.x;\n  lowp vec3 x2 = x0 - i2 + C.y;\n  lowp vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  lowp vec4 p = permute( permute( permute(\n\t  i.z + vec4(0., i1.z, i2.z, 1.))\n\t+ i.y + vec4(0., i1.y, i2.y, 1.))\n\t+ i.x + vec4(0., i1.x, i2.x, 1.));\n  lowp vec3 ns = .142857142857 * D.wyz - D.xzx;\n  lowp vec4 j = -49. * floor(p * ns.z * ns.z) + p;\n  lowp vec4 x_ = floor(j * ns.z);\n  lowp vec4 x = x_ * ns.x + ns.yyyy;\n  lowp vec4 y = floor(j - 7. * x_ ) * ns.x + ns.yyyy;\n  lowp vec4 h = 1. - abs(x) - abs(y);\n  lowp vec4 b0 = vec4( x.xy, y.xy );\n  lowp vec4 b1 = vec4( x.zw, y.zw );\n  lowp vec4 sh = -step(h, vec4(0));\n  lowp vec4 a0 = b0.xzyw + (floor(b0)*2.+ 1.).xzyw*sh.xxyy;\n  lowp vec4 a1 = b1.xzyw + (floor(b1)*2.+ 1.).xzyw*sh.zzww;\n  lowp vec3 p0 = vec3(a0.xy,h.x);\n  lowp vec3 p1 = vec3(a0.zw,h.y);\n  lowp vec3 p2 = vec3(a1.xy,h.z);\n  lowp vec3 p3 = vec3(a1.zw,h.w);\n  lowp vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  lowp vec4 m = max(.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);\n  return -0.334 +.5 + 12. * dot( m * m * m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\n// Optimized Ashima Simplex noise2D by @makio64 https://www.shadertoy.com/view/4sdGD8\n// Original shader : https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// snoise return a value between 0 & 1\n\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return -0.278 + .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}\n#endif\n\n#ifdef FAST_NOISE\nfloat snoise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash22(i+0.0)), dot(b,hash22(i+o)), dot(c,hash22(i+1.0)));\n    \n    return dot( n, vec3(70.0) );\n}\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\nfloat snoise(vec3 p)\n{\n \t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n\n#endif\n\nbool overworld(vec3 p) {\n\tfloat density = 48. - p.z;\n    density += mix(0., 40., pow(.5 + .5 * snoise(p.xy /557. + vec2(0.576, .492)), 2.)) * snoise(p / 31.51 + vec3(0.981, .245, .497));\n\n    return density > 0.;\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdCross( vec3 p, vec3 b )\n{\n  float d1 = length(max( abs(p) - b,0.));\n  float d2 = length(max( abs(p) - b.zyx,0.));\n  float d3 = length(max( abs(p) - b.xzy,0.));\n  return min(d1, min(d2,d3));\n}\n\n\nvoxel getGeneratedVoxel(vec3 voxelCoord,bool caves,int frame){\n\n    \tvoxel vox=newVox(voxelCoord.z);\n#ifdef FLAT\n    \tvox.id=(voxelCoord.z>=50.?0.:3.);\n#else \n    \n    \tbool layer[4];\n    \tfor (int i =0; i <=3 ; i++) {\n            float h;\n            if(i==1) h=1.; \n            else if(i==2) h=3.; \n            else if(i==3)  h=-1.; \n            else h=0.;\n            \n            layer[i+min(frame,0)]=overworld(voxelCoord+ vec3(0,0,h));\n            if(!layer[0]) break;\n        }\n         \n    \tbool solid = layer[0];\n    \n   \n        if (solid) {\n            //GRASS\n            vox.id = 3.;\n            \n                             \n            //DIRT\n            if (layer[1]) vox.id = 2.; \n            //ROCK\n            if (layer[2]) vox.id = 1.; \n            //TORCH\n            if (hash13(voxelCoord) > 0.98 && !layer[3]) {vox.id = 6.;vox.light.t = 15.;}\n \n            //TREE BASE\n            if (hash13(voxelCoord) > 0.98 && !layer[1]) {vox.id = 10.;vox.life = 2.+ TREE_SIZE; vox.shape=9;}\n\n             // CAVE\n            if(caves){\n                caves=snoise(voxelCoord / 27.99 + vec3(0.981, .245, .497).yzx * 17.) > 1. - (smoothstep(0., 5., voxelCoord.z) - 0.7 * smoothstep(32., 48., voxelCoord.z));\n\t        \tif (caves) {vox.id = 0.;}\n            }\n        } \n \t    \n    \t//WATER\n    \tif(vox.id == 0. && voxelCoord.z < WATER_LEVEL) {\n            vox.id=12.; \n            if(voxelCoord.z > WATER_LEVEL -2.) vox.shape=3;\n#ifdef WATER_FLOW\n            vox.life=WATER_FLOW;    \n#endif                \n         }\n        //GEMS\n        if (hash13(voxelCoord) > 0.995 && voxelCoord.z < 20.  &&  vox.id!=12. && vox.id!=0. ) {if(hash13(voxelCoord +vec3(1.))>.5) vox.id = 6.; else vox.id=8.;}    \n        //BEDROCK\n        if (voxelCoord.z < 1.) vox.id = 16.; \n    \n#if STRUCTURES>0    \n    \t// STRUCTURES REPEATED EVERY BUILD_DISTANCE SQUARE\n    \tvec3  buildCoord = vec3(floor((voxelCoord.xy -vec2(3260. -40.,9650. -40.))/BUILD_DISTANCE)*BUILD_DISTANCE,0.)   +vec3(3260.,9650.,50.);\n \t\t//RANDOM POSITION INSIDE THE 80x80 SQUARE\t buildCoord += hash33(buildCoord)\n    \tif(length(voxelCoord.xy -vec2(3260, 9650.))>50.) buildCoord += floor(hash33(buildCoord) *vec3(50.,50, .10)) -vec3(25.,25, 5.);\n   \n    \tfloat type =hash13(buildCoord);\n    \tfloat type2 =hash13(buildCoord+vec3(1.));\n        if(type2>.5 && vox.id == 0. && voxelCoord.z < WATER_LEVEL2) {\n            vox.id=12.; \n#ifdef WATER_FLOW\n            vox.life=WATER_FLOW;\n            \n            \n            if(voxelCoord.z > WATER_LEVEL2-2.) vox.shape=3; else vox.shape=0;\n#endif                \n         }\n    \tif(type<.2) {\n            //PYRAMID          \n            if(sdOctahedron(voxelCoord -  buildCoord -vec3(-2.,-3.,2.),30.)<=0.) vox.id=13.;\n\n        }\n    \telse{\n\n            //TOWER\n             if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-3.))<2.  && voxelCoord.z <75.)  {vox.id=1.;  vox.light.t=8.;}\n            if(length(voxelCoord - buildCoord  - vec3(-2.,-3.,30.))<1.5)  {vox.id=6.;  vox.light.t=15.;}\n        }\n#endif\n    \n#endif\n        \n  \t\n        return vox;\n\t\t\n}\n\n\n\n// MIX PROCEDURAL AND MEMORY VOXEL\nbool inRange(vec2 p, vec4 r) {\n\treturn (p.x > r.x && p.x < r.y && p.y > r.z && p.y < r.w);\n}\n\n\n\nvoxel getVoxelData( vec3 voxelCoord,\n                    sampler2D iChannel_B, \n                    sampler2D iChannel_C, \n                    int frame, \n                    vec3 resolution_B, \n                    vec3 resolution_C,\n                    vec4 range_B,\n                    vec4 range_C,\n                    vec3 offset,\n                    bool caves,\n                    int caller){\n  \n#ifdef EXCLUDE_CACHE\n    return getGeneratedVoxel(voxelCoord,true,frame); \n#else    \n    \n \n    if (inRange(voxelCoord.xy,range_B) && frame > 0 && voxelCoord.z <heightLimit_B  \n        && (caller!=2)  //comment this line to enable persistence between cache (doesn't handle resolution change)\n       ) {\n        return getCachedVoxel(voxelCoord  - offset,iChannel_B,resolution_B,BUFFER_B); \n        \n    }\n#if SURFACE_CACHE==1     \n     if (inRange(voxelCoord.xy,range_C) && frame > 0  \n               &&  voxelCoord.z >= SURFACE_C\n         \t\t&& voxelCoord.z <heightLimit_C +SURFACE_C\n              //&& (caller!=1) //\n              \n             ) {\n        return getCachedVoxel(voxelCoord - vec3(0.,0.,SURFACE_C) - offset,iChannel_C,resolution_C,BUFFER_C); \n         \n    }\n#elif SURFACE_CACHE==2\n    if (inRange(voxelCoord.xy,range_C) && frame > 0){\n         if ( voxelCoord.z >= 0.&& voxelCoord.z <heightLimit_C  && (caller==2) ) {\n            // BUFFER C previous frame\n        \treturn getCachedVoxel(voxelCoord - offset,iChannel_C,resolution_C,BUFFER_C); \n         }\n        if(caller!=2){\n        \tvoxel vo= getCachedVoxel(vec3(voxelCoord.xy,0.) - offset,iChannel_C,resolution_C,BUFFER_C);\n         \tif(vo.ground>0. && vo.ground< heightLimit_B  ){\n                //Above max height of BUFFER C --> air\n                float h=voxelCoord.z-vo.ground;\n                if(h==0. ) {  return vo;}\n                \n                voxel vox=newVox(voxelCoord.z);\n             \tif(h>0. && caller==3) { \n                   \t//GRASS\n                    if(h==1. &&vo.id==3.) { vox.life=1.;}\n                    \n                    //TREE TRUNK\n                    if(h<TREE_SIZE+2. && vo.id==10. && vo.ground >= WATER_LEVEL-1.) {vox.id=10.; vox.life=2.+TREE_SIZE-h; ; vox.shape=9;}                   \n                    return vox;\n                }\n             \t\n                if(h>-3. && h<0. && vo.id==11. && caller==3) {\n                    //TREE LEAFS\n                    vox.id=11.; \n                    vox.shape=8;\n                    vox.life=0.;\n                    return vox;\n                }\n\t\t\t\t\t\n         \t}\n         }\n    }    \n#endif\n  \n    return getGeneratedVoxel(voxelCoord,caves,frame);\n#endif\n}\n\n#define getCVoxel(p,v,id)           \\\n\t{vec2 frame=(id!=3&&id!=0?_old:vec2(0.) );\\\n    vec4 range_B = load(frame+_loadRange_B);  \\\n    vec4 range_C = load(frame+_loadRange_C);  \\\n    vec3 offset =(id==0?vec3(0.): floor(vec3(load(frame+_pos).xy, 0.)));   \\\n    if(id==2)  v= getCachedVoxel(p-offset,iChannel2,iChannelResolution[2],2); \\\n    else v= getCachedVoxel(p-offset,iChannel1,iChannelResolution[1],1);}\n\n\n#define getVoxel(p,v,id)           \\\n\t{vec2 frame=(id!=3&&id!=0?_old:vec2(0.) );\\\n    vec4 range_B = load(frame+_loadRange_B);  \\\n    vec4 range_C = load(frame+_loadRange_C);  \\\n    vec3 offset =(id==0?vec3(0.): floor(vec3(load(frame+_pos).xy, 0.)));   \\\n    v= getVoxelData(p,iChannel1,iChannel2,iFrame,iChannelResolution[1],iChannelResolution[2],range_B,range_C,offset,true,id);}\n\n\n\nvoid structures(vec3 voxelCoord, inout voxel vox, vec3 oldOffset, int iFrame, float iTime){\n\n    // STRUCTURES REPEATED EVERY 80x80 SQUARE  \n    vec3  buildCoord = vec3(floor((oldOffset.xy -vec2(3260. -40.,9650. -40.))/BUILD_DISTANCE)*BUILD_DISTANCE,0.)   +vec3(3260.,9650.,50.);\n    //vec3  buildCoord= +vec3(3260.,9650.,50.);\n\n\n    //RANDOM POSITION INSIDE THE 80x80 SQUARE\n    if(length(oldOffset.xy -vec2(3260, 9650.))>50.) buildCoord += floor(hash33(buildCoord) *vec3(50.,50, .10)) -vec3(25.,25, 5.);\n    \n    //REBUILD EVERY 30 FRAMES\n\n    if(iFrame==0 || (mod(float(iFrame),30.)==0.)  && vox.value<1){\n\n   float type =hash13(buildCoord);\n#if STRUCTURES==2\n         \n    \tif(type<.2) {\n            //PYRAMID          \n\n            if(abs(sdOctahedron(voxelCoord -  buildCoord -vec3(-2.,-3.,2.),31.))<.5\n              && abs(voxelCoord.x-buildCoord.x+2.)<.5 && voxelCoord.y-buildCoord.y>-2.\n               && voxelCoord.z>48.\n              ) {vox.id=1.; vox.shape=6;}\n\n   \t\t }\n#endif\n    \n        //TOWER\n        if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-3.))<2.  && voxelCoord.z <75.)  {vox.id=1.;vox.shape=0;}\n        if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-3.))<1.  && voxelCoord.z <75.)  {vox.id=14.;vox.shape=0;}\n        if(WATER_LEVEL<35. ){\n            \n             //CAVE IF UNDER TERRAIN LEVEL\n            if(sdBox(voxelCoord-  buildCoord - vec3(0.,0.,-4.), vec3(10.,9.,4.)) <.5){ vox.id=1.;vox.shape=0;}\n       \t\t if(sdBox(voxelCoord-  buildCoord - vec3(0.,0.,-4.), vec3(8.,7.,2.)) <.5) vox.id=0.;\n            //HOUSE\n            float house=sdBox(voxelCoord- buildCoord - vec3(-0.5,5.,-4.5), vec3(2.5,3.,2.5));\n            if( abs(house) <.5 ) {vox.id=7.;vox.shape=0; }\n\n            if(sdBox(voxelCoord- buildCoord- vec3(.5,1.,-7.), vec3(6.,8.,0.5)) <.5) {vox.id=9.;vox.shape=0;}\n            if(sdBox(voxelCoord- buildCoord- vec3(2.,4.,-5.), vec3(.1,.1,1.5)) <.5) vox.id=0.;\n            if(sdBox(voxelCoord- buildCoord- vec3(2.,6.,-5.), vec3(.1,.1,1.5)) <.5) {vox.id=14.;vox.shape=0;}\n\n            if(length(voxelCoord - buildCoord - vec3(3.,5.,-2.))<0.5)  {vox.id=6.; vox.shape=0; vox.light.t=15.;}\n            if(length(voxelCoord - buildCoord- vec3(3.,3.,-2.))<0.5)  {vox.id=6.; vox.shape=0; vox.light.t=15.;}\n            if(length(voxelCoord - buildCoord- vec3(-2.,7.,-4.))<0.5)  {vox.id=6.; vox.shape=0; vox.light.t=15.;}\n\n\n            //WATER SOURCE\n            if(length(voxelCoord - buildCoord- vec3(+22.,4.,-8.))<0.5)  {vox.id=15.; vox.shape=0; }\n\n            //POOL\n            //if(sdBox(voxelCoord-  buildCoord - vec3(7.,10.,-9.), vec3(2.,2.,2.)) <.5) vox.id=12.;\n            if(sdBox(voxelCoord- buildCoord- vec3(8.,1.,-9.), vec3(3.,3.,1.5)) <.5) {vox.id=9.;vox.shape=0;}\n            if(sdBox(voxelCoord- buildCoord- vec3(8.,1.,-8.), vec3(2.,2.,1.5)) <.5) {vox.id=12.; vox.life=255.;vox.value=1;vox.shape=0;}\n\n       \n        }\n \n        //ELEVATOR PLATFORMS (3 LEVELS)\n        if(type>.2){\n            if(sdBox(voxelCoord-buildCoord- vec3(-1.5,-3.,23.), vec3(4.,5.,0.5)) <.5) {vox.id=9.;vox.shape=0;}\n            if(abs(sdBox(voxelCoord-buildCoord- vec3(-1.5,-3.,24.), vec3(4.,5.,0.5))) <.5) {vox.id=9.; vox.shape=4; vox.rotation=1.;}\n            if(abs(sdBox(voxelCoord-buildCoord- vec3(-1.5,-3.5,24.), vec3(3.5,5.,0.5))) <.5) {vox.id=9.; vox.shape=4;}\n\n\n            if(sdBox(voxelCoord- buildCoord-vec3(-1.5,-3.,-26.), vec3(4.,4.,0.5)) <.5) {vox.id=9.; vox.shape=0;}\n\n            if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-5.))<2. && abs(voxelCoord.z -buildCoord.z -1.)<27. && voxelCoord.z>WATER_LEVEL)  {vox.id=0.;}\n            if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-1.))<2. && abs(voxelCoord.z- buildCoord.z -1.)<27. && voxelCoord.z>WATER_LEVEL)  {vox.id=0.;}\n\n\n            // LIGHTs\n            //if(length(voxelCoord - buildCoord  - vec3(-2.,-3.,30.))<2.5)  {vox.id=6.;  vox.light.t=15.;}\n            if(length(voxelCoord - buildCoord - vec3(-2.,-3.,-26.))<2.5)  {vox.id=6.;  vox.light.t=15.;vox.shape=0;}\n        }\n    }\n\n\n    // ELEVATOR- UP\n    if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-5.))<2. && abs(voxelCoord.z -buildCoord.z +26.-abs(mod((iTime-1.),100.)-50.) )<.5 )  {vox.id=0.;}\n    if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-5.))<2. && abs(voxelCoord.z -buildCoord.z +26.-abs(mod((iTime),100.)-50.) )<.5 )  {vox.id=9.;vox.shape=0;}\n\n\n    //ELEVATOR DOWN\n    if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-1.))<2. && abs(voxelCoord.z -buildCoord.z -24.+abs(mod((iTime-1.),100.)-50.) )<.5 )  {vox.id=0.;}\n    if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-1.))<2. && abs(voxelCoord.z -buildCoord.z -24. +abs(mod((iTime),100.)-50.) )<.5 )  {vox.id=9.;vox.shape=0;}\n\n\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define KEY_FORWARDS 87\n#define KEY_BACKWARDS 83\n#define KEY_LEFT 65\n#define KEY_RIGHT 68\n#define KEY_JUMP 32\n#define KEY_SNEAK 16\n#define KEY_PLACE 81\n#define KEY_DESTROY 69\n#define KEY_SHAPE 82\n#define KEY_ROTATE_Z 70\n#define KEY_ROTATE_Y 71\n#define KEY_MULTISELECT 67\n#define KEY_DECREASE_ZOOM 33\n#define KEY_INCREASE_ZOOM 34\n#define KEY_DECREASE_PIXELSIZE 75\n#define KEY_INCREASE_PIXELSIZE 76\n#define KEY_INCREASE_TIME_SCALE 80\n#define KEY_DECREASE_TIME_SCALE 79\n#define KEY_STATS 114\n#define KEY_DUMP1 115\n#define KEY_DUMP2 116\n#define KEY_TORCH 118\n#define KEY_FLOW 119\n#define KEY_TELEPORT 84\n#define KEY_INCREASE_PERFORMANCE 117\n#define KEY_WORLD 89\n#define KEY_MAP 77\n#define KEY_INVENTORY 73\n\n\n//ACTIONS \n\n\n\nbool inBox(vec2 coord, vec4 bounds) {\n    return coord.x >= bounds.x && coord.y >= bounds.y && coord.x < (bounds.x + bounds.z) && coord.y < (bounds.y + bounds.w);\n}\nvec2 currentCoord;\nvec4 outValue;\nbool store4(vec2 coord, vec4 value) {\n    if (inBox(currentCoord, vec4(coord, 1., 1.))) {\n        outValue = value;\n        return true;\n    }\n    else return false;\n}\nbool store3(vec2 coord, vec3 value) { return store4(coord, vec4(value, 1)); }\nbool store2(vec2 coord, vec2 value) { return store4(coord, vec4(value, 0, 1)); }\nbool store1(vec2 coord, float value) { return store4(coord, vec4(value, 0, 0, 1)); }\n\nfloat keyDown(int keyCode) {\n    return texture(iChannel2, vec2((float(keyCode) + 0.5) / 256., .5/3.), 0.0).r;   \n}\n\nfloat keyPress(int keyCode) {\n    return texture(iChannel2, vec2((float(keyCode) + 0.5) / 256., 1.5/3.), 0.0).r;   \n}\n\nfloat keySinglePress(int keycode) {\n    bool now = bool(keyDown(keycode));\n    bool previous = bool(texture(iChannel0, vec2(256. + float(keycode) + 0.5, 0.5) / iResolution.xy, 0.0).r);\n    return float(now && !previous);\n}\n\n\nfloat keyToggled(int keyCode) {\n    return texture(iChannel2, vec2((float(keyCode) + 0.5) / 256., 2.5/3.), 0.0).r;   \n}\n\nfloat rectangleCollide(vec2 p1, vec2 p2, vec2 s) {\n    return float(all(lessThan(abs(p1 - p2), s)));   \n}\n\nfloat horizontalPlayerCollide(vec2 p1, vec2 p2, float h) {\n    vec2 s = (vec2(1) + vec2(.6, h)) / 2.;\n    p2.y += h / 2.;\n    return rectangleCollide(p1, p2, s);\n}\n\n\n/*\nvoxel getCachedVoxel(vec3 p) {\n    return getCachedVoxel(p,iChannel1,iChannelResolution[1],BUFFER_B);\n}*/\n\nfloat isSolidVoxel(bool slope,vec3 p) {\n    voxel t;\n    getCVoxel(p,t,0);\n    return isSolidVoxel(t) * (!slope || t.shape!=6?1.:0.);\n}\n\nstruct rayCastResults {\n    bool hit;\n    vec3 mapPos;\n    vec3 normal;\n};\n\nrayCastResults  getMouseRay(){\n       \n   vec4 mouseRay=  texture(iChannel3, vec2(0.));\n   rayCastResults res;\n   res.hit = mouseRay.a!=0.;\n   res.mapPos = mouseRay.rgb;\n    \n   float eN = mouseRay.a -1.;\n   res.normal=vec3(mod(eN,3.),floor(mod(eN,9.)/3.),floor(eN/9.))- vec3(1.);  \n   return res;\n}\n\nfloat mouseSelect(vec2 c,float h) {\n\tfloat scale = floor(iResolution.y / 128.);\n    c /= scale;\n    vec2 r = iResolution.xy / scale;\n    float xStart = (r.x - 16. * NUM_ITEMS) / 2.;\n    c.x -= xStart;\n    if (c.x <NUM_ITEMS * 16. && c.x >= 0. && c.y < 16.*h) {\n        float slot = floor(c.x / 16.) + NUM_ITEMS*floor(c.y / 16.);\n    \treturn slot;\n    }\n\n    return -1.;\n}\n\nbool mouseDoubleClick(){\n    \n    if(iMouse.z <1. ) {\n   \n        int changeCount=0;\n        for(int i=0;i<20;i++){\n\n            int mouseChange=          \n               (load(_old *vec2(i) + _mouse ).z>0.?0:1)\n              +(load( _old * vec2(i+1) +_mouse ).z>0.?0:1);\n\n\n            if(mouseChange==1)changeCount++;\n            if(load(_mouseBusy).r>0.) {store1(_mouseBusy,float(1.));return false;}\n                               \n            if(changeCount>2){\n                //if(load(_time).r - load(_old*vec2(i) +_time).r<1.) return false;\n                if(length(load(_mouse).xy -load(_old * vec2(i+1) +_mouse).xy)>.05) return false;\n                store1(_mouseBusy,float(1.));\n                return true;\n\n            }         \n        }\n    }\n    store1(_mouseBusy,float(0.));\n    return false; \n}\n\n\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//From https://www.shadertoy.com/view/4djGRh\nfloat tileableWorley(in vec2 p, in float numCells)\n{\n\tp *= numCells;\n\tfloat d = 1.0e10;\n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n\t\t\tvec2 tp = floor(p) + vec2(xo, yo);\n\t\t\ttp = p - tp - hash22(256. * mod(tp, numCells));\n\t\t\td = min(d, dot(tp, tp));\n\t\t}\n\t}\n\treturn sqrt(d);\n\t//return 1.0 - d;// ...Bubbles.\n}\n\nfloat crackingAnimation(vec2 p, float t) {\n    t = ceil(t * 8.) / 8.;\n\tfloat d = 1.0e10;\n    //t *= ;\n    for (float i = 0.; i < 25.; i++) {\n    \tvec2 tp = hash22(p )-.5; //texture(iChannel1, vec2(4, i) / 256.).xy - 0.5;\n        tp *= max(0., (length(tp) + clamp(t, 0., 1.) - 1.) / length(tp));\n        d = min(d, length(tp + 0.5 - p));\n    }\n    return pow(mix(clamp(1. - d * 3., 0., 1.), 1., smoothstep(t - 0.3, t + 0.3, max(abs(p.x - 0.5), abs(p.y - 0.5)) * 2.)), .6) * 1.8 - 0.8;\n}\n\nfloat brickPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x - 4. * step(4., mod(c.y, 8.)), 8.) > 7.) o = 0.;\n    return o;\n}\nfloat woodPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x + 2. - 6. * step(4., mod(c.y, 8.)), 16.) > 15.) o = 0.;\n    return o;\n}\n\n\n\n\n//textures from https://www.shadertoy.com/view/4ds3WS by Reinder\nvoid setTexture( out vec4 o, in vec2 fragCoord )\n{\n    \n \tif(fragCoord.x>8.*16. || fragCoord.y >10.*16.) discard;\n    vec2 gridPos = floor((fragCoord -vec2(0.,32.))/ 16.) ;\n    vec2 c = mod(fragCoord, 16.);\n    int id = int(gridPos.x + gridPos.y * 8.);\n \n   \n    vec2 uv = floor( c );\t\n    float h = hash12(uv +vec2(float(id)));\n    float br = 1. - h * (96./255.);\t\t\n\tfloat xm1 = mod((uv.x * uv.x * 3. + uv.x * 81.) / 4., 4.);\n\n    if (iFrame > 10 && iChannelResolution[0].x > 0. && id!=32  ) discard;\n    o.a = 1.;\n    if (id == 0) { //NO TEXTURE\n    \to = vec4(1,0,1,1);\n    }\n    if (id == 1) { //STONE\n       \n        o.rgb =  vec3( 127./255., 127./255., 127./255.) *br;        \n    }\n    if (id == 2) { //DIRT\n        \n        o.rgb =  vec3( 150./255., 108./255.,  74./255.) *br;\n    }\n    if (id == 3) { //GRASS LATERAL\n        \n        o.rgb =  vec3( 150./255., 108./255.,  74./255.) *br;\n        if (c.y  + hash( c.x*2.) *3.  > 14. ) \n         o.rgb =  vec3( 96./255., 157./255.,  59./255.)*br;\n    }\n    if (id == 4) { //GRASS UP\n   \t\t\n        o.rgb = vec3( 96./255., 157./255.,  59./255.)*br;\n    }\n    if (id == 5) { //ROCK\n       \n        o.rgb = vec3( 106./255., 170./255.,  64./255.)*br;\n        o.rgb = vec3(clamp(pow(1. - tileableWorley(c / 16., 4.), 2.), 0.2, 0.6) + 0.2 * tileableWorley(c / 16., 5.));\n \n    }\n    if (id == 6 || id == 26) {//LIGHT OR FIREFLY\n        float w = 1. - tileableWorley(c / 16., 4.);\n        float l = clamp(0.7 * pow(w, 4.) + 0.5 * w, 0., 1.);\n        o.rgb = mix(vec3(.3, .1, .05), vec3(1,1,.6), l);\n        if (w < 0.2) o.rgb = vec3(0.3, 0.25, 0.05);\n    }\n    if (id == 7) { //BRICK\n        o.rgb = vec3( 181./255.,  58./255.,  21./255.)*br; \n\t\tif ( mod(uv.x + (floor(uv.y / 4.) * 5.), 8.) == 0. || mod( uv.y, 4.) == 0.) {\n\t\t\to.rgb = vec3( 188./255., 175./255., 165./255.); \n\t\t}\n        \n    \t//o.rgb = -0.1 * hash12(c) + mix(vec3(.6,.3,.2) + 0.1 * (1. - brickPattern(c + vec2(-1,1)) * brickPattern(c)), vec3(0.8), 1. - brickPattern(c));\n    }\n    if (id == 8) {//GOLD\n    \to.rgb = mix(vec3(1,1,.2), vec3(1,.8,.1), sin((c.x - c.y) / 3.) * .5 + .5);\n        if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(1,.8,.1);\n    }\n    if (id == 9) { //WOOD\n        \n         o.rgb= vec3(0.5,0.4,0.25)*(0.5 + 0.5 * woodPattern(c))*br;        \n    }    \n    if (id == 10) {//TREE\n\t\t\n        if ( h < 0.5 ) {\n\t\t\tbr = br * (1.5 - mod(uv.x, 2.));\n\t\t}\n        o.rgb = vec3( 103./255., 82./255.,  49./255.)*br; \t\t\t\t\n\t}\t\n    if (id == 11) {//LEAF\n\t        o.rgb=  vec3(  40./255., 117./255.,  38./255.)*br;\t\t\n\t}\n    if (id == 12) {//WATER\t\t\n        o.rgb=vec3(  64./255.,  64./255., 255./255.)*br;\t\t\n\t}\t\n    if (id == 13) {//SAND\n\t\t//getMaterialColor(10,c,o.rgb);\n\t\to.rgb= vec3(0.74,0.78,0.65);\n\t}\t\n    if (id == 14) {//RED APPLE\t- MIRROR\t\n\t\to.rgb= vec3(.95,0.,0.05);\n       \n\t}\n    if (id == 15) {//PINK MARBLE\t\n        o.rgb= vec3(.95,0.5,.5)*br;\n    \t//o.rgb = mix(vec3(.2,1,1), vec3(1,.8,.1), sin((c.x - c.y) / 3.) * .5 + .5);\n       // if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(.1,.8,1);\n       \n\t}\n    if (id == 16) { //BEDROcK\n        \n    \n        o.rgb =   .2*vec3( 127./255., 127./255., 127./255.) *br;   \n    }\n    if (id == 17) {//DIAMOND\t\n       \n    \to.rgb = mix(vec3(.2,1,1), vec3(.1,.8,1), sin((c.x - c.y) / 3.) * .5 + .5);\n       if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(.1,.8,1);\n       \n\t}\n /*   \n    \n    if (id == 18) {//\t\n        o.rgb= vec3(0.04, 0.14, 0.42)*br;\n       \n\t}\n    if (id == 19) {//\t\n        o.rgb=  vec3(0.05, 0.50, 0.95)*br;\n       \n\t}\n    if (id == 20) {//\t\n        o.rgb= vec3(0.36, 0.72, 0.68)*br;\n       \n\t}\n    if (id == 21) {//\t\n        o.rgb= vec3(0.48, 0.46, 0.28)*br;\n       \n\t}\n    if (id == 22) {//\t\n        o.rgb= vec3(0.69, 0.58, 0.27)*br;\n       \n\t}\n    if (id == 23) {//\t\n        o.rgb= vec3(0.42, 0.51, 0.20)*br;\n       \n\t}    \n    if (id == 24) {//\t\n        o.rgb= vec3(0.23, 0.53, 0.16)*br;\n       \n\t}\n    if (id == 25) {//\t\n        o.rgb= vec3(0.06, 0.20, 0.07)*br;\n       \n\t}\n    if (id == 26) {//\t\n        o.rgb= vec3(0.32, 0.33, 0.27)*br;\n       \n\t}\n    if (id == 27) {//\t\n        o.rgb= vec3(0.25, 0.37, 0.41)*br;\n       \n\t}\n    if (id == 28) {//\t\n        o.rgb= vec3(0.44, 0.67, 0.74)*br;\n       \n\t}  \n    if (id == 29) {//\t\n        o.rgb= vec3(0.73, 0.86, 0.91)*br;\n       \n\t}  \n*/  \n\n    if (id == 32) { //DESTROYING BLOCK ANIMATION\n    \to.rgb = vec3(crackingAnimation(c / 16., load(_pickTimer).r));\n    }\n    if (id == 48) { \n    \to = vec4(vec3(0.2), 0.7);\n        vec2 p = c - 8.;\n        float d = max(abs(p.x), abs(p.y));\n        if (d > 6.) {\n            o.rgb = vec3(0.7);\n            o.rgb += 0.05 * hash12(c);\n            o.a = 1.;\n            if ((d < 7. && p.x < 6.)|| (p.x > 7. && abs(p.y) < 7.)) o.rgb -= 0.3;\n        }\n        o.rgb += 0.05 * hash12(c);\n        \n    }\n    \n}\n\n/*--------------------\n\nx=0 && y<256: global variables\nx=0 &&  256<=y<512: keyboard state for each ascii code with millisecs since laste change\n1<=x<16 y<512: previous values fo variables and keys\nx<= 128 && 16<=y< 140 : textures \n\n\n*///-------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    currentCoord = fragCoord;\n    if(fragCoord.x>512. || fragCoord.y >160.) discard;\n    vec2 texCoord = floor(fragCoord);\n    if (texCoord.x < 512. && texCoord.y<30.) {\n        if (texCoord.y == varRow) {\n            if (texCoord.x >= 256.) {\n                fragColor.r = texture(iChannel2, (fragCoord - 256.) / vec2(256,3)).r;\n                vec4 old = texture(iChannel0, (_old + fragCoord) / iChannelResolution[0].xy);\n                if (fragColor.r != old.r) old.a = 0.;\n                fragColor.a = old.a + iTimeDelta;\n            }\n            else {\n                vec3 pos = load(_pos).xyz;\n                vec3 oldPos = pos;\n                vec3 offset = vec3(floor(pos.xy), 0.);\n                vec2 angle = load(_angle).xy;\n                vec4 oldMouse = load(_mouse);\n                vec3 vel = load(_vel).xyz;\n                vec4 mouse = iMouse / length(iResolution.xy);\n                float renderScale = load(_renderScale).r;\n                vec2 time = load(_time).rg;\n                vec2 flightMode = load(_flightMode).rg;\n                vec2 sprintMode = load(_sprintMode).rg;\n                float selected = load(_selectedInventory).r;\n                float dt = min(iTimeDelta, .05);\n                float rayDistMax = max(load(_rayDistMax).r,50.);\n\t\t\t\t\n                float pixelSize =load(_pixelSize).r;\n                float inventory =load(_inventory).r;\n                float demo =load(_demo).r;\n\t\t\t\tfloat map=load(_map).r;;\n\n                    \n                if (iFrame <2  ) {\n#ifdef FAST_NOISE  \n                    pos = vec3(2952.8,10140.8,89.);\n                    offset = vec3(floor(pos.xy), 0.);\n                    oldPos = pos;\n                    angle = vec2(-0.6,1.8  );                   \n#else\n                    pos = vec3(3265.5,9654.5,50.);                   \n                    angle = vec2(-2.,1.6  );\n#endif                    \n                    demo=1.;\n                    oldMouse = vec4(-1);\n                    vel = vec3(0);\n                    renderScale = -2.;\n                    time = vec2(0.,4);\n                    selected = 0.;\n                    inventory=0.;\n                    rayDistMax=250.;\n                    map=1.;\n                    pixelSize=2.;\n                }\n                if(demo>0. && \n                   (keyDown(KEY_JUMP)>.0||keyDown(KEY_FORWARDS)>0. || iMouse.z>0. ))\n                {\n                    inventory=1.;\n                    map=1.;\n                    demo=0.;\n                }\n                \n                if ( bool(keyDown(KEY_TELEPORT))) {\n\t\t\t\t\t\n                    if(hash(iTime) <.5) pos=vec3(3221.5,10159.5,70.);\n                    else pos =vec3(hash33(pos).xy *10000.,72.); \n                       \n                    offset = vec3(floor(pos.xy), 0.);\n                    oldPos = pos;\n                    time.r=hash13(pos)*1200.;\n                    oldMouse = vec4(-1);\n                    vel = vec3(0);\n                    renderScale = -2.;                  \n                    selected = 0.;\n                    rayDistMax=250.;\n                }\n                if (oldMouse.z > 0. && iMouse.z > 0. && map<1.5)\n                    if(1==1){\n                        float zoom = pow(10., load(_renderScale).r/10.);\n                        angle += 5.*(mouse.xy - oldMouse.xy) * vec2(-1,-1)/zoom;\n                        angle.y = clamp(angle.y, 0.1, PI - 0.1);\n                    }\n                vec3 dir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n                vec3 dirU = vec3(normalize(vec2(dir.y, -dir.x)), 0);\n                vec3 dirV = cross(dirU, dir);\n                vec3 move = vec3(0);\n\n                \n                vec3 dirFwd = vec3(cos(angle.x), sin(angle.x), 0);;\n                    vec3 dirRight = vec3(dirFwd.y, -dirFwd.x, 0);\n                vec3 dirUp = vec3(0,0,1);\n                \n                float inBlock = 0.;      \n                vec3  vColPos, hColPos;\n                \n                //z of closest  blocks below\n                float minHeight = 0.; \n                \n                //z of closest  blocks above\n                float maxHeight = 1000.;\n                \n                //XY of closest lateral blocks\n                float minX = pos.x - 1000.; \n                float maxX = pos.x + 1000.;\n                float minY = pos.y - 1000.;\n                float maxY = pos.y + 1000.;\n#ifndef XRAY_MODE\n                if(isSolidVoxel(false,pos-offset) >.5)  pos.z+=clamp(3./iTimeDelta,.3,1.);\n                \n                //DOWN\n                for (float i = 0.; i < 4.; i++) {\n                    vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z - 1. - i));\n                    float solid=0.;\n                    for(int j=0;j<4;j++){\n                        solid+=\n                          isSolidVoxel(false,vColPos - offset + vec3(j/2,j%2,min(iFrame,0))) * rectangleCollide(vColPos.xy + vec2(0.5 +float(j/2),0.5+float(j%2)), pos.xy, vec2(.8));\n                    }\n                    if ( solid> .5) {\n                        minHeight = vColPos.z + 1.001; \n                        inBlock = 1.;\n                        break;\n                    }\n                }\n\t\t\t\t\n                //UP\n                vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z + 1.8 + 1.));\n                float solidUp=0.;\n                for(int j=0;j<4;j++){\n                 \tsolidUp+= isSolidVoxel(false,vColPos - offset + vec3(j/2,j%2,min(iFrame,0))) * rectangleCollide(vColPos.xy + vec2(0.5 +float(j/2),0.5+float(j%2)), pos.xy, vec2(.8));\n                }\n\t\t\t\tif(  solidUp > .5) {\n                    maxHeight = vColPos.z - 1.8 - .001; \n                    inBlock = 1.;     \n\n                }\n               \n                //LATERAL\n                float solidL[4];\n                for(int i=0;i<4;i++){\n                    vec2 posL;\n                    vec2 hColPosL;\n                    if(i==0) {hColPos = vec3(floor(pos.xy - vec2(.3, .5)) + vec2(-1,0), floor(pos.z)); hColPosL=hColPos.yz;posL=pos.yz;}\n                    if(i==1) {hColPos = vec3(floor(pos.xy - vec2(-.3, .5)) + vec2(1,0), floor(pos.z));hColPosL=hColPos.yz;posL=pos.yz;}\n                    if(i==2) {hColPos = vec3(floor(pos.xy - vec2(.5, .3)) + vec2(0,-1), floor(pos.z));hColPosL=hColPos.xz;posL=pos.xz;}\n                    if(i==3) {hColPos = vec3(floor(pos.xy - vec2(.5, -.3)) + vec2(0,1), floor(pos.z));hColPosL=hColPos.xz;posL=pos.xz;}\n                    solidL[i]=0.;\n                    for(int j=0;j<6;j++){\n                        \n       \n                        solidL[i ] += isSolidVoxel(true,hColPos - offset + vec3((i/2)*(j%2),(1-i/2)*(j%2),(j/2)+min(iFrame,0))) \n                            * horizontalPlayerCollide(hColPosL + vec2(0.5+float(j%2), 0.5+float(j/2)), posL, 1.8);\n                    }\n                \n                    if(i==0 && solidL[i]>.5) minX = hColPos.x + 1.301;\n                    if(i==1 && solidL[i]>.5) maxX = hColPos.x - .301;\n                    if(i==2 && solidL[i]>.5) minY = hColPos.y + 1.301;\n                    if(i==3 && solidL[i]>.5) maxY = hColPos.y - .301;\n                }\n                \n\n                \n                if (abs(pos.z - minHeight) < 0.01) flightMode.r = 0.; \n#else\n                flightMode.rg=vec2(.3,1.);\n                if(iFrame==0) pos.z=65.;\n#endif\n                \n                if (bool(keySinglePress(KEY_JUMP))) {\n                    if (flightMode.g > 0.) {\n                        flightMode.r = 1.- flightMode.r;\n                        sprintMode.r = 0.;\n                    }\n                    flightMode.g = 0.3;\n                }\n                flightMode.g = max(flightMode.g - dt, 0.);\n\n                if (bool(keySinglePress(KEY_FORWARDS))) {\n                    if (sprintMode.g > 0.) sprintMode.r = 1.;\n                    sprintMode.g = 0.3;\n                }\n                if (!bool(keyDown(KEY_FORWARDS))) {\n                    if (sprintMode.g <= 0.) sprintMode.r = 0.;\n                }\n                sprintMode.g = max(sprintMode.g - dt, 0.);\n\n                vec3 stats =vec3(\n                    bool(keyToggled(KEY_STATS))?1.:0.,\n                    bool(keyToggled(KEY_DUMP1))?1.:0.,\n                    bool(keyToggled(KEY_DUMP2))?1.:0.\n                );\n                float torch = bool(keyToggled(KEY_TORCH))?1.:0.;\n                float flow = bool(keyToggled(KEY_FLOW))?1.:0.;\n                \n                map = mod( map +keyPress(KEY_MAP),3.);\n                inventory = floor(mod( inventory + keyPress(KEY_INVENTORY),3.));\n                if(inventory<2.) selected=clamp(selected,0., NUM_ITEMS-1.);\n\n                float loadDistLimit=80.;\n                float rayLimit=500.; \n                if(bool(keyToggled(KEY_INCREASE_PERFORMANCE))){        \n                    pixelSize=max(2.,pixelSize) ;\n                    loadDistLimit=50.;\n                    rayLimit=200.;\n                }\n                pixelSize=clamp( pixelSize  + keyPress(KEY_INCREASE_PIXELSIZE) - keyPress(KEY_DECREASE_PIXELSIZE)  ,1.,4.);\n\n\n                if (bool(flightMode.r)) {\n                    if (length(vel) > 0.) vel -= min(length(vel), 25. * dt) * normalize(vel);\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    vel += 50. * dt * dirUp * sign(keyDown(KEY_JUMP) - keyDown(KEY_SNEAK));\n                    if (length(vel) > 20.) vel = normalize(vel) * 20.;\n                }\n                else {\n                    vel.xy *= max(0., (length(vel.xy) - 25. * dt) / length(vel.xy));\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirFwd * 0.4 * sprintMode.r;\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    if (abs(pos.z - minHeight) < 0.01) {\n                        vel.z = 9. * keyDown(32);\n                    }\n                    \n                    else {\n                        //voxel t;\n                        //getCVoxel(pos -offset,t,0);\n                        //bool isWater=(t.id ==12.);\n                        vel.z -= 32. * dt;\n                        vel.z = clamp(vel.z, -80., 30.);\n                    }\n\t\t\t\t\t\n                    if (length(vel.xy) > 4.317 * (1. + 0.4 * sprintMode.r)) vel.xy = normalize(vel.xy) * 4.317 * (1. + 0.4 * sprintMode.r);\n                }\n\n\n                pos += dt * vel; \n                if (pos.z < minHeight) {\n                    pos.z = minHeight;\n                    vel.z = 0.;\n                }\n                if (pos.z > maxHeight ) {\n                    pos.z = maxHeight;\n                    vel.z = 0.;\n                }\n                \n                if (pos.x < minX) {\n                    pos.x = minX;\n                    vel.x = 0.;\n                }\n                if (pos.x > maxX) {\n                    pos.x = maxX;\n                    vel.x = 0.;\n                }\n                if (pos.y < minY) {\n                    pos.y = minY;\n                    vel.y = 0.;\n                }\n                if (pos.y > maxY) {\n                    pos.y = maxY;\n                    vel.y = 0.;\n                }\n\n                float timer = load(_old+_pickTimer).r;\n                vec4 oldPick = load(_old+_pick);\n                vec4 pick;\n                float pickAction;\n                           \n                rayCastResults mousePointer = getMouseRay();\n            \n                bool dblClk =mouseDoubleClick();\n                if(dblClk){\n                    if (mousePointer.hit ) {\n                        \n                            pick.xyz = mousePointer.mapPos;\n                            pick.a = 7.;\n                  }                \n                }\n                \n                if (iMouse.z > 0. ) {                    \n                    \n                    float h= (inventory>1.?NUM_ITEM_ROWS:1.);\n                    float slot = mouseSelect(iMouse.xy,h);\n                    if(slot>= 0. && inventory>0. ){\n                        selected = slot;\n                    }\n                    else {\t\n                    \n                    if (mousePointer.hit ) {\n                        pick.xyz = mousePointer.mapPos;\n                        if (bool(keyDown(KEY_DESTROY))) {\n                            pick.a = 1.;\n                            store1(_pick,pick.a);\n                            timer += dt / 0.25;\n                        }\n                        else if (dblClk || bool(keySinglePress(KEY_PLACE))) {\n                            pick.a = 2.;\n                            pick.xyz += mousePointer.normal;                         \n                        }\n                        else if (bool(keySinglePress(KEY_SHAPE))) {\n                            pick.a = 3.;\n                        }\n                        else if (bool(keySinglePress(KEY_ROTATE_Z))) {\n                            pick.a = 4.;\n                         }\n                        else if (bool(keySinglePress(KEY_ROTATE_Y))) {\n                            pick.a = 5.;\n                        }\n                         else if (bool(keyDown(KEY_MULTISELECT))) {\n                            pick.a = 6.;\n                             store1(_pick,pick.a);\n                             timer += dt / 0.25;\n                        }\n                        if (oldPick != pick) timer = 0.;\n                    }\n                    else {\n                        //pick = vec4(-1,-1,-1,0);\n                        timer = 0.;\n                    }\n                }\n                }\n                else { \n                    \n                    // NO MOUSE KEY PRESSED  \n                    //pick = vec4(-1,-1,-1,0);\n\t\t\t\t\t\tif (bool(keyDown(KEY_DESTROY))) {\n                            pick.a = 1.;\n                            store1(_pick,pick.a);\n                            timer += dt / 0.25;\n                        }\n                        else if (bool(keySinglePress(KEY_PLACE))) {\n                            pick.a = 2.;\n                        }\n                        else if (bool(keySinglePress(KEY_SHAPE))) {\n                            pick.a = 3.;\n                         }\n                        else if (bool(keySinglePress(KEY_ROTATE_Z))) {\n                            pick.a = 4.;\n                        }\n                        else if (bool(keySinglePress(KEY_ROTATE_Y))) {\n                            pick.a = 5.;\n                        }\n                        else if (bool(keyDown(KEY_MULTISELECT))) {\n                            pick.a = 6.;\n                             store1(_pick,pick.a);\n                             timer += dt / 0.25;                   \n                        }else timer = 0.;\n                }\n\n\n                renderScale = clamp(renderScale + keySinglePress(KEY_DECREASE_ZOOM) - keySinglePress(KEY_INCREASE_ZOOM), -5., 10.);\n                time.g = clamp(time.g + keySinglePress(KEY_INCREASE_TIME_SCALE) - keyPress(KEY_DECREASE_TIME_SCALE), 0., 8.);\n                time.r = mod(time.r + dt * sign(time.g) * pow(2., time.g - 1.), 1200.);\n\n                bool still= length(pos-oldPos)<0.01 && length(angle -load(_angle).xy )<0.01  &&  iMouse.z<1.;\n                rayDistMax= rayLimit;/*clamp(rayDistMax  \n                                  +(still?10.:0.) \n                                  - ((iTimeDelta>0.03 && !still)?5.:0.)\n                                  -((iTimeDelta>0.1)?1.:0.) \n                                  -((iTimeDelta>0.1  && !still)?50.:0.) \n                                  + ((iTimeDelta<0.03 && still)?20.:0.)\n                                  ,loadDistLimit*2.5,rayLimit);*/\n\n\n                store3(_pos, pos);\n                store2(_angle, angle);\n                store4(_loadRange_B,calcLoadRange_B(pos.xy,iChannelResolution[1].xy,0.));\n#if SURFACE_CACHE>0\n                store4(_loadRange_C,calcLoadRange_C(pos.xy,iChannelResolution[1].xy,0.));\n#endif\n                store4(_mouse, mouse);\n                //store1(_inBlock, inBlock);\n                store3(_vel, vel);\n                store4(_pick, pick);\n                store1(_pickTimer, timer);\n                store1(_renderScale, renderScale);\n                store1(_selectedInventory, selected);\n                store2(_flightMode, flightMode);\n                store2(_sprintMode, sprintMode);\n                store2(_time, time);\n                store3(_stats, stats);\n                store1(_rayDistMax, rayDistMax);\n                store1(_loadDistLimit, loadDistLimit);\n                store1(_rayLimit, rayLimit);\n                store1(_map,map);\n                store1(_pixelSize,pixelSize);\n                store1(_inventory,inventory);\n                store1(_demo,demo);\n                store1(_torch,torch);\n                store1(_flow,flow);\n               \n\n\n                fragColor = outValue;\n            }\n        }  \n        else fragColor = texture(iChannel0, (fragCoord - _old) / iChannelResolution[0].xy);\n    }\n#ifdef MC    \n    else if (texCoord.x < 512. && texCoord.y<32.) {\n            if(iFrame>3) discard;\n            else if(texCoord.y<31.&& texCoord.x<256.)\n            {\n               int _edgeTable[256]= int[256](\n                -1   , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, \n                0x190, 0x099, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, \n                0x230, 0x339, 0x033, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, \n                0x3a0, 0x2a9, 0x1a3, 0x0aa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, \n                0x460, 0x569, 0x663, 0x76a, 0x066, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, \n                0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0x0ff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, \n                0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x055, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, \n                0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0x0cc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, \n                0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0x0cc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, \n                0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x055, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, \n                0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0x0ff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, \n                0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x066, 0x76a, 0x663, 0x569, 0x460, \n                0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0x0aa, 0x1a3, 0x2a9, 0x3a0, \n                0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x033, 0x339, 0x230, \n                0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x099, 0x190, \n                0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0\n               );\n               fragColor=vec4(_edgeTable[int(texCoord.x)]);\n           }\n           else if(texCoord.y<32.&& texCoord.x<256.){\n\n            int  _triTableCompact[1024] = int[1024](\n                65535,65535,65535,65535, 62336,65535,65535,65535, 63760,65535,65535,65535, 37761,65304,65535,65535, 64033,65535,65535,65535, \n                4992,65442,65535,65535, 2601,65426,65535,65535, 9090,39562,65528,65535, 62131,65535,65535,65535, 33456,65291,65535,65535, \n                8337,65459,65535,65535, 4785,35257,65531,65535, 45475,65338,65535,65535, 416 ,47272,65530,65535, 12435,43931,65529,65535, \n                43657,65464,65535,65535, 63604,65535,65535,65535, 28724,65347,65535,65535, 35088,65396,65535,65535, 18708,14103,65521,65535,\n                35361,65396,65535,65535, 14147,8512,65530,65535, 39465,18464,65527,65535, 10658,29305,18803,65535, 14152,65323,65535,65535,\n                46923,578 ,65524,65535, 33033,12916,65531,65535, 39796,47540,4754,65535, 12707,34731,65524,65535, 6833,436 ,19316,65535, 39028,\n                47536,12474,65535, 19316,47515,65530,65535, 62553,65535,65535,65535, 1113,65336,65535,65535, 5200,65285,65535,65535, 33880,4947,\n                65525,65535, 39457,65349,65535,65535, 6147,38050,65525,65535, 23077,1060,65522,65535, 13730,21330,33844,65535, 9305,65459,65535,\n                65535, 688 ,38072,65525,65535, 1104,12881,65531,65535, 9490,33413,22603,65535, 43834,22833,65524,65535, 1428,43032,43905,65535,\n                20549,46512,12474,65535, 22597,35496,65531,65535, 22649,65431,65535,65535, 36921,30005,65523,65535, 2160,20849,65527,65535, 13137,\n                65397,65535,65535, 39033,6773,65522,65535, 37402,13573,14160,65535, 33288,22610,9639,65535, 9634,21301,65527,65535, 30103,45976,\n                65522,65535, 38745,10535,46880,65535, 2866,29057,29976,65535, 45355,6001,65525,65535, 34905,6773,45987,65535, 20597,46992,40976,\n                61611, 45227,23088,28800,61557, 30123,65371,65535,65535, 62826,65535,65535,65535, 21376,65386,65535,65535, 20745,65386,65535,65535,\n                4993,42377,65526,65535, 9569,65302,65535,65535, 5473,866  ,65528,65535, 38249,8288,65526,65535, 22677,9512,33334,65535, 43826,65366,\n                65535,65535, 47115,27138,65525,65535, 10512,42419,65526,65535, 5797,47401,47250,65535, 27446,5429,65523,65535, 2944,20571,27473,65535,\n                1715,24675,38149,65535, 26966,39865,65528,65535, 18085,65415,65535,65535, 16436,22071,65530,65535, 20625,18538,65527,65535, 5482,\n                29049,18803,65535, 25110,29717,65528,65535, 21793,866 ,29748,65535, 38728,24656,25093,65535, 31031,9033,26969,63842, 29363,27208,\n                65525,65535, 18085,9255,46880,65535, 18704,12935,27227,65535, 37161,18731,19323,63141, 14152,21339,27473,65535, 23317,363 ,19323,\n                64320, 2384,12374,14006,63304, 26966,29881,39801,65535, 26954,65444,65535,65535, 18084,32937,65523,65535, 41226,17926,65520,65535,\n                33080,26721,41316,65535, 6465,25154,65524,65535, 6147,17042,17961,65535, 17440,65378,65535,65535, 33336,9282,65526,65535, 43338,\n                11078,65523,65535, 8832,38072,27210,65535, 691 ,24673,41316,65535, 24902,33953,45345,61880, 37993,6499,14003,65535, 33208,27393,\n                16785,61766, 14003,24582,65524,65535, 47174,65414,65535,65535, 30375,39080,65530,65535, 880,36986,42858,65535, 5994,29050,2072,\n                65535, 42858,28951,65523,65535, 5665,33158,30345,65535, 10594,30233,14601,63799, 28807,1632,65522,65535, 25143,65319,65535,65535,\n                43826,35462,30345,65535, 9986,37047,42855,63401, 4225,41351,42855,64306, 45355,27249,5985,65535, 34456,6518,14006,63025, 45456,\n                65398,65535,65535, 28807,45920,1712,65535, 63159,65535,65535,65535, 64359,65535,65535,65535, 47107,65383,65535,65535, 47376,65383,\n                65535,65535, 35096,31507,65526,65535, 25114,65403,65535,65535, 14881,46720,65527,65535, 8338,46746,65527,65535, 10166,35386,35235,\n                65535, 25383,65394,65535,65535, 30727,9734,65520,65535, 9842,4211,65529,65535, 4705,37224,26504,65535, 42618,12657,65527,65535, \n                5754,33191,32791,65535, 1840,41127,31337,65535, 31335,43146,65529,65535, 46214,65384,65535,65535, 15203,16480,65526,65535, 35688,\n                2404,65521,65535, 38473,14646,25521,65535, 25734,41611,65521,65535, 14881,24752,25611,65535, 18612,8374,39465,65535, 41882,18723,\n                25523,62308, 33576,25636,65522,65535, 16960,65318,65535,65535, 8337,16963,33606,65535, 5265,16932,65526,65535, 33560,18454,6758,\n                65535, 40986,1632,65524,65535, 17252,42627,37635,62362, 25754,65354,65535,65535, 30100,65462,65535,65535, 17280,31577,65526,65535,\n                20741,26372,65531,65535, 34427,21315,20788,65535, 42073,26401,65531,65535, 6070,32930,22851,65535, 23399,9380,8266,65535, 14403,\n                9029,9637,63099, 29479,17702,65529,65535, 1113,24680,30818,65535, 12899,20839,1104,65535, 26662,4728,22600,63569, 42073,29025,29462,\n                65535, 6753,359 ,1927,62553, 18948,12378,31338,64115, 31335,17802,43082,65535, 26006,35739,65529,65535, 2915,20534,22790,65535, \n                2224,4277,46677,65535, 25526,13651,65521,65535, 39457,47541,26040,65535, 944 ,37046,38486,64033, 46475,2149,9637,62752, 25526,\n                41555,13731,65535, 22917,25986,10290,65535, 38489,24582,65522,65535, 6225,25864,10296,63526, 9809,65377,65535,65535, 5681,33702,\n                38486,63128, 40986,22880,1616,65535, 22576,65446,65535,65535, 63066,65535,65535,65535, 31323,65461,65535,65535, 47707,14423,65520,\n                65535, 22453,37306,65520,65535, 42362,35195,4993,65535, 45595,22295,65521,65535, 4992,29042,45685,65535, 38265,2418,31522,65535, \n                29271,38322,33330,62089, 10834,29523,65525,65535, 32808,30757,21157,65535, 20745,13626,10807,65535, 37513,30738,21154,62039,\n                13617,65367,65535,65535, 1920,28951,65525,65535, 37641,13651,65527,65535, 22409,65401,65535,65535, 21637,47754,65528,65535, 21509,\n                42251,955 ,65535, 35088,43172,21675,65535, 42170,15188,5268,62483, 8530,45656,34120,65535, 2880,21563,6955,64277, 1312,45717,34117,\n                62859, 9545,65339,65535,65535, 14930,17189,18485,65535, 21157,9282,65520,65535, 12963,33701,34117,63760, 21157,37186,9362,65535, \n                34120,21301,65521,65535, 5440,65360,65535,65535, 34120,2357,21253,65535, 62793,65535,65535,65535, 18356,43449,65531,65535, 17280,\n                47481,47767,65535, 7073,16715,46192,65535, 13331,41348,46196,62650, 38836,10571,8603,65535, 38009,6523,6955,62336, 46203,16932,\n                65520,65535, 46203,14372,16948,65535, 10898,12951,38007,65535, 38825,10823,1927,63234, 14963,18218,2586,64004, 33441,65351,65535,\n                65535, 16788,6001,65523,65535, 16788,32881,6017,65535, 29444,65332,65535,65535, 63364,65535,65535,65535, 43177,65419,65535,65535,\n                14595,39865,65530,65535, 2576,43146,65531,65535, 47635,65443,65535,65535, 6945,47515,65528,65535, 14595,8633,39721,65535, 35616,\n                65456,65535,65535, 64291,65535,65535,65535, 10290,35496,65529,65535, 681 ,65321,65535,65535, 10290,4264,35352,65535, 62113,65535,\n                65535,65535, 38961,65409,65535,65535, 61840,65535,65535,65535, 63536,65535,65535,65535, 65535,65535,65535,65535\n            );\n\n             int id= int(texCoord.x)*4;\n             fragColor= vec4(_triTableCompact[id],_triTableCompact[id+1],_triTableCompact[id+2],_triTableCompact[id+3] );\n\n         }\n    }\n#endif    \n    else setTexture(fragColor,fragCoord);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void  lightDiffusion(inout voxel vox,in voxel temp ,vec3 rPos){\n    if(vox.id != 6. && vox.id != 26. ){\n \t   vox.light.s =  max( vox.light.s  ,  \ttemp.light.s  -(rPos.z==1.?0.:1.) - (vox.id==0.?0.: vox.id==11.?5.:15.));       \t\n \t   vox.light.t =  max( vox.light.t,   temp.light.t - (vox.id==0.|| vox.id==12.?1.:vox.id==11.? 5.:15.)); \n    \t\n    }        \n}\n\n//VOXEL MEMORY 1 - NEAR BLOCKS\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef EXCLUDE_CACHE\n    discard;\n#else\n   \n    vec2 textelCoord = floor(fragCoord);\n    vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    vec3 voxelCoord = texToVoxCoord(textelCoord, offset,BUFFER_B); \n\n    vec4 newRange= calcLoadRange_B(offset.xy,iChannelResolution[1].xy,0.);\n    \n    if(!inRange(voxelCoord.xy, newRange)) {discard;}\n    \n    vec4 pick = load(_pick);   \n\n    voxel vox ; \n    getVoxel( voxelCoord,vox,1);\n\n    if (voxelCoord == pick.xyz || vox.value==2 )  {\n        if(vox.value==0)vox.value=1;\n        \n        if (pick.a == 1. &&  vox.id != 16. && load(_pickTimer).r > 1.) \n        {vox.value=1; \n                vox.id = 0.; \n                vox.shape=0;  \n         \t\tvox.light.t=0.;\n         \t\tvox.life=0.;\n         \t\tvox.ground=0.;\n        }\n        else if (pick.a == 2.) \n        {\n            vox.id = getInventory(load(_selectedInventory).r);\n            if(vox.id==10.) vox.life=3.;\n            else if (vox.id==12.)vox.life=64.;\n            else vox.life=0.;               \n            vox.value=1;\n            vox.shape=0;\n        } \n        else if (pick.a == 3. && vox.id != 10. && vox.id != 11. && vox.id != 12.) \n          { if(vox.shape<7) vox.shape++; else vox.shape=0;}\n        else  if (pick.a == 4. && vox.id != 10. && vox.id != 11. && vox.id != 12.) \n          {if(vox.rotation<3.) vox.rotation++; else vox.rotation=0.;}\n        else if (pick.a == 5. && vox.id != 10. && vox.id != 11. && vox.id != 12.) \n          { if(vox.rotation<12.) vox.rotation+=4.; else vox.rotation= mod(vox.rotation , 4.);}     \n    } \n        \n     if(voxelCoord == pick.xyz  &&  pick.a == 6. ) \n     {vox.value= 2 ;}\n    \n    if(voxelCoord == pick.xyz  &&  pick.a == 7. ) \n     {\n        if(vox.value==2) vox.value=1;\n         else vox.value=2;          \n     }\n    if(load(_pickTimer).r >1. && pick.a == 6. && vox.value==2)\n     {vox.value= 1 ;}\n\n   \t// SUN LIGHT SOURCES\n   \n    if (voxelCoord.z >= heightLimit_B - 2.) {\n        vox.light.s = 15.;   \n    } else  {\n        //vox.light.s=0.; //correct but initial value is better oon surface\n        vox.light.s = lightDefault(voxelCoord.z);       \n    }\n    \n    // TORCH LIGHT SOURCES\n    if(vox.id==12.) vox.light.t=max(2.,vox.light.t);\n    else if(vox.id==6.) vox.light.t=15.;\n    else vox.light.t=clamp(vox.light.t- (hash(iTime)>.5?1.:0.),0.,15.);\n     \n    if(length( load(_pos).xyz + vec3(0,0,3.)- voxelCoord.xyz) <2.) vox.light.t=max( 12.,vox.light.t);\n  \n        \n        \n    voxel temp;\n    float air=0.;\n    //int border=0;    \n    \n    //NEIGHBOURS 2=ABOVE 5=BELOW, 0-1-3-4= SIDES\n    float iE=0.;\n      \n    float g=MAX_GROUND;\n    //vox.surface=0.;\n    voxel next[9];\n    for(int j=0;j<=2;j++){\n        for(int i=0;i<3;i++){\n            vec3 n= vec3(i==0?1.:0. ,i==1?1.:0.,i==2?1.:0.) * vec3((j==0?1.:-1.));\n#ifdef WATER_FLOW            \n            // lateral voxels, random direction\n            if(j==2) {\n                int k= int(hash(iTime)*4.);// iFrame%4;\n            \tn = vec3(   (1- k/2) * (-1 +(k%2)*2), (k/2)* (-1 +(k%2)*2)  ,1-i);;\n            }\n#endif            \n            voxel temp;\n            getVoxel(voxelCoord + n ,temp,1 );           \n    \t\tnext[i+3*j]= temp;\n            \n            if(vox.id==0. && temp.id!=0.) vox.surface=1.;\n            if(vox.id!=0. && temp.id==0. ) vox.surface=1.;\n            \n            if(j!=2){\n                if(voxelCoord.z> 80.) {vox.light.s=15.;vox.light.t=0.;}\n                else  lightDiffusion(vox,temp,n);\n\n                //ELECTRICITY DIFFUSION\n                if(vox.id==17.){\n                    if(temp.id==8.) iE=10.;\n                    if(temp.id==17. && temp.life>1.) iE=max(iE,temp.life-1.);\n                }\n                //GROUND DISTANCE\n                if(vox.id!=0. && vox.id!=12. &&vox.id!=26.){\n                    if(voxelCoord.z <=1.) g=1.;\n                    if(temp.id!=0. && temp.id!=12. &&vox.id!=26. && temp.ground>0. )  g=min(g, temp.ground+(i+3*j==5?0.:vox.id==13.?10.:1.)); \n                }\n\n               if(temp.id==0.) air += pow(2., float(j*3+i));\n\n                //LEAFS:\n               if(temp.id==11.  && temp.life>0. &&vox.id==0.) {vox.id=11.;  vox.life=temp.life-1.; }  \n            }\n        }\n    }\n      \n    vec3 pos = load(_pos).xyz;\n    \n    //ELECTRICITIY\n    if(vox.id==17.){\n        vox.life=max(iE,vox.life-1.);\n        //if(iE>0.) vox.light.t=15.; else vox.light.t=0.;\n    }\n    \n    //GROUND CONNECTION: blocks not connected to the ground or sand with 4+ horizontal steps\n    if(vox.id!=0. && vox.id!=12. &&vox.id!=26.){\n        vox.ground=clamp(min(vox.ground+2.,g),0.,MAX_GROUND);\n                \n        //FALLING BLOCK\n#ifdef FALLING_SAND\n        if(vox.ground>=MAX_GROUND \n           && length(pos.xy-voxelCoord.xy)<load(_loadDistLimit).r -5.\n           &&  (next[5].id==0.|| next[5].id==12.)) vox.value=3;\n#endif        \n    }\n           \n\tif(sdBox(pos-voxelCoord -vec3(0.,0.,1.),vec3(.5,.5,.5))<=.01 &&vox.id==3.) vox.id=2.;\n       \n    //ABOVE    \n    if(next[2].id==0.  &&  vox.id==2.) {if(hash13(voxelCoord +iTime ) >.95 && hash(iTime)>.99) vox.id=3.;vox.life=0.;}\n    if(next[2].id==0.  &&  vox.id==3.) {if(hash13(voxelCoord +iTime+30.) >.95 && hash(iTime +30.)>.99) vox.life=clamp(vox.life+1.,0.,3.);}\n    if(next[2].id==3.  &&  vox.id==3.) {vox.id=2.;}\n    if(next[2].value==3 && (vox.id==0.|| vox.id==12.)) {vox.id=next[2].id;} \n    \n    //BELOW\n    if(next[5].id==10.  && next[5].life>0. && vox.id==0.) {vox.id=10.;  vox.life=next[5].life-1.; vox.ground=0.;}\n    if(next[5].id==10.  && next[5].life<1.) {vox.id=11.;  vox.life=TREE_SIZE;}\t\n    if((next[5].id!=3.|| next[5].shape!=0)  &&  vox.id==0.) {vox.life=0.;}\n    if((next[5].id!=0.|| next[5].id==12.)  &&  vox.value==3) {vox.id=0.; vox.value=0;vox.life=0.;}\n\n#ifdef WATER_FLOW\n    if(load(_flow).r>0.5) {\n    if(vox.id==0.) vox.life=0.;           \n    if(vox.id==12. || vox.id==0.){\n    \t\n        float w= vox.id==12.?vox.life:0.;\n        float w_new=w;\n        \n        float w_U  = next[2].id==12.?next[2].life:0.;//(next[2].id==0.? 0.:-1.);\n        float w_D  = next[5].id==12.?next[5].life:(next[5].id==0.? 0.:-1.);\n        float w_LU = next[6].id==12.?next[6].life:(next[6].id==0.? 0.:-1.);\n        float w_L  = next[7].id==12.?next[7].life:(next[7].id==0.? 0.:-1.);\n        float w_LD = next[8].id==12.?next[8].life:(next[8].id==0.? 0.:-1.);\n\n               \n        float OW=.0;\n        float FL=.9; // lateral flow\n        //TRANSITIONS \n     \t//porting from https://www.shadertoy.com/view/WdjBDV\n\t\t\n        \n        //RULE 1 OUT          \n        if( w>0. && w_D < WATER_FLOW && w_D>-1.) { w_new =max(0.,w +w_D -WATER_FLOW   ); }       \n        //RULE 1 IN    \n         if( w_U>0. && w<WATER_FLOW ) {w_new=min(WATER_FLOW, w + w_U);}\n\n            \n         // RULE2_OUT \n        if(w>0. && (w_LD>= WATER_FLOW*OW || w_D<0.) && (w_L < w -2. ) && w_L>=0. && w_LU <1. )\n        {w_new= w -floor(w-w_L)*FL;}\n\n        //RULE2 IN        \n        if( ( w_L >0. ) && (w_LD>=WATER_FLOW*(1.-OW*2.) || w_LD<0.) && (w<w_L-2.) && (w_U <1.))\n        {w_new  =  w + floor((w_L-w)*FL );}  \n\n\n        //INFINITE SOURCE\n        if(next[7].id==15. || next[5].id==15. || next[2].id==15. ){ w_new  =  WATER_FLOW; }\n        \n        \n    \tif(w_new >0. && vox.value==0) {vox.id=12.; vox.life= clamp(w_new,0.,WATER_FLOW);}\n    \tif(w_new <.1 &&  vox.value==0){vox.id=0.;vox.life= 0.;}\n        if( vox.value==1) {vox.value=0;}\n#ifdef SUBVOXEL\n        //surface water is half block\n        if( next[2].id!=12. && vox.id==12.){\n            if(vox.life < WATER_FLOW*.3) vox.shape=2;\n            else vox.shape=3;\n             \n        }\n        else  vox.shape=0;\n    \n#endif\n        \n    }\n\t}\n#endif\n    if(next[5].id==3.  &&  vox.id==0.) {vox.life=1.;}\n    \n#ifdef TREE_DETAIL\t\n    if(vox.id==11.) vox.shape=8;\n    if(vox.id==10.) {vox.shape=9;};\n#endif\n\n#ifdef FIREFLIES \n    //if(vox.id==26.){vox.id=0.;  vox.light.t=15.;}\n    if(vox.id==26.){if(vox.light.t>1.) vox.light.t--; else vox.id=0.;vox.light.s=15.; }\n    \n    if(voxelCoord.z<35. || abs(load(_time).r-750.)<250.)\n        if( air>=62. && (voxelCoord.z < heightLimit_B - 1.)){\n            if(vox.id==0.  && hash13(voxelCoord +vec3(iTime))>0.9999  ) {vox.id=26.;  vox.light.t=15.;}\n        } \n#endif\n    \n#if STRUCTURES>0\n    vec3 oldOffset = floor(vec3(load(_old+_pos).xy, 0.));\n\tstructures( voxelCoord,   vox,  oldOffset,  iFrame,  iTime);\n#endif\n    \n    fragColor = encodeVoxel(vox);\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\nVOXEL MEMORY 2 - SURFACE \n  mode = 1 it's just a copy of buffer B, working in a limited z range\n  mode = 2 stores onlythe surface block with the height, for a wider area\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef EXCLUDE_CACHE\n    discard;\n#endif\n    \n#ifndef SURFACE_CACHE\n    discard;\n#elif SURFACE_CACHE==2\n    vec2 textelCoord = floor(fragCoord);\n    vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    vec3 voxelCoord = texToVoxCoord(textelCoord, offset,BUFFER_C); \n\n    vec4 newRange_C= calcLoadRange_C(offset.xy,iChannelResolution[1].xy,0.);\n\n    if(!inRange(voxelCoord.xy, newRange_C)) {\n        discard;\n     \n    }\n    voxel vox;  \n    getVoxel( voxelCoord,vox,2);\n\n    if(voxelCoord.z==0. && vox.ground >100.){\n    \tvoxel temp;\n        float h= vox.ground-100.;\n        getVoxel(vec3(voxelCoord.xy,h),temp,2);\n        float id = temp.id;\n        if(id !=0.){\n            vox=temp;\n            vox.ground=h;\n        }\n        else vox.ground--;           \n    } \t\n \n    //NEIGHBOURS\n    if(voxelCoord.z==0. && vox.ground<100.){\n       vec3 s = vec3(1.,0.,0. );\n       vec3 t = vec3(0.,1.,0. );    \n       voxel v[9];    \n       for (int i =-1; i <=1; i++) {\n            for (int j =-1; j <=1  ; j++) {\n               \n                getVoxel(voxelCoord + s* float(i)+t*float(j),v[4+ i+3*j +min(iFrame,0) ] ,2 ); \n                \n                voxel temp = v[4+ i+3*j ];\n                if(i+3*j !=0 && temp.id==10. && temp.ground <100. && temp.ground> vox.ground -TREE_SIZE -1.) {\n                \tvox.id=11.; vox.shape=8;vox.ground=temp.ground+TREE_SIZE+2.;vox.life=0.;\n                }\n            }\n        }\n    }\n    \n    fragColor = encodeVoxel(vox);\n\n#elif SURFACE_CACHE==1\n    vec2 textelCoord = floor(fragCoord);\n    vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    vec3 voxelCoord = texToVoxCoord(textelCoord, offset,BUFFER_C); \n\n    voxelCoord.z+=SURFACE_C;\n\t//vec4 newrange_B = calcLoadRange_B(offset.xy,iChannelResolution[1].xy,1.);\n    vec4 newRange_C= calcLoadRange_C(offset.xy,iChannelResolution[1].xy,0.);\n    //if (inRange(voxelCoord.xy,newrange_B)  ||    \n    if(!inRange(voxelCoord.xy, newRange_C)) {\n        discard;       \n    }\n\n    voxel vox;    \n    getVoxel( voxelCoord,vox,2);\n\n   \t// SUN LIGHT SOURCES  \n    if (voxelCoord.z >= heightLimit_C- 2.) {\n        vox.light.s = 15.;   \n    } else  {\n        //vox.light.s=0.; //correct but initial value is better oon surface\n        vox.light.s = lightDefault(voxelCoord.z);       \n    }\n    \n    // TORCH LIGHT SOURCES\n    if(vox.id==12.) vox.light.t=max(2.,vox.light.t);\n    else if(vox.id==6.) vox.light.t=15.;\n    if(length( load(_pos).xyz + vec3(0,0,3.)- voxelCoord.xyz) <2.) vox.light.t=max( 12.,vox.light.t);\n    \n    \n        \n\t//LIGHT DIFFUSE\n    voxel temp;\n    float air=0.;\n    //int border=0;    \n    \n   \n    //NEIGHBOURS 2=ABOVE 5=BELOW, 0-1-3-4= SIDES\n    float iE=0.;\n       \n    float g=MAX_GROUND;\n    \n    voxel next[6];\n    for(int j=0;j<=1;j++){\n        for(int i=0;i<3;i++){\n            vec3 n= vec3(i==0?1.:0. ,i==1?1.:0.,i==2?1.:0.) * vec3((j==0?1.:-1.));\n      \n            if(voxelCoord.z >= heightLimit_C +SURFACE_C-1.) break;\n            if( voxelCoord.z <SURFACE_C +1.) break;\n            voxel temp;\n            getVoxel(voxelCoord + n,temp,2);//- vec3(0.,0.,SURFACE_C));\n            \n    \t\tnext[i+3*j]= temp;\n            \n            if(voxelCoord.z> heightLimit_C +SURFACE_C) vox.light.s=15.;\n                else lightDiffusion(vox,temp,n);\n            \n            //ELECTRICITY DIFFUSION\n            if(vox.id==17.){\n            \tif(temp.id==8.) iE=10.;\n                if(temp.id==17. && temp.life>1.) iE=max(iE,temp.life-1.);\n            }\n\n            \n           if(temp.id==0.) air += pow(2., float(j*3+i));\n            \n            //LEAFS:\n           if(temp.id==11.  && temp.life>0. &&vox.id==0.) {vox.id=11.;  vox.life=temp.life-1.; }\n     \n        }\n    }\n    \n    \n    vec3 pos = load(_pos).xyz;\n    \n    //ELECTRICITIY\n    if(vox.id==17.){\n        vox.life=max(iE,vox.life-1.);\n        //if(iE>0.) vox.light.t=15.; else vox.light.t=0.;\n    }\n        \n\tif(sdBox(pos-voxelCoord -vec3(0.,0.,1.),vec3(.5,.5,.5))<=.01 &&vox.id==3.) vox.id=2.;\n    \n    \n    //ABOVE    \n    if(next[2].id==0.  &&  vox.id==2.) {if(hash13(voxelCoord +iTime ) >.95 && hash(iTime)>.99) vox.id=3.;vox.life=0.;}\n    if(next[2].id==0.  &&  vox.id==3.) {if(hash13(voxelCoord +iTime+30.) >.95 && hash(iTime +30.)>.99) vox.life=clamp(vox.life+1.,0.,3.);}\n    if(next[2].id==3.  &&  vox.id==3.) {vox.id=2.;}\n    if(next[2].id==12. && vox.id==0.) {vox.id=12.;}\n    if(next[2].value==3 && (vox.id==0.|| vox.id==12.)) {vox.id=next[2].id;} \n    \n    //BELOW\n    if(next[5].id==10.  && next[5].life>0. && vox.id==0.) {vox.id=10.;  vox.life=next[5].life-1.; vox.ground=0.;}\n    if(next[5].id==10.  && next[5].life<1.) {vox.id=11.;  vox.life=TREE_SIZE;}\n    if((next[5].id!=3.|| next[5].shape!=0)  &&  vox.id==0.) {vox.life=0.;}\n    if((next[5].id!=0.|| next[5].id==12.)  &&  vox.value==3) {vox.id=0.; vox.value=0;vox.life=0.;}\n    if(next[5].id==3.  &&  vox.id==0.) {vox.life=1.;}\n    \n#ifdef TREE_DETAIL\t\n    if(vox.id==11.) vox.shape=8;\n    if(vox.id==10.) {vox.shape=9;};\n#endif\n\n\n    // FIREFLIES \n    //if(vox.id==26.){vox.id=0.;  vox.light.t=15.;}\n    if(vox.id==26.){if(vox.light.t>1.) vox.light.t--; else vox.id=0.;vox.light.s=15.; }\n    \n    if(voxelCoord.z<35. || abs(load(_time).r-750.)<250.)\n        if( air>=62. && (voxelCoord.z < heightLimit_C +SURFACE_C - 1.)){\n            if(vox.id==0.  && hash13(voxelCoord +vec3(iTime))>0.9999  ) {vox.id=26.;  vox.light.t=15.;}\n\n        } \n\n#ifdef STRUCTURES\n    vec3 oldOffset = floor(vec3(load(_old+_pos).xy, 0.));\n\tstructures( voxelCoord,   vox,  oldOffset,  iFrame,  iTime);\n#endif\n    \n    fragColor = encodeVoxel(vox);\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#ifdef MC\n\n\nint gFrame=0; \n\n//--------------------\n//porting of \"Marching Cubes\" algorithm by Paul Bourke (1994)\n//http://paulbourke.net/geometry/polygonise/ \n struct TRIANGLE {\n   vec3 p[3];\n} ;\n\n\n struct GRIDCELL{\n   vec3 p[8];\n   float val[8];\n} ;\n\n const vec3 VertexOffset[8] =vec3[8]\n(\n        vec3(0,0,0), vec3(1,0,0),vec3(1,1,0),vec3(0,1,0),\n        vec3(0,0,1), vec3(1,0,1),vec3(1,1,1),vec3(0,1,1)\n);\n\n\n//lookup tables retrieved from BufferA\n#define edgeTable(i) int(texelFetch(confChannel, ivec2(i,30),0).x)\n#define triTableRow(i) ivec4(texelFetch(confChannel, ivec2(i,31),0))\n#define triTableVal(tt,j) int((tt[j>>2]&(15*(1<<((j&3)*4))))>>((j&3)*4))\n\nconst int  vertexTable[24] =int[24](\n   0,1,   1,2,  2,3,   3,0, \n   4,5,   5,6,  6,7,   7,4,   \n   0,4,   1,5,  2,6,   3,7);\n   \n/*\n   Linearly interpolate the position where an isosurface cuts\n   an edge between two vertices, each with their own scalar value\n*/\nfloat  VertexWeight(float isolevel,float valp1, float valp2)\n{  \n   return  (isolevel - valp1) / (valp2 - valp1);\n}\n\n//input: isolevel value at 8 cube vertexs and isolevel threshold\n//output: number of triangles (-1= outside) and list of triangles (up to 5 in worst case)\nuvec4  Polygonise(inout GRIDCELL grid,float isolevel,inout TRIANGLE[5] triangles,sampler2D confChannel)\n{\n \n   /*\n      Determine the index into the edge table which\n      tells us which vertices are inside of the surface\n   */\n   int cubeindex = 0;\n   for(int i=gFrame;i<8;i++) if (grid.val[i] < isolevel) cubeindex |= 1<<i;\n\n   /* Cube is entirely in/out of the surface -1=IN, 0=OUT */\n   int e=edgeTable(cubeindex);\n   if ( e<= 0) return uvec4(e);\n\n   /* Find the vertices where the surface intersects the cube */\n   vec3 vertlist[12];\n   float vertW[12];\n\n\n   for(int i=0;i<12;i++)\n   if ((e & (1<<i))>0)  {\n       vertW[i]= VertexWeight(isolevel,grid.val[vertexTable[i*2]], grid.val[vertexTable[i*2+1]]);\n          \n       vertlist[i]= mix( grid.p[vertexTable[i*2]], grid.p[vertexTable[i*2+1]],vertW[i]);\n   }\n   /* Create the triangle */\n   uvec4 tridata=uvec4(0u); //x=number of triangles, yzw= tritable\n   \n   ivec4 ttr=triTableRow(cubeindex); \n   for (int i=gFrame;triTableVal(ttr,i)!=15 && i<15;i+=3) {\n       \n       for(int j=gFrame;j<3;j++)   {\n           uint k =uint(triTableVal(ttr,(i+j)));\n           int idx =(i+j);\n           if(idx<8) tridata.y +=  k*( 1u<<(idx*4));\n           else tridata.z += k*( 1u<<(idx*4-32));\n        \n           tridata.w+=  uint( floor(vertW[k]*4. )  ) \n                        *( 1u<<(idx*2));\n           triangles[tridata.x].p[j] = vertlist[k];\n       }\n      \n      tridata.x++;\n   }\n\n   return uvec4(tridata);\n}\n//-------------------------------------\n//Iq\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); \n    \n    //vec3 normal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n\n\n// triangle degined by vertices v0, v1 and  v2\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n    vec3  n = cross( v1v0, v2v0 );\n    \n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    return vec3( t, u, v );\n}\n#endif\n//--------------------------\nvec2 max24(vec2 a, vec2 b, vec2 c, vec2 d) {\n\treturn max(max(a, b), max(c, d));   \n}\n\nfloat lightLevelCurve(float t) {\n    t = mod(t, 1200.);\n\treturn 1. - ( smoothstep(400., 700., t) - smoothstep(900., 1200., t));\n}\n\nvec3 lightmap(in vec2 light) {\n    light = 15. - light;\n\tif(load(_torch).r>0.5) light.t=13.;\n    \n    return clamp(mix(vec3(0), mix(vec3(0.11, 0.11, 0.21), vec3(1), lightLevelCurve(load(_time).r)), pow(.8, light.s)) + mix(vec3(0), vec3(1.3, 1.15, 1), pow(.75, light.t)), 0., 1.);   \n\n}\n\nfloat vertexAo(float side1, float side2, float corner) {\n\treturn 1. - (side1 + side2 + max(corner, side1 * side2)) / 5.0;\n}\n\nfloat opaque(float id) {\n\t//return id > .5 ? 1. : 0.;\n    return  id != 0. && id!= 12. && id!= 26. ? 1. :0.;\n}\n\nvec3 calcOcclusion(vec3 r,vec3 n, vec2 uv,voxel vox) {\n#ifndef OCCLUSION\n    return vec3(vox.light , .75);\n#else    \n \t//tangents:\n    vec3 s = vec3(step(.1,abs(n.y)), 1.- step( .1, abs(n.y)) ,0.                  );\n    vec3 t = vec3(step(.1,abs(n.z)), 0.                   ,1.- step(.1,abs(n.z)  ));\n    \n   //neightbours vector\n   //v[0],v[1],v[2]\n   //v[3],v[4],v[5]\n   //v[6],v[7],v[8]\n   voxel v[9]; \n   \n   for (int i =-1; i <=1; i++) {\n        for (int j =-1; j <=1  ; j++) {            \n             getVoxel(r +n + s* float(i)+t*float(j),v[4+ i+3*j +min(iFrame,0) ] ,3 );                     \t\n        }\n    }\n      \n    float aom, ao[4];\n    vec2 lightm,light[4];\n    for(int i=0;i<=3;i++){\n        \n        ivec4 ids;\n        if(i==0) ids=ivec4(6,7,3,4);\n        if(i==1) ids=ivec4(7,8,4,5);\n        if(i==2) ids=ivec4(3,4,0,1);\n        if(i==3) ids=ivec4(4,5,1,2);\n    \tlight[i +min(iFrame,0)] =max24(v[ids.x].light, v[ids.y].light, v[ids.z].light, v[ids.w].light);\n    }\n    lightm = mix(mix(light[2], light[3], uv.x), mix(light[0], light[1], uv.x), uv.y);\n    \n    for(int i=0;i<=3 ;i++){\n\n        ivec3 ids;\n        if(i==0) ids=ivec3(7,3,6);\n        if(i==1) ids=ivec3(7,5,8);\n        if(i==2) ids=ivec3(1,3,0);          \n        if(i==3) ids=ivec3(1,5,2);;\n        ao[i] = vertexAo(opaque(v[ids.x].id), opaque(v[ids.y].id), opaque(v[ids.z].id));\n    }\n    aom = mix(mix(ao[2], ao[3], uv.x), mix(ao[0], ao[1], uv.x), uv.y);\n   if(opaque(v[4].id)>0.) {aom*=0.75;}  \n    \n     \n    return vec3(lightm , aom);\n#endif    \n\n}\n\n// RENDERING\n\nvec3 rayDirection(vec2 angle, vec2 uv, vec2 renderResolution){\n    vec3 cameraDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) * renderResolution.y / renderResolution.x;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n\n}\n\nstruct rayCastResults {\n\tbool hit;\n    vec3 rayPos;\n    vec3 mapPos;\n    vec3 normal;\n    vec2 uv;\n#ifdef SUBTEXTURE  \n    vec2 uv_txt;\n#endif    \n    float dist;\n    voxel vox;\n    float water;\n    float fog;\n    bool grass;\n    bool mirror;\n    vec3 color;\n    float fresnel;\n\n};\nmat3 rotate(float theta,int axis) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    if (axis==1) return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, s),\n        vec3(0, -s, c)\n    );\n    if (axis==2) return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n    return mat3(\n        vec3(c, s, 0),\n        vec3(-s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n//From https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 sun(){\n    float t = load(_time).r;\n    float sunAngle = (t * PI * 2. / 1200.) + PI / 4.;\n    const float risingAngle=PI/6.;\n    return  vec4(cos(sunAngle)*sin(risingAngle), cos(sunAngle)*cos(risingAngle), sin(sunAngle),lightLevelCurve(t));\n}\n\n#ifdef CLOUDS \nfloat fogDensity(vec3 p) {\n\n\tfloat density = 2. - abs(p.z - 80.)*1.7;\n    //density += mix(0., 40., pow(.5 + .5 * snoise(p.xy /557. + vec2(0.576, .492)), 2.)) * snoise(p / 31.51 + vec3(0.981, .245, .497));\n    density += mix(0., 30., pow(.2 + 1.5 * snoise((p.xy +iTime)/207. + vec2(0.576 +iTime/200., .492)), 2.)) * snoise((p +iTime) / 30.99 + vec3(0.981, .245, .497 +iTime/2000.));\n\n     return clamp(density ,0.,50.);\n\n}\nvoid applyFog( inout vec3  rgb,       // original color of the pixel\n               in float distance ) // camera to point distance\n{\n    \n    float fogAmount = 1.0 - exp( -distance*0.015 );\n    vec3  fogColor  = vec3(0.5,0.6,0.7)*clamp(sun().w,.1,1.);\n    rgb= mix( rgb, fogColor, fogAmount );\n}\n#endif\n\n//-------------\n\nfloat noise(in vec2 p) {\n\tvec2 F = floor(p), f = fract(p);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(\n\t\tmix(hash2(F), \t\t\t hash2(F+vec2(1.,0.)), f.x),\n\t\tmix(hash2(F+vec2(0.,1.)), hash2(F+vec2(1.)),\t  f.x), f.y);\n}\n\n//GRASS ADAPTED FROM POLYANKA by W23\n//https://www.shadertoy.com/view/MdsGzS\n#ifdef GRASS_DETAIL\nconst int c_grassmarch_steps = 48;\nconst float c_gscale = 37.;\nconst float c_gheight = 0.4;\n//const float c_rgslope = 2. / (c_gscale * c_gheight);\n\n\nvec2 noise2(in vec2 p) {\n\tvec2 F = floor(p), f = fract(p);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(\n\t\tmix(hash22(F), \t\t\t  hash22(F+vec2(1.,0.)), f.x),\n\t\tmix(hash22(F+vec2(0.,1.)), hash22(F+vec2(1.)),\tf.x), f.y);\n}\n\nfloat fnoise(in vec2 p) {\n\treturn .5 * noise(p) + .25 * noise(p*2.03) + .125 * noise(p*3.99);\n}\n\nvec2 wind_displacement(in vec2 p) {\n\treturn noise2(p*.1+iTime)/100. - 0.005;\n}\n\nfloat grass_height(in vec3 p,float gheight) {\n\tfloat base_h= 0.15;\n\tfloat depth = 1. - (base_h - p.z) / gheight;\n\tvec2 gpos = (p.xy  + depth * wind_displacement(p.xy));\n\treturn base_h - noise(gpos * c_gscale) * gheight;\n}\n\n\nstruct xs_t {\n    bool hit;\n\tvec3 pos; \n\tfloat occlusion;\n    float dist;\n};\n\n\nxs_t trace_grass(vec3 o, vec3 d,vec3 mapPos,float gheight) {\n    bool hit=false;\n\tfloat L = .005;\n    //float Lmax= 1.8;\n\tfor (int i = 0; i < c_grassmarch_steps; ++i) {\n\t\tvec3 pos = o + d * L ;\n\t\tfloat h = grass_height(pos +mod(mapPos,10.),gheight);\n\t\tfloat dh = pos.z - h;\n        if (dh < .005) {hit=true; break;}\n\t\tL += dh * 2. / (c_gscale * gheight);\n        vec3  dist = abs(pos-.5);\n        //if (L > Lmax) break;\n\t\tif (max(dist.z, max(dist.x,dist.y))>.5) break;\n\t}\n\tvec3 pos = o + d * L;\n\tfloat occlusion = 1. - 2.*(0. - pos.z) / gheight;\n\treturn xs_t(hit, pos + mod(mapPos,99.),  (hit)?1.:min(1.,occlusion),L);\n}\n\nvec3 shade_grass(in xs_t xs) {\n    \n\tvec2 typepos = xs.pos.xy + wind_displacement(xs.pos.xy);\n\tfloat typemask1 = fnoise(2.5*typepos);\n\tfloat typemask2 = pow(fnoise(.4*typepos), 3.);\n\tfloat typemask3 = step(.71,fnoise(.8*typepos));\n\tvec3 col1 = vec3( 106./255., 170./255.,  64./255.);\n\tvec3 col2 = vec3(.7, .73, .3)*.3;\n\tvec3 col3 = vec3(1., 1., .1);\n\tvec3 col4 = vec3(1., .4, .7);\n\tvec3 color = mix(mix(mix(col1, col2, typemask1),\n\t\t\tcol3, typemask2), col4, typemask3) *.8;\n\tcolor *= xs.occlusion;\n\treturn color;\n}\t\n#endif\n//-----------------------------\n//water reflection: https://www.shadertoy.com/view/MdXGW2\n#define BUMPFACTOR 0.3\n#define EPSILON 0.1\n\nfloat waterHeightMap( vec2 pos ) {\n    return 0.9+.2*noise(pos +iTime/3.);\n    //better but requires more compilation time\n    //return 0.9+.1*snoise(vec3(pos,iTime/3.));\n}\n\nfloat fresnelR(vec3 d, vec3 n)\n{\n    //float a = clamp(1.0-dot(n,-d), 0.0, 1.0);   \n   // return clamp(exp((5.0*a)-5.0), 0.0, 1.0);\n    return pow( clamp( 1.0 + dot(d,n), 0.0, 1.0 ), 5.0 );\n}\n//------------------------*/\nvec4 VoxelHitPos(vec3 pos, vec3 ro, vec3 rd){\n    vec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n    vec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n    float t=  max ( mini.x, max ( mini.y, mini.z ) );\n    return vec4(t*rd+ro,t);\n}\n\n#ifdef SUBVOXEL\nrayCastResults raySubCast(vec3 rayPosOrig, vec3 rayDir, int shape,float rotation,vec3 seed){\n \n\trayCastResults  res;\n    \n    \n    vec3 c=vec3(.5);\n    float theta1= PI/2.*floor(mod(rotation,4.));\n    rayPosOrig = rotate( theta1,3) *(rayPosOrig-c) +c;\n    rayDir= rotate( theta1,3)*rayDir; \n    float theta2= PI/2.*(floor(rotation/4.));\n    rayPosOrig = rotate( theta2,2) *(rayPosOrig-c)+c;\n    rayDir= rotate( theta2,2)*rayDir; \n       \n     vec3 ro = (rayPosOrig) *N_SUBVOXEL;\n   \n\t//if(abs(ro.x -N/2.)>N/2. ||abs(ro.y -N/2.)>N/2. ||abs(ro.y -N/2.)>N/2.)return vec4(0.,0.,0.,1.);\n       \n\tvec3 ri = 1.0/rayDir;\n\tvec3 rs = sign(rayDir);\n    vec3 pos = floor(ro-rayDir*0.002);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tres.hit=false;\n\tvec3 mm = vec3(0.);\n    float t=0.;\n       \n\tfor( int i=0; i<int(N_SUBVOXEL)*3; i++ ) \n    {\t\n\t\tif(i>=0){\n       \t mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);           \n        }\n         dis += mm * rs * ri;\n         pos += mm * rs;\n        \n        //if( sdBox( ro+t*rayDir-vec3(N_SUBVOXEL/2.),vec3(N_SUBVOXEL/2.) )>.05) {res.hit=false; break;}\n        \n        //float timestep= floor(mod(iTime,N_SUBVOXEL));\n        //SHAPES\n       \n        //SINGLE BLOCK\n        //if( sdBox( pos-vec3(x,x,x) +rs*0.001 ,vec3(.5,.5,.5) )<.01) {res.hit=true; break;}\n     \n\n        if(shape==1){// POLE\n        \tif( sdBox( pos-vec3(2.,2.,2.) ,vec3(.5,.5,2.5) )<.001) {res.hit=true; break;}\n\t      \n        }else if(shape==2){//STEP 1\n            if(sdBox( pos-vec3(2.,2.,0.)  ,vec3(2.5,2.5,0.5) )<.001) {res.hit=true; break;}\n          \n        }else if(shape==3){//STEP 2\n             if( sdBox( pos-vec3(2.,2.,0.) ,vec3(2.5,2.5,1.5) )<.001) {res.hit=true; break;}\n           \n        }else if(shape==4){//FENCE 1\n         \tif( sdBox( pos-vec3(2.,2.,2.)  ,vec3(.5,.5,2.5) )<.001) {res.hit=true; break;}\n          \tif( sdBox( pos-vec3(2.,2.,4.)  ,vec3(.5,2.5,.5) )<.001) {res.hit=true; break;}\n          \n        }else if(shape==5){//FENCE 2\n        \tif( sdBox( pos-vec3(2.,2.,2.) ,vec3(.5,.5,2.5) )<.001) {res.hit=true; break;}\n          \tif( sdBox( pos-vec3(1.,2.,4.)  ,vec3(1.5,.5,.5) )<.001) {res.hit=true; break;}\n          \tif( sdBox( pos-vec3(2.,1.,4.)  ,vec3(.5,1.5,.5) )<.001) {res.hit=true;break;}\n\n        }else if(shape==6){//SLOPE 1\n            if( dot(pos,  vec3(0.,sqrt(2.),sqrt(2.))) -6. <0.001 \n            && sdBox( pos-vec3(2.,2.,2.),vec3(2.5,2.5,2.5) )<.001  ) {res.hit=true; break;}\n            \n        }else if(shape==7){//PANEL\n            if(sdBox( pos-vec3(0.,2.,2.)  ,vec3(.5,2.5,2.5) )<.001) {res.hit=true; break;}\n            \n        }\n#ifdef TREE_DETAIL        \n        else if(shape==8){//TREE W LEAFS\n            \n     \t\tif( sdCross( pos-vec3(2.,2.,2.)  ,vec3(.5,.5,1.5) )<.001) {res.hit=true; res.vox.id=10.; break;}\n            vec3 applePos= vec3(1.,1.,1.);//floor(hash33(seed)*5.);\n            if( sdBox( pos-applePos  ,vec3(.5,.5,.5) )<.01 // && hash13(seed)<.95 \n                 ){res.hit=true; res.vox.id=14.; break;}\n\n            if( sdBox( pos-vec3(2.,2.,2.)  ,vec3(2.5,2.5,2.5) )<.001 && hash13(floor(pos)+seed+.5 )  >.75){res.hit=true; res.vox.id=11.; break;}\n    \n            //\n        }else if(shape==9){//TRUNK\n\t\t\tvec3 p=pos-vec3(2.,2.,2.);\n            //p= vec3(abs(p.x)+abs(p.y),max(p.x,p.y),p.z);\n            if(sdBox( p ,vec3(1.5,1.5,2.5) )<.001){res.hit=true; res.vox.id=10.; break;}\n         \n        }\n#endif        \n\t}\n\t\n\t\n    if(res.hit){\n        res.normal = - mm*rs; \n        vec4 hitPos=VoxelHitPos(pos,ro,rayDir);\n        res.dist=hitPos.a/N_SUBVOXEL;\n        vec3 xyz = hitPos.xyz - pos;\n        res.uv = vec2( dot(mm.yzx, xyz), dot(mm.zxy, xyz) );\n        if(abs(mm.x)>0.) res.uv=res.uv.yx; //invert xz \n        //relative to absolute normals:\n   \t\tres.normal  = rotate( -theta2,2) * rotate(- theta1,3) *res.normal;\n    }\n    return res;  \n}\n#endif\n\n\nvec3    g_n;\nvec2    g_uv;\n\nrayCastResults rayCast(vec3 rayPos0, vec3 rayDir,int maxRayDist,vec4 range,int rayType) {\n\t   \n    voxel vox;\n    vox.id=0.;\n    float waterDist=0.;\n    float fog=0.; \n    rayCastResults res;\n    res.hit = false;\n    res.color=vec3(-1.);\n    res.fresnel=0.;\n    res.mirror=false;\n    rayCastResults subRes;\n    subRes.hit=false;\n\n    vec3 raySign= sign(rayDir);\n    vec3 rayInv = 1./rayDir;\n\tvec3 rayPos=rayPos0;\n    \n    vec3 mapPos=floor(rayPos);\n    if ( rayPos.z >= heightLimit_B && rayDir.z<0.){\n       \n        //MAP RAY FROM ABOVE\n        float nstep= (rayPos.z - heightLimit_B)*rayInv.z;\n        mapPos = floor(rayPos-rayDir *nstep+ raySign*0.001);\n    }\n    vec3 sideDist = (mapPos-rayPos + 0.5 + sign(rayDir)*0.5) *rayInv;\n    vec3 mask=vec3(0.); \n\n    \n    //vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    voxel currentVoxel;\n    getCVoxel( mapPos,currentVoxel,3);\n\tvec3 hitWater = (currentVoxel.id==12.? rayPos: vec3(0.));\n\tbool xRay=(currentVoxel.id!=0. && currentVoxel.id!=12.);\n        \n    for (int i = 0; i < 1000; i++) {\n\n        if(i>0){\n       \t\tmask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n\n        }\n\t\tsideDist += mask *  raySign *rayInv;\n        mapPos += mask *  raySign;\n        \n        if ( mapPos.z < 0. ) break;\n        if ( mapPos.z >= heightLimit_B && rayDir.z > 0.)  break;\n                   \n        getVoxel( mapPos, vox ,3 );\n        \n        //GRASS\n#ifdef  GRASS_DETAIL      \n        if(vox.id==0. && vox.life>0. && rayType==1 ){\n\t\t\tvec4 vd =VoxelHitPos(mapPos,rayPos,rayDir);\n            res.rayPos= vd.xyz;\n            res.dist=vd.a;\n    \t\tvec3 relativePos = res.rayPos -mapPos;\n            \n            float grass = c_gheight*vox.life;\n           \txs_t xs = trace_grass(relativePos,rayDir,mapPos,grass);\n            \n            if (xs.hit ) {\n                \n                //color = mix(color, c_skycolor, smoothstep(c_maxdist*.35, c_maxdist, xs.l));\n            \tres.hit = true;                \n                res.vox=vox;\n                res.grass=true;\n                res.color=shade_grass(xs);\n                res.mapPos = mapPos;\n                res.water =waterDist;\n    \t\t\tres.fog=fog;\n                res.normal = vec3(0,0,1);\n                res.dist+=  xs.dist ;\n    \t\t\tres.rayPos += rayDir * xs.dist ;\n                return res;\n            } \n\t\n        }\n#endif        \n       \n#ifdef SUBVOXEL        \n        if(vox.shape!=0 && vox.id!=0. ){ \n            //SUB VOXEL\n\n    \t\tvec3 hitVoxelPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n            \n            if( sdBox( mapPos+vec3(.5) -rayPos,vec3(.5,.5,.5) )<.001) hitVoxelPos=rayPos;\n            float rotation= vox.rotation;\n            \n             subRes = raySubCast( hitVoxelPos - mapPos ,  rayDir, vox.shape,rotation,mapPos);\n            if(subRes.hit && vox.id!=12.) { \t\t\n       \t\t \tres.hit = true; \n                if(subRes.vox.id!=0.) vox.id=subRes.vox.id;             \n                break;\n            }\n            else if(vox.id==12. && subRes.hit && rayType!=3) { \n            \t//nothing to do\n            }\n            else {vox.id=0.;res.hit = false;}\n        }\n         \n#endif \n#ifdef MC\n         if(vox.surface!=0. && rayType==1){ \n                gFrame=min(iFrame,0);\n                vec3 hitVoxelPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n                GRIDCELL g;\n                float csz=1.;\n                float mcid=0.;\n                bool surface=false;\n                for(int id=0;id<8;id++)\n                {\n                    g.p[id]=mapPos+  VertexOffset[id]*csz;\n                    voxel vt;\n                    getCVoxel(g.p[id],vt,3 );\n                    if(vt.id==3.) vt.id=4.;\n                    mcid =max(mcid,vt.id);\n                    g.val[id]= vt.id!=0.?1.:-1.;\n                    surface = surface || ( g.val[id]*g.val[0]<0.);\n                }    \n\n                if(surface ){\n\n                    TRIANGLE[5] triangles;\n\n                        //calculate vertexes & triangles (requires buffer A and B)\n\n                    uvec4 tridata = Polygonise(g,0.,triangles,iChannel0);\n\n                    int ntriangles=int(tridata.x);          \n                    float t = 1000.0; \n                    for(int i=min(iFrame,0);i<ntriangles;i++) {\n                        vec3 tri =triIntersect( hitVoxelPos,rayDir,triangles[i].p[0],triangles[i].p[1],triangles[i].p[2]);\n                        if(tri.x>0.  && tri.x <t) {\n                            t=tri.x;\n                             g_n=-normalize(cross(triangles[i].p[1]-triangles[i].p[0],triangles[i].p[2]-triangles[i].p[0]));\n                             g_uv= tri.yz;\n                         }\n                    }\n                    if(t< 1000. ) {\n                    \n                        subRes.hit = true; \n                        subRes.mapPos = mapPos;\n                        subRes.normal = g_n;\n                        subRes.uv=g_uv;\n                        subRes.rayPos = hitVoxelPos + rayDir*t;\n                        subRes.dist = length(rayPos0 - subRes.rayPos);\n                        vox.id=mcid;\n                        subRes.vox=vox;\n                        subRes.color = getTexture(mcid, g_uv).rgb *(.7 - .3*dot( sun().xyz,g_n));;             \n                        subRes.water =waterDist;                                     \n                        subRes.fog=fog;\n                        subRes.grass=true;\n                        return subRes;\n                        \n                        //res.hit = true;                        \n                        //break;\n                    }else vox.id=0.;\n                }\n                \n        }\n#endif       \n        if(vox.id==14. &&rayType!=3){ //&& length(rayPos-mapPos -vec3(0.,0.,1.))<=6.){\n            //MIRROR \n                \n            vec3 endRayPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n            rayDir*= (vec3(1.) - 2.* mask); \t\t\t\t\n            rayDir=normalize(rayDir);rayInv=1./rayDir;raySign= sign(rayDir);\n\n            sideDist = (mapPos-endRayPos + 0.5 + raySign*0.5) /rayDir;\n            vox.id=0.;\n            res.mirror=true;\n            rayPos=endRayPos;\n            continue;\n        }\n        if(vox.id==12.  ){ //vox.life < WATER && vox.life>0.){\n        \t//ENTERING WATER\n            if(hitWater.z<1.) {\n                \n                // deviate ray xy if intercept water NOT EXACT                \n    \t\t\tvec3 endRayPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n                vec3 n=mask;\n                if(subRes.hit) {\n                    \tendRayPos+=rayDir * subRes.dist;                    \t\n                        n=subRes.normal;\n                }\n     \t\t\thitWater=endRayPos;\n\n                if(abs(n.z)>0.) {\n                    vec2 coord = hitWater.xy;\n                    vec2 dx = vec2( EPSILON, 0. );\n                    vec2 dy = vec2( 0., EPSILON );\n                    float bumpfactor = BUMPFACTOR ;//* (1. - smoothstep( 0., BUMPDISTANCE, dist) );\n\n                    vec3 normal = vec3( 0., 0., 1. );\n                    normal.x = -bumpfactor * (waterHeightMap(coord + dx) - waterHeightMap(coord-dx) ) / (2. * EPSILON);\n                    normal.y = -bumpfactor * (waterHeightMap(coord + dy) - waterHeightMap(coord-dy) ) / (2. * EPSILON);\n                    normal = normalize( normal );\n                   \n                    vec3 rayDirOld=rayDir;\n                    \n                    res.fresnel=fresnelR(rayDir, normal);\n    \t\t\t\t\n                    \n                    rayDir = refract( rayDir, normal ,1.3);\n                    if(res.fresnel>.005){\n                        rayDir = reflect( rayDirOld, normal );\n                        hitWater=vec3(0.,0.,-1.);\n                    }\n                }else if(abs(n.x)>0.) rayDir.yz*=(0.7+.4*noise(endRayPos.yz+iTime));\n                else  rayDir.xz*=(0.7+.4*noise(endRayPos.xz+iTime));\n                rayDir=normalize(rayDir);rayInv=1./rayDir;raySign=sign(rayDir);\n\n                rayPos=endRayPos;\n                sideDist = (mapPos-endRayPos + 0.5 + raySign*0.5) /rayDir;\n                               \n            }\n            subRes.hit=false;\n            //vox.id=0.;\n            continue;\n        }\n        if( vox.id !=0. && vox.id!=26. && vox.id!=12. ){\n        \tif(xRay) continue;\n            else{\n            \tres.hit = true; \n                break;\n            }\n        } \n\n#ifdef CLOUDS         \n        //FOG & CLOUDS\n        if(CLOUDS>0.) {\n        \tfloat fogd= fogDensity(mapPos)/4.*CLOUDS;\n        \tif(fogd >4. && rayType!=2) break;        \n        \tfog += fogd;\n        }\n#endif        \n        //NO HIT\n        xRay=false; \n        if(hitWater.z>0. && vox.id==0.)  {waterDist +=length(hitWater-mapPos); hitWater=vec3(-1.);res.fresnel=.001;}\n        \n        if(!inRange(mapPos.xy, range) && i> maxRayDist) break;\n\n        if(i > int( load(_rayLimit).r)) break;\n\t}\n    if(hitWater.z>0.)  waterDist +=length(hitWater-mapPos);\n    if(hitWater.z<0.)  waterDist =0.;   //reflection\n    \n    \n    if(load(_stats).r>0.5){\n    \tvec4 range_B= calcLoadRange_B(rayPos.xy,iResolution.xy,1.);\n        if(res.hit && inRange(mapPos.xy, range)  && !inRange(mapPos.xy, range_B)) vox.id = 8.;    \n\n\n#if SURFACE_CACHE>0        \n        vec4 range_C1= calcLoadRange_C(rayPos.xy,iResolution.xy,1.);\n\t\tvec4 range_C0 = load(_old+_loadRange_C);\n        if(res.hit && inRange(mapPos.xy, range_C0)  && !inRange(mapPos.xy, range_C1)) vox.id = 17.;    \n#endif\n    }\n        \n    if(!res.hit  &&rayDir.z < 0. && !inRange(mapPos.xy, range)){\n        if(mapPos.z>55.) {vox.id = 0.; res.hit=false;}\n        else { vox.id=3.; res.hit = true;}\n    }\n    \n    res.mapPos = mapPos;\n    res.normal = res.hit? -raySign * mask:vec3(0.);\n    res.rayPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n    res.dist = length(rayPos0 - res.rayPos);\n    res.vox=vox;\n    res.water =waterDist;\n    res.fog=fog;\n    \n    if(subRes.hit){\n        \n       \tres.normal=  subRes.normal; \n      \tmask=abs(subRes.normal);\n        res.rayPos += rayDir * subRes.dist ;\n        res.dist = length(rayPos - res.rayPos);\n        \n#ifdef SUBTEXTURE\n        // uv coordinates are relative to subvoxel (more detailed but aliased)\n    \tres.uv_txt = subRes.uv ;\n    \t//return res;\n#endif\n    }\n    \n    //uv coordinates are relative to block (also with subvoxels)                       \n    if (abs(mask.x) > 0.) {\n        res.uv = fract(res.rayPos.yz);\n    }\n    else if (abs(mask.y) > 0.) {\n        res.uv = fract(res.rayPos.xz);\n    }\n    else {\n        res.uv = fract(res.rayPos.yx);\n    }  \n    if(res.hit && !res.grass){\n        float textureId = res.vox.id;\n        if (textureId == 3.) textureId += res.normal.z;\n        vec2 uv_txt= res.uv;\n#ifdef SUBTEXTURE                \n        if(res.vox.shape!=0) uv_txt= res.uv_txt;\n#endif               \n        res.color = getTexture(textureId, uv_txt).rgb;\n    \n    }   \n    return res;\n}\n\n\nvec3 skyColor(vec3 rayDir) {\n    \n    vec4 s= sun();\n    float lightLevel = s.w;\n\n    vec3 sunDir=s.xyz;\n    vec3 daySkyColor = vec3(.5,.75,1);\n    vec3 dayHorizonColor = vec3(0.8,0.8,0.9);\n    vec3 nightSkyColor = vec3(0.1,0.1,0.2) / 2.;\n    \n    vec3 skyColor = mix(nightSkyColor, daySkyColor, lightLevel);\n    vec3 horizonColor = mix(nightSkyColor, dayHorizonColor, lightLevel);\n    float sunVis = smoothstep(.99, 0.995, dot(sunDir, rayDir));\n    float moonVis = smoothstep(.999, 0.9995, dot(-sunDir, rayDir));\n    return mix(mix(mix(horizonColor, skyColor, clamp(dot(rayDir, vec3(0,0,1)), 0., 1.)), vec3(1,1,0.95), sunVis), vec3(0.8), moonVis);\n    \n}\n\n\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\nvoid render( out vec4 fragColor, vec3 rayPos, vec3 rayDir ,int  maxRayDist, int rayType) {\n\n    vec4 range_B = load(_old+_loadRange_B);\n    vec3 sunDir = sun().xyz; sunDir *= sign(sunDir.z);\n      \n    rayCastResults rays[2] ;//0=view,1 =shadow\n    vec3 ro=rayPos;\n    vec3 rd=rayDir;\n    int rt=rayType;\n    for(int i=0; i<=1;i++){\n    \trays[i]=rayCast(ro, rd,maxRayDist,range_B,rt);\n\t\tif(!rays[i].hit) break;\n \t\tif(SHADOW<0.) break;\n        ro=rays[i].rayPos +rays[i].normal*0.01;\n        rd=sunDir;\n        maxRayDist=  25;//inRange(rays[i].rayPos.xy, range_B) ? 25:5;\n        rt=3;\n            \n    }\n    \n   rayCastResults res = rays[0];\n\t\n\tvec3 color = vec3(0.);\n    \n    if (res.hit) {\n        \n\t\t\t\n        float shadow =rays[1].hit?SHADOW:0.;\n\n        color=res.color;\n\n\n        if(rayType==1 ){\n            bool hB=(res.vox.ground>=MAX_GROUND && res.vox.id!=0. &&res.vox.buffer==BUFFER_B)  \n                   || (res.vox.id==17. && res.vox.life >0.) ;        \n                             \n            if(hB && HIGHLIGHT>0. ){              \n                color  *=(fract(iTime*4.)+.5);\n            }\n            \n            if(res.grass) {              \n            \tcolor *= lightmap( vec2(res.vox.light.s*(1.-shadow*.2),res.vox.light.t)   );                 \n            }else{\n              vec3 occ=calcOcclusion(res.mapPos, res.normal, res.uv,res.vox);\n                color *= lightmap(vec2(occ.x*(1.-shadow*.2),occ.y)) *occ.z; \n            }\n\t\t\t\n            // SELECTION AND MOUSE OVER\n            vec4 pick = load(_pick);\n            if (res.mapPos == pick.xyz || res.vox.value==2) {\n                if (pick.a == 1.) color *= getTexture(32., res.uv).r;\n                else if (res.vox.value==2) color = mix(color, vec3(1.,0.,0.), 0.5);\n                \n                else color = mix(color, vec3(1), 0.2);\n            }\n        }else\n        {\t\n            //MAP\n \t\t\t color *=  clamp( (res.mapPos.z-30.) /30.,0.,1.);\n            color = mix(color, vec3(1), 0.2);\n          \n        }\n        \n    }\n     else color = skyColor(rayDir);\n    \n    vec3 wcolor= vec3(.03,.1,.60)* lightmap( vec2(res.vox.light.s,res.vox.light.t)   );\n    //if(res.water>0.) color *= pow( wcolor ,vec3(sqrt(res.water)/(7. + res.fresnel*1000.)));\n    if(res.water>0.) {\n        color *= pow( wcolor ,vec3(sqrt(res.water)/7.));\n        color = mix(color,wcolor, clamp(res.fresnel*500.,0.3,1.));\n    }\n    else if(res.fresnel>0. ) color =mix(wcolor ,color,clamp(res.fresnel*4.,0.,.9));\n    if(res.mirror) color *= vec3(.9,.5,.5);\n    if(rayType==1) {\n#ifdef CLOUDS        \n        applyFog(color.rgb,res.fog);\n#endif\n        color = pow( color, vec3(0.9) );\n             \n    }\n    fragColor.rgb = color; //pow(color, vec3(1.));\n    \n    if(rayType==3 ) {\n        \n        float encodeNormal=14.+ res.normal.x + res.normal.y*3. + res.normal.z*9.;\n        fragColor=vec4(res.mapPos,(res.hit && res.dist >1. && res.dist <MAX_PICK_DISTANCE ? encodeNormal:0.));\n    }  \n     \n    //DEBUG:\n    //fragColor=vec4( vec2(1.- res.dist /50.),  res.hit?1.:0.,1.);\n    //fragColor=vec4( (1.-.5* sign(res.normal))* abs(res.normal) ,1.);\n    //fragColor=vec4( res.uv,max(abs(res.uv -.5).x,abs(res.uv-.5).y)<.5?1:0 ,1.);\n    //if(res.vox.id==12.) fragColor=vec4(vec2(res.vox.life<2. ? .5:0.),1.- res.vox.life/255.,1.);\n}\n\n\n#define NB 8\nfloat[] \n    camx = float[]   (2954. , 2952. , 2972. , 2972.,2971. ,2955. ,2955. ,2954.),\n\tcamy = float[]   (10139., 10140., 10151.,10151.,10152.,10151.,10153.,10139.),\n\tcamz = float[]   (71.   , 83.   , 48.   ,34.   ,50.   ,50.   ,71.   ,71.),\n    lookx = float[]  (2970. ,2972.  , 2972. ,2952. ,2955. ,2955. ,2954. ,2970.),\n\tlooky = float[]  (10152.,10153. , 10154.,10133.,10151.,10150.,10139.,10152.),\n\tlookz = float[]  (55.   , 50.   , 34.   ,27.   ,50.   ,71.   ,71.   ,55.); \n \n\nmat3 LookAt(in vec3 ro, in vec3 up){\n    vec3 fw=normalize(ro),\n    \t rt=normalize(cross(fw,up));\n    return mat3(rt, cross(rt,fw),fw);\n}\n\nvec3 RD(in vec3 ro, in vec3 cp, vec2 uv, vec2 res) {\n    return LookAt(cp-ro, vec3(0,0,1))*normalize(vec3((2.*uv-res.xy)/res.y, 3.5));\n}\n\nvoid getCam(in vec2 uv, in vec2 res, in float time, out vec3 ro, out vec3 rd) {\n       \n\tvec2 q = uv/res;\n    \n    float t = .16* time,\n\t\t kt = smoothstep(0.,1.,fract(t));\n\n    // - Interpolate positions  and direction\n    int  i0 = int(t)%NB, i1 = i0+1;\n    \n    vec3 cp = mix(vec3(lookx[i0],looky[i0],lookz[i0]), vec3(lookx[i1],looky[i1],lookz[i1]), kt); \n  \n    ro = mix(vec3(camx[i0],camy[i0],camz[i0]), vec3(camx[i1],camy[i1],camz[i1]), kt),\n    ro += vec3(.01*cos(2.*time), .01*cos(time),0.);\n    rd = RD(ro, cp, uv, res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    float pixelSize = load(_pixelSize).r;\n    vec2 renderResolution = ceil(iResolution.xy / pixelSize); \n    if (any(greaterThan(fragCoord, renderResolution))) {\n        fragColor = vec4(0);\n        return;\n    }\n        \n    vec3 cameraPos;    \n    vec3 cameraDir;\n    int  rayType = 1;\n \n#ifdef MAP    \n    float MAP_SIZE= iResolution.y/8./pixelSize; \n    vec2 MapCenter=vec2(iResolution.x/pixelSize -MAP_SIZE , iResolution.y/pixelSize - MAP_SIZE);\n    if(abs(load(_map).r-1.) <.1 && distance(fragCoord,MapCenter)<MAP_SIZE) rayType=2;\n    if(abs(load(_map).r-2.) <.1) {\n        rayType=2;\n        MapCenter=vec2(iResolution.x/pixelSize/2. , iResolution.y/pixelSize/2.);\n    }\n    \n#endif    \n    \n    if(max(fragCoord.x,fragCoord.y)<1. ) rayType=3;\n    if(rayType==3){\n        //MOUSE RAY\n        float zoom = pow(10., load(_renderScale).r/10.);///pixelSize;\n        vec2 renderResolution = iResolution.xy *zoom; \n        vec2 renderCenter=vec2(0.5);\n        vec2 uv = (iMouse.xy- renderCenter) / renderResolution - (renderCenter/zoom);//  /pixelSize;\n         cameraPos = load(_pos).xyz + vec3(0,0,1.6);    \n         cameraDir = rayDirection(load(_angle).xy,uv,renderResolution);\n  \n    } \n#ifdef MAP \n    else if(rayType==2){\n     \n        // MAP CAMERA\n        float cameraHeight =1500.;\n        float zoom = cameraHeight/iResolution.x/pixelSize*(load(_map).r>1.5?1.6:.4);\n        vec2 renderResolution = iResolution.xy *zoom; \n        vec2 renderCenter=MapCenter/iResolution.xy*pixelSize;\n        vec2 uv = (fragCoord.xy- renderCenter) / renderResolution - (renderCenter/zoom/pixelSize);    \n        vec2 angle = vec2(0.,PI);\n        if(load(_map).r>1.5){\n        \tangle=iMouse.xy/iResolution.xy*vec2(PI,-PI/3.)+vec2(0,PI);\n        }\n        cameraDir = rayDirection(angle,uv,renderResolution); \n        vec3 cameraCenterDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n        cameraPos = load(_pos).xyz -cameraCenterDir* cameraHeight;\n    }       \n#endif            \n    else if(rayType==1) \n    {    \n        // MAIN CAMERA\n        float zoom = pow(10., load(_renderScale).r/10.)/pixelSize;\n        vec2 renderResolution = iResolution.xy *zoom; \n        vec2 renderCenter=vec2(0.5);\n        vec2 uv = (fragCoord.xy- renderCenter) / renderResolution - (renderCenter/zoom/pixelSize);\n         cameraPos = load(_pos).xyz + vec3(0,0,1.6);    \n         cameraDir = rayDirection(load(_angle).xy,uv,renderResolution);\n     \n      //DEMO VIEW     \n         if(load(_demo).r >.5)\n             getCam((fragCoord.xy- renderCenter) , renderResolution, iTime, cameraPos, cameraDir);\n                  \n    }   \n\n    render(fragColor,cameraPos, cameraDir, int(load(_rayDistMax).r),rayType);\n       \n    //MAP BORDER:\n#ifdef MAP\n    if(rayType==2){\n        if(load(_map).r <1.5){\n        \tif(abs(distance(fragCoord,MapCenter)-MAP_SIZE)<1.) fragColor.rgb=vec3(0.);    \n        \tif(distance(fragCoord,MapCenter + vec2(sin( load(_angle).x), -cos( load(_angle).x))*MAP_SIZE )<3.) fragColor.rgb= vec3(1.,0.,0.);\n        }\n    }\n#endif        \n    //fragColor = texture(iChannel2, fragCoord / 3. / iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}