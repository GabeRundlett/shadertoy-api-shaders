{
    "Shader": {
        "info": {
            "date": "1526268370",
            "description": "Siemens star and aliasing. Comparing no AA, axis aligned (not rotated) grid, grid rotated by 45 degrees and a grid rotated like in DX MSAA. Naive box filter.",
            "flags": 0,
            "hasliked": 0,
            "id": "lscfRS",
            "likes": 7,
            "name": "Siemens star antialiasing",
            "published": 3,
            "tags": [
                "aliasing",
                "resolution"
            ],
            "usePreview": 0,
            "username": "bartwronski",
            "viewed": 1462
        },
        "renderpass": [
            {
                "code": "// Text rendering code copied/pasted from https://www.shadertoy.com/view/4dtGD2 by Hamneggs\n#define _f float\nconst lowp _f CH_A    = _f(0x69f99), CH_B    = _f(0x79797), CH_C    = _f(0xe111e),\n       \t  \t  CH_D    = _f(0x79997), CH_E    = _f(0xf171f), CH_F    = _f(0xf1711),\n\t\t  \t  CH_G    = _f(0xe1d96), CH_H    = _f(0x99f99), CH_I    = _f(0xf444f),\n\t\t  \t  CH_J    = _f(0x88996), CH_K    = _f(0x95159), CH_L    = _f(0x1111f),\n\t\t  \t  CH_M    = _f(0x9f999), CH_N    = _f(0x9bd99), CH_O    = _f(0x69996),\n\t\t  \t  CH_P    = _f(0x79971), CH_Q    = _f(0x69b5a), CH_R    = _f(0x79759),\n\t\t  \t  CH_S    = _f(0xe1687), CH_T    = _f(0xf4444), CH_U    = _f(0x99996),\n\t\t  \t  CH_V    = _f(0x999a4), CH_W    = _f(0x999f9), CH_X    = _f(0x99699),\n    \t  \t  CH_Y    = _f(0x99e8e), CH_Z    = _f(0xf843f), CH_0    = _f(0x6bd96),\n\t\t  \t  CH_1    = _f(0x46444), CH_2    = _f(0x6942f), CH_3    = _f(0x69496),\n\t\t  \t  CH_4    = _f(0x99f88), CH_5    = _f(0xf1687), CH_6    = _f(0x61796),\n\t\t  \t  CH_7    = _f(0xf8421), CH_8    = _f(0x69696), CH_9    = _f(0x69e84),\n\t\t  \t  CH_APST = _f(0x66400), CH_PI   = _f(0x0faa9), CH_UNDS = _f(0x0000f),\n\t\t  \t  CH_HYPH = _f(0x00600), CH_TILD = _f(0x0a500), CH_PLUS = _f(0x02720),\n\t\t  \t  CH_EQUL = _f(0x0f0f0), CH_SLSH = _f(0x08421), CH_EXCL = _f(0x33303),\n\t\t  \t  CH_QUES = _f(0x69404), CH_COMM = _f(0x00032), CH_FSTP = _f(0x00002),\n    \t  \t  CH_QUOT = _f(0x55000), CH_BLNK = _f(0x00000), CH_COLN = _f(0x00202),\n\t\t\t  CH_LPAR = _f(0x42224), CH_RPAR = _f(0x24442);\nconst lowp vec2 MAP_SIZE = vec2(4,5);\n#undef flt\n/*\n\treturns the status of a bit in a bitmap. This is done value-wise, so\n\tthe exact representation of the float doesn't really matter.\n*/\nfloat getBit( in float map, in float index )\n{\n    // Ooh -index takes out that divide :)\n    return mod( floor( map*exp2(-index) ), 2.0 );\n}\nfloat drawChar( in float char, in vec2 pos, in vec2 size, in vec2 uv )\n{\n    // Subtract our position from the current uv so that we can\n    // know if we're inside the bounding box or not.\n    uv-=pos;\n    \n    // Divide the screen space by the size, so our bounding box is 1x1.\n    uv /= size;    \n    \n    // Create a place to store the result.\n    float res;\n    \n    // Branchless bounding box check.\n    res = step(0.0,min(uv.x,uv.y)) - step(1.0,max(uv.x,uv.y));\n    \n    // Go ahead and multiply the UV by the bitmap size so we can work in\n    // bitmap space coordinates.\n    uv *= MAP_SIZE;\n    \n    // Get the appropriate bit and return it.\n    res*=getBit( char, 4.0*floor(uv.y) + floor(uv.x) );\n    return clamp(res,0.0,1.0);\n}\n\nvec2 movement = vec2(0.0);\n\nfloat SiemensStar(in vec2 fragCoord, in vec2 offset) {\n    fragCoord = round(fragCoord / 2.0) * 2.0;\n    fragCoord += offset * 2.0;\n    fragCoord += movement;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    if (dot(uv, uv) > 0.22)\n        return 1.0;\n    \n    float angle = atan(uv.x, uv.y);\n\treturn 0.5 + 0.5*cos(50.0 * angle);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    movement = 6.0 * vec2(sin(iTime), cos(iTime));\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float boxFiltered1 = SiemensStar(fragCoord, vec2(-sqrt(2.0)/4.0, 0.0)) + \n        SiemensStar(fragCoord, vec2(sqrt(2.0)/4.0, 0.0))\n        + SiemensStar(fragCoord, vec2(0.0, sqrt(2.0)/4.0)) \n        + SiemensStar(fragCoord, vec2(0.0, -sqrt(2.0)/4.0));\n    float boxFiltered2 = SiemensStar(fragCoord, vec2(-0.5 / 2.0, -0.5 / 2.0)) + \n        SiemensStar(fragCoord, vec2(0.5 / 2.0, -0.5 / 2.0))\n        + SiemensStar(fragCoord, vec2(-0.5 / 2.0, 0.5 / 2.0)) \n        + SiemensStar(fragCoord, vec2(0.5 / 2.0, 0.5 / 2.0));\n    float boxFiltered3 = SiemensStar(fragCoord, vec2(-2.0 / 8.0, -6.0 / 8.0)) + \n        SiemensStar(fragCoord, vec2(6.0 / 8.0, -2.0 / 8.0))\n        + SiemensStar(fragCoord, vec2(-6.0 / 8.0, 2.0 / 8.0)) \n        + SiemensStar(fragCoord, vec2(2.0 / 8.0, 6.0 / 8.0));\n    float unfiltered = SiemensStar(fragCoord, vec2(0.0));\n    \n    vec3 col = vec3(uv.y < 0.0 ? (uv.x > 0.0 ? boxFiltered2 / 4.0 : boxFiltered1 / 4.0) : \n                    (uv.x < 0.0 ? unfiltered : boxFiltered3 / 4.0));\n    if (abs(uv.y) < 0.003 || abs(uv.x) < 0.003)\n        col = vec3(0.5, 1.0, 1.0);\n    \n    // Set a general character size...\n    vec2 charSize = vec2(.015, .018);\n    // and a starting position.\n    vec2 charPos = vec2(-0.8, -0.3);\n    // Draw some text\n    float chr = 0.0;\n    // Bitmap text rendering\n    chr += drawChar( CH_R, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_O, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_A, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += .04; charPos.x += .04;\n    chr += drawChar( CH_4, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_5, charPos, charSize, uv); charPos.x += .04;\n    charPos = vec2(-0.8, 0.30);\n    chr += drawChar( CH_N, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_O, charPos, charSize, uv); charPos.x += .04;charPos.x += .04;\n    chr += drawChar( CH_A, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_A, charPos, charSize, uv); charPos.x += .04;\n    charPos = vec2(0.4, 0.30);\n    chr += drawChar( CH_R, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_O, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_A, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += .04; charPos.x += .04;\n    chr += drawChar( CH_D, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_X, charPos, charSize, uv); charPos.x += .04;\n    charPos = vec2(0.4, -0.30);\n    chr += drawChar( CH_N, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_O, charPos, charSize, uv); charPos.x += .04; charPos.x += .04;\n    chr += drawChar( CH_R, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_O, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_A, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_I, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_O, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_N, charPos, charSize, uv); charPos.x += .04;\n    \n    fragColor = vec4(mix(col, vec3(0.0), chr),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}