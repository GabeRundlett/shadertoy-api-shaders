{
    "Shader": {
        "info": {
            "date": "1570141678",
            "description": "2D vector field in glsl, you can change the vector field as you like.\n\nPlease post it in the comment if you have something cool as a result.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdyGWD",
            "likes": 2,
            "name": "vector field coloring",
            "published": 3,
            "tags": [
                "color",
                "polar",
                "vectorfield"
            ],
            "usePreview": 0,
            "username": "Cewein",
            "viewed": 354
        },
        "renderpass": [
            {
                "code": "/*\n\n\tShader writtend by Maximilien 'cewein' nowak\n\t\n\tYou can modify the Vector field function under\n\tthis commentto change the look of the vector field\n\n\tfor the coloring, I use polar coordinate and the \n\ttransation form hsv color to rgb color. \n\n\t\n*/\n\nconst float PI = 3.14159265359;\n\n/*************************************************/\n/*                                               */\n/*            Vector field function              */\n/*                                               */\n/*************************************************/\n\nvec2 f(vec2 uv)\n{ \n    vec2 v = vec2(0.,5.);\n    \n    v.x =cos(uv.y) / tan(uv.y);\n    v.y =sin(uv.y * uv.x + iTime+length(uv)*5.);\n\n    return v;\n}\n\n\n/*************************************************/\n/*                                               */\n/*             Maths and coloring                */\n/*                                               */\n/*************************************************/\n\n//cartesian to poloar coordinate\nfloat xy2polar(vec2 xy)\n{\n    return atan(xy.x, xy.y);\n}\n\n//self explnatory function\nfloat rad2deg(float rad)\n{\n    return ((rad + PI)/(2.*PI)) * 360.;\n}\n\n//for the math being it : https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB\nvec3 hsv2rgb(float hue)\n{\n    float hue1 = hue/60.;\n    float x = 1. * (1.-abs((mod(hue1,2.))-1.));\n    vec3 col = vec3(0.);\n\n    if (hue1 >= 0. && hue1 <= 1.) {\n        col.x = 1.;\n        col.y = x;\n    } else if (hue1 >= 1. && hue1 <= 2.) {\n        col.x = x;\n        col.y = 1.;\n    } else if (hue1 >= 2. && hue1 <= 3.) {\n        col.y = 1.;\n        col.z = x;\n    } else if (hue1 >= 3. && hue1 <= 4.) {\n        col.y = x;\n        col.z = 1.;\n    } else if (hue1 >= 4. && hue1 <= 5.) {\n        col.x = x;\n        col.z = 1.;\n    } else if (hue1 >= 5. && hue1 <= 6.) {\n        col.x = 1.;\n        col.z = x;\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    //image zoom\n    uv *= 10.;\n    \n    //applying vector function\n    vec2 v = f(uv);\n    \n    //coloring\n    float phi = xy2polar(v);\n    float deg = rad2deg(phi);\n    vec3 polarColor = hsv2rgb(deg);\n    vec3 col = vec3(polarColor);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}