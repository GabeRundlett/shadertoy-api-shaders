{
    "Shader": {
        "info": {
            "date": "1723509520",
            "description": "Simple TV scene.\nAs texture used my old previous shaders.",
            "flags": 48,
            "hasliked": 0,
            "id": "4fffR7",
            "likes": 62,
            "name": "TV Scene, wall of TV",
            "published": 3,
            "tags": [
                "raytracing",
                "voxels",
                "retro",
                "screen",
                "tv",
                "intersection",
                "crt"
            ],
            "usePreview": 1,
            "username": "morimea",
            "viewed": 987
        },
        "renderpass": [
            {
                "code": "\n// Created by Danil (2024+) https://github.com/danilw\n// https://mastodon.gamedev.place/@danil\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// self https://www.shadertoy.com/view/4fffR7\n\n\n// using:\n// https://iquilezles.org/articles/intersectors/\n// https://www.shadertoy.com/view/NlycW1 - RayTracing Domain Repetition\n// https://www.shadertoy.com/view/cd3XWr - Agx\n\n\n// for TAA asd everything else look\n// https://danilw.github.io/blog/my_shader_templates_list/\n\n\n// Control:\n// keyboard arrows to change move direction\n// mouse on borders - same\n// mouse on middle - zoom\n// (hidden feature - after zoom click with mouse on border direction - zoom stay)\n// space - stop movement\n\n\nvec3 color2agx(vec3 col);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    float sharpness = 0.001+0.099*smoothstep(0.5,1.5,iTime);\n    for (int dy = -1; dy <= 1; ++dy)\n    {\n        for (int dx = -1; dx <= 1; ++dx)\n        {\n            float weight = (dx == 0 && dy == 0)? (1.0 + 8.0*sharpness): -sharpness;\n            col += weight * texelFetch(iChannel3, ivec2(fragCoord)+ivec2(dx,dy), 0).rgb;        }\n    }\n    \n    col = max(col, vec3(0.));\n    col=col*col*.5+col;\n    col = color2agx(col);\n    \n    uv = fragCoord.xy/iResolution.xy - 0.5;\n    float vignetteAmt = 1. - dot(uv * .85, uv * .85);\n    col *= vec3(vignetteAmt);\n\n    col = clamp(col, 0., 1.);\n    \n    fragColor = vec4(col,1.0);\n    \n}\n\n\n\n\n\n\n\n// Agx from https://www.shadertoy.com/view/cd3XWr\n#define AGX_LOOK 2\n\n// AgX\n// ->\n\n// Mean error^2: 3.6705141e-06\nvec3 agxDefaultContrastApprox(vec3 x) {\n  vec3 x2 = x * x;\n  vec3 x4 = x2 * x2;\n  \n  return + 15.5     * x4 * x2\n         - 40.14    * x4 * x\n         + 31.96    * x4\n         - 6.868    * x2 * x\n         + 0.4298   * x2\n         + 0.1191   * x\n         - 0.00232;\n}\n\nvec3 agx(vec3 val) {\n  const mat3 agx_mat = mat3(\n    0.842479062253094, 0.0423282422610123, 0.0423756549057051,\n    0.0784335999999992,  0.878468636469772,  0.0784336,\n    0.0792237451477643, 0.0791661274605434, 0.879142973793104);\n    \n  const float min_ev = -12.47393f;\n  const float max_ev = 4.026069f;\n\n  // Input transform\n  val = agx_mat * val;\n  \n  // Log2 space encoding\n  val = clamp(log2(val), min_ev, max_ev);\n  val = (val - min_ev) / (max_ev - min_ev);\n  \n  // Apply sigmoid function approximation\n  val = agxDefaultContrastApprox(val);\n\n  return val;\n}\n\nvec3 agxEotf(vec3 val) {\n  const mat3 agx_mat_inv = mat3(\n    1.19687900512017, -0.0528968517574562, -0.0529716355144438,\n    -0.0980208811401368, 1.15190312990417, -0.0980434501171241,\n    -0.0990297440797205, -0.0989611768448433, 1.15107367264116);\n    \n  // Undo input transform\n  val = agx_mat_inv * val;\n  \n  // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display\n  //val = pow(val, vec3(2.2));\n\n  return val;\n}\n\nvec3 agxLook(vec3 val) {\n  const vec3 lw = vec3(0.2126, 0.7152, 0.0722);\n  float luma = dot(val, lw);\n  \n  // Default\n  vec3 offset = vec3(0.0);\n  vec3 slope = vec3(1.0);\n  vec3 power = vec3(1.0);\n  float sat = 1.0;\n \n#if AGX_LOOK == 1\n  // Golden\n  slope = vec3(1.0, 0.9, 0.5);\n  power = vec3(0.8);\n  sat = 0.8;\n#elif AGX_LOOK == 2\n  // Punchy\n  slope = vec3(1.0);\n  power = vec3(1.35, 1.35, 1.35);\n  sat = 1.4;\n#endif\n  \n  // ASC CDL\n  val = pow(val * slope + offset, power);\n  return luma + sat * (val - luma);\n}\n\n// <-\n\nvec4 toLinear(vec4 sRGB) {\n  bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n  vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n  vec4 lower = sRGB/vec4(12.92);\n  \n  return mix(higher, lower, cutoff);\n}\n\nvec3 color2agx(vec3 col)\n{\n  //col = toLinear(vec4(col, 1.0)).rgb;\n\n  col = agx(col);\n  col = agxLook(col);\n  col = agxEotf(col);\n\n  return col;\n}\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define MAX_DIST 1000.\n#define MIN_DIST .001\n\n#define OBJ_SKY 0\n#define OBJ_FLOOR 1\n#define OBJ_BOX 2\n\n#define cam_cyli\n\nconst float camera_fov = 70.;\n\n\nstruct HitInfo {\n    float t;\n    vec3 norm;\n    vec4 color;\n    int obj_type;\n};\n\nbool boxAABB(in vec3 dims, vec3 ro, vec3 rd) {\n    rd += 0.0001 * (1.0 - abs(sign(rd)));\n    vec3 n = ro / rd;\n    vec3 k = dims / abs(rd);\n    vec3 t1 = -k - n, t2 = k - n;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    return tN < tF && tF > 0.0;\n}\n\nconst vec2 mscl = vec2(800.,450.)*1.15;\n\n// https://danilw.github.io/blog/Hash_Noise_in_GPU_Shaders/\n#define FIX_FRACT_HASH 3000.\n\nfloat hash12(vec2 p)\n{\n#ifdef FIX_FRACT_HASH\n    p = sign(p)*(floor(abs(p))+floor(fract(abs(p))*FIX_FRACT_HASH)/FIX_FRACT_HASH);\n#endif\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n#ifdef FIX_FRACT_HASH\n    p = sign(p)*(floor(abs(p))+floor(fract(abs(p))*FIX_FRACT_HASH)/FIX_FRACT_HASH);\n#endif\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat noise(vec2 x) {\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\tfloat a = hash12(i);\n\tfloat b = hash12(i + vec2(1.0, 0.0));\n\tfloat c = hash12(i + vec2(0.0, 1.0));\n\tfloat d = hash12(i + vec2(1.0, 1.0));\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn (-1.+2.*(mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y));\n}\n\nvec3 Hue(vec3 c, float h)\n{\n    vec3 P = vec3(0.55735)*dot(vec3(0.55735),c);\n    vec3 U = c-P;\n    vec3 V = cross(vec3(0.55735),U);    \n    c = U*cos(h*6.2832) + V*sin(h*6.2832) + P;\n    return c;\n}\n\nvec3 HueShift(vec3 c, float h){\n    h = floor(h*25.)/25.;\n    vec3 tc = Hue(c, (h-0.5)*0.25);\n    return tc;\n}\n\nvec2 Box_hit(vec3 ro,vec3 rd,vec3 p0,vec3 p1)\n{\n    vec3 t0 = (mix(p1, p0, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    vec3 t1 = (mix(p0, p1, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    return vec2(max(t0.x, max(t0.y, t0.z)),min(t1.x, min(t1.y, t1.z)));\n}\n\nvec3 boxNormal(vec3 pos,vec3 p0,vec3 p1, vec3 bsize)\n{\n    pos = pos - (p0 + p1) / 2.;\n    vec3 arp = abs(pos) / bsize;\n    return step(arp.yzx, arp) * step(arp.zxy, arp) * sign(pos);\n}\n\nbool BoxIntersect_min( in vec3 ro, in vec3 rd, vec3 opos, vec3 size, out float tN, out vec3 norm){\n    vec3 p = size*0.5+opos;\n    vec3 q = -size*0.5+opos;\n    vec2 b = Box_hit(ro, rd, p, q);\n    tN=MAX_DIST;\n    norm=vec3(0.,1.,0.);\n\n    if(b.x > MIN_DIST && b.x < b.y && b.x < MAX_DIST)\n    {\n        tN = b.x;\n        vec3 pos = ro + rd * tN;\n        norm = boxNormal(pos, p, q, size);\n        return true;\n    }\n    return false;\n}\n\n\nconst vec3 sun_color = vec3(0.5);\nconst vec3 sky_color = vec3(0.075);\n//const vec3 horizon_color = vec3(.25);\nconst vec3 ground_color = vec3(0.05);\n\nconst vec3 lig = normalize(vec3(0.7,0.5,0.4));\n\nvec3 blurred_background(vec3 rd)\n{\n    float sun = max(0.0, dot(rd, lig));\n    return 0.1*(mix(ground_color, sky_color, (dot(rd, vec3(0.0, 1.0, 0.0))*0.5 + 0.5)) +\n        0.24*pow(sun, 2.0)*sun_color);\n}\n\nfloat fresnel(vec3 d, vec3 n)\n{\n    float a = clamp(1.0-dot(n,-d), 0.0, 1.0);\n    return clamp(exp((5.0*a)-5.0), 0.0, 1.0);\n}\n\nvec3 mixc(vec3 ro, vec3 rd, float t, vec3 nor, vec3 a, vec3 e, float v){\n    const vec3 lig = normalize(vec3(0.7,0.5,0.4));\n    vec3 hal = normalize(-rd+lig);\n    float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n    float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n    \n    vec3 col = a+e*0.;\n    col *= vec3(0.6)*amb + vec3(1.)*dif;\n    col+=e;\n    float tl = fresnel(rd, nor);\n    col*=1.-tl;\n    col += v*0.4*pow(clamp(dot(hal,nor),0.0,1.0),8.0)*dif;\n    col += v*5.*pow(clamp(dot(hal,nor),0.0,1.0),28.0)*dif*tl;\n    return col;\n    \n}\n\n\nbool BoxIntersect_min_inv( in vec3 ro, in vec3 rd, vec3 opos, vec3 size, out float tN, out vec3 norm){\n    vec3 p = size*0.5+opos;\n    vec3 q = -size*0.5+opos;\n    vec2 b = Box_hit(ro, rd, p, q);\n    tN=MAX_DIST;\n    norm=vec3(0.,1.,0.);\n\n    if(b.y > MIN_DIST && b.x < b.y && b.y < MAX_DIST)\n    {\n        tN = b.y;\n        vec3 pos = ro + rd * tN;\n        norm = -boxNormal(pos, p, q, size);\n        return true;\n    }\n    return false;\n}\n\nvoid tix_ta(vec2 ts, bool fa, out vec2 tix, out bool ta);\nvoid BoxIntersectMin_minimal_inv_tv(vec3 ro, vec3 rd, vec3 box_l, vec3 opos, inout bool result, inout HitInfo hit, sampler2D ch, vec2 ires, vec2 ts, bool fa, float timer) {\n    float tnew;\n    vec3 normnew;\n    \n    if (BoxIntersect_min_inv(ro, rd, opos, box_l, tnew, normnew)) {\n        if (tnew < hit.t) {\n            if(normnew.x>-0.5){\n                hit.t = tnew;\n                hit.norm = normnew;\n                vec3 refd = normalize(reflect(rd, normnew));\n                vec3 mc = blurred_background(refd);\n                \n                vec3 tp = ro-opos+rd*tnew;\n                \n                vec2 tuv = vec2(tp.zx/box_l.zx)*vec2(0.95,.85*-normnew.y);\n                if(abs(normnew.z)>0.5)tuv = (tp.xy/box_l.xy)*vec2(-normnew.z*0.95,.85);\n                tuv+=0.5;\n                const ivec2 MEMORY_BOUNDARY = ivec2(5, 3+10);\n                const float mscale = 10.;\n                vec2 sft = vec2(0.,MEMORY_BOUNDARY.y+1)/ires;\n                vec2 tix;\n                bool ta;\n                tix_ta(ts, fa, tix, ta);\n                \n                bool ecf = ((hash12(ts*11.31+10.853))>0.8);\n                vec2 ttixx = ivec2(tix)==ivec2(1,1)?(hash12(ts*1.31+.53)>0.6?vec2(1.,0.):vec2(0.,1.-float(hash12(ts*.31+.53)>0.5))):tix;\n                if(ecf)tix=1.-ttixx;\n                tuv+=tix;\n                \n                tuv*=(mscl/ires.xy)*.5*1./mscale;\n                tuv+=sft;\n                if(ecf)tuv.y+=2.0*((mscl/ires.xy)*.5*1./mscale).y;\n                vec4 tc = textureLod(ch, tuv, 0.);\n                tc.rgb=HueShift(tc.rgb,hash12(ts*263.131+0.5));\n                \n                int ix = int(hash12(ts*143.331)*7.);\n                mat3 trc = mat3(vec3(1.,0.5,0.75),vec3(.5,1.,.75),vec3(0.5,0.75,1.));\n                vec3 tco = ((ix<3)&&(ivec2(tix)!=ivec2(1,1)))?trc[ix]:vec3(.25,.85,1.);\n                if(ecf){tco[2-(ix%3)]+=5.;tco*=0.25;}\n                if(ta)tc.rgb = vec3(tco*clamp(tc.a,0.,1.));\n                bool tfax = ivec2(tix)==ivec2(1,1)&&ta;\n                if(tfax)tc.rgb=clamp((1.-clamp(.5*trc[ix%3]/(2.5*tc.rgb+0.001),0.,1.))*1.5,0.,1.);\n                \n                float ttsx = (ts.x+ts.y)*.5-10.;\n                float tml = timer*2.75;\n                float ttd = step(0.,0.35-ttsx-tml);\n                float tsl = step(timer, 10.);\n                ttd*=tsl;\n                ttd*=float(!((fa)&&(ivec2(ts)==ivec2(1,-2))));\n                tc.rgb = tc.rgb*(1.-ttd)+ttd*0.;\n                \n                tc.rgb*=0.25+1.6*float(ta&&!tfax);\n                \n                \n                float d = step(0.15,(tuv.y))*1.;\n                \n                mc = mixc(ro, rd, tnew, normnew, 2.5*mc+tc.rgb*0.5, tc.rgb*0.21, .25);\n                \n                hit.color = vec4(mc, 1.);\n                hit.obj_type = OBJ_BOX;\n                result = true;\n            }\n        }\n    }\n}\n\nvoid BoxIntersectMin_minimal_inv_tv_a1(vec2 m, vec3 ro, vec3 rd, vec3 box_l, vec3 opos, inout bool result, inout HitInfo hit) {\n    float tnew;\n    vec3 normnew;\n    \n    if (BoxIntersect_min_inv(ro, rd, opos, box_l, tnew, normnew)) {\n        if (tnew < hit.t) {\n            bool a = normnew.x>-0.5;\n            bool b = true;\n            if(normnew.x>0.5){\n                vec3 tp = ro-opos+rd*tnew;\n                tp.z+=sign(tp.z)*0.15*(m.x+.5);\n                tp.z=fract(tp.z)-0.5;\n                \n                b = length(m.y*tp.yz*vec2(1.,0.5)*1.5)>0.125;\n            }\n            if(a&&b){\n                hit.t = tnew;\n                hit.norm = normnew;\n                vec3 refd = normalize(reflect(rd, normnew));\n                vec3 mc = blurred_background(refd);\n                mc = mixc(ro, rd, tnew, normnew, mc, vec3(0.), 0.5);\n                hit.color = vec4(mc, 1.);\n                hit.obj_type = OBJ_BOX;\n                result = true;\n            }\n        }\n    }\n}\n\n\n\n\n\n// https://www.shadertoy.com/view/3tj3DW\nbool rounded2Intersect_iSphere4( in vec3 ro, in vec3 rd, in float ra, out float tNo)\n{\n    tNo=MAX_DIST+1.;\n    float r2 = ra*ra;\n    \n    vec3 d2 = rd*rd; vec3 d3 = d2*rd;\n    vec3 o2 = ro*ro; vec3 o3 = o2*ro;\n\n    float ka = 1.0/dot(d2,d2);\n\n    float k3 = ka* dot(ro,d3);\n    float k2 = ka* dot(o2,d2);\n    float k1 = ka* dot(o3,rd);\n    float k0 = ka*(dot(o2,o2) - r2*r2);\n\n    float c2 = k2 - k3*k3;\n    float c1 = k1 + 2.0*k3*k3*k3 - 3.0*k3*k2;\n    float c0 = k0 - 3.0*k3*k3*k3*k3 + 6.0*k3*k3*k2 - 4.0*k3*k1;\n\n    float p = c2*c2 + c0/3.0;\n    float q = c2*c2*c2 - c2*c0 + c1*c1;\n    \n    float h = q*q - p*p*p;\n\n    if( h<0.0 ) return false;\n    float sh = sqrt(h);\n\n    float s = sign(q+sh)*pow(abs(q+sh),1.0/3.0);\n    float t = sign(q-sh)*pow(abs(q-sh),1.0/3.0);\n    vec2  w = vec2( s+t,s-t );\n\n#if 1\n    vec2  v = vec2( w.x+c2*4.0, w.y*sqrt(3.0) )*0.5;\n    float r = length(v);\n    float tt = -abs(v.y)/sqrt(r+v.x) - c1/r - k3;\n    if(tt<0.0) return false;\n    tNo=tt;\n    return true;\n#else\n    float r = sqrt( c2*c2 + w.x*w.x + 2.0*w.x*c2 - c0 );\n    float tt = -sqrt( 3.0*w.y*w.y/(4.0*r+w.x*2.0+c2*8.0)) - c1/r - k3;\n    if(tt<0.0) return false;\n    tNo=tt;\n    return true;\n#endif    \n}\n\nvec3 nSphere4( in vec3 pos )\n{\n    return normalize( pos*pos*pos );\n}\n\n\n// https://www.shadertoy.com/view/WlSXRW\nbool roundedboxIntersect( in vec3 ro, in vec3 rd, in vec3 size, in float rad, out float tNo) \n{\n    tNo=MAX_DIST+1.;\n    // bounding box\n    rd += 0.0001 * (1.0 - abs(sign(rd)));\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*(size+rad);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return false;\n    float t = tN;\n    \n    // convert to first octant\n    vec3 pos = ro+t*rd;\n    vec3 s = sign(pos);\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n\n    // faces\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n\n    bool ifl = t<0.0;\n    if( min(min(pos.x,pos.y),pos.z)<0.0&&!ifl){tNo = t; return true;}\n\n    // some precomputation\n    vec3 oc = ro - size;\n    vec3 dd = rd*rd;\n    vec3 oo = oc*oc;\n    vec3 od = oc*rd;\n    float ra2 = rad*rad;\n\n    t = MAX_DIST+1.;        \n\n    {\n        float b = od.x + od.y + od.z;\n        float c = oo.x + oo.y + oo.z - ra2;\n        \n        float h = b*b - c;\n        if( h>0.0 ) t = -b-sqrt(h);\n    }\n\n    // edge X\n    {\n        float a = dd.y + dd.z;\n        float b = od.y + od.z;\n        float c = oo.y + oo.z - ra2;\n        float h = b*b - a*c;\n        if( h>0.0 )\n        {\n            h = (-b-sqrt(h))/a;\n            if( h>0.0 && h<t && abs(ro.x+rd.x*h)<size.x ) t = h;\n        }\n    }\n    // edge Y\n    {\n        float a = dd.z + dd.x;\n        float b = od.z + od.x;\n        float c = oo.z + oo.x - ra2;\n        float h = b*b - a*c;\n        if( h>0.0 )\n        {\n            h = (-b-sqrt(h))/a;\n            if( h>0.0 && h<t && abs(ro.y+rd.y*h)<size.y ) t = h;\n        }\n    }\n    // edge Z\n    {\n        float a = dd.x + dd.y;\n        float b = od.x + od.y;\n        float c = oo.x + oo.y - ra2;\n        float h = b*b - a*c;\n        if( h>0.0 )\n        {\n            h = (-b-sqrt(h))/a;\n            if( h>0.0 && h<t && abs(ro.z+rd.z*h)<size.z ) t = h;\n        }\n    }\n\n    if(t>MAX_DIST){return false;}\n    if(t<=0.0) return false;\n    tNo = t;\n    return true;\n}\n\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\n    return sign(pos)*normalize(max(abs(pos)-siz,0.0));\n}\n\nvoid RoundedBoxIntersectMin_mod_tv(vec2 ts, vec4 acu, vec3 ro, vec3 rd, in vec3 size, vec3 opos, in float rad, inout bool result, inout HitInfo hit) {\n    float tnew;\n    vec3 normnew;\n    ro -= opos;\n    if (roundedboxIntersect(ro, rd, size, rad, tnew)) {\n        if (tnew < hit.t) {\n            normnew=roundedboxNormal(ro+rd*tnew, size, rad);\n            vec3 tp = ro+rd*tnew;\n            bool a = normnew.x<0.5;\n            bool b = a;\n            if(!a){\n                bool se = false;\n                vec3 bpc = vec3(acu.x*0.5, -(acu.x*0.25+acu.z*0.5), 0.);\n                float tlp = abs(tp.y-bpc.y)-(acu.x*0.5-acu.z)*0.5*acu.w;\n                bool c=tlp>0.;\n                if(!c)c=c||((fract(tlp*45.)-0.5>0.));\n                b = (normnew.x>0.5&&(se||(c&&step(tp.y,-acu.z)>0.5)||step(acu.y,tp.y)>0.5||step(acu.y,abs(tp.z))>0.5));\n                \n            }\n            \n            if(a||b){\n                hit.t = tnew;\n                \n                hit.norm = normnew;\n                vec3 refd = normalize(reflect(rd, normnew));\n                vec3 mc = blurred_background(refd);\n                mc = mixc(ro, rd, tnew, normnew, mc, vec3(0.), .25);\n                hit.color = vec4(mc*(1.-smoothstep(-0.16,-0.18,(tnew*rd+ro).x-size.x)),1.);\n                hit.obj_type = OBJ_BOX;\n                result = true;\n            }\n        }\n    }\n}\n\n// https://www.shadertoy.com/view/wdBXRt\nvec2 edts(vec2 p) {\n    vec2 uv = p*p;\n    float t = 2.0 * sqrt(2.0);\n    vec2 s = vec2(2.0 + uv.x - uv.y, 2.0 - uv.x + uv.y);\n    vec2 t1 = s + p * t;\n    vec2 t2 = s - p * t;\n    //t1=abs(t1);t2=abs(t2); //or this\n    if (any(lessThan(vec4(t1, t2), vec4(0.))))return 0.5 * (t1) - 0.5 * (t2);\n    return 0.5 * sqrt(t1) - 0.5 * sqrt(t2);\n}\n\n\nvoid tix_ta(vec2 ts, bool fa, out vec2 tix, out bool ta){\n    ts+=112.;\n    tix = floor(hash22(ts*141.331)*2.);\n    ta = hash12(ts*122.331)>0.45;\n    if(ivec2(tix)==ivec2(1,1)&&(!fa)&&ta){\n        tix = vec2(hash22(ts*81.331));\n        ta = tix.y>0.5;\n        if(ta)tix = tix.x>0.66?vec2(1.,0.):(tix.x>0.33?vec2(0.,0.):vec2(0.,1.));\n        else tix = floor(hash22(ts*91.331)*2.);\n    }\n}\n\nvec3 texure_sph(vec3 nor, vec3 pos, sampler2D ch, sampler2D ch2, out float d, float rad, vec2 ts, out float tba, bool fa, float timer){\n    vec3 uvw = pos/rad;\n    vec2 uv = uvw.zy;\n    uv = edts(uv*.62588);\n    vec2 tix;\n    bool ta;\n    tix_ta(ts, fa, tix, ta);\n    d = step(abs(uv.x),0.5)*step(abs(uv.y),0.5);\n    vec4 tc = vec4(0.);\n    \n    bool ecf = ((hash12(ts*11.31+10.853))>0.8);\n    vec2 ttixx = ivec2(tix)==ivec2(1,1)?(hash12(ts*1.31+.53)>0.6?vec2(1.,0.):vec2(0.,1.-float(hash12(ts*.31+.53)>0.5))):tix;\n    if(!ecf)tc = textureLod(ch,(uv+0.5)*.5+.5*tix,0.);\n    else tc = textureLod(ch2,(uv+0.5)*.5+.5*(1.-ttixx),0.);\n    tc.rgb=HueShift(tc.rgb,hash12(ts*263.131+0.5));\n    \n    int ix = int(hash12(ts*143.331)*7.);\n    mat3 trc = mat3(vec3(1.,0.5,0.75),vec3(.5,1.,.75),vec3(0.5,0.75,1.));\n    vec3 tco = ((ix<3)&&(ivec2(tix)!=ivec2(1,1)))?trc[ix]:vec3(.25,.85,1.);\n    if(ecf){tco[2-(ix%3)]+=5.;tco*=0.25;}\n    if(ta)tc.rgb = vec3(tco*clamp(tc.a,0.,1.));\n    tba = (1.-2.*float(ta));\n    if(ivec2(tix)==ivec2(1,1)&&ta)tc.rgb=clamp((1.-clamp(0.5*trc[ix%3]/(tc.rgb+0.001),0.,1.))*2.,0.,2.);\n    \n    float ttsx = (ts.x+ts.y)*.5-10.;\n    float tml = timer*2.75;\n    float ttd = step(0.,length(uv)-ttsx-tml);\n    float tsl = step(timer, 10.);\n    ttd*=tsl;\n    ttd*=float(!((fa)&&(ivec2(ts)==ivec2(1,-2))));\n    if(tba>0.5)tba=1.-2.*step(ttsx+tml,1.)*tsl;\n    tc.rgb = tc.rgb*(1.-ttd)+ttd*0.;\n    return tc.rgb*d+0.001;\n}\n\nvoid Rounded2Intersect_iSphere4Min_tv(vec2 ts, bool fa, vec3 ro, vec3 rd, vec3 opos, in float rad, inout bool result, inout HitInfo hit, sampler2D ch, sampler2D ch2, float timer) {\n    float tnew;\n    ro -= opos;\n    if (rounded2Intersect_iSphere4( ro, rd, rad, tnew)) {\n        if (tnew < hit.t) {\n            vec3 normnew=nSphere4(ro+rd*tnew);\n            vec3 refd = normalize(reflect(rd, normnew));\n            vec3 mc = mixc(ro, rd, tnew, normnew, vec3(0.), vec3(0.), 1.);\n            \n            hit.t = tnew;\n            hit.norm = normnew;\n            hit.color = vec4(mc, 1.);\n            hit.obj_type = OBJ_BOX;\n            result = true;\n            \n            float ttnew;\n            if(rounded2Intersect_iSphere4( ro, rd, rad*0.905, ttnew))\n            {\n                if((ttnew*rd+ro).x>0.805*rad*0.905)\n                {\n                    //hit.t = ttnew;\n                    vec3 tnormnew=nSphere4(ro+rd*tnew);\n                    //hit.norm = tnormnew;\n                    float d;\n                    float tba;\n                    mc = texure_sph(tnormnew, ro+rd*ttnew, ch, ch2, d, rad, ts, tba, fa, timer);\n                    mc = mixc(ro, rd, tnew, normnew, mc*0.25, mc*.85, 0.45);\n                    if(d>0.5)hit.color = vec4(mc*tba,1.);\n                    //hit.obj_type = OBJ_BOX;\n                    //result = true;\n                }\n            }\n\n        }\n    }\n}\n\n\nvec3 eliNormal( in vec3 pos, vec3 sph_pos, vec3 sph_rad)\n{\n    return normalize((pos-sph_pos)/(sph_rad*sph_rad));\n}\n\n//https://www.shadertoy.com/view/MlsSzn\nbool eliIntersect_inv( in vec3 ro, in vec3 rd, vec3 sph_pos, vec3 sph_rad, out float tN)\n{\n    tN = MAX_DIST;\n    vec3 oc = ro - sph_pos;\n    \n    vec3 ocn = oc / sph_rad;\n    vec3 rdn = rd / sph_rad;\n    \n    float a = dot(rdn, rdn);\n  float b = dot(ocn, rdn);\n  float c = dot(ocn, ocn);\n  //float h = b*b - a*(c-1.0);\n    float h = b*b - a*(c-1.0);\n  if( h<0.0 ) return false;\n  float t = (-b + sqrt(h))/a;\n    if(t<0.)return false;\n    tN = t;\n    return true;\n}\n\nvoid eliIntersectMin_inv_mod_tv(vec4 acu, vec3 SpPos, vec3 SpRad, vec3 ro, vec3 rd, inout bool result, inout HitInfo hit, int obj_t, sampler2D ch, vec2 ires, vec2 ts, bool fa, float timer) {\n    float tnew;\n    if (eliIntersect_inv(ro, rd, SpPos, SpRad, tnew)) {\n        if (tnew < hit.t) {\n            vec3 tp = ro-SpPos+rd*tnew;\n            vec3 normnew = eliNormal(ro+rd*tnew, SpPos, SpRad);\n            bool ab = boxAABB(vec3(100.5,acu.x*0.25+acu.z*0.5-0.5*(acu.x*0.5-acu.y),acu.y+0.001), tp, normnew);\n            \n            if(ab&&tp.x<-acu.w)\n            {\n                hit.t = tnew;\n                hit.norm = -normnew;\n                hit.obj_type = obj_t;\n                vec3 refd = normalize(reflect(rd, -normnew));\n                \n                vec2 tuv = (tp.zy/SpRad.zy)*vec2(0.66,0.62)+0.5;\n                const ivec2 MEMORY_BOUNDARY = ivec2(5, 3+10);\n                const float mscale = 10.;\n                vec2 sft = vec2(0.,MEMORY_BOUNDARY.y+1)/ires;\n                vec2 tix;\n                bool ta;\n                tix_ta(ts, fa, tix, ta);\n                \n                bool ecf = ((hash12(ts*11.31+10.853))>0.8);\n                vec2 ttixx = ivec2(tix)==ivec2(1,1)?(hash12(ts*1.31+.53)>0.6?vec2(1.,0.):vec2(0.,1.-float(hash12(ts*.31+.53)>0.5))):tix;\n                if(ecf)tix=1.-ttixx;\n                \n                tuv+=tix;\n                vec2 ouv = tuv;\n                tuv*=(mscl/ires.xy)*.5*1./mscale;\n                tuv+=sft;\n                if(ecf)tuv.y+=2.0*((mscl/ires.xy)*.5*1./mscale).y;\n                \n                vec4 tc = textureLod(ch, tuv, 0.);\n                tc.rgb=HueShift(tc.rgb,hash12(ts*263.131+0.5));\n                int ix = int(hash12(ts*143.331)*7.);\n                mat3 trc = mat3(vec3(1.,0.5,0.75),vec3(.5,1.,.75),vec3(0.5,0.75,1.));\n                vec3 tco = ((ix<3)&&(ivec2(tix)!=ivec2(1,1)))?trc[ix]:vec3(.25,.85,1.);\n                if(ecf){tco[2-(ix%3)]+=5.;tco*=0.25;}\n                if(ta)tc.rgb = vec3(tco*clamp(tc.a,0.,1.));\n                bool tfax = ivec2(tix)==ivec2(1,1)&&ta;\n                if(tfax)tc.rgb=clamp((1.-clamp(0.5*trc[ix%3]/(2.5*tc.rgb+0.001),0.,1.))*1.5,0.,1.);\n                \n                float ttsx = (ts.x+ts.y)*.5-10.;\n                float tml = timer*2.75;\n                float ttd = step(0.,0.35-ttsx-tml);\n                float tsl = step(timer, 10.);\n                ttd*=tsl;\n                ttd*=float(!((fa)&&(ivec2(ts)==ivec2(1,-2))));\n                tc.rgb = tc.rgb*(1.-ttd)+ttd*0.;\n                \n                vec2 tpu = (fract(ouv)-0.5);\n                tpu*=tpu;\n                float d = 1.-smoothstep(0.05,0.305,length(tpu));\n                tc.rgb*=0.25+0.46*float(ta&&!tfax);\n                tc.rgb*= vec3(d*d);\n                vec3 mc = mixc(ro, rd, tnew, -normnew, blurred_background(refd)*1.+tc.rgb*1., tc.rgb*0., 0.01);\n                hit.color = vec4(mc,1.);\n                result = true;\n            }\n        }\n    }\n}\n\n\nbool CylinderIntersect( in vec3 ro, in vec3 rd, in float ra, in float heigh, out float tN, out vec3 norm, out bool wa) \n{\n    vec3 pa=vec3(0.,heigh,0.);\n    vec3 pb=vec3(0.,-heigh,0.);\n    vec3 ba = pb-pa;\n    wa = false;\n\n    norm=vec3(0.,1.,0.);\n    tN=MAX_DIST;\n\n    vec3  oc = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n\n    float k2 = baba            - bard*bard;\n    float k1 = baba*dot(oc,rd) - baoc*bard;\n    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n\n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return false;\n    float ins = -1.; // inside -1.\n    h = ins*sqrt(h);\n    float t = (-k1-h)/k2;\n    //if( t<0.0 ) return false; //original\n\n    float y = baoc + t*bard;\n    if( y>0.0 && y<baba ){\n        if( t<0.0 ) return false;//fix to hide when camera over it\n        tN=t;\n        norm=ins*(oc+t*rd - ba*y/baba)/ra;\n        return true;\n    }\n\n    t = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;\n    if( t<0.0 ) return false;//fix to hide when camera over it\n    if( abs(k1+k2*t)<ins*h ){\n        tN=t;\n        norm=ba*sign(y)/baba;\n        wa=true;\n        return true;\n    }\n\n    return false;\n}\n\nvec3 cylNormal( in vec3 p, float ra )\n{\n    vec3 a=vec3(0.,1.,0.);\n    vec3 b=vec3(0.,-1.,0.);\n    vec3  pa = p - a;\n    vec3  ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float h = dot(pa,ba)/baba;\n    return (pa - ba*h)/ra;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a;\n    float t = dot(p - a, ab) / dot(ab, ab);\n    t = clamp(t, 0.0, 1.0);\n    return length((a + t * ab) - p) - r;\n}\n\nfloat flare(float e, float i, float s) { return exp(1.-(e*i))*s; }\n\nvec4 colorCylinder(vec3 ro, vec3 rd, float d, vec3 nor,float heigh, vec2 ts, float timer, bool fa)\n{\n    vec3 pos = (ro+rd*d);\n    vec2 tuv=vec2(0.5,0.)+vec2(2.*atan(pos.x,pos.z)/(3.1415926*2.), pos.y*.5/heigh);\n    \n    float tt = (abs(ts.x)+abs(ts.y))*112.331;\n    tt+=timer;\n    vec3 col = 0.5 + 0.5*cos(tt*2.+10.*tuv.xyx+vec3(0,2,4));\n    \n    float tl = clamp(0.051/(0.001+smoothstep(0.0,.975,abs(tuv.x))),0.,1.);\n    vec2 ttuv= tuv*4.;\n    ttuv.y+=timer*2.5;\n    float td = fract(ttuv.x + ttuv.y)*fract(ttuv.y - ttuv.x); \n    td*=tl;\n    vec3 c1 = 1.*(td*0.35+1.5*td*col);\n    ttuv= tuv*2.;\n    ttuv.y+=timer*.5;\n    td = fract(ttuv.x + ttuv.y)*fract(ttuv.y - ttuv.x); \n    td*=tl;\n    c1 = c1*0.5+2.*td*c1+0.5*(td*0.35+1.5*td*col);\n    //c1=clamp(c1,0.,1.);\n    \n    float ttsx = (ts.x+ts.y)*.5-10.;\n    float tml = timer*2.75;\n    float ttd = step(0.,0.35-ttsx-tml);\n    float tsl = step(timer, 10.);\n    ttd*=tsl;\n    ttd*=float(!((fa)&&(ivec2(ts)==ivec2(1,-2))&&timer>0.4));\n    c1.rgb = c1.rgb*(1.-ttd)+ttd*0.;\n    \n    int ix = int(hash12(ts*243.331+1.3)*7.);\n    mat3 trc = mat3(vec3(1.,0.25,0.275),vec3(.35,.75,.75),vec3(0.25,0.275,1.));\n    vec3 tco = (ix<5)?trc[ix%3]*5.:vec3(1.,1.,1.);\n    \n    vec3 mc = mixc(ro, rd, d, nor, clamp(c1*tco,0.,1.)*1.5, vec3(0.), .5);\n    return vec4(mc,1.);\n}\n\nvoid CylinderIntersectMin(vec3 ro, vec3 rd, float rad, float heigh, vec3 opos, inout bool result, inout HitInfo hit, vec2 ts, float timer, bool fa) {\n    float tnew;\n    vec3 normnew;\n    ro -= opos;\n    bool wa;\n    if (CylinderIntersect(ro, rd, rad, heigh, tnew, normnew, wa)) {\n        if (tnew < hit.t) {\n            vec3 tp = ro+rd*tnew;\n            if(tp.x<-0.0){\n                normnew=normnew.xzy; //rot\n                hit.t = tnew;\n                hit.norm = normnew;\n                if(wa){hit.color = vec4(vec3(0.051),1.);}\n                else hit.color = colorCylinder(ro,rd,hit.t,normnew,heigh,ts,timer, fa);\n                hit.obj_type = OBJ_BOX;\n                result = true;\n            }\n        }\n    }\n}\n\n\n\n\n\n// base on https://www.shadertoy.com/view/NlycW1\n\nstruct its\n{\n\tfloat t;\n\tvec3 n;    //normal \n\t\n};\nconst its  NO_its=its(MAX_DIST,vec3(0.,1.,0.));\n\nstruct span\n{\n\tits n;\n\tits f;\n};\n\n//-----------Intersection functions--(based on Iq)------------------\nspan Inter(span a, span b)\n{\n   bvec4 cp = bvec4(a.n.t<b.n.t,a.n.t<b.f.t,a.f.t<b.n.t,a.f.t<b.f.t); \n   // if(b.n.t==NOHIT || a.n.t==NOHIT) return span(NO_its,NO_its);\n   \n   if(cp.x && cp.z) return span(NO_its,NO_its);\n   else if(cp.x && !cp.z && cp.w)  return span(b.n,a.f);\n   else if(cp.x && !cp.z && !cp.w) return b;\n   else if(!cp.x && cp.y &&  cp.w) return a;\n   else if(!cp.x && cp.y &&  !cp.w) return span(a.n,b.f);\n   else return span(NO_its,NO_its);\n}\n\nspan Sub(span a, span b)\n{\n   bvec4 cp = bvec4(a.n.t<b.n.t,a.n.t<b.f.t,a.f.t<b.n.t,a.f.t<b.f.t); \n   // if(a.n.t==NOHIT) return span(NO_its,NO_its);\n   // else if(b.n.t==NOHIT) return a;        \n   if     (cp.x && cp.z) return a;\n   else if(cp.x && !cp.z && cp.w)  return span(a.n,b.n);\n   else if(cp.x && !cp.z && !cp.w && b.n.t>0.) return span(a.n,b.n); \n   else if(cp.x && !cp.z && !cp.w && b.n.t<0.) return span(b.f,a.f); //+ secondary span =  span(b.f,a.f)\n   else if(!cp.x && cp.y && cp.w) return span(NO_its,NO_its);\n   else if(!cp.x && cp.y && !cp.w) return span(b.f,a.f);\n   else return a;\n   \n}\n\n// useful if transparent \nspan Union(span a, span b)\n{\n   bvec4 cp = bvec4(a.n.t<b.n.t,a.n.t<b.f.t,a.f.t<b.n.t,a.f.t<b.f.t); \n   if(b.n.t==MAX_DIST) return a;\n   else if(a.n.t==MAX_DIST) return b;   \n   else if(cp.x  && cp.z  && a.f.t>0.) return a;\n   else if(cp.x  && cp.z  && a.f.t<0.) return b;\n   else if(cp.x  && !cp.z && cp.w) return span(a.n,b.f);\n   else if(cp.x  && !cp.z && !cp.w) return a;\n   else if(!cp.x && cp.y  && cp.w) return b;\n   else if(!cp.x && cp.y  && !cp.w) return span(b.n,a.f);\n   else if(!cp.x && !cp.y  && a.f.t>0.) return b;\n   else /*if(!cp.x && !cp.y  && a.f.t<0.) */ return a;   \n}\n\n// this is infinite long box\n// exist because Nvidia bugs https://www.shadertoy.com/view/NtfyD2\nspan iBox_2d( in vec3 ro, in vec3 rd, vec2 boxSize) \n{\n    rd+=0.000001*(1.-abs(sign(rd))); //fix against vertical line on middle\n    vec3 m = 1./rd; \n    vec3 n = m*ro;   \n    vec3 boxSize_t=vec3(1.,boxSize);\n    vec3 k = abs(m)*boxSize_t;\n    \n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( t1.y, t1.z );\n    float tF = min( t2.y, t2.z );\n    if( tN>tF ) return span(NO_its,NO_its); // no intersection\n    vec3 oNor = -sign(rd)*vec3(0.,step(t1.zy,t1.yz)); \n    vec3  fNor= sign(rd)*vec3(0.,step(t2.yz,t2.zy)); \n    return  span(its(tN,oNor) , its(tF,fNor));\n}\n\n\n//  plane with thickness h\nspan iPlane( in vec3 ro, in vec3 rd, in vec3 n ,float h)\n{\n    float d1= -dot(ro,n)/dot(rd,n),   d2= -(dot(ro-h*n,n))/dot(rd,n);\n    vec3  u = normalize(cross(n,vec3(0,0,1))), v = normalize(cross(u,n) );\n    vec3 oNor=n;\n    if(d1<d2) return span(its(d1,-oNor),its(d2,oNor));\n    return span(its(d2,oNor),its(d1,-oNor));\n}\n\nvec3 opU( vec3 d, span s, inout vec3 normal, float mat ) {\n    its ix= s.n;   \n    //if(ix.t<0.) ix=s.f;\n    if( ix.t<d.y && ix.t>d.x) {\n        normal=ix.n;\n        d=vec3(d.x, ix.t, mat);\n    }\n\treturn d;\n}\n\nvec3 RayTracing_Domain_Repetition( in vec3 ro, in vec3 rd, out vec3 normal, float sc, float st, vec2 boxx, int mx) {\n    \n    vec3  d = vec3(MIN_DIST, MAX_DIST, 0.);\n    span s2,s3,s4;\n    s2= iBox_2d(ro,rd,boxx);\n    normal=vec3(0.,1.,0.);\n\n    if(s2.n.t<MAX_DIST){\n        float x = s2.n.t>0.? ro.x+ rd.x*s2.n.t:ro.x;\n        float xm = fract(x*sc),         \n              xf = floor(x*sc); \n              \n        // 2x visible only to single direction when Sub used\n        // add more loop iterations to see more layers repetitions when inside\n        for(int j=0; j<2;j++){\n            s3=  iPlane(ro-vec3(sign(xf)*min(abs(xf),float(mx))/sc,0,0),rd,normalize(vec3(1.,0.,0.)),st);\n            s4=  Inter(s2,s3);\n            d= opU(d,  s4,normal, xf);\n            xf+=sign(rd.x);\n        }\n\n    }\n    \n    if(dot(rd,normal)>0.) normal=-normal;\n    return d;\n}\n\n\nvoid RayTracing_Domain_RepetitionMin(vec3 ro, vec3 loc, vec3 rd, inout bool result, inout HitInfo hit, float sc, float st, vec2 boxx) {\n    float tnew;\n    vec3 normnew;\n    vec3 rrt = RayTracing_Domain_Repetition((ro-loc).zxy, (rd).zxy, normnew, sc, st, boxx, 33);\n    tnew = rrt.y;\n    if (tnew < hit.t) {\n        //if(rrt.z>-35.&&rrt.z<35.)\n        {\n            hit.t = tnew;\n            hit.norm = normnew.yzx;\n            vec3 refd = normalize(reflect(rd, normnew.yzx));\n            vec3 mc = blurred_background(refd);\n            mc = mixc(ro, rd, tnew, normnew.yzx, mc, vec3(0.), .25);\n            hit.color = vec4(mc,1.);\n            hit.obj_type = OBJ_BOX;\n            result = true;\n        }\n    }\n}\n\n\n//#define SHOW_ab\nvoid TVIntersectMin(float max_h, vec2 ts, vec3 ro, vec3 rd, inout bool result, inout HitInfo hit, sampler2D ch, sampler2D ch2, float timer, vec2 ires){\n    float box_tv = .985;\n    vec4 sfi = vec4(0.);\n    vec2 tm = vec2(1.);\n    vec2 tts = mod(ts, vec2(5.));\n    vec2 tix = floor(ts/5.);\n    tts+=-floor(hash22(tix*111.185+23.43)*3.95);\n    float tva = step(abs(tts.x-0.5),1.)*step(abs(tts.y-0.5),1.);\n    box_tv+= 1.*tva;\n    sfi+= vec4(-tts,vec2(1.))*tva;\n    tm+=vec2(-1.,-0.5)*tva;\n    \n    vec2 tv_frame_sz = box_tv*vec2(0.45, 0.27);\n    vec3 box_sz = vec3(box_tv);\n    float tv_sz = box_tv*0.4;\n    float tv_s_p = box_tv*0.05;\n\n    bool ft_bx = false;\n    vec2 ls_bx = vec2(1.395,1.435);\n\n    float ls_sc = box_tv*0.0451;\n    float ls_es = ls_sc*0.0;\n    vec2 tv_s_szsc2 = vec2(.95,.95);\n    float tv2_sh = box_tv*0.1214;\n    float el_1_sc = 0.7;\n    \n\n    vec3 box_pos_local = vec3(-box_tv*0.5+-box_tv*0.025*(1.-tva),vec2(0.5,0.5)+vec2(0.5,0.5)*ts*2.+sfi.xy*1.+0.5*sfi.zw);\n    \n    \n    // to use replace in VoxelsIntersect vec3 k = rda*vec3(.5, tps, .5); to vec3 k = rda*vec3(.5, 30.+tps, .5);\n    /*\n    box_pos_local.x+=0.5*ts.y;\n    //vec2 tts2 = ts;\n    tts.y=4.*sin(timer*1.+tts.y*.133);\n    box_pos_local.x+=0.5*tts.y;\n    box_pos_local.x+=0.5*length(tts.xy);\n    */\n    \n    bool ab = boxAABB(box_sz*0.5+vec3(tv_s_p*1.25,0.,0.)+0.01, ro-box_pos_local+vec3(-tv_s_p*1.25,0.,0.), rd);\n    //bool ab = true;\n    if(ab){\n        const float rb = 0.0135;\n        RoundedBoxIntersectMin_mod_tv(ts, vec4(box_tv,tv_frame_sz,el_1_sc), ro, rd, box_sz*0.5-rb, box_pos_local, rb, result, hit);\n#ifdef SHOW_ab\nhit.color=vec4(vec3(0.),1.);\nresult = result||ab;\n#endif\n        \n        vec3 esr_s = vec3(box_tv*0.25,tv_frame_sz.x-(box_tv*0.5-tv_frame_sz.y)*0.5+0.5*(box_tv*0.5-tv_frame_sz.x),tv_frame_sz.x);\n        bool ab_s = boxAABB(esr_s+vec3(tv_s_p*1.25,0.,0.)+0.01, ro-box_pos_local+vec3(-tv_s_p*1.25,0.,0.)+-vec3(esr_s.x,-tv_frame_sz.y*0.5+0.5*tv_frame_sz.x,0.), rd);\n        if(ab_s){\n            BoxIntersectMin_minimal_inv_tv(ro, rd, esr_s*2., box_pos_local+vec3(esr_s.x,-tv_frame_sz.y*0.5+0.5*tv_frame_sz.x,0.), result, hit, ch2, ires, tix*tva+ts*(1.-tva), tva>0.5, timer);\n            Rounded2Intersect_iSphere4Min_tv(tix*tva+ts*(1.-tva), tva>0.5, ro, rd, box_pos_local+vec3(box_tv*0.5-tv_sz+tv_s_p,-tv_frame_sz.y*0.5+0.5*tv_frame_sz.x,0.), tv_sz, result, hit, ch, ch2, timer);\n            {\n                vec3 es = vec3(ls_sc,ls_bx.x*((tv_frame_sz.x-(box_tv*0.5-tv_frame_sz.y)*0.5+0.5*(box_tv*0.5-tv_frame_sz.x))+float(ft_bx)*(box_tv*0.5-tv_frame_sz.x)),ls_bx.y*(tv_frame_sz.x+float(ft_bx)*(box_tv*0.5-tv_frame_sz.x)));\n                vec3 ep = box_pos_local+vec3(box_tv*0.5+ls_es,-tv_frame_sz.y*0.5+0.5*tv_frame_sz.x,0.);\n                eliIntersectMin_inv_mod_tv(vec4(box_tv,tv_frame_sz,ls_es), ep, es, ro, rd, result, hit, OBJ_BOX, ch2, ires, tix*tva+ts*(1.-tva), tva>0.5, timer);\n            }\n#ifdef SHOW_ab\nhit.color=vec4(vec3(0.,0.,1.),1.);\nresult = result||ab_s;\n#endif\n        }\n        \n        vec3 esr_bp = box_pos_local+vec3(box_tv*0.5, -(box_tv*0.25+tv_frame_sz.y*0.5), 0.);\n        bool ab_d = boxAABB(vec3((box_tv*0.5-tv_frame_sz.y)*0.5*el_1_sc,(box_tv*0.5-tv_frame_sz.y)*0.5*el_1_sc,tv_frame_sz.x)+0.01, ro-esr_bp, rd);\n        if(ab_d){\n            CylinderIntersectMin(ro.xzy, rd.xzy, (box_tv*0.5-tv_frame_sz.y)*0.5*el_1_sc, tv_frame_sz.x, esr_bp.xzy, result, hit, tix*tva+ts*(1.-tva), timer, tva>0.5);\n\n            BoxIntersectMin_minimal_inv_tv_a1(tm, ro, rd, vec3(0.0051, 0.001+(box_tv*0.5-tv_frame_sz.y)*el_1_sc, 0.001+2.*tv_frame_sz.x), esr_bp-vec3(0.5*0.0051,0.,0.), result, hit);\n            \n            RayTracing_Domain_RepetitionMin(ro, esr_bp+vec3(-0.01,0.,0.), rd, result, hit, (25.+tm.x*25.)*1.5, (1.+(1.-tm.x)*0.9)/1.5*0.0082, vec2(0.012,-0.0+(box_tv*0.5-tv_frame_sz.y)*0.5*el_1_sc));\n#ifdef SHOW_ab\nhit.color=vec4(vec3(0.,1.,0.),1.);\nresult = result||ab_d;\n#endif\n        }\n    }\n}\n\n\n\nfloat heightField(vec2 uv)\n{\n    //return hash21u(uv);\n    return 0.5;\n}\n\n// ffix float precision fix, fix reflections 0.0001 main, -0.0009 refl\nbool VoxelsIntersect(int steps, float max_h, float ffix, in vec3 ro, in vec3 rd, out vec3 normal , out float tnew, out vec2 idx, out vec3 col, sampler2D ch, sampler2D ch2, float timer, vec2 ires) {\n    col = vec3(0.);\n    vec2 pos = floor(ro.xz);\n    rd += 0.0001 * (1.0 - abs(sign(rd)));\n    vec3 rdi = 1./rd;\n\n    vec3 rda = abs(rdi);\n    vec3 rds = sign(rd);\n    vec2 dis = (pos - ro.xz + .5 + rds.xz*.5) * rdi.xz;\n    \n    vec3 roi = rdi*(ro-vec3(.5,0.,.5));\n\n    vec2 mm = vec2(0.0);\n    for( int i=0; i<steps; i++ ) {    \n        float tm=1.;\n        float tps = -0.00099+max(heightField(pos),0.001)*max_h*tm;\n        vec3 n = roi - rdi * vec3(pos.x, tps-1., pos.y);\n        \n        vec3 k = rda*vec3(.5, tps, .5);\n\n        vec3 t1 = -n - k;\n        vec3 t2 = -n + k;\n\n        float tN = max( max( t1.x, t1.y ), t1.z )-ffix;\n        float tF = min( min( t2.x, t2.y ), t2.z );\n\n        if ( tN < tF && tN>MIN_DIST && tN<MAX_DIST ) {\n            \n            bool tresult = false;\n            HitInfo thit;\n            thit.color=vec4(0.);\n            thit.t = MAX_DIST;\n            thit.obj_type = OBJ_SKY;\n            TVIntersectMin(max_h, pos, ro.yxz, rd.yxz, tresult, thit, ch, ch2, timer, ires);\n            if(tresult){\n                normal = thit.norm;\n                tnew = thit.t;\n                idx = pos;\n                col = thit.color.rgb;\n                return true;\n            }\n        }\n\n    mm = step( dis.xy, dis.yx ); \n    dis += mm*rda.xz;\n    pos += mm*rds.xz;\n    }\n\n    return false;\n}\n\nvoid VoxelsIntersectMin(vec3 ro, vec3 rd, inout bool result, inout HitInfo hit, sampler2D ch, sampler2D ch2, float timer, vec2 ires) {\n    \n    float tnew;\n    vec2 idx;\n    vec3 normnew;\n    float ref = 1.;\n    float vros = length(ro.xz);\n    //box_tv+tv_s_p*1.25\n    vec3 tcol;\n    if(VoxelsIntersect(25, 1.1, 0.0001, ro, rd, normnew, tnew, idx, tcol, ch, ch2, timer, ires)){\n        if (tnew < hit.t) {\n            hit.color = vec4(tcol,1.);\n            //hit.color = vec4(normnew,1.);\n            hit.obj_type = OBJ_BOX;\n            result = true;\n            hit.t = tnew;\n            hit.norm = normnew;\n        }\n    }\n}\n\n\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvoid halton_loop(inout vec2 s, inout vec4 a){\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    a.xy = a.xy/coprimes;\n    a.zw += a.xy*mod(s, coprimes);\n    s = floor(s/coprimes);\n}\nvec2 halton(int index){\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    return a.zw;\n}\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n\n\n// mix of two+1 my shaders - texture\n// https://www.shadertoy.com/view/sldGDf\n// https://www.shadertoy.com/view/DlByW1\n// https://www.shadertoy.com/view/4tKczz\n\n\n// this shader reveal new AMD bug\n// https://gitlab.freedesktop.org/mesa/mesa/-/issues/11683\n// https://github.com/danilw/GPU-my-list-of-bugs\n \n\nvoid mainImage_col2( out vec4 fragColor, in vec2 fragCoord );\nvoid mainImage_col1( out vec4 fragColor, in vec2 fragCoord );\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    mainImage_col1(fragColor, fragCoord);\n    float ta = fragColor.r;\n    mainImage_col2(fragColor, fragCoord);\n    fragColor.a = ta;\n}\n\n\n\n\n// modified https://www.shadertoy.com/view/DlByW1\n//-----------------------------\n\n// Created by Danil (2023+) https://cohost.org/arugl\n\n// License - CC0 or use as you wish\n\n// self https://www.shadertoy.com/view/DlByW1\n\n\n#define local_iTime (iTime*2.25)\n\n\n// using FabriceNeyret2 runes (simplified version) \n// https://www.shadertoy.com/view/4ltyDM\n\n//--------------------------------------\n\n// --- glyphs simplified from \"runes\" by otaviogood. \n// https://shadertoy.com/view/MsXSRn - original is CC0\n\nfloat line(vec2 p, vec2 a,vec2 b) {\n    p -= a, b -= a;\n\tfloat h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n\treturn length(p - b * h);\n}\n/*\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}*/\n\nfloat Rune(vec2 U, vec2 seed, float px)\n{\n\tfloat d = 1e5;\n    float h = hash12(seed.xy*33.);\n    int rn = int(h*h*h*6.);\n    for (int i = 0; i < 1+rn; i++)\n    {\n        vec4 pos = vec4(hash22(seed).xy,hash22(seed+1.).xy );\n        seed += 2.;\n        pos = fract(pos * 128.);\n        if (i == 0) pos.y = .0;\n        if (i == 1) pos.x = .999;\n        if (i == 2) pos.x = .0;\n        if (i == 3) pos.y = .999;\n        vec4 snaps = vec4(2, 3, 2, 3);\n        pos = ( floor(pos * snaps) + .5) / snaps;\t\n        d = min(d, line(U, pos.xy, pos.zw + .001) );\n    }\n\treturn 1.-smoothstep(40./360.-px,40./360.,d);\n}\n//--------------------------------------\n\n\n\n\n\n\n\n// right top\n\n//--------------------------------------\n// from my old shader https://www.shadertoy.com/view/4lKyDd\n// updated Fabrice version\n\n\n\n\n\nvoid mainImage_col3(out vec4 fragColor, in vec2 fragCoord);\nvoid mainImage_lt( out vec4 fragColor, in vec2 fragCoord, float ts);\nvoid mainImage_rt(out vec4 O,vec2 u){\n    //mainImage_lt(O, u, 235.);\n    mainImage_col3(O, u);\n\n}\n\n\n\n\n/*\nvoid mainImage_rt(out vec4 O,vec2 u){\n    O=vec4(0.);\n    vec2 T =  1./vec2(62.5,31.),\n         R = iResolution.xy,\n         U = (u -.5*R) / R.y,\n         p = mod( U-T/2., T) - T/2.,\n         r = R / R.y, c=r/T;\n    float t = local_iTime*4.+14.;\n    int x = int(c),\n        i = int( t*8. + 3.5*( cos(t/1.5) - cos(t) ) ) % ( x*int(c.y) );\n    r = vec2( i%x, i/x ) - ceil( (r/2. + vec2(U.x,-U.y) ) / T );\n    r.y>0. || r.y==0. && r.x>0.\n       ? O += 1. - ( .98 < fract(1e4*sin(dot(ceil(U/T-.5),vec2(591,154))))\n                        ? p = abs(p), max( max(p.x,p.y)-.0051, min(p.x,p.y) )\n                        : length(p+T*vec2(0.,.25)) - .001\n                   ) / .003\n       : O;\n}*/\n//--------------------------------------\n\n\n\n\n\n// left bot\n\n//--------------------------------------\n\nvoid mainImage_lb( out vec4 fragColor, in vec2 fragCoord)\n{\n\n    vec2 res=iResolution.xy/iResolution.xy;\n    vec2 uv=fragCoord/iResolution.xy-0.5*res;\n    \n    float px = 1.5/iResolution.y;\n    vec4 c=vec4(0.);\n    \n    float sc = 25.;\n    vec2 tuv = (uv+res*0.5)*sc;\n    vec2 lid = floor(tuv);\n    vec2 alid = floor(res*sc);\n    vec2 olid = lid;\n    tuv = fract(tuv)-0.5;\n    \n    float t = (local_iTime*5.+178.)*0.1+22.51;\n    float x = step(tuv.y+0.35,0.)*step(0.,abs(tuv.x+0.5)-0.15);\n    x*=step(fract(t*9.85+(lid.x-lid.y+alid.y*2.)*0.33),(olid.y<0.5?0.65:0.25)-0.15*sin(lid.x*5.35));\n    float ttl = t + .4*(cos(t/1.5) - cos(t));\n    lid.y=-lid.y+2.*alid.y;\n    lid.y+=floor(ttl);\n    ttl = fract(ttl);\n    float s = 0.;\n    float r = smoothstep(0.,px*sc,length(tuv)-0.35);\n    float vid = mod(lid.y,12.);\n    if(vid>0.5){\n        vec2 lp = tuv;\n        s = 1.-max(smoothstep(0.,px*sc,min(abs(lp.y)*1.75, abs(-abs(lp.y)+abs(lp.x*1.5)))-0.065),r);\n        bool ra = cos(lid.x*0.15)>-0.75;\n        bool rb = !ra&&cos(lid.x*1.5)>-0.95&&floor(mod(lid.y,4.))!=0.;\n        bool rc = ra&&cos(lid.x*0.22)<-0.05&&cos(lid.x*4.80)>-0.0&&sin(lid.y*0.57+lid.x*0.33)<-0.05;\n        float h = hash12(lid.xy*33.);\n        ra=ra&&(vid>=mod(lid.x+1.,15.)*4.||mod(lid.x-15.,30.)>4.)&&floor(mod(lid.y,4.))==1.+floor(mod(lid.y,12.)/4.);\n        vec2 tid = lid;\n        if(rb){\n            tid.y = floor(mod(tid.y/1.65,3.))+10.*floor((tid.y/3.));\n            bool rb1 = cos(lid.x*1.5)>0.75;\n            if(rb1){\n                tid.y += 33.*(1.-abs(sign(floor(mod(lid.y,4.))-2.)));\n            }\n        }\n        bool rg = ra||rb||rc;\n        s = (lid.x>1.&&lid.x<13.)?s*step(lid.x-1.,vid):((lid.x>0.&&lid.x<14.)?\n            (1.-r)*step(abs(lp.x)-0.065,0.)+step(sign(lid.x-5.)*lp.x-0.065,0.)*step(abs(lp.x)-0.065*3.,0.)*step(abs(abs(lp.y)-0.5+0.065*2.)-0.065,0.):\n            (rg?Rune(lp+0.5, tid, 1./200.*sc):0.));\n        if(olid.y==1.&&lid.x>13.&&rg){float tdx=(alid.x+13.)*smoothstep(0.,.8,ttl);s=mix(x*(step(olid.x-3.,max(13.,tdx))),s,step(olid.x,tdx));}\n        else if(olid.y==0.){float tx=floor(14.*smoothstep(.4+0.15*sin(lid.y*2.33),.6,ttl*ttl));s=lid.x==tx?x:(lid.x<14.?s*step(lid.x,tx):0.);}\n    }else{\n        s = 1.-max(smoothstep(0.,px*sc,abs(abs(tuv.y)+tuv.x)-0.065),r);\n        if(olid.y<0.5)s*=step(0.55,ttl);\n        vec2 tid = lid;\n        tid.y=tid.y*step((sin(tid.x*0.15)+2.*cos(tid.x*0.75)),0.);\n        bool ra = step(tid.x,8.)>0.5;\n        bool rb = step(10.,tid.x)*step(tid.x,12.+mod(lid.y,7.))>0.5;\n        bool rg = ra||rb;\n        s=lid.x>0.5?(rg?Rune(tuv+0.5, tid, 1./200.*sc):0.):s;\n        if(olid.y<0.5){float ttl=rg||ttl<0.65?smoothstep(.3,.65,ttl*ttl):((alid.x-2.)/alid.x);float ts=step(olid.x,alid.x*ttl);s=(s*ts+step(0.01,ttl)*x*(1.-ts)*step(olid.x-1.,alid.x*ttl));}\n    }\n    s*=step(72.,lid.y);\n    c=vec4(clamp(s,0.,0.88));\n    \n    fragColor = vec4(c.rgb,1.0);\n}\n//--------------------------------------\n\n\n\n\n//left top\n\n//--------------------------------------\n// Rune reused from above\n\nvoid mainImage_lt( out vec4 fragColor, in vec2 fragCoord, float ts)\n{\n\n    vec2 res=iResolution.xy/iResolution.y;\n    vec2 uv=fragCoord/iResolution.y-0.5*res;\n    \n    float px = 1.5/iResolution.y;\n    vec4 c=vec4(0.);\n    \n    float sc = 25.;\n    vec2 tuv = (uv+res*0.5)*sc;\n    vec2 lid = floor(tuv);\n    vec2 alid = floor(res*sc);\n    vec2 olid = lid;\n    tuv = fract(tuv)-0.5;\n    \n    float s = 0.;\n    float r = smoothstep(0.,px*sc,length(tuv)-0.35);\n    \n    float t = (local_iTime+ts+178.)*0.075+0.005;\n    float x = step(tuv.y+0.35,0.)*step(0.,abs(tuv.x+0.5)-0.15);\n    float l = step(abs(tuv.x)-0.075,0.)*(1.-r);\n    x*=step(fract(t*17.85+(lid.x-lid.y+alid.y*2.)*0.33),(olid.y<0.5?0.65:0.25)-0.15*sin(lid.x*5.35));\n    \n    float ttl = t + .4*(cos(t/1.5) - cos(t));\n    lid.y=-lid.y+2.*alid.y;\n    lid.y+=25.+26.*floor(ttl/5.);\n    ttl = fract(ttl/5.);\n    \n    vec2 lp = tuv;\n    float ra = step(lid.x,0.)*step(25.,mod(lid.y,26.));\n    s = ra*(1.-max(smoothstep(0.,px*sc,abs(abs(lp.y)+lp.x)-0.065),r));\n    float a = cos(lid.x*2.25+lid.y*11.33);\n    float b = sin((lid.x*.025+16.*sin(lid.y*.33)));\n    float rb = (1.-ra)*step(0.5,0.5+(0.5*a+0.5*b)+b*3.*sin(lid.y*.33));\n    b = sin(lid.x*.25+0.6);\n    ra=(1.-ra)*step(0.5,0.5+0.5*a+0.6*b)*step(lid.x,18.)*step(25.,mod(lid.y,26.));\n    \n    float rc=step(mod(lid.y,26.),4.)*(1.-step(4.,mod(lid.y,26.))*step(9./alid.x,abs(lid.x/alid.x-0.5)));\n    rb*=(1.-rc)*step(mod(lid.y,26.),17.);\n    \n    rc*=step(abs(lid.x/alid.x-0.5),7./alid.x);\n    \n    float rd = (1.-rc)*step(abs(lid.x/alid.x-0.5),8./alid.x)*step(mod(lid.y,26.),4.);\n    rc*=1.-step(abs(lid.x-alid.x*0.5)-2.*abs(mod(lid.y+6.,26.)-8.),0.);\n    \n    vec2 tid = lid;\n    \n    lp.x=mix(lp.x,-lp.x,step(tid.x-alid.x*0.5,0.));\n    tid=mix(tid,vec2(abs(tid.x-alid.x*0.5),floor(tid.y/6.)),rc);\n    s += mix(Rune(lp+0.5, tid, 1./200.*sc)*(rb+ra+rc),l,rd);\n    \n    \n    ra = step(lid.x,2.);\n    rb = (1.-ra)*step(lid.x,3.)+step(lid.x,25.)*step(25.,lid.x);\n    rc = step(26.,lid.x);\n    rd = (1.-step(mod(lid.y,26.),17.))*step(mod(lid.y,26.),24.);\n\n    float trb = rb;\n    float trd = rd;\n    float tra = ra;\n    float xs = step(abs(lp.x),0.45)*step(abs(lp.y),0.45)*(1.-(step(lid.x,3.)+step(25.,lid.x)));\n    \n    ra = step(0.03,ttl);\n    float tlp = 0.4*smoothstep(0.3,0.35,ttl)+0.3*smoothstep(0.05,0.056,ttl)+0.2*smoothstep(0.1,0.13,ttl)+0.1*smoothstep(0.2,0.27,ttl);\n    float tlx = smoothstep(0.37,0.995,ttl);\n    s*=step(mod(lid.y+1.,26.),floor(tlp*18.));\n    \n    rb = step(ttl,0.03);\n    rc = step(mod(lid.y,26.),23.);\n    s*=max(rc,step(lid.x,floor(smoothstep(0.,0.03,ttl)*16.)));\n    s+=(1.-rc)*rb*x*step(lid.x-1.,floor(smoothstep(0.,0.03,ttl)*16.))*step(floor(smoothstep(0.,0.03,ttl)*16.),lid.x-1.);\n    \n    rd = step(mod(lid.y+1.,26.),floor(tlp*18.)+floor(tlx*6.));\n    rc = step(mod(lid.y+2.,26.),floor(tlp*18.)+floor(tlx*6.));\n    \n    tid = lid;\n    tid.y = mix(tid.y,mix(min(4.,floor(fract(tlx*6.)*11.))/4.,1.,rc),tra);\n    float os = mix(Rune(lp+0.5, tid, 1./200.*sc)*(tra+step(27.,lid.x)*step(-0.5,sin(lid.x*1.25)))*trd,l*trd,trb);\n    s+=os*rd;\n    s+=xs*step(lid.x-3.,mix(fract(tlx*6.)*50.,50.,rc))*rd*step(19.,mod(lid.y+1.,26.));\n    s*=1.-step(mod(lid.y,26.),24.)*step(23.,mod(lid.y,26.));\n    s+=ra*x*step(lid.x,0.)*step(mod(lid.y,26.),floor(tlp*18.)+floor(tlx*6.))*step(floor(tlp*18.)+floor(tlx*6.),mod(lid.y,26.));\n    \n    c=vec4(clamp(s,0.,0.88));\n    \n    fragColor = vec4(c.rgb,1.0);\n}\n//--------------------------------------\n\n\n\n\n//right bot\n\n//--------------------------------------\n// Rune reused from above\n\n\nvoid mainImage_rb( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 res=iResolution.xy/iResolution.xy;\n    vec2 uv=fragCoord/iResolution.xy-0.5*res;\n    \n    float px = 1.5/iResolution.y;\n    vec4 c=vec4(0.);\n    \n    float sc = 25.;\n    vec2 tuv = (uv+res*0.5)*sc;\n    vec2 lid = floor(tuv);\n    vec2 alid = floor(res*sc);\n    vec2 olid = lid;\n    tuv = fract(tuv)-0.5;\n    \n    float s = 0.;\n    float r = smoothstep(0.,px*sc,length(tuv)-0.35);\n    \n    float t = (local_iTime*3.5+178.)*0.24+22.51;\n    float x = step(tuv.y+0.35,0.)*step(0.,abs(tuv.x+0.5)-0.15);\n    x*=step(fract(t*4.85+(lid.x-lid.y+alid.y*2.)*0.33),(olid.y<0.5?0.65:0.25)-0.15*sin(lid.x*5.35));\n    float ttl = t + .4*(cos(t/1.5) - cos(t));\n    lid.y=-lid.y+2.*alid.y;\n    lid.y+=floor(ttl);\n    ttl = fract(ttl);\n    \n    float l = (1.-r)*step(abs(tuv.x)-0.065,0.)+step(sign(lid.x-1.)*tuv.x-0.065,0.)*step(abs(tuv.x)-0.065*3.,0.)*step(abs(abs(tuv.y)-0.5+0.065*2.)-0.065,0.);\n    \n    float ra = (step(lid.x,0.)+step(3.,lid.x)*step(lid.x,3.));\n    float rb = (step(1.,lid.x)*step(lid.x,3.));\n    float rc = step(1.,olid.y);\n    \n    s=l*ra;\n    \n    vec2 tid = lid;\n    tid.y = mix(tid.y,mod(tid.y*5.,20.),rb);\n    s+=Rune(tuv+0.5, tid, 1./200.*sc)*(1.-ra)*step((tid.x+30.*(0.5+0.5*sin(tid.y*2.33))),alid.x);\n    \n    s*=step(72.,lid.y)*rc*max(step(2.,olid.y),step(lid.x,3.+alid.x*step(0.015,ttl*ttl)));\n    s+=x*step(lid.x,0.)*(1.-rc);\n    \n    c=vec4(clamp(s,0.,0.88));\n    \n    fragColor = vec4(c.rgb,1.0);\n}\n\n\n//--------------------------------------\n\n\n\nvoid mainImage_col1( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    ivec2 tid = ivec2(uv*2.);\n    \n    float m = 2.;\n    /*if(iMouse.z>0.){\n        m=1.;\n        tid = ivec2(iMouse.xy/iResolution.xy*2.);\n    }*/\n    \n    if(tid==ivec2(0,0)){mainImage_lb(fragColor, fract(uv*m)*iResolution.xy);}\n    \n    else{if(tid==ivec2(0,1)){mainImage_lt(fragColor, fract(uv*m)*iResolution.xy, 0.);}\n    else{if(tid==ivec2(1,0)){mainImage_rb(fragColor, fract(uv*m)*iResolution.xy);}\n    else mainImage_rt(fragColor, fract(uv*m)*iResolution.xy);}\n    }\n    \n    fragColor.a = 1.;\n    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n// modified https://www.shadertoy.com/view/sldGDf\n//-----------------------------\n\n\n// Created by Danil (2021+) https://cohost.org/arugl\n\n// License - CC0 or use as you wish\n\n\n\n// using MIT License code\n// using https://www.shadertoy.com/view/wtXfRH\n// using https://www.shadertoy.com/view/ll2GD3\n\n\n#define SS(x, y, z) smoothstep(x, y, z)\n#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\n// divx is number of lines on background\n//#define divx floor(iResolution.y/15.)\n\nconst float divx = 25.;\n#define polar_line_scale (2./divx)\n\nconst float zoom_nise = 5.;\n\n\n// Common code moved for Cineshader support\n//-------------Common code\n\n// using MIT License code\n// using https://www.shadertoy.com/view/wtXfRH\n// using https://www.shadertoy.com/view/ll2GD3\n\nmat3 rotx(float a){float s = sin(a);float c = cos(a);return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, c, s), vec3(0.0, -s, c));  }\nmat3 roty(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, 0.0, s), vec3(0.0, 1.0, 0.0), vec3(-s, 0.0, c));}\nmat3 rotz(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, s, 0.0), vec3(-s, c, 0.0), vec3(0.0, 0.0, 1.0 ));}\n\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\n\nfloat fbm( in vec2 p )\n{\n    p*=0.25;\n    float s = 0.5;\n    float f = 0.0;\n    for( int i=0; i<4; i++ )\n    {\n        f += s*noise(p);\n        s *= 0.8;\n        p = 2.01*mat2(0.8,0.6,-0.6,0.8)*p;\n    }\n    return 0.5+0.5*f;\n}\n\nvec2 ToPolar(vec2 v)\n{\n    return vec2(atan(v.y, v.x)/3.1415926, length(v));\n}\n\n// fwidth removed because AMD bug\n// bug https://www.shadertoy.com/view/MfsBz8\n// https://gitlab.freedesktop.org/mesa/mesa/-/issues/11683\nvec3 fcos( vec3 x )\n{\nreturn cos(x);\n/*\n    vec3 w = fwidth(x);\n    return cos(x) * smoothstep(3.14*2.0,0.0,w);\n*/\n}\n\n\nvec3 getColor( in float t )\n{\n    vec3 col = vec3(0.3,0.4,0.5);\n    col += 0.12*fcos(6.28318*t*  1.0+vec3(0.0,0.8,1.1));\n    col += 0.11*fcos(6.28318*t*  3.1+vec3(0.3,0.4,0.1));\n    col += 0.10*fcos(6.28318*t*  5.1+vec3(0.1,0.7,1.1));\n    col += 0.10*fcos(6.28318*t* 17.1+vec3(0.2,0.6,0.7));\n    col += 0.10*fcos(6.28318*t* 31.1+vec3(0.1,0.6,0.7));\n    col += 0.10*fcos(6.28318*t* 65.1+vec3(0.0,0.5,0.8));\n    col += 0.10*fcos(6.28318*t*115.1+vec3(0.1,0.4,0.7));\n    col += 0.10*fcos(6.28318*t*265.1+vec3(1.1,1.4,2.7));\n    return col;\n}\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//----------end of Common\n\nvec3 get_noise(vec2 p,float timer){\n    vec2 res = iResolution.xy/iResolution.y;\n    vec2 shiftx= res*0.5*1.25+.5*(0.5+0.5*vec2(sin(0.01*timer*0.0851),cos(0.01*timer*0.0851)));\n    vec2 shiftx2= res*0.5*2.+.5*(0.5+0.5*vec2(sin(timer*0.0851),cos(timer*0.0851)));\n    vec2 tp = p + shiftx;\n    float atx = (atan(tp.x+0.0001*(1.-abs(sign(tp.x))),tp.y)/3.141592653)*.5+fract(timer*0.0125);\n    vec2 puv = ToPolar(tp);\n    puv.y+=atx;\n    puv.x*=0.5;\n    vec2 tuv = puv*divx;\n    float idx = mod(floor(tuv.y),divx)+200.;\n    puv.y=fract(puv.y);\n    puv.x=abs(fract(puv.x/divx)-0.5)*divx; // mirror seamless noise\n    puv.x+=-.5*timer*(0.075-0.0025*max((min(idx,16.)+2.*sin(idx/5.)),0.));\n    return vec3(SS(0.43,0.73,fbm(((p*0.5+shiftx2)*MD(-timer*0.013951*10./zoom_nise))*zoom_nise*2.+vec2(4.+2.*idx))),SS(0.543,0.73,fbm(((p*0.5+shiftx2)*MD(timer*0.02751*10./zoom_nise))*zoom_nise*1.4+vec2(4.+2.*idx))),fbm(vec2(4.+2.*idx)*puv*zoom_nise/100.));\n}\n\nvec4 get_lines_color(vec2 p, vec3 n, float timer){\n    vec2 res = iResolution.xy/iResolution.y;\n    \n    vec3 col= vec3(0.);\n    float a = 1.;\n    \n    vec2 shiftx= res*0.5*1.25+.5*(0.5+0.5*vec2(sin(0.01*timer*0.0851),cos(0.01*timer*0.0851)));\n    vec2 tp = p + shiftx;\n    float atx = (atan(tp.x+0.0001*(1.-abs(sign(tp.x))),tp.y)/3.141592653)*(0.5)+fract(timer*0.0125);\n    vec2 puv = ToPolar(tp);\n    puv.y+=atx;\n    puv.x*=0.5;\n    vec2 tuv = puv*divx;\n    float idx = mod(floor(tuv.y),divx)+1.;\n    \n    \n    // thin lines\n    float d = length(tp);\n    d+=atx;\n    float v = sin(3.141592653*2.*divx*0.5*d+0.5*3.141592653);\n    float fv =fwidth(v);\n    fv+=0.0001*(1.-abs(sign(fv)));\n    d = 1.-SS(-1.,1., .3*abs(v)/fv);\n    \n    float d2 = 1.-SS(0., 0.473, abs(fract(tuv.y)-0.5));\n    tuv.x+=3.5*timer*(0.01+divx/200.)-0.435*idx;\n    \n    // lines\n    tuv.x=abs(fract(tuv.x/divx)-0.5)*divx;\n    float ld = SS(0.1,.9,(fract(polar_line_scale*tuv.x*max(idx,1.)/10.+idx/3.)))*(1.-SS(0.98,1.,(fract(polar_line_scale*tuv.x*max(idx,1.)/10.+idx/3.))));\n    \n    tuv.x+=1.*timer*(0.01+divx/200.)-01.135*idx;\n    ld *= 1.-SS(0.1,.9,(fract(polar_line_scale*tuv.x*max(idx,1.)/10.+idx/6.5)))*(1.-SS(0.98,1.,(fract(polar_line_scale*tuv.x*max(idx,1.)/10.+idx/6.5))));\n    \n    float ld2 = .1/(max(abs(fract(tuv.y)-0.5)*1.46,0.0001)+ld);\n    ld = .1/((max(abs(fract(tuv.y)-0.5)*1.46,0.0001)+ld)*(2.5-(n.y+1.*max(n.y,n.z))));\n\n    \n    ld=min(ld,13.);\n    ld*=SS(0.0,0.15,0.5-abs(fract(tuv.y)-0.5));\n    \n    // noise\n    d*=n.z*n.z*2.;\n    float d3=(d*n.x*n.y+d*n.y*n.y+(d2*ld2+d2*ld*n.z*n.z));\n    d=(d*n.x*n.y+d*n.y*n.y+(d2*ld+d2*ld*n.z*n.z));\n    \n    a=clamp(d,0.,1.);\n    \n    \n    puv.y=mix(fract(puv.y),fract(puv.y+0.5),SS(0.,0.1,abs(fract(puv.y)-0.5)));\n    col = getColor( .54*length(puv.y) );\n    \n    col = 3.5*a*col*col+2.*(mix(col.bgr,col.grb,0.5+0.5*sin(timer*0.1))-col*0.5)*col;\n    \n    d3=min(d3,4.);\n    d3*=(d3*n.y-(n.y*n.x*n.z));\n    d3*=n.y/max(n.z+n.x,0.001);\n    d3=max(d3,0.);\n    vec3 col2 = .5*d3*vec3(0.3,0.7,0.98);\n    col2=clamp(col2,0.,2.);\n    \n    col=col2*0.5*(0.5-0.5*cos((2.88*2.)))+mix(col,col2,0.45+0.45*cos((2.88*2.)));\n    \n    col=clamp(col,0.,1.);\n    \n    //col=vec3(ld);\n    \n    return vec4(col,a);\n}\n\nvec4 planet(vec3 ro, vec3 rd, float timer, out float cineshader_alpha)\n{   \n    vec3 lgt = vec3(-.523, .41, -.747);\n    float sd= clamp(dot(lgt, rd)*0.5+0.5,0.,1.);\n    float far = 400.;\n    float dtp = 13.-(ro + rd*(far)).y*3.5;\n    float hori = (linearstep(-1900., 0.0, dtp) - linearstep(11., 700., dtp))*1.;\n    hori *= pow(abs(sd),.04);\n    hori=abs(hori);\n    \n    vec3 col = vec3(0);\n    col += pow(hori, 200.)*vec3(0.3, 0.7,  1.0)*3.;\n    col += pow(hori, 25.)* vec3(0.5, 0.5,  1.0)*.5;\n    col += pow(hori, 7.)* pal( timer*0.48*0.1, vec3(0.8,0.5,0.04),vec3(0.3,0.04,0.82),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) )*1.;\n    col=clamp(col,0.,1.);\n    \n    float t = mod(timer,15.);\n    float t2 = mod(timer+7.5,15.);\n    float td = .071*dtp/far+5.1;\n    float td2 = .1051*dtp/far+t*.00715+.025;\n    float td3 = .1051*dtp/far+t2*.00715+.025;\n    vec3 c1=getColor(td);\n    vec3 c2=getColor(td2);\n    vec3 c3=getColor(td3);\n    c2=mix(c2,c3.bbr,abs(t-7.5)/7.5);\n\n    c2=clamp(c2,0.0001,1.);\n    \n    col+=sd*hori*clamp((c1/(2.*c2)),0.0,3.)*SS(0.,50.,dtp);\n    col=clamp(col,0.,1.);\n    \n    float a=1.;\n    a=(0.15+.95*(1.-sd))*hori*(1.-SS(.0,25.,dtp));\n    a=clamp(a,0.,1.);\n    \n    hori = mix(linearstep(-1900., 0.0, dtp), 1. - linearstep(11., 700., dtp), sd);\n    cineshader_alpha=1.-pow(hori,3.5);\n\n    return vec4(col,a);\n}\n\nvec3 cam(vec2 uv, float timer)\n{\n    //vec2 res = (ires.xy / ires.y);\n    //vec2 im = (mouse.xy) / ires.y - res/2.0;\n    timer*=0.48;\n    vec2 im = vec2(cos(mod(timer,3.1415926)),-0.02+0.06*cos(timer*0.17));\n    im*=3.14159263;\n    im.y = -im.y;\n    \n    float fov = 90.;\n    float aspect = 1.;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.14159263 / 180.0)) / 2.0)));\n    vec3 rd = normalize(vec3(uv*screenSize, 1./aspect));\n    rd = (roty(-im.x) * rotx(im.y) * rotz(0.32*sin(timer*0.07))) * rd;\n    return rd;\n}\n\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    color = clamp(color, 0.0, 1.0);\n    return color;\n}\n\n\nvoid mainImage_col2( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n   \n    vec4 ttimers = vec4(80.7,11.,289.,161.);\n    vec4 ttimers2 = vec4(.865);\n    vec4 ttimers3 = vec4(2.05,2.75,4.,1.75);\n    \n    vec2 res = iResolution.xy/iResolution.xy;\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    int ix = int(uv.x*2.)+2*int(uv.y*2.);\n    uv=fract(uv*2.)-0.5*res;\n    float timer = floor(iTime*ttimers3[ix])/ttimers3[ix];\n    vec3 noisev = get_noise(uv, timer*ttimers2[ix]+ttimers[ix]);\n\n    vec4 lcol = get_lines_color(uv, noisev, timer*ttimers2[ix]+ttimers[ix]);\n\n    //fragColor = vec4(lcol.rgba);\n\n    vec3 ro = vec3(1.,40.,1.);\n    vec3 rd = cam(uv, ttimers[ix]);\n    float cineshader_alpha;\n    vec4 planetc = planet(ro,rd,timer*ttimers2[ix]+ttimers[ix],cineshader_alpha);\n\n    vec3 col = lcol.rgb*planetc.a*0.75+0.5*lcol.rgb*min(12.*planetc.a,1.)+planetc.rgb;\n    col=clamp(col,0.,1.);\n    \n    fragColor = vec4(col*0.85+0.15*col*col,1.);\n    \n    // extra color correction\n    fragColor.rgb = fragColor.rgb*0.15+fragColor.rgb*fragColor.rgb*0.65+(fragColor.rgb*0.7+0.3)*ACESFitted(fragColor.rgb);\n    \n    fragColor.rgb = fragColor.rgb*0.15+2.5*fragColor.rgb*fragColor.rgb;\n    \n}\n\n\n\n\n\n\n// modified https://www.shadertoy.com/view/4tKczz\n//-----------------------------\n\n#define ltimer2 (iTime*0.85)\n\nfloat grid(vec2 uv, float res) {\n    uv.x = mod(uv.x, res);\n    float ret = smoothstep(res / 2. - res / 10., res / 2., abs(uv.x - res / 2.));\n    uv.y = mod(uv.y, res);\n    ret = max(ret, 0.72 * smoothstep(res / 2. - res / 5., res / 2., abs(uv.y - res / 2.)));\n    return ret;\n}\n\nconst float time_val = 14.; //animation time\nconst int layersxx = 4; //number of layers\n#define mod_loc(ffx) mod(ffx,time_val)\n\nvec2 layer(vec2 uv, float time, float zoom) {\n    float vsal = 0.5 * zoom;\n    float dv = mod_loc(time) + vsal;\n    float circle = 1. - smoothstep(0.497 * (dv - vsal), 0.5 * (dv - vsal), length(uv + vec2(0., vsal)));\n    return vec2(grid(uv / (dv / 2.), 0.1), circle);\n}\n\nfloat mi_o_y(vec2 uv, float zoom) {\n    uv *= zoom;\n    float layersx = float(layersxx);\n    vec2 layerax[layersxx];\n    //sorry I dont know how to make it simpler\n    for (int i = 0; i < layersxx; i++) {\n        layerax[clamp(i,0,layersxx-1)] = layer(uv, ltimer2 + time_val / layersx * float(i), zoom);\n    }\n    vec2 retl[layersxx];\n    for (int i = layersxx; i >= 0; i--) {\n        int itr = i + int(layersx * (mod_loc(ltimer2) / time_val));\n        if (itr >= layersxx)itr = (itr - layersxx);\n        retl[clamp(itr,0,layersxx-1)] = layerax[clamp(i,0,layersxx-1)];\n    }\n    float ret = 0.;\n    for (int i = layersxx; i >= 0; i--) {\n        ret = max(ret * (1. - retl[clamp(i,0,layersxx-1)].y), retl[clamp(i,0,layersxx-1)].x * retl[clamp(i,0,layersxx-1)].y);\n    }\n    return ret;\n}\n\nfloat mk(vec2 st) {\n    vec2 lines = vec2(1.0, 2.0);\n    float maxVlines = 4.0;\n    st.y += 0.5;\n    vec2 shift = vec2(mix(lines.x, maxVlines, st.y), lines.y);\n    st.y += -0.5;\n    st.x *= 9. / 16.;\n    st.x += 0.5;\n    vec2 suv = vec2((st.x * shift.x) - (shift.x * 0.5), st.y * shift.y);\n    float zoom = 2.5 + 2. * (sin(1.5 * sin(ltimer2 / 10.)));\n    return mi_o_y(suv, zoom * 0.56);\n}\n\nvoid mainImage_col3(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy / iResolution.xy;\n    vec2 uv = (((fragCoord.xy) / iResolution.xy) - res / 2.0);\n    fragColor = vec4(abs(mk(1.035*uv*vec2(1.,.5)+vec2(0.,-0.417))));\n    fragColor*=fragColor;\n    fragColor*=step(length(uv)-smoothstep(0.5,1.75,iTime),0.);\n    fragColor = clamp(fragColor,0.,1.);\n    \n    \n    vec2 tuv = fragCoord.xy / iResolution.xy;\n    \n    float tft = iTime;\n    \n\tfloat d = 0.5+0.5*noise(tuv*vec2(0.05,100.)+tft*vec2(0.5,1.5));\n    d*= 0.5+0.5*noise(tuv*vec2(0.05,30.)+vec2(0.,tft*8.5));\n    d*= 0.5+0.5*noise(tuv*vec2(0.05,10.5)+vec2(0.,tft*5.5));\n    d *= hash12(300.*floor(tuv*100.)/100.+tft*0.1);\n    d*=2.;\n    float tt = abs(20.-mod(iTime*1.,40.));\n    d*=1.-smoothstep(0.5-0.001-2.*smoothstep(5.,15.,tt),0.5-.5*smoothstep(5.,15.,tt),abs(tuv.y-0.5));\n    \n    fragColor+=d;\n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// do not use this - this is junk made only for this case\n// if you look for camera control in buffer:\n// look my template shaders, BufA there\n// https://www.shadertoy.com/view/DljGzy\n// or\n// https://danilw.github.io/blog/my_shader_templates_list/\n\n#define keyboard_texture iChannel3\n#define self_texture iChannel1\n\nconst vec3 start_pos = vec3(3.35, 8., -7.);\nconst vec2 start_mouse = vec2(-0.5*3.1415926+0.001, -0.0+0.001);\nconst float mouse_dir_ms = 0.4*0.75*1.;\nconst vec2 mouse_dir_st = vec2(-1.,0.);\n\n#define iTimeDelta min(iTimeDelta,1./10.)\n\nvoid store(ivec2 P, ivec2 ipx, vec4 V, inout vec4 fc){ if(ipx==P) fc = V;}\n\nvec4 load(ivec2 P, sampler2D self){return texelFetch(self, ivec2(P), 0);}\nfloat key(int K, sampler2D kb){return step(0.5, texelFetch(kb, ivec2(K, 0), 0).x);}\nfloat key_t(int K, sampler2D kb){return step(0.5, texelFetch(kb, ivec2(K, 2), 0).x);}\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(5, 3);\nconst ivec2 RES_LAST = ivec2(0, 0);\nconst ivec2 INIT = ivec2(0, 1);\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 POSITION = ivec2(1, 0);\nconst ivec2 POSITION_last = ivec2(1, 1);\nconst ivec2 tt_st = ivec2(1, 2);\n\nconst ivec2 last_iMouse = ivec2(2, 0);\nconst ivec2 mouse_dir = ivec2(2, 1);\nconst ivec2 t_ha = ivec2(2, 2);\nconst ivec2 t_ha2 = ivec2(4, 2);\n\nconst ivec2 INPUT = ivec2(3, 0);\nconst ivec2 PMOUSE = ivec2(3, 1);\n\nconst ivec2 RES_LAST_LAST = ivec2(3, 2);\n\n\nconst int Key_Backspace = 8, Key_Tab = 9, Key_Enter = 13, Key_Shift = 16, Key_Ctrl = 17, \nKey_Alt = 18, Key_Pause = 19, Key_Caps = 20, Key_Escape = 27, Key_Space = 32, \nKey_PageUp = 33, Key_PageDown = 34, Key_End = 35,Key_Home = 36, Key_LeftArrow = 37, \nKey_UpArrow = 38, Key_RightArrow = 39, Key_DownArrow = 40, Key_Insert = 45, \nKey_Delete = 46, Key_0 = 48, Key_1 = 49, Key_2 = 50, Key_3 = 51, Key_4 = 52,\nKey_5 = 53, Key_6 = 54, Key_7 = 55, Key_8 = 56, Key_9 = 57, Key_A = 65, Key_B = 66, \nKey_C = 67, Key_D = 68, Key_E = 69, Key_F = 70, Key_G = 71, Key_H = 72,Key_I = 73, \nKey_J = 74, Key_K = 75, Key_L = 76, Key_M = 77, Key_N = 78, Key_O = 79, Key_P = 80,\nKey_Q = 81, Key_R = 82, Key_S = 83, Key_T = 84, Key_U = 85,Key_V = 86, Key_W = 87, \nKey_X = 88, Key_Y = 89, Key_Z = 90, Key_LeftWindow = 91, Key_RightWindows = 92, \nKey_Select = 93, Key_Numpad0 = 96, Key_Numpad1 = 97, Key_Numpad2 = 98, Key_Numpad3 = 99,\nKey_Numpad4 = 100, Key_Numpad5 = 101, Key_Numpad6 = 102, Key_Numpad7 = 103, \nKey_Numpad8 = 104, Key_Numpad9 = 105, Key_NumpadMultiply = 106, Key_NumpadAdd = 107,\nKey_NumpadSubtract = 109, Key_NumpadPeriod = 110, Key_NumpadDivide = 111, Key_F1 = 112,\nKey_F2 = 113, Key_F3 = 114, Key_F4 = 115, Key_F5 = 116, Key_F6 = 117, Key_F7 = 118,\nKey_F8 = 119, Key_F9 = 120, Key_F10 = 121, Key_F11 = 122, Key_F12 = 123, \nKey_NumLock = 144, Key_ScrollLock = 145,Key_SemiColon = 186, Key_Equal = 187, \nKey_Comma = 188, Key_Dash = 189, Key_Period = 190, Key_ForwardSlash = 191, \nKey_GraveAccent = 192, Key_OpenBracket = 219, Key_BackSlash = 220, \nKey_CloseBraket = 221, Key_SingleQuote = 222;\n\nvec2 KeyboardInput(sampler2D kb) {\n    ivec4 inputs1 = ivec4(Key_UpArrow, Key_DownArrow, Key_RightArrow, Key_LeftArrow); //ARROWS\n    ivec4 inputs2 = ivec4(Key_W, Key_S, Key_D, Key_A);//WASD\n    //ivec4 inputs2 = ivec4(Key_E, Key_D, Key_F, Key_S);//ESDF\n    \n\tvec2 i = vec2(max(key(inputs1.z,kb),key(inputs2.z,kb))   - max(key(inputs1.w,kb),key(inputs2.w,kb)), \n                  max(key(inputs1.x,kb),key(inputs2.x,kb)) - max(key(inputs1.y,kb),key(inputs2.y,kb)));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return clamp(i * (n + (1.0 - n)),-1.,1.);\n}\n\nvec3 CameraDirInput(sampler2D kb, vec2 op, out vec2 tdx, float ltz) {\n    vec2 td = load(mouse_dir, self_texture).xy;\n    vec2 m = vec2(-0.5*3.1415926+0.001, -0.0+0.001);\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    float ty = 0.;\n    vec3 last_imc = vec3(load(last_iMouse, self_texture).xy,ltz);\n    vec3 position_l = load(POSITION, self_texture).xyz;\n    if(last_imc.x>0.)ty = (max(position_l.x-(start_pos.x-1.55),0.));\n    else ty = min(position_l.x-(start_pos.x-0.25),0.);\n    float tb = smoothstep(0.,1.75-0.5*sign(ty)-1.05*max(sign(ty),0.),iTime-last_imc.z+min(sign(ty),0.)*1.25);\n    ty*=tb*tb;\n    vec2 im = iMouse.xy/iResolution.y-0.5*iResolution.xy/iResolution.y;\n    vec2 tix = vec2(step(vec2(0.47,0.4),abs(im)));\n    float tx = 1.-min(dot(tix,vec2(1.)),1.);\n    ty*=tx;\n    \n    float tva = (1.-smoothstep(0.,.75,start_pos.x-(position_l.x+ty)));\n    op+=mouse_dir_ms*td.yx;\n    tdx = -step(abs(td),vec2(0.5))*(abs(td) - (1.-smoothstep(0.025+0.125*tva,0.05+0.125*tva,abs(op.yx))));\n    \n    return (rotY * rotX) * vec3(mouse_dir_ms*td*(0.25+0.75*tva), ty).xyz;\n}\n\n\nvoid build_mip( out vec4 fragColor, ivec2 ipx )\n{\n    fragColor = vec4(0.);\n    const float mscale = 10.;\n    vec2 sc_res = (mscl/iResolution.xy)*(iResolution.xy/2.)/mscale;\n    \n    vec2 suv = (vec2(ipx)+0.5)/sc_res;\n    ivec2 six = ivec2(suv);\n    bool yx = true;\n    if(any(greaterThan(six, ivec2(1,3))))return;\n    yx = six.y>1;\n    if(yx){\n        six.y=six.y-2;\n    }\n    \n    vec4 col = vec4(0.);\n    const int lp = 10;\n    float stp = .5*float(mscale)/float(lp);\n    for(int i = 0; i<lp; i++){\n        for(int j = 0; j<lp; j++){\n            vec2 lsuv = (vec2(ipx)+0.5+(float(lp)/2.-vec2(i,j))*stp)/sc_res;\n            lsuv = fract(lsuv*0.5)*2.;\n            lsuv = clamp(lsuv,vec2(six),vec2(six)+1.);\n            if(yx)col += textureLod(iChannel1, lsuv*0.5, 0.);\n            else col += textureLod(iChannel0, lsuv*0.5, 0.);\n        }\n    }\n    col = col/float(lp*lp);\n    \n    fragColor = col;\n    return;\n}\n\nconst vec3 tm = vec3(2.73,4.3,3.23);\nvoid set_frame( out vec4 fragColor, vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = clamp(textureLod(iChannel1, uv, 0.),0.,2.);\n    vec2 tid = floor(2.*uv);\n    int ti = int(tid.x)+2*int(tid.y);\n    if(tid==vec2(1.,1.))uv+=-0.5;\n\n    bool res_ch = ivec2(load(RES_LAST_LAST, self_texture))!=ivec2(iResolution.xy);\n    float h0 = load(t_ha2, self_texture)[ti-1];\n    \n    if(h0<-0.5)fragColor = textureLod(iChannel0, uv, 0.).bgra;\n    if(res_ch)fragColor = textureLod(iChannel0, uv, 0.).bgra;\n    vec4 tcc = textureLod(iChannel0, uv, 0.).bgra;\n    \n    \n    vec2 tuv = fragCoord.xy / iResolution.xy;\n    tuv=fract(tuv*2.);\n    float tft = iTime*0.75+float(ti)*15.3;\n    \n\tfloat d = 0.5+0.5*noise(tuv*vec2(0.05,100.)+tft*vec2(0.5,1.5));\n    d*= 0.5+0.5*noise(tuv*vec2(0.05,30.)+vec2(0.,tft*8.5));\n    d*= 0.5+0.5*noise(tuv*vec2(0.05,10.5)+vec2(0.,tft*5.5));\n    d *= hash12(300.*floor(tuv*100.)/100.+tft*0.1);\n    d*=2.;\n    float tt = abs(20.-mod(iTime*1.85+float(ti)*15.3,40.));\n    d*=1.-smoothstep(0.5-0.001-2.*smoothstep(8.,10.,tt),0.5-.5*smoothstep(8.,10.,tt),abs(tuv.y-0.5));\n    d*=d;\n    d*=float((iFrame%3)<1);\n    float d1 = d;\n    \n    tft = iTime+float(ti+4)*18.3;\n\td = 0.5+0.5*noise(tuv*vec2(0.05,100.)+tft*vec2(0.5,1.5));\n    d*= 0.5+0.5*noise(tuv*vec2(0.05,30.)+vec2(0.,tft*8.5));\n    d*= 0.5+0.5*noise(tuv*vec2(0.05,10.5)+vec2(0.,tft*5.5));\n    d *= hash12(300.*floor(tuv*100.)/100.+tft*0.1);\n    d*=2.;\n    tt = abs(20.-mod(iTime*1.25+float(ti+4)*18.3,40.));\n    d*=1.-smoothstep(0.5-0.001-2.*smoothstep(11.,15.,tt),0.5-.5*smoothstep(11.,15.,tt),abs(tuv.y-0.5));\n    d*=d;\n    d*=float((iFrame%8)<1);\n    \n    fragColor.rgb=d1*tcc.rgb+fragColor.rgb*(1.-d1)+d*0.;\n    fragColor.a=d*tcc.a+fragColor.a*(1.-d)+d1*0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    ivec2 ipx = ivec2(fragCoord);\n    fragColor=vec4(0.);\n    if (any(greaterThan(ipx, MEMORY_BOUNDARY))){\n        if(ipx.y>MEMORY_BOUNDARY.y+10-1)build_mip(fragColor, ipx- ivec2(0., MEMORY_BOUNDARY.y+10));\n        ivec2 tid = ivec2(2.*fragCoord/iResolution.xy);\n        if(tid!=ivec2(0,0))set_frame(fragColor, fragCoord);\n        return;\n    }\n    \n    fragColor = load(ipx, self_texture);\n    \n    vec3 position_l = load(POSITION, self_texture).xyz;\n    bool is_init = load(INIT, self_texture).x>1.;\n    \n    if (iFrame == 0 || !is_init) \n    {\n        position_l=start_pos;\n        store(POSITION, ipx, vec4(start_pos, 0.), fragColor);\n        store(POSITION_last, ipx, vec4(position_l, 0.), fragColor);\n        store(TARGET, ipx, vec4(start_pos, 0.), fragColor);\n        store(mouse_dir, ipx, vec4(mouse_dir_st,0.,0.), fragColor);\n        store(tt_st, ipx, vec4(0.), fragColor);\n        store(last_iMouse, ipx, vec4(iMouse.zw,0.,0.), fragColor);\n        store(INIT, ipx, vec4(2.,0.,0.,0.), fragColor);\n        store(INPUT, ipx, vec4(2.,0.,0.,0.), fragColor);\n        store(RES_LAST, ipx, vec4(iResolution.xy,0.,0.), fragColor);\n        store(RES_LAST_LAST, ipx, vec4(vec2(1.),0.,0.), fragColor);\n        store(t_ha, ipx, vec4(0.), fragColor);\n        store(t_ha2, ipx, vec4(0.), fragColor);\n        return;\n    }\n    \n\n    vec3 target      = load(TARGET, self_texture).xyz;   \n    vec3 position    = load(POSITION, self_texture).xyz;\n    vec2 res_l       = load(RES_LAST, self_texture).xy;\n    \n    vec3 ptarget = target;\n    vec2 tdx;\n    \n    vec3 last_imc = load(last_iMouse, self_texture).xyz;\n    if(sign(last_imc.x)!=sign(iMouse.z))last_imc=vec3(iMouse.zw,iTime);\n    \n    vec3 mdl = CameraDirInput(keyboard_texture,target.yz-position.yz, tdx, last_imc.z);\n    vec3 mvl = mdl;\n    \n    float ltd = iTimeDelta * 1.75*smoothstep(2.75,7.5,iTime);\n    target += mvl*vec3(1.*iTimeDelta*1.75,tdx*ltd*(1.-key_t(Key_Space,keyboard_texture)));\n    ltd*=smoothstep(1.5,8.5,iTime);\n    \n    vec3 lp = position;\n    position += (target - position) * iTimeDelta * 1.75;\n    \n    bool input_registered = false;\n    input_registered = ivec2(res_l)!=ivec2(iResolution.xy);\n    if(length(abs(position)-abs(lp))>0.0001)input_registered=true;\n    \n    store(TARGET, ipx, vec4(target, 0.0), fragColor);\n    store(POSITION, ipx, vec4(position, 0.0), fragColor);\n    \n    if (iMouse.z>0.0) {\n        vec2 im = iMouse.xy/iResolution.y-0.5*iResolution.xy/iResolution.y;\n        vec2 tix = vec2(step(vec2(0.47,0.4),abs(im)));\n        float tx = min(dot(tix,vec2(1.)),1.);\n        tix.x*=step(0.5,abs(tix.x-tix.y));\n        im = tix*sign(im);\n        \n        im = tx*im+(1.-tx)*load(mouse_dir, self_texture).xy;\n        store(mouse_dir, ipx, vec4(im,0.,0.), fragColor);\n    }else{\n        vec2 tixn = KeyboardInput(keyboard_texture);\n        vec2 tix = abs(tixn);\n        float tx = min(dot(tix,vec2(1.)),1.);\n        tixn.x*=step(0.5,abs(tix.x-tix.y));\n        if(tx>0.5){\n            store(mouse_dir, ipx, vec4(tixn,0.,0.), fragColor);\n        }\n    }\n    \n    float ltt = clamp(load(tt_st, self_texture).x,-1.,1.);\n    float nlt = clamp(ltt+clamp(iTime-load(last_iMouse, self_texture).z,0.,1.)*(((1.-float(sign(load(mouse_dir, self_texture).x)==sign(ltt)))+(float(sign(load(mouse_dir, self_texture).x)==sign(ltt)))*min(1.-abs(ltt),1.))*ltd/1.75*load(mouse_dir, self_texture).x-sign(ltt)*min(sqrt(abs(ltt))*1.5,1.)*ltd/1.75*abs(load(mouse_dir, self_texture).y)),-1.,1.);\n    if(abs(sign(load(mouse_dir, self_texture).y))>0.5)if(sign(nlt)!=sign(ltt)&&abs(nlt)<0.1)nlt=0.;\n    store(tt_st, ipx, vec4(nlt,ltt,0.,0.), fragColor);\n\n    store(last_iMouse, ipx, vec4(last_imc,0.), fragColor);\n    store(POSITION_last, ipx, vec4(position_l, 0.), fragColor);\n\n    \n    store(INPUT, ipx, vec4(input_registered?2.:0.,0.,0.,0.), fragColor);\n    \n    store(RES_LAST, ipx, vec4(iResolution.xy,0.,0.), fragColor);\n    store(RES_LAST_LAST, ipx, vec4(res_l,0.,0.), fragColor);\n    \n    \n    vec2 tid = vec2(1.,0.);\n    int ti = int(tid.x)+2*int(tid.y);\n    vec3 h0 = load(t_ha, self_texture).rgb;\n    float h1 = hash12(tid*33.3+3.133+3.*vec2(floor((iTime)/tm[ti-1])));\n    tid = vec2(0.,1.);\n    ti = int(tid.x)+2*int(tid.y);\n    float h2 = hash12(tid*33.3+3.133+3.*vec2(floor(iTime/tm[ti-1])));\n    tid = vec2(1.,1.);\n    ti = int(tid.x)+2*int(tid.y);\n    float h3 = hash12(tid*33.3+3.133+3.*vec2(floor(iTime/tm[ti-1])));\n    vec3 hn = floor(vec3(h1,h2,h3)*1000.)/1000.;\n    \n    vec3 tt = mod(vec3(iTime),tm)/tm;\n    \n    \n    vec3 h02o = load(t_ha2, self_texture).rgb;\n    vec3 h02 = (1.-vec3(equal(ivec3(hn*100.),ivec3(h0*100.))));\n    vec3 thh2 = vec3(greaterThan(h02o,vec3(0.5)));\n    vec3 tsh2 = sign(max(tt-max(h0,vec3(0.35)),vec3(0.)));\n    h02o=h02+(1.-h02)*(thh2*(-tsh2+(1.-tsh2)*h02o));\n    \n    \n    store(t_ha, ipx, vec4(hn,0.), fragColor);\n    store(t_ha2, ipx, vec4(h02o,0.), fragColor);\n    \n}\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// Created by Danil (2024+) https://github.com/danilw\n// https://mastodon.gamedev.place/@danil\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// using\n// https://iquilezles.org/articles/intersectors/\n// https://www.shadertoy.com/view/NlycW1\n\n\n\n#define AA 0\n\nvoid SetCamera(vec2 uv, out vec3 ro, out vec3 rd, vec2 ires);\nvoid GroundIntersectMin(vec3 ro, vec3 rd, inout bool result, inout HitInfo hit);\n\nbool minDist(vec3 ro, vec3 rd, out HitInfo hit)\n{\n    hit.t = MAX_DIST;\n    hit.obj_type = OBJ_SKY;\n    hit.color=vec4(vec3(0.),1.);\n    bool result = false;\n\n    VoxelsIntersectMin(ro.yxz, rd.yxz, result, hit, iChannel0, iChannel1, iTime, iResolution.xy);\n    \n    // TAA work better with this\n    if(hit.obj_type == OBJ_SKY)hit.t = 4.;\n\n    return result;\n}\n\nvec4 render(vec3 ro, vec3 rd)\n{\n    vec3 col = vec3(0.0);\n    vec3 objectcolor = vec3(1.0);\n    vec3 mask = vec3(1.0);\n    HitInfo hit;\n    hit.color=vec4(0.);\n    {\n        if(minDist(ro, rd, hit)){\n            objectcolor = hit.color.rgb;\n            vec3 p = ro + rd * hit.t + hit.norm*0.0001;\n            col = objectcolor;\n        }else col = vec3(0.);\n    }\n    return vec4(col, hit.t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   //discard;\n    vec4 ret_col = vec4(0.0);\n    vec3 ro; vec3 rd;\n    vec2 h1 = (halton(iFrame % 360 + 1) - 0.5);\n    #if AA>1\n    for( int mx=0; mx<AA; mx++ )\n    for( int nx=0; nx<AA; nx++ )\n    {\n    vec2 o = vec2(float(mx),float(nx)) / float(AA) - 0.5;\n    vec2 uv = (fragCoord+o+h1)/iResolution.xy * 2.0 - 1.0;\n    #else\n    vec2 uv = (fragCoord+h1)/iResolution.xy * 2.0 - 1.0;\n    #endif\n    uv.y *= iResolution.y/iResolution.x;\n    SetCamera(uv, ro, rd, iResolution.xy);\n    vec4 col = render(ro, rd);\n    ret_col += col;\n    #if AA>1\n    }\n    ret_col /= float(AA*AA);\n    #endif\n    \n    //ret_col.rgb = clamp(ret_col.rgb,0.,1.);\n    \n    fragColor = ret_col;\n}\n\n\n\n// camera\n//----------------------------\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define SS(x, y, z) smoothstep(x, y, z)\n\nconst ivec2 RES_LAST = ivec2(0, 0);\nconst ivec2 INIT = ivec2(0, 1);\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 tt_st = ivec2(1, 2);\nconst ivec2 POSITION = ivec2(1, 0);\nconst ivec2 POSITION_last = ivec2(1, 1);\n\nconst ivec2 INPUT = ivec2(3, 0);\nconst ivec2 PMOUSE = ivec2(3, 1);\n\nvec3 l1Pos = vec3(2,1,0);\n\nmat3 rotx(float a){float s = sin(a);float c = cos(a);return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, c, s), vec3(0.0, -s, c));  }\nmat3 roty(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, 0.0, s), vec3(0.0, 1.0, 0.0), vec3(-s, 0.0, c));}\nmat3 rotz(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, s, 0.0), vec3(-s, c, 0.0), vec3(0.0, 0.0, 1.0 ));}\n\nmat3 rotationMatrix(vec2 m, float tt){\n  mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n  mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n  return rotY*rotX*rotz(-tt*0.175);\n}\n\nvoid SetCamera(vec2 uv, out vec3 ro, out vec3 rd, vec2 ires)\n{\n    ro = load(POSITION).xyz;\n    vec2 m = vec2(-0.5*3.1415926+0.001, -0.0+0.001);\n    m.y = -m.y;\n    float fov=camera_fov;\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n    \n#ifdef cam_cyli\n    // cylindrical perspective https://www.shadertoy.com/view/ftffWN\n      float a = rd.x/rd.z;\n      rd.xz = rd.z * vec2(sin(a),cos(a));\n#endif\n    //rd+=0.000001*(1.-abs(sign(rd)));\n    rd = normalize(rd);\n    \n    \n    float ltt = load(tt_st).x;\n    rd = rotationMatrix(m,ltt) * rd;\n}\n//----------------------------\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// TAA from https://www.shadertoy.com/view/dldGWj\n\n// MODIFIED do not use\n\n#define use_dynamic_TAA\n\n#ifndef use_dynamic_TAA\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    discard;\n}\n#else\n\n// from https://www.shadertoy.com/view/DsfGWX\n\nvoid SetCamera(vec2 uv, out vec3 ro, out vec3 rd, vec2 ires);\nvoid SetCamera_prev(vec2 uv, out vec3 ro, out vec3 rd, vec2 ires);\nvec2 pos2uv(vec3 pos, vec2 ires);\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\nconst ivec2 RES_LAST_LAST = ivec2(3, 2);\n\n#define ENABLE_TAA\n#define TEMPORAL_REPROJECT\n\n#define VARIANCE_CLIPPING\n\n// debug\n//#define SHOW_MOTION\n//#define SHOW_DISOCCLUSION\n\n// TAA\n// alpha of this shader is unused, it used to store curr_d but hist.a used only in SHOW_DISOCCLUSION\n\n#define EPS 1e-4\n\n\n\n#define OFFSET_COUNT 4\n\nconst ivec2 off[OFFSET_COUNT] = ivec2[OFFSET_COUNT](\n \tivec2( 1,  0), ivec2( 0, -1), \n\tivec2( 0,  1), ivec2(-1,  0)\n);\n/*\n#define OFFSET_COUNT 8\n\nconst ivec2 off[OFFSET_COUNT] = ivec2[OFFSET_COUNT](\n    ivec2(-1, -1), ivec2(-1,  1), \n\tivec2( 1, -1), ivec2( 1,  1), \n\tivec2( 1,  0), ivec2( 0, -1), \n\tivec2( 0,  1), ivec2(-1,  0)\n);\n*/\n\n\nvec3 rgb2ycocg(in vec3 rgb)\n{\nreturn rgb;\n    float co = rgb.r - rgb.b;\n    float t = rgb.b + co / 2.0;\n    float cg = rgb.g - t;\n    float y = t + cg / 2.0;\n    return vec3(y, co, cg);\n}\n\n\nvec3 ycocg2rgb(in vec3 ycocg)\n{\nreturn ycocg;\n    float t = ycocg.r - ycocg.b / 2.0;\n    float g = ycocg.b + t;\n    float b = t - ycocg.g / 2.0;\n    float r = ycocg.g + b;\n    return vec3(r, g, b);\n}\n\nvec3 RGBtoYCoCg(vec3 c)\n{\nreturn c;\n    //return rgb2ycocg(c);\n    return mat3(0.25, 0.5, -0.25, 0.5, 0, 0.5, 0.25, -0.5, -0.25) * c;\n}\n\nvec3 YCoCgToRGB(vec3 c)\n{\nreturn c;\n    //return ycocg2rgb(c);\n    return mat3(1, 1, 1, 1, 0, -1, -1, 1, -1) * c;\n}\n\nvec4 clipToAABB(in vec4 cOld, in vec4 cNew, in vec4 center, in vec4 halfSize)\n{\n    vec4 r = cOld - cNew;\n    vec4 m = (center + halfSize) - cNew;\n    vec4 n = (center - halfSize) - cNew;\n    \n    if (r.x > m.x + EPS)\n\t\tr *= (m.x / r.x);\n\tif (r.y > m.y + EPS)\n\t\tr *= (m.y / r.y);\n\tif (r.z > m.z + EPS)\n\t\tr *= (m.z / r.z);\n    if (r.w > m.w + EPS)\n\t\tr.w *= (m.w / r.w);\n\n\tif (r.x < n.x - EPS)\n\t\tr *= (n.x / r.x);\n\tif (r.y < n.y - EPS)\n\t\tr *= (n.y / r.y);\n\tif (r.z < n.z - EPS)\n\t\tr *= (n.z / r.z);\n    if (r.w < n.w - EPS)\n\t\tr.w *= (n.w / r.w);\n\n\treturn cNew + r;\n}\n\nvec4 SampleTextureCatmullRom(sampler2D tex, vec2 texSize, vec2 uv)\n{\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n    vec2 f = samplePos - texPos1;\n\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    \n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / w12;\n\n    vec2 texPos0 = texPos1 - vec2(1.0);\n    vec2 texPos3 = texPos1 + vec2(2.0);\n    vec2 texPos12 = texPos1 + offset12;\n\n    texPos0 /= texSize;\n    texPos3 /= texSize;\n    texPos12 /= texSize;\n\n    vec4 result = vec4(0.0);\n    result += textureLod(tex, vec2(texPos0.x,  texPos0.y), 0.) * w0.x * w0.y;\n    result += textureLod(tex, vec2(texPos12.x, texPos0.y), 0.) * w12.x * w0.y;\n    result += textureLod(tex, vec2(texPos3.x,  texPos0.y), 0.) * w3.x * w0.y;\n\n    result += textureLod(tex, vec2(texPos0.x,  texPos12.y), 0.) * w0.x * w12.y;\n    result += textureLod(tex, vec2(texPos12.x, texPos12.y), 0.) * w12.x * w12.y;\n    result += textureLod(tex, vec2(texPos3.x,  texPos12.y), 0.) * w3.x * w12.y;\n\n    result += textureLod(tex, vec2(texPos0.x,  texPos3.y), 0.) * w0.x * w3.y;\n    result += textureLod(tex, vec2(texPos12.x, texPos3.y), 0.) * w12.x * w3.y;\n    result += textureLod(tex, vec2(texPos3.x,  texPos3.y), 0.) * w3.x * w3.y;\n\n    return result;\n}\n\nfloat distancePixel22( vec2 prevFragCoord, vec3 pos, sampler2D samplerx, vec2 ires, vec3 p_ro, vec3 p_rd){\n    if(  min(ires.xy-1., prevFragCoord) != prevFragCoord\n      || max(vec2(0.)      , prevFragCoord) != prevFragCoord) return MAX_DIST;\n    \n    float prev_d = textureLod(samplerx, prevFragCoord/ires.xy,0.).a;\n    vec3 prevPos = p_ro + p_rd*prev_d;\n    return length(prevPos-pos);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tmxa = .051;// modified\n    \n    ivec2 ipx = ivec2(fragCoord);\n    \n    // adding halton_px_shift to fragCoord not needed\n    vec2 uv = (fragCoord)/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec2 halton_px_shift = (halton(iFrame % 360 + 1) - 0.5);\n    float curr_d = textureLod(iChannel2, (fragCoord - halton_px_shift) / iResolution.xy, 0.).a;\n    vec4 curr_color = textureLod(iChannel2, (fragCoord - halton_px_shift) / iResolution.xy, 0.).rgba;\n    bool tba = any(lessThan(curr_color.rgb, vec3(0.)));\n    curr_color.rgb = abs(curr_color.rgb); \n    \n    vec4 new = vec4(RGBtoYCoCg(curr_color.rgb),curr_color.a);\n\n#ifdef TEMPORAL_REPROJECT\n\n    vec3 ro;\n    vec3 rd;\n    SetCamera(uv, ro, rd, iResolution.xy);\n    \n    vec3 pro;\n    vec3 prd;\n    SetCamera_prev(uv, pro, prd, iResolution.xy);\n    \n    vec3 pos = ro + rd * curr_d;\n    \n    // adding prevUv to fragCoord not needed\n    vec2 prevUv = pos2uv(pos, iResolution.xy);\n    vec2 prevFragCoord = (prevUv * iResolution.y + iResolution.xy/2.0);\n    vec2 puv = prevFragCoord/iResolution.xy; \n    \n    \n    //vec4 hist = texture(iChannel2, puv);\n    //vec4 hist = getTextureSmooth(iChannel2, iResolution.xy, puv);\n    vec4 hist = SampleTextureCatmullRom(iChannel3, iResolution.xy, puv);\n    hist*=step(abs(puv.x-0.5),0.5)*step(abs(puv.y-0.5),0.5);// modified\n\n    vec4 old = vec4(RGBtoYCoCg(hist.rgb),hist.a);\n#else\n    ivec2 sp = ivec2(fragCoord);\n    vec4 old = vec4(RGBtoYCoCg(texelFetch(iChannel3, sp, 0).rgb),texelFetch(iChannel3, sp, 0).a);\n#endif\n\n#ifdef VARIANCE_CLIPPING\n    vec4 avg = new;\n    vec4 var = new * new;\n    \n    for (int i = 0; i < OFFSET_COUNT; i++)\n    {\n        vec4 tex_data = texelFetch(iChannel2, ipx + off[i], 0);\n        tba = tba||any(lessThan(tex_data.rgb, vec3(0.)));\n        tex_data.rgb = abs(tex_data.rgb);\n        vec4 tex = vec4(RGBtoYCoCg(tex_data.rgb),tex_data.a);\n        \n        avg += tex;\n        var += tex * tex;\n    }\n    avg /= float(OFFSET_COUNT + 1);\n    var /= float(OFFSET_COUNT + 1);\n\n    vec4 sig = sqrt(max(var - avg * avg, vec4(0)));\n    \n    const float g = 1.;\n    vec4 cmin = avg - sig * g;\n    vec4 cmax = avg + sig * g;\n    \n    #if 0\n    vec4 clip = clamp(old, cmin, cmax);\n    #else\n    vec4 clip = clipToAABB(old, clamp(avg, cmin, cmax), avg, sig);\n    #endif\n    \n    old = mix(old, clip, 0.05+0.645*float(tba)); //1. modified\n#endif\n    bool res_ch = ivec2(load(RES_LAST_LAST))!=ivec2(iResolution.xy);\n    vec4 col = iFrame != 0 && !res_ch ? mix(old, new, tmxa) : new;\n    \n#ifdef ENABLE_TAA\n    fragColor = vec4(YCoCgToRGB(col.rgb), curr_d);\n#else\n    fragColor = vec4(texelFetch(iChannel2, ivec2(fragCoord), 0).rgb, curr_d);\n#endif\n    \n#ifdef SHOW_DISOCCLUSION\n\n    if (puv.x < 0. || puv.x >= 1. || puv.y < 0. || puv.y >= 1. ||\n        distance(pos, (pro+prd*hist.a)) > 2.*0.1*curr_d)\n    {\n        fragColor = vec4(1, 0, 0, curr_d);\n    }\n#endif\n\n#ifdef SHOW_MOTION\n    fragColor = vec4((fragCoord/iResolution.xy - puv) * 50., 0, curr_d);\n#endif\n    fragColor.rgb=clamp(fragColor.rgb,0.,100.); // seems color can be little negative\n\n#ifndef SHOW_DISOCCLUSION\n    //debug\n    //fragColor.a = length(texture(iChannel3,puv).rgb);\n#endif\n    \n}\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// camera\n//----------------------------\n#define SS(x, y, z) smoothstep(x, y, z)\n\n\n\nconst ivec2 INIT = ivec2(0, 1);\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 tt_st = ivec2(1, 2);\nconst ivec2 POSITION = ivec2(1, 0);\nconst ivec2 POSITION_last = ivec2(1, 1);\n\nconst ivec2 INPUT = ivec2(3, 0);\nconst ivec2 PMOUSE = ivec2(3, 1);\n\nmat3 rotx(float a){float s = sin(a);float c = cos(a);return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, c, s), vec3(0.0, -s, c));  }\nmat3 roty(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, 0.0, s), vec3(0.0, 1.0, 0.0), vec3(-s, 0.0, c));}\nmat3 rotz(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, s, 0.0), vec3(-s, c, 0.0), vec3(0.0, 0.0, 1.0 ));}\n\nmat3 rotationMatrix(vec2 m, float tt){\n  mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n  mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n  \n  return rotY*rotX*rotz(-tt*0.175);\n}\n\nvoid SetCamera(vec2 uv, out vec3 ro, out vec3 rd, vec2 ires)\n{\n    ro = load(POSITION).xyz;\n    vec2 m = vec2(-0.5*3.1415926+0.001, -0.0+0.001);\n    m.y = -m.y;\n    float fov=camera_fov;\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n    \n#ifdef cam_cyli\n    // cylindrical perspective https://www.shadertoy.com/view/ftffWN\n      float a = rd.x/rd.z;\n      rd.xz = rd.z * vec2(sin(a),cos(a));\n#endif\n    //rd+=0.000001*(1.-abs(sign(rd)));\n    rd = normalize(rd);\n    \n    \n    float ltt = load(tt_st).x;\n    rd = rotationMatrix(m,ltt) * rd;\n}\n\nvoid SetCamera_prev(vec2 uv, out vec3 ro, out vec3 rd, vec2 ires)\n{\n    ro = load(POSITION_last).xyz;\n    vec2 m = vec2(-0.5*3.1415926+0.001, -0.0+0.001);\n    m.y = -m.y;\n    float fov=camera_fov;\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n#ifdef cam_cyli\n    // cylindrical perspective https://www.shadertoy.com/view/ftffWN\n      float a = rd.x/rd.z;\n      rd.xz = rd.z * vec2(sin(a),cos(a));\n#endif\n    //rd+=0.000001*(1.-abs(sign(rd)));\n    rd = normalize(rd);\n    \n    float ltt = load(tt_st).y;\n    rd = rotationMatrix(m,ltt) * rd;\n}\n\n\n//----------------------------\n\n\n\n\n\n\n// reprojection\n//----------------------------------------------\n\nvec2 pos2uv(vec3 pos, vec2 ires){\n    vec3 ro_old = load(POSITION_last).xyz;\n    vec2 m_old = vec2(-0.5*3.1415926+0.001, -0.0+0.001);\n    m_old.y = -m_old.y;\n    vec3 td = pos - ro_old;\n    if(length(td)<0.0001)return vec2(-1.);\n    \n    float ltt = load(tt_st).y;\n    vec3 dir = normalize(td) * (rotationMatrix(m_old,ltt));\n    \n    \n    float fov=camera_fov;\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    dir.z+=0.0001*(1.-abs(sign(dir.z)));\n\n#ifdef cam_cyli\n    // cylindrical perspective https://www.shadertoy.com/view/ftffWN\n    //undone\n    float last_sa = atan(dir.x/dir.z);\n    vec3 ord = dir;\n    ord.z = dir.z*1./cos(last_sa);\n    ord.x=last_sa*ord.z;\n    dir = ord;\n#endif\n\n    return dir.xy * (.5/screenSize) / dir.z ;\n}\n\n//----------------------------------------------\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}