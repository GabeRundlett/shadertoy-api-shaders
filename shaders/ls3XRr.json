{
    "Shader": {
        "info": {
            "date": "1457310286",
            "description": "A basic Voronoi implementation.",
            "flags": 0,
            "hasliked": 0,
            "id": "ls3XRr",
            "likes": 19,
            "name": "Basic 2D Voronoi",
            "published": 3,
            "tags": [
                "voronoi"
            ],
            "usePreview": 0,
            "username": "Bers",
            "viewed": 1189
        },
        "renderpass": [
            {
                "code": "// Author : SÃ©bastien BÃ©rubÃ©\n// Created : March 2013\n// Modified : Feb 2016\n//\n// An exercise with 2D voronoi cell generation.\n// \n// License : Creative Commons Non-commercial (NC) license\n\nconst int CELL_COUNT = 300;\nconst float EDGE_WIDTH = 0.0010;\nconst float JITTER_SPEED = 1./100.0;\n\n//Globals\nfloat D_S = 10.0; //Horizontal cell count\nfloat D_AMP = 0.4; //Jitter amplitude\n\nvec2 discretePos(vec2 p)\n{\n    vec2 dp = floor(p*D_S);\n    if(fract(dp.x*0.5)>0.25)\n    {\n        p.y += 0.5/D_S;\n        dp = floor(p*D_S)/D_S;\n        dp.y -= 0.5/D_S;\n        return dp;\n    }\n    else\n        return dp/D_S;\n}\n\nvec2 noise(vec2 p)\n{\n    return (-0.5+texture(iChannel0,p+iTime*JITTER_SPEED,-100.0).xy)*D_AMP;\n}\n\nvec2 noiseDiscretePos(vec2 p)\n{\n    vec2 samplePos = discretePos(p);\n    vec2 d = noise(samplePos);\n    return samplePos+d;\n}\n\nvec2 neighbor(vec2 p, vec2 a )\n{\n    return noiseDiscretePos(p+a/D_S);\n}\n\nvec2 animateCell()\n{\n    //Arbitrary animation.\n    vec2 p = vec2(0.55+0.40*sin(0.1*iTime),\n                  0.25+0.20*cos(0.1*iTime*1.298));\n    p += noise(p);\n    return p;\n}\n\nstruct SiteInfo\n{\n    vec2 pos;\n    float dist;\n};\n\nstruct VoroInfo\n{\n    SiteInfo closest;\n    SiteInfo second_closest;\n};\n    \nvoid processProximity(vec2 px, vec2 pSite, inout VoroInfo vInfo)\n{\n    SiteInfo sInfo;\n    sInfo.dist = dot(px-pSite,px-pSite);\n    sInfo.pos  = pSite;\n    if(sInfo.dist<vInfo.closest.dist)\n\t{\n\t\tvInfo.second_closest = vInfo.closest;\n        vInfo.closest = sInfo;\n\t}\n\telse if(sInfo.dist<vInfo.second_closest.dist)\n\t{\n\t\tvInfo.second_closest = sInfo;\n\t}\n}\n\nVoroInfo closestSites(vec2 px)\n{\n    VoroInfo vInfo;\n    vInfo.closest.pos = px;\n    vInfo.closest.dist = 100000.0;\n    vInfo.second_closest.pos = px;\n    vInfo.second_closest.dist = 100000.0;\n    \n    for(int i=-3; i<=3; i++)\n    {\n        for(int j=-3; j<=3; j++)\n        {\n            vec2 posSite = neighbor(px,vec2(i,j));\n            processProximity(px,posSite,vInfo);\n        }\n    }\n    \n   \t/*vec2 posMouseSite = (iMouse.z>0.5)? iMouse.xy/iResolution.x : animateCell();\n    processProximity(px,posMouseSite,vInfo);*/\n    \n    vInfo.closest.dist = sqrt(vInfo.closest.dist);\n\tvInfo.second_closest.dist = sqrt(vInfo.second_closest.dist);\n    \n    return vInfo;\n}\n\n#define saturate(a) clamp(a,0.0,1.0)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    D_S = sqrt(float(CELL_COUNT)*2.0); //Horizontal cell count\n\tD_AMP = 4.0/D_S; //Jitter amplitude\n    \n\tvec2 uv = fragCoord.xy / iResolution.x;\n    vec2 uvMouse = (iMouse.z>0.5)? iMouse.xy/iResolution.x : animateCell();\n\t\n    VoroInfo vInfo = closestSites(uv);\n    float deltaDist = abs(vInfo.closest.dist-vInfo.second_closest.dist);\n    vec2 vDeltaCenters = vInfo.second_closest.pos-vInfo.closest.pos;\n    vec2 vToCenter = vInfo.closest.pos-uv;\n    //orthogonal projection on boundary\n    vec2 vEdgeDir = vec2(-vDeltaCenters.y,vDeltaCenters.x);\n    vec2 boundaryCenter = vInfo.closest.pos+vDeltaCenters*.5;\n    vec2 boundaryProjection = boundaryCenter-dot(vToCenter,vEdgeDir)*vEdgeDir/dot(vEdgeDir,vEdgeDir);\n    float edgeDist = length(boundaryProjection-uv);\n    \n    vec3 cellColor = vec3(0);\n    float d = saturate(2.0*vInfo.closest.dist/D_AMP);\n    if(length(uvMouse-vInfo.closest.pos)<0.001)\n    {\n        cellColor = vec3(d/4.0,d/2.0,d).bgr*6.0;\n    }\n    else\n    {\n        \n        //cellColor = vec3(saturate(1.0-3.0*vInfo.closest.dist/D_AMP));\n        cellColor = vec3(d/4.0,d/2.0,d)*1.0;\n    }\n    \n    float aa = 0.001; //aa = transition width (pixel \"antialiazing\" or smoothness)\n    float fBlobLerp = smoothstep(EDGE_WIDTH-aa,EDGE_WIDTH+aa,edgeDist);\n    fragColor.rgb = mix(vec3(1,1,1),cellColor,fBlobLerp);\n    \n    fragColor.rgb = mix(fragColor.rgb, vec3(0.7,0.8,1), smoothstep(2.0*EDGE_WIDTH+aa,2.0*EDGE_WIDTH-aa,vInfo.closest.dist));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}