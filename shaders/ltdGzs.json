{
    "Shader": {
        "info": {
            "date": "1471051873",
            "description": "A VR terrain shader, made to be used with Google Cardboard on the Shadertoy app.",
            "flags": 1,
            "hasliked": 0,
            "id": "ltdGzs",
            "likes": 4,
            "name": "VR Terrain",
            "published": 3,
            "tags": [
                "noise",
                "terrain",
                "raymarcher",
                "height",
                "vr"
            ],
            "usePreview": 0,
            "username": "jackdavenport",
            "viewed": 1203
        },
        "renderpass": [
            {
                "code": "#define EPSILON .00001\n#define MAX_DIST 256.\n#define MAX_ITER 512\n\n#define LIGHT_DIR normalize(vec3(45.,30.,-45.))\n#define LIGHT_COL vec3(1.,.8,.2)\n#define LIGHT_AMB vec3(.1,.1,.3)\n\n// Noise by Pixelshaders.com\n// Source: http://pixelshaders.com/examples/noise.html\nfloat random(float p) {\n  return fract(sin(p)*10000.);\n}\nfloat noise(vec2 p) {\n  return random(p.x + p.y*10000.);\n}\nvec2 sw(vec2 p) {return vec2( floor(p.x) , floor(p.y) );}\nvec2 se(vec2 p) {return vec2( ceil(p.x)  , floor(p.y) );}\nvec2 nw(vec2 p) {return vec2( floor(p.x) , ceil(p.y)  );}\nvec2 ne(vec2 p) {return vec2( ceil(p.x)  , ceil(p.y)  );}\nfloat smoothNoise(vec2 p) {\n  vec2 inter = smoothstep(0., 1., fract(p));\n  float s = mix(noise(sw(p)), noise(se(p)), inter.x);\n  float n = mix(noise(nw(p)), noise(ne(p)), inter.x);\n  return mix(s, n, inter.y);\n  return noise(nw(p));\n}\nfloat fractalNoise(vec2 p) {\n  float total = 0.0;\n  total += smoothNoise(p);\n  total += smoothNoise(p*2.) / 2.;\n  total += smoothNoise(p*4.) / 4.;\n  total += smoothNoise(p*8.) / 8.;\n  total += smoothNoise(p*16.) / 16.;\n  total /= 1. + 1./2. + 1./4. + 1./8. + 1./16.;\n  return total;\n}\n//\n\nfloat getHeight(vec3 p) {\n    \n    return smoothNoise(p.xz);\n    \n}\n\nfloat raymarch(vec3 ori, vec3 dir) {\n \n    float t = 0.;\n    for(int i = 0; i < MAX_ITER; i++) {\n   \t\tvec3  p = ori + dir * t;\n        float h = p.y - getHeight(p);\n        if(h < t*EPSILON || t > MAX_DIST)\n            break;\n        t += h * .5;\n    }\n    return t;\n    \n}\n\nvec3 calcNormal(vec3 p, float t) {\n    vec2  e = vec2(t*EPSILON,0.);\n    vec3  n = vec3(getHeight(p-e.xyy)-getHeight(p+e.xyy),\n                   2.*e.x,\n                   getHeight(p-e.yyx)-getHeight(p+e.yyx));\n    return normalize(n);\n}\n\nvec3 calcLighting(vec3 col, vec3 p, vec3 n, vec3 r, float sp) {\n \n    float d = max(dot(LIGHT_DIR,n),0.);\n    float s = 0.;\n    \n    if(raymarch(p+LIGHT_DIR*.01,LIGHT_DIR) < MAX_DIST)\n        d = 0.;\n    \n    if(d > 0. && sp > 0.)\n        s = pow(max(dot(LIGHT_DIR,r),0.),sp);\n    \n    return col*(LIGHT_AMB+LIGHT_COL*d)+(LIGHT_COL*s);\n    \n}\n\nvec3 getSky(vec3 dir) {\n \n    float y = pow(dir.y,.5);\n    float s = pow(max(dot(LIGHT_DIR,dir),0.),30.);\n    \n    return mix(vec3(.6,.6,.8),vec3(.3,.3,.8),y) + LIGHT_COL*s;\n    \n}\n\nvec3 shadeTerrain(vec3 p, vec3 n, vec3 r) {\n\t  \n    vec3 col;\n    col = texture(iChannel0, p.xz).xyz;\n    col = calcLighting(col, p, n, r, 60.); \n    \n    return col;\n    \n}\n\nvec3 shade(vec3 ori, vec3 dir) {\n \n    float  t = raymarch(ori,dir);\n    vec3 col = getSky(dir);\n    \n    if(t < MAX_DIST) {\n    \tvec3 p = ori+dir*t;\n        vec3 n = calcNormal(p, t);\n        vec3 r = normalize(reflect(dir, n));\n        \n        col = shadeTerrain(p,n,r);\n        \n        vec3  rc = vec3(0.);\n        float rt = raymarch(p+r*.01,r);\n        if(rt < MAX_DIST) {\n       \t\tvec3 rp = p+r*(rt+.01);\n            vec3 rn = calcNormal(rp,rt);\n            vec3 rr = normalize(reflect(r,rn));\n            rc = shadeTerrain(rp,rn,rr);\n        } else {\n        \trc = getSky(r);   \n        }\n        \n        float f = 1.-pow(max(-dot(dir,n),0.),.5);\n        col = mix(col, rc, mix(.2,.8,f));\n        \n    }\n    \n    return col;\n    \n}\n\nvoid transformOri(inout vec3 ori) {\n \n    ori += vec3(cos(iTime*.2)*5.,.5,iTime);\n    if(ori.y < getHeight(ori))\n        ori.y = getHeight(ori)+.2;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 ori = vec3(0.,0.,0.);\n    vec3 dir = vec3(uv, 1.);\n    \n    transformOri(ori);\n\tfragColor = vec4(shade(ori,normalize(dir)),1.);\n}\n\nvoid mainVR(out vec4 fc, in vec2 fp, in vec3 ro, in vec3 rd) {\n \n    transformOri(ro);\n\tfc = vec4(shade(ro,normalize(rd)),1.);   \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}