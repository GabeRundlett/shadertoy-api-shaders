{
    "Shader": {
        "info": {
            "date": "1455500523",
            "description": "A prime number visualization based on https://www.jasondavies.com/primos/\nAny point on the X-axis where only 2 waves intersect is a prime number.",
            "flags": 0,
            "hasliked": 0,
            "id": "MsK3zV",
            "likes": 16,
            "name": "Prime Waves",
            "published": 3,
            "tags": [
                "waves",
                "math",
                "visualization",
                "prime"
            ],
            "usePreview": 0,
            "username": "Flyguy",
            "viewed": 1103
        },
        "renderpass": [
            {
                "code": "//A prime number visualization based on https://www.jasondavies.com/primos/\n//Any point on the X-axis where only 2 waves intersect is a prime number.\n\n#define INF 1e6\n#define WAVES 128\n#define WAVE_SIZE (1.0/32.0)\n#define WAVE_THICKNESS 1.25\n\nfloat pi = atan(1.0)*4.0;\n\n//Number printing stuff\n#define CHAR_SIZE vec2(3, 7)\n#define CHAR_SPACING vec2(4, 8)\n\nint digit(float d)\n{\n    d = mod(floor(d), 10.0);\n    \n    if(d == 0.0) return 0x1EDB6F;\n    if(d == 1.0) return 0x0B2497;\n    if(d == 2.0) return 0x1C9F27;\n    if(d == 3.0) return 0x1C9E4F;\n    if(d == 4.0) return 0x16DE49;\n    if(d == 5.0) return 0x1E4E4F;\n    if(d == 6.0) return 0x1E4F6F;\n    if(d == 7.0) return 0x1C9492;\n    if(d == 8.0) return 0x1EDF6F;\n    if(d == 9.0) return 0x1EDE4F;\n    return 0;\n}\n\nfloat extractBit(float n, float b)\n{\n    n = floor(n);\n    b = floor(b);\n\treturn mod(floor(n / exp2(b)),2.0);   \n}\n\nfloat sprite(int spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    float bit = (size.x - uv.x - 1.0) + uv.y * size.x;\n    bool bounds = all(greaterThanEqual(uv, vec2(0))) && all(lessThan(uv, size));    \n    return bounds ? extractBit(float(spr), bit) : 0.0;\n}\n\n//Flip Y-axis\nvec2 flipY(vec2 v)\n{\n    return vec2(v.x, -v.y);\n}\n\n//Mirror X-axis\nvec2 mirrorX(vec2 v)\n{\n    return vec2(abs(v.x), v.y);\n}\n\n//Distance to a semi-circle\nfloat dfSemiCircle(vec2 uv, float r)\n{\n    float d = abs(length(uv) - r);\n \td = max(d, INF * step(0.0, - uv.y));\n    d = min(d, length(abs(uv) - vec2(r, 0)));\n    return d;\n}\n\n//Distance to a semicircular wave.\nfloat dfWave(vec2 uv, float r)\n{\n    r *= 0.5;\n    \n    uv.x -= r;\n    uv.x = mod(uv.x, 4.0*r);\n    \n    vec2 offs = vec2(2.0*r, 0);\n    \n    float d = dfSemiCircle(mirrorX(uv - offs) - offs, r);\n    d = min(d, dfSemiCircle(flipY(mirrorX(uv) - offs), r)); \n    \n    return d;\n}\n\n//Distance to prime indicator dots.\nfloat dfPrimes(vec2 uv, float s, float r)\n{\n    uv.x += s/2.0;\n    \n    float n = floor(uv.x/s);\n    \n\tuv.x = mod(uv.x, s) - s/2.0;\n    \n    bool prime = true;\n    \n    if(n != 0.0 && n != 1.0)\n    {\n        for(int i = 2; i < WAVES;i++)\n        {\n            float fi = float(i);\n            \n            if(fi < n)\n            {\n                float modni = mod(n, fi);\n                if(modni == 0.0 || modni == fi) //mod(x,y) sometimes returns y when it should return 0.\n                {\n                    prime = false;\n                    break;\n                }\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n    else\n    {\n    \tprime = false;   \n    }\n    \n    return prime ? (length(uv) - r) : INF;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    uv.y -= res.y/2.0;\n    \n    float ps = 1.0/iResolution.y;\n    \n    //Waves\n    float dw = INF;\n    \n    for(int i = 1;i < WAVES;i++)\n    {\n    \tdw = min(dw, dfWave(uv, WAVE_SIZE * float(i)));   \n    }\n    \n    dw = smoothstep(WAVE_THICKNESS * ps,0.0,dw);\n    \n    //Dots\n    float dp = dfPrimes(uv, WAVE_SIZE, ps*2.0);\n    \n    dp = smoothstep(ps,0.0, dp);\n    \n    //Background\n    vec3 back = vec3(floor(0.5 * sin(pi * uv.x / WAVE_SIZE) + 1.0) * 0.05 + 0.125);\n    \n    vec3 col = mix(back, vec3(0.5), dw);\n    col = mix(col, vec3(1.0), dp);\n    \n    //Numbers\n    float n = floor(uv.x / WAVE_SIZE);\n    \n    uv = floor(uv * iResolution.y);\n    uv.x = mod(uv.x, iResolution.x * WAVE_SIZE / res.x);\n    \n    float ncol = 0.0;\n    float off = 0.0;\n    \n    for(int i = 0;i < 3;i++)\n    {\n        float mag = pow(10.0, float(2-i)); //Magnitude of digit (1, 10, 100, 1000, ...)\n        if(n >= mag || (mag == 1.0 && n == 0.0)) //Clip off leading 0s (except when n=0)\n        {\n        \tfloat d = floor(n / mag);\n    \t\tncol += sprite(digit(d), CHAR_SIZE, uv - vec2(4.0 * off + 3.0, -8.0));\n            off++;\n        }\n    }\n    \n    col = mix(col, vec3(0.2,1,0.6), ncol);\n    \n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}