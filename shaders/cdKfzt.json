{
    "Shader": {
        "info": {
            "date": "1699205498",
            "description": "Raymarching tutorial",
            "flags": 0,
            "hasliked": 0,
            "id": "cdKfzt",
            "likes": 0,
            "name": "RayMarchHelloWorld",
            "published": 3,
            "tags": [
                "raymarch",
                "tutorial"
            ],
            "usePreview": 0,
            "username": "GabrielTheWalrus",
            "viewed": 176
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nmat3 setCamera(vec3 ro, vec3 lookat, vec3 wUp){\n\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = normalize(cross(f, r));\n    \n    return mat3(f,r,u);\n}\n\nvec2 getDist(vec3 p){\n\n    float t = iTime;\n\n    vec4 sphere = vec4(0., 1., 5., 1.);\n    vec4 sphere2 = vec4(.5, 3., 2., 2.);\n    vec4 wall = vec4(0.0, .0, 2, 1.0);\n    \n    float sphereDist = sdSphere((p-sphere.xyz), sphere.w);\n    float sphereDist2 = sdSphere((p-sphere2.xyz), sphere2.w);\n    float groundDist = sdPlane(p);\n    \n    if(sphereDist < groundDist)\n        return vec2(sphereDist, 1.);\n    \n    else return vec2(groundDist, 0.);\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd){\n\n    float dO = .0;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        \n        vec3 p = ro + rd * dO; // distancia da superficie\n        float dS = getDist(p).x;\n        dO = dO + dS;\n        \n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 getNormal(vec3 p){\n \n     float d = getDist(p).x;\n     vec2 e = vec2(.01, 0);\n     \n     vec3 n = d - vec3(\n         getDist(p-e.xyy).x,\n         getDist(p-e.yxy).x,\n         getDist(p-e.yyx).x);\n         \n     return normalize(n);\n}\n\nfloat getLight(vec3 p, vec3 lightSourcePos){\n    \n    vec3 l = normalize(lightSourcePos-p); // light direction from point p\n    vec3 n = getNormal(p);\n    \n    float dif = clamp(dot(n,l), 0., 1.);\n    \n    float d = rayMarch(p+n*SURF_DIST*2.0, l);\n    \n    if(d < length(lightSourcePos-p))\n        return dif*0.2;\n\n    return dif;\n \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy; // 640 x 360\n    //uv = uv*2.0 - 1.0f; //Pq isso Ã© ruim?\n    \n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float t = iTime;\n    \n    vec3 ro = vec3(.0, 1.0, -2.);\n    vec3 lookat = vec3(.0, 1., 5.);\n    \n    mat3 cameraMatrix = setCamera(ro, lookat, vec3(0., 1., 0.));\n    \n    float zoom = 1.;\n    \n    vec3 c = ro + cameraMatrix[0]*zoom;\n    vec3 i = c + uv.x * cameraMatrix[1] + uv.y * cameraMatrix[2];\n    \n    //vec3 rd = i - ro;\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0)); ///outro tipo de camera?\n    \n    vec3 lightSourcePos = vec3(sin(t), 5., cos(t));\n    \n    float res = rayMarch(ro, rd);\n    vec3 p = ro + rd * res;\n    \n    res = getLight(p, lightSourcePos);\n    vec2 teste = getDist(p);\n    \n    vec3 sphereColor = vec3(1.0, .0, 1.0);\n    vec3 groundColor = vec3(.0, 1.0, 0.0);\n    \n    //res /= 20.; \n    \n   // res = smoothstep(.001, 1., res);\n    \n    vec3 col = vec3(res);\n    \n    \n    if(teste.y == 1.0)\n        col = col * sphereColor;\n    else\n        col = col * groundColor;\n    \n    //fragColor = vec4(uv, 0., 1.);\n    \n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}