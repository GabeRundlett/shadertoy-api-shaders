{
    "Shader": {
        "info": {
            "date": "1508641219",
            "description": "A quick Alpha Tower for you all! :) Enjoy!\n\nfixed the glitch by adding the substepping :)",
            "flags": 0,
            "hasliked": 0,
            "id": "4t2cDW",
            "likes": 10,
            "name": "AlphaTower",
            "published": 3,
            "tags": [
                "raymarch",
                "font"
            ],
            "usePreview": 0,
            "username": "Del",
            "viewed": 763
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// tower & fruit machine reels added by Del\n\n\n#define AA 1   // make this 1 is your machine is too slow\n\n#define PI 3.1415926\n#define DEG2RAD ((PI * 2.0) / 360.0)\nfloat tBlend = -1.0;\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\n\n\n//---------------------------------------------------------\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\n\n\n#define XP 0.0\n#define ZP 0.0\n#define HEIGHT 0.4\n#define FONTTHICKNESS 0.1\n#define INNER 1.9\n\nstruct ReelData\n{\n  float rot;\n};\n\nvec3 p00 = vec3(XP, 2.7, ZP);\n\nReelData dat[4] = ReelData[4](\n    ReelData(0.0),\n    ReelData(0.0),\n    ReelData(0.0),\n    ReelData(0.0)\n);\n    \n// crap stuff\n// dirty... not sure if I am doing this correctly...\nvec4 SampleFontTex(vec2 uv,float xoff)\n{\n    uv = uv.yx;\n    uv.x = -uv.x;\n//    uv += 0.04;\n    uv.x += 0.04 + (0.25 * xoff);\n    uv *= 0.25;\n    vec2 fl = floor(uv + 0.5);\n    uv = fl + fract(uv+0.5)-0.5;\n    \n    // Sample the font texture. Make sure to not use mipmaps.\n    // Add a small amount to the distance field to prevent a strange bug on some gpus. Slightly mysterious. :(\n    //return texture(iChannel0, (uv+0.5)*((1.0/16.0)*8.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.00001);\n    return texture(iChannel0, uv, -100.0) + vec4(0.0, 0.0, 0.0, 0.00001);\n}\n\n\n//------------------------------------------------------------------\n\nvec2 reel (in vec3 pos)\n{\n   \tfloat _mat1 = 230.0;\t// tower\n\tfloat _mat2 = 20.0;\t// font\n\n    float sv = 4.0 * sin(pos.y*0.1+dat[1].rot*0.01);\n    \n    float cval = abs(pos.y)*12.0;\n    \n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\n    float _index = pModInterval1(pos.y,1.0,-3.0,3.0);\n    int index = int(abs(_index)) % 4;\n    \n\tpos = rotateY (pos,sv );\t// sin movement (pixel)\n    \n//    pos = rotateY (pos, sin(dat[index].rot*0.02));\t// sin movement (reel)\n//\tpos = rotateY (pos,  DEG2RAD*dat[index].rot);\t// spin\n    \n    float innercylinderdist = sdCylinder(pos,vec2(INNER,HEIGHT));\n    float d1 = sdCylinder(pos,vec2(INNER+FONTTHICKNESS,HEIGHT));\n \t// Load the font texture's distance field.\n\tvec4 _c = SampleFontTex( vec2(atan(pos.x,pos.z), 0.5+(pos.y*0.75)) / PI, 13.0);\n    float letterDistField = _c.w - 0.5+1.0/256.0;\n    d1 = max(letterDistField,d1);\n    \n    vec2 res = vec2( d1, _mat2 + cval);\n    \n    d1 = sdCylinder(pos,vec2(INNER-0.01,HEIGHT+0.1));\n    res.x = opS(res.x, d1 );\n    \n    res = opU(res, vec2( d1, _mat1 ) );\n    return res;\n    \n}\n\n\n\n\n\n//------------------------------------------------------------------\n// old alpha tower version...\nconst vec3 p01 = vec3(XP+0.0,5.95, ZP+0.0);\n\nvec4 SampleFontTex(vec2 uv)\n{\n    vec2 fl = floor(uv + 0.5);\n    uv = fl + fract(uv+0.5)-0.5;\n    // Sample the font texture. Make sure to not use mipmaps.\n    // Add a small amount to the distance field to prevent a strange bug on some gpus. Slightly mysterious. :(\n    return texture(iChannel0, (uv+0.5)*((1.0/16.0)*8.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.00001);\n}\n\nvec2 _maptower( in vec3 pos )\n{\n\tvec3 r1, r2;\n\tfloat d1 = 0.0f;\n\tfloat d2 = 0.0f;\n\tfloat _mat1 = 230.0;\t// tower\n\tfloat _mat2 = 48.0;\t// font\n       \n\tvec2 res = vec2( sdPlane(pos), 1.0 ); \t\t\t// floor (checker)\n    \n\tr1 = rotateY (pos-p01,  dat[0].rot*0.02);\n\tr1 = rotateX (r1,  DEG2RAD*0.0);\n    d1 = sdCylinder(r1,vec2(1.90,6.0));\n    res = opU(res, vec2( d1, _mat1 ) );\n\n    d1 = sdCylinder(r1,vec2(2.0,6.0));\n \t// Load the font texture's distance field.\n\tvec4 _c = SampleFontTex( vec2(atan(r1.x,r1.z), r1.y) / PI);\n    float letterDistField = _c.w - 0.5+1.0/256.0;\n    d1 = max(letterDistField,d1);\n    \n    float cval = pos.y*30.0;\n    res = opU(res, vec2( d1, _mat2+ cval)  );\n    \n    // More accuracy (substepping)\n\tres.x *= 0.85;\n    \n\treturn res;\n}\n\n\n\nvec2 map( in vec3 pos )\n{\n    \n    vec2 res = vec2( sdPlane(pos), 1.0 ); \t\t\t// floor (checker)\n\n    vec2 res2 = res;\n    res2 =  opU(res2,_maptower(pos));\n    \n\n    pos = rotateX (pos-p00,  DEG2RAD*270.0);\n\n    res =  opU(res,reel(pos));\n\n    // More accuracy (substepping)\n\tres.x *= 0.85;\n\n    // blend the scenes...\n    return mix(res2, res, tBlend);\n    \n    \n//\tres.x *= 0.85;\n//\treturn res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n       \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(0.5*pos.z) + floor(0.5*pos.x), 2.0);\n            col = 0.3 + 0.1*f*vec3(1.0);\n        }\n#if 1\n        // lighting        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\tlin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n#endif\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n    if (iMouse.z<0.5)\n        mo = vec2((180.0 * DEG2RAD)/6.0,0.0);\n    \n\t// blend...\n\ttBlend = cos(iTime*0.4);\n    tBlend*=2.0f;\n    \n    tBlend = clamp(tBlend,0.0,1.0);\n        \n\tfloat time = iTime;\n    dat[0].rot += time*25.0;\n    dat[1].rot += time*50.0;\n    dat[2].rot += time*75.0;\n    dat[3].rot += time*100.0;\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera\t\n        //vec3 ro = vec3( 6.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 6.5*sin(0.1*time + 6.0*mo.x) );\n        \n\t\tfloat ang = 180.0 * DEG2RAD;        \n        vec3 ro = vec3( 6.5*cos(ang+(6.0*mo.x)), 4.0 + 2.0*mo.y, 6.5*sin(ang+(6.0*mo.x)) );\n        vec3 ta = vec3( 0.0, 2.0, 0.0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}