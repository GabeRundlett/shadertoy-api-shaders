{
    "Shader": {
        "info": {
            "date": "1547505667",
            "description": "csg",
            "flags": 0,
            "hasliked": 0,
            "id": "Wsf3D2",
            "likes": 0,
            "name": "CSG_shad",
            "published": 3,
            "tags": [
                "csg"
            ],
            "usePreview": 0,
            "username": "Clemm_ence",
            "viewed": 281
        },
        "renderpass": [
            {
                "code": "const float FLT_MAX = 1.0 / 0.0;\nconst int MAX_NB_BOUNCES = 3;\nconst int PIXEL_SAMPLING_SIZE = 25;\nconst int PIXEL_SAMPLING_GRID_SIZE = 5;\nconst int NB_LIGHTS = 2;\n\nint subObjectIdC = 0;\n\nstruct Material\n{\n    float Ka;\t// ambiant        coefficient\n    float Kd;\t// diffuse        coefficient\n    float Ks;\t// specular       coefficient\n    float Kn;\t// specular power coefficient\n};\n    \n    \n    \nstruct ShadeInfo\n{\n\tvec3 shadeCol;\n    float Ks;\n};\n    \n    \nstruct LightInfo\n{\n\tvec3 pos;\n    vec3 col;\n    float pow;\n};\nLightInfo lights[NB_LIGHTS];\n//parametre camera\nvec3 camPos=vec3(6,4,-5);\n\nconst vec3 camObj = vec3(3,1,-8);\nconst float camFovY = 90.0;\n\n//parametre sphere\n vec3 center = camObj + vec3(0,1,2);\nconst float rayonS = 1.0;\nconst vec3 sphereCol = vec3(1.0,0,0);\nconst Material sphereMat = Material(0.2,0.7,1.0,50.0);\nconst int      sphereId     = 1;\n\n//parametre lumiere\nconst vec3     ambiantCol   = vec3(0,0,1);\t\t// blue\n\nconst vec3     light1Col     = vec3(1,1,1);\t\t// white\n      vec3     light1Pos     = vec3(8,10,-12);\nconst float    light1Pow = 0.8;\n\nconst vec3     light2Col     = vec3(1,1,0.5);\t\t// white/yellow\n      vec3     light2Pos     = vec3(3,10,1);\nconst float    light2Pow = 0.5;\n\n\n\n\n// Plane parameters\nconst vec3     planePos     = vec3(0, 0.1, 0);\nconst vec3     planeNormal  = vec3(0, 1.0, 0);\nconst vec3     planeCol1    = vec3(1.0);\t\t// white\nconst vec3     planeCol2    = vec3(0.4);\t\t// gray\nconst Material planeMat     = Material(0.2/*Ka*/, 1.0/*Kd*/, 0.2/*Ks*/,  5.0/*Kn*/);\nconst int      planeId      = 2;\n\n\n\n// Sky parameters\nconst vec3     skyCol       = vec3(0);\t\t\t// black\nconst int      skyId        = 0;\n\nconst int antialliazing = 1;\n\n\n//CSG objects parameters\nconst vec3     csgSphere1Pos \t= camObj + vec3(-1.125, 2, 0);\nconst float    csgSphere1Radius = 1.4;\nconst vec3\t   csgSphere2Pos \t= camObj + vec3(1.125, 2, 0);\nconst float\t   csgSphere2Radius = 1.4;\nconst vec3\t   csgSphere3Pos \t= camObj  + vec3(0, 2.5, 0);\nconst float\t   csgSphere3Radius = 0.5;\nconst vec3\t   csgSphere4Pos \t= camObj  + vec3(0, 2.4, -0.5);\nconst float\t   csgSphere4Radius = 0.5;\nconst vec3\t   csgCol1 \t\t\t= vec3(1.0, 0.5, 0.0); //orange\nconst vec3\t   csgCol2 \t\t\t= vec3(0.4, 1.0, 1.0); //light cyan\nconst vec3     csgCol3\t\t\t= vec3(1.0, 0.0, 1.0); //magenta\nconst vec3     csgCol4\t\t\t= vec3(5.0, 5.0, 0.0); //hyper yellow\nconst Material csgMat \t\t\t= Material(0.2, 1.0, 0.1, 90.0);\nconst int \t   csgId\t\t\t= 3;\n\n\n\nfloat raySphere(vec3 rayPos, vec3 rayDir,vec3 center, float rayonS,out vec3 intersecPt, out vec3 normal)\n{\n\tvec3 diff = rayPos - center ; \n     float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - rayonS * rayonS;\n    \n    float d = b*b - 4.0*a*c;\n    \n    \n    if (d >= 0.0)\n    {\n        float sd = sqrt(d);\n    \tfloat t1 = (-b - sd ) / (2.0 * a);\n    \tfloat t2 = (-b + sd ) / (2.0 * a);\n        \n       float dir = 1.0;\n       float t = -1.0;\n        if (t1 > 0.0 )\n          t = t1;\n        else if (t2 > 0.0)\n        {\n        \tt = t2;\n        }else\n            return t;\n        intersecPt = rayPos + t * rayDir;\n        normal     = normalize(intersecPt - center) * dir;\n        \n        return t;\n\n     }\n    return -1.0;\n}\n\n\n\nfloat rayPlane(    vec3 rayPos    ,     vec3 rayDir, vec3 planePos, vec3 planeNormal,\n               out vec3 intersecPt, out vec3 normal)\n{\n    float den = dot(planeNormal, rayDir);\n    if (abs(den) <= 0.000001)\n        return -1.0;\n    float t = dot(planeNormal, planePos - rayPos) / den;\n    intersecPt = rayPos + t * rayDir;\n     normal = -sign(den) * planeNormal;\n    \n    return t;\n    \n}\n\nfloat rayCSG(vec3 rayPos, vec3 rayDir, out vec3 interPt, out vec3 normal, out int subObjectId)\n{\n\tvec3 interPt1;\n    vec3 normal1;\n    vec3 interPt2;\n    vec3 normal2;\n    vec3 interPt3;\n    vec3 normal3;\n    vec3 interPt4;\n    vec3 normal4;\n  \n    float dist1 = raySphere(rayPos, rayDir, csgSphere1Pos, csgSphere1Radius, interPt1, normal1);\n    float dist2 = raySphere(rayPos, rayDir, csgSphere2Pos, csgSphere2Radius, interPt2, normal2);\n    float dist3 = raySphere(rayPos, rayDir, csgSphere3Pos, csgSphere3Radius, interPt3, normal3);   \n    float dist4 = raySphere(rayPos, rayDir, csgSphere4Pos, csgSphere4Radius, interPt4, normal4);\n    \n    \n    if (dist1 > 0.0) //intersection s1/s2\n    {\t\n        float dist12 = distance(interPt1, csgSphere2Pos);\n        if (dist12 < csgSphere2Radius){ \n        \tfloat dist14 = distance(interPt1, csgSphere4Pos); // s1 vers s4\n            if (dist14 >csgSphere4Radius){\n            \tinterPt= interPt1;\n                subObjectId = 1;\n                normal = normal1;\n                return dist1;\n            \t}\n            \tfloat dist41 = distance(interPt4, csgSphere1Pos);\n            \tfloat dist42 = distance(interPt4, csgSphere2Pos);\n       \t\t\t \n        \tif ((dist41 < csgSphere2Radius) && (dist42 < csgSphere1Radius ) && (dist4 > 0.0))\n             { \n                interPt= interPt4;\n                subObjectId = 4;\n                normal = normal4;\n                return dist4;\n            }\n                }\n            }\n    \n    if (dist2 > 0.0) //intersection s2/s1\n    {\t\n        float dist21 = distance(interPt2, csgSphere1Pos);\n        if (dist21 < csgSphere1Radius)\n        {\n            float dist24= distance(interPt2, csgSphere4Pos);\n            if  (dist24 > csgSphere4Radius)\n            {\n                interPt= interPt2;\n                subObjectId = 2;\n                normal = normal1;\n                return dist2;\n            }\n            dist24 = distance(interPt4, csgSphere2Pos);\n            float dist14 = distance(interPt4, csgSphere1Pos);\n            if ((dist24 < csgSphere2Radius) && (dist14 < csgSphere1Radius) && (dist4 > 0.0)){\n            \tinterPt = interPt4;\n                 subObjectId = 4;\n                 normal = normal4; \n                 return dist4;\n            }\n                }\n    \n    //intersection s3/s4\n  \n    if (dist3 > 0.0){\n        // distance sphere 3 / origine 4\n    \tfloat dist34 = distance(interPt3, csgSphere4Pos);\n\t\tif (dist34     > csgSphere4Radius)  \n        {\n        \tinterPt = interPt3;\n            subObjectId = 3;\n            normal = normal3; \n            return dist3;\n        }\n        float dist43 = distance( interPt4, csgSphere3Pos);\n            if ((dist43 < csgSphere3Radius) && (dist4 > 0.0))\n            {\n            interPt = interPt4;\n            subObjectId = 4;\n            normal = normal4; \n            return dist4;\n            }\n    \t}\n\t}\nreturn -1.0;\n}\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n \n   float focal = 1.0 / tan(radians(camFovY) / 2.0);\n   vec3 cz = normalize(camObj - camPos);\n     vec3 up = vec3(0,1,0);\n   vec3 cx = normalize(cross(-up, cz));\n   vec3 cy = normalize(cross( cz, cx));\n    \n   vec2 pt = (2.*pixCoord - iResolution.xy) / iResolution.y;\n    \n   rayPos = camPos;\n   rayDir = normalize(pt.x * cx - pt.y * cy + focal * cz);\n}\n\n\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir,\n                                 out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n \t float minDist  = FLT_MAX;\n          objectId = skyId;   \n    vec3 intersecS, normalS;\n    \n   //test sphere\n      float distS = raySphere(rayPos, rayDir, center, rayonS, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n          normalI =   normalS;\n    }\n    //test CSG\n     vec3 intersecC, normalC;\n    float distC =  rayCSG(rayPos, rayDir,intersecC, normalC, subObjectIdC);\n    if ((distC > 0.0) && (distC < minDist))\n    {\n        objectId  =   csgId;\n        minDist   =   distC;\n\t    intersecI =   intersecC;\n    \tnormalI   =   normalC;\n    }\n    \n    //test plane\n     vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId  =   planeId;\n        minDist   =     distP;\n\t    intersecI = intersecP;\n    \t  normalI =   normalP;\n    }\n       if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n\n}\n\n\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    \n     vec3 axisY  = normalize(cross(planeNormal, axisX));\n    \n     vec3 diff = pt - planePos; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n\n}\nvec3 getCSGColorAtPoint(vec3 pt) \n{\n\tif (subObjectIdC == 1)\n        return csgCol1;\n    if (subObjectIdC == 2)\n        return csgCol2;\n    if (subObjectIdC == 3)\n        return csgCol3;\n    if (subObjectIdC == 4)\n        return csgCol4;\n    return vec3(3);\n}\n\n\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    if (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n    else if (objectId == csgId) \n    {\n        objectMat = csgMat;\n        return getCSGColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\n\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat, float shadowFactor, vec3 N, vec3 L, vec3 R, vec3 V, LightInfo lights )\n{\n\n     vec3 ambiant  = objectMat.Ka * ambiantCol;\n \t \n   \n    vec3 diffuse  = objectMat.Kd *  objectCol * lights.col *     max(dot(N,L), 0.)*shadowFactor;\n    vec3 specular = objectMat.Ks *              lights.col * pow(max(dot(R,V), 0.), objectMat.Kn)*shadowFactor;\n     \n    vec3 phongCol = ambiant + diffuse + specular;\n\n    return phongCol;   \n}\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n\tint object;\n    vec3 inter;\n    vec3 nI;\n    float shadowPoint;\n   \t\n    \n        \n    float intersec =computeNearestIntersection(I, L,object,  inter, nI);\n    if ((intersec < 0.0) || (intersec > Ldist))\n    {\tshadowPoint = 0.5;\n    }else {\n        shadowPoint = 0.0;\n}\nreturn  shadowPoint;\n\n}\n\nvoid AnimeScene(float time)\n{\n \t//animate the sphere position\n    const float pi = 3.1415926535;\n    const float rs = 2.0;\n    const float spr = 5.0;\n    float as = 2.0 * pi * time / spr;\n    \n    center = camObj + rs * vec3(-sin(as),0.0,cos(as))+vec3(0,1,0);\n    \n    //anime ligth position\n    light1Pos += vec3(0,10.5 +9.5 * cos(time)-10.,0);\n    \n    float targetDist = length(camObj - camPos);\n    camPos -=vec3(0,0,targetDist);\n    camPos += targetDist*vec3(sin(time), max(sin(time*0.5),0.),cos(time));\n}\n\n\n\nvec4 RaytraceAtPixelCoord_RT(vec2 pixCoord)\n{\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n    ShadeInfo infos[MAX_NB_BOUNCES];\n    int nbBounces = 0;\n    \n    \n    int objectId;\n    vec3 intersecI, normalI;\n    \n    vec3 color;\n   \n    \n    do\n    {\n        \n        \n        float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n        vec3 color;\n        Material objMat;\n        \n         \n        if (distI <= 0.0) //pt dans le ciel\n        {\n            infos[nbBounces].shadeCol = skyCol;\n            infos[nbBounces].Ks = 0.0 ; \n            break;\n        }\n    \n      \n        //objets\n        \n        vec3 V =- rayDir;\n        vec3 objColor = getObjectColorAtPoint(objectId, intersecI, objMat);\n         vec3 I = intersecI + normalI*0.01;\n         vec3 RayRefract = 2.0 * normalI * dot(normalI, V) - V;\n            \n         for (int l = 0 ; l < NB_LIGHTS ; l++){   \t\t\n            vec3 L = normalize(lights[l].pos - intersecI);\n            \n           vec3 R = normalize(2.0 * normalI * dot(normalI, L) - L);\n        \n           \n            float Ldist = length(lights[l].pos - I);\n            \n             float shadowFactor = getShadowFactorAtPoint(I,normalI, objMat,L,Ldist);\n             color += computePhongShading(objColor, objMat,  shadowFactor,normalI, L, R, V, lights[l]);\n             \n         }\n            infos[nbBounces].shadeCol= color;\n            infos[nbBounces].Ks = objMat.Ks;\n            \n          rayDir = RayRefract;\n             rayPos = I;\n            \n               nbBounces++;\n            \n           \n        }\n    \n    while (nbBounces < MAX_NB_BOUNCES);\n    vec3 resCol = vec3(0);\n    \n    for (int i =0; i<=nbBounces; i++)\n    {\n        resCol = infos[nbBounces -i].Ks *resCol + infos[nbBounces - i].shadeCol; \n    \n    }\n    \n    return vec4(resCol,1);\n}\n\n\n\nvec2 noise2(vec2 location , vec2 delta)\n{\n\tconst vec2 c= vec2 (12.9898 , 78.233);\n    const float m = 43758.5453;\n    return vec2(fract(sin(dot(location + delta,c))*m),\n                      fract(sin(dot(location+ vec2(delta.y,delta.x),c)) * m));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \t \n    float time = iTime;\n     AnimeScene(time);\n    \n    lights[0].pos = light1Pos;\n    lights[0].col = light1Col;\n    lights[0].pow = light1Pow;\n    lights[1].pos = light2Pos;\n    lights[1].col = light2Col;\n    lights[1].pow = light2Pow;\n    \n    \n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n    \n    int  objectId; \n    vec3 intersecI, normalI;\n   \n    \n    float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n    \n    float pixel = 1.0/iResolution.y;\n    float sousPixel = pixel/float(PIXEL_SAMPLING_GRID_SIZE); \n    vec4 finalColor = vec4(0);\n  \n    \n    if (antialliazing == 0)\n    {\n         for (int i = 0; i < PIXEL_SAMPLING_GRID_SIZE; i++)\n    {\n        \tfor (int j = 0 ; j < PIXEL_SAMPLING_GRID_SIZE; j++)\n        {\n           finalColor +=RaytraceAtPixelCoord_RT(fragCoord + vec2(float(i) * sousPixel, float(j) * sousPixel));\n            \n        }\n    }\n    finalColor /=pow(float(PIXEL_SAMPLING_GRID_SIZE), 2.0);\n    }else {\n        vec2 delta = vec2 (600.0, 5468.265);\n        for (int i= 0; i < PIXEL_SAMPLING_SIZE; i++)\n    {\n            finalColor += RaytraceAtPixelCoord_RT(fragCoord + noise2(fragCoord, delta) * pixel);\n        }\n        finalColor /= float(PIXEL_SAMPLING_SIZE);\n    }\n    \n   \n    fragColor= finalColor;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}