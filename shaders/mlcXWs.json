{
    "Shader": {
        "info": {
            "date": "1685865835",
            "description": "render Cube - Sphere U Sphere with ray marching",
            "flags": 0,
            "hasliked": 0,
            "id": "mlcXWs",
            "likes": 2,
            "name": "Raymarching (Cube-Sphere)UCube 2",
            "published": 3,
            "tags": [
                "raymarching",
                "raymarch",
                "spheretracing",
                "reflect"
            ],
            "usePreview": 0,
            "username": "silica163",
            "viewed": 245
        },
        "renderpass": [
            {
                "code": "//#extension GL_OES_standard_derivatives : enable\n\n//precision highp float;\n\n//uniform float time;\n//uniform vec2 mouse;\n//uniform vec2 resolution;\n\n#define time iTime\n#define resolution iResolution\n#define mouse iMouse.xy\n#define PI 3.14159265\n#define MAX_DIST  20.\n#define MIN_DIST  .001\n#define MAX_STEP  128\n#define MAX_REF   3\n\nconst int LIGHTS = 4;\nconst int SPHERES = 3;\nconst int CUBES = 2;\n\nstruct Ray {\n\tvec3 o;\n\tvec3 p;\n\tvec3 dir;\n\tvec3 c;\n\tfloat dist;\n    float rl;\n};\n\nstruct Sphere {\n\tvec4 p;\n\tvec3 color;\n};\n\t\nstruct Cube {\n\tvec3 p;\n\tvec3 c;\n\tvec3 s;\n};\n\nstruct Light {\n\tvec3 p;\n\tvec3 c;\n    vec3 L;\n};\n\nSphere sp[SPHERES];\nCube cu[CUBES];\nLight l[LIGHTS];\n\nvoid init(){\n    sp[0] = Sphere(vec4(0,0,0,1.3),vec3(0));\n    sp[1] = Sphere(vec4(0,0,-.5,.4),vec3(0));\n    \n    sp[2] = Sphere(vec4(0,0,.5,.4),vec3(0));\n    \n    cu[0] = Cube(vec3(0,0,0),vec3(0),vec3(1));\n    cu[1] = Cube(vec3(0,-1,0),vec3(0),vec3(3.,.01,3.));\n\n    l[0].p = vec3(sin(2./3.*PI*2.)*1.5,2,cos(2./3.*PI*2.)*1.5);\n    l[0].c = vec3(0,0,1);\n\n    l[1].p = vec3(sin(1./3.*PI*2.)*1.5,2,cos(1./3.*PI*2.)*1.5);\n    l[1].c = vec3(1,0,0);\n    \n    l[2].p = vec3(sin(0.)*1.5,2,cos(0.)*1.5);\n    l[2].c = vec3(0,1,0);\n\n    l[3].p = vec3(0,5,0);\n    l[3].c = vec3(1);\n}\n\nvec3 N = vec3(0);\nvec3 V = vec3(0);\n\nfloat max3(vec3 n){\n    return max(max(n.x,n.y),n.z);\n}\n\nfloat cubeSDF(vec3 p,int id){\n    vec3 c = abs(p-cu[id].p)-cu[id].s;\n    return length(max(c,0.)) + min(0.,max3(c));\n}\n\nfloat sphereSDF(vec3 p, int id){\n    float d = length(p - sp[id].p.xyz) - sp[id].p.w;\n    return d;\n}\n\t\nfloat dist(vec3 p){\n\tfloat d = 0.;\n    \n\td = sphereSDF(p,0);\n\t\n\td = max(cubeSDF(p,0)-.01,-d);\n\td = min(d,cubeSDF(p,1));\n    d = min(d,sphereSDF(p,1));\n    d = min(d,sphereSDF(p,2));\n\t\n\treturn d;\n}\n\nfloat lightDist(vec3 p,float d){\n    for(int i = 0;i<LIGHTS;i++)\n        d = min(d,length(p - l[i].p)-.1);\n\treturn d;\n}\n\nvoid march(inout Ray r,int t){\n\tfor(int i = 0;i<MAX_STEP;i++){\n\t\tr.p = r.o + r.dist*r.dir;\n\t\tfloat d = dist(r.p);\n\t\td = t == 0 ? d : min(d,lightDist(r.p,d));\n\t\tif(d <= MIN_DIST || d > MAX_DIST)break;\n\t\tr.dist += d;\n\t}\n    r.rl += r.dist;\n}\n\nvec3 sNormal(vec3 p){\n\tvec2 t = vec2(.001,0);\n\tfloat d = dist(p);\n\t\n\treturn normalize(d - vec3(\n\t\tdist(p-t.xyy),\n\t\tdist(p-t.yxy),\n\t\tdist(p-t.yyx)\n\t));\n}\n\nfloat diffuse(vec3 p,vec3 L){\n\treturn max(dot(sNormal(p),normalize(L)),0.);\n}\n\nvec3 colorDiff(Light l,Ray r){\n\tvec3 c = vec3(0);\n\tfloat d = diffuse(r.p,l.L);\n\t\n\tc += l.c * d;\n\t\n\treturn c;\n}\n\nfloat bPhong(Light l,Ray r){\n\tfloat c = 0.;\n\tfloat d = diffuse(r.p,l.L);\n\t\n\tc += pow(max(dot(normalize(l.L+V),N),0.),100.)*2. * d;\n\t\n\treturn c;\n}\n\nfloat shadowMask(vec3 p,vec3 l){\n\tfloat m = 1.;\n\tfloat x = 10.;\n\tRay r = Ray(p+N*MIN_DIST*x,p+N*MIN_DIST*x,normalize(l-p),vec3(0),0.,0.);\n\tmarch(r,0);\n\tif(r.dist < length(l-p))m = 0.1;\n\treturn m;\n}\n\nvoid lNormal(inout Light l,Ray r){\n\tl.L = normalize(l.p-r.p);\n}\n\nvec3 getColor(Light l,Ray r){\n    return ((colorDiff(l,r) + bPhong(l,r)*l.c) * vec3(shadowMask(r.p,l.p)))/length(r.p-l.p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = ( fragCoord.xy / resolution.xy )*2.-1.;\n\tuv.x*= resolution.x/resolution.y;\n\tuv*=2.;\n\tvec2 m = vec2(time*.1,-abs(sin(time/40.)*1.));\n    //m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\n\tfloat camz = PI;\n\tvec3 ca = vec3(\n\t\tPI/2.+m.y*PI/2.,\n\t\tPI/2.+m.x*PI/1.,\n\t\t0\n\t);\n\t\n\tmat3 rotX = mat3(\n\t\t1,         0,        0,\n\t\t0, sin(ca.x),cos(ca.x),\n\t\t0,-cos(ca.x),sin(ca.x)\n\t);\n\t\n\tmat3 rotY = mat3(\n\t\t sin(ca.y),0, cos(ca.y),\n\t\t0,         1,         0,\n\t\t-cos(ca.y),0, sin(ca.y)\n\t);\n\tvec3 camera = vec3(0,0,camz)*rotX*rotY;\n\tvec3 plane = (vec3(uv,0)*rotX*rotY);\n\t\n\tRay r = Ray(camera,camera,normalize(plane-camera),vec3(0),0.,0.);\n    \n    init();\n\tmarch(r,1);\n\t\n\tvec3 c = vec3(.2);\n\tN = sNormal(r.p);\n\tV = -r.dir;\n    \n    Ray fr = r;\n\t\n\tfor(int i = 0;i<LIGHTS;i++){\n        lNormal(l[i],r);\n        c += getColor(l[i],r);\n    }\n    vec3 fc = c;\n    //c *= 0.;\n    \n    for( int i = 0;i< MAX_REF;i++){\n        r.dir = reflect(r.dir,N);\n        r.o = r.p + N * MIN_DIST;\n        r.p = r.o;\n        r.dist = 0.;\n        \n        march(r,1);\n        N = sNormal(r.p);\n        if(r.rl > 20.)break;\n        V = -r.dir;\n    \n        for(int i = 0;i<LIGHTS;i++){\n            lNormal(l[i],r);\n            c += (getColor(l[i],r)*pow(.9,float(i))*2./r.rl );\n            if(length(r.p-l[i].p)-.1 <= MIN_DIST) c = l[i].c*5.;\n        }\n    }\n    //c += fc*.1+.2;\n    //c *= fc;\n    \n    //c *= 1./vec3(r.rl);\n\t\t\n\tif(fr.dist > MAX_DIST) c = vec3(.1);\n    for(int i = 0;i< LIGHTS;i++){\n        if(length(fr.p-l[i].p)-.1 <= MIN_DIST) c = l[i].c*5.;\n    }\n\n\tfragColor = vec4( c, 1.0 );\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}