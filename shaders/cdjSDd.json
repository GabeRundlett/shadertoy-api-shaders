{
    "Shader": {
        "info": {
            "date": "1671108482",
            "description": "my four raytracer!",
            "flags": 0,
            "hasliked": 0,
            "id": "cdjSDd",
            "likes": 4,
            "name": "my four raytracer",
            "published": 3,
            "tags": [
                "raytracing",
                "ray",
                "shadow",
                "light",
                "sphere",
                "green",
                "reflections",
                "box",
                "occlusion",
                "flare",
                "chess",
                "dark",
                "raycaster",
                "softshadow",
                "crosshair"
            ],
            "usePreview": 1,
            "username": "SONENEIS",
            "viewed": 362
        },
        "renderpass": [
            {
                "code": "const float pi = 3.14159265;\nconst float tau = pi * 2.0;\n\nmat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\nfloat dot2(vec3 v){return dot(v,v);}\n\nfloat hash(float v){return fract(sin(v*dot(vec2(737.873,777.873),vec2(173.873,515.526)))*82723.782);}\nfloat hash(vec2 uv){return fract(sin(dot(uv,vec2(173.873,515.526)))*82723.782);}\nfloat hash(vec3 uv){return fract(sin(dot(uv,vec3(173.873,515.526,726.873)))*82723.782);}\n\n#define BUFFERS\n\n// transformation matrices\nmat4 mDefault(){\n\treturn mat4(\n\t\tvec4(1,0,0,0),\n\t\tvec4(0,1,0,0),\n\t\tvec4(0,0,1,0),\n\t\tvec4(0,0,0,1)\n\t);\n}\nmat4 mRotateX(float a){\n\tfloat s=sin(a),c=cos(a);\n\treturn mat4(\n\t\tvec4(c,-s,0,0),\n\t\tvec4(s,c,0,0),\n\t\tvec4(0,0,1,0),\n\t\tvec4(0,0,0,1)\n\t);\n}\nmat4 mRotateY(float a){\n\tfloat s=sin(a),c=cos(a);\n\treturn mat4(\n\t\tvec4(c,0,s,0),\n\t\tvec4(0,1,0,0),\n\t\tvec4(-s,0,c,0),\n\t\tvec4(0,0,0,1)\n\t);\n}\nmat4 mRotateZ(float a){\n\tfloat s=sin(a),c=cos(a);\n\treturn mat4(\n\t\tvec4(1,0,0,0),\n\t\tvec4(0,c,-s,0),\n\t\tvec4(0,s,c,0),\n\t\tvec4(0,0,0,1)\n\t);\n}\nmat4 mRotateAll(float x,float y,float z){\n\treturn mRotateX(x) * mRotateY(y) * mRotateZ(z);\n}\nmat4 mTranslate(vec3 p){\n\treturn mat4(\n\t\tvec4(1,0,0,0),\n\t\tvec4(0,1,0,0),\n\t\tvec4(0,0,1,0),\n\t\tvec4(p.x,p.y,p.z,1)\n\t);\n}\n\nstruct Hit{\n\tint id;\n\tfloat d;\n\tint type; // intersect primitive id\n\tvec3 nor;\n\tvec3 v3a;\n\tvec4 v4a;\n\tmat4 imat;\n\tmat4 mat;\n};\nstruct Hit2{\n\tint type;\n\tint id;\n\tvec3 v3a;\n\tvec4 v4a;\n\tmat4 imat;\n\tmat4 mat;\n};\n\nHit iUnion(Hit a,Hit b){\n if(b.d > 0.0 && b.d < a.d) return b;\n else return a;\n}\n\n// raytracer primitives\n\nHit iPlane(int id,vec3 ro,vec3 rd,vec4 pln){\n  Hit hit;\n  hit.d = -(dot(ro,normalize(pln.xyz))+pln.w)/dot(rd,pln.xyz);\n  hit.id = id;\n  hit.type = 0;\n  hit.v4a = pln;\n  return hit;\n}\n\nHit iSphere(int id,vec3 ro,vec3 rd,vec4 sph){\n\tHit hit;\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\thit.d = -b - sqrt(h);\n\tif(h < 0.0) hit.d = -1.0;\n\thit.id = id;\n  hit.type = 1;\n\thit.v4a = sph;\n  return hit;\n}\n\nHit iBox(int id,vec3 ro,vec3 rd,vec3 size,mat4 mat,mat4 imat){\n  rd = (imat*vec4(rd,0.0)).xyz;\n\tro = (imat*vec4(ro,1.0)).xyz;\n\tHit hit;\n\tvec3 m = 1.0/rd;\n\tvec3 n = m*ro;\n\tvec3 k = abs(m)*size;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max(max(t1.x,t1.y),t1.z);\n\tfloat tF = min(min(t2.x,t2.y),t2.z);\n\thit.d = tN;\n\tif(tN>tF || tF<0.0) hit.d = -1.0;\n\thit.nor = (tN>0.0) ? step(vec3(tN),t1) : step(t2,vec3(tF));\n\thit.nor *= -sign(rd);\n\thit.nor = (mat*vec4(hit.nor,0.0)).xyz;\n\thit.id = id;\n\thit.type = 2;\n\thit.v3a = size;\n\thit.imat = imat;\n\thit.mat = mat;\n\treturn hit;\n}\n\n// call of the primitives to the scene\n\nHit2 objPlane(int id,vec4 pln){\n\tHit2 obj;\n\tobj.type = 0;\n\tobj.id = id;\n\tobj.v4a = pln;\n  return obj;\n}\n\nHit2 objSphere(int id,vec4 sph){\n\tHit2 obj;\n\tobj.type = 1;\n\tobj.id = id;\n\tobj.v4a = sph;\n  return obj;\n}\n\nHit2 objBox(int id,vec3 size,mat4 mat){\n\tHit2 obj;\n\tobj.type = 2;\n\tobj.id = id;\n\tobj.v3a = size;\n\tobj.imat = inverse(mat);\n\tobj.mat = mat;\n  return obj;\n}\n\n//scene\nconst int scnLen = 13;\nHit2[scnLen] scn;\nvoid initScene(){\n\tscn[0] = objPlane(0,vec4(0.0,1.0,0.0,1.0));\n\tscn[1] = objSphere(1,vec4(0.0,0.0,0.0,1.0));\n\tscn[2] = objSphere(2,vec4(1.0,-0.5,1.25,0.5));\n\tscn[3] = objSphere(3,vec4(-0.75,-0.75,1.0,0.25));\n\tscn[4] = objSphere(4,vec4(sin(-iTime*2.0),sin(iTime*0.5),cos(-iTime),0.3));\n  scn[5] = objSphere(3,vec4(0.0,3.0,0.0,0.5));\n  scn[6] = objSphere(2,vec4(sin(iTime*0.07)*1.5,0.8,cos(iTime*0.07)*1.5,0.25));\n\tscn[7] = objBox(5,vec3(0.5,0.25,0.75),mTranslate(vec3(1.75,-0.5,-1.0))*mRotateAll(iTime,iTime,iTime));\n\tscn[8] = objBox(5,vec3(1.0,0.25,1.0),mTranslate(vec3(3.0,-0.75,1.5))*mRotateY(iTime*0.5));\n\tscn[9] = objPlane(6,vec4(0.0,0.0,1.0,4.5));\n\tscn[10] = objBox(6,vec3(1.0),mTranslate(vec3(-3.5,0.0,-3.5)));\n\tscn[11] = objPlane(6,vec4(1.0,0.0,0.0,4.5));\n\tscn[12] = objBox(6,vec3(0.5),mTranslate(vec3(1.0,-0.5,-2.0)));\n}\n\nHit raycast(vec3 ro,vec3 rd){\n\tHit h;\n\th.d = 9999999999999999999.9;\n\th.id = -1;\n\n  for(int i=0;i<scnLen;i++){\n  \tHit2 s = scn[i];\n  \tif(scn[i].type == 0){ //plane\n  \t\th = iUnion(h,iPlane(s.id,ro,rd,s.v4a));\n  \t}else if(scn[i].type == 1){ //sphere\n  \t\th = iUnion(h,iSphere(s.id,ro,rd,s.v4a));\n  \t}else if(scn[i].type == 2){ //box\n  \t\th = iUnion(h,iBox(s.id,ro,rd,s.v3a,s.mat,s.imat));\n  \t}\n  }\n\n\treturn h;\n}\n\nvec3 getNormal(Hit h,vec3 p){\n\tvec3 nor = vec3(0.0);\n\n  if(h.type == 0){ //plane\n  \tnor = h.v4a.xyz;\n  }else if(h.type == 1){ //sphere\n  \tnor = (p-h.v4a.xyz) / h.v4a.w;\n  }else if(h.type == 2){ //sphere\n  \tnor = h.nor;\n  }\n\n\treturn normalize(nor);\n}\n\nfloat getOcc(Hit h,vec3 n,vec3 p){\n  float res = 1.0;\n  float occBox = 1.0;\n\n  for(int i=0;i<scnLen;i++){\n  \tHit2 s = scn[i];\n\n  \tif(scn[i].type == 2){ //box\n  \t  float occ = 0.0;\n\n      vec3 pp = (s.imat*vec4(p,1.0)).xyz;\n      vec3 nn = (s.imat*vec4(n,0.0)).xyz;\n\n      vec3 f = s.v3a * sign(pp);\n      vec3 i = sign(s.v3a - abs(pp));\n\n      vec3 v0 = normalize(vec3( 1.0, 1.0,-1.0)*f - pp);\n      vec3 v1 = normalize(vec3( 1.0, i.x, i.x)*f - pp);\n      vec3 v2 = normalize(vec3( 1.0,-1.0, 1.0)*f - pp);\n      vec3 v3 = normalize(vec3( i.z, i.z, 1.0)*f - pp);\n      vec3 v4 = normalize(vec3(-1.0, 1.0, 1.0)*f - pp);\n      vec3 v5 = normalize(vec3( i.y, 1.0, i.y)*f - pp);\n\n      occ += dot(nn,normalize(cross(v0,v1)))*acos(dot(v0,v1));\n      occ += dot(nn,normalize(cross(v1,v2)))*acos(dot(v1,v2));\n      occ += dot(nn,normalize(cross(v2,v3)))*acos(dot(v2,v3));\n      occ += dot(nn,normalize(cross(v3,v4)))*acos(dot(v3,v4));\n      occ += dot(nn,normalize(cross(v4,v5)))*acos(dot(v4,v5));\n      occ += dot(nn,normalize(cross(v5,v0)))*acos(dot(v5,v0));\n\n      occ = clamp(abs(occ)/tau,0.0,1.0);\n      occ = pow(occ,0.75);\n\n      occBox *= 1.0 - occ;\n    }\n  }\n\n  for(int i=0;i<scnLen;i++){\n  \tHit2 s = scn[i];\n\n  \tif(scn[i].type == 0){ //plane\n  \t  float occ = 0.0;\n\n      float b = dot(p,s.v4a.xyz);\n      float a = 1.0-clamp(b+s.v4a.w,0.0,1.0);\n      if(a < 0.99999) occ = pow(a,2.0);\n\n      res *= 1.0 - occ;\n  \t}else if(scn[i].type == 1){ //sphere\n      vec3 r = s.v4a.xyz - p;\n      float l = length(r);\n      float d = dot(n,r);\n      float occ = d;\n\n  \t  if(d < s.v4a.w) occ = clamp((d+s.v4a.w)/(2.0*s.v4a.w),0.0,1.0) * s.v4a.w;\n      occ = clamp(occ*(s.v4a.w*s.v4a.w)/(l*l*l),0.0,1.0);\n\n      res *= 1.0 - occ;\n  \t}/*else if(scn[i].type == 2){ //box\n      //empty\n  \t}*/\n  }\n\n  if(h.type != 2) res *= occBox;\n\n  return clamp(res*res*res,0.0,1.0);\n}\n\nfloat segShadow(vec3 ro,vec3 rd,vec3 pa,float sh){\n  float dm = dot(rd.yz,rd.yz);\n  float k1 = (ro.x-pa.x)*dm;\n  float k2 = (ro.x+pa.x)*dm;\n  vec2 k5 = (ro.yz+pa.yz)*dm;\n  float k3 = dot(ro.yz+pa.yz,rd.yz);\n  vec2 k4 = (pa.yz+pa.yz)*rd.yz;\n  vec2 k6 = (pa.yz+pa.yz)*dm;\n\n  for(int i=0;i<4;i++){\n    vec2 s = vec2(i&1,i>>1);\n    float t = dot(s,k4) - k3;\n\n    if(t > 0.0)\n      sh = min(sh,dot2(vec3(clamp(-rd.x*t,k1,k2),k5-k6*s)+rd*t)/(t*t));\n  }\n\n  return sh;\n}\n\nfloat getSoftShadow(Hit h,vec3 ro,vec3 rd,float sk){\n\tfloat sha = 1.0;\n\n  for(int i=0;i<scnLen;i++){\n  \tHit2 s = scn[i];\n\n    /*if(scn[i].type == 0){ //plane\n      //empty\n    }else*/if(scn[i].type == 1){ //sphere\n      vec3 oc = ro - s.v4a.xyz;\n      float b = dot(oc,rd);\n      float c = dot(oc,oc) - s.v4a.w*s.v4a.w;\n      float h = b*b - c;\n\n      float d = sqrt(max(0.0,s.v4a.w*s.v4a.w-h)) - s.v4a.w;\n      float t = -b - sqrt(max(h,0.0));\n      float s = (t<0.0) ? 1.0 : smoothstep(0.0,1.0,sk*d/t);\n\n      sha *= s;\n    }else if(scn[i].type == 2){ //box\n \t   vec3 rdd = (s.imat*vec4(rd,0.0)).xyz;\n\t    vec3 roo = (s.imat*vec4(ro,1.0)).xyz;\n\n      vec3 rad = s.v3a;\n      vec3 m = 1.0/rdd;\n      vec3 n = m*roo;\n      vec3 k = abs(m)*rad-0.00001;\n\n      vec3 t1 = -n - k;\n      vec3 t2 = -n + k;\n\n      float tN = max(max(t1.x,t1.y),t1.z);\n\t    float tF = min(min(t2.x,t2.y),t2.z);\n\n      float s = 1.0;\n      s = segShadow(roo.xyz,rdd.xyz,rad.xyz,s);\n      s = segShadow(roo.yzx,rdd.yzx,rad.yzx,s);\n      s = segShadow(roo.zxy,rdd.zxy,rad.zxy,s);\n      s = clamp(sk*sqrt(s),0.0,1.0);\n      s = s*s*(3.0-2.0*s);\n\n      if(tN<tF && tF>0.0) s = 0.0;\n\n      sha *= s;\n    }\n  }\n\n\treturn sha;\n}\n\nvec3 getMaterial(vec3 ro,vec3 rd,Hit h){\n\tvec3 pos = ro+rd*h.d;\n\tvec3 nor = getNormal(h,pos);\n  vec3 mate = vec3(0.0);\n\n  if(h.id == 0){\n    mate += 0.1+0.9*mod(floor(pos.x*5.0)+floor(pos.z*5.0),2.0);\n  }else if(h.id == 1){\n  \tmate += vec3(1.0,0.0,0.0);\n  }else if(h.id == 2){\n  \tmate += vec3(0.0,1.0,0.0);\n  }else if(h.id == 3){\n  \tmate += vec3(0.0,0.0,1.0);\n  }else if(h.id == 4){\n  \tmate += vec3(0.5,0.5,1.0) * mod(floor((atan(nor.z,nor.x)/pi)*8.0)+floor(nor.y*3.0),2.0);\n  }else if(h.id == 5){\n  \tvec3 q = (h.imat*vec4(pos,1.0)).xyz;\n  \tvec3 n = (h.imat*vec4(nor,0.0)).xyz;\n  \tvec3 x = texture(iChannel0,q.yz).rgb;\n  \tvec3 y = texture(iChannel0,q.xz).rgb;\n  \tvec3 z = texture(iChannel0,q.xy).rgb;\n  \tmate += x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n  \tmate = pow(mate,vec3(3.5))*2.0;\n  }else if(h.id == 6){\n  \tvec3 x = texture(iChannel1,pos.yz).rgb;\n  \tvec3 y = texture(iChannel1,pos.xz).rgb;\n  \tvec3 z = texture(iChannel1,pos.xy).rgb;\n  \tmate += x*abs(nor.x) + y*abs(nor.y) + z*abs(nor.z);\n  \tmate = pow(mate,vec3(2.2))*2.0;\n  }else mate += 1.0;\n\n  return mate;\n}\n\nfloat dirLight(vec3 rd,Hit h,vec3 lpos,float r){\n\tfloat lig = 1.0;\n\n\tfloat a = length(rd-normalize(lpos));\n\tif(h.id == -1) lig = a;\n\n\treturn r/250.0 / (lig*lig);\n}\n\nfloat pointLight(vec3 ro,vec3 rd,Hit h,vec3 lpos,float r){\n\tfloat lig = 1.0;\n\n\tfloat dt = dot(lpos-ro,rd);\n\tdt = clamp(dt,0.0,h.d);\n\tvec3 p = ro+rd*dt;\n\tlig = length(p-lpos);\n\n\treturn r/5.0 / (lig*lig);\n}\n\nvec3 render3D(vec2 uv){\n\tvec3 col = vec3(0.0);\n\n  initScene();\n\n  uv += hash(uv+iTime)*2.0 / iResolution.y;\n\n  vec3 ro = vec3(0.25,0.0,4.0);\n  vec3 rd = normalize(vec3(uv,-2.0));\n\n  rd += hash(rd+iTime)*0.2/iResolution.y;\n\n  // \"\"\" realistic movement \"\"\"\n  #if 1\n  ro.y = abs(sin(iTime*5.0))*0.1-0.25;\n  rd.yz *= rot(cos(iTime*5.0)*0.025);\n  rd.xy *= rot(sin(iTime*10.0)*0.01);\n  rd.xz *= rot(sin(iTime*5.0)*0.025);\n  ro.z -= sin(iTime*7.0)*0.05;\n  ro.z -= sin(iTime)*0.05;\n  #endif\n\n  //orbit scene\n  ro.xz *= rot(iTime/3.0);\n  rd.xz *= rot(iTime/3.0);\n\n  Hit h = raycast(ro,rd);\n  vec3 pos = ro + rd*h.d;\n\n  vec3 bgCol = vec3(0.2,0.2,0.2);\n  vec3 fogCol = vec3(0.0,0.0,0.0);\n  vec3 bg = mix(fogCol,bgCol,clamp(rd.y,0.0,1.0));\n\n  vec3 ligPos = vec3(1.0);\n  vec3 ligDir = normalize(ligPos-pos); //pointlight\n  vec3 ligCol = vec3(0.9,0.7,0.8);\n\n  if(h.d > 0.0 && h.id != -1){\n  \tvec3 nor = getNormal(h,pos);\n    float occ = getOcc(h,nor,pos);\n  \tvec3 mate = getMaterial(ro,rd,h);\n    vec3 ref = reflect(rd,nor);\n\n    { // pink light point\n      float dif = clamp(dot(nor,ligDir),0.0,1.0);\n      float backdif = clamp(dot(nor,-ligDir),0.0,1.0);\n    \t//float sha = step(1.0,raycast(pos,ligDir).d); // It does not make infinite shadows.\n    \tfloat sha = getSoftShadow(h,pos,ligDir,4.0); // the projection is completely wrong.\n    \t//float sha = step(length(ligPos-pos),raycast(pos,ligDir).d); // 100% functional but does not soft shadow.\n    \tfloat spe = pow(clamp(dot(ref,ligDir),0.0,1.0),10.0);\n    \tfloat fre = clamp(pow(1.0-dot(nor,-rd),5.0),0.0,1.0);\n      float speref = getSoftShadow(h,pos,ref,1.0)*0.5;\n      vec3 lc = pow(ligCol,vec3(2.2));\n      dif *= sha;\n      dif += 0.01;\n      col += mate;\n      col = mix(col,bgCol,fre);\n      col *= dif;\n      col += lc * spe * sha * speref;\n      col *= lc;\n      col = clamp(col,0.0,1.0);\n    }\n\n    { //sky\n    \tfloat dif = clamp(nor.y*0.5+0.5,0.0,1.0);\n    \tfloat speref = getSoftShadow(h,pos,ref,4.0);\n    \tfloat spe = pow(clamp(ref.y*0.5+0.5,0.0,1.0),2.0);\n\n      col += 0.00075 * dif;\n    \tcol += 0.00075 * spe * speref;\n    }\n\n    { //back\n      float dif = clamp(dot(nor,-ligDir),0.0,1.0);\n    \tfloat spe = clamp(dot(ref,-ligDir),0.0,1.0);\n\n      col += mate * pow(dif,3.0)*0.0025;\n      col += mate * pow(spe,4.0)*0.00125;\n    }\n\n    { //bounce\n    \tfloat dif = clamp(-nor.y,0.0,1.0);\n      col.r += 0.00175 * pow(dif,2.0);\n    }\n\n    col = clamp(col,0.0,1.0) * occ;\n  }\n\n  //gamma correction\n  col = clamp(pow(col,vec3(1.0/2.2)),0.0,1.0);\n\n  //fog & background\n  col = mix(col,bg,clamp(1.0-exp(-0.025*h.d*h.d),0.0,1.0));\n\n  // draw lights //\n\n  //col = mix(col,ligCol,dirLight(rd,h,ligPos,0.125));\n  col = mix(col,ligCol,pointLight(ro,rd,h,ligPos,0.125));\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.0);\n\n  col += render3D(uv);\n\n  #ifdef BUFFERS\n  { //crosshair\n    vec2 p = uv * 0.5;\n    float b = sin(iTime*1.5)*1.0075;\n    float hb = sign(b) * pow(abs(b),64.0);\n    vec2 nuv = p * rot(hb);\n    vec2 q = abs(nuv.x)<abs(nuv.y)?nuv.xy:nuv.yx;\n    if(max(-(max(abs(q.x),abs(q.y))-0.005),max(abs(q.x)-0.002,abs(q.y)-0.01)) < 0.0) col = (1.0-col) * vec3(0,1,0);\n    uv *= rot(-hb);\n    if(max(-max(-(abs(p.y)-0.0075-abs(b*0.01)+0.005),-(abs(p.x)-0.0075-abs(b*0.01)+0.005)),abs(length(p)-0.02-(abs(b*b*b*b*b)*0.0025))-0.001) < 0.0) col = (1.0-col) * vec3(0,1,0);\n  }\n  //vignete\n  col += vec3(0,1,0)*length(fragCoord/iResolution.xy-0.5)*0.025;\n  #endif\n\n  fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}