{
    "Shader": {
        "info": {
            "date": "1667331045",
            "description": "interact with mouse",
            "flags": 0,
            "hasliked": 0,
            "id": "mdj3zW",
            "likes": 28,
            "name": "My first volumetric clouds",
            "published": 3,
            "tags": [
                "volume",
                "fbm",
                "light",
                "fog",
                "smoke"
            ],
            "usePreview": 1,
            "username": "kishimisu",
            "viewed": 665
        },
        "renderpass": [
            {
                "code": "/* I tried to make my own volumetric raymarcher for arbitrary shapes. \n*  It's a naive implementation consisting of a basic raymarcher extended with an inside/outside \n*  awareness that collects density & light when inside a shape (distance field < 0).\n*  I think it can be optimized by using fixed steps when marching inside a volume.    */\n\n#define MAX_ITER 300.\n#define MAX_DIST 8.\n#define ABSORPTION 17.\n\n#define hash33(p) fract(sin( (p) * mat3( 127.1,311.7,74.7 , 269.5,183.3,246.1 , 113.5,271.9,124.6) ) * 43758.5453123)\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n// noise and fbm are from https://www.shadertoy.com/view/XtS3DD\nfloat noise(in vec3 p) {\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod(iChannel0, (tap+0.5)/256.0, 0.0).yx;\n\treturn mix(rz.x, rz.y, fp.z);\n}\n\nfloat fbm(in vec3 x) {\n    x += vec3(iTime*.015, iTime*.035, 0.);\n    \n    float rz = 0.;\n    float a = .35;\n    for (int i = 0; i<4; i++) {\n        rz += noise(x)*a;\n        a*=.35;\n        x*= 4.;\n    }\n    return rz - .25;\n}\n\n// signed distance to volume\nfloat vol(vec3 p) {\n    p.y -= .2;\n    float r = fbm(p) + p.y*.4 + .08 + .05*max(0., 1.-length(p));\n    float sphere = length(p) - 1.;\n    return max(sphere, r*.9);\n}\n\n// get light visibility at point\nfloat sampleLight(vec3 ro) {\n    vec3 rd = normalize(-ro + vec3(0.,.2,0.));\n    float t = 0., visibility = 1., stepSize = 0.005;\n    \n    for (int i = 0; i < 20; i++) {\n        vec3 p = ro + t*rd;\n        float d = vol(p);\n        t += max(stepSize, d) + hash33(p).x*.002;\n        if (d < 0.) visibility *= exp(-stepSize*ABSORPTION);\n    }\n    \n    return visibility;\n}\n\nvoid initRayOriginAndDirection(vec2 fragCoord, inout vec3 ro, inout vec3 rd) {\n    vec2 uv = ( fragCoord - .5*iResolution.xy )/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    float d = 1.75;\n    ro = vec3(d*cos(iTime*.1), 1.5, d*sin(iTime*.1));\n    ro.xz *= rot(-m.x*2.);\n    \n    float z = iMouse.z == 0. ? 1.4 : 1.2 + m.y;\n\n    vec3 f = normalize(-ro),\n         r = normalize(cross(vec3(0,1,0), f)),\n         u = cross(f,r),\n         c = ro+f*z,\n         i = c + uv.x*r + uv.y*u;\n         \n    rd = normalize(i-ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 ro, rd;\n    \n    initRayOriginAndDirection(fragCoord, ro, rd);\n    \n    float visibility = 1.;\n    vec3 vColor = vec3(0.), color = vec3(0.,0.,.1);\n    \n    float t = 0., eps = 0.0005;\n    float inside = vol(ro) < 0. ? 1. : 0.;\n            \n    for (float i = 0.; i < MAX_ITER; i++) {\n        vec3 p = ro + t*rd;\n        \n        float d = vol(p);\n        t += abs(d) + 0.001*t;\n        \n        bool isInsideVolume = mod(inside, 2.) > .5;\n        \n        if (!isInsideVolume) { \n            if (d < eps) {  \n                inside++; t += eps*10.; // enter volume\n            }\n        } else {    \n            if (d > -eps) {  \n                inside++; t += eps*10.; // exit volume\n            } else {\n                // sample density & light\n                float prev = visibility;\n                visibility *= exp(-abs(d)*ABSORPTION);\n                \n                float absorption = prev - visibility;\n                vColor += absorption * sampleLight(p) * (vec3(1.3, 1.,.8) + fbm(p)*2.);\n                        \n                if (visibility <= .01 || dot(vColor, vColor) >= 3.) break;         \n            }\n        }\n        \n        if (t > MAX_DIST) break;\n    }\n\n    color = vColor + color * visibility;\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}