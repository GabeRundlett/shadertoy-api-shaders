{
    "Shader": {
        "info": {
            "date": "1504648946",
            "description": "Example of dispersion in a transparent material, to get those sweet rainbow effects.",
            "flags": 0,
            "hasliked": 0,
            "id": "XlscDH",
            "likes": 92,
            "name": "Dispersion",
            "published": 3,
            "tags": [
                "spectrum",
                "refraction",
                "glass",
                "dispersion"
            ],
            "usePreview": 1,
            "username": "tdhooper",
            "viewed": 4266
        },
        "renderpass": [
            {
                "code": "/*\n\n\tDispersion\n\t----------\n\n\tCombines multiple samples that vary the refractive\n    index and wavelength.\n\n    This gets expensive for high dispersion values that\n    need more samples to reduce banding.\n\n    I don't think this is physically correct in any way,\n    as I'm using a very crude method to split the\n    visible spectrum.\n\n*/\n\n\n// --------------------------------------------------------\n// CONFIG\n// --------------------------------------------------------\n\n// #define DEBUG\n\nconst float MAX_TRACE_DISTANCE = 5.;\nconst float INTERSECTION_PRECISION = .001;\nconst int NUM_OF_TRACE_STEPS = 50;\n\nconst float REFRACTION_BOUNCES = 3.;\nconst float DISPERSION_SAMPLES = 20.; // Higher = slower but smoother blending\nconst float WAVELENGTH_BLEND_MULTIPLIER = 5.;\n\nconst float DISPERSION = .15; // Try changing\n\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smax(float a, float b, float r) {\n    float m = max(a, b);\n    if ((-a < r) && (-b < r)) {\n        return max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n    } else {\n        return m;\n    }\n}\n\n\n// --------------------------------------------------------\n// Rotation controls\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n\nfloat time;\n\nmat3 sphericalMatrix(float theta, float phi) {\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 mouseRotation(vec2 xy) {\n    vec2 p = (-iResolution.xy + 2. * iMouse.xy) / iResolution.y;\n    \n    if (iMouse.x != 0. && iMouse.y != 0.) {\n        xy = p;\n    }\n\n    float rx, ry;\n\n    rx = (xy.y * .25) * PI;\n    ry = (-xy.x * .25) * PI;\n\n    return sphericalMatrix(rx, ry);\n}\n\n\nmat3 modelRotation() {\n    vec2 defaultRotation = vec2(sin(time * PI * 4.) * .1 + .5);\n    pR(defaultRotation, sin(time * PI * 2.) * .1);\n    \n    float a = time;\n    float r = mix(.2, .8, sin(time * PI * 1.) * .5 + .5);\n\n    defaultRotation = vec2(\n        sin(a * PI * 2.) * r,\n        cos(a * PI * 2.) * r\n    );\n\n    mat3 m = mouseRotation(defaultRotation);\n    return m;\n}\n\n\n// --------------------------------------------------------\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// Materials\n// --------------------------------------------------------\n\nstruct Material {\n    int id;\n    bool transparent;\n    float refractiveIndex;\n    float dispersion;\n};\n\nMaterial transparentMaterial = Material(\n    0,\n    true,\n    1. / 1.333,\n    DISPERSION\n);\n\nMaterial backMaterial = Material(\n    1,\n    false,\n    0.,\n    0.\n);  \n\n\n// --------------------------------------------------------\n// Modelling\n// --------------------------------------------------------\n\nbool insideTransparency = false;\nbool enableTransparency = true;\n\nstruct Model {\n    float dist;\n    vec2 uv;\n    Material material;\n};\n\nModel newModel() {\n    return Model(\n        1e12,\n        vec2(0),\n        backMaterial\n    );\n}\n\n// checks to see which intersection is closer\nModel opU( Model m1, Model m2 ){\n    if (m1.dist < m2.dist) {\n        return m1;\n    } else {\n        return m2;\n    }\n}\n\nModel backModel(vec3 p) {\n    Model model = newModel();\n    p.z += 2.;\n    model.dist = dot(p, vec3(0,0,1)) - .7;\n    model.uv = vec2(p.x, p.y);\n    return model;\n}\n\nModel mainModel(vec3 p) {\n    Model model = newModel();\n\n    float part, d;\n    float indentOffset = .1;\n    float indentSize = .2;\n    float indentSmooth = .2;\n\n    // Sphere\n    d = length(p) - .3;\n\n    // Mirror\n    p.z *= sign(p.z);\n\n    // Indent\n    p.z -= indentSize + indentOffset;\n    part = length(p) - indentSize;\n    d = smax(d, -part, indentSmooth);\n\n    model.dist = d;\n    return model;\n}\n\nModel transparentModel(vec3 p) {\n    if ( ! enableTransparency) return newModel();\n\n    Model model = mainModel(p);\n    \n    if (insideTransparency) model.dist *= -1.;\n\n    model.material = transparentMaterial;\n    return model;\n}\n\nModel map( vec3 p ){\n    Model model = backModel(p);\n    p *= modelRotation();\n    model = opU(model, transparentModel(p));\n    return model;\n}\n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from: https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n\nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    Model model;\n\n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(ray.origin + ray.direction * ray.len);\n        currentDist = model.dist;\n        ray.len += currentDist;\n    }\n\n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n\n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, vec3(0));\n}\n\n\n// --------------------------------------------------------\n// Shading\n// --------------------------------------------------------\n\nfloat makeDots(vec2 uv, float repeat, float size) {\n    uv = mod(uv, 1. / repeat) * repeat;\n    uv -= .5;\n    return smoothstep(size, size * .8, length(uv));\n}\n\nfloat makeLine(float x, float thick) {\n    float start = .5 - thick * .5;\n    float end = .5 + thick * .5;\n    float aa = .01;\n    return smoothstep(start, start + aa, x) - smoothstep(end -aa, end, x);\n}\n\nfloat makeLines(float x, float repeat, float thick) {\n    x = mod(x, 1. / repeat) * repeat;\n    return makeLine(x, thick);\n}\n\nvec3 shadeSurface(Hit hit) {\n    vec3 color = vec3(0);\n\n    if (hit.isBackground) {\n        return color;\n    }    \n    \n    if (hit.model.material.id == 1) {\n        vec2 uv = hit.model.uv;\n        float repeat = 5.;\n        color += makeDots(uv + .5 / repeat, repeat, .1);\n        color += makeLines(uv.x, repeat, .025);\n        color += makeLines(uv.y, repeat, .025);\n    }\n\n    return color;\n}\n\n\n// --------------------------------------------------------\n// Refraction & Dispersion\n// Some refraction logic from https://www.shadertoy.com/view/lsXGzH\n// --------------------------------------------------------\n\nHit marchTransparent(Hit hit, float wavelength) {\n    enableTransparency = true;\n    insideTransparency = false;\n\n    for (float i = 0.; i < REFRACTION_BOUNCES; i++) {\n        if (hit.isBackground || ! hit.model.material.transparent) {\n            return hit;\n        } else {\n\n            // Adjust refractive index for wavelength and dispersion amount\n            float refractiveIndex = hit.model.material.refractiveIndex;\n            float riMin = refractiveIndex;\n            float riMax = refractiveIndex * (1. + hit.model.material.dispersion);\n            refractiveIndex = mix(riMin, riMax, wavelength);\n\n            // Invert when moving from the transparent object to air\n            if (insideTransparency) {\n                refractiveIndex = 1. / refractiveIndex;\n            }\n\n            vec3 rayDirection = refract(hit.ray.direction, hit.normal, refractiveIndex);\n            if (rayDirection == vec3(0)) {\n                // Total internal reflection\n                rayDirection = reflect(hit.ray.direction, hit.normal);\n            } else {\n                insideTransparency = ! insideTransparency;\n            }\n\n            // Don't let the ray get trapped inside a transparent object\n            if (i == REFRACTION_BOUNCES - 1.) {\n                enableTransparency = false;\n                insideTransparency = false;\n            }\n\n            // Move away from the surface before marching\n            float separation = 0.01;\n            float startDistance = separation / abs(dot(rayDirection, hit.normal));\n\n            vec3 rayOrigin = hit.pos + startDistance * rayDirection;\n            CastRay castRay = CastRay(rayOrigin, rayDirection);\n            hit = raymarch(castRay);\n        }\n    }\n    return hit;\n}\n\nvec3 shadeTransparentSurface(Hit hit) {\n    float wavelength;\n    vec3 sampleColor;\n    vec3 color = vec3(0);\n\n    // March for each wavelength and blend together\n    for(float r = 0.; r < DISPERSION_SAMPLES; r++){\n        wavelength = r / DISPERSION_SAMPLES;\n        Hit hit2 = marchTransparent(hit, wavelength);\n        sampleColor = shadeSurface(hit2) * spectrum(wavelength);\n        // I don't have a model for correctly blending wavelengths together\n        // so there's a fudge multiplier to stop the result going grey\n        sampleColor /= DISPERSION_SAMPLES / WAVELENGTH_BLEND_MULTIPLIER;\n        color += sampleColor;\n    }\n\n    return color;\n}\n\n\n// --------------------------------------------------------\n// Main\n// --------------------------------------------------------\n\n// https://www.shadertoy.com/view/Xl2XWt\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in vec3 up )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,up));\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 getColor(vec2 p) {\n\n    vec3 camUp = vec3(0,-1,0);\n    vec3 camTar = vec3(0.);\n    vec3 camPos = vec3(0,0,1.25);\n\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camUp);\n    float focalLength = 2.;\n    vec3 rayDirection = normalize(camMat * vec3(p, focalLength));\n\n    CastRay castRay = CastRay(camPos, rayDirection);\n    Hit hit = raymarch(castRay);\n\n    #ifdef DEBUG\n        return hit.normal * .5 + .5;\n    #endif\n\n    if ( hit.isBackground || ! hit.model.material.transparent) {\n        return shadeSurface(hit);\n    }\n\n    return shadeTransparentSurface(hit);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;    \n    vec2 m = iMouse.xy / iResolution.xy;\n\n    time = iTime;\n    time /= 4.;\n    time = mod(time, 1.);\n    \n    p /= 1.5;\n\n    vec3 color = getColor(p);\n\n    fragColor = vec4(color,1.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}