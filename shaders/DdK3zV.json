{
    "Shader": {
        "info": {
            "date": "1678821388",
            "description": "GPT-4 Creates its first shdaertoy! None of this code was made by me or edited in any way.",
            "flags": 0,
            "hasliked": 0,
            "id": "DdK3zV",
            "likes": 0,
            "name": "GPT-4 First Project",
            "published": 3,
            "tags": [
                "star",
                "gravity",
                "gpt"
            ],
            "usePreview": 0,
            "username": "incription",
            "viewed": 255
        },
        "renderpass": [
            {
                "code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 rayOrigin = vec3(0.0, 0.0, -2.0);\n    vec3 rayDirection = normalize(vec3(uv * 2.0 - 1.0, 1.0));\n\n    float d = raymarch(rayOrigin, rayDirection);\n\n    // Placeholder coloring, improve by adding shading and lighting effects\n    vec3 color = vec3(1.0 - d / maxDistance);\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n// Neutron star properties\nconst vec3 starPosition = vec3(0.0, 0.0, 0.0);\nconst float starRadius = 1.0;\nconst float magneticFieldStrength = 0.15; // Placeholder value\n\n// Raymarching parameters\nconst int maxSteps = 100;\nconst float maxDistance = 10.0;\nconst float surfaceThreshold = 0.001;\n\n\nconst vec3 magneticMoment = vec3(0.0, 1.0, 0.0); // Adjust to set the magnetic moment of the neutron star\n\nfloat distanceToStar(vec3 p) {\n    return length(p - starPosition) - starRadius;\n}\n\nvec3 magneticFieldStrengthAtPoint(vec3 point) {\n    vec3 r = point - starPosition;\n    float rLength = length(r);\n    vec3 rNormalized = normalize(r);\n\n    vec3 magneticField = (3.0 * dot(magneticMoment, rNormalized) * rNormalized - magneticMoment) / pow(rLength, 3.0);\n    return magneticField;\n}\n\nvec3 applyBirefringence(vec3 rayDirection, vec3 rayPosition, float magneticFieldStrength) {\n    float distanceToSurface = distanceToStar(rayPosition);\n    float bendFactor = magneticFieldStrength * distanceToSurface;\n    vec3 bendingDirection = normalize(cross(rayDirection, vec3(0.0, 1.0, 0.0)));\n\n    return normalize(rayDirection + bendingDirection * bendFactor);\n}\n\nfloat raymarch(vec3 rayOrigin, vec3 rayDirection) {\n    float totalDistance = 0.0;\n    vec3 currentPosition = rayOrigin;\n    for (int i = 0; i < maxSteps; ++i) {\n        currentPosition += rayDirection * totalDistance;\n        float starDistance = distanceToStar(currentPosition);\n\n        if (starDistance < surfaceThreshold || totalDistance > maxDistance) {\n            break;\n        }\n\n        totalDistance += starDistance;\n        rayDirection = applyBirefringence(rayDirection, currentPosition, magneticFieldStrength);\n    }\n\n    return totalDistance;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}