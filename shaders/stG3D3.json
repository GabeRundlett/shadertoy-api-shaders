{
    "Shader": {
        "info": {
            "date": "1638421858",
            "description": "A shader I made for my English class!",
            "flags": 32,
            "hasliked": 0,
            "id": "stG3D3",
            "likes": 0,
            "name": "English Project",
            "published": 3,
            "tags": [
                "creative"
            ],
            "usePreview": 0,
            "username": "Benny505",
            "viewed": 192
        },
        "renderpass": [
            {
                "code": "float EPSILON = 0.00001;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float coeff = 5.0;\n    float vertical = 0.7 / coeff;\n    float horizontal = 7.0 * coeff;\n    float height = 0.5;\n    \n    vec3 otherShape = texture(iChannel0, uv).rgb;\n    vec3 test = vec3(0.0, 0.0, 0.0);\n    \n    float maxRad = 0.4;\n    float rad = (1.0 / 10.0) * (0.8 + sin(1.0 * iTime));\n    rad = clamp(rad, 0.0, maxRad);\n    \n    float radicand = rad - (uv.x - 0.5) * (uv.x - 0.5);\n    float yUp = (iResolution.x / iResolution.y) * sqrt(radicand) + height;\n    float yDown = -1.0 * (iResolution.x / iResolution.y) * sqrt(rad - (uv.x - 0.5) * (uv.x - 0.5)) + height;\n    bool check = uv.y > yUp || uv.y < yDown || radicand < 0.0;\n    if (check)\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    else\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    \n    if (otherShape != test && !check)\n        fragColor = vec4(otherShape, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// returns the x y and m values based off of the y value of the pixel (uv.y)\nvec3 genCurve(vec2 point1, vec2 point2, vec2 point3, vec2 uv) {\n    // check to see if we should be generating curve\n    float x;\n    float y;\n    // mY is the second derivitave of y with respect to t\n    float mY;\n    // mX is the second derivitave of x with respect to t\n    float mX;\n    // decrease t step for a cleaner curve\n    for (float t = 0.0; t < 1.0; t+=0.001) {\n        // bezier curve equations for 3 points\n        x = (1.0 - t) * (1.0 - t) * point1.x + 2.0 * (1.0 - t) * t * point2.x + t * t * point3.x;\n        y = (1.0 - t) * (1.0 - t) * point1.y + 2.0 * (1.0 - t) * t * point2.y + t * t * point3.y;\n        // first derivitave mY = -2.0 * (1.0 - t) * point1.y + 2.0 * point2.y * (1.0 - (2.0 * t)) + 2.0 * t * point3.y;\n        // first derivitave mX = -2.0 * (1.0 - t) * point1.x + 2.0 * point2.x * (1.0 - (2.0 * t)) + 2.0 * t * point3.x;\n        mY = 2.0 * point1.y - 4.0 * point2.y + 2.0 * point3.y; // second derivitave\n        mX = 2.0 * point1.x - 4.0 * point2.x + 2.0 * point3.x; // second derivitave\n        // must get point in relation to y value\n        if (abs(uv.y - y) < 1.0 / iResolution.y)\n            return vec3(x, y, mY * mX);\n    }\n    return vec3(-1.0, -1.0, -1.0);\n}\n\n// returns the x and y values based off of the x value of the pixel (uv.x)\nvec2 getCurve(vec2 point1, vec2 point2, vec2 point3, vec2 uv) {\n    // check to see if we should be generating curve\n    float x;\n    float y;\n    // decrease t step for a cleaner curve\n    for (float t = 0.0; t < 1.0; t+=0.001) {\n        // bezier curve equations for 3 points\n        x = (1.0 - t) * (1.0 - t) * point1.x + 2.0 * (1.0 - t) * t * point2.x + t * t * point3.x;\n        y = (1.0 - t) * (1.0 - t) * point1.y + 2.0 * (1.0 - t) * t * point2.y + t * t * point3.y;\n        if (abs(uv.x - x) < 1.0 / iResolution.x)\n            return vec2(x, y);\n    }\n    return vec2(-1.0, -1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float maxScale = 0.1;\n    float scale = (0.01) * (0.6 + 30.0 * sin(iTime - 0.01));\n    if (scale > maxScale)\n        scale = maxScale;\n    if (scale < 0.0)\n        scale = 0.0;\n    float midX = 0.5;\n    float midY1 = 0.2;\n    float midY2 = midY1 + 0.4;\n    \n    // points\n    vec2 point1C1 = vec2((midX - 0.1), (midY1 + 0.5));\n    vec2 point2C1 = vec2((midX - 0.2), (midY1 + 0.4));\n    vec2 point3C1 = vec2(midX, midY1);\n    \n    vec2 point1C2 = vec2((midX + 0.1), (midY1 + 0.5));\n    vec2 point2C2 = vec2((midX + 0.2), (midY1 + 0.4));\n    vec2 point3C2 = vec2(midX, midY1);\n    \n    vec2 point1C3 = vec2((midX - 0.1), (midY2 + 0.1));\n    vec2 point2C3 = vec2((midX - 0.05), (midY2 + 0.15));\n    vec2 point3C3 = vec2(midX, midY2);\n    \n    vec2 point1C4 = vec2((midX + 0.1), (midY2 + 0.1));\n    vec2 point2C4 = vec2((midX + 0.05), (midY2 + 0.15));\n    vec2 point3C4 = vec2(midX, midY2);\n    \n    \n    bool draw = false;\n    vec3 vecC1 = genCurve(point1C1, point2C1, point3C1, uv);\n    vec3 vecC2 = genCurve(point1C2, point2C2, point3C2, uv);\n    vec3 vecC3 = genCurve(point1C3, point2C3, point3C3, uv);\n    vec3 vecC4 = genCurve(point1C4, point2C4, point3C4, uv);\n    vec2 vecC3X = getCurve(point1C3, point2C3, point3C3, uv);\n    vec2 vecC4X = getCurve(point1C4, point2C4, point3C4, uv);\n    \n    bool c1Check = vecC1.x == - 1.0 || (vecC1.z > 0.0 && uv.x < vecC1.x) || (vecC1.z < 0.0 && uv.x > vecC1.x);\n    bool c2Check = vecC2.x == - 1.0 || (vecC2.z > 0.0 && uv.x < vecC2.x) || (vecC2.z < 0.0 && uv.x > vecC2.x);\n    bool c3Check = vecC3.x == - 1.0 || vecC3X.x == - 1.0 || (vecC3X.y >= uv.y && vecC3.x != -1.0);\n    bool c4Check = vecC4.x == - 1.0 || vecC4X.x == - 1.0 || (vecC4X.y >= uv.y && vecC4.x != -1.0);\n    \n    if (!c3Check)\n        c4Check = false;\n    else if (!c4Check)\n        c3Check = false;\n    \n    if ((c1Check && c2Check && c3Check) || (c1Check && c2Check && c4Check))\n        draw = true;\n    \n    if (vecC1.x == -1.0 && vecC2.x == -1.0 && (vecC3.x == -1.0 || vecC3X.x == -1.0) && (vecC4.x == -1.0 || vecC4X.x == -1.0))\n        draw = false;\n    \n    if (draw)\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    else \n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}