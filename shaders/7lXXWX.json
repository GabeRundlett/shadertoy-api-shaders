{
    "Shader": {
        "info": {
            "date": "1626940611",
            "description": "Continuing my isometric fun, and playing with mixing 2D and 3D ",
            "flags": 0,
            "hasliked": 0,
            "id": "7lXXWX",
            "likes": 57,
            "name": "Isometric Flat ",
            "published": 3,
            "tags": [
                "2d",
                "raymarching",
                "fractal",
                "flat",
                "isometric"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 1096
        },
        "renderpass": [
            {
                "code": "/**\n\n    Isometric Flat\n    @byt3_m3chanic | 7/22/2021\n\n    Continuing my isometric fun, and playing with\n    mixing 2D and 3D \n\n*/\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    100.\n#define MIN_DIST    1e-4\n\nfloat time,ga1,ga2,ga3,ga4,tmod;\nmat2 turn,r45,rx,ry;\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\n\n//@iq - all sdf's\nfloat box(vec3 p, vec3 s) \n{\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat box( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec4 hex(vec2 uv, float scale)\n{\n    uv *= scale;\n    const vec2 s = vec2(sqrt(3.), 1.);\n    //id's and center - compacted to vec4's\n    vec4 id = vec4(floor(uv/s),floor(uv/s + .5));\n    vec4 cn = vec4(vec2(id.xy)+.5,vec2(id.zw)+.0)*vec4(s,s);\n    vec2 p,cid;\n    vec2 p1 = cn.xy - uv;\n    vec2 p2 = cn.zw - uv;\n    //nearest hexagon coords / id.\n    if (length(p1) < length(p2)){\n        p = p1;\n        cid = id.xy;\n    } else {\n        p = p2;\n        cid = id.zw + .5;\n    }\n    return vec4(p,cid);\n}\n\nvoid btn(inout vec4 p, float s, float f, float m)\t\n{\n\tp.xy = abs(p.xy + f) - abs(p.xy - f) - p.xy;\n\tfloat r = dot(p.xyz, p.xyz);\n\tif (r < m){\n\t\tif(m==.0) m=.000001;\n\t\tp /= m;\n\t}else if (r<1.){\n\t\tp /= r;\n\t}\n\tp *= s;\n}\n\nvoid tet(inout vec4 p, float k1, float k2, float k3, float k4) \n{\n\tp = abs(p);\n\tfloat k = (k1 - .5)*2.;\n\tp.xyz /= vec3(k2, k3, k4);\n\n\tif (p.x < p.y) p.xy = p.yx; p.x = -p.x;\n\tif (p.x > p.y) p.xy = p.yx; p.x = -p.x;\n\tif (p.x < p.z) p.xz = p.zx; p.x = -p.x;\n\tif (p.x > p.z) p.xz = p.zx; p.x = -p.x;\n\n\tp.xyz = p.xyz * k1 - k + 1.;\n\tp.xyz *= vec3(k2, k3, k4);\n\tp.w *= abs(k);\n}\n\nvec2 map (vec3 p) \n{\n    p.yz*=r45;\n    p.xz*=r45;\n    p.xz*=rx;\n    \n    vec3 q = p;\n    float orbits = .0;\n    \n    p.y-=ga1*5.;\n    p.y=mod(p.y+2.5,5.)-2.5;\n    \n    vec4 P = vec4(p.xzy, 1.0); \n    for(int i = 0; i < 3; i++) {\n        btn(P, 3.85, 2.5, .25);\n        if(i == 1) orbits = max(length(P.xy)/PI,abs(P.z));\n        tet(P, 1.5, 1., 1., 1.); \n    }\n    \n    float ln = .99*(abs(P.z)-05.)/P.w;\n    float bx = box(q,vec3(1.25,4.,1.25));\n    ln=max(ln,bx);\n    \n\treturn vec2(ln,floor(orbits*.5));\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec3 hue(float t)\n{ \n    const vec3 c = vec3(0.941,0.686,0.141);\n    return .45 + .45*cos(time*.5+PI2*t*(c*vec3(.98,.99,.97))); \n}\n\nvoid pattern(inout vec3 C, vec2 uv, float d)\n{\n    vec2 vuv = uv;\n    vec2 uvp = uv;\n    uv.y -=ga1;\n    uvp.y+=ga1*2.;\n    float pd = floor((uvp.y+1.)/2.);\n    uvp.y=mod(uvp.y+1.,2.)-1.;\n    float px = fwidth(uv.x);\n    vec4 p    = hex(uv,8.);\n    \n    float hs  = hash21(p.zw);\n\n    float sz =  (length(abs(p.z))*12.);\n    float sy =  (length(abs(p.w))*12.);\n    float sx = .18+.18*sin(sz+sy+T*2.75);//\n    \n    p.y*=1.5;\n    p.xy*=rot(45.*PI/180.);\n    \n    float h2 = box(p.xy,vec2(sx));\n    if(hs>.5) h2=abs(h2)-.02;\n    h2=smoothstep(.01+px,-px,h2);\n    \n    uvp.y*=1.5;\n    uvp.xy*=rot(45.*PI/180.);\n    \n    float h3 = box(uvp.xy+vec2(.2665),vec2(.675));\n    h3 = max(h3,-box(uvp.xy+vec2(.2665),vec2(.475)));\n    h3=smoothstep(px,-px,h3);\n    \n    vec3 h3c = hue( clamp((vuv.y+.5)*.25,0.,1.)+pd );\n    C = mix(C,h3c,d>0.?h3:0.);\n    \n    if(p.z<-2. || p.z>1.5){\n        C = mix(C,hue(hs),d>0.?h2:0.);\n    }\n\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    // precal       \n    time = T*1.;\n    \n    r45=rot(-0.78539816339);\n    turn=rot(T*5.*PI/180.);\n\n    tmod = mod(time, 10.);\n    float t1 = lsp(0.0, 5.0, tmod);\n    float t2 = lsp(5.0, 10.0, tmod);\n    ga1 = (t1)+floor(time*.1);\n    ga2 = (t2)+floor(time*.1);\n    rx=rot(-t2*PI); \n    //\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    \n    //@Flopine's isometric setup - tweaked\n    //https://www.shadertoy.com/view/NtXSWS\n    vec3 ro = vec3(uv*2.5,-10.);\n    vec3 rd = vec3(0.,0.,1.);\n    //\n    \n    //background\n    vec3 C = mix(hue(3.),hue(32.),clamp((uv.y+1.)*.75,0.,1.));\n    \n    vec3 p;\n    float d=0.,m;\n    //marcher\n    for(int i=0;i<150;i++)\n    {\n        p=ro+rd*d;\n        vec2 ray = map(p);\n        d += ray.x;\n        m  = ray.y;\n        if(abs(ray.x)<MIN_DIST ||d>MAX_DIST)break;\n    }\n    float alpha = 1.;\n    if(d<MAX_DIST)\n    {\n        alpha = 0.;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(-5.0, .25, -9.0);\n        vec3 l = normalize(lpos-p);\n\n        float diff = d*.1;//clamp(dot(n,l),0.,1.);\n        \n        float shdw = .95;\n        for( float t=.06; t < 12.; )\n        {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 24.*h/t);\n            t += h * .25;\n            if( shdw<MIN_DIST || t>25. ) break;\n        }\n\n        diff = mix(diff,diff*shdw,.75);\n\n        vec3 h = hue(m);\n\n        C = vec3(diff)*h;\n    } \n    pattern(C,uv,alpha);\n    C=clamp(C,vec3(.03),vec3(1.));\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}