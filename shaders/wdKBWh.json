{
    "Shader": {
        "info": {
            "date": "1613457331",
            "description": "Sometimes things go so wrong that they make their way back to right.\n\nTell your GPU that I am sorry.\n\nby Connor Alexander Haskins - Parcle - https://twitter.com/Lucodivo",
            "flags": 0,
            "hasliked": 0,
            "id": "wdKBWh",
            "likes": 3,
            "name": "Menger Noise Prison",
            "published": 3,
            "tags": [
                "noise",
                "mengersponge"
            ],
            "usePreview": 0,
            "username": "Parcle",
            "viewed": 245
        },
        "renderpass": [
            {
                "code": "/*\n * \"Menger Noise Prison\" by Connor Alexander Hasking - 2021\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: ConnorAHaskins@gmail.com\n */\n\n#define MAX_STEPS 60 // less steps will increase performance but narrow viewing distance, and lower detail & overall brightness\n#define MISS_DIST 200.0\n#define HIT_DIST 0.01\n    \nint distanceRayToScene(vec3 rayOrigin, vec3 rayDir);\nfloat distPosToScene(vec3 rayPos);\n\nmat2 rotate(float angle);\n\nfloat sdRect(vec2 rayPos, vec2 dimen);\nfloat sdCross(vec3 rayPos, vec3 dimen);\nfloat sdCube(vec3 rayPos);\nfloat sdMengerNoisePrison(vec3 rayPos);\n\nfloat rayNoiseValue(vec3 rayPos);\n\nconst vec3 missColor = vec3(0.1, 0.1, 0.1);\nconst float boxDimen = 20.0;\nconst float halfBoxDimen = boxDimen / 2.0;\n\nconst int mengerSpongeIterations = 3;\nconst float pi = 3.14159265;\nconst float piOver4 = pi * 0.25;\nconst float tau = pi * 2.0f;\nconst vec3 startingRayOrigin = vec3(0.0, 0.0, -boxDimen);\n\nconst float velocityUnit = boxDimen; // velocity in terms of length of the largest menger cube\nconst float velocity = 0.5; // velocity units per second\nconst float secondsPerCycle = 4.0 / velocity;\nconst float cyclesPerSecond = 1.0 / secondsPerCycle;\n\nint cycleModulo6 = 0;\nint noiseIndex0 = 0;\nint noiseIndex1 = 1;\nfloat cycleFract = 0.0;\n\nconst float highYLevel[3] = float[](1.0, 0.5 + (3.0 / 18.0), 0.5 + (3.0 / 54.0));\nconst vec2 upRightLeftDownVecs[4] = vec2[](vec2(0.0, 1.0), vec2(1.0, 0.0), vec2(0.0, -1.0), vec2(-1.0, 0.0));\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec2 pixelCoord = fragCoord.xy - (iResolution.xy * 0.5);\n    pixelCoord = pixelCoord / iResolution.y;\n    \n    float cycle = iTime * cyclesPerSecond;\n    int cycleTrunc = int(cycle);\n    float cosY = -cos(tau * cycle); // cycles per second\n    float smoothY = smoothstep(-0.60, 0.60, cosY);\n    int upRightLeftDownIndex = cycleTrunc % 4;\n    int highYLevelIndex = cycleTrunc % 3;\n    float highLevelY = highYLevel[highYLevelIndex];\n    \n    float offset1d = smoothY * boxDimen * highLevelY;\n    vec3 offset3d = vec3(offset1d * upRightLeftDownVecs[upRightLeftDownIndex], iTime * velocity * velocityUnit);\n    vec3 rayOrigin = startingRayOrigin + offset3d;\n    vec3 fragmentPos = vec3(pixelCoord.x, pixelCoord.y, 0.0);\n    const vec3 focalPoint = vec3(0.0, 0.0, -1.0);\n    vec3 rayDir = fragmentPos - focalPoint;\n    \n    // special case as the mouse starts in the lower left when we want it to start in the center\n    vec2 normalizedMouseCoord = iMouse.x > 0.0 ?(((iMouse.xy / iResolution.xy) - vec2(0.5)) * 2.0) : vec2(0,0);\n    if(length(normalizedMouseCoord) > 1.0) { // reduce maximum distance of mouse from center to be 1 unit\n        normalizedMouseCoord = normalize(normalizedMouseCoord);\n    }\n    mat2 rotateYaw = rotate(normalizedMouseCoord.x * piOver4);\n    mat2 rotatePitch = rotate(normalizedMouseCoord.y * piOver4);\n    rayDir = vec3(rayDir.x, rotatePitch * rayDir.yz);\n    rayDir = vec3(rotateYaw * rayDir.xz, rayDir.y).xzy;\n    rayDir = normalize(rayDir);\n\n    cycleModulo6 = (cycleTrunc - 1) % 6; // offset cycleTrunc so that noise transition occurs during highYLevel[0], instead of highYLevel[2]\n    noiseIndex0 = cycleModulo6 / 3;\n    noiseIndex1 = abs(noiseIndex0 - 1);\n    // when cycleModulo is 2 or 5, enable cycleFract for lerping between noise\n    cycleFract = step(2.0, float(cycleModulo6 % 3)) * fract(iTime * cyclesPerSecond);\n    \n    int iteration = distanceRayToScene(rayOrigin, rayDir);\n\n    if(iteration < MAX_STEPS) { // hit\n        vec3 col = vec3(1.0 - (float(iteration)/float(MAX_STEPS)));\n        fragColor = vec4(col, 1.0);\n    } else { // miss\n        fragColor = vec4(missColor, 1.0);\n    }\n}\n\n\n// returns num iterations\n// NOTE: ray dir arguments are assumed to be normalized\nint distanceRayToScene(vec3 rayOrigin, vec3 rayDir) {\n\n\tfloat dist = 0.0;\n\n\tfor(int i = 0; i < MAX_STEPS; i++) {\n        vec3 pos = rayOrigin + (dist * rayDir);\n        float posToScene = sdMengerNoisePrison(pos) + rayNoiseValue(pos);\n        dist += posToScene;\n        if(abs(posToScene) < HIT_DIST) return i; // absolute value for posToScene incase the ray makes its way inside an object\n        if(posToScene > MISS_DIST) break;\n    }\n\n    return MAX_STEPS;\n}\n\n\n// NOTE: Piggy status of this function more directly related to the fairly random distance which results from the noise\n// NOTE: and, in turn, results in larger iterations that each ray takes. It is NOT simply the tripple sin calculations\n// NOTE: below (though I'm sure that doesn't help :()\nfloat rayNoiseValue(vec3 rayPos) {\n  // removing one creates a weird \"light source\" and \"tubes\" effect in the direction of the light\n  // removing two creates a plane of light\n  const float noiseFudgeMult = 20.0;\n  \n  vec3 rayPosFudge = noiseFudgeMult * rayPos;\n  float noiseVals[2] = float[](\n      sin(rayPosFudge.x)*sin(rayPosFudge.y)*sin(rayPosFudge.z), // normal?\n      fract(rayPosFudge.z) // ghost\n  );\n  \n  return mix(noiseVals[noiseIndex0], noiseVals[noiseIndex1], cycleFract);\n}\n\nfloat sdCube(vec3 rayPos) {\n\tconst vec3 corner = vec3(halfBoxDimen);\n    vec3 ray = abs(rayPos); // fold ray into positive octant\n    vec3 cornerToRay = ray - corner;\n    float cornerToRayMaxComponent = max(max(cornerToRay.x, cornerToRay.y), cornerToRay.z);\n    float distToInsideRay = min(cornerToRayMaxComponent, 0.0);\n    vec3 closestToOutsideRay = max(cornerToRay, 0.0);\n\treturn length(closestToOutsideRay) + distToInsideRay;\n}\n\n\nfloat sdCross(vec3 rayPos) {\n    const vec3 corner = vec3(halfBoxDimen);\n\tvec3 ray = abs(rayPos); // fold ray into positive quadrant\n\tvec3 cornerToRay = ray - corner;\n\n    float smallestComp = min(min(cornerToRay.x, cornerToRay.y), cornerToRay.z);\n\tfloat largestComp = max(max(cornerToRay.x, cornerToRay.y), cornerToRay.z);\n\tfloat middleComp = cornerToRay.x + cornerToRay.y + cornerToRay.z\n\t\t\t\t\t\t\t- smallestComp - largestComp;\n            \n\tvec2 closestOutsidePoint = max(vec2(smallestComp, middleComp), 0.0);\n\tvec2 closestInsidePoint = min(vec2(middleComp, largestComp), 0.0);\n\n\treturn (middleComp > 0.0) ? length(closestOutsidePoint) : -length(closestInsidePoint);\n}\n\nfloat sdMengerNoisePrison(vec3 rayPos) {\n  vec3 prisonRay = mod(rayPos, boxDimen * 2.0);\n  prisonRay -= boxDimen;\n\n  float mengerPrisonDist = sdCross(prisonRay, vec3(halfBoxDimen));\n\n  float scale = 1.0;;\n  for(int i = 0; i < 3; ++i) {\n    float boxedWorldDimen = boxDimen / scale;\n    vec3 ray = mod(rayPos + boxedWorldDimen / 2.0, boxedWorldDimen);\n    ray -= boxedWorldDimen * 0.5;\n    ray *= scale;\n    float crossesDist = sdCross(ray * 3.0, vec3(halfBoxDimen));\n    scale *= 3.0;\n    crossesDist /= scale;\n    mengerPrisonDist = max(mengerPrisonDist, -crossesDist);\n  }\n\n  return mengerPrisonDist;\n}\n\n\nfloat sdRect(vec2 rayPos, vec2 dimen) {\n  vec2 rayToCorner = abs(rayPos) - dimen;\n  // maxDelta is the maximum negative value if the point exists inside of the box, otherwise 0.0\n  float maxDelta = min(max(rayToCorner.x, rayToCorner.y), 0.0);\n  return length(max(rayToCorner, 0.0)) + maxDelta;\n}\n\nfloat sdCross(vec3 rayPos, vec3 dimen) {\n  float da = sdRect(rayPos.xy, dimen.xy);\n  float db = sdRect(rayPos.xz, dimen.xz);\n  float dc = sdRect(rayPos.yz, dimen.yz);\n  return min(da,min(db,dc));\n}\n\nmat2 rotate(float angle) {\n    float sine = sin(angle);\n    float cosine = cos(angle);\n    return mat2(cosine, -sine, sine, cosine);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}