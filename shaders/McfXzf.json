{
    "Shader": {
        "info": {
            "date": "1706224790",
            "description": "YACB. Just playing with RT.",
            "flags": 32,
            "hasliked": 0,
            "id": "McfXzf",
            "likes": 2,
            "name": "Cornell Box RT Playground",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "VPaltoDance",
            "viewed": 193
        },
        "renderpass": [
            {
                "code": "// Cornell Box https://www.graphics.cornell.edu/online/box/data.html\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor.rgb = pow(texelFetch(iChannel0, ivec2(fragCoord),0).rgb, vec3(0.45));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Cornell Box https://www.graphics.cornell.edu/online/box/data.html\n\n// Const data\n#define LIGHT_POWER 16.0\n#define NUM_TRIS 32\n\n// Math misc\n#define ONE_OVER_MAX_UINT 2.32830643654e-10\n#define ONE_OVR_PI 0.31830988618\n#define M_PI 3.1415926535\n#define M_2PI 6.2831853071\n#define MAX_FLOAT 3.4e+38\n#define EPSILON 0.0005\n\n// Iteration controllers\n#define MAX_PATH_LENGTH 10\n#define SAMPLE_COUNT 1\n\n// Material names for material_map\n#define EMISSIVE_LIGHT_MAT 0u\n#define RED_MAT 1u\n#define GREEN_MAT 2u\n#define WHITE_MAT 3u\n\n//Misc\n#define PER_FRAME_SEED_3(x) uvec3(abs(x) * 4621.0, iFrame)\n\n\n// Camra struct - we assume a model of camera with sensor and thin lens in front of it.\n// We can derive data required for raytracing from this params.\nstruct Camera\n{\n    //Cornell data https://www.graphics.cornell.edu/online/box/data.html\n    vec3 pos;\n    vec3 dir;    \n    vec3 right;\n    float focal;\n    vec2 size;\n    float aspect;\n};\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Hit\n{\n    vec3 pos;\n    vec3 normal;\n    vec4 color;\n    float t;\n};\n\nstruct Triangle\n{\n    vec3 v0, v1, v2;\n    vec3 normal;\n    uint mat;\n};\n\n// Create and initialize the camera instance. Data from https://www.graphics.cornell.edu/online/box/data.html\nCamera camera = Camera(\n    vec3(278.0, 273.0, -800.0), // Position\n    vec3(0.0, 0.0, 1.0),        // Direction\n    vec3(0.0, 1.0, 0.0),        // Up direction\n    0.035,                      // Focal length\n    vec2(0.025, 0.025),         // Width and height of sensor\n    1.0                         // Pre-initialize with default 1.0, we will calculate it in the application\n);\n\n// Loved this geometry representation.\n// Taken from https://www.shadertoy.com/view/WtlSWM (by stack_overflow)\n#define QUAD(_a, _b, _c, _d, _m) \\\n    Triangle((_a), (_b), (_c), vec3(0.0, 1.0, 0.0), _m), \\\n    Triangle((_c), (_d), (_a), vec3(0.0, 1.0, 0.0), _m)\n\nTriangle[NUM_TRIS] tris = Triangle[](\n\n    // Light\n    QUAD(\n        vec3(343.0, 548.7, 332.0),\n        vec3(213.0, 548.7, 332.0),\n        vec3(213.0, 548.7, 227.0),\n        vec3(343.0, 548.7, 227.0),\n        EMISSIVE_LIGHT_MAT\n        ),\n\n     // Floor\n    QUAD(\n        vec3(  0.0, 0.0, 559.2),\n        vec3(552.8, 0.0, 559.2),\n        vec3(552.8, 0.0,   0.0),\n        vec3(  0.0, 0.0,   0.0),\n        WHITE_MAT),\n\n    // Ceiling\n    QUAD(\n        vec3(552.8, 548.8, 559.2),\n        vec3(  0.0, 548.8, 559.2),\n        vec3(  0.0, 548.8,   0.0),\n        vec3(552.8, 548.8,   0.0),\n        WHITE_MAT),\n    \n    // Back Wall\n    QUAD(\n        vec3(552.8,   0.0, 559.2),\n        vec3(  0.0,   0.0, 559.2),\n        vec3(  0.0, 548.8, 559.2),\n        vec3(552.8, 548.8, 559.2),\n        WHITE_MAT),\n    \n    // Right Wall\n    QUAD(\n        vec3(  0.0,   0.0,   0.0), \n        vec3(  0.0, 548.8,   0.0),\n        vec3(  0.0, 548.8, 559.2),\n        vec3(  0.0,   0.0, 559.2),\n        RED_MAT),\n    \n    // Left Wall\n    QUAD(\n        vec3(552.8,   0.0,   0.0),\n        vec3(552.8,   0.0, 559.2), \n        vec3(552.8, 548.8, 559.2),\n        vec3(552.8, 548.8,   0.0),\n        GREEN_MAT),\n        \n    // Short block\n    \n    // top\n    QUAD(\n        vec3(130.0, 165.0,  65.0),\n        vec3( 82.0, 165.0, 225.0),\n        vec3(240.0, 165.0, 272.0),\n        vec3(290.0, 165.0, 114.0),\n        WHITE_MAT\n        ),\n    // left\n    QUAD(\n        vec3(290.0,  0.0, 114.0),\n        vec3(290.0, 165.0, 114.0),\n        vec3(240.0, 165.0, 272.0),\n        vec3(240.0,   0.0, 272.0),\n        WHITE_MAT\n        ),\n    // front\n    QUAD(\n        vec3(130.0,   0.0,  65.0),\n        vec3(130.0, 165.0,  65.0),\n        vec3(290.0, 165.0, 114.0),\n        vec3(290.0,   0.0, 114.0),\n        WHITE_MAT\n        ),\n    // right\n    QUAD(\n        vec3(82.0 ,   0.0, 225.0),\n        vec3(82.0 , 165.0, 225.0),\n        vec3(130.0, 165.0,  65.0),\n        vec3(130.0,   0.0,  65.0),\n        WHITE_MAT\n        ),\n    // back\n    QUAD(\n        vec3(240.0,   0.0, 272.0),\t\t\t\n        vec3(240.0, 165.0, 272.0),\n        vec3( 82.0, 165.0, 225.0),\n        vec3( 82.0,   0.0, 225.0),\n        WHITE_MAT\n        ),\n\n    // Tall block\n    \n    // back\n    QUAD(\n        vec3(472.0,   0.0, 406.0),\n        vec3(472.0, 330.0, 406.0),\n        vec3(314.0, 330.0, 456.0),\n        vec3(314.0,   0.0, 456.0),\n        WHITE_MAT\n        ),\n    // top\n    QUAD(\n        vec3(423.0, 330.0, 247.0),\n        vec3(265.0, 330.0, 296.0),\n        vec3(314.0, 330.0, 456.0),\n        vec3(472.0, 330.0, 406.0),\n        WHITE_MAT\n        ),\n    // left\n    QUAD(\n        vec3(423.0,   0.0, 247.0),\n        vec3(423.0, 330.0, 247.0),\n        vec3(472.0, 330.0, 406.0),\n        vec3(472.0,   0.0, 406.0),\n        WHITE_MAT\n        ),\n    // right \n    QUAD(\n        vec3(314.0,   0.0, 456.0),\n        vec3(314.0, 330.0, 456.0),\n        vec3(265.0, 330.0, 296.0),\n        vec3(265.0,   0.0, 296.0),\n        WHITE_MAT\n        ),\n    // front\n    QUAD(\n        vec3(265.0,   0.0, 296.0),\n        vec3(265.0, 330.0, 296.0),\n        vec3(423.0, 330.0, 247.0),\n        vec3(423.0,   0.0, 247.0),\n        WHITE_MAT\n        )        \n);\n\n\n// An array of material data - vec4 per material. xyz - color, a - emission\nvec4[4] material_map = vec4[](\n    vec4(vec3(LIGHT_POWER), 1.0), \n    vec4(.75,.05,.05, 0.0),    \n    vec4(.12,.55,.15, 0.0),\n    vec4(.73, .73, .73, 0.0)   \n);\n\n// Wraped in a function for more quick future change\nvec4 get_tri_mat(Triangle tri)\n{\n    return material_map[tri.mat];\n}\n\n\n// Source: Hash Functions for GPU Rendering (by\tMark Jarzynski, Marc Olano)\n// A (3->3) hash function\nvec3 pcg32d_hash(uvec3 v) \n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    \n    return vec3(v) * ONE_OVER_MAX_UINT;\n}\n\n// Generate ray with a pin-hole camera model\nRay generate_ray(Camera cam, vec2 uv)\n{\n    uv -= 0.5;   // Align center with (0.5, 0.5).\n    uv.y = -uv.y;   // Loking through the hole makes things \"upside-down\" we pre-fix it here\n    \n    // Calculate sensor normalized device coords, so they are normalized to [0, 1] in the smallest dimention (usually - vertical).\n    vec2 sensor_ndc = vec2(uv.x * cam.aspect, uv.y);\n    // Randomly shift the ray start inside the pixel to employ Multisampling for AA\n    float shift = 1.0 / iResolution.y;\n    // TODO: Try using Halton here for more uniform distribution\n    vec2 jitter2 = shift * pcg32d_hash(PER_FRAME_SEED_3(sensor_ndc)).xy;\n    sensor_ndc += jitter2;  \n    // We assume, that the cam.pos is the position of pinhole not the sensor.\n    vec3 ray_dir = normalize(vec3(-sensor_ndc * cam.size, cam.focal)); // camera.pos - worldspace_sensor_coords\n    \n    return Ray(\n        cam.pos,\n        ray_dir\n    );\n}\n\n// Sampling a hemisphere with distribution increasing towards normal direction\n// From https://www.shadertoy.com/view/fdS3zw (by apfel1994)\nvec3 random_cos_weighted_hemisphere_direction(vec2 rand, vec3 n)\n{\n    vec2 u = rand;\n\n    float r = sqrt(u.x);\n    float theta = M_2PI * u.y;\n \n    vec3  B = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  T = cross( B, n );\n    \n    return normalize(r * sin(theta) * B + sqrt(1.0 - u.x) * n + r * cos(theta) * T);\n}\n\n// Inigo Quilez ray-triangle hit (https://iquilezles.org/articles/hackingintersector/)\nbool ray_triangle_hit(inout Hit hit, const Ray ray, const Triangle tri) \n{\n\n    vec3 v1v0 = tri.v1 - tri.v0;\n    vec3 v2v0 = tri.v2 - tri.v0;\n    vec3 rov0 = ray.pos - tri.v0;\n    \n    // storing hit data based on triangle params\n    hit.color = get_tri_mat(tri);\n    hit.normal = cross( v1v0, v2v0 );\n    \n    vec3  q = cross( rov0, ray.dir );\n    float d = 1.0/dot( ray.dir, hit.normal );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    hit.t = d*dot( -hit.normal, rov0 );\n    if( u<0.0 || v<0.0 || (u+v)>1.0 || hit.t <= 0.0) return false;\n    \n    hit.pos = ray.pos + ray.dir * hit.t; \n    hit.normal = normalize(hit.normal);\n    \n    return  true;\n}\n\n// Iterate through all triangles in the scene\n// Choose the closest hit (hit.t)\nbool ray_scene_hit(inout Hit ray_hit, const Ray ray)\n{\n    ray_hit.t = MAX_FLOAT;\n    bool intersect = false;\n    for(int i = 0; i < NUM_TRIS; ++i)\n    {\n        Hit hit;\n        bool curr_is = ray_triangle_hit(hit, ray, tris[i]);\n        intersect = intersect || curr_is;\n                \n        if(curr_is && ray_hit.t > hit.t)\n            ray_hit = hit; \n    }\n    \n    return intersect;\n}\n\n// Generating and shooting rays in a hemisohere traversing the scene\n// Calculating the resulting color accumulated from hit objects\nvec3 get_ray_color(Ray ray)\n{\n    Hit hit;\n    vec4 color = vec4(vec3(1.0), 0.0);\n    for (int i = 0; i < MAX_PATH_LENGTH; ++i) \n    {        \n        if(!ray_scene_hit(hit, ray)) break;\n        \n        // Importance sampling with random distribution that has more weight closer to normal and proportional to cos\n        // This also simulates lambert, so no need in cos term when calculating output color\n        vec3 ray_dir = random_cos_weighted_hemisphere_direction(\n                            pcg32d_hash(PER_FRAME_SEED_3(ray.dir.xy)).xy, hit.normal);\n        \n        // Shifting ray start by 0.001 to avoid self-intersection\n        ray = Ray(hit.pos + hit.normal * 0.001, ray_dir); \n        \n        // Getting color from hit position\n        color.xyz *= hit.color.rgb;\n        \n        // Checking for emissive objects (lights) hit one - we can break and return accumulated color\n        color.a = max(color.a, hit.color.a);\n        if(color.a > 0.5) break;\n    }\n    \n    // We get light only from hits with emissive objects\n    color.xyz *= color.a;\n    \n    return color.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    camera.aspect = iResolution.x / iResolution.y;\n    \n    Ray cam_ray = generate_ray(camera, uv);\n    \n    vec3 prev_col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    fragColor.rgb = get_ray_color(cam_ray);\n    \n    // Weighted average color is blended to buffer accumulated from previous frames\n    float weight = 1.0 / float(iFrame + 1);\n    fragColor.rgb = (1.0 - weight) * prev_col + weight * fragColor.rgb;\n\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}