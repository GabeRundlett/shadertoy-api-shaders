{
    "Shader": {
        "info": {
            "date": "1609812507",
            "description": "move camera with esdf+tg \nrotate camera with arrows+wr\n\ncamera of \nhttps://www.shadertoy.com/view/wtdyRs\nCubemapA GlobalIllumination of \nhttps://www.shadertoy.com/view/MlKcR1",
            "flags": 48,
            "hasliked": 0,
            "id": "wtccWB",
            "likes": 2,
            "name": "CubemapA Gi",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "volumetric",
                "cubemap",
                "godrays",
                "cubemapa"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 321
        },
        "renderpass": [
            {
                "code": "#define crashme 1\n//[crashme] case almost solved, error was that the camera was stuck inside the distanceField\n//and the constand collisiondetection crashed opengl.\n//or maybe the camera just being stuck inside the df, somehow doing too many iterations.\n\n//mope. this shader still tends to crash opengl, if only after some time.\n\n\n//crashes with 50 volumeSamples\n//crashes with d>0. exit condition\n\n//lets see if it EVER crashes with only 50. \n#define volumeSamples 50. \n\nfloat rayvolum(v22 r, float maxdist, vec3 light\n){float accum = 0.0\n ;for(float d=0.;d<maxdist;d+=maxdist/volumeSamples\n ){vec3 p = r.a+r.b*d\n  ;vec3 lightrd = p-light\n  ;float lightlen = length(lightrd)\n  ;lightrd /= lightlen\n  ;float lightdist = texture(iChannel3,lightrd).x\n  ;accum += float(lightdist>lightlen)\n  ;}\n ;return accum/maxdist/volumeSamples;}\n\n//shadows are hard and lowres, BAD combination!\nvec4 getCol(v22 r,float d\n){vec3 light = lightpos(iTime)\n ;float accum=rayvolum(r,d,light) //volume light\n ;r.a+=d*r.b\n ;vec3 normal = normal(r.a)\n ;vec3 lightrd = r.a-light\n ;float lightlen = length(lightrd)\n ;float shadow = texture(iChannel3,lightrd/lightlen).x\n ;vec4 c = vec4(normal*0.5+0.5,1)\n ;if(shadow-lightlen+.01<0.)c*=.2 //i am not convinced by this hard blocky shadow\n \n ;//c*=.5*mix(1.,.2,smoothstep(0.,1.,shadow-lightlen+1.1))\n ;//if(shadow-lightlen+.1<0.)c*=.2\n //c=mix(c*.01,c,smoothstep(0.,1.,lightlen))//mix(.2,.5,shadow)//hard blocky shadow\n ;c+=accum\n ;//c=mix(c,c*.2,sat(shadow))\n ;return sqrt(c);}\n\n#if crashme\nv22 getR(vec2 u//get ray from ichannel0\n){vec2 v=(u-iR.xy*.5)/iR.y\n ;mat4 ct=q2m(get2(iChannel0,CamR0),get2(iCb,CamP0).xyz)\n ;mat3 m=m42Rot(ct)\n ;vec3 rd=normalize(m*vec3(0,0,1)   //up\n                    +(m*vec3(1,0,0)*v.x//right+forward...\n                     +m*vec3(0,1,0)*v.y)*pi/FieldOfView)\n ;return v22(ct[3].xyz,rd) \n ;}\n#else\nv22 getR(vec2 u){\n;u=(u*2.-iResolution.xy)/iResolution.y\n;return v22(vec3(0.5,0.5,iTime*0.2),normalize(vec3(u,1)));}\n#endif\n\nvoid mainImage(out vec4 o,vec2 u\n){\n ;v22 r=getR(u)\n ;float d=march(r)\n ;if (d<100.&&d>0.)o=getCol(r,d) //>0. still dies not catch the crashing case.\n ;}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MOUSE_SENSITIVITY vec2(-1,1)\n#define FieldOfView 2.5\n\n#define pi acos(-1.)\n#define iM iMouse\n#define iR iResolution\n#define ST struct\n#define norma normalize\n#define m1 mat2\n#define m2 mat3\n#define m3 mat4\n#define i0 int\n#define i1 ivec2\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\nstruct v00{v0 a;v0 b;};\nstruct v11{v1 a;v1 b;};\nstruct v22{v2 a;v2 b;};//for 2 domains(density/distance field)\nstruct v33{v3 a;v3 b;};\nstruct v111{v1 a;v1 b;v1 c;};\nstruct v222{v2 a;v2 b;v2 c;};\nstruct v333{v3 a;v3 b;v3 c;};//for 3 domains(density/distance field); also used by DA,but as bridge to non-DA.\nstruct v2222{v2 a;v2 b;v2 c;v2 d;};\nv111 g111(v22 a){return v111(vec2(a.a.x,a.b.x),vec2(a.a.y,a.b.y),vec2(a.a.z,a.b.z));}\nv2222 muv(v2222 a,vec4 b){return v2222(a.a*b.x,a.b*b.y,a.c*b.z,a.d*b.w);}\nv22 g22(vec2 a){return v22(vec3(a.x),vec3(a.y));}\n\n// Fetch a single pixe from a buffer\nvec4 get2(sampler2D b,ivec2 a){return texelFetch(b,a,0);}\nvec4 get2(sampler2D b,int a){return texelFetch(b,ivec2(a,0),0);}\n\nconst float \n LIN_ACCE=5.//linear accelleration\n,ANG_ACCE=5.//angular accelleration\n,LIN_DRAG=1.//linear drag\n,ANG_DRAG=1.//angular drag\n;\n\n#define iCb iChannel0\nconst int \n CamP0=0//cameraPositionLinear\n,CamR0=1//cameraRotationLinear\n,CamP1=2//cameraVelocityAngular\n,CamR1=3//cameraVelocityAngular\n;\n\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,0.,1.)\n\n//--- quaterion math (updated 2021-1) //https://www.shadertoy.com/view/4tSyRz\nvec4 qid(){return vec4(0,0,0,1);}//quaternion Identity\n//return quaternion from Axis[a] and Angle[r]\nvec4 aa2q(vec3 a,float r){vec2 g=vec2(sin(r),cos(r))*.5;return normalize(vec4(a*g.x,g.y));}\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.0);}//assumed q is normalized coverts to axis&angle\n//return quaternion of rotattion input ANGLES [pitch.x, yaw.y, roll.z] in that ORDER:\nvec4 pyr2q(vec3 o){o*=.5//this *.5 scalar may not need to be internal\n ;vec3 s=sin(o);o=cos(o);vec4 a=vec4(s.xy,o.xy)//https://www.shadertoy.com/view/4tSyRz\n ;return a.xyxz*a.wzyw*o.z+a.yxzx*a.zwwy*s.z*vec4(1,-1,1,-1);}\n/*\n ;vec4 qp=pyr2q(vec3(a.yxz))\n ;return normalize(qq2q(qp,r))\n//above 2 lines are nearly identical to below 4 lines\n ;r=qq2q(aa2q(vec3(1,0,0),a.y),r)\n ;r=qq2q(aa2q(vec3(0,1,0),a.x),r)\n ;r=qq2q(aa2q(vec3(0,0,1),a.z),r)\n ;return r;\n*/\n//return q2, rotated by q1, order matters (is non commutative)\nvec4 qq2q(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz)\n,(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\n//extension to qq2q() quaternion multiplication, BUT scaled by SENITIVITY [f] (quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f\n){float d=dot(a,b),t=acos(abs(d)),o=(1./sin(t))\n ;return normalize(a*sin(t*(1.0-f))*o*sign(d)+b*sin(t*f)*o);}\n//return inverse of quaternion\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dd(q);}\n//return p, rotated by VECTOR q;\nvec3 qv2v(vec4 q,vec3 p){return qq2q(q,qq2q(vec4(p,.0),qinv(q))).xyz;}\n//qv2v()  with swapped inputs (note that this is not commutative)\nvec3 vq2v(vec3 p,vec4 q){return qq2q(qinv(q),qq2q(vec4(p,0.0),q)).xyz;}\nvec3 vq2v(vec4 a,vec3 b){return qv2v(a,b);}//in case of namespace confuction\nvec3 qv2v(vec3 a,vec4 b){return vq2v(a,b);}//in case of namespace confuction\n//return quaternion, that rotates to look from vec3(0) to input [v]\nvec4 qlookat(vec3 v){return aa2q(vec3(-v.y,v.x,0),acos(v.z/length(v)));}//point in direction v \n//return mat3 of [q]uaternion (rotation matrix without translation)\nmat3 q2m(vec4 q //https://www.shadertoy.com/view/WsGfWm\n){vec3 a=vec3(-1,1,1);mat3 m=mat3(.5)+mat3(0,q.zyz*a,0,q.xyx*a.xxy,0)*q.w\n +matrixCompMult(outerProduct(q.xyz,q.xyz),1.-mat3(1))//3 unnecessary multy by 0.\n ;q*=q//<-everythig except the main diagonal\n ;m-=mat3(q.y+q.z,0,0,0,q.x+q.z,0,0,0,q.x+q.y)//<- only the main diagonal\n ;return m*2.;}//this *2 scalar may not need to be internal\n//return q2m() as mat4, with [t]ranslation \nmat4 q2m(vec4 q,vec3 t //studying https://www.shadertoy.com/view/WsGfWm\n){mat3 m=q2m(q);return mat4(m[0],0,m[1],0,m[2],0,t,0);}//*=2,and add tranlation\n//return only mat3 rotation of mat4\nmat3 m42Rot(mat4 a){return mat3(a[0].xyz,a[1].xyz,a[2].xyz);}\n\n\n\n\nfloat df(vec3 u\n){vec3 p = fract(u)-.5\n ;float t =-length(p)+.6\n ;p.x=fract(u.x-.5)-.5\n ;t = min(t,length(p)-.2)\n ;return t;}\n\nvec3 normal(vec3 u\n){vec2 e=vec2(0,.001)\n ;return normalize(vec3(df(u+e.yxx)-df(u-e.yxx)\n                       ,df(u+e.xyx)-df(u-e.xyx)\n                       ,df(u+e.xxy)-df(u-e.xxy)));}\n\nfloat march(v22 r///1000 marching steps crash browser?\n){float d=0.\n ;for(int i=0;i<100;i++\n ){float len=df(r.a+d*r.b)\n  ;d+=len\n  ;if (len<.001||d>100.)break\n  ;}return d;}\n\nvec3 lightpos(float time){return vec3(-0.5,0.2*sin(time)+0.5,time*0.2+1.0);}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainCubemap(out vec4 o,vec2 u,vec3 ro,vec3 d\n){o=vec4(march(v22(lightpos(iTime),d)));}",
                "description": "",
                "inputs": [],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "#define PHYSICS_RADIUS .05\n#define startingCamPos vec4(lightpos(0.),0)\n#define startingCamRot aa2q(vec3(0,1,0),0.)\n\n#define keyA 65\n#define keyB 66\n#define keyC 67\n//...alphanumeric Keys\n#define keyE 69\n#define keyS 83\n#define keyD 68\n#define keyF 70\n#define keyT 84\n#define keyG 71\n//above moves linear, below rotates angular(mouse drag also rotates)\n#define keyW 87\n#define keyR 82\n#define keyUp 38\n#define keyDn 40\n#define keyLe 37\n#define keyRi 39\n\n/*\ninertia quaternion camera 2021\n\nCamera Controls:\n ESDF  - strafe forwards/backwares\n TG    - strafe up/down\n Arrows- rotate (pitch+jaw)\n WR    - rotate (roll)\n\n//self  : https://www.shadertoy.com/view/wtdyRs#\n//parent; https://www.shadertoy.com/view/WsGfWm\n\n*/\n\n//modify inputs by changing the ivec3() below (keys are defined in CommonTab)\nconst ivec3 klp=ivec3(keyF ,keyT ,keyE) //right      ,up      ,front      ==+linear\n           ,kln=ivec3(keyS ,keyG ,keyD) //left       ,down    ,back       ==-linear\n           //...\n           ,kap=ivec3(keyLe,keyUp,keyR) //kPitchLeft ,kJawUp  ,kRollRight ==+angular\n           ,kan=ivec3(keyRi,keyDn,keyW);//kPitchRight,kJawDown,kRollLeft  ==-angular\n\n//constant code:\n\n\n// STATE\n\n\n#define BUFFER_KEYBOARD iChannel1\n\n// Return the state of a key\nfloat get_key(int key_code\n){return texelFetch(BUFFER_KEYBOARD, ivec2(key_code,0), 0).x;}\n\nvec3 ks(ivec3 a){return vec3(get_key(a.x),get_key(a.y),get_key(a.z));}//key input subroutine\n\n\nvec4 cp0(vec4 o,vec2 u//return camera linear Position.xyz (.w is unused)\n){if (iFrame<1)return startingCamPos\n ;vec3 r=get2(iCb,CamP0).xyz\n ;float d=PHYSICS_RADIUS-df(r.xyz)\n ;if (d >0.)r.xyz+=normal(r)*d\n ;return vec4(r+(q2m(get2(iCb, CamR0),vec3(0))\n                 *vec4(get2(iCb, CamP1).xyz,0)).xyz*iTimeDelta,0);}\n \nvec4 cr0(vec4 o,vec2 u//return camera angular Position.xyz (quaternion)\n){if (iTime < 0.1)return startingCamRot\n ;return normalize(qq2q(pyr2q(iTimeDelta*get2(iCb, CamR1).yxz),get2(iCb, CamR0)));}\n\nvec3 drag(vec3 r,vec3 a,float d){return (r+a*iTimeDelta)*(1.-d*iTimeDelta);}\n\nvec4 cp1(vec4 o,vec2 u//return camera linear velocity.xyz (.w is unused)\n){return vec4(drag(get2(iCb,CamP1).xyz,LIN_ACCE*(ks(klp)-ks(kln)),LIN_DRAG),0);}\n \nvec4 cr1(vec4 o,vec2 u//return camera angular velocity.xyzw (quaternion)\n){vec3 a=ks(kap)-ks(kan)\n ;if(sign(iMouse.z)==1.)a.xy+=MOUSE_SENSITIVITY*(iM.xy-abs(iM.zw))/iR.xy;\n ;a=clamp(a,-1.,1.)\n ;return vec4(drag(get2(iCb,CamR1).xyz,a*ANG_ACCE,ANG_DRAG),0.);}\n\nvoid mainImage(out vec4 o,vec2 u\n){int a=int(u.x)\n ;if(a<2\n ){     if(a==CamP0)o=cp0(o,u)\n  ;else if(a==CamR0)o=cr0(o,u)\n ;}\n ;     if(a==CamP1)o=cp1(o,u)\n ;else if(a==CamR1)o=cr1(o,u)\n ;}\n\n\n/*\nuse this function to get the v22(rayOrigin,rayDirection) from this buffer\nv22 getR(vec2 U\n){vec2 u=(U-iR.xy*.5)/iR.y\n ;mat4 ct=q2m(get2(iCb,CamR0),get2(iCb, CamP0).xyz)\n ;mat3 m=m42Rot(ct)\n ;vec3 rd=normalize(m*vec3(0,0,1)   //up\n                    +(m*vec3(1,0,0)*u.x//right+forward...\n                     +m*vec3(0,1,0)*u.y)*pi/FieldOfView)\n ;return v22(ct[3].xyz,rd);}\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}