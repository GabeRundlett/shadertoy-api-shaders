{
    "Shader": {
        "info": {
            "date": "1619219652",
            "description": "Dividing by z.",
            "flags": 0,
            "hasliked": 0,
            "id": "NssXzB",
            "likes": 7,
            "name": "Divide by Z",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "warp",
                "z",
                "divide"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 161
        },
        "renderpass": [
            {
                "code": "// Hack (https://iquilezles.org/articles/normalsSDF)\n#define ZERO min(iFrame, 0)\n\nmat2 Rotate(in float a) {\n    float rad = radians(a);\n    float c = cos(rad), s = sin(rad);\n    return mat2(c, -s, s, c);\n}\n\nfloat mapScene(in vec3 p) {\n    p.xy /= mix(1.0, max(0.1, 0.2 * p.z + 0.75), 0.5 + 0.5 * sin(iTime));\n\n    vec3 q = abs(p) - 2.5;\n    float box1 = max(abs(max(q.x, max(q.y, q.z))) - 0.05, p.z - 2.0);\n\n    p.xz *= Rotate(30.0);\n    p -= vec3(0.25, -1.0, -1.5);\n    q = abs(p) - vec3(0.75, 1.5, 0.75);\n    float box2 = max(q.x, max(q.y, q.z));\n\n    p -= vec3(0.8, -0.7, 2.0);\n    p.xz *= Rotate(-55.0);\n    q = abs(p) - 0.8;\n    float box3 = max(q.x, max(q.y, q.z));\n\n    p.y -= 1.3;\n    float sphere1 = length(p) - 0.5;\n\n    p -= vec3(-2.0, -1.0, 1.5);\n    float sphere2 = length(p) - 1.0;\n\n    return min(box1, min(box2, min(box3, min(sphere1, sphere2))));\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 getGrad(in vec3 p) {\n    vec2 v = vec2(1.0, -1.0);\n    vec2 e = v * 0.001;\n    return (v.xyy * mapScene(p + e.xyy) +\n            v.yyx * mapScene(p + e.yyx) +\n            v.yxy * mapScene(p + e.yxy) +\n            v.xxx * mapScene(p + e.xxx)) / e.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(vec3(0.125), 1.0);\n\n    if (iMouse.xy == vec2(0.0)) mouse = vec2(0.5 * sin(iTime * 0.5), 0.0);\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float t = 0.0;\n    for (int i=ZERO; i < 150; i++) {\n        vec3 p = ro + rd * t;\n        vec3 j = getGrad(p);\n        float g = length(j);\n        float d = mapScene(p) / g;\n        if (d < 0.001) {\n            vec3 n = j / g;\n            fragColor.rgb += (0.5 + 0.5 * n) * max(0.0, dot(n, -rd));\n            break;\n        }\n\n        if (t > 20.0) {\n            break;\n        }\n\n        t += d;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}