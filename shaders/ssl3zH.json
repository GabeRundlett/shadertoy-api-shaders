{
    "Shader": {
        "info": {
            "date": "1615626764",
            "description": "Something simple today: plotting circles and finding intersections in a way that works nicely for lines as a special case.\n\nThe mouse moves the yellow line.",
            "flags": 0,
            "hasliked": 0,
            "id": "ssl3zH",
            "likes": 7,
            "name": "Plotting Circles",
            "published": 3,
            "tags": [
                "circles",
                "intersection",
                "plotting"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 326
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Plotting circles, mla, 2021\n//\n// For given float k and unit vector r, if kp.p = p.r the locus of p is a\n// circle passing through the origin, diameter 1/k with centre at r/2k.\n//\n// This is nice as the case k=0 gives a line (with normal r) without any\n// special treatment. Also, while kp.p-p.r isn't an exact distance function\n// everywhere its gradient on the circle has magnitude 1 (its a nice \n// exercise to see why this is) so it does work as a distance function locally\n// eg. for plotting the circle as a line (and the calculation of the\n// distance function involves just one dot product).\n//\n// This should work in any number of dimensions, so sphere intersections can \n// be calculated in the same way (with a nice degeneration to the plane case).\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  float scale = 10.0;\n  vec2 mouse = vec2(-2,1);\n  vec2 p = scale*(2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n  if (iMouse.x > 0.0) mouse = scale*(2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n  vec3 color = vec3(0.5,1,0.75); //vec3(smoothstep(0.0,0.01,abs(dist/ddist)));\n  vec2 r = normalize(vec2(1,1)); // Centre direction\n  float k = 0.5*tan(iTime);          // Inverse diameter\n  // kp.p-p.r == 0\n  float dist = abs(dot(p,k*p-r));\n  color = mix(vec3(0),color,smoothstep(0.1,0.15,dist)); \n\n  vec2 q = vec2(-2,-2);       // Line origin\n  vec2 t = normalize(mouse-q); // Line direction\n  q += -dot(q,t)*t; // Move q along line so q.t = 0 (helps with stability)\n  float ldist = abs(dot(p-q,vec2(t.y,-t.x)));\n  color = mix(vec3(1,1,0),color,smoothstep(0.1,0.15,ldist));\n  // Intersect q+xt with kp.p-p.r = 0\n  // k(q+xt).(q+xt) - (q+xt).r = 0\n  // k(q.q+2xq.t+x²) - q.r - xt.r = 0 (and q.t = 0)\n  // Solving Ax² - 2Bx + C = 0\n  float A = k;\n  float B = 0.5*dot(t,r);\n  float C = dot(q,k*q-r);\n  float D = B*B-A*C;\n  if (D >= 0.0) {\n    float tmp = B < 0.0 ? B-sqrt(D) : B+sqrt(D);\n    float x0 = tmp/A;\n    float x1 = C/tmp;\n    float pdist = min(distance(p,q+t*x0),distance(p,q+t*x1));\n    color = mix(vec3(1,0,0),color,smoothstep(0.3,0.35,pdist));\n  }\n  color = pow(color,vec3(0.4545));\n  fragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}