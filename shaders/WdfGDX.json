{
    "Shader": {
        "info": {
            "date": "1565967761",
            "description": "use mouse up/down to zoom\n\nhybrid example using the sound channel as offets in the hybrid alternation loop\n\nsound by teo and chromag\n https://soundcloud.com/rocknrolla42/chromag-and-teo-zuckerfrei\n\n",
            "flags": 4,
            "hasliked": 0,
            "id": "WdfGDX",
            "likes": 10,
            "name": "#EVOKE 2019 Sound Hybrid Mandel",
            "published": 3,
            "tags": [
                "fractalhybrid"
            ],
            "usePreview": 0,
            "username": "VJSpackOMat",
            "viewed": 1531
        },
        "renderpass": [
            {
                "code": "// Hybrid Mandelbrot Example by c.Kleinhuis for evoke 2019 talk\n//\n// Color Setup by by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// this is work in progres for upcoming talk about hybridisation\n\n// Disclaimer\n// \n// This is a hybrid alternate example, from a starting to an ending iteratoin\n// the input of the sound channel is used as an offset inside the iteration loop\n//\n// since the alternation starts only from a certain start to a certain end iteration\n// the initial mandelbrot shape is preserved\n//\n// the mapping of each input frequency results in slight variations\n// \n// example coordinates are entered uncomment them to use them, but make sure commenting all afterwards as well\n// \n// \n\nconst float PI=3.14159265359;\nconst int maxIter=1215;\nconst float maxIterFloat=float(maxIter);\n\nconst int startIteration=20;\nconst int endIteration=120;\n\n// cost intensive rotate, use it for rotating view for the downside bulbs\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m*v;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n     \n    // default\n    vec2 click=vec2(.25,.15);\n    // right above tip (uncomment only this to zoom this area)\n    // click=vec2(.25,.15);\n    // left bulb (uncomment only this to zoom this area)\n    // click=vec2(-1.35,.0);\n    // top small bulb (uncomment only this to zoom this area)\n    click=vec2(-0.1,0.8);\n    // top small left bulb (uncomment only this to zoom this area)\n    //  click=vec2(-0.5,0.6);\n    // top small right bulb (uncomment only this to zoom this area)\n    // click=vec2(0.3,0.5);\n    // bottom small right bulb (uncomment only this to zoom this area)\n    // click=vec2(0.25,-0.55);\n    // bottom small left bulb (uncomment only this to zoom this area)\n    // click=vec2(-0.5,-0.6);\n    \n    \n    vec2 mouse=(-iMouse.xy/iResolution.xy)*2.0f-1.0f;\n    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y; \n        p=rotate(p,0.);\n        float time = iTime; \n    \ttime=1.;\n        float zoo = 0.82 + 0.28*cos(.07*time);\n        zoo=iMouse.x<0.0001f?0.15:iMouse.y/iResolution.y;   \n        vec2 c =  click+p.xy*zoo;// '+ xy*zoo;\n\n        const float B = 256.0;\n        float l = 0.0;\n\t    vec2 z  = vec2(0.0);\n    \n        for( int i=0; i<maxIter; i++ )\n        {\n\n            \n\n            // z = z*z + c\t\t\n    \t\tz = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\n            \n            if(i>startIteration && i<endIteration){\n               /*\n\t\t\t\tlets sample from the input fourier values (todo: get sampling rate/subdivision right)\n\t\t\t\t\n\t\t\t\t*/  \n                float iPos= float(i-startIteration)/float(endIteration-startIteration); \n\t\t\t\tcol.x=sin(iPos*PI*100.+iTime )*.1;\n             \tcol.y=cos(iPos*PI*10.+iTime )*.1;\n                \n                /*\n\n\t\t\t\t\tsince sample rate is 1-dimensional, but we have a 2dimensional complex value,\n\t\t\t\t\tlets use a timed arrrow rotating as direction ...\n\t\t\t\t*/\n                float value=texture(iChannel0,vec2(float(i)/float(maxIter))).r;\n                \n                \n                // this just offsets from audio per iteration - rather linear\n                 z.x+= value*value*.15  ;\n                 z.y-=  value*value*.15   ;\n                \n                // use this to make rotational direction \n                 //z.x+= col.x*value*value*.15  ;\n                 //z.y-= col.x*value*value*.15   ;\n            }\n                if( dot(z,z)>(B*B) ) break;\n\n    \t\tl += 1.0;\n        }\n\n    \t// ------------------------------------------------------\n        // smooth interation count\n    \t//float sl = l - log(log(length(z))/log(B))/log(2.0);\n         \n\n        col += 0.5 + 0.5*cos( 3.0 + l*0.15 + vec3(0.0,0.6,1.0));\n \n\n    fragColor = vec4( col, 1.0 );\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "mic",
                        "id": 32,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/mic.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}