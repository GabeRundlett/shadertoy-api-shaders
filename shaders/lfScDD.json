{
    "Shader": {
        "info": {
            "date": "1722340562",
            "description": "Use mouse to change parameters, click lower left corner to autoplay.\nThe number of dots in the right lower corner denote the number of roots found.",
            "flags": 0,
            "hasliked": 0,
            "id": "lfScDD",
            "likes": 6,
            "name": "Numerical cubic solver",
            "published": 3,
            "tags": [
                "iterative",
                "root",
                "halley"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 72
        },
        "renderpass": [
            {
                "code": "/*\nSolving a cubic polynomial by isolating roots using the roots\nof the derivative and then using Halley iterations.\n\nThe most fiddly part is computing the number of found roots in the end.\n*/\n\nconst float eps1 = .01;\nconst float eps2 = .00001;\nconst float pi = 3.1416;\nconst float zoom = 3.5;\nconst float dot_size = .03;\n\nconst float it_num_visual = 30.;\nconst int it_num_solver = 10;\n\nvec3 x_to_col(float x){\n\treturn .5+.5*vec3(sin(x),sin(x+2./3.*pi),sin(x+4./3.*pi));\n}\n\nfloat eval_poly3(vec3 coeffs, float x){\n\n\tfloat f = ((x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\n\treturn f;\n}\n\nvec3 eval_poly3x3(vec3 coeffs, vec3 x){\n\n\tvec3 f = ((x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\n\treturn f;\n}\n\nfloat eval_poly2(vec2 coeffs, float x){\n\n\tfloat f = (x + coeffs[1]) * x + coeffs[0];\n\n\treturn f;\n}\n\nfloat halley_iteration3(vec3 coeffs, float x){\n\tfloat a2=coeffs[2]+x;\n\tfloat a1=coeffs[1]+x*a2;\n\n\tfloat f=coeffs[0]+x*a1;\n\n\tfloat b2=a2+x;\n\n\tfloat f1=a1+x*b2;\n\tfloat f2=2.*(b2+x);\n\n\treturn x-(2.*f*f1)/(2.*f1*f1-f*f2);\n}\n\nvec3 halley_iteration3x3(vec3 coeffs, vec3 x){\n\tvec3 a2=coeffs[2]+x;\n\tvec3 a1=coeffs[1]+x*a2;\n\n\tvec3 f=coeffs[0]+x*a1;\n\n\tvec3 b2=a2+x;\n\n\tvec3 f1=a1+x*b2;\n\tvec3 f2=2.*(b2+x);\n\n\treturn x-(2.*f*f1)/(2.*f1*f1-f*f2);\n}\n\nvec3 sort_roots3(vec3 coeffs){\n    if(coeffs.x < coeffs.y){\n        if(coeffs.z < coeffs.x){\n            return coeffs.zxy;\n        }\n        else if(coeffs.z < coeffs.y){\n            return coeffs.xzy;\n        }\n        else{\n            return coeffs.xyz;\n        }\n    }\n    else if(coeffs.z < coeffs.y){\n        return coeffs.zyx;\n    }\n    else if(coeffs.z < coeffs.x){\n        return coeffs.yzx;\n    }\n    else{\n        return coeffs.yxz;\n    }\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n    // normal form: x^2 + px + q = 0\n    float p = coeffs[1] / 2.;\n    float q = coeffs[0];\n\n    float D = p * p - q;\n\n    if (D < 0.){\n\t\treturn 0;\n    }\n    else if (D > 0.){\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n    }\n}\n\nint solve_cubic_cardano(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n    r[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n    \n\treturn 3;\n}\n\nint solve_cubic_numeric(vec3 coeffs, out vec3 r){\n    vec2 d1 = vec2(coeffs[1],2.*coeffs[2])/3.;\n    float d2 = coeffs[2]/3.;\n    \n    vec2 roots_drv = vec2(0);\n\tint num_roots_drv = solve_quadric(d1,roots_drv);\n    \n    r = vec3(-1.-d2,-d2,1.-d2);\n    \n    int num_roots = 0;\n    \n    if(num_roots_drv == 2){\n        r[0] = roots_drv[0]-1.;\n        r[2] = roots_drv[1]+1.;\n    }\n    \n    for(int i=0;i<it_num_solver;i++){\n        r = halley_iteration3x3(coeffs,r);\n    }\n    \n    vec3 eval_r = eval_poly3x3(coeffs, r);\n    if(abs(eval_r[0]) > eps1){\n        r[0] = 1e38;\n    }\n    if(abs(eval_r[1]) > eps1){\n        r[1] = 1e38;\n    }\n    if(abs(eval_r[2]) > eps1){\n        r[2] = 1e38;\n    }\n    \n    r = sort_roots3(r);\n    \n    if(abs(r[0]-r[1]) < eps2){\n        if(abs(r[1]-r[2]) < eps2){\n            if(r[0] == 1e38){\n                return 0;\n            }\n        }\n        else if(r[2] != 1e38){\n            r = r.xzy;\n            return 2;\n        }\n        return 1;\n    }\n    else{\n        if(abs(r[1]-r[2]) < eps2){\n            if(r[1] == 1e38){\n                return 1;\n            }\n        }\n        else if(r[2] != 1e38){\n            return 3;\n        }\n        return 2;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-=.5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tmouse-=.5;\n\tmouse.x *= iResolution.x / iResolution.y;\n\n    float border = 2./iResolution.y;\n\n\tborder *= zoom;\n\tuv *= zoom;\n\tmouse *= zoom;\n\n\tfloat a0 = -6. / 89.;\n\tfloat a1 = 158. / 267.;\n\tfloat a2 = 34. / 89.;\n\n\tfloat t0 = mod(iTime,6.*pi);\n\n\ta0 += sin(t0)*.3;\n\ta1 += sin(t0*2./3.)*.7;\n    \n    //mouse condition copied from mattz (https://www.shadertoy.com/view/4dyyR1)\n    if(max(iMouse.x, iMouse.y) > 20.){\n        a0=mouse.y;\n        a1=mouse.x;\n    }\n\n\tvec2 d1 = vec2(a1,2.*a2)/3.;\n\tfloat d2 = a2/3.;\n\n\tfloat val = eval_poly3(vec3(a0,a1,a2),uv.x);\n\tfloat drv = eval_poly2(d1,uv.x)*3.;\n\n\tfloat d0 = abs(val-uv.y)/length(vec2(drv,1.));\n\n\td0 = min(d0,abs(uv.y));\n\n    vec3 roots;\n\tint num_roots = solve_cubic_numeric(vec3(a0,a1,a2),roots);\n    \n    for(int i=0;i<num_roots;i++){\n        d0 = min(d0,distance(uv,vec2(roots[i],0))-dot_size);\n        d0 = min(d0,distance(uv,vec2(2.5+.1*float(i),-1.5))-dot_size);\n    }\n\n\tvec2 roots_drv=vec2(1e38);\n\n\tint num_roots_drv = solve_quadric(d1,roots_drv);\n\n\tfor(int i=0;i<2;i++){\n\t\tif(i < num_roots_drv){\n\t\t\td0 = min(d0,abs(uv.x - roots_drv[i]));\n\t\t}\n\t}\n\tif(num_roots_drv != 2){\n\t\td0 = min(d0,abs(uv.x + d2));\n\t}\n\n\tfloat x = uv.x;\n\n\tfloat j = floor((1.-(uv.y/zoom+.5))*it_num_visual);\n\n\tfor(float i=0.;i<it_num_visual;i+=1.){\n\t\tif(i<j){\n\t\t\tx = halley_iteration3(vec3(a0,a1,a2),x);\n\t\t}\n\t}\n\n\tvec3 col = x_to_col(x);\n\n\tfragColor = vec4(mix(vec3(0),col,smoothstep(0., border, d0)),1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}