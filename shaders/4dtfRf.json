{
    "Shader": {
        "info": {
            "date": "1526200613",
            "description": "just fix the error of:\n https://www.shadertoy.com/view/XscSDN\nin fact this shader code is from:\nhttps://blog.csdn.net/candycat1992/article/details/47777937\nin case any one wants to learn watercolorization.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4dtfRf",
            "likes": 9,
            "name": "fix error:  Kubelka-Munk Model",
            "published": 3,
            "tags": [
                "watercolorizationfixerror"
            ],
            "usePreview": 0,
            "username": "thu_yumeng",
            "viewed": 1163
        },
        "renderpass": [
            {
                "code": "// just alter the little error of the other shader\n// reference: https://www.shadertoy.com/view/XscSDN\n// in fact the orignal this shader code from this blog:\n// https://blog.csdn.net/candycat1992/article/details/47777937\n\n// Table of pigments \n// from Computer-Generated Watercolor. Cassidy et al.\n// K is absortion. S is scattering\nvec3 K_QuinacridoneRose = vec3(0.22, 1.47, 0.57);\nvec3 S_QuinacridoneRose = vec3(0.05, 0.003, 0.03);\nvec3 K_FrenchUltramarine = vec3(0.86, 0.86, 0.06);\nvec3 S_FrenchUltramarine = vec3(0.005, 0.005, 0.09);\nvec3 K_CeruleanBlue = vec3(1.52, 0.32, 0.25);\nvec3 S_CeruleanBlue = vec3(0.06, 0.26, 0.40);\nvec3 K_HookersGreen = vec3(1.62, 0.61, 1.64);\nvec3 S_HookersGreen = vec3(0.01, 0.012, 0.003);\nvec3 K_HansaYellow = vec3(0.06, 0.21, 1.78);\nvec3 S_HansaYellow = vec3(0.50, 0.88, 0.009);\nvec3 K_CadmiumRed = vec3(0.14, 1.08, 1.68);\nvec3 S_CadmiumRed = vec3(0.77, 0.015, 0.018);\nvec3 K_IndianRed = vec3(0.46, 1.07, 1.50);\nvec3 S_IndianRed = vec3(1.28, 0.38, 0.21);\nvec3 K_InterferenceLilac = vec3(0.08, 0.11, 0.07);\nvec3 S_InterferenceLilac = vec3(1.25, 0.42, 1.43);\n\n// Math functions not available in webgl\nvec3 coshi(vec3 val) { vec3 e = exp(val); return (e + vec3(1.0) / e) / vec3(2.0); }\nvec3 tanhi(vec3 val) { vec3 e = exp(val); return (e - vec3(1.0) / e) / (e + vec3(1.0) / e); }\nvec3 sinhi(vec3 val) { vec3 e = exp(val); return (e - vec3(1.0) / e) / vec3(2.0); }\n\n\n// Kubelka-Munk reflectance and transmitance model\nvoid KM(vec3 K, vec3 S, float x, out vec3 R, out vec3 T) {\n\tvec3 a = (K + S) / S;\n\tvec3 b = sqrt(a * a - vec3(1.0, 1.0, 1.0));\n\tvec3 bSx = b * S * vec3(x, x, x);\n\tvec3 sinhi_bSx = sinhi(bSx);\n\tvec3 c = a * sinhi_bSx + b * coshi(bSx);\n\t    \n\tR = sinhi_bSx / c;\n\tT = b / c;\n}\n\n// Simulate edge darkening effect\n// Input: dist < 0 outer area, dist > 0 inner area\nfloat BrushEffect(float dist, float x_avg, float x_var) {\n    // Only when abs(dist) < 1.0/10.0, x > 0.0\n    // Means that the edges have more thickness of pigments\n    float x = max(0.0, 1.0 - 10.0 * abs(dist)); \n    x *= x;\n    x *= x;\n    return (x_avg + x_var * x) * smoothstep(-0.01, 0.002, dist);\n}\n\n\n// Simple 2d noise fbm with 3 octaves\nfloat noise2d(vec2 p)\n{\n    float t = texture(iChannel0, p).x;\n    t += 0.5 * texture(iChannel0, p * 2.0).x;\n    t += 0.25 * texture(iChannel0, p * 4.0).x;\n    return t / 1.75;\n}\n\n\nfloat DistanceCircle(vec2 pos, vec2 center, float radius) {\n    return 1.0 - distance(pos, center) / radius;\n}\n\n// Kubelka-Munk model for optical compositing of layers\nvoid CompositeLayers(vec3 R0, vec3 T0, vec3 R1, vec3 T1, out vec3 R, out vec3 T) {\n    vec3 tmp = vec3(1.0) / (vec3(1.0) - R0 * R1);\n    R = R0 + T0 * T0 * R1 * tmp;\n    T = T0 * T1 * tmp;\n}\n\nfloat DistanceSegment(vec2 pos, vec2 point0, vec2 point1, float halfwidth) {\n    vec2 dir0 = point1 - point0;\n    vec2 dir1 = pos - point0;\n    float h = clamp(dot(dir0, dir1)/dot(dir0, dir0), 0.0, 1.0);\n    float d = length(dir1 - dir0 * h);\n    \n    return 1.0 - d / halfwidth;\n}\n\nfloat DistanceMountain(vec2 pos, float height) {\n    return height + 0.04 * (sin(pos.x * 18.0 + 2.0) + sin(sin(pos.x * 2.0) * 7.0)) - pos.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 r0,t0,r1,t1;\n    \n    //float sky = 0.1 + 0.1 * noise2d(uv * vec2(0.1));\n    //KM(K_CeruleanBlue, S_CeruleanBlue, sky, r0, t0);\n    \n    //float mountain_line = 0.5+0.04*(sin(uv.x*18.0+2.0)+sin(sin(uv.x*2.0)*7.0))-uv.y;\n    //float s = clamp(2.0-10.0*abs(mountain_line),0.0,1.0);\n    //vec2 uv2 = uv + vec2(0.04*s*noise2d(uv * vec2(0.1)));\n    //float mountains = brush_effect(0.5+0.04*(sin(uv2.x*18.0+2.0)+sin(sin(uv2.x*2.0)*7.0))-uv2.y, 0.2, 0.1);\n    //mountains *= 0.85+0.15*noise2d(uv*vec2(0.2));\n    //KM(K_HookersGreen, S_HookersGreen, mountains, r1, t1);\n    //layering(r0,t0,r1,t1,r0,t0);\n    \n    //vec2 uv3 = uv*vec2(1.0,iResolution.y/iResolution.x) + vec2(0.02*noise2d(uv * vec2(0.2)));\n    //float sun = brush_effect(1.0 - distance(uv3, vec2(0.2,0.45)) / 0.08, 0.2, 0.1);\n    //KM(K_HansaYellow, S_HansaYellow, sun, r1, t1);\n    //layering(r0,t0,r1,t1,r0,t0);\n    \n\t//fragColor = vec4(r0+t0,1.0);\n    \n\n    \n    \n    /// \n    /// Second Scene\n    ///\n\n    // Background\n    float background = 0.1 + 0.2 * noise2d(uv * vec2(1.0));\n    KM(K_HansaYellow, S_HansaYellow, background, r0, t0);\n\n    // Edge roughness: 0.04\n    vec2 pos = uv * vec2(1.0, iResolution.y / iResolution.x) + vec2(0.04 * noise2d(uv * vec2(0.1)));\n    float dist = DistanceCircle(pos, vec2(0.5, 0.5), 0.15);\n    // Average thickness: 0.2, edge varing thickness: 0.2\n    float circle = BrushEffect(dist, 0.2, 0.2);\n    // Granulation: 0.85\n    circle *= 0.15 + 0.85 * noise2d(uv * vec2(0.2));\n    KM(K_CadmiumRed, S_CadmiumRed, circle, r1, t1);\n    CompositeLayers(r0, t0, r1, t1, r0, t0);\n\n    // Edge roughness: 0.03\n    pos = uv * vec2(1.0, iResolution.y / iResolution.x) + vec2(0.03 * noise2d(uv * vec2(0.1)));\n    dist = DistanceCircle(pos, vec2(0.4, 0.3), 0.15);\n    // Average thickness: 0.3, edge varing thickness: 0.1\n    circle = BrushEffect(dist, 0.3, 0.1);\n    // Granulation: 0.65\n    circle *= 0.35 + 0.65 * noise2d(uv * vec2(0.2));\n    KM(K_HookersGreen, S_HookersGreen, circle, r1, t1);\n    CompositeLayers(r0, t0, r1, t1, r0, t0);\n\n    // Edge roughness: 0.02\n    pos = uv * vec2(1.0, iResolution.y / iResolution.x) + vec2(0.02 * noise2d(uv * vec2(0.1)));\n    dist = DistanceCircle(pos, vec2(0.6, 0.3), 0.15);\n    // Average thickness: 0.3, edge varing thickness: 0.2\n    circle = BrushEffect(dist, 0.3, 0.2);\n    // Granulation: 0.45\n    circle *= 0.55 + 0.45 * noise2d(uv * vec2(0.2));\n    KM(K_FrenchUltramarine, S_FrenchUltramarine, circle, r1, t1);\n    CompositeLayers(r0, t0, r1, t1, r0, t0);\n\n    // Opaque paints, e.g. Indian Red\n    pos = uv * vec2(1.0, iResolution.y / iResolution.x) + vec2(0.02 * noise2d(uv * vec2(0.3)));\n    dist = DistanceSegment(pos, vec2(0.2, 0.1), vec2(0.4, 0.25), 0.03);\n    float line = BrushEffect(dist, 0.2, 0.1);\n    KM(K_IndianRed, S_IndianRed, line, r1, t1);\n    CompositeLayers(r0, t0, r1, t1, r0, t0);\n\n    // Transparent paints, e.g. Quinacridone Rose\n    pos = uv * vec2(1.0, iResolution.y / iResolution.x) + vec2(0.02 * noise2d(uv * vec2(0.2)));\n    dist = DistanceSegment(pos, vec2(0.2, 0.5), vec2(0.4, 0.55), 0.03);\n    line = BrushEffect(dist, 0.2, 0.1);\n    KM(K_QuinacridoneRose, S_QuinacridoneRose, line, r1, t1);\n    CompositeLayers(r0, t0, r1, t1, r0, t0);\n    // Interference paints, e.g. Interference Lilac\n    pos = uv * vec2(1.0, iResolution.y / iResolution.x) + vec2(0.02 * noise2d(uv * vec2(0.1)));\n    dist = DistanceSegment(pos, vec2(0.6, 0.55), vec2(0.8, 0.4), 0.03);\n    line = BrushEffect(dist, 0.2, 0.1);\n    KM(K_InterferenceLilac, S_InterferenceLilac, line, r1, t1);\n    CompositeLayers(r0, t0, r1, t1, r0, t0);\n    \n    fragColor = vec4(r0+t0,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}