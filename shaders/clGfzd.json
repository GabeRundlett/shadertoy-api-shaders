{
    "Shader": {
        "info": {
            "date": "1702377770",
            "description": "More hyperbolic pentagonal tilings. This uses rotational symmetries around edge midpoints, so the tiles are all directly congruent. Mouse drags centre point. 'x' to enter \"configuration mode\". See header for more info, controls, etc.",
            "flags": 48,
            "hasliked": 0,
            "id": "clGfzd",
            "likes": 11,
            "name": "Hyperbolic Pentagons II",
            "published": 3,
            "tags": [
                "tiling",
                "pentagon",
                "hyperbolic",
                "hyperboloid"
            ],
            "usePreview": 1,
            "username": "mla",
            "viewed": 256
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Hyperbolic Pentagonal Tilings II, mla, 2023.\n//\n// A convex hyperbolic polygon with angles adding up to 360° will\n// tile the hyperbolic plane with the basic symmetry of the tiling\n// being rotations about midpoints of edges (so the tiles are all\n// directly congruent). For pentagons, as well as the angles, two\n// side lengths can be specified, the rest are determined by the\n// construction.\n//\n// Set two of the angles in \"configuration mode\" by pressing 'x' or 'y'\n// and dragging the red ring. Not all combinations of angles and lengths\n// are possible. The screen may flash red for an invalid combination.\n//\n// When not in configuration mode, use the mouse to drag centre point.\n//\n// <up>,<down>: zoom in/out\n// c: don't colour tiles\n// d: don't shade area outside disc\n// h: half space projection\n// l: toggle line thickness\n// v: don't show vertices\n// x: config mode\n// y: show config dot\n// z: zoom in (only in half space projection)\n//\n// Calculations are done in the hyperboloid model, including folding into\n// the fundamental region (though errors accumulate faster than in\n// the disc model.\n//\n// Point A is the centre, (0,0,1), which lies on lines a and e, at angle\n// P to each other. Measuring along a and e from A gives two more\n// points, B and E and we construct lines b and d through them at angles \n// Q and T. Finally, a line c is constructed making angles R and S with b\n// and d. This line (if it exists) is unique and determines the length of\n// the final three segments.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int N = 5; // Number of sides. Currently must be 5\n\n// Basic operations for hyperbolic (Minkowski) space\n\n// Inner product\nfloat hdot(vec3 p, vec3 q) {\n  return dot(vec3(1,1,-1)*p,q);\n}\n\nvec3 hcross(vec3 p, vec3 q) {\n  // hdot(p,hcross(p,q)) = hdot(q,hcross(p,q)) = 0\n  return cross(p,q)*vec3(1,1,-1);\n}\n\nfloat hnorm(vec3 p) {\n  return hdot(p,p);\n}\n\nfloat hlength(vec3 p) {\n  return sqrt(abs(hnorm(p)));\n}\n\n// Normalize a point or a line\nvec3 hnormalize(vec3 p) {\n  return p/hlength(p);\n}\n\n// Map point on plane to hyperboloid hnorm(p) = -1\nvec3 unproject(vec2 z) {\n  // k²|z|²-(1-k)² = -1\n  // k²|z|²-1+2k-k² = -1\n  // k|z|²+2-k = 0\n  float k = 2.0/(1.0-dot(z,z));\n  return vec3(k*z,k-1.0);\n}\n\n// NB: sinh(x) = asinh(x) = tanh(x) = x (approximately) for\n// small values of x (eg. sinh 0.1 = 0.10017, tanh 0.1 = 0.0997)\n// Hyperbolic distance from line\nfloat hline(vec3 p, vec3 l) {\n  return abs(asinh(hdot(p,l)));\n}\n\n// Hyperbolic distance between points\nfloat hpoint(vec3 p, vec3 q) {\n  //return acosh(-hdot(p,q)); // Bad truncation error\n  return 2.0*abs(asinh(0.5*hlength(p-q)));\n}\n\n// Find a point on the line formed by the intersections\n// of planes l and m. Try to find point of form\n// (x,y,0), (x,0,z) or (0,y,z) by solving a 2x2\n// linear system. Construct three matrices & use the one\n// with largest determinant (it's possible for two\n// determinants to be zero, but not all three if the\n// planes aren't parallel).\nvec3 linepoint(vec3 l, vec3 m, float a, float b) {\n  vec2 A = vec2(1,-1); // adjust for metric\n  mat2 m0 = mat2(l.xy,m.xy);\n  mat2 m1 = mat2(A*l.xz,A*m.xz);\n  mat2 m2 = mat2(A*l.yz,A*m.yz);\n  float d0 = abs(determinant(m0));\n  float d1 = abs(determinant(m1));\n  float d2 = abs(determinant(m2));\n  float dmax = max(d0,max(d1,d2));\n  if (dmax == d1) m0 = m1;\n  else if (dmax == d2) m0 = m2;\n  vec3 p = vec3(vec2(a,b)*inverse(m0),0);\n  if (dmax == d1) p = p.xzy;\n  else if (dmax == d2) p = p.zxy;\n  assert(eq(hdot(p,l),a));\n  assert(eq(hdot(p,m),b));\n  return p;\n}\n\n// Given vectors l and m, return a normalized vector n\n// with l.n = a, m.n = b (all with Minkowski product)\n// sign parameter says if we want a line (spacelike) or a point (timelike)\nbool f(vec3 l, vec3 m, float a, float b, out vec3 n, float sign) {\n  // Want a line m with hdot(l,n) = A, hdot(m,n) = B\n  vec3 r = hcross(l,m); // Direction vector for intersection of planes l and m\n  // Now find p with hdot(p,l) = A, hdot(p,m) = B\n  vec3 p = linepoint(l,m,a,b);\n  // Now try to find a normalized point on that line ie. hnorm(p+tr) = <sign>\n  // (p+tr).(p+tr) - sign = 0\n  // p.p + 2t(p.r) + t²(r.r) - 1 = 0\n  // Set p.r = 0, so B = 0 in quadratic formula\n  p -= hdot(p,r)/hdot(r,r)*r;\n  float A = hdot(r,r);\n  float C = hdot(p,p) - sign;\n  float D = -A*C;\n  if (D < 0.0) return false;\n  // Two solutions are eg. for complementary angles, opposite distances.\n  float t = sqrt(D)/A;\n  n = p+t*r;\n  return true;\n}\n\n// Find a (normalized) point p with l.p = a, m.p = b\n// l and m can be points or lines\nvec3 fpoint(vec3 l, vec3 m, float a, float b) {\n  vec3 p;\n  bool t = f(l,m,a,b,p,-1.0);\n  assert(t);\n  assert(p.z >= 0.0);\n  return p;\n}\n\n// Find a (normalized) line p with l.p = a, m.p = b\n// l and m can be points or lines\nvec3 fline(vec3 l, vec3 m, float a, float b) {\n  vec3 p;\n  bool t = f(l,m,a,b,p,1.0);\n  assert(t);\n  assert(p.z <= 0.0);\n  return p;\n}\n\n// Get point on line l, distance d from p, also on l.\n// Same as fpoint(p,l,-cosh(d),0) but less rounding error.\nvec3 pointatdistance(vec3 p, vec3 l, float d) {\n  vec3 r = hcross(p,l); // Tangent vector\n  float k = tanh(d)/hlength(r); // Get right angle\n  vec3 q = p+k*r;\n  return hnormalize(q); // And normalize\n}\n\n// Assume l normalized\nvec3 hreflect(vec3 p, vec3 l) {\n  return p-2.0*hdot(p,l)*l;\n}\n\n// Reflect in a hyperbolic line\nint tryreflect(vec3 l, vec3 m, int i, inout vec3 p, inout vec3 h) {\n  float k = hdot(p,l);\n  if (k > 0.0) return 0;\n  p -= 2.0*k*l;\n  p = hreflect(p,m);\n  h = hreflect(h,l);\n  h = hreflect(h,m);\n  return 1;\n}\n\nvec3 fold(vec2 z, int MAX, vec3 edges[N], vec3 points[N], inout vec3 h) {\n  vec3 p = unproject(z);\n  vec3 bisectors[N];\n  for (int i = 0; i < N; i++) {\n    bisectors[i] = hnormalize(points[i]-points[(i+1)%N]);\n  }\n  for (int count = 0; count < MAX; count++) {\n    int k = 0;\n    for (int i = 0; i < N; i++) {\n      k += tryreflect(edges[i],bisectors[i],0,p,h);\n    }\n    if (k == 0) break;\n  }\n  return p;\n}\n\n// Given a Euclidean distance d, and a direction p, return\n// an hspace point that is at that distance and direction\n// from the centre in the Poincare disc.\nvec3 pointfromcentre(float d, vec2 p) {\n  float x = 2.0*d/(1.0-d*d);\n  float t = sqrt(1.0+x*x);\n  return vec3(x*p,t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Calculate sides and vertices of the polygon.\n  // All angles are given, as well as side lengths for a and e.\n  // A a B b C c D d E e A ..\n  // A is at origin, so a and e are straight lines in disc model\n  // and have t = 0 in hyperboloid model.\n  // Angle at A is PI/P, etc\n  // R = 0 means R = PI/infinity, also works for S\n  vec2 params = abs(getselection(0));\n  float angles[N];\n  angles[0] = angles[1] = angles[2] = angles[3] = 2.0*PI/5.0;\n  angles[0] = 2.0*params[0];\n  angles[1] = 2.0*params[1];\n  angles[N-1] = 2.0*PI;\n  for (int i = 0; i < N-1; i++) {\n    angles[N-1] -= angles[i];\n  }\n  assert(angles[N-1] >= 0.0);\n  vec3 edges[N], points[N];\n  {\n    // Need to sort this out for N != 5\n    vec3 a = vec3(1,0,0);\n    vec3 e = vec3(-mycos(angles[0]),mysin(angles[0]),0);\n    vec3 A = vec3(0,0,1);\n    vec3 B = pointfromcentre(0.7,vec2(0,1));\n    vec3 E = pointfromcentre(0.7,vec2(mysin(angles[0]),mycos(angles[0])));\n    vec3 b = fline(a,B,-mycos(angles[1]),0.0);\n    vec3 d = fline(E,e,0.0,-mycos(angles[N-1]));\n    vec3 c = fline(d,b,-mycos(angles[3]),-mycos(angles[2]));\n    vec3 C = hnormalize(hcross(b,c));\n    vec3 D = hnormalize(hcross(c,d));\n    edges = vec3[](a,b,c,d,e);\n    points = vec3[](A,B,C,D,E);\n  }\n  vec2 z = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  vec2 w = vec2(0);\n  if (!configmode) w = iMouse.x <= 10.0 ? 0.5*expi(0.25*iTime) : defaultselection();\n  float scale = 1.0;\n  if (!configmode) scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  z *= scale;\n  w *= scale;\n  float lwidth = 0.02;\n  float pwidth = 3.0*lwidth;\n  if (key(CHAR_L)) lwidth = 0.0;\n  \n  float px = fwidth(z.x);\n  bool dohalfplane = key(CHAR_H);\n  bool dozoom = key(CHAR_Z);\n  if (dohalfplane) z.y += scale;\n  // Conversion factor between hyperbolic and screen distances\n  float scalefactor = 1.0;\n  if (dohalfplane) {\n    if (dozoom) {\n      float k = exp(-iTime);\n      z *= k;\n      scalefactor /= k;\n    }\n    z.y += 1.0;\n    float k = 2.0/dot(z,z);\n    z *= k;\n    scalefactor /= k;\n    z.y -= 1.0;\n  }\n  scalefactor *= 0.5*abs(1.0 - dot(z,z));\n  if (!configmode) {\n    // Invert to mouse position\n    vec2 c = w;\n    z -= c;\n    z *= (dot(c,c)-1.0)/dot(z,z);\n    z += c;\n    z /= -dot(z,z);\n  }\n  bool indisc = dot(z,z) <= 1.0;\n  if (!indisc) z /= dot(z,z);\n  int NMAX = configmode ? 0 : 10;\n  vec3 h = vec3(0,0,1);\n  vec3 p = fold(z,NMAX,edges,points,h);\n  //vec3 p = fold(z,N,a,b,c,d,e,h);\n  vec3 col = vec3(0.5,1,1);\n  if (!configmode && !key(CHAR_C)) col = h2rgb(dot(h,vec3(1,2,3)));\n  {\n    float t = 1e8;\n    for (int i = 0; i < N; i++) {\n      t = min(t,hline(p,edges[i]));\n    }\n    vec3 lcol = vec3(0.1);\n    if (!configmode && key(CHAR_W)) lcol = vec3(1);\n    col = mix(lcol,col,smoothstep(0.0,px/scalefactor,t - lwidth));\n  }\n  {\n    float t = 1e8;\n    if (!key(CHAR_V)) {\n      for (int i = 0; i < N; i++) {\n        t = min(t,hpoint(p,points[i]));\n      }\n    }\n    col = mix(vec3(0),col,smoothstep(0.0,px/scalefactor,t - pwidth));\n  }\n  if (!key(CHAR_D) && !indisc) col *= 0.5;\n  if (showconfig) {\n    vec2 p = map(fragCoord);\n    float d = abs(distance(p,getselection(0))-0.03)-0.005;\n    col = mix(vec3(1,0,0),col,0.25+0.75*smoothstep(0.0,px,d));\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 t, vec2 uv) {\n  //setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  vec4 t0 = texelFetch(iChannel2,ivec2(0),0); // Get current state   \n  if (iFrame == 0 || t0 != vec4(1234.0)) {\n    t = vec4(0);\n  }  \n  if (j == 0) {\n    if (i == 0) t = vec4(1234.0);\n    else {\n      // First row - key count\n      // Do key repeat here as well?\n      float w1 = keystate(i,0).x;\n      if (w1 != t.w) {\n        t.w = w1;\n        // Don't count key changes when ALT pressed\n        if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n          t.x++; t.y = iTime;\n        }\n      }\n      // Key repeat - only when shader is running!\n      // Should have longer pause after first key press.\n      if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n        t.x++; t.y = iTime;\n      }\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (showconfig && t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        t.x = -1.0;\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < 0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n      if (!configmode && t.x <= 0.0 && iMouse.z > 0.0) {\n        t.zw = iMouse.x < 20.0 ? vec2(0) : map(iMouse.xy);\n      }\n    } else if (iFrame == 0 || t.w != 1234.0) {\n      t.xy = initselection(i-1); // Current coordinates\n      t.w = 1234.0;\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store((key),0).x))\n#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\n#define map(screenpos) ((2.0*(screenpos)-iResolution.xy)/iResolution.y)\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n//#define getselected() (texelFetch(iChannel2,ivec2(0,3),0))\n#define defaultselection() (texelFetch(iChannel2,ivec2(0,3),0).zw)\n//#define setscale() (scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP))))\n#define configmode (key(CHAR_X))\n#define showconfig (configmode || key(CHAR_Y))\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst float PI =  3.141592654;\n\nconst int nselections = 1;\nvec2 initselection(int i) {\n  if (i == 0) return vec2(0.8,0.7);\n  if (i == 1) return vec2(0.75,0.25);\n  if (i == 2) return vec2(-2,-1.5);\n  if (i == 3) return vec2(0,-1);\n  if (i == 4) return vec2(0.25,0);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return mix(vec3(1),rgb,0.8);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec2 expi(float t) {\n  return normalize(vec2(cos(t),sin(t)));\n}\n\nbool eq(float a, float b) {\n  return abs(a-b) < 1e-4;\n}\n\nfloat COS[] =\n  float[](1.0,-1.0,0.0,0.5,0.7071067812,0.8090169944,0.8660254038,\n          0.9009688679,0.9238795325,0.9396926208,0.9510565163,0.9594929736,\n          0.9659258263,0.9709418174,0.9749279122,0.9781476007,0.9807852804,\n          0.9829730997,0.984807753,0.9863613034,0.9876883406,0.9888308262,\n          0.9898214419,0.990685946,0.9914448614,0.9921147013,0.9927088741,\n          0.9932383577,0.9937122099,0.9941379572,0.9945218954,0.9948693234);\n\nfloat icos(int p) {\n  // cos(PI/p)\n  if (p < COS.length()) return COS[p];\n  return cos(PI/float(p));\n}\n                        \nfloat isin(int p) {\n  // sin(PI/p)\n  float t = icos(p);\n  return sqrt(1.0-t*t);\n}\n\n// GPU cos might not be good enough for repeated reflections\n// Chebyshev might be better here, but these work pretty well.\nfloat mycos(float x) {\n  //return cos(x);\n  int N = 14;\n  float x2 = x*x, y = 1.0;\n  for (int n = N; n > 0; n-=2) {\n    y = 1.0-x2*y/float(n*(n-1));\n  }\n  return y;\n}\n\nfloat mysin(float x) {\n  //return sin(x);\n  int N = 12;\n  float x2 = x*x, y = 1.0;\n  for (int n = N; n > 0; n-=2) {\n    y = 1.0-x2*y/float(n*(n+1));\n  }\n  return x*y;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}