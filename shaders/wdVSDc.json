{
    "Shader": {
        "info": {
            "date": "1575520451",
            "description": "Move mouse to change iterations\nIn the future it might be cool to make full control over zoom and position with mouse+scroll+keyboard",
            "flags": 0,
            "hasliked": 0,
            "id": "wdVSDc",
            "likes": 22,
            "name": "sofake",
            "published": 3,
            "tags": [
                "fractal",
                "snowflake"
            ],
            "usePreview": 0,
            "username": "cmarangu",
            "viewed": 1318
        },
        "renderpass": [
            {
                "code": "\n\n\n\n// TODO\n// - use digits of number as array (hard but super awesome)\n// - or just use nested for-loops\n// to traverse binary tree ignoring \"other side\" branches each iter\n// figure out what \"level\" using floor(log_2(y))\n\n\n\n\n \n\n#define debuglines 0\n\n\n\n// i know more\n#define PI 3.1415926535897932384626433832795028841971693993751058209749\n#define TAU (PI*2.)\n\n// #define arg mod(.75+float(iFrame)/60./16., 1.)\n// 2024 01 22 6:22pm EST - swapping /60. for /30. due to shadertoy apparently\n// having 30FPS as the new default.\n#define arg mod(.75+float(iFrame)/30./16., 1.)\n\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 q = (fragCoord.xy-iResolution.xy/2.)/iResolution.y*2.;\n    float SDFp = 1e6;\n    float scalene = 1.;\n    \n    // weird slice morphthingy\n    //float qyx = atan(q.y, q.x)+rot+iTime*PI*.1;\n    //float th = mod(atan(q.y, q.x)+arg*TAU/6., TAU/6.)+arg*TAU/6.;\n    //float r = length(q)*(1.+.9*sin(arg*TAU));\n    float th = mod(atan(q.y, q.x), TAU);\n    float r = length(q);\n    //q.x = r*cos(th);\n    //q.y = r*sin(th);\n    //q.x += sin(arg*TAU);\n    q *= 1.4; // scale to fit tips of snowflake on screen\n    //#define ease(x) clamp(0.5+((x)-0.5)*1.1, 0., 1.)\n    #define ease(x) (.5-.5*cos(PI*pow(x, .6) ))\n    if (arg < .5) {\n        float arg2 = fract(arg*2.);\n        q = mix(\n            q,\n            vec2(0.06,1.),\n            ease(min(2.*arg2,2.-2.*arg2))*.993\n        );\n    }\n    else {\n        float arg2 = fract(arg*2.);\n        q = mix(\n            q,\n            vec2(0.1,0.15),\n            ease(min(2.*arg2,2.-2.*arg2))*.99\n        );\n    }\n    \n    // rotate to make 6 branch from 1\n    //th = mod(atan(q.y, q.x)+arg*TAU/6., TAU/6.)+PI*.5-PI*.5/3.;\n    th = mod(atan(q.y, q.x), TAU/6.)+PI*.5-PI*.5/3.;\n    r = length(q)*2.;\n    q.x = r*cos(th);\n    q.y = r*sin(th);\n    \n    // recursion\n    //for (int i=0; i<10; ++i) {\n    // 2023 04 21 got the idea to make it based on mouse when my friend asked me whether it was infinite\n    int theMax = int(\n        (0.5 + 0.5*sin(arg*TAU*6.))*24.\n    );\n    //if (iMouse.w == 0.) {\n      theMax = int( clamp(abs(iMouse.x-iResolution.x/2.)/iResolution.x*30., 0., 24.) );\n    //}\n    for (int i=0; i<theMax; ++i) {\n        q.x = abs(q.x);\n        // top branch\n        if ((q.y-.9)-q.x*.4+.1 > 0.) {\n            q.y -= .9;\n            q *= 1.6;\n            scalene *= 1.6;\n        }\n        // left and right branches\n        else if (q.x > .04) {\n            q.x -= .03;\n            q.y -= .23;\n            float qyx = atan(q.y, q.x)+PI*.27;\n            float qyxr = length(q);\n            q.x = qyxr*cos(qyx);\n            q.y = qyxr*sin(qyx);\n            // q.y -= .2;\n            q *= 3.;\n            scalene *= 3.;\n        }\n    }\n    \n    \n    // rounded rect\n    q.y -= .46;\n    q = abs(q);\n    q = max(q-vec2(.0, .4), 0.);\n    SDFp = min(SDFp, length(q)-.02);\n    // distance scaling correction\n    SDFp /= scalene;\n    \n    \n    \n    // rendering\n    vec3 retina;\n    if (SDFp <= 0.) {\n        retina = vec3(1.);\n    }\n    else {\n        retina = mix(\n            vec3(0., 1., 1.),\n            vec3(0., 0., 100./255.),\n            clamp(pow(SDFp, .2), 0., 1.)\n        );\n        #if debuglines\n        \tif (mod(SDFp-iTime*.1, .1) < .01) {\n            \tretina = mix(retina, vec3(0., 0., 0.), .4);\n            }\n        \t// if (mod(atan(dFdy(SDFp),dFdx(SDFp)), .25)<.05 && SDFp > .25) {\n            // \tretina = mix(retina, vec3(0., 0., 0.), .4);\n            // }\n        #endif\n        // retina = vec3(0.);\n    }\n    fragColor = vec4(retina, 1.);\n    \n}\n/**/\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}