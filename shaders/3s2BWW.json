{
    "Shader": {
        "info": {
            "date": "1590067991",
            "description": "Learning more and more every day!",
            "flags": 0,
            "hasliked": 0,
            "id": "3s2BWW",
            "likes": 2,
            "name": "Spooky Gyration 2",
            "published": 3,
            "tags": [
                "gyroidraymarching"
            ],
            "usePreview": 0,
            "username": "workingclasshacker",
            "viewed": 359
        },
        "renderpass": [
            {
                "code": "// Based on Art_of_code's youtube tutorial on Gyroids.\n// https://www.youtube.com/watch?v=-adHIyjIYgk\nprecision mediump float;\n\n#define MAX_STEPS 100\n#define SURFACE_DIST.001\n#define MAX_DIST 200.\n\nfloat sdSphere(vec3 p, vec4 sphere){\n  return length(p-sphere.xyz)-sphere.w;\n}\n\nfloat sdBox(vec3 p, vec3 box){\n  p = abs(p)-box;\n  return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)),0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias, float xamp, float yamp){\n    p *= scale;\n    return abs(dot(sin(p)*xamp, cos(p.zxy)*yamp)-bias)/scale-thickness;\n}\nfloat GetDist(vec3 p){\n  //float box = sdSphere(p, vec4(vec3(0),3.4));\n  // p = abs(p);\n  float box = sdBox(p-vec3(0,0,0), vec3(2.5));\n  //float planed=p.y;\n  float t = iTime/12.;\n  float gyroid = sdGyroid(p, 10., min(.12,.1*sin(iTime)+.11), -1.4,2.*sin(t), cos(t));\n  // float gyroid2 = sdGyroid(p-.1, 21.);\n\n  float d = max(box, gyroid*.7);\n  // d = max(d-.05, gyroid2);\n  return d;\n}\n\nvec3 GetNormal(vec3 p){\n  vec2 e=vec2(.01,0);\n  float d=GetDist(p);\n  vec3 n=d-vec3(GetDist(p-e.xyy),GetDist(p-e.yxy),GetDist(p-e.yyx));\n  return normalize(n);\n}\n\nmat4 RotationX(float angle){\n  return mat4(1.,0,0,0,\n    0,cos(angle),-sin(angle),0,\n    0,sin(angle),cos(angle),0,\n  0,0,0,1);\n}\n\nmat4 RotationY(float angle){\n  return mat4(cos(angle),0,sin(angle),0,\n  0,1.,0,0,\n  -sin(angle),0,cos(angle),0,\n0,0,0,1);\n}\n\nmat4 RotationZ(float angle){\n  return mat4(cos(angle),-sin(angle),0,0,\n    sin(angle),cos(angle),0,0,\n    0,0,1,0,\n    0,0,0,1);\n}\n\nmat2 Rot2d(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat RayMarch(vec3 ro,vec3 rd){\n  float dO=0.;\n  for(int i=0;i<MAX_STEPS;i++){\n    vec3 p=ro+dO*rd;\n    float ds=GetDist(p);\n    dO+=ds;\n    if(dO<SURFACE_DIST||dO>MAX_DIST){\n      break;\n    }\n  }\n  return dO;\n}\n\nfloat GetLight(vec3 p){\n  mat4 r = RotationY(iTime);\n  vec4 lpos=vec4(1,2,3,1)*r;\n  \n  vec3 l=normalize(lpos.xyz-p);\n  vec3 n=GetNormal(p);\n  float diff=dot(n,l)*.5+.5;\n  float d=RayMarch(p+n*.02,l);\n  if(d<length(lpos.xyz-p)){\n    diff*=.4;\n  }\n  return diff;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n  vec3 color=vec3(0);\n  \n  float t = iTime/10.;\n  // camera\n  vec3 ro = vec3(0, 3, -2);\n  \n    ro.yz *= Rot2d(t*3.14+1.);\n    ro.xz *= Rot2d(t*6.2831);\n  \n\n  vec3 rd=GetRayDir(uv, ro, vec3(0),1.);\n\n  // trace scene\n  float d=RayMarch(ro,rd);\n\n  // material\n  vec3 p=ro+rd*d;\n  vec3 n = GetNormal(p);\n  float diffuse=GetLight(p);\n  float o=0.;\n  color=vec3(diffuse-o);\n  color.rg += n.xy*.2-d*.05;\n  fragColor=vec4(color,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}