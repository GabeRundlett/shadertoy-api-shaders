{
    "Shader": {
        "info": {
            "date": "1656026945",
            "description": "bird",
            "flags": 0,
            "hasliked": 0,
            "id": "3tdcRB",
            "likes": 13,
            "name": "Black n White Bird",
            "published": 3,
            "tags": [
                "bird"
            ],
            "usePreview": 0,
            "username": "BradyInstead",
            "viewed": 269
        },
        "renderpass": [
            {
                "code": "// Fork of \"Bird\" by BradyInstead. https://shadertoy.com/view/wdsfWM\n// 2020-12-30 23:59:38\n\n#define PI 3.14159265358979323846\n\n#define FLOOR_Y 3.\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat fnoise( in vec3 pos )\n{\n    float f = 0.0;\n\tvec3 q = 8.0*pos;\n    f  = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n    f += 0.0625*noise( q ); q = m*q*2.01;\n    return f;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdPlane( vec3 p)\n{\n\treturn abs(p.y);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec3 opCheapBend(in vec3 p , float amount)\n{\n    float k = amount; // or some other amount\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 opRotate(vec3 v, vec3 axis, float angle) {\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n\nfloat model(vec3 p)\n{\n    // set up\n    p*=.9;\n    p.y -= .5;\n    \n    \n    // bird\n    float bird;\n    \n    // movement\n    p.y += -1. - sin(iTime*14.) * .2 * sin(iTime);\n    \n    \n    // body\n    float body;\n    {\n    \tvec3 bp = p;\n        bp *= 1.;\n        bp.z += 1.25;\n        bp.y *= 1.25;\n        bp.y *= .6 + sin(bp.z*4. + 3.)*.1;\n        //bp.yx *= 1. - sin(bp.zy*25.)*.05;\n        \n        bp.z *= 1.2;\n        \n        body = sdCapsule( bp, vec3(0., -.25, .0), vec3(.1, .1, 2.), .3);\n    }\n    bird = body;\n    \n    \n    // head\n    float head;\n    {\n        vec3 hp = p;\n        hp.z -= .7;\n        hp.x -= .1;\n        hp.y -= .2;\n        \n        head = sdSphere(hp, .24);\n    }\n    bird = opSmoothUnion(bird, head, .2);\n    \n    \n    // beak\n    float beak;\n    {\n        // position\n        vec3 bp = p;\n        bp.z -= 1.2;\n        bp.x -= .1;\n        bp.y -= .1;\n        //bp.z *= .3;\n        //bp.y *= .75;\n        \n        bp.y += bp.z*.25;\n        \n        // rotate\n        bp = opRotate(bp, vec3(1., 0., 0.), - PI * .6);\n        \n        beak = sdRoundCone( bp, .025, .1, .3 ) * .8;\n    }\n    bird = opSmoothUnion(bird, beak, .1);\n    \n    \n    // wings\n    float wings = 9999999.;\n    {\n        // shaping\n    \tvec3 wp = opCheapBend(p, sin(iTime*14.) * .2 * sin(iTime));\n    \t//wp.z += pow(abs(wp.x), 4.)*.1;\n        wp.y -= .15;\n        \n        // rotate\n        wp = opRotate(wp, vec3(1., 0., 0.), - PI * .1);\n        \n        // texturing\n        if(wp.z < .35)\n        \t\twp.z += sin(wp.x * 30.) * .05 * wp.z;\n        \n        // wing frills\n       \tif(wp.z < -.1)\n            wp.z += sin(abs(wp.x) * 1.6) * .3;\n        else\n            wp.z += sin(abs(wp.x) * 2.75) * .1;\n        \n        // texturing\n        wp.y *= 1. - sin(wp.z*25.)*.05;\n        \n        //wp.z -= wp.x;\n        \n        \n        //if(wp.x > .2 || wp.x < -.1)\n    \t\twings = sdBox(wp, vec3(2.8, .05, .4));\n        \n        \n        wings *= .4;\n    }\n    bird = opSmoothUnion(bird, wings, .05); \n    \n    \n    // talons\n    float talons = 999999.;\n    {\n        for(float i = -1.; i <= 1.; i+=2.)\n        {\n            float index = 0.;\n            for(float j = 3.; j > 2.; j-=.3)\n            {\n            \n        \t\tvec3 wp = p;\n                \n        \t\twp = opCheapBend(wp, sin(iTime*14.) * .2 * sin(iTime));\n                \n        \t\twp.x += j * i;\n            \twp.x += .1;\n        \t\twp.z += .6;\n        \t\twp.y -= .2;\n        \t\twp.y *= 1.1;\n                wp.y += (index/3.)*.2;\n              \n        \n        \t\ttalons = min(talons, sdCapsule( wp, vec3(0., 0., 0.), vec3(.1, .1, .7), .025));\n                \n                index++;\n                \n            }\n        }\n    }\n    bird = opSmoothUnion(bird, talons, .3); \n    \n    \n    // tail\n    float tail;\n    {\n    \tvec3 wp = p;\n        wp *= .7;\n        \n        // positioning\n        //wp.z += 1.7;\n        wp.y += .1;\n        wp.z -= .7;\n        wp.z *= 1.2;\n        wp.x *= .6;\n        \n        // shaping\n       \t//wp.z += sin(wp.x * 30.) * .05;\n        //wp.z += abs(sin(wp.x*1.5));\n        \n        //if(wp.x > 1.)\n        \twp.z += sin(wp.x + PI/2.)*2.;\n        wp.x *= 1.5;\n        \n        wp.x *= 1. + wp.z*.9;\n        wp.x *= 1.4;\n        \n        // texturing\n        wp.y *= 1. - sin(wp.x*25.)*.3;\n        \n    \ttail = sdBox(wp, vec3(.5, .05, .4)) * .7;\n    }\n    bird = opSmoothUnion(bird, tail, .25);\n    \n    \n    // return\n    return bird;\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd)\n{\n    float dist = 0.;\n    for(int i = 0; i < 90; i++)\n    {\n\t\tfloat m = model(ro+rd*dist);\n        dist += m;\n        \n        if(m < .05) return dist;\n        else if(dist > 30.) break;\n    }\n    return -1.;\n}\n\nvec3 normal(vec3 pos)\n{\n    vec3 eps = vec3(.01, -.01, 0.);\n    \n    return normalize(vec3(\n        model(pos + eps.xzz) - model(pos + eps.yzz),\n        model(pos + eps.zxz) - model(pos + eps.zyz),\n        model(pos + eps.zzx) - model(pos + eps.zzy)));\n}\n\nfloat shadow(in vec3 pos, in vec3 ld)\n{\n    float spread = 3.;\n    float res = 1.0;\n\tfor(float t = .2; t < .4;)\n    {\n        float dist = model(pos+ld*t);\n        if(dist<.001) return 0.;\n        res = min(res, spread*dist/t);\n        t += dist;\n    }\n    return res;\n}\n\nvec3 background()\n{\n\treturn vec3(0.);  \n}\n\nvec3 shade(vec3 pos, vec3 nor, vec3 rd, float dist)\n{\n    if(dist < 0.) return background();\n    \n    vec3 ld = normalize(vec3(2., 10., 2.));\n    //vec3 ld = normalize(lp-pos);\n    \n    vec3 lightColor = vec3(.9, .6, .1) * 1.8;\n    \n    float dif = max(dot(nor,ld),0.);\n    float sha = 0.;\n    if(dif > .01) sha = shadow(pos, ld);\n    vec3 lin = vec3(dif*sha);\n    \n    vec3 col = lin;\n    \n    // bird\n    col *= lightColor;\n    \n    col = min(col, vec3(1.));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    float zoom = 3.;\n    vec3 ro = vec3(sin(iTime*.5)*zoom, zoom * 2., cos(iTime*.5)*zoom); \n    vec3 ta = vec3(0.);\t\t\t\t\n    \n    vec3 w = normalize (ta-ro);\n    vec3 u = normalize (cross (w, vec3(0., 1., 0.)));\n    vec3 v = normalize (cross (u, w));\n    mat3 mat = mat3(u, v, w);\n    vec3 rd = normalize (mat*vec3(p.xy,.5));\n    \n    float dist = raymarch(ro, rd);\n    vec3 pos = ro+rd*dist;\n    vec3 nor = normal(pos);\n    \n    vec3 col = shade(pos, nor, rd, dist);\n    \n    col = mix(col, background(), pow(dist/30., 2.));\n    \n    col = vec3(dot(col.rgb, vec3(0.299, 0.587, 0.114)));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}