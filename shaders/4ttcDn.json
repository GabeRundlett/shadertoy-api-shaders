{
    "Shader": {
        "info": {
            "date": "1532256143",
            "description": "Body members: joints  by  inverse kinematics\n+ quadratic Bezier ( cleanup of  [url]https://shadertoy.com/view/XdB3Ww[/url] )",
            "flags": 0,
            "hasliked": 0,
            "id": "4ttcDn",
            "likes": 2,
            "name": "QBezier + inv-K body",
            "published": 3,
            "tags": [
                "quadraticbezier",
                "inversekinematics"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 499
        },
        "renderpass": [
            {
                "code": "// QBezier from https://shadertoy.com/view/XtdyDn\n//         cleanup of https://shadertoy.com/view/XdB3Ww\n\n// -----------------------------------------------------------------\n//Find roots using Cardano's method. http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\nvec2 solveCubic2(vec3 a)\n{\n\tfloat p  = a.y - a.x*a.x/3.,\n\t      p3 = p*p*p,\n\t      q  = a.x* ( 2.*a.x*a.x - 9.*a.y ) /27. + a.z,\n\t      d  = q*q + 4.*p3/27.;\n    \n\tif(d>0.) {\n\t\tvec2 x = ( vec2(1,-1)*sqrt(d) -q ) *.5;\n        x = sign(x) * pow( abs(x) , vec2(1./3.) );\n  \t\treturn vec2( x.x+x.y -a.x/3. );\n  \t}\n    \n \tfloat v = acos( -sqrt(-27./p3)*q*.5 ) / 3.,\n \t      m = cos(v),\n \t      n = sin(v)*sqrt(3.);\n\n\treturn vec2(m+m,-n-m) * sqrt(-p/3.) - a.x/3.;\n}\n\n// How to solve the equation below can be seen on this image.\n// http://www.perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\n#define dd(a) dot(a,a)\n\nfloat dQBezier(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n\tb = mix( b+vec2(1e-4), b, abs(sign(b*2.-a-c)) );\n\tvec2 A = b-a,\n\t     B = c-b-A,\n\t     C = p-a,\n\t     D = A*2.,\n\tP = solveCubic2( vec3(-3.*dot(A,B), dot(C,B)-2.*dd(A), dot(C,A))/-dd(B) );\n    P = clamp( P,0.,1.); // curve parameterization\n\n\treturn sqrt( min( dd( (D+B*P.x)*P.x -C ),\n                      dd( (D+B*P.y)*P.y -C )));\n}\n\n// ---------------------------------------------------------------\n\n\n#define knee(p0,p2,L) ( l = p2-p0,                             \\\n                        h = sqrt(max(0.,L*L-dot(l,l)))/2.,     \\\n                        (p0+p2)/2. +  h * normalize( vec2(-l.y,l.x) ) )\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float t = iTime, h;\n    vec2 R =   iResolution.xy,\n         U = ( u+u - R ) / R.y;\n    \n\tvec2 p0 = vec2(0,.1), l,                            // body end\n\t     p2 = p0 + vec2(0,.4);                          // distant end\n\n\tfloat d = length(p0+vec2(0,.75)-U)/2.;              // head\n    d = min( d, dQBezier(U,p0,(p0+p2)/2.,p2) / 1.2 );   // body\n    \n    p0.x += .125; p0.y -= .1;\n    p2 = p0 + vec2(cos(t*1.3)*.4, -.5 +sin(t*.3)*.48 ); \n    d = min( d, dQBezier(U,p0,knee(p0,p2,1.),p2) );     // right leg\n\n    t += .5;\n    p0.x -= .25;\n    p2 = p0 + vec2(cos(t*1.3)*.4, -.5 +sin(t*.3)*.48 ),\n    d = min( d, dQBezier(U,p0,knee(p0,p2,1.),p2) );     // left leg\n    \n    t += .5; p0.y += .6;\n    p2 = p0 + vec2(-.4+cos(t*1.3)*.38, sin(t*.3)*.4 );\n    d = min( d, dQBezier(U,p0,knee(p0,p2,1.),p2) );     // left hand\n  \n    t += .5; p0.x += .25;\n    p2 = p0 + vec2(.4+cos(t*1.3)*.38, sin(t*.3)*.4 );\n    d = min( d, dQBezier(U,p0,knee(p0,p2,1.),p2) );     // right hand\n  \n\t//O = vec4(smoothstep(5./R.y,0., d-.1 ) );\n    d/=.1; O = vec4(1.-d*d);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}