{
    "Shader": {
        "info": {
            "date": "1496164193",
            "description": "to be multiplied with \nhttps://www.shadertoy.com/view/XsXfD4\nto have start and end of a note better.\n\nto use\nhttps://www.shadertoy.com/view/Xl3BD4\nfor chords\n\nmusic is a lot simpler after you get how to chain-ruled tessellations. ",
            "flags": 8,
            "hasliked": 0,
            "id": "MdXfW4",
            "likes": 16,
            "name": "mod() tilemap music sheet",
            "published": 3,
            "tags": [
                "sound",
                "tiled",
                "audio",
                "mod",
                "modulo",
                "audiovisual",
                "tesselation",
                "tilemap",
                "chainrule",
                "floorulation",
                "starguitar"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 2142
        },
        "renderpass": [
            {
                "code": "//brother: https://www.shadertoy.com/view/XsXfD4\n//thjis shader is an old but still valid initial basis for many things\n//as such it is very naive and wrong about a few details\n//, that get fixed in later shaders that are based on it.\n\n/*\nthe trick top good \"audiovisual\"\nis to FIRST define an sdf function, that quickly returns a 2d sdf, ideally with good\nhttps://www.shadertoy.com/results?query=halfspace\nrastrization, that also happens to resemble a music sheet (within its rasterization), like a \nhttps://www.shadertoy.com/results?query=blackmidi\nAND that, iff you sample the signs of some points of it\n, after doing biject() of functions of \nhttps://www.shadertoy.com/results?query=rationalstride\nto set a noteKey of a sequence of seq4() (of this shader)\n\nthis shader has that the other way around\n, it has a bias to define a melody first, and derive an image from that.\nin 2018-oct i learned that this shader is a VERY inefficient/special approach \n, for being rasterized already, while an [sdf comes first] approach defers the rasterization via \n  https://www.shadertoy.com/results?query=tartan\n, if you also want to render the same thing, but not just as squares\n, if you wand high (visual) performance and less opengl crashes (by displaying a DFT or waveform)\n\nthis sdf can be voxels, if you like voxels, or any other \nhttps://www.shadertoy.com/results?query=honeycomb\n(to be traversed for video, or just tapped for audio)\nor it can just be any float-precision sdf, like a distance to a sphere or any \nhttps://www.shadertoy.com/results?query=blackmidi\ngradient (hopefully with harmonic frequency-filters, that change over time to emulate a cadence)\n\nthis sdf than should return more than just a distance (whos sign determines if a frequency is audible)\nbut also return NoteEndTime, NoteVolume, and als the dsp parameters of FM\nvia different (but mostly similar) gradients, that take the very same inputs.\n*/\n\n\n/*\nit is VERY trivial to CG-render something \nhttps://www.shadertoy.com/results?query=audiovisual\nhttps://en.wikipedia.org/wiki/Star_Guitar#Music_video\nhttps://vimeo.com/17149977\nin @shadertoy, in real time (3d/parametric/hashed) for ANY \"melody\"\nI have all (missing) elements for it within the shadertoy tags:\nhttps://www.shadertoy.com/results?query=blackmidi\nhttps://www.shadertoy.com/results?query=halfspace\nhttps://www.shadertoy.com/view/4ttBD4\n...\n*/\n\n\n/*\nmelody is \nhttps://www.youtube.com/watch?v=W5Z35jk1E4w\nis\n[The Magic Inside] by [Daniel Ingram and Lena Hall]\nis ponies:\nhttps://www.youtube.com/watch?v=buuYIBejsuM\n*/\n\n/*\nyour waveform editor ma have an y=f(x) function to synthesize a sample.\nYou would not think to define a full midi track with all instromends as single function.\nBut it is pretty easy, and with Rasterisation it is pretty efficient.\n\nMany concepts that aid encoding music are usually not associated with music, \n...unless you insist on quantizing a midi, this shader goes down this path:\nhttps://en.wikipedia.org/wiki/Quantization_(signal_processing)\nhttps://en.wikipedia.org/wiki/Rasterisation\nhttps://en.wikipedia.org/wiki/Tessellation\nhttps://en.wikipedia.org/wiki/Wallpaper_group\nhttps://en.wikipedia.org/wiki/Glide_reflection\n*/\n\n\n/*\nxAxis=time\nyAxis=pitch\ndefining a bitmap to be used as:\n- a bitmap factor (for the below 2)\n- - a 3d distance field modifier\n- - a Webaudio input \"Sound\" buffer\n\nThe tricky part is to define it procedurally, with subroutines\n...instead of defining an array of notes.\nProcedurally, I get a lot of repeating sequences that can be transformed in many ways.\nThat creates an associative sequence library.\n\nThis is my first attempt at this. first steps are the hardest, building a function library\n... learning what works best, pioneering through all the useless deserts.\n\ni did an abc parser    in second-life-script, so this should be simple.\ni did ChordName2Cord() in second-life-script, so this should be simple.\nbut the wide namespace of valid chord names made the parser 55k in size, \n...able to parse ALL jazz chords. this will likey get inside here, too, soon.\n*/\n\n#define zoom 50.\n//#define frame(u) zoom*(u-.5*iResolution.xy)/iResolution.y\nvec2 frame(vec2 u){u/=iResolution.xy;\n u.x*=iResolution.x/iResolution.y;\n return u*zoom;}\n\n//if(a==black_piano_key)return 1.;return 0.;\nfloat keyShade(float a){a=mod(a,12.);return (mod(a+step(5.,a),2.));}\n\n//a sequence of 4 notes, set by [a], is checked for a match with u.\nfloat seq4(vec2 u,vec4 a){\n u.x=mod(u.x,4.);\n for (int i=0;i<5;i++){if(float(i)==u.x&&a[i]==u.y)return 1.;}return 0.;}\n//i have MANY ideas to improve the seq4() function\n//,but as of 2018-oct-20 none of them ever got implemented on shadertoy\n//, because all of these are contextually biased different caes.\n//It will have the \"audioviual\" tag, one i do improve significantly on seq4()\n\n//LeadTail() is one of 2 sequences\nfloat LeadTail(vec2 u,float c){\n if(c==0.)return seq4(u,vec4(9,11,9,7));\n if(c==1.)return seq4(u,vec4(8,7,5,3));\n return 0.;}\n//initael Lead has 2 main sections, in 2 variants each.\n//first  section repeats more, and is less \"sequential\"\n//second section is labeled LeadTail(), is one of 2 simple 4_key_sequences.\nfloat Lead(vec2 u){\n float c=floor(u.x/16.);\n c=mod(c,2.);\n u.x=mod(u.x,16.);\n if(u.x>4.*3.-1.)return LeadTail(u,c);\n float l=3.+c*2.;//the lower note of the period varies.\n u.x=mod(u.x,3.);//a 3*periodic (1*low 2*high) interval is \"LadHead()\":\n if(u.x>0.&&u.y==8.)return .7+.3*step(u.x,1.);//the higher note has 2*length, second part has less color.\n else if(u.x<1.&&u.y==l)return 1.;//else lower note of the period\n return 0.;}\n \n//sequence for baselines, tend to be held down for longer;\n//....x got divided by something to make notes longer. \nfloat seq4b(vec2 u,vec4 a){\n u.x=mod(u.x,4.);\n for (int i=0;i<5;i++){\n  float j=float(i);\n  if(a[i]==u.y){\n   if(j<u.x&&j>u.x-1.)return .7;\n   if(float(i)==u.x)return 1.;}\n }return 0.;}\n//single long note with pitch [a.x], from [a.y] to [a.z] \nfloat lon(vec2 u,vec3 a){\n if(u.y==a.x){\n  if(u.x==a.y)return 1.;\n  return step(a.y,u.x)*step(u.x,a.z)*.7;\n }return 0.;} \n//pmodN() folds y to create one overtone.\nfloat pmodN(float y){float c=floor(y/12.);\n if(y>0.||y<-24.)return -99.;//if (out of bounds) become -99, outside of other iteration loops, would be inaudible.\n return mod(y,12.);}//else if(within bouns), modulo fold.\n//initial baseline has an oddly long note, pitch 1, from 15 to 25, played 2x.\nfloat BaseMainOdd(vec2 u){u.x=mod(u.x,32.);return lon(u,vec3(1,16,27));}\n//initial baseline  has one \"overwrite\" sequence.\nfloat BaseMainO1(vec2 u){return seq4b(u,vec4(1,8,14,8)-24.);}\n//initial baseline sequence with one overwrite.\nfloat BaseMain(vec2 u){\n if(u.x>15.&&u.x<16.+8.){\n  if(u.x>21.)return lon(u,vec3(-16,22.,24.));\n  if(u.x>19.)return lon(u,vec3(-23,20.,22.));\n  return BaseMainO1(u);}//end of the overwrite.\n //start of the initial main baseline.\n u.y=pmodN(u.y);//pmodN() creates one overtone.\n u.x/=8.;//8* longer note durations\n u.x=mod(u.x,4.);return seq4b(u,vec4(8,6,1,3));}//main base sequence.\n//initial baseline has one specific (longer) lote near the end\nfloat long2(vec2 u){return lon(u,vec3(-16,52,55));}\n\nfloat BaseMix(vec2 u){return max(long2(u),max(BaseMainOdd(u),BaseMain(u)));}\n\n//melody to \"i am just a pony\"\n// as in https://www.youtube.com/watch?v=xMJRpDnvlm0\nfloat IAmJustAPony(vec2 u){\n //if(u.x<0.) return 0.;//(if u.x<0 is an issue) left end is 0;\n if(u.x<64.)//show only one full unrepeated segment\n return max(BaseMix(u),Lead(u));}\n\n//return 1 on some tiles, 0 on others.\nfloat sheet(vec2 u){u=floor(u); //u is tileID positions.\n //u.x=mod(u.x,64.);\n return IAmJustAPony(u);}//if(IAmJustAPony(u))return 1.;return 0.;}\n\nvoid mainImage(out vec4 O,in vec2 U){vec2 u=frame(U);\n u.y-=30.;//transpose by 1 octave.\n vec2 m=frame(iMouse.xy);\n float d=sheet(u); \n u.y=keyShade(floor(u.y))*1.2;//blue==black piano keys.\n u.x=fract(u.x);\n u*=.5;//to make red more visible.\n O=vec4(d,u,1.);}  ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nmelody is \nhttps://www.youtube.com/watch?v=W5Z35jk1E4w\nis\n[The Magic Inside] by [Daniel Ingram and Lena Hall]\nis ponies:\nhttps://www.youtube.com/watch?v=buuYIBejsuM\n*/\n\n/*\nThis is just a start. It lacks over time overlapping (or bleeding) tiles .\nI think this is best solved in a 2pass, just like an echo, like occlusion, shadows.\n*/\n\n//the [children of Nancarrow] insist on an [irrational tempo]\n// in spite of planck scales and quantum physics (and other audio quality modifiers)\n// apparently insisting on quantizing all the music.\n#define tempo sqrt(5.)*2.\n\n//this implements an attempt of cutting off a period only at its end.\n// It lacks offset calculations [offset-welding] for longer notes\n// ,therefore sounds bad for longer notes, you can hear the gaps.\n//it is a relatively simple bug, easy to bix, but i am bored of it.\n\n//#define modPackFilter\n//the thing i wanted to inclide via [modPackFilter] is\n//  https://www.shadertoy.com/view/XsXfD4\n//but without offset-welding it sounds bad on longer notes.\n\n#define tau acos(-1.)*2.\n\n//return wavelength of piano key, [a] is relative to C4\nfloat wkey(float a){return 440.*pow(2.,a/12.);}\n//return 12th root of [a]\n//float troot(float a){a=max(.001,abs(a));return pow(a,12./a);}\n\n//this lacks [offset-welding], all else is \"fine\", as in , max volume till the end.\n//return how many times period [a] fits into period [b].\nfloat howManyAfitInB(float a, float b){if(a==0.)return 0.;return floor(b/a);}\nfloat howManyFitIn(float a){if(a==0.)return 0.;return floor(1./a);}\n//if (x < largest_possible_stack_of_interval_p ) return 1; return 0; //[p]PeriodLength (wavelength)\nfloat packsin(float x,float p){return step(abs(x),p*howManyFitIn(p));}\n//is oblivious about negative input ranges. see\n// https://www.shadertoy.com/view/MsXfWN\n//or its parent \n// https://www.shadertoy.com/view/XsXfD4\n\n//MsXfWN actually seems to almost solve [offset-welding]\n\n//if(a==black_piano_key)return 1.;return 0.;\n//float keyShade(float a){a=mod(a,12.);return (mod(a+step(5.,a),2.));}\n//for the above, it is likely simple to instead...\n// define \"not white\" piano keys, than to define \"black\" piano keys.\n//the piano by iq uses the \"not white\" keys approach to remove some black keys.\n//this likely saves some divisions, but adds one max(a,-b), better overall?\n\n//very often you parse a sequence of 4 notes of the same length per note.\n//thsis checks a single freuency_band==key for a match with such a sequence\n//for a set slice of time.\n//a is 4 numbers, representing a seuence of 4 different enumerated piano keys==pitches.\n//u.xy is a sqare on the sheed as you see it in the shader.\n//it retuens if there is a note played on that square or not. later on, notes tint the sheet red.\n//a sequence of 4 notes, set by [a], is checked for a match with u.\nfloat seq4(vec2 u,vec4 a){\n u.x=mod(u.x,4.);//likely faster to insist on using u.x=clamp(u.x,0.,3.), but harder to debug?\n for (int i=0;i<5;i++){if(float(i)==u.x&&a[i]==u.y)return 1.;}return 0.;}\n\n//LeadTail() is one of 2 sequences with high freuency range.\n//inital Lead has 2 main sections, in 2 variants each.\n//first  section repeats more, and is less \"sequential\"\n//second section is labeled LeadTail(), is one of 2 simple 4_key_sequences.\nfloat LeadTail(vec2 u,float c){\n if(c==0.)return seq4(u,vec4(9,11,9,7));\n if(c==1.)return seq4(u,vec4(8,7,5,3));\n return 0.;}\n//Lead() is one of 2 sequences with high freuency range.\nfloat Lead(vec2 u){\n float c=floor(u.x/16.);\n c=mod(c,2.);\n u.x=mod(u.x,16.);\n if(u.x>4.*3.-1.)return LeadTail(u,c);\n float l=3.+c*2.;//the lower note of the period varies.\n u.x=mod(u.x,3.);//a 3*periodic (1*low 2*high) interval is \"LadHead()\":\n if(u.x>0.&&u.y==8.)return .7+.3*step(u.x,1.);//the higher note has 2*length, second part has less color.\n else if(u.x<1.&&u.y==l)return 1.;//else lower note of the period\n return 0.;}\n\n//sequence for baselines, tend to be held down for longer;\n//....x got divided by something to make notes longer. \nfloat seq4b(vec2 u,vec4 a){\n u.x=mod(u.x,4.);\n for (int i=0;i<5;i++){\n  float j=float(i);\n  if(a[i]==u.y){\n   if(j<u.x&&j>u.x-1.)return .7;\n   if(float(i)==u.x)return 1.;}\n }return 0.;}\n//single long note with pitch [a.x], from [a.y] to [a.z] \nfloat lon(vec2 u,vec3 a){\n if(u.y==a.x){\n  if(u.x==a.y)return 1.;\n  return step(a.y,u.x)*step(u.x,a.z)*.7;\n }return 0.;} \n//pmodN() folds y to create one overtone.\nfloat pmodN(float y){float c=floor(y/12.);\n if(y>0.||y<-24.)return -99.;//if (out of bounds) become -99, outside of other iteration loops, would be inaudible.\n return mod(y,12.);}//else if(within bouns), modulo fold.\n//initial baseline has an oddly long note, pitch 1, from 15 to 25, played 2x.\nfloat BaseMainOdd(vec2 u){u.x=mod(u.x,32.);return lon(u,vec3(1,16,27));}\n//initial baseline  has one \"overwrite\" sequence. 3rd long note is replaced by 6 shorter notes.\nfloat BaseMainO1(vec2 u){return seq4b(u,vec4(1,8,14,8)-24.);}\n//initial baseline sequence with one overwrite.\nfloat BaseMain(vec2 u){\n if(u.x>15.&&u.x<16.+8.){\n  if(u.x>21.)return lon(u,vec3(-16,22.,24.));\n  if(u.x>19.)return lon(u,vec3(-23,20.,22.));\n  return BaseMainO1(u);}//end of the overwrite.\n //start of the initial main baseline.\n u.y=pmodN(u.y);//pmodN() creates one overtone.\n u.x/=8.;//8* longer note durations\n u.x=mod(u.x,4.);return seq4b(u,vec4(8,6,1,3));}//main base sequence.\n//initial baseline has one specific (longer) lote near the end\nfloat long2(vec2 u){return lon(u,vec3(-16,52,55));}\n\nfloat BaseMix(vec2 u){return max(long2(u),max(BaseMainOdd(u),BaseMain(u)));}\n\n//melody to \"i am just a pony\"\nfloat IAmJustAPony(vec2 u){\n u.x=mod(u.x,64.);\n //if(u.x<0.) return 0.;//left end is 0;\n //if(u.x<64.)//stop or keep looping?\n return max(BaseMix(u),Lead(u));}\n\n//return 1 on some tiles, 0 on others.\nfloat sheet(vec2 u){u=floor(u); //u is tileID positions.\n return IAmJustAPony(u);}//if(IAmJustAPony(u))return 1.;return 0.;}\n\n//return average speaker position, assuming that range [0..[k]] keys on a sheet play at once, within key[l] till key[l+r] (inclusively)\nfloat sheetAcc(float x){ \n //midi poano has keys range [1..128], with middle C4 = key #40 ?\n float a=0.;\n for(float i=-41.;i<89.;i++){//is a bit larger than full midi piano range\n  if((sheet(vec2(x,i))>0.)){\n   float w=wkey(i-12.*log2(tempo));//w==frequency in Hz; if(i==40)w=440. ish ?\n   #ifdef modPackFilter\n    float d=packsin(fract(x),1./w);//an incomplete filter, uses wavelength.\n    a+=d*sin(w*fract(x)*tau);//periodic waveform, better for single short notes.\n   #else\n    a+=sin(tau*x*w);//waveform, cut off by tiles\n   #endif\n }}\n\n a/=4.;//average of [k] sinusoids. if (more sinusoids play at the same time) you fucked up\n //a=clamp(a,-1.,1.);//range clamping, the lazy solution.\n //a=atan(a)/(acos(-0.));//range atanIng: a=atan(a)*.5/pi//evenly distort frequencies over time in favor of keeping ampllitude sums within range [-1..1]\n //a=log(a)-log(1.);//naaah, not worth it!\n //a=fract(abs(a))*sign(a);//physically a horrible idea. it tortures the speaker!\n return a;\n}\n\nvec2 mainSound( in int samp,float t){\n return vec2(sheetAcc(t*tempo));\n //float w=wkey(0.);//w=440.;\n //return vec2(sin(tau*t*w));\n}\n\n//float fade(float t){return exp(-3.0*t);}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}