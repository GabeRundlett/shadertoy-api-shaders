{
    "Shader": {
        "info": {
            "date": "1716907690",
            "description": "Effect of multiple scattering, with [url=https://www.shadertoy.com/view/XXc3DN]δ-Eddington approximation[/url], on clouds.\nLeft - single-scattering approximation.\nRight - δ-Eddington approximation.",
            "flags": 0,
            "hasliked": 0,
            "id": "M333RX",
            "likes": 21,
            "name": "Clouds with delta-Eddington",
            "published": 3,
            "tags": [
                "scattering"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 244
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Effect of multiple scattering, with δ-Eddington approximation\n// (see https://www.shadertoy.com/view/XXc3DN), on clouds.\n\n// Single-scattering approximation predicts, for looking directly at\n// Sun through the cloud of optical depth T, the following direct\n// and diffuse components:\n//     Idirect  ~   exp(-T)\n//     Idiffuse ~ T*exp(-T)\n// For other view directions, this doesn't work: for one, the slant\n// optical depths in view (Tview) and Sun (Tsun) directions may differ.\n// But if the directions are close enough, an approximation\n//     Idiffuse ~ Tview*exp(-0.5*(Tview+Tsun))\n// is passable, though it does break down eventually.\n// The two-stream model (https://www.shadertoy.com/view/l3t3z8)\n// for multiple scattering predicts the same for the direct component,\n// but has much milder falloff for the diffuse component for large T,\n// assuming no absorption:\n//     Idiffuse ~ 1/T\n// With absorption, the falloff is again exponential, but\n// corresponding to only absorption optical depth.\n// The δ-Eddington approximation (https://www.shadertoy.com/view/XXc3DN)\n// appears to predict something similar, except it uses scaled\n// optical depth (since the light scattered into the forward δ-peak\n// is treated as unscattered).\n\n#define SINGLE_SCATTERING_HACK 2\n\nconst float pi=3.14159265358979;\n\n//==============================================================================\n// https://www.shadertoy.com/view/4XsXRn\n\n// Draine phase function.\n//     B.T. Draine. 2003. Scattering by interstellar dust grains. I. Optical and ultraviolet. The Astrophysical Journal 598, 2 (2003), 1017. https://doi.org/10.1086/379118\n// NOTE: this reduces to Henyey-Greenstein for a=0,\n// to Rayleigh for g=0, a=1 and to Cornette-Shanks for a=1.\nfloat phase_draine(float a,float g,float x)\n{\n    float d=1.0+g*g-2.0*g*x;\n    return 1.0/(4.0*pi)*(1.0-g*g)/(1.0+a*(1.0+2.0*g*g)/3.0)* // <-- constant factor.\n        (1.0+a*x*x)/(d*sqrt(d));\n}\n\nfloat phase_rayleigh(float x)\n{\n    return phase_draine(1.0,0.0,x);\n}\n\n// Parametrization by droplet size.\n// Input: droplet size, in micrometres.\n// Valid range: 5<d<50.\nvec4 phase_params_mie(float d)\n{\n    return vec4(\n        exp(-0.0990567/(d-1.67154)),          // gHG\n        exp(-2.20679/(d+3.91029)-0.428934),   // gD\n        exp(3.62489-8.29288/(d+5.52825)),     // alpha\n        exp(-0.599085/(d-0.641583)-0.665888)  // wD\n    );\n}\n\n// \"Jendersie-d'Eon phase function\".\n// NOTE: this reduces to pure Henyey-Greenstein for phase_mie(vec4(g,0,0,0),c).\nfloat phase_mie(vec4 M,float x)\n{\n    return mix(phase_draine(0.0,M.x,x),phase_draine(M.z,M.y,x),M.w);\n}\n\n// NOTE: unlike Henyey-Greenstein, the asymmetry parameter (defined\n// as <cos(θ)> = 2*π * ∫ p(θ)*cos(θ)*sin(θ) dθ on [0;π]) for Draine\n// phase function is not simply g, but g*(1+a*(3+2*g^2)/5)/(1+a*(1+2*g^2)/3).\nfloat asymmetry_draine(float a,float g)\n{\n    return g*(1.0+a*(3.0+2.0*g*g)/5.0)/(1.0+a*(1.0+2.0*g*g)/3.0);\n}\n\nfloat asymmetry_mie(vec4 M)\n{\n    return mix(M.x,asymmetry_draine(M.z,M.y),M.w);\n}\n\n// Expressions for <cos^2(θ)>.\n// NOTE: second moment of Legendre expansion is (3*<cos^2(θ)>-1)/2\n// (e.g. g^2 for Henyey-Greenstein).\nfloat cos2_draine(float a,float g)\n{\n    float g2=g*g,g4=g2*g2;\n    return (1.0+2.0*g2+(3.0*a/35.0)*(7.0+20.0*g2+8.0*g4))/(3.0+a*(1.0+2.0*g2));\n}\n\nfloat cos2_mie(vec4 M)\n{\n    return mix(cos2_draine(0.0,M.x),cos2_draine(M.z,M.y),M.w);\n}\n\n//==============================================================================\n// https://www.shadertoy.com/view/XXc3DN\n\n// Compute the Eddington approximation. Input:\n//     w  - single-scattering albedo (ω in [3])\n//     g  - anisotropy parameter\n//     A  - ground albedo\n//     y  - cos of zenith angle of direct light (μ0 in [3])\n//     T  - total optical depth of the layer (Δτ in [3])\n//     S  - incident-beam flux\n//     Fd - external downward diffuse flux at top (F0↓ in [3])\n//     Fu - external upward diffuse flux at bottom (F0↑ in [3])\n//     t  - optical depth of current position (τ in [3])\n// Returns (diffuse-down,diffuse-up,unscattered) fluxes.\nvec3 F_Eddington(float w,float g,float A,float y,float T,float S,float Fd,float Fu,float t)\n{\n    float l=sqrt(3.0*(1.0-w)*(1.0-w*g));                           // λ in [3].\n    float P=(2.0/3.0)*l/(1.0-w*g);\n    float a=(3.0/4.0)*w*S*(1.0+g*(1.0-w))/(1.0/(y*y)-l*l);         // α in [3].\n    float b=(1.0/2.0)*w*S*(3.0*g*(1.0-w)*y+1.0/y)/(1.0/(y*y)-l*l); // β in [3].\n    // Compute the constants C1, C2 to\n    // satisfy the boundary conditions:\n    //     G(0)+H(0)=Fd\n    //     G(T)-H(T)=Fu+a*(G(T)+H(T)+y*S*exp(-T/y))\n    float L=exp(-l*T),Y=exp(-T/y);\n#if 1\n    // WARNING: GLSL uses column-major notation.\n    // Mathematically, this is a 2x3 matrix.\n    mat3x2 M=mat3x2( \n        1.0-P , ((1.0+P)-A*(1.0-P))/L,\n        1.0+P , ((1.0-P)-A*(1.0+P))*L,\n        Fd+a+b, Fu+Y*(a-b+A*(y*S-a-b)));\n    float C1=determinant(mat2(M[2],M[1]))/determinant(mat2(M[0],M[1]));\n    float C2=determinant(mat2(M[0],M[2]))/determinant(mat2(M[0],M[1]));\n#else\n    // Same as above, but written fully in scalar form.\n    float D=((1.0+A)*P*P+(1.0-A))*(L*L-1.0)-2.0*P*(L*L+1.0);\n    float C1=-L/D*(\n        (P+1.0)*(A*(S*y-a-b)+(a-b))*Y+\n        L*(A*P+P+A-1.0)*(a+b)+\n        L*(A*(P+1.0)+P-1.0)*Fd+\n        (P+1.0)*Fu);\n    float C2=-1.0/D*(\n        (P-1.0)*(A*(S*y-a-b)+(a-b))*L*Y+\n        (P*(1.0+A)+(1.0-A))*(a+b)+\n        (P*(1.0+A)+(1.0-A))*Fd+\n        (P-1.0)*L*Fu);\n#endif\n    float G=   C2*exp(-l*t)+C1*exp(+l*t) -a*exp(-t/y);\n    float H=P*(C2*exp(-l*t)-C1*exp(+l*t))-b*exp(-t/y);\n    return vec3(G+H,G-H,y*S*exp(-t/y));\n}\n\n// The meaning is same as above, with added parameter\n//     f  - fractional scattering into forward peak\nvec3 F_delta_Eddington(float w,float g,float f,float A,float y,float T,float S,float Fd,float Fu,float t)\n{\n    // Under the δ-Eddington approximation, the parameters are\n    // transformed as follows:\n    //     g' = (g-f)/(1-f)\n    //     t' = (1-w*f)*t\n    //     w' = (1-f)*w/(1-w*f)\n    // This can be further simplified under the common\n    // assumption that f=g^2, which we don't make here.\n    return F_Eddington(\n        (1.0-f)*w/(1.0-w*f),\n        (g-f)/(1.0-f),\n        A,\n        y,\n        (1.0-w*f)*T,\n        S,\n        Fd,\n        Fu,\n        (1.0-w*f)*t);\n}\n\n//==============================================================================\n\nvec3 xyz2rgb(vec3 xyz)\n{\n    return mat3( // WARNING: column-major.\n        +3.2404542, -0.9692660, +0.0556434,\n        -1.5371385, +1.8760108, -0.2040259,\n        -0.4985314, +0.0415560, +1.0572252)*xyz;\n}\n\nvec3 rgb2xyz(vec3 rgb)\n{\n    return mat3( // WARNING: column-major.\n        0.4124, 0.2126, 0.0193,\n        0.3576, 0.7152, 0.1192,\n        0.1805, 0.0722, 0.9505)*rgb;\n}\n\n//==============================================================================\n\nuint hash(uint x)\n{\n    x^=x>>15;\n    x^=(x*x)|1u;\n    x^=x>>17;\n    x*=0x9E3779B9u;\n    x^=x>>13;\n    return x;\n}\n\nfloat hash(vec2 p) {return float(int(hash(uint(int(p.x)+(int(p.y)<<16)))))*4.6566129e-10;}\n\nfloat noise(vec2 p)\n{\n    vec2 i=floor(p),f=fract(p),e=vec2(0,1);\n    f=f*f*f*(10.0+f*(-15.0+f*6.0));\n    return mix(mix(hash(i+e.xx),hash(i+e.yx),f.x),\n               mix(hash(i+e.xy),hash(i+e.yy),f.x),f.y);\n}\n\nfloat fbm(int n,float a,float b,vec2 p)\n{\n    float ret=0.0,w=1.0;\n    float t=0.125*iTime;\n    p+=t;\n    for(int i=0;i<n;++i)\n    {\n        ret+=w*noise(p);\n        w*=a;\n        p=b*mat2(0.6,-0.8,0.8,0.6)*p+vec2(3,-2)*t;\n    }\n    return ret;\n}\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 xy=(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float focus=1.5;\n    vec3 view_dir=normalize(vec3(xy,focus));\n    vec3 sun_dir=normalize(vec3(0.5,0.5,focus));\n    float cosS=sun_dir.z;                   // Cosine of solar zenith angle.\n    float cosV=view_dir.z;                  // Cosine of view zenith angle.\n    float Isc=128e3;                        // Solar illuminance constant.\n    float Lref=10.0e3;                      // Reference luminance (typical cloudy noon zenith).\n    float droplet=7.0;                      // Water droplet size in cloud, in μm.\n    float A=0.17;                           // Ground albedo.\n    // Rayleigh-only color (luminance) of the atmosphere.\n    vec3 sky_col=xyz2rgb(vec3(1288,1316,2715)-vec3(1343,1326,2918)*(1.0-cosS));\n    // Color (illuminance here!) of the Sun.\n    vec3 sun_col=Isc*vec3(1,1,1);\n    vec4 M=phase_params_mie(droplet);\n    float p=phase_mie(M,dot(view_dir,sun_dir));\n    float w=0.915; // Typical single-scattering albedo of clouds.\n    // See https://amt.copernicus.org/articles/13/907/2020/amt-13-907-2020.pdf:\n    // \"For Ci–Cs, 95% of the SSAc values are estimated to be\n    // between 0.84 and 0.99 using the diffuse radiation.\"\n    float g=asymmetry_mie(M);\n    float f=(3.0*cos2_mie(M)-1.0)/2.0;\n    float Tmax=17.0; // Maximum cloud optical depth.\n    float T=Tmax*(1.0-tanh(exp(2.0*fbm(8,0.58,1.7,xy)))); // Cloud optical depth.\n    T+=0.1; // Typical aerosol optical depth of clear atmosphere.\n    vec3 col=vec3(0.0),colSS=vec3(0),colMS=vec3(0);\n    // Single-scatering approximation.\n    // Note that the whole 0.5*(cosS+cosV) thing is a hack.\n    colSS+=sky_col*exp(-T);                              // Transmitted part.\n    colSS+=p*sun_col*(T/cosV)*exp(-T/(0.5*(cosS+cosV))); // Single-scattered direct sunlight.\n    // Multiple-scattering approximation.\n    // Computed per channel.\n    for(int k=0;k<3;++k)\n    {\n        vec3 F=F_delta_Eddington(\n            w,g,f,A,cosS,T,\n            sun_col[k],pi*sky_col[k],0.0,\n            T);\n        // The δ-Eddington approximation hands us two things:\n        // the downward flux of the direct (0th order scattering)\n        // light (which we do not see, unless we look directly into\n        // the Sun), and diffuse fluxes (both upward and downward),\n        // which are assumed to have the radiance distribution\n        //     L=L0+L1*cosθ\n        // Which means, flux from hemisphere in direction θ is\n        //     F=pi*L0+2/3*pi*L1*cosθ\n        // In particular\n        //     L0=(Fdown+Fup)/(2*pi)\n        //     L1=(Fdown-Fup)/(4/3*pi)\n        float L0=(F.x+F.y)/(2.0*pi);\n        float L1=3.0*(F.x-F.y)/(4.0*pi);\n        colMS[k]+=L0+cosV*L1;\n    }\n    if(xy.x<sin(iTime)) col=colSS;\n    else\n    {\n        // Diffuse part of the δ-Eddington approximation is\n        // VERY diffuse. It lacks characteristic strong\n        // forward-scattering peak of the phase function.\n        // This is especially apparent for cloudless skies\n        // (i.e. only atmospheric aerosol layer).\n        // We use the following hacks to recover some of it.\n#if   SINGLE_SCATTERING_HACK==2\n        // New version.\n        // In spirit of TMS method described in\n        //     Nakajima T, Tanaka M (1988) Algorithms for radiative intensity calculations in moderately thick atmospheres using a truncation approximation. J Quant Spectrosc Radiat Transfer 40:51–69\n        // and in chapter 6.2 of\n        //     Laszlo, I., Stamnes, K., Wiscombe, W. J., & Tsay, S.-C. (2016). The Discrete Ordinate Algorithm, DISORT for Radiative Transfer. Light Scattering Reviews, Volume 11, 3–65. doi:10.1007/978-3-662-49538-4_1 \n        // we take the difference between \"unscattered\" fluxes\n        // in original and δ-Eddington formulations (i.e. scattered\n        // light that δ-Eddington counts as unscattered) and\n        // redistribute it according to phase function.\n        col=colMS+p*sun_col*(exp(-(1.0-w*f)*T/cosS)-exp(-T/cosS));\n#elif SINGLE_SCATTERING_HACK==1\n        // Old version.\n        // As a (not particularly physical) hack, we\n        // simply blend single- and multiple-scattering\n        // approximations based on the optical depth.\n        col=mix(colMS,colSS,0.5*exp(-0.25*T/cosS));\n#else\n        col=colMS;\n#endif\n    }\n    // Sun disc.\n    float r_sun=0.00935/2.0; // Sun angular radius.\n    if(dot(view_dir,sun_dir)>cos(r_sun)) col+=sun_col*exp(-T/cosS)/(pi*r_sun*r_sun);\n    col/=Lref;\n    // col=1.0-exp(-col); // Tonemap.\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}