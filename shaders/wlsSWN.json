{
    "Shader": {
        "info": {
            "date": "1563066359",
            "description": "using bounding spheres to reduce raymarching cost (hopefully).",
            "flags": 48,
            "hasliked": 0,
            "id": "wlsSWN",
            "likes": 3,
            "name": "bounding spheres+raymarching",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 800
        },
        "renderpass": [
            {
                "code": "\n//box intersection from iq\n//https://www.shadertoy.com/view/ld23DV\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n\tfloat tN = max(max( t1.x, t1.y ), t1.z);\n\tfloat tF = min(min( t2.x, t2.y ), t2.z);\n\n\treturn vec2(tN, tF);\n}\n\nstruct Mesh\n{\n    //bounding sphere radius\n\tfloat r;\n    //bounding sphere center\n    vec3 p;\n    //raymarching shape in the bounding sphere\n    int shape;\n};\n\nMesh meshes[] = Mesh[](\n    Mesh(1.0,vec3(0),SHAPE_TETRAHEDRON),\n    Mesh(sqrt(3.0),vec3(0,1,0),SHAPE_SPONGE),\n    Mesh(0.33,vec3(0,1,0),SHAPE_HORSE)\n);\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in float r )\n{\n    float b = dot(rd, ro);\n    float c = dot(ro, ro) - r*r;\n    float t = b*b - c;\n    if( t > 0.0)\n        return -b + sqrt(t)*vec2(-1,1);\n    else\n        return vec2(-1,-2);\n}\n\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat cone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    vec2 q = vec2(length(p.xz),p.y);\n    \n    if (dot(vec2(-c.y,c.x),q) < 0.0) {\n        return dot(c,q);\n    } else {\n        return length(q);\n    }\n}\n\n//cylinder distance from iq\n//https://iquilezles.org/articles/distfunctions\nfloat cylinder( vec3 p, vec2 s)\n{\n    vec2 q = vec2(length(p.xz),p.y);\n    return length(max(abs(q)-s,0.0));\n}\n\n//torus distance from iq\n//https://iquilezles.org/articles/distfunctions\nfloat torus( vec3 p, float s)\n{\n    vec2 q = vec2(length(p.xz),p.y);\n    return length(abs(q)-vec2(s,0));\n}\n\nfloat halftorus(vec3 p,float s)\n{\n    float len = abs(length(vec2(p.x,min(p.y,0.0)))-s);\n    return length(vec3(len,max(p.y,0.0),p.z));\n}\n\n//box distance by iq\n//https://iquilezles.org/articles/distfunctions\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat box( vec3 p, vec3 b )\n{\n    vec3 q = abs(p)-b;\n\treturn max(max(q.x,q.y),q.z);\n}\n\nfloat ellipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// special cone with a bottom\nfloat cone( vec3 p, vec2 c, float bot)\n{\n    p.x = length(p.xz); //for 3d\n    \n    float l = dot(c,p.xy);\n    \n    vec2 q = p.xy-c*l;\n    \n    if (q.x < 0.0) {\n        l = length(p.xy)*sign(p.y);\n    } else if (q.y < -bot && p.x > c.y/c.x*bot) {\n        l = length(p.xy-vec2(c.y/c.x*bot,-bot));\n    } else if (l < 0.0) {\n        l = max(l,-p.y-bot);\n    }\n    \n    return l;\n}\n\nfloat pie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,r) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat pizza(vec3 p, vec2 c, float r, float h) {\n    \n    vec2 q;\n    q.y = abs(p.y)-h;\n    q.x = pie(p.xz,c,r);\n    \n    return length(max(q,0.0));\n    \n}\n\nfloat capsule( vec3 p, vec3 a, vec3 b )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat horse(vec3 p) {\n    float len = cylinder(p-vec3(0,-0.45,0),vec2(0.2,0.05));\n    \n    vec3 q = p;\n    q.yz *= rot(pi*0.1);\n    len = min(len,udBox(q-vec3(0,-0.3,-0.15),vec3(0,0.15,0))-0.07);\n    len = min(len,halftorus(-vec3(q.z,q.y,q.x)+vec3(-0.05,-0.15,0),0.1)-0.07);\n    \n    return len;\n}\n\nfloat mid(vec3 p) {\n    p = max(p,p.yzx);\n    \n    return min(min(p.x,p.y),p.z);\n}\n\nfloat map(vec3 p, Mesh mesh) {\n    float l = FAR;\n    \n    if (mesh.shape == SHAPE_TETRAHEDRON) {\n        vec3 q = abs(p)-0.5;\n\n        l = min(l,length(q)-0.03);\n\n        float l2 =  dot(p,(vec3( 1, 1, 1)));\n        l2 = max(l2,dot(p,(vec3( 1,-1,-1))));\n        l2 = max(l2,dot(p,(vec3(-1, 1,-1))));\n        l2 = max(l2,dot(p,(vec3(-1,-1, 1))));\n        l2 -= 0.5;\n        l2 /= sqrt(3.0);\n\n\n        l = min(l,l2);\n    } else if (mesh.shape == SHAPE_SPONGE) {\n        \n        \n        vec3 q = abs(p);\n        \n        float l2 = max(max(q.x,q.y),q.z)-1.0;\n        \n        for (float s = 2.0; s > 0.1; s /= 3.0) {\n            q = abs(mod(p+s*0.5,s)-s*0.5);\n            l2 = max(l2,s/6.0-mid(q));\n        }\n        \n        l = min(l2,l);\n        \n    } else if (mesh.shape == SHAPE_HORSE) {\n        \n        \n        l = min(l,horse(p-vec3(0,0.3,0)));\n        \n    }\n    \n    return l;\n}\n\nvec3 normal(vec3 p, Mesh mesh) {\n    vec2 e = vec2(0,0.001);\n    \n    return normalize(vec3(\n        map(p+e.yxx,mesh)-map(p-e.yxx,mesh),\n        map(p+e.xyx,mesh)-map(p-e.xyx,mesh),\n        map(p+e.xxy,mesh)-map(p-e.xxy,mesh)));\n}\n\nfloat ray(vec3 ro, vec3 rd, vec2 t, Mesh mesh) {\n    \n    float d = t.x;\n    \n    for (int i = 0; i < 100; i++) {\n        float l = map(ro+rd*d-mesh.p, mesh);\n        \n        if (l < 0.001 || d > FAR) {\n            break;\n        }\n        \n        d += l;\n    }\n    if (d > t.y) return FAR;\n    return d;\n}\n\nvec4 getdata(int index) {\n    ivec2 p;\n    p.x = index%int(iResolution.x);\n    p.y = index/int(iResolution.x);\n    return texelFetch(iChannel0,p,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float debug = 0.0;\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = getdata(campos).xyz;\n    vec3 rd = normalize(vec3(uv,1));\n\n    vec4 rotcam = getdata(camrot);\n\n    rd.zy *= rot(rotcam.y);\n    rd.zx *= rot(rotcam.x);\n    \n    float d = FAR;\n    \n    meshes[1].p = vec3(0,sin(iTime)*2.0,cos(iTime)*2.0);\n    \n    int id;\n    \n    for (int i = 0; i < meshes.length(); i++) {\n        //load mesh\n        Mesh mesh = meshes[i];\n        //p is local position to the center of the sphere\n        vec3 p = ro-mesh.p;\n        //t is the beginning (t.x) and end (t.y) of the bounding sphere\n        vec2 t = iSphere(p,rd,mesh.r);\n        t = vec2(max(t.x,0.0),min(t.y,d));\n        \n        //if the end point is closer than the start point, don't raymarch\n        if (max(t.x,0.0) < min(t.y,d)) {\n            debug++;\n            float l = ray(ro,rd,t,mesh);\n            \n            //if the ray hit is the current closest, add to closest\n            if (l < d) {\n                d = l;\n                id = i;\n            }\n        }\n    }\n    \n    vec3 col = vec3(0);\n    \n    if (d < FAR) {\n        //loading the mesh\n        Mesh mesh = meshes[id];\n        vec3 p = ro+rd*d-mesh.p;\n        vec3 n = normal(p,mesh);\n        \n        float phong = dot(n,normalize(vec3(1)));\n        phong = max(phong,0.1);\n        \n        col = fract(p+0.001)*0.7+(n*0.5+0.5)*0.3;\n        col *= phong;\n    }\n    \n    col += debug*0.03;\n    \n    fragColor.rgb = pow(col,vec3(1.0/2.2));    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat getkey(int x, int y)\n{\n    return texelFetch(iChannel1,ivec2(x,y),0).x;\n}\n\nvec4 getdata(int index) {\n    ivec2 p;\n    p.x = index%int(iResolution.x);\n    p.y = index/int(iResolution.x);\n    return texelFetch(iChannel0,p,0);\n}\nvec4 updatedata(int index) {\n    vec4 data = getdata(index);\n    \n    vec4 iMouse2 = getdata(lastmouse);\n    \n    \n    bool refresh = iFrame == 0;\n    \n    if (index == lastmouse) {\n        return iMouse;\n    } else if (index == campos) {\n        \n        if (refresh) {\n            return vec4(vec3(0,2,-4),1);\n        }\n        \n        vec4 rotcam = getdata(camrot);\n        \n        vec3 move = vec3(getkey(MOVE_RIGHT,0)-getkey(MOVE_LEFT,0),\n                         getkey(MOVE_UP   ,0)-getkey(MOVE_DOWN,0),\n                         getkey(MOVE_FORW ,0)-getkey(MOVE_BACK,0));\n        \n        move.zy *= rot(rotcam.y);\n        move.zx *= rot(rotcam.x);\n        \n        vec3 newpos = data.xyz+movespeed*move*iTimeDelta;\n        \n        data.xyz = newpos;\n        \n        return data;\n    } else if (index == camrot) {\n        \n        if (refresh) {\n            return vec4(0,0,0,0);\n        }\n        \n        if (min(iMouse2.z,iMouse.z) > 0.5) {\n            data.xy += (iMouse.xy-iMouse2.xy)/iResolution.y*sensitivity;\n        }\n        \n        return data;\n    }\n    \n    \n    return data;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    fragColor = updatedata(coord.x+coord.y*int(iResolution.x));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define lastmouse 0\n#define campos 1\n#define camrot 2\n\n#define pi acos(-1.0)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define sc(a) vec2(sin(a),cos(a))\n#define sqr(a) (a*a)\n\n#define FAR 100.0\n\n#define sensitivity 3.0\n#define movespeed 2.0\n\n#define SHAPE_TETRAHEDRON 0\n#define SHAPE_SPONGE 1\n#define SHAPE_HORSE 2\n\n//keyboard keys\n#define KEY_UP    38\n#define KEY_DOWN  40\n#define KEY_RIGHT 39\n#define KEY_LEFT  37\n#define KEY_SHIFT 16\n#define KEY_CTRL  17\n\n//movement keys\n#define MOVE_FORW   KEY_UP\n#define MOVE_LEFT   KEY_LEFT\n#define MOVE_RIGHT  KEY_RIGHT\n#define MOVE_BACK   KEY_DOWN\n#define MOVE_UP     KEY_SHIFT\n#define MOVE_DOWN   KEY_CTRL",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}