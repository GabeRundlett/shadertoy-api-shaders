{
    "Shader": {
        "info": {
            "date": "1610136490",
            "description": "Happy Birthday Mr.Mau5",
            "flags": 96,
            "hasliked": 0,
            "id": "wlcyDX",
            "likes": 0,
            "name": "Deadmau5 - Bridged by a Lightwav",
            "published": 3,
            "tags": [
                "deadmau5"
            ],
            "usePreview": 0,
            "username": "MacroMachines",
            "viewed": 266
        },
        "renderpass": [
            {
                "code": "#define DISPLAY_GAMMA 1.98\n#define USE_CHROMATIC_ABBERATION\n#define USE_GLOW\n\nvec2 uvsToUv(vec2 uvs){\n    return (uvs)*vec2(iResolution.y/iResolution.x,1.0)+vec2(.5,.5);\n}\n\nconst float blurSize = 1.0/512.0*0.75;\nconst float intensity = 0.25;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvs = (fragCoord.xy-iResolution.xy*.5)/iResolution.yy;\n    \n   //BLOOM\n   vec4 sum = vec4(0);\n   vec2 texcoord = fragCoord.xy/iResolution.xy;\n   int j;\n   int i;\n\n   //thank you! http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/ for the \n   //blur tutorial\n   // blur in y (vertical)\n   // take nine samples, with the distance blurSize between them\n   sum += texture(iChannel0, vec2(texcoord.x - 4.0*blurSize, texcoord.y)) * 0.05;\n   sum += texture(iChannel0, vec2(texcoord.x - 3.0*blurSize, texcoord.y)) * 0.09;\n   sum += texture(iChannel0, vec2(texcoord.x - 2.0*blurSize, texcoord.y)) * 0.12;\n   sum += texture(iChannel0, vec2(texcoord.x - blurSize, texcoord.y)) * 0.15;\n   sum += texture(iChannel0, vec2(texcoord.x, texcoord.y)) * 0.16;\n   sum += texture(iChannel0, vec2(texcoord.x + blurSize, texcoord.y)) * 0.15;\n   sum += texture(iChannel0, vec2(texcoord.x + 2.0*blurSize, texcoord.y)) * 0.12;\n   sum += texture(iChannel0, vec2(texcoord.x + 3.0*blurSize, texcoord.y)) * 0.09;\n   sum += texture(iChannel0, vec2(texcoord.x + 4.0*blurSize, texcoord.y)) * 0.05;\n\t\n\t// blur in y (vertical)\n   // take nine samples, with the distance blurSize between them\n   sum += texture(iChannel0, vec2(texcoord.x, texcoord.y - 4.0*blurSize)) * 0.05;\n   sum += texture(iChannel0, vec2(texcoord.x, texcoord.y - 3.0*blurSize)) * 0.09;\n   sum += texture(iChannel0, vec2(texcoord.x, texcoord.y - 2.0*blurSize)) * 0.12;\n   sum += texture(iChannel0, vec2(texcoord.x, texcoord.y - blurSize)) * 0.15;\n   sum += texture(iChannel0, vec2(texcoord.x, texcoord.y)) * 0.16;\n   sum += texture(iChannel0, vec2(texcoord.x, texcoord.y + blurSize)) * 0.15;\n   sum += texture(iChannel0, vec2(texcoord.x, texcoord.y + 2.0*blurSize)) * 0.12;\n   sum += texture(iChannel0, vec2(texcoord.x, texcoord.y + 3.0*blurSize)) * 0.09;\n   sum += texture(iChannel0, vec2(texcoord.x, texcoord.y + 4.0*blurSize)) * 0.05;\n    \n    \n    //chromatic abberation\n    #ifdef USE_CHROMATIC_ABBERATION\n    vec3 color = vec3(0,0,0);\n    color.x   += texture(iChannel0, uvsToUv(uvs)).x*.66;\n    color.xy  += texture(iChannel0, uvsToUv(uvs*.995)).xy*.33;\n    color.y   += texture(iChannel0, uvsToUv(uvs*.9920)).y*.33;\n    color.yz  += texture(iChannel0, uvsToUv(uvs*.9985)).yz*.33;\n    color.z   += texture(iChannel0, uvsToUv(uvs*.99890)).z*.66;\n    #else\n    vec3 color = texture(iChannel0, uvsToUv(uvs)).xyz;\n    #endif\n    \n    \n   // #ifdef USE_GLOW\n   // vec3 glow = texture\n    \n    //tone mapping\n    //color = vec3(1.7,1.8,1.9)*color/(1.0+color);\n    \n\n    \n    //scanlines\n    color /= cos(uv.y*1000.)+1.50*1.5;\n   \n    \n        color += sum.rgb*intensity;\n        \n    //vinette\n    color *= smoothstep(0.20,0.65,vec3(1.0-distance(uv, vec2(0.5))))*1.75;\n    \n    //inverse gamma correction\n\tfragColor = vec4(color,1.0);//\n    //fragColor = vec4(pow(color,vec3((1.0)/(DISPLAY_GAMMA))),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define time mod(iTime,562.5)\n#define iTime mod(iTime,562.5)\n#define v3 vec3\n\n\n#define PRECISION 0.0001 \n//0.000001\n#define DEPTH 50.0\n#define STEPS 124\n#define PI 3.1415926535897932384626433832795\n#define OCCLUSION_SAMPLES 8.0\n#define OCCLUSION_FACTOR 1.0\n\nvec3 eye   = vec3(0.0,0.0,-1.0);\nvec3 light = vec3(-2.0,0.0,-2.0);\n\n\n\n\n//#define LIGHT_COLOR vec3(0.063,0.141,0.416)+KICK*0.2\n//#define LIGHT_AMBIENT vec3(0.710,0.071,0.082) //\n//#define LIGHT_AMBIENT vec3(0.478,0.000,0.000) //\n//#define LIGHT_COLOR vec3(0.396,0.184,0.184)*KICK2 //+KICK*0.2\n#define LIGHT_AMBIENT vec3(0.302,0.000,0.000) //\n#define LIGHT_COLOR vec3(0.478,0.478,0.478) //*KICK2\n\nmat3 rotmat;\nmat3 rotmatHead;\n\nbool hit = false;\nstruct sMaterial\n{\n    float metallic;\n    float roughness;\n    float fresnel_pow;\n    vec3 color;\n};\n\n\n//sMaterial mat_red = sMaterial(0.0, 1.0, 1.0, vec3(1.0, 0.0, 0.0));\n//sMaterial mat_white = sMaterial(0.0, 5.0, 1.0, vec3(1.0));\n//sMaterial mat_black = sMaterial(0.0,  10.0,  0.050, vec3(0.0));\n//sMaterial mat_red   = sMaterial(0.00, 10.00, 4.50, vec3(0.475,0.004,0.004));\n\nsMaterial mat_white = sMaterial(0.8750,  50.0,   0.510,    vec3(10.0));\nsMaterial mat_black = sMaterial(0.10,      4.0,    4.50,    vec3(0.0));\nsMaterial mat_red   = sMaterial(0.925,     10.00,  0.1250,    vec3(1.000,0.000,0.000));\n\n\n\n\n\n\n// KOREOGRAPHY\n// NOTES\n//\n// --142.5 sec beat kicks in\n// --232 clap and end beat\n// 297 oceans of blank space - fade out music for moment\n// 300 back in synth\n// 305 synth note back out\n// --321 swell back into snare / beat\n// 472 off\n// 562.5 end fade out, modulo time\n\n#define BPM 128.0\n#define SEC_PER_MIN 60.0\n\n#define TEMPO iTime * BPM / SEC_PER_MIN / 4.0 + 1.0\n//#define KICKb pow(fract(TEMPO)*2.0, 2.0)\n//#define KICK2 mix(0.0 , 1.0-pow(fract(iTime*BPM/SEC_PER_MIN), 0.50)), BEATON)\n//#define KICK2b 1.0-pow(fract(iTime*BPM/SEC_PER_MIN), 0.50)* BEATON\n\n//#define TEMPO_SNARE iTime * BPM / SEC_PER_MIN / 2.0 + 1.0\n//#define SNARE pow(fract(TEMPO_SNARE)*0.50, 0.50)\n//#define SINE sin(PI*fract(iTime*BPM/SEC_PER_MIN))\n\nbool BEAT = false;\n\nfloat TEMPOTIME = 0.0;\nfloat BEATON    = 0.0;\nfloat MEASURE   = 0.0;\nfloat MEASURE2  = 0.0;\nfloat FADEIN    = 0.0;\nfloat SYNTHJUMP = 0.0;\nfloat KICK      = 0.0;\nfloat KICK2     = 0.0;\nfloat TRIPLET   = 0.0;\nfloat SNARE     = 0.0;\nfloat SINE      = 0.0;\nvec3 audioTex   = vec3(0.0);\n//vec2 view = vec2(0.0);\n\nvoid coreography (vec3 view){\n    TEMPOTIME = BPM / SEC_PER_MIN;\n    BEAT      = (iTime > 142.5 && iTime < 232.0) || (iTime > 321.0 && iTime < 472.0) ;\n    BEATON    = float(BEAT);\n    MEASURE   = iTime * TEMPOTIME;\n    MEASURE2  = 1.0-fract(MEASURE/16.0);\n    FADEIN    = smoothstep(0.,6.,iTime);\n    SYNTHJUMP = step(MEASURE2, 0.5)*BEATON * float(iTime < 413.0);\n    KICK      = pow(fract(MEASURE/4.0)*2.0, 2.0);\n    TRIPLET   = mix(0.0, 1.0 - pow(fract(iTime*BPM/SEC_PER_MIN/0.666666666666), 0.250), SYNTHJUMP);\n    KICK2     = mix(1.0, 1.0 - pow(fract(iTime*BPM/SEC_PER_MIN), 0.50), BEATON);\n    SNARE     = pow(fract(MEASURE/2.0 + 1.0)*0.50, 0.50);\n    SINE      = sin(PI*fract(iTime*BPM/SEC_PER_MIN));\n    //audioTex  = pow( texture( iChannel1, cos(view.xy * (SNARE * 0.50 - KICK * 0.5 - KICK2 * 1.0) )*0.50 ).xyz, vec3(4.0) )*1.0;\n    audioTex  = pow( texture( iChannel1, cos(view.xy * (SNARE * 0.50 - KICK * 0.5 - KICK2 * 1.0) )*0.50 ).xyz, vec3(8.0) )*3.0;\n    //audioTex    = pow( texture( iChannel1, cos(view.xy * (SNARE * 0.50 - KICK * 0.5 - KICK2 * 1.0) )*0.950 ).xyz, vec3(4.0) )*3.0;\n    mat_white.color = mix(vec3(0.0),mat_white.color*KICK2+0.1250,BEATON-TRIPLET);;\n}\n\n\n\n\nstruct sHit\n{\n    float d;\n    sMaterial material;\n};\nsHit map(vec3);\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e=vec2(PRECISION,0);\n    return(normalize(vec3(map(p+e.xyy).d-map(p-e.xyy).d\n                          ,map(p+e.yxy).d-map(p-e.yxy).d\n                          ,map(p+e.yyx).d-map(p-e.yyx).d)));}\n\n// ROTATION FUNCTIONS TAKEN FROM\n//https://www.shadertoy.com/view/XsSSzG\nmat3 xrotate(float t) {\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrotate(float t) {\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrotate(float t) {\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\n\nmat3 rotate( vec3 r ){\n \n   return xrotate( r.x ) * yrotate( r.y ) * zrotate( r.z );\n    \n}\n\nvec3 opCheapBend( vec3 p , float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n\n}\nvec2 hash( vec2 p ) \n{                       // rand in [-1,1]\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)) );\n    return -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define TAU (2.*PI)\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0., 1.)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {   return (x<0.)?-1.:1.;}\nvec2 sgn(vec2 v) {   return vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);}\nfloat square (float x) {   return x*x;}\nvec2 square (vec2 x) {   return x*x;}\nvec3 square (vec3 x) {   return x*x;}\nfloat lengthSqr(vec3 x) {   return dot(x, x);}\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {   return max(v.x, v.y);}\nfloat vmax(vec3 v) {   return max(max(v.x, v.y), v.z);}\nfloat vmax(vec4 v) {   return max(max(v.x, v.y), max(v.z, v.w));}\nfloat vmin(vec2 v) {   return min(v.x, v.y);}\nfloat vmin(vec3 v) {   return min(min(v.x, v.y), v.z);}\nfloat vmin(vec4 v) {   return min(min(v.x, v.y), min(v.z, v.w));}\n\n\n//......................................... transform \n/////////////////////////////////////////////////////\nmat2 rotate( float a ) {\n   float cs = cos(a);\n   float si = sin(a);\n   return mat2(cs, -si, si, cs);\n}\nmat3 calcLookAtMatrix( vec3 camPos , vec3 camTar , float roll ){\n\n  vec3 up = vec3( sin( roll ) ,cos( roll ) , 0. );\n  vec3 ww = normalize( camTar - camPos );\n  vec3 uu = normalize( cross( ww , up ) );\n  vec3 vv = cross( uu , ww ); // already normalized\n\n  return mat3( uu , vv , ww );\n\n}\n\n\n\n\n// ███████╗ ██████╗ ██████╗ ███╗   ███╗                           \n// ██╔════╝██╔═══██╗██╔══██╗████╗ ████║                           \n// █████╗  ██║   ██║██████╔╝██╔████╔██║                           \n// ██╔══╝  ██║   ██║██╔══██╗██║╚██╔╝██║                           \n// ██║     ╚██████╔╝██║  ██║██║ ╚═╝ ██║                           \n// ╚═╝      ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝ \n\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n\t// c must be normalized\n\tfloat q = length(p.xy);\n\treturn dot(c,vec2(q,p.z));\n}\n\nfloat sdTorus(vec3 p, vec2 t) \n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\t\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n   return length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n   return dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n   return vmax(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n   vec3 d = abs(p) - b;\n   return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n   return vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n   vec2 d = abs(p) - b;\n   return length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\n// Endless \"corner\"\nfloat fCorner (vec2 p) {\n   return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n// Blobby ball object. You've probably seen it somewhere. This is not a correct distance bound, beware.\nfloat fBlob(vec3 p) {\n   p = abs(p);\n   if (p.x < max(p.y, p.z)) p = p.yzx;\n   if (p.x < max(p.y, p.z)) p = p.yzx;\n   float b = max(max(max(\n      dot(p, normalize(vec3(1., 1., 1.))),\n      dot(p.xz, normalize(vec2(PHI+1., 1.)))),\n      dot(p.yx, normalize(vec2(1., PHI)))),\n      dot(p.xz, normalize(vec2(1., PHI))));\n   float l = length(p);\n   return l - 1.5 - 0.2 * (1.5 / 2.)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n   float d = length(p.xz) - r;\n   d = max(d, abs(p.y) - height);\n   return d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n   return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n   vec3 ab = b - a;\n   float t = saturate(dot(p - a, ab) / dot(ab, ab));\n   return length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n   return fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n   return length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n   float l = length(p.xz) - r;\n   return length(vec2(p.y, l));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n   float l = length(p.xz) - r;\n   return l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n   vec3 q = abs(p);\n   return max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n   //this is mathematically equivalent to this line, but less efficient:\n   //return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Hexagonal prism, incircle variant\nfloat fHexagonIncircle(vec3 p, vec2 h) {\n   return fHexagonCircumcircle(p, vec2(h.x*sqrt(3.)*0.5, h.y));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n   vec2 q = vec2(length(p.xz), p.y);\n   vec2 tip = q - vec2(0, height);\n   vec2 mantleDir = normalize(vec2(height, radius));\n   float mantle = dot(tip, mantleDir);\n   float d = max(mantle, -q.y);\n   float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n   \n   // distance to tip\n   if ((q.y > height) && (projected < 0.)) {\n      d = max(d, length(tip));\n   }\n   \n   // distance to base ring\n   if ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n      d = max(d, length(q - vec2(radius, 0.)));\n   }\n   return d;\n}\n\n//......................................... 3d forms \n////////////////////////////////////////////////////\nfloat sphere (vec3 p, float s){\n   return length(p) - s;\n}\nfloat box(vec3 p, vec3 b){\n   return length(max(abs(p)-b, 0.0));\n}\nfloat rbox(vec3 p, vec3 b, float r){\n   return length(max(abs(p)-b,0.0))-r;\n}\n\n\n//........................................... deform \n////////////////////////////////////////////////////\nfloat displace(vec3 p){\n   float d1 = rbox(p, vec3(0.25), 0.20);\n   //float d2 = sphere(p, 0.5);\n   float sz = 8.0;\n   float d2 = sin(sz*p.x)*sin(sz*p.y)*sin(sz*p.z);\n   return d1+d2;\n}\n//............................................ domain \n/////////////////////////////////////////////////////\nfloat rep( vec3 p, vec3 c){\n   vec3 q = mod(p, c) -0.5*c;\n   q.xy *= rotate(time);\n   vec3 c2 = c*3.0*cos(time*0.33);\n   vec3 q2 = mod(p, c2) -0.5*c2;\n   vec3 q3 = mod(p, c*0.25) - 0.125*c;\n   //return displace(p);//\n   float size = 1.0;\n   float rp = min(box(q2, vec3(cos(time+q3.z)*2.0, cos(p.z+time*0.5)*0.5, 1.0)),\n         rbox(q, fract(p.y+time*.1)*v3(size*0.125,0.05,0.1), 0.05));\n   rp = min(rp, sphere(q3, sin(p.x+time)*0.05));\n   return rp;\n}\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that modifies the domain is named pSomething.\n//\n// Many operate only on a subset of the three dimensions. For those,\n// you must choose the dimensions that you want manipulated\n// by supplying e.g. <p.x> or <p.zx>\n//\n// <inout p> is always the first argument and modified in place.\n//\n// Many of the operators partition space into cells. An identifier\n// or cell index is returned, if possible. This return value is\n// intended to be optionally used e.g. as a random seed to change\n// parameters of the distance functions inside the cells.\n//\n// Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n// are centered on the origin so objects don't have to be moved to fit.\n//\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n   p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n   p = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n   float halfsize = size*0.5;\n   float c = floor((p + halfsize)/size);\n   p = mod(p + halfsize, size) - halfsize;\n   return c;\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size) {\n   float halfsize = size*0.5;\n   float c = floor((p + halfsize)/size);\n   p = mod(p + halfsize,size) - halfsize;\n   p *= mod(c, 2.0)*2. - 1.;\n   return c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n   float halfsize = size*0.5;\n   float c = floor((p + halfsize)/size);\n   if (p >= 0.)\n      p = mod(p + halfsize, size) - halfsize;\n   return c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n   float halfsize = size*0.5;\n   float c = floor((p + halfsize)/size);\n   p = mod(p+halfsize, size) - halfsize;\n   if (c > stop) { //yes, this might not be the best thing numerically.\n      p += size*(c - stop);\n      c = stop;\n   }\n   if (c <start) {\n      p += size*(c - start);\n      c = start;\n   }\n   return c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n   float angle = 2.*PI/repetitions;\n   float a = atan(p.y, p.x) + angle/2.;\n   float r = length(p);\n   float c = floor(a/angle);\n   a = mod(a,angle) - angle/2.;\n   p = vec2(cos(a), sin(a))*r;\n   // For an odd number of repetitions, fix cell index of the cell in -x direction\n   // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n   if (abs(c) >= (repetitions/2.)) c = abs(c);\n   return c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n   vec2 c = floor((p + size*0.5)/size);\n   p = mod(p + size*0.5,size) - size*0.5;\n   return c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n   vec2 halfsize = size*0.5;\n   vec2 c = floor((p + halfsize)/size);\n   p = mod(p + halfsize, size) - halfsize;\n   p *= mod(c,vec2(2.))*2. - vec2(1.);\n   return c;\n}\n\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n   vec2 c = floor((p + size*0.5)/size);\n   p = mod(p + size*0.5, size) - size*0.5;\n   p *= mod(c,vec2(2))*2. - vec2(1.);\n   p -= size/2.;\n   if (p.x > p.y) p.xy = p.yx;\n   return floor(c/2.);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n   vec3 c = floor((p + size*0.5)/size);\n   p = mod(p + size*0.5, size) - size*0.5;\n   return c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n   float s = sgn(p);\n   p = abs(p)-dist;\n   return s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n   vec2 s = sgn(p);\n   pMirror(p.x, dist.x);\n   pMirror(p.y, dist.y);\n   if (p.y > p.x)\n      p.xy = p.yx;\n   return s;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n   float t = dot(p, planeNormal)+offset;\n   if (t < 0.) {\n      p = p - (2.*t)*planeNormal;\n   }\n   return sgn(t);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n   return min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n   return max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n   return fOpIntersectionChamfer(a, -b, r);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n   vec2 u = max(vec2(r - a,r - b), vec2(0.));\n   return max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n   vec2 u = max(vec2(r + a,r + b), vec2(0.));\n   return min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n   return fOpIntersectionRound(a, -b, r);\n}\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n   if ((a < r) && (b < r)) {\n      vec2 p = vec2(a, b);\n      float columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n      pR45(p);\n      p.x -= sqrt(2.)/2.*r;\n      p.x += columnradius*sqrt(2.);\n      if (mod(n,2.) == 1.) {\n         p.y += columnradius;\n      }\n      // At this point, we have turned 45 degrees and moved at a point on the\n      // diagonal that we want to place the columns on.\n      // Now, repeat the domain along this direction and place a circle.\n      pMod1(p.y, columnradius*2.);\n      float result = length(p) - columnradius;\n      result = min(result, p.x);\n      result = min(result, a);\n      return min(result, b);\n   } else {\n      return min(a, b);\n   }\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n   a = -a;\n   float m = min(a, b);\n   //avoid the expensive computation where not needed (produces discontinuity though)\n   if ((a < r) && (b < r)) {\n      vec2 p = vec2(a, b);\n      float columnradius = r*sqrt(2.)/n/2.0;\n      columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\n      pR45(p);\n      p.y += columnradius;\n      p.x -= sqrt(2.)/2.*r;\n      p.x += -columnradius*sqrt(2.)/2.;\n\n      if (mod(n,2.) == 1.) {\n         p.y += columnradius;\n      }\n      pMod1(p.y,columnradius*2.);\n\n      float result = -length(p) + columnradius;\n      result = max(result, p.x);\n      result = min(result, a);\n      return -min(result, b);\n   } else {\n      return -m;\n   }\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n   return fOpDifferenceColumns(a,-b,r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n   float s = r/n;\n   float u = b-r;\n   return min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n   return -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n   return -fOpUnionStairs(-a, b, r, n);\n}\n\n\n// Similar to fOpUnionRound, but more lipschitz-y at acute angles\n// (and less so at 90 degrees). Useful when fudging around too much\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n   float e = max(r - abs(a - b), 0.);\n   return min(a, b) - e*e*0.25/r;\n}\n\n\n// produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n   return length(vec2(a, b)) - r;\n}\n\n// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a, float b, float r) {\n   return max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n   return max(a, min(a + ra, rb - abs(b)));\n}\n\n// first object gets a capenter-style tongue attached\nfloat fOpTongue(float a, float b, float ra, float rb) {\n   return min(a, max(a - ra, abs(b) - rb));\n}\n\n\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n\n\nsHit eyeMau5 ( in vec3 p )\n{\n    sHit hit;\n    return hit;\n}\n\nsHit mau5head( in vec3 q )\n{\n    q += vec3(0.,0.5,0.);\n   // q = mix(q, q*yrotate(sin(iTime)),FADEIN);\n    q*=yrotate(sin(iTime));\n    \n    float XROT = KICK2*0.75-0.5; //cos(TEMPO);\n    q *= zrotate(-XROT-0.3);\n        \n    vec3 eyeOffset = vec3(0.0);//-0.01,-0.01,-0.051);\n    vec3 eyePosL = vec3(0.48,-0.4,0.43)+eyeOffset;\n    vec3 eyePosR = eyePosL * vec3(1.0,1.0,-1.0);//vec3(0.5,-0.5,-0.5);\n    vec3 mouthPos =  vec3(-0.7, -0.25, 0.);\n//  float mouth = sdTriPrism(zrotate(PI)* q + vec3(-0.866025, -0.5, 0.0), vec2(1.0, 1.5)); //TODO: should be wedge with 50deg edge?       \n//  float mouth = sdTriPrism(zrotate(PI+0.01725) * q + mouthPos, vec2(1.0, 1.5)); \n    float mouth = sdTriPrism(zrotate(PI+0.0725) * q + mouthPos, vec2(0.70, 1.05)); \n    \n    float eyes  = opU(sdSphere(q+eyePosL, 4.5/14.0),sdSphere(q+eyePosR, 4.5/14.0));\n    float eyeXthickness = 0.015;\n    float eyeXs = udBox(xrotate(PI*0.25)*yrotate(PI*-0.01)*q + vec3(0.5,0.0,0.80125), vec3(0.5, 0.5, eyeXthickness));\n          eyeXs = opU(eyeXs, udBox(xrotate(PI*0.75)*zrotate(PI*0.02)*q + vec3(0.5,0.750,-0.0125), vec3(0.5, 0.5, eyeXthickness)));\n          eyeXs = opU(eyeXs, udBox(xrotate(PI*0.25)*zrotate(PI*0.02)*q + vec3(0.5,-0.750,-0.0125), vec3(0.5, 0.5, eyeXthickness)));\n          eyeXs = opU(eyeXs, udBox(xrotate(PI*0.75)*zrotate(PI*0.02)*q + vec3(0.5,0.0,0.80125), vec3(0.5, 0.5, eyeXthickness)));\n         // eyeXs = opU(eyeXs, udBox(xrotate(PI*0.75)*q + vec3(0.5,0.750,-0.125), vec3(0.5, 0.5, 0.0251)));\n         // eyeXs = opU(eyeXs, udBox(xrotate(PI*0.25)*q + vec3(0.5,-0.750,-0.125), vec3(0.5, 0.5, 0.0251)));\n         // eyeXs = opU(eyeXs, udBox(xrotate(PI*0.75)*q + vec3(0.5,0.0,0.85), vec3(0.5, 0.5, 0.0251)));\n\n          eyeXs = opI(eyeXs, eyes);\n          \n          \n    float head  = opS(eyes, opS(mouth, sdSphere(q, 1.0)));\n    float teeth = opI(mouth, sdSphere(q, 0.9));\n    \n    \n    //this causes a strange artifact in soft shadows on my laptop but not my PC?\n    //not sure how to fix it but I like the curved ears too much to remove it\n    \n    vec3 ear_p = opCheapBend(q, 0.15); \n    float ear_angle = 49.0 * PI/180.0;\n    vec2  ear_size = vec2(0.89,0.071);\n    float ears_center = opU(sdCappedCylinder(zrotate(ear_angle)*ear_p+vec3(-1.1, 0.0, -1.1), ear_size)\n                     ,sdCappedCylinder(zrotate(ear_angle)*ear_p+vec3(-1.1, 0.0, 1.1), ear_size));\n    float ears_edge = opU(sdTorus(zrotate(ear_angle)*ear_p+vec3(-1.1, 0.0, -1.1), ear_size)\n                     ,sdTorus(zrotate(ear_angle)*ear_p+vec3(-1.1, 0.0, 1.1), ear_size));\n    float ears = opS(head, opU(ears_center,ears_edge));\n    \n    float walls = opU(sdPlane(q + vec3(0.0, 0.0, 4.0), normalize(vec4(0.0, 0.0, 1.0, 1.0)))\n                      ,sdPlane(q + vec3(0.0, 4.0, 0.0), normalize(vec4(0.0, 1.0, 0.0, 1.0)))) + 0.001;\n                      \n    float mainHead = smin(head,ears,0.09521);\n    \n    float result = 0.250;//1e10;\n    result = opU(result, mainHead);\n    result = opU(result, teeth);\n    result = opU(result, eyes);\n    //result = opU(result, ears);\n    //result = opU(result, walls);\n    \n    sHit hit;\n    hit.d = result;\n    if(result == mainHead)// || result == ears)\n        hit.material = mat_red;\n    else if ((result == eyeXs || result == teeth))//&& SYNTHJUMP==1.0)\n        hit.material = mat_black;\n    else\n        hit.material = mat_white;\n        \n    return hit;\n}\n\nsHit map( in vec3 p )\n{    \n    vec3 ppp = p;\n    float sizer = 2.0;\n    \n    /// PLAY WITH KICK ADD / MULT / SNARE \n    vec3 c = vec3(sizer)*KICK*0.5+8.0;//-SNARE;     ///2.0;//*(TEMPO);\n    //c = vec3(sizer)+8.0;\n    \n    \n    //p *= 1.0/c;//*0.5;  //////////// crazy warp\n    //p /= c*0.125; //////////// crazy warp\n    //p *= c/sizer; //////////// crazy warp\n    \n    \n    vec3 qA = (mod(p,c)-0.5*c);//min((mod(p,c)-0.5*c), KICK2*2.0);//*rotmat;\n    vec3 qB = p;//*rotmat;\n    vec3 q  = qA;\n    //q.x = p.x-4.5 <= sin(MEASURE*PI*2.)*0.9 ? p.x:q.x;//vec3(0.0);\n//    q.x = p.x-16.5 <= sin(MEASURE*PI*2.)*0.9 ? p.x:q.x;//vec3(0.0);\n    //q.x = p.x-.5 <= 4.0 ? p.x*2.0:q.x;//vec3(0.0);\n    //q = q+p*rotmat;\n    //q = mix(qA, qB, min(KICK*0.50, SNARE));\n    //q = mix(q, qB, SNARE-1.0);\n    \n//    float XROT = KICK2*0.75-0.5; //cos(TEMPO);\n//        p *= zrotate(-XROT);\n//    float YROT = 10.0;//0.0+sin(TEMPO*0.25)+1.0*0.5;\n    \n    //rotmatHead = xrotate(XROT*2.0*PI) * yrotate(YROT*2.0*PI + PI / 2.0); \n    //q *= rotmatHead;\n    \n    //rotmatHead = xrotate(XROT*2.0*PI) * yrotate(YROT*2.0*PI); \n //   p *= zrotate(-XROT);\n    \n    //some animation\n    //q = q / vec3(pow(1.0 + 0.125*SINE,0.250));\n    q = q / vec3(KICK2+1.0);\n    //q = q+KICK*vec3(-10.0, 0.0, 0.5);\n        \n\n    //float sizemult = 1.0;\n\n    vec3 pp = q;//\n    //pModPolar(pp.xz, 2.0);\n    sHit mau5 = mau5head(pp);//*sizemult);\n    sHit mau5big = mau5head(ppp);\n    //if(mau5.d>=0.0) mau5.d = mau5head(ppp).d; //mau5.material = mat_white;\n    return mau5;\n}\n\n\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n// ██████╗ ███████╗███╗   ██╗██████╗ ███████╗██████╗              \n// ██╔══██╗██╔════╝████╗  ██║██╔══██╗██╔════╝██╔══██╗             \n// ██████╔╝█████╗  ██╔██╗ ██║██║  ██║█████╗  ██████╔╝             \n// ██╔══██╗██╔══╝  ██║╚██╗██║██║  ██║██╔══╝  ██╔══██╗             \n// ██║  ██║███████╗██║ ╚████║██████╔╝███████╗██║  ██║             \n// ╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝╚═════╝ ╚══════╝╚═╝  ╚═╝   \n\n\n\n\n\n\nvec3 march( in vec3 ro, in vec3 rd)\n{\n    float t=0.0,d;\n    \n    for(int i=0;i<STEPS;i++)\n    {\n        d=map(ro+rd*t).d;\n        if(abs(d)<PRECISION){hit=true;}\n        if(hit==true||t>DEPTH){break;}\n        t+=d;\n    }\n    \n    return ro+rd*t;\n}\n\nfloat shadow_march( in vec3 ro, in vec3 rd)\n{\n    float t=0.01,d;\n    \n    for(int i=0;i<STEPS;i++)\n    {\n        d = map(ro + rd*t).d;\n        if( d < 0.0001 )\n            return 0.0;\n        t += d;\n    }\n    return 1.0;\n}\n\nfloat soft_shadow_march( in vec3 ro, in vec3 rd, float k)\n{\n    float res = 1.0;\n    float t=0.01;//.0001*sin(PI*fract(iTime));\n    float d;\n    \n    for(int i=0;i<STEPS;i++)\n    {\n        d = map(ro + rd*t).d;\n        if( d < PRECISION )\n            return 0.0;\n        res = min( res, k*d/t );\n        t += d;\n    }\n    return res;\n}\n\n/*  taken from Hamneggs https://www.shadertoy.com/view/4dj3Dw\n\tCalculates the ambient occlusion factor at a given point in space.\n\tUses IQ's marched normal distance comparison technique.\n*/\nfloat calcOcclusion(vec3 pos, vec3 surfaceNormal)\n{\n\tfloat result = 0.0;\n\tvec3 normalPos = vec3(pos);\n\tfor(float i = 0.0; i < OCCLUSION_SAMPLES; i+=1.0)\n\t{\n\t\tnormalPos += surfaceNormal * (1.0/OCCLUSION_SAMPLES);\n\t\tresult += (1.0/exp2(i)) * (i/OCCLUSION_SAMPLES)-map(normalPos).d;\n\t}\n\treturn 1.0-(OCCLUSION_FACTOR*result);\n}\n\n//some code borrowed from https://www.shadertoy.com/view/XsfXWX#\nfloat phong(vec3 l, vec3 e, vec3 n, float power) {\n    float nrm = (power + 8.0) / (PI * 8.0);\n    return pow(max(dot(l,reflect(e,n)),0.0), power) * nrm;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec3 getColor(vec3 p)\n{\t\n    sHit hit_obj = map(p);\n    sMaterial material = hit_obj.material;\n    \n\tvec3 n = getNormal(p);\n\tvec3 l = normalize(light-p);\n    \n\tvec3 light_color = vec3(0);\n    vec3 cubemap = texture(iChannel2,-n).xyz;   \n    vec3 reflection = vec3(0.0);//cubemap;\n    \n    //float shadow = shadow_march(p, l);\n    //float shadow = soft_shadow_march(p, l, 50.0);\n    \n    \n    // Diffuse lighting\n    //light_color += LIGHT_COLOR * vec3(shadow) * max(dot(n, l), 0.0);\n    light_color += LIGHT_COLOR * max(dot(n, l), 0.0);\n    \n    \n\tfloat occlusion = calcOcclusion(p, n);\n    light_color += LIGHT_AMBIENT * occlusion;\n    \n    vec3 diffuse = light_color * max(dot(n, l), 0.0);\n    \n    \n    // fresnel\n    float fresnel = max(1.0 - dot(n,p), 0.0050);\n    fresnel = pow(fresnel , material.fresnel_pow);    \n\n\n    // specular\n    float power = 1.0 / max(material.roughness * 0.4,0.01);\n    vec3 spec = light_color * phong(-l,p,n,power);\n    reflection -= spec;\n    reflection *= max(1.0-fresnel,0.51);\n\n\n    // diffuse\n    vec3 diff = diffuse;\n    //diff = mix(diff * material.color, reflection*cubemap, fresnel);        \n\n\n    vec3 color = mix( diff, reflection * cubemap * material.color , material.metallic) + spec;\n    //vec3 color = mix( diff, reflection * material.color , material.metallic) + spec;\n    color = vec3( (occlusion*0.15 * material.color)  + ((1.0-fresnel) * material.metallic))+spec*0.251+diff*0.125;\n    //return diffuse * material.color + spec;;\n    //return cubemap*material.color;//\n    //return vec3(occlusion*0.15)*diff+spec+fresnel*0.1;//color;\n    return mix(color,vec3(10.0),TRIPLET);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// ███╗   ███╗ █████╗ ██╗███╗   ██╗\n// ████╗ ████║██╔══██╗██║████╗  ██║\n// ██╔████╔██║███████║██║██╔██╗ ██║\n// ██║╚██╔╝██║██╔══██║██║██║╚██╗██║\n// ██║ ╚═╝ ██║██║  ██║██║██║ ╚████║\n// ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝\n\n//uncomment below to enable mouse moving\n//#define MOUSE_MOVE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    \n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    \n    \n#ifdef MOUSE_MOVE\n    vec2 mouse = iMouse.xy/ iResolution.xy;\t\n    mouse -= 0.5;\n#else\n    vec2 mouse = vec2(0.0);\n#endif\n\n\n    //vec2 moveMult   = vec2(1.50);\n    //vec2 moveOffset = vec2(0.0,1.50);\n    vec2 moveMult   = vec2(1.5);\n    vec2 moveOffset = vec2(0.0,1.);\n    \n\tfloat tb = iTime * BPM / SEC_PER_MIN / 8.0;// + 1.0; //+1.0 to start at 2nd rotation cuz i like it best\n    float percent = fract(tb);\n    vec2 current = 2.0 * texture(iChannel0, vec2(floor(tb)       / 64.0, floor(tb)     / 32.0)).rg - 1.0;\n    vec2 next    = 2.0 * texture(iChannel0, vec2(floor(tb + 1.0) / 64.0, floor(tb+1.0) / 32.0)).rg - 1.0;\n    vec2 final   = mix(current, next, smoothstep(0.0, 0.1, percent)) * moveMult + moveOffset;\n    \n    rotmat = xrotate(final.x)*yrotate(final.y + PI / 2.0);\n    \n   // rotmat *= xrotate((mouse.y-final.x/2.0)*2.0*PI) * yrotate((mouse.x - final.y/2.0)*2.0*PI + PI / 2.0); \n   // rotmat *= xrotate((mouse.y/4.0)*2.0*PI) * yrotate((mouse.x/4.0)*2.0*PI + PI / 2.0); \n    rotmat *= yrotate(1.750-sin(tb/2.0)*0.5);\n   \n   ////////// \n    //rotmat *= yrotate(sin(tb/8.0))-0.50; // crazy stretch FX //////\n    \n    \n\n    \n    \n    float timeFlys = 0.0;\n    \n    //vec3 view = normalize(vec3( p, 0.750 ));\n    //vec3 eye = vec3( -1.150, 1.050, -5.0-iTime*timeFlys );\n    \n    vec3 view = normalize(vec3( p, 1.30 ));   \n    vec3 eye = vec3( 0., 0.,-4.0 );\n    \n    light = eye + (40.,40.,-4.0);\n    //light = vec3(-2.5,1.5,0.);\n    \n    view *= rotmat; eye *= rotmat; //light *= rotmat;\n    \n    \n    \n    coreography(view);\n    timeFlys = mix(0.0,0.52,SYNTHJUMP);\n    //eye.z = mix(eye.z,iTime,SYNTHJUMP);//*timeFlys*0.51;\n    eye.y = mix(eye.y,sin(TRIPLET*PI)*2.50,SYNTHJUMP);//*timeFlys*20.0;\n    light.z = eye.z -4.0;//-iTime*timeFlys;\n    \n    vec3 pos = march(eye,view);\n    vec3 col = vec3(0);\n    \n    if (hit == true) \n    { \n        col = getColor(pos); \n    }\n    else\n    {\n        col = pow( texture( iChannel1, cos(view.xy * (SNARE * 0.50 - KICK * 0.5 - KICK2 * 0.50) )*1.1950 ).xyz, vec3(8.40) )*3.0;\n       // col = audioTex;\n    }\n    \n\tfragColor = max(vec4(col,1.0), 0.0);//+(vec4(0.50,0.50,0.50,0.0)*KICK2);\n    fragColor.r += TRIPLET;//SYNTHJUMP*KICK2;\n    fragColor *= FADEIN;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 25186,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/deadmau5/bridged-by-a-lightwave"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}