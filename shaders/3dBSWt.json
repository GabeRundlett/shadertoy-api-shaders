{
    "Shader": {
        "info": {
            "date": "1555219464",
            "description": "EightRotated Projection\nu*mat2(1,1,-1,1)/sqrt(2.)\nits quite interesting how much i can defer in this symmetry, but not so much defer its /sqrt(2.) detemrinant.",
            "flags": 32,
            "hasliked": 0,
            "id": "3dBSWt",
            "likes": 1,
            "name": "TheWitness1 DiagonalDraw",
            "published": 3,
            "tags": [
                "projection",
                "maze",
                "symmetry",
                "quadrant",
                "thewitness",
                "gap"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 376
        },
        "renderpass": [
            {
                "code": "//child  2: https://www.shadertoy.com/view/wdBXWt\n//self   1: https://www.shadertoy.com/view/3dBSWt\n//parent 0: https://www.shadertoy.com/view/WdSSWt\n\n/*\nblue is a lattice of maze-paths\nred circle is mouse cursor\nred lineSegment is walked path (incompletely walked segment)\nthis shader has a lot more refinec planning in BuffA\non how to define a node-maze with gaps, that can be walked trough.\nto make a game, similar to [the Witness]\n\nThe game [The Witness] mostly defines mazes with gaps\n,that you draw ONE condinuous non-self-ontersecting line over.\nI wondered on how far i can push the mouse-offset-tolerance of this\n\nBuuffA has a concept on how to buffer/draw;\n+ a tiled maze (with gaps in their connections, and missing modes)\n+ 1 incompletely-walked segment\n+ highlight all FULLY walked segments differently.\nwith some doubly-linking where it may make sense.\n*/\n\n\n//rotate whole view by another eightRot \n#define eightRotView\n//disable eightRotView, when you want to understand how this works\n\nfloat pre2(vec2 u,vec2 m//eightRotation simplifies quadtants and projection\n){vec2 s=sign(m)//sign of quadrant\n ;if(s.x!=s.y){u.x=-u.x;m.x=-m.x;}//if(slope of quadrant does NOT go:[\\])\n ;m.xy=r8(m.xy);u=r8(u)\n ;u/=sqrt(2.);m.xy/=sqrt(2.)//optional, preserve scaling, but lose precision/speed\n  //cant be deferred more, as we measure squared euclidean distance soon\n     //and any scaling to that would heavily distort the gradient.\n ;return segment2(u,vec2(m.x,0),vec2(0))//squared euclidean distance to line segment\n ;return       dd(u-vec2(m.x,0)        )//squared euclidean distance to dot\n ;}\n\nvoid mainImage(out vec4 o,vec2 u\n){vec3 r=iResolution.xyz\n ;vec4 m=iMouse.xyzw\n ;float t=iTime\n ;float aa=2./Aa(t,u,r,m)//bokeh (zoom independent)\n ;if(m.z<=0.)m.xy=((cos(1.+iTime*vec2(1,.61))*4.)*.075+.5)*iResolution.xy//auto-mouse\n ;u=fra(t,u,r,m)      //context frame\n ;m.xy=fra(t,m.xy,r,m)//context frame\n #ifdef eightRotView\n ;u=r8(u);m.xy=r8(m.xy)  //optional global view rotation\n ;u/=sqrt(2.);m.xy/=sqrt(2.)//optional, preserve scaling, but lose precision/speed\n #endif\n ;//prior to a geneal u=abs(u) and r8(), we calculate a projection, with a more dependant abs()\n ;float pre=min(dd(u-m.xy),pre2(u,m.xy))\n ;\n ;u   =abs(u)\n ;m.xy=abs(m.xy) \n ;u   =r8(u   );//u   /=sqrt(2.)\n ;m.xy=r8(m.xy);//m.xy/=sqrt(2.)\n ;vec3 c=vec3(pre,dd(u-m.xy),dd(vec2(m.x,0)-u))//3 squared euclidean distances\n ;c=sqrt(c)-.2//squarRoot and offset\n ;c.g+=.1//green mirror symmetry helpers are a bit distracting, make em smaller dots.\n ;c.b=min(c.b,abs(u.y)-.05)//add lines to blue\n ;c=mix(smoothstep(aa,-aa,c),fract(c),.1)//visualize gradient/shape\n ;o=vec4(c,1)\n ;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//this is going to be a common subroutine\n//therefore it is declared in the common tao with my (t,u,t,m) structure\n//the most common identity of (t,u,r,m) parameters are in the Image Tab\n//(iTime,u,iResolution.xyz,iMouse.xyzw)\n//and {tuem] as german word toe [tower] is a neat memonic device.\n//r.z was initially intended for projective mapping (mostly a z-buffer)\n//but is rarely used as such, and instead r is contecually ANY vec3\n//once we are deep enough to make iResolution irrelevant.\n\n//2d camera FoV just zooms out.\n#define viewZoom(t,u,r,m) 4.\n\n//#define viewZoom(t,r) (hl2(r)/floor(mix(1.,hl2(r)*.1,u5(-cos(t)))))\n//viewZoom() returns a float; is defined in a local channel context, to quickly modify its scaling\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define Aa(t,u,r,m) (min(r.x,r.y)/viewZoom(t,u,r,m))\n//fta insists on TURM-parameters because it contains Viewzoom(), that (locally) insists on TURM\n#define fra(t,u,r,m) (u-.5*r.xy)*viewZoom(t,u,r,m)/(r.y)\n\n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define u2(a)(a*2.-1.)\n#define u5(a)(a*.5+.5)\n#define dd(a)dot(a,a)\n//perpendicular dot()used for line intersections, VERY common subroutine in complex-numbers\n#define dotp(a,b)dot(vec2(-a.y,a.x),b)\nv0 suv(vec2 a){return a.x+a.y;}\nv0 mi(v1 a){return min(a.y,a.x);}//return max domain of vector.\nv0 mi(v2 a){return min(a.z,mi(a.xy));}\nv0 mi(v3 a){return min(mi(a.zw),mi(a.xy));}\n#define mav(a)-miv(-a)\n#define sat(a)clamp(a,0.,1.)\nvec4 minx(vec4 a,vec4 b){return mix(b,a,step(a.x,b.x));}//return the vec4 with the smaller .x\n#define min2dd(a)min(dd(a.xy),dd(a.zw))\n#define equals(a,b,c)  mix(b,a,step(c,0.)+step(0.,c)-1.)\n#define equals2(a,b,c)  mix(b,a,step(c.x,0.)+step(0.,c.x)+step(c.y,0.)+step(0.,c.y)-3.)\nvec2 perp(vec2 a){return vec2(-a.y,a.x);}\nbool rea(float s,float b,float e){b-=s;return(abs(s-.5*b)*e<abs(b));}//return(abs(b-a*.5)<a*e);//return(s<b-e||s>b+e);\nfloat gPRxZ(vec2 n,vec2 u,vec2 t){return-(dot(n,u)/dot(n,t));}//second life wiki geometric,is a generalization of segment():\nv0 segment2(v1 p,v1 a,v1 b){p-=a;b-=a;return dd(p-b*sat(dot(p,b)/dd(b)));}\nv0 segment(v1 u,v1 a,v1 b){return sqrt(segment2(u,a,b));}\nv0 lie(v1 u,v1 a,v1 b\n){float c=dd(a-u);float d=segment2(u,a,b);a.x=equals2(c,d,(a-b));return sqrt(a.x);}\n//return distacne from [u] to intersection of ray [ut] and plane [n] trough origin.//[n]PlaneNormal,[u]RayOrigin,[t]RayDirection\n//float gPRxZ(vec3 n,vec3 u,vec3 t){return-(dot(n,u)/dot(n,t));}\n\nvec2 r8(vec2 u){return u*mat2(1,1,-1,1);}//eight-rotation that also scales y sqrt(2)\n\n\n/*\n//parent function, might actually be obsolete/useless\nfloat quadrant(vec2 u//return quadrant[0..3] of u (diagonal borders)\n){vec2 r=mix(vec2(0),vec2(1,2),step(u.x*vec2(1,-1),u.yy))\n //0=down,1=left,2=right,3=up\n //;if(u.x<u.y)r.x+=1.\n //;if(-u.x<-u.y)r.y+=2.\n ;return r.x+r.y;\n ;}\n//this function is a multi-purpose function for maze-lattice games\n//where you actually draw a maze, like in [the Witness]\n*/\n\n\nfloat box(vec2 u\n){u=abs(u)\n ;return abs(max(u.x,u.y)-1.)\n ;}\n\n//line, gaps should be constraine to stay within a single quadrant\n//this seems to be a simple constrain thickness<=1\n//gap width is constrained by thickness\n//you needthinner lines to allow for wider gaps.\nfloat lineGap(float t,vec2 u,vec3 r,vec4 m\n){//t=cos(t)*.5+.5; \n ;t=clamp(t,-r.z,1.)\n ;//r.z=.7//r.z=line thickness\n ;//r.z=mix(.1,.5,sin(t*2.061));\n ;//r.z=mix(.01 ,1.,clamp(m.x,.1,1.))//override thickness width with m.x\n ;//t  =mix(-r.z,1.,clamp(m.y,.1,1.))//override gap width with m.y\n ;u=abs(u)\n ;float c=u.y\n ;c=max(c,u.x-1.)\n ;c=max(c,-u.x+t)//gap of width t\n ;return c-r.z;}\n\n\n//may one day lead into []: https://www.shadertoy.com/view/3dSSWt",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//buffA mostly draws a maze-background, likely static, to be defined in commonTab\n//this maxe os nodes on a square lattice, with adjacency-connecting lines\n//these lines may have gaps in them\n//\n//buffA also addresses one segment that is not fully drawn AND it memorizes a walkedPath\n//lines without gaps can be [walked] and are marked as such, like a SINGLE string\n//that can not collide with itself and will be wound back up while walking backwards.\n//\n//buffA defines 1 node for each fragment, with:\n\n//.z=nodeType\n//- if a node exists at that uv, and what type of node it is\n//- .w=nodeType is a bitmask, but stored in type float, only 8 bit matter;\n//- 6 of its bits are [doubly linked] for speed:\n//- -   0= this node does not exist, it has no connectios to nodes/entrance/exit\n//- -   1= there exists a note to the right of this node\n//- -   2= there exists a note to the up    of this node\n//- -   4= there exists a note to the left  of this node\n//- -   8= there exists a note to the down  of this node\n//- -  16= there exists a note to the   up-right of this node\n//- - 32= there exists a note to the down-lleft of this node\n//- these 2 bits are not [doubly linked]:\n//- -  64=this node is an entranceNode\n//- - 128=this node is an exitNode\n//first 6 bits are doubly linked, because they are used for conditionals!\n//\n//- an entranceNode is a ticker circle (roughly double line-thickness)\n//- an exitNode in the witness looks like a path-end,that reaches out of the grid.\n//- this makes sense for its diegetic feature\n//- , but my exit node will look different/simpler, likely just a hole.\n\n//- .xyz defines how wide the gaps of lines between nodes are\n//a node only stores 3 gaps on its positive-directions\n//, the negative directions are stored inthe  3 other offset nodes.\n//, all else would turn this into an overly excessive [doubly-gapped-list]\n//admittingly, a doublyLinkedList of this could be a bit faster\n//, but using 2x as much FBO-memory is just too bad for mobile devices.\n//\n//- .x=horizontal line gaps\n//- .y=vertical line gaps\n//- .z=diagonal line gaps (only [/], not [\\] diagonals)\n//- - [-2]                      ==line is fully drawn in another color (walked maze path)\n//- - [-lineThickness]          ==no gap (maximum kerning, minimun gap)\n//- - [mix(-lineThickness,1.,.5)== 50% gap\n//- - [1.]                      ==max gap size between 2 nodes.\n\n//by mouseInput. the .xyz values may toggle between [-2] and [-lineThickness]\n//but only if it has no gap in the line.\n\n//silly idea, no need to buffer this one at all:\n//because its a stateless entity, fully defined by all other things.\n//- in addition, 1 pixel [likely vec2(0) corner] stores 1 incpmpletely drawn line state\n//- .x=startingNode\n//- .y=endNode\n//- .z=percentage\n//- .w=doesItExist\n//- the whole map at any moment only has 1 incompletely drawn segment\n//- so this is NOT part of any tesselation.\n\n\n//this buffer is read in 2 quite different passes\n//to draw only the fully walked segments\n//, it makes more sense to have nodes in tile-denters.\n//because a fully walked path only has 1 entrance and 1 exit.\n\n//BUT, the unwalked maze background may need a different tiling of triangles\n//so that theres only 2 borders in each triangle, and we only need 3taps to BuffA\n//to get the state of the maze.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){ \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}