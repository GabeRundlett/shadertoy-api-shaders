{
    "Shader": {
        "info": {
            "date": "1622392040",
            "description": "Wave simulation of randomly distributed water droplets falling onto a surface.",
            "flags": 0,
            "hasliked": 0,
            "id": "slX3RB",
            "likes": 6,
            "name": "Water droplets",
            "published": 3,
            "tags": [
                "2d",
                "wave",
                "water",
                "droplets"
            ],
            "usePreview": 0,
            "username": "sheepmaster",
            "viewed": 563
        },
        "renderpass": [
            {
                "code": "const float WAVELENGTH = 30.;\nconst float WAVE_FREQUENCY = 3.;\nconst float INTENSITY_DISTANCE_DROPOFF_SCALE = 0.001;\nconst float INTENSITY_TIME_DROPOFF_SCALE = 1.;\nconst float DROP_FREQUENCY = 2.;\n\n// Minimum amount of time to look back for drops.\nconst float TIME_WINDOW = 10.;\n\nconst float TAU = 8. * atan(1.);\n\n// Samples an exponential distribution with the parameter lambda,\n// given a uniform sample `u` between 0 and 1.\nfloat exponentialSample(float u, float lambda) {\n    return -log(u) / lambda;\n}\n\nfloat sigmoid(float x) {\n    float expX = exp(x);\n    return expX / (expX + 1.);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash31(float p) {\n   vec3 p3 = fract(vec3(p + 1.) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n// Calculate the impact of all drops that have fallen between\n// `startTime` and `endTime`. \nfloat calcDrops(vec2 fragCoord, float startTime, float endTime) {\n    float z = 0.;\n    while (true) {\n        vec3 hash = hash31(startTime);\n        vec2 dropCenter = hash.xy * iResolution.xy;\n        \n        // The time between drops is exponentially distributed.\n        float dropTime = startTime + exponentialSample(hash.z, DROP_FREQUENCY);\n        if (dropTime >= endTime) {\n            break;\n        }\n\n        float d = length(fragCoord - dropCenter);\n        float t = (iTime - dropTime) * WAVE_FREQUENCY - d / WAVELENGTH;\n        \n        // Intensity drops off with the square of the distance...\n        float distanceIntensity = min(1., 1. / (d * d * INTENSITY_DISTANCE_DROPOFF_SCALE));\n\n        // ...and exponentially with time.\n        float timeIntensity = t >= 0. ? 1./exp(t * INTENSITY_TIME_DROPOFF_SCALE) : 0.;\n\n        z += sin(t * TAU) * timeIntensity * distanceIntensity;\n        \n        startTime = dropTime;\n    }\n    return z;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float i = floor(iTime / TIME_WINDOW) - 1.;\n    float startTime = i * TIME_WINDOW;\n    float endTime = startTime + TIME_WINDOW;\n    \n    // Split up the calculation into two intervals\n    // to get a total interval length of at least TIME_WINDOW\n    // while keeping the start values stable.\n    float z = calcDrops(fragCoord, startTime, endTime);\n    z += calcDrops(fragCoord, endTime, iTime);\n\n    fragColor = vec4(vec3(sigmoid(z)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}