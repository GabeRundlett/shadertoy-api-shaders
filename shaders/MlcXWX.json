{
    "Shader": {
        "info": {
            "date": "1481804752",
            "description": "My personal ray marching learning example",
            "flags": 0,
            "hasliked": 0,
            "id": "MlcXWX",
            "likes": 1,
            "name": "Ray Marching Example",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "ProgC",
            "viewed": 579
        },
        "renderpass": [
            {
                "code": "const int max_iterations = 512;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.02;\nconst float clip_far = 1000.0;\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n\t// n must be normalized\n\treturn dot( p, n.xyz ) + n.w;\n}\n\nfloat sdSphere( vec3 p, float radius )\n{\n    return length(p)-radius;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// union operation\nfloat opU( float d1, float d2 )\n{\n\treturn min(d1,d2);\n}\n\nvec4 opUVec4(vec4 d1, vec4 d2)\n{\n    if ( d1.a < d2.a )\n    {\n        return d1;\n    }\n    return d2;\n}\n\n// substraction operation\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// get ray direction\nvec3 rayDir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nvec4 dist_field(vec3 eyePos)\n{\n    // sphere pos\n    vec3 spherePos = vec3(1,2,0);\n    vec3 boxPos = vec3(-3.0,3,0);\n    vec3 boxSize = vec3(1.3, 2, 1.3);\n    \n    vec4 plane = vec4( 0.0, 1.0, 0.0, 0.0 ); // xyz, d\n    \n    vec4 sphereObject = vec4( vec3(1.0, 0.0, 0.0), sdSphere(eyePos-spherePos, 2.0) );\n    vec4 boxObject = vec4( vec3(0.0, 0.0, 1.0), udBox( eyePos - boxPos, boxSize) );\n    vec4 planeObject = vec4( vec3(0.7, 0.8, 0.8), sdPlane(eyePos, plane) );\n    vec4 box2Object = vec4( vec3(0.3, 1.0, 0.6), udBox( eyePos - vec3(2.2,4,1), vec3(0.8)));\n    vec4 cylinderObject = vec4( vec3(1.0, 1.0, 0.0), sdCylinder(eyePos - vec3(-3,0,5), vec2(0.6, 3)));\n        \n    return opUVec4(cylinderObject,\n                   opUVec4( box2Object, \n                   opUVec4(planeObject, \n                   opUVec4( sphereObject, boxObject ) )));\n}\n\nfloat shadowSoft( vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n\tfloat t = mint;\n\tfloat res = 1.0;\n    for ( int i = 0; i < 256; ++i )\n    {        \n        vec4 h = dist_field(ro + rd * t );\n        \n        if ( h.a < 0.001 )\n            return 0.0;\n\t\t\n\t\tres = min( res, k * h.a / t );\n        t += h.a;\n\t\t\n\t\tif ( t > maxt )\n\t\t\tbreak;\n    }\n    return res;\n}\n\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx).a - dist_field( pos - dx ).a,\n\t\t\tdist_field( pos + dy ).a - dist_field( pos - dy ).a,\n\t\t\tdist_field( pos + dz ).a - dist_field( pos - dz ).a\t\t\t\n\t\t)\n\t);\n}\n\n\nfloat ao(vec3 ro, vec3 norm, float k)\n{\n    float res = 0.0;\n    float f = 0.1;\n    for(int i = 1; i<6; i++)\n    {\n        vec3 rp = ro + f*float(i)*norm;\n     \tres+=(1.0/pow(2.0,float(i)))*(f*float(i)-dist_field(rp).a);    \n    }\n\treturn 1.0-k*res;\n}\n\nvec4 rayMarching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n    vec4 d = vec4(0);\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n        vec3 p = origin + dir * depth;\n        d = dist_field(p);\n\t\tfloat dist = d.a / length( gradient( p ) );\n\t\tif ( abs( dist ) < stop_threshold ) {\n\t\t\treturn vec4(d.xyz,depth);\n\t\t}\n\t\tdepth += dist * 0.9;\n\t\tif ( depth >= end) {\n\t\t\treturn vec4(d.xyz,end);\n\t\t}\n\t}\n\treturn vec4(d.xyz, end);\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) \n{\n\tfloat shininess = 2.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( cos(iTime) * 70.0, 90.0, sin(iTime) * 70.0 );\n\t\tvec3 light_color = vec3( 1.0, 1.0, 1.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t        \n        \n        float toLightLen = length( vl );\n\t\tvec3 toLight = normalize( vl );\n\t\n\t\tfloat comb = 0.1;\t\n    \tfloat vis = shadowSoft( v, n, 0.0625, toLightLen, 0.2 );\n                \n        if ( vis > 0.0 )\n\t\t{\n            float range = 30.3;\n\t\t\tfloat diff = 2.0 * max( 0.0, dot( n, vl ) );\n\t\t\tfloat attn = 1.0 - pow( min( 1.0, toLightLen / range ), 2.0 );\n\t\t\tcomb += diff * attn * vis;            \n\t\t}\n        \n\t\tfinal += light_color * ( diffuse + specular );        \n        final *= vec3( comb, comb, comb );\n    }\n        \n\treturn final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // with fragCoord, we generate a dir        \n    vec3 eye = vec3(0,2,10.5);\n    vec3 dir = rayDir( 45.0, iResolution.xy, fragCoord.xy );        \n            \n    vec4 depth = rayMarching(eye, dir, 0.0, clip_far);\n    if ( depth.a >= clip_far )\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    // with the depth, give it a color\n    vec3 pos = eye + dir * depth.a;\n\tvec3 n = gradient( pos );                 \n        \n\tfragColor = vec4( ao(pos, n, 5.0) * 0.9 * depth.xyz * shading( pos, n, eye ), 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}