{
    "Shader": {
        "info": {
            "date": "1651870894",
            "description": "just trying out some things",
            "flags": 0,
            "hasliked": 0,
            "id": "stsBDH",
            "likes": 2,
            "name": "Testbyme",
            "published": 3,
            "tags": [
                "test"
            ],
            "usePreview": 0,
            "username": "abrasaxxx93",
            "viewed": 230
        },
        "renderpass": [
            {
                "code": "#define MAX_DIST 10.\n#define MAX_STEPS 100\n#define HIT_DIST 0.0001\n\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nvec3 hsbColor(float h,float s,float b){\n    clamp(h,0.,1.);\n    clamp(s,0.,1.);\n    clamp(b,0.,1.);\n    \n    float six=6.*h;\n\n    float red;\n    float gre;\n    float blu;\n    if(six<3.){\n        if(six<1.){\n            red=1.;\n            gre=six;\n            blu=0.;\n        }\n        else if(six<2.){\n            red=2.-six;\n            gre=1.;\n            blu=0.;\n        }\n        else{\n            red=0.;\n            gre=1.;\n            blu=six-2.;\n        }\n    }\n    else{\n        if(six<4.){\n            red=0.;\n            gre=4.-six;\n            blu=1.;\n        }\n        else if(six<5.){\n            red=six-4.;\n            gre=0.;\n            blu=1.;\n        }\n        else{\n            red=1.;\n            gre=0.;\n            blu=6.-six;\n        }\n    }\n    red=1.-s*(1.-red);\n    gre=1.-s*(1.-gre);\n    blu=1.-s*(1.-blu);\n\n    red*=b;\n    gre*=b;\n    blu*=b;\n\n    return vec3(red,gre,blu);\n\n}\n\nfloat r(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat dCuboid(vec3 pos,vec3 s,vec3 p){\n    p-=pos;\n    return length(max(abs(p)-s,0.));\n}\n\nfloat dSphere(vec3 pos,float r,vec3 p){\n    return length(p-pos)-r;\n}\n\nfloat dTriangle(vec3 a, vec3 b, vec3 c ,vec3 p){\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat dCapsule(vec3 a, vec3 b, float r, vec3 p){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat dWing(vec3 pos,float s,vec3 p){\n    float d=dTriangle(pos-vec3(-s/16.,0,0),pos-vec3(s/4.,0,0),pos-vec3(-s/16.,0,-s/1.5),p);\n    d=min(d,dTriangle(pos-vec3(s/8.,0,-s/1.5),pos-vec3(s/4.,0,0),pos-vec3(-s/16.,0,-s/1.5),p));\n    d=min(d,dCapsule(pos-vec3(s/8.,0,-s/1.5),pos-vec3(-s/16.,0,-s/1.5),s/64.,p));\n    return d;\n}\n\nfloat dAirPlane(vec3 pos,float s,vec3 p){\n    p.z=abs(p.z);\n    float d=dCapsule(pos+vec3(s/4.,0,0),pos-vec3(s/4.,0,0),s/16.,p);\n    d=min(d,dWing(pos,s,p));//frontwings\n    d=min(d,2.);\n    return d;\n}\n\nfloat dTerrain(vec3 pos,vec3 p){\n    p-=pos;\n    int o=0;\n    float r=pow(.5,float(o))*.25;\n    float dSpheres=length(p-vec3(0,0,0))-r;\n    return max(dSpheres,dCuboid(vec3(0,.25,0),vec3(.5,.25,.5),p));\n}\n\nfloat sdf(vec3 p){\n    float dCube=dCuboid(vec3(0,0,0),vec3(.5),p);\n    //float dAP=dAirPlane(vec3(0,1.5+.125*sin(iTime),0),1.,p);\n    float dTerr=dTerrain(vec3(0,.5,0),p);\n    return min(dCube,dTerr);\n}\n\nvec3 normal(vec3 p){\n    vec2 h=vec2(0.000001,0.);\n    return normalize(vec3(sdf(p+h.xyy)-sdf(p-h.xyy),sdf(p+h.yxy)-sdf(p-h.yxy),sdf(p+h.yyx)-sdf(p-h.yyx)));\n}\n\nfloat light(vec3 lo,vec3 n,vec3 p){\n    return max(dot(normalize(lo-p),n),0.);\n}\n\nfloat rayMarch(vec3 ro,vec3 rd){\n    float t=0.;\n    float dt=0.;\n    int steps=0;\n    vec3 p=ro;\n    do{\n        t+=dt;\n        p+=dt*rd;\n        dt=sdf(p);\n        steps++;\n    }while(dt>=HIT_DIST&&t<MAX_DIST&&steps<MAX_STEPS);\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(2.*fragCoord/iResolution.yy)-vec2(iResolution.x/iResolution.y,1.);\n    \n    vec3 ro=vec3(2.,2.,2.);\n    float zoom=.5;\n    vec3 lookat=vec3(0.);\n    vec3 rd=normalize(lookat-ro);\n    vec3 right=cross(vec3(0.,1.,0.),rd);\n    vec3 up=cross(rd,right);\n    ro+=(uv.x*right+uv.y*up)/zoom;\n    \n    vec3 col=vec3(0);\n    float d=rayMarch(ro,rd);\n    if(d<MAX_DIST){\n        vec3 p=ro+d*rd;\n        vec3 n=normal(p);\n\n        //point light\n        vec3 lo=vec3(3.,3.,3.);\n        float li=light(lo,n,p);\n\n\n        col=vec3(5.*li/(d*d));\n        //col-=vec3(smoothstep(.45,.5,abs(fract(10.*p.y)-.5)));\n    }\n    fragColor=vec4(col,1.);\n    \n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}