{
    "Shader": {
        "info": {
            "date": "1555836435",
            "description": "I did the same thing because I like this look!\nThank you for the Great shader!!!\n\nhttps://twitter.com/connrbell/status/1109491576429047808\nhttps://www.shadertoy.com/view/wdSGRG",
            "flags": 0,
            "hasliked": 0,
            "id": "WlXGzM",
            "likes": 10,
            "name": "IFS Thinking",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "ifs"
            ],
            "usePreview": 0,
            "username": "kaneta",
            "viewed": 771
        },
        "renderpass": [
            {
                "code": "#define MAT_BODY 1.0\n#define MAT_FACE 2.0\n#define MAT_HAND 3.0\n\nconst float pi = acos(-1.);\nconst float pi2 = pi * 2.;\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nvec2 opSU( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), d1.y); }\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 pMod(in vec2 p, in float s) {\n    float a = pi / s - atan(p.x, p.y);\n    float n = pi2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\nvec2 thinkingFace(vec3 p)\n{\n    float boundingSphere = sdSphere(p, 1.5);\n    if (boundingSphere > 0.5) {\n    \treturn vec2(boundingSphere, 0.0);\n    }\n    \n    vec2 face = vec2(sdSphere(p, 1.0), MAT_BODY);\n    \n    vec3 q = p;\n    q.x = abs(q.x);\n    q.xz *= rot(-.3);\n    q.yz *= rot(-0.25 + 0.05 * step(0.0, p.x));\n    q.y *= 0.8;q.z *= 2.0;q.z -= 2.0;\n    vec2 eye =  vec2(sdSphere(q, .11) * 0.5, MAT_FACE);\n    \n    q = p;\n    q.x = abs(q.x);\n    q.xz *= rot(-.35);\n    q.yz *= rot(-0.62 + 0.26 * step(0.0, p.x) + pow(abs(q.x), 1.7) * 0.5);\n    q.z -= 1.0;\n    vec2 brow = vec2(sdCapsule(q, vec3(0.2, 0.0, 0.0), vec3(-.2, 0.0, 0.0), .05) * 0.5, MAT_FACE);\n\n    q = p;\n    q.yz *= rot(0.2 + pow(abs(p.x), 1.8));\n    q.xy *= rot(-0.25);\n    q.z -= 1.0;\n    vec2 mouth = vec2(sdCapsule(q, vec3(0.2, 0.0, 0.0), vec3(-.2, 0.0, 0.0), .045), MAT_FACE);\n    \n    p -= vec3(-.25, -.73, .93);\n    p.xy *= rot(0.2);\n    q = p;\n    q = (q * vec3(1.2, 1.0, 2.0));\n    q -= vec3(0.0, 0.01, 0.0);\n    vec2 hand = vec2(sdSphere(q, .3) * 0.5, MAT_HAND);\n    \n    q = p;\n    \n    vec2 finger1 = vec2(sdCapsule(q - vec3(0.3, 0.2, 0.02), vec3(0.2, 0.0, 0.0), vec3(-.2, 0.0, 0.0), .07), MAT_HAND);\n    vec2 finger2 = vec2(sdCapsule(q * vec3(1.2, 1.0, .8) - vec3(0.2, 0.06, 0.02), vec3(0.1, 0.0, 0.0), vec3(-.1, 0.0, 0.0), .08), MAT_HAND);\n    vec2 finger3 = vec2(sdCapsule(q * vec3(1.2, 1.0, .8) - vec3(0.15, -0.08, 0.015), vec3(0.1, 0.0, 0.0), vec3(-.1, 0.0, 0.0), .08), MAT_HAND);\n    vec2 finger4 = vec2(sdCapsule(q * vec3(1.2, 1.0, .9) - vec3(0.1, -0.2, -0.01), vec3(0.1, 0.0, 0.0), vec3(-.1, 0.0, 0.0), .08), MAT_HAND);\n    \n    p -= vec3(-0.1, 0.3, 0.0);\n    q = p;\n    q.x -= q.y * 0.7;\n\n    vec2 finger5 = vec2(sdCapsule(p, vec3(0.0, -0.2, 0.0) - q, vec3(0.0, 0.2, 0.0), .1 - p.y * 0.15), MAT_HAND);\n    vec2 finger = opU(finger1, opU(finger5, opSU(finger2, opSU(finger3, finger4, 0.035), 0.035)));\n    \n    hand = opSU(hand, finger, 0.02);\n    \n    vec2 d = opU(eye, face);\n    d = opU(brow, d);\n    d = opS(mouth, d);\n    d = opU(hand, d);\n    return d;\n}\n\nvec2 remap(vec2 val, vec2 im, vec2 ix, vec2 om, vec2 ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\n#define ITERATION_NUM 6\n\nfloat it = 0.0;\n\nvec2 map(vec3 p)\n{\n    float s = 1.0;\n    vec3 offset = vec3(1., .5, 2.) * 0.75;\n    float d = 99999.9;\n    float distFromCam = length(p)*0.4;\n    \n    vec3 spacesize = vec3(3.,10.,4.2);\n    p.xyz = mod(p.xyz, spacesize) - spacesize*0.5;\n    \n    vec2 mouse = remap(iMouse.xy/iResolution.xy, vec2(0.0), vec2(1.0), vec2(-pi), vec2(pi));\n    for (int i = 0; i < ITERATION_NUM; i++) {\n    \tp = abs(p) - offset * s;\n        \n        float phase = iTime * 4.0+float(i)*0.25+distFromCam*5.;\n        \n        p.xz *= rot(1.0 + float(i+1) * 0.6 + sin(phase) * 0.08);\n        p.zy *= rot(float(i+1) * 0.5 + sin(phase * 0.33) * 0.05);\n        p.xy *= rot(float(i+1) * 0.6 + sin(phase * 0.77) * 0.075);\n\n        \n        vec3 pp = p / s;\n        //pp.xz *= rot(-pi * 0.5);\n        pp.xz = pMod(pp.xz, 4.0);\n        //d = min(d, thinkingFace(pp).x * s);\n        float thinkd = thinkingFace(pp).x * s;\n        if (d > thinkd) {\n        \td = thinkd;\n            it = float(i);\n        }\n        s *= 0.6;\n        \n    }\n    return vec2(d, 0.0);\n}\n\nvec2 map2(vec3 p)\n{\n    float s = 1.0;\n    vec3 offset = vec3(1., .5, 2.) * 0.75;\n    float d = 99999.9;\n    float distFromCam = length(p)*0.4;\n    \n    vec3 spacesize = vec3(3.,10.,4.2);\n    p.xyz = mod(p.xyz, spacesize) - spacesize*0.5;\n    \n    vec2 mouse = remap(iMouse.xy/iResolution.xy, vec2(0.0), vec2(1.0), vec2(-pi), vec2(pi));\n    for (int i = 0; i < ITERATION_NUM; i++) {\n    \tp = abs(p) - offset * s;\n        \n        float phase = iTime * 4.0+float(i)*0.25+distFromCam*5.;\n        \n        p.xz *= rot(1.0 + float(i+1) * 0.6 + sin(phase) * 0.08);\n        p.zy *= rot(float(i+1) * 0.5 + sin(phase * 0.33) * 0.05);\n        p.xy *= rot(float(i+1) * 0.6 + sin(phase * 0.77) * 0.075);\n\n        \n        vec3 pp = p / s;\n        //pp.xz *= rot(-pi * 0.5);\n        pp.xz = pMod(pp.xz, 4.0);\n        d = min(d, thinkingFace(pp).x * s);\n        s *= 0.6;\n        \n    }\n    return vec2(d, 0.0);\n}\n\nvec3 normal( in vec3 pos, float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map2( pos + e.xyy ).x +\n\t\t\t\t\t  e.yyx*map2( pos + e.yyx ).x +\n\t\t\t\t\t  e.yxy*map2( pos + e.yxy ).x +\n\t\t\t\t\t  e.xxx*map2( pos + e.xxx ).x );\n}\n\nvec3 sunDir = normalize(vec3(.0, .25, .5));\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nfloat sm(float start, float end, float t, float smo)\n{\n    return smoothstep(start, start + smo, t) - smoothstep(end - smo, end, t);\n}\n\nvec3 hsv2rgb(float h, float s, float v)\n{\n    return ((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\nfloat linerFog(float x, float ma, float len)\n{\n  return pow(min(max(x - ma, 0.0) / len, 1.0), 1.7);\n}\n\nvec3 materialize(vec3 p, vec3 ray, float depth, vec2 mat)\n{\n    vec3 col = vec3(0.0);\n    vec3 nor = normal(p, 0.001);\n    col = vec3(max(.75+dot(ray,nor), 0.0));\n   \tnor.b = .1-nor.b;\n    nor.g = 0.;\n    if (depth > 100.0) {\n        col = vec3(0.0);\n    }\n    \n    float t = mod(iTime * 3.0, float(ITERATION_NUM));\n    float val = sm(it, it+1.0, t, 0.5);\n    nor = mix(nor, hsv2rgb(it / float(ITERATION_NUM), 0.8, 1.0) * 20.0, val);\n    col *= (nor.rgb*0.5+0.5);\n    col = mix(col, vec3(0.0), linerFog(depth, 0.1, 20.0));\n    return col;\n}\n\nvec3 trace(vec3 p, vec3 ray)\n{\n    float t = 0.0;\n    vec3 pos;\n    vec2 mat;\n    for (int i = 0; i < 128; i++) {\n        pos = p + ray * t;\n        mat = map(pos);\n        if (mat.x < 0.001 || t > 100.0) {\n        \tbreak;\n        }\n        t += mat.x;\n    }\n    return materialize(pos, ray, t, mat);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float t = iTime;\n    sunDir = vec3(cos(t), 0.3, sin(t));\n    \n    vec3 ro = vec3(6.0 - t * 0.5, 7.5,-2.5);\n    vec3 ta = ro + vec3(-2.0,-1.5,1.0);\n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 3.5));\n    vec3 col = trace(ro, ray);\n\n    col = acesFilm(col);\n    col = pow(col, vec3(1.0/2.2));\n    \n    p = fragCoord.xy / iResolution.xy;\n    p *=  1.0 - p.yx;\n    float vig = p.x*p.y * 200.0;\n    vig = pow(vig, 0.2);\n\n    fragColor = vec4(col * vig,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}