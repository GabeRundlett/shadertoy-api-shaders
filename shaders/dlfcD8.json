{
    "Shader": {
        "info": {
            "date": "1692139870",
            "description": "Good old naive path tracing",
            "flags": 32,
            "hasliked": 0,
            "id": "dlfcD8",
            "likes": 7,
            "name": "Path Tracing name already in use",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "lighting",
                "sphere",
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "beans_please",
            "viewed": 263
        },
        "renderpass": [
            {
                "code": "/* -----------------------------------------------\n  Shadertoy Unit: Image\n  Description: Output\n  iChannel0: Buffer A\n  iChannel1: Buffer B\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Skip the bottom row of pixels (data row)\n    if (int(frag_coord.y) < 1)\n    {\n        frag_col = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    // Read the data from Buffer A\n    vec3 col = texelFetch(iChannel0, ivec2(frag_coord), 0).xyz;\n    \n    // flim\n    col = flim_transform(col, 4., iChannel1);\n    \n    // Output\n    frag_col = vec4(col, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/* -----------------------------------------------\n  Shadertoy Unit: Common\n----------------------------------------------- */\n\n\n\n// -----------------------------------------------\n// Math Utils\n// -----------------------------------------------\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n#define DEG_TO_RAD 0.01745329251994329576923690768\n#define RAD_TO_DEG 57.2957795130823208767981548141\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Pseudo-Random Number Generator\n// Source: https://www.shadertoy.com/view/WdSSRt\n// -----------------------------------------------\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return float(result) / float(0xffffffffu);\n}\n\nvoid prng_init(vec3 seed)\n{\n    seed.xy *= (seed.z + 10.258);\n    seed += 3.49276101561702;\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    random();\n}\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Additional Color Utils (most functions are in flim)\n// -----------------------------------------------\n\nconst vec3 lum_linear_bt709 = vec3(0.2126, 0.7152, 0.0722);\n\nfloat rgb_variance(vec3 a, vec3 b)\n{\n    a = max(a, 0.0);\n    b = max(b, 0.0);\n    \n    a += 0.001;\n    b += 0.001;\n    \n    float v = dot(abs(log2(a / b)), vec3(0.3, 0.59, 0.11));\n    return v*v;\n}\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Keyboard Utils\n// -----------------------------------------------\n\n#define KEY_BACKSPACE 8\n#define KEY_TAB 9\n#define KEY_ENTER 13\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_PAUSE_BREAK 19\n#define KEY_CAPS_LOCK 20\n#define KEY_ESC 27\n#define KEY_SPACE 32\n#define KEY_PAGE_UP 33\n#define KEY_PAGE_DOWN 34\n#define KEY_END 35\n#define KEY_HOME 36\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_PRINT_SCREEN 44\n#define KEY_INSERT 45\n#define KEY_DELETE 46\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_LWIN 91\n#define KEY_RWIN 92\n#define KEY_POPUP 93\n#define KEY_NUMPAD_0 96\n#define KEY_NUMPAD_1 97\n#define KEY_NUMPAD_2 98\n#define KEY_NUMPAD_3 99\n#define KEY_NUMPAD_4 100\n#define KEY_NUMPAD_5 101\n#define KEY_NUMPAD_6 102\n#define KEY_NUMPAD_7 103\n#define KEY_NUMPAD_8 104\n#define KEY_NUMPAD_9 105\n#define KEY_NUMPAD_ASTERISK 106 \n#define KEY_NUMPAD_PLUS 107\n#define KEY_NUMPAD_MINUS 109\n#define KEY_NUMPAD_PERIOD 110\n#define KEY_NUMPAD_SLASH 111\n#define KEY_F1 112\n#define KEY_F2 113\n#define KEY_F3 114\n#define KEY_F4 115\n#define KEY_F5 116\n#define KEY_F6 117\n#define KEY_F7 118\n#define KEY_F8 119\n#define KEY_F9 120\n#define KEY_F10 121\n#define KEY_F11 122\n#define KEY_F12 123\n#define KEY_NUM_LOCK 144\n#define KEY_SCROLL_LOCK 145\n#define KEY_LSHIFT 160\n#define KEY_RSHIFT 161\n#define KEY_LCTRL 162\n#define KEY_RCTRL 163\n\nbool key_is_down(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 0), 0).x != 0.0;\n}\n\nbool key_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 1), 0).x != 0.0;\n}\n\nbool key_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 2), 0).x != 0.0;\n}\n\nfloat fkey_is_down(int key, sampler2D keyboard_channel)\n{\n    return key_is_down(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return key_got_pressed(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return key_toggle_state(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Common\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The common unit contains most of the code, and\n  receives gamut extension matrices from a buffer.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// Parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.0);\nconst float flim_pre_formation_filter_strength = 0.0;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = 0.5;\nconst float flim_extended_gamut_green_rot = 2.0;\nconst float flim_extended_gamut_blue_rot = 0.1;\nconst float flim_extended_gamut_red_mul = 1.0;\nconst float flim_extended_gamut_green_mul = 1.0;\nconst float flim_extended_gamut_blue_mul = 1.0;\n\nconst float flim_sigmoid_log2_min = -10.0;\nconst float flim_sigmoid_log2_max = 22.0;\nconst float flim_sigmoid_toe_x = 0.44;\nconst float flim_sigmoid_toe_y = 0.28;\nconst float flim_sigmoid_shoulder_x = 0.591;\nconst float flim_sigmoid_shoulder_y = 0.779;\n\nconst float flim_negative_film_exposure = 6.0;\nconst float flim_negative_film_density = 5.0;\n\nconst vec3 flim_print_backlight = vec3(1.0);\nconst float flim_print_film_exposure = 6.0;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.0; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1.0);\nconst float flim_post_formation_filter_strength = 0.0;\nconst float flim_midtone_saturation = 1.02;\n\n// -------------------------------\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_uniform_offset(vec3 inp, float black_point, float white_point)\n{\n    float mono = rgb_avg(inp);\n    float mono2 = remap_clamp(mono, black_point / 1000.0, 1.0 - (white_point / 1000.0), 0.0, 1.0);\n    return inp * (mono2 / mono);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), remap_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), remap_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), remap_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), remap_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), remap_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), remap_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\n// -------------------------------\n\nvec3 flim_rgb_sweep(vec2 uv0to1)\n{\n    float hue = 1.0 - uv0to1.y;\n    float exposure = remap(uv0to1.x, 0.0, 1.0, -5.0, 10.0);\n    return rgb_sweep(hue) * pow(2.0, exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(float inp, float toe_x, float toe_y, float shoulder_x, float shoulder_y)\n{\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n    toe_x = clamp(toe_x, 0.0, 1.0);\n    toe_y = clamp(toe_y, 0.0, 1.0);\n    shoulder_x = clamp(shoulder_x, 0.0, 1.0);\n    shoulder_y = clamp(shoulder_y, 0.0, 1.0);\n\n    // Calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // Toe\n    if (inp < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(inp / toe_x, toe_pow);\n    }\n\n    // Straight line\n    if (inp < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * inp + intercept;\n    }\n\n    // Shoulder\n    float shoulder_pow = -slope / (((shoulder_x - 1.0) / pow(1.0 - shoulder_x, 2.0)) * (1.0 - shoulder_y));\n    return (1.0 - pow(1.0 - (inp - shoulder_x) / (1.0 - shoulder_x), shoulder_pow)) * (1.0 - shoulder_y) + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2.0, flim_sigmoid_log2_min);\n    float fac = remap_clamp(log2(mono + offset), flim_sigmoid_log2_min, flim_sigmoid_log2_max, 0.0, 1.0);\n\n    // Calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(fac, flim_sigmoid_toe_x, flim_sigmoid_toe_y, flim_sigmoid_shoulder_x, flim_sigmoid_shoulder_y);\n\n    // Calculate dye density\n    fac *= max_density;\n\n    // Mix factor\n    fac = pow(2.0, -fac);\n\n    // Clip and return\n    return clamp(fac, 0.0, 1.0);\n}\n\nvec3 flim_rgb_color_layer(vec3 inp, vec3 sensitivity_tone, vec3 dye_tone, float max_density)\n{\n    // Normalize\n    vec3 sensitivity_tone_norm = sensitivity_tone / rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / rgb_max(dye_tone);\n\n    // Dye mix factor\n    float mono = dot(inp, sensitivity_tone_norm);\n    float mixFac = flim_dye_mix_factor(mono, max_density);\n\n    // Dye mixing\n    return lerp(dye_tone_norm, vec3(1.0), mixFac);\n}\n\nvec3 flim_rgb_develop(vec3 inp, float exposure, float max_density)\n{\n    // Exposure\n    inp *= pow(2.0, exposure);\n\n    // Blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(inp, vec3(0, 0, 1), vec3(1, 1, 0), max_density);\n\n    // Green-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(0, 1, 0), vec3(1, 0, 1), max_density);\n\n    // Red-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(1, 0, 0), vec3(0, 1, 1), max_density);\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(float primary_hue, float scale, float rotate, float mul)\n{\n    vec3 result = blender_hsv_to_rgb(vec3(wrap(primary_hue + (rotate / 360.0), 0.0, 1.0), 1.0 / scale, 1.0));\n    result /= rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(0.0, red_scale, red_rot, red_mul);\n    m[1] = flim_gamut_extension_mat_row(1.0 / 3.0, green_scale, green_rot, green_mul);\n    m[2] = flim_gamut_extension_mat_row(2.0 / 3.0, blue_scale, blue_rot, blue_mul);\n    return m;\n}\n\nvec3 negative_and_print(vec3 inp, vec3 backlight_ext)\n{\n    // Develop Negative\n    inp = flim_rgb_develop(inp, flim_negative_film_exposure, flim_negative_film_density);\n\n    // Backlight\n    inp *= backlight_ext;\n\n    // Develop Print\n    inp = flim_rgb_develop(inp, flim_print_film_exposure, flim_print_film_density);\n\n    return inp;\n}\n\nbool flim_load_matrices(sampler2D matrix_ch, out mat3 extend_mat, out mat3 extend_mat_inv)\n{\n    // W == valid_w means the matrices have been calculated\n    // in the source buffer.\n    const float valid_w = 2.0;\n\n    vec4 row;\n\n    // extend_mat\n    {\n        row = texelFetch(matrix_ch, ivec2(0, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(1, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(2, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[2] = row.xyz;\n    }\n\n    // extend_mat_inv\n    {\n        row = texelFetch(matrix_ch, ivec2(3, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(4, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(5, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[2] = row.xyz;\n    }\n\n    return true;\n}\n\n// -------------------------------\n\n// matrix_ch: Which channel provides the buffer\n// containing gamut extension matrices?\nvec3 flim_transform(vec3 inp, float exposure, sampler2D matrix_ch)\n{\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // Pre-Exposure\n    inp *= pow(2.0, flim_pre_exposure + exposure);\n\n    // Clip very large values for float precision reasons\n    inp = min(inp, 5000.0);\n\n    // Gamut Extension Matrix (Linear BT.709)\n    mat3 extend_mat, extend_mat_inv;\n    if (!flim_load_matrices(matrix_ch, extend_mat, extend_mat_inv))\n    {\n        return vec3(1, 0, 1);\n    }\n\n    // Backlight (extended gamut)\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // Upper limit in the print (highlight cap)\n    const float big = 10000000.0;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // Pre-Formation Filter\n    inp = lerp(inp, inp * flim_pre_formation_filter, flim_pre_formation_filter_strength);\n\n    // Convert to extended gamut\n    inp *= extend_mat;\n\n    // Negative & Print\n    inp = negative_and_print(inp, backlight_ext);\n\n    // Convert from extended gamut\n    inp *= extend_mat_inv;\n\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // White cap\n    inp /= white_cap;\n\n    // Black cap\n    if (flim_black_point == -1.0) // -1 = auto\n    {\n        vec3 black_cap = negative_and_print(vec3(0.0), backlight_ext);\n        black_cap /= white_cap;\n        inp = rgb_uniform_offset(inp, rgb_avg(black_cap) * 1000.0, 0.0);\n    }\n    else\n    {\n        inp = rgb_uniform_offset(inp, flim_black_point, 0.0);\n    }\n\n    // Post-Formation Filter\n    inp = lerp(inp, inp * flim_post_formation_filter, flim_post_formation_filter_strength);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // Midtone Saturation\n    float mono = rgb_avg(inp);\n    float mixFac = (mono < 0.5) ? remap_clamp(mono, 0.05, 0.5, 0.0, 1.0) : remap_clamp(mono, 0.5, 0.95, 1.0, 0.0);\n    inp = lerp(inp, blender_hue_sat(inp, 0.5, flim_midtone_saturation, 1.0), mixFac);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // OETF (Gamma 2.2)\n    inp = pow(inp, vec3(1.0 / 2.2));\n\n    return inp;\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Common\n\n***********************************/\n\n\n\nvec3 random_unit_vector()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr <= 1.) break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.) return v;\n    }\n    return v;\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.) return v;\n    }\n    return v;\n}\n\n// Basic perspective camera\nstruct cam_t\n{\n    vec3 pos;\n    float fov;\n    float internal_zoom;\n    vec3 internal_forward;\n    vec3 internal_right;\n    vec3 internal_up;\n};\n\n// Ray\nstruct ray_t\n{\n    vec3 orig;\n    vec3 dir;\n};\n\n// Hit info\nstruct hit_t\n{\n    bool hit;\n    float t;\n    vec3 pos;\n    vec3 normal;\n    int mat_id;\n};\n\n// Material info\nstruct mat_t\n{\n    vec3 diffuse;\n    float roughness;\n    vec3 emission;\n    bool no_bounce;\n};\n\n// Ray offset\nconst float ray_offset = .001;\n\n// cam_t: Update internal zoom factor\nvoid cam_update_zoom(inout cam_t cam)\n{\n    cam.internal_zoom = 90. / cam.fov;\n}\n\n// cam_t: Look at a point\nvoid cam_look_at(inout cam_t cam, vec3 look_at)\n{\n    cam.internal_forward = normalize(vec3(0., 0., 1.) - cam.pos);\n    cam.internal_right = normalize(cross(cam.internal_forward, vec3(0, 0, 1)));\n    cam.internal_up = cross(cam.internal_right, cam.internal_forward);\n}\n\n// cam_t: Generate a camera ray for a given set of UV coords\nray_t cam_gen_ray(in cam_t cam, vec2 uv)\n{\n    ray_t r;\n    r.orig = cam.pos;\n    r.dir = normalize(\n        cam.internal_forward\n        + cam.internal_right * (uv.x / cam.internal_zoom)\n        + cam.internal_up * (uv.y / cam.internal_zoom)\n    );\n    return r;\n}\n\n// cam_t: Generate a camera ray for a given set of UV coords (includes DOF)\nray_t cam_gen_ray_dof(in cam_t cam, vec2 uv, float focus_dist, float jitter)\n{\n    // Generate normal ray without normalizing the direction\n    ray_t r;\n    r.orig = cam.pos;\n    r.dir =\n        cam.internal_forward\n        + cam.internal_right * (uv.x / cam.internal_zoom)\n        + cam.internal_up * (uv.y / cam.internal_zoom);\n    \n    // Focal point\n    vec3 fp = r.orig + focus_dist * r.dir;\n    \n    // Randomly offset the ray origin\n    vec2 offs = jitter * random_in_circle();\n    r.orig += cam.internal_right * offs.x + cam.internal_up * offs.y;\n    \n    // Look at the focal point again\n    r.dir = normalize(fp - r.orig);\n    \n    return r;\n}\n\n// https://www.reddit.com/r/opengl/comments/8ntzz5/comment/dzyqwgr\nvoid ray_aabb(int mat_id, const vec3 box_min, const vec3 box_max, in ray_t r, out hit_t h) {\n    vec3 inv_dir = 1.0 / r.dir;\n    vec3 tbot = inv_dir * (box_min - r.orig);\n    vec3 ttop = inv_dir * (box_max - r.orig);\n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    vec2 t = max(tmin.xx, tmin.yz);\n    float t0 = max(t.x, t.y);\n    t = min(tmax.xx, tmax.yz);\n    float t1 = min(t.x, t.y);\n    if (t1 > max(t0, 0.0))\n    {\n        h.hit = true;\n        h.t = t0;\n        h.pos = r.orig + r.dir * t0;\n        h.normal = vec3(0.0, 0.0, 1.0); // what's the proper way? please comment\n        \n        // Material ID\n        h.mat_id = mat_id;\n    }\n}\n\nvoid ray_sphere(int mat_id, const vec3 center, const float radius, in ray_t r, out hit_t h)\n{\n    vec3 ro = r.orig - center;\n    \n    // Quadratic equation\n    float a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(ro, r.dir);\n    float c = dot(ro, ro) - radius*radius;\n    float discriminant = (b * b) - (4.0 * a * c);\n    \n    if (discriminant < 0.0)\n    {\n        // No hits\n        h.hit = false;\n        return;\n    }\n    \n    float sqrt_d = sqrt(discriminant);\n    float t = (-b - sqrt_d) / (2.0 * a);\n    \n    if (t < 0.0)\n    {\n        h.hit = false;\n        return;\n    }\n    \n    h.hit = true;\n    h.t = t;\n    h.pos = r.orig + (t * r.dir);\n    \n    // Normal\n    h.normal = (h.pos - center) / radius;\n    \n    // Material ID\n    h.mat_id = mat_id;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/* -----------------------------------------------\n  Shadertoy Unit: Buffer A\n  Description: Rendering\n  iChannel0: Cubemap\n  iChannel1: Buffer A (self-feeding)\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\n// Sample the environment\nvec3 get_env(vec3 dir)\n{\n    return .02 * pow(texture(iChannel0, dir.xzy).xyz, vec3(2.2));\n}\n\n// Materials\nvoid get_mat(int id, out mat_t m)\n{\n    // Default values\n    m.diffuse = vec3(1);\n    m.roughness = 1.;\n    m.emission = vec3(0);\n    m.no_bounce = false;\n\n    // Ground\n    if (id == 0)\n    {\n        m.diffuse = vec3(.6);\n        m.roughness = .9;\n        return;\n    }\n    \n    // Sphere 1\n    if (id == 1)\n    {\n        m.diffuse = vec3(.1, .25, .9);\n        m.roughness = .9;\n        return;\n    }\n    \n    // Sphere 2\n    if (id == 2)\n    {\n        m.diffuse = vec3(.9, .05, .01);\n        m.roughness = .12;\n        return;\n    }\n    \n    // LEDs\n    if (id >= 3 && id <= 7)\n    {\n        float hue = .1 * iTime +  247.34 * float(id - 3) / 4.;\n        m.emission = 10. * rgb_sweep(hue);\n        m.no_bounce = true;\n        return;\n    }\n}\n\nray_t gen_ray(vec2 uv)\n{\n    const vec3 cam_target = vec3(0, 0, 1);\n    \n    // Camera params\n    cam_t cam;\n    cam.pos = vec3(-.3, -3., 1.5);\n    cam.fov = 60.0;\n    cam_update_zoom(cam);\n    cam_look_at(cam, cam_target);\n    \n    // Ray\n    return cam_gen_ray_dof(cam, uv, iTime * .5, .2);\n}\n\n// Cast a ray to the scene and return information about it\nvoid cast_ray(ray_t r, out hit_t h_final)\n{\n    // Reset\n    h_final.hit = false;\n    h_final.t = 1e9;\n    h_final.mat_id = -1;\n    \n    // Ground\n    {\n        hit_t h;\n        ray_aabb(0, vec3(-8., -8., -.1), vec3(8., 8., 0.), r, h);\n        if (h.hit && h.t < h_final.t) h_final = h;\n    }\n    \n    // Sphere 1\n    {\n        hit_t h;\n        const vec3 sphere_pos = vec3(-.55, 0., 0.5);\n        const float sphere_radius = 0.5;\n        ray_sphere(1, sphere_pos, sphere_radius, r, h);\n        if (h.hit && h.t < h_final.t) h_final = h;\n    }\n    \n    // Sphere 2\n    {\n        hit_t h;\n        const vec3 sphere_pos = vec3(.55, 0., 0.5);\n        const float sphere_radius = 0.5;\n        ray_sphere(2, sphere_pos, sphere_radius, r, h);\n        if (h.hit && h.t < h_final.t) h_final = h;\n    }\n    \n    // LEDs\n    for (int i = 0; i < 5; i++)\n    {\n        hit_t h;\n        float t = iTime * .4;\n        vec3 sphere_pos = vec3(\n            1.8 * cos(TAU * .48 * t + float(i)),\n            -.1 + .2 * cos(TAU * t + float(i)),\n            2. + .2 * cos(TAU * 1.35 * t + 3.72 * float(i)));\n        ray_sphere(i + 3, sphere_pos, .1, r, h);\n        if (h.hit && h.t < h_final.t) h_final = h;\n    }\n}\n\n// Update a given set of absorption and emission spectra based on given ray hit info\nvoid shade_ray(inout ray_t r, inout hit_t h, inout vec3 absorbed, inout vec3 emitted, out bool no_bounce)\n{\n    if (h.hit)\n    {\n        // Get material info\n        mat_t mat;\n        get_mat(h.mat_id, mat);\n        \n        // Emission\n        emitted += mat.emission;\n        \n        // Absorption (Diffuse)\n        absorbed *= mat.diffuse;\n        \n        // Should we stop bouncing?\n        if (mat.no_bounce)\n        {\n            no_bounce = true;\n            return;\n        }\n        \n        // Bounce ray\n        r.orig = h.pos + ray_offset * h.normal;\n        vec3 dir_refl = reflect(r.dir, h.normal);\n        vec3 dir_rand = normalize(h.normal + random_in_sphere());\n        r.dir = normalize(mix(dir_refl, dir_rand, mat.roughness));\n    }\n    else\n    {\n        // Environment\n        emitted += get_env(r.dir);\n        no_bounce = true;\n    }\n}\n\nvec2 screen_to_uv(vec2 coord)\n{\n    return (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvec3 render(vec2 frag_coord)\n{\n    // UV\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Generate camera ray\n    ray_t r = gen_ray(uv);\n    \n    // Ray info\n    hit_t h;\n    vec3 absorbed = vec3(1);\n    vec3 emitted = vec3(0);\n    \n    // Bounce ray and shade\n    bool no_bounce = false;\n    for (int i = 0; i <= 4; i++)\n    {\n        cast_ray(r, h);\n        shade_ray(r, h, absorbed, emitted, no_bounce);\n        if (no_bounce) break;\n    }\n    \n    // Final color\n    return absorbed * emitted;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Read data from the previous frame, stored at the bottom row of pixels.\n    \n    // Data: Resolution\n    vec4 prev_res;\n    {\n        const ivec2 data_coord = ivec2(0, 0);\n        if (ivec2(frag_coord) == data_coord)\n        {\n            frag_col = vec4(iResolution.xy, 0., 0.);\n            return;\n        }\n        prev_res = texelFetch(iChannel1, data_coord, 0);\n    }\n    \n    // Read the previous value of the current pixel\n    vec4 data = texelFetch(iChannel1, ivec2(frag_coord), 0);\n    \n    // Initialize PRNG\n    prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n    // Render with jitter sampling\n    const int num_samples = 50;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < num_samples; i++)\n    {\n        vec2 offs = vec2(random(), random()) - 0.5;\n        col += render(frag_coord + offs);\n    }\n    col /= float(num_samples);\n    \n    // Frame blending\n    frag_col = vec4(mix(data.xyz, col, .3), 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Buffer X\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The buffer unit performs a one-time calculation\n  of flim's gamut extension matrices.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// NOTE:\n// iChannel0 must be set to this buffer (self-feeding).\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // W == valid_w means the matrices have already been calculated.\n    const float valid_w = 2.0;\n\n    // We only care about the first 6 pixels\n    if (ivec2(fragCoord).x > 5 || ivec2(fragCoord).y > 0)\n        return;\n\n    // Previous frame's value\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = prev;\n\n    // Do we need to recalculate the matrices?\n    bool needToCalc = (prev.w != valid_w) || (iTime == 0.0) || (iFrame < 1);\n    if (!needToCalc)\n        return;\n\n    // (Re)calculate the matrices\n    mat3 extend_mat = flim_gamut_extension_mat(flim_extended_gamut_red_scale, flim_extended_gamut_green_scale, flim_extended_gamut_blue_scale, flim_extended_gamut_red_rot, flim_extended_gamut_green_rot, flim_extended_gamut_blue_rot, flim_extended_gamut_red_mul, flim_extended_gamut_green_mul, flim_extended_gamut_blue_mul);\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // extend_mat\n    {\n        if (ivec2(fragCoord) == ivec2(0, 0))\n        {\n            fragColor = vec4(extend_mat[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(1, 0))\n        {\n            fragColor = vec4(extend_mat[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(2, 0))\n        {\n            fragColor = vec4(extend_mat[2], valid_w);\n        }\n    }\n\n    // extend_mat_inv\n    {\n        if (ivec2(fragCoord) == ivec2(3, 0))\n        {\n            fragColor = vec4(extend_mat_inv[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(4, 0))\n        {\n            fragColor = vec4(extend_mat_inv[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(5, 0))\n        {\n            fragColor = vec4(extend_mat_inv[2], valid_w);\n        }\n    }\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Buffer X\n\n***********************************/\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}