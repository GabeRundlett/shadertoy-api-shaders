{
    "Shader": {
        "info": {
            "date": "1588976406",
            "description": "Ray marching participating media in a path tracer.\nDrag mouse to move camera and see different scenes.\nUsing Henyey-Greenstein phase function, importance sampled.",
            "flags": 48,
            "hasliked": 0,
            "id": "wslfzX",
            "likes": 16,
            "name": "Pathtraced Volumetrics",
            "published": 3,
            "tags": [
                "fog",
                "pathtracing",
                "scatter",
                "participatingmedia"
            ],
            "usePreview": 0,
            "username": "demofox",
            "viewed": 1184
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// get the linear color of the pixel\n    vec3 pixelColor = texture( iChannel0, fragCoord.xy/iResolution.xy).rgb;\n    \n    // add in bloom\n    pixelColor += BloomPass2(fragCoord.xy, iResolution.xy, iChannel1);\n    \n    // apply exposure\n    pixelColor *= c_exposure;\n    \n    // tone map the color to bring it from unbound HDR levels to SDR levels\n    pixelColor = ACESFilm(pixelColor);\n    \n    // convert to sRGB, then output\n    pixelColor = LinearToSRGB(pixelColor);\n    fragColor = vec4(pixelColor, 1.0f);    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// =======================================================================\n// Constants\n// =======================================================================\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\nconst float c_goldenRatioConjugate = 0.61803398875; // 1 / goldenRatio\nconst float KEY_SPACE = 32.5/256.0;\n\n// =======================================================================\n// Parameters\n// =======================================================================\n\n// camera parameters\nconst vec3 c_cameraAt = vec3(0.0f, 40.0f, 0.0f);\nconst float c_cameraDistance = 80.0f;\nconst float c_apertureRadius = 0.4f;  // in world units. 0 for pinhole camera.\nconst float c_focalPlaneDistance = 80.0f; // in world units. How far from the camera things are in focus at.\nconst float c_minCameraAngle = c_pi / 2.0f - 0.125f;\nconst float c_maxCameraAngle = (c_pi - 0.01f);\nconst float c_exposure = 2.0f;  // +1 fstops of exposure\nconst float c_FOV = 90.0f; // in degrees\n\n// the place to put the mouse if it hasn't moved yet (aka the default view)\nconst vec2 c_defaultMousePos = vec2(314.0f / 800.0f, 100.0f / 450.0f);\n\n// bloom parameters\nconst vec3 c_bloomMin = vec3(1.0f, 1.0f, 1.0f);\n// The array below is a 1d gaussian which starts at index 0.\n// A nice gaussian calculator is at http://dev.theomader.com/gaussian-kernel-calculator/\n// Just calculate a kernel that is (c_radius * 2 + 1) large and use the second half of the result (including the center).\n// That should give you an array that is (c_radius+1) items large.\n//const int c_bloomRadius = 3;\n//const float c_bloomKernel[c_bloomRadius+1] = float[c_bloomRadius+1](0.383103, 0.241843, 0.060626, 0.00598); // sigma 1.0\nconst int c_bloomRadius = 5;\n//const float c_bloomKernel[c_bloomRadius+1] = float[c_bloomRadius+1](0.382925, 0.24173, 0.060598, 0.005977, 0.000229, 0.000003); // sigma 1.0\nconst float c_bloomKernel[c_bloomRadius+1] = float[c_bloomRadius+1](0.163053, 0.150677, 0.118904, 0.080127, 0.046108, 0.022657); // sigma 2.5\n//const float c_bloomKernel[c_bloomRadius+1] = float[c_bloomRadius+1](0.109317, 0.107159, 0.100939, 0.091364, 0.079465, 0.066414); // sigma 5.0    \n\n// scene parameters\nconst float c_skyboxMultiplier = 0.2f; // for the cube map, if visible.\n\n// ray tracing parameters\nconst int c_numBounces = 8;\nconst float c_minimumRayHitTime = 0.1f;\nconst float c_superFar = 10000.0f;\n\n// ray marching parameters\nconst int c_numSteps = 256;\nconst float c_minStepDistance = 0.1f;\nconst int c_numStepsVolumetric = 32;  // how many steps are taken between the camera and the first solid object down a ray. uniform sampling but randomly offset [0,1] steps\nconst float c_maxDistanceVolumetric = 200.0f; // maximum depth to ray march for volumetric data.\n\n// other parameters\nconst float c_rayPosNormalNudge = 0.01f; // after a hit, it moves the ray this far along the normal away from a surface\n\n// =======================================================================\n// Display Adaptation Functions\n// =======================================================================\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb * 1.055f, vec3(1.f / 2.4f)) - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\n// =======================================================================\n// Bloom Functions\n// =======================================================================\n\nvec3 BloomPass1(in vec2 pixelPos, in vec2 resolution, in sampler2D linearImage)\n{\n    // horizontal & conditional\n    vec3 sum = vec3(0.0f, 0.0f, 0.0f);\n    for (int ix = -c_bloomRadius; ix <= c_bloomRadius; ++ix)\n    {\n        vec3 pixelColor = texture( linearImage, (pixelPos + vec2(ix, 0))/resolution.xy).rgb;\n        vec3 bloomColor = clamp(pixelColor - c_bloomMin, 0.0f, 1.0f);\n        \n        bloomColor = (dot(bloomColor, c_bloomMin) > 0.0f ? bloomColor : vec3(0.0f, 0.0f, 0.0f));\n\n        float weight = c_bloomKernel[abs(ix)];\n        sum += bloomColor * weight;\n    }\n    \n    return sum;\n}\n\nvec3 BloomPass2(in vec2 pixelPos, in vec2 resolution, in sampler2D bloomImage)\n{\n    // vertical\n    vec3 sum = vec3(0.0f, 0.0f, 0.0f);\n    for (int iy = -c_bloomRadius; iy <= c_bloomRadius; ++iy)\n    {\n        vec3 bloomColor = texture( bloomImage, (pixelPos + vec2(0, iy))/resolution.xy).rgb;\n        float weight = c_bloomKernel[abs(iy)];\n        sum += bloomColor * weight;\n    }\n    \n    return sum;\n}\n\n// =======================================================================\n// RNG Functions\n// =======================================================================\n\n// from \"Hash without Sine\" https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n// =======================================================================\n// Misc Functions\n// =======================================================================\n\nfloat MaxComp(vec3 v)\n{\n    return max(v.x, max(v.y, v.z));\n}\n\nint MaxCompIndex(vec3 v)\n{\n    if (v.x > v.y)\n    {\n        if (v.x > v.z)\n            return 0;\n        else\n            return 2;\n    }\n    else\n    {\n        if (v.y > v.z)\n            return 1;\n        else\n            return 2;\n    }\n}\n\nfloat Bias(float x, float bias)\n{\n  return (x / ((((1.0f/bias) - 2.0f)*(1.0f - x))+1.0f));\n}\n\nfloat dot2(in vec3 v ) { return dot(v,v); }\n\n// =======================================================================\n// Distance Functions 2D\n// https://iquilezles.org/articles/distfunctions2d\n// =======================================================================\n\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon,\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\n// =======================================================================\n// Distance Functions 3D\n// https://iquilezles.org/articles/distfunctions\n// =======================================================================\n\nfloat SphereDistance(in vec4 sphere, in vec3 point)\n{\n    return length(point - sphere.xyz) - sphere.w;\n}\n\nfloat PlaneDistance(in vec4 plane, in vec3 point)\n{\n    return (dot(plane.xyz, point) - plane.w) / dot(plane.xyz, plane.xyz);\n}\n\nfloat BoxDistance(in vec3 boxPos, in vec3 boxRadius, in float width, in vec3 point)\n{\n    point -= boxPos;\n    width = max(width, 0.01f);  // fix for a problem i didn't investigate :P\n    \n    // from https://www.youtube.com/watch?reload=9&v=62-pRVZuS5c\n    // rounding the box from https://www.youtube.com/watch?v=s5NGeUV2EyU\n    vec3 q = abs(point) - boxRadius;\n    return length(max(q,vec3(0.0f,0.0f,0.0f))) + min(MaxComp(q), 0.0f) - width;\n}\n\nfloat LineDistance(in vec3 A, in vec3 B, float width, in vec3 point, out vec3 normal)\n{\n\tvec3 AP = point - A;\n    vec3 AB = B - A;\n    \n    // from https://www.youtube.com/watch?v=PMltMdi1Wzg\n    // added normal calculation though\n    float h = min(1.0f, max(0.0f, dot(AP, AB) / dot(AB, AB)));\n    vec3 closestPoint = A + h * AB;\n    normal = normalize(point - closestPoint);\n    return length(point - closestPoint) - width;\n}\n\nfloat BezierDistance( in vec3 pos, in vec3 A, in vec3 B, in vec3 C, in float width)\n{    \n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res ) - width;\n}\n\n// =======================================================================\n// Object Intersection Helpers for Ray Marching\n// =======================================================================\n\n#define OBJECTPASS_RAYTRACE           0\n#define OBJECTPASS_RAYMARCH           1\n#define OBJECTPASS_RAYMARCHVOLUMETRIC 2\n\nstruct SMaterial\n{\n    vec3 diffuse;\n    vec3 specular;\n\tfloat roughness;\n    vec3 emissive;    \n};\n\nstruct SRayHitInfo\n{\n    bool hitAnObject;\n    int objectPass;\n    float dist;\n    vec3 normal;\n    SMaterial material;\n};\n    \nstruct SRayVolumetricInfo\n{\n    float scatterProbability; // per unit distance\n    // for phase function. should be in (-1, 1)\n    // positive numbers scatter rays in the direction they were traveling.\n    // negative numbers scatter them backwards, back to where they came from.\n    // zero for uniformly random scattering.\n\tfloat anisotropy;\n    \n    // Note: emissive and absorption will happen even if scatterProbability is zero.\n    vec3 emissive;            // per unit distance\n    vec3 absorption;          // per unit distance    \n};\n    \nvoid TestSphereMarch(in vec3 rayPos, inout SRayHitInfo info, in vec4 sphere, in SMaterial material)\n{\n    float dist = SphereDistance(sphere, rayPos);\n    if (dist < info.dist)\n    {\n        info.objectPass = OBJECTPASS_RAYMARCH;\n        info.dist = dist;        \n        info.normal = normalize(rayPos - sphere.xyz);\n        info.material = material;\n    }    \n}\n\nvoid TestPlaneMarch(in vec3 rayPos, inout SRayHitInfo info, in vec4 plane, in SMaterial material)\n{\n    float dist = PlaneDistance(plane, rayPos);\n    if (dist < info.dist)\n    {\n        info.objectPass = OBJECTPASS_RAYMARCH;\n        info.dist = dist;        \n        info.normal = plane.xyz;\n        info.material = material;\n    }    \n}\n\nvoid TestBoxMarch(in vec3 rayPos, inout SRayHitInfo info, in vec3 boxPos, in vec3 boxRadius, in float width, in SMaterial material)\n{\n    float dist = BoxDistance(boxPos, boxRadius, width, rayPos);\n    if (dist < info.dist)\n    {\n        info.objectPass = OBJECTPASS_RAYMARCH;\n        info.dist = dist;\n        \n        vec3 relPos = max(abs(rayPos - boxPos) - boxRadius, 0.0f);\n        int maxIndex = MaxCompIndex(relPos);\n        if (maxIndex == 0)\n        {\n            info.normal = (rayPos.x < boxPos.x) ? vec3(-1.0f, 0.0f, 0.0f) : vec3(1.0f, 0.0f, 0.0f);\n        }\n        else if(maxIndex == 1)\n        {\n            info.normal = (rayPos.y < boxPos.y) ? vec3(0.0f, -1.0f, 0.0f) : vec3(0.0f, 1.0f, 0.0f);\n        }\n        else\n        {\n            info.normal = (rayPos.z < boxPos.z) ? vec3(0.0f, 0.0f, -1.0f) : vec3(0.0f, 0.0f, 1.0f);\n        }\n        \n        info.material = material;\n    }    \n}\n\nvoid TestLineMarch(in vec3 rayPos, inout SRayHitInfo info, in vec3 A, in vec3 B, in float width, in SMaterial material)\n{   \n    vec3 normal;\n    float dist = LineDistance(A, B, width, rayPos, normal);\n    if (dist < info.dist)\n    {\n        info.objectPass = OBJECTPASS_RAYMARCH;\n        info.dist = dist;        \n        info.normal = normal;\n        info.material = material;\n    }    \n}\n\nvoid TestBezierMarch(in vec3 rayPos, inout SRayHitInfo info, in vec3 A, in vec3 B, in vec3 C, in float width, in SMaterial material)\n{\n    float dist = BezierDistance(rayPos, A, B, C, width);\n    if (dist < info.dist)\n    {\n        info.objectPass = OBJECTPASS_RAYMARCH;\n        info.dist = dist;    \n        info.normal = vec3(1.0f, 0.0f, 0.0f); // TODO: figure out the normal, if you ever need it! finite differences? dunno.\n        info.material = material;\n    }    \n}\n\n// =======================================================================\n// Object Intersection Helpers for Ray Tracing\n// =======================================================================\n\nbool TestPlaneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 plane, in SMaterial material)\n{\n    float dist = -1.0f;\n    float denom = dot(plane.xyz, rayDir);\n    if (abs(denom) > 0.001f)\n    {\n        dist = (plane.w - dot(plane.xyz, rayPos)) / denom;\n    \n        if (dist > c_minimumRayHitTime && dist < info.dist)\n        {\n            info.hitAnObject = true;\n            info.objectPass = OBJECTPASS_RAYTRACE;\n            info.dist = dist;        \n            info.normal = plane.xyz;\n            info.material = material;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in SMaterial material)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.hitAnObject = true;\n        info.objectPass = OBJECTPASS_RAYTRACE;\n        info.dist = dist;        \n        info.normal = normal;\n\t\tinfo.material = material;        \n        return true;\n    }    \n    \n    return false;\n}\n\nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere, in SMaterial material)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.hitAnObject = true;\n        info.objectPass = OBJECTPASS_RAYTRACE;\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n\t\tinfo.material = material;        \n        return true;\n    }\n    \n    return false;\n}\n\n// Tests against a vertical cylinder without caps\n// Derived from the sphere function and not super optimal but whatever.\nbool TestCylinderTrace(in vec3 rayPos_, in vec3 rayDir_, inout SRayHitInfo info, in vec3 pos, in float radius, in float height, in SMaterial material)\n{\n    vec3 relativeRayPos = rayPos_ - pos;\n    vec3 projectedRayPos = vec3(relativeRayPos.x, 0.0f, relativeRayPos.z);\n    vec3 projectedRayDir = vec3(rayDir_.x, 0.0f, rayDir_.z);\n    \n    float lengthCorrection = length(projectedRayDir);\n    projectedRayDir /= lengthCorrection;\n    \n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = projectedRayPos;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, projectedRayDir);\n\n\tfloat c = dot(m, m) - radius * radius;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n\n    // adjust distance\n    dist /= lengthCorrection;\n\n    // enforce height - note we may be invalid height for the first distance but not the second.\n    vec3 relativeHitPos = relativeRayPos + rayDir_ * dist;\n    if (relativeHitPos.y < 0.0f || relativeHitPos.y > height)\n    {\n        dist = -b + sqrt(discr);\n        dist /= lengthCorrection;\n        relativeHitPos = relativeRayPos + rayDir_ * dist;\n        if (relativeHitPos.y < 0.0f || relativeHitPos.y > height)\n      \t\treturn false;\n    }\n        \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.hitAnObject = true;\n        info.objectPass = OBJECTPASS_RAYTRACE;\n        info.dist = dist;        \n        info.normal = normalize(vec3(relativeHitPos.x, 0.0f, relativeHitPos.z)) * (fromInside ? -1.0f : 1.0f);\n\t\tinfo.material = material;        \n        return true;\n    }\n    \n    return false;\n}\n\n/*\n============================================\n\nNon PBR Path tracer version 2.\nBranched from https://www.shadertoy.com/view/tdXBW8\n\nRaymarched volumetrics. Every point in space can have these properties:\n* scatter chance (particle density)\n* isotropy (for henyey-greenstein phase function, which is importance sampled)\n* emission\n* absoprtion\n\nThis allows for fogs/clouds, subsurface scattering, and also just areas with emission or absorption but no scattering (like a block of jello)\nTransparents / refraction not yet supported though, so you can't make an absorbing jello that also has a shiny surface.\n\nhttp://www.pbr-book.org/3ed-2018/Light_Transport_II_Volume_Rendering/Sampling_Volume_Scattering.html\nhttps://www.alanzucconi.com/2017/10/10/atmospheric-scattering-1/\nhttps://shaderbits.com/blog/creating-volumetric-ray-marcher\nhttps://www.shadertoy.com/view/tsScDG\nhttps://dai.fmph.uniba.sk/upload/f/f9/Ris_lesson07.pdf\nhttps://www.csie.ntu.edu.tw/~cyy/courses/rendering/09fall/lectures/handouts/chap17_volume_4up.pdf\n\n============================================\n\nNon PBR Path tracer version 1.\n\n* ray traced objects & ray marched objects\n * many analystical ray vs object tests are from \"real time collision detection\" by Christer Ericson\n* thin lens simulation (depth of field and bokeh) with a circular aperture.\n* bloom\n\n============================================\n\nneed to make a \"path tracing on shadertoy for dummies\" series focusing on simplicity over convergence speed.\n\n============================================\n\nImprovements for future versions (other shadertoys)...\n\n* blue noise for low sample counts. maybe low discrepancy sequences too for more than low sample counts.\n\n* spectral path tracing - different material properties for different wavelengths of light.\n\n* transparency & refraction?\n * would need ot be able to be inside of objects. maybe only allow for raytracing?\n * maybe combine this with subsurface scattering?\n\n* subsurface scattering\n * which i think is just denser participating media\n * https://my.eng.utah.edu/~darais/classes/cs6620/project/index.html\n * https://www.fxguide.com/fxfeatured/pixar-deep-dive-on-sss-siggraph-preview/\n\n* panini projection for wider angle shots\n * https://wiki.panotools.org/The_General_Panini_Projection\n * or barrel distortion: https://www.decarpentier.nl/lens-distortion\n\n* make a skybox function in Buffer A instead of the hard coded cube map lookup.\n * it could take ray direction (only) as input and return a vec3.\n * could be cool for making procedural skyboxes, including constant color, gradient, and cube map lookups.\n\n* lens flare\n* motion blur\n* fresnel\n* clear coat (multiple shading lobe materials)\n\n* importance sample cos(theta) for diffuse instead of weighting the sample by it.\n * easy to do, just have to re-org how it calculates the next ray direction a bit.\n\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// =======================================================================\n// Scene Descriptions - both ray tracing and ray marched objects. Also participating media.\n// =======================================================================\n\n#define SCENE_FOG1         0  // a ball casting a shadow into an isotropic fog\n#define SCENE_FOG2         1  // a ball casting a shadow into a fog with -0.5 backscattering (left) and 0.5 forward scattering (right)\n#define SCENE_ABSORPTION1  2  // a ball with absorption (left) vs same ball without (right)\n#define SCENE_ABSORPTION2  3  // a ball with absorption (left) vs same ball without (right) - no scattering\n#define SCENE_EMISSION     4  // a ball with emission (left) vs same ball without (right)\n#define SCENE_LIGHTINFOG1  5  // a fog ball with a light inside of it\n#define SCENE_LIGHTINFOG2  6  // a fog ball with a light inside of it - but with soft edges\n#define SCENE_MULTIFOG     7  // multiple types and colors of fog\n#define SCENE_ORGANICFOG   8  // using 3d noise for fog density\n\n#define SCENE SCENE_FOG1\n\nvoid RayTraceScene(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)\n{\n    // floor\n    {\n    \tSMaterial material;\n        material.diffuse = vec3(0.5f, 0.5f, 0.5f);\n        material.specular = vec3(0.3f, 0.3f, 0.3f);\n        material.roughness = 0.02f;\n        material.emissive = vec3(0.0f, 0.0f, 0.0f);\n    \tif (TestPlaneTrace(rayPos, rayDir, hitInfo, vec4( normalize(vec3(0.0f, 1.0f, 0.0f)), 0.0f), material))\n        {\n            vec3 intersectPos = rayPos + rayDir * hitInfo.dist;\n            vec2 uv = floor(intersectPos.xz / 20.0f);\n            float shade = mix(0.2f, 0.6f, mod(uv.x + uv.y, 2.0f));\n            material.roughness = mix(0.02f, 0.2f, mod(uv.x + uv.y, 2.0f));\n            hitInfo.material.diffuse = vec3(shade, shade, shade);\n        }\n    }\n    \n    // walls\n    {\n    \tSMaterial material;\n        material.specular = vec3(0.0f, 0.0f, 0.0f);\n        material.roughness = 0.02f;\n        material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        \n        vec3 offset = vec3(0.0f, 80.0f, -80.0f);\n        vec3 scale = vec3(80.0f, 80.0f, 1.0f);\n        vec3 A = vec3( 1.0f,  1.0f, 0.0f) * scale + offset;\n        vec3 B = vec3(-1.0f,  1.0f, 0.0f) * scale + offset;\n        vec3 C = vec3(-1.0f, -1.0f, 0.0f) * scale + offset;\n        vec3 D = vec3( 1.0f, -1.0f, 0.0f) * scale + offset;\n        \n        // back wall\n\t\tmaterial.diffuse = vec3(0.9f, 0.9f, 0.9f);\n        TestQuadTrace(rayPos, rayDir, hitInfo, A.xyz, B.xyz, C.xyz, D.xyz, material);\n        \n        // left wall\n        material.diffuse = vec3(0.9f, 0.1f, 0.1f);\n        TestQuadTrace(rayPos, rayDir, hitInfo, A.zyx, B.zyx, C.zyx, D.zyx, material);\n        \n        // right wall\n        material.diffuse = vec3(0.1f, 0.9f, 0.1f);\n        vec3 multiplier = vec3(-1.0f, 1.0f, 1.0f);\n        TestQuadTrace(rayPos, rayDir, hitInfo, A.zyx * multiplier, B.zyx * multiplier, C.zyx * multiplier, D.zyx * multiplier, material);\n    }\n    \n    #if SCENE == SCENE_FOG1 || SCENE == SCENE_FOG2\n    \n        // shadow casting ball\n        {\n            SMaterial material;\n            material.diffuse = vec3(0.9f, 0.9f, 0.9f);\n            material.specular = vec3(0.0f, 0.0f, 0.0f);\n            material.roughness = 0.0f;\n            material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            TestSphereTrace(rayPos, rayDir, hitInfo, vec4( 0.0f, 40.0f, -30.0f, 15.0f), material);\n        }\n\n        // light source\n        {\n            SMaterial material;\n            material.diffuse = vec3(0.0f, 0.0f, 0.0f);\n            material.specular = vec3(0.0f, 0.0f, 0.0f);\n            material.roughness = 0.0f;\n\n            material.emissive = vec3(0.9f, 0.9f, 0.4f) * 100.0f;\n            TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 80.0f, -30.0f, 5.0f), material);        \n        }        \n    \n    #elif SCENE == SCENE_ABSORPTION1 || SCENE == SCENE_ABSORPTION2 || SCENE == SCENE_MULTIFOG || SCENE == SCENE_ORGANICFOG\n    \n        // light source\n        {\n            SMaterial material;\n            material.diffuse = vec3(0.0f, 0.0f, 0.0f);\n            material.specular = vec3(0.0f, 0.0f, 0.0f);\n            material.roughness = 0.0f;\n\n            material.emissive = vec3(0.9f, 0.9f, 0.4f) * 100.0f;\n            TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 80.0f, -30.0f, 5.0f), material);        \n        }  \n    \n    #elif SCENE == SCENE_EMISSION\n    \n    \t// none!\n    \n    #elif SCENE == SCENE_LIGHTINFOG1 || SCENE == SCENE_LIGHTINFOG2\n    \n        // light source\n        {\n            SMaterial material;\n            material.diffuse = vec3(0.0f, 0.0f, 0.0f);\n            material.specular = vec3(0.0f, 0.0f, 0.0f);\n            material.roughness = 0.0f;\n\n            material.emissive = vec3(0.9f, 0.9f, 0.4f) * 100.0f;\n            TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 40.0f, -30.0f, 5.0f), material);        \n        }     \n    \n    #endif\n}\n\n// from https://www.shadertoy.com/view/XsX3RB\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = textureLod( iChannel3, (uv+ vec2(0.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg2 = textureLod( iChannel3, (uv+ vec2(1.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg3 = textureLod( iChannel3, (uv+ vec2(0.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg4 = textureLod( iChannel3, (uv+ vec2(1.5,1.5))/256.0, 0. ).yx;    \n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvoid TestSceneVolumetric(in vec3 rayPos, out SRayVolumetricInfo info)\n{   \n    info.scatterProbability = 0.0f;\n    info.anisotropy = 0.0f;\n    info.emissive = vec3(0.0f, 0.0f, 0.0f);\n    info.absorption = vec3(0.0f, 0.0f, 0.0f);\n    \n    #if SCENE == SCENE_FOG1 || SCENE == SCENE_FOG2\n    \n    \tfloat dist = BoxDistance(vec3(0.0f, 25.0f, -30.0f), vec3(60.0f, 25.0f, 30.0f), 0.0f, rayPos);\n    \tinfo.scatterProbability = step(dist, 0.01f) * 0.02f;\n    \n    \t#if (SCENE == SCENE_FOG2)\n    \t\tif (rayPos.x > 0.0f)\n                info.anisotropy = 0.5f;\n    \t\telse\n                info.anisotropy = -0.5f;\n        #endif\n    \n    #elif SCENE == SCENE_ABSORPTION1 || SCENE == SCENE_ABSORPTION2\n    \tif (step(SphereDistance(vec4( -25.0f, 40.0f, -30.0f, 20.0f), rayPos), 0.01f) > 0.0f)\n        {\n            #if SCENE == SCENE_ABSORPTION1\n            \tinfo.scatterProbability = 0.1f;\n            #endif\n            info.absorption = vec3(0.0f, 0.4f, 0.9f) * 0.1;\n        }\n    \n    \tif (step(SphereDistance(vec4( 25.0f, 40.0f, -30.0f, 20.0f), rayPos), 0.01f) > 0.0f)\n        {\n            info.scatterProbability = 0.1f;\n        }\n    \n    #elif SCENE == SCENE_EMISSION\n    \tif (step(SphereDistance(vec4( -25.0f, 40.0f, -30.0f, 20.0f), rayPos), 0.01f) > 0.0f)\n        {\n           \tinfo.scatterProbability = 0.1f;\n            info.emissive = vec3(0.0f, 0.4f, 0.9f) * 0.05f;\n        }\n    \n    \tif (step(SphereDistance(vec4( 25.0f, 40.0f, -30.0f, 20.0f), rayPos), 0.01f) > 0.0f)\n        {\n            info.scatterProbability = 0.1f;\n        }\n    \n    #elif SCENE == SCENE_LIGHTINFOG1\n    \n    \tif (step(SphereDistance(vec4( 0.0f, 40.0f, -30.0f, 20.0f), rayPos), 0.01f) > 0.0f)\n        {\n           \tinfo.scatterProbability = 0.1f;            \n            info.absorption = vec3(1.0f, 1.0f, 1.0f) * 0.05f;\n        }\n    \n    #elif SCENE == SCENE_LIGHTINFOG2\n    \n \t\tfloat dist = length(rayPos - vec3(0.0f, 40.0f, -30.0f));\n\n        float fogAmount = smoothstep(25.0f, 15.0f, dist);\n    \tinfo.scatterProbability = fogAmount * 0.1f;\n    \tinfo.absorption = vec3(1.0f, 1.0f, 1.0f) * 0.05f * fogAmount;\n    \n    #elif SCENE == SCENE_MULTIFOG\n    \n    \tfloat weight = 0.0f;\n    \n    \tif (BezierDistance(rayPos, vec3(10.0f, 0.0f, -30.0f), vec3(10.0f, 40.0f, -30.0f), vec3(50.0f, 50.0f, -30.0f), 7.0f) < 0.0f)\n        {\n            weight += 1.0f;\n            info.scatterProbability += 0.2f;\n        }\n    \n    \tif (BezierDistance(rayPos, vec3(-50.0f, 40.0f, 0.0f), vec3(-10.0f, 50.0f, 10.0f), vec3(0.0f, 0.0f, 10.0f), 7.0f) < 0.0f)\n        {\n            weight += 1.0f;\n            info.scatterProbability += 0.05f;\n            info.absorption = vec3(0.1f, 0.1f, 0.05f) * 2.0f;\n        }    \n    \n    \tif (BezierDistance(rayPos, vec3(-40.0f, 0.0f, -40.0f), vec3(-40.0f, 40.0f, -20.0f), vec3(-20.0f, 60.0f, 0.0f), 7.0f) < 0.0f)\n        {\n            weight += 1.0f;\n            info.scatterProbability += 0.1f;\n            info.emissive = vec3(1.0f, 1.0f, 0.125f) * 0.1f;\n        }\n        \n    \tif (BoxDistance(vec3(30.0f, 10.0f, -20.0f), vec3(15.0f, 10.0f, 15.0f), 5.0f, rayPos) < 0.0f)\n        {\n            weight += 1.0f;\n            info.absorption = vec3(0.1f, 0.4f, 0.9f) * 0.25f;\n        }\n    \n    \tif (weight > 0.0f)\n        {\n            info.scatterProbability /= weight;\n            info.absorption /= weight;\n            info.emissive /= weight;\n        }\n    #elif SCENE == SCENE_ORGANICFOG\n    \n    \tfloat density = noise((rayPos + vec3(10.0f, 0.0f, 0.0f)) / 25.0f);\n    \tconst float threshold = 0.6f;\n    \n    \tdensity = clamp((density - threshold) / (1.0f - threshold), 0.0f, 1.0f);\n    \tinfo.scatterProbability = density * 0.075f;\n    #endif\n}\n\nSRayHitInfo TestSceneMarch(in vec3 rayPos)\n{\n    SRayHitInfo hitInfo;\n    hitInfo.hitAnObject = false;\n    hitInfo.dist = c_superFar;\n    return hitInfo;\n}\n\n// =======================================================================\n// Ray Marching\n// =======================================================================\n\nvoid RayMarchScene(in vec3 startingRayPos, in vec3 rayDir, inout SRayHitInfo oldHitInfo)\n{\n    SMaterial dummyMaterial = SMaterial(vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 0.0f, 0.0f), 0.0f, vec3(0.0f, 0.0f, 0.0f));\n    \n    float rayDistance = c_minimumRayHitTime;\n    float lastRayDistance = c_minimumRayHitTime;\n    \n    float lastHitInfoDist = 0.0f;\n    \n    SRayHitInfo newHitInfo = oldHitInfo;\n    newHitInfo.hitAnObject = false;\n    \n    for (int stepIndex = 0; stepIndex < c_numSteps; ++stepIndex)\n    {\n        vec3 rayPos = startingRayPos + rayDistance * rayDir;\n        \n        newHitInfo = TestSceneMarch(rayPos);\n        \n        // these two lines are so that the material code goes away when the test functions are inlined\n        newHitInfo.normal = vec3(0.0f, 0.0f, 0.0f);\n        newHitInfo.material = dummyMaterial;\n        \n        newHitInfo.hitAnObject = newHitInfo.dist < 0.0f;\n        if (newHitInfo.hitAnObject)\n            break;\n        \n        lastRayDistance = rayDistance;\n        rayDistance += max(newHitInfo.dist, c_minStepDistance);\n\n        lastHitInfoDist = newHitInfo.dist;\n        \n        if (rayDistance > oldHitInfo.dist)\n            break;\n    }\n    \n    if (newHitInfo.hitAnObject)\n    {\n\t\tfloat refinedHitPercent = lastHitInfoDist / (lastHitInfoDist - newHitInfo.dist);\n        newHitInfo.dist = mix(lastRayDistance, rayDistance, refinedHitPercent);\n        \n        if (newHitInfo.dist < oldHitInfo.dist)\n            oldHitInfo = newHitInfo;\n    }\n}\n\n// http://www.pbr-book.org/3ed-2018/Geometry_and_Transformations/Vectors.html#CoordinateSystem\nvoid CoordinateSystem(in vec3 v1, out vec3 v2, out vec3 v3)\n{\n    if (abs(v1.x) > abs(v1.y))\n        v2 = vec3(-v1.z, 0.0f, v1.x) /\n              sqrt(v1.x * v1.x + v1.z * v1.z);\n    else\n        v2 = vec3(0, v1.z, -v1.y) /\n              sqrt(v1.y * v1.y + v1.z * v1.z);\n    v3 = cross(v1, v2);\n}\n\n// http://www.pbr-book.org/3ed-2018/Color_and_Radiometry/Working_with_Radiometric_Integrals.html#SphericalDirection\nvec3 SphericalDirection(float sinTheta, float cosTheta, float phi, vec3 x, vec3 y, vec3 z) {\n    return sinTheta * cos(phi) * x +\n           sinTheta * sin(phi) * y + cosTheta * z;\n}\n\nvoid RayMarchVolumetric(in vec3 startingRayPos, in vec3 rayDir, inout SRayHitInfo hitInfo, out vec3 absorption, inout uint rngState, in vec2 fragCoord)\n{\n    float searchDistance = hitInfo.hitAnObject ? min(hitInfo.dist, c_maxDistanceVolumetric) : c_maxDistanceVolumetric;\n    float stepSize = searchDistance / float(c_numStepsVolumetric);\n\n    // random starting offset up to a step size for each ray, to make up for lower step count ray marching.\n    float t = RandomFloat01(rngState) * stepSize;\n    \n    float scatterRoll = RandomFloat01(rngState);\n    float scatterCum = 1.0f;\n    absorption = vec3(1.0f, 1.0f, 1.0f);\n    vec3 emissive = vec3(0.0f, 0.0f, 0.0f);\n\n    SRayVolumetricInfo volumetricInfo;\n    bool scattered = false;\n    \n    for (int i = 0; i < c_numStepsVolumetric; ++i)\n    {\n\t\tvec3 rayPos = startingRayPos + rayDir * t;\n        TestSceneVolumetric(rayPos, volumetricInfo);  // we could maybe try averaging the volumetricInfo with the last step or something.\n        \n        float desiredScatter = scatterRoll / scatterCum;  // this is how much we need to multiply scatterCum by to get to scatterRoll\n        \n        scatterCum *= exp(-volumetricInfo.scatterProbability * stepSize);               \n        if (scatterCum < scatterRoll)\n        {\n            float lastT = t - stepSize;\n            \n            // using inverted beer's law to find the time between steps to get the right scatter amount.\n            // beer's law is   y = e^(-p*x)\n            // inverted, it is x = 1/p * ln(1/y)\n            float stepT = (1.0f / volumetricInfo.scatterProbability) * log(1.0f / desiredScatter);\n            t = lastT + stepT;\n            \n            // absorption and emission over distance\n            absorption *= exp(-volumetricInfo.absorption * stepT);\n            emissive += volumetricInfo.emissive * stepT;\n            \n            scattered = true;\n            break;\n        }\n        \n        // absorption and emission over distance\n        absorption *= exp(-volumetricInfo.absorption * stepSize);       \n        emissive += volumetricInfo.emissive * stepSize;\n        \n        // go to next ray position\n        t += stepSize;\n    }\n    \n    if (!scattered)\n    {\n        // emissive over distance should happen even when there's no scattering\n        hitInfo.material.emissive += emissive;\n        return;\n    }\n    \n    hitInfo.hitAnObject = true;\n    hitInfo.objectPass = OBJECTPASS_RAYMARCHVOLUMETRIC;\n    hitInfo.dist = t;\n    \n    // importance sample Henyey Greenstein phase function to get the next ray direction and put it in the normal.\n    // http://www.pbr-book.org/3ed-2018/Light_Transport_II_Volume_Rendering/Sampling_Volume_Scattering.html\n    // https://www.csie.ntu.edu.tw/~cyy/courses/rendering/09fall/lectures/handouts/chap17_volume_4up.pdf\n    {\n        float g = volumetricInfo.anisotropy;\n        \n        vec2 rand = vec2(RandomFloat01(rngState), RandomFloat01(rngState));\n        \n        float cosTheta;\n\t\tif (abs(g) < 1e-3)\n    \t\tcosTheta = 1.0f - 2.0f * rand.x;\n\t\telse\n        {\n    \t\tfloat sqrTerm = (1.0f - g * g) /\n                    \t\t(1.0f - g + 2.0f * g * rand.x);\n    \t\tcosTheta = (1.0f + g * g - sqrTerm * sqrTerm) / (2.0f * g);\n\t\t}\n        \n        float sinTheta = sqrt(max(0.0f, 1.0f - cosTheta * cosTheta));\n\t\tfloat phi = c_twopi * rand.y;\n\t\tvec3 v1, v2;\n\t\tCoordinateSystem(rayDir, v1, v2);\n\t\thitInfo.normal = SphericalDirection(sinTheta, cosTheta, phi, v1, v2, -rayDir);\n    }\n        \n    hitInfo.material.diffuse = vec3(0.0f, 0.0f, 0.0f);\n    hitInfo.material.specular = vec3(0.0f, 0.0f, 0.0f);\n    hitInfo.material.roughness = 0.0f;\n    hitInfo.material.emissive = emissive;\n}\n\n// =======================================================================\n// Iterative bounce path tracing - the main loop.\n// =======================================================================\n    \nvec3 GetColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState, in vec2 fragCoord)\n{\n    vec3 ret = vec3(0.0f, 0.0f, 0.0f);\n    vec3 colorMultiplier = vec3(1.0f, 1.0f, 1.0f);\n    \n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n       \n    for (int i = 0; i <= c_numBounces; ++i)\n    {\n        SRayHitInfo hitInfo;\n\t\thitInfo.hitAnObject = false;\n        hitInfo.dist = c_superFar;\n        \n        // ray trace first, which also gives a maximum distance for ray marching\n        RayTraceScene(rayPos, rayDir, hitInfo);\n        \n        // ray march next\n        RayMarchScene(rayPos, rayDir, hitInfo);\n        \n        // Volumetric ray march after that\n        vec3 absorption;\n        RayMarchVolumetric(rayPos, rayDir, hitInfo, absorption, rngState, fragCoord);\n        \n        // apply absorption to the color multiplier before shading the object or sampling the skybox\n        colorMultiplier *= absorption;\n        \n\t\t// handle ray misses by sampling a skybox and exiting the loop\n        if (!hitInfo.hitAnObject)\n        {\n            ret += texture(iChannel1, rayDir).rgb * c_skyboxMultiplier * colorMultiplier;\n            break;\n        }\n                      \n        // update the ray position\n        rayPos += rayDir * hitInfo.dist;\n               \n        // get the material info if it was a ray marched object\n        if (hitInfo.objectPass == OBJECTPASS_RAYMARCH)\n\t\t\thitInfo = TestSceneMarch(rayPos);\n                \n\t\t// add in emissive lighting\n        ret += hitInfo.material.emissive * colorMultiplier;\n        \n        // set up the next ray direction       \n        if (hitInfo.objectPass == OBJECTPASS_RAYMARCHVOLUMETRIC)\n        {            \n            // volumetrics set up their own raydir in the normal\n\t\t\trayDir = hitInfo.normal;\n        }\n        else\n        {\n            // figure out whether we are going to shoot out a specular or diffuse ray.\n            // If neither, exit\n            float diffuseLength = length(hitInfo.material.diffuse);        \n            float specularLength = length(hitInfo.material.specular);\n            if (diffuseLength + specularLength == 0.0f)\n                break;\n            float specularWeight = specularLength / (diffuseLength + specularLength);       \n            float doSpecular = float(RandomFloat01(rngState) < specularWeight);\n            \n        \tfloat roughness = mix(1.0f, hitInfo.material.roughness, doSpecular);\n        \tvec3 reflectDir = reflect(rayDir, hitInfo.normal);\n            \n\t\t\tvec3 randomDir = RandomUnitVector(rngState);\n        \trayDir = normalize(mix(reflectDir, randomDir, roughness));\n        \tif (dot(rayDir, hitInfo.normal) < 0.0f)\n            \trayDir *= -1.0f;        \n        \n        \t// move the ray away from the surface it hit a little bit\n        \trayPos += hitInfo.normal * c_rayPosNormalNudge;\n            \n            // Attenuate diffuse by the dot product of the outgoing ray and the normal (aka multiply diffuse by cosine theta or N dot L)\n            hitInfo.material.diffuse *= dot(hitInfo.normal, rayDir);\n            \n            // Make all future light affected be modulated by either the diffuse or specular reflection color\n            // depending on which we are doing.\n            colorMultiplier *= mix(hitInfo.material.diffuse, hitInfo.material.specular, doSpecular);                 \n        }\n        \n        // Russian Roulette\n        // Randomly terminate a path with a probability inversely equal to the throughput\n        {\n        \tfloat p = max(colorMultiplier.r, max(colorMultiplier.g, colorMultiplier.b));\n        \tif (RandomFloat01(rngState) > p)\n            \tbreak;\n\n        \t// Add the energy we 'lose' by randomly terminating paths\n        \tcolorMultiplier *= 1.0f / p;            \n        }\n    }\n    \n    return ret;\n}\n\n// =======================================================================\n// Orbit Camera\n// =======================================================================\n\nvoid GetCameraVectors(out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraUp, out vec3 cameraRight)\n{   \n    vec2 mouse = iMouse.xy;\n    if (dot(mouse, vec2(1.0f, 1.0f)) == 0.0f)\n        mouse = c_defaultMousePos * iResolution.xy;\n    \n    float angleX = -mouse.x * 16.0f / float(iResolution.x);\n    float angleY = mix(c_minCameraAngle, c_maxCameraAngle, mouse.y / float(iResolution.y));\n    \n    cameraPos.x = sin(angleX) * sin(angleY) * c_cameraDistance;\n    cameraPos.y = -cos(angleY) * c_cameraDistance;\n    cameraPos.z = cos(angleX) * sin(angleY) * c_cameraDistance;\n    \n    cameraPos += c_cameraAt;\n    \n    cameraFwd = normalize(c_cameraAt - cameraPos);\n    cameraRight = normalize(cross(cameraFwd, vec3(0.0f, 1.0f, 0.0f)));\n    cameraUp = normalize(cross(cameraRight, cameraFwd));   \n}\n\n// =======================================================================\n// Main function\n// =======================================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    // add sub pixel jitter for anti aliasing\n    vec2 fragCoordJittered = fragCoord + (vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f);\n    \n    // get the camera vectors\n    vec3 cameraPos, cameraFwd, cameraUp, cameraRight;\n    GetCameraVectors(cameraPos, cameraFwd, cameraUp, cameraRight);\n    \n    // calculate the ray direction for this pixel\n    vec2 uvJittered = fragCoordJittered/iResolution.xy;\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n    vec3 rayDir;\n    {   \n\t\tvec2 screen = uvJittered * 2.0f - 1.0f;\n        screen.y /= aspectRatio;\n                \n        float cameraDistance = tan(c_FOV * 0.5f * c_pi / 180.0f);       \n        rayDir = vec3(screen, cameraDistance);\n        rayDir = normalize(mat3(cameraRight, cameraUp, cameraFwd) * rayDir);\n    }\n    \n    // simulate a thin lens (depth of field and circular bokeh)\n    if (c_apertureRadius > 0.0f)\n    {\n        // calculate point on the focal plane\n        vec3 focalPlanePoint = cameraPos + rayDir * c_focalPlaneDistance;\n        \n        // calculate a random point on the aperture\n        float angle = RandomFloat01(rngState) * 2.0f * c_pi;\n\t\tfloat radius = sqrt(RandomFloat01(rngState)) * c_apertureRadius;\n\t\tvec2 offset = vec2(cos(angle), sin(angle)) * radius;\n        \n        // update the camera pos\n        cameraPos += offset.x * cameraRight + offset.y * cameraUp;\n        \n        // update the ray direction\n        rayDir = normalize(focalPlanePoint - cameraPos);  \n    }\n    \n    // get the linear color of the ray\n    vec3 color = GetColorForRay(cameraPos, rayDir, rngState, fragCoord);\n    \n    // integrate color with previous frame.\n    // incremental averaging: https://blog.demofox.org/2016/08/23/incremental-averaging/\n    bool spacePressed = (texture(iChannel2, vec2(KEY_SPACE,0.25)).x > 0.1);\n    vec4 oldColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (oldColor.a == 0.0f || iMouse.z > 0.0 || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / oldColor.a));\n    color = mix(oldColor.rgb, color, blend);    \n    fragColor = vec4(color, blend);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Does first pass of Bloom (horizontal & conditional)\n    fragColor = vec4(BloomPass1(fragCoord.xy, iResolution.xy, iChannel0), 1.0f);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}