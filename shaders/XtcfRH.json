{
    "Shader": {
        "info": {
            "date": "1538661185",
            "description": "Utilizing a repeat polar grid to plot objects moving along a transcendental rose curve path.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtcfRH",
            "likes": 62,
            "name": "Polar Grid Motion",
            "published": 3,
            "tags": [
                "grid",
                "particles",
                "curve",
                "motion",
                "polar",
                "rose",
                "rosace"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 2779
        },
        "renderpass": [
            {
                "code": "/*\n\n\tPolar Grid Motion\n\t-----------------\n\n\tUtilizing a repeat polar grid to plot objects moving along a transcendental rose \n    curve path.\n\n\tI wanted to post something nice and simple that the average GPU could handle. This \n    was inspired in part by Vovosunt's \"Dots and Spirals,\" but was based on Fabrice's \n    original \"rosace 3\" example. They say small things amuse small minds, and at the \n    time, that particular example kept me busy for ages. :)\n\n\tThe particle movement is pretty standard. Each object moves in a circular path with a \n    varying radius and Z position based on transcendental functions according to angular \n    position. For anyone not quite familiar with it, I've provided some links below.\n\n\tThe only mildly tricky bit was the rendering process. That involved keeping track of\n\tpotentially overlapping objects, then sorting prior to rendering. There are three\n\tpolar partitioned grids overlapping one another, but arranged radially and depthwise\n\tto look like they form a continuous closed curve. Potential overlapping objects\n\tconsist of three overlapping polar cells (one for each loop) and each of their adjacent \n    polar neighbors (the two on either side). That's nine altogether, which is not very \n    taxing on the average GPU. Therefore, I wouldn't expect any frame rate problems.\n\n\tI've tried to keep things relatively simple, but there's still a bit of esoteric \n\tdressing up code in there. For anyone who'd like to make something similar, you'd be \n    better off starting from scratch, then using this, Vovosunt's or Fabrices example as \n    a guide.\n\t\n\tAnyway, I'd call this a pseudo 3D example. At some stage, I'll try to come up with a\n\traymarched variation. By the way, there's a \"TRANSPARENT\" and \"RANDOM_VARIATION\" \n\tdefine below, for anyone bored enough to try them. :)\n\n\n    Examples:\n\n\t// Really nice.\n\tDots and Spirals - Vovosunt\n\thttps://www.shadertoy.com/view/MltyzN\n    \n    // The original that I based this off of.\n    rosace 3 ( 215 chars) - FabriceNeyret2 \n\thttps://www.shadertoy.com/view/ls3XWM\n\n    // A much simpler demonstration of the key motion concept.\n\tLinear motion - ABizard \n\thttps://www.shadertoy.com/view/4lKyzd\n\n\tLinks:\n\n    Rose (mathematics)\n    https://en.wikipedia.org/wiki/Rose_(mathematics)\n\n\tROSE\n    https://www.mathcurve.com/courbes2d.gb/rosace/rosace.shtml\n\n*/\n\n\n\n// A custom transparent overlay effect. The thing I like about pixel shaders is that\n// Photoshop layer effects are almost rudimentary.\n//#define TRANSPARENT\n\n\n// Making use of the individual particle ID to produce a random variation.\n//#define RANDOM_VARIATION\n\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values, but that's not an issue here.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\nvec3 getLight(vec3 p, vec3 n, vec3 lp){\n    \n    vec3 ld = lp - p;\n    float lDist = length(ld);\n    ld /= lDist;\n    float diff = max(dot(ld, n), 0.);\n    float atten = 1.5/(1. + lDist*lDist);\n    vec3 light = vec3(1)*(diff + .5)*atten;\n    \n    return light;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 U ){\n\n\tvec2 R = iResolution.xy;\n    \n    // Setting a minimum resolution, since fullscreen looks too bloated... Of course,\n    // that would ruin a mobile phone fullscreen settings... Too many systems, so it's\n    // impossible to win without seriously ruining your code. I miss the days when we were \n    // all on 17 inch screens... but not the grainy PPI. Definitely don't miss that. :)\n    float yRes = min(R.y, 800.);\n    \n    // Screen coordinates. This started with a discussion on Fabrice's rosace example\n    // (See the link above). Hence, the confusing minimal variable names. :)\n    U = (2.*U - R)/yRes;\n    \n   \n    //U *= 1. + dot(U, U)*.025; // Makeshift fisheye, if that's your thing.\n    \n     \n    // Three lines of 21, so 63 objects in all. There's nothing special about 21. It's\n    // just the number I settled on. Higher numbers work, but object size needs to be\n    // reduced, since overlap becomes a problem.\n    const float num = 21.;\n    \n    \n    // The scene light. Placed just above the scene.\n    vec3 lp = vec3(0, 0, 1); // Moving light: vec3(.3*cos(t), .2*sin(t), 1).\n    // The object normals. Trivial, in this case, since all are facing the same way.\n    vec3 n = vec3(0, 0, -1);\n    \n    \n\n    \n    \n    \n    // SCENE BACKGROUND.\n    //\n    // Just some noise, lines, and square geometry. Hopefully, self explanatory.\n    \n    // Initialize the background do a brownish gradient.\n    vec3 bg = vec3(.5, .45, .4);\n    \n    #ifdef TRANSPARENT\n    \tbg /= 2.;\n    #endif\n    \n    // Apply some light to the background.\n    vec3 light = getLight( vec3(U, 2.6), n,lp);\n    bg *= light;\n     \n    // Apply some subtle marbly noise.\n    float ns = fbm(U*5. + 17.3);\n    ns = mix(ns, sin(ns*32. - cos(ns*34.)), .125);\n    bg *= max(ns, 0.)*.4 + .8;\n    \n    // Apply a grainy randomized diagonal pattern. It's subtle, but I prefer it.\n    // Without it, the background seems a little too clean.\n    float pat = clamp(sin((U.x - U.y)*min(R.y, 800.)/1.5)*1. + .5, 0., 1.);\n    float rnd = fract(sin(dot(U, vec2(11.27, 112.43)))*43758.5453);\n    if(rnd>.5) pat *= .6; \n    else pat *= 1.4;\n    bg *= pat*.3 + .75;  \n    \n\n    \n    // Initiate the scene color to the background.\n    vec3 col = bg;\n    \n    // Render some border objects to frame things a little bit.\n    //\n    // Border sights: The background corners looked a little empty, so I threw \n    // these in to balance things out... Not sure if it worked, but it's done now. :)\n    vec2 b = vec2(iResolution.x/iResolution.y, 1) - .1;\n    vec2 q = abs(U);\n    float bord = max(q.x - b.x, q.y - b.y);\n    bord = max(bord, -(bord + .11));\n    bord = max(bord, -min(q.x - b.x + .22, q.y - b.y + .22));\n    //bord = max(bord, -(bord + .02));\n\n    \n    // Render the border sight... edge things, or whatever they are.\n    float falloff = 1./min(R.y, 800.);\n    col = mix(col, vec3(0), (1. - smoothstep(0., falloff*12., bord ))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., falloff, bord))*.7);\n    col = mix(col, bg*2.2, (1. - smoothstep(0., falloff, bord + .01)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., falloff, bord + .035)));\n    col = mix(col, bg*1.2, (1. - smoothstep(0., falloff, bord + .044)));   \n    \n    \n    \n    // OBJECT MOVEMENT.\n    //\n    // Moving the cell objects around the rose curve path whilst storing their \n    // positions for rendering.\n    \n    // Nine storage vectors: XYZ hold the 3D positions of the center object and each\n    // of its 8 polar neighbors. The W position holds the object ID.\n    //\n    // When taking polar coordinates into account, there are a potential 9 objects that \n    // could possibly overlap. Therefore, Z distances on all 9 need to be sorted to get \n    // the rendering order correct. If you spaced out the objects more, then you could\n    // probably get away with 3.\n    vec4 c[9];\n    \n    vec4 p; // Utility storage for the object position and ID.\n  \n    // A bit of global rotation -- Rotating the collection of objects as a whole.\n    float t = iTime/4.;\n    // Alternatively, you could take \"t\" out of the loop below, and globally rotate\n    // \"U\" itself.\n    //float t = iTime/4., cs = cos(t), sn = sin(t);\n    //U *= mat2(cs, sn, -sn, cs);\n    \n    // Storing \"atan\" to save a couple of extra calls. Not overly necessary, but my\n    // oldschool brain still thinks of it as an expensive function. :)\n    float a0 = atan(U.y, U.x) - t;\n    \n    // Due to overlap, polar neighbors need to be considered. If the cell objects are \n    // smaller, then it's not a problem, but I wanted a bit of object density.\n    //\n    for(int i=0; i<3; i++){ // Adjacent polar angle cells.\n         \n        float a = a0; // Polar angle.\n    \t\t\n        for(int j=0; j<3; j++) {  // Three intertwining overlapping revolutions.\n          \n            // Current cell angle.\n            //\n            // Note the \"i - 1\" figure. That's because we're considering overlapping\n            // cells to the left and right of \"ia,\" and not two to the right... It took\n            // me a while to realize that oversight. :)\n            //\n            // Cell index.\n        \tfloat ia = mod(floor(a*num/6.283) + float(i - 1), num*3.);\n            // Set the object ID to the cell index.\n            p.w = ia; \n            // Covert cell index to a polar angle.\n            ia = (ia/num + .5/num)*6.283;\n          \n            // Move X and Y along a rose curve path... or a rosace path, as Fabrice calls \n            // it, which I'll assume is the French rosette discription. Without going into \n            // detail, it's a circular path with a varying sinusoidal radius that gives it\n            // that interesting overlapping look.\n            //\n            // By the way, figures of 2./3., 4./3, 7./3. will also produce patterns. For \n            // other patterns, an adjustment of the \"j\" loop here and below and the \"c\" \n            // array size would be necessary... I'm sure you'll figure it out. :)\n            float off = ia*5./3. + iTime;\n        \t// The X and Y positions. Basically, a circle of varying radius.\n            p.xy = (.55 - .25*sin(off))*vec2(cos(ia + t), sin(ia + t));\n            \n            // By varying the Z component with a complementing offset, the objects move\n            // along an interwoven closed path. Obviously, if you set Z to a constant, all \n            // objects would be coplanar and things wouldn't work.\n        \tp.z = 2. + cos(off - 3.14159/5.)*.35;\n            //p.z = (2. + cos(a*5./3. + iTime - 3.14159/5.)*.35);\n   \n            \n            // Store the current cell postion and ID for usage in the rendering loop.\n            c[i*3 + j] = p;\n\n            // Increase the polar angle. Altogether, there'll be three whole revolutions.\n            a += 6.283; \n        \n        \t\n    \t}\n        \n    }\n    \n    // OVERLAPPING NEIGHBORING OBJECT SORTING.\n        \n    // Super lazy distance ordering: Since there are only 45 ((9 + 1)*9/2) iterations --\n    // or something along those lines -- performing a quick swap, the GPU shouldn't really \n    // notice. Also, I've heard that for small datasets, keeping the algorithm simple\n    // (branchless, etc) is more important than iteration count, but I don't know for sure.\n    //\n    // By the way, I think there's a quick vector swap somewhere, so I should probably \n    // track that down.\n    //\n    // On a side note, you could probably get away with a Z-buffer test and do away with the \n    // ordering, but it might disturb the smooth rendering.\n    //\n\tfor(int i=0; i<9; i++){\n        for(int j=i + 1; j<9; j++){\n            // Branchless swaps are possible (see below), but I'm a little paranoid \n            // regarding precision issues, so I'm sticking to what I know. :)\n            if(c[i].z<c[j].z){ \n                vec4 temp = c[i]; c[i] = c[j]; c[j] = temp;\n                \n                // Branchless swap: It works fine on my machine, but I can't\n                // guarantee it'll work in all situations, or that it's faster.\n                // If someone knows one way or the other, I'd love to know.\n                //c[i] = c[i] + c[j]; c[j] = c[i] - c[j]; c[i] = c[i] - c[j];\n            }\n        }\n\t}\n    \n    // OBJECT RENDERING.\n\n    for(int i=0; i<3; i++){ // Adjacent polar angle cells.\n\n        for (int j=0; j<3; j++) {  // Three intertwining overlapping revolutions.\n            \n            // Obtaining the position and ID for the current cell.\n            p = c[i*3 + j];\n            \n            // Using the Z coordi\n            float sz = .175/p.z;\n            float d = length(U - p.xy) - sz;\n            \n            // Main object color \n            #ifdef RANDOM_VARIATION   \n                // Object ID based random value.\n            \tfloat rnd = fract(sin(p.w + 37.)*43758.5453);\n                // Annulus. Equivalent to: max(d, -(d + sz*.75)).\n            \tif(rnd>.5) d = (abs(d + sz*.375) - sz*.375); \n            \n            \t// Random color variations.\n            \t#ifdef TRANSPARENT\n                vec3 pCol = mod(p.w, 3.)==0.?  vec3(1.5, .9, .3) : vec3(1.5, .24, .52);\n                #else\n            \t//vec3 pCol = rnd>.25? vec3(1, .75, .25) : vec3(.6, .9, .25);\n            \tvec3 pCol = mod(p.w, 3.)==0.? vec3(.35) : vec3(1, .22, .45);\n                #endif\n            #else\n            \tvec3 pCol = vec3(1, .75, .25);\n            #endif\n\n            \n            // Lighting the object. Very simple.\n            light = getLight(p.xyz, n, lp);\n\n            // Circular smoothstep falloff, based in the radial inverse.\n            falloff = .0005/sz;\n            \n            // Rendering the simple pattern on the discs. By the way, you could use some\n            // repeat trickery, and cut these steps down, but this isn't a GPU intensive\n            // example, and I wanted to try different variations, and so forth. Also, for \n            // readability, I wanted \"col\" written on the left, so these could be trimmed\n            // down further.\n            //\n            // Shadow, edges, color, etc.\n            //\n            \n            #ifdef TRANSPARENT\n            \tpCol = (col + .1)*pCol*light*3.;\n                // Alternate: Fade between transparent and opaque.\n                //pCol = mix(pCol*light, (col + .1)*pCol*light*3., smoothstep(-.1, .1, sin(iTime/4.)));            \n            #else\n            \tpCol *= light;\n            #endif\n            \n            col = mix(col, vec3(0), (1. - smoothstep(0., falloff*10., d - .0035))*.5);\n            col = mix(col, vec3(0), 1. - smoothstep(0., falloff, d));\n            col = mix(col, pCol, 1. - smoothstep(0., falloff, d + .01));\n            col = mix(col, vec3(0), 1. - smoothstep(0., falloff, d + sz - sz*.4));\n            col = mix(col, vec3(light), 1. - smoothstep(0., falloff, d + sz - sz*.4 + .01));\n            col = mix(col, vec3(0), 1. - smoothstep(0., falloff, d + sz - sz*.2 + .01));\n\n\n        }\n\n    }\n  \n    \n\t// POSTPROCESSING.\n    \n\t// A bit of color mixing, based on the canvas Y coordinate.\n    //col = mix(col.xzy, col, .75);\n    col = mix(col.xzy, col, U.y*.3 + .65);\n    \n    #ifndef RANDOM_VARIATION\n\t#ifdef TRANSPARENT\n    col = col.zyx;\n    #endif \n    #endif \n \n    // Rough gamma correction.\n    O = vec4(sqrt(max(col, 0.)), 1);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}