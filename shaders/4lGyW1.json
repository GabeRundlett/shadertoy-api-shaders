{
    "Shader": {
        "info": {
            "date": "1535981840",
            "description": "Variation of [url=https://www.shadertoy.com/view/XtGyWh]Shaderdough x-ray[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "4lGyW1",
            "likes": 184,
            "name": "Shaderdough fairy",
            "published": 3,
            "tags": [
                "sdf",
                "glow",
                "neon",
                "twist",
                "playdough",
                "fairy"
            ],
            "usePreview": 0,
            "username": "tdhooper",
            "viewed": 6693
        },
        "renderpass": [
            {
                "code": "// --------------------------------------------------------\n// OPTIONS\n// --------------------------------------------------------\n\n// Disable to see more colour variety\n#define SEAMLESS_LOOP\n#define COLOUR_CYCLE\n#define HIGH_QUALITY\n\n// --------------------------------------------------------\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n// --------------------------------------------------------\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n#define PHI (1.618033988749895)\n\n\nfloat t;\n\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat sgn(float x) {\n    return (x<0.)?-1.:1.;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\n\n// --------------------------------------------------------\n// IQ\n// https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// knighty\n// https://www.shadertoy.com/view/MsKGzw\n// --------------------------------------------------------\n\nint Type=5;\nvec3 nc;\nvec3 pbc;\nvec3 pca;\nvoid initIcosahedron() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n    nc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n    pbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n    pca=vec3(0.,scospin,cospin);\n    pbc=normalize(pbc); pca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n\n}\n\nvoid pModIcosahedron(inout vec3 p) {\n    p = abs(p);\n    pReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.);\n}\n\nfloat splitPlane(float a, float b, vec3 p, vec3 plane) {\n    float split = max(sign(dot(p, plane)), 0.);\n    return mix(a, b, split);\n}\n\nfloat icosahedronIndex(inout vec3 p) {\n    vec3 sp, plane;\n    float x, y, z, idx;\n\n    sp = sign(p);\n    x = sp.x * .5 + .5;\n    y = sp.y * .5 + .5;\n    z = sp.z * .5 + .5;\n\n    plane = vec3(-1. - PHI, -1, PHI);\n\n    idx = x + y * 2. + z * 4.;\n    idx = splitPlane(idx, 8. + y + z * 2., p, plane * sp);\n    idx = splitPlane(idx, 12. + x + y * 2., p, plane.yzx * sp);\n    idx = splitPlane(idx, 16. + z + x * 2., p, plane.zxy * sp);\n\n    return idx;\n}\n\nvec3 icosahedronVertex(vec3 p) {\n    vec3 sp, v, v1, v2, v3, result, plane;\n    float split;\n    v = vec3(PHI, 1, 0);\n    sp = sign(p);\n    v1 = v.xyz * sp;\n    v2 = v.yzx * sp;\n    v3 = v.zxy * sp;\n\n    plane = vec3(1, PHI, -PHI - 1.);\n\n    split = max(sign(dot(p, plane.xyz * sp)), 0.);\n    result = mix(v2, v1, split);\n    plane = mix(plane.yzx * -sp, plane.zxy * sp, split);\n    split = max(sign(dot(p, plane)), 0.);\n    result = mix(result, v3, split);\n\n    return normalize(result);\n}\n\n// Nearest vertex and distance.\n// Distance is roughly to the boundry between the nearest and next\n// nearest icosahedron vertices, ensuring there is always a smooth\n// join at the edges, and normalised from 0 to 1\nvec4 icosahedronAxisDistance(vec3 p) {\n    vec3 iv = icosahedronVertex(p);\n    vec3 originalIv = iv;\n\n    vec3 pn = normalize(p);\n    pModIcosahedron(pn);\n    pModIcosahedron(iv);\n\n    float boundryDist = dot(pn, vec3(1, 0, 0));\n    float boundryMax = dot(iv, vec3(1, 0, 0));\n    boundryDist /= boundryMax;\n\n    float roundDist = length(iv - pn);\n    float roundMax = length(iv - vec3(0, 0, 1.));\n    roundDist /= roundMax;\n    roundDist = -roundDist + 1.;\n\n    float blend = 1. - boundryDist;\n    blend = pow(blend, 6.);\n    \n    float dist = mix(roundDist, boundryDist, blend);\n\n    return vec4(originalIv, dist);\n}\n\n// Twists p around the nearest icosahedron vertex\nvoid pTwistIcosahedron(inout vec3 p, float amount) {\n    vec4 a = icosahedronAxisDistance(p);\n    vec3 axis = a.xyz;\n    float dist = a.a;\n    mat3 m = rotationMatrix(axis, dist * amount);\n    p *= m;\n}\n\n\n// --------------------------------------------------------\n// MAIN\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec3 colour;\n    float id;\n};\n     \n     \nModel fInflatedIcosahedron(vec3 p) {\n    float d = 1000.;\n\n    // Slightly inflated icosahedron\n    float idx = icosahedronIndex(p);\n    d = min(d, dot(p, pca) - .9);\n    d = mix(d, length(p) - .9, 1.0);\n\n    // Colour each icosahedron face differently\n    # ifdef SEAMLESS_LOOP\n        if (idx == 3.) {\n            idx = 2.;\n        }\n        idx /= 10.;\n    # else\n        idx /= 20.;\n    # endif\n    # ifdef COLOUR_CYCLE\n        idx = mod(idx + t*1., 1.);\n    # endif\n    vec3 colour = spectrum(idx);\n    \n    d *= .6;\n    return Model(d, colour, 1.);\n}\n\nModel model(vec3 p) {\n    float rate = PI/6.;\n\n    float a = atan(1., PHI + 1.);\n    pR(p.yz, a);\n\n    pR(p.yx, t * 2.1 + rate);\n    pR(p.yz, a);\n\n    vec3 twistCenter = vec3(.7, 0, 0);\n    pR(twistCenter.yx, t * 2.1 + rate);\n    pR(twistCenter.yz, a);\n\n    p += twistCenter;\n    pTwistIcosahedron(p, 10.5);\n    p -= twistCenter;\n\n    # ifdef SEAMLESS_LOOP\n        pR(p.yz, -a);\n        pR(p.xy, -PI/2.);\n        pModPolar(p.xy, 3.);\n        pR(p.xy, -PI/2.);\n        pR(p.yz, -a);\n    #endif\n\n    return fInflatedIcosahedron(p);\n}\n\n\nModel map(vec3 p) {\n    return model(p);\n}\n\n\nmat3 calcLookAtMatrix(in vec3 ro, in vec3 ta, in float roll) {\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nconst float MAX_TRACE_DISTANCE = 6.0;\nconst float INTERSECTION_PRECISION = 0.001;\n#ifdef HIGH_QUALITY\n    const float FUDGE_FACTOR = .2;\n#else\n    const float FUDGE_FACTOR = .4;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initIcosahedron();\n    t = iTime - .25;\n    t /= 2.;\n    //t = mod(t, 1.);\n    //t *= 2.5;\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n\n    vec3 camPos = vec3(-1.5,1.6,0);\n    vec3 camTar = -camPos + vec3(0,.1,0);\n    float camRoll = 0.;\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camRoll );  // 0.0 is the camera roll\n\n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,1.0) ); // 2.0 is the lens length\n\n    vec3 color = pow(vec3(.15,0,.2), vec3(2.2));    \n    \n    vec3 ro = camPos;\n    float t = 0.0;\n    float h = INTERSECTION_PRECISION * 2.0;\n    float res = -1.0;\n    vec3 colour;\n    \n    int iter = int(20. / FUDGE_FACTOR);\n\n    for( int i=0; i < iter; i++ ){\n\n        if( t > MAX_TRACE_DISTANCE ) break;\n        Model m = map( ro+rd*t );\n        h = abs(m.dist);\n        t += max(INTERSECTION_PRECISION, h * FUDGE_FACTOR);\n        color += m.colour * pow(max(0., (.02 - h)) * 19.5, 10.) * 150.;\n        color += m.colour * .001 * FUDGE_FACTOR;\n    }\n    \n    color = pow(color, vec3(1./1.8)) * 1.5;\n    color = pow(color, vec3(1.5));\n    color *= 3.5;\n    \n    fragColor = vec4(color,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}