{
    "Shader": {
        "info": {
            "date": "1621006159",
            "description": "my first shader\na raytraced sphere (only diffuse and specular) \nmove with mouse (no rotation support)\ni'm not sure I'm applying normals properly\nadd a custom normal map to make it look decent\n",
            "flags": 0,
            "hasliked": 0,
            "id": "7sSXWK",
            "likes": 0,
            "name": "illuminated sphere",
            "published": 3,
            "tags": [
                "raytracing",
                "raytracing",
                "illumination",
                "normals",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "LelloPisello",
            "viewed": 6187
        },
        "renderpass": [
            {
                "code": "//paste this snippet in your browser's javascript console to add a normal map\n/*\ngShaderToy.SetTexture(0, {mSrc:'https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/daa69c9f-c54f-4f10-a57f-185a25677132/d6sulh0-9d2ecd83-43d4-4c10-943c-0077b19c778c.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7InBhdGgiOiJcL2ZcL2RhYTY5YzlmLWM1NGYtNGYxMC1hNTdmLTE4NWEyNTY3NzEzMlwvZDZzdWxoMC05ZDJlY2Q4My00M2Q0LTRjMTAtOTQzYy0wMDc3YjE5Yzc3OGMuanBnIn1dXSwiYXVkIjpbInVybjpzZXJ2aWNlOmZpbGUuZG93bmxvYWQiXX0.wXxYlNM9PT-eqrwObuP53O6qDJCPl0gNQfvfwK80I6I', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n*/\n\n//number of lights, if you add some change this to fit the actual number\n#define LIGHTS 3\n\n//exponent for the specular highlight\n#define EXPONENT 25.0\n\n//if you want the sphere to have the same color as the normal map set this to 1\n#define TEXTURED 0\n\nstruct light\n{\n    vec3 position;\n    vec4 color;\n};\n\nprecision highp float;\n\nvec3 raySphereIntersection(in vec3 rayOrigin, in vec3 rayDir, in vec4 sphere)\n{\n    vec3 oc = rayOrigin - sphere.xyz;\n    float b = 2.0 * dot(oc, rayDir);\n    float c = dot(oc, oc) - sphere.w * sphere.w;\n    float discriminant = b * b - 4.0 * c;\n    if(discriminant < 0.0)\n    {\n        return vec3(-1);\n    }\n    else\n    {\n        float t = (-b - sqrt(discriminant)) / (2.0);\n        vec3 endpoint = rayDir * t + rayOrigin;\n        if(endpoint.y < rayOrigin.y) return vec3(-1);\n        return endpoint;\n    }\n}\n\n//only works for a sphere, works anyways if you use no normal map\nvec3 calculateLighting(vec3 position, vec3 normal, vec2 uv, light lights[LIGHTS], vec3 camera)\n{\n    //convert from tangent space to world space\n    {\n        mat3 conversion;\n        conversion[0] = normalize(cross(vec3(0, 0, 1), normal));\n        conversion[1] = normalize(cross(normal, conversion[0]));\n        conversion[2] = normal;\n        {\n            vec3 normmap = texture(iChannel0, uv).rgb * 2.0 - 1.0;\n            normmap = normalize(normmap);\n            normal = normmap * conversion;\n        }\n    }\n    vec3 total = vec3(0.0);\n    for(int i = 0; i < LIGHTS; ++i)\n    {\n        \n        vec3 to_light = lights[i].position - position;\n        vec3 incoming = normalize(position - camera);\n        total +=\n            (\n                max(dot(normal, normalize(to_light)), 0.0) + \n                pow(max(dot(normal, normalize((to_light + incoming) * 0.5)), 0.0), EXPONENT)\n            ) * lights[i].color.a / length(to_light) * lights[i].color.rgb;\n    }\n    #if TEXTURED == 1\n    return total * texture(iChannel0, uv).rgb * 0.5;\n    #else\n    return total * 0.5;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //objects\n    //add lights here\n    //the alpha component in the color field of the light struct represents the light's intensity\n    const light lights[LIGHTS] = light[LIGHTS](\n        light(vec3(-0.5, 1.0, 1.25), vec4(1.0, 0.0, 0.0, 1.75)),\n        light(vec3(1.5, 0.5, -0.75), vec4(0.2, 1.0, 0.4, 1.0)),\n        light(vec3(-1.75, 4, 2.0), vec4(0.0, 0.0, 1.0, 5))\n    );\n    //camera position\n    vec3 camera = vec3((iMouse.x / iResolution.x - .5) * 5.0, -5.0, (iMouse.y / iResolution.y - .5) * 5.0);\n    //sphere position\n    vec4 sphere = vec4(cos(iTime * 2.5), sin(iTime * 5.0), 0.0, 1.5);\n    #if TEXTURED != 1\n    vec3 sphereColor = vec3(1.0, 1.0, 1.0);\n    #endif\n    \n    //rendering\n    vec3 rayDir = \n    normalize(vec3\n    (\n        fragCoord.x - iResolution.x / 2.0,\n        iResolution.y / 1.5,\n        fragCoord.y - iResolution.y / 2.0\n    ));\n    vec3 intersect = raySphereIntersection(camera, rayDir, sphere);\n    if(intersect == vec3(-1)) fragColor = vec4(vec3(0.0), 1.0);\n    else \n    {\n        vec3 normal = normalize(intersect - sphere.xyz);\n        vec2 uv = (intersect.xz - sphere.xz) / sphere.w / 2.0 + 0.5;\n        \n        fragColor = \n            #if TEXTURED == 1\n            vec4(calculateLighting(intersect, normal, uv, lights, camera), 1.0);\n            #else\n            vec4(calculateLighting(intersect, normal, uv, lights, camera) * sphereColor, 1.0);\n            #endif\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}