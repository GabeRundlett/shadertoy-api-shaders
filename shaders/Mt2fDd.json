{
    "Shader": {
        "info": {
            "date": "1517754145",
            "description": "inspired by [url=https://www.shadertoy.com/view/MlsBDB]Layered Terrain Islands[/url]\nbasically many layers of 2d raymarching",
            "flags": 0,
            "hasliked": 0,
            "id": "Mt2fDd",
            "likes": 4,
            "name": "distance field slices",
            "published": 3,
            "tags": [
                "raymarching",
                "voxels",
                "slixels"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 740
        },
        "renderpass": [
            {
                "code": "#define rot(spin) mat2(sin(spin),cos(spin),cos(spin),-sin(spin))\n\nfloat box(vec2 p, vec2 s) {\n    return length(max(abs(p)-s,vec2(0)));\n}\n\nfloat map(vec2 p, float slice)\n{\n    vec2 offset = vec2(sin(slice*0.1+iTime*0.3),cos(slice*0.1+iTime*0.3));\n    p = fract(p*0.1+offset)*10.0-5.0;\n    \n    vec2 size = vec2((sin(floor(slice))*sin(iTime))*0.2+0.45,cos(slice*0.5)*0.5+0.6)*2.5;\n    \n    float isbox = mod(slice,2.0);\n    \n    return box(p,vec2(size*isbox))-size.x*(1.0-isbox);\n}\n\nvec2 findnormal(vec2 p, float slice, float len) {\n    vec2 eps = vec2(0.0,0.01);\n    return normalize(vec2(\n        map(p+eps.yx,slice),\n        map(p+eps.xy,slice))-\n        len);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0.0,iTime*3.0,0.0);\n    vec3 rd = vec3(uv,1.0);\n    \n    rd.zy *= rot(iMouse.y/iResolution.y*3.14+3.14);\n    rd.zx *= rot(-iMouse.x/iResolution.x*6.28+3.14*0.5);\n    rd /= length(rd.xz);\n    float rdlen = length(rd);\n    bool hit = false;\n    float len;\n    float dist = 0.0;\n    \n    vec3 floorpos = floor(ro);\n    vec3 signdir = sign(rd);\n    float inv = 1.0/(abs(rd.y)+0.0001);\n    \n    float limit = inv*abs((signdir.y*0.5+0.5)-fract(ro.y));\n    \n    float slice = floor(ro.y);\n    \n    bool hitside = false;\n    \n    for (int i = 0; i < 200; i++)\n    {\n        len = map(ro.xz,slice);\n        \n        if (len < 0.01||dist>100.0)\n        {\n            hit = len < 0.01;\n            break;\n        }\n        \n        hitside = false;\n        \n        len = min(limit,len);\n        limit -= len;\n        ro += rd*len;\n        dist += len*rdlen;\n        \n        if (limit == len)\n        {\n            limit = inv;\n            slice+=signdir.y;\n            \n            hitside = true;\n            \n            //break;\n        }\n    }\n    if (dist < 100.0)\n    {\n        vec3 normal;\n        if (hitside)\n        {\n            normal = vec3(0,-signdir.y,0);\n        } else {\n        \tnormal = vec3(findnormal(ro.xz,slice,len),0.0).xzy;\n        }\n        \n        vec3 lightdir = vec3(-1);\n        \n        vec3 col = vec3(1.0,0.3,0.0);\n        if (hitside) col = vec3(1.0,0.2,0.1);\n        \n        float ambient = 0.2;\n        \n        float diffusion = clamp(dot(-lightdir,normal),ambient,1.0);\n        \n        fragColor = vec4(col*diffusion,1.0);\n        \n        fragColor /= dist*dist*0.005+1.0;\n        \n    }\n    fragColor = sqrt(fragColor);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}