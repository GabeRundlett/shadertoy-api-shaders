{
    "Shader": {
        "info": {
            "date": "1675080573",
            "description": "Bleep",
            "flags": 36,
            "hasliked": 0,
            "id": "mlsXR2",
            "likes": 6,
            "name": "La fabrique a cookie #04",
            "published": 3,
            "tags": [
                "raymarch",
                "cookie",
                "collective",
                "fabrique"
            ],
            "usePreview": 0,
            "username": "z0rg",
            "viewed": 349
        },
        "renderpass": [
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n// Converted from bonzomatic to shadertoy with\n// https://github.com/TheNuSan/BonzomaticToShadertoy\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec3 col = texture(iChannel0, ouv).xyz;\n     out_color = vec4(col, 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n// Converted from bonzomatic to shadertoy with\n// https://github.com/TheNuSan/BonzomaticToShadertoy\n\n\nfloat _seed = 0.0;\nvec3 accCol = vec3(0.0);\n\nfloat hash(float seed)\n{\n    return fract(sin(seed * 123.456) * 123.456);\n}\n\nfloat rand()\n{\n    float _74 = _seed;\n    _seed = _74 + 1.0;\n    float param = _74;\n    return hash(param);\n}\n\nvec3 getCam(vec3 rd, inout vec2 uv)\n{\n    uv *= (1.0 - clamp(length(uv) * 0.5, 0.0, 1.0));\n    vec3 r = normalize(cross(rd, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize((rd + (r * uv.x)) + (u * uv.y));\n}\n\nfloat truchet(inout vec2 uv)\n{\n    vec2 id = floor(uv);\n    uv = fract(uv) - vec2(0.5);\n    if (fract(sin(dot(vec2(232.1, 314.7), id * 0.2)) * 167.5) < 0.5)\n    {\n        uv.x *= (-1.0);\n    }\n    float s = (uv.x > (-uv.y)) ? 1.0 : (-1.0);\n    uv -= vec2(s * 0.5);\n    return abs(length(uv) - 0.5);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n    {\n        return a;\n    }\n    return b;\n}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p) - s;\n    float c = max(l.x, max(l.y, l.z));\n    l = abs(l) - (s * th);\n    float x = max(max(l.x, c), l.y);\n    float y = max(max(l.z, c), l.y);\n    float z = max(max(l.x, c), l.z);\n    return min(min(x, y), z);\n}\n\nvec2 SDF(inout vec3 p)\n{\n    vec2 acc = vec2(1000.0, -1.0);\n    vec3 op = p;\n    p.z += iTime;\n    vec3 pg = (p * 1.0) - vec3(0.0, -iTime, 0.0);\n    float gyr = (dot(sin(pg), cos(pg.yzx)) + 1.2) + pow(clamp(texture(iChannel0, vec2(0.5)).x * 500.0, 0.0, 1.0), 0.5);\n    gyr = max(gyr, abs(p.x) - 3.0);\n    float shape = max(gyr, length(op) - 10.0);\n    vec2 param = acc;\n    vec2 param_1 = vec2(shape, 0.0);\n    acc = _min(param, param_1);\n    float ground = (-p.y) + ((((sin(p.x + iTime) * 0.2) + (sin(p.z + iTime) * 0.2)) + (sin(length(p.xz) + iTime) * 0.5)) * 0.2);\n    vec2 param_2 = acc;\n    vec2 param_3 = vec2(ground, 1.0);\n    acc = _min(param_2, param_3);\n    vec3 param_4 = op;\n    vec3 param_5 = vec3(5.0);\n    vec3 param_6 = vec3(0.1);\n    float cucube = _cucube(param_4, param_5, param_6);\n    vec2 param_7 = acc;\n    vec2 param_8 = vec2(cucube, 2.0);\n    acc = _min(param_7, param_8);\n    return acc;\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    accCol = vec3(0.0);\n    vec3 p = ro;\n    int i = 0;\n    for (;;)\n    {\n        bool _362 = i < steps;\n        bool _370 = false;\n        if (_362)\n        {\n            _370 = distance(p, ro) < 20.0;\n        }\n        else\n        {\n            _370 = _362;\n        }\n        if (_370)\n        {\n            vec3 param = p;\n            vec2 _374 = SDF(param);\n            vec2 res = _374;\n            if (res.x < 0.01)\n            {\n                return vec3(res.x, distance(p, ro), res.y);\n            }\n            p += (rd * res.x);\n            accCol += ((vec3(1.0, 0.3, 0.5) * (1.0 - clamp(res.x / 1.5, 0.0, 1.0))) * 0.01);\n            i++;\n            continue;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return vec3(-1.0);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.0);\n    vec3 param = p - e.xyy;\n    vec2 _423 = SDF(param);\n    vec3 param_1 = p - e.yxy;\n    vec2 _430 = SDF(param_1);\n    vec3 param_2 = p - e.yyx;\n    vec2 _437 = SDF(param_2);\n    return normalize(vec3(d) - vec3(_423.x, _430.x, _437.x));\n}\n\nvec3 getmat(vec3 p)\n{\n    vec3 col = vec3(0.8, 0.4, 0.6);\n    vec3 _470 = col;\n    vec2 _472 = _470.xy * mat2(vec2(cos(p.z * 5.0), sin(p.z * 5.0)), vec2(-sin(p.z * 5.0), cos(p.z * 5.0)));\n    col.x = _472.x;\n    col.y = _472.y;\n    col = abs(col);\n    return col;\n}\n\nvec3 rdr(inout vec2 uv)\n{\n    uv *= mat2(vec2(cos(iTime * 0.1), sin(iTime * 0.1)), vec2(-sin(iTime * 0.1), cos(iTime * 0.1)));\n    float t = iTime * 0.2;\n    float d = 15.0;\n    vec3 ro = vec3(0.01 + (sin(t) * d), -2.0, cos(t) * d);\n    float _515 = rand();\n    float _516 = rand();\n    vec3 _521 = ro;\n    vec2 _523 = _521.xy + ((vec2(_515, _516) - vec2(0.5)) * 0.2);\n    ro.x = _523.x;\n    ro.y = _523.y;\n    vec3 ta = vec3(0.0, -2.0, 0.0);\n    vec3 rd = normalize(ta - ro);\n    vec3 param = rd;\n    vec2 param_1 = uv;\n    vec3 _539 = getCam(param, param_1);\n    rd = _539;\n    vec2 param_2 = uv;\n    float _543 = truchet(param_2);\n    vec3 col = vec3(_543) * 0.0;\n    float depth = 100.0;\n    vec3 param_3 = ro;\n    vec3 param_4 = rd;\n    int param_5 = 64;\n    vec3 _555 = trace(param_3, param_4, param_5);\n    vec3 res = _555;\n    if (res.y > 0.0)\n    {\n        vec3 p = ro + (rd * res.y);\n        vec3 param_6 = p;\n        float param_7 = res.x;\n        vec3 norm = getNorm(param_6, param_7);\n        depth = res.y;\n        if (res.z == 0.0)\n        {\n            vec3 param_8 = p;\n            col = getmat(param_8);\n        }\n        if (res.z == 1.0)\n        {\n            vec3 refl = normalize(reflect(rd, norm));\n            vec3 param_9 = p + (norm * 0.01);\n            vec3 param_10 = refl;\n            int param_11 = 64;\n            vec3 _604 = trace(param_9, param_10, param_11);\n            vec3 resrefl = _604;\n            if (resrefl.y > 0.0)\n            {\n                vec3 prefl = (p + (norm * 0.01)) + (refl * resrefl.y);\n                vec3 param_12 = prefl;\n                col += getmat(param_12).zxy;\n            }\n        }\n    }\n    col = mix(col, vec3(0.18, 0.02, 0.02), vec3(1.0 - clamp(exp(0.2 * depth), 0.0, 1.0)));\n    col += accCol;\n    return col;\n}\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec2 uv = ((fragCoord.xy * 2.0) - iResolution.xy) / vec2(iResolution.xy.y);\n    _seed = texture(iChannel2, uv).x + iTime;\n    float stp = 0.05;\n    if (abs(uv.x) > 0.5)\n    {\n        uv = floor(uv / vec2(stp)) * stp;\n    }\n    vec2 param = uv;\n    vec3 _690 = rdr(param);\n    vec3 col = _690;\n    float _692 = rand();\n    float _693 = rand();\n    vec2 off = (vec2(_692, _693) - vec2(0.5)) * 0.05;\n    col = clamp(col, vec3(0.0), vec3(1.0));\n    col = mix(col, texture(iChannel1, ouv + off).xyz * 1.5, vec3(0.5));\n    out_color = vec4(col, 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "mic",
                        "id": 32,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/mic.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}