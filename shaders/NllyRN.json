{
    "Shader": {
        "info": {
            "date": "1650889208",
            "description": "A cell by cell traversal of overlapping objects.",
            "flags": 0,
            "hasliked": 0,
            "id": "NllyRN",
            "likes": 67,
            "name": "Raycasting Overlapping Objects",
            "published": 3,
            "tags": [
                "raycasting",
                "cube",
                "cell",
                "block",
                "overlap",
                "traversal"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1257
        },
        "renderpass": [
            {
                "code": "/*\n\n    Raycasting Overlapping Objects\n    ------------------------------\n    \n    Rendering inside a pixelshader environment can be challenging, and \n    in many cases, restrictive. If you've ever tried to render a grid\n    of closely packed or overlapping objects, you'll notice neighboring \n    grid cell overlap artifacts. Sometimes, you can render four cells at\n    a time to account for the overlap, but in a 3D scene, a pixel ray \n    can usually visit more cells than you can accomodate for. Traversing \n    a grid in a cell by cell manner along the line of sight can fix that\n    problem, but isn't of much use when objects overlap cell boundaries.\n    \n    In that case, you will have to perform a neighboring cell by cell \n    traversal, like this one. A cell by cell traversal with neighbor\n    checks is not ideal, but will be artifact free. This traversal only\n    accounts for four neighboring cells, so only a certain amount of \n    overlap is possible, but as you can see, you can create more \n    interesting variations when overlap is allowed. If you wanted to \n    create a more interesting cityscape, a traversal like this would give\n    you more options.\n    \n    This scene works on an extruded 2D (XZ) grid schematic, but a proper \n    3D voxel version (XYZ) is possible. In fact, Reinder has incorporated \n    just that in his \"RIOW 2.09\" scene. It's in static form, but I think\n    a realtime version would be possible.\n    \n    Rendering overlapped artifact free scenes in this manner gives the \n    user another tool to work with, but ultimately, I'd imagine more \n    sophisticated partitioning structures would be required to render \n    more sophisticated scenes.\n    \n    As for the scene itself, I made it up as I went along, so I'm not \n    really sure what it's supposed to represent, but it reminds me of \n    the final minutes of touchdown in various places I've flown to... \n    I've been to some dreary places in my time. :)\n\n\n    Other traversal rendering schemes:\n    \n    // This is a static image, but I believe it is the first example \n    // on Shadertoy involving a 3D voxel cell traversal that caters \n    // for overlapping objects (the cube of white spheres).\n    RIOW 2.09: A Scene Testing All - reinder\n    https://www.shadertoy.com/view/MtycDD\n    \n    // Fizzer has all kinds of really cool traversal examples.\n    Procedural Octree - Fizzer\n    https://www.shadertoy.com/view/3dSGDR\n    \n    // One of IQ's BVH examples. There are a few on Shadertoy, and\n    // all are worth a look.\n    Boxes traced - IQ\n    https://www.shadertoy.com/view/4tKBWy\n    \n    // Abje's stackless version, based on IQ's example.\n    many boxes - abje\n    https://www.shadertoy.com/view/wsS3Wz\n    \n    // OCB's really nice architectural sci-fi scene constructed\n    // with three variable sized grids. OCB has similar examples\n    // that are worth the look too.\n    Hope - ocb\n    https://www.shadertoy.com/view/MllfDX\n\n*/\n\n\n#define FAR 25.\n \n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// IQ's vec2 to vec2 hash.\nvec2 hash22(vec2 p) {\n    \n    return fract(sin(vec2(dot(p, vec2(12.783, 78.137)), dot(p, vec2(41.581, 57.263))))\n                          *vec2(43758.5453, 23421.6361));\n}\n\n// Rectangle scale. Smaller scales mean smaller squares, thus more of\n// them. Sometimes, people (including myself) will confuse matters\n// and use the inverse number. :)\nvec2 s = vec2(1, 1)/4.; \n\n // Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec2 ro, vec2 rd, vec2 p, vec2 n){\n   \n   // This it trimmed down, and can be trimmed down more. Note that \n   // \"1./dot(rd, n)\" can be precalculated outside the loop. However,\n   // this isn't a GPU intensive example, so it doesn't matter here.\n   return dot(p - ro, n)/dot(rd, n);\n\n}\n\n// Grid cell function.\nvec2 gridID(vec2 p){\n    // Using the rectangle's center position for the ID. \n    return floor(p/s) + .5;\n\n}\n\n\nfloat hm(vec2 p){\n\n    // Only one texture read.\n    vec3 tx = texture(iChannel0, p/iChannelResolution[0].xy*24.).xyz;  tx *= tx;\n    // Greyscale height. Using \"tx.x\" would work, too.\n\tfloat f = dot(tx, vec3(.299, .587, .114));\n    float f2 = f; \n    \n    return f*1.8;//min(f*2., 1.8);//max(f*2. - .075, 0.);//*12. + f2*4.;\n\n}\n\n// IQ's box routine.\n// https://iquilezles.org/articles/boxfunctions\nvec4 iBox( in vec3 ro, in vec3 invRd, in vec3 dim){ \n\n\t// Ray-box intersection.\n    vec3 n = ro*invRd;\n    vec3 k = abs(invRd)*dim;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max(max(t1.x, t1.y ), t1.z);\n\tfloat tF = min(min(t2.x, t2.y ), t2.z);\n\t\n\tif( tN>tF || tF<0.) return vec4(1e8);\n\n\t//vec3 nor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\treturn vec4(tN, t1);\n}\n\nvec3 gN;\nfloat gObjID;\n\nvec2 gDist;\n\nvec4 raycast(vec3 ro, vec3 rd, int iters){\n   \n    vec4 res = vec4(FAR, 0, 0, 0);\n    \n    vec3 invRd = 1./rd;\n    \n    gObjID = -1.;\n    \n    \n    // Rectangle normals: Any two will do. By the way, there's nothing\n    // stopping you from declaring all four normals for all surrounding\n    // walls, but since you know only two will be in front of the\n    // direction ray at any given time, it makes sense to only choose\n    // two.\n    //\n    // Declare two normals. Any side by side ones will do.\n    vec2 n1 = vec2(-1, 0), n2 = vec2(0, -1); // Right and top edges.\n    \n    // If the cell wall is behind the ray (or the ray is facing the opposing cell\n    // wall, if you prefer), use the normal index from the back cell wall. This \n    // trick is possible because of the rectangle symmetry. As an aside, for \n    // anyone who doesn't know, dotting the direction ray with the face normal \n    // is something you do in software engines for back face culling.\n    n1 = dot(rd.xz, n1)<0.? -n1 : n1;\n    n2 = dot(rd.xz, n2)<0.? -n2 : n2;\n    \n    // Initiate the ray position at the ray origin.\n    vec3 pos = ro;\n    \n    // Obtain the coordinates of the cell that the current ray position \n    // is contained in -- I've arranged for the cell coordinates to \n    // represent the cell center to make things easier.\n    vec2 ip = gridID(pos.xz);\n    \n    vec2 gIP = ip;\n    \n    float t1 = 1e8, t2 = 1e8, tT = 1e8;\n    \n    float floorDist = (0. - ro.y)/rd.y;\n    \n    int hit = 0;\n    \n    gDist = vec2(1e8);\n    \n    gDist.y = floorDist;\n    \n    vec4 t44 = vec4(FAR);\n    \n    //vec3 ip0 = vec3(ip.x*s.x, pos.y, ip.y*s.y);\n   float d = 1e8;\n    // Iterate through 24 cells -- Obviously, if the cells were smaller,\n    // you'd need more to cover the distance.\n    for(int i = 0; i<iters; i++){ \n    \n        // If we've hit the ocean plane, return immediately.\n        if (pos.y<0.){ gN = vec3(0, 1, 0); gObjID = 0.; return vec4(floorDist, vec3(0)); }\n\n         \n        vec2 svIP;\n        //d = 1e8;\n        t1 = rayLine(pos.xz, rd.xz, (ip + n1*.5)*s, -n1);\n        t2 = rayLine(pos.xz, rd.xz, (ip + n2*.5)*s, -n2);\n        \n        // This example doesn't differ much from a simple cell by cell traversal.\n        // The difference is the neighbor check. \n        float gMa;\n        // Checking four cells to cater for overlap, instead of the usual one only.\n        for(int j = 0; j<4; j++){ \n         \n            // Standard 2x2 neighbor check.\n            vec2 offs = vec2(j&1, j>>1) - .5;\n            vec2 ipJ = floor(ip - offs) + .5;\n            \n            // Height.\n            float ma = hm(ipJ*s);\n            // Skipping blocks below a certain height to make a clear water line distinction.\n            if(ma<1./20.) continue; \n\n            // At this point, we haven't advanced the ray to the back of the cell boundary,\n            // so we're at one of the front cell face positions. Therefore, check to see if \n            // we're under the pylon height. If so, we've hit a face, so mark the face as hit, \n            // then break.\n\n            vec2 w = hash22(ipJ + .21)*.8 + .05;//(min(ma, 1.)*.7 + .3) + .1;// - .02;\n                \n            t44 = iBox(ro - vec3(ipJ.x*s.x, ma/2., ipJ.y*s.y), invRd, vec3(s.x*w.x, ma/2., s.y*w.y));\n\n            // Nearest of the four boxes.\n            if(t44.x<d && (t44.x<length(pos - ro) + min(t1, t2))){\n\n                d = t44.x;\n                gN = t44.yzw;\n                gN = -sign(rd)*step(gN.yzx, gN)*step(gN.zxy, gN);\n                svIP = ipJ;\n                gMa = ma;\n   \n            }\n        \n        }\n       \n \n        gDist.x = d; \n     \n        // We've hit a box, so return.\n        if(d<FAR) { hit = 1; gObjID = 1.; return vec4(d, 0, svIP); }\n\n        // Determine the closest edge then record the closest distance and\n        // asign its normal index.\n        vec3 tn = t1<t2? vec3(t1, n1) : vec3(t2, n2);\n\n        \n        // Advance the cell index position by the indices of the \n        // cell wall normal that you hit. \n        ip += tn.yz;\n        // Advance the ray position by the distance to the next cell wall.\n        pos += rd*tn.x;\n    \n    }\n    \n    \n  /*  \n    float fID = tT<t1 && tT<t2? 0. : t1<t2? 1. : 2.;\n    if(fID == 1.){ fID = dot(rd.xz, vec2(-1, 0))<0.? -fID : fID; }\n    else if(fID == 2.){ fID = dot(rd.xz, vec2(0, -1))<0.? -fID : fID; }\n    \n    \n    \n    res.x = length(pos - ro);*/\n    \n    // Top face distance.\n    //float tB = (.0 - ro.y)/rd.y;\n    //if (tB>=0.){ gN = vec3(0, 1, 0); gObjID = 0.; return vec4(tB, 0, vec2(0)); }\n \n    // No hit, so return the far plane.\n    if(hit == 0) res.x = FAR;\n    \n    float fID = -1.;\n    return vec4(res.x, fID, ip);\n    \n}\n\n// Standard normal function.\nvec3 nr(float fID, vec3 rd) {\n\t\n    vec3 n = fID == 0.? vec3(0, 1, 0) : abs(fID) == 1.? vec3(1, 0, 0) : vec3(0, 0, 1);\n    n *= fID<-.001? -1. : 1.; \n\treturn n;\n}\n\n///////\n\nfloat surface(vec3 p){\n\n    // Very cheap sinusoidal water effect.\n    vec3 q = p*3.;\n    float t = iTime;\n    float wat = dot(sin(q + vec3(t*.75, 0, 0) - cos(q.yzx*2. - vec3(0, t, 0))*2.), vec3(.333));\n    q.xy *= rot2(3.14159/4.)*2.;\n    float wat2 = dot(sin(q + vec3(t*.75*2., 0, 0) - cos(q.yzx*2. - vec3(0, t*2., 0))*2.), vec3(.333));\n    wat = mix(wat, wat2, 1./3.);\n    \n    // For anyone not familiar, abs(x*x + a) is a smooth absolute function trick.\n    // In this case, it's used to subtly smooth off the crests of the waves.\n    return 1. - sqrt(wat*wat*.98 + .02);\n}\n\nfloat bObjID;\n// Surface bump function..\nfloat bumpSurf3D(in vec3 p, in vec3 n){\n    \n    // Water surface bump map only.\n    return surface(p);\n    \n    /*\n    // Water surface bump map.\n    if(bObjID<.5) return surface(p);\n    else {\n        // More subtle texture based bump mapping on the blocks.\n        vec2 uv = abs(n.y) > .5? p.xz : abs(n.x)>.5 ? p.zy : p.xy;\n        vec3 tx = texture(iChannel1, uv).xyz; tx *= tx;\n        return dot(tx, vec3(.299, .587, .114));\n    }\n    */\n}\n\n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(.001, 0); \n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    float ref = bumpSurf3D(p, n);\n    \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, n),\n                      bumpSurf3D(p - e.yxy, n),\n                      bumpSurf3D(p - e.yyx, n)) - ref)/e.x; \n   \n    \n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    //vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n    //                 bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n    //                 bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    \n  \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= n*dot(n, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(n + grad*bumpfactor);\n\t\n}\n///////\n\nvoid mainImage( out vec4 c, vec2 u )\n{\n    \n    // Unit direction vector, camera (moving along Z), and point light (above the camera).\n    // A \"to\" and \"from\" camera system is better, and only requires a few more lines, but\n    // we're keeping things simple.\n    vec3 r = normalize(vec3(u - iResolution.xy*.5, iResolution.y*2.5)), \n         o = vec3(iTime, 2, iTime*.25), l = o + vec3(-1, 4, 12);\n    \n    \n    \n    // Rotating the unit direction ray, for a bit of visual interest.\n    r.xz = rot2(.5)*r.xz;\n    r.xy = rot2(.1)*r.xy;\n    r.yz = rot2(-.25)*r.yz;\n\n    // Raycasting\n    vec4 res = raycast(o, r, 160);\n    \n     \n    float t = res.x; // Ray distance.\n    float fID = res.y; // Face ID.\n    vec2 id = res.zw; // Block position ID.\n    \n    float objID = gObjID; // Scene object ID: Blocks or water.\n    bObjID = gObjID; // Bump object ID: Something I've hacked in at the last minute. \n    \n    // Object height.\n    float h = hm(id*s);\n    \n    t = min(t, FAR); // Clipping to the far distance, which helps avoid artifacts.\n    \n    // Scene color, initialized to zero.\n    c = vec4(0);\n    \n    // If we've hit an object, light it up.\n    if(t<FAR){\n    \n        // Hit position and normal.\n        vec3 p = o + r*t, n = gN;//nr(fID, r);\n \n        if(objID<.5) n = doBumpMap(p, n, .01);\n\n        // Point light.\n        //l -= p; // Light to surface vector. Ie: Light direction vector.\n        //float d = max(length(l), 0.001); // Light to surface distance.\n        //l /= d; // Normalizing the light direction vector.\n        \n        // Directional light.\n        l = normalize(vec3(-.8, .25, .9)); \n        \n        // Diffuse.\n        float dif = max(dot(l, n), 0.);\n        \n        // Shadows.\n        float sh = 0.;\n        if(dif>0.){\n           vec4 resSh = raycast(p + n*.002, l, 64);\n           \n           if(resSh.x>FAR - 1e-3) sh = 1.; //\n           //if(resSh.x>d - 1e-3) sh = 1.; // Point light.\n           \n        }\n         \n         \n\n        // Scene object color.\n        //\n        // UV coordinates.\n        //vec2 uv = fID == 0.? p.xz : abs(fID) == 1.? p.zy : p.xy;\n        vec2 uv = abs(n.y) > .5? p.xz : abs(n.x)>.5 ? p.zy : p.xy;\n        //\n        // Texture color.\n        vec3 tx = texture(iChannel1, rot2(3.14159/1.)*uv/2.).xyz; tx *= tx;\n        vec3 tx2 = texture(iChannel1, rot2(-3.14159/1.)*uv/1. + .5).xyz; tx2 *= tx2;\n        tx = mix(tx, tx2, .5);\n        //\n        c.xyz = .05 + tx*1.5;\n        \n        // Random Earth tone coloring.\n        vec3 bCol = .65 + .3*cos(6.2831*hash21(id + .04)/3. + vec3(0, 1, 2) - .5);\n        //vec3 bCol = .65 + .3*cos(6.2831*id.y*s.y/8. + vec3(0, 1, 2)*1.5 - 1.);\n        c.xyz *= bCol*1.5;\n        // Applying a little river weathering to the blocks -- Obviously more\n        // to the surfaces that are closer to the water level.\n        const vec3 wCol = vec3(.7, 1, .9);\n        c.xyz *= mix(vec3(1), wCol*1.1, tx*clamp(1. - p.y/h, 0., 1.));//\n\n        \n        vec3 c2 = wCol*(tx*.5 + .5);\n   \n        if(objID<.5) c.xyz = c2;\n       \n\n       \n        // Fake water level shore line AO. I'll look for a better way, but\n        // this is cheap and it works well enough for this example.\n        if(p.y<.1){//objID<.5\n       \n           // Raytrace just above water level for a few cells in the direction of \n           // the unit ray, and if you hit a block, you're near enough to it to\n           // be occluded... That's my story and I'm sticking to it. :D\n           vec4 resR = raycast(p + n*.002, normalize(vec3(r.x, 0, r.z)), 8);\n           resR.x = max(resR.x - .15, p.y-.05);\n           \n           c.xyz = mix(c.xyz, c2/2., 1. - smoothstep(-.1, .1, resR.x));// - .25\n       \n        }\n        \n        // IQ's rim lighting snippet: For anyone not familiar, he's using \n        // the Fresnel factor for some sillouette lighting.\n        float rim = pow(clamp(1. + dot(r, n), 0., 1.), 5.);\n        \n         \n        // Specular reflection. \n        //float spe = pow(clamp(dot(l, reflect(r, n)), 0., 1.), 8.);\n        float spe = pow(clamp(dot(reflect(l, n), r), 0., 1.), 8.);\n        \n       \n        // AO routine. Hacked together from one of IQ's old routines.\n        // I started this example a while ago, so I don't think it's\n        // complete. I'll need to take a proper look later.\n        vec2 p2 = (p.xz - id*s);\n        float h0 = hm(id*s);\n        float py = (1. - smoothstep(0., 1., -p.y + h0));\n        vec4 h4 = vec4(hm((id + vec2(-1, 0))*s), hm((id + vec2(1, 0))*s), \n                       hm((id + vec2(0, -1))*s), hm((id + vec2(0, 1))*s));\n                       \n        vec4 h4mh0 = h4 - h0;\n        \n        float ao = 1.;\n        float minEdge = min(s.x, s.y)/4.;\n        float edge = s.y/4.;\n        float edge2 = s.x/4.;\n        \n        float aoSh = .5;\n        if(n.y>.5){\n            if(p2.y>minEdge && h4mh0.w>0.) ao = min(ao, 1. - smoothstep(0., 1., (p2.y - edge)/edge)*aoSh);\n            if(p2.y<-minEdge && h4mh0.z>0.) ao = min(ao, 1. - smoothstep(0., 1., (-p2.y - edge)/edge)*aoSh);\n            if(p2.x<-minEdge && h4mh0.x>0.) ao = min(ao, 1. - smoothstep(0., 1., (-p2.x - edge2)/edge2)*aoSh);\n            if(p2.x>minEdge && h4mh0.y>0.) ao = min(ao, 1. - smoothstep(0., 1., (p2.x - edge2)/edge2)*aoSh);\n        }\n        else {\n            \n            vec4 mEdge4 = vec4(minEdge) - (h4 - h0)/2.;\n            vec4 hp = p.y - h4 - mEdge4;\n            \n            if(n.z<-.5 && hp.z<0.) ao = min(ao, 1. - smoothstep(0., 1., -(hp.z)/(mEdge4.z))*aoSh);\n            if(n.z>.5  && hp.w<0.) ao = min(ao, 1. - smoothstep(0., 1., -(hp.w)/(mEdge4.w))*aoSh);\n            if(n.x<-.5 && hp.x<0.) ao = min(ao, 1. - smoothstep(0., 1., -(hp.x)/(mEdge4.x))*aoSh);\n            if(n.x>.5 && hp.y<0.) ao = min(ao, 1. - smoothstep(0., 1., -(hp.y)/(mEdge4.y))*aoSh);\n             \n        }\n        ao = max(ao, 0.);\n       \n        \n        //////////////////\n\n        // Last minute edge routine. I've returned the nearest rectangle ID\n        // and dimensions from the \"raycasting\" routine, and the rest \n        // figures itself out.\n        vec2 ipJ = id;\n        float ma = h0;\n        vec2 w = (hash22(ipJ + .21)*.8 + .05)*s;\n        p2 = (p.xz - id*s); // Local coordinates.\n        float rct = abs(max(abs(p2.x) - w.x, abs(p2.y) - w.y));\n        float topEdge = max(abs(p.y - ma), rct);\n        float sideEdge = abs(abs(p2.x) - w.x);\n        sideEdge = max(sideEdge, abs(abs(p2.y) - w.y));\n        float objEdge = min(topEdge, sideEdge) - .006;\n\n        // Rendering light and dark edges.\n        //c.xyz = mix(c.xyz, vec3(0), 1. - smoothstep(0., 2./iResolution.y, length(p2) - .02));\n        c.xyz = mix(c.xyz, c.xyz*1.5, 1. - smoothstep(0., 2./iResolution.y, objEdge - .006));\n        c.xyz = mix(c.xyz, c.xyz/1.5/2., 1. - smoothstep(0., 2./iResolution.y, objEdge));\n\n        ///////////////////// \n        \n        // Applying diffuse lighting, ambient lighting, and attenuation.\n        c.xyz = c.xyz*(dif*sh + vec3(1, .2, .1)*spe*sh*4. + vec3(.5, .7, 1).zyx*rim*1. + .25);\n        \n        // Applying ambient occlusion.\n        c.xyz *= ao;\n  \n        // Reflections: It's based on one of IQ's nice looking reflective\n        // pass shortcuts. Not quite as realistic as proper object and sky coloring,\n        // but really effective for scenarios like these.\n        vec3 ref = reflect(r, n);\n        vec4 resRef = raycast(p + n*.001, ref, 64); // Note the fewer iterations.\n        vec3 refTx = texture(iChannel3, ref).xyz; refTx *= refTx;\n        if(resRef.x<FAR - 1e-3) refTx *= 0.;\n        // Fresnel reflection.\n        float fr = mix(.03, .25, pow(max(0., 1. + dot(r, n)), 3.));\n        if(objID<.5) refTx *= 2.; // More reflection on the water.\n        c.xyz = mix(c.xyz, refTx, fr);\n        // Alternate reflections. Gives it a cartoonish look.\n        //c.xyz += c.xyz*refTx*2.;  \n        \n    }\n    \n    // Applying horizon fog.\n    c = mix(clamp(c, 0., 1.), vec4(.87, .95, .95, 0), smoothstep(0., .99, t*t/FAR/FAR));\n    \n    // Subtle vignette.\n    u /= iResolution.xy;\n    c *= pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .0625);\n    \n    // Very subtle tone mapping, which can sometimes even things out.\n    //c *= 1.1/(1. + c*.2);\n    \n    // Rough gamma correction. The short explanation is that that if you don't do\n    // this, all your colors and shades will be wrong. :)\n    c = vec4(sqrt(clamp(c.xyz, 0., 1.)), 1.);\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}