{
    "Shader": {
        "info": {
            "date": "1703236572",
            "description": "raymarching\nglow + motionblur + aberration + text",
            "flags": 0,
            "hasliked": 0,
            "id": "lflGRS",
            "likes": 67,
            "name": "Emissive Ikura",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "amagitakayosi",
            "viewed": 4180
        },
        "renderpass": [
            {
                "code": "// global vars\nfloat light = 999.;\nfloat dark = 1.;\nfloat roty = 0.;\nfloat time;\nfloat mode;\nfloat modetime;\n\nmat2 rot(float t) {\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec2 map(vec3 p) {\n    p.xz *= rot(roty);\n    \n    float d1, d2;\n    d1 = d2 = 999.;    \n    \n    // White cells\n    for (int i = 0; i < 7; i++) {\n        float fi = float(i) * 0.8+ time * 0.3;\n        vec3 pp = p + vec3(\n            cos(fi* 1.7),\n            sin(fi * 2.3),\n            sin(fi * 1.9)\n        ) * 1.3;\n        pp.xz *= rot(fi * 0.1);\n        pp.xy *= rot(fi * -0.4);\n        pp *= 1. + sin(fi * 3.) * 0.1;\n        d1 = min(d1, sdSphere(pp, 1.3));\n    }\n\n    // Ikura\n    vec3 p2 = p * 2.;   \n    vec3 p3 = p2.yxz;       \n\n    p2 = abs(p2);\n    p2 -= vec3(2,0,0);        \n    d2 = min(d2, sdSphere(p2, 1.));\n\n    p3.xy *= rot(time * .7);\n    p3 = abs(p3);        \n    p3 -= vec3(2, 1, 2);\n    d2 = min(d2, sdSphere(p3, 1.));               \n\n    // Save ikura dist as light power\n    light = d2;\n\n    return d1 < d2 ? vec2(d1, 1) : vec2(d2, 2);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 d = vec2(0, 0.001);\n    return normalize(vec3(\n        (map(p + d.yxx) - map(p - d.yxx)).x,\n        (map(p + d.xyx) - map(p - d.xyx)).x,\n        (map(p + d.xxy) - map(p - d.xxy)).x\n    ));\n}\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(49., 489.))) * 39284.);\n}\n\nfloat char(vec2 uv, float i, vec2 offset) {\n    uv += offset;\n    uv = (uv - .5) * 2. + .5;\n    uv = clamp(uv, 0., 1.);\n    \n    float x = mod(i, 16.);\n    float y = 15. - floor(i / 16.);    \n    vec4 char = texture(iChannel0, (uv + vec2(x, y)) / 16.);\n    return 1. - char.a;\n}\n\nfloat text(vec2 p, bool isEdge) {\n    vec2 uv = p * 0.5 * vec2(1, 2.2) + 0.5;    \n\n    // Joint \"C\" and \"T\"\n    uv.x = max(min(uv.x, .34), min(uv.x, step(.675, uv.x) * uv.x));\n        \n    float c = 0.;\n    c = max(c, char(uv, 82., vec2(0.7, 0)));\n    c = max(c, char(uv, 69., vec2(0.51, 0)));\n    c = max(c, char(uv, 65., vec2(0.34, 0)));\n    c = max(c, char(uv, 67., vec2(0.19, 0)));\n    c = max(c, char(uv * .97, 84., vec2(-.18, 0.016))); // Adjust \"T\"\n    c = max(c, char(uv, 73., vec2(-.35, 0)));\n    c = max(c, char(uv, 79., vec2(-.5, 0)));\n    c = max(c, char(uv, 78., vec2(-.7, 0)));\n\n    return isEdge\n        ? smoothstep(.01, 0., abs(c - .5))\n        : smoothstep(.5, .52, c);\n}\n\nvec3 raymarch(in vec2 p, vec3 ro, vec3 rd) {\n    float l = length(p);\n\n    vec3 rp;\n    float t;\n    vec2 hit;\n    float iter;\n\n    vec3 col;            \n\n    // keep the iteration count low; I love the artifact\n    for (int i = 0; i < 30; i++) {\n        iter = float(i);    \n        rp = ro + rd * t;\n\n        hit = map(rp);\n        if (hit.x < 0.03) {\n            break;\n        } else if (t > 30.) {\n            hit = vec2(0);\n        }\n        \n        t += hit.x * 0.5;\n    }\n\n    vec3 ld = normalize(vec3(1, 1, 0));\n    ld.xz *= rot(-roty);\n\n    // Cheap AO with dither\n    float ao = pow(iter, .8);\n    ao *= (0.8 + 0.2 * hash(p + iTime));\n\n    vec3 n = normalize(getNormal(rp) + vec3(0, 0, hash(p * 0.2 + iTime) * 0.03));\n    if (hit.y == 1.) {                                   \n        // diffuse\n        float dif = clamp(dot(n, ld), 0., 1.) * .2;\n        float amb = 0.8;\n        col += vec3(.92, .9, .99) * (dif+amb);\n\n        // specular\n        vec3 hv = normalize(ld - rd);                \n        col += pow(clamp(dot(n,hv),0.,1.), 88.0) * 0.2;\n        \n        // reflection\n        col *= mix(vec3(1), texture(iChannel1, n).rgb * 3., .07); \n        \n        col += pow(.2 / light, 0.8) * vec3(1., .3, 0); // glow\n        col -= 0.01 * ao;\n        \n        col *= smoothstep(-8., 0.7, rp.y); // vertical shadow\n    } else if (hit.y == 2.) {     \n        // diffuse\n        float fre = pow(1. - clamp(dot(-rd, n), 0., 1.), 1.);        \n        col += pow(fre, 3.) * 7.; \n        \n        // specular\n        vec3 hv = normalize(ld - rd);                \n        col += pow(clamp(dot(n,hv),0.,1.),99.0) * 0.9; \n\n        // reflection\n        col *= mix(vec3(1), texture(iChannel1, n).rgb * 2., .9);        \n\n        // glow\n        fre = pow(1. - clamp(dot(-rd, n), 0., 1.), 8.);\n        col += mix(vec3(3., 2., 0), vec3(.2, .0, .0), fre) * 0.8;\n        col -= 0.2 * ao;\n    } else {    \n        // BG\n        col = cos(l * 1.2 - 1.2) * vec3(.94, .99, 1.) * 0.9;\n        \n        // Text animation\n        if (mode == 1. || mode == 3.) {                    \n            bool isEdge = mode > 2.;\n            float y = 0.3;\n            for (int i = 0; i < 6; i++) {\n                float fi = float(i);\n                col -= text(p + vec2(0, -.75 + float(i) * y), isEdge) * 0.7 \n                    * step(fi * .1 + .3, modetime) * step(modetime, fi * .1 + 1.3);\n                col += text(p + vec2(0, -.75 + float(i) * y), isEdge) * 0.7 \n                    * step(fi * .1 + 2., modetime) * step(modetime, fi * .1 + 3.);\n            }\n        }\n    }   \n\n    return col;\n}\n\nfloat spin(float x, float div, float slope) {\n    return (1. - exp(mod(x, div) * -3.) + floor(x / div) + x / slope);\n}\n\n#define PHASE_1 0.5\n#define PHASE_2 4.0\n#define PHASE_12 4.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n\n    time = iTime;\n    \n    // motion blur\n    float motion = exp(mod((time - PHASE_1), PHASE_12)* -2.);\n    time += motion * hash(p * vec2(.000003, 20.)) * 0.02;\n    \n    // Update global variables\n    roty = spin(time - PHASE_1, PHASE_12, 16.) * 18.;           \n    mode = mod(floor(time / PHASE_12) + floor((time - PHASE_1) / PHASE_12) + 1., 4.);\n    modetime = min(mod(time, PHASE_12), mod(time - PHASE_1, PHASE_12));\n\n    float l = length(p);\n\n    // Change camera zoom by mode\n    float zoom = 1.0;    \n    if (mode == 0.) { zoom = 3.0; }\n    else if (mode == 1.) { zoom = 1.2; }\n    else if (mode == 2.) { zoom = 2.1; p *= rot(.78); }\n    else { zoom = 1.1; }    \n\n    vec3 ro = vec3(0, 0, 5);\n    vec3 rd = normalize(vec3(p, -zoom + 0.2 * pow(l, 2.)));        \n\n    vec3 col;\n    \n    // Aberration    \n    col.r += raymarch(p, ro, rd).r;\n    col.g += raymarch(p*.99, ro, rd).g;\n    col.b += raymarch(p*.98, ro, rd).b;    \n    \n    // Overlay text\n    if (mode == 0.) {\n        col.rgb += text(p, true) * step(0., sin(time * 50.));\n    }\n    if (mode == 2.) {        \n        col.rgb -= text(abs(uv * 2. - 1.) * vec2(3, 2) - 1., false) * sin(time * 50.);\n        col.rgb = 1. - col.grb; // Invert\n    }    \n\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}