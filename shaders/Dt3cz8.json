{
    "Shader": {
        "info": {
            "date": "1698864325",
            "description": "Something I made. No multisample antialiasing!\nChange scene scale in Common if it's too slow\nHas day night cycle",
            "flags": 32,
            "hasliked": 0,
            "id": "Dt3cz8",
            "likes": 9,
            "name": "Aerial View",
            "published": 3,
            "tags": [
                "voronoi",
                "noise",
                "simple",
                "clouds",
                "fbm",
                "antialiasing",
                "aa",
                "stylized",
                "fwidth",
                "land"
            ],
            "usePreview": 0,
            "username": "fishy",
            "viewed": 224
        },
        "renderpass": [
            {
                "code": "vec4 cubic(float v){\n    vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n    vec4 s = n * n * n;\n    float x = s.x;\n    float y = s.y - 4.0 * s.x;\n    float z = s.z - 4.0 * s.y + 6.0 * s.x;\n    float w = 6.0 - x - y - z;\n    return vec4(x, y, z, w) * (1.0/6.0);\n}\n\nvec4 textureBc(sampler2D sampler, vec2 texCoords, int lod){\n\n   vec2 texSize = vec2(textureSize(sampler, lod));\n   vec2 invTexSize = 1.0 / texSize;\n   \n   texCoords = texCoords * texSize - 0.5;\n\n   \n    vec2 fxy = fract(texCoords);\n    texCoords -= fxy;\n\n    vec4 xcubic = cubic(fxy.x);\n    vec4 ycubic = cubic(fxy.y);\n\n    vec4 c = texCoords.xxyy + vec2 (-0.5, +1.5).xyxy;\n    \n    vec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);\n    vec4 offset = c + vec4 (xcubic.yw, ycubic.yw) / s;\n    \n    offset *= invTexSize.xxyy;\n    \n    vec4 sample0 = textureLod(sampler, offset.xz, float(lod));\n    vec4 sample1 = textureLod(sampler, offset.yz, float(lod));\n    vec4 sample2 = textureLod(sampler, offset.xw, float(lod));\n    vec4 sample3 = textureLod(sampler, offset.yw, float(lod));\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix(mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = textureBc(iChannel0, fragCoord/iResolution.xy*RES_SCALE, 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define iTime iDate.w\n//#define iDate vec4(iTime)\n\n#define PI 3.1415926535\n#define TAU (2.0*PI)\n\n#define sstep(a, b, x) smoothstep(a-b, a+b, x)\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat voronoi( in vec2 x, float t, float w )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n\tfloat m = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2(float(i), float(j));\n        vec2 o = hash22(n + g);\n        o = 0.5 + 0.5*sin(t + 6.2831*o);\n\t\tfloat d = length(g - f + o);\n\t\tfloat h = smoothstep(-1.0, 1.0, (m-d)/w);\n\t    m   = mix(m, d, h) - h*(1.0-h)*w/(1.0+3.0*w);\n    }\n\t\n\treturn m;\n}\n\nfloat noise(vec3 p)\n{\n    vec2 o = vec2(0, 1);\n    vec3 a = floor(p);\n    \n    vec3 i = fract(p);\n    i = 3.0*i*i-2.0*i*i*i;\n    float x, y;\n    \n    float xtl = hash13(a + o.xyx);\n    float xbl = hash13(a + o.xxx);\n    float xtr = hash13(a + o.yyx);\n    float xbr = hash13(a + o.yxx);\n    x = mix(mix(xbl, xtl, i.y), mix(xbr, xtr, i.y), i.x);\n    \n    float ytl = hash13(a + o.xyy);\n    float ybl = hash13(a + o.xxy);\n    float ytr = hash13(a + o.yyy);\n    float ybr = hash13(a + o.yxy);\n    y = mix(mix(ybl, ytl, i.y), mix(ybr, ytr, i.y), i.x);\n    \n    return mix(x, y, i.z);\n}\n\n#define fbm2(uv, func) (func(uv+10.0)*0.5+func(uv*2.0+10.0)*0.25)\n#define fbm4(uv, func) (fbm2(uv, func)+func(uv*4.0+10.0)*0.125+func(uv*8.0+10.0)*0.0625)\n#define fbm8(uv, func) (fbm4(uv, func)+func(uv*16.0+10.0)/16.0+func(uv*32.0+10.0)/32.0+func(uv*64.0+10.0)/64.0+func(uv*128.0+10.0)/128.0)\n\n#define OCEAN_COLOR vec3(0.3, 0.4, 0.8)\n#define SAND_COLOR vec3(0.9,0.75,0.4)\n#define LAND_COLOR vec3(0.2, 0.8, 0.3)\n#define SNOW_COLOR vec3(0.9, 0.9, 1.0)\n#define CLOUDS_COLOR vec3(1, 1, 1)\n\n#define srgb3(c) pow(c, vec3(2.2))\n\nconst vec4[] layers = vec4[] (\n                            vec4(srgb3(OCEAN_COLOR), 0.6),\n                            vec4(srgb3(SAND_COLOR) , 0.62),\n                            vec4(srgb3(LAND_COLOR) , 0.75),\n                            vec4(srgb3(SNOW_COLOR) , 1.0)\n                          );\n\nvec4 renderClouds(vec2 uv)\n{\n    vec2 vpos = uv*6.0+iTime*vec2(0.1, 0.000);\n    float v = voronoi(vpos, iTime*0.4, 1.0);\n    float n = fbm2(vec3(uv*2.0+30.0+iTime*vec2(0.1, 0.003), iTime*0.1), noise);\n    n = sstep(0.4+sin(iTime*0.01)*0.1, 0.2, n);\n    v = n-v;\n    v = smoothstep(0.0, fwidth(v), v);\n    return vec4(CLOUDS_COLOR, 1)*v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord /= RES_SCALE;\n    if(any(greaterThan(fragCoord, iResolution.xy)))\n    {\n        fragColor = vec4(0);\n    }\n    else\n    {\n        vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n        vec2 mo = (iMouse.xy*2.0-iResolution.xy)/iResolution.y;\n        uv += iTime*vec2(0.1, 0.003);\n        vec4 land, clouds;\n        float sunAngle = fract(iDate.w/86400.0-0.325)*TAU;\n        float sunGrad = max(0.0,sin(sunAngle));\n\n        clouds = renderClouds(uv);\n        float cloudsShadow = renderClouds(uv-vec2(0.1*tan(sunAngle-PI*0.5), 0)).a*0.75;\n        cloudsShadow *= pow(sunGrad, 0.2);\n\n        float n = fbm4(vec3(uv*2.0, 0), noise);\n        land = vec4(layers[0].rgb, 1);\n        for(int i = 1; i < layers.length(); i++)\n        {\n            land.rgb = mix(land.rgb, layers[i].rgb, smoothstep(n+fwidth(n), n, layers[i-1].w));\n        }\n\n        fragColor.a = 1.0;\n        fragColor = land;\n        fragColor.rgb *= 1.0-cloudsShadow;\n        fragColor.rgb = mix(fragColor.rgb, clouds.rgb, clouds.a);\n        fragColor.rgb *= 1.01-pow(vec3(pow(1.0-sunGrad, 2.0)), vec3(6.0, 4.0, 3.0));\n        fragColor.rgb = pow(fragColor.rgb, vec3(0.4545));\n        fragColor = mix(texture(iChannel0, (fragCoord*RES_SCALE)/iResolution.xy), fragColor, 0.5);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define RES_SCALE 1.0",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}