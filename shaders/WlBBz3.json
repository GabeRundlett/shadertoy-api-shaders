{
    "Shader": {
        "info": {
            "date": "1599427121",
            "description": "Some minimalist/bauhaus stuff.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "WlBBz3",
            "likes": 15,
            "name": "Day 260",
            "published": 3,
            "tags": [
                "paint",
                "watercolor",
                "watercolour",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 599
        },
        "renderpass": [
            {
                "code": "// Fork of \"Day 260 - LOGO DRAFT 1\" by jeyko. https://shadertoy.com/view/ttjBRV\n// 2020-09-06 20:56:55\n\n// Fork of \"Day 259\" by jeyko. https://shadertoy.com/view/tlBBRK\n// 2020-09-06 09:18:13\n\n// Fork of \"Day 258\" by jeyko. https://shadertoy.com/view/tl2fRG\n// 2020-09-05 10:41:09\n\n\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n\nfloat df = 0.;\n\n// ----------\n\n\nvec2 guv;\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode){\n    //float dea = smoothstep(df,0.,da );\n    float deb = smoothstep(df,0.,db );\n    \n    //vec3 oa = mix(vec3(0),ca,dea);\n    vec3 ob = mix(vec3(0),cb,deb);\n    vec3 co = vec3(0);\n    \n    vec4 t = texture(iChannel2,guv);\n    \n    cb*=1. - smoothstep(1.,0.,abs(db)*7. + t.z*1.53)*0.2;\n    \n    \n    if(mode == 0){\n    \t\n        // 0 replace\n        \n    \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77), 4.25), 0.));\n    \t//co = mix( oa, cb, deb);\n\n    } else if(mode == 1){\n    \t\n        // 1 multiply\n    \n        co = mix(ca, ca*cb, deb);\n    } else if(mode == 2){\n    \t\n        // 2 overlay\n        \n        if (length(ca) < 0.5){\n    \t\tco = mix(ca, 2.*ca*cb, deb);    \t\n        } else {\n    \t\tco = mix(ca, 1. - 2.*(1. - ca)*(1. - cb), deb);\n        \n        }\n    } else if(mode == 3){\n    \t\n        // 3 darken\n        \n    \tco = mix(ca, min(ca,cb)*length(ca /* cb */), deb);\n    } else if(mode == 4){\n    \t\n        // 4 burn\n        \n    \tco = mix(ca, clamp(1.0 - (1.0 - ca) / cb,0.,1.), deb);\n    } else if(mode == 5){\n    \t\n        // 5 linear burn\n        \n    \tco = mix(ca, ca + cb - 1., deb);\n    } else if(mode == 6){\n    \t\n        // 6 color dodge\n        \n    \tco = mix(ca, length(ca) > .5 ? 1.0 - 2.0 * (1.0 - ca) * (1.0 - cb) : 2.0 * ca * cb, deb);\n    }\n        \n    return co;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    df = dFdx(uv.x);\n    \n    guv = uv;\n    uv *= 0.5;\n    //uv *= rot(-0.25*pi);\n    //uv = kink( uv, vec2(0.1), 0.5);\n    \n    uv += texture(iChannel1,uv).xy*0.003 + texture(iChannel2,uv*0.05).xy*0.01;\n\t\n    vec3 col = vec3(1.);\n\n    \n    float d = 10e5;\n    \n    \n    // -- // \n    d = 10e5;\n    //d = length(uv) - 0.15;\n\n    \n    float wd = 0.005;\n    float h = 0.22;\n    float horiz = 0.319;\n    float twd = 0.03;\n    \n    float T = iTime*0.4 + 1.;\n    \n    float modthing = sin((floor(T) + pow(fract(T), 5.) )*pi/2.)*0.5 + 0.5;\n    \n    // COOLINE\n    \n    d = sdLine( uv - 0.14, vec2(-0.01,0.) , vec2(0.4,0.),0.) - 0.001;\n\t\n    \n    d = xor(d,length(uv) - 0.2,0.02);\n    \n    // COOLINE\n    d = min(d,sdLine( uv + vec2(0.13,0.1), vec2(-0.05,0.) , vec2(-0.3,0.),0.) - 0.001);\n\n    \n    d = xor(d,-abs(sdLine( uv + 0., vec2(-0.1,0.) , vec2(0.2,0.),1.) - 0.03) - 0.002,0.02);\n    \n    \n    // SQUARE\n    d = xor(d,-abs(sdBox( uv + 0.0, vec2(0.1))) - 0.001,0.02 + modthing*0.03);\n    \n    \n    d = xor(d,-abs(sdBox( uv*rot(0.25*pi) + 0.0, vec2(0.25))) - 0.002,0.02);\n    \n     \n    col = colour( d, col, vec3(1.)*0.01, 0);\n   \n    d = xor(d,sdBox(uv,vec2(0.5,0.25)),0.031 );\n    \n    \n    d = xor(d,-length(uv)-0.1,0.11 + modthing*0.1);\n    \n    \n    col = colour( d, col, vec3(0.01,0.01,0.0), 0);\n\t\n    d = xor(d,-length(uv)-0.,0.01);\n    col = colour( d, col, vec3(0.01,0.01,0.0), 0);\n\t\n    \n    d = xor(d,-length(uv)-0.,0.015);\n    //col = colour( d, col, vec3(0.11,0.21,0.4)*0.02, 0);\n\tcol = colour( d, col, vec3(0.01,0.01,0.0)*1., 0);\n\t\n    \n    uv = abs(uv);\n    \n    \n    float db = sdBox(uv - vec2(horiz,0.),vec2(wd,0.13));\n    db = max(db,uv.y - h);\n    \n    db = min(db,sdBox(uv - vec2(horiz - twd + wd,h),vec2(twd,wd)));\n    \n    d = xor(d,-db,0.1);\n    \n    col = colour( d, col, vec3(1.), 0);\n\t\n    \n    \n    \n    //col = 1. - col;\n    col = max(col,0.002);\n    \n    \n\tvec4 f = smoothstep(0.,1.,fbm(uv*50.));\n\tvec4 g = smoothstep(0.,1.,fbm(uv*60. - 0.4));\n    \n    f.x = pow(f.x, 5.);\n    \n    float n = 0.;\n    n += f.x*.5;\n    n += pow(f.y,7.)*2.5;\n    n += pow(f.z,6.)*2.5;\n    n += pow(f.w,3.)*0.1;\n        \n    n += pow(g.x,6.)*3.;\n    n += pow(g.y,4.)*1.;\n    n += pow(g.z,4.)*1.;\n        \n    \n    n = min(n,0.5);\n    \n    \n    \n    if(length(col) > 0.2){\n        vec3 nn = vec3(n*0.6,n,n)*1.4;\n        col *= 1. - nn;\n        //col -= pow(g,5.)*2.5;\n        //col -= pow(g,2.)*.9;\n    }\n    else{\n        col += pow(n,2.)*0.1;\n    \t//col += f*4.;\n    \n    }    \n    \n    col *= vec3(1.06,0.98,0.9);\n\t\n    \n    col = pow(col,vec3(0.5545));\n    \n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define xor(a,b,c) min(max(a,-b), max(-a + c,b))\n\n#define pi acos(-1.)\n#define rmod(a,uv,md,amt) max(a, -abs(mod(atan((uv).y,(uv).x),md*pi) - md*pi*0.5) + md*pi*amt)\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\nvec2 kink(vec2 p, vec2 c, float k) {\n    p -= c;\n    //to polar coordinates\n    float ang = atan(p.x, p.y);\n    float len = length(p);\n    //warp angle with sigmoid function\n    ang -= ang/sqrt(1.+ang*ang)*(1.-k);\n    //to cartesian coordiantes\n    return vec2(sin(ang),cos(ang))*len + c;\n}\n\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat sdLine(vec2 p, vec2 A, vec2 B, float bally){\n    vec2 AB = B - A;\n    \n    float angle = atan(AB.y, AB.x);\n    \n    vec2 n = normalize(vec2(sin(-angle),cos(-angle)));\n\n    float d = dot(p - B,n);\n    \n    d = abs(d);\n    if(bool(bally)){\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    } else {\n        d = max(d,dot(p-A,n*rot(0.5*pi)));\n        d = max(d,-dot(p-B,n*rot(0.5*pi)));\n        /*\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    \t*/\n        \n    }\n    \n    \n    return d;\n}\n\n\n// from iq\nfloat sdSine( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n\n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<24; i++ ) // 24 bit precision\n    {\n        float x = 0.5*(xa+xb);\n        float y = x-p.x+b*c*sin(x)*(p.y-b*c*cos(x));\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}