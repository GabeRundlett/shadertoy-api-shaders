{
    "Shader": {
        "info": {
            "date": "1665989925",
            "description": "Upgrade of my previous volumetric ray marcher. The volumes now scatter light from a single light source by casting shadow rays at various positions along the ray.",
            "flags": 0,
            "hasliked": 0,
            "id": "7lyBWc",
            "likes": 3,
            "name": "Volumes with Direct Lighting",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "lighting",
                "volumetric"
            ],
            "usePreview": 0,
            "username": "SpinningCube",
            "viewed": 286
        },
        "renderpass": [
            {
                "code": "/*\n *\n * Volumes with Direct Lighting\n * by SpinningCube\n *\n * \n * Uses a constant step size, and samples from a 3D layered noise texture.\n * At each sample, a secondary \"shadow ray\" is also cast towards the light source\n * if the density at that position is greater than 0.\n * The shadow ray measures how much direct light that sample receives.\n * Randomness is used to get rid of layering artifacts\n * \n * \n * Filmic tonemapping curve by milesWaugh\n *\n * Hash functions by Nimitz:\n * https://www.shadertoy.com/view/Xt3cDn\n *\n */\n\nuint baseHash(uvec3 p)\n{\n    p = 1103515245U*((p.xyz >> 1U)^(p.yzx));\n    uint h32 = 1103515245U*((p.x^p.z)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash13(uvec3 x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash23(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec2 rz = uvec2(n, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash33(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash43(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec4 rz = uvec4(n, n*16807U, n*48271U, n*69621U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec4((rz >> 1) & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n\n/* Variables */\n\nconst int maxSteps = 256;\nconst float epsilon = 0.005;\nconst float pi = 3.1415926536;\nconst float focalLength = 0.7;\nconst float renderDist = 50.;\n\nvec3 lightDir = normalize(vec3(-1,1,-2));\nvec3 lightCol = 4. * vec3(1, 1, .8);\nfloat lightDist = 10.;\n\nvec3 camera;\nfloat SDE;\nvec3 ray;\nfloat rayDensity;\nvec3 volumetricColor;\n\nvec3 surfCol;\nvec3 surfNormal;\nfloat surfSpecular;\nfloat surfRoughness;\nbool updateMat;\n\nvec3 diffuse = vec3(0.);\nvec3 specular;\nvec3 ambient = vec3(0.05);\n\n\nvec3 rayDirection( float focal, vec2 xy ) {\n    return (normalize(vec3(xy, focal)));\n}\n\nfloat visibility(float x) {\n    return exp(-x);\n}\n\nmat2 rotate(float a) {\n    float sinA = sin(a);\n    float cosA = cos(a);\n    return mat2(cosA, -sinA, sinA, cosA);\n}\n\n/* Objects */\n\nfloat Sphere( vec3 ray, vec3 pos, float radius ) {\n    return distance(ray, pos ) - radius;\n}\n\nfloat SphereVolume( vec3 ray, vec3 pos, float radius, float density ) {\n    return density * max(0., (radius - distance(ray, pos))/radius);\n}\n\nfloat Ground( vec3 ray, float y ) {\n    return ray.y - y;\n}\n\nvoid addSDF( float SDF, vec3 col, float specular, float roughness ) {\n    if ( SDF < SDE ) {\n        SDE = SDF;\n        if (updateMat) {\n        \tsurfCol = col;\n        \tsurfSpecular = specular;\n        \tsurfRoughness = roughness * roughness;\n        }\n    }\n}\n\nfloat Noise3D(vec3 pos) {\n    int layers = 6;\n    float noise = 0.;\n    for (int i = 1; i <= layers; i++) {\n        float scale = exp2(float(i));\n        noise += 1./scale * texture(iChannel0, 0.008*pos*scale).r;\n    }\n    \n    return max(0., mix(-.25, 1., noise/(1. - exp2(-float(layers)))));\n}\n\n/* Scene */\n\nfloat scene( vec3 ray, float renderDist ) {\n    \n    SDE = renderDist;\n\n    addSDF( Sphere( ray, vec3(0.), 2.), .6 * vec3(0.2,1.,0.2), 1.5, 0.1 );\n    \n    return SDE;\n}\n\nfloat sceneVolumes( vec3 ray ) {\n    \n    float density = 0.;\n    \n    density += max(0., 25.0 * SphereVolume( ray, vec3(0.), 12., 7. * pow(Noise3D( .2 * ray + iTime + 1./60. * vec3(0.5, 1, 0.5)), 8.)));\n    \n    return max(0., density);\n}\n\n/* Sampling and Raycasts */\n\nvec3 calcNormal( vec3 p )\n{\n    const float h = 10. * epsilon; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy * scene( p + k.xyy*h, renderDist ) + \n                      k.yyx * scene( p + k.yyx*h, renderDist ) + \n                      k.yxy * scene( p + k.yxy*h, renderDist ) + \n                      k.xxx * scene( p + k.xxx*h, renderDist ));\n    \n}\n\nfloat shadowRay( vec3 rayDir, vec3 start, float renderDist ) {\n    float shadowRayDensity = 0.;\n    float firstStepSize = .4;\n    float secondStepSize = 0.005;\n    bool oldUpdateMat = updateMat;\n    updateMat = false;\n    ray = start;\n    float rayLength = 0.;\n    float oldSDE = SDE;\n    for ( int i = 0; i <= maxSteps; i++ ) {\n    \n        float nextStepSize = min(firstStepSize, firstStepSize);\n        \n        ray += rayDir * float(nextStepSize >= firstStepSize) * nextStepSize * (hash13( uvec3(86412.4352 * start.xyz + vec3(6425.432, 9624.242, 2355.543) * vec3(float(i)) ) ) - 0.5);\n        \n        float pointDensity = sceneVolumes( ray );\n        shadowRayDensity += 1. * pointDensity * nextStepSize;        \n        scene( ray, renderDist );\n        rayLength += nextStepSize;\n        ray = rayDir * rayLength + start;\n        \n        if ( rayLength > renderDist ) {\n            updateMat = oldUpdateMat;\n            ray = start;\n            SDE = oldSDE;\n            return 0.;\n        }\n        if ( SDE < epsilon ) {\n            for ( int i = 0; i <= maxSteps; i++ ) {\n                scene( ray, renderDist );\n                rayLength -= secondStepSize;\n                ray = rayDir * rayLength + start;\n                if (SDE >= 0.) {\n                    break;\n                }\n            }\n            updateMat = oldUpdateMat;\n            ray = start;\n            if ( SDE < epsilon ) {\n                SDE = oldSDE;\n                return 0.;\n            }\n            SDE = oldSDE;\n            return visibility(shadowRayDensity);\n        }\n        firstStepSize *= 1.02;\n    }\n    updateMat = oldUpdateMat;\n    ray = start;\n    SDE = oldSDE;\n    return visibility(shadowRayDensity);\n}\n\nvec4 shootRay( vec3 rayDir, vec3 start, float renderDist, bool updateMaterial ) {\n    rayDensity = 0.;\n    float firstStepSize = 0.05;\n    float secondStepSize = 0.005;\n    updateMat = updateMaterial;\n    ray = start;\n    float rayLength = 0.;\n    for ( int i = 0; i <= maxSteps; i++ ) {\n    \n        float nextStepSize = min(SDE, firstStepSize + 0.2 * rayDensity);\n        \n        scene( ray, renderDist );\n        \n        ray += rayDir * float(nextStepSize >= firstStepSize + 0.2 * rayDensity) * nextStepSize * (hash13( uvec3(48421.425 * rayDir.xyz + 30214.6452 * vec3(1.2, 0.6, 1.5) * float(i)) ) - 0.5);\n        \n        float pointDensity = sceneVolumes( ray );\n        if (pointDensity > 0.0) {\n            vec3 sampleColor = lightCol * shadowRay(lightDir, ray, lightDist) + .5 * ambient;\n            volumetricColor += 0.3 * visibility(rayDensity) * nextStepSize * pointDensity * sampleColor;\n        }\n        rayDensity += pointDensity * nextStepSize;\n        \n        rayLength += nextStepSize;\n        ray = rayDir * rayLength + start;\n        \n        if ( rayLength > renderDist ) {\n            return vec4(0., ray);\n        }\n        if ( SDE < 0.01 * epsilon ) {\n            for ( int i = 0; i <= maxSteps; i++ ) {\n        \n                scene( ray, renderDist );\n                rayLength -= secondStepSize;\n                ray = rayDir * rayLength + start;\n                if (SDE >= 0.) {\n                    break;\n                }\n            }\n            return vec4(float(SDE < epsilon), ray);\n        }\n        firstStepSize *= 1.01;\n    }\n    return vec4(0., ray);\n}\n\n/* Lighting */\n\nfloat GGX (float halfDot, float roughness) {\n    float r2 = roughness*roughness;\n    float a = halfDot * halfDot * (r2 - 1.) + 1.;\n    return r2 / (a * a);\n}\n\nvoid directionalLight(vec3 ray, vec3 rayDir, vec3 lightDir, vec3 surfNormal, vec3 intensity, float lightDist) {\n    float lightVisibility = shadowRay(lightDir, ray + (surfNormal * epsilon), lightDist);\n    if ( lightVisibility > 0. ) {\n        float lambertian = dot(surfNormal, lightDir);\n        intensity *= lambertian * lightVisibility;\n        \n        diffuse += max(intensity, 0.);\n\t\t\n        vec3 halfway = normalize(lightDir - rayDir);\n        float halfDot = dot(surfNormal, halfway);\n    \tspecular += max(intensity * GGX(halfDot, surfRoughness), 0.);\n\n    }\n}\n\nvoid pointLight( vec3 ray, vec3 rayDir, vec3 position, vec3 intensity, vec3 surfNormal ) {\n    vec3 lightDir = normalize(position - ray);\n    directionalLight( ray, rayDir, lightDir, surfNormal, intensity, distance(position, ray) );\n}\n\nvoid sceneLights(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    directionalLight( ray, rayDir, normalize(vec3(-1,1,-2)), surfNormal, lightCol, 2. );\n}\n\n// Filmic tonemapping curve by milesWaugh\nvec3 filmic(vec3 color) {\n    //return color;\n    return 1.0 - (1.0/(5.0 * color * color + 1.0));\n}\n\n// Uses Schlick's approximation\nfloat fresnel(float IOR, float roughness, vec3 surfNormal, vec3 incident) {\n    float F0 = (1. - IOR)/(1. + IOR);\n    F0 *= F0;\n    return F0 + (1. - roughness)*((1. - F0) * pow(1. - dot(surfNormal, incident), 5.));\n}\n\nvec3 lighting(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    diffuse = vec3(0.0);\n    specular = vec3(0.0);\n    \n    sceneLights(ray, rayDir, surfNormal);\n    \n\n    float f = fresnel(1.5, surfRoughness, surfNormal, -rayDir);\n    vec3 finalCol = mix(surfCol * (diffuse + ambient), vec3(specular) + ambient, f);\n    \n    return finalCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    volumetricColor = vec3(0.);\n    camera = vec3(0, 0, -30);\n    \n    vec2 mouse = (1.1 * iMouse.xy)/iResolution.xy - vec2(0.5);\n    \n    if(iMouse.xy == vec2(0.0)){\n        mouse = vec2(0.25, 0.0);\n    }    \n    \n    camera.yz *= rotate(pi * -mouse.y);\n    camera.xz *= rotate(2. * pi * -mouse.x);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.x;\n    vec2 UV = fragCoord/iResolution.xy;\n    vec3 rayDir = rayDirection( focalLength, uv );\n    \n    rayDir.yz *= rotate(pi * -mouse.y);\n    rayDir.xz *= rotate(2. * pi * -mouse.x);\n    \n    vec4 rayData = shootRay( rayDir, camera, renderDist, true );\n    \n    float cameraRayDensity = rayDensity;\n    \n    vec3 col;\n    \n    vec3 finalVolumetricColor = volumetricColor;\n    \n    if (rayData.x == 1.) {\n        vec3 surfNormal = calcNormal( rayData.yzw );\n    \tcol = lighting( rayData.yzw, rayDir, surfNormal );\n    }\n    else {\n        col = ambient;\n    }\n    \n    col = filmic( mix( finalVolumetricColor, col, visibility(cameraRayDensity)) );\n    \n    // Output to screen\n    fragColor = vec4(pow(col, vec3(1.0/2.2)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}