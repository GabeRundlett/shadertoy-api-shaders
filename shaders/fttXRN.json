{
    "Shader": {
        "info": {
            "date": "1638816219",
            "description": "This is yet another recreation of https://www.shadertoy.com/view/4dX3zl based on https://www.shadertoy.com/view/7dK3D3.",
            "flags": 0,
            "hasliked": 0,
            "id": "fttXRN",
            "likes": 10,
            "name": "Branchless Voxel Raycasting Tex",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "raycasting",
                "voxel",
                "fork",
                "dda",
                "textured"
            ],
            "usePreview": 1,
            "username": "theraot",
            "viewed": 568
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926\n\n// Helper functions for the camera transform\n\nmat4 rotate_xz(float t)\n{\n    return mat4(\n        cos(t) , 0.0, sin(t), 0.0,\n        0.0    , 1.0, 0.0   , 0.0,\n        -sin(t), 0.0, cos(t), 0.0,\n        0.0    , 0.0, 0.0   , 1.0\n    );\n}\n\nmat4 translate (vec3 v)\n{\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                v.x, v.y, v.z, 1.0); \n}\n\n// Helper functions for voxel geometry\n\nfloat sdSphere(vec3 p, float d)\n{ \n    return length(p) - d;\n} \n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat getVoxel(vec3 c) {\n\tvec3 p = c + vec3(0.5);\n\tfloat d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 25.0));\n    return step(0.0, -d);\n}\n\n// Main\n\n#define MAX_RAY_STEPS 128\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Basic setup:\n    float aspect = iResolution.x / iResolution.y;\n    vec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0; \n    vec3 rayDir = normalize(vec3(screenPos.x, screenPos.y * (1.0/aspect), 1.0));\n    vec3 rayPos = vec3(0.0, 0.0, 0.0);\n    \n    // Camera transform:\n    float verticalOscilation = sin(iTime * 2.7) * 0.0;\n    float orbitDistance = 14.0;\n    float orbitAngle = (iTime / 5.0);\n    mat4 cam_position = translate(vec3(0.0, verticalOscilation, orbitDistance));\n    mat4 orbit = rotate_xz(orbitAngle);\n    mat4 look = rotate_xz(orbitAngle + PI);\n    rayPos = (orbit * cam_position * vec4(rayPos, 1.0)).xyz;\n    rayDir = (look * vec4(rayDir, 1.0)).xyz;\n\n    // Voxel traversal setup:\n    vec3 raySgn = sign(rayDir);\n    vec3 next = floor(rayPos) + clamp(raySgn, 0.0, 1.0);\n    vec3 lengthBetween = raySgn / rayDir;\n    \n    // Vext traversal (first step unrolled):\n    vec3 current = rayPos;\n    vec3 lengthToNext = (next - rayPos) / rayDir;\n    float voxel = getVoxel(floor(current));\n    vec3 mask = step(0.0, min(lengthToNext.yzx, lengthToNext.zxy) - lengthToNext.xyz);   \n    vec3 lastMask; // This allows me to keep the last mask even without shortcircuiting the loop.\n    \n    for (int i = 0; i < MAX_RAY_STEPS; i++)\n    {\n        vec3 effectiveMask = (1.0 - voxel) * mask;\n        current += effectiveMask * raySgn;\n        lengthToNext += effectiveMask * lengthBetween;\n        voxel = sign(voxel + getVoxel(floor(current)));\n        // if (voxel == 1.0) break;\n        mask = step(0.0, min(lengthToNext.yzx, lengthToNext.zxy) - lengthToNext.xyz);\n        lastMask = mask * (1.0 - voxel) + lastMask * (voxel);\n    }\n    \n    // Correct position (the above code does integer steps):\n    lengthToNext = lengthToNext - lastMask * lengthBetween; // Step back once\n    float traversedLength = min(lengthToNext.x, min(lengthToNext.y, lengthToNext.z));\n    current = rayPos + rayDir * traversedLength;\n    \n    // Compute UV (we use the fractional part of the position): \n    vec3 f = current - floor(current);\n    vec2 uv = lastMask.x * f.yz + lastMask.y * f.xz + lastMask.z * f.xy;\n\n    // Texture:\n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    // Shade: \n    color *= vec3(dot(lastMask, vec3(0.5, 1.0, 0.75)));\n    \n    // Fog:\n    vec3 fogcolor = vec3(0.25, 0.4, 0.5);\n    color *= mix(fogcolor, color, exp(-traversedLength * traversedLength / 200.0));\n    \n    // Output:\n\tfragColor.rgb = color;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}