{
    "Shader": {
        "info": {
            "date": "1712575338",
            "description": "Comparing different corner shapes to achieve rounded boxes. Only the Cosine and the Cubic produce C2 continuous surfaces. See [url]https://iquilezles.org/articles/roundedboxes/[/url] for a 3D version.",
            "flags": 0,
            "hasliked": 0,
            "id": "4cG3R1",
            "likes": 25,
            "name": "Rounded boxes comparison 2D",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "squircle",
                "superellipse",
                "roundedbox",
                "roundedbox"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 1198
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2024 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n// Made for this article: https://iquilezles.org/articles/roundedboxes/\n\n// Comparing different corner shapes to achieve rounded boxes\n// (motivated by https://www.shadertoy.com/view/lcyGRz). Here\n// I show a Circle, Parabola, Cosine and Cubic corner shapes.\n// Skipped hyperbola in this example, it doesn't help really.\n// But Superellipse is given for convenience even though it's\n// not a rounded box.\n//\n// The yellow shade is the laplacian, a measure of the second\n// derivatives. When that's discontinuous so will be lighting\n// on a 3D shape extruded from this. Note how only the Cosine\n// and the Cubic produce C2 continuous surfaces.\n//\n// See https://www.shadertoy.com/view/4fyGz1 for a 3D version.\n//\n// Related:\n//   Rounded Box : https://www.shadertoy.com/view/4llXD7\n//   Squircle    : https://www.shadertoy.com/view/7stcR4\n\n\n\nfloat sdCornerCircle(   in vec2 p ); // c(u) = sqrt(2-u^2)-1\nfloat sdCornerParabola( in vec2 p ); // c(u) = (1-u^2)/2\nfloat sdCornerCosine(   in vec2 p ); // c(u) = (2/PI)*cos(u*PI/2)\nfloat sdCornerCubic(    in vec2 p ); // c(u) = (u^3-3u^2+2)/3\n\nconst float kT = 6.28318531;\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r, in int type )\n{\n    // select corner radius\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    // box coordinates\n    vec2 q = abs(p)-b+r.x;\n    // distance to sides\n    if( min(q.x,q.y)<0.0 ) return max(q.x,q.y)-r.x;\n    // rotate 45 degrees, offset by r and scale by r*sqrt(0.5) to canonical corner coordinates\n    vec2 uv = vec2( abs(q.x-q.y), q.x+q.y-r.x )/r.x;\n    // compute distance to corner shape\n    float d;\n         if( type==0 ) d = sdCornerCircle( uv );\n    else if( type==1 ) d = sdCornerParabola( uv );\n    else if( type==2 ) d = sdCornerCosine( uv );\n    else if( type==3 ) d = sdCornerCubic( uv );\n    // undo scale\n    return d * r.x*sqrt(0.5);\n}\n\nfloat sdCornerCircle( in vec2 p )\n{\n    return length(p-vec2(0.0,-1.0)) - sqrt(2.0);\n}\n\nfloat sdCornerParabola( in vec2 p )\n{\n    // https://www.shadertoy.com/view/ws3GD7\n    float y = (0.5 + p.y)*(2.0/3.0);\n    float h = p.x*p.x + y*y*y;\n    float w = pow( p.x + sqrt(abs(h)), 1.0/3.0 ); // note I allow a tiny error in the very interior of the shape so that I don't have to branch into the 3 root solution\n    float x = w - y/w;\n    vec2  q = vec2(x,0.5*(1.0-x*x));\n    return length(p-q)*sign(p.y-q.y);\n}\n\nfloat sdCornerCosine( in vec2 uv )\n{\n    // https://www.shadertoy.com/view/3t23WG\n    uv *= (kT/4.0);\n\n    float ta = 0.0, tb = kT/4.0;\n    for( int i=0; i<8; i++ )\n    {\n        float t = 0.5*(ta+tb);\n        float y = t-uv.x+(uv.y-cos(t))*sin(t);\n        if( y<0.0 ) ta = t; else tb = t;\n    }\n    vec2  qa = vec2(ta,cos(ta)), qb = vec2(tb,cos(tb));\n    vec2  pa = uv-qa, di = qb-qa;\n    float h = clamp( dot(pa,di)/dot(di,di), 0.0, 1.0 );\n    return length(pa-di*h) * sign(pa.y*di.x-pa.x*di.y) * (4.0/kT);\n}\n\nfloat sdCornerCubic( in vec2 uv )\n{\n    float ta = 0.0, tb = 1.0;\n    for( int i=0; i<12; i++ )\n    {\n        float t = 0.5*(ta+tb);\n        float c = (t*t*(t-3.0)+2.0)/3.0;\n        float dc = t*(t-2.0);\n        float y = (uv.x-t) + (uv.y-c)*dc;\n        if( y>0.0 ) ta = t; else tb = t;\n    }\n    vec2  qa = vec2(ta,(ta*ta*(ta-3.0)+2.0)/3.0);\n    vec2  qb = vec2(tb,(tb*tb*(tb-3.0)+2.0)/3.0);\n    vec2  pa = uv-qa, di = qb-qa;\n    float h = clamp( dot(pa,di)/dot(di,di),0.0,1.0 );\n    return length(pa-di*h) * sign(pa.y*di.x-pa.x*di.y);\n}\n\nfloat approx_sdSuperEllipse( vec2 p, vec2 b, vec4 r )\n{\n    // select corner radius\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    \n    float n = r.x;\n    \n    p = abs(p);\n    \n    #if 0\n        // reall bad, cheap linearliation of the basic implicit formula\n        n = 2.0/n;\n        float w = pow(p.x/b.x,n) + pow(p.y/b.y,n);\n        float kb = 2.0*n - 2.0;\n        float ka = 1.0-1.0/n;\n        float kc = 2.0*n;\n        return (w-pow(w,ka)) * inversesqrt( pow(p.x,kb)/pow(b.x,kc) + pow(p.y,kb)/pow(b.y,kc) );\n    #else\n        // bisection root finder for distance minimizer\n        float xa = 0.0, xb = kT/4.0;\n        if( p.x-b.x>p.y-b.y ) xb*=0.5; // hack for interior distances, still wrong\n        for( int i=0; i<12; i++ ) \n        {\n            float x = 0.5*(xa+xb);\n            float c = cos(x);\n            float s = sin(x);\n            float cn = pow(c,n);\n            float sn = pow(s,n);\n            float y = (p.x-b.x*cn)*b.x*cn*s*s - (p.y-b.y*sn)*b.y*sn*c*c;\n            if( y<0.0 ) xa = x; else xb = x;\n        }\n        vec2  qa = b*pow(vec2(cos(xa),sin(xa)),vec2(n));\n        vec2  qb = b*pow(vec2(cos(xb),sin(xb)),vec2(n));\n        vec2  pa = p-qa, ba = qb-qa;\n        float h = clamp( dot(pa,ba)/dot(ba,ba),0.0,1.0);\n        return length( pa - ba*h ) * sign(pa.x*ba.y-pa.y*ba.x);\n    #endif\n}\n\nconst float kNorm[4] = float[4]( sqrt(2.0)-1.0, 1.0/2.0, 4.0/6.283185, 2.0/3.0 );\nfloat map( in vec2 p, in int type )\n{\n\tvec2 si = vec2(1.2,0.6);\n    vec4 ra = vec4(0.42,0.05,0.3,0.2);\n    \n    // normalize radii, usually NOT needed, here just for demo purposes\n    #if 1\n    if( type<4 ) ra *= kNorm[type]/kNorm[0]; \n    #endif\n\n    return (type==4) ? approx_sdSuperEllipse( p, si, ra) : \n                       sdRoundBox( p, si, ra, type );\n}\n\n/*\nfloat lapRoundBox( in vec2 p, in vec2 b, in vec4 r, int type )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    if( min(q.x,q.y)<0.0 ) return 0.0;\n    vec3 uv = vec2( abs(q.x-q.y), q.x+q.y-r.x )/r.x;\n    \n    float l;\n         if( type==0 ) l = inversesqrt(uv.x*uv.x+(uv.y+1.0)*(uv.y+1.0));\n    else if( type==1 ) l = 0.0; // TODO\n    else if( type==2 ) l = 0.0; // TODO\n    else if( type==3 ) l = 0.0; // TODO\n\n    return l/r.x/sqrt(0.5);  // note laplacian is rotational invariant, we only need to take care of scale\n}\n\nfloat calcLaplacian( in vec2 p, int type )\n{\n\tconst vec2 si = vec2(1.2,0.6);\n    const vec4 ra = vec4(0.42,0.05,0.3,0.2);\n    return (type==4) ? approx_sdSuperEllipse( p, si, ra) : \n                       lapRoundBox( p, si, ra, type );\n}\n*/\n\nfloat print( in float sdf, inout vec2 p, in int str[12] )\n{\n    if( p.y<0.0|| p.y>1.0 ) return sdf;\n    float d = 1e20;\n    for( int i=0; i<str.length(); i++ )\n    {\n        int c = str[i];\n        if( c==0 ) break;\n        if( p.x>0.0 && p.x<1.0 )\n        {\n            vec2 q = p/16.0;\n            d = min(d,textureGrad( iChannel0, vec2(c,15-c/16)/16.0+q, dFdx(q), dFdy(q) ).w);\n        }\n        p.x -= 0.5;\n    }\n    return min(d,sdf);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    int type = int( iTime/2.0 ) % 5;\n    bool showLaplacian = (int( iTime/10.0) & 1 ) == 1;\n\n    // compute SDF\n\tfloat d = map( p, type );\n\n    // central differenes based laplacian (note skeleton artifacts, could use\n    const vec2 eps = vec2(0.005,0.0);   // true derivatives of autodiff)\n    float laplacian = ( map( p-eps.xy, type ) + \n                        map( p+eps.xy, type ) +\n                        map( p-eps.yx, type ) + \n                        map( p+eps.yx, type ) - 4.0*d )/(eps.x*eps.x);\n                        \n    //laplacian = calcLaplacian( p, type ); // analytical laplacian\n\n    // colors\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    if( showLaplacian ) col.xy += 0.15*abs(laplacian);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    // mouse interaction\n    if( iMouse.z>0.001 )\n    {\n        d = map(m,type);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n    // draw text\n    {\n        const float text_scale = 0.15;\n        vec2 q = (p-vec2(-0.5,-0.9))/text_scale;\n        float text = 1e20;\n              if( type==0 )  text = print(text,q,int[12](67,105,114, 99,108,101,  0,  0,  0,  0,  0,  0));\n        else  if( type==1 )  text = print(text,q,int[12](80, 97,114, 97, 98,111,108, 97,  0,  0,  0,  0));\n        else  if( type==2 )  text = print(text,q,int[12](67,111,115,105,110,101,  0,  0,  0,  0,  0,  0));\n        else  if( type==3 )  text = print(text,q,int[12](67,117, 98,105, 99,  0,  0,  0,  0,  0,  0,  0));\n        else/*if( type==4 )*/text = print(text,q,int[12](83,117,112,101,114,101,108,108,105,112,115,101));\n        col = mix(col,vec3(0.0),1.0-smoothstep( 0.06,0.08,text-0.5));\n        col = mix(col,vec3(1.0),1.0-smoothstep(-0.01,0.01,text-0.5));\n    }\n\n    // output\n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}