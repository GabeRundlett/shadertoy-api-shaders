{
    "Shader": {
        "info": {
            "date": "1688263522",
            "description": "Apollonian circles and conic sections via the two-body field.  Illustration for: https://www.blakecourter.com/2023/07/01/two-body-field.html",
            "flags": 32,
            "hasliked": 0,
            "id": "cs2cW3",
            "likes": 3,
            "name": "Two Body Apollonian and Conics",
            "published": 3,
            "tags": [
                "sdf",
                "ugf",
                "twobody"
            ],
            "usePreview": 0,
            "username": "bcourter",
            "viewed": 914
        },
        "renderpass": [
            {
                "code": "// Apollonian and conic two-body fields\n// Illustration for: https://www.blakecourter.com/2023/07/01/two-body-field.html\n\n// Sliders thanks to https://www.shadertoy.com/view/XlG3WD\n\nfloat pi = 3.1415926535;\n\nvec2 mouse = vec2(-180.0, 250.0);\n\nvec2 center = vec2(0.0);\nfloat offset = 0.5;\nvec2 direction = vec2(1.0, 1.0);\nint viz = 0;\n\n// Sliders\nfloat readFloat(float address) { return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; }\nvec4 readVec4(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\n\nvec4 strokeImplicit(Implicit a, float width, vec4 base) {\n    vec4 color = vec4(a.Color.rgb * 0.25, a.Color.a);\n    \n    float interp = clamp(width * 0.5 - abs(a.Distance) / length(a.Gradient), 0.0, 1.);\n    return mix(base, color, color.a * interp);\n    \n    return base;\n}\n\nvec4 drawImplicit(Implicit a, vec4 base) {\n    float bandWidth = 20.0;\n    float falloff = 150.0;\n    float widthThin = 2.0;\n    float widthThick = 4.0;\n\n    vec4 opColor = mix(base, a.Color, (a.Distance < 0.0 ? a.Color.a * 0.1 : 0.0));\n    Implicit wave = TriangleWaveEvenPositive(a, bandWidth, a.Color);  \n\n    wave.Color.a = max(0.2, 1.0 - abs(a.Distance) / falloff);\n    opColor = strokeImplicit(wave, widthThin, opColor);\n    opColor = strokeImplicit(a, widthThick, opColor);\n    \n    return opColor;\n}\n\nvec4 drawLine(Implicit a, vec4 opColor) {\n    a.Color.a = 0.75;\n    return strokeImplicit(a, 2.0, opColor);\n}\n\nvec4 drawFill(Implicit a, vec4 opColor) {\n    if (a.Distance <= 0.0)\n        return mix(opColor, a.Color, a.Color.a);\n\n    return opColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 opColor = vec4(1.0);\n    \n    offset = readFloat(0.);\n    viz = int(readFloat(1.) * 2.);\n    \n    vec2 p = fragCoord - 0.5 * iResolution.xy; // * iResolution.xy;\n    \n    if (iMouse.x > bounds.x + bounds.z + 20.0 || iMouse.y > bounds.y + bounds.w + 20.0)\n        mouse = iMouse.xy - 0.5 * iResolution.xy;\n    \n    vec3 p3 = vec3(p, 0.0);\n\n    float paddingAmt = 0.33;\n    float padding = iResolution.x * paddingAmt; // * (0.3 + cos(iTime) * 0.05);\n    float size = iResolution.x * (0.5 - paddingAmt) * sin(iTime) * offset;   \n    \n    Implicit a;\n    vec2 aCenter = vec2(padding, iResolution.y / 2.0);\n    float aRadius = size;\n    vec4 red = vec4(1., 0., 0., 1);\n    switch (viz) {\n    case 0:\n        a = Circle(fragCoord, aCenter, aRadius, red);\n        break;\n    default:\n        a = Plane(fragCoord, aCenter + vec2(aRadius, 0.), vec2(1, 0), red);\n    }\n \n    \n    Implicit b = Circle(fragCoord, vec2(iResolution.x - padding, iResolution.y / 2.0), -size, vec4(0., 0., 1., 1));\n    \n    Implicit shapes = Min(a, b);\n    Implicit sum = Add(a, b);   \n    Implicit diff = Subtract(a, b);\n    Implicit interp = Divide(diff, sum);\n    \n    opColor = min(\n        drawImplicit(Multiply(interp, 100.), opColor),\n        drawImplicit(Multiply(Subtract(1., Abs(interp)), 100.), opColor)\n    );\n \n \n    if (shapes.Distance < 0.)\n        opColor.rgb = min(opColor.rgb, opColor.rgb * 0.65 + shapes.Color.rgb * 0.2);\n\n    vec4 ui = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    opColor = mix(opColor, ui, ui.a);\n    \n //   opColor = DrawVectorField(p3, Divide(shape, length(shape.Gradient)), opColor, 25., 1.);\n    \n    fragColor = opColor;\n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define UI_COLOR vec3(0.0,0.0,0.0)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n// Backwards at https://github.com/dhepper/font8x8/blob/master/font8x8_basic.h\n#define RPAREN text.w += char(0x180C, 0x0606, 0x060C, 0x1800);\n#define LPAREN text.w += char(0x060C, 0x1818, 0x180C, 0x0600);\n#define SLASH  text.w += char(0x0306, 0x0C18, 0x3060, 0x4000);\n#define BSLASH text.w += char(0x6030, 0x180C, 0x0603, 0x0100);\n#define PLUS   text.w += char(0x000C, 0x0C3F, 0x0C0C, 0x0000);\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloatCentered(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printFloat(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloatCentered(data.r, 1., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n}\n\n//boolean\nvoid drawBoolean(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy, b) <= gap && iMouse.w > 0.0){\n     //   float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x + b.z) - b.x;\n      //  data.r = round(distanceFromLeftEdege / b.z);        \n        //data.a=1.0;\n        data.r = round(1.0 - data.r);\n        setPixel(vec2(id, 1), data);\n        \n        b.w = 35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r > 0.5) {\n        _T R U E\n    }\n    else {\n        _F A L S E\n    }\n    ui = mix(ui, 0., text.w);\n    text = tmp;\n}\n\n//chooser\nvoid drawChooser(int id, float val, inout float ui, vec2 p, vec4 b, int count){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    float increment = 1. / float(count);\n    moveCursor(b.xy + vec2(8., 2.));\n    if (data.r * 2. < increment) {\n        _A P O L L O N I A N\n    }\n    else {\n        _C O N I C S\n    }\n    ui = mix(ui, 0., text.w);\n\n    text = tmp;\n}\n\n\n#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYBOOLEAN(id,val) drawBoolean(id, round(val), ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYCHOOSER(id,val,count) drawChooser(id, val, ui, pixel, bounds, count); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n    \n    //define sliders    \n    EASYCHOOSER(1,0.0,1)  _V I S U A L I Z A T I O N      \n    EASYSLIDER(0,0.2)  _W I G G L E\n//    EASYSLIDER(2,0.75)  _A N G L E   \n          \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    \n    fragColor=result;    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec4 bounds = vec4(30,100,160,18);\n\n//////////////////\n\nstruct Implicit {\n\tfloat Distance;\n\tvec3 Gradient;\n\tvec4 Color;\n};\n\nImplicit CreateImplicit() { return Implicit(0.0, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue) { return Implicit(iValue, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue, vec4 iColor) { return Implicit(iValue, vec3(0.0), iColor); }\n\nImplicit Negate(Implicit iImplicit) {\n\treturn Implicit(-iImplicit.Distance, -iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Add(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance + b.Distance, a.Gradient + b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Subtract(Implicit a, Implicit b)  {\n\treturn Implicit(a.Distance - b.Distance, a.Gradient - b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Add(float iT, Implicit iImplicit) {\n\treturn Implicit(iT + iImplicit.Distance, iImplicit.Gradient, iImplicit.Color);\n}\nImplicit Add(Implicit iImplicit, float iT) { return Add(iT, iImplicit); }\nImplicit Subtract(float iT, Implicit iImplicit) { return Add(iT, Negate(iImplicit)); }\nImplicit Subtract(Implicit iImplicit, float iT) { return Add(-iT, iImplicit); }\n\nImplicit Multiply(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance * b.Distance, a.Distance * b.Gradient + b.Distance * a.Gradient, (a.Color + b.Color) * 0.5);\n}\nImplicit Multiply(float iT, Implicit iImplicit) { return Implicit(iT * iImplicit.Distance, iT * iImplicit.Gradient, iImplicit.Color); }\nImplicit Multiply(Implicit iImplicit, float iT) { return Multiply(iT, iImplicit); }\n\nImplicit Square(Implicit iA) { return Multiply(iA, iA); }\n\nImplicit Divide(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance / b.Distance, (b.Distance * a.Gradient - a.Distance * b.Gradient) / (b.Distance * b.Distance), (a.Color + b.Color) * 0.5);\n}\nImplicit Divide(Implicit a, float b) { return Implicit(a.Distance / b, a.Gradient / b, a.Color); }\n\nImplicit Min(Implicit a, Implicit b) \n{\n\tif (a.Distance <= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nImplicit Max(Implicit a, Implicit b) {\n\tif (a.Distance >= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nfloat mix11(float a, float b, float t) {\n    return mix(a, b, t * 0.5 + 0.5);\n}\n\nImplicit Exp(Implicit iImplicit)\n{\n\tfloat exp = exp(iImplicit.Distance);\n\treturn Implicit(exp, exp * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Log(Implicit iImplicit)\n{\n\treturn Implicit(log(iImplicit.Distance), iImplicit.Gradient / iImplicit.Distance, iImplicit.Color);\n}\n\nImplicit Sqrt(Implicit iImplicit)\n{\n\tfloat sqrt = sqrt(iImplicit.Distance);\n\treturn Implicit(sqrt, iImplicit.Gradient / (2.0 * sqrt), iImplicit.Color);\n}\n\nImplicit Abs(Implicit iImplicit)\n{\n\treturn Implicit(abs(iImplicit.Distance), sign(iImplicit.Distance) * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Mod(Implicit iImplicit, float iM)\n{\n\treturn Implicit(mod(iImplicit.Distance, iM), iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Shell(Implicit iImplicit, float thickness, float bias) \n{\n\tthickness *= 0.5;\n\treturn Subtract(Abs(Add(iImplicit, bias * thickness)), thickness);\n}\n\nImplicit EuclideanNorm(Implicit a, Implicit b) {\n    return Sqrt(Add(Multiply(a, a), Multiply(b, b)));\n}\nImplicit EuclideanNorm(Implicit a, Implicit b, Implicit c) {\n    return Sqrt(Add(Add(Multiply(a, a), Multiply(b, b)), Multiply(c, c)));\n}\n\n// Booleans\n// https://mercury.sexy/hg_sdf/\nImplicit IntersectionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit maxab = Max(a, b);\n    Implicit r = CreateImplicit(radius, maxab.Color);\n    \n    Implicit ua = Implicit(Max(Add(a, r), CreateImplicit()).Distance, a.Gradient, a.Color);\n    Implicit ub = Implicit(Max(Add(b, r), CreateImplicit()).Distance, b.Gradient, b.Color);\n    \n\tImplicit op = Add(Min(Negate(r), maxab), EuclideanNorm(ua, ub));\n    \n    if (maxab.Distance <= 0.0)\n        op.Gradient = maxab.Gradient;\n        \n    if (min(a.Distance, b.Distance) > 0.)\n        op.Color = mix(a.Color, b.Color, 0.5 + 0.5 * (b.Distance - a.Distance)/(a.Distance + b.Distance));\n        \n    return op;\n}\n\n// https://mercury.sexy/hg_sdf/\nImplicit UnionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit ab = Min(a, b);\n    Implicit r = CreateImplicit(radius, ab.Color);\n    \n    Implicit ua = Max(Subtract(r, a), CreateImplicit(0.0, a.Color));\n    Implicit ub = Max(Subtract(r, b), CreateImplicit(0.0, b.Color));\n    \n\tImplicit op = Subtract(Max(r, ab), EuclideanNorm(ua, ub));\n    \n    if (ab.Distance > 0.0)\n        op.Gradient = ab.Gradient;\n        \n    return op;\n}\n\n// https://mercury.sexy/hg_sdf/\nImplicit UnionEuclidean(Implicit a, Implicit b, Implicit c, float radius) {\n    Implicit zero = CreateImplicit(0.0);\n    Implicit r = CreateImplicit(radius);\n    Implicit ua = Max(Subtract(r, a), zero);\n    Implicit ub = Max(Subtract(r, b), zero);\n    Implicit uc = Max(Subtract(r, c), zero);\n    \n    Implicit abc = Min(a, Min(b, c));\n\n\tImplicit op = Subtract(Max(r, abc), EuclideanNorm(ua, ub, uc));\n    \n    if (abc.Distance > 0.0)\n        op.Gradient = abc.Gradient;\n        \n    return op;\n}\n\nImplicit UnionChamfer(Implicit iA, Implicit iB, float k)\n{\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(h, 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    float param = h2.Distance;\n    result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\n// Polynomial Smooth Min 2 from https://iquilezles.org/articles/smin/ and https://iquilezles.org/articles/distgradfunctions2d/\nImplicit UnionSmoothMedial(Implicit a, Implicit b, float k) \n{\n    float h = max(k-abs(a.Distance-b.Distance),0.0);\n    float m = 0.25*h*h/k;\n    float n = 0.50 * h/k;\n    float dist = min(a.Distance,  b.Distance) - m; \n                 \n    float param = (a.Distance < b.Distance) ? n : 1.0 - n;\n    vec3 grad = mix(a.Gradient, b.Gradient, param);\n    vec4 color = mix(a.Color, b.Color, param);\n\n\n    return Implicit(dist, grad, color);\n}\n\nImplicit UnionSmooth(Implicit a, Implicit b, float k){\n    a.Distance -= k;\n    b.Distance -= k;\n\n //   if (min(a.Distance, b.Distance) >= 0.)\n //       return (Min(a, b));\n\n    return Add(UnionSmoothMedial(a, b, abs(a.Distance + b.Distance) * abs(1.-dot(a.Gradient, b.Gradient))), k);\n}\n\n\nImplicit IntersectionSmoothMedial(Implicit iA, Implicit iB, float k){\n    return Negate(UnionSmoothMedial(Negate(iA), Negate(iB), k));\n}\n\n\nImplicit IntersectionSmooth(Implicit iA, Implicit iB, float k){\n    return Negate(UnionSmooth(Negate(iA), Negate(iB), k));\n}\n\n\n\n// R0 fro, https://www.cambridge.org/core/journals/acta-numerica/article/abs/semianalytic-geometry-with-rfunctions/3F5E061C35CA6A712BE338FE4AD1DB7B\nImplicit UnionRvachev(Implicit iA, Implicit iB, float k)\n{\n    Implicit result = Subtract(Add(iA, iB), Sqrt(Add(Square(iA), Square(iB))));\n  //  float param = 0.5;\n  //  result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\nImplicit IntersectionRvachev(Implicit iA, Implicit iB, float k){\n    return Negate(UnionRvachev(Negate(iA), Negate(iB), k));\n}\n\n\n// Primitives\n\nImplicit Plane(vec3 p, vec3 origin, vec3 normal, vec4 color) \n{\n    vec3 grad = normalize(normal);\n    float v = dot(p - origin, grad);\n    return Implicit(v, grad, color);\n}\nImplicit Plane(vec2 p, vec2 origin, vec2 normal, vec4 color) \n{\n    return Plane(vec3(p, 0.0), vec3(origin, 0.0), vec3(normal, 0.0), color);\n}\n\n\nImplicit Circle(vec2 p, vec2 center, float iRadius, vec4 color)\n{\n\tvec2 centered = p - center;\n    float len = length(centered);\n\tfloat length = len - iRadius;\n\treturn Implicit(length, vec3(centered / len, 0.0), color);\n}\n \nmat2 Rotate2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c)\n    );\n}\n\nImplicit RectangleCenterRotated(vec2 p, vec2 center, vec2 size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n    centered = rot * centered;\n    \n\tvec2 b = size * 0.5;\n\tvec2 d = abs(centered)-b;\n\tfloat dist = length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n\n\tvec2 grad = d.x > d.y ? vec2(1.0, 0.0) : vec2 (0.0, 1.0);\n\tif (d.x > 0. && d.y > 0.)\n\t\tgrad = d / length(d);\n\n\tgrad *= -sign(centered);\n\n\treturn Implicit(dist, vec3(grad * rot, 0.0), color);\n}\n\nImplicit RectangleUGFSDFCenterRotated(vec2 p, vec2 center, float size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n //   centered = rot * centered;\n    size *= 0.5;\n    \n    Implicit x = Plane(centered, vec2(0.), rot * vec2(-1., 0.), color);\n    Implicit y = Plane(centered, vec2(0.), rot * vec2(0., -1.), color);\n    Implicit cornerA = Subtract(Max(x, y), size);\n    Implicit cornerB = Subtract(Max(Negate(x), Negate(y)), size);\n   \n\treturn IntersectionEuclidean(cornerA, cornerB, 0.);\n}\n\nImplicit TriangleWaveEvenPositive(Implicit param, float period, vec4 color)\n{\n\tfloat halfPeriod = 0.5 * period;\n    float wave = mod(param.Distance, period) - halfPeriod;\n\tfloat dist = halfPeriod - abs(wave);\n\tvec3 grad = -sign(wave) * param.Gradient;\n\treturn Implicit(dist, grad, color);\n}\n\n\n// Viz\nvec4 DrawVectorField(vec3 p, Implicit iImplicit, vec4 iColor, float iSpacing, float iLineHalfThick)\n{\n\tvec2 spacingVec = vec2(iSpacing);\n\tvec2 param = mod(p.xy, spacingVec);\n\tvec2 center = p.xy - param + 0.5 * spacingVec;\n\tvec2 toCenter = p.xy - center;\n\n\tfloat gradParam = dot(toCenter, iImplicit.Gradient.xy) / length(iImplicit.Gradient);\n\tfloat gradLength = length(iImplicit.Gradient);\n\t\n\tbool isInCircle = length(p.xy - center) < iSpacing * 0.45 * max(length(iImplicit.Gradient.xy) / gradLength, 0.2);\n\tbool isNearLine = abs(dot(toCenter, vec2(-iImplicit.Gradient.y, iImplicit.Gradient.x))) / gradLength < iLineHalfThick + (-gradParam + iSpacing * 0.5) * 0.125;\n\t\n\tif (isInCircle && isNearLine)\n\t\treturn vec4(iColor.rgb * 0.5, 1.);\n\n\treturn iColor;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}