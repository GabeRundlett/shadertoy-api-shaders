{
    "Shader": {
        "info": {
            "date": "1700573703",
            "description": "Extruded Tron circuit, otherwise known as a multipoint nonintersecting random walk. Tap the screen to reset and produce another pattern.",
            "flags": 32,
            "hasliked": 0,
            "id": "dsGcDz",
            "likes": 99,
            "name": "Extruded Tron Circuit",
            "published": 3,
            "tags": [
                "raymarch",
                "tron",
                "random",
                "snake",
                "path",
                "walk",
                "circuit",
                "finding"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1044
        },
        "renderpass": [
            {
                "code": "/*\n\n    Extruded Tron Circuit\n    ---------------------\n    \n    I guess you'd call this a muli-path non-intersecting random walk example, \n    but for anyone old enough to remember, it's a glorified Windows screen saver. :)\n    \n    A few months ago, Shadertoy user, Gunthern, posted a rough 2D version of the \n    Windows pipe screensaver. He must have posted it at a weird time, because it \n    didn't receive a great deal of attention, but I thought it was awesome and \n    wanted to make my own one. Gunthern's was created using brute force array \n    methods, which worked great, but I wanted to use neighboring cell techniques. \n    I hacked away and got there in the end, but the non-intersecting random walk \n    code needs a logical overhaul. At some stage, I'll rewrite it, but for now it \n    works, so I'll leave it alone. By the way, if someone wants to write a nicer \n    cleaner version, I'd welcome that. :)\n    \n    The display code is pretty standard, so there's not much to garnish from that. \n    I took a while to post this because I didn't like the original result. However, \n    I got bored a week ago and added some blinking lights which added the extra \n    detail that I felt was lacking, so here it is. :) The comments have been\n    rushed, so if some of them don't make sense, it's probably because they don't. :)\n    However, I'll tidy them up in due course. I intend to write a 3D version at \n    some stage. Gunthern has one of those too. The link is below.\n    \n    \n    \n    Inspired by:\n    \n    // 2D Windows pipes.\n    Windows Pipe Dream 2D - Gunthern\n    https://www.shadertoy.com/view/mdGGRw\n    \n    // The 3D version.\n    Windows Pipe Dream 3D - Gunthern\n    https://www.shadertoy.com/view/dsGGRw\n\n*/\n \n \n// Object ID: Either the back plane, extruded object or beacons.\nint objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n    \n// Height map value.\nfloat hm(in vec2 p, float id){ \n\n    float h = .1;\n    if(id>0.) h = .15; // + id/4.;\n    return h;\n\n}\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n}\n\n\n\n/////////\n\n// IQ's unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\n// Wrapped texture lookup.\nvec4 aTx(vec2 uv){ \n    uv = mod(uv, SIZE);\n    return texelFetch(iChannel0, ivec2(uv), 0);\n}\n\n//////////\n \n\n// Global scale.\nfloat gScale = 1./4.;\n\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n \n// Global cell ID. \nvec2 gIP;\n\n// Constructing the Tron (random walk) pattern.\nvoid tr(inout vec2 oP, inout vec4 d, inout vec2 id){\n\n\n    vec2 p = oP; \n \n   \n    // Positional cell ID and local coordinates. If you didn't want to shift\n    // rows and columns, you wouldn't need any of the code above, nor would you\n    // need the three lines below.\n    vec2 ip = floor(p/gScale);\n    p -= (ip + .5)*gScale;\n    \n    \n    gIP = ip; // Record the ID for usage elsewhere.\n    oP = p; // Record the local position.\n    \n \n\n    \n    // Three distances and IDs, to represent up to three shapes per cell.\n    d = vec4(1e5);\n    \n\n\n/////////\n         \n    \n    // Cell border, border width and line width.\n    float bw = .03;\n    float lw = .325*gScale;\n    vec2 q = abs(p);\n    float sq = max(q.x, q.y) - (.5 - bw)*gScale; // Square boundary.\n\n\n    // Read in from the buffer.\n    vec4 bufA = aTx(ip);\n    // Bit value, telling us which line directions to draw.\n    int iVal = int(bufA.x);\n\n    // Neighboring directions.\n    mat4x2 dir = mat4x2(vec2(-1, 0), vec2(0, 1), vec2(1, 0), vec2(0, -1));\n \n    // Neighboring values.\n    vec4 mDir = vec4(aTx(ip + vec2(-1, 0)).x,  // Left\n                     aTx(ip + vec2(0, 1)).x,   // Up.\n                     aTx(ip + vec2(1, 0)).x,   // Right.\n                     aTx(ip + vec2(0, -1)).x); // Down.\n\n    // Left, up, right, down bits.\n    ivec4 bit = ivec4(1, 2, 4, 8);\n    bit = bit.zwxy; // Left pixel needs a right connection, up pixel needs a down one, etc.\n\n    // Connection values.\n    int cnct = 0;\n    int cnct4 = 0;\n\n    \n    // Debug: Active connections.\n    // int activeCon = 0;\n\n    // Line value.\n    float ln = 1e5;\n\n    // Render the four lines eminating from the cell center.\n    q = p;\n\n    for(int i = 0; i<4; i++){\n\n        //vec2 q2 = rot2(3.14159265/2.*float(i))*(q - dir[i]*.5);\n        \n        // If the direction bit is set, render the line.\n        if((iVal&(1<<i))>0){\n\n           if((int(mDir[i])&bit[i])>0){ // If the neighboring connection exists.\n               \n               // Line.\n               ln = min(ln, distLine(q, vec2(0), dir[i]*gScale*(.5)) - lw);\n               //ln = min(ln, sBoxS(q2, vec2(.5 + lw, lw), 0.));//(.5 + lw\n               cnct++;\n\n               cnct4 += 1<<i;\n\n           }\n           //else activeCon = 1;\n        }\n\n\n    }\n\n////////\n    \n    // Rounded curves. Commenting this out will result in sharp corners.\n    #define CURVES\n\n    #ifdef CURVES\n\n    float sm = .2*gScale;\n    vec2 sz = vec2(.5)*gScale;\n    if(cnct4==3 && iVal == 3) ln = abs(sBoxS(q - vec2(-1, 1)*sz, sz, sm)) - lw;\n    if(cnct4==6 && iVal == 6) ln = abs(sBoxS(q - vec2(1, 1)*sz, sz, sm)) - lw;\n    if(cnct4==12 && iVal == 12) ln = abs(sBoxS(q - vec2(1, -1)*sz, sz, sm)) - lw;\n    if(cnct4==9 && iVal == 9) ln = abs(sBoxS(q - vec2(-1, -1)*sz, sz, sm)) - lw;\n\n \n    #endif  \n\n    // Single square override.\n    // q = abs(fract(p) - .5);\n    \n    // If there are no connections in the cell, render a single nodule. This\n    // was an aesthetic choice, but it's not necessary.\n    if(iVal==0){\n       //ln = sBoxS(q, vec2(.25*gScale), .1*gScale);\n       ln = length(q) - .325*gScale;\n    }\n\n    // If there is just one connecting line, render round circle in the center.\n    // This is another nonfunctional aesthetic choice.\n    if(cnct==1){\n        ln = min(ln, length(q) -.4*gScale);\n        //ln = max(ln, -(length(q) -.05*gScale));\n    }\n\n    \n    // ID.\n    id = ip;\n\n    // Saving some values for later usage.\n    //d.x = max(ln, sq - gScale*.25*.5);\n    d.x = ln; //sq;\n    d.y = bufA.y>-1e-5? hash21(vec2(6, bufA.y)) : bufA.y;\n    d.z = sq;\n    d.w = float(iVal);\n \n}\n\n\n// Glow variable.\nvec3 glow;\n\n  \n// The scene's distance function: There'd be faster ways to do this, but it's\n// more readable this way. Plus, this  is a pretty simple scene, so it's \n// efficient enough.\nfloat m(vec3 p){\n    \n    // Back plane.\n    float fl = -p.z;\n    \n    // 2D Truchet distance, for the extrusion cross section.\n    vec4 d; vec2 id;\n    vec2 gP = p.xy;\n    tr(gP, d, id);\n \n    // Extrude the 2D field object along the Z-plane.\n    // A bit of face beveling to reflect the light a little more.\n    float bev = min(-d.x/gScale*2., .2)*.05; // 03;\n    float h2 = hash21(gIP + .04);\n    float h = hm(gIP, d.y);// + d.y*.25; // Cell ID, and individual curve ID.\n    float blockH = .05 + max(d.y*.25, 0.);\n    float obj = opExtrusion(d.x, p.z + blockH + h/2., h/2., .0)  - bev; \n    \n    \n    // Beveling and extruded block.\n    bev = min(-d.z/gScale*2., .2)*.025;\n    float block = opExtrusion(d.z, p.z + blockH/2., blockH/2., .0) - bev;\n    fl = min(fl, block); \n    fl -= smoothstep(0., .125, (abs(fract(d.x*32.) - .5) - .25)/32.)*.25;\n    \n    // Directional ray collision with the square cell boundaries.\n    vec2 rC = (gDir.xy*gScale - gP)/gRd.xy; // For 2D, this will work too.\n    \n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... I'm not entirely sure it's\n    // necessary here, but it stops artifacts from appearing with other \n    // non-rectangular grids.\n    //gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0015;\n    gCD = max(min(rC.x, rC.y), 0.) + .0015; // Adding a touch to advance to the next cell.\n \n \n    // Last minute glow code.\n    float rW = .05*gScale;\n    if(obj<fl && d.y>-1e-5){//\n    \n        // Color.\n        float id2 = hash21(vec2(d.y, 8));\n        vec3 sCol = .5 + .45*cos(6.72831589*id2/4. + vec3(0, 1, 2.)*1.5);\n        if(hash21(vec2(2, d.y))<.5) sCol = mix(sCol ,sCol.yxz, .9);\n \n        \n        d.x = min(d.x, gCD);\n        float rnd = hash21(gIP + .01);\n        rnd = smoothstep(.8, .95, sin(6.2831589*rnd + iTime*2.))*2. + .25;\n        \n        // Add the glow.\n        glow += sCol*rnd*64./(1. + obj*obj*32.)*smoothstep(0., .35, -(d.x + rW));\n    \n    }\n    \n    // Object ID.\n    objID = fl<obj? 0 : 1;\n    \n    // Minimum distance for the scene.\n    return min(fl, obj);\n    \n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not affordable for slower machines.\n    const int iter = 32; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(rd)*.5;\n    gRd = rd; \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<iter; i++){\n\n        float d = m(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(min(d*.7, gCD), .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = m(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n  \n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(in vec3 p) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = m(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n\n\nvoid mainImage(out vec4 c, vec2 u){\n\n    \n    // Aspect correct coordinates. Only one line necessary.\n    u = (u - iResolution.xy*.5)/iResolution.y;    \n    \n    // Unit direction vector, camera origin and light position.\n    vec3 r = normalize(vec3(u, 1)), o = vec3(iTime/2., 0, -3), l = o + vec3(.5, 1, 1.5);\n    \n    // Rotating the camera about the XY plane.\n    r.yz = rot2(-.2)*r.yz;\n    r.xz = rot2(-cos(iTime*3.14159/32.)/8.)*r.xz;\n    r.xy = rot2(sin(iTime*3.14159/32.)/8.)*r.xy; \n    \n  \n    \n    // Standard raymarching setup.\n    float d, t = hash31(o + r + fract(iTime))*.25;\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(r)*.5;\n    gRd = r; \n\n    // Glow initialization.\n    glow = vec3(0);\n    \n    // Raymarch.\n    for(int i = min(iFrame, 0); i<96; i++){ \n        \n        vec3 p = o + r*t;\n        d = m(p); // Surface distance.\n        // Surface hit -- No far plane break, since it's just the floor.\n        if(abs(d)<.001) break; \n        t += min(d*.9, gCD);  // Advance the overall distance closer to the surface.\n         \n    }\n    \n    \n    vec3 svGlow = glow;\n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int gObjID = objID;\n    \n \n \n    // Hit point and normal.\n    vec3 p = o + r*t, n = nr(p); \n    \n    \n    \n    // Basic point lighting.   \n    vec3 ld = l - p;\n    float lDist = length(ld);\n    ld /= lDist; // Light direction vector.\n    float at = 1./(1. + lDist*lDist*.05); // Attenuation.\n    \n    // Very, very cheap shadows -- Not used here.\n    //float sh = min(min(m(p + ld*.08), m(p + ld*.16)), min(m(p + ld*.24), m(p + ld*.32)))/.08*1.5;\n    //sh = clamp(sh, 0., 1.);\n    float sh = softShadow(p, l, n, 8.); // Shadows.\n    float ao = calcAO(p, n); // Ambient occlusion.\n    \n    /*\n    // Old diffuse and specular calculations.\n    float df = max(dot(n, ld), 0.); // Diffuse.\n    float sp = pow(max(dot(reflect(r, n), ld), 0.), 32.); // Specular.\n    float fr = pow(max(1. + dot(r, n), 0.), 2.); // Fresnel.\n    \n    // UV texture coordinate holder.\n    vec2 uv = p.xy;\n    */\n    \n    // 2D pattern face distace -- Used to render borders, etc.\n    //scale *= 3.;\n    vec4 d4; vec2 vID;\n    vec2 p2 = p.xy;\n    tr(p2, d4, vID);\n    \n    // Minimum tile object index.\n    int index = 0;//(d4.x<d4.y && d4.x<d4.z)? 0 : d4.y<d4.z? 1 : 2;\n    // 2D object face distance and ID.\n    float obj2D = d4[index];\n    vec2 id = vID*scale;\n    \n    // Object heights.\n    float h2 = hash21(gIP + .04);\n    float blockH = .05 + max(d4.y*.25, 0.);\n    float h = hm(gIP, d4.y) + blockH;// + h2*.125;\n \n \n    // Texture position.\n    vec3 txP = vec3(p2, p.z);\n    vec3 txN = n;\n    vec3 tx = tex3D(iChannel1, txP/2., txN); \n\n     \n\n  \n    // Standard material properties: Roughness, matType and reflectance.\n    //\n    float roughness = .2; // Lower roughness reflects more light, as expected.\n    float matType = 0.; // Dielectric (non conducting): 0, or metallic: 1.\n    float reflectance = .5; // Reflective strength.\n    \n    \n    // Object color.\n    vec3 oCol = vec3(0);\n    \n    // Use whatever logic to color the individual scene components. I made it\n    // all up as I went along.\n    //\n    if(gObjID == 0){\n    \n    \n       // Floor, or wall, depending on perspective.\n       oCol = vec3(.125);\n       matType = 1.; // Metallic material.\n       roughness = .5;\n       \n       \n    }\n    else if(gObjID==1){\n    \n        // Extruded Tron pattern:\n\n        // Noise texture, used for a hacky scratched surface look.\n        // Usually, you'd tailor this to specific material needs.\n        vec3 txR = txP;\n        txR.xy *= rot2(-3.14159/6.);\n        vec3 rTx = tex3D(iChannel2, txR*vec3(.5, 3, .5), txN);\n        float rGr = dot(rTx, vec3(.299, .587, .114));\n \n        \n        // The tile base color.\n         \n        ////////////////    \n\n        float rW = .125*gScale; // Rim width.\n        float sf = .007; // Smoothing factor.\n        float ew = .02; // Edge width.\n\n\n        \n \n        // Face rim and face distance values for edge rendering. \n        float b = abs(obj2D) - .01;\n        float pH = p.z + h - .04;\n        b = max(b, (p.z + h - .02));\n        \n\n        // Object color.\n        vec3 sCol = vec3(.25);\n         \n        \n        \n        // Applying edges to the light color.   \n        vec3 lgtCol = mix(min(sCol*1.4, 1.), vec3(1), .2);\n        lgtCol = mix(lgtCol, oCol*.15, (1. - smoothstep(0., sf, -d4.z)));\n\n\n        // Applying face color patterns, edges, etc..\n        oCol = sCol*.5;\n        oCol = mix(oCol, oCol*.15, (1. - smoothstep(0., sf, pH)));\n        oCol = mix(oCol, sCol, (1. - smoothstep(0., sf, pH + ew)));\n        oCol = mix(oCol, oCol*.15, (1. - smoothstep(0., sf, obj2D + rW)));\n\n        // Mixing in the light color.\n        oCol = mix(oCol, lgtCol, (1. - smoothstep(0., sf, obj2D + rW + ew)));\n        //roughness = mix(.6,.2, (1. - smoothstep(0., sf, obj2D + rW + ew)));\n        oCol *= tx*.6 + .9;\n\n        // Dielectic material roughness.\n\n        roughness = .3;\n        roughness *= (rGr*.4 + .6);\n       \n\n        \n    }\n    \n    \n    \n    // More last minute dark texturing and glow.\n    tx = tex3D(iChannel2, p/3., n);\n    oCol *= tx*2. + .2;\n    oCol = oCol + oCol*svGlow;  \n    \n\n    /*\n    // Shiny... Doesn't really work here. Perhaps with extra tweaking.\n    // Requires \"Forest\" cube map loaded into \"iChannel3\".\n    // Specular reflection.\n    vec3 hv = normalize(-r + ld); // Half vector.\n    vec3 ref = reflect(r, n); // Surface reflection.\n    vec4 refTx = texture(iChannel3, -ref.yzx, 1.); refTx *= refTx; // Cube map.\n    float spRef = pow(max(dot(hv, n), 0.), 8.); // Specular reflection.\n    //spRef = mix(spRef/4., spRef, 1. - smoothstep(0., .01, d + .05));   \n    float rf = (matType < .5)? 8. : 1.;//mix(.25, 4., 1. - smoothstep(0., .01, d + .05));\n    oCol += oCol*reflectance*spRef*refTx.zyx*rf; //smoothstep(.03, 1., spRef) \n    */ \n\n\n    // I wanted to use a little more than a constant for ambient light this \n    // time around, but without having to resort to sophisticated methods, then I\n    // remembered Blackle's example, here:\n    // Quick Lighting Tech - blackle\n    // https://www.shadertoy.com/view/ttGfz1\n    float am = pow(length(sin(n*2.)*.5 + .5)/sqrt(3.), 2.)*1.5; // Studio.\n    //float am = length(sin(n*2.)*.5 + .5)/sqrt(3.)*smoothstep(-1., 1., -n.z); // Outdoor.\n \n    // Cook-Torrance based lighting.\n    vec3 ct = BRDF(oCol, n, ld, -r, matType, roughness, reflectance);\n        \n    // Combining the ambient and microfaceted terms to form the final color:\n    // None of it is technically correct, but it does the job. Note the hacky \n    // ambient shadow term. Shadows on the microfaceted metal doesn't look \n    // right without it... If an expert out there knows of simple ways to \n    // improve this, feel free to let me know. :)\n    c.xyz = (oCol*am*(sh*.5 + .5) + ct*(sh))*ao*at;\n     \n \n    // Save the linear color to the backbuffer.\n    c = pow(max(c, 0.), vec4(1./2.2)); \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nconst float SIZE = 36.;\nconst float scale = 1./SIZE;\n\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    //f.xy = mod(f.xy, 1.);\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\n// Hacked together from IQ, Nimitz and Fabrice's hash functions.\nvec3 hash23(in vec2 f){\n     \n    uvec2 p = floatBitsToUint(f);\n    uint  n = 1103515245U*((p.x)^(p.y>>3U));\n    // Converting a uint to a uvec3:\n    // These numbers came from here:\n    // Quality hashes collection WebGL2 - Nimitz.\n    // https://www.shadertoy.com/view/Xt3cDn\n    uvec3 u3 = uvec3(1, 16807U, 48271U);\n    return vec3(((u3*n) >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n    \n    // Dave Hoskins's reliable hash function.\n\t//vec3 p3 = fract(f.xyx*vec3(.1031, .1030, .0973));\n    //p3 += dot(p3, p3.yxz + 423.123);\n    //return fract((p3.xxy+p3.yzz)*p3.zyx);\n     \n}\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n///////////////////////////\nconst float PI = 3.14159265;\n\n// Microfaceted normal distribution function.\nfloat D_GGX(float NoH, float roughness) {\n    float alpha = pow(roughness, 4.);\n    float b = (NoH*NoH*(alpha - 1.) + 1.);\n    return alpha/(PI*b*b);\n}\n\n// Surface geometry function.\nfloat G1_GGX_Schlick(float NoV, float roughness) {\n    //float r = roughness; // original\n    float r = .5 + .5*roughness; // Disney remapping.\n    float k = (r*r)/2.;\n    float denom = NoV*(1. - k) + k;\n    return max(NoV, .001)/denom;\n}\n\nfloat G_Smith(float NoV, float NoL, float roughness) {\n    float g1_l = G1_GGX_Schlick(NoL, roughness);\n    float g1_v = G1_GGX_Schlick(NoV, roughness);\n    return g1_l*g1_v;\n}\n\n// Bidirectional Reflectance Distribution Function (BRDF). \n//\n// If you want a quick crash course in BRDF, see the following:\n// Microfacet BRDF: Theory and Implementation of Basic PBR Materials\n// https://www.youtube.com/watch?v=gya7x9H3mV0&t=730s\n//\nvec3 BRDF(vec3 col, vec3 n, vec3 l, vec3 v, \n          float type, float rough, float fresRef){\n     \n    vec3 h = normalize(v + l); // Half vector.\n\n    // Standard BRDF dot product calculations.\n    float nv = clamp(dot(n, v), 0., 1.);\n    float nl = clamp(dot(n, l), 0., 1.);\n    float nh = clamp(dot(n, h), 0., 1.);\n    float vh = clamp(dot(v, h), 0., 1.);  \n\n\n    // Specular microfacet (Cook- Torrance) BRDF.\n    //\n    // F0 for dielectics in range [0., .16] \n    // Default FO is (.16 * .5^2) = .04\n    // Common Fresnel values, F(0), or F0 here.\n    // Water: .02, Plastic: .05, Glass: .08, Diamond: .17\n    // Copper: vec3(.95, .64, .54), Aluminium: vec3(.91, .92, .92), Gold: vec3(1, .71, .29),\n    // Silver: vec3(.95, .93, .88), Iron: vec3(.56, .57, .58).\n    vec3 f0 = vec3(.16*(fresRef*fresRef)); \n    // For metals, the base color is used for F0.\n    f0 = mix(f0, col, type);\n    vec3 F = f0 + (1. - f0)*pow(1. - vh, 5.);  // Fresnel-Schlick reflected light term.\n    // Microfacet distribution... Most dominant term.\n    float D = D_GGX(nh, rough); \n    // Geometry self shadowing term.\n    float G = G_Smith(nv, nl, rough); \n    // Combining the terms above.\n    vec3 spec = F*D*G/(4.*max(nv, .001));\n\n\n    // Diffuse calculations.\n    vec3 diff = vec3(nl);\n    diff *= 1. - F; // If not specular, use as diffuse (optional).\n    diff *= (1. - type); // No diffuse for metals.\n\n\n    // Combining diffuse and specular.\n    // You could specify a specular color, multiply it by the base\n    // color, or multiply by a constant. It's up to you.\n    return (col*diff + spec*PI);\n  \n}\n////////////////////",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nint dr(vec2 uv){\n    \n    // Obtain a random direction.\n    uv = mod(uv, SIZE);\n    return int(1024.*hash31(vec3(uv, float(iFrame))))&3;\n     \n}\n\nvec4 tx(vec2 uv){ \n    // Wrapped texel fetch.\n    uv = mod(uv, SIZE);\n    return texelFetch(iChannel0, ivec2(uv), 0);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n\n\n    // Reject any pixels outside the wrapping area to lessen the GPU load.\n    if(fragCoord.x>SIZE || fragCoord.y>SIZE) discard;\n\n  \n    // Skipping a few frames to slow down the animation and faster machines.\n    float frameRate = 1./iTimeDelta;\n    int iFr = int(round(frameRate/60.));\n    if(iFrame%iFr>0){       \n       fragColor = tx(fragCoord);\n       return;        \n    }\n   \n    if(textureSize(iChannel0, 0).x<2 || iFrame==0 || iMouse.z>0.){\n        \n        // Starting conditions. The following is a bit messy, but I'm\n        // essentially spacing out some starting points on a grid.\n        \n        vec4 rVal = vec4(0, -1, 0, 0);\n        vec2 ip = floor(fragCoord);\n        #if 0\n        if(length(mod(ip, 1./scale) - .0 - floor((1./scale/2.))) < 0.01){\n          rVal.x = .5;\n          rVal.z = 1.;\n        }\n        #else\n        vec2 mIP = mod(ip, 1./scale);\n        vec2 repIp = mIP;\n        float rSc = 6.;\n        if(mod(floor(repIp.y/rSc), 2.)<.5){\n            repIp.x += floor(rSc/2.); // Offset rows.\n            mIP.x += floor(rSc/2.);\n        }\n        \n        repIp = mod(repIp, rSc);\n        mIP = mod(mIP, 1./scale);\n        \n        if(repIp.x == 0. && repIp.y == 0.){ \n            rVal.x = .5;\n            mIP = floor(mIP/rSc);\n            float colID = (mIP.x + mIP.y*rSc)/(rSc*rSc);\n            //float colID = hash21(mIP + .157);\n            rVal.y = colID;\n            rVal.z = 1.;\n        \n        }\n        #endif \n        \n        fragColor = rVal;\n \n        \n    }else{\n        \n       \n        \n        // Currect pixel value and neighboring cell pixel values.\n        vec4 a = tx(fragCoord), // Current.\n              \n        lft = tx(fragCoord + vec2(-1, 0)), // Left\n        up = tx(fragCoord + vec2(0, 1)), // Up.\n        rgt = tx(fragCoord + vec2(1, 0)), // Right.\n        dwn = tx(fragCoord + vec2(0, -1)); // Down.\n \n              \n        ////////\n        // No more than two connections allowed.\n        int cn = 0;\n        //ivec4 dCn = ivec4(0);\n        int iVal = int(a.x);\n        ivec4 iVal4 = ivec4(lft.x, up.x, rgt.x, dwn.x);\n        for(int i = 0; i<4; i++){\n            if((iVal&(1<<i))>0) cn++;\n\n        }        \n        \n        ////////\n         \n        // On the first try, don't connect from both ends.\n        int maxCons = 2; \n        \n        // For the initialized cell, only allow connections from one\n        // side... This avoids duplicates from forming.\n        if(a.z==1.) maxCons = 1; // Set the maxium connections to one.\n         \n  \n          \n        if(a.x==0.){\n        \n            // If the current cell is empty, but a neighboring cell has\n            // an existing connection.\n\n            int rnd = dr(fragCoord); // Obtain a random direction for this pixel.\n            // If the random direction of the empty cell is left and the \n            // left cell is not empty, flag left.\n\n\n            // At this point we're opening a connection to the possibility of\n            // of being activated from it's neighboring pixel. Most form, but not\n            // all, since some connections will be blocked by another worm passing\n            // by. Therefore, when equilibrium for this pass has been reached, open \n            // connections that haven't formed need to be deactivated.\n\n\n            if(cn<maxCons)if(rnd==0 && (int(lft.x)&4)>0){ a.x = 1.; a.y = lft.y; cn++; } // Flag left.\n            if(cn<maxCons)if(rnd==1 && (int(up.x)&8)>0){ a.x = 2.; a.y = up.y; cn++; }   // Flag up.\n            if(cn<maxCons)if(rnd==2 && (int(rgt.x)&1)>0){ a.x = 4.; a.y = rgt.y; cn++; } // Flag right.\n            if(cn<maxCons)if(rnd==3 &&(int(dwn.x)&2)>0){ a.x = 8.; a.y = dwn.y; cn++; } // Flag down.\n \n        }\n        else\n        {  \n        \n            // If the current cell is not empty, but a neighboring one is empty.\n \n\n            // 1 - left, 2 - up, 4 - right, 8 - down.\n  \n            if(hash31(vec3(fragCoord + .5, iTime))<1.5){\n            // If the left cell is empty and the random direction of that particular \n            // cell is right (connecting the current cell) flag the left direction.\n            if(cn<maxCons)if(lft.x==0. && dr(fragCoord + vec2(-1, 0)) == 2){ a.x += 1.; cn++;  }// Flag left.\n            if(cn<maxCons)if(up.x==0. && dr(fragCoord + vec2(0, 1)) == 3){ a.x += 2.; cn++; } // Flag up.\n            if(cn<maxCons)if(rgt.x==0. && dr(fragCoord + vec2(1, 0)) == 0){ a.x += 4.; cn++; } // Flag right.\n            if(cn<maxCons)if(dwn.x==0. && dr(fragCoord + vec2(0, -1)) == 1){ a.x += 8.; cn++; }// Flag down.\n             \n            }\n            else {\n            \n                if(cn<maxCons){\n                   if(lft.x==0. && dr(fragCoord + vec2(-1, 0)) == 2){ a.x += 1.;  }// Flag left.\n                   if(up.x==0. && dr(fragCoord + vec2(0, 1)) == 3){ a.x += 2.;  } // Flag up.\n                   if(rgt.x==0. && dr(fragCoord + vec2(1, 0)) == 0){ a.x += 4.;  } // Flag right.\n                   if(dwn.x==0. && dr(fragCoord + vec2(0, -1)) == 1){ a.x += 8.;  }// Flag down.\n                }  \n                \n            } \n        \n         \n         }  \n         \n         //if(a.w>8.) a.z = 0.;\n         \n         a.w++;\n         \n           \n         if(a.w>256.){\n         \n             // When every worm can go no further, you need to check for\n             // open connections (when another worm has blocked the path)\n             // and deactivate them.\n             if((int(lft.x)&4)==0 && (int(a.x)&1)>0) a.x -= 1.;\n             if((int(up.x)&8)==0 && (int(a.x)&2)>0) a.x -= 2.;\n             if((int(rgt.x)&1)==0 && (int(a.x)&4)>0) a.x -= 4.;\n             if((int(dwn.x)&2)==0 && (int(a.x)&8)>0) a.x -= 8.;\n              \n              \n             a.w = 0.; // Restart the counter.\n             // If it's finished in one direction, unflag the starting position. \n             // This is optional, but I like it becausse it produces a more packed \n             // and complete pattern.\n             a.z = 0.; \n             \n         \n         }\n \n          \n        \n        fragColor = a;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}