{
    "Shader": {
        "info": {
            "date": "1582150884",
            "description": "yo",
            "flags": 0,
            "hasliked": 0,
            "id": "wtySRh",
            "likes": 7,
            "name": "Day 62",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 484
        },
        "renderpass": [
            {
                "code": "\nvec3 glow = vec3(0);\nvec3 glowG = vec3(0);\n#define pmod(p, x) mod(p, x) - 0.5*x\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define mx (iTime*(0.8 )+ sin(iTime*2.)*0.4 + 20.*iMouse.x/iResolution.x)\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n\tvec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\nvec3 path(float z){\n    z*= 0.4;\n\treturn vec3(\n    \tsin(z),\n        cos(z),\n        0.\n    )*1.;\n\n}\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n#define tunnW 0.4\n#define md  vec2(1./10., 1.)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nvec3 pid;\nfloat did;\n\nvec2 sdBoxy(vec3 p, vec3 pC){\n\tvec2 d = vec2(10e5);\n    did = 1.;\n    float iters = 5.;\n    vec3 boxSz = vec3(md.x*0.46,0.1,1.4*md.y/10.);\n    \n    d.x = min(d.x, sdBox(pC,boxSz ));\n    pC.y += tunnW*0.47;\n    \n    for (float i = 0.; i < iters; i++){\n        boxSz.xz *= 0.7;\n        boxSz.y *= 1.05;\n        \n        float dB =sdBox(pC,boxSz );\n        if(d.x < -dB ){\n        \td.x = -dB;\n        } else {\n        \tdid++;\n        }\n        \n    }\n    \n    return d;\n}\n\nvec2 sdInner(vec3 p, vec3 pC){\n\tvec2 d = vec2(10e5);\n    float iters = 4.;\n    vec3 boxSz = vec3(md.x*0.46,0.1,1.4*md.y/10.)*0.3;\n    for (float i = 0.; i < 2.; i++){\n        pC = abs(pC);\n    \n        //pC.y -= 0.01;\n        pC.xz *= rot(0.);\n    }  \n    pC.y += tunnW*0.00;\n    d.x = min(d.x, sdBox(pC,boxSz ));\n\n    return d;\n}\n\nvec3 pCG;\nvec2 sdInnerB(vec3 p, vec3 pCG){\n\tvec2 d = vec2(10e5);\n    float iters = 4.;\n    vec3 boxSz = vec3(md.x*0.46,0.04,1.4*md.y/10.)*0.3;\n    for (float i = 0.; i < 2.; i++){\n        pCG = abs(pCG);\n    \n        //pC.y -= 0.01;\n        pCG.xz *= rot(0.);\n    }  \n    \n    \tpCG.y -= tunnW*0.1;\n    for(int i = 0; i < 2; i++){\n    \tpCG = abs(pCG);\n        pCG.xz *= rot(0.1);\n        pCG.xy *= rot(0.5);\n        pCG.x += 0.01;\n        //d.x = min(d.x, sdBox(pCG,boxSz ));\n        //pCG.x += 0.1;\n    }\n\n    return d;\n}\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\tp -= path(p.z);\n    \n    //d.x = min(d.x, -length(p.xy) + 0.6);\n    vec3 pC = vec3(atan(p.y,p.x)/tau,length(p.xy),p.z);\n   \t\n    vec3 pCC = pC;\n    pid = floor(vec3(pC.x/md.x, pC.y, pC.z/md.y));\n    vec3 pidB = floor(vec3(pC.x/md.x - 0.5, pC.y, pC.z/md.y));\n    pC.x = pmod(pC.x, md.x);\n    pC.z = pmod(pC.z, md.x*tau*0.4);\n    \n    pC.y -= tunnW;\n    d.x = min(d.x, sdBoxy(p, pC).x);\n    pC.y += 0.12;\n    pC.x = pmod(pC.x, md.x);\n    //pC.x -= md.x*0.5;\n    \n    float dTube = length(pC.xy) - 0.01;\n    \n    d.x = min(d.x, dTube);\n    \n    \n    glowG += exp(-dTube*200. )*pal(0.78, 0.2, vec3(4.,3.,1.), vec3(1.,1.,1.),2.9 )*1.2;\n\t\n    glowG += exp(-dTube*100. )*pal(0.98, 0.2, vec3(1.,2.,1.), vec3(4.,4.3,2.6),2.9 )*pow(abs(sin(p.z*0.2 - iTime*0.5+ pidB.x) ), 300.)*1.;\n        \n    pCG = pC;\n    d.x = min(d.x, sdInner(p, pC).x);\n    float innB = sdInnerB(p, pCG).x;\n    d.x = min(d.x, innB);\n    glowG += exp(-innB*200. )*pal(0.98, 0.2, vec3(1.,2.,1.), vec3(4.,2.3,2.6),5.9 )*0.5;;\n\n    d.x *= 0.5;\n    glow += exp(-d.x*220. );\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e6);\n\tp = ro;\n    hit = false; t = 0.;\n    \n    for(int i = 0; i < 250 + min(0,iFrame); i++){\n    \td = map(p);\n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\t\n    vec3 ro = vec3(0);\n    ro.z += mx;\n    ro += path(ro.z);\n    vec3 lookAt = vec3(0,0,ro.z + 2.);\n    lookAt += path(lookAt.z);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    rd.xy *= rot(sin(iTime)*0.3);\n    \n    bool hit; float t; vec3 p;\n    vec2 d = march(ro, rd, p, t, hit);\n    \n    if(hit){\n    \tcol += pal(0.08, 0.2, vec3(4.,1.39,1.4 + sin(p.z)*0.4), vec3(1.,1.,1.),-6.4 - did*0.3)*0.24;\n        //col += pal(0.5, 0.4, vec3(3.,1.,1.), vec3(1.,1.,2.),2.6 - did*2.3 )*0.09;\n        //col += pal(0.5, 0.6, vec3(3.,1.1,1.), vec3(1.,1.,2.),0.4 - did*0.6 )*0.09;\n    \t\n    } \n    \n    col -= glow*0.008;\n    col += glowG*0.02;\n    col *= 1.2;\n    col.b *= 1.2;\n    col *= 5.;\n    col = mix(col,vec3(1.),t*0.2);\n    //col += pal(0.5, 0.5, vec3(4.,2.,1.), vec3(1.,1.,1.),2.9 + pid.x + did*2.);\n    col = pow(col, vec3(0.45));\n    col *= 1. - pow(max(abs(uv.x) - 0.25,0.),6. )*10.;\n    col *= 1. - pow(abs(uv.y) - 0.25,3. )*20.;\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}