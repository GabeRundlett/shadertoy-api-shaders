{
    "Shader": {
        "info": {
            "date": "1585198795",
            "description": "chrysalis",
            "flags": 0,
            "hasliked": 0,
            "id": "3dfyRX",
            "likes": 0,
            "name": "chrysalis",
            "published": 3,
            "tags": [
                "chrysalis"
            ],
            "usePreview": 0,
            "username": "haptix",
            "viewed": 228
        },
        "renderpass": [
            {
                "code": "float pi = acos(-1.);\nfloat glo = 0.;\n\nmat2 rot (float rad)\n{\n    return mat2(cos(rad), sin(rad), -sin(rad), cos(rad));\n}\n\nvec2 box(vec3 p, vec3 b, float matId)\n{\n    vec3 q = abs(p) - b;\n    return vec2(length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.), matId);\n}\n\nvec3 kif(vec3 p)\n{    \n    float t = iTime + 65.;\n    \n    for(int i = 0; i < 6; i++)\n    {\n        p.xy *= rot(.061*t);\n        \n        p = abs(p) - vec3(.05*cos(t*.21) + .31,\n                          .05*sin(t*.27) + .35,\n                          .05*sin(t*.37) + .37);\n        \n        p.yz *= rot(.043*t);\n    }\n    \n    return p;\n}\n\nvec2 add(vec2 m1, vec2 m2)\n{\n    return m1.x < m2.x ? m1 : m2;\n}\n\nvec2 map(vec3 p)\n{   \n    p = kif(p);\n    \n    vec2 m1 = box(p, vec3(.07, .8, 1.), 1.);\n    p.x -= .25;\n    vec2 m2 = box(p, vec3(.06, .75, .85), 2.);\n    p.x += .5;\n    vec2 m3 = box(p, vec3(.06, .75, .85), 3.);\n    vec2 m = add(m1, m2);\n    m = add(m, m3);\n    glo += .1 / (.1 + m1.x*m1.x*m1.x*2500.);\n    return m;\n}\n\nvec2 tr(vec3 ro, vec3 rd)\n{\n    float far = 15.;\n\tvec2 h,t= vec2(.01);\n\tfor(int i = 0; i < 384; i++)\n\t{\n\t\th = map(ro + rd*t.x);\n\t\tif(h.x < .00001 || t.x > far)\n\t\t\tbreak;\n\t\tt.x += h.x;\n        t.y = h.y;\n  \t}\n    if(t.x > far)\n        t.y = 0.;\n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ro = vec3(.6*cos(-.1*iTime),\n                   .91*sin(-.1*iTime),\n                   -7.);\n\tvec3 camTarget = vec3(0.);\n\tvec3 up = vec3(0., 1., 0.);\n\tvec3 camDir = normalize(camTarget - ro);\n\tvec3 camRight = normalize(cross(up, ro));\n\tvec3 camUp = normalize(cross(camDir, camRight));\n    vec3 lightPos = vec3(1.5, 1.5, -30.);\n  \n\tvec2 screenPos = -1. + 2. * gl_FragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec2 eps = vec2(0., .01);\n\tvec3 rd = normalize(camRight*screenPos.x + camUp*screenPos.y + camDir);\n  \n\tvec2 t = tr(ro, rd);\n\n    vec3 colRot = vec3(sin(.317*(iTime + 44.)),\n                       sin(.151*(iTime + 55.)),\n                       sin(.227*(iTime + 79.))) + 1.2;\n\n    if (t.y > 0.)\n    {\n        vec3 hit = ro + rd*t.x;\n        vec3 lightDir = normalize(lightPos - hit);\n        \n        vec3 norm = normalize(map(hit).x - vec3(map(hit - eps.yxx).x,\n                              \t\t\t\t\tmap(hit - eps.xyx).x,\n                              \t\t\t\t\tmap(hit - eps.xxy).x));\n        \n        float diff = max(0., dot(lightDir, norm));\n        float spec = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 200.);\n        float ao = clamp(map(t.x + norm*.5).x / .5, 0., 1.);\n\n        vec3 col = .1 * colRot;\n        if(t.y == 2.)\n        \tcolRot = vec3(.2);\n        else if(t.y == 3.)\n            colRot = vec3(.5);\n        \n        col *= .12 * ao;\n        col += .35 * diff * colRot.yzx;\n        col += 1. * spec * vec3(1., 1., 1.);\n        col += glo*.008*colRot;\n        \n        fragColor = vec4(col, 1.);\n    }\n    else\n    \tfragColor = vec4(glo*.008*colRot.zyx, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}