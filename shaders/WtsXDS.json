{
    "Shader": {
        "info": {
            "date": "1564118787",
            "description": "CHALLENGE: Create procedural principled PBR materials (without textures!!) by replacing the getMainMaterial() function in the Common tab. Enable displacement mapping for best quality.",
            "flags": 32,
            "hasliked": 0,
            "id": "WtsXDS",
            "likes": 7,
            "name": "[PBRMAT] Tiles",
            "published": 3,
            "tags": [
                "procedural",
                "material",
                "pbr"
            ],
            "usePreview": 0,
            "username": "markusm",
            "viewed": 972
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.4545));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Abstracted Material Interface                          \n// In Common tab so no texture functions are available :)\n\n// 0 = Plane, 1 = Plane + Sphere\n#define SHAPE  1\n\n// 0 for bump mapping (fast), 1 for better quality displacement mapping\n#define DISPLACE 0\n\n#define OBJ_PLANE  \t1.\n#define OBJ_SPHERE \t2.\n\n// Sends secondary rays to allow scene reflections\n#define useReflections false\n\nstruct MaterialInfo {\n    vec3  baseColor;\n    float subsurface;\n    float roughness;\n    float metallic;\n    float specular;\n    float specularTint;\n    float clearcoat;\n    float clearcoatGloss;\n    float anisotropic;\n    float sheen;\n    float sheenTint;\n    float bump;\n};\n\n// --- Mixes two materials into the destination material using the given blend factor\nvoid mixMaterials( in MaterialInfo source1, in MaterialInfo source2, inout MaterialInfo dest, float blend)\n{\n    dest.baseColor = mix(source1.baseColor, source2.baseColor, blend);\n    dest.subsurface = mix(source1.subsurface, source2.subsurface, blend);\n    dest.roughness = mix(source1.roughness, source2.roughness, blend);\n    dest.metallic = mix(source1.metallic, source2.metallic, blend);\n    dest.specular = mix(source1.specular, source2.specular, blend);\n    dest.specularTint = mix(source1.specularTint, source2.specularTint, blend);\n    dest.clearcoat = mix(source1.clearcoat, source2.clearcoat, blend);\n    dest.clearcoatGloss = mix(source1.clearcoatGloss, source2.clearcoatGloss, blend);\n    dest.anisotropic = mix(source1.anisotropic, source2.anisotropic, blend);\n    dest.sheen = mix(source1.sheen, dest.sheen, blend);\n    dest.sheenTint = mix(source1.sheenTint, source2.sheenTint, blend);\n    dest.bump = mix(source1.bump, source2.bump, blend);\n}\n    \nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n    \n// Info about hit attributes\nstruct SurfaceInteraction {\n    float id;\n    vec3 incomingRayDir;\n    vec3 point;\n    vec3 normal;\n    vec3 tangent;\n    vec3 binormal;\n    float objId;\n};\n\n// --- Compute Sky color    \nvec3 getSky(Ray ray)\n{\n   vec3 col = vec3(1);  \n   float t = 0.5 * ray.direction.y + 0.5;\n   col *= mix(vec3(1),vec3(.5,.7,1), t);\n   return col;\n}\n    \n// --- Get secondary material (unused for now)\nvoid getUtilityMaterial(vec2 uv, SurfaceInteraction inter, out MaterialInfo mat)\n{\n\tmat.baseColor = vec3(1, 1, 1);\n}\n\n// ------------------------------------- Main material code\n\n// IQ's signed box formula.\nfloat sBox(vec2 p, vec2 b, float r) {\n  vec2 d = abs(p) - b + r;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\n// Creates a mask for the border of an sdf \nfloat borderMask(float dist, float width)\n{\n\treturn clamp(dist + width, 0.0, 1.0) - clamp(dist, 0.0, 1.0);\n}\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// Noise from Morgan McGuire, https://www.shadertoy.com/view/4dS3Wd\n#define NUM_NOISE_OCTAVES 5\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n#define rot(a) mat2( cos(a),-sin(a),sin(a),cos(a) )\n\n// Shane's box divide formula from https://www.shadertoy.com/view/XsGyDh\nvec2 boxDivide(in vec2 p, in vec2 res) {\n    vec2 ip = floor(p); p -= ip;\n    vec2 l = vec2(1), lastL;    \n    float r = hash21(ip);\n    \n    for(int i=0; i<6; i++) {\n        r = fract(dot(l + r, vec2(123.71, 439.43)))*.4 + (1. - .4)/2.;\n        \n        lastL = l;\n        if(l.x>l.y) { p = p.yx; l = l.yx;  }\n         \n        if(p.x<r) { l.x /= r; p.x /= r; }\n        else { l.x /= (1. - r); p.x = (p.x - r)/(1. - r); }\n        \n        if(lastL.x>lastL.y){ p = p.yx; l = l.yx;  }\n    }\n    p -= 0.5;\n    \n    // Create the id\n    float id = hash21(ip + l);\n    \n  \t// Slighly rotate the tile based on its id  \n    p *= rot((id - 0.5)* 0.15);\n\n    // Gap, or morter, width. Using \"l\" to keep it roughly constant.\n    vec2 th = l*.02;\n    // Take the subdivided space and turn them into rounded pavers.\n    float c = sBox(p, vec2(.5) - th, noise(p)* 0.5);\n    // Smoothing factor.\n    float sf = 2./res.x*length(l);\n    // Individual tile ID.\n    \n    // Return distance and id\n    return vec2(c, id);\n}\n\n// --- Main Material Entry Point\nvoid getMainMaterial(vec2 res, SurfaceInteraction inter, out MaterialInfo mat)\n{\n    vec2 uv = inter.objId == OBJ_PLANE ? inter.point.xy : inter.point.xz;\n    if (inter.objId == OBJ_PLANE ) {\n    \tuv /= 2.5;// Make plane uv larger\n    }\n    uv.x += 7.0;\n\tvec2 box = boxDivide(uv / 10.0, res);\n\n    float grainyNoise = fbm(uv*30.);\n    float noise = fbm(uv/1.3);\n\n    // Create three materials for the cement, the tile edges and the tile and mix them\n    \n    // --- Cement Material\n    MaterialInfo cement = MaterialInfo(vec3(.8), 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0.);\n    float mossMix = noise * 1.2 - 0.2;\n    cement.roughness = mix(0.3, 0., mossMix);\n    cement.metallic = mix(0.3, 0.5, mossMix);\n    cement.specular = grainyNoise;\n    cement.baseColor = vec3(0.678, 0.694, 0.578) * 1.5;\n    cement.baseColor = mix(cement.baseColor, vec3(0,0.5,0), mossMix);\n    cement.bump = clamp(-box.x * 5., -0.46, 0.) + grainyNoise * 0.6;\n   \n    // Tile Edge Material, edges have a lighter color than the center\n    MaterialInfo tileEdge = MaterialInfo(vec3(.8), 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0.);\n    \n    tileEdge.baseColor = mix(vec3(0.502, 0.459, 0.365), vec3(0.714, 0.706, 0.678), box.y);\n    tileEdge.roughness = 0.2;\n    tileEdge.metallic = noise * 0.4;\n    tileEdge.bump = noise;\n    \n    // Tile Material\n    MaterialInfo tile = MaterialInfo(vec3(.8), 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0.);\n    tile.baseColor = tileEdge.baseColor * 0.2;\n    tile.metallic = grainyNoise * 0.4;\n    tile.roughness = 0.;\n    tile.bump = 0.;\n    \n    // Mix tile edge with tile material\n    MaterialInfo temp;\n    mixMaterials(tile, tileEdge, temp, borderMask(box.x * (grainyNoise-0.3), noise + 0.1 ));\n    // Mix cement material\n    mixMaterials(cement, temp, mat, 1.0 - clamp(box.x * noise * 8.4, 0., 1.));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Principled PBR Shader. Except where otherwise noted:\n\n// Copyright Â© 2019 Markus Moenig Distributed under The MIT License.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// \n// Based on an collaboration with pixotronics.com\n\n#define SAMPLES 1\n#define MAXDEPTH 4.\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318\n\n#define LIGHT_ID 10.\n#define FLOOR_ID 8.\n\n#define LIGHT_TYPE_SPHERE 0\n#define LIGHT_TYPE_SUN    1\n\n#define MAT_UTILITY 1.\n#define MAT_MAIN\t2.\n\n#define EPSILON 0.0001\n#define INFINITY 1000000.\n\n#define IS_SAME_MATERIAL(id1, id2) (id1 == id2)\n\n#define clearCoatBoost 1.\n\nstruct LightInfo {\n    vec3 L;\n    vec3 position;\n    vec3 direction;\n    float radius;\n    int type;\n    bool enabled;\n};\n\nstruct Sphere {\n    float r;\n    vec3 p;\n};\n    \nstruct Plane {\n    vec3 p;\n    vec4 n;\n};\n\n\nfloat seed = 0.;\n\n#define NUM_LIGHTS 2\nLightInfo lights[NUM_LIGHTS];\n\n/* Sun/Directional Light Parameters\n\nSUN_DIRECTION   - Mean direction\nSUN_SOLID_ANGLE - The solid angle sun subtens at eye. higher value will create softer shadows.\nsunLe           - Radiance\n\n*/\n\n#define SUN_DIRECTION vec3(0.1,-0.4,0.5)\n#define SUN_SOLID_ANGLE 6.87E-2     \n#define sunLe vec3(2.)\n\n#define Le vec3(2.)\n\nvoid initScene() {\n    \n    // Sphere light\n    lights[0] = LightInfo(vec3(Le), vec3(-10,0,18), vec3(0.), 1., LIGHT_TYPE_SPHERE, true);\n    // Sun light\n    lights[1] = LightInfo(sunLe, vec3(0.), normalize(SUN_DIRECTION), 0., LIGHT_TYPE_SUN, true);\n}\n\n///////////////////////////////////////////////////////////////////////\n//////////////////////// Utility Functions ///////////////////////////\n///////////////////////////////////////////////////////////////////////\n\nvec3 linearToGamma(const in vec3 linearColor) {\n   return pow(linearColor, vec3(0.4545));\n}\n\nvec3 gammaToLinear(const in vec3 gammaColor) {\n   return pow(gammaColor, vec3(2.2));\n}\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p) {\n    vec3 p3 = fract(vec3(p) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat random() {\n   return fract(sin(seed++)*43758.5453123);\n}\n\nfloat distanceSq(vec3 v1, vec3 v2) {\n    vec3 d = v1 - v2;\n    return dot(d, d);\n}\n\nfloat pow2(float x) { \n    return x*x;\n}\n\nvoid createBasis(vec3 normal, out vec3 tangent, out vec3 binormal){\n    if (abs(normal.x) > abs(normal.y)) {\n        tangent = normalize(vec3(0., normal.z, -normal.y));\n    }\n    else {\n        tangent = normalize(vec3(-normal.z, 0., normal.x));\n    }\n    \n    binormal = cross(normal, tangent);\n}\n\nvoid directionOfAnisotropicity(vec3 normal, out vec3 tangent, out vec3 binormal){\n    tangent = cross(normal, vec3(1.,0.,1.));\n    binormal = normalize(cross(normal, tangent));\n    tangent = normalize(cross(normal,binormal));\n}\n\nvec3 sphericalDirection(float sinTheta, float cosTheta, float sinPhi, float cosPhi) {\n    return vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);\n}\n\nvec3 uniformSampleCone(vec2 u12, float cosThetaMax, vec3 xbasis, vec3 ybasis, vec3 zbasis) {\n    float cosTheta = (1. - u12.x) + u12.x * cosThetaMax;\n    float sinTheta = sqrt(1. - cosTheta * cosTheta);\n    float phi = u12.y * TWO_PI;\n    vec3 samplev = sphericalDirection(sinTheta, cosTheta, sin(phi), cos(phi));\n    return samplev.x * xbasis + samplev.y * ybasis + samplev.z * zbasis;\n}\n\nbool sameHemiSphere(const in vec3 wo, const in vec3 wi, const in vec3 normal) {\n    return dot(wo, normal) * dot(wi, normal) > 0.0;\n}\n\nvec2 concentricSampleDisk(const in vec2 u) {\n    vec2 uOffset = 2. * u - vec2(1., 1.);\n\n    if (uOffset.x == 0. && uOffset.y == 0.) return vec2(0., 0.);\n\n    float theta, r;\n    if (abs(uOffset.x) > abs(uOffset.y)) {\n        r = uOffset.x;\n        theta = PI/4. * (uOffset.y / uOffset.x);\n    } else {\n        r = uOffset.y;\n        theta = PI/2. - PI/4. * (uOffset.x / uOffset.y);\n    }\n    return r * vec2(cos(theta), sin(theta));\n}\n\nvec3 cosineSampleHemisphere(const in vec2 u) {\n    vec2 d = concentricSampleDisk(u);\n    float z = sqrt(max(EPSILON, 1. - d.x * d.x - d.y * d.y));\n    return vec3(d.x, d.y, z);\n}\n\nvec3 uniformSampleHemisphere(const in vec2 u) {\n    float z = u[0];\n    float r = sqrt(max(EPSILON, 1. - z * z));\n    float phi = 2. * PI * u[1];\n    return vec3(r * cos(phi), r * sin(phi), z);\n}\n\n///////////////////////////////////////////////////////////////////////\n///////////// DISTANCE FIELDS AND RAY MARCHING ////////////////////////\n///////////////////////////////////////////////////////////////////////\n\nfloat sdSphere( vec3 p, float r) { \n    return length(p) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n ) {\n  return dot(p,n.xyz) + n.w;\n}\n\nvec3 opU(vec3 o1, vec3 o2) {\n    return (o1.x < o2.x) ? o1 : o2;\n}\n\nvec3 map( vec3 p, bool bumps )\n{\n    vec3 res = vec3( 1000000, 0, 0 );\n    \n    #if (SHAPE == 0)\n    res=opU( res, vec3( p.z, OBJ_PLANE, MAT_MAIN ) );\n    #elif (SHAPE == 1)\n    res = opU( res, vec3( p.z, OBJ_PLANE, MAT_MAIN ) );\n    res = opU( res, vec3( length( p - vec3(0, 16, 7. ) ) - 6.0, OBJ_SPHERE, MAT_MAIN ) );\n    #elif (SHAPE == 2)\n    vec2 h = vec2( 0.95, 0.8 ); vec2 d = abs(vec2(length(p.xz),p.y)) - h; \n    res=opU( res, vec2( min(max(d.x,d.y),0.0) + length(max(d,0.0)), 0 ) );\n    #elif (SHAPE == 3)\n    vec3 tp=p;tp.zxy=opTwist( tp.zxy, 2.531 );\n    res=opU( res, vec2( length( max( abs(tp) - vec3( 0.213 * 3.0, 0.978 * 3.0, 0.213 * 3.0 ), 0.0 ) ) - 0.10, 0) );\n    #elif (SHAPE == 4)\n    res=opU( res, vec3( p.y + 1.5, 0 ) );\n    #endif\n\n    if ( bumps == true && res.z == MAT_MAIN) {\n    \tRay ray; SurfaceInteraction inter;\n        MaterialInfo material; \n    \tinter.point = p;\n        inter.objId = res.y;\n        getMainMaterial(vec2(iResolution.x, iResolution.y), inter, material);\n    \tres.x -= material.bump / 5.;\n    }\n    //res = opU( res, vec2( length( p - LIGHT1_POS ) - 1.0, 2 ) );\n\n    return res;\n}\n\nvec3 calculateNormal(vec3 p) {\n \n    vec3 epsilon = vec3(0.001, 0., 0.);\n    bool doBumps = true;\n    \n    vec3 n = vec3(map(p + epsilon.xyy, doBumps).x - map(p - epsilon.xyy, doBumps).x,\n                  map(p + epsilon.yxy, doBumps).x - map(p - epsilon.yxy, doBumps).x,\n                  map(p + epsilon.yyx, doBumps).x - map(p - epsilon.yyx, doBumps).x);\n    \n    return normalize(n);\n}\n\nSurfaceInteraction rayMarch(vec3 ro, vec3 rd) {\n    \n    SurfaceInteraction interaction = SurfaceInteraction(-1., rd, vec3(0.), vec3(0.), vec3(0.), vec3(0.), -10.);\n    \n    float t = 0.;\n    vec3 obj = vec3(0.);\n    float d = INFINITY;\n    float maxt = 1000.;\n    \n    bool doBumps = DISPLACE == 1;\n\n    for (int i = 0; i < 200; i++) {\n        \n        obj = map(ro + t * rd, doBumps);\n        d = obj.x;\n                \n        if (d < .001 || t > maxt) { break; }\n        t += d;\n    }\n\n    if ( t > maxt ) obj = vec3(0);\n    \n    interaction.id = obj.z;        \n    interaction.point = ro + rd *t;\n    interaction.normal = calculateNormal(interaction.point);\n    interaction.objId = obj.y;\n    return interaction;\n}\n\n// Get the material\nMaterialInfo getMaterial(vec2 uv, SurfaceInteraction interaction, Ray ray, out bool found){\n    MaterialInfo material = MaterialInfo(vec3(.8), 0., 1., 0., 0., 0., 0., 0., 0., 0., 0.,0.);\n\tfound = true;\n    \n    //if (interaction.id == LIGHT_ID) {\n    //    material.baseColor = lights[0].L;\n    //} else\n    if (interaction.id == MAT_UTILITY) {\n    \tgetUtilityMaterial(uv, interaction, material);\n    } else\n    if (interaction.id == MAT_MAIN) {\n    \tgetMainMaterial(uv, interaction, material);\n    } else {\n    \tfound = false;    \n    }\n    \n    return material;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, DISPLACE == 1 ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.0005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat visibilityTest(vec3 ro, vec3 rd) {\n    float softShadowValue = calcSoftshadow(ro, rd, 0.01, 3.);//, softShadowValue);\n    return softShadowValue;\n}\n\nfloat visibilityTestSun(vec3 ro, vec3 rd) {\n    float softShadowValue = calcSoftshadow(ro, rd, 0.01, 3.);\n    return softShadowValue;//IS_SAME_MATERIAL(interaction.objId, 0.) ? 1. : 0.;\n}\n\n\nfloat powerHeuristic(float nf, float fPdf, float ng, float gPdf){\n    float f = nf * fPdf;\n    float g = ng * gPdf;\n    return (f*f)/(f*f + g*g);\n}\n///////////////////////////////////////////////////////////////////////\n///////////////////////  PDF's and BRDF's  ////////////////////////////\n///////////////////////////////////////////////////////////////////////\n\n// Disney brdf's taken from here:: https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\nfloat schlickWeight(float cosTheta) {\n    float m = clamp(1. - cosTheta, 0., 1.);\n    return (m * m) * (m * m) * m;\n}\n\nfloat GTR1(float NdotH, float a) {\n    if (a >= 1.) return 1./PI;\n    float a2 = a*a;\n    float t = 1. + (a2-1.)*NdotH*NdotH;\n    return (a2-1.) / (PI*log(a2)*t);\n}\n\nfloat GTR2(float NdotH, float a) {\n    float a2 = a*a;\n    float t = 1. + (a2-1.)*NdotH*NdotH;\n    return a2 / (PI * t*t);\n}\n\nfloat GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n    return 1. / (PI * ax*ay * pow2( pow2(HdotX/ax) + pow2(HdotY/ay) + NdotH*NdotH ));\n}\n\nfloat smithG_GGX(float NdotV, float alphaG) {\n    float a = alphaG*alphaG;\n    float b = NdotV*NdotV;\n    return 1. / (abs(NdotV) + max(sqrt(a + b - a*b), EPSILON));\n}\n\nfloat smithG_GGX_aniso(float NdotV, float VdotX, float VdotY, float ax, float ay) {\n    return 1. / (NdotV + sqrt( pow2(VdotX*ax) + pow2(VdotY*ay) + pow2(NdotV) ));\n}\n\nfloat pdfLambertianReflection(const in vec3 wi, const in vec3 wo, const in vec3 normal) {\n    return sameHemiSphere(wo, wi, normal) ? abs(dot(normal, wi))/PI : 0.;\n}\n\nfloat pdfMicrofacet(const in vec3 wi, const in vec3 wo, const in SurfaceInteraction interaction, const in MaterialInfo material) {\n    if (!sameHemiSphere(wo, wi, interaction.normal)) return 0.;\n    vec3 wh = normalize(wo + wi);\n    \n    float NdotH = dot(interaction.normal, wh);\n    float alpha2 = material.roughness * material.roughness;\n    alpha2 *= alpha2;\n    \n    float cos2Theta = NdotH * NdotH;\n    float denom = cos2Theta * ( alpha2 - 1.) + 1.;\n    if( denom == 0. ) return 0.;\n    float pdfDistribution = alpha2 * NdotH /(PI * denom * denom);\n    return pdfDistribution/(4. * dot(wo, wh));\n}\n\nfloat pdfMicrofacetAniso(const in vec3 wi, const in vec3 wo, const in vec3 X, const in vec3 Y, const in SurfaceInteraction interaction, const in MaterialInfo material) {\n    if (!sameHemiSphere(wo, wi, interaction.normal)) return 0.;\n    vec3 wh = normalize(wo + wi);\n    \n    float aspect = sqrt(1.-material.anisotropic*.9);\n    float alphax = max(.001, pow2(material.roughness)/aspect);\n    float alphay = max(.001, pow2(material.roughness)*aspect);\n    \n    float alphax2 = alphax * alphax;\n    float alphay2 = alphax * alphay;\n\n    float hDotX = dot(wh, X);\n    float hDotY = dot(wh, Y);\n    float NdotH = dot(interaction.normal, wh);\n    \n    float denom = hDotX * hDotX/alphax2 + hDotY * hDotY/alphay2 + NdotH * NdotH;\n    if( denom == 0. ) return 0.;\n    float pdfDistribution = NdotH /(PI * alphax * alphay * denom * denom);\n    return pdfDistribution/(4. * dot(wo, wh));\n}\n\nfloat pdfClearCoat(const in vec3 wi, const in vec3 wo, const in SurfaceInteraction interaction, const in MaterialInfo material) {\n    if (!sameHemiSphere(wo, wi, interaction.normal)) return 0.;\n\n    vec3 wh = wi + wo;\n    wh = normalize(wh);\n    \n    float NdotH = abs(dot(wh, interaction.normal));\n    float Dr = GTR1(NdotH, mix(.1,.001,material.clearcoatGloss));\n    return Dr * NdotH/ (4. * dot(wo, wh));\n}\n\nvec3 disneyDiffuse(const in float NdotL, const in float NdotV, const in float LdotH, const in MaterialInfo material) {\n    \n    float FL = schlickWeight(NdotL), FV = schlickWeight(NdotV);\n    \n    float Fd90 = 0.5 + 2. * LdotH*LdotH * material.roughness;\n    float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n    \n    return (1./PI) * Fd * material.baseColor;\n}\n\nvec3 disneySubsurface(const in float NdotL, const in float NdotV, const in float LdotH, const in MaterialInfo material) {\n    \n    float FL = schlickWeight(NdotL), FV = schlickWeight(NdotV);\n    float Fss90 = LdotH*LdotH*material.roughness;\n    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n    float ss = 1.25 * (Fss * (1. / (NdotL + NdotV) - .5) + .5);\n    \n    return (1./PI) * ss * material.baseColor;\n}\n\nvec3 disneyMicrofacetIsotropic(float NdotL, float NdotV, float NdotH, float LdotH, const in MaterialInfo material) {\n    \n    float Cdlum = .3*material.baseColor.r + .6*material.baseColor.g + .1*material.baseColor.b; // luminance approx.\n\n    vec3 Ctint = Cdlum > 0. ? material.baseColor/Cdlum : vec3(1.); // normalize lum. to isolate hue+sat\n    vec3 Cspec0 = mix(material.specular *.08 * mix(vec3(1.), Ctint, material.specularTint), material.baseColor, material.metallic);\n    \n    float a = max(.001, pow2(material.roughness));\n    float Ds = GTR2(NdotH, a);\n    float FH = schlickWeight(LdotH);\n    vec3 Fs = mix(Cspec0, vec3(1), FH);\n    float Gs;\n    Gs  = smithG_GGX(NdotL, a);\n    Gs *= smithG_GGX(NdotV, a);\n    \n    return Gs*Fs*Ds;\n}\n\nvec3 disneyMicrofacetAnisotropic(float NdotL, float NdotV, float NdotH, float LdotH,\n                                 const in vec3 L, const in vec3 V,\n                                 const in vec3 H, const in vec3 X, const in vec3 Y,\n                                 const in MaterialInfo material) {\n    \n    float Cdlum = .3*material.baseColor.r + .6*material.baseColor.g + .1*material.baseColor.b;\n\n    vec3 Ctint = Cdlum > 0. ? material.baseColor/Cdlum : vec3(1.);\n    vec3 Cspec0 = mix(material.specular *.08 * mix(vec3(1.), Ctint, material.specularTint), material.baseColor, material.metallic);\n    \n    float aspect = sqrt(1.-material.anisotropic*.9);\n    float ax = max(.001, pow2(material.roughness)/aspect);\n    float ay = max(.001, pow2(material.roughness)*aspect);\n    float Ds = GTR2_aniso(NdotH, dot(H, X), dot(H, Y), ax, ay);\n    float FH = schlickWeight(LdotH);\n    vec3 Fs = mix(Cspec0, vec3(1), FH);\n    float Gs;\n    Gs  = smithG_GGX_aniso(NdotL, dot(L, X), dot(L, Y), ax, ay);\n    Gs *= smithG_GGX_aniso(NdotV, dot(V, X), dot(V, Y), ax, ay);\n    \n    return Gs*Fs*Ds;\n}\n\nfloat disneyClearCoat(float NdotL, float NdotV, float NdotH, float LdotH, const in MaterialInfo material) {\n    float gloss = mix(.1,.001,material.clearcoatGloss);\n    float Dr = GTR1(abs(NdotH), gloss);\n    float FH = schlickWeight(LdotH);\n    float Fr = mix(.04, 1.0, FH);\n    float Gr = smithG_GGX(NdotL, .25) * smithG_GGX(NdotV, .25);\n    return clearCoatBoost * material.clearcoat * Fr * Gr * Dr;\n}\n\nvec3 disneySheen(float LdotH, const in MaterialInfo material) {\n    float FH = schlickWeight(LdotH);\n    float Cdlum = .3*material.baseColor.r + .6*material.baseColor.g  + .1*material.baseColor.b;\n\n    vec3 Ctint = Cdlum > 0. ? material.baseColor/Cdlum : vec3(1.);\n    vec3 Csheen = mix(vec3(1.), Ctint, material.sheenTint);\n    vec3 Fsheen = FH * material.sheen * Csheen;\n    return FH * material.sheen * Csheen;\n}\n\nvec3 lightSample( const in LightInfo light, const in SurfaceInteraction interaction, out vec3 wi, out float lightPdf, float seed, const in MaterialInfo material) {\n    vec3 L = (light.position - interaction.point);\n    vec3 V = -normalize(interaction.incomingRayDir);\n    vec3 r = reflect(V, interaction.normal);\n    vec3 centerToRay = dot( L, r ) * r - L;\n    vec3 closestPoint = L + centerToRay * clamp( light.radius / length( centerToRay ), 0.0, 1.0 );\n    wi = normalize(closestPoint);\n\n\n    return light.L/dot(L, L);\n}\n\nvec3 sampleSun(const in LightInfo light, const in SurfaceInteraction interaction, out vec3 wi, out float lightPdf, float seed) {\n    wi = light.direction;\n    return light.L;\n}\n\nfloat lightPdf(const in vec4 light, const in SurfaceInteraction interaction) {\n    float sinThetaMax2 = light.w * light.w / distanceSq(light.xyz, interaction.point);\n    float cosThetaMax = sqrt(max(EPSILON, 1. - sinThetaMax2));\n    return 1. / (TWO_PI * (1. - cosThetaMax));\n}\n\n\nvec3 bsdfEvaluate(const in vec3 wi, const in vec3 wo, const in vec3 X, const in vec3 Y, const in SurfaceInteraction interaction, const in MaterialInfo material) {\n    if( !sameHemiSphere(wo, wi, interaction.normal) )\n        return vec3(0.);\n    \n    float NdotL = dot(interaction.normal, wo);\n    float NdotV = dot(interaction.normal, wi);\n    \n    if (NdotL < 0. || NdotV < 0.) return vec3(0.);\n\n    vec3 H = normalize(wo+wi);\n    float NdotH = dot(interaction.normal,H);\n    float LdotH = dot(wo,H);\n    \n    vec3 diffuse = disneyDiffuse(NdotL, NdotV, LdotH, material);\n    vec3 subSurface = disneySubsurface(NdotL, NdotV, LdotH, material);\n    vec3 glossy = disneyMicrofacetAnisotropic(NdotL, NdotV, NdotH, LdotH, wi, wo, H, X, Y, material);\n    float clearCoat = disneyClearCoat(NdotL, NdotV, NdotH, LdotH, material);\n    vec3 sheen = disneySheen(LdotH, material);\n\n    vec3 f = ( mix(diffuse, subSurface, material.subsurface) + sheen ) * (1. - material.metallic);\n    f += glossy;\n    f += clearCoat;\n    //f = material.specular * Lr + (1.f - material.specular) * f;\n    return f;\n}\n\n\n\nvec3 sampleLightType( const in LightInfo light, const in SurfaceInteraction interaction, out vec3 wi, out float lightPdf, out float visibility, float seed, const in MaterialInfo material) {\n    if( !light.enabled )\n        return vec3(0.);\n    \n    if( light.type == LIGHT_TYPE_SPHERE ) {\n        vec3 L = lightSample(light, interaction, wi, lightPdf, seed, material);\n        vec3 shadowRayDir =normalize(light.position - interaction.point);\n        visibility = visibilityTest(interaction.point + shadowRayDir * .01, shadowRayDir);\n        return L;\n    }\n    else if( light.type == LIGHT_TYPE_SUN ) {\n        vec3 L = sampleSun(light, interaction, wi, lightPdf, seed);\n        visibility = visibilityTestSun(interaction.point + wi * .01, wi);\n        return L;\n    }\n    else {\n        return vec3(0.);\n    }\n}\n\n// From https://www.shadertoy.com/view/XlKSDR\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(0.3,  0.3,  0.3) * (n.y)\n        + vec3( 0.35,  0.36,  0.35) * (n.z)\n        + vec3(-0.2, -0.24, -0.24) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calculateDirectLight(const in LightInfo light, const in SurfaceInteraction interaction, const in MaterialInfo material, out vec3 wi, out vec3 f, out float scatteringPdf) {\n    \n        \n    vec3 wo = -interaction.incomingRayDir;\n    vec3 Ld = vec3(0.);\n    float lightPdf = 0., visibility = 1.;\n\n    vec3 Li = sampleLightType( light, interaction, wi, lightPdf, visibility, seed, material);\n    Li *= visibility;\n\n    f = bsdfEvaluate(wi, wo, interaction.tangent, interaction.binormal, interaction, material) * abs(dot(wi, interaction.normal));        \n    Ld += Li * f;\n\n    return Ld;\n}\n\n///////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////\n\nRay getCameraRay(vec2 offset) {\n    vec3 origin = vec3(0.0, -5., 8.0);\n    vec3 lookAt = vec3(0., 100.2, 2.);\n\n    vec2 uv = (gl_FragCoord.xy + offset) / iResolution.xy - .5;\n    uv.y *= iResolution.y / iResolution.x;\n\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( lookAt - origin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    vec3 direction = normalize( uv.x * ix + uv.y * iy + .85 * iz );\n\n    return Ray(origin, direction);\n}\n\n// IQs Occlusion\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, DISPLACE == 1 ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.z);\n}\n\nvec3 calculatePixelColor() {\n        \n    vec3 L = vec3(0.);\n    vec3 beta = vec3(1.);\n    \n    vec2 uv = gl_FragCoord.xy / iResolution.xy;            \n    seed = float(iFrame) + hash12( uv );\n    vec3 wi;\n    \n    Ray ray = getCameraRay( vec2(random(), random()) );\n\n    for (float depth = 0.; depth < 1.; ++depth) {\n        \n        SurfaceInteraction interaction = rayMarch(ray.origin, ray.direction);\n\t\tbool found = false;\n        MaterialInfo material = getMaterial(vec2(iResolution.x, iResolution.y), interaction, ray, found);\n        if(IS_SAME_MATERIAL(interaction.id, LIGHT_ID) && depth == 0.){\n            L += vec3(Le);\n            break;\n        }\n        if(!found){\n           \tL += gammaToLinear(getSky(ray));\n            break;\n        }\n\n        vec3 X = vec3(0.), Y = vec3(0.);\n        directionOfAnisotropicity(interaction.normal, X, Y);\n        interaction.tangent = X;\n        interaction.binormal = Y;\n        \n        vec3 wi;\n        vec3 f = vec3(0.);\n        float scatteringPdf = 0.;\n        vec3 Ld = beta * calculateDirectLight(lights[0], interaction, material, wi, f, scatteringPdf);\n        Ld += beta * calculateDirectLight(lights[1], interaction, material, wi, f, scatteringPdf);\n        L += Ld;\n        \n        // Add indirect diffuse light from an env map\n        //vec3 diffuseColor = (1.0 - material.metallic) * material.baseColor.rgb ;\n        //L += diffuseColor * Irradiance_SphericalHarmonics(interaction.normal)/3.14;\n        \n        \n        if(useReflections) {\n            \n            vec3 f0 = 0.04 * (1.0 - material.metallic) + material.baseColor.rgb * material.metallic;\n        \tvec2 dfg = PrefilteredDFG_Karis(material.roughness, abs(dot(interaction.normal, ray.direction)));\n        \tvec3 specularColor = f0 * dfg.x + dfg.y;\n        \n            vec3 r = reflect(normalize(interaction.incomingRayDir), interaction.normal);\n            Ray reflRay = Ray(interaction.point, r);\n            SurfaceInteraction interaction1 = rayMarch(interaction.point + .02 * r, r);\n            MaterialInfo m = getMaterial(vec2(iResolution.x, iResolution.y), interaction1, reflRay, found);\n            if(found && !IS_SAME_MATERIAL(interaction1.id, LIGHT_ID)) {\n                L += m.baseColor * specularColor;\n            }\n            if(!found) {\n                // env map\n                L += gammaToLinear(getSky(reflRay)) * 0.2;\n            }\n        }\n        \n        if ( found )\n        \tL *= calcAO(interaction.point, interaction.normal);\n    }\n    \n    return L;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    initScene();\n        \n    vec2 uv = fragCoord.xy / iResolution.xy;        \n\n    float seed = float(iFrame) + hash12( uv );\n    \n    vec3 pixelColor = calculatePixelColor( );   \n    \n    vec3 finalColor = (pixelColor);\n    fragColor = vec4(clamp(finalColor, vec3(0.), vec3(10.)), 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel1, uv) * (1. - 1./float(iFrame+1)) + texture(iChannel0, uv) * 1./float(iFrame + 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}