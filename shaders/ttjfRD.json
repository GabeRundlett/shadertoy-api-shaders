{
    "Shader": {
        "info": {
            "date": "1598560164",
            "description": "Procedural techno.",
            "flags": 8,
            "hasliked": 0,
            "id": "ttjfRD",
            "likes": 15,
            "name": "Protected Void (sound)",
            "published": 3,
            "tags": [
                "raymarching",
                "sound",
                "music",
                "audio"
            ],
            "usePreview": 0,
            "username": "ruojake",
            "viewed": 510
        },
        "renderpass": [
            {
                "code": "// Protected Void by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\nvec3 hash32(in vec2 p)\n{\n\treturn fract(sin(p.xyx * 172.41 + dot(p, vec2(13.43, 14.05))) * 43212.513);\n}\n\nfloat hash12(in vec2 p)\n{\n\treturn fract(sin(172.41 + dot(p, vec2(13.43, 14.05))) * 43212.513);\n}\n\nvec3 hash31(in float v)\n{\n\treturn fract(sin(vec3(21.51, 32.21, 11.43) * v + 31.33) * 25234.312);\n}\n\nmat2 rot(in float a)\n{\n\tfloat s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat sqrL(in vec3 d)\n{\n    return dot(d, d);\n}\n\nvec2 box(in vec3 p, in float b)\n{\n  vec3 d = abs(p) - b;\n  return vec2(sqrL(max(d, 0.)), min(max(d.x, max(d.y, d.z)), 0.));\n}\n\nfloat size(in vec3 t, in vec3 id)\n{\n    float h = .0625 * floor(16. * fract(sin(t.x + dot(id, vec3(11.31, 12.07, 11.66))) * 42313.541));\n    h *= 2. - h;\n    float b = .375 - t.y * step(.07, h);\n    return fract(t.z + h) * b + .025;\n}\n\nvec2 minX(in vec2 a, in vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec3 sizeTiming(in float t)\n{\n    const float bdwn = 132. / 60. / 512.;\n    const float hlf = 132. / 120.;\n    return vec3(\n        floor(t * hlf),\n        sat(floor(fract(t * bdwn + .75) * 8.) - 6.) * .35625,\n        t * hlf\n    );\n}\n\nvec2 cubes(in vec3 p)\n{\n    float d = (1. - fract(iTime * 132. / 60.));\n    d *= d;\n    d = d * .3 + .9;\n    vec3 o = vec3(.75, -.75, 0.);\n    vec3 od = o * d;\n    vec3 t = sizeTiming(iTime);\n    \n    return minX(\n            minX(\n              minX(vec2(1000.), minX(box(p + od.y, size(t, o.yyy)),\n              minX(box(p + od.yzy, size(t, o.yzy)),\n              minX(box(p + od.yxy, size(t, o.yxy)),\n              minX(box(p + od.yyz, size(t, o.yyz)),\n              minX(box(p + od.yzz, size(t, o.yzz)),\n              box(p + od.yxz, size(t, o.yxz)))))))),\n\n              minX(box(p + od.yyx, size(t, o.yyx)),\n              minX(box(p + od.yzx, size(t, o.yzx)),\n              minX(box(p + od.yxx, size(t, o.yxx)),\n              minX(box(p + od.zyy, size(t, o.zyy)),\n              minX(box(p + od.zzy, size(t, o.zzy)),\n              minX(box(p + od.zxy, size(t, o.zxy)),\n              box(p + od.zyz, size(t, o.zyz))))))))\n              ),\n            minX(\n              minX(box(p + od.zxz, size(t, o.zxz)),\n              minX(box(p + od.zyx, size(t, o.zyx)),\n              minX(box(p + od.zzx, size(t, o.zzx)),\n              minX(box(p + od.zxx, size(t, o.zxx)),\n              minX(box(p + od.xyy, size(t, o.xyy)),\n              box(p + od.xzy, size(t, o.xzy))))))),\n\n              minX(box(p + od.xxy, size(t, o.xxy)),\n              minX(box(p + od.xyz, size(t, o.xyz)),\n              minX(box(p + od.xzz, size(t, o.xzz)),\n              minX(box(p + od.xxz, size(t, o.xxz)),\n              minX(box(p + od.xyx, size(t, o.xyx)),\n              minX(box(p + od.xzx, size(t, o.xzx)),\n              box(p + od.x, size(t, o.xxx)))))))))\n          ); \n}\n\nfloat scene(in vec3 p)\n{\n    const float pi = 3.1415;\n    \n    float a = iTime * 132. / 120.;\n    float b = sat(fract(a * .5) * 2. - 1.);\n    a = 1. - sat((1. - fract(a * .5)) * 2. - 1.);\n    \n\tp -= vec3(0,1,0);\n    \n    p.xy *= rot(a * pi);\n    p.xz *= rot(-b * pi);\n\tp.yz *= rot(iTime * .25);\n    \n    vec2 c = cubes(p);\n    \n    return min(sqrt(c.x) + c.y - .02, length(p) - .5);\n}\n\nvec3 normal(in vec3 p)\n{\n\tfloat d = scene(p);\n    vec2 e = vec2(.001, .0);\n    return normalize(d - vec3(\n        scene(p - e.xyy),\n        scene(p - e.yxy),\n        scene(p - e.yyx)));\n}\n\nvec3 ray(in vec3 ro, vec3 lookAt, vec2 uv, float zoom)\n{\n\tvec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n\n    return normalize(uv.x * r + uv.y * u + f * zoom);\n}\n\nvec3 bg(in float y)\n{\n\ty = y * .5 + .5;\n    return vec3(.02, .025, .03) * y * y;\n}\n\nvec3 shake(in float v)\n{\n\tfloat i = floor(v);\n    float f = smoothstep(0., 1., v - i);\n    \n    return mix(hash31(i), hash31(i + 1.), f) * 2. - 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float beat = iTime / 60. * 132.;\n    float md = sat(floor(fract(iTime * .034375) * 4.) - 2.);\n    float rs = iResolution.y / 20.;\n    vec2 lcoord = floor((fragCoord - iResolution.xy * .5) / rs + vec2(fract(-iTime * 132. / 3.75) * 2. - 1., 0.)) * rs;\n    vec2 coord = fragCoord - iResolution.xy * .5;\n    float h = hash12(lcoord + floor(iTime * 132. / 30.));\n    coord = mix(coord, lcoord, step(.95, h) * md);\n    \n    vec2 uv = coord / iResolution.y;\n    vec3 ro = vec3(0,1.5,-4);\n    vec3 tgt = vec3(0, 1, 0);\n    vec3 rd = ray(ro, tgt, uv, .75);\n    vec3 p = vec3(0);\n    float t = 0.;\n    \n    for(int i = 0; i < 50 && t <= 6.; i++)\n    {\n    \tp = ro + rd * t;\n        float d = scene(p);\n        t += d + .005;\n        if(abs(d) < .001) break;\n    }\n    \n    float dSphere = length(p - vec3(0,1,0));\n    if (dSphere > .5009) p += md * shake(h * fract(beat)) * .2;\n    \n    vec3 n = normal(p);\n    vec3 col = mix(bg(reflect(-ro, n).y),\n                   bg(rd.y).zyx * .5 * (1. - fract(beat) * md * (length(uv) * 3. - 2.2)),\n                   1. - sat(6. - t));\n    col *= sat(iTime * 132. / 960.);\n\n    if (dSphere < .501) col = vec3(1.);\n\t\n    col = pow(col, vec3(1./2.2));\n    \n    #ifdef FADE\n    col *= 1. - sat((iTime - 160.) * .05);\n    #endif\n    \n    col += (vec3(col.g * .75) - col) * -40. * md * sat(fract(h * 421.1) * 20. - 19.);\n    \n    fragColor = vec4(col + hash32(fragCoord + floor(fract(iTime) * 7200.)) * .0078 - .0039,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float hash(float t)\n{\n\treturn fract(sin(t * 3123. + 5134.) * 4321.312) * 2. - 1.;\n}\n\nfloat noise(float t)\n{\n\tfloat i = floor(t);\n    float f = smoothstep(0., 1., t - i);\n    return mix(hash(i), hash(i+1.), f);\n}\n\nfloat fbm(float t)\n{\n\tfloat a = 1.;\n    float snd = 0.;\n    for(float i = 1.; i < 6.; i++)\n    {\n    \tsnd += noise(t * i) * a;\n        a *= .75;\n    }\n    return snd;\n}\n\nfloat sfract(float v, float k)\n{\n    v = fract(v);\n\treturn mix(v, 0., clamp(v * k - k + 1., 0., 1.));\n}\n\nfloat note(float n)\n{\n\treturn n >= 0. ? 440. * pow(2., n / 12.) : 440. / pow(2., -n / 12.);\n}\n\nfloat saw(float t, float f, float n, float hp)\n{\n    float a = 1.;\n    float p = 0.;\n    float snd = 0.;\n\tfor(float i = max(floor(hp), 1.); i < 40. && a > 1e-36; i++)\n    {\n    \tfloat h = sin(6.2831 * t * note(n) * i + p) / i * a;\n        snd += h;\n\t\ta *= f;\n        p += 3.1415;\n    }\n    return snd * .5;\n}\n\nvec2 syn(float n, float t, float f, float h)\n{\n    vec2 snd = vec2(0.);\n    n -= 17.;\n    for(float c = 0.; c < 2.; c++)\n    {\n        float nn = n;\n        for(float i = 0.; i < 5.; i += 1.)\n        {\n            float hash = hash(nn+c);\n            float ff = sfract(f*3., 50.); \n            float note = (floor(nn + h) + hash * .1 - .05);\n            snd.x += saw(t + fract(abs(hash) * 51123.) * 3.1415, \n                         f * .3 + ff * .2 + .5, \n                         note, floor(3. - f * 3.) * 3.) \n                * ff;\n            nn += 3.5;\n        }\n        snd = snd.yx;\n    }\n    return snd;\n}\n\nfloat bass(float t, float f, float n)\n{\n    const float tau = 6.2831;\n    f = 1. - f;\n\treturn sin(tau * t * note(-36. + n) + sin(tau * t * note(-24. + n)) + .25 * sin(tau * t * note(-5. + n))) * f * f;\n}\n\nfloat hh(float t, float f)\n{\n    f = 1. - f;\n    float h = hash(f * 100.) * .3 + hash(f * .1) * .7;\n\treturn f * f * f * f * f * h * abs(h);\n}\n\nfloat kick(float f)\n{\n\tf = 1. - f;\n    return (cos(4. * note(-21. + f * f * f * f * f * 3.))\n        + cos(5. * note(-16. + f * f * f * 2.)) * .4\n        + .5 * (.8 - f * f) * fbm(f * 70.))\n        * pow(f, .4);\n}\n\nfloat snare(float f)\n{\n\tf = 1. - f;\n    return smoothstep(-.7, .7, \n        (fbm(f * 140. + f * f * f * f * f * 50.) + fbm(f * 110. + f * f * 20.)) * .5 * f * f * f)\n        * 2. - 1.;\n}\n\nvec2 ride(float f)\n{\n\treturn (sin(f * 8000.) + 1.) * (1.25-f) * .1 * vec2(\n        (noise(f * 7900.) + noise(f * 4100. - 41.)),\n        (noise(f * 7900. - 51.) + noise(f * 4100. + 141.)));\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float tempo = 132.;\n    float beat = time / 60. * tempo;\n    float tick = beat * 4.;\n    float chord = beat * 4. / 3.;   \n    float sn = beat * .5 + .5 + floor(fract(beat * .25) * 2.) * .125;\n    float rd = beat * 2.;\n    float h = floor(fract(sin(floor(chord) * 15121.31)) * 5.);\n    float md = sat(floor(fract(beat / 64.) * 4.) - 2.);\n    float bdwn = 1. - sat(floor(fract(beat / 512. + .75) * 8.) - 6.);\n    \n    vec2 snd = sat(beat * .03125 - 2.) * .25 \n        * syn(h * -3. - md * 4., time, \n            1.-sfract(chord, 30.), \n            fract((h+md) * .5) * .5) * (sfract(beat, 40.) * .75 + .25) \n        + bdwn * sat(beat * .125 - 1.) * .15 * hh(time, fract(tick) * (floor(sfract(beat + .5, 20.) * 4. + 1.) * .5))\n        + bdwn * sat(beat * .125) * .55 * kick(fract(beat))\n        + sat(beat * .25 - .5) * .4 * bass(time, clamp(sfract(beat + .25, 30.), 0., .5) * 2., 0.+ md * 3.)\n        + sat(beat * .25 - .5) * .35 * bass(time, clamp(sfract(beat + .5, 30.), 0., .5) * 2., -2.)\n        + sat(beat * .125 - .5) * .15 * snare(clamp(fract(sn), 0., .125) * 8.)\n        + md * .1 * ride(sfract(rd, 20.));\n    \n    snd /= max(snd * snd * 1.05, 1.);\n    \n    #ifdef FADE\n    snd *= 1. - sat((time - 160.) * .05);\n    #endif\n    \n    return snd;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "// comment this out if you're using the shadertoy browser plugin\n// and you want an infinite loop\n#define FADE\n\n#define sat(x) clamp((x), 0., 1.)",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}