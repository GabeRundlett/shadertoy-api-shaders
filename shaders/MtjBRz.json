{
    "Shader": {
        "info": {
            "date": "1514498703",
            "description": "we need MOAR SPHEARS",
            "flags": 48,
            "hasliked": 0,
            "id": "MtjBRz",
            "likes": 7,
            "name": "3D Lissajous curve",
            "published": 3,
            "tags": [
                "3d",
                "grid",
                "march",
                "sparse"
            ],
            "usePreview": 0,
            "username": "mattz",
            "viewed": 943
        },
        "renderpass": [
            {
                "code": "/* 3D Lissajous curve, by mattz. \n   License Creative Commons Attribution 3.0 (CC BY 3.0) Unported License.\n\n   Mouse rotates (or click in bottom left for auto-rotate).\n   SPACE resets.\n\n   Basic idea same as \"party grid 3d\" - https://www.shadertoy.com/view/XtlfWs\n   and \"3D diffusion limited aggregation\" - https://www.shadertoy.com/view/XtSfRz\n\n   Raytrace through a voxel grid, intersecting spheres in each cell.\n   Sphere locations are stored in a multipass texture.\n\n   I started out intending to do a Lorentz attractor in 3D, but ended up here.\n   Still have cool ideas about Lorentz, though...\n\n*/\n\nconst int nslot = 16; \nint nx, ny;\nfloat nbox;\nivec2 tex_stride;\nivec4 vec_stride;\nint estart;\nvec3 ctr;\n\nvoid check_res() {\n    \n    int nboxi;\n\n    if (iResolution.x >= 320. && iResolution.y >= 240.) {\n        \n        ny = 240;  \n        nx = 320;  \n        nboxi = 16; \n        \n    } else {\n        \n        ny = 140;\n        nx = 200;\n        nboxi = 12;\n        \n    }\n\n    tex_stride = ivec2(1, nx); \n\n    vec_stride = ivec4(nboxi*nboxi*nslot,\n                       nboxi*nslot,\n                       nslot,\n                       1); // for converting idx <-> voxel / slot\n    \n    estart = nboxi*nboxi*nboxi*nslot; // number of voxel/slots\n    \n    nbox = float(nboxi);\n    \n    ctr = vec3(0.5*nbox) - 0.5;\n\n}\n\n// flat index -> tex coord\nivec2 idx2tex(int idx) {\n    return ivec2(idx % tex_stride.y, idx / tex_stride.y);\n}\n\nivec2 slot2tex(ivec3 v, int slot) {\n    return idx2tex(vec_stride.x*v.x + vec_stride.y*v.y + vec_stride.z*v.z + slot);\n}\n\n// voxel / slot -> tex uv\nivec2 slot2tex(vec3 vox, int slot) {\n    ivec3 v = ivec3(vox+0.5);    \n    return slot2tex(v, slot);\n}\n\n\nivec2 extra2tex(int e) {\n    return idx2tex(estart + e);\n}\n\n//////////////////////////////////////////////////////////////////////\n\nconst float farval = 10000.0;\nconst vec4 miss = vec4(vec3(0.0), farval);\nconst float rad = .4;\n\nconst int rsteps = 48;\n\n\nvec3 L = normalize(vec3(-0.5, 1.0, -0.8));\nmat3 Rview;\n\n\n// RGB from hue\nvec3 hue(float h) {\n    vec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n    return h >= 1.0 ? vec3(h-1.0) : clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n// rotate about x-axis \nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n\n// rotate about y-axis \nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n// ray-sphere intersection\nvec4 sphere(in vec3 o, in vec3 d, in vec3 ctr, in float r) {\n\t\n    vec3 oc = o - ctr;\n    \n    float a = dot(d, d);\n    float b = 2.0*dot(oc, d);\n    float c = dot(oc, oc) - r*r;\n        \n    float D = b*b - 4.0*a*c;\n    \n    if (D > 0.0) {\n        \n        float sqrtD = sqrt(D);\n        \n        float t = 0.5 * ( -b - sqrtD ) / a;\n        \n        if (t >= 0.0) {\n            vec3 n = normalize( oc + t*d );\n            return vec4(n, t);\t\n        }\n        \n    }\n    \n    return miss;\n\t\t\n}\n\n// minimum of vector\nfloat min3(vec3 a) {\n\treturn min(a.x, min(a.y, a.z));\n}\n\n// max of vector\nfloat max3(vec3 a) {\n\treturn max(a.x, max(a.y, a.z));\n}\n\n// ray-box intersection\nfloat box(vec3 ro, vec3 rd, vec3 b) {\n\t\n\tvec3 rdi = 1.0/rd;\t\n\t\t\n\tvec3 t1 = (-b - ro)*rdi;\n\tvec3 t2 = ( b - ro)*rdi;\n\t\n\tvec3 tmin = min(t1, t2);\n\tvec3 tmax = max(t1, t2);\n    \n    float ta = max3(tmin);\n    float tb = min3(tmax);\n\t\n\tif (ta <= tb) {\n\t\treturn ta;\n\t} else {\n\t\treturn farval;\n\t}\n\n}\n\n// select whichever basis edge minimizes time to hit\nvec3 bselect(vec3 k, vec3 d, vec3 b1, vec3 b2) {\n\treturn (abs(dot(k,b1)*dot(d,b2)) < abs(dot(k,b2)*dot(d,b1))) ? b1 : b2;\n}\n\n// for stepping through cube lattice\nfloat stepcube(in vec3 p, in vec3 d) {\n\t\n\t// g is half-integer coords from p in the direction of d\n\tvec3 g = floor(p+vec3(0.5))-vec3(0.5) + step(vec3(0.0), d);\n\n\t// k is the vector from p to the corner in direction d\n\tvec3 k = g-p;\n\t\n\t// select the basis vector representing the first to intersect\t\n\tvec3 b = bselect(k, d, \n\t\t\t\t\t bselect(k, d, vec3(1.0, 0.0, 0.0), \n\t\t\t\t\t \t\t\t   vec3(0.0, 1.0, 0.0)), \n\t\t\t\t\t\t           vec3(0.0, 0.0, 1.0));\n\t\n\t// compute the distance along the ray to the nearest cube edge\n\treturn dot(k,b) / dot(d, b);\n\t\n}\n\n// point in box?\nbool inbox(vec3 c, float tol) {\n    float cmin = min(c.x, min(c.y, c.z));\n    float cmax = max(c.x, max(c.y, c.z));\n    return cmin >= -tol && cmax < nbox + tol;\n}\n\n// ray-plane intersection\nfloat rayplane(vec3 ro, vec3 rd, vec3 n, vec3 p) {\n    float d = dot(n, p);\n    return (d - dot(ro, n)) / dot(rd, n);\n}\n\n\n// select closest ray intersection result\nvec4 pselect(vec4 a, vec4 b) {\n    return a.w < b.w ? a : b;\n}\n\nvec2 d_ray_point(vec3 ro, vec3 rd, vec3 p) {\n    \n    p -= ro;\n    float u = max(0.0, dot(rd, p) / dot(rd, rd));\n    \n    return vec2(u, length(p - u*rd));\n    \n}\n\n// raytrace against sphere whose position is given\n// by texture lookup\nvoid sphere_tex(in vec3 ro, in vec3 rd, in ivec2 tex, \n                in bool shadow, inout vec4 rresult) {\n    \n    vec4 ct = texelFetch(iChannel0, tex, 0);\n    if (ct.w > 0.) {\n        if (shadow) {\n            vec2 k = d_ray_point(ro, rd, ct.xyz);\n            float brt = exp(-0.025*k.x);\n            float f = mix(1.0, 0.1, brt);\n            float cov = smoothstep((1.-f)*rad, (1.+f)*rad, k.y);\n            rresult.w = min(rresult.w, mix(1.0, cov, brt));\n        } else {\n            vec4 s = sphere(ro, rd, ct.xyz, rad);        \n\t        s.xyz *= ct.w;\n    \t    rresult = pselect(rresult, s);\n        }\n    }\n}\n\nvec4 trace(in vec3 ro, in vec3 rd, bool shadow) {\n    \n    float curw = 0.0;\n    \n    if (!inbox(ro, 0.0)) {\n        curw = box(ro, rd, 0.5*vec3(nbox));\n    }\n\n    vec4 rresult = shadow ? vec4(1) : miss;\n\n    float tplane = rayplane(ro, rd, vec3(0, 1, 0), vec3(0, -0.5*nbox - 1., 0));\n    \n    if (!shadow && rd.y < 0. && tplane > 0.0) {\n        vec2 p = ro.xz + ctr.xz + tplane*rd.xz;\n        p = step(mod(0.125*p, vec2(2.0)), vec2(1.));\n        float m = p.x*(1.-p.y) + p.y*(1.-p.x);\n        m = m > 0. ? 1.9 : 1.7;\n        rresult = pselect(rresult, vec4(0, m, 0, tplane));\n    }\n    \n    ro += ctr;\n        \n    // raytrace result\n    //vec4 rresult = miss;\n    \n    sphere_tex(ro, rd, extra2tex(0), shadow, rresult);\n    \n    \n    int f = iFrame;\n    \n    // if hit box, raytrace thru\n    if (curw < farval) {\n\n        // added to cube step\n        const float eps = 0.001;\n\n        // march along ray thru grid\n        for (int i=0; i<rsteps; ++i) {\n\n            // point in grid\n            vec3 p = ro + curw * rd;\n\n            // base cell \n            ivec3 vbase = ivec3(p);\n\n            // for each neighbor in 2x2x2 neighborhood\n            for (int j=0; j<8; ++j) {\n\n                // offset to neighbor\n                ivec3 joffs = ivec3(j >> 2, j >> 1, j) & 1;\n\n                // center of cell\n                ivec3 v = vbase + joffs;\n                \n                // if center in box and box occupied\n                if (inbox(vec3(v), 0.) && texelFetch(iChannel0, slot2tex(v, nslot-1), 0).x > 0.) {\n\n                    for (int k=0; k<5; ++k) {\n                        sphere_tex(ro, rd, slot2tex(v, (3*k + f) % (nslot-1)), shadow, \n                                   rresult);\n                    }\n                    \n                } // center in box\n\n            } // for each neighbor\n\n            curw += stepcube(p, rd) + eps;\n\n        } // for each step along ray\n\n    } // if hit bounding box\n\n    \n    return rresult;\n    \n}\n\n// ray trace\nvec3 shade(in vec3 ro, in vec3 rd) {\n    \n    vec3 bgcolor = vec3(0.9);\n    \n    vec4 rresult = trace(ro, rd, false);\n        \n    // if hit a sphere, shade it\n    if (rresult.w < farval) {\n\n        vec3 n = rresult.xyz;\n        float t = length(n);\n        n /= t;\n        \n        vec4 sresult = trace(ro + rresult.w * rd + n*(rad+0.001), L, true);\n        float ks = sresult.w;\n        \n        vec3 c = hue(t);\n\n        vec3 diffamb = (ks*0.7*clamp(dot(n,L), 0.0, 1.0)+0.3) * c;\n        vec3 R = 2.0*n*dot(n,L)-L;\n\n        vec2 ss = t > 1.0 ? vec2(0.3, 10.0) : vec2(1.5, 15.0);\n        float spec = ks*ss.x*pow(clamp(-dot(R, rd), 0.0, 1.0), ss.y);\n\n        return diffamb + spec;\n\n    } else {\n        \n        return bgcolor;\n        \n    }\n    \t\n}\t\n\n// basic view setup and raytrace\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    check_res();\n \n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * 0.8 / (iResolution.y);\n   \n    const vec3 tgt = vec3(0.0, 0.0, 0.0);\n    vec3 cpos = vec3(0.0, 0.0, 2.*nbox);\n    const vec3 up = vec3(0, 1, 0);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\n    float thetay = 0.4*iTime;\n    float thetax = 0.8;\n    float border = 1.0;\n    \n    if (false) { // for making gifs\n        vec2 r = 0.5*iResolution.xy;\n        vec2 p = r - abs(fragCoord - r);\n        thetay = 1.0471975511965976*iTime;\n        float k = mod(iTime, 12.0);\n        border = max(step(k, 6.0), step(10.0, min(p.x, p.y)));\n    }\n\n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        thetax = (iMouse.y - .5*iResolution.y) * -5.0/iResolution.y; \n        thetay = (iMouse.x - .5*iResolution.x) * 10.0/iResolution.x; \n    }\n\n    Rview = mat3(rx,ry,rz)*rotY(thetay)*rotX(thetax); \n    L = Rview*L;\n\n    vec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n\n    fragColor.xyz = border*shade(ro, rd);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int nslot = 16; \nint nx, ny;\nfloat nbox;\nivec2 tex_stride;\nivec4 vec_stride;\nint estart;\nvec3 ctr;\n\nvoid check_res() {\n    \n    int nboxi;\n\n    if (iResolution.x >= 320. && iResolution.y >= 240.) {\n        \n        ny = 240;  \n        nx = 320;  \n        nboxi = 16; \n        \n    } else {\n        \n        ny = 140;\n        nx = 200;\n        nboxi = 12;\n        \n    }\n\n    tex_stride = ivec2(1, nx); \n\n    vec_stride = ivec4(nboxi*nboxi*nslot,\n                       nboxi*nslot,\n                       nslot,\n                       1); // for converting idx <-> voxel / slot\n    \n    estart = nboxi*nboxi*nboxi*nslot; // number of voxel/slots\n    \n    nbox = float(nboxi);\n    \n    ctr = vec3(0.5*nbox) - 0.5;\n\n}\n\n// flat index -> tex coord\nivec2 idx2tex(int idx) {\n    return ivec2(idx % tex_stride.y, idx / tex_stride.y);\n}\n\n// voxel / slot -> tex uv\nivec2 slot2tex(vec3 vox, int slot) {\n    ivec3 v = ivec3(vox+0.5);    \n    return idx2tex(vec_stride.x*v.x + vec_stride.y*v.y + vec_stride.z*v.z + slot);\n}\n\nivec2 extra2tex(int e) {\n    return idx2tex(estart + e);\n}\n\n//////////////////////////////////////////////////////////////////////\n\n// lookup texture from integer tex coords\nvec4 texlookup(ivec2 t) {\n    return texelFetch(iChannel0, t, 0);\n}\n\n// from https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p) {\n\n    #define HASHSCALE3 vec3(.1031, .1030, .0973)\n\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n// sample uniform on face of sphere\nvec3 random_dir(vec2 ti) {\n   \n    vec2 pq = hash22(ti);\n    \n    float z = pq.y * 2. - 1.;\n    float s = sqrt(1. - z*z);\n    \n    float theta = pq.x * 6.283185307179586;\n    \n    return vec3(cos(theta)*s, sin(theta)*s, z).yzx;\n    \n}\n\n// minimum of vector\nfloat min3(vec3 a) {\n\treturn min(a.x, min(a.y, a.z));\n}\n\n// max of vector\nfloat max3(vec3 a) {\n\treturn max(a.x, max(a.y, a.z));\n}\n\nvec4 pos_at_frame(int f) {\n    \n    float t = (float(f)+0.5) / 1800.;\n    const float pi = 3.141592653589793;\n\n    vec3 p = ctr + (0.5*nbox-.5)*sin(2. * pi * t * vec3(3.0, 7.0, 5.0) + vec3(0.25*pi, 0, 0.5*pi));\n    \n    return vec4(p, t);\n\n}\n\n// this is the main logic behind the dla algorithm\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    check_res();\n    \n    ivec2 fc = ivec2(fragCoord);\n   \n    // check if current fragment in minimum texture area \n    ivec2 outside = fc - ivec2(nx, ny);\n    if (max(outside.x, outside.y) > 0) {\n        discard; \n        return;\n    }\n\n\t// each voxel has a number of \"slots\" (possible spheres)\n    // to keep things simple and avoid having to loop to check \n    // for free slots, we have a fixed destination slot\n    // which increments each frame.\n    int f = iFrame - int(texlookup(extra2tex(1)).x);\n    \n    int frame_slot = f % (nslot-1);\n    \n\t// get the fragment color by looking up in the texture (feedback buffer)        \n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    // future operations assume fragCoord is exact integer\n    fragCoord = floor(fragCoord);\n    \n    if (texelFetch(iChannel1, ivec2(32, 0), 0).x > 0.) {\n        \n        fragColor = vec4(0);\n        if (fc == extra2tex(1)) {\n            fragColor.x = float(iFrame);\n        }\n        \n    } else {\n\n\n        vec4 p = pos_at_frame(f);\n\n        if (fc == extra2tex(0)) {\n            if (p.w < 1.0) {\n                fragColor = pos_at_frame(0);\n            } else {\n                fragColor = vec4(0);\n            }\n        } else if (fc == slot2tex(p.xyz, frame_slot)) {\n            fragColor = vec4(p.xyz, fract(p.w));\n        } else if (fc == slot2tex(p.xyz, nslot-1)) {\n            fragColor = vec4(1.);\n        }\n\n    }\n   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}