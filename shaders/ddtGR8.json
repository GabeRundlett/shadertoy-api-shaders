{
    "Shader": {
        "info": {
            "date": "1677077751",
            "description": "Experiment with a cone tracing to achieve sky dynamic occlusion\n\nInspiration: \n[1] https://advances.realtimerendering.com/s2015/DynamicOcclusionWithSignedDistanceFields.pdf\n[2] https://advances.realtimerendering.com/s2006/Evans-Fast_Approximations_for_Lig",
            "flags": 0,
            "hasliked": 0,
            "id": "ddtGR8",
            "likes": 5,
            "name": "Dynamic Occlusion",
            "published": 3,
            "tags": [
                "sdf",
                "cone",
                "ao",
                "conetracing"
            ],
            "usePreview": 0,
            "username": "krupitskas",
            "viewed": 282
        },
        "renderpass": [
            {
                "code": "#define M_PI 3.1415926535897932384626433832795\n\nconst float EPSILON = 0.001;\n    \nfloat sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat scene(vec3 p) \n{\n    float a1 = sphere(p + vec3(2.0 * sin( iTime * 0.7), 1.0, 2.0 * cos( iTime * 0.7)), 1.0);\n    float a2 = sphere(p, 1.0);\n    float a3 = sphere(p - vec3(0.0, -33.5, 0.0), 32.0);\n    float a4 = sphere(p - vec3(0.0, -2.0, 0.0), 0.5 + abs(sin( iTime )) );\n    float a5 = sphere(p + vec3(-4.0, -0.5 + sin( iTime ), 0.0), 1.0);\n    \n    return min(min(min(min(a1,a2), a3), a4), a5);\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + EPSILON, p.y, p.z)) - scene(vec3(p.x - EPSILON, p.y, p.z)),\n        scene(vec3(p.x, p.y + EPSILON, p.z)) - scene(vec3(p.x, p.y - EPSILON, p.z)),\n        scene(vec3(p.x, p.y, p.z  + EPSILON)) - scene(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    const int MAX_MARCHING_STEPS = 255;\n\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = scene(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    \n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nuvec2 quasi2 = uvec2(0xC13FA9A9u,0x91E10DA5u);\nuvec3 quasi3 = uvec3( 3518319155, 2882110345, 2360945575 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 15.0);\n    \n    const float MIN_DIST = 0.0;\n    const float MAX_DIST = 100.0;\n\n    // Get geometry information\n    \n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n\n    vec3 p = eye + dist * dir;\n    vec3 N = estimateNormal(p);\n\n    uint seed = uint(fragCoord.x)*quasi2.x\n        \t\t+ uint(fragCoord.y)*quasi2.y;\n     \n    // Now start with cone tracing\n    \n    const float CONES_NUM = 5.0; \n    const float MAX_DIST_CONE = 5.0;\n    const float MAX_STEPS_CONE = 16.0;\n    const float CONE_CAP_RAD = M_PI / CONES_NUM; \n\n    const float phi = 1.6180339887498948;\n    const float tau = 6.2831853071795865;\n\n    float ao = 0.0;\n\n    for( int j=0; j < int(CONES_NUM); j++ )\n    {\n        // https://mathworld.wolfram.com/DiskPointPicking.html\n        float r = sqrt((float(j) + 0.5) / CONES_NUM);\n        float a = phi * tau * float( j );\n        \n        // Dither\n        a += tau*(float(seed)/exp2(32.));\n\n        vec3 dir = vec3(sin(a) * r, sqrt( 1.0 - r * r), cos( a ) * r);\n        vec3 tangent = normalize(cross(N, vec3(1,0,0)));\n        vec3 bitangent = cross(tangent,N);\n        \n        // Rotate it\n        dir = dir.x * tangent + dir.y * N + dir.z * bitangent;\n\n        // Get the step size\n        vec3 endTrace = p + MAX_DIST_CONE * dir;\n        float len = length(p - endTrace);\n        float stepSize = len / MAX_STEPS_CONE;\n\n        float vis = 1.0f;\n\n        // Start a bit offsetted\n        for(int i = 1; i <= int(MAX_STEPS_CONE); i++)\n        {\n            vec3 stepPos = p + dir * stepSize * float(i);\n            \n            float distToStep = length(p - stepPos); \n            float radiusAtStep = tan(CONE_CAP_RAD / 2.0) * distToStep;\n            \n            float sdf_d = scene(stepPos);\n\n            vis = min( vis, smoothstep( -radiusAtStep, radiusAtStep, sdf_d ) );\n        }\n\n        ao += vis;\n    }\n    \n    // Normalize\n    ao /= CONES_NUM;\n\n    fragColor = vec4(ao, ao, ao, 1.0);\n        \n }",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}