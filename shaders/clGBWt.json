{
    "Shader": {
        "info": {
            "date": "1702644181",
            "description": "Basic geometric operations in hyperboloid model using homogeneous coordinates. Drag with mouse, set triangle size with control ring, restart angle animation with 't'. See header for more info.",
            "flags": 48,
            "hasliked": 0,
            "id": "clGBWt",
            "likes": 12,
            "name": "Hyperbolic Triangle Geometry",
            "published": 3,
            "tags": [
                "hyperbolic",
                "hyperboloid",
                "heptagon",
                "heptagon"
            ],
            "usePreview": 1,
            "username": "mla",
            "viewed": 290
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Hyperbolic Triangle Geometry, mla, 2023.\n//\n// Using the hyperboloid model for basic geometry operations, finding\n// midpoints, bisectors, doing reflections & so on. Find circumcentre,\n// orthocentre, centroid, incentre & outcentres, with the corresponding\n// lines. Figuring out what is what is left to reader.\n//\n// Circles don't appear if their centre is outside hyperbolic space,\n// though we could still show eg. the partial circle through the\n// triangle points.\n//\n// Set size of triangle with control blob (hide with 'x')\n// Mouse applies translation\n//\n// d: show region outside disc\n// l: scale width of lines (doesn't look good, a useful test though).\n// t: animation of angle\n// x: hide control blob\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Basic operations for hyperbolic (Minkowski) space\n\n// Inner product\nfloat hdot(vec3 p, vec3 q) {\n  return dot(vec3(1,1,-1)*p,q);\n}\n\nvec3 hcross(vec3 p, vec3 q) {\n  // hdot(p,hcross(p,q)) = hdot(q,hcross(p,q)) = 0\n  return cross(p,q)*vec3(1,1,-1);\n}\n\nfloat hnorm(vec3 p) {\n  return hdot(p,p);\n}\n\nfloat hlength(vec3 p) {\n  return sqrt(abs(hnorm(p)));\n}\n\n// Normalize a point or a line\nvec3 hnormalize(vec3 p) {\n  float t = hnorm(p);\n  if (t < 0.0 && p.z < 0.0) p = -p;\n  return p/sqrt(abs(t));\n}\n\nvec3 pnormalize(vec3 p) {\n  float t = hnorm(p);\n  if (t >= 0.0) return vec3(0); // Invalid point\n  if (p.z < 0.0) p = -p;\n  return p/sqrt(abs(t));\n}\n\n// Map point on plane to hyperboloid hnorm(p) = -1\nvec3 unproject(vec2 z) {\n  // k²|z|²-(1-k)² = -1\n  // k²|z|²-1+2k-k² = -1\n  // k|z|²+2-k = 0\n  float k = 2.0/(1.0-dot(z,z));\n  return vec3(k*z,k-1.0);\n}\n\n// NB: sinh(x) = asinh(x) = tanh(x) = x (approximately) for\n// small values of x (eg. sinh 0.1 = 0.10017, tanh 0.1 = 0.0997)\n// Hyperbolic distance from line\nfloat hline(vec3 p, vec3 l) {\n  //return abs(hdot(p,l)); // Asymptotic approximation\n  return abs(asinh(hdot(p,l)));\n}\n\nbool hline(inout float d, inout int t, vec3 p, vec3 l, int type) {\n  float d0 = hline(p,l);\n  if (d0 > d) return false;\n  d = d0;\n  t = type;\n  return true;\n}\n\nfloat hcircle(vec3 p, vec3 centre, float radius) {\n  float d = 2.0*abs(asinh(0.5*hlength(p-centre)));\n  return abs(d-radius);\n}\n\nbool hcircle(inout float d, inout int t, vec3 p, vec3 centre, float radius, int type) {\n  if (centre == vec3(0)) return false;\n  float d0 = hcircle(p,centre,radius);\n  if (d0 > d) return false;\n  d = d0; t = type;\n  return true;\n}\n\n// Hyperbolic distance between points\nfloat hpoint(vec3 p, vec3 q) {\n  //return acosh(-hdot(p,q)); // Bad truncation error\n  return 2.0*abs(asinh(0.5*hlength(p-q)));\n}\n\nbool hpoint(inout float d, inout int t, vec3 p, vec3 q, int type) {\n  if (q == vec3(0)) return false;\n  float d0 = hpoint(p,q);\n  if (d0 > d) return false;\n  d = d0; t = type;\n  return true;\n}\n\nbool hpoint(inout float d, inout int t, vec3 p, vec3 q) {\n  return hpoint(d,t,p,q,0);\n}\n\n// Find a point on the line formed by the intersections\n// of planes l and m. Try to find point of form\n// (x,y,0), (x,0,z) or (0,y,z) by solving a 2x2\n// linear system. Construct three matrices & use the one\n// with largest determinant (it's possible for two\n// determinants to be zero, but not all three if the\n// planes aren't parallel).\nvec3 linepoint(vec3 l, vec3 m, float a, float b) {\n  vec2 A = vec2(1,-1); // adjust for metric\n  mat2 m0 = mat2(l.xy,m.xy);\n  mat2 m1 = mat2(A*l.xz,A*m.xz);\n  mat2 m2 = mat2(A*l.yz,A*m.yz);\n  float d0 = abs(determinant(m0));\n  float d1 = abs(determinant(m1));\n  float d2 = abs(determinant(m2));\n  float dmax = max(d0,max(d1,d2));\n  if (dmax == d1) m0 = m1;\n  else if (dmax == d2) m0 = m2;\n  vec3 p = vec3(vec2(a,b)*inverse(m0),0);\n  if (dmax == d1) p = p.xzy;\n  else if (dmax == d2) p = p.zxy;\n  assert(eq(hdot(p,l),a));\n  assert(eq(hdot(p,m),b));\n  return p;\n}\n\n// Given vectors l and m, return a normalized vector n\n// with l.n = a, m.n = b (all with Minkowski product)\n// sign parameter says if we want a line (spacelike) or a point (timelike)\nbool f(vec3 l, vec3 m, float a, float b, out vec3 n, float sign) {\n  // Want a line m with hdot(l,n) = A, hdot(m,n) = B\n  vec3 r = hcross(m,l); // Direction vector for intersection of planes l and m\n  // Now find p with hdot(p,l) = A, hdot(p,m) = B\n  vec3 p = linepoint(l,m,a,b);\n  // Now try to find a normalized point on that line ie. hnorm(p+tr) = <sign>\n  // (p+tr).(p+tr) - sign = 0\n  // p.p + 2t(p.r) + t²(r.r) - 1 = 0\n  // Set p.r = 0, so B = 0 in quadratic formula\n  p -= hdot(p,r)/hdot(r,r)*r;\n  float A = hdot(r,r);\n  float C = hdot(p,p) - sign;\n  float D = -A*C;\n  if (D < 0.0) return false;\n  // Two solutions are eg. for complementary angles, opposite distances.\n  float t = sqrt(D)/A;\n  n = p+t*r;\n  return true;\n}\n\n// Find a (normalized) point p with l.p = a, m.p = b\n// l and m can be points or lines\nvec3 fpoint(vec3 l, vec3 m, float a, float b) {\n  vec3 p;\n  bool t = f(l,m,a,b,p,-1.0);\n  assert(t);\n  assert(p.z >= 0.0);\n  return p;\n}\n\n// Find a (normalized) line p with l.p = a, m.p = b\n// l and m can be points or lines\nvec3 fline(vec3 l, vec3 m, float a, float b) {\n  vec3 p;\n  bool t = f(l,m,a,b,p,1.0);\n  assert(t);\n  assert(p.z <= 0.0);\n  return p;\n}\n\n// Get point on line l, distance d from p, also on l.\n// Same as fpoint(p,l,-cosh(d),0) but less rounding error.\n// ie. get q such that q.l = 0, q.p = -cosh(d)\n// hcross(p,l) is perpendicular to l at p, \nvec3 pointatdistance(vec3 p, vec3 l, float d) {\n  //return fpoint(p,l,-cosh(d),0.0);\n  vec3 r = hcross(l,p); // Tangent vector\n  float k = tanh(d)/hlength(r); // Get right angle\n  vec3 q = p+k*r;\n  return hnormalize(q); // And normalize\n}\n\n// Reflect in a hyperbolic line\nint tryreflect(vec3 l, int i, inout vec3 p, inout uint h) {\n  float k = hdot(p,l);\n  if (k > 0.0) return 0;\n  p -= 2.0*k*l;\n  h = ihash(h^uint(i));\n  return 1;\n}\n\n// Reflect in a euclidean line\nint tryreflect(vec2 l, int i, inout vec2 z, inout uint h) {\n  float k = dot(z,l);\n  if (k > 0.0) return 0;\n  z -= 2.0*k*l;\n  h = ihash(h^uint(i));\n  return 1;\n}\n\n// Invert in a euclidean circle\nint tryinvert(vec3 c, int i, inout vec2 z, inout uint h) {\n  float r2 = c.z;\n  vec2 z1 = z-c.xy;\n  float l2 = dot(z1,z1);\n  if (l2 > r2) return 0;\n  z1 *= r2/l2;\n  z = z1+c.xy;\n  h = ihash(h^uint(i));\n  return 1;\n}\n\n// Convert hyperbolic line into a Euclidean circle.\n// z component is square of radius.\nvec3 tocircle(vec3 l) {\n  assert(l.z != 0.0);\n  l /= l.z;\n  l.z = dot(l.xy,l.xy)-1.0;\n  return l;\n}\n\n// Convert hyperbolic line into a Euclidean line.\nvec2 toline(vec3 l) {\n  assert(l.z == 0.0);\n  return l.xy;\n}\n\n// Given a Euclidean distance d, and a direction p, return\n// an hspace point that is at that distance and direction\n// from the centre in the Poincare disc.\nvec3 pointfromcentre(float d, vec2 p) {\n  float x = 2.0*d/(1.0-d*d);\n  float t = sqrt(1.0+x*x);\n  return vec3(x*p,t);\n}\n\nvec3 hreflect(vec3 p, vec3 m) {\n  p -= 2.0*hdot(p,m)*m;\n  return p;\n}\n\nvec3 hperp(vec3 p, vec3 m) {\n  p -= hdot(p,m)*m;\n  return pnormalize(p);\n}\n\nvec3 mpoint(vec3 A, vec3 B, vec3 C, float t) {\n  float d[] = float[](acosh(-hdot(A,B)),\n                      acosh(-hdot(B,C)),\n                      acosh(-hdot(C,A)));\n  float ttime = d[0]+d[1]+d[2];\n  t = mod(t,ttime);\n  vec3 P0 = A, P1 = B;\n  do {\n    // This seems a bit awkward\n    if (t < d[0]) break;\n    t -= d[0];\n    if (t < d[1]) { P0 = B; P1 = C; break; }\n    t -= d[1];\n    P0 = C, P1 = A;\n  } while(false);\n  // We could express P as aA+bB then\n  // |aA+bB|² = -1 and (aA+bB).P = cosh(-t)\n  vec3 P = pointatdistance(P0,hcross(P0,P1),t);\n  return P;\n}\n\nvec3 getcol(int t) {\n  if (t == 0) return vec3(0);\n  if (t == 1) return vec3(1,0,0);\n  if (t == 2) return vec3(0,1,0);\n  if (t == 3) return vec3(0,0,1);\n  if (t == 4) return vec3(1,1,0);\n  if (t == 5) return vec3(1);\n  return vec3(1,0,1);\n}\n\n// A+B is midpoint\n// A-B is perp bisector (a line)\n// a-b, a+b are internal & external bisectors (depending on orientation of the lines)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 z = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  vec2 w = defaultselection();\n  vec2 params = 2.0*abs(getselection(0));\n  float scale = 1.0;\n  scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  z *= scale;\n  w *= scale;\n  float lwidth = 0.02;\n  float pwidth = 3.0*lwidth;\n  if (!key(CHAR_L)) { lwidth = 0.0; pwidth = 0.02; }\n  \n  float px = fwidth(z.x);\n  bool dohalfplane = key(CHAR_H);\n  bool dozoom = key(CHAR_Z);\n  if (dohalfplane) z.y += scale;\n  // Conversion factor between hyperbolic and screen distances\n  float scalefactor = 1.0;\n  if (dohalfplane) {\n    if (dozoom) {\n      float k = exp(-iTime);\n      z *= k;\n      scalefactor /= k;\n    }\n    z.y += 1.0;\n    float k = 2.0/dot(z,z);\n    z *= k;\n    scalefactor /= k;\n    z.y -= 1.0;\n  }\n  scalefactor *= 0.5*abs(1.0 - dot(z,z)); // Scale factor for disc\n  if (true) {\n    // Invert to mouse position\n    vec2 c = w;\n    z -= c;\n    z *= (dot(c,c)-1.0)/dot(z,z);\n    z += c;\n    z /= -dot(z,z);\n  }\n  bool indisc = dot(z,z) <= 1.0;\n  if (!indisc) z /= dot(z,z);\n  vec3 p = unproject(z);\n  float theta = PI/3.0;\n  if (iMouse.x <= 0.0 || key(CHAR_T)) theta += 0.25*iTime;\n  // Three triangle points, A is at the origin,\n  // A,B,C are in clockwise order for theta < 180°\n  vec3 b = vec3(1,0,0);\n  vec3 c = vec3(-cos(theta),sin(theta),0);\n  vec3 A = vec3(0,0,1);\n  vec3 B = pointatdistance(A,c,params[0]); // Note line orientation!\n  vec3 C = pointatdistance(A,-b,params[1]);\n  vec3 a = hnormalize(hcross(B,C));\n  // Depending on orientation of the triangle, inside is either\n  // all positive or all negative.\n  bool intriangle = hdot(p,a) > 0.0 && hdot(p,b) > 0.0 && hdot(p,c) > 0.0;\n  bool outtriangle = hdot(p,a) < 0.0 && hdot(p,b) < 0.0 && hdot(p,c) < 0.0;\n  // Feet of altitudes\n  vec3 D = hperp(A,a);\n  vec3 E = hperp(B,b);\n  vec3 F = hperp(C,c);\n  // The altitude lines\n  vec3 dline = hnormalize(hcross(A,D));\n  vec3 e = hnormalize(hcross(B,E));\n  vec3 f = hnormalize(hcross(C,F));\n  // Orthocentre\n  vec3 ortho = pnormalize(hcross(dline,e));\n  vec3 circum = pnormalize(hcross(A-B,B-C));\n  vec3 incentre = pnormalize(hcross(a-b,b-c));\n  float inradius = hpoint(incentre,hperp(incentre,a));\n  vec3 out1 = pnormalize(hcross(a-b,b+c));\n  vec3 out2 = pnormalize(hcross(b-c,c+a));\n  vec3 out3 = pnormalize(hcross(c-a,a+b));\n  // Median points and lines\n  vec3 A1 = hcross(a,B-C);\n  vec3 B1 = hcross(b,C-A);\n  vec3 C1 = hcross(c,A-B);\n  vec3 a1 = hnormalize(hcross(A,B+C));\n  vec3 b1 = hnormalize(hcross(B,C+A));\n  vec3 c1 = hnormalize(hcross(C,A+B));\n  vec3 cent = pnormalize(hcross(a1,b1));\n  vec3 T = mpoint(D,E,F,0.5*iTime);\n#if 0\n  vec3 T1 = hreflect(hreflect(T,b),a);\n  vec3 t1 = hnormalize(hcross(T,T1));\n  vec3 t2 = hreflect(t1,a);\n  vec3 t3 = hreflect(t2,b);\n#endif\n  vec3 col = vec3(0.5);\n  if (!intriangle && !outtriangle) col *= 0.8;\n  {\n    float d = 1e8;\n    int t = -1;\n    hline(d,t,p,a,0);\n    hline(d,t,p,b,0);\n    hline(d,t,p,c,0);\n    // Internal and external bisectors\n    hline(d,t,p,hnormalize(a-b),1);\n    hline(d,t,p,hnormalize(b-c),1);\n    hline(d,t,p,hnormalize(c-a),1);\n    hcircle(d,t,p,incentre,inradius,0);\n    hcircle(d,t,p,out1,hpoint(out1,hperp(out1,a)),0);\n    hcircle(d,t,p,out2,hpoint(out2,hperp(out2,a)),0);\n    hcircle(d,t,p,out3,hpoint(out3,hperp(out3,a)),0);\n    hcircle(d,t,p,circum,hpoint(circum,A),0);\n    hline(d,t,p,hnormalize(hcross(D,E)),5);\n    hline(d,t,p,hnormalize(hcross(E,F)),5);\n    hline(d,t,p,hnormalize(hcross(F,D)),5);\n#if 1\n    hline(d,t,p,hnormalize(a+b),1);\n    hline(d,t,p,hnormalize(b+c),1);\n    hline(d,t,p,hnormalize(c+a),1);\n#endif\n    // Medians\n    hline(d,t,p,a1,2);\n    hline(d,t,p,b1,2);\n    hline(d,t,p,c1,2);\n\n#if 0\n    hline(d,t,p,t1,0);\n    hline(d,t,p,t2,0);\n    hline(d,t,p,t3,0);\n#endif\n#if 1\n    // Perp bisectors, intersecting at circumcentre\n    hline(d,t,p,hnormalize(A-B),3);\n    hline(d,t,p,hnormalize(B-C),3);\n    hline(d,t,p,hnormalize(C-A),3);\n    // Altitudes\n    hline(d,t,p,dline,4);\n    hline(d,t,p,e,4);\n    hline(d,t,p,f,4);\n#endif\n    vec3 lcol = getcol(t);\n    col = mix(lcol,col,smoothstep(0.0,px/scalefactor,d-lwidth));\n  }\n  {\n    float d = 1e8;\n    int t = 0;\n    //hpoint(d,t,p,pnormalize(A+B),3);\n    hpoint(d,t,p,A);\n    hpoint(d,t,p,B);\n    hpoint(d,t,p,C);\n    hpoint(d,t,p,ortho);\n    hpoint(d,t,p,circum);\n    hpoint(d,t,p,cent);\n    hpoint(d,t,p,incentre);\n    hpoint(d,t,p,out1);\n    hpoint(d,t,p,out2);\n    hpoint(d,t,p,out3);\n    hpoint(d,t,p,T,1);\n    //hpoint(d,t,p,T1,1);\n#if 0\n    hpoint(d,t,p,D);\n    hpoint(d,t,p,E);\n    hpoint(d,t,p,F);\n#endif\n    col = mix(getcol(t),col,smoothstep(0.0,px/scalefactor,d-pwidth));\n  }\n  if (!indisc) col *= !key(CHAR_D) ? 0.0 : 0.5;\n  if (showconfig) {\n    vec2 p = map(fragCoord);\n    float d = abs(distance(p,getselection(0))-0.03)-0.005;\n    col = mix(vec3(1,0,0),col,0.25+0.75*smoothstep(0.0,px,d));\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 t, vec2 uv) {\n  //setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  vec4 t0 = texelFetch(iChannel2,ivec2(0),0); // Get current state   \n  if (t0 != vec4(1234.0)) {\n    t = vec4(0);\n  }  \n  if (j == 0) {\n    if (i == 0) t = vec4(1234.0);\n    else {\n      // First row - key count\n      // Do key repeat here as well?\n      float w1 = keystate(i,0).x;\n      if (w1 != t.w) {\n        t.w = w1;\n        // Don't count key changes when ALT pressed\n        if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n          t.x++; t.y = iTime;\n        }\n      }\n      // Key repeat - only when shader is running!\n      // Should have longer pause after first key press.\n      if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n        t.x++; t.y = iTime;\n      }\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (showconfig && t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        t.x = -1.0;\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < 0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n      if (t.x <= 0.0 && iMouse.z > 0.0) {\n        t.zw = iMouse.x < 20.0 ? vec2(0) : map(iMouse.xy);\n      }\n    } else if (t.w != 1234.0) {\n      t.xy = initselection(i-1); // Current coordinates\n      t.w = 1234.0;\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store((key),0).x))\n#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\n#define map(screenpos) ((2.0*(screenpos)-iResolution.xy)/iResolution.y)\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n//#define getselected() (texelFetch(iChannel2,ivec2(0,3),0))\n#define defaultselection() (texelFetch(iChannel2,ivec2(0,3),0).zw)\n//#define setscale() (scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP))))\n#define showconfig (!key(CHAR_X))\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst float PI =  3.141592654;\n\nconst int nselections = 1;\nvec2 initselection(int i) {\n  if (i == 0) return vec2(1,0.8);\n  if (i == 1) return vec2(0.75,0.25);\n  if (i == 2) return vec2(-2,-1.5);\n  if (i == 3) return vec2(0,-1);\n  if (i == 4) return vec2(0.25,0);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return mix(vec3(1),rgb,0.8);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec2 expi(float t) {\n  return normalize(vec2(cos(t),sin(t)));\n}\n\nbool eq(float a, float b) {\n  return abs(a-b) < 1e-4;\n}\n\nfloat COS[] =\n  float[](1.0,-1.0,0.0,0.5,0.7071067812,0.8090169944,0.8660254038,\n          0.9009688679,0.9238795325,0.9396926208,0.9510565163,0.9594929736,\n          0.9659258263,0.9709418174,0.9749279122,0.9781476007,0.9807852804,\n          0.9829730997,0.984807753,0.9863613034,0.9876883406,0.9888308262,\n          0.9898214419,0.990685946,0.9914448614,0.9921147013,0.9927088741,\n          0.9932383577,0.9937122099,0.9941379572,0.9945218954,0.9948693234);\n\nfloat icos(int p) {\n  // cos(PI/p)\n  if (p < COS.length()) return COS[p];\n  return cos(PI/float(p));\n}\n                        \nfloat isin(int p) {\n  // sin(PI/p)\n  float t = icos(p);\n  return sqrt(1.0-t*t);\n}\n\n// GPU cos might not be good enough for repeated reflections\n// Chebyshev might be better here, but these work pretty well.\nfloat mycos(float x) {\n  return cos(x);\n  int N = 14;\n  float x2 = x*x, y = 1.0;\n  for (int n = N; n > 0; n-=2) {\n    y = 1.0-x2*y/float(n*(n-1));\n  }\n  return y;\n}\n\nfloat mysin(float x) {\n  return sin(x);\n  int N = 12;\n  float x2 = x*x, y = 1.0;\n  for (int n = N; n > 0; n-=2) {\n    y = 1.0-x2*y/float(n*(n+1));\n  }\n  return x*y;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}