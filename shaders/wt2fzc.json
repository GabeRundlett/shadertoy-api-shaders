{
    "Shader": {
        "info": {
            "date": "1599552826",
            "description": "in addition to smart antialiasing of [url]https://shadertoy.com/view/Wt2fzV[/url], \nhere we interpolate to avoid banding artifact ( pseudo-shading = iteration , + color from hit point )\n\nMouse.x : ref separator   SPACE: show where oversampling is done",
            "flags": 48,
            "hasliked": 0,
            "id": "wt2fzc",
            "likes": 22,
            "name": "smoothing band in sphere tracing",
            "published": 3,
            "tags": [
                "raytracing",
                "raymarching",
                "antialiasing",
                "spheretracing",
                "sampling",
                "optimization",
                "adaptive",
                "gpmipmap",
                "spacefungus",
                "raysurfing"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 608
        },
        "renderpass": [
            {
                "code": "// adapted from https://shadertoy.com/view/Wt2fzV\n#define N 5      // pixel oversampling NxN ( only where necessary )\n#define eps .05  // similarity threshold, is case of continuous mask\n\n//#define T(U,l)          texelFetch(iChannel0, ivec2(U)>>l, l)\n  #define T(U,l)          textureLod(iChannel0, (U)/R, float(l-1) )\n//#define M(U,l)          T(U,l).w\n  #define M(U,l)        ( length( T(U,l).rgb )*.58 ) \n  #define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n     vec2  U = ( 2.*u - R ) / R.y;      // normalized centered coords\n   \n    O -= O;                             // background\n    vec4 C = vec4(0);\n\n    float n = float(N),\n       // m = M( u, 3 ),                // check neighborhood. Here: LOD #2 of mask\n          s = iMouse.z>0. ? iMouse.x : R.x/2.;\n    sep = u.x > s;\n    if ( sep\n     //  && abs(m-M(u,0)) > eps ) {     // neighborhood does not agree\n         && length( T(u,3) - T(u,0) ) > eps ) { // thanks Gijs !\n        for (int k=0; k<N*N; k++) {     // --- oversampling\n            vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. ) / n; // subpixel\n            C += f(  U +  2.*D/R.y , iTime);\n        }\n        C /= n*n;\n    }\n    else                                // LOD#0 is ok\n        C = T( u, 0 ),\n        keyToggle(32)                   // SPACE: show red/blue where not oversampled\n            ? C.r -= .5*C.a, C.b += .5*(1.-C.a) , C.a = 1.: n;\n        \n    O = mix( O, C, C.a );\n    if ( abs(u.x-s) < 1. ) O = vec4(1,0,0,1); // red separator\n    O = pow( O, vec4(1./2.2) );         // to sRGB\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// --- custom function or image or render\n\n#define R  iResolution.xy\nbool       sep = true;    // to separate left/right cases\n\n// Space fungus https://www.shadertoy.com/view/lsSBWh\n\n#define map(q) (                                                     \\\n    t = max( length(q) - 9.,                        /* Sphere */     \\\n             abs(a=cos(b=3.*dot(sin(q),D/D)))/9. ), /* EggCarton */  \\\n    t = max( t, 8.5-length(q) ),                    /* inner hole */ \\\n    t )\n//  q = mod(q,.5)-.25, t = max(t,.2-length(q) ),    /* cheese holes  */\n\nvec4 f(vec2 U, float t) {\n    float a,b,                                        // materials id\n        _t, c = 1., s = .015;                         // color (pseudo-shading), delta per iteration\n    mat2  rot = mat2( cos( .1*t + vec4(0,33,11,0)) );  \n    vec3  D = normalize( vec3(U,-1) ),                // ray direction\n          p = vec3(0,0,13), q;                        // ray origin, then current point on ray\n    D.xz *= rot, D.yz *= rot,                         // rotate camera\n    p.xz *= rot, p.yz *= rot;\n\n    for ( ; c > 0. && t > .01 ; c -= s )              // march scene\n        q = p, _t=t,\n        t = map(q),                                   // distance to objects\n        p += t*D;                                     // sphere-tracing step\n\n    if ( c > 0. && sep )  // && abs(t-abs(a)/9.) < 1e-4 && t > 1e-4 ) // [ trying to avoid the artifact turnedaround by the min ]\n        c += s * ( 1. - 2.3*t/.01 ),  // pseudo-shading: interpolate between iterations [why this ? + not perfect ]\n        t = min( _t/t*(_t-t), .01 ),  // Taylor series estimation of true distance [ min: because an artifact I don't understand. would be better without ]\n        p += t*D, t = map(p);         // go there and reeval, to correct hit point material \n    \n    vec4 O = vec4(c);                                 // output color\n    if (c > 0.) O.r -= b/30., O.g -= a, O*=O,         // coloring\n                O.a = 1.;                             // hit -> opaque\n       else     O -= O;\n    return O;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// --- evaluate the function everywhere at pixel resolution\n\nvoid mainImage(out vec4 O, vec2 u) {\n    sep = u.x > ( iMouse.z>0. ? iMouse.x : R.x/2. );\n\n    vec2  U = ( 2.*u - R ) / R.y;      // normalized centered coords\n    O = f( U, iTime );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}