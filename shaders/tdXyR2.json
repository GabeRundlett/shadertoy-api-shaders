{
    "Shader": {
        "info": {
            "date": "1585174979",
            "description": "potato",
            "flags": 40,
            "hasliked": 0,
            "id": "tdXyR2",
            "likes": 17,
            "name": "Day 987",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 445
        },
        "renderpass": [
            {
                "code": "// radiual blur in this buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\n    // Radial blur\n    float steps = 20.;\n    float scale = 0.00 + pow(length(uv - 0.5),1.8)*0.06;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*3.3;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.9);\n    \n    fragColor.gb *= 0.95  - smoothstep(0.,1.,dot(uvn,uvn))*0.1;\n    \n    fragColor.b *= 1. + uv.x*0.02;\n    fragColor.g *= 1. + uv.t*0.05;\n    \n    fragColor = max(fragColor, 0.);\n    //fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*0.1));\n    fragColor *= 1. - dot(uvn,uvn)*0.9    ;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi acos(-1.)\n#define tau (2.*pi)\n#define TT (tau*t)\n#define tt (tau*t)\n\n#define init vec2 s = vec2(0)\n#define ret return s\n#define bpm 140.\n\n#define tick (60./bpm)\n\n#define beat tick\n#define bar  beat*4.\n#define hbar  bar/2.\n#define msr  bar*4.\n#define hbeat tick/2.\n#define qbeat tick/4.\n\n#define S vec2 s = vec2(0);\n#define E return s;\n#define T true\n#define F false\n\n\nbool[] pattA = bool[8](T,F,T,T,F,T,F,F);\nbool[] pattS = bool[8](F,T,F,T,F,T,F,T);\n\n\nbool[] pattBa = bool[8](T,T,F,T,F,T,F,T);\nbool[] pattB = bool[8](T,F,T,T,F,T,F,T);\nint[] notesB = int[8](0,5,2,1,0,1,3,4);\n\nvec4[] chords = vec4[4](\n    vec4(0.,3.,7.,10.),\n    vec4(0. + 2.,3. + 2.,7. + 2.,10. + 2.),\n    vec4(0. - 2.,3. - 2.,7. - 2.,10. - 2.),\n    vec4(0.+3.,5.+3.,7.+3. - 12.,10. )\n);\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\n\nvec2 hash22(vec2 p)\n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float ft = fract(t);\n    float tn = t - ft;\n    ft = smoothstep(0.0, 1.0, ft);\n\n    vec2 n0 = noise(floor(tn + 0.0) / fq);\n    vec2 n1 = noise(floor(tn + 1.0) / fq);\n\n    return mix(n0, n1, ft);\n}\n\nvec2 kick (float t, inout float sc){\n\tinit;\n\t\n    \n    float md = beat;\n    float pl = 8.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    float env = exp(-t*40.7);\n    s += sin((exp(-t*15.1)*200. + 40.)*tt )*env;\n    \n    s = mix(s,sin(s*3.)*1., 0.3);\n    \n    \n    float bitreduction = 0.04;\n    s = sign(s) * floor(abs(s)/bitreduction)*bitreduction;\n    \n    //s = sign(s)*smoothstep(0.,1.,abs(s));\n    \n    \n    s = clamp(s,-1., 1.);\n    \n    \n    float att = float(pattA[int(idx)]);\n    s *= att;\n    sc = 1. - pow(env, 0.15)*att;\n    sc = smoothstep(0.,1.,sc);\n    ret;\n}\n\n\n\nvec2 snare(float t){\n\n    init;\n    \n    float md = beat;\n    float pl = 8.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 3500.)*0.45;\n    \n    float amt = 1.;\n    float env = exp(-t*16.);\n    //float f = (400. + exp(-t*50.)*600.)*tt;\n    float f = (440./1.5 + exp(-t*50.)*1400.  )*tt;\n    s += sin( f )*env;\n    //s += sin( f*2.25 )*env*0.1;\n    //s += sin( f*1.5 )*env*0.1;\n    s += amt*sin( f + nn*0.9*smoothstep(0.,1.,t*20.) )*env;\n    s -= amt*sin( f )*env;\n    \n    \n    //s += sign(s)*pow(abs(s), vec2(2.))*0.9;\n    s += amt*sin( f*4. + nn.x*exp(-t*10.))*env*env*0.2;\n    //s *= 1.6;\n    s *= 0.39;\n    //s = mix(s,sign(s)*smoothstep(0.1,1.,abs(s)), 0.1);\n\ts = sin(s*1.5);\n    \n    s *= float(pattS[int(idx)]);\n    ret;\n}\n\nvec2 lead(float t){\n\tinit;\n\t\n    float to;\n    vec2 nn = lpnoise(t, 600.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 5500.)*0.1;\n    \n    \n    vec2 id;\n    float r = bar;\n    t = mod(t, r*4.);\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,bar);\n    float reps = 16.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \n    \n    float amt = 0.4;\n    float env = exp(-t*10.4);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    //n += floor(id.y/4.)*12.;\n    \n    s += sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*0.4)*env;\n    s -= sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    //s += sin(f + sin(2000.*tt)*exp(-t*20.))*env;\n    \n    \n    float bitreduction = 0.3 + sin(6.28*to/beat)*0.0;\n    s = mix(s,sign(s) * floor(abs(s)/bitreduction)*bitreduction, 0.1 + smoothstep(0.,1.,t*2.)*0.7);\n    \n    //s += sin( f )*env;\n    //s += amt*sin( f + nn*0.5 )*env;\n    //s -= amt*sin( f )*env;\n    \n    s *= 0.7;\n    ret;\n}\n\n\nvec2 chord(float t){\n\tinit;\n    \n    float r = bar;\n    t = mod(t,r*4.);\n    int id = int(floor(t/r));\n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 4500.)*0.45;\n    \n    nn *= 0.1*sin(t);\n    float m = 1.;\n    for(float i = 0.; i < 5.; i++){\n        float a = (1. + i/2.);\n    \ts += sin( note(chords[id].x, 4.) *tt*a + nn)*m;\n    \ts += sin( note(chords[id].y, 4.) *tt*a + nn)*m;\n    \ts += sin( note(chords[id].z, 4.) *tt*a + nn)*m;\n    \ts += sin( note(chords[id].w, 4.) *tt*a + nn)*m;\n    \tm *= 0.5;\n    }\n    \n    \n    s *= 0.04;\n    //s = sin(s);\n\tret;\n}\n\nvec2 bass(float t){\n\tinit;\n\t\n    float ttt = t;\n    float r = bar;\n    t = mod(t,r*4.);\n    \n    float bt = mod(t,beat*2.);\n    ivec2 id = ivec2(int(floor(t/r)),int(floor(bt/(beat/4.))));\n    \n    //t = mod(t, beat*2.);\n    \n    bt = mod(bt, beat/4.);\n    t = bt;\n    float env = exp(-t*1.);\n    float n = note(chords[id.x][id.y],1.);\n    s += sin(n*tt \n             + sin(n*2.*tt)*exp(-bt*9.)*0.6\n             + sin(n*4.*tt)*exp(-bt*10.)*1.\n            \n            )*env;\n    \n    \n    \n    s *= float(pattB[id.y]);\n    \n    \n    \n    float bitreduction = 0.04;\n    s = sign(s) * floor(abs(s)/bitreduction)*bitreduction;\n    //s += sin(200.*tt + exp(-t*3.1)*200.)*exp(-t*3.7)*(1. - exp(-t*1.4));\n    \n    \n    ret;\n}\n\nvec2 hats (float t){\n\tinit;\n\t\n    t = mod(t + 0., hbeat*0.5);\n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 5500.)*0.4;\n    \n    float amt = 1.;\n    float env = exp(-t*15.4);\n    float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((9000. )*tt)*exp(-t*2.)*0.5 + ( 2000. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    s *= 0.7;\n    ret;\n}\nvec2 hatsb (float t){\n\tinit;\n\t\n    t = mod(t + 0., hbeat/0.5);\n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 5500.)*0.4;\n    \n    float amt = 1.;\n    float env = exp(-t*5.4);\n    float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((9000. )*tt)*exp(-t*2.)*0.5 + ( 2000. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    float bitreduction = 0.35;\n    s = sign(s) * floor(abs(s)/bitreduction)*bitreduction;\n    \n    s *= 0.7;\n    ret;\n}\n\n\nvec2 mainSound( in int samp, float t )\n{\n    vec2 s= vec2(0);\n    \n    \n    float sc;\n    s += kick(t,sc)*1.;\n    s += bass(t)*0.4*pow(sc, 1.4);\n    s += snare(t);\n    s += chord(t)*sc;\n    s += hats(t)*0.06*(0.2 + pow(sc, 2.)*0.8)*0.4;\n    s += hatsb(t)*0.06*(0.2 + pow(sc, 1.)*0.8)*0.7;\n    s += lead(t)*0.4;\n    s *= 0.8;\n    \n    s = mix(s,sign(s)*smoothstep(0.1,1.,abs(s)), 0.2 + sin(t)*0.2);\n    s = clamp(s,-1.,1.);\n    \n    s *= smoothstep(0.,1.,t*0.5);\n    return s;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "\n\n// Fork of \"Day 98\" by jeyko. https://shadertoy.com/view/tdXyR2\n// 2020-03-25 16:38:38\n\n// Fork of \"Day 97\" by jeyko. https://shadertoy.com/view/tslyRB\n// 2020-03-25 10:51:05\n\n#define pmod(p,x) mod(p,x) - 0.5*x\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define iTime (iTime*1.6)\n\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    n += valueNoise(uv*800.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n -= valueNoise(uv*10.,1.)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.5;\n    n = max(n, 0.);\n    return n;\n}\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n\nfloat xor(vec2 p){\n    ivec2 q = ivec2(p);\n\treturn float(q.x^q.y);\n}\n\nvec3 get(vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n\tvec2 uvn = uv;\n    //uv *= 1. - dot(uv,uv)*0.3;\n    \n    uv *= 1. - dot(uv,uv)*0.3 + valueNoise(vec2(iTime),0.2).x*0.4;\n    //vec3 aa =pal(0.5,0.55,vec3(0.1,0.7,0.9), 0.6 + sin(id*0.4 + iTime)*.4, id*0.9 + iTime*0.5 - dot(uvn,uvn)*.5);\n    \n    vec2 p = uv;\n    \n    \n    \n    \n    float its = 2.;\n    for(float i = 0.; i < its; i++){\n        //p = abs(p);\n        float dpp = dot(p,p);\n        dpp = clamp(dpp, 0.1,1.);\n    \tp = (p)/dpp;\n        p = clamp(p, -5.,1.7);\n    \tp = vec2(2.*atan(p.y, p.x)/6.28, length(p));\n        if(i == 0.)\n        \tp *= xor(abs(p)*2.)*0.25;\n        if(p.x < 0. && p.y > 0. && i == 1. && false)\n            p.xy = p.yx;\n    }\n    \n    \n    p.y = 0.05*log(p.y) + (iTime)*0.004;\n    \n    \n    float modD = 0.01;\n    vec2 id = floor(p/modD);\n    \n\n    col += mod(id.x, 2.);\n    col += mod(id.y, 2.);\n    \n    \n    col = max(col, 0.);\n    col = mix(col,smoothstep(0.,1.,col), 0.8);\n    \n    col -= fbm(uvn).x*0.01;\n    col += fbm(uv + 4.).x*0.01;\n    \n    col = max(col, 0.);\n    col = pow(col, vec3(1. + dot(uvn,uvn)*0.4) );\n    \n    col *= 1. - dot(uvn,uvn);\n    \n    return col;\n}\n    \n    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    for(float i =0.; i < 9. + float(min(iFrame,0)); i++){\n    \tcol += get(fragCoord + vec2(mod(i,3.),floor(i/3.))*0.25);\n    }\n    col /= 9.;\n    \n    col = max(col, 0.);\n\tcol = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}