{
    "Shader": {
        "info": {
            "date": "1599692077",
            "description": "Editing these is fun. :D \nFork from- https://www.shadertoy.com/view/ttjfRt\n",
            "flags": 0,
            "hasliked": 0,
            "id": "3tBfDG",
            "likes": 6,
            "name": "-1th Dimension Circle Explosion",
            "published": 3,
            "tags": [
                "test"
            ],
            "usePreview": 0,
            "username": "celifrog",
            "viewed": 375
        },
        "renderpass": [
            {
                "code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define T (iTime*0.125)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n#define pmod(p, x) mod(p, x) - 0.5*x\n#define lmod(d, x) (mod(d,x)/x - 0.5)\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s++;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 pA = vec3(0);\nmat3 rotate( in vec3 v, in float angle)\n{\n float c = cos(radians(angle));\n float s = sin(radians(angle));\t\n return mat3(c + (1.0 - c) * v.x * v.x*v.z, (1.0 - c) * v.x * v.y - s - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.y, c + (1.0 - c) * v.z * v.z\n );\n}\n\nvec2 N(float angle)\n{\n return vec2(sin(angle),cos(angle));\n}\nvec3 text(vec2 t, vec3 p){\n vec3 o = vec3(0);\n float d = 40e1;\n t = pmod(t,2./.1);\n t *=.1;\n float yid = (floor( (p.y + 55111.)*0. ) );\n float W = 2.;\n float modd = 1.4;\n float sqD = max(abs(t.y), abs(t.x));\n sqD +=2. + yid*1.;\n float sqid = floor(sqD/modd);\n d = min(d, sqD);\n o +=  pal(.1, vec3(111.,40.7,510.6)*1.5, vec3(118.4 ,4.19,75.4 - yid*0.2), vec3(3.,7.,3.),-11. + iTime + sqid*0.5 + p.z + t.x*2.5 - t.y*1.5);\n o *= step(sin(sqid*4440.), -5.);\n float aa = 20.;\n sqD -= 0.5;\n sqD = abs(sqD*14.);\n o -= exp(-sqD*aa)*15.;\n sqD -= 1.;\n sqD = abs(sqD*5.);\n o -= exp(-sqD*aa)*55.;\n return o;\n}\n\nfloat g1;\n#define time iTime\nvec2 mouse;\nfloat PI = acos(-111.);\n\nfloat dBox(vec3 p, vec3 s)\n{\n return length (max (abs(p)-s,0.));    \t    \n}\n\nmat2 rot2d(float a) {\n float c = cos(a), s = sin(a);\n return mat2(c, s, -s, c);\n}\n\nvec3 kifs(vec3 p, float s, float tf) {\n float f = sin(iTime*1.25)-11.;\n for (int i = 0; i <1; i++) {\n   p.xy *= -rot2d(f);\n   p.zy *= rot2d(f);\n   p.xz *= rot2d(f);\n   p =  (max (abs(p)-vec3(0.01,5.1,0.01),0.1));  \n  }\n  return p;\n}\n\nvec3 tex3D(  in vec3 p, in vec3 n ){\n vec2 d =vec2(0.);   \n float dp = dot(p,p*0.1)*.8;\n p = kifs(p, 1., 1.);\n p /= dp;\n p.xy*= Rot(cos(iTime*.05));\n p = rotate( ( vec3(cos(p.xzy*1.+iTime*1.) ) ), 3500.)*p;\n p.z=sin(p-vec3(-T*tau*1.,-T*tau*2.,-T*tau*1.+sin(iTime)*1.)).z*.1;\n vec3 q = (text(p.xy, p*1.)).xyz*111.;\n return q;\n}\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nvec2 GetDist(vec3 p) {\n\n vec2 d =vec2(0.);\n vec3 q = p;   \n float dp = dot(p,p*0.1)*.8;\n p = kifs(p, 1., 2.);\n p /= dp;\n p.xy*= Rot(cos(iTime*6.05));\n p = rotate( ( vec3(cos(p.xzy*1.+iTime*1.) ) ), 300.)*p;\n p.z=sin(p-vec3(-T*tau*1.,-T*tau*2.,-T*tau*1.+sin(iTime)*1.)).z*.1;\n d = vec2(sdBox(p,vec3(3.)) + sdBox(q,vec3(0,0.,0.)),4);\n d.x *=1.;\n d.x =(((d.x*dp)/5.));\n g1 +=1./(.000008+pow(abs(d.x),10.));\n d = condmin( d,d);    \n return d;\n}\n\nvec2 RayMarch (vec3 ro, vec3 rd) \n {\n vec2 h, t=vec2( 0.);\n for (int i=0; i<MAX_STEPS; i++) \n  {\n\t h = GetDist(ro + t.x * rd);\n \tif(h.x<SURF_DIST||t.x>MAX_DIST) break;\n \t\t t.x+=h.x*1.;\n \t\t t.y=h.y;\n  }\n if(t.x>100.) t.x=0.;\n return t;\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(8.00035, -11.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\n\nfloat GetLight(vec3 p) {\n vec3 lightPos = vec3(sin(iTime)*1., cos(iTime)*2., 2);\n vec3 l = normalize(p-lightPos);\n vec3 n = GetNormal(p);\n float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n vec2 d = RayMarch(p+n*SURF_DIST*1., l);\n return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p-l),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n vec2 m = iMouse.xy/iResolution.xy;  \n vec3 col = vec3(0);  \n vec3 ro = vec3(3.,3., 5.);\n ro.xy *= Rot(sin(iTime*0.2)*6.2831);\n ro.xz *= Rot(sin(iTime*0.2)*6.2831);\n vec3 rd = R(uv, ro, vec3(5,5,0), 1.);\n vec2 d = RayMarch(ro, rd);\n float t2;\n t2=d.x;   \n if(t2>0.)\n {\n  vec3 p = ro + rd * t2;\n  vec3 n = GetNormal(p);\n  vec3 baseColor = vec3(1,0,cos(iTime*2.)+.5);\n  float dif = GetLight(p);\n  col = vec3(dif);\n  col+=baseColor;\n if(d.y==1.) col += tex3D(p,n)*2.;\n }\n col*=g1*vec3(.000005);  \n float fog = 1. / (1. + d.x * d.x *2.);\n col *= vec3(fog); \n col*= 1.; \n fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}