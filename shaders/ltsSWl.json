{
    "Shader": {
        "info": {
            "date": "1440711344",
            "description": "A prototype of one of the many overlay effects for demoscene production \"Emix\" (https://www.youtube.com/watch?v=F415chvZhHo)",
            "flags": 0,
            "hasliked": 0,
            "id": "ltsSWl",
            "likes": 7,
            "name": "emix-0012",
            "published": 3,
            "tags": [
                "tunnel",
                "vj"
            ],
            "usePreview": 0,
            "username": "sm",
            "viewed": 867
        },
        "renderpass": [
            {
                "code": "const int Npoly = 3;\nconst float TWOPI = 6.283185;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 rayPlane(vec3 p, vec3 o, vec3 n, vec3 d) {\n    float dn = dot(d, n);\n    float s = 1e8;\n    \n    if (dn != 0.0) {\n        s = dot(p - o, n) / dn;\n        s += float(s < 0.0) * 1e8;\n    }\n    return o + s * d;;\n}\n\nvec3 rayTriangle(vec3 o, vec3 ray) {\n    const float R = 2.0;\n    vec3 cand = o;\n\tfloat cdist = 1e10;\n    float phase = 0.2 * iTime;\n    \n    for (int i = 0; i < Npoly; i++) {\n        vec3 p = R * vec3(cos(TWOPI * float(i) / float(Npoly) + phase),\n                          sin(TWOPI * float(i) / float(Npoly) + phase),\n                          0.0);\n        vec3 n = normalize(-p);\n        vec3 rh = rayPlane(p, o, n, ray);\n        float dist = length(rh - o);\n        \n        if (dist < cdist) {\n            cand = rh;\n            cdist = dist;\n        }\n    }\n    return cand;\n}\n\nvec4 colorize(vec3 pos) {\n    float c = float(mod(pos.z, 0.03) < 0.015);\n    return vec4(vec3(c), 1.0);\n}\n\nvec4 trace(vec2 p) {\n    vec3 ray = normalize(vec3(p, 5.0/200.0));\n    vec3 campos = vec3(0.0, 0.0, 0.05*iTime);\n   \tvec3 hitpos = rayTriangle(campos, ray);\n    vec4 col = colorize(hitpos);\n    \n    // fog me beautiful\n    float fogfactor = exp(3.5 - 2.0 * length(hitpos - campos));\n    vec4 oc =  col * min(1.0, fogfactor);\n    return oc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 buv = fragCoord.xy / iResolution.xy - vec2(0.5);\n\tvec2 uv = buv;\n    uv.x *= iResolution.x / iResolution.y;\n    fragColor = trace(uv);\n    for (int i = 0; i < 4; i++) {\n        uv = buv + 0.25*vec2(cos(fragCoord.x+fragCoord.y + float(i)*TWOPI/4.0),\n                             sin(fragCoord.x+fragCoord.y + float(i)*TWOPI/4.0)) / iResolution.xy;\n\t    uv.x *= iResolution.x / iResolution.y;\n        fragColor += trace(uv);\n    }\n    fragColor /= 5.0;\n    fragColor += 0.1*rand(fragCoord.xy + 0.1*iTime);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}