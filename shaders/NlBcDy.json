{
    "Shader": {
        "info": {
            "date": "1650198568",
            "description": "sample code",
            "flags": 0,
            "hasliked": 0,
            "id": "NlBcDy",
            "likes": 4,
            "name": "8_4_normalMapping",
            "published": 3,
            "tags": [
                "ch8"
            ],
            "usePreview": 0,
            "username": "tomoe",
            "viewed": 234
        },
        "renderpass": [
            {
                "code": "const float PI = 3.14159265359;\nconst float TAU = 6.2831853;\n//begin rot\nvec2 rot2(vec2 p, float t){\n    return vec2(cos(t) * p.x -sin(t) * p.y, sin(t) * p.x + cos(t) * p.y);\n}\nvec3 rotX(vec3 p, float t){\n    return vec3(p.x, rot2(p.yz, t));\n}\nvec3 rotY(vec3 p, float t){\n    return vec3(p.y, rot2(p.zx, t)).zxy;\n}\nvec3 rotZ(vec3 p, float t){\n    return vec3(rot2(p.xy, t), p.z);\n}\n//end rot\n//start hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\n\n//start vnoise\nfloat vnoise21(vec2 p){\n    vec2 n = floor(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = hash21(n + vec2(i, j));\n        }\n    }\n    vec2 f = fract(p);\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]);\n}\n//end vnoise\n//start processing noise\nfloat base21(vec2 p){\n    return vnoise21(p) - 0.5;\n}\nfloat fbm21(vec2 p, float g){\n    float val = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for (int i = 0; i < 4; i++){\n        val += amp * base21(freq * p);\n        amp *= g;\n        freq *= 2.01;\n    }\n    return 0.5 * val + 0.5;\n}\nfloat warp21(vec2 p, float g){\n    float val = 0.0;\n    for (int i = 0; i < 3; i++){\n        val = fbm21(p + g * vec2(cos(TAU * val), sin(TAU * val)), 0.5);\n    }\n    return val;\n}\n//end processing noise\nvec2 grad2(vec2 uv){\n    uv += 0.3 * iTime;\n    float d = 0.001;\n    return 0.5 * (vec2(\n        warp21(uv + vec2(d, 0.0), 1.0)\n             - warp21(uv - vec2(d, 0.0), 1.0),\n            warp21(uv + vec2(0.0, d), 1.0) - warp21(uv - vec2(0.0, d), 1.0)\n        )) / d;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 cPos = vec3(0.0, 0.0, 0.0);\n    float t = -0.25 * PI;\n    vec3 cDir = rotX(vec3(0.0, 0.0, - 1.0), t);\n    vec3 cUp = rotX(vec3(0.0, 1.0, 0.0), t);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth - cPos;\n    ray = normalize(ray);\n    vec3 groundNormal = vec3(0.0, 1.0, 0.0);\n    float groundHeight = 1.5;\n    vec3 lPos = vec3(0.,0.,0.);\n    if (dot(ray, groundNormal) < 0.0){\n        vec3 hit = cPos - ray * groundHeight / dot(ray, groundNormal);\n        groundNormal.zx += grad2(hit.zx);\n        groundNormal = normalize(groundNormal);\n        float diff = max(dot(normalize(lPos - hit), groundNormal), 0.0);\n        diff *= 1.5;\n        diff /= pow(length(lPos - hit), 1.5) ;\n        fragColor = vec4(diff);\n    } else {\n        fragColor = vec4(0.0);\n    }  \n    fragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}