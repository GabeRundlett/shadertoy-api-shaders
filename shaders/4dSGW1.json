{
    "Shader": {
        "info": {
            "date": "1386732267",
            "description": "Using a 2D regular grid as acceleration structure for raytracing (an infinite amount of) cylinders. I trace across the 2D grid and then intersect the cylinder inside each cell. When the first intersection is found, the tracing can stop.",
            "flags": 1,
            "hasliked": 0,
            "id": "4dSGW1",
            "likes": 311,
            "name": "Grid of Cylinders",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raytracing",
                "grid",
                "cylinder",
                "regulargrid",
                "vr"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 53829
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n// Try 4, 15, 30 samples if yo have a powerful machine\n\n#if HW_PERFORMANCE==0\n#define VIS_SAMPLES 1\n#else\n#define VIS_SAMPLES 4\n#endif\n\nfloat hash1( float n ) { return fract(43758.5453123*sin(n)); }\nfloat hash1( vec2  n ) { return fract(43758.5453123*sin(dot(n,vec2(1.0,113.0)))); }\nvec2  hash2( float n ) { return fract(43758.5453123*sin(vec2(n,n+1.0))); }\n\nfloat gAnimTime;\n\nfloat map( vec2 p ) \n{\n\tfloat f = textureLod( iChannel0, p/iChannelResolution[0].xy, 0.0 ).x;\n\tf *= sqrt( textureLod( iChannel2, (0.03*p + 2.0*gAnimTime)/256.0, 0.0 ).x );\n\treturn 22.0*f;\n}\n\nvec3 calcNormal( in vec3 pos, in float ic )\n{\n\treturn mix( normalize(vec3(pos.x,0.0,pos.z)), vec3(0.0,1.0,0.0), ic );\n}\n\nvec4 raycast( in vec3 ro, in vec3 rd )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\t\n\tvec4 res = vec4( -1.0, 0.0, 0.0, 0.0 );\n\n    // traverse regular grid (in 2D)\n\tvec2 mm = vec2(0.0);\n\tfor( int i=0; i<200; i++ ) \n\t{\n\n\t\tfloat ma = map(pos);\n\t\t\n        // intersect capped cylinder\t\t\n\t\tvec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );\n\t\tvec3  rc = ro - ce;\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) - 0.249;\n\t\tfloat h = b*b - a*c;\n\t\tif( h>=0.0 )\n\t\t{\n            // cylinder\t\t\t\n\t\t\tfloat s = (-b - sqrt( h ))/a;\n\t\t\tif( s>0.0 && (ro.y+s*rd.y)<ma )\n\t\t\t{\n\t\t\t\tres = vec4( s, 0.0, pos );\n    \t\t\tbreak; \n\t\t\t}\n            // cap\t\t\t\n\t\t\ts = (ma - ro.y)/rd.y;\n\t\t\tif( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )\n\t\t\t{\n\t\t\t\tres = vec4( s, 1.0, pos );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n        // step to next cell\t\t\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm*ris;\n        pos += mm*rs;\n\t}\n\n\n\treturn res;\n}\n\nfloat castShadowRay( in vec3 ro, in vec3 rd )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\tfloat t = -1.0;\n\tfloat res = 1.0;\n\t\n    // first step we check noching\t\n\tvec2 mm = step( dis.xy, dis.yx ); \n\tdis += mm * ris;\n    pos += mm * rs;\n\t\n    // traverse regular grid (2D)\t\n\tfor( int i=0; i<16; i++ ) \n\t{\n\t\tfloat ma = map(pos);\n\t\t\n        // test capped cylinder\t\t\n\t\tvec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );\n\t\tvec3  rc = ro - ce;\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) - 0.249;\n\t\tfloat h = b*b - a*c;\n\t\tif( h>=0.0 )\n\t\t{\n\t\t\tfloat t = (-b - sqrt( h ))/a;\n\t\t\tif( (ro.y+t*rd.y)<ma )\n\t\t\t{\n\t\t\t\tres = 0.0;\n    \t\t\tbreak; \n\t\t\t}\n\t\t}\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm * ris;\n        pos += mm * rs;\n\t}\n\n\treturn res;\n}\n\nvec3 cameraPath( float t )\n{\n    // procedural path\t\n    vec2 p  = 200.0*sin( 0.01*t*vec2(1.2,1.0) + vec2(0.1,0.9) );\n\t     p += 100.0*sin( 0.02*t*vec2(1.1,1.3) + vec2(1.0,4.5) );\n\tfloat y = 15.0 + 4.0*sin(0.05*t);\n\t\n\t// collision\n\tfloat h;\n\th  = map( p+vec2(-1.0, 0.0) );\n\th += map( p+vec2( 1.0, 0.0) );\n\th += map( p+vec2( 0.0, 1.0) );\n\th += map( p+vec2( 0.0,-1.0) );\n\th /= 4.0;\n\th += 5.0;\n\ty = max( y, h );\n\n\treturn vec3( p.x, y, p.y );\n}\n\nvec4 texcyl( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, vec2(p.y,0.5+0.5*atan(n.x,n.z)/3.14) );\n\tvec4 y = texture( sam, p.xz );\n\treturn mix( x, y, abs(n.y) );\n}\n\nconst vec3 lig = normalize(vec3(-0.7,0.25,0.6));\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    // background color\t\n    float sun = clamp( dot( rd, lig ), 0.0, 1.0 );\n\n    vec3 bgcol = vec3(0.9,1.0,1.0) + 0.3*pow(sun,4.0);\n\n    // raytrace\n    vec3 col = bgcol;\n    vec4 res = raycast( ro, rd );\n    vec2 vos = res.zw;\n    float t = res.x;\n    if( t>0.0 )\n    {\n        vec3  pos = ro + rd*t;\n        float id  = hash1( vos );\n        vec3  nor = calcNormal( fract(pos)-0.5, res.y );\n        float h = map(vos);\n\n        // material color\t\t\t\n        vec3 mate = 0.55 + 0.45*sin( 2.0*id + 1.8 + vec3(0.0,0.5,1.0) );\n\n        vec3 uvw = pos - vec3(0.0,h,0.0);\n        vec3 tex = texcyl( iChannel3, 0.2*uvw + 13.1*hash1(id), nor ).xyz;\n        mate *= 0.2+4.0*tex*tex;\n        mate *= 0.02 + 0.98*smoothstep( 0.1,0.11, hash1(id) );\t\n\n        // material cheap/wrong bump\t\t\t \n        //vec3 bn = -1.0 + 2.0*texcyl( iChannel1, 0.2*uvw*vec3(1.0,0.2,1.0) + 13.1*hash1(id), nor ).xyz;\n        //nor = normalize(nor + 0.3*bn*(1.0-0.5*nor.y) );\n\n        // procedural occlusion\n        float occ = nor.y*0.75;\n        occ += 0.5*clamp( nor.x,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 1.0, 0.0)) );\n        occ += 0.5*clamp(-nor.x,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2(-1.0, 0.0)) );\n        occ += 0.5*clamp( nor.z,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 0.0, 1.0)) );\n        occ += 0.5*clamp(-nor.z,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 0.0,-1.0)) );\n        occ = 0.2 + 0.8*occ;\n        occ *= pow( clamp((0.1+pos.y)/(0.1+map(floor(pos.xz))),0.0,1.0),2.0);\n        occ = occ*0.5+0.5*occ*occ;\n        float rim = pow( clamp( 1.0+dot(rd,nor), 0.0, 1.0 ),5.0 );\n\n        //-------------\n        // lighitng\n        //-------------\n        float amb = 1.0;\n        //-------------\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z)) ), 0.0, 1.0 ) * clamp(1.0-pos.y/20.0,0.0,1.0);;\n        //-------------\n        float dif = dot( nor, lig );\n        if( dif>0.0 ) dif *= castShadowRay( pos, lig );\n        dif = max( dif, 0.0 );\n        float spe = pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0 ),3.0 );\n        //-------------\n        vec3 lin  = 3.00*vec3(1.0,1.0,1.0)*dif;\n             lin += 0.80*vec3(0.4,1.0,1.7)*amb*occ;\n             lin += 0.30*vec3(0.8,0.5,0.3)*bac*occ;\n\n        col = mate*lin + tex.x*1.5*(0.3+0.7*rim)*spe*dif;\n\n        // fog\n        float ff = 1.0 - smoothstep( 0.0, 1.0, pow(t/160.0,1.8) );\n        col = mix( col, bgcol, 1.0-ff );\n        \n    }\n    col += 0.2*pow(sun,8.0)*vec3(1.0,0.7,0.2);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // inputs\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.z<=0.00001 ) mo=vec2(0.0);\n\t\n    gAnimTime = iTime;\n    \n\t// montecarlo\t\n\tvec3 tot = vec3(0.0);\n    #if VIS_SAMPLES<2\n\tint a = 0;\n\t{\n        vec2 p = -1.0 + 2.0*(fragCoord.xy) / iResolution.xy;\n        p.x *= iResolution.x/ iResolution.y;\n        float time = 4.0*iTime + 50.0*mo.x;\n    #else\n\tfor( int a=0; a<VIS_SAMPLES; a++ )\n\t{\n\t\tvec4 rr = texture( iChannel1, (fragCoord.xy+floor(256.0*hash2(float(a))))/iChannelResolution[1].xy );\n        vec2 p = -1.0 + 2.0*(fragCoord.xy+rr.xz) / iResolution.xy;\n        p.x *= iResolution.x/ iResolution.y;\n\t\t#if VIS_SAMPLES>3\n        float time = 4.0*(iTime + 1.0*(0.4/24.0)*rr.w) + 50.0*mo.x;\n\t\t#else\n        float time = 4.0*(iTime) + 50.0*mo.x;\n\t\t#endif\n    #endif\t\n\n\t\t// camera\n        vec3  ro = cameraPath( time );\n        vec3  ta = cameraPath( time+5.0 ); ta.y = ro.y - 5.5;\n        float cr = 0.2*cos(0.1*time*0.5);\n\t\n        // build ray\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\n        vec3 vv = normalize(cross(ww,uu));\n        float r2 = p.x*p.x*0.32 + p.y*p.y;\n        p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n        // dof\n        #if VIS_SAMPLES>2\n        vec3 fp = ro + rd * 17.0;\n        ro += (uu*(-1.0+2.0*rr.y) + vv*(-1.0+2.0*rr.w))*0.035;\n        rd = normalize( fp - ro );\n        #endif\n\n        // render\n        vec3 col = render( ro, rd );\n        \n\t\ttot += col;\n\t}\n\ttot /= float(VIS_SAMPLES);\n\n    // tone mapping\t\t\t\n    tot = tot*1.2/(1.0+tot);\n\n\t// gamma\t\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n\n    tot = tot*tot*(3.0-2.0*tot);\n    \n\t// vignetting\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\ttot *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( tot, 1.0 );\n}    \n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 cam = cameraPath( iTime );\n\n    gAnimTime = iTime*0.2;\n\n    vec3 ro = fragRayOri + cam + vec3(0.0,-2.0,0.0);\n    vec3 rd = fragRayDir*vec3(-1.0,1.0,-1.0);\n    vec3 col = render( ro, rd );\n\n    // gamma\t\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.44) );\n\n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}