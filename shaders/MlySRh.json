{
    "Shader": {
        "info": {
            "date": "1482752049",
            "description": "Graphing tool to compare up to 8 functions at the same time with free mouse pan and zoom. Keys: Press M to disable demo mode. Press 1-8 to toggle each function. Press space and drag to zoom. Or press W / S to zoom and AÂ / D to pan left/right.",
            "flags": 48,
            "hasliked": 0,
            "id": "MlySRh",
            "likes": 12,
            "name": "8x Multi-Graphing",
            "published": 3,
            "tags": [
                "2d",
                "zoom",
                "plot",
                "state",
                "graphing",
                "subpixel",
                "pan"
            ],
            "usePreview": 0,
            "username": "TimoKinnunen",
            "viewed": 810
        },
        "renderpass": [
            {
                "code": "/*\n\n 8x Multi-Graphing\n by Timo Kinnunen \n\n License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n A not so small graphing tool that does multisampling and more.\n\n - noise based sampling\n - antialiasing\n - subpixel rendering\n - extreme zoom range\n - 8 functions at same time\n - derivative approximation\n - state buffer based panning\n\n Like the original, works perfectly with functions that have \n discontinuities or are even just noise.\n\n Usage:\n\n 1. define your function(s) in float f1...f8(float x) \n the default is to graph all functions at the same time.\n the example functions have some highly complicated functions,\n some which use all floating-point range and precision. \n the base 10 logarithm used for the grid and the noise function\n used for sampling are amongst them as well.\n\n 2. optionally set the quality 1-100,\n the more quality the more samples are taken\n more samples = less noisy result but slower\n\n 3. optionally change subpixel rendering,\n not subpixel rendering requires increasing quality about 3x\n for similar result.\n\n 4. keys and other controls available:\n use the M key to turn off demo mode.\n drag the screen to pan around.\n use keys 1-8 to toggle individual functions on and off.\n use space bar to activate zooming while dragging up/down.\n or, pan left/right with A / D keys and zoom with W / S.\n\n ----\n\n Graphing (This buffer) based on Precise Graphing by musk\n @ https://www.shadertoy.com/view/4dS3WG\n\n Pan/Zoom (Buffer A) based on Pan zoom control by Andre \n @ https://www.shadertoy.com/view/XdG3Dh\n\n */\nconst int quality = 10;\nconst int SubpixelOff = 0;\nconst int SubpixelOn_normal_pixel_order = 1;\nconst int SubpixelOn_reverse_pixel_order = 2;\nconst int subpixel_render = SubpixelOn_normal_pixel_order;\n\nfloat f1(float x) { // undefined at x = 0\n\treturn sin(1.0/ x);\n}\nfloat f2(float x) { //unstable\n\tx = pow(4.0,x);\n\treturn sin(x* 10.0);\n}\nfloat f3(float x) { // undefined at x = 0\n\treturn 1.0/ x;\n}\nfloat f4(float x) { // interference\n\tx = x* 200.0;\n\treturn sin(x)+ sin(x* .99);\n}\nfloat f5(float x) { // sawtooth wave and extra\n\treturn mod(x,1.0)* sin(x* sin(x* sin(x* sin(x* 2.0+ x)+ x)+ x)+ x);\n}\nfloat f6(float x) { //animated\n\treturn sin(x* 4.0+ iTime)+ sin(x* 3.0+ iTime);\n}\nfloat f7(float x) { // logarithmic base 10 and extra\n\tfloat a = abs(cos(x/ (0.00001+ x* x)));\n\tx = log(x)/ log(10.0);\n\tif(a< 0.33) return x;\n\tx = floor(x);\n\tif(a< 0.66) return x;\n\tx = pow(10.0,x);\n\treturn x;\n}\nfloat n4rand_ss(vec2 n);\nfloat f8(float x) { // randomness\n\tx = n4rand_ss(vec2(x,x+ iTime));\n\treturn x;\n}\n\nconst vec3 graphColor0 = vec3(0.9394,0.9929,0.8644);\nconst vec3 graphColor1 = vec3(0.9969,0.7467,0.0625);\nconst vec3 graphColor2 = vec3(0.0625,0.7812,0.9061);\nconst vec3 graphColor3 = vec3(0.3317,0.7229,0.2616);\nconst vec3 graphColor4 = vec3(0.7658,0.3127,0.9964);\nconst vec3 graphColor5 = vec3(0.7669,0.0868,0.3056);\nconst vec3 graphColor6 = vec3(0.1641,0.2818,0.9964);\nconst vec3 graphColor7 = vec3(0.1772,0.4721,0.2038);\n\n#define texture texture\n\n//======Start shared code for state\n#define pz_stateYOffset 0.0\n#define pz_stateBuf 0\n#define pz_stateSample(x) texture(iChannel0,x)\nvec2 pz_realBufferResolution;\nvec2 pz_originalBufferResolution;\n\nvoid pz_initializeState() {\n\tpz_realBufferResolution = iResolution.xy;\n\tpz_originalBufferResolution = pz_stateSample(.5/pz_realBufferResolution).xy;\n}\n\nvec2 pz_nr2vec(float nr) {\n\treturn vec2(mod(nr,pz_originalBufferResolution.x),pz_stateYOffset+ floor(nr/ pz_originalBufferResolution.x))+ .5;\n}\n\nvec4 pz_readState(float nr) {\n\treturn pz_stateSample(pz_nr2vec(nr)/ pz_realBufferResolution);\n}\n\nfloat pz_resetCount() {\n\treturn pz_readState(1.).z;\n}\n\nvec4 pz_position() {\n\treturn pz_readState(3.);\n}\n\nvec2 pz_initializeState(vec2 fragCoord) {\n\tpz_initializeState();\n\n\tvec4 position = pz_position();\n\tfragCoord -= 0.5* iResolution.xy;\n\tfragCoord *= position.z;\n\tfragCoord += (0.5+ position.xy)* iResolution.xy;\n\treturn fragCoord;\n}\n//======End shared code for state\n//==Utility functions\nfloat max2(vec2  a) { return max(a.x,a.y); }\nfloat min2(vec2  a) { return min(a.x,a.y); }\nfloat max4(float a, float b, float c, float d) { return max(max(a,b),max(c,d)); }\nfloat max4(vec4  a) { return max4(a.x,a.y,a.z,a.w); }\nfloat saturate(float a) { return clamp(a,0.0,1.0); }\nvec2  saturate(vec2  a) { return clamp(a,0.0,1.0); }\nvec4  saturate(vec4  a) { return clamp(a,0.0,1.0); }\nvec2  square(vec2  x) { return x* x; }\nvec4  square(vec4  x) { return x* x; }\nvec2  flip(vec2  x) { return 1.0- x; }\nvec4  flip(vec4  x) { return 1.0- x; }\n// by Dave Hoskins\nfloat linearstep(float e0, float e1, float x) { return saturate((x- e0)/ (e1- e0)); }\nvec2  linearstep(vec2  e0, vec2  e1, vec2  x) { return saturate((x- e0)/ (e1- e0)); }\nvec4  linearstep(vec4  e0, vec4  e1, vec4  x) { return saturate((x- e0)/ (e1- e0)); }\nvec4  bump(vec4  x) { return flip(abs(x- 0.5)* 2.0); }\n// by:stubbe @ shadertoy.com\nvec2  cheap(vec2  x) { return flip(square(x)); }\nvec4  cheap(vec4  x) { return flip(square(x)); }\nvec2  cheapstep(vec2  x) { return cheap(cheap(x)); }\nvec4  cheapstep(vec4  x) { return cheap(cheap(x)); }\nvec2  cheapstep(vec2  e0, vec2  e1, vec2  x) { return cheapstep(linearstep(e0,e1,x)); }\nvec4  cheapstep(vec4  e0, vec4  e1, vec4  x) { return cheapstep(linearstep(e0,e1,x)); }\n// by:huwb @ shadertoy.com\nvec4  cheappulse(vec4  x) {return square(cheap(clamp(x,-1.0,1.0)));}\n//======End of utility functions\nfloat f(int i, float x) {\n\treturn i< 4? i< 2? i< 1? f1(x): f2(x) : i< 3? f3(x): f4(x) : i< 6? i< 5? f5(x): f6(x) : i< 7? f7(x): f8(x);\n}\nvec4 functions1to4(float x) {\n\treturn vec4(f1(x),f2(x),f3(x),f4(x));\n}\nvec4 functions5to8(float x) {\n\treturn vec4(f5(x),f6(x),f7(x),f8(x));\n}\n//note: uniformly distributed, normalized rand, [-0.5;0.5[\nfloat nrand(vec2 n) {\n\treturn fract(sin(dot(n.xy,vec2(12.9898,78.233)))* 43758.5453)- 0.5;\n}\nconst float NONZERO = 1.4E-45;\nconst float LARGE = 94804082544878020000000000000000000.0;\nconst float KEY_M = 77.5/ 256.0;\nconst float KEY_0 = 48.5/ 256.0;\nconst float KEY_1 = 49.5/ 256.0;\nconst float KEY_2 = 50.5/ 256.0;\nconst float KEY_3 = 51.5/ 256.0;\nconst float KEY_4 = 52.5/ 256.0;\nconst float KEY_5 = 53.5/ 256.0;\nconst float KEY_6 = 54.5/ 256.0;\nconst float KEY_7 = 55.5/ 256.0;\nconst float KEY_8 = 56.5/ 256.0;\nconst float KEY_9 = 57.5/ 256.0;\n//alternative Gaussian, thanks to @self_shadow. see http://www.dspguide.com/ch2/6.htm\nfloat seed;\nfloat n4rand_ss(vec2 n) {\n\tfloat nrnd0 = nrand(n+ 0.07* fract(seed));\n\tfloat nrnd1 = nrand(n+ 0.11* fract(seed+ 0.573953));\n//return 0.23*sqrt(-log(nrnd0+0.00001))*cos(2.0*3.141592*nrnd1)+0.5;\n\treturn 0.23* sqrt(-log(nrnd0+ 0.50001))* cos(radians(360.0)* nrnd1);\n}\nfloat computeGrid(vec2 pixel, vec2 uv, vec2 base10, float off) {\n\tvec2 ibase10 = floor(base10/ 3.0)* 3.0;\n\tvec2 fbase10 = mod(base10,3.);\n\tvec2 linear = cheapstep(vec2(.2),vec2(2),fbase10);\n\tvec2 base = pow(vec2(10),ibase10+ off);\n\tvec4 bumpxy = bump(((fract(uv.xxyy* base.xyxy+ .5)- .5)/ base.xyxy/ pixel.xxyy+ 1.)* .5)* linear.xyxy;\n\tfloat amount = max4(bumpxy);\n\treturn amount;\n}\nvec2 computeGrids(vec2 pixel, vec2 zoom, vec2 uv) {\n\tvec2 base10 = log(zoom)/ log(10.);\n\tfloat amountB = computeGrid(pixel, uv, base10+ 2.0, 1.0);\n\tfloat amountR = computeGrid(pixel, uv, base10+ 1.0, 2.0);\n\tfloat amountG = computeGrid(pixel, uv, base10+ 0.0, 3.0);\n\tfloat maxAmount = max4(0.0,amountB,amountR,amountG);\n\tfloat origin = min(1.0,max2(0.0078125/ (0.0078125+ abs(uv)* zoom)));\n\tfloat subGrids = 3.* maxAmount* origin;\n\tfloat mainGrids = subGrids* origin;\n\tvec2 grids = vec2(subGrids,mainGrids);\n\treturn grids;\n}\nfloat key(float code) {\n\treturn texture(iChannel1,vec2(code,1)).x;\n}\nvec4 keys1to4() {\n\treturn vec4(key(KEY_1),key(KEY_2),key(KEY_3),key(KEY_4));\n}\nvec4 keys5to8() {\n\treturn vec4(key(KEY_5),key(KEY_6),key(KEY_7),key(KEY_8));\n}\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tpz_initializeState();\n\tvec4 pz_pos = pz_position();\n\tfloat zoom = clamp(1.0/ pz_pos.z,NONZERO,LARGE);\n\tvec2 center = clamp(pz_pos.xy* 2.0,-LARGE,LARGE);\n\tbool manual = key(KEY_M)>0.1;\n\tif(manual==false) {\n\t\tzoom = pow(10.0,-3.0+ mod(iTime,20.0)/ 20.0* 18.0);\n\t}\n\tseed = gl_FragCoord.y/ iResolution.x/ iResolution.y+ gl_FragCoord.x/ iResolution.x;\n\n\tvec2 uv = fragCoord.xy;\n\tuv /= iResolution.xy;\n\tuv -= .5;\n\tuv /= zoom;\n\tif(manual) {\n\t\tuv += center* .5* max(iResolution.y,iResolution.x)/ iResolution.xy;\n\t}\n\tuv.x = uv.x* iResolution.x/ iResolution.y;\n\n\tfloat aQuality = float(quality);\n\tfloat lowQuality = linearstep(1.,10.,aQuality);\n\tfloat highQuality = linearstep(10.,100.,aQuality);\n\tfloat aBlurMax = mix(2.,8.,lowQuality);\n\tfloat aBlurFactor = mix(mix(2.,1.,lowQuality),.125,highQuality);\n\tfloat aKernelBase = mix(.5,.25,lowQuality);\n\tfloat aKernelBias = mix(.1875,0.,lowQuality);\n\tvec2 pixel = 1.0/ iResolution.yy/ zoom;\n\tvec2 blur = min(aBlurMax,aQuality* aBlurFactor)* pixel;\n\tvec2 base = aKernelBase* blur;\n\tvec2 bias = aKernelBias* blur;\n\n\tbool subpixelSampling = subpixel_render!= 0;\n\tbool reverseSubpixelOrder = subpixel_render== 2;\n\tfloat bg = 0.0;\n\tvec3 c = vec3(0);\n\tfloat sampleCount = 1.0;\n\tfloat noise = 0.0;\n\tvec4 activated1 = 1.0- keys1to4();\n\tvec4 activated2 = 1.0- keys5to8();\n\tfloat functions = 1.0+ activated1.x+ activated1.y+ activated1.z+ activated1.w+ activated2.x+ activated2.y+ activated2.z+ activated2.w;\n\tfor(int i = 0; i< 3; i++) {\n\t\tif(subpixelSampling== false&& i!= 1) continue;\n\t\tvec3 mask = i== 0? vec3(2.4375,.375,.1875): i== 2? vec3(.1875,.375,2.4375): subpixelSampling? vec3(.375,2.25,.375): vec3(1);\n\t\tfloat subpixel = pixel.x/ 3.* (reverseSubpixelOrder? float(1- i): float(i- 1));\n        for(int j = 0; j < 100; j++) {\n            float fi = float(j)/aQuality;\n            if(j>= quality) break;\n\t\t\tnoise = n4rand_ss(uv+ vec2(seed+ subpixel,fi));\n\t\t\tfloat x = uv.x+ noise* blur.x/ 3.+ subpixel;\n\t\t\tvec4 sL1 = functions1to4(x- pixel.x);\n\t\t\tvec4 sL2 = functions5to8(x- pixel.x);\n\t\t\tvec4 sC1 = functions1to4(x);\n\t\t\tvec4 sC2 = functions5to8(x);\n\t\t\tvec4 sR1 = functions1to4(x+ pixel.x);\n\t\t\tvec4 sR2 = functions5to8(x+ pixel.x);\n\t\t\tvec4 sMin1 = min(min(sL1,sC1),sR1);\n\t\t\tvec4 sMin2 = min(min(sL2,sC2),sR2);\n\t\t\tvec4 sMax1 = max(max(sL1,sC1),sR1);\n\t\t\tvec4 sMax2 = max(max(sL2,sC2),sR2);\n\t\t\tvec4 levelness1 = cheappulse((sMax1- sMin1)* .5/ pixel.y);\n\t\t\tvec4 levelness2 = cheappulse((sMax2- sMin2)* .5/ pixel.y);\n\t\t\tvec4 pix1 = base.y+ bias.y* levelness1;\n\t\t\tvec4 pix2 = base.y+ bias.y* levelness2;\n\t\t\tvec4 inside1 = cheapstep(uv.y+ pix1,uv.yyyy,sMin1)* cheapstep(uv.y- pix1,uv.yyyy,sMax1);\n\t\t\tvec4 inside2 = cheapstep(uv.y+ pix2,uv.yyyy,sMin2)* cheapstep(uv.y- pix2,uv.yyyy,sMax2);\n\t\t\tvec4 valid1 = vec4(equal(inside1,inside1))* activated1;\n\t\t\tvec4 valid2 = vec4(equal(inside2,inside2))* activated2;\n\t\t\tvec4 graph1 = (1.0- saturate(1.0/ (1.0+ inside1)))* valid1;\n\t\t\tvec4 graph2 = (1.0- saturate(1.0/ (1.0+ inside2)))* valid2;\n\t\t\tvec3 graphs1 = graph1.x* graphColor0+ graph1.y* graphColor1+ graph1.z* graphColor2+ graph1.w* graphColor3;\n\t\t\tvec3 graphs2 = graph2.x* graphColor4+ graph2.y* graphColor5+ graph2.z* graphColor6+ graph2.w* graphColor7;\n\t\t\tc += (graphs1+ graphs2)* mask;\n\t\t\tbg += dot(valid1,levelness1)+ dot(valid2,levelness2);\n\t\t\tsampleCount += valid1.x+ valid1.y+ valid1.z+ valid1.w+ valid2.x+ valid2.y+ valid2.z+ valid2.w;\n\t\t}\n\t}\n\tc *= functions/ sampleCount;\n\tbg *= 1.0/sampleCount;\n\tvec2 grids = computeGrids(pixel, vec2(zoom), uv);\n\t// Remove banding in background color by adding 1/128th of noise.\n\tvec3 colorBg = vec3(0,bg* 0.0625+ abs(noise)/128.0,bg* 0.0625);\n\t// Add fading parts of axis lines.\n\tvec3 colorSG = grids.x* vec3(0,0.5,0.5);\n\t// Add bright parts of main axis lines.\n\tvec3 colorMG = vec3(linearstep(0.,2.,grids.y));\n\tvec3 color = max(vec3(0),c)+ saturate(1.0- dot(c,c))* (colorMG+ colorSG)+ max(vec3(0),colorBg);\n\tfragColor = vec4(color,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define texture texture\n\n//======Start shared code for state\n#define pz_stateYOffset 0.0\n#define pz_stateBuf 0\n#define pz_stateSample(x) texture(iChannel0,x)\nvec2 pz_realBufferResolution;\nvec2 pz_originalBufferResolution;\n\nvoid pz_initializeState() {\n\tpz_realBufferResolution = iResolution.xy;\n\tpz_originalBufferResolution = pz_stateSample(.5/pz_realBufferResolution).xy;\n}\n\nvec2 pz_nr2vec(float nr) {\n\treturn vec2(mod(nr,pz_originalBufferResolution.x),pz_stateYOffset+ floor(nr/ pz_originalBufferResolution.x))+ .5;\n}\n\nvec4 pz_readState(float nr) {\n\treturn pz_stateSample(pz_nr2vec(nr)/ pz_realBufferResolution);\n}\n\nfloat pz_resetCount() {\n\treturn pz_readState(1.).z;\n}\n\nvec4 pz_position() {\n\treturn pz_readState(3.);\n}\n\nvec2 pz_initializeState(vec2 fragCoord) {\n\tpz_initializeState();\n\n\tvec4 position = pz_position();\n\tfragCoord -= 0.5* iResolution.xy;\n\tfragCoord *= position.z;\n\tfragCoord += (0.5+ position.xy)* iResolution.xy;\n\treturn fragCoord;\n}\n//======End shared code for state\n\n//======Defines for state behavior\n#define pz_resetOnMove 1\n#define pz_kinetic 0.95\n\nbool pz_checkCell(float nr, vec2 coord) {\n\treturn distance(pz_nr2vec(nr),coord)<= 0.5;\n}\n\n// Keyboard constants definition\nconst float KEY_BSP = 8.5/ 256.0;\nconst float KEY_SP = 32.5/ 256.0;\nconst float KEY_LEFT = 37.5/ 256.0;\nconst float KEY_UP = 38.5/ 256.0;\nconst float KEY_RIGHT = 39.5/ 256.0;\nconst float KEY_DOWN = 40.5/ 256.0;\nconst float KEY_A = 65.5/ 256.0;\nconst float KEY_B = 66.5/ 256.0;\nconst float KEY_C = 67.5/ 256.0;\nconst float KEY_D = 68.5/ 256.0;\nconst float KEY_E = 69.5/ 256.0;\nconst float KEY_F = 70.5/ 256.0;\nconst float KEY_G = 71.5/ 256.0;\nconst float KEY_H = 72.5/ 256.0;\nconst float KEY_I = 73.5/ 256.0;\nconst float KEY_J = 74.5/ 256.0;\nconst float KEY_K = 75.5/ 256.0;\nconst float KEY_L = 76.5/ 256.0;\nconst float KEY_M = 77.5/ 256.0;\nconst float KEY_N = 78.5/ 256.0;\nconst float KEY_O = 79.5/ 256.0;\nconst float KEY_P = 80.5/ 256.0;\nconst float KEY_Q = 81.5/ 256.0;\nconst float KEY_R = 82.5/ 256.0;\nconst float KEY_S = 83.5/ 256.0;\nconst float KEY_T = 84.5/ 256.0;\nconst float KEY_U = 85.5/ 256.0;\nconst float KEY_V = 86.5/ 256.0;\nconst float KEY_W = 87.5/ 256.0;\nconst float KEY_X = 88.5/ 256.0;\nconst float KEY_Y = 89.5/ 256.0;\nconst float KEY_Z = 90.5/ 256.0;\nconst float KEY_COMMA = 188.5/ 256.0;\nconst float KEY_PER = 190.5/ 256.0;\nconst float KEY_ADD = 107.5/ 256.0;\nconst float KEY_SUBS = 109.5/ 256.0;\nconst float KEY_EQUAL = 187.5/ 256.0;\nconst float KEY_MINUS = 189.5/ 256.0;\nconst float KEY_PLUS = 43.5/ 256.0;\nconst float KEY_DASH = 45.5/ 256.0;\nconst float KEY_ISNOW = 61.5/ 256.0;\nconst float KEY_0 = 48.5/ 256.0;\nconst float KEY_1 = 49.5/ 256.0;\nconst float KEY_2 = 50.5/ 256.0;\nconst float KEY_3 = 51.5/ 256.0;\nconst float KEY_4 = 52.5/ 256.0;\nconst float KEY_5 = 53.5/ 256.0;\nconst float KEY_6 = 54.5/ 256.0;\nconst float KEY_7 = 55.5/ 256.0;\nconst float KEY_8 = 56.5/ 256.0;\nconst float KEY_9 = 57.5/ 256.0;\n\nbool checkKey(float key) {\n\treturn texture(iChannel1,vec2(key,0.25)).x> 0.5;\n}\n\nbool checkKey(float key1, float key2) {\n\treturn checkKey(key1)|| checkKey(key2);\n}\n\nbool checkKey(float key1, float key2, float key3) {\n\treturn checkKey(key1)|| checkKey(key2)|| checkKey(key3);\n}\nbool checkKey(float key1, float key2, float key3, float key4) {\n\treturn checkKey(key1,key2)|| checkKey(key3,key4);\n}\nbool checkKey(float key1, float key2, float key3, float key4, float key5) {\n\treturn checkKey(key1,key2,key3,key4)|| checkKey(key5);\n}\n\nvoid pz_mainImage( inout vec4 fragColor, in vec2 fragCoord) {\n\tpz_initializeState();\n\tfragColor = pz_stateSample(fragCoord/ pz_realBufferResolution);\n\tif(fragCoord.x< 1.&& fragCoord.y< 1.) {\n\t\t//Lets store the initial buffer size at pos0 and use that for addressing\n\t\tif(pz_originalBufferResolution.x== 0.0) fragColor = vec4(pz_realBufferResolution,1.0,1.0);\n\n\t} else if(pz_checkCell(1.,fragCoord)) {\n\n\t\t// Use position 1 to trigger screen size changes so we can clear other buffers on going fullscreen\n\t\tif(distance(fragColor.xy,pz_realBufferResolution)> 1.0\n#if pz_resetOnMove\n\t\t|| pz_readState(3.).w> 0.0\n#endif\n\t\t) {\n\t\t\tfragColor.xy = pz_realBufferResolution;\n\t\t\tfragColor.z = 60.0;\n\t\t} else {\n\t\t\tif(fragColor.z> 0.0) fragColor.z -= 1.0;\n\t\t}\n\n\t} else if(pz_checkCell(2.,fragCoord)) {\n\t\t// Store mouse delta if key down\n\t\tvec4 mouse;\n\t\tif(checkKey(KEY_SP)) {\n\t\t\tmouse = vec4(0);\n\t\t} else {\n\t\t\tmouse = iMouse;\n\t\t}\n\n\t\tif(mouse.w> 0.5) {\n\t\t\tif(fragColor.x> 0.0) {\n\t\t\t\tfragColor.zw = fragColor.xy- mouse.xy;\n\t\t\t} else {\n\t\t\t\tfragColor.zw = vec2(0.0);\n\t\t\t}\n\t\t\tfragColor.xy = mouse.xy;\n\t\t} else {\n\n\t\t\tfragColor.xy = vec2(-1.,-1.);\n#ifdef pz_kinetic\n\t\t\tfragColor.zw = length(fragColor.zw)> 0.02? fragColor.zw* pz_kinetic: vec2(0.0,0.0);\n#else\n\t\t\tfragColor.zw = vec2(0.0,0.0);\n#endif\n\t\t}\n\n\t} else if(pz_checkCell(3.,fragCoord)) {\n\t\t// Handle keyboard moves\n\t\tvec2 delta = vec2(\n\t\tcheckKey(KEY_LEFT,KEY_A,KEY_Q)? -0.02: checkKey(KEY_RIGHT,KEY_D)? 0.02: 0.0,\n\t\tcheckKey(KEY_DOWN)? -0.02: checkKey(KEY_UP,KEY_Z)? 0.02: 0.0);\n\t\tfloat factor = 1.0;\n\t\tfactor += checkKey(KEY_SUBS,KEY_MINUS,KEY_DASH)? 0.01: checkKey(KEY_ADD,KEY_EQUAL,KEY_PLUS,KEY_ISNOW)? -0.01: 0.0;\n\t\tfactor += checkKey(KEY_S)? 0.0625: checkKey(KEY_W)? -0.0625: 0.0;\n\t\tif(fragColor.z<=0.0) {\n\t\t\tfragColor.z = 1.0;\n\t\t}\n\n\t\t//Update transform state\n\t\tvec2 mouseDelta = pz_readState(2.).zw;\n\t\tvec2 zoomDelta = pz_readState(4.).zw;\n\t\tfragColor.z *= factor+ clamp(zoomDelta.y* 0.01,-.75,.75);\n\t\tfragColor.xy += delta* fragColor.z; //Add keyboard move\n\t\tfragColor.xy += mouseDelta/ iResolution.xy* fragColor.z; //Add mouse delta\n\n\t\t//Store movement in w\n\t\tfragColor.w = abs(factor- 1.0)* 3.+ length(delta)+ length(mouseDelta);\n\n\t} else if(pz_checkCell(4.,fragCoord)) {\n\t\t// Store mouse delta if key down\n\t\tvec4 mouse = vec4(0);\n\t\tif(checkKey(KEY_SP)) {\n\t\t\tmouse = iMouse;\n\t\t}\n\t\tif(mouse.w> 0.5) {\n\t\t\tif(fragColor.x> 0.0) {\n\t\t\t\tfragColor.zw = fragColor.xy- mouse.xy;\n\t\t\t} else {\n\t\t\t\tfragColor.zw = vec2(0.0);\n\t\t\t}\n\t\t\tfragColor.xy = mouse.xy;\n\t\t} else {\n\n\t\t\tfragColor.xy = vec2(-1.,-1.);\n#ifdef pz_kinetic\n\t\t\tfragColor.zw = length(fragColor.zw)> 0.02? fragColor.zw* pz_kinetic: vec2(0.0,0.0);\n#else\n\t\t\tfragColor.zw = vec2(0.0,0.0);\n#endif\n\t\t}\n\n\t} else fragColor = vec4(0.,0.,0.,1.0);\n\tvec4 v = fragColor;\n\tbvec4 nan = bvec4(v.r!= v.r,v.g!= v.g,v.b!= v.b,v.a!= v.a);\n\tif(nan.r|| nan.g|| nan.b|| nan.a) {\n\t\tfragColor = vec4(0);\n\t}\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tpz_mainImage(fragColor,fragCoord);\n\n\t// Add multiple state handlers here\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}