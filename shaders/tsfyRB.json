{
    "Shader": {
        "info": {
            "date": "1585049250",
            "description": "Inspired by Fabrice Neyret's https://www.shadertoy.com/view/4sSBRd\nThis shader demonstrates how light reflection and refraction stem from wave interference.\n\nClick and drag to change the direction of the incoming wave.",
            "flags": 0,
            "hasliked": 0,
            "id": "tsfyRB",
            "likes": 24,
            "name": "Light interaction with interface",
            "published": 3,
            "tags": [
                "reflection",
                "refraction",
                "interference",
                "photon",
                "huygens",
                "wavepropagation"
            ],
            "usePreview": 1,
            "username": "Zavie",
            "viewed": 10856
        },
        "renderpass": [
            {
                "code": "/*\n\nThis shader illustrates how an electromagnetic wave reflects\nand refracts at an interface. It was used as an illustration\nin the talk at Revision 2020, \"Implementing a Physically\nBased Shading without locking yourself in\" :\n\nhttps://bit.ly/2IZqYET\n\nThe directions of the reflected and refracted waves are not\nhard coded, but instead a consequence of the interferences\nat the interface.\n\nThe shader is inspired by Fabrice Neyret's\nhttps://www.shadertoy.com/view/4sSBRd\n\n--\nZavie\n\n*/\n\n\n// Settings:\n#define SHOW_INCIDENT_WAVE 1\n#define SHOW_REFLECTED_WAVE 1\n#define SHOW_TRANSMITTED_WAVE 1\n\n#define NUMBER_OF_SAMPLES 256\n#define WAVE_LENGTH 32 // Wave length, in pixels\n#define ENABLE_ROUGHNESS 1\n#define ENABLE_DISTANCE_ATTENUATION 1 // Not sure which is correct. :-/\n#define ENABLE_WAVE_HIGHLIGHTING 0 // Doesn't work yet.\n\n// Index of refraction of both media:\n#define N1 1.0\n#define N2 1.5\n\n// Color to distinguish the two media:\n#define bgColor vec3(0.05, 0.2, 0.4)\n#define matColor vec3(0.4, 0.2, 0.05)\n\n// Colors to distinguish incident, reflected and\n// transmitted waves:\n#define iColor vec3(1.0, 0.8, 0.6)\n#define rColor vec3(1.0, 0.2, 0.1)\n#define tColor vec3(1.0, 0.7, 0.0)\n\n#define PI acos(-1.)\n\n// ---8<---------------------------------------------------------\n// Implementation starts here.\n\nfloat getHeight(float x)\n{\n    float a = texture(iChannel0, vec2(x+0.5, 0.)).r;\n#if ENABLE_ROUGHNESS\n    float roughness = smoothstep(1., 0., abs(x * 2. - 1.));\n    roughness *= roughness;\n#else\n    float roughness = 0.;\n#endif\n    float h = ((a-0.5)*0.2*roughness + 0.5);\n    return h * iResolution.y/iResolution.x;\n}\n\nfloat getWave(float d, float t, float waveLength, float speed, float phase)\n{\n    float x = (d - t*speed + phase);\n#if ENABLE_WAVE_HIGHLIGHTING\n    float intensity = pow(fract(x), 5.);\n#else\n    float intensity = 1.;\n#endif\n    return sin(2. * PI * x / waveLength) * intensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= iResolution.y/iResolution.x;\n\n    float height = getHeight(uv.x);\n    float fAbove = smoothstep(-0.001, 0.001, uv.y-height);\n    bool isAbove = (fAbove > 0.5);\n    float t = iTime * 50. / iResolution.x;\n\n    // Incoming wave:\n    vec2 sourceDirection = iMouse.xy / iResolution.xy - vec2(0.5, 0.);\n    vec2 sourcePosition = 0.5 + 100. * normalize(sourceDirection);\n    float iWave = 0.;\n#if SHOW_INCIDENT_WAVE\n    if (isAbove)\n    {\n    \tfloat iWaveLength = float(WAVE_LENGTH) / iResolution.x / N1;\n    \tiWave += getWave(length(uv - sourcePosition), t, iWaveLength, 1./N1, 0.) * fAbove;\n    }\n#endif\n\n    // Reflected and transmitted waves:\n    float rWave = 0.;\n    float tWave = 0.;\n    for (int i = 0; i < NUMBER_OF_SAMPLES; ++i)\n    {\n        float x = float(i) / max(1., float(NUMBER_OF_SAMPLES-1));\n        float y = getHeight(x);\n\n        vec2 p = vec2(x, y);\n        float di = length(p - sourcePosition) * N1;\n        float drt = length(uv - p);\n\n#if ENABLE_DISTANCE_ATTENUATION\n\t    float attenuation = drt;\n#else\n    \tfloat attenuation = 0.1;\n#endif\n\n#if SHOW_REFLECTED_WAVE\n        if (isAbove)\n        {\n\t        float rWaveLength = float(WAVE_LENGTH) / iResolution.x / N1;\n            rWave += getWave(drt, t, rWaveLength, 1./N1, di/N1) * fAbove / attenuation;\n        }\n#endif\n#if SHOW_TRANSMITTED_WAVE\n        if (!isAbove)\n        {\n    \t    float tWaveLength = float(WAVE_LENGTH) / iResolution.x / N2;\n\t        tWave += getWave(drt, t, tWaveLength, 1./N2, di/N2) * (1.-fAbove) / attenuation;\n        }\n#endif\n    }\n    rWave /= float(NUMBER_OF_SAMPLES);\n    tWave /= float(NUMBER_OF_SAMPLES);\n\n    vec3 color = mix(matColor, bgColor, fAbove);\n    color = mix(color, iColor, clamp(iWave, 0., 1.));\n    color = mix(color, rColor, clamp(rWave, 0., 1.));\n    color = mix(color, tColor, clamp(tWave, 0., 1.));\n\n    // Output to screen\n    fragColor = vec4(pow(color, vec3(1./2.2)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}