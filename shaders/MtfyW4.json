{
    "Shader": {
        "info": {
            "date": "1504796657",
            "description": "Just a study on 2D SDF functions",
            "flags": 0,
            "hasliked": 0,
            "id": "MtfyW4",
            "likes": 35,
            "name": "The Tree of Knowledge",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "tree"
            ],
            "usePreview": 0,
            "username": "rigel",
            "viewed": 1096
        },
        "renderpass": [
            {
                "code": "// Author: Rigel\n// licence: https://creativecommons.org/licenses/by/4.0/\n\n#define PI 3.14159265\n#define BW 0.\n#define WB 1.\n\n// hash function 1D\nfloat hash(float n) {\n   return fract(sin(n) * 43758.5453123);\n}\n\n// noise function 1D\nfloat noise(float p) {\n   float i = floor(p);\n   float f = fract(p);\n   return mix(hash(i), hash(i + 1.0), f);\n}\n\n// signed distance function for a square\nfloat sdfSquare(vec2 p) {\n   vec2 ap = abs(p);\n   return max(ap.x,ap.y) - 1.;\n}\n\n// signed distance function for a circle\nfloat sdfCircle(vec2 p) {\n   return length(p) - 1.0;\n}\n\n// render an sdf with a stroke with a witdth w, at the zero boundary\n// the combination of smoothstep and fwidth allow a proper scaled antialiasing\nfloat stroke(float d, float w, float i) {\n    return abs(smoothstep(w*0.5, w*0.5+fwidth(d),abs(d)) - i);\n}\n\n// render an sdf with a normal fill BW or inverse fill WB, at the zero boundary\n// the combination of smoothstep and fwidth allow a proper scaled antialiasing\nfloat fill(float d, float i) {\n    return abs(smoothstep(-1.,1.,d/fwidth(d)) - i);\n}\n\n//smooth min between two sdf from iq\n//https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n   float res = exp(-k*a)+exp(-k*b);\n   return -log(res)/k;\n}\n\n// signed distance function for a tree\n// level is the branching level of the tree\n// theta is the angle between the branches\n// scalef is the scaling factor between each level\nfloat sdfTree(vec2 p, int level, float theta, vec2 scalef) {\n    p += vec2(0.,1.);\n\n    // because the primitive is a square we need a base scale to transform it to a rectangle\n    vec2 scale = vec2(10.,3.);\n    vec2 trans = vec2(1.,2.)/scale;\n    \n    // so we start with the trunk...\n    scale *= scalef;\n    float d = sdfSquare(p * scale - vec2(0.,1.));\n\t\n    // then for each level...\n    for (int i=0; i<level; i++) {\n        scale *= scalef;\n        trans /= scalef;\n      \n        // we translate the rectangle up, and mirror in the x axis with abs and rotate it\n        // the power of  symmetry creates all the branches from only a few (level) branches\n        // try to remove the abs to see the only branches needed.\n        p = vec2(abs(p.x),p.y)-trans;\n        // 2d rotation matrix\n        p *= mat2(cos(theta),-sin(theta),sin(theta),cos(theta));\n        \n        // calculate the intersection with the trunk.. and repeat.\n        d = smin(d,sdfSquare(p * scale- vec2(0.,1.)),2.);\n    }\n  \n    return d;\n}\n\nfloat treeAnim(vec2 p, float phase) {\n    float theta = (PI/6.)*cos(1.-2.*noise(iTime+phase));\n    return fill(sdfTree(p*2.2-vec2(0.,0.55),7,theta,vec2(1.4,1.3)),BW);\n}\n\n\n// scene description\nvec3 TheTreeOfKnowledge(vec2 p) {\n    vec3 color = vec3(0.);\n  \n   \t// the iris of the eye\n    float c = sdfCircle(p*1.4);\n    color += fill(c,WB)*step(-0.2,p.y);\n    color += stroke(c,0.1,WB);\n    \n    // the tree and the roots\n    vec3 tree = vec3(treeAnim(p,0.),treeAnim(p,10.),treeAnim(p,20.)); \n    float roots = fill(sdfTree(vec2(0.9*p.x,-1.5*p.y)*2.-vec2(0.,1.3),4,PI/6.,vec2(1.38,1.39)),WB);\n\n    color *= tree;\n    color += roots*tree.r;// masking the roots trunk\n\n   \t// the eye and the rays\n    p.y = abs(p.y);\n   \tfloat eye = sdfCircle(p*.6+vec2(0.,.5));\n    float rays = stroke(cos(atan(abs(p.y),abs(p.x))*12.+iTime*0.5),1.8,BW);\n\n    color += fill(eye,BW)*rays; // use the eye to mask the rays\n    color += stroke(eye,0.05,WB);\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (2. * fragCoord - iResolution.xy) /iResolution.y;\n\n\tfragColor = vec4(TheTreeOfKnowledge(p), 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}