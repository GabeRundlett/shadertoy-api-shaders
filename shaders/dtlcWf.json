{
    "Shader": {
        "info": {
            "date": "1691562182",
            "description": "you can zoom in as far as you want but frames will suffer",
            "flags": 0,
            "hasliked": 0,
            "id": "dtlcWf",
            "likes": 1,
            "name": "Mandelbrot Arbitrary Precision",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "wyattlukelowery",
            "viewed": 179
        },
        "renderpass": [
            {
                "code": "#define hsl(h) .5-.5*k.www*clamp(k.xxx-abs(fract(h+k.xyz)*4.-2.),-1.,1.)\nconst vec4 k=vec4(3.,2.,1.,9.)/3.;\n\n#ifdef GL_ES\nprecision highp int;\n#endif\n\n/* integers per arbitrary-precision number */\nconst int vals = 5; //Chunks of ints\n\n//Size of int per 'int-chunk'\nconst int limit = 10000;\nconst float limitFlt = float(limit);\n\nint result[vals];\n\n#define zero(x, len) for(int i=0;i<len;i++){x[i]=0;}\n#define assign(x, y) for(int i=0;i<vals;i++){x[i]=y[i];}\n#define negate(x) for(int i = 0; i < vals; i++) { x[i] = -x[i]; }\n\nbool signp(int[vals] a) {\n\treturn (a[vals-1] >= 0);\n}\nint keepVal, carry;\nvoid roundOff(int x) {\n\tcarry = x / limit;\n\tkeepVal = x - carry * limit;\n}\nvoid add(int[vals] a, int[vals] b) {\n\tbool s1 = signp(a), s2 = signp(b);\n\n\tcarry = 0;\n\n\tfor(int i = 0; i < vals-1; i++) {\n\t\troundOff(a[i] + b[i] + carry);\n\n\t\tif(keepVal < 0) {\n\t\t\tkeepVal += limit;\n\t\t\tcarry--;\n\t\t}\n\n\t\tresult[i] = keepVal;\n\t}\n\troundOff(a[vals-1] + b[vals-1] + carry);\n\tresult[vals-1] = keepVal;\n\t\n\tif(s1 != s2 && !signp(result)) {\n\t\tnegate(result);\n\n\t\tcarry = 0;\n\n\t\tfor(int i = 0; i < vals; i++) {\n\t\t\troundOff(result[i] + carry);\n\n\t\t\tif(keepVal < 0) {\n\t\t\t\tkeepVal += limit;\n\t\t\t\tcarry--;\n\t\t\t}\n\n\t\t\tresult[i] = keepVal;\n\t\t}\n\n\t\tnegate(result);\n\t}\n}\nvoid mul(int[vals] a, int[vals] b) {\n\tbool toNegate = false;\n\n\tif(!signp(a)) {\n\t\tnegate(a);\n\t\ttoNegate = !toNegate;\n\t}\n\tif(!signp(b)) {\n\t\tnegate(b);\n\t\ttoNegate = !toNegate;\n\t}\n\n\tconst int lenProd = (vals-1)*2+1;\n\tint prod[lenProd];\n\tzero(prod, lenProd);\n\n\tfor(int i = 0; i < vals; i++) {\n\t\tfor(int j = 0; j < vals; j++) {\n\t\t\tprod[i+j] += a[i] * b[j];\n\t\t}\n\t}\n\n\tcarry = 0;\n\tconst int clip = lenProd - vals;\n\tfor(int i = 0; i < clip; i++) {\n\t\troundOff(prod[i] + carry);\n\t\tprod[i] = keepVal;\n\t}\n\n\tif(prod[clip-1] >= limit/2) {\n\t\tcarry++;\n\t}\n\n\tfor(int i = clip; i < lenProd; i++) {\n\t\troundOff(prod[i] + carry);\n\t\tprod[i] = keepVal;\n\t}\n\n\tfor(int i = 0; i < lenProd - clip; i++) {\n\t\tresult[i] = prod[i+clip];\n\t}\n\n\tif(toNegate) {\n\t\tnegate(result);\n\t}\n}\nvoid loadFloat(float f) {\n\tfor(int i = vals - 1; i >= 0; i--) {\n\t\tint fCurr = int(f);\n\t\tresult[i] = fCurr;\n\t\tf -= float(fCurr);\n\t\tf *= limitFlt;\n\t}\n}\n\nvoid mainImage( out vec4 O, in vec2 F ){\n    \n    //float zoom =exp(iTime*.6); & inverse\n    int zoom[vals];\n    loadFloat(exp(iTime*.6));\n    assign(zoom, result);\n    \n    int invZoom[vals]; //LIMITER ---- FIND WAY TO DO 'BIG' division\n    loadFloat(1./exp(iTime*.6));\n    assign(invZoom, result);\n    \n    //Center & unit coords\n    vec3 r = iResolution;\n    vec2 uv = (F*2.-r.xy)/r.y;\n    \n    //Seperate uv coords\n\tint uvX[vals];\n    loadFloat(uv.x);\n    assign(uvX, result);\n    \n    int uvY[vals];\n    loadFloat(uv.y);\n    assign(uvY, result);\n    \n    //Focal\n    int focalX[vals];\n    loadFloat(-.9002005);\n    focalX[vals-2]=-9003;\n    focalX[vals-3]=9800;\n    focalX[vals-4]=3889;\n    \n    int focalY[vals];\n    focalY[vals-2]=2325;\n    focalY[vals-3]=0030;\n    focalY[vals-4]=7299;\n    \n    \n    //ZOOM----------\n  \n    \n    //  uv/=zoom\n    mul(uvX, invZoom);\n    assign(uvX, result);\n    \n    mul(uvY, invZoom);\n    assign(uvY, result);\n    \n    // uv += focal\n    add(uvX, focalX);\n    assign(uvX, result);\n    \n    add(uvY, focalY);\n    assign(uvY, result);\n    \n    //--------\n    \n    \n    //vec2 z\n    int zX[vals];\n    int zY[vals];\n    \n    //Itermitent calcs\n    int z1[vals]; // x^2\n    int z2[vals]; //y^2\n    int z3[vals]; // x*y\n    int len[vals]; //length()\n    \n    //Iterate - num iterations here\n    for(float i,n=199.;i<n;i++){\n    \n        //CPU Saver & get rid of dots\n        if(abs(zX[vals-1])>2 || abs(zY[vals-1])>2)\n            return;\n    \n        //mult(z,z)\n        //vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n\n        mul(zX, zX); // x^2\n        assign(z1, result);\n\n        mul(zY, zY); //y^2\n        assign(z2, result);\n\n        mul(zX, zY); // x*y\n        assign(z3, result);\n\n        add(z3, z3); //zY = 2*x*y\n        assign(zY, result);\n\n        negate(z2); //zX = x^2-y^2\n        add(z1,z2);\n        assign(zX,result);\n\n        //z=mult(z,z)+uv\n        add(zX,uvX);\n        assign(zX,result);\n\n        add(zY,uvY);\n        assign(zY,result);\n        \n        //Length(z)\n        mul(zX,zX); //x^2\n        assign(len,result);\n        mul(zY,zY); //y^2\n        add(len,result);//x^2 + y^2\n        assign(len, result);\n\n        //SQRT - Linear Approximation around x=4 -----> y=x/4 + 1\n        loadFloat(0.25);\n        mul(len, result);\n        assign(len,result);//I forgot this line lmfao\n        len[vals-1] += 1;\n\n        //There is some issue with large numbers that repeat but it just adds spots so who cares\n        //Convergence Check\n        if(len[vals-1]<2)\n            O=(hsl(i/n)).xyzz;\n        \n\n    }\n       \n}\n\n\n    \n    \n    \n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}