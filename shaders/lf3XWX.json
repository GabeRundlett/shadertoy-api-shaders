{
    "Shader": {
        "info": {
            "date": "1714765975",
            "description": "Infinite hattifatteners surrounding a lightning rod.\nMade while learning how to do better domain repetition.\nFirst try making a raymarched scene with different materials.\nLighting is kept simple in part for the aesthetic (overcast sky etc.).",
            "flags": 8,
            "hasliked": 0,
            "id": "lf3XWX",
            "likes": 11,
            "name": "Signed Hattifattener Field",
            "published": 3,
            "tags": [
                "raymarching",
                "sound",
                "repetition",
                "lightning",
                "infinite"
            ],
            "usePreview": 1,
            "username": "rucksack",
            "viewed": 159
        },
        "renderpass": [
            {
                "code": "/********* ABOUT **********/\n/* Infinite hattifnatters surrounding a lightning rod.\n/* Lightning strikes every 10ish secs.\n/* Music transcribed from a Moomin episode.\n/* Click and drag to control position (vertical) and rotation (horizontal)\n/* Toggle settings on/off) to see different (mostly debug) views.\n\npres outline:\n- inspiration (screenshot of episode, what are they)\n- no triangles (instead of e.g. modeling in Blender, this is all code)\n- just distance\n- for each pixel, this code (called shader) is run\n- 2d march illustration (explain lil better here) (emphasize that center is camera)\n- show 2d ver of scene (helps explanation)\n- back to 3d w/o hats (plane)\n- grid\n- hash\n- buildup model\n- lightning + extra\n- aaaaaand the music you've heard comes from another shader (it was code all along)\n- ask me 4 questions later :)\n/**************************/\n\n/******** SETTINGS ********/\n//#define IS_2D\n//#define SINGLE\n\n//#define SHOW_DEPTH\n//#define SHOW_QUADRANTS\n//#define SHOW_GRID\n//#define SHOW_HASH\n\n#define BODY\n#define EYES\n//#define EYES_NONMIRROR\n#define ARMS\n#define BAG\n\n//#define FUNNY_BUG\n\n\n/******** TIME/INPUT-BASED PARAMETERS ********/\nvec3 ORIGIN;\nfloat LIGHTNING;\nfloat LIGHTNING_STRIKE;\nfloat CHARGE;\n\nvoid initialize_globals()\n{\n    ORIGIN = vec3(8.*(1.4-iMouse.y/iResolution.y)*cos(.2*iTime), 1.2*iMouse.y/iResolution.y, 8.*(1.4-iMouse.y/iResolution.y)*sin(.2*iTime));\n    LIGHTNING = (.6*smoothstep(.7, 1., (pow(abs(sin(.2*iTime + .3)), 80.))) + smoothstep(.7, 1., (pow(abs(sin(.2*iTime)), 100.))));\n    LIGHTNING_STRIKE = smoothstep(.3, 1., (pow(abs(sin(.2*iTime -.13)), 100.)));\n    CHARGE = smoothstep(0., .2, (pow(abs(sin(.2*iTime -.4)), 100.)));\n}\n\n/******** PARAMETERS ********/\nconst float VERY_LARGE = 1e30;\nconst float NORMAL_DELTA = .005;\nconst float STEP = .001;\nconst int MAX_STEPS = 100;\nconst float MAX_DIST = 40.;\nconst float MIN_DIST = .001;\nconst vec2 e = vec2(NORMAL_DELTA, 0);\nconst float PI = 3.1415;\n\nconst float MAX_SKY_DIST = 700.;\nconst float SKY_HEIGHT = 30.;\nconst float CELL_SIZE = 1.1;\nconst float POLE_AREA_RADIUS = 5.;\n\n\n/******** MATERIALS ********/\nfloat last_dist = VERY_LARGE;\nfloat hattifnatter_dist = VERY_LARGE;\nfloat pole_dist = VERY_LARGE;\nfloat bag_dist = VERY_LARGE;\nfloat bag_deco_dist = VERY_LARGE;\nfloat ground_dist = VERY_LARGE;\nfloat barometer_dist = VERY_LARGE;\nfloat barometer_glass_dist = VERY_LARGE;\nfloat lightning_dist = VERY_LARGE;\nfloat min_lightning_dist = VERY_LARGE;\nfloat min_hattifnatter_dist = VERY_LARGE;\n\n\nconst vec3 HATTIFNATTER_COLOR = vec3(204./256., 200./256., 192./256.);\nconst vec3 HATTIFNATTER_CHARGE_COLOR = vec3(196./256., 186./256., 163./256.);\nconst vec3 SKY_COLOR = vec3(138./256., 159./256., 202./256.);\nconst vec3 FOG_COLOR = SKY_COLOR*.5;\nconst vec3 GROUND_COLOR = vec3(71./256., 86./256., 53./256.);\nconst vec3 BAROMETER_COLOR = vec3(169./256., 89./256., 75./256.);\nconst vec3 BLACK_COLOR = vec3(27./256., 34./256., 35./256.)*.4;\nconst vec3 GOLD_COLOR = vec3(243./256., 202./256., 89./256.);\n\nstruct Material\n{\n    vec3 color;\n    float rim_strength;\n    float shininess;\n};\n\nconst Material hattifnatter_mat = Material(HATTIFNATTER_COLOR, 1., 0.);\nconst Material pole_mat = Material(BLACK_COLOR, 0., 0.);\nconst Material bag_mat = Material(BLACK_COLOR, 0., 0.);\nconst Material bag_deco_mat = Material(GOLD_COLOR, 1., 50.);\nconst Material barometer_mat = Material(BAROMETER_COLOR, 1., 100.);\nconst Material barometer_glass_mat = Material(HATTIFNATTER_COLOR, 1., 80.);\n\n\n/******** Rotations ********/\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s,\n               -s, c);\n}\n\nmat3 rotZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, s, 0,\n               -s, c, 0,\n                0, 0, 1);\n}\n\nmat3 rotY(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, 0, s,\n                0, 1, 0,\n               -s, 0, c);\n}\n\nmat3 rotX(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n#ifdef FUNNY_BUG\n    return mat3(0, 0, 1,\n#else\n    return mat3(1, 0, 0,\n#endif\n                0,  c, s,\n                0, -s, c);\n}\n\n/******** SDFs (most by Inigo Quilez) ********/\n\n// 3D //\nfloat sphere( vec3 p, float r )\n{\n  return length(p)-r;\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat vertical_capsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat rbox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// 2D //\nfloat disk(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat rrect( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p)-b+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\n// Operators //\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat extrudez(in float d, in vec3 p, in float h )\n{\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n\n/******** NOISE ********/\nfloat hash1(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(43.3333, 53.8123))) * 42348.234);\n}\nfloat hash2(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(93.263434, 76.2134))) * 646881.3461);\n}\n\nfloat perlin(in vec2 uv)\n{\n    vec2 ij = floor(uv);\n    vec2 t = smoothstep(0., 1., fract(uv));\n\n    vec2 d = vec2(1, 0);\n    float nw = hash1(ij);\n    float ne = hash1(ij + d.xy);\n    float se = hash1(ij + d.xx);\n    float sw = hash1(ij + d.yx);\n    \n    return mix(mix(nw, ne, t.x), mix(sw, se, t.x), t.y);\n}\n\nfloat fbm(in vec2 uv)\n{\n    float s = 1.;\n    float d = 1.;\n    float n = perlin(uv);\n    mat2 r = rot(17.3215);\n    for (int i = 0; i < 8; i++)\n    {\n        s *= 2.;\n        d *= .7;\n        r *= r;\n        n += perlin(s*r*uv) * d;\n    }\n    return n;\n}\n\n/******** SCENE ********/\nfloat pattern(vec3 p, vec2 id)\n{\n    // Avoid rendering inside the pole area\n    // and avoid oversteping based on this\n    float origin_dist = length(id);\n    if (origin_dist < POLE_AREA_RADIUS)\n        return POLE_AREA_RADIUS - origin_dist;\n\n    float r1 = hash1(id);\n    float r2 = hash2(id);\n\n    float h = .5 + r1*.5 + .1*sin(r1*.5*iTime+r2*13.);\n    float arm_length = .2+r1*.1;\n    float arm_height = max(.3, h*.6 - r2*.3);\n\n\n    // Offset pos\n    p.xz += .7*(vec2(1. - r1, r2)-.5);\n\n\n#ifdef BAG\n    // TODO make this its own function smh my head\n    mat3 brot = rotY(r1*2.*PI);\n    vec3 bp = rotY(r2*2.*PI) * p - vec3(.2, 0.1, .2);\n    float bag = rbox(brot * bp, vec3(.06, .1, .12), .02);\n    vec3 bdp = brot*(bp - vec3(0, .12, 0));\n    float bag_deco = rbox(vec3(bdp.xy, abs(bdp.z)) - vec3(0, 0, .03), vec3(.02, .022, .01), .005);\n    bag_deco = min(bag_deco, rbox(bdp - vec3(0, .02, 0), vec3(.02, .01, .04), .005));\n#else\n    float bag = VERY_LARGE;\n    float bag_deco = VERY_LARGE;\n#endif\n\n\n    // Turn towards moving origin\n    vec3 o = ORIGIN;\n    p = rotY(atan(id.x + sign(o.x)*.5*CELL_SIZE - o.x, id.y + sign(o.z)*.5*CELL_SIZE - o.z)) * p;\n\n    // Widen top\n    float wavy = .4*p.x;\n    // Sway\n    wavy += .09*sin(2.*iTime+r1*13.)*p.y;\n    // Wave\n    wavy += .02*sin(iTime + (14.-h)*p.y + r2*23.);\n    p = rotZ(wavy) * p;\n\n    // Body\n    float d = VERY_LARGE;\n#ifdef BODY\n    float hd = vertical_capsule(p, h, .1);\n#else\n    float hd = VERY_LARGE;\n#endif\n    \n#ifdef EYES\n    // Eyes (symmetry on the X axis)\n#ifdef EYES_NONMIRROR\n    hd = max(hd, -sphere(p - vec3(.04, h*.9, -.08), .03));\n#else\n    hd = max(hd, -sphere(vec3(abs(p.x), p.yz) - vec3(.04, h*.9, -.08), .03));\n#endif\n    // Pupils????\n    //bag = min(bag, sphere(vec3(abs(p.x), p.yz) - vec3(.04, h*.9, -.06), .013));\n#endif\n\n#ifdef ARMS\n    // Arms\n    mat3 r = rotZ(.5*PI + (r1 - .5)*.2 - .2*PI);\n    mat3 ri = rotZ(.1*PI);\n    for (int i = -2; i <= 2; i++)\n    {\n        vec3 ap = r*(p - vec3(0, arm_height, 0)) - vec3(0, -arm_length, 0);\n        hd = smin(hd, vertical_capsule(ap, 2.*arm_length, .015) , .04+r1*.04);\n        if (i < 2) r = ri * r;\n    }\n#endif\n    \n    hattifnatter_dist = min(hattifnatter_dist, hd);\n    d = min(d, hd);\n    \n    // The suitcase should be unaffected by swaying\n    bag_dist = min(bag_dist, bag);\n    bag_deco_dist = min(bag_deco_dist, bag_deco);\n\n    d = min(d, min(bag, bag_deco));\n\n    return d;\n}\n\n// From https://iquilezles.org/articles/sdfrepetition/\nfloat repeat(vec3 p, vec2 s)\n{\n    vec2 p2d = p.xz;\n    vec2 id = round(p2d/s);\n    vec2 id_offset = sign(p2d-s*id);\n\n    float d = VERY_LARGE;\n    bag_dist = VERY_LARGE;\n    bag_deco_dist = VERY_LARGE;\n    hattifnatter_dist = VERY_LARGE;\n    for (int y = 0; y < 2; y++)\n    {\n        for (int x = 0; x < 2; x++)\n        {\n            vec2 neighbour_id = id + vec2(x, y) * id_offset;\n            vec2 grid_point = s * neighbour_id;\n            vec3 real_p = p - vec3(grid_point.x, 0., grid_point.y);\n            d = min(d, pattern(real_p, neighbour_id));\n        }\n    }\n\n    return d;\n}\n\nfloat pole(vec3 p)\n{\n    pole_dist = vertical_capsule(p, 3., .2);\n\n    // Barometer as extruded 2d surface\n    p = rotY(.25*PI) * p;\n    p.z = -p.z;\n    p -= vec3(0, 2, -.249);\n    float d2d = rrect(p.xy - vec2(0, -.1), vec2(.05, .3), .05);\n    d2d = min(d2d, disk(p.xy - vec2(0, .15), .15));\n    d2d = min(d2d, rrect(p.xy - vec2(0, -.2), vec2(.1, .05), .05));\n    d2d = min(d2d, rrect(p.xy - vec2(0, -.3), vec2(.1, .05), .05));\n    barometer_dist = extrudez(d2d, p, .04);\n    p -= vec3(0, .15, -.02);\n    barometer_glass_dist = extrudez(disk(p.xy, .1), p, .04);\n    // Allow the glass to sink into the barometer surface w/o issue\n    barometer_dist = max(barometer_dist, -barometer_glass_dist);\n\n    return min(pole_dist, min(barometer_dist, barometer_glass_dist));\n}\n\nfloat dist(vec3 p)\n{\n    lightning_dist = VERY_LARGE;\n    if (LIGHTNING_STRIKE > 0.)\n    {\n        float n1 = .4*(fbm(vec2(p.x, p.y*.5)+iTime) - 1.5);\n        float n2 = .4*(fbm(vec2(p.x + 23., p.y*.5 - 35.)+iTime) - 1.5);\n        float r = smoothstep(0., .8, LIGHTNING_STRIKE)*(.1 + .4*sqrt(max(0., 4. - p.y)));\n        lightning_dist = vertical_capsule(p - vec3(n1,0,n2), SKY_HEIGHT, r);\n    }\n\n    // Bounding plane (cutting pole)\n    if (p.y > 3.7)\n         return min(lightning_dist, p.y + 3.5);\n\n    float hattifnatter = repeat(p, vec2(CELL_SIZE));\n    float pole = pole(p);\n    ground_dist = p.y;\n\n    return min(hattifnatter, min(lightning_dist, min(pole, ground_dist)));\n}\n\n\n/******** RAYMARCHING ********/\nfloat march(vec3 origin, vec3 dir)\n{\n    float d = 0.;\n    vec3 p = origin;\n    min_lightning_dist = VERY_LARGE;\n    min_hattifnatter_dist = VERY_LARGE;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        float step = dist(p);\n        d += step;\n        min_lightning_dist = min(min_lightning_dist, max(0., .01 + lightning_dist));\n        min_hattifnatter_dist = min(min_hattifnatter_dist, max(0., hattifnatter_dist));\n        if (step < MIN_DIST || d > MAX_DIST)\n        {\n            last_dist = step;\n            break;\n        }\n        // understep slightly\n        p += dir*step*.997;\n    }\n\n    return d;   \n}\n\nvec3 normal(vec3 p)\n{\n    return normalize(vec3(\n        dist(p + e.rgg) - dist(p - e.rgg),\n        dist(p + e.grg) - dist(p - e.grg),\n        dist(p + e.ggr) - dist(p - e.ggr)\n    ));\n}\n\n\n/******** COLOR ********/\nfloat lightning_bolt()\n{\n    return LIGHTNING_STRIKE*max(0.,0.4*log(1./min_lightning_dist));\n}\n\nvec3 charge_glow()\n{\n    if (CHARGE <= 0.) return vec3(0);\n    return CHARGE*HATTIFNATTER_CHARGE_COLOR*max(0.,0.1*log(1./min_hattifnatter_dist));\n}\n\nvec3 render_sky(vec3 ro, vec3 rd)\n{\n    float t = (SKY_HEIGHT - ro.y)/rd.y;\n    vec3 base_color = SKY_COLOR * (.5 + LIGHTNING);\n    float bolt = lightning_bolt();\n    if (t <= 0. || t > MAX_SKY_DIST)\n        return base_color;\n    vec3 p = ro + t*rd;\n    float fn = fbm(.2*p.xz);\n    float noise = .3*fn + fn*LIGHTNING;\n    return mix(SKY_COLOR * noise, base_color, smoothstep(100., MAX_SKY_DIST, t));\n}\n\nvec3 render_ground(vec3 p)\n{\n    vec3 base = GROUND_COLOR * (.2+.5*fbm(2.*p.xz));\n    vec3 tint = vec3(1);\n#ifdef SHOW_QUADRANTS\n    tint *= vec3(int(p.z < 0.), int(p.x > 0.), int(p.z > 0. && p.x < 0.));\n#endif\n#ifdef SHOW_GRID\n    vec2 idg = round(p.xz/CELL_SIZE);\n    tint *= .3 + .7*mod(idg.x + idg.y, 2.);\n#endif\n#ifdef SHOW_HASH\n    vec2 idh = round(p.xz/CELL_SIZE);\n    tint *= hash1(idh);\n#endif\n    return base * tint;\n}\n\nvec3 light(vec3 p, vec3 n, vec3 l, vec3 v, Material m)\n{\n    vec3 col = vec3(0);\n    // Light sources\n    col += m.color * (.8 * max(0., dot(n, l)) + .5 + .2*LIGHTNING);\n    col += float(m.shininess > 0.) * vec3(1) * pow(max(0., dot(reflect(l, n), -v)), max(.0001, m.shininess));\n    col += SKY_COLOR * (0.4 * max(0., dot(n, -l)) + .2 + .1*LIGHTNING);\n    col += vec3(1) * (LIGHTNING * max(0., dot(n, normalize(vec3(0, 40, 0)-p))));\n    col += vec3(1) * (LIGHTNING_STRIKE * max(0., dot(n, normalize(vec3(0, 4, 0)-p))) );\n    // Rim lighting\n    float vdotn = dot(v, n);\n    col = mix(col, m.color*1.2, m.rim_strength*smoothstep(.1, 0., max(0., vdotn*vdotn)));\n    return col;\n}\n\nMaterial get_material(vec3 p)\n{\n    Material m = hattifnatter_mat;\n    dist(p);\n    if (hattifnatter_dist <= MIN_DIST)\n        m = hattifnatter_mat;\n    else if (pole_dist <= MIN_DIST)\n        m = pole_mat;\n    else if (bag_dist <= MIN_DIST)\n        m = bag_mat;\n    else if (bag_deco_dist <= MIN_DIST)\n        m = bag_deco_mat;\n    else if (barometer_dist <= MIN_DIST)\n        m = barometer_mat;\n    else if (barometer_glass_dist <= MIN_DIST)\n        m = barometer_glass_mat;\n    else\n        m = Material(render_ground(p), 0., 0.);\n    return m;\n}\n\nvec3 color(vec3 p, vec3 v, float d)\n{\n    // Regular lighting\n    vec3 n = normal(p);\n    vec3 l = vec3(.5, 1, .5);\n    Material m = get_material(p);\n    return mix(light(p, n, l, v, m), FOG_COLOR + LIGHTNING, smoothstep(.8, 4., log(d)));\n}\n\n\n/******** RENDER ********/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    initialize_globals();\n\n#ifdef IS_2D\n#ifdef SINGLE\n    // Hattifnatter cross section 💀\n    uv.y += .5;\n    vec3 p = vec3(uv, .1);\n    float d = pattern(rotY(PI*.5) * (p + vec3(0, 0, .2)), vec2(9, 11));\n    float f = 300.;\n#else\n    // Top-down SDF slice\n    uv *= 20.;\n    vec3 p = vec3(uv.x, .5 + .5*iMouse.x/iResolution.x, uv.y);\n    float d = dist(p);\n    float f = 60.;\n#endif\n    vec3 col = mix(vec3(.5,0,.1), vec3(1), smoothstep(.02, 0., d)) * (.5 + .8*cos(f*d));\n\n#else\n    // 3D scene >:)\n    vec3 origin = ORIGIN + vec3(0, 1.2, 0);\n    float face_angle = atan(origin.x, origin.z) - iMouse.x/iResolution.x*PI*2.;\n    vec3 dir = rotY(-face_angle) * rotX(-.3*(iMouse.y/iResolution.y - .5) - .2) * normalize(vec3(uv.x, uv.y, -.7));\n    float d = march(origin, dir);\n    vec3 p = origin + dir*d;\n    \n    vec3 col;\n    // Beyond (sky)\n    if (d > MAX_DIST*.9 || lightning_dist <= MIN_DIST)\n        col = render_sky(origin, dir);\n    // Everything else\n    else\n        col = color(p, dir, d);\n    col += lightning_bolt();\n    col += charge_glow();\n#endif\n\n#ifdef SHOW_DEPTH\n    col = vec3(1) * max(0.,1. - log(1./(.07*d)));\n#endif\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float TAU = 6.2831;\nconst float CHAMBER_TONE = 440.;\n\n/****** ADJUSTMENTS ******/\nfloat env(float dec, float amp, float t)\n{\n    return exp(-dec*t)*amp;\n}\n\nvec2 pan(float p)\n{\n    return normalize(vec2(1.-p, 1.+p));\n}\n\n/****** INSTRUMENTS ******/\nfloat fm(float fc, float fm, float iom, float t)\n{\n    return sin(TAU*fract(fc*t) + iom*sin(TAU*fract(fm*t)));\n}\n\nfloat stringFM(float f, float t)\n{\n    return fm(f, f*4., 1., t) * env(3., .3, t);\n}\n\nvec2 bassFM(float f, float t)\n{\n    vec2 sound = vec2(0);\n    sound += fm(f-1., f*2., .7, t) * env(5., .2, t) * pan(-.5);\n    sound += fm(f+1., f*2., .7, t) * env(5., .2, t) * pan(.5);\n    sound += fm(f*.5, f*4., 1., t) * env(5., .2, t);\n\n    return sound;\n}\n\n\n/****** NOTE STUFF ******/\nfloat interval(float semitones)\n{\n    return pow(2., semitones/12.);\n}\n\nstruct T {\n    float semitones;\n    float duration;\n};\n\n\nconst float BPM = 95.;\nconst float SPB = 60./BPM;\n\n\n/****** NOTES ******/\n#define NOTES_IN_MELODY 10\nconst T melody[] = T[NOTES_IN_MELODY]\n(\n    T(0., .5), T(3., .5), T(2., .5), T(3., 4.5),\n    T(0., .5), T(3., .5), T(2., .5), T(3., .5),\n    T(0., 1.), T(0., 3.)\n);\n\n#define NOTES_IN_BASS 4\nconst T bass[] = T[NOTES_IN_BASS]\n(\n    T(-0., .5), T(3., .5), T(2., .5), T(3., .5)\n);\n\n\n/****** PLAYBACK ******/\nvec2 play_melody(float t)\n{\n    vec2 sound = vec2(0);\n    float nt = 4. * SPB;\n    float duration = 4.;\n    for (int i = 0; i < NOTES_IN_MELODY; i++)\n    {\n        duration += melody[i].duration;\n    }\n    for (int i = 0; i < NOTES_IN_MELODY; i++)\n    {\n        T note = melody[i];\n        float f = CHAMBER_TONE * interval(note.semitones);\n        sound += stringFM(f, mod(t - nt, duration*SPB));\n        nt += note.duration * SPB;\n    }\n    return sound;\n}\n\nvec2 play_bass(float t)\n{\n    vec2 sound = vec2(0);\n    float nt = 0.;\n    float duration = 0.;\n    for (int i = 0; i < NOTES_IN_BASS; i++)\n    {\n        duration += bass[i].duration;\n    }\n    for (int i = 0; i < NOTES_IN_BASS; i++)\n    {\n        T note = bass[i];\n        float f = CHAMBER_TONE * interval(note.semitones-24.);\n        sound += bassFM(f, mod(t - nt, duration*SPB));\n        nt += note.duration * SPB;\n    }\n    return sound;\n}\n\n\n/****** OUTPUT ******/\nvec2 mainSound( int samp, float t )\n{\n    vec2 sound = vec2(0);\n    \n    sound += play_melody(t);\n    sound += play_bass(t);\n\n    float lightning = (.6*smoothstep(.7, 1., (pow(abs(sin(.2*t + .3)), 80.))) + smoothstep(.7, 1., (pow(abs(sin(.2*t)), 100.))));\n    sound += lightning*sin(TAU*CHAMBER_TONE*interval(-12.)*mod(t, 20.))*.6;\n    float lightning_strike = smoothstep(.3, 1., (pow(abs(sin(.2*t -.13)), 100.)));\n    sound += lightning_strike*cos(TAU*CHAMBER_TONE*interval(-4.)*mod(t, 20.))*.6;\n\n    return sound;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}