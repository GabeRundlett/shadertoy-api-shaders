{
    "Shader": {
        "info": {
            "date": "1567978391",
            "description": "Fractals make the most beautiful jewelry, I think we can all agree on that.\n\nThe code is a mess, I'm really sorry about that.",
            "flags": 32,
            "hasliked": 0,
            "id": "Wsd3R4",
            "likes": 20,
            "name": "Precious marble",
            "published": 3,
            "tags": [
                "fractal",
                "mandelbulb",
                "dof",
                "volumetric",
                "bloom"
            ],
            "usePreview": 0,
            "username": "loicvdb",
            "viewed": 882
        },
        "renderpass": [
            {
                "code": "//film grain, bloom and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec3 shortBloom = vec3(0);\n    float tot, influence, phi, r;\n    float rd = 16.0;\n    int samples = 16;\n    for(int i = 1; i <= samples; i++){\n        phi = float(i) * 2.3998277;\n        r = sqrt(float(i)/float(samples+1));\n        influence = 1.0/r;\n        //shortBloom += texture(iChannel0, (fragCoord.xy+vec2(cos(phi), sin(phi))*r*rd)/iResolution.xy).rgb * influence;\n        shortBloom += texelFetch(iChannel0, ivec2(fragCoord.xy+vec2(cos(phi), sin(phi))*r*rd), 0).rgb * influence;\n        tot += influence;\n    }\n    shortBloom /= tot;\n    \n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).rgb;\n    color += max(shortBloom-1.5, vec3(0.0))*.3;\n    color += max(texelFetch(iChannel1, ivec2(fragCoord.xy), 0).rgb-1.0, vec3(0.0))*.3;\n    \n    float noise = .9 + randomFloat()*.2;\n    \n    float focalLength = .4;\n    float vignette = cos(atan(length(uv-.5), focalLength));\n    \n  \tfragColor = vec4(ACESFilm(color*noise * vignette), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define Pi 3.14159265359\n\n\n//uncomment for a high quality version\n//#define HQ\n\n#ifdef HQ\n\n#define MaxCameraOpacity .8\n#define MaxShadowOpacity .99\n#define MaxAmbientOpacity .4\n\n#define CameraRayStepSize .005\n#define ShadowRayStepSize .02\n#define AmbientRayStepSize .01\n\n#else\n\n#define MaxCameraOpacity .7\n#define MaxShadowOpacity .95\n#define MaxAmbientOpacity .3\n\n#define CameraRayStepSize .015\n#define ShadowRayStepSize .03\n#define AmbientRayStepSize .01\n\n#endif\n\n#define CameraRayStepFactor 1.5\n#define ShadowRayStepFactor 1.1\n#define AmbientRayStepFactor 2.0\n\n#define Epsilon .001\n\n#define LightBounces 2\n\nvec3 LightDir = normalize(vec3(-1, .0, .0));\nvec3 LightColor = vec3(.5, .5, .5) * 25.0;\n\nvec3 CamDir = normalize(vec3(-1, 0, .1));\nvec3 CamPos = vec3(2.5, 0, -.2);\nfloat FocalLength = .9;\n\nfloat BackgroundIntensity = 1.0;\nint BackgroundIndex = 0;\n    \nfloat Density = 20.0;\nfloat Anisotropy = .25;\n\nvec3 GoldAlbedo = vec3(1.000, 0.766, 0.336);\n\nfloat Ior = 1.7;\n\nfloat Power = 8.0;\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 814.1321914114157;\n  return fract(NoiseSeed);\n}\n\nfloat maxV(vec3 v){return max(max(v.x, v.y), v.z);}\n\nbool insideShape(vec3 pos, out vec3 volumeColor) {\n    \n    pos *= 1.9;\n    \n    vec3 z = pos;\n\tfloat r, zr, sinTheta, phi, theta;\n\tfor(int i = 0; i < 4; i++) {\n\t\tr = length(z);\n\t\tif(r>1.3) break;\n\t\ttheta = acos(z.z/r)*Power;\n\t\tphi = atan(z.y,z.x)*Power;\n        sinTheta = sin(theta);\n\t\tz = pow(r,Power)*vec3(sinTheta*vec2(cos(phi), sin(phi)), cos(theta)) + pos;\n\t}\n    volumeColor = 1.0-(pos*.5 + .5)*.6;\n\treturn r < 1.0;\n}\n\nfloat henyeyGreenstein(vec3 dir){\n\tfloat cosTheta = dot(dir, -LightDir);\n \treturn Pi/4.0 * (1.0-Anisotropy*Anisotropy) / pow(1.0 + Anisotropy*Anisotropy - 2.0*Anisotropy*cosTheta, 3.0/2.0);\n}\n\n\nvec3 background(vec3 dir){\n    if(dot(dir, -LightDir) > .995) return LightColor * 2.0;\n    vec3 col;\n    if(BackgroundIndex == 0)\n    \tcol = texture(iChannel0, dir.xzy).rgb;\n    else \n        col = texture(iChannel1, dir.xzy).rgb;\n    return (col*col + col) * BackgroundIntensity;\n}\n\nvec3 backgroundBlurred(vec3 dir){\n    vec3 col;\n    if(BackgroundIndex == 0)\n    \tcol = texture(iChannel0, dir.xzy, 7.0).rgb;\n    else \n        col = texture(iChannel1, dir.xzy, 7.0).rgb;\n    return (col*col + col) * BackgroundIntensity;\n}\n\nvec3 rotateZ(vec3 v, float phi){\n    return vec3(cos(phi)*v.x - sin(phi)*v.y, cos(phi)*v.y + sin(phi)*v.x, v.z);\n}\n\nfloat distThorus(vec3 pos, float angle){\n    pos = rotateZ(pos, angle);\n    pos = rotateZ(pos.zyx, .75).zyx;\n    return length( vec2(length(pos.xz)-1.02, pos.y) )-.015;\n}\n\nfloat distThorii(vec3 pos){\n    \n    float d = 10.0;\n    for(int i = 0; i < 8; i++){\n        d = min(distThorus(pos, float(i)*Pi/4.0), d);\n    }\n    \n    return d;\n}\n\nbool thoriiIntersect(inout vec3 pos, vec3 dir, out vec3 normal){\n    float dist;\n    while(length(pos) < 1.2 || dot(dir, pos) < 0.0){\n        dist = distThorii(pos);\n        if(dist < Epsilon) {\n            normal = normalize(vec3(distThorii(pos + vec3(Epsilon, 0, 0)),\n\t\t\t\t\t\t\t\t\tdistThorii(pos + vec3(0, Epsilon, 0)),\n\t\t\t\t\t\t\t\t\tdistThorii(pos + vec3(0, 0, Epsilon)))\n\t\t\t\t\t\t\t - vec3(distThorii(pos - vec3(Epsilon, 0, 0)),\n\t\t\t\t\t\t\t\t\tdistThorii(pos - vec3(0, Epsilon, 0)),\n\t\t\t\t\t\t\t\t\tdistThorii(pos - vec3(0, 0, Epsilon))));\n            return true;\n        }\n        pos += dir * dist;\n    }\n    return false;\n}\n\nbool sphereIntersect(inout vec3 pos, in vec3 dir, out vec3 normal){\n    float d = length(pos);\n    if(dot(pos, dir) >= 0.0) return false;\n    float alpha = acos(dot(dir, normalize(-pos)));\n    float h = d * sin(alpha);\n    if(h >= 1.0) return false;\n    pos += dir * (sqrt(d*d - h*h) - sqrt(1.0 - h*h));\n    normal = pos;\n    return true;\n}\n\nfloat distanceInSphere(vec3 pos, vec3 dir){\n    float d = length(pos);\n    float alpha = acos(dot(dir, normalize(-pos)));\n    float h = d * sin(alpha);\n    if(h >= 1.0) return 0.0;\n    return 2.0 * sqrt(1.0 - h*h);\n}\n\nvec3 directLight(vec3 pos){\n    \n    vec3 normal, hitPos = pos;\n    //if(thoriiIntersect(hitPos, -LightDir, normal)) return vec3(0.0);\n    \n    pos -= LightDir * ShadowRayStepSize * randomFloat();\n    \n    vec3 absorption = vec3(1.0);\n    vec3 volumeColor;\n    float stepSize = ShadowRayStepSize;\n    float hg = henyeyGreenstein(LightDir);\n    \n    do{\n        pos -= LightDir * stepSize;\n        if(insideShape(pos, volumeColor)){\n            absorption *= volumeColor * pow(.5, stepSize*Density * hg);\n            stepSize *= ShadowRayStepFactor;\n        }\n    } while(maxV(absorption) >= 1.0-MaxShadowOpacity && dot(pos, pos) < 1.0);\n    \n    absorption = max((absorption-vec3(1.0-MaxShadowOpacity)) / MaxShadowOpacity, vec3(0.0));\n    \n    return absorption*LightColor;\n}\n\nvec3 ambientLight(vec3 pos){\n    \n    vec3 ambientDir = normalize(pos);\n    \n    pos += ambientDir * AmbientRayStepSize * randomFloat() * 1.0;\n    \n    vec3 absorption = vec3(1.0);\n    vec3 volumeColor;\n    float stepSize = AmbientRayStepSize;\n    \n    float hg = henyeyGreenstein(ambientDir);\n    \n    do{\n        pos += stepSize * ambientDir;\n        if(insideShape(pos, volumeColor)){\n            absorption *= volumeColor * pow(.5, stepSize*Density * hg);\n            stepSize *= AmbientRayStepFactor;\n        }\n    } while(maxV(absorption) >= 1.0-MaxAmbientOpacity && length(pos) < 1.0);\n    \n    absorption = max((absorption-vec3(1.0-MaxAmbientOpacity)) / MaxAmbientOpacity, vec3(0.0));\n    \n    return absorption * backgroundBlurred(normalize(pos));\n}\n\nvec3 lightReceived(vec3 pos){\n    return ambientLight(pos) + directLight(pos);\n}\n\nvec3 marchRay(vec3 pos, vec3 dir, out vec3 absorption){\n    \n    pos += dir * CameraRayStepSize * randomFloat();\n    \n    float hg = henyeyGreenstein(dir);\n    vec3 color;\n    \n    float stepSize = CameraRayStepSize;\n    \n    absorption = vec3(1.0);\n    vec3 volumeColor;\n    \n    do {\n        if(insideShape(pos, volumeColor)){\n            color += volumeColor*absorption*lightReceived(pos) * hg*stepSize*Density;\n            absorption *= volumeColor * pow(.5, stepSize*Density * hg);\n            stepSize *= CameraRayStepFactor;\n        }\n        pos += dir * stepSize;\n    } while(maxV(absorption) >= 1.0-MaxCameraOpacity && dot(pos, pos) < 1.0);\n    \n    absorption = max((absorption-vec3(1.0-MaxCameraOpacity)) / MaxCameraOpacity, vec3(0.0));\n    \n    return color;\n}\n\nfloat fresnel(vec3 dir, vec3 normal, float ior) {\n  float cosi = dot(dir, normal);\n  float etai = 1.0;\n  float etat = ior;\n  if (cosi > 0.0) {\n    float tmp = etai;\n    etai = etat;\n    etat = tmp;\n  }\n    \n  // Compute sini using Snell's law\n  float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));\n    \n  // Total internal reflection\n  if (sint >= 1.0) return 1.0;\n    \n  float cost = sqrt(max(0.0, 1.0 - sint * sint));\n  cosi = abs(cosi);\n  float sqrtRs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n  float sqrtRp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n  return (sqrtRs * sqrtRs + sqrtRp * sqrtRp) / 2.0;\n}\n\nvec4 colorAndDepth(vec3 pos, vec3 dir){\n    \n    vec3 color = vec3(0.0);\n    vec3 absorption = vec3(1.0);\n    float depth = -1.0;\n    \n    for(int i = 0; i < LightBounces; i++){\n        \n        vec3 sphereNormal, hitSpherePos = pos;\n        bool hitSphere = sphereIntersect(hitSpherePos, dir, sphereNormal);\n        float dSphere = length(pos - hitSpherePos);\n            \n        vec3 thoriiNormal, hitThoriiPos = pos;\n        bool hitThorii = thoriiIntersect(hitThoriiPos, dir, thoriiNormal);\n        float dThorii = length(pos - hitThoriiPos);\n        \n        if(hitSphere && (!hitThorii || dThorii > dSphere)){\n            \n            pos = hitSpherePos;\n            \n            if(depth == -1.0) depth = length(CamPos-pos);\n            \n            float fresnel = fresnel(dir, sphereNormal, Ior);\n            vec3 reflectDir = reflect(dir, sphereNormal);\n            vec3 reflectColor;\n            hitThoriiPos = pos;\n            if(thoriiIntersect(hitThoriiPos, reflectDir, thoriiNormal))\n                reflectColor = background(reflect(reflectDir, thoriiNormal)) * GoldAlbedo;\n            else \n                reflectColor = background(reflectDir);\n\n            //first refraction\n            dir = refract(dir, sphereNormal, 1.0/Ior);\n           \n            vec3 newAbsorption;\n            vec3 rayMarchColor = marchRay(pos, dir, newAbsorption);\n            \n            color += absorption * (fresnel*reflectColor + (1.0-fresnel) * rayMarchColor);\n            \n            //second refraction\n            pos += distanceInSphere(pos, dir) * dir;\n            vec3 refractDir = refract(dir, -pos, Ior);\n            \n            if(refractDir != vec3(0)) dir = refractDir;\n                \n            absorption *= (1.0-fresnel) * newAbsorption;\n           \n        } else if(hitThorii){\n            \n            dir = reflect(dir, thoriiNormal);\n            if(depth == -1.0) depth = length(CamPos-hitThoriiPos);\n            pos = hitThoriiPos + thoriiNormal * Epsilon;\n            \n            absorption *= GoldAlbedo;\n        } else {\n    \t\tif(depth == -1.0) depth = 1000.0;\n            break;\n        }\n        \n        if(dir == vec3(0.0)) return vec4(color, depth);\n    }\n    \n    return vec4(color + absorption * background(dir), depth);\n}\n \nvec4 projectRay(vec2 posOnScreen){\n    \n\tvec3 camX = vec3(-CamDir.y, CamDir.x, 0);\n\tvec3 camY = cross(camX, CamDir);\n\tvec3 sensorX = camX * (posOnScreen.x/length(camX));\n\tvec3 sensorY = camY * (posOnScreen.y/length(camY));\n\tvec3 centerSensor = CamPos - CamDir * FocalLength;\n\tvec3 posOnSensor = centerSensor + sensorX + sensorY;\n\tvec3 newDir = normalize(CamPos - posOnSensor);\n    \n\treturn colorAndDepth(CamPos, newDir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    NoiseSeed = iTime + fragCoord.y * .02986546543 + fragCoord.x;\n    \n    CamDir = rotateZ(CamDir, -iTime/3.0 + sin(iTime*2.0) * .025);\n    CamDir = rotateZ(CamDir.xzy, sin(iTime*3.0) * .007).xzy;\n    CamPos = rotateZ(CamPos, -iTime/3.0);\n    \n    FocalLength *= 1.0 + pow(abs(cos(iTime/2.5)), 10.0)*.2;\n    \n    LightDir = rotateZ(LightDir, iTime/3.0);\n    LightDir = rotateZ(LightDir.xzy, .75).xzy;\n    \n    BackgroundIntensity = sin(iTime/3.0) * 1.5;\n    \n    if(BackgroundIntensity < 0.0){\n        BackgroundIntensity = -BackgroundIntensity;\n        BackgroundIndex = 1;\n    }\n    \t\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy/2.0)/iResolution.y;\n    fragColor = projectRay(uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define Pi 3.14159265359\n\n#define LensRatio 3.5\n#define DoFSamples 32\n#define Aperture .05\n\nfloat FocalDistance = 1.5;\nfloat FocalLength = .9;\n\nfloat dofRadius(float depth){\n\treturn Aperture*iResolution.y*atan(abs(depth-FocalDistance), depth) * FocalLength;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    FocalDistance *= 1.0 + sin(pow(abs(sin(iTime/2.0)), 30.0) * 3.0) *.5;\n    FocalLength *= 1.0 + pow(abs(cos(iTime/2.5)), 10.0)*.2;\n    \n    vec4 colorAndDepth;\n    float samples;\n    float r = 0.0, phi;\n    vec2 sc = vec2(sqrt(1.0/LensRatio), sqrt(LensRatio)) * iResolution.y * Aperture/Pi/2.0;\n    for(int i = 0; i < DoFSamples; i++){\n        \n        r = sqrt(float(i) / float(DoFSamples-1));\n        phi = 2.3998277 * float(i);\n        \n        vec2 d = r*vec2(cos(phi), sin(phi)) * sc;\n        vec4 p = texelFetch(iChannel0, ivec2(fragCoord.xy + d), 0);\n        float dr = dofRadius(p.a);\n        float influence = clamp(dr - length(d) + .5, 0.0, 1.0) / (dr*dr+.01);\n        colorAndDepth += influence * p;\n        samples += influence;\n    }\n    \n  \tfragColor = colorAndDepth/samples;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int rd = 32;\n    vec3 sum;\n    float influence, tot = 0.0;\n    for(int y = -rd; y <= rd; y++){\n        influence = 1.0 - (abs(float(y))+1.0)/float(rd);\n        sum += texelFetch(iChannel0, ivec2(fragCoord.xy) + ivec2(4*y, 4*y), 0).rgb * influence;\n        tot += influence;\n    }\n    fragColor = vec4(sum/tot, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int rd = 32;\n    vec3 sum;\n    float influence, tot = 0.0;\n    for(int x = -rd; x <= rd; x++){\n        influence = 1.0 - (abs(float(x))+1.0)/float(rd);\n        sum += texelFetch(iChannel0, ivec2(fragCoord.xy) + ivec2(4*x, -4*x), 0).rgb * influence;\n        tot += influence;\n    }\n    fragColor = vec4(sum/tot, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}