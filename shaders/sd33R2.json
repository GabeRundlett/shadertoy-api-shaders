{
    "Shader": {
        "info": {
            "date": "1630182872",
            "description": "Source for Oftenhide production - 4KiB executable moving picture \"Црни Поклон\" aka \"Xenium Noir\", published at Xenium Demoparty 2021. 1st place, counting backwards :), in 4k intro competition.\n\nCode: Angelo",
            "flags": 0,
            "hasliked": 0,
            "id": "sd33R2",
            "likes": 12,
            "name": "Црни Поклон",
            "published": 3,
            "tags": [
                "source",
                "exegfx"
            ],
            "usePreview": 1,
            "username": "unjello",
            "viewed": 410
        },
        "renderpass": [
            {
                "code": "/// Црни Поклон / oftenhide, a 4kib executable moving picture\n/// 1st place, counting backwards :) @ Xenium 2021\n/// License: CC0\n///\n/// Effects inspired by:\n/// Night Sneakings / crocidb: https://www.shadertoy.com/view/tlVXRz\n/// Neontoy / Flyguy: https://www.shadertoy.com/view/4sc3Wn\n/// Sound visualizer with hexagons / levonchic: https://www.shadertoy.com/view/wscfzX\n/// Lagomorph Noir / Soulman: https://www.pouet.net/prod.php?which=88672\n///\n/// <3 to all the authors, et al.\n///\n\n#define ZERO (min(iFrame, 0))\n#define DRAW_DISTANCE 25.\n#define AA  1\n#define SURFACE_DISTANCE 0.001\n\nfloat pi = atan(1.0)*4.;\nfloat epsilon = 1e-3;\nfloat infinity = 1e6;\n\nbool in_hexagon(vec2 p, vec2 pos, float d, float a) {\n    float x_ = pos.x - p.x;\n    float y_ = pos.y - p.y;\n    float s_ = sin(a);\n    float c_ = cos(a);\n    float dx = abs(x_ * c_ - y_ * s_)/d;\n    float dy = abs(x_ * s_ + y_ * c_)/d;\n    float ar = 0.25 * sqrt(3.0);\n    return (dy <= ar) && (ar * dx + 0.25 * dy <= 0.5 * ar);\n}\n\nvec4 render_background(vec2 fragCoord) {\n\tvec4 color = vec4(0., 0., 0., 1.);\n\tfloat grad = 1.0 - length(fragCoord - iResolution.xy / 2.0) / length(iResolution.xy) * 1.6;\n    color += grad / 3.0;\n\n    float d = 0.33 * iResolution.y;\n\tvec2 center = iResolution.xy / 2.0;\n\t\n\tfloat s = 1.0;\n\tfor (float i = 1.; i < 9.; i+=1.) {\n\t\tif(in_hexagon(fragCoord, center, d*i, (.4+i)*s)) {\n\t\t\tcolor += .025*s;\n\t\t}\n\t\ts *= -1.;\n\t}\n    return color*0.1;\n}\n\n\nfloat sdf_line(vec2 start, vec2 end, vec2 uv) {\n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\n\nfloat sdf_arc(vec2 origin, float start, float sweep, float radius, vec2 uv) { \n\tuv -= origin;\n\tuv *= mat2(cos(start), sin(start),-sin(start), cos(start));\n\n    float offs = (sweep / 2.0 - pi);\n    float ang = mod(atan(uv.y, uv.x) - offs, pi*2.) + offs;\n    ang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n\n    return distance(radius * vec2(cos(ang), sin(ang)), uv);\n}\n\n#define sdf_polygon(points, num_segments) for (int i = 0; i < num_segments*2; i+=2) { dist = min(dist, sdf_line(vec2(points[i], points[i+1]), vec2(points[i+2], points[i+3]), uv)); }\nfloat render_logo(vec2 uv) {\n\tfloat dist = infinity;\n    \n    sdf_polygon(float[8](0.,-.002,.053,-.057,.107,-.002,0.,-.002),3);\n    sdf_polygon(float[26](.319,.119,.42,-.002,.34,-.002,.279,.076,.216,.012,.135,.012,.239,.119,.071,.297,.151,.297,.279,.162,.326,.211,.406,.211,.319,.119),12);\n    sdf_polygon(float[10](.437,.262,.437,.333,.336,.226,.468,.226,.437,.262),4);\n    sdf_polygon(float[22](.596,.142,.383,.142,.434,.085,.447,.085,.447,.012,.577, .012,.577,.071,.499,.071,.499,.085,.545,.085,.596,.142),10);\n    sdf_polygon(float[10](.447,.213,.577,.213,.577,.152,.447,.152,.447,.213),4);\n    sdf_polygon(float[22](.662,.098,.662,.012,.608,.012,.608,.24,.662,.183,.715,.126,.715,.211,.769,.211,.769,-.015,.715,.041,.662,.098),10);\n    sdf_polygon(float[10](.796,.012,.796,.155,.85,.211,.85,.012,.796,.012),4);\n    sdf_polygon(float[6](1.065,.213,1.013,.213,1.013,.112),2);\n    sdf_polygon(float[14](.929,.112,.929,.212,.929,.225,.929,.295,.863,.225,.876,.214,.876,.112),6);\n    sdf_polygon(float[8](1.062,.112,1.062,.152,1.156,.213,1.065,.213),3);\n    sdf_polygon(float[48](1.25,.098,1.25,.24,1.198,.183,1.146,.126,1.093,.07,1.025,-.002,.779,-.002,.779,-.044,.742,-.002,.124,-.002,.07,-.06,1.053,-.06,1.146,.04,1.199,.098,1.199,-.044,1.253,.012,1.28,.041,1.333,.098,1.333,.012,1.384,.012,1.384,.24,1.333,.183,1.278,.126,1.25,.098),23);\n    sdf_polygon(float[10](1.4,.24,1.4,.185,1.477,.267,1.374,.267,1.4,.24),4);\n    sdf_polygon(float[8](1.436,.012,1.4,.051,1.4,.012,1.436,.012),3);\n    sdf_polygon(float[68](1.054,.303,1.06,.286,1.058,.277,1.053,.27,1.046,.266,1.04,.263,1.034,.262,1.028,.26,1.024,.256,1.022,.25,1.022,.236,1.058,.236,1.06,.234,1.06,.23,1.058,.227,1.015,.227,1.013,.23,1.013,.25,1.015,.26,1.02,.266,1.027,.27,1.033,.272,1.04,.274,1.046,.276,1.05,.28,1.051,.286,1.047,.296,1.038,.3,1.015,.3,1.013,.303,1.013,.306,1.015,.309,1.038,.309,1.054,.303),33);\n    sdf_polygon(float[44](1.082,.232,1.078,.245,1.078,.291,1.082,.304,1.095,.309,1.11,.309,1.123,.304,1.127,.291,1.127,.245,1.123,.232,1.11,.227,1.094,.227,1.118,.247,1.118,.289,1.116,.297,1.109,.3,1.096,.3,1.089,.297,1.087,.289,1.087,.247,1.089,.239,1.082,.232),21);\n    sdf_polygon(float[66](1.186,.303,1.192,.286,1.19,.277,1.185,.27,1.178,.266,1.171,.263,1.166,.262,1.16,.26,1.155,.256,1.154,.25,1.154,.236,1.189,.236,1.192,.234,1.192,.23,1.189,.227,1.147,.227,1.144,.23,1.144,.25,1.147,.26,1.152,.266,1.159,.27,1.165,.272,1.172,.274,1.177,.276,1.181,.28,1.183,.286,1.179,.296,1.17,.3,1.147,.3,1.144,.303,1.147,.309,1.17,.309,1.186,.303),32);\n    sdf_polygon(float[24](1.207,.3,1.205,.303,1.205,.306,1.207,.309,1.223,.309,1.225,.306,1.225,.23,1.223,.227,1.219,.227,1.216,.23,1.216,.3,1.207,.3),11);\n\n\tdist = min(dist, sdf_arc(vec2(0.971,0.112),3.14, 3.14, .041, uv));\n\tdist = min(dist, sdf_arc(vec2(0.969,0.112),3.14, 3.14, .093, uv));\n\treturn dist;\n}\n\nfloat render_border(vec2 uv) {\n    float dist = infinity;\n    \n\tdist = min(dist, sdf_line(vec2(0.027,0.422), vec2(1.488,0.422), uv));\n    dist = min(dist, sdf_line(vec2(0.027,0.4), vec2(0.772,0.4), uv));\n    dist = min(dist, sdf_line(vec2(0.827,0.4), vec2(1.488,0.4), uv));\n    dist = min(dist, sdf_line(vec2(-0.05,-.088), vec2(-0.016,0.355), uv));\n    dist = min(dist, sdf_line(vec2(-0.072,-.088), vec2(-0.038,0.355), uv));\n\tdist = min(dist, sdf_line(vec2(1.555,0.355), vec2(1.522,-0.138), uv));\n\tdist = min(dist, sdf_line(vec2(1.533,0.355), vec2(1.5,-0.138), uv));\n    dist = min(dist, sdf_line(vec2(1.455,-0.183), vec2(-.011,-0.133), uv));\n    dist = min(dist, sdf_line(vec2(1.455,-0.205), vec2(0.694,-0.180), uv));\n\tdist = min(dist, sdf_line(vec2(0.655,-0.180), vec2(-.011,-0.155), uv));\n    \n\n    dist = min(dist, sdf_arc(vec2(1.488,0.355),0.000, 1.571, 0.044, uv));\n    dist = min(dist, sdf_arc(vec2(1.488,0.355),0.000, 1.571, 0.066, uv));\n    dist = min(dist, sdf_arc(vec2(1.455,-0.138),4.712, 1.571, 0.044, uv));\n    dist = min(dist, sdf_arc(vec2(1.455,-0.138),4.712, 1.571, 0.066, uv));\n    dist = min(dist, sdf_arc(vec2(0.027,0.355),1.571, 1.571, 0.066, uv));\n    dist = min(dist, sdf_arc(vec2(0.027,0.355),1.571, 1.571, 0.044, uv));\n    dist = min(dist, sdf_arc(vec2(-0.005,-0.088),3.142, 1.571, 0.066, uv));\n    dist = min(dist, sdf_arc(vec2(-0.005,-0.088),3.142, 1.571, 0.044, uv));\n    \n    return dist;\n}\n\nvec3 render_neon(vec2 uv) {\n\tuv.y += 0.0045*sin(22.*iTime+uv.x*22.0+uv.y*77.)*0.3*sin(56.*iTime)*cos(14.*iTime);\n    vec2 offs = vec2(0.75, 0.125);\n    \n    float dist = 0.0;\n    float shade = 0.0;\n    vec3 color = vec3(0);\n    \n    float tf_text = max(epsilon*22., iTime - 0.6);\n    const float brightness = 0.00035;\n    float bright_text = brightness *2.2 * min(1.0, 1.0 - sin(tf_text*0.6 * pi * 50.0) / (0.3+tf_text*0.6 * pi * 1.3)); \n\tdist = render_logo(uv + offs);\n\tshade = bright_text / max(epsilon, dist*1.5 - 0.004*0.125);\n\tcolor += vec3(.9, .8, 0.8) * shade;\n    \n    tf_text = max(epsilon*22., iTime - 0.5);\n    bright_text = brightness * 3.5* min(1.0, 1.0 - sin(tf_text*0.5 * pi * 50.0) / (0.3+tf_text*0.5 * pi * 1.3));\n    dist = render_border(uv + offs);\n\tshade = bright_text / max(epsilon, dist - 0.003);\n\tcolor += vec3(2.25, 0.15, 0.10) * shade / (dist*10.);\n\t\n    return clamp(color,0.0001,1.);\n}\n\n\nfloat sdf_box(vec3 p, vec3 b)  {\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n}\n\nfloat sdf_vertical_capsule(vec3 p, float h, float r) {\n  p.y -= clamp(p.y, 0.0, h);\n  return length(p) - r;\n}\n\n\n\nvec2 sdf_wall(vec3 p, bool complete) {\n\n    // mortar\n    float f = dot(p, vec3(0.0, 0.0, -1.0)); \n   \tvec2 wall = vec2(f, 2.);\n\n\tif(complete)\n\t{\n\t    float abs_noise_1 = abs(noise(p * 50.0));\n    \tfloat abs_noise_2 = abs(noise(p * 5.0));\n    \n\t    // bricks\n\t    vec3 c = vec3(0.7, 0.65, 0.0);\n\t    vec3 bp = p - vec3(0.0, 0.0, 0.004);\n\t    vec3 bp1 = mod(bp + 0.5 * c, c) - 0.5 * c;\n\t    bp -= vec3(0.35, 0.33, 0.0);\n\t    vec3 bp2 = mod(bp + 0.5 * c, c) - 0.5 * c;\n\t    \n\t    float b = sdf_box(bp1, vec3(0.288, 0.08, 0.03));\n\t    b = min(b, sdf_box(bp2, vec3(0.288, 0.09, 0.03)));\n\t    vec2 bricks = vec2(b - abs_noise_1 * 0.005 - abs_noise_2 * 0.02 - .020, 3.);\n\t    \n\t    return wall.x < bricks.x ? wall : bricks;\n    }\n\n    return wall;\n}\n\nvec2 map(vec3 p, bool complete) {\n\tvec2 result = vec2(DRAW_DISTANCE, 0.);\n\t\n\t// floor 1.\n\tfloat f = dot(p + vec3(0.0, 0.3, 0.0), vec3(0.0, 1.0, 0.0));\n\t// sidewalk\n    f = min(f, sdf_box(p + vec3(0.0, 0.32, 0.0), vec3(30.2, 0.3, 2.7)) - .025);\n    f = min(f, sdf_box(p + vec3(-1.5, 0.32, 0.0), vec3(1.5, 0.3, 30.2)) - .025);\n    if (f < result.x) result = vec2(f, 1.0);\n    \n    vec2 wall1 = sdf_wall(p, complete);\n    if (wall1.x < result.x) result = wall1;\n    \n    vec3 p2 = p;\n    p2.x -= 3.0;\n    p2.xz = p2.zx;\n    vec2 wall2 = sdf_wall(p2, complete);\n\tif (wall2.x < result.x) result = wall2;\n    \n    float door = sdf_box(p+vec3(-3.93,-2,5.), vec3(1.1,3.,1.5));\n    if (door < result.x) result = vec2(door, 4.);\n    \n    float pipe = sdf_vertical_capsule(p + vec3(-2.7, 4.4, .3), 20., .11);\n    if (pipe < result.x) result = vec2(pipe, 5.);\n    \n\tfloat ddoor = sdf_box(p+vec3(-4.2,-2,3.5), vec3(4.1,3.,.05));\n\tif (ddoor < result.x) result = vec2(ddoor, 6.);\n\n    return result;\n}\n\nvec3 estimate_normal(vec3 p) {\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ ) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.0001*e, true).x;\n    }\n    return normalize(n);\n}\n\nvec2 ray_march(vec3 ray_origin, vec3 ray_destination) {\n    float total_distance = 0.0;\n    vec3 point;\n    vec2 result;\n    for (int i = 0; i < 20; i++) {\n        point = ray_origin + total_distance * ray_destination;\n       \t\n        result = map(point, true);\n        \n        if (result.x < SURFACE_DISTANCE || total_distance > DRAW_DISTANCE) break;\n        \n        total_distance += result.x;\n    }\n    \n    result.x = total_distance;\n    return result;\n}\n\n// Lighting\nfloat ambient_occlusion(vec3 p, vec3 n) {\n\tfloat stepSize = 0.002f;\n\tfloat t = stepSize;\n\tfloat oc = 0.0f;\n\tfor(int i = 0; i < 10; ++i) {\n\t\tvec2 obj = map(p + n * t, false);\n\t\toc += t - obj.x;\n\t\tt += pow(float(i), 2.2) * stepSize;\n\t}\n\n\treturn 1.0 - clamp(oc * 0.2, 0.0, 1.0);\n}\n\nfloat get_visibility(vec3 p0, vec3 p1, float k) {\n\tvec3 rd = normalize(p1 - p0);\n\tfloat t = 10.0f * SURFACE_DISTANCE;\n\tfloat maxt = length(p1 - p0);\n\tfloat f = 1.0f;\n\twhile(t < maxt || t < DRAW_DISTANCE) {\n\t\tvec2 o = map(p0 + rd * t, false);\n\n\t\tif(o.x < SURFACE_DISTANCE)\n\t\t\treturn 0.0f;\n\n\t\tf = min(f, k * o.x / t);\n\t\tt += o.x;\n\t}\n\treturn f;\n}\n\n\nvec3 render(vec2 obj, vec3 p, vec3 rd, vec2 uv) {\n\tvec3 col;\n\tvec3 normal = estimate_normal(p);\n\tfloat fog;\n\t\n    vec3 background = vec3(0.0, 0.01, 0.05);\n    float n = noise(uv * 250.0);\n    n = smoothstep(0.6, 0.65, n) * .5;\n    background *= n;\n\t\n\tif (obj.x >= DRAW_DISTANCE) {\n\t\tcol = background;\n\t} else {\n\t\tfloat wallnoise = ((noise(p * 2.0)) * .2 + 0.7);\n\t\tvec3 albedo = vec3(0.285, 0.364, 0.294) * 0.6;\n        fog = pow((obj.x / DRAW_DISTANCE), 6.8);\n        float aa = ambient_occlusion(p, normal);\n        \n        float diff_mask = 1.0;\n        float spec_power = 10.0;\n        float spec_mask = .5;\n        \n\n    \tcol += albedo * pow(aa, 4.0) * .7+.03;\n    \tif (obj.y >= 6.0) { // door\n        \n            albedo = vec3(.055, .194, .184) ;\n            \n            spec_power = 20.0;\n            spec_mask = 10.;\n        } else if (obj.y >= 5.0) { // pipe\n        \n            albedo = vec3(0.505, 0.194, 0.184) ;\n            \n\n            spec_power = 20.0;\n            spec_mask = 1.;\n        } else if (obj.y >= 4.0) { // door\n            albedo = vec3(.505, .194, .084) ;\n            \n            spec_power = 20.0;\n            spec_mask = smoothstep(0.1, 1.,sin(iTime*0.5)-0.2)+normal.y*2.;\n        } else if (obj.y >= 3.0) { // bricks\n            float n = abs(noise(uv * 2.0));\n            albedo = vec3(0.405, 0.194, 0.184) * (n * 0.4 + 0.6);\n            \n            spec_power = 50.0;\n            spec_mask = .3;\n        } else if (obj.y >= 2.) { // mortar\n            albedo = vec3(0.305, 0.354, 0.384) * wallnoise *0.5;\n        } else if (obj.y >= 1.) { // floor\n        \tfloat floornoise = ((noise(p * 22.0)) * .02 + 0.7);\n            albedo = vec3(0.285, 0.364, 0.294) * 0.7 * floornoise;\n\n            spec_power = 10.0;\n            spec_mask = 0.5;\n        }\n    \t{\n            vec3 light_pos = vec3(-32.0, 35.0, -35.);\n            vec3 light_col = vec3(0.2, 0.2, .2);\n            vec3 light_dir = normalize(light_pos - p);\n\t\n\t\t\tvec3 refd = reflect(rd, normal);\n\n   \n            float diffuse = dot(light_dir, normal);\n            float visibility = get_visibility(p, light_pos, 10.0);\n        \tfloat spec = pow(max(0.0, dot(refd, light_dir)), spec_power);\n\n            col += diff_mask * diffuse * albedo * visibility * light_col * 3.5;\n            col += spec * (light_col * albedo) * spec_mask;\n        }\n        {\n            vec3 light_pos = vec3(1.8, 3.2, -5.);\n            vec3 light_col = vec3(1.725, 1.285, 1.0);\n            vec3 normal = normal;\n            normal.y*=sin(iTime*0.5);\n         \n            vec3 refd = reflect(rd, normal);\n            vec3 light_dir = normalize(light_pos - p);\n\n            float diffuse = dot(light_dir, normal);\n            float visibility = get_visibility(p, light_pos, 20.0);\n            float spec = pow(max(0.0, dot(refd, light_dir)), spec_power);\n\n            col += diffuse * albedo * 0.2 * light_col;\n            col += spec * (light_col * albedo) * spec_mask;\n        }\n\t}\n\t\n\treturn mix(col, background, fog);\n}\n\n\nvec3 render_from(vec2 uv, vec3 eye_position, vec3 look_at, vec3 up) {\n    vec3 forward = normalize(look_at - eye_position);\n    vec3 right = normalize(cross(up, forward));\n    up = cross(-right, forward);\n    float focal_length = 1.0;\n    vec3 start_pos = eye_position + forward * focal_length + right * uv.x + up * uv.y;\n    vec3 direction = normalize(start_pos - eye_position);\n\n    vec2 obj = ray_march(start_pos, direction);\n    vec3 p = start_pos + obj.x * direction;\n    vec3 color = render(obj, p, direction, uv);\n    color = pow(vec3(dot(color, vec3(.2126, .7152, .0722))), vec3(0.995));\n\tcolor -= vec3(0.315); \n  \treturn color*0.729;\n}\n\nvec3 volumetric_fog(vec2 uv, vec3 bg) {\n    float T = 5.0;\n    float t = iTime*0.05;\n    float iterations = 30.;\n    float fog_density = .5;\n    float view_distance = 6.0;\n    float fog_intensity = 2.0;\n\tvec3 fog_color = vec3(.13, .1, .1);\n   \n    float tr = (t / 2.0 + 910. / 200.0);\n    float r = (1.0 + cos(tr)) * 15.0;\n    \n    float tx = t * 0.1 - 1400. / 1000.0;\n    float camx = r * cos(tx / T * (2.0 * pi));\n    float camy = 0.0;\n    float camz = r * sin(tx / T * (2.0 * pi));\n        \n    vec3 cam_pos = vec3(camx, camy, camz);\n    vec3 cam_up = vec3(0, 1, 0);\n    vec3 cam_dir = normalize(cam_pos);\n    vec3 cam_right = cross(cam_up, cam_dir);\n    \n    vec3 ray = cam_up * uv.y + cam_right * uv.x + cam_dir;\n    vec3 pos = cam_pos;\n\n    vec3 p = pos;\n    float density = 0.0;\n\n    for (float i = 0.0; i < iterations; i++) {\n        float f = i / iterations;\n        float alpha = smoothstep(0.0, iterations * 0.2, i) * (1.0 - f) * (1.0 - f);\n        float dense_fog = smoothstep(fog_density, 0.75, noise(p));\n        float light_fog = (smoothstep(-0.2, 1.2, noise(p * 2.0)) - 0.5) * 0.5;\n        density += (light_fog + dense_fog) * alpha;\n        p = pos + ray * f * view_distance;\n    }\n\n    float l = (density / iterations) * fog_intensity;\n    return bg+(fog_color+fog_color*l*8.)*0.35;\n}\n\nvec3 render_left(vec2 uv) {\n\treturn volumetric_fog(uv*4., render_from(uv, vec3(-12., 1.5, -5.), vec3(12., 4.,-1.), vec3(0.,.2, .1)));\n}\n\n\nvec3 render_right(vec2 uv) {\n\tvec3 neon = render_neon(uv*2.1);\n\treturn render_from(uv, vec3(-6., 3., -15.), vec3(-6., 5., 0.), vec3(0.,1.,0.))\n\t*(-0.001+pow(neon, vec3(0.35)))\n\t+neon+0.0025;\n}\n\nvec3 render(vec2 uv) {\n\tuv /= 1.45;\n\n    float lw = 0.005;\n    float split = uv.x - 0.45 * uv.y;\n\n\tif (abs(uv.x) > 1.-lw || abs(uv.y) > iResolution.y/iResolution.x - lw) {\n\t\treturn vec3(-1.);\n\t}\n    if (abs(split) < lw*.5 || abs(uv.x) > 1.-lw*2. || abs(uv.y) > iResolution.y/iResolution.x - lw*2.) {\n        return vec3(1.);\n    }\n    if (abs(split) < lw*2. || abs(uv.x) > 1.-lw*3. || abs(uv.y) > iResolution.y/iResolution.x - lw*3.) {\n        return vec3(0.);\n    }\n    if (split > 0.) {\n        return render_right(uv-vec2(0.5,0.));\n    } else {\n        return render_left(uv+vec2(0.5,0.));\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec4 total_color = vec4(0.);\n\t\n\tfor(int m=0; m<AA; m++) \n    for(int n=0; n<AA; n++) {\n        vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0 * (fragCoord + o) - iResolution.xy) / iResolution.y;\n   \n   \t\tvec4 color = render_background(fragCoord);\n   \t\tvec3 c = render(uv);\n   \t\tif (c.x > -0.5) {\n   \t\t   \tcolor = vec4(c,1.);\n   \t\t}\n\n    \tcolor.xyz = pow( color.xyz, vec3(0.795) );\n\t    color *= 2.5;\n\t   \tcolor *= 0.5;\n\t    color = 1.-exp(color*-2.);\n\t    \n\t    total_color += color;\n\t}\n\ttotal_color /= float(AA*AA);\n    fragColor = total_color;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// value noise as seen on iq's tutorials \n// https://iquilezles.org/articles/morenoise\nfloat hash1(vec2 p) {\n    p=50.0*fract(p*0.3183099 );\n    return fract(p.x*p.y*(p.x+p.y));\n}\n\nfloat hash1(float n) {\n    return fract(n*17.0*fract(n*0.3183099));\n}\n\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\n\nfloat noise(vec2 x) {\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    return -1.0+2.0*(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}