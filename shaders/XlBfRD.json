{
    "Shader": {
        "info": {
            "date": "1514725735",
            "description": "An Approximation Chapman Function for Atmospheric Scattering, Per Pixel with 16 samples, See GPU Pro 3 for more information\n\n* Use mouse to move the sun\n* Run it in fullscreen",
            "flags": 0,
            "hasliked": 0,
            "id": "XlBfRD",
            "likes": 50,
            "name": " Atmospheric Scattering",
            "published": 3,
            "tags": [
                "sky",
                "scattering"
            ],
            "usePreview": 0,
            "username": "cubi",
            "viewed": 5074
        },
        "renderpass": [
            {
                "code": "// License (MIT) Copyright (C) 2017-2018 Rui. All rights reserved.\n                \n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define PI 3.1415926535f\n#define PI_2 (3.1415926535f * 2.0)\n\n#define EPSILON 1e-5\n\n#define SAMPLES_NUMS 16\n\nfloat saturate(float x){ return clamp(x, 0.0, 1.0); }\n\nstruct ScatteringParams\n{\n    float sunRadius;\n\tfloat sunRadiance;\n\n\tfloat mieG;\n\tfloat mieHeight;\n\n\tfloat rayleighHeight;\n\n\tfloat3 waveLambdaMie;\n\tfloat3 waveLambdaOzone;\n\tfloat3 waveLambdaRayleigh;\n\n\tfloat earthRadius;\n\tfloat earthAtmTopRadius;\n\tfloat3 earthCenter;\n};\n\nfloat3 ComputeSphereNormal(float2 coord, float phiStart, float phiLength, float thetaStart, float thetaLength)\n{\n\tfloat3 normal;\n\tnormal.x = -sin(thetaStart + coord.y * thetaLength) * sin(phiStart + coord.x * phiLength);\n\tnormal.y = -cos(thetaStart + coord.y * thetaLength);\n\tnormal.z = -sin(thetaStart + coord.y * thetaLength) * cos(phiStart + coord.x * phiLength);\n\treturn normalize(normal);\n}\n\nfloat2 ComputeRaySphereIntersection(float3 position, float3 dir, float3 center, float radius)\n{\n\tfloat3 origin = position - center;\n\tfloat B = dot(origin, dir);\n\tfloat C = dot(origin, origin) - radius * radius;\n\tfloat D = B * B - C;\n\n\tfloat2 minimaxIntersections;\n\tif (D < 0.0)\n\t{\n\t\tminimaxIntersections = float2(-1.0, -1.0);\n\t}\n\telse\n\t{\n\t\tD = sqrt(D);\n\t\tminimaxIntersections = float2(-B - D, -B + D);\n\t}\n\n\treturn minimaxIntersections;\n}\n\nfloat3 ComputeWaveLambdaRayleigh(float3 lambda)\n{\n\tconst float n = 1.0003;\n\tconst float N = 2.545E25;\n\tconst float pn = 0.035;\n\tconst float n2 = n * n;\n\tconst float pi3 = PI * PI * PI;\n\tconst float rayleighConst = (8.0 * pi3 * pow(n2 - 1.0,2.0)) / (3.0 * N) * ((6.0 + 3.0 * pn) / (6.0 - 7.0 * pn));\n\treturn rayleighConst / (lambda * lambda * lambda * lambda);\n}\n\nfloat ComputePhaseMie(float theta, float g)\n{\n\tfloat g2 = g * g;\n\treturn (1.0 - g2) / pow(1.0 + g2 - 2.0 * g * saturate(theta), 1.5) / (4.0 * PI);\n}\n\nfloat ComputePhaseRayleigh(float theta)\n{\n\tfloat theta2 = theta * theta;\n\treturn (theta2 * 0.75 + 0.75) / (4.0 * PI);\n}\n\nfloat ChapmanApproximation(float X, float h, float cosZenith)\n{\n\tfloat c = sqrt(X + h);\n\tfloat c_exp_h = c * exp(-h);\n\n\tif (cosZenith >= 0.0)\n\t{\n\t\treturn c_exp_h / (c * cosZenith + 1.0);\n\t}\n\telse\n\t{\n\t\tfloat x0 = sqrt(1.0 - cosZenith * cosZenith) * (X + h);\n\t\tfloat c0 = sqrt(x0);\n\n\t\treturn 2.0 * c0 * exp(X - x0) - c_exp_h / (1.0 - c * cosZenith);\n\t}\n}\n\nfloat GetOpticalDepthSchueler(float h, float H, float earthRadius, float cosZenith)\n{\n\treturn H * ChapmanApproximation(earthRadius / H, h / H, cosZenith);\n}\n\nfloat3 GetTransmittance(ScatteringParams setting, float3 L, float3 V)\n{\n\tfloat ch = GetOpticalDepthSchueler(L.y, setting.rayleighHeight, setting.earthRadius, V.y);\n\treturn exp(-(setting.waveLambdaMie + setting.waveLambdaRayleigh) * ch);\n}\n\nfloat2 ComputeOpticalDepth(ScatteringParams setting, float3 samplePoint, float3 V, float3 L, float neg)\n{\n\tfloat rl = length(samplePoint);\n\tfloat h = rl - setting.earthRadius;\n\tfloat3 r = samplePoint / rl;\n\n\tfloat cos_chi_sun = dot(r, L);\n\tfloat cos_chi_ray = dot(r, V * neg);\n\n\tfloat opticalDepthSun = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_sun);\n\tfloat opticalDepthCamera = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_ray) * neg;\n\n\treturn float2(opticalDepthSun, opticalDepthCamera);\n}\n\nvoid AerialPerspective(ScatteringParams setting, float3 start, float3 end, float3 V, float3 L, bool infinite, out float3 transmittance, out float3 insctrMie, out float3 insctrRayleigh)\n{\n\tfloat inf_neg = infinite ? 1.0 : -1.0;\n\n\tfloat3 sampleStep = (end - start) / float(SAMPLES_NUMS);\n\tfloat3 samplePoint = end - sampleStep;\n\tfloat3 sampleLambda = setting.waveLambdaMie + setting.waveLambdaRayleigh + setting.waveLambdaOzone;\n\n\tfloat sampleLength = length(sampleStep);\n\n\tfloat3 scattering = float3(0.0);\n\tfloat2 lastOpticalDepth = ComputeOpticalDepth(setting, end, V, L, inf_neg);\n\n\tfor (int i = 1; i < SAMPLES_NUMS; i++, samplePoint -= sampleStep)\n\t{\n\t\tfloat2 opticalDepth = ComputeOpticalDepth(setting, samplePoint, V, L, inf_neg);\n\n\t\tfloat3 segment_s = exp(-sampleLambda * (opticalDepth.x + lastOpticalDepth.x));\n\t\tfloat3 segment_t = exp(-sampleLambda * (opticalDepth.y - lastOpticalDepth.y));\n\t\t\n\t\ttransmittance *= segment_t;\n\t\t\n\t\tscattering = scattering * segment_t;\n\t\tscattering += exp(-(length(samplePoint) - setting.earthRadius) / setting.rayleighHeight) * segment_s;\n\n\t\tlastOpticalDepth = opticalDepth;\n\t}\n\n\tinsctrMie = scattering * setting.waveLambdaMie * sampleLength;\n\tinsctrRayleigh = scattering * setting.waveLambdaRayleigh * sampleLength;\n}\n\nfloat ComputeSkyboxChapman(ScatteringParams setting, float3 eye, float3 V, float3 L, out float3 transmittance, out float3 insctrMie, out float3 insctrRayleigh)\n{\n\tbool neg = true;\n\n\tfloat2 outerIntersections = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthAtmTopRadius);\n\tif (outerIntersections.y < 0.0) return 0.0;\n\n\tfloat2 innerIntersections = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthRadius);\n\tif (innerIntersections.x > 0.0)\n\t{\n\t\tneg = false;\n\t\touterIntersections.y = innerIntersections.x;\n\t}\n\n\teye -= setting.earthCenter;\n\n\tfloat3 start = eye + V * max(0.0, outerIntersections.x);\n\tfloat3 end = eye + V * outerIntersections.y;\n\n\tAerialPerspective(setting, start, end, V, L, neg, transmittance, insctrMie, insctrRayleigh);\n\n\tbool intersectionTest = innerIntersections.x < 0.0 && innerIntersections.y < 0.0;\n\treturn intersectionTest ? 1.0 : 0.0;\n}\n\nfloat4 ComputeSkyInscattering(ScatteringParams setting, float3 eye, float3 V, float3 L)\n{\n\tfloat3 insctrMie = float3(0.0);\n\tfloat3 insctrRayleigh = float3(0.0);\n\tfloat3 insctrOpticalLength = float3(1.0);\n\tfloat intersectionTest = ComputeSkyboxChapman(setting, eye, V, L, insctrOpticalLength, insctrMie, insctrRayleigh);\n\n\tfloat phaseTheta = dot(V, L);\n\tfloat phaseMie = ComputePhaseMie(phaseTheta, setting.mieG);\n\tfloat phaseRayleigh = ComputePhaseRayleigh(phaseTheta);\n\tfloat phaseNight = 1.0 - saturate(insctrOpticalLength.x * EPSILON);\n\n\tfloat3 insctrTotalMie = insctrMie * phaseMie;\n\tfloat3 insctrTotalRayleigh = insctrRayleigh * phaseRayleigh;\n\n\tfloat3 sky = (insctrTotalMie + insctrTotalRayleigh) * setting.sunRadiance;\n\n\tfloat angle = saturate((1.0 - phaseTheta) * setting.sunRadius);\n\tfloat cosAngle = cos(angle * PI * 0.5);\n\tfloat edge = ((angle >= 0.9) ? smoothstep(0.9, 1.0, angle) : 0.0);\n                         \n\tfloat3 limbDarkening = GetTransmittance(setting, -L, V);\n\tlimbDarkening *= pow(float3(cosAngle), float3(0.420, 0.503, 0.652)) * mix(vec3(1.0), float3(1.2,0.9,0.5), edge) * intersectionTest;\n\n\tsky += limbDarkening;\n\n\treturn float4(sky, phaseNight * intersectionTest);\n}\n\nfloat3 TonemapACES(float3 x)\n{\n\tconst float A = 2.51f;\n\tconst float B = 0.03f;\n\tconst float C = 2.43f;\n\tconst float D = 0.59f;\n\tconst float E = 0.14f;\n\treturn (x * (A * x + B)) / (x * (C * x + D) + E);\n}\n\nfloat noise(float2 uv)\n{\n\treturn fract(dot(sin(uv.xyx * uv.xyy * 1024.0), float3(341896.483, 891618.637, 602649.7031)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if (mouse.x == 0.0 && mouse.y == 0.0)\n        mouse = float2(0.5, 0.7);\n    \n    float3 V = ComputeSphereNormal(uv, 0.0, PI_2, 0.0, PI);\n    float3 L = ComputeSphereNormal(float2(mouse.x, mouse.y), 0.0, PI_2, 0.0, PI);\n    \n\tScatteringParams setting;\n\tsetting.sunRadius = 500.0;\n\tsetting.sunRadiance = 20.0;\n\tsetting.mieG = 0.76;\n\tsetting.mieHeight = 1200.0;\n\tsetting.rayleighHeight = 8000.0;\n\tsetting.earthRadius = 6360000.0;\n\tsetting.earthAtmTopRadius = 6420000.0;\n\tsetting.earthCenter = float3(0, -setting.earthRadius, 0);\n\tsetting.waveLambdaMie = float3(2e-7);\n    \n    // wavelength with 680nm, 550nm, 450nm\n    setting.waveLambdaRayleigh = ComputeWaveLambdaRayleigh(float3(680e-9, 550e-9, 450e-9));\n    \n    // see https://www.shadertoy.com/view/MllBR2\n\tsetting.waveLambdaOzone = float3(1.36820899679147, 3.31405330400124, 0.13601728252538) * 0.6e-6 * 2.504;\n\t\n    float3 eye = float3(0,1000.0,0);\n   \tfloat4 sky = ComputeSkyInscattering(setting, eye, V, L);\n    sky.rgb = TonemapACES(sky.rgb * 2.0);\n    sky.rgb = pow(sky.rgb, float3(1.0 / 2.2)); // gamma\n    sky.rgb += noise(uv*iTime) / 255.0; // dither\n   \n\tfragColor = float4(sky.rgb, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}