{
    "Shader": {
        "info": {
            "date": "1603553475",
            "description": "Here is something spooky for Halloween.\nUse the mouse to look around.\nI hope this brings you joy.\n\nMusic : This is Halloween - JackG 90bpm remix",
            "flags": 64,
            "hasliked": 0,
            "id": "3sGyzd",
            "likes": 22,
            "name": "Pumpkin Patch",
            "published": 3,
            "tags": [
                "ray",
                "marching",
                "iq",
                "halloween",
                "spooky",
                "pumpkin"
            ],
            "usePreview": 0,
            "username": "PixelPhil",
            "viewed": 1075
        },
        "renderpass": [
            {
                "code": "//\n// Pumpkin Patch by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n#define MAX_DST 200.0\n#define MIN_DST 0.008\n#define S(a,b,c) smoothstep(a,b,c)\n#define sat(a) clamp(a,0.0,1.0)\n#define ZERO (min(iFrame,0))\n\n//Material regions\n#define PUMPKIN_DARK \t0.0\n#define PUMPKIN \t\t1.0\n#define PUMPKIN_INSIDE\t2.0\n#define GROUND_AO\t\t3.0\n#define GROUND\t\t\t4.0\n#define STEM\t\t\t5.0\n\n//#define MODELING\n\nfloat speechHeight = 0.0;\nfloat beat = 0.0;\n\n\n// Attributes of a PBR material\nstruct PBRMat\n{\n    vec3 albedo;\n    float metalness;\n    float roughness;\n};\n\n    \nfloat spacing = 9.0;\nfloat offsetMax = 3.5;\n\n// Computes a PBR Material from material ID and world position\nvoid GetColor(float id, vec3 pos, out PBRMat mat, vec2 pumpkinCenter)\n{   \n\n\n    \n    vec3 orange = vec3(0.8, 0.3, 0.01);\n    vec3 orangeDark = vec3(0.5, 0.01, 0.01);\n    vec3 yellow = vec3(0.8, 0.8, 0.0);\n    \n    vec3 stem = vec3(0.15, 0.65, 0.02);\n    vec3 stemDark = vec3(0.05, 0.15, 0.05);\n    \n    if (id <= PUMPKIN)\n    {\n        mat = PBRMat(mix(orange, orangeDark, id), 0.15 * id, id);\n    } \n    else if (id <= GROUND)\n    {\n        \n    \n        float len = length(pos.xz - pumpkinCenter);\n\t\tfloat ao = 0.6 + 0.4 * S(0.5, 3.0, len);\n\n   \n        float noise2 = VoroNoise(pos.xz * 4.0, 1.0, 1.0);\n        vec2 band = S(vec2(0.26), vec2(0.25), abs(fract(pos.xz * 0.07 + vec2(noise2 * 0.05)) - vec2(0.5))); \n        \n        \n        mat = PBRMat(mix( vec3(0.4, 0.01, 0.4), vec3(0.3, 0.01, 0.3), band.y) * ao, 0.05, 1.0);\n    }  \n    else\n    {\n        float ratio = id - STEM;\n        \n        mat = PBRMat(mix(stemDark, stem, ratio), 0.06, 1.0);\n    }  \n  \n    return;\n}\n\n\n\nvec2 SDFPumpkin(vec3 pos, vec4 rnd)\n{  \n\n    float proxy = length(pos - vec3(0.0, 1.2, 0.0));\n    \n    if (proxy > 4.0)\n    {\n    \treturn vec2(proxy - 3.0, 0.0);\n    }\n    else   \n    {\n        \n        pos = (rotationY(rnd.z * 360.0) * vec4(pos, 1.0)).xyz;\n        \n        float bounce = sin(iTime * 10.0 + (rnd.x + rnd.a) * 234.4) * beat;\n        \n        float scX = rnd.x * 0.4 + 1.0 + bounce * 0.05;\n        float scY = rnd.w * 0.4 + 1.0 - bounce * 0.1;\n        \n        pos *= vec3(scX, scY, scX);\n        \n        pos.y -= 1.25;\n        \n    \n        \n        float angle = atan(pos.x, pos.z);\n\n\n        float section = smax(0.05, abs(sin(angle * 4.0)), 0.05) * 0.1;\n\n        float longLen = length(pos.xz);\n\n        float pinch = S(1.4, -0.2, longLen);\n\n        float pumpkin = sdEllipsoid(pos, vec3(1.7, 1.5, 1.7)) + pinch * 0.6;\n        \n        float pumpkinDisplace =  ((sin(angle * 25.0) + sin(angle * 43.0)) * 0.0015 - section) * S(0.2, 1.3, longLen);\n\n        pumpkin +=   pumpkinDisplace;\n\n        //pumpkin *= mix(1.0, 0.5, pinch);\n\n        float stem = longLen - 0.29 + S(1.1, 1.5, pos.y) * 0.15 + sin(angle * 4.0) * 0.01;\n        \n        float stemDisplace = sin(angle * 10.0);\n        \n        stem += stemDisplace * 0.005;\n\n        stem -= (pos.y - 1.2) * 0.1;\n        \n        stem *= 0.8;\n        \n        float stemCut =  pos.y - 1.6 + pos.x * 0.3;\n\n        stem = smax(stem, stemCut, 0.05);\n\n        stem = max(stem, 1.0 - pos.y);\n\n\n        float pumpkinID = clamp(pumpkinDisplace * 4.0 + 0.5, 0.0, 0.999);//, PUMPKIN_INSIDE, S(0.03, -0.05, pumpkin));\n        \n\t    float stemID = STEM + (0.5 + stemDisplace * 0.2) * S(0.1, -0.6, stemCut);\n        \n        \n        pumpkin = abs(pumpkin) - 0.05;\n\n        float face = length(pos.xy - vec2(0.0, 0.3)) - 1.1;\n        face = max(face, -(length(pos.xy - vec2(0.0, 1.8)) - 2.0));\n        \n        float teeth = abs(pos.x - 0.4) - 0.16;\n        teeth = smax(teeth, -0.45 - pos.y + pos.x * 0.1, 0.07);\n        \n        float teeth2 = abs(pos.x + 0.40) - 0.16;\n        teeth2 = smax(teeth2, 0.5 + pos.y + pos.x * 0.05, 0.07);\n        \n        \n        face = smax(face, -min(teeth, teeth2), 0.07);\n\n        vec2 symPos = pos.xy;\n        symPos.x = abs(symPos.x);\n\n        float nose = -pos.y + 0.1;\n        nose = max(nose, symPos.x - 0.25 + symPos.y* 0.5);\n\n        float eyes = -pos.y + 0.48 - symPos.x * 0.17;\n        eyes = max(eyes, symPos.x - 1.0 + symPos.y * 0.5);\n        eyes = max(eyes, -symPos.x - 0.05 + symPos.y * 0.5);\n\n\n        face = min(face, nose);\n        face = min(face, eyes);\n\n        face = max(face, pos.z);\n\n        pumpkin = smax(pumpkin, -face, 0.03);\n        \n        \n\n\n        pumpkin *= 0.9 / max(scX, scY);\n\n        vec2 res = vec2(pumpkin, pumpkinID);\n\t\tres = combineMin(res, vec2(stem, stemID));\n\n        return res;\n    }\n}\n\nfloat groundHeight(vec2 xz, bool detailed)\n{\n    float h = sin(xz.x * 0.05) * 4.0;\n    h += sin(xz.y * 0.05) * 4.0;\n    \n    h += sin(xz.y * 0.1 + xz.x * 0.2) * 0.5;\n    \n    h += sin(xz.y * 0.15 + xz.x * 0.3) * 0.3;\n   \n    \n    return h;\n}\n\nvec2 SDFPumpkinCell(vec3 pos, vec2 cellId)\n{   \n\t\n    \n    vec4 rnd = N24(cellId);\n    \n    vec2 offsetXZ = (rnd.xy - vec2(0.5)) * offsetMax;\n    \n    float ground0 = groundHeight((cellId + vec2(0.5)) * spacing + offsetXZ, false);\n    \n    vec2 pumpkin = SDFPumpkin(pos - vec3(offsetXZ.x, ground0, offsetXZ.y), rnd);\n    \n   \n    \n \n\n    return pumpkin;\n}\n\n// SDF of the scene\nvec2 SDF(vec3 pos, bool precise)\n{   \n    \n#ifdef MODELING\n    vec2 pumpkin =  SDFPumpkinCell(pos, vec2(0.0));\n#else\n\n    vec2 posxz = pos.xz / spacing;\n    \n    vec2 cellId = floor(posxz);\n    \n    \n    vec2 cellXZ = (fract(posxz) - vec2(0.5)) * spacing;\n\n    vec3 cellPos = vec3(cellXZ.x, pos.y, cellXZ.y);\n    \n    \n    // Make sure the pumpkin sits on flat ground\n    vec4 rnd = N24(cellId);\n    vec2 offsetXZ = (rnd.xy - vec2(0.5)) * offsetMax;\n    vec2 centerPumpkin = (cellId + vec2(0.5)) * spacing + offsetXZ;\n    float len = length(centerPumpkin.xy - pos.xz);\n    float ground0 = groundHeight(centerPumpkin , true);\n    float gound = pos.y - mix(ground0, groundHeight(pos.xz, true), S(1.0, 3.0, len));\n    \n    vec2 res = vec2(gound, GROUND);\n    \n    if (precise)\n    {\n        for (float z = -1.0; z <= 1.0; z++)\n        {\n            for (float x = -1.0; x <= 1.0; x++)\n            {\n\n                res = combineMin(res, SDFPumpkinCell(cellPos - vec3(x * spacing, 0.0,z * spacing), \n                                                     cellId + vec2(x, z)));\n            }\n        }\n    \t \n    }\n    else\n    {\n        res = combineMin(res, SDFPumpkinCell(cellPos, cellId));\n    }\n#endif\n    \n\n    \n    return res;\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( vec3 pos)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    \n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * SDF(pos+0.0005*e, false).x;\n    }\n    return normalize(n);\n}\n\n// inspired by\n// https://iquilezles.org/articles/rmshadows\nfloat shadow(vec3 pos, vec3 lPos)\n{   \n    vec3 dir = lPos - pos;  // Light direction & disantce\n    \n    float len = length(dir);\n    dir /= len;\t\t\t\t// It's normalized now\n    \n    pos += dir * MIN_DST * 2.0;  // Get out of the surface\n    \n    float dst = SDF(pos, false).x; // Get the SDF\n    \n    // Start casting the ray\n    float t = 0.0;\n    float obscurance = 1.0;\n    \n    while (t < len)\n    {\n        if (dst < MIN_DST) return 0.0; \n        obscurance = min(obscurance, (20.0 * dst / t)); \n        t += dst;\n        pos += dst * dir;\n        dst = SDF(pos, false).x;\n    }\n    return obscurance;     \n}\n\nfloat shadow(vec3 p, vec3 n, vec3 lPos)\n{\n    return shadow(p + n * MIN_DST * 10.0, lPos);\n}\n\n// Cast a ray across the SDF return x: Distance, y: Materila Id\nvec2 castRay(vec3 pos, vec3 dir, float maxDst, float minDst)\n{\n    vec2 dst = vec2(minDst * 2.0, 0.0);\n    \n    float t = 0.0;\n    \n    while (dst.x > minDst && t < maxDst)\n    {\n        dst = SDF(pos, true);\n        t += dst.x;\n        pos += dst.x * dir;\n    }\n    \n    return vec2(t + dst.x, dst.y);\n}\n\nvec3 cookie(vec3 camPos, vec3 camDir, vec3 cookiePos, float radius, vec3 color)\n{\n    return vec3(0.0);\n}\n\n\n// A PBR-ish lighting model\nvec3 PBRLight(vec3 pos, vec3 normal, vec3 view, PBRMat mat, vec3 lightPos, vec3 lightColor, float fresnel, bool shadows, float range)\n{\n    //Basic lambert shading stuff\n    \n    //return vec3(fresnel);\n    \n    vec3 key_Dir = lightPos - pos;\n    \n    float key_len = length(key_Dir);\n    \n    float atten = key_len / range;\n    atten = 1.0 - atten * atten;\n    if (atten < 0.0) return vec3(0.0);\n\n    \n    key_Dir /= key_len;\n    \n\n    float key_lambert = max(0.0, dot(normal, key_Dir));\n    \n     \n    float key_shadow = shadows ? S(0.0, 0.10, shadow(pos, normal, lightPos)) : 1.0; \n    \n    float diffuseRatio = key_lambert * key_shadow;\n   \n    \n    vec3 key_diffuse = vec3(diffuseRatio);\n    \n\n    // The more metalness the more present the Fresnel\n    float f = pow(fresnel + 0.5 * mat.metalness, mix(2.5, 0.5, mat.metalness));\n    \n    // metal specular color is albedo, it is white for dielectrics\n    vec3 specColor = mix(vec3(1.0), mat.albedo, mat.metalness);\n    \n    vec3 col = mat.albedo * key_diffuse * (1.0 - mat.metalness);\n    \n    // Reflection vector\n    vec3 refDir = reflect(view, normal);\n    \n    // Specular highlight (softer with roughness)\n    float key_spec = max(0.0, dot(key_Dir, refDir));\n    key_spec = pow(key_spec, 10.0 - 9.0 * mat.roughness) * key_shadow;\n    \n    float specRatio = mat.metalness * diffuseRatio;\n    \n    col += vec3(key_spec) * specColor * specRatio;\n    col *= lightColor;\n    \n\n    \n    return col * atten;\n}\n\nvec4 render(vec2 uvs)\n{\n\n#ifdef MODELING\n    vec3 camPos = vec3(0.0, 2.0, -10);\n    vec3 camDir = vec3(0.0, 0.0,  1.0);\n#else\n    \n    float z = iTime * 4.0 - 38.0;\n    \n    float y = groundHeight(vec2(0.0, z), false);\n    float yNext = groundHeight(vec2(0.0, z + 1.3), false);\n    \n    // build camera ray\n    vec3 camPos = vec3(0.0, 2.0 + y, z);\n    vec3 camDir = normalize(vec3(0.0, (yNext - y) * 0.3,  1.0));\n#endif\n    \n\n    vec3 rayDir = camDir + vec3(uvs * 0.45, 0.0);\n    \n    \n//    vec3 key_LightPos = camPos + vec3(6.0, 10.0, -5.0);  \n    \n    vec3 key_LightPos = camPos + vec3(6.0, 2.0, 5.0);\n    \t//vec3 fill_LightPos =  (modelViewMat * vec4(-15.0, -7.0, 10.0, 0.0)).xyz;\n\n\t// mouse interaction\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    if(mouse.x<.001) mouse = vec2(0.5, 0.5);\n\n    vec2 viewAngle = vec2((-mouse.x - 0.35 ) * pi2, (mouse.y - 0.54) * pi2);\n\n\n\n\t// then the viwe matrix\n    mat4 viewMat =  rotationY(viewAngle.x) * rotationX(viewAngle.y);\n\n\t// transform the ray in object space\n    rayDir = (viewMat * vec4(rayDir, 0.0)).xyz;\n\n    \n\tvec2 d = castRay(camPos, rayDir, MAX_DST, MIN_DST);\n    \n    vec3 bg = vec3(0.0, 0.0, 0.2);\n    bg.r += S( 0.25, 0.0, rayDir.y);\n    bg.g += S( 0.16, -0.1, rayDir.y);\n    \n    vec3 col;\n    \n    if (d.x < MAX_DST)\n    {\n        // if it's a hit render the face\n        \n    \tvec3 pos = camPos + rayDir * d.x;\n \t\n    \tvec3 n;\n        \n        vec2 cellId = floor(pos.xz / spacing);\n        vec4 rnd = N24(cellId);\n        vec2 offsetXZ = (rnd.xy - vec2(0.5)) * offsetMax;\n        vec2 pumpkinCenter = (cellId + vec2(0.5)) * spacing + offsetXZ;\n\n        // compute the surface material\n    \tPBRMat mat;\n    \tGetColor(d.y, pos, mat, pumpkinCenter);\n    \t\n    \tmat.albedo *= mat.albedo; // Convert albedo to linear space\n    \t\n    \tn = calcNormal(pos);\n\n    \tcol = mat.albedo * 0.2;\n    \t\n    \t// Fresnel\n    \tfloat fresnel = 1.0 - sat(dot(n, -rayDir));\n\t\n\t\n        // transform lights to object space\n        vec3 innerLight = vec3(pumpkinCenter.x, groundHeight(pumpkinCenter.xy, false)  + 1.34 ,pumpkinCenter.y);\n    \n        //innerLight += sin(vec3(iTime * fract(pumpkinCenter.xyx * vec3(45.0, 35.0,12.0))) * 10.0) * 0.05;\n        \n        // Add lighting\n    \tcol += PBRLight(pos, n, rayDir, mat, key_LightPos, vec3(1.3), fresnel, true, 120.0);\n\n        // Light from inside the pumpkin\n        //float dst = length(pumpkinCenter.xy - pos.xz) * 0.25;\n        //float lightAtten = max(0.0, (1.0 - dst * dst));\n    \tcol += PBRLight(pos, n, rayDir, mat, innerLight, vec3(8.0), fresnel, true, 4.5);// * lightAtten;\n\t\n \t\t//col *= S(0.0, 0.1, ao) * 0.5 + 0.5; // blend AO to unflatten a bit\n        \n      \tcol = mix(col, vec3(1.0), S(0.0, -20.3,pos.y));\n    \t\n    \tcol = pow(col,vec3(0.4545)); // gamma correction\n        \n        col = mix(col, bg, S(100.0, MAX_DST,d.x));\n        \n    \treturn vec4(col, 0.0);\n    }\n    \n    \n    // Background\n \tcol = bg;\n\n  \n    return vec4(col, 0.0);\n}\n\n// Classic stuff\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv =(fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    \n\n    \n    float a = textureLod(iChannel0, vec2(0.0, 0.5), 0.0).r;\n    float b = textureLod(iChannel0, vec2(0.01, 0.5), 0.0).r;\n    float c = textureLod(iChannel0, vec2(0.5, 1.0), 0.0).r;\n    \n    speechHeight =  abs(a - b);\n    beat = max(0.0, a + b + c - 1.0) * 0.5;\n    \n    vec3 res = render(uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(res.rgb,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 24205,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/iamjackg/this-is-halloween-6"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi 3.14159265359\n#define pi2 (pi * 2.0)\n#define halfPi (pi * 0.5)\n#define degToRad (pi / 180.0)\n\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat3 rotationX3( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat3(1.0, 0,\t 0,\n\t\t\t \t0, \t c,\t-s,\n\t\t\t\t0, \t s,\t c);\n}\n\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat3 rotationY3( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat3( c, 0,\t s,\n\t\t\t \t 0,\t1.0, 0,\n\t\t\t\t-s,\t0,\t c);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n\n\nvec2 combineMin(vec2 a, vec2 b)\n{\n    return (a.x < b.x)? a : b;\n}\n\n\n// Adapted from BigWIngs\nvec4 N24(vec2 t) {\n    float n = mod(t.x * 458.0 + t.y * 127.3, 100.0);\n\treturn fract(sin(n*vec4(123., 1024., 1456., 264.))*vec4(6547., 345., 8799., 1564.));\n}\n\n\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoidPrecise( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k1 = length(p/r);\n    return (k1-1.0)*min(min(r.x,r.y),r.z);\n}\n\n\n\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\n// https://iquilezles.org/articles/voronoise\nfloat VoroNoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    float k = 1.0 + 63.0*pow(1.0-v,4.0);\n    float va = 0.0;\n    float wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec3  o = hash3( p + g )*vec3(u,u,1.0);\n        vec2  r = g - f + o.xy;\n        float d = dot(r,r);\n        float w = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n        va += w*o.z;\n        wt += w;\n    }\n\n    return va/wt;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}