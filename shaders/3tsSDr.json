{
    "Shader": {
        "info": {
            "date": "1562594678",
            "description": "chaldni emulator cymatics waves wave tank. lot of possibilities with this cheap algorythm. see shader code top for details. \n\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "3tsSDr",
            "likes": 17,
            "name": "chladni emulator cymatics salt",
            "published": 3,
            "tags": [
                "symmetry",
                "chladni",
                "singularity",
                "wavecompression",
                "collapsedbaryoncompression"
            ],
            "usePreview": 0,
            "username": "henry",
            "viewed": 1138
        },
        "renderpass": [
            {
                "code": "/*five concentric waves additively, \nouter wave origins can move away from center of image for variance. \nThis was imagined to mimic the reverberations of the edges \nof a square plane of metal which is tricky to \nemulate as it uses resoncance feedback.\nThe central concentric wave is the plate shaking up and down, \nand the 4 edge waves are the waves returning from the metal plane sides.\nappears fine with 5 and 9 waves.\n\nit's a wavetank of this symmetry using salt fx. \n\n @\n@@@\n @\n\n*/ \n\n// Noise pixel size\n#define SIZE 1.0\n// Lower - more flowing\n#define FLUENCY 0.85\nfloat rand(vec2 co) { \n    return fract(sin(dot(co.xy , vec2(12.9898, 78.233))) * 43758.5453);\n} \n\nvoid mainImage(out vec4 color, vec2 UVcoords)\n{\n    \n          vec2 id = ceil(UVcoords/SIZE);    \n    vec2 rid = vec2(rand(id), rand(id+iResolution.y));    \n    color = -vec4( 0.1/fract(rid.x + rid.y - iTime * FLUENCY)-0.1)*15.0;//sparke effect\n    \n   float d3 = iResolution.y*.5 ,//number to move pic upwards\n         d4 =  iResolution.x*.5 ,//number to move pic sideways\n         d2 = 8.0 - 2.0 * sin( 5.0+iTime*.07 ) + iMouse.y*0.021, //number to move 5 wave machines outwards\n    \td1 = .5; ;// wave width\n   UVcoords = .5*(UVcoords - vec2(d4,d3)); //move pic around\n    \n    \n\t//function to make color concentric sinewaves like water drop waves radiating from a pt:   \n#define S(X, Y, period)   color += sin(length(UVcoords + vec2(X,Y)*d2)*period)-.2;\n    \n         \n    \n    \n    //if (color.x<0.0)\n  \n    \n    \n    \n    // color += sin(UVcoords.x*100.0*iTime)/6.0;\n    //  color += sin(UVcoords.y*150.0*iTime)/6.0;  \n    // sin(length()*p2)+v2\n\t//see end for full formula including angular coordinates as well as concentric\n\t//Tip: to remix the code, you can try mixing 3/4/8 \n    //wave machines in different symmetries and vary their distance and amplitudes\n  \n\n   \n//make 5 wave machines where the color is added t*d2ogether on coordinates of pentagon:\n    \n    //these dots are arranged in a + arrangement, one origin for on xy axes. \n    //central wave machine on origin\n    S(0.0,0.0,iMouse.x*0.002)\n        \n    //4 other wave machines on axes\n    S(0,1.0*d2,d1)  S(0,-1.0*d2,d1)  S(-1.0*d2,-0.0,d1)  S(1.0*d2,0.0,d1)  \n        \n        \n}\n    \n\n//NOTE: original version had concentric wave forms in this fasion:\n\n//float2 xy2 = IN.uv_MainTex + float2(-0.5, -0.5*d3 ) + float2(k1,j1)*d2; \n//position of the point\n\n//float c2 = length(xy2);//polar coordinates (x axis becomes radial)\n\n//ht+=  (sin(c2 * p2)  *v2) ;//angular coordinates (y becomes angle)\n    \n    \n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}