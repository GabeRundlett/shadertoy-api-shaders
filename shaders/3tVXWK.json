{
    "Shader": {
        "info": {
            "date": "1585433868",
            "description": "Voronoi patterns according to\nhttps://www.youtube.com/watch?v=l-07BXzNdPw\nhttps://cyangamedev.wordpress.com/2019/07/16/voronoi/",
            "flags": 0,
            "hasliked": 0,
            "id": "3tVXWK",
            "likes": 5,
            "name": "Basic voronoi with borders",
            "published": 3,
            "tags": [
                "voronoi"
            ],
            "usePreview": 0,
            "username": "maksy",
            "viewed": 395
        },
        "renderpass": [
            {
                "code": "#define S smoothstep\n\nvec2 N22(vec2 p) {\n\tvec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \t\n    // normalize coordinates ranging from -1. to 1 and fix aspect ratio\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    uv*=4.;\n    \n    // divides the screen into a grid\n    // the id of a grid cell. X and y go from -4 to 4.\n    vec2 id = floor(uv); \n    \n    // inner coordinates of a grid cell\n    vec2 gv = fract(uv);\n    \n    // ####################################\n    // # First pass\n    // ####################################\n       \n    // index of the voronoi cell containing the shading point\n    vec2 cellIndex = vec2(0.);\n    \n    // the center of the voronoi cell\n    vec2 center = vec2(0.0);\n    \n    // Distance to the center\n    float minDist = 8.;  \n    \n    // the grid cell with the closest point\n    vec2 closestGridCell = vec2(0.);\n    \n    // finds which cell contains the closest point to the shading point. \n    // Only 9 cells in the grid must looped through.\n    for (float y = -1.; y <= 1.; y++) {\n        for (float x = -1.; x <= 1.; x++) {\n            vec2 offset = vec2(x, y);\n            vec2 n = 0.5+sin(N22(id+offset) * iTime)*0.5;\n            \n            float d = length(offset+n - gv);\n            if (d < minDist) {\n                center = offset+n - gv;\n                cellIndex = id+offset;\n                minDist = d;\n                closestGridCell = offset;\n            }\n        }\n    }\n    \n    // ####################################\n    // # Second pass\n    // ####################################\n    \n    // calculates distance to the closest border\n    \n    // performs neighbor search centered at the closest cell instead of\n    // the cell that contains the shading point\n    float borderDist = 8.0;\n    for (float y = -2.; y <= 2.; y++) {\n       for (float x = -2.; x <= 2.; x++) {\n            \n           vec2 offset = closestGridCell + vec2(x, y);\n           vec2 n = 0.5+sin(N22(id+offset)*iTime)*0.5;\n           \n           vec2 r = offset + n - gv;\n           \n           // skip the same cell\n           if (dot(center-r, center-r) > .01) {            \n           \tborderDist = min(borderDist, dot(0.5*(center+r),normalize(r-center)));\n           }\n        }\n     }\n    \n    vec3 col = vec3(minDist);\n       \n    if (cellIndex.x > 3.) {\n    \tcol = vec3(0.70, 0.62, 0.85);\n    }\n    \n    else if (cellIndex.x > -1.) {\n        col = vec3(0.99, 0.64, 0.66);\n    }\n    \n    else if (cellIndex.x > -5.) {\n        col = vec3(0.47, 0.87, 0.47);\n    }\n    \n     else if (cellIndex.x > -9.) {\n        col = vec3(0.46, 0.62, 0.80);\n    }\n    \n    // edges  \n    col = mix(vec3(0.2, 0.2, 0.2), col, S(0.01, 0.06, borderDist));\n    \n    // isolines\n    col -= abs(sin(100.0*minDist))*0.1;\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}