{
    "Shader": {
        "info": {
            "date": "1631824494",
            "description": "Some shoddy workmanship.",
            "flags": 0,
            "hasliked": 0,
            "id": "fdy3z3",
            "likes": 4,
            "name": "Hexagins",
            "published": 3,
            "tags": [
                "2d",
                "hexagons",
                "myocdhatesthis"
            ],
            "usePreview": 0,
            "username": "narida",
            "viewed": 296
        },
        "renderpass": [
            {
                "code": "precision highp float;\nprecision highp int;\n\nfloat banded(float bandCount, float t) {\n  return clamp(floor(t * bandCount) / (bandCount - 1.0), 0.0, 1.0);\n}\nvec2 banded(float bandCount, vec2 t) {\n  return clamp(floor(t * bandCount) / (bandCount - 1.0), 0.0, 1.0);\n}\nvec3 banded(float bandCount, vec3 t) {\n  return clamp(floor(t * bandCount) / (bandCount - 1.0), 0.0, 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\nbool between(float min, float max, float value) {\n    return min <= value && value <= max;\n}\n\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\nvec3 unmix(float a, float b, vec3 value) {\n  return (value - a) / (b - a);\n}\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\nvec2 hex2xy(vec3 hex) {\n    float y = hex.t * 0.866;\n    float x = hex.s + hex.t / 2.0;\n    return vec2(x, y);\n}\n\n// correct the 3d coordinate of a hex coordinate.\nvec3 hexFix(vec2 hexXy) {\n    return vec3(hexXy, -(hexXy.x + hexXy.y));\n}\n\nvec3 hexRound(vec3 hex) {\n    vec3 r = floor(hex + 0.5);\n    vec3 diff = abs(r - hex);\n\n    if (diff.x > diff.y && diff.x > diff.z) {\n        r.x = -(r.y + r.z);\n    } else if (diff.y > diff.z) {\n        r.y = -(r.x + r.z);\n    } else {\n        r.z = -(r.x + r.y);\n    }\n\n    return r;\n}\n\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\nfloat min3(float a, float b, float c) {\n    return min(a, min(b, c));\n}\n\nfloat min3(vec3 a) {\n    return min(a.x, min(a.y, a.z));\n}\n\nfloat hexSdf(vec3 hex) {\n//    hex.x += 2.*hex.y/.6;\n//    hex.z = -(hex.x+hex.y);\n//    return max3(abs(hex.xyz));\n    return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\n\n// Smooth HSV to RGB conversion\nvec3 hsv2rgb_smooth_2315452051(vec3 hsv) {\n    vec3 rgb = clamp(\n    abs(mod(hsv.x*6.0+vec3(0.0, 4.0, 2.0), 6.0)-3.0)-1.0,\n    0.0, 1.0);\n\n    rgb = rgb*rgb*(3.0-2.0*rgb);// cubic smoothing\n\n    return hsv.z * mix(vec3(1.0), rgb, hsv.y);\n}\n\nconst float TAU = 6.283185307179586;\n// returns a random vector inside the unit circle\n// all points inside the circle are more likely,\n// ie. higher radiuses are more likely\nvec2 randomVector(vec2 random01) {\n    return fromPolar(sqrt(random01.x), random01.y * TAU);\n}\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nmat2 rot2d(float angleRad) {\n    float c = cos(angleRad), s = sin(angleRad);\n    return mat2(\n    c, -s,\n    s, c);\n}\n\nvec2 tri2xy(vec3 uvR) {\n    float y = uvR.t * 0.866;\n    float x = uvR.s + uvR.t / 2.0;\n    return vec2(x, y);\n}\nvec2 tri2xy(vec2 uv) {\n    float y = uv.t * 0.866;\n    float x = uv.s + uv.t / 2.0;\n    return vec2(x, y);\n}\n\nvec3 triCenter(vec3 uvR) {\n    vec3 base = floor(uvR);\n    vec2 centerOffset = mix(vec2(1./3.), vec2(2./3.), uvR.z);\n    return base + vec3(centerOffset, 0.0);\n}\n\nvec3 xy2hex(vec2 xy) {\n    float hex_t = xy.y / 0.866;\n    float hex_s = xy.x - hex_t / 2.0;\n    return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\nvec3 xy2tri(vec2 xy) {\n    float v = xy.y / 0.866;\n    float u = xy.x - v / 2.0;\n    float R = float(fract(u) + fract(v) > 1.0);\n    return vec3(u, v, R);\n}\n\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n\nuvec2 pcg(uvec2 v) {\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v >> 16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v >> 16u);\n\n    return v;\n}\n\n// pcg3d renamed for overload\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\nvec3 pcgf(out uvec3 v) {\n    v = pcg(v);\n    return vec3(v) / float(0xffffffffu);\n}\n\nvec4 linRgbColor(vec4 sRgbColor) {\n    return vec4(pow(sRgbColor.xyz, vec3(2.2)), sRgbColor.w);\n}\n\nvec4 getColorAt(ivec2 pos) {\n    uvec2 upos = uvec2(pos);\n\n    uvec3 rnd = uvec3(upos, upos.x ^ upos.y);\n    rnd = pcg(rnd);\n    rnd = pcg(rnd);\n    vec3 rndf = vec3(rnd) / float(0xffffffffu);\n    vec4 color = black;\n    //    color.xyz = rndf;\n    float s = .6;\n    //    float s = mix(.5, .7, color.y);\n    color.xyz = hsv2rgb_smooth_2315452051(vec3(rndf.x, s, 1.));\n    //        color.xyz = vec3(rndf.x);\n    color = linRgbColor(color);\n    //        return rnd.x>>31 == 0u ? black:white;\n    return color;\n}\n\nfloat calculateHexFalloff(float x) {\n    //        return  smoothstep(.3, .4, x);\n    return smoothstep(.520, .530, x);\n    //        return banded(5., smoothstep(a, a+.3, x));\n    //    return escalator(3., smoothstep(.4, .6, x), highResTimeStamp*.0001);\n}\n\nvec4 mix3(float s, float t, float u, vec4 a, vec4 b, vec4 c) {\n    return (a * s + b * t + c * u) / (s + t + u);\n}\n\nvec4 blend(vec4 source, vec4 dest) {\n    return source + dest * (1. - source.w);\n}\n\nvoid sortLayers2(out ivec2 a, out ivec2 b) {\n    if (a.x > b.x) {\n        ivec2 tmp = b; b = a; a = tmp;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 scaledCoord = fragCoord / min(iResolution.x, iResolution.y);\n    //    scaledCoord = mix(vec2(-1.), vec2(1.), scaledCoord);\n    scaledCoord *= 22.;\n    scaledCoord += iTime * normalize(vec2(100., 1.)) * 2.;\n\n    // UNIT GRID\n    vec2 unitGridDistances = scaledCoord - round(scaledCoord);\n    if (abs(unitGridDistances.x) < .01 || abs(unitGridDistances.y) < .01) {\n        fragColor = vec4(scaledCoord, 0., 1.);\n        //        return;\n    }\n\n    // TRIANGLE CENTER CIRCLES\n    vec3 tri = xy2tri(scaledCoord);\n    vec3 triTriangleCenter = triCenter(tri);\n    vec2 xyTriangleCenter = tri2xy(triTriangleCenter);\n    if (distance(xyTriangleCenter, scaledCoord) <.1) {\n        fragColor = black;\n        //                return;\n    }\n    vec3 triFract = fract(tri);\n    // TRIANGLE GRID\n    float w = .01;\n    if (abs(triFract.x-.5) > .5-w\n    || abs(triFract.y-.5) > .5-w\n    || abs(triFract.x + triFract.y - 1.) <w) {\n        fragColor = black;\n        //                        return;\n    }\n\n    // RENDER HEXAGONS\n    // As hexagons can potentially overlap each other, we cannot just calculate the nearest hexagon center and get the\n    // distance from that. Instead, we use the fact that each corner of a hex touches at most 3 triangles. Each corner\n    // of a hex matches the center of a triangle in a triangle grid (see above).\n    // For every triangle, we calculate the nearest three hex centers, and calculate the color of that hex and the\n    // distance to it.\n\n    // Depending on if we are in a up or down triangle, the offsets are differnt.\n    // Mobile browsers do NOT like vec2[3]:\n    // vec2[3] offsets = vec2[3](vec2(1, 0), vec2(0, 1), mix(vec2(0), vec2(1), tri.z));\n    mat3x2 offsets = mat3x2(vec2(1, 0), vec2(0, 1), mix(vec2(0), vec2(1), tri.z));\n    vec4[3] colors;\n    ivec2[3] order; // (z-index, i)\n    for (int i = 0; i < 3; i++) {\n        vec3 hexHexagonCenter = hexFix(floor(tri.xy) + offsets[i]);\n        vec2 xyHexagonCenter = hex2xy(hexHexagonCenter);\n        vec2 xyDiff = scaledCoord - xyHexagonCenter;\n        vec4 c = getColorAt(ivec2(hexHexagonCenter));\n        uvec2 upos = uvec2(ivec2(hexHexagonCenter));\n        uvec3 rnd = uvec3(upos, upos.x^upos.y);\n        vec3 rndf = pcgf(rnd);\n        // Calculate a smaller random int, so we can trigger random effects on specific values.\n        uint rndx = rnd.x >> 22;\n        //                uint rndx = rnd.x >> 28;\n        if (rndx == 7u) {\n            // angle wrong\n            xyDiff.xy *= rot2d(rndf.y);\n        }\n        if (rndx == 3u) {\n            // wrong position\n            xyDiff += .2*randomVector(rndf.yz);\n        }\n        if (rndx == 2u) {\n            // grayscale\n            c.xyz = c.xxx;\n        }\n        float d = hexSdf(xy2hex(xyDiff));\n\n        if (rndx == 4u) {\n            // wrong size\n            d += mix(-.15, .15, rndf.y);\n        }\n        if (rndx == 5u) {\n            // wrong shape: circle\n            d = length(xyDiff)*.9;\n        }\n        if (rndx == 6u) {\n            // wrong shape: square\n            d = max(abs(xyDiff.x), abs(xyDiff.y));\n        }\n        colors[i] = c*(calculateHexFalloff(1.-d));\n        order[i] = ivec2(hexHexagonCenter.x  + hexHexagonCenter.y*1000., i);\n    }\n\n    // Sort the hexagons into a consistent order, so there are no discontinuities at the triangle borders.\n    sortLayers2(order[0], order[1]);\n    sortLayers2(order[1], order[2]);\n    sortLayers2(order[0], order[1]);\n\n    // Blend colors together according to sorted order.\n    fragColor = black;\n    for (int i = 0; i < 3; i++) {\n        int j = order[i].y;\n        fragColor = blend(colors[j], fragColor);\n    }\n\n    // gamma correction\n    fragColor = vec4(pow(fragColor.xyz, vec3(1.0/2.2)), 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}