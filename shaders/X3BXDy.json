{
    "Shader": {
        "info": {
            "date": "1710989671",
            "description": " This uses 2 stochastic taps + temporal accumulation to get a sinc like zoom filter, I wanted it to replace a 5 tap bicubic.\n\nDefaults to round mode but you can toggle sharper mode that more closely resembles catmul rom\n\n(it was 3 tap originally)",
            "flags": 32,
            "hasliked": 0,
            "id": "X3BXDy",
            "likes": 3,
            "name": "2 tap stochastic sinc",
            "published": 3,
            "tags": [
                "stochastic",
                "taa",
                "sinc"
            ],
            "usePreview": 0,
            "username": "Dain",
            "viewed": 161
        },
        "renderpass": [
            {
                "code": "/*\n    buffer A contains the code\n\n    Started from  https://www.shadertoy.com/view/flVGRd though not much is left as that was lancoz\n    \n    \n    I wanted a texture sampler to use when zooming in on the most detailed mip, \n    previously I was using a 5 tap bicubic variant, but was rather slow( + .5 milliseconds over bilinear)\n    \n    This is a 2 tap sinc along a 1D axis, each frame it picks a random uniformly distributed rotation for the axis.\n    It also jitters the center point by .5 pixels, this jitter is also uniformly distrubted in a circle,  which is then reshaped as a diamond\n    \n    It has a pretty strong sharpening, and rounds pixels off rather than squaring \n    \n\n    \n\n    This has the advantage that if you aren't zooming in you can just skip the extra taps, and random offset, and get standard bilinear\n    \n    Performance wise it is about half way between 5 tap bicubic and bilinear.\n    \n    Because it is stocastic you probably need TAA ( as this shader is using)\n    \n    \n    NOTE: holding left mouse shows bilinear and resets the TAA sample count\n    NOTE: if you change the texture it is zooming in on, you need to click on the window to make it reset\n    NOTE: if you want to see it without TAA pause and reset time to 0\n    \n       \n \n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;   \n    vec3 col = texture(iChannel2, uv).rgb;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n    \n/*\n\n     I don't think this can be done with 1 sample as you need a negative lobe, \n     but then again.. perhaps with some ddx/ddy tricks you could get a neighboring texel to supply a negative lobe value..\n    \n     The 5 and 7 tap versions also looked good but too expensive\n     \n     Desmos graph for sinc https://www.desmos.com/calculator/uevfqvn9e4\n     \n     Desmos for shaping: https://www.desmos.com/calculator/d25hrvathn\n    \n    \n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI    3.1415926535897932384626433\n#define SCALE .05 // Scale of image\n#define USE_2_TAPS 2          //I updated this it now looks more or less the same as the 3 tap version\n/*\n    buffer A contains the code\n\n    Started from  https://www.shadertoy.com/view/flVGRd though not much is left as that was lancoz\n    \n    \n    I wanted a texture sampler to use when zooming in on the most detailed mip, \n    previously I was using a 5 tap bicubic variant, but was rather slow( + .5 milliseconds over bilinear)\n    \n    This is a 2 tap sinc along a 1D axis, each frame it picks a random uniformly distributed rotation for the axis.\n    It also jitters the center point by .5 pixels, this jitter is also uniformly distrubted in a circle,  which is then reshaped as a diamond\n    \n    It has a pretty strong sharpening, and rounds pixels off rather than squaring \n    \n\n    \n\n    This has the advantage that if you aren't zooming in you can just skip the extra taps, and random offset, and get standard bilinear\n    \n    Performance wise it is about half way between 5 tap bicubic and bilinear.\n    \n    Because it is stocastic you probably need TAA ( as this shader is using)\n    \n    \n    NOTE: holding left mouse shows bilinear and resets the TAA sample count\n    NOTE: if you change the texture it is zooming in on, you need to click on the window to make it reset\n    NOTE: if you want to see it without TAA pause and reset time to 0\n    \n       \n \n*/\n\n\nvec2 MakeTriangularFilter(vec2 a) {\n\tvec2 v = 1.0 - sqrt(1.0 - abs(a));\n    return v*sign(a);\n}\n// Inverse CDF sampling for a tent / bilinear kernel. Followed by rounding - nearest-neighbor box kernel,\n// UV jittering this way produces a biquadratic B-Spline kernel.\n// See the paper for the explanation: https://research.nvidia.com/labs/rtr/publication/pharr2024stochtex/\nvec2 bilin_inverse_cdf_sample(vec2 x) {\n    x = x*.5 + .5;\n    return mix(1.0 - sqrt(2.0 - 2.0 * x), -1.0 + sqrt(2.0 * x), step(x, vec2(0.5)));\n}\n\n//jitter UV over time\nvec2 offsetUV(vec2 uv){\n    return uv + sin(vec2(287.0,417.0)*iTime);\n}\n\nvec2 AngleToPointOnUnitCircle(float a){\n    float k = a*PI*2.0;\n    return vec2(sin(k), cos(k));\n}\n\n//triangle shaped version of sin(wants unit input)\nfloat TriSin(float x){\n    x = x+.25;\n    return abs(x - round(x))*4.0-1.0;\n}\nfloat TriCos(float x){\n    x = x+.5;\n    return abs(x - round(x))*4.0-1.0;\n}\nvec2 AngleToPointOnUnitDiamond(float a){\n    return vec2(TriSin(a), TriCos(a));\n}\n\nvec2 SqrKeepSgn(vec2 s){\n    return abs(s)*s;\n\n}\nvec2 SqrLength(vec2 s){\n    float l = length(s)/sqrt(2.0);\n    return s*l*l;\n}\nfloat Sinc(float x){\nreturn sin(x*PI)/(PI*x);\n}\nfloat SincAA(float x){\nreturn pow(1.0-x*x,2.0);\n}\nfloat SincAA2(float x){\n  return 1.0-pow(x,4.0);\n//return 1.0-x*x*x;\n}\n\nfloat bilin_inverse_cdf_sample1(float x) {\n\n   return bilin_inverse_cdf_sample(vec2(x,x)*2.0-1.0).x;\n}\nvec3 SampleTexture2D_SincStochastic (sampler2D sampler, vec2 coord) {\n    vec2 res    = vec2(textureSize(sampler, 0));\n   \n    //need 2 or 3(depends on method) random values between 0 and 1, used for angle on circle\n    vec3 rand01 =  texture(iChannel1,offsetUV(coord/SCALE)).rgb;\n \n    //our axis for this run\n    vec2 axis =AngleToPointOnUnitCircle(rand01.x)/res;\n     \n\n    //half pixel random offset(diamond shape)\n //   vec2 cc = coord+ MakeTriangularFilter(AngleToPointOnUnitCircle(rand01.y))/res*.5;\n  //  vec2 cc = coord+ bilin_inverse_cdf_sample(AngleToPointOnUnitCircle(rand01.y))/res*.5;\n     \n    //Direct diamond without going through sin/cos/filter etc. About 99% identical shape\n  //  vec2 cc = coord+ (AngleToPointOnUnitDiamond(rand01.y))/res*.5;\n   \n    //circle variant(no diamond shape)\n    //vec2 cc = coord+ (AngleToPointOnUnitCircle(rand01.y))/res*.5*(1.0/sqrt(2.0));\n      \n    \n    //other variants of random offset that require a 3rd random variable\n    //vec2 cc = coord+ rand01.z*(AngleToPointOnUnitCircle(rand01.y))/res*.5;\n    //vec2 cc = coord+ MakeTriangularFilter(rand01.z*AngleToPointOnUnitCircle(rand01.y))/res*.5;\n //   vec2 cc = coord+ rand01.z*MakeTriangularFilter(AngleToPointOnUnitCircle(rand01.y))/res*.5;\n  //  vec2 cc = coord+ bilin_inverse_cdf_sample(AngleToPointOnUnitCircle(rand01.y)*rand01.z)/res*.5;\n    \n  //  vec2 cc = coord+ bilin_inverse_cdf_sample(rand01.yz*2.0-1.0)/res*.5;//sharper but can overexagerate diagnals..\n //   vec2 cc = coord+ (rand01.yz*2.0-1.0)/res*.5;                        //rounder\n    \n    //   vec2 cc = coord+ (normalize(rand01.yz*2.0-1.0))/res*.5; \n  //  vec2 cc = coord+ bilin_inverse_cdf_sample(normalize(rand01.yz*2.0-1.0))/res*.5; \n   // vec2 cc = coord + AngleToPointOnUnitCircle(rand01.y)/res*.5*sqrt(rand01.y);\n   //  vec2 cc = coord + bilin_inverse_cdf_sample(axis*sqrt(rand01.y))*.5;\n   //  vec2 cc = coord + axis*.5*sqrt(rand01.y);\n     \n    //  vec2 cc = coord + (axis*.5*(1.0-pow(rand01.y,2.0)));\n      \n        vec2 cc = coord + (axis*SincAA2(rand01.y)*.5);\n      // vec2 cc = coord + axis*.5*sqrt(rand01.y);;\n       \n    //weight and offset for first negative lobe of sinc\n    const float w1 = -.217;\n    const float w1_offset = 1.43;\n    const float normalizeW = 1.0/(1.0 +w1 + w1);\n\n    //center positive lobe\n    vec3 s0= texture(sampler,cc).rgb;  \n\n    //left and right negative lobes\n    vec3 s1= texture(sampler,(cc+axis*w1_offset)).rgb;\n    vec3 q1= texture(sampler,(cc-axis*w1_offset)).rgb;\n    \n #if USE_2_TAPS == 1\n    s1 = q1;\n #endif\n \n    return (  s0 + s1*w1 + q1*w1)*normalizeW;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 coord = fragCoord / vec2(textureSize(iChannel0, 0)) * SCALE;\n\n    vec3 col = SampleTexture2D_SincStochastic(iChannel0, coord);\n \n    vec4 TAAHistory = texture(iChannel3, uv).rgba;\n   \n    //track your sample count heathen\n    float sampleCount = TAAHistory.a*255.0 + 1.0;\n   \n    if (iMouse.z > 0.5)//bilinear when left mouse held + TAA sample count reset to 1\n    {\n       sampleCount = 1.0;\n       col = texture(iChannel0, coord).rgb;\n    }\n \n    col = mix(TAAHistory.rgb, col, 1.0/sampleCount);\n\n    fragColor = vec4(col,sampleCount/255.0);\n}\n\n/*\n\n     I tried a 2 tap verison, it works ok, but much less sharp\n        \n     I don't think this can be done with 1 sample as you need a negative lobe, \n     but then again.. perhaps with some ddx/ddy tricks you could get a neighboring texel to supply a negative lobe value..\n    \n     The 5 and 7 tap versions also looked good but too expensive\n     \n      Desmos graph for sinc https://www.desmos.com/calculator/uevfqvn9e4\n     \n      Desmos for shaping: https://www.desmos.com/calculator/0j0oixdcsf\n    \n    \n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}