{
    "Shader": {
        "info": {
            "date": "1722692955",
            "description": "https://glslsandbox.com/e#103073.0 https://glslsandbox.com/e#104126.0",
            "flags": 0,
            "hasliked": 0,
            "id": "MfBcR3",
            "likes": 4,
            "name": " colorful stars",
            "published": 3,
            "tags": [
                "fractal",
                "star"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 120
        },
        "renderpass": [
            {
                "code": "\n\nuniform float exposure;\nuniform vec3 color;\nuniform float speed;\nuniform float seed;\n\n#define Hash1(t) fract(sin(t*785.587)*124.421)\n\n#define Rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nconst int num = 33;\nconst float ITERATIONS = 6.;\nconst float TARGET_EXP = 5.e-2;\nconst vec3 COLOR = vec3(0.7,0.4,0.1);\n#define time iTime\n#define resolution iResolution.xy\n\nvec2 rotz(in vec2 p, float ang) { return vec2(p.x*cos(ang)-p.y*sin(ang),p.x*sin(ang)+p.y*cos(ang)); }\n#define PI 3.14159265\n\nfloat pointLight(vec2 pos, vec2 uv, float ra, float spa ,float r){\n\tfloat color = 0.;\n\tfloat d = radians(mod(-spa,90.));\n\tfloat a = radians(mod(ra,360.));\n\t\n\tmat2 rot = mat2(\n\t\tsin(a),cos(a),\n\t\t-cos(a),sin(a)\n\t);\n\t\n\tvec2 pj = uv*rot;\n\t\n\tvec2 ppj = pos*rot;\n\t\n\tcolor += clamp((-d+asin(((pj.x-ppj.x)/distance(pj,ppj)))) / (PI/2.),0.,1.) ;\n\tcolor *= clamp(1.-distance(pj/r,ppj/r),0.,1.);\n\t\n\treturn color;\n}\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( gl_FragCoord.xy - 0.5 * resolution.xy ) / resolution.y;\nvec2 uv2 = ( gl_FragCoord.xy / resolution.xy );\n\tuv2=uv*23.-1.;\n\tuv2.x*=resolution.x/resolution.y;\n\tfloat col = 0.;\n\tfloat tc = floor(time+1.);\n\t\n\tfor(float i = 0.; i < ITERATIONS; i++)\n\t{\n\t\tfloat ii = i+10.;\n\t\tfloat it = ii/ITERATIONS;\n\t\tuv *= Rot(radians((ii*Hash1(tc*ii))*450.));\n\t\n\t\tfloat b = 1.-smoothstep(.0,mix(0.4,0.,fract(time)*it),length(uv.y));\n\t\tfloat l = mix(TARGET_EXP,0.,fract(time));\n\t\t\n\t\tcol += (l/length(abs(uv.y+uv.x)))*b;\n\t}\n\t\n\tcol /= ITERATIONS;\n    \n\n\t\n\tvec2 light = vec2(-1,0);\n\tmat2 rot = mat2(\n\t\tsin(time*sin(length(uv*PI))),cos(time*sin(length(uv*PI))),\n\t\t-cos(time*sin(length(uv*PI))),sin(time*sin(length(uv*PI)))\n\t);\n\n\tvec3 color = vec3(.0);\n\t\n\tfloat d = PI/6.;\n\t\t\n\t//color += clamp((-d+asin(((uv.x-light.x)/distance(uv,light)))) / (PI/2.),0.,1.) *vec3(1,2,3);\n\t\n\t//color += pointLight(m, uv, m.x*360., m.y*360. ,sin(time)*2.)*vec3(.5,.5,1)*2.;\n\t\n\tcolor.r += pointLight(vec2(sin(0.),cos(PI)), uv,0., 90.,1.9);\n\tcolor.g += pointLight(vec2(-sin(PI/3.),cos(PI/3.)), uv,120., 90.,1.9);\n\tcolor.b += pointLight(vec2(sin(PI/3.),cos(PI/3.)), uv,-120., 90.,1.9);\n\t\n\tcolor *= clamp(1.-distance(uv,vec2(0)),0.,1.)*2.;\nfloat sum = 0.;\n    float size = resolution.x / 2000.0;\n    for (int i = 0; i < num; ++i) {\n        vec2 position = resolution / 2.0;\n\tfloat t = (float(i) + time) / 5.0;\n\tfloat c = float(i) * 4.0;\n        position.x += cos(2.0 * t + c) * resolution.x * .2;\n        position.y += sin(t) * resolution.y * 0.5;\n\n        sum += size / length(gl_FragCoord.xy - position)*color.x;\n    }\n    vec2 p = 1.0*( gl_FragCoord.xy / resolution.xy )-1.0; \n\tp.x *= resolution.x/resolution.y; \t\n\tvec3 col3 = vec3(-2.4); \nfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(p.xy) + .07)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n    \n\tp.y = abs(p.y);\n\t\n\tp = rotz(p, time*0.35+atan(p.y,p.x)*6.28);\n\tp *= 0.1+sin(time*0.5); \n\n\t\n\tfor(float i = 0.; i < ITERATIONS; i++)\n\t{\n\t\tfloat ii = i+1.;\n\t\tfloat it = ii/ITERATIONS;\n\t\tuv *= Rot(radians((ii*Hash1(tc*ii))*45.));\n\t\n\t\tfloat b = 1.-smoothstep(.0,mix(0.4,0.,fract(time)*it),length(uv.y));\n\t\tfloat l = mix(TARGET_EXP,0.,fract(time));\n\t\t\n\t\tcol += (l/length(abs(uv.x)))*b;\n\t}\n\t\n\tcol /= ITERATIONS;\n  \n\tfragColor = vec4( vec3( col*COLOR+color ), 1.0 );\nfragColor*=vec4(color,1.);\nfragColor *= vec4(sum * 2.1, sum * 1.5, sum*1.9, 1);\n vec2 uv5 = gl_FragCoord.xy / resolution.xy;\n    uv5 -= 0.5;\n    uv5 /= vec2(resolution.y / resolution.x, 1.0);\n\n    float angle = atan(uv5.y, uv5.x) + time * 0.5;\n    float radius = length(uv5);\n    float swirl = sin(radius * 10.0 - time * 3.0) * 0.5 + 0.5;\n\n    float hue = fract(angle / (2.0 * 3.141592) + swirl);\n    float saturation = 1.0 - radius;\n    float value = swirl;\n\n    vec3 color3 = hsv2rgb(vec3(hue, saturation, value));\n    fragColor+= vec4(color3, 1.0);\n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor*= vec4(happy_star(uv, anim) * vec3(0.35,0.2,0.85)*1., 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}