{
    "Shader": {
        "info": {
            "date": "1542301609",
            "description": "Self-healing voronoi particles are advected by my trusty fluid algorithm.\nReally crazy transition to full screen...",
            "flags": 96,
            "hasliked": 0,
            "id": "MlVfDR",
            "likes": 220,
            "name": "Fluid Mosaic",
            "published": 3,
            "tags": [
                "voronoi",
                "fluid"
            ],
            "usePreview": 0,
            "username": "wyatt",
            "viewed": 11740
        },
        "renderpass": [
            {
                "code": "// concept for voronoi tracking from user stb\n//Render particles\nvec2 R;\nvec4 T ( vec2 U ) {return texture(iChannel0,U/R);}\nvec4 P ( vec2 U ) {return texture(iChannel1,U/R);}\nvoid mainImage( out vec4 C, in vec2 U )\n{\tR = iResolution.xy;\n    C = P(U);\n\tvec2 \n        n = P(U+vec2(0,1)).xy,\n        e = P(U+vec2(1,0)).xy,\n        s = P(U-vec2(0,1)).xy,\n        w = P(U-vec2(1,0)).xy;\n \tfloat d = (length(n-C.xy)-1.+\n        length(e-C.xy)-1.+\n        length(s-C.xy)-1.+\n        length(w-C.xy)-1.);\n \tfloat m1 = 2.*texture(iChannel2,vec2(abs(0.3*C.w),0.)).x,\n \t      m2 = 1.5*texture(iChannel2,vec2(abs(0.3*C.z),0.)).x;\n \tfloat p = smoothstep(2.5,2.,length(C.xy-U));\n \tC = 0.5-0.5*sin(.2*(1.+m1)*C.z*vec4(1)+.4*(3.+m2)*C.w*vec4(1,3,5,4));\n\n \tC *= 1.-clamp(.1*d,0.,1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 16675,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/symphonicsamples/cornfield-chase-hans-zimmer-midi-mockup"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Fluid Algorithm  https://www.shadertoy.com/view/MtdBDB\nvec2 R;float N;\nvec4 T ( vec2 U ) {return texture(iChannel0,U/R);}\nfloat X (vec2 U0, vec2 U, vec2 U1, inout vec4 Q, in vec2 r) {\n    vec2 V = U + r, u = T(V).xy,\n         V0 = V - u,\n         V1 = V + u;\n    float P = T (V0).z, rr = length(r);\n    Q.xy -= r*(P-Q.z)/rr/N;\n    return (0.5*(length(V0-U0)-length(V1-U1))+P)/N;\n}\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nvoid mainImage( out vec4 Q, in vec2 U )\n{   R = iResolution.xy;\n \tvec2 U0 = U - T(U).xy,\n         U1 = U + T(U).xy;\n \tfloat P = 0.; Q = T(U0);\n \tN = 4.;\n    P += X (U0,U,U1,Q, vec2( 1, 0) );\n \tP += X (U0,U,U1,Q, vec2( 0,-1) );\n \tP += X (U0,U,U1,Q, vec2(-1, 0) );\n \tP += X (U0,U,U1,Q, vec2( 0, 1) );\n \tQ.z = P;\n \tif (iFrame < 1) Q = vec4(0);\n    if (U.x < 1.||U.y < 1.||R.x-U.x < 1.||R.y-U.y < 1.) Q.xy *= 0.;\n \t\n \tif (length(U-vec2(0.1,0.5)*R) < .03*R.y) \n        Q.xy= Q.xy*.9+.1*vec2(.5,-.3);\n \tif (length(U-vec2(0.7,0.3)*R) < .03*R.y) \n        Q.xy= Q.xy*.9+.1*vec2(-.6,.3);\n \tif (length(U-vec2(0.2,0.2)*R) < .03*R.y) \n        Q.xy= Q.xy*.9+.1*vec2(.4,.6);\n \tif (length(U-vec2(0.7,0.5)*R) < .03*R.y) \n        Q.xy= Q.xy*.9+.1*vec2(-.1,-.3);\n \tif (length(U-vec2(0.5,0.6)*R) < .03*R.y) \n        Q.xy= Q.xy*.9+.1*vec2(0,-.7);\n    \n \tvec4 mo = texture(iChannel2,vec2(0));\n \tfloat l = ln(U,mo.xy,mo.zw);\n \tif (mo.z > 0. && l < 10.) Q.xyz += vec3((10.-l)*(mo.xy-mo.zw)/R.y,(10.-l)*(length(mo.xy-mo.zw)/R.y)*0.02);\n \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Voronoi based particle tracking\n\nvec2 R;float N;\nvec4 T ( vec2 U ) {return texture(iChannel0,U/R);}\nvec4 P ( vec2 U ) {return texture(iChannel1,U/R);}\nvoid swap (vec2 U, inout vec4 Q, vec2 u) {\n    vec4 p = P(U+u);\n    float dl = length(U-Q.xy) - length(U-p.xy);\n    float e = .1;\n    // allows for probabistic reproduction\n    Q = mix(Q,p,0.5+0.5*sign(floor(1e5*dl)));//the value next to dl adjusts the proabability of reproduction\n    \n    //uncomment and comment the line above to make it not self healing \n    //Q = mix(Q,p,dl>0.?1.:0.);\n}\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nvoid mainImage( out vec4 Q, in vec2 U )\n{   R = iResolution.xy;\n \t// go back through the fluid and test the neighbors\n \t//  for the closes particles\n \tU = U-T(U).xy;\n \tQ = P(U);\n \tswap(U,Q,vec2(1,0));\n \tswap(U,Q,vec2(0,1));\n \tswap(U,Q,vec2(0,-1));\n \tswap(U,Q,vec2(-1,0));\n \n \t\n \t// add color from the jets in the fluid\n \tif ((length(Q.xy-vec2(0.1,0.5)*R) < .02*R.y))\n        Q.zw = vec2(1,1);\n    if ((length(Q.xy-vec2(0.7,0.3)*R) < .02*R.y))\n        Q.zw = vec2(3,3);\n    if ((length(Q.xy-vec2(0.2,0.2)*R) < .02*R.y))\n        Q.zw = vec2(6,5);\n \tif (length(Q.xy-vec2(0.7,0.5)*R) < .02*R.y)\n        Q.zw = vec2(2,7);\n \tif (length(Q.xy-vec2(0.5,0.6)*R) < .02*R.y) \n        Q.zw = vec2(5,4);\n \tvec4 mo = texture(iChannel2,vec2(0));\n \tif (mo.z > 0. && ln(U,mo.xy,mo.zw) < 10.) Q = vec4(U,1,3.*sin(.4*iTime));\n \n \t// advect this particle with the fluid\n \tQ.xy = Q.xy + T(Q.xy).xy;\n \tif (iFrame < 1) Q = vec4(floor(U/10.+0.5)*10.,0.2,-.1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// keep track of mouse\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 p = texture(iChannel0,fragCoord/iResolution.xy);\n    if (iMouse.z>0.) {\n        if (p.z>0.) fragColor =  vec4(iMouse.xy,p.xy);\n    \telse fragColor =  vec4(iMouse.xy,iMouse.xy);\n    }\n    else fragColor = vec4(-iResolution.xy,-iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Fluid Algorithm  https://www.shadertoy.com/view/MtdBDB\nvec2 R;float N;\nvec4 T ( vec2 U ) {return texture(iChannel0,U/R);}\nfloat X (vec2 U0, vec2 U, vec2 U1, inout vec4 Q, in vec2 r) {\n    vec2 V = U + r, u = T(V).xy,\n         V0 = V - u,\n         V1 = V + u;\n    float P = T (V0).z, rr = length(r);\n    Q.xy -= r*(P-Q.z)/rr/N;\n    return (0.5*(length(V0-U0)-length(V1-U1))+P)/N;\n}\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nvoid mainImage( out vec4 Q, in vec2 U )\n{   R = iResolution.xy;\n \tvec2 U0 = U - T(U).xy,\n         U1 = U + T(U).xy;\n \tfloat P = 0.; Q = T(U0);\n \tN = 4.;\n    P += X (U0,U,U1,Q, vec2( 1, 0) );\n \tP += X (U0,U,U1,Q, vec2( 0,-1) );\n \tP += X (U0,U,U1,Q, vec2(-1, 0) );\n \tP += X (U0,U,U1,Q, vec2( 0, 1) );\n \tQ.z = P;\n \tif (iFrame < 1) Q = vec4(0);\n    if (U.x < 1.||U.y < 1.||R.x-U.x < 1.||R.y-U.y < 1.) Q.xy *= 0.;\n \t\n \tif (length(U-vec2(0.1,0.5)*R) < .03*R.y) \n        Q.xy= Q.xy*.9+.1*vec2(.5,-.3);\n \tif (length(U-vec2(0.7,0.3)*R) < .03*R.y) \n        Q.xy= Q.xy*.9+.1*vec2(-.6,.3);\n \tif (length(U-vec2(0.2,0.2)*R) < .03*R.y) \n        Q.xy= Q.xy*.9+.1*vec2(.4,.6);\n \tif (length(U-vec2(0.7,0.5)*R) < .03*R.y) \n        Q.xy= Q.xy*.9+.1*vec2(-.1,-.3);\n \tif (length(U-vec2(0.5,0.6)*R) < .03*R.y) \n        Q.xy= Q.xy*.9+.1*vec2(0,-.7);\n    \n \tvec4 mo = texture(iChannel2,vec2(0));\n \tfloat l = ln(U,mo.xy,mo.zw);\n \tif (mo.z > 0. && l < 10.) Q.xyz += vec3((10.-l)*(mo.xy-mo.zw)/R.y,(10.-l)*(length(mo.xy-mo.zw)/R.y)*0.02);\n \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}