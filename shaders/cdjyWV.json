{
    "Shader": {
        "info": {
            "date": "1688189299",
            "description": "DESIGN this scene\ninspiration from a pillow",
            "flags": 0,
            "hasliked": 0,
            "id": "cdjyWV",
            "likes": 7,
            "name": "oooowl",
            "published": 3,
            "tags": [
                "cineshader",
                "oooowl"
            ],
            "usePreview": 0,
            "username": "chenxianming",
            "viewed": 1121
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926\n#define TAU 6.2831852\n#define T(s) fract(iTime * s) * PI * 4.\n\n#define calcLine( a ) step( mod( a, .5 ) - .25, 0. )\n#define calcLine2( a ) step( mod( a, .5 ) - .1, 0. )\n\n#define enableMouse 1\n\nvec2 m = vec2( 0.6, 0.55 ); \nmat2 m2 = mat2( .1, .1, -.7, .5 );\n\nfloat noise( in vec2 f ){\n  f *= m2;\n  return ( cos( f.x + .18975 ) * sin( f.y + .494516 ) + .1615246 );\n}\n\nfloat fbm( in vec2 x, in float H )\n{    \n    float t = 0.0;\n    for( int i=0; i<10; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*noise(f*x);\n    }\n    return t;\n}\n\nint eyeInt = 0;\n\n\nmat2 rotation(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat smin (float a, float b, float r)\n{\n    float h = clamp(.5+.5*(b-a)/r,0.,1.);\n    return mix(b, a, h) - r*h*(1.-h);\n}\n\nfloat smax(float a, float b, float c) {\n    return -smin(-a, -b, c);\n}\n\nfloat getPath( vec2[3] path, in vec2 uv ){\n    return path[0].x * pow( uv.x, 2. ) + path[0].y * pow( uv.y, 2. ) + path[1].x * uv.x * uv.y + path[1].y * uv.x + path[2].x * uv.y + path[2].y;\n}\n\nvec2 path1[3] = vec2[]( vec2( 0.0036000000000000337, 0.008099999999999927 ), vec2( 0.010800000000000087, -0.008496000000000004  ), vec2( 0.003480000000000096, -0.004072799999999995 ) );\n\nvec2 path2[3] = vec2[]( vec2( 0.03609999999999998, 0.003600000000000006 ), vec2( -0.022800000000000015, 0.03411199999999999  ), vec2( -0.003252000000000005, 0.005616280000000001 ) );\n\t\nvec2 path3[3] = vec2[]( vec2( 0.010000000000000007, 0.0001000000000000445 ), vec2( -0.0020000000000000157, 0.005656000000000005  ), vec2( 0.0028940000000000007, 0.0005264499999999997 ) );\n\n\nfloat calcBody( vec2 uv ){\n\n    float d = 0.5;\n    \n    // body\n    d = min( d,\n        length( uv * vec2( 1.2, 1. ) ) - .5\n    );\n    \n    d = smin( d, length( uv + vec2( .27, -.25 ) ) - .2, .3 );\n    d = smin( d, length( uv + vec2( -.27, -.25 ) ) - .2, .3 );\n    \n    d = smin( d, length( uv + vec2( .15, .2 ) ) - .25, .3 );\n    d = smin( d, length( uv + vec2( -.15, .2 ) ) - .25, .3 );\n\n    return d;\n}\n\nfloat calcEar( vec2 uv ){\n    return max(\n        max(\n            getPath( path1, uv ),\n            getPath( path2, uv )\n        ),\n        -getPath( path3, uv )\n    );\n}\n\nfloat calcWing( vec2 uv ){\n    float d = .1;\n    \n    uv.x -= .08;\n    uv.y += .25;\n    \n    uv.x -= cos( T( .25 ) ) * .01;\n    uv.y -= cos( T( .25 ) ) * .02;\n    \n    d = min(\n        d,\n        length( uv * rotation( .1 )  * vec2( 1., 1.5 ) + vec2( .33, -.3 ) ) - .35\n    );\n    \n    d = smin(\n        d,\n        length( uv + vec2( .35, -.05 ) ) - .2,\n        .2\n    );\n    \n    return d;\n    \n}\n\nfloat calcEyeSockets( vec2 uv ){\n    float d = .1;\n    \n    d = min(\n        d,\n        length( uv * vec2( 1., 1.5 ) + vec2( 0.25, -.3 ) ) - .25\n    );\n    \n    d = min(\n        d,\n        length( uv * vec2( 1., 1.5 ) + vec2( -0.25, -.3 ) ) - .25\n    );\n    \n    d = smin(\n        d,\n        length( uv * vec2( 1., 1.3 ) + vec2( -0.0, -.32 ) ) - .1,\n        .3\n    );\n    \n    d = smin(\n        d,\n        length( uv + vec2( -0.25, -.27 ) ) - .1,\n        .2\n    );\n    \n    d = smin(\n        d,\n        length( uv + vec2( 0.25, -.27 ) ) - .1,\n        .2\n    );\n    \n    return d;\n}\n\nfloat calcEyeOline( vec2 uv ){\n    return length( uv + vec2( .25, -.23 ) ) - .13;\n}\n\nfloat calcEye( vec2 uv ){\n    float d = .1;\n    eyeInt++;\n    \n    d = min(\n        d,\n        length( uv + vec2( .28, -.24 ) ) - .07\n    );\n    \n    d = max(\n        d,\n        eyeInt == 1 ?\n        -( length( uv * rotation( -.1 )  * vec2( 1., 1.2 ) + vec2( .33, -.3 ) ) - .03 ) :\n        -( length( uv * rotation( -.15 )  * vec2( 1., 1.5 ) + vec2( .35, -.35 ) ) - .025 )\n    );\n    \n    return d;\n    \n}\n\nfloat calcBeak( vec2 uv ){\n\n    float d = .1;\n    \n    d = min(\n        d,\n        length( uv + vec2( 0., -.05 ) ) - .05\n    );\n    \n    d = smin(\n        d,\n        length( uv + vec2( 0.05, -0.03 - .05 ) ) - .03,\n        .03\n    );\n    \n    d = smin(\n        d,\n        length( uv + vec2( -0.03, -0.03 - .05 ) ) - .03,\n        .04\n    );\n    \n    return d;\n\n}\n\nfloat calcChesty( vec2 uv ){\n\n    float d = .1;\n    \n    d = min(\n        d,\n        length( uv * vec2( .6, 1. ) + vec2( 0.02, .25 ) ) - .19\n    );\n    \n    return d;\n\n}\n\nfloat getPat( vec2 uv ){\n    float wave = 0.;\n    \n    uv.x -= cos( T( .025 ) ) * .1;\n    uv.y += sin( T( .025 ) ) * .1;\n    \n    uv.y -= .05;\n    uv.y = mod( uv.y, .1 ) - .05;\n    \n    vec2 uv2 = uv;\n    vec2 uv3 = uv;\n    \n    uv2.x = mod( uv2.x, .1 ) - .05;\n    wave = ( length( uv2 ) - .05 );\n    \n    uv3.x = mod( uv3.x, .1 ) - .05;\n    wave = max(\n        wave,\n        -( length( uv3 + vec2( 0., -.01 ) ) - .05 )\n    );\n\n    return wave;\n}\n\nfloat calcClawu( vec2 uv ){\n    float p = 0.;\n\n    float py = uv.y;\n    \n    if( py < 0. ){\n        py *= 6.;\n    }\n    \n    if( py <= -1. ){\n        py = -1.;\n    }\n    \n    if( py > 0. ){\n        py *= 3.;\n    }\n    \n    if( py >= 1. ){\n        py = 1.;\n    }\n    \n    py = abs( pow( py, 2. ) ) - 1.;\n    py = abs( py );\n    \n    p = abs( uv.x ) - .1 * py;\n    \n    return p;\n}\n\nfloat calcClawg( vec2 uv ){\n\n    float d = .1;\n\n    d = min( d,\n        calcClawu( uv * 3. * rotation( PI * 1.05 ) + vec2( 0.3, 0.1 ) )\n    );\n    \n    d = min( d,\n        calcClawu( uv * 3. * rotation( PI * 1.05 ) + vec2( -0.25, 0. ) )\n    );\n    \n    d = min( d,\n        calcClawu( uv * 2.6 * rotation( PI * 1.1 ) )\n    );\n\n    return d;\n}\n\nfloat calcWoocry( vec2 uv ){\n\n    float d = .1;\n    \n    float py = uv.y;\n    \n    py /= 2.;\n    py += .5;\n\n    d = min(\n        d,\n        max(\n            abs( uv.x ) - .1 * py,\n            abs( uv.y ) - .15\n        )\n    );\n\n    return d;\n}\n\nvec3 texMap( vec2 uv )\n{\n\n    vec3 col = vec3( \n        mix( vec3( 1. ), vec3( 0.73, 0.82, 0.84 ), calcLine( uv.y * .6 + abs(uv.x -.0 ) * .5 - ( iTime * .05 ) ) )\n    );\n    \n    uv.y += cos( T( .25 ) ) * .005;\n    \n    float d = 0.;\n    \n    // ears\n    d = .1;\n    d = min( d,\n        calcEar( uv * vec2( -1., 1. ) * rotation( .3 ) + vec2( -.12, -.35 ) )\n    );\n    \n    d = min( d,\n        calcEar( uv * vec2( 1., 1. ) * rotation( .1 ) + vec2( 0., -.3 ) )\n    );\n    d = step( d, 0. );\n    \n    col = mix(\n        col,\n        vec3( 0.92, 0.40, 0.15 ),\n        d\n    );\n    \n    // wings\n    d = .1;\n    d = min( d,\n        calcWing( uv )\n    );\n    \n    d = min( d,\n        calcWing( uv * vec2( -1., 1. ) + vec2( .01, -.05 ) )\n    );\n    \n    d = step( d, 0. );\n    \n    col = mix(\n        col,\n        vec3( 0. ),\n        d\n    );\n    \n    // body\n    d = .1;\n    d = min( d,\n        calcBody( uv )\n    );\n    \n    d = step( d, 0. );\n    \n    col = mix(\n        col,\n        vec3( 0.91, 0.8, 0.15 ),\n        d\n    );\n    \n    // eye\n    d = max(\n        calcBody( uv ),\n        -calcEyeSockets( uv )\n    );\n    \n    d = max(\n        d,\n        -( uv.y - .2 )\n    );\n\n    d = step( d, 0. );\n       col = mix(\n        col,\n        vec3( 0.92, 0.40, 0.15 ),\n        d\n    );\n    \n    d = .1;\n    d = min( d,\n        calcEyeSockets( uv )\n    );\n    \n    d = step( d, 0. );\n    \n    col = mix(\n        col,\n        vec3( 1. ),\n        d\n    );\n    \n    d = .1;\n    d = min( d,\n        calcEyeOline( uv + vec2( -.5, 0. ) )\n    );\n    \n    d = min( d,\n        calcEyeOline( uv + vec2( 0., 0. ) )\n    );\n    \n    d = smoothstep( 0., d, .01 );\n    d = dot(d, d);\n    d = dot(d, d);\n    d = dot(d, d);\n    \n    col = mix(\n        col,\n        vec3( 0. ),\n        d\n    );\n    \n    \n    // eye2\n    d = .1;\n    d = min( d,\n        calcEye( uv )\n    );\n    \n    d = min( d,\n        calcEye( uv * vec2( -1., 1. ) )\n    );\n    \n    \n    d = step( d, 0. );\n    \n    col = mix(\n        col,\n        vec3( 0. ),\n        d\n    );\n    \n    // beak\n    d = .1;\n    d = min( d,\n        calcBeak( uv )\n    );\n    \n    d = step( d, 0. );\n    \n    col = mix(\n        col,\n        vec3( 0. ),\n        d\n    );\n    \n    // chesty\n    d = .1;\n    d = min( d,\n        calcChesty( uv )\n    );\n    \n    d = step( d, 0. );\n    \n    col = mix(\n        col,\n        vec3( 0.15, 0.53, 0.60 ),\n        d\n    );\n    \n    \n    col = mix(\n        col,\n        vec3( 1. ),\n        d * step( getPat( uv ), 0. )\n    );\n    \n   \n    // claw\n    d = .1;\n    \n    d = min( d, calcClawg( uv + vec2( -.22, 0.62 ) ) );\n    d = min( d, calcClawg( uv * vec2( -1., .95 ) + vec2( -.2, 0.6 ) ) );\n    \n    d = step( d, 0. );\n    \n    col = mix(\n        col,\n        vec3( 0. ),\n        d\n    );\n    \n    // woocry\n    d = .1;\n    \n    uv += vec2( -.55, -.65 );\n    uv *= 1.2;\n    d = min( d, calcWoocry( uv * rotation( PI * -.25 ) + vec2( -.1, -0.1 ) ) );\n    d = step( d, -1. + round( fract( iTime + 1. ) ) );\n    \n    col = mix(\n        col,\n        vec3( 0.92, 0.40, 0.15 ),\n        d\n    );\n    \n    d = .1;\n    d = min( d, calcWoocry( uv * 1.2 * rotation( PI * -.3 ) + vec2( -.3, -0.15 ) ) );\n    \n    d = step( d, -1. + round( fract( iTime * .25 ) ) );\n    \n    col = mix(\n        col,\n        vec3( 0.92, 0.40, 0.15 ),\n        d\n    );\n    \n    d = .1;\n    d = min( d, calcWoocry( uv * 1.2 * rotation( PI * -.35 ) + vec2( -.45, -0.15 ) ) );\n    \n    d = step( d, -1. + round( fract( iTime * .5 ) ) );\n    \n    col = mix(\n        col,\n        vec3( 0.92, 0.40, 0.15 ),\n        d\n    );\n\n    return col;\n}\n\nfloat calcB( vec3 p ){\n    float d = .1;\n    \n    p.xz *= rotation( clamp( m.x, -1., 1. ) );\n    p.yz *= rotation( clamp( m.y, -.5, .3 ) );\n    \n    // p.z += fbm( p.yz, 1.1 ) * .5;\n    \n    d = smax(\n      smax( abs( p.x ) - .8, abs( p.z ) - .15, .1 ),\n      abs( p.y ) - .8,\n      .3\n    );\n    \n    d = smin( d,\n        max(\n            length( p.yz * vec2( 1., 2.1 ) + vec2( 0., fbm( p.yz, 1. ) * .05 ) ) - .5,\n            abs( p.x ) - .7\n        )\n        ,.5\n    );\n    \n    return d;\n}\n\nfloat ground( vec3 p ){\n    float d = .1;\n    \n    p.xz *= rotation( PI * -.5 );\n    \n    d = min(\n        d,\n        p.y + .7\n    );\n    \n    d = min(\n        d,\n        p.x + 1.1\n    );\n    \n    return d;\n}\n\nfloat map(vec3 p) {\n    float d = .1;\n    \n    d = min(\n        d,\n        calcB( p )\n    );\n    \n    d = min(\n        d,\n        ground( p )\n    );\n    \n    \n    return d;\n}\n\n// IQ\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy * eps) +\n        e.yyx * map(pos + e.yyx * eps) +\n        e.yxy * map(pos + e.yxy * eps) +\n        e.xxx * map(pos + e.xxx * eps));\n}\n\nvec3 raymarching( vec3 ro, vec3 rd ){\n    \n    float t = 0.,\n          dist = 0.;\n          \n    vec3 lig = normalize(vec3(.57703));\n    lig.xz *= rotation( PI * 1.3 );\n    lig.xy *= rotation(  PI * .5 );\n    \n    vec3 hal = normalize(lig - rd);\n    \n    vec3 pos = vec3( 0. );\n    \n    for( int i = 0; i < 64; i++ ){\n        \n        pos = ro + rd * t;\n\n        dist = map( pos );\n        \n        if( t > 1e3 ){\n            break ;\n        }\n        \n        t += dist;\n    }\n    \n    \n    if( dist < 1e-3 ){\n    \n        vec3 nor = calcNormal(pos);\n\n        float dif = clamp(dot(nor, vec3(.4, 1., -.5)), 0.0, 1.0);\n\n        float shadow = calcSoftshadow( pos, lig, 0.1, 3.0, 1 );\n        dif *= shadow;\n\n        float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 50.0) * .6;\n        spe *= dif;\n\n        float amb = dot(nor, vec3(0.0, 1.0, 0.0));\n\n        vec3 reflection = reflect(rd, nor);\n        \n        vec3 col = vec3( 0. );\n        \n        if( map( pos ) == ground( pos ) ){\n            \n            vec3 posg = pos;\n            posg.zx *= rotation( PI * .2 );\n            float pt = fbm( vec2( fbm( posg.zx - ( 100. ), 1. ) ), .1 );\n\n            posg.xy += calcLine( pos.x );\n            \n            col += spe + vec3( .3 ) * dif + amb * .2 + mix( vec3( vec3(pt) * vec3( .1 ) ), vec3(pt) * vec3( 0.37, 0.34, 0.31 ) * .7, calcLine( pos.x ) ) * .25 ;\n            col += vec3( 0.73, 0.82, 0.84 ) * .1;\n        }\n        \n        if( map( pos ) == calcB( pos ) ){\n            \n            vec3 posg = pos;\n            posg.xz *= rotation( clamp( m.x, -1., 1. ) );\n            posg.yz *= rotation( clamp( m.y, -.5, .3 ) );\n            nor.xz *= rotation( clamp( m.x, -1., 1. ) );\n            nor.yz *= rotation( clamp( m.y, -.5, .3 ) );\n        \n            col = spe + vec3( .1 ) * dif + ( .3 + calcLine2( posg.y * 1.5 )) * max( nor.x, 0. ) + (  vec3( 0.73, 0.82, 0.84 ) * .5 +  calcLine2( posg.y * 1.5 )) * max( -nor.x, 0. );\n            col += max( -nor.z, .0 ) * texMap( posg.xy * 1.5 );\n        }\n        \n        return col;\n        \n    }\n        \n    return vec3( 0. );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if( iMouse.z > .01 && enableMouse == 1 ){\n        m = iMouse.xy/iResolution.xy;\n    }\n    \n    uv = (uv - .5) * 2.;\n    m = (m - .5) * 2.;\n\n    uv.x *= iResolution.x / iResolution.y;\n    m.x *= iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3( 0. );\n    \n    vec3 ro = vec3( 0., 0., -2. );\n    vec3 rd = vec3( uv, 1. );\n    \n    col = raymarching( ro, rd );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}