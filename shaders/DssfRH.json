{
    "Shader": {
        "info": {
            "date": "1688461327",
            "description": "playing with lighting techniques",
            "flags": 0,
            "hasliked": 0,
            "id": "DssfRH",
            "likes": 1,
            "name": "[RMO] - lighting",
            "published": 3,
            "tags": [
                "raymarch",
                "lighting",
                "experiment"
            ],
            "usePreview": 0,
            "username": "silica163",
            "viewed": 150
        },
        "renderpass": [
            {
                "code": "float dist(vec3 p){\n\tfloat d = 0.;\n    \n    d = prismSDF(p,0);\n    d = min(d,sphereSDF(p,0));\n    d = min(d,cubeSDF(p,0));\n    d = min(d,octahedronSDF(p,0));\n    d = min(d,lineSDF(p,0));\n    d = min(d,cylinderSDF(p,0));\n    d = min(d,torusSDF(p,0));\n    \n    d = min(d,p.y+4.);\n    \n\treturn d;\n}\n\nvec3 sNormal(vec3 p){\n\tvec2 t = vec2(.001,0);\n\tfloat d = dist(p);\n\t\n\treturn normalize(d - vec3(\n\t\tdist(p-t.xyy),\n\t\tdist(p-t.yxy),\n\t\tdist(p-t.yyx)\n\t));\n}\n\nfloat diffuse(vec3 p,vec3 L){\n\treturn max(dot(sNormal(p),normalize(L)),0.);\n}\n\n// phong\nfloat phong(Light l,Ray r){\n    float c = 0.;\n    float d = diffuse(r.p,l.L);\n    vec3 lRef = reflect(-l.L,N);\n    \n    c = pow(max(dot(lRef,-r.dir),0.),8.) * d;\n    \n    return c;\n}\n\n// blinn phong\nfloat bPhong(Light l,Ray r){\n\tfloat c = 0.;\n\tfloat d = diffuse(r.p,l.L);\n\t\n\tc += pow(max(dot(normalize(l.L+V),N),0.),4.) * d;\n\t\n\treturn c;\n}\n\nvec3 render(Ray r){\n    vec3 c = vec3(0);\n    N = sNormal(r.p);\n    for( int i = 0;i< LIGHTS;i++){\n        lNormal(l[i],r);\n        c += .2;\n        c += diffuse(r.p,l[i].L);\n        c += bPhong(l[i],r);\n    }\n    //c = .5+.5*N;\n    c = mix(vec3(0.5),vec3(1.0),c);\n    c *= normalize(vec3(1));\n    \n    if(r.dist > MAX_DIST)c = vec3(0);\n    return c;\n}\n\nvoid march(inout Ray r,int t){\n\tfor(int i = 0;i<MAX_STEP;i++){\n\t\tr.p = r.o + r.dist*r.dir;\n\t\tfloat d = dist(r.p);\n\t\td = t == 0 ? d : min(d,lightDist(r.p,d));\n\t\tif(d <= MIN_DIST || d > MAX_DIST)break;\n\t\tr.dist += d;\n\t}\n    r.rl += r.dist;\n}\n\nvoid mainImage( out vec4 fColor, in vec2 fCoord )\n{\n    vec2 uv = (2.*fCoord.xy - iResolution.xy)/iResolution.y;\n    uv *= 1.5;\n    vec2 m = vec2(time*.1,-abs(sin(time/40.)*1.));\n    m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 c = vec3(0);\n    vec3 ca = vec3(\n        PI/2.+m.y*PI/1.5,\n        PI/2.-m.x*PI/1.,\n        0\n    );\n    \n    float camz = PI;\n    vec3 camera = vec3(0,0,camz)*rotX(ca.x)*rotY(ca.y);\n    vec3 plane = vec3(uv*2.,0)*rotX(ca.x)*rotY(ca.y);\n    \n    Ray r = initRay(camera,plane);\n    \n    cu[0].p = vec3(1.5,0,1.5);\n    cu[0].s = vec3(.4);\n    \n    pr[0].p = vec3(1.5,0,0);\n    pr[0].s = vec3(.2,.4,6);\n    \n    l[0].p = vec3(2)*rotX(ca.x)*rotY(ca.x);\n    \n    sp[0].p = vec4(0,0,1.5,.4);\n    \n    line[0].a = vec3(.5,.5,-.5)+vec3(-.9,0,-.9);\n    line[0].b = vec3(-.5,-.5,.5)+vec3(-.9,0,-.9);\n    line[0].r = .2;\n    \n    cyl[0].p = vec3(1.5,0,-1.5);\n    cyl[0].s = vec2(.5,.4);\n    \n    tor[0].r = vec2(.4,.2);\n    tor[0].p = vec3(-1.5,0,1.5);\n    \n    oc[0].p = vec4(0,0,0,.5);\n    \n    //l[0].p = vec3(5);//*rotX(ca.x)*rotY(ca.y);\n    //l[1].p = vec3(1,2,1);//*rotX(ca.x)*rotY(ca.y);\n\n    l[0].p.xz = l[0].p.xz * rot2D(iTime*.5);\n    \n    march(r,0);\n    N = sNormal(r.p);\n    V = -r.dir;\n    \n    //c = N*.5+.5;\n    //c = r.p;\n    c += render(r);\n    //c = vec3(1./r.rl);\n    fColor = vec4(c,1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define time iTime\n#define resolution iResolution\n#define mouse iMouse.xy\n#define PI 3.14159265\n#define MAX_DIST  100.\n#define MIN_DIST  .001\n#define MAX_STEP  256\n#define MAX_REF   2\n\n#define rotX(a) mat3(      1,      0,       0,       0, sin(a), cos(a),      0,- cos(a), sin(a))\n#define rotY(a) mat3( sin(a),      0, -cos(a),       0,      1,      0, cos(a),       0, sin(a))\n#define rotZ(a) mat3( sin(a), cos(a),       0, -cos(a), sin(a),      0,      0,       0,      1)\n#define rot2D(a) mat2(sin(a),cos(a),-cos(a),sin(a))\n\nconst int LIGHTS = 1;\nconst int PRISM = 1;\nconst int OCTS  = 1;\nconst int TORUS = 1;\nconst int SPHERES = 1;\nconst int CUBES = 1;\nconst int LINES = 1;\nconst int CYLS = 1;\n\nvec3 N = vec3(0);\nvec3 V = vec3(0);\n\nstruct Ray {\n\tvec3 o;\n\tvec3 p;\n\tvec3 dir;\n\tvec3 c;\n\tfloat dist;\n    float rl;\n};\n\nstruct Light {\n\tvec3 p;\n\tvec3 c;\n    vec3 L;\n},l[LIGHTS];\n\nstruct Octahedron {\n    vec4 p;\n    vec3 c;\n},oc[OCTS];\n\nstruct Prism {\n    vec3 p;\n    vec3 s;\n    vec3 c;\n},pr[PRISM];\n\nstruct Torus {\n    vec3 p;\n    vec2 r;\n    vec3 c;\n},tor[TORUS];\n\nstruct Cyl {\n    vec3 p;\n    vec2 s;\n    vec3 c;\n},cyl[CYLS];\n\nstruct Line {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    float r;\n},line[LINES];\n\nstruct Cube {\n\tvec3 p;\n\tvec3 c;\n\tvec3 s;\n},cu[CUBES];\n\nstruct Sphere {\n    vec4 p;\n    vec3 c;\n},sp[SPHERES];\n\n\n// octahedron\nfloat octahedronSDF(vec3 p,int id){\n    Octahedron o = oc[id];\n    float d;\n    \n    p = abs(p-o.p.xyz);\n    float face = p.x+p.y+p.z - o.p.w;\n        \n    vec3 q = p;\n    \n    if(p.x*3.< face)q = p.xyz;\n    else if(p.y*3. < face)q = p.yzx;\n    else if(p.z*3. < face)q = p.zxy;\n    else return face* (1./sqrt(3.));\n    \n    float k = clamp(0.5*(q.z-q.y+o.p.w),0.0,o.p.w);\n    float edge = length(vec3(q.x,q.y-o.p.w+k,q.z-k));\n    \n    d = edge;\n    return d;\n}\n\n// torus / donut\nfloat torusSDF(vec3 p,int id){\n    float d = 0.;\n    Torus t = tor[id];\n    \n    vec3 sp;\n    sp.xz = normalize(p.xz-t.p.xz)*t.r.x;\n    d = length(p-t.p-sp)-t.r.y;\n    \n    return d;\n}\n\n// cylinder\nfloat cylinderSDF(vec3 p,int id){\n    vec2 d = vec2(0);\n    Cyl c = cyl[id];\n    vec3 cp = p - c.p;\n    \n    d = vec2(abs(cp.y),length(cp.xz)) - c.s * vec2(.5,1);\n    \n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\n// line / capsule\nfloat lineSDF(vec3 p,int id){\n    float d = 0.;\n    Line li = line[id];\n    vec3 p1 = p - li.a;\n    vec3 p2 = li.b - li.a;\n    \n    d = length(p1 - clamp(dot(p1,p2)/dot(p2,p2),0.,1.)*p2) - li.r;\n    return d;\n}\n\n// sphere\nfloat sphereSDF(vec3 p,int id){\n    return length(p-sp[id].p.xyz) - sp[id].p.w;\n}\n\nfloat max3(vec3 n){\n    return max(max(n.x,n.y),n.z);\n}\n\n// cube sdf\nfloat cubeSDF(vec3 p,int id){\n    vec3 c = abs((p-cu[id].p))-cu[id].s;\n    return length(max(c,0.)) + min(0.,max3(c));\n}\n\n//2d polygon sdf\nfloat polygon(vec2 uv,vec2 p,float r,float n){\n    uv = uv - p;\n    n = floor(n);\n    float pa = PI-atan(uv.x,uv.y);      // position angle\n    float sa = 2.*PI/n;                 // side angle\n    float id = (pa - mod(pa,sa)) / sa ;\n    float ra = id * (sa) + sa/2.;       // rotate angle\n    float ir = cos(sa/2.)*r;            // inner radius\n    float sl = sin(sa/2.)*r;            // half side length\n    \n    uv = rot2D(ra)*uv;\n    uv += vec2(-ir,0);\n    \n    if(uv.x < 0.)return uv.x;\n    \n    return length(vec2(uv.x,uv.y - clamp(uv.y,-sl,sl)));\n}\n\n// prism sdf\nfloat prismSDF(vec3 p,int id){\n    vec2 d = vec2(0);\n    Prism ps = pr[id];\n    vec3 cp = p - ps.p;\n    \n    d = vec2(abs(cp.y)-ps.s.x,polygon(cp.xz,vec2(0),ps.s.y,ps.s.z)-.05) * vec2(.5,1);\n    \n    return min(max(d.y,d.x),0.) + length(max(d,0.));\n}\n\n\nvoid lNormal(inout Light l,Ray r){\n\tl.L = normalize(l.p-r.p);\n    //l.L = normalize(l.p);\n}\n\nfloat lightDist(vec3 p,float d){\n    for(int i = 0;i<LIGHTS;i++)\n        d = min(d,length(p - l[i].p)-.1);\n\treturn d;\n}\n\n\n\nRay initRay(vec3 c,vec3 p){\n    // c camera\n    // p projection plane\n    Ray r;\n    r.o = c;\n    r.p = r.o;\n    r.dir = normalize(p-c);\n    r.c = vec3(0);\n    r.dist = .5;\n    r.rl = 0.;\n    return r;\n}\n\nfloat smin(float a, float b, float k){\n    float r = min(a,b) - pow(max(0.,k - abs(a - b)/k)*.5,2.);\n    return r;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}