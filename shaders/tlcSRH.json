{
    "Shader": {
        "info": {
            "date": "1580371978",
            "description": "for test",
            "flags": 0,
            "hasliked": 0,
            "id": "tlcSRH",
            "likes": 2,
            "name": "HSB test",
            "published": 3,
            "tags": [
                "hsb"
            ],
            "usePreview": 0,
            "username": "tonywu",
            "viewed": 334
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nvec2 tile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    return fract(_st);\n}\n\nvec2 brickTile(vec2 _st, float _zoom){\n    _st *= _zoom;\n\n    // Here is where the offset is happening\n    _st.x += step(1., mod(_st.y,2.0)) * 0.5 *iTime;\n\n    return fract(_st);\n}\n\nvec2 brickTile2(vec2 _st, float _zoom){\n    _st *= _zoom;\n\n    // Here is where the offset is happening\n    _st.y += step(1., mod(_st.x,2.0)) * 0.5 *iTime;\n\n    return fract(_st);\n}\n\nvec2 movingTiles(vec2 _st, float _zoom, float _speed){\n    _st *= _zoom;\n    float time = iTime*_speed;\n    if( fract(time)>0.5 ){\n        if (fract( _st.y * 0.5) > 0.5){\n            _st.x += fract(time)*2.0;\n        } else {\n            _st.x -= fract(time)*2.0;\n        }\n    } else {\n        if (fract( _st.x * 0.5) > 0.5){\n            _st.y += fract(time)*2.0;\n        } else {\n            _st.y -= fract(time)*2.0;\n        }\n    }\n    return fract(_st);\n}\n\n\nfloat rectShape(vec2 position, vec2 scale){\n    scale = vec2(0.5) - scale * 0.5;\n    vec2 shaper = vec2(step(scale.x, position.x), step(scale.y, position.y));\n    shaper *= vec2(step(scale.x, 1.0 - position.x), step(scale.y, 1.0 - position.y));\n    return shaper.x * shaper.y;\n}\n\nfloat circleShape(vec2 position, float radius){\n    return step(radius, length(position - vec2(0.5)));\n}\n\nfloat polygonShape(vec2 position, float radius, float sides){\n    position = position * 2.0 - 1.0;\n    float angle = atan(position.x, position.y);\n    float slice = PI * 2.0 / sides;\n    return step(radius, cos(floor(0.5 + angle / slice) * slice - angle) * length(position));\n}\n\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n   \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 position = fragCoord/iResolution.xy;\n    // Divide the space in 4\n    //uv = tile(uv,4.);\n    //uv = brickTile2(uv, 4.);\n    uv = movingTiles(uv,4.,0.5);\n    \n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    \n    \n    //int tx = int(uv.x*512.0);\n    int tx = 3;\n     \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n    \n    position -= vec2(0.5);\n    // rotate the space\n    position = rotate2d( sin(iTime)*PI*fft ) * uv;\n    position = scale(vec2(0.8*sin(fft))) * position;\n    // move it back to the original place\n    position += vec2(0.5);\n    \n  \n    \n    vec3 color = vec3(0.0);\n\n    // Use polar coordinates instead of cartesian\n    vec2 toCenter = vec2(0.)-uv;\n    float angle = atan(toCenter.y,toCenter.x);\n    float radius = length(toCenter)*2.0;\n    \n\n\n    // Map the angle (-PI to PI) to the Hue (from 0 to 1)\n    // and the Saturation to the radius\n    color = hsb2rgb(vec3(radius-iTime,abs(sin(angle+fft*iTime)),1.));\n       \n    color -= vec3(0.,0.,rectShape(position,vec2(1.,abs(sin(fft))-0.5)));\n    color -= vec3(rectShape(position,vec2(abs(sin(fft))-0.5,1.)),0.,0.);\n    \n\n\n    fragColor = vec4(color*1.5*cos(fft),1.0);\n    //fragColor.rgb = pow(color, vec3(1./2.2));\n    // apply gamma correction\n    float gamma = 2.2;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/gamma));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 34,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}