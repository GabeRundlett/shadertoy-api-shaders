{
    "Shader": {
        "info": {
            "date": "1720611471",
            "description": "Ground truth version of Visibility Bitmask Ambient Occlusion (VBAO | https://arxiv.org/abs/2301.11376).\nThis work was partially fundend by 1000Orks: https://1000orks.com/ | https://x.com/1000orks.\nCamera controls via mouse + shift key",
            "flags": 48,
            "hasliked": 0,
            "id": "XXGSDd",
            "likes": 12,
            "name": "GT-VBAO",
            "published": 3,
            "tags": [
                "ao",
                "occlusion",
                "ambient",
                "gtao",
                "vbao"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 540
        },
        "renderpass": [
            {
                "code": "/*\n    Ground truth version of Visibility Bitmask Ambient Occlusion (VBAO | https://arxiv.org/abs/2301.11376).\n    This version matches the result of a brute force ray marcher that shares the same limitations and assumptions\n    (limited number of screen space depth samples, depth sample distribution along marching direction, thickness assumption).\n    GT-VBAO supports both, uniform hemisphere weighting, and cosine weighted hemisphere weighting.\n    \n    This work was partially fundend by 1000Orks: https://1000orks.com/ | https://x.com/1000orks.\n    \n    An overview of the original VBAO including source code can be found on Olivier Therrien's blog: https://cdrinmatane.github.io/posts/ssaovb-code/.\n    \n    \n    GT-VBAO accounts for the shortcoming of the original VBAO implementation in the following ways:\n    \n    1. correct slice-local sample distribution: \n        VBAO assumes a uniform distribution of samples in each slice. \n        However, this does not account for the pole at the view vector, which leads to a lower sample density close to angN.\n        In addition, for properly cosine weighted AO, the cosine falloff towards the horizons also needs to be considered here.\n        \n        To account for the non-uniform slice-local sample pdf the min/max-horizon angles are remapped by the corresponding CDF.\n        \n        Because of the bit mask approach we can't remap the sample locations themselves as it is usually done via the inverse CDF.\n        However, we can apply the inverse mapping (i.e. the CDF itself) to the constant interval we intent to sample.\n        This also has the advantage that we do not need to invert the CDF (at least as long as we are only interested in AO).\n    \n    2. treat the slice-local samples as point samples instead of as sectors (+ jitter the sample group as a whole)\n        This is done by calculating the quantized arc length from the quantized min/max-horizon angles instead of \n        computing the arc length from the unquantized angles and then quantizing it.\n        \n        The code here uses an equivalent approach that first computes two bit masks from the min/max-angles, respectively, \n        and then 'ands' those together. The resulting code is a bit more readable and should produce the same number of instructions.\n        \n    3. account for perspective distorion when not using an orthographic projection\n        VBAO treats a perspective camera the same way as an orthographic one. \n        A perspective projection can be accounted for by sampling the slice direction in a local frame around the view vector (view vec space).\n        The resulting slice direction can then subsequently be projected to the image plane.\n        \n        Also, when accounting for the assumed thickness by computing an offseted position from the current depth sample we can not do so using the\n        view vector. Instead we need to compute an offset direction for each depth sample associated position individually.\n    \n    These changes apply to both, the uniformly weighted hemisphere variant, as well as the cosine weighted hemisphere variant of GT-VBAO.\n    However, the cosine weighted hemisphere variant also requires us to make changes to the slice direction sampling routine:\n    \n    4. support for slice direction sampling from a cosine weighted hemisphere via one of 3 options:\n        1 - Sample uniformly, but account for the cosine distribution by weighting each slice accordingly.\n            This is the most straightforward option, but it produces significant amounts of variance.\n        2 - Sample a ray direction from the world space cosine lobe around N. Project this ray direction to the image plane and\n            use it as the slice direction. I don't have a prove that this is actually correct, but comparing it to option 1 and to the\n            reference ray marcher output it most likely is. While this approach (appears) to perfectly sample proportionally\n            to the desired slice pdf, it has the drawback that it requires 2 random numbers to generate a single slice direction.\n            This usually reduces the effectiveness of low-discrepancy sequences and sampling patterns that are designed to distribute \n            the sampling error in image space.\n        3 - Directly importance sample the one dimensional pdf of slice angles using a single random number. \n            The difficulty with this approach is that the corresponding CDF is not invertible.\n            It is, however, possible to construct a pretty good invertible approximation that does not produce any noticeable bias.\n            \n            The CDF we are trying to approximate is a simple sinusoid s-curve if the view vector is orthogonal to the surface normal.\n            The more the view vector alignes with the surface normal the more the s-curve blends towards a simple linear ramp.\n            However, at the same time as the linear blend happens the C1-continuous sinusoid s-curve morphes into a C2-continuous sinusoid s-curve.\n            The C2-continuous sinusoid s-curve is one of those curves that appear simple at first glance but then turn out to be non-invertible.\n            \n            The approximation of the inverse CDF I came up with looks like this:\n            \n            float SampleSlice(float x, float sinNV)\n            {\n                float s = QBias(sinNV, 0.15);\n\n                      x =    SinStep(x);\n                float y = InvSinStep(x, s);\n                      y = InvSinStep(y);\n\n                return y;\n            } \n            \n            SinStep(x) is the C1-continuous sinusoid s-curve and InvSinStep(x) its inverse.\n            InvSinStep(x, s) is a generalization that allows to morph the curve into a linear ramp by stretching it\n            (simply lerping towards a linear ramp wouldn't give the desired behavior and also wouldn't be invertible).\n            QBias(x, b) is a simple quatratic bias used to compute the streching value from the sine of the angle between\n            the view vector and the surface normal. The bias of 0.15 is chosen so as to match the ground truth pdf.\n            In practice, the first SinStep(x) and the last InvSinStep(y) can be optimized away by not working with angles directly\n            (compare the two versions of SampleSliceDir(vvsN, rnd01) in Buffer C).\n            \n            The sampling option used here can be set via GTVBAO_SLICE_SAMPLING_MODE at the top of Buffer C (default: option 3)\n    \n    I also tried using a dedicated bit mask for both ray marching directions, separately, but found that, at least for this test scene here, \n    it made virtually no difference. 32 bits for the whole slice seems like a solid choice.\n    \n    \n    Buffer A: input logic\n    Buffer B: g-buffer rendering\n    Buffer C: GT-VBAO + reference ray marcher/caster\n    Image   : documentation + presentation\n\n    Controls:\n    1: split screen comparison of GT-VBAO (left) and reference ray marcher (right)\n    2: GT-VBAO\n    3: reference ray marcher\n    4: grey-scale difference betwwen GT-VBAO and reference (white: too bright | black: too dark)\n    5: colored    difference betwwen GT-VBAO and reference (red  : too bright | blue : too dark)\n    6: blurred version of 4\n    7: blurred version of 5\n    -> options 4-7 only make sense to use with converged results\n\n    toggles:\n    \n    Tab  : toggle temporal accumulation on/off\n    Ctrl : toggle ortho cam off/on\n    Space: toggle between cosine and uniform hemisphere weighting (changes appearance of UI | default: cosine)\n\n    W    : toggle white noise use on/off\n    U    : toggle UI off/on\n    \n    Camera controls via mouse + shift key.\n    \n    To compare against the orignal VBAO implementation (generally too bright) toggle uniform hemisphere weighting on and activate \n    USE_ORIGNAL_VBAO_IF_UNIFORM_HEMISHPHERE_WEIGHTING_IS_ACTIVE (at the top of Buffer C).\n    \n    \n    Related/Sources:\n    \n        - Screen Space Indirect Lighting with Visibility Bitmask: the original VBAO\n          https://arxiv.org/abs/2301.11376\n          \n        - An overview of the original VBAO including source code (Olivier Therrien's blog): my initial implementation was based on this\n          https://cdrinmatane.github.io/posts/ssaovb-code/\n          \n        - Practical Real-Time Strategies for Accurate Indirect Occlusion: introduces GTAO which VBAO is a variant of\n          https://www.activision.com/cdn/research/Practical_Real_Time_Strategies_for_Accurate_Indirect_Occlusion_NEW%20VERSION_COLOR.pdf\n*/\n\n\n/*\n    The following work is licensed under a dual license, public domain and MIT, unless noted otherwise. Chose which one suits your needs best:\n    \n    CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n    To the extent possible under law, the author has waived all copyrights and related or neighboring rights to this work.\n    \n    or\n    \n    The MIT License\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), \n    to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, \n    and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR \n    THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#define KeyBoard iChannel2\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 2), 0).x;}\n\n#define VarTex iChannel3\n#define OutCol outCol\n#define OutChannel w\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n/////////////////////////////////////////////////////////////////////////////////// UI\n//===============================================================================//\n\nfloat glyph2(bool style, vec2 tc)\n{\n    float r0 = 10.0;\n    float r1 = 1.;\n    float b = max(abs(tc.x), abs(tc.y)) - r0;\n    float c = length(tc) - r0*0.9;\n    \n    b = max(b, -c);\n    \n    if(!style) if(r1 != 0.0) b = abs(b) - r1;\n    \n    b = max(b, -(abs(tc.x) - r1));\n    b = max(b, -(abs(tc.y) - r1));\n    \n    return 1.0 - clamp(b + 0.5, 0.0, 1.0);\n}\n\nfloat glyph(bool type, vec2 tc, float r0, float r1, bool separator)\n{\n    float b = (type ? length(tc) : max(abs(tc.x), abs(tc.y))) - r0;\n    \n    if(r1 != 0.0) b = abs(b) - r1;\n    \n    if(separator) b = max(b, -(abs(tc.x) - r1));\n    \n    return 1.0 - clamp(b + 0.5, 0.0, 1.0);\n}\n\nvec2 EvalUI(vec2 uv0, float id, bvec2 modes)\n{\n    vec2 s = vec2(30.0, 30.0);\n\n    vec2 uv = uv0;\n\n    vec2 uvI = floor(uv / s);\n    vec2 uvF = uv - uvI * s;\n\n    if(uvI.y > 0.0 || uvI.x < 0.0 || uvI.x > 3.0) { return vec2(0.0); }\n\n    vec2 tc = uvF-s*0.5;\n\n    float k = 0.35;\n    if(uvI.x == id) k = 0.9;\n\n    bool isSolid = false;\n\n    if(uvI.x == 0.0) \n    isSolid = tc.x   < 0.0 ? modes.x : modes.y;\n    else\n    isSolid = uvI.x == 1.0 ? modes.x : modes.y;\n    \n    bool type = uvI.x == 1.0;\n    if(uvI.x == 0.0) type = tc.x < 0.0;\n\n    float v = glyph(type, tc, 8.0, isSolid ? 0.0 : 2.0, uvI.x == 0.0);\n    if(uvI.x == 3.0) v = glyph2(modes.x || modes.y, tc);\n\n    //if(uvI.y > 0.0 || uvI.x < 0.0 || uvI.x > 3.0) { v = 0.0; k = 0.0; }\n\n    return vec2(v, k);\n}\n\n//===============================================================================//\n///////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    Resolution = iResolution.xy;\n\n    float num = ReadVar(4, 0);\n\n    ivec2 uv = ivec2(uv0.xy - 0.5);\n\tvec2 tex = uv0.xy / iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n        \n    vec2 ao = textureLod(iChannel0, tex, 0.0).rg;\n    //num=1.0;\n    if(num == 0.0)// split screen: gtvbao | ray-marched reference\n    {\n        col = vec3(uv0.x > iResolution.x * 0.5 ? ao.x : ao.y);\n    }\n    else if(num == 1.0)// gtvbao\n    {\n        col = vec3(ao.y);\n    }\n    else if(num == 2.0)// ray-marched reference\n    {\n        col = vec3(ao.x);\n    }\n    else if(num == 3.0 || num == 4.0)// visualize error\n    {\n        float diff = (ao.y - ao.x) * 8.0;\n        \n        if(num == 3.0)\n        {\n            col = vec3(0.5 + diff*2.0);\n        }\n        else// num == 4.0: gtvbao brighter than ref -> red | gtvbao darker than ref -> blue\n        {\n            col = abs(diff) * 3.0 * (diff > 0.0 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.18, 1.0));\n        }\n    }\n    else if(num == 5.0 || num == 6.0)// visualize error blurred\n    {\n        float count = 10.0;\n        float wa = 0.0;\n        \n        for(float j = -count; j <= count; ++j)\n        for(float i = -count; i <= count; ++i)\n        {\n            vec2 o = vec2(i, j);\n            vec2 w2 = pow(1.0 - pow(abs(o)/(count+0.5), vec2(2.0)), vec2(1.0));\n            \n            float w = 1.0;\n            w = w2.x * w2.y;\n            \n            vec2 ao = textureLod(iChannel0, (uv0 + o) / iResolution.xy, 0.0).rg;\n            \n            float diff = (ao.y - ao.x) * 8.0;\n\n            vec3 col0;\n            \n            if(num == 5.0)\n            {\n                col0 = vec3(abs(diff));\n                col0 = vec3(0.5 + diff*2.0);\n            }\n            else\n            {\n                col0 = abs(diff) * 3.0 * (diff > 0.0 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.18, 1.0));\n            }\n        \n            col += col0 * w;\n            wa += w;\n        }\n        \n        col /= wa;\n    }\n    \n    #if 0\n    if(num < 3.0 && ReadKeyToggle(KEY_S) != 0.0)\n    {\n        // isolines\n        col = 1.0-(cos(col * 32.0) * 0.5 + 0.5);\n    }\n    #endif\n    \n    // highlight pixels green if they clip beneath 0 or above 1: \n    if(ReadKeyToggle(KEY_N) != 0.0)\n    if(col.r < 0.0 || col.r > 1.0 || col.g < 0.0 || col.g > 1.0 || col.b < 0.0 || col.b > 1.0) col.rgb = vec3(0.0, 1.0, 0.0);\n    \n    outCol = vec4(pow(clamp01(col), vec3(1.0/2.2)), 0.0);\n    \n    \n    if(SHOW_UI_COND)\n    {\n        bvec2 modes = bvec2(USE_UNIFORM_HEMISHPHERE_WEIGHTING);\n        \n        vec2 ui = EvalUI(uv0, min(num, 3.0), modes.xx);\n        \n        outCol.rgb = mix(outCol.rgb, vec3(ui.y) * mix(vec3(0., 0.6, 1.0), vec3(1.0), 0.9), ui.x);\n    }    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n    This work is licensed under a dual license, public domain and MIT, unless noted otherwise. Chose which one suits your needs best:\n    \n    CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n    To the extent possible under law, the author has waived all copyrights and related or neighboring rights to this work.\n    \n    or\n    \n    The MIT License\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), \n    to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, \n    and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR \n    THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/*\n    Input logic\n*/\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 2), 0).x;}\n\n#define VarTex iChannel3\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == uint(cx) && uv.y == uint(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{     \n    Resolution = iResolution.xy;\n\n    uvec2 uv = uvec2(uv0.xy - 0.5);\n\n    outCol = vec4( 0.0);\n        \n    // program state:\n    {\n        vec4 iMouseLast     = ReadVar4(0, 0);\n        vec4 iMouseAccuLast = ReadVar4(1, 0);\n        vec4 wasdAccuLast   = ReadVar4(2, 0);\n        float frameAccuLast = ReadVar (3, 0);\n        float num           = ReadVar (4, 0);\n        \n\n        bool shift = ReadKey(KEY_SHIFT) != 0.0;\n\n        float kW = ReadKey(KEY_W);\n        float kA = ReadKey(KEY_A);\n        float kS = ReadKey(KEY_S);\n        float kD = ReadKey(KEY_D);\n\n        float left  = ReadKey(KEY_LEFT);\n        float right = ReadKey(KEY_RIGHT);\n        float up    = ReadKey(KEY_UP);\n        float down  = ReadKey(KEY_DOWN);\n        \n        if(ReadKey(KEY_N1) != 0.0) num = 0.0;\n        if(ReadKey(KEY_N2) != 0.0) num = 1.0;\n        if(ReadKey(KEY_N3) != 0.0) num = 2.0;\n        if(ReadKey(KEY_N4) != 0.0) num = 3.0;\n        if(ReadKey(KEY_N5) != 0.0) num = 4.0;\n        if(ReadKey(KEY_N6) != 0.0) num = 5.0;\n        if(ReadKey(KEY_N7) != 0.0) num = 6.0;\n        \n        bool anyK = false;\n        \n        anyK = anyK || iMouse.z > 0.0;\n        anyK = anyK || shift;\n        anyK = anyK || kW != 0.0;\n        anyK = anyK || kA != 0.0;\n        anyK = anyK || kS != 0.0;\n        anyK = anyK || kD != 0.0;\n        anyK = anyK || left  != 0.0;\n        anyK = anyK || right != 0.0;\n        anyK = anyK || up    != 0.0;\n        anyK = anyK || down  != 0.0;\n        anyK = anyK || ReadKey(KEY_TAB) != 0.0;\n        anyK = anyK || ReadKey(KEY_SHIFT) != 0.0;\n        anyK = anyK || ReadKey(KEY_SPACE) != 0.0;\n        anyK = anyK || ReadKey(KEY_CTRL) != 0.0;\n        \n        float frameAccu = frameAccuLast;\n        //if(anyK) frameAccuLast = 0.0;\n        \n\n        vec4 wasdAccu = wasdAccuLast;\n        wasdAccu += vec4(kW, kA, kS, kD);\n        wasdAccu += vec4(up, left, down, right);        \n\n        \n        vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n\n\n\n        bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n        vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n        vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n\n        vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n\n        if(cond0 && dot(abs(mouseDelta), vec2(1.0)) != 0.0) frameAccu = 0.0;\n        if(ReadKey(KEY_TAB ) != 0.0) frameAccu = 0.0;\n        if(ReadKey(KEY_CTRL) != 0.0) frameAccu = 0.0;\n        if(ReadKey(KEY_R   ) != 0.0) frameAccu = 0.0;\n        if(ReadKey(KEY_W   ) != 0.0) frameAccu = 0.0;\n        if(ReadKey(KEY_SPACE) != 0.0) frameAccu = 0.0;\n        \n        frameAccu += 1.0;\n        \n        vec4 toggles = vec4(\n        ReadKeyToggle(KEY_TAB  ) != 0.0 ? 1.0 : 0.0,\n        ReadKeyToggle(KEY_SHIFT) != 0.0 ? 1.0 : 0.0,\n        ReadKeyToggle(KEY_SPACE) != 0.0 ? 1.0 : 0.0,\n        ReadKeyToggle(KEY_CTRL ) != 0.0 ? 1.0 : 0.0);\n        \n        WriteVar4(iMouse,        0, 0);\n        WriteVar4(iMouseAccu,    1, 0);\n        WriteVar4(wasdAccu,      2, 0);\n        WriteVar (frameAccu,     3, 0);\n        WriteVar (num,           4, 0);\n        WriteVar4(iMouseAccuLast,5, 0);\n        WriteVar4(toggles       ,6, 0);\n\n        #if 0\n        PrepareCam(iMouseAccuLast, false);\n        \n        WriteVar (cdist,         5, 0);\n        WriteVar (focalLen,      5, 1);\n        WriteVar4(cmat2[0].xyzz, 6, 0);\n        WriteVar4(cmat2[1].xyzz, 7, 0);\n        WriteVar4(cmat2[2].xyzz, 8, 0);\n        WriteVar4(   cpos2.xyzz, 9, 0);\n        #endif\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n    This work is licensed under a dual license, public domain and MIT, unless noted otherwise. Chose which one suits your needs best:\n    \n    CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n    To the extent possible under law, the author has waived all copyrights and related or neighboring rights to this work.\n    \n    or\n    \n    The MIT License\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), \n    to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, \n    and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR \n    THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nvec2 Resolution;\n\n#define USE_TEMP_ACCU_COND                (ReadKeyToggle(KEY_TAB  ) != 0.0)\n#define USE_UNIFORM_HEMISHPHERE_WEIGHTING (ReadKeyToggle(KEY_SPACE) != 0.0)\n#define USE_PERSPECTIVE_CAM_COND          (ReadKeyToggle(KEY_CTRL ) == 0.0)\n#define SHOW_UI_COND                      (ReadKeyToggle(KEY_U    ) == 0.0)\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////// misc\n//==========================================================================================================//\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n\n#define KEY_Q 81\n#define KEY_W 87\n#define KEY_E 69\n#define KEY_R 82\n#define KEY_T 84\n\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_F 70\n#define KEY_G 71\n\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_U 85\n\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float RcpPi = 1.0 / Pi;\nconst float Pi05 = Pi * 0.5;\nconst float RcpPi05 = 1.0 / Pi05;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////// camera logic + transforms\n//==========================================================================================================//\nbool isPerspectiveCam;// ortho/proj cam toggle\nfloat cdist, nearZ;// camera dist from origin + z-near\nmat3 cmat;// camera matrix\nvec3 cpos;// camera pos\nmat4 pmat, ipmat;// proj matrix + inverse\n\nvoid PrepareCam(vec4 mouseAccu, bool isPerspectiveCam0)\n{\n    isPerspectiveCam = isPerspectiveCam0;\n    \n    vec2 ang = vec2(Pi * 0.25, Pi * -0.1);\n   // ang = vec2(Pi05, Pi * -0.5);// start top-down\n    ang += mouseAccu.xy * 0.008;\n\n    vec3 front, right, up;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        front = vec3(cosPhi * cosTheta, \n                              sinTheta, \n                     sinPhi * cosTheta);\n\n        right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        up    = vec3(-cosPhi * sinTheta,\n                               cosTheta,\n                     -sinPhi * sinTheta);\n        \n    }\n\n    cmat = mat3(right, up, front);\n    \n    cdist = exp2(1.5 + mouseAccu.w * 0.02);\n\n    float aspect = Resolution.x / Resolution.y;\n\n    vec2 vpSize = vec2(1.0, 1.0 / aspect) * 2.0;// viewport size at focal length\n\n    if(!isPerspectiveCam) vpSize *= cdist;\n\n    nearZ = isPerspectiveCam ? 0.125 : 0.0;\n\n   #if 1\n    float focalLen = 0.8;// = cot(fov * 0.5) for w == 2\n\n    float w = vpSize.x;\n    float h = vpSize.y;\n\n    float m00 = 2.0 * focalLen / w;\n    float m11 = 2.0 * focalLen / h;\n   #else \n\n    float fovX = 0.570447 * Pi;// 2 * arccot(focalLen) fpr w == 2\n    float m00 = cos(fovX * 0.5) / sin(fovX * 0.5);\n    float m11 = m00 * aspect;\n   #endif\n    \n    \n    float m23 = -nearZ;\n    float m32 = 1.0;\n    \n    float m33 = 0.0;\n    \n    if(!isPerspectiveCam)\n    {\n        m00 = 2.0 / vpSize.x;\n        m11 = 2.0 / vpSize.y;\n    \n        m23 = m32 = 0.0;\n        m33 = 1.0;\n    }    \n    \n    pmat = mat4(m00, 0.0, 0.0, 0.0,\n                0.0, m11, 0.0, 0.0,\n                0.0, 0.0, 1.0, m32,\n                0.0, 0.0, m23, m33);\n    \n    float i00 = 1.0 / m00;\n    float i11 = 1.0 / m11;\n    \n    float i22 = 0.0;\n    \n    float i23 = 1.0;\n    float i32 =-1.0/nearZ;\n    \n    float i33 = 1.0/nearZ;\n    \n    if(!isPerspectiveCam)\n    {\n        i22 = i33 = 1.0;\n        i23 = i32 = 0.0;\n    }\n                \n    ipmat = mat4(i00, 0.0, 0.0, 0.0,\n                 0.0, i11, 0.0, 0.0,\n                 0.0, 0.0, i22, i32,\n                 0.0, 0.0, i23, i33);\n    \n    \n    if(isPerspectiveCam)\n    {\n        cpos = -front * cdist;\n    }\n    else\n    {\n        cpos = -front * 8.0;\n    }    \n}\n\nfloat LinDepth_from_NonLinDepth(float depth)\n{\n    if(!isPerspectiveCam) return depth;\n    \n    //1.0 / (-depth/nearZ + 1.0/nearZ);\n    //1.0 / ((-depth + 1.0)/nearZ);\n    //nearZ / (-depth + 1.0);\n    return nearZ / (1.0 - depth);\n}\n\nfloat NonLinDepth_from_LinDepth(float depth)\n{\n    if(!isPerspectiveCam) return depth;\n\n    //return (depth - n) / depth;\n    return 1.0 - nearZ / depth;\n}\n\n\n// ====== View <-> World ====== //\nvec3 VPos_from_WPos(vec3 wpos)\n{\n    return (wpos - cpos) * cmat;\n}\n\nvec3 VVec_from_WVec(vec3 wvec)\n{\n    return wvec * cmat;\n}\n\n////\n\nvec3 WPos_from_VPos(vec3 vpos)\n{\n    return cmat * vpos + cpos;\n}\n\nvec3 WVec_from_VVec(vec3 vvec)\n{\n    return cmat * vvec;\n}\n// =========================== //\n\n// ====== Proj <-> View ====== //\nvec4 PPos_from_VPos(vec3 vpos)\n{\n    return pmat * vec4(vpos, 1.0);\n}\n\nvec3 VPos_from_PPos(vec4 ppos)\n{\n    vec4 vpos = ipmat * ppos;\n    \n    return vpos.xyz / vpos.w;\n}\n\nvec4 PVec_from_VVec(vec3 vvec)\n{\n    return pmat * vec4(vvec, 0.0);\n}\n// =========================== //\n\n\n// ====== Screen <-> View ====== //\nvec3 SPos_from_VPos(vec3 vpos)\n{\n    vec4 ppos = PPos_from_VPos(vpos);\n    \n    vec2 tc21 = ppos.xy / ppos.w;\n    \n    vec2 uv0 = (tc21 * 0.5 + 0.5) * Resolution;\n    \n    return vec3(uv0, vpos.z);\n}\n\nvec3 SVec_from_VVec_Ortho(vec3 vvec)\n{\n    vec4 pvec = PVec_from_VVec(vvec);\n    \n    vec2 xy = (pvec.xy * 0.5) * Resolution;\n    \n    return vec3(xy, vvec.z);\n}\n////\n\nvec3 VPos_from_SPos(vec3 spos)\n{\n    vec2 uv0 = spos.xy;\n    float depth = spos.z;\n          depth = NonLinDepth_from_LinDepth(depth);\n    \n    vec2 tc21 = uv0 / Resolution * 2.0 - 1.0;\n    \n    vec3 ppos = vec3(tc21, depth);\n    \n    vec4 vpos = ipmat * vec4(ppos, 1.0); \n    \n    vpos /= vpos.w;\n    \n    return vpos.xyz;  \n}\n// ============================= //\n\n// ====== Proj <-> World ====== //\nvec4 PPos_from_WPos(vec3 wpos)\n{\n    vec3 vpos = VPos_from_WPos(wpos);\n    \n    return PPos_from_VPos(vpos);\n}\n\nvec3 WPos_from_PPos(vec4 ppos)\n{\n    vec3 vpos = VPos_from_PPos(ppos);\n    \n    return WPos_from_VPos(vpos);\n}\n\nvec4 PVec_from_WVec(vec3 wvec)\n{\n    vec3 vvec = VVec_from_WVec(wvec);\n    \n    return PVec_from_VVec(vvec);\n}\n// =========================== //\n\n// ====== Screen <-> World ====== //\nvec3 SPos_from_WPos(vec3 wpos)\n{\n    vec3 vpos = VPos_from_WPos(wpos);\n\n    return SPos_from_VPos(vpos);\n}\n\n////\n\nvec3 WPos_from_SPos(vec3 spos)\n{\n    vec3 vpos = VPos_from_SPos(spos);\n\n    return WPos_from_VPos(vpos);\n}\n// ============================== //\n\nvoid GetRay(vec2 uv0, out vec3 rp, out vec3 rd)\n{\n    vec3 spos = vec3(uv0, nearZ);\n    \n    vec3 vpos = VPos_from_SPos(spos); \n\n    if(isPerspectiveCam)\n    {\n        rp = cpos;\n        rd = WVec_from_VVec(normalize(vpos)); \n    }\n    else\n    {\n        rp = WPos_from_VPos(vpos); \n        rd = cmat[2];\n    }\n}\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////// intersection routines\n//==========================================================================================================//\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\nbvec2 minmask(vec2 v)\n{\n    bool x = v.x < v.y || isnan(v.y);\n    \n    return bvec2(x, !x);\n}\n\n\nbvec2 maxmask(vec2 v)\n{\n    bool x = v.x >= v.y || isnan(v.y);\n    \n    return bvec2(x, !x);\n}\n\n\nbvec3 minmask(vec3 v)\n{    \n    return bvec3(v.x <= v.y && v.x <= v.z,\n                 v.y <  v.z && v.y <  v.x,\n                 v.z <  v.x && v.z <= v.y);\n}\n\nbvec3 maxmask(vec3 v)\n{\n    return bvec3(v.x >= v.y && v.x >= v.z,\n                 v.y >  v.z && v.y >  v.x,\n                 v.z >  v.x && v.z >= v.y);\n}\n\nbvec3 minmask2(vec3 v)\n{\n    bool x = !(v.x >  v.y || v.x >  v.z) && !isnan(v.x);\n    bool y = !(v.y >= v.z || v.y >= v.x) && !isnan(v.y);\n    \n    return bvec3(x, y, !(x || y));\n}\n\nbvec3 maxmask2(vec3 v)\n{\n    bool x = !(v.x <  v.y || v.x <  v.z) && !isnan(v.x);\n    bool y = !(v.y <= v.z || v.y <= v.x) && !isnan(v.y);\n    \n    return bvec3(x, y, !(x || y));\n}\n\nvoid Intersect_Ray_CubeBackside(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout float t, out vec3 N)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n\tvec3 o = -cth * os;\n\t\n\tvec3 ub = (rp - o) * m;\n\t\n    bvec3 mb = minmask2(ub);\n    \n    N = os * vec3(mb);\n    \n    t = mb.x ? ub.x : mb.y ? ub.y : ub.z;\n}\n\nbool IsInsideCube(vec3 p, vec3 cp, vec3 cd)\n{\n    vec3 b = abs(p - cp);\n    \n    return b.x < cd.x && b.y < cd.y && b.z < cd.z;\n}\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////// scene intersection\n//==========================================================================================================//\nvoid Intersect_Ray_Cube(vec3 rp, vec3 rd, vec3 c0p, vec3 c0d, \n                        inout float hit, inout float t, inout vec3 n)\n{\n    vec2 tt; vec3 n0, n1;\n    float th = Intersect_Ray_Cube(rp, rd, c0p, c0d, /*out:*/ tt, n0, n1);\n\n    if(th > 0.0)\n    if(hit <= 0.0 || tt.x < t)\n    {\n        t = tt.x;\n        n = n0;\n\n        hit = 1.0;\n    }        \n}\n\nfloat Intersect_Scene(\nvec3 rp, vec3 rd,\nout float t, out vec3 n, out vec3 a)\n{\n    float hit = 0.0;\n\n    float c1dxz = 0.4;\n    float c1ps = 0.85;\n\n    // ground plate thingy:\n    //if(false)\n    {\n        vec3 c0p = vec3(0.0, -0.8, 0.0);\n        vec3 c0d = vec3(2.0, 0.125*1.2, 2.0);//0.5\n        \n        vec3 c1p = vec3(0.0, -0.64, 0.0);\n        vec3 c1d = vec3(2.5, 0.125, 1.5);\n         c1d = vec3(c1dxz, 0.125, c1dxz);\n        \n        \n        c1p.xz = (floor(rp.xz*c1ps+0.5))/c1ps;\n        \n        bool isInsideC0 = IsInsideCube(rp, c0p, c0d);\n        bool isInsideC1 = IsInsideCube(rp, c1p, c1d);\n        \n        if(isInsideC0 && isInsideC1)\n        {\n            float t0; vec3 n0;\n            Intersect_Ray_CubeBackside(rp, rd, c1p, c1d, t0, n0);\n            \n            if(IsInsideCube(rp+rd*t0, c0p, c0d))\n            {\n                hit = 1.0;\n                t = t0;\n                n = n0;\n            }\n        }\n        else\n        {\n            vec2 tt; vec3 n0, n1;\n            float th = Intersect_Ray_Cube(rp, rd, c0p, c0d, /*out:*/ tt, n0, n1);\n\n            hit = th > 0.0 ? 1.0 : 0.0;\n            t = tt.x;\n            n = n0;\n            a = vec3(1.0, 0.005, 0.005) * 0.8;\n            \n            if(hit==1.0) c1p.xz = (floor((rp.xz+rd.xz*t)*c1ps+0.5))/c1ps;\n            if(hit==1.0 && IsInsideCube(rp+rd*t, c1p, c1d))\n            {\n                float t0; vec3 n0;\n                Intersect_Ray_CubeBackside(rp, rd, c1p, c1d, t0, n0);\n\n                if(IsInsideCube(rp+rd*t0, c0p, c0d))\n                {\n                    t = t0;\n                    n = n0;                \n                }\n                else\n                {\n                    hit = 0.0;\n                }\n            }\n        }\n    }\n    \n    // slim pillars:\n    //if(false)\n    {\n        float r = 0.125*0.25;\n        float u = 1.0/c1ps;\n        float l = 0.4;\n        float h = 1.0;\n        \n        vec3 c0p = vec3(c1dxz, l, c1dxz);\n         c0p = vec3(u - c1dxz, l, u - c1dxz);\n         c0p = vec3(u - c1dxz, l, c1dxz);\n        vec3 c0d = vec3(r, h, r);\n        \n        vec3 pa = vec3(u - c1dxz, l,     c1dxz);\n        vec3 pb = vec3(u - c1dxz, l, u - c1dxz);\n        vec3 pc = vec3(    c1dxz, l, u - c1dxz);\n        \n        //Intersect_Ray_Cube(rp, rd, c0p, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pa, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pb, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pc, c0d, /*inout*/ hit, t, n);\n        \n        pa = vec3(-pa.z, pa.y, pa.x);\n        pb = vec3(-pb.z, pb.y, pb.x);\n        pc = vec3(-pc.z, pc.y, pc.x);\n        \n        Intersect_Ray_Cube(rp, rd, pa, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pb, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pc, c0d, /*inout*/ hit, t, n);\n        \n        pa = vec3(-pa.z, pa.y, pa.x);\n        pb = vec3(-pb.z, pb.y, pb.x);\n        pc = vec3(-pc.z, pc.y, pc.x);\n        \n        #if 0\n        Intersect_Ray_Cube(rp, rd, pa, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pb, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pc, c0d, /*inout*/ hit, t, n);\n        #endif\n        \n        pa = vec3(-pa.z, pa.y, pa.x);\n        pb = vec3(-pb.z, pb.y, pb.x);\n        pc = vec3(-pc.z, pc.y, pc.x);\n        \n        Intersect_Ray_Cube(rp, rd, pa, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pb, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pc, c0d, /*inout*/ hit, t, n);\n    }\n    \n    // top sphere:\n    //if(false)\n    {\n        vec2 tt;\n\t\tfloat th = Intersect_Ray_Sphere(rp, rd, vec3(0.0), 0.5, /*out:*/ tt);\n        \n        if(th > 0.0)\n        if(hit <= 0.0 || tt.x < t)\n        {\n            t = tt.x;\n            n = normalize(rp + rd * tt.x);\n            a = vec3(1.0);\n            \n            hit = 1.0;\n        }\n    }\n    \n    // bottom sphere:\n    if(false)\n    {\n        vec2 tt;\n\t\tfloat th = Intersect_Ray_Sphere(rp, rd, vec3(0.0, -2.25, 0.0), 2.0, /*out:*/ tt);\n        \n        if(th > 0.0)\n        if(hit <= 0.0 || tt.x < t)\n        {\n            t = tt.x;\n            n = normalize(rp + rd * tt.x - vec3(0.0, -2.25, 0.0));\n            a = vec3(1.0);\n            \n            hit = 1.0;\n        }\n    }\n    \n    if(hit <= 0.0)\n    {\n        t = exp2(20.0);\n        n = vec3(0.0);\n        a = vec3(0.0);\n    }\n    \n    return hit;\n}\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////// sampling routines\n//==========================================================================================================//\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(1.0 - s1*s1);\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\nvec3 Sample_Sphere(vec2 s) { return Sample_Sphere(s.x, s.y); }\n\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// interleaved gradient noise | license: unclear\n// Jorge Jimenez http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\nfloat IGN(vec2 uv) { return fract(52.9829189 * fract(dot(uv, vec2(0.06711056, 0.00583715)))); }\n\nfloat IGN(vec2 uv, uint frame)\n{\n    frame = frame % 64u;\n    \n    uv += 5.588238 * float(frame);\n    \n    return IGN(uv);\n}\n\n// linearizes uv using a Hilbert curve; tile dimension = 2^N\nuint EvalHilbertCurve(uvec2 uv, uint N)\n{\n    uint C = 0xB4361E9Cu;// cost lookup\n    uint P = 0xEC7A9107u;// pattern lookup\n    \n    uint c = 0u;// accumulated cost\n    uint p = 0u;// current pattern\n\n    for(uint i = N; --i < N;)\n    {\n        uvec2 m = (uv >> i) & 1u;// local uv\n\n        uint n = m.x ^ (m.y << 1u);// linearized local uv\n\n        uint o = (p << 3u) ^ (n << 1u);// offset into lookup tables\n\n        c += ((C >> o) & 3u) << (i << 1u);// accu cost (scaled by level)\n\n        p = (P >> o) & 3u;// update pattern\n    }\n    \n    return c;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////// low-discrepancy sobol noise\n//==========================================================================================================//\n// \"Shuffled Scrambled Sobol (2D)\" - https://www.shadertoy.com/view/3lcczS | license: unclear\n//  code taken from \"Practical Hash-based Owen Scrambling\" - http://www.jcgt.org/published/0009/04/01/\nuint reverse_bits(uint x) \n{\n    x = (((x & 0xaaaaaaaau) >> 1) | ((x & 0x55555555u) << 1));\n    x = (((x & 0xccccccccu) >> 2) | ((x & 0x33333333u) << 2));\n    x = (((x & 0xf0f0f0f0u) >> 4) | ((x & 0x0f0f0f0fu) << 4));\n    x = (((x & 0xff00ff00u) >> 8) | ((x & 0x00ff00ffu) << 8));\n    \n    return ((x >> 16) | (x << 16));\n}\n\n// license: unclear\nuint laine_karras_permutation(uint x, uint seed) \n{\n    x += seed;\n    x ^= x*0x6c50b47cu;\n    x ^= x*0xb82f1e52u;\n    x ^= x*0xc7afe638u;\n    x ^= x*0x8d22f6e6u;\n    \n    return x;\n}\n\n// license: unclear\nuint nested_uniform_scramble(uint x, uint seed) \n{\n    x = reverse_bits(x);\n    x = laine_karras_permutation(x, seed);\n    x = reverse_bits(x);\n    \n    return x;\n}\n\n// from https://www.shadertoy.com/view/3ldXzM | license: unclear\nuvec2 sobol_2d(uint index) \n{\n    uvec2 p = uvec2(0u);\n    uvec2 d = uvec2(0x80000000u);\n\n    for(; index != 0u; index >>= 1u) \n    {\n        if((index & 1u) != 0u) \n        {\n            p ^= d;\n        }\n\n        d.x >>= 1u;  // 1st dimension Sobol matrix, is same as base 2 Van der Corput\n        d.y ^= d.y >> 1u; // 2nd dimension Sobol matrix\n    }\n    \n    return p;\n}\n\n// license: unclear\nuvec2 shuffled_scrambled_sobol_2d(uint index, uint seed) \n{\n    index = nested_uniform_scramble(index, seed);\n    \n    uvec2 p = sobol_2d(index);\n    \n    seed = seed * 2891336453u + 1u;\n    p.x = nested_uniform_scramble(p.x, seed );\n    seed = seed * 2891336453u + 1u;\n    p.y = nested_uniform_scramble(p.y, seed);\n   \n    return p;\n}\n\nuint shuffled_scrambled_sobol_angle01(uint x, uint seed) \n{\n    x = reverse_bits(x);\n    \n    x = laine_karras_permutation(x, seed);\n    \n    return x;\n}\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// RNG\n//==============================================================================================================================================//\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/\nconst float rPhif1 =      0.6180340;\nconst vec2  rPhif2 = vec2(0.7548777, 0.5698403);\nconst vec3  rPhif3 = vec3(0.8191725, 0.6710436, 0.5497005);\nconst vec4  rPhif4 = vec4(0.8566749, 0.7338919, 0.6287067, 0.5385973);\n\nconst uint  rPhi1 =       2654435769u;\nconst uvec2 rPhi2 = uvec2(3242174889u, 2447445413u);\nconst uvec3 rPhi3 = uvec3(3518319153u, 2882110345u, 2360945575u);\nconst uvec4 rPhi4 = uvec4(3679390609u, 3152041523u, 2700274805u, 2313257605u);\n\n// low bias version | https://nullprogram.com/blog/2018/07/31/ | license: public domain (http://unlicense.org/)\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\n// minimal bias version | https://nullprogram.com/blog/2018/07/31/ | license: public domain (http://unlicense.org/)\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html | license: public domain (http://unlicense.org/)\nuint WeylHash(uvec2 c)\n{ \n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u;\n}\n\n// Pierre L'Ecuyer - \"TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD LATTICE STRUCTURE\"\n// https://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf\nconst uint lcgM = 2891336453u;// ideal for 32 bits with odd c\n\nuint lcg(uint h)\n{\n    return h * lcgM + 0x5C995C6Du;\n}\n\n#define SEED uvec4(0x5C995C6Du, 0x6A3C6A57u, 0xC65536CBu, 0x3563995Fu)\n\n// Melissa E. O’Neill - \"PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation\"\n// https://www.cs.hmc.edu/tr/hmc-cs-2014-0905.pdf\n\n// Mark Jarzynski & Marc Olano - \"Hash Functions for GPU Rendering\"\n// http://jcgt.org/published/0009/03/02/ | https://www.shadertoy.com/view/XlGcRh\nuvec3 pcg3Mix(uvec3 h)\n{\n    h.x += h.y * h.z; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    \n    return h;\n}\n\nuvec3 pcg3Permute(uvec3 h)\n{\n    h = pcg3Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg3Mix(h);\n}\n\nuvec3 pcg3(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg3Permute(uvec3(2447445413u, state, 3242174889u));\n}\n\nuvec3 pcg3(uvec3 h, uint seed)\n{\n    uvec3 c = (seed << 1u) ^ SEED.xyz;\n    \n    return pcg3Permute(h * lcgM + c);\n}\n\nuvec4 pcg4Mix(uvec4 h)\n{\n    h.x += h.y * h.w; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    h.w += h.y * h.z;\n    \n    return h;\n}\n\nuvec4 pcg4Permute(uvec4 h)\n{\n    h = pcg4Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg4Mix(h);\n}\n\nuvec4 pcg4(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg4Permute(uvec4(2882110345u, state, 3518319153u, 2360945575u));\n}\n\nuvec4 pcg4(uvec4 h, uint seed)\n{\n    uvec4 c = (seed << 1u) ^ SEED;\n\n    return pcg4Permute(h * lcgM + c);\n}\n\nuint pcg(inout uint state)\n{\n    state = lcg(state);\n    \n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    \n    return (word >> 22u) ^ word;\n}\n\nuint pcg(uint h, uint seed)\n{\n    uint c = (seed << 1u) ^ SEED.x;\n\n    h = h * lcgM + c;\n    \n    h = ((h >> ((h >> 28u) + 4u)) ^ h) * 277803737u;\n    \n    return (h >> 22u) ^ h;\n}\n\n#undef SEED\n\n//---------------------------------------------------------------------------------------------//\n\nuint  Hash(uint  h, uint seed) { return pcg(h, seed); }\nuvec2 Hash(uvec2 h, uint seed) { return pcg3(uvec3(h, 0u), seed).xy; }\nuvec3 Hash(uvec3 h, uint seed) { return pcg3(h, seed); }\nuvec4 Hash(uvec4 h, uint seed) { return pcg4(h, seed); }\n\nvec4 Hash01x4(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed)); }\nvec4 Hash01x4(vec3  v, uint seed) { return Hash01x4(vec4(v, 0.0          ), seed); }\nvec4 Hash01x4(vec2  v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash01x4(float v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash01x3(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash01x3(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed)); }\nvec3 Hash01x3(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed); }\nvec3 Hash01x3(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash01x2(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash01x2(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash01(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).x); }\nfloat Hash01(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).x); }\nfloat Hash01(vec2  v, uint seed) { return Float01(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash01(float v, uint seed) { return Float01(pcg(asuint2(v), seed)); }\n\n\nvec4 Hash11x4(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed)); }\nvec4 Hash11x4(vec3  v, uint seed) { return Hash11x4(vec4(v, 0.0          ), seed); }\nvec4 Hash11x4(vec2  v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash11x4(float v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash11x3(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash11x3(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed)); }\nvec3 Hash11x3(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed); }\nvec3 Hash11x3(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash11x2(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash11x2(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash11(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).x); }\nfloat Hash11(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).x); }\nfloat Hash11(vec2  v, uint seed) { return Float11(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash11(float v, uint seed) { return Float11(pcg(asuint2(v), seed)); }\n\n\nvec4 Hash01x4(uvec4 v, uint seed) { return Float01(pcg4(v, seed)); }\nvec4 Hash01x4(uvec3 v, uint seed) { return Hash01x4(uvec4(v, 0u        ), seed); }\nvec4 Hash01x4(uvec2 v, uint seed) { return Hash01x4(uvec4(v, 0u, 0u    ), seed); }\nvec4 Hash01x4(uint  v, uint seed) { return Hash01x4(uvec4(v, 0u, 0u, 0u), seed); }\n\nvec3 Hash01x3(uvec4 v, uint seed) { return Float01(pcg4(v, seed).xyz); }\nvec3 Hash01x3(uvec3 v, uint seed) { return Float01(pcg3(v, seed)); }\nvec3 Hash01x3(uvec2 v, uint seed) { return Hash01x3(uvec3(v, 0u    ), seed); }\nvec3 Hash01x3(uint  v, uint seed) { return Hash01x3(uvec3(v, 0u, 0u), seed); }\n\nvec2 Hash01x2(uvec4 v, uint seed) { return Float01(pcg4(v, seed).xy); }\nvec2 Hash01x2(uvec3 v, uint seed) { return Float01(pcg3(v, seed).xy); }\nvec2 Hash01x2(uvec2 v, uint seed) { return Hash01x3(uvec3(v, 0u    ), seed).xy; }\nvec2 Hash01x2(uint  v, uint seed) { return Hash01x3(uvec3(v, 0u, 0u), seed).xy; }\n\nfloat Hash01(uvec4 v, uint seed) { return Float01(pcg4(v, seed).x); }\nfloat Hash01(uvec3 v, uint seed) { return Float01(pcg3(v, seed).x); }\nfloat Hash01(uvec2 v, uint seed) { return Float01(pcg3(uvec3(v, 0u), seed).x); }\nfloat Hash01(uint  v, uint seed) { return Float01(pcg(v, seed)); }\n\n\nvec4 Hash11x4(uvec4 v, uint seed) { return Float11(pcg4(v, seed)); }\nvec4 Hash11x4(uvec3 v, uint seed) { return Hash11x4(uvec4(v, 0u        ), seed); }\nvec4 Hash11x4(uvec2 v, uint seed) { return Hash11x4(uvec4(v, 0u, 0u    ), seed); }\nvec4 Hash11x4(uint  v, uint seed) { return Hash11x4(uvec4(v, 0u, 0u, 0u), seed); }\n\nvec3 Hash11x3(uvec4 v, uint seed) { return Float11(pcg4(v, seed).xyz); }\nvec3 Hash11x3(uvec3 v, uint seed) { return Float11(pcg3(v, seed)); }\nvec3 Hash11x3(uvec2 v, uint seed) { return Hash11x3(uvec3(v, 0u    ), seed); }\nvec3 Hash11x3(uint  v, uint seed) { return Hash11x3(uvec3(v, 0u, 0u), seed); }\n\nvec2 Hash11x2(uvec4 v, uint seed) { return Float11(pcg4(v, seed).xy); }\nvec2 Hash11x2(uvec3 v, uint seed) { return Float11(pcg3(v, seed).xy); }\nvec2 Hash11x2(uvec2 v, uint seed) { return Hash11x3(uvec3(v, 0u    ), seed).xy; }\nvec2 Hash11x2(uint  v, uint seed) { return Hash11x3(uvec3(v, 0u, 0u), seed).xy; }\n\nfloat Hash11(uvec4 v, uint seed) { return Float11(pcg4(v, seed).x); }\nfloat Hash11(uvec3 v, uint seed) { return Float11(pcg3(v, seed).x); }\nfloat Hash11(uvec2 v, uint seed) { return Float11(pcg3(uvec3(v, 0u), seed).x); }\nfloat Hash11(uint  v, uint seed) { return Float11(pcg(v, seed)); }\n\n//==============================================================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*\n    This work is licensed under a dual license, public domain and MIT, unless noted otherwise. Chose which one suits your needs best:\n    \n    CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n    To the extent possible under law, the author has waived all copyrights and related or neighboring rights to this work.\n    \n    or\n    \n    The MIT License\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), \n    to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, \n    and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR \n    THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/*\n    G-buffer rendering: vec4(world space normal.xyz, linear depth)\n    \n    Camera controls via mouse + shift key.\n*/\n\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 2), 0).x;}\n\n#define VarTex iChannel3\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == uint(cx) && uv.y == uint(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{     \n    Resolution = iResolution.xy;\n    \n    uvec2 uv = uvec2(uv0.xy - 0.5);\n\tvec2 tex = uv0.xy / iResolution.xy;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    uint frame = uint(iFrame);\n    \n    vec4 mouseAccu  = ReadVar4(1, 0);\n    vec4 wasdAccu   = ReadVar4(2, 0);\n    float frameAccu = ReadVar (3, 0);\n    vec4 mouseAccuLast = ReadVar4(5, 0);\n\n    PrepareCam(mouseAccu, USE_PERSPECTIVE_CAM_COND);\n    \n    vec3 rp, rd;\n    GetRay(uv0, /*out*/ rp, rd);\n    \n    float t; vec3 N; vec3 a;\n    Intersect_Scene(rp, rd, /*out:*/ t, N, a);    \n    \n    vec3 wpos = rp + rd * t;\n    \n    vec3 vpos = VPos_from_WPos(wpos);\n    \n    // N     : world space normal.xyz\n    // vpos.z: linear depth\n    outCol = vec4(N, vpos.z);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n    This work is licensed under a dual license, public domain and MIT, unless noted otherwise. Chose which one suits your needs best:\n    \n    CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n    To the extent possible under law, the author has waived all copyrights and related or neighboring rights to this work.\n    \n    or\n    \n    The MIT License\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), \n    to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, \n    and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR \n    THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n////////////////////////////////////////////////////////////////////////////////////// config\n//==================================================================================//\n\n/*\n    toggles:\n    \n    Tab  : toggle temporal accumulation on/off\n    Ctrl : toggle ortho cam off/on\n    Space: toggle between cosine and uniform hemisphere weighting (changes appearance of UI | default: cosine)\n\n    W    : toggle white noise use on/off\n    U    : toggle UI off/on\n*/\n\n/*\n    1: uniform sampling + slice weighting\n    2: exact  importance sampling via 2 random numbers\n    3: approx importance sampling via 1 random number (default)\n    -> only used if cosine weighting is active (otherwise uniform sampling is used)\n*/\n#define GTVBAO_SLICE_SAMPLING_MODE 3\n\n#if 1\n    // use high quality variants (so there is no unintentional bias when comparing to reference)\n    #define USE_HQ_APPROX_SLICE_IMPORTANCE_SAMPLING\n    #define USE_HQ_ACOS\n#endif\n\n// #define USE_ANALYTICAL_RAYCASTING\n\n// use this to compare against the orignal VBAO implementation (generally too bright)\n// #define USE_ORIGNAL_VBAO_IF_UNIFORM_HEMISHPHERE_WEIGHTING_IS_ACTIVE\n\n#define RAY_MARCH_SAMPLE_COUNT 32.0\n#define RAY_MARCH_RADIUS 512.0\n\n//==================================================================================//\n////////////////////////////////////////////////////////////////////////////////////// \n\n\nbool isLeft;// true on the left half of the screen; for debugging purposes\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 2), 0).x;}\n\n#define VarTex iChannel3\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == uint(cx) && uv.y == uint(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n\n////////////////////////////////////////////////////////////////////////////////////// acos approx\n//==================================================================================//\n\nfloat ACos_Approx(float x)\n{\n    float v = x < 0.0 ? Pi : 0.0;\n    \n    x = abs(x);\n\n    // minimizes max abs(ACos_Approx(cos(x)) - x)\n    float s = 0.21545;\n    float s1 = -(s + 1.0);\n    \n    float u = (x * s + s1) * x + 1.0;\n    \n    float ang = abs(v - Pi05 * sqrt(clamp(u, 0.0, 1.0)));\n    \n    return ang;\n}\n\n\n#ifdef USE_HQ_ACOS\nfloat ACos(float x)\n{   \n    return acos(clamp(x, -1.0, 1.0));\n}\n#else\nfloat ACos(float x)\n{\n    return ACos_Approx(x);\n}\n#endif\n\nvec2 ACos(vec2 v)\n{\n    return vec2(ACos(v.x), ACos(v.y));\n}\n\n//==================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////// slice sampling\n//==================================================================================//\n\n#if 1\n// vvsN: view vec space normal | rnd01: [0, 1]\nvec2 SampleSliceDir(vec3 vvsN, float rnd01)\n{\n    float ang0 = rnd01 * Pi;\n\n    vec2 dir0 = vec2(cos(ang0), sin(ang0));\n            \n    float l = length(vvsN.xy);\n\n    if(l == 0.0) return dir0;\n    \n    // flip dir0 into hemi-circle of rsN.xy\n    dir0 *= dot(dir0, vvsN.xy) < 0.0 ? -1.0 : 1.0;\n    \n    vec2 n = vvsN.xy / l;\n    \n    // SampleSlice(..) inlined + optimized\n    vec2 dir;\n    {\n        float x = dir0.x * n.y - dir0.y * n.x;// dir0 x n\n        \n        float s = l;// acos stretch param; chosen to approx match ref pdf\n        {\n            // quadratic bias\n            s += (s - s * s) * 0.15;\n        }\n        \n       #ifdef USE_HQ_APPROX_SLICE_IMPORTANCE_SAMPLING\n        float y = acos(x * sin(s * Pi05)) * RcpPi05;// stretched acos\n       #else\n        // approximation (not that much faster)\n        float k = 0.21545;// asin approx param\n        \n        float xs;// inverse approx asin\n        {\n            float a = 0.5 + 0.5 / k;\n            float b = 0.5 - 0.5 / k;\n            float d = b * b;\n            float c = 4.0 / k;\n\n            xs = 0.5 - 0.5 * s;\n            xs = a - sqrt(d + c * (xs*xs));\n        }\n        \n        x *= xs;// stretch curve along x\n        \n        float y;// approx acos\n        {\n            float v = x > 0.0 ? 2.0 : 0.0;\n\n            float g = -k - 1.0;\n\n            float u = (abs(x) * k + g) * abs(x) + 1.0;\n\n            y = abs(v - sqrt(clamp(u, 0.0, 1.0)));        \n        }\n       #endif\n        \n        float ys = 1.0 / s;// remap curve along y\n        \n        dir.y = ys - ys * y;// [-1, 1]\n        dir.x = sqrt(clamp(1.0 - dir.y*dir.y, 0.0, 1.0));// [0, 1]\n    }    \n    \n    // align x-axis with n\n\treturn vec2(dir.x * n.x - dir.y * n.y, \n\t\t        dir.y * n.x + dir.x * n.y);\n}\n\n#else\n\nfloat QBias(float x, float b)\n{\n    return x + (x - x*x) * b;\n}\n\nfloat SinStep(float x)\n{\n    return 0.5 - 0.5 * cos(x * Pi);\n}\n\nfloat InvSinStep(float x)\n{\n    return acos(1.0 - 2.0 * x) * RcpPi;\n}\n\nfloat InvSinStep(float x, float s)\n{\n    if(s < 0.00001) return x;\n    \n    float u = asin(sin(s * Pi05) * (1.0 - 2.0 * x));\n    \n    return 0.5 - u * (RcpPi / s);\n}\n\nfloat SampleSlice(float x, float sinNV)\n{\n    float s = QBias(sinNV, 0.15);\n    \n          x =    SinStep(x);\n    float y = InvSinStep(x, s);\n          y = InvSinStep(y);\n    \n    return y;\n}\n\nvec2 cmul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x * c1.x - c0.y * c1.y, \n\t\t        c0.y * c1.x + c0.x * c1.y);\n}\n\n// vvsN: view vec space normal | rnd01: [0, 1]\nvec2 SampleSliceDir(vec3 vvsN, float rnd01)\n{\n    float ang0 = rnd01 * Pi;\n    \n    vec2 dir0 = vec2(cos(ang0), sin(ang0));\n\n    float l = length(vvsN.xy);\n\n    if(l == 0.0) return dir0;\n    \n    // flip dir0 into hemi-circle of rsN.xy\n    dir0 *= dot(dir0, vvsN.xy) < 0.0 ? -1.0 : 1.0;\n    \n    vec2 n = vvsN.xy / l;    \n    \n    // align n with x-axis\n    dir0 = cmul(dir0, n * vec2(1.0, -1.0));\n\n    // sample slice angle\n    float ang;\n    {\n        float x = atan(-dir0.y / dir0.x) * RcpPi + 0.5;\n        float sinNV = l;\n\n        ang = SampleSlice(x, sinNV) * Pi - Pi05;\n    }\n    \n    // ray space slice direction\n    vec2 dir = vec2(cos(ang), sin(ang));\n    \n    // align x-axis with n\n    dir = cmul(dir, n);\n    \n    return dir;\n}\n#endif\n\n//==================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////// quaternion utils\n//==================================================================================//\n\nvec4 GetQuaternion(vec3 from, vec3 to)\n{\n    vec3 xyz = cross(from, to);\n    float s  =   dot(from, to);\n\n    float u = inversesqrt(max(0.0, s * 0.5 + 0.5));// rcp(cosine half-angle formula)\n    \n    s    = 1.0 / u;\n    xyz *= u * 0.5;\n\n    return vec4(xyz, s);  \n}\n\nvec4 GetQuaternion(vec3 to)\n{\n    //vec3 from = vec3(0.0, 0.0, 1.0);\n\n    vec3 xyz = vec3(-to.y, to.x, 0.0);// cross(from, to);\n    float s  =                   to.z;//   dot(from, to);\n\n    float u = inversesqrt(max(0.0, s * 0.5 + 0.5));// rcp(cosine half-angle formula)\n    \n    s    = 1.0 / u;\n    xyz *= u * 0.5;\n\n    return vec4(xyz, s);  \n}\n\n// transform v by unit quaternion q.xyzs\nvec3 Transform(vec3 v, vec4 q)\n{\n    vec3 k = cross(q.xyz, v);\n    \n    return v + 2.0 * vec3(dot(vec3(q.wy, -q.z), k.xzy),\n                          dot(vec3(q.wz, -q.x), k.yxz),\n                          dot(vec3(q.wx, -q.y), k.zyx));\n}\n\n// transform v by unit quaternion q.xy0s\nvec3 Transform_Qz0(vec3 v, vec4 q)\n{\n    float k = v.y * q.x - v.x * q.y;\n    float g = 2.0 * (v.z * q.w + k);\n    \n    vec3 r;\n    r.xy = v.xy + q.yx * vec2(g, -g);\n    r.z  = v.z  + 2.0 * (q.w * k - v.z * dot(q.xy, q.xy));\n    \n    return r;\n}\n\n// transform v.xy0 by unit quaternion q.xy0s\nvec3 Transform_Vz0Qz0(vec2 v, vec4 q)\n{\n    float o = q.x * v.y;\n    float c = q.y * v.x;\n    \n    vec3 b = vec3( o - c,\n                  -o + c,\n                   o - c);\n    \n    return vec3(v, 0.0) + 2.0 * (b * q.yxw);\n}\n\n//==================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////// GT-VBAO\n//==================================================================================//\n\n// https://graphics.stanford.edu/%7Eseander/bithacks.html#CountBitsSetParallel | license: public domain\nuint CountBits(uint v)\n{\n    v = v - ((v >> 1u) & 0x55555555u);\n    v = (v & 0x33333333u) + ((v >> 2u) & 0x33333333u);\n    return ((v + (v >> 4u) & 0xF0F0F0Fu) * 0x1010101u) >> 24u;\n}\n\n\nfloat SliceRelCDF_Uniform(float x, float angN)\n{\n    float phi = x * Pi - Pi05;\n    \n    bool c = phi >= angN;\n\n    float m0 = c ? 2.0 : 0.0;\n    float m1 = c ?-1.0 : 1.0;\n\n    float d0 = 0.5 * (m0 + m1 * cos(angN - phi) + sin(angN));\n    \n    return d0;\n}\n\nfloat SliceRelCDF_Cos(float x, float angN)\n{\n    float phi = x * Pi - Pi05;\n\n    bool c = phi >= angN;\n    \n    float n0 = c ?  3.0 : 1.0;\n    float n1 = c ? -1.0 : 1.0;\n    float n2 = c ?  4.0 : 0.0;\n    \n    float t0 = n0 * cos(angN) + n1 * cos(angN - 2.0 * phi) + (n2 * angN + (n1 * 2.0) * phi + Pi) * sin(angN);\n    float t1 = 4.0 * (cos(angN) + angN * sin(angN));\n\n    return t0 / t1;\n}\n\n\nfloat GTVBAO(vec2 uv0, vec3 wpos, vec3 N, uint pxId, uint dirCount)\n{\n    //if(doTempAccu) pxId += uint(iFrame) * 98u;// 135u 153u (159u) 169u 193 208 224 242 258u (273u) 276u 279u\n\n    vec3 positionVS = VPos_from_WPos(wpos);\n    vec3 normalVS   = VVec_from_WVec(N);\n    \n    vec3 V = isPerspectiveCam ? -normalize(positionVS) : vec3(0.0, 0.0, -1.0);\n    \n    vec2 rayStart = SPos_from_VPos(positionVS).xy;\n\n    float ao = 0.0;\n    \n    for(uint i = 0u; i < dirCount; ++i)\n    {        \n        uint h = pxId * dirCount + i;\n        \n        ////////////////////////////////////////////////// slice direction sampling\n        vec3 smplDirVS;// view space sampling vector\n        vec2 dir;// screen space sampling vector\n        {\n           #if GTVBAO_SLICE_SAMPLING_MODE == 1\n            // sample slice dir uniformly and later compute slice_weight accordingly\n            \n            float rnd01 = Float01(h * rPhi1);\n            //rnd01 = IGN(floor(uv0), USE_TEMP_ACCU_COND ? uint(iFrame) : 0u);\n\n            dir = vec2(cos(rnd01 * Pi), sin(rnd01 * Pi));\n\n            smplDirVS = vec3(dir.xy, 0.0);\n\n            if(isPerspectiveCam)\n            {\n                // set up View Vec Space -> View Space mapping\n                vec4 Q_toV = GetQuaternion(V);\n            \n                smplDirVS = Transform_Vz0Qz0(dir, Q_toV);\n\n                vec3 rayStart = SPos_from_VPos(positionVS);\n                vec3 rayEnd   = SPos_from_VPos(positionVS + smplDirVS*(nearZ*0.5));\n\n                vec3 rayDir   = rayEnd - rayStart;\n\n                rayDir /= length(rayDir.xy);\n\n                dir = rayDir.xy;\n            }\n            \n           #elif GTVBAO_SLICE_SAMPLING_MODE == 2\n            // sample cos lobe in world space and project dir to screen space to be used as slice dir\n            \n            vec2 s = Float11(shuffled_scrambled_sobol_2d(h, 0xCC925D21u));\n\n            vec3 cosDir = normalize(Sample_Sphere(s) + N);\n\n            smplDirVS = VVec_from_WVec(cosDir);\n\n            vec3 rayDir = smplDirVS;\n            \n            if(isPerspectiveCam)\n            {\n                rayDir = SPos_from_WPos(wpos + cosDir * (nearZ * 0.5)) - SPos_from_WPos(wpos);\n            }\n            \n            // 1 px step size\n            rayDir /= length(rayDir.xy);\n\n            dir = rayDir.xy;\n\n            // make orthogonal to V (alternatively use sliceN = normalize(sliceN);)\n            smplDirVS = normalize(smplDirVS - V * dot(V, smplDirVS));\n\n           #else\n            // approximate slice dir importance sampling\n            \n            float rnd01 = Float01(h * rPhi1);// 'Hilbert R1 Blue Noise' by paniq: https://www.shadertoy.com/view/3tB3z3\n            //rnd01 = IGN(floor(uv0), USE_TEMP_ACCU_COND ? uint(iFrame) : 0u);\n\n            // set up View Vec Space <-> View Space mapping\n            vec4   Q_toV = GetQuaternion(V);\n            vec4 Q_fromV = Q_toV * vec4(vec3(-1.0), 1.0);// conjugate\n\n            vec3 normalVVS = normalVS;\n\n            if(isPerspectiveCam) normalVVS = Transform_Qz0(normalVS, Q_fromV);\n\n            dir = SampleSliceDir(normalVVS, rnd01);\n\n            smplDirVS = vec3(dir.xy, 0.0);\n\n            if(isPerspectiveCam)\n            {\n                smplDirVS = Transform_Vz0Qz0(dir, Q_toV);\n\n                vec3 rayStart = SPos_from_VPos(positionVS);\n                vec3 rayEnd   = SPos_from_VPos(positionVS + smplDirVS*(nearZ*0.5));\n\n                vec3 rayDir   = rayEnd - rayStart;\n\n                rayDir /= length(rayDir.xy);\n\n                dir = rayDir.xy;\n            }\n           #endif\n           \n            if(USE_UNIFORM_HEMISHPHERE_WEIGHTING)\n            {\n                float rnd01 = Float01(h * rPhi1);\n \n                dir = vec2(cos(rnd01 * Pi), sin(rnd01 * Pi));\n                smplDirVS = vec3(dir, 0.0);\n                 \n               #ifndef USE_ORIGNAL_VBAO_IF_UNIFORM_HEMISHPHERE_WEIGHTING_IS_ACTIVE\n                if(isPerspectiveCam)\n                {\n                    // set up View Vec Space -> View Space mapping\n                    vec4 Q_toV = GetQuaternion(V);\n            \n                    smplDirVS = Transform_Vz0Qz0(dir, Q_toV);\n\n                    vec3 rayStart = SPos_from_VPos(positionVS);\n                    vec3 rayEnd   = SPos_from_VPos(positionVS + smplDirVS*(nearZ*0.5));\n\n                    vec3 rayDir   = rayEnd - rayStart;\n\n                    rayDir /= length(rayDir.xy);\n\n                    dir = rayDir.xy;\n                }\n               #endif\n            }\n        }\n        //////////////////////////////////////////////////\n        \n        ////////////////////////////////////////////////// construct slice\n        float cosN, angN, projNRcpLen;\n        {\n            vec3 sliceN = cross(V, smplDirVS);\n\n            vec3 projN = normalVS - sliceN * dot(normalVS, sliceN);\n\n            float projNSqrLen = dot(projN, projN);\n               if(projNSqrLen == 0.0) return 1.0;\n\n            projNRcpLen = inversesqrt(projNSqrLen);\n\n            cosN = dot(projN, V) * projNRcpLen;\n\n            vec3 T = cross(sliceN, projN);\n            \n            float sgn = dot(V, T) < 0.0 ? -1.0 : 1.0;\n            \n            angN = sgn * ACos(cosN);\n        }\n        //////////////////////////////////////////////////\n\n        vec2 rnd01 = Hash01x2(h, 0x968CC604u);\n        \n        // find horizons\n        uint occBits = 0u;\n        for(float d = -1.0; d <= 1.0; d += 2.0)\n        {\n            vec2 rayDir = dir.xy * d;\n            \n            const float count = RAY_MARCH_SAMPLE_COUNT;\n            \n            const float s = pow(RAY_MARCH_RADIUS, 1.0/count);\n            \n            float t = pow(s, rnd01.x);// init t: [1, s]\n            \n            rnd01.x = 1.0 - rnd01.x;\n            \n            for (float i = 0.0; i < count; ++i)\n            {\n                vec2 samplePos = rayStart + rayDir * t;\n                \n                t *= s;\n                \n                // handle oob\n                if(samplePos.x < 0.0 || samplePos.x >= iResolution.x || samplePos.y < 0.0 || samplePos.y >= iResolution.y) break;\n                \n                float sampleDepth = textureLod(iChannel2, samplePos / Resolution.xy, 0.0).w;\n                \n                vec3 samplePosVS = VPos_from_SPos(vec3(samplePos, sampleDepth));\n\n                float Thickness = 0.5;\n\n                vec3 deltaPosFront = samplePosVS - positionVS;\n                vec3 deltaPosBack  = deltaPosFront - V * Thickness;\n                \n                if(isPerspectiveCam)\n                {\n                   #if 1\n                    deltaPosBack = VPos_from_SPos(vec3(samplePos, sampleDepth + Thickness)) - positionVS;\n                   #else\n                    // also valid, but not consistent with reference ray marcher\n                    deltaPosBack = deltaPosFront + normalize(samplePosVS) * Thickness;\n                   #endif\n                }\n\n                // project samples onto unit circle and compute angles relative to V\n                vec2 horCos = vec2(dot(normalize(deltaPosFront), V), \n                                   dot(normalize(deltaPosBack ), V));\n\n                vec2 horAng = ACos(horCos) * d;\n\n                // shift relative angles from V to N + map to [0,1]\n                vec2 hor01 = clamp((horAng + angN) * RcpPi + 0.5, 0.0, 1.0);\n\n                // sampling direction flips min/max angles\n                hor01 = d >= 0.0 ? hor01.xy : hor01.yx;\n                \n                if(!USE_UNIFORM_HEMISHPHERE_WEIGHTING)\n                {\n                    // map to slice relative distribution\n                    hor01.x = SliceRelCDF_Cos(hor01.x, angN);\n                    hor01.y = SliceRelCDF_Cos(hor01.y, angN);\n\n                    // jitter sample locations + clamp01\n                    hor01 = clamp(hor01 + rnd01.y * (1.0/32.0), 0.0, 1.0);\n                }\n               #ifndef USE_ORIGNAL_VBAO_IF_UNIFORM_HEMISHPHERE_WEIGHTING_IS_ACTIVE\n                else\n                {\n                    // map to slice relative distribution\n                    hor01.x = SliceRelCDF_Uniform(hor01.x, angN);\n                    hor01.y = SliceRelCDF_Uniform(hor01.y, angN);\n\n                    // jitter sample locations + clamp01\n                    hor01 = clamp(hor01 + rnd01.y * (1.0/32.0), 0.0, 1.0);\n                }\n               #endif\n               \n                uint occBits0;// turn arc into bit mask\n                {\n                    uvec2 horInt = uvec2(floor(hor01 * 32.0));\n\n                    uint OxFFFFFFFFu = 0xFFFFFFFFu;// don't inline here! ANGLE bug: https://issues.angleproject.org/issues/353039526\n\n                    uint mX = horInt.x < 32u ? OxFFFFFFFFu <<        horInt.x  : 0u;\n                    uint mY = horInt.y != 0u ? OxFFFFFFFFu >> (32u - horInt.y) : 0u;\n\n                    occBits0 = mX & mY;            \n                }\n\n                occBits = occBits | occBits0;\n            }\n        }\n        \n        float occ0 = float(CountBits(occBits)) * (1.0/32.0);\n\n        float slice_weight = 1.0;\n        \n       #if GTVBAO_SLICE_SAMPLING_MODE == 1\n        // if we sample the slice dir from a uniform distribution we need to account for that here\n        slice_weight = 1.0/projNRcpLen * (cosN + angN * sin(angN));\n       #endif\n        \n        ao += (1.0 - occ0) * slice_weight;\n    }\n    \n    ao /= float(dirCount);\n    \n    return ao;\n}\n\n//==================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////// reference AO\n//==================================================================================//\n\nfloat ReferenceAO(vec3 wpos, vec3 N, uint pxId, uint dirCount)\n{\n    //if(doTempAccu) pxId += uint(iFrame) * 19u;\n\n    vec3 positionVS = VPos_from_WPos(wpos);\n\n    float occ = 0.0;\n    \n    for(uint i = 0u; i < dirCount; ++i)\n    {        \n        uint h = pxId * dirCount + i;\n        vec2 s = Float11(shuffled_scrambled_sobol_2d(h, 0xCC925D21u));\n\n        vec3 rayDir = Sample_Sphere(s); \n        \n        if(USE_UNIFORM_HEMISHPHERE_WEIGHTING)\n        {\n            // uniform weighted hemisphere\n            rayDir -= N * min(dot(rayDir, N) * 2.0, 0.0);\n        }\n        else\n        {\n            // cosine weighted hemisphere\n            rayDir = normalize(rayDir + N);\n        }\n        \n       #ifdef USE_ANALYTICAL_RAYCASTING\n        {\n            float t; vec3 n; vec3 a;\n            occ += Intersect_Scene(wpos, rayDir, /*out:*/ t, n, a) > 0.0 ? 1.0 : 0.0;\n        }\n       #else\n        // ray march in screen space\n        if(isPerspectiveCam)\n        {\n            vec4 rayStart = PPos_from_WPos(wpos);\n            vec4 rayEnd   = PPos_from_WPos(wpos + rayDir * (nearZ * 0.5));\n            \n            float rwStart = 1.0 / rayStart.w;\n            float rwEnd   = 1.0 / rayEnd.w;\n            \n            vec2 tcStart = rayStart.xy * rwStart * 0.5 + 0.5;\n            vec2 tcEnd   = rayEnd.xy   * rwEnd   * 0.5 + 0.5;\n            \n            vec2  tcDelta0 = tcEnd - tcStart;\n            float rwDelta0 = rwEnd - rwStart;\n            \n            vec2  uvDelta0       = tcDelta0 * iResolution.xy;\n            float uvDelta0RcpLen = inversesqrt(dot(uvDelta0, uvDelta0));\n\n            // 1 px step size\n            vec2  tcDelta = tcDelta0 * uvDelta0RcpLen;\n            float rwDelta = rwDelta0 * uvDelta0RcpLen;\n            \n            float rnd01 = Float01(Hash(h, 0xCA0F1C0Du));\n\n            const float count = RAY_MARCH_SAMPLE_COUNT;\n            \n            const float s = pow(RAY_MARCH_RADIUS, 1.0/count);\n            \n            float t = pow(s, rnd01);// init t: [1, s]\n\n            for (float i = 0.0; i < count; ++i)\n            {\n                vec2  tc = tcStart + tcDelta * t;\n                float rw = rwStart + rwDelta * t;\n\n                t *= s;\n\n                float depth = 1.0 / rw;\n\n                // handle oob\n                if(tc.x < 0.0 || tc.x >= 1.0 || tc.y < 0.0 || tc.y >= 1.0) break;\n                \n                float sampleDepth = textureLod(iChannel2, tc.xy, 0.0).w;\n\n                float Thickness = 0.5;\n\n                if(depth > sampleDepth && depth < sampleDepth + Thickness)\n                {\n                    occ += 1.0;\n                    \n                    break;\n                }\n             }\n        }\n        else\n        {\n            vec3 rayStart = SPos_from_WPos(wpos);\n            vec3 rayDir   = SVec_from_VVec_Ortho(VVec_from_WVec(rayDir));\n            \n            // 1 px step size\n            rayDir /= length(rayDir.xy);\n\n            float rnd01 = Float01(Hash(h, 0xCA0F1C0Du));\n\n            const float count = RAY_MARCH_SAMPLE_COUNT;\n                        \n            const float s = pow(RAY_MARCH_RADIUS, 1.0/count);\n            \n            float t = pow(s, rnd01);// init t: [1, s]\n            \n            for (float i = 0.0; i < count; ++i)\n            {\n                vec3 samplePos = rayStart + rayDir * t;\n                \n                t *= s;\n\n                vec2 tc = samplePos.xy / iResolution.xy;\n\n                // handle oob\n                if(tc.x < 0.0 || tc.x >= 1.0 || tc.y < 0.0 || tc.y >= 1.0) break;\n                \n                float sampleDepth = textureLod(iChannel2, tc.xy, 0.0).w;\n\n                float Thickness = 0.5;\n\n                if(samplePos.z > sampleDepth && samplePos.z < sampleDepth + Thickness)\n                {\n                    occ += 1.0;\n                    \n                    break;\n                }\n            }\n        }\n       #endif\n    }\n    \n    occ /= float(dirCount);\n    \n    return 1.0 - occ;\n}\n\n//==================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{     \n    Resolution = iResolution.xy;\n    isLeft = uv0.x < iResolution.x * 0.5;\n    \n    uvec2 uvu = uvec2(uv0.xy - 0.5);\n\t\n    vec4 mouseAccu  = ReadVar4(1, 0);\n    vec4 wasdAccu   = ReadVar4(2, 0);\n    float frameAccu = ReadVar (3, 0);\n    vec4 mouseAccuLast = ReadVar4(5, 0);\n\n    \n    PrepareCam(mouseAccu, USE_PERSPECTIVE_CAM_COND);\n    \n    vec4 gbuffer = textureLod(iChannel2, uv0 / iResolution.xy, 0.0);\n    vec3  N     = gbuffer.xyz;\n    float depth = gbuffer.w;\n    \n    if(depth >= exp2(10.0))\n    {\n        outCol = vec4(0.0);\n        \n        return;\n    }\n    \n    vec3 spos = vec3(uv0, depth);\n    \n    vec3 wpos = WPos_from_SPos(spos);\n    if(USE_UNIFORM_HEMISHPHERE_WEIGHTING)\n    {\n         // need a larger offset here when using uniform hemisphere weighting \n         // due to increased potential for self-shadowing\n         wpos+= N * (4.0/1024.0);\n    }\n    else\n    {\n         wpos+= N * (1.0/1024.0);\n    }\n    \n    // randomly shift noise pattern around\n    if(USE_TEMP_ACCU_COND) uvu += Hash(uvec2(iFrame, 0u), 0xBD1E0BB0u).xy;\n    \n    // linearize uv in a locality preserving way\n    uint pxId = EvalHilbertCurve(uvu, 9u);\n\n    // fill pxId with white noise\n    if(ReadKeyToggle(KEY_W) != 0.0)\n    {\n        pxId = WeylHash(uvu); \n    }\n    \n    \n    vec3 col = vec3(0.0);\n\n    float refao;\n    {\n        uint count = 2u;\n        \n        refao = ReferenceAO(wpos, N, pxId, count);\n    }\n    \n    float ssao;\n    {\n        uint count = 1u;\n        \n        ssao = GTVBAO(uv0, wpos, N, pxId, count);\n    }\n    \n    col = vec3(refao, ssao, 0.0);\n    \n    // accumulate frames\n    if(USE_TEMP_ACCU_COND)\n    {\n        vec2 tc = uv0.xy / iResolution.xy;\n    \n        vec4 colLast = textureLod(iChannel0, tc, 0.0);\n\n        col = mix(colLast.rgb, col, 1.0 / (frameAccu));\n        \n        frameAccu += 1.0;\n        \n        outCol = vec4(col.rgb, frameAccu);\n        \n        return;\n    }\n   \n    outCol = vec4(col, 0.0);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}