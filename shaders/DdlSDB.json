{
    "Shader": {
        "info": {
            "date": "1669514859",
            "description": "Example of a 3x3 separable Scharr filter for edge detection. A gaussian blur applied first significantly improves the result for noisy input. At the end I apply a threshold to reduce unwanted edges. Works nice with 'Google Logo' or Webcam input.",
            "flags": 34,
            "hasliked": 0,
            "id": "DdlSDB",
            "likes": 10,
            "name": "Separable Scharr Filter",
            "published": 3,
            "tags": [
                "sobel",
                "webcam",
                "scharr",
                "separablefilter"
            ],
            "usePreview": 0,
            "username": "CaffeinePwrdAl",
            "viewed": 621
        },
        "renderpass": [
            {
                "code": "float luminance(in vec3 colour)\n{\n    const vec3 srgb_factors = vec3(0.2126, 0.7152, 0.0722);\n    return dot(srgb_factors, colour);\n}\n\n//#define THRESHOLD_SCALE_BIAS\n//#define THRESHOLD_CUT\n#define THRESHOLD_SMOOTHSTEP\n\n#if defined (THRESHOLD_SCALE_BIAS)\nvec2 threshold(in float threshold, in float colour)\n{\n    float upper = (colour - threshold) * (1.0 / (1.0 - threshold));\n    //float lower = -min(0.0, (colour - threshold)) * (1.0 / threshold);\n    float lower = colour - upper;\n    return vec2(clamp(upper, 0.0, 1.0), lower);\n}\n#elif defined(THRESHOLD_CUT)\nvec2 threshold(in float threshold, in float colour)\n{\n    float upper = (colour < threshold)?(0.0):(colour);\n    float lower = (colour < threshold)?(colour):(0.0);\n    return vec2(upper, lower );\n}\n#elif defined (THRESHOLD_SMOOTHSTEP)\nvec2 threshold(in float threshold, in float colour)\n{\n    float upper = smoothstep(0.0, 1.0 - threshold, colour - threshold);\n    float lower = colour - upper;\n    return vec2(upper, lower);\n}\n#endif\n\nvec3 apply_filter_result(vec3 rgb, float filter_result)\n{\n    if (mod(iTime, 10.0) < 5.0)\n    {\n        return rgb * (1.0 - filter_result);\n    }\n    else\n    {\n        return vec3(1.0 - filter_result);\n    }\n}\n\n/*\n// Cycle between full screen application of the effect and a set of\n// animating bands showing different aspects of the filter and the\n// effect of applying the threshold\n*/\nbool showFullScreenEffect()\n{\n    //return true;\n    return mod(iTime, 20.0) > 10.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    vec4 filter_result = texelFetch(iChannel0, coord, 0).rgba;\n    \n    vec3 colour = filter_result.rgb;\n    float scharr = filter_result.a;\n    \n    /*\n    // Threshold test to remove some of the finer edges.\n    // Cycle it over time to show the effect of variation\n    */\n    float thres_cycle = 0.5 + 0.3 * sin(iTime * 2.0);\n    vec2 thres = threshold(thres_cycle, scharr);\n    \n    if (showFullScreenEffect())\n    {\n        thres = threshold(0.6, scharr);\n        colour *= (1.0 - thres.r);\n    }\n    else\n    {\n        // Just some maths to draw the bars of different outputs\n        float res_l1 = iResolution.x + iResolution.y;\n        float wipe  = (res_l1 * 0.3) * cos(iTime * 0.5);\n        float bar_s = (res_l1 * 0.10);\n        float bar_m = (res_l1 * 0.50);\n        float bar_e = (res_l1 * 0.90);\n\n        float fragCoord_l1 = fragCoord.x + fragCoord.y;\n\n        if (fragCoord_l1 < bar_s + wipe)\n        {\n            // Original Image\n            colour = filter_result.rgb;\n        }\n        else if (fragCoord_l1 < bar_s + wipe + 4.0)\n        {\n            colour *= 0.5;\n        }\n        else if (fragCoord_l1 < bar_m + wipe)\n        {\n            // Edges that passed the threshold test\n            colour = apply_filter_result(colour, thres.r);       \n        }\n        else if (fragCoord_l1 < bar_m + wipe + 4.0)\n        {\n            colour *= 0.5;\n        }\n        else if (fragCoord_l1 < bar_e + wipe)\n        {\n            // Original Scharr Result\n            colour = apply_filter_result(colour, scharr);\n        }\n        else if (fragCoord_l1 < bar_e + wipe + 4.0)\n        {\n            colour *= 0.5;\n        }\n        else\n        {\n            // The edges below the threshold we're excluding\n            colour = apply_filter_result(colour, scharr - thres.r);\n        }\n    }\n    \n    fragColor.rgb = colour;\n    //fragColor.rgb = filter_result.aaa;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define USE_WEBCAM\n//#define USE_VIDEO\n#define USE_TEXTURE\n\n#if defined(USE_WEBCAM)\n#define CHANNEL_IDX 2\n#define SAMPLER iChannel2\n#elif defined (USE_VIDEO)\n#define CHANNEL_IDX 1\n#define SAMPLER iChannel1\n#else\n#define CHANNEL_IDX 0\n#define SAMPLER iChannel0\n#endif\n\n\n/*\n// Scale-to-fit whatever image/source I'm using, maintaining aspect ratio and covering the screen.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    \n    float aspect_screen = iResolution.x / iResolution.y;\n    float aspect_image = iChannelResolution[CHANNEL_IDX].x / iChannelResolution[CHANNEL_IDX].y;\n    \n    if (aspect_image > aspect_screen)\n    {\n        uv.x *= aspect_screen / aspect_image;\n    }\n    else\n    {\n        uv.y *= aspect_image / aspect_screen;\n    }\n    \n    uv += vec2(0.5);\n    \n    fragColor = texture(SAMPLER, uv).rgba;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "video",
                        "id": 11,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv"
                    },
                    {
                        "channel": 2,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n// Performs a separable gaussian blur on the input image\n*/\n\n#define SEPARABLE_9\n\n#if defined(SEPARABLE_15)\n#define TAPS 15\n#endif\n#if defined(SEPARABLE_9)\n#define TAPS 9\n#endif\n#if defined(SEPARABLE_5)\n#define TAPS 5\n#endif\n#if !defined(TAPS)\n#define TAPS 3\n#endif\n\n/*\n// Convert sRGB to Luminance\n*/\nfloat luminance(in vec3 colour)\n{\n    const vec3 srgb_factors = vec3(0.2126, 0.7152, 0.0722);\n    return dot(srgb_factors, colour);\n}\n\n/*\n// Can do this better, but this works for now while I work out how much of a\n// blur I want prior to the Scharr filter being applied. This is helpful on\n// noisier input.\n*/\nfloat WideSeparableL(ivec2 fragCoord, ivec2 delta, const float taps[TAPS/2+1])\n{\n\tfloat ret;\n\tivec2 coord = fragCoord - (TAPS/2) * delta;\n\n\tret = taps[0] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n\tret += taps[1] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#if (TAPS >= 5)\n\tret += taps[2] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#if (TAPS >= 7)\n\tret += taps[3] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#if (TAPS >= 9)\n\tret += taps[4] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#if (TAPS >= 11)\n\tret += taps[5] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#if (TAPS >= 13)\n\tret += taps[6] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#if (TAPS >= 15)\n\tret += taps[7] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n\tret += taps[6] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#endif\n\tret += taps[5] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#endif\n\tret += taps[4] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#endif\n\tret += taps[3] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#endif\n\tret += taps[2] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#endif\n\tret += taps[1] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#endif\n\tret += taps[0] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\n\treturn ret;\n}\n\n\n/*\n// Chooses a set of gaussian filter taps based upon defines and passes\n// them to the separable filter function above\n*/\nfloat gaussian_filter_3x3(in ivec2 fragCoord)\n{\n#if defined (SEPARABLE_15)\n\tconst float taps[8] = float[](\n\t\t// Sig = 3.0\n\t\t//0.009033,\t0.018476,\t0.033851,\t0.055555,\t0.08167,\t0.107545,\t0.126854,\t0.134032\n        // Sig = 1.4\n\t\t0.000002,\t0.000041,\t0.000611,\t0.005556,\t0.030863,\t0.104916,\t0.218504,\t0.279015\n\t);\n#elif defined (SEPARABLE_9)\n\tconst float taps[5] = float[5](\n\t\t// Sigma = 3\n\t\t//0.063327, 0.093095, 0.122589, 0.144599, 0.152781\n\t\t// Sigma = 2\n\t\t0.028532, 0.067234, 0.12400, 0.179044, 0.20236\n\t\t// Sigma = 1.4\n\t\t//0.005563, 0.030904, 0.105053, 0.21879, 0.27938\n\t\t// Sigma = 1 -- Nice round shape, but almost too much falloff, makes the \n\t\t// outer taps of too low a value - especially in multi pass filtering\n\t\t//0.000229, 0.005977, 0.060598, 0.241732, 0.382928\n\t);\n#elif defined (SEPARABLE_5)\n    const float taps[3] = float[3](\n        // Sigma = 3\n        //0.1784, 0.210431, 0.222338\n        // Sigma = 2\n        0.153388, 0.221461, 0.250301\n        // Sigma = 1.4\n        //0.113318, 0.236003, 0.30136\n        // Sigma = 1\n        //0.06136, 0.24477, 0.38774\n        // NOP\n        //0.0, 0.0, 1.0\n    );\n#else /*defined (SEPARABLE_3)*/\n    const float taps[2] = float[2](\n        // Sigma = 3\n        //0.327162, 0.345675\n        // Sigma = 2\n        0.319466, 0.361069\n        // Sigma = 1.4\n        //0.305163, 0.389673\n        // Sigma = 1\n        //0.27901, 0.44198\n        // NOP\n        //0.0, 1.0\n    );\n#endif\n\n    float x = WideSeparableL(fragCoord, ivec2(1,0), taps);\n    float y = WideSeparableL(fragCoord, ivec2(0,1), taps);\n    \n    return 0.5 * (x + y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float blurred_luminance = gaussian_filter_3x3(ivec2(fragCoord));\n    vec3 original = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n\n    // Output original image colour and the blurred luminance\n    fragColor = vec4(original, blurred_luminance);\n    //fragColor = vec4(original, luminance(original));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Perform a separable scharr filter in X\nfloat scharr_x(in float texels[9])\n{ \n    const float weights[9] = float[](\n         -3.0,  0.0,   3.0,\n        -10.0,  0.0,  10.0,\n         -3.0,  0.0,   3.0\n    );\n    \n    float filtered = 0.0;\n    \n    for (int y = 0; y < 3; y++)\n    {\n        for (int x = 0; x < 3; x++)\n        {\n            int idx = y * 3 + x;\n            filtered += weights[idx] * texels[idx];\n        }\n    }\n    return filtered;\n}\n\n// Perform a separable scharr filter in Y\nfloat scharr_y(in float texels[9])\n{\n    const float weights[9] = float[](\n          3.0,  10.0,  3.0,\n          0.0,   0.0,  0.0,\n         -3.0, -10.0, -3.0\n    );\n    \n    float filtered = 0.0;\n    \n    for (int y = 0; y < 3; y++)\n    {\n        for (int x = 0; x < 3; x++)\n        {\n            int idx = y * 3 + x;\n            filtered += weights[idx] * texels[idx];\n        }\n    }\n    return filtered;\n}\n\n/*\n// Scharr Filter\n//\n// This is a specialisation of the 3x3 Sobel edge detection filter where\n// the filter kernel produces a nice rotationally consistent result.\n//\n// This implementation first samples the pool of 9 texels we need for the\n// filter, then runs our x and y separable filter kernels over them, \n// and combining them to give us our final gradient value\n*/\n#define USE_TEXEL_FETCH\n#if defined(USE_TEXEL_FETCH)\nfloat scharr_filter_3x3(in ivec2 fragCoord)\n{\n    float texels[9];\n    \n    // Little heuristic that seems to make the sampling behaviour consistent-ish\n    // across different screen resolutions. Originally I used texelFetch as I was\n    // just applying the filter at the source resolution, but when you stretch the\n    // image across the screen you change the response of the filter. Might be\n    // better to switch back to normal image sampling.\n    float offset = max(iResolution.x, iResolution.y) / 400.0;\n    offset = sqrt(offset);\n    \n    texels[0] = (texelFetch(iChannel0, fragCoord + ivec2(-offset, -offset), 0).a);\n    texels[1] = (texelFetch(iChannel0, fragCoord + ivec2(      0, -offset), 0).a);\n    texels[2] = (texelFetch(iChannel0, fragCoord + ivec2( offset, -offset), 0).a);\n    \n    texels[3] = (texelFetch(iChannel0, fragCoord + ivec2(-offset,  0), 0).a);\n    texels[4] = (texelFetch(iChannel0, fragCoord + ivec2(      0,  0), 0).a);\n    texels[5] = (texelFetch(iChannel0, fragCoord + ivec2( offset,  0), 0).a);\n    \n    texels[6] = (texelFetch(iChannel0, fragCoord + ivec2(-offset,  offset), 0).a);\n    texels[7] = (texelFetch(iChannel0, fragCoord + ivec2(      0,  offset), 0).a);\n    texels[8] = (texelFetch(iChannel0, fragCoord + ivec2( offset,  offset), 0).a);\n    \n    float x = scharr_x(texels);\n    float y = scharr_y(texels);\n    \n    //return abs(x) + abs(y);\n    return sqrt(x*x + y*y);\n}\n#else\nfloat scharr_filter_3x3(in ivec2 fragCoord)\n{\n    float texels[9];\n    \n    // Little heuristic that seems to make the sampling behaviour consistent-ish\n    // across different screen resolutions. Originally I used texelFetch as I was\n    // just applying the filter at the source resolution, but when you stretch the\n    // image across the screen you change the response of the filter. Might be\n    // better to switch back to normal image sampling.\n    float delta = sqrt(max(iResolution.x, iResolution.y) / 400.0);\n    delta = sqrt(delta);\n    \n    vec2 offset = vec2(delta);\n    vec2 uv = vec2(fragCoord) / iResolution.xy;\n    offset /= iResolution.xy;\n    \n    texels[0] = (texture(iChannel0, uv + vec2(-offset.x, -offset.y)).a);\n    texels[1] = (texture(iChannel0, uv + vec2(        0, -offset.y)).a);\n    texels[2] = (texture(iChannel0, uv + vec2( offset.x, -offset.y)).a);\n    \n    texels[3] = (texture(iChannel0, uv + vec2(-offset.x,  0)).a);\n    texels[4] = (texture(iChannel0, uv + vec2(        0,  0)).a);\n    texels[5] = (texture(iChannel0, uv + vec2( offset.x,  0)).a);\n    \n    texels[6] = (texture(iChannel0, uv + vec2(-offset.x,  offset.y)).a);\n    texels[7] = (texture(iChannel0, uv + vec2(        0,  offset.y)).a);\n    texels[8] = (texture(iChannel0, uv + vec2( offset.x,  offset.y)).a);\n    \n    float x = scharr_x(texels);\n    float y = scharr_y(texels);\n    \n    //return abs(x) + abs(y);\n    return sqrt(x*x + y*y);\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scharr = scharr_filter_3x3(ivec2(fragCoord));  \n    vec4 original = texelFetch(iChannel0, ivec2(fragCoord), 0).rgba;\n\n    // Store the original image, and the scharr filter result\n    fragColor = vec4(original.rgb, scharr);\n    //fragColor = vec4(original);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}