{
    "Shader": {
        "info": {
            "date": "1717104468",
            "description": "Vespro is an open source library for volumetric path-tracing. This is the minified version, fully documented sources here: [url]https://www.shadertoy.com/view/lXd3DX[/url]\n\nCommon: Scene\nBufferA: Textures\nBuffer B,C,D: reserved\nImage: Overview + API doc",
            "flags": 48,
            "hasliked": 0,
            "id": "XXcGzj",
            "likes": 13,
            "name": "Vespro - Volumetric Path Tracer",
            "published": 3,
            "tags": [
                "volumetric",
                "pathtracer",
                "importancesampling",
                "mis",
                "library",
                "api",
                "opensource"
            ],
            "usePreview": 1,
            "username": "Lorenzo_Vannuccini",
            "viewed": 214
        },
        "renderpass": [
            {
                "code": "//   __      __  _____    _____     _____    _____     _____\n//   \\ \\    / / | ____|  / ____|   |  __ \\  |  __ \\   / ____ \\\n//    \\ \\  / /  | |___  | |____    | |__) | | |__) | | |    | |\n//     \\ \\/ /   |  ___|  \\_____ \\  |  ___/  |  _  /  | |    | |\n//      \\  /    | |___    _____) | | |      | | \\ \\  | |____| |\n//       \\/     |_____|  |_____/   |_|      |_|  \\_\\  \\______/\n//\n//                      VOLUMETRIC PATH TRACER           v.3.2.3\n//\n//    Developed by: Lorenzo Vannuccini, blackravenprod@gmail.com\n\n\n// ------------------------------------------------------------------ //\n//                           Description                              // ------------------------------------------------------------------------------------------- //\n// ------------------------------------------------------------------ //\n/*\n\n  Vespro is an open source library for volumetric path-tracing I wrote in 2024.\n  Feel free to fork it and do what you want with it, a citation is appreciated but not required.\n\n  This project was heavily inspired by:\n\n      - SÃ©bastien Hillaire - SebH publications:  https://sebh.github.io/publications/\n      - Inigo Quilez       - IQ articles:        https://iquilezles.org/articles/\n\n  Vespro supports multiple importance sampled analytical lights, volumetric nodes with multiple participating media channels,\n  different light integrators inclusive of multiple scattering, and lambertian diffuse surfaces.\n\n  Lambertian surfaces can be modeled as parametric or implicit, Vespro already provides several built-in surface samplers,\n  but it also supports custom SDFs and intersectors.\n\n  The following abstract methods MUST be user-defined when importing the lib: Vespro_surfaceSampler(), Vespro_densitySampler(), Vespro_radianceSampler()\n  These callbacks are invoked by the light integrator, and are responsible of sampling the volumetric densities and solid surfaces of the scene.\n\n  The Vespro_integrateAsync() mode allows for the light integrator to operate asynchronously over multiple frames, it's more memory intensive but it allows\n  for better control between convergence over performance. This mode is also used to iteratively solve SDF intersections without risking\n  to hang the GPU. The non-async counterpart, Vespro_integrate() should only be used for very simple scenes with relatively thin participating media.\n\n  Tweak the targetFPS in the Common tab to trade between convergence time and performance. The number of spp are\n  adjusted at runtime to match the desired framerate on your hardware. Be wary that if the spp get too low, or the scene\n  complexity is very high, it might take a few frames before seeing anything on screen.\n\n  Note that since the sampling strategy is tile-based, and some tiles converge quicker than others,\n  there will be artefacts on the rendered image initially, but should go away after a while.\n\n  Controls:\n\n      - LMB:         look around\n      - W, A, S, D:  move around\n      - E, Q:        move up / down\n      - SPACE:       reset path tracer\n      - H:           show / hide rendered tiles\n      - I:           lock / unlock adaptive exposure\n      - L:           center sun to screen (changes time of day)\n\n  Hints:\n\n      - Split participating media with considerably different densities in separate nodes.\n\n      - Always try to fit complex volumes/sufaces to nodes or AABBs to ease convergence time.\n\n      - Prefer parametric intersectors over implicit SDFs, whenever possible.\n\n      - When sampling multiple surfaces sharing the same materials, consider using batch sampling queries.\n\n      - All analytical lights are importance-sampled, emissive surfaces aren't.\n\n      - Set Vespro_MAX_NODES, Vespro_MAX_MEDIA, Vespro_MAX_LIGHTS to the minimum scene requirements to ease compilation.\n\n\n  To Improve:\n\n      - I'm not super sure about physical accuracy, especially with non-isotropic phase. The math can definitely use a double-check,\n        especially the importance sampling part.\n\n      - It would be cool to add importance sampling for emissive surfaces as well, and different types of area lights other than spheres.\n\n      - Extending support for specular BRDF seems like a must, but I want to make sure the diffuse and volumetric part is correct first.\n\n      - Add support for ray-marching, similar logic to current SDFs, but with linear stepping or binary search rather than sphere tracing.\n\n      - Code complexity is a bit on the crazy side for a shader, it could use some optimization even if it's a path tracer.\n\n\n  Below you fill find the public API documentation.\n\n  Enjoy :)\n\n*/\n// ------------------------------------------------------------------ //\n//                        API Documentation                           // ------------------------------------------------------------------------------------------------------- //\n// ------------------------------------------------------------------ //\n\n// --------------------------- //\n//       Public (exposed)      //\n// --------------------------- //\n\n// Initializes Vespro's path tracing context.\n// Note: the context must be initialized before calling any Vespro function.\nvoid Vespro_initContext( in Vespro_Enum profile, // the light integrator profile, Vespro_TRANSMITTANCE, Vespro_SINGLE_SCATTERING or Vespro_MULTIPLE_SCATTERING\n                         in vec2 fragCoord,      // the current pixel coords in viewport space, must be >= 0\n                         in vec2 viewportSize,   // the current viewport size, must be >= 0\n                         in int frameID );       // the current frame count, must be >= 0 (drives temporal noise)\n\n// Creates a spherical light source. All light sources are importance-sampled (improves convergence rate), and affect all volumetric nodes.\nvoid Vespro_createLight( in uint lightID,   // the light unique identifier, must be in range [0, Vespro_MAX_LIGHTS - 1]\n                         in vec3 intensity, // the light radiant intensity (watt/steradian)\n                         in vec3 position,  // the light position\n                         in float radius ); // the light radius\n\n// Creates a cuboid volumetric node. Each volumetric node contains a fixed list of participating media.\n// When nodes intersect eachothers, their participating media will be blended together. To improve convergence, participating media with significant\n// difference in density should be placed in separated nodes. Ideally each node must be full (or as full as possible) for optimal convergence.\nvoid Vespro_createNode( in uint nodeID,   // the node unique identifier, must be in range [0, Vespro_MAX_NODES - 1]\n                        in vec3 position, // the node position\n                        in vec3 size );   // the node size\n\n// Creates a spherical volumetric node. Each volumetric node contains a fixed list of participating media.\n// When nodes intersect eachothers, their participating media will be blended together. To improve convergence, participating media with significant\n// difference in density should be placed in separated nodes. Ideally each node must be full (or as full as possible) for optimal convergence.\nvoid Vespro_createNode( in uint nodeID,    // the node unique identifier, must be in range [0, Vespro_MAX_NODES - 1]\n                        in vec3 position,  // the node position\n                        in float radius ); // the node radius\n\n// Creates a participating medium for a given volumetric node.\nvoid Vespro_createMedium( in uint nodeID,       // the node unique identifier, must be in range [0, Vespro_MAX_NODES - 1]\n                          in uint mediumID,     // the medium identifier (unique for this node), must be in range [0, Vespro_MAX_MEDIA - 1]\n                          in vec3 scatteringCoeff, // medium scattering coefficients (probability of scattering events over 1km distance per R, G, B wavelengths)\n                          in vec3 absorptionCoeff, // medium absorption coefficients (probability of absorption events over 1km distance per R, G, B wavelengths)\n                          in float phaseG );       // scattering phase asymmetry (g < 0: back-scatter, g = 0: isotropic, g > 0: forward-scatter)\n\n// Sets a small depth offset for intersections, ensuring photons don't get stuck on surfaces and node boundaries.\n// Tweak this offset accordingly should you experience artefacts (eg. darkening spots or light bleeding), default offset is 1e-5.\nvoid Vespro_setDepthOffset( in float depthOffset );\n\n// This function should be called from Vespro_densitySampler() when invoked by the integrator, to set the sampled participating media densities result.\n// Subsequent calls from the same invocation will lead to the last value being accepted. If un-set, the sample densities are assumed to be zero.\nvoid Vespro_setDensity( in uint mediumID,   // the participating medium unique identifier for the sampled node, must be in range [0, Vespro_MAX_MEDIA - 1]\n                        in float density ); // the participating medium density for the sampled position in the node, must be in range [0, 1]\n\n// This function should be called from Vespro_radianceSampler() when invoked by the integrator, to set the sampled radiance result.\n// Subsequent calls from the same invocation will lead to the last value being accepted. If un-set, the radiance sample is assumed to be zero.\nvoid Vespro_setRadiance(in vec3 radiance); // the radiance sample to set, in radiant intensity (watt/steradian)\n\n// This function should be called after performing a successful surface sample from Vespro_surfaceSampler() when invoked by the integrator.\n// It sets the sampled surface albedo. Subsequent calls from the same invocation will lead to the last value being accepted.\n// If un-set, the surface albedo is assumed to be one.\nvoid Vespro_setSurfaceAlbedo( in vec3 albedo ); // the fraction of incident radiation reflected by the surface (unorm)\n\n// This function should be called after performing a successful surface sample from Vespro_surfaceSampler() when invoked by the integrator.\n// It returns the last set albedo for the sampled surface.\nvec3 Vespro_getSurfaceAlbedo();\n\n// This function should be called after performing a successful surface sample from Vespro_surfaceSampler() when invoked by the integrator.\n// It sets the sampled surface emission. Subsequent calls from the same invocation will lead to the last value being accepted.\n// If un-set, the surface emission is assumed to be zero.\nvoid Vespro_setSurfaceEmissive( in vec3 emissive ); // surface emission radiant intensity (watt/steradian)\n\n// This function should be called after performing a successful surface sample from Vespro_surfaceSampler() when invoked by the integrator.\n// It returns the last set emission for the sampled surface.\nvec3 Vespro_getSurfaceEmissive();\n\n// This function should be called after performing a successful surface sample from Vespro_surfaceSampler() when invoked by the integrator.\n// It sets the sampled surface normal. Subsequent calls from the same invocation will lead to the last value being accepted.\nvoid Vespro_setSurfaceNormal( in vec3 normal ); // surface geometric normal (two-sided)\n\n// This function should be called after performing a successful surface sample from Vespro_surfaceSampler() when invoked by the integrator.\n// It returns the sampled surface normal. Not available for custom parametric surfaces (normals must be specified manually).\nvec3 Vespro_getSurfaceNormal();\n\n// This function should be called after performing a successful surface sample from Vespro_surfaceSampler() when invoked by the integrator.\n// It returns the sampled surface position.\nvec3 Vespro_getSurfacePosition();\n\n// This function should be called from Vespro_surfaceSampler(), Vespro_densitySampler() or Vespro_radianceSampler().\n// Returns the distance from a given world position to the observer\nfloat Vespro_distance(in vec3 p); // the position (in world space)\n\n// This function should be called from Vespro_surfaceSampler() when invoked by the integrator.\n// Performs a LESS depth tests against an intersection distance. Can be used to sample custom parametric surfaces.\n// Negative depth values are assumed to be un-set, a negative value at the source always produces a fail.\nbool Vespro_depthTest( in float srcDepth ); // the depth value to test\n\n// This function should be called from Vespro_surfaceSampler() when invoked by the integrator.\n// Samples a volumetric node, the function returns true if the node passed depth testing.\n// This check can be used to quickly determine the visibility of a set of samples contained within a node.\nbool Vespro_sampleNode(in uint nodeID); // the node unique identifier\n\n// This function should be called from Vespro_surfaceSampler() when invoked by the integrator.\n// Samples an axis-aligned bounding box, the function returns true if the AABB passed depth testing.\n// This check can be used to quickly determine the visibility of a set of samples contained within the AABB.\nbool Vespro_sampleAABB( in vec3 position, // the AABB position\n                        in vec3 size );   // the AABB size (on each axis)\n\n// This function should be called from Vespro_surfaceSampler() when invoked by the integrator.\n// Begins a batch-sampling query, this function can be used to sample multiple surfaces at once\n// sharing the same properties. The query result can be evaluated with Vespro_validateBatchSampling().\nvoid Vespro_beginBatchSampling();\n\n// This function should be called from Vespro_surfaceSampler() when invoked by the integrator.\n// Terminates and validate the last issued batch-sampling query. The function returns true if any sampled\n// surface in between Vespro_beginBatchSampling() and Vespro_validateBatchSampling() passed depth testing.\nbool Vespro_validateBatchSampling();\n\n// This function should be called from Vespro_surfaceSampler() when invoked by the integrator.\n// Samples a signed distance field surface, the function returns true if it passed depth testing.\n// In case of a pass, the surface properties are automatically set, but can be overridden.\n// Can be used to sample custom signed distance field functions\nbool Vespro_sampleSDF(in float sd); // the signed distance to the implicit surface\n\n// This function should be called from Vespro_surfaceSampler() when invoked by the integrator.\n// Samples an infinite plane surface, the function returns true if it passed depth testing.\nbool Vespro_samplePlane( in vec3 position,  // the plane origin (pivot)\n                         in vec3 normal );  // the plane normal\n\n// This function should be called from Vespro_surfaceSampler() when invoked by the integrator.\n// Samples a sphere surface, the function returns true if it passed depth testing.\n// In case of a pass, the surface properties are automatically set, but can be overridden.\nbool Vespro_sampleSphere( in vec3 position,  // the sphere position (in world space)\n                          in float radius ); // the sphere radius\n\n// This function should be called from Vespro_surfaceSampler() when invoked by the integrator.\n// Samples an axis-aligned cuboid surface, the function returns true if it passed depth testing.\n// In case of a pass, the surface properties are automatically set, but can be overridden.\nbool Vespro_sampleBox( in vec3 position, // the cuboid position\n                       in vec3 size );   // the cuboid size (on each axis)\n\n// This function should be called from Vespro_surfaceSampler() when invoked by the integrator.\n// Samples an oriented cuboid surface, the function returns true if it passed depth testing.\n// In case of a pass, the surface properties are automatically set, but can be overridden.\n// Prefer using the axis-aligned counterpart when no orientation is needed\nbool Vespro_sampleBox( in vec3 position,      // the cuboid position\n                       in vec3 size,          // the cuboid size (on each axis)\n                       in vec4 orientation ); // a normalized quaternion representing its orientation\n\n// This function should be called from Vespro_surfaceSampler() when invoked by the integrator.\n// Samples a cuboid frame surface, the function returns true if it passed depth testing.\n// In case of a pass, the surface properties are automatically set, but can be overridden.\nbool Vespro_sampleBoxFrame( in vec3 position,     // the cuboid frame position (in world space)\n                            in vec3 size,         // the cuboid frame size (on each axis)\n                            in float thickness ); // the cuboid frame thickness\n\n// This function should be called from Vespro_surfaceSampler() when invoked by the integrator.\n// Samples an oriented cuboid frame surface, the function returns true if it passed depth testing.\n// In case of a pass, the surface properties are automatically set, but can be overridden.\n// Prefer using the axis-aligned counterpart when no orientation is needed\nbool Vespro_sampleBoxFrame( in vec3 position,      // the cuboid frame position (in world space)\n                            in vec3 size,          // the cuboid frame size (on each axis)\n                            in float thickness,    // the cuboid frame thickness\n                            in vec4 orientation ); // a normalized quaternion representing its orientation\n\n// This function should be called from Vespro_surfaceSampler() when invoked by the integrator.\n// Samples a cylinder surface, the function returns true if it passed depth testing.\n// In case of a pass, the surface properties are automatically set, but can be overridden.\nbool Vespro_sampleCylinder( in vec3 a,   // the cylinder's first  extremity position (in world space)\n                            in vec3 b,   // the cylinder's second extremity position (in world space)\n                            in float r); // the cylinder's radius\n\n// This function should be called from Vespro_surfaceSampler() when invoked by the integrator.\n// Samples an oriented cylinder surface, the function returns true if it passed depth testing.\n// In case of a pass, the surface properties are automatically set, but can be overridden.\n// Prefer using the rotationless counterpart when no orientation is needed.\nbool Vespro_sampleCylinder( in vec3 a,             // the cylinder's first extremity  position (in world space)\n                            in vec3 b,             // the cylinder's second extremity position (in world space)\n                            in float r,            // the cylinder's radius\n                            in vec4 orientation ); // a normalized quaternion representing its orientation\n\n// This function should be called from Vespro_surfaceSampler() when invoked by the integrator.\n// Samples a capsule surface, the function returns true if it passed depth testing.\n// In case of a pass, the surface properties are automatically set, but can be overridden.\nbool Vespro_sampleCapsule( in vec3 a,   // the capsule's first  extremity position (in world space)\n                           in vec3 b,   // the capsule's second extremity position (in world space)\n                           in float r); // the capsule's radius\n\n// This function should be called from Vespro_surfaceSampler() when invoked by the integrator.\n// Samples an oriented capsule surface, the function returns true if it passed depth testing.\n// In case of a pass, the surface properties are automatically set, but can be overridden.\n// Prefer using the rotationless counterpart when no orientation is needed.\nbool Vespro_sampleCapsule( in vec3 a,             // the capsule's first extremity  position (in world space)\n                           in vec3 b,             // the capsule's second extremity position (in world space)\n                           in float r,            // the capsule's radius\n                           in vec4 orientation ); // a normalized quaternion representing its orientation\n\n// This function should be called from Vespro_surfaceSampler() when invoked by the integrator.\n// Samples a torus surface, the function returns true if it passed depth testing.\n// In case of a pass, the surface properties are automatically set, but can be overridden.\nbool Vespro_sampleTorus( in vec3 position,     // the torus position (in world space)\n                         in float radius,      // the torus outer radius\n                         in float thickness ); // the torus thickness\n\n// This function should be called from Vespro_surfaceSampler() when invoked by the integrator.\n// Samples an oriented torus surface, the function returns true if it passed depth testing.\n// In case of a pass, the surface properties are automatically set, but can be overridden.\n// Prefer using the rotationless counterpart when no orientation is needed.\nbool Vespro_sampleTorus( in vec3 position,      // the torus position (in world space)\n                         in float radius,       // the torus outer radius\n                         in float thickness,    // the torus thickness\n                         in vec4 orientation ); // a normalized quaternion representing its orientation\n\n// This function should be called from Vespro_surfaceSampler() when invoked by the integrator.\n// Samples the surfaces of a Cornell box, the function returns true if any surface passed depth testing.\n// In case of a pass, the surface properties are automatically set, but can be overridden.\nbool Vespro_sampleCornellBox( in vec3 position, // the Cornell box position (in world space)\n                              in float size );  // the Cornell box size (uniform in all axis)\n\n// This function should be called from Vespro_surfaceSampler() when invoked by the integrator.\n// Samples the surfaces of an oriented Cornell box, the function returns true if any surface passed depth testing.\n// In case of a pass, the surface properties are automatically set, but can be overridden.\nbool Vespro_sampleCornellBox( in vec3 position,      // the Cornell box position (in world space)\n                              in float size,         // the Cornell box size (uniform in all axis)\n                              in vec4 orientation ); // a normalized quaternion representing its orientation\n\n// Solves the radiative transfer integral along a given ray (eg. an \"observer\"), and returns the result.\n// Depending on the profile specified in the context, this can either be transmitted, scattered or multi-scattered light.\n// A sample corresponds to a complete light-path. If the light-path is not resolved within Vespro_MAX_STEPS iterations,\n// the sample is aborted. For complex scenes or very dense participating media, consider using Vespro_integrateAsync().\nbool Vespro_integrate( inout vec4 result,  // the destination color in which to store the result, alpha channel is reserved\n                       in vec3 ro,         // the ray origin (observer position)\n                       in vec3 rd,         // the ray direction (observer direction)\n                       in uint nSamples ); // n. of light samples per frame\n\n// Solves the radiative transfer integral asynchronously along a given ray (eg. an \"observer\").\n// Depending on the profile specified in the context, this can either be transmitted, scattered or multi-scattered light.\n// In the asynch mode, each iteration correspond to a photon step. Several iterations might be requires to complete a light path (a \"sample\"),\n// but the workload is much easily managed, useful to handle complex scenes. The async state should be stored and loaded across multiple frames\n// via Vespro_storeAsyncState() and Vespro_loadAsyncState(). This mode ignores the iteration limit imposed by Vespro_MAX_STEPS\nbool Vespro_integrateAsync( inout vec4 result,     // the destination color in which to store the result, alpha channel is ignored\n                            in vec3 ro,            // the ray origin (observer position)\n                            in vec3 rd,            // the ray direction (observer direction)\n                            in uint nIterations ); // n. of iterations per frame\n\n// Stores the integration progress into a 32 bit 4x4 matrix.\n// This matrix can be stored on the current pixel and used to progress the integration over multiple frames.\nvoid Vespro_storeAsyncState(out mat4 packedData); // the 4x4 matrix to encode the data into\n\n// Load a previously stored integration progress from a 32 bit 4x4 matrix.\n// This matrix can be stored on the current pixel and used to progress the integration over multiple frames.\n// Note: the context must be already initialized with the node hierarchy defined in the same way.\nvoid Vespro_loadAsyncState(in mat4 packedData); // the 4x4 matrix to decode data from\n\n// Generates a random number in range [0, 1].\n// The sequence is ruled by the frag coordinates and frameID, if frameID is constant, output will be time-invariant.\nfloat Vespro_random();\n\n// Returns a quaternion identity\nvec4 Vespro_quaternion();\n\n// Constructs a normalized quaternion from a given angle and a rotation axis\nvec4 Vespro_quaternion( in float angleDeg, // the rotation angle in degrees\n                        in vec3 axis );    // the rotation axis (normalized)\n\n// Computes a quaternion's inverse (q^-1)\nvec4 Vespro_quaternionConjugate(in vec4 q);\n\n// Rotates a point from a given normalized quaternion\nvec3 Vespro_quaternionMul( in vec4 q,   // a normalized quaternion representing a rotation\n                           in vec3 p ); // the point to rotate\n\n// Inversely rotates a point from a given normalized quaternion\nvec3 Vespro_quaternionMul( in vec3 p,   // the point to inversely rotate\n                           in vec4 q ); // a normalized quaternion representing a rotation\n\n// Multiplies two quaternions together\nvec4 Vespro_quaternionMul( in vec4 q1,   // the first  quaternion\n                           in vec4 q2 ); // the second quaternion\n\n// Generates an anti-aliased look-at ray origin and direction (observer) from a given field of view.\nvoid Vespro_getLookAtRay( in vec3 source,        // the point to look from (in world space)\n                          in vec3 target,        // the point to look at (in world space)\n                          in float fov,          // the field of view (in degrees)\n                          out vec3 ro,           // the output ray origin\n                          out vec3 rd,           // the output ray direction\n                          in bool antialiased ); // whether or not the ray should be temporally anti-aliased\n\n// Generates an anti-aliased view ray origin and direction (observer) from a given view-projection matrix.\nvoid Vespro_getViewProjectionRay( in mat4 viewMatrix,       // the view matrix\n                                  in mat4 projectionMatrix, // the projection matrix\n                                  out vec3 ro,              // the output ray origin\n                                  out vec3 rd,              // the output ray direction\n                                  in bool antialiased );    // whether or not the ray should be temporally anti-aliased\n\n// Samples a 2D texture unit from Vespro's sampler with bilinear filtering.\nvec4 Vespro_texture( in uint textureID, // the texture unit to sample, must be in range [0, Vespro_TEXTURE_UNITS - 1]\n                     in vec2 uv );      // the texture coordinates\n\n// Samples an environment map direction from Vespro's sampler.\nvec4 Vespro_texture( in uint textureID,   // the texture unit to sample, must be in range [0, Vespro_TEXTURE_UNITS - 1]\n                     in vec3 direction ); // the normalized sample direction (in world space)\n\n// Samples a 2D texture unit from Vespro's sampler with triplanar mapping.\nvec4 Vespro_texture( uint textureIDs, // the texture unit to sample, must be in range [0, Vespro_TEXTURE_UNITS - 1]\n                     in vec3 p,       // the surface position (controls the texture repetition)\n                     in vec3 n );     // the surface normal\n\n// Samples three 2D texture units from Vespro's sampler with triplanar mapping,\n// this versions allows to specify 3 different textures for each X, Y, Z axis.\nvec4 Vespro_texture( uvec3 textureIDs, // The texture units for each axis, must be in range [0, Vespro_TEXTURE_UNITS - 1]\n                     in vec3 p,        // the surface position (controls the texture repetition)\n                     in vec3 n );      // the surface normal\n\n// --------------------------- //\n//   Abstract (user-defined)   //\n// --------------------------- //\n\n// This callback must be implemented by the user, it's responsible of sampling the scene solid surfaces, and it's automatically\n// invoked by the integrator. The built-in Vespro_sampleXXX() can be used to sample pre-defined primitives.\n// For custom implicit and parametric surfaces, refer to Vespro_sampleSDF() and Vespro_depthTest() functions.\n// After a succesful sample, the surface properties can be overriden via:\n// Vespro_setSurfaceAlbedo(), Vespro_setSurfaceEmissive() and Vespro_setSurfaceNormal().\n// The sampled surface position and normal can be queried via Vespro_getSurfacePosition(), Vespro_getSurfaceNormal().\nvoid Vespro_surfaceSampler( in vec3 ro,   // the ray origin    (used to evaluate custom SDFs or intersectors)\n                            in vec3 rd ); // the ray direction (used to evaluate custom intersectors)\n\n// This callback must be implemented by the user, it's responsible for sampling the participating media densities\n// on the created nodes, and it's automatically invoked by the integrator. Each participating medium density must be set by calling:\n// Vespro_setDensity(mediumID, density);\n// All media of the given node will assume zero density unless explicitly set from within the callback.\nvoid Vespro_densitySampler( in uint nodeID,  // the input node (unique identifier) to sample\n                            in vec3 pLocal,  // the input position to sample, relative to the node (normalized space)\n                            in vec3 pWorld); // the input position to sample, in absolute space (world space)\n\n// This callback must be implemented by the user, it's responsible for sampling the ingoing radiance along a given ray,\n// and it's automatically invoked by the integrator. This function can be used to sample environment maps,\n// or extra directional lights that are not importance-sampled. The radiance must be set by calling Vespro_setRadiance(radiance);\n// The ingoing radiance will be assumed to be zero unless explicitly set from within the callback.\nvoid Vespro_radianceSampler(in vec3 rd); // the input direction to sample ingoing radiance from\n\n// ----------------------------------------------------------------------------------------------------------------------------------------------------------------- //\n\n// The shared uniforms, duplicated in buffers B,C,D, Image\n// as we want to reserve the Common tab for the scene code only\nstruct Uniforms\n{\n    int  spp;\n    int  tileID;\n    int  lastFrameTileID;\n    int  fenceStepID;\n    bool tileResolved;\n    bool previewMode;\n\n    vec2 tileRes;\n    vec2 canvasRes;\n    vec2 previewRes;\n\n    vec2 lastScreenRes;\n    bool validFrame;\n    int  frameID;\n\n    vec3 cameraPosition;\n    vec2 cameraPitchYaw;\n    vec4 mouseAnchor;\n\n    bool  exposureLocked;\n    float avgLuminance;\n    float exposure;\n\n    bool displayTiles;\n    vec3 sunDirection;\n};\n\nvoid Uniforms_Load(in sampler2D s, out Uniforms u)\n{\n    vec3 data = texelFetch(s, ivec2(0, 0), 0).xyz;\n    u.tileResolved = bool(data.x);\n    float packedTileIDs = data.y;\n    u.avgLuminance = data.z;\n\n    data = texelFetch(s, ivec2(1, 0), 0).xyz;\n    u.lastScreenRes = data.xy;\n    u.cameraPosition.x = data.z;\n\n    data = texelFetch(s, ivec2(2, 0), 0).xyz;\n    u.cameraPosition.yz = data.xy;\n    u.cameraPitchYaw.x = data.z;\n\n    data = texelFetch(s, ivec2(3, 0), 0).xyz;\n    u.cameraPitchYaw.y = data.x;\n    u.previewRes = data.yz;\n\n    data = texelFetch(s, ivec2(4, 0), 0).xyz;\n    u.validFrame = bool(data.x);\n    u.mouseAnchor.xy = data.yz;\n\n    data = texelFetch(s, ivec2(5, 0), 0).xyz;\n    u.mouseAnchor.zw = data.xy;\n    u.previewMode = bool(data.z);\n\n    data = texelFetch(s, ivec2(6, 0), 0).xyz;\n    u.frameID = int(data.x);\n    u.canvasRes = data.yz;\n\n    data = texelFetch(s, ivec2(7, 0), 0).xyz;\n    u.spp = int(data.x);\n    u.tileRes = data.yz;\n\n    data = texelFetch(s, ivec2(8, 0), 0).xyz;\n    u.exposure = data.x;\n    u.fenceStepID = int(data.y);\n    u.displayTiles = bool(data.z);\n\n    data = texelFetch(s, ivec2(9, 0), 0).xyz;\n    u.exposureLocked = bool(data.x);\n    u.sunDirection = _Vespro_unpackNormal(data.yz);\n    \n    vec2 tileIDs = unpackHalf2x16(floatBitsToUint(packedTileIDs));\n    u.tileID = int(tileIDs.x);\n    u.lastFrameTileID = int(tileIDs.y);\n}\n\nbool screenToTile(in int tileID, in vec2 fragCoord, in ivec2 size, out ivec2 tileTexCoord[4])\n{\n    fragCoord = floor(fragCoord);\n\n    ivec2 tileCoord = ivec2(tileID % int(ceil(iResolution.x / float(size.x))),\n                            tileID / int(ceil(iResolution.x / float(size.x)))) * size;\n\n    if((int(fragCoord.x) < tileCoord.x || int(fragCoord.x) >= tileCoord.x + size.x) ||\n       (int(fragCoord.y) < tileCoord.y || int(fragCoord.y) >= tileCoord.y + size.y)) return false;\n\n    tileTexCoord[0] = ivec2(fragCoord) - tileCoord;\n    tileTexCoord[1] = tileTexCoord[0] + size * ivec2(1, 0);\n    tileTexCoord[2] = tileTexCoord[0] + size * ivec2(0, 1);\n    tileTexCoord[3] = tileTexCoord[0] + size * ivec2(1, 1);\n\n    return true;\n}\n\nvec3 tonemapUncharted2(in vec3 col, in float exposure)\n{\n    const float A = 0.15;\n    const float B = 0.50;\n    const float C = 0.10;\n    const float D = 0.20;\n    const float E = 0.02;\n    const float F = 0.30;\n    const float W = 11.2;\n\n    const float whiteScale = 1.3790642466494378;\n\n    vec3 x = (col * 6.0 * exposure);\n\n    return (((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F) * whiteScale;\n}\n\nvec3 applyColorCorrection(in vec3 color, in float exposure)\n{\n    color += 4e-5; // black saturation\n\n    color = tonemapUncharted2(color, exposure); // tone mapping\n    color = pow(color, vec3(1.0 / 2.24)); // linear to gamma space\n    \n    color = pow(color, vec3(1.4)); // constrast\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel3, ivec2(fragCoord), 0);\n\n    uint integratedSamples = floatBitsToUint(fragColor.a);\n    if(integratedSamples > 0u) fragColor.rgb /= float(integratedSamples);\n\n    Uniforms u;\n    Uniforms_Load(iChannel2, u);\n    \n    fragColor = vec4(applyColorCorrection(fragColor.rgb, u.exposure), 1);\n    \n    if(u.previewMode || !u.displayTiles) return;\n\n    ivec2 tileFragCoord[4];\n    if(screenToTile(u.lastFrameTileID, fragCoord, ivec2(u.tileRes), tileFragCoord))\n    {\n    \n#if (1) // show sampling progression in the tile\n\n        mat4 fragData = mat4(texelFetch(iChannel1, tileFragCoord[0], 0),\n                             texelFetch(iChannel1, tileFragCoord[1], 0),\n                             texelFetch(iChannel1, tileFragCoord[2], 0),\n                             texelFetch(iChannel1, tileFragCoord[3], 0));\n                            \n        Vespro_loadAsyncState(fragData);\n\n        if(u.frameID > 0 && _VesproCtx.integratedSamples > integratedSamples)\n        {\n            fragColor.rgb = _VesproCtx.radiativeTransfer / float(max(_VesproCtx.integratedSamples, 1u));\n            fragColor.rgb = applyColorCorrection(fragColor.rgb, u.exposure);\n        }\n#endif   \n\n        float e = 0.0;\n        e = max(e, smoothstep(0.5, 0.25, abs(float(tileFragCoord[0].x) - 0.25)));\n        e = max(e, smoothstep(0.5, 0.25, abs(float(tileFragCoord[0].x) - (float(u.tileRes.x) - 1.25))));\n        e = max(e, smoothstep(0.5, 0.25, abs(float(tileFragCoord[0].y) - 0.25)));\n        e = max(e, smoothstep(0.5, 0.25, abs(float(tileFragCoord[0].y) - (float(u.tileRes.y) - 1.25))));\n\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0) - fragColor.rgb, e);\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//   __      __  _____    _____     _____    _____     _____\n//   \\ \\    / / | ____|  / ____|   |  __ \\  |  __ \\   / ____ \\\n//    \\ \\  / /  | |___  | |____    | |__) | | |__) | | |    | |\n//     \\ \\/ /   |  ___|  \\_____ \\  |  ___/  |  _  /  | |    | |\n//      \\  /    | |___    _____) | | |      | | \\ \\  | |____| |\n//       \\/     |_____|  |_____/   |_|      |_|  \\_\\  \\______/\n//\n//                      VOLUMETRIC PATH TRACER           v.3.2.3\n//\n//    Developed by: Lorenzo Vannuccini, blackravenprod@gmail.com\n\n\n// ------------------------------------------------------------------ //\n//                         Minified Sources                           //\n// ------------------------------------------------------------------ //\n\n// v.3.2.3 - Full open sources with complete documentation can be found here: https://www.shadertoy.com/view/lXd3DX\n#define IMPORT_VESPRO(MAX_NODES, MAX_MEDIA, MAX_LIGHTS, MAX_TEXTURES, MAX_STEPS, ZFAR) _VESPRO_IMP0(MAX_NODES, MAX_MEDIA, MAX_LIGHTS, MAX_TEXTURES, MAX_STEPS, ZFAR) _VESPRO_IMP1()\n#define _VESPRO_IMP0(_a, _b, _c, _d, _e, _f) const uint Vespro_MAX_NODES=uint(_a),Vespro_MAX_MEDIA=uint(_b),Vespro_MAX_LIGHTS=uint(_c),Vespro_MAX_TEXTURES=uint(_d),Vespro_MAX_STEPS=uint(_e);const float Vespro_ZFAR=float(_f);struct Vespro_Light{vec3 intensity;vec3 position;float radius;};struct Vespro_Photon{vec3 position;vec3 direction;float throughput;bool initialized;};struct Vespro_Surface{vec3 albedo;vec3 emissive;vec3 normal;};struct Vespro_Medium{vec3 scattering;vec3 absorption;float density;float phaseG;};struct Vespro_BoundingVolume{vec3 position,size;bool isBoundingSphere;};struct Vespro_Node{Vespro_BoundingVolume boundingVolume;Vespro_Medium media[max(Vespro_MAX_MEDIA,1u)];vec3 extinctionMajorant;bool selected;};struct Vespro_Context{Vespro_Photon primaryPhoton;Vespro_Photon misPhoton;bool primaryScattered;vec3 radiativeTransfer;uint integratedSamples;Vespro_Light lights[max(Vespro_MAX_LIGHTS,1u)];Vespro_Node nodes[max(Vespro_MAX_NODES,1u)];Vespro_Surface surfaceSample;vec3 sampleRo,sampleRd;bool batchSampleState;bool samplingImplicitDistance;float implicitDistance;float implicitDepth;float depth;uint nodeID;uint surfaceSamplerType;vec3 radianceSample;float depthOffset;vec3 origin;vec2 viewport;vec2 fragCoord;float randomSeed;uint profile;bool no_unroll;} _VesproCtx;struct Vespro_Enum{uint id;};const Vespro_Enum Vespro_TRANSMITTANCE=Vespro_Enum(0u),Vespro_SINGLE_SCATTERING=Vespro_Enum(1u),Vespro_MULTIPLE_SCATTERING=Vespro_Enum(2u),Vespro_PARAMETRIC_SURFACES=Vespro_Enum(3u),Vespro_IMPLICIT_SURFACES=Vespro_Enum(4u),Vespro_IMPLICIT_DISTANCE=Vespro_Enum(5u),Vespro_IMPLICIT_DERIVATIVES=Vespro_Enum(6u);void Vespro_surfaceSampler(in vec3 ro, in vec3 rd);void Vespro_radianceSampler(in vec3 rd);void Vespro_densitySampler(in uint nodeID, in vec3 pLocal, in vec3 pWorld);void Vespro_createLight(uint lightID,vec3 intensity,vec3 position,float radius){if(lightID<Vespro_MAX_LIGHTS)_VesproCtx.lights[lightID]=Vespro_Light(intensity,position,radius);}void Vespro_createMedium(uint nodeID,uint mediumID,vec3 scatteringCoeff,vec3 absorptionCoeff,float phaseG){if(nodeID<Vespro_MAX_NODES&&mediumID<Vespro_MAX_MEDIA){scatteringCoeff=max(scatteringCoeff,0.);absorptionCoeff=max(absorptionCoeff,0.);phaseG=clamp(phaseG,-1.,1.);Vespro_Medium lastParticipatingMedium=_VesproCtx.nodes[nodeID].media[mediumID];vec3 lastExtinction=lastParticipatingMedium.scattering+lastParticipatingMedium.absorption;_VesproCtx.nodes[nodeID].extinctionMajorant+=scatteringCoeff+absorptionCoeff-lastExtinction;_VesproCtx.nodes[nodeID].media[mediumID]=Vespro_Medium(scatteringCoeff,absorptionCoeff,1.,phaseG);}}void Vespro_setDepthOffset(float depthOffset){_VesproCtx.depthOffset=max(depthOffset,0.);}float _Vespro_evaluateDepthOffset(vec3 p){return max(distance(_VesproCtx.origin,p),1.)*_VesproCtx.depthOffset;}Vespro_Node _Vespro_createEmptyNode(){Vespro_Node node;for(uint i=0u;i<Vespro_MAX_MEDIA;++i)node.media[i]=Vespro_Medium(vec3(0),vec3(0),1.,0.);node.boundingVolume=Vespro_BoundingVolume(vec3(0),vec3(0),false);node.extinctionMajorant=vec3(0);node.selected=false;return node;}void Vespro_initContext(Vespro_Enum profile,vec2 fragCoord,vec2 viewportSize,int frameID){_VesproCtx.primaryPhoton=Vespro_Photon(vec3(0),vec3(0),1.,false);_VesproCtx.misPhoton=Vespro_Photon(vec3(0),vec3(0),1.,false);_VesproCtx.primaryScattered=false;_VesproCtx.radiativeTransfer=vec3(0);_VesproCtx.integratedSamples=0u;for(uint i=0u;i<Vespro_MAX_NODES;++i)_VesproCtx.nodes[i]=_Vespro_createEmptyNode();_VesproCtx.surfaceSample=Vespro_Surface(vec3(0),vec3(0),vec3(0));_VesproCtx.radianceSample=vec3(0);_VesproCtx.depthOffset=1e-5;_VesproCtx.implicitDepth=0.;_VesproCtx.nodeID=0u;float time=float(frameID)/60.,fragSeed=(fragCoord.x+3840.*fragCoord.y)/2160.;_VesproCtx.randomSeed=time*sin(time)+fragSeed;_VesproCtx.fragCoord=fragCoord;_VesproCtx.origin=vec3(0);_VesproCtx.viewport=viewportSize;_VesproCtx.profile=profile.id;_VesproCtx.no_unroll=all(greaterThanEqual(vec4(fragCoord,viewportSize),vec4(0)))&&frameID>=0;}void Vespro_createNode(uint nodeID,vec3 position,vec3 size){if(nodeID<Vespro_MAX_NODES){_VesproCtx.nodes[nodeID]=_Vespro_createEmptyNode();_VesproCtx.nodes[nodeID].boundingVolume=Vespro_BoundingVolume(position,size,false);}}void Vespro_createNode(uint nodeID,vec3 position,float radius){if(nodeID<Vespro_MAX_NODES){_VesproCtx.nodes[nodeID]=_Vespro_createEmptyNode();_VesproCtx.nodes[nodeID].boundingVolume=Vespro_BoundingVolume(position,vec3(radius),true);}}Vespro_Photon _Vespro_getActivePhoton(out bool importanceSampledLightPath){if(_VesproCtx.misPhoton.throughput<=0.)_VesproCtx.misPhoton.initialized=false;importanceSampledLightPath=_VesproCtx.primaryPhoton.initialized&&_VesproCtx.misPhoton.initialized; if(importanceSampledLightPath) return _VesproCtx.misPhoton; else return _VesproCtx.primaryPhoton;}void _Vespro_updateActivePhoton(bool importanceSampledLightPath,Vespro_Photon photon){if(importanceSampledLightPath)_VesproCtx.misPhoton=photon;else _VesproCtx.primaryPhoton=photon;}vec3 _Vespro_evaluateExtinctionMajorant(){vec3 extinctionMajorant=vec3(0);for(uint i=0u;i<Vespro_MAX_NODES;++i)if(_VesproCtx.nodes[i].selected)extinctionMajorant+=_VesproCtx.nodes[i].extinctionMajorant;return extinctionMajorant;}vec3 _Vespro_worldSpaceToNode(uint nodeID,vec3 p){Vespro_BoundingVolume bv=_VesproCtx.nodes[nodeID].boundingVolume;p-=bv.position;p/=bv.isBoundingSphere?bv.size.xxx:bv.size;return p;}bool _Vespro_insideNode(uint nodeID,vec3 p){Vespro_BoundingVolume bv=_VesproCtx.nodes[nodeID].boundingVolume;bool inside=all(greaterThanEqual(p,bv.position-bv.size))&&all(lessThanEqual(p,bv.position+bv.size));if(inside&&bv.isBoundingSphere){vec3 v=p-bv.position;float l_sq=dot(v,v);inside=l_sq<=bv.size.y*bv.size.y;}return inside;}void Vespro_setRadiance(vec3 radiance){_VesproCtx.radianceSample=max(radiance,0.);}void Vespro_setDensity(uint mediumID,float density){if(mediumID<Vespro_MAX_MEDIA)_VesproCtx.nodes[_VesproCtx.nodeID].media[mediumID].density=clamp(density,0.0,1.0);}void Vespro_setSurfaceAlbedo(vec3 albedo){_VesproCtx.surfaceSample.albedo=clamp(albedo,0.0,1.0);}void Vespro_setSurfaceEmissive(vec3 emissive){_VesproCtx.surfaceSample.emissive=max(emissive,0.);}vec3 Vespro_getSurfaceAlbedo(){return _VesproCtx.surfaceSample.albedo;}vec3 Vespro_getSurfaceEmissive(){return _VesproCtx.surfaceSample.emissive;}void Vespro_setSurfaceNormal(vec3 normal){_VesproCtx.surfaceSample.normal=normal;}vec3 Vespro_getSurfacePosition(){float z=_VesproCtx.surfaceSamplerType!=Vespro_IMPLICIT_SURFACES.id?_VesproCtx.depth:0.;return _VesproCtx.sampleRo+_VesproCtx.sampleRd*z;}vec3 Vespro_getSurfaceNormal(){return _VesproCtx.surfaceSample.normal;}void Vespro_beginBatchSampling(){_VesproCtx.batchSampleState=false;}bool Vespro_validateBatchSampling(){return _VesproCtx.batchSampleState;}bool Vespro_sampleSDF(float sd){if(_VesproCtx.surfaceSamplerType==Vespro_PARAMETRIC_SURFACES.id)return false;if(sd<=_VesproCtx.implicitDistance||isinf(_VesproCtx.implicitDistance)){_VesproCtx.implicitDistance=sd;bool retval=_VesproCtx.surfaceSamplerType==Vespro_IMPLICIT_SURFACES.id;if(retval)_VesproCtx.batchSampleState=true;return retval;}return false;}vec2 _Vespro_intersectBox(vec3 ro,vec3 rd,vec3 boxPosition,vec3 boxSize,out vec3 normal){vec3 m=1./rd,n=m*(ro-boxPosition),k=abs(m)*boxSize,t1=-n-k,t2=-n+k;float tN=max(max(t1.x,t1.y),t1.z),tF=min(min(t2.x,t2.y),t2.z);normal=step(vec3(tN),t1)*-sign(rd);return tN<=tF&&tF>=0.?vec2(tN,tF):vec2(-1);}bool Vespro_sampleAABB(vec3 position,vec3 size){if(_VesproCtx.surfaceSamplerType==Vespro_IMPLICIT_DERIVATIVES.id)return true;vec3 n;vec2 i=_Vespro_intersectBox(_VesproCtx.sampleRo,_VesproCtx.sampleRd,position,size+1e1*_VesproCtx.depthOffset,n);i.x=max(i.x,0.);bool retval=i.y>=0.&&i.x>=0.&&(i.x<_VesproCtx.depth||_VesproCtx.depth<0.);if(retval)_VesproCtx.batchSampleState=true;return retval;}bool Vespro_sampleBoxFrame(vec3 position,vec3 size,float thickness){if(_VesproCtx.surfaceSamplerType==Vespro_PARAMETRIC_SURFACES.id)return false;if(!Vespro_sampleAABB(position,size))return false;vec3 p=abs(_VesproCtx.sampleRo-position)-size,q=abs(p+thickness)-thickness;return Vespro_sampleSDF(min(min(length(max(vec3(p.x,q.yz),0.))+min(max(p.x,max(q.y,q.z)),0.),length(max(vec3(q.x,p.y,q.z),0.))+min(max(q.x,max(p.y,q.z)),0.)),length(max(vec3(q.xy,p.z),0.))+min(max(q.x,max(q.y,p.z)),0.)));}bool Vespro_sampleCapsule(vec3 a,vec3 b,float r){if(_VesproCtx.surfaceSamplerType==Vespro_PARAMETRIC_SURFACES.id)return false;vec3 aabb_min=min(a,b),aabb_max=max(a,b),aabb_pos=(aabb_min+aabb_max)*.5,aabb_size=(aabb_max-aabb_min)*.5+r;if(!Vespro_sampleAABB(aabb_pos,aabb_size))return false;vec3 pa=_VesproCtx.sampleRo-a,ba=b-a;float h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);return Vespro_sampleSDF(length(pa-ba*h)-r);}bool Vespro_sampleCylinder(vec3 a,vec3 b,float r){if(_VesproCtx.surfaceSamplerType==Vespro_PARAMETRIC_SURFACES.id)return false;vec3 aabb_min=min(a,b),aabb_max=max(a,b),aabb_pos=(aabb_min+aabb_max)*.5,aabb_size=(aabb_max-aabb_min)*.5+r;if(!Vespro_sampleAABB(aabb_pos,aabb_size))return false;vec3 ba=b-a,pa=_VesproCtx.sampleRo-a;float baba=dot(ba,ba),paba=dot(pa,ba),x=length(pa*baba-ba*paba)-r*baba,y=abs(paba-baba*.5)-baba*.5,x2=x*x,y2=y*y*baba,d=max(x,y)<0.?-min(x2,y2):(x>0.?x2:0.)+(y>0.?y2:0.);return Vespro_sampleSDF(sign(d)*sqrt(abs(d))/baba);}bool Vespro_sampleTorus(vec3 position,float radius,float thickness){if(_VesproCtx.surfaceSamplerType==Vespro_PARAMETRIC_SURFACES.id)return false;if(!Vespro_sampleAABB(position,vec3(vec2(radius+thickness),thickness).xzy))return false;vec3 p=_VesproCtx.sampleRo-position;vec2 q=vec2(length(p.xz)-radius,p.y);return Vespro_sampleSDF(length(q)-thickness);}vec2 _Vespro_intersectSphere(vec3 ro,vec3 rd,vec3 spherePosition,float sphereRadius){vec3 oc=ro-spherePosition;float a=dot(rd,rd),b=2.*dot(rd,oc),c=dot(oc,oc)-sphereRadius*sphereRadius,h=b*b-4.*dot(rd,rd)*c;if(h<0.||a==0.)return vec2(-1);h=sqrt(h);return vec2(-b-h,-b+h)/(2.*a);}vec2 _Vespro_intersectNode(uint nodeID,vec3 ro,vec3 rd){vec2 i=vec2(-1);Vespro_BoundingVolume bv=_VesproCtx.nodes[nodeID].boundingVolume;if(all(greaterThan(bv.size,vec3(0)))){vec3 n;i=bv.isBoundingSphere?_Vespro_intersectSphere(ro,rd,bv.position,bv.size.y):_Vespro_intersectBox(ro,rd,bv.position,bv.size,n);}return i;}bool Vespro_sampleNode(uint nodeID){if(nodeID>=Vespro_MAX_NODES)return false;if(_VesproCtx.surfaceSamplerType==Vespro_IMPLICIT_DERIVATIVES.id)return true;vec2 i=_Vespro_intersectNode(nodeID,_VesproCtx.sampleRo,_VesproCtx.sampleRd);i.x=max(i.x,0.);bool retval=i.y>=0.&&i.x>=0.&&(i.x<_VesproCtx.depth||_VesproCtx.depth<0.);if(retval)_VesproCtx.batchSampleState=true;return retval;}vec2 _Vespro_intersectNodes(vec3 ro,vec3 rd){vec2 crossSection=vec2(-1);for(uint i=0u;i<Vespro_MAX_NODES;++i){vec2 depth=_Vespro_intersectNode(i,ro,rd);if(depth.y>0.){depth.x=max(depth.x,0.);crossSection.x=crossSection.x<0.?depth.x:min(crossSection.x,depth.x);}}if(crossSection.x<0.)return crossSection;for(uint i=0u;i<Vespro_MAX_NODES;++i){vec2 depth=_Vespro_intersectNode(i,ro,rd);if(depth.y>0.){float z=depth.x>crossSection.x?depth.x:depth.y;crossSection.y=crossSection.y<0.?z:min(crossSection.y,z);}}crossSection.x=max(crossSection.x,0.);crossSection+=vec2(_Vespro_evaluateDepthOffset(ro+rd*crossSection.x),_Vespro_evaluateDepthOffset(ro+rd*crossSection.y)) * vec2(greaterThan(crossSection,vec2(0)));return crossSection;}float Vespro_random(){uint v=uint(_VesproCtx.fragCoord.x),s=uint(_VesproCtx.fragCoord.y),u=floatBitsToUint(_VesproCtx.randomSeed++),seed=u*1664525u+v+s;seed=seed^61u^seed>>16u;seed*=9u;seed^=seed>>4u;seed*=uint(668265261);seed^=seed>>15u;return float(seed)/4294967296.;}vec3 _Vespro_importanceSamplePhaseHG(float g,vec3 incomingDirection){float phi=6.283185307179586*Vespro_random(),cosTheta=-1.+2.*Vespro_random();if(abs(g)>=1e-6){float one_plus_g2=1.+g*g,one_minus_g2=1.-g*g,one_over_2g=.5/g,t=one_minus_g2/(1.-g+2.*g*(.5+.5*cosTheta));cosTheta=one_over_2g*(one_plus_g2-t*t);}float sinTheta=sqrt(max(0.,1.-cosTheta*cosTheta));const vec3 up=vec3(0,1,0),right=vec3(1,0,0);vec3 t0,t1;if(abs(dot(incomingDirection,up))>.001){t0=normalize(cross(incomingDirection,up));t1=normalize(cross(incomingDirection,t0));}else{t0=normalize(cross(incomingDirection,right));t1=normalize(cross(incomingDirection,t0));}return normalize(sinTheta*sin(phi)*t0+sinTheta*cos(phi)*t1+cosTheta*incomingDirection);}Vespro_Medium _Vespro_importanceSampleParticipatingMedia(vec3 p){Vespro_Medium importanceSampledMedium=Vespro_Medium(vec3(0),vec3(0),1.,0.);uint nScatteringMedia=0u;bool anisotropicScattering=false;for(uint i=0u;i<Vespro_MAX_NODES;++i)if(_VesproCtx.nodes[i].selected){for(uint j=0u;j<Vespro_MAX_MEDIA;++j)_VesproCtx.nodes[i].media[j].density=0.;_VesproCtx.nodeID=i;Vespro_densitySampler(i,_Vespro_worldSpaceToNode(i,p),p);for(uint j=0u;j<Vespro_MAX_MEDIA;++j){Vespro_Medium medium=_VesproCtx.nodes[i].media[j];vec3 scattering=medium.scattering*medium.density,absorption=medium.absorption*medium.density;importanceSampledMedium.scattering+=scattering;importanceSampledMedium.absorption+=absorption;bool hasScattering=dot(scattering,scattering)>0.;if(hasScattering){if(abs(medium.phaseG)>=1e-6)anisotropicScattering=true;++nScatteringMedia;}}}if(anisotropicScattering){uint randomScatterMediumID=clamp(uint(Vespro_random()*float(nScatteringMedia)),0u,nScatteringMedia-1u);float scatteringPDF=1./float(nScatteringMedia);nScatteringMedia=0u;for(uint i=0u;i<Vespro_MAX_NODES;++i)if(_VesproCtx.nodes[i].selected)for(uint j=0u;j<Vespro_MAX_MEDIA;++j){Vespro_Medium medium=_VesproCtx.nodes[i].media[j];vec3 scattering=medium.scattering*medium.density;bool hasScattering=dot(scattering,scattering)>0.;if(!hasScattering)continue;++nScatteringMedia;if(randomScatterMediumID==nScatteringMedia-1u){importanceSampledMedium.scattering=scattering/scatteringPDF;importanceSampledMedium.phaseG=medium.phaseG;}}}return importanceSampledMedium;}vec4 Vespro_quaternion(){return vec4(0,0,0,1);}vec4 Vespro_quaternion(float angleDeg,vec3 axis){float angleRad=radians(angleDeg);return vec4(axis*sin(angleRad*.5),cos(angleRad*.5));}vec4 Vespro_quaternionConjugate(vec4 q){return vec4(-q.x,-q.y,-q.z,q.w);}vec3 Vespro_quaternionMul(vec3 p,vec4 q){vec4 q2=vec4(p*q.w+cross(p,-q.xyz),-dot(p,-q.xyz));return q2.xyz*q.w+q.xyz*q2.w+cross(q.xyz,q2.xyz);}float Vespro_distance(vec3 p){return distance(p,_VesproCtx.origin);}bool Vespro_sampleBoxFrame(vec3 position,vec3 size,float thickness,vec4 orientation){if(_VesproCtx.surfaceSamplerType==Vespro_PARAMETRIC_SURFACES.id)return false;vec3 ro_tmp=_VesproCtx.sampleRo,rd_tmp=_VesproCtx.sampleRd;_VesproCtx.sampleRo=Vespro_quaternionMul(_VesproCtx.sampleRo,orientation);_VesproCtx.sampleRd=Vespro_quaternionMul(_VesproCtx.sampleRd,orientation);position=Vespro_quaternionMul(position,orientation);bool retval=Vespro_sampleBoxFrame(position,size,thickness);_VesproCtx.sampleRo=ro_tmp,_VesproCtx.sampleRd=rd_tmp;return retval;}bool Vespro_sampleCapsule(vec3 a,vec3 b,float r,vec4 orientation){if(_VesproCtx.surfaceSamplerType==Vespro_PARAMETRIC_SURFACES.id)return false;vec3 ro_tmp=_VesproCtx.sampleRo,rd_tmp=_VesproCtx.sampleRd;_VesproCtx.sampleRo=Vespro_quaternionMul(_VesproCtx.sampleRo,orientation);_VesproCtx.sampleRd=Vespro_quaternionMul(_VesproCtx.sampleRd,orientation);vec3 pivot=(a+b)*.5;a-=pivot;b-=pivot;pivot=Vespro_quaternionMul(pivot,orientation);a+=pivot;b+=pivot;bool retval=Vespro_sampleCapsule(a,b,r);_VesproCtx.sampleRo=ro_tmp,_VesproCtx.sampleRd=rd_tmp;return retval;}bool Vespro_sampleCylinder(vec3 a,vec3 b,float r,vec4 orientation){if(_VesproCtx.surfaceSamplerType==Vespro_PARAMETRIC_SURFACES.id)return false;vec3 ro_tmp=_VesproCtx.sampleRo,rd_tmp=_VesproCtx.sampleRd;_VesproCtx.sampleRo=Vespro_quaternionMul(_VesproCtx.sampleRo,orientation);_VesproCtx.sampleRd=Vespro_quaternionMul(_VesproCtx.sampleRd,orientation);vec3 pivot=(a+b)*.5;a-=pivot;b-=pivot;pivot=Vespro_quaternionMul(pivot,orientation);a+=pivot;b+=pivot;bool retval=Vespro_sampleCylinder(a,b,r);_VesproCtx.sampleRo=ro_tmp,_VesproCtx.sampleRd=rd_tmp;return retval;}bool Vespro_sampleTorus(vec3 position,float radius,float thickness,vec4 orientation){if(_VesproCtx.surfaceSamplerType==Vespro_PARAMETRIC_SURFACES.id)return false;vec3 ro_tmp=_VesproCtx.sampleRo,rd_tmp=_VesproCtx.sampleRd;_VesproCtx.sampleRo=Vespro_quaternionMul(_VesproCtx.sampleRo,orientation);_VesproCtx.sampleRd=Vespro_quaternionMul(_VesproCtx.sampleRd,orientation);position=Vespro_quaternionMul(position,orientation);bool retval=Vespro_sampleTorus(position,radius,thickness);_VesproCtx.sampleRo=ro_tmp,_VesproCtx.sampleRd=rd_tmp;return retval;}vec3 Vespro_quaternionMul(vec4 q,vec3 p){return Vespro_quaternionMul(p,Vespro_quaternionConjugate(q));}vec4 Vespro_quaternionMul(vec4 q1,vec4 q2){return vec4(q2.xyz*q1.w+q1.xyz*q2.w+cross(q1.xyz,q2.xyz),q1.w*q2.w-dot(q1.xyz,q2.xyz));}bool _Vespro_depthTest(float srcDepth,inout float dstDepth){if(srcDepth>=0.&&(srcDepth<dstDepth||dstDepth<0.)){dstDepth=srcDepth;return true;}return false;}bool _Vespro_intersectLights(vec3 ro,vec3 rd){if(_VesproCtx.profile==Vespro_TRANSMITTANCE.id)return false;float rz=_VesproCtx.depth;bool intersectedLight=false;for(uint i=0u;i<Vespro_MAX_LIGHTS;++i){Vespro_Light light=_VesproCtx.lights[i];if(light.radius<=0.)continue;vec2 d=_Vespro_intersectSphere(ro,rd,light.position,light.radius);if(d.y<0.)continue;d.x=max(d.x,0.)+float(d.x>0.)*_VesproCtx.depthOffset;if(_Vespro_depthTest(d.x,rz)){_VesproCtx.surfaceSample.emissive=light.intensity;_VesproCtx.surfaceSample.albedo=vec3(0);intersectedLight=true;}}_VesproCtx.depth=rz;return intersectedLight;}bool Vespro_depthTest(float srcDepth){return _Vespro_depthTest(srcDepth,_VesproCtx.depth);}bool Vespro_sampleSphere(vec3 position,float radius){if(_VesproCtx.surfaceSamplerType!=Vespro_PARAMETRIC_SURFACES.id)return false;vec2 i=_Vespro_intersectSphere(_VesproCtx.sampleRo,_VesproCtx.sampleRd,position,radius);if(i.y>=0.&&Vespro_depthTest(max(i.x,0.))){vec3 p=_VesproCtx.sampleRo+_VesproCtx.sampleRd*_VesproCtx.depth,n=normalize(p-position);_VesproCtx.surfaceSample=Vespro_Surface(vec3(1),vec3(0),n);_VesproCtx.batchSampleState=true;return true;}return false;}bool Vespro_samplePlane(vec3 position,vec3 normal){if(_VesproCtx.surfaceSamplerType!=Vespro_PARAMETRIC_SURFACES.id)return false;float z=-dot(_VesproCtx.sampleRo-position,normal)/dot(_VesproCtx.sampleRd,normal);if(Vespro_depthTest(z)){_VesproCtx.surfaceSample=Vespro_Surface(vec3(1),vec3(0),normal);_VesproCtx.batchSampleState=true;return true;}return false;}bool Vespro_sampleBox(vec3 position,vec3 size){if(_VesproCtx.surfaceSamplerType!=Vespro_PARAMETRIC_SURFACES.id)return false;vec3 n;vec2 i=_Vespro_intersectBox(_VesproCtx.sampleRo,_VesproCtx.sampleRd,position,size,n);if(i.y>=0.&&Vespro_depthTest(max(i.x,0.))){_VesproCtx.surfaceSample=Vespro_Surface(vec3(1),vec3(0),n);_VesproCtx.batchSampleState=true;return true;}return false;}bool Vespro_sampleBox(vec3 position,vec3 size,vec4 orientation){if(_VesproCtx.surfaceSamplerType!=Vespro_PARAMETRIC_SURFACES.id)return false;vec3 ro_tmp=_VesproCtx.sampleRo,rd_tmp=_VesproCtx.sampleRd;_VesproCtx.sampleRo=Vespro_quaternionMul(_VesproCtx.sampleRo,orientation);_VesproCtx.sampleRd=Vespro_quaternionMul(_VesproCtx.sampleRd,orientation);position=Vespro_quaternionMul(position,orientation);bool retval=Vespro_sampleBox(position,size);if(retval)_VesproCtx.surfaceSample.normal=Vespro_quaternionMul(orientation,_VesproCtx.surfaceSample.normal);_VesproCtx.sampleRo=ro_tmp,_VesproCtx.sampleRd=rd_tmp;return retval;}bool Vespro_sampleCornellBox(vec3 position,float size){if(_VesproCtx.surfaceSamplerType!=Vespro_PARAMETRIC_SURFACES.id)return false;bool sampleResult=false,lastBatchSampleState=_VesproCtx.batchSampleState;if(!Vespro_sampleAABB(position,vec3(size)))return sampleResult;const float thickness=.025;vec3 p=vec3(1.-thickness,-1.+thickness,0)*size;vec2 l=vec2(1,thickness)*size;Vespro_beginBatchSampling();Vespro_sampleBox(position+p.zyz,l.xyx);Vespro_sampleBox(position+p.zzy,l.xxy);Vespro_sampleBox(position+p.zxz,l.xyx);Vespro_sampleBox(position+p.yzz,l.yxx);Vespro_sampleBox(position+p.xzz,l.yxx);if(Vespro_validateBatchSampling()){vec3 n=Vespro_getSurfaceNormal(),p=Vespro_getSurfacePosition()-position;Vespro_setSurfaceAlbedo(vec3(.8));if(all(lessThan(abs(p),l.xxx-_VesproCtx.depthOffset))){if(n.x>.5)Vespro_setSurfaceAlbedo(vec3(.8,.02,.02));if(n.x<-.5)Vespro_setSurfaceAlbedo(vec3(.02,.8,.02));if(n.y<-.5&&all(lessThan(abs(p.xz),vec2(.25)*size)))Vespro_setSurfaceEmissive(vec3(100));}sampleResult=true;}Vespro_beginBatchSampling();vec4 q=Vespro_quaternion(-30.,vec3(0,1,0));Vespro_sampleBox(position+vec3(0,-l.x+l.y*2.,0)+vec3(-.35,.5,-.5)*size,vec3(.25,.55,.25)*size,q);q=Vespro_quaternion(30.,vec3(0,1,0));Vespro_sampleBox(position+vec3(0,-l.x+l.y*2.,0)+vec3(.325,.25,.325)*size,vec3(.25)*size,q);if(Vespro_validateBatchSampling()){Vespro_setSurfaceAlbedo(vec3(.8));sampleResult=true;}_VesproCtx.batchSampleState=lastBatchSampleState;if(sampleResult)_VesproCtx.batchSampleState=true;return sampleResult;}\n#define _VESPRO_IMP1() bool Vespro_sampleCornellBox(vec3 position,float size,vec4 orientation){if(_VesproCtx.surfaceSamplerType!=Vespro_PARAMETRIC_SURFACES.id)return false;vec3 ro_tmp=_VesproCtx.sampleRo,rd_tmp=_VesproCtx.sampleRd;_VesproCtx.sampleRo=Vespro_quaternionMul(orientation,_VesproCtx.sampleRo);_VesproCtx.sampleRd=Vespro_quaternionMul(orientation,_VesproCtx.sampleRd);position=Vespro_quaternionMul(orientation,position);bool retval=Vespro_sampleCornellBox(position,size);if(retval)_VesproCtx.surfaceSample.normal=Vespro_quaternionMul(_VesproCtx.surfaceSample.normal,orientation);_VesproCtx.sampleRo=ro_tmp,_VesproCtx.sampleRd=rd_tmp;return retval;}void Vespro_getViewProjectionRay(mat4 viewMatrix,mat4 projectionMatrix,out vec3 ro,out vec3 rd,bool antialiased){vec2 uv=vec2(_VesproCtx.fragCoord)/_VesproCtx.viewport;if(antialiased)uv+=vec2(Vespro_random()-.5,Vespro_random()-.5)/_VesproCtx.viewport;mat3 rotation=mat3(viewMatrix);ro=-transpose(rotation)*viewMatrix[3].xyz;rd=normalize(inverse(projectionMatrix*mat4(rotation))*vec4(-1.+2.*uv,1,1)).xyz;}void Vespro_getLookAtRay(vec3 source,vec3 target,float fov,out vec3 ro,out vec3 rd,bool antialiased){vec2 uv=_VesproCtx.fragCoord/_VesproCtx.viewport;if(antialiased)uv+=vec2(Vespro_random()-.5,Vespro_random()-.5)/_VesproCtx.viewport;float aspectRatio=_VesproCtx.viewport.x/_VesproCtx.viewport.y;vec3 up=vec3(0,1,0),viewDirection=normalize(source-target);if(length(cross(viewDirection,up))<1e-4)up=length(cross(viewDirection,vec3(1,0,0)))<1e-4?vec3(0,0,1):vec3(1,0,0);float theta=radians(fov),halfHeight=tan(theta*.5),halfWidth=aspectRatio*halfHeight;vec3 rightVector=normalize(cross(up,viewDirection)),actualUpVector=cross(viewDirection,rightVector),halfWidthVector=halfWidth*rightVector,halfHeightVector=halfHeight*actualUpVector,lowerLeftCorner=source-halfWidthVector-halfHeightVector-viewDirection,horizontalSpan=2.*halfWidthVector,verticalSpan=2.*halfHeightVector;ro=source;rd=normalize(lowerLeftCorner+uv.x*horizontalSpan+uv.y*verticalSpan-ro);}float _Vespro_phaseHG(float g,float cosTheta){const float epsilon=1e-6;g=min(abs(g),1.-epsilon)*sign(g);float denominator=1.+g*g-2.*g*cosTheta,normalization=1./12.56637061435917;return normalization*(1.-g*g)/pow(denominator,1.5);}vec3 _Vespro_tangentSpaceVectorToWorld(vec3 localDir,vec3 worldDir){vec3 up=abs(worldDir.z)<.99?vec3(0,0,1):vec3(1,0,0),tanX=normalize(cross(up,worldDir)),tanY=cross(worldDir,tanX);return normalize(localDir.x*tanX+localDir.y*tanY+localDir.z*worldDir);}vec3 _Vespro_importanceSampleSolidAngle(vec3 n,float steradian,out float pdf){float u=Vespro_random(),v=Vespro_random(),phi=6.283185307179586*u,theta=acos(1.-v+v*cos(steradian)),st=sin(theta),ct=cos(theta),sp=sin(phi),cp=cos(phi);pdf=6.283185307179586*(1.-cos(steradian));pdf=pdf>0.?1./pdf:0.;return _Vespro_tangentSpaceVectorToWorld(vec3(st*cp,st*sp,ct),n);}vec3 _Vespro_importanceSampleHemisphere(vec3 n,out float pdf){float u1=Vespro_random(),u2=Vespro_random(),ra=sqrt(u2),rx=ra*cos(6.283185307179586*u1),ry=ra*sin(6.283185307179586*u1),rz=sqrt(1.-u2);vec3 sampleDir=_Vespro_tangentSpaceVectorToWorld(vec3(rx,ry,rz),n);float costTheta=max(dot(sampleDir,n),0.);pdf=costTheta/3.141592653589793;return sampleDir;}vec3 _Vespro_importanceSampleLight(Vespro_Light light,vec3 p,out float pdf){pdf=0.;vec3 pToLight=light.position-p;float D=dot(pToLight,pToLight);if(D<light.radius*light.radius)return vec3(0);D=sqrt(D);pToLight/=D;float steradian=asin(clamp(light.radius/D,-1.,1.));return _Vespro_importanceSampleSolidAngle(pToLight,steradian,pdf);}Vespro_Photon _Vespro_importanceSampleLights(vec3 p){Vespro_Photon photon=Vespro_Photon(p,vec3(0),1.,false);if(_VesproCtx.profile==Vespro_TRANSMITTANCE.id)return photon;uint nDominantLights=0u;for(uint i=0u;i<Vespro_MAX_LIGHTS;++i){Vespro_Light light=_VesproCtx.lights[i];bool contributingLight=light.radius>0.&&dot(light.intensity,light.intensity)>0.;if(contributingLight)++nDominantLights;}if(nDominantLights>0u){uint lightID=clamp(uint(Vespro_random()*float(nDominantLights)),0u,nDominantLights-1u);nDominantLights=0u;Vespro_Light importanceSampledLight;for(uint i=0u;i<Vespro_MAX_LIGHTS;++i){Vespro_Light light=_VesproCtx.lights[i];bool contributingLight=light.radius>0.&&dot(light.intensity,light.intensity)>0.;if(!contributingLight)continue;++nDominantLights;if(lightID==nDominantLights-1u)importanceSampledLight=light;}float pdf;photon.direction=_Vespro_importanceSampleLight(importanceSampledLight,p,pdf);pdf/=float(nDominantLights);photon.throughput*=pdf>0.?1./pdf:0.;photon.initialized=true;}return photon;}bool _Vespro_integrateDiffuse(inout Vespro_Photon photon,vec3 wavelength,bool importanceSampledLightPath){if(_VesproCtx.profile==Vespro_TRANSMITTANCE.id)return true;if(_VesproCtx.depth<0.)return true;if(distance(photon.position,_VesproCtx.origin)>=Vespro_ZFAR)return true;const float wavelengthPDF=1./3.;_VesproCtx.radiativeTransfer+=_VesproCtx.surfaceSample.emissive*photon.throughput*wavelength/wavelengthPDF;if(importanceSampledLightPath)photon.throughput*=0.;if(photon.throughput<=0.)return true;if(dot(_VesproCtx.surfaceSample.normal,photon.direction)>0.)_VesproCtx.surfaceSample.normal*=-1.;photon.position+=photon.direction*_VesproCtx.depth;float depthOffset=_Vespro_evaluateDepthOffset(photon.position);photon.position-=photon.direction*_VesproCtx.depthOffset;photon.position+=_VesproCtx.surfaceSample.normal*_VesproCtx.depthOffset;float pdf;photon.direction=_Vespro_importanceSampleHemisphere(_VesproCtx.surfaceSample.normal,pdf);_VesproCtx.implicitDepth=0.;float costTheta=max(dot(photon.direction,_VesproCtx.surfaceSample.normal),0.),brdf=dot(_VesproCtx.surfaceSample.albedo*costTheta/3.141592653589793,wavelength);brdf=dot(_VesproCtx.surfaceSample.albedo,wavelength),pdf=1.;photon.throughput*=pdf>0.?brdf/pdf:0.;_VesproCtx.primaryScattered=true;_VesproCtx.misPhoton=_Vespro_importanceSampleLights(photon.position);_VesproCtx.misPhoton.throughput*=photon.throughput;pdf=1.;brdf=max(dot(_VesproCtx.surfaceSample.normal,_VesproCtx.misPhoton.direction)/3.141592653589793,0.);_VesproCtx.misPhoton.throughput*=pdf>0.?brdf/pdf:0.;if(_VesproCtx.profile==Vespro_SINGLE_SCATTERING.id)photon.throughput*=0.;return false;}bool _Vespro_integrateScatter(inout Vespro_Photon photon,vec3 wavelength,bool importanceSampledLightPath){bool lightPathIntersectsSurface=_VesproCtx.depth>=0.,surfaceHasEmission=dot(_VesproCtx.surfaceSample.emissive,_VesproCtx.surfaceSample.emissive)>0.;if(_VesproCtx.profile==Vespro_TRANSMITTANCE.id&&lightPathIntersectsSurface)photon.throughput=0.;if(importanceSampledLightPath&&lightPathIntersectsSurface&&!surfaceHasEmission)photon.throughput=0.;const float transmittanceCutoff=1e-9;if(photon.throughput<=transmittanceCutoff)photon.throughput=0.;if(photon.throughput<=0.)return true;if(distance(photon.position,_VesproCtx.origin)>=Vespro_ZFAR)return true;vec2 crossSection=_Vespro_intersectNodes(photon.position,photon.direction);if(crossSection.y<0.)return true;if(_VesproCtx.depth>=0.)crossSection.y=min(crossSection.y,_VesproCtx.depth);if(_VesproCtx.depth>=0.&&_VesproCtx.depth<=crossSection.x)return true;photon.position+=photon.direction*crossSection.x;for(uint i=0u;i<Vespro_MAX_NODES;++i)_VesproCtx.nodes[i].selected=_Vespro_insideNode(i,photon.position);float extinctionMajorant=dot(_Vespro_evaluateExtinctionMajorant(),wavelength);if(extinctionMajorant<=0.){photon.position+=photon.direction*(crossSection.y-crossSection.x);return false;}bool scatteringEvent=false,absorptionEvent=false,allowPhotonScattering=_VesproCtx.profile==Vespro_MULTIPLE_SCATTERING.id&&!importanceSampledLightPath;float sampleDistance=max(-log(1.0 - Vespro_random())/extinctionMajorant,_Vespro_evaluateDepthOffset(photon.position));photon.position+=photon.direction*min(sampleDistance,crossSection.y-crossSection.x);if(sampleDistance>=crossSection.y-crossSection.x)return false;Vespro_Medium medium=_Vespro_importanceSampleParticipatingMedia(photon.position);float scattering=dot(medium.scattering,wavelength),extinction=dot(medium.scattering+medium.absorption,wavelength),photonInteractionProbability=Vespro_random();if(scattering>0.&&photonInteractionProbability<=scattering/extinctionMajorant)scatteringEvent=true;else if(extinction>0.&&photonInteractionProbability<=extinction/extinctionMajorant)absorptionEvent=true;if(scatteringEvent){if(!importanceSampledLightPath){_VesproCtx.misPhoton=_Vespro_importanceSampleLights(photon.position);_VesproCtx.misPhoton.throughput*=photon.throughput;float pdf=1.,bsdf=_Vespro_phaseHG(medium.phaseG,dot(photon.direction,_VesproCtx.misPhoton.direction));_VesproCtx.misPhoton.throughput*=bsdf/pdf;}if(allowPhotonScattering){photon.direction=_Vespro_importanceSamplePhaseHG(medium.phaseG,photon.direction);_VesproCtx.primaryScattered=true;_VesproCtx.implicitDepth=0.;}else photon.throughput*=clamp(_Vespro_phaseHG(medium.phaseG,1.),0.0,1.0);}else if(absorptionEvent){photon.throughput=0.;return true;}return false;}float _Vespro_evaluateImplicitDistance(vec3 p){vec3 ro_tmp=_VesproCtx.sampleRo;_VesproCtx.sampleRo=p;_VesproCtx.implicitDistance=uintBitsToFloat(0x7F800000u);Vespro_surfaceSampler(_VesproCtx.sampleRo,_VesproCtx.sampleRd);_VesproCtx.sampleRo=ro_tmp;return _VesproCtx.implicitDistance;}vec3 _Vespro_evaluateImplicitDerivatives(vec3 p,float delta){_VesproCtx.surfaceSamplerType=Vespro_IMPLICIT_DERIVATIVES.id;const vec2 k=vec2(1,-1);return k.xyy*_Vespro_evaluateImplicitDistance(p+k.xyy*delta)+k.yyx*_Vespro_evaluateImplicitDistance(p+k.yyx*delta)+k.yxy*_Vespro_evaluateImplicitDistance(p+k.yxy*delta)+k.xxx*_Vespro_evaluateImplicitDistance(p+k.xxx*delta);}bool _Vespro_intersectImplicitSurfacesAsync(){float maxTracingDistance=uintBitsToFloat(0x7F800000u);if(_VesproCtx.depth>=0.)maxTracingDistance=min(_VesproCtx.depth,maxTracingDistance);vec3 p=_VesproCtx.sampleRo+_VesproCtx.sampleRd*_VesproCtx.implicitDepth;_VesproCtx.surfaceSamplerType=Vespro_IMPLICIT_DISTANCE.id;float d=max(_Vespro_evaluateImplicitDistance(p),0.);if(d>=maxTracingDistance||_VesproCtx.implicitDepth>=maxTracingDistance||distance(p,_VesproCtx.origin)>=Vespro_ZFAR)return true;float depthOffset=_Vespro_evaluateDepthOffset(p);if(d<=depthOffset){_VesproCtx.implicitDepth-=depthOffset;if(Vespro_depthTest(_VesproCtx.implicitDepth)){vec3 n=_Vespro_evaluateImplicitDerivatives(p,depthOffset);if(dot(n,n)<=0.)n=-_VesproCtx.sampleRd;_VesproCtx.surfaceSample=Vespro_Surface(vec3(1),vec3(0),normalize(n));vec3 ro_tmp=_VesproCtx.sampleRo;_VesproCtx.sampleRo=p;_VesproCtx.implicitDistance=d;_VesproCtx.surfaceSamplerType=Vespro_IMPLICIT_SURFACES.id;Vespro_surfaceSampler(p,_VesproCtx.sampleRd);_VesproCtx.sampleRo=ro_tmp;}_VesproCtx.implicitDepth=0.;return true;}_VesproCtx.implicitDepth+=d;return false;}bool Vespro_integrateAsync(inout vec4 result,vec3 ro,vec3 rd,uint nIterations){_VesproCtx.origin=ro;uint startIntegrationSamples=_VesproCtx.integratedSamples;for(uint i=0u;i<nIterations&&_VesproCtx.no_unroll;++i){if(!_VesproCtx.primaryPhoton.initialized)_VesproCtx.primaryPhoton=Vespro_Photon(ro,rd,1.,true);bool importanceSampledLightPath;Vespro_Photon photon=_Vespro_getActivePhoton(importanceSampledLightPath);vec3 wavelength=vec3(equal(_VesproCtx.integratedSamples%uvec3(3,3,3),uvec3(0,1,2)));const float wavelengthPDF=1./3.;_VesproCtx.depth=-1.;_VesproCtx.batchSampleState=false;_VesproCtx.surfaceSamplerType=Vespro_PARAMETRIC_SURFACES.id;_VesproCtx.surfaceSample=Vespro_Surface(vec3(1),vec3(0),vec3(0));_VesproCtx.sampleRo=photon.position,_VesproCtx.sampleRd=photon.direction;Vespro_surfaceSampler(_VesproCtx.sampleRo,_VesproCtx.sampleRd);if(!_Vespro_intersectImplicitSurfacesAsync())continue;float depthOffset=_Vespro_evaluateDepthOffset(photon.position+photon.direction*max(_VesproCtx.depth,0.));if(_VesproCtx.depth>=0.)_VesproCtx.depth=max(_VesproCtx.depth-2.*depthOffset,0.);_VesproCtx.depth+=float(_VesproCtx.depth>0.)*depthOffset;if(_Vespro_intersectLights(photon.position,photon.direction))_VesproCtx.surfaceSample.emissive*=float(importanceSampledLightPath||!_VesproCtx.primaryScattered);if(_VesproCtx.depth>=0.){vec3 surfacePosition=photon.position+photon.direction*_VesproCtx.depth;if(distance(surfacePosition,_VesproCtx.origin)>=Vespro_ZFAR)_VesproCtx.depth=-1.;}bool lightPathResolved=_Vespro_integrateScatter(photon,wavelength,importanceSampledLightPath)&&_Vespro_integrateDiffuse(photon,wavelength,importanceSampledLightPath);if(lightPathResolved){bool photonTransmitted=_VesproCtx.depth<0.;if(_VesproCtx.profile!=Vespro_TRANSMITTANCE.id&&photonTransmitted&&!importanceSampledLightPath){_VesproCtx.radianceSample=vec3(0);Vespro_radianceSampler(photon.direction);_VesproCtx.radiativeTransfer+=_VesproCtx.radianceSample*photon.throughput*wavelength/wavelengthPDF;}if(!importanceSampledLightPath){if(_VesproCtx.profile==Vespro_TRANSMITTANCE.id&&photonTransmitted&&!_VesproCtx.primaryScattered)_VesproCtx.radiativeTransfer+=photon.throughput*wavelength/wavelengthPDF;++_VesproCtx.integratedSamples;_VesproCtx.primaryScattered=false;}_VesproCtx.implicitDepth=0.;photon.initialized=false;}_Vespro_updateActivePhoton(importanceSampledLightPath,photon);}result.xyz=_VesproCtx.radiativeTransfer/float(max(_VesproCtx.integratedSamples,1u));return _VesproCtx.integratedSamples!=startIntegrationSamples;}bool Vespro_integrate(inout vec4 result,vec3 ro,vec3 rd,uint nSamples){_VesproCtx.primaryPhoton.initialized=false;_VesproCtx.misPhoton.initialized=false;_VesproCtx.primaryScattered=false;_VesproCtx.integratedSamples=floatBitsToUint(result.w);_VesproCtx.radiativeTransfer=result.xyz*float(_VesproCtx.integratedSamples);uint targetSampleCount=_VesproCtx.integratedSamples+nSamples,nIterations=0u,maxIterations=Vespro_MAX_STEPS*nSamples;for(;_VesproCtx.integratedSamples<targetSampleCount&&++nIterations<=Vespro_MAX_STEPS;Vespro_integrateAsync(result,ro,rd,1u));result.w=uintBitsToFloat(_VesproCtx.integratedSamples+uint(!_VesproCtx.no_unroll));return nIterations<=maxIterations;}vec2 _Vespro_packNormal(vec3 n){n=normalize(n);n.xy/=dot(abs(n),vec3(1));n.xy=.5+.5*mix(n.xy,(1.-abs(n.yx))*vec2(n.x>=0.?1.:-1.,n.y>=0.?1.:-1.),step(n.z,0.));return n.xy;}vec3 _Vespro_unpackNormal(vec2 packedNormal){vec3 n=vec3(packedNormal,0);n.xy=-1.+2.*n.xy;n.z=1.-abs(n.x)-abs(n.y);if(n.z<0.)n.xy=(1.-abs(n.yx))*vec2(n.x>=0.?1.:-1.,n.y>=0.?1.:-1.);return normalize(n);}vec3 _Vespro_pack_bvec3_uvec3(bool flag0,bool flag1,bool flag2,vec3 unsignedVec3){return(1.+max(unsignedVec3,0.))*(-1.+2.*vec3(flag0,flag1,flag2));}void Vespro_storeAsyncState(out mat4 packedData){uint throuputsPacked=packHalf2x16(vec2(_VesproCtx.primaryPhoton.throughput,_VesproCtx.misPhoton.throughput));packedData[0].xyz=_VesproCtx.primaryPhoton.position;packedData[0].w=uintBitsToFloat(throuputsPacked+uint(!_VesproCtx.no_unroll));packedData[1].xyz=_VesproCtx.misPhoton.position;packedData[1].w=_VesproCtx.implicitDepth;packedData[2].xy=_Vespro_packNormal(_VesproCtx.primaryPhoton.direction);packedData[2].zw=_Vespro_packNormal(_VesproCtx.misPhoton.direction);packedData[3].xyz=_Vespro_pack_bvec3_uvec3(_VesproCtx.primaryPhoton.initialized,_VesproCtx.misPhoton.initialized,_VesproCtx.primaryScattered,_VesproCtx.radiativeTransfer);packedData[3].w=uintBitsToFloat(_VesproCtx.integratedSamples+uint(!_VesproCtx.no_unroll));}void _Vespro_unpack_bvec3_uvec3(vec3 packedVec3,out bool flag0,out bool flag1,out bool flag2,out vec3 unsignedVec3){flag0=packedVec3.x>0.;flag1=packedVec3.y>0.;flag2=packedVec3.z>0.;unsignedVec3=max(abs(packedVec3)-1.,0.);}void Vespro_loadAsyncState(mat4 packedData){_VesproCtx.primaryPhoton.position=packedData[0].xyz;vec2 throuputsPacked=unpackHalf2x16(floatBitsToUint(packedData[0].w));_VesproCtx.primaryPhoton.throughput=throuputsPacked.x;_VesproCtx.misPhoton.throughput=throuputsPacked.y;_VesproCtx.misPhoton.position=packedData[1].xyz;_VesproCtx.implicitDepth=packedData[1].w;_VesproCtx.primaryPhoton.direction=_Vespro_unpackNormal(packedData[2].xy);_VesproCtx.misPhoton.direction=_Vespro_unpackNormal(packedData[2].zw);_Vespro_unpack_bvec3_uvec3(packedData[3].xyz,_VesproCtx.primaryPhoton.initialized,_VesproCtx.misPhoton.initialized,_VesproCtx.primaryScattered,_VesproCtx.radiativeTransfer);_VesproCtx.integratedSamples=floatBitsToUint(packedData[3].w);}float _Vespro_packTexture(vec4 textureUnorm8){uvec4 a=uvec4(round(clamp(textureUnorm8,0.,1.)*255.));uint textureDataPacked32=uint(a.x<<24|a.y<<16|a.z<<8|a.w<<0);return uintBitsToFloat(textureDataPacked32+uint(!_VesproCtx.no_unroll));}vec4 _Vespro_unpackTexture(float packedTexture32){uint a=floatBitsToUint(packedTexture32);return vec4((a&4278190080u)>>24,(a&16711680u)>>16,(a&65280u)>>8,(a&255u)>>0)/255.;}vec3 _Vespro_octMapToWorld(ivec2 resolutionPx,vec2 uv){uv=clamp(mix(-.5/vec2(resolutionPx),1.+.5/vec2(resolutionPx),uv),0.,1.);uv=-1.+2.*uv;vec3 nor=vec3(uv,1.-abs(uv.x)-abs(uv.y));float t=max(-nor.z,0.);nor.x+=nor.x>0.?-t:t;nor.y+=nor.y>0.?-t:t;return normalize(nor);}vec2 _Vespro_worldToOctMap(ivec2 resolutionPx,vec3 rd){rd=max(abs(rd),1e-6)*(-1.+2.*step(vec3(0),rd));vec2 p=rd.xy/(abs(rd.x)+abs(rd.y)+abs(rd.z)),uv=.5+.5*(rd.z<0.?(vec2(1)-abs(p.yx))*sign(p):p);uv=mix(.5/vec2(resolutionPx),1.-.5/vec2(resolutionPx),uv);return uv;}vec4 Vespro_texture(uint textureID,vec2 uv){if(textureID>=Vespro_MAX_TEXTURES)return vec4(0);const uint nChannels=4u;uint channelID=textureID%nChannels;textureID/=nChannels;uint nTextureTiles=max(Vespro_MAX_TEXTURES/4u,1u);vec2 tiles=vec2(ceil(sqrt(float(nTextureTiles))),0);tiles.y=ceil(float(nTextureTiles)/tiles.x);vec2 texSize=vec2(textureSize(Vespro_textures,0)),res=floor(texSize/tiles),st=uv.xy*res-.5,iuv=floor(st),fuv=fract(st),tile_uv=vec2(textureID%uint(tiles.x),textureID/uint(tiles.x));vec4 a=texelFetch(Vespro_textures,ivec2((fract((iuv.xy+vec2(.5))/res)+tile_uv)/tiles*texSize),0),b=texelFetch(Vespro_textures,ivec2((fract((iuv.xy+vec2(1.5,.5))/res)+tile_uv)/tiles*texSize),0),c=texelFetch(Vespro_textures,ivec2((fract((iuv.xy+vec2(.5,1.5))/res)+tile_uv)/tiles*texSize),0),d=texelFetch(Vespro_textures,ivec2((fract((iuv.xy+vec2(1.5))/res)+tile_uv)/tiles*texSize),0);a=_Vespro_unpackTexture(a[channelID]);b=_Vespro_unpackTexture(b[channelID]);c=_Vespro_unpackTexture(c[channelID]);d=_Vespro_unpackTexture(d[channelID]);return mix(mix(a,b,fuv.x),mix(c,d,fuv.x),fuv.y);}vec4 Vespro_texture(uint textureID,vec3 direction){uint nTextureTiles=max(Vespro_MAX_TEXTURES/4u,1u);vec2 tiles=vec2(ceil(sqrt(float(nTextureTiles))),0);tiles.y=ceil(float(nTextureTiles)/tiles.x);vec2 texSize=vec2(textureSize(Vespro_textures,0));ivec2 octmapRes=ivec2(texSize/tiles);vec2 uv=_Vespro_worldToOctMap(octmapRes,direction);return Vespro_texture(textureID,uv);}vec4 Vespro_texture(uvec3 textureIDs,vec3 p,vec3 n){n=normalize(abs(n));float weightSum=n.x+n.y+n.z;n/=weightSum;vec4 sampleX=Vespro_texture(textureIDs.x,p.yz),sampleY=Vespro_texture(textureIDs.y,p.xz),sampleZ=Vespro_texture(textureIDs.z,p.xy);return sampleX*n.x+sampleY*n.y+sampleZ*n.z;}vec4 Vespro_texture(uint textureIDs,vec3 p,vec3 n){return Vespro_texture(uvec3(textureIDs),p,n);}\n\n// Remap Vespro_textures sampler to iChannel0, except for the common tab (or compiler will complain due to iChannel0 not being defined)\n#ifndef HW_PERFORMANCE // Trick to detect if we're compiling ShaderToy's common tab, from https://www.shadertoy.com/view/WldSRj\nuniform sampler2D Vespro_textures;\n#else\n#define Vespro_textures iChannel0\n#endif\n\n// ------------------------------------------------------------------ //\n//                       Sample Usage (demo scene)                    // ------------------------------------------------------------------------------------------------------- //\n// ------------------------------------------------------------------ //\n\nconst int  targetFPS = 60;   // IMPORTANT: must be <= monitor's refresh rate since ShaderToy is v-synched\nconst uint maxSteps = 4096u; // maximum allowed number of steps per tile\n\nconst ivec2 tileSize = ivec2(256);         // rendered tiles size in px (capped at 1/2 viewport res)\nconst ivec2 previewSize = ivec2(640, 480); // rendered preview size in px (capped at viewport res)\nconst float blackBandsSize = 0.2;          // cinematic black bands size (relative to viewport height)\n\n// Metric Units\nconst float mtToUnit       = 1e-3; // 1 graphical unit = 1km\nconst float planetaryScale = 1e-2; // solar system scaling factor\n\n#define Mt(x)    ((x) * mtToUnit)       // meters to graphical units \n#define Km(x)    ((x) * mtToUnit * 1e3) // kilometers to graphical units\n#define perMt(x) ((x) / Mt(1.0))        // inverse meters to graphical units \n#define perKm(x) ((x) / Km(1.0))        // inverse kilometers to graphical units\n\n// Solar System\nconst float sunRadius        = Km(696340.0)       * planetaryScale;\nconst float sunDistance      = Km(150e6)          * planetaryScale;\nconst float planetRadius     = Km(6360.0)         * planetaryScale;\nconst float atmosphereRadius = Km(6360.0 + 100.0) * planetaryScale;\nconst float moonDistance     = Km(384400.0)       * planetaryScale;\nconst float moonRadius       = Km(1737.4) * 30.0  * planetaryScale;\n\nconst vec3 planetPosition   = vec2(0, -planetRadius).xyx; // planet surface tangent to origin\nvec3 sunDir = normalize(vec3(0.4, 0.4, 0.5));             // initial sun direction (press L to change)\n\n// Camera\nconst vec3  cameraPosition = Mt(vec3(0, 1.75, 6.24138) ); // starting camera position\nconst vec2  cameraPitchYaw = vec2(0.085, 0.0);            // starting camera pitch / yaw\nconst float cameraLinearSpeed = Mt(2.0);                  // camera speed\nconst float cameraAngularSpeed = 1.0;                     // orientation speed\nconst float cameraFOV   = 30.0;                           // camera field of view (in degrees)\nconst float cameraZFAR  = 1e30;                           // maximum tracing distance\nconst float exposureMul = 1.0;                            // auto-exposure multiplier\nconst float exposureMin = 1e-2;                           // auto-exposure min luminance\nconst float exposureMax = 1e+2;                           // auto-exposure max luminance\n\n// camera motion and collisions\nvoid cameraUpdatePosition(inout vec3 position, in vec3 velocity, in float dt)\n{\n    // increase speed proportionally to altitude\n    float altitude = (length(position - planetPosition) - planetRadius);\n    float camSpeed = cameraLinearSpeed * max(altitude / mtToUnit * 2e-1, 1.0);\n\n    const float c = Mt(299792458.0) * planetaryScale;\n    camSpeed = min(camSpeed, c * 1e-2); // max velocity: 1/10th the speed of light (when shift pressed)\n\n    position += velocity * camSpeed * dt;\n\n    // collision with planet terrain\n    const float minAltitudeMt = Mt(1.75);\n    altitude = length(position - planetPosition) - planetRadius;\n    if(altitude < minAltitudeMt) position = planetPosition + normalize(position - planetPosition) * (planetRadius + minAltitudeMt);\n}\n\n// Integrator profile (Vespro_SINGLE_SCATTERING, Vespro_MULTIPLE_SCATTERING or Vespro_TRANSMITTANCE)\n#define INTEGRATOR_PROFILE Vespro_MULTIPLE_SCATTERING\n\n// Volumetric nodes\n#define PLANET_ATMOSPHERE  0u\n#define VOLUMETRIC_TORUS   1u\n#define VOLUMETRIC_SPHERE  2u\n#define N_VOLUMETRICS      3u\n\n// Participating media channels\n#define MEDIA_CHANNEL0    0u\n#define MEDIA_CHANNEL1    1u\n#define MEDIA_CHANNEL2    2u\n#define N_MEDIA_CHANNELS  3u\n\n#define MEDIA_RAYLEIGH  MEDIA_CHANNEL0\n#define MEDIA_OZONE     MEDIA_CHANNEL1\n#define MEDIA_MIE       MEDIA_CHANNEL2\n\n// Analytical lights (importance-sampled)\n#define LIGHT_SUN  0u\n#define LIGHT_BOX  1u\n#define N_LIGHTS   2u\n\n// Textures\n#define TEXTURE_WALL    0u\n#define TEXTURE_PLANET  1u\n#define TEXTURE_STONE   2u\n#define TEXTURE_ENV     3u\n#define N_TEXTURES      4u\n\n// Import Vespro with settings\nIMPORT_VESPRO( N_VOLUMETRICS, N_MEDIA_CHANNELS, N_LIGHTS, N_TEXTURES, maxSteps, cameraZFAR )\n\n// This callback is responsible of sampling the ingoing radiance along a given ray,\n// and it's automatically invoked by the integrator. This function can be used to sample environment maps,\n// or extra directional lights that are not importance-sampled. The radiance must be set by calling Vespro_setRadiance(radiance);\nvoid Vespro_radianceSampler(in vec3 rd) // the input direction to sample ingoing radiance from\n{\n    // set radiance sample:\n    vec3 spaceColor = Vespro_texture(TEXTURE_ENV, rd.zyx).rgb * 0.0;\n    Vespro_setRadiance(spaceColor); // const background color or sample env map\n}\n\n// This callback is responsible of sampling the scene solid surfaces, and it's automatically\n// invoked by the integrator. The built-in Vespro_sampleXXX() can be used to sample pre-defined primitives.\n// For custom implicit and parametric surfaces, refer to Vespro_sampleSDF() and Vespro_depthTest() functions.\n// After a succesful sample, the surface properties can be overriden via:\n// Vespro_setSurfaceAlbedo(), Vespro_setSurfaceEmissive() and Vespro_setSurfaceNormal().\n// The sampled surface position and normal can be queried via Vespro_getSurfacePosition(), Vespro_getSurfaceNormal().\nvoid Vespro_surfaceSampler( in vec3 ro,   // the ray origin    (used to evaluate custom SDFs or intersectors)\n                            in vec3 rd )  // the ray direction (used to evaluate custom intersectors)\n{\n    // Planet surface (flat sphere, blend between far/close texture)\n    if(Vespro_sampleSphere(planetPosition, planetRadius))\n    {\n        vec3 p = Vespro_getSurfacePosition();\n        vec3 n = Vespro_getSurfaceNormal();\n\n        // wave pattern to break repetition\n        vec3 pm = 1e-3 * p / mtToUnit;\n        vec3 p_sand = (pm + vec3(0.005 * vec2(sin(pm.z * 30.0 * 1e6), cos(pm.x * 100.0 + 5.0 * sin(pm.z * 20.0))), 0).xzy) * 50.0;\n        vec3 p_wall = (pm + vec3(0.005 * vec2(sin(pm.z * 30.0), cos(pm.x * 100.0)), 0).xzy) * 50.0 * 1e3;\n\n        vec3 planetAlbedoNear = Vespro_texture(TEXTURE_PLANET, p_sand, n).rgb;\n        vec3 planetAlbedoFar  = Vespro_texture(TEXTURE_PLANET, p / planetRadius, n).rgb;\n\n        vec3 floorAlbedo = Vespro_texture(TEXTURE_WALL, p_wall * 0.25e-2, n).rgb;\n        planetAlbedoNear = mix(planetAlbedoNear, floorAlbedo, smoothstep(300.0, 200.0, abs(p_wall.x)));\n\n        float observerAltitude = max((Vespro_distance(planetPosition) - planetRadius) / (mtToUnit * 1e3 * planetaryScale), 0.0);\n        vec3 planetAlbedo = mix(planetAlbedoNear, planetAlbedoFar, smoothstep(0.0, 40.0, observerAltitude));\n\n        Vespro_setSurfaceAlbedo(planetAlbedo);\n    }\n\n    // Moon surface (flat sphere)\n    if(Vespro_sampleSphere(planetPosition + normalize(vec3(0.325, 0.2, -1)) * moonDistance, moonRadius))\n    {\n        vec3 p = Vespro_getSurfacePosition() * 0.01;\n        vec3 n = Vespro_getSurfaceNormal();\n\n        vec3 moonAlbedo = Vespro_texture(TEXTURE_STONE, 1e2 * p / moonRadius, n).rgb;\n\n        Vespro_setSurfaceAlbedo(moonAlbedo);\n    }\n\n    // Orbital megastructure\n    vec4 ringOrientation = Vespro_quaternion(65.90, vec3(0, 0, 1));\n    if(Vespro_sampleTorus(planetPosition, planetRadius * 1.25, planetRadius * 0.025, ringOrientation))\n    {\n        vec3 p = Vespro_getSurfacePosition();\n        vec3 n = Vespro_getSurfaceNormal();\n\n        // Torus uv\n        vec3 p_local = Vespro_quaternionMul(p - planetPosition, ringOrientation);\n        vec3 n_local = Vespro_quaternionMul(n, ringOrientation);\n        vec2 uv = vec2(dot(normalize(p_local), vec3(0, 0, 1)), dot(normalize(n_local), normalize(p_local)));\n        uv = acos(clamp(uv, -1.0, 1.0));\n\n        // Emissive windows\n        float e = step(fract(uv.x * 80.0), 0.5) * step(fract(uv.y * 2.0), 0.25);\n        e *= 0.5 + 0.5 * sin(uv.x * 60.0) * cos(uv.y * 10.0); // uneven dimming\n\n        Vespro_setSurfaceAlbedo(vec3(0.1));\n        Vespro_setSurfaceEmissive(vec3(0.5) * e);\n    }\n\n    // Cornell Box\n    if(Vespro_sampleCornellBox(Mt(vec3(0, 1.74, -6.241)), Mt(1.74)))\n    {\n        // Adjust Cornell box emissive ceiling intensity\n        vec3 emissive = vec3(1, 0.75, 0.5) * Vespro_getSurfaceEmissive() * 2e-2;\n        if(sunDir.y >= 0.0) emissive *= 0.0; // turn off in day-time\n\n        Vespro_setSurfaceEmissive(emissive);\n    }\n\n    // Primitives showcase\n    if(Vespro_sampleAABB(Mt(vec3(0, 0.7482, -11.46138)), Mt(vec3(10.44, 0.696, 0.696))))\n    {\n        vec4 torusOrientation = Vespro_quaternion(90.0, vec3(1, 0, 0));\n\n        // sample in batching (treat all primitives as a single material)\n        Vespro_beginBatchSampling();\n\n        Vespro_sampleSphere(Mt(vec3(-9.135, 0.7482, -11.461)), Mt(0.696));\n        Vespro_sampleBox(Mt(vec3(-6.525, 0.7482, -11.461)), Mt(vec3(0.696)));\n        Vespro_sampleBoxFrame(Mt(vec3(-3.915, 0.7482, -11.461)), Mt(vec3(0.696)), Mt(0.087));\n        Vespro_sampleCapsule(Mt(vec3(3.915, 0.4, -11.461)), Mt(vec3(3.915, 1.044, -11.46138)), Mt(0.348));\n        Vespro_sampleCylinder(Mt(vec3(6.525, 0.052, -11.461)), Mt(vec3(6.525, 1.392, -11.46138)), Mt(0.696));\n        Vespro_sampleTorus(Mt(vec3(9.135, 0.748, -11.461)), Mt(0.522), Mt(0.174), torusOrientation);\n\n        // validate batched sample (closest intersecting surface of the group, if any)\n        if(Vespro_validateBatchSampling())\n        {\n            vec3 p = Vespro_getSurfacePosition();\n            vec3 n = Vespro_getSurfaceNormal();\n\n            vec3 primitivesAlbedo = Vespro_texture(TEXTURE_STONE, p / mtToUnit * 0.574, n).rgb;\n\n            Vespro_setSurfaceAlbedo(primitivesAlbedo);\n        }\n    }\n\n/*\n    // How to sample a custom SDF surface:\n    \n    // Consider delimiting SDFs with AABBs whenever possible (improves convergence)\n    if(Vespro_sampleAABB(aabbCenter, aabbSize) && Vespro_sampleSDF( map(ro) ))\n    {\n        vec3 p = Vespro_getSurfacePosition(); // the sampled surface position\n        vec3 n = Vespro_getSurfaceNormal();   // the sampled surface normal (auto-generated for implicit surfaces)\n\n        Vespro_setSurfaceAlbedo(0.5 + 0.5 * n);\n    }\n*/\n/*\n    // How to sample a custom parametric surface:\n    \n    // Consider delimiting primitives with AABBs whenever possible (improves convergence)\n    if(Vespro_sampleAABB(aabbCenter, aabbSize) && Vespro_depthTest( mySurfaceIntersector(ro, rd) ))\n    {\n        vec3 p = Vespro_getSurfacePosition(); // the sampled surface position\n        vec3 n = mySurfaceNormal(p); // the sampled surface normal (must be manually evaluated for parametric surfaces)\n\n        Vespro_setSurfaceNormal(n);\n        Vespro_setSurfaceAlbedo(0.5 + 0.5 * n);\n    }\n */\n}\n\n// This callback is responsible for sampling the participating media densities on the created nodes,\n// and it's automatically invoked by the integrator. Each participating medium density must be set by calling:\n// Vespro_setDensity(mediumID, density); All media of the given node will assume zero density unless explicitly set.\nvoid Vespro_densitySampler( in uint nodeID, // the input node (unique identifier) to sample\n                            in vec3 pLocal, // the input position to sample, relative to the node (normalized space)\n                            in vec3 pWorld) // the input position to sample, in absolute space (world space)\n{\n    // planet atmosphere\n    if(nodeID == PLANET_ATMOSPHERE)\n    {\n        float altitude = max((length(pWorld - planetPosition) - planetRadius) / (mtToUnit * 1e3), 0.0);\n        altitude /= planetaryScale;\n\n        float rayleighScaleHeight = -1.0 / 8.0;\n        float rayleighDensity = exp(altitude * rayleighScaleHeight); // Rayleigh density on a given sample position\n\n    #if (0) // boosted Mie (artistic)\n        float mieScaleHeight = -1.0 / 3.2;\n    #else // SebH\n        float mieScaleHeight = -1.0 / 1.2;\n    #endif\n        float mieDensity = exp(altitude * mieScaleHeight); // Mie density on a given sample position\n\n        float ozoneDensity0LayerWidth = 25.0;\n        float ozoneDensity0ConstantTerm = -2.0 / 3.0;\n        float ozoneDensity0LinearTerm = 1.0 / 15.0;\n        float ozoneDensity1ConstantTerm = 8.0 / 3.0;\n        float ozoneDensity1LinearTerm = -1.0 / 15.0;\n\n        float ozoneDensity = altitude < ozoneDensity0LayerWidth // Ozone density on a given sample position\n                           ? clamp(ozoneDensity0LinearTerm*altitude + ozoneDensity0ConstantTerm, 0.0, 1.0)\n                           : clamp(ozoneDensity1LinearTerm*altitude + ozoneDensity1ConstantTerm, 0.0, 1.0);\n\n        Vespro_setDensity(MEDIA_RAYLEIGH, rayleighDensity);\n        Vespro_setDensity(MEDIA_OZONE, ozoneDensity);\n        Vespro_setDensity(MEDIA_MIE, mieDensity);\n    }\n\n    // volumetric torus in Cornell box\n    if(nodeID == VOLUMETRIC_TORUS)\n    {\n         float torusSDF = (length(vec2(length(pLocal.xy) - 0.8, pLocal.z * 0.3)) - 0.2); // torus signed distance field\n         Vespro_setDensity(MEDIA_CHANNEL0, smoothstep(0.0, -1e-1, torusSDF)); // apply density to torus substance\n    }\n\n    // volumetric sphere in Cornell box\n    if(nodeID == VOLUMETRIC_SPHERE)\n    {\n        float sphereSDF = length(pLocal) - 1.0; // sphere signed distance field\n        Vespro_setDensity(MEDIA_CHANNEL0, smoothstep(0.0, -1e-1, sphereSDF)); // apply density to torus substance\n    }\n}\n\n// Run Demo Scene (context auto-initialized from caller)\nvoid Vespro_main(out vec4 fragColor, in vec2 fragCoord, in vec2 viewportSize, in vec3 eyePos, in vec3 eyeDir, in uint nSteps)\n{\n    // analtical lights (importance-sampled)\n    Vespro_createLight( LIGHT_SUN, vec3(2e5), planetPosition + sunDir * sunDistance, sunRadius );\n\n    // Cornell box ceiling lamp (note: Cornell box also has emissive ceiling, this light is only added to speed up convergence)\n    if(sunDir.y < 0.0) Vespro_createLight(LIGHT_BOX, vec3(1, 0.75, 0.5) * 1e2, Mt(vec3(0, 3.376, -6.241)), Mt(0.07));\n\n    // planet volumetric atmosphere ( 3 media: rayleigh, mie and ozone )\n    Vespro_createNode( PLANET_ATMOSPHERE,  // volumetric node\n                       planetPosition,     // node position\n                       atmosphereRadius ); // node size (spherical)\n\n    Vespro_createMedium( PLANET_ATMOSPHERE,                                          // volumetric node\n                         MEDIA_RAYLEIGH,                                             // media channel (of the node)\n                         perKm(vec3(0.005802, 0.013558, 0.033100) / planetaryScale), // scattering coefficients (probability per Km)\n                         perKm(vec3(0, 0, 0) / planetaryScale),                      // absorption coefficients (probability per Km)\n                         0.0 );                                                      // phase asymmetry\n\n    Vespro_createMedium( PLANET_ATMOSPHERE,                                          // volumetric node\n                         MEDIA_MIE,                                                  // media channel (of the node)\n                         perKm(vec3(0.003996, 0.003996, 0.003996) / planetaryScale), // scattering coefficients (probability per Km)\n                         perKm(vec3(0.000444, 0.000444, 0.000444) / planetaryScale), // absorption coefficients (probability per Km)\n                         0.8 );                                                      // phase asymmetry\n\n    Vespro_createMedium( PLANET_ATMOSPHERE,                                          // volumetric node\n                         MEDIA_OZONE,                                                // media channel (of the node)\n                         perKm(vec3(0, 0, 0) / planetaryScale ),                     // scattering coefficients (probability per Km)\n                         perKm(vec3(0.000650, 0.001881, 0.000085) / planetaryScale), // absorption coefficients (probability per Km)\n                         0.0 );                                                      // phase asymmetry\n\n    // volumetric torus in Cornell box\n    Vespro_createNode( VOLUMETRIC_TORUS,               // volumetric node\n                       Mt(vec3(0.5, 1.54, -5.641)),    // node position\n                       Mt(vec3(0.565, 0.565, 0.17)) ); // node size (cuboid)\n\n    Vespro_createMedium( VOLUMETRIC_TORUS,                      // volumetric node\n                         MEDIA_CHANNEL0,                        // media channel (of the node)\n                         perMt(vec3(26.437, 62.069, 151.724)),  // scattering coefficients (probability per Mt)\n                         perMt(vec3(0, 0, 0)),                  // absorption coefficients (probability per Mt)\n                         0.0 );                                 // phase asymmetry\n\n    // volumetric sphere in Cornell box\n    Vespro_createNode( VOLUMETRIC_SPHERE,            // volumetric node\n                       Mt(vec3(-0.6, 2.44, -7.141)), // node position\n                       Mt(0.566) );                  // node size (spherical)\n\n    Vespro_createMedium( VOLUMETRIC_SPHERE,            // volumetric node\n                         MEDIA_CHANNEL0,               // media channel (of the node)\n                         perMt(vec3(9.195)),           // scattering coefficients (probability per Mt)\n                         perMt(vec3(9.195, 4.598, 0)), // absorption coefficients (probability per Mt)\n                         0.0 );                        // phase asymmetry\n\n    // view ray\n    vec3 ro, rd;\n    Vespro_getLookAtRay(eyePos, eyePos + eyeDir, cameraFOV, ro, rd, true);\n\n    // depth offset to ensure photons don't get stuck on surfaces\n    Vespro_setDepthOffset(Mt(planetaryScale)); // modulate proportionally to planetary scale\n\n    // integrate pixel color\n    Vespro_integrateAsync(fragColor, ro, rd, nSteps);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ------------------------------------------------------------------ //\n//                          Texture Packer                           //\n// ------------------------------------------------------------------ //\n\n// This pass is responsible of packing the scene textures in a single 32 bit buffer.\n\n// You can have as many textures as you want (N_TEXTURES is Common tab, aka Vespro_MAX_TEXTURES), \n// as long as they are RGBA8 UNORM. The more textures are defined, the lower their resolution will be.\n// Resolution is screen dependent, halved by 2 for every 4 textures.\n\n// Packed textures support tiling, but their filtering is limited to bilinear (no mips)\n// Color space is assumed to be sRGB, packed textures are converted to RGB linear (alpha is left un-tounched)\n\n// Return your custom textures here:\nvec4 texturePacker( in uint textureID, // the texture ID, ranges from [0, Vespro_MAX_TEXTURES - 1]\n                    in vec2 uv,        // the texture coordinates to sample\n                    in vec3 rd )       // the direction to sample (for cubemaps)\n{\n    // ShaderToy iChannels 0,1,2,3 (change these as you prefer)\n    if(textureID == 0u) return texture(iChannel0, uv); // sampler2D\n    if(textureID == 1u) return texture(iChannel1, uv); // sampler2D\n    if(textureID == 2u) return texture(iChannel2, uv); // sampler2D\n    if(textureID == 3u) return texture(iChannel3, rd); // samplerCube \n    \n    // Custom Textures (additional procedurally generated textures)\n    \n    // if(textureID == 4u) return vec4(0);\n    // if(textureID == 5u) return vec4(0);\n    // if(textureID == 6u) return vec4(0);\n    // ...\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{ \n    uint nTextureTiles = max(Vespro_MAX_TEXTURES / 4u, 1u);\n    \n    vec2 tiles = vec2(ceil(sqrt(float(nTextureTiles))), 0);\n    tiles.y = ceil(float(nTextureTiles) / tiles.x);\n    \n    vec2  texSize = vec2(textureSize(Vespro_textures, 0).xy);\n    ivec2 octMapRes = ivec2(texSize / tiles);\n    \n    vec2 uv = (fragCoord / iResolution.xy) * tiles;\n    \n    uint textureID = uint(floor(uv.x) + floor(uv.y) * tiles.x);\n    uv = fract(uv);\n   \n    vec3 rd = _Vespro_octMapToWorld(octMapRes, uv); // sampling direction for cube maps\n    \n    const vec4 gamma = vec4(vec3(2.24), 1); // pack in linear space (don't gamma-correct alpha channel)\n  \n    Vespro_initContext(INTEGRATOR_PROFILE, fragCoord, iResolution.xy, iFrame); // context needs to be initialized before calling Vespro_packTexture()\n  \n    fragColor.r = _Vespro_packTexture(pow(max(texturePacker(textureID * 4u + 0u, uv, rd), 0.0), gamma));\n    fragColor.g = _Vespro_packTexture(pow(max(texturePacker(textureID * 4u + 1u, uv, rd), 0.0), gamma));\n    fragColor.b = _Vespro_packTexture(pow(max(texturePacker(textureID * 4u + 2u, uv, rd), 0.0), gamma));\n    fragColor.a = _Vespro_packTexture(pow(max(texturePacker(textureID * 4u + 3u, uv, rd), 0.0), gamma));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ------------------------------------------------------------------ //\n//                              Reserved                              //\n// ------------------------------------------------------------------ //\n\n// This buffer is responsible of asynchronously integrating light on the current tile.\n// The tile state is then validated in buffer C with a fence, when all the pixels in the tile\n// performed \"at least\" one succesful light sample, the integration result is copied to buffer D,\n// which holds the whole image, and the next tile is scheduled for rendering.\n\n// Since ShaderToy doesn't support MRTs, we emulate them by rendering the same tile 4 times,\n// storing a different quantity per tile. It's very important that all four tiles follow\n// the same execution path in order not to have divergence in the stored data.\n\n// The shared uniforms, duplicated in buffers B,C,D, Image\n// as we want to reserve the Common tab for the scene code only\nstruct Uniforms\n{\n    int  spp;\n    int  tileID;\n    int  lastFrameTileID;\n    int  fenceStepID;\n    bool tileResolved;\n    bool previewMode;\n\n    vec2 tileRes;\n    vec2 canvasRes;\n    vec2 previewRes;\n\n    vec2 lastScreenRes;\n    bool validFrame;\n    int  frameID;\n\n    vec3 cameraPosition;\n    vec2 cameraPitchYaw;\n    vec4 mouseAnchor;\n\n    bool  exposureLocked;\n    float avgLuminance;\n    float exposure;\n\n    bool displayTiles;\n    vec3 sunDirection;\n};\n\nvoid Uniforms_Load(in sampler2D s, out Uniforms u)\n{\n    vec3 data = texelFetch(s, ivec2(0, 0), 0).xyz;\n    u.tileResolved = bool(data.x);\n    float packedTileIDs = data.y;\n    u.avgLuminance = data.z;\n\n    data = texelFetch(s, ivec2(1, 0), 0).xyz;\n    u.lastScreenRes = data.xy;\n    u.cameraPosition.x = data.z;\n\n    data = texelFetch(s, ivec2(2, 0), 0).xyz;\n    u.cameraPosition.yz = data.xy;\n    u.cameraPitchYaw.x = data.z;\n\n    data = texelFetch(s, ivec2(3, 0), 0).xyz;\n    u.cameraPitchYaw.y = data.x;\n    u.previewRes = data.yz;\n\n    data = texelFetch(s, ivec2(4, 0), 0).xyz;\n    u.validFrame = bool(data.x);\n    u.mouseAnchor.xy = data.yz;\n\n    data = texelFetch(s, ivec2(5, 0), 0).xyz;\n    u.mouseAnchor.zw = data.xy;\n    u.previewMode = bool(data.z);\n\n    data = texelFetch(s, ivec2(6, 0), 0).xyz;\n    u.frameID = int(data.x);\n    u.canvasRes = data.yz;\n\n    data = texelFetch(s, ivec2(7, 0), 0).xyz;\n    u.spp = int(data.x);\n    u.tileRes = data.yz;\n\n    data = texelFetch(s, ivec2(8, 0), 0).xyz;\n    u.exposure = data.x;\n    u.fenceStepID = int(data.y);\n    u.displayTiles = bool(data.z);\n\n    data = texelFetch(s, ivec2(9, 0), 0).xyz;\n    u.exposureLocked = bool(data.x);\n    u.sunDirection = _Vespro_unpackNormal(data.yz);\n    \n    vec2 tileIDs = unpackHalf2x16(floatBitsToUint(packedTileIDs));\n    u.tileID = int(tileIDs.x);\n    u.lastFrameTileID = int(tileIDs.y);\n}\n\nbool screenToTile(in int tileID, in vec2 fragCoord, in ivec2 size, out ivec2 tileTexCoord[4])\n{\n    fragCoord = floor(fragCoord);\n\n    ivec2 tileCoord = ivec2(tileID % int(ceil(iResolution.x / float(size.x))),\n                            tileID / int(ceil(iResolution.x / float(size.x)))) * size;\n\n    if((int(fragCoord.x) < tileCoord.x || int(fragCoord.x) >= tileCoord.x + size.x) ||\n       (int(fragCoord.y) < tileCoord.y || int(fragCoord.y) >= tileCoord.y + size.y)) return false;\n\n    tileTexCoord[0] = ivec2(fragCoord) - tileCoord;\n    tileTexCoord[1] = tileTexCoord[0] + size * ivec2(1, 0);\n    tileTexCoord[2] = tileTexCoord[0] + size * ivec2(0, 1);\n    tileTexCoord[3] = tileTexCoord[0] + size * ivec2(1, 1);\n\n    return true;\n}\n\nbool tileToScreen(in int tileID, in ivec2 tileFragCoord, in ivec2 size, out vec2 fragCoord, out int targetID)\n{\n    if(tileFragCoord.x < 0 || tileFragCoord.x >= 2 * size.x ||\n       tileFragCoord.y < 0 || tileFragCoord.y >= 2 * size.y) return false;\n\n    targetID = tileFragCoord.x / size.x + 2 * (tileFragCoord.y / size.y);\n\n    tileFragCoord = tileFragCoord % size;\n\n    ivec2 tileCoord = ivec2(tileID % int(ceil(iResolution.x / float(size.x))),\n                            tileID / int(ceil(iResolution.x / float(size.x)))) * size;\n\n    int fragID = tileFragCoord.x + tileFragCoord.y * size.x;\n    fragCoord = vec2(tileCoord + ivec2(fragID % size.x, fragID / size.x));\n\n    return((fragCoord.x >= 0.0 && fragCoord.x < iResolution.x) &&\n           (fragCoord.y >= 0.0 && fragCoord.y < iResolution.y));\n}\n\nint getTileSPP(in Uniforms u) \n{\n    int spp = int(texelFetch(iChannel2, ivec2(u.tileID, 1), 0).b);\n    return clamp(((spp > 0) ? spp : u.spp), 1, int(Vespro_MAX_STEPS)); \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Uniforms u;\n    Uniforms_Load(iChannel2, u);\n\n    sunDir = u.sunDirection;\n    vec3 camPos = u.cameraPosition;\n    vec3 camDir = normalize(vec3(cos(u.cameraPitchYaw.x) * sin(u.cameraPitchYaw.y),\n                                 sin(u.cameraPitchYaw.x),\n                                -cos(u.cameraPitchYaw.x) * cos(u.cameraPitchYaw.y)));\n\n    ivec2 tileFragCoord = ivec2(fragCoord);\n    ivec2 size = ivec2(u.previewMode ? u.previewRes : u.tileRes);\n\n    int targetID;\n    if(!tileToScreen(u.tileID, tileFragCoord, size, fragCoord, targetID)) return;\n   \n    vec2 canvasRes = u.canvasRes;\n    canvasRes.y *= (1.0 - blackBandsSize);\n\n    vec2 canvasFragCoord = fragCoord;\n    canvasFragCoord.y -= u.canvasRes.y * blackBandsSize * 0.5;\n\n    Vespro_initContext(INTEGRATOR_PROFILE, canvasFragCoord, canvasRes, iFrame);\n\n    mat4 fragData = mat4(0);\n\n    if(iFrame > 0 && u.validFrame)\n    {\n        if(!u.tileResolved)\n        {\n            ivec2 tileFragCoords[4];\n            screenToTile(u.tileID, fragCoord, size, tileFragCoords);\n\n            fragData = mat4(texelFetch(iChannel1, tileFragCoords[0], 0),\n                            texelFetch(iChannel1, tileFragCoords[1], 0),\n                            texelFetch(iChannel1, tileFragCoords[2], 0),\n                            texelFetch(iChannel1, tileFragCoords[3], 0));\n\n            Vespro_loadAsyncState(fragData);\n        }\n        else\n        {\n            fragColor = texelFetch(iChannel3, ivec2(fragCoord), 0);\n\n            _VesproCtx.radiativeTransfer = fragColor.rgb;\n            _VesproCtx.integratedSamples = floatBitsToUint(fragColor.a);\n\n            if(_VesproCtx.integratedSamples < 1u) _VesproCtx.radiativeTransfer = vec3(0);\n        }\n    }\n\n    uint nSteps = uint(getTileSPP(u));\n    \n    if(u.previewMode)\n    {\n        float tilePixelCount = u.tileRes.x * u.tileRes.y;\n        float previewPixelCount = u.previewRes.x * u.previewRes.y;\n\n        nSteps = uint(max(float(nSteps) / (previewPixelCount / tilePixelCount), 1.0));\n    }\n\n    nSteps = clamp(nSteps, 1u, Vespro_MAX_STEPS);\n\n    if(canvasFragCoord.y >= 0.0 && canvasFragCoord.y < canvasRes.y)\n    {\n        Vespro_main(fragColor, canvasFragCoord, canvasRes, camPos, camDir, nSteps);\n\n    } else ++_VesproCtx.integratedSamples;\n\n    Vespro_storeAsyncState(fragData);\n\n    if(u.frameID < 0) fragData *= 0.0;\n\n    fragColor = fragData[targetID];\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ------------------------------------------------------------------ //\n//                              Reserved                              //\n// ------------------------------------------------------------------ //\n\n// This buffer is responsible of updating the shared uniforms and sheduling the tile renderer.\n\n// Since the tile is evaluated asynchronously over multiple frames, it needs a fence.\n// The fence is resolved if all pixels in the tile performed at least one successful sample,\n// marking the tile as resolved. After the tile is resolved, the result is accumulated in buffer D,\n// and the next tile is scheduled for rendering.\n\n// The fence state and average luminance (for adaptive exposure) are evaluated by performing\n// an 8x8 convolution n times on the tile, until the result is permuted to a single 1x1 pixel,\n// holding the final state of the fence (logical-AND of all its pixels) and the tile average luminance.\n\n// The shared uniforms, duplicated in buffers B,C,D, Image\n// as we want to reserve the Common tab for the scene code only\nstruct Uniforms\n{\n    int  spp;\n    int  tileID;\n    int  lastFrameTileID;\n    int  fenceStepID;\n    bool tileResolved;\n    bool previewMode;\n\n    vec2 tileRes;\n    vec2 canvasRes;\n    vec2 previewRes;\n\n    vec2 lastScreenRes;\n    bool validFrame;\n    int  frameID;\n\n    vec3 cameraPosition;\n    vec2 cameraPitchYaw;\n    vec4 mouseAnchor;\n\n    bool  exposureLocked;\n    float avgLuminance;\n    float exposure;\n\n    bool displayTiles;\n    vec3 sunDirection;\n};\n\nvoid Uniforms_Load(in sampler2D s, out Uniforms u)\n{\n    vec3 data = texelFetch(s, ivec2(0, 0), 0).xyz;\n    u.tileResolved = bool(data.x);\n    float packedTileIDs = data.y;\n    u.avgLuminance = data.z;\n\n    data = texelFetch(s, ivec2(1, 0), 0).xyz;\n    u.lastScreenRes = data.xy;\n    u.cameraPosition.x = data.z;\n\n    data = texelFetch(s, ivec2(2, 0), 0).xyz;\n    u.cameraPosition.yz = data.xy;\n    u.cameraPitchYaw.x = data.z;\n\n    data = texelFetch(s, ivec2(3, 0), 0).xyz;\n    u.cameraPitchYaw.y = data.x;\n    u.previewRes = data.yz;\n\n    data = texelFetch(s, ivec2(4, 0), 0).xyz;\n    u.validFrame = bool(data.x);\n    u.mouseAnchor.xy = data.yz;\n\n    data = texelFetch(s, ivec2(5, 0), 0).xyz;\n    u.mouseAnchor.zw = data.xy;\n    u.previewMode = bool(data.z);\n\n    data = texelFetch(s, ivec2(6, 0), 0).xyz;\n    u.frameID = int(data.x);\n    u.canvasRes = data.yz;\n\n    data = texelFetch(s, ivec2(7, 0), 0).xyz;\n    u.spp = int(data.x);\n    u.tileRes = data.yz;\n\n    data = texelFetch(s, ivec2(8, 0), 0).xyz;\n    u.exposure = data.x;\n    u.fenceStepID = int(data.y);\n    u.displayTiles = bool(data.z);\n\n    data = texelFetch(s, ivec2(9, 0), 0).xyz;\n    u.exposureLocked = bool(data.x);\n    u.sunDirection = _Vespro_unpackNormal(data.yz);\n    \n    vec2 tileIDs = unpackHalf2x16(floatBitsToUint(packedTileIDs));\n    u.tileID = int(tileIDs.x);\n    u.lastFrameTileID = int(tileIDs.y);\n}\n\nvoid Uniforms_Store(in Uniforms u, in ivec2 fragCoord, inout vec4 fragData)\n{\n    if(fragCoord.y == 0)\n    {\n        float tileIDs = uintBitsToFloat(packHalf2x16(vec2(u.tileID, u.lastFrameTileID)) + uint(mod(iTime,1e-6)));\n        \n        if(fragCoord.x == 0) fragData.rgb = vec3(u.tileResolved, tileIDs, u.avgLuminance);\n        if(fragCoord.x == 1) fragData.rgb = vec3(u.lastScreenRes, u.cameraPosition.x);\n        if(fragCoord.x == 2) fragData.rgb = vec3(u.cameraPosition.yz, u.cameraPitchYaw.x);\n        if(fragCoord.x == 3) fragData.rgb = vec3(u.cameraPitchYaw.y, u.previewRes);\n        if(fragCoord.x == 4) fragData.rgb = vec3(u.validFrame, u.mouseAnchor.xy);\n        if(fragCoord.x == 5) fragData.rgb = vec3(u.mouseAnchor.zw, u.previewMode);\n        if(fragCoord.x == 6) fragData.rgb = vec3(u.frameID, u.canvasRes);\n        if(fragCoord.x == 7) fragData.rgb = vec3(u.spp, u.tileRes);\n        if(fragCoord.x == 8) fragData.rgb = vec3(u.exposure, u.fenceStepID, u.displayTiles);\n        if(fragCoord.x == 9) fragData.rgb = vec3(u.exposureLocked, _Vespro_packNormal(u.sunDirection));\n    }\n    \n    if(fragCoord.y == 1)\n    {\n        Uniforms last;\n        Uniforms_Load(iChannel2, last);\n        fragData.b = texelFetch(iChannel2, fragCoord, 0).b;\n        \n        if(last.lastFrameTileID == fragCoord.x) fragData.b = float(u.spp);\n\n        if(iFrame == 0 || u.frameID == 0 || u.previewMode || !u.validFrame) fragData.b = 0.0;\n    }\n    \n    if(fragCoord.y == 2)\n    {\n        Uniforms last;\n        Uniforms_Load(iChannel2, last);\n        fragData.b = texelFetch(iChannel2, fragCoord, 0).b;\n        \n        if(last.lastFrameTileID == fragCoord.x)\n        {\n            uint tileSampleCount = floatBitsToUint(fragData.b);\n            \n            tileSampleCount += uint(u.spp);\n            \n            fragData.b = uintBitsToFloat(tileSampleCount + uint(mod(iTime,1e-6)));\n        }\n        \n        if(last.lastFrameTileID != last.tileID)  fragData.b = 0.0;\n        if(iFrame == 0 || u.frameID == 0 || u.previewMode || !u.validFrame) fragData.b = 0.0;\n    }\n}\n\nint getTileSPP(in Uniforms u) \n{\n    int spp = int(texelFetch(iChannel2, ivec2(u.tileID, 1), 0).b);\n    return clamp(((spp > 0) ? spp : u.spp), 1, int(Vespro_MAX_STEPS)); \n}\n\nuint getTileSampleCount(in Uniforms u) {\n    return floatBitsToUint(texelFetch(iChannel2, ivec2(u.tileID, 2), 0).b);\n}\n\nbool tileToScreen(in int tileID, in ivec2 tileFragCoord, in ivec2 size, out vec2 fragCoord, out int targetID)\n{\n    if(tileFragCoord.x < 0 || tileFragCoord.x >= 2 * size.x ||\n       tileFragCoord.y < 0 || tileFragCoord.y >= 2 * size.y) return false;\n\n    targetID = tileFragCoord.x / size.x + 2 * (tileFragCoord.y / size.y);\n\n    tileFragCoord = tileFragCoord % size;\n\n    ivec2 tileCoord = ivec2(tileID % int(ceil(iResolution.x / float(size.x))),\n                            tileID / int(ceil(iResolution.x / float(size.x)))) * size;\n\n    int fragID = tileFragCoord.x + tileFragCoord.y * size.x;\n    fragCoord = vec2(tileCoord + ivec2(fragID % size.x, fragID / size.x));\n\n    return((fragCoord.x >= 0.0 && fragCoord.x < iResolution.x) &&\n           (fragCoord.y >= 0.0 && fragCoord.y < iResolution.y));\n}\n\nfloat validateTileFragment(in Uniforms u, in ivec2 tileFragCoord)\n{\n    ivec2 size = ivec2(u.tileRes);\n    \n    vec2 fragCoord; int targetID;\n    if(!tileToScreen(u.tileID, tileFragCoord, size, fragCoord, targetID) || targetID != 0) return 1.0; // doesn't belong to tile\n\n    mat4 fragData = mat4(texelFetch(iChannel1, tileFragCoord + size * ivec2(0, 0), 0),\n                         texelFetch(iChannel1, tileFragCoord + size * ivec2(1, 0), 0),\n                         texelFetch(iChannel1, tileFragCoord + size * ivec2(0, 1), 0),\n                         texelFetch(iChannel1, tileFragCoord + size * ivec2(1, 1), 0));\n\n    Vespro_loadAsyncState(fragData);\n\n    uint targetSamples = 1u; // at least 1 new sample to validate the tile fragment\n    uint lastTileFragSamples = floatBitsToUint(texelFetch(iChannel3, ivec2(fragCoord), 0).a);\n    bool fragResolved = (_VesproCtx.integratedSamples >= lastTileFragSamples + targetSamples);\n\n    // abort pending fragments if max steps is reached (disabled)\n    const uint maxSamplesPerTile = Vespro_MAX_STEPS;\n    if(maxSamplesPerTile > 0u && getTileSampleCount(u) > maxSamplesPerTile) fragResolved = true;\n    \n    return float(fragResolved);\n}\n\nvec2 tileFragmentLuminance(in Uniforms u, in ivec2 tileFragCoord)\n{\n    ivec2 size = ivec2(u.tileRes);\n    \n    if(tileFragCoord.x < 0 || tileFragCoord.x >= size.x ||\n       tileFragCoord.y < 0 || tileFragCoord.y >= size.y) return vec2(0);\n\n    vec2 uv = vec2(tileFragCoord) / vec2(size);\n\n    // remap to img space, as we want the avg luminance of the whole image, not just the tile\n    vec2 fragCoord = uv * iResolution.xy;\n    \n    // ignore first 2 rows of pixels (contain binary data)\n    if(fragCoord.y < 2.0) return vec2(0);\n    \n    // ignore black bands when evaluating tile luminance\n    if(fragCoord.y <  floor(iResolution.y * blackBandsSize * 0.5) ||\n       fragCoord.y >= floor(iResolution.y - iResolution.y * blackBandsSize * 0.5)) return vec2(0);\n       \n    // fetch luminance from accumulated image in buffer D\n    vec4 fragData = textureLod(iChannel3, uv, 0.0);\n\n    uint lastTileFragSamples = max(floatBitsToUint(fragData.a), 1u);\n    fragData.rgb /= float(lastTileFragSamples);\n\n    float weight = pow(max(1.0 - 0.5 * length(uv - 0.5), 0.0), 20.0);\n    float luminance = max(fragData.r * 0.2126 + fragData.g * 0.7152 + fragData.b * 0.0722, 0.0);\n\n    luminance = clamp(luminance, exposureMin, exposureMax);\n\n    return vec2(luminance, 1) * weight;\n}\n\nvoid updateAdaptiveExposure(in float avgLuminance, inout float adaptiveExposure)\n{\n    const float adjustSpeed = 2.0;\n\n    float targetExposure = ((avgLuminance > 0.0) ? (0.5 / avgLuminance) : 0.0) * exposureMul;\n    float speed = min(iTimeDelta * adjustSpeed * (1.0 + 6.0 * float(targetExposure < adaptiveExposure)), 1.0);\n\n    adaptiveExposure = adaptiveExposure + (targetExposure - adaptiveExposure) * speed;\n    adaptiveExposure = clamp(adaptiveExposure, 1e-6, 1e+6);\n}\n\nvoid updateTileFenceLum_8x8(inout Uniforms u, in ivec2 fragCoord, inout vec4 fragColor)\n{\n    int nTiles = int(ceil(u.canvasRes.x / u.tileRes.x)) *\n                 int(ceil(u.canvasRes.y / u.tileRes.y));\n\n    // total convolution steps required to resolve the fence\n    int nConvolutionSteps = int(ceil(log2(float(max(u.tileRes.x, u.tileRes.y))) / 3.0));\n    bool isConvolution1x1 = (u.fenceStepID == (nConvolutionSteps - 1)); // final convolution step (1x1)\n\n    fragColor = vec4(0, 0, 0, 1);\n\n    ivec2 logicalSize = ivec2(ceil(u.tileRes / float(1 << (u.fenceStepID * 3))));\n    if(fragCoord.x < logicalSize.x && fragCoord.y < logicalSize.y)\n    {\n        // 8x8 convolution kernel\n        for(int i = 0; i < 8; ++i)\n        for(int j = 0; j < 8; ++j)\n        {\n            ivec2 uv = fragCoord * 8 + ivec2(i, j);\n\n            // Luminance Weighted Average\n            vec2 L = ((u.fenceStepID == 0) ? tileFragmentLuminance(u, uv) : texelFetch(iChannel2, uv, 0).rg);\n            if(uv.y < 1) L *= 0.0; // ignore first row of pixels (as it contains uniforms binary data)\n\n            fragColor.rg += L;\n\n            // Logic-AND\n            fragColor.a *= ((u.fenceStepID == 0) ? validateTileFragment(u, uv) : texelFetch(iChannel2, uv, 0).a);\n        }\n    }\n\n    if(isConvolution1x1 && fragColor.g > 0.0) u.avgLuminance = (fragColor.r / fragColor.g);\n\n    bool all_true = (fragColor.a > 0.0);\n\n    u.tileResolved = (isConvolution1x1 && all_true);\n    u.fenceStepID = ((u.fenceStepID + 1) % nConvolutionSteps);\n\n    if(u.tileResolved) u.tileID = (u.tileID + 1) % nTiles;\n}\n\nvoid Uniforms_update(inout Uniforms u)\n{\n    ++u.frameID;\n\n    if(iFrame == 0)\n    {\n        u.spp = 64; // kick-off samples per pixel (heuristically adjusted at runtime)\n\n        u.exposure = exposureMul;\n        u.avgLuminance = 1.0;\n\n        u.cameraPosition = cameraPosition;\n        u.cameraPitchYaw = cameraPitchYaw;\n        u.sunDirection = sunDir;\n\n        u.tileID = 0;\n        u.lastFrameTileID = 0;\n        u.fenceStepID = 0;\n        u.tileResolved = false;\n\n        u.mouseAnchor = vec4(0);\n        u.lastScreenRes = vec2(0);\n        u.validFrame = false;\n        u.frameID = 0;\n\n        u.exposureLocked = false;\n        u.displayTiles = true;\n        u.previewMode = true;\n    }\n\n    u.spp = getTileSPP(u);\n    \n    const float fpsCritical = 5.0; // if FPS drop below critical threshold, spp reset to 1\n    const float fpsTarget = max(float(targetFPS), fpsCritical);\n    const float targetDt = 1.0 / fpsTarget;\n    \n    float dt = min(iTimeDelta, targetDt);\n\n    // try to match desired framerate by adjusting spp at runtime\n    if(iTimeDelta > 0.0) u.spp += int((((1.0 / iTimeDelta) - fpsTarget) + 1.0) * 20.0 * max(iTimeDelta, targetDt));\n    if(iFrameRate <= fpsCritical) u.spp = 1; // critical threshold\n\n    u.spp = clamp(u.spp, 1, int(Vespro_MAX_STEPS));\n    \n    bool mousePressed = (iMouse.z > 0.0);\n    if(mousePressed)\n    {\n        if(any(lessThan(u.mouseAnchor.xy, vec2(0)))) u.mouseAnchor = vec4(iMouse.xy, u.cameraPitchYaw);\n\n    } else u.mouseAnchor.xy = vec2(-1);\n\n    vec2 mouseDelta = 2.0 * ((iMouse.xy - u.mouseAnchor.xy) / iResolution.xy) * float(mousePressed);\n    if(any(greaterThan(abs(mouseDelta.xy), vec2(0))))\n    {\n        u.validFrame = false;\n\n        u.cameraPitchYaw = u.mouseAnchor.zw + mouseDelta.yx * cameraAngularSpeed;\n        u.cameraPitchYaw.x = clamp(u.cameraPitchYaw.x, -1.5, +1.5);\n    }\n\n    vec3 camDir = normalize(vec3(cos(u.cameraPitchYaw.x) * sin(u.cameraPitchYaw.y),\n                                 sin(u.cameraPitchYaw.x),\n                                -cos(u.cameraPitchYaw.x) * cos(u.cameraPitchYaw.y)));\n\n    const vec3 up = vec3(0, 1, 0);\n    vec3 forward = camDir, right = normalize(cross(forward, up));\n\n    vec3 cameraVelocity = vec3(0);\n    if(texelFetch(iChannel0, ivec2(87, 0), 0).x > 0.0) cameraVelocity += forward;\n    if(texelFetch(iChannel0, ivec2(83, 0), 0).x > 0.0) cameraVelocity -= forward;\n    if(texelFetch(iChannel0, ivec2(65, 0), 0).x > 0.0) cameraVelocity -= right;\n    if(texelFetch(iChannel0, ivec2(68, 0), 0).x > 0.0) cameraVelocity += right;\n    if(texelFetch(iChannel0, ivec2(81, 0), 0).x > 0.0) cameraVelocity -= up;\n    if(texelFetch(iChannel0, ivec2(69, 0), 0).x > 0.0) cameraVelocity += up;\n\n    if(dot(cameraVelocity, cameraVelocity) > 0.0)\n    {\n        u.validFrame = false;\n        cameraVelocity = normalize(cameraVelocity);\n        if(texelFetch(iChannel0, ivec2(16, 0), 0).x > 0.0) cameraVelocity *= 10.0;\n\n        cameraUpdatePosition(u.cameraPosition, cameraVelocity, dt);\n    }\n\n    if(texelFetch(iChannel0, ivec2(76, 0), 0).x > 0.0) u.sunDirection = camDir, u.validFrame = false;\n    if(texelFetch(iChannel0, ivec2(73, 1), 0).x > 0.0) u.exposureLocked = !u.exposureLocked;\n    if(texelFetch(iChannel0, ivec2(84, 1), 0).x > 0.0) u.displayTiles = !u.displayTiles;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Uniforms u;\n    Uniforms_Load(iChannel2, u);\n \n    u.lastFrameTileID = u.tileID;\n   \n    u.validFrame = true;\n    bool wasPreview = u.previewMode;\n\n    // update uniforms\n    Uniforms_update(u);\n\n    // update tile fence and avg luminance\n    updateTileFenceLum_8x8(u, ivec2(fragCoord), fragColor);\n\n    // update adaptive exposure\n    if(!u.exposureLocked) updateAdaptiveExposure(u.avgLuminance, u.exposure);\n\n    // resolution changes\n    bool resetKeyPressed = (texelFetch(iChannel0, ivec2(32, 0), 0).x > 0.0);\n    if(resetKeyPressed) u.validFrame = false;\n\n    if(u.previewMode && u.frameID > 60) u.previewMode = false;\n    if(!u.validFrame || resetKeyPressed) u.previewMode = true;\n\n    bool resolutionChanged = (ivec2(u.lastScreenRes) != ivec2(iResolution.xy));\n    u.lastScreenRes = iResolution.xy;\n\n    ivec2 newTileRes = clamp(tileSize, ivec2(1), ivec2(iResolution.xy * 0.5));\n    if(newTileRes != ivec2(u.tileRes)) resolutionChanged = true;\n    u.tileRes = vec2(newTileRes);\n\n    vec2 newPreviewRes = vec2(previewSize);\n    newPreviewRes = floor(min(newPreviewRes, iResolution.xy * 0.5));\n\n    vec2 ar = vec2(iResolution.x / iResolution.y, 1);\n    ar *= vec2(newPreviewRes.y / newPreviewRes.x, 1);\n    if(ar.x > ar.y) ar = 1.0 / ar.yx;\n    newPreviewRes = floor(newPreviewRes * ar);\n\n    if(newPreviewRes != u.previewRes) resolutionChanged = true;\n    u.previewRes = newPreviewRes;\n\n    u.canvasRes = (u.previewMode ? vec2(u.previewRes) : iResolution.xy);\n\n    u.validFrame = (!resetKeyPressed && !resolutionChanged && u.validFrame);\n\n    if(wasPreview != u.previewMode) u.validFrame = false;\n    if(resolutionChanged) u.previewMode = true;\n\n    if(iFrame <= 0 || !u.validFrame || u.previewMode)\n    {\n        u.tileID = 0;\n        u.lastFrameTileID = 0;\n        \n        if(!u.previewMode || !u.validFrame) u.frameID = 0;\n        if(!u.previewMode || iFrame <= 0) u.fenceStepID = 0;\n\n        u.tileResolved = false;\n\n        if(resolutionChanged) u.frameID = -1;\n    }\n\n    Uniforms_Store(u, ivec2(fragCoord), fragColor);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ------------------------------------------------------------------ //\n//                              Reserved                              //\n// ------------------------------------------------------------------ //\n\n// This buffer is responsible of composing the whole image. It waits for the tile fence to be resolved,\n// and copies the integrated samples from the tile to the image.\n\n// The shared uniforms, duplicated in buffers B,C,D, Image\n// as we want to reserve the Common tab for the scene code only\nstruct Uniforms\n{\n    int  spp;\n    int  tileID;\n    int  lastFrameTileID;\n    int  fenceStepID;\n    bool tileResolved;\n    bool previewMode;\n\n    vec2 tileRes;\n    vec2 canvasRes;\n    vec2 previewRes;\n\n    vec2 lastScreenRes;\n    bool validFrame;\n    int  frameID;\n\n    vec3 cameraPosition;\n    vec2 cameraPitchYaw;\n    vec4 mouseAnchor;\n\n    bool  exposureLocked;\n    float avgLuminance;\n    float exposure;\n\n    bool displayTiles;\n    vec3 sunDirection;\n};\n\nvoid Uniforms_Load(in sampler2D s, out Uniforms u)\n{\n    vec3 data = texelFetch(s, ivec2(0, 0), 0).xyz;\n    u.tileResolved = bool(data.x);\n    float packedTileIDs = data.y;\n    u.avgLuminance = data.z;\n\n    data = texelFetch(s, ivec2(1, 0), 0).xyz;\n    u.lastScreenRes = data.xy;\n    u.cameraPosition.x = data.z;\n\n    data = texelFetch(s, ivec2(2, 0), 0).xyz;\n    u.cameraPosition.yz = data.xy;\n    u.cameraPitchYaw.x = data.z;\n\n    data = texelFetch(s, ivec2(3, 0), 0).xyz;\n    u.cameraPitchYaw.y = data.x;\n    u.previewRes = data.yz;\n\n    data = texelFetch(s, ivec2(4, 0), 0).xyz;\n    u.validFrame = bool(data.x);\n    u.mouseAnchor.xy = data.yz;\n\n    data = texelFetch(s, ivec2(5, 0), 0).xyz;\n    u.mouseAnchor.zw = data.xy;\n    u.previewMode = bool(data.z);\n\n    data = texelFetch(s, ivec2(6, 0), 0).xyz;\n    u.frameID = int(data.x);\n    u.canvasRes = data.yz;\n\n    data = texelFetch(s, ivec2(7, 0), 0).xyz;\n    u.spp = int(data.x);\n    u.tileRes = data.yz;\n\n    data = texelFetch(s, ivec2(8, 0), 0).xyz;\n    u.exposure = data.x;\n    u.fenceStepID = int(data.y);\n    u.displayTiles = bool(data.z);\n\n    data = texelFetch(s, ivec2(9, 0), 0).xyz;\n    u.exposureLocked = bool(data.x);\n    u.sunDirection = _Vespro_unpackNormal(data.yz);\n    \n    vec2 tileIDs = unpackHalf2x16(floatBitsToUint(packedTileIDs));\n    u.tileID = int(tileIDs.x);\n    u.lastFrameTileID = int(tileIDs.y);\n}\n\nbool screenToTile(in int tileID, in vec2 fragCoord, in ivec2 size, out ivec2 tileTexCoord[4])\n{\n    fragCoord = floor(fragCoord);\n\n    ivec2 tileCoord = ivec2(tileID % int(ceil(iResolution.x / float(size.x))),\n                            tileID / int(ceil(iResolution.x / float(size.x)))) * size;\n\n    if((int(fragCoord.x) < tileCoord.x || int(fragCoord.x) >= tileCoord.x + size.x) ||\n       (int(fragCoord.y) < tileCoord.y || int(fragCoord.y) >= tileCoord.y + size.y)) return false;\n\n    tileTexCoord[0] = ivec2(fragCoord) - tileCoord;\n    tileTexCoord[1] = tileTexCoord[0] + size * ivec2(1, 0);\n    tileTexCoord[2] = tileTexCoord[0] + size * ivec2(0, 1);\n    tileTexCoord[3] = tileTexCoord[0] + size * ivec2(1, 1);\n\n    return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Uniforms u;\n    Uniforms_Load(iChannel2, u);\n\n    fragColor = texelFetch(iChannel3, ivec2(fragCoord), 0);\n\n    bool validFrame = (iFrame > 0 && bool(texelFetch(iChannel2, ivec2(4, 0), 0).x));\n    if(!validFrame && !u.previewMode)\n    {\n        uint integratedSamples = floatBitsToUint(fragColor.a);\n        if(integratedSamples > 0u) fragColor.rgb /= float(integratedSamples);\n\n        fragColor.a = 0.0;\n        return;\n    }\n\n    if(!u.tileResolved && !u.previewMode) return;\n\n    int tileID = u.lastFrameTileID;\n\n    ivec2 size = ivec2(u.previewMode ? u.previewRes : u.tileRes);\n    if(u.previewMode)\n    {\n        fragCoord = floor(fract((fragCoord.xy / iResolution.xy)) * vec2(size));\n        tileID = 0;\n    }\n\n    ivec2 tileFragCoord[4];\n    if(!screenToTile(tileID, fragCoord, size, tileFragCoord)) return;\n\n    mat4 fragData = mat4(texelFetch(iChannel1, tileFragCoord[0], 0),\n                         texelFetch(iChannel1, tileFragCoord[1], 0),\n                         texelFetch(iChannel1, tileFragCoord[2], 0),\n                         texelFetch(iChannel1, tileFragCoord[3], 0));\n\n    Vespro_loadAsyncState(fragData);\n\n    fragColor.rgb = _VesproCtx.radiativeTransfer;\n    fragColor.a   = uintBitsToFloat(_VesproCtx.integratedSamples + uint(mod(iTime,1e-6)));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}