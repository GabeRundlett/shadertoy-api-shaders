{
    "Shader": {
        "info": {
            "date": "1684851566",
            "description": "Cool effect i accidently created",
            "flags": 0,
            "hasliked": 0,
            "id": "dtyGWt",
            "likes": 8,
            "name": "Perlin noise effect",
            "published": 3,
            "tags": [
                "noise",
                "perlin",
                "effect",
                "shades"
            ],
            "usePreview": 0,
            "username": "djancool",
            "viewed": 226
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y * 4.0 + iTime * 0.2;\n\n    // Time varying pixel color\n    float perlin = perlin_noise(uv);\n    float perlin_x = perlin_noise(uv + vec2(0.1, 0.0));\n    float perlin_y = perlin_noise(uv + vec2(0.0, 0.1));\n    vec3 normal = normalize(vec3(perlin - perlin_x, perlin - perlin_y, 0.05));\n    \n    float angle = atan(normal.x, normal.y) / 3.14159 / 2.0 + 0.5;\n    float waves = sin(angle * (sin(iTime * 0.3) + 1.4) * 4.0);\n    waves *= waves;\n\n    \n    fragColor = vec4(waves);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 n22 (vec2 p)\n{\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nvec2 get_gradient(vec2 pos)\n{\n    float twoPi = 6.283185;\n    float angle = n22(pos).x * twoPi;\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat perlin_noise(vec2 uv)\n{\n    vec2 pos_in_grid = uv;\n    vec2 cell_pos_in_grid =  floor(pos_in_grid);\n    vec2 local_pos_in_cell = (pos_in_grid - cell_pos_in_grid);\n    vec2 blend = local_pos_in_cell * local_pos_in_cell * (3.0f - 2.0f * local_pos_in_cell);\n    \n    vec2 left_top = cell_pos_in_grid + vec2(0, 1);\n    vec2 right_top = cell_pos_in_grid + vec2(1, 1);\n    vec2 left_bottom = cell_pos_in_grid + vec2(0, 0);\n    vec2 right_bottom = cell_pos_in_grid + vec2(1, 0);\n    \n    float left_top_dot = dot(pos_in_grid - left_top, get_gradient(left_top));\n    float right_top_dot = dot(pos_in_grid - right_top,  get_gradient(right_top));\n    float left_bottom_dot = dot(pos_in_grid - left_bottom, get_gradient(left_bottom));\n    float right_bottom_dot = dot(pos_in_grid - right_bottom, get_gradient(right_bottom));\n    \n    float noise_value = mix(\n                            mix(left_bottom_dot, right_bottom_dot, blend.x), \n                            mix(left_top_dot, right_top_dot, blend.x), \n                            blend.y);\n   \n    \n    return (noise_value / 0.7) * 0.5 + 0.5;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}