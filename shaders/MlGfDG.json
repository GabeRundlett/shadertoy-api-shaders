{
    "Shader": {
        "info": {
            "date": "1543835680",
            "description": "For Tokyo Demo Fest 2018 GLSL Graphics compo.",
            "flags": 0,
            "hasliked": 0,
            "id": "MlGfDG",
            "likes": 46,
            "name": "[TDF2018] Morph",
            "published": 3,
            "tags": [
                "2d",
                "fractal"
            ],
            "usePreview": 0,
            "username": "soma_arc",
            "viewed": 1673
        },
        "renderpass": [
            {
                "code": "precision mediump float;\n\nconst vec3 BLACK = vec3(0, 0, 0.01);\nconst vec3 WHITE = vec3(1);\nconst vec3 RED = vec3(0.8, 0, 0);\nconst vec3 GREEN = vec3(0, 0.8, 0);\nconst vec3 BLUE = vec3(0, 0, 0.8);\nconst vec3 YELLOW = vec3(1, 1, 0);\nconst vec3 PINK = vec3(.78, 0, .78);\nconst vec3 LIGHT_BLUE = vec3(0, 1, 1);\n\nconst float PI = 3.141592;\n\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 circleInvert(const vec2 pos, const vec4 circle){\n    vec2 p = pos - circle.xy;\n    float d = length(p);\n    return (p * circle.w)/(d * d) + circle.xy;\n}\n\n\nconst float GAMMA_COEFF = 2.2;\nconst float DISPLAY_GAMMA_COEFF = 1. / GAMMA_COEFF;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 degamma(vec3 rgb) {\n  return vec3((min(pow(rgb.r, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, GAMMA_COEFF), 1.)));\n}\n\nfloat lineY(vec2 pos, vec2 uv){\n\treturn uv.x * .5 + sign(uv.y * .5) * (2.*uv.x-1.95)/4. * sign(pos.x + uv.y * 0.5)* (1. - exp(-(7.2-(1.95-uv.x)*15.)* abs(pos.x + uv.y * 0.5)));\n}\n\nvec2 TransA(vec2 z, vec2 uv){\n\tfloat iR = 1. / dot(z, z);\n\tz *= -iR;\n\tz.x = -uv.y - z.x; z.y = uv.x + z.y;\n    return z;\n}\n\nvec2 TransAInv(vec2 z, vec2 uv){\n\tfloat iR = 1. / dot(z + vec2(uv.y,-uv.x), z + vec2(uv.y, -uv.x));\n\tz.x += uv.y; z.y = uv.x - z.y;\n\tz *= iR;\n    return z;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 computeColor(float n){\n\treturn hsv2rgb(vec3(.3 +0.06 * n, 1., .7));\n}\n\nvec3 computeColor2(float n, float numTransA) {\n    if(n == 0.) {\n        return vec3(0, 0, 0.05);\n    }\n    return hsv2rgb(vec3(0. + 0.05 * (n -1.), 1.0, 1.0));\n}\n\n//w: start time\n//s: duration\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;\n}\n\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\nfloat expEasingOut(float t) {\n\treturn -pow( 2., -10. * t) + 1.;\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\nconst int LOOP_NUM = 500;\nvec3 josKleinianIIS(vec2 pos, vec2 uv, float translation){\n    float loopNum = 0.;\n    vec2 lz = pos + vec2(1.);\n    vec2 llz = pos + vec2(-1.);\n\n    float numTransA = 0.;\n    for(int i = 0 ; i < LOOP_NUM ; i++){\n        // translate\n    \tpos.x += translation/2. + (uv.y * pos.y) / uv.x;\n        pos.x = mod(pos.x, translation);\n        pos.x -= translation/2. + (uv.y * pos.y) / uv.x;\n\n        // rotate 180\n        if (pos.y >= lineY(pos, uv.xy)){\n            // pos -= vec2(-uv.y, uv.x) * .5;\n            // pos = - pos;\n            // pos += vec2(-uv.y, uv.x) * .5;\n            // |\n            pos = vec2(-uv.y, uv.x) - pos;\n            //loopNum++;\n        }\n\n        pos = TransA(pos, uv);\n        numTransA++;\n        if(uv.x < pos.y) {\n            pos.y -= uv.x;\n            pos.y *= -1.;\n            pos.y += uv.x;\n            loopNum++;\n        }\n        if(pos.y <= 0.){\n            pos.y *= -1.;\n            loopNum++;\n        }\n\n        // 2-cycle\n        if(dot(pos-llz,pos-llz) < 1e-6) return computeColor2(loopNum, numTransA);\n\n        llz=lz; lz=pos;\n    }\n    return computeColor2(loopNum, numTransA);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    const int SAMPLE_NUM = 10;\n    vec3 sum = vec3(0);\n\tfloat ratio = iResolution.x / iResolution.y / 2.0;\n\n    float p_scale = 4.;\n    vec2 p_translate = vec2(-1, 1);\n    vec4 p_inversionCircle = vec4(0, 1, 1, 1);\n\n    vec2 p_symmetricalPoint = vec2(0., 1.);\n\n    float n = 1.;\n    float p_maskitK = 2. * cos(PI / n); // default value is k = 2\n\n    float t = mod(iTime, 16.);\n    float start = 0.0;\n    float duration = 1.5;\n\n    p_inversionCircle.x += mix(0., 0.5, circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.1;\n    p_inversionCircle.x += mix(0., -1.5, circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.1;\n\n    // arms start\n    duration = 0.8;\n    p_scale += mix(0., .9, circEasingInOut(scene(t, start, duration)));\n    p_symmetricalPoint += mix(vec2(0), vec2(0.1, -0.1), circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.2;\n    p_symmetricalPoint -= mix(vec2(0), vec2(0.1, -0.1), circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.1;\n\n    p_symmetricalPoint += mix(vec2(0), vec2(-0.1, -0.1), circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.2;\n    p_symmetricalPoint -= mix(vec2(0), vec2(-0.1, -0.1), circEasingInOut(scene(t, start, duration)));\n    p_scale += mix(0., -.9, circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.1;\n    // arms end\n\n    duration = 1.0;\n    p_inversionCircle.y += mix(0., -1., circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.1;\n    p_inversionCircle.x += mix(0., 1., circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.1;\n    p_inversionCircle.x += mix(0., -0.5, circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.1;\n\n    p_scale += mix(0., 15.5, circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.1;\n\n    p_translate.x += mix(0., 1.5, circEasingInOut(scene(t, start, duration)));\n    p_translate.y += mix(0., -.5, circEasingInOut(scene(t, start, duration)));\n    p_inversionCircle.y += mix(0., -0.5, circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.1;\n    p_scale -= mix(0., 15.5, circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.25;\n\n    // ending\n    p_inversionCircle.y += mix(0., 1.5, circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.1;\n    p_inversionCircle.x += mix(0., 0.5, circEasingInOut(scene(t, start, duration)));\n    p_translate.x += mix(0., -1.5, circEasingInOut(scene(t, start, duration)));\n    p_translate.y += mix(0., .5, circEasingInOut(scene(t, start, duration)));\n\n    vec2 p_maskitUV = vec2(p_symmetricalPoint.y * 2., -p_symmetricalPoint.x * 2.);\n    for(int i = 0 ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (fragCoord.xy + (rand2n(fragCoord.xy, float(i)))) / iResolution.yy ) - vec2(ratio, 0.5);\n        position *= p_scale;\n        position += p_translate;\n\n\n        position = circleInvert(position, p_inversionCircle);\n\n        if(true) {\n            sum += josKleinianIIS(position,\n                                  p_maskitUV, p_maskitK);\n        } else {\n            //sum += josKleinian(position,\n            //                  p_maskitUV, p_maskitK);\n        }\n    }\n\n\n    fragColor = vec4(gammaCorrect(sum / float(SAMPLE_NUM)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}