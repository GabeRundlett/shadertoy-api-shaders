{
    "Shader": {
        "info": {
            "date": "1670297690",
            "description": "I tried to make a piece of 3D art. Mouse orbits. W/ stochastic AA, which actually gives really good results with only 2-4 samples. Locked 144 fps on rtx 3080, Firefox w/ angle. Now with dithering!",
            "flags": 32,
            "hasliked": 0,
            "id": "ddSSWD",
            "likes": 27,
            "name": "Broken CRT",
            "published": 3,
            "tags": [
                "tv",
                "crt",
                "raymarcher",
                "aa"
            ],
            "usePreview": 0,
            "username": "fishy",
            "viewed": 500
        },
        "renderpass": [
            {
                "code": "float hash21(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 dither(vec3 color, vec2 coord, float steps)\n{\n    vec3 reduce = floor(color*steps)/steps;\n    vec3 error = color-reduce;\n    return reduce+step(vec3(hash21(coord)), error*steps)/steps;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dither = dither(texture(iChannel0, fragCoord/iResolution.xy).rgb, fragCoord, 256.);\n    fragColor = vec4(dither, 1.0);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define iTime mod(iDate.w, 50.)\n\n#define AA 2.0\n#define FOCAL_LEN 20.\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash12(float p)\n{\n    vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash21(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat shash(float x)\n{\n    return mix(hash11(floor(x)), hash11(floor(x)+1.), fract(x));\n}\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat sharpstep(float a, float b, float x)\n{\n    return saturate((x-a)/(b-a));\n}\n\nfloat peak(float a, float b, float x)\n{\n    return saturate(1.-abs((x-b)/a));\n}\n\nfloat peak2(float a, float b, float m, float x)\n{\n    x = saturate((x-a)/(b-a));\n    return saturate(1.-abs((x-m)/mix(m, 1.-m, step(0., x-m))));\n}\n\nmat2 rotMat(float r){ return  mat2(cos(r), -sin(r), sin(r), cos(r)); }\n\n\nvec3 rotX(vec3 p, float r)\n{\n    p.yz *= rotMat(r); return p;\n}\n\nvec3 rotY(vec3 p, float r)\n{\n    p.xz *= rotMat(r); return p;\n}\n\nvec3 rotZ(vec3 p, float r)\n{\n    p.xy *= rotMat(r); return p;\n}\n\nvec3 rot(vec3 v, in vec3 k, float t) // rotates point v t radians around axis k. See https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n{\n    k = normalize(k);\n    return mix(k*dot(k,v), v, cos(t)) + cross(k, v)*sin(t);\n}\n\nstruct marchMat\n{\n    vec3 color;\n    int id;\n};\n\nstruct marchRes\n{\n    bool hit;\n    float depth;\n    vec3 pos;\n    marchMat mat;\n};\nvoid join(inout float a, float b) { a = min(a, b); }\nvoid sub(inout float a, float b) { a = max(a, -b); }\nvoid intersect(inout float a, float b) { a = max(a, b); }\n\nvoid sjoin(inout float a, float b, float k ) // by iq\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    a = min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nvoid ssub(inout float d2, float d1, float k ) // by iq\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    d2 = mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nvec2 opRepLim2( in vec2 p, in float c, in vec2 l) // by iq\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nvec3 opRepLim3( in vec3 p, in float c, in vec3 l) // by iq\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) // by iq\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox(vec3 p, vec3 b, float r)\n{\n    return sdBox(p, b-r)-r;\n}\n\nvec3 planeIntersect(in vec3 ro, vec3 rd, float y, out bool hit)\n{\n    hit = sign(-rd.y) == sign(ro.y-y);\n    ro.xz = ro.xz+rd.xz*(y-ro.y)/rd.y;\n    return vec3(ro.x, y, ro.z);\n}\n\nfloat sceneDist(vec3 p, out marchMat outMat)\n{\n    p = rotX(p, -0.1);\n    float d = 1e20;\n    join(d, sdBox(p, vec3(0.3, 0.25, 0.1), 0.05)); // main body\n    sjoin(d, sdBox(p-vec3(0.0, -0.025, 0.22), vec3(0.25, 0.2, 0.2), 0.05), smoothstep(0.0, 0.2, p.z)*0.1+0.02); // the thing that sticks out the back\n    ssub(d, sdBox(p-vec3(0.0, 0.0, -0.25), vec3(0.25, 0.2, 0.2), 0.03), 0.02);\n    \n    float s0 = 1e20;\n    join(s0, sdSphere(p-vec3(0.0, 0.0, 1.4), 1.5));\n    intersect(s0, sdBox(p-vec3(0.0, 0.0, -0.25), vec3(0.28, 0.23, 0.2), 0.03));\n    outMat = marchMat(s0 > d? vec3(0.93, 0.9, 0.75) : vec3(0.25, 0.25, 0.25), int(s0 < d));\n    \n    join(d, s0);\n    \n    float s1 = 1e20;\n    \n    vec3 tp = p;\n    tp.x = abs(tp.x);\n    tp = tp - vec3(0.25, -0.025, 0.22);\n    vec2 lim = opRepLim2(tp.yz, 0.02, vec2(7,7));\n\n    join(s1, sdSphere(vec3(tp.x, lim)-vec3(0.0, 0.0, 0.00), 0.00));\n    ssub(d, s1, 0.01);\n    return d;\n}\n\nfloat sceneDist(vec3 p)\n{\n    marchMat m;\n    return sceneDist(p, m);\n}\n\nvec3 screenColor(vec2 p, float b)\n{\n    return vec3(hash21(floor(iTime*40.)*20.+floor(p.xy*150.))*0.3+0.7*((cos((p.y-iTime*0.2)*400.0)+cos((p.y+iTime*0.1)*25.0))*0.25+0.5))*b;\n}\n\nfloat planeColor(vec3 p, float b)\n{\n    float ao = 0.14/(abs(sceneDist(p)+0.2));\n    float a = peak2(-1., 0., 0.7, p.z);\n    a = smoothstep(-0.1, 1.0, pow(a, 3.))*(1.-smoothstep(0., 0.4, abs(p.x)))*0.2*b+0.1/(length(p.xz)+1.);\n    return a*(1.-ao);\n}\n\nmarchRes march(vec3 ro, vec3 rd, float margin, float maxDist, int maxIt)\n{\n    float depth = 0.0;\n    vec3 cp;\n    marchRes mres;\n    for(int i = 0; i < maxIt && depth < maxDist; i++)\n    {\n        cp = ro + depth*rd;\n        float cd = sceneDist(cp, mres.mat);\n        if(cd < margin)\n        {\n            return marchRes(true, depth, cp, mres.mat);\n        }\n        depth += cd;\n    }\n    \n    return marchRes(false, depth, ro + depth*rd, mres.mat);\n}\n\nvec3 calcNormal( in vec3 p ) // by iq\n{\n    const float h = 0.001;\n    #define ZERO (min(iFrame,0))\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sceneDist(p+e*h);\n    }\n    return normalize(n);\n}\n\nvec4 getColorAtPix(vec2 fc, vec4 m)\n{\n    vec2 uv = (fc-iResolution.xy*0.5)/iResolution.y;\n    vec2 mouse = (m.xy-iResolution.xy*0.5)/iResolution.y*step(0.01, m.z)*3.0;\n\n    vec2 cr = vec2(0.6154729, 0.7853982) - mouse.yx;\n    vec3 ro = rotY(rotX(vec3(0.1, 0.05, -2.*FOCAL_LEN), cr.x), cr.y);\n    vec3 rd = rotY(rotX(normalize(vec3(uv, FOCAL_LEN)), cr.x), cr.y);\n    \n    marchRes res = march(ro, rd, 0.001, 100.0, 512);\n    vec3 n = calcNormal(res.pos);\n    bool ph;\n    vec3 plane = planeIntersect(ro, rd, -0.25, ph);\n    float pd = distance(plane, ro);\n    float brightness = shash(floor(iTime)+smoothstep(0.0, 1.0, fract(iTime))*10.);\n    brightness = (0.6+0.4*sqrt(brightness));\n\n    float lighting = dot(max(rot(n, vec3(1,1,0)*0.707106781187, 0.96), 0.0), vec3(0.33))*0.5+0.5;\n    lighting = lighting*lighting*lighting*lighting-0.03;\n\n    vec3 screenColor = screenColor(res.pos.xy, brightness);\n\n    return sqrt(vec4(vec3(pd < res.depth && ph? vec3(planeColor(plane, brightness)):float(res.hit)*(res.mat.id == 1? screenColor : res.mat.color*lighting)), 1.));\n\n}\n\nvec4 simpleAA(vec2 fc, vec4 m)\n{\n    vec4 res = vec4(0);\n    float st = 2.0/AA;\n    for(float x = -1.; x < 1.; x += st) { for(float y = -1.; y < 1.; y += st)\n    {\n        res += getColorAtPix(fc + (vec2(x,y)+0.5), m);\n    }}\n    return res/(AA*AA);\n}\n\nvec4 stochasticAA(vec2 fc, vec4 m)\n{\n    vec4 res = vec4(0);\n    float st = 1.0/AA;\n    for(float x = 0.; x < 1.; x += st)\n    {\n        res += getColorAtPix(fc + (hash22(x+iTime+fc)-0.5), m);\n    }\n    return res/AA;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = stochasticAA(fragCoord, iMouse);\n    fragColor = mix(col, texture(iChannel1, fragCoord/iResolution.xy), 0.5);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}