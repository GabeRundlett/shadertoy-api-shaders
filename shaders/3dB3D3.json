{
    "Shader": {
        "info": {
            "date": "1550151173",
            "description": "An odd looking tree",
            "flags": 0,
            "hasliked": 0,
            "id": "3dB3D3",
            "likes": 3,
            "name": "Backwards Cap Tree",
            "published": 3,
            "tags": [
                "raymarch",
                "tree"
            ],
            "usePreview": 0,
            "username": "BackwardsCap",
            "viewed": 562
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 128\n#define SHADOW_STEPS 36\n#define ZERO (min(iFrame,0))\n#define RENDER_DIST 10.\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec4 smin( vec4 a, vec4 b, float k )\n{\n    float h = max( k-abs(a.x-b.x), 0.0 )/k;\n    \n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\n\nvec4 map( in vec3 p)\n{\n    \n    vec4 res = vec4(1e10,vec3(1));\n    //base\n    vec3 bp = p-vec3(0,-.2,0.5);\n\n    vec3 baseTex = texture(iChannel1, p.xy*4.).rgb * 0.6 + 0.4;\n    res = min(res, vec4(sdCappedCone(bp,.16,.1,.5),baseTex*vec3(0.5)));\n    //trunk\n    vec3 trunkTex = texture(iChannel0, p.xy).rgb * 0.6 + 0.4;\n    res = opU(res, vec4(sdCylinder(p-vec3(0,0.,0.5),vec3(0.,0.0,0.0),vec3(0,1.,0),0.05),\n                       trunkTex*vec3(.49,.36,0)));\n    \n    \n    \n    //smooth tree at base\n\tres = smin(res, vec4(sdCappedCone(bp+vec3(0,0.1,0),.05,.01,.05),vec3(1)),.6);\n\n    \n    //leaves on top\n    float rad = 0.3+.2*cos(p.y*10.0+3.0+3.0);\n    \n    vec3 lp = p-vec3(0,1,0.5);\n    \n    //rotating sphere\n    res = opU(res, vec4(sdSphere(lp+vec3(sin(iTime)*.6,sin(iTime)*.2+.5,cos(iTime)*.6),.1),\n                        vec3(0.5,.2+cos(iTime),.2+sin(iTime))));\n    \n    float rot = 0.;\n    \n//    lp.zx*=mat2(-cos(rot),sin(rot),-sin(rot),cos(rot));\n    \n    vec4 l = vec4(1e10,vec3(1));\n    l = opU(l, vec4(sdSphere(lp,rad),vec3(0,.5,0)));\n                \n    /*\n    for(float z=-.25;z<=.25;z+=.5)\n    {\n    \tfor(float x=-.25;x<=.25;x+=.5)\n    \t{\n        \tl = opU(l, vec4(sdSphere(lp+vec3(x,0,z),.2),vec3(0,.5,0)));\n    \t}\n    }\n    */\n                \n    res = opU(res,l);\n    \n  \n\n    \n    return res;\n    \n    \n}\n\nvec4 trace(in vec3 ro, in vec3 rd, float maxDist)\n{\n    \n    vec4 res = vec4(-1.0,-1.0,-1.0,-1.0);\n    \n    float t = 1.0;\n        for(int i=0;i<MAX_STEPS;++i){\n            \n            vec4 h = map(ro+rd*t);\n\n            t+=h.x;\n            if(abs(h.x)<(0.0001)||maxDist<t){\n                if(maxDist<t){\n                    res = vec4(t,vec3(-1));\n                    break;\n                }\n                res = vec4(t,h.yzw);\n                break;\n                \n            }\n            \n            \n            \n\n            \n        }\n        \n        return res;\n    \n}\n\nfloat maxHei = 1.5;\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    \n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<SHADOW_STEPS; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    \n    //sample around the point to calculate the normal of our surface\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    \n    vec3 col = vec3(0);\n    \n    vec4 res = trace(ro,rd,RENDER_DIST);\n    float t = res.x;//distance\n    vec3 m = res.yzw;//material info\n    \n    if(m.x<0.){\n        //set background to a gradient\n        col = vec3(.5+rd.y);\n    }else{\n    \t//distance casting\n    \tvec3 p = ro+t*rd;\n    \tvec3 nor = (m.x<1.5)?vec3(0.0,1.0,0.0) : calcNormal(p);\n    \tvec3 ref = reflect(rd,nor);\n    \t\n        \n   \t\tcol=m.xyz;\n    \n        //calc ambient occlusion\n        float occ = calcAO(p, nor);\n\t\t//light vector\n        vec3 lig = normalize(vec3(-1.0,.5,-0.5));\n        vec3 hal = normalize(lig-rd);\n\t\t//ambient lighting\n        float amb = clamp(0.5+0.5*nor.y,0.0,1.0);\n\n        //diffusion lighting\n        float dif = clamp(dot(nor,lig),0.0,1.0);\n\n        \n        float bac = clamp(dot(nor, normalize(vec3(-lig.x,0.0,-lig.z))),0.0,1.0)*clamp(1.0-p.y,0.0,1.0);\n        //reflections\n        float dom = smoothstep(-0.2,0.2,ref.y);\n        float fre = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n        \n        //add shadows\n        dif *= calcSoftshadow(p, lig, 0.02, 2.5);\n        dom*= calcSoftshadow(p,ref,0.02,2.5);\n        \n        //calc specularity\n        float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 16.0)*\n            dif*\n            (0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n        \n        //add the lighting and color together!\n        vec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n        lin += 0.30*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n    \n    \n    \n    return vec3(clamp(col,0.0,1.0));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -.5 to .5)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float offset = 5.;\n    \n    vec3 ro = vec3(offset*cos(1.*iTime),1.5,0.5+offset*sin(1.*iTime));\n        \n    \n    vec3 ta = vec3(-0.,0.5,0.5);\n    \n    //set cam pos\n    mat3 ca = setCamera(ro,ta,0.0);\n    vec3 rd = ca * normalize(vec3(uv.xy,2.0) );\n    \n    \n    vec3 col = render(ro, rd);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}