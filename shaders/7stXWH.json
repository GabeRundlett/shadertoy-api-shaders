{
    "Shader": {
        "info": {
            "date": "1633113574",
            "description": "A naive attempt at path tracing, doesn't really work as I want it to. ðŸ˜­",
            "flags": 32,
            "hasliked": 0,
            "id": "7stXWH",
            "likes": 5,
            "name": "inktober 1 - crystal",
            "published": 3,
            "tags": [
                "sdf",
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "pali6",
            "viewed": 300
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 p = texture(iChannel0, uv);\n    fragColor = vec4(p.rgb / p.a, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float rand(vec2 co)\n{\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nmat3 rotation(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat3(\n\t\toc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n\t);\n}\n\n#define PI 3.14159\n\nvec3 camPos = vec3(0, 0, 0.5);\nvec3 camDir = vec3(0, 0, -1);\nvec3 camUp = vec3(0, 450. / 800., 0);\nfloat camF = 0.3;\nconst int maxSteps = 32;\n\nvec3 rayDir(vec2 uv)\n{\n    vec3 camRight = normalize(cross(camDir, camUp));\n    float xs = rand(vec2(iTime * 0.01 + uv.x, uv.y)) / iResolution.x;\n    float ys = rand(vec2(iTime * 0.01 + uv.x, uv.y + 0.3)) / iResolution.y;\n    return normalize(camDir * camF + (uv.y + ys - 0.5) * 2. * camUp + (uv.x + xs - 0.5) * 2. * camRight);\n}\n\nfloat prism(vec3 pos, int n, float rot, float pointy)\n{\n    float result = 0.;\n    for(int i = 0; i < n; i++)\n    {\n        float angle = float(i) / float(n) * 2. * PI + rot;\n        result = max(result, dot(pos, vec3(cos(angle), 0, sin(angle))) - 1.);\n        result = max(result, dot(pos, vec3(cos(angle), pointy, sin(angle))) - 1.);\n    }\n    return result;\n}\n\nbool l = true;\n\nvec2 scene(vec3 pos)\n{\n    vec2 result = vec2(1e7, 0.);\n    /*\n    float s1 = distance(pos, vec3(0, 0, -4)) - 1.\n    if(s1 < result.x)\n        result = vec2(s1, 2.);\n    float s2 = distance(pos, vec3(-4, -1, -4.5)) - 2.;\n    if(s2 < result.x)\n        result = vec2(s2, 2.);\n    float s3 = distance(pos, vec3(5., 2.5, -5)) - 2.;\n    if(s3 < result.x)\n        result = vec2(s3, 2.);\n    */\n    for(int i = 0; i < 15; i++)\n    {\n        float fi = float(i) + 0.0019;\n        if(i >= 10)\n            fi += 0.11;\n        float rot1 = 2. * PI * rand(vec2(0.1 + 0.1 * fi, 0.1));\n        float rot2 = 2. * PI * rand(vec2(0.1 + 0.1 * fi, 0.2));\n        vec3 shift = vec3(\n            rand(vec2(0.1 + 0.1 * fi, 0.3)) * 6. - 3.,\n            rand(vec2(0.1 + 0.1 * fi, 0.4)) * 6. - 3.,\n            rand(vec2(0.1 + 0.1 * fi, 0.5)) * 6. - 3.\n        );\n        shift += vec3(0, 0, 6.);\n        int sides = 2 + int(5. * rand(vec2(0.1 + 0.1 * fi, 0.6)));\n        float pointiness = rand(vec2(0.1 + 0.1 * fi, 0.7)) + 0.1;\n        float rotoffset = 2. * PI * rand(vec2(0.1 + 0.1 * fi, 0.8));\n        \n        vec3 temppos = rotation(vec3(0, 1, 0), rot1) * rotation(vec3(0, 0, 1), rot2) * pos + shift;\n        float p1 = prism(temppos, sides, rotoffset, pointiness);\n        if(p1 < result.x)\n            result = vec2(p1, 3. + float(i));\n    }\n    float bs = 15. - distance(pos, vec3(0, 0, -4));\n    if(bs < result.x)\n        result = vec2(bs, 2.);\n    float li = distance(pos, vec3(-3., 4., -4.)) - 0.5;\n    if(l && li < result.x)\n        result = vec2(li, 1.);\n    return result;\n}\n\nvec3 sceneNormal(vec3 pos)\n{\n    float d = 0.001;\n    float base = scene(pos).x;\n    return normalize(vec3(\n        scene(pos + vec3(d, 0, 0)).x - base,\n        scene(pos + vec3(0, d, 0)).x - base,\n        scene(pos + vec3(0, 0, d)).x - base\n    ));\n}\n\nvec4 rt(vec3 rayPos, vec3 rayDir)\n{\n    float retVal = 0.;\n    for(int i = 0; i < maxSteps; i++)\n    {\n        vec2 sc = scene(rayPos);\n        float val = sc.x;\n        if(val < 0.001)\n        {\n            return vec4(rayPos, sc.y);\n        }\n        rayPos += rayDir * val;\n    }\n    return vec4(rayPos, 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 rd = rayDir(uv);\n    // l = false;\n    vec4 d = rt(camPos, rd);\n    int paths = 5;\n    float ff = 0.;\n    bool diff = false;\n    while(d.w != 1. && paths-- > 0)\n    {\n        if(paths == 1)\n            l = true;\n        vec3 norm = sceneNormal(d.xyz);\n        vec3 dir;\n        if(d.w >= 3.)\n            ff += 1.;\n        if(rand(vec2(iTime * 0.001 + d.x, 0.01 + d.y + d.z)) > 0.3 || !diff && paths == 1)\n        {\n            dir = normalize(vec3(rand(vec2(iTime * 0.001 + d.x, d.y + d.z))-0.5, rand(vec2(1. - iTime * 0.001 + d.x, 0.05 + d.y + d.z))-0.5, rand(vec2(0.03 + iTime * 0.001 + d.x, 1. - d.y + d.z))-0.5));\n            diff = true;\n        }\n        else\n            dir = normalize(norm + (norm + rd));\n        rd = dir;\n        d = rt(d.xyz + dir * 0.1, dir);\n    }\n    vec3 col;\n    float ls = 1.;\n    if(d.w != 1.)\n    {\n        fragColor = texture(iChannel0, uv) + vec4(0, 0, 0, 0.01);\n        return;\n    }\n    else\n    {\n        ls = max(0., dot(sceneNormal(d.xyz), normalize(rd)));\n        ls = ls * ls;\n        ls = ls * ls;\n        col = vec3(1. - ff / 6., 1. - ff / 6., 1.);\n        col = vec3(1);\n    }\n    fragColor = texture(iChannel0, uv) + vec4(col, ls);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}