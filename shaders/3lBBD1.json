{
    "Shader": {
        "info": {
            "date": "1598771534",
            "description": "Generative material texture for physics based rendering.\nBased on fBM, cellular noise, warping.\nPseudo random generated by permuted congruential generator",
            "flags": 0,
            "hasliked": 0,
            "id": "3lBBD1",
            "likes": 3,
            "name": "Generative material texture",
            "published": 3,
            "tags": [
                "texture",
                "material"
            ],
            "usePreview": 0,
            "username": "hyranno",
            "viewed": 297
        },
        "renderpass": [
            {
                "code": "/*\nby hyranno 2020/08/30\nGenerative material texture\nBased on fBM, cellular noise, warping\nPseudo random generated by permuted congruential generator\n*/\n\n#define MATERIAL 2\n/*\n0 : rough metal\n1 : scaled leather\n2 : wood\n*/\n\n\nconst float PI  = 3.141592653589793;\n\n/*\nhandling tetrahedron basis\nshould be uniform or const?\n*/\nmat3 TetrahedronBasis;\nmat3 InvTetrahedronBasis;\nvec3 TetrahedronCenter;\nvoid initTetrahedron(){\n  TetrahedronBasis = mat3(\n      cos(PI/6.0), sin(PI/6.0), 0,\n      cos(PI/6.0), -sin(PI/6.0), 0,\n      sqrt(1.0/3.0), 0, sqrt(2.0/3.0)\n  );\n  InvTetrahedronBasis = mat3(sqrt(1.0/3.0),sqrt(1.0/3.0),0, 1,-1,0, -sqrt(1.0/6.0),-sqrt(1.0/6.0),sqrt(3.0/2.0));\n  TetrahedronCenter = (TetrahedronBasis[0]+TetrahedronBasis[1]+TetrahedronBasis[2])/4.0;\n}\n//vec3 toTetrahedronCoord(vec3 p){ return InvTetrahedronBasis*p; }\n//vec3 fromTetrahedronCoord(vec3 p){ return TetrahedronBasis*p; }\n\n\nvec3[8] getBoundingCuboid(vec3 point){\n  vec3 ptf = floor(point), ptc = floor(point + vec3(1.0));\n  vec3[8] res;\n  res[0] = ptf;\n  res[1] = vec3(ptf.x, ptf.y, ptc.z);\n  res[2] = vec3(ptf.x, ptc.y, ptf.z);\n  res[3] = vec3(ptf.x, ptc.y, ptc.z);\n  res[4] = vec3(ptc.x, ptf.y, ptf.z);\n  res[5] = vec3(ptc.x, ptf.y, ptc.z);\n  res[6] = vec3(ptc.x, ptc.y, ptf.z);\n  res[7] = ptc;\n  return res;\n}\n\n\n/*\nvector rotation\n*/\nmat2 rotate2D(float angle){\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\nvec3 rotateAround(vec3 axis, float angle, vec3 p){\n  //Rodrigues' rotation formula\n  return p*cos(angle) + axis*dot(axis, p)*(1.0-cos(angle)) + cross(axis, p)*sin(angle);\n}\nvec3 rotateFromTo(vec3 f, vec3 t, vec3 p){\n  vec3 tmp = cross(f,t);\n  vec3 axis = normalize(tmp);\n  float angle = atan(length(tmp),dot(f,t));\n  vec3 res = rotateAround(axis, angle, p);\n  return (length(tmp)>0.0)? res : p;\n}\nvec3 tiltVec(vec3 v, float amp, float dir){\n  vec3 tmp = rotateAround(vec3(0,1,0), amp, vec3(1,0,0));\n  tmp = rotateAround(vec3(1,0,0), dir, tmp);\n  return rotateFromTo(vec3(1,0,0), v, tmp);\n}\n\n\n/*\nrandom generation\n */\n\nint rand_PCG(int seed){\n  const highp int increment = 0x4f6f4f3;\n  const highp int multiplier = 0x8934649*4+1;\n  highp int state = (seed + increment) & 0xffffffff;\n  highp int x;\n  int count;\n  state = (state * multiplier + increment) & 0xffffffff;\n  x = state;\n  state = (state * multiplier + increment) & 0xffffffff;\n  count = (x >> 28)&0x0f;  //32-log2(16)\n  x ^= (x >> 10)&0x3fffff;  //(32-(16-log2(16)))/2\n  int xs = (x >> 12)&0xffff;  //16-log2(16)\n  return ((xs >> count) | (xs << (16-count)))&0xffff;\n}\nint rand16(float f){\n  return rand_PCG(int(floor(f)));\n}\nfloat rand_uniform(vec3 v){\n  ivec3 sv = ivec3(floor(v));\n  int r = rand_PCG(rand_PCG(rand_PCG(sv.x)^sv.y)^sv.z);\n  return float(r+1) / float(0x10000);\n}\nfloat rand_exponential(vec3 v, float average){\n  //inversion method\n  return -average*log(1.0-rand_uniform(v));\n}\nvec2 rand_normal2(vec3 v){\n  //Boxâ€“Muller's method\n  float r1 = rand_uniform(v);\n  float r2 = rand_uniform(v.zxy);\n  float len = sqrt(-2.0*log(r1));\n  float angle = 2.0*PI*r2;\n  return len * vec2(cos(angle), sin(angle));\n}\nfloat rand_normal(vec3 v){\n  return rand_normal2(v).x;\n}\n\n\n\n/*\ncamera\n*/\nstruct Camera {\n  vec3 position;\n  vec3 target;\n  float roll;\n  vec2 angle;\n};\nCamera cam; //uniform\n\nvec3 uvToRayDirection(vec2 uv){\n  vec2 uvs = 2.0*uv - vec2(1.0);\n  vec3 defview = vec3(0.0, 0.0, 1.0);\n  vec3 view = normalize(cam.target-cam.position);\n  vec3 res = normalize( vec3(tan(cam.angle.x)*uvs.x, tan(cam.angle.y)*uvs.y, 1.0) );\n  res.xy = rotate2D(cam.roll)*res.xy;\n  res.yz = rotate2D(asin(view.y))*res.yz;\n  res.xz = rotate2D(atan(view.x, view.z))*res.xz;\n  return res;\n}\nfloat getPixelSize(vec3 point) {\n  float pixelAngle = cam.angle.x / iResolution.x;\n  return distance(cam.position, point) * tan(pixelAngle);\n}\n\n\n/*\nfBM noise generation\n */\nstruct ParamFBM {\n  float seed;\n  vec3 scale;\n  float attenuation;\n  float tilt;\n};\nstruct PartFBM {\n  float weightSum;\n  vec3 vec;\n  float scalar;\n};\nPartFBM newPartFBM(){\n  PartFBM res;\n  res.weightSum = 0.0;\n  res.vec = vec3(0.0);\n  res.scalar = 0.0;\n  return res;\n}\nPartFBM normalize(PartFBM src){\n  PartFBM res;\n  res.weightSum = src.weightSum/src.weightSum;\n  res.vec = src.vec/src.weightSum;\n  res.scalar = src.scalar/src.weightSum;\n  return res;\n}\n\nvoid partNoise(inout PartFBM res, vec3 pt, vec3 pti, ParamFBM param, float amp){\n  float angle = rand_uniform(pti*13.0) * 2.0*PI;\n  float mag = rand_normal(pti);\n  float r = distance(pt, pti);// / sqrt(2.0/3.0);\n  float weight = smoothstep(1.0,0.0, r*r);\n  float val = amp*weight*mag;\n  res.weightSum += weight;\n  res.vec += tiltVec(vec3(1,0,0)*val, param.tilt*mag, angle);\n  res.scalar += val;\n}\nvoid tetraNoise(inout PartFBM res, vec3 p, ParamFBM param, float freq, float amp){\n  float salt = float(rand16(freq + param.seed));\n  vec3 pt = InvTetrahedronBasis*(p/(freq*param.scale) + salt);\n  PartFBM part = newPartFBM();\n  vec3[8] pts = getBoundingCuboid(pt);\n  for (int i=min(0,iFrame); i<8; i++) {\n    partNoise(part, pt, pts[i], param, amp);\n  }\n  part = normalize(part);\n  res.vec += part.vec;\n  res.scalar += part.scalar;\n}\nPartFBM fbmNoise(vec3 point, ParamFBM param){\n  int maxOctave = int(ceil( log2(length(param.scale)/getPixelSize(point)) ));\n  float freq = 1.0;\n  float amp = 1.0;\n  PartFBM sum = newPartFBM();\n  for (int octave=0; octave <= maxOctave; octave++){\n    tetraNoise(sum, point, param, freq, amp);\n    freq /= 2.0;\n    amp /= param.attenuation;\n  }\n  return sum;\n}\n\n\n/*\ncellular noise generation\n */\nstruct CellParam{\n  vec3 shift;\n  vec3 seed;\n  vec3 scale;\n  float randomness;\n};\nstruct CellInfo{\n  vec3 center;\n  float rCenter;\n  float rBoundary;\n};\nvoid cellularNoiseSub(vec3 p, CellParam param, vec3 center, inout float r1, inout float r2, inout CellInfo res){\n  vec3 rands;\n  rands.x = rand_normal(center+param.seed.xxx);\n  rands.y = rand_uniform(center+param.seed.yyy);\n  rands.z = rand_uniform(center+param.seed.zzz);\n  vec3 randv = param.randomness*rands.x *tiltVec(vec3(1,0,0), rands.y*PI, rands.z*PI*2.0);\n  vec3 cellp = center+randv;\n  float r = distance(p, cellp);\n  r2 = (r2<r)? r2 : r;\n  res.center = (r1<r)? res.center : cellp;\n  r2 = (r1<r)? r2 : r1;\n  r1 = (r1<r)? r1 : r;\n}\nCellInfo cellularNoise(vec3 point, CellParam param){\n  vec3 p = point/param.scale + param.shift;\n  CellInfo res;\n  float r1=200.0, r2=200.0;\n  vec3[8] pts = getBoundingCuboid(InvTetrahedronBasis*p);\n  for (int i=min(0,iFrame); i<8; i++) {\n    cellularNoiseSub(p, param, TetrahedronBasis*pts[i], r1, r2, res);\n  }\n  res.center = (res.center-param.shift)*param.scale;\n  res.rCenter = r1;\n  res.rBoundary = (r2-r1)/2.0;\n  return res;\n}\n\n\n/*\ngrouth ring generation\n */\nstruct GrowthRingParam{\n  float scale;\n  vec3 center;\n  vec3 direction;\n  float sharpness;\n  float randomness;\n  ParamFBM pFBM;\n};\nfloat GrowthRingNoise(vec3 point, GrowthRingParam param) {\n  vec3 pt = point/param.scale - param.center;\n  vec3 p = rotateFromTo(param.direction, vec3(1,0,0), pt);\n  float r = length( p.yz );\n  r += param.randomness * fbmNoise(p, param.pFBM).scalar;\n  float v = fract(r);\n  float val = (v*v) * smoothstep(0.0, 1.0, param.sharpness*(1.0-v));\n  return val;\n}\n\n\n\nstruct DistanceToSurface {\n  int objectID;\n  float distance;\n};\n\nstruct Surface {\n  int objectID;\n  vec3 position;\n  vec3 albedo;\n  vec3 normal;\n  float metalness;\n  float roughness;\n  float occlusion;\n};\n\n/*\nray marching\n */\n\nDistanceToSurface findNearestSurface(vec3 point) {\n  DistanceToSurface res;\n  res.objectID = 1;\n  res.distance = distance(point, vec3(0.0)) - 5.0;\n  return res;\n}\nSurface getSurface(int objectID, vec3 point) {\n  Surface res;\n  res.objectID = 1;\n  res.position = point;\n  res.normal = normalize(point);\n  res.occlusion = 0.0;\n  float pixelSize = getPixelSize(res.position);\n  vec3 dp1 = pixelSize * rotateFromTo(vec3(1,0,0), res.normal, vec3(0,1,0));\n  vec3 dp2 = pixelSize * rotateFromTo(vec3(1,0,0), res.normal, vec3(0,0,1));\n  float height = 0.0;\n  float h1 = 0.0;\n  float h2 = 0.0;\n\n#if MATERIAL == 0\n  res.albedo = vec3(0.8, 0.8, 0.8);\n  res.metalness = 0.24;\n  res.roughness = 0.1;\n\n  ParamFBM pFBM;\n  pFBM.seed = 893.0;\n  pFBM.scale = vec3(1.0, 1.0, 1.0);\n  pFBM.attenuation = 2.0;\n  pFBM.tilt = 0.1;\n  vec3 fbmHue = normalize(vec3(1, -1, -1));\n  float fbmAlbedo = 0.004;\n  float fbmHeight = 0.006;\n  float fbmMetalness = -0.01;\n  float fbmRoughness = 0.01;\n\n#elif MATERIAL == 1\n  res.albedo = vec3(0.8, 0.8, 0.8);\n  res.metalness = 0.20;\n  res.roughness = 0.20;\n\n  ParamFBM pFBM;\n  pFBM.seed = 893.0;\n  pFBM.scale = vec3(0.05);\n  pFBM.attenuation = 4.0;\n  pFBM.tilt = 0.5 * PI/2.0;\n  vec3 fbmHue = normalize(vec3(1, 1, 1));\n  float fbmAlbedo = 0.1;\n  float fbmHeight = 0.003;\n  float fbmMetalness = 0.01;\n  float fbmRoughness = -0.02;\n\n#elif MATERIAL == 2\n  res.albedo = vec3(0.9, 0.8, 0.7);\n  res.metalness = 0.14;\n  res.roughness = 0.26;\n\n  ParamFBM pFBM;\n  pFBM.seed = 893.0;\n  pFBM.scale = vec3(1.0);\n  pFBM.attenuation = 2.0;\n  pFBM.tilt = 0.1;\n  vec3 fbmHue = normalize(vec3(1, 0, -0.2));\n  float fbmAlbedo = 0.004;\n  float fbmHeight = 0.014;\n  float fbmMetalness = -0.01;\n  float fbmRoughness = 0.01;\n#endif\n\n  h1 += fbmHeight * fbmNoise(point+dp1, pFBM).scalar;\n  h2 += fbmHeight * fbmNoise(point+dp2, pFBM).scalar;\n  PartFBM fbm = fbmNoise(point, pFBM);\n\n  height += fbmHeight * fbm.scalar;\n  res.albedo += fbmAlbedo * rotateFromTo(vec3(1,0,0), fbmHue, fbm.vec);\n  res.metalness += fbmMetalness * fbm.scalar;\n  res.roughness += fbmRoughness * fbm.scalar;\n\n#if MATERIAL == 1\n  CellParam pCell;\n  pCell.shift = vec3(8.93,10.9,4.643);\n  pCell.seed = vec3(634,546,763);\n  pCell.scale = vec3(0.7);\n  pCell.randomness = 0.027;\n  vec3 cellAlbedo = 0.4*normalize(vec3(-0.4,-1,-1));\n  float cellHeight = -0.07;\n  float cellMetalness = -0.04;\n  float cellRoughness = 0.04;\n\n  CellInfo cellNoise1 = cellularNoise(point+dp1, pCell);\n  h1 += cellHeight*(smoothstep(0.4, 0.0, cellNoise1.rBoundary*1.4) + smoothstep(0.0, 1.0, cellNoise1.rCenter));\n  CellInfo cellNoise2 = cellularNoise(point+dp2, pCell);\n  h2 += cellHeight*(smoothstep(0.4, 0.0, cellNoise2.rBoundary*1.4) + smoothstep(0.0, 1.0, cellNoise2.rCenter));\n  CellInfo cellNoise = cellularNoise(point, pCell);\n  float cellVal = smoothstep(0.4, 0.0, cellNoise.rBoundary*1.4) + smoothstep(0.0, 1.0, cellNoise.rCenter);\n\n  height += cellHeight * cellVal;\n  res.albedo += cellAlbedo * cellVal;\n  res.metalness += cellMetalness * cellVal;\n  res.roughness += cellRoughness * cellVal;\n#endif\n\n#if MATERIAL == 2\n  GrowthRingParam pGrowthRing;\n  pGrowthRing.scale = 0.8;\n  pGrowthRing.center = vec3(1.0, 0.0, 0.0);\n  pGrowthRing.direction = normalize(vec3(0.3, 1.0, 0.0));\n  pGrowthRing.sharpness = 4.0;\n  pGrowthRing.randomness = 0.1;\n  pGrowthRing.pFBM.seed = 763.0;\n  pGrowthRing.pFBM.scale = vec3(5.0, 1.0, 1.0);\n  pGrowthRing.pFBM.attenuation = 2.0;\n  pGrowthRing.pFBM.tilt = 0.0;\n  vec3 growthRingAlbedo = 2.0 * normalize(vec3(-0.3, -1, -3));\n  float growthRingMetalness = -0.01;\n  float growthRingRoughness = -0.01;\n\n  float growthRingVal = GrowthRingNoise(point, pGrowthRing);\n  res.albedo += growthRingAlbedo * growthRingVal;\n  res.metalness += growthRingMetalness * growthRingVal;\n  res.roughness += growthRingRoughness * growthRingVal;\n#endif\n\n  res.normal = normalize(cross(dp1 + (h1-height)*res.normal, dp2 + (h2-height)*res.normal));\n  res.albedo = clamp(res.albedo, 0.0, PI);\n  res.metalness = clamp(res.metalness, 0.0, 1.0);\n  res.roughness = clamp(res.roughness, 0.0, 1.0);\n  return res;\n}\n\nSurface raycast(vec3 origin, vec3 direction) {\n  const float e = 0.00001;\n  const float rayMaxLength = 100.0;\n  const int maxIteration = 50;\n  vec3 point = origin;\n  DistanceToSurface nearest = findNearestSurface(point);\n  for (int i=0; (i<maxIteration) && (distance(point, origin) < rayMaxLength) && (nearest.distance >= e); i++) {\n    point += direction * nearest.distance;\n    nearest = findNearestSurface(point);\n  }\n  Surface res = getSurface(nearest.objectID, point);\n  res.objectID = (nearest.distance < e)? res.objectID : -1;\n  return res;\n}\n\n\n/*\nphysics based rendering\n */\n\nfloat Vt_GGX(Surface suf, vec3 v){\n  return 0.5*(-1.0 + sqrt(1.0 + pow(suf.roughness,2.0)*(1.0/pow(dot(v,suf.normal),2.0)-1.0)));\n}\nvec3 applyDirectionalLight(Surface suf, vec3 light, vec3 lightDir, vec3 viewDir){\n  vec3 halfDir = normalize(lightDir+viewDir);\n  float F0 = suf.metalness; // Fresnel reflection rate\n  float F = F0 + (1.0-F0)*pow(1.0-dot(viewDir,halfDir), 5.0);\n  float G = 1.0/(1.0 + Vt_GGX(suf, lightDir) + Vt_GGX(suf, viewDir));\n  float D = pow(suf.roughness, 2.0) /PI /pow(pow(dot(suf.normal, halfDir),2.0) * (pow(suf.roughness,2.0)-1.0) +1.0, 2.0);\n  vec3 specular = vec3(1.0) * D*G*F / (4.0* dot(suf.normal, lightDir) * dot(suf.normal, viewDir));\n  vec3 diffuse = suf.albedo/PI;\n  vec3 color = (diffuse*(1.0-suf.metalness) + specular*suf.metalness) * dot(lightDir, suf.normal) * light;\n  return max(color, 0.0);\n}\n\nvec3 applyAmbientLight(Surface suf, vec3 light){\n  vec3 diffuse = suf.albedo/PI;\n  return (1.0-suf.occlusion) * diffuse * light;\n}\n\n\n\n/*\nmain\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  initTetrahedron();\n\n  float radius = 4.0*cos(iTime/5.0) + 12.0;\n  cam.position = vec3(radius*cos(iTime/2.0), 4.0, radius*sin(iTime/2.0));\n  cam.target = vec3(0.0, 0.0, 0.0);\n  cam.roll = 0.0/360.0 * 2.0*PI;\n  cam.angle.x = 2.0*PI * 50.0/360.0;\n  cam.angle.y = atan(tan(cam.angle.x)*(iResolution.y/iResolution.x));\n\n  vec2 uv = fragCoord/iResolution.xy;\n  vec3 rayDir = uvToRayDirection(uv);\n  Surface suf = raycast(cam.position, rayDir);\n\n  vec3 col = vec3(0.0);\n  col += (suf.objectID<0)? vec3(0.0) : applyDirectionalLight(suf, vec3(2.0), -vec3(0.0, -1.0, 0.0), -rayDir);\n  col += (suf.objectID<0)? vec3(0.0) : applyAmbientLight(suf, vec3(0.5));\n\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}