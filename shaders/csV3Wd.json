{
    "Shader": {
        "info": {
            "date": "1679236769",
            "description": "CC0: Sommarhack 2023\nI started as an Atari ST hacker and while I don't really do anything on the Atari ST\nanymore I feel excitement over that the community is still alive and makes amazing things.\n",
            "flags": 64,
            "hasliked": 0,
            "id": "csV3Wd",
            "likes": 42,
            "name": "Sommarhack 2023",
            "published": 3,
            "tags": [
                "2d",
                "sommarhack"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 534
        },
        "renderpass": [
            {
                "code": "// CC0: Sommarhack 2023\n//  I started as an Atari ST hacker and while I don't really do anything on the Atari ST\n//  anymore I feel excitement over that the community is still alive and makes amazing things.\n//  There is an event happening most years called sommarhack and I hope to be able to go this year.\n//  This an unofficial promotion shader for that event :)\n//  https://sommarhack.se/2023/\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TTIME           (TIME*TAU)\n#define DOT2(x)         dot(x, x)\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define SCA(a)          vec2(sin(a), cos(a))\n\nvec2 g_qx = vec2(0.0);\nvec2 g_qy = vec2(0.0);\n\nvec2 g_rx = vec2(0.0);\nvec2 g_ry = vec2(0.0);\n\n// https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat horseshoe(vec2 p, vec2 c, float r, vec2 w) {\n  p.x = abs(p.x);\n  float l = length(p);\n  p = mat2(-c.x, c.y, c.y, c.x)*p;\n  p = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),\n           (p.x>0.0)?p.y:l );\n  p = vec2(p.x,abs(p.y-r))-w;\n  return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat segmenty(vec2 p, float h, float w) {\n  float hh = 0.5*h;\n  p.y = abs(p.y);\n  p.y -= hh;\n  float d0 = length(p);\n  float d1 = abs(p.x);\n  float d = p.y > 0.0 ? d0 : d1;\n  d -= w;\n  return d; \n}\n\nconst float lw = 0.1;\n\n\nfloat noise(vec2 p) {\n  p /= pow(1.1 + 0.25*(0.5 + 0.5*sin(0.1*(p.x + p.y) + TTIME/10.0)), 1.15);\n  float a = sin(p.x);\n  float b = cos(p.y);\n  float c = sin(p.x + p.y);\n  float d = mix(a, b, c);\n  return tanh_approx(d);\n\n}\n\n// https://iquilezles.org/articles/fbm\nfloat fbm(vec2 p) {    \n  const float A = 0.57;\n  const float F = 2.1;\n  const int numOctaves = 4;\n  const mat2 rots[numOctaves] = mat2[](F*ROT(0.0/float(numOctaves)), F*ROT(1.0/float(numOctaves)), F*ROT(2.0/float(numOctaves)), F*ROT(3.0/float(numOctaves)));\n\n  float t = 0.0;\n  float f = 1.0;\n  float a = 1.0;\n  for(int i = 0; i<numOctaves; ++i) {\n    t += a*noise(f*p);\n    p *= rots[i];\n    a *= A;\n  }\n\n  return tanh_approx(0.3+t);\n}\n\nconst float scale1 = 1.4;\nconst float scale2 = 0.2; \n\nvoid compute_globals(vec2 p) {\n  const vec2 qx = vec2(1.0,3.0)*scale2;\n  const vec2 qy = vec2(5.0,2.0)*scale2;\n\n  const vec2 rx = vec2(2.0,9.0)*scale2;\n  const vec2 ry = vec2(8.0,3.0)*scale2;\n  \n  g_qx = qx*ROT(TTIME/100.0);\n  g_qy = qy*ROT(TTIME/90.0);\n\n  g_rx = rx*ROT(TTIME/80.0);\n  g_ry = ry*ROT(TTIME/70.0);\n}\n\n// https://iquilezles.org/articles/warp\nvec3 warp(in vec2 p, float d) {\n  p.y = -p.y;\n  float lp = length(p);\n  p.x = -abs(p.x);\n  p *= ROT(TTIME/150.0 + 0.125*length(p));\n  \n  vec2 qx = g_qx;\n  vec2 qy = g_qy;\n\n  vec2 rx = g_rx;\n  vec2 ry = g_ry;\n\n  vec2 q = vec2(fbm(p + qx),\n                fbm(p + qy));\n\n  vec2 r = vec2(fbm(0.25*p + scale1*q + rx),\n                fbm(0.5*p + scale1*q + ry));\n\n  float f = fbm(0.75*p + scale1*r);\n \n  float scaleIt = 1.5*(pow(abs((p.x + p.y)), 0.7));\n\n  float pp= mix(0.7, 0.35, 1.5*tanh_approx(length(p)));\n\n  float fi = tanh_approx(pow(scaleIt, pp)*d / (f - d*scaleIt));\n  vec3 col =  abs(fi*fi+0.05)*(1.0+cos(0.5*vec3(0.0, 1.0, 2.0)+1.0*(dot(q,r))+0.5));\n  return pow(col, vec3(2.0, 1.5, 1.5)*tanh_approx(0.25*lp));\n}\n\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) \n         ? length(p-vec2(0.0,b))                         \n         : length(p-vec2(-d,0.0))-r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat moon(vec2 p, float d, float ra, float rb ) {\n  p.y = abs(p.y);\n  float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n  float b = sqrt(max(ra*ra-a*a,0.0));\n  if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n        return length(p-vec2(a,b));\n  return max( (length(p          )-ra),\n             -(length(p-vec2(d,0))-rb));\n}\n\n// Imprecise faster version\nfloat fastMoon(vec2 p, float d, float ra, float rb) {\n  float d0 = length(p) - ra;\n  float d1 = length(p-vec2(d, 0.0)) - rb;\n  return max(d0, -d1);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedCross( in vec2 p, in float h ) {\n  float k = 0.5*(h+1.0/h); // k should be const at modeling time\n  p = abs(p);\n  return ( p.x<1.0 && p.y<p.x*(k-h)+h ) ? \n           k-sqrt(DOT2(p-vec2(1,k)))  :\n         sqrt(min(DOT2(p-vec2(0,h)),\n                  DOT2(p-vec2(1,0))));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n \nfloat plane(vec2 p, vec3 pp) {\n  return dot(p, pp.xy) + pp.z;\n}\n \nfloat summerhack(vec2 p) {\n  // As the moon shapes are mostly used for cut-outs I think there is less need for exact\n  //  moon distance and therefore rely on fastMoon instead\n  vec2 op = p;\n  p.x = abs(p.x);\n  vec2 p0 = p;\n  p0 -= vec2(0.0, 0.385);\n  float d0 = circle(p0, 0.605);\n  vec2 p1 = p;\n  p1 -= vec2(0.0, -0.375);  \n  float d1 = vesica(p1, vec2(0.04, 0.569))-(mix(0.005, 0.035, smoothstep(0.1, 0.2, p1.y)));\n  \n  vec2 p2 = p;\n  p2 -= vec2(0.0, 0.4);\n  p2 = -p2.yx;\n  float d2 = fastMoon(p2, 0.075, 0.33, 0.275);\n  \n  vec2 p3 = p;\n  p3 -= vec2(0.0, 0.65);\n  float d3 = circle(p3, 0.367);\n  \n  vec2 p4 = p;\n  p4 -= vec2(0.0, 0.43);\n  float d4 = circle(p4, 0.29);\n  \n  vec2 p5 = p;\n  p5 -= vec2(-0.185, 0.12);\n  float d5 = circle(p5, 0.30);\n  \n  vec2 p6 = p;\n  p6 -= vec2(0.12, -0.19);\n  p6 *= ROT(0.65);\n  float d6 = vesica(p6, vec2(0.15, 0.024))-0.0175;\n  \n  vec2 p7 = p;\n  p7 -= vec2(0.0, 0.735);\n  p7 = -p7.yx;\n  float d7 = fastMoon(p7, 0.13, 0.68, 0.595);\n  \n  vec2 p8 = p;\n  p8 -= vec2(0.0, 0.7);\n  p8 = -p8.yx;\n  float d8 = fastMoon(p8, 0.1, 0.477, 0.4676);\n\n  vec2 p9 = p;\n  p9 -= vec2(0.25, 0.72);\n  p9.x = -p9.x;\n  float d9 = fastMoon(p9, 0.188, 0.73, 0.775);\n\n  vec2 p10 = op;\n  p10 -= vec2(0.0, 0.28);\n  p10 = p10.yx;\n  p10.x *= sign(op.x);\n  p10.x += (-sign(op.x)+1.0)*-0.0775;\n  float d10 = moon(p10, 0.045, 0.105, 0.095);\n\n  vec2 p11 = p;\n  p11 -= vec2(0.0, -0.78);\n  p11 = p11.yx;\n  float d11 = roundedCross(p11, 0.55);\n  \n  vec2 p12 = p;\n  float d12 = plane(p12, vec3(normalize(vec2(-4.0, 1.0)), 0.315));\n  \n  vec2 p13 = p;\n  p13 -= vec2(-0.05, -0.805);\n  float d13 = circle(p13, 0.175);\n\n  vec2 p14 = p;\n  p14 -= vec2(0.0, -0.88);\n  float d14 = p14.y;\n  \n  vec2 p15 = p;\n  p15 -= vec2(0.45, -0.4);\n  p15 = p15.yx;\n  float d15 = fastMoon(p15, 0.14, 0.4, 0.4);\n\n  vec2 p16 = op;\n  p16 -= vec2(-0.095, 0.323);\n  // Cheat to remove discontinuity in distance field due to hacking on d10\n  float d16 = length(p16); \n    \n  d11 = max(d11, -d13);\n  d11 = max(d11, -d14);\n  d11 = max(d11, -d15);\n  d11 = pmax(d11, -d12, 0.0125);\n\n  float dn = d3;\n  dn = min(dn, d4);\n  dn = min(dn, d2);\n  dn = min(dn, d5);\n  dn = min(dn, d6);\n  dn = min(dn, d7);\n  dn = min(dn, d8);\n  dn = min(dn, d9);\n\n  float d = d0;\n  d = max(d, -dn);\n  d = min(d, d1);\n  d = min(d, d10);\n  d = min(d, d11);\n  d = min(d, d16);\n  \n  \n  return d;\n}\n\nfloat digit_0(vec2 p) {\n  const vec2 sca = SCA(0.);\n  vec2 p0 = p;\n  p0.y = -abs(p0.y);\n  p0.y -= -0.3;\n  float d0 = horseshoe(p0, sca, 0.5, vec2(1.0, lw));\n  \n  float d = d0;\n  return d;\n}\n\nfloat digit_2(vec2 p) {\n  const vec2 sca = SCA(0.);\n  const mat2 r0 = ROT(radians(132.5));\n  vec2 p0 = p;\n  vec2 p2 = p;\n  p2.y -= -0.8;\n  p2 = p2.yx;\n  p0.y -= 0.3;\n  p0 *= r0;\n  vec2 p1 = p0;\n  p1.x -= -0.5;\n  p1.y -= 0.25;\n  float d0 = horseshoe(p0, sca, 0.5, vec2(0.1, 0.0))-lw;\n  float d1 = segmenty(p1, 1.655, lw);\n  float d2 = segmenty(p2, 1.0-lw, lw);\n  \n  float d = d0;\n  if (p0.y > 0.0 && p0.x < 0.0) {\n    d = d1;\n  }\n  d = min(d, d2);\n  return d;\n}\n\n\nfloat digit_3(vec2 p) {\n  const vec2 sca = SCA(0.);\n  const mat2 r0 = ROT(radians(132.));\n  vec2 p0 = p;\n  p0.y = pabs(p0.y, 0.1);\n  p0.y -= 0.35;\n  p0 *= r0;\n  float d0 = horseshoe(p0, sca, 0.45, vec2(0.15, 0.0))-lw;\n  float d = d0;\n  return d;\n}\n\nfloat year2023(vec2 p) {\n  p.x -= -0.575;\n  vec2 p0 = p;\n  p0.x -= 0.06;\n  vec2 p1 = p;\n  float sx = sign(p1.x);\n  p1.x = -abs(p1.x);\n  p1.x -= -1.2;\n  p1.x *= -sx;\n  vec2 p2 = p;\n  p2.x -= 2.35;\n  float d0 = digit_0(p0);\n  float d1 = digit_2(p1);\n  float d2 = digit_3(p2);\n  float d = d0;\n  d = min(d, d1);\n  d = min(d, d2);\n  return d;\n}\n\n// License: Unknown, author: Unknown, found: shadertoy somewhere, don't remember where\nfloat dfcos(float x) {\n  return sqrt(x*x+1.0)*0.8-1.8;\n}\n\n// License: Unknown, author: Unknown, found: shadertoy somewhere, don't remember where\nfloat dfcos(vec2 p, float freq) {\n  // Approximate distance to cos\n  float x = p.x;\n  float y = p.y;\n  x *= freq;\n\n  float x1 = abs(mod(x+PI,TAU)-PI);\n  float x2 = abs(mod(x   ,TAU)-PI);\n\n  float a = 0.18*freq;\n\n  x1 /= max( y*a+1.0-a,1.0);\n  x2 /= max(-y*a+1.0-a,1.0);\n  return (mix(-dfcos(x2)-1.0,dfcos(x1)+1.0,clamp(y*0.5+0.5,0.0,1.0)))/max(freq*0.8,1.0)+max(abs(y)-1.0,0.0)*sign(y);\n}\n\nfloat bounce(float t, float dy, float dropOff) {\n  const float g = 10.0;\n  float p0 = 2.0*dy/g;\n\n  t += p0/2.0;\n    \n  float ldo = log(dropOff);\n  float yy = 1.0 - (1.0 - dropOff) * t / p0;\n\n\n  if (yy > 1e-4) {\n    float n  = floor(log(yy) / ldo);\n    float dn = pow(dropOff, n);\n\n    float yyy = dy * dn;\n    t -= p0 * (1.0 - dn) / (1.0 - dropOff);\n\n    return -0.5*g*t*t + yyy*t;\n\n  }\n  else {\n      return 0.0;\n  }\n}\n\n\nvec3 effect(vec2 p, vec2 pp) {\n  float ltm = mod(TIME, 225.0);\n  compute_globals(p);\n  float aa = 2.0 / RESOLUTION.y;\n  float b = bounce(max(ltm-1.0, 0.0),8.0, 0.8);\n  vec3 col = vec3(0.0);\n  vec2 p0 = p;\n  p0.y -= -0.025;\n  float d0 = summerhack(p0);\n  const float z1 = 0.4;\n  vec2 p1 = p;\n  p1.x -= -0.05;\n  p1.y -= -0.6+b;\n  p1 /= z1;\n  const float z2 = 0.15;\n  vec2 p2 = p;\n  p2.x += -0.05*ltm;\n  p2.y -= -0.6+b;\n  p2 /= z2;\n  float d1 = year2023(p1)*z1;\n  float d2 = dfcos(p2, 0.5)*z2;\n  d2 = abs(d2)-0.025;\n  vec2 p3 = p;\n  float n3 = mod1(p3.y, 0.04);\n  n3 = abs(n3);\n  n3 += 3.0;\n  p3.x = abs(p3.x);\n  p3.x -= RESOLUTION.x/RESOLUTION.y;\n  p3 = p3.yx;\n  float fft = texture(iChannel0, vec2(0.02*n3, 0.25)).x;\n  fft -= 0.3;\n  fft = max(fft, 0.0);\n  fft *= fft;\n  fft *= 1.5;\n  float d3 = segmenty(p3, fft, 0.01);\n\n  d1 = max(d1, -d2);\n  d1 = min(d1, d2+0.015+0.0075*p.x*p.x);\n  d1 = min(d1, d3);\n  float d = d0;\n  vec2 c = vec2(0.0, 0.385);\n  \n  const float hue = 0.05;\n  const vec3 dcol = HSV2RGB(vec3(hue, 0.95,  4.0));\n  const vec3 gcol = HSV2RGB(vec3(hue, 0.9, .0005));\n  col = warp(p*6.0, d-0.05);\n  float dg = d+0.01;\n  float ol = length(p-c);\n  col = mix(2.0, 0.5, smoothstep(0.6, 1.85, ol))*col;\n  col += gcol/max(dg*dg, 0.00001);\n  col += vec3(3.0)*smoothstep(-aa, aa, -(d-0.005));\n  col = mix(col, vec3((dcol)*smoothstep(0.6, 0.8, pp.y+0.2*(p.x*p.x)+0.005*sin(30.0*(p.x)+0.36*TTIME)*cos(53.0*(p.x)-0.25*TTIME))), smoothstep(-aa, aa, -(d)));\n  col -= vec3(1.0, 2.0, 0.0)*0.05*(length(pp));\n\n  col = aces_approx(col);\n  col *= smoothstep(9.0, 11.0, ltm);\n  col = mix(col, vec3(0.0), smoothstep(aa, -aa, d1-0.005));\n  col = mix(col, vec3(1.0), smoothstep(aa, -aa, d1));\n  col *= smoothstep(220.0, 205.0, ltm);\n  col = sRGB(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, q);\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 32791,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/phenix-80/goldrunner-remix-2020?si=06d3b4da101a4bd18cc6df2de6a69130&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}