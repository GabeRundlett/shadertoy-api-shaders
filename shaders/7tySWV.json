{
    "Shader": {
        "info": {
            "date": "1641944406",
            "description": "a clock that looks like it's made of ferrofluid. move the mouse to change the light position.",
            "flags": 32,
            "hasliked": 0,
            "id": "7tySWV",
            "likes": 19,
            "name": "Ferrofluid Clock",
            "published": 3,
            "tags": [
                "mouse",
                "clock",
                "buffer"
            ],
            "usePreview": 1,
            "username": "ArmandB",
            "viewed": 456
        },
        "renderpass": [
            {
                "code": "/*\n0: distance\n1: black\n2: sin of dist\n3: shaded\n4: displaced grid\n5: normals\n*/\nconst int mode = 3;\nbool cycleModes = false;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float pxunit = 1.0/iResolution.y*7.0;\n    int effectiveMode = mode;\n    \n    if (cycleModes == true){\n        effectiveMode = int(mod(iDate.w/5.0,6.0));\n    }\n    \n    if (effectiveMode == 1) { //black\n        col = vec3(mix(0.0, 1.0, smoothstep(thresh, thresh + pxunit*2.0, col.x)));\n    } else if (effectiveMode == 2) { //sin\n        col = sin(col*20.0);\n    } else if (effectiveMode == 3 || effectiveMode == 5) { //normals && shaded \n        float normScale = 0.1;\n        \n        vec3 p0 = vec3(0,thresh-col.x,0);\n        vec3 p1 = vec3(normScale,thresh-texture(iChannel0, uv + vec2(pxunit,0)).x,0);\n        vec3 p2 = vec3(0,thresh-texture(iChannel0, uv + vec2(0,pxunit)).x,normScale);\n        vec3 v1 = normalize(p1-p0);\n        vec3 v2 = normalize(p2-p0);\n        vec3 normal = cross(v1,v2);\n        if (effectiveMode == 3){ //shaded\n            vec3 lightpos = vec3(m.x,0.1,m.y);\n            vec3 light = normalize(vec3(uv.x,0,uv.y) - lightpos);\n            vec3 camray = normalize(vec3(0.5,1,0.5) - vec3(uv.x, col.x, uv.y));\n            vec3 color = vec3(0.6,0.1,0.0);\n            vec3 background = vec3(1.0,1.0,0.8);\n            \n            float mask = mix(1.0, 0.0, smoothstep(thresh, thresh + pxunit*2.0, col.x));\n            \n            float dotproduct = clamp(dot(light, normal),0.0,1.0);\n            vec3 reflectedRay = reflect(light, normal);\n            float specular = max(dot(reflectedRay, camray),0.0);\n            vec3 ambient = color * 0.4;\n            vec3 basecol = ambient + (specular * dotproduct * mask * color)/pow(distance(vec3(uv.x,0,uv.y),lightpos),2.0);\n            \n            col = mix(background, basecol, mask);\n            \n        } else { //normals\n            col = normal;\n        }\n    } else if (effectiveMode == 4) { //displaced grid\n        col = vec3(mix(col.x, 0.5+col.x/3.0, smoothstep(0.95, 1.0, sin(uv.y*200.0 + col.x*6.0))));\n        col = vec3(mix(col.x, 0.5+col.x/3.0, smoothstep(0.95, 1.0, sin(uv.x*200.0 + col.x*3.0))));\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float thresh = 0.2;\n\nfloat smin(float a, float b) {\n  float k = 0.25;\n  float h = max(k - abs(a - b), 0.0) / k;\n  return min(a, b) -  h * h * k * (1.0 / 4.0);\n}\n\nfloat weightedPointToLineSegment(vec2 a, vec2 b, vec2 p) {\n  float l2 = (b.x-a.x)*(b.x-a.x) + (b.y-a.y)*(b.y-a.y);\n  float t = max(0.0, min(1.0, dot(p - a, b - a) / l2));\n  vec2 projection = a + t * (b - a);\n  return distance(p, projection) + smin(t, 1.0-t)/4.0; \n}\n\nfloat segment0(vec2 uv) {\n    return weightedPointToLineSegment(vec2(0,0), vec2(1,0), uv);\n}\nfloat segment1(vec2 uv) {\n    return weightedPointToLineSegment(vec2(0,1), vec2(1,1), uv);\n}\nfloat segment2(vec2 uv) {\n    return weightedPointToLineSegment(vec2(0,2), vec2(1,2), uv);\n}\nfloat segment3(vec2 uv) {\n    return weightedPointToLineSegment(vec2(0,0), vec2(0,1), uv);\n}\nfloat segment4(vec2 uv) {\n    return weightedPointToLineSegment(vec2(0,1), vec2(0,2), uv);\n}\nfloat segment5(vec2 uv) {\n    return weightedPointToLineSegment(vec2(1,0), vec2(1,1), uv);\n}\nfloat segment6(vec2 uv) {\n    return weightedPointToLineSegment(vec2(1,1), vec2(1,2), uv);\n}\nfloat segment7(vec2 uv) {\n    return weightedPointToLineSegment(vec2(0,0), vec2(0,2), uv);\n}\nfloat segment8(vec2 uv) {\n    return weightedPointToLineSegment(vec2(1,0), vec2(1,2), uv);\n}\n\nfloat zero(vec2 uv) {\n    return smin(smin(smin(segment0(uv),segment2(uv)),smin(segment3(uv),segment4(uv))),smin(segment5(uv),segment6(uv)));\n}\n\nfloat one(vec2 uv) {\n    return smin(segment3(uv),segment4(uv));\n}\n\nfloat two(vec2 uv) {\n    return smin(smin(smin(segment0(uv),segment1(uv)),smin(segment2(uv),segment3(uv))),segment6(uv));\n}\n\nfloat three(vec2 uv) {\n    return smin(smin(smin(segment0(uv),segment1(uv)),smin(segment2(uv),segment6(uv))),segment5(uv));\n}\n\nfloat four(vec2 uv) {\n    return smin(smin(segment1(uv),segment4(uv)),smin(segment5(uv),segment6(uv)));\n}\n\nfloat five(vec2 uv) {\n    return smin(smin(smin(segment0(uv),segment1(uv)),smin(segment2(uv),segment4(uv))),segment5(uv));\n}\n\nfloat six(vec2 uv) {\n    return smin(smin(smin(segment0(uv),segment1(uv)),smin(segment2(uv),segment4(uv))),smin(segment5(uv),segment3(uv)));\n}\n\nfloat seven(vec2 uv) {\n    return smin(smin(segment2(uv),segment5(uv)),segment6(uv));\n}\n\nfloat eight(vec2 uv) {\n    return smin(smin(smin(segment0(uv),segment1(uv)),smin(segment2(uv),segment4(uv))),smin(smin(segment6(uv),segment3(uv)), segment5(uv)));\n}\n\nfloat nine(vec2 uv) {\n    return smin(smin(segment1(uv),segment2(uv)),smin(smin(segment6(uv),segment5(uv)), segment4(uv)));\n}\n\nfloat colon(vec2 uv) {\n    return min(distance(vec2(0,0.25), uv), distance(vec2(0,1.75), uv));\n}\n\nfloat dist(int num, vec2 uv) {\n    if (num == 1) {\n        return one(uv);\n    } else if (num == 2) {\n        return two(uv);\n    } else if (num == 3) {\n        return three(uv);\n    } else if (num == 4) {\n        return four(uv);\n    } else if (num == 5) {\n        return five(uv);\n    } else if (num == 6) {\n        return six(uv);\n    } else if (num == 7) {\n        return seven(uv);\n    } else if (num == 8) {\n        return eight(uv);\n    } else if (num == 9) {\n        return nine(uv);\n    } else {\n        return zero(uv);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*7.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv += vec2(-1, -1.2);\n\n    float seconds = iDate.w;\n    float minutes = seconds / 60.0;\n    float hours = minutes / 60.0;\n    float second = floor(mod(seconds, 60.0));\n    float minute = floor(mod(minutes, 60.0));\n    float hour = floor(mod(hours, 12.0));\n    \n    int sec1s = int(mod(second,10.0));\n    int sec10s = int(second/10.0);\n    int min1s = int(mod(minute,10.0));\n    int min10s = int(minute/10.0);\n    int hour1s = int(mod(hour,10.0));\n    int hour10s = int(hour/10.0);\n    \n    bool am = hours-1.0 < 12.0;\n    \n    vec3 col = vec3(1);\n        \n    float yoffset = 0.0;\n    \n    float mindist = 999.0;\n    \n    if (hour == 0.0){\n        mindist = min(mindist, dist(1, uv - vec2(0)));\n        yoffset += 1.0;\n        mindist = min(mindist, dist(2, uv - vec2(yoffset, 0)));\n        yoffset += 2.0;\n    } else {\n        if (hour10s != 0) {\n            mindist = min(mindist, dist(hour10s, uv - vec2(yoffset, 0)));\n            if (hour10s == 1) {\n                yoffset += 1.0;\n            } else {\n                yoffset += 2.0;\n            }\n        }\n        mindist = min(mindist, dist(hour1s, uv - vec2(yoffset, 0)));\n        if (hour1s == 1) {\n            yoffset += 1.0;\n        } else {\n            yoffset += 2.0;\n        }\n    }\n    \n    mindist = min(mindist, colon(uv - vec2(yoffset, 0)));\n    yoffset += 1.0;\n    \n    mindist = min(mindist, dist(min10s, uv - vec2(yoffset, 0)));\n    if (min10s == 1) {\n        yoffset += 1.0;\n    } else {\n        yoffset += 2.0;\n    }\n    mindist = min(mindist, dist(min1s, uv - vec2(yoffset, 0)));\n    if (min1s == 1) {\n        yoffset += 1.0;\n    } else {\n        yoffset += 2.0;\n    }\n            \n    mindist = min(mindist, dist(sec10s, (uv - vec2(yoffset, 0))/0.75));\n    if (sec10s == 1) {\n        yoffset += 1.0*0.75;\n    } else {\n        yoffset += 2.0*0.75;\n    }\n    mindist = min(mindist, dist(sec1s, (uv - vec2(yoffset, 0))/0.75));\n    \n    //test sphere\n    //mindist = min(mindist, -sqrt(1.0-pow(distance(vec2(3.0, 4.0),uv),2.0)));\n\n    col = (vec3(mindist) + texture(iChannel0, fragCoord/iResolution.xy).x*12.0)/13.0;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}