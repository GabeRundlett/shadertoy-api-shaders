{
    "Shader": {
        "info": {
            "date": "1533020568",
            "description": "The negative Mandelbrot set, also known as the Negabrot set. The negative Mandelbrot set is obtained by raising z to the power of -2 instead of 2 on every iteration. Click and drag the mouse to explore its Julia sets.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltcczB",
            "likes": 5,
            "name": "Negative Mandelbrot & Julia",
            "published": 3,
            "tags": [
                "fractal",
                "julia",
                "mandelbrot",
                "negabrot"
            ],
            "usePreview": 0,
            "username": "FutureFractal",
            "viewed": 323
        },
        "renderpass": [
            {
                "code": "// Negabrot viewer\n// by FutureFractal\n\n\nconst float M_PI = 3.14159265358979323846264338327950288;\n\nconst int MAX_ITER = 506;\n\n\n#if __VERSION__ < 300\nbool isnan(float x)\n{\n    // The builtin isnan() function is only supported in WebGL 2.0 or higher.\n    // If it's unavailable, use this as a fallback.\n    // source: https://stackoverflow.com/questions/11810158\n    return (x < 0.0 || 0.0 < x || x == 0.0) ? false : true;\n}\n#endif\n\n\nvec2 cmplx_mul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y,\n                a.y*b.x + a.x*b.y);\n}\n\nvec2 cmplx_pow(vec2 z, float p)\n{\n    // Adapted from Microsoft's reference source for .NET's Complex type\n    // https://referencesource.microsoft.com/#System.Numerics/System/Numerics/Complex.cs\n    \n    if (p == 0.0) {\n        return vec2(1.0, 0.0);\n    }\n    if (z == vec2(0.0, 0.0)) {\n        return z;\n    }\n    \n    float rho = length(z);\n    float theta = atan(z.y, z.x);\n    float newRho = p * theta;\n    \n    float t = pow(rho, p);\n    \n    return vec2(t * cos(newRho), t * sin(newRho));\n}\n\nvec2 cmplx_pow2(vec2 z)\n{\n    return vec2((z.x*z.x) - (z.y*z.y), \n                2.0 * z.x * z.y);\n}\n\nvec2 cmplx_recipr(vec2 z)\n{\n    // Also adapted from Microsoft's reference source\n    \n    // Smith's formula\n    float c = z.x;\n    float d = z.y;\n  \tif (c - d > 0.0) {\n        float doc = d / c;\n        return vec2(1.0 / (c + d*doc), -doc / (c + d*doc));\n    } else {\n        float cod = c / d;\n        return vec2(cod / (d + c*cod), -1.0 / (d + c*cod));\n    }\n}\n\nvec2 cmplx_pow2_recipr(vec2 z)\n{\n    // Compute 1/(z^2).\n    // First, try this with the optimized cmplx_pow2 and cmplx_recipr functions.\n    // Unfortunately, for some values these functions over/underflow and generate NaNs.\n    // When that happens, fall back on cmplx_pow, which is more accurate but much slower.\n \tvec2 zz = cmplx_recipr(cmplx_pow2(z));\n    return (!isnan(zz.x) && !isnan(zz.y)) ? zz : cmplx_pow(z, -2.0);\n}\n\n\nvec2 scaleFragCoord(vec2 fragCoord, vec2 resolution, float scale)\n{\n    if (resolution.x > resolution.y) {\n        return vec2(\n            scale * ((4.0 * fragCoord.x / resolution.x) - 2.0),\n            scale * (4.0 * (fragCoord.y - (resolution.y / 2.0)) / resolution.x)\n        );\n    } else {\n        return vec2(\n            scale * (4.0 * (fragCoord.x - (resolution.x / 2.0)) / resolution.y),\n            scale * ((4.0 * fragCoord.y / resolution.y) - 2.0)\n        );\n    }\n}\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    // source: https://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 hsv2rgb(float h, float s, float v)\n{\n \treturn vec4(hsv2rgb(vec3(h, s, v)), 1.0);\n}\n\nvec4 reimannColor(vec2 z)\n{\n    // Compute a color based on the point's last value's distance from the origin.\n    // Specifically, its position between 0 and infinity on the Reimann sphere.\n\t// Maps [0, 1, inf] on the Reimann sphere to real numbers [0, 0.5, 1].\n    float R = atan(length(z)) * (2.0 / M_PI);\n    \n    // slowly cycle the colors:\n    float anim = iTime * (1.0 / 50.0);\n    \n    float h = (1.0 - R) + anim;\n    float s = 1.0;\n    float v = 1.0;\n    return hsv2rgb(h, s, v);\n}\n\n\nvec4 drawNegaJulia(vec2 c, vec2 j)\n{\n    vec2 z = c;\n    for (int i = 0; i < MAX_ITER; ++i)\n    {\n//\t\tz = cmplx_pow(z, -2.0) + j;\n\t    z = cmplx_pow2_recipr(z) + j;\n    }\n    return reimannColor(z);\n}\n\nvec4 drawNegabrot(vec2 c)\n{\n    vec2 z = c;\n    for (int i = 0; i < MAX_ITER; ++i)\n    {\n//\t\tz = cmplx_pow(z, -2.0) + c;\n        z = cmplx_pow2_recipr(z) + c;\n    }\n    return reimannColor(z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float scale = 1.2;\n    \n    vec2 c = scaleFragCoord(fragCoord.xy, iResolution.xy, scale);\n    \n    if (iMouse.z > 0.0) {\n        vec2 j = scaleFragCoord(iMouse.xy, iResolution.xy, scale);\n    \tfragColor = drawNegaJulia(c, j);\n    } else {\n        fragColor = drawNegabrot(c);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}