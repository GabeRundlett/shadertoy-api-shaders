{
    "Shader": {
        "info": {
            "date": "1577652333",
            "description": "Second iteration of this previous shader https://www.shadertoy.com/view/Wsd3R4",
            "flags": 32,
            "hasliked": 0,
            "id": "wldGWj",
            "likes": 14,
            "name": "Precious marble 2.0",
            "published": 3,
            "tags": [
                "fractal",
                "mandelbulb",
                "dof",
                "volumetric",
                "bloom"
            ],
            "usePreview": 0,
            "username": "loicvdb",
            "viewed": 671
        },
        "renderpass": [
            {
                "code": "vec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 bloom(float scale, float threshold, vec2 fragCoord){\n    float logScale = log2(scale)+1.0;\n    \n    vec3 bloom = vec3(0);\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++)\n            bloom += textureLod(iChannel0, (fragCoord+vec2(x, y) * scale)/iResolution.xy, logScale).rgb;\n    \n    return max(bloom/9.0 - vec3(threshold), vec3(0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    vec3 bloomSum = bloom(.25 * iResolution.y, .6, fragCoord) * .3\n        \t\t  + bloom(.1 * iResolution.y, .9, fragCoord) * .3;\n    \n    fragColor = vec4(ACESFilm(col + bloomSum), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define Pi 3.14159265359\n\n\n//uncomment for a high quality version\n//#define HQ\n\n#ifdef HQ\n\n#define MaxCameraOpacity .7\n#define MaxShadowOpacity .9\n\n#define CameraRayStepSize .015\n#define ShadowRayStepSize .03\n\n#else\n\n#define MaxCameraOpacity .5\n#define MaxShadowOpacity .85\n\n#define CameraRayStepSize .03\n#define ShadowRayStepSize .06\n\n#endif\n\n#define Epsilon .001\n\n#define LightBounces 2\n\nvec3 LightDir = normalize(vec3(-1, .0, .0));\nvec3 LightColor = vec3(.5, .5, .5) * 40.0;\n\nvec3 CamDir = normalize(vec3(-1, 0, .1));\nvec3 CamPos = vec3(2.5, 0, -.2);\nfloat FocalLength = .9;\n\nint BackgroundIndex = 0;\nfloat BackgroundIntensity;\n   \nfloat Density = 10.0;\nfloat Anisotropy = .0;\n\nvec3 GoldAlbedo = vec3(1.000, 0.766, 0.336);\n\nfloat Ior = 1.7;\n\nfloat Power = 8.0;\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 814.1321914114157;\n  return fract(NoiseSeed);\n}\n\nfloat maxV(vec3 v){return max(max(v.x, v.y), v.z);}\n\nfloat distanceEstimation(vec3 pos) {\n    \n    pos *= 1.9;\n    \n    float r = length(pos);\n    vec3 z = pos;\n    vec3 c = pos;\n\tfloat dr = 1.0, theta, phi;\n\tfor (int i = 0; i < 4; i++) {\n\t\tr = length(z);\n\t\tif (r>1.2) break;\n\t\ttheta = acos(z.z/r);\n\t\tphi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\ttheta *= Power;\n\t\tphi *= Power;\n\t\tz = pow(r,Power)*vec3(sin(theta)*cos(phi),\n                              sin(phi)*sin(theta),\n                              cos(theta)) + c;\n\t}\n\treturn (0.5*log(r)*r/dr)/1.9;\n}\n\nfloat henyeyGreenstein(vec3 dir){\n\tfloat cosTheta = dot(dir, -LightDir);\n \treturn Pi/4.0 * (1.0-Anisotropy*Anisotropy) / pow(1.0 + Anisotropy*Anisotropy - 2.0*Anisotropy*cosTheta, 3.0/2.0);\n}\n\n\nvec3 background(vec3 dir){\n    vec3 col = (BackgroundIndex == 1) \t? texture(iChannel0, dir.xzy).rgb\n        \t\t\t\t\t\t\t\t: texture(iChannel1, dir.xzy).rgb;\n    col *= BackgroundIntensity;\n    return (dot(dir, -LightDir) > .997) ? LightColor\n                                        : col*col + col;\n}\n\nvec3 backgroundBlurred(vec3 dir){\n    return (BackgroundIndex == 1) \t? texture(iChannel0, dir.xzy, 8.).rgb*BackgroundIntensity\n        \t\t\t\t\t\t\t: texture(iChannel1, dir.xzy, 8.).rgb*BackgroundIntensity;\n}\n\nvec3 rotateZ(vec3 v, float phi){\n    return vec3(cos(phi)*v.x - sin(phi)*v.y, cos(phi)*v.y + sin(phi)*v.x, v.z);\n}\n\nfloat distThorus(vec3 pos, float angle){\n    pos = rotateZ(pos, angle);\n    pos = rotateZ(pos.zyx, .75).zyx;\n    return length( vec2(length(pos.xz)-1.02, pos.y) )-.015;\n}\n\nfloat distThorii(vec3 pos){\n    \n    float d = 10.0;\n    for(int i = 0; i < 8; i++){\n        d = min(distThorus(pos, float(i)*Pi/4.0), d);\n    }\n    \n    return d;\n}\n\nbool thoriiIntersect(inout vec3 pos, vec3 dir, out vec3 normal){\n    float dist;\n    while(length(pos) < 1.2 || dot(dir, pos) < 0.0){\n        dist = distThorii(pos);\n        if(dist < Epsilon) {\n            normal = normalize(vec3(distThorii(pos + vec3(Epsilon, 0, 0)),\n\t\t\t\t\t\t\t\t\tdistThorii(pos + vec3(0, Epsilon, 0)),\n\t\t\t\t\t\t\t\t\tdistThorii(pos + vec3(0, 0, Epsilon)))\n\t\t\t\t\t\t\t - vec3(distThorii(pos - vec3(Epsilon, 0, 0)),\n\t\t\t\t\t\t\t\t\tdistThorii(pos - vec3(0, Epsilon, 0)),\n\t\t\t\t\t\t\t\t\tdistThorii(pos - vec3(0, 0, Epsilon))));\n            return true;\n        }\n        pos += dir * dist;\n    }\n    return false;\n}\n\nbool sphereIntersect(inout vec3 pos, in vec3 dir, out vec3 normal){\n    float d = length(pos);\n    if(dot(pos, dir) >= 0.0) return false;\n    float alpha = acos(dot(dir, normalize(-pos)));\n    float h = d * sin(alpha);\n    if(h >= 1.0) return false;\n    pos += dir * (sqrt(d*d - h*h) - sqrt(1.0 - h*h));\n    normal = pos;\n    return true;\n}\n\nfloat distanceInSphere(vec3 pos, vec3 dir){\n    float d = length(pos);\n    float alpha = acos(dot(dir, normalize(-pos)));\n    float h = d * sin(alpha);\n    if(h >= 1.0) return 0.0;\n    return 2.0 * sqrt(1.0 - h*h);\n}\n\nvec3 directLight(vec3 pos){\n    \n    vec3 absorption = vec3(1.0);\n    \n    for(int i = 0; i < 128; i++){\n        float dist = distanceEstimation(pos);\n        pos -= LightDir * max(dist, ShadowRayStepSize);\n        if(dist < ShadowRayStepSize) {\n            float abStep = ShadowRayStepSize * randomFloat();\n            pos -= LightDir * (abStep-ShadowRayStepSize);\n            if(dist < 0.0){\n                float absorbance = exp(-Density*abStep);\n                absorption *= absorbance;\n                if(maxV(absorption) < 1.0-MaxShadowOpacity) break;\n            }\n        }\n        \n        if(length(pos) > 1.0) break;\n    }\n    return LightColor * max((absorption+MaxShadowOpacity-1.0) / MaxShadowOpacity, vec3(0));\n}\n\nvec3 ambientLight(vec3 pos){\n    float absorbance = exp(Density*min(max(distanceEstimation(pos), -.02), -.01) * 3.);\n    float occlusion = distanceEstimation(pos *1.5) * 30.;\n    return backgroundBlurred(normalize(pos)) * absorbance * occlusion;\n}\n\nvec3 lightReceived(vec3 pos){\n    return ambientLight(pos) + directLight(pos);\n}\n\nvec3 marchRay(vec3 pos, vec3 dir, out vec3 absorption){\n    \n    float hg = henyeyGreenstein(dir);\n    \n    vec3 outColor = vec3(0.0);\n    absorption = vec3(1.0);\n    \n    for(int i = 0; i < 128; i++){\n        float dist = distanceEstimation(pos);\n        pos += dir * max(dist, CameraRayStepSize);\n        if(dist < CameraRayStepSize && length(pos) < 1.) {\n            float abStep = CameraRayStepSize * randomFloat();\n            pos += dir * (abStep-CameraRayStepSize);\n            if(dist < 0.0){\n                \n                float absorbance = exp(-Density*abStep);\n                float transmittance = 1.0-absorbance;\n                \n                vec3 volumeColor = clamp(1.0-pos*2., vec3(0.), vec3(1.));\n                \n                outColor += hg * absorption * transmittance * volumeColor * lightReceived(pos);\n                absorption *= absorbance;\n                if(maxV(absorption) < 1.0-MaxCameraOpacity) break;\n            }\n        }\n        \n        if(length(pos) > 1.0) break;\n    }\n    \n    absorption = max((absorption+MaxCameraOpacity-1.0) / MaxCameraOpacity, vec3(0));\n    return outColor;\n}\n\nfloat fresnel(vec3 dir, vec3 normal, float ior) {\n  float cosi = dot(dir, normal);\n  float etai = 1.0;\n  float etat = ior;\n  if (cosi > 0.0) {\n    float tmp = etai;\n    etai = etat;\n    etat = tmp;\n  }\n    \n  // Compute sini using Snell's law\n  float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));\n    \n  // Total internal reflection\n  if (sint >= 1.0) return 1.0;\n    \n  float cost = sqrt(max(0.0, 1.0 - sint * sint));\n  cosi = abs(cosi);\n  float sqrtRs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n  float sqrtRp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n  return (sqrtRs * sqrtRs + sqrtRp * sqrtRp) / 2.0;\n}\n\nvec4 colorAndDepth(vec3 pos, vec3 dir){\n    \n    vec3 color = vec3(0.0);\n    vec3 absorption = vec3(1.0);\n    float depth = -1.0;\n    \n    for(int i = 0; i < LightBounces; i++){\n        \n        vec3 sphereNormal, hitSpherePos = pos;\n        bool hitSphere = sphereIntersect(hitSpherePos, dir, sphereNormal);\n        float dSphere = length(pos - hitSpherePos);\n            \n        vec3 thoriiNormal, hitThoriiPos = pos;\n        bool hitThorii = thoriiIntersect(hitThoriiPos, dir, thoriiNormal);\n        float dThorii = length(pos - hitThoriiPos);\n        \n        if(hitSphere && (!hitThorii || dThorii > dSphere)){\n            \n            pos = hitSpherePos;\n            \n            if(depth == -1.0) depth = length(CamPos-pos);\n            \n            float fresnel = fresnel(dir, sphereNormal, Ior);\n            vec3 reflectDir = reflect(dir, sphereNormal);\n            vec3 reflectColor;\n            hitThoriiPos = pos;\n            if(thoriiIntersect(hitThoriiPos, reflectDir, thoriiNormal))\n                reflectColor = background(reflect(reflectDir, thoriiNormal)) * GoldAlbedo;\n            else \n                reflectColor = background(reflectDir);\n\n            //first refraction\n            dir = refract(dir, sphereNormal, 1.0/Ior);\n           \n            vec3 newAbsorption;\n            vec3 rayMarchColor = marchRay(pos, dir, newAbsorption);\n            \n            color += absorption * (fresnel*reflectColor + (1.0-fresnel) * rayMarchColor);\n            \n            //second refraction\n            pos += distanceInSphere(pos, dir) * dir;\n            vec3 refractDir = refract(dir, -pos, Ior);\n            \n            if(refractDir != vec3(0)) dir = refractDir;\n                \n            absorption *= (1.0-fresnel) * newAbsorption;\n           \n        } else if(hitThorii){\n            \n            dir = reflect(dir, thoriiNormal);\n            if(depth == -1.0) depth = length(CamPos-hitThoriiPos);\n            pos = hitThoriiPos + thoriiNormal * Epsilon;\n            \n            absorption *= GoldAlbedo;\n        } else {\n    \t\tif(depth == -1.0) depth = 1000.0;\n            break;\n        }\n        \n        if(dir == vec3(0.0)) return vec4(color, depth);\n    }\n    \n    return vec4(color + absorption * background(dir), depth);\n}\n \nvec4 projectRay(vec2 posOnScreen){\n    \n\tvec3 camX = vec3(-CamDir.y, CamDir.x, 0);\n\tvec3 camY = cross(camX, CamDir);\n\tvec3 sensorX = camX * (posOnScreen.x/length(camX));\n\tvec3 sensorY = camY * (posOnScreen.y/length(camY));\n\tvec3 centerSensor = CamPos - CamDir * FocalLength;\n\tvec3 posOnSensor = centerSensor + sensorX + sensorY;\n\tvec3 newDir = normalize(CamPos - posOnSensor);\n    \n\treturn colorAndDepth(CamPos, newDir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    NoiseSeed = iTime + fragCoord.y * .02986546543 + fragCoord.x;\n    \n    CamDir = rotateZ(CamDir, -iTime/3.0 + sin(iTime*2.0) * .025);\n    CamDir = rotateZ(CamDir.xzy, sin(iTime*3.0) * .007).xzy;\n    CamPos = rotateZ(CamPos, -iTime/3.0);\n    \n    FocalLength *= 1.0 + pow(abs(cos(iTime/2.5)), 10.0)*.2;\n    \n    LightDir = rotateZ(LightDir, iTime/3.0);\n    LightDir = rotateZ(LightDir.xzy, .75).xzy;\n    \n    BackgroundIntensity = sin(iTime/3.0) * 1.5;\n    \n    if(BackgroundIntensity < 0.0){\n        BackgroundIntensity = -BackgroundIntensity;\n        BackgroundIndex = 1;\n    }\n    \t\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy/2.0)/iResolution.y;\n    fragColor = projectRay(uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//first DoF pass\n\n#define Aperture .04\n#define DoFClamping .35\n#define DoFSamples 32\n\n#define dir normalize(vec2(1.0, 1.0))\n\nfloat FocalDistance = 1.5;\nfloat FocalLength = .9;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    FocalDistance *= 1.0 + sin(pow(abs(sin(iTime/2.0)), 30.0) * 3.0) *.5;\n    FocalLength *= 1.0 + pow(abs(cos(iTime/2.5)), 10.0)*.2;\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture*FocalLength)/iResolution.xy);\n        dr = min(abs(p.a-FocalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*Aperture*FocalLength + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//second DoF pass\n\n#define Aperture .04\n#define DoFClamping .35\n#define DoFSamples 32\n\n#define dir normalize(vec2(1.0, -1.0))\n\nfloat FocalDistance = 1.5;\nfloat FocalLength = .9;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    FocalDistance *= 1.0 + sin(pow(abs(sin(iTime/2.0)), 30.0) * 3.0) *.5;\n    FocalLength *= 1.0 + pow(abs(cos(iTime/2.5)), 10.0)*.2;\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture*FocalLength)/iResolution.xy);\n        dr = min(abs(p.a-FocalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*Aperture*FocalLength + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}