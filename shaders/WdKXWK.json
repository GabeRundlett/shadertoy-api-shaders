{
    "Shader": {
        "info": {
            "date": "1575036555",
            "description": "Click anywhere to regenerate. Made for [url=https://boardgamegeek.com/boardgame/178900/codenames]Codenames boardgame[/url]\n\nThis is my first ever shadertoy. :) yay!\n\nThings to work on (I need help):\n - Debugging on iOS",
            "flags": 0,
            "hasliked": 0,
            "id": "WdKXWK",
            "likes": 11,
            "name": "Random Codenames Spymaster Card",
            "published": 3,
            "tags": [
                "tool",
                "codenames"
            ],
            "usePreview": 0,
            "username": "Spaxe",
            "viewed": 1531
        },
        "renderpass": [
            {
                "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n////////////////////////////////////////////\n//\n// CODENAMES SPYMASTER CARD GENERATOR\n// MIT LICENSE @Xavier_Ho on Twitter\n// \n////////////////////////////////////////////\n\n/////////////////////////////////////////////////////////\n\nvec2 SEED = vec2(48.23423, 12.23432);\n\n// spymaster data\n//  0 - red\n//  1 - blue\n// -1 - assassin\n//  9 - neutral\nint data[25] = int[](\n    0, 0, 0, 0, 0,\n    0, 0, 0, 0, 1, \n    1, 1, 1, 1, 1, \n    1, 1, 9, 9, 9, \n    9, 9, 9, 9, -1);\n\n/////////////////////////////////////////////////////////\n\n// utility funcs ---------------------------------------\n\nvec3 rgb ( int r, int g, int b ) {\n  return vec3(r, g, b) * 0.00392156863;\n}\n\nmat2 rotate ( float a ) {\n  float r = radians(a);\n  float cosr = cos(r);\n  float sinr = sin(r);\n  return mat2(cosr, sinr,\n              -sinr, cosr);\n}\n\nvec2 rotateO ( vec2 uv, float a, vec2 O ) {\n  return rotate(a) * (uv - O) + O;\n}\n\n// https://github.com/carld/ray-tracer-glsl/blob/master/fragment.glsl\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rand2(vec2 co) {\n  return vec2(rand(co.xy), rand(co.yx));\n}\n\n// https://stackoverflow.com/questions/6S127503/shuffle-array-in-c\nvoid shuffle ( inout int[25] array )\n{\n  vec2 r = rand2(SEED);\n  int n = array.length();\n  int n1 = n - 1;\n   \n  for (int i = n1; i > 0; i--) \n  {\n    vec2 r1 = rand2(r);\n    int j = int(float(n1) * r1.x);\n    int t = array[j];\n    int s = array[i];\n    array[j] = s;\n    array[i] = t;\n    r = r1;\n  }\n}\n\n// distance funcs ------------------------------------\n\nfloat rect ( vec2 uv, float _w, float _h ) {\n  float w = _w * 0.5;\n  float h = _h * 0.5;\n  return\n    smoothstep(w + 0.001, w - 0.001, abs(uv.x-w)) *\n    smoothstep(h + 0.001, h - 0.001, abs(uv.y-h));\n}\n\nfloat circle ( vec2 uv, float r ) {\n  return smoothstep(r + 0.001, r - 0.001, distance(uv, vec2(0.0, 0.0)));\n}\n\nfloat rrect ( vec2 uv, float _w, float _h, float r ) {\n  float r2 = r * 2.0;\n  float w = _w - r2;\n  float h = _h - r2;\n  \n  return min( \n    rect(uv - vec2(r), w, h) +\n    rect(uv - vec2(r, 0.0), w, r2) +\n    rect(uv - vec2(r, h), w, r2) +\n    rect(uv - vec2(0.0, r), r2, h) +\n    rect(uv - vec2(w, r), r2, h) +\n    circle(uv - vec2(r), r) + \n    circle(uv - vec2(w + r, r), r) + \n    circle(uv - vec2(w + r, h + r), r) + \n    circle(uv - vec2(r, h + r), r),\n    1.0);   \n}\n\nfloat diam ( vec2 uv, float r ) {\n  return \n    smoothstep(r + 0.001, r - 0.001, abs(r - uv.x + uv.y)) *\n    smoothstep(r + 0.001, r - 0.001, abs(r - uv.x - uv.y));   \n}\n\n// compound shapes -------------------------------------\n\nfloat bgShape ( vec2 uv, float size, float r ) {\n  float inSize = 0.555555; \n  float cSize = 0.5 * (size - inSize);\n    \n  float leftC = max(\n    rect(uv - vec2(0.0, cSize), r, inSize) -\n    diam(uv - vec2(0.0, cSize), r) -\n    diam(uv - vec2(0.0, cSize + inSize), r),\n  0.0);\n    \n  float rightC = max(\n    rect(uv - vec2(size-r, cSize), r, inSize) -\n    diam(uv - vec2(size-r*2.0, cSize), r) -\n    diam(uv - vec2(size-r*2.0, cSize + inSize), r),\n  0.0);\n    \n  float topC = max(\n    rect(uv - vec2(cSize, size-r), inSize, r) -\n    diam(uv - vec2(cSize-r, size-r), r) -\n    diam(uv - vec2(cSize+inSize-r, size-r), r),\n  0.0);\n    \n  float bottomC = max(\n    rect(uv - vec2(cSize, 0.0), inSize, r) -\n    diam(uv - vec2(cSize-r, r), r) -\n    diam(uv - vec2(cSize+inSize-r, r), r),\n  0.0);\n    \n  return clamp( \n    rrect(uv, size, size, r) \n    - leftC - rightC - topC - bottomC,\n  0.0, 1.0);\n}\n\nfloat edgeLightSockets ( vec2 uv, float size, float w, float h ) {\n  float d = (size - h) * 0.5;\n  return \n    rect(uv - vec2(0, d), w, h) +\n    rect(uv - vec2(size-w, d), w, h) +\n    rect(uv - vec2(d, size-w), h, w) +\n    rect(uv - vec2(d, 0), h, w);\n}\n\nfloat edgeLights ( vec2 uv, float size, float w, float h, float o ) {\n  float d = (size - h) * 0.5;\n  return \n    rect(uv - vec2(o, d), w, h) +\n    rect(uv - vec2(size-w-o, d), w, h) +\n    rect(uv - vec2(d, size-w-o), h, w) +\n    rect(uv - vec2(d, o), h, w);\n}\n\nfloat edgeColorFlood ( vec2 uv, float size, float w, float h, float o ) {\n  float d = (size - h) * 0.5;\n  vec2 left = uv - vec2(o, d);\n  vec2 right = uv - vec2(size-w-o, d);\n  vec2 top = uv - vec2(d, size-w-o);\n  vec2 bottom = uv - vec2(d, o);\n    \n  return \n    smoothstep(h, 0.0, distance(left, vec2(w*2.0, h*0.5))) +\n    smoothstep(h, 0.0, distance(right, vec2(-w, h*0.5))) +\n    smoothstep(h, 0.0, distance(top, vec2(h*0.5, -w))) +\n    smoothstep(h, 0.0, distance(bottom, vec2(h*0.5, w*2.0)));\n}\n\nfloat edgeWhiteGlow ( vec2 uv, float size, float w, float h, float o ) {\n  float d = (size - h) * 0.5;\n  vec2 left = uv - vec2(o, d);\n  vec2 right = uv - vec2(size-w-o, d);\n  vec2 top = uv - vec2(d, size-w-o);\n  vec2 bottom = uv - vec2(d, o);\n    \n  return \n    rect(left, w, h) * smoothstep(h * 0.333, 0.0, distance(left, vec2(o, h*0.5))) +\n    rect(right, w, h) * smoothstep(h * 0.333, 0.0, distance(right, vec2(o, h*0.5))) +\n    rect(top, h, w) * smoothstep(h * 0.333, 0.0, distance(top, vec2(h*0.5, o))) +\n    rect(bottom, h, w) * smoothstep(h * 0.333, 0.0, distance(bottom, vec2(h*0.5, o)));\n}\n\n// elements ------------------------------------------------------------\n\nvec4 diamCell ( vec2 uv, float size, vec4 c, vec4 light ) {\n   vec4 outColor = c;\n    \n   // glow\n   outColor = mix(outColor, mix(c, light, 0.75), smoothstep(size, 0.0, distance(uv, vec2(size))));\n    \n   // diamond edge\n   outColor = mix(outColor, mix(c, light, 0.75), rrect(rotateO(uv - vec2(size*0.9, 0.0), 45.0, vec2(size)), size*0.75, size*0.75, size*0.1));\n     \n   // diamond fill\n   float matte = rrect(rotateO(uv - vec2(size, 0.0), 45.0, vec2(size)), size*0.61, size*0.61, size*0.08);\n   vec4 innerGlow = mix(mix(vec4(0.0), c, 0.8), mix(light, c, 0.75), smoothstep(size * 0.5, 0.0, distance(uv, vec2(size))));\n   outColor = mix(outColor, innerGlow, matte);\n   return outColor;\n}\n\nvec4 circleCell ( vec2 uv, float size, vec4 c, vec4 light ) {\n   vec4 outColor = c;\n    \n   // glow\n   outColor = mix(outColor, mix(c, light, 0.75), smoothstep(size, 0.0, distance(uv, vec2(size))));\n    \n   // circle edge\n   outColor = mix(outColor, mix(c, light, 0.75), circle(uv - vec2(size), size*0.45));\n    \n   // circle fill\n   float matte = circle(uv - vec2(size), size*0.37);\n   vec4 innerGlow = mix(mix(vec4(0.0), c, 0.8), mix(light, c, 0.75), smoothstep(size * 0.5, 0.0, distance(uv, vec2(size))));\n   outColor = mix(outColor, innerGlow, matte);\n   return outColor;\n}\n\nvec4 xCell ( vec2 uv, float size, vec4 c, vec4 light ) {\n   vec4 outColor = c;\n   vec4 dark = mix(c, vec4(0.0), 0.8);\n   float xSize = size * 0.4;\n   float r = size * 0.1; // TODO: fix construction of cross\n   light = mix(vec4(0.9, 0.9, 1.0, 1.0), light, 0.25);\n    \n   vec2 lbUV = uv - vec2(size - xSize);\n   vec2 rtUV = uv - vec2(size + xSize);\n   vec2 ltUV = uv - vec2(size - xSize, size + xSize);\n   vec2 rbUV = uv - vec2(size + xSize, size - xSize);\n    \n   float xShape = min(\n     // cross en ds\n     circle(lbUV, r) +\n     circle(rtUV, r) + \n     circle(ltUV, r) +\n     circle(rbUV, r) +\n     // cross lines - compensated for AA\n     rect(rotate(-45.0) * (uv - vec2(size*0.5+r*1.5, size*0.51)), size+r*1.25, r*2.0) +\n     rect(rotate( 45.0) * (uv - vec2(size*0.51, size+r*3.5)), size+r*1.25, r*2.0),\n   1.0);\n    \n   // glow (faking the shape)\n   outColor = mix(outColor, light, smoothstep(r*2.75, 0.0, distance(lbUV, vec2(0.0))));\n   outColor = mix(outColor, light, smoothstep(r*2.75, 0.0, distance(rtUV, vec2(0.0))));\n   outColor = mix(outColor, light, smoothstep(r*2.75, 0.0, distance(ltUV, vec2(0.0))));\n   outColor = mix(outColor, light, smoothstep(r*2.75, 0.0, distance(rbUV, vec2(0.0))));\n   outColor = mix(outColor, light, smoothstep(r*2.75, 0.0, distance(lbUV - vec2(size*0.15), vec2(0.0))));\n   outColor = mix(outColor, light, smoothstep(r*2.75, 0.0, distance(rtUV + vec2(size*0.15), vec2(0.0))));\n   outColor = mix(outColor, light, smoothstep(r*2.75, 0.0, distance(ltUV + vec2(-size*0.15, size*0.15), vec2(0.0))));\n   outColor = mix(outColor, light, smoothstep(r*2.75, 0.0, distance(rbUV + vec2(size*0.15, -size*0.15), vec2(0.0))));\n   outColor = mix(outColor, light, smoothstep(r*5.0, 0.0, distance(vec2(size), uv)));\n    \n   // cross fill\n   outColor = mix(outColor, dark, xShape);\n   return outColor;\n}\n\n\n// entry ---------------------------------------------------------------\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ) {\n    \n  // interaction\n  SEED = iMouse.xy;\n  vec4 outColor;\n    \n  // center + aspect ratio ---------------------------------------------\n  float minScreen = min(iResolution.x, iResolution.y);\n  float maxScreen = max(iResolution.x, iResolution.y);\n    \n  vec2 uv = fragCoord.xy / minScreen;\n    \n  float offset = (maxScreen - minScreen) / maxScreen;\n \n  vec2 offsetUV, biasUV;\n  if (iResolution.x > iResolution.y) {\n    offsetUV = vec2(offset, 0.0);\n    biasUV = vec2(0.0, 0.05);\n  } else {\n    offsetUV = vec2(0.0, offset);\n    biasUV = vec2(0.05, 0.0);\n  }\n  uv -= offsetUV;\n    \n  // layering shapes with colours ---------------------------------------\n  vec4 bg = vec4(rgb(124, 112, 122), 1.0);\n  vec4 socketB = vec4(rgb(56 ,44, 46), 1.0);\n  vec4 socket = vec4(rgb(106, 98, 104), 1.0);\n  vec4 cardB = vec4(rgb(60, 55, 51), 1.0);\n  vec4 card = vec4(rgb(20, 22, 16), 1.0);\n    \n  vec4 neutral =  vec4(rgb(193, 195, 187), 1.0);\n  vec4 red =  vec4(rgb(169, 48, 39), 1.0);\n  vec4 blue =  vec4(rgb(16, 108, 184), 1.0);\n  vec4 assassin =  vec4(rgb(62, 64, 64), 1.0);\n  vec4 light =  vec4(rgb(185, 180, 180), 1.0);\n    \n  outColor = bg;\n  outColor = mix(outColor, socketB, bgShape(uv - biasUV , 0.9, 0.04));\n  outColor = mix(outColor, socket, bgShape(uv - vec2(0.005) - biasUV, 0.89, 0.04));\n    \n  // Starting player color on the border\n  float coinflip = step(rand(SEED), 0.5);\n  vec4 p1 = red;\n  if (coinflip < 0.5)\n    p1 = blue;\n    \n  outColor = mix(outColor, cardB, edgeLightSockets(uv - biasUV, 0.9, 0.04, 0.13));\n  outColor = mix(outColor, cardB, rrect(uv - vec2(0.06) - biasUV, 0.78, 0.78, 0.025));\n  outColor = mix(outColor, p1, edgeLights(uv - biasUV, 0.9, 0.025, 0.11, 0.01)); \n  outColor = mix(outColor, p1, edgeColorFlood(uv - biasUV, 0.9, 0.025, 0.11, 0.01)); \n  outColor = mix(outColor, light, edgeWhiteGlow(uv - biasUV, 0.9, 0.025, 0.11, 0.01)); \n    \n  // grid\n  outColor = mix(outColor, card, rrect(uv - vec2(0.07) - biasUV, 0.76, 0.76, 0.025));\n    \n  // 5 x 5 grid for Codenames\t\n  float block = 0.124;\n  float padding = 0.015;\n  vec2 gridUV = uv - vec2(0.11) - biasUV;\n    \n  if (coinflip < 0.5)\n    data[0] = 1;\n   \n  shuffle(data);\n    \n  for (int i = 0; i < 25; ++i) {\n    int x = int(floor(float(i) / 5.0));\n    int y = i % 5;\n    float dx = float(x) * block + float(x) * padding;\n    float dy = float(y) * block + float(y) * padding;\n    float matte = rrect(gridUV - vec2(dx, dy), block, block, 0.0125);\n      \n    if (data[i] == 0)\n      outColor = mix(outColor, diamCell(gridUV - vec2(dx, dy), block * 0.5, red, light), matte);\n    else if (data[i] == 1) \n      outColor = mix(outColor, circleCell(gridUV - vec2(dx, dy), block * 0.5, blue, light), matte);\n    else if (data[i] == -1)\n      outColor = mix(outColor, xCell(gridUV - vec2(dx, dy), block * 0.5, assassin, light), matte);\n    else\n      outColor = mix(outColor, neutral, matte);\n  }\n    \n  fragColor = outColor;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}