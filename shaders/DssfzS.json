{
    "Shader": {
        "info": {
            "date": "1691501209",
            "description": "direct + inverse    smoothfloor + controlable flat parts and overall slope\nmouse.x: flat part length ( spline part = 1-d )\nmouse.y: spline height ( overall slope = 1-h )",
            "flags": 0,
            "hasliked": 0,
            "id": "DssfzS",
            "likes": 9,
            "name": "inverse smoothfloor + slope",
            "published": 3,
            "tags": [
                "inverse",
                "loopless",
                "smoothfloor"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 169
        },
        "renderpass": [
            {
                "code": "// basic smoothfloor:         floor(x) + spline(fract(x))   ( spline=smoothstep )\n// with tunable flat parts d: floor(x) + spline( ( fract(x) - d/2. ) / (1.-d) )\n// + tunable general slope h: floor(x) + mix( fract(x), spline( ( fract(x) - d/2. ) / (1.-d) ) )\n// Here we want to compute the inverse x=invcurve(y) ( compulsory for the green dots ).\n//   but just set h=1 and/or d=0 to get the simpler curves\n\n#define curve(x) ( f = clamp( ( fract(x) - d/2. ) / (1.-d), 0.,1.),  \\\n                   floor(x) + mix( fract(x), f*f*(3.-2.*f), h )  )\n\n#define S(v) smoothstep( 1.5*s/R.y, 0., length(v) - 2.5*s/R.y )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float n = 20.,  // number of dots per cycle\n          s = 1.5;  // figure scaling\n    vec2  R = iResolution.xy,\n          U = s*( 2.*u - R ) / R.y, \n          M = iMouse.xy/R;\n    bool  m = length(iMouse.xy)>10.; // iMouse.z>0.;\n    \n    O *= 0.;                    // --- direct slope-spline ( red dots as guide ) ------------\n    // base smooth floor (no slope ) : https://www.desmos.com/calculator/srnrjrphqu\n    float t = iTime, d = m ? M.x : .6, h = m ? M.y : .8,     //  1.-d, h = width,height of spline part \n          x = round(U.x*n-t)/n +t/n, \n          f, y = curve(x); \n\n    O.r += S(U-vec2(x,y));                                   // draw red dots   \n   \n                                    // --- inverse spline cf https://www.shadertoy.com/view/clXyWj ------\n   float a,b,c,k,l,A,Y,R3=sqrt(3.); //                    with slope: https://www.shadertoy.com/view/DlByz1\n    y = U.y, Y = floor(y), y = fract(y);\n    if      ( y <    (1.-h)*d/2. ) O.r, x =     y/(1.-h);    // flat parts\n    else if ( y > 1.-(1.-h)*d/2. ) O.r, x = (y-h)/(1.-h);\n    else {                                                   // spline+slope part\n#if 0                                                        // old version ( no slope )\n     // solve spline: https://www.wolframalpha.com/input?i=solve%28y%3Dx*x*%283-2*x%29%2C+x%29\n        a = 1. -2.*y, b = 2.*sqrt(y*(1.-y)), /*l = pow(a*a+b*b,1./6.),*/ A = atan(b,a)/3.,\n     // x = ( -(l+1./l)*cos(A) + 2.*R3*l*sin(A)  + 2. ) / 4.;          // inverse spline\n        x = ( -cos(A) + R3*sin(A)  + 1. ) / 2.;                        // inverse spline\n#else                                                        //  new version ( slope )\n     // solve spline+kx: https://www.wolframalpha.com/input?i=solve%28y%3Dx*x*%283-2*x%29%2Bax%2C+x%29\n        y = ( y - (1.-h)/2.*d ) / (1.- (1.-h)*d );   \n        y /= h; \n        k = (1.-h) / h , \n        a = k+1.-2.*y, c = 2./3.*k+1., b = sqrt(c*c*c-a*a), /*l = sqrt(c),*/ A = atan(b,a)/3.,\n        x = sqrt(c)/2. * ( - cos(A) + R3*sin(A) )  + .5;\n#endif        \n        x = x*(1.-d) + d/2.;                                 // remaps for d\n    }\n             \n    y = curve(x);                 // --- verification (should be thick vertical bar) : still not perfect for big d\n    O.g += S(U-vec2(-s*1.1 ,y+Y))*.5;\n                            \n    x = round(x*n-t)/n +t/n,      // --- after inverse-map, draw dots from it\n    y = curve(x);\n    \n    O.g += S(U-vec2(x+Y,y+Y));                               // to check, draw green dot over red dots → yellow if of\n    O.g += S(U-vec2(-s ,y+Y));                               // green vertical dots\n    O.b += S(U.y-y-Y)  * .5;                                 // horizontal blue lines   \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}