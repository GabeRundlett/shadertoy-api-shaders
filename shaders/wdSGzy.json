{
    "Shader": {
        "info": {
            "date": "1549220379",
            "description": "quaternion testing ",
            "flags": 32,
            "hasliked": 0,
            "id": "wdSGzy",
            "likes": 4,
            "name": "testing quaternions",
            "published": 3,
            "tags": [
                "testing",
                "quaternion"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 444
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define PI 3.1415926535\n\n//quaternion functions from http://ai.stanford.edu/~acoates/quaternion.h\n#define qidentity vec4(0,0,0,1)\nvec4 qfromEuler(vec3 eu) {//yaw(x)-pitch(y)-roll(z)\n    vec3 sn = sin(eu.yxz*.5),\n        cs = cos(eu.yxz*.5);\n    return vec4(cs.z*cs.y*sn.x-sn.z*sn.y*cs.x,\n                cs.z*sn.y*cs.x+sn.z*cs.y*sn.x,\n                sn.z*cs.y*cs.x-cs.z*sn.y*sn.x,\n                cs.z*cs.y*cs.x+sn.z*sn.y*sn.x);\n}\nvec4 qconjugate(vec4 q) {\n \treturn vec4(-q.xyz,q.w);   \n}\nvec4 qmult(vec4 a, vec4 b) {\n    /*vec4 x = a.yzxw*b.zxyw,\n        y = a.zxyx*b.yzxx,\n        z = a.xyzy*b.wwwy,\n        w = a.wwwz*b.xyzz;\n    z.w *= -1.;\n    w.w *= -1.;\n    return x-y+z+w;*/\n    return vec4(a.y*b.z-a.z*b.y+a.x*b.w+a.w*b.x,\n                a.z*b.x-a.x*b.z+a.y*b.w+a.w*b.y,\n                a.x*b.y-a.y*b.x+a.z*b.w+a.w*b.z,\n                a.w*b.w-a.x*b.x-a.y*b.y-a.z*b.z);\n}\nvec3 qrot(vec4 q, vec3 p) {\n    return (qmult(qmult(q,vec4(p,0)),qconjugate(q))).xyz;\n}\nmat3x3 qtoMatrix(vec4 q) {\n\treturn mat3x3(\n1.-2.*q.y*q.y-2.*q.z*q.z, 2.*q.x*q.y - 2.*q.z*q.w, 2.*q.x*q.z + 2.*q.y*q.w,\n2.*q.x*q.y + 2.*q.z*q.w, 1.-2.*q.x*q.x-2.*q.z*q.z, 2.*q.y*q.z - 2.*q.x*q.w,\n2.*q.x*q.z - 2.*q.y*q.w, 2.*q.y*q.z + 2.*q.x*q.w, 1.-2.*q.x*q.x-2.*q.y*q.y);\n}\nvec3 qtoEuler(vec4 q) {\n\tvec4 s = q*q;\n    vec3 eu;\n    eu.y = asin(2.*(q.w*q.y-q.x*q.z));\n    if (PI*.5-abs(eu.y) > 1e-6) {\n        eu.z = atan(2.*(q.x*q.y+q.w*q.z),s.x-s.y-s.z+s.w);\n        eu.x = atan(2.*(q.w*q.x+q.y*q.z),s.w-s.x-s.y+s.z);\n    } else {\n    \teu.z = atan(2.*q.y*q.z-2.*q.x*q.z,2.*q.x*q.z+2.*q.y*q.z);\n        eu.x = 0.;\n        if (eu.y < 0.) eu.z = PI-eu.z;\n    }\n    return eu.yxz;\n}\nvec4 qfromMatrix(vec3 right, vec3 up, vec3 forward) {\n    float rt = right.x+up.y+forward.z;\n    if (rt > 0.0) {\n    \tfloat s = sqrt(rt+1.0), s1 = 0.5/s;\n        return vec4((forward.y-up.z)*s1,(right.z-forward.x)*s1,(up.x-right.y)*s1,s*0.5);\n\t} else if (right.x > up.y && right.x > forward.z) {\n\t\tfloat s = sqrt(1.0+right.x-up.y-forward.z), s1 = 0.5/s;\n\t\treturn vec4(s*0.5,(right.y-up.x)*s1,(right.z-forward.x)*s1,(forward.y-up.z)*s1);\n\t} else if (up.y > forward.z) {\n\t\tfloat s = sqrt(1.0+up.y-right.x-forward.z), s1 = 0.5/s;\n\t\treturn vec4((right.y-up.x)*s1,s*0.5,(up.z+forward.y)*s1,(right.z-forward.x)*s1);\n\t} else {\n\t\tfloat s = sqrt(1.0+forward.z-right.x-up.y), s1 = 0.5/s;\n\t\treturn vec4((right.z-forward.x)*s1,(up.z+forward.y)*s1,s*0.5,(up.x-right.y)*s1);\n\t}\n}\n\nfloat triwave(float v) {\n    return v*2.-max(0.,v*4.-2.);\n}\n\nvec4 hash(vec4 a) {\n\treturn fract(abs(sin(a.ywxz*766.345)+cos(normalize(a)*4972.92855))*2048.97435+abs(a.wxyz)*.2735);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //quaternion checks to make sure everything works\n    //vec3 eu = vec3(iTime,0,0);\n    //vec3 p = normalize(vec3((fragCoord*2.-iResolution.xy)/iResolution.x,1.));\n    //fragColor = vec4(abs(qrot(qfromEuler(eu),p)),1);\n    //fragColor = vec4(length(eu-qtoEuler(qfromEuler(eu))));\n    //mat3x3 qmat = qtoMatrix(qfromEuler(eu)),\n    //    rmat = qtoMatrix(qfromMatrix(qmat[0],qmat[1],qmat[2])),\n    //    dmat = qmat-rmat;\n    //fragColor = vec4(abs(p*qmat),1);\n    //fragColor = vec4(length(dmat[0])+length(dmat[1])+length(dmat[2]));\n    //return;\n    \n    vec4 p = vec4((fragCoord*2.-iResolution.xy+hash(fragCoord.xyyx*vec4(1,1,1.3,1.3)+float(iFrame)*vec4(.0283,.0876,.0347,.0443)).xy*3.-1.5)/iResolution.x*(.01+pow(triwave(fract(iTime*.01)),1.8)*.8)+vec2(.05,.43),-.3,1.);\n    for (int j = 0; j < 32; j++) {\n        if (length(p) > 1e3) break;\n        p = qmult(p,p)+vec4(0.2,-0.4,0.5098,0.);\n    }\n    if (p.w == 0.) p.w = 1e-7;\n\tfragColor = mix(texture(iChannel0,fragCoord/iResolution.xy),\n                    vec4(pow(abs(log(length(p))*.05),1./2.)),\n                    //vec4(length(sin(p.xyz/p.w))*.6),\n                    //pow(sin(p.zxyw/p.w)*.5+.5,vec4(4.)),\n                    .3);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}