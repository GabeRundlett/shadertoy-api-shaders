{
    "Shader": {
        "info": {
            "date": "1682796204",
            "description": "from evvvvil's raymarching boilerplate",
            "flags": 0,
            "hasliked": 0,
            "id": "Dl33zX",
            "likes": 2,
            "name": "Wobbly Toroids",
            "published": 3,
            "tags": [
                "basic",
                "tutorial",
                "boilerplate",
                "workshop"
            ],
            "usePreview": 0,
            "username": "drliquidglitch",
            "viewed": 171
        },
        "renderpass": [
            {
                "code": "//GLOBAL VARIABLES\nfloat time;\n//PRIMITIVE FUNCTIONS\nfloat plane(vec3 p,vec3 r){p=min(p,r);return p.y;}\nfloat sphere(vec3 p,float r){return length(p)-r;}\nfloat torus(vec3 p,vec2 t ){\n    p.z += cos(p.y*.01*sin(iTime));\n    p.y += sin(p.x*.5*cos(iTime));\n    vec2 q=vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n//MAP / SCENE FUNCTION\nfloat map(vec3 p)\n{ \n  float mainBox=plane(p,vec3(1));\n  float leftSphere=sphere(p+vec3(0,0,3),1.);\n  float scene=max(mainBox,leftSphere);\n\n  for (float i=0.; i< 14.; i++){\n  \n      float rightTorus=torus(p-vec3(2.*sin(i),i-7.,i),vec2(i,0.5));\n      scene=min(scene,rightTorus);\n\n  }\n  return scene;\n}\n//RAY CAST / TRACE LOOP FUNCTION\nfloat raycast( vec3 ro, vec3 rd )\n{\n  float dist,res=0.;\n  for(int i=0;i<128;i++){ \n    dist=map(ro+rd*res); \n    if(dist<.0001||res>120.) break;\n    res+=dist;\n  }\n  if(res>120.) res=0.;\n  return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //UV.y from -.5 to .5 and UV.x from -.88 to .88 (aspect ratio broooh)\n  time=mod(iTime,62.82); //Modulo time to avoid sin glitch noise due to floating point precision\n  // CAMERA  \n  vec3 rayOrigin=vec3(cos(time*.2)+4.,5,sin(time*.2)+14.);\n  vec3 cameraForward=normalize(vec3(0)-rayOrigin);\n  vec3 cameraLeft=normalize(cross(cameraForward,vec3(0,1,0)));\n  vec3 cameraUp=normalize(cross(cameraLeft,cameraForward));\n  vec3 rayDirection=mat3(cameraLeft,cameraUp,cameraForward)*normalize(vec3(uv,.5)); \n  // LIGHT DIRECTION & BACKGROUND SETUP   \n  vec3 lightDirection=normalize(vec3(-.1,.4,-.3));  \n  vec3 backgroundColor=vec3(.5*uv.y,.25*sin(iTime),.1*cos(iTime))-length(uv)*.1;\n  vec3 color=backgroundColor;\n  // TRACE AND GET RESULT FOR THIS PIXEL\n  float result=raycast(rayOrigin,rayDirection);\n  // IF WE HIT SOMETHING THEN DO SOME LIGHTING  \n  if(result>0.){ \n    vec3 hitPos=rayOrigin+rayDirection*result; // GET POSITION OF WHERE WE HIT\n    vec2 e=vec2(.00035,-.00035); // e=ESPILON = OFFSET NUMBER FOR NORMALS CALCULATION\n    vec3 normals=normalize(e.xyy*map(hitPos+e.xyy)+e.yyx*map(hitPos+e.yyx)+e.yxy*map(hitPos+e.yxy)+e.xxx*map(hitPos+e.xxx)); //CALCULATE NORMALS FOR WHERE WE HIT\n    vec3 albedo=vec3(.0,.2,.4); // SETUP BASE COLOUR\n    float diffuse=max(0.,dot(normals,lightDirection)); // SIMPLE DIFFUSE LIGHTING\n    float fresnel=pow(1.+dot(normals,rayDirection),4.); // FRESNEL = BACKGROUND REFLECTIONS ADDED TO EDGES OF GEOMETRY TO COMPOSITE IT BETTER IN THE SCENE\n    float specular=pow(max(dot(reflect(-lightDirection,normals),-rayDirection),0.),30.);// SPECULAR LIGHTING = Bright highlights, the shiny white flashy bit especially visible on metallic objects\n    float ao=clamp(map(hitPos+normals*.05)/.05,0.,1.); // AO = AMBIENT OCCLUSION = Small shadows where geometries touch due to ambient lighting\n    float sss=smoothstep(0.,1.,map(hitPos+lightDirection*.4)/.4);// SSS = Sub surface scattering = Light penetrating through edges of a translucent object, especially visible on candle wax or skin. Can be used as backlight too.\n    color=mix(specular+albedo*(ao+.2)*(diffuse+sss*.1),backgroundColor,fresnel); // Final lighting result made of all the above and then mixed with fresnel\n    color=mix(backgroundColor,color,exp(-.002*result*result*result)); // Add fog right at the end\n  }\n  fragColor = vec4(pow(color,vec3(sin(iTime))),1);// RETURN FINAL COLOR WITH GAMMA CORRECTION (pow(color,vec3(.4545)))\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}