{
    "Shader": {
        "info": {
            "date": "1630564706",
            "description": "check out Slowtember by megaelod on IG\nhttps://www.instagram.com/p/CSCRu85jWe0/",
            "flags": 0,
            "hasliked": 0,
            "id": "sd33WS",
            "likes": 4,
            "name": "Slowtember 01-03: Street/Walk",
            "published": 3,
            "tags": [
                "slowtember"
            ],
            "usePreview": 0,
            "username": "klemek",
            "viewed": 235
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415927\n#define E .001\n\nfloat n(float c) {\n    return min(1., max(.0, c));\n}\n\nfloat rand(float seed) {\n    float v = pow(seed, 6.0 / 7.0);\n    v *= sin(v) + 1.;\n    return v - floor(v);\n}\n\nvec3 color(float x) {\n    return vec3(\n        .5 * (sin(x * 2. * PI) + 1.),\n        .5 * (sin(x * 2. * PI + 2. * PI / 3.) + 1.),\n        .5 * (sin(x * 2. * PI - 2. * PI / 3.) + 1.)\n    );\n}\n\nvec3 n3(vec3 c) {\n    return min(vec3(1), max(vec3(0), c));\n}\n\nvec3 mask(vec3 c0, vec3 c1, float m) {\n    return n3(c0 * (1.0 - m) + c1 * m);\n}\n\nfloat circle(vec2 uv, vec2 center, float size, float e) {\n    uv -= center;\n    return smoothstep(size * .5 + e,size * .5 - e, length(uv));\n}\n\nfloat ellipse(vec2 uv, vec2 center, vec2 size, float e) {\n    uv -= center;\n    uv.y *= size.x / size.y;\n    return circle(uv, vec2(.0), size.x, e);\n}\n\nvec2 rotate(vec2 uv, float angle) {\n    return vec2(\n        cos(angle * PI) * uv.x - sin(angle * PI) * uv.y,\n        sin(angle * PI) * uv.x + cos(angle * PI) * uv.y\n    );\n}\n\nfloat rect(vec2 uv, vec2 center, vec2 size, float angle, float e) {\n    uv -= center;\n    uv = rotate(uv, angle);\n    return \n        smoothstep(size.x * .5 + e, size.x * .5 - e, uv.x) *\n        smoothstep(-size.x * .5 - e, -size.x * .5 + e, uv.x) *\n        smoothstep(size.y * .5 + e, size.y * .5 - e, uv.y) *\n        smoothstep(-size.y * .5 - e, -size.y * .5 + e, uv.y);\n}\n\nfloat rrect(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rotate(uv, angle);\n    vec2 isize = size - vec2(r);\n    vec2 v1 = isize * .5;\n    vec2 v2 = v1 * vec2(-1, 1);\n    return n(\n        circle(uv, + v1, r, e) +\n        circle(uv, - v1, r, e) +\n        circle(uv, + v2, r, e) +\n        circle(uv, - v2, r, e) +\n        rect(uv, vec2(.0), vec2(size.x, isize.y), .0, e) + \n        rect(uv, vec2(.0), vec2(isize.x, size.y), .0, e)\n    );\n}\n\nfloat rrect2(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rotate(uv, angle);\n    return n(\n        rrect(uv, vec2(.0), size, r, .0, E) +\n        rect(uv, vec2(.0, - size.y * .5 + r * .5), vec2(size.x, r), .0, E)\n    );\n}\n\nfloat triangle(vec2 uv, vec2 center, vec2 size, float angle, float e) {\n    uv -= center;\n    uv = rotate(uv, angle);\n    uv += vec2(0, size.y * .5);\n    return\n        smoothstep(-size.x * .5 -e, -size.x * .5  + e, uv.x - uv.y * size.x * .5 / size.y) *\n        smoothstep(-size.x * .5 -e, -size.x * .5  + e, - uv.x - uv.y * size.x * .5 / size.y) *\n        smoothstep(-e, +e, uv.y);\n}\n\nfloat line(vec2 uv, vec2 p1, vec2 p2, float size, float e) {\n    vec2 diff = p2 - p1;\n\n    float angle = atan(diff.y, diff.x) / PI;\n    return n(\n        circle(uv, p1, size, e) +\n        circle(uv, p2, size, e) +\n        rect(uv, (p1 + p2) * .5, vec2(length(diff), size), -angle, e)\n    );\n}\n\nvec3 building(float x, vec2 uv, vec3 c) {\n    float height = .4 + .35 * rand(floor(x) + 8234.);\n    height -= mod(height, .1) - .07;\n\n    float color_x = rand(floor(x) + 233.);\n    vec3 bg_color = vec3(.2) + .05 * color(color_x);\n    vec3 door_color = vec3(.2, .0, .0) + .1 * color(color_x + .5);\n\n    c = mask(c, bg_color, rrect2(uv, vec2(.0, -.2 + height * .5), vec2(.3, height), .01, .0, E));\n    \n    float door_pos = .2 * (rand(floor(x) + 234.) - .5);\n\n    c = mask(c, door_color, rrect2(uv, vec2(door_pos, -.15), vec2(.08, .1), .01, .0, E));\n    c = mask(c, vec3(.5, .5, .0), circle(uv, vec2(door_pos + .02, -.15), .02, E));\n    \n    float mask_height = height - .165;\n    mask_height -= mod(mask_height, .1);\n    float window_mask = rect(uv, vec2(.0, mask_height * .5 - .04), vec2(.3, mask_height), .0, E);\n\n    vec2 uv2 = mod(uv + .05, .1) - .05;\n    float light = rand(floor(x) + 432. + floor((uv.x + .05) * 10.) * 233. + floor((uv.y + .05) * 10.) * 523.);\n    c = mask(c, light < .3 ? vec3(.1, .1, .1) : vec3(.7, .7, .5), window_mask * rrect(uv2, vec2(.0, -.0), vec2(.07, .07), .01, .0, E));\n    return c;\n}\n\nvec3 dude(vec2 uv, vec3 c, float t0) {\n    const vec2 LEG0[8] = vec2[](vec2(+.00,-.10),vec2(+.00,-.12),vec2(+.00,-.09),vec2(+.00,-.08),vec2(+.00,-.10),vec2(+.00,-.12),vec2(+.00,-.09),vec2(+.00,-.08));\n    const vec2 LEG1[8] = vec2[](vec2(+.06,-.20),vec2(+.06,-.20),vec2(-.01,-.20),vec2(-.03,-.20),vec2(-.03,-.20),vec2(-.03,-.20),vec2(+.02,-.18),vec2(+.06,-.15));\n    const vec2 LEG2[8] = vec2[](vec2(+.11,-.30),vec2(+.06,-.30),vec2(-.02,-.30),vec2(-.06,-.30),vec2(-.09,-.28),vec2(-.12,-.25),vec2(-.04,-.20),vec2(+.01,-.25));\n    const vec2 ARM0[8] = vec2[](vec2(-.00,+.07),vec2(-.01,+.05),vec2(+.01,+.08),vec2(+.02,+.09),vec2(+.03,+.07),vec2(+.03,+.05),vec2(+.02,+.08),vec2(+.01,+.09));\n    const vec2 ARM1[8] = vec2[](vec2(-.05,+.02),vec2(-.07,+.02),vec2(+.00,+.00),vec2(+.03,+.02),vec2(+.04,+.01),vec2(+.05,+.01),vec2(+.00,+.01),vec2(-.04,+.02));\n    const vec2 ARM2[8] = vec2[](vec2(-.06,-.06),vec2(-.08,-.05),vec2(+.00,-.07),vec2(+.05,-.07),vec2(+.07,-.07),vec2(+.09,-.06),vec2(+.01,-.06),vec2(-.04,-.06));\n\n    float t = mod(t0, .8);\n    float t2 = t * 10.;\n    float t3 = mod(t, .1) * 10.;\n    \n    int ti1 = int(t2);\n    int ti1_next = int(mod(t2 + 1., 8.));\n    \n    int ti2 = int(mod(t2 + 4., 8.));\n    int ti2_next = int(mod(t2 + 5., 8.));\n    \n    vec2 l10 = (1. - t3) * LEG0[ti1] + t3 * LEG0[ti1_next];\n    vec2 l11 = (1. - t3) * LEG1[ti1] + t3 * LEG1[ti1_next];\n    vec2 l12 = (1. - t3) * LEG2[ti1] + t3 * LEG2[ti1_next];\n    \n    vec2 l20 = (1. - t3) * LEG0[ti1] + t3 * LEG0[ti1_next];\n    vec2 l21 = (1. - t3) * LEG1[ti2] + t3 * LEG1[ti2_next];\n    vec2 l22 = (1. - t3) * LEG2[ti2] + t3 * LEG2[ti2_next];\n    \n    vec2 a10 = (1. - t3) * ARM0[ti1] + t3 * ARM0[ti1_next];\n    vec2 a11 = (1. - t3) * ARM1[ti1] + t3 * ARM1[ti1_next];\n    vec2 a12 = (1. - t3) * ARM2[ti1] + t3 * ARM2[ti1_next];\n    \n    vec2 a20 = (1. - t3) * ARM0[ti2] + t3 * ARM0[ti2_next];\n    vec2 a21 = (1. - t3) * ARM1[ti2] + t3 * ARM1[ti2_next];\n    vec2 a22 = (1. - t3) * ARM2[ti2] + t3 * ARM2[ti2_next];\n    \n    vec3 c0 = color(t0 * .2);\n    \n    c = mask(c, .4 * c0, line(uv, l20, l21, .05, E));\n    c = mask(c, .4 * c0, line(uv, l21, l22, .05, E));\n    \n    c = mask(c, .4 * c0, line(uv, a20, a21, .04, E));\n    c = mask(c, .4 * c0, line(uv, a21, a22, .04, E));\n \n    c = mask(c, .5 * c0, line(uv, l10 + vec2(.0, .01), l10 + vec2(.01, .15), .1, E));\n    \n    c = mask(c, .5 * c0, line(uv, l10, l11, .05, E));\n    c = mask(c, .5 * c0, line(uv, l11, l12, .05, E));\n    \n    c = mask(c, .6 * c0, line(uv, a10, a11, .04, E));\n    c = mask(c, .6 * c0, line(uv, a11, a12, .04, E));\n    \n    c = mask(c, .5 * c0, circle(uv, l10 + vec2(.015, .25), .1, E));\n\n    return c;\n}\n\nvec3 lamp(vec2 uv, vec3 c) {\n\n    c = mask(c, vec3(.05), rrect2(uv, vec2(.25, -.1), vec2(.03, .25), .01, .0, E));\n    \n    float light_mask = n(\n        triangle(uv, vec2(.23, -.1), vec2(.2, .25), .0, .01) +\n        rect(uv, vec2(.25, -.1), vec2(.04, .25), .0, .01) +\n        triangle(uv, vec2(.27, -.1), vec2(.2, .25), .0, .01) +\n        ellipse(uv, vec2(.25, -.23), vec2(.24, .1), .01)\n    );\n    \n    c = mask(c, vec3(.8, .8, .0), light_mask * .5 * n(uv.y * 2.5 + .6));\n    c = mask(c, vec3(.05), rrect2(uv, vec2(.25, .02), vec2(.06, .02), .01, .0, E));\n\n    return c;\n}\n\nvec3 road(vec2 uv, vec3 c) {\n    c = mask(c, vec3(.2), smoothstep(E, -E, uv.y+.2));\n    c = mask(c, vec3(.05), smoothstep(E, -E, uv.y+.24));\n    c = mask(c, vec3(.1), smoothstep(E, -E, uv.y+.25));\n    c = mask(c, vec3(.2), smoothstep(E, -E, uv.y+.38));\n    \n    c = mask(c, vec3(.6), rrect(uv, vec2(.0, -.31), vec2(.05, .01), .0, .0, E));\n    \n    return c;\n}\n\nvec3 sky(vec2 uv, float x) {\n    vec3 c = vec3(0, .3 - .5 * uv.y, .5);\n    \n    float t = x * .1;\n    \n    const float size = .05;\n    vec2 uv2 = mod(uv + vec2(t, .0), size);\n    float r1 = rand(floor((uv.x + t + size) * 20.) * 223. + floor((uv.y + 10. + size) * 20.) * 523.);\n    float r2 = rand(floor((uv.x + t + size) * 20.) * 523. + floor((uv.y + 10. + size) * 20.) * 823.);\n    float r3 = rand(floor((uv.x + t + size) * 20.) * 923. + floor((uv.y + 10. + size) * 20.) * 323.);\n    if (r3 < .1) {\n    \n        float star =  n(uv.y * 2.) * n(\n            circle(mod(uv2, .05), vec2(size * .5 + size * .4 * (r1 - .5), size * .5 + size * .4 * (r2 - .5)), .002, E) +\n            circle(mod(uv2, .05), vec2(size * .5 + size * .4 * (r1 - .5), size * .5 + size * .4 * (r2 - .5)), .005, .015)\n        );\n    \n        c = mask(c, vec3(.9, .9, .7), star);\n    }\n    \n    c = mask(c, vec3(.9, .9, .7), n(circle(uv, vec2(-.6,.25), .1, E) + circle(uv, vec2(-.6,.25), .11, .02)));\n    \n    return c;\n}\n\nvec3 image(vec2 uv, float t) {\n    float bg_time = uv.x + t * .4;\n    \n    vec3 c = sky(uv, t);\n    \n    vec2 uv1 = vec2(mod(bg_time, .2), uv.y);\n    c = road(uv1, c);\n    \n    vec2 uv2 = vec2(mod(bg_time, .32), uv.y);\n    c = building(bg_time/.32, uv2 - vec2(.15, .0), c);\n\n    vec2 uv3 = vec2(mod(bg_time, .5), uv.y);\n    c = lamp(uv3, c);\n\n    c = dude(uv + vec2(.0, .1), c, t * .6);\n    \n    return c;\n}\n\nvec3 colorShiftImage(vec2 uv, float t0, float t1, float size) {\n    vec3 c1 = image(uv + vec2(size * sin(t1), size * cos(t1)), t0);\n    vec3 c2 = image(uv + vec2(size * sin(t1 + 2.), size * cos(t1 + 2.)), t0);\n    vec3 c3 = image(uv + vec2(size * sin(t1 + 4.), size * cos(t1 + 4.)), t0);\n    \n    return vec3(c1.x, c2.y, c3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 c = colorShiftImage(uv, iTime * .5, iTime * 5., .0);\n \n    fragColor = vec4(c, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}