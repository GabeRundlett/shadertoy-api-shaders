{
    "Shader": {
        "info": {
            "date": "1697407784",
            "description": "This shader graphs a randomly generated function of a single variable.",
            "flags": 0,
            "hasliked": 0,
            "id": "csdfz2",
            "likes": 4,
            "name": "Random function generator",
            "published": 3,
            "tags": [
                "random",
                "function",
                "generator"
            ],
            "usePreview": 0,
            "username": "jarble",
            "viewed": 198
        },
        "renderpass": [
            {
                "code": "//from David Hoskins' \"Hash without sine\"\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//get the output of a random function with a random arity\nfloat func1(float seed, float param1, inout float arity){\n    //the function is determined by a random seed\n    \n    int func_id = int(hash11(seed*2.)*8.);\n    if(func_id == 0) return sin(param1);\n    else if(func_id == 1){ return cos(param1); arity = 1.;}\n    else if(func_id == 2){ return param1*param1; arity = 1.;}\n    else if(func_id == 3){ return param1+(hash11((seed+1.)*5.-10.)); arity = 2.;}\n    else if(func_id == 4){ return abs(param1); arity = 1.;}\n    else if(func_id == 5){ return log(param1); arity = 1.;}\n    else if(func_id == 6){ return log(param1); arity = 1.;}\n    else if(func_id == 7){ return param1*(hash11((seed+1.)*5.-10.)); arity = 2.;}\n    //else if(func_id == 8){ return pow(param1,(hash11((seed+1.)*5.-10.))); arity = 2.;}\n    else return param1;\n}\n\nfloat random_function_generator(float param1,float seed){\n    \n    float arity = 1.,\n    h1 = hash11(seed),\n    f1 = func1((seed+h1)*2.,param1,arity);\n    while(h1 > 0.25){\n        seed += arity;\n        h1 = hash11(seed);\n        f1 = func1((seed+h1)*2.,f1,arity);\n    }\n    return f1;\n}\n\n// ##### Y-Function Graph #####\n// Made by Zi7ar21 on February 12th, 2021\n// Last Updated: February 12th, 2021 at 13:30 Mountain Time\n\n// If you found this anywhere except Shadertoy, the original and possibly a newer version can be found at:\n// https://www.shadertoy.com/view/wl3fRf\n\n/*All of the other shaders that are supposed to plot functions (that I have used at least)\nseem to have variations in line thickness due to the fact that they simply take a function's\ndifference from the screen's y coordinate and draw it if it is a certain distance from the\ny coordinate at that point, however this shader solves that problem by drawing an aliased line\nwith uniform-ish thickness and then superampling it.*/\n\n// Super-Sample Levels\n#define samples 4\n\n// Y-Scale\n#define yscale 2.5\n\n// X-Scale\n#define xscale 4.0/iResolution.x\n\n// Pi (used for the example function)\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n\n// Example Function: y = (sin(x*pi*2.0+t)+cos(x*pi))/2.0\nfloat function(float x){\n    return random_function_generator(x,floor(iTime*4.));\n}\n\n// Plot\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Initialize the Color\n    vec3 color  = vec3(0.0);\n    // Initialize the Coordinates\n    vec2 coord = fragCoord;\n    // The Super-Sampling Loop\n    for(int y = -samples; y < samples; y++){for(int x = -samples; x < samples; x++){\n    // Set the Super-Sampled Coordinate\n    coord = (fragCoord+(vec2(x, y)/float(samples)));\n    // Find The Points for a Smooth yet Aliased Line\n    bool pointa =     round(function((coord.x-1.0)*xscale)*iResolution.y) >= yscale*(coord.y-0.5*iResolution.y);\n    bool pointb =     round(function((coord.x    )*xscale)*iResolution.y) <= yscale*(coord.y-0.5*iResolution.y);\n    bool pointc =     round(function((coord.x    )*xscale)*iResolution.y) >= yscale*(coord.y-0.5*iResolution.y);\n    bool pointd =     round(function((coord.x-1.0)*xscale)*iResolution.y) <= yscale*(coord.y-0.5*iResolution.y);\n    // Some Points take less than 2x to move up a pixel so we sample a point where the line is at every point\n    bool pointe = abs(round(function( coord.x*xscale)*iResolution.y)-yscale*(coord.y-0.5*iResolution.y)) <= 1.0;\n    // Check if the pixel is part of the line\n    if((pointa && pointb) || (pointc && pointd) || pointe){\n        color += vec3(1.0);\n    }\n    }}\n    // Output the Super-Sampled Line\n    fragColor = vec4(color/float(samples*samples*4), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}