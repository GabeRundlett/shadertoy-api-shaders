{
    "Shader": {
        "info": {
            "date": "1674416553",
            "description": "March ray, reflect, refract, repeat. As in light so does darkness.",
            "flags": 0,
            "hasliked": 0,
            "id": "cllXzN",
            "likes": 14,
            "name": "Prism 2D",
            "published": 3,
            "tags": [
                "raymarch",
                "refraction"
            ],
            "usePreview": 0,
            "username": "QuantumSuper",
            "viewed": 362
        },
        "renderpass": [
            {
                "code": "//Prism v0.5-220122\n\n// Not entirely accurate 2D prism.\n\n#define PI3 1.0471975512\n#define MAX_STEPS 100\n#define MAX_DIST 1.\n#define MIN_DIST 0.02\nvec3[3] lines;\n\nfloat rect2(vec2 myVar, vec2 lim1, vec2 lim2){\n    return dot(step(min(lim1,lim2),myVar),step(myVar,max(lim1,lim2)));\n}\n\nfloat sRect2(vec2 myVar, vec2 lim1, vec2 lim2){\n    vec2 myMin = min(lim1,lim2);\n    vec2 myMax = max(lim1,lim2);\n    return dot(smoothstep(myMin,myMin+.05,myVar),smoothstep(myMax,myMax-.05,myVar));\n}\n\nfloat getLine(vec2 pos, vec3 def){ //def: x,y,c\n\treturn dot(def, vec3(pos, 1.)); //=0\n}\n\nfloat getDist(vec2 pos){\n\tfloat minDist = MAX_DIST;\n    float someDist;\n\t\n\tfor (int n=0; n<3; n++){\n\t\tminDist = min(minDist, abs(getLine(pos, lines[n])));\n\t}\n\t\n\treturn minDist;\n}\n\nvec2 guessNormal(vec2 pos){\n\tvec2 tangent = vec2(MIN_DIST, 0);\n\t\n\tvec2 normal = getDist(pos) - vec2(\n\t\tgetDist(pos-tangent.xy),\n\t\tgetDist(pos-tangent.yx)\n\t\t);\n\t\t\n\treturn normalize(normal);\n}\n\nfloat rayMarch(vec2 rayOrigin, vec2 rayDir){\n\tfloat rayLength = 0.1;  //tune to not get stuck at origin\n\tfloat radCirc;\n    \n    if (length(rayOrigin)>.5) rayLength += length(rayOrigin)-.5; //there is nothing outside of this circle\n\t\n\tfor (int n=0; n<MAX_STEPS; n++){\n\t\tradCirc = getDist(rayOrigin+rayLength*rayDir);\n\t\trayLength += radCirc;\n\t\tif (rayLength>MAX_DIST || abs(radCirc)<MIN_DIST) break;\n\t}\n\t\n\treturn rayLength;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y);\n    float animTime = 2.133333*iTime;\n    //mat2 rotM = mat2(cos(animTime/12.),-sin(animTime/12.),sin(animTime/12.),cos(animTime/12.)); \n    //uv *= rotM; //rotate \n    uv.y += .1+.1*sin(animTime/12.); //translate\n\tuv *= 1.+.05*sin(animTime/12.); //zoom\n    vec3 col = vec3(0);\n    \n\t// \"Surfaces\"\n    lines = vec3[](\n\t\tvec3(0.,1.,.5*sin(PI3/2.)), //horz edge\n\t\tvec3(sin(PI3),cos(PI3),-.5*sin(PI3/2.)), //right edge\n\t\tvec3(-sin(PI3),cos(PI3),-.5*sin(PI3/2.)) //left edge\n\t);\n\t\n    // Prism\n\tfloat bw = 0.;\n    bw += smoothstep(.01,.0,abs(getLine( uv, lines[0]))); \n    bw += smoothstep(.01,.0,abs(getLine( uv, lines[1]))); \n    bw += smoothstep(.01,.0,abs(getLine( uv, lines[2]))); \n    bw *= smoothstep(.001,.0,uv.x*uv.x+uv.y*uv.y-0.25); //cut overhangs (visual trick)\n\tcol += vec3(bw);\n\t//col += vec3(getLine( uv, lines[0]),getLine( uv, lines[1]),getLine( uv, lines[2])); //to see distance function\n\t\n\t// Ray marching\n    vec2 normal, pos, dir, pos2, dir2; \n    float amp, spread;\n\tfloat[] eta = float[](//baseline refraction index ratio, n2/n1, color dependence\n        0.68-.1*1.2598,\n        0.68-.1*1.3660,\n        0.68-.1*1.4863,\n        0.68-.1*1.7666,\n        0.68-.1*2.3124,\n        0.68-.1*2.6122,\n        0.68-.1*2.9032\n        ); \n    vec3[] myCol = vec3[](\n\t\t.3*abs(cos(animTime-.3))*vec3(1,0,0), //red\n        .2*abs(cos(animTime-.2))*vec3(.895,.446,0), //orange\n        .2*abs(cos(animTime-.1))*vec3(.707,.707,0), //yellow\n\t\t.2*abs(cos(animTime))*vec3(0,1,0), //green\n\t\t.2*abs(cos(animTime+.1))*vec3(0,0,1), //blue\n        .05*abs(cos(animTime+.2))*vec3(.5,0,.866), //indigo\n        .05*abs(cos(animTime+.3))*vec3(.574,0,.819) //violet\n\t);\n\t\n\tfor (int rayCol=0; rayCol<myCol.length(); rayCol++){ //r,g,b\n\t\tfor (int rayT=1; rayT<4; rayT++){ // (refractions, reflections) x (0,1; 1,0; 0,0; 1,1) \n            pos = vec2(-1.1,.03+.05*sin(animTime/8.)); //start pos\n            dir = normalize(vec2(1.+.01*float(rayCol),.2+.1*sin(animTime/8.))); //start dir\n            amp = 1.; //start amplitude\n            spread = 0.01; //start beam width\n\t\t\t for (int n=0; n<5; n++){//...I guess long iterations are not liked by shaders\n\t\t\t\tpos2 = pos+rayMarch(pos,dir)*dir;\n                col += amp*sRect2(uv,pos,pos2)*smoothstep(spread,.0,abs(getLine(uv, vec3(dir.y,-dir.x,pos.y*dir.x-pos.x*dir.y))))*myCol[rayCol];\n                spread += .01*length(pos2-pos);\n                normal = guessNormal(pos2-MIN_DIST*dir);\n\t\t\t\tif (int(mod(float(n+rayT)+mod(float(n),2.)*float(rayT)/2.,2.)) == 0){ //BUG this does not work right (rayT=0)\n\t\t\t\t\tdir2 = reflect(dir,normal);\n                    amp *= 0.4;\n\t\t\t\t} else {\n                    dir2 = refract(dir,normal,eta[rayCol]);\n                    eta[rayCol] = 1./eta[rayCol];\n                    amp *= 0.8;\n\t\t\t\t}\n                if (pos2.x*pos2.x+pos2.y*pos2.y > .25) break;\n\t\t\t\tpos=pos2; dir=dir2;\n\t\t\t }\t\t\n\t\t}\n\t}\n\t\t\n\tcol = pow(col, vec3(.4545)); //gamma correction\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}