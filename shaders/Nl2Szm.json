{
    "Shader": {
        "info": {
            "date": "1627348528",
            "description": "Based on @iq's article for projecting spheres: [url=https://iquilezles.org/articles/sphereproj/sphereproj.htm]https://iquilezles.org/articles/sphereproj/sphereproj.htm[/url]\nI finally had a use for my ellipse extraction code! :)",
            "flags": 0,
            "hasliked": 0,
            "id": "Nl2Szm",
            "likes": 21,
            "name": "Ellipsoid Projection",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "projection",
                "area",
                "ellipsoid"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 487
        },
        "renderpass": [
            {
                "code": "/*\nAfter reading @iq's article on projecting spheres (https://iquilezles.org/articles/sphereproj)\nI wanted to try something similar so I decided to compute the projection of an ellipsoid.\n\nThe general ellipsoid can be defined as a linearly transformed unit sphere.\nBecause the transformation is independent of the distance the ray has travelled\nthe transformation can be applied to the ray and then to determine the edges of\nthe ellipsoid in screenspace we can analyze the discriminant of a unit sphere intersection.\n\nThe intersection between a ray and a unit sphere requires solving a quadratic equation\nso the discriminant is this (notice that there is no 2 in the B coefficient because it\nall simplifies out of the solution):\nb^2 - ac\n\na = dot(rd, rd)\nb = dot(ro, rd)\nc = dot(ro, ro) - 1\n\nThe full discriminant in terms of 2D coordinates is a quadric (\"quadric\" is short for \"quadratic\"\nbut I also like to use it to differentiate between 1D and 2D second degree equations). This quadric\nencodes all the information about the ellipsoid's projection in screenspace. You can see the\ncoefficients I computed in the projEllipsoid() function below.\n\nThe center of the quadric is where both its partial derivatives equal zero.\nThe axes are at the minima and maxima of the intersection function\nfor a ray rotating at the center of it.\n\nSee https://www.shadertoy.com/view/stS3Ww for the ellipse extraction code.\nIt also has links to some desmos graphs of the workthrough.\n*/\n\n// Constants\n#define PI 3.14159265359\n\n// Structures\nstruct Camera {\n    vec3 pos;\n    mat3 axes;\n    float focal;\n};\n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\n// Ellipse in quadric form to ellipse in parametric form with major and minor axes\n// See https://www.shadertoy.com/view/stS3Ww\nvoid extractEllipse(in float a, in float b, in float c, in float d, in float e, in float f, out mat2 axes, out vec2 size, out vec2 center) {\n    center = vec2(2.0 * b * d - c * e, 2.0 * a * e - c * d) / (c * c - 4.0 * a * b);\n    float g = a * center.x * center.x + b * center.y * center.y + c * center.x * center.y + d * center.x + e * center.y + f;\n\n    float ba = b - a, r = ba / c;\n    float ca = 0.5 * sign(c) / sqrt(1.0 + r * r);\n    float ch = sqrt(0.5 + ca), sh = sqrt(0.5 - ca) * sign(ba);\n    float i = ch - sh, j = ch + sh;\n\n    float ii = i * i, jj = j * j, ij = c * i * j;\n    size = sqrt(-2.0 * g / vec2(a * ii + b * jj + ij, a * jj + b * ii - ij));\n    axes = mat2(i, j, -j, i) * sqrt(0.5);\n}\n\n// Ellipsoid projection\nvoid projEllipsoid(in vec3 pos, in mat3 mat, in Camera cam, out mat2 axes, out vec2 size, out vec2 center) {\n    mat3 inv = inverse(mat), view = inv * cam.axes, tview = transpose(view);\n    vec3 ro = inv * (cam.pos - pos);\n\n    vec3 vo = tview * ro;\n    mat3 vv = tview * view * (dot(ro, ro) - 1.0);\n\n    float a = (vo.x * vo.x - vv[0][0]);\n    float b = (vo.y * vo.y - vv[1][1]);\n    float c = (vo.x * vo.y - vv[0][1]) * 2.0;\n    float d = (vo.x * vo.z - vv[0][2]) * cam.focal * 2.0;\n    float e = (vo.y * vo.z - vv[1][2]) * cam.focal * 2.0;\n    float f = (vo.z * vo.z - vv[2][2]) * cam.focal * cam.focal;\n\n    extractEllipse(a, b, c, d, e, f, axes, size, center);\n}\n\n// Intersectors\nfloat iEllipsoid(in vec3 ro, in vec3 rd, in vec3 pos, in mat3 mat, out vec3 hit, out vec3 nor) {\n    mat3 inv = inverse(mat);\n    vec3 o = inv * (ro - pos), d = inv * rd;\n\n    float a = dot(d, d), b = dot(o, d), c = dot(o, o) - 1.0;\n    float h = b * b - a * c;\n    if (h < 0.0) return -1.0;\n    float t = (-b - sign(c) * h) / a;\n\n    hit = ro + rd * t;\n    nor = normalize(transpose(inv) * inv * (hit - pos)); // Not sure if this is the correct transform, I tried working it out by hand\n\n    return t;\n}\n\nfloat iPlane(in vec3 ro, in vec3 rd, in vec3 pos, in vec3 nor, out vec3 hit) {\n    float t = dot(pos - ro, nor) / dot(rd, nor);\n    hit = ro + rd * t;\n    return t;\n}\n\n// Double integral of mod(floor(x) + floor(y), 2) from a to b\n// Inspired by https://iquilezles.org/articles/checkerfiltering\nfloat integrateCheckers(in vec2 a, in vec2 b) {\n    vec2 u = b - a, v = abs(mod(b, 2.0) - 1.0) - abs(mod(a, 2.0) - 1.0);\n    return 0.5 * (u.x * u.y - v.x * v.y);\n}\n\n// SDFs\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v, in float t, in float hw, in float hh) {\n    float m = length(v); vec2 n = v / m;\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));\n    return min(sdVerticalLine(p, m) - t, sdIsosceles(p - vec2(0.0, m), hw, hh));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat cbrt(in float x) { return sign(x) * pow(x, 1.0 / 3.0); }\nfloat sdEllipse(in vec2 p, in vec2 ab) {\n    p = abs(p);\n    if (p.x > p.y) p = p.yx, ab = ab.yx;\n    float l = ab.y * ab.y - ab.x * ab.x;\n    float m = ab.x * p.x / l,        m2 = m * m;\n    float n = ab.y * p.y / l,        n2 = n * n;\n    float c = (m2 + n2 - 1.0) / 3.0, c3 = c * c * c;\n    float q = c3 + m2 * n2 * 2.0;\n    float d = c3 + m2 * n2;\n    float g = m + m * n2;\n    float co;\n    if (d < 0.0) {\n        float h = acos(q / c3) / 3.0;\n        float s = cos(h);\n        float t = sin(h) * sqrt(3.0);\n        float rx = sqrt(-c * (s + t + 2.0) + m2);\n        float ry = sqrt(-c * (s - t + 2.0) + m2);\n        co = (ry + sign(l) * rx + abs(g) / (rx * ry) - m) / 2.0;\n    }\n\n    else {\n        float h = 2.0 * m * n * sqrt(d);\n        float s = cbrt(q + h), u = cbrt(q - h);\n        float rx = -s - u - c * 4.0 + 2.0 * m2;\n        float ry = (s - u) * sqrt(3.0);\n        float rm = sqrt(rx * rx + ry * ry);\n        co = (ry / sqrt(rm - rx) + 2.0 * g / rm - m) / 2.0;\n    }\n\n    vec2 r = vec2(co, sqrt(1.0 - co * co)) * ab;\n    return length(p - r) * sign(p.y-r.y);\n}\n\n// Camera and ray routines\nCamera makeCamera(in vec3 pos, in vec3 target, in float focal) {\n    vec3 f = normalize(target - pos);\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x));\n    vec3 u = cross(r, f);\n    return Camera(pos, mat3(r, u, f), focal);\n}\n\nRay makeRay(in vec2 uv, in Camera cam) {\n    return Ray(cam.pos, normalize(cam.axes * vec3(uv, cam.focal)));\n}\n\n// Project onto the camera X and Y axes\nvec2 proj2D(in vec3 p, in Camera cam) {\n    p = (p - cam.pos) * cam.axes;\n    return p.xy / p.z * cam.focal;\n}\n\n#define drawSDF(dist, color) fragColor.rgb = mix(fragColor.rgb, color, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0, -1.5) : (iMouse.xy - center) / iResolution.y * 3.0;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    // Blue gradient in the background\n    fragColor = vec4(pow(1.0 - length(fragCoord / iResolution.xy - 0.5), 0.8)) * vec4(0.5, 0.5, 1.0, 1.0);\n\n    // Camera and light\n    float rot = 0.1 * cos(iTime) + 1.57;\n    Camera cam = makeCamera(vec3(vec2(cos(rot) * 8.0, 2.0) + mouse, sin(rot) * 8.0), vec3(0.0), 1.0);\n    Ray ray = makeRay(uv, cam);\n\n    vec3 light = normalize(vec3(-1.0, 1.0, 1.0));\n\n    // Ground plane\n    vec3 planeHit, planeNor = vec3(0.0, 1.0, 0.0);\n    float tPlane = iPlane(ray.ro, ray.rd, vec3(0.0, -2.0, 0.0), planeNor, planeHit);\n    if (tPlane > 0.0) {\n        vec2 filt = pow(vec2(length(ray.ro.xz - planeHit.xz) * 0.05), vec2(2.0)) * 0.25; // Hack filter\n        fragColor.rgb = vec3(integrateCheckers(planeHit.xz - filt, planeHit.xz + filt) / (4.0 * filt.x * filt.y));\n    }\n\n    // Ellipse transformation\n    float move = 0.5 * iTime;\n    vec3 ellipPos = vec3(2.5 + sin(iTime), sin(move), cos(move)), ellipRad = vec3(2.25, 1.5, 0.5);\n    mat3 ellipMat = mat3(1.0, 0.0, 0.0,\n                         0.0, 1.0, 0.0,\n                         0.0, 0.0, 1.0);\n\n    float pitch = 0.5 * iTime;\n    float cp = cos(pitch), sp = sin(pitch);\n    ellipMat *= mat3(1.0, 0.0, 0.0, // Rotation about X\n                     0.0, cp, -sp,\n                     0.0, sp, cp);\n\n    float yaw = iTime;\n    float cy = cos(yaw), sy = sin(yaw);\n    ellipMat *= mat3(cy, 0.0, -sy, // Rotation about Y\n                     0.0, 1.0, 0.0,\n                     sy, 0.0, cy);\n\n    // Then scale (I originally got the order wrong so it was mysteriously not rotating XD)\n    ellipMat *= mat3(ellipRad.x, 0.0, 0.0,\n                     0.0, ellipRad.y, 0.0,\n                     0.0, 0.0, ellipRad.z);\n\n    // Intersect the ellipse\n    vec3 ellipHit, ellipNor;\n    float tEllip = iEllipsoid(ray.ro, ray.rd, ellipPos, ellipMat, ellipHit, ellipNor);\n    if (tEllip > 0.0) fragColor.rgb = vec2(max(0.2, dot(light, ellipNor)), 0.0).rrg;\n\n    // Project and draw ellipse trasformation (for debugging, I always\n    // manage to mix something up when I'm dealing with OpenGL's matrices\n    // that are indexed column major and initialized like they're row major and\n    // then they are also transposed when you mutiply backwards)\n    //vec2 projCen = proj2D(ellipPos, cam);\n    //drawSDF(sdVectorArrow(uv - projCen, proj2D(ellipPos + ellipMat[0], cam) - projCen, 0.001, 0.015, 0.03), vec3(0.8, 0.0, 0.0));\n    //drawSDF(sdVectorArrow(uv - projCen, proj2D(ellipPos + ellipMat[1], cam) - projCen, 0.001, 0.015, 0.03), vec3(0.0, 0.8, 0.0));\n    //drawSDF(sdVectorArrow(uv - projCen, proj2D(ellipPos + ellipMat[2], cam) - projCen, 0.001, 0.015, 0.03), vec3(0.0, 0.0, 0.8));\n    //drawSDF(sdDisk(uv, projCen, 0.0125), vec3(0.0));\n\n    // Project the ellipsoid\n    mat2 axes; vec2 size, cen;\n    projEllipsoid(ellipPos, ellipMat, cam, axes, size, cen);\n    drawSDF(abs(sdEllipse(transpose(axes) * (uv - cen), size)) - 0.001, vec3(1.0, 0.5, 0.0));\n    drawSDF(sdVectorArrow(uv - cen, axes[0] * size.x, 0.001, 0.015, 0.03), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdVectorArrow(uv - cen, axes[1] * size.y, 0.001, 0.015, 0.03), vec3(0.0, 1.0, 0.0));\n    drawSDF(sdDisk(uv, cen, 0.015), vec3(0.0, 0.0, 1.0));\n\n    // Virtual camera\n    Camera vcam = makeCamera(vec3(-5.0, mix(-2.0, 3.0, 0.5 + 0.5 * cos(0.1 * iTime)), 0.0), vec3(0.0), 3.0);\n    float vw = 2.0, vh = 1.5; // Screen dimensions\n    vec3 vScreenCenter = vcam.pos + vcam.axes[2] * vcam.focal;\n\n    // Project the vertices composing the virtual camera\n    vec2 camVerts0 = proj2D(vcam.pos + vcam.axes * vec3(-vw,  vh, vcam.focal), cam);\n    vec2 camVerts1 = proj2D(vcam.pos + vcam.axes * vec3(-vw, -vh, vcam.focal), cam);\n    vec2 camVerts2 = proj2D(vcam.pos + vcam.axes * vec3( vw, -vh, vcam.focal), cam);\n    vec2 camVerts3 = proj2D(vcam.pos + vcam.axes * vec3( vw,  vh, vcam.focal), cam);\n    vec2 camVerts4 = proj2D(vcam.pos, cam);\n\n    // Camera wireframe\n    bool drawFrameNow; float wire;\n    if (tEllip < 0.0) {\n        drawFrameNow = dot(ray.ro - (vcam.pos + vcam.axes[2] * vcam.focal), vcam.axes[2]) > 0.0;\n        wire = sdLine(uv, camVerts0, camVerts4, 0.001);\n        wire = min(wire, sdLine(uv, camVerts1, camVerts4, 0.001));\n        wire = min(wire, sdLine(uv, camVerts2, camVerts4, 0.001));\n        wire = min(wire, sdLine(uv, camVerts3, camVerts4, 0.001));\n        if (drawFrameNow) drawSDF(wire, vec3(0.0));\n    }\n\n    // Intersect the virtual camera's screen\n    vec3 screenHit, screenNor = vcam.axes[2];\n    float tScreen = iPlane(ray.ro, ray.rd, vScreenCenter, vcam.axes[2], screenHit);\n    vec2 screenUv = screenHit * mat2x3(vcam.axes[0], vcam.axes[1]); // vec * mat = transpose(mat) * vec\n    if (abs(screenUv.x) < vw && abs(screenUv.y) < vh && (tEllip < 0.0 ? true : tScreen < tEllip)) {\n        fragColor.rgb = vec3(1.0);\n        Ray vray = makeRay(screenUv, vcam);\n        projEllipsoid(ellipPos, ellipMat, vcam, axes, size, cen);\n\n        // Ground plane\n        planeHit, planeNor = vec3(0.0, 1.0, 0.0);\n        tPlane = iPlane(vray.ro, vray.rd, vec3(0.0, -2.0, 0.0), planeNor, planeHit);\n        if (tPlane > 0.0) {\n            vec2 filt = pow(vec2(length(vray.ro.xz - planeHit.xz) * 0.05), vec2(2.0)); // Hack filter\n            fragColor.rgb = vec3(integrateCheckers(planeHit.xz - filt, planeHit.xz + filt) / (4.0 * filt.x * filt.y));\n        }\n\n        tEllip = iEllipsoid(vray.ro, vray.rd, ellipPos, ellipMat, ellipHit, ellipNor);\n        if (tEllip > 0.0) fragColor.rgb = vec2(max(0.2, dot(light, ellipNor)), 0.0).rrg;\n\n        float j = 0.08; // Approximate unstretching factor\n        drawSDF((abs(sdEllipse(transpose(axes) * (screenUv - cen), size)) - 0.001) * j, vec3(1.0, 0.5, 0.0));\n        drawSDF(sdVectorArrow(screenUv - cen, axes[0] * size.x, 0.001, 0.015, 0.03) * j, vec3(1.0, 0.0, 0.0));\n        drawSDF(sdVectorArrow(screenUv - cen, axes[1] * size.y, 0.001, 0.015, 0.03) * j, vec3(0.0, 1.0, 0.0));\n        drawSDF(sdDisk(screenUv, cen, 0.05) * j, vec3(0.0, 0.0, 1.0));\n    }\n\n    // Camera wireframe\n    if (tEllip < 0.0) {\n        if (!drawFrameNow) drawSDF(wire, vec3(0.0));\n        drawSDF(sdLine(uv, camVerts0, camVerts1, 0.001), vec3(0.0));\n        drawSDF(sdLine(uv, camVerts1, camVerts2, 0.001), vec3(0.0));\n        drawSDF(sdLine(uv, camVerts2, camVerts3, 0.001), vec3(0.0));\n        drawSDF(sdLine(uv, camVerts3, camVerts0, 0.001), vec3(0.0));\n    }\n\n    // \"Eye\" of the camera\n    drawSDF(sdDisk(uv, camVerts4, 0.0125), vec3(0.0, 0.0, 1.0));\n\n    // Area of the projected ellipsoid in pixels\n    float area = PI * size.x * size.y * iResolution.y * iResolution.y;\n    vec2 corner = vec2(0.5 * iResolution.x / iResolution.y, 0.5); // Corner of the screen\n    fragColor.rgb = digitIn(fragColor.rgb, vec3(1.0, 0.0, 0.5), uv - vec2(-corner.x + 0.05, corner.y - 0.1), 100.0, area);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Handy (debugging) font by @valalalalala\n// Thanks!\n\n        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"little debugging font\"                                   // //\n     //                                                            //  //\n    //  This utility uses a small bitmapped font (3x5) to render  //   //\n   //  floats, primarily intended for debugging. The code can    //    //\n  //  be copy/pasta'd into the Common tab as needed.            //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\nconst int CHARACTERS[14] = int[14](31599, 9362, 31183, 31207, 23524, 29671, 29679, 30994, 31727, 31719, 1488, 448, 2, 3640);\n\nfloat digitIsOn(in int digit, in vec2 id) {   \n    if (id.x < 0.0 || id.y < 0.0 || id.x > 2.0 || id.y > 4.0 ) return 0.0;\n    return floor(mod(float(CHARACTERS[int(digit)]) / pow(2.0, id.x + id.y * 3.0), 2.0));\n}\n\nfloat digitSign(in float v, in vec2 id) {\n    return digitIsOn(10 - int((sign(v) - 1.0) * 0.5), id);\n}\n\nint digitCount(in float v) {\n    return int(floor(log(max(v, 1.0) ) / log(10.0)));\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v, in int decimalPlaces) {\n    vec2 id = floor(uv * scale);\n\n    if (0.0 < digitSign(v, id)) return 1.0;\n    v = abs(v);\n\n    int digits = digitCount(v);\n    float power = pow(10.0, float(digits));\n    \n    float offset = floor(0.1 * scale);\n    id.x -= offset;\n\n    float n;\n    for (int i = 0; i < 33; i++, id.x -= offset, v -= power * n, power /= 10.0) {\n        n = floor(v / power);\n        if (0.0 < digitIsOn(int(n), id)) return 1.0;   \n        if (i == digits) {\n            id.x -= offset;\n            if (0.0 < digitIsOn(int(12), id)) return 1.0;\n        }\n\n        if (i >= digits + decimalPlaces) return 0.0;\n    }\n\n    return 0.0;\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v) {\n    return digitFirst(uv, scale, v, 3);\n}\n\nvec3 digitIn(in vec3 color, in vec3 toMix, in vec2 uv, in float scale, in float v) {\n    float f = digitFirst(uv, scale, v);\n    return mix(color, toMix, f);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}