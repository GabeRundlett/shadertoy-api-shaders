{
    "Shader": {
        "info": {
            "date": "1725818603",
            "description": "Surfaces of revolution generated by quartic curves of the form -kt² = x⁴+Ax³+Bx²+Cx+D.\n\nMouse rotates. <up>/<down> to zoom. Click & drag red blobs in crosshairs to set A,B,C,D.\n\nFor other controls see code header.",
            "flags": 48,
            "hasliked": 0,
            "id": "4XXyz8",
            "likes": 12,
            "name": "Quartic Surfaces of Revolution",
            "published": 3,
            "tags": [
                "surface",
                "quartic",
                "revolution"
            ],
            "usePreview": 1,
            "username": "mla",
            "viewed": 115
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Quartic Surfaces of Revolution, mla, 2024.\n//\n// Surfaces of revolution generated by quartic curves of the form:\n//\n// -kt² = x⁴+Ax³+Bx²+Cx+D.\n//\n// (for the surface, put t² = y²+z²)\n//\n// Mouse rotates. \n// <up>/<down> to zoom. \n// Click & drag red blobs in crosshairs to set A,B,C,D.\n\n// 'a': flip k\n// 'k': k animation between -1 and 1 (on by default)\n// 'z' hides controls\n// 'r' autorotation\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat sgn(float x) {\n  return x < 0.0? -1.0: 1.0; // Return 1 for x == 0\n}\n\nint quadratic(float A, float B, float C, out vec2 res) {\n  float x1,x2;\n  float b = -0.5*B;\n  float q = b*b - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  x1 = C/r;\n  x2 = r/A;\n  res = vec2(x1,x2);\n  return 2;\n}\n\n// The Kahan algorithm, for explanation see:\n// https://people.eecs.berkeley.edu/~wkahan/Math128/Cubic.pdf\n\nvoid eval(float X, float B, float C, float D,\n          out float Q, out float DQ, out float B1,out float C2) {\n  float q0 = X;\n  B1 = q0+B;\n  C2 = B1*X+C;\n  DQ = (q0+B1)*X + C2;\n  Q = C2*X + D;\n}\n\nfloat qcubic(float B, float C, float D) {\n  float X,b1,c2;\n  X = -B/3.0;\n  float t,r,s,q,dq,x0;\n  eval(X,B,C,D,q,dq,b1,c2);\n  t = q; r = pow(abs(t),1.0/3.0); s = sgn(t);\n  t = -dq; if (t > 0.0) r = 1.324718*max(r,sqrt(t));\n  x0 = X - s*r;\n  if (x0 != X) {\n    X = x0;\n    for (int i = 0; i < 4; i++) {\n      eval(X,B,C,D,q,dq,b1,c2);\n      if (dq == 0.0) break;\n      X -= q/dq;\n    }\n    if (X*X > abs(D/X)) {\n      c2 = -D/X; b1 = (c2 - C)/X;\n    }\n  }\n  vec2 res;\n  if (quadratic(1.0,b1,c2,res) == 0) return X;\n  X = max(X,res[0]);\n  X = max(X,res[1]);\n  return X;\n}\n\nint quartic(vec4 coeffs, out vec4 res) {\n  float c1 = coeffs[0];\n  float c2 = coeffs[1];\n  float c3 = coeffs[2];\n  float c4 = coeffs[3];\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  psi = max(psi,0.0);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi == 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  int n0 = quadratic(1.0,alpha+a,beta+b,res.xy);\n  int n1 = quadratic(1.0,alpha-a,beta-b,res.zw);\n  if (n0 == 0) res.xy = res.zw;\n  return n0+n1;\n}\n\nint quartic(float A, float B, float C, float D, float E, out vec4 roots) {\n  int nroots;\n  // It can be advantageous to use the coefficients in the\n  // opposite order, thus solving for the reciprocal.\n  bool flip = abs(A) < 1e-2 && abs(B) < 1e-2;\n  if (abs(B/A) > abs(D/E)) flip = true;\n  vec4 coeffs = flip ? vec4(D,C,B,A)/E : vec4(B,C,D,E)/A;\n  nroots = quartic(coeffs,roots);\n  if (!flip) return nroots;\n  for (int i = 0; i < nroots; i++) {\n    roots[i] = 1.0/roots[i];\n  }\n  return nroots;\n}\n\n// Surface is x^4+Ax^3+Bx^2+Cx+D + k(y^2+z^2) = 0\n// ie. a surface of revolution of a quartic curve\nint surface(vec4 params, float k, vec3 q, vec3 r, out vec4 roots) {\n  float A = params[0], B = params[1], C = params[2], D = params[3];\n  float a = q.x, b = q.y, c = q.z;\n  float x = r.x, y = r.y, z = r.z;\n  // [[A*a^3 + a^4 + B*a^2 + C*a + k*b^2 + k*c^2 + D, 0],\n  // [3*A*a^2*x + 4*a^3*x + 2*B*a*x + C*x + 2*k*b*y + 2*k*c*z, 1],\n  // [3*A*a*x^2 + 6*a^2*x^2 + B*x^2 + k*y^2 + k*z^2, 2],\n  // [A*x^3 + 4*a*x^3, 3],\n  // [x^4, 4]]\n  float a2 = a*a, a3 = a2*a, a4 = a2*a2, b2 = b*b, c2 = c*c;\n  float x2 = x*x, x3 = x2*x, x4 = x2*x2, y2 = y*y, z2 = z*z;\n  //assert(x4 >= 1e-6);\n  float p0 = A*a3 + a4 + B*a2 + C*a + k*b2 + k*c2 + D;\n  float p1 = 3.0*A*a2*x + 4.0*a3*x + 2.0*B*a*x + C*x + 2.0*k*b*y + 2.0*k*c*z;\n  float p2 = 3.0*A*a*x2 + 6.0*a2*x2 + B*x2 + k*y2 + k*z2;\n  // When ray direction is close to x=0, the higher quartic\n  // coefficients get very small, so get better results by\n  // approximating by a quadratic. There may be better ways to\n  // solve this problem.\n  if (!key(CHAR_X) && abs(x) < 0.01) {\n    return quadratic(p2,p1,p0,roots.xy);\n  }\n  float p3 = (A+4.0*a)*x3, p4 = x4;\n  return quartic(p4,p3,p2,p1,p0,roots);\n  \n}\n\nvec3 surfacegrad(vec4 params, float k, vec3 p) {\n  float A = params[0], B = params[1], C = params[2], D = params[3];\n  float x = p.x, y = p.y, z = p.z;\n  return vec3(4.0*x*x*x+3.0*A*x*x+3.0*B*x+C, 2.0*k*y, 2.0*k*z);\n}\n\n// Lighting\nvec3 light = vec3(1,1,-1);\nfloat ambient = 0.4;\nfloat diffuse = 0.6;\nfloat specular = 0.8;\nfloat specularpow = 10.0;\nvec3 specularcolor = vec3(1);\n\nvec3 applylighting(vec3 baseColor, vec3 p, vec3 n, vec3 r) {\n  vec3 c = baseColor*ambient;\n  c += baseColor*diffuse*(max(0.0,dot(light,n)));\n  float s = pow(max(0.0,dot(reflect(light,n),r)),specularpow);\n  c += specular*s*specularcolor;\n  return c;\n}\n\nvec3 image(vec3 q, vec3 r) {\n  vec4 res;\n  vec2 s0 = getselection(0);\n  vec2 s1 = getselection(1);\n  vec4 params = 2.0*vec4(s0,s1);\n  float k = 1.0;\n  if (!key(CHAR_K)) k = cos(0.5*iTime);\n  if (key(CHAR_A)) k = -k;\n\n  int n = surface(params,k,q,r,res);\n  // Sort results in decreasing order with insertion sort\n  if (n > 1) {\n    if (res.x < res.y) res.xy = res.yx;\n  }\n  if (n > 2) {\n    if (res.y < res.z) res.yz = res.zy;\n    if (res.x < res.y) res.xy = res.yx;\n  }\n  if (n > 3) {\n    if (res.z < res.w) res.zw = res.wz;\n    if (res.y < res.z) res.yz = res.zy;\n    if (res.x < res.y) res.xy = res.yx;\n  }\n  vec3 col = vec3(0);\n  // Process from furthest\n  for (int i = 0; i < n; i++) {\n    float t = res[i];\n    if (t < 0.0) break;\n    vec3 p = q+t*r;\n    vec3 n = surfacegrad(params,k,p);\n    n = normalize(n);\n    vec3 basecolor = pow(abs(n),vec3(1.0));\n    basecolor = basecolor.bgr;\n    {\n      vec3 p1 = abs(p-round(p));\n      if (min(p1.x,min(p1.y,p1.z)) < 0.01) basecolor *= vec3(0.5);\n    }\n    //if (dot(r,n) > 0.0) n = -n; // Face forwards\n    vec3 c = applylighting(basecolor,p,n,r);\n    col = i == 0 ? c : mix(c,col,0.5);\n  }\n  return col;\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nvec3 transform(in vec3 p) {\n  vec2 s = defaultselection();\n  {\n    float theta = s.y*PI;\n    float phi = s.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    p.yz = rotate(p.yz, 0.1*iTime);\n    p.zx = rotate(p.zx, 0.222*iTime);\n  }\n  return p;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 uv = map(fragCoord);\n  float camera = 4.0;\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  vec3 p = vec3(0,0,-camera);\n  vec3 r = vec3(uv,2);\n\n  light = transform(light);\n  light = normalize(light);\n  p = transform(p);\n  r = transform(r);\n  r = normalize(r);\n  vec3 col = vec3(0);\n  if (!key(CHAR_Z)) {\n    float px = fwidth(uv.x);\n    for (int i = 0; i < 2; i++) {\n      vec2 d = abs(uv-getselection(i));\n      col = mix(vec3(1),col,0.95+0.05*smoothstep(-px,px,min(d.x,d.y)-0.005));\n      col = mix(vec3(1,0,0),col,0.6+0.4*smoothstep(-px,px,length(d)-0.02));\n    }\n  }\n  vec3 c = image(p,r);\n  if (c != vec3(0)) col = 0.25*col+c;\n  col = clamp(col,0.0,1.0);\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 t, vec2 uv) {\n  //setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        t.x = -1.0;\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n      if (t.x <= 0.0 && iMouse.z > 0.0) t.zw = map(iMouse.xy);\n    } else if (iFrame == 0 || t.w != 1234.0) {\n      t.xy = initselection(i-1); // Current coordinates\n      t.w = 1234.0;\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define map(p) ((2.0*(p) - iResolution.xy)/iResolution.y)\nint nselections = 2;\nfloat scale = 1.0;\nvec2 initselection(int i) {\n  if (i == 0) return vec2(-1,0);\n  return vec2(1,-0.5);\n}\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n#define defaultselection() (texelFetch(iChannel2,ivec2(0,3),0).zw)\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nbool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\nconst float PI =  3.141592654;\nconst float TWOPI = 2.0*PI;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}