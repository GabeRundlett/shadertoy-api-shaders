{
    "Shader": {
        "info": {
            "date": "1585756827",
            "description": "Inspired by glow-in-the-dark figures.\nThe luminescent effect is derived from the pseudo-SSS technique.",
            "flags": 0,
            "hasliked": 0,
            "id": "tsfcWf",
            "likes": 14,
            "name": "kraken",
            "published": 3,
            "tags": [
                "raymarching",
                "sss",
                "kraken",
                "octopus",
                "luminous"
            ],
            "usePreview": 0,
            "username": "yuntaRobo",
            "viewed": 555
        },
        "renderpass": [
            {
                "code": "const float PI = 3.1415926;\nconst float E = 0.005;\n\nconst vec3 light_dir = normalize(vec3(-0.6, 0.2, -1.0));\nconst vec3 light_color = vec3(0.3, 0.6, 1.0);\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nmat2 rotate2D(float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/smin\nvec2 smin(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return vec2(mix(d2, d1, h) - k * h * (1.0 - h), h);\n}\n\n// https://gaz.hateblo.jp/entry/2019/05/17/231141\nvec2 spfold4(vec2 p, float k)\n{\n    const int n = 4;\n    for(int i = 0; i < n; i++)\n    {\n        float a = PI / exp2(float(i));\n        vec2 v = vec2(cos(a), sin(a));  \n        p -= 2.0 * smin(0.0, dot(p, v), k).x * v;\n    }\n    return p;\n}\n\nfloat deBody(vec3 p, float t)\n{\n    float a = atan(p.z, p.x);\n    p *= vec3(1.0, 0.7, 1.0);\n    p += vec3(0.0, 0.7 - sin(t) * 0.25, 0.0);\n    float d = length(p) - 0.9 - sin(a * 20.0) * 0.05;\n    d = abs(d) - 0.2;\n    return d;\n}\n\nfloat deLeg(vec3 p, float h, float r)\n{\n    float a = atan(p.z, p.x);\n    p.y -= clamp(p.y, 0.0, h);\n    float d = length(p) - r - sin(a * 10.0) * pow(r, 0.8) * 0.05;\n    return d;\n}\n\nfloat deOctopus(vec3 p)\n{\n    float t = iTime - pow(length(p), 0.5) * 1.5;\n    \n    p.y *= -1.0;\n    p.xz *= rotate2D(0.45);\n    p.yz *= rotate2D(1.2 + sin(iTime * 0.333) * 0.25);\n    \n    float body = deBody(p, t);\n    \n    p.xz *= rotate2D(0.4);\n    p.xz = spfold4(p.xz, 0.04);\n    float h = 5.0;\n    float r = exp(-length(p) * 0.7) * 0.75;\n    mat2 m = rotate2D(0.35 + cos(length(p) * 1.75 + t) * 0.1);\n    p.yz *= m;\n    float leg = deLeg(p, h, r);\n    p.yz *= m;\n    leg = smin(leg, deLeg(p, h, r), 0.04).x;\n\n    float d = smin(body, leg, 0.3).x;\n    d *= 0.5;\n    \n    return d;\n}\n\nfloat deSea(vec3 p)\n{\n    float t = iTime - pow(length(p), 0.5) * 1.5;\n    \n    p.xz *= rotate2D(t);\n    float d = p.y + 0.2\n        - sin(p.x * 2.0) * 0.05\n        - sin(p.z * 3.111) * 0.05\n        - (sin(t * 0.333) * 0.5 + 0.5) * 0.5;\n    return d;\n}\n\nvec2 de(vec3 p)\n{\n    vec2 o = smin(deOctopus(p), deSea(p), 0.1);\n    return o;\n}\n\nfloat sss(vec3 o, vec3 dir, float ed, float la)\n{\n    const int ei = 4;\n    float accum = 0.0;\n    float st = ed / float(ei);\n    float d = st;\n    for (int i = 0; i < ei; i++)\n    {\n        accum += max(de(o + dir * d).x, 0.0);\n        d += st;\n    }\n    accum = clamp(accum / ed / (float(ei) * 0.5 + 0.5), 0.0, 1.0);\n    return exp(-(1.0 - accum) * la);\n}\n\nfloat luminous(vec3 o, vec3 dir, float ed, float la)\n{\n    const int ei = 16;\n    float accum = 0.0;\n    float st = ed / float(ei);\n    float d = st;\n    for (int i = 0; i < ei; i++)\n    {\n        accum += max(-de(o + dir * d).x / d, 0.0);\n        d += st;\n    }\n    accum = clamp(accum / float(ei), 0.0, 1.0);\n    return exp(-(1.0 - accum) * la);\n}\n\n// iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p)\n{\n    float h = E;\n    vec2 k = vec2(1.0, -1.0);\n    return normalize(\n            k.xyy * de(p + k.xyy * h).x + \n            k.yyx * de(p + k.yyx * h).x + \n            k.yxy * de(p + k.yxy * h).x + \n            k.xxx * de(p + k.xxx * h).x\n        );\n}\n\nvoid trace(Ray ray, inout vec3 color, float md)\n{\n    float ad = 0.0;\n    for (float i = 1.0; i > 0.0; i -= 1.0 / 150.0)\n    {\n        vec2 o = de(ray.pos);\n        if (o.x < E)\n        {\n            // normal\n            vec3 n = normal(ray.pos);\n            \n            // fresnel\n            float f0 = 0.075;\n            float f = f0 + (1.0 - f0) * pow(1.0 - max(dot(-ray.dir, n), 0.0), 5.0);\n            \n            // color\n            vec3 em = vec3(0.1, 1.0, 0.3);\n            \n            vec3 color1 = luminous(ray.pos, ray.dir, 0.35, 7.5) * em * 60.0;\n            color1 += sss(ray.pos, light_dir, 0.35, 5.0) * light_color * 5.0;\n            \n            vec3 color2 = sss(ray.pos, ray.dir, 0.5, 5.0) * vec3(0.0, 0.0, 1.0) * 2.0 * f;\n            color2 += sss(ray.pos, light_dir, 0.5, 6.0) * light_color * 0.3 * f;\n            color2 += exp(-deOctopus(ray.pos) * 17.5) * (em + light_color) * 0.01 * exp(-length(ray.pos) * 0.25);\n            \n            color += mix(color2, color1, pow(o.y, 5.0));\n            \n            color *= exp(-ad * ad * 0.03);\n            \n            return;\n        }\n\n        ray.pos += ray.dir * o.x;\n        ad = ad + o.x;\n        if (ad > md)\n        {\n            break;\n        }\n    }\n\n    // background\n    color += pow(max(dot(ray.dir, light_dir), 0.0), 800.0) * light_color * 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // view\n    vec3 view = vec3(-1.0, 1.0, 6.75);\n    vec3 at = normalize(vec3(-2.0, 0.0, 0.0) - view);\n    vec3 right = normalize(cross(at, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, at);\n    float focallength = 2.25;\n\n    // ray\n    Ray ray;\n    ray.pos = view;\n    ray.dir = normalize(right * p.x + up * p.y + at * focallength);\n\n    // ray marching\n    trace(ray, color, 20.0);\n\n    // cheap tonemapping\n    // https://www.desmos.com/calculator/adupt0spl8\n    float k = 0.75;\n    color = mix(color, 1.0 - exp(-(color - k) / (1.0 - k)) * (1.0 - k), step(k, color));\n\n    // gamma correction\n    color = pow(color, vec3(0.454545));\n\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}