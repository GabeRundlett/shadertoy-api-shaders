{
    "Shader": {
        "info": {
            "date": "1650580239",
            "description": "noi",
            "flags": 0,
            "hasliked": 0,
            "id": "stffR8",
            "likes": 9,
            "name": "voronoi from scratch",
            "published": 3,
            "tags": [
                "cineshader"
            ],
            "usePreview": 0,
            "username": "mAmaro",
            "viewed": 3622
        },
        "renderpass": [
            {
                "code": "#if 0\nfloat Circle(vec2 uv, vec2 Pos, float Rad)\n{\n    //TODO(): How tf do i do radius correctly????\n    return smoothstep(0.05, 0.044, 1./Rad*length(uv-Pos));\n}\n\nfloat UnilatSin(float Freq)\n{\n    return 1.0+0.5*cos(iTime*Freq);\n}\n\nvec2 Noise(vec2 Pos, float Freq)\n{\n    vec3 a = fract(Pos.xyx * vec3(123.45, 345.678, 567.89));\n    a += dot(a, a + 345.578*UnilatSin(Freq));   \n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float AR = iResolution.x/iResolution.y;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.yy;\n    vec3 Col = vec3(0.1,.1,.03);\n    //uv.x = abs(uv.x);\n    //uv = vec2(0.17*atan(uv.x, uv.y), 0.2*log(length(0.6*uv)));\n    float Dots = .0;\n    \n    float MinDist = 100.0;\n    float VCI = 0.; //VertCellIndex\n    for(float i=0.; i<50.; i+=1.)\n    {\n        float RowCount = 10.0;//*UnilatSin(iTime*0.0001);\n        vec2 Margin = vec2(0.4, 0.3);\n        vec2 Step = vec2(0.1, 0.09);\n        vec2 Point = vec2((-0.5*AR)+Margin.x+Step.x*mod(i,RowCount),\n        -0.5+Margin.y+Step.y*floor(i/RowCount));\n        Point+=sin(Noise(vec2(i), 0.0)*iTime)*0.4;\n        \n        Dots += Circle(uv, Point, 0.3);\n        float Dist = length(uv-Point);\n        \n        if(Dist<MinDist)\n        {\n            MinDist = Dist;\n            VCI = i;\n        }\n    }\n   \n   //TODO(): Spatial partition\n   \n   vec4 Output = vec4(Col + Dots + floor(250.0*mod(MinDist,0.03))*4.1,1.0);\n   if(fragCoord.x/iResolution.x <.5)\n   {\n       Output = 1.-vec4(Col +Dots + floor(250.0*mod(MinDist,0.03))*4.1,1.0); \n   }\n  \n    fragColor = Output;\n}\n\n#elif 1\n\nvec2 Noise(vec2 P)\n{\n    vec3 a = fract(P.xyx * vec3(123.45, 345.678, 567.89));\n    a += dot(a, a + 518.);   \n    return fract(a.y*a.xz);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, P,\n         U =  u / R.y - vec2(.4, .3);\n    \n    float d = 9.;\n    for(int N=10, i=0; i<50; i++)\n        P = .1 * vec2( i%N, i/N ) \n            + sin( Noise(vec2(i)) *iTime ) *.4,\n        d = min( d, length(U-P) );\n\n   \n   O = vec4( smoothstep( 0., 4./R.y, .03*abs(2.*fract(d/.03+.6)-1.) ) );\n   if(u.x < .5*R.x )  O = 1.-O; \n}\n\n#else\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, d = R;\n    for(int n=10, i=0; i<50; i++)\n        d = min( d, length(   .1 * vec2( i%n, i/n ) \n                            + .4 * sin( fract(sin(vec2(i)* R) * 4e4 ) *iTime ) \n                            -  u / R.y + vec2(.4, .3) ) );\n\n   O += R.y/1e2* abs(2.*fract(d.x/.03+.6)-1.) -O;\n   if(u.x < .5*R.x )  O = 1.-O; \n}\n#endif\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}