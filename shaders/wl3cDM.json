{
    "Shader": {
        "info": {
            "date": "1609894584",
            "description": "This is a variation of https://www.shadertoy.com/view/MlcSWS\napproximating the arithmetic mean of the fourier partial sums instead.",
            "flags": 8,
            "hasliked": 0,
            "id": "wl3cDM",
            "likes": 2,
            "name": "Fejer summation approximation",
            "published": 3,
            "tags": [
                "sound",
                "antialias",
                "fourier",
                "squarewave",
                "synth",
                "bandlimited",
                "gibbs",
                "fejer"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 445
        },
        "renderpass": [
            {
                "code": "/*\nVariation of https://www.shadertoy.com/view/MlcSWS\n\nThe Fejer summation method is to take the average over the\npartial sums of the fourier series of the function.\nWhile this approximation is worse in the least squares sense,\nit behaves better in some other areas. In particular,\nit doesn't show the typical overshoot of the Gibbs phenonemon.\n\nWhile the original method approximates the Dirichlet kernel\nwith a sinc function, here the Fejer kernel is approximated with a squared sinc function.\nBecause the Fourier partial sums are the convolution with a Dirichlet kernel\nand the Fejer summation the convolution with a Fejer kernel, the\nFourier approximation can be approximated with the sine integral and\nthe Fejer summation with the integral of the squared sinc, which\ncan be computed using the sine integral.\n\nSee for example: https://en.wikipedia.org/wiki/Fej%C3%A9r_kernel\n*/\n\nconst float eps=.00034526;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float border=1.3/iResolution.y;\n    \n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    float t0=mod(iTime,freq_modulus);\n    \n    float audio_freq=get_audio_freq(t0);\n    \n    n=int((iSampleRate*.5+1.)/(2.*audio_freq)+.5);\n\n\tfloat freq=.0002*audio_freq;\n\n\tfloat zoom=5.;\n    \n    vec2 uv1=uv;\n    uv1.y-=.25*sign(uv.y);\n    \n    uv1*=zoom;\n\n\tfloat dis1=abs(integral_fejer_squarewave(uv1.x,freq)-uv1.y);\n\tdis1/=zoom*length(vec2((integral_fejer_squarewave(uv1.x,freq)-integral_fejer_squarewave((uv1.x+eps),freq))/eps,1.));\n\n\tfloat dis2=abs(additive_fejer_squarewave(uv1.x,freq)-uv1.y);\n\tdis2/=zoom*length(vec2((additive_fejer_squarewave(uv1.x,freq)-additive_fejer_squarewave((uv1.x+eps),freq))/eps,1.));\n\n\tfloat dis3=abs(simple_squarewave(uv1.x,freq)-uv1.y);\n\tdis3/=zoom;\n\n\tfloat thickness=zoom*.0001;\n\n\tvec3 bg_col=vec3(0);\n\n\tvec3 add_col=vec3(1);\n\tvec3 int_col=vec3(1,0,0);\n\tvec3 smp_col=vec3(0,1,0);\n\n\tvec3 color;\n    \n    if(uv.y>0.){\n    \tcolor=mix(smp_col,bg_col,smoothstep(0.,border,dis3-thickness));\n\t\tcolor=mix(add_col,color,smoothstep(0.,border,dis2-thickness));\n\t\tcolor=mix(int_col,color,smoothstep(0.,border,dis1-thickness));\n    }\n    else{\n        float t1=mod(iTime,wave_modulus);\n        \n        int wave_index=get_wave_index(t1);\n        \n        if(wave_index==0){\n        \tcolor=mix(smp_col,bg_col,smoothstep(0.,border,dis3-thickness));\n        }\n        else if(wave_index==1){\n\t\t\tcolor=mix(add_col,bg_col,smoothstep(0.,border,dis2-thickness));\n        }\n        else{\n\t\t\tcolor=mix(int_col,bg_col,smoothstep(0.,border,dis1-thickness));\n        }\n    }\n    \n\tfragColor=vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float pi=3.1416;\nconst int max_n=100;\nint n;\n\nconst float freq_modulus=18.;\nconst float wave_modulus=6.;\n\nfloat polynomial(vec4 a, float x){\n\treturn (((x*x + a[0])*x*x + a[1])*x*x + a[2])*x*x+a[3];\n}\n\nfloat rational(vec4 a, vec4 b, float x){\n\n\tfloat numerator=polynomial(a,x);\n\tfloat denominator=polynomial(b,x);\n\n\treturn numerator/denominator;\n}\n\nfloat Si(float x){\n\n\tfloat sgn=1.;\n\n\tif(x<0.){\n\t\tsgn=-1.;\n\t\tx=-x;\n\t}\n\n\tif(x<1.){\n\t\tvec4 a = vec4(-1./35280.,1./600.,-1./18.,1.)*3265920.;\n\t\treturn sgn*polynomial(a,x)/3265920.*x;\n\t}\n\telse{\n\n\t\tvec4 a_f=vec4(38.027264,265.187033,335.67732,38.102495);\n\t\tvec4 b_f=vec4(40.021433,322.624911,570.236280,157.105423);\n\n\t\tfloat f=1./x*rational(a_f,b_f,x);\n\n\t\tvec4 a_g=vec4(42.242855,302.757865,352.018498,21.821899);\n\t\tvec4 b_g=vec4(48.196927,482.485984,1114.978885,449.690326);\n\n\t\tfloat g=1./(x*x)*rational(a_g,b_g,x);\n\n\t\treturn sgn*(pi/2.-f*cos(x)-g*sin(x));\n\t}\n}\n\nfloat integral_fejer_squarewave(float x, float freq){\n\tx*=freq;\n\n\tfloat sgn=1.;\n\n\tif(fract(x)>=0.25 && fract(x)<0.75){\n\t\tsgn=-1.;\n\t}\n    \n\tx=mod(x+.25,.5)-.25;\n    \n    if(x==0.){\n        return 0.;\n    }\n    \n\tfloat a=2.*pi*(2.*float(n)+1.);\n\treturn sgn*(Si(x*a)+(cos(a*x)-1.)/(a*x))*2./pi;\n}\n\nfloat additive_fejer_squarewave(float x, float freq){\n\n\tfloat sum=0.;\n\n\tfor(int k=0;k<max_n;k++){\n\t\tif(k<n){\n\t\t\tsum+=(1.-(2.*float(k)+1.)/(2.*float(n)+1.))*sin(mod(2.*pi*(2.*float(k)+1.)*freq*x,2.*pi))/(2.*float(k)+1.);\n\t\t}\n\t}\n\n\treturn sum*4./pi;\n}\n\n\nfloat simple_squarewave(float x, float freq){\n\tfloat sgn=-sign(mod(x,1./freq)-.5/freq);\n\treturn sgn;\n}\n\nfloat get_audio_freq(float t){\n    if(t<6.){\n        return 1046.5022612024;//C8\n    }\n    else if(t<12.){\n        return 2637.0204553030;//E9\n    }\n    else{\n        return 4186.0090448096;//C10\n    }\n}\n\nint get_wave_index(float t){\n    if(t<2.){\n    \treturn 0;\n    }\n    else if(t<4.){\n\t\treturn 1;\n    }\n    else{\n\t\treturn 2;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec2 mainSound( in int samp,float time){\n    \n    float t0=mod(time,freq_modulus);\n    float t1=mod(time,wave_modulus);\n    \n    float audio_freq=get_audio_freq(t0);\n    n=int((iSampleRate*.5+1.)/(2.*audio_freq)+.5);\n    \n    int wave_index=get_wave_index(t1);\n    \n    if(wave_index==0){\n    \treturn vec2(.2*simple_squarewave(t0,audio_freq));\n    }\n    else if(wave_index==1){\n    \treturn vec2(.2*additive_fejer_squarewave(t0,audio_freq));\n    }\n    else{\n    \treturn vec2(.2*integral_fejer_squarewave(t0,audio_freq));\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}