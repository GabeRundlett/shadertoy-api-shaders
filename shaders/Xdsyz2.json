{
    "Shader": {
        "info": {
            "date": "1488980022",
            "description": "i want a smoother seesaw-like:\n\ni do not want to fourier or taylor or bezier a square wave or seesaw to get a more continuous smooth variant of them, but want a simpler solution for something THAT specific.\n\nso far i am is not too good at that.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xdsyz2",
            "likes": 1,
            "name": "wave slanted sine rounded seesaw",
            "published": 3,
            "tags": [
                "wave",
                "sine",
                "egg",
                "seesaw"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 718
        },
        "renderpass": [
            {
                "code": "//goals is to have a move continuous/smooth variant of a seesaq or square wave.\n//but without fourier or taylor approximation, as they are general and low performance.\n//and this specific goal may have faster folutions.\n\n//based on \"egg shaped sinusoids\" https://www.shadertoy.com/view/lld3DS\n\n//modulo repeater:\n#define pMod(x,d) (mod(x+d*.5,d)-d*.5)\n\n\nfloat SeeSaw(float x,float w,float a){return mod(x,w)*a;}\n//set [a]mplitude = 1/[w]avelength\nfloat SeeSaw2(float x,float w){return SeeSaw(x,w,1./w);}\n///return sin(t), shifted to range [0...1]\n//float sinP(float t){return(sin(t)+1.)*.5;}\n\n//smin, common, slow, favoured for having continuous derivatives\nfloat smin(float a,float b,float k){float h=clamp(.5+.5*(a-b)/k,0.,1.);return mix(a,b,h)-k*h*(1.-h);}\n//smin exponential, fastest, less precise, nicely works with negative [k]\nfloat SRampExp(float x,float k){return x/(1.-exp2(x*k));}\nfloat sminExp(float a,float b,float k){return a+SRampExp(b-a,k);}\n//float smaxExp(float a,float b,float k){return b-SRampExp(b-a,k);}//not needed, just negate k\n//smin cubic, fast and precise, fails on negative [k]\nfloat SRampCub(float x,float k){return .5*(x-sqrt(x*x+k));}\nfloat sminCub(float a,float b,float k){return a+SRampCub(b-a,k);}\nfloat smaxCub(float a,float b,float k){return b-SRampCub(b-a,k);}\n\n/*\n----------\nsin()-egg-shapes:\ny=sqrt(sin(x));//is a chain of half circles\ny=sqrt(abs(sin(x)))+sqrt(abs(sin(1.3*x)));// produces a chain of egg shapes out of sin().\ny=sqrt(abs(sin(x)+.1*sin(x+x)))//chain of alternating eggs. \ny=-sqrt(pow(y,1.5)-sqrt(a)); //based on egg shape by Florian Blaschke \n//defined for range [0..a]\n*/\n\nfloat curve(in float i){\n  i*=-2.5;\n\n  float s=sin(iTime*4.)*.5+.5;\n  \n  i=pMod(i,asin(1.)*4.);\n  return .5*(sin(i)+0.15*sin(2.*i));//is too much like fourier.\n  return .5*pow(sin(i)+0.15*sin(2.*i),2.);//is too much like fourier.\n  //return pow((sin(i)+.125*sin(2.*i)),2.) ;\n    \n    \n  //smin is not the way to go, dummy!\n  //return sminCub(SeeSaw2(i,1.),SeeSaw2(i+.1,1.),s);\n  //return sminCub(SeeSaw2(i,1.),1.,s);\n    \n  //return SeeSaw2(i,1.);\n    \n    \n    \n  return pow((abs(sin(i)+.5*sin(-i*2.))),s);//i like this one a bit\n    \n  //return sqrt(abs(sin(i)))+sqrt(abs(sin(1.3*i)));\n  return pow((abs(sin(i)-.5*sin(i+i))),s);\n    \n  //experimental dump of reminders.\n  i=pMod(i,asin(1.)*2.*.63);   \n  return pow(cos(asin(i)),4.);//is is a sine again?\n  return pow(cos(asin(i)),2.);//pow(x,2) is unsurprisingly parabolic.\n  return cos(asin(i));//is half-circle\n  return sin(acos(i));//is half-circle\n  return sin(i);\n  return pow(sin(i),8.);//commonly used for \"heartbeat\"\n}\n\nfloat lSeg(in vec2 i){\n  return i.y-curve(i.x);\n}\n\n\n\n//Code for visualisation:\n\n#define res iResolution.xy\n//translate fragments to a frame; scale, center, aspectRatio.\nvec2 frame(vec2 a){a=(a-.5*res.xy)/res.y;\n a*=4.;//a=vec2(-a.y,a.x);//rotate 90 deg.\n return a;}//not for horizonral screens where res.x<res.y ??\n\n\n//2d rotation:\n//#define rot(a) {float s=sin(a);float c=cos(a);mat2(c,-s,s,c);}\n\n//2d \"SINGLE rotation matrix\" that is acttually just mirroring on a half-rotated axis:\n#define r2s(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//its caveat is that applying it multiple times just mirrors the point back and forth.\n//testable in https://www.shadertoy.com/view/MtKGWD\n\n\nvoid mainImage(out vec4 r,in vec2 i){r.a=1.;\n vec2 p=frame(i);//aspect ratio and zoom of the view to focsus coordinate systems.\n //float dx=res.x/res.y;\n //vec2 mr=iMouse.xy/res.xy;//relative mouse position on the screen\n float s=sin(iTime);\n float t=sin(199.+s*.3)+.5;//swivel over time for 3 color dimensions displaying 3 SDF\n //p.x+=s+.5;//move whole distance field (frame) left-right.\n //p*=r2s(iTime);//single rotation over time.\n //p.x+=.5;//make distance field rotate around segment center\n vec3 c=vec3(lSeg(p));\n //c*=2.;//c+=1.;//scaling the distance, scaling the colors you see to visualize distance.\n c.r=SeeSaw2(c.r,1.);\n c.g=SeeSaw2(c.g,sqrt(5.)*.5-.5);//golden ratio 0.61...\n c.b=SeeSaw2(c.b,asin(1.)*1.);    //pi/2         1.57... swiveling over time.\n //log2(3.);//relevant for hexagonal tiling     1.85...\n \n if(abs(c.g)<.1)c*=vec3(2.);//dark border line\n else c*=.2;\n r.rgb=c;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}