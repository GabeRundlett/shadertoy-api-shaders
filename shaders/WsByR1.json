{
    "Shader": {
        "info": {
            "date": "1586036143",
            "description": "The Live Coders Conference - Online on twitch.tv April 9, 2020 - https://captcalli.github.io/LiveCodersConf/\n\nCreated a few shaders inspired by the online event, these shaders are not officially adopted just made for fun and to promote the event.",
            "flags": 0,
            "hasliked": 0,
            "id": "WsByR1",
            "likes": 10,
            "name": "The Live Coders Conference - 3",
            "published": 3,
            "tags": [
                "2d",
                "fbm",
                "tlc"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 475
        },
        "renderpass": [
            {
                "code": "// Created by mrange/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 Unported License.\n\n// The Live Coders Conference - Online on twitch.tv April 9, 2020 - https://captcalli.github.io/LiveCodersConf/\n// Created a few shaders inspired by the online event, these shaders are not officially adopted just made for fun and to promote the event.\n\n// 2D shape created by combining 2D primitives from IQ's blog:\n//  https://iquilezles.org/articles/distfunctions2d\n// pmin from IQ's blog on smooth minimum functions:\n//  https://iquilezles.org/articles/smin\n// warped fbms from IQ's blog:\n//  https://iquilezles.org/articles/warp\n\n#define PI     3.141592654\n#define TAU    (2.0*PI)\n#define SCA(a) vec2(sin(a), cos(a))\n#define TIME   (iTime+120.0)\n#define TTIME  (TIME*TAU)\n#define PERIOD 600.0\n\nconst float a1 = PI/2.0;\nconst float a2 = PI*4.5/6.0;\n\nconst vec2 sca1 = SCA(a1);\nconst vec2 sca2 = SCA(a2);\n\nconst mat2 frot = mat2(0.80, 0.60, -0.60, 0.80);\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat noise(vec2 p) {\n  float a = sin(p.x);\n  float b = sin(p.y);\n  float c = 0.5 + 0.5*cos(p.x + p.y);\n  float d = mix(a, b, c);\n  return d;\n}\n\nfloat fbm(vec2 p) {    \n  float f = 0.0;\n  float a = 1.0;\n  float s = 0.0;\n  float m = 2.0-0.1;\n  for (int x = 0; x < 4; ++x) {\n    f += a*noise(p); p = frot*p*m;\n    m += 0.01;\n    s += a;\n    a *= 0.45;\n  }\n  return f/s;\n}\n\nfloat warp(vec2 p, float offset, out vec2 v, out vec2 w) {\n  vec2 vx = vec2(0.0, 0.0);\n  vec2 vy = vec2(3.2, 1.3);\n\n  vec2 wx = vec2(1.7, 9.2);\n  vec2 wy = vec2(8.3, 2.8);\n\n  vec2 off = (1.75 + 0.5*cos(TTIME/60.0))*vec2(-5, 5);\n\n  p += mix(vec2(0.0), off, 0.5 + 0.5*tanh(offset));\n\n  rot(vx, TTIME/1000.0);\n  rot(vy, TTIME/900.0);\n\n  rot(wx, TTIME/800.0);\n  rot(wy, TTIME/700.0);\n\n  vec2 vv = vec2(fbm(p + vx), fbm(p + vy));  \n  vec2 ww = vec2(fbm(p + 3.0*vv + wx), fbm(p + 3.0*vv + wy));\n\n  float f = fbm(p + 2.25*ww);\n\n\n  v = vv;\n  w = ww;\n\n//  return tanh(f);\n  return f;\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = max(k-abs(a-b), 0.0)/k;\n  return min(a, b) - h*h*k*(1.0/4.0);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b, vec4 r) {\n  r.xy = (p.x>0.0)?r.xy : r.zw;\n  r.x  = (p.y>0.0)?r.x  : r.y;\n  vec2 q = abs(p)-b+r.x;\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat arc(vec2 p, vec2 sca, vec2 scb, float ra, float rb) {\n  p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n  p.x = abs(p.x);\n  float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n  return sqrt(dot(p,p) + ra*ra - (2.0 - 0.000001)*ra*k) - rb;\n}\n\nfloat spokes(vec2 p, float s) {\n  vec2 pp = toPolar(p);\n  pp.y += TTIME*10.0/PERIOD;\n  mod1(pp.y, TAU/10.0);\n  pp.y += PI/2.0;\n  p = toRect(pp);\n  float ds = box(p, s*vec2(0.075, 0.5), s*vec4(0.04));\n  return ds;\n}\n\nfloat arcs(vec2 p, float s) {\n  \n  float d1 = arc(p, sca1, sca2, s*0.275, s*0.025);\n  float d2 = arc(p, sca1, sca2, s*0.18, s*0.025);\n  \n  return min(d1, d2);\n}\n\nfloat meeple(vec2 p, float s) {\n  float dh = box(p - s*vec2(0.0, -0.035), s*vec2(0.07, 0.1), s*vec4(0.065));\n  float dc = box(p - s*vec2(0.0, -0.22), s*vec2(0.15, 0.04), s*vec4(0.05, 0.02, 0.05, 0.02));\n  \n  return pmin(dh, dc, s*0.115);\n}\n\nfloat theLiveCoders(vec2 p, float s) {\n  float ds = spokes(p, s);\n  float dc = circle(p, 0.375*s);\n  float da = arcs(p, s);\n  float dm = meeple(p, s);\n  \n  float d = ds;\n  d = min(d, dc);\n  d = max(d, -da);\n  d = max(d, -dm);\n  \n  return d;\n}\n\nfloat df(vec2 p) {  \n  return theLiveCoders(p, 3.0);\n}\n\nvec3 normal(vec2 p, float offset) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(0.0001, 0);\n  \n  vec3 n;\n  n.x = warp(p + e.xy, offset, v, w) - warp(p - e.xy, offset, v, w);\n  n.y = 2.0*e.x;\n  n.z = warp(p + e.yx, offset, v, w) - warp(p - e.yx, offset, v, w);\n  \n  return normalize(n);\n}\n\n\nvec3 postProcess(vec3 col) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75));\n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= iResolution.x/iResolution.y;\n\n  p *= 1.65;\n  vec3 col = vec3(1.0);\n \n  float d = df(p);\n  p += -0.025*TTIME*vec2(-1.0, 1.0);\n \n  vec2 v;\n  vec2 w;\n \n  float f = warp(p, d, v, w);\n  vec3 n = normal(p, d);\n\n  vec3 lig = normalize(vec3(0.6, -0.4, -0.4));\n//  rot(lig.xz, TTIME/100.0);\n  float dif = max(dot(lig, n), 0.5);\n\n  const vec3 col1 = vec3(0.1, 0.3, 0.8);\n  const vec3 col2 = vec3(0.7, 0.3, 0.5);\n  \n  float c1 = dot(normalize(lig.xz), v)/length(v);\n  float c2 = dot(normalize(lig.xz), w)/length(w);\n  \n  col = pow(dif, 0.75)*tanh(pow(abs(f + 0.5), 1.5)) + c1*col1 + c2*col2;\n  col += 0.25*vec3(smoothstep(0.0, -0.0125, d));\n\n  col = postProcess(col);\n\n  col *= smoothstep(0.0, 16.0, iTime*iTime);\n  \n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}