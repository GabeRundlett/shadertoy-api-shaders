{
    "Shader": {
        "info": {
            "date": "1501496855",
            "description": "A basis 2d shader for trigonometry \n\nwith the ability \n- to drag your mouse over a larger .xy area, while always having vec2(0,0) in the view.\n- to zoom in on x=0 and y=0;\n- easily tell rotation and coordinates in Cartesian space (every square is unique)",
            "flags": 0,
            "hasliked": 0,
            "id": "4djfRc",
            "likes": 2,
            "name": "viewZoom sawCos template",
            "published": 3,
            "tags": [
                "zoom",
                "template",
                "subpixel",
                "view",
                "sawcos",
                "viewzoom"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 973
        },
        "renderpass": [
            {
                "code": "//sharpness of FullScreenAntiAliasing\n#define fsaa 5./iResolution.y\n//maximum view zoom\n#define viewZoom 20.\n\n//setting infinity lower han largest float can have its advantages.\n#define Infinity 99999.\n\n//view scaling\n#define fr(u) (u-.5*iResolution.xy)*viewZoom/iResolution.y\n\n//3.14=ratio of unitCircleCircumference to diameter=\n#define pi acos(-1.)\n//0.61=golden ratio; phi-1=1/phi,smaller solution\n#define phi (sqrt(5.)*.5-.5)\n//1.61=Golden Ratio; Phi-1=1/Phi,larger  solution\n#define Phi (sqrt(5.)*.5+.5)\n\n//modulo tiled grid.\nfloat grid(vec2 u){u=abs(fract(u)-.5);\n u.x=max(max(u.x,u.y),1./8.);u.x=u.x*8.-3.;\n u.x=fract(u.x)/(4.-(floor(u.x+3.)));                   \n u.x*=u.x;return u.x*u.x;}\n\nfloat sawCos(vec2 u){//u*=2.;//sale here, or better outside of this function.\n u.x=fract(u.x);u+=(1.- 2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0., 1.)*pi)*.5+.5;}\nfloat sawCos(vec2 u,float b){u.y=b;return sawCos(u);}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,fsaa);}\n//mix smoothstep(aa,-aa,c) with a hint of s, diminishing over c.\n#define sci() mix(s,smoothstep(fsaa,-fsaa,c),.85)/(abs(c)+.5)\nvec3 sawCos3(vec3 c,float b){vec3 s=vec3(sawCos(c.r,b),sawCos(c.g,b),sawCos(c.b,b));return sci();}\nvec2 sawCos2(vec2 c,float b){vec2 s=vec2(sawCos(c.r,b),sawCos(c.g,b));return sci();}\n\n//use a matrix as if it is a list.\nfloat gm3(mat3 a,int n){return a[n/3][n%3];}\n//return a[int(n/3.)][int(mod(n,3.))];}//float variant\n#define gp(a) gm3(co,a)\n\n//vector dotproduct with vecN(1) is a faster sum.\n//float sum(float a,float b,float c,float d){return dot(vec4(a,b,c,d),vec4(1.));}\n//float sum(float a,float b,float c){return dot(vec3(a,b,c),vec3(1.));}\n\n//just some demo y=f(x) functions\nfloat fx(vec2 u,vec2 m){\n float x=u.x;\n float logE = log(x);\n float expE = exp(x);\n float pow3 = (x*1.)*(x*x);\n float pow4 = (x*x )*(x*x);\n mat3 co=mat3(-10,8,-6,5,-6,4,-7,-2,1);//9 coeficients to a polynomial should be enough\n //co=1.co; //reciprocal coeficcients\n //co*=.1;//smaller coefficients\n //float polyn=x*gm3(co,0)-u.y;\n   \n float polyn=x*(gp(0)+x*(x*(gp(1)+x*(x*(gp(2)+x*(x*(gp(3)+x*gp(4)+x*(gp(5)))))))));\n float cosine=cos(x*.1)*10.;//a large amplitude large interval cosine.\n x*=.1;\n float fourier=cos(x*gp(0))\n              +cos(x*gp(1)*2.)\n              +cos(x*gp(2)*3.)\n              +cos(x*gp(3)*5.)\n              +cos(x*gp(4)*7.)\n              +cos(x*gp(5)*13.);//cosines, scaled by primes.\n    \n //return fourier;\n \n //return cosine;\n //return logE; //makes negative blue green, i see no way to cath this NaN\n return fourier+cosine+x*x;\n}\n\n//explicit isnan() returns if v=NaN\nbool isn(float v ){return (abs(v)>0.||v==.0 );// ? false : true;\n  // important: some nVidias failed to cope with version below.\n  // Probably wrong optimization.\n  /*return ( val <= 0.0 || 0.0 <= val ) ? false : true;*/\n}\n\n//m.y sets zoom (makes sense for waveforms)\n//length sets zoom\n//#define scaledot(u) length(m)*u\n//length*length sets zoom, for EXTREME zoom out\n//#define scaledot(u) dot(m,m)*u\n//near main axes, zoom in\n//#define scaledot(u) min(abs(m.x),abs(m.y)   )*u\n//mix of axial distances sets zoom\n//#define scaledot(u) mix(abs(m.x),abs(m.y),.5)*u\n#define scaledot(u) u=min(abs(m.x),abs(m.y))*u\n\nvec3 co(vec2 u){\n vec2 m=fr(iMouse.xy);u=fr(u);\n //if(mouse up) autoMouse\n if(iMouse.z<0.){m=vec2(3,-2)+9.*vec2(sin(iTime*.61),cos(iTime)*Phi).yx;}\n scaledot(u);scaledot(m);\n u+=m;\n m+=m;\n vec3 c;\n //u*=.25;//scaling canvas (independent from mouse)\n c.r=abs(fx(u,m)-u.y)-.3;\n \n c.r=min(c.x,length(u-m)-1.);//show muse cursor\n \n //increase distance to c.x, depending on how far m is from (0,0)\n //makes thin things thicker when zoomed out.\n //c.x-=sqrt(abs(length(m)));\n c.gb=u; \n //below distance gradient indicators are scaled by 0.61 to aboid overlap along the diagonals.\n c=sawCos3(c*phi,.9);//smoothest gradient visualization, this function may replace it?\n //c.gb+=vec2(sawCos(length(u)*phi,.5)*.001);//show circles around (0,0)\n \n //the color mix below usually looks nice, \n //but hues cyclically bleed into another, causing some optical illusions if one domain is very low\n //it also means if any domain is NaN, it becomes 0.\n if(isnan(c.r))c.r=0.;//projecting NaN to 0.\n if(isnan(c.b))c.b=0.;//projecting NaN to 0.\n if(isnan(c.g))c.g=0.;//projecting NaN to 0.\n c=sqrt(c);//more evenly gamma correcting\n c=max(vec3(0),c);\n return c*.5+c.yzx*.25;}\n \n void mainImage( out vec4 o, in vec2 u ){o=vec4(co(u),1.);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}