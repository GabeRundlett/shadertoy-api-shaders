{
    "Shader": {
        "info": {
            "date": "1478465647",
            "description": "I want to climb on this rock !",
            "flags": 96,
            "hasliked": 0,
            "id": "4ldSR4",
            "likes": 65,
            "name": "Pachamama",
            "published": 3,
            "tags": [
                "procedural",
                "distancefield",
                "grass",
                "motionblur",
                "dof",
                "sky",
                "mandelbox",
                "multisampling",
                "rock",
                "climbing"
            ],
            "usePreview": 1,
            "username": "XT95",
            "viewed": 3702
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by anatole duprat - XT95/2016\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//\n//  /!\\ Heavy GPU required /!\\\n//  You can disable some features on the Buffer A if it's too slow..\n//\n// \tSpecial Thanks to :\n//  Shane ( Nice Bump mapping https://www.shadertoy.com/view/MscSDB )\n//  Virgill ( Killer DOF https://www.shadertoy.com/view/llK3Dy )\n//  iq ( OrenNayar https://www.shadertoy.com/view/ldBGz3 & Soft Shadow https://iquilezles.org/articles/rmshadows )\n//\n//  Wonderfull music by Tinush : https://soundcloud.com/tinush/tinush-journey-original\n//  Enjoy =)\n//\n// ---------------------------------------------------------------------------------------\n\n\n\nconst float GA =2.399; \nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\n// \tsimplyfied version of Dave Hoskins blur\nvec3 dof(sampler2D tex,vec2 uv,float rad)\n{\n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(.002*iResolution.y/iResolution.x,.002),angle=vec2(0,rad);;\n    rad=1.;\n\tfor (int j=0;j<80;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor.rgb = dof(iChannel0,uv, texture(iChannel0,uv).a) ;\n    fragColor.rgb *= min(mod(iTime,30.)*.5,1.) * (1.-max((mod(iTime,30.)-28.),0.)*.5);\n\tfragColor.a = 1.;\n    \n    \n    \n    //Gamma correction & Vignetting\n    fragColor.rgb = pow(fragColor.rgb, vec3(1./2.2));\n    fragColor.rgb *= .5 + .5*pow( uv.x*uv.y*(1.-uv.x)*(1.-uv.y)*16., .75);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by anatole duprat - XT95/2016\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//\n//  /!\\ Heavy GPU required /!\\\n//  You can disable some features on the Buffer A if it's too slow..\n//\n// \tSpecial Thanks to :\n//  Shane ( Nice Bump mapping https://www.shadertoy.com/view/MscSDB )\n//  Virgill ( Killer DOF https://www.shadertoy.com/view/llK3Dy )\n//  reinder ( FXAA https://www.shadertoy.com/view/ls3GWS)\n//  iq ( OrenNayar https://www.shadertoy.com/view/ldBGz3 & Soft Shadow https://iquilezles.org/articles/rmshadows )\n//\n//  Wonderfull music by Tinush : https://soundcloud.com/tinush/tinush-journey-original\n//  Enjoy =)\n//\n// ---------------------------------------------------------------------------------------\n\n\n#define ROCKITERATION 7\n#define ENABLE_GRASS\n\n//Header\nconst float PI = 3.14159265359;\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec2 nfplane );\nvec3 normal( in vec3 p );\nvec3 bumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf);\nfloat map( in vec3 p );\nmat3 lookat( in vec3 fw, in vec3 up );\nmat3 rotate( in vec3 v, in float angle);\nvec3 triPlanarProj( in sampler2D tex, in vec3 p, in vec3 n );\nfloat hash( in float n );//->0:1\nvec2 hash2( in float n );\nfloat fbm( in vec2 uv);\nvec3 randomSphereDir(in vec2 rnd);\nvec3 randomHemisphereDir(in vec3 dir, in float i);\nfloat ambientOcclusion( in vec3 p, in vec3 n, float maxDist, float falloff );\nfloat softshadow( in vec3 ro, in vec3 rd );\n\n\n//-----------------------------------------------------------------------------\n// Distance field\n//-----------------------------------------------------------------------------\n//Based on Mandelbox\nfloat rock(in vec3 pos)\n{\n    const float scale = 2.82;\n    const float minRad2 = .83;\n    const vec4 scaled8 = vec4(3.525);\n\n    vec4 p = vec4(pos,1.), p0 = p;\n    float r2;\n    for (int i=0; i<ROCKITERATION; i++)\n    {\n        p.xyz = rotate(vec3(0.,1.,0.),p.y*.12) * p.xyz;\n        p.xyz = rotate(vec3(0.,0.,1.),-p.z*.1) * p.xyz;\n        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n        r2 = dot(p.xyz, p.xyz);\n        p *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);\n\n        p = p*scaled8 + p0;\n    }\n  \treturn ((length(p.xyz) - abs(scale - 1.0)) / p.w - pow(scale, float(1-ROCKITERATION)));\n}\n\n//Deformed cylinders\nfloat grass(in vec3 p)\n{\n\tfloat id = textureLod(iChannel1,floor(p.xz)/256.,0.0).r;\n    float h = p.y;\n    \n\tp.xz = mod(p.xz,1.)-.5;\n\tp = rotate(vec3(0.,1.,0.),id*60.)*p;\n    \n\t//p = rotate(vec3(1.,0.,0.),p.y*.2+cos(iTime*.01+id*7.))*p; //Grass animation\n\tp = rotate(vec3(1.,0.,0.),p.y*.2)*p;\n    \n    float d = length( p.xz )-id*.05 + pow(h*.2,4.) ;\n\n   return d;\n}\n\n//Final distance field map\nfloat map(in vec3 p)\n{\n    float r = rock(p);\n\tfloat ground = min(p.y+.5,p.y+r*.5);\n    \n    float d = min(r, ground);\n\td = max(d,p.y-1.);\n    \n\t#ifdef ENABLE_GRASS\n\tconst float grassSize = 100.;\n\tvec3 pgrass = (p+vec3(0.,ground-p.y,0.)) * grassSize;\n    d = min(d, grass(pgrass)/grassSize );\n    d = min(d, grass(pgrass+vec3(10.8,0.,1.5))/grassSize );\n    d = min(d, grass(pgrass+vec3(-1.3,0.,-10.1))/grassSize );\n    #endif\n    \n    return  d;\n}\n\n\n\n\n//-----------------------------------------------------------------------------\n// Shading\n//-----------------------------------------------------------------------------\n//Cheap procedural sky - https://www.shadertoy.com/view/lt2SR1\nvec3 skyColor( in vec3 rd )\n{\n    vec3 sundir = normalize( vec3(.0, .1, 1.) );\n    rd.y += .02;\n    float yd = min(rd.y, 0.), clouds = 0.;\n    rd.y = max(rd.y, 0.);\n    \n    vec3 col = vec3(0.);\n    \n    col += vec3(.4, .4 - exp( -rd.y*20. )*.3, .0) * exp(-rd.y*9.);\n    col += vec3(.4, .6, .7) * (1. - exp(-rd.y*8.) ) * exp(-rd.y*.9);\n    \n    col = mix(col*1.2, vec3(.3),  1.-exp(yd*100.));\n    \n    //Clouds\n    vec2 pclouds = rd.xz/rd.y;\n    clouds += fbm(pclouds*.01);\n    col += .1*(clouds*2.-1.);\n    \n    //Synchronized raindow!\n    vec3 raindow = clamp( abs(mod(-rd.x*20.*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    raindow = raindow*raindow*(3.0-2.0*raindow);;\n    col += raindow * max(-abs(rd.x+.715)+.025,0.)*100.*pow(texture(iChannel3, vec2(mod(rd.x*5.,1.),0.)).r,2.);\n    \n    return clamp(col,vec3(0.),vec3(1.))*2.;\n}\n\n//Better diffuse for rock - https://www.shadertoy.com/view/ldBGz3\nfloat orenNayar( in vec3 l, in vec3 n, in vec3 v, float r )\n{\n    float lv = dot(l,v);\n    float nl = dot(n,l);\n    float nv = dot(n,v);\n    \n    float r2 = r*r;\n    float a = 1. - .5 * (r2 / (r2+.57));\n    float b = .45 * r2 / (r2+.09);\n    \n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\n}\n\n//Shading a point\nvec3 shade( in vec4 p, in vec3 n, in vec3 ro, in vec3 rd )\n{\t\t\n\tvec3 ldir = normalize(vec3(-0.8,2.,0.95));\n\tvec3 albedo, amb, dif, sky, col;\n    \n    //Sky\n    float d = exp( -length(p.xyz-ro)*0.1 );\n    if( d < .3 )\n    {\n        return skyColor(rd);\n    }\n    \n    //Albedo\n\tfloat r = rock(p.xyz);\n\tif(r>.003)\n\t\talbedo = vec3(0.65,1.,0.05)*(1.-exp(-(p.y+r*.5)*120.));\n\telse\n\t{\t\n\t\tn = bumpMap(iChannel0,p.xyz*8.,n,.1);\n\t\talbedo = triPlanarProj(iChannel0,p.xyz*8.,n);\n\t}\n\n    //Lighting\n    float occ = ambientOcclusion(p.xyz,n, .05, -108.5) * ambientOcclusion(p.xyz,n, .2, -17.);\n    float shad = softshadow(p.xyz,ldir);\n\n\tdif = vec3(1.,.7,.3) * orenNayar(n,ldir,rd,1.) * shad;\n    sky = vec3(.8,.95,1.) * orenNayar(n,vec3(0.,1.,0.),rd,1.) * occ;\n\tamb = vec3(.9,.95,1.) * occ;\n   \n    col = albedo * ( dif*2.5 + sky*.1 + amb*.2 );\n\n    //Fog\n\tcol += vec3(1.,.8,.6)*pow(p.w,2.)*.025;\n\tcol = mix(col, vec3(.8,1.,1.), min(length(p.xyz-ro)*.001, 1.));\n\n\treturn col;\n}\n\n\n//-----------------------------------------------------------------------------\n// Entry point\n//-----------------------------------------------------------------------------\nfloat time;\nint idSeq; \n\nvoid cameraPath( in vec2 v, out vec3 ro, out vec3 rd )\n{\n    float nt = smoothstep(0.,1., max(mod(time,30.),0.)/30.);\n    \n    if(idSeq == 0)\n    {\n        ro = mix(vec3(2.1,0.1,1.45), vec3(2.1,0.1,.7), nt);\n        rd = mix(vec3(5.,0.,3.), vec3(5.,0.,-1.5), nt);\n    }\n    else if(idSeq == 1)\n    {    \n        ro = mix(vec3(.1,.1,2.6), vec3(.1,.7,2.2), nt);\n        rd = mix(vec3(0.,0.,3.), vec3(0.,-1.,3.), nt);\n    }\n    else if(idSeq == 2)\n    {    \n        ro = mix(vec3(2.1,.05,1.2), vec3(0.,.05,1.2), nt);\n        rd = mix(vec3(5.,2.,0.), vec3(5.,-8.,0.), nt);\n    }\n    else if(idSeq == 3)\n    {    \n        ro = mix(vec3(.5,.1,4.5), vec3(-.5,.1,4.5), nt);\n        rd = mix(vec3(2.,-2.,5.), vec3(2.,-3.,5.), nt);\n    }\n    else if(idSeq == 4)\n    {    \n        ro = mix(vec3(2.53,.05,-1.505),vec3(1.8,.05,-.8), nt);\n        rd = mix(vec3(5.,2.,-4.), vec3(5.,-3.,-0.), nt);\n    }\n    \n    rd = lookat(rd,vec3(0.,1.,0.)) * normalize( vec3(v.xy*vec2(-1.,1.),-1.5) );\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = mod(iTime,150.);\n\tidSeq = int(time/30.);\n\n    \n    vec2 o = hash2( float(iFrame) ) - 0.5;\n    vec2 q = (-iResolution.xy + 2.0*(fragCoord+o*.6))/ iResolution.y;\n    \n    //Camera ray\n    vec3 ro,rd;\n    cameraPath( q, ro, rd );\n\n\t//Classic raymarching by distance field\n\tvec4 p = raymarch(ro, rd, vec2(0., 1000.) );\n    vec3 n = normal(p.xyz);\n    vec3 col = shade(p, n, ro, rd);\n\n\n    fragColor = vec4(col,0.);\n        \n    //Dof factor\n    if(idSeq == 0 || idSeq == 4)\n    \tfragColor.a += clamp( 1.-(length(ro-p.xyz)-.2)*4., 0., 1.)*.25;\n    else if(idSeq == 1 || idSeq == 2)\n \t    fragColor.a += clamp( (length(ro-p.xyz)-2.)*4., 0., 1.)*.4;\n    else\n \t    fragColor.a += clamp( (length(ro-p.xyz)-1.)*1., 0., 1.)*.5;\n            \n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = mix(fragColor, texture(iChannel2, uv),.5);\n    \n}\n\n\n\n\n\n    \n//-----------------------------------------------------------------------------\n// Utils\n//-----------------------------------------------------------------------------\n//Raymarching by distance field\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec2 nfplane )\n{\n    float glow = 0.;\n\tvec3 p = ro+rd*nfplane.x;\n\tfloat t = 0.;\n\tfor(int i=0; i<256; i++)\n\t{\n        float d = map(p)*.8;\n        t += d;\n        p += rd*d;\n\t\tglow += 1./256.;\n\t\tif( d < 0.0001 || t > nfplane.y )\n            break;\n            \n\t}\n\t\n\treturn vec4(p,glow);\n}\n\n//Take the gradient of map()\nvec3 normal( in vec3 p )\n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\treturn normalize( vec3(\n\t\tmap(p+eps.xyy)-map(p-eps.xyy),\n\t\tmap(p+eps.yxy)-map(p-eps.yxy),\n\t\tmap(p+eps.yyx)-map(p-eps.yyx)\n\t) );\n}\n\n//Clever code taken from Shane shader - https://www.shadertoy.com/view/MscSDB\nvec3 bumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)\n{\n    const vec2 e = vec2(0.001, 0);\n    \n    mat3 m = mat3( triPlanarProj(tx, p - e.xyy, n), triPlanarProj(tx, p - e.yxy, n), triPlanarProj(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m;\n    g = (g - dot(triPlanarProj(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf );\n    \n}\n\n//Lookat matrix\nmat3 lookat( in vec3 fw, in vec3 up )\n{\n\tfw = normalize(fw);\n\tvec3 rt = normalize( cross(fw, normalize(up)) );\n\treturn mat3( rt, cross(rt, fw), fw );\n}\n\n//Rotate matrix\nmat3 rotate( in vec3 v, in float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\n//Tri Planar Projection of a texture\nvec3 triPlanarProj( in sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = abs(n);\n\tvec4 col = texture(tex, p.yz)*n.x + texture(tex, p.xz)*n.y + texture(tex, p.xy)*n.z;\n    return pow(col.rgb,vec3(2.2));\n}\n\n//Random number [0:1]\nfloat hash( in float n )\n{\n    return fract(sin(n)*3538.5453);\n}\nvec2 hash2( in float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\n//2D Fractional Brownian motion\nfloat fbm( in vec2 uv )\n{\n    float r = .5 * texture(iChannel1, uv).r;\n    r += .25 * texture(iChannel1, uv*2.).g;\n    r += .125 * texture(iChannel1, uv*4.).b;\n    r += .05125 * texture(iChannel1, uv*8.).r;\n    return r;\n}\n\n//Random vector\nvec3 randomSphereDir(in vec2 rnd)\n{\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\n\n//Random vector in a hemisphere\nvec3 randomHemisphereDir(in vec3 dir, in float i)\n{\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\n//More info at http://www.aduprat.com/portfolio/?page=articles/hemisphericalSDFAO\nfloat ambientOcclusion( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv;\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; \n        \n        ao += (l - map( p + rd )) / pow(1.+l, falloff);\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\n//From iq - https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t=0.01;\n    for(int i=0; i<128; i++)\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, 200.*h/t );\n        t += h;\n        if(t>2.)\n            break;\n    }\n    return res;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 5270,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/tinush/tinush-journey-original"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}