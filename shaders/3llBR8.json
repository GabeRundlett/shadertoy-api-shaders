{
    "Shader": {
        "info": {
            "date": "1595976881",
            "description": "raymarching! texturing! voxel-ish stuff! woohoo!\noriginally made in KodeLife\n\nnext thing to figure out...anti-aliasing... haha",
            "flags": 0,
            "hasliked": 0,
            "id": "3llBR8",
            "likes": 20,
            "name": "DNA Palace",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "trippy"
            ],
            "usePreview": 0,
            "username": "scry",
            "viewed": 654
        },
        "renderpass": [
            {
                "code": "#define time iTime*0.5\n// All components are in the range [0…1], including hue.\n//rgb2hsv & hsv2rgb from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nmat2 r2d(float a) {\n    return mat2(sin(a),cos(a),-cos(a),sin(a));\n}\n\nfloat cr(vec2 uv) {\n    float col = 0.;\n    col = (sin(uv.y+time*1.));\n    col += (sin(uv.x*10.));\n    return col;\n}\n\n//from https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 getDist(vec3 p) {\n    //d = min(d,sdBox(vec3(p.x+5.,p.y+bd+2.,p.z),vec3(bd3,bd2,bd2)));\n    //return d;\n    float rd = 0.02;\n    \n    float id = 0.+p.y*0.02;\n    //p = floor(p*2)/10.;\n    //p.zy *= r2d(mouse.x*2.);\n    //p.xz = (fract(p.xz*rd)-0.5)/rd;\n    p.xz = (fract((abs(p.xz)+5.)*rd)-0.5)/rd;\n    //p.xy *= r2d(mouse.y*2.);\n    //float ps = floor(p.y*0.15-2.5)*0.3;\n    float ps = 0.9;\n    vec3 p1 = p;\n    float t = time;\n    float sc = 3.;\n    float wl = 0.3;\n    p1.zx *= r2d(t+t);\n    p1 = floor(p1*ps)/ps;\n    //p1.z -= 2.;\n    p1.zx *= r2d(p1.y*wl-t);\n    p1.xy += sc;\n    //p1 = floor(p1*ps)/ps;\n    vec3 p2 = p;\n    p2.zx *= r2d(t+t);\n    p2 = floor(p2*ps)/ps;\n    //p2.z -= 0.9;\n    p2.zx *= r2d(p2.y*wl-t+3.);\n    p2.xy += sc;\n    //p1.yx *= r2d(time*0.01);\n    float s = 0.1294+(p.y*p.y*p.y+500.)*0.001;\n    //float s = 0.1294;\n    //p1 = floor(p1*0.5)*0.09;\n    //p1.xz = fract(p1.xz);\n    float d = length(p1.xz)-s;\n    float d2 = length(p2.xz)-s;\n    d = min(d,d2);\n    if (d2 > d) {\n        id += 0.3;\n        //d *= 02.9;\n    }\n    d = min(d,p.y+8.);\n    if (p.y+7.99 < d) {\n        float cs = 2.;\n        vec2 fp = p.xz*0.02;\n        fp.xy *= r2d(p1.y*1.-time+3.);\n        fp = floor(fp.xy*cs)/cs;\n        //fp.xy *= r2d(p1.y*1.+time*0.1);\n        id = (mod(fp.x + mod(fp.y, 2.0), 2.0));\n        //if (id < 0.) {\n        //    id = 0.;\n        //}\n        //id = floor(id);\n        //id = 0.3;\n        if (d < 0.) {\n            d = 40.0;\n        }\n        //d = abs(d);\n    }\n    //if (d < 0.) {\n    //        d = -20.;\n    //    }\n    return vec2(d,id);\n}\n\nvec2 RM (vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<200;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = getDist(p).x;\n        dO += dS*0.3;\n        ii += 0.01;\n        if (dS < 0.01 || dO > 1000.) {\n            break;\n        }\n    }\n    return vec2(dO,ii);\n}\n\n\n\nvec3 mainKL(vec2 uv)\n{\n    //vec2 uv = -1. + 2. * inData.v_texcoord;\n    //vec2 tv = inData.v_texcoord;\n    vec2 tv = uv;\n    vec3 col = vec3(0.);\n    uv.x *= iResolution.x/iResolution.y;\n    float c = length(uv);\n    //uv *= 0.5;\n    float t = time*0.1;\n    vec3 ro = vec3(0,-2,-0.);\n    ro.z += time*30.;\n    ro.z += iMouse.x*0.5;\n    //ro += mouse.y*20.;\n    vec3 rd = normalize(vec3(uv,0.8));\n    //rd.zx *= r2d(-mouse.x*20.);\n    rd.zy *= r2d(1.9);\n    rd.zx *= r2d(tv.x+t*5.);\n    //rd.zy *= r2d(2.5);\n    vec2 d = RM(ro,rd);\n    vec3 p2 = rd*d.x;\n    vec3 p = ro+rd*d.x;\n    col = vec3(d.x/100.);\n    float ci = getDist(p).y;\n    //col = hsv2rgb(vec3(ci,1.,(d.y)+(d.x*0.001)));\n    col = hsv2rgb(vec3(ci,1.,1.));\n    if (d.x > 999.) {\n        col *= 0.8;\n    }\n    //d.y += -ci*2.;\n    col += ((d.y*0.9)/(d.x*0.01)-1.)*0.2+d.y*0.2;\n    vec3 cf = fwidth(col);\n    col -= cf;\n    //col = (1.-col)+cf;\n    //col = 1.-cf;\n    //cf = fwidth(col);\n    //col = cf-col;\n    col -= vec3(d.x*0.05)*cf;\n    col = mix(col,vec3(0.),clamp(d.x*0.003,0.,1.));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = mainKL(uv-0.5);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}