{
    "Shader": {
        "info": {
            "date": "1623491057",
            "description": "Demonstration of a very simple bouncing effect which can be used as an easing function.",
            "flags": 0,
            "hasliked": 0,
            "id": "stj3zD",
            "likes": 3,
            "name": "Bouncy ball formula",
            "published": 3,
            "tags": [
                "graph",
                "physics"
            ],
            "usePreview": 0,
            "username": "voxel",
            "viewed": 274
        },
        "renderpass": [
            {
                "code": "/* Configuration:\n * R is the rate of decay, i.e., how much faster and shorter is each bounce?\n * B is the number of bounces.\n *\n * W1 is the width of the first bounce. This can be derived from the formula\n *    for the B-th partial sum of a geometric series. If you replace pow(R, B)\n *    with 0 you can get infinitely many bounces.\n *\n * f() here can be an arbitrary function which is graphed by mainImage(). The\n *     x-axis of the graph runs from 0 (left) to 1 (right).\n *\n * The implementation isn't too complicated:\n *\n * - The first line just re-scales the argument to fit in the center of the\n *   graph. Comment it out and you'll see what I mean.\n *\n * - We need to figure out what bounce the argument belongs in. In theory this\n *   could be done using floor(log(... , ...)) but it's simpler to look through\n *   every bounce until we find one whose end position is > x. The variable\n *   t tracks the end position and w tracks the width of the bounce. If B is\n *   constant you might get better performance by unrolling this loop since it\n *   will run no more than B times.\n *\n * - Next we need to calculate the height we are at within the parabolic bounce.\n *   The general formula for this is k*(x-a)*(x-b) where a and b are the roots,\n *   which are the beginning and end of the bounce (t-w and t respectively).\n *   k can be derived from the fact that the output must be 1 on the 1st bounce.\n *\n * The main function graphs f() and uses it to control the height of a ball.\n */\n\n#define R  0.4\n#define B  4.\n\nconst float W1 = ((1. - R) / (1. - pow(R, B)));\n\nfloat f(float x) {\n    x = clamp((x-.25)*2., 0., 1.);\n    float t = 0., w = W1;\n    while (x > (t += w)) w *= R;\n    return (x-t+w) * (x-t) / (-.25*W1*w);\n}\n\nvoid mainImage(out vec4 color, in vec2 co) {\n    vec3 col = mix(\n        vec3(0.,0.,.8),\n        vec3(.9),\n        // graph shape\n        smoothstep(0., 5., abs(f(co.x/iResolution.x)*iResolution.y-co.y))\n            *\n        // bouncy ball\n        smoothstep(5., 10., distance(co, iResolution.xy * vec2(.5, f(fract(iTime/6.)))))\n    );\n\n    // Output to screen\n    color = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}