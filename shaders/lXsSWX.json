{
    "Shader": {
        "info": {
            "date": "1710097417",
            "description": "Like [url]https://www.shadertoy.com/view/slGyWt[/url], computing the interior distance by finding the feature/intersection corners of the two shapes by repeated averaging projection points. Not working in general (due to convex regions)",
            "flags": 0,
            "hasliked": 0,
            "id": "lXsSWX",
            "likes": 27,
            "name": "SDF Interior Distance (wrong)",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 898
        },
        "renderpass": [
            {
                "code": "// A failed attempt to computing the correct union of two SDFs.\n// The exterior of the resulting SDFs is easy to compute, but the\n// interior is not, see https://iquilezles.org/articles/interiordistance/\n//\n// Here I try doing it by finding the closest corner or intersection\n// beteween the two SDFs. I compute this intersection iteratively, see\n// line 65. It's the same as what's described here:\n// https://en.wikipedia.org/wiki/Projections_onto_convex_sets#Related_algorithms\n//\n// Problem: it's not clear which of the many intersections the method\n// will converge to; it's not guaranteed it will be the closest.\n//\n// Based on this: https://www.shadertoy.com/view/slGyWt\n\n\n// iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0));\n}\n\n// .x = f(p), .yz = ∇f(p) with ‖∇f(p)‖ = 1, iquilezles.org/articles/distfunctions2d\nvec3 sdgCircle( in vec2 p, in float r ) \n{\n    float l = length(p);\n    return vec3( l-r, p/l );\n}\n\n// .x = f(p), .yz = ∇f(p) with ‖∇f(p)‖ = 1, iquilezles.org/articles/distfunctions2d\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2  w = abs(p)-b;\n    vec2  s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    float g = max(w.x,w.y);\n\tvec2  q = max(w,0.0);\n    float l = length(q);\n    return vec3(   (g>0.0)?l: g,\n                s*((g>0.0)?q/l : ((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\n//---------------------------------------------------------------------\n// the two SDFs we are going to combine\n\nvec3 sdf1( in vec2 p ) { return sdgCircle(p-vec2(-0.5, -0.25),0.65); }\nvec3 sdf2( in vec2 p ) { return sdgBox(p-vec2( 0.4,  0.25), vec2(0.8,0.5)); }\n\n//---------------------------------------------------------------------\n// the Union operator\nfloat opUnion( in vec2 p )\n{\n    vec3  a = sdf1(p);\n    vec3  b = sdf2(p);\n    float d = min( a.x, b.x );\n    \n    // if exterior distance, we are done\n    if( d>0.0 ) return d;\n\n    // if closest point is NOT inside the other shape, trust that\n    // (from Eclipixie, see https://www.shadertoy.com/view/XX3GDM)\n    if( max(sdf1(p-b.x*b.yz).x,sdf2(p-a.x*a.yz).x)>0.0 ) return d;\n\n    // otherwise, iteratively find the two shape's intersection/corner...\n    vec2 q = p;\n    for( int i=0; i<32; i++ )\n    {\n        q -= 0.5*(a.x*a.yz + b.x*b.yz);\n        a = sdf1(q);\n        b = sdf2(q);\n        if( max(abs(a.x),abs(b.x))<0.001 ) break;\n    }\n    // ...and return distance to intersection/corner\n    return -length(q-p); \n}\n\nfloat map( in vec2 p )\n{\n    return opUnion(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2  p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2  m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    // mouse probe\n    if( iMouse.z<0.001 )\n    {\n        m = vec2(0.6,0.25)*sin(iTime*vec2(0.7,0.5)+vec2(0.0,2.0));\n        m = vec2(m.x-m.y,m.x+m.y);\n    }\n    \n    // compute SDF\n    float d = map(p);\n\n    // display SDF\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.5,0.85,1.0);\n\tcol *= 1.0 - exp2(-32.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.002,0.005,abs(d)) );\n\n    // show distance bound\n    {\n        float dm = map(m);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(dm))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n    // show search path to closest intersection/corner\n    //if( dm<0.0 )\n    {\n        vec2 w = m;\n        float c = 1e20;\n        for( int i=0; i<64; i++ )\n        {\n            vec3 a = sdf1(w);\n            vec3 b = sdf2(w);\n            vec2 q = w - 0.5*(a.x*a.yz+b.x*b.yz);\n            c = min( c, sdSegment(p,w,q)-0.005 );\n            c = min( c, length(p-w)-0.015 );\n            w = q;\n        }\n        col = mix(col, vec3(1.0,1.0,1.0), smoothstep(px, -px, c));\n    }\n\n    // draw the basins of attraction to both corners\n    if( false )\n    {\n        vec2 q = p;\n        for( int i=0; i<64; i++ )\n        {\n            vec3 a = sdf1(q);\n            vec3 b = sdf2(q);\n            q -= 0.5*(a.x*a.yz + b.x*b.yz);\n            if( max(abs(a.x),abs(b.x))<0.001 ) break;\n        }\n        float s = sign( length(q-vec2(-0.4,0.4)) - length(q-vec2(0.15,-0.25)) );\n        col += 0.2*s;\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}