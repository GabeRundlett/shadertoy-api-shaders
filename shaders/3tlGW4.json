{
    "Shader": {
        "info": {
            "date": "1556351167",
            "description": "Very simple one. I might add the UI and others later.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tlGW4",
            "likes": 14,
            "name": "AKIRA inspired bike",
            "published": 3,
            "tags": [
                "raymerching",
                "akira"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 509
        },
        "renderpass": [
            {
                "code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// Edge detection code from:https://www.shadertoy.com/view/MsSGD1\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define hash(h) fract(sin(h) * 43758.5453123)\n#define EDGE_WIDTH 0.05\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))-0.08;\n}\n\nfloat dBox2d(vec2 p, vec2 b) {\n    return max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) {\n        return val1;\n    }\n    return val2;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nvec3 tireTex(vec2 uv) {\n    vec3 col = vec3(1.0,0.0,0.0);\n    float d0 = length(uv+vec2(0.5,0.5))-0.36;\n    float d1 = length(uv+vec2(0.5,0.5))-0.33;\n    float d2 = length(uv+vec2(-0.5,0.5))-0.36;\n    float d3 = length(uv+vec2(-0.5,0.5))-0.33;\n    \n    float size = 0.01;\n    \n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.02,d0) );\n    col = mix( col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.01,0.02,d1) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.02,d2) );\n    col = mix( col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.01,0.02,d3) );\n    \n    return col;\n}\n\nvec3 bodyTex(vec2 uv) {\n    vec3 col = vec3(1.0,0.0,0.0);\n    float d0 = dBox2d(uv+vec2(-0.4,0.2),vec2(0.1,0.03));\n    float d1 = dBox2d(uv+vec2(0.4,0.2),vec2(0.1,0.03));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.05,d0) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.05,d1) );\n    \n    return col;\n}\n\nvec3 animateTex(vec2 uv, float dir) {\n    vec3 col = vec3(1.0,0.0,0.0);\n    uv.y+=(dir == 0.0)?iTime*-0.1:iTime*0.1;\n    uv.y = mod(uv.y,0.1)-0.05;\n    float d0 = dBox2d(uv+vec2(0.0,0.0),vec2(0.1,0.02));\n    col = mix( col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.01,0.02,d0) );\n    return col;\n}\n\nvec3 seatTex(vec2 uv) {\n    vec3 col = vec3(1.0,0.0,0.0);\n    float d0 = dBox2d(uv+vec2(0.0,0.0),vec2(0.25,0.4));\n    col = mix( col, vec3(0.2), 1.0-smoothstep(0.01,0.02,d0) );\n    return col;\n}\n\nvec3 floorTex(vec2 uv) {\n    vec3 col = vec3(0.9,0.6,0.6);\n    float w = 2.0;\n    col = (uv.x>=-w && uv.x< w)? vec3(0.8):col;\n    uv.y+=iTime*30.0;\n    uv.y = mod(uv.y,8.0)-4.0;\n    float d0 = dBox2d(uv+vec2(1.5,0.0),vec2(0.05,2.5));\n    float d1 = dBox2d(uv+vec2(-1.5,0.0),vec2(0.05,2.5));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.03,d0) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.03,d1) );\n    \n    return col;\n}\n\nvec4 sdBike(vec3 p) {\n    vec3 pref = p;\n    vec2 uv = p.xy;\n    \n    vec4 tireF = vec4(vec3(0.0,0.0,0.0),sdTorus((p+vec3(0.0,0.55,1.2))*matRotateZ(radians(90.0)),vec2(0.3,0.12)));\n    vec4 tireF2 = vec4(tireTex(uv),length(p+vec3(0.0,0.55,1.2))-0.3);\n    \n    vec4 tireB = vec4(vec3(0.0,0.0,0.0),sdTorus((p+vec3(0.0,0.55,-1.2))*matRotateZ(radians(90.0)),vec2(0.3,0.12)));\n    vec4 tireB2 = vec4(tireTex(uv),length(p+vec3(0.0,0.55,-1.2))-0.3);\n\n    p.x = abs(p.x);\n    vec4 rearFrame = vec4(bodyTex(uv),sdBox((p+vec3(-0.3,0.3,0.9))*matRotateX(radians(40.0)), vec3(0.002,0.17,0.45)));\n    p = pref;\n    \n    vec4 body0 = vec4(seatTex(uv),sdBox((p+vec3(0.0,0.2,0.4))*matRotateX(radians(-60.0)), vec3(0.2,0.17,0.45)));\n    vec4 body1 = vec4(vec3(1.0,0.0,0.0),sdBox(p+vec3(0.0,0.6,-0.12), vec3(0.2,0.1,0.4)));\n    vec4 body2 = vec4(vec3(1.0,0.0,0.0),sdBox((p+vec3(0.0,0.35,-0.55))*matRotateX(radians(-20.0)), vec3(0.2,0.3,0.1)));\n    \n    p.x = abs(p.x);\n    vec4 frontFrame = vec4(bodyTex(uv),sdBox((p+vec3(-0.25,0.2,-0.8))*matRotateX(radians(-25.0)), vec3(0.002,0.15,0.45)));\n    p = pref;\n    \n    vec4 frontGlass = vec4(animateTex(uv,0.0),sdBox(( p+vec3(0.0,-0.03,-0.80))*matRotateX(radians(-25.0)),vec3(0.25,0.05,0.55)));\n    p = pref;\n    \n    p.x = abs(p.x);\n    vec4 engine = vec4(vec3(1.0,0.0,0.0),sdRoundedCylinder((p+vec3(-0.25,0.65,0.3))*matRotateZ(radians(90.0)), 0.11,0.05,0.05));\n    vec4 engine2 = vec4(vec3(1.0,0.0,0.0),sdRoundedCylinder((p+vec3(-0.25,0.75,-0.05))*matRotateZ(radians(90.0)), 0.08,0.05,0.05));\n    p = pref;\n    \n    vec4 rearMudguard = vec4(animateTex(uv,1.0),sdBox((p+vec3(0.0,-0.17,0.77))*matRotateX(radians(20.0)), vec3(0.2,0.02,0.3)));\n    \n    p.x = abs(p.x);\n    vec4 handle = vec4(vec3(0.2),sdBox((p+vec3(-0.25,-0.1,-0.3))*matRotateX(radians(20.0))*matRotateY(radians(45.0)), vec3(0.2,0.0001,0.0001)));\n    \n    return combine(combine(combine(combine(combine(combine(combine(tireF,tireF2), combine(tireB,tireB2)),combine(rearFrame,body0)),combine(body1,body2)),combine(frontFrame,frontGlass)),combine(engine,engine2)),combine(rearMudguard,handle));\n}\n\nvec4 map(vec3 p){    \n    vec3 pref = p;\n    vec2 uv = p.xy;\n    vec4 f = vec4(floorTex( p.xz),p.y+1.0);\n    p.z += iTime*30.0;\n    p.z = mod(p.z,20.0)-10.0;\n\n    float d0 = sdHexPrism((p+ vec3(0.0,-1.5,0.0)),vec2(4.5,1.0));\n    float d1 = sdHexPrism((p+ vec3(0.0,-1.5,0.0)),vec2(4.7,0.7));\n    d0 = max(-d0,d1);\n    vec4 cell = vec4(vec3(1.0,0.0,0.0),max(sdBox(pref,vec3(9.0,9.0,70.0)),d0));\n    return combine(combine(f,sdBike(pref*matRotateZ(radians(sin(iTime*1.2)*15.0)))),cell);\n}\n\nvec3 normalMap(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        map(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n        map(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n        map(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n    ));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = map(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\n// from simon green and others\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - map(p + n*d).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 uv = p;\n    \n    p.x+=(mod(iTime,4.0)<0.5)?sin(floor(p.y*60.0)*iTime*30.)*0.05:0.0;\n    \n    float time = iTime*2.0;\n    \n    float handShakeY = fbm(vec3(iTime,iTime*1.1,iTime*1.2))*0.5;\n    float handShakeX = fbm(vec3(iTime*1.1,iTime*1.2,iTime))*0.3;\n    \n    vec3 ro = vec3( handShakeX+0.5+3.5*cos(0.1*time + 6.0), handShakeY + 1.0, -0.5+5.5*sin(0.1*time + 6.0) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    \n    float t, dist;\n    float lastDistEval = 1e10;\n\tfloat edge = 0.0;\n    t = 0.0;\n    vec3 distPos = ro+rd;\n    vec4 distCl = vec4(0.0);\n    for(int i = 0; i < 64; i++){\n        distCl = map(distPos);\n        dist = distCl.w;\n        t += dist;\n        distPos = ro+rd*t;\n        \n\t\tif (lastDistEval < EDGE_WIDTH && dist > lastDistEval + 0.001) {\n\t\t\tedge = 1.0;\n\t\t}\n        if (dist < lastDistEval) lastDistEval = dist;\n        if(dist < 0.01 || dist > 30.0) break;\n    }\n\n    vec3 color;\n    float shadow = 1.0;\n    if(dist < 1.0){\n        // lighting\n        vec3 lightDir = vec3(0.0, 1.0, 0.0);\n        vec3 light = normalize(lightDir + vec3(0.5, 0.0, 0.9));\n        vec3 normal = normalMap(distPos);\n\n        // difuse color\n        float diffuse = clamp(dot(light, normal), 0.5, 1.0);\n        float lambert = max(.0, dot( normal, light));\n        \n        // ambient occlusion\n        float ao = ambientOcclusion(distPos,normal);\n        \n        // shadow\n        shadow = shadowMap(distPos + normal * 0.001, light);\n\n        // result\n        color += vec3(lambert);\n        color = ao*diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n        \n    }else{\n        color =.84*max(mix(vec3(0.9,0.81,0.85)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n    }\n\n    // rendering result\n    float brightness = 1.5;\n    vec3 dst = (color * max(0.8, shadow))*brightness;\n    \n    // add edge detection result\n    dst = mix(dst,vec3(0.1,0.1,0.1),edge);\n    \n    // UI\n    vec3 uicol = vec3(0.0);\n    vec3 barColor = vec3(0.7,0.2,0.2);\n    \n    float numBar = 20.0;\n    float deg = 360.0/numBar;\n    vec2 pos = vec2(0.0,0.0);\n    for(float i = 0.0; i<numBar; i+=1.0) {\n\t\tfloat rotVal = radians(i*deg+iTime*10.0);\n    \tmat2 m = rot(rotVal);\n        float animateVal = sin(hash(i)*(i*deg)*iTime*0.1)*0.1;\n        float bdist = 0.8;\n        float x = pos.x+cos(rotVal)*(bdist+animateVal);\n        float y = pos.y+sin(rotVal)*(bdist+animateVal);\n        float bar = dBox2d((uv+vec2(y, x))*m, vec2(0.01,0.12+animateVal));\n    \tuicol = mix( uicol, barColor, 1.0-smoothstep(0.01,0.02,bar) );\n    }\n    \n    vec2 ruv = uv*rot(radians(iTime*60.0));\n    float circleD = (ruv.y<-0.3)?length(ruv)-0.6:10.0;\n    float circleD2 = (ruv.y>=0.3)?length(ruv)-0.6:10.0;\n    \n    uicol = mix( uicol, barColor, 1.0-smoothstep(0.01,0.015,abs(min(circleD,circleD2))) );\n    fragColor = vec4(dst+uicol, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}