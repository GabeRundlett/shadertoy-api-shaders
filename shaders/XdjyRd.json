{
    "Shader": {
        "info": {
            "date": "1494236072",
            "description": "Marching the rays -tests",
            "flags": 0,
            "hasliked": 0,
            "id": "XdjyRd",
            "likes": 1,
            "name": "Marching the rays",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "DrunkenMastered",
            "viewed": 422
        },
        "renderpass": [
            {
                "code": "const vec3 cameraPos = vec3(0.0,3.0,0.0);\nconst vec3 lookAt = vec3(0,0.0,0.0);\nconst vec3 lightDir = vec3(1,1,-1.0);\nconst vec3 lightDiffuse = vec3(0.95,0.95,0.8);\nconst vec3 lightSpecular = vec3(1.0,1.0,1.0);\n\nconst float shininess = 30.0;\n\n\n// primitives\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n\nfloat sdGoo( vec3 p )\n{\n    float d1 = sdSphere(p, 0.5);\n    float mult = (sin(iTime * 2.0) + 1.0) * 0.5 * 2.0;\n    float d2 = sin(mult * p.x) * sin(mult * p.y) * sin(mult * p.z);\n    return d1+d2;\n}\n\nfloat opRepGoo( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sdSphere( q , 0.5);// max( sdSphere( q , 0.5),  sdSphere( q + vec3(0.3,0.1,0.3), 0.5) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y) ;\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n\nfloat sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }\n{\n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n \n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    return max(-box,octa); // Subtraction\n }\n\n// welcher ist n√§her\nvec2 closerOne( vec2 d1, vec2 d2 )\n{\n    return d1.x < d2.x ? d1 : d2;\n}\n\n\nfloat sdf_blend(float d1, float d2, float a)\n{\n\treturn a * d1 + (1. - a) * d2;\n}\n\n\nstruct ObjectStruct { float dist; int material; }; \n\n// scene vector2 y ist das material/id\nvec2 scene( in vec3 pos )\n{\n    float animationY = 2.5 + sin(iTime * 2.25) * 1.0;\n    \n    vec3  n = normalize(-pos);\n    vec2 uv = asin(n.xy) / 3.14159 + 1.5;\n    \n    float d = texture(iChannel1, vec2(pos.x, pos.y - animationY)).x * .04;\n    \n    d += sin(pos.y * 10.) * 0.04;\n    //vec2 res = vec2(sdPlane(pos), 1.0);\n    \n    float boxD \t\t\t = max(-sdBox(pos - vec3(0.0, animationY , 0.0), vec3(3,1,1.2)),sdSphere(pos - vec3(0.0, animationY , 0.0), 2.0));\n    float sphereD \t\t = sdSphere(pos - vec3(0.0, animationY , 0.0), 2.0);\n    float boxSphereBlend = sdf_blend(boxD,sphereD,(sin(iTime) + 1.) / 2.) + d;\n        \n    vec2 scene1 = closerOne(vec2( sdPlane (pos - vec3(0.0, -0.5, 0.0))\t , 1.0),                             \n                            vec2 (boxSphereBlend\t\t\t\t\t\t , 2.0));\n    \n    \t scene1 = closerOne(scene1, \n                            vec2(sdTorus(pos - vec3(0.0,0.0,0.0), vec2(6.0,0.6)), 3.0));\n    \n\tvec2 scene2 = closerOne(vec2(sdPlane(pos - vec3(0.0, -0.0, 0.0)) \t\t\t, 3.0), \n                            vec2(opRepGoo(pos - vec3(0.5), vec3(2.5, 0.0, 2.5)), 2.0));\n    \n   // ObjectStruct object = ObjectStruct(scene1, 2);\n    \n    return scene1;\n}\n\n\n// returns distance & material\nvec2 march(vec3 rot, vec3 ray)\n{\n   float material = -1.0;\n   float depth = 0.1;\n   float threshold = 1.0;\n    \n   for (int i=0; i < 128; i++) {\n      vec3 pos = rot + ray * depth;\n      vec2 hit = scene(pos);\n      threshold = hit.x;\n     \n      if (threshold < 0.001 || depth >= 25.0) {\n          break;          \n      }\n       \n      material = hit.y;\n      depth += threshold;\n\n   }\n    if(depth > 25.0){\n        material = -1.0;\n    }\n   return vec2(depth, material);\n}\n\n\nvec3 getNormal(vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0) * 0.5773 * 0.0005;\n    return normalize( e.xyy * scene( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx * scene( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy * scene( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx * scene( pos + e.xxx ).x );\n}\n\n\n\nvec3 getRay(vec3 dir, vec2 pos)\n{\n   pos = pos - 0.5;\n   pos.x *= iResolution.x/iResolution.y;\n   \n   dir = normalize(dir);\n   vec3 right = normalize(cross(vec3(0.,1.,0.),dir));\n   vec3 up = normalize(cross(dir,right));\n   \n   return dir + right*pos.x + up*pos.y;\n}\n\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n\tfloat res = 1.0;\n    float threshold = 0.01;\n    //float depth = 0.0;\n    \n    for( float depth=0.1; depth<16.; )\n    {            \n\t\tthreshold = scene( ro + rd * depth ).x;\n        if (threshold < 0.001)\n        {\n            return 0.0;\n        }\n        \n        res = min( res, 8.0 * threshold / depth );\n        depth += threshold;\n         \n    }\n    \n    return res;\n}\n\n\n\n\nvec4 shading(vec3 viewDir, vec3 pos, vec3 mainColor, vec3 normal)\n{\n    vec3 lightDir \t= normalize(lightDir);\n    vec3 reflection = normalize(reflect(viewDir,normal));\n    \n    float diff = max(dot(lightDir,normal),0.);\n       \n    float spec = max(pow(max(dot(lightDir,reflection),0.0),shininess),0.)*diff;   \n    \n    vec4 color = vec4(mainColor * (diff + 0.2) + spec, 1.0);\n\n    vec3 rc = vec3(0.);\n    vec2 hit = march(pos + reflection * .01, reflection);\n    float rd = hit.x;\n    float mat = hit.y;\n    if(rd < 10. ) {\n        vec3 rp = pos + reflection * rd;\n        vec3 rn = getNormal(rp);\n        rc = mainColor * max(dot(lightDir, rn),0.);\n    } \n    else{\n        rc = texture(iChannel2,reflection).xyz;   \n    }\n    \t\n    \n    \n    float fres = 1.-max(pow(max(-dot(viewDir,normal),0.0),.3),0.);\n    //return vec4(fres);\n    return mix(color, vec4(rc.x, rc.y, rc.z, 1.0), fres) * shadow(pos, lightDir);                                              \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    vec3 ro = vec3(cos(iTime * 0.25) * 10.0, 2.0, sin(iTime * 0.25) * 10.0);\n    vec3 rd = normalize(getRay(lookAt - ro, p));\n    vec2 hit = march(ro, rd);\n    float distance = hit.x;\n    float material = hit.y;\n    \n    vec3 color;\n    if(material > 0.0)\n    {\n        vec3 res = ro + rd * distance;\n        color = vec3(0.9, 0.9, 1.0) +rd.y*0.9;\n        \n        vec3 mainColor = color;//vec3(0.65, 0.85, 1.0) + rd.y * 0.72;\n        \n        if(material == 2.0)// Sphere\n        {           \n            mainColor = vec3(1.0, 0.1, 0.1);\n        }\n        else if(material == 1.0)\n        {\n            float f = mod(floor(1.0 * res.z) + floor(1.0 * res.x), 2.0);\n            mainColor = f * vec3(0.6,0.6,0.6) + 0.5;\n            \n        }\n        else if(material == 3.0)\n        {\n             vec2 uvSphere = getNormal(res.xyz).xy;\n            vec4 tex = texture(iChannel0,uvSphere);\n            mainColor = tex.xyz;//vec3(1, 0.25, 0.25);\n        }\n\n        color *= clamp(shading(rd.xyz, res.xyz, mainColor, getNormal(res.xyz)).xyz, 0.0, 1.0);\n\n        //color = mix(color, 1.5 * vec3(0.5, 0.5, 0.7), 1.0 - exp2(-0.006 * hit.x * hit.x));\n\n\n        fragColor = vec4(color, 1.0);\n    }\n    else\n    {\n        vec3 r = normalize(reflect(rd,getNormal(ro)));\n        color = texture(iChannel2,r).xyz;   \n    \t// color = vec3(0.65, 0.85, 1.0) + rd.y * 0.72;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}