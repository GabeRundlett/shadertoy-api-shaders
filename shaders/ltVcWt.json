{
    "Shader": {
        "info": {
            "date": "1538210909",
            "description": "to unite with\nhttps://www.shadertoy.com/view/MlscWn\nhttps://www.shadertoy.com/view/4s3XDn\nhttps://www.shadertoy.com/view/XtSczV\nbut non-monospaced, by making a tree of this function.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltVcWt",
            "likes": 1,
            "name": "BVH CoC typeset overlap (tree)",
            "published": 3,
            "tags": [
                "blur",
                "tree",
                "bvh",
                "overlap",
                "glyph",
                "typesetting",
                "coccircleofconfusion",
                "halfspace"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 534
        },
        "renderpass": [
            {
                "code": "//the core goal is to make something overlapping, but without a loop, like\n//https://www.shadertoy.com/view/MlscWn\n//but for non-monospaced fonts/shape libraries that have a known variable width.\n//and i think a tree structure \n//... (of this shaders main function) is the fastest solution here.\n\n\n\n//2d zoom\n#define ViewZoom 3.\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define aa (min(iResolution.x,iResolution.y)/ViewZoom)\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y//usually first function of mainImage(),not typecast.\n\n\n#define pi acos(-1.)//trig definition for 3.14...can be better for smarter compilers.\n#define vec1 float\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n#define ss(a,u)smoothstep(a,-a,u)\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\nvec1 miv(vec2 a){return min(a.y,a.x);}vec1 miv(vec3 a){return min(a.z,miv(a.xy));}vec1 miv(vec4 a){return min(miv(a.zw),miv(a.xy));}\n#define mav(a)-miv(-a)\n\n/*\n//fract(dot(1031))hash summer 2018 seems ot be generally superior to fract(sin())hashes\nvec3 g3(vec1 a){return vec3(a);}\nvec3 g3(vec2 a){return a.xyx;}\nvec3 g3(vec3 a){return a;}\nvec4 g4(vec1 a){return vec4(a);}\nvec4 g4(vec2 a){return a.xyxy;}\nvec4 g4(vec3 a){return a.xyzy;}\nvec4 g4(vec4 a){return a;}\n//hashes by David Hoskins,Creative Commons Attribution-ShareAlike 4.0 International Public License\n//parent https://www.shadertoy.com/view/4djSRW\n#define hs vec4(.1031,.1030,.0973,.1099)\n//#define HASHSCALE3 vec3(443.897,441.423,437.195,444.129)//For smaller input rangers like audio tick or 0-1 UVs use these...\n#define hout1(a)fract((a.x+a.y)*a.z)\n#define hout2(a)fract((a.xx+a.yz)*a.zy)\n#define hout3(a)fract((a.xxy+a.yzz)*a.zyx)\n#define hout4(a)fract((a.xxyz+a.yzzw)*a.zywx)\n#define h3mid(a)((a)+dot(a,a.yzx+19.19))\n#define h4mid(a)((a)+dot(a,a.wzxy+19.19))\n//hashes are named by output type,NEVER by input type\n//hash1 mirrors at y=x and has strong banding on diagonals.\n//only hash4 takes in vec4.all hash functions take vey1,v3c2,vec3 in (a vec4 generalizations is a mild overkill for most vec2,vec3 contexts)\n#define hash1(a)hout1(h3mid(fract(hs.x*g3(a))))\n#define hash2(a)hout2(h3mid(fract(hs.xyz*g3(a))))\n#define hash3(a)hout3(h3mid(fract(hs.xyz*g3(a))))\n#define hash4(a)hout4(h4mid(hs*g4(a)))\n//not sure if its this shaders fault,likely a fract()error,but the avobe hsh gives bad lines.\n//float hash1(float n){ return fract(sin(n)*1e4);}\n\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nvec3 rainbow(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbow2(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbow(float a){return rainbow(a,1./3.);}\nvec3 rainbow2(float a){return rainbow2(a,1./3.);}\n*/\n\n\n//think of the rex and green cosines as:\n//- 2 images,scaled along .x to fit the screen\n//- 2 V-shaped glyphs,with overlappable typesetting\n//-=the glyphs know their relative width-ratio to set the red and green borders,with parametric overlap.\n\n\n//2 shape functions, insert any glyph here.\n//take gratdients from\n//https://www.shadertoy.com/view/4s3XDn\nvec4 shapeA(vec2 u){\n ;u.x=cos(u.x*6.)-u.y*6.-3.\n ;u.x=1.-abs(u.x)\n ;return vec4(u.x,0,0,0);}\nvec4 shapeB(vec2 u){\n ;u.x=-cos(u.x*6.)-u.y*6.-3.\n ;u.x=1.-abs(u.x)\n ;return vec4(0,u.x,0,0);}\n\n\n//#define u5(a)((a)*.5+.5)\nvoid mainImage(out vec4 O,vec2 u){u=fra(u)\n ;vec2 m=fra(iMouse.xy);vec2 n=fra(iMouse.zw)\n ;vec2 r=vec2(length(m-u),length(n-u))*vec2(5,7)//2 distances\n//;r.x=miv(r);r.x=fract(r.x)\n//;vec3 c=vec3(r.x,fract(u))\n ;vec4 c=vec4(1)\n ;c.x=u5(cos(iTime))//position of red,all left of c.x is red\n ;c.y=mix(c.x,1.,u5(cos(iTime*u5(sqrt(5.)))))//position of green,all right of c.y is green\n ;c.w=mix(c.x,c.y,.5)//position of yellow is midpoint between red and green\n ;c.z=abs(u.x-.5)-.5//blue border is \"outside\" bounding Volume.\n ;if(u.y<.5//lower half od the screen (upper half visualizes unput parameters c.xyw)\n){vec2 b=u-vec2(u.x-u.x/c.y+1.,0)//stretchy frames left  context\n  ;vec2 a=u-vec2(u.x+(1.-u.x)/(1.-c.x)-1.,0)//stretchy frames right context\n  ;if(.5<abs(u.x-.5))O=vec4(0,0,1,1)//BV-skip (blue area)\n  ;else{//red, yellow or green\n      //this is a case(0,1,2) branch, but transformed into a single mix() (specual case of overlapping 2 channels)\n   ;float s=u5(sign(abs(c.w-u.x)-c.w+c.x))\n//next line substitutes 2_min()with 2_mix()\n//one of them is the min()of the overlapping intner part\n//the other is the min()of the non-overlapping outer parts\n//min()->mix()substitution allows this to be pararametric,and then united.\n   ;O=mix(shapeA(a),shapeB(b),s*(sign(c.w-u.x)*.5)+.5)*(2.-s)\n//This [Overlap] is reduced to 1 mix()and 2 sign()\n//and the middle-part can be extrac ted,and transformed into an interpolation [from c.x to c.y]\n//to turn this into a {CircleOfConfusion]\n//but the interpolation comes iwth extra costs.\n  ;}return;\n }else if(u.y>m.y//show input c.xyw as lines\n){c.xyw=u.x-c.xyw\n  ;c=abs(c)\n  ;c=smoothstep(.01,-.01,c-.01)\n ;}else{//show input c.xyw as area\n  ;if(.5<abs(u.x-.5))O=vec4(0,0,1,1)//BV-skip\n  ;else if(abs(u.x-c.w)<c.w-c.x)O=vec4(1,1,0,1)//BV-mix inner\n  ;else{\n  ;O=mix(vec4(0,1,0,1),vec4(1,0,0,1),step(u.x-c.w,0.))//BV-mix outer\n  ;}\n  ;return;\n  ;}\n ;c.xy+=c.w;//treat .w as yellow\n ;O=vec4(c.xyz,1)\n ;}\n\n\n/*\n[halfspace tapping] link collection (v3) (may only be correlated, not even using the method, but SHOULD use the method)\n//\nsawblade serrated disk inversion  \nhttps://www.shadertoy.com/view/4t3fz7\nparent of the above is below\nhttps://www.shadertoy.com/view/XtSczV\n//\nwhich contains links to\ni tried to make this a sawblade\n, and noticed that i would need an insideout rounded box gradient for this: \nhttps://www.shadertoy.com/view/4t3fz7 \n//\nwe need a label for this [overlapping tile/slice] [typesetting] [CircleOfConfusion] \nstuff first time i see it in polar coordinates: \nprevious instances where linear or square lattice (and often only partially overlappin CoC's) \nhttps://www.shadertoy.com/view/4tjcWR\nhttps://www.shadertoy.com/view/MlscWn \n//\nI suggest [halfspace tapping]\n, where CoC implies bokeh, this generalizes it to \"overlapping of dark areas with lit areas\" \nthat may even not overlap completely (or at not overlap at all) :\ntoon clouds (very similar to / MlscWn ):\nhttps://www.shadertoy.com/view/4t23RR\nhttps://www.shadertoy.com/view/MltyR7 \nhttps://www.shadertoy.com/view/ltVcWt\nconcept of a non-monoispaced tree structure (branching a dualGlpyhString into 2 non monospaced sub-glyphs, branchless tree element)\nhttps://www.shadertoy.com/view/ltVcWt\n//\nolder and simpler [halfspace] shaders, closer to \nhttps://www.shadertoy.com/view/Md2cWK\nmodulo-gears:\nhttps://www.shadertoy.com/view/Msl3Rn\npavement:\nhttps://www.shadertoy.com/view/XsKXz3\npolar grid motion does 3-tap, and wopuld be great for half-space overlap:\nhttps://www.shadertoy.com/view/XtcfRH\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}