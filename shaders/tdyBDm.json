{
    "Shader": {
        "info": {
            "date": "1607279951",
            "description": "a new boolean function. (line 44)\nIt is an effect like a hard substance sinking into a soft substance.\n\nEdit:\nI add jelliy motion and fake sss.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdyBDm",
            "likes": 11,
            "name": "OpUnionSink",
            "published": 3,
            "tags": [
                "boolean"
            ],
            "usePreview": 0,
            "username": "iY0Yi",
            "viewed": 450
        },
        "renderpass": [
            {
                "code": "vec3 ro = vec3(0), rd = vec3(0);\nvec3 col = vec3(0);\nvec3  L0_dir, L0_col, L1_dir, L1_col;\nfloat L0_str, L0_end, L0_sft;\nfloat L1_str, L1_end, L1_sft;\n\n// SDF functions\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat sdSphere(in vec3 p,in float r)\n{\n    return length(p)-r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return ((min(max(d.x,d.y),0.0) + length(max(d,0.0))));\n}\n\nfloat fOpUnionSmooth(float a,float b,float r)\n{\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\nfloat vmax(vec3 v){\n    return max(max(v.x, v.y), v.z);\n}\nfloat sdBox(vec3 p,vec3 b)\n{\n    vec3 d=abs(p)-b;\n    return length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));\n}\n// a modified func of \"fOpUnionColumns\" by hg_sdf:\n// https://mercury.sexy/hg_sdf/\nvec4 v4OpUnionSink(vec4 a, vec4 b, float r, float n) {\n    \n    vec2 p = vec2(a.x, b.x);\n    float rad = r*sqrt(2.)/(2.+sqrt(2.));\n    p.x -= sqrt(2.)/2.*r;\n    p.x += rad*sqrt(2.0);\n    p.y -= rad;\n    float d = length(p+vec2(0,n)) - rad;\n    d = fOpUnionSmooth(d, b.x, p.x);\n    d = min(d, a.x);\n    return vec4(d, (d==a.x)?a.yzw:b.yzw);\n}\n\n// // The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\n// float fOpUnionColumns(float a, float b, float r, float n) {\n//     if ((a < r) && (b < r)) {\n//         vec2 p = vec2(a, b);\n//         float columnradius = r*sqrt(2)/((n-1)*2+sqrt(2));\n//         pR45(p);\n//         p.x -= sqrt(2)/2*r;\n//         p.x += columnradius*sqrt(2);\n//         if (mod(n,2) == 1) {\n//             p.y += columnradius;\n//         }\n//         // At this point, we have turned 45 degrees and moved at a point on the\n//         // diagonal that we want to place the columns on.\n//         // Now, repeat the domain along this direction and place a circle.\n//         pMod1(p.y, columnradius*2);\n//         float result = length(p) - columnradius;\n//         result = min(result, p.x);\n//         result = min(result, a);\n//         return min(result, b);\n//     } else {\n//         return min(a, b);\n//     }\n// }\n\n// scene: Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define MAT0 vec3(0.890,0.871,0.769)\n#define MAT0_1 vec3(0.851,0.702,0.451)\n#define MAT1 vec3(1.000,1.000,1.000)\n#define MAT2 vec3(0.690,0.969,0.890)\nvec4 sdScene(vec3 p)\n{\n    float d = MAX_DIST;\n    vec4 res = vec4(MAX_DIST, MAT_VOID);\n    //p.xz+=1.25;\n    R(p.xz, iTime*.05);\n    \n    p.xz = abs(p.xz);\n\td = sdSphere(p, 2.);\n\tres = vec4(d, MAT0);\n    float anim = elasticInOut(s2u(sin(iTime*2.)))*.3;\n    float anim2 = elasticInOut(s2u(sin(iTime*2.-PI)))*.3;\n    vec3 q = p;\n    d = sdCappedCylinder(rot(q+vec3(0., 0., -3.-anim), vec3(PI*.5, 0., 0.)), vec2(0.5, 1.1));\n\tres = v4OpUnionSink(vec4(d, MAT1), res, .7, 1.*anim);\n    \n\td = sdBox(q+vec3(-3.-anim2, 0., 0), vec3(1.1, 0.4000,0.4000));\n    res = v4OpUnionSink(vec4(d, MAT1), res, .7, 1.*anim2);\n    return res;\n}\n\nvec4 sdSticks(vec3 p)\n{\n    float d = MAX_DIST;\n    vec4 res = vec4(MAX_DIST, MAT_VOID);\n    //p.xz+=1.25;\n    R(p.xz, iTime*.05);\n    \n    //p.xz = abs(p.xz);\n    float anim = elasticInOut(s2u(sin(iTime*2.)))*.3;\n    float anim2 = elasticInOut(s2u(sin(iTime*2.-PI)))*.3;\n    vec3 q = p;\n    d = sdCappedCylinder(rot(q+vec3(0., 0., -3.-anim), vec3(PI*.5, 0., 0.)), vec2(0.5, 1.1));\n\tres = v4OpUnionSink(vec4(d, MAT1), res, .7, 1.*anim);\n    \n\td = sdBox(q+vec3(-3.-anim2, 0., 0), vec3(1.1, 0.4000,0.4000));\n    res = v4OpUnionSink(vec4(d, MAT1), res, .7, 1.*anim2);\n    return res;\n}\n\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 intersect()\n{\n    float d = 1.;\n    vec3  m = MAT_VOID;\n\n    for (int i = ZERO; i < ITERATION; i++)\n    {\n        vec3 p = ro + d * rd;\n        vec4 res = sdScene(p);\n        m = res.yzw;\n        res.x *= .5;\n        if (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n        d += res.x;\n        if (d >= MAX_DIST) break;\n    }\n\n    return vec4(d,m);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 normal(vec3 p)\n{\n    float c=sdScene(p).x;\n    float e=MIN_DIST*.1;\n    return normalize(vec3(\n        sdScene(p+vec3(e,0.,0.)).x-c,\n        sdScene(p+vec3(0.,e,0.)).x-c,\n        sdScene(p+vec3(0.,0.,e)).x-c)\n    );\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat shadow(vec3 o, vec3 n)\n{\n    float mint=L0_str;\n    float maxt=L0_end;\n    float k = L0_sft;\n    float res = 1.;\n    float t=mint;\n    for( int i=0; i < ITERATION; i++)\n    {\n        float h = sdScene(o + L0_dir*t).x;\n        res = min( res, k*h/t);\n        t += h;\n        if( res<0.001 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n    vec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n    return v * sign(dot(v, dir));\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n    const int nbIte = 12;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n\n    float ao = 0.0;\n\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash11(float(i))*maxDist;\n        vec3 aord = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal// for self occlusion problems!\n\n        ao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat specular(vec3 p, vec3 n, vec3 ld, float power)\n{\n    vec3 to_eye = normalize(p - ro);\n    vec3 reflect_light = normalize(reflect(ld, n));\n    return pow(max(dot(to_eye, reflect_light), 0.), power);\n}\n\n// https://www.shadertoy.com/view/wljSz1\nvec4 sss(vec3 ro, vec3 rd){\n    vec3 p = ro;\n    float pres = .03;\n    float e = 0.;\n    for(int i = 0; i < 120; ++i){\n        float d = sdScene(p).x;\n        \n        if(d > -MIN_DIST)\n            break;\n        \n        e += -pres; // marching with constant. \n        p -= pres*rd; // marching with constant.\n        //st_assert(i<59);\n    }\n    return vec4(p, e);\n}\n\n// for sss occlusion\nvec4 absss(vec3 ro, vec3 rd){\n    vec3 p = ro;\n    float pres = .02;\n    float e = 1.;\n    vec4 d;\n    for(int i = 0; i < 120; ++i){\n        d = sdSticks(p);\n        \n        if(d.x < MIN_DIST)\n            break;\n        \n        e *= 1.-pres; // marching with constant. \n        p += pres*rd; // marching with constant.\n        rd=normalize(rd+u2s(hash33(p))*.05);\n        //st_assert(i<59);\n    }\n    e = 1.-e*1.;\n    return vec4(p, e);\n}\n\n\n// abailable: AMB_COL, AMB_STRENGTH, FOG_COL, FOG_START, L0_col, L0_dir, L0_str, L0_end, L0_sft\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid render()\n{\n    vec4 hit = intersect();\n    vec3 p = ro + hit.x * rd;\n    vec3 base_col = hit.yzw;\n\n    if (hit.x>=MAX_DIST)\n    {\n        col=FOG_COL*(.65+.45*saturate(dot(-rd, L0_dir)));\n    }\n    else\n    {\n        vec3 n = normal(p);\n        vec3 offset = n * .00001;\n        float light1 = saturate(dot(n, L0_dir));\n        float light2 = saturate(dot(n, L1_dir))*.3;\n        \n\n        float ao=0.;\n        ao = ambientOcclusion(p, n, .1, 2.);\n        ao += ambientOcclusion(p, n, .5, 2.);\n        ao += ambientOcclusion(p, n, 1., 2.);\n        ao += ambientOcclusion(p, n, 4., 2.);\n        ao = smoothstep(0., 4., ao);\n\n        float shade = 0.;\n        shade = light1;\n\t\tfloat spec = 0.;\n        vec3 shadeLight1 = vec3(L0_col*light1);\n        vec3 shadeLight2 = vec3(L1_col*light2);\n\t\tif(distance(MAT0,base_col)<.01)\n        {\n            light1 = s2u(dot(n, L0_dir));\n\t\t\tL0_sft = 5.;\n            float shadow = shadow(p+offset, n);\n            // https://www.shadertoy.com/view/wljSz1\n            vec3 h = normalize(mix(-n, rd, .5));\n            // sv.zyz contains outgoing position, w contains accumulate distance (path \"tightness\")\n            vec4 sv = sss(p+h, -L0_dir);\n            // subsurface magic term\n            float ss = saturate(-sv.w*.3);\n            // light visibility across the volume\n            float ssha = max(0., dot(normal(sv.xyz), normalize(p-sv.xyz)));\n            float ssmix = mix(dot(n, L0_dir)*.5+.5, ss, .5);\n            shadeLight1 = vec3(ssmix)*L0_col;\n            vec4 ab = absss(p-n*.01, rd);\n            float abss = saturate(ab.w);\n            //st_assert(sss>.1);\n            base_col = mix(MAT0, MAT0_1, mix(sms(.0, 1., ss), (1.-.05+.95*saturate(1.-abss)), .5));\n            spec = specular(p+offset, n, L0_dir, 155.)*shadow*1.;\n            col = shadeLight1;\n            col *= .8+.2*shadow;\n            col+= MAT0*(.5+.5*ao)*.3;\n            col*= base_col;\n            col = mix(col, col+L0_col, spec);\n            //col = vec3(abss);\n        }\n        else\n        {\n            L0_sft = 50.;\n            float shadow = shadow(p+offset, n);\n            col = shadeLight1;\n            col *= shadow;\n            col+= shadeLight2*ao;\n            col+= AMB_COL*ao*.4;\n\t\t\tcol+= mix(MAT0, MAT0_1, .85)*sms(1.,.05,ao)*.75;\n            col*= base_col;\n            col = mix(col, col+L0_col, spec);\n            col = mix(col, FOG_COL, saturate(pow(distance(ro,p)/MAX_DIST+FOG_START, FOG_POW)));\n            //col = vec3(0);\n        }\n        \n    }\n}\n\n\nvec3  Camera_pos;\nvec4  Camera_quat;\nfloat Camera_fov;\n\n// \"init\": init camera/lights.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid init()\n{\n\tCamera_pos = vec3(10, -10, 5.5);\n\tCamera_quat = vec4(0.5026, 0.2445, 0.3628, 0.7457);\n\tCamera_fov = 0.3;\n\tL0_dir = normalize(vec3(0.6605, 0.5660, -0.4934));\n    R(L0_dir.xz, iTime*.25); \n    L0_dir = normalize(L0_dir);\n\tL0_col = vec3(0.933,0.894,0.788)*1.5;\n\tL0_str = 0.0500;\n\tL0_end = 30.;\n\tL0_sft = 8.2700;\n\tL1_dir = normalize(vec3(-0.6605, -0.5660, 0.4934));\n    R(L1_dir.xz, iTime*.25); \n    L1_dir = normalize(L1_dir);\n\tL1_col = vec3(0.3684, 0.4668, 0.5815);\n\tL1_str = 0.0500;\n\tL1_end = 30.;\n\tL1_sft = 50.;\n}\n\n// \"camera\": create camera vectors.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nvec3 quat_rotate(vec4 quat, vec3 dir)\n{\n    return dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\n\nvoid camera(vec2 uv)\n{\n\n    vec3 dir = normalize(vec3(0,-.4,1));//quat_rotate(Camera_quat, vec3(0,0,-1)).xzy;\n    vec3 up = vec3(0,1,0);//quat_rotate(Camera_quat, vec3(0,1,0)).xzy;\n    vec3 pos = vec3(0,11.75,-30);\n    float fov = .14;\n    vec3 target = pos-dir;\n\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    ro = pos;\n\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup UV...\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    if(uv.x>INV_ERNST_RENDER_SCALE || uv.y>INV_ERNST_RENDER_SCALE)\n        return;\n    uv*=ERNST_RENDER_SCALE;\n    float ml = (min(iResolution.x, iResolution.y)==iResolution.x)?1.0:iResolution.y/iResolution.x;\n    uv = (uv*2.-1.)*ml;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Rendering...\n    init();\n    camera(uv);\n    render();\n    \n    col*= .75+.25*pow(1.-length(uv), 1.);\n    \n    col = ACESFilm(col);\n    \n    fragColor = vec4(col, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.\n#define ZERO min(0,iFrame)\n#define PI 3.14159265\n#define HALF_PI 1.5707963267948966\n#define PI2 (2.0*PI)\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Random & Noise\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// \"Random number generator\" by Toshiya Hachisuka:\n// https://www.ci.i.u-tokyo.ac.jp/~hachisuka/tdf2015.pdf\nfloat rnd(inout vec4 n){\n    const vec4 q=vec4(1225.0,1585.0,2457.0,2098.0);\n    const vec4 r=vec4(1112.0,367.0,92.0,265.0);\n    const vec4 a=vec4(3423.0,2646.0,1707.0,1999.0);\n    const vec4 m=vec4(4194287.0,4194277.0,4194191.0,4194167.0);\n    vec4 beta=floor(n/q);\n    vec4 p=a*(n-beta*q)-beta*r;\n    beta=(sign(-p)+vec4(1.0))*vec4(0.5)*m;\n    n=(p+beta);\n    return fract(dot(n/m,vec4(1.0,-1.0,1.0,-1.0)));\n}\n\n// Hash / Noise by Anonymous:\n// I forgot where I found this...\nfloat hash( float n )\n{\n    return fract(sin(n)*158.5453);\n}\nfloat noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash(p+0.0), hash(p+1.0),f);\n}\n\n// \"Integer Hash - II\" by iq:\n// https://www.shadertoy.com/view/XlXcW4\n  const uint k = 1103515245U;  // GLIB C\n//const uint k = 134775813U;   // Delphi and Turbo Pascal\n//const uint k = 20170906U;    // Today's date (use three days ago's dateif you want a prime)\n//const uint k = 1664525U;     // Numerical Recipes\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 n){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <5; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\nfloat fbm(vec2 n, int rep){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <rep; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n    return mix(\n            mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n                    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n            mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    f = 0.5000 * noise(p);\n    p *= 2.01;\n    f += 0.2500 * noise(p);\n    p *= 2.02;\n    f += 0.1250 * noise(p);\n\n    return f;\n}\n\n// Raymarching\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define ERNST_RENDER_SCALE float(1.)\n#define INV_ERNST_RENDER_SCALE (1./ERNST_RENDER_SCALE)\n#define MIN_DIST 0.0001\n#define MAX_DIST 80.\n#define ITERATION 200\n#define MAT_VOID vec3(-1)\n\n#define AMB_COL vec3(0.859,0.733,0.604)\n#define AMB_STRENGTH 0.1500\n#define FOG_COL vec3(0.722,0.620,0.518)*.75\n#define FOG_START -0.4500\n#define FOG_POW 1.\n\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n    R(p.xz, r.y);\n    R(p.yx, r.z);\n    R(p.zy, r.x);\n    return p;\n}\n\n\n//Animation\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// Easings\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// \"glsl-easings\": https://github.com/glslify/glsl-easings\nfloat linear(float t){return t;}\nfloat sineInOut(float t){return -0.5 * (cos(PI * t) - 1.0);}\nfloat quadraticInOut(float t){float p = 2.0 * t * t; return t < 0.5 ? p : -p + (4.0 * t) - 1.0;}\nfloat cubicInOut(float t){return t < 0.5 ? 4.0 * t * t * t : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;}\nfloat quarticInOut(float t) {return t < 0.5? +8.0 * pow(t, 4.0): -8.0 * pow(t - 1.0, 4.0) + 1.0;}\nfloat qinticInOut(float t){return t < 0.5 ? +16.0 * pow(t, 5.0) : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;}\nfloat exponentialInOut(float t){return t == 0.0 || t == 1.0 ? t : t < 0.5 ? +0.5 * pow(2.0, (20.0 * t) - 10.0) : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;}\nfloat circularInOut(float t){return t < 0.5 ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t)) : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);}\nfloat elasticInOut(float t){return t < 0.5 ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0)) : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;}\nfloat backInOut(float t){float f = t < 0.5 ? 2.0 * t : 1.0 - (2.0 * t - 1.0);float g = pow(f, 3.0) - f * sin(f * PI); return t < 0.5 ? 0.5 * g : 0.5 * (1.0 - g) + 0.5;}\nfloat bounceOut(float t){const float a = 4.0 / 11.0; const float b = 8.0 / 11.0; const float c = 9.0 / 10.0; const float ca = 4356.0 / 361.0; const float cb = 35442.0 / 1805.0; const float cc = 16061.0 / 1805.0; float t2 = t * t; return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;}\nfloat bounceInOut(float t){return t < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0)) : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;}\n\n\n\n// Read vec3(10bit/float) from a float...\nconst float THRESHOLD = .92;\n// Read vec3(10bit/float) from a float. Although can't say so smart...\nvec3 unpackSnorm3x10(uint x)\n{\n    uvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n    uvec3 sig = r >> 9;\n    uvec3 mag = r & uvec3(0x1FF);\n    vec3 fsig = mix(vec3(1), vec3(-1), greaterThanEqual(sig,uvec3(1)));\n    vec3 fmag = vec3(mag);\n    return fsig * fmag / 511.0/THRESHOLD;\n}\nfloat packSnorm3x10(vec3 x) {\n    uvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(vec3(0),sign(x))));\n    x = clamp(x*THRESHOLD,-THRESHOLD, THRESHOLD) * 511.0;\n    uvec3 mag = uvec3(abs(x));\n    uvec3 r = sig << 9 | mag;\n    return float((r.x << 22) | (r.y << 12) | (r.z << 2));\n}\n\nuint packSnorm3x10_2(vec3 x) {\n    x = clamp(x,-1., 1.) * 511.;\n    uvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(sign(x),vec3(0))));\n    uvec3 mag = uvec3(abs(x));\n    uvec3 r = sig.xyz << 9 | mag.xyz;\n    return r.x << 22 | r.y << 12 | r.z << 2;\n}\n\nvec3 unpackSnorm3x10_2(uint x) {\n    uvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n    uvec3 sig = r >> 9;\n    uvec3 mag = r & uvec3(0x1FF);\n    vec3 fsig = mix(vec3(-1), vec3(1), greaterThanEqual(sig, uvec3(1)));\n    vec3 fmag = vec3(mag) / 511.;\n    return fsig * fmag;\n}\n\n#define pack(x) uintBitsToFloat(packSnorm3x10_2(x))\n#define unpack(x) unpackSnorm3x10_2(floatBitsToUint(x))\n\nuint packSnorm4x8(vec4 x) {\n    x = clamp(x,-1.0, 1.0) * 127.0;\n    uvec4 sig = uvec4(mix(vec4(0), vec4(1), greaterThanEqual(sign(x),vec4(0))));\n    uvec4 mag = uvec4(abs(x));\n    uvec4 r = sig << 7 | mag;\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n\nvec4 unpackSnorm4x8(uint x) {\n    uvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    uvec4 sig = r >> 7;\n    uvec4 mag = r & uvec4(0x7F);\n    vec4 fsig = mix(vec4(-1), vec4(1), greaterThanEqual(sig,uvec4(1)));\n    vec4 fmag = vec4(mag) / 127.0;\n    return fsig * fmag;\n}\n#define pack4(x) uintBitsToFloat(packSnorm4x8(x))\n#define unpack4(x) unpackSnorm4x8(floatBitsToUint(x))\n\n#define pack_bl(x) uintBitsToFloat(packSnorm3x10(x))\n#define unpack_bl(x) unpackSnorm3x10(floatBitsToUint(x))\nvoid readFrameTexCamera3x10(sampler2D tex, int id, int f, inout vec3 pos, inout vec4 quat, inout float fov, in vec3 tra_scl, in vec4 quat_scl)\n{\n    vec4 anm = texelFetch(tex, ivec2(f, id),0);\n    pos = unpack_bl(anm.x) * tra_scl;\n\n    quat = vec4(0);\n    quat.xyz = unpack_bl(anm.y)*quat_scl.xyz;\n    vec3 qw_fov_zero = unpack_bl(anm.z);\n    quat.w = qw_fov_zero.x*quat_scl.w;\n\n    fov = qw_fov_zero.y;\n}\n\nvoid readFrameTex3x10(sampler2D tex, int id, int f, inout vec3 pos, inout vec3 rot, in vec3 tra_scl)\n{\n    vec4 anm = texelFetch(tex, ivec2(f, id),0);\n    pos = unpack_bl(anm.x) * tra_scl;\n    rot = unpack_bl(anm.y).xyz * PI;\n}\n\nvoid readFrameTexLight3x10(sampler2D tex, int id, int f, inout vec3 dir, inout vec3 col, inout float clip_start, inout float clip_end, inout float softness, in vec3 shadow_props_scl)\n{\n    vec4 anm = texelFetch(tex, ivec2(f, id),0);\n    dir = unpack_bl(anm.x).xzy;\n    col = unpack_bl(anm.y);\n    vec3 shadow = unpack_bl(anm.z);\n    clip_start = shadow.x*shadow_props_scl.x;\n    clip_end = shadow.y*shadow_props_scl.y;\n    softness = shadow.z*shadow_props_scl.z;\n}\n\n\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n    vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n    vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n    vec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n    p4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}