{
    "Shader": {
        "info": {
            "date": "1540385476",
            "description": "A fairly minimal dual-level Truchet pattern implementation -- utilizing a large non-overlapping tile and a complimentary smaller one.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltcfz2",
            "likes": 24,
            "name": "Minimal Dual-Level Truchet",
            "published": 3,
            "tags": [
                "truchet",
                "dual",
                "minimal",
                "multiscale",
                "quadtree"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1222
        },
        "renderpass": [
            {
                "code": "/*\n\t\n\tMinimal Dual Level Truchet\n\t--------------------------\n\n\tThis is a fairly minimal dual-level Truchet pattern implementation -- utilizing \n\ta large non-overlapping tile and a complimentary smaller one. Obviously, it's \n    less interesting than the multiscale version constructed with overlapping tiles, \n\tbut it has a certain clean appeal to it.\n\n\tI've put it together for anyone who's interested in the process, but doesn't have \n\ttime to decipher the logic in my \"Quadtree Truchet\" example. By the way, Abje has \n\tan interesting version, which I've linked to below.\n\n\tI've made the two-iteration quadtree loop as minimal, yet readable, as possible,\n\tbut it could be cut down further. However, I'll leave it to the code golfers to \n    write the one or two tweet version. :)\n\n    I really held back on the rendering, but I at least wanted to make it look \n\tpresentable. When rendering a 2D distance field, I usually like to take advantage \n\tof the pixel shader environment and mix in a few layers. This has the standard \n\tshadow, edge and opaque layers, with some additional field-based patterns and \n\thighlighting. For anyone not familiar with the process, it's worth learning,\n\tbecause you can add some extra dimension to your flat 2D imagery, which, on a lot \n\tof occasions, can provide more viual interest.\n\n\tAnyway, 2D extruded and 3D versions are next. I also have a more interesting \n    looking tri-level example, so I should probably post that as well.\n\n\t\n\t// Multiscale versions with overlapping tiles:\n\n\t// More elaborate quadtree example.\n\tQuadtree Truchet - Shane\n\thttps://www.shadertoy.com/view/4t3BW4\n\n    // Abje always has an interesting way of coding things. :)\n\tblack and white truchet quadtree - abje\n\thttps://www.shadertoy.com/view/MtcBDM\n\n\t// A really simple non-overlapping quadtree example.\n\tRandom Quadtree - Shane\n\thttps://www.shadertoy.com/view/llcBD7\n\t\n\n*/\n\n// Standard single scale (one level) Truchet pattern -- otherwise knows as a \n// Truchet pattern. :) Actually, I find it effectively illustrates how the\n// dual scale pattern relates to the regular one.\n//#define SINGLE_SCALE\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p){ \n\n    // Faster, but doesn't disperse things quite as nicely.\n    return fract(vec2(262144, 32768)*sin(dot(p, vec2(57, 27))));\n}\n \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Screen coordinates, plus some screen resolution restriction to stop the\n    // fullscreen version from looking too bloated... unless people are on a high\n    // PPI device, in which case you'd need a PPI variable to account for that,\n    // which isn't standard or trivial at present. Either way, it's all too hard,\n    // so I'll make do with this hack. :)\n    float iRy = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iRy;\n    \n    // Scaling and translation.\n    vec2 oP = uv*4. + vec2(.5, iTime/2.);\n\n    \n    // Distance tile values and random entries. Each represents the chance that\n    // a tile for each layer will be rendered. For instance, the large tile \n    // will have a 50% chance, and the remaining smaller tiles will have a 100% \n    // chance. I.e., they'll fill in the rest of the squares.\n    vec2 d = vec2(1e5), rndTh = vec2(.5, 1);\n    \n    #ifdef SINGLE_SCALE\n    rndTh.x = 1.;\n    #endif\n\n    // Initial cell dimension.\n    float dim = 1.;    \n    \n    for(int k=0; k<2; k++){\n        \n        // Base cell ID.\n\t\tvec2 ip = floor(oP*dim);\n        \n        // Unique random ID for the cell.\n        vec2 rnd = hash22(ip);\n\n       \n\t\t// If the random cell ID at this particular scale is below a certain threshold, \n        // render the tile. \n        if(rnd.x<rndTh[k]){\n            \n            // Tile construction: By the way, the tile designs you use are limited by your imagination. \n        \t// I chose the ones that seemed most logical at the time -- Arcs and grid vertice circles.\n\n           \n            // Local cell coordinate.\n            vec2 p = oP - (ip + .5)/dim; // Equivalent to: mod(oP, 1./dim) - .5/dim;\n            \n            // Grid lines.\n \t\t    d.y = abs(max(abs(p.x), abs(p.y)) - .5/dim) - .0075;\n         \n             \n            // Use the unique random cell number to flip half the tiles vertically, which,\n            // in this case, has the same effect as rotating by 90 degrees.\n            p.y *= rnd.y>.5? 1. : -1.;\n           \n            // Arc width: Arranged to be one third of the cell side length. This is half that\n            // length, but it gets doubled below.\n            float aw = .5/3./dim;\n\n            // Rendering the two arcs by rendering one arc flipped across the diagonal: It's an old \n            // trick that works in some situations, like this one. Alternatively, you could uncomment \n            // the diagonal reflection line below and render another arc on the opposite diagonal.\n            p = p.x>-p.y? p : -p.yx;\n            d.x = abs(length(p - .5/dim) - .5/dim) - aw;\n            \n            // Negate the arc distance field values on the second tile.\n            d.x *= k==1? -1. : 1.;\n          \n            #ifndef SINGLE_SCALE \n            // Placing circles at the four corner grid vertices. If you're only rendering one \n            // level (rndTh[0]=1.), you won't need them... unless you like the look, I guess. :)\n            d.x = min(d.x, (length(abs(p) - .5/dim) - aw));\n            #endif\n             \n            // Increasing the overall width of the pattern slightly.\n            d.x -= .01;\n \n            // Since we don't need to worry about neighbors\n            break;\n\n        }\n        \n        // Subdividing. I.e., decrease the cell size by doubling the frequency.\n        // Equivalent to writing \"dim = exp2(float(k))\" at the top of the loop.\n        dim *= 2.;\n        \n    }\n    \n    // RENDERING.\n    //\n    // A lot of the following lines are for decorative purposes.\n    \n    // Scene color. Initiated to the background.\n    vec3 col = vec3(.1);\n\n    // Render the grid lines.\n    float fo = 4./iRy;\n    col = mix(col, vec3(0), (1. - smoothstep(0., fo*5., d.y - .01))*.5); // Shadow.\n    col = mix(col, vec3(1), (1. - smoothstep(0., fo, d.y))*.15); // Overlay.\n \n\n    // Render the tiles. This is a lazy way to do things, but it gets the job done.\n    fo = 10./iRy/sqrt(dim);\n    float sh = max(.75 - d.x*10., 0.); // Distance field-based shading.\n    sh *= clamp(-sin(d.x*6.283*18.) + .75, -.25, 1.) + .25; // Pattern overlay.\n\n    col = mix(col, vec3(0), (1. - smoothstep(0., fo*5., d.x))*.75); // Shadow.\n    col = mix(col, vec3(0), 1. - smoothstep(0., fo, d.x)); // Outline.\n    // Greyish, shaded, pattern overlay.\n    col = mix(col, vec3(.3)*sh, 1. - smoothstep(0., fo, d.x + .015)); \n    // Pinkish, shaded color.\n    // abs(d.x + .12) - .02 = max(d.x + .1, -(d.x + .14))));\n    col = mix(col, vec3(.8, .03, .1)*sh, 1. - smoothstep(0., fo, abs(d.x + .12) - .02));\n      \n    \n     \n    // UV color mixing.\n    col = mix(col, col.xzy, uv.y*.5 + .5);\n    \n    // Mild spotlight.\n    col *= max(1.25 - length(uv)*.25, 0.);\n    \n\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}