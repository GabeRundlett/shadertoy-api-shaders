{
    "Shader": {
        "info": {
            "date": "1537297534",
            "description": "Hausdorff distance metric function applied between two sets of physical particles. Particle code with physics derived from qwertsol (https://www.shadertoy.com/view/MsKBzD).",
            "flags": 32,
            "hasliked": 0,
            "id": "XlGyz3",
            "likes": 11,
            "name": "Hausdorff Distance",
            "published": 3,
            "tags": [
                "particles",
                "physics",
                "collisions",
                "hausdorff"
            ],
            "usePreview": 0,
            "username": "CLPB",
            "viewed": 918
        },
        "renderpass": [
            {
                "code": "// From https://www.shadertoy.com/view/MsKBzD\n\n// Hausdorff distance metric is the maximum minimum distance of any point in set A to a point in set B.\n// Note that dH(A.B) != dH(B,A)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n\n    fragColor = vec4(vec3(0), 1.0);\n    \n    for (int i=0; i<N; i++) \n    {\n        vec4 particle = getBody(i, iChannel0) * iResolution.y;\n        vec4 properties = getBodyProperties(i, iChannel0);\n        properties.w *= iResolution.y;\n        \n        drawCircle(uv, particle.xy, properties.w, vec4(properties.rgb, 1.0), fragColor);\n    }\n    \n    float hsdG=0.0;\n    float hsdR=0.0;\n    vec2 hsGdir = vec2(0.0);\n    vec2 hsRdir = vec2(0.0);\n    vec4 hsG = vec4(100.0), hsR = vec4(100.0);\n    \n    for (int i=0; i<N; i++){\n        vec4 part1 = getBody(i, iChannel0) * iResolution.y;\n        vec4 prop1 = getBodyProperties(i, iChannel0);\n        \n        vec4 clPart, clProp;\n        float closest = 99999999.0;\n        \n        // find closest opposite set point to current particle\n        for (int j=0; j<N; j++){\n            vec4 part2 = getBody(j, iChannel0) * iResolution.y;\n        \tvec4 prop2 = getBodyProperties(j, iChannel0);\n            \n            float dist = distance(part1.xy, part2.xy);\n            \n            if ((prop1.x > 0.5 && prop2.x < 0.5) \n             || (prop1.x < 0.5 && prop2.x > 0.5)) {\n            \tif (dist < closest){\n                    closest = dist;\n                    clPart = part2;\n                    clProp = prop2;\n                }\n\t\t\t}\n\t\t}\n        \n        // set furthest distance to nearest particle of opposite set \n        if ((prop1.x > 0.5) && (closest > hsdR)){\n            hsdR = closest;\n            hsR = part1;\n            hsRdir = normalize(clPart.xy - part1.xy);\n        }\n        if ((prop1.x < 0.5) && (closest > hsdG)) {\n            hsdG = closest;\n            hsG = part1;\n            hsGdir = normalize(clPart.xy - part1.xy);\n        }\n    }\n    \n    //vec3 col = texture(iChannel0, vec2(uv.x*0.0003,uv.y*0.0003)).rgb;\n    //fragColor = mix(fragColor, vec4(col, 1.0), col.r<=0. && col.g<=.0 && col.b<=.0?0.0:1.0);\n    \n  \tdrawCircle(uv, hsG.xy, 4.0, vec4(0.0,0.0,1.0,1.0), fragColor);\n    drawCircleO(uv, hsG.xy, hsdG, vec4(0.0,1.0,0.0,0.2), fragColor);\n    \n    drawCircle(uv, hsR.xy, 4.0, vec4(0.0,1.0,1.0,1.0), fragColor);\n    drawCircleO(uv, hsR.xy, hsdR, vec4(1.0,0.0,0.0,0.2), fragColor);\n    \n    drawLine(uv, hsR.xy, hsR.xy+hsRdir*hsdR, 1.0, vec4(1.0,1.0,1.0,0.2), fragColor);\n    drawLine(uv, hsG.xy, hsG.xy+hsGdir*hsdG, 1.0, vec4(1.0,1.0,1.0,0.2), fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    if (fragCoord.x < float(N) && fragCoord.y < 2.0)\n    {\n        if (iFrame < 1) \n        {\n            if (fragCoord.y < 1.0)\n            {\n                // Initialize particles (position and speed)\n                vec3 h1 = hash(uvec3(fragCoord, 13.0));\n                h1.x *= iResolution.x / iResolution.y;\n                vec3 h2 = hash(uvec3(h1 * 129.0));\n\n                fragColor = createBody(h1.xy, (h2.yz - vec2(.5)));\n            }\n            else\n            {\n                // Initialize particles (color and radius)\n                vec3 h1 = hash(uvec3(fragCoord, 13.0));\n                h1.x *= iResolution.x / iResolution.y;\n                vec3 h2 = hash(uvec3(h1 * 129.0));\n                \n                vec3 c = h1.x < .5 ? vec3(0.0,1.0,0.0) : vec3(1.0,0.0,0.0);\n                \n                fragColor = vec4(c, .02);\n            }\n        } \n        else \n        {\n            if (fragCoord.y < 1.0) \n            {\n            \t// Physics simulation\n                vec4 particle = getBody(int(fragCoord.x), iChannel0);\n                float radius = getBodyProperties(int(fragCoord.x), iChannel0).w;\n                \n                // Collisions\n                // Floor\n                if (particle.w < 0.0 && particle.y < radius)\n                    particle.w = -particle.w;\n                // Roof\n                if (particle.w > 0.0 && 1.0 - particle.y < radius)\n                    particle.w = -particle.w;\n                // Left wall\n                if (particle.z < 0.0 && particle.x < radius)\n                    particle.z = -particle.z;\n                // Right wall\n                if (particle.z > 0.0 && (iResolution.x / iResolution.y) - particle.x < radius)\n                    particle.z = -particle.z;\n                \n                // Particles\n                float m0 = mass(radius);\n                float im0 = 1.0 / m0;\n                for (int i=0; i<N; i++)\n                {\n                    if (i == int(fragCoord.x))\n                        continue;\n                    \n                    vec4 other = getBody(i, iChannel0);\n                    float otherRadius = getBodyProperties(i, iChannel0).w;\n                    float m1 = mass(otherRadius);\n                    \n                \tvec2 d = other.xy - particle.xy;\n                \tfloat l = length(d);\n                    if (l < (radius + otherRadius))\n                    {                      \n                        vec2 v1 = other.zw;\n                    \t\n                    \tvec2 dv = particle.zw - v1;\n                    \tvec2 n = normalize(d);\n                    \t\n                    \tfloat cv = dot(dv, n);\n                    \tif (cv > 0.0)\n                    \t{\n                    \t    float im1 = 1.0 / m1;\n                            float m = im0 / (im0 + im1);\n                   \t\t\tvec2 impulse = (n * (-(1.0f + cof) * cv)) * m;\n                            \n                            particle.zw += impulse;\n                        }\n                    } \n                }\n                \n                // Update position\n                // FIXME: Tied to framerate due to large framedelta pushing particles offscreen\n                particle.xy += particle.zw * 0.01 * timeMultiplier;\n                \n                // Save state\n                fragColor = particle;\n            }\n            else\n            {\n            \tfragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float pi = 3.14159265;\nconst float timeMultiplier = .5;\nconst float cof = 1.0;\nconst int N = 16;\n\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec4 hue( float x )\n{\n    return .6 + .6 * cos(6.3 * x  + vec4(0,23,21,0));\n}\n\nfloat mass( float radius )\n{\n    return 1.33333 * pi * pow(radius, 3.0);\n}\n\nvec4 createBody( vec2 pos, vec2 speed )\n{\n    return vec4(pos, speed);\n}\n\nvec4 getBody( int i, sampler2D sampler )\n{      \n    return texelFetch(sampler, ivec2(i, 0), 0);\n}\n\nvec4 getBodyProperties( int i, sampler2D sampler )\n{      \n    return texelFetch(sampler, ivec2(i, 1), 0);\n}\n\nvoid drawCircle( vec2 coords, vec2 center, float radius, vec4 color, inout vec4 outputColor)\n{\n    float sD = distance(coords, center);\n\tfloat a = 1.0 - clamp(sD - radius + .5, 0.0, 1.0);\n    \n    outputColor = mix(outputColor, color, a * color.a);\n}\n\nvoid drawCircleO( vec2 coords, vec2 center, float radius, vec4 color, inout vec4 outputColor)\n{\n    float sD = distance(coords, center);\n\tfloat a = 1.0 - clamp(sD - radius + .5, 0.0, 1.0);\n    a *= ((mod(sD, 20.0) > 18.0) || (sD > radius-3.0) ? 1.0 : 0.0);\n    \n    outputColor = mix(outputColor, color, a * color.a);\n}\n\nfloat dLine(in vec2 a, in vec2 b, in vec2 p)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n\treturn length(pa-ba*h);\n}\n\nvoid drawLine( vec2 coords, vec2 a, vec2 b, float thickness, vec4 color, inout vec4 outputColor)\n{\n    float sD = dLine(a, b, coords);\n\tfloat alpha = 1.0 - clamp(sD - thickness + .5, 0.0, 1.0);\n    \n    outputColor = mix(outputColor, color, alpha * color.a);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}