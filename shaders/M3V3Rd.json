{
    "Shader": {
        "info": {
            "date": "1718115896",
            "description": "Psychedelic Wired (via DarkStar)\nMouse around to accelerate trip (top left = safe space.. lol)\ncredit to @kishimisu",
            "flags": 0,
            "hasliked": 0,
            "id": "M3V3Rd",
            "likes": 2,
            "name": "Psychedelic Bright Wired Star",
            "published": 3,
            "tags": [
                "shader"
            ],
            "usePreview": 0,
            "username": "timmaffett",
            "viewed": 153
        },
        "renderpass": [
            {
                "code": "// Fork of \"DarkStar\" by duo. https://shadertoy.com/view/43y3zd\n// 2024-06-11 14:12:06\n\n// Fork of \"Wired\" by kishimisu. https://shadertoy.com/view/4c2XDc\n// 2024-06-11 14:09:12\n\n/* \"Wired\" by @kishimisu (2024) - https://www.shadertoy.com/view/4c2XDc\n\n   I wonder what it's powering...\n\n   This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 \n   International License       (https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)\n*/\n\n\n// customizable color from @WhiteTophat  in https://www.shadertoy.com/view/dlBczW\nvec4 lerp(vec4 a, vec4 b, float t) {\n    return (a * vec4(t)) + (b * vec4(1.0-t));\n}\nvec4 lerp(vec4 a, vec4 b, vec4 t) {\n    return (a * t) + (b * (vec4(1.0) * t));\n}\n\nvec4 hue2rgb(float hue) {\n    hue = fract(hue); //only use fractional part of hue, making it loop\n    float r = abs(hue * 6.0 - 3.0) - 1.0; //red\n    float g = 2.0 - abs(hue * 6.0 - 2.0); //green\n    float b = 2.0 - abs(hue * 6.0 - 4.0); //blue\n    vec4 rgb = vec4(r,g,b, 1.0); //combine components\n    rgb = clamp(rgb, 0.0, 1.0); //clamp between 0 and 1\n    return rgb;\n}\nvec4 hsv2rgb(vec3 hsv) {\n    vec4 rgb = hue2rgb(hsv.x); //apply hue\n    rgb = lerp(vec4(1.0), rgb, 1.0 - hsv.y); //apply saturation\n    rgb = rgb * hsv.z; //apply value\n    return rgb;\n}\n \n\n#define r(a) mat2 (cos(a + vec4(0,33, 11,0)));\n#define R(p, T) p.yx *= r(round((atan(p.y, p.x) + T) * 1.91) / 1.91 - T)\nvoid mainImage(out vec4 O, vec2 F) {\n    float i, t = 0.0, d, k = iTime / 8.0;\n\n\nvec2 mouseUV = iMouse.xy==vec2(0.) ? vec2(0.1,0.9) : iMouse.xy / iResolution.xy;\n\n    O = vec4(0.0);\n    vec2 R = iResolution.xy;\n    vec3 p;\n\n    for (i = 0.0; i < 30.0; i++) {\n        p = vec3(F + F - R, R.y);\n        p = normalize(p) * t;\n        p.z -= 3.0;\n        p.xz *= r(k + 0.1);\n        p.zy *= r(k + k);\n        d = length(p)- sin(k + k) * .5 - 0.4;\n\n        p.y += sin(p.x * cos(k + k) + k * 4.0) * sin(k) * 0.3;\n        R(p.xy, 0.0);\n        R(p.xz, k);\n        p.x = mod(p.x + k * 8.0, 2.0) - 1.0;\n        t += d = min(d, length(p.yz) - 0.03) * 0.5;\n\n        O += 0.01 * (cos(t - k + vec4(0, 1, 3, 0))) / (length(p) - 0.02) + (0.025 + sin(k) * 0.01) / (0.8 + d * 24.0);\n    }\n\n    O = fract(O+ hsv2rgb(p+t*sin(iTime)*(mouseUV.x/sin(mouseUV.y))) +(iTime/10.));\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}