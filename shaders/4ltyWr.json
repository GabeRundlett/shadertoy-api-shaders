{
    "Shader": {
        "info": {
            "date": "1532256179",
            "description": "Body members: joints  by  inverse kinematics\n+ quadratic Bezier ( cleanup of  [url]https://shadertoy.com/view/XdB3Ww[/url] )\n\ntry STYLE = 0, 1, 2",
            "flags": 0,
            "hasliked": 0,
            "id": "4ltyWr",
            "likes": 11,
            "name": "QBezier + inv-K body 2",
            "published": 3,
            "tags": [
                "quadraticbezier",
                "inversekinematics"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 687
        },
        "renderpass": [
            {
                "code": "#define STYLE 0  // 0 1 2\n    \n// variant of https://shadertoy.com/view/4ttcDn\n// keep on floor.\n\n// -----------------------------------------------------------------\n// QBezier from https://shadertoy.com/view/XtdyDn\n//         cleanup of https://shadertoy.com/view/XdB3Ww\n\n//Find roots using Cardano's method. http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\nvec2 solveCubic2(vec3 a)\n{\n\tfloat p  = a.y - a.x*a.x/3.,\n\t      p3 = p*p*p,\n\t      q  = a.x* ( 2.*a.x*a.x - 9.*a.y ) /27. + a.z,\n\t      d  = q*q + 4.*p3/27.;\n    \n\tif(d>0.) {\n\t\tvec2 x = ( vec2(1,-1)*sqrt(d) -q ) *.5;\n        x = sign(x) * pow( abs(x) , vec2(1./3.) );\n  \t\treturn vec2( x.x+x.y -a.x/3. );\n  \t}\n    \n \tfloat v = acos( -sqrt(-27./p3)*q*.5 ) / 3.,\n \t      m = cos(v),\n \t      n = sin(v)*sqrt(3.);\n\n\treturn vec2(m+m,-n-m) * sqrt(-p/3.) - a.x/3.;\n}\n\n// How to solve the equation below can be seen on this image.\n// http://www.perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\n#define dd(a) dot(a,a)\n\nfloat dQBezier(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n\tb = mix( b+vec2(1e-4), b, abs(sign(b*2.-a-c)) );\n\tvec2 A = b-a,\n\t     B = c-b-A,\n\t     C = p-a,\n\t     D = A*2.,\n\tP = solveCubic2( vec3(-3.*dot(A,B), dot(C,B)-2.*dd(A), dot(C,A))/-dd(B) );\n    P = clamp( P,0.,1.); // curve parameterization\n\n\treturn sqrt( min( dd( (D+B*P.x)*P.x -C ),\n                      dd( (D+B*P.y)*P.y -C )));\n}\n\n// ---------------------------------------------------------------\n\n// Does the inverse kinematics by finding the joint position between p0 and p2\n// ensuring fix member length |L|.  Sign(L) choose side. \n#define knee(p0,p2,L) ( l = p2-p0,                                  \\\n                        h = sqrt(max(0.,L*L-dot(l,l)))/2. *sign(L), \\\n                        (p0+p2)/2. +  h * normalize( vec2(-l.y,l.x) ) )\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float t = iTime, h, d, s;\n    vec2 R =   iResolution.xy,\n         U = ( u+u - R ) / R.y;\n    \n    // --- QBezier curves storage\n#define N 6\n    vec2 P0[N],P1[N],P2[N];                             // QBezier nodes\n    float W[N];                                         // width\n    int k=-1;\n    vec2 m = vec2(1e5), M = vec2(-1e5);                 // drawing Bbox\n         \n#define push(p0,p1,p2,w)  k++; P0[k]=p0; P1[k]=p1; P2[k]=p2; W[k]=w; \\\n                          m = min(min(m+.1*w,p0),min(p1,p2)) -.1*w;  \\\n                          M = max(max(M-.1*w,p0),max(p1,p2)) +.1*w; // BBbox\n    \n    // --- define animated members\n    \n\tvec2 p0 = vec2(0,.1), l,                            // body end or neck\n\t     p2 = p0 + vec2(0,.75);                         // distant end\n\n    push(p2,p2,p2, 2.);                                 // head\n\n    p2 = p0 + vec2(0,.4);\n    push(p0,(p0+p2)/2.,p2, 1.2 );                       // body\n    \n    p0.x += .125; p0.y -= .1;\n    p2 = p0 + vec2(cos(t*1.3)*.4, -.5 +sin(t*.3)*.48 ); \n    push(p0,knee(p0,p2,1.),p2, 1. );                    // right leg\n\n    t += .5;\n    p0.x -= .25;\n    p2 = p0 + vec2(cos(t*1.3)*.4, -.5 +sin(t*.3)*.48 ),\n    push(p0,knee(p0,p2,1.),p2, 1. );                    // left leg\n    \n    t += .5; p0.y += .6;\n    p2 = p0 + vec2(-.4 +cos(t*1.3)*.38, sin(t*.3)*.5 );\n    push(p0,knee(p0,p2,1.),p2, .6 );                    // left hand\n  \n    t += .5; p0.x += .25;\n    p2 = p0 + vec2(.4 +cos(t*1.3)*.38, sin(t*.3)*.5 );\n    push(p0,knee(p0,p2,1.),p2, .6 );                    // right hand\n    \n    // --- draw\n    m.x = 0.; m.y+=1.;                                  // offset to y_min\n\n#if STYLE == 0       // draw blended members\n    O -= O;\n    for (int i=k; i>=0; i--) {\n        d = dQBezier(U,P0[i]-m,P1[i]-m,P2[i]-m) / W[i]; // blend members\n        s = smoothstep(5./R.y,0., d-.1 );               // shape mask\n        vec4 C = vec4( (1.-d*d/.01) * vec3(i!=1,1,1),1);// color & shading\n        O += (1.-O.a)* C * s;                           // blend front to back\n      //O = mix(O, C , s);                              // blend back to front\n      //O.gb += max(0.,1.-50.*length(U-P1[i]+m));       // show ctrl points\n    }\n    O *= vec4(1,.8,.8,1);\n\n#elif  STYLE == 1    // draw skeleton of members\n    \n    d = 1.;\n    for (int i=k; i>=0; i--)                            // nearest member\n        d = min( d, dQBezier(U,P0[i]-m,P1[i]-m,P2[i]-m) / W[i] );     \n  //O = vec4(smoothstep(5./R.y,0., d-.1 ) );\n    d/=.1; O = vec4(1.-d*d);\n  //O.x = max(O.x, cos(10.*d) );                        // echos\n\n#else                // draw silouhette\n    \n#define K 40.    \n#define min(a,b) -log( exp( -K*a ) + exp( -K*b ) ) / K  // smoothMin\n    d = 1.;\n    for (int i=k; i>=0; i--)                            // nearest member\n        d = min( d, dQBezier(U,P0[i]-m,P1[i]-m,P2[i]-m) / W[i] );     \n     O = vec4(smoothstep(5./R.y,0., d-.1 ) );\n   //d/=.1; O = vec4(1.-d*d);\n   //O.x = max(O.x, cos(100.*d) );                      // echos   \n    \n#endif\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}