{
    "Shader": {
        "info": {
            "date": "1620346080",
            "description": "Wanted to test out my auto tiling logic on a cool shader. So copied[ https://www.shadertoy.com/view/ldscWH ]and added auto tiling logic. Pages through all possible 16 auto tile sub tiles.",
            "flags": 0,
            "hasliked": 0,
            "id": "ssSXWm",
            "likes": 3,
            "name": "Shane's Noise, but auto tiled",
            "published": 3,
            "tags": [
                "tiled",
                "shane",
                "autotile",
                "ruletile"
            ],
            "usePreview": 0,
            "username": "DEKTEN",
            "viewed": 289
        },
        "renderpass": [
            {
                "code": "\n//: A copy of shane's \"Smooth Noise Countours\" with auto tiling math applied to it.\n//: Pages through the 16 possible sub-tiles of an auto tile sets and maps shanes\n//: shader onto the tile. The screen being the coordinate space of the tile.\n//:\n//: You can use this kind of math to create procedural auto tiling.\n//:\n//: Shane's original shader: https://www.shadertoy.com/view/ldscWH\n//: \n//: My twitch coding stream: www.twitch.com/kanjicoder\n\n\n// Variable to a keep a copy of the noise value prior to palettization. Used to run a soft gradient \n// over the surface, just to break things up a little.\nfloat ns;\n\n\n//float sFract(float x, float sm){ float fx = fract(x); return fx - smoothstep(fwidth(x)*sm, 0., 1. - fx); }\n//float sFract(float x, float sm){ float fx = fract(x); return min(fx, fx*(1. - fx)/fwidth(x)/sm); }\n\n// Based on Ollj's smooth \"fract\" formula.\nfloat sFract(float x, float sm){\n    \n    // Extra smoothing factor. \"1\" is the norm.\n    const float sf = 1.; \n    \n    // The hardware \"fwidth\" is cheap, but you could take the expensive route and\n    // calculate it by hand if more quality was required.\n    vec2 u = vec2(x, fwidth(x)*sf*sm);\n    \n    // Ollj's original formula with a transcendental term omitted.\n    u.x = fract(u.x);\n    u += (1. - 2.*u)*step(u.y, u.x);\n    return clamp(1. - u.x/u.y, 0., 1.); // Cos term ommitted.\n}\n\n\n\n// Only correct for nonnegative values, but in this example, numbers aren't negative.\nfloat sFloor(float x){ return x - sFract(x, 1.); } \n\n// Standard hue rotation formula with a bit of streamlining. \nvec3 rotHue(vec3 p, float a){\n\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr, 0., 1.);\n}\n\n\n\n// vec3 to vec3 hash algorithm.\nvec3 hash33(vec3 p) { \n\n    // Faster, but doesn't disperse things quite as nicely as the block below it. However, when framerate\n    // is an issue, and it often is, this is the one to use. Basically, it's a tweaked amalgamation I put\n    // together, based on a couple of other random algorithms I've seen around... so use it with caution,\n    // because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; // return fract(vec3(64, 8, 1)*32768.0*n)*2.-1.; \n\n    // I'll assume the following came from IQ.\n    //p = vec3( dot(p, vec3(127.1, 311.7, 74.7)), dot(p, vec3(269.5, 183.3, 246.1)), dot(p, vec3(113.5, 271.9, 124.6)));\n    //return (fract(sin(p)*43758.5453)*2. - 1.);\n\n}\n\n\n\n// Cheap, streamlined 3D Simplex noise... of sorts. I cut a few corners, so it's not perfect, but it's\n// artifact free and does the job. I gave it a different name, so that it wouldn't be mistaken for\n// the real thing.\n// \n// Credits: Ken Perlin, the inventor of Simplex noise, of course. Stefan Gustavson's paper - \n// \"Simplex Noise Demystified,\" IQ, other \"ShaderToy.com\" people, etc.\nfloat tetraNoise(in vec3 p)\n{\n    // Skewing the cubic grid, then determining the first vertice and fractional position.\n    vec3 i = floor(p + dot(p, vec3(.333333)) );  p -= i - dot(i, vec3(.166666)) ;\n    \n    // Breaking the skewed cube into tetrahedra with partitioning planes, then determining which side of the \n    // intersecting planes the skewed point is on. Ie: Determining which tetrahedron the point is in.\n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1. - i1.zxy); i1 = min(i1, 1. - i1.zxy);    \n    \n    // Using the above to calculate the other three vertices -- Now we have all four tetrahedral vertices.\n    // Technically, these are the vectors from \"p\" to the vertices, but you know what I mean. :)\n    vec3 p1 = p - i1 + .166666, p2 = p - i2 + .333333, p3 = p - .5;\n  \n\n    // 3D simplex falloff - based on the squared distance from the fractional position \"p\" within the \n    // tetrahedron to the four vertice points of the tetrahedron. \n    vec4 v = max(.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    \n    // Dotting the fractional position with a random vector, generated for each corner, in order to determine \n    // the weighted contribution distribution... Kind of. Just for the record, you can do a non-gradient, value \n    // version that works almost as well.\n    vec4 d = vec4(dot(p, hash33(i)), dot(p1, hash33(i + i1)), dot(p2, hash33(i + i2)), dot(p3, hash33(i + 1.)));\n     \n     \n    // Simplex noise... Not really, but close enough. :)\n    return clamp(dot(d, v*v*v*8.)*1.732 + .5, 0., 1.); // Not sure if clamping is necessary. Might be overkill.\n\n}\n\n\n// The function value. In this case, slightly-tapered, quantized Simplex noise.\nfloat func(vec2 p){\n    \n    // The noise value.\n    float n = tetraNoise(vec3(p.x*4., p.y*4., 0) - vec3(0, .25, .5)*iTime);\n    \n    // A tapering function, similar in principle to a smooth combine. Used to mutate or shape \n    // the value above. This one tapers it off into an oval shape and punches in a few extra holes.\n    // Airtight uses a more interesting triangular version in his \"Cartoon Fire\" shader.\n    float taper = .1 + dot(p, p*vec2(.35, 1));\n\tn = max(n - taper, 0.)/max(1. - taper, .0001);\n    \n    // Saving the noise value prior to palettization. Used for a bit of gradient highlighting.\n    ns = n; \n    \n    // I remember reasoning to myself that the following would take a continuous function ranging\n    // from zero to one, then palettize it over \"palNum\" discreet values between zero and one\n    // inclusive. It seems to work, but if my logic is lacking (and it often is), feel free to \n    // let me know. :)\n    const float palNum = 9.; \n    // The range should strictly fall between zero and one, but for some crazy reason, numbers fall\n    // outside the range, so I've had to clamp it. I know the computer is never wrong, so I'm \n    // probably overlooking something. Having said that, I don't trust the GPU \"fract\" function much.\n    //return clamp(sFloor(n*(palNum - .001))/(palNum - 1.), 0., 1.);\n    return n*.25 + clamp(sFloor(n*(palNum - .001))/(palNum - 1.), 0., 1.)*.75;\n    \n}\n\nvec2 getSubTileCoords( vec2 f_c ){\n\n    //: Pretend the entire screen is one tile for this  -----://\n    //: example code. Center is at [0,0] , top left is  -----://\n    //: at [-1,-1] and bottom right is at [+1,+1]       -----://\n    vec2 uvc   = (f_c -0.5*iResolution.xy)/iResolution.y;\n         uvc.y =( 0.0 - uvc.y ); //:Invert Y axis\n\n//+----------------------------------------------------------+//\n//| What is the current wang-tile touching mask for          |//\n//| the tile you are drawing. In this example,               |//\n//| pretend the entire screen is one tile.                   |//\n//| TIL == Your One Tile                                     |//\n//|          +---+                                           |//\n//|          |y_0|                                           |//\n//|      +---+---+---+      0|1  0|1  |  0|1  0|1            |//\n//|      |x_0|TIL|x_1| -->  ___  ___  |  ___  ___            |//\n//|      +---+---+---+      X_0  X_1  |  Y_0  Y_1            |//\n//|          |y_1|                                           |//\n//|          +---+                                           |//\n//|                                                          |//\n//| toutang means : Touching Tangent                         |//\n//|                                                          |//\n//| [-1,-1]                                                  |//\n//|     +-------------+                                      |//\n//|     |             |                                      |//\n//|     |             |                                      |//\n//|     |     0.0     | <--[ TIL ] www.twitch.com/kanjicoder |//\n//|     |             |                                      |//\n//|     |             |                                      |//\n//|     +-------------+                                      |//\n//|                 [+1,+1]                                  |//\n//|                                                          |//\n//+----------------------------------------------------------+//\n\n    //:Animate the touching value of your tile.         -----://\n    //:Emulating all different combinations of which    -----://\n    //:neighbors can exist above,below,left,and right:  -----://\n\n    uint toutang=(uint(int(mod(iTime,16.0))));\n\n//+----------------------------------------------------------+//\n//|   +-----------------+ If( touself ==BINARY[ 1000 ] )THEN:|//\n//|   |\\\\     y_0     //|                                    |//\n//|   |  \\\\         //  |   We are in the x_0 pie slice.     |//\n//|   |    \\\\     //    |                                    |//\n//|   |      \\\\ //      | If( touself ==BINARY[ 1010 ] )THEN:|//\n//|   |x_0  ( 0.0 )  x_1|                                    |//\n//|   |      // \\\\      |   I fucked up the formula because  |//\n//|   |    //     \\\\    |   only ONE_BIT in touself should   |//\n//|   |  //         \\\\  |   have been set.                   |//\n//|   |//     y_1     \\\\|                                    |//\n//|   +-----------------+                                    |//\n//|   BITS[  0   0   0   0  ]                                |//\n//|   SIDE[ x_0 x_1 y_0 y_1 ]     www.twitch.com/kanjicoder  |//\n//|                                                          |//\n//|   touself means: \"TOUching SELF\"                         |//\n//+----------------------------------------------------------+//\n\n    //:Figure out which pie slice the pixel of  -------------://\n    //:your tile belongs to and set that bit:   -------------://\n    #define A abs\n    #define U uint\n    #define X uvc.x\n    #define Y uvc.y\n    U touself =( U(0)\n    | (( (X <= 0.0 && (A(X)>A(Y))) ? U(1) : U(0) ) << 3)\n    | (( (X >= 0.0 && (A(X)>A(Y))) ? U(1) : U(0) ) << 2)\n    | (( (Y <= 0.0 && (A(Y)>A(X))) ? U(1) : U(0) ) << 1)\n    | (( (Y >= 0.0 && (A(Y)>A(X))) ? U(1) : U(0) ) << 0)\n    );;\n    #undef A\n    #undef U\n    #undef X\n    #undef Y\n\n    //:If we are on a pie slice that is touching a           ://\n    //:neighbor, use the connected gradient(congrad).        ://\n    //:If we are on a pie slice that is __NOT__              ://\n    //:touching a neighbor, use walled-off gradient(walgrad).://\n    float walgrad = float( max( abs(uvc.x),abs(uvc.y) ) );\n    float congrad = float( min( abs(uvc.x),abs(uvc.y) ) );\n    float tougrad = (( touself & toutang )>=uint(1)) \n                 ? congrad   //:TRUE : Connected  Gradient\n                 : walgrad ; //:FALSE: Walled Off Gradient\n\n    float invgrad = (( touself & toutang )>=uint(1)) \n                 ? walgrad   //:INVERTED_GRADIENT\n                 : congrad ; //:INVERTED_GRADIENT\n\n    return( vec2( tougrad , invgrad ) );\n\n} //:[getSubTileCoords]:<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<://\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen coordinates.\n\tvec2 u = getSubTileCoords( fragCoord );\n    \n    // Function value.\n    float f = func(u);\n    float ssd = ns; // Saving the unpalettized noise value to add a little gradient to the color, etc.\n    \n    // Four sample values around the original. Used for edging and highlighting.\n    vec2 e = vec2(1.5/iResolution.y, 0);\n    float fxl = func(u + e.xy);\n    float fxr = func(u - e.xy);\n    float fyt = func(u + e.yx);\n    float fyb = func(u - e.yx);\n    \n    // Colorizing the function value, and applying some hue rotation based on position.\n    // Most of it was made up.\n    vec3 col = pow(min(vec3(1.5, 1, 1)*(f*.7 + ssd*.35), 1.), vec3(1, 2., 10)*2.) + .01;\n    col = rotHue(col, -.25+.4*length(u));\n\n    // Applying the dark edges.\n    col *= max(1. - (abs(fxl - fxr) + abs(fyt - fyb))*5., 0.);\n    //col *= max(1. - length(vec2(fxl, fyt) - vec2(fxr, fyb))*7., 0.);\n    // Resampling with a slightly larger spread to provide some highlighting.\n    fxl = func(u + e.xy*1.5);\n    fyt = func(u + e.yx*1.5);\n    col += vec3(.5, .7, 1)*(max(f - fyt, 0.) + max(f - fxl, 0.))*ssd*10.;\n    \n    // Subtle, bluish vignette.\n    //u = fragCoord/iResolution.xy;\n    //col = mix(vec3(0, .1, 1), col, pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .125)*.15 + .85);\n\n \t\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}