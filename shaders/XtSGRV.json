{
    "Shader": {
        "info": {
            "date": "1430212092",
            "description": "Effects from \"Prism Break\" 4k intro by Virgill / Alcatraz              \nFull Intro here:\nwww.pouet.net/prod.php?which=65359\nwww.youtube.com/watch?v=8UYrJoCsYEY",
            "flags": 64,
            "hasliked": 0,
            "id": "XtSGRV",
            "likes": 90,
            "name": "Prism Break",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "demoscene",
                "glass"
            ],
            "usePreview": 1,
            "username": "Virgill",
            "viewed": 5803
        },
        "renderpass": [
            {
                "code": "// Prism Break\n// an Alcatraz 4K intro \n\n// www.pouet.net/prod.php?which=65359\n// www.youtube.com/watch?v=8UYrJoCsYEY\n\n\n// Jochen \"Virgill\" Feldkoetter\n\n//*****************************************************\n\n// change effect number:\n\t\t\t\t\t\nint ef = 1;\t\t// Effekt\n\n// ef=0 : boxes\n// ef=1 : menger sponge\n// ef=2 : singlebox\n// ef=4 : menger sponge + box\n\n//***************************************************************************************************\n\n\nfloat kl = 0.0;\t\t\t// from 4Klang\nvec4 ot;\t\n\n\n//***************************************************************************************************\n// function rotate\n//***************************************************************************************************\nvec3 rotXaxis(vec3 p, float rad)\n{\n\tfloat z2 = cos(rad) * p.z - sin(rad) * p.y;\n\tfloat y2 = sin(rad) * p.z + cos(rad) * p.y;\n\tp.z = z2;\n\tp.y = y2;\n\treturn p;\n}\n\nvec3 rotYaxis(vec3 p, float rad) \n{\n\tfloat x2 = cos(rad) * p.x - sin(rad) * p.z;\n\tfloat z2 = sin(rad) * p.x + cos(rad) * p.z;\n\tp.x = x2;\n\tp.z = z2;\n\treturn p;\n}\n\n//***************************************************************************************************\n// function rand1\n//***************************************************************************************************\nfloat rand1(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.54);\n}\n\n//***************************************************************************************************\n// function sdBox\n//***************************************************************************************************\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.));\n\n}\n\n//***************************************************************************************************\n// sdf boxes\n//***************************************************************************************************\nfloat Boxes(vec3 pos) \n{\nvec3 rok = vec3(0.35);\nfloat m;\nm = length(max(abs(rotYaxis(rotXaxis(pos+vec3(0.0,-0.3,0.0),iTime*0.3 ),iTime*0.15))-rok,0.0))-0.03; // Cube\nm = min (m,length(max(abs(rotYaxis(rotXaxis(pos+vec3(0.0,-0.3, 1.2),iTime*0.21),iTime*0.24))-rok,0.0))-0.03); \nm = min (m,length(max(abs(rotYaxis(rotXaxis(pos+vec3(0.0,-0.3,-1.2),iTime*0.2 ),iTime*0.3 ))-rok,0.0))-0.03); \nm = min (m,length(max(abs(rotYaxis(rotXaxis(pos+vec3(1.2,-0.3, 0.0),iTime*0.17),iTime*0.26))-rok,0.0))-0.03); \nm = min (m,length(max(abs(rotYaxis(rotXaxis(pos+vec3(-1.2,-0.3,0.0),iTime*0.32),iTime*0.2 ))-rok,0.0))-0.03); \nreturn m;\n}\n\n//***************************************************************************************************\n// sdf singlebox\n//***************************************************************************************************\nfloat Singlebox(vec3 pos) \n{\nreturn length(max(abs(rotXaxis(pos+vec3(0.0,-0.5,0.0),iTime*0.47))-vec3(0.55-0.025*(kl+0.4)*sin(pos.z*pos.x*pos.y*35.)),0.0))-0.025; // Cube\n}\n\n//***************************************************************************************************\n// sdf plane\n//***************************************************************************************************\nfloat sdPlane(vec3 p) \n{\nreturn p.y+(0.005*sin(p.x*10.))+(0.005*sin(p.z*12.))+0.4;\n}\n\n//***************************************************************************************************\n// sdf menger by IQ\n//***************************************************************************************************\nfloat menger(vec3 pos )\n{\n\tfloat d = sdBox(pos,vec3(1.));\n\tfloat s = 1.63+0.07*sin(0.53*iTime)-0.3*pos.y;\n\tfor( int m=0; m<2; m++ )\n\t{\n      vec3 a = mod( pos*s, 2.0 )-1.0;\n      s *= 3.0;\n\t  vec3 r = abs(1.0 - 3.0*abs(a))-0.025;\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float c = (min(da,min(db,dc))-1.0)/s;\n      d = max(d,c);\n   }\n    return d;\n}\n\n//***************************************************************************************************\n// map\n//***************************************************************************************************\nfloat map(vec3 p)\n{\nfloat d,m;\not = vec4(length(p)-0.8*p.z,length(p)-0.8*p.y,length(p)-0.8*p.x,0.0)*0.8;\nd = sdPlane(p);\n\nif (ef==0)\t\t   m = Boxes(p); \nif (ef==1||ef==3)  m = menger(rotYaxis(p,0.12*iTime));\nif (ef==2)\t\t   m = Singlebox(p+0.1*kl*rand1(gl_FragCoord.xy+iTime));\nif (ef==4)\t\t   m = min(menger(rotYaxis(p,0.1*iTime)),sdBox(rotYaxis(rotXaxis(p+vec3(0.,0.2,0.),iTime),0.2*iTime),vec3(0.1,0.1,0.04)-0.002*sin(p.x*p.y*440.+iTime))-0.01);\nreturn min (m, d); \n}\n\n//***************************************************************************************************\n// softshadow by IQ\n//***************************************************************************************************\nfloat softshadow(vec3 ro,vec3 rd) \n{\n    float sh = 1.0;\n    float t = 0.02;\n    float h = 0.0;\n    for(int i = 0; i < 23; i++)  \n\t{\n        if(t > 20.) continue;\n        h = map(ro + rd * t)+0.003*rand1(gl_FragCoord.xy+iTime);\n        sh = min(sh, 4.0 * h / t);\n        t += h;\n    }\n    return sh;\n}\n\n//***************************************************************************************************\n// normal calculation\n//***************************************************************************************************\nvec3 calcNormal(vec3 p) \n{\n    vec3 e = vec3(0.0001,0.,0.);\n\tif (ef==1) e = vec3(0.01,0.,0.);\n\treturn normalize (vec3(map(p + e.xyy) - map(p - e.xyy),  map(p + e.yxy) - map(p - e.yxy),  map(p + e.yyx) - map(p - e.yyx)));\n}\n\n//***************************************************************************************************\n// orbit color\n//***************************************************************************************************\nvec3 cycle(vec3 c, float s) \n{\n\tfloat Cycles = 10.;\n\treturn vec3(0.5)+0.5*vec3(cos(s*Cycles+c.x),cos(s*Cycles+c.y),cos(s*Cycles+c.z));\n}\n\nvec3 getColor(int o)\n{\n\tvec4 Z = vec4(0.3, 0.5, 0.6, 0.2);\n\tvec4 Y = vec4(0.1, 0.5, 1.0, -0.5);\n\tvec4 X = vec4(0.7, 0.8, 1.0, 0.3);\n\tvec3 orbitColor = cycle(X.xyz,ot.x)*X.w*ot.x + cycle(Y.xyz,ot.y)*Y.w*ot.y + cycle(Z.xyz,ot.z)*Z.w*ot.z;\n\tif (orbitColor.x >= 4.) orbitColor.x =0.;\n\tif (orbitColor.y >= 4.) orbitColor.y =0.;\n\tif (orbitColor.z >= 4.) orbitColor.z =0.;\n\treturn clamp(3.0*orbitColor,0.0,4.0);\n}\n\n//***************************************************************************************************\n// cast ray\n//***************************************************************************************************\nfloat castRay(vec3 ro,vec3 rd,float maxt) \n{\n    float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\n\tfor(int i = 0; i < 130; i++) \n\t{\n        if(abs(h) < precis || t > maxt) break;\n\t\th = map(ro + rd * t);\n        t += h;\n\t}\n    return t;\n}\n\n//***************************************************************************************************\n// cast ray2 inside\n//***************************************************************************************************\nfloat castRay2(vec3 ro,vec3 rd) \n{\n    float precis = 0.2;\n    float h = 0.;\n    float t = 0.01;\n\n    for(int i = 0; i < 90; i++) \n\t{\n\t\tif(abs(h) > precis ) break;\n\t\th = map(ro + rd * t);\n\t\tt-=h;\n\t}\n\treturn t;\n}\n\n\n//***************************************************************************************************\n// main\n//***************************************************************************************************\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    \n    // time control (only in shadertoy)\n\n    if (iTime>32.) ef=0;\n\n//  blend    \n\tfloat blend=min(2.*abs(sin((0.1*iTime)*3.1415/3.2)),1.0); // Blende\n\tvec2 uv,p;\n\n//\tzoom XY\t\n    if (ef==1||ef==3){\n\tuv.x = 1.0+(mod(gl_FragCoord.x-   sin(iTime)*gl_FragCoord.y   -(iResolution.x/2.),    ((iResolution.x/4.)* (-1.5*blend+0.501) +(iResolution.x/4.)))-(1.*gl_FragCoord.x)  ) / iResolution.x;\n\tuv.y = 1.0+(mod(gl_FragCoord.y+   sin(iTime)*gl_FragCoord.x   -(iResolution.y/2.),    ((iResolution.y/4.)* (-1.5*blend+0.501) +(iResolution.y/4.)))-(1.*gl_FragCoord.y)  ) / iResolution.y;\n\t}\n\n// \tzoom Y\n\tif (ef==0||ef==2)\n    {\n\tuv.x = 1.0+ (mod(gl_FragCoord.x   -(iResolution.x/2.),    ((iResolution.x/4.)  * (-1.5*blend+0.501)  +(iResolution.x/4.)))-1.*gl_FragCoord.x) / iResolution.x;\n\tuv.y=  1.0-(gl_FragCoord.y /iResolution.y);\n\t}\n\tp = (1.-uv) * 2.0 - 1.0;\n\n// \twithout effect\n\tif (ef==4){ uv.xy = gl_FragCoord.xy /iResolution.xy; p = uv * 2.0 - 1.0;}\n   \n    \n\tp.x *= iResolution.x /iResolution.y;\n\tfloat theta = sin(iTime*0.1) * 6.28;\n    float x = 3.0 * cos(theta); \n    float z = 3.0 * sin(theta);\n\n//  camera\n\tvec3 ro; \n\tif (ef==0||ef==2) ro = vec3(x*2.0, 2.0+2.*sin((iTime+37.)*0.15), z*1.4);\t\t//camera Cubes\n\tif (ef==1)\t\t\t\t ro = vec3(x*0.2+1.0, 4.0, 0.6*z-3.);\t\t\t\t\t    //camera Menger\n\tif (ef==4)\t\t\t\t ro = vec3(0.0, 0.3+0.10*iTime, 0.001);\t\t\t    //camera Tunnel\n\tif (ef==3)\t\t\t\t ro = vec3(0.0, 36.-0.24*iTime, 0.001);\t\t\t    //camera Tunnel\n\tvec3 cw = normalize(vec3(0., 0.25, 0.) - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n\tvec3 rd = normalize(p.x * cu + p.y * cv + 7.5 * cw);\n\n\n\n// \trender:\n    vec3 col= vec3(0.);\n\tfloat t = castRay(ro,rd,12.);\n\tif (t >= 12.) t=12.;\n\tvec3 pos = ro + rd *t;\n\tvec3 nor = calcNormal(pos);\n\n// \tlightning:\n\tvec3 ligvec = vec3(-0.5,.2,.5);\n\tif (ef==4||ef==2||ef==1) ligvec = vec3(0.5*sin(iTime*0.2), 0.2, -0.5*cos(iTime*0.3));\n\tvec3 lig = normalize(ligvec);\t\n\tfloat dif = clamp(dot(lig, nor),0.,1.);\n\tfloat spec = pow(clamp(dot(reflect(rd, nor), lig),0.,1.),16.);\n\tvec3 color = (3.5-0.35*t)*getColor(1);\n\tcol = 0.3*dif+0.5*color+spec;\n  \tfloat sh = softshadow(pos, lig);\n  \tcol *= clamp(sh, 0.0, 1.0);\n\n\n// \treflection\n\tvec3 ro2r = pos-rd/t;\n\tvec3 rd2r = reflect(rd,nor);\n    float t2r = castRay(ro2r, rd2r, 7.0);\n\tvec3 pos2r = vec3(0.0);\n\tpos2r = ro2r + rd2r* t2r;\n    vec3 nor2r = calcNormal(pos2r);\n\tfloat dif2r = clamp(dot(lig, nor2r), 0.0, 1.0);\n\tfloat spec2r = pow(clamp(dot(reflect(rd2r, nor2r), lig), 0.0, 1.0), 16.0);\n\tcol+= 0.1*(dif2r*color+spec2r);\n\n  \n//  refraction\n\tvec3 rd2 = refract(rd,nor,0.78);  \n    float t2 = castRay2(pos, rd2);\n\tvec3 pos2 = pos + rd2* t2;\n    vec3 nor2 = calcNormal(pos2);\n\tfloat dif2 = clamp(dot(lig, nor2), 0.0, 1.0);\n\tcol.r+= 0.3*dif2;\n\n\trd2 = refract(rd,nor,0.82);  \n    t2 = castRay2(pos, rd2);\n\tpos2 = pos + rd2* t2;\n    nor2 = calcNormal(pos2);\n\tdif2 = clamp(dot(lig, nor2), 0.,1.);\n\tcol.b+= 0.3*dif2;\n\n\trd2 = refract(rd,nor,0.8);  \n    t2 = castRay2(pos, rd2);\n\tpos2 = pos + rd2* t2;\n    nor2 = calcNormal(pos2);\n\tdif2 = clamp(dot(lig, nor2), 0.,1.);\n    float spec2 = pow(clamp(dot(reflect(rd2, nor2), lig),0.,1.),16.);\n\tcol.g+=.3*dif2;\n\tcol +=.6*spec2;\n  \n// \trefraction 2\n\tvec3 ro3 = pos2+rd; \n\tvec3 rd3 = rd2+0.002*rand1(gl_FragCoord.xy); \n    float t3 = castRay(ro3, rd3, 10.);\n\tif (t3>=10.)t3=10.;\n\tvec3 pos3 = ro3 + rd3* t3;\n    vec3 nor3 = calcNormal(pos3);\n\tfloat dif3 = clamp(dot(lig, -nor3), 0.0, 1.0);\n\tcolor = clamp(1.+(1.-0.2*t3)*getColor(1),0.,8.);\n\tcol+= 0.1*dif3*color;\n\tcol+= 0.04*(1.-dif3)*color;\n\n\tcol = mix(col, vec3(.4,.5,.6), exp(-(2.-(0.18*t)) ) );\n\n// \tpostprocessing\n\tvec2 uv2= gl_FragCoord.xy/iResolution.xy;\n\tcol-=0.04*rand1(uv2.xy*iTime);\t\t\t\t\t\t\t\t\t\n\tcol*=.9+.1*sin(2.*uv2.y*iResolution.y);\t\n    col-=1.-dot(uv,1.-uv)*2.4;\n    fragColor = vec4(col*blend, 1.0);\n\n\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 3365,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/virgill/prism-break"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}