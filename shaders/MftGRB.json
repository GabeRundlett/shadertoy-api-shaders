{
    "Shader": {
        "info": {
            "date": "1713234506",
            "description": "Easy to remember, okayish quality integer hash, which is, however, somewhat slower than it needs to be.\nProbably, code compresses well too, if you care (4K demos?).",
            "flags": 0,
            "hasliked": 0,
            "id": "MftGRB",
            "likes": 4,
            "name": "hash13",
            "published": 3,
            "tags": [
                "random",
                "hash"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 171
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Easy to remember, okayish quality integer hash, which is,\n// however, somewhat slower than it needs to be.\n\nuint hash13(uint x)\n{\n    x ^= ~x >> 13;\n    x ^= (x * x) | 13u;\n    x ^= ~x >> 13;\n    x ^= (x * x) | 13u;\n    x ^= ~x >> 13;\n    return x;\n}\n\n// Multidimensional wrappers.\n// Quality/speed not tested much.\n\nuint rotl(uint x,int y) {return (x<<(31&y))|(x>>(31&-y));}\n\nuint hash13(uvec2 v) {return hash13(v.x+rotl(v.y,16));}\nuint hash13(uvec3 v) {return hash13(v.x+rotl(v.y,11)+rotl(v.z,22));}\nuint hash13(uvec4 v) {return hash13(v.x+rotl(v.y, 8)+rotl(v.z,16)+rotl(v.w,24));}\n\n/*\nComparison:\n\nFunction     | Linf        | RMS         | PractRand      | Speed, a.u.\n-------------|-------------|-------------|----------------|---------------------------------\nxxHash       |     8658392 |   1195645.4 | Fails at  16KB | 100.0%       [5]\nMurmurHash3  |     4044016 |    566904.4 | Fails at  16KB | 100.0%       [5]\nlowbias32    |     2023971 |    372660.4 | Fails at  32KB | 100.0% \nlowbias32_tib|     1211488 |    231074.2 | Fails at  64KB | 100.0%       [5]\npcg_hash     |   331871348 |  16645540.6 | Fails at   4MB |  94.5%\ndllSW7       |      836260 |    121867.6 | Fails at   1GB |  92.2%/94.8% [6]\ntriple32     |      167788 |     44857.8 | Fails at   1GB |  90.0%\nhash13       |     1340416 |    137241.7 | Fails at 512MB |  75.2%\n\nNotes:\n1. Avalanche scores are measured similarly to\n     http://marc-b-reynolds.github.io/math/2019/08/10/Avalanche.html\n     with abs(counts[i][j]-(1ul<<31)) as data. Linf is infinity norm,\n     RMS is root mean square.\n2. PractRand is the result of `while(1) output(hash(i++));` piped to\n     RNG_test stdin32 -tlmin 1K -te 0 -tf 2\n     Using `-te 1` might be better.\n3. See https://www.shadertoy.com/view/XlGcRh for pcg_hash.\n4. See https://github.com/skeeto/hash-prospector for lowbias32 and\n     triple32. lowbias32_tib is the version by https://github.com/TheIronBorn.\n     See https://www.shadertoy.com/view/WttXWX.\n5. Speed for functions of the same form as lowbias32 is not measured\n     separately, and assumed to be identical.\n6. See https://www.shadertoy.com/view/dllSW7 for \"dllSW7\" hash,\n     including faster version.\n7. The speed column is based on latency (for(int i=0;i<n;++i) x=hash(x);),\n     relatively to lowbias32, using iFrame in Shadertoy. May differ\n     depending on GPU.\n8. See https://github.com/skeeto/hash-prospector/issues/23\n     for the description of the XQO primitive (hash13 uses a suggestion\n     by tommyettinger).\n9. Adding 1 more round (x^=(x*x)|13u; x^=~x>>13;) brings quality\n     on par with triple32 (144520/45359.6/2GB).\n)\n*/\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    // Thanks to \"hash: visualising bitplanes\" by hornet https://www.shadertoy.com/view/lt2yDm\n    vec2 seed=mod(fragCoord,vec2(iResolution.x/8.0,iResolution.y/4.0));\n    uint bit=uint(int(floor(8.0*uv.x)+8.0*floor(4.0 * uv.y)));\n    uvec2 icoord=uvec2(ivec2(floor(seed+10.0*iTime)));\n    uint idx=1024u*icoord.y+icoord.x;\n    float c=float((hash13(idx)>>bit)&1u);\n    fragColor=vec4(c,c,c,1.0);\n    // Grid.\n    fragColor*=step(10.0/iResolution.x,1.0-abs(2.0*fract(8.0*uv.x)-1.0));\n    fragColor*=step(10.0/iResolution.y,1.0-abs(2.0*fract(4.0*uv.y)-1.0));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}