{
    "Shader": {
        "info": {
            "date": "1658213350",
            "description": "* I realize this runs very slowly, sorry about that. Probably needs spatial partitioning\n* Buffer A renders the ground, which is referenced during the ray march\n* Marching code derived from Liquid in glass by tmst: https://www.shadertoy.com/view/3tfcRS",
            "flags": 32,
            "hasliked": 0,
            "id": "ssGfDh",
            "likes": 7,
            "name": "Battuto Vase",
            "published": 3,
            "tags": [
                "sdf",
                "refraction",
                "glass",
                "vase",
                "battuto"
            ],
            "usePreview": 1,
            "username": "fenix",
            "viewed": 363
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Buffer A renders all the rays that bounce off the table.\n//\n//  Marching code in common buffer derived from Liquid in glass by tmst:\n//      https://www.shadertoy.com/view/3tfcRS\n//\n//  Kind of trying to make something that looks like this (except polished):\n//      https://www.originalmuranoglass.com/images/stories/virtuemart/product/nightsky.jpg \n//\n//  I realize this is very slow and probably needs some kind of spatial partitioning. I could\n//  make slicing planes at the midpoints between each cutting sphere. Maybe I'll try that for\n//  version 2.0, unless someone beats me to it.\n//\n// ---------------------------------------------------------------------------------------\n\n// ===============================\n// Camera setup\n// ===============================\n\n#define RES iResolution\n#define TAN_HALF_FOVY 0.5773502691896257\n\nvec3 nvCamDirFromClip(vec3 iResolution, vec3 nvFw, vec2 clip)\n{\n    vec3 nvRt = normalize(cross(nvFw, vec3(0.,1.,0.)));\n    vec3 nvUp = cross(nvRt, nvFw);\n    return normalize(TAN_HALF_FOVY*(clip.x*(RES.x/RES.y)*nvRt + clip.y*nvUp) + nvFw);\n}\n\nvoid getCamera(in vec2 uv, out vec3 camPos, out vec3 nvCamDir) {\n    float animate = iTime;\n    vec2 mouseAng = vec2(animate * 0.17, PI*0.3 + 0.1*cos(animate * 0.27));\n    if (iMouse.z > 0.0)\n        mouseAng += vec2(8.0*iMouse.x / iResolution.x,0.8*iMouse.y / iResolution.y);\n        \n    float radius = 5.0 + 2.0 * cos(animate * 0.1);\n    camPos = vec3(0.0, 1.0, 0.0) + radius * SPHERICAL(mouseAng.x, mouseAng.y);\n\n    vec3 lookTarget = vec3(0.0);\n    vec3 nvCamFw = normalize(lookTarget - camPos);\n\n    nvCamDir = nvCamDirFromClip(iResolution, nvCamFw, uv*2. - 1.);\n}\n\n// ===============================\n// Main render\n// ===============================\n\nvec4 mainColor(vec2 fragCoord)\n{\n    vec3 camPos;\n    vec3 nvCamDir;\n    vec2 uv = fragCoord / RES.xy;\n    getCamera(uv, camPos, nvCamDir);\n\n    vec4 color;\n    vec3 nvRayOut;\n    march(iChannel0, camPos, nvCamDir, color, nvRayOut);\n\n    return blendOnto(color, SKYBOX(nvRayOut));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = mainColor(fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ===============================\n// Table render\n// ===============================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 oldRes = texelFetch(iChannel0, ivec2(0, 0), 0);\n    bool init = oldRes.xyz != iResolution || iFrame == 0; // Init at the beginning or if the resolution changes\n    \n    if (init)\n    {\n        fragColor = vec4(GROUND_COLOR);\n        \n        if (ivec2(fragCoord) == ivec2(0, 0))\n        {\n            // Store the resolution in the first pixel\n            fragColor = vec4(iResolution, iFrame);\n        }\n    }\n    else\n    {\n        int framesSinceReset = iFrame - int(oldRes.w);\n        \n        vec4 oldColor;\n        oldColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n        // Shoot a ray in a random direction\n        vec2 camUV = (fragCoord.xy / iResolution.xy) * TABLE_SIZE + TABLE_MIN;\n        vec3 camPos = vec3(camUV.x, TABLE_HEIGHT, camUV.y);\n        vec3 nvRayCur = noise(ivec3(iFrame * int(fragCoord.x), int(fragCoord.y) * iFrame, int(fragCoord.x * fragCoord.y))).xyz;\n        nvRayCur = normalize(nvRayCur);\n        if (nvRayCur.y < 0.0) nvRayCur.y = -nvRayCur.y;\n\n        vec4 newColor;\n        vec3 nvRayOut;\n        march(iChannel0, camPos, nvRayCur, newColor, nvRayOut);\n        \n        if (ivec2(fragCoord) == ivec2(0, 0))\n        {\n            fragColor = oldRes;\n        }\n        else\n        {\n            // Compute the average over time\n            fragColor = oldColor * float(framesSinceReset) / float(framesSinceReset + 1) + newColor / float(framesSinceReset + 1);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define LAST_FRAME iChannel0\n#define SKYBOX(v) vec3(dot(v, vec3(-0.4, 1.0, 0.4)))\nconst vec2 TABLE_MIN = vec2(-15.0, -15.0);\nconst vec2 TABLE_MAX = vec2(2.0, 2.0);\nconst vec2 TABLE_SIZE = TABLE_MAX - TABLE_MIN;\n\n// ===============================\n// Generic Helpers/Constants\n// ===============================\n\n#define PI 3.141592653589793\n#define TWOPI 6.283185307179586\n#define HALFPI 1.570796326794896\n#define SQRT2INV 0.7071067811865475\n\n#define POLAR(theta) vec3(cos(theta), 0.0, sin(theta))\n#define SPHERICAL(theta, phi) (sin(phi)*POLAR(theta) + vec3(0.0, cos(phi), 0.0))\n\nuvec4 hash(uvec3 x0){\n    uvec4 x = x0.xyzz;\n    x = ((x >> 16u) ^ x.yzxy) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxz) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\nvec4 noise(ivec3 p){\n    const float scale = 1.0/float(0xffffffffU);\n    uvec4 h = hash(uvec3(p));\n    return vec4(h)*scale;\n}\n\nvec4 noise(ivec2 p){\n    return noise(ivec3(p, 0));\n}\n\n// Same as built-in 'refract' (cf. link) but replaces the case which would\n// normally result in 0 with a reflection (for total internal reflection)\n// https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/refract.xhtml\nvec3 refractFix(vec3 I, vec3 N, float eta) {\n    float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n    return k < 0.0\n        ? reflect(I, N) // <- 'refract' returns 0 here\n    \t: eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n}\n\nvec4 blendOnto(vec4 cFront, vec4 cBehind) {\n    return cFront + (1.0 - cFront.a)*cBehind;\n}\n\nvec4 blendOnto(vec4 cFront, vec3 cBehind) {\n    return cFront + (1.0 - cFront.a)*vec4(cBehind, 1.0);\n}\n\nfloat length2(vec3 v)\n{\n    return dot(v, v);\n}\n\nfloat square(float x)\n{\n    return x*x;\n}\n\n// ===============================\n// Geometry definitions\n// ===============================\n\n#define BOUNDING_SPHERE_RADIUS 15.0\n\nfloat sdfPlane(vec3 planePoint, vec3 nvPlaneN, vec3 p) {\n    return dot(p - planePoint, nvPlaneN);\n}\n\nfloat sdfInterval(float a, float b, float x) {\n    return abs(x - 0.5*(a+b)) - 0.5*(b-a);\n}\n\n// From https://iquilezles.org/articles/distfunctions\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat sdfSphere(vec3 p, vec3 pos, float radius)\n{\n    return length(p - pos) - radius;    \n}\n\nfloat sdfInterior(vec3 p)\n{\n    return sdfSphere(p * vec3(2.0, 1.0, 2.0), vec3(0.0, 1.5, 0.0), 1.4);\n}\n\nconst ivec2 DIVS = ivec2(20, 20);\nconst vec2 DIVS_REL = vec2(DIVS) / (2.0 * PI);\nconst vec2 DIVS_NOISE = vec2(0.2, 0.3);\nconst float CUT_DIST = 3.3;\n\nvec3 getCutPos(vec2 spherical)\n{\n    vec2 spherical2 = spherical;\n    spherical2.x += PI;\n    spherical2 = mod(spherical2, vec2(PI * 2.0));\n    spherical2.x -= PI;\n    vec2 dirNoise = noise(ivec2(spherical2 * 100.0)).xy - 0.5;\n    vec2 spherical3 = spherical2 + dirNoise * DIVS_NOISE;\n    float sinX = sin(spherical3.x);\n    float sinY = sin(spherical3.y);\n    float cosX = cos(spherical3.x);\n    float cosY = cos(spherical3.y);\n\n    vec3 dir = vec3(sinY * cosX, cosY, sinY * sinX);\n    float radius = 0.75 + 0.25 * (abs(dir.y)) + 0.15 * dir.y;\n    return CUT_DIST * dir * radius;\n}\n\nvec3 pointCache[9]; // Store the most recently used points we already computed using some expensive trig functions\nvec2 cachedFor; // Remember what spherical voxel we have the points cached for\n\nfloat sdfGlass(vec3 p)\n{\n    vec3 delta = p;\n    float sd = sdfSphere(p, vec3(0), 3.0);\n\n    vec2 spherical = vec2(atan(delta.z, delta.x), atan(length(delta.xz), delta.y));\n    spherical = (floor(spherical * DIVS_REL) + 0.5) / DIVS_REL;//vec2((floor(theta * THETA_DIVS) + 0.5) / THETA_DIVS, (floor(phi * PHI_DIVS) + 0.5) / PHI_DIVS)\n\n    if (spherical != cachedFor)\n    {\n        // This would probably benefit from some kind of spatial partitioning, but for this version caching the positions per\n        // spherical \"voxel\" at least helps.\n        pointCache[0] = getCutPos(spherical + vec2(-1, -1) / DIVS_REL);\n        pointCache[1] = getCutPos(spherical + vec2(-1,  0) / DIVS_REL);\n        pointCache[2] = getCutPos(spherical + vec2(-1,  1) / DIVS_REL);\n        pointCache[3] = getCutPos(spherical + vec2( 0, -1) / DIVS_REL);\n        pointCache[4] = getCutPos(spherical + vec2( 0,  0) / DIVS_REL);\n        pointCache[5] = getCutPos(spherical + vec2( 0,  1) / DIVS_REL);\n        pointCache[6] = getCutPos(spherical + vec2( 1, -1) / DIVS_REL);\n        pointCache[7] = getCutPos(spherical + vec2( 1,  0) / DIVS_REL);\n        pointCache[8] = getCutPos(spherical + vec2( 1,  1) / DIVS_REL);\n        \n        cachedFor = spherical;\n    }\n    \n    sd = max(sd, - sdfSphere(p, pointCache[0], 1.3));\n    sd = max(sd, - sdfSphere(p, pointCache[1], 1.3));\n    sd = max(sd, - sdfSphere(p, pointCache[2], 1.3));\n    sd = max(sd, - sdfSphere(p, pointCache[3], 1.3));\n    sd = max(sd, - sdfSphere(p, pointCache[4], 1.3));\n    sd = max(sd, - sdfSphere(p, pointCache[5], 1.3));\n    sd = max(sd, - sdfSphere(p, pointCache[6], 1.3));\n    sd = max(sd, - sdfSphere(p, pointCache[7], 1.3));\n    sd = max(sd, - sdfSphere(p, pointCache[8], 1.3));\n\n    float vase = max(-sdfInterior(p), sd);\n    \n    return max(vase, delta.y - 2.3);\n}\n\n#define SDF_N_EPS 0.005\n#define SDF_NORMAL(sdfFn, p) \\\n    normalize(vec3( \\\n        sdfFn( p+vec3(SDF_N_EPS,0.0,0.0) ) - sdfFn( p-vec3(SDF_N_EPS,0.0,0.0) ), \\\n        sdfFn( p+vec3(0.0,SDF_N_EPS,0.0) ) - sdfFn( p-vec3(0.0,SDF_N_EPS,0.0) ), \\\n        sdfFn( p+vec3(0.0,0.0,SDF_N_EPS) ) - sdfFn( p-vec3(0.0,0.0,SDF_N_EPS) )  \\\n    ))\n\n// ===============================\n// Marching, lighting/materials\n// ===============================\n\n// rendering engine forked from Liquid in glass by tmst https://www.shadertoy.com/view/3tfcRS\n#define SDF_EPS 0.01\n#define DSTEP_ADJUST_EPS 0.02\n#define STEPS 50\n\n#define LIGHT_COLOR vec3(1.0)\n\n#define GLASS_COLOR vec3(0.1, 0.1, 1.0)\n#define GLASS_OPACITY 1.1\n\n#define IR_AIR 1.0\n#define IR_GLASS 1.5\n\n// Enums\n#define SUBSTANCE_AIR 0\n#define SUBSTANCE_GLASS 1\n\n#define TABLE_HEIGHT -1.0\nconst float GROUND_COLOR = 0.515;\n\nvec4 computeSpecular(\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam)\n{\n    const float specularCoefficient = 0.8;\n    const float specularExponent = 80.0;\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    return valSpecular*vec4(LIGHT_COLOR, 1.0);\n}\n\nvoid march(in sampler2D tableSampler, in vec3 pRay, in vec3 nvRayIn, out vec4 color, out vec3 nvRayOut)\n{\n    // Light (in world coordinates)\n    vec3 pLightO = pRay + vec3(0.0, 10.0, 0.0);\n\n    // Light and camera (in object coordinates)\n\n    vec3 pCam = pRay;\n    vec3 pLight = pLightO;\n\n    // Ray while marching (in object coordinates)\n    vec3 pCur = pCam;\n    vec3 nvRayCur = nvRayIn;\n\n    color = vec4(0.0);\n    int curSubstance = SUBSTANCE_AIR;\n\n    int i=0;\n    for (; i<STEPS; i++) {\n\n        // Quick exits\n        // ----------------\n        vec3 centerToCur = pCur;\n        if (\n            (length2(centerToCur) > square(BOUNDING_SPHERE_RADIUS)) &&\n            (dot(nvRayCur, centerToCur) > 0.0)\n        ) {\n            if (nvRayCur.y < 0.0)\n                color = blendOnto(color, vec4(GROUND_COLOR, GROUND_COLOR, GROUND_COLOR, 1.0));\n            else\n                color = blendOnto(color, vec4(SKYBOX(nvRayCur), 1.0));\n            break;\n        }\n\n        if (color.a > 0.95) { break; }\n\t\t// ----------------\n\n        float sdGlass = sdfGlass(pCur);\n        vec3 dpStep = abs(sdGlass) * nvRayCur;\n\n        if (curSubstance == SUBSTANCE_AIR)\n        {\n            if (sdGlass < SDF_EPS)\n            {\n                vec3 nvGlass = SDF_NORMAL(sdfGlass, pCur);\n\n                if (dot(nvGlass,nvRayCur) < 0.0) \n                {\n                    curSubstance = SUBSTANCE_GLASS;\n\n                    vec4 sColor = computeSpecular(\n                        nvGlass, normalize(pLight-pCur), normalize(pCam-pCur)\n                    );\n                    color = blendOnto(color, sColor);\n\n                    // Schlick approximation\n                    float cosHitAngle = clamp(dot(nvGlass, -nvRayCur), 0.0, 1.0);\n                    float r0 = pow((IR_GLASS-IR_AIR)/(IR_GLASS+IR_AIR), 2.0);\n                    float valRefl = mix(r0, 1.0, pow(clamp(1.0 - cosHitAngle, 0.0, 1.0), 3.0)); // Modified exponent 5 -> 3\n\n                    vec3 nvRefl = reflect(nvRayCur, nvGlass);\n                    color = blendOnto(color, valRefl*vec4(SKYBOX(nvRefl), 1.0));\n\n                    dpStep = sdGlass*nvRayCur;\n                    dpStep += -DSTEP_ADJUST_EPS*nvGlass;\n                    nvRayCur = refractFix(nvRayCur, nvGlass, IR_AIR/IR_GLASS);\n                }\n            }\n        }\n        else if (curSubstance == SUBSTANCE_GLASS)\n        {\n            vec3 nvGlass = SDF_NORMAL(sdfGlass, pCur);\n            float sdGlassInv = -sdGlass;\n            vec3 nvGlassInv = -nvGlass;\n\n            dpStep = abs(sdGlassInv)*nvRayCur;\n\n            color = blendOnto(color, length(dpStep) * clamp(GLASS_OPACITY*sdGlassInv,0.0,1.0)*vec4(GLASS_COLOR, 1.0));\n\n            if (sdGlassInv < SDF_EPS && dot(nvGlassInv,nvRayCur) < 0.0)\n            {\n                curSubstance = SUBSTANCE_AIR;\n\n                dpStep = sdGlassInv*nvRayCur;\n                dpStep += -DSTEP_ADJUST_EPS*nvGlassInv;\n                nvRayCur = refractFix(nvRayCur, nvGlassInv, IR_GLASS/IR_AIR);\n            }\n        } \n\n        pCur += dpStep;\n        \n        if (pCur.y <= TABLE_HEIGHT)\n        {\n            float t = (TABLE_HEIGHT - pCur.y) / dpStep.y;\n            pCur += t * dpStep;\n            \n            vec3 tableColor;\n            if (any(lessThan(pCur.xz, TABLE_MIN)) || any(greaterThan(pCur.xz, TABLE_MAX)))\n            {\n                tableColor = vec3(GROUND_COLOR);\n            }\n            else\n            {\n                vec2 tableUV = (pCur.xz - TABLE_MIN) / TABLE_SIZE;\n                tableColor = texture(tableSampler, tableUV).xyz;\n                vec2 deltaFromSide = max(vec2(0), abs(tableUV - 0.5) - 0.4);\n                float distFromSide = max(deltaFromSide.x, deltaFromSide.y) * 10.0;\n                tableColor = mix(vec3(GROUND_COLOR), tableColor, 1.0 - distFromSide);\n            }\n            color = blendOnto(color, tableColor);\n            break;\n        }\n    }\n\n    // Convert ray direction from object to world coordinates\n    nvRayOut = nvRayCur;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}