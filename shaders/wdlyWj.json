{
    "Shader": {
        "info": {
            "date": "1585625378",
            "description": "Spacy 3D Voronoi noise makes foggy feelings.",
            "flags": 0,
            "hasliked": 0,
            "id": "wdlyWj",
            "likes": 13,
            "name": "Teal Voronoi Fog",
            "published": 3,
            "tags": [
                "noise",
                "raymarch",
                "fog",
                "3dvoronoi"
            ],
            "usePreview": 0,
            "username": "grinchdubs",
            "viewed": 619
        },
        "renderpass": [
            {
                "code": "// Fork of \"3D voronoi fog\" by jasondecode. https://shadertoy.com/view/XlXBWj\n// 2020-03-31 03:27:56\n\n/*\n3D Voronoi fogness.\n\nAuthor: Tim Gerritsen <tim@mannetje.org>\nDate: December 2017\n\n*/\n\n#define MAX_MARCH_STEPS 16\n#define MARCH_STEP_SIZE 0.2\n\n#define NOISE_AMPLITUDE 0.75\n\n#define FBM_ITERATIONS 3\n#define FBM_AMPLITUDE_GAIN .8\n#define FBM_FREQUENCY_GAIN 1.9\n\n// 2*tan(radians(45)/2)\n#define FOV45 0.82842693331417825056778150945139\n\nvec3 UvToWorld(vec2 uv) { return normalize(vec3((uv-0.5) * iResolution.xy, -iResolution.y / FOV45)); }\nvec3 Hash3( vec3 p ) { return fract(sin(vec3( dot(p,vec3(127.1,311.7,786.6)), dot(p,vec3(269.5,183.3,455.8)), dot(p,vec3(419.2,371.9,948.6))))*43758.5453); }\nfloat Voronoi(vec3 p)\n{\n\tvec3 n = floor(p);\n\tvec3 f = fract(p);\n\n\tfloat shortestDistance = 1.0;\n\tfor (int x = -1; x < 1; x++) {\n\t\tfor (int y = -1; y < 1; y++) {\n\t\t\tfor (int z = -1; z < 1; z++) {\n\t\t\t\tvec3 o = vec3(x,y,z);\n\t\t\t\tvec3 r = (o - f) + 1.0 + sin(Hash3(n + o)*50.0)*0.2;\n\t\t\t\tfloat d = dot(r,r);\n\t\t\t\tif (d < shortestDistance) {\n\t\t\t\t\tshortestDistance = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn shortestDistance;\n}\n\nfloat FractalVoronoi(vec3 p)\n{\n\tfloat n = 0.0;\n\tfloat f = 0.8, a = 0.5;\n\tmat2 m = mat2(1, 0.6, -0.6, 0.8);\n\tfor (int i = 0; i < FBM_ITERATIONS; i++) {\n\t\tn += Voronoi(p * f) * a;\n\t\tf *= FBM_FREQUENCY_GAIN;\n\t\ta *= FBM_AMPLITUDE_GAIN;\n\t\tp.xy = m * p.xy;\n\t}\n\treturn n;\n}\n\nvec2 March(vec3 origin, vec3 direction)\n{\n\tfloat depth = MARCH_STEP_SIZE;\n\tfloat d = 0.0;\n\tfor (int i = 0; i < MAX_MARCH_STEPS; i++) {\n\t\tvec3 p = origin + direction * depth;\n\t\td = FractalVoronoi(p) * NOISE_AMPLITUDE;\n\t\tdepth += max(MARCH_STEP_SIZE, d);\n\t}\n\treturn vec2(depth, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 res = iResolution.xy;\n\tvec2 uv = (fragCoord.xy / res);\n\n\tvec3 direction = UvToWorld(uv);\n\tvec3 origin = vec3(0.0, -iTime*0.2, 0.0);\n\tvec2 data = March(origin, direction);\n    \n\tvec4 color = vec4(.5, 0.615733, 0.555, 1) * data.y * data.x * 0.7;\n        fragColor = mix(color, vec4(1,.2,1,1), max(0.0, 0.4-data.y));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}