{
    "Shader": {
        "info": {
            "date": "1683144948",
            "description": "Hacky, but alive.",
            "flags": 0,
            "hasliked": 0,
            "id": "cdV3Rc",
            "likes": 42,
            "name": "Dream Island",
            "published": 3,
            "tags": [
                "procedural",
                "noise",
                "waves",
                "terrain",
                "raymarch",
                "sea",
                "lighting",
                "island"
            ],
            "usePreview": 1,
            "username": "VPaltoDance",
            "viewed": 894
        },
        "renderpass": [
            {
                "code": "// water based on https://www.shadertoy.com/view/Ms2SD1\n\nfloat water_octave(vec2 uv) \n{\n    uv += value_noise(uv) * 2.0 - 1.0;        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),2.0);\n}\n\n// leave only big waves for geometry calculation\nfloat water_geom(vec2 uv)\n{\n    float freq = WATER_FREQ * 5.832;\n    float amplitude = WATER_HEIGHT * 0.02;\n    float time = WATER_TIME;\n    uv *= octave_m_3;\n    \n    return WATER_LEVEL_HEIGHT + (water_octave((uv+time)*freq) + water_octave((uv-time)*freq))* amplitude;\n}\n\n// for detailed per-fragment appearance use more octaves\nfloat water_detailed(vec2 uv)\n{\n    float freq = WATER_FREQ * 3.24;\n    float amplitude = WATER_HEIGHT *0.0625;\n    float height = WATER_LEVEL_HEIGHT; \n    float time = WATER_TIME;\n    uv *= octave_m_2;\n    \n    for(int i = 0; i < 3; i++) \n    {        \n        height += (water_octave((uv+time)*freq) + water_octave((uv-time)*freq))* amplitude;\n        \n    \tuv *= octave_m; freq *= 1.8; amplitude *= 0.25;\n    }\n    \n    return height;\n}\n\n\nbool map(vec3 ray, inout float t, inout int material_idx)\n{\n    float delta_w_terrain = ray.y - terrain(ray.xz);\n    float delta_w_water = ray.y - water_geom(ray.xz);\n    \n    if(abs(delta_w_terrain) < ERROR) { material_idx = 0; return true; }\n    if(abs(delta_w_water) < ERROR) {material_idx = 1; return true;}\n    \n    \n    float step_mul = min(delta_w_water, delta_w_terrain);\n    t += step_mul * 0.2;\n    \n    return false;\n}\n\nvec3 get_sky_color(vec3 rd)\n{\n    return SKY_LIGHT;\n}\n\nvec3 water_color(vec3 normal, vec3 pos, vec3 rd)\n{\n    // calibrate fresnel - we want some pattern even at high view angels\n    if(rd.y < -0.5)\n        rd.y = -0.5;\n    \n   \tfloat fresnel = pow( 1.0-clamp(dot(-rd, normal), 0.0, 1.0), 5.0);\n            \n    return fresnel*SKY_LIGHT + 0.8 * MAIN_BLUE ;\n}\n\n// doing normals\nvec3 calc_normal(float center, float dhdx, float dhdz, float eps)\n{\n    return normalize(vec3(center - dhdx, eps, center - dhdz));\n}\n\nvec3 get_normal(in vec3 p, float t, int mat)\n{\n    float eps = 0.001 * t;\n    \n    if(mat == 0)\n    {\n        return calc_normal(terrain(p.xz), terrain(vec2(p.x+eps, p.z)), terrain(vec2(p.x, p.z+eps)), eps);\n    }\n    else if(mat == 1) \n    {\n        return calc_normal(water_detailed(p.xz), water_detailed(vec2(p.x+eps, p.z)), water_detailed(vec2(p.x, p.z+eps)), eps);\n    }\n    \n    return vec3(1.0, 0.0, 1.0);\n}\n\n// super-hacky shadows\nfloat test_shadow( vec3 ray_origin, vec3 ray_direction)\n{\n    \n    vec2 box_intersect = box_intersection(ray_origin, ray_direction, BOX);\n    \n    float res = 1.0;\n    \n    if(box_intersect.x > 0.0\n        || (ray_origin.x < 1.0 && ray_origin.x > -1.0 &&  \n            ray_origin.y < BOX.y && \n            ray_origin.z < 1.0 && ray_origin.z > -1.0))\n    {\n        float t = box_intersect.x > 0.0 ? box_intersect.x : 0.02;\n        for (int i = 0; i < MAX_ITER; i++)\n        {\n            vec3 ray = ray_origin + t*ray_direction;\n            float delta_w_terrain = ray.y - terrain(ray.xz );\n            if (delta_w_terrain < ERROR)\n            {\n                return clamp(ray.y * ray.y * t * t * 1.5, clamp(t, 0.0, 0.3), 1.0 );\n            }\n            \n            t += delta_w_terrain * 0.4 + 0.001;\n            if(t > box_intersect.y || ray.y > BOX.y) return 1.0;\n        }\n    }\n    \n    return clamp( res, 0.0, 1.0 );\n}\n\n// main material function for water and terrain\nvec3 material_calc(vec3 pos, vec3 ray_direction, vec3 normal, float t, int mat_type)\n{\n    vec3 col;\n    vec3 light_dir = -normalize(LIGHT_DIR);\n    \n    float sun_shadow = test_shadow(pos, light_dir);\n    if(mat_type == TERRAIN_MATERIAL)\n    {\n        float sun_diffuse = clamp(dot(normal, light_dir), 0.0, 1.0);\n        float sky_diffuse = sqrt(clamp(0.5 + 0.5 * normal.y, 0.0, 1.0 ));\n        float ind_diffuse = clamp( 0.2 + 0.8*dot( normalize( vec3(-light_dir.x, 0.0, light_dir.z ) ), normal ), 0.0, 1.0 );\n\n        float mid = pos.y - WATER_LEVEL_HEIGHT * 0.5;\n        vec3 colmain = mix(MAIN_GREEN, MAIN_BROWN, smoothstep(0.2,0.9,fract(mid)) );\n        colmain *= 1.0-0.6*smoothstep(0.31,0.8,pos.y);\n          \n        if(abs(pos.y - WATER_LEVEL_HEIGHT) < 0.04) colmain = SAND_COLOR;\n        \n        col = LIGHT_COL *sun_diffuse *sun_shadow + SKY_LIGHT * sky_diffuse;\n        col += ind_diffuse * vec3(0.45,0.35,0.25) + (get_sky_color(normal) + MAIN_BLUE)*0.12 ;\n        col *= colmain; \n        \n        vec3 hal = normalize(light_dir-ray_direction);\n        \n        col += (0.5)*(0.04+0.96*pow(clamp(1.0+dot(hal,ray_direction),0.0,1.0),5.0))*\n               vec3(7.0,6.0,5.0)*sun_diffuse*sun_shadow*\n               pow( clamp(dot(normal,hal), 0.0, 1.0),16.0);\n    }\n    else if(mat_type == WATER_MATERIAL)\n    {\n        float x = terrain(pos.xz);\n        float delta = abs(pos.y - x) * 0.5;\n        \n        float atten = smoothstep(1.0,0.99,length(pos.xz));\n        vec3 depth_layer1 =  atten*vec3(0.0, 0.2, 0.4);\n               \n        \n        col = water_color(normal, pos, ray_direction);\n        \n        \n        col *= (1.0 + 1.3 * smoothstep(0.11, 0.0, delta));\n        \n        float sh = float(clamp(abs(value_noise(pos.xz * 12.0 + iTime*0.1)), 0.0, 1.0)> 0.5);\n        col += 0.4 * smoothstep(0.35, 1.0, \n                sh * sin(delta * 200.0 + iTime * 1.5)\n                * smoothstep(1.5, 1.45, length(pos.xz))\n                * smoothstep(0.07, 0.02, delta));\n        \n        col = mix(0.3 * col, col, sun_shadow);\n    }\n    else\n    {\n        col = vec3(1.0, 0.0, 1.0); // Debug for missing some parts with no material\n    }\n    \n    \n   float fo = 1.0 - exp(-pow(0.1 * t, 1.5) );\n   vec3 fco = 0.25 * (MAIN_BLUE + get_sky_color(normal))*vec3(0.2, 0.33, 0.5);\n   col = mix( col, fco, fo );\n   \n   col += rainbow(ray_direction);\n   \n   return col;\n}\n\n\nvec3 Render(in vec3 ray_origin, in vec3 ray_direction)\n{\n    vec2 box_intersect = box_intersection(ray_origin, ray_direction, BOX);\n    float water_dist = ( WATER_LEVEL_HEIGHT * 2.0 - ray_origin.y) / ray_direction.y;\n    \n    int material_idx = WATER_MATERIAL;\n    \n    float t = box_intersect.x > 0.0 ? box_intersect.x : water_dist;\n    vec3 ray = ray_origin + ray_direction * t;\n    \n    for(int i = 0; i < MAX_ITER; ++i)\n    {\n        if(map(ray, t, material_idx)) break;\n        \n        ray = ray_origin + ray_direction * t;\n    }\n    \n    vec3 normal = get_normal(ray, t, material_idx);\n    vec3 col = material_calc(ray, ray_direction, normal, t, material_idx);  \n    return col;\n}\n\n// Post-processing from some of Inigo Quilez shaders\nvoid psot_process(inout vec3 in_color, vec2 q, vec2 sp, float aspect)\n{\t\n    in_color += smoothstep(1.0, 0.0, length(sp)) * LIGHT_COL * 0.003;\n    \n    // Color grading\n    in_color = in_color * vec3(1.11,0.89,0.79);\n    \n    // Compress\n    in_color = 1.35*in_color/(1.0+in_color);\n    \n    // Gamma\n    in_color = pow( in_color, vec3(0.454545) );\n    \n    // S-surve\n    //color = clamp(color,0.0,1.0);\n    in_color = in_color*in_color*(3.0-2.0*in_color);\n    \n    // Vignette\n    in_color *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    float aspect = iResolution.x / iResolution.y;\n    \n    vec3 view_target = vec3(0.0, 0.1, 0.0);\n    vec3 cam_pos = vec3( 0.0,1.288,-0.96);\n    mat3 cam_mat = set_camera(cam_pos, view_target); \n    \n    vec3 color = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = (-0.5 + vec2(float(m),float(n)) / float(AA)) * 2.0/ iResolution.y;\n        vec3 view_dir = cam_mat * normalize(vec3(p + o,1.5));\n\t#else    \n        vec3 view_dir = cam_mat * normalize(vec3(p,1.5));\n\t#endif\n    \n        color += Render(cam_pos, view_dir);\n    \n\t#if AA>1\n    }\n    color /= float(AA*AA);\n\t#endif\n    \n    // Do the post-processing\n    psot_process(color, fragCoord/iResolution.xy, p, aspect);\n    \n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// math\n#define PI 3.14159265\n#define PI_D_2 1.5707963267\n// parameters\n#define WATER_LEVEL_HEIGHT 0.21\n#define TERRAIN_OCTAVE_NUM 8\n#define MAX_ITER 64\n\n// error to be used for float operations\n#define ERROR 0.02\n\n// AABB of the island for ray marching optimization\n#define BOX vec3(1.0, 0.7, 1.0)\n\n\n// main colors use for material appearance\n#define MAIN_GREEN vec3(0.035, 0.08, 0.02)\n#define MAIN_BLUE vec3(0.0, 0.15, 0.35)\n#define MAIN_BROWN vec3(0.4,0.2,0.05)\n#define SAND_COLOR vec3(0.256, 0.16, 0.04)\n\n// light parameters\n#define LIGHT_DIR vec3(0.1, -0.2, 1.0)\n#define LIGHT_COL vec3(8.10,6.00,4.20)\n#define SKY_LIGHT vec3(0.4, 0.7, 1.2)\n\n// water parameters\n#define WATER_HEIGHT 0.36\n#define WATER_SPEED 0.4\n#define WATER_FREQ 0.16\n#define WATER_TIME iTime * WATER_SPEED\n\n// material ids\n#define WATER_MATERIAL 1\n#define TERRAIN_MATERIAL 0\n\nconst mat2 octave_m   = mat2(1.6,1.2,-1.2,1.6);\nconst mat2 octave_m_2 = mat2(1.12,3.84,-3.84,1.12); // octave_m * octave_m\nconst mat2 octave_m_3 = mat2(-2.816,7.488,-7.488,-2.816); // octave_m * octave_m * octave_m\n\n// super-sampling parameter for AA\n#define AA 1\n\n// a hack for webgl compiler to not unroll the loop\n#define ZERO (min(iFrame,0))\n\n// rotation matrix for octaves\nconst mat2 terrain_octave_rot = mat2(0.75471,-0.65606,0.65606,0.75470);\n\nfloat hash13(vec2 p2)\n{\n    vec3 p3 = vec3(fract(p2 * .1031), .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat value_noise( in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 u = smoothstep(0.0, 1.0, fract(p));    \n    \n    float res = mix(mix( hash13(i),             \n                         hash13(i + vec2(1,0)),u.x),\n                    mix( hash13(i + vec2(0,1)), \n                         hash13(i + vec2(1,1)),u.x),u.y);\n    return res;\n}\n\n// a terrain pattern of first (OCTAVE_NUM / 2) octaves\nfloat terrain_raw_height( in vec2 p)\n{\n    float amplitude = 1.0;\n\tfloat height = 0.0;\n    vec2 rot_coords = p;\n\tfor (int i = 0; i < TERRAIN_OCTAVE_NUM / 2; ++i)\n\t{\n\t\theight += amplitude * value_noise(rot_coords);\n\t\tamplitude *= 0.45;\n\t\trot_coords = 2.0 * terrain_octave_rot * rot_coords;\n\t}\n    \n    return height;\n    \n}\n\n// the actual terrain heightmap, downscaled at the edges the bounding box to make the actual island form\nfloat terrain( in vec2 p)\n{\n    // calculating major low-freq octaves\n    float amplitude = 1.0;\n\tfloat octaves = 0.0;\n    vec2 rot_coords = p;\n\tfor (int i = 0; i < TERRAIN_OCTAVE_NUM / 2; i++)\n\t{\n\t\toctaves += amplitude * value_noise(rot_coords);\n\t\tamplitude *= 0.45;\n\t\trot_coords = 2.0 * terrain_octave_rot * rot_coords;\n\t}\n    \n    // downscale them to get the island pattern\n    float height = (octaves - 1.0) * (1.5 - smoothstep(0.8, 1.0, length(p)));\n    \n    // calculating minor high-freq octaves \n    octaves = .0;\n\tfor (int i = TERRAIN_OCTAVE_NUM / 2; i < TERRAIN_OCTAVE_NUM; i++)\n\t{\n\t\toctaves += amplitude * value_noise(rot_coords);\n\t\tamplitude *= 0.45;\n\t\trot_coords = 2.0 * terrain_octave_rot * rot_coords;\n\t}\n    \n    // adding them without any scale\n    height += 2.0 * octaves;\n\t\n    // making shure the underwater surface fades smoothly with distance from the center\n    float dist = length(p);\n    return dist > 1.0 ? max(0.0, height) * (2.0 - dist * dist) : height;\n}\n\nvec3 rainbow(vec3 ray_dir) \n{\n    \n    vec3 rainbow_dir = normalize(vec3(0.0, -1.0, 0.7));\n    float angle = degrees(acos(4.0*dot(rainbow_dir, ray_dir) - 2.35));\n\n    const float intensity = 0.15;\n\t\n\tvec3 color_angles = vec3(50.0, 53.0, 56.0);\t// angle for red, green and blue\n    vec3 spectre_color = clamp(1.0 - abs((color_angles - angle) * 0.2), 0.0, 1.0);\n    \n    vec3 spectre_color_2 = spectre_color * spectre_color;    \n    vec3 spectre_color_3 = spectre_color_2 * spectre_color;\n\tvec3 color = (3.0 * spectre_color_2 - 2.0 * spectre_color_3) * intensity;\n    \n    return color  *  smoothstep(-0.6, -0.5, ray_dir.y);\n}\n\n\nmat3 set_camera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cf = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cf,up) );\n\tvec3 cv = normalize( cross(cu,cf) );\n    return mat3( cu, cv, cf );\n}\n\n// Box intersection by Inigo Quilez https://iquilezles.org/articles/boxfunctions\n\nvec2 box_intersection( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN > tF || tF < 0.0) return vec2(-1.0); // no intersection\n    \n    return vec2( tN, tF );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}