{
    "Shader": {
        "info": {
            "date": "1513796580",
            "description": "The 2nd version of the iterative SDF Encoder shown here: https://www.shadertoy.com/view/XlfBDl\nStill takes the same amount of iterations, but is much more accurate with the result. Click & Drag to create a shape.",
            "flags": 32,
            "hasliked": 0,
            "id": "4tXfDl",
            "likes": 1,
            "name": "Signed Distance Fields v2",
            "published": 3,
            "tags": [
                "sdf",
                "iterative",
                "float"
            ],
            "usePreview": 0,
            "username": "Xaymar",
            "viewed": 846
        },
        "renderpass": [
            {
                "code": "// 2nd Version of this: https://www.shadertoy.com/view/XlfBDl\n\n// Buffer A: Shape Input for Buffer D.\n// Buffer D: SDF Generator, handles actual Alpha -> SDF conversion.\n// Image: Final output, do whatever you want with the SDF and shape input here.\n\n// Controls\n// - LMB + X Move: Resize Inner Ring Radius\n// - LMB + Y Move: Resize Outer Ring Radius\n\nconst float dist = 64.0;\nconst float borderDist = 32.0; // Modify this to get a larger or smaller ring.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float v = texture(iChannel0, uv).r;\n    if (v <= borderDist) {\n        fragColor = vec4(1.0, 1.0, 1.0, 0.0) * (1.0 - v / (borderDist + 0.0001));\n    }\n    //fragColor = vec4(v / dist);\n    //fragColor.rgb = texture(iChannel0, uv).rgb;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5, 0.5);\n    \n    fragColor.a = 0.0;\n    float dist = distance(uv, vec2(0, 0)) * 2.0;\n    if ((dist >= iMouse.x / iResolution.x) && (dist <= iMouse.x / iResolution.x + iMouse.y / iResolution.y)) {\n    \tfragColor.a = 1.0;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// 2nd Version of this: https://www.shadertoy.com/view/XlfBDl\n// \n// This approach relies on actual distance to an edge, instead\n//  of naively adding 1 or 1.41 to neighbouring fields. Due to\n//  this is has much higher precision, but now has other issues.\n//\n// The idea behind it is still the same, we generate the SDF \n//  during runtime instead of using a precalculated one. Since\n//  GPUs are optimized to gather instead of scatter, the approach\n//  is still iterative and only checks the neighbouring texels.\n//\n// The issues this approach has:\n// - Updates to the SDF are rather jarring.\n// - Generates noise if it can't find a proper unique shape.\n// - Somewhat slower than the original V1.\n// \n// Advantages over V1:\n// - Higher accuracy if there is a unique shape.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvInverse = 1.0 / iResolution.xy;\n    \n    // Are we already on the shape?\n    float alpha = texture(iChannel1, uv).a;\n    if (alpha > 0.0) {\n        fragColor.r = 0.0;\n        fragColor.gb = uv;\n        return;\n    }\n    \n    // Solve distance based on neighbours.\n\t{\n        float dU, dD, dL, dR, dUL, dUR, dDL, dDR;\n        vec2 uvU, uvD, uvL, uvR, uvUL, uvUR, uvDL, uvDR;\n        \n        uvU = texture(iChannel0, uv - vec2(0, uvInverse.y)).gb;\n        uvD = texture(iChannel0, uv + vec2(0, uvInverse.y)).gb;\n        uvL = texture(iChannel0, uv - vec2(uvInverse.x, 0)).gb;\n        uvR = texture(iChannel0, uv + vec2(uvInverse.x, 0)).gb;\n        \n        uvUL = texture(iChannel0, uv - vec2(uvInverse.x, uvInverse.y)).gb;\n        uvUR = texture(iChannel0, uv - vec2(-uvInverse.x, uvInverse.y)).gb;\n        uvDL = texture(iChannel0, uv + vec2(-uvInverse.x, uvInverse.y)).gb;\n        uvDR = texture(iChannel0, uv + vec2(uvInverse.x, uvInverse.y)).gb;\n        \n        dU = (texture(iChannel1, uvU).a > 0.0 ? distance(uv / uvInverse, uvU / uvInverse) : 65535.0);\n        dD = (texture(iChannel1, uvD).a > 0.0 ? distance(uv / uvInverse, uvD / uvInverse) : 65535.0);\n        dL = (texture(iChannel1, uvL).a > 0.0 ? distance(uv / uvInverse, uvL / uvInverse) : 65535.0);\n        dR = (texture(iChannel1, uvR).a > 0.0 ? distance(uv / uvInverse, uvR / uvInverse) : 65535.0);\n        dUL = (texture(iChannel1, uvUL).a > 0.0 ? distance(uv / uvInverse, uvUL / uvInverse) : 65535.0);\n        dUR = (texture(iChannel1, uvUR).a > 0.0 ? distance(uv / uvInverse, uvUR / uvInverse) : 65535.0);\n        dDL = (texture(iChannel1, uvDL).a > 0.0 ? distance(uv / uvInverse, uvDL / uvInverse) : 65535.0);\n        dDR = (texture(iChannel1, uvDR).a > 0.0 ? distance(uv / uvInverse, uvDR / uvInverse) : 65535.0);\n        \n        float dLow = 65535.0; vec2 uvLow = uv;\n        if (dU < dLow) { uvLow = uvU; dLow = dU; };\n        if (dD < dLow) { uvLow = uvD; dLow = dD; };\n        if (dL < dLow) { uvLow = uvL; dLow = dL; };\n        if (dR < dLow) { uvLow = uvR; dLow = dR; };\n        if (dUL < dLow) { uvLow = uvUL; dLow = dUL; }\n        if (dUR < dLow) { uvLow = uvUR; dLow = dUR; }\n        if (dDL < dLow) { uvLow = uvDL; dLow = dDL; }\n        if (dDR < dLow) { uvLow = uvDR; dLow = dDR; }\n        \n        fragColor.r = dLow + 1.0;\n        fragColor.gb = uvLow;\n        \n\t\treturn;\n\t}\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}