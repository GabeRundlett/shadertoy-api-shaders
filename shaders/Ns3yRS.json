{
    "Shader": {
        "info": {
            "date": "1653578314",
            "description": "You are on a DISCO BAR. You have drink way to much, taken some pills, the music is very loud , your head is spinning and spinning non stop.",
            "flags": 32,
            "hasliked": 0,
            "id": "Ns3yRS",
            "likes": 6,
            "name": "Palos de boliche",
            "published": 3,
            "tags": [
                "raymarching",
                "disco",
                "lights",
                "bar"
            ],
            "usePreview": 0,
            "username": "jpupper",
            "viewed": 359
        },
        "renderpass": [
            {
                "code": "// VARIABLES GLOBALES\nfloat det = .001; // umbral para detectar choque \nvec3 lightpos1, lightpos2,lightpos3; // posicion de las luces\nfloat light1, light2,light3; // distancia a las luces\nvec3 light1color = vec3(2.,0.,0.); // color luz 1\nvec3 light2color = vec3(0.,2.,2.); // color luz 2\nvec3 light3color = vec3(0.,0.2,.0); // color luz 2\n\n#define pi 3.14159265359\n#define time iTime\n#define resolution iResolution\n// matriz de rotación\nmat2 rot(float a) \n{\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n// distancia a un octaedro\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n// función de distancia (distance estimation)\nfloat de(vec3 p) \n{\n    light1 = length(p - lightpos1) - .1; // distancia a las luces, que están definidas como esferas de radio .1\n    light2 = length(p - lightpos2) - .1; // \n    \n    vec3 p2 = p; \n    \n    \n    p.yz *= rot(pi/4.+sin(time*.3)*1.); // rotaciones\n    p.xz *= rot(time * .1);\n    p.xy *= rot(time * .1+cos(time*.025)*2.);\n    //p.x = sin(p.x+time*2.);\n    //p- = sin(p.y+time*2.);\n    \n    \n    \n    float oct = max(sdOctahedron(p, 5.), -length(p)+0.3); // distancia a octaedro restando una esfera\n    \n    float ms = floor(4.0)+1.;\n    float id2 = floor(p.x/ms);\n\n    \n    p.y+=time;\n    p.x = mod(p.x, ms) - ms/2.;\n    p.z = mod(p.z, ms) - ms/2.;\n \n    p.y = mod(p.y, ms) - ms/2.;\n    \n   // p.x = sin(p.x*1.0+time);\n    \n\n    oct = sdTorus(p,vec2(1.+sin(p.z*1.+time*1.+sin(id2*30.+time)*10.)*.3,0.1));   \n    \n    \n     float idx2 = sin(id2*2.);\n    \n    \n     float s =  exp(-.2 * sin(distance(p, lightpos1)*2.+time)*.4);\n     oct = sdSphere(p,0.8);\n     oct = sdRoundBox(p,vec3(0.1,.1,sin(id2*10.)*4.+2000000000000.1),0.01);\n    \n    \n    \n    float d = min(oct, min(light1, light2)*10.); // obtención de distancia mínima (combinar objetos)\n    \n    \n    p2.z+=30.5;\n    float d2 = max(d,1.-sdSphere(p2,10.9));\n          //d2 = min(d,sdSphere(p2,4.9));\n    \n    return d2*0.53;\n}\n\n\n// función normal (vector perpendicular a la superficie)\nvec3 normal(vec3 p) \n{\n    vec2 d = vec2(0., det);\n    return normalize(vec3(de(p+d.yxx), de(p+d.xyx), de(p+d.xxy)) - de(p));\n}\n\n\n// función shade (p = punto en el que golpeó el rayo, dir = dirección del rayo)\nvec3 shade(vec3 p, vec3 dir)\n{   \n    \n    \n    \n    float l1 = length(p.xyz);\n    \n    light1color = vec3(1.0,sin(l1*10.+time*.1),1.0);\n\n    light2color = vec3(0.3,0.0,sin(l1*10.)*.5+.5);\n\n    vec3 c1 = vec3(1.0,0.7,0.0);\n    \n    vec3 c2 = vec3(1.0,0.0,0.8);\n    \n    \n    l1  = exp(-.5 * distance(p, lightpos1));\n    l1 = sin(l1*10.+time+sin(p.x));\n    //l1 = smoothstep(0.9,0.9,l1);\n    light1color = mix(c1,c2,l1);\n    \n    //light1color = hsb2rgb(vec3(l1,1.0,1.0));\n    \n    if (light1 < det) return light1color; // si golpeó a una luz, devolver el color de la misma\n    if (light2 < det) return light2color; // sin aplicar obviamente el cálculo de su propia iluminación\n    \n    vec3 lightdir1 = normalize(lightpos1 - p); // obtención de la dirección hacia donde están las luces\n    vec3 lightdir2 = normalize(lightpos2 - p); // desde el punto p\n    vec3 lightdir3 = normalize(lightpos3 - p); // desde el punto p\n     \n    \n    float fade1 = exp(-.2 * distance(p, lightpos1)); // atenuación de la luz basada en la distancia entre p\n    float fade2 = exp(-.2 * distance(p, lightpos2)); // y la posición de las mismas\n    \n    vec3 n = normal(p); // obtención de la normal\n    \n    \n    vec3 amb = mix(c1,c2,0.5)*.03; // luz ambiental\n    vec3 dif1 = max(0., dot(lightdir1, n)) * light1color * fade1 * .7; // luces difusas, se aplica el color de la luz\n    vec3 dif2 = max(0., dot(lightdir2, n)) * light2color * fade2 * .7; // y la atenuación según la distancia\n     vec3 ref1 = reflect(lightdir1, n); // vector reflejo entre la dirección de la luz y\n    vec3 ref2 = reflect(lightdir2, n); // el normal de la superficie\n    \n    vec3 spe1 = pow(max(0., dot(ref1, dir)),10.) * light1color * fade1; // calculo de luz especular, también \n    vec3 spe2 = pow(max(0., dot(ref2, dir)),10.) * light2color * fade2; // teniendo en cuenta la atenuación por distancia\n    \n    return amb + dif1 + spe1 +dif2+spe2 ; // color final combinando las luces\n}\n\n// función de raymarching\nvec3 march(vec3 from, vec3 dir) \n{\n    float maxdist = 50.;\n    float totdist = 0.;\n    float steps = 100.;\n    float d;\n    vec3 p;\n    vec3 col = vec3(0.);\n    float glow1 = 0., glow2 = 0.,glow3 = 0.; // variables para la obtención del brillo \"glow\" alrededor de las luces\n    float glowgeneral = 0.; // variable para la obtención de glow general con \"step count\"\n    for (float i=0.; i<steps; i++)\n    {\n        p = from + totdist * dir;\n        d = de(p);\n        if (d < det || totdist > maxdist) break;\n        totdist += d;\n        glow1 = max(glow1, 1. - light1); // capturamos cuando el rayo pasa cerca de las luces, obteniendo un valor\n        glow2 = max(glow2, 1. - light2); // entre 0 y 1 según la distancia a la que pasó\n      \n        glowgeneral++; // step counting para obtener brillo glow general\n    }\n    \n    if (d < det) \n    {\n        col = shade(p, dir);\n    }\n    \n    col+=smoothstep(.99,.99,sin(shade(p,dir)*100.+10.+pi/2.));\n    \n    if(length(col) > .9){\n        //col = vec3(0.0);\n    }\n    \n    col += pow(glow1, 5.) * light1color; // sumamos el brillo glow de las luces, elevando a un exponente\n   \n   // col += pow(glow2, 5.) * light2color; // para definir el tamaño del glow    \n //   col += glowgeneral * glowgeneral * .00001; // lo mismo para el glow general que se puede apreciar en el objeto\n    // este glow genera \"banding\", sobre todo si no está exponenciado\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = (gl_FragCoord.xy - resolution.xy / 2.) / resolution.y;\n    vec2 puv  = fragCoord.xy / iResolution.xy; ;\n    vec3 from = vec3(0., 0., -25.);\n    vec3 dir = normalize(vec3(uv, 1.5));\n    lightpos1 = vec3(sin(time) * 2., sin(time * 1.), sin(time*1.)*5.); // definimos la posición de las luces\n    lightpos2 = -lightpos1.yxz; // copia las coordenadas de la luz 1 rotando los ejes\n   \n    vec3 col = march(from, dir);\n    \n    \n    puv.x-=0.35;\n    \n    puv.y+=0.48;\n    puv.y = 1.-puv.y;\n    vec3 textoloco = texture(iChannel0,puv).rgb;\n    textoloco = vec3((textoloco.r+textoloco.g+textoloco.b)/3.);\n    textoloco*=col;\n    \n    \n    col += textoloco*3.*abs(fract(time*.1)*2.-1.);\n    \n    //col = blendMode(16,col,textoloco,1.0);\n    fragColor = vec4(col, 1.);\n    \n    \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ↙\n//  ↙\n//   ↙\n// https://youtu.be/dQw4w9WgXcQ\n\n// compare algorithm performance, comment out line below to see previous performance:\n#define ANOTHER_ALGORITHM      // runs slower on ARM, so comment this out if mobile phone performance is priority\n\nvec2 uv;\n\n#define time iTime\n#define resolution iResolution\n\nconst vec2 ch_size  = vec2(1.0, 2.0) * 0.6;              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.5, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -5., 1.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\n//      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)\n//const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n// split 16 Bit int into two 8 Bit int for mobile phones with ridiculous 1-byte int\n#define n0 ddigit(0x22,0xFF);\n#define n1 ddigit(0x02,0x81);\n#define n2 ddigit(0x11,0x77);\n#define n3 ddigit(0x11,0xE7);\n#define n4 ddigit(0x55,0x08);\n#define n5 ddigit(0x11,0xEE);\n#define n6 ddigit(0x11,0xFE);\n#define n7 ddigit(0x22,0x06);\n#define n8 ddigit(0x11,0xFF);\n#define n9 ddigit(0x11,0xEF);\n\n#define A ddigit(0x11,0x9F);\n#define B ddigit(0x92,0x7E);\n#define C ddigit(0x00,0x7E);\n#define D ddigit(0x44,0xE7);\n#define E ddigit(0x10,0x7E);\n#define F ddigit(0x10,0x1E);\n#define G ddigit(0x80,0x7E);\n#define H ddigit(0x11,0x99);\n#define I ddigit(0x44,0x66);\n#define J ddigit(0x44,0x36);\n#define K ddigit(0x92,0x18);\n#define L ddigit(0x00,0x78);\n#define M ddigit(0x0A,0x99);\n#define N ddigit(0x88,0x99);\n#define O ddigit(0x00,0xFF);\n#define P ddigit(0x11,0x1F);\n#define Q ddigit(0x80,0xFF);\n#define R ddigit(0x91,0x1F);\n#define S ddigit(0x88,0x66);\n#define T ddigit(0x44,0x06);\n#define U ddigit(0x00,0xF9);\n#define u ddigit(0x00,0xF0);\n#define V ddigit(0x22,0x18);\n#define W ddigit(0xA0,0x99);\n#define w ddigit(0xA0,0x90);\n#define X ddigit(0xAA,0x00);\n#define Y ddigit(0x4A,0x00);\n#define Z ddigit(0x22,0x66);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0,0);\n#define s_minus   ddigit(0x11,0x00);\n#define s_plus    ddigit(0x55,0x00);\n#define s_greater ddigit(0x28,0x00);\n#define s_less    ddigit(0x82,0x00);\n#define s_sqrt    ddigit(0x0C,0x02);\n#define s_sw      ddigit(0x55,0xAA);\n#define s_pow     ddigit(0x02,0x01);\n#define upper_u   ddigit(0x11,0x09);\n#define s_bra    ddigit(0x00,0x3C);\n#define s_ket    ddigit(0x00,0xC3);\n#define s_quotl    ddigit(0x04,0x01);\n#define s_quotr    ddigit(0x04,0x08);\n#define s_degrees    ddigit(0x05,0x03);\n#define s_ast    ddigit(0xFF,0x00);\n#define s_question ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x41,0x07);\n#define s_exclam   ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x44,0x00);\n#define s_comma   ch_pos-=vec2(.45); ddigit(0x20,0x00); ch_pos+=vec2(.45);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n\n#ifdef ANOTHER_ALGORITHM\nfloat dseg1(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x-(uv.y*.5-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\nfloat dseg2(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x+(uv.y*.5-.9-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n#else\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n}\n#endif\nfloat dsegH(vec2 p0, vec2 p1) // avoiding matric ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n\treturn distance(cp, vec2(clamp(cp.x, 0., p1.x-p0.x), 0.) );\n}\nfloat dsegV(vec2 p0, vec2 p1) // avoiding matrix ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(0, distance(p0, p1))));\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n\nbool bit(int n)\n{\n\treturn (n/2)*2 != n;\n}\n\nfloat d = 1e6;\n\n#ifdef ANOTHER_ALGORITHM\t\t// Intel skylake GPU seems to prefer this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n\tvec2 cp = uv - ch_pos;\n\t// better performance in this order, on Intel Iris 550 skylake  (WHY does order matter??)\n\tif (n == 0 && nn==0)     v = min(v, dsegH(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/4)) v = min(v, dsegH(vec2( -0.438,  1.000), vec2(-0.063, 1.000)));\n\tif (bit(nn/2)) v = min(v, dsegH(vec2(0.063,  1.000), vec2(0.438,  1.000)));\n\tif (bit(nn/32)) v = min(v, dsegH(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dsegH(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n/1)) v = min(v, dsegH(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/16)) v = min(v, dsegH(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(nn/1)) v = min(v, dsegV(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/128)) v = min(v, dsegV(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/4)) v = min(v, dsegV(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/64)) v = min(v, dsegV(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(nn/8)) v = min(v, dsegV(vec2(-0.500,  0.063), vec2(-0.500,  0.937)));\n\tif (bit(nn/16)) v = min(v, dsegV(vec2(-0.500, -0.938), vec2(-0.500, -0.063)));\n\t// matrix ops last\n\tif (bit(n/2)) v = min(v, dseg1(vec2( 0.063,  0.063), vec2( 0.063,  0.938)));\n\tif (bit(n/8)) v = min(v, dseg2(vec2(-0.963,  0.063), vec2(-1.338,  0.938)));\n\tif (bit(n/32)) v = min(v, dseg1(vec2(-0.963, -0.938), vec2(-0.963, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg2(vec2( 0.063, -0.938), vec2( 0.063, -0.063)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#else\t\t// some GPU's may run faster with this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n    vec2 cp = uv - ch_pos;\n    if (n == 0 && nn == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/1)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/2)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(nn/4)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(nn/8)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(nn/16)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(nn/32)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(nn/128)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/1)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/2)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n/4)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/8)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n/16)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n/32)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n/64)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#endif\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvec3 generarTextoLoco(){\n   \n    //fragColor = vec4(fractalLoco();,1.);\n    //fragColor = vec4(vec3(1.0,0.0,0.0),1.);\n    vec2 aspect = resolution.xy / resolution.y;\n\tuv = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\n\tfloat _d =  1.0-length(uv);\n    \n    \n\tuv *= 40.0 ;\n\t\n    uv -= vec2(-8., 4.);\n    //uv *= rotate(time+uv.x*0.05);\n\n\t//uv.x+=4. + sin(uv.y*1.5+time*3.)*.15;\n\tch_pos = ch_start;\n\n\t\t\tnl2\n\t   \t\t_ _ _ _ _ _ _ J P U P P E R _ _ _ _ _\n    float a = smoothstep(0.6,0.1,d);\n    float b = smoothstep(0.5,0.4,d) * .8;\n  \tvec3 ch_color = hsv2rgb_smooth(vec3(time*0.4+uv.y*0.1,0.5,1.0));\n    vec3 col=ch_color*a;\n    return col;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec3 col=generarTextoLoco();\n       //  col+=texto;\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float STfeed = 0.971;\nfloat STspeed = 0.81;\n\n#define time iTime\n#define resolution iResolution\n#define mouse iMouse\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat poly(vec2 uv,vec2 p, float s, float dif,int N,float a){\n    \n    // Remap the space to -1. to 1.\n    \n    vec2 st = p - uv ;\n    \n    \n    // Angle and radius from the current pixel\n    float a2 = atan(st.x,st.y)+a;\n    float r = TWO_PI/float(N);\n    \n    float d = cos(floor(.5+a2/r)*r-a2)*length(st);\n    float e = 1.0 - smoothstep(s,dif,d);\n      \n    return e;\n}\n\n\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.56222123);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\n\nfloat noise (in vec2 st,float fase) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float fase2 = fase;\n    // Four corners in 2D of a tile\n    float a = sin(random(i)*fase2);\n    float b =  sin(random(i + vec2(1.0, 0.0))*fase2);\n    float c =  sin(random(i + vec2(0.0, 1.0))*fase2);\n    float d =  sin(random(i + vec2(1.0, 1.0))*fase2);\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(1);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y) ;\n    return 20.0 * dot(m, g);\n}\n\n/*************************************************/\n\n// TODAS LAS FUNCIONES DE BLENDING SACADAS DE  https://github.com/jamieowen/glsl-blend\n\n\n///SOFT LIGHT\n#define ADD 1 \n#define\tAVERAGE 2\n#define\tCOLOR_BURN 3\n#define\tCOLOR_DODGE 4\n#define\tDARKEN 5\n#define\tDIFFERENCE 6\n#define\tEXCLUSION 7\n#define\tGLOW 8\n#define\tHARD_LIGHT 9\n#define\tHARD_MIX 10\n#define\tLIGHTEN 11\n#define\tLINEAR_BURN 12\n#define\tLINEAR_DODGE 13\n#define\tLINEAR_LIGHT 14\n#define\tMULTIPLY 15\n#define\tNEGATION 16\n#define\tNORMAL 17\n#define\tOVERLAY 18\n#define\tPHOENIX 19\n#define\tPIN_LIGHT 20\n#define\tREFLECT 21\n#define\tSCREEN 22\n#define\tSOFT_LIGHT 23\n#define\tSUBTRACT 24\n#define\tVIVID_LIGHT 25\n\n\nfloat blendSoftLight(float base, float blend) {\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n//ADD : \nfloat blendAdd(float base, float blend) {\n\treturn min(base+blend,1.0);\n}\n\nvec3 blendAdd(vec3 base, vec3 blend) {\n\treturn min(base+blend,vec3(1.0));\n}\n\nvec3 blendAdd(vec3 base, vec3 blend, float opacity) {\n\treturn (blendAdd(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendAverage(vec3 base, vec3 blend) {\n\treturn (base+blend)/2.0;\n}\n\nvec3 blendAverage(vec3 base, vec3 blend, float opacity) {\n\treturn (blendAverage(base, blend) * opacity + base * (1.0 - opacity));\n}\n  \nfloat blendColorBurn(float base, float blend) {\n\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend) {\n\treturn vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendColorDodge(float base, float blend) {\n\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend) {\n\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendDarken(float base, float blend) {\n\treturn min(blend,base);\n}\n\nvec3 blendDarken(vec3 base, vec3 blend) {\n\treturn vec3(blendDarken(base.r,blend.r),blendDarken(base.g,blend.g),blendDarken(base.b,blend.b));\n}\n\nvec3 blendDarken(vec3 base, vec3 blend, float opacity) {\n\treturn (blendDarken(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendDifference(vec3 base, vec3 blend) {\n\treturn abs(base-blend);\n}\n\nvec3 blendDifference(vec3 base, vec3 blend, float opacity) {\n\treturn (blendDifference(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendExclusion(vec3 base, vec3 blend) {\n\treturn base+blend-2.0*base*blend;\n}\n\nvec3 blendExclusion(vec3 base, vec3 blend, float opacity) {\n\treturn (blendExclusion(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendLighten(float base, float blend) {\n\treturn max(blend,base);\n}\n\nvec3 blendLighten(vec3 base, vec3 blend) {\n\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\n}\n\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearBurn(float base, float blend) {\n\t// Note : Same implementation as BlendSubtractf\n\treturn max(base+blend-1.0,0.0);\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendSubtract\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearDodge(float base, float blend) {\n\t// Note : Same implementation as BlendAddf\n\treturn min(base+blend,1.0);\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendAdd\n\treturn min(base+blend,vec3(1.0));\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearLight(float base, float blend) {\n\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend) {\n\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendMultiply(vec3 base, vec3 blend) {\n\treturn base*blend;\n}\n\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\n\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendNegation(vec3 base, vec3 blend) {\n\treturn vec3(1.0)-abs(vec3(1.0)-base-blend);\n}\n\nvec3 blendNegation(vec3 base, vec3 blend, float opacity) {\n\treturn (blendNegation(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nvec3 blendNormal(vec3 base, vec3 blend) {\n\treturn blend;\n}\n\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) {\n\treturn (blendNormal(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendOverlay(float base, float blend) {\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend) {\n\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendPhoenix(vec3 base, vec3 blend) {\n\treturn min(base,blend)-max(base,blend)+vec3(1.0);\n}\n\nvec3 blendPhoenix(vec3 base, vec3 blend, float opacity) {\n\treturn (blendPhoenix(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendPinLight(float base, float blend) {\n\treturn (blend<0.5)?blendDarken(base,(2.0*blend)):blendLighten(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendPinLight(vec3 base, vec3 blend) {\n\treturn vec3(blendPinLight(base.r,blend.r),blendPinLight(base.g,blend.g),blendPinLight(base.b,blend.b));\n}\n\nvec3 blendPinLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendPinLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendReflect(float base, float blend) {\n\treturn (blend==1.0)?blend:min(base*base/(1.0-blend),1.0);\n}\n\nvec3 blendReflect(vec3 base, vec3 blend) {\n\treturn vec3(blendReflect(base.r,blend.r),blendReflect(base.g,blend.g),blendReflect(base.b,blend.b));\n}\n\nvec3 blendReflect(vec3 base, vec3 blend, float opacity) {\n\treturn (blendReflect(base, blend) * opacity + base * (1.0 - opacity));\n}\n  \nfloat blendScreen(float base, float blend) {\n\treturn 1.0-((1.0-base)*(1.0-blend));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend) {\n\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\n\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendSubstract(float base, float blend) {\n\treturn max(base+blend-1.0,0.0);\n}\n\nvec3 blendSubstract(vec3 base, vec3 blend) {\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\n}\n\nvec3 blendSubstract(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSubstract(base, blend) * opacity + blend * (1.0 - opacity));\n}\nfloat blendVividLight(float base, float blend) {\n\treturn (blend<0.5)?blendColorBurn(base,(2.0*blend)):blendColorDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendVividLight(vec3 base, vec3 blend) {\n\treturn vec3(blendVividLight(base.r,blend.r),blendVividLight(base.g,blend.g),blendVividLight(base.b,blend.b));\n}\n\nvec3 blendVividLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendVividLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendHardLight(vec3 base, vec3 blend) {\n\treturn blendOverlay(blend,base);\n}\n\nvec3 blendHardLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendHardLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendGlow(vec3 base, vec3 blend) {\n\treturn blendReflect(blend,base);\n}\n\nvec3 blendGlow(vec3 base, vec3 blend, float opacity) {\n\treturn (blendGlow(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendHardMix(float base, float blend) {\n\treturn (blendVividLight(base,blend)<0.5)?0.0:1.0;\n}\n\nvec3 blendHardMix(vec3 base, vec3 blend) {\n\treturn vec3(blendHardMix(base.r,blend.r),blendHardMix(base.g,blend.g),blendHardMix(base.b,blend.b));\n}\n\nvec3 blendHardMix(vec3 base, vec3 blend, float opacity) {\n\treturn (blendHardMix(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendMode( int mode, vec3 base, vec3 blend ){\n\tif( mode == 1 ){\n\t\treturn blendAdd( base, blend );\n\t}else\n\tif( mode == 2 ){\n\t\treturn blendAverage( base, blend );\n\t}else\n\tif( mode == 3 ){\n\t\treturn blendColorBurn( base, blend );\n\t}else\n\tif( mode == 4 ){\n\t\treturn blendColorDodge( base, blend );\n\t}else\n\tif( mode == 5 ){\n\t\treturn blendDarken( base, blend );\n\t}else\n\tif( mode == 6 ){\n\t\treturn blendDifference( base, blend );\n\t}else\n\tif( mode == 7 ){\n\t\treturn blendExclusion( base, blend );\n\t}else\n\tif( mode == 8 ){\n\t\treturn blendGlow( base, blend );\n\t}else\n\tif( mode == 9 ){\n\t\treturn blendHardLight( base, blend );\n\t}else\n\tif( mode == 10 ){\n\t\treturn blendHardMix( base, blend );\n\t}else\n\tif( mode == 11 ){\n\t\treturn blendLighten( base, blend );\n\t}else\n\tif( mode == 12 ){\n\t\treturn blendLinearBurn( base, blend );\n\t}else\n\tif( mode == 13 ){\n\t\treturn blendLinearDodge( base, blend );\n\t}else\n\tif( mode == 14 ){\n\t\treturn blendLinearLight( base, blend );\n\t}else\n\tif( mode == 15 ){\n\t\treturn blendMultiply( base, blend );\n\t}else\n\tif( mode == 16 ){\n\t\treturn blendNegation( base, blend );\n\t}else\n\tif( mode == 17 ){\n\t\treturn blendNormal( base, blend );\n\t}else\n\tif( mode == 18 ){\n\t\treturn blendOverlay( base, blend );\n\t}else\n\tif( mode == 19 ){\n\t\treturn blendPhoenix( base, blend );\n\t}else\n\tif( mode == 20 ){\n\t\treturn blendPinLight( base, blend );\n\t}else\n\tif( mode == 21 ){\n\t\treturn blendReflect( base, blend );\n\t}else\n\tif( mode == 22 ){\n\t\treturn blendScreen( base, blend );\n\t}else\n\tif( mode == 23 ){\n\t\treturn blendSoftLight( base, blend );\n\t}else\n\tif( mode == 24 ){\n\t\treturn blendSubstract( base, blend );\n\t}else\n\tif( mode == 25 ){\n\t\treturn blendVividLight( base, blend );\n\t}\n\treturn vec3(0.0);\n}\nvec3 blendMode( int mode, vec3 base, vec3 blend ,float opacity){\n\tif( mode == 1 ){\n\t\treturn blendAdd( base, blend ,opacity);\n\t}else\n\tif( mode == 2 ){\n\t\treturn blendAverage( base, blend ,opacity);\n\t}else\n\tif( mode == 3 ){\n\t\treturn blendColorBurn( base, blend ,opacity);\n\t}else\n\tif( mode == 4 ){\n\t\treturn blendColorDodge( base, blend ,opacity);\n\t}else\n\tif( mode == 5 ){\n\t\treturn blendDarken( base, blend ,opacity);\n\t}else\n\tif( mode == 6 ){\n\t\treturn blendDifference( base, blend ,opacity);\n\t}else\n\tif( mode == 7 ){\n\t\treturn blendExclusion( base, blend,opacity );\n\t}else\n\tif( mode == 8 ){\n\t\treturn blendGlow( base, blend ,opacity);\n\t}else\n\tif( mode == 9 ){\n\t\treturn blendHardLight( base, blend ,opacity);\n\t}else\n\tif( mode == 10 ){\n\t\treturn blendHardMix( base, blend,opacity );\n\t}else\n\tif( mode == 11 ){\n\t\treturn blendLighten( base, blend ,opacity);\n\t}else\n\tif( mode == 12 ){\n\t\treturn blendLinearBurn( base, blend ,opacity);\n\t}else\n\tif( mode == 13 ){\n\t\treturn blendLinearDodge( base, blend,opacity );\n\t}else\n\tif( mode == 14 ){\n\t\treturn blendLinearLight( base, blend ,opacity);\n\t}else\n\tif( mode == 15 ){\n\t\treturn blendMultiply( base, blend ,opacity);\n\t}else\n\tif( mode == 16 ){\n\t\treturn blendNegation( base, blend ,opacity);\n\t}else\n\tif( mode == 17 ){\n\t\treturn blendNormal( base, blend ,opacity);\n\t}else\n\tif( mode == 18 ){\n\t\treturn blendOverlay( base, blend ,opacity);\n\t}else\n\tif( mode == 19 ){\n\t\treturn blendPhoenix( base, blend ,opacity);\n\t}else\n\tif( mode == 20 ){\n\t\treturn blendPinLight( base, blend ,opacity);\n\t}else\n\tif( mode == 21 ){\n\t\treturn blendReflect( base, blend ,opacity);\n\t}else\n\tif( mode == 22 ){\n\t\treturn blendScreen( base, blend ,opacity);\n\t}else\n\tif( mode == 23 ){\n\t\treturn blendSoftLight( base, blend ,opacity);\n\t}else\n\tif( mode == 24 ){\n\t\treturn blendSubstract( base, blend ,opacity);\n\t}else\n\tif( mode == 25 ){\n\t\treturn blendVividLight( base, blend ,opacity);\n\t}\n\treturn vec3(0.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}