{
    "Shader": {
        "info": {
            "date": "1709067579",
            "description": "Use the mouse to look around :)",
            "flags": 0,
            "hasliked": 0,
            "id": "43XXRr",
            "likes": 5,
            "name": "antarctica",
            "published": 3,
            "tags": [
                "antarctica"
            ],
            "usePreview": 0,
            "username": "ianertson",
            "viewed": 169
        },
        "renderpass": [
            {
                "code": "// increase for more detail (also more laggy)\n// This will increase the number of iterations.\n#define DETAIL 12.0\n\n// increase how much you want without lag\n#define CHEAP_DETAIL_COUNT 0.5\n#define CHEAP_DETAIL_SCALE 1.5\n\n\n#define R iResolution.xy\n#define T (iTime)\n#define M_PI 3.14159265358979323846264338327950288\n#define TAU (M_PI*2.0)\n#define FUI floatBitsToUint\n#define ZERO min(0, iFrame)\n\nmat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, s, -s, c); }\nvec3 aces(vec3 x) { return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.0,1.0); }\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\n\nfloat hash(vec2 ip, float seed) {\n  uvec2 p = FUI(ip); uint s = FUI(seed); uvec2 k = ~p + ~s;\n  p ^= p << 17U; p ^= p >> 13U; p ^= p << 5U;\n  p += (p ^ k) + p * k; p *= 1013U; p ^= (p >> 4U);\n  return float(p.x * k.y + p.y + p.y * k.x + k.y) / float(0xFFFFFFFFU);\n}\n\n\n\n#define LINEAR(ID, LV, FUN, S)\\\n    mix(\\\n        mix(FUN(ID+vec2(0, 0), S), FUN(ID+vec2(1, 0), S), LV.x),\\\n        mix(FUN(ID+vec2(0, 1), S), FUN(ID+vec2(1, 1), S), LV.x),\\\n        LV.y)\n\n\n\nvec3 G(vec2 p) {\n  vec3 col = vec3(0.0);\n  vec2 id = floor(p);\n  vec2 lv = fract(p); \n  \n  float x = LINEAR(id, lv, hash, 13.58743);\n  float y = LINEAR(id, lv, hash, 55.55537);\n  \n  vec2 po = id+(0.1*(vec2(x, y)-0.5));\n  \n\n  \n  float r =  mix(0.2, 0.9, x*y);\n  \n  float fe = r*0.75;\n  float d = smoothstep(r+fe, r-fe, distance(p, po));\n  col = col+d;\n  \n  return clamp(col+y, 0.0, 1.0);\n}\n\nvec3 ground(vec2 ip) {\n  ip += 400.;\n  vec3 col = vec3(0.0);\n  \n  \n  vec2 id = floor(ip);\n  vec2 lv = fract(ip);\n  lv = lv*lv*(3.0-2.0*lv);\n  \n  float se1 = 3.28583;\n  float se2 = 7.48663;\n  float se3 = 44.0755;\n  float se4 = 13.6436;\n  float se5 = 1.04372;\n  float se6 = 31.88501;\n  float se7 = 81.11046;\n  float h1 = LINEAR(id, lv, hash, se1);\n  float n = ceil(mix(1.0, DETAIL, h1*h1))+1.;\n  float t = T*0.05;\n  \n  \n  vec2 woff = vec2(sin((t*4.)+TAU*h1), cos((t*4.)+TAU*h1));\n  vec2 p3 = (ip+woff)*0.25;\n  vec2 id3 = floor(p3);\n  vec2 lv3 = fract(p3);\n  float wt = LINEAR(id3, lv3, hash, se7);\n  wt = smoothstep(0.4, 0.7, wt);\n\n  for (float i = float(ZERO)+1.; i < n; i+=(1.0+0.15*n*wt)) {\n      float ni = i / n;\n      float a = LINEAR(id, lv, hash, se2);\n      float b = LINEAR(id, lv, hash, se3);\n      vec2 off = (vec2(a, b)*2.0-1.0)*0.25;\n      \n      float c = LINEAR(id, lv, hash, se4);\n      float d = LINEAR(id, lv, hash, se5);\n      \n      off += 0.25*vec2(sin(t+TAU*c), cos(t+TAU*d));\n      \n      vec2 p2 = (ip+off)*ceil(1.0+ni*CHEAP_DETAIL_COUNT);\n      id = floor(p2);\n      lv = fract(p2);\n      lv = lv * lv*(3.0-2.0*lv);\n      float e = LINEAR(id, lv, hash, se6);\n      vec3 next = G((lv*e*b*(CHEAP_DETAIL_SCALE)));\n      col += next;\n  }\n  col /= n;\n  col += vec3(0.05, 0.56, 0.97)*wt*2.;\n  return col;\n}\n\nvec3 render(vec2 p) {\n    vec3 col = vec3(0.0);\n    \n    \n    vec2 e = vec2(0.05);\n    float nz = 0.0;\n    vec3 n3 = normalize(luma(ground(p)) - vec3(\n        luma(ground(p - e.xy)),\n        luma(ground(p - e.yx)),\n        1.\n    ));\n    vec2 n = n3.xy;\n    vec2 L = normalize(vec2(0.5, -1.));\n    vec3 alb = ground(p) / (M_PI*0.5);\n    float NdotL = max(0.15, dot(n, L));\n    vec3 diffuse = alb;\n    vec3 att = vec3(0.96, 0.89, 0.89) * NdotL * 2.;\n    col += diffuse * att;\n    return col;\n}\n\nvoid mainImage(out vec4 o, in vec2 fc) {\n  vec3 col = vec3(0.0);\n  vec2 uv = (fc-0.5*R.xy)/R.y;\n  vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y,iMouse.zw);\n  float st = T*0.25;\n  float zm = mix(8.0, 20.0, 0.5+0.5*sin(st));\n  vec2 move = 20.0*vec2(sin(st), cos(st));\n  if (m.z > 0.001) {\n      move = -m.xy*zm;\n  }\n  col += render((uv*zm) + move);\n  col = max(vec3(0.0), col);\n  col += col*col + col*luma(col);\n  col = aces(col);\n  col += col*0.45;\n  col = pow(col, vec3(1.0 / 2.2));\n  o = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}