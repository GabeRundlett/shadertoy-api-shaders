{
    "Shader": {
        "info": {
            "date": "1441889734",
            "description": "3-tap 2D Voronoi with cheap highlights.",
            "flags": 0,
            "hasliked": 0,
            "id": "4lBSzW",
            "likes": 57,
            "name": "3-Tap 2D Voronoi",
            "published": 3,
            "tags": [
                "voronoi",
                "triangle",
                "simplex",
                "bump",
                "3tap"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 5864
        },
        "renderpass": [
            {
                "code": "/*\n\t3-Tap 2D Voronoi\n\t----------------\n\n\tI saw member BH's hexagonal Voronoi example, which reminded me that I had a 3-tap \n    simplex version gathering pixel dust on my harddrive, so here it is.\n\n\tI hastily added some coloring and very cheap highlights, just to break the visual \n    monotony,  but you can safely ignore most of the code and head straight to the \n    \"Voronoi3Tap\" function. That's the main point. Like BH's example, this one is \n    branchless. In fact, there's virtually no code at all.\n\n\tAs mentioned below, 3-tap Voronoi is just a novelty, bordering on pointless, but I \n    thought it might provide a basis for anyone wishing to build a 3D simplex version. \n    I also have a 4-tap Voronoi function that involves even less computation.\n\n\tBy the way, the pattern is supposed to be concave. The reason I mention that is, if \n    I stare at a highlighted Voronoi pattern for too long, it sometimes looks inverted. \n    Usually, I have to close my eyes and reopen them to reinvert it. I've often wondered \n    whether that happens to everyone, or whether I'm just getting old. :)\n\n\t// Other Shadertoy examples:\n\n\t// Hexagonal Voronoi - By \"BH.\"\n    // By the way, his version has artifacts, but Dr2 and myself have some hexagonal \n    // Voronoi examples on here that are more robust.\n\thttps://www.shadertoy.com/view/ltjXz1 - I'm looking forward to the finished version. :)\n\n\t// Voronoi fast, a 2x2 grid, 4tap version - By \"davidbargo\":\n\thttps://www.shadertoy.com/view/4tsXRH\n\n*/\n\n\n\n// Standard 2x2 hash algorithm.\nvec2 hash22(vec2 p) { \n\n    // Faster, but probably doesn't disperse things as nicely as other ways.\n    float n = sin(mod(dot(p,vec2(1, 113)), 6.2831859)); \n    p = fract(vec2(8.*n, n)*262144.);\n    return sin(p*6.2831853 + iTime*2.);\n    \n/* \n\treturn fract(sin(p)*43758.5453)*2. - 1.;\n    \n    //p = fract(sin(p)*43758.5453);\n\t//p = sin(p*6.2831853 + iTime);\n    //return sign(p)*.25 + .75*p;\n    \n    //p = fract(sin(p)*43758.5453)*2. - 1.;\n    //return (sign(p)*.25 + p*.75);    \n */   \n    \n}\n\n// 3-tap Voronoi... kind of. I'm pretty sure I'm not the only one who's thought to try this.\n//\n// Due to the simplex grid setup, it's probably slightly more expensive than the 4-tap, \n// square grid version, but I believe the staggered cells make the patterns look a little \n// nicer. I'd imagine it's faster than the unrolled 9-tap version, but I couldn't say for \n// sure. Anyway, it's just a novelty, bordering on pointless, but I thought it might \n// interest someone.\n\n// I'm not perfectly happy with the random offset figure of \".125\" or the normalization \n// figure of \".425.\" They might be right, but I'll determine those for sure later. They \n// seem to work.\n//\n// Credits: Ken Perlin, Brian Sharpe, IQ, various Shadertoy people, etc.\n//\nfloat Voronoi3Tap(vec2 p){\n    \n\t// Simplex grid stuff.\n    //\n    vec2 s = floor(p + (p.x + p.y)*.3660254); // Skew the current point.\n    p -= s - (s.x + s.y)*.2113249; // Use it to attain the vector to the base vertice.\n\n    // Determine which triangle we're in -- Much easier to visualize than the 3D version. :)\n    // The following is equivalent to \"float i = step(p.y, p.x),\" but slightly faster, I \n    // hear.\n    float i = p.x<p.y? 0. : 1.;\n    \n    \n    // Vectors to the other two triangle vertices.\n    vec2 p1 = p - vec2(i, 1. - i) + .2113249, p2 = p - .5773502; \n\n    // Add some random gradient offsets to the three vectors above.\n    p += hash22(s)*.125;\n    p1 += hash22(s +  vec2(i, 1. - i))*.125;\n    p2 += hash22(s + 1.)*.125;\n    \n    // Determine the minimum Euclidean distance. You could try other distance metrics, \n    // if you wanted.\n    float d = min(min(dot(p, p), dot(p1, p1)), dot(p2, p2))/.425;\n   \n    // That's all there is to it.\n    return sqrt(d); // Take the square root, if you want, but it's not mandatory.\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Prerotation to align the grid to the horizontal, but I'm leaving it on a\n    // slant for... stylistic purposes. :)\n    //const float a = 3.14159/12.;\n    //uv *= mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n    // Take two 3-tap Voronoi samples near one another.\n    float c = Voronoi3Tap(uv*5.);\n    float c2 = Voronoi3Tap(uv*5. - 9./iResolution.y);\n    \n    // Coloring the cell.\n    //\n    // Use the Voronoi value, \"c,\" above to produce a couple of different colors.\n    // Mix those colors according to some kind of moving geometric patten.\n    // Setting \"pattern\" to zero or one displays just one of the colors.\n    float pattern = cos(uv.x*.75*3.14159 - .9)*cos(uv.y*1.5*3.14159 - .75)*.5 + .5;\n    \n    // Just to confuse things a little more, two different color schemes are faded in out.\n    //\n    // Color scheme one - Mixing a firey red with some bio green in a sinusoidal kind of \n    // pattern.\n    vec3 col = mix(vec3(c*1.3, c*c, pow(c, 10.)), vec3(c*c*.8, c, c*c*.35), pattern );\n    // Color scheme two - Farbrausch fr-025 neon, for that disco feel. :)\n    vec3 col2 = mix(vec3(c*1.2, pow(c, 8.), c*c), vec3(c*1.3, c*c, pow(c, 10.)), pattern );\n    // Alternating between the two color schemes.\n    col = mix(col, col2, smoothstep(.4, .6, sin(iTime*.25)*.5 + .5)); // \n\n    //col = mix(col.zxy, col, cos(uv.x*2.*3.14159)*cos(uv.y*5.*3.141595)*.25 + .75 );\n    \n    // Hilighting.\n    //\n    // Use a combination of the sample difference to add some really cheap, blueish \n    // highlighting. It's a directional-derviative based lighting trick. Interesting, \n    // but no substitute for point-lit bump mapping. Comment the following line out to \n    // see the regular, flat pattern.\n    col += vec3(.5, .8, 1)*(c2*c2*c2 - c*c*c)*5.;\n       \n    // Speckles.\n    //\n    // Adding subtle speckling to break things up and give it a less plastic feel.\n    col += (length(hash22(uv + iTime))*.06 - .03)*vec3(1, .5, 0);\n    \n\n    // Vignette.\n    //\n    uv = fragCoord/iResolution.xy;\n    //col *= (1.15 - dot(uv - .5, uv - .5)*.5); // *vec3(1, .97, .92); // Roundish.\n    // Rectangular.\n    col *= smoothstep(0., .5, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y), .25))*\n                      vec3(1.1, 1.07, 1.01);\n    \n    \n    // Even more color schemes.\n    //col = col.xzy; // col.yzx, col.zyx, etc.\n    \n    // Approximate gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}