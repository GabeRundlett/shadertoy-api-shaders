{
    "Shader": {
        "info": {
            "date": "1457846769",
            "description": "reference implementation for YUV colorspaces. cylinder demos the YCoCg color space, with chroma radius clamped to bicone of safe values in RGB cube. Drag mouse to see slices.",
            "flags": 0,
            "hasliked": 0,
            "id": "4dcSRN",
            "likes": 18,
            "name": "YUV YPbPr YCoCg",
            "published": 3,
            "tags": [
                "yuv",
                "srgb",
                "ycbcr",
                "ypbpr",
                "yccbccrc",
                "ycocg",
                "ycgco"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 2202
        },
        "renderpass": [
            {
                "code": "// undefine to see full mapped range\n#define CLAMP_BICONE\n\n// define for chroma normalization (when biconic clamping is disabled)\n//#define NORM_CHROMA\n\n//----------------------------------------------------------------------------\n\n// YUV, generic conversion\n// ranges: Y=0..1, U=-uvmax.x..uvmax.x, V=-uvmax.x..uvmax.x\n\nvec3 yuv_rgb (vec3 yuv, vec2 wbwr, vec2 uvmax) {\n    vec2 br = yuv.x + yuv.yz * (1.0 - wbwr) / uvmax;\n\tfloat g = (yuv.x - dot(wbwr, br)) / (1.0 - wbwr.x - wbwr.y);\n\treturn vec3(br.y, g, br.x);\n}\n\nvec3 rgb_yuv (vec3 rgb, vec2 wbwr, vec2 uvmax) {\n\tfloat y = wbwr.y*rgb.r + (1.0 - wbwr.x - wbwr.y)*rgb.g + wbwr.x*rgb.b;\n    return vec3(y, uvmax * (rgb.br - y) / (1.0 - wbwr));\n}\n\n//----------------------------------------------------------------------------\n\n// YUV, HDTV, gamma compressed, ITU-R BT.709\n// ranges: Y=0..1, U=-0.436..0.436, V=-0.615..0.615\n\nvec3 yuv_rgb (vec3 yuv) {\n    return yuv_rgb(yuv, vec2(0.0722, 0.2126), vec2(0.436, 0.615));\n}\n\nvec3 rgb_yuv (vec3 rgb) {\n    return rgb_yuv(rgb, vec2(0.0722, 0.2126), vec2(0.436, 0.615));\n}\n\n//----------------------------------------------------------------------------\n\n// Y*b*r, generic conversion\n// ranges: Y=0..1, b=-0.5..0.5, r=-0.5..0.5\n\nvec3 ypbpr_rgb (vec3 ybr, vec2 kbkr) {\n    return yuv_rgb(ybr, kbkr, vec2(0.5));\n}\n    \nvec3 rgb_ypbpr (vec3 rgb, vec2 kbkr) {\n    return rgb_yuv(rgb, kbkr, vec2(0.5));\n}\n\n//----------------------------------------------------------------------------\n\n// YPbPr, analog, gamma compressed, HDTV\n// ranges: Y=0..1, b=-0.5..0.5, r=-0.5..0.5\n\n// YPbPr to RGB, after ITU-R BT.709\nvec3 ypbpr_rgb (vec3 ypbpr) {\n    return ypbpr_rgb(ypbpr, vec2(0.0722, 0.2126));\n}\n\n// RGB to YPbPr, after ITU-R BT.709\nvec3 rgb_ypbpr (vec3 rgb) {\n    return rgb_ypbpr(rgb, vec2(0.0722, 0.2126));\n}\n\n//----------------------------------------------------------------------------\n\n// YPbPr, analog, gamma compressed, VGA, TV\n// ranges: Y=0..1, b=-0.5..0.5, r=-0.5..0.5\n\n// YPbPr to RGB, after ITU-R BT.601\nvec3 ypbpr_rgb_bt601 (vec3 ypbpr) {\n    return ypbpr_rgb(ypbpr, vec2(0.114, 0.299));\n}\n\n// RGB to YPbPr, after ITU-R BT.601\nvec3 rgb_ypbpr_bt601 (vec3 rgb) {\n    return rgb_ypbpr(rgb, vec2(0.114, 0.299));\n}\n\n//----------------------------------------------------------------------------\n\n// in the original implementation, the factors and offsets are\n// ypbpr * (219, 224, 224) + (16, 128, 128)\n\n// YPbPr to YCbCr (analog to digital)\nvec3 ypbpr_ycbcr (vec3 ypbpr) {\n\treturn ypbpr * vec3(0.85546875,0.875,0.875) + vec3(0.0625, 0.5, 0.5);\n}\n\n// YCbCr to YPbPr (digital to analog)\nvec3 ycbcr_ypbpr (vec3 ycbcr) {\n\treturn (ycbcr - vec3(0.0625, 0.5, 0.5)) / vec3(0.85546875,0.875,0.875);\n}\n\n//----------------------------------------------------------------------------\n\n// YCbCr, digital, gamma compressed\n// ranges: Y=0..1, b=0..1, r=0..1\n\n// YCbCr to RGB (generic)\nvec3 ycbcr_rgb(vec3 ycbcr, vec2 kbkr) {\n    return ypbpr_rgb(ycbcr_ypbpr(ycbcr), kbkr);\n}\n// RGB to YCbCr (generic)\nvec3 rgb_ycbcr(vec3 rgb, vec2 kbkr) {\n    return ypbpr_ycbcr(rgb_ypbpr(rgb, kbkr));\n}\n// YCbCr to RGB\nvec3 ycbcr_rgb(vec3 ycbcr) {\n    return ypbpr_rgb(ycbcr_ypbpr(ycbcr));\n}\n// RGB to YCbCr\nvec3 rgb_ycbcr(vec3 rgb) {\n    return ypbpr_ycbcr(rgb_ypbpr(rgb));\n}\n\n//----------------------------------------------------------------------------\n\n// ITU-R BT.2020:\n// YcCbcCrc, linear\n// ranges: Y=0..1, b=-0.5..0.5, r=-0.5..0.5\n\n// YcCbcCrc to RGB\nvec3 yccbccrc_rgb(vec3 yccbccrc) {\n\treturn ypbpr_rgb(yccbccrc, vec2(0.0593, 0.2627));\n}\n\n// RGB to YcCbcCrc\nvec3 rgb_yccbccrc(vec3 rgb) {\n\treturn rgb_ypbpr(rgb, vec2(0.0593, 0.2627));\n}\n\n//----------------------------------------------------------------------------\n\n// YCoCg\n// ranges: Y=0..1, Co=-0.5..0.5, Cg=-0.5..0.5\n\nvec3 ycocg_rgb (vec3 ycocg) {\n    vec2 br = vec2(-ycocg.y,ycocg.y) - ycocg.z;\n    return ycocg.x + vec3(br.y, ycocg.z, br.x);\n}\n\nvec3 rgb_ycocg (vec3 rgb) {\n    float tmp = 0.5*(rgb.r + rgb.b);\n    float y = rgb.g + tmp;\n    float Cg = rgb.g - tmp;\n    float Co = rgb.r - rgb.b;\n    return vec3(y, Co, Cg) * 0.5;\n}\n\n//----------------------------------------------------------------------------\n\nvec3 yccbccrc_norm(vec3 ypbpr) {\n    vec3 p = yccbccrc_rgb(ypbpr);\n   \tvec3 ro = yccbccrc_rgb(vec3(ypbpr.x, 0.0, 0.0));\n    vec3 rd = normalize(p - ro);\n    vec3 m = 1./rd;\n    vec3 b = 0.5*abs(m)-m*(ro - 0.5);\n    float tF = min(min(b.x,b.y),b.z);\n    p = ro + rd * tF * max(abs(ypbpr.y),abs(ypbpr.z)) * 2.0;\n\treturn rgb_yccbccrc(p); \n}\n\nvec3 ycocg_norm(vec3 ycocg) {\n    vec3 p = ycocg_rgb(ycocg);\n   \tvec3 ro = ycocg_rgb(vec3(ycocg.x, 0.0, 0.0));\n    vec3 rd = normalize(p - ro);\n    vec3 m = 1./rd;\n    vec3 b = 0.5*abs(m)-m*(ro - 0.5);\n    float tF = min(min(b.x,b.y),b.z);\n    p = ro + rd * tF * max(abs(ycocg.y),abs(ycocg.z)) * 2.0;\n\treturn rgb_ycocg(p); \n}\n\n//----------------------------------------------------------------------------\n\nfloat linear_srgb(float x) {\n    return mix(1.055*pow(x, 1./2.4) - 0.055, 12.92*x, step(x,0.0031308));\n}\nvec3 linear_srgb(vec3 x) {\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x,vec3(0.0031308)));\n}\n\nfloat srgb_linear(float x) {\n    return mix(pow((x + 0.055)/1.055,2.4), x / 12.92, step(x,0.04045));\n}\nvec3 srgb_linear(vec3 x) {\n    return mix(pow((x + 0.055)/1.055,vec3(2.4)), x / 12.92, step(x,vec3(0.04045)));\n}\n\n//----------------------------------------------------------------------------\n\n// from https://www.shadertoy.com/view/4s23DR\nbool cylinder(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// quadratic x^2 + y^2 = 0.5^2 => (org.x + t*dir.x)^2 + (org.y + t*dir.y)^2 = 0.5\n\tfloat a = dot(dir.xy, dir.xy);\n\tfloat b = dot(org.xy, dir.xy);\n\tfloat c = dot(org.xy, org.xy) - 0.25;\n\n\tfloat delta = b * b - a * c;\n\tif( delta < 0.0 )\n\t\treturn false;\n\n\t// 2 roots\n\tfloat deltasqrt = sqrt(delta);\n\tfloat arcp = 1.0 / a;\n\tnear = (-b - deltasqrt) * arcp;\n\tfar = (-b + deltasqrt) * arcp;\n\t\n\t// order roots\n\tfloat temp = min(far, near);\n\tfar = max(far, near);\n\tnear = temp;\n\n\tfloat znear = org.z + near * dir.z;\n\tfloat zfar = org.z + far * dir.z;\n\n\t// top, bottom\n\tvec2 zcap = vec2(0.5, -0.5);\n\tvec2 cap = (zcap - org.z) / dir.z;\n\n\tif ( znear < zcap.y )\n\t\tnear = cap.y;\n\telse if ( znear > zcap.x )\n\t\tnear = cap.x;\n\n\tif ( zfar < zcap.y )\n\t\tfar = cap.y;\n\telse if ( zfar > zcap.x )\n\t\tfar = cap.x;\n\t\n\treturn far > 0.0 && far > near;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nbool huecylinder(vec3 ro, vec3 rd, vec3 p, float cap, float rscale, out vec3 uv) {\n    ro = ro.xzy;\n    rd = rd.xzy;\n    cap = max(cap, 0.0001);\n    ro -= p;\n    ro.z += 0.5;\n    ro.z /= cap;\n    rd.z /= cap;\n    ro.z -= 0.5;\n    \n    float near, far;\n    if (cylinder(ro, rd, near, far)) {\n        vec3 p = ro + rd * near;\n        \n        uv.x = (p.z + 0.5) * cap;\n        //uv.x = srgb_linear(uv.x);\n        uv.yz = p.xy * rscale;\n#ifdef CLAMP_BICONE\n        float r = (1.0-abs(uv.x-0.5)*2.0) * 0.7071;\n        //float r = (1.0-abs(uv.x-0.5)*2.0) * 0.53235;\n        uv.yz *= r;\n#else\n        //uv.yz *= 1.1681404025202;\n#endif\n        uv = clamp(uv, vec3(0.0,-0.5,-0.5), vec3(1.0,0.5,0.5));\n        \n        return true;\n    }    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ms = iMouse.xy / iResolution.xy;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pd = uv * 2.0 - 1.0;\n    pd.x *= iResolution.x / iResolution.y;\n    \n    float a = iTime * 0.5;\n    vec3 ro = vec3(cos(a), 1.0, sin(a)) * 3.0;\n    mat3 m = calcLookAtMatrix(ro, vec3(0.0), 0.0);\n    vec3 rd = normalize(m * vec3(pd.xy,5.0));\n    \n    float cap = (iMouse.z > 0.5)?clamp(ms.y*2.0-0.5,0.0,1.0):(sin(iTime)*0.5+0.5);\n    float rscale = 1.0; //(iMouse.z > 0.5)?ms.x*2.0:1.0;\n    \n    vec3 color = vec3(0.0);\n    float near, far;\n    vec3 yuv;\n    if (huecylinder(ro, rd, vec3(0.0, 0.0, 0.0), cap, rscale, yuv)) {\n        vec3 p = ro + rd * near;\n#ifdef NORM_CHROMA\n        yuv = ycocg_norm(yuv);\n#endif\n        color = ycocg_rgb(yuv);\n        vec3 c = abs(color - 0.5);\n        if (max(c.r,max(c.g,c.b)) > 0.501)\n            color = vec3(0.5);\n    }\n \n#if 0\n    for (int i = 0; i < 10; ++i) {\n    \tcolor = rgb_ycocg(color);\n    \tcolor = ycocg_rgb(color);\n    }\n#endif\n    \n    color = linear_srgb(color);\n    \n\tfragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}