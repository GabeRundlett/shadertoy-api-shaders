{
    "Shader": {
        "info": {
            "date": "1727709841",
            "description": "Simulation of wave equation on a sphere.\n",
            "flags": 32,
            "hasliked": 0,
            "id": "lXSyzV",
            "likes": 8,
            "name": "Waves on a sphere",
            "published": 3,
            "tags": [
                "wave",
                "solver",
                "equation"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 118
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Simulation of wave equation on a sphere.\n// Mouse click to see the map.\n// See individual tabs for details.\n// NOTE: to better model oceans, you might want to use shallow\n// water equations instead.\n// List of tabs:\n//     Common   - Common constants and functions.\n//     Buffer A - Terrain.\n//     Buffer B - Wave simulation.\n//     Image\"   - Main program.\n\n//==============================================================================\n// \"Image\" tab. Main program.\n\nmat2x4 surface(vec3 r)\n{\n    vec3 sph=xyz2sph(r);\n    vec2 uv=tp2uv(sph.yz);\n    // NOTE: relies on texture wrap mode being set to \"repeat\"\n    // in x direction. Alternatively, we can use get().\n    vec4 h=texture(iChannel0,uv);\n    vec3 e=vec3(1.0/iResolution.xy,0);\n    float C=texture(iChannel1,uv).y;\n    float N=texture(iChannel1,uv+e.zy).y;\n    float E=texture(iChannel1,uv+e.xz).y;\n    float S=texture(iChannel1,uv-e.zy).y;\n    float W=texture(iChannel1,uv-e.xz).y;\n    vec2 d=uv2tp(0.5*vec2(E-W,N-S)/e.xy);\n    vec3 n=(vec3(r.x*r.z,r.y*r.z,-r.x*r.x-r.y*r.y)*d.x\n           +vec3(-r.y,+r.x,0)/length(r.xy)*d.y)/length(r.xy);\n    return mat2x4(h,vec4(normalize(r-n),C));\n}\n\nvec3 color(vec3 r,vec3 l,vec3 v)\n{\n    mat2x4 S=surface(r);\n    float a=max(dot(r,l),0.0);\n    float b=max(dot(S[0].xyz,l),0.0);\n    vec3 land =vec3(0.3,0.5,0.3)*(b+1.0/16.0);\n    vec3 ocean=vec3(0.1,0.2,0.5)*(a+1.0/16.0)+pow(max(dot(S[1].xyz,normalize(l-v)),0.0)*smoothstep(0.0,1e-3,a),8.0);\n    return mix(ocean,land,smoothstep(-4e-5,+4e-5,S[0].w));\n}\n\n//==============================================================================\n// Main image.\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec3 col=vec3(0);\n    vec3 l=normalize(vec3(2,3,4));\n    vec4 q=vec4(cos(iTime/32.0)*normalize(vec3(2,5,1)),sin(iTime/32.0));\n    if(iMouse.z<=0.0) // 3D view.\n    {\n        col=0.03125*vec3(0.433,0.3257,0.27655); // Cosmic latte (CIE xz=(0.345,0.345)).\n        vec3 ro=vec3(0,0,2);\n        vec3 rd=normalize(vec3((2.0*fragCoord-iResolution.xy)/iResolution.y,-1.5));\n        float R=1.0,p=dot(ro,rd),d=p*p-dot(ro,ro)+R*R;\n        if(d>0.0)\n        {\n            vec3 r=normalize(ro+(-p-sqrt(d))*rd);\n            col=color(\n                r +2.0*cross(q.xyz,cross(q.xyz,r )+q.w*r ),\n                l +2.0*cross(q.xyz,cross(q.xyz,l )+q.w*l ),\n                rd+2.0*cross(q.xyz,cross(q.xyz,rd)+q.w*rd));\n        }\n    }\n    else              // 2D view.\n    {\n        vec2 uv=fragCoord/iResolution.xy;\n        vec3 rd=vec3(0,0,-1);\n        vec3 r=sph2xyz(vec3(1,uv2tp(uv)));\n        col=color(\n                r,\n                l +2.0*cross(q.xyz,cross(q.xyz,l )+q.w*l ),\n                rd+2.0*cross(q.xyz,cross(q.xyz,rd)+q.w*rd));\n    }\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n//==============================================================================\n// \"Common\" tab. Common constants and functions.\n\nconst float pi=3.14159265358979;\n\n// Conversion between texture and geographical coordinates.\n// NOTE: flips order, i.e. (x,y) <-> (θ,φ), but x<->φ and y<->θ.\n\nvec2 uv2tp(vec2 uv)\n{\n    return vec2(1,2)*pi*uv.yx;\n}\n\nvec2 tp2uv(vec2 tp)\n{\n    return vec2(0.5,1)/pi*tp.yx;\n}\n\n// Spherical coordinates, as per ISO 80000-2:2019.\n// (r,θ,φ) with 0<=θ<π, 0<=φ<2*π.\n\nvec3 sph2xyz(vec3 sph)\n{\n    return sph[0]*vec3(vec2(cos(sph.z),sin(sph.z))*sin(sph.y),cos(sph.y));\n}\n\nvec3 xyz2sph(vec3 xyz)\n{\n    if(length(xyz.xy)==0.0) return vec3(abs(xyz.z),0,0);\n    return vec3(length(xyz),pi/2.0-atan(xyz.z,length(xyz.xy)),pi-atan(xyz.y,-xyz.x));\n}\n\n// Sample texture with the wrapping we need, regardless of what it is setup to.\nvec4 get(sampler2D s,ivec2 v)\n{\n    ivec2 m=textureSize(s,0);\n    return texelFetch(s,ivec2(v.x+m.x*(((m.x-v.x-1)>>31)-(v.x>>31)),clamp(v.y,0,m.y-1)),0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n//==============================================================================\n// \"Buffer A\" tab. Terrain.\n// The terrain is stored in Buffer A, to avoid recomputing it each frame.\n// This (while not strictly necessary) speeds up the code considerably.\n//     .xyz contains terrain normal, in Cartesian space.\n//     .w   contains terrain height.\n\n//==============================================================================\n// Noise with gradient, see https://www.shadertoy.com/view/XXBczD.\n\n// https://www.shadertoy.com/view/dllSW7\nuint hash(uint x)\n{\n    x^=x>>15;\n    x^=(x*x)|1u;\n    x^=x>>17;\n    x*=0x9E3779B9u;\n    x^=x>>13;\n    return x;\n}\n\nvec3 hash3(vec3 r)\n{\n    ivec3 v=ivec3(r);\n    uint h=hash(uint(v.x+1024*v.y+1048576*v.z));\n    return vec3(h&1023u,(h>>10)&1023u,(h>>20)&1023u)/512.0-1.0;\n}\n\n// 3D gradient noise. Gradient in xyz, value in w.\nvec4 noise3(vec3 r)\n{\n    vec3 i=floor(r),v=fract(r),k=vec3(0,1,0),t=v*v*v*(v*(v*6.0-15.0)+10.0);\n    vec3 A=hash3(i+k.xxx); float a=dot(A,v-k.xxx);\n    vec3 B=hash3(i+k.yxx); float b=dot(B,v-k.yxx);\n    vec3 C=hash3(i+k.xyx); float c=dot(C,v-k.xyx);\n    vec3 D=hash3(i+k.yyx); float d=dot(D,v-k.yyx);\n    vec3 E=hash3(i+k.xxy); float e=dot(E,v-k.xxy);\n    vec3 F=hash3(i+k.yxy); float f=dot(F,v-k.yxy);\n    vec3 G=hash3(i+k.xyy); float g=dot(G,v-k.xyy);\n    vec3 H=hash3(i+k.yyy); float h=dot(H,v-k.yyy);\n    return vec4(mix(mix(vec3(b-a,c-a,e-a),vec3(d-c,g-e,f-b),t.yzx),\n                    mix(vec3(f-e,d-b,g-c),vec3(h-g,h-f,h-d),t.yzx),t.zxy)*30.0*v*v*(v*(v-2.0)+1.0)+\n                mix(mix(mix(A,B,t.x),mix(C,D,t.x),t.y),\n                    mix(mix(E,F,t.x),mix(G,H,t.x),t.y),t.z),\n                mix(mix(mix(a,b,t.x),mix(c,d,t.x),t.y),\n                    mix(mix(e,f,t.x),mix(g,h,t.x),t.y),t.z));\n}\n\n//==============================================================================\n// Simple fBm terrain.\n\nvec4 terrain(vec3 r)\n{\n    vec4 ret=vec4(0);\n    for(int i=0;i<11;++i)\n    {\n        float k=float(i),A=exp(2.875*exp(-0.25*abs(k-8.0))-0.5*k),B=exp(0.5*k);\n        ret+=A*vec4(B,B,B,1)*noise3(B*r);\n    }\n    ret+=vec4(0.0,0.0,1.875*exp(r.z*r.z-1.0)*2.0*r.z,1.875*exp(r.z*r.z-1.0)-1.5);\n    ret/=700.0;\n    ret.xyz=normalize(r-ret.xyz);\n    return ret;\n}\n\n//==============================================================================\n// Main image.\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    fragColor=iFrame==0?terrain(sph2xyz(vec3(1,uv2tp(fragCoord/iResolution.xy)))):\n                        get(iChannel0,ivec2(fragCoord));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n//==============================================================================\n// \"Buffer B\" tab. Wave simulation.\n// We are simulating a wave equation of the form\n//     ∂²f/∂t²-c²*∇²f=F\n// where F is the external force. In 3D, the laplacian ∇² in Cartesian\n// coordinates is\n//     ∇²f=∂²f/∂x²+∂²f/∂y²+∂²f/∂z²\n// and in spherical coordinates\n//     ∇²f=1/r²*(∂/∂r(r²*∂f/∂r)+1/sinθ*∂/∂θ(sinθ*∂f/∂θ)+1/sin²θ*∂²f/∂φ²)\n//        =∂²f/∂r²+(2/r)*∂f/∂r+(1/r²)*(∂²f/∂θ²+tanθ*∂f/∂θ+(1/sin²θ)*∂²f/∂φ²)\n// Since we are restricted to the surface of the sphere, we extend the\n// function so it doesn't change with radius:\n//     f(v)=f(v/|v|)\n// which makes radial part of the laplacian 0. If we further work with\n// unit sphere, r=1, then\n//     ∇²f=∂²f/∂θ²+tanθ*∂f/∂θ+(1/sin²θ)*∂²f/∂φ²\n// We then numerically solve this using a leapfrog (CTCS) scheme on\n// a rectangular latitude-longitude grid. The obvious problems at poles\n// are mitigated by the simple expedient of placing continents there.\n// If you lack the ability to reshape the planet to suit your computational\n// needs, you may consider fancier schemes (e.g. cubed sphere, or some\n// kind of logically rectangular grid, or icosahedral-hexagonal grid).\n// The stored values are:\n//     .x - f at previous step\n//     .y - f at current step\n//\n// References:\n//     https://en.wikipedia.org/wiki/Laplace_operator\n//     https://en.wikipedia.org/wiki/Quadrilateralized_spherical_cube\n//     https://en.wikipedia.org/wiki/Geodesic_grid\n//     http://web.archive.org/web/20110514181414/https://www.aei.mpg.de/~rezzolla/lnotes/Evolution_Pdes/evolution_pdes_lnotes.pdf\n//     https://admg.engin.umich.edu/wp-content/uploads/sites/525/2021/03/13-taylor-quadgrids.pdf\n//     Matania Ben-Artzi, Joseph Falcovitz, Philippe G. LeFloch. Hyperbolic conservation laws on the sphere. A geometry-compatible finite volume scheme. 2009. ⟨hal-00387395⟩\n//         https://hal.science/hal-00387395v1/document\n//     Calhoun, Donna A., Christiane Helzel and Randall J. LeVeque. “Logically Rectangular Grids and Finite Volume Methods for PDEs in Circular and Spherical Domains.” SIAM Rev. 50 (2008): 723-752.\n//         https://faculty.washington.edu/rjl/pubs/circles/066409.pdf\n//     Rowan Cockett, Eldad Haber. \"Logically Orthogonal Meshes for Geophysical Applications\"\n//         https://row1.ca/pdf/logically-rectangular-mesh.pdf\n\n//==============================================================================\n\n// External force.\nfloat force(vec2 uv)\n{\n    vec3 r=sph2xyz(vec3(1,uv2tp(uv)));\n    vec3 v=normalize(cos(vec3(5,7,8)*(7.5+4e-4*float(iFrame))));\n    return exp(-512.0*dot(v-r,v-r))*sin(0.01*float(iFrame));\n}\n\n// Wave equation simulation.\nvec4 update(ivec2 ij)\n{\n    vec2 C=get(iChannel1,ij).xy;\n    vec2 N=get(iChannel1,ij+ivec2(0,1)).xy;\n    vec2 E=get(iChannel1,ij+ivec2(1,0)).xy;\n    vec2 S=get(iChannel1,ij-ivec2(0,1)).xy;\n    vec2 W=get(iChannel1,ij-ivec2(1,0)).xy;\n    vec2 uv=(vec2(ij)+0.5)/iResolution.xy;\n    vec2 tp=uv2tp(uv);\n    vec2 d =uv2tp(1.0/iResolution.xy);\n    float dt=0.25*min(d.x,d.y);\n    float c=0.125;\n    float Ft=(N-S).y/(2.0*d.x);\n    float Ftt=(N+S-2.0*C).y/(d.x*d.x);\n    float Fpp=(E+W-2.0*C).y/(d.y*d.y);\n    float a=1.0/sin(tp.x),b=cos(tp.x);\n    C=vec2(C.y,c*c*dt*dt*(a*b*Ft+Ftt+a*a*Fpp)+2.0*C.y-C.x);\n    // Add external force impact.\n    C.y+=force(uv)*dt*dt;\n    // Artificial dampening, in part to offset\n    // the energy influx which the above adds.\n    C.y-=1e-4*C.y*dt;\n    // Dampen at shores.\n    C.y*=smoothstep(0.0,-1e-4,get(iChannel0,ij).w);\n    return vec4(C,0,0);\n}\n\n//==============================================================================\n// Main image.\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    fragColor=iFrame==0?vec4(0):\n                        update(ivec2(fragCoord));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}