{
    "Shader": {
        "info": {
            "date": "1696616254",
            "description": "I have no idea what I'm doing :D",
            "flags": 48,
            "hasliked": 0,
            "id": "msycDV",
            "likes": 7,
            "name": "Flow Fields͏",
            "published": 3,
            "tags": [
                "simulation",
                "particles",
                "slime",
                "life",
                "automaton",
                "voronoitracking"
            ],
            "usePreview": 0,
            "username": "01000001",
            "viewed": 220
        },
        "renderpass": [
            {
                "code": "// Buffer A : Particle control\n// Buffer B : Voronoi Tracking\n// Buffer C : Rendering\n// Buffer D : Post processing\n\n// See Buffer A to play around with particle configurations\n// I've included a few fun presets to try :D\n\n// You may wanna use the shadertoy unofficial plugin\n// to speed it up by increasing drawcalls\n// For interactivity though, realtime is nice\n\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    #ifdef display_voronoi\n        O = uv.x>.5?\n            texture(iChannel2, uv):\n            texture(iChannel1, uv).xyzw/r.x/r.y;\n    #else \n        O = texture(iChannel2, uv);\n        \n        //*    \n        O = vec4(\n            O.x*O.x, \n            O.x, \n            sqrt(O.x), \n        1.);//*/\n\n    #endif\n}\n\n// Next up: Ant simulation!\n// And then turbulent particles 👀\n// ^ I wanna recreate this render I made in Blender\n// https://cdn.discordapp.com/attachments/1134975470526537879/1156789266739900456/still_particles.png\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Particle Buffer\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    float aspect = r.x/r.y;\n    \n    // if (uv.x * scale > 1. || uv.y * scale > 1.) return;\n    // Prevent simulation of particles out of bounds\n    // If we allow it then can resize at runtime\n    \n    \n    if (iFrame < 30){\n    \n        O.xy = uv*scale;\n        O.zw = normalize(hash(uvec3(U, iDate.w)).xy*2.-1.);\n        return;\n        \n    }\n\n    O = texture(iChannel0, uv);\n\n    vec2 pos = O.xy;        \n    vec2 vel = O.zw;\n\n    \n    vel += field(pos*6.2 + 2.1)*1e-2;\n    \n    \n    float l = length(vel);\n    if (l > 1.) vel = normalize(vel);\n    vel *= 0.997; // try .998 with pos*2.2 above\n    \n    \n    \n    pos += vel*1e-3 * vec2(1, aspect);\n\n\n    pos = mod(pos, 1.);\n\n    O = vec4(pos, vel);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Voronoi buffer\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    if (iFrame < 10){\n        O = vec4(0);\n        return;\n    }\n    \n    \n    O = texture(iChannel1, uv);\n    \n    vec2 myParticles[4];\n    vec4 particleDists;\n    \n    for (int i = 4; i-->0;){\n        myParticles[i] = texture(iChannel0, decrypt(O[i], r)/scale).xy;\n        particleDists[i] = length(myParticles[i] - uv);\n    }\n    \n    \n    for (int i = 10; i-->0;){\n\n        for (int j = 4; j-->0;){\n        \n            vec3 a = hash(uvec3(U, iFrame - i + j*8))*2.-1.;\n            vec3 b = hash(uvec3(U, iFrame * i - j  ))*2.-1.;\n            vec3 c = hash(uvec3(U, iFrame + i - j*8))*2.-1.;\n        \n            vec2 samp = decrypt(\n                texture(iChannel1,\n                    mod(myParticles[j]\n                        + (a.xy + vec2(a.z, b.x) + b.yz + c.xy) / (r.x/scale) \n                        // Gaussian-ish sampling\n                        // we can use two vec3s to get three vec2s \n                        // and then another one for good measure\n                    ,1.) // Mod loops around overflow coordinates\n                )[i%5]\n            ,r);\n\n            vec2 newParticle = texture(iChannel0, samp/scale).xy;\n\n            push(O, samp, r, particleDists[j], length(newParticle-uv));\n            // Stores four particle IDs in the floats\n        }\n    }\n    \n    \n    for (int i = 0; i < 2; i++){\n        vec2 samp = hash(uvec3(U, iFrame * i)).xy;\n        \n        vec2 newParticle = texture(iChannel0, samp/scale).xy;\n\n        push(O, samp, r, particleDists[0], length(newParticle-uv));\n        // Completely random samples may not seem too critical, \n        // but they significantly improve the stability of the simulation\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n     // I am become pixel, creator of shaders\n    // - 01000001 2023\n\nconst float pi = 3.14159;\nconst float scale = 3.;\n// Try big number to see what's going on. 3 is about the minimum that works semi coherently.\n// Any improvements to accurately render an even larger quanitity of particles would be appreciated :D\n// I have a few ideas but I'd love to learn about the community's knowledge\n\n\n// #define debug\n// Render particles directly, no visual processing\n\n// #define display_voronoi\n// Show the voronoi buffer\n\n\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nvec2 circleSample(uvec3 x){\n    vec2 v,z;\n    for(int i = 0;v=hash(x+uint(v*1e9)).xy, z=v*2.-1., i++<9 && length(z) > 1.;);\n    return z;\n}\n\nmat2 rot( float rad ){\n    return mat2(\n        cos(rad), sin(rad),\n        -sin(rad), cos(rad)\n    );\n}\n\nvec2 decrypt(float d, vec2 r){\n    return vec2(mod(d, r.x), floor(d/r.x))/r;\n}\n\nfloat encrypt(vec2 uv, vec2 r){\n    return uv.x*r.x + floor(uv.y*r.y)*r.x;\n}\n\nvoid push(inout vec4 O, vec2 uv, vec2 res, float me, float new){\n    ivec2 iuv = ivec2(floor(uv*res));\n    ivec2 ires = ivec2(floor(res));\n    \n    float e = encrypt(uv, res);\n    if (new < me && e != O.x && e != O.y && e != O.z && e != O.w){\n        O.w = O.z; O.z = O.y; O.y = O.x;\n        O.x = e;\n    }\n    \n}\n\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n#if 0\n\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n    \n#else\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec2 field(vec2 uv){\n    return vec2(noise(uv), noise(uv + 500.));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Render Buffer\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    float aspect = r.x/r.y;\n    \n    O = vec4(0);\n    \n    float minD = 2.;\n    float x = 0.;\n    for (int i = 0; i<2; i++){\n    \n        for (int j = 4; j-->0;){\n            vec2 samp = decrypt(\n                texture(iChannel1, \n                    uv + (circleSample(uvec3(U, iFrame * i << j)) / (r.x / scale))\n                )[j]\n            ,r)/scale;\n\n            x = length(\n                (texture(iChannel0, samp).xy - uv) * vec2(1, 1./aspect)\n            );\n\n            if (x < minD){\n                minD = x;\n            }\n        }\n    }\n    \n    #ifdef debug\n    #else\n        O = texture(iChannel2, uv\n            //+ (vec2(scale*3e-3)/r)*rot(float(iFrame) * pi/2.)\n        );\n        O *= .96;\n    #endif\n    O += smoothstep(scale/r.x * .25, 0., minD);\n        \n    \n    if (iMouse.z > 0.){\n        if (texelFetch(iChannel3, ivec2(16, 0), 0).x > .0){\n            O.x += max(0., 1.-length((iMouse.xy - U)/r/scale * vec2(1, 1./aspect)) * 500.);\n        } else {\n            O *= min(1., length((iMouse.xy - U)/r/scale * vec2(1, 1./aspect)) * 200.);   \n        }\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Post Processing\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    #ifdef debug\n        O = texture(iChannel2, uv);\n    #else\n        O = texture(iChannel3, uv);\n        O *= .95;\n        O += texture(iChannel2, uv)*1e-2;\n    #endif\n    \n    // Because of SIMD, vector as opposed to operating on only O.x\n    // should be the same speed right? I hope? Pls lmk in comments :)\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}