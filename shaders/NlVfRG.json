{
    "Shader": {
        "info": {
            "date": "1664739613",
            "description": "Some experiment",
            "flags": 0,
            "hasliked": 0,
            "id": "NlVfRG",
            "likes": 4,
            "name": "2D Water Effect Perspective",
            "published": 3,
            "tags": [
                "water",
                "effect",
                "perspective"
            ],
            "usePreview": 0,
            "username": "rubioh",
            "viewed": 288
        },
        "renderpass": [
            {
                "code": "float make_square(vec2 uv, float radius){\n    float length_uv = max(abs(uv.y), abs(uv.x));\n    return (1.-step(radius, length_uv));\n}\nvec2 hash( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(175.1,311.7)),\n             dot(p,vec2(260.5,752.3)));\n    return fract(sin(p+455.)*18.5453);\n}\n\nvec3 random_color(vec2 p)\n{\n    return vec3(hash(p).x, hash(2.*p).x, hash(3.*p).x);\n}\n\n//==============================================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.9;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat noise2(vec3 p)\n{\n    float n = .1;\t// noise amount\n    float iter = 2.0;\n    for (int i = 0; i < 5; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = hash(i).x;\n    float b = hash(i + vec2(1.0, 0.0)).x;\n    float c = hash(i + vec2(0.0, 1.0)).x;\n    float d = hash(i + vec2(1.0, 1.0)).x;\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat fbm( in vec2 x)\n{    \n    float t = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        float f = pow( 2., float(i) );\n        float a = pow( f, -.75 );\n        t += a*noise(f*x);\n    }\n    return t*1.-.4;\n}\n\nfloat fbm_water( in vec2 x)\n{    \n    float t = 0.0;\n    float amp = 0.;\n    for( int i=0; i<7; i++ )\n    {\n        float f = pow( 2., float(i) );\n        float a = pow( f, -.75 );\n        amp = .25*step(5., float(i));\n        t += a*noise(f*x+amp*iTime);\n    }\n    return t*1.-.4;\n}\n\nvec3 warp(vec2 uv){\n    vec2 st = uv;\n    st.y *= 1./(st.y+.2);\n    st.x *= .1;\n    st.x += iTime*.0002;\n    \n    vec2 tmp = st;\n\n    float n = fbm_water(tmp + fbm_water(tmp +fbm_water(tmp )));\n    vec2 pos = rotate2d(n*1./st.y*.1*abs(cos(iTime*.01)))*uv;\n    return vec3(pos, n*1./st.y*.1);\n}\n\n\nvec3 downmirror(vec2 uv){\n    float a = 1.;\n    float z = -a*(uv.y) + 1.;\n    vec2 down_uv = vec2(uv.x/z, -uv.y/z*4.);\n    vec3 warp_down_uv = warp(down_uv);\n    return warp_down_uv; \n    \n}\n\n\nvec3 make_bg(vec3 bg_color){\n    \n    vec3 res = vec3(0, 0, 0);\n    vec3 color_cell = bg_color;\n    res = color_cell;\n    return res;\n}\n\n\nfloat lines(in vec2 pos){\n    float scale = 15.0+.01*cos(iTime);\n    pos *= scale;\n    float v = sin(pos.x*3.1415);\n    return smoothstep(-2., 2., v/fwidth(v));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5, .3);\n\n    // Time varying pixel color\n\n    float up_mask = step(0., uv.y);\n    float down_mask = 1.-up_mask;\n    \n    vec2 up_uv = uv * up_mask;\n    vec2 up_centerize = vec2(0., .2);\n    up_uv = up_uv;\n\n    vec3 tmp = downmirror(uv) * (1.-up_mask);\n    \n    vec2 down_uv = tmp.xy;\n\n\n\n    vec2 bg_up = up_uv/5.;\n    bg_up = rotate2d(noise(bg_up*10.) ) * bg_up;\n    vec3 pattern_up = vec3(2.*lines(bg_up*10.));\n\n    vec2 bg_down = down_uv/5.;\n    bg_down = rotate2d(noise(bg_down*10.) ) * bg_down;\n    vec3 pattern_down = vec3(2.*lines(bg_down*10.));\n    \n    vec3 col_up = make_bg(pattern_up)*up_mask;\n    vec3 col_down = make_bg(pattern_down)*down_mask;\n\n    \n    //vec3 col_up = (vec3(up_uv.x+.2, up_uv.y+.2, 0.) );\n    //vec3 col_down = (vec3(down_uv.x+.2, down_uv.y+.2, 0.) )*down_mask;\n    \n\n    float n = tmp.z;\n    \n    float deltax = dFdx(n)*50.;\n    float deltay = dFdy(n)*100.;\n    float shadow_mask = ((deltax)+(deltay));\n\n   fragColor = vec4((col_down+down_mask*vec3(0., 0., 1.))*.4+vec3(.1,.1,.1)*(shadow_mask)*1.5+col_up,1.0);\n   //fragColor = vec4(vec3(n)*5., 1.);\n\n    // Output to screen\n       \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}