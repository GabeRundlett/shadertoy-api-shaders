{
    "Shader": {
        "info": {
            "date": "1487714745",
            "description": "Hilbert and Morton curves",
            "flags": 0,
            "hasliked": 0,
            "id": "XdlcWr",
            "likes": 30,
            "name": "Inverse Morton and Hilbert",
            "published": 3,
            "tags": [
                "2d",
                "inverse",
                "hilbert",
                "morton"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 1797
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2017\n// License Creative Commons Attribution-ShareAlike 3.0 Unported\n// https://creativecommons.org/licenses/by-sa/3.0/\n\n\n// 0 = Hilbert\n// 1 = Morton\n#define CURVE 0\n\nconst int level = 4;  // Number of points is 2^level in each dimension\n\nivec2 curve( int i )\n{\n    ivec2 res = ivec2(0,0);\n    for( int k=0; k<level; k++ )\n    {\n        #if CURVE==0\n        // inverse Hilbert, https://en.wikipedia.org/wiki/Hilbert_curve\n        ivec2 r = ivec2( i>>1, i^(i>>1) ) & 1;\n        if (r.y==0) { if(r.x==1) { res = (1<<k)-1-res; } res = res.yx; }\n        #else\n\t\t// inverse Morton, https://iquilezles.org/articles/wavelet\n        ivec2 r = ivec2( i, i>>1 ) & 1;\n        #endif\n        \n        res += r<<k;\n        i >>= 2;\n    }\n    return res;\n}\n\n\nfloat sdSqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 d = pa - ba*h;\n    return dot(d,d);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 1.0/iResolution.y; // size of a pixel\n    vec2 p = (fragCoord - vec2(0.25*iResolution.x,0.0))*e;\n    \n    p = -0.05 + (1.0+2.0*0.05)*p; // add margin of 0.05\n    \n    const int numPoints = 1<<(level<<1);\n    const float w = float((1<<level)-1); // distance between grid points\n\n    // compute distance field\n    float d = 2.0;\n    ivec2 o = ivec2(0,0);\n    for( int i=1; i<numPoints; i++ )\n    {\n        ivec2 m = curve(i);\n        \n        d = min( d, sdSqLine( p, vec2(m)/w, vec2(o)/w ) );\n        o = m;\n    }\n    d = sqrt(d);\n    \n    // colors\n    float f  = smoothstep(0.0,2.0*e,d); \n          f *= 0.8 + 0.2*sqrt(clamp(d/(8.0*e),0.0,1.0));\n    \n    fragColor = vec4( f, f, f, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}