{
    "Shader": {
        "info": {
            "date": "1477920471",
            "description": "An abstract representation of some terraced hills. In essence, just a very basic terrain layout with a small code footprint.",
            "flags": 0,
            "hasliked": 0,
            "id": "MtdSRn",
            "likes": 63,
            "name": "Terraced Hills",
            "published": 3,
            "tags": [
                "raymarching",
                "terrain",
                "abstract",
                "edges"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 2604
        },
        "renderpass": [
            {
                "code": "/*\n\n\tTerraced Hills\n\t--------------\n\n    This is an abstract representation of the terraced hills you see throughout various parts \n\tof the world. In essence, it's just a very basic terrain layout with some edging.\n\n\tI wanted to make something nice and simple. The code is reasonably compact, but without \n\tsacrificing too much in the way of efficiency or readability.\n\n*/\n\n// 2x2 matrix rotation. Angle vector, courtesy of Fabrice.\nmat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool.\nfloat tri(in float x){return abs(x-floor(x)-.5);} // Triangle function.\nvec2 tri(in vec2 x){return abs(x-floor(x)-.5);} // Triangle function.\n//vec2 tri(in vec2 x){return cos(x*6.2831853)*0.25+0.25;} // Smooth version. Not used here.\n\n// PF - phase variance. Varies between zero and 1. Zero is redundant, as it returns the triangle function.\n//vec2 trap(in vec2 x, float pf){ return (tri(x - pf*.125) + tri(x + pf*.125))*.5; } // Trapezoid function.\n\n// A simple noisey layer made up of a sawtooth combination.\nfloat hLyr(vec2 p) { return dot(tri(p/1.5 + tri(p.yx/3. + .25)), vec2(1)); }\n//float hLyr(vec2 p) { return dot(trap(p/1.5 + trap(p.yx/3. + .25, .5), .5), vec2(1)); }\n\n\n// I've mentioned this before, but you can make some pretty interesting surfaces simply by \n// combining mutations of a rudimentary functional layer. Take the base layer, then rotate, skew,\n// change frequency, amplitude, etc, and combine it with the previous layer. Continue ad infinitum...\n// or until your GPU makes you stop. :)\nfloat hMap(vec2 p) {\n    \n    float ret = 0., a = 1.;\n\n    // Combining three layers of the function above.\n    for(int i=0; i<3; i++) {\n        ret += abs(a)*hLyr(p/a); // Add a portion of the layer to the final result.\n        //p = rot2(1.5707963/3.)*p;\n        //p = mat2(.866025, .5, -.5, .866025)*p; // Rotate the layer only.\n        p = mat2(.866025, .57735, -.57735, .866025)*p; // Rotate and skew the layer.\n        a *= -0.3; // Multiplying the amplitude by a negative for an interesting variation.     \n    }\n\n    // Squaring and smoothing the result for some peakier peaks. Not mandatory.\n    ret = smoothstep(-.2, 1., ret*ret/1.39/1.39);\n    \n    \n    // The last term adds some ridges. Basically, you take the result then blend in a \n    // small periodic portion of it... The code explains it better.   \n    return ret*.975 + tri(ret*12.)*.05; // Range: [0, 1].. but I'd double check. :)\n    //return ret*.99 + clamp(cos((ret)*6.283*24.)*.5+.5, 0., 1.)*.01; // Another way.\n\n\n}\n\n// Distance function. A flat plane perturbed by a height function of some kind.\nfloat map(vec3 p) { return (p.y - hMap(p.xz)*.35)*.75; }\n\n\n// Tetrahedral normal - courtesy of IQ. I'm in saving mode, so am saving a few map calls.\n// I've added to the function to include a rough tetrahedral edge calculation.\nvec3 normal(in vec3 p, inout float edge){\n  \n    // Edging thickness. I wanted the edges to be resolution independent... or to put it\n    // another way, I wanted the lines to be a certain pixel width regardless of the \n    // canvas size. If you don't, then the lines can look too fat in fullscreen.\n    vec2 e = vec2(-1., 1.)*.5/iResolution.y;  \n    \n    // The hit point value, and four nearby samples, spaced out in a tetrahedral fashion.\n\tfloat d1 = map(p + e.yxx), d2 = map(p + e.xxy);\n\tfloat d3 = map(p + e.xyx), d4 = map(p + e.yyy); \n    float d = map(p);\n    \n    // Edge calculation. Taking for samples around the hit point and determining how\n    // much they vary. Large variances tend to indicate an edge.\n    edge = abs(d1 + d2 + d3 + d4 - d*4.);\n    edge = smoothstep(0., 1., sqrt(edge/e.y*2.));\n    \n    // Recalculating for the normal. I didn't want the sample spacing to change from\n    // one resolution to the next. Hence, the fixed number. Just for the record, I tend\n    // to work within the 800 by 450 window. \n    e = vec2(-1., 1.)*.001;  \n\td1 = map(p + e.yxx), d2 = map(p + e.xxy);\n\td3 = map(p + e.xyx), d4 = map(p + e.yyy); \n    \n    // Normalizing.\n\treturn normalize(e.yxx*d1 + e.xxy*d2 + e.xyx*d3 + e.yyy*d4 );   \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\t{\n\t\n\n    // Unit direction ray.\n\tvec3 rd = normalize(vec3(fragCoord.xy - iResolution.y*.5, iResolution.y));\n    \n    // Orienting to face a particular direction.\n    rd.yz = rot2(.35)*rd.yz;\n    \n    // Camera point - Placed above the plane and moving in the general XZ direction. \n    vec3 ro = vec3(iTime*.4, .5, iTime*.2);\n    \n    // Basic raymarching.\t\n\tfloat t=0., d;\n\tfor(int i=0; i<96; i++) {\n        \n\t\td = map(ro + rd*t); // Closest distance to current ray point.\n        \n        // Break condition - Surface hit, or too far.\n        if(abs(d)<.001*(t*.125 + 1.) || t>20.) break; \n\n        // Advancing the ray - Using a bit more accuracy nearer the camera.\n        t += (step(1., t)*.3 + .7)*d;\n\t}\n    \n    // Hit point. Note that about a quarter of the screen hits the curved far plane (sky),\n    // so a few cycles are wasted, but there's no nested code block, which looks a bit\n    // neater... I wouldn't do this for more sophisticated examples, but it's OK here.\n    vec3 sp = ro + rd*t;\n    \n    // Applying direct lighting. It's simpler, but it's more of an aesthetic choice for this\n    // particular example.\n    vec3 ld = vec3(-0.676, 0.408, 0.613); // Normalized, or pretty close.\n    \n\n    // Normal and edge value.\n    float edge;\n    vec3 n = normal(sp, edge);\n    \n    float dif = max(dot(ld, n), 0.); // Diffuse.\n    float spe = pow(max(dot(reflect(rd, n), ld), 0.), 16.); // Specular.\n\n    float sh = hMap(sp.xz); // Using the height map to enhance the peaks and troughs.\n    \n    // A bit of random, blocky sprinkling for the hills. Cheap, but it'll do.\n    float rnd = fract(sin(dot(floor(sp.xz*512.), vec2(41.73, 289.67)))*43758.5453)*.5 + .5;\n\n    // The fog. Since the foreground color is pretty bland, I've made it really colorful. I've gone\n    // for the sunset cliche... or misty morning sunrise, if you prefer. :)\n    vec3 fog = mix(vec3(.75,.77, .78), vec3(1.04, .95, .87), (pow(1.0 + dot(rd, ld), 3.))*.35);\n   \n    // Using the values above to produce the final color, then mixing in some fog according to distance.\n    vec3 c = mix((vec3(1.1, 1.05, 1)*rnd*(dif + .1)*sh + fog*spe)*(1. - edge*.7), fog*fog, min(1., t*.3));\n\n    // No gamma correction. If you wanted, you could think of it as postprocessing the final\n    // color and gamma correction rolled into one. :)\n    fragColor = vec4(c, 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}