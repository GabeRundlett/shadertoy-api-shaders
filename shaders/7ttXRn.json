{
    "Shader": {
        "info": {
            "date": "1639040907",
            "description": "SDF to render kyu190a",
            "flags": 0,
            "hasliked": 0,
            "id": "7ttXRn",
            "likes": 8,
            "name": "kyu190a",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "soma_arc",
            "viewed": 283
        },
        "renderpass": [
            {
                "code": "// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst vec3 BLACK = vec3(0);\nconst vec3 LIGHT_POS = vec3(100, 100, 100);\nconst vec3 LIGHT_DIR = normalize(LIGHT_POS);\nconst float AMBIENT_FACTOR = 0.1;\nconst int OBJ_PLANE = 0;\n\nconst float EPSILON = 0.001;\nconst float PI = 3.14159265;\nconst float PI_2 = 3.14159265 / 2.;\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 deGamma(vec3 rgb){\n  return vec3((min(pow(rgb.r, 2.2), 1.)),\n              (min(pow(rgb.g, 2.2), 1.)),\n              (min(pow(rgb.b, 2.2), 1.)));\n}\n\nmat3 getRotationX(float rotationDegrees) {\n    float thetaRad = radians(rotationDegrees);\n    float cosTheta = cos(thetaRad);\n    float sinTheta = sin(thetaRad);\n    return mat3(1, 0, 0,\n                0, cosTheta, -sinTheta,\n                0, sinTheta, cosTheta);\n}\n\nmat3 getRotationY(float rotationDegrees){\n    float thetaRad = radians(rotationDegrees);\n    float cosTheta = cos(thetaRad);\n    float sinTheta = sin(thetaRad);\n    return mat3(cosTheta, 0, sinTheta,\n                0, 1, 0,\n                -sinTheta, 0, cosTheta);\n}\n\nmat3 getRotationZ(float rotationDegrees){\n    float thetaRad = radians(rotationDegrees);\n    float cosTheta = cos(thetaRad);\n    float sinTheta = sin(thetaRad);\n    return mat3(cosTheta, -sinTheta, 0,\n                sinTheta, cosTheta, 0,\n                0, 0, 1);\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat distSphere(vec3 p, vec4 sphere){\n\treturn distance(p, sphere.xyz) - sphere.w;\n}\n\nfloat distPlane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat distEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat distTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat distVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat distCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nconst int OBJ_KYU_BODY = 1;\nconst int OBJ_KYU_EYE = 2;\nconst int OBJ_KYU_BROW = 3;\nconst int OBJ_KYU_MOUTH = 4;\nconst int OBJ_KYU_CHEEK = 5;\nconst int OBJ_KYU_ARM = 6;\nconst int OBJ_KYU_TAIL = 7;\n\nvec2 distKyuBrow(vec3 p) {\n    mat3 r1 = getRotationX(135.) * getRotationY(-70.) * getRotationZ(-30.);\n    mat3 r2 = getRotationX(135.) * getRotationY(70.) * getRotationZ(30.);\n    vec3 t1 = vec3(130, -260, -180);\n    vec3 t2 = vec3(-130, -260, -180);\n    return opUnion(vec2(distVerticalCapsule(r1 * (p + t1), 100., 20.),\n                   OBJ_KYU_BROW),\n                   vec2(distVerticalCapsule(r2 * (p + t2), 100., 20.),\n                   OBJ_KYU_BROW));\n}\n\nvec2 distKyuEye(vec3 p) {\n    mat3 r1 = getRotationX(40.) * getRotationZ(15.);\n    mat3 r2 = getRotationX(40.) * getRotationZ(-15.);\n    vec3 t1 = vec3(120, -200, -280);\n    vec3 t2 = vec3(-120, -200, -280);\n    return opUnion(vec2(distTorus(r1 * (p + t1), vec2(50, 20)),\n                   OBJ_KYU_EYE),\n                   vec2(distTorus(r2 * (p + t2), vec2(50, 20)),\n                   OBJ_KYU_EYE));\n}\n\nvec2 distKyuMouth(vec3 p){\n    mat3 r = getRotationX(30.) * getRotationZ(180.);\n    vec3 t1 = vec3(120 -70, -120, -350);\n    vec3 t2 = vec3(10  -70, -120, -350);\n    float an = radians(90.);\n    return opUnion(vec2(distCappedTorus(r * (p + t1), vec2(sin(an),cos(an)), 50., 20.),\n                        OBJ_KYU_MOUTH),\n                   vec2(distCappedTorus(r * (p + t2), vec2(sin(an),cos(an)), 50., 20.),\n                        OBJ_KYU_MOUTH));\n}\n\nvec2 distKyuCheek(vec3 p ) {\n    mat3 r1 = getRotationX(130.) * getRotationY(-40.) * getRotationZ(-20.);\n    mat3 r2 = getRotationX(130.) * getRotationY(40.) * getRotationZ(20.);\n    vec3 t1 = vec3(-260, -140, -280);\n    vec3 t2 = vec3(260, -140, -280);\n    return opUnion(vec2(distVerticalCapsule(r1 * (p + t1), 100., 20.),\n                   OBJ_KYU_BROW),\n                   vec2(distVerticalCapsule(r2 * (p + t2), 100., 20.),\n                   OBJ_KYU_BROW));\n}\n\nvec2 distKyuArm(vec3 p){\n    return opUnion(vec2(distEllipsoid(p + vec3(400, 0, -100),\n                                      vec3(100, 100, 200)),\n                   OBJ_KYU_ARM),\n                   vec2(distEllipsoid(p + vec3(-400, 0, -100),\n                                      vec3(100, 100, 200)),\n                   OBJ_KYU_ARM));\n}\n\nvec2 distKyuTail(vec3 p){\n    return vec2(distEllipsoid(p + vec3(0, 0, 500), \n                              vec3(200, 100, 200)),\n                OBJ_KYU_TAIL);\n}\n\nvec2 distKyu190a(vec3 p) {\n    vec2 d = vec2(distEllipsoid(p, vec3(500, 300, 400)), OBJ_KYU_BODY);\n    d = opUnion(d, distKyuEye(p));\n    d = opUnion(d, distKyuBrow(p));\n    d = opUnion(d, distKyuMouth(p));\n    d = opUnion(d, distKyuCheek(p));\n    d = opUnion(d, distKyuArm(p));\n    d = opUnion(d, distKyuTail(p));\n    return d;\n}\n\nvec3 getMatKyu190a(int objId) {\n    if(objId == OBJ_KYU_BODY){\n        return vec3(1);\n    } else if(objId == OBJ_KYU_EYE) {\n        return vec3(0);\n    } else if(objId == OBJ_KYU_BROW) {\n        return vec3(0);\n    } else if (objId== OBJ_KYU_MOUTH) {\n        return vec3(0);\n    } else if(objId == OBJ_KYU_CHEEK) {\n        return vec3(0);\n    } else if(objId == OBJ_KYU_ARM) {\n        return vec3(1);\n    } else if(objId == OBJ_KYU_TAIL) {\n        return vec3(1);\n    }\n}\n\nvec2 distFunc(vec3 p, float time) {\n\tvec2 d = vec2(distPlane(p, vec4(0, 1, 0, 300)), OBJ_PLANE);\n    d = opUnion(d, distKyu190a(p + vec3(0,-200. + -400. * sin(iTime) * sin(iTime), 0)));\n    return d;\n}\n\nconst vec2 NORMAL_COEFF = vec2(1., 0.);\nvec3 computeNormal(const vec3 p, const float t){\n  return normalize(vec3(distFunc(p + NORMAL_COEFF.xyy, t).x - distFunc(p - NORMAL_COEFF.xyy, t).x,\n                        distFunc(p + NORMAL_COEFF.yxy, t).x - distFunc(p - NORMAL_COEFF.yxy, t).x,\n                        distFunc(p + NORMAL_COEFF.yyx, t).x - distFunc(p - NORMAL_COEFF.yyx, t).x));\n}\n\nconst int MAX_MARCH = 500;\nint march (vec3 rayOrg, vec3 rayDir, float time, inout float minDist,\n           float maxDist,\n           inout vec3 intersection, inout vec3 normal) {\n    vec3 rayPos = rayOrg + minDist * rayDir;\n    vec2 dist = vec2(-1);\n    float rayLength = 0.;\n    for(int i = 0 ; i < MAX_MARCH ; i++){\n        if(rayLength > maxDist) return -1;\n        dist = distFunc(rayPos, time);\n        rayLength += dist.x;\n        rayPos = rayOrg + rayDir * rayLength;\n        if(dist.x < EPSILON){\n            int objId = int(dist.y);\n            intersection = rayPos;\n            normal = computeNormal(intersection, time);\n            minDist = rayLength;\n            return objId;\n        }\n    }\n    return -1;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 xaxis = normalize(cross(v, up));\n  vec3 yaxis =  normalize(cross(v, xaxis));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nvec3 getMatColor(int objId, vec3 normal, vec3 intersection){\n    if(objId == OBJ_PLANE){\n        vec2 p = fract(intersection.xz / iChannelResolution[0].xy);\n        vec3 col = deGamma(texture(iChannel0, p).rgb);\n        return mix(col, vec3(0.7, 0.8, 1.), 0.); \n    }else if(objId != -1){\n        return getMatKyu190a(objId);\n    }\n\treturn BLACK;\n}\n\nvec3 sky(vec3 rayDir){\n\treturn clamp(vec3(.7, .8, 1.) + exp(dot(rayDir, LIGHT_DIR))*0.1, 0.0, 1.0);\n}\n\nfloat computeShadowFactor (vec3 rayOrg, vec3 rayDir,\n                           float mint, float maxt, float k) {\n    float shadowFactor = 1.0;\n    for(float t = mint ; t < maxt ;){\n        float d = distFunc(rayOrg + rayDir * t, 0.).x;\n        if(d < EPSILON) break;\n\n        shadowFactor = min(shadowFactor, k * d / t);\n        t += d;\n    }\n    return clamp(shadowFactor, 0.0, 1.0);\n}\n\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    return pow(clamp(dot(reflect(e,n),l),0.0, 1.),s);\n}\n\n// p: center of the plane\n// n: normal of the plane\nbool intersectPlane(vec3 p, vec3 n, \n                    vec3 rayOrigin, vec3 rayDir,\n                     inout float minDist,\n                    inout vec3 intersection, inout vec3 normal){\n    float d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(EPSILON < t && t < minDist){\n\t\tintersection = rayOrigin + t * rayDir;\n        normal = n;\n        minDist = t;\n        return true;\n    }\n    return false;\n}\n\n\nbool intersectSphere(vec3 sphereCenter, float radius, \n                     vec3 rayOrigin, vec3 rayDir, \n                     inout float minDist,\n                     inout vec3 intersection, inout vec3 normal){\n  \tvec3 v = rayOrigin - sphereCenter;\n  \tfloat b = dot(rayDir, v);\n  \tfloat c = dot(v, v) - radius * radius;\n  \tfloat d = b * b - c;\n  \tif(d >= 0.){\n    \tfloat s = sqrt(d);\n    \tfloat t = -b - s;\n    \tif(t <= EPSILON) t = -b + s;\n    \tif(EPSILON < t && t < minDist){\n      \t\tintersection = (rayOrigin + t * rayDir);\n      \t\tminDist = t;\n            normal = normalize(intersection - sphereCenter);\n      \t\treturn true;\n    \t}\n  \t}\n  \treturn false;\n}\n\nbool intersectBox(vec3 rayOrg, vec3 rayDir, vec3 boxMin, vec3 boxMax,\n                  out float hit0, out float hit1) {\n\tfloat t0 = -10000.0, t1 = 10000.0;\n    hit0 = t0;\n    hit1 = t1;\n    \n    vec3 tNear = (boxMin - rayOrg) / rayDir;\n    vec3 tFar  = (boxMax - rayOrg) / rayDir;\n    \n    if (tNear.x > tFar.x) {\n        float tmp = tNear.x;\n        tNear.x = tFar.x;\n        tFar.x = tmp;\n    }\n    t0 = max(tNear.x, t0);\n    t1 = min(tFar.x, t1);\n\n    if (tNear.y > tFar.y) {\n        float tmp = tNear.y;\n        tNear.y = tFar.y;\n        tFar.y = tmp;\n    }\n    t0 = max(tNear.y, t0);\n    t1 = min(tFar.y, t1);\n\n    if (tNear.z > tFar.z) {\n        float tmp = tNear.z;\n        tNear.z = tFar.z;\n        tFar.z = tmp;\n    }\n    t0 = max(tNear.z, t0);\n    t1 = min(tFar.z, t1);\n\n    if (t0 <= t1) {\n        hit0 = t0;\n        hit1 = t1;\n        return true;\n    }\n    return false;\n}\n\n\nvec3 calcColor(float time, vec3 eye, vec3 ray){\n  \tvec3 l = BLACK;\n\n    float t = 999999.;\n    vec3 intersection, normal;\n    int objId = -1;\n    float t0, t1;\n    bool hitPlane = false;\n    \n    bool hitBox = intersectBox(eye, ray, \n                               vec3(-700, 0, -800), \n                               vec3(700, 900, 500),\n                               t0, t1);\n    if(hitBox){\n        objId = march(eye, ray, time, t0, t1,\n                      intersection, normal);\n    }\n    if(objId < 1){\n        hitPlane = intersectPlane(vec3(0, -100, 0), \n                                  vec3(0, 1, 0), \n                                  eye, ray, t,\n                       intersection, normal);\n        if(hitPlane) objId = OBJ_PLANE;\n    } else {\n        t = t0;\n    }\n    if(objId != -1){\n        vec3 matColor = BLACK;\n        matColor = getMatColor(objId, normal, intersection);\n        float k = computeShadowFactor(intersection + normal, LIGHT_DIR,\n                                      0., 1000., 5.);\n        vec3 diffuse =  clamp(dot(normal, LIGHT_DIR), 0., 1.) * matColor;\n        vec3 ambient = matColor * AMBIENT_FACTOR;\n        l += k * diffuse + ambient;\n    } else {\n        l = sky(ray);\n    }\n\n    l = mix( sky(ray), l, exp( -0.000000009*t * t ) );\n\n  \treturn l;\n}\n\n\nconst vec3 target = vec3(0, 300, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nconst float SAMPLE_NUM = 5.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 eye = vec3(900. * sin(iTime) , 1000., \n                    900. * cos(iTime) );\n  \tvec3 sum = vec3(0);\n    float t = iTime;\n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n          \n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n          \n    \tsum += calcColor(t, eye, ray);\n  \t}\n \tvec3 col = (sum/SAMPLE_NUM);\n  \n    \n  \tfragColor = vec4(gammaCorrect(col), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}