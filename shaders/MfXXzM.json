{
    "Shader": {
        "info": {
            "date": "1705050922",
            "description": "My implementation of https://www.realtimerendering.com/raytracing/Ray%20Tracing%20in%20a%20Weekend.pdf\nAnd... I dont know how to implement direct light sampling and ray marching into this renderer",
            "flags": 32,
            "hasliked": 0,
            "id": "MfXXzM",
            "likes": 19,
            "name": "RIOW but with Disney BSDF",
            "published": 3,
            "tags": [
                "3d",
                "raytracing"
            ],
            "usePreview": 1,
            "username": "Nguyen2007",
            "viewed": 948
        },
        "renderpass": [
            {
                "code": "/* Inspired by reinder RIOW inplementation (remove classes),\n   and knightcrawler25's \"GLSL-PathTracer\": https://github.com/knightcrawler25/GLSL-PathTracer\n   Sky texture by fgarlin: https://www.shadertoy.com/view/msXXDS\n   Change scene in Common */\n\n// ACES Cinematic Tonemapping by afl_ext: https://www.shadertoy.com/view/XsGfWV\n\nvec3 tonemap(vec3 c)\n{\t\n\tc *= mat3(.59719, .35458, .04823,\n              .076  , .90834, .01566,\n              .0284 , .13383, .83777);\n    \n    c = (c * (c + .0245786) - .000090537) / (c * (.983729 * c + .432951) + .238081);\n\t\n    return c * mat3(1.60475, -.53108, -.07367,\n                    -.10208, 1.10813, -.00605,\n                    -.00327, -.07276, 1.07602);\t\n}\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    O = vec4(pow(tonemap(texture(iChannel0, I / R.xy).xyz), vec3(.4545)), 1);\n    //O = sqrt(texture(iChannel0, I / R.xy));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SPHERES 1\n#define CORNELL 2\n#define TESTALL 3\n\n#define SCENE 2\n#define SKYTYPE 0 // 0: No sky, 1: Sky used in RIOW, 2: Physically-based Sky\n#define USE_MIS\n\n//#define RUSSIAN_ROULETE\n\n#define ZERO min(0, iFrame)\n\n#define R iResolution\n\nconst float TAU    = 6.28318530717958647693,\n            PI     = 3.14159265358979323846,\n            INVPI  =  .31830988618379067154,\n            INV4PI =  .07957747154594766788;\n\nfloat sqr(float x) { return x * x; }\nfloat dot2(vec2 x) { return dot(x, x); }\nfloat dot2(vec3 x) { return dot(x, x); }\n\n#define translate(p) mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -(p), 1)\n\nmat4 rotateX(float a)\n{\n    float s = sin(a), c = cos(a);\n\n    return mat4(1, 0,  0, 0,\n                0, c, -s, 0,\n                0, s,  c, 0,\n\t\t\t    0, 0,  0, 1);\n}\n\nmat4 rotateY(float a)\n{\n    float s = sin(a), c = cos(a);\n\n    return mat4( c, 0, s, 0,\n                 0, 1, 0, 0,\n                -s, 0, c, 0,\n\t\t\t     0, 0, 0, 1);\n}\n\nmat4 rotateZ(float a)\n{\n    float s = sin(a), c = cos(a);\n\n    return mat4(c, -s, 0, 0,\n                s,  c, 0, 0,\n                0,  0, 1, 0,\n\t\t\t    0,  0, 0, 1);\n}\n\nconst mat4 noTransform = mat4(1);\n\nfloat deNaN (float v)\n{\n    return v != v ? 0. : v;\n}\n\nvec3 deNaN(vec3 v)\n{\n    return vec3(deNaN(v.x), deNaN(v.y), deNaN(v.z));\n}\n\nstruct ray\n{\n    vec3 o, d;\n};\n\nstruct material\n{\n    vec3 baseColor, emission;\n    \n    float anisotropic,\n          metallic,\n          roughness,\n          subsurface,\n          specularTint,\n          sheen,\n          sheenTint,\n          clearcoat,\n          clearcoatRoughness,\n          specTrans,\n          IOR, ax, ay;\n};\n\nconst material initMat = material(vec3(0), vec3(0), 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0.);\n\nstruct hitRecord\n{\n    float eta, t;\n    vec3 p, n;\n    material mat;\n    bool isVolume;\n    int lightID;\n};\n\nstruct cam\n{\n    vec3 o, llc, hor, ver, u, v, w;\n    float rad;\n};\n\nuvec4 seed;\n\nvec4 PCG(inout uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n    \n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n    \n    v ^= v >> 16u;\n    \n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n    \n    return vec4(v) / 4294967296.;\n}\n\n#define rand  rand4.x\n#define rand2 rand4.xy\n#define rand3 rand4.xyz\n#define rand4 PCG(seed)\n\n\nvec4 hash4(vec4 p)\n{\n\tuvec4 v = floatBitsToUint(p);\n    return PCG(v);\n}\n\nvec4 hash4(float v) {return hash4(vec4(v));}\nvec4 hash4(vec2 v)  {return hash4(v.xyxy);}\nvec4 hash4(vec3 v)  {return hash4(v.xyzx);}\n\n#define hash(v)  hash4(v).x\n#define hash2(v) hash4(v).xy\n#define hash3(v) hash4(v).xyz\n\n#define toWorld(x, y, z, v) mat3(x, y, z) * (v)\n#define toLocal(x, y, z, v) (v) * mat3(x, y, z)\n\nvec2 ranDir()\n{\n    float phi = TAU * rand;\n    return vec2(cos(phi), sin(phi));\n}\n\n#define ranDisk() sqrt(rand) * ranDir()\n\n// Sampling Functions\n\nfloat GTR1(float NoH, float a)\n{\n    if (a >= 1.) return INVPI;\n    float a2 = a * a;\n    return (a2 - 1.) / (PI * log(a2) * (1. + (a2 - 1.) * NoH * NoH));\n}\n\nvec3 sampleGTR1(float a)\n{\n    float a2 = a * a;\n\n    float cos2T = (1. - pow(a2, rand)) / (1. - a2);\n\n    return vec3(sqrt(1. - cos2T) * ranDir(), sqrt(cos2T));\n}\n\nvec3 sampleGGXVNDF(vec3 V, float ax, float ay)\n{\n    V = normalize(vec3(ax * V.x, ay * V.y, V.z));\n    \n    vec2 t   = ranDisk();\n         t.y = mix(sqrt(1. - t.x * t.x), t.y, .5 + .5 * V.z);\n    \n    float l2 = dot2(V.xy);\n    \n    vec3 T1 = l2 > 0. ? vec3(-V.y, V.x, 0) * inversesqrt(l2) : vec3(1, 0, 0),\n         T2 = cross(V, T1),\n         N  = mat3(T1, T2, V) * vec3(t, sqrt(1. - dot2(t)));\n\n    return normalize(vec3(ax * N.x, ay * N.y, max(0., N.z)));\n}\n\nfloat GTR2Aniso(float NoH, float HoX, float HoY, float ax, float ay)\n{\n    return INVPI / (ax * ay * sqr(dot2(vec3(HoX / ax, HoY / ay, NoH))));\n}\n\nfloat smithG(float NoV, float alphaG)\n{\n    float a = alphaG * alphaG,\n          b = NoV * NoV;\n    \n    return 2. * NoV / (NoV + sqrt(a + b - a * b));\n}\n\nfloat smithGAniso(float NoV, float VoX, float VoY, float ax, float ay)\n{\n    float a = VoX * ax,\n          b = VoY * ay,\n          c = NoV;\n    \n    return 2. * NoV / (NoV + sqrt(a * a + b * b + c * c));\n}\n\nfloat schlickWeight(float u)\n{\n    float m = min(1. - u, 1.),\n          m2 = m * m;\n    \n    return m2 * m2 * m;\n}\n\nfloat fresnel(float cosI, float eta)\n{\n    cosI = abs(cosI);\n    float cosT = (1. - cosI * cosI) * eta * eta;\n\n    if (cosT >= 1.) return 1.;\n\n    cosT = sqrt(1. - cosT);\n\n    return (sqr(.5 - cosI / (eta * cosT + cosI))\n          + sqr(.5 - cosT / (eta * cosI + cosT))) * 2.;\n}\n\nfloat dielectricFresnel(float cosI, float eta)\n{\n    float sin2T = eta * eta * (1. - cosI * cosI);\n\n    // Total internal reflection\n    \n    if (sin2T > 1.) return 1.;\n\n    float cosT = sqrt(1. - sin2T);\n\n    float rs = (eta * cosT - cosI) / (eta * cosT + cosI),\n          rp = (eta * cosI - cosT) / (eta * cosI + cosT);\n\n    return .5 * (rs * rs + rp * rp);\n}\n\nvec3 ranCos()\n{\n    float r = rand;\n    return vec3(sqrt(r) * ranDir(), sqrt(1. - r));\n}\n\nvec3 ranSph()\n{\n    float h = rand * 2. - 1.;\n\treturn vec3(sqrt(1. - h * h) * ranDir(), h);\n}\n\nvec3 ranHemi(vec3 n)\n{\n    vec3 d = ranSph();\n    return d * sign(dot(d, n));\n}\n\nvoid onb(vec3 N, out vec3 T, out vec3 B) \n{\n    float s = N.z > 0. ? 1. : -1.,\n          a = s + N.z,\n          b = -N.x * N.y / a;\n    \n    T = s * vec3(s - N.x * N.x / a, b, -N.x);\n    B =     vec3(b, s - N.y * N.y / a, -N.y);\n}\n\n// Disney BSDF\n\n#define luma(v) dot(v, vec3(.3, .6, .1))\n\nvoid tint(material mat, float eta, out float F0, out vec3 Csheen, out vec3 Cspec)\n{\n    float lum = luma(mat.baseColor);\n    vec3 tint = lum > 0. ? mat.baseColor / lum : vec3(1);\n\n    F0 = sqr((1. - eta) / (1. + eta));\n    \n    Cspec  = mix(vec3(1), tint, mat.specularTint) * F0;\n    Csheen = mix(vec3(1), tint, mat.sheenTint);\n}\n\nvec3 diffuse(material mat, vec3 Csheen, vec3 V, vec3 L, vec3 H, out float pdf)\n{\n    float LoH = dot(L, H),\n          Rr  = 2. * mat.roughness * LoH * LoH,\n\n    // Diffuse\n    \n    FL     = schlickWeight(L.z),\n    FV     = schlickWeight(V.z),\n    Fretro = Rr * (FL + FV + FL * FV * (Rr - 1.)),\n    Fd     = (1. - .5 * FL) * (1. - .5 * FV),\n\n    // Fake subsurface\n    \n    Fss90 = .5 * Rr,\n    Fss   = mix(1., Fss90, FL) * mix(1., Fss90, FV),\n    ss    = 1.25 * (Fss * (1. / (L.z + V.z) - .5) + .5);\n\n    // Sheen\n    \n    vec3 Fsheen = schlickWeight(LoH) * mat.sheen * Csheen;\n\n    pdf = L.z * INVPI;\n    \n    return INVPI * mat.baseColor * mix(Fd + Fretro, ss, mat.subsurface) + Fsheen;\n}\n\nvec3 reflection(material mat, vec3 V, vec3 L, vec3 H, vec3 F, out float pdf)\n{\n    float D  = GTR2Aniso(H.z, H.x, H.y, mat.ax, mat.ay),\n          G1 = smithGAniso(abs(V.z), V.x, V.y, mat.ax, mat.ay),\n          G2 = smithGAniso(abs(L.z), L.x, L.y, mat.ax, mat.ay) * G1;\n\n    pdf = .25 * G1 * D / V.z;\n    \n    return F * D * G2 / (4. * L.z * V.z);\n}\n\nvec3 refraction(material mat, float eta, vec3 V, vec3 L, vec3 H, vec3 F, out float pdf)\n{\n    float LoH = dot(L, H), VoH = dot(V, H),\n\n    D  = GTR2Aniso(H.z, H.x, H.y, mat.ax, mat.ay),\n    G1 = smithGAniso(abs(V.z), V.x, V.y, mat.ax, mat.ay),\n    G2 = smithGAniso(abs(L.z), L.x, L.y, mat.ax, mat.ay) * G1;\n    \n    float jacobian = abs(LoH) / sqr(LoH + VoH * eta);\n\n    pdf = G1 * max(0., VoH) * D * jacobian / V.z;\n    \n    return sqrt(mat.baseColor) * (1. - F) * D * G2 * abs(VoH) * jacobian * eta * eta / abs(L.z * V.z);\n}\n\nfloat clearcoat(material mat, vec3 V, vec3 L, vec3 H, out float pdf)\n{\n    float VoH = dot(V, H),\n\n    F = mix(.04, 1., schlickWeight(VoH)),\n    D = GTR1(H.z, mat.clearcoatRoughness),\n    G = smithG(L.z, .25) * smithG(V.z, .25);\n\n    pdf = .25 * D * H.z / VoH;\n    \n    return F * D * G;\n}\n\nvec3 DisneyBSDF(hitRecord rec, vec3 V, vec3 N, vec3 L, out float pdf)\n{\n    if(rec.isVolume)\n    {\n        pdf = INV4PI;\n        return rec.mat.baseColor * INV4PI;\n    }\n    \n    float aspect = sqrt(1. - rec.mat.anisotropic * .9);\n    rec.mat.ax = max(.001, rec.mat.roughness / aspect);\n    rec.mat.ay = max(.001, rec.mat.roughness * aspect);\n    \n    pdf = 0.;\n    vec3 f = vec3(0);\n\n    vec3 T, B;\n    onb(N, T, B);\n\n    V = toLocal(T, B, N, V);\n    L = toLocal(T, B, N, L);\n\n    vec3 H = normalize(L.z > 0. ? L + V : L + V * rec.eta);\n\n    if (H.z < 0.) H = -H;\n\n    // Tint colors\n    \n    vec3 Csheen, Cspec;\n    float F0;\n    tint(rec.mat, rec.eta, F0, Csheen, Cspec);\n\n    // Model weights\n    \n    float dielectricW = (1. - rec.mat.metallic) * (1. - rec.mat.specTrans);\n    float metalW      = rec.mat.metallic;\n    float glassW      = (1. - rec.mat.metallic) * rec.mat.specTrans;\n\n    // Lobe probabilities\n    \n    float schlickW = schlickWeight(V.z);\n\n    float diffP       = dielectricW * luma(rec.mat.baseColor);\n    float dielectricP = dielectricW * mix(luma(Cspec), 1., schlickW);\n    float metalP      = metalW * mix(luma(rec.mat.baseColor), 1., schlickW);\n    float glassP      = glassW;\n    float clearCoatP  = .25 * rec.mat.clearcoat;\n\n    // Normalize probabilities\n    \n    float norm = 1. / (diffP + dielectricP + metalP + glassP + clearCoatP);\n    \n    diffP       *= norm;\n    dielectricP *= norm;\n    metalP      *= norm;\n    glassP      *= norm;\n    clearCoatP  *= norm;\n\n    bool reflect = L.z > 0.;\n\n    float tmpPdf = 0.;\n    float VoH = abs(dot(V, H));\n\n    // Diffuse\n    if (diffP > 0. && reflect)\n    {\n        f += diffuse(rec.mat, Csheen, V, L, H, tmpPdf) * dielectricW;\n        pdf += tmpPdf * diffP;\n    }\n\n    // Dielectric Reflection\n    if (dielectricP > 0. && reflect)\n    {\n        float F = (dielectricFresnel(VoH, 1. / rec.eta) - F0) / (1. - F0);\n\n        f += reflection(rec.mat, V, L, H, mix(Cspec, vec3(1), F), tmpPdf) * dielectricW;\n        pdf += tmpPdf * dielectricP;\n    }\n\n    // Metallic Reflection\n    if (metalP > 0.0 && reflect)\n    {\n        // Tinted to base color\n        vec3 F = mix(rec.mat.baseColor, vec3(1), schlickWeight(VoH));\n\n        f += reflection(rec.mat, V, L, H, F, tmpPdf) * metalW;\n        pdf += tmpPdf * metalP;\n    }\n\n    // Glass/Specular BSDF\n    if (glassP > 0.0)\n    {\n        // Dielectric fresnel (achromatic)\n        float F = dielectricFresnel(VoH, rec.eta);\n\n        if (reflect)\n        {\n            f += reflection(rec.mat, V, L, H, vec3(F), tmpPdf) * glassW;\n            pdf += tmpPdf * glassP * F;\n        }\n        else\n        {\n            f += refraction(rec.mat, rec.eta, V, L, H, vec3(F), tmpPdf) * glassW;\n            pdf += tmpPdf * glassP * (1. - F);\n        }\n    }\n\n    // Clearcoat\n    if (clearCoatP > 0. && reflect)\n    {\n        f += clearcoat(rec.mat, V, L, H, tmpPdf) * .25 * rec.mat.clearcoat;\n        pdf += tmpPdf * clearCoatP;\n    }\n\n    return f * abs(L.z);\n}\n\nvec3 DisneySample(hitRecord rec, vec3 V, out vec3 L, out float pdf)\n{\n    if(rec.isVolume)\n    {\n        L = ranSph();\n        pdf = INV4PI;\n        return rec.mat.baseColor * INV4PI;\n    }\n    \n    float aspect = sqrt(1. - rec.mat.anisotropic * .9);\n    rec.mat.ax = max(.001, rec.mat.roughness / aspect);\n    rec.mat.ay = max(.001, rec.mat.roughness * aspect);\n    \n    pdf = 0.;\n\n    vec3 N = rec.n, T, B;\n    onb(N, T, B);\n\n    V = toLocal(T, B, N, V);\n\n    // Tint colors\n    vec3 Csheen, Cspec;\n    float F0;\n    tint(rec.mat, rec.eta, F0, Csheen, Cspec);\n\n    // Model weights\n    float dielectricW = (1. - rec.mat.metallic) * (1. - rec.mat.specTrans);\n    float metalW      = rec.mat.metallic;\n    float glassW      = (1. - rec.mat.metallic) * rec.mat.specTrans;\n\n    // Lobe probabilities\n    float schlick = schlickWeight(V.z);\n\n    float diffP       = dielectricW * luma(rec.mat.baseColor);\n    float dielectricP = dielectricW * mix(luma(Cspec), 1., schlick);\n    float metalP      = metalW * mix(luma(rec.mat.baseColor), 1., schlick);\n    float glassP      = glassW;\n    float clearCoatP  = .25 * rec.mat.clearcoat;\n\n    // Normalize probabilities\n    float norm = 1. / (diffP + dielectricP + metalP + glassP + clearCoatP);\n    diffP *= norm;\n    dielectricP *= norm;\n    metalP *= norm;\n    glassP *= norm;\n    clearCoatP *= norm;\n\n    // CDF of the sampling probabilities\n    vec3 cdf;\n    cdf.x = diffP;\n    cdf.y = cdf.x + dielectricP + metalP;\n    cdf.z = cdf.y + glassP;\n\n    // Sample a lobe based on its importance\n    float r = rand;\n    \n    if (r < cdf.x) // Diffuse\n    {\n        L = ranCos();\n    }\n    else if (r < cdf.y) // Dielectric + Metallic reflection\n    {\n        vec3 H = sampleGGXVNDF(V, rec.mat.ax, rec.mat.ay);\n        L = reflect(-V, H);\n    }\n    else if (r < cdf.z) // Glass\n    {\n        vec3 H = sampleGGXVNDF(V, rec.mat.ax, rec.mat.ay);\n        \n        float F = dielectricFresnel(abs(dot(V, H)), rec.eta);\n        \n        L = rand < F ? reflect(-V, H) : refract(-V, H, rec.eta);\n    }\n    else // Clearcoat\n    {\n        vec3 H = sampleGTR1(rec.mat.clearcoatRoughness);\n\n        L = reflect(-V, H);\n    }\n\n    L = toWorld(T, B, N, L);\n    V = toWorld(T, B, N, V);\n\n    return DisneyBSDF(rec, V, N, L, pdf);\n}\n\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x), f = smoothstep(0., 1., fract(x));\n\t\n    return mix(mix(mix(hash(p                ), \n                       hash(p + vec3(1, 0, 0)), f.x),\n                   mix(hash(p + vec3(0, 1, 0)), \n                       hash(p + vec3(1, 1, 0)), f.x), f.y),\n               mix(mix(hash(p + vec3(0, 0, 1)), \n                       hash(p + vec3(1, 0, 1)), f.x),\n                   mix(hash(p + vec3(0, 1, 1)), \n                       hash(p +            1.), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p, int o)\n{\n    float a = 0., w = 1.;\n     \n    for (int i = 0; i < o; i++)\n    {\n        w *= .5;\n        a += w * noise(p);\n        p *= 2.;\n    }\n    return a;\n}\n\nconst vec4  groundAlbedo         = vec4(0.3);\n// Ray marching steps. More steps mean better accuracy but worse performance\nconst int TRANSMITTANCE_STEPS     = 32;\nconst int IN_SCATTERING_STEPS     = 32;\n\n//-----------------------------------------------------------------------------\n// Constants\n\n// All parameters that depend on wavelength (vec4) are sampled at\n// 630, 560, 490, 430 nanometers\n\nconst float g = 0.8;\n\nconst float groundRadius        = 6371.; // km\nconst float atmosphereThickness = 1e2;   // km\nconst float atmosphereRadius    = groundRadius + atmosphereThickness;\nconst vec3 viewPos = vec3(0, 0, 6371.5);\nconst vec3 sunDir = normalize(vec3(-8, 4, .1));\n\nconst vec4 sun_spectral_irradiance = vec4(1.679, 1.828, 1.986, 1.307);\nconst vec4 molecular_scattering_coefficient_base = vec4(6.605e-3, 1.067e-2, 1.842e-2, 3.156e-2);\nconst vec4 ozone_absorption_cross_section = vec4(3.472e-25, 3.914e-25, 1.349e-25, 1.103e-26);\n\nconst float ozoneMean = 3e2;\n\nconst vec4 aerosol_absorption_cross_section = vec4(2.8722e-24, 4.6168e-24, 7.9706e-24, 1.3578e-23);\nconst vec4 aerosol_scattering_cross_section = vec4(1.5908e-22, 1.7711e-22, 2.0942e-22, 2.4033e-22);\nconst float aerosol_base_density = 1.3681e20;\nconst float aerosol_background_density = 2e6;\nconst float aerosol_height_scale = 0.73;\n\n//-----------------------------------------------------------------------------\n\nfloat iSphere(vec3 ro, vec3 rd, float rad)\n{\n    float b = dot(ro, rd),\n          d = rad * rad - dot2(ro - b * rd);\n    \n    if (d < 0.) return -1.;\n    \n    return d > b * b ? -b + sqrt(d) : -b - sqrt(d);\n}\n\n/*\n * Rayleigh phase function.\n */\nfloat molecular_phase_function(float cosTheta)\n{\n    return .75 * INV4PI * (1. + cosTheta * cosTheta);\n}\n\n/*\n * Henyey-Greenstrein phase function.\n */\nfloat aerosol_phase_function(float cosTheta)\n{\n    float gg  = g * g,\n          den = 1. + gg + 2. * g * cosTheta;\n    \n    return INV4PI * (1. - gg) / den / sqrt(den);\n}\n\n/*\n * Return the molecular volume scattering coefficient (km^-1) for a given altitude\n * in kilometers.\n */\nvec4 get_molecular_scattering_coefficient(float h)\n{\n    return molecular_scattering_coefficient_base / exp(.07771971 * pow(h, 1.16364243));\n}\n\n/*\n * Return the molecular volume absorption coefficient (km^-1) for a given altitude\n * in kilometers.\n */\nvec4 get_molecular_absorption_coefficient(float h)\n{\n    h += 1e-4;\n    float density = 3.78547397e20 / h / exp(sqr(log(h) - 3.22261) * 5.55555555);\n    return ozone_absorption_cross_section * ozoneMean * density;\n}\n\nfloat get_aerosol_density(float h)\n{\n    return aerosol_base_density / exp(h / aerosol_height_scale) + aerosol_background_density;\n}\n\n/*\n * Get the collision coefficients (scattering and absorption) of the\n * atmospheric medium for a given point at an altitude h.\n */\nvoid get_atmosphere_collision_coefficients(float h,\n                                           out vec4 aerosol_absorption,\n                                           out vec4 aerosol_scattering,\n                                           out vec4 molecular_absorption,\n                                           out vec4 molecular_scattering,\n                                           out vec4 extinction)\n{\n    h = max(h, 0.); // In case height is negative\n    \n    float aerosol_density = get_aerosol_density(h);\n    aerosol_absorption = aerosol_absorption_cross_section * aerosol_density;\n    aerosol_scattering = aerosol_scattering_cross_section * aerosol_density;\n    \n    molecular_absorption = get_molecular_absorption_coefficient(h);\n    molecular_scattering = get_molecular_scattering_coefficient(h);\n    extinction = aerosol_absorption + aerosol_scattering + molecular_absorption + molecular_scattering;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*\n * Buffer A: Transmittance LUT\n *\n * In this buffer we precompute the transmittance to the top of the atmosphere.\n * We use the same technique as in \"Precomputed Atmospheric Scattering\"\n * by Eric Bruneton and Fabrice Neyret (2008).\n */\n\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    I /= R.xy;\n\n    float cosTheta = I.x * 2. - 1.;\n\n    vec3 ro = vec3(0, 0, groundRadius + atmosphereThickness * I.y);\n    vec3 rd = vec3(-sqrt(1. - cosTheta * cosTheta), 0, cosTheta);\n\n    float tmax = iSphere(ro, rd, atmosphereRadius);\n    float dt = tmax / float(TRANSMITTANCE_STEPS);\n\n    O = vec4(0);\n    \n    vec3 pos = ro;\n\n    for (int i = 0; i < TRANSMITTANCE_STEPS; i++)\n    {\n        vec4 aerosol_absorption, aerosol_scattering,\n             molecular_absorption, molecular_scattering,\n             extinction;\n        \n        get_atmosphere_collision_coefficients(\n            length(pos) - groundRadius,\n            aerosol_absorption, aerosol_scattering,\n            molecular_absorption, molecular_scattering,\n            extinction);\n\n        O += extinction;\n        \n        pos += rd * dt;\n    }\n\n    O = exp(-O * dt);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n * Buffer B: Sky texture\n *\n * \"A Scalable and Production Ready Sky and Atmosphere Rendering Technique\"\n * by Sébastien Hillaire (2020).\n *\n * We render the sky to a texture instead of raymarching on the entire screen.\n * This is not very useful in Shadertoy, but very useful for someone looking\n * to implement this on a real application.\n *\n * It is important to note that quality decreases significantly when rendering\n * space views. To avoid this, the compute_inscattering() function can be used\n * directly when rendering to a fullscreen quad.\n */\n\nvec4 LUT(float cosTheta, float normalized_altitude)\n{\n    return texture(iChannel0, vec2(cosTheta * .5 + .5, normalized_altitude));\n}\n\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    I /= R.xy;\n\n    float azimuth = TAU * I.x;\n\n    // Apply a non-linear transformation to the elevation to dedicate more\n    // texels to the horizon, where having more detail matters.\n    float l = I.y - .5;\n    float elev = l * abs(l) * TAU; // [-pi/2, pi/2]\n\n    vec3 rd = vec3(cos(elev) * vec2(cos(azimuth), sin(azimuth)), sin(elev));\n\n    vec3 ro = viewPos;\n\n    float atmos_dist  = iSphere(ro, rd, atmosphereRadius);\n    float ground_dist = iSphere(ro, rd, groundRadius);\n    float t_d;\n    \n    // We are inside the atmosphere\n    if (ground_dist < 0.0) {\n        // No ground collision, use the distance to the outer atmosphere\n        t_d = atmos_dist;\n    } else {\n        // We have a collision with the ground, use the distance to it\n        t_d = ground_dist;\n    }\n\n    float cosTheta = dot(-rd, sunDir);\n\n    float molecular_phase = molecular_phase_function(cosTheta);\n    float aerosol_phase = aerosol_phase_function(cosTheta);\n\n    float dt = t_d / float(IN_SCATTERING_STEPS);\n\n    vec4 L = vec4(0),\n         transmittance = vec4(1);\n    \n    vec3 pos = ro;\n    \n    for (int i = 0; i < IN_SCATTERING_STEPS; ++i)\n    {\n        float d = length(pos);\n        vec3 zenith_dir = pos / d;\n        float altitude = d - groundRadius;\n        float normalized_altitude = altitude / atmosphereThickness;\n\n        cosTheta = dot(zenith_dir, sunDir);\n\n        vec4 aerosol_absorption, aerosol_scattering;\n        vec4 molecular_absorption, molecular_scattering;\n        vec4 extinction;\n        get_atmosphere_collision_coefficients(\n            altitude,\n            aerosol_absorption, aerosol_scattering,\n            molecular_absorption, molecular_scattering,\n            extinction);\n\n        vec4 transmittance_to_sun = LUT(cosTheta, normalized_altitude);\n        \n        // Solid angle subtended by the planet from a point at d distance\n        // from the planet center.\n        // 2nd order scattering from the ground\n        vec4 L_ground = .5 * (1. - sqrt(1. - sqr(groundRadius / d))) * groundAlbedo * INVPI * LUT(cosTheta, 0.) * LUT(1., 0.) / LUT(1., normalized_altitude) * cosTheta;\n\n        // Fit of Earth's multiple scattering coming from other points in the atmosphere\n        vec4 L_ms = vec4(.00434, .00694, .01188, .02) / (1. + 5. * exp(-17.92 * cosTheta));\n\n        vec4 ms = L_ms + L_ground;\n\n        vec4 S = sun_spectral_irradiance *\n            (molecular_scattering * (molecular_phase * transmittance_to_sun + ms) +\n             aerosol_scattering   * (aerosol_phase   * transmittance_to_sun + ms));\n\n        vec4 step_transmittance = exp(-dt * extinction);\n\n        // Energy-conserving analytical integration\n        // \"Physically Based Sky, Atmosphere and Cloud Rendering in Frostbite\"\n        // by Sébastien Hillaire\n        \n        L += transmittance * S * (1. - step_transmittance) / extinction;\n        transmittance *= step_transmittance;\n        \n        pos += rd * dt;\n    }\n    \n    O.xyz = mat4x3(137.672389239975, -8.632904716299537, -1.7181567391931372,\n                   32.549094028629234, 91.29801417199785, -12.005406444382531,\n                   -38.91428392614275, 34.31665471469816, 29.89044807197628,\n                   8.572844237945445, -11.103384660054624, 117.47585277566478) * L;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nbool volume(float N, float F, float dens, ray r, float tmin, float tmax, inout hitRecord rec)\n{\n    N = max(N, tmin);\n    F = min(F, tmax);\n    \n    if (N > F) return false;\n        \n    N -= log(rand) / dens;\n        \n    if (N > F) return false;\n         \n    rec.t = N; \n    rec.p = r.o + r.d * N;\n    rec.n = ranSph();\n    \n    rec.isVolume = true;\n    \n    return true; \n}\n\nbool iSphere(mat4 txx, float rad, float dens, ray r, float tmin, float tmax, inout hitRecord rec)\n{\n    vec3 ro = (txx * vec4(r.o, 1)).xyz,\n\t     rd = (txx * vec4(r.d, 0)).xyz;\n    \n    float b = dot(ro, rd),\n          d = rad * rad - dot2(ro - b * rd);\n\n    if (d < 0.) return false;\n    \n    d = sqrt(d);\n    \n    float N = -b - d,\n          F = -b + d;\n    \n    if(dens > 0.) return volume(N, F, dens, r, tmin, tmax, rec);\n    \n    rec.isVolume = false;\n    \n    float t = N < tmin ? F : N;\n    \n    if(t < tmin || t > tmax) return false;\n    \n    rec.t = t;\n    rec.p = r.o + r.d * t;\n    rec.n = (inverse(txx) * vec4(ro + rd * t, 0) / rad).xyz;\n    \n    return true;\n}\n\nbool iBox(mat4 txx, vec3 rad, float dens, ray r, float tmin, float tmax, inout hitRecord rec)\n{\n    vec3 ro = (txx * vec4(r.o, 1)).xyz,\n\t     rd = (txx * vec4(r.d, 0)).xyz,\n         \n    k = rad * sign(rd),\n                  \n\tt1 = (-ro - k) / rd,\n\tt2 = (-ro + k) / rd;\n    \n    float N = max(max(t1.x, t1.y), t1.z),\n          F = min(min(t2.x, t2.y), t2.z);\n    \n    if(N > F || F < tmin || N > tmax) return false;\n    \n    if(dens > 0.) return volume(N, F, dens, r, tmin, tmax, rec);\n    \n    rec.isVolume = false;\n\n    vec4 res = (N > tmin) ? vec4(N, step(vec3(N), t1))\n                          : vec4(F, step(t2, vec3(F)));\n    \n    rec.t = res.x;\n    rec.p = r.o + r.d * res.x;\n    rec.n = (inverse(txx) * vec4(-sign(rd) * res.yzw, 0)).xyz;\n\t\n\treturn true;\n}\n\nvec3 minorAxis(vec3 v)\n{\n\tv = abs(v);\n    \n    return v.x < v.y ? v.x < v.z ? vec3(1, 0, 0) : vec3(0, 0, 1)\n\t                 : v.y < v.z ? vec3(0, 1, 0) : vec3(0, 0, 1);\n}\n\nvoid constructFrame(vec3 normal, out vec3 xAxis, out vec3 yAxis)\n{\n\tvec3 m = minorAxis(normal);\n\txAxis = normalize(cross(normal, m));\n\tyAxis = cross(xAxis, normal);\n}\n\n// note: x,y,z are scalars, forward is a vec3\nvec3 rotateFrame(float x, float y, float z, vec3 forward)\n{\n\tvec3 xAxis, yAxis;\n    vec3 m = minorAxis(forward);\n\txAxis = normalize(cross(forward, m));\n\tyAxis = cross(xAxis, forward);\n\treturn xAxis * x + yAxis * y + forward * z;\n}\n\nvec3 randomQuad(vec3 nor, vec2 rad)\n{\n\tvec2 uv = (rand2 - .5) * rad;\n\treturn rotateFrame(uv.x, uv.y, 0., nor);\n}\n\nbool iQuad(mat4 txx, vec3 cen, vec3 nor, vec2 rad, ray r, float tmin, float tmax, inout hitRecord rec)\n{\n    vec3 ro = (txx * vec4(r.o, 1)).xyz,\n\t     rd = (txx * vec4(r.d, 0)).xyz;\n    \n    if(abs(dot(rd, nor)) < 1e-6) return false;\n    \n    float t = dot(ro - cen, nor) / -dot(rd, nor);\n    \n    if (t < tmin || t > tmax) return false;\n    \n    vec3 u, v;\n    \n    constructFrame(nor, u, v);\n    \n    vec3 vi = ro + rd * t - cen;\n    \n    if (abs(dot(vi, u)) > rad.x * .5) return false;\n    if (abs(dot(vi, v)) > rad.y * .5) return false;\n    \n    rec.t = t;\n    rec.p = r.o + r.d * t;\n    rec.n = (inverse(txx) * vec4(nor, 0)).xyz;\n    \n    return true;\n}\n\n#if SCENE == 1\nconst int numSphereLights = 0,\n          numQuadLights = 0,\n#elif SCENE == 2\n#if SKYTYPE == 0\nconst int numSphereLights = 0,\n          numQuadLights = 1,\n#else\nconst int numSphereLights = 0,\n          numQuadLights = 0,\n#endif\n#else\n#if SKYTYPE == 0\nconst int numSphereLights = 0,\n          numQuadLights = 1,\n#else\nconst int numSphereLights = 0,\n          numQuadLights = 0,\n#endif\n#endif\n\nnumLights = numSphereLights + numQuadLights;\n\nstruct sphereLight\n{\n    vec3 emission;\n    vec3 cen;\n    float rad;\n};\n\nstruct quadLight\n{\n    vec3 emission;\n    vec3 cen;\n    vec3 nor;\n    vec2 rad;\n};\n\nsphereLight[max(numSphereLights, 1)] sphereLights;\nquadLight[max(numQuadLights, 1)] quadLights;\n\nvoid initLight()\n{\n    \n    if (SCENE == 2 && SKYTYPE < 1)\n    {\n        quadLights[0] = quadLight(vec3(15), vec3(0, 277, 0), vec3(0, 1, 0), vec2(130, 105));\n    }\n    if (SCENE == 3 && SKYTYPE < 1)\n    {\n        quadLights[0] = quadLight(vec3(7), vec3(273, 555, 279.5), vec3(0, 1, 0), vec2(300, 265));\n    }\n    \n    //sphereLights[0] = sphereLight(vec3(15), vec3(0, 277, 0), 100.);\n}\n\nbool sphere(mat4 txx, float rad, ray r, float tmin, float tmax, out float t)\n{\n    vec3 ro = (txx * vec4(r.o, 1)).xyz,\n\t     rd = (txx * vec4(r.d, 0)).xyz;\n    \n    float b = dot(ro, rd),\n          d = rad * rad - dot2(ro - b * rd);\n\n    if (d < 0.) return false;\n    \n    d = sqrt(d);\n    \n    float N = -b - d,\n          F = -b + d;\n    \n    t = N < tmin ? F : N;\n    \n    if(t < tmin || t > tmax) return false;\n    \n    return true;\n}\n\nbool box(mat4 txx, vec3 rad, ray r, float tmin, float tmax, out float t)\n{\n    vec3 ro = (txx * vec4(r.o, 1)).xyz,\n\t     rd = (txx * vec4(r.d, 0)).xyz,\n\n\tk = rad * sign(rd),\n                  \n\tt1 = (-ro - k) / rd,\n\tt2 = (-ro + k) / rd;\n    \n    float N = max(max(t1.x, t1.y), t1.z),\n          F = min(min(t2.x, t2.y), t2.z);\n    \n    if(N > F || F < tmin || N > tmax) return false;\n    \n    t = N > tmin ? N : F;\n\t\n\treturn true;\n}\n\nmaterial DIFFUSE(vec3 col)\n{\n    material mat  = initMat;\n    mat.baseColor = col;\n    mat.roughness = 1.;\n    \n    return mat;\n}\n\nmaterial METAL(vec3 col, float roughness)\n{\n    material mat  = initMat;\n    mat.baseColor = col;\n    mat.metallic  = 1.;\n    mat.roughness = roughness;\n    \n    return mat;\n}\n\nmaterial GLASS(vec3 col, float IOR)\n{\n    material mat  = initMat;\n    mat.baseColor = col;\n    mat.specTrans = 1.;\n    mat.IOR       = IOR;\n    \n    return mat;\n}\n\nmaterial LIGHT(vec3 col)\n{\n    material mat = initMat;\n    mat.emission = col;\n    \n    return mat;\n}\n\nmaterial VOLUME(vec3 col)\n{\n    material mat  = initMat;\n    mat.baseColor = col;\n    \n    return mat;\n}\n\nfloat sdSphere(mat4 txx, vec3 p, float s)\n{\n    p = (txx * vec4(p, 1)).xyz;\n    return length(p) - s;\n}\n\nfloat density(vec3 p, out vec3 col)\n{\n    float dens = .0001;\n    col = vec3(1);\n    \n    if (sdSphere(translate(vec3(360, 150, 145)), p, 69.) < 0.)\n    {\n        dens = .2;\n        col = vec3(.2, .4, .9);\n    }\n    if (sdSphere(translate(vec3(400, 200, 400)), p, 99.) < 0.)\n    {\n        dens = .2;\n        col = vec3(.4, .5, .7);\n    }\n    \n    return dens;\n}\n\n#define DENSITY .2\nbool traceVolume(ray r, float tmin, float tmax, inout hitRecord rec)\n{\n    float t = tmin;\n    bool hit = false;\n    vec3 col;\n    \n    for(int j = 0; j < 256 && t < tmax && !hit; j++)\n    {\n        t -= log(rand) / DENSITY;\n        hit = rand < density(r.o + t * r.d, col) / DENSITY;\n    }\n    \n    if(!hit) return false;\n    \n    rec.t = t;\n    rec.p = r.o + r.d * t;\n    rec.mat = VOLUME(col);\n    rec.isVolume = true;\n    \n    return hit;\n}\n\nbool worldHit(ray r, float tmin, float tmax, out hitRecord rec)\n{\n    rec.t = tmax;\n    rec.lightID = -1;\n    rec.isVolume = false;\n    \n    bool hit = false;\n    \n    initLight();\n    \n    if (SCENE == 1)\n    {\n        if (iBox(noTransform, vec3(1e3, .01, 1e3), 0., r, tmin, rec.t, rec))\n        \n            hit = true,\n            rec.mat = DIFFUSE(vec3(.5));\n        \n        if (iSphere(translate(vec3(0, 1, 0)), 1., 0., r, tmin, rec.t, rec))\n        \n            hit = true,\n            rec.mat = GLASS(vec3(1), 1.5);\n        \n        if (iSphere(translate(vec3(-4, 1, 0)), 1., 0., r, tmin, rec.t, rec))\n        \n            hit = true,\n            rec.mat = DIFFUSE(vec3(.4, .2, .1));\n        \n        if (iSphere(translate(vec3(4, 1, 0)), 1., 0., r, tmin, rec.t, rec))\n        \n            hit = true, \n            rec.mat = METAL(vec3(.7, .6, .5), 0.);\n        \n        vec2 ro = r.o.xz, rd = r.d.xz, p = floor(ro), s = sign(rd), m,\n             d = (p - ro + .5 + s * .5) / rd, cen;\n        \n        bool bhit = false;\n        \n        float t;\n        if(box(translate(vec3(0, .2, 0)), vec3(12, .2, 12), r, tmin, rec.t, t))\n        for(int i = ZERO; i < 40; i++)\n        {\n            for(int j = ZERO; j < 4; j++)\n            {\n                cen  = p - vec2(j / 2, j % 2);\n                cen += .2 + .9 * hash2(cen);\n                \n                if (all(lessThan(abs(cen), vec2(12))))\n                if (sqr(abs(abs(cen.x) - 2.) - 2.) + sqr(cen.y) > .8)\n                if (iSphere(translate(vec3(cen.x, .2, cen.y)), .2, 0., r, tmin, rec.t, rec))\n                {\n                    bhit = true;\n                    \n                    vec4 ran = hash4(cen);\n                    \n                    if      (ran.w < .8) rec.mat = DIFFUSE(ran.xyz * ran.xyz * .9 + .1);\n                    else if (ran.w < .95) rec.mat = METAL(.5 * ran.xyz + .5, .5 * hash(ran));\n                    else                 rec.mat = GLASS(.5 * ran.xyz + .5, 1.5);\n                }\n            }\n\n            if(bhit)\n            {\n                hit = true;\n                break;\n            }\n            \n            m = step(d, d.yx);\n            d += m / abs(rd);\n            p += m * s;\n        }\n    }\n    \n    if (SCENE == 2)\n    {\n        material red   = DIFFUSE(vec3(.65, .05, .05)),\n                 white = DIFFUSE(vec3(.73)),\n                 green = DIFFUSE(vec3(.12, .45, .15));\n        \n        if (iBox(translate(vec3(-278,    0,   0)), vec3(  1, 278, 278), 0., r, tmin, rec.t, rec)) hit = true, rec.mat = red;\n        if (iBox(translate(vec3(   0, -278,   0)), vec3(278,   1, 278), 0., r, tmin, rec.t, rec)) hit = true, rec.mat = white;\n        if (iBox(translate(vec3(   0,    0, 278)), vec3(278, 278,   1), 0., r, tmin, rec.t, rec)) hit = true, rec.mat = white;\n        if (iBox(translate(vec3( 278,    0,   0)), vec3(  1, 278, 278), 0., r, tmin, rec.t, rec)) hit = true, rec.mat = green;\n        if (iBox(translate(vec3(   0,  278,   0)), vec3(278,   1, 278), 0., r, tmin, rec.t, rec)) hit = true, rec.mat = white;\n        \n        if (iBox(rotateY(-.1 * PI) * translate(-vec3(105, 195.5, 82)), vec3(82.5), 0., r, tmin, rec.t, rec))\n            \n            hit     = true, \n            rec.mat = white;\n\n        if (iBox(rotateY(PI / 12.) * translate(vec3(93.5, -113, 71)), vec3(82.5, 165, 82.5), 0., r, tmin, rec.t, rec))\n\n            hit     = true, \n            rec.mat = white;\n    }\n    \n    if (SCENE == 3)\n    {\n        if (iSphere(translate(vec3(4e2 + 30. * rand, 400, 200)), 50., 0., r, tmin, rec.t, rec))\n            \n            hit = true,\n            rec.mat = DIFFUSE(vec3(.7, .3, .1));\n        \n        if (iSphere(translate(vec3(260, 150, 45)), 50., 0., r, tmin, rec.t, rec))\n        \n            hit = true,\n            rec.mat = GLASS(vec3(1), 1.5);\n        \n        if (iSphere(translate(vec3(0, 150, 145)), 50., 0., r, tmin, rec.t, rec))\n        \n            hit = true,\n            rec.mat = METAL(vec3(.8, .8, .9), .5);\n        \n        if (iSphere(translate(vec3(220, 280, 300)), 80., 0., r, tmin, rec.t, rec))\n        \n            hit = true,\n            rec.mat = DIFFUSE(vec3(.5 - .5 * sin(.1 * rec.p.x + 10. * fbm(.1 * rec.p, 7))));\n        \n        if (iSphere(translate(vec3(360, 150, 145)), 70., 0., r, tmin, rec.t, rec))\n        \n            hit = true,\n            rec.mat = GLASS(vec3(1), 1.5);\n        \n        if (iSphere(translate(vec3(400, 200, 400)), 1e2, 0., r, tmin, rec.t, rec))\n            \n            hit = true,\n            rec.mat = GLASS(vec3(1), 1.04);\n        \n        mat4 txx = rotateY(PI / 12.) * translate(vec3(-17.5, 352.5, 477.5));\n        \n        vec3 roo = (txx * vec4(r.o, 1)).xyz,\n             rdd = (txx * vec4(r.d, 0)).xyz;\n\n        float t;\n\n        if (box(noTransform, vec3(100), ray(roo, rdd), tmin, tmax, t))\n        {\n            vec3 ro = roo / 20., s = sign(rdd), m,\n                 p = floor(ro + (all(lessThan(abs(ro), vec3(5))) ? tmin : t) * rdd / 20.),\n                 d = (p - ro + .5 + s * .5) / rdd;\n\n            bool bhit = false;\n            \n            for (int i = ZERO; i < 30; i++)\n            {\n                for(int j = ZERO; j < 27; j++)\n                {\n                    vec3 pos = p + vec3(j / 9, j / 3 % 3, j % 3) - 1.;\n\n                    if (all(lessThan(abs(pos), vec3(4.1))))\n                    if (iSphere(translate(20. * pos + 15. * hash(pos) - 7.5), 10., 0., ray(roo, rdd), tmin, rec.t, rec))\n                        bhit = true;\n                }\n\n                if(bhit)\n                {\n                    hit = true;\n                    rec.p = r.o + r.d * rec.t;\n                    rec.n = (inverse(txx) * vec4(rec.n, 0)).xyz;\n                    \n                    rec.mat = DIFFUSE(vec3(.73));\n                    \n                    break;\n                }\n\n                m = step(d, d.yzx) * step(d, d.zxy);\n                d += m / abs(rdd);\n                p += m * s;\n            }\n        }\n        \n        vec2 ro = r.o.xz / 1e2, rd = r.d.xz, p = floor(ro) + .5, m,\n             s = sign(rd), d = (p - ro + s * .5) / rd;\n        \n        if(box(noTransform, vec3(1e3), r, tmin, rec.t, t))\n        for (int i = ZERO; i < 30; i++)\n        {\n            if (all(lessThan(abs(p), vec2(10))))\n            {\n                if (iBox(translate(1e2 * vec3(p.x, 0, p.y)), vec3(50, 1e2 * hash(p), 50), 0., r, tmin, rec.t, rec))\n                {\n                    hit = true;\n\n                    rec.mat = DIFFUSE(vec3(.48, .83, .53));\n\n                    break;\n                }\n            }\n            m = step(d, d.yx); \n            d += m / abs(rd);\n            p += m * s;\n        }\n    }\n    \n    int ID = 0;\n    \n    for(int i = 0; i < numSphereLights; i++)\n    {\n        sphereLight light = sphereLights[i];\n        \n        if(iSphere(translate(light.cen), light.rad, 0., r, tmin, rec.t, rec))\n            \n            hit = true,\n            rec.mat = LIGHT(light.emission),\n            rec.lightID = ID;\n        \n        ID++;\n    }\n    \n    for(int i = 0; i < numQuadLights; i++)\n    {\n        quadLight light = quadLights[i];\n        \n        if(iQuad(noTransform, light.cen, light.nor, light.rad, r, tmin, rec.t, rec))\n            \n            hit = true,\n            rec.mat = LIGHT(light.emission),\n            rec.lightID = ID;\n        \n        ID++;\n    }\n    \n    if(SCENE > 2)\n    if(traceVolume(r, tmin, rec.t, rec)) hit = true, rec.lightID = -1;\n    \n    rec.mat.roughness = max(rec.mat.roughness, .001);\n    \n    return hit;\n}\n\nfloat geom_fact_sa(vec3 P, vec3 P_surf, vec3 n_surf)\n{\n    vec3 dir = normalize(P_surf - P);\n    float dist2 = dot2(P_surf - P);\n    return abs(dot(n_surf, dir)) / dist2;\n}\n\nbool visibility(vec3 a, vec3 b)\n{\n    vec3 dir = normalize(b - a);\n    hitRecord rec;\n    worldHit(ray(a, dir), .01, 1e5, rec);\n    return dot2(rec.p - b) < 1e-6;\n}\n\nvec3 sphericalDirection(float sinTheta, float cosTheta, float sinPhi, float cosPhi)\n{\n    return vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);\n}\n\nvec3 uniformSampleCone(float cosThetaMax, vec3 X, vec3 Y, vec3 Z)\n{\n    float cosTheta = 1. + rand * (cosThetaMax - 1.);\n    float sinTheta = sqrt(1. - cosTheta * cosTheta);\n    float phi = rand * TAU;\n    vec3 V = sphericalDirection(sinTheta, cosTheta, sin(phi), cos(phi));\n    return V.x * X + V.y * Y + V.z * Z;\n}\n\nfloat uniformConePdf(float cosThetaMax)\n{\n    return .5 * INVPI / (1. - cosThetaMax);\n}\n\nbool sampleLights(vec3 P, vec3 n, out vec3 POut,\n                  out vec3 LeOut, out float pdfOut)\n{\n    int chosenLight = int(rand * float(numLights));\n    vec3 lPos, lNor;\n    float p = 1. / float(numLights);\n    \n    int cdf[2];\n    \n    cdf[0] = numSphereLights;\n    cdf[1] = cdf[0] + numQuadLights;\n    \n    vec3 emission;\n    \n    if (chosenLight < cdf[0])\n    {\n        sphereLight l = sphereLights[chosenLight];\n        vec3 oc = l.cen - P;\n        vec3 N = normalize(oc), T, B;\n        onb(N, T, B);\n        float sinThetaMax2 = sqr(l.rad) / dot2(oc);\n        float cosThetaMax = sqrt(max(0., 1. - sinThetaMax2));\n        vec3 wi = uniformSampleCone(cosThetaMax, T, B, N);\n        lPos = P + wi * iSphere(-oc, wi, l.rad);\n        p *= uniformConePdf(cosThetaMax);\n        emission = l.emission;\n    }\n    else if (chosenLight < cdf[1])\n    {\n        quadLight l = quadLights[chosenLight - cdf[0]];\n        lPos = l.cen + randomQuad(l.nor, l.rad);\n        lNor = l.nor;\n        float area = l.rad.x * l.rad.y;\n        p /= area * geom_fact_sa(P, lPos, lNor);\n        emission = l.emission;\n    }\n    \n    bool vis = visibility(P, lPos);\n    \n    POut = lPos;\n    pdfOut = p;\n    LeOut = vis ? emission : vec3(0);\n    \n    return vis;\n}\n\nfloat sampleLightsPdf(vec3 P, vec3 n, vec3 lPos, vec3 lNor, int chosenLight)\n{\n    float p = 1. / float(numLights);\n    \n    int cdf[2];\n    \n    cdf[0] = numSphereLights;\n    cdf[1] = cdf[0] + numQuadLights;\n    \n    if (chosenLight < cdf[0])\n    {\n        sphereLight l = sphereLights[chosenLight];\n        float sinThetaMax2 = sqr(l.rad) / dot2(l.cen - P);\n        float cosThetaMax = sqrt(max(0., 1. - sinThetaMax2));\n        p *= uniformConePdf(cosThetaMax);\n    }\n    else if (chosenLight < cdf[1])\n    {\n        quadLight l = quadLights[chosenLight - cdf[0]];\n        float area = l.rad.x * l.rad.y;\n        p /= area * geom_fact_sa(P, lPos, lNor);\n    }\n    \n    return p;\n}\n\nfloat heuristic(float a, float b)\n{\n    float t = a * a;\n    return t / (t + b * b);\n}\n\nvec3 skyTexture(vec3 rd)\n{\n    if(SKYTYPE == 1) return (1. - vec3(.25, .15, 0) * (rd.y + 1.));\n    if(SKYTYPE == 2)\n    {\n        float phi   = atan(rd.z, rd.x),\n              theta = asin(rd.y);\n                \n        return texture(iChannel0, vec2(phi / PI, sqrt(2. * abs(theta) / PI) * sign(theta)) * .5 + .5).rgb;\n    }\n    return vec3(0);\n}\n\n#ifdef USE_MIS\nvec3 color(ray r)\n{\n    vec3 col = vec3(1), emitted = vec3(0);\n    float pdf;\n\thitRecord rec;\n    \n    if(worldHit(r, .01, 1e5, rec))\n    for (int i = ZERO; i < 10; i++)\n    {\n        if(i == 0) emitted += col * rec.mat.emission;\n        \n        if(dot(rec.n, r.d) > 0.) rec.eta = rec.mat.IOR, rec.n = -rec.n;\n        else rec.eta = 1. / rec.mat.IOR;\n        \n        ray scattered;\n        scattered.o = rec.p;\n        \n        vec3 Le, mWi, lPos;\n        float lPdf, mPdf;\n        \n        // Light sampling\n        \n        if(sampleLights(rec.p, rec.n, lPos, Le, lPdf))\n        {\n            vec3 lWi = normalize(lPos - rec.p);\n            float mPdf;\n            vec3 brdf = DisneyBSDF(rec, -r.d, rec.n, lWi, mPdf);\n            float weight = heuristic(lPdf, mPdf);\n            emitted += col * brdf * weight * Le / lPdf;\n        }\n        \n        vec3 lWi = ranHemi(rec.n);\n        hitRecord rec_;\n        if(!worldHit(ray(rec.p, lWi), .01, 1e5, rec_))\n        {\n            lPdf = 1. / TAU;\n            vec3 brdf = DisneyBSDF(rec, -r.d, rec.n, lWi, mPdf);\n            float weight = heuristic(lPdf, mPdf);\n            vec3 Le = skyTexture(lWi);\n            emitted += col * brdf * weight * Le / lPdf;\n        }\n        \n        // Material sampling\n        \n        vec3 brdf = DisneySample(rec, -r.d, mWi, mPdf);\n        if(mPdf > 0.) col *= brdf / mPdf;\n        else break;\n        \n        if (worldHit(ray(rec.p, mWi), .01, 1e5, rec_))\n        {\n            if (rec_.lightID > -1)\n            {\n                float lightPdf = sampleLightsPdf(rec.p, rec.n, rec_.p, rec_.n, rec_.lightID);\n                float weight = heuristic(mPdf, lightPdf);\n                vec3 Le = rec_.mat.emission;\n                emitted += col * weight * Le;\n                break;\n            }\n        }\n        else\n        {\n            float lightPdf = 1. / TAU;\n            float weight = heuristic(mPdf, lightPdf);\n            vec3 Le = skyTexture(mWi);\n            emitted += col * weight * Le;\n            break;\n        }\n        \n        scattered.d = mWi;\n        r = scattered;\n        rec = rec_;\n        \n        #ifdef RUSSIAN_ROULETE\n        float p = 1. - 1. / luma(col + 1.);\n        if (rand > p) break;\n        col /= p;\n        #endif\n    }\n    \n    else emitted = skyTexture(r.d);\n    \n    return emitted;\n}\n#else\nvec3 color(ray r)\n{\n    vec3 col = vec3(1), emitted = vec3(0);\n    float pdf;\n\thitRecord rec;\n    \n    for (int i = ZERO; i < 10; i++)\n    {\n        if (worldHit(r, .01, 1e5, rec))\n        {\n            emitted += col * rec.mat.emission;\n            \n            if(dot(rec.n, r.d) > 0.) rec.eta = rec.mat.IOR, rec.n = -rec.n;\n            else rec.eta = 1. / rec.mat.IOR;\n            \n            ray scattered;\n            scattered.o = rec.p;\n            \n            vec3 BSDF = DisneySample(rec, -r.d, scattered.d, pdf);\n            if(pdf > 0.) col *= BSDF / pdf;\n            \n            r = scattered;\n            \n            #ifdef RUSSIAN_ROULETE\n            float p = 1. - 1. / luma(col + 1.);\n        \tif (rand > p) break;\n            col /= p;\n            #endif\n        }\n        \n        else\n        {\n            emitted += col * skyTexture(r.d);\n            break;\n    \t}\n    }\n    \n    return emitted;\n}\n#endif\n\ncam camera(vec3 ro, vec3 lp, vec3 vup, \n           float vfov, float aperture, \n           float d)\n{\n    cam c;    \n    c.rad = aperture / 2.;\n    \n    float hh = tan(radians(vfov) / 2.) * d,\n          hw = R.x / R.y * hh;\n          \n    c.o = ro;\n    c.w = normalize(ro - lp);\n    c.u = normalize(cross(vup, c.w));\n    c.v = cross(c.w, c.u);\n    c.llc = c.o - hw * c.u - hh * c.v - d * c.w;\n    c.hor = 2. * hw * c.u;\n    c.ver = 2. * hh * c.v;\n    \n    return c;\n}\n\nray getRay(cam c, vec2 uv)\n{\n    vec2 rd = c.rad * ranDisk();\n    \n    c.o += c.u * rd.x + c.v * rd.y;\n    \n    return ray(c.o, normalize(c.llc + uv.x * c.hor + uv.y * c.ver - c.o));\n}\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    \n    if (vec2(I) == vec2(.5))\n    {\n        O.xy = R.xy;\n        return;\n    }\n    \n    seed = uvec4(I, iFrame, I.x * I.y);\n    \n    int samp = 2, i = ZERO;\n    \n    vec2 uv = (I + rand2 - .5) / R.xy;\n    \n    cam c;\n    if     (SCENE == 1) c = camera(vec3(13, 2, 3), vec3(0), vec3(0, 1, 0), 20., 0., 10.);\n    else if(SCENE == 2) c = camera(vec3(0, 0, -1078), vec3(0), vec3(0, 1, 0), 40., 0., 1.);\n    else                c = camera(vec3(478, 278, -600), vec3(278, 278, 0), vec3(0, 1, 0), 40., 20., 9e2);\n    \n    vec3 col = deNaN(color(getRay(c, uv)));\n    \n    if (texelFetch(iChannel1, ivec2(0), 0).xy == R.xy)\n    {\n        vec4 pre = texture(iChannel1, I / R.xy);\n        O = vec4(mix(pre.rgb, col, pre.a /= pre.a + 1.), pre.a);\n    }\n    \n    else O = vec4(col, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}