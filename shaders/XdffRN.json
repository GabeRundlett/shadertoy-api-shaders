{
    "Shader": {
        "info": {
            "date": "1494972627",
            "description": "Use mouse to change ray direction.\n\n2D view (view from above) of a scenery divided by sectors (grid)\nDo raytrace/raymarch only in the sector crossed by ray. Interest: limited mapping calculation even with hundreds of objects.\nMore details in head of code.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdffRN",
            "likes": 20,
            "name": "Sectors RayTace demo",
            "published": 3,
            "tags": [
                "demo",
                "raytrace",
                "optimisation"
            ],
            "usePreview": 0,
            "username": "ocb",
            "viewed": 914
        },
        "renderpass": [
            {
                "code": "// Author: ocb\n// Title: algo RT by sector Demo\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Algo developped for \"the Boreal Spring\" shader\n// https://www.shadertoy.com/view/ldXBRH\n\n// The aim of this program is a demo of getNextCell() function used in the Boreal Spring shader\n// It is a 2D view from above of a scenery with lot of objects.\n// The red line represents one ray in the raytracing process.\n// The objective when you have a lot of objects is to RayTrace only the objects along the ray,\n// avoiding heavy calculation when mapping or raytracing hundreds or thousands objects.\n// The solution here is to divide the space in sectors or cells, represented by the blue grid.\n// We have to find a efficient process to find the cells crossed by the ray to take\n// advantage on mapping all objects.\n\n// Ray (red line) is moved by mouse\n// Magenta dots represent an object (here it could be a sphere view from above)\n\n// cells in gray are the ones crossed by the ray, wich contain no object\n// => very fast calculation to find the next cell.\n\n// cells in blue are the ones with an object.\n// => heavy calculation (ray marching or ray tracing)\n\n// blue dots are the ones hit by ray.\n// if no transparency, process stop at first hit.\n\n// Cells left in black are ignored!\n\n// Finaly, to make sure process will stop even with no hit, the ray max distance\n// must be limited. Here max dist is 20 cells.\n\n// As we can see, with hundreds of object in the scenery, we have only very few blue cells,\n// involving raytrace calculation.\n// others are simply ignored.\n\n\n#define INFINI 1000.\n\n\n//----------------------------\nfloat rand1 (in float v) { \t\t\t\t\t\t\n    return fract(sin(v) * 437585.);\n}\nfloat rand2 (in vec2 st,in float time) { \t\t\t\t\t\t\n    return fract(sin(dot(st.xy,vec2(12.9898,8.233))) * 43758.5453123+time);\n}\n\n//-----------------------------\n// find if a cell contain object\nvec3 getObj(in vec2 cell, in float cellD){\n    vec3 ob= vec3(0.);\n    ob.z = rand2(cell*5.87,1.);\n    if (ob.z>.7){\n        ob.xy = .6*vec2(rand2(cell*1.44,0.)-.5,rand2(cell*2.51,0.)-.5);\n        ob.xy += cell;\n        ob.z = .2;\n        ob *= cellD;\n    }\n    else ob.z=0.;\n    return ob;\n}\n\n//-----------------------------\n// raytrace object\nfloat objImpact(in vec3 obj,in vec2 p, in vec2 v){\n    float t = INFINI;\n    vec2 d = obj.xy-p;\n    float b = dot(d,v);\n    \tfloat c = dot(d,d) - obj.z*obj.z;\n    \tfloat disc = b*b - c;\n    \tif (disc >= 0.){\n        \tfloat sqdisc = sqrt(disc);\n        \tfloat t1= b + sqdisc;\n        \tfloat t2= b - sqdisc;\n    \t\tt = min(t1,t2) ;\n        \tif (t <= 0.001){\n            \tt = max(t1,t2);\n            \tif (t <= 0.001) t = INFINI;\n        \t}\n    \t}\n    return t;\n}\n\n//------------------------------//\n//THE KEY FONCTION:             //\n//------------------------------//\nvec2 getNextCell(in vec2 p, in vec2 v, in vec2 cell, in float cellD){\n    vec2 d = sign(v);\n\tvec2 dt = ((cell+d*.5)*cellD-p)/v;\n    d *= vec2( step(dt.x-0.01,dt.y) , step(dt.y-0.01,dt.x) );\t\t// -0.01 to avoid cell change for epsilon inside\n    return cell+d;\n}\n//-----------------------------\n// is there object?\n// is there hit if raytraced?\n// render object.\nbool checkObject(in vec2 cell,in float cellD,in vec2 mp,in vec2 v, in vec2 st, inout vec3 color){\n    bool impact = false;\n    color += vec3(.2);\n    vec3 obj = getObj(cell, cellD);\n    if(obj.z > 0.){\n        color.b += .5;\n        float t = objImpact(obj,mp,v);\n        if(t != INFINI){\n            color.g += .8*step(-obj.z,-length(obj.xy-st));\n            impact = true;\n        }\n    }\n    return impact;\n}\n//---------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy-.5;\n    st.x *= iResolution.x/iResolution.y;\n\n    vec3 color = vec3(0.);\n    vec2 cell;\n    float cellD = .05;\n    vec2 p;\n    \n    vec2 mp = iMouse.xy/iResolution.xy-.5;\n    mp.x *= iResolution.x/iResolution.y;\n    vec2 op = vec2(.2);//.3*vec2(cos(u_time*.3),sin(u_time*.4));\n    vec2 v = normalize(op-mp);\n    \n    //--------------------------------------------------------\n    // demo visualisation\n    \n    //grid\n    vec2 c = floor(st/cellD +.5);\n    vec2 f = fract(st/cellD +.5)-.5;\n    float grid = smoothstep(.9,1.,abs(f.x-.5))+smoothstep(.9,1.,abs(f.y-.5));\n    //color += .4*vec3((c+10.)/20.,.0);\n    color += vec3(0.,0.,grid);\n    vec3 obj = getObj(c,cellD);\n    color.rb += .5*step(-obj.z,-length(obj.xy-st));\n    \n    //ray\n    float ray = step(sign(v.x)*mp.x,sign(v.x)*st.x)*smoothstep(st.y-0.002,st.y, v.y/v.x*(st.x-op.x) + op.y)*(1.-smoothstep(st.y,+st.y+.002, v.y/v.x*(st.x-op.x)+ op.y));\n    color.r += ray;\n    \n    //--------------------------------------------------------\n    //The actual process\n    \n    //first cell\n    bool impact = false;\n    cell = floor(mp/cellD +.5);\n    if(c==cell) impact = checkObject(cell,cellD,mp,v,st, color);\n    \n    //other cell\n    if(!impact){\n    \tfor(int i=0; i<20;i++){\n        \tcell = getNextCell(mp,v,cell,cellD);\n        \tif(c==cell) impact = checkObject(cell,cellD,mp,v,st,color);\n            if(impact) break;\n    \t}\n    }\n    \n    fragColor = vec4(color,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}