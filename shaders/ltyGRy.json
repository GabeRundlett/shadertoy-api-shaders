{
    "Shader": {
        "info": {
            "date": "1475152883",
            "description": "3D Trabeculum pattern (camera follow mouse) - messy testbench.\nVoronoi with smooth corners and normalized thickness (see comments).\n\nSo costly. How to make it cheaper ?",
            "flags": 0,
            "hasliked": 0,
            "id": "ltyGRy",
            "likes": 17,
            "name": "hypertexture - trabeculum -2",
            "published": 3,
            "tags": [
                "procedural",
                "noise",
                "perlin",
                "hypertexture",
                "trabeculum"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1478
        },
        "renderpass": [
            {
                "code": "// mix of 3D trabeculum https://www.shadertoy.com/view/ltj3Dc\n// and even-border 2D-trabeculum https://www.shadertoy.com/view/MlGGDw\n\n#define SHADED 1\n#define FOG 1\n#define VARIANT 1\n#define ANIMATE 1 // 1: camera shake  2: evolving trabeculum\n    \nconst vec3 skyColor = vec3(.7,.8,1.); const float skyTrsp = .5;\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\nconst vec3 ambient  = vec3(.2,0.,0.), \n           diffuse  = vec3(.8);\n\n#define PI 3.14159\n\n\nfloat hash( float n ) { // from https://www.shadertoy.com/view/XslGRr\n    return fract(sin(n)*43758.5453);\n}\n\n\nvec3 hash13( float n ) {\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\n}\nfloat hash31( vec3 n ) {\n    return hash(n.x+10.*n.y+100.*n.z);\n}\nvec3 hash33( vec3 n ) {\n    return hash13(n.x+10.*n.y+100.*n.z);\n}\n\nvec3 dist(vec3 g, vec3 x) {\n    vec3 n = floor(x), f = fract(x),\n         o = hash33( n + g );\n\t#if ANIMATE==2\n    o = .5 + .5*sin( iTime + 6.2831*o );\n    #endif\t\n    return g + o - f;\n}\n\nvec4 worley( vec3 x) {\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec3 mg, mr;\n\n    float md = 8., md2, md3;\n    for( int k=-1; k<=1; k++ ) \n      for( int j=-1; j<=1; j++ )\n        for( int i=-1; i<=1; i++ ) {\n            vec3  g = vec3(i,j,k), \n                  r = dist(g, x);\n            float d = dot(r,r);\n\n            if( d < md ) { md = d; mr = r;  mg = g; } // memorize closest + state\n        }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    vec4 d = vec4(1e15);\n/**/\n    mg-=mg;\n    #define W 1   // shortcut. why does it work ?\n/**\n    #define W 2   // should be the correct way\n/**/\n    for( int k=-W; k<=W; k++ )\n      for( int j=-W; j<=W; j++ )\n        for( int i=-W; i<=W; i++ ) {\n            vec3 g = mg + vec3(i,j,k),       // around cell of closest\n                 r = dist(g, x);\n\n            if( dot(mr-r,mr-r) > 1e-5 ) {  // don't count self cell\n                float d0 = dot( .5*(mr+r), normalize(r-mr) );\n                if      (d0<d.x) { d.yz=d.xy; d.x=d0; } // we might store normals as well\n                else if (d0<d.y) { d.z =d.y ; d.y=d0; }\n                else if (d0<d.z) {            d.z=d0; }   \n /*             if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; } // we might store normals as well\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\n                else if (d0<d.w) {              d.w=d0; }   */\n            }\n        }\n    return d;           // distances to border P0-PN, N=1..4 closests (after P0)\n}\n\nfloat grad=.2/2., scale = 5., thresh=.5, // default value possibly overloaded below.\n    _dist=1.;\n\n// my noise\nfloat tweaknoise( vec3 p) {\n    // macroscopic shape pruning the noise\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\n          d2 = smoothstep(grad/2.,-grad/2.,abs(p.z)-.5),\n          d=d1, v;\n\n  #if !VARIANT\n    d = (1.-d1)*d2; \n  #endif\n    _dist = 1.;\n    if (d < .5) return 0.;\n    \n    // 3D noise\n    //grad=.8, scale = 10., thresh=.7+.3*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\n    grad=.1, scale = 4., thresh=.9;\n    vec4 w = scale*worley(scale*p); \n#define TRAB 2 // variation for the magic trabeculum distance\n  #if TRAB==1\n    v = 1.-2./(0./w.x+1./w.y+1./w.z); // formula (c) Fabrice NEYRET - BSD3:mention author.\n  #elif TRAB==2\n    float n = 1.3; v= 1.-2.*pow(pow(w.y,-n)+pow(w.z,-n),-n);\n  #else\n    v= 1.-1.*w.y;\n  #endif\n    \n    _dist = 1.-v*d-thresh;\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\n}\n\n\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\nfloat shadedNormal( vec3 p, float v ) {\n    float epsL = 0.01;\n#if 1// centered directional derivative\n    float dx = (tweaknoise(p+epsL*lightDir)-tweaknoise(p-epsL*lightDir))/(2.*epsL);\n#else // cheap directional derivative\n    float dx = (tweaknoise(p+epsL*lightDir)-v)/epsL;\n#endif\n    return clamp(-dx*grad/scale/v*.5, 0.,1.); // Lambert shading  \n}\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \n    // { fragColor = vec4(ambient,1.); return; }\n    \n    vec2 mouse=iMouse.xy/iResolution.xy;\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\n\n    //camera\n    float theta = (mouse.x*2. - 1.)*PI;\n    float phi = (mouse.y - .5)*PI;\n#if ANIMATE==1 // camera shake \n    float t=10.*iTime,B=.02; theta += B*cos(t); phi += B*sin(t);\n#endif\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \n    vec3 cameraTarget = vec3(0.);\n    vec3 ww = normalize( cameraPos - cameraTarget );\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec2 q = 2.*(fragCoord / iResolution.y -vec2(.9,.5));\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\n  \n    // ray-trace volume\n    vec3 col=vec3(0.);\n \tfloat transp=1., epsC=.01/2.;\n    float l = .5;\n    vec3 p=cameraPos+l*rayDir, p_=p;\n    \n    for (int i=0; i<200; i++) { \n        float Aloc = tweaknoise(p); // density field\n        //epsC = .1*_dist;  // adaptive stepping\n        if (Aloc>0.01) {            \n#if FOG \n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\n            col += transp*skyColor*(1.-fog);\n    \t    transp *= fog; \n            if (transp<.001) break;\n#endif            \n#if SHADED          \n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\n          //vec3 c = ambient+diffuse*dot(N,lightDir); // if N already calculated\n#else\n            vec3 c = vec3(0.);\n#endif\n \t        col += transp*c*Aloc;\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\n            col = clamp(col,0.,1.); // anomaly :-(\n    \t    transp *= 1.-Aloc;\n\t        if (transp<.001) break;\n        }\n \n        p += epsC*rayDir;\n    }\n    \n   fragColor = vec4(col+ transp*skyColor, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}