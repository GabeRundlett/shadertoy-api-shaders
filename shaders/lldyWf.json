{
    "Shader": {
        "info": {
            "date": "1534508275",
            "description": "mouse sets 3rd point of a circle trough 3 points, this circle is used for an interpolation.\n\nfunction is fast, but i also see next to no use for it.\n\ni was hoping that i could mix this with itself or other functions to become useful, but so far found none",
            "flags": 0,
            "hasliked": 0,
            "id": "lldyWf",
            "likes": 4,
            "name": "3point lerp",
            "published": 3,
            "tags": [
                "circle",
                "lerp",
                "3point"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 705
        },
        "renderpass": [
            {
                "code": "\n//2d zoom\n#define ViewZoom 3.\n//divide by /aa for hairline drawing and sharp smoothstep()\n#define aa (min(iResolution.x,iResolution.y)/ViewZoom)\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y//usually first function of mainImage(), not typecast.\n\n\n#define pi acos(-1.)//trig definition for 3.14... can be better for smarter compilers.\n#define vec1 float\n#define sat(x) clamp(x,0.,1.)\n#define dd(a) dot(a,a)\n#define u5(a) ((a)*.5+.5)\n#define u2(a) ((a)*2.-1.)\n#define ss(a,u)smoothstep(a,-a,u)\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b) mix(b,a,step(a.x,b.x))\n#define manx(a,b) mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b) -minx(-a,-b)\nvec1 miv(vec2 a){return min(a.y,a.x);}vec1 miv(vec3 a){return min(a.z,miv(a.xy));}vec1 miv(vec4 a){return min(miv(a.zw),miv(a.xy));}\n#define mav(a) -miv(-a)\n\n\n//fract(dot(1031)) hash summer 2018 seems ot be generally superior to fract(sin()) hashes\nvec3 g3(vec1 a){return vec3(a);}\nvec3 g3(vec2 a){return a.xyx;}\nvec3 g3(vec3 a){return a;}\nvec4 g4(vec1 a){return vec4(a);}\nvec4 g4(vec2 a){return a.xyxy;}\nvec4 g4(vec3 a){return a.xyzy;}\nvec4 g4(vec4 a){return a;}\n//hashes by David Hoskins, Creative Commons Attribution-ShareAlike 4.0 International Public License\n//parent https://www.shadertoy.com/view/4djSRW\n#define hs vec4(.1031,.1030,.0973,.1099)\n//#define HASHSCALE3 vec3(443.897,441.423,437.195,444.129)// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define hout1(a) fract((a.x+a.y)*a.z)\n#define hout2(a) fract((a.xx+a.yz)*a.zy)\n#define hout3(a) fract((a.xxy+a.yzz)*a.zyx)\n#define hout4(a) fract((a.xxyz+a.yzzw)*a.zywx)\n#define h3mid(a) ((a)+dot(a,a.yzx+19.19))\n#define h4mid(a) ((a)+dot(a,a.wzxy+19.19))\n//hashes are named by output type, NEVER by input type\n//hash1 mirrors at y=x and has strong banding on diagonals.\n//only hash4 takes in vec4. all hash functions take vey1,v3c2,vec3 in (a vec4 generalizations is a mild overkill for most vec2,vec3 contexts)\n#define hash1(a) hout1(h3mid(fract(hs.x*g3(a))))\n#define hash2(a) hout2(h3mid(fract(hs.xyz*g3(a))))\n#define hash3(a) hout3(h3mid(fract(hs.xyz*g3(a))))\n#define hash4(a) hout4(h4mid(hs*g4(a)))\n//not sure if its this shaders fault, likely a fract() error, but the avobe hsh gives bad lines.\n//float hash1(float n) { return fract(sin(n) * 1e4); }\n\n#define ab012(a,b) (a+b*vec3(0,1,2))//desaturation.rgb kernel; b scales offset\n//rainbow*() ro from purple to purple for range[0..1], this makes ab012() desaturate into semi-gaussian scattering.\nvec3 rainbow(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets, desaturates colors for small b\nvec3 rainbow2(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets, desaturates colors for small b\nvec3 rainbow(float a){return rainbow(a,1./3.);}\nvec3 rainbow2(float a){return rainbow2(a,1./3.);}\n\n\n\n\n\n\n\n//3points21circle is useful for interpolations, barely at all, i played with this and found no useful mix() of this.\n\n//optional bound so that it always interpolates from [0..1] to [0..1]\n//#define Bound01\n\n\n//infinity, is really just an upper bound, set by address space, that translates into [distance by resolution]\n#define infinity 4096.\n#define sq(a) ((a)*(a))\n\nvec3 calcCircleFrom3Points(vec2 a,vec2 b,vec2 c//return m.xy point of euqal distance to 3 distances and m.z=squared distance.\n){vec3 m=vec3(0)\n ;vec2 da=(b-a)\n ;vec2 db=(c-b)\n ;float eps=.0001//eps of 0 woorks for me here.\n ;if(abs(da.x) < eps && abs(db.y) <=eps\n ){m.xy=.5*(vec2(c.x,a.y)+b)\n  ;m.z=dd(m.xy-a)\n  ;return m;\n  ;}\n ;vec2 s=vec2(da.y/da.x,db.y/db.x)\n ;if(abs(s.x-s.y)<eps||da.x==0.||db.x==0.\n ){m.xy=infinity*vec2(-1,1)-vec2(1,0);return vec3(m.xy,dd(m.xy-a));}//colinear&&delta==0 cases are set to far away large circle\n ;m.x=(s.x*s.y*(a.y-c.y) +s.y*(a.x+b.x)-s.x*(b.x+c.x))*.5/(s.y-s.x) \n ;m.y=-1.*(m.x-(a.x+b.x)/2.)/s.x+(a.y+b.y)/2.\n ;m.z=(dd(m.x-a.x)+dd(m.y-a.y));\n ;return m;\n ;}\n\nvoid mainImage(out vec4 O,vec2 u\n){u=fra(u)\n ;vec2 m=fra(iMouse.xy)//;vec2 n=fra(iMouse.zw)\n ;vec4 c=vec4(0)\n //;m=vec2(sat(m.x))//debug all perpendicular cases in range[0..1], also tests the 2 cases where 2/3 points are identical\n //;m=sat(m)//optional, for simplicity, doesnt really aid much though\n #ifdef Bound01\n ;if(dd(m-vec2(0,1))>1.)     m=vec2(1.-sqrt(3.),sqrt(3.))//vec2(sqrt(2.),2.-sqrt(2.))*.5\n ;else if(dd(m-vec2(1,0))>1.)m=vec2(sqrt(3.),1.-sqrt(3.))//vec2(2.-sqrt(2.),sqrt(2.))*.5\n //above 3 lines may be more precise than the identical bracket below; [1-sqrt(3)] is more precise than [(2.-sqrt(2.))*.5]\n //;if(max(dd(m-vec2(0,1)),dd(m-vec2(1,0)))>1.){vec2 a=vec2(sqrt(2.),2.-sqrt(2.))\n // ;m=mix(a,a.yx,sign(m.y-m.x)*.5+.5)*.5//m=((sign(m.y-m.x)*.5+.5)*(vec2(1.-sqrt(2.),sqrt(2.)-1.)*2.)+a)*.5\n // ;}\n #endif\n ;c.x=dd(m-u)//square distance to mouse\n ;vec3 o=calcCircleFrom3Points(vec2(0),vec2(1),m)//o.xy has same distance to 3 input points o.z is euclidean distance\n ;c.w=dd(o.xy-u)\n ;c.y=o.y-u.y+sign(o.x-o.y)*sqrt(o.z-sq(sat(u.x)-o.x))//both half circle cases\n //;if(o.x<o.y)c.y=o.y-u.y-sqrt(o.z-sq(sat(u.x)-o.x))//lower half circle\n //;else       c.y=o.y-u.y+sqrt(o.z-sq(sat(u.x)-o.x))//upper half circle\n ;c.xw=sqrt(c.xw)//squared distance -> distance\n ;c.z=miv(abs(u-.5))+.5//distance to cross at vec2(.5) for a coordinate system.\n ;float thick=.03,diam=.1//to mark a point with a dot and a circle around it.\n ;c.y=smoothstep(.01,-.01,abs(c.y)-thick)//green graph is main goal here.\n //i could do a 2tap differential for a better thickness, but i prefer to emphasize that this is a .y-distance\n ;thick*=.1 \n ;c.x=smoothstep(.01,-.01,abs(abs(c.x-diam)-diam+thick)-thick)//red mouse cursor is 3rd point\n ;c.w=smoothstep(.01,-.01,abs(c.w-sqrt(o.z))-thick)//yellow circle trough 3 points\n ;c.z=smoothstep(.01,-.01,abs(abs(c.z-1.))-thick)//blue cross coordinate system\n //i know theres better ways to do this abs(abs()) identities...\n ;c.xy+=c.w;//treat .w as yellow\n ;O=vec4(c.xyz,1);}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}