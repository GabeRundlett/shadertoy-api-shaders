{
    "Shader": {
        "info": {
            "date": "1592803548",
            "description": "voronoi bump map mosaic ",
            "flags": 0,
            "hasliked": 0,
            "id": "3tlyzl",
            "likes": 1,
            "name": "rtset",
            "published": 3,
            "tags": [
                "voronoi",
                "shader"
            ],
            "usePreview": 0,
            "username": "elmt",
            "viewed": 139
        },
        "renderpass": [
            {
                "code": "// July 2020\n// Ethan M\n\nconst float EPSILON = 0.01;\nconst int MAX_ITER = 400;\n\nconst vec2 RND_SEED = vec2(0.8388678474921857, 0.31300111519792606);\n\nstruct PointLight {\n    vec3 position;\n    float strength;\n};\n\nconst int LIGHT_COUNT = 2;\nconst PointLight lights[LIGHT_COUNT] = PointLight[](\n\tPointLight(vec3(0, 2, -0.1), 20.),\n    PointLight(vec3(-4, 0, 0), 11.)\n);\n\nvec3 rotateX(vec3 vec, float theta) {\n    float s = sin(theta), c = cos(theta);\n    float y = c * vec.y - s * vec.z, z = s * vec.y + c * vec.z;\n    \n    return vec3(vec.x, y, z);\n}\nvec3 rotateY(vec3 vec, float theta) {\n    float s = sin(theta), c = cos(theta);\n    float x = c * vec.x + s * vec.z, z = -s * vec.x + c * vec.z;\n    \n    return vec3(x, vec.y, z);\n}\nvec3 rotateZ(vec3 vec, float theta) {\n    float s = sin(theta), c = cos(theta);\n    float x = c * vec.x - s * vec.y, y = s * vec.x + c * vec.y;\n    \n    return vec3(x, y, vec.z);\n}\n\nfloat project(vec2 v0, vec2 v1, vec2 p) {\n    float dx = v0.x - v1.x, dy = v0.y - v1.y;\n    return 1.-((p.x*dx - v1.x*dx + p.y*dy - v1.y*dy)/(dx*dx + dy*dy));\n}\n\nfloat random(vec2 pos, float offset) {\n\treturn fract(sin(dot(pos, RND_SEED) * 640. + offset) * 640.);\n}\n\nfloat lighting(vec3 position, vec3 normal, float k) {\n    float mult = 0.0;\n    \n    for (int i = 0; i < LIGHT_COUNT; i++) {\n    \tPointLight light = lights[i];\n        \n        vec3 diff = light.position - position;\n        float diff_len = dot(diff, diff);\n        \n        float local = pow(dot(normal, normalize(diff)), k) / (diff_len) * light.strength;\n        \n        if (local > 0.0) { mult += local; }\n    }\n    \n    return mult;\n}\nfloat lighting(vec3 position, vec3 normal) { return lighting(position, normal, 1.); }\n\nconst float PI_6 = 0.5235987756;\nconst float SPHERE_RADIUS = 0.5;\nvec3 sphere_get_center() {\n\treturn vec3(1. + sin(iTime), -1. + cos(iTime / 2.) * 0.1, 4);\n}\nfloat sphereSDF(vec3 position) {\n\treturn length(sphere_get_center() - position) - SPHERE_RADIUS;\n}\nvec3 sphere_color(vec3 position) {\n    vec3 diff = position - sphere_get_center();\n    \n    vec2 m = diff.xz;\n    vec2 h = diff.yz;\n    \n    \n\treturn vec3(mod(floor((atan(m.y, m.x) - iTime) / PI_6), 2.));\n}\nvec3 sphere_normal(vec3 position) {\n    return normalize(position - sphere_get_center());\n}\n\nfloat wallSDF(vec3 position) {\n\treturn abs(5. - position.z);\n}\nfloat back_wallSDF(vec3 position) {\n    return abs(-4. - position.z);\n}\n\nconst float CHECKER_SIZE = 1.2;\nvec3 back_wall_color(vec3 position) {\n    float row = floor(position.x / CHECKER_SIZE);\n    float col = floor(position.y / CHECKER_SIZE);\n    bool is_black = mod(col, 2.) != mod(row, 2.);\n    return vec3(is_black ? 0. : 1.);\n}\n\nconst float VORONOI_CELL_SIZE = .76;\nconst int VORONOI_SEARCH_DEPTH_X = 3;\nconst int VORONOI_SEARCH_DEPTH_Y = 6;\n\nvec2 voronoi_cell_rnd(vec2 new_pos) {\n    vec2 new_center = vec2(random(new_pos, 0.), random(new_pos, 1.));\n    return (new_pos + new_center)*VORONOI_CELL_SIZE;\n}\n\nvec3 voronoi_cell_color(vec2 new_pos) {\n\treturn vec3(\n    \trandom(new_pos, 2.), random(new_pos, 3.), random(new_pos, 4.)\n    ) * 0.5 + 0.5;\n}\n\n/*\n\tFirst, find the random cell center that is closest to the point we're drawing\n\tThen, look around the chosen rnd cell center for other rnd cell centers\n\tFor each cell center, draw a line between the closest center and the center\n\twe're looking at.  Draw a perpendicular line in the middle of the line and\n\tproject the point we're drawing onto the perpendicular line.   The length of\n\tthat projected line is the length between the border and the point.  The\n\tsmallest distance is our uniform voronoi value\n*/\nvec3 wall_color(vec3 position, out vec3 normal) { \n\tvec2 pos = position.xy;\n    vec2 cell_pos = floor(pos / VORONOI_CELL_SIZE);\n\n    float smallest = 100.;\n    vec2 closest = vec2(0);\n    vec2 closest_pos = vec2(0);\n    vec3 color = vec3(0);\n    \n    for (int i = 0; i < 9; i++) {\n    \tvec2 offset = vec2(i / 3 - 1, (i % 3) - 1);\n\n        vec2 new_pos = cell_pos + offset;\n        vec2 new_point = voronoi_cell_rnd(new_pos);\n        \n        vec2 diff = new_point - pos;\n\n        float r2 = dot(diff, diff);\n\n        if (r2 < smallest) {\n            smallest = r2;\n            closest_pos = new_pos;\n            closest = new_point;\n            color = voronoi_cell_color(new_pos);\n        }\n    }\n    \n    smallest = 100.;\n    vec2 norm = vec2(0);\n    for (int i = -VORONOI_SEARCH_DEPTH_X; i < VORONOI_SEARCH_DEPTH_X; i++) {\n    for (int j = -VORONOI_SEARCH_DEPTH_Y; j < VORONOI_SEARCH_DEPTH_Y; j++) {\n    \tvec2 offset = vec2(i, j);\n        \n        vec2 new_pos = closest_pos + offset;\n        vec2 new_point = voronoi_cell_rnd(new_pos);\n        \n        vec2 cntr = mix(closest, new_point, 0.5);\n        vec2 dir = normalize(closest - cntr);\n        \n        float d = dot(dir, pos - cntr);\n        \n        if (d < smallest) {\n        \tsmallest = d;\n            norm = -dir; \n        }\n    }\n    }\n  \n    float level = smoothstep(0.0, 0.05, smallest);\n    norm = normalize(norm);\n    \n    /*\n\t\tBasically the idea is we take a straight vector perpendicular to the wall\n\t\tand interpolate that and our 2 dimensional direction vector pointing to the\n\t\tclosest voronoi wall.  Then we normalize the result.  It isn't 100% accurate\n\t\tbut its good enough and we dont have to deal with rotation matricies\n\t*/\n    vec3 normal_3d = normalize(mix(vec3(0, norm), vec3(0, 0, -1), level));\n    \n    normal = normal_3d;\n    \n    return color;\n}\n\nconst int FRONT_WALL = 0;\nconst int BACK_WALL = 1;\nconst int SPHERE_D = 2;\n\nvec3 march_point(vec3 position, vec3 direction, out int int_type, bool exclude_front) {\n    int type;\n    \n    for (int i = 0; i < MAX_ITER; i++) {\n    \tfloat front_d = exclude_front ? 100. : wallSDF(position);\n        float back_d = back_wallSDF(position);\n        float sphere_d = sphereSDF(position);\n        \n        float d = min(min(front_d, back_d), sphere_d);\n        \n        if (d == sphere_d) { type = SPHERE_D; }\n        else if (d == back_d) { type = BACK_WALL; }\n        else if (d == front_d) { type = FRONT_WALL; }\n        \n        if (d <= EPSILON) { break; }\n        \n        position += direction * d;\n    }\n    \n    int_type = type;\n    \n    return position;\n}\n\nconst vec3 FRONT_WALL_NORMAL = vec3(0, 0, -1);\nconst vec3 BACK_WALL_NORMAL = vec3(0, 0, 1);\nconst float SPECULAR_CONSTANT = 0.4;\nconst float DIFFUSE_CONSTANT = 1. - SPECULAR_CONSTANT;\n\nvec3 march(vec3 position, vec3 direction) {\n\tvec3 color = vec3(0);\n    bool bounced = false;\n    \n\tfor (int i = 0; i < 3; i++) {\n        int kind;\n        vec3 pos = march_point(position, direction, kind, bounced);\n        \n        if (kind == FRONT_WALL) {\n            vec3 n;\n            vec3 cell_color = wall_color(pos, n);\n            color = cell_color * lighting(pos, n);\n            \n            bounced = true;\n            \n        \tvec3 incident = direction;\n            direction = reflect(incident, n);\n            position = pos;\n        } else if (kind == BACK_WALL)  {\n            vec3 b_col = back_wall_color(pos) * lighting(pos, BACK_WALL_NORMAL);\n            if (bounced) {\n                color = DIFFUSE_CONSTANT * color + SPECULAR_CONSTANT * b_col;\n            } else {\n            \tcolor = b_col;\n            }\n            break;\n        } else if (kind == SPHERE_D) {\n        \tvec3 n = sphere_normal(pos);\n            vec3 s_col = sphere_color(pos) * lighting(pos, n);\n            if (bounced) {\n            \tcolor = DIFFUSE_CONSTANT * color + SPECULAR_CONSTANT * s_col;\n            } else {\n            \tcolor = s_col;\n            }\n            break;\n        }\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 ray = normalize(vec3(uv, 1.));\n    ray = rotateX(rotateY(ray, cos(iTime / 2.) * 0.15), sin(iTime / 2.) * 0.15);\n    \n    fragColor = vec4(march(vec3(0), ray), 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}