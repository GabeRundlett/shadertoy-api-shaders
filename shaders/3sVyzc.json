{
    "Shader": {
        "info": {
            "date": "1603391784",
            "description": "my midterm for my Introduction to Graphics class\nControls:\nWS: z-axis controls\nAD: x-axis controls\nQE: y-axis controls",
            "flags": 48,
            "hasliked": 0,
            "id": "3sVyzc",
            "likes": 0,
            "name": "Raymarching Lightcycle",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "dnekos",
            "viewed": 179
        },
        "renderpass": [
            {
                "code": "/*\n\tCopyright 2020 Demetrius and Nathan\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\t\thttp://www.apache.org/licenses/LICENSE-2.0\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n// rotationMatrix: Basic Rotation matrix for any axis\n//    angle: the vector, in radians, to be translated into a matrix\nmat3 rotationMatrix(in vec2 angle)\n{\n    //credit to wikipedia for matrix\n    \n    float sa = sin(angle.x);\n    float ca = cos(angle.x);\n    float sb = sin(-angle.y);\n    float cb = cos(-angle.y);\n\n    return mat3(ca, sa * sb, sa * cb,\n                0.0, cb, -sb,\n                -sa, ca * sb, cb * ca);\n}\n\n// Sets up and draws scene\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 camuv = fragCoord / iResolution.xy; // used for sampling camera channels\n    \n    // default cam position + position gotten from inputs\n    vec3 rayOrigin = vec3(0.2, 2.3, 1.0) + texture(iChannel0,uv).xyz;\n    // default coords * mouse angle (put through rotation matrix\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1.0)) * rotationMatrix(texture(iChannel1,uv).xy * 3.14159);\n        \n    // distance from viewport to whatever the ray hits\nsColoredObj dist = shortestDistanceToSurface(rayOrigin, rayDirection, MIN_DIST, MAX_DIST, iTime);    \t\n    // point on object surface\n    vec3 point = rayOrigin + dist.dist * rayDirection;\n    \n\tvec4 color = dist.color; // set color\n    // add pointlights\n    color = calcLighting ( vec3(0.0, 5.0, 1.0),  vec4(1.0),  20.0,  point,\n                    getNormal(point),  rayOrigin, point-rayOrigin,color)\n        + calcLighting ( vec3(3.0, 5.0, 9.0),  vec4(1.0),  20.0,  point,\n                    getNormal(point),  rayOrigin, point-rayOrigin,color);\n\n    fragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Work by Demetrius and Nathan\n// This common tab is responsible for holding all functions and structs relevent to the overall project\n// This tab also contains the code for the main implementations of lighting, ray marching, and scene rendering\n// \n\n#define MAX_STEPS 150\n#define MAX_DIST 150.0\n#define SURF_DIST 0.0001\n#define MIN_DIST 0.0\n  \n// sColoredOBJ: Object in scene\n//    color: color of object\n//    dist:  distance of object calculated by corresponding distance function (initOBJ)  \nstruct sColoredObj\n{\n    vec4 color;\n    float dist;\n};\n        \n// OBJintersect: Returns the intesection of two volumes\n//    distA: the first volume\n//    distA: the second volume\nsColoredObj OBJintersect(sColoredObj distA, sColoredObj distB) \n{\n    if (distA.dist > distB.dist)\n        return distA;\n    return distB;\n}\n\n// OBJintersect: Returns the union of two volumes\n//    distA: the first volume\n//    distA: the second volume\nsColoredObj OBJunion(in sColoredObj distA, in sColoredObj distB) \n{\n    if (distA.dist > distB.dist)\n        return distB;\n    return distA;\n\n}\n\n// OBJintersect: Returns the difference of two volumes\n//    distA: the first volume\n//    distA: the second volume, which will be removed\nsColoredObj OBJdifference(in sColoredObj distA, in sColoredObj distB) \n{\n    //return (distA.dist > -distB.dist) ? distA : distB; //WHY TF DOESNT ISNT THIS LEGAL\n    if (distA.dist > -1.0 * distB.dist)\n        return distA;\n    distB.dist = -1.0 * distB.dist;\n    return distB;\n}\n\n// initSphere: distance to a given sphere\n//    center: Coordinates to manipulate spheres position in coordinate space. Sets center point of sphere\n//    radius: Holds the radius of the spheres\n//    p:      Coordinate in space that a ray hits a sphere created by this function\n//    color:  Holds the color of the sphere\n// Functions main purpose is to algebraically calculate the distance of any point on the sphere\n// from a position passed into the function and return that distance.\nsColoredObj initSphere(vec4 center, float radius, \n                      vec4 color, vec3 p)\n{\n    sColoredObj sphere;\n    sphere.color = color;\n    sphere.dist = length(p - center.xyz) - radius;\n    return sphere;\n}\n\n// initPlane: distance to the plane y = 0\n// p: sample point \n// color: color of plane (used as grid in this instance)\n// Grid design inspired from theraot on shadertoy\n// https://www.shadertoy.com/view/wljXRh\nsColoredObj initPlane(vec4 color, vec3 p, float time)\n{\n\tsColoredObj plane;\n    p.x = p.x - time * 10.0;\n    vec2 tile_coord = p.xz;\n\tfloat size = 2.5;  // size of the tile\n\tfloat edge = size/16.0; // size of the edge\n    float tile_brightness = 0.1; // 0.9 controls the brighness of the face of the tile\n    float edge_brightness = 2.0; // 0.5 controls the darkness of the edge\n\ttile_coord = (mod(tile_coord, size) - mod(tile_coord - edge, size) - edge) * 1.0/size; //Calculates grid\n\tplane.color = vec4(tile_brightness + length(tile_coord) * edge_brightness);\n    plane.dist = p.y;\n    return plane;\n}\n\n// initCylinder: Distance function of a cylinder borrowed from: \n// https://iquilezles.org/articles/distfunctions\n//    position: Coordinate in space that a ray hits a cylinder created by this function\n//    top:      Holds the coordinate space for the top part of the cylinder (axis alignment)\n//    bottom:   Holds the coordinate space for the bottom part of the cylinder (axis alignment)\n//    center:   Coordinates to manipulate cylinders position in coordinate space. Sets center point of cylinder\n//    radius:   Holds the radius of the cylinder\n//    color:    Holds the color of the cylinder\n// Functions main purpose is to algebraically calculate the distance of any point on the cylinder\n// from a position passed into the function and return that distance.\nsColoredObj initCylinder(vec3 position, vec3 top, vec3 bottom, vec4 center,\n                          float radius, vec4 color)\n{\n\tsColoredObj cylinder;\n\tcylinder.color = color;\n    vec3  bottomToTop = bottom - top;\n    vec3  positionToTop = (position - center.xyz) - top;\n    float fullLength = dot(bottomToTop, bottomToTop);\n    float currentLength = dot(positionToTop, bottomToTop);\n    float x = length(positionToTop * fullLength - bottomToTop * currentLength) - radius * fullLength;\n    float y = abs(currentLength - fullLength * 0.5) - fullLength * 0.5;\n    float x2 = x * x;\n    float y2 = y * y * fullLength;\n    \n    float d = (max(x, y) < 0.0) ? -min(x2, y2) : (((x > 0.0) ? x2 : 0.0) + ((y > 0.0) ? y2 : 0.0));\n    \n    cylinder.dist = sign(d) * sqrt(abs(d)) / fullLength;\n\treturn cylinder;\n}\n\n// initCone: Distance function of a cone borrowed from: \n// https://iquilezles.org/articles/distfunctions\n//    position:     Coordinate in space that a ray hits a cone created by this function\n//    top:          Holds the coordinate space for the top part of the cone (axis alignment)\n//    bottom:       Holds the coordinate space for the botom part of the cone (axis alignment)\n//    center:       Coordinates to manipulate cones position in coordinate space. Sets center point of cone\n//    topRadius:    Radius of the top part of the cone\n//    bottomRadius: Radius of the bottom part of the cone\n//    color:        Holds the color of the cone\n// Functions main purpose is to algebraically calculate the distance of any point on the cone\n// from a position passed into the function and return that distance.\nsColoredObj initCone(vec3 position, vec3 top, vec3 bottom, vec4 center, float topRadius,\n\t\t\t\tfloat bottomRadius, vec4 color)\n{\n\tsColoredObj cone;\n\tcone.color = color;\n    float middleRadius  = bottomRadius - topRadius;\n    float bottomFromTop = dot(bottom - top, bottom - top);\n    float positionFromTop = dot((position - center.xyz) - top, (position - center.xyz) - top);\n    float positionIntersect = dot((position - center.xyz) - top, bottom - top) / bottomFromTop;\n\n    float x = sqrt( positionFromTop - positionIntersect * positionIntersect * bottomFromTop );\n\n    float topx = max(0.0, x - ((positionIntersect < 0.5) ? topRadius : bottomRadius));\n    float topy = abs(positionIntersect - 0.5) - 0.5;\n\n    float k = middleRadius * middleRadius + bottomFromTop;\n    float f = clamp( (middleRadius * (x - topRadius) + positionIntersect * bottomFromTop) / k, 0.0, 1.0 );\n\n    float bottomx = x - topRadius - f * middleRadius;\n    float bottomy = positionIntersect - f;\n    \n    float s = (bottomx < 0.0 && topy < 0.0) ? -1.0 : 1.0;\n    \n    cone.dist = s * sqrt( min(topx * topx + topy * topy * bottomFromTop,\n                       bottomx * bottomx + bottomy * bottomy * bottomFromTop) );\n\treturn cone;\n}\n\n// initBox: Distance function of a box borrowed from: \n// https://iquilezles.org/articles/distfunctions\n//    position:   Coordinate in space that a ray hits a box created by this function\n//    dimensions: Holds the dimensions of the box\n//    center:     Coordinates to manipulate boxes position in coordinate space. Sets center point of box\n//    color:      Holds the color of the box\n// Functions main purpose is to algebraically calculate the distance of any point on the box\n// from a position passed into the function and return that distance.\nsColoredObj initBox( vec3 position, vec3 dimensions, vec4 center, vec4 color)\n{\n\tsColoredObj box;\n\tbox.color = color;\n    \n\tvec3 q = abs(position - center.xyz) - dimensions;\n\tbox.dist = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n\treturn box;\n}\n\n// initTorus: Distance function of a torus borrowed from: \n// https://iquilezles.org/articles/distfunctions\n//    position: Coordinate in space that a ray hits a torus created by this function\n//    toroid:   axis of revolution against which the torus is drawn to. Usually represented as a circle\n//    center:   Coordinates to manipulate tori position in coordinate space. Sets center point of torus\n//    color:    Holds the color of the torus\n// Functions main purpose is to algebraically calculate the distance of any point on the torus\n// from a position passed into the function and return that distance.\nsColoredObj initTorus( vec3 position, vec2 toroid, vec4 center, vec4 color)\n{\n    sColoredObj torus;\n    torus.color = color;\n    \n    vec2 innerDistance = vec2(length((position.xy - center.xy)) - toroid.x,(position.z - center.z));\n    torus.dist = length(innerDistance) - toroid.y;\n    return torus;\n}\n\n// initCapsule: Distance function of a capsule borrowed from: \n// https://iquilezles.org/articles/distfunctions\n//    position: Coordinate in space that a ray hits a capsule created by this function\n//    top:      Holds the coordinate space for the top part of the capsule (axis alignment)\n//    bottom:   Holds the coordinate space for the bottom part of the capsule (axis alignment)\n//    center:   Coordinates to manipulate capsules position in coordinate space. Sets center point of capsule\n//    radius:   Holds the radius of the capsule\n//    color:    Holds the color of the capsule\n// Functions main purpose is to algebraically calculate the distance of any point on the capsule\n// from a position passed into the function and return that distance.\nsColoredObj initCapsule( vec3 position, vec3 top, vec3 bottom, vec4 center, \n                float radius, vec4 color)\n{\n    sColoredObj capsule;\n    capsule.color = color;\n    \n    vec3 topFromPosition = (position - center.xyz) - top, topFromBottom = bottom - top;\n    float height = clamp( dot(topFromPosition, topFromBottom)\n                         / dot(topFromBottom, topFromBottom), 0.0, 1.0 );\n    capsule.dist = length( topFromPosition - topFromBottom * height ) - radius;\n    return capsule;\n}\n   \n// renderScene: Creates objects according to their distance functions\n//              Adds model to scene by returning the calculated sum distance of all objects\n//    Position: A ray created using ray marching\n//    Color:    Output color\n// Sets up scene for model rendering by creating containers for Objects and using distance functions\n// to fill containers with data for each object being rendered in scene. Also uses union, difference,\n// and intersection functions to determine if space is being displayed, negated, or conjoined \n// Model reference: https://sketchfab.com/3d-models/classic-tron-lightcycle-a9eae73385234105b548b0e35a3e63a4\nsColoredObj renderScene(vec3 position, float time)\n{\n\n    // use Logic to build the correct distance\n\n    // front wheel done\n    sColoredObj d = OBJdifference(initSphere(vec4(-1.5, 1.0, 6.0, 1.0), 1.0, // Front wheel\n                  vec4(1.0, 0.5, 0.0, 1.0), position),\n                  initSphere(vec4(-1.5, 1.0, 5.1, 1.0), 0.8, // Front wheel negative space left\n                  vec4(1.0, 0.5, 0.0, 1.0), position));\n    d = OBJdifference(d,initSphere(vec4(-1.5, 1.0, 6.9, 1.0), 0.8, // Front wheel negative space right\n                  vec4(1.0, 0.5, 0.0, 1.0), position));\n    d = OBJunion(d, initSphere(vec4(-1.5, 1.0, 6.4, 1.0), 0.15, // Front wheel cap left\n                  vec4(1.0), position));\n    d = OBJunion(d, initSphere(vec4(-1.5, 1.0, 5.6, 0.0), 0.15, // Frot wheel cap right\n                  vec4(1.0), position));\n    d = OBJunion(d, initCylinder(position, vec3(0.0, 0.0, 0.4), vec3(0.0, 0.0, -0.4), vec4(-1.5, 1.0, 6.0, 1.0),\n                  0.9, vec4(0.0))); // Front wheel black\n    \n    // grey chasis\n    d = OBJunion(d, initBox(position, vec3(1.5, 0.65, 0.3), vec4(0.0, 1.0, 6.0, 1.0),\n                  vec4(0.7))); // body\n    d = OBJunion(d, initCylinder(position, vec3(0.0, 0.0, 0.4), vec3(0.0, 0.0, -0.4), vec4(1.4, 0.65, 6.0, 1.0),\n                  0.06, vec4(1.0, 0.5, 0.0, 1.0))); // foothold axel thing\n    d = OBJunion(d, initCone(position, vec3(0.0,0.0,0.0), vec3(1.4,0.0,0.0), vec4(-.7, 1.0, 6.0, 1.0),\n                  0.6, 0.2, vec4(0.7))); // Front wheel cone\n    d = OBJunion(d, initCone(position, vec3(0.0,-0.1,0.0), vec3(-.5,0.0,0.0), vec4(0.95, 0.87, 5.8, 1.0),\n                  0.2, 0.1, vec4(0.7))); // Left pipe bit\n    d = OBJunion(d, initCone(position, vec3(0.0,-0.1,0.0), vec3(-.5,0.0,0.0), vec4(0.95, 0.87, 6.2, 1.0),\n                  0.2, 0.1, vec4(0.7))); // right pipe bit);\n\td = OBJunion(d, initBox(position, vec3(1.0, 0.65, 0.02), vec4(1.7, 1.0, 5.72, 1.0),\n                  vec4(0.7))); // backwheel frame left\n    d = OBJunion(d, initBox(position, vec3(1.0, 0.65, 0.02), vec4(1.6, 1.0, 6.28, 1.0),\n                  vec4(0.7))); // backwheel frame right\n    d = OBJunion(d, initCylinder(position, vec3(0.5,0.3,0.0), vec3(-1.2,-0.5,0.0), vec4(2.2, 1.6, 6.0, 1.0),\n                  0.30, vec4(0.7))); // Back Wheel body cover);\n    d = OBJunion(d, initCone(position, vec3(0.0,0.0,-0.08), vec3(-.65,-0.15,0.0), vec4(2.65,1.7, 5.8, 1.0),\n                  0.2, 0.1, vec4(0.7))); // Left exhaust\n    d = OBJunion(d, initCone(position, vec3(0.0,0.0,0.08), vec3(-.65,-0.15,0.0), vec4(2.65,1.7, 6.2, 1.0),\n                  0.2, 0.1, vec4(0.7))); // right exhaust\n\n    \n    d = OBJdifference(d, initCylinder(position, vec3(0.55,0.3,0.0), vec3(-1.25,-0.5,0.0), vec4(2.2, 1.6, 6.0, 1.0),\n                  0.27, vec4(0.7))); //Back Wheel body cover negative\n    d = OBJdifference(d, initCylinder(position, vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, -1.0), vec4(2.6, 1.0, 6.0, 1.0),\n                  0.28, vec4(0.7))); //back wheel 'axis' negative\n    d = OBJdifference(d,initBox(position, vec3(0.5, 1.5, 0.5), vec4(3.1, 1.0, 6.0, 1.0),\n                  vec4(0.7))); // backwheel cutoff negative\n    d = OBJdifference(d, initBox(position, vec3(0.7, 0.8, 0.25), vec4(2.8, 1.0, 6.0, 1.0),\n                  vec4(0.7))); // backwheel cutoff negative\n\n\n    //orange body\n    sColoredObj top = OBJunion(initCylinder(position, vec3(0.0,0.0,0.2), vec3(0.0,0.0,-0.2), vec4(0.1, -3.6, 6.0, 1.0),\n                  6.0, vec4(1.0, 0.5, 0.0, 1.0)), // Top piece\n                  initCylinder(position, vec3(0.0,0.0,0.39), vec3(0.0,0.0,-0.39), vec4(0.1, -3.66, 6.0, 1.0),\n                  6.0, vec4(1.0, 0.5, 0.0, 1.0))); // Top main bit);\n    top = OBJintersect(top, initBox(position, vec3(2.3, 1.0, 0.9), vec4(0.0, 1.74, 6.0, 1.0),\n                  vec4(1.0, 0.5, 0.0, 1.0))); // Orange body base cuttoff negative\n    top = OBJdifference(top,initCone(position, vec3(0.0,0.0,0.0), vec3(1.6,0.0,0.0), vec4(-.78, 1.0, 6.0, 1.0),\n                  0.7, 0.2, vec4(1.0, 0.5, 0.0, 1.0))); // orage top front slant negative\n    top = OBJdifference(top,initBox(position, vec3(0.7, 0.5, 0.9), vec4(-1.76, 1.33, 6.0, 1.0),\n                  vec4(1.0, 0.5, 0.0, 1.0))); // orange body wheel negative\n\ttop = OBJdifference(top,initBox(position, vec3(0.7, 0.5, 0.9), vec4(0.4, 0.6, 6.0, 1.0),\n                  vec4(1.0, 0.5, 0.0, 1.0)));\n    top = OBJdifference(top,initCone(position, vec3(0.0,0.0,0.0), vec3(0.3,-0.7,0.0), vec4(0.48, 0.83, 6.0, 1.0),\n                  0.8, 0.8, vec4(1.0, 0.5, 0.0, 1.0))); // orage top front slant negative\n\ttop = OBJdifference(top,initBox(position, vec3(0.5, 0.8, 0.9), vec4(2.0, 0.6, 6.0, 1.0),\n                  vec4(1.0, 0.5, 0.0, 1.0)));\n    top = OBJdifference(top,initCylinder(position, vec3(0.5,0.5,0.0), vec3(-0.8,-0.2,0.0), vec4(2.44, 1.36, 5.4, 1.0),\n                  0.35, vec4(1.0, 0.5, 0.0, 1.0))); // orange body Back Wheel cover negative left\n    top = OBJdifference(top,initCylinder(position, vec3(0.5,0.5,0.0), vec3(-0.8,-0.2,0.0), vec4(2.44, 1.36, 6.6, 1.0),\n                  0.35, vec4(1.0, 0.5, 0.0, 1.0))); // orange body Back Wheel cover negative right\n\n    \n    // windows\n    sColoredObj windows = OBJunion(initSphere(vec4(2.6, 1.0, 6.0,0.0), 0.15, // back wheel cap\n                  vec4(1.0), position), \n                  initCapsule(position, vec3(0.5, 0.0, 0.0), vec3(-0.5, 0.0, 0.0), vec4(-0.4, 1.8, 5.45, 1.0), \n                  0.3, vec4(0.0))); // right window\n    windows = OBJunion(windows, initCapsule(position, vec3(0.5, 0.0, 0.0), vec3(-0.5, 0.0, 0.0), vec4(-0.47, 1.8, 6.45, 1.0), \n                0.3, vec4(0.0))); //left window\n    windows = OBJdifference(windows, initBox(position, vec3(1.3, 0.8, 1.25), vec4(-0.4, 0.99, 5.55, 1.0),\n                  vec4(0))); // Window lower cutoff\n    windows = OBJdifference(windows, initBox(position, vec3(1.3, 0.8, 1.25), vec4(1.2, 1.5, 5.55, 1.0),\n                  vec4(0))); // Window back cutoff\n    windows = OBJdifference(windows, initCone(position, vec3(0.0,0.0,0.0), vec3(1.2,0.0,0.0), vec4(-1.3, 2.4, 5.45, 1.0),\n                  0.6, 0.3, vec4(0.0))); // window left slant negative\n    windows = OBJdifference(windows, initCone(position, vec3(0.0,0.0,0.0), vec3(1.2,0.0,0.0), vec4(-1.3, 2.4, 6.45, 1.0),\n                  0.6, 0.3, vec4(0.0))); // window right slant negative\n\t\n    // trail\n    sColoredObj trail = OBJdifference( initBox(position, vec3(500.0, 0.8, 0.1), vec4(502.6, 1.0, 6.0, 1.0),\n                  vec4(mix(vec4(1.0),vec4(1.0, 0.5, 0.0, 1.0),position.y / 0.8))), // trail\n    initCylinder(position, vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, -1.0), vec4(2.6, 1.0, 6.0, 1.0),\n                  0.8, vec4(0.0)));\n    d = OBJunion(d, trail);\n\n\n    // back wheel\n    sColoredObj wheel = OBJdifference(initTorus(position, vec2(0.8,0.19), vec4(2.6, 1.0, 6.0, 1.0), vec4(1.0, 0.5, 0.0, 1.0)),\n                  initCylinder(position, vec3(0.0, 0.0, 0.4), vec3(0.0, 0.0, -0.4), vec4(2.6, 1.0, 6.0, 1.0),\n                  0.7, vec4(1.0, 0.5, 0.0, 1.0))); // Back Wheel Negative Space\n    wheel = OBJunion(wheel, initCylinder(position, vec3(0.0, 0.0, 0.02), vec3(0.0, 0.0, -0.02), vec4(2.6, 1.0, 6.0, 1.0),\n                  0.7, vec4(0.0))); // Back Wheel black\n    d = OBJunion(d, initSphere(vec4(2.6, 1.0, 6.0,0.0), 0.15, // back wheel cap\n                  vec4(1.0), position));\n                       \n    //combining subobjects\n    d = OBJunion(d, wheel);\n    d = OBJunion(d, top);\n\td = OBJunion(d, windows);\n    d = OBJunion(d, initPlane(vec4(1.0), position - vec3(0.08).y, time));\n        \n    return d;\n}\n\n// RayMarching Function: Draws scene by getting a distance for every object in the scene from the \n//                       Calculated position found from ray origin and ray direction\n//    color:             Output color\n//    eye:               ray origin\n//    marchingDirection: ray direction\n//    start:             Minimum distance ray can travel while searching for Objects\n//    end:               Maximum distance ray can travel while searching for Objects\nsColoredObj shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end, float time) {\n    //credit to https://www.shadertoy.com/view/4tcGDr\n    sColoredObj dist;\n    float depth = start;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        dist = renderScene(eye + depth * marchingDirection, time);\n        if (dist.dist < SURF_DIST) {\n            dist.dist = depth;\n\t\t\treturn dist;\n        }\n        depth += dist.dist;\n        if (depth >= end) {\n            dist.dist = end;\n\t\t\treturn dist;\n        }\n    }\n    dist.dist = end;\n\treturn dist;\n}\n\n// getNormal: Calculate normal for given rat\n//    p: A ray created using ray marching\n// \"ShaderToy Tutorial - Ray Marching for Dummies!\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/PGtv-dBi2wE\n// https://www.shadertoy.com/view/XlGBW3\nvec3 getNormal(vec3 p)\n{  \n    float d = renderScene(p, 0.0).dist;\n    vec2 e = vec2(0.01, 0.0);\n    \n    vec3 n = d - vec3(\n    renderScene(p - e.xyy, 0.0).dist,\n    renderScene(p - e.yxy, 0.0).dist,\n    renderScene(p - e.yyx, 0.0).dist);\n    \n    return normalize(n);\n}\n\n// calcLighting: calculates Lambertian and Blinn-Phong reflectance, and returns part of the summation of the final color\n//    light: the current Point Light\n//    position:     point on the sphere that we are drawing\n//    normal:       normal vector from point\n//    rayOrigin:    input ray origin\n//\t  viewVector:\tvector from point to camera\nvec4 calcLighting (in vec3 lightpos, in vec4 lightcolor, float lightintense, in vec3 position,\n                   in vec3 normal, in vec3 rayOrigin, in vec3 viewVector, in vec4 Objectcolor)\n{\n    //Taken from Demetri's Lab 4\n    // LAMBERTIAN REFLECTANCE\n    vec3 lightVector = lightpos.xyz - position; // get vector of position to the light\n\tfloat lightLength = length(lightVector); // get length of light vector\n    lightVector = lightVector / lightLength; // normalizes vector\n   \n    float diffuseCoefficient = max(0.0, dot(lightVector, normal)); // get coefficient\n   \n    float intensityRatio = lightLength/lightintense; // simplifying attenuation equation by doing this once\n    float attenuation = 1.0 / (1.0 + intensityRatio +\n                             (intensityRatio * intensityRatio)); // get attenuation\n    float Lambertian = diffuseCoefficient * attenuation; // final lambertian\n\n    // BLINN-PHONG REFLECTANCE\n   \n    float specular = max(0.0,dot(normal, normalize(viewVector + lightVector))); // get base specular coefficient\n    specular *= specular; // specularCoefficient^2\n    specular *= specular; // specularCoefficient^4\n    specular *= specular * specular * specular; // ^16\n    specular *= specular * specular * specular; // ^64\n\n    specular *= 4.0; // Blinn coefficient\n   \n    //return (Lambertian * vec4(normal * 0.5 + 0.5, 1.0) + specular) * lightcolor;\n    return (Lambertian * Objectcolor + specular) * lightcolor;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*\n\tCopyright 2020 Demetrius and Nathan\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\t\thttp://www.apache.org/licenses/LICENSE-2.0\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n/*\n    Credit to Andrew Hunt for advice on keyboard controls\n*/\n\n// Keyboard constants definition\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_W     = 87;\nconst int KEY_A     = 65;\nconst int KEY_S     = 83;\nconst int KEY_D     = 68;\nconst int KEY_Q     = 81;\nconst int KEY_E     = 69;\n\n\n// getKey: texel fetches input from keyboard\n//    channel: the channel that the keyboard is on, iChannel1\n//    key1:    first ASCII key\n//    key2:    second ASCII key (for WASD)\nfloat getKey(sampler2D channel, int key1, int key2)\n{\n    return texelFetch(channel, ivec2(key1, 0), 0).x + \n        texelFetch(channel, ivec2(key2, 0), 0).x;\n}\n\n//determines new movement and stores camera position in Buffer A\n// Controls: \n//    WS/Up Down arrows - Z axis\n//    AD/Left Right arrows - X axis\n//    QE - Y axis\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //get UV and fetch last recorded position\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 previouscoord = texture(iChannel0,uv);\n    \n    //get all inputs\n    float forward = getKey(iChannel1, KEY_UP, KEY_W);\n    float left = getKey(iChannel1, KEY_LEFT, KEY_A);\n    float back = getKey(iChannel1, KEY_DOWN, KEY_S);\n    float right = getKey(iChannel1, KEY_RIGHT, KEY_D);\n\tfloat up = getKey(iChannel1, KEY_Q, KEY_Q) * 0.5;\n\tfloat down = getKey(iChannel1, KEY_E, KEY_E) * 0.5;\n\n    //add inputs with previous position for new position\n    fragColor = previouscoord + vec4(right - left, up - down, forward - back, 0.0) * 0.1;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\tCopyright 2020 Demetrius and Nathan\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\t\thttp://www.apache.org/licenses/LICENSE-2.0\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n/*\n    Credit to Andrew Hunt for advice on keyboard controls\n*/\n\n//Sets up mouse interactivity\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get uv\n    vec2 invReso = 1.0 / iResolution.xy;\t\n    vec2 uv = fragCoord * invReso;\n\n    // sample previous mouse coordinate\n    vec4 mouse = texture(iChannel1,uv);\n    vec2 mousecurrent = mouse.xy;\n    vec2 mouseclick = mouse.zw;\n    \n    if (iMouse.z >= 0.0) // if mouse down\n    {\n        vec2 newmouse = iMouse.xy * invReso; // take in new mouse variables\n        vec2 newclick = abs(iMouse.zw) * invReso;\n        \n        // get centralized distance of mouse to clicked coord\n        vec2 mousefromclick = (newmouse - 0.5) - (newclick - 0.5);\n        vec2 radian = mouseclick - mousefromclick; // get difference from last frame\n\t\tfragColor = vec4(radian, mouseclick);\n    }\n    else\n    {\n        fragColor = vec4(mousecurrent, mousecurrent); // unchanged, return last frame\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}