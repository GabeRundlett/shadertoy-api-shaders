{
    "Shader": {
        "info": {
            "date": "1470577378",
            "description": "Thanks To: KukaTails - For Template Of Water.",
            "flags": 0,
            "hasliked": 0,
            "id": "Ml33RX",
            "likes": 3,
            "name": "Sky & Water (v2)",
            "published": 3,
            "tags": [
                "water",
                "sky",
                "distortionnoise"
            ],
            "usePreview": 0,
            "username": "Imsure1200q_1UWE130",
            "viewed": 957
        },
        "renderpass": [
            {
                "code": "#define pix gl_FragCoord.xy / iResolution.xy;\nconst vec4 SKY_COLOR = vec4(0.5, 0.6, 0.9, 1.0);\nconst vec4 CLOUD_COLOR = vec4(0.9, 0.7, 0.5, 1.0);\nconst vec4 CC = CLOUD_COLOR + 0.3;\n\nfloat Hash(vec2 p)\n{\n    float h = dot(p, vec2(17.1, 311.7));\n    return 1.0 - 2.0 * fract(sin(h) * 4358.5453);\n}\n\nfloat Noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = (f * f * (3.0 - 2.0 * f));\n    \n    return mix(mix(Hash(i + vec2(0.0, 0.0)),\n                   Hash(i + vec2(1.0, 0.0)), u.x),\n               mix(Hash(i + vec2(0.0, 1.0)),\n                   Hash(i + vec2(1.0, 1.0)), u.x), u.y);\n \n}\n\nvec2 VecNoise(vec2 point)\n{\n    vec2 res;\n    res.x = Noise(point);\n    res.y = Noise(point + vec2(iTime));\n    return res;\n}\n\n\nfloat DistortionNoise(vec2 point, float distortion)\n{\n    vec2 offset = point + vec2(0.5);\n    offset = VecNoise(point);\n    offset *= distortion;\n    point += offset;\n    return Noise(point);\n}\n\n\nfloat FbmNoise(vec2 p)\n{\n  const float octaves = 8.0;\n  const float lacunarity = 2.0;\n  const float H = 0.5;\n\n  float value = 0.0, k = 0.0;\n  for (float i = 0.0; i < octaves; ++ i) {\n    value += Noise(p) * pow(lacunarity, -H * i);\n    p *= lacunarity;\n    ++k;\n  }\n\n  float remainder = fract(octaves);\n  if (remainder >= 0.0) {\n    value -= remainder * Noise(p) - pow(lacunarity, -H * k);\n  }\n  return value;\n}\n\nfloat DistFbmNoise(vec2 p)\n{\n  const float octaves = 8.0;\n  const float lacunarity = 2.0;\n  const float H = 0.5;\n\n  float value = 0.0, k = 0.0;\n  for (float i = 0.0; i < octaves; ++ i) {\n    value += DistortionNoise(p, 1.0) * pow(lacunarity, -H * i);\n    p *= lacunarity;\n    ++k;\n  }\n\n  float remainder = fract(octaves);\n  if (remainder != 0.0) {\n    value += remainder * Noise(p) * pow(lacunarity, -H * k);\n  }\n  return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= length(uv);\n    //uv *= sqrt(uv);\n    //uv = vec2(length(uv));\n    uv = uv * 3.0 - 1.0;\n\tif( uv.y >= 0.3 )\n    {\n    const float threshold = 0.35;\n\n    float value = DistFbmNoise(2.0 * uv);\n    vec4 ct = mix(SKY_COLOR, mix(\n        CLOUD_COLOR, CC, smoothstep(threshold, 2.0, value)),\n                  smoothstep(threshold, 1.3, value));\n \n    fragColor = ct;\n    }\n    else{\n        uv.y -= uv.y * 2.0 - 1.0;\n        const float threshold = 0.351;\n        float value = DistFbmNoise(2.0 * uv);\n        vec4 ct = mix(SKY_COLOR - 0.1, \n                      CLOUD_COLOR,\n                      smoothstep(threshold, 1.3, value));\n        fragColor = ct;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}