{
    "Shader": {
        "info": {
            "date": "1698127802",
            "description": "A test pattern grid generator for projection and led displays. Lots of defines for color and shape parameters.\n\nWorks best with even resolutions.",
            "flags": 0,
            "hasliked": 0,
            "id": "ddyBWz",
            "likes": 4,
            "name": "Projection Alignment Grid",
            "published": 3,
            "tags": [
                "grid",
                "sdf",
                "projection",
                "testpattern",
                "alignment"
            ],
            "usePreview": 0,
            "username": "matthewwachter",
            "viewed": 246
        },
        "renderpass": [
            {
                "code": "// background color\n#define bg_c vec4(0.0, 0.0, 0.0, 1.0)\n\n// grid color\n#define grid_c vec4(.5, .5, .5, 1.0)\n\n// grid line width\n#define grid_w 2.0\n\n// grid vertical divisions\n// grid cross\n#define grid_s vec2(9.0, 0.0)                     \n\n// circlegrid color\n#define circlegrid_c vec4(0.5)\n\n// circlegrid line width\n// circlegrid size\n// circlegrid offset x\n// circle grid offset y\n#define circlegrid_s vec4(1.0, .25, 0.0, 0.0)\n\n// circle color\n#define circle_c vec4(1.0)\n\n// circle line width\n#define circle_w 2.0\n\n// TL to BR diagonal color\n#define diag1_c vec4(.5, 1.0, .75, 1.0)\n\n// BL to TR diagonal color\n#define diag2_c vec4(1.0, .5, .666, 1.0)\n\n// diagonal line width\n#define diag_w 2.0\n\n// horizontal centerline color\n#define centerh_c vec4(1.0, 1.0, .5, 1.0)\n\n// vertical centerline color\n#define centerv_c vec4(1.0, 1.0, .5, 1.0)\n\n// center line width\n#define center_w 2.0\n\n// rainbow line width\n// rainbow alpha\n// rainbow period\n// rainbow offset\n#define rainbow_s vec4(3.0, 1.0, 2.0, .17)\n\n// border color\n#define border_c vec4(.5, 1.0, .5, 1.0)\n\n// border line width\n#define border_w 2.0\n\n// logo color 1\n#define logo_c1 vec4(0.0, 0.0, 0.0, 1.0)\n\n// logo color 2\n#define logo_c2 vec4(1.0, 1.0, 1.0, 1.0)\n\n// logo color 3\n#define logo_c3 vec4(.5, 0.5, 0.5, 1.0)\n\n// logo type\n// logo size\n#define logo_s vec2(0.0, .1)\n\n// grid\nvoid grid(vec2 p, float px_size, inout vec4 fragColor)\n{\n    float gc = (1.0 - grid_s.y)*.5;\n    vec2 grid = p - round(p*grid_s.x)/grid_s.x;\n    grid *= grid_s.x;\n    float d = min(abs(grid.x), abs(grid.y));\n    vec2 cross = vec2(step(gc, abs(grid.x)), step(gc, abs(grid.y)));\n    d += max(cross.x, cross.y);\n    stroke(d, grid_c, fragColor, grid_s.x*grid_w*px_size);\n}\n\n// circle grid\nvoid circleGrid(vec2 p, float px_size, inout vec4 fragColor)\n{\n    p -= circlegrid_s.zw/grid_s.x;\n    vec2 cell = mod(p * vec2(grid_s.x), 1.0);\n    vec2 center = mod(vec2(.5), 1.0);\n    float radius = circlegrid_s.y;\n    vec2 dist = cell - center;\n    float d = length(dist) - radius;\n    strokeAA(d, circlegrid_c, fragColor, circlegrid_s.x*grid_s.x * px_size, length(fwidth(p*grid_s.x)));\n}\n\n// circle\nvoid circle(vec2 p, vec2 center, float radius, vec4 c, float px_size, inout vec4 fragColor)\n{\n    center = center + round(p);\n    \n    float d = length(p - center) - radius;\n    strokeAA(d, c, fragColor, circle_w * px_size, length(fwidth(p)));\n}\n\n// rainbow circle\nvoid rainbowCircle(vec2 p, vec2 center, float radius, vec4 c, float px_size, inout vec4 fragColor)\n{\n\tvec2 pq = vec2(atan(p.x, p.y) / TAU*rainbow_s.z + rainbow_s.w, length(p));\n\tfloat d = length(p - center) - radius;\n\tc = vec4(hsv2rgb(vec3(pq.x, 1., 1.)), 1.0);\n\tstrokeAA(d, c, fragColor, rainbow_s.x * px_size, length(fwidth(p)));\n}\n\n// horizontal center line\nvoid centerH(vec2 p, float px_size, inout vec4 fragColor)\n{\n    stroke(abs(p.x), centerh_c, fragColor, center_w*px_size);\n    p = mod(p, 1.0)-.5;\n    stroke(abs(p.x), centerh_c, fragColor, center_w*px_size);\n}\n\n// vertical center line\nvoid centerV(vec2 p, float px_size, inout vec4 fragColor)\n{\n    stroke(abs(p.y), centerv_c, fragColor, center_w*px_size);\n    p = mod(p, 1.0)-.5;\n    stroke(abs(p.y), centerh_c, fragColor, center_w*px_size);\n}\n\n// diagonal lines\nvoid diagonals(vec2 p, float px_size, float aspect, inout vec4 fragColor)\n{\n\tp += .5;\n\tp = mod(p, 1.0);\n\t//p = p - floor(p);\n\n\tfloat dist = abs(p.x - p.y);\n\tstrokeAA(dist, diag1_c, fragColor, diag_w*px_size, length(fwidth(p)));\n\t\n\tdist = abs(p.x + p.y)-1.0;\n\tstrokeAA(dist, diag2_c, fragColor, diag_w*px_size, length(fwidth(p)));\n\t//fragColor = vec4(vec3(dist), 1.0);\n}\n\n// render border\nvoid border(vec2 p, vec2 res, inout vec4 fragColor)\n{\n\tfloat d = min(min(p.x, 1.0-p.x)*res.x, min(p.y, 1.0-p.y)*res.y);\n\tfragColor = mix(fragColor, border_c, 1.0-step(border_w, d));\n}\n\n\n// mw logo\nvoid mwLogo(vec2 p, vec2 offset, float scale, float aspect, float px_size, inout vec4 fragColor)\n{\n\tp -= offset;\n\tp.y *= .6;\n\tp /= scale;\n\t\n\t\n\tfloat w = 20.0 * px_size;\n\t\n\tvec2 ra =vec2(0.5,0.5);\n\tfloat d1 = sdRhombus( vec2(p.x + .5, p.y), ra );\n\tfloat d2 = sdRhombus( vec2(p.x - .5, p.y), ra );\n\tfragColor = mix(fragColor, vec4(vec3(pow(min(d1+.95, d2+.95), 8.0)), 1.0)*logo_c3, (1.0-step(0.0, min(d1, d2)))*logo_c3.a);\n\tstrokeAA(min(d1, d2), logo_c2, fragColor, w, length(fwidth(p)));\n\tstrokeAA(min(d1+.1, d2+.1), logo_c2 * vec4(0.8), fragColor, w, length(fwidth(p)));\n\tstrokeAA(min(d1+.2, d2+.2), logo_c2 * vec4(0.6), fragColor, w, length(fwidth(p)));\n\tstrokeAA(min(d1+.3, d2+.3), logo_c2 * vec4(0.4), fragColor, w, length(fwidth(p)));\n\t\n\tfloat d3 = sdSegment(p, vec2(1.0, 0.0), vec2(-1.0, 0.0));\n\tstrokeAA(d3, logo_c2, fragColor, w, length(fwidth(p)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 vUV = fragCoord/iResolution.xy;\n    \n    \n    // resolution\n    vec2 res = iResolution.xy;\n    \n    // aspect ratio\n    float aspect = res.x / res.y;\n\t\n\t// -.5 to .5 coordinate space\n\tvec2 p = vUV.st-.5;\n\t\n\tvec2 logo_offset = vec2(0.0, 0.0);\n\t\n\t// pixel size\n\tfloat px_size = 0.0;\n\t\n\t// alignment for different aspect ratios\n\tif (aspect > 1.0)\n\t{\n\t\tp.x *= aspect;\n\t\tlogo_offset.x = (aspect>1.0+logo_s.y*2.0)?.5 : .25;\n\t\tpx_size = 1.0/res.y;\n\t} else {\n\t\tp.y /= aspect;\n\t\tlogo_offset.y = (aspect<1.0-logo_s.y*2.0)?.5 : .25;\n\t\tpx_size = 1.0/res.x;\n\t} \n\t\n\n\t\n\t// background color\n\tfragColor = bg_c;\n\t\n\t// square grid\n\tgrid(p, px_size, fragColor);\n\t\n\t// circle grid\n\tcircleGrid(p, px_size, fragColor);\n\t\n\t// big circles\n    circle(p, vec2(0), 0.5, circle_c, px_size, fragColor);\n    \n    // diagonal lines\n    diagonals(p, px_size, aspect, fragColor);\n    \n    // vertical center lines\n\tcenterV(p, px_size, fragColor);\n\t\n\t// horizontal center lines\n\tcenterH(p, px_size, fragColor);\n\t\n\t// rainbow circle\n    rainbowCircle(p, vec2(0), .333, vec4(1.0), px_size, fragColor);\n\n\t// border lines\n    //vec2 b_pos = vec2(vUV.x * aspect, vUV.y);\n    //b_pos = vUV.xy * res;\n    border(vUV.st, res, fragColor);\n    \n\n    // mw logo\n\tmwLogo(p, logo_offset, logo_s.y, aspect, px_size, fragColor);\n\tmwLogo(p, -logo_offset, logo_s.y, aspect, px_size, fragColor);\n\n\t\n\t//pxGrid(p, px_size, fragColor);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Íñigo Quílez\n// https://iquilezles.org/articles/distfunctions2d/\n\n#define     TAU 6.28318530717958647 // pi * 2\n#define     PI  3.14159265358979323 // pi\n\n// hsv to rgb\nvec3 hsv2rgb(vec3 c) {\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3. - 2. * rgb);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\n// sd polygon\nconst int N = 8;\nfloat sdPolygon( in vec2 p, in vec2[N] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n// sd segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// sd box\nfloat sdBox( vec2 p, vec2 b, vec2 o)\n{\n    p -= o;\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// sd circle\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n// sd rhombus\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n\n\treturn d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\n// sd distorted pill\nfloat sdDistortedPill(vec2 p, vec2 start, vec2 end, float radius, float power, float depth)\n{\n    p = -p;\n    vec2 dir = normalize(end - start);\n\n    vec2 localP = p - start;\n    float proj = dot(localP, dir);\n    float perpProj = dot(localP, vec2(-dir.y, dir.x));\n\n    float alongLine = clamp(proj, 0.0, length(end - start));\n    vec2 closestPoint = start + dir * alongLine;\n\n    float d = length(p - closestPoint) - radius;\n\n    float frequency = PI / length(end - start);\n    float sind = sin(frequency * alongLine);\n    sind = pow(sind, power);\n    sind *= depth*radius;\n    \n    return d + sind;\n}\n\n\n// stroke edge\nvoid stroke(float d, vec4 c, inout vec4 fragColor, float w)\n{\n    float m = 1.0-step(.5*w, abs(d));\n    fragColor = mix(fragColor, c, m*c.a);\n}\n\n// stroke edge with anti-aliasing\nvoid strokeAA(float d, vec4 c, inout vec4 fragColor, float w, float aa)\n{\n    float m = smoothstep(0.5 * (w + aa), 0.5 * (w - aa), abs(d));\n    fragColor = mix(fragColor, c, m*c.a);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}