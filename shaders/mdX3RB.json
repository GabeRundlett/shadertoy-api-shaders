{
    "Shader": {
        "info": {
            "date": "1666311205",
            "description": "An anaglyph stereo rendering of a pair of \"better 3d goggles\"\n\nInspired by https://xkcd.com/977/ : \"What your favorite map projection says about you\", particularly the entry on the Dymaxion projection.",
            "flags": 64,
            "hasliked": 0,
            "id": "mdX3RB",
            "likes": 4,
            "name": "better 3d goggles",
            "published": 3,
            "tags": [
                "anaglyph",
                "stereo",
                "xkcd"
            ],
            "usePreview": 0,
            "username": "mds2",
            "viewed": 291
        },
        "renderpass": [
            {
                "code": "#define RADIUS 1.0\n#define TOP 0.15\n#define BOTTOM -0.1\n#define SMOOTHING 0.025\n#define MAX_DIST 5.0\n#define THICK 0.1\n\nfloat bandSdf(in vec3 pt) {\n  float baseSphere = length(pt) - RADIUS;\n  if (baseSphere > abs(1.5 * (TOP - BOTTOM))) {\n    return baseSphere;\n  }\n  float chops = max(pt.z - TOP, BOTTOM - pt.z);\n  chops = checked_smooth_min(max(pt.x - 0.25 * TOP, -0.25 * TOP - pt.x), chops, 4.0 * SMOOTHING);\n  chops = max(chops, BOTTOM - pt.z);\n  return checked_smooth_max(baseSphere, chops, SMOOTHING);\n}\n\nfloat socketSdf(in vec3 pt) {\n  vec3 center = vec3(0.4 * RADIUS, -0.866 * RADIUS, 0.5 * (TOP + BOTTOM));\n  float d = length(vec3(abs(pt.x), pt.yz) - center);\n  float spheres = d - abs(1.5 * (TOP - BOTTOM));\n  return checked_smooth_max(spheres, -0.866 * RADIUS - THICK - pt.y, SMOOTHING);\n}\n\nfloat sdf(in vec3 pt) {\n  float frame = bandSdf(pt);\n  if (frame > abs(1.5 * (TOP - BOTTOM))) {\n    return frame;\n  }\n  float outer = checked_smooth_min(socketSdf(pt), frame, 4.0 * SMOOTHING);\n  if (outer > THICK + SMOOTHING) {\n    return outer + SMOOTHING;\n  }\n  float withEyes = checked_smooth_max(outer, -(length(pt) + THICK - RADIUS), SMOOTHING);\n  return checked_smooth_max(withEyes, 3.0 - length(pt - vec3(0.0, 0.0, -3.0)) - THICK - BOTTOM, SMOOTHING);\n}\n\nvec3 surfNorm(in vec3 pt) {\n  float f = sdf(pt);\n  const float h = 0.01;\n  return normalize(\n           vec3(\n             sdf(pt + vec3(h, 0.0, 0.0)) - f,\n             sdf(pt + vec3(0.0, h, 0.0)) - f,\n             sdf(pt + vec3(0.0, 0.0, h)) - f));\n}\n\nfloat castRay(in vec3 orig, in vec3 dir, out float accum) {\n  float along = 0.0;\n  accum = 0.0;\n  for (int i = 0; i < 100; ++i) {\n    vec3 pt = orig + along * dir;\n    float dist = sdf(pt);\n    if (abs(dist) < 1.0e-5) {\n      return along;\n    }\n    accum = accum + 0.3 / max(dist, 0.1);\n    along = along + 0.3 * dist;\n    if (along > MAX_DIST) {\n      return along;\n    }\n  }\n  return MAX_DIST * 1.01;\n}\n\nfloat brightness(in vec2 fragCoord, in float eye )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float noise = texture(iChannel0, 2.0 * uv).r;\n    \n    vec3 orig = vec3(eye, -3.1, 0.1 * RADIUS);\n    \n    vec3 dir = normalize(vec3(uv.x, -0.8, uv.y + 0.1 * RADIUS) - orig);\n    vec3 light = normalize(vec3(0.2, -1.0, 0.1));\n    \n    float ct = cos(0.2);\n    float st = sin(0.2);\n    mat3 pitch = mat3(1.0, 0.0, 0.0,\n                      0.0, ct, st,\n                      0.0, -st, ct);\n    \n    ct = cos(0.5 * iTime);\n    st = sin(0.5 * iTime);\n    \n    mat3 twist = mat3(ct, st, 0.0,\n                      -st, ct, 0.0,\n                      0.0, 0.0, 1.0);\n                      \n    orig = orig * pitch * twist;\n    dir = dir * pitch * twist;\n    light = light * pitch * twist;\n    \n    float glowIntegral;\n    \n    float noiseBump = 0.15 * noise;\n    noiseBump = noiseBump;\n    \n    float dist = castRay(orig + noiseBump * dir, dir, glowIntegral) + noiseBump;\n\n    // Time varying pixel color\n    float col = (0.004 * max(glowIntegral, 3.0));\n    \n    if (dist < MAX_DIST) {\n        vec3 n = surfNorm(orig + dist * dir);\n        vec3 bounce = normalize(reflect(dir, n));\n        float lightDot = dot(bounce, light);\n        col += 1.5 * smoothstep(0.95, 1.0, lightDot);\n    }\n\n    // Output to screen\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  const float eyeHalfDist = 0.15;\n  fragColor = vec4(brightness(fragCoord, -eyeHalfDist), vec2(brightness(fragCoord, eyeHalfDist)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 32186,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/mds/beepbox-loop-minor-slide"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**\n * standard blend func, courtesy IQ\n */\nfloat conventional_smin(in highp float a, in highp float b, in highp float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/** more expensive, but smoother, blend funcs */\nfloat super_smooth_max(in highp float a, in highp float b, in highp float k) {\n  // return 0.25 * k * log(exp(4.0 * a / k) + exp(4.0 * b / k));\n  return 0.1732802*k*log2(exp2(5.771*a/k) + exp2(5.771*b/k));\n}\n\nfloat super_smooth_min(in float a, in float b, in float k) {\n  return -super_smooth_max(-a, -b, k);\n}\n\n/** best of both worlds */\nfloat checked_smooth_min(in highp float a, in highp float b, in highp float k) {\n  float val = conventional_smin(a, b, k);\n  if (abs(val) < 4.0 * k) {\n    return super_smooth_min(a, b, k);\n  }\n  return val;\n}\n\nfloat checked_smooth_max(in highp float a, in highp float b, in highp float k) {\n  return -checked_smooth_min(-a, -b, k);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}