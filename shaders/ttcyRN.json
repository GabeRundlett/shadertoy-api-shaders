{
    "Shader": {
        "info": {
            "date": "1608587631",
            "description": "potato",
            "flags": 0,
            "hasliked": 0,
            "id": "ttcyRN",
            "likes": 30,
            "name": "Day 368",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 567
        },
        "renderpass": [
            {
                "code": "#define planetSz 34.\n#define atmoSz 15.\n#define pi acos(-1.)\n\n#define tau (2.*pi)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p - 0.5*a,a) - 0.5*a\n\n#define iMouse (iMouse.y < 10. ? iResolution.xy/2. : iMouse.xy)\nvec2 dmin(vec2 a, float b, float cmp){return a.x < b ? a : vec2(b,cmp);}\n\n// PBR atmospheric scattering, learned from Sebastian Lague https://www.youtube.com/watch?v=DxfEbulyFcY\n// ACES from knarkowitz\n// cheap noise from nimitz\n// voronoi, smoothmin from iq\n// noise from dave hoskins\n    \nfloat cloudsLowerLimit = planetSz + 13.;\nfloat cloudsHigherLimit = planetSz + 27.;\nfloat dland, dsea;\nbool marchInsideSea = false;\n\nfloat fa;\n\nfloat valueNoiseCheap(in vec3 p,float pw)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod( iChannel0, (tap+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rz.x, rz.y, fp.z );\n}\n\n\n// do not use texture\n//#define FULL_PROCEDURAL\n\n#ifdef FULL_PROCEDURAL\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\n#else\nvec3 hash( vec3 x )\n{\n\treturn texture( iChannel0, (x.xy+vec2(3.0,1.0)*x.z+0.5)/256.0, -100.0 ).xyz;\n}\n#endif\n\n// returns closest, second closest, and cell id\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\nfloat fbma(vec3 p){\n\n    vec3 op = p;\n    float n = 0.;\n    p *= 0.25;\n    fa = valueNoise(p,1.); \n    \n    float fb = valueNoise(p*2.,1.);\n    \n    \n    p.x += fb*1.2 ;\n    p.z += fb*.4 ;\n    float fd = valueNoise(p*9.8,1.);\n    \n    float fc = valueNoise(p*15.2,1.);\n    \n    float v = voronoi(op*0.1).x; \n\n    //fa += v*(1.2-v)*0.4;\n        \n\n    n += fa*3.4 + fd*0.05; /*fa*/;// + valueNoise(op*5.8,1.)*0.0;\n    \n    n += valueNoise(op*20.,1.)*0.002;\n    \n    n *= 1.2;\n    \n    return n;\n}\n\nfloat fbmsea(vec3 p){\n    float d = 0.;\n    vec3 modul = normalize(p);\n    //vec3 v = voronoi(p*1. + modul); \n    //d += (v.x)*(1.-v.x)*0.1;\n    d += valueNoise(p*0. + modul*(30.9 ) + vec3(0,iTime*1.,0),1.)*.2;\n    \n    return d;\n}\n\nfloat mapClouds(vec3 p){\n    float rotEnv = 0.125*iTime;\n    float currHeight = length(p);\n    \n    p.yz *= rot(rotEnv);\n    \n    \n    p *= 0.5;\n    float cloudsRange = (cloudsHigherLimit - cloudsLowerLimit)*0.494;\n    float cloudsMid = cloudsLowerLimit + cloudsRange;\n    \n    float f = valueNoiseCheap(p*0.25,1.);\n    \n    f += valueNoiseCheap(p*0.51,1.)*0.325;\n    f += valueNoiseCheap(p*1.005,1.)*0.254;\n    f += valueNoiseCheap(p*2.04,1.)*0.105;\n    \n    f *= pow(valueNoiseCheap(p*0.2 + iTime*0.2,1.)*1.,2.9);\n    \n    f = smoothstep(0.,1.,f*1.2);\n    \n    f *= pow( smoothstep( 1.,0., abs(currHeight - cloudsHigherLimit + cloudsRange)/cloudsRange*0.94), 0.99);\n    \n    return f * 1.;\n}\n\n\nfloat sdRocks(vec3 _p, float md, float s){\n  vec4 p = vec4(_p,1.);\n  \n  p.yw *= rot(0.4);\n  p = abs(p);\n  p.xz *= rot(0.4);\n  p = abs(p);\n  \n  p.xy *= rot(2.4);\n  p = abs(p) - 1.4;\n  \n  p.yz *= rot(.2);\n  p = abs(p);\n  p = pmod(p,md);\n  \n  p = abs(p) - s;\n  return max(p.x,max(p.y,max(p.z,p.w))) ;\n}\n\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    \n    float rotEnv = 0.125*iTime;\n    p.yz *= rot(rotEnv);\n    if(!marchInsideSea){\n        dsea = length(p) - planetSz - 2.8 - fbmsea(p*1.) ;\n        d = dmin(d, dsea,2.);\n    }\n    dland = length(p) - planetSz - fbma(p)*1.;\n    d = dmin(d, dland,1.);\n    \n    p.yx *= rot(0.5);\n    p.xz *= rot(0.5);\n    //float drocks = sdRocks(p, 14.4, 3.8);\n    //drocks = opSmoothSubtraction( -drocks, -(-length(p) + planetSz + 4.5), 1.2 );\n    \n    //d = dmin(d, drocks,3.);\n    \n    \n    d.x *= 0.75;\n    return d;\n}\n\nvec3 getNormala(vec3 p){\n    vec2 t = vec2(0.01,0.);\n    return normalize(map(p).x - vec3(\n        map(p - t.xyy).x,\n        map(p - t.yxy).x,\n        map(p - t.yyx).x\n    ));\n}\n\n\nvec3 getNormal(vec3 p){\n    vec4 vals;\n    for(int i = 0; i < 4 + min(iFrame,0); i++){\n        if(i == 3){\n            vals[3] = map(p).x;\n        }\n            \n        vals[i] = map(p - vec3(float(i%3==0),float(i%3==1),float(i%3==2)) * 0.001 ).x; \n    \t\n    }\n    \n    return normalize(vals.w - vals.xyz);\n}\nvec3 getSun(vec2 uv, vec2 sunUV, vec2 sunUVPos,vec3 sunCol){\n    \n    vec2 sunUVB = sunUV;\n    \n    sunUV -= sunUVPos;\n    vec3 sunRays = 0.4*sunCol * smoothstep(0.035*(1. + smoothstep(1.,0.,abs(sunUV.x)) ) ,0.,abs(sunUV.y))*smoothstep(0.5,0.,abs(sunUV.x));\n\n    for(float i = 0.; i < 8.; i++){\n        sunUV *= rot(pi/8./1.);\n        sunRays += .1* (sunCol) * smoothstep(0.04 + sin(i*pi/4.)*0.01,0.,abs(sunUV.y))*smoothstep((0.2 + sin(i*pi/4.)*0.1)*1.5,0.,abs(sunUV.x));\n    }   \n    sunUV = sunUVB - sunUVPos;\n    vec3 flares = vec3(0);\n    vec2 toMid = sunUVPos;\n    vec2 dirToMid = -normalize(toMid);\n    float lenToMid = length(toMid);\n\n    for(float i = 0.; i < 12.; i++){\n          sunUV -= 2.*lenToMid*dirToMid/12.;\n          float dfl = length(sunUV) - (0.1 + 0.1*sin(i*5.))*0.5;\n          dfl *= 0.5;\n          vec3 flare = 0.01*(sunCol)*smoothstep(0.02,0.,dfl);\n          flare += 0.003*(sunCol*sunCol)*smoothstep(0.01,0.,abs(dfl - dFdx(uv.x)));\n          flares += flare*abs(sin(i*10.));\n    }   \n    \n    \n    return sunRays + flares*2.;\n}\n\n#define itersAtmo 10.\n#define itersOptic 10.\n\nfloat densFalloff = 5.;\n\nfloat atmosphericDensity( vec3 p){\n    float fact = (length(p) - planetSz -0.2  )/atmoSz;\n    fact = max(fact, 0.001);\n    return exp(-fact*densFalloff)*pow((1. - fact),0.04);//*pow(smoothstep(0.95,0.84,fact),1.);\n}\n\nfloat opticalDepth(vec3 p, vec3 rd, float len){\n    float stSz = len / (itersOptic-1.);\n    float depth = 0.;\n    for(float opticIdx = 0.; opticIdx < itersOptic; opticIdx++ ){\n        depth += atmosphericDensity(p) * stSz;\n        p += rd*stSz;\n     }\n    return depth;\n}\n\n\nconst float redLightLen = 650.;\nconst float greenLightLen = 530.;\nconst float blueLightLen = 440.;\n\nconst float transStrength = 0.7;\n\nvec3 scatteringCoefficients = transStrength*vec3(\n    pow(400./redLightLen,4.),\n    pow(400./greenLightLen,4.),\n    pow(400./blueLightLen,4.)\n);\nvec3 getAtmosphere(vec3 ro, vec3 rd, out float opticalDepthView, float t, bool hit, vec3 sunPos){\n    vec3 accumAtmo = vec3(0);\n    float atmoMarchLen = 0.;\n    \n    vec3 p = ro;\n    //sunPos += offs;\n    \n    //p += offs*1.;\n    \n    \n    if(hit){\n        atmoMarchLen = t;\n    } else {\n        atmoMarchLen = sphIntersect( p, rd, vec3(0), planetSz + atmoSz ).y;\n    }\n    float stepSz = atmoMarchLen/(itersAtmo - 1.);\n    \n\n    for(float atmoIdx = 0.; atmoIdx < itersAtmo ; atmoIdx++ ){\n        vec3 dirToSun = normalize(sunPos - p);\n        float lenSunDirToEndOfAtmosphere = sphIntersect( p, dirToSun, vec3(0), planetSz + atmoSz ).y;\n        float lenViewDirToEndOfAtmosphere = sphIntersect( p, -rd, vec3(0), planetSz + atmoSz ).y;\n        \n        float opticalDepthSun = opticalDepth(p, dirToSun, lenSunDirToEndOfAtmosphere);\n        opticalDepthView = opticalDepth(p, -rd, stepSz*atmoIdx);\n        \n        float localDens = atmosphericDensity(p);\n        \n\n        vec3 transmittance = exp(-(opticalDepthSun + opticalDepthView) * scatteringCoefficients);        \n        accumAtmo += transmittance * localDens * scatteringCoefficients * stepSz;\n        \n        p += rd * stepSz;\n    }\n    \n    return accumAtmo;\n}\n\n\n\nvec3 getRdSpherical(vec3 ro,vec2 uv){\n    \n    // polar coords\n    uv = vec2(atan(uv.y,uv.x),length(uv));\n    uv += 0.5;\n    uv.y *= tau/2.;\n    \n    // parametrized sphere\n    vec3 offs = vec3(cos(uv.y)*cos(uv.x),sin(uv.y),cos(uv.y)*sin(uv.x));\n    \n    // insert camera rotations here\n    offs.yz *= rot(-(1. + sin(iTime)*0.)*pi);\n    \n    vec3 lookAt = ro + offs;\n    \n    return normalize(lookAt - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0);\n    \n    ro.y += planetSz + 2.2 + iMouse.y/iResolution.y*atmoSz*.5;\n    \n    map(ro);\n    ro.y += fa*1.9 ;\n    \n    #define pump(a,b) (floor(a) + pow(fract(a),b))\n    float sphericalEnv = cos(pump(iTime*0.06,20.)*pi + pi)*0.5 + 0.5; \n    \n    sphericalEnv = 0.;\n    \n    vec3 rd = normalize(vec3(uv,1));\n    rd = mix(rd,getRdSpherical(ro,uv),sphericalEnv);\n    \n    float rotEnv = 0.25*iTime;\n    rd.yz *= rot(0.25*(1.-sphericalEnv));\n    //rd.yz *= rot(rotEnv);\n        \n    vec3 p = ro;\n    \n\n    float t = 0.;\n    bool hit = false;\n    \n    vec3 albedo = vec3(1.,0.9,0.6);\n    // Marching\n    \n    vec2 d;\n    for(int i = 0; i < 130 ; i++){\n        d = map(p);\n        \n        if(d.x < 0.02){\n            hit = true;\n            break;\n        } else if (t > 29.){\n            break;\n        }\n        \n        p = ro + rd*(t += d.x);\n    }\n    float seaDepthFactor = 0.;\n    vec3 seaHitP = p;\n    float tSea = 0.;\n    if (hit && d.y == 2.){\n        // Sea marching\n        marchInsideSea = true;\n        seaDepthFactor = smoothstep(1.,2.6,fa*2.);\n        albedo = mix(vec3(0.,0.5,1)*0.9,vec3(0.21,0.2,0.6),seaDepthFactor);\n        for(int i = 0; i < 20; i++){\n            vec2 d = map(p);\n\n            if( d.x < 0.004){\n                hit = true;\n                marchInsideSea = false;\n\n                break;\n            }\n\n            p = seaHitP + rd*(tSea += d.x);\n        }\n\n    \n    }\n    \n    vec3 sunPos = normalize(vec3(.9,2.4,2));\n    //sunPos.yz *= rot(sin(iTime*0.5)*1.5);\n    float spmd = sin(iTime*0.5)*1.5;\n    sunPos.yz += vec2(sin(spmd),cos(spmd));\n    \n    \n    //sunPos.xz *= rot(sin(iTime));\n    sunPos *= (planetSz + 50.);\n    \n    vec3 sunDir = normalize(sunPos - p);\n    \n    vec3 sunCol = vec3(0.9,0.9,0.9)*0. + vec3(1,0.9,0.7);\n        \n    float depthView; \n    vec3 atmosphere = getAtmosphere( ro, rd, depthView, t, hit, sunPos);\n    \n    \n    // Shading\n    \n    if(hit){\n        \n        marchInsideSea = true;\n        vec3 n = getNormal(p);\n        marchInsideSea = false;\n\n        vec3 hf = normalize(sunDir + n);\n        float diff = max(dot(n,sunDir),0.);\n        float spec = pow(max(dot(n,hf),0.),32.);\n        \n        vec3 groundAlbedo = vec3(0.6,1.2,0.4)*1.;\n        groundAlbedo = vec3(0.4,1.2,0.4)*1.;\n        \n        vec3 sandAlbedo = vec3(0.86,0.8,0.5)*1.6;\n        groundAlbedo = mix(sandAlbedo, groundAlbedo,smoothstep(0.,0.6,length(p) - planetSz - 2.9));\n        #define SSS(a) clamp(map(p + sunDir).x/a,0., 1.)\n        float sssfact = SSS(0.5)*SSS(4.5)*4.5;\n        //sssfact = 1.;\n        vec3 groundColor = groundAlbedo*(diff + 0.03 + sssfact*(1. + diff)*0.1)*(sunCol*0.6 + atmosphere) + spec*0.05*(sunCol + atmosphere);\n\n        if (d.y == 3.){\n            groundColor = 0.2*sandAlbedo*(diff + 0.03)*(sunCol + atmosphere) + spec*0.4*sunCol;\n            col += groundColor;\n        }\n        \n        if(d.y == 1.){\n            col += groundColor;\n        } else if (d.y == 2.){\n            \n            vec3 seaN = getNormal(seaHitP);\n            \n            vec3 seaSunDir = normalize(sunPos - seaHitP);\n    \n            vec3 seaHf = normalize(seaSunDir + seaN);\n            float seaDiff = max(dot(seaN,seaSunDir),0.);\n            float seaSpec = pow(max(dot(seaN,seaHf),0.),22.);\n            float seaFres = pow(1. - max(dot(seaN,-rd),0.),5.);\n            \n            vec3 vP = seaHitP;\n            vP.yz *= rot(0.125*iTime);\n            float foam = voronoi(normalize(vP)*(136. + sin(iTime*0.05)*40.)*0.4 + vP).x;\n            \n            foam *= pow(valueNoiseCheap(normalize(vP)*(136. + sin(iTime*0.3)*40.)*0.1,1.), 1.2 ) ;\n            //v *= 1. - v;\n            col += (albedo + smoothstep(0.1,0.,dland - 0. - foam))*(seaDiff*0.5 + 0.1)*(sunCol + atmosphere)*0.8 \n            + (seaSpec + seaFres)*0.2*(sunCol*0.3 + 0.2*atmosphere + albedo*0.4);\n            col *= 1. + seaDepthFactor*groundColor*26.;\n        }\n    }\n    \n    // Atmosphere\n    \n    atmosphere *= 1.-exp(-t*0.2);\n\n    \n    if(hit){\n       atmosphere *= 1.-pow(exp(-(t + tSea*2.)*0.05 ),2.);\n    }\n    \n    col = col * exp(-depthView) + atmosphere; \n    \n    //col += accumAtmo*1.;\n    \n    // Clouds\n    \n    float cloudSteps = 26.;\n    \n    float currH = length(ro);\n    \n    \n    \n    vec2 lowerSphere = sphIntersect( ro, rd, vec3(0), cloudsLowerLimit );\n    vec3 lowerLimitP = ro + rd * lowerSphere.y;\n    \n    \n    //if(currH > cloudsLowerLimit && currH < cloudsHigherLimit) {\n    if(currH > cloudsLowerLimit  ) {\n      \n        //lowerLimitP = ro;\n    }\n    \n    vec3 higherLimitP = lowerLimitP + rd * sphIntersect( lowerLimitP, rd, vec3(0), cloudsHigherLimit ).y;\n    \n    vec3 cloudP = lowerLimitP;\n    \n    float cloudLength = length(higherLimitP - lowerLimitP); // TODO: can make this cheaper\n    float cloudStepSz = cloudLength/(cloudSteps);\n    \n    float cloudDensTotal = 0.;\n    vec3 cloudAccum = vec3(0.);\n    \n    \n    for(float i = 0.; i < cloudSteps; i++){\n        float d = mapClouds(cloudP);\n        \n        sunDir = normalize(sunPos - cloudP);\n        float difffact = clamp( d*1. - mapClouds(cloudP + sunDir*1.4)*1.1 , 0., 1. );\n        vec3 diff = mix( atmosphere*0.1 + vec3(0.04,0.11,0.2)*(0.4 - smoothstep(0.,1.,1. - atmosphere*1.8)*0.4), (vec3(1,0.9,0.9)*1. + sunCol*0.4 + atmosphere*.4)*0.5, difffact );\n        vec3 absorption = mix( vec3(1,0.9,0.8), vec3(1,0.9,0.7)*0.5, clamp( cloudDensTotal*0.5, 0., 1. ) );\n        vec3 fringe = vec3(0.9,0.8,0.5)*clamp( 1. - d*4., 0.,1.);\n        \n        d = d*(1.-cloudDensTotal)*cloudStepSz;\n        \n        cloudDensTotal += d;\n        cloudAccum += d*(diff*3.7*absorption + fringe*(0.1 + diff*0.9)*2.64);\n\n        // map(cloudP).x < 0.\n\n            \n        if( cloudDensTotal > 1.){\n            break;\n        }\n        cloudP += rd*cloudStepSz;\n    }\n    if (!hit){\n        col = mix(col,cloudAccum , pow(clamp(cloudDensTotal*1. - 0.,0.,1.),5.));\n    }\n    \n    // sun \n    \n    //sunPos.yz *= rot(0.25);\n    \n    sunPos.yz *= rot(0.25*(1.-sphericalEnv));\n    vec2 sunUV = mix( uv, uv+2000., sphericalEnv);\n    \n    vec3 sun = vec3(0);\n    vec3 sunDirNormalized = normalize(sunPos - ro);\n    //sunDirNormalized = mix( sunDirNormalized, getRdSpherical(ro, sunUV), sphericalEnv);\n    sunDirNormalized = mix( sunDirNormalized, getRdSpherical(ro, sunDirNormalized.xy), sphericalEnv);\n    \n    \n    if (!hit){\n        sun += .5* smoothstep(1.,0.,length(sunUV - sunDirNormalized.xy) + .44)*vec3(1,0.6,0.4);\n        sun += .5* smoothstep(0.5,0.,length(sunUV - sunDirNormalized.xy) + .24)*vec3(2,0.9,0.4);\n        sun += smoothstep(0.08,0.,length(sunUV - sunDirNormalized.xy) - .03)*vec3(1,0.8,0.9);\n    }\n    float sunCloudBlend = smoothstep( 0. ,1. , 1. - cloudDensTotal*0.8 );\n    col += sun*sunCloudBlend;\n    \n    //sphericalEnv\n    float sunRaysBlend = smoothstep(0.,1.,  \n        mix(\n            (sunDirNormalized.y +  0.24 - smoothstep(0.,0.4,abs(sunDirNormalized.y) - 0.4 ) )*4.,\n            ( 2.4 - length(sunUV - sunDirNormalized.xy) )*19.*0. + 0.,\n            sphericalEnv\n            ))\n            ;\n    col += sunRaysBlend*sunCloudBlend*getSun(uv, sunUV, sunDirNormalized.xy, sunCol*0.2 + vec3(1,0.6,0.4)*0.8);\n    col = mix(col,smoothstep(0.,1.,col*1.6),0.5);\n    col = max(col,0.);\n    col = mix(acesFilm(col), col, 0.9);\n    col *= 1. - dot(uv,uv*0.4)*2.1;\n    \n    col = pow(col,vec3(0.454545));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    //return -b+h;\n    //return max(max(-b-h,0.),max(-b+h,0.));\n    return vec2( -b-h, -b+h );\n}\n\n\nfloat hash13(vec3 p3){\n    p3 = fract((p3)*0.1031);\n    p3 += dot(p3, p3.yzx  + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat valueNoise(vec3 uv,float pw){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    fd = pow(fd,vec3(pw));\n    \n    float ibl = hash13(id + vec3(0,-1,0));\n    float ibr = hash13(id + vec3(1,-1,0));\n    float itl = hash13(id + vec3(0));\n    float itr = hash13(id + vec3(1,0,0));\n    \n    \n    float jbl = hash13(id + vec3(0,-1,1));\n    float jbr = hash13(id + vec3(1,-1,1));\n    float jtl = hash13(id + vec3(0,0, 1));\n    float jtr = hash13(id + vec3(1,0, 1));\n    \n    \n    float ibot = mix(ibl, ibr, fd.x); \n    float iup = mix(itl, itr, fd.x);\n    float jbot = mix(jbl, jbr, fd.x);\n    float jup = mix(jtl, jtr, fd.x);\n    \n    float i = mix(ibot, iup, fd.y);\n    float j = mix(jbot, jup, fd.y);\n    \n    return mix(i, j, fd.z); \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}