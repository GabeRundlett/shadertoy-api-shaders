{
    "Shader": {
        "info": {
            "date": "1633500478",
            "description": "My first experiments with refraction. pretty pleased with how it turned out. \n\nuse mouse to zoom out",
            "flags": 0,
            "hasliked": 0,
            "id": "NscSzB",
            "likes": 33,
            "name": "Radiant Ember Orb",
            "published": 3,
            "tags": [
                "raymarching",
                "waves",
                "refraction",
                "particles",
                "orb"
            ],
            "usePreview": 0,
            "username": "Tater",
            "viewed": 792
        },
        "renderpass": [
            {
                "code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pi 3.1415926535\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n\n#define elon(p,h) (p-clamp(p,-h,h))\n\n//Enable exit ray\n#define refraction2\n\n\n//iq octohedron\nfloat oct( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\n\nfloat torus (vec3 p, vec2 b){\n  vec2 d = vec2(length(p.yz)-b.x,p.x);\n  return length(d)-b.y;\n}\nfloat torus2 (vec3 p, vec2 b){\n  vec2 d = vec2(length(p.yx)-b.x,p.z);\n  return length(d)-b.y;\n}\nfloat glow = 0.;\nfloat glow2 = 0.;\n\nbool inside = false;\nvec2 map(vec3 p){\n    float t= iTime;\n    vec3 po2 = p;\n    vec2 a = vec2(1.);\n    vec2 b = vec2(2.);\n    //Swing\n    p.y-=7.0;\n    p.xy*=rot(sin(t*2.0*pi/3.)*0.28);\n    p.y+=7.0;\n    vec3 po = p;\n    //Glass Displacment\n    p+=t*0.2;\n    float dis = sin(p.x*5.)*sin(p.y*5.)*sin(p.z*5.)*0.02;\n    p = po;\n    //Glass ball\n    a.x = length(p)-1.0+dis;\n    glow2+=0.5/(0.5+a.x*a.x);\n    a.x*=0.85;\n    if(inside){\n        //Octohedron\n        p.xz*=rot(t*0.8);\n        b.x = oct(p,0.3)-0.02;\n        \n        //Mini Octohedron\n        float s = sign(p.x*p.y*p.z);\n        p = abs(p)-0.25+sin(t)*0.05;\n        p.xz*=rot(-t*s*2.0);\n        b.x = min(b.x, oct(p,0.05)-0.01);\n\n        p = po;\n        //Particles\n        p.xz*=rot(t);\n        p.y-=t;\n        float m = 0.5;\n        vec3 id = floor(p/m)-0.5;\n        p.y+=sin(id.x*id.z)*4.0;\n\n        p = pmod(p,vec3(m));\n        b.x*=0.9;\n        b.x = min(b.x,length(p));\n\n        b.x = max(a.x,b.x);\n        glow+=0.005/(0.001+b.x);\n\n        a.x = max(a.x,-b.x);\n\n        a=(abs(a.x)<abs(b.x))?a:b;\n    }\n    //chain\n    b.y = 3.0;\n    float scl = 0.6;\n    float m2 = 1.5*scl;\n    po.y-=7.5*scl;\n    po.xz*=rot(t*0.8);\n    p = po;\n\n    p.y = pmod(max(p.y,-m2*4.),m2);\n    p.y = elon(p.y,0.3*scl);\n    b.x = torus(p,vec2(0.2,0.1)*scl);\n    \n    p = po;\n    p.y+=0.75*scl;\n    p.y = pmod(max(p.y,-m2*4.),m2);\n    p.y = elon(p.y,0.3*scl);\n    b.x = min(b.x,torus2(p,vec2(0.2,0.1)*scl));\n    \n    a=(abs(a.x)<abs(b.x))?a:b;\n    \n    if(!inside){\n        //Background\n        b.y = 4.0;\n        p = po2;\n        //technique idea taken from yonatan\n        for(float s = 1.; s<10.; s/=.55){\n            p.xz*=rot(s);\n            p.y+=abs(dot(sin(p.xz*s+t*0.8)/s,vec2(0.15)));\n            p.y+=(dot(sin(p.xz*s+t*0.4+pi/2.)/s,vec2(0.15)));\n        }\n        b.x = p.y+1.3;\n        b.x*=0.7;\n\n        b.x = max(b.x,(length(p)-9.0));\n        a=(a.x<b.x)?a:b;\n    }\n    return a;\n}\n\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.001,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n#define MDIST 50.0\nvec2 march(vec3 ro, vec3 rd, int steps){\n    float dO = 0.;\n    for(int i = 0; i<steps; i++){\n        vec3 p = ro+rd*dO;\n        vec2 d = map(p);\n        dO+=abs(d.x);\n        if(dO>MDIST){\n            return vec2(dO,-1.);\n        }\n        if(abs(d.x)<0.0001||i==steps-1){\n            return vec2(dO,d.y);\n        }\n    }\n}\n\nvec3 colorI(vec3 ro, vec3 rd, float dO, float mat){\n    vec3 col = vec3(0);\n    vec3 p = ro+rd*dO;\n    vec3 n = norm(p);\n \n    \n    vec3 ld = normalize(vec3(1));\n    vec3 h = normalize(ld-rd);\n    float ndotl = abs(dot( -rd, n ));\n    float rim = pow(1.0-ndotl, 5.0);\n    float spec = pow(max(dot(n,h),0.0),5.0);\n    \n    \n    vec3 bg = vec3(0.3);\n    if(mat==1.0) col = bg;\n    \n    col+=rim;\n    \n    float dens = 0.1;\n    vec3 gemCol = vec3(0.310,0.004,0.396);\n    vec3 coloredDens = (1.-log(gemCol))*dens;\n    vec3 optDist = exp(-dO*coloredDens);\n    \n    //float optDist = exp(-dO*dens);\n    col = mix(gemCol,col,optDist);\n\n    col = col*optDist*gemCol;\n    \n    if(mat==2.0)glow*=rim;\n    col+=clamp(glow*0.5,0.,2.0)*vec3(0.886,0.376,0.129);\n    \n    \n    return col;\n}\nbool refracted = false;\nvec3 colorO(vec3 ro, vec3 rd, float dO, float mat){\n    vec3 col = vec3(0);\n    vec3 p = ro+rd*dO;\n    vec3 n = norm(p);\n    vec3 ld = normalize(vec3(1));\n    vec3 h = normalize(ld-rd);\n    vec3 r = reflect(rd,n);\n    float ndotl = abs(dot( -rd, n ));\n    float rim = pow(1.0-ndotl, 3.0);\n    float spec = length(sin(r*2.)*.5+.5)/sqrt(3.);\n    \n    vec3 bg = vec3(0.);\n    col = mix(col,bg,1.0);\n    //col+=clamp(glow*0.3,0.,0.8)*vec3(0.886,0.376,0.129);\n    if(dO<MDIST&&mat!=4.0){\n        col+=pow(spec,4.0)*3.0*vec3(1,0,0);\n        col+=rim*5.0;\n    }\n    \n    col+=clamp(glow2*0.03,0.,2.0)*vec3(0.886,0.376,0.129);\n    if(refracted) col=glow2*rim*vec3(0.886,0.376,0.129)*0.1;\n    return col;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 col = vec3(0);\n    m.y+=0.1;\n    vec3 ro = vec3(0,0.5+m.y*5.0,-4.0-m.y*10.0);\n    \n    //ro.yz *= rot(-m.y*3.14+1.);\n    ro.xz *= rot(-m.x*6.2831);\n    \n    vec3 lk = vec3(0,0.3,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*0.99+uv.x*r+uv.y*cross(f,r));\n    vec2 dO = vec2(0);\n    vec3 rdo = rd;\n    //Index of Refraction\n    float ior = 1.4;\n    \n    dO = march(ro,rd,170);\n    vec3 p = ro+rd*dO.x;\n    //Yeah this lighting setup is janky but it looks better than how I intended it\n    //so I'm keeping it \n    col = colorO(ro,rd,dO.x,dO.y); //Color the outside\n    \n    //If hit the glass then march into it and color the inside\n    if(dO.y==1.0||dO.y==3.0){\n        inside = true; //optimize which geometry to check\n        glow = 0.;\n        ro = p;\n        vec3 n = norm(p);\n        ro-=n*0.05;\n        rd = refract(rd,n,1./ior);\n        if(dO.y==1.0)dO = march(ro,rd,90);\n        col = mix(col,colorI(ro,rd,dO.x,dO.y),0.9);\n        \n        //attempted reflection on the surface, might re-visit\n        /* \n        inside = false; //optimize which geometry to check\n        glow = 0.;\n        glow2 = 0.;\n        vec2 dO2 = vec2(0);\n        dO2 = march(p+n*0.05,reflect(rd,n),90);\n        refracted = true;\n        vec3 col2 = colorO(ro,rd,dO2.x,dO2.y);\n        float fres = pow(1.0-abs(dot(-rdo, n)),1.0);\n        col+=col2*fres;\n        */\n\n    #ifdef refraction2\n        if(dO.y==1.0){\n            inside = false; //optimize which geometry to check\n            refracted = true; //janky fix to make the background more defined\n            p =ro+rd*dO.x;\n            glow = 0.;\n            glow2 = 0.;\n            ro = p;\n            n = norm(p);\n            ro += n*0.05;\n            vec3 ref = refract(rd,-n,ior);\n            if(ref == vec3(0)) rd = reflect(rd,-n);\n            else rd = ref;\n            \n            //not accurate but maybe more visually apealing ray direction\n            //rd = rdo; \n            \n            dO = march(ro,rd,40);\n            \n            col = mix(col,colorO(ro,rd,dO.x,dO.y),0.1);    \n        }\n    #endif     \n\n    }\n\n    fragColor = vec4(col,1.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}