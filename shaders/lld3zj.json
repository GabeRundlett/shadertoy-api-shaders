{
    "Shader": {
        "info": {
            "date": "1470375602",
            "description": "chilly\n",
            "flags": 64,
            "hasliked": 0,
            "id": "lld3zj",
            "likes": 52,
            "name": "Frost Marcher",
            "published": 3,
            "tags": [
                "raymarch",
                "normalmap",
                "cubemap"
            ],
            "usePreview": 0,
            "username": "Passion",
            "viewed": 1938
        },
        "renderpass": [
            {
                "code": "/* 2016 Passion */\n/* \"doBumpMap\" and \"tex3D\" borrowed from user 'Shane' */\n\n#define EPS 0.001\n#define MAX_STEPS 128\n#define MAX_DIST 15.0\n#define BUMP_AMOUNT 12.0\n//#define COLD_FOG\n\nmat2 r2(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(s, c, -c, s);\n}\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nfloat lengthN(vec3 v, float n)\n{\n  //v*=rx*ry*rz;\n  vec3 tmp = pow(abs(v), vec3(n));\n  return pow(tmp.x+tmp.y+tmp.z, 1.0/n);\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\nfloat map(vec3 p){\n    p = mod(p, 4.) - 2.0;\n    float t = iTime;\n    \n    float bmp = sin(p.x*BUMP_AMOUNT-t)* sin(p.y*BUMP_AMOUNT+t)* sin(p.z*BUMP_AMOUNT-t*1.5);\n    bmp*=.025;\n    \n    \n    return (lengthN(p,8.) - 0.75)+bmp;\n}\n\nfloat trace(vec3 o, vec3 r){\n    float d, t = 0.0;\n    for(int i = 0; i<32; i++){\n        vec3 p = o+t*r;\n        d = map(p);\n        if(d < EPS || t > MAX_DIST) break;\n        t += d;// * 0.7;\n    }\n    return t;\n}\n\n\n\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(0.0, 0.001);\n    return normalize((vec3(map(p + e.yxx), map(p + e.xyx), map(p + e.xxy)) - map(p)) / e.y);\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n    return (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(EPS, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    float time = iTime/3.;\n    \n    \n    vec3 l = normalize(vec3(0.1,0.8,0.1));\n    \n    vec3 o = vec3(0.0, 0.0, -19.0);  //1.5, -13.0\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv) * .25));\n    o.xz*=r2(time/3.);\n    r.xz*=r2(time/3.);//.4\n    \n    r.xy*=r2(time/1.75);\n    \n    float hit = trace(o, r);\n    \n    vec3 sp = o+r * hit;\n    \n    vec3 n = getNormal(sp);\n    n = doBumpMap(iChannel1, (sp)*(1.0/3.0), n, 0.05);\n    vec3 ref = reflect(-l, n);\n    \n    float ff = fbm(sp);\n    float d = map(sp);\n    \n    float f = fbm(r+time*1.5)*.2; //\n    vec3 ice = normalize(vec3(165., 242., 243.))*ff*1.8;\n    vec3 incident = normalize(sp - o);  \n    vec3 reflected = normalize(reflect(incident,n)); //, 1.31\n    vec3 refracted = normalize(refract(incident,n,1.31));\n    reflected.y*=-1.;\n    refracted.y*=-1.;\n    if(d < 0.5){\n        float dif = max(dot(n, l), 0.5)*.5+.5;\n        \n        vec3 halfVec = normalize(l - r);\n        float theta = max(dot(n, halfVec), 0.0);\n        float spec = pow(theta, 160.);\n        float fog = smoothstep(0.2, 0.5, hit*.03);\n        vec4 mm = texture(iChannel0, reflected);\n        vec4 m1 = texture(iChannel0, refracted);\n        fragColor = mix(vec4(vec3(ice+m1.rgb*m1.rgb*mm.rgb)+spec, 1.0), vec4(0.0), \n                        smoothstep(0.2,.75,hit*.07));\n#ifdef COLD_FOG\n        fragColor = mix(vec4(vec3(ice+m1.rgb*m1.rgb*mm.rgb)+spec, 1.0), vec4(f), \n                        smoothstep(0.2,.75,f+hit*.06));\n#endif\n    }\n    else{\n        fragColor = vec4(0.0); //texture(iChannel0,vec3(r.x,r.y*-1.,r.z));\n#ifdef COLD_FOG\n        fragColor = vec4(f); //texture(iChannel0,vec3(r.x,r.y*-1.,r.z));\n#endif\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 4461,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/hipdozer/vanilla-summer"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}