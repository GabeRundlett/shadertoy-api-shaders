{
    "Shader": {
        "info": {
            "date": "1580024434",
            "description": "What I call \"Knotted Hyper/Epi-Trochoid\". Tring to show depth by changing size of point, but not really good.\nThis one was the base for https://www.shadertoy.com/view/Wty3Dc.",
            "flags": 0,
            "hasliked": 0,
            "id": "wlGGW3",
            "likes": 6,
            "name": "Knotted Hyper/Epitrochoid",
            "published": 3,
            "tags": [
                "2d",
                "epitrochoid",
                "hypertrochoid"
            ],
            "usePreview": 0,
            "username": "hiogawa",
            "viewed": 341
        },
        "renderpass": [
            {
                "code": "//\n// Knotted Hyper/Epi-Trochoid\n//\n\n#define M_PI 3.14159\n\nfloat AA = 2.0;\nfloat SCALE_TIME = 1.5;\nvec2  UV_CENTER = vec2(0.0, 0.0);\nfloat UV_HEIGHT = 2.2;\n\nfloat CHECKER_SCALE = 1.0;\nvec3  CHECKER_COLOR0 = vec3(0.1);\nvec3  CHECKER_COLOR1 = vec3(0.2);\n\nconst float kEpi = 0.0;\nconst float kHyper = 1.0;\n\nconst float EPI_OR_HYPER = kEpi;\nfloat NUM_SYMMETRY = 4.0;\nconst float NUM_POINTS = 128.0 * (EPI_OR_HYPER == kEpi ? 2.0 : 1.0);\nfloat POINT_RADIUS = M_PI / NUM_POINTS * (EPI_OR_HYPER == kEpi ? 2.0 : 0.9);\nvec4  TROCHOID_COLOR = vec4(0.8, 1.0, 1.0, 0.9);\n\n//\n// Re-parameterize hyper/epi-trochoid for easier visual control\n//\n//   \"num_symmetry\"\n//     n = r1 / r2 = 1 / r2 \\in N\n//\n//   \"knotness\" (knot (a > 1), intersecton (1 > a > 0), no-intersection (0 > a))\n//     r3 = (1 - a) r2 + a * (r1 - r2)  (for hyper-trochoid)\n//     r3 = (1 - a) r2 + a * (r1 + r2)  (for epi-trochoid)\n//\n// TODO:\n// - reduce loop by taking symmetry into account\n// - for higher n, there is different kind of qualitative change (e.g. intersection with neighbor).\n//\nfloat signedDistanceToKnottedTrochoidPoints(\n    vec2 p, float trochoid_type, float knotness, float num_symmetry,\n    float num_points, float point_radius, float knot_offset) {\n\n  float r1 = 1.0;\n  float r2 = 1.0 / num_symmetry;\n  float r3, size; {\n    if (trochoid_type == kHyper) {\n      r3 = (1.0 - knotness) * r2 + knotness * (r1 - r2);\n      size = r1 - r2 + r3;\n    }\n    if (trochoid_type == kEpi) {\n      r3 = (1.0 - knotness) * r2 + knotness * (r1 + r2);\n      size = r1 + r2 + r3;\n    }\n  }\n  r1 /= size; r2 /= size; r3 /= size;\n\n  float min_distance = 1000.0;\n  for (float i = 0.0; i < num_points; i++) {\n    float t = 2.0 * M_PI * i / num_points;\n    vec3 q; {\n      if (trochoid_type == kHyper) {\n        q = vec3(\n          // usual hyper-trochoid formula\n          (r1 - r2) * cos(t) + r3 * cos((1.0 - num_symmetry) * t),\n          (r1 - r2) * sin(t) + r3 * sin((1.0 - num_symmetry) * t),\n          // knot by waving z coord along symmetry\n          sin(num_symmetry * (t + knot_offset)));\n      }\n      if (trochoid_type == kEpi) {\n        q = vec3(\n          // usual epi-trochoid formula\n          (r1 + r2) * cos(t) + r3 * cos((1.0 + num_symmetry) * t - M_PI),\n          (r1 + r2) * sin(t) + r3 * sin((1.0 + num_symmetry) * t - M_PI),\n          // knot by waving z coord along symmetry\n          sin(num_symmetry * (t + knot_offset)));\n      }\n    }\n    float radius = point_radius * mix(0.6, 1.0, q.z);\n    float sd = distance(p, q.xy) - radius;\n    if (sd < min_distance) {\n      min_distance = sd;\n    }\n  }\n  return min_distance;\n}\n\n\n//\n// Misc\n//\n\nfloat signedDistanceToChecker(vec2 uv, float scale) {\n  uv *= scale;\n  vec2 uvi = floor(uv);\n  vec2 uvf = uv - uvi;\n  float dist = min(min(min(uvf.x, uvf.y), 1.0 - uvf.x), 1.0 - uvf.y);\n  dist /= scale;\n  bool is_even_spot = mod(uvi.x + uvi.y, 2.0) == 0.0;\n  return is_even_spot ? -dist : dist;\n}\n\nmat3 invViewTransform(vec2 center, float height) {\n  vec2 Res = iResolution.xy;\n  vec2 size = vec2(height * Res.x / Res.y, height);\n  vec2 a = center - size / 2.0;\n  float Sy = height / Res.y;\n  mat3 xform = mat3(\n       Sy,   0,   0,\n        0,  Sy,   0,\n      a.x, a.y, 1.0);\n  return xform;\n}\n\nfloat smoothBoundaryCoverage(float signed_distance, float boundary_width) {\n  return 1.0 - smoothstep(0.0, 1.0, signed_distance / boundary_width + 0.5);\n}\n\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  mat3 inv_view_xform = invViewTransform(UV_CENTER, UV_HEIGHT);\n  float inv_view_scale = inv_view_xform[0][0];\n  vec2 uv =  vec2(inv_view_xform * vec3(frag_coord, 1.0));\n  float t = SCALE_TIME * iTime;\n\n  vec3 color;\n  {\n    // Checker\n    float sd = signedDistanceToChecker(uv, CHECKER_SCALE);\n    float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n    color = mix(CHECKER_COLOR0, CHECKER_COLOR1, coverage);\n  }\n  {\n    // Hyper/Epi-Trochoid\n    float knotness = 3.0 * (0.5 + 0.5 * sin(t));\n    float knot_offset = 0.0; // not used now\n    float sd = signedDistanceToKnottedTrochoidPoints(\n        uv, EPI_OR_HYPER, knotness, NUM_SYMMETRY, NUM_POINTS, POINT_RADIUS, knot_offset);\n    float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n    color = mix(color, TROCHOID_COLOR.xyz, TROCHOID_COLOR.w * coverage);\n  }\n  frag_color = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}