{
    "Shader": {
        "info": {
            "date": "1665495368",
            "description": "Trying to get a cinematiic feel by focussing on fog and silhouettes more than surface materials. Inspired partly by the landscape shots in Arrival (2016).",
            "flags": 32,
            "hasliked": 0,
            "id": "slVfD1",
            "likes": 34,
            "name": "Atmospheric Landscape",
            "published": 3,
            "tags": [
                "volumetric"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 580
        },
        "renderpass": [
            {
                "code": "vec3 LinearToSRGB ( vec3 col )\n{\n    return mix( col*12.92, 1.055*pow(col,vec3(1./2.4))-.055, step(.0031308,col) );\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    ivec2 dynamicResolutionDataUV = ivec2(iResolution.xy)-1;\n    int resolutionScaling = int( floor( texelFetch( iChannel0, dynamicResolutionDataUV, 0 ).y ) );\n\n    fragColour = texelFetch(iChannel0,ivec2(fragCoord)/resolutionScaling,0);\n    \n    // contrast stretch\n    fragColour.rgb = smoothstep(vec3(.05,.06,.08)*2.,vec3(1.)-vec3(.05,.06,.08)*1.,fragColour.rgb);\n    \n    fragColour.rgb = LinearToSRGB( fragColour.rgb );\n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float MAX_MEGAPIXELS = 1.5; // adjust fullscreen resolution for speed (lower = faster)\n\nvec2 quasi2 = vec2(.754877666247,.569840290998);\nvec3 quasi3 = vec3(0.8191725,0.6710436,0.5497005);\n\nfloat Noise( vec3 pos )\n{\n    return texture(iChannel1,pos/32.).r*2.-1.;\n}\n\nfloat GroundSDF( vec3 pos, int octaves )\n{\n    float f = 0.;\n    \n    float s = 1.4;\n    vec3 p = pos * s * .1;\n    \n    for ( int i = 0; i < octaves; i++ )\n    {\n        //f = mix(f,1.,abs(Noise(p))*s);\n        f += abs(Noise(p))*s;\n        p = vec3(p.z*5.,p.xy*3.+p.yx*4.*vec2(1,-1))*2./5.;\n        s /= 2.;\n    }\n    \n    return (pos.y + f) * .8;\n}\n\nfloat FogDensity( vec3 pos, int octaves )\n{\n    float f = 0.;\n    float s = 1.; // Don't change\n    vec3 p = pos * .7;\n    \n    p += iTime*vec3(0,-.02,.02);\n    \n    for ( int i = 0; i < octaves; i++ )\n    {\n        f += Noise(p)*s;\n        p = vec3(p.z*5.,p.xy*3.+p.yx*4.*vec2(1,-1))*2./5.;\n        s /= 1.7; // lower = stronger details\n    }\n    \n    // add a low layer\n    f += smoothstep(.2,.0,abs(pos.y+1.))*.4;\n    \n    // add a cloud layer\n    f += smoothstep(.4,.2,abs(pos.y-.3))*.7;\n\n//    f = smoothstep(-.3,1.5,f); // bigger clouds\n    f = smoothstep(.2,1.5,f); // smaller clouds\n//    f = smoothstep(-.2,3.,f); // softer clouds\n\n    float g = GroundSDF(pos,2);\n    f *= 1.-g/(abs(g)+.04);\n    \n    return f*1.; // Modulate density here instead\n}\n\nfloat AirDensity( vec3 pos )\n{\n    return exp2(-pos.y/5.-3.);\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 _fragCoordIn )\n{\n    ivec2 dynamicResolutionDataUV = ivec2(iResolution.xy)-1;\n    \n    if ( int(_fragCoordIn.x) == dynamicResolutionDataUV.x &&\n         int(_fragCoordIn.y) == dynamicResolutionDataUV.y )\n    {\n        float resolutionScalingF = texelFetch( iChannel0, dynamicResolutionDataUV, 0 ).x;\n        float lastResolutionScalingF = resolutionScalingF;\n        \n        if ( iFrame == 0 ) resolutionScalingF = 1.0;\n        \n/*\n        // adjust dynamic resolution\n        if ( iTimeDelta > 1.1/60. )\n        {\n            // drop resolution fast\n            resolutionScalingF *= 1.1;\n        }\n        else\n        {\n            // increase resolution slowly\n            resolutionScalingF *= .995;\n        }\n        resolutionScalingF = max(resolutionScalingF,1.);\n        //^ that's too stuttery, just base it on resolution\n*/\n\n        resolutionScalingF = ceil(iResolution.x*iResolution.y/(MAX_MEGAPIXELS*1000000.));\n        \n        fragColour = vec4(resolutionScalingF,lastResolutionScalingF,0,1);\n\n        return;\n    }\n    \n    vec4 resolutionData = texelFetch( iChannel0, dynamicResolutionDataUV, 0 );\n    float resolutionScaling = floor( resolutionData.x );\n    float lastResolutionScaling = floor( resolutionData.y );\n    \n    vec2 fragCoord = _fragCoordIn * resolutionScaling;\n\n    // black bars to make it look more cinematic\n    if ( abs(fragCoord.y-iResolution.y*.5) > iResolution.x*.5/2.39\n        || fragCoord.x >= iResolution.x )\n    {\n        fragColour = vec4(0);\n        return;\n    }\n    \n    float time = iTime*.2; // I want a fairly static shot with enough movement to break up the aliasing\n    vec3 velocity = vec3(1.0,0,0);\n    \n    float zoom = 1.;\n    vec3 camPos = vec3(sin(time*.618)*.4,-.3+.1*sin(time),0) + time*velocity;\n    vec3 camLook = vec3(-1,-.5,4) + (time-sin(time))*velocity;\n    \n    float jitterSeed = fract(\n                            dot(quasi2.yx,fragCoord)\n                            + texelFetch(iChannel1,ivec3(fragCoord,0)&31,0).r * .2\n                        );\n    vec2 jitter = fract(quasi2*(float(iFrame) + jitterSeed)); // ideal precession per point to give maximum coverage as fast as possible\n    vec3 ray = vec3((fragCoord+jitter-iResolution.xy*.5)/(iResolution.x*zoom),1.);\n    vec3 camDir = normalize(camLook-camPos);\n    vec3 camRight = normalize(cross(vec3(0,1,0),camDir));\n    vec3 camUp = cross(camDir,camRight);\n    \n    ray = ray.x*camRight + ray.y*camUp + ray.z*camDir;\n\n    // depth of field\n    float focalDepth = 4.;\n    float aperture = .003;\n    camPos += ray*focalDepth; // rely on ray.z = 1 before transform \n    ray += ((jitter.y*2.-1.)*camRight + (jitter.x*2.-1.)*camUp)*aperture;\n    camPos -= ray*focalDepth;\n\n    ray = normalize(ray);\n\n    vec3 sunDir = normalize(vec3(-3,2,1));\n\n\n    /*\n    march against the ground\n    BUT with a maximum step size dictated by volumetric quality\n    accumulate volumetric occlusion with emissive absorbant fog\n    ground intersection picks a neutral dark ground colour - emphasis is on atmospherics\n    */\n    vec3 pos = camPos;\n    vec3 absorption = vec3(1);\n    vec3 emission = vec3(0);\n    float lastStride = 0.;\n    float lastFogDensity = 0.;\n    float lastAirDensity = 0.;\n    for ( int i=0; i < 200; i++ )\n    {\n        float h = GroundSDF( pos, 6 );\n        \n        // accumulate fog occlusion\n        float fogDensity = FogDensity(pos,6);\n        float fogIntegral = lastStride*mix(fogDensity,lastFogDensity,.5);\n\n        float airDensity = AirDensity(pos);\n        float airIntegral = lastStride*mix(airDensity,lastAirDensity,.5);\n        \n        vec3 fogAbsorptionDelta = pow( vec3(0.1), vec3(fogIntegral) );\n        vec3 fogEmissionDelta = (1.-pow( vec3(0.1), vec3(fogIntegral) ));\n        \n        // fog lighting - just sample toward light and subtract\n        float shadowStep = .07;\n        float shadow = (fogDensity - FogDensity(pos+sunDir*shadowStep,3))/shadowStep;\n        fogEmissionDelta *= mix(vec3(.2,.27,.35)*.4,vec3(1)*.6,smoothstep(-1.,1.,shadow));\n\n        vec3 airAbsorptionDelta = pow( 1.-vec3(.3,.48,.7), vec3(airIntegral) );\n        vec3 airEmissionDelta = (1. - pow( 1.-vec3(.4,.55,.7), vec3(airIntegral) )) * vec3(.6);\n\n        vec3 absorptionDelta = fogAbsorptionDelta * airAbsorptionDelta;\n        emission += (absorption*sqrt(absorptionDelta)) * (fogEmissionDelta + airEmissionDelta);\n        absorption *= absorptionDelta;\n        \n        lastFogDensity = fogDensity;\n        lastAirDensity = airDensity;\n        \n        h = min(h,.1); // fog step\n        lastStride = h;\n\n        pos += h*ray;\n        if ( h < .001 ) break;\n    }\n    \n    // do some lighting on the terrain\n    vec2 d = vec2(-1,1)*.02; // big enough to avoid most of the aliasing in the noise texture\n    vec3 normal = normalize(\n                        GroundSDF( pos + d.xxx, 6 )*d.xxx +\n                        GroundSDF( pos + d.xyy, 6 )*d.xyy +\n                        GroundSDF( pos + d.yxy, 6 )*d.yxy +\n                        GroundSDF( pos + d.yyx, 6 )*d.yyx\n                    );\n    \n    float aostep = .3;\n    float ao = smoothstep(-.2,1.5,GroundSDF( pos + normal*aostep, 6 )/aostep);\n    \n    fragColour.rgb = vec3(.5)*ao + vec3(.5)*max(dot(normal,sunDir),0.); //vec3(.03);//fract(pos);\n    fragColour.rgb *= .4*mix( vec3(.0,.2,.0), vec3(.07,.1,0)+.3, smoothstep(.3,.9,ao) ); // albedo\n\n    if ( GroundSDF( pos, 6 ) > .5 ) fragColour.rgb = vec3(.14);\n\n    fragColour.rgb = fragColour.rgb*absorption + emission;\n\n    fragColour.rgb = mix( texelFetch(iChannel0,ivec2(_fragCoordIn*resolutionScaling/lastResolutionScaling),0).rgb, fragColour.rgb, .3 );\n\n    fragColour.a = 1.;\n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}