{
    "Shader": {
        "info": {
            "date": "1703717532",
            "description": "Slightly changed version of the basic raymarching shader by TheArtOfCode, but in this one, when ray marching, the light doesn't follow straight paths. Instead, they follow a 3d-sin-wave-like pattern, as illustrated by the RayMarch() function.",
            "flags": 32,
            "hasliked": 0,
            "id": "XcBGzz",
            "likes": 0,
            "name": "[steve] sin wave raymarching",
            "published": 3,
            "tags": [
                "3d",
                "sdf",
                "editor"
            ],
            "usePreview": 0,
            "username": "import_shader_steve",
            "viewed": 166
        },
        "renderpass": [
            {
                "code": "#define MAX_STEP 100\n#define SURF_DIST 0.01\n#define MAX_DIST 100.\n#define PI 3.14159\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdGround(vec3 p) {\n    return p.y;\n}\n\nfloat GetDist(vec3 p) {\n    vec3 pBox = vec3(0., 1., 6.);\n    float dBox = sdBox(p - pBox, vec3(1.));\n    vec3 pGround = vec3(0., 0., 3.);\n    float dGround = sdGround(p - pGround);\n    \n    float dScene = min(dBox, dGround);\n    return dScene;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    float d = GetDist(p);\n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n    return normalize(n);\n}\n\n// make a light above the sphere\nvec3 lightPos = vec3(2, 5, 1);\n\nfloat GetLight(vec3 p) {\n    //lightPos.xz = vec2(sin(iTime*2.), cos(iTime*2.)) * 5.;\n    vec3 lv = normalize(lightPos - p);\n    vec3 nv = GetNormal(p);\n    float rawLight = dot(lv, nv);\n    float finalLight = clamp(rawLight, 0., 1.);\n    return finalLight;\n}\n\nvec3 twistFunction(float t, float fq, float amt) {\n    // return vec3(t, sin(fq * t), sin(fq * t)) * amt;\n    return vec3(t, sin(fq * t), 0.) * amt;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float twistFrequency) {\n    float d0 = 0.;\n    for (int i = 0; i < MAX_STEP; i++) {\n        // here we need to twist the ray based on d0\n        // make the direction not rd, but a 3d-sin-wave-like function extending along rd direction\n        // we need to take this function (t, sint, sint) (direction (1, 0, 0)), and rotate it towards rd\n        // replace t with d0, and then normalize it. Use this resulting vec3 to replace rd\n        vec3 newRd = twistFunction(d0, twistFrequency, 1.);\n        vec4 quat = quatFromUnitVectors(vec3(1., 0., 0.), normalize(rd));\n        newRd = applyQuat(newRd, quat);\n        vec3 p = ro + newRd;\n        // vec3 p = ro + rd * d0;\n        float ds = GetDist(p);\n        d0 += ds;\n        if (ds < SURF_DIST || d0 > MAX_DIST) break;\n    }\n    return d0;\n}\n\nfloat GetShadow(vec3 p, float twistFrequency) {\n    vec3 rd = normalize(lightPos - p);\n    vec3 pOffset = p + GetNormal(p) * SURF_DIST * 2.;\n    float ds = RayMarch(pOffset, rd, twistFrequency);\n    float dl = length(p - lightPos);\n    if (ds < dl) {\n        return 0.1;\n    } else {\n        return 1.;\n    }\n}\n\n// input camera position, lookAt point, & zoomFactor, output camera ray direction\nvec3 makeCamera(vec3 ro, vec3 lookAt, float zoomFactor, vec2 uv) {\n    vec3 fVect = normalize(lookAt - ro);\n    vec3 rVect = normalize(cross(vec3(0., 1., 0.), fVect));\n    vec3 uVect = normalize(cross(fVect, rVect));\n    vec3 rd = normalize(uv.x * rVect + uv.y * uVect + zoomFactor * fVect);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy; //[0, 1]\n    m = vec2(iTime * 0.08);\n    vec3 color = vec3(0.);\n    \n    vec3 lookAt = vec3(0., 1.5, 6.);\n    vec3 ro = lookAt + vec3( 4.5*cos(7.0*-m.x), 2.2, 4.5*sin(7.0*-m.x) );\n    // haven't taken into account the m.y\n    // maybe should normalize the two rotations in order to get rid of the weird \"zooming out\"\n    // effect in my previous \"Flappy Bird on a 3D Console\" code\n    \n    float twistFrequency = zigzag(iTime * .1); // range [0., 1.]\n    twistFrequency = remap(twistFrequency, 0., 1., 0., 1.);\n    // twistFrequency = 0.002;\n    // twistFrequency = 0.1;\n\n    float zoomFactor = 1.;\n    vec3 rd = makeCamera(ro, lookAt, zoomFactor, uv);\n    \n    float d = RayMarch(ro, rd, twistFrequency);\n    if (d > MAX_DIST) {\n        color = backgroundColor;\n    } else {\n        vec3 p = ro + rd * d;\n        float l = GetLight(p) * GetShadow(p, twistFrequency);\n        color += vec3(l);\n    }\n    \n    \n    fragColor = vec4(color ,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec3 backgroundColor = vec3(1., 169./256., 20./256.);\n\nconst ivec2 txCameraPos = ivec2(31, 1);\n\nconst float PI = 3.14159;\n\nvec4 quatSetAxisAngle(vec3 axis, float rad) {\n    vec4 outVec4 = vec4(0., 0., 0., 0.);\n    \n    rad = rad * 0.5;\n    float s = sin(rad);\n    outVec4.x = s * axis.x;\n    outVec4.y = s * axis.y;\n    outVec4.z = s * axis.z;\n    outVec4.w = cos(rad);\n    \n    return outVec4;\n}\n\nvec4 quatFromUnitVectors(vec3 a, vec3 b) {\n    vec3 tmpvec3 = vec3(0., 0., 0.);\n    vec3 xUnitVec3 = vec3(1., 0., 0.);\n    vec3 yUnitVec3 = vec3(0., 1., 0.);\n    \n    float dotFloat = dot(a, b);\n    \n    if (dotFloat < -0.999999) {\n        tmpvec3 = cross(xUnitVec3, a);\n        if (length(tmpvec3) < 0.000001) tmpvec3 = cross(yUnitVec3, a);\n        tmpvec3 = normalize(tmpvec3);\n        vec4 outVec4 = quatSetAxisAngle(tmpvec3, PI);\n        return outVec4;\n    } else if (dotFloat > 0.999999) {\n        vec4 outVec4 = vec4(0., 0., 0., 0.);\n        outVec4.x = 0.;\n        outVec4.y = 0.;\n        outVec4.z = 0.;\n        outVec4.w = 1.;\n        return outVec4;\n    } else {\n        vec4 outVec4 = vec4(0., 0., 0., 0.);\n        tmpvec3 = cross(a, b);\n        outVec4.x = tmpvec3.x;\n        outVec4.y = tmpvec3.y;\n        outVec4.z = tmpvec3.z;\n        outVec4.w = 1. + dotFloat;\n        return normalize(outVec4);\n    }\n}\n\nvec3 applyQuat(vec3 a, vec4 q) {\n    float qx = q.x;\n    float qy = q.y;\n    float qz = q.z;\n    float qw = q.w;\n    float x = a.x;\n    float y = a.y;\n    float z = a.z;\n    // var qvec = [qx, qy, qz];\n    // var uv = vec3.cross([], qvec, a);\n    float uvx = qy * z - qz * y;\n    float uvy = qz * x - qx * z;\n    float uvz = qx * y - qy * x;\n    // var uuv = vec3.cross([], qvec, uv);\n    float uuvx = qy * uvz - qz * uvy;\n    float uuvy = qz * uvx - qx * uvz;\n    float uuvz = qx * uvy - qy * uvx;\n    // vec3.scale(uv, uv, 2 * w);\n    float w2 = qw * 2.;\n    uvx *= w2;\n    uvy *= w2;\n    uvz *= w2;\n    // vec3.scale(uuv, uuv, 2);\n    uuvx *= 2.;\n    uuvy *= 2.;\n    uuvz *= 2.;\n    // return vec3.add(out, a, vec3.add(out, uv, uuv));\n    vec3 outVec3 = vec3(0., 0., 0.);\n    outVec3.x = x + uvx + uuvx;\n    outVec3.y = y + uvy + uuvy;\n    outVec3.z = z + uvz + uuvz;\n    return outVec3;\n}\n\n// generate a zigzag pattern that oscillates between 0. and 1.\nfloat zigzag(float x) {\n    float modX = mod(x, 2.);\n    \n    if (modX < 1.) {\n        return fract(x);\n    } else {\n        return 1. - fract(x);\n    }\n}\n\nfloat remap01(float x, float low, float high) {\n    x = clamp(x, low, high);\n    return (x - low) / (high - low);\n}\n\nfloat remap(float x, float lowIn, float highIn, float lowOut, float highOut) {\n    float a = remap01(x, lowIn, highIn);\n    return lowOut + a * (highOut - lowOut);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec4 loadValue( in ivec2 valueCoord )\n{\n    return texelFetch( iChannel0, valueCoord, 0 );\n}\n\nvoid storeValue( in ivec2 valueCoord, in vec4 value, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = ( valueCoord.x == fragCoord.x && valueCoord.y == fragCoord.y ) \n    ? value : fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}