{
    "Shader": {
        "info": {
            "date": "1662464222",
            "description": "fitting an arbitrary 1D function or point set with a SIREN neural network using a combination of Adam and forward gradient optimization https://arxiv.org/pdf/2202.08587.pdf - also uses differential evolution laterally for best of breed effects.",
            "flags": 32,
            "hasliked": 0,
            "id": "NlKyDd",
            "likes": 17,
            "name": "Forward Gradient Fitting",
            "published": 3,
            "tags": [
                "gradient",
                "optimization",
                "training",
                "fitting",
                "forward",
                "siren",
                "ml",
                "cost",
                "loss",
                "adam"
            ],
            "usePreview": 1,
            "username": "paniq",
            "viewed": 539
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////////////\n\nModel f_scoeffs;\nfloat f_scoeffs_func(float x) {\n    ModelIO io;\n    io.i[0] = ad_const(x);\n    model_eval(f_scoeffs, f_scoeffs, io);\n    return io.o[0].x;\n}\n\nfloat f_error(float x) {\n    return pow2(f_scoeffs_func(x) - target_func(x))*1000.0 - 1.0;\n}\n\nvoid paint() {\n    setup_s_K(iFrame);\n    float t = iTime;\n    \n    Random rng = seed(seed(get_origin()), iFrame);\n    int mi = range(rng, 0, int(iResolution.y));\n    //mi = 0;\n\n    Model source;\n    for (int i = 0; i < ModelSize; ++i) {\n#if EMA\n        source.c[i] = texelFetch(iChannel0, ivec2(i,mi), 0).a / (1.0 - pow(beta2, float(iFrame+1)));\n#else\n        source.c[i] = texelFetch(iChannel0, ivec2(i,mi), 0).x;\n#endif\n    }\n\n    set_source_rgb(0.0,0.0,0.0);\n    clear();\n    \n    grid(vec2(1.0/10.0));\n    set_line_width_px(1.0);\n    set_source_rgba(vec4(vec3(1.0),0.3));\n    stroke();\n\n    set_source_rgba(vec4(vec3(1.0),0.7));\n    rectangle(-1.0,-1.0,2.0,2.0);\n    stroke();\n\n    f_scoeffs = source;\n#ifdef FIT_POINTS\n    set_source_rgba(vec4(vec3(1.0,0.5,0.5),1.0));\n    for (int i = 0; i < FIT_POINTS; ++i) {\n        vec2 p = get_point(i, iFrame);\n        float y = f_scoeffs_func(p.x);\n        float err = pow2(y - p.y) / 1e-3;\n        move_to(p.x, -1.0);\n        line_to(p.x, -1.0 + err);\n        stroke();\n    }\n    set_source_rgba(vec4(vec3(1.0),1.0));\n    for (int i = 0; i < FIT_POINTS; ++i) {\n        circle(get_point(i, iFrame), 0.02);\n        fill();\n    }\n#else\n    graph1D(target_func);\n    set_source_rgba(vec4(vec3(1.0),1.0));\n    stroke();\n    \n    graph1D(f_error);\n    set_source_rgba(vec4(vec3(1.0,0.5,0.5),1.0));\n    stroke();\n#endif\n#if 0\n    graph1D(f_scoeffs_func_i0);\n    set_line_width_px(1.0);\n    set_source_rgba(vec4(vec3(0.8,0.5,1.0),0.8));\n    stroke();\n    graph1D(f_scoeffs_func_i1);\n    set_line_width_px(1.0);\n    set_source_rgba(vec4(vec3(0.8,0.5,1.0),0.8));\n    stroke();\n#endif\n    graph1D(f_scoeffs_func);\n    set_line_width_px(2.0);\n    set_source_rgba(vec4(vec3(0.8,0.5,1.0),1.0));\n    stroke();\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint();\n\n    blit(fragColor);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "\n\n// fit a random cloud of points instead\n#define FIT_POINTS 32\n// use triangle wave (PSIREN) rather than sinusoid (SIREN)\n#define USE_TRI 0\n\n// if 0, project random vector; if 1, compute full gradient (slow, O(n^2) for n weights)\n// empirically, stochastic descent takes longer to ramp up speed, but appears to take\n// twice as many steps, but converges much faster in this shader, simply because the\n// framerate is higher.\n// using newton stepmethods requires a full gradient\n#define FULL_GRADIENT 0\n\n// forward gradient descent (https://arxiv.org/abs/2202.08587)\n#define METHOD_FGD 0\n// Adam gradient descent (https://arxiv.org/abs/1412.6980, algorithm 1)\n#define METHOD_ADAM 1\n// AdaMax gradient descent (https://arxiv.org/abs/1412.6980, algorithm 2)\n#define METHOD_ADAMAX 2\n\n#define METHOD METHOD_ADAM\n//#define METHOD METHOD_FGD\n\n// step by negative gradient\n#define STEPMETHOD_GRADIENT 0\n// step by newton's method, unbounded\n#define STEPMETHOD_NEWTON 1\n// step by newton's method, clamped (this one is quite good for functions with discontinuities)\n#define STEPMETHOD_CLAMP_NEWTON 2\nconst float newton_clamp_limit = 10.0;\n// step by newton's method, softclamped (same)\n#define STEPMETHOD_SOFTCLAMP_NEWTON 3\n\n#define STEPMETHOD STEPMETHOD_GRADIENT\n//#define STEPMETHOD STEPMETHOD_CLAMP_NEWTON\n\n// if 1, smooth result with exponential moving average; needs restart\n// (https://arxiv.org/abs/1412.6980, 7.2)\n#define EMA 0\n\n#if (METHOD == METHOD_ADAMAX)\nconst float alpha = 0.002;\n#elif (METHOD == METHOD_ADAM)\nconst float alpha = 0.001;\n#else\nconst float alpha = 0.001;\n#endif\n#if FULL_GRADIENT\nconst float beta1 = 0.9;\nconst float beta2 = 0.999;\n#else\nconst float beta1 = 0.95;\nconst float beta2 = 0.9995;\n#endif\nconst float epsilon = 10.0 * 1e-8;\n\nconst float max_float = 3.402e+38;\n\n// for stochastic descent, if set to 1, clamp the random gradient\n// close to infinity and normalize.\n#define NORMALIZE_MC_GRADIENT 0\n#if NORMALIZE_MC_GRADIENT\nconst float gradient_clamp = 3.402e+38;\n#else\n// for stochastic descent, clamp the generated gaussian amplitudes\n// not doing so can cause sudden inf/nan death.\nconst float gradient_clamp = 1.0;\n#endif\n\nfloat smoothReLU(float x, float r) {\n    float xa = abs(x);\n    float c = max(r - xa, 0.0);\n    return 0.5*x + 0.5*xa + 0.25*c*c/r;\n}\nfloat smoothReLUdx(float x, float r) {\n    return clamp(0.5 + 0.5*x/r,0.0,1.0);\n}\n\nvec2 explu(vec2 x) {\n    float w = exp(x.x);\n    return vec2(w, x.y*w);\n}\n\nvec2 relu(vec2 x) {\n    return vec2(\n        max(0.0, x.x),\n        x.y*step(0.0, x.x));\n}\n\nvec2 gelu(float x) {\n    float w = exp(x);\n    float ww = w + 1.0;\n    return vec2(\n        x*w/(1.0 + w),\n        w*(x + w + 1.0) / (ww*ww));\n}\n\nfloat s_K = 1.0;\n\nvec2 clamped_relu(vec2 x) {\n    return vec2(\n        clamp(x.x, 0.0, 1.0),\n        x.y*step(0.0,x.x)*step(x.x,1.0));\n}\n\nvec2 logistic(vec2 x) {\n    float w = exp(-x.x);\n    float w1 = w + 1.0;\n    return vec2(\n        1.0 / (1.0 + w),\n        x.y*w/(w1*w1));\n}\n\nvec2 tanhlu(vec2 x) {\n    float w = tanh(x.x);\n    return vec2(w, x.y*(1.0 - w*w));\n}\n\n// logistic function over 0..1, with unit rate of change\n// the smooth version of clamped_relu()\nvec2 logistic_unit(vec2 x) {\n    float w = exp(-4.0*x.x + 2.0);\n    float w1 = w + 1.0;\n    return vec2(\n        1.0 / (1.0 + w),\n        4.0*x.y*w/(w1*w1));\n}\n\n// logistic unit clamped to zero \nvec2 clamped_logistic_unit(vec2 x) {\n    const float K = exp(0.01);\n    vec2 q = x;\n    q.x -= 0.5;\n    q /= K;\n    q.x += 0.5;\n    q = logistic_unit(x);\n    q.x -= 0.5;\n    q *= K;\n    q.x += 0.5;\n    return clamped_relu(q);\n}\n\n// inverse of logistic unit\nvec2 inv_logistic_unit(vec2 x) {\n    return vec2(\n        0.5 - 0.25*log(1.0/x.x - 1.0),\n        x.y*0.25/((1.0 / x.x - 1.0)*x.x*x.x));\n}\n\nvec2 lerp_logistic_unit_to_clamped_relu(vec2 x) {\n    vec2 b = clamped_relu(x);\n    if (s_K < 1e-3)\n        return b;\n    vec2 a = logistic_unit(x);\n    return mix(b, a, s_K);\n}\n\nvec2 crazy(vec2 x) {\n    float w = exp(-x.x*x.x);\n    float ws = w*sin(x.x);\n    float wc = w*cos(x.x);\n    return vec2(\n        w,\n        x.y*w*(cos(x.x) - 2.0*sin(x.x)*x.x));\n}\n\nvoid setup_s_K(int frame) {\n    // after 100 seconds, lower K towards zero, approximating the sharp ReLU function\n    float t = float(frame) / 60.0;\n    //s_K = 1.0 / (1.0 + pow(float(t)/100.0,2.0));    \n    //Random rng = seed(frame);\n    s_K = exp(-t/5.0);\n    //s_K = 1.0 / (1.0 + t/100.0);\n}\n\n/////////////////////////////////////////////////////////////////////////\n\nbool isbad(float x) {\n    return isinf(x) || isnan(x);\n}\n\nvec2 ad_const(float c) {\n    return vec2(c, 0.0);\n}\n\nvec2 ad_max(vec2 a, vec2 b) {\n    return (a.x > b.x)?a:b;\n}\n\nvec2 ad_mul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x, a.x*b.y + a.y*b.x);\n}\nvec2 ad_mul(vec2 a, float b) {\n    return a * b;\n}\nvec2 ad_neg(vec2 a) {\n    return -a;\n}\nvec2 ad_sq(vec2 a) {\n    return vec2(a.x * a.x, 2.0*a.x*a.y);\n}\nvec2 ad_sqrt(vec2 a) {\n    float w = sqrt(a.x);\n    return vec2(w, 0.5 * a.y / w);\n}\nvec2 ad_abs(vec2 a) {\n    return vec2(abs(a.x), sign(a.x)*a.y);\n}\nvec2 ad_add(vec2 a, vec2 b) {\n    return a + b;\n}\nvec2 ad_add(vec2 a, float b) {\n    return vec2(a.x + b, a.y);\n}\nvec2 ad_sub(vec2 a, float b) {\n    return vec2(a.x - b, a.y);\n}\nvec2 ad_div(vec2 a, vec2 b) {\n    return vec2(a.x / b.x, a.y/b.x - a.x*b.y/(b.x*b.x));\n}\nvec2 ad_sin(vec2 a) {\n    return vec2(sin(a.x), a.y*cos(a.x));\n}\nconst float pi = 3.14159265359;\nvec2 ad_sin_L1T(vec2 a) {\n    return vec2(\n        (abs(2.0-abs(fract(a.x/(2.0*pi))*4.0-1.0))-1.0)*pi/2.0,\n        a.y*sign(1.0-fract(a.x/(2.0*pi) + 1.0/4.0)*2.0));\n}\nvec2 ad_sin_L1(vec2 a) {\n    return vec2(\n        (abs(2.0-abs(fract(a.x/(2.0*pi))*4.0-1.0))-1.0),\n        a.y*sign(1.0-fract(a.x/(2.0*pi) + 1.0/4.0)*2.0))*2.0/pi;\n}\nvec2 ad_fract(vec2 a) {\n    return vec2(\n        fract(a.x),\n        a.y);\n}\nvec2 ad_tri(vec2 a) {\n    float w = fract(a.x);\n    return vec2(\n        abs(0.5-w),\n        a.y*sign(w-0.5));\n}\nvec2 ad_mf(vec2 a) {\n    float w = fract(a.x);\n    return vec2(\n        min(w, 0.5),\n        step(w, 0.5));\n}\nvec2 ad_exp2(vec2 a) {\n    float w = exp2(a.x);\n    return vec2(w, a.y*w*log(2.0));\n}\nvec2 ad_gfloor(vec2 a) {\n    float k = exp2(-4.0);\n    float w = floor(a.x/k)*k;\n    //return vec2(a.x + w, a.y);\n    return vec2(w, a.y);\n}\n\n// edit target_func() at the very bottom of this file to define the target to fit\n\n\n// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.16\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2020-12-02: 0.16\n// * support for drawing concentric rings\n\n// 2020-11-30: 0.15\n// * support for drawing orthogonal grids\n// * adjusted uv so corners are centered on pixels\n// * small adjustment to line pixel width computation\n\n// 2020-11-12: 0.14\n// * added support for depth testing\n\n// 2020-11-11: 0.13\n// * fixed 2D graphs not filling\n// * added circle_px()\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\nvoid set_source_depth(float depth);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the old source with the new one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n// if enabled, use the depth value for testing;\n// smaller values win\nvoid depth_test(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a circle path at P with pixel radius R\nvoid circle_px(vec2 p, float r);\nvoid circle_px(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// add an orthogonal grid with cell size S\nvoid grid(vec2 s);\nvoid grid(float w, float h);\nvoid grid(float s);\n// draw concentric rings around origin p, with spacing r and offset phase\nvoid rings(vec2 p, float r, float phase);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    bool depth_test;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n    float source_z;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n#define DEFAULT_DEPTH 1e+30\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.5;\n\tAAINV = 1.0 / AA;\n    \n    uv = (fragCoord.xy - 0.5) / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false,\n        DEFAULT_DEPTH\n    );\n}\n\nvec3 _color = vec3(1);\nfloat _depth = DEFAULT_DEPTH;\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color.rgb = mix(_color.rgb, _stack.source.rgb, _stack.source.a);\n    _depth = (_stack.source.a == 1.0)?_stack.source_z:_depth;\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(pow(_color.rgb, vec3(1.0/2.2)), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color.rgb;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    if (_stack.depth_test) {\n        if ((w == 1.0) && (_stack.source_z <= _depth)) {\n            _depth = _stack.source_z;\n        } else if ((w == 0.0) || (_stack.source_z > _depth)) {            \n            return;\n        }\n    }\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color.rgb = _color.rgb * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\n\nvoid depth_test(bool enable) {\n    _stack.depth_test = enable;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_depth(float depth) {\n    _stack.source_z = depth;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid grid(vec2 size) {\n    vec4 f = abs(fract(_stack.position/size.xyxy+0.5)-0.5)*size.xyxy;\n    add_field(vec2(min(f.x,f.y),min(f.z,f.w)));\n}\nvoid grid(float w, float h) {\n    grid(vec2(w,h));\n}\nvoid grid(float s) {\n    grid(vec2(s));\n}\nvoid rings(vec2 p, float r, float phase) {\n    vec4 q = _stack.position - p.xyxy;\n    vec2 f = abs(fract(vec2(length(q.xy),length(q.zw))/r-phase+0.5)-0.5)*r;\n    add_field(f);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid circle_px(vec2 p, float r) {\n    circle(p, r/(0.5*ScreenH));\n}\nvoid circle_px(float x, float y, float r) {\n    circle_px(vec2(x,y), r);\n}\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(f_x / length(df_x));\n}\n\n// random number generator library (https://www.shadertoy.com/view/ssGXDd)\n// by Leonard Ritter (@leonard_ritter)\n\n// based on https://www.shadertoy.com/view/MdcfDj\n// license: https://unlicense.org/\n\n// comment out for faster but lower quality hashing\n#define RNGL_HIGH_QUALITY\n\nstruct Random { uint s0; uint s1; };\n\n// constructors; note that constructors are wilfully unique,\n// i.e. calling a different constructor with the same arguments will not\n// necessarily produce the same state.\nuint uhash(uint a, uint b);\nRandom seed(uint s) { return Random(s, uhash(0x1ef7c663u, s)); }\nRandom seed(uvec2 s) { return Random(s.y, uhash(s.x, s.y)); }\nRandom seed(Random a, uint b) { return Random(b, uhash(a.s1, b)); }\nRandom seed(Random a, uvec2 b) { return seed(a, uhash(b.x, b.y)); }\nRandom seed(Random a, uvec3 b) { return seed(a, uhash(uhash(b.x, b.y), b.z)); }\nRandom seed(Random a, uvec4 b) { return seed(a, uhash(uhash(b.x, b.y), uhash(b.z, b.w))); }\nRandom seed(uvec3 s) { return seed(seed(s.xy), s.z); }\nRandom seed(uvec4 s) { return seed(seed(s.xy), s.zw); }\nRandom seed(int s) { return seed(uint(s)); }\nRandom seed(ivec2 s) { return seed(uvec2(s)); }\nRandom seed(ivec3 s) { return seed(uvec3(s)); }\nRandom seed(ivec4 s) { return seed(uvec4(s)); }\nRandom seed(Random a, int b) { return seed(a, uint(b)); }\nRandom seed(Random a, ivec2 b) { return seed(a, uvec2(b)); }\nRandom seed(Random a, ivec3 b) { return seed(a, uvec3(b)); }\nRandom seed(Random a, ivec4 b) { return seed(a, uvec4(b)); }\nRandom seed(float s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec2 s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec3 s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec4 s) { return seed(floatBitsToUint(s)); }\nRandom seed(Random a, float b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec2 b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec3 b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec4 b) { return seed(a, floatBitsToUint(b)); }\n\n// fundamental functions to fetch a new random number\n// the last static call to the rng will be optimized out\nuint urandom(inout Random rng) {\n    uint last = rng.s1;\n    uint next = uhash(rng.s0, rng.s1);\n    rng.s0 = rng.s1; rng.s1 = next;\n    return last;\n}\nuvec2 urandom2(inout Random rng) { return uvec2(urandom(rng),urandom(rng)); }\nuvec3 urandom3(inout Random rng) { return uvec3(urandom2(rng),urandom(rng)); }\nuvec4 urandom4(inout Random rng) { return uvec4(urandom2(rng),urandom2(rng)); }\nint irandom(inout Random rng) { return int(urandom(rng)); }\nivec2 irandom2(inout Random rng) { return ivec2(urandom2(rng)); }\nivec3 irandom3(inout Random rng) { return ivec3(urandom3(rng)); }\nivec4 irandom4(inout Random rng) { return ivec4(urandom4(rng)); }\n\nfloat unorm(uint n);\nfloat random(inout Random rng) { return unorm(urandom(rng)); }\nvec2 random2(inout Random rng) { return vec2(random(rng),random(rng)); }\nvec3 random3(inout Random rng) { return vec3(random2(rng),random(rng)); }\nvec4 random4(inout Random rng) { return vec4(random2(rng),random2(rng)); }\n\n// ranged random value < maximum value\nint range(inout Random rng, int mn, int mx) { return mn + (irandom(rng) % (mx - mn)); }\nivec2 range(inout Random rng, ivec2 mn, ivec2 mx) { return mn + (irandom2(rng) % (mx - mn)); }\nivec3 range(inout Random rng, ivec3 mn, ivec3 mx) { return mn + (irandom3(rng) % (mx - mn)); }\nivec4 range(inout Random rng, ivec4 mn, ivec4 mx) { return mn + (irandom4(rng) % (mx - mn)); }\nuint range(inout Random rng, uint mn, uint mx) { return mn + (urandom(rng) % (mx - mn)); }\nuvec2 range(inout Random rng, uvec2 mn, uvec2 mx) { return mn + (urandom2(rng) % (mx - mn)); }\nuvec3 range(inout Random rng, uvec3 mn, uvec3 mx) { return mn + (urandom3(rng) % (mx - mn)); }\nuvec4 range(inout Random rng, uvec4 mn, uvec4 mx) { return mn + (urandom4(rng) % (mx - mn)); }\nfloat range(inout Random rng, float mn, float mx) { float x=random(rng); return mn*(1.0-x) + mx*x; }\nvec2 range(inout Random rng, vec2 mn, vec2 mx) { vec2 x=random2(rng); return mn*(1.0-x) + mx*x; }\nvec3 range(inout Random rng, vec3 mn, vec3 mx) { vec3 x=random3(rng); return mn*(1.0-x) + mx*x; }\nvec4 range(inout Random rng, vec4 mn, vec4 mx) { vec4 x=random4(rng); return mn*(1.0-x) + mx*x; }\n\n// marshalling functions for storage in image buffer and rng replay\nvec2 marshal(Random a) { return uintBitsToFloat(uvec2(a.s0,a.s1)); }\nRandom unmarshal(vec2 a) { uvec2 u = floatBitsToUint(a); return Random(u.x, u.y); }\n\n//// specific distributions\n\n// normal/gaussian distribution\n// see https://en.wikipedia.org/wiki/Normal_distribution\nfloat gaussian(inout Random rng, float mu, float sigma) {\n    vec2 q = random2(rng);\n    float g2rad = sqrt(-2.0 * (log(1.0 - q.y)));\n    float z = cos(q.x*6.28318530718) * g2rad;\n    return mu + z * sigma;\n}\n\n// triangular distribution\n// see https://en.wikipedia.org/wiki/Triangular_distribution\n// mode is a mixing argument in the range 0..1\nfloat triangular(inout Random rng, float low, float high, float mode) {\n    float u = random(rng);\n    if (u > mode) {\n        return high + (low - high) * (sqrt ((1.0 - u) * (1.0 - mode)));\n    } else {\n        return low + (high - low) * (sqrt (u * mode));\n    }\n}\nfloat triangular(inout Random rng, float low, float high) { return triangular(rng, low, high, 0.5); }\n\n// after https://www.shadertoy.com/view/4t2SDh\n// triangle distribution in the range -0.5 .. 1.5\nfloat triangle(inout Random rng) {\n    float u = random(rng);\n    float o = u * 2.0 - 1.0;\n    return max(-1.0, o / sqrt(abs(o))) - sign(o) + 0.5;\n}\n\n//// geometric & euclidean distributions\n\n// uniformly random point on the edge of a unit circle\n// produces 2d normal vector as well\nvec2 uniform_circle_edge (inout Random rng) {\n    float u = random(rng);\n    float phi = 6.28318530718*u;\n    return vec2(cos(phi),sin(phi));\n}\n\n// uniformly random point in unit circle\nvec2 uniform_circle_area (inout Random rng) {\n    return uniform_circle_edge(rng)*sqrt(random(rng));\n}\n\n// gaussian random point in unit circle\nvec2 gaussian_circle_area (inout Random rng, float k) {\n    return uniform_circle_edge(rng)*sqrt(-k*log(random(rng)));\n}\nvec2 gaussian_circle_area (inout Random rng) { return gaussian_circle_area(rng, 0.5); }\n\n// barycentric coordinates of a uniformly random point within a triangle\nvec3 uniform_triangle_area (inout Random rng) {\n    vec2 u = random2(rng);\n    if (u.x + u.y > 1.0) {\n        u = 1.0 - u;\n    }\n    return vec3(u.x, u.y, 1.0-u.x-u.y);\n}\n\n// uniformly random on the surface of a sphere\n// produces normal vectors as well\nvec3 uniform_sphere_area (inout Random rng) {\n    vec2 u = random2(rng);\n    float phi = 6.28318530718*u.x;\n    float rho_c = 2.0 * u.y - 1.0;\n    float rho_s = sqrt(1.0 - (rho_c * rho_c));\n    return vec3(rho_s * cos(phi), rho_s * sin(phi), rho_c);\n}\n\n// uniformly random within the volume of a sphere\nvec3 uniform_sphere_volume (inout Random rng) {\n    return uniform_sphere_area(rng) * pow(random(rng), 1.0/3.0);\n}\n\n// barycentric coordinates of a uniformly random point within a 3-simplex\n// based on \"Generating Random Points in a Tetrahedron\" by Rocchini et al\nvec4 uniform_simplex_volume (inout Random rng) {\n    vec3 u = random3(rng);\n    if(u.x + u.y > 1.0) {\n        u = 1.0 - u;\n    }\n    if(u.y + u.z > 1.0) {\n        u.yz = vec2(1.0 - u.z, 1.0 - u.x - u.y);\n    } else if(u.x + u.y + u.z > 1.0) {\n        u.xz = vec2(1.0 - u.y - u.z, u.x + u.y + u.z - 1.0);\n    }\n    return vec4(1.0 - u.x - u.y - u.z, u); \n}\n\n// for differential evolution, in addition to index K, we need to draw three more\n// indices a,b,c for a list of N items, without any collisions between k,a,b,c.\n// this is the O(1) hardcoded fisher-yates shuffle for this situation.\nivec3 sample_k_3(inout Random rng, int N, int K) {\n    ivec3 t = range(rng, ivec3(1,2,3), ivec3(N));\n    int db = (t.y == t.x)?1:t.y;\n    int dc = (t.z == t.y)?((t.x != 2)?2:1):((t.z == t.x)?1:t.z);\n    return (K + ivec3(t.x, db, dc)) % N;\n}\n\n/////////////////////////////////////////////////////////////////////////\n\n// if it turns out that you are unhappy with the distribution or performance\n// it is possible to exchange this function without changing the interface\nuint uhash(uint a, uint b) { \n    uint x = ((a * 1597334673U) ^ (b * 3812015801U));\n#ifdef RNGL_HIGH_QUALITY\n    // from https://nullprogram.com/blog/2018/07/31/\n    x = x ^ (x >> 16u);\n    x = x * 0x7feb352du;\n    x = x ^ (x >> 15u);\n    x = x * 0x846ca68bu;\n    x = x ^ (x >> 16u);\n#else\n    x = x * 0x7feb352du;\n    x = x ^ (x >> 15u);\n    x = x * 0x846ca68bu;\n#endif\n    return x;\n}\nfloat unorm(uint n) { return float(n) * (1.0 / float(0xffffffffU)); }\n\n/////////////////////////////////////////////////////////////////////////\n\nfloat gain(float x, float P) {\n    if (x > 0.5)\n        return 1.0 - 0.5*pow(2.0-2.0*x, P);\n    else\n        return 0.5*pow(2.0*x, P);\n}\n\nfloat target_func(float x) {\n#if 0\n    Random rng = seed(4);\n    float y = random(rng);\n    for (int i = 1; i < 16; ++i) {\n        y = x*y + random(rng);\n    }\n    return y * 0.5 - 0.5;\n#elif 0\n    return sin(x*pi)*0.7;\n#elif 0\n    return sqrt(x*0.5+0.5) - 0.5;\n#elif 0\n    return 4.0*x*x-0.5;\n#elif 0\n    return tanh(x*10.0) * 0.5;\n#elif 0\n    return tanh(1.0 / (x*10.0)) * 0.5;\n#elif 0\n    return smoothstep(-0.25, 0.25, x)-0.5;\n#elif 1\n    return fract(x*1.0 + 0.5) - 0.5 + sin(x*pi)*0.1;\n#elif 0\n    return 1.0 / (x + 1.5) - 1.0;\n#elif 1\n    return abs(fract(x) - 0.5);\n#elif 1\n    return min(fract(x), 0.5);\n#elif 1\n    //return step(0.0, x)-0.9 + x*x;\n    return step(0.5, fract(x*0.5)) - 0.5;\n#else\n    return smoothstep(-0.1, 0.1, x)-0.5;\n#endif\n}\n\n#ifdef FIT_POINTS\nvec2 get_point(int i, int s) {\n    Random rng = seed(seed(i),0);\n    vec2 p = random2(rng);\n    //p.x = gaussian(rng, 0.5, 0.5);\n    p.x = float(i) / float(FIT_POINTS-1);\n    #if 1\n    //p.x = gain(p.x, 1.0/2.0); // distribute more samples at the border\n    //p.x = p.x*p.x;\n    p = p*2.0 - 1.0;\n    p.y = p.y * abs(p.x) * 0.0 + target_func(p.x);\n    #else\n    p = p*2.0 - 1.0;\n    #endif\n    return p;\n}\n#endif\n\nfloat pow2(float x) { return x*x; }\n\nstruct ModelSetup {\n    int input_count;\n    int layer_count;\n    int node_count;\n    int output_count;\n};\n\n#define NUM_MODEL_WEIGHTS(M) (M.node_count*(M.node_count*(M.layer_count - 1) + M.layer_count + M.input_count + M.output_count) + M.output_count)\n#define DEFINE_MODEL(NAME, IONAME, CFGNAME, SIZENAME, INPUTS, LAYERS, NODES, OUTPUTS) \\\n    const ModelSetup CFGNAME = ModelSetup(INPUTS, LAYERS, NODES, OUTPUTS); \\\n    const int SIZENAME = NUM_MODEL_WEIGHTS(CFGNAME); \\\n    struct NAME { \\\n        float c[SIZENAME]; \\\n    }; \\\n    struct IONAME { \\\n        vec2 i[INPUTS]; \\\n        vec2 o[OUTPUTS]; \\\n    };\n\n// for layer 0, node is in the range 0..NUM_NODES-1, edge is 0..NUM_INPUTS\n// for layer 1..NUM_LAYERS-1, node is in the range 0..NUM_NODES-1, edge is 0..NUM_NODES\n// for layer NUM_LAYERS, node is in the range 0..NUM_OUTPUTS-1, edge is 0..NUM_NODES\n// edge NUM_NODES is always the bias\nint weight_index(const ModelSetup setup, int layer, int node, int edge) {\n    int index = 0;\n    if (layer > 0) {\n        index = setup.node_count * ((setup.input_count + 1) + (setup.node_count + 1) * (layer - 1)) + node * (setup.node_count + 1) + edge;\n    } else {\n        index = node * (setup.input_count + 1) + edge;\n    }\n    return index;\n}\n#if USE_TRI\n#define ACTIVATE ad_tri\n#else\n#define ACTIVATE ad_sin\n#endif\n#define N(L, K, J) vec2(c.c[weight_index(setup, L, K, J)], v.c[weight_index(setup, L, K, J)])\n#define DEFINE_MODEL_EVAL_GRAD(NAME, MODELNAME, IONAME, CFGNAME) \\\nvoid NAME(MODELNAME c, MODELNAME v, inout IONAME io) { \\\n    const ModelSetup setup = CFGNAME; \\\n    /* first hidden layer */ \\\n    vec2 tmp0[CFGNAME.node_count]; \\\n    for (int k = 0; k < CFGNAME.node_count; ++k) { \\\n        tmp0[k] = N(0, k, CFGNAME.input_count); \\\n        for (int j = 0; j < CFGNAME.input_count; ++j) { \\\n            tmp0[k] = ad_add(tmp0[k], ad_mul(N(0, k, j), io.i[j])); \\\n        } \\\n        tmp0[k] = ACTIVATE(tmp0[k]); \\\n    } \\\n    /* rest of hidden layers */ \\\n    vec2 tmp1[CFGNAME.node_count]; \\\n    for (int l = 1; l < CFGNAME.layer_count; ++l) { \\\n        for (int k = 0; k < CFGNAME.node_count; ++k) { \\\n            tmp1[k] = N(l, k, CFGNAME.node_count); \\\n            for (int j = 0; j < CFGNAME.node_count; ++j) { \\\n                tmp1[k] = ad_add(tmp1[k], ad_mul(N(l, k, j), tmp0[j])); \\\n            } \\\n            tmp1[k] = ACTIVATE(tmp1[k]); \\\n        } \\\n        tmp0 = tmp1; \\\n    } \\\n    /* assemble output */ \\\n    for (int k = 0; k < CFGNAME.output_count; ++k) { \\\n        io.o[k] = N(CFGNAME.layer_count, k, CFGNAME.node_count); \\\n        for (int j = 0; j < CFGNAME.node_count; ++j) { \\\n            io.o[k] = ad_add(io.o[k], ad_mul(N(CFGNAME.layer_count, k, j), tmp0[j])); \\\n        } \\\n    } \\\n}\n\n#if USE_TRI\n#define DECLARE_INIT_CONSTANTS() \\\n    const float W_I = 15.0; \\\n    const float W_L = 1.0; \\\n    const float W_B = 1.0;\n#else\n#define DECLARE_INIT_CONSTANTS() \\\n    const float w0 = 30.0; \\\n    const float W_I = sqrt(6.0 / float(setup.input_count)) * w0; \\\n    const float W_L = sqrt(6.0 / (w0*w0*float(setup.node_count))) * w0; \\\n    const float W_B = 3.14159265359;\n#endif\n\n#define INITN(L, K, J) c.c[weight_index(setup, L, K, J)]\n#define DEFINE_MODEL_INIT(NAME, MODELNAME, CFGNAME) \\\nvoid NAME (inout MODELNAME c, inout Random rng) { \\\n    const ModelSetup setup = CFGNAME; \\\n    DECLARE_INIT_CONSTANTS(); \\\n    /* first hidden layer */ \\\n    for (int k = 0; k < CFGNAME.node_count; ++k) { \\\n        for (int j = 0; j < CFGNAME.input_count; ++j) { \\\n            INITN(0, k, j) = (random(rng)*2.0-1.0)*W_I; \\\n        } \\\n        /* init bias */ \\\n        INITN(0, k, CFGNAME.input_count) = (random(rng)*2.0-1.0)*W_B; \\\n    } \\\n    /* rest of hidden layers */ \\\n    for (int l = 1; l < CFGNAME.layer_count; ++l) { \\\n        for (int k = 0; k < CFGNAME.node_count; ++k) { \\\n            for (int j = 0; j < CFGNAME.node_count; ++j) { \\\n                INITN(l, k, j) = (random(rng)*2.0-1.0)*W_L; \\\n            } \\\n            /* init bias */ \\\n            INITN(l, k, CFGNAME.node_count) = (random(rng)*2.0-1.0)*W_B; \\\n        } \\\n    } \\\n    /* output weights */ \\\n    for (int k = 0; k < CFGNAME.output_count; ++k) { \\\n        for (int j = 0; j < CFGNAME.node_count; ++j) { \\\n            INITN(CFGNAME.layer_count, k, j) = random(rng)*2.0-1.0; \\\n        } \\\n        /* init bias */ \\\n        INITN(CFGNAME.layer_count, k, CFGNAME.node_count) = random(rng)*2.0-1.0; \\\n    } \\\n}\n\nDEFINE_MODEL(Model, ModelIO, model_setup, ModelSize, 1, 5, 2, 1)\nDEFINE_MODEL_EVAL_GRAD(model_eval, Model, ModelIO, model_setup)\nDEFINE_MODEL_INIT(model_init, Model, model_setup)\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nvec2 loss(Model source, Model v, int frame) {\n    vec2 err = vec2(0.0);\n    for (int i = 0; i < FIT_POINTS; ++i) {\n        vec2 p = get_point(i, frame);\n        ModelIO io;\n        io.i[0] = vec2(p.x, 0.0);\n        model_eval(source, v, io);\n        err += ad_sq(ad_sub(io.o[0], p.y));\n    }\n    err /= float(FIT_POINTS);\n    err = ad_sqrt(err);\n    //vec2 cost = model_cost(source, v);\n    //err.x += pow(err.y - 1.0, 2.0);\n    return err;\n}\n\n// https://arxiv.org/abs/2307.06324\nfloat alphastep() {\n    int n = (iFrame + 1) & ~iFrame;\n    return float(n % 63) * alpha;\n}\n#define alpha alphastep()\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setup_s_K(iFrame);\n    ivec2 fc = ivec2(fragCoord);\n    int ci = fc.x;\n    int mi = fc.y;\n    if (ci < ModelSize) {\n        Model startp;\n        if (iFrame == 0) {\n            Random rng = seed(ivec2(mi, 0));\n            model_init(startp, rng);\n            fragColor = vec4(startp.c[ci],0.0,0.0,0.0);\n        } else {\n            Model m, v, ema;\n            float t = float(iFrame + 1);\n            for (int i = 0; i < ModelSize; ++i) {\n                vec4 data = texelFetch(iChannel0, ivec2(i,mi), 0);\n                startp.c[i] = data.r;\n                m.c[i] = data.g;\n                v.c[i] = data.b;\n#if EMA\n                ema.c[i] = data.a;\n#endif                \n            }\n\n            vec2 l = loss(startp, startp, iFrame);\n\n            Random rng = seed(seed(mi), iFrame);\n            #if 1\n            {\n                Model testp;\n                Model testm;\n                Model testv;\n                #if EMA\n                Model testema;\n                #endif\n                // apply one round of differential evolution\n                // do more and more the later it is\n                float CR = tanh(t/(60.0*30.0));\n                float F = 0.0;\n                ivec3 k = sample_k_3(rng, int(iResolution.y), mi);\n                int R = range(rng, 0, ModelSize);\n                for (int i = 0; i < ModelSize; ++i) {\n                    if ((i == R) || (random(rng) < CR)) {\n                        vec4 ai = texelFetch(iChannel0, ivec2(i, k.x), 0);\n                        vec4 bi = texelFetch(iChannel0, ivec2(i, k.y), 0);\n                        vec4 ci = texelFetch(iChannel0, ivec2(i, k.z), 0);\n                        testp.c[i] = ai.x + F * (bi.x - ci.x);\n                        testm.c[i] = ai.y + F * (bi.y - ci.y);\n                        testv.c[i] = ai.z + F * (bi.z - ci.z);\n                        #if EMA\n                        testema.c[i] = ai.w + F * (bi.w - ci.w);\n                        #endif\n                    } else {\n                        testp.c[i] = startp.c[i];\n                        testm.c[i] = m.c[i];\n                        testv.c[i] = v.c[i];\n                        #if EMA\n                        testema.c[i] = ema.c[i];\n                        #endif\n                    }\n                }\n                vec2 newloss = loss(testp, testp, iFrame);\n                if (newloss.x < l.x) {\n                    startp = testp;\n                    m = testm;\n                    v = testv;\n                #if EMA\n                    ema = testema;\n                #endif\n                }\n            }\n            #endif\n            Model g;\n#if FULL_GRADIENT\n            Model d;\n            for (int i = 0; i < ModelSize; ++i) {\n                d.c[i] = 0.0;\n            }\n            d.c[0] = 1.0;\n            g.c[0] = loss(startp, d, iFrame).y;\n            for (int i = 1; i < ModelSize; ++i) {\n                d.c[i-1] = 0.0;\n                d.c[i] = 1.0;\n                g.c[i] = loss(startp, d, iFrame).y;\n            }\n            vec2 f_d = vec2(1.0);\n#else\n            float nf = 0.0;\n            for (int i = 0; i < ModelSize; ++i) {\n                g.c[i] = clamp(gaussian(rng, 0.0, 1.0), -gradient_clamp, gradient_clamp); \n                nf += g.c[i]*g.c[i];\n            }            \n#if NORMALIZE_MC_GRADIENT\n            nf = 1.0 / (nf + epsilon); // surface of d-sphere\n            //nf *= pow(random(rng), 1.0/float(NUM_WEIGHTS)); // inside d-ball\n            for (int i = 0; i < ModelSize; ++i) {\n                g.c[i] = g.c[i] * nf;\n            }\n#endif\n            vec2 f_d = loss(startp, g, iFrame);\n#endif\n            for (int i = 0; i < ModelSize; ++i) {\n#if STEPMETHOD == STEPMETHOD_SOFTCLAMP_NEWTON\n                // softclamped newton's method\n                float g_c_i = tanh(f_d.x / (g.c[i] * f_d.y)); \n#elif STEPMETHOD == STEPMETHOD_CLAMP_NEWTON\n                // softclamped newton's method\n                float g_c_i = clamp(f_d.x / (g.c[i] * f_d.y), -newton_clamp_limit, newton_clamp_limit);\n#elif STEPMETHOD == STEPMETHOD_NEWTON\n                // newton's method\n                float g_c_i = f_d.x / (g.c[i] * f_d.y);\n#else // STEPMETHOD == STEPMETHOD_GRADIENT\n                float g_c_i = g.c[i] * f_d.y;\n#endif\n#if (METHOD == METHOD_ADAM)                \n                // Adam gradient descent (https://arxiv.org/abs/1412.6980, algorithm 1)\n                float g2_c_i = g_c_i*g_c_i;\n                m.c[i] = mix(g_c_i, m.c[i], beta1);\n                v.c[i] = mix(g2_c_i, v.c[i], beta2);\n                float mu_c_i = m.c[i] / (1.0 - pow(beta1, t));\n                float vu_c_i = v.c[i] / (1.0 - pow(beta2, t));\n                startp.c[i] = startp.c[i] - alpha * mu_c_i / (sqrt(vu_c_i) + epsilon);\n#elif (METHOD == METHOD_ADAMAX)\n                // AdaMax gradient descent (https://arxiv.org/abs/1412.6980, algorithm 2)\n                m.c[i] = mix(g_c_i, m.c[i], beta1);                \n                v.c[i] = max(beta2 * v.c[i], abs(g_c_i));\n                startp.c[i] = startp.c[i] - (alpha / (1.0 - pow(beta1, t))) * m.c[i] / (v.c[i] + epsilon);                \n#else // FGD\n                // Gradients without Backpropagation (https://arxiv.org/abs/2202.08587)\n                startp.c[i] = startp.c[i] - alpha * g_c_i;\n#endif\n#if EMA\n                // Ema extension (https://arxiv.org/abs/1412.6980, 7.2)\n                ema.c[i] = mix(startp.c[i], ema.c[i], beta2);\n#endif                 \n            }\n            fragColor = vec4(startp.c[ci],m.c[ci],v.c[ci],ema.c[ci]);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}