{
    "Shader": {
        "info": {
            "date": "1671847458",
            "description": "I mainly made this because I noticed that ðŸ˜Ž Pixel Rave ðŸ˜Ž was the 11th fork in a chain of forks so I thought, hell, why not make it 12? ",
            "flags": 64,
            "hasliked": 0,
            "id": "dlf3D7",
            "likes": 25,
            "name": "ðŸ˜¸ Cat Rave ðŸ˜¸",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "cat",
                "motion"
            ],
            "usePreview": 0,
            "username": "Xibanya",
            "viewed": 567
        },
        "renderpass": [
            {
                "code": "// the audio doesn't start automatically sometimes and I don't know why?\n// if it doesn't start you can hit pause/unpause on iChannel0 and it'll start...\n\n// designs inspired by https://www.freepik.com/premium-vector/cute-cats-collection-cats-faces_10120615.htm\n// comment this out to get four rows of procgen cats rather than 2\n#define BIGGER\n\n#define PUPIL vec3(0.18, 0.17, 0.165)\n#define CAT_BASE_1 vec3(0.9, 0.77, 0.55)\n#define CAT_BASE_2 vec3(0.4, 0.37, 0.37)\n#define CAT_BASE_3 vec3(0.7, 0.6, 0.5)\n#define CAT_BASE_4 vec3(0.7, 0.6, 0.5)\n#define CAT_BASE_5 vec3(0.9, 0.9, 0.83)\n#define CAT_LIGHT_1 vec3(0.97, 0.9, 0.7)\n#define CAT_LIGHT_2 vec3(1., 0.95, 0.97)\n#define CAT_LIGHT_3 vec3(1., 0.95, 0.85) \n#define CAT_LIGHT_4 vec3(1., 0.96, 0.78)\n#define CAT_LIGHT_5 vec3(0.9, 0.9, 0.83)\n#define CAT_DARK_1 vec3(0.7, 0.5, 0.4)\n#define CAT_DARK_2 vec3(0.25, 0.2, 0.2)\n#define CAT_DARK_3 vec3(0.5, 0.4, 0.35)\n#define CAT_DARK_4 vec3(0.5, 0.4, 0.35)\n#define CAT_DARK_5 vec3(0.44, 0.37, 0.36)\n#define CAT_OUTLINE_1 vec3(0.37, 0.2, 0.13)\n#define CAT_OUTLINE_2 vec3(0.18, 0.18, 0.16)\n#define CAT_OUTLINE_3 vec3(0.35, 0.3, 0.26)\n#define CAT_OUTLINE_4 vec3(0.35, 0.3, 0.26)\n#define CAT_OUTLINE_5 vec3(0.35, 0.3, 0.26)\n#define CAT_EYE_1 vec3(1.)\n#define CAT_EYE_2 vec3(0.8, 0.76, 0.38)\n#define CAT_EYE_3 vec3(0.6, 0.86, 0.9)\n#define CAT_EYE_4 vec3(0.6, 0.86, 0.9)\n#define CAT_EYE_5 vec3(0.9)\n#define CAT_BELLY_1 vec3(0.97, 0.9, 0.7)\n#define CAT_BELLY_2 vec3(1., 0.95, 0.97)\n#define CAT_BELLY_3 vec3(0.7, 0.6, 0.5) * 1.1\n#define CAT_BELLY_4 vec3(1., 0.96, 0.78)\n#define CAT_BELLY_5 vec3(0.9, 0.9, 0.83)\n\n#define TABBY_SPOT 0.075\n\n#define MAX_ROTATION 150.\n#define MIN_ROTATION -150.\n#define MAX_EAR_DOWN 225.\n#define MAX_EAR_UP 195.\n\n#ifdef BIGGER\n    #define OUTLINE_THICKNESS 0.04\n#else\n    #define OUTLINE_THICKNESS 0.02\n#endif\n#define OUTLINE_THRESHOLD 0.7\n\nstruct Cat {\n    float butt; // width of the lower end of the body\n    float height; // body length\n    float rotation; // body rotation in degrees\n    vec3 baseColor;\n    vec3 lightColor;\n    vec3 darkColor;\n    vec3 outlineColor;\n    vec3 eyeColor;\n    vec3 belly;\n    float f; // this is to cache the FBM noise value\n    float r; // progress from min rotation value to max rotation value from 0 to 1\n    float faceDark;\n    float heart;\n    float spots;\n    float tabby;\n    int type;\n    vec3 sound;\n};\nmat2 Rotate2DMatrix(float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca, -sa, sa, ca);\n}\nvec2 Rotate2D(vec2 p, float a)\n{\n    return Rotate2DMatrix(radians(a)) * p;\n}\nvec3 DoOutline(float d, vec3 color, float thickness, vec3 outColor)\n{\n    if (d < 0.)\n    {\n        float t = -d / thickness;\n        t = t * t;\n        color = mix(outColor, color, step(OUTLINE_THRESHOLD, t));\n    }\n    return color;\n}\nfloat InvLerp(in float from, float to, float value)\n{\n    return (value - from) / (to - from);\n}\nvec2 interpolate(vec2 a, vec2 b, vec2 c, vec2 d, float p)\n{\n    vec2 v0 = mix(a, b, p);\n    vec2 v1 = mix(b, c, p);\n    vec2 v2 = mix(c, d, p);\n    vec2 v3 = mix(v0, v1, p);\n    vec2 v4 = mix(v1, v2, p);\n    \n    return mix(v3, v4, p);\n}\nfloat Spline(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n// 2D SDF functions from https://iquilezles.org/articles/distfunctions2d/\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat Heart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\nfloat UnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\nfloat EquiTriSDF(in vec2 p)\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\nfloat Isosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat Egg( in vec2 p, in float ra, in float rb )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    float r = ra - rb;\n    return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n            (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\nfloat Circle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat FBMRandom(vec2 st)\n{\n    vec2 m = vec2(iMouse.xy);\n    return fract(sin(dot(st.xy, m + vec2(12.9898, 78.233))) *\n                    43758.5453123);\n}\nfloat Audio(float x)\n{\n    return texture(iChannel0, vec2(x, 0.0)).r;\n}\n// https://www.shadertoy.com/view/MtG3Wh by FabriceNeyret2\nvec4 hue(float x)\n{\n    return .5+.5*cos(6.283185*(x +vec4(0,1,-1,0)/3.));\n}\nCat GetCat(vec2 uv)\n{\n    // declaring the arrays outside the function doesn't work on some platforms\n    // so gotta do this rigamarole here\n    vec3[5] base;\n    base[0] = CAT_BASE_1; base[1] = CAT_BASE_2; base[2] = CAT_BASE_3; \n    base[3] = CAT_BASE_4; base[4] = CAT_BASE_5;\n\n    vec3[5] light;\n    light[0] = CAT_LIGHT_1; light[1] = CAT_LIGHT_2; light[2] = CAT_LIGHT_3; \n    light[3] = CAT_LIGHT_4; light[4] = CAT_LIGHT_5;\n\n    vec3[5] dark;\n    dark[0] = CAT_DARK_1; dark[1] = CAT_DARK_2; dark[2] = CAT_DARK_3; \n    dark[3] = CAT_DARK_4; dark[4] = CAT_DARK_5;\n\n    vec3[3] eye;\n    eye[0] = CAT_EYE_1; eye[1] = CAT_EYE_2; eye[2] = CAT_EYE_3;\n\n    vec3[5] outline;\n    outline[0] = CAT_OUTLINE_1; outline[1] = CAT_OUTLINE_2; outline[2] = CAT_OUTLINE_3; \n    outline[3] = CAT_OUTLINE_4; outline[4] = CAT_OUTLINE_5;\n\n    vec3[5] belly;\n    belly[0] = CAT_BELLY_1; belly[1] = CAT_BELLY_2;\n    belly[2] = CAT_BELLY_3; belly[3] = CAT_BELLY_4;\n    belly[4] = CAT_BELLY_5;\n\n    Cat cat;\n\n    vec2 cUV = floor(uv * 2.);\n\n    float f = clamp(0., 1., FBMRandom(cUV));\n    cat.f = f;\n    int i = 0;\n    float count = 5.;\n    float mul = 1000.;\n    float cF = fract(f + cUV.x + cUV.y * 0.5);\n    if (mod(floor(cF * mul) + 1., count) == 0.) i = 1;\n    else if (mod(floor(cF * mul) + 2., count) == 0.) i = 2; \n    else if (mod(floor(cF * mul) + 3., count) == 0.) i = 3; \n    else if (mod(floor(cF * mul) + 4., count) == 0.) i = 4;\n\n    cat.type = i;\n    \n    float isEven = mod(float(i), 2.) == 0.? 1. : 0.;\n    float audioHigh = Audio(0.95 * isEven + 0.75 * (1. - isEven));\n    float audioMed = Audio(0.65 * isEven + 0.45 * (1. - isEven));\n    float bass = Audio(0.1);\n    cat.sound = vec3(audioHigh, audioMed, bass);\n    audioMed = smoothstep(0.25, 1., audioMed);\n    \n    cat.baseColor = base[i] * mix(vec3(1.), hue(cat.f).rgb * 1.25, smoothstep(0.15, 0.75, audioHigh));\n    cat.lightColor = light[i] + pow(hue(float(i)).rgb, vec3(audioMed));\n    cat.darkColor = dark[i] + hue(cat.f).rgb * audioHigh;\n    cat.outlineColor = outline[i];\n    cat.belly = belly[i];\n    cat.eyeColor = mod(floor(f * 100.), 3.) == 0.? eye[0] : \n        (mod(floor(f * 100.) + 1., 3.) == 0.? eye[1] : eye[2]);\n\n    float highRot = (smoothstep(0.5, 1., audioHigh) * 2. - 1.) * 0.5;\n    cat.rotation = mix(MIN_ROTATION, MAX_ROTATION, fract(f + cUV.x * 0.3) + highRot);\n    cat.r = InvLerp(MIN_ROTATION, MAX_ROTATION, cat.rotation);\n    cat.height = mix(0.5, 1., fract(f + 0.5 + cUV.y));\n    bass = smoothstep(0.6, 1., bass) * 2. - 1.;\n    cat.butt = mix(0.65, 0.95, abs(f * 2. - 1.) + bass * 0.25);\n   \n    cat.faceDark = mod(floor((1. - cat.f) * 5.), 4.) == 0.? 1. : 0.;\n    cat.heart = mod(floor(fract(cat.f + 0.75) * 10.), 2.) == 0.? 1. : 0.;\n    cat.spots = mod(floor(cat.f * 1450.), 2.) == 0.? 1. : 0.;\n    cat.tabby = mod(floor(fract(cat.f + 0.25) * 1329.), 3.) == 0.? 1. : 0.;\n\n    return cat;\n}\nfloat Smooth(float sdf) { return 1. - smoothstep(-0.025, -0.01, sdf);}\nfloat TopMarks(vec2 headUV)\n{\n    float xSign = sign(headUV.x);  \n    vec2 mUV = headUV * vec2(7., 1.) + vec2(0., 2.);\n    float markScale = 1.;\n    float mSDF = Circle(mUV, markScale);\n\n    vec2 mUV1 = Rotate2D(headUV, 16. * xSign);\n    mUV1 = mUV1 * vec2(10., 1.) + vec2(-1. * -xSign, 2.2);\n    mSDF = min(mSDF, Circle(mUV1, markScale));\n    return mSDF;\n}\nfloat HeartMark(vec2 headUV)\n{\n    vec2 heartUV = headUV * vec2(0.15, 0.2) + vec2(0., 1.05);\n    return Heart(heartUV);\n}\nvoid HeadMarkings(vec2 p, Cat cat, inout vec3 col)\n{\n    float xSign = sign(p.x);\n    vec3 light = mix(cat.lightColor * 1.1, cat.lightColor, \n        clamp(0., 1., dot(p, p)));\n    if (cat.heart == 1.)\n    {\n        float heartSDF = HeartMark(p);\n        col = heartSDF < 0.? col : light;\n    }\n   \n    if (cat.faceDark == 1.)\n    {\n        float spots = 0.;\n        vec3 sColor = cat.darkColor;\n        if (cat.spots == 1.)\n        {\n            float w =  sin(p.x * 50.) * 0.025;\n            vec2 stUV = p + vec2(1., 1.4);\n            stUV.y += w;\n            spots = Circle(stUV * vec2(1., 1.2), 1.2);\n            stUV -= vec2(2.3, 0.1);\n            spots = min(spots, Circle(Rotate2D(stUV, 25.) * vec2(1., 1.75), 0.75));\n            if (cat.heart == 0.)\n            {\n                stUV = p - vec2(0.8, 1.4);\n                stUV.y += w * 0.2;\n                stUV.x *= 0.7;\n                spots = min(spots, Circle(stUV, 0.75));\n            }\n            if (cat.tabby == 1.) sColor += TABBY_SPOT;\n        }\n        else\n        {\n            vec2 sideUV = p - vec2(1.6 * xSign, -0.9);\n            spots = Circle(sideUV, 1.5);\n        }\n         col = mix(col, sColor, Smooth(spots));\n    }\n    if (cat.tabby == 1.)\n    {\n        float mSDF = TopMarks(p);\n        col = mix(col, cat.darkColor, Smooth(mSDF));\n    }\n    if (mod(floor(cat.f * 1000.), 2.) == 0.)\n    {\n        float muzzle = Isosceles(p * 3. + vec2(0., 0.1), vec2(0.9, 1.)) - 1.;\n        col = mix(col, light, Smooth(muzzle));\n    }\n}\nvoid Eyes(vec2 headUV, Cat cat, inout vec3 col)\n{\n    float xSign = sign(headUV.x);  \n    vec2 eyeUV = headUV + vec2(0., 0.5);\n    eyeUV.x -= 0.8 * xSign;\n\n    // blinky blinky\n    float t = sin(iTime * max(0.5, cat.f) + cat.f) * 0.5 + 0.5;\n    float b = smoothstep(0., 1., InvLerp(0.999, 1., t));\n    eyeUV.y = mix(eyeUV.y, eyeUV.y * 7., b);\n\n    float eyeScale = mix(0.5, 0.55, cat.f);\n    float eyeSDF = Circle(eyeUV, eyeScale);\n    vec3 eyeCol = cat.eyeColor;\n    float pupil = Circle(eyeUV, eyeScale * 0.75);\n    eyeCol = mix(eyeCol, PUPIL, Smooth(pupil));\n    vec2 shineUV = eyeUV + vec2(0.2, 0.15);\n    float shine = Circle(shineUV, eyeScale * 0.3);\n    shine = min(shine, Circle(shineUV + vec2(0.1, -0.2), eyeScale * 0.15));\n    eyeCol = mix(eyeCol, vec3(1.), Smooth(shine));\n    vec2 lidUV = eyeUV * vec2(1., 0.95) + vec2(0., 0.05);\n    lidUV.y = mix(lidUV.y, lidUV.y * 0.95 - 0.02, b);\n    float lid = Circle(lidUV, eyeScale);\n    vec3 lidColor = cat.faceDark == 1.? cat.outlineColor : cat.darkColor;\n    eyeCol = mix(lidColor, eyeCol, Smooth(eyeSDF));\n    eyeSDF = min(eyeSDF, lid);\n    col = mix(col, eyeCol, Smooth(eyeSDF));\n}\nfloat Head(vec2 p, Cat cat, out vec3 col)\n{\n    float headHeight = cat.height * 1.2;\n    float headScale = 2.5 - smoothstep(0.25, 0.75, cat.sound.x) * 0.25;\n    vec2 headUV = (p - vec2(0., headHeight)) * headScale;\n    float headRot = (smoothstep(0.25, 1., cat.sound.y) * 2. - 1. ) * 10. * cat.sound.y * -sign(cat.rotation);\n    headUV = Rotate2D(headUV, -cat.rotation + headRot);\n    headUV.y *= -1.;\n    float xSign = sign(headUV.x);  \n    float headSDF = Egg(headUV, 2., 3.) + 0.1;\n    vec2 huv = headUV + vec2(0., 0.);\n    col = mix(cat.baseColor * 1.2, cat.baseColor, \n        smoothstep(0., 1.5, dot(huv, huv)));\n\n    // markings\n    HeadMarkings(headUV, cat, col);\n\n    //Ears\n    vec2 earUV = headUV;\n    earUV.x -= 1.1 * xSign;\n    earUV.y += 1.1;\n    float earWiggle = smoothstep(0.5, 1., Audio(0.5));\n    float earRot = mix(MAX_EAR_DOWN - earWiggle * 100., MAX_EAR_UP + earWiggle * 50., fract(cat.f * 25.) );\n    float earTip = 1.;\n    if (mod(floor(cat.f * 0.35 * 1000.), 3.) == 0.) earTip = 0.75;\n    earUV = Rotate2D(earUV, earRot * xSign);\n    float ear = Egg(earUV, 2., earTip) + 1.2;\n    vec3 earColor = cat.darkColor;\n    earUV = Rotate2D(earUV, -5. * xSign);\n    float earNeg = Egg(earUV * vec2(1.1, 1.) + vec2(0.2 * xSign, 0.), 2., 1.) + 1.4;\n    earColor = mix(earColor, cat.lightColor, Smooth(earNeg));\n    col = mix(earColor, col, Smooth(headSDF));\n    headSDF = min(headSDF, ear);\n   \n    // nose\n    vec3 noseColor = cat.outlineColor;\n    float noseScale = 8.;\n    vec2 noseUV = headUV;\n   \n    float bridge = Isosceles(noseUV * noseScale + vec2(0., 2.3), \n        vec2(0.7, 2.5)) - .75;\n    vec3 bridgeCol = cat.darkColor;\n    if (cat.type == 1) bridgeCol = cat.baseColor;\n    else if (mod(floor(cat.f * 2324321.), 2.) == 0.)\n    {\n        bridgeCol = cat.baseColor * 1.1;\n    }\n    col = mix(col, bridgeCol, Smooth(bridge));\n\n    noseUV *= vec2(1., -1.);\n    noseUV.y += 0.2;\n    float noseSDF = Isosceles(noseUV * noseScale, vec2(1.1, 0.8)) - .5;\n    col = mix(col, noseColor, Smooth(noseSDF));\n\n    // Eyes\n    Eyes(headUV, cat, col);\n\n    // Mouth\n    vec2 mouthUV = headUV - vec2(0., 0.3);\n    mouthUV.x *= 0.8;\n    mouthUV.x -= 0.19 * xSign;\n    float mouthScale = 0.2;\n    float mouth = Circle(mouthUV, mouthScale);\n    mouthUV = mouthUV * vec2(1.2, 0.9) + vec2(0., 0.1);\n    mouth = max(mouth, -Circle(mouthUV, mouthScale));\n    col = mix(col, cat.outlineColor, Smooth(mouth));\n\n    // head outline before whiskers\n    col = DoOutline(headSDF, col, OUTLINE_THICKNESS * headScale, cat.outlineColor);\n\n    // whiskers\n    vec2 wUV = headUV;\n    wUV.x -= 2. * xSign;\n    wUV.y -= 1.;\n    float wScale = 1.2;\n    float whisker = Circle(wUV, wScale);\n    vec2 wUV2 = wUV * vec2(0.8, 1.) - vec2(0.1 * xSign, 0.075);\n    whisker = max(whisker, -Circle(wUV2, wScale));\n\n    wUV.x += 0.35 * xSign;\n    wUV.y -= 0.25;\n    float w2 = Circle(wUV, wScale);\n    wUV2 = wUV * vec2(0.8, 1.) + vec2(0.1 * xSign, -0.075);\n    w2 = max(w2, -Circle(wUV2, wScale));\n    whisker = min(whisker, w2);\n\n    wUV.x += 0.1 * xSign;\n    wUV.y -= 0.15;\n    w2 = Circle(wUV, wScale);\n    wUV2 = wUV * vec2(0.75, 1.) + vec2(0.2 * xSign, -0.05);\n    w2 = max(w2, -Circle(wUV2, wScale));\n    whisker = min(whisker, w2);\n\n    col = whisker < 0.? cat.outlineColor : col;\n\n    headSDF = min(headSDF, whisker);\n    return headSDF;\n}\nfloat Tail(vec2 uv, Cat cat)\n{\n    float rSign = sign(cat.rotation);\n    float xMul = cat.r * 2. - 1.;\n    float invX = 1. - abs(xMul);\n    float t = (sin(iTime * (cat.f + cat.sound.y * 0.001) + cat.f + cat.sound.z * 0.1) * 0.5 + 0.5);\n    \n    float rotMod = (Audio(cat.f) * 2. - 1.) * 0.5;\n    t += rotMod;\n    xMul -= rotMod;\n\n    vec2 a = vec2(0. - cat.sound.y * 0.1, 0.6 + cat.sound.x * 0.1 - cat.sound.z * 0.15);\n    vec2 b = vec2(1. * xMul * t - cat.sound.z * 0.2, 1. * abs(xMul) - cat.sound.y * 0.1);\n    vec2 c = vec2((-0.5 + 0.5 *invX) * xMul + 1.5 * invX + t * 0.5 - cat.sound.z * 0.1, 1. - 0.5 * invX);\n    vec2 d = vec2((0.3 + 0.5 * invX) * xMul * t + cat.sound.y * 0.1, 1.5 + 0.15 * abs(xMul) * t * 2. - cat.sound.z * 0.1);\n\n    float tail = 0.;\n    const float STEPS = 20.;\n    for (float i = 0.; i < STEPS; ++i)\n    {\n        vec2  p0 = interpolate(a, b, c, d, (i   ) / STEPS);\n        vec2  p1 = interpolate(a, b, c, d, (i+1.) / STEPS);\n        float l = Spline(uv, p0, p1) - 0.1;\n        tail = min(tail, l);\n    }   \n    return tail;\n}\nvoid BackPattern(vec2 p, Cat cat, inout vec3 col)\n{\n    float r = cat.r * 2. - 1.;\n    float aR = abs(r);\n    float rSign = sign(r);\n    \n    //spots\n    if ((cat.spots == 1. || cat.faceDark == 1.))\n    {\n        vec2 spotUV = p * 7.;\n        spotUV.y += mix(10., 2., aR) * rSign;\n        spotUV.x += mix(-10., -3., aR) * rSign;\n\n        // if smooth face marks, spots should also be smooth\n        if (cat.spots == 1.) spotUV.y += sin(spotUV.x * 10.) * 0.1;\n       \n        float spot = EquiTriSDF(spotUV) - 2.;\n        spot = min(spot, EquiTriSDF(spotUV * 2. + \n            vec2(10. * rSign + 10. * step(rSign, 0.), 6. + 5. * step(rSign, 0.))) - 2.);\n\n        vec3 spotColor = cat.darkColor;\n        if (cat.tabby == 1.) spotColor += TABBY_SPOT;\n        \n        col = spot < 0.? spotColor : col;\n    }\n    \n    // tabby stripes\n    if (cat.tabby == 1.)\n    {\n        float xSign = sign(p.x);\n        vec2 uv = p;\n        \n        if (rSign > 0.)\n        {\n            uv.x += mix(-2., -.05, aR);\n            uv = Rotate2D(uv, 25. * aR);\n        }\n        else if (rSign < 0.)\n        {\n            uv.x += mix(2., 0.5, aR);\n            uv = Rotate2D(uv, -50. * aR);\n        }\n        uv *= vec2(1., 8.);\n        float l = Circle(uv, 0.5);\n        l = min(l, Circle(uv + vec2(0., 1.5), 0.5));\n        l = min(l, Circle(uv - vec2(0, 1.5), 0.5));\n        col = l < 0.? cat.darkColor : col;\n    }\n}\nfloat SceneSDF(vec2 p, out vec3 col)\n{\n    Cat cat = GetCat(p);\n    p = fract(p * 2.) - 0.5;\n    #ifdef BIGGER\n    float scale = 4.;\n    p.y += 0.1;\n    #else\n     float scale = 4.5;\n    #endif\n    \n    vec2 bodyUV = p * scale;\n    \n    float rotMod = cat.f + (Audio(0.25) * 2. - 1.) * 0.01;\n   \n    col = mix(cat.baseColor, cat.baseColor * 1.2, dot(bodyUV, bodyUV) * 0.5 + 0.5);\n    cat.rotation += mix(-50., 50., cos(iTime * 0.2 * rotMod + (rotMod * 2. - 1.)) * 0.5 + 0.5);\n    bodyUV = Rotate2D(bodyUV, cat.rotation);\n   \n    float sdf = UnevenCapsule(bodyUV, cat.butt, 0.5, cat.height);\n\n    BackPattern(bodyUV, cat, col);\n\n    vec2 bellyUV = bodyUV;\n    bellyUV.y += sin(bodyUV.x * 75.) * 0.025;\n    float b = InvLerp(-90., 90., cat.rotation);\n    float bX = 0.75;\n    bellyUV.x += mix(-bX, bX, b);\n    bellyUV.y += mix(-0.1, 0.1, b);\n    float width = mix(0.7, 0.5, abs(b * 2. - 1.));\n    float belly = UnevenCapsule(bellyUV * 1.5, width, 0.5, cat.height) - 0.2;\n    col = mix(col, cat.belly, Smooth(belly));\n    col = DoOutline(sdf, col, OUTLINE_THICKNESS, cat.outlineColor);\n\n    // head casting shadow on the body\n    float shadow = Circle(bodyUV - vec2(0., cat.height * 1.1), 0.5);\n    col = shadow < 0.? col * 0.9 : col;\n\n    vec3 headCol;\n    float headSDF = Head(bodyUV, cat, headCol);\n    col = headSDF < 0.? headCol : col;\n    sdf = min(sdf, headSDF);\n\n    float tail = Tail(p * scale, cat);\n    vec3 tailCol = DoOutline(tail, cat.baseColor, OUTLINE_THICKNESS, cat.outlineColor);\n    col = sdf < 0.? col : tailCol;\n    sdf = min(sdf, tail);  \n    return sdf;\n}\n\n// this part is from the Pixel Rave shader this one's forked from\n// https://www.shadertoy.com/view/dts3Dr\n#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\n//https://lospec.com/palette-list/endesga-32\n#define c0 vec3(184,111,80)/255.\n#define c1 vec3(194,133,105)/255.\n#define c2 vec3(228,166,114)/255.\n#define c3 vec3(232,183,150)/255.\n// From Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec4 h41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);   \n}\nvec3 Visualizer(vec2 f)\n{\n    f.x += 10.;\n    vec2 uv = (f - 0.5 * iResolution.xy) / iResolution.y;\n    float sc = 0.3;\n    vec3 tx = texelFetch(iChannel0, ivec2(sc*f), 0).rgb;\n    vec3 col = vec3(0);\n    \n    float w = 64. / sc;\n    f.x += floor(-30. * iTime/sc) - 4.;\n    float ix = floor(f.x/w);\n    vec4 h = h41(ix);\n    \n    if (tx == vec3(1)) tx = vec3(24,20,37)/255.;\n    else if (tx.r > 0.) col = c0 * tx.r;\n    else if (tx.b > 0.) col = c1 * tx.b;\n    else if (tx.g > 0.) col = c2 * tx.g;\n    \n    vec3 pl = .5+.5*cos(2.*pi*(ix/8. + vec3(0,1,2)/3.));\n    float mx = mix(0., 0.5-0.5*uv.y, .25+.25*thc(400.,2.*pi*h.x - 10.*h.x*uv.y+iTime));\n    mx *= tanh(0.1 * iTime);\n    if (tx == vec3(0)) {\n        col = vec3(mix(240.,210.,.5-uv.y))/255.;\n        col = mix(col, pl, mx);\n    }\n    else\n        col = mix(col, col * (.6+.4*pl), mx);\n        \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    p.x += (iTime + 3000.) * 0.25;\n    #ifdef BIGGER\n        // adjusting for how it looks different in shadertoy \n        // than from VSCode where I authored this...\n        p *= 0.5;\n        p.y += 0.01;\n    #else\n        p.y += 0.025;\n    #endif\n    \n    float bass = smoothstep(0.25, 1., Audio(0.2));\n    // https://www.shadertoy.com/view/llycWD\n    vec2 shake = vec2(sin(iTime * 10. + bass * 2.), cos(iTime * 3. + bass)) * 0.015;\n   \n    vec3 col = Visualizer((p + shake * 0.25) * 1000.);\n    vec3 fg = vec3(0.);\n    \n    float sdf = SceneSDF(p + shake, fg);\n    col = sdf < 0.? fg : col;\n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 31654,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/kordhell/murder-in-my-mind"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}