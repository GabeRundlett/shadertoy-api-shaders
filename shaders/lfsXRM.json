{
    "Shader": {
        "info": {
            "date": "1705158600",
            "description": "[url]https://x.com/AkiyoshiKitaoka/status/1742853795988808023?s=20[/url]\n\nTry scrolling to see it move!",
            "flags": 0,
            "hasliked": 0,
            "id": "lfsXRM",
            "likes": 9,
            "name": "Moving heart illusion",
            "published": 3,
            "tags": [
                "2d",
                "illusion",
                "opticalillusion",
                "apparentmotion"
            ],
            "usePreview": 0,
            "username": "sheepmaster",
            "viewed": 182
        },
        "renderpass": [
            {
                "code": "const float HEART_SCALE = 1.1;\nconst float TILE_SIZE = 46.;\nconst float BORDER_SIZE = 1.;\nconst float CORNER_SIZE = 8.;\n\n// Drop shadow for the heart.\nconst vec2 SHADOW_OFFSET = vec2(0.01, -0.01);\nconst float SHADOW_BLUR_RADIUS = 0.05;\n// Shadow color with alpha value for blending.\nconst ivec4 SHADOW_COLOR = ivec4(0x00, 0x00, 0x00, 0x7F);\n\nconst ivec3 BG_COLOR = ivec3(0xCC, 0x66, 0xFF);\nconst ivec3 HEART_COLOR = ivec3(0xFF, 0x00, 0x00);\nconst ivec3 FG_COLOR_1 = ivec3(0xFF, 0xFF, 0xFF);\nconst ivec3 FG_COLOR_2 = ivec3(0x00, 0x00, 0x00);\n\n// Anti-aliasing variant of step() using linear interpolation\nfloat aaStep(float edge, float x, float w) {\n    return clamp((x - edge) / (2. * w) + 0.5, 0., 1.);\n}\n\n// Approximation of the error function from https://www.shadertoy.com/view/7dXXDN\nfloat erf(float x) {\n    const float P = sqrt(3.14159265359)/2.;\n    float e = exp(-x*x);\n    return sign(x)/P * sqrt(1. - e) * (P + 31./200.*e - 341./8000.*e*e);\n}\n\nfloat gaussianSmooth(float x, float sd) {\n    return (erf(x / (sqrt(2.) * sd)) + 1.)/2.;\n}\n\nfloat dot2(in vec2 v) { return dot(v,v); }\n\n// Heart-shaped SDF from https://www.shadertoy.com/view/DldXRf\nfloat sdHeart(in vec2 p) {\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\n// Heart-shaped SDF with gradient from https://www.shadertoy.com/view/DldXRf\nvec3 sdgHeart(in vec2 p) {\n    float sx = (p.x<0.0)?-1.0:1.0;\n    p.x = abs(p.x);\n \n    if(p.y+p.x>1.0) {\n        const float r = sqrt(2.0)/4.0;\n        vec2 q0 = p - vec2(0.25,0.75);\n        float l = length(q0);\n        vec3 d = vec3(l-r, q0/l);\n        d.y *= sx;\n        return d;\n    } else {\n        vec2 q1 = p - vec2(0.0,1.0);\n        vec3 d1 = vec3(dot(q1,q1),q1);\n        vec2 q2 = p - 0.5*max(p.x+p.y,0.0);\n        vec3 d2 = vec3(dot(q2,q2),q2);\n        vec3 d = (d1.x<d2.x) ? d1: d2;\n        d.x = sqrt(d.x);\n        d.yz /= d.x;\n        d *= (p.x>p.y)?1.0:-1.0;\n        d.y *= sx;\n        return d;\n    }\n}\n\nfloat minOf(in vec2 v) {\n    return min(v.x, v.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const vec3 bgCol = vec3(BG_COLOR) / 255.;\n    const vec3 heartCol = vec3(HEART_COLOR) / 255.;\n    const vec4 shadowCol = vec4(SHADOW_COLOR) / 255.;\n    const vec3 fgCol1 = vec3(FG_COLOR_1) / 255.;\n    const vec3 fgCol2 = vec3(FG_COLOR_2) / 255.;\n\n    float scale = 1. / (minOf(iResolution.xy) * HEART_SCALE);\n    vec2 relCoord = (2. * fragCoord - iResolution.xy) * scale;\n    relCoord.y += 0.5;\n    float heart = 1. - aaStep(0., sdHeart(relCoord), scale);\n    float dropShadow = 1. - gaussianSmooth(sdHeart(relCoord - SHADOW_OFFSET), SHADOW_BLUR_RADIUS);\n    vec3 background = mix(bgCol, shadowCol.rgb, dropShadow*shadowCol.a);\n    vec3 col = mix(background, heartCol, heart);\n\n    float tileScale = 1. / TILE_SIZE;\n    // Center the tiles, attempting to avoid catastrophic cancellation by minimizing the shift.\n    vec2 tile = (fragCoord - mod(iResolution.xy, 2. * TILE_SIZE) * 0.5) * tileScale + 0.5;\n    vec2 tileCornerDist = abs(tile - round(tile)); \n    float grid = 1. - aaStep(BORDER_SIZE * 0.5 * tileScale, minOf(tileCornerDist), tileScale);\n    float corner = 1. - aaStep(CORNER_SIZE * tileScale, tileCornerDist.x + tileCornerDist.y, tileScale);\n    float flip = 1. - heart * 2.;\n    vec3 gridCol = mix(fgCol1, fgCol2, floor(mod(tile.x + flip * tile.y, 2.)));\n    col = mix(col, gridCol, max(grid, corner));\n\n    fragColor = vec4(col, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}