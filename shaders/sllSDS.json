{
    "Shader": {
        "info": {
            "date": "1626467598",
            "description": "After just finishing the Ready Player One book, and watching the film a couple of times, I was inspired\nto try to make a scene inspired by it.\nHope you like it!\n",
            "flags": 1,
            "hasliked": 0,
            "id": "sllSDS",
            "likes": 38,
            "name": "Ready Player One",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "glow",
                "vr",
                "movie",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "dean_the_coder",
            "viewed": 6946
        },
        "renderpass": [
            {
                "code": "// 'Ready Player One' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/sllSDS (YouTube: https://youtu.be/jUx2yGj3pGo)\n//\n// \"It's not about winning, it's about playing.\"\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// After just finishing the Ready Player One book,\n// and watching the film a couple of times, I was inspired\n// to try to make a scene inspired by it.\n//\n// Hope you like it!\n//\n// Tricks to get the performance:\n//\n// A relatively straight-forward ray-marching scene, but to keep\n// the performance up I've tried to avoid adding noise into the SDF\n// as much as possible - The finer detail on the terrain is applied\n// when calculating the material color.\n//\n// The Iron Giant only has one real arm and leg - I've used mirroring\n// on the X axis to duplicate the other side.\n// The arm and leg SDF is generated from the same function, parameterized\n// to slightly adjust appearance.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// Blackle and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c) smoothstep(a, b, c)\n\nfloat t, g;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 uv;\n};\n\n#define HASH\tp = fract(p * .1031); p *= p + 3.3456; return fract(p * (p + p));\n\nvec4 h44(vec4 p) { HASH }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(h44(h), h44(h + s.x), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\n#define minH(a)\tif (a.d < h.d) h = a\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat hex(vec3 p, vec2 h) {\n\tconst vec3 k = vec3(-.8660254, .5, .57735);\n\tp = abs(p);\n\tp.xy -= 2. * min(dot(k.xy, p.xy), 0.) * k.xy;\n\tvec2 d = vec2(length(p.xy - vec2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x), p.z - h.y);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.zy), p.x)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.y -= clamp(p.y, 0., h);\n\treturn length(p) - r;\n}\n\nfloat pod(vec3 p, float s) { return hex(p.xzy, vec2(.5 - (p.y > 0. ? p.y * .3 : 0.), 1) * s); }\n\nfloat limb(inout vec3 p, float a1, float a2, float s) {\n\tfloat f, d,\n\t      oy = p.y;\n\tp.yz *= rot(a1);\n\tf = max(max(length(p.zy) - .45, p.x - p.y), -p.x);\n\td = min(cyl(p, vec2(.5, .1)), f);\n\tf = p.y;\n\tp.y = abs(p.y + .7) - .7;\n\td = min(d, length(p) - .35 + .1 * step(oy, -.3));\n\tp.y = f + 1.2;\n\td = min(d, cap(p, 1., .2));\n\tp.y += .2;\n\tp.yz *= rot(a2);\n\tp.y += .1 + s;\n\treturn min(d, pod(p, s));\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nHit map(vec3 p, bool shield) {\n\tvec3 pp, op,\n\t     rp = p;\n\trp.xz *= rot(S(-1., 1., 1.5 * sin(cos(t * .5))) - .5);\n\tpp = rp;\n\tpp.z += .05;\n\tfloat bd, bdd, eye, mx, lxz, d,\n\t      chin = max(cap(pp, .6, .5), -pp.z - .45);\n\tchin = max(chin, rp.y - .6);\n\tpp.y -= 1.3 + pp.z * .2;\n\tpp.z += 1.1;\n\tbd = max(min(cap(rp, .7, .45), max(chin, -box(pp, vec3(1)))), .15 - rp.y + rp.z * .5);\n\tpp = rp;\n\tpp.x = abs(pp.x) - .2;\n\tpp.yz = rp.yz - vec2(.6, -.4);\n\top = pp;\n\tbd = min(max(bd, .12 - length(pp)), cyl(rp - vec3(0, .7, 0), vec2(.5, .02)));\n\teye = max(length(pp - vec3(0, 0, .1)) - .1, abs(pp.y) - S(1., .8, sin(t * .9)) + .05);\n\tg += 1e-4 / (.001 + eye * eye);\n\tHit orb,\n\t    h = Hit(eye, 3, rp);\n\tmx = abs(p.x);\n\tpp.x = mx - .2;\n\tpp.yz = p.yz - vec2(.6, -.4);\n\tlxz = length(p.xz);\n\td = .25 + .35 * step(p.y, -1.) * mix(.8, 1., sat(2. * abs(sin(p.y * 10.))));\n\tbdd = max(max(lxz - d, p.y - 1.), -p.y - 2.5);\n\td = max(max(max(length(p.xz * vec2(.5, .9)) - (p.y + 6.2) * .12, p.y + 1.), -p.y - 2.), -box(pp + vec3(0, 2.4, 0), vec3(-pp.y * .18, .3, 1)));\n\tbd = min(bd, d);\n\tpp.x -= .4;\n\tpp.y += 1.4;\n\tpp.xz *= rot(.4);\n\tpp.xy *= rot(-.1);\n\tbd = min(bd, .9 * box(pp, vec3(.8, .5 + pp.z * .4, .25)));\n\tpp = p;\n\tpp.x = mx - 1.58;\n\tpp.xy *= rot(.1);\n\tpp.y += .8;\n\tbd = min(bd, limb(pp, -.2, .4, .7));\n\td = box(pp + vec3(-.1, .9, 0), vec3(0, .2, .2));\n\tpp.xy *= rot(-.7 - sin(t) * .025);\n\tbd = min(bd, min(d, box(pp + vec3(-.8, 1, 0), vec3(0, .2, .2))) - .1 + .03 * abs(sin(pp.z * 20.75)));\n\tpp = p;\n\tpp.y += 3.2;\n\tpp.x = floor(mx * 5.) / 5.;\n\tminH(Hit(min(bdd, cap(pp, 1., .3)), 2, p));\n\tbd = min(bd, max(length(pp.zy) - .15, lxz - 1.));\n\tpp.x = mx - 1.;\n\tbd = min(bd, limb(pp, .2, -.2, 1.));\n\tpp.y += 1.4;\n\tbd = min(bd, max(max(hex(pp, vec2(.4, 1.2)), -pp.y), pp.z - .3));\n\tminH(Hit(bd, 1, p));\n\top = p - vec3(10, -7, 30);\n\torb = Hit(length(op) - 25., 0, op);\n\tg += .01 / (orb.d * orb.d * .1 + 1.);\n\tif (shield) minH(orb);\n\tpp = p - vec3(p.y + 74.875 + sin(p.y * 15.) * .05, n21(pp.xy * .5) * .2, -11.22);\n\td = n21(pp.xz * .2);\n\tminH(Hit(pp.y - 2. * pow(d, 10.) + 7.1, 4, vec3(pp.xz, d)));\n\top.xz *= rot(1.);\n\tp = op;\n\top.xz = abs(op.xz) - 8.;\n\tpp = op;\n\top.xz *= rot(op.y / 12.7348);\n\td = 4. - 2.8 * pow(sin(.5 * pow(op.y * .39, .65) + .2), 1.8);\n\td = min(max(box(op, vec3(d, 20, d)) - .1, box(pp, vec3(3.25, 20, 3.25))), box(p, vec3(12, .3, 12)) - .2);\n\tminH(Hit(d, 5, op));\n\td = cyl(p.yxz, vec2(.7 - p.y * 0.12, 4.0)) - .5;\n\tminH(Hit(d, 2, op));\n\tp.y -= 5.;\n\torb = Hit(length(p) - .7 + n31(p * 3. + t) * .4, 0, op);\n\tg += .01 / (orb.d * orb.d * .1 + 1.);\n\tminH(orb);\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h, false).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld) {\n\tfloat i, h,\n\t      s = 1.,\n\t      t = .1;\n\tfor (i = Z0; i < 20.; i++) {\n\t\th = map(t * ld + p, false).d;\n\t\ts = min(s, 30. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > 20.) break;\n\t}\n\n\treturn sat(s);\n}\n\nvec3 vig(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tif (h.id == 3) return vec3(1);\n\tvec3 n, c,\n\t     ld = normalize(vec3(2, 20, 15) - p);\n\tif (h.id == 0) {\n\t\tn = normalize(h.uv);\n\t\tfloat ns,\n\t\t      f = sat(.2 + .8 * dot(ld * vec3(-1, 1, 1), n));\n\t\tvec2 k = (n.xy * rot(t * .1) - vec2(.3, .1)) * rot(t * -.3) + vec2(.1, .2);\n\t\tfor (float i = 0.; i < 2.; i++) {\n\t\t\tfloat l = length(k + i * .1);\n\t\t\tf += (.4 + .2 * sin(l * 60. - t * 2.)) * (.003 + S(.5, 0., l) * S(0., .5, l));\n\t\t\tt += 32.;\n\t\t}\n\n\t\tns = n31(n * 19. + vec3(0, 0, t * 2.)) * .7 + n31(n * 39. + vec3(0, t * 2., 0)) * .3;\n\t\tf *= .5 + .5 * S(.2, .8, ns);\n\t\treturn vec3(1, 1.1, 1.7) * f;\n\t}\n\n\tn = N(p, d);\n\tif (h.id == 1) c = vec3(.2);\n\telse if (h.id == 2) c = vec3(.01);\n\telse if (h.id == 4) {\n\t\tc = vec3(.55);\n\t\tn.xz += 4. * (h.uv.z * .5 + n21(p.xz) * .125 - .5 + (n21(p.xz * 2.) + n21(p.zx * 32.1)) * .05);\n\t\tn = normalize(n);\n\t}\n\telse if (h.id == 5) c = mix(vec3(-.05), vec3(2. * pow(sat(sin(t + p.y * .2)), 10.), 0, 0), step(.8, fract(p.y)) * step(-7., p.y));\n\n\tfloat gg = g,\n\t      l1 = sat(.1 + .9 * dot(ld, n)) * (.2 + .8 * shadow(p, ld)),\n\t      l2 = sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .3 + pow(sat(dot(rd, reflect(ld, n))), 10.),\n\t      fre = 1. - S(.7, 1., 1. + dot(rd, n)) * .5;\n\tg = gg;\n\treturn (l1 + l2) * fre * c * vec3(.4, .32, .3);\n}\n\nvec3 sky(vec3 rd) {\n\tfloat f = pow(1. - sat(rd.y / .5), 3.);\n\treturn vec3(.16, .18, .24) * f + vec3((1. - f) * S(-.2, -.7, rd.x) * step(.96, n31(rd * 2e2)) * .5 * (.01 + .99 * n31(rd * 40. - t * .5)));\n}\n\nvec3 march(inout vec3 p, vec3 rd) {\n\tfloat i,\n\t      d = .01;\n\tbool addOrb = true;\n\tHit h, orb;\n\tvec3 orbP, c;\n\tg = 0.;\n\tfor (i = Z0; i < 128.; i++) {\n\t\th = map(p, addOrb);\n\t\tif (abs(h.d) < .0015) {\n\t\t\tif (h.id == 0) {\n\t\t\t\torb = h;\n\t\t\t\torbP = p;\n\t\t\t\taddOrb = false;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\n\t\td += h.d;\n\t\tif (d > 64.) break;\n\t\tp += h.d * rd;\n\t}\n\n\tc = (d < 64. ? lights(p, rd, d, h) : sky(rd)) + g;\n\tif (!addOrb) c += lights(orbP, rd, d, orb);\n\treturn c;\n}\n\n#define R\tiResolution\n\nvec3 render(vec3 ro, vec3 rd) {\n\tt = mod(iTime, 30.);\n\treturn pow(max(vec3(0), march(ro, rd)), vec3(.45)) * sat(iTime);\n}\n\nvoid mainVR(out vec4 fragColor, vec2 fc, vec3 ro, vec3 rd) {\n\trd.xz *= rot(-1.57);\n\tfragColor = vec4(render(vec3(-2, -4, -5), rd), 0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\tif (abs(uv.y) > .4) {\n\t\tfragColor = vec4(0);\n\t\treturn;\n\t}\n\n\tt = mod(iTime, 30.);\n\tfloat p = S(1., 15., t);\n\tvec3 lookAt = vec3(3, -3, 0) * p,\n\t     ro = mix(vec3(0, 0, -5), vec3(6, -5, -11), p);\n\tfragColor = vec4(vig(render(ro, rayDir(ro, lookAt, uv)), fc), 0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}