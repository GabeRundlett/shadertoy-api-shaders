{
    "Shader": {
        "info": {
            "date": "1490479496",
            "description": "Volumetric 32x32x32 Stanford Bunny with volumetric lighting, shadow and noise.\nThe shader does not compile on some platform for some reason. Set \"VOLUME_FILTERING_NEAREST 1\" can fix that issue (Thanks Fabrice for the investigation).",
            "flags": 0,
            "hasliked": 0,
            "id": "MdlyDs",
            "likes": 163,
            "name": "Volumetric Stanford Bunny",
            "published": 3,
            "tags": [
                "voxel",
                "volumetricscattering",
                "stanfordbunny"
            ],
            "usePreview": 1,
            "username": "SebH",
            "viewed": 12487
        },
        "renderpass": [
            {
                "code": "// By SebH \n// https://twitter.com/SebHillaire\n// Use mouse left to rotate camera (X axis) and change noise strength (Y axis)\n//\n// Warning: \n// Does not compile on all platforms/driver due to the packedBunny array which is\n// a ugly hacky way to get volume asset texture in shader toy. \n// A right way to do that would be to have loadable textures from weblinks.\n// Set \"VOLUME_FILTERING_NEAREST 1\" can fix that issue.\n//\n\n\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n#define uint2 uvec2\n#define uint3 uvec3\n#define uint4 uvec4\n\n////////// Parameters\n\n// Participating media properties. have fun tweaking those :)\nfloat3 scattering = 25.0*float3(0.25,0.5,1.0);\nfloat3 absorption = 0.0 * float3(0.75,0.5,0.0);\n\n// Default noise erosion strength\nfloat erosionStrength = 1.0;\n\n////////// Options\n\n#define VOLUME_FILTERING_NEAREST 0\n\n#define FBM_NOISE 1\n\n#define BASIC_ANIMATED_NOISE 1\n\n//0, 1 or 2\n#define BASIC_ANIMATED_MEDIA 0\n\n\n\n//////////////////////////////////////////////////\n// Bunny volume data\n//////////////////////////////////////////////////\n\n// Packed 32^3 bunny data as 32x32 uint where each bit represents density per voxel\n#define BUNNY_VOLUME_SIZE 32\nconst uint packedBunny[1024] = uint[1024](0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,917504u,917504u,917504u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1966080u,12531712u,16742400u,16742400u,16723968u,16711680u,8323072u,4128768u,2031616u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,6144u,2063360u,16776704u,33553920u,33553920u,33553920u,33553920u,33520640u,16711680u,8323072u,8323072u,2031616u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,268435456u,402653184u,134217728u,201326592u,67108864u,0u,0u,7168u,2031104u,16776960u,33554176u,33554176u,33554304u,33554176u,33554176u,33554176u,33553920u,16744448u,8323072u,4128768u,1572864u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,805306368u,939524096u,402653184u,478150656u,260046848u,260046848u,260046848u,125832192u,130055680u,67108608u,33554304u,33554304u,33554304u,33554304u,33554304u,33554304u,33554304u,33554176u,16776704u,8355840u,4128768u,917504u,0u,0u,0u,0u,0u,0u,0u,0u,0u,805306368u,1056964608u,1056964608u,528482304u,528482304u,260046848u,260046848u,260046848u,130039296u,130154240u,67108739u,67108807u,33554375u,33554375u,33554370u,33554368u,33554368u,33554304u,33554304u,16776960u,8330240u,4128768u,393216u,0u,0u,0u,0u,0u,0u,0u,0u,939524096u,1040187392u,1040187392u,520093696u,251658240u,251658240u,260046848u,125829120u,125829120u,130088704u,63045504u,33554375u,33554375u,33554375u,33554407u,33554407u,33554370u,33554370u,33554374u,33554310u,16776966u,4144642u,917504u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,15360u,130816u,262017u,4194247u,33554383u,67108847u,33554415u,33554407u,33554407u,33554375u,33554375u,33554318u,2031502u,32262u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,31744u,130816u,262019u,2097151u,134217727u,134217727u,67108863u,33554415u,33554407u,33554415u,33554383u,2097102u,982926u,32262u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,31744u,130816u,524263u,117964799u,127926271u,134217727u,67108863u,16777215u,4194303u,4194303u,2097151u,1048574u,65422u,16134u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3u,31751u,130951u,524287u,252182527u,261095423u,261095423u,59768830u,2097150u,1048574u,1048575u,262143u,131070u,65534u,16134u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,7u,31751u,130959u,503840767u,520617982u,529530879u,261095423u,1048575u,1048574u,1048574u,524286u,524287u,131070u,65534u,16134u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3u,1799u,32527u,134348750u,1040449534u,1057488894u,520617982u,51380223u,1048575u,1048575u,524287u,524287u,524287u,131070u,65534u,15886u,6u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1536u,3968u,8175u,65535u,1006764030u,1040449534u,1057488894u,50855934u,524286u,524286u,524287u,524287u,524286u,262142u,131070u,65534u,32270u,14u,6u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3968u,8160u,8191u,805371903u,2080505854u,2114191358u,101187582u,34078718u,524286u,524286u,524286u,524286u,524286u,524286u,262142u,131070u,32766u,8078u,3590u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8128u,8176u,16383u,2013331455u,2080505854u,235143166u,101187582u,524286u,1048574u,1048574u,1048574u,1048574u,524286u,524286u,262142u,131070u,32766u,16382u,8070u,1024u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8160u,8184u,1879064574u,2013331455u,470024190u,67371006u,524286u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,524286u,262142u,65534u,16382u,8160u,1024u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8128u,8184u,805322750u,402718719u,134479870u,524286u,524286u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,65534u,16382u,16368u,1792u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3968u,8184u,16382u,131071u,262142u,524286u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,65534u,16382u,16368u,1792u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1792u,8184u,16380u,65535u,262143u,524286u,524286u,1048574u,1048574u,1048575u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,65534u,16376u,16368u,1792u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8176u,16376u,32767u,262143u,524286u,1048574u,1048574u,1048575u,1048575u,1048575u,1048575u,1048574u,1048574u,524286u,262142u,32766u,16376u,8176u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4032u,8184u,32766u,262142u,524286u,524286u,1048575u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,32766u,16376u,8176u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,384u,8184u,32766u,131070u,262142u,524286u,1048575u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,524286u,131070u,32766u,16368u,1920u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4080u,32764u,65534u,262142u,524286u,524286u,524286u,1048574u,1048574u,524286u,524286u,524286u,262142u,131070u,32764u,8160u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,256u,16376u,32760u,131068u,262140u,262142u,524286u,524286u,524286u,524286u,524286u,262142u,131070u,65532u,16368u,3840u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3968u,32752u,65528u,131068u,262142u,262142u,262142u,262142u,262142u,262142u,262140u,131064u,32752u,7936u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8064u,32736u,65528u,131070u,131070u,131070u,131070u,131070u,131070u,65532u,32752u,8160u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3456u,16376u,32764u,65534u,65534u,65534u,32766u,32764u,16380u,4048u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,48u,2680u,8188u,8188u,8188u,8188u,4092u,120u,16u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,120u,248u,508u,508u,508u,248u,240u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,96u,240u,504u,504u,504u,240u,96u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,224u,224u,224u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u);\n\n\nfloat sampleBunny(float3 uvs)\n{\n    float3 voxelUvs = max(float3(0.0),min(uvs*float3(BUNNY_VOLUME_SIZE), float3(BUNNY_VOLUME_SIZE)-1.0));\n    uint3 intCoord = uint3(voxelUvs);\n    uint arrayCoord = intCoord.x + intCoord.z*uint(BUNNY_VOLUME_SIZE);\n\t\n    // Very simple clamp to edge. It would be better to do it for each texture sample\n    // before the filtering but that would be more expenssive...\n    // Also adding small offset to catch cube intersection floating point error\n    if(uvs.x<-0.001 || uvs.y<-0.001 || uvs.z<-0.001 ||\n      uvs.x>1.001 || uvs.y>1.001 || uvs.z>1.001)\n    \treturn 0.0;\n   \n    // 1 to use nearest instead\n#if VOLUME_FILTERING_NEAREST\n    // sample the uint representing a packed volume data of 32 voxel (1 or 0)\n    uint bunnyDepthData = packedBunny[arrayCoord];\n    float voxel = (bunnyDepthData & (1u<<intCoord.y)) > 0u ? 1.0 : 0.0;\n#else\n    uint3 intCoord2 = min(intCoord+uint3(1), uint3(BUNNY_VOLUME_SIZE-1));\n    \n    uint arrayCoord00 = intCoord.x  + intCoord.z *uint(BUNNY_VOLUME_SIZE);\n    uint arrayCoord01 = intCoord.x  + intCoord2.z*uint(BUNNY_VOLUME_SIZE);\n    uint arrayCoord10 = intCoord2.x + intCoord.z *uint(BUNNY_VOLUME_SIZE);\n    uint arrayCoord11 = intCoord2.x + intCoord2.z*uint(BUNNY_VOLUME_SIZE);\n    \n    uint bunnyDepthData00 = packedBunny[arrayCoord00];\n    uint bunnyDepthData01 = packedBunny[arrayCoord01];\n    uint bunnyDepthData10 = packedBunny[arrayCoord10];\n    uint bunnyDepthData11 = packedBunny[arrayCoord11];\n        \n    float voxel000 = (bunnyDepthData00 & (1u<<intCoord.y)) > 0u ? 1.0 : 0.0;\n    float voxel001 = (bunnyDepthData01 & (1u<<intCoord.y)) > 0u ? 1.0 : 0.0;\n    float voxel010 = (bunnyDepthData10 & (1u<<intCoord.y)) > 0u ? 1.0 : 0.0;\n    float voxel011 = (bunnyDepthData11 & (1u<<intCoord.y)) > 0u ? 1.0 : 0.0;\n    float voxel100 = (bunnyDepthData00 & (1u<<intCoord2.y)) > 0u ? 1.0 : 0.0;\n    float voxel101 = (bunnyDepthData01 & (1u<<intCoord2.y)) > 0u ? 1.0 : 0.0;\n    float voxel110 = (bunnyDepthData10 & (1u<<intCoord2.y)) > 0u ? 1.0 : 0.0;\n    float voxel111 = (bunnyDepthData11 & (1u<<intCoord2.y)) > 0u ? 1.0 : 0.0;\n    \n    float3 d = voxelUvs - float3(intCoord);\n    \n    voxel000 = mix(voxel000,voxel100, d.y);\n    voxel001 = mix(voxel001,voxel101, d.y);\n    voxel010 = mix(voxel010,voxel110, d.y);\n    voxel011 = mix(voxel011,voxel111, d.y);\n    \n    voxel000 = mix(voxel000,voxel010, d.x);\n    voxel001 = mix(voxel001,voxel011, d.x);\n    \n    float voxel = mix(voxel000,voxel001, d.z);\n#endif\n    \n    return voxel;\n}\n\n//////////////////////////////////////////////////\n// Volume noise from somewhere...\n//////////////////////////////////////////////////\n\nfloat rand(vec3 co)\n{\n    return -1.0 + fract(sin(dot(co.xy,vec2(12.9898 + co.z,78.233))) * 43758.5453) * 2.0;\n}\n\nfloat linearRand(vec3 uv)\n{\n\tvec3 iuv = floor(uv);\n\tvec3 fuv = fract(uv);\n\t\n\tfloat v1 = rand(iuv + vec3(0,0,0));\n\tfloat v2 = rand(iuv + vec3(1,0,0));\n\tfloat v3 = rand(iuv + vec3(0,1,0));\n\tfloat v4 = rand(iuv + vec3(1,1,0));\n\t\n\tfloat d1 = rand(iuv + vec3(0,0,1));\n\tfloat d2 = rand(iuv + vec3(1,0,1));\n\tfloat d3 = rand(iuv + vec3(0,1,1));\n\tfloat d4 = rand(iuv + vec3(1,1,1));\n\t\n\treturn mix(mix(mix(v1,v2,fuv.x),mix(v3,v4,fuv.x),fuv.y),\n\t\t       mix(mix(d1,d2,fuv.x),mix(d3,d4,fuv.x),fuv.y),\n\t\t\t   fuv.z);\n}\n\nfloat linearRandFBM(vec3 uv)\n{\n\tfloat c = (linearRand(uv * 1.0) * 32.0 +\n\t\t\t   linearRand(uv * 2.0) * 16.0 + \n\t\t\t   linearRand(uv * 4.0) * 8.0 + \n\t\t\t   linearRand(uv * 8.0) * 4.0) / 32.0;\n\treturn c * 0.5 + 0.5;\n}\n\n\n//////////////////////////////////////////////////\n// Cube intersection\n//////////////////////////////////////////////////\n\nfloat3 worldPosTocubePos(float3 worldPos)\n{\n    // cube of world space size 4 with bottom face on the ground y=0\n    return worldPos*0.15 + float3(0.0,-0.5,0.0);\n}\n\n// From https://www.shadertoy.com/view/4s23DR\nbool cube(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = 1.0/dir;\n\tvec3 tbot = invR * (-0.5 - org);\n\tvec3 ttop = invR * (0.5 - org);\n\t\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max(tmin.xx, tmin.yz);\n\tnear = max(t0.x, t0.y);\n\tt0 = min(tmax.xx, tmax.yz);\n\tfar = min(t0.x, t0.y);\n\n\t// check for hit\n\treturn near < far && far > 0.0;\n}\n\n\n//////////////////////////////////////////////////\n// Main\n//////////////////////////////////////////////////\n\nfloat3 L = 4.0 * float3(1.0,1.0,1.0);// incoming luminance from light (ignoring its shape, etc.)\nfloat3 Lpos = float3(1.0,1.0,1.0);\t// in volumetric cube space\n\n#define extinction  (absorption + scattering)\n\n// all volumetric computation are done once position has been transform into unit cube space\n\n// Get density for a position\nfloat getDensity(float3 cubePos)\n{\n    float density = sampleBunny(cubePos);\n    if(density==0.0) return 0.0;\t// makes things a tad bit faster\n#if FBM_NOISE\n    float3 noiseUV = cubePos*12.0;\n\t#if BASIC_ANIMATED_NOISE\n    noiseUV += iTime * float3(1.0,0.0,0.0);\n\t#endif\n    density = density * max(0.0, 1.25*erosionStrength*linearRandFBM(noiseUV)*4.0-2.0); // more complex FBM noise\n#else\n    float3 noiseUV = cubePos*16.0;\n\t#if BASIC_ANIMATED_NOISE\n    noiseUV += iTime * float3(1.0,0.0,0.0);\n\t#endif\n    density = density * max(0.0, 0.5 + 0.5*erosionStrength*linearRand(noiseUV));\n#endif\n    return density;\n}\n\n// Get transmittance from a direction and distance onto a point (volume shadows)\nfloat3 getShadowTransmittance(float3 cubePos, float sampledDistance, float stepSizeShadow)\n{\n    float3 shadow = float3(1.0);\n    float3 Ldir = normalize(Lpos-cubePos);\n    for(float tshadow=0.0; tshadow<sampledDistance; tshadow+=stepSizeShadow)\n    {\n        float3 cubeShadowPos = cubePos + tshadow*Ldir;\n        float densityShadow = getDensity(cubeShadowPos);\n        shadow *= exp(-densityShadow * extinction * stepSizeShadow);\n    }\n    return shadow;\n}\n\n// Returns the light distance attenuation\nfloat distanceAttenuation(float distance)\n{\n    float lightMaxRadius = 3.0;\n    float linAtt = clamp((lightMaxRadius-distance)/lightMaxRadius,0.0,1.0);\n    linAtt*=linAtt;\t// some \"fake artistic\" attenuation\n    return linAtt/(distance*distance);\n}\n\nvoid mainImage( out float4 fragColor, in float2 fragCoord )\n{    \n\tfloat2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = float4(uv,0.5+0.5*sin(iTime),1.0);\n    float time = iTime;\n    \n\tvec2 mouseControl = iMouse.xy / iResolution.xy;\n    erosionStrength = iMouse.z>0.0 ? mouseControl.y * 4.0 : erosionStrength;\n    \n#if BASIC_ANIMATED_MEDIA==1\n    float r = floor(time);\n    scattering = abs(25.0* float3(rand(float3(r,0.0,1.0)),rand(float3(r,0.0,5.0)),rand(float3(r,0.0,9.0))));\n    absorption = abs(5.0* float3(rand(float3(r,1.0,2.0)),rand(float3(r,1.0,7.0)),rand(float3(r,1.0,7.0))));\n#elif BASIC_ANIMATED_MEDIA==2\n    float r = time*0.2;\n    scattering = abs(25.0* float3(sin(r*1.1),sin(r*3.3),sin(r*5.5)));\n    absorption = abs( 5.0* float3(sin(r*2.2),sin(r*4.4),sin(r*6.6)));\n\n#endif\n    \n    // View diretion in camera space\n    float3 viewDir = normalize(float3((fragCoord.xy - iResolution.xy*0.5) / iResolution.y, 1.0));\n    viewDir*= float3(0.9,1.0,1.0);\n    \n    Lpos = float3(0.85*cos(time*0.55),1.5, 0.85*sin(time*1.0));\n    \n    // Compute camera properties\n    float  camDist = 10.0;\n    float3 camUp = float3(0,1,0);\n    float3 camPos = float3(camDist*cos(time*0.51),8.0, camDist*sin(time*0.51));\n    camPos = iMouse.z<=0.0 ? camPos : float3(camDist*cos(mouseControl.x*10.0),8.0, camDist*sin(mouseControl.x*10.0));\n    float3 camTarget = float3(0,3.0,0);\n    \n    // And from them evaluted ray direction in world space\n    float3 forward = normalize(camTarget - camPos);\n    float3 left = normalize(cross(forward, camUp));\n    float3 up = cross(left, forward);\n    float3 worldDir = viewDir.x*left + viewDir.y*up + viewDir.z*forward;\n    \n    //////////////////////////////////////////////////////////////////////////////////////////\n    //// Render the flat ground with lighting and volumetric shadows\n    float3 color= float3(0.0, 0.0, 0.0);\n    float3 groundIntersection = camPos + worldDir * abs(camPos.y/worldDir.y);\n    float2 groundUv = groundIntersection.xz*0.1;\n    float3 groundTex = texture(iChannel0, groundUv).xyz;\n    if(worldDir.y<0.0)\n    {\n        // ground position to cube space for lighting evaluation\n    \tfloat3 cubeSpacePos= worldPosTocubePos(groundIntersection)+0.5;\n        \n        float3 shadow = getShadowTransmittance(cubeSpacePos,2.0,0.05);\n\n       \tfloat3 Ldir = Lpos-cubeSpacePos;\n        float Ldist = length(Ldir);\n    \tfloat3 LdirNorm = Ldir / max(0.0001, Ldist);\n        float Lattenuation = distanceAttenuation(Ldist);\n        \n        float N00 = texture(iChannel0, groundUv + float2( 0.001, 0.001)).g;\n        float N01 = texture(iChannel0, groundUv + float2( 0.001,-0.001)).g;\n        float N10 = texture(iChannel0, groundUv + float2(-0.001, 0.001)).g;\n        float N11 = texture(iChannel0, groundUv + float2(-0.001,-0.001)).g;\n        float3 N = cross(normalize(float3(1.0,25.0*(N11-N00),1.0)),normalize(float3(1.0,25.0*(N10-N01),-1.0)));\n        \n        color = groundTex * shadow * Lattenuation * L * dot(N,LdirNorm);\n    }\n    \n    //////////////////////////////////////////////////////////////////////////////////////////\n    //// Compute intersection with cube containing the bunny\n    float near = 0.0;\n    float far  = 0.0;\n    float3 cubeSpacePos= worldPosTocubePos(camPos);\n\tif (cube(cubeSpacePos, worldDir, near, far))\n    {\n    \tfloat3 scatteredLuminance = float3(0.0,0.0,0.0);\n        float3 transmittance = float3(1.0);\n        \n        float stepSize = 0.01;\n        for(float t=near; t<far; t+=stepSize)\n        {\n            float3 cubePos = cubeSpacePos + t*worldDir + 0.5;\n            float density = getDensity(cubePos);\n            \n       \t\tfloat stepSizeShadow = 0.1;\n            float3 shadow = getShadowTransmittance(cubePos,1.0, 0.1);\n            \n            \n    \t\tfloat Ldist = length(Lpos-cubePos);\n            float Lattenuation = distanceAttenuation(Ldist);\n\n#if 0\n            // Scattered luminance ignores phase function (assumes L has it baked in)\n            // This is not energy conservative.\n            scatteredLuminance += Lattenuation * shadow * transmittance * density *scattering * stepSize * L;       \n            transmittance *= exp(-density * extinction * stepSize);\n#else\n            // Improved scattering integration. See slide 28 at http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/\n            vec3 S = L * Lattenuation * shadow * density *scattering;\n            vec3 sampleExtinction = max(vec3(0.0000000001), density * extinction);\n            vec3 Sint = (S - S * exp(-sampleExtinction * stepSize)) / sampleExtinction;\n            scatteredLuminance += transmittance * Sint;\n\n            // Evaluate transmittance to view independentely\n            transmittance *= exp(-sampleExtinction * stepSize);\n#endif\n        }\n        \n        // Apply volumetric on scene\n        color = transmittance*color + scatteredLuminance;\n    }\n    \n    \n    \n    fragColor = float4(pow(color, float3(1.0/2.2)),1.0); // simple linera to gamma\n    \n    \n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}