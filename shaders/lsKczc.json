{
    "Shader": {
        "info": {
            "date": "1528384387",
            "description": "I used this shadertoy to generate some of the diagrams for my Digital Dragons 2018 talk.\nspace for controls",
            "flags": 48,
            "hasliked": 0,
            "id": "lsKczc",
            "likes": 33,
            "name": "Spectral Power Distribution",
            "published": 3,
            "tags": [
                "spectrum",
                "prism"
            ],
            "usePreview": 0,
            "username": "P_Malin",
            "viewed": 1278
        },
        "renderpass": [
            {
                "code": "// Spectral Power Distribution\n// @P_Malin\n// https://www.shadertoy.com/view/lsKczc\n\n// I used this shadertoy to generate some of the diagrams for my Digital Dragons 2018 talk.\n// https://www.youtube.com/watch?v=EN1Uk6vJqRw\n// https://research.activision.com/t5/Publications/HDR-in-Call-of-Duty/ba-p/10744846\n\n#define SHOW_SPECTRUM  1\n#define SHOW_SPD_GRAPH 1\n\n// Set SPD below to positive value if compilation is crashing with these options.\n\n#define SHOW_RESPONSE_GRAPH 0\n#define RESPONSE_GRAPH_LMS 0\n#define RESPONSE_GRAPH_RGB 1\n\n#define SEPARATE_SPD_GRAPH 0\n#define SEPARATE_SPECTRUM 0\n#define SEPARATE_RESPONSE_GRAPH 0\n#define SHOW_WEIGHTED_RESPONSE 0\n\n// Set to 0, 1 or 2\n#define SHOW_LUMINOSITY_GRAPH 0\n#define SHOW_LUMINOSITY_BAR 0\n\n#define DRAW_PRISM     1\n#define SHOW_SPREAD    1\n#define SHOW_BEAM      1\n\nconst int \tSPD_UNITY = 0,\n    \t\tSPD_GAUSSIAN_A = 1,\n    \t\tSPD_GAUSSIAN_B = 2,\t\n    \t\tSPD_GAUSSIAN_ANIMATED = 3,\n    \t\tSPD_NOISE_A = 4,\n    \t\tSPD_NOISE_B = 5,\n    \t\tSPD_NOISE_C = 6,\n    \t\tSPD_BLACKBODY = 7,\n    \t\tSPD_RGB = 8;\n\nconst int SPD = -1;\n\n    \n//#define BLACKBODY_TEMP 1000.0\n//#define BLACKBODY_TEMP 2000.0\n//#define BLACKBODY_TEMP 6500.0\n#define BLACKBODY_TEMP 10000.0\n\n#define iChannelUI \t\t\tiChannel1\n\nfloat UI_GetFloat( int iData )\n{\n    return texelFetch( iChannelUI, ivec2(iData,0), 0 ).x;\n}\n\nbool UI_GetBool( int iData )\n{\n    return UI_GetFloat( iData ) > 0.5;\n}\n\nvec3 UI_GetColor( int iData )\n{\n    return texelFetch( iChannelUI, ivec2(iData,0), 0 ).rgb;\n}\n\nint GetSPD()\n{\n    if ( SPD < 0 )\n    {\n\t\treturn int( UI_GetFloat( DATA_FLOAT_SPD ) );\n    }\n    else\n    {\n        return SPD;\n    }\n}\n\nvec3 GetRGBFactor()\n{\n    //return vec3(1.0);\n    //return vec3(0.0583, 0.2416, 0.2000 );\n        float r = UI_GetFloat( DATA_FLOAT_A );\n        float g = UI_GetFloat( DATA_FLOAT_B );\n        float b = UI_GetFloat( DATA_FLOAT_C );\n        vec3 vRGBFactor = vec3(r,g,b);\n    return vRGBFactor;\n}\n\nconst float fGlobalXOffset = 0.3;\nconst float fSpHScale = 0.75;\nconst float fSpMinX = fGlobalXOffset + 0.5 - fSpHScale * 0.5;\nconst float fSpMaxX = fGlobalXOffset + 0.5 + fSpHScale * 0.5;\nconst float fSpMinY = 0.7;\nconst float fSpMaxY = 0.75;\n\nconst float fSpdMinY = 0.76;\nconst float fSpdMaxY = 0.99;\n\nconst float fGraphSpacing = 0.3;\n\nvec2 GetSpectrumUV( vec2 vUV, int index )\n{\n    vec2 vSpectrumUV = vUV;\n    float fMinY = fSpMinY - float(index) * fGraphSpacing;\n    float fMaxY = fSpMaxY - float(index) * fGraphSpacing;\n    \n    vSpectrumUV.x = (vSpectrumUV.x - fSpMinX) / (fSpMaxX - fSpMinX);\n    vSpectrumUV.y = (vSpectrumUV.y - fMinY) / (fMaxY - fMinY);\n    \n    return vSpectrumUV;\n}\n\nvec2 GetGraphUV( vec2 vUV, int index )\n{\n    vec2 vGraphUV = vUV;\n    float fMinY = fSpdMinY - float(index) * fGraphSpacing;\n    float fMaxY = fSpdMaxY - float(index) * fGraphSpacing;   \n    \n    vGraphUV.x = (vGraphUV.x - fSpMinX) / (fSpMaxX - fSpMinX);\n    vGraphUV.y = (vGraphUV.y - fMinY) / (fMaxY - fMinY);\n    \n    return vGraphUV;\n}\n\n\nfloat BlackBody( float w_nm, float t )\n{\n    float h = 6.6e-34; // Planck constant\n    float k = 1.4e-23; // Boltzmann constant\n    float c = 3e8;// Speed of light\n\n    float w = w_nm / 1e9;\n\n    // Planck's law https://en.wikipedia.org/wiki/Planck%27s_law\n    \n    float w5 = w*w*w*w*w;\n    float o = 2.*h*(c*c) / (w5 * (exp(h*c/(w*k*t)) - 1.0));\n\n    return o;\n}\n\nfloat SPD_BlackBody( float w, float t )\n{\n    return BlackBody( w, t ) / BlackBody( 600.0, t );\n}\n\n\nfloat SPD_Sin( float w )\n{\n    return sin( w * 0.06 + iTime * 2.0) * 0.5 + 0.5;\n}\n\nfloat SPD_Noise( float w )\n{\n    //float fOffset = 0.0;\n    //float fOffset = iTime;\n    //float fOffset = 10.0;\n    //float fOffset = 784.0;\n    //float fOffset = 15825.0;\n        \n    //float fOffset = iMouse.x;\n    \n    //w += fOffset;\n    \n    float n = FBM( (w) * 0.02, 0.5 );\n    return n * n;\n}\n\nfloat Gaussian( float x, float u, float sd )\n{\n    float v = sd * sd;\n        \n    float d = x - u;\n    \n    float fScale = 1.0 / sqrt( TAU * v );\n    return fScale * exp( - ( d * d ) / 2.0 * v );    \n}\n\nfloat UnitGaussian( float x, float u, float sd )\n{\n    float v = sd * sd;\n        \n    float d = x - u;\n    \n    //float fScale = 1.0 / sqrt( TAU * v );\n    float fScale = 1.0;\n    return fScale * exp( - ( d * d ) / 2.0 * v );    \n}\n\nfloat SPD_Gaussian( float w )\n{\n    //float u = 780.0;//380.0;\n    \n    float u = 500.0 + sin(iTime) * 200.0;        \n    float sd = 0.04;  \n    \n    return UnitGaussian( w, u, sd );\n    \n    //return clamp( 1.0 - abs(d) * 0.02, 0.0, 1.0 );    \n    //return smoothstep( 0.0, 1.0, 1.0 - abs(d) * 0.02 );\n    \n}\n\nfloat GetSPD( float w )\n{\n    float result = 1.0;\n    switch( GetSPD() )\n    {\n        default:\n        case SPD_UNITY:\n        {\n            result = 1.0;    \n        }\n        break;\n\n    //return WavelengthToXYZLinear( w ).x;\n    //return WavelengthToConeLinear( w ).x;\n    //return SPD_Gaussian( w );\n    \n    //return WavelengthToLuminosityLinear( w );\n    \n\t\tcase SPD_GAUSSIAN_A:\n        {\n\t\t    result = UnitGaussian( w, 600.0, 0.02 ) * sqrt(SPD_Noise( w + 123. ));\n    \t}\n        break;\n\n        case SPD_GAUSSIAN_B:\n        {\n            result = UnitGaussian( w, 500.0, 0.02 ) * sqrt(SPD_Noise( w + 234. ));            \n        }\n        break;\n\n\t\tcase SPD_GAUSSIAN_ANIMATED:\n        {\n            result = UnitGaussian( w, 500.0 + sin(iTime) * 200.0, 0.02 ) * sqrt(SPD_Noise( w ));            \n        }\n        break;\n\n    //return SPD_Sin( w );\n    \n    //return SPD_Noise( w + 784.0 ) * WavelengthToXYZLinear(w).z;\n\n    //return dot( WavelengthToXYZLinear( w ), vec3(0.01, 0.3, 0.2));\n    \n        case SPD_NOISE_A:\n        {    \n            result = SPD_Noise( w + 784.0 );    \n        }\n        break;\n\n        case SPD_NOISE_B:\n        {    \n            result = SPD_Noise( w + 15825.0 );\n        }\n        break;\n    \n        case SPD_NOISE_C:\n        {    \n            result = SPD_Noise( w + 43.0 );\n        }\n        break;\n    \n        case SPD_BLACKBODY:\n        {    \n            float t = BLACKBODY_TEMP;\n            result = SPD_BlackBody( w, t ) * 0.4;\n        }\n        break;\n    \n        case SPD_RGB:\n        {    \n            bool show = UI_GetBool( DATA_CHECKBOX_A );\n\n            if ( show )\n            {    \n                vec3 vRGBFactor = GetRGBFactor();\n                result = dot( WavelengthToRGBLinear(w), vRGBFactor );\n            }\n            else\n            {\n                result = SPD_Noise( w + 784.0 );  \n            }\n        }    \n        break;\n    }\n\n    return result;\n}\n\n\nconst int \n    GRAPH_SPD = 0,\n    GRAPH_CONE_L = 1,\n    GRAPH_CONE_M = 2,\n    GRAPH_CONE_S = 3,\n    GRAPH_LUMINOSITY = 4,\n    GRAPH_R = 5,\n    GRAPH_G = 6, \n    GRAPH_B = 7;\n\nconst int \n    GRAPH_SCALE_UNITY = 0,\n    GRAPH_SCALE_L = 1,\n    GRAPH_SCALE_M = 2,\n    GRAPH_SCALE_S = 3,\n    GRAPH_SCALE_R = 4,\n    GRAPH_SCALE_G = 5,\n    GRAPH_SCALE_B = 6;\n\nconst int GRAPH_Y_NORMAL = 0,\n    GRAPH_Y_RGB = 1;\n\nfloat GraphFunction( float x, int function, int scale, int graphY )\n{\n    float w = mix(standardObserver1931_w_min, standardObserver1931_w_max, x);\n\n    float fScale = 1.0;\n    \n    switch ( scale )\n    {\n        case GRAPH_SCALE_UNITY:\n        break;\n        case GRAPH_SCALE_L:\n\t\t    fScale = WavelengthToConeLinear( w ).x;\n        break;\n        case GRAPH_SCALE_M:\n\t\t    fScale = WavelengthToConeLinear( w ).y;\n        break;\n        case GRAPH_SCALE_S:\n\t\t    fScale = WavelengthToConeLinear( w ).z;\n        break;\n        \n        case GRAPH_SCALE_R:\n\t\t    fScale = WavelengthToRGBLinear( w ).x;\n        break;\n        case GRAPH_SCALE_G:\n\t\t    fScale = WavelengthToRGBLinear( w ).y;\n        break;\n        case GRAPH_SCALE_B:\n\t\t    fScale = WavelengthToRGBLinear( w ).z;\n        break;        \n    }\n    \n    float fValue = 0.0;\n    \n    if ( function == GRAPH_SPD )\n    {\n    \tfValue = GetSPD( w );\n    }\n    \n    if ( function == GRAPH_CONE_L )\n    {\n\t\tfValue = WavelengthToConeLinear( w ).x;\n    }\n    if ( function == GRAPH_CONE_M )\n    {\n\t\tfValue = WavelengthToConeLinear( w ).y;\n    }\n    if ( function == GRAPH_CONE_S )\n    {\n\t\tfValue = WavelengthToConeLinear( w ).z;   \n    }\n    if ( function == GRAPH_LUMINOSITY )\n    {\n\t\tfValue = WavelengthToLuminosityLinear( w );\n    }\n    \n    if ( function == GRAPH_R )\n    {\n\t\tfValue = WavelengthToRGBLinear( w ).x; \n        fValue *= GetRGBFactor().r;\n    }\n    if ( function == GRAPH_G )\n    {\n\t\tfValue = WavelengthToRGBLinear( w ).y;\n        fValue *= GetRGBFactor().g;\n    }\n    if ( function == GRAPH_B )\n    {\n\t\tfValue = WavelengthToRGBLinear( w ).z;\n        fValue *= GetRGBFactor().b;\n    }    \n    \n    fValue *= fScale;\n    \n    if ( graphY == GRAPH_Y_RGB )\n    {\n        fValue = fValue * 0.4 + 0.2;\n    }\n    \n    return fValue;\n}\n\nfloat GraphDyDx( float x, int function, int scale, int graphY )\n{\n    //float w = mix(standardObserver1931_w_min, standardObserver1931_w_max, x);    \n    //return cos( w * 0.06 + iTime * 2.0);\n    \n    float fDx = 0.01;\n    float fMagicNumber = 10.0;\n    return (GraphFunction( x + fDx, function, scale, graphY ) - GraphFunction( x -fDx, function, scale, graphY )) / (fMagicNumber * fDx);\n}\n\n\nfloat GraphInfo( DrawContext drawContext, int function, int scale, int graphY )\n{\n    vec2 vPos = drawContext.vUV;\n    vPos.y = vPos.y * 1.1 - 0.05;\n\n    float x = vPos.x;\n    \n    float fDyDx = GraphDyDx( x, function, scale, graphY );\n    float fDistScale = 1.0;\n    fDistScale = sqrt( 1.0 + fDyDx * fDyDx );\n    return (vPos.y - GraphFunction( x, function, scale, graphY )) / fDistScale;\n}\n\n// Inverse bilinear by iq - from https://www.shadertoy.com/view/lsBSDm\n\n// Inverse bilinear interpolation: given four points defining a quadrilateral, compute the uv\n// coordinates of any point in the plane that would give result to that point as a bilinear \n// interpolation of the four points.\n//\n// The problem can be solved through a quadratic equation. More information in this article:\n//\n// https://iquilezles.org/articles/ibilinear\n\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n// given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    // if edges are parallel, this is a linear equation. Do not this test here though, do\n    // it in the user code\n    //if( abs(k2)<0.001 )\n    //{\n\t//\t  float v = -k0/k1;\n\t//    float u  = (h.x*k1+f.x*k0) / (e.x*k1-g.x*k0);\n    //    \n    //    if( v>0.0 && v<1.0 && u>0.0 && u<1.0 )  res = vec2( u, v );\n    //}\n\t//else\n    {\n        // otherwise, it's a quadratic\n        float w = k1*k1 - 4.0*k0*k2;\n        if( w<0.0 ) return vec2(-1.0);\n        w = sqrt( w );\n\n        #if 1\n            float ik2 = 0.5/k2;\n            float v = (-k1 - w)*ik2; if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;\n            float u = (h.x - f.x*v)/(e.x + g.x*v);\n            if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);\n            res = vec2( u, v );\n\t\t#else\n            float v1 = (-k1 - w)/(2.0*k2);\n            float v2 = (-k1 + w)/(2.0*k2);\n            float u1 = (h.x - f.x*v1)/(e.x + g.x*v1);\n            float u2 = (h.x - f.x*v2)/(e.x + g.x*v2);\n            bool  b1 = v1>0.0 && v1<1.0 && u1>0.0 && u1<1.0;\n            bool  b2 = v2>0.0 && v2<1.0 && u2>0.0 && u2<1.0;\n\n            if(  b1 && !b2 ) res = vec2( u1, v1 );\n            if( !b1 &&  b2 ) res = vec2( u2, v2 );\n\t\t#endif\n    }\n    \n    return res;\n}\n\nfloat GetGlare( float fDist )\n{\n    float fGlare = 0.0;\n    fDist = 1.0f - fDist;\n    if ( fDist < 0.0 )\n        return 0.0;\n    fGlare += pow(fDist, 20.0);\n    fGlare += pow(fDist, 4.0) * 0.1;\n    fGlare += pow(fDist, 100.0) * 5.0;    \n    \n    return fGlare;\n}\n\nfloat GetSpectrumGlare( float fDist )\n{\n    float fGlare = 0.0;\n    fDist = 1.0f - fDist;\n    if ( fDist < 0.0 )\n        return 0.0;\n    \n    fGlare += pow( fDist, 30.0);\n    fGlare += pow( fDist, 10.0) * 0.1;\n    //return UnitGaussian( fDist, 0.0, 20.0 );\n    \n    return fGlare * 0.005;\n}\n\n\n\nfloat GetPrismGlare( float fDist )\n{\n    float fGlare = 0.0;\n    fDist = 1.0f - fDist;\n    if ( fDist < 0.0 )\n        return 0.0;\n    \n    fGlare += pow( fDist, 100.0);\n    fGlare += pow( fDist, 30.0) * 0.1;\n    //return UnitGaussian( fDist, 0.0, 20.0 );\n    \n    return fGlare * 0.05;\n}\n\nconst vec2 vPrismPoint = vec2(fGlobalXOffset + 0.8, 0.2);\nconst vec2 vPrismN1 = normalize( vec2( 1, sqrt(3.0) ) );    \nconst vec2 vPrismN2 = normalize( -vec2( -1, sqrt(3.0) ) );    \nconst vec2 vPrismN3 = normalize( vec2( -1, 0 ) );    \nconst float fPrismD1 = -dot( vPrismN1, vPrismPoint );\nconst float fPrismD2 = -dot( vPrismN2, vPrismPoint );\nconst float fPrismD3 = vPrismPoint.x - 0.2;\n\n\nfloat GetPrismDist( vec2 vUV )\n{    \n    float fD1 = dot( vUV, vPrismN1 ) + fPrismD1;\n    float fD2 = dot( vUV, vPrismN2 ) + fPrismD2;\n    float fD3 = dot( vUV, vPrismN3 ) + fPrismD3;\n                       \n    return max(max( fD1, fD2 ), fD3);\n}\n\nfloat ProjectPlane( float x, vec2 n, float d )\n{\n    float yi = d / n.y;\n    \n    float y = x * -n.x / n.y - yi;\n    \n    return y;\n}\n\nfloat PrismShade( vec2 vUV )\n{\n    float d = GetPrismDist( vUV );\n    \n    float fEpsilon = 0.001;\n    float fDX = GetPrismDist( vUV + vec2( fEpsilon, 0 ) );\n    float fDY = GetPrismDist( vUV + vec2( 0, fEpsilon ) );\n    \n    vec2 vNorm = normalize( vec2( fDX - d, fDY -d ) / fEpsilon );\n    \n\tfloat fEdge = clamp( 1.0 - abs(d) * 200.0, 0.0, 1.0 );\n    \n    float fLight = dot( normalize( vec2(0.5, -0.4) ), vNorm );\n    \n    float fLightA = clamp( fLight * 0.5 + 0.5, 0.0, 1.0 );\n    float fLightB = pow( clamp( fLight, 0.0, 1.0 ), 100.0 ) * 2.0;\n    \n    float fShade = fEdge * (fLightA + fLightB + 0.5);\n        \n    if ( d < 0.0 )\n    {\n        fShade = max( fShade, 0.25 );   \n    }\n    \n    fShade = max( 0.0f, fShade );\n    \n\treturn fShade * 0.05;\n}\n\nvoid DrawSpectrum( inout DrawContext drawContext, vec3 vColBG )\n{   \n    vec2 vSpectrumUV = GetSpectrumUV( drawContext.vUV, 0 );\n    \n    float fGap = 0.01;\n\n    float fSpread0 = 0.01;\n    float x0 = vPrismPoint.x - 0.1 - fSpread0;\n    float x1 = vPrismPoint.x - 0.1 + fSpread0;\n    \n    vec2 v0 = vec2(x0, ProjectPlane( x0, vPrismN1, fPrismD1 ) );\n    vec2 v1 = vec2(x1, ProjectPlane( x1, vPrismN1, fPrismD1 ) );\n    vec2 v2 = vec2(fSpMaxX, fSpMinY - fGap);\n    vec2 v3 = vec2(fSpMinX, fSpMinY - fGap);\n    \n    vec2 vSpreadUV = invBilinear( drawContext.vUV, v0, v1, v2, v3 );    \n    bool inSpreadLight = InUnitSquare( vSpreadUV );\n\n    float fSpread1 = 0.005;\n    float x4 = vPrismPoint.x - 0.09 - fSpread1;\n    float x5 = vPrismPoint.x - 0.09 + fSpread1;\n    \n    vec2 v4 = vec2(x4, ProjectPlane( x4, vPrismN2, fPrismD2 ) );\n    vec2 v5 = vec2(x5, ProjectPlane( x5, vPrismN2, fPrismD2 ) );\n\n    vec2 vSpreadUV_B = invBilinear( drawContext.vUV, v0, v1, v5, v4 );    \n    bool inSpreadLightB = InUnitSquare( vSpreadUV_B );\n    \n\n    \n    if ( !inSpreadLight )\n    {\n        if ( inSpreadLightB )\n        {\n            inSpreadLight = true;\n            vSpreadUV = vSpreadUV_B;\n            vSpreadUV.y = 0.0;\n        }\n    }\n    \n#if !SHOW_SPREAD\n    inSpreadLight = false;\n#endif    \n    \n    // Hack convergence color\n    vSpreadUV.y = vSpreadUV.y * 0.96 + 0.04;\n    \n    vec2 vBeamA = (v4 + v5) * 0.5;\n    vec2 vBeamB = vec2(0.66 + fGlobalXOffset,0);\n    \n    float fBeamDist = LineInfo( drawContext.vUV, vBeamA, vBeamB );\n    float fBeam = clamp( abs(fBeamDist) * 200.0, 0.0, 1.0 );\n    fBeam = sqrt( 1.0 - fBeam * fBeam);\n    fBeam += GetGlare( abs( fBeamDist ) ) * 0.2;\n    \n    float fGlareDist = length( drawContext.vUV - vBeamA );\n    float fBeamGlare = GetGlare( fGlareDist );\n\n    \n#if !SHOW_BEAM    \n    fBeam = 0.0;\n    fBeamGlare = 0.0;\n#endif    \n\n    bool inSpectrum = InUnitSquare( vSpectrumUV );    \n\n#if SEPARATE_SPECTRUM    \n\tinSpectrum = inSpectrum || InUnitSquare( GetSpectrumUV( drawContext.vUV, 1 ) ) || InUnitSquare( GetSpectrumUV( drawContext.vUV, 2 ) );\n#endif\n    \n#if !SHOW_SPECTRUM\n    inSpectrum = false;\n#endif\n    \n    float fSpreadLightW0 = mix(standardObserver1931_w_min - 20.0, standardObserver1931_w_max + 20.0, vSpreadUV.x);\n    float fSpectrumW0 = mix(standardObserver1931_w_min - 20.0, standardObserver1931_w_max + 20.0, vSpectrumUV.x);\n    \n    \n    vec3 vLightColor = vec3(0);\n    \n    vec3 vTotXYZ = vec3(0);\n    for( float w = standardObserver1931_w_min; w < NO_UNROLLF(standardObserver1931_w_max); w += 5.0 )\n    {\n        vec3 vCurrXYZ = WavelengthToXYZLinear( w );\n\n        float fPower = GetSPD( w );\n        \n        if ( inSpreadLight )\n        {\n            float fWeight = UnitGaussian( w, fSpreadLightW0, 0.2 * vSpreadUV.y);\n        \tvTotXYZ += vCurrXYZ * fWeight * fPower * 0.01;\n        }\n\n        float t = (w - standardObserver1931_w_min) / (standardObserver1931_w_max - standardObserver1931_w_min);\n        \n#if SHOW_SPREAD        \n        {\n            vec2 vSpPos = vec2( mix( fSpMinX, fSpMaxX, t), fSpMinY - fGap);\n            \n            vec2 vOffset = vSpPos - drawContext.vUV;\n            float d = length( vOffset );\n            if ( vOffset.y > 0.0 && d < 0.5 )\n            {\n\t        \tvTotXYZ += vCurrXYZ * GetSpectrumGlare( d ) * fPower;\n            }\n        }\n        \n        {\n            vec2 vPrismPos = mix( v0, v1, t );\n            \n            vec2 vOffset = vPrismPos - drawContext.vUV;\n            float d = length( vOffset );\n            if ( d < 0.5 )\n            {\n\t        \tvTotXYZ += vCurrXYZ * GetPrismGlare( d ) * fPower;\n            }\n        }\n#endif        \n        \n        vLightColor += vCurrXYZ * fPower;\n    }\n    \n    vTotXYZ += vLightColor * (fBeam + fBeamGlare) * 0.03;\n\n#if DRAW_PRISM        \n    float fPrismShade = PrismShade( drawContext.vUV );    \n    vTotXYZ += vLightColor * fPrismShade * 0.1 * vec3( 0.8, 0.9, 1 );\n    vTotXYZ += fPrismShade * .3 * vec3( 0.8, 0.9, 1 );\n#endif    \n    \n    if ( inSpectrum )\n    {\n        vTotXYZ += WavelengthToXYZLinear(fSpectrumW0) * 0.3;\n    }\n    \n    /*if (  drawContext.vUV.y > fSpMinY - fGap )\n    {\n    \tvTotXYZ += 0.5;\n    }*/\n    \n    mat3 cat = GetChromaticAdaptionTransform( mCAT_Bradford, XYZ_D65, XYZ_E );           \n\tvTotXYZ = vTotXYZ * cat;\n        \n    vec3 vColor = XYZtosRGB( vTotXYZ );    \n    vColor = max( vColor, vec3(0) );\n    \n    vColor += vColBG;\n\n#if SHOW_LUMINOSITY_BAR    \n    vec2 vLuminosityUV = vSpectrumUV;\n    vLuminosityUV.y += 1.5;\n    if ( InUnitSquare( vLuminosityUV ) )\n    {\n        float l = WavelengthToLuminosityLinear( fSpectrumW0 ) ;\n        vColor += vec3(l);\n    }\n#endif    \n    \n    vColor = 1.0 - exp2( vColor * -2.0 ); // Tonemap\n    \n    vColor = pow( vColor, vec3(1.0 / 2.2) );\n        \n    drawContext.vResult = vColor;\n}\n\nvoid mainSPD( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 vUV = fragCoord / iResolution.xy;\n\n    float fScale = 1.0f;\n    // scale down around centre of square\n    vec2 vDiagramUV = (vUV - 0.5) * fScale + 0.5;\n    \n    // aspect ratio adjust\n    vDiagramUV.x *= iResolution.x / iResolution.y;\n        \n    \n    // centre image horizontally\n    vDiagramUV.x += (1.0 - (iResolution.x / iResolution.y)) / 2.0;\n    \n    vec3 vColBg = texture( iChannel0, vUV * 2.0 ).rgb;\n    vColBg = vColBg * vColBg * 0.01;     \n    \n    vec3 vClearColor = vec3( 0.0 );\n    DrawContext drawContext = DrawContext_Init( vDiagramUV, vClearColor );\n    \n    DrawSpectrum( drawContext, vColBg );    \n    \n    //DrawLine( drawContext, vec3(0.5), vec2(0.1, 0.1), vec2(0.9, 0.9),  0.1 );\n    //DrawLine( drawContext, vec3(0.5), vec2(0.1, 0.9), vec2(0.9, 0.1),  0.1 );    \n            \n    vec2 vA = vec2(0.1, 0.5);\n    vec2 vB = vec2(0.9, 0.75);       \n\n    float fGraphLineThickness = 0.015;\n    vec3 vSPDColor = vec3(1);\n\n    int graphY = GRAPH_Y_NORMAL;\n#if RESPONSE_GRAPH_RGB\n    graphY = GRAPH_Y_RGB;\n#endif\n    \n    //graphY = GRAPH_Y_RGB;\n    \n#if SHOW_WEIGHTED_RESPONSE\n\t{\n#if RESPONSE_GRAPH_LMS        \n        vec3 vGraphCols[3] = vec3[3]( \n            vec3( .1, 0, 1 ), \n            vec3( .3,1,.3 ), \n            vec3( 1,1,.1 ) );\n        int graphScale[3] = int[3] ( GRAPH_SCALE_S, GRAPH_SCALE_M, GRAPH_SCALE_L );\n#endif        \n#if RESPONSE_GRAPH_RGB\n        vec3 vGraphCols[3] = vec3[3]( \n            vec3( .8,0,0 ), \n            vec3( 0,.8,0 ), \n            vec3( 0,0,.8 ) );        \n        int graphScale[3] = int[3] ( GRAPH_SCALE_R, GRAPH_SCALE_G, GRAPH_SCALE_B );\n#endif        \n        for ( int i=0; i<NO_UNROLL(3); i++ )\n        {\n            int graphIndex = i;\n            vec2 vGraphUV = GetGraphUV( vDiagramUV, graphIndex );       \n            drawContext = DrawContext_Init( vGraphUV, drawContext.vResult );    \n\t\t    if ( InUnitSquare(drawContext.vUV) )\n            {\n                        \n                float fGraphInfo = GraphInfo( drawContext, GRAPH_SPD, graphScale[i], graphY );\n\n                if ( graphY == GRAPH_Y_RGB )\n                {\n                \tif ( drawContext.vUV.y < 0.21 ) fGraphInfo  = -fGraphInfo;\n                }                \n                \n                float fBlend = LineSmooth( drawContext, fGraphInfo, 0.0 );\n                \n                if ( graphY == GRAPH_Y_NORMAL )\n                {\n                \tif ( drawContext.vUV.y < 0.03 ) fBlend  = 0.0;\n                }\n\n                \n                \n                fBlend *= 0.75;\n                DrawBlend( drawContext, vGraphCols[i], fBlend );\n            }\n        }\n    }        \n#endif\n    \n#if SHOW_RESPONSE_GRAPH    \n\t{\n        \n#if RESPONSE_GRAPH_LMS\n        vec3 vGraphCols[3] = vec3[3]( \n            vec3( .1, 0, 1 ), \n            vec3( .3,1,.3 ), \n            vec3( 1,1,.1 ) );\n        \n        int graphType[3] = int[3] ( GRAPH_CONE_S, GRAPH_CONE_M, GRAPH_CONE_L );\n#endif \n#if RESPONSE_GRAPH_RGB\n        vec3 vGraphCols[3] = vec3[3]( \n            vec3( 1,0,0 ), \n            vec3( 0,1,0 ), \n            vec3( 0,0,1 ) );\n        \n        int graphType[3] = int[3] ( GRAPH_R, GRAPH_G, GRAPH_B );\n#endif \n        \n        for ( int i=0; i<NO_UNROLL(3); i++ )\n        {\n            int graphIndex = 0;\n            #if SEPARATE_RESPONSE_GRAPH\n\t\t\tgraphIndex = i;\n\t\t\t#endif            \n            vec2 vGraphUV = GetGraphUV( vDiagramUV, graphIndex );       \n            drawContext = DrawContext_Init( vGraphUV, drawContext.vResult );    \n            \n\t\t    if ( InUnitSquare(drawContext.vUV) )\n            {   \n#if RESPONSE_GRAPH_RGB                \n                {\n                    float fAxisInfo = drawContext.vUV.y - 0.22;\n                    float fBlend = LineSmooth( drawContext, abs(fAxisInfo), fGraphLineThickness );\n                    DrawBlend( drawContext, vec3(0.25), fBlend );\n                }\n#endif                \n                \n                float fGraphInfo = GraphInfo( drawContext, graphType[i], GRAPH_SCALE_UNITY, graphY );\n                float fBlend = LineSmooth( drawContext, abs(fGraphInfo), fGraphLineThickness );\n                DrawBlend( drawContext, vGraphCols[i], fBlend );\n            }\n        }\n    }\n#endif\n    \n\n#if SHOW_SPD_GRAPH    \n\t{\n#if SEPARATE_SPD_GRAPH\n        for ( int i=0; i<NO_UNROLL(3); i++ )\n#else\n        int i = 0;\n#endif            \n        {\n            vec2 vGraphUV = GetGraphUV( vDiagramUV, i );       \n            drawContext = DrawContext_Init( vGraphUV, drawContext.vResult );    \n\n            if ( InUnitSquare(drawContext.vUV) )\n            {            \n                //float fLineInfo = LineInfo( drawContext.vUV, vA, vB );\n                float fGraphInfo = GraphInfo( drawContext, GRAPH_SPD, GRAPH_SCALE_UNITY, graphY );\n\n                float fBlend = LineSmooth( drawContext, abs(fGraphInfo), fGraphLineThickness );\n                DrawBlend( drawContext, vSPDColor, fBlend );\n            }\n        }\n    }\n#endif    \n        \n#if SHOW_LUMINOSITY_GRAPH\n\t{\n        vec2 vGraphUV = GetGraphUV( vDiagramUV, 0 );       \n        drawContext = DrawContext_Init( vGraphUV, drawContext.vResult );    \n        \n        vec3 vGraphCols[2] = vec3[2]( \n            vec3( 1,1,1 ),\n            vec3( .3,1,.3 )\n        );\n        \n        int graphType[2] = int[2] ( GRAPH_LUMINOSITY, GRAPH_CONE_M );\n        for ( int i=0; i<NO_UNROLL(SHOW_LUMINOSITY_GRAPH); i++ )\n        {\n\t\t    if ( InUnitSquare(drawContext.vUV) )\n            {            \n                float fGraphInfo = GraphInfo( drawContext, graphType[i], GRAPH_SCALE_UNITY, 0 );\n                float fBlend = LineSmooth( drawContext, abs(fGraphInfo), fGraphLineThickness );\n                DrawBlend( drawContext, vGraphCols[i], fBlend );\n            }\n        }\n    }        \n#endif\n        \n            \n\t//DrawLine( drawContext, vec3(0), vec2(0, 0), vec2(1, 0),  0.1 );\n\n    // Output to screen\n    fragColor = vec4(drawContext.vResult,1.0);\n\n    \n#if 0    \n    vec2 vNumSize = vec2(16);\n\n    vec4 vSample = texelFetch( iChannel2, ivec2(0), 0 );\n    float fBestOffset = vSample.x;\n    float fMin = vSample.y;\n    fragColor = mix( fragColor, vec4(1), PrintValue( (fragCoord - vec2(40,30)) / vNumSize, fBestOffset, 3.0, 2.0 ) );\n    fragColor = mix( fragColor, vec4(1), PrintValue( (fragCoord - vec2(160,30)) / vNumSize, fMin, 8.0, 6.0 ) );\n#endif    \n}\n\n\nvoid UI_Compose( vec2 fragCoord, inout vec3 vColor, out int windowId, out vec2 vWindowCoord, out float fShadow )\n{\n    vec4 vUISample = texelFetch( iChannelUI, ivec2(fragCoord), 0 );\n    \n    if ( fragCoord.y < 2.0 )\n    {\n        // Hide data\n        vUISample = vec4(1.0, 1.0, 1.0, 1.0);\n        return;\n    }\n    \n    vColor.rgb = vColor.rgb * (1.0f - vUISample.w) + vUISample.rgb;    \n    \n    windowId = -1;\n    vWindowCoord = vec2(0);\n    \n    fShadow = 1.0f;\n    if ( vUISample.a < 0.0 )\n    {\n        vWindowCoord = vUISample.rg;\n        windowId = int(round(vUISample.b));\n        \n        fShadow = clamp( -vUISample.a - 1.0, 0.0, 1.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mainSPD( fragColor, fragCoord );\n    \n    int windowId;\n    vec2 vWindowCoord;\n    float fShadow;\n    UI_Compose( fragCoord, fragColor.rgb, windowId, vWindowCoord, fShadow );\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.141592654\n#define TAU (PI * 2.0)\n\n#define NO_UNROLL(X) (X + min(0,iFrame))\n#define NO_UNROLLF(X) (X + (min(0.,iTime)))\n#define NO_UNROLLU(X) (X + uint(min(0,iFrame)))\n\n// http://www.cie.co.at/technical-work/technical-resources\nvec3 standardObserver1931[] =\n    vec3[] (\n    vec3( 0.001368, 0.000039, 0.006450 ), // 380 nm\n    vec3( 0.002236, 0.000064, 0.010550 ), // 385 nm\n    vec3( 0.004243, 0.000120, 0.020050 ), // 390 nm\n    vec3( 0.007650, 0.000217, 0.036210 ), // 395 nm\n    vec3( 0.014310, 0.000396, 0.067850 ), // 400 nm\n    vec3( 0.023190, 0.000640, 0.110200 ), // 405 nm\n    vec3( 0.043510, 0.001210, 0.207400 ), // 410 nm\n    vec3( 0.077630, 0.002180, 0.371300 ), // 415 nm\n    vec3( 0.134380, 0.004000, 0.645600 ), // 420 nm\n    vec3( 0.214770, 0.007300, 1.039050 ), // 425 nm\n    vec3( 0.283900, 0.011600, 1.385600 ), // 430 nm\n    vec3( 0.328500, 0.016840, 1.622960 ), // 435 nm\n    vec3( 0.348280, 0.023000, 1.747060 ), // 440 nm\n    vec3( 0.348060, 0.029800, 1.782600 ), // 445 nm\n    vec3( 0.336200, 0.038000, 1.772110 ), // 450 nm\n    vec3( 0.318700, 0.048000, 1.744100 ), // 455 nm\n    vec3( 0.290800, 0.060000, 1.669200 ), // 460 nm\n    vec3( 0.251100, 0.073900, 1.528100 ), // 465 nm\n    vec3( 0.195360, 0.090980, 1.287640 ), // 470 nm\n    vec3( 0.142100, 0.112600, 1.041900 ), // 475 nm\n    vec3( 0.095640, 0.139020, 0.812950 ), // 480 nm\n    vec3( 0.057950, 0.169300, 0.616200 ), // 485 nm\n    vec3( 0.032010, 0.208020, 0.465180 ), // 490 nm\n    vec3( 0.014700, 0.258600, 0.353300 ), // 495 nm\n    vec3( 0.004900, 0.323000, 0.272000 ), // 500 nm\n    vec3( 0.002400, 0.407300, 0.212300 ), // 505 nm\n    vec3( 0.009300, 0.503000, 0.158200 ), // 510 nm\n    vec3( 0.029100, 0.608200, 0.111700 ), // 515 nm\n    vec3( 0.063270, 0.710000, 0.078250 ), // 520 nm\n    vec3( 0.109600, 0.793200, 0.057250 ), // 525 nm\n    vec3( 0.165500, 0.862000, 0.042160 ), // 530 nm\n    vec3( 0.225750, 0.914850, 0.029840 ), // 535 nm\n    vec3( 0.290400, 0.954000, 0.020300 ), // 540 nm\n    vec3( 0.359700, 0.980300, 0.013400 ), // 545 nm\n    vec3( 0.433450, 0.994950, 0.008750 ), // 550 nm\n    vec3( 0.512050, 1.000000, 0.005750 ), // 555 nm\n    vec3( 0.594500, 0.995000, 0.003900 ), // 560 nm\n    vec3( 0.678400, 0.978600, 0.002750 ), // 565 nm\n    vec3( 0.762100, 0.952000, 0.002100 ), // 570 nm\n    vec3( 0.842500, 0.915400, 0.001800 ), // 575 nm\n    vec3( 0.916300, 0.870000, 0.001650 ), // 580 nm\n    vec3( 0.978600, 0.816300, 0.001400 ), // 585 nm\n    vec3( 1.026300, 0.757000, 0.001100 ), // 590 nm\n    vec3( 1.056700, 0.694900, 0.001000 ), // 595 nm\n    vec3( 1.062200, 0.631000, 0.000800 ), // 600 nm\n    vec3( 1.045600, 0.566800, 0.000600 ), // 605 nm\n    vec3( 1.002600, 0.503000, 0.000340 ), // 610 nm\n    vec3( 0.938400, 0.441200, 0.000240 ), // 615 nm\n    vec3( 0.854450, 0.381000, 0.000190 ), // 620 nm\n    vec3( 0.751400, 0.321000, 0.000100 ), // 625 nm\n    vec3( 0.642400, 0.265000, 0.000050 ), // 630 nm\n    vec3( 0.541900, 0.217000, 0.000030 ), // 635 nm\n    vec3( 0.447900, 0.175000, 0.000020 ), // 640 nm\n    vec3( 0.360800, 0.138200, 0.000010 ), // 645 nm\n    vec3( 0.283500, 0.107000, 0.000000 ), // 650 nm\n    vec3( 0.218700, 0.081600, 0.000000 ), // 655 nm\n    vec3( 0.164900, 0.061000, 0.000000 ), // 660 nm\n    vec3( 0.121200, 0.044580, 0.000000 ), // 665 nm\n    vec3( 0.087400, 0.032000, 0.000000 ), // 670 nm\n    vec3( 0.063600, 0.023200, 0.000000 ), // 675 nm\n    vec3( 0.046770, 0.017000, 0.000000 ), // 680 nm\n    vec3( 0.032900, 0.011920, 0.000000 ), // 685 nm\n    vec3( 0.022700, 0.008210, 0.000000 ), // 690 nm\n    vec3( 0.015840, 0.005723, 0.000000 ), // 695 nm\n    vec3( 0.011359, 0.004102, 0.000000 ), // 700 nm\n    vec3( 0.008111, 0.002929, 0.000000 ), // 705 nm\n    vec3( 0.005790, 0.002091, 0.000000 ), // 710 nm\n    vec3( 0.004109, 0.001484, 0.000000 ), // 715 nm\n    vec3( 0.002899, 0.001047, 0.000000 ), // 720 nm\n    vec3( 0.002049, 0.000740, 0.000000 ), // 725 nm\n    vec3( 0.001440, 0.000520, 0.000000 ), // 730 nm\n    vec3( 0.001000, 0.000361, 0.000000 ), // 735 nm\n    vec3( 0.000690, 0.000249, 0.000000 ), // 740 nm\n    vec3( 0.000476, 0.000172, 0.000000 ), // 745 nm\n    vec3( 0.000332, 0.000120, 0.000000 ), // 750 nm\n    vec3( 0.000235, 0.000085, 0.000000 ), // 755 nm\n    vec3( 0.000166, 0.000060, 0.000000 ), // 760 nm\n    vec3( 0.000117, 0.000042, 0.000000 ), // 765 nm\n    vec3( 0.000083, 0.000030, 0.000000 ), // 770 nm\n    vec3( 0.000059, 0.000021, 0.000000 ), // 775 nm\n    vec3( 0.000042, 0.000015, 0.000000 )  // 780 nm\n);\nfloat standardObserver1931_w_min = 380.0f;\nfloat standardObserver1931_w_max = 780.0f;\nint standardObserver1931_length = 81;\n\n// http://www.cvrl.org/ Cone Fundamentals\nvec3 coneFundamentals[] =\n\tvec3[] (\n\tvec3( 0.000000000,  0.000000000,  0.000000000 ), // 380 nm\n\tvec3( 0.000000000,  0.000000000,  0.000000000 ), // 385 nm\n\tvec3( 4.15003E-04,  3.68349E-04,  9.54729E-03 ), // 390 nm\n\tvec3( 1.05192E-03,  9.58658E-04,  2.38250E-02 ), // 395 nm\n\tvec3( 2.40836E-03,  2.26991E-03,  5.66498E-02 ), // 400 nm\n\tvec3( 4.83339E-03,  4.70010E-03,  1.22451E-01 ), // 405 nm\n\tvec3( 8.72127E-03,  8.79369E-03,  2.33008E-01 ), // 410 nm\n\tvec3( 1.33837E-02,  1.45277E-02,  3.81363E-01 ), // 415 nm\n\tvec3( 1.84480E-02,  2.16649E-02,  5.43618E-01 ), // 420 nm\n\tvec3( 2.29317E-02,  2.95714E-02,  6.74474E-01 ), // 425 nm\n\tvec3( 2.81877E-02,  3.94566E-02,  8.02555E-01 ), // 430 nm\n\tvec3( 3.41054E-02,  5.18199E-02,  9.03573E-01 ), // 435 nm\n\tvec3( 4.02563E-02,  6.47782E-02,  9.91020E-01 ), // 440 nm\n\tvec3( 4.49380E-02,  7.58812E-02,  9.91515E-01 ), // 445 nm\n\tvec3( 4.98639E-02,  8.70524E-02,  9.55393E-01 ), // 450 nm\n\tvec3( 5.53418E-02,  9.81934E-02,  8.60240E-01 ), // 455 nm\n\tvec3( 6.47164E-02,  1.16272E-01,  7.86704E-01 ), // 460 nm\n\tvec3( 8.06894E-02,  1.44541E-01,  7.38268E-01 ), // 465 nm\n\tvec3( 9.94755E-02,  1.75893E-01,  6.46359E-01 ), // 470 nm\n\tvec3( 1.18802E-01,  2.05398E-01,  5.16411E-01 ), // 475 nm\n\tvec3( 1.40145E-01,  2.35754E-01,  3.90333E-01 ), // 480 nm\n\tvec3( 1.63952E-01,  2.68063E-01,  2.90322E-01 ), // 485 nm\n\tvec3( 1.91556E-01,  3.03630E-01,  2.11867E-01 ), // 490 nm\n\tvec3( 2.32926E-01,  3.57061E-01,  1.60526E-01 ), // 495 nm\n\tvec3( 2.88959E-01,  4.27764E-01,  1.22839E-01 ), // 500 nm\n\tvec3( 3.59716E-01,  5.15587E-01,  8.88965E-02 ), // 505 nm\n\tvec3( 4.43683E-01,  6.15520E-01,  6.08210E-02 ), // 510 nm\n\tvec3( 5.36494E-01,  7.19154E-01,  4.28123E-02 ), // 515 nm\n\tvec3( 6.28561E-01,  8.16610E-01,  2.92033E-02 ), // 520 nm\n\tvec3( 7.04720E-01,  8.85550E-01,  1.93912E-02 ), // 525 nm\n\tvec3( 7.70630E-01,  9.35687E-01,  1.26013E-02 ), // 530 nm\n\tvec3( 8.25711E-01,  9.68858E-01,  8.09453E-03 ), // 535 nm\n\tvec3( 8.81011E-01,  9.95217E-01,  5.08900E-03 ), // 540 nm\n\tvec3( 9.19067E-01,  9.97193E-01,  3.16893E-03 ), // 545 nm\n\tvec3( 9.40198E-01,  9.77193E-01,  1.95896E-03 ), // 550 nm\n\tvec3( 9.65733E-01,  9.56583E-01,  1.20277E-03 ), // 555 nm\n\tvec3( 9.81445E-01,  9.17750E-01,  7.40174E-04 ), // 560 nm\n\tvec3( 9.94486E-01,  8.73205E-01,  4.55979E-04 ), // 565 nm\n\tvec3( 9.99993E-01,  8.13509E-01,  2.81800E-04 ), // 570 nm\n\tvec3( 9.92310E-01,  7.40291E-01,  1.75039E-04 ), // 575 nm\n\tvec3( 9.69429E-01,  6.53274E-01,  1.09454E-04 ), // 580 nm\n\tvec3( 9.55602E-01,  5.72597E-01,  6.89991E-05 ), // 585 nm\n\tvec3( 9.27673E-01,  4.92599E-01,  4.39024E-05 ), // 590 nm\n\tvec3( 8.85969E-01,  4.11246E-01,  2.82228E-05 ), // 595 nm\n\tvec3( 8.33982E-01,  3.34429E-01,  1.83459E-05 ), // 600 nm\n\tvec3( 7.75103E-01,  2.64872E-01,  1.20667E-05 ), // 605 nm\n\tvec3( 7.05713E-01,  2.05273E-01,  8.03488E-06 ), // 610 nm\n\tvec3( 6.30773E-01,  1.56243E-01,  5.41843E-06 ), // 615 nm\n\tvec3( 5.54224E-01,  1.16641E-01,  0.000000000 ), // 620 nm\n\tvec3( 4.79941E-01,  8.55872E-02,  0.000000000 ), // 625 nm\n\tvec3( 4.00711E-01,  6.21120E-02,  0.000000000 ), // 630 nm\n\tvec3( 3.27864E-01,  4.44879E-02,  0.000000000 ), // 635 nm\n\tvec3( 2.65784E-01,  3.14282E-02,  0.000000000 ), // 640 nm\n\tvec3( 2.13284E-01,  2.18037E-02,  0.000000000 ), // 645 nm\n\tvec3( 1.65141E-01,  1.54480E-02,  0.000000000 ), // 650 nm\n\tvec3( 1.24749E-01,  1.07120E-02,  0.000000000 ), // 655 nm\n\tvec3( 9.30085E-02,  7.30255E-03,  0.000000000 ), // 660 nm\n\tvec3( 6.85100E-02,  4.97179E-03,  0.000000000 ), // 665 nm\n\tvec3( 4.98661E-02,  3.43667E-03,  0.000000000 ), // 670 nm\n\tvec3( 3.58233E-02,  2.37617E-03,  0.000000000 ), // 675 nm\n\tvec3( 2.53790E-02,  1.63734E-03,  0.000000000 ), // 680 nm\n\tvec3( 1.77201E-02,  1.12128E-03,  0.000000000 ), // 685 nm\n\tvec3( 1.21701E-02,  7.61051E-04,  0.000000000 ), // 690 nm\n\tvec3( 8.47170E-03,  5.25457E-04,  0.000000000 ), // 695 nm\n\tvec3( 5.89749E-03,  3.65317E-04,  0.000000000 ), // 700 nm\n\tvec3( 4.09129E-03,  2.53417E-04,  0.000000000 ), // 705 nm\n\tvec3( 2.80447E-03,  1.74402E-04,  0.000000000 ), // 710 nm\n\tvec3( 1.92058E-03,  1.20608E-04,  0.000000000 ), // 715 nm\n\tvec3( 1.32687E-03,  8.41716E-05,  0.000000000 ), // 720 nm\n\tvec3( 9.17777E-04,  5.89349E-05,  0.000000000 ), // 725 nm\n\tvec3( 6.39373E-04,  4.16049E-05,  0.000000000 ), // 730 nm\n\tvec3( 4.46035E-04,  2.94354E-05,  0.000000000 ), // 735 nm\n\tvec3( 3.10869E-04,  2.08860E-05,  0.000000000 ), // 740 nm\n\tvec3( 2.19329E-04,  1.50458E-05,  0.000000000 ), // 745 nm\n\tvec3( 1.54549E-04,  1.08200E-05,  0.000000000 ), // 750 nm\n\tvec3( 1.09508E-04,  7.82271E-06,  0.000000000 ), // 755 nm\n\tvec3( 7.79912E-05,  5.69093E-06,  0.000000000 ), // 760 nm\n\tvec3( 5.56264E-05,  4.13998E-06,  0.000000000 ), // 765 nm\n\tvec3( 3.99295E-05,  3.02683E-06,  0.000000000 ), // 770 nm\n\tvec3( 2.86163E-05,  2.21100E-06,  0.000000000 ), // 775 nm\n\tvec3( 2.07321E-05,  1.63433E-06,  0.000000000 )  // 780 nm\n);\n\n\n// http://www.cvrl.org/ luminous efficiency\nfloat luminousEfficiency[] =\n    float[] (\n    0.0,      // 380 nm\n    0.0,      // 385 nm\n    4.15E-04, // 390 nm\n    1.06E-03, // 395 nm\n    2.45E-03, // 400 nm\n    4.97E-03, // 405 nm\n    9.08E-03, // 410 nm\n    1.43E-02, // 415 nm\n    2.03E-02, // 420 nm\n    2.61E-02, // 425 nm\n    3.32E-02, // 430 nm\n    4.16E-02, // 435 nm\n    5.03E-02, // 440 nm\n    5.74E-02, // 445 nm\n    6.47E-02, // 450 nm\n    7.24E-02, // 455 nm\n    8.51E-02, // 460 nm\n    1.06E-01, // 465 nm\n    1.30E-01, // 470 nm\n    1.54E-01, // 475 nm\n    1.79E-01, // 480 nm\n    2.06E-01, // 485 nm\n    2.38E-01, // 490 nm\n    2.85E-01, // 495 nm\n    3.48E-01, // 500 nm\n    4.28E-01, // 505 nm\n    5.20E-01, // 510 nm\n    6.21E-01, // 515 nm\n    7.18E-01, // 520 nm\n    7.95E-01, // 525 nm\n    8.58E-01, // 530 nm\n    9.07E-01, // 535 nm\n    9.54E-01, // 540 nm\n    9.81E-01, // 545 nm\n    9.89E-01, // 550 nm\n    9.99E-01, // 555 nm\n    9.97E-01, // 560 nm\n    9.90E-01, // 565 nm\n    9.73E-01, // 570 nm\n    9.42E-01, // 575 nm\n    8.96E-01, // 580 nm\n    8.59E-01, // 585 nm\n    8.12E-01, // 590 nm\n    7.54E-01, // 595 nm\n    6.92E-01, // 600 nm\n    6.27E-01, // 605 nm\n    5.58E-01, // 610 nm\n    4.90E-01, // 615 nm\n    4.23E-01, // 620 nm\n    3.61E-01, // 625 nm\n    2.98E-01, // 630 nm\n    2.42E-01, // 635 nm\n    1.94E-01, // 640 nm\n    1.55E-01, // 645 nm\n    1.19E-01, // 650 nm\n    8.98E-02, // 655 nm\n    6.67E-02, // 660 nm\n    4.90E-02, // 665 nm\n    3.56E-02, // 670 nm\n    2.55E-02, // 675 nm\n    1.81E-02, // 680 nm\n    1.26E-02, // 685 nm\n    8.66E-03, // 690 nm\n    6.03E-03, // 695 nm\n    4.20E-03, // 700 nm\n    2.91E-03, // 705 nm\n    2.00E-03, // 710 nm\n    1.37E-03, // 715 nm\n    9.45E-04, // 720 nm\n    6.54E-04, // 725 nm\n    4.56E-04, // 730 nm\n    3.18E-04, // 735 nm\n    2.22E-04, // 740 nm\n    1.57E-04, // 745 nm\n    1.10E-04, // 750 nm\n    7.83E-05, // 755 nm\n    5.58E-05, // 760 nm\n    3.98E-05, // 765 nm\n    2.86E-05, // 770 nm\n    2.05E-05, // 775 nm\n    1.49E-05  // 780 nm        \n);\n\nvec3 WavelengthToXYZLinear( float fWavelength )\n{\n    float fPos = ( fWavelength - standardObserver1931_w_min ) / (standardObserver1931_w_max - standardObserver1931_w_min);\n    float fIndex = fPos * float(standardObserver1931_length);\n    float fFloorIndex = floor(fIndex);\n    float fBlend = clamp( fIndex - fFloorIndex, 0.0, 1.0 );\n    int iIndex0 = int(fFloorIndex);\n    int iIndex1 = iIndex0 + 1;\n    iIndex0 = min( iIndex0, standardObserver1931_length - 1);\n    iIndex1 = min( iIndex1, standardObserver1931_length - 1);    \n    return mix( standardObserver1931[iIndex0], standardObserver1931[iIndex1], fBlend );\n}\n\nvec3 WavelengthToConeLinear( float fWavelength )\n{\n    float fPos = ( fWavelength - standardObserver1931_w_min ) / (standardObserver1931_w_max - standardObserver1931_w_min);\n    float fIndex = fPos * float(standardObserver1931_length);\n    float fFloorIndex = floor(fIndex);\n    float fBlend = clamp( fIndex - fFloorIndex, 0.0, 1.0 );\n    int iIndex0 = int(fFloorIndex);\n    int iIndex1 = iIndex0 + 1;\n    iIndex0 = min( iIndex0, standardObserver1931_length - 1);\n    iIndex1 = min( iIndex1, standardObserver1931_length - 1);    \n    return mix( coneFundamentals[iIndex0], coneFundamentals[iIndex1], fBlend );\n}\n\nfloat WavelengthToLuminosityLinear( float fWavelength )\n{\n    float fPos = ( fWavelength - standardObserver1931_w_min ) / (standardObserver1931_w_max - standardObserver1931_w_min);\n    float fIndex = fPos * float(standardObserver1931_length);\n    float fFloorIndex = floor(fIndex);\n    float fBlend = clamp( fIndex - fFloorIndex, 0.0, 1.0 );\n    int iIndex0 = int(fFloorIndex);\n    int iIndex1 = iIndex0 + 1;\n    iIndex0 = min( iIndex0, standardObserver1931_length - 1);\n    iIndex1 = min( iIndex1, standardObserver1931_length - 1);    \n    return mix( luminousEfficiency[iIndex0], luminousEfficiency[iIndex1], fBlend );\n}\n\n\n\nvec3 WavelengthToRGBLinear( float fWavelength )\n{\n     mat3 m = mat3( 2.3706743, -0.9000405, -0.4706338,\n\t-0.5138850,  1.4253036,  0.0885814,\n \t0.0052982, -0.0146949,  1.0093968 );\n    return WavelengthToXYZLinear( fWavelength ) * m;\n}\n\nvec3 XYZtosRGB( vec3 XYZ )\n{\n    // XYZ to sRGB\n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n   mat3 m = mat3 (\n        3.2404542, -1.5371385, -0.4985314,\n\t\t-0.9692660,  1.8760108,  0.0415560,\n \t\t0.0556434, -0.2040259,  1.0572252 );\n    \n    return XYZ * m;\n}\n\nvec3 sRGBtoXYZ( vec3 RGB )\n{\n   // sRGB to XYZ\n   // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\n   mat3 m = mat3(  \t0.4124564,  0.3575761, 0.1804375,\n \t\t\t\t\t0.2126729,  0.7151522, 0.0721750,\n \t\t\t\t\t0.0193339,  0.1191920, 0.9503041 );\n    \n    \n    return RGB * m;\n}\n\nvec3 WavelengthToXYZ( float f )\n{    \n    //return xyzFit_1931( f ) * mXYZtoSRGB;\n    \n    return WavelengthToXYZLinear( f );\n}\n\n\nstruct Chromaticities\n{\n    vec2 R, G, B, W;\n};\n    \nvec3 CIE_xy_to_xyz( vec2 xy )\n{\n    return vec3( xy, 1.0f - xy.x - xy.y );\n}\n\nvec3 CIE_xyY_to_XYZ( vec3 CIE_xyY )\n{\n    float x = CIE_xyY[0];\n    float y = CIE_xyY[1];\n    float Y = CIE_xyY[2];\n    \n    float X = (Y / y) * x;\n    float Z = (Y / y) * (1.0 - x - y);\n        \n\treturn vec3( X, Y, Z );        \n}\n\nvec3 CIE_XYZ_to_xyY( vec3 CIE_XYZ )\n{\n    float X = CIE_XYZ[0];\n    float Y = CIE_XYZ[1];\n    float Z = CIE_XYZ[2];\n    \n    float N = X + Y + Z;\n    \n    float x = X / N;\n    float y = Y / N;\n    float z = Z / N;\n    \n    return vec3(x,y,Y);\n}\n\nChromaticities Primaries_Rec709 =\nChromaticities(\n        vec2( 0.6400, 0.3300 ),\t// R\n        vec2( 0.3000, 0.6000 ),\t// G\n        vec2( 0.1500, 0.0600 ), \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nChromaticities Primaries_Rec2020 =\nChromaticities(\n        vec2( 0.708,  0.292 ),\t// R\n        vec2( 0.170,  0.797 ),\t// G\n        vec2( 0.131,  0.046 ),  \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nChromaticities Primaries_DCI_P3_D65 =\nChromaticities(\n        vec2( 0.680,  0.320 ),\t// R\n        vec2( 0.265,  0.690 ),\t// G\n        vec2( 0.150,  0.060 ),  \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nmat3 RGBtoXYZ( Chromaticities chroma )\n{\n    // xyz is a projection of XYZ co-ordinates onto to the plane x+y+z = 1\n    // so we can reconstruct 'z' from x and y\n    \n    vec3 R = CIE_xy_to_xyz( chroma.R );\n    vec3 G = CIE_xy_to_xyz( chroma.G );\n    vec3 B = CIE_xy_to_xyz( chroma.B );\n    vec3 W = CIE_xy_to_xyz( chroma.W );\n    \n    // We want vectors in the directions R, G and B to form the basis of\n    // our matrix...\n    \n\tmat3 mPrimaries = mat3 ( R, G, B );\n    \n    // but we want to scale R,G and B so they result in the\n    // direction W when the matrix is multiplied by (1,1,1)\n    \n    vec3 W_XYZ = W / W.y;\n\tvec3 vScale = inverse( mPrimaries ) * W_XYZ;\n    \n    return transpose( mat3( R * vScale.x, G * vScale.y, B * vScale.z ) );\n}\n\nmat3 XYZtoRGB( Chromaticities chroma )\n{\n    return inverse( RGBtoXYZ(chroma) );\n}\n\n// chromatic adaptation\n\n// http://www.brucelindbloom.com/index.html?Eqn_ChromAdapt.html    \n\nvec3 XYZ_A = vec3( 1.09850,\t1.00000,\t0.35585); // Illuminant A\nvec3 XYZ_E = vec3(1.0,\t1.00000,\t1.0); // E\nvec3 XYZ_D65 = vec3(0.95047,\t1.00000,\t1.08883); // D65\n\nmat3 CA_A_to_D65_VonKries = mat3(\n    0.9394987, -0.2339150,  0.4281177,\n\t-0.0256939,  1.0263828,  0.0051761,\n \t0.0000000,  0.0000000,  3.0598005\n    );\n\n\nmat3 CA_A_to_D65_Bradford = mat3(\n    0.8446965, -0.1179225,  0.3948108,\n\t-0.1366303,  1.1041226,  0.1291718,\n \t0.0798489, -0.1348999,  3.1924009\n    );\n\n\nconst mat3 mCAT_VonKries = mat3 ( \n    0.4002400,  0.7076000, -0.0808100,\n\t-0.2263000,  1.1653200,  0.0457000,\n \t0.0000000,  0.0000000,  0.9182200 );\n\nconst mat3 mCAT_02 = mat3( \t0.7328, 0.4296, -0.1624,\n\t\t\t\t\t\t\t-0.7036, 1.6975, 0.0061,\n \t\t\t\t\t\t\t0.0030, 0.0136, 0.9834 );\n\nconst mat3 mCAT_Bradford = mat3 (  0.8951000, 0.2664000, -0.1614000,\n\t\t\t\t\t\t\t\t-0.7502000,  1.7135000,  0.0367000,\n \t\t\t\t\t\t\t\t0.0389000, -0.0685000,  1.0296000 );\n\n\nmat3 GetChromaticAdaptionTransform( mat3 M, vec3 XYZ_w, vec3 XYZ_wr )\n{\n    //return inverse(CA_A_to_D65_VonKries);    \n    //return inverse(CA_A_to_D65_Bradford);\n        \n    //return mat3(1,0,0, 0,1,0, 0,0,1); // do nothing\n    \n\t//mat3 M = mCAT_02;\n    //mat3 M = mCAT_Bradford;\n    //mat3 M = mCAT_VonKries;\n    //mat3 M = mat3(1,0,0,0,1,0,0,0,1);\n    \n    vec3 w = XYZ_w * M;\n    vec3 wr = XYZ_wr * M;\n    vec3 s = w / wr;\n    \n    mat3 d = mat3( \n        s.x,\t0,\t\t0,  \n        0,\t\ts.y,\t0,\n        0,\t\t0,\t\ts.z );\n        \n    mat3 cat = M * d * inverse(M);\n    return cat;\n}\n\n\n\n// DrawContext simple 2d drawing\n\nstruct DrawContext\n{\n    vec2 vUV;\n    vec3 vResult;\n    float fEdgeFade;\n};\n\nDrawContext DrawContext_Init( vec2 vUV, vec3 vClearColor )\n{\n    vec2 vWidth = fwidth( vUV );\n    \n    float fEdgeFade = 1.0 / max(abs(vWidth.x), abs(vWidth.y));\n    return DrawContext( vUV, vClearColor, fEdgeFade );\n}\n\nbool DrawContext_OnCanvas( DrawContext drawContext )\n{\n    vec2 vUV = drawContext.vUV;\n    if ( (vUV.x >= 0.0f) && (vUV.y >= 0.0f) && (vUV.x < 1.0f) && (vUV.y < 1.0f) ) \n    {    \n    \treturn true;\n    }\n    return false;\n}\n    \nfloat LineSmooth( DrawContext drawContext, float fDist, float fThickness )\n{\n    return clamp( (fThickness - fDist) * drawContext.fEdgeFade, 0.0, 1.0 );\n}\n\nfloat LineInfo( vec2 vUV, vec2 vA, vec2 vB, out vec2 vClosest )\n{\n    vec2 vDir = vB - vA;\n\n    float fLen = length(vDir);\n\n    float fDist = 10000.0;\n    float fSide = -1.0;\n    \n    float fEpsilon = 0.002f;\n    \n    if ( fLen < fEpsilon )\n    {\n        vClosest = vA;\n    }\n    else\n    {\n        vDir /= fLen;            \n        vec2 vOffset = vUV - vA.xy;            \n\n        float cp = vDir.x * vOffset.y - vDir.y * vOffset.x;\n        if ( cp > 0.0f )\n        {\n            fSide = 1.0;\n        }\n\n        float d = dot( vDir, vOffset );\n        d = clamp( d, 0.0, fLen );\n        vClosest = vA + vDir * d;\n    }  \n    fDist = length( vClosest - vUV );\n    \n    return fDist * fSide;\n}\n\n\nfloat LineInfo( vec2 vUV, vec2 vA, vec2 vB )\n{\n    vec2 vClosestUnused;\n    return LineInfo( vUV, vA, vB, vClosestUnused );\n}\n\nvoid DrawBlend( inout DrawContext drawContext, vec3 vColor, float fBlend )\n{\n    drawContext.vResult = mix( drawContext.vResult, vColor, clamp( fBlend, 0.0, 1.0 ) );\n}\n\nvoid DrawOutlinePoint( inout DrawContext drawContext, vec3 vOutlineColor, vec3 vColor, vec2 vPos, float fStrokeThickness, float fOutlineThickness )\n{\n    float fDist = length( drawContext.vUV - vPos );\n    \n    DrawBlend( drawContext, vOutlineColor, LineSmooth( drawContext, fDist, fStrokeThickness + fOutlineThickness) );\n    DrawBlend( drawContext, vColor, LineSmooth( drawContext, fDist, fStrokeThickness ) );  \n}\n\nbool InUnitSquare( vec2 vPos )\n{\n    return (vPos.x >= 0.0) && (vPos.y >= 0.0) && (vPos.x < 1.0) && (vPos.y < 1.0);\n}\n\n\nbool InRect( vec2 vPos, vec2 vA, vec2 vB )\n{\n    return (vPos.x >= vA.x) && (vPos.y >= vA.y) && (vPos.x < vB.x) && (vPos.y < vB.y);\n}\n\nvoid DrawRect( inout DrawContext drawContext, vec3 vColor, vec2 vA, vec2 vB )\n{\n    vec2 vUV = drawContext.vUV;\n    \n    if ( InRect( vUV, vA, vB ) )\n    {    \n    \tdrawContext.vResult = vColor;\n    }\n}\n\nvoid DrawLine( inout DrawContext drawContext, vec3 vColor, vec2 vA, vec2 vB, float fThickness )\n{\n    DrawBlend( drawContext, vColor, LineSmooth( drawContext, abs(LineInfo( drawContext.vUV, vA, vB )), fThickness ) );\n}\n\nstruct PolyInfo\n{\n\tfloat fDist;\n\tfloat fEdgeDist;\n};\n\nPolyInfo Poly_Init()\n{\n    return PolyInfo( -10000.0f, 10000.0f );\n}\n\nvoid Poly_Edge( inout PolyInfo polyInfo, float fEdgeInfo )\n{\n    polyInfo.fDist = max( polyInfo.fDist, fEdgeInfo );\n    polyInfo.fEdgeDist = min( polyInfo.fEdgeDist, abs( fEdgeInfo ) );\n}\n\n\n\n\n// Random\n\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nfloat SmoothNoise(float o) \n{\n\tfloat p = floor(o);\n\tfloat f = fract(o);\n\t\t\n\t//float n = p.x + p.y*57.0;\n\n\tfloat a = hash11(p);\n\tfloat b = hash11(p+1.0);\n\t\n\tfloat f2 = f * f;\n\tfloat f3 = f2 * f;\n\t\n\tfloat t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat res = a + (b-a)*t;\n    \n    return res;\n}\n\nfloat FBM( float p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<5; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( const vec2 vStringCoords, const float fValue, const float fMaxDigits, const float fDecimalPlaces )\n{\n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\n\n\n// Hacky SPD compare\n\nfloat SPD_Test( float w )\n{\n    float n = FBM( w * 0.02, 0.5 );\n    return n * n;\n}\n\nfloat Match( float fOffsetA, float fOffsetB )\n{    \n    vec3 vTotXYZA = vec3(0);\n    vec3 vTotXYZB = vec3(0);\n    \n    for( float w = standardObserver1931_w_min; w < standardObserver1931_w_max; w += 5.0 )\n    {\n        vec3 vCurrXYZ = WavelengthToXYZLinear( w );\n\n        float fPowerA = SPD_Test( w + fOffsetA );\n        float fPowerB = SPD_Test( w + fOffsetB );\n        \n        vTotXYZA += vCurrXYZ * fPowerA;\n\t\tvTotXYZB += vCurrXYZ * fPowerB;\n\n    }  \n           \n    return length( vTotXYZA - vTotXYZB );\n}\n\n\n\n//\n//  _  __          _                         _ \n// | |/ /___ _   _| |__   ___   __ _ _ __ __| |\n// | ' // _ \\ | | | '_ \\ / _ \\ / _` | '__/ _` |\n// | . \\  __/ |_| | |_) | (_) | (_| | | | (_| |\n// |_|\\_\\___|\\__, |_.__/ \\___/ \\__,_|_|  \\__,_|\n//           |___/                             \n//\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\nconst int KEY_1 = \t49;\nconst int KEY_2 = \t50;\nconst int KEY_3 = \t51;\nconst int KEY_ENTER = 13;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_ALT   = 18;\nconst int KEY_TAB\t= 9;\n\nbool Key_IsPressed( sampler2D samp, int key)\n{\n    return texelFetch( samp, ivec2(key, 0), 0 ).x > 0.0;    \n}\n\nbool Key_IsToggled(sampler2D samp, int key)\n{\n    return texelFetch( samp, ivec2(key, 2), 0 ).x > 0.0;    \n}\n\n\n\n/////////// UI DATA:\n\nconst int\n    DATA_UICONTEXT\t\t\t\t\t\t= 0,\t\n\tDATA_WINDOW_CONTROLS   \t\t\t\t= 1,    \n\tDATA_CHECKBOX_A \t\t\t= 3,\n\tDATA_FLOAT_A\t\t\t= 4,\n\tDATA_FLOAT_B        \t\t= 5,\n    DATA_FLOAT_C = 6,\n    DATA_WINDOW_SCROLLBAR = 7,\n    DATA_FLOAT_SPD = 8\n;\n    \nconst int\n\tIDC_WINDOW_CONTROLS      \t\t\t= 0,\n    IDC_CHECKBOX_A \t\t\t= 1,\n\tIDC_SLIDER_FLOAT_A\t\t= 2,\n\tIDC_SLIDER_FLOAT_B     \t= 3,\n    IDC_SLIDER_FLOAT_C \t\t= 4,\n    IDC_WINDOW_SCROLLBAR\t= 5,\n    IDC_SLIDER_SPD \t\t\t= 6;\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Super Shader GUI\n// https://www.shadertoy.com/view/Xs2cR1\n// Shadertoy UI framework - @P_Malin\n\n\n#define iChannelUI \t\t\tiChannel0\n#define iChannelKeyboard \tiChannel1\n#define iChannelFont \t\tiChannel2\n\n#define SHADOW_TEST\n\n#define NEW_THEME\n\n#ifdef NEW_THEME\nvec3 cCheckboxOutline = vec3(0.4);\nvec3 cSliderLineCol = vec3(0.7);\nvec3 cSliderHandleOutlineCol = vec3(0.5);\nvec3 cButtonActive = vec3(0.6, 0.6, 0.9 );\nvec3 cButtonInactive = vec3( 0.5 );\nvec3 cWindowBorder = vec3(0.5, 0.5, 0.6 );\nvec3 cActiveWindowBorder = vec3(0.3, 0.3, 0.5 );\nvec3 cWindowBackgroundColor = vec3(0.9);\nconst vec3 cTitleBarA = vec3(0.7);\nconst vec3 cTitleBarB = cTitleBarA + 0.1;\nvec3 cTitleBarAActive = cTitleBarA + 0.05;\nvec3 cTitleBarBActive = cTitleBarB + 0.05; \nvec3 cWindowTitle = vec3(0.0);\nvec3 cResize = vec3( 0.7 );\nvec3 cResizeActive = vec3( 0.8 );\nvec3 cScrollPanelCorner = vec3(0.6);\nvec3 cScrollPanelCornerOutline = vec3(0.7);\n#else\nvec3 cWindowBackgroundColor = vec3(0.75);\nconst vec3 cTitleBarA = vec3(0.0, 0.0, 0.5);\nconst vec3 cTitleBarB = vec3(0.03, 0.5, 0.8);\nvec3 cTitleBarAActive = cTitleBarA + 0.1;\nvec3 cTitleBarBActive = cTitleBarB + 0.1; \nvec3 cWindowTitle = vec3(1.0);        \nvec3 cResize = vec3( 0.6 );\nvec3 cResizeActive = vec3( 0.8 );\nvec3 cScrollPanelCorner = vec3(0.7);\n#endif\n\n///////////////////////////\n// Data Storage\n///////////////////////////\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( p, c ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n///////////////////////////\n// Rect\n///////////////////////////\n\nstruct Rect\n{\n    vec2 vPos;\n    vec2 vSize;\n};      \n\nbool Inside( vec2 vPos, vec2 vMin, vec2 vMax )\n{\n    return all( greaterThanEqual( vPos, vMin ) ) && all( lessThan( vPos, vMax ) );\n}\n\nbool Outside( vec2 vPos, vec2 vMin, vec2 vMax )\n{\n    return any( lessThan( vPos, vMin ) ) || any( greaterThanEqual( vPos, vMax ) );\n}\n\nbool Inside( vec2 vPos, Rect rect )\n{\n    return Inside( vPos, rect.vPos, rect.vPos + rect.vSize );\n}\n    \nbool Outside( vec2 vPos, Rect rect )\n{\n    return Outside( vPos, rect.vPos, rect.vPos + rect.vSize );\n}\n\nvoid RectExpand( inout Rect region, vec2 vPadding )\n{\n    // Padding\n    region.vPos -= vPadding;\n    region.vSize += vPadding * 2.0;        \n}\n\nvoid RectShrink( inout Rect region, vec2 vPadding )\n{\n    RectExpand( region, -vPadding);\n}\n\n///////////////////////////\n// Font\n///////////////////////////\n\n// Font printing based on https://www.shadertoy.com/view/ldfcDr\n\n#define AUTO_FONT_SPACING\n//#define HANDLE_EOL\n//#define HANDLE_PRINT_STYLES\n\n// Font characters\nconst uint\n   \t// HTML Entity Names\n    \n    _SP = 0x20u,\t\t// ' '\n    _EXCL = 0x21u, \t\t// '!' \n    _QUOT = 0x22u, \t\t// '\"'\n    _NUM = 0x23u,  \t\t// '#'\n    _DOLLAR = 0x24u, \t// '$'\n    _PERCNT = 0x25u, \t// '%'\n    _AMP = 0x26u, \t\t// '&'\n    _APOS = 0x27u,\t\t// '''    \n    _LPAR = 0x28u, \t\t// '('\n    _RPAR= 0x29u, \t\t// ')'\n    _AST = 0x2Au,\t\t// '*'\n    _PLUS = 0x2Bu,\t\t// '+'\n    _COMMA = 0x2Cu,\t\t// ','    \n    _MINUS = 0x2Du,\t\t// '-'\n    _PERIOD = 0x2Eu,\t// '.'\n    _SOL = 0x2Fu,\t\t// '/' \n\n    _0 = 0x30u, _1 = 0x31u, _2 = 0x32u, _3 = 0x33u, _4 = 0x34u, \n    _5 = 0x35u, _6 = 0x36u, _7 = 0x37u, _8 = 0x38u, _9 = 0x39u, \n\n    _COLON = 0x3Au,\t\t// ':' \n    _SEMI = 0x3Bu,\t\t// ';' \n    _LT = 0x3Cu,\t\t// '<' \n    _EQUALS = 0x3Du,\t// '=' \n    _GT = 0x3Eu,\t\t// '>' \n    _QUEST = 0x3Fu,\t\t// '?' \n    _COMAT = 0x40u,\t\t// '@' \n    \n    _A = 0x41u, _B = 0x42u, _C = 0x43u, _D = 0x44u, _E = 0x45u, \n    _F = 0x46u, _G = 0x47u, _H = 0x48u, _I = 0x49u, _J = 0x4Au,\n    _K = 0x4Bu, _L = 0x4Cu, _M = 0x4Du, _N = 0x4Eu, _O = 0x4Fu,\n    _P = 0x50u, _Q = 0x51u, _R = 0x52u, _S = 0x53u, _T = 0x54u,\n    _U = 0x55u, _V = 0x56u, _W = 0x57u, _X = 0x58u, _Y = 0x59u,\n    _Z = 0x5Au,\n\n    _LSQB = 0x5Bu,\t\t// '[' \n    _BSOL = 0x5Cu,\t\t// '\\'\n    _RSQB = 0x5Du,\t\t// ']' \n    _CIRC = 0x5Eu,\t\t// '^' \n    _LOWBAR = 0x5Fu,\t// '_' \n    _GRAVE = 0x60u,\t\t// '`' \n    \n    _a = 0x61u, _b = 0x62u, _c = 0x63u, _d = 0x64u, _e = 0x65u,\n    _f = 0x66u, _g = 0x67u, _h = 0x68u, _i = 0x69u, _j = 0x6Au,\n    _k = 0x6Bu, _l = 0x6Cu, _m = 0x6Du, _n = 0x6Eu, _o = 0x6Fu,\n    _p = 0x70u, _q = 0x71u, _r = 0x72u, _s = 0x73u, _t = 0x74u,\n    _u = 0x75u, _v = 0x76u, _w = 0x77u, _x = 0x78u, _y = 0x79u,\n    _z = 0x7Au\n\n\t,_LCUB = 0x7Bu\t\t// '{'\n    ,_VERBAR = 0x7Cu\t// '|'\n    ,_RCUB = 0x7Du\t\t// '}'\n    ,_TILDE = 0x7Eu\t\t// '~'\n    \n#ifdef HANDLE_EOL       \n    ,_EOL = 0x1000u \t// End of Line - Carriage Return & Line Feed    \n#endif    \n#ifdef HANDLE_PRINT_STYLES    \n    ,_BOLDON = 0x1001u\t// Special\n    ,_BOLDOFF = 0x1002u\t// Special\n    ,_ITALON = 0x1003u\t// Special\n    ,_ITALOFF = 0x1004u\t// Special    \n#endif    \n;\n\n\nvec4 SampleCharacterTex( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vUV = (vec2(iChPos) + vCharUV) / 16.0f;\n    return textureLod( iChannelFont, vUV, 0.0 );\n}\n    \nvec4 SampleCharacter( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vClampedCharUV = clamp(vCharUV, vec2(0.01), vec2(0.99));\n    vec2 vUV = (vec2(iChPos) + vClampedCharUV) / 16.0f;\n\n    vec4 vSample;\n    \n    float l = length( (vClampedCharUV - vCharUV) );\n\n    // Skip texture sample when not in character boundary\n    // Ok unless we have big font weight\n    if ( l > 0.01f )\n    {\n        vSample.rgb = vec3(0);\n\t\tvSample.w = 2000000.0; \n    }\n    else\n    {\n\t\tvSample = textureLod( iChannelFont, vUV, 0.0 );    \n        vSample.gb = vSample.gb * 2.0f - 1.0f;\n        vSample.a -= 0.5f + 1.0/256.0;    \n    }\n        \n    return vSample;\n}\n\n\nstruct CharExtents\n{\n    float left;\n    float width;\n};\n    \n// Auto font spacing adapted from Klems shader: https://www.shadertoy.com/view/MsfyDN\nfloat CharVerticalPos(uint iChar, vec2 vUV) \n{\n    vec4 vSample = SampleCharacterTex(iChar, vUV);\n    float dist = vSample.a - (127.0/255.0);\n    dist *= vSample.g * 2.0 - 1.0;\n    return vUV.x - dist;\n}\n\nCharExtents GetCharExtents( uint iChar )\n{\n    CharExtents result;\n\n    result.left = CharVerticalPos( iChar, vec2(0.02, 0.5) );\n    float right = CharVerticalPos( iChar, vec2(0.98, 0.5) );\n    result.width = right - result.left;\n    \n    if ( iChar == _SP )\n    {\n        result.left = 0.3f;\n        result.width = 0.4f;\n    }\n    return result;\n}\n\nstruct PrintState\n{\n    vec2 vPixelPos;\n    \n    vec2 vLayoutStart;\n    // print position\n    vec2 vCursorPos;\n    vec2 vPixelSize;\n\n#ifdef HANDLE_EOL\n    bool EOL;\n#endif\n\n    // result\n    float fDistance;\n};    \n\nvoid MoveTo( inout PrintState state, vec2 vPos )\n{\n    state.vLayoutStart = vPos;\n    state.vCursorPos = vPos;\n#ifdef HANDLE_EOL\n    state.EOL = false;\n#endif\n}\n\nvoid ClearPrintResult( inout PrintState state )\n{\n    state.fDistance = 1000000.0;   \n}\n\nPrintState PrintState_InitCanvas( vec2 vCoords, vec2 vPixelSize )\n{\n    PrintState state;\n    state.vPixelPos = vCoords;\n    state.vPixelSize = vPixelSize;\n    \n    MoveTo( state, vec2(0) );\n\n    ClearPrintResult( state );\n    \n    return state;\n}\n\nstruct LayoutStyle\n{\n    vec2 vSize;\n    float fLineGap;\n    float fAdvancement;\n#ifdef HANDLE_PRINT_STYLES    \n    bool bItalic;\n    bool bBold;  \n#endif    \n};\n    \nLayoutStyle LayoutStyle_Default()\n{\n    LayoutStyle style;\n    style.vSize = vec2(24.0f, 32.0f);    \n    style.fLineGap = 0.1f;\n    style.fAdvancement = 0.1f;\n#ifdef HANDLE_PRINT_STYLES    \n    style.bItalic = false;\n    style.bBold = false;       \n#endif    \n    return style;\n}\n\nstruct RenderStyle\n{\n    vec3 vFontColor;\n    float fFontWeight;   \n};\n\nRenderStyle RenderStyle_Default( vec3 vFontColor )\n{\n    RenderStyle style;\n    style.vFontColor = vFontColor;\n    style.fFontWeight = 0.0f;  \n    return style;\n}\n\nconst float g_fFontDescent = 0.15f;\nconst float g_fFontAscent = 0.65f;\n\nvoid PrintEndCurrentLine( inout PrintState state, const LayoutStyle style )\n{\n    // Apply CR\n    state.vCursorPos.x = state.vLayoutStart.x;\n    \n    // advance Y position to bottom of descender based on current font size.\n\tstate.vCursorPos.y += style.vSize.y * g_fFontDescent;    \n}\n\nvoid PrintBeginNextLine( inout PrintState state, const LayoutStyle style )\n{\n    // move Y position to baseline based on current font size\n\tstate.vCursorPos.y += style.vSize.y * (g_fFontAscent + style.fLineGap);\n}\n\n#ifdef HANDLE_EOL\nvoid PrintEOL( inout PrintState state, const LayoutStyle style )\n{\n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n    }\n    PrintEndCurrentLine( state, style );\n    state.EOL = true;\n}\n#endif\n\nvoid PrintCh( inout PrintState state, inout LayoutStyle style, const uint iChar )\n{\n#ifdef HANDLE_EOL\n    if ( iChar == _EOL )\n    {\n        PrintEOL( state, style );\n        return;\n    }\n    else\n#endif\n#ifdef HANDLE_PRINT_STYLES            \n    if ( iChar == _BOLDON )\n    {\n        style.bBold = true;\n        return;\n    }\n    else\n    if ( iChar == _BOLDOFF )\n    {\n        style.bBold = false;\n        return;\n    }\n    else\n    if ( iChar == _ITALON )\n    {\n        style.bItalic = true;\n        return;\n    }\n    else\n    if ( iChar == _ITALOFF )\n    {\n        style.bItalic = false;\n        return;\n    }\n#endif\n    \n#ifdef HANDLE_EOL\n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n\t\tstate.EOL = false;\n    }\n#endif\n    \n    vec2 vUV = ((state.vPixelPos - state.vCursorPos) / style.vSize);\n\n    /*if ( (vUV.y > -0.1) && (vUV.y < 0.1) && (abs(vUV.x) < 0.02 || abs(vUV.x - CharWidth(iChar)) < 0.02) )\n    {\n        state.fDistance = -10.0;\n    }*/\n    \n\tCharExtents extents = GetCharExtents( iChar );    \n    vUV.y += 0.8f; // Move baseline\n    vUV.x += extents.left - style.fAdvancement;\n    \n#ifdef HANDLE_PRINT_STYLES    \n    if ( style.bItalic )\n    {\n    \tvUV.x += (1.0 - vUV.y) * -0.4f;\n    }\n#endif\n    \n    vec3 v = SampleCharacter( iChar, vUV ).agb;\n\n#ifdef HANDLE_PRINT_STYLES    \n    if ( style.bBold )\n    {\n    \tv.x -= 0.025f;\n    }\n#endif    \n    \n    if ( v.x < state.fDistance )\n    {\n        state.fDistance = v.x;       \n    }\n    \n    state.vCursorPos.x += style.vSize.x * (extents.width + style.fAdvancement);\n}\n\n\nRect GetFontRect( PrintState state, LayoutStyle style, bool initialLineOffset )\n{\n    Rect rect;\n    \n    rect.vPos = state.vLayoutStart;\n    if ( initialLineOffset )\n    {\n    \trect.vPos.y += style.vSize.y * (style.fLineGap + g_fFontAscent);\n    }\n\trect.vPos.y -= style.vSize.y * (g_fFontAscent);\n    rect.vSize.x = state.vCursorPos.x - state.vLayoutStart.x;\n    rect.vSize.y = style.vSize.y * ( g_fFontAscent + g_fFontDescent );\n    \n    return rect;\n}\n\nfloat GetFontBlend( PrintState state, LayoutStyle style, float size )\n{\n    float fFeatherDist = 1.0f * length(state.vPixelSize / style.vSize);    \n    float f = clamp( (size-state.fDistance + fFeatherDist * 0.5f) / fFeatherDist, 0.0, 1.0);\n    return f;\n}\n\nvoid RenderFont( PrintState state, LayoutStyle style, RenderStyle renderStyle, inout vec3 color )\n{   \n    float f = GetFontBlend( state, style, renderStyle.fFontWeight );\n\n    vec3 vCol = renderStyle.vFontColor;\n    \n    color.rgb = mix( color.rgb, vCol, f);    \n}\n\n// Font print helpers\n\n#define NO_UNROLL(X) (X + min(0,iFrame))\n#define NO_UNROLLU(X) (X + uint(min(0,iFrame)))\n\n#define ARRAY_PRINT( STATE, STYLE, CHAR_ARRAY ) { for (int i=0; i< NO_UNROLL( CHAR_ARRAY.length() ); i++) PrintCh( STATE, STYLE, CHAR_ARRAY[i] ); }\n\nvoid Print( inout PrintState state, LayoutStyle style, uint value )\n{\n\tuint place = 1000000000u;\n\n    bool leadingZeros = true;\n    while( place > NO_UNROLLU( 0u ) )\n    {\n        uint digit = (value / place) % 10u;\n        if ( place == 1u || digit != 0u )\n        {\n            leadingZeros = false;\n        }\n        \n        if (!leadingZeros)\n        {\n            PrintCh( state, style, _0 + digit );\n        }\n        place = place / 10u;\n    }    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, int value )\n{\n    if ( value < 0 )\n    {\n        PrintCh( state, style, _MINUS );\n        value = -value;\n    }\n\n    Print ( state, style, uint(value) );    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, float value, int decimalPlaces )\n{\n    if ( value < 0.0f )\n    {\n        PrintCh( state, style, _MINUS );\n    }\n    value = abs(value);\n    \n    int placeIndex = 10;\n    \n    bool leadingZeros = true;\n    while( placeIndex >= NO_UNROLL( -decimalPlaces ) )\n    {\n        float place = pow(10.0f, float(placeIndex) );\n        float digitValue = floor( value / place );\n        value -= digitValue * place;\n        \n        \n        uint digit = min( uint( digitValue ), 9u );\n        \n        if ( placeIndex == -1 )\n        {\n            PrintCh( state, style, _PERIOD );\n        }\n        \n        if ( placeIndex == 0 || digit != 0u )\n        {\n            leadingZeros = false;\n        }        \n        \n        if ( !leadingZeros )\n        {\n        \tPrintCh( state, style, _0 + digit );\n        }\n                \n        placeIndex--;\n    }\n}\n\n\n\n///////////////////////////////////////////\n// General 2d Drawing\n///////////////////////////////////////////\n\nvoid DrawRect( vec2 vCanvasPos, Rect rect, vec4 vColor, inout vec4 vOutColor )\n{\n\tif ( Inside( vCanvasPos, rect ) )\n    {\n        vOutColor = vColor;\n    }\n}\n\nvoid DrawLine( vec2 vCanvasPos, vec2 vA, vec2 vB, float fThickness, vec4 vColor, inout vec4 vOutColor )\n{\n    vec2 vDir = vB - vA;\n    float l = length( vDir );\n    vDir = normalize( vDir );\n\n    vec2 vOffset = vCanvasPos - vA;\n    float fDot = dot( vOffset, vDir );\n    float fT = clamp( fDot, 0.0, l );\n\n    vec2 vClosest = vA + vDir * fT;\n    float fDist = length(vClosest - vCanvasPos) - fThickness;\n\n    if ( fDist < 0.0 )\n    {\n        vOutColor = vColor;\n    }    \n}\n\nvoid DrawBorderOutdent( vec2 vCanvasPos, Rect rect, inout vec4 vOutColor )\n{    \n    vec2 vThickness = vec2(1.0);\n    \n\tif ( Inside( vCanvasPos, rect ) )\n    {\n        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness) ) )\n        {\n            vOutColor.rgb = vec3(0.85);\n        }\n        else\n        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness) ) )\n        {\n            vOutColor.rgb = vec3(0.0);\n        }\n        else\n        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness * 2.0) ) )\n        {\n            vOutColor.rgb = vec3(1.0);\n        }\n        else\n        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness * 2.0) ) )\n        {\n            vOutColor.rgb = vec3(0.4);\n        }\n    }\n}\n\nvoid DrawBorderRect( vec2 vCanvasPos, Rect rect, vec3 vOutlineColor, inout vec4 vOutColor )\n{ \n    vec2 vThickness = vec2(1.0);\n    \n\tif ( Inside( vCanvasPos, rect ) )\n    {        \n        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness) ) )\n        {\n            vOutColor.rgb = vOutlineColor;\n        }\n        else\n        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness) ) )\n        {\n            vOutColor.rgb = vOutlineColor;\n        }\n        else\n        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness * 2.0) ) )\n        {\n            vOutColor.rgb = vOutlineColor;\n        }\n        else\n        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness * 2.0) ) )\n        {\n            vOutColor.rgb = vOutlineColor;\n        }\n    }    \n}\n\nvoid DrawBorderIndent( vec2 vCanvasPos, Rect rect, inout vec4 vOutColor )\n{    \n    vec2 vThickness = vec2(1.0);\n    \n\tif ( Inside( vCanvasPos, rect ) )\n    {        \n        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness) ) )\n        {\n            vOutColor.rgb = vec3(0.0);\n        }\n        else\n        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness) ) )\n        {\n            vOutColor.rgb = vec3(0.85);\n        }\n        else\n        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness * 2.0) ) )\n        {\n            vOutColor.rgb = vec3(0.4);\n        }\n        else\n        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness * 2.0) ) )\n        {\n            vOutColor.rgb = vec3(1.0);\n        }\n    }\n}\n    \nstruct UIDrawContext\n{        \n    vec2 vCanvasSize;\n    \n    // position and size of unclipped viewport on the screen\n    Rect viewport;\n    \n    // visible region of viewport on the screen\n    Rect clip;\n    \n    // canvas co-ordinates at top-left corner of viewport\n    vec2 vOffset;\n};\n\nvec2 UIDrawContext_ScreenPosToCanvasPos( UIDrawContext drawContext, vec2 vScreenPos )\n{\n    vec2 vViewPos = vScreenPos - drawContext.viewport.vPos;\n    return vViewPos + drawContext.vOffset;\n}\n\nvec2 UIDrawContext_CanvasPosToScreenPos( UIDrawContext drawContext, vec2 vCanvasPos )\n{\n    return vCanvasPos - drawContext.vOffset + drawContext.viewport.vPos;\n}\n\nbool UIDrawContext_ScreenPosInView( UIDrawContext drawContext, vec2 vScreenPos )\n{\n    return Inside( vScreenPos, drawContext.clip );\n}\n\nbool UIDrawContext_ScreenPosInCanvasRect( UIDrawContext drawContext, vec2 vScreenPos, Rect canvasRect )\n{\n\tvec2 vCanvasPos = UIDrawContext_ScreenPosToCanvasPos( drawContext, vScreenPos );    \n    return Inside( vCanvasPos, canvasRect );\n}\n\nUIDrawContext UIDrawContext_SetupFromRect( Rect rect )\n{\n    UIDrawContext drawContext;\n    drawContext.viewport = rect;\n    drawContext.vOffset = vec2(0);\n    drawContext.vCanvasSize = rect.vSize;\n\treturn drawContext;\n}\n\n\nUIDrawContext UIDrawContext_TransformChild( UIDrawContext parentContext, UIDrawContext childContext )\n{\n    UIDrawContext result;\n    \n    // The child canvas size is unmodified\n    result.vCanvasSize = childContext.vCanvasSize;\n\n    // Child viewport positions are in the parent's canvas\n    // Transform them to screen co-ordinates    \n    result.viewport.vPos = UIDrawContext_CanvasPosToScreenPos( parentContext, childContext.viewport.vPos );\n    vec2 vMax = childContext.viewport.vPos + childContext.viewport.vSize;\n    vec2 vScreenMax = UIDrawContext_CanvasPosToScreenPos( parentContext, vMax );\n    result.viewport.vSize = vScreenMax - result.viewport.vPos;\n    result.vOffset = childContext.vOffset;\n    \n    // Now clip the view so that it is within the parent view\n    vec2 vViewMin = max( result.viewport.vPos, parentContext.clip.vPos );\n    vec2 vViewMax = min( result.viewport.vPos + result.viewport.vSize, parentContext.clip.vPos + parentContext.clip.vSize );\n\n    // Clip view to current canvas\n    vec2 vCanvasViewMin = result.viewport.vPos - result.vOffset;\n    vec2 vCanvasViewMax = vCanvasViewMin + result.vCanvasSize;\n    \n    vViewMin = max( vViewMin, vCanvasViewMin );\n\tvViewMax = min( vViewMax, vCanvasViewMax );\n    \n    result.clip = Rect( vViewMin, vViewMax - vViewMin );\n    \n    return result;\n}\n\nfloat \tUIStyle_TitleBarHeight();\nvec2 \tUIStyle_WindowBorderSize();\nvec2 \tUIStyle_WindowContentPadding();\nvec2 \tUIStyle_ControlSpacing();\nvec2 \tUIStyle_FontPadding();\nvec2 \tUIStyle_CheckboxSize();\nvec2 \tUIStyle_SliderSize();\nvec3 \tUIStyle_ColorPickerSize();\nfloat \tUIStyle_ScrollBarSize();\nfloat   UIStyle_WindowTransparency();\n\nstruct UILayout\n{\n    float fTabPosition;\n    vec2 vCursor;\n    Rect controlRect;\n    \n    // Bounds of controls in current stack\n    vec2 vControlMax;\n    vec2 vControlMin;\n};\n    \nUILayout UILayout_Reset()\n{\n    UILayout uiLayout;\n    \n    uiLayout.fTabPosition = 0.0;\n    uiLayout.vCursor = vec2(0);\n    uiLayout.controlRect = Rect( vec2(0), vec2(0) );\n    uiLayout.vControlMax = vec2(0);\n    uiLayout.vControlMin = vec2(0);\n    \n    return uiLayout;\n}\n\nRect UILayout_GetStackedControlRect( inout UILayout uiLayout, vec2 vSize )\n{\n    return Rect( uiLayout.vCursor, vSize );\n}\n\nvoid UILayout_SetControlRect( inout UILayout uiLayout, Rect rect )\n{\n    uiLayout.controlRect = rect;\n    \n    uiLayout.vControlMax = max( uiLayout.vControlMax, rect.vPos + rect.vSize );\n    uiLayout.vControlMin = max( uiLayout.vControlMin, rect.vPos );    \n}\n\nRect UILayout_StackControlRect( inout UILayout uiLayout, vec2 vSize )\n{\n    Rect rect = UILayout_GetStackedControlRect( uiLayout, vSize );\n    UILayout_SetControlRect( uiLayout, rect );\n    return rect;\n}\n\nvoid UILayout_SetX( inout UILayout uiLayout, float xPos )\n{\n    uiLayout.vCursor.x = xPos;\n    uiLayout.vControlMax.x = uiLayout.vCursor.x;\n    uiLayout.vControlMin.x = uiLayout.vCursor.x;\n}\n\nvoid UILayout_StackRight( inout UILayout uiLayout )\n{\n    UILayout_SetX( uiLayout, uiLayout.vControlMax.x + UIStyle_ControlSpacing().x );\n}\n\nvoid UILayout_StackDown( inout UILayout uiLayout )\n{\n    uiLayout.vCursor.x = uiLayout.fTabPosition;\n    uiLayout.vCursor.y = uiLayout.vControlMax.y + UIStyle_ControlSpacing().y;    \n    uiLayout.vControlMax.x = uiLayout.vCursor.x;\n    uiLayout.vControlMin.x = uiLayout.vCursor.x;\n    uiLayout.vControlMax.y = uiLayout.vCursor.y;\n    uiLayout.vControlMin.y = uiLayout.vCursor.y;\n}\n\n#define IDC_NONE            -1\n\nstruct UIContext\n{\n    vec2 vPixelPos;\n    \n    vec2 vMousePos;\n    bool bMouseDown;\n    bool bMouseWasDown;\n    bool bHandledClick;\n    \n    ivec2 vFragCoord;\n    vec4 vOutColor;\n    float fBlendRemaining;\n\n    vec4 vOutData;\n    \n    int iActiveControl;\n    vec2 vActivePos;\n\n    UIDrawContext drawContext;\n    bool bPixelInView; // derived from drawContext\n    vec2 vPixelCanvasPos; // derived from drawContext\n    bool bMouseInView; // derived from drawContext\n    vec2 vMouseCanvasPos; // derived from drawContext\n\n    vec4 vWindowOutColor; // Output for current window draw pass\n#ifdef SHADOW_TEST\n    float fShadow;\n    float fOutShadow;\n#endif    \n};\n\nvoid UI_SetDrawContext( inout UIContext uiContext, UIDrawContext drawContext )\n{\n    uiContext.drawContext = drawContext;\n    \n    uiContext.vPixelCanvasPos = UIDrawContext_ScreenPosToCanvasPos( drawContext, uiContext.vPixelPos );\n    uiContext.bPixelInView = UIDrawContext_ScreenPosInView( drawContext, uiContext.vPixelPos );\n\n    uiContext.vMouseCanvasPos = UIDrawContext_ScreenPosToCanvasPos( drawContext, uiContext.vMousePos );\n    uiContext.bMouseInView = UIDrawContext_ScreenPosInView( drawContext, uiContext.vMousePos );\n}    \n\nUIContext UI_GetContext( vec2 fragCoord, int iData )\n{\n    UIContext uiContext;\n    \n    uiContext.vPixelPos = fragCoord;\n    uiContext.vPixelPos.y = iResolution.y - uiContext.vPixelPos.y;\n    uiContext.vMousePos = iMouse.xy;\n    uiContext.vMousePos.y = iResolution.y - uiContext.vMousePos.y;\n    uiContext.bMouseDown = iMouse.z > 0.0;       \n    \n    vec4 vData0 = LoadVec4( iChannelUI, ivec2(iData,0) );\n    \n    uiContext.bMouseWasDown = (vData0.x > 0.0);\n    \n    uiContext.vFragCoord = ivec2(fragCoord);\n    uiContext.vOutColor = vec4(0.0);\n#ifdef SHADOW_TEST    \n    uiContext.fShadow = 1.0;\n    uiContext.fOutShadow = 1.0f;\n#endif    \n    uiContext.fBlendRemaining = 1.0;\n    \n    uiContext.vOutData = vec4(0.0);\n    if ( int(uiContext.vFragCoord.y) < 2 )\n    {\n        // Initialize data with previous value\n\t    uiContext.vOutData = texelFetch( iChannelUI, uiContext.vFragCoord, 0 );     \n    }\n    uiContext.bHandledClick = false;\n    \n    uiContext.iActiveControl = int(vData0.y);\n    uiContext.vActivePos = vec2(vData0.zw);\n        \n    \n    UIDrawContext rootContext;\n    \n    rootContext.vCanvasSize = iResolution.xy;\n    rootContext.vOffset = vec2(0);\n    rootContext.viewport = Rect( vec2(0), vec2(iResolution.xy) );\n    rootContext.clip = rootContext.viewport;\n\n    UI_SetDrawContext( uiContext, rootContext );\n    \n    uiContext.vWindowOutColor = vec4(0);    \n        \n    if ( iFrame == 0 )\n    {\n        uiContext.bMouseWasDown = false;\n        uiContext.iActiveControl = IDC_NONE;\n    }\n    \n    return uiContext;\n}///\n\nvoid UI_StoreContext( inout UIContext uiContext, int iData )\n{\n    vec4 vData0 = vec4( uiContext.bMouseDown ? 1.0 : 0.0, float(uiContext.iActiveControl), uiContext.vActivePos.x, uiContext.vActivePos.y );\n    StoreVec4( ivec2(iData,0), vData0, uiContext.vOutData, ivec2(uiContext.vFragCoord) );\n}\n\nvec4 UI_GetFinalColor( UIContext uiContext )\n{\n    if ( int(uiContext.vFragCoord.y) < 2 )\n    {\n        return uiContext.vOutData;\n    }\n    \n    if ( uiContext.vOutColor.a >= 0.0 )\n    {\n        // Apply premultiplied alpha.\n        uiContext.vOutColor.rgb *= uiContext.vOutColor.a;\n  \n#ifdef SHADOW_TEST\n        // Shadow composite for premultiplied alpha.\n        // Don't even ask how this works - I'm not sure I know\n        uiContext.vOutColor.rgb *= uiContext.fOutShadow;\n        uiContext.vOutColor.a = 1.0 - ((1.0 - uiContext.vOutColor.a) * uiContext.fOutShadow);\n#endif \t\n    }\n    else\n    {\n#ifdef SHADOW_TEST\n        uiContext.vOutColor.a = -1.0 -uiContext.fOutShadow;\n#else\n        uiContext.vOutColor.a = -2.0;\n#endif \n    }\n    \n    return uiContext.vOutColor;\n}\n\nvoid UI_ComposeWindowLayer( inout UIContext uiContext, float fTransparency, Rect windowRect )\n{\n#ifdef SHADOW_TEST   \n  \tif ( !uiContext.bPixelInView )\n    {\n        return;\n    }\n\n#if 1\n    // cull window?\n    Rect boundsRect = windowRect;\n    RectExpand( boundsRect, vec2( 16.0 ) );\n    if ( !Inside( uiContext.vPixelPos, boundsRect ) )\n    {\n        return;\n    }\n#endif\n    \n    // We need to compose in the parent drawContext for this to work...\n    float fPrevShadow = uiContext.fShadow;\n    \n    vec2 vShadowOffset = vec2( 5.0, 8.0 );\n    float fShadowInner = 3.0;\n\tfloat fShadowOuter = 12.0;\n    \n    Rect shadowRect = windowRect;\n    RectShrink( shadowRect, vec2( fShadowInner ) );\n    \n    vec2 vShadowTestPos = uiContext.vPixelPos - vShadowOffset;\n    vec2 vWindowClosest = clamp( vShadowTestPos, shadowRect.vPos, shadowRect.vPos + shadowRect.vSize );\n\n    float fWindowDist = length( vWindowClosest - vShadowTestPos );\n    \n    float fCurrentShadow = clamp( (fWindowDist) / (fShadowOuter + fShadowInner), 0.0, 1.0 );\n    fCurrentShadow = sqrt( fCurrentShadow );\n    float fShadowTransparency = 0.5;\n\tuiContext.fShadow *= fCurrentShadow * (1.0 - fShadowTransparency) + fShadowTransparency; \n#endif    \n\n  \tif ( !Inside( uiContext.vPixelPos, windowRect ) )\n    {\n        return;\n    }\n\n    float fBlend = uiContext.fBlendRemaining * (1.0f - fTransparency);\n\n#ifdef SHADOW_TEST\n    uiContext.fOutShadow *= fPrevShadow * (fBlend) + (1.0 - fBlend);\n#endif\n    \n    // never blend under \"ID\" window\n    if ( uiContext.vOutColor.a < 0.0 )\n    {\n        return;\n    }\n    \n    if ( uiContext.vWindowOutColor.a < 0.0 )\n    {\n        if ( uiContext.fBlendRemaining == 1.0f )\n        {\n            // Ouput ID without blending\n            uiContext.vOutColor = uiContext.vWindowOutColor;\n            uiContext.fBlendRemaining = 0.0f;\n            return;\n        }\n        else\n        {\n            // blending id under existing color - blend in grey instead of ID\n            uiContext.vWindowOutColor = vec4(0.75, 0.75, 0.75, 1.0);\n        }\n    }\n\n    uiContext.vOutColor += uiContext.vWindowOutColor * fBlend;\n    \n    uiContext.fBlendRemaining *= fTransparency;\n}\n\n///////////////////////////\n// UI Data\n///////////////////////////\n\n#define DIRTY_DATA_MAGIC\t\t\t123.456\n\n// from HSV and HSL by iq - https://www.shadertoy.com/view/lsS3Wc\nconst float eps = 0.0000001;\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 rgb2hsv( in vec3 c)\n{\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x);\n}\n\nstruct UIData_Bool\n{\n    bool bValue;\n};\n    \nUIData_Bool UI_GetDataBool( int iData, bool bDefault )  \n{\n    UIData_Bool dataBool;\n        \n\tvec4 vData0 = LoadVec4( iChannelUI, ivec2(iData,0) );\n    \n    if ( iFrame == 0 )\n    {\n        dataBool.bValue = bDefault;\n    }\n    else\n    {\n        dataBool.bValue =  vData0.x > 0.5;\n    }\n    \n    return dataBool;\n}\n\nvoid UI_StoreDataBool( inout UIContext uiContext, UIData_Bool dataBool, int iData )\n{\n    vec4 vData0 = vec4(0);\n    vData0.x = dataBool.bValue ? 1.0 : 0.0;\n    StoreVec4( ivec2(iData,0), vData0, uiContext.vOutData, ivec2(uiContext.vFragCoord) );            \n}\n\n\nstruct UIData_Value\n{\n    float fValue;\n    float fRangeMin;\n    float fRangeMax;\n    bool bInteger;\n};\n\nUIData_Value UI_GetDataValue( int iData, float fDefaultValue, float fRangeMin, float fRangeMax, bool bInteger )  \n{\n    UIData_Value dataValue;\n    \n    vec4 vData0 = LoadVec4( iChannelUI, ivec2(iData,0) );\n    \n    if ( iFrame == 0 )\n    {\n        dataValue.fValue = fDefaultValue;\n    }\n    else\n    {\n        dataValue.fValue = vData0.x;\n    }\n    \n    dataValue.fRangeMin = fRangeMin;\n    dataValue.fRangeMax = fRangeMax;\n    dataValue.bInteger = bInteger;\n    \n    return dataValue;\n}\n\nvoid UI_StoreDataValue( inout UIContext uiContext, UIData_Value dataValue, int iData )\n{\n    vec4 vData0 = vec4(0);\n    vData0.x = dataValue.fValue;\n    StoreVec4( ivec2(iData,0), vData0, uiContext.vOutData, ivec2(uiContext.vFragCoord) );            \n}\n\nstruct UIData_Color\n{    \n    vec3 vHSV;\n};\n\nUIData_Color UI_GetDataColor( int iData, vec3 cDefaultRGB )  \n{\n    UIData_Color dataColor;\n    \n    vec4 vData1 = LoadVec4( iChannelUI, ivec2(iData,1) );\n    \n    if ( iFrame == 0 )\n    {\n        dataColor.vHSV = rgb2hsv( cDefaultRGB );\n    }\n    else\n    {\n        dataColor.vHSV = vData1.rgb;\n    }\n    \n    return dataColor;\n}\n\nvoid UI_StoreDataColor( inout UIContext uiContext, UIData_Color dataColor, int iData )\n{\n    vec4 vData0 = vec4(0);\n    vData0.rgb = hsv2rgb( dataColor.vHSV );\n        \n    StoreVec4( ivec2(iData,0), vData0, uiContext.vOutData, ivec2(uiContext.vFragCoord) );            \n\n    vec4 vData1 = vec4(0);\n    vData1.rgb = dataColor.vHSV;\n        \n    StoreVec4( ivec2(iData,1), vData1, uiContext.vOutData, ivec2(uiContext.vFragCoord) );            \n}\n\nPrintState UI_PrintState_Init( inout UIContext uiContext, LayoutStyle style, vec2 vPosition )\n{\n    vec2 vCanvasPos = uiContext.vPixelCanvasPos;\n    \n    PrintState state = PrintState_InitCanvas( vCanvasPos, vec2(1.0) );\n    MoveTo( state, vPosition + UIStyle_FontPadding() );\n\tPrintBeginNextLine(state, style);\n\n\treturn state;\n}\n\nRect UI_GetFontRect( PrintState state, LayoutStyle style )\n{\n    Rect rect;\n    rect = GetFontRect( state, style, true );\n    vec2 vExpand = UIStyle_FontPadding();\n    vExpand.y += style.vSize.y * style.fLineGap;\n    RectExpand( rect, vExpand );\n\treturn rect;\n}\n\nvoid UI_RenderFont( inout UIContext uiContext, PrintState state, LayoutStyle style, RenderStyle renderStyle )\n{\n    if( uiContext.bPixelInView )\n    {\n        RenderFont( state, style, renderStyle, uiContext.vWindowOutColor.rgb );\n    }\n}\n\nvoid UILayout_SetControlRectFromText( inout UILayout uiLayout, PrintState state, LayoutStyle style )\n{\n    UILayout_SetControlRect( uiLayout, UI_GetFontRect( state, style ) );\n}\n\nstruct UIPanelState\n{\n    UIDrawContext parentDrawContext;\n\tvec4 vParentWindowColor;\n};\n    \nvoid UI_PanelBegin( inout UIContext uiContext, inout UIPanelState panelState )\n{\n    panelState.parentDrawContext = uiContext.drawContext;\n    panelState.vParentWindowColor = uiContext.vWindowOutColor;\n}\n\nvoid UI_PanelEnd( inout UIContext uiContext, inout UIPanelState panelState )\n{\n    if ( !uiContext.bPixelInView )\n    {\n        // Restore parent window color if outside view\n\t    uiContext.vWindowOutColor = panelState.vParentWindowColor;    \n    }\n\n    UI_SetDrawContext( uiContext, panelState.parentDrawContext );\n}\n\n#define FLAG_SET(X,F) (( X & F ) != 0u)\n    \nconst uint\tWINDOW_CONTROL_FLAG_CLOSE_BOX \t\t= 1u,\n\t\t\tWINDOW_CONTROL_FLAG_MINIMIZE_BOX\t= 2u,\n\t\t\tWINDOW_CONTROL_FLAG_RESIZE_WIDGET \t= 4u,\n\t\t\tWINDOW_CONTROL_FLAG_TITLE_BAR \t\t= 8u;\n    \nstruct UIWindowDesc\n{\n    Rect initialRect;\n    bool bStartMinimized;\n    bool bStartClosed;\n    \n    uint uControlFlags;    \n    vec2 vMaxSize;\n};\n\n\nstruct UIWindowState\n{\n    UIPanelState panelState;\n\n    Rect rect;\n    bool bMinimized;\n    bool bClosed;\n    \n    uint uControlFlags;    \n    vec2 vMaxSize;\n    int iControlId;\n\n    Rect drawRect;\n};\n\n\nUIWindowState UI_GetWindowState( UIContext uiContext, int iControlId, int iData, UIWindowDesc desc )\n{\n    UIWindowState window;    \n    \n    vec4 vData0 = LoadVec4( iChannelUI, ivec2(iData,0) );\n        \n    window.rect = Rect( vData0.xy, vData0.zw );\n    \n    vec4 vData1 = LoadVec4( iChannelUI, ivec2(iData,1) );\n    \n    window.bMinimized = (vData1.x > 0.0);    \n    window.bClosed = (vData1.y > 0.0);    \n    \n    // Clamp window position so title bar is always on canvas\n\tvec2 vSafeMin = vec2(24.0);        \n\tvec2 vSafeMax = vec2(32.0);        \n    vec2 vPosMin = vec2( -window.rect.vSize.x + vSafeMin.x, -vSafeMin.y);//vec2( -window.rect.vSize.x, 0.0) + 24.0, -24.0 );\n    vec2 vPosMax = uiContext.drawContext.vCanvasSize - vSafeMax;\n    window.rect.vPos = clamp( window.rect.vPos, vPosMin, vPosMax );\n    \n    if ( iFrame == 0 || vData1.z != DIRTY_DATA_MAGIC)\n    {\n        window.rect = desc.initialRect;\n        window.bMinimized = desc.bStartMinimized;\n\t    window.bClosed = desc.bStartClosed;\n    }       \n    \n    window.uControlFlags = desc.uControlFlags;\n    window.vMaxSize = desc.vMaxSize;\n    \n    window.iControlId = iControlId;\n        \n    return window;\n}\n\nvoid UI_StoreWindowState( inout UIContext uiContext, UIWindowState window, int iData )\n{    \n    vec4 vData0;\n    vData0.xy = window.rect.vPos;\n    vData0.zw = window.rect.vSize;\n    \n    StoreVec4( ivec2(iData,0), vData0, uiContext.vOutData, ivec2(uiContext.vFragCoord) );        \n\n    vec4 vData1;\n    \n    vData1.x = window.bMinimized ? 1.0f : 0.0f;\n    vData1.y = window.bClosed ? 1.0f : 0.0f;\n    vData1.z = DIRTY_DATA_MAGIC;\n    vData1.w = 0.0f;\n\n    StoreVec4( ivec2(iData,1), vData1, uiContext.vOutData, ivec2(uiContext.vFragCoord) );        \n}\n\nvoid UI_WriteCanvasPos( inout UIContext uiContext, int iControlId )        \n{\n\tif (!uiContext.bPixelInView)\n        return;\n    Rect rect = Rect( vec2(0), uiContext.drawContext.vCanvasSize );\n    DrawRect( uiContext.vPixelCanvasPos, rect, vec4(uiContext.vPixelCanvasPos, float(iControlId), -1.0 ), uiContext.vWindowOutColor );\n}    \n\nvoid UI_WriteCanvasUV( inout UIContext uiContext, int iControlId )        \n{\n\tif (!uiContext.bPixelInView)\n        return;\n    Rect rect = Rect( vec2(0), uiContext.drawContext.vCanvasSize );\n    DrawRect( uiContext.vPixelCanvasPos, rect, vec4(uiContext.vPixelCanvasPos / uiContext.drawContext.vCanvasSize, float(iControlId), -1.0 ), uiContext.vWindowOutColor );\n}\n\nvoid UI_DrawButton( inout UIContext uiContext, bool bActive, bool bMouseOver, Rect buttonRect )\n{\n\tif (!uiContext.bPixelInView)\n        return;\n    \n    if ( bActive && bMouseOver )\n    {\n#ifdef NEW_THEME\n    \tDrawBorderRect( uiContext.vPixelCanvasPos, buttonRect, cButtonActive, uiContext.vWindowOutColor );\n#else\n    \tDrawBorderIndent( uiContext.vPixelCanvasPos, buttonRect, uiContext.vWindowOutColor );\n#endif        \n    }\n    else\n    {\n#ifdef NEW_THEME\n    \tDrawBorderRect( uiContext.vPixelCanvasPos, buttonRect, cButtonInactive, uiContext.vWindowOutColor );\n#else\n    \tDrawBorderOutdent( uiContext.vPixelCanvasPos, buttonRect, uiContext.vWindowOutColor );\n#endif        \n    }\n}\n\nbool UI_ProcessButton( inout UIContext uiContext, int iControlId, Rect buttonRect )\n{    \n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, buttonRect ) && uiContext.bMouseInView;\n    \n    bool bButtonPressed = false;\n    \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n            if ( bMouseOver )\n            {\n                bButtonPressed = true;\n            }\n        }\n    }\n\n    bool bActive = (uiContext.iActiveControl == iControlId);\n    \n    UI_DrawButton( uiContext, bActive, bMouseOver, buttonRect );    \n        \n    return bButtonPressed;\n}\n\nvoid UI_DrawCheckbox( inout UIContext uiContext, bool bActive, bool bMouseOver, bool bChecked, Rect checkBoxRect )\n{\n\tif (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, checkBoxRect ))\n        return;\n    \n    uiContext.vWindowOutColor = vec4(1.0);\n    \n    if ( bActive && bMouseOver )\n    {\n        uiContext.vWindowOutColor = vec4(0.85,0.85,0.85,1.0);\n    }\n\n#ifdef NEW_THEME\n    DrawBorderRect( uiContext.vPixelCanvasPos, checkBoxRect, cCheckboxOutline, uiContext.vWindowOutColor );\n#else    \n    DrawBorderIndent( uiContext.vPixelCanvasPos, checkBoxRect, uiContext.vWindowOutColor );\n#endif    \n\n    Rect smallerRect = checkBoxRect;\n    RectShrink( smallerRect, vec2(6.0));\n\n    if ( bChecked )\n    {\n        vec4 vCheckColor = vec4(0.0, 0.0, 0.0, 1.0);\n        DrawLine( uiContext.vPixelCanvasPos, smallerRect.vPos+ smallerRect.vSize * vec2(0.0, 0.75), smallerRect.vPos+ smallerRect.vSize * vec2(0.25, 1.0), 2.0f, vCheckColor, uiContext.vWindowOutColor );\n        DrawLine( uiContext.vPixelCanvasPos, smallerRect.vPos+ smallerRect.vSize * vec2(0.25, 1.0), smallerRect.vPos+ smallerRect.vSize * vec2(1.0, 0.25), 2.0f, vCheckColor, uiContext.vWindowOutColor );\n    }\n}\n\nvoid UI_ProcessCheckbox( inout UIContext uiContext, int iControlId, inout UIData_Bool data, Rect checkBoxRect )\n{    \n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, checkBoxRect ) && uiContext.bMouseInView;\n    \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n            if ( bMouseOver )\n            {\n                data.bValue = !data.bValue;\n            }\n        }\n    }\n    \n    bool bActive = (uiContext.iActiveControl == iControlId);\n    \n    UI_DrawCheckbox( uiContext, bActive, bMouseOver, data.bValue, checkBoxRect );    \n}\n\nvoid UI_DrawSliderX( inout UIContext uiContext, bool bActive, bool bMouseOver, float fPosition, Rect sliderRect, float fHandleSize, bool scrollbarStyle )\n{\n\tif (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, sliderRect ))\n        return;\n    \n    Rect horizLineRect;\n    \n    horizLineRect = sliderRect;\n    if (!scrollbarStyle)\n    {\n\t    float fMid = sliderRect.vPos.y + sliderRect.vSize.y * 0.5;\n    \thorizLineRect.vPos.y = fMid - 2.0;\n    \thorizLineRect.vSize.y = 4.0;\n    }\n\n#ifdef NEW_THEME    \n    DrawBorderRect( uiContext.vPixelCanvasPos, horizLineRect, cSliderLineCol, uiContext.vWindowOutColor );\n#else    \n    DrawBorderIndent( uiContext.vPixelCanvasPos, horizLineRect, uiContext.vWindowOutColor );\n#endif\n\n    float fSlideMin = sliderRect.vPos.x + fHandleSize * 0.5f;\n    float fSlideMax = sliderRect.vPos.x + sliderRect.vSize.x - fHandleSize * 0.5f;\n\n    float fDistSlider = (fSlideMin + (fSlideMax-fSlideMin) * fPosition);\n\n    Rect handleRect;\n\n    handleRect = sliderRect;\n    handleRect.vPos.x = fDistSlider - fHandleSize * 0.5f;\n    handleRect.vSize.x = fHandleSize;\n\n    vec4 handleColor = vec4(0.75, 0.75, 0.75, 1.0);\n    if ( bActive )\n    {\n        handleColor.rgb += 0.1;\n    }       \n    \n    // highlight\n#ifdef NEW_THEME     \n    if ( (uiContext.vPixelCanvasPos.y - handleRect.vPos.y) < handleRect.vSize.y * 0.3 )\n    {\n        handleColor.rgb += 0.05;\n    }\n#endif    \n\n    DrawRect( uiContext.vPixelCanvasPos, handleRect, handleColor, uiContext.vWindowOutColor );\n\n#ifdef NEW_THEME   \n    DrawBorderRect( uiContext.vPixelCanvasPos, handleRect, cSliderHandleOutlineCol, uiContext.vWindowOutColor );\n#else    \n    DrawBorderOutdent( uiContext.vPixelCanvasPos, handleRect, uiContext.vWindowOutColor );\n#endif    \n}\n\nvoid UI_DrawSliderY( inout UIContext uiContext, bool bActive, bool bMouseOver, float fPosition, Rect sliderRect, float fHandleSize, bool scrollbarStyle )\n{\n\tif (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, sliderRect ))\n        return;\n    \n    Rect horizLineRect;\n    \n    horizLineRect = sliderRect;\n    if (!scrollbarStyle)\n    {\n\t    float fMid = sliderRect.vPos.x + sliderRect.vSize.x * 0.5;\n    \thorizLineRect.vPos.x = fMid - 2.0;\n    \thorizLineRect.vSize.x = 4.0;\n    }\n\n#ifdef NEW_THEME    \n    DrawBorderRect( uiContext.vPixelCanvasPos, horizLineRect, cSliderLineCol, uiContext.vWindowOutColor );\n#else    \n    DrawBorderIndent( uiContext.vPixelCanvasPos, horizLineRect, uiContext.vWindowOutColor );\n#endif    \n\n    float fSlideMin = sliderRect.vPos.y + fHandleSize * 0.5f;\n    float fSlideMax = sliderRect.vPos.y + sliderRect.vSize.y - fHandleSize * 0.5f;\n\n    float fDistSlider = (fSlideMin + (fSlideMax-fSlideMin) * fPosition);\n\n    Rect handleRect;\n\n    handleRect = sliderRect;\n    handleRect.vPos.y = fDistSlider - fHandleSize * 0.5f;\n    handleRect.vSize.y = fHandleSize;\n\n    vec4 handleColor = vec4(0.75, 0.75, 0.75, 1.0);\n    if ( bActive )\n    {\n        handleColor.rgb += 0.1;\n    }\n    \n    // highlight\n#ifdef NEW_THEME     \n    if ( (uiContext.vPixelCanvasPos.y - handleRect.vPos.y) < handleRect.vSize.y * 0.3 )\n    {\n        handleColor.rgb += 0.05;\n    }\n#endif    \n\n    DrawRect( uiContext.vPixelCanvasPos, handleRect, handleColor, uiContext.vWindowOutColor );\n#ifdef NEW_THEME   \n    DrawBorderRect( uiContext.vPixelCanvasPos, handleRect, cSliderHandleOutlineCol, uiContext.vWindowOutColor );\n#else     \n    DrawBorderOutdent( uiContext.vPixelCanvasPos, handleRect, uiContext.vWindowOutColor );\n#endif    \n}\n\nvoid UI_ProcessSlider( inout UIContext uiContext, int iControlId, inout UIData_Value data, Rect sliderRect )\n{    \n    float fHandleSize = 8.0;\n    \n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, sliderRect ) && uiContext.bMouseInView;\n    \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        float fSlidePosMin = sliderRect.vPos.x + fHandleSize * 0.5f;\n        float fSlidePosMax = sliderRect.vPos.x + sliderRect.vSize.x - fHandleSize * 0.5f;\n        float fPosition = (uiContext.vMouseCanvasPos.x - fSlidePosMin) / (fSlidePosMax - fSlidePosMin);\n        fPosition = clamp( fPosition, 0.0f, 1.0f );\n        data.fValue = data.fRangeMin + fPosition * (data.fRangeMax - data.fRangeMin);\n        if ( data.bInteger )\n        {\n            data.fValue = floor( data.fValue + 0.5 );\n        }\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }\n        \n    bool bActive = (uiContext.iActiveControl == iControlId);\n    float fPosition = (data.fValue - data.fRangeMin) / (data.fRangeMax - data.fRangeMin);\n    \n    UI_DrawSliderX( uiContext, bActive, bMouseOver, fPosition, sliderRect, fHandleSize, false );    \n}\n\nvoid UI_ProcessScrollbarX( inout UIContext uiContext, int iControlId, inout UIData_Value data, Rect sliderRect, float fHandleSize )\n{    \n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, sliderRect ) && uiContext.bMouseInView;\n        \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        float fSlidePosMin = sliderRect.vPos.x + fHandleSize * 0.5f;\n        float fSlidePosMax = sliderRect.vPos.x + sliderRect.vSize.x - fHandleSize * 0.5f;\n        float fPosition = (uiContext.vMouseCanvasPos.x - fSlidePosMin) / (fSlidePosMax - fSlidePosMin);\n        fPosition = clamp( fPosition, 0.0f, 1.0f );\n        data.fValue = data.fRangeMin + fPosition * (data.fRangeMax - data.fRangeMin);\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }\n        \n    bool bActive = (uiContext.iActiveControl == iControlId);\n    float fPosition = (data.fValue - data.fRangeMin) / (data.fRangeMax - data.fRangeMin);\n    \n    UI_DrawSliderX( uiContext, bActive, bMouseOver, fPosition, sliderRect, fHandleSize, true );    \n}\n\nvoid UI_ProcessScrollbarY( inout UIContext uiContext, int iControlId, inout UIData_Value data, Rect sliderRect, float fHandleSize )\n{    \n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, sliderRect ) && uiContext.bMouseInView;\n    \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        float fSlidePosMin = sliderRect.vPos.y + fHandleSize * 0.5f;\n        float fSlidePosMax = sliderRect.vPos.y + sliderRect.vSize.y - fHandleSize * 0.5f;\n        float fPosition = (uiContext.vMouseCanvasPos.y - fSlidePosMin) / (fSlidePosMax - fSlidePosMin);\n        fPosition = clamp( fPosition, 0.0f, 1.0f );\n        data.fValue = data.fRangeMin + fPosition * (data.fRangeMax - data.fRangeMin);\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }\n        \n    bool bActive = (uiContext.iActiveControl == iControlId);\n    float fPosition = (data.fValue - data.fRangeMin) / (data.fRangeMax - data.fRangeMin);\n    \n    UI_DrawSliderY( uiContext, bActive, bMouseOver, fPosition, sliderRect, fHandleSize, true );    \n}\n\nvoid UI_DrawColorPickerSV( inout UIContext uiContext, bool bActive, vec3 vHSV, Rect pickerRect )\n{\n\tif (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, pickerRect ))\n        return;\n    \n    vec2 vCurrPixelPos = (uiContext.vPixelCanvasPos - pickerRect.vPos) / pickerRect.vSize;\n    vCurrPixelPos.y = 1.0f - vCurrPixelPos.y;\n    vec3 vHSVCurr = vHSV;\n    vHSVCurr.yz = vCurrPixelPos;\n\n    uiContext.vWindowOutColor = vec4( hsv2rgb( vHSVCurr ), 1.0 );\n    \n    vec2 vSelectedPos = vHSV.yz;\n    vSelectedPos.y = 1.0f - vSelectedPos.y;\n    vSelectedPos = vSelectedPos * pickerRect.vSize + pickerRect.vPos;\n        \n    float l = length( vSelectedPos - uiContext.vPixelCanvasPos );\n    float d = l - 3.0;\n    d = min(d, 5.0 - l);\n    if ( bActive )\n    {\n        float d2 = l - 5.0;\n    \td2 = min(d2, 7.0 - l);\n\t    d = max(d, d2);\n    }\n    \n    float fBlend = clamp(d, 0.0, 1.0);\n    \n    uiContext.vWindowOutColor.rgb = mix(uiContext.vWindowOutColor.rgb, vec3(1.0) - uiContext.vWindowOutColor.rgb, fBlend);\n}\n\nvoid UI_ProcessColorPickerSV( inout UIContext uiContext, int iControlId, inout UIData_Color data, Rect pickerRect )\n{\n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, pickerRect ) && uiContext.bMouseInView;\n    \n    vec3 vHSV = data.vHSV;\n    \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        vec2 vPos = (uiContext.vMouseCanvasPos - pickerRect.vPos) / pickerRect.vSize;\n        vPos = clamp( vPos, vec2(0), vec2(1) );\n        \n        vHSV.yz = vPos;\n        vHSV.z = 1.0f - vHSV.z;\n        \n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }\n    \n    data.vHSV = vHSV;\n    \n    bool bActive = (uiContext.iActiveControl == iControlId);\n    \n    UI_DrawColorPickerSV( uiContext, bActive, vHSV, pickerRect );    \n}\n\nvoid UI_DrawColorPickerH( inout UIContext uiContext, bool bActive, vec3 vHSV, Rect pickerRect )\n{\n\tif (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, pickerRect ))\n        return;\n    \n    vec2 vCurrPixelPos = (uiContext.vPixelCanvasPos - pickerRect.vPos) / pickerRect.vSize;\n    vec3 vHSVCurr = vHSV;\n    vHSVCurr.x = vCurrPixelPos.y;\n    vHSVCurr.yz = vec2(1.0, 1.0);\n    \n    float fSelectedPos = vHSV.x * pickerRect.vSize.y + pickerRect.vPos.y;\n\n\tuiContext.vWindowOutColor = vec4( hsv2rgb( vHSVCurr ), 1.0 );\n        \n    float l = length( fSelectedPos - uiContext.vPixelCanvasPos.y );\n    float d = l - 1.0;\n    d = min(d, 5.0 - l);\n    if ( bActive )\n    {\n        float d2 = l - 4.0;\n    \td2 = min(d2, 6.0 - l);\n\t    d = max(d, d2);\n    }\n    \n    float fBlend = clamp(d, 0.0, 1.0);\n    \n    uiContext.vWindowOutColor.rgb = mix(uiContext.vWindowOutColor.rgb, vec3(0.5), fBlend);    \n}\n\nvoid UI_ProcessColorPickerH( inout UIContext uiContext, int iControlId, inout UIData_Color data, Rect pickerRect )\n{\n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, pickerRect ) && uiContext.bMouseInView;\n    \n    vec3 vHSV = data.vHSV;\n    \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        float fPos = (uiContext.vMouseCanvasPos.y - pickerRect.vPos.y) / pickerRect.vSize.y;\n        fPos = clamp( fPos, 0.0f, 1.0f );\n        \n        vHSV.x = fPos;\n        \n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }\n    \n    data.vHSV = vHSV;\n    \n    bool bActive = (uiContext.iActiveControl == iControlId);\n    \n    UI_DrawColorPickerH( uiContext, bActive, vHSV, pickerRect );\n}\n\nbool UI_DrawWindowCloseBox( inout UIContext uiContext, Rect closeBoxRect )\n{\n\tif (!uiContext.bPixelInView || !Inside( uiContext.vPixelCanvasPos, closeBoxRect ))\n        return false;\n    \n    vec2 vCrossPos = closeBoxRect.vPos + closeBoxRect.vSize * 0.5;        \n    vec2 vCrossSize = closeBoxRect.vSize * 0.5 * 0.4;\n    vec4 crossColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec2 vCrossSizeFlip = vCrossSize * vec2(1.0, -1.0);\n    \n    DrawLine( uiContext.vPixelCanvasPos, vCrossPos - vCrossSize, vCrossPos + vCrossSize, 2.0f, crossColor, uiContext.vWindowOutColor );\n    DrawLine( uiContext.vPixelCanvasPos, vCrossPos - vCrossSizeFlip, vCrossPos + vCrossSizeFlip, 2.0f, crossColor, uiContext.vWindowOutColor );\n    \n    return true;\n}\n\nbool UI_ProcessWindowCloseBox( inout UIContext uiContext, inout UIWindowState window, int iControlId, Rect closeBoxRect )\n{\n    bool bPressed = UI_ProcessButton( uiContext, iControlId, closeBoxRect );\n    \n    if ( bPressed )\n    {\n \t\twindow.bClosed = true;\n    }\n\n    bool bActive = (uiContext.iActiveControl == iControlId);\n    \n    return UI_DrawWindowCloseBox( uiContext, closeBoxRect );\n}\n    \nbool UI_DrawWindowMinimizeWidget( inout UIContext uiContext, bool bMinimized, Rect minimizeBoxRect )\n{\n\tif (!uiContext.bPixelInView || !Inside( uiContext.vPixelCanvasPos, minimizeBoxRect ))\n        return false;\n    \n    vec2 vArrowPos = minimizeBoxRect.vPos + minimizeBoxRect.vSize * 0.5;        \n    vec2 vArrowSize = minimizeBoxRect.vSize * 0.25;\n    vec4 arrowColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if ( !bMinimized )\n    {\n        DrawLine( uiContext.vPixelCanvasPos, vArrowPos + vec2(-1.0, -0.5) * vArrowSize, vArrowPos + vec2(0.0, 0.5) * vArrowSize, 2.0f, arrowColor, uiContext.vWindowOutColor );\n        DrawLine( uiContext.vPixelCanvasPos, vArrowPos + vec2( 1.0, -0.5) * vArrowSize, vArrowPos + vec2(0.0, 0.5) * vArrowSize, 2.0f, arrowColor, uiContext.vWindowOutColor );\n    }\n    else\n    {\n        DrawLine( uiContext.vPixelCanvasPos, vArrowPos + vec2( 0.5, 0.0 )* vArrowSize, vArrowPos + vec2(-0.5, -1.0) * vArrowSize, 2.0f, arrowColor, uiContext.vWindowOutColor );\n        DrawLine( uiContext.vPixelCanvasPos, vArrowPos + vec2( 0.5, 0.0 )* vArrowSize, vArrowPos + vec2(-0.5,  1.0) * vArrowSize, 2.0f, arrowColor, uiContext.vWindowOutColor );\n    }    \n    \n    return true;\n}\n\nbool UI_ProcessWindowMinimizeWidget( inout UIContext uiContext, inout UIWindowState window, int iControlId, Rect minimizeBoxRect )\n{    \n    bool bPressed = UI_ProcessButton( uiContext, iControlId, minimizeBoxRect );\n    \n    if ( bPressed )\n    {\n \t\twindow.bMinimized = !window.bMinimized;        \n    }\n\n    bool bActive = (uiContext.iActiveControl == iControlId);\n    \n    return UI_DrawWindowMinimizeWidget( uiContext, window.bMinimized, minimizeBoxRect );\n}\n\nvoid UI_ProcessScrollbarPanelBegin( inout UIContext uiContext, inout UIPanelState scrollbarState, int iControlId, int iData, Rect scrollbarPanelRect, vec2 vScrollbarCanvasSize )\n{\n    float styleSize = UIStyle_ScrollBarSize();\n    \n\tbool bScrollbarHorizontal = (scrollbarPanelRect.vSize.x < vScrollbarCanvasSize.x);\n    if ( bScrollbarHorizontal )\n    {        \n        scrollbarPanelRect.vSize.y -= styleSize;\n    }\n\n    bool bScrollbarVertical = (scrollbarPanelRect.vSize.y < vScrollbarCanvasSize.y);\n    if ( bScrollbarVertical )\n    {\n        scrollbarPanelRect.vSize.x -= styleSize;\n    }\n\n    // Adding a vertical scrollbar may mean we now need a horizontal one\n    if ( !bScrollbarHorizontal )\n    {\n        bScrollbarHorizontal = (scrollbarPanelRect.vSize.x < vScrollbarCanvasSize.x);\n        if ( bScrollbarHorizontal )\n        {        \n            scrollbarPanelRect.vSize.y -= styleSize;\n        }\n    }\n    \n    // Todo : Force enable or disable ?\n\n\tvec4 vData0 = LoadVec4( iChannelUI, ivec2(iData,0) );   \n        \n    UIData_Value scrollValueX;\n    scrollValueX.fRangeMin = 0.0;\n    scrollValueX.fRangeMax = max(0.0, vScrollbarCanvasSize.x - scrollbarPanelRect.vSize.x);\n        \n    UIData_Value scrollValueY;\n    scrollValueY.fRangeMin = 0.0;\n    scrollValueY.fRangeMax = max(0.0, vScrollbarCanvasSize.y - scrollbarPanelRect.vSize.y);\n    \n    if ( iFrame == 0 || vData0.z != DIRTY_DATA_MAGIC )\n    {\n        scrollValueX.fValue = 0.0;\n        scrollValueY.fValue = 0.0;\n    }\n    else\n    {\n        scrollValueX.fValue = vData0.x;\n        scrollValueY.fValue = vData0.y;\n    }    \n    \n    scrollValueX.fValue = clamp( scrollValueX.fValue, scrollValueX.fRangeMin, scrollValueX.fRangeMax );\n    scrollValueY.fValue = clamp( scrollValueY.fValue, scrollValueY.fRangeMin, scrollValueY.fRangeMax );\n    \n    if ( bScrollbarHorizontal )\n    {\n        Rect scrollbarRect;\n        scrollbarRect.vPos = scrollbarPanelRect.vPos;\n        scrollbarRect.vPos.y += scrollbarPanelRect.vSize.y;\n        scrollbarRect.vSize.x = scrollbarPanelRect.vSize.x;\n        scrollbarRect.vSize.y = styleSize;\n        \n        float fHandleSize = scrollbarRect.vSize.x * (scrollbarPanelRect.vSize.x / vScrollbarCanvasSize.x);\n\n        if ( uiContext.bPixelInView ) \n        {\n\t        DrawRect( uiContext.vPixelCanvasPos, scrollbarRect, vec4(0.6, 0.6, 0.6, 1.0), uiContext.vWindowOutColor );\n        }        \n        UI_ProcessScrollbarX( uiContext, iControlId, scrollValueX, scrollbarRect, fHandleSize );\n    }\n        \n    if ( bScrollbarVertical )\n    {        \n        Rect scrollbarRect;\n        scrollbarRect.vPos = scrollbarPanelRect.vPos;\n        scrollbarRect.vPos.x += scrollbarPanelRect.vSize.x;\n        scrollbarRect.vSize.x = styleSize;\n        scrollbarRect.vSize.y = scrollbarPanelRect.vSize.y;\n        \n        float fHandleSize = scrollbarRect.vSize.y * (scrollbarPanelRect.vSize.y / vScrollbarCanvasSize.y);\n        \n        if ( uiContext.bPixelInView ) \n        {\n\t        DrawRect( uiContext.vPixelCanvasPos, scrollbarRect, vec4(0.6, 0.6, 0.6, 1.0), uiContext.vWindowOutColor );\n        }\n        \n        UI_ProcessScrollbarY( uiContext, iControlId + 1000, scrollValueY, scrollbarRect, fHandleSize );\n    }\n    \n    if ( bScrollbarHorizontal && bScrollbarVertical ) \n    {\n        Rect cornerRect;\n        cornerRect.vPos = scrollbarPanelRect.vPos;\n        cornerRect.vPos += scrollbarPanelRect.vSize;\n        cornerRect.vSize = vec2(styleSize);\n        \n        if ( uiContext.bPixelInView ) \n        {\n            DrawRect( uiContext.vPixelCanvasPos, cornerRect, vec4(cScrollPanelCorner, 1.0), uiContext.vWindowOutColor );\n#ifdef NEW_THEME  \n        \tDrawBorderRect( uiContext.vPixelCanvasPos, cornerRect, cScrollPanelCornerOutline, uiContext.vWindowOutColor );\n#else            \n        \tDrawBorderIndent( uiContext.vPixelCanvasPos, cornerRect, uiContext.vWindowOutColor );\n#endif            \n        }\n    }\n\n    UI_PanelBegin( uiContext, scrollbarState );    \n    \n    vData0.x = scrollValueX.fValue;\n    vData0.y = scrollValueY.fValue;\n    vData0.z = DIRTY_DATA_MAGIC;\n    StoreVec4( ivec2(iData,0), vData0, uiContext.vOutData, ivec2(uiContext.vFragCoord) );    \n        \n            \n    UIDrawContext scrollbarPanelContextDesc = UIDrawContext_SetupFromRect( scrollbarPanelRect );\n    scrollbarPanelContextDesc.vCanvasSize = vScrollbarCanvasSize;\n    scrollbarPanelContextDesc.vOffset = vec2(scrollValueX.fValue, scrollValueY.fValue);\n\n    UIDrawContext scrollbarPanelContext = UIDrawContext_TransformChild( scrollbarState.parentDrawContext, scrollbarPanelContextDesc );\n    UI_SetDrawContext( uiContext, scrollbarPanelContext );\n}\n\nvoid UI_ProcessScrollbarPanelEnd( inout UIContext uiContext, inout UIPanelState scrollbarState )\n{\n    UI_PanelEnd( uiContext, scrollbarState );    \n}\n\n\nvoid UIStyle_GetFontStyleTitle( inout LayoutStyle style, inout RenderStyle renderStyle );\nvoid PrintWindowTitle( inout PrintState state, LayoutStyle style, int controlId );\n\nvec2 UI_WindowGetTitleBarSize( UIContext uiContext, inout UIWindowState window )\n{\n    return vec2(window.drawRect.vSize.x - UIStyle_WindowBorderSize().x * 2.0, UIStyle_TitleBarHeight() );\n}\n\nvoid UI_DrawWindowTitleBar( inout UIContext uiContext, bool bActive, Rect titleBarRect, inout UIWindowState window )\n{   \n\tif (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, titleBarRect ))\n        return;\n    \n    vec4 colorA = vec4(cTitleBarA, 1.0);\n    vec4 colorB = vec4(cTitleBarB, 1.0);\n       \n    if ( bActive )\n    {\n        colorA.rgb = cTitleBarAActive;\n        colorB.rgb = cTitleBarBActive;\n    }\n\n    float t = (uiContext.vPixelCanvasPos.x - titleBarRect.vPos.x) / 512.0;\n    t = clamp( t, 0.0f, 1.0f );\n    uiContext.vWindowOutColor = mix( colorA, colorB, t );\n    \n    {\n        LayoutStyle style;\n        RenderStyle renderStyle;\n        UIStyle_GetFontStyleTitle( style, renderStyle );\n\n        vec2 vTextOrigin = vec2(0);\n        if ( FLAG_SET(window.uControlFlags, WINDOW_CONTROL_FLAG_MINIMIZE_BOX) )\n        {\n        \tvTextOrigin.x += titleBarRect.vSize.y;\n        }\n        \n        PrintState state = UI_PrintState_Init( uiContext, style, vTextOrigin );    \n        PrintWindowTitle( state, style, window.iControlId );    \n        RenderFont( state, style, renderStyle, uiContext.vWindowOutColor.rgb );\n    }\n}\n\nbool UI_ProcessWindowTitleBar( inout UIContext uiContext, inout UIWindowState window )\n{\n    int iWindowTitleBarControlId = window.iControlId;\n    int iWindowMinimizeControlId = window.iControlId + 1000;\n    int iWindowCloseControlId = window.iControlId + 3000;\n    Rect titleBarRect = Rect( vec2(0.0), UI_WindowGetTitleBarSize( uiContext, window ) );\n    \n    bool bRenderedWidget = false;\n    if ( FLAG_SET(window.uControlFlags, WINDOW_CONTROL_FLAG_MINIMIZE_BOX) )\n    {\n        Rect minimizeBoxRect = Rect( vec2(0.0), vec2(titleBarRect.vSize.y) );\n        RectShrink( minimizeBoxRect, vec2(4.0) );\n        \n    \tbRenderedWidget = UI_ProcessWindowMinimizeWidget( uiContext, window, iWindowMinimizeControlId, minimizeBoxRect );\n    }\n\n    if ( FLAG_SET(window.uControlFlags, WINDOW_CONTROL_FLAG_CLOSE_BOX) )\n    {\n        Rect closeBoxRect = Rect( vec2(0.0), vec2(titleBarRect.vSize.y) ); \n        closeBoxRect.vPos.x = titleBarRect.vSize.x - closeBoxRect.vSize.x;\n        RectShrink( closeBoxRect, vec2(4.0) );\n        \n        if( UI_ProcessWindowCloseBox( uiContext, window, iWindowCloseControlId, closeBoxRect ) )\n        {\n            bRenderedWidget = true;\n        }\n    }\n            \n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, titleBarRect ) && uiContext.bMouseInView;\n        \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iWindowTitleBarControlId;\n            uiContext.vActivePos = window.rect.vPos - uiContext.vMousePos;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iWindowTitleBarControlId )\n    {\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }    \n    \n    bool bActive = (uiContext.iActiveControl == iWindowTitleBarControlId);\n    \n    if ( bActive )\n    {\n        window.rect.vPos = uiContext.vMousePos + uiContext.vActivePos;\n    }   \n    \n    if (!bRenderedWidget)\n    {\n    \tUI_DrawWindowTitleBar( uiContext, bActive, titleBarRect, window );\n    }\n    \n    return Inside( uiContext.vPixelCanvasPos, titleBarRect );\n}\n\nbool ScreenPosInResizeWidget( inout UIContext uiContext, vec2 vCorner, float fControlSize, vec2 vTestPos )\n{\n    vec2 vTestCanvasPos = UIDrawContext_ScreenPosToCanvasPos( uiContext.drawContext, vTestPos );\n    vec2 vOffset = vTestCanvasPos - vCorner + vec2( fControlSize, 0.0 );\n    bool bInCorner = (vOffset.x + vOffset.y) > 0.0;\n    \n    return bInCorner;\n}\n\nvoid UI_ProcessWindowResizeWidget( inout UIContext uiContext, inout UIWindowState window, int iControlId )\n{\n    vec2 vCorner = uiContext.drawContext.vCanvasSize;\n    float fControlSize = 24.0;\n    \n    bool bMouseOver = ScreenPosInResizeWidget( uiContext, vCorner, fControlSize, uiContext.vMousePos )\n        && uiContext.bMouseInView;\n        \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick)\n        {\n            uiContext.iActiveControl = iControlId;\n            \n            uiContext.vActivePos = window.rect.vSize - uiContext.vMousePos;\n            \n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }\n        \n    bool bActive = (uiContext.iActiveControl == iControlId);        \n    \n    if ( bActive )\n    {\n        window.rect.vSize = uiContext.vMousePos + uiContext.vActivePos;\n        vec2 vMinWindowSize = vec2( 96.0, 64.0 );\n        window.rect.vSize = max( vMinWindowSize, window.rect.vSize );\n        window.rect.vSize = min( window.vMaxSize, window.rect.vSize );\n    }\n    \n    \n    if ( uiContext.bPixelInView &&\n        ScreenPosInResizeWidget( uiContext, vCorner, fControlSize, uiContext.vPixelPos ) )\n    {\n        vec4 vColor = vec4(cResize, 1.0);\n        \n        if( bActive )\n        {\n            vColor = vec4(cResizeActive, 1.0);\n        }\n        uiContext.vWindowOutColor = vColor;\n    }    \n}\n\nvec2 UI_GetWindowSizeForContent( vec2 vContentSize )\n{\n    return vContentSize \n        + vec2( 0.0, UIStyle_TitleBarHeight() )\n    \t+ UIStyle_WindowBorderSize() * 2.0\n    \t+ UIStyle_WindowContentPadding() * 2.0;\n}\n\nUIWindowState UI_ProcessWindowCommonBegin( inout UIContext uiContext, int iControlId, int iData, UIWindowDesc desc )\n{   \n    UIWindowState window = UI_GetWindowState( uiContext, iControlId, iData, desc );\n        \n    if ( window.bClosed )\n    {\n        return window;\n    }\n    \n    UI_PanelBegin( uiContext, window.panelState );\n    \n    uiContext.vWindowOutColor.rgba = vec4( cWindowBackgroundColor, 1.0 );\n    \n    window.drawRect = window.rect;\n    \n    Rect contextRect = window.drawRect;    \n    RectShrink( contextRect, UIStyle_WindowBorderSize() );\n    \n    vec2 vTitleBarSize = UI_WindowGetTitleBarSize( uiContext, window );\n    if ( window.bMinimized )\n    {\n\t    window.drawRect.vSize.y = vTitleBarSize.y + UIStyle_WindowBorderSize().y * 2.0;\n    }\n    \n    // Get window main panel view\n    Rect panelRect = contextRect;\n    \n    panelRect.vPos.y += vTitleBarSize.y;\n    panelRect.vSize.y -= vTitleBarSize.y;\n    \n    if ( window.bMinimized )\n    {\n        panelRect.vSize.y = 0.0;\n    }           \n    \n    \n    UIDrawContext panelDesc = UIDrawContext_SetupFromRect( panelRect );\n    UIDrawContext panelContext = UIDrawContext_TransformChild( window.panelState.parentDrawContext, panelDesc );\n    UI_SetDrawContext( uiContext, panelContext );\n    \n    if ( FLAG_SET(window.uControlFlags, WINDOW_CONTROL_FLAG_RESIZE_WIDGET) )\n    {\n        int iWindowResizeControlId = window.iControlId + 2000; // hack        \n    \tUI_ProcessWindowResizeWidget( uiContext, window, iWindowResizeControlId );\n    }\n            \n    // Get window content panel view\n    UIDrawContext contentPanelDesc;\n    contentPanelDesc.viewport = Rect( vec2(0.0), uiContext.drawContext.viewport.vSize );\n    RectShrink( contentPanelDesc.viewport, UIStyle_WindowContentPadding() );\n    contentPanelDesc.vOffset = vec2(0);\n    contentPanelDesc.vCanvasSize = contentPanelDesc.viewport.vSize;\n\n    UI_SetDrawContext( uiContext, UIDrawContext_TransformChild( panelContext, contentPanelDesc ) ); \n    \n    return window;\n}\n\nvoid UI_ProcessWindowCommonEnd( inout UIContext uiContext, inout UIWindowState window, int iData )\n{    \n    bool bPixelInPanel = uiContext.bPixelInView;\n    \n    Rect contextRect = window.drawRect;    \n    RectShrink( contextRect, UIStyle_WindowBorderSize() );\n    \n    UIDrawContext windowContextDesc = UIDrawContext_SetupFromRect( contextRect );\n    UIDrawContext windowContext = UIDrawContext_TransformChild( window.panelState.parentDrawContext, windowContextDesc );\n\tUI_SetDrawContext( uiContext, windowContext );\n    \n    bool inTitleBar = false;\n    if (  FLAG_SET(window.uControlFlags, WINDOW_CONTROL_FLAG_TITLE_BAR)  )\n    {\n    \tinTitleBar = UI_ProcessWindowTitleBar( uiContext, window );\n    }\n    \n    UIDrawContext windowBackgroundContextDesc = UIDrawContext_SetupFromRect( window.drawRect );\n    UIDrawContext windowBackgroundContext = UIDrawContext_TransformChild( window.panelState.parentDrawContext, windowBackgroundContextDesc );    \n\n    UI_SetDrawContext( uiContext, windowBackgroundContext );\n    if ( !bPixelInPanel && !inTitleBar )\n    {\n        Rect rect = Rect( vec2(0), window.drawRect.vSize );\n#ifdef NEW_THEME        \n\t    DrawBorderRect( uiContext.vPixelCanvasPos, rect, cWindowBorder, uiContext.vWindowOutColor );                            \n#else        \n\t    DrawBorderOutdent( uiContext.vPixelCanvasPos, rect, uiContext.vWindowOutColor );                    \n#endif\n        \n    }    \n    \n    if ( uiContext.bMouseDown && uiContext.bMouseInView && !uiContext.bHandledClick )\n    {\n        uiContext.bHandledClick = true;\n    }\n    \n    Rect windowRect = uiContext.drawContext.clip;\n\n    UI_PanelEnd( uiContext, window.panelState );\n    UI_ComposeWindowLayer( uiContext, UIStyle_WindowTransparency(), windowRect );\n    \n    UI_StoreWindowState( uiContext, window, iData );    \n}\n\n\n////////////////////////////////////////////////////////////////////////\n// Client Code Below Here\n////////////////////////////////////////////////////////////////////////\n\n//#define MAIN_WINDOW_ONLY\n\nfloat \tUIStyle_TitleBarHeight() \t\t{ return 32.0; }\nvec2 \tUIStyle_WindowBorderSize() \t\t{ return vec2(6.0); }\nvec2 \tUIStyle_WindowContentPadding() \t{ return vec2(16.0, 8.0); }\nvec2 \tUIStyle_ControlSpacing() \t\t{ return  vec2(6.0); }\nvec2 \tUIStyle_FontPadding() \t\t\t{ return vec2(8.0, 2.0); }\nvec2 \tUIStyle_CheckboxSize() \t\t\t{ return vec2(24.0); }\nvec2 \tUIStyle_SliderSize()\t\t\t{ return vec2(128.0, 32.0f); }\nvec3 \tUIStyle_ColorPickerSize()\t\t{ return vec3(128.0, 128.0, 32.0); }\nfloat \tUIStyle_ScrollBarSize() \t\t{ return 24.0; }\nfloat   UIStyle_WindowTransparency() \t{ return 0.025f; }\n\nvoid UIStyle_GetFontStyleWindowText( inout LayoutStyle style, inout RenderStyle renderStyle )\n{\n    style = LayoutStyle_Default();\n\trenderStyle = RenderStyle_Default( vec3(0.0) );\n}\n\nvoid UIStyle_GetFontStyleTitle( inout LayoutStyle style, inout RenderStyle renderStyle )\n{\n    style = LayoutStyle_Default();\n\trenderStyle = RenderStyle_Default( cWindowTitle );\n}\n\nvoid PrintWindowTitle( inout PrintState state, LayoutStyle style, int controlId )\n{\n    if ( controlId == IDC_WINDOW_CONTROLS )\n    {\n        uint strA[] = uint[] ( _C, _o, _n, _t, _r, _o, _l, _s );\n        ARRAY_PRINT(state, style, strA);\n    }\n}\n\nstruct UIData\n{\n    UIData_Bool checkboxA;\n    //DATA_WINDOW_VISIBLE\n    \n    UIData_Value floatA;\n    UIData_Value floatB;\n    UIData_Value floatC;    \n\n    UIData_Value floatSPD;    \n};    \n\n    \nUIData UI_GetControlData()\n{\n    UIData data;\n    \n    data.checkboxA = UI_GetDataBool( DATA_CHECKBOX_A, true );\n    \n    data.floatA = UI_GetDataValue( DATA_FLOAT_A, 0.0583, 0.0, 1.0, false );\n    data.floatB = UI_GetDataValue( DATA_FLOAT_B, 0.2416,  0.0, 1.0, false );\n    data.floatC = UI_GetDataValue( DATA_FLOAT_C, 0.2000, 0.0, 1.0, false );\n\n    data.floatSPD = UI_GetDataValue( DATA_FLOAT_SPD, 3.0, 0.0, 8.0, true );\n        \n    return data;\n}\n\nvoid UI_StoreControlData( inout UIContext uiContext, UIData data )\n{\n    UI_StoreDataBool( uiContext, data.checkboxA, DATA_CHECKBOX_A );\n\n    UI_StoreDataValue( uiContext, data.floatA, DATA_FLOAT_A );\n    UI_StoreDataValue( uiContext, data.floatB, DATA_FLOAT_B );\n    UI_StoreDataValue( uiContext, data.floatC, DATA_FLOAT_C );\n\n    UI_StoreDataValue( uiContext, data.floatSPD, DATA_FLOAT_SPD );\n}\n\nvoid UI_ProcessWindowMain( inout UIContext uiContext, inout UIData uiData, int iControlId, int iData )\n{\n    UIWindowDesc desc;\n    \n    desc.initialRect = Rect( vec2(32, 128), vec2(380, 180) );\n    desc.bStartMinimized = false;\n    desc.bStartClosed = true;\n    desc.uControlFlags = WINDOW_CONTROL_FLAG_TITLE_BAR | WINDOW_CONTROL_FLAG_MINIMIZE_BOX | WINDOW_CONTROL_FLAG_RESIZE_WIDGET | WINDOW_CONTROL_FLAG_CLOSE_BOX;    \n    desc.vMaxSize = vec2(100000.0);\n    \n    UIWindowState window = UI_ProcessWindowCommonBegin( uiContext, iControlId, iData, desc );\n    \n    if ( window.bClosed )\n    {\n        //if ( uiContext.bMouseDown )\n        if ( Key_IsPressed( iChannelKeyboard, KEY_SPACE ) )\n        {\n            window.bClosed = false;\n        }\n    }\n    \n    if ( !window.bMinimized )\n    {\n        // Controls...\n\n        Rect scrollbarPanelRect = Rect( vec2(0), vec2( 300.0 + UIStyle_ScrollBarSize(), uiContext.drawContext.vCanvasSize.y ) );\n\n        vec2 vScrollbarCanvasSize = vec2(300, 200);\n\n        UIPanelState scrollbarPanelState;            \n        UI_ProcessScrollbarPanelBegin( uiContext, scrollbarPanelState, IDC_WINDOW_SCROLLBAR, DATA_WINDOW_SCROLLBAR, scrollbarPanelRect, vScrollbarCanvasSize );\n\n        {        \n            UILayout uiLayout = UILayout_Reset();\n\n            LayoutStyle style;\n            RenderStyle renderStyle;             \n            UIStyle_GetFontStyleWindowText( style, renderStyle );       \n\n            \n            UILayout_StackControlRect( uiLayout, UIStyle_SliderSize() );                \n            UI_ProcessSlider( uiContext, IDC_SLIDER_SPD, uiData.floatSPD, uiLayout.controlRect );       \n            //UILayout_StackDown( uiContext.uiLayout );    \n            UILayout_StackRight( uiLayout );\n\n            {\n                PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );        \n                uint strA[] = uint[] ( _S, _P, _D, _COLON, _SP );\n                ARRAY_PRINT(state, style, strA);\n                Print(state, style, int(uiData.floatSPD.fValue) );\n                UI_RenderFont( uiContext, state, style, renderStyle );\n                UILayout_SetControlRectFromText( uiLayout, state, style );\n            }\n            UILayout_StackDown( uiLayout );              \n\n            \n            \n            UILayout_StackControlRect( uiLayout, UIStyle_CheckboxSize() );                \n            UI_ProcessCheckbox( uiContext, IDC_CHECKBOX_A, uiData.checkboxA, uiLayout.controlRect );\n\n            UILayout_StackRight( uiLayout );\n            UILayout_StackDown( uiLayout );    \n\n\n            \n            UILayout_StackControlRect( uiLayout, UIStyle_SliderSize() );                \n            UI_ProcessSlider( uiContext, IDC_SLIDER_FLOAT_A, uiData.floatA, uiLayout.controlRect );\n\n            UILayout_StackRight( uiLayout );\n\n            {\n                PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );        \n                uint strA[] = uint[] ( _R, _COLON, _SP );\n\n                ARRAY_PRINT(state, style, strA);\n\n                Print(state, style, uiData.floatA.fValue, 4 );\n\n                UI_RenderFont( uiContext, state, style, renderStyle );\n\n                UILayout_SetControlRectFromText( uiLayout, state, style );\n            }\n\n            UILayout_StackDown( uiLayout );    \n\n            UILayout_StackControlRect( uiLayout, UIStyle_SliderSize() );                \n            UI_ProcessSlider( uiContext, IDC_SLIDER_FLOAT_B, uiData.floatB, uiLayout.controlRect );       \n            //UILayout_StackDown( uiContext.uiLayout );    \n            UILayout_StackRight( uiLayout );\n\n            {\n                PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );        \n                uint strA[] = uint[] ( _G, _COLON, _SP );\n                ARRAY_PRINT(state, style, strA);\n                Print(state, style, uiData.floatB.fValue, 4 );\n                UI_RenderFont( uiContext, state, style, renderStyle );\n                UILayout_SetControlRectFromText( uiLayout, state, style );\n            }\n            UILayout_StackDown( uiLayout );\n\n\n\n            UILayout_StackControlRect( uiLayout, UIStyle_SliderSize() );                \n            UI_ProcessSlider( uiContext, IDC_SLIDER_FLOAT_C, uiData.floatC, uiLayout.controlRect );       \n            //UILayout_StackDown( uiContext.uiLayout );    \n            UILayout_StackRight( uiLayout );\n\n            {\n                PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );        \n                uint strA[] = uint[] ( _B, _COLON, _SP );\n                ARRAY_PRINT(state, style, strA);\n                Print(state, style, uiData.floatC.fValue, 4 );\n                UI_RenderFont( uiContext, state, style, renderStyle );\n                UILayout_SetControlRectFromText( uiLayout, state, style );\n            }\n            UILayout_StackDown( uiLayout );     \n            \n            \n\n            #if 0\n            // Debug state\n            {\n                PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );\n                uint strA[] = uint[] ( _C, _t, _r, _l, _COLON );\n                ARRAY_PRINT(state, style, strA);\n\n                Print(state, style, uiContext.iActiveControl );\n                UI_RenderFont( uiContext, state, style, renderStyle );\n\n                UILayout_SetControlRectFromText( uiLayout, state, style );            \n            }        \n            #endif\n        }\n           \n        UI_ProcessScrollbarPanelEnd(uiContext, scrollbarPanelState);\n    }    \n    \n    UI_ProcessWindowCommonEnd( uiContext, window, iData );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    UIContext uiContext = UI_GetContext( fragCoord, DATA_UICONTEXT );\n    UIData uiData = UI_GetControlData();\n        \n    // Content...\n    \n    UI_ProcessWindowMain( uiContext, uiData, IDC_WINDOW_CONTROLS, DATA_WINDOW_CONTROLS );\n    \n    Rect composeRect = uiContext.drawContext.clip;\n    UI_ComposeWindowLayer( uiContext, 0.0f, composeRect );\n\n    UI_StoreControlData( uiContext, uiData );\n    \n    UI_StoreContext( uiContext, DATA_UICONTEXT );\n    \n    fragColor = UI_GetFinalColor( uiContext );    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define ACTIVE 0\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if !ACTIVE\n    discard;\n#endif    \n    \n    if ( fragCoord.x > 4. || fragCoord.y > 4.) discard;\n    \n    float fOffsetA = 784.0;\n    \n    float steps = 1000.0;\n    \n    float fStart = float(iFrame) * steps;\n    \n    float fMin = 10000.0;\n    float fBestOffset = -1.0;\n    \n#if ACTIVE\n    for ( float f =0.; f< steps + max(0., -iTime); f+=1.0 )\n    {\n        float fCurr = fStart + f;\n        float t = Match( fOffsetA, fCurr );\n        \n        if ( t < fMin )\n        {\n            fMin = t;\n            fBestOffset = fCurr;\n        }\n    }\n\n    \n    if ( iFrame > 1 )\n    {\n        vec4 vSample = texelFetch( iChannel0, ivec2(0), 0 );\n        float fPrevBestOffset = vSample.x;\n        float fPrevMin = vSample.y;\n\n        if ( fPrevMin < fMin )\n        {\n            fBestOffset = fPrevBestOffset;\n            fMin = fPrevMin;\n        }\n    }\n#endif    \n    \n    fragColor = vec4(fBestOffset,fMin,1.0,1.0);\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}