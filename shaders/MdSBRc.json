{
    "Shader": {
        "info": {
            "date": "1501519816",
            "description": "Polygonizing an isosurface via the marching tetrahedra algorithm.",
            "flags": 0,
            "hasliked": 0,
            "id": "MdSBRc",
            "likes": 54,
            "name": "[SH17C] Surface Mesh Generation",
            "published": 3,
            "tags": [
                "triangle",
                "marching",
                "tetrahedron",
                "isosurface",
                "polygon",
                "mesh"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 3882
        },
        "renderpass": [
            {
                "code": "/*\n\n\tSurface Mesh Generation\n\t-----------------------\n\n\tIn case it needs to be said, performing the marching cubes algorithm inside a pixel\n\tshader is committing compiler and frame rate suicide, and to a lesser degree, that also \n\tapplies to the marching tetrahedra version. In fact, I'd be very surprised if anyone \n\thas ever been stupid enough to try this in a pixel shader before. With that said, here \n\tis an example of polygonizing a scalar isosurface via the marching tetrahedra method. :D\t\n\n\tJokes aside, one of the things I like most about Shadertoy is that a lot of democoders\n\tI follow have accounts here, and every once so often, one of them will implement \n\tan esoteric Siggraph paper containing difficult to find code in a very succinct and \n\tsimplistic manner.\n\n    With that in mind, for the \"Shader Professor\" round, I wanted to provide something that\n\tyou probably wouldn't find in pixel shader form that might be useful outside the shader\n\tenvironment.\n\n\tHaving the ability to create interesting isosurfaces is great, but if you ever want to \n\ttransfer the data to the triangle rasterization world, you'll need to polygonize it in \n\tsome way, and the marching tetrahedra algorithm - which is a lesser used cousin of the \n    marching cubes algorithm - is one of them. Unfortunately, it's really difficult to find \n\ta simple implementation with working support code, so that's what I'm attempting to\n\tprovide here.\n\n\tI've explained the process below, but here's a short breakdown: First, break space into \n\ta cubic grid, then further partition each cube into six individual tetrahedra - That\n\tmay sound complicated, but believe it or not, it can be achieved in just a few lines.\n\tAfter that, obtain the isosurface values at each of the four tetrahedral vertices.\n\tOnce you have those, determine which ones fall below the threshold, and which remain \n\tabove it. These differences can then be used on a case by case basis to render the\n\trequired triangle arrangement. Since the tetrahedra share edges, the triangles will\n\tform a continuous mesh.\n\n\tThe point of this excercise was to provide a working algorithm - The scene and rendering\n\tquality was of secondary importance. It's a little on the slow side and there are tiny\n\tartifacts visible. Those are rendering artifacts only - due to the fact that I'm taking a \n\tcouple of shortcuts. However, the algorithm itself should produce robust vertice lists.\n\n\tYou'll note that I've only rendered the triangle edges. That was a style choice, plus\n\tit's cheaper. However, triangles are also possible. Allowing the isosurface to protrude\n\tthrough parts of the mesh was a style choice as well. In general, I had to dispense with \n\tthe bells and whistles, since I coded this on a pretty fast machine and it barely manages \n\t60 fps in the 800 by 450 window. Performance could definitely be increased, but not \n\twithout seriously disturbing the readable state of the code, which I'm assuming was the \n\tpoint of the excercise. Besides, this was only meant to be a proof of concept.\n    \n\n\tReferences:\n\n\tPaul Bourke's site has long been a favorite of mine and has been a Mecca to graphics\n\tcoders for years. Anyway, the following is a great article to familiarize yourself \n    with the content before proceeding:\n\t\n\tPolygonising A Scalar Field - Paul Bourke\n    http://paulbourke.net/geometry/polygonise/\n\n\n*/\n\n#define FAR 80.\n\n// Scene object ID. Object identification. Either the mesh (0) or the isosurface (1).\nfloat objID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\n\n// Non-standard vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n// Camera path.\nvec3 path(float t){\n  \n    //return vec3(0, 0, t); // Straight path.\n    //return vec3(-sin(t/2.), sin(t/2.)*.5 + 1.57, t); // Windy path.\n    \n    float a = sin(t * 0.11);\n    float b = cos(t * 0.14);\n    return vec3(a*4. -b*1.5, b*1.7 + a*1.5, t);\n    \n}\n\n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// A cheap orthonormal basis vector function - Taken from Nimitz's \"Cheap Orthonormal Basis\" example, then \n// modified slightly.\n//\n//Cheap orthonormal basis by nimitz\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n//via: http://psgraphics.blogspot.pt/2014/11/making-orthonormal-basis-from-unit.html\nmat3 basis(in vec3 n){\n    \n    float a = 1./(1. + n.z);\n    float b = -n.x*n.y*a;\n    return mat3(1. - n.x*n.x*a, b, n.x, b, 1. - n.y*n.y*a, n.y, -n.x, -n.y, n.z);\n                \n}\n \n// A line segment formula that orients via an orthanormal basis. It'd be faster to use\n// IQ's 3D line segment formula, but this one allows for more interesting cross sections,\n// like hexagons and so forth.\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ){\n\n    b -= a;\n    float l = length(b);\n    p = basis(normalize(b))*(p - a - b*.5);\n    \n    p = abs(p);\n    //return = max(length(p.xy) - r, p.z - l*.5);\n    //return = max((p.x + p.y)/2. - r, p.z - l*.5);\n    //return = max(max(p.x, p.y) - r, p.z - l*.5);\n    return max(max(p.x*.866025 + p.y*.5, p.y) - r, p.z - l*.5);\n \n}\n\n \n \n/*\n// Smooth maximum, based on the function above.\nfloat smaxP(float a, float b, float s){\n    \n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n*/\n\n// A fake, noisy looking field - cheaply constructed from a spherized sinusoidal\n// combination. I came up with it when I was bored one day. :) Lousy to hone in\n// on, but it has the benefit of being able to guide a camera through it.\nfloat isoMap(vec3 p){\n     \n    p.xy -= path(p.z).xy; // Perturb the object around the camera path.\n    \n\tp = cos(p*.315*1.25 + sin(p.zxy*.875*1.25)); // 3D sinusoidal mutation.\n    \n    float n = length(p); // Spherize. The result is some mutated, spherical blob-like shapes.\n\n    // It's an easy field to create, but not so great to hone in one. The \"1.4\" fudge factor\n    // is there to get a little extra distance... Obtained by trial and error.\n    return (n - 1.);\n    \n}\n\n// Interpolating along the edge connecting vertices v1 and v2 with respect to the isovalue.\nvec3 inter(in vec3 p1, in vec3 p2, float v1, float v2, float isovalue){\n    \n     \n    // The interpolated point will fall somewhere between the vertex points p1 and p2.\n    // Obviously if the isovalue is closer to p1, then the interpolated point will be\n    // closer to p1, and vice versa.\n    return mix(p1, p2, (isovalue - v1)/(v2 - v1));\n    \n    // Equivalent to:\n    //return p1 + (isovalue - v1)/(v2 - v1)*(p2 - p1);\n    \n    // This is probably more correct, but we seem to be getting away with the line above.\n    //float inter = v1 == v2 ? .5 : (isovalue - v1) /(v2 - v1); \n    //return mix(p1, p2, inter);\n}\n\n// Hacky global to save the unit direction ray for use below.\nvec3 svRd;\nfloat rayBox(in vec3 ro){\n    \n    vec3 p = 1./svRd;\n    p = abs(p)*1.01 - p*ro;\n\treturn min(min(p.x, p.y), p.z);\n}\n\n/*\n// Standard ray-plane intersection.\nfloat rayPlane(vec3 p, vec3 o, vec3 n, vec3 rd) {\n    \n    float dn = dot(rd, n);\n\n    float s = 1e8;\n    \n    if (abs(dn) > 0.) {\n        s = dot(p - o, n) / dn;\n        s = s<0. ? 1e8 : s;\n    }\n    \n    return s;//o + s*rd;\n}\n\n// Quickly hacked together ray to tetrahedron intersection... It seems to work. :)\nfloat rayTetra(vec3 p, vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 rd){\n    \n    vec3 n = normalize(cross(p0 - p1, p0 - p2));\n    //vec3 pc = (p0 + p1 + p2)/3.;\n    float t = rayPlane(p, p0, n, svRd);\n    n = normalize(cross(p0 - p2, p0 - p3));\n    //pc = (p0 + p2 + p3)/3.;\n    t = min(t, rayPlane(p, p0, n, svRd));\n    n = normalize(cross(p0 - p1, p0 - p3));\n    //pc = (p0 + p1 + p3)/3.;\n    t = min(t, rayPlane(p, p0, n, svRd));\n    n = normalize(cross(p1 - p2, p1 - p3));\n    //pc = (p1 + p2 + p3)/3.;\n    t = min(t, rayPlane(p, p1, n, svRd)); \n    \n    return t;//min(t, .5);\n}\n*/\n\n/*\n\n\tIf you're not familiar with the marching cubes or marching tetrahedra process, it's\n\tworth reading the article I've provided below, which contains easy to follow visuals,\n    etc. It would have been nice to include those within the shader, but this is a pretty\n\texpensive algorithm, so the frame rate and compiler wouldn't let me. :)\n\n\tAscii tetrahedron with labled vertices, for a mild visual reference.\n\n        0 + \n         /|\\\n        / | \\\n       /  |  \\\n    3 +---|---+ 1\n       \\  |  /\n        \\ | /\n         \\|/\n          + 2\n\n\n\tThe method is simple. Patition space into a cubic grid, then split each cube into six \n\tindividual tetrahedra. Obtain the isosurface values at each of the four tetrahedral vertices.\n\tthen use them to determine the required triangle arrangment for the tetrahedral cell.\n    Since the tetrahedron edges align with those on adjacent cells, the interpolated triangles\n\twill line up throughout the grid to produce a triangulated mesh. For a better explanation\n\tand visual representation, feel free to follow the link below.\n\t\n\tI remember fumbling my way through the correct triangle orientations, then deciding to \n\ttry Paul Bourke's site, and sure enough, there was some fantastic working code to get\n\tme started. Although, I still had to do more work to get the right oriented triangles.\n\n\tPaul Bourke's site used to be a graphics community Mecca, and still is to a certain\n\tdegree. At one point his Alexa ranking was so low that he could have made a fortune via\n\tadvertising... Anyway, for anyone who's not familiar with the site, it's still a fantastic \n    resource.\n\n\tReferences:\n\n\tPolygonising A Scalar Field\n    http://paulbourke.net/geometry/polygonise/\n \n    Marching tetrahedra source: http://paulbourke.net/geometry/polygonise/source1.c\n*/\n\nfloat map(vec3 p){\n \n    \n    // Grid scale. Smaller values give a denser mesh, which obviously fit the isosurface \n    // better. I deliberately chose a less dense mesh in order to display the individual \n    // triangles more clearly.\n    const float sc = .75;\n \n    // Partitioning space into cubes, which are further subdivided into six tetrahedra. \n    // Note that no skewing is performed. You could, but I hear that it's not necessary.\n    vec3 i = floor(p/sc)*sc;  p -= i;\n    // Partioning into tetrahedra - Determined by checking which side of a couple \n    // of diagonal planes we're on.\n    vec3 i1 = step(p.yzx, p)*sc, i2 = max(i1, sc - i1.zxy); i1 = min(i1, sc - i1.zxy);    \n    \n    // The four vertices of the individual tetrahedron.\n    vec3 p0 = vec3(0), p1 = i1, p2 = i2, p3 = vec3(1)*sc;\n    \n    // Places for six vertices. Difference combinations require two triangles. \"va\" hold\n    // the round vertex places.\n    vec3 v1, v2, v3, v4, v5, v6, va;\n        \n     ///////////    \n     \n    // The four surface isolvalues at each of the four vertices. Yes, taking four isovalues\n    // per distance function is crazy. In fact, we're rendering the continuous surface as\n    // well, so that makes five... Don't try this at home, folks. :D\n    vec4 ps = vec4(isoMap(i+p0), isoMap(i+p1), isoMap(i+p2), isoMap(i+p3));\n \n    // The continuous isosurface value. Actually, it's a little smaller, just so it can \n    // fit inside the polygonized mesh a little better. I deliberately left a bit of\n    // overlap for stylistic purposes, and to show that the mesh is an approximation.\n    float surface = isoMap(p + i) + .1;\n    \n    // The mesh and vertice values.\n    float mesh = 1e8, verts = 1e8;\n \n    // A flag to determine whether one, two, or zero triangle arrangements should be drawn.\n    float tri = 0.;\n    \n    \n    // Edge thickness and isolevel threshold constants.\n    const float r1 = .03;\n    \n    // The threshold doesn't have to be zero, but it makes more sense this way, since it's\n    // analogous to the zero distance mark. Ie, a surface hit.\n    const float isolevel = 0.;\n \n    int index = 0; \n    \n    // An old power-of-two flag trick. For instance, if point ps[0] and ps[2] are below the\n    // isolevel - or, in other words, inside the surface, the \"index\" variable will have a \n    // unique value of 5.\n    index += ps[0] < isolevel ? 1 : 0;\n    index += ps[1] < isolevel ? 2 : 0;\n    index += ps[2] < isolevel ? 4 : 0;\n    index += ps[3] < isolevel ? 8 : 0;\n \n    \n    \n    // If there are no verices with isovalues below the threshold, then we are\n    // effectively in open space. The question at this point is, \"How far do we\n    // advance the ray?\" What we should be doing is tetrahedral traversal, but \n    // instead, we'll cheat a little and use the continuous isosurface value.\n    // It's not ideal, but it simplifies things greatly.\n         \n    // No vertices inside.\n    if(index == 0) { \n        \n        // In theory, a tetrahedral grid traversal is necessary here, but it's slow and \n        // cumbersome, so I'm hacking through it with a bit of fudge, which is prone to\n        // artifacts. However, it's a lot simpler and hones in on the surface faster.        \n        //mesh = rayTetra(p, p0, p1, p2, p3, svRd) + .05; //rayBox(p);\n        \n        mesh = surface + .005;  \n         \n    }\n    // All vertices inside.\n    else if(index == 15){\n        \n        // Also requires a tetrahedral grid traversal. However, this way is cheaper.\n        //mesh = rayTetra(p, p0, p1, p2, p3, svRd) + .05;\n        \n        mesh = rayBox(p) + .05;\n    \t \n    }\n    \n    // Determining triangle arrangement based on how the four vertex isovalues\n    // relate to the threshold. To me it's common sense, but in general, if\n    // only one of the four isovalues is above the zero point threshold or only\n    // one is below, then one triangle should cut through the three edges it's\n    // connected to. That accounts for the first 8 (4x2) cases you see.\n    // That leaves the two isovalue above or below case. In that instance, a \n    // two triangle arrangement is necessary. As mentioned, look at the pictures\n    // in the article provided above, and that should make it clearer.\n    \n    // Because we're not concerned with triangular orientation, we can handle\n    // two cases at once, which saves half the decision making. When triangle \n    // orientation is important, you can handle the cases seperately. It's been\n    // while, but I'm pretty sure you can just reverse the order in once of \n    // the cases... Either way, if you weren't sure, a quick arrangement and\n    // visual test would do the trick.\n    \n    // Single triangle cases:\n    //\n    // Vertex 0 only is inside (index = 1) or outside (index = 14) the isosurface \n    // (Ie: 1, 2 and 3 are inside).\n    if(index == 1 || index == 14){\n        \n        //objID = 1.;\n        tri = 1.;\n        \n        // This particular triangle will cut through the three edges connecting to \n        // vertex 0. Where the three vertices cut the edge will depend upon where the\n        // isosurface touches the edge. You can determine that via simple interpolation.\n        // For instance, if \"ps[0]\" has a value of \"1\" and \"ps[1]\" has a value of \"-2,\"\n        // then you'd expect the triangle vertex to cut the edge one third of the \n        // way along the edge from \"ps[0].\"\n        v1 = inter(p0, p1, ps[0], ps[1], isolevel);\n        v2 = inter(p0, p2, ps[0], ps[2], isolevel);\n        v3 = inter(p0, p3, ps[0], ps[3], isolevel);\n        \n    }    \n    // Vertex 1 only is inside or outside.\n    else if(index == 2 || index == 13){\n\n        tri = 1.;\n        v1 = inter(p1, p0, ps[1], ps[0], isolevel);\n        v2 = inter(p1, p3, ps[1], ps[3], isolevel);\n        v3 = inter(p1, p2, ps[1], ps[2], isolevel);\n        \n        \n    }\n    // Vertex 2 only is inside or outside.\n    else if(index == 4 || index == 11){\n        \n        tri = 1.;\n        v1 = inter(p2, p0, ps[2], ps[0], isolevel);\n        v2 = inter(p2, p1, ps[2], ps[1], isolevel);\n        v3 = inter(p2, p3, ps[2], ps[3], isolevel);\n\n        \n    } \n    // Vertex 3 only is inside or outside.\n    else if(index == 7 || index == 8){\n        \n        tri = 1.;\n        v1 = inter(p3, p0, ps[3], ps[0], isolevel);\n        v2 = inter(p3, p2, ps[3], ps[2], isolevel);\n        v3 = inter(p3, p1, ps[3], ps[1], isolevel);\n        \n    }\n    \n \n    \n    \n    // Two triangle cases.\n    //\n\t// Vertices 0 and 1 are inside or vertices 2 and 3 are inside.\n    if(index == 3 || index == 12){\n        \n        tri = 2.;\n        \n        v1 = inter(p0, p3, ps[0], ps[3], isolevel);\n        v2 = inter(p0, p2, ps[0], ps[2], isolevel);\n        v3 = inter(p1, p3, ps[1], ps[3], isolevel);\n        \n        v4 = v3;\n        v5 = inter(p1, p2, ps[1], ps[2], isolevel);\n        v6 = v2;\n\n    \n    }\n    // Vertices 0 and 2 are inside or vertices 1 and 3 are inside.   \n    else if(index == 5 || index == 10){\n        \n        tri = 2.;\n        \n        v1 = inter(p0, p1, ps[0], ps[1], isolevel);\n        v2 = inter(p2, p3, ps[2], ps[3], isolevel);\n        v3 = inter(p0, p3, ps[0], ps[3], isolevel);\n        \n        v4 = v1;\n        v5 = inter(p1, p2, ps[1], ps[2], isolevel);\n        v6 = v2;\n\n    } \n    // Vertices 1 and 2 are inside or vertices 0 and 3 are inside.\n    else if(index == 6 || index == 9){\n        \n        tri = 2.;\n        \n        v1 = inter(p0, p1, ps[0], ps[1], isolevel);\n        v2 = inter(p1, p3, ps[1], ps[3], isolevel);\n        v3 = inter(p2, p3, ps[2], ps[3], isolevel);\n        \n        v4 = v1;\n        v5 = inter(p0, p2, ps[0], ps[2], isolevel);\n        v6 = v3;\n\n    }\n    \n    // Some notes on producing the vertex list - Per Dave Hoskins's request.\n    //\n    // Performing marching tetrahedra inside a pixel shader is a bit of a novelty, so as you \n    // could imagine, you wouldn't produce the actual vertex list within the shader. The idea \n    // would be to take this algorithm outside the pixel shader environment and produced the \n    // vertices there, where it'd be trivial. Basically, you'd visit every cube just once \n    // (instead of the multiple times required here). You'd subdivide each cube into tetrahedra \n    // using the 8 cube vertices (no need for step arithmetic), take the four isovalues, then \n    // proceed from there.\n    \n    // int vIndex = 0; // Counter to the vertex list. \n \n    // If necessary, draw a single triangle arrangement - in this case, three triangle edges.\n    // All edges together form the mesh.\n    if(tri>.5){\n        \n         mesh = sdCapsule(p, v1, v2, r1);\n         mesh = min(mesh, sdCapsule(p, v2, v3, r1));\n         mesh = min(mesh, sdCapsule(p, v3, v1, r1)); \n        \n         // Imaginary vertex list array. Just keep adding vertices. Groups of three make \n         // up a triangle. \"i\" is the relative position of each cube, and v1, v2 and v3\n         // are unique to each tetrahedron. Obviously, this would be performed outside the\n         // the shader environment. You'd have to perform this over a 3 dimensional cubic\n         // grid, then run through all six tetrahedra for each cube.\n         // Splitting a cube into six tetrhedra. c0 to c7 represent the cube vertices.\n\t\t // 1st [c0, c2, c3, c7], 2nd [c0, c2, c6, c7], 3rd [c0, c4, c6, c7],\n\t\t // 4th [c0, c6, c1, c2], 5th [c0, c6, c1, c4], 6th [c5, c6, c1, c4].\n         // For instance the first tetrahedron would be:\n         // 1st [i, i + vec3(0, 0, 1), i + vec3(1, 0, 1), i + vec3(1, -1, 1)].\n         //vertexList[vIndex++] = i + v1;\n         //vertexList[vIndex++] = i + v2;\n         //vertexList[vIndex++] = i + v3;\n    } \n    \n    // If a second triangle arrangement is required, draw it too.\n    if(tri>1.5){\n         mesh = min(mesh, sdCapsule(p, v4, v5, r1));\n         mesh = min(mesh, sdCapsule(p, v5, v6, r1));\n         mesh = min(mesh, sdCapsule(p, v6, v4, r1));\n        \n         // Imaginary vertex list array. Just keep adding triangles.\n         //vertexList[vIndex++] = i + v4;\n         //vertexList[vIndex++] = i + v5;\n         //vertexList[vIndex++] = i + v6;\n         \n    } \n    \n    \n    // If necessary, draw little spheres to represent the vertex points for one\n    // or two triangles.\n    if(tri>.001) {\n        va = vec3(dot(p - v1, p - v1), dot(p - v2, p - v2), dot(p - v3, p - v3));\n        verts = sqrt(min(min(va.x, va.y), va.z)) - .06; \n    }\n    if(tri>1.001) {\n        va = vec3(dot(p - v4, p - v4), dot(p - v5, p - v5), dot(p - v6, p - v6));\n        verts = min(verts, sqrt(min(min(va.x, va.y), va.z)) - .06);\n    }\n\n    // Add the vertices to the mesh.\n    mesh = min(mesh, verts);\n\n    // Object identification. Either the mesh or the encased isosurface.\n    objID = mesh > surface ? 0. : 1.;\n    \n    // Combine the mesh with the continuous, encased surface.\n    return min(mesh, surface);\n    \n    \n    \n}\n\n \n\n\n// Standard raymarching routine.\nfloat trace(vec3 o, vec3 r){\n    \n    float t = 0., d;\n    \n    for (int i = 0; i < 128; i++){\n        \n        d = map(o + r*t);\n        \n        if(abs(d)<.003*(t*.125 + 1.) || t>FAR) break;\n        \n        // Make smaller jumps as we approach the surface... kind of.\n        t += (d<1. ? d*.5 : d);\n    }\n    \n    return min(t, FAR);\n}\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.5, occ = 0.0;\n    for( int i=min(0, iFrame); i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.35/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n        \n        // Fake break to prevent loop unrolling. Bad coding at its\n        // finest, but the compiler seems to like it... Sigh! :)\n        if(sca>1e5) break;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nfloat getEdge(in vec3 p, in vec2 e) { \n\n     \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(0, iFrame); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n        \n    float d = map(p)*2.;\n\n    float edge = abs(mp[0] + mp[1] - d) + abs(mp[2] + mp[3] - d) + abs(mp[4] + mp[5] - d);\n    //edge = abs(mp[0] + mp[1] + mp[2] + mp[3] + mp[4] + mp[5] - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n    \n    return edge;\n}\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNrm(in vec3 p, in vec2 e) {\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(0, iFrame); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n// Normal calculation, with some edging and curvature bundled in.\n//\n// Addendum: I've rewritten this in a very contrived and ugly form to \n// appease the compiler. It seems to work, but I still don't like it. :)\nvec3 nrm(vec3 p, inout float edge, inout float crv, float t) { \n\t\n    \n    // Roughly two pixel edge spread, regardless of resolution.\n    vec2 e = vec2(1./iResolution.y*(1. + t*.5), 0);\n    \n    edge = getEdge(p, e);\n/*   \n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n    \n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n    */\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.002, 0); //iResolution.y - Depending how you want different resolutions to look.\n    /*\n    d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n    */\n    \n    return getNrm(p, e);\n}\n\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n    const float camSpeed = 1.;\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*camSpeed); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .25);  // \"Look At\" position.\n \n   \n    // Light position. Set in the vicinity of the camera.\n    vec3 lp = ro + vec3(0, 2, -1);\n   \n   \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the path. The \"path\" function is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z).xy;\n\tlk.xy += path(lk.z).xy;\n\tlp.xy += path(lp.z).xy;\n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 r = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    //r = normalize(vec3(r.xy, sqrt(max(r.z*r.z - dot(r.xy, r.xy)*.15, 0.)) ));\n    \n    // Saving the unit direction ray, to be used in the distance function.\n    svRd = r;\n    \n    // Camera swivel - based on path position.\n    //vec2 sw = path(lk.z).xy;\n    //r.xy *= r2(-sw.x/32.);\n    \n    // Basic raymarching function.\n    float t = trace(ro, r);\n    \n    svObjID = objID; // Save the ID.\n\n\n    // Scene color.\n    vec3 sc = vec3(0);\n   \n\n    // Edge and curvature - The latter isn't being used..\n    float edge = 0., crv = 1.;\n    \n    if(t<FAR){\n        \n        // Hit position and normal.\n        vec3 sp = ro + r*t;\n        vec3 sn = nrm(sp, edge, crv, t);\n        \n        // Scene coloring. Very basic.\n        vec3 oCol = tex3D(iChannel0, sp, sn)*2.;\n        if(svObjID<.5) oCol = mix(oCol, oCol.zyx, .75);\n        \n        \n        float ao = cAO(sp, sn); // Ambient occlusion.\n\n        // Point light.\n        vec3 ld = lp - sp;\n        float dist = max(length(ld), 0.001);\n        ld /= dist;\n\n        float atten = 5./(1. + dist*0.125 + dist*dist*0.05); // Attenuation.\n        \n        float diff = max(dot(ld, sn), 0.); // Diffuse.\n        \n       \n        // Putting it all together.\n    \tsc = oCol*(diff + ao*.35)*atten*ao*(1. - edge*.7);\n        \n\n    }\n    \n    \n    // Extra dark fog. The more we hide with this scene the better. :)\n    sc = mix(vec3(0), sc, 1.0 / (1. + t*0.125 + t*t * 0.03));\n    //sc = mix(sc, vec3(0), smoothstep(0.0, .2, t/FAR));\n    \n    // Rough gamma correction.\n\tfragColor = vec4(sqrt(max(sc, 0.)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}