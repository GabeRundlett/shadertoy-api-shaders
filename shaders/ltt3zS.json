{
    "Shader": {
        "info": {
            "date": "1470138138",
            "description": "Creating a new dynamical system by chaining two different systems together, with fleshy rendering. Paint with mouse controls.",
            "flags": 48,
            "hasliked": 0,
            "id": "ltt3zS",
            "likes": 43,
            "name": "Dynamical Flesh",
            "published": 3,
            "tags": [
                "system",
                "flesh",
                "dynamical"
            ],
            "usePreview": 0,
            "username": "cornusammonis",
            "viewed": 1998
        },
        "renderpass": [
            {
                "code": "// uncomment to just render the normals\n//#define NORMAL\n\n// displacement\n#define DISP 2.5\n\n// contrast\n#define SIGMOID_CONTRAST 20.0\n\n// mip level\n#define MIP 2.0\n\n\nvec3 contrast(vec3 x) {\n\treturn 1.0 / (1.0 + exp(-SIGMOID_CONTRAST * (x - 0.5)));    \n}\n\nvec3 normz(vec3 x) {\n\treturn x == vec3(0) ? vec3(0) : normalize(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 texel = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    #ifdef NORMAL\n    \tvec2 d = texture(iChannel0, uv).xy;\n   \t\tvec3 nr = 0.5 + 0.5 * normalize(vec3(d.x,d.y,sqrt(clamp(1.0-length(d.xy),0.0,1.0))));\n    \tfragColor = vec4(nr, 1.0);\n    #else\n        vec2 n  = vec2(0.0, texel.y);\n        vec2 e  = vec2(texel.x, 0.0);\n        vec2 s  = vec2(0.0, -texel.y);\n        vec2 w  = vec2(-texel.x, 0.0);\n\n        vec2 d   = texture(iChannel0, uv).zw;\n        vec2 d_n = texture(iChannel0, fract(uv+n)).zw;\n        vec2 d_e = texture(iChannel0, fract(uv+e)).zw;\n        vec2 d_s = texture(iChannel0, fract(uv+s)).zw;\n        vec2 d_w = texture(iChannel0, fract(uv+w)).zw; \n        \n    \tvec2 d_ne = texture(iChannel0, fract(uv+n+e)).zw;\n        vec2 d_se = texture(iChannel0, fract(uv+s+e)).zw;\n        vec2 d_sw = texture(iChannel0, fract(uv+s+w)).zw;\n        vec2 d_nw = texture(iChannel0, fract(uv+n+w)).zw; \n\n        vec3 i   = texture(iChannel1, fract(vec2(0.5) + DISP * d  ), MIP).xyz;\n        vec3 i_n = texture(iChannel1, fract(vec2(0.5) + DISP * d_n), MIP).xyz;\n        vec3 i_e = texture(iChannel1, fract(vec2(0.5) + DISP * d_e), MIP).xyz;\n        vec3 i_s = texture(iChannel1, fract(vec2(0.5) + DISP * d_s), MIP).xyz;\n        vec3 i_w = texture(iChannel1, fract(vec2(0.5) + DISP * d_w), MIP).xyz;\n\n    \t// The section below is an antialiased version of \n    \t// Shane's Bumped Sinusoidal Warp shadertoy here:\n\t\t// https://www.shadertoy.com/view/4l2XWK\n    \n    \tvec3 sp = vec3(uv, 0);\n    \tvec3 light = vec3(cos(iTime/2.0)*0.5, sin(iTime/2.0)*0.5, -1.);\n        vec3 ld = light - sp;\n        float lDist = max(length(ld), 0.001);\n        ld /= lDist;  \n        float atten = min(1./(0.25 + lDist*0.5 + lDist*lDist*0.05), 1.);\n    \tvec3 rd = normalize(vec3(uv - 1.0, 1.));\n    \n    \tfloat bump = 50.0;\n\n    \tfloat dxn[3];\n    \tfloat dyn[3];\n    \n    \tdyn[0] = length(d_nw) - length(d_sw);\n        dyn[1] = length(d_n)  - length(d_s); \n        dyn[2] = length(d_ne) - length(d_se);\n    \n    \tdxn[0] = length(d_ne) - length(d_nw); \n        dxn[1] = length(d_e)  - length(d_w); \n        dxn[2] = length(d_se) - length(d_sw); \n    \n    \tfloat spec = 0.0;\n        for(int i = 0; i < 3; i++) {\n            for(int j = 0; j < 3; j++) {\n                vec2 dxy = vec2(dxn[i], dyn[j]);\n                vec3 bn = normalize(vec3(dxy * bump, -1.0));\n                spec += pow(max(dot( reflect(-ld, bn), -rd), 0.), 8.) / 9.0;                 \n            }\n        }\n\n    \t// end bumpmapping section\n    \n    \t// darken areas with a large gradient for an occlusion-like effect\n    \tfloat dd = exp(-1.0 * length(abs(d_n-d_s) + abs(d_e-d_w)));\n    \n    \t// antialias our vector field and image samples by blurring\n    \tvec2 db = 0.4 * d + 0.15 * (d_n+d_e+d_s+d_w);\n        vec3 ib = 0.4 * i + 0.15 * (i_n+i_e+i_s+i_w);\n\n    \tfloat shl =  min(4.0 * exp(-4.0 * max(1.0 - length(db), 0.0)) * dd, 1.0);\n\n    \tvec3 m = shl * mix(vec3(1.2, 0.0, 0.0), 0.5 * vec3(0.9, 0.7, 0.3), shl);\n\n        vec3 texCol = contrast(0.85*ib + m);\n    \tfragColor = vec4((texCol + vec3(0.5, 0.4, 0.3)*spec)*atten, 1.0);\n\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n    A fracturing dynamical system\n\tsee: https://www.shadertoy.com/view/MsyXRW\n*/\n\n#define _G0 0.25\n#define _G1 0.125\n#define _G2 0.0625\n#define W0 10.0\n#define W1 0.3\n#define TIMESTEP 0.1\n#define ADVECT_DIST -4.0\n#define DV 0.70710678\n\n// nonlinearity\nfloat nl(float x) {\n    return 1.0 / (1.0 + exp(W0 * (W1 * x - 0.5))); \n}\n\nvec4 gaussian(vec4 x, vec4 x_nw, vec4 x_n, vec4 x_ne, vec4 x_w, vec4 x_e, vec4 x_sw, vec4 x_s, vec4 x_se) {\n    return _G0*x + _G1*(x_n + x_e + x_w + x_s) + _G2*(x_nw + x_sw + x_ne + x_se);\n}\n\nbool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\nvec4 advect(vec2 ab, vec2 vUv, vec2 step) {\n    \n    vec2 aUv = vUv - ab * ADVECT_DIST * step;\n    \n    vec2 n  = vec2(0.0, step.y);\n    vec2 ne = vec2(step.x, step.y);\n    vec2 e  = vec2(step.x, 0.0);\n    vec2 se = vec2(step.x, -step.y);\n    vec2 s  = vec2(0.0, -step.y);\n    vec2 sw = vec2(-step.x, -step.y);\n    vec2 w  = vec2(-step.x, 0.0);\n    vec2 nw = vec2(-step.x, step.y);\n\n    vec4 u =    texture(iChannel0, fract(aUv));\n    vec4 u_n =  texture(iChannel0, fract(aUv+n));\n    vec4 u_e =  texture(iChannel0, fract(aUv+e));\n    vec4 u_s =  texture(iChannel0, fract(aUv+s));\n    vec4 u_w =  texture(iChannel0, fract(aUv+w));\n    vec4 u_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 u_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 u_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 u_se = texture(iChannel0, fract(aUv+se));\n    \n    return gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n}\n\nvec2 diagH(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    const float xd = sqrt(3.0) / 2.0;\n    const float xi = 1.0 - xd;\n    return 0.5 * ((x + x_v) * xi + (x_h + x_d) * xd);\n}\n\nvec2 diagV(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    const float xd = sqrt(3.0) / 2.0;\n    const float xi = 1.0 - xd;\n    return 0.5 * ((x + x_h) * xi + (x_v + x_d) * xd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    vec2 n  = vec2(0.0, 1.0);\n    vec2 ne = vec2(1.0, 1.0);\n    vec2 e  = vec2(1.0, 0.0);\n    vec2 se = vec2(1.0, -1.0);\n    vec2 s  = vec2(0.0, -1.0);\n    vec2 sw = vec2(-1.0, -1.0);\n    vec2 w  = vec2(-1.0, 0.0);\n    vec2 nw = vec2(-1.0, 1.0);\n\n    vec4 u =    texture(iChannel0, fract(vUv));\n    vec4 u_n =  texture(iChannel0, fract(vUv+texel*n));\n    vec4 u_e =  texture(iChannel0, fract(vUv+texel*e));\n    vec4 u_s =  texture(iChannel0, fract(vUv+texel*s));\n    vec4 u_w =  texture(iChannel0, fract(vUv+texel*w));\n    vec4 u_nw = texture(iChannel0, fract(vUv+texel*nw));\n    vec4 u_sw = texture(iChannel0, fract(vUv+texel*sw));\n    vec4 u_ne = texture(iChannel0, fract(vUv+texel*ne));\n    vec4 u_se = texture(iChannel0, fract(vUv+texel*se));\n    \n    const float vx = 0.5;\n    const float vy = sqrt(3.0) / 2.0;\n    const float hx = vy;\n    const float hy = vx;\n\n    float di_n  = nl(distance(u_n.xy + n, u.xy));\n    float di_w  = nl(distance(u_w.xy + w, u.xy));\n    float di_e  = nl(distance(u_e.xy + e, u.xy));\n    float di_s  = nl(distance(u_s.xy + s, u.xy));\n    \n    float di_nne = nl(distance((diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)), u.xy));\n    float di_ene = nl(distance((diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)), u.xy));\n    float di_ese = nl(distance((diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)), u.xy));\n    float di_sse = nl(distance((diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)), u.xy));    \n    float di_ssw = nl(distance((diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)), u.xy));\n    float di_wsw = nl(distance((diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)), u.xy));\n    float di_wnw = nl(distance((diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)), u.xy));\n    float di_nnw = nl(distance((diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)), u.xy));\n\n    vec2 xy_n  = u_n.xy + n - u.xy;\n    vec2 xy_w  = u_w.xy + w - u.xy;\n    vec2 xy_e  = u_e.xy + e - u.xy;\n    vec2 xy_s  = u_s.xy + s - u.xy;\n    \n    vec2 xy_nne = (diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)) - u.xy;\n    vec2 xy_ene = (diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)) - u.xy;\n    vec2 xy_ese = (diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)) - u.xy;\n    vec2 xy_sse = (diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)) - u.xy;\n    vec2 xy_ssw = (diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)) - u.xy;\n    vec2 xy_wsw = (diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)) - u.xy;\n    vec2 xy_wnw = (diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)) - u.xy;\n    vec2 xy_nnw = (diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)) - u.xy;\n\n    vec2 ma = di_nne * xy_nne + di_ene * xy_ene + di_ese * xy_ese + di_sse * xy_sse + di_ssw * xy_ssw + di_wsw * xy_wsw + di_wnw * xy_wnw + di_nnw * xy_nnw + di_n * xy_n + di_w * xy_w + di_e * xy_e + di_s * xy_s;\n\n    vec4 u_blur = gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n    \n    vec4 auv = advect(u.xy, vUv, texel);\n    \n    vec2 dv = auv.zw + TIMESTEP * ma;\n    vec2 du = u_blur.xy + TIMESTEP * dv;\n\n    if (iMouse.z > 0.0) {\n    \tvec2 d = fragCoord.xy - iMouse.xy;\n        float m = exp(-length(d) / 50.0);\n        du += 0.2 * m * normz(d);\n    }\n    \n    vec2 init = texture(iChannel1, vUv, 4.0).xy;\n    // initialize with noise\n    if((length(u) < 0.001 && length(init) > 0.001) || reset()) {\n        fragColor = 8.0 * (vec4(-0.51) + vec4(init.xy, init.xy));\n    } else {\n        du = length(du) > 1.0 ? normz(du) : du;\n        fragColor = vec4(du, dv);\n    }\n    \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n    A fluid-like dynamical system\n\tsee: https://www.shadertoy.com/view/XddSRX\n*/\n\nbool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\n// reverse advection\nvec4 advect(vec2 ab, vec2 vUv, vec2 step, float sc) {\n    \n    vec2 aUv = vUv - ab * sc * step;\n    \n    const float _G0 = 0.25; // center weight\n    const float _G1 = 0.125; // edge-neighbors\n    const float _G2 = 0.0625; // vertex-neighbors\n    \n    // 3x3 neighborhood coordinates\n    float step_x = step.x;\n    float step_y = step.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, fract(aUv));\n    vec4 uv_n =  texture(iChannel0, fract(aUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(aUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(aUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(aUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(aUv+se));\n    \n    return _G0*uv + _G1*(uv_n + uv_e + uv_w + uv_s) + _G2*(uv_nw + uv_sw + uv_ne + uv_se);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float _K0 = -20.0/6.0; // center weight\n    const float _K1 = 4.0/6.0;   // edge-neighbors\n    const float _K2 = 1.0/6.0;   // vertex-neighbors\n    const float cs = -3.0;  // curl scale\n    const float ls = 0.2;  // laplacian scale\n    const float ps = 0.0;  // laplacian of divergence scale\n    const float ds = -0.2; // divergence scale\n    const float dp = -4.0; // divergence update scale\n    const float pl = 0.1;   // divergence smoothing\n    const float ad = 6.0;   // advection distance scale\n    const float pwr = 1.0;  // power when deriving rotation angle from curl\n    const float amp = 1.0;  // self-amplification\n    const float upd = 0.95;  // update smoothing\n    const float sq2 = 0.6;  // diagonal weight\n    \n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    // 3x3 neighborhood coordinates\n    float step_x = texel.x;\n    float step_y = texel.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, fract(vUv));\n    vec4 uv_n =  texture(iChannel0, fract(vUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(vUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(vUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(vUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(vUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(vUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(vUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(vUv+se));\n    \n    // uv.x and uv.y are the x and y components, uv.z and uv.w accumulate divergence \n\n    // laplacian of all components\n    vec4 lapl  = _K0*uv + _K1*(uv_n + uv_e + uv_w + uv_s) + _K2*(uv_nw + uv_sw + uv_ne + uv_se);\n    \n    // calculate curl\n    // vectors point clockwise about the center point\n    float curl = uv_n.x - uv_s.x - uv_e.y + uv_w.y + sq2 * (uv_nw.x + uv_nw.y + uv_ne.x - uv_ne.y + uv_sw.y - uv_sw.x - uv_se.y - uv_se.x);\n    \n    // compute angle of rotation from curl\n    float sc = cs * sign(curl) * pow(abs(curl), pwr);\n    \n    // calculate divergence\n    // vectors point inwards towards the center point\n    float div  = uv_s.y - uv_n.y - uv_e.x + uv_w.x + sq2 * (uv_nw.x - uv_nw.y - uv_ne.x - uv_ne.y + uv_sw.x + uv_sw.y + uv_se.y - uv_se.x);\n    \n    vec2 norm = normz(uv.xy);\n    \n    float sdx = uv.z + dp * uv.x * div + pl * lapl.z;\n    float sdy = uv.w + dp * uv.y * div + pl * lapl.w;\n\n    vec2 ab = advect(vec2(uv.x, uv.y), vUv, texel, ad).xy;\n    \n    // temp values for the update rule\n    float ta = amp * ab.x + ls * lapl.x + norm.x * ps * lapl.z + ds * sdx;\n    float tb = amp * ab.y + ls * lapl.y + norm.y * ps * lapl.w + ds * sdy;\n\n    // rotate\n    float a = ta * cos(sc) - tb * sin(sc);\n    float b = ta * sin(sc) + tb * cos(sc);\n    \n    vec4 abd = upd * uv + (1.0 - upd) * vec4(a,b,sdx,sdy);\n    \n    fragColor = vec4(abd);\n    \n    vec2 init = texture(iChannel1, vUv, 4.0).xy;\n    // initialize with noise\n    if((length(uv) < 0.001 && length(init) > 0.001) || reset()) {\n        fragColor = 8.0 * (vec4(-0.51) + vec4(init.xy, init.xy));\n    } else {\n        //abd.zw = clamp(abd.zw, -1.0, 1.0);\n        abd.xy = clamp(length(abd.xy) > 1.0 ? normz(abd.xy) : abd.xy, -1.0, 1.0);\n        fragColor = vec4(abd);\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}