{
    "Shader": {
        "info": {
            "date": "1667346750",
            "description": "Here's a somewhat customizable dithering shader that takes an image, crushes its colors, and adds some dithering on top. Does not use the dither texture that comes by default.\n\nDrag the mouse to overlay a gradient on top of the video.\n\nLicense: CC BY 4.0",
            "flags": 32,
            "hasliked": 0,
            "id": "cdXGDn",
            "likes": 3,
            "name": "Limited Color Dithering",
            "published": 3,
            "tags": [
                "dithering",
                "bayer"
            ],
            "usePreview": 0,
            "username": "Mors",
            "viewed": 310
        },
        "renderpass": [
            {
                "code": "// ------------------\n// Epic Dither Shader\n// ------------------\n// by Mors\n// CC BY 4.0\n//\n// Originally written for a secret project, later modified to work in ShaderToy.\n// Should be easy to port to game engines such as GameMaker.\n// Shoutouts to Catonator for providing me with the pattern, and just overall support. :)\n\n\n// Resolution of the base image\nconst vec2 RESOLUTION = vec2(320.0, 180.0);\n\n// Number of colors in each channel\nconst float COLORS_PER_CHANNEL = 8.0;\n\n// Strength of the dithering effect, from 0.0 to 1.0\nconst float DITHER_STRENGTH = 1.0;\n\n// Size of the dither texture\nconst float BAYER_SIZE = 8.0;\n\n// 8x8 bayer ordered dithering pattern. Each input pixel\n// is scaled to the 0..63 range before looking in this table\n// to determine the action\nconst float BAYER_TEXTURE[8 * 8] = float[](\n     0., 32.,  8., 40.,  2., 34., 10., 42.,\n    48., 16., 56., 24., 50., 18., 58., 26.,\n    12., 44.,  4., 36., 14., 46.,  6., 38.,\n    60., 28., 52., 20., 62., 30., 54., 22.,\n     3., 35., 11., 43.,  1., 33.,  9., 41.,\n    51., 19., 59., 27., 49., 17., 57., 25.,\n    15., 47.,  7., 39., 13., 45.,  5., 37.,\n    63., 31., 55., 23., 61., 29., 53., 21.\n    );\n\n\n// Getting the specific pattern from the grid\nfloat getBayer(vec2 uvScreenSpace)\n{\n    vec2 uv = mod(uvScreenSpace.xy / (iResolution.xy / RESOLUTION), BAYER_SIZE);\n    return BAYER_TEXTURE[int(uv.y) * int(BAYER_SIZE) + int(uv.x)] / (BAYER_SIZE * BAYER_SIZE);\n}\n\n// Crushing the colors\nfloat quantize(float channel, float period)\n{\n    return floor((channel + period / 2.0) / period) * period;\n}\n\n// Where the magic happens\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 period = vec3(1.0 / (COLORS_PER_CHANNEL - 1.0));\n    \n    vec3 col = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    col += (getBayer(fragCoord) - 0.5) * period * DITHER_STRENGTH;\n    col = vec3(quantize(col.r, period.r),\n               quantize(col.g, period.g),\n               quantize(col.b, period.b));\n            \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// -----------\n// DOWNSCALING\n// -----------\n\n// Resolution of the base image\nconst vec2 RESOLUTION = vec2(320.0, 180.0);\n\n\n// Crumch\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // This is where we downscale the channel 0 texture for demonstration purposes\n    // Ideally it's better to just serve a low resolution image instead\n    vec2 uv = floor(fragCoord.xy / iResolution.xy * RESOLUTION) / RESOLUTION;\n    vec4 downscaled = texture(iChannel0, uv);\n    \n    // Let's also add a gradient on top so we can showcase more colors\n    vec4 gradient = vec4(sin((uv.x + vec3(0.0, 0.25, 0.5)) * 3.14159265359 / 0.5 + iTime * 0.25), 1.0);\n    gradient = 0.5 + gradient * 0.5;\n\n    // Combine the results\n    float amount = clamp(iMouse.x / iResolution.x * 2.0 - 0.5, 0.0, 1.0);\n    fragColor = mix(downscaled, gradient, amount);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 11,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}