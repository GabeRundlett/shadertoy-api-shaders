{
    "Shader": {
        "info": {
            "date": "1495921002",
            "description": "Parametrized multiharmonic curves. Similar to Lissajous curves (https://en.wikipedia.org/wiki/Lissajous_curve), but with an additional cyclic factor.\n\nSegment-based approximation from https://www.shadertoy.com/view/XdSGzh.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdXBDH",
            "likes": 36,
            "name": "Parametrized curves",
            "published": 3,
            "tags": [
                "2d",
                "oscilloscope",
                "rainbow",
                "parametrized"
            ],
            "usePreview": 0,
            "username": "sheepmaster",
            "viewed": 1348
        },
        "renderpass": [
            {
                "code": "const float PERIOD = 3.5;\n\nconst float RADIUS = 0.8;\n\nconst float LINE_WIDTH = 3.;\n\nconst int NUM_LINE_SEGMENTS = 50;\nconst int NUM_NEWTON_ITERATIONS = 0;\n\nconst int TILE_MIN = -5;\nconst int TILE_MAX = 5;\n\nconst float PI = 4. * atan(1.);\n\n// Smooth HSV to RGB conversion \n// https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth(float hue, float saturation, float value) {\n    vec3 rgb = clamp(abs(mod(hue*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n\n\trgb = rgb*rgb*(3.0-2.0*rgb);  // Cubic smoothing\t\n\n\treturn value * mix(vec3(1.0), rgb, saturation);\n}\n\nvec2 curve(float t, float a, float b, float d) {\n\treturn vec2(\n        sin(a * t + d) * cos(t + d),\n        cos(b * t)     * sin(t + d)\n    );\n}\n\nvec2 curvePrime(float t, float a, float b, float d) {\n    return vec2(\n        a * cos(a * t + d) * cos(t + d) -     sin(a * t + d) * sin(t + d),\n            cos(b * t)     * cos(t + d) - b * sin(b * t)     * sin(t + d)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const int numTiles = TILE_MAX - TILE_MIN + 1;\n    \n    float minRes = min(iResolution.x, iResolution.y);\n    float scale = float(numTiles) / minRes;\n\n    ivec2 tileCoord = ivec2(round((fragCoord - iResolution.xy / 2.) * scale));\n\n\tvec2 uv = 2. * fragCoord * scale - 2. * vec2(tileCoord) - iResolution.xy * scale;\n    \n    // Flip tiles with positive a Y coordinate for symmetry.\n    if (tileCoord.y > 0) {\n        uv.y = -uv.y;\n    }\n\n\tfloat d = (iMouse.w > 0. ? iMouse.y / iResolution.y : iTime / PERIOD) * 2. * PI;\n    float hueOffset = (iMouse.w > 0. ? 4. * iMouse.x / iResolution.x : 0.);\n\n    // If the tile coordinates have different parity,\n    // only half of the period is needed.\n    bool halfPeriod = abs((tileCoord.x * tileCoord.y) % 2) == 1;\n\tfloat tPeriod = halfPeriod ? PI : 2. * PI;\n    vec2 p1 = curve(0., float(tileCoord.x), float(tileCoord.y), d) * RADIUS;\n\tfloat minDist = 1.0;\n    float minT;\n    float t;\n    int numSteps = halfPeriod ? NUM_LINE_SEGMENTS : 2 * NUM_LINE_SEGMENTS;\n    for (int i = 1; i <= numSteps; i++) {\n        t = float(i) / float(numSteps) * tPeriod;\n        vec2 p2 = curve(t, float(tileCoord.x), float(tileCoord.y), d) * RADIUS;\n\n\t\t// Distance to line\n        vec2 pa = uv - p2;\n        vec2 ba = p1 - p2;\n\n        float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n        vec2 q = pa - ba * h;\n\n        float dist = dot(q, q);\n        if (dist < minDist) {\n            minDist = dist;\n            minT = (float(i) - h) / float(numSteps) * tPeriod;\n        }\n        p1 = p2;\n    }\n    \n    t = minT;\n    // TODO: This doesn't work well yet\n    for (int i = 0; i < NUM_NEWTON_ITERATIONS; i++) {\n        vec2 p = curve(t, float(tileCoord.x), float(tileCoord.y), d) * RADIUS;\n        vec2 pPrime = curvePrime(t, float(tileCoord.x), float(tileCoord.y), d) * RADIUS;\n        vec2 uvp = uv - p;\n        float h = dot(uvp, pPrime) / dot(pPrime, pPrime);\n        t += h;\n        vec2 q = uv - (p + pPrime * h);\n        minDist = dot(q, q);\n    }\n\n    float hue = fract(hueOffset + t / tPeriod);\n//    float dist = length(curve(hue * tPeriod, float(tileCoord.x), float(tileCoord.y), d) * RADIUS - uv);\n    \n\tfloat v = smoothstep(LINE_WIDTH * scale, 0.0, sqrt(minDist));\t\n\tfragColor = vec4(hsv2rgb_smooth(hue, 1., v), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}