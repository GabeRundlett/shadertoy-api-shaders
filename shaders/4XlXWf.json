{
    "Shader": {
        "info": {
            "date": "1710406618",
            "description": "Using mod for space repetition, adding random spherical movement for each sphere and radius deformation based on sound. Please suggest how to properly sync sound with animation, it seems like it can be synced much better. Sound only 1 channel?",
            "flags": 0,
            "hasliked": 0,
            "id": "4XlXWf",
            "likes": 1,
            "name": "Dancing Sphere Field",
            "published": 3,
            "tags": [
                "2d",
                "space",
                "flowers",
                "repetion"
            ],
            "usePreview": 0,
            "username": "Friend",
            "viewed": 157
        },
        "renderpass": [
            {
                "code": "#define res_           iResolution\n#define time_          iTime\n#define pi_            3.14159265\n#define tau_           2.*pi_\n\n#define dom(f,s)       (2. * f.xy - res_.xy) / res_.y * s\n\n#define march_steps_   228\n#define hit_perc_      .0001\n#define max_range_     5000.\n\n\nvec2  de(vec3 p, vec4 snd);\nvec3  normal(vec3 p, vec4 snd);\nmat3  look_at(vec3 ro, vec3 ta, float roll);\nfloat fog_exp2(float dist, float dens);\n\nvec3 shsv(float h, float s, float v) {\n    vec3 p = clamp(abs(fract(vec3(h) + vec3(3.0, 2.0, 1.0) / 3.0) * 6.0 - vec3(3.0)) - vec3(1.0), 0.0, 1.0);\n    p = p * p * (3.0 - 2.0 * p); // Apply smoothstep function\n    return v * mix(vec3(1.0), p, s);\n}\n\nfloat rand(vec3 co) {\n    return fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 45.164))) * 43758.5453);\n}\n\n\nvoid mainImage(out vec4 o, vec2 f) {\n\tvec2 p  = dom(f, 1.); vec2 np = f / res_.xy;\n    vec4 snd = texture(iChannel0, f/res_.xy);\n    // Camera\n    // ----------------\n    float r = 20.;\n    float fq = .2;\n    float phi = fq * time_; \n    float theta = mix(\n        0.1 * pi_,\n        0.9 * pi_,\n        sin(0.5 * fq * time_)\n    ); \n\n    vec3 ro = vec3(\n        r * sin(theta) * cos(phi),\n        r * cos(theta),\n        r * sin(theta) * sin(phi)\n    );\n    vec3 target = vec3(0., 0., 0.);\n    mat3 lam = look_at(ro, target, 0.);    \n\tvec3 rd = normalize(lam * vec3(p.xy, 1.5));\n    \n    // Raymarch\n    // ----------------\n    vec3 pos, nor = vec3(0.);\n    float d, step_ , id= 0.;\n    int i = 0;\n    for(i = 0; i < march_steps_; i++) {\n        pos = ro + step_ * rd;\n        \n        vec2 info = de(pos, snd);\n        d   = info.x; id  = info.y;\n        step_ += .7*d;\n        \n    \tif(d < hit_perc_ || d > max_range_) break;    \n    }\n    pos = ro + step_ * rd;\n \tnor = normal(pos, snd);\n    \n    // Shading\n    // ----------------\n    vec3 c = vec3(.0);\n    if(d < hit_perc_) { \n       if (id == 1.0) {                        \n            c += shsv(nor.x/pi_, nor.y, 1.);\n        }\n    }\n\t\n\n\t// Postprocessing\n    //----------------\n    // fog\n    c = mix(c, vec3(0.05), fog_exp2(float(i), .035));\n    // gamma\n\tc = pow( clamp(c, 0.0, 1.0), vec3(.98545) );\n    // final\n    o = vec4(c, 1.);\n}\n\nvec2 de(vec3 p, vec4 snd) {\n    // Apply sound texture effect\n    float ss = texture(iChannel0, vec2(time_, 0.2)).x;\n    float si = ss * 2.0 - 1.0; \n    \n    // Calculate grid position\n    vec3 grid = floor(p / 40.);\n    \n    // Generate a unique pseudo-random radius for spherical movement\n    float radius = mix(2.5, 4.5, rand(grid));  // Random radius between 0.5 and 1.5 units\n    \n    // Generate two unique pseudo-random angles for each sphere based on the grid position\n    float angle1 = rand(grid) * 6.28318530718; // Random angle between 0 and 2*PI\n    float angle2 = rand(grid + vec3(1.0)) * 6.28318530718; // Another unique random angle\n\n    // Calculate the spherical movement for each axis\n    float fq = 5.;\n    vec3 mv = vec3(\n        radius * sin(angle1 + time_ * fq), \n        radius * sin(angle2 + time_ * fq),\n        radius * cos(angle1 + time_ * fq)\n    );\n\n    // Apply the movement to p\n    p += mv;\n    \n    // Normalize the position within the repeating pattern\n    p = mod(p, 40.) - 20.;\n    \n    // Calculate the sphere distance field\n    float d_sp = length(p) - 8.;\n    \n    d_sp -= si * 8.; \n    \n    return vec2(d_sp, 1.0);\n}\n\nfloat fog_exp2(float dist, float dens) {\n  const float log2v = -0.442695;\n  float d = dens * dist;\n  \n  return 1. - clamp(exp2(d*d*d*log2v), 0., 1.);\n}\n\nvec3 normal(vec3 p, vec4 snd) {\n    vec2 e = vec2(hit_perc_, .0);\n    return normalize(vec3(\n        de(p+e.xyy, snd).x-de(p-e.xyy, snd).x,\n        de(p+e.yxy, snd).x-de(p-e.yxy, snd).x,\n        de(p+e.yyx, snd).x-de(p-e.yyx, snd).x\n    ));\n}\n\n\nmat3 look_at(vec3 ro, vec3 ta, float roll) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}