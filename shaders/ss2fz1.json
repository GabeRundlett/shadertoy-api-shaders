{
    "Shader": {
        "info": {
            "date": "1645784169",
            "description": "These are my simple clouds and sky, they're not very optimized, so they're slow",
            "flags": 32,
            "hasliked": 0,
            "id": "ss2fz1",
            "likes": 4,
            "name": "Simple clouds",
            "published": 3,
            "tags": [
                "simple",
                "clouds"
            ],
            "usePreview": 0,
            "username": "MinimilisticBits",
            "viewed": 247
        },
        "renderpass": [
            {
                "code": "//NOT MY CODE//////////////////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n//////////////////////////////////\n\n\nvec3 blur2(vec2 p,float dist){\np*=iResolution.xy;\n    vec3 s;\n    \n    vec3 div = vec3(0.);\n    //vec2 off = vec2(0.0, r);\n    float k = 0.61803398875;\n    for(int i = 0; i < 150; i++){\n    float m = float(i)*0.01;\n    float r = 2.*3.14159*k*float(i);\n    vec2 coords = vec2(m*cos(r), m*sin(r))*dist;\n    vec3 c = texture(iChannel0, vec2(p+coords)/iResolution.xy).xyz;\n    c = c*c *1.0;\n    vec3 bok = pow(c,vec3(4.));\n      s+=c*bok;\n      div += bok;\n    }\n        \n    s/=div;\n    \n    return s;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    for(int i = 0; i < 9; i++){\n        vec2 coords = vec2(float(i%3)-1., float(i/3)-1.)*1.;\n        vec2 fin = (fragCoord+coords)/iResolution.xy;\n        col += texture(iChannel0, fin).xyz;\n    }\n    col /= 9.;\n    \n\n    // Output to screen*/\n    col = pow(col, vec3(1.));\n    col = ACESFilm(col);\n   col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n\n\nfloat RayleighPhase(float cost){\nreturn (3./(16.*3.14159))*(1.0+cost*cost);\n}\n\nfloat p22(float h){\nreturn exp(-h/8500.);\n}\n\nvec3 S(vec3 wave, float cost, float h){\nfloat n = 1.00029;\nfloat N = 2.504;\nfloat a = 3.14159*3.14159*(n*n-1.0)*(n*n-1.0)/2.0;\nfloat b = p22(h)/N;\nvec3 c = 1.0/(wave*wave*wave*wave);\nfloat d = (1.0-cost*cost);\nreturn a*b*c*d;\n}\n\nvec3 B(vec3 wave, float h){\nfloat n = 1.00029;\nfloat N = 2.504;\n\nfloat a = 8.*pow(3.14159,3.)*(n*n-1.0)*(n*n-1.0)/3.;\nfloat b = p22(h)/N;\nvec3 c = 1./wave;\nreturn a*b*c;\n}\n\nvec3 reyleighapprox(vec3 wave, float cost, float h){\nfloat n = 1.00029;\nfloat d = 1432.1;\nfloat a = (1.0+cost*cost)/(2.0*h*h);\nvec3 b = pow(2.*3.14159/wave,vec3(4.));\nfloat c = pow((n*n-1.0)/(n*n+2.),2.);\nfloat d2 = pow(d/2.,6.);\nreturn a*b*c*d2;\n}\n\nfloat CornetteShanksPhase(float costheta, float g){\nfloat a = 3./(8.*3.14159);\nfloat b = (1.0-g*g)*(1.0+costheta*costheta);\nfloat c = (2.0+g*g)*pow(1.0+g*g-2.*g*costheta, 3./2.);\nreturn a*(b/c);\n}\n\nfloat dr(float h){\nreturn exp(h/1200.);\n}\n\nfloat dr2(float h){\nreturn exp(h/8000.);\n}\n\nvec3 boreyleigh(float costheta, vec3 wave){\nfloat n = 1.00029;\nfloat N = 1.504;\nfloat a = 1.0+costheta*costheta;\nfloat v = 3.14159*3.14159*pow(n*n-1., 2.);\nreturn (v/(3.*N*wave*wave*wave*wave*0.000000000002))*a;\n}\n\nvec3 boreyleighconstant(vec3 wave){\nfloat n = 1.00029;\nfloat N = 1.504;\nfloat v = 8.*pow(3.14159, 3.)*pow(n*n-1., 2.);\nreturn (v/(3.*N*wave*wave*wave*wave));\n}\n\nvec3 bommie(float costheta, vec3 wave){\nfloat T = 5.;\nfloat C = (0.6544*T-0.6510);\nvec3 Bm = 0.434*C*3.14159*((4.*3.14159*3.14159)/(wave*wave))*0.67;\nreturn 0.434*C*((4.*3.14159*3.14159)/(wave*wave))*0.5*Bm;\n}\nvec3 bommieconstant(vec3 wave){\nfloat T = 5.;\nfloat C = (0.6544*T-0.6510);\nvec3 Bm = 0.434*C*3.14159*((4.*3.14159*3.14159)/(wave*wave))*0.67;\nreturn Bm;\n}\n\nfloat HenyeyG(float cost, float g){\nreturn (1.0-g*g)/(4.*3.14159*pow(1.0+g*g-2.*cost,3./2.));\n}\n\nfloat ph(float h, float H){\nreturn exp(-(abs(h)/H));\n}\n\nvec3 S(vec3 wave, float h, float H, float cost){\nfloat n = 1.00029;\nfloat N = 2.504*pow(10., 2.);\nfloat a = pow(3.14159,2.)*pow(n*n-1.,2.)/2.;\nfloat b = ph(h, H)/N;\nvec3 c = 1./pow(wave, vec3(4.));\nfloat d = (1.0+cost*cost);\nreturn a*b*c*d;\n}\n//S = B*Y\n\nvec3 B(vec3 wave, float h, float H){\nfloat n = 1.00029;\nfloat N = 2.504*pow(10., 2.);\nfloat a = 8.*pow(3.14159,3.)*pow(n*n-1.,2.)/3.;\nfloat b = ph(h, H)/N;\nvec3 c = 1./pow(wave, vec3(4.));\nreturn a*b*c;\n}\n\nvec3 Bconstant(vec3 wave){\nfloat n = 1.00029;\nfloat N = 2.504*pow(10., 25.);\nfloat a = 8.*pow(3.14159,3.)*pow(n*n-1.,2.)/3.;\nfloat b = 1./N;\nvec3 c = 1./pow(wave, vec3(4.));\nreturn a*b*c;\n}\n\nvec3 BsR(vec3 wave, float h, float H){\nfloat n = 1.00029;\nvec3 N = vec3(2.504)*pow(10., 25.);\nvec3 a = (8.*pow(3.14159,3.)*pow(n*n-1.,2.))/(3.*N*pow(wave,vec3(4.)));\nfloat b = exp(-(h/H));\nreturn a*b;\n}\n\nfloat PM(float cost, float g){\nfloat a = 3./(8.*3.14159);\nfloat b = (1.0-g*g)*(1.0+cost*cost);\nfloat c = (2.0+g*g)*pow(1.0+g*g-2.*g*cost, 3./2.);\nreturn a*(b/c);\n}\n\nfloat PR(float cost){\nreturn (3./(16.*3.14159))*(1.0+cost*cost);\n}\n\nfloat Y(float cost){\nfloat a = 3./(16.*3.14159);\nfloat b = 1.0+cost*cost;\nreturn a*b;\n}\n\nvec3 F(vec3 wave,vec3 wave2, vec3 wave3, vec3 wave4, float s, float cost){\nvec3 br = boreyleighconstant(wave);\nvec3 bm = bommieconstant(wave2);\n\nfloat pr = ph(s, 8500.);\nfloat pm = ph(s, 1200.);\n\nvec3 Br = boreyleigh(cost, wave3);\nvec3 Bm = bommie(cost, wave4);\n\nreturn pr*Br*br*200. + pm*Bm*bm;\n}\n//NOT MY CODE///////////\n bool intersect22(vec3 p,  vec3 C, float size, vec3 d, inout vec2 t){\n \n \t\n\tvec3 o_minus_c = p - C.xyz;\n\n    float p2 = dot(d, o_minus_c);\n    float q = dot(o_minus_c, o_minus_c) - (size * size);\n    \n    float discriminant = (p2 * p2) - q;\n    \n\n    float dRoot = sqrt(discriminant);\n    t.x = -p2 - dRoot;\n    t.y = -p2 + dRoot;\n\n    return true;\n \n }\n vec3 Be(vec3 b0,float h, float H){\nreturn b0*exp(-h/H);\n}\nvec3 Brr(vec3 wave){\nfloat n = 1.029;\nfloat N = 10.;\nreturn 8.*pow(3.14159,3.)*(pow(n*n-1.0, 2.)/(3.*N*wave*wave*wave*wave));\n}\nvec3 sky(vec3 p, vec3 d, vec3 lig) {\n  p = vec3(0., 0., 6400.);\n  vec3 wavelengths = vec3(700., 530., 420.);\n  lig.z = clamp(lig.z, 0., 1.);\n\n  vec2 t = vec2(0.);\n  float reyleighH = 4000.;\n  float MieH = 1200.;\n\n  vec3 accumulateLight = vec3(0.);\n  vec3 accumulateLightMie = vec3(0.);\n  if (intersect22(p, vec3(0., 0., 0.), 6420.0, d, t)) {\n    // col = vec3(t.x);\n    vec3 m = p;\n\n    vec3 cam = p;\n    vec3 fin = p + d * t.y;\n    vec3 div = vec3(fin - cam) / 20.;\n    float mm = length(cam - fin);\n\n    vec3 accum = vec3(0.);\n    vec3 accum11 = vec3(0.);\n    vec3 accum1111 = vec3(0.);\n\n    ///////////////////////////////////\n    float PMMM = PM(max(dot(d, lig), 0.), 0.76);\n    float PRRR = RayleighPhase(max(dot(d, lig), 0.0));\n    vec3 coefficients = vec3(33.1, 13.5, 5.8);\n    float Bs = 110.;\n    vec3 Be0 = Be(coefficients, 0.0, 2000.);\n    // vec3 BRrgb = vec3(6.5, 1.73, 2.30);\n    vec3 BRrgb = Brr(wavelengths * 0.00109);\n    vec3 BMrgb = vec3(0.01);\n    ///////////////////////////////////\n\n    for (int i = 0; i < 20; i++) {\n      accum += ph(max(cam.z - 1660., 0.), reyleighH) * length(div);\n      // accum11 += Bwave(wavelengths*0.01, cam.z, MieH)*length(div);;\n      accum1111 += ph(max(cam.z - 1460., 0.), MieH) * length(div);\n      vec3 accum2 = vec3(0.);\n      vec3 accum222 = vec3(0.);\n      float accum3 = 0.;\n      // energy = energy*(1.0-rayleighcoefficients);\n      if (intersect22(cam, vec3(0., 0., 0.), 6420.0, lig, t)) {\n        vec3 cam2 = cam;\n        vec3 fin2 = cam2 + lig * t.y;\n        vec3 div2 = vec3(fin2 - cam2) / 20.;\n        for (int k = 0; k < 20; k++) {\n          accum2 += max(length(cam2) - 6260., 0.) * length(div2);\n         \n          cam2 += div2;\n        }\n\n        vec3 t1 = BRrgb * accum222 + BMrgb * accum2;\n        vec3 t2 = BRrgb * accum + BMrgb * accum1111;\n\n        accumulateLight +=\n            (exp(-pow(t1 * 0.0054, vec3(1.))) * exp(-t2 * 0.028)) *\n            length(div * 1.) * .0005 * (PRRR * BRrgb * 230. + PMMM * 10.) *\n            mix(vec3(0.9, 0.4, 0.2), vec3(0.9),\n                clamp(dot(lig, vec3(0., 0., 1.)) * 4., 0., 1.));\n\n      }\n\n      if (cam.z < 6360.) {\n        break;\n      }\n      cam += div;\n    }\n    \n  }\n  \n  return max(accumulateLight * 1.4,\n             0.);\n \n}\n\nfloat remap(float v, float l0, float h0, float ln, float hn){\nreturn ln + ((v-l0)*(hn-ln))/(h0-l0);\n}\nvec3 remap(vec3 v, vec3 l0, vec3 h0, vec3 ln, vec3 hn){\nreturn ln + ((v-l0)*(hn-ln))/(h0-l0);\n}\nfloat random3d(vec3 p){\nreturn fract(sin(p.x*214. + p.y*241. + p.z*123.)*100. + cos(p.x*42. + p.y*41.2+p.z*32.)*10.);\n}\n\nfloat worley3d(vec3 p){\nvec3 f = floor(p);\n\nfloat ll = 999.;\nfor(int i = 0; i < 27; i++){\nvec3 coords = vec3(float(i%3)-1., mod(float(i/3)-1., 3.), float(i/9)-1.);\nvec3 col = f+coords;\nvec3 curr = vec3(random3d(col), random3d(col+2.), random3d(col+4.))-0.5;\nfloat len = length((col+curr)-p);\nll = min(ll, len);\n}\nreturn ll;\n\n}\n\nfloat hash(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise222( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbmss(vec3 p)\n{\n    float scale = 0.1;\n    float threshold = 0.3;\n    float sum = 0.;\n        p += vec3(5., 0., 0.);\n        for(int i = 1; i <= 8; i++)\n        {\n            sum += noise222((p+vec3(iTime, iTime,iTime)*0.5) * scale * pow(2., float(i))) / pow(1.7, float(i));\n        }\n        return max(sum - threshold, 0.);\n}\nfloat fbm(vec3 p, vec3 cam){\n\n\nfloat b = fbmss(p*0.1);\n\n  float Srb = clamp(\n      remap(clamp((cam.z - 200.) / 15., 0., 0.09), 0., 0.09, 0., 1.), 0., 1.);//a *= clamp(abs(length(p)-6500.)*0.00013, 0.0, 1.);\n\nreturn clamp((Srb)*b,0.,1.);\n}\n\n\n\nfloat noise(vec3 p){\nreturn fract(sin(p.x * 23. + p.y * 241.4 + p.z*52.)*100. + cos(p.x * 234. + p.y * 21.4 + p.z*542.)*124.);\n}\n\n\nvec4 clouds2(vec3 p, vec3 d, vec3 lig, inout float dist) {\n  vec3 befo = p;\n \n  float transmission = 1.0;\n  vec3 Ex = vec3(1.0);\n\n \n  vec3 accumulateLight = vec3(0.);\n\n  vec3 ccc = p;\n  vec3 cam = p;\n\n  vec3 accum = vec3(0.);\n  float minus = 0.20;\n  float mult = 1.0;\n\n \n  vec3 sky2 = sky(vec3(0.), lig, lig)*0.1;\n  float pr2 = PR(max(dot(d, lig), 0.));\n  float keepdensity = 0.;\n  bool firsth = false;\n  vec3 firstHit = p;\n  for (int i = 0; i < 150; i++) {\n    float density =\n        max(fbm(cam * mult, cam) - minus - abs(cam.z - 220.) * 0.01, 0.);\n    density = clamp(density, 0., 1.);\n    density = 1.0 - pow(1.0 - density, 4.);\n    if (density > 0.00001) {\n      if (!firsth) {\n        dist = length(cam - ccc);\n        firsth = true;\n        firstHit = cam;\n      }\n      accum += density * 10.6;\n      // accum11 += ph(length(cam)-6500., MieH)*length(div);\n\n      vec3 accum2 = vec3(0.);\n      // float accum3 = 0.;\n      // energy = energy*(1.0-rayleighcoefficients);\n      vec3 cam2 = cam;\n\n      for (int k = 0; k < 13; k++) {\n        float density2 = max(\n            fbm(cam2 * mult, cam2) - minus - abs(cam2.z - 220.) * 0.01, 0.);\n        // density2 = smoothstep(0.,1.,density2);\n        density2 = clamp(density2, 0., 1.);\n        density2 = 1.0 - pow(1.0 - density2, 4.);\n\n        // accum2 += ph(cam2.z, 1300.)*30.;\n        accum2 += density2 * 20.1;\n        // accum3 += ph(length(cam2)-6500., MieH)*length(div2);\n        cam2 += lig * (1. - 0.2 * random3d(cam2));\n      }\n\n      transmission *= 1.0 - density;\n\n    \n      float octave = 0.;\n\n      for (int i = 0; i < 8; i++) {\n   \n        vec3 pm2 = vec3((PM(max(dot(d, lig), 0.), 0.76))) * 140. +\n                   vec3((PM(max(dot(d, lig), 0.), pow(0.5, octave)))) * 13.5 +\n                   vec3((PM(max(dot(d, lig), 0.), -0.5))) * 40.;\n       //  pm2 *= mix(vec3(0.9,0.6,0.2), vec3(0.9), max(dot(lig, vec3(0.,\n       //  0., 1.)), 0.));\n           vec3 colr = vec3(0.9, 0.5, 0.1);\n        accumulateLight +=\n            (1. - exp(-density * 0.6)) * density * transmission *\n            (pm2 + pr2 * 12.*sky2) * pow(0.5, octave) * 3. * sky2 *\n            (exp(-accum2 * 0.05 * pow(.5, octave)) * exp(-accum * 0.1));\n\n        octave += 0.2;\n      }\n\n    } \n\n    cam += d * (3. - 0.5 * random3d(cam));\n    if(transmission < 0.5 || cam.z < 210.){\n        break;\n    }\n  }\n \n  return vec4(accumulateLight * 1.3, transmission);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    \n    int tiles = 4;\n    int samples = 20;\n    //jk = float(iFrame%samples);\n\n    vec2 res = iResolution.xy / float(tiles);\n    int times = (iFrame/samples);\n    vec2 time = vec2(float(times%tiles), float((times/tiles)%(tiles)));\n    vec2 rr = res*time;\n    bool wtf = false;\n    //if(check == 1.){\n   //if(fragCoord.x < (rr.x) || fragCoord.x > (rr.x+res.x))discard;\n   //if(fragCoord.y < (rr.y) || fragCoord.y > (rr.y+res.y))discard;\n    \n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    \n    vec3 d = normalize(vec3(uv.x, 1., uv.y));\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    d.yz = rot(d.yz, mouse.y*90.);\n    d.xy = rot(d.xy, -mouse.x*180.);\n\n    vec3 lig = normalize(vec3(0., 0.6, 0.09));\n  \n    vec3 skys = sky(vec3(0.), d, lig);\n    vec3 final = vec3(0.);\n    \n    float dist = 0.;\n    vec4 mmm = clouds2(vec3(0.,0.,260.),d,lig,dist);\n\n    //vec3 final = skys;\n    final = final*mmm.w + pow(mmm.xyz, vec3(1.3));\n    float f = exp(-dist * .002);\n   // final.xyz = final.xyz * f + skys.xyz * (1.0 - f);\n    \n    // Output to screen\n    fragColor = vec4(final,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float pi = 3.14159;\nvec2 rot(vec2 a, float c){\nfloat g = c*pi/180.;\nfloat l = length(a);\na = normalize(a);\nfloat ang = atan(a.y,a.x)+g; \nreturn vec2(l*cos(ang),l*sin(ang));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}