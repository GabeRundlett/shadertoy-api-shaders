{
    "Shader": {
        "info": {
            "date": "1561959373",
            "description": "Inspired by [url=https://twitter.com/SeanWal49402031/status/1188159030436487168]Sean Walker's gifs[/url]\n\n[b]VARIATIONS:[/b] [url]https://twitter.com/c010011012/status/1275841326408318979[/url]\n\nI only check 9 spheres per pixel >:â€‹)",
            "flags": 0,
            "hasliked": 0,
            "id": "3lXXR8",
            "likes": 22,
            "name": "sphere vortex",
            "published": 3,
            "tags": [
                "conformal",
                "complexanalysis",
                "raytacing",
                "skymap"
            ],
            "usePreview": 0,
            "username": "cmarangu",
            "viewed": 1101
        },
        "renderpass": [
            {
                "code": "// /*\n// Current code for: \"sphere vortex\"\n// Started: 2020 2/14 (before then)\n// Tags: conformal, raytacing, skymap, complexanalysis\n// Description: wip\n// - Updated: 2020 3/21 cleaned up the code by making it\n//   alot longer but more precise, now you can rotate view, started\n//   raymarching solution (slower but more accurate)\n// - Updated: 2020 4/1 worked on the shading, added more features\n// - Updated: 2020 4/8 starting from scratch again to get the shading right\n// - Updated: 2020 5/29 going to store phase level with coords in vec3's\n//   - Trying to clean up code and have necessary features\n//   - Adding a complex_pow function which can raise any vec2 to the power of another\n// - Updated: 2020 5/30 I think I've mostly fixed problems with phase_level by implementing\n//   code which stores the integer representing the actual phase in an array, but the \"array\"\n//   is actually a \"stack\" of integers represented by 1 other integer (its complicated)\n// - Updated: 2020 3/20 replaced this nonsense weave_ints and untwine_int functions\n//   with normal float arrays. Been toying with phase plotters like the davidbau.com one to\n//   find new vortecies (like a triple vortex and others)\n\n// TODO\n// clean up code a bit (i guess)\n// project is mostly finished\n// distribute across time between frames? motion blur/frame blending\n\n\n\n\n#define arg mod(float(iFrame)/30., 1.)\n#define PI 3.141592653589793238462643383279502884197169399375105820974944592307816\n// i know more\n#define TAU (2.*PI)\n\n#define sphere_scaling 1.\n\n\n\n\n// sky map\n#define sund normalize(vec3(2.5, 1.5, -.5))\n\nvec3 sky_map (vec3 d) {\n\tfloat dimness = .5+.5*cos(d.y*PI);\n\tdimness = pow(dimness, 1.);\n\t\n\t// return texture(iChannel1, d).rgb;\n\t\n\tvec2 g = vec2(d.x/d.y, d.z/d.y)*2.*sign(d.y);\n\t\n\t// get ths sky color\n\tfloat cloudamt = 0.;\n\tcloudamt += .7*texture(iChannel1, vec2(g.x+g.y, g.x-g.y)/430.).r;\n\tcloudamt += .3*texture(iChannel1, vec2(g.x+g.y, g.x-g.y)/150.).r;\n\tcloudamt = pow(cloudamt, 2.);\n\t\t// cloudamt *= .4;\n\t\t// cloudamt += .0*texture(iChannel1, vec2(g.x+g.y, g.x-g.y)/90.).r;\n\t\tfloat sunamt = clamp(dot(d, sund), 0., 1.);\n\t\tfloat sunglow = pow(sunamt, 20.);\n\t\t\n\t\tvec3 SKY_COLOR = vec3(.0, .5, 1.);\n\t\tSKY_COLOR += cloudamt;\n\t\t// SKY_COLOR *= 1.-sunhalo;\n\t\t// SKY_COLOR += vec3(1., .9, .6)*sunhalo;\n\t\tSKY_COLOR *= 1.-sunglow;\n\t\tSKY_COLOR += vec3(1., 1., 1.)*sunglow;\n\t\t\n\t\tdimness = mix(dimness, 1., sunglow);\n\t\t// dimness = mix(dimness, 1., sunhalo);//sunamt*sunamt);\n\tif (d.y > .2) {\n\t\treturn SKY_COLOR*pow(dimness, .05)*mix(.7, 1., sunglow);\n\t}\n\telse {\n\t\t// return vec3(1.)*mod(floor(g.x)+floor(g.y), 2.);\n\t\tvec3 GROUND_COLOR = vec3(.3, .5, .3)*(.0+.8*texture(iChannel1, g/10.).r);\n\t\tfloat dirtamt = texture(iChannel1, g/54.).r;\n\t\tGROUND_COLOR *= 1.-dirtamt;\n\t\tGROUND_COLOR += vec3(.5, .3, .0)*dirtamt;\n\t\t\n\t\tGROUND_COLOR = 3.*GROUND_COLOR*GROUND_COLOR-2.*GROUND_COLOR*GROUND_COLOR*GROUND_COLOR;\n\t\tGROUND_COLOR = 3.*GROUND_COLOR*GROUND_COLOR-2.*GROUND_COLOR*GROUND_COLOR*GROUND_COLOR;\n\t\tGROUND_COLOR = 3.*GROUND_COLOR*GROUND_COLOR-2.*GROUND_COLOR*GROUND_COLOR*GROUND_COLOR;\n\t\tGROUND_COLOR *= 17.;\n\t\tGROUND_COLOR = clamp(GROUND_COLOR, 0., 1.);\n\t\t\n\t\tfloat puddleamt = .5+.5*sin(g.x*length(g)*.05);\n\t\tpuddleamt = .5*puddleamt+.5*texture(iChannel1, vec2(g.x, g.y)/20.).r;\n\t\tpuddleamt = pow(puddleamt, .3);\n\t\tdimness = mix(dimness, 1., puddleamt)*.5;\n\t\t\n\t\tif (puddleamt > .8) {\n\t\t\tfloat amt = (puddleamt-.3)/.6;\n\t\t\tamt = clamp(amt, 0., 1.);\n\t\t\tamt = pow(amt, 2.);\n\t\t\tGROUND_COLOR = mix(GROUND_COLOR, SKY_COLOR+vec3(.4), amt);\n\t\t}\n\t\t\n\t\tif (-.2 <= d.y && d.y <= .2) {\n\t\t\tfloat amt = (d.y+.2)/.4;\n\t\t\tdimness = mix(\n\t\t\t\tdimness,\n\t\t\t\tmix(\n\t\t\t\t\tdimness*2.,\n\t\t\t\t\t1.,\n\t\t\t\t\t-puddleamt\n\t\t\t\t),\n\t\t\t\tamt\n\t\t\t);\n\t\t\tamt = 3.*amt*amt-2.*amt*amt*amt;\n\t\t\tamt = 3.*amt*amt-2.*amt*amt*amt;\n\t\t\tamt = 3.*amt*amt-2.*amt*amt*amt;\n\t\t\tGROUND_COLOR = mix(GROUND_COLOR, SKY_COLOR, amt);\n\t\t}\n\t\treturn GROUND_COLOR*dimness*mix(0., 1., clamp(abs(d.y)*12., 0., 1.));\n\t\n\t}\n\t\n}\n\n\n\n\n// conformap transforms\n\n#define complex_exp(z) vec3(exp(z.x)*vec2(cos(z.y), sin(z.y)), floor(z.y/TAU) )\n#define complex_ln(Z) vec3(\\\n\tlog(length(Z.xy)),\\\n\tmod(atan(Z.y, Z.x), TAU)+Z.z*TAU,\\\n\tZ.z\\\n)\n\nvec3 complex_multZK (vec3 z, vec3 k) {\n\tfloat th = mod(atan(z.y, z.x), TAU)+z.z*TAU;\n\tfloat ph = mod(atan(k.y, k.x), TAU)+z.z*TAU;\n\treturn vec3(\n\t\t(length(z.xy)*length(k.xy))*vec2(cos(th+ph), sin(th+ph)),\n\t\tfloor(th/TAU+ph/TAU)\n\t);\n}\n\nvec3 complex_powZK (vec3 z, vec3 k) {\n\tfloat th = mod(atan(z.y, z.x), TAU)+z.z*TAU;\n\treturn vec3(\n\t\tpow(length(z.xy), k.x)*vec2(cos(th*k.x), sin(th*k.x)),\n\t\tfloor(th*k.x/TAU)\n\t);\n}\n\n#define phaselen 3\n\nvec3 f (vec3 z, float[phaselen] phaselvl) {\n\t#define scl 26./TAU\n\t#define zoom 1.3\n\t#define pan vec2(0., 0.)\n\tint lvli = phaselen-1;\n\t\n\tz.x -= arg;\n\t\n\tz.xy /= scl;\n\t\n\t#if 1\n\tz.z = phaselvl[lvli];\n\t--lvli;\n\t//z = complex_multZK(z, vec3(.5, -.5, -1.) );\n\tz.xy = vec2(z.x*.5+z.y*.5, -z.x*.5+z.y*.5);\n\tz = complex_exp(z);\n\t#endif\n\t\n\t#if 0\n\t// complex arctangent\n\t// atan(z) = (1/2i)ln(-z+i/z+i)\n\tz.z = phaselvl[lvli];\n\t--lvli;\n\tz = complex_multZK(\n\t\tvec3(0., 1., 0.)+complex_multZK(z, vec3(-1., 0., 0.) ),\n\t\tcomplex_powZK(\n\t\t\tvec3(0., 1., 0.)+z,\n\t\t\tvec3(-1., 0., 0.)\n\t\t)\n\t);\n\tz.z = phaselvl[lvli];\n\t--lvli;\n\tz = complex_ln(z);\n\tz = complex_multZK(z, vec3(0., -.5, 0.));\n\t#endif\n\t\n\t\n\t// mobius\n\tz.x += .2;\n\tfloat th = mod(atan(z.y, z.x), TAU)+z.z*TAU;\n\tz.xy = vec2(cos(-th), sin(-th))/length(z.xy);\n\tz.x -= 2.;\n\t\n\t//z.xy = vec2(z.x*.5+z.y*.5, -z.x*.5+z.y*.5);\n\t\n\tz.xy *= zoom;\n\tz.xy += pan;\n\treturn z;\n\t\n}\nvec3 inv_f (vec3 z, out float[phaselen] phaselvl) {\n\tint lvli = 0;\n\t\n\tz.xy -= pan;\n\tz.xy /= zoom;\n\t\n\t//z.xy = vec2(z.x-z.y, z.x+z.y);\n\t\n\t// mobius\n\tz.x += 2.;\n\tfloat th = mod(atan(z.y, z.x), TAU)+z.z*TAU;\n\tz.xy = vec2(cos(-th), sin(-th))/length(z.xy);\n\tz.x -= .2;\n\t\n\t#if 0\n\t// complex tangent\n\t// 2i*z then e^z then blah\n\t// tan(z) = blah(  iz-i/-z-1  )\n\tz = complex_multZK(z, vec3(0., 2., 0.));\n\tz = complex_exp(z);\n\tphaselvl[lvli] = z.z;\n\t++lvli;\n\tz = complex_multZK(\n\t\tvec3(0., -1., 0.)+complex_multZK(z, vec3(0., 1., 0.)),\n\t\tcomplex_powZK(\n\t\t\tvec3(-1., 0., 0.)+complex_multZK(z, vec3(-1., 0., 0.)),\n\t\t\tvec3(-1., 0., 0.)\n\t\t)\n\t);\n\tphaselvl[lvli] = z.z;\n\t++lvli;\n\t#endif\n\t\n\t#if 1\n\tz = complex_ln(z);\n\t//z = complex_multZK(z, vec3(1., 1., 0.));\n\tz.xy = vec2(z.x-z.y, z.x+z.y);\n\tphaselvl[lvli] = z.z;\n\t++lvli;\n\t#endif\n\t\n\tz.xy *= scl;\n\t\n\tz.x += arg;\n\t\n\t\n\treturn z;\t\n}\n\n\n\n// related to tracing onto various surfaces\n#define inter_sky vec4(vec3(0.), 1e9)\n\nvec4 inter_sphere (vec3 p, vec3 d, vec3 c, float r, bool insideout) {\n\t// if 1 to use raymarching for slower but more accurate sphere intersections\n\t#if 0\n\t\n\tif (!insideout) {\n\t\tfloat w1 = 1e9;\n\t\tr *= 1.5;\n\t\tfloat bsign = !insideout ? -1. : 1.;\n\t\tvec3 bar = c-p;\n\t\tfloat h = length(bar);\n\t\tfloat a = h*dot(normalize(bar), d);\n\t\tfloat o = sqrt(h*h-a*a);\n\t\tif (o <= r) {\n\t\t\tfloat bevel = sqrt(r*r-o*o);\n\t\t\tvec3 hitp = p+d*(a+bsign*bevel);\n\t\t\tw1 = a+bsign*bevel;\n\t\t\tp += d*w1;\n\t\t}\n\t\tr /= 1.5;\n\t}\n\tvec3 camp = p;\n\tfloat SDFp = length(p-c)-r;\n\tp += d*abs(SDFp)*.2;\n\tint hits = 0;\n\tfor (int mrch=0; mrch<260; ++mrch) {\n\t\tSDFp = length(p-c)-r;\n\t\tif (mrch > 5 && SDFp > 10.) {\n\t\t\tbreak;\n\t\t}\n\t\tif (abs(SDFp) < 1e-3) {\n\t\t\tif (insideout && hits < 1) {\n\t\t\t\thits++;\n\t\t\t\tp += d*SDFp;\n\t\t\t\tp += d*1e-2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn vec4(\n\t\t\t\t\tnormalize(p-c),\n\t\t\t\t\tlength(p-camp)//*sign(length(p-c)-r)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tp += d*abs(SDFp)*.99;\n\t}\n\treturn inter_sky;\n\t#endif\n\tfloat bsign = !insideout ? -1. : 1.;\n\tvec3 bar = c-p;\n\tfloat h = length(bar);\n\tfloat a = h*dot(normalize(bar), d);\n\tfloat o = sqrt(h*h-a*a);\n\tif (o <= r) {\n\t\tfloat bevel = sqrt(r*r-o*o);\n\t\tvec3 hitp = p+d*(a+bsign*bevel);\n\t\treturn vec4(\n\t\t\tnormalize(hitp-c),\n\t\t\ta+bsign*bevel\n\t\t);\n\t}\n\treturn inter_sky;\n}\n\n\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\t///*\n\t#define spp 1\n\tvec3 finalCol = vec3(0.);\n\tvec3 randy; randy = vec3(0.);\n\t#if spp == 1\n\t#define samplei 0.\n\t#else\n\tfor (float samplei=0.; samplei<float(spp); ++samplei) {\n\t#endif\n\t\t\n\t\t#if 0\n\t\trandy = vec3(\n\t\t\tfract(sin(\n\t\t\t\tmod(\n\t\t\t\t\tsamplei*21.463049023049+float(iFrame+int(fragCoord.x) )*0.021415,\n\t\t\t\t\tTAU\n\t\t\t\t)\n\t\t\t)),\n\t\t\tfract(sin(\n\t\t\t\tmod(\n\t\t\t\t\tsamplei*421.83743204984+float(iFrame+int(fragCoord.x) )*8.234203,\n\t\t\t\t\tTAU\n\t\t\t\t)\n\t\t\t)),\n\t\t\tfract(sin(\n\t\t\t\tmod(\n\t\t\t\t\tsamplei*952.13454543556+float(iFrame)*8.234203,\n\t\t\t\t\tTAU\n\t\t\t\t)\n\t\t\t))\n\t\t);\n\t\t#endif\n\t\t\n\t\tvec2 screen = vec2(fragCoord+randy.xy-iResolution.xy/2.)/iResolution.y;\n\t\tvec3 camp = vec3(0., 0., 0.);\n\t\tvec3 camd = normalize(vec3(screen.x, screen.y, 1.));\n\t\t\n\t\t\n\t\tvec4 inter_closest = inter_sky;\n\t\tint closest_id;\n\t\tvec3 closest_center = vec3(0.);\n\t\tfloat closest_r = 0.;\n\t\t\n\t\tvec2 zxy = screen*5.;\n\t\tvec3 z = vec3(zxy, 0.);\n\t\t\n\t\tfloat[phaselen] phaselvl;\n\t\tfloat[phaselen] phaselvl2;\n\t\t\n\t\tvec3 guess2 = inv_f(z, phaselvl);\n\t\tphaselvl2 = phaselvl;\n\t\tguess2.xy = floor(guess2.xy);\n\t\tvec3 guess;\n\t\t\n\t\t\n\t\t\n\t\tfloat lvli;\n\t\tfor (float ox=-1.; ox<=1.; ++ox) {\n\t\tfor (float oy=-1.; oy<=1.; ++oy) {\n\t\t#define phaseoff 0\n\t\t#if phaseoff\n\t\t//for (float oP=0.; oP<pow(3., float(phaselen)); ++oP) {\n\t\tfor (float oP=0.; oP<pow(3., 1.); ++oP) {\n\t\t#else\n\t\t#define oP 0.\n\t\t#endif\n\t\t\tguess = guess2;\n\t\t\tguess.xy = guess.xy+vec2(.5, .5)+vec2(ox, oy);\n\t\t\t//guess.z = guess.z+oP;\n\t\t\t\n\t\t\tphaselvl = phaselvl2;\n\t\t\t#if phaseoff\n\t\t\tphaselvl[0] += mod(oP, 3.)-1.;\n\t\t\t//for (lvli=0.; lvli<phaselen; ++lvli) {\n\t\t\t//  phaselvl[int(lvli)] += mod(floor(oP/pow(3., lvli)), 3.)-1.;\n\t\t\t//}\n\t\t\t#endif\n\t\t\t\n\t\t\t#if 1\n\t\t\t// does not use 3 points method\n\t\t\tvec2 cen = f(guess, phaselvl).xy;\n\t\t\tfloat r = length(f(guess+vec3(.07, 0., 0.), phaselvl).xy-cen.xy)/.07*.5;\n\t\t\tr = min(r, length(f(guess+vec3(0., .07, 0.), phaselvl).xy-cen.xy)/.07*.5);\n\t\t\t#else\n\t\t\t// uses 3 points method\n\t\t\tvec2 a = f(guess+vec3(0., .5, 0.), phaselvl, randy).xy;\n\t\t\tvec2 cen = circle_from3pts(\n\t\t\t\ta,\n\t\t\t\tf(guess+vec3(-.5, 0., 0.), phaselvl).xy,\n\t\t\t\tf(guess+vec3(0., -.5, 0.), phaselvl).xy\n\t\t\t);\n\t\t\tfloat r = length(a.xy-cen.xy);\n\t\t\t#endif\n\t\t\tvec3 sphc = vec3(cen.x, cen.y, 5.);\n\t\t\tr *= sphere_scaling;\n\t\t\tif (r > 10.) { continue; }\n\t\t\tr = min(r, .5);\n\t\t\t//r = max(r, .00001);\n\t\t\t\n\t\t\t// only check blue spheres cos its cooler\n\t\t\t// cover up ugly floating point artifacts/white noise\n\t\t\t// if (max(abs(guess.y), abs(guess.x*.9)) > 3e1) { continue; }\n\t\t\t//if (r < .002) { continue; }\n\t\t\t\n\t\t\tvec4 inter_current = inter_sphere(\n\t\t\t\tcamp, camd, sphc, r, false\n\t\t\t);\n\t\t\t\n\t\t\t\n\t\t\tif (inter_current.w < inter_sky.w) {\n\t\t\t\tif (inter_closest.w >= inter_sky.w) {\n\t\t\t\t\tinter_closest = inter_current;\n\t\t\t\t\tclosest_center = sphc;\n\t\t\t\t\tclosest_r = r;\n\t\t\t\t\tclosest_id = 1+1*int( mod(guess.y, 2.) );\n\t\t\t\t}\n\t\t\t\telse if (inter_current.w < inter_closest.w) {\n\t\t\t\t\tinter_closest = inter_current;\n\t\t\t\t\tclosest_center = sphc;\n\t\t\t\t\tclosest_r = r;\n\t\t\t\t\tclosest_id = 1+1*int( mod(guess.y, 2.) );\n\t\t\t\t}\n\t\t\t}\n\t\t}}\n\t\t#if phaseoff\n\t\t}\n\t\t#endif\n\t\t\n\t\t\n\t\t// rendering lol\n\t\tvec3 retina = vec3(0., 0., 100./255.);\n\t\tif (inter_closest.w < inter_sky.w) {\n\t\t\t// There is a sphere, shade it\n\t\t\tvec3 specular = sky_map(reflect(camd, inter_closest.xyz));\n\t\t\tfloat specularh = length(specular)/sqrt(3.);\n\t\t\t\n\t\t\t\n\t\t\tif (closest_id == 1) {\n\t\t\t\t// pearly white\n\t\t\t\tfloat diffuse = clamp(dot(inter_closest.xyz, sund), 0., 1.);\n\t\t\t\t// specularh = 3.*specularh*specularh-2.*specularh*specularh*specularh;\n\t\t\t\tspecularh = pow(specularh, 4.);\n\t\t\t\tretina = vec3(.53)+vec3(.6)*diffuse+specularh*.7;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// heres for blue bubble\n\t\t\t\tvec4 inter_inside = inter_sphere(camp, camd, closest_center, closest_r, true);\n\t\t\t\tvec2 glob = vec2(\n\t\t\t\t\t.5+.5*dot(inter_inside.xyz, normalize(vec3(0., -1., .5)) ),\n\t\t\t\t\t.5+.5*dot(inter_closest.xyz, normalize(vec3(0., -1., .5)) )\n\t\t\t\t);\n\t\t\t\tfloat glo = length(glob)/sqrt(2.);\n\t\t\t\t\n\t\t\t\tglo = 3.*glo*glo-2.*glo*glo*glo;\n\t\t\t\tglo = pow(glo, 1.7);\n\t\t\t\t\n\t\t\t\tspecularh = 3.*specularh*specularh-2.*specularh*specularh*specularh;\n\t\t\t\tspecularh = pow(specularh, 1.5);\n\t\t\t\t\n\t\t\t\tfloat glo2 = pow(glo, 2.);\n\t\t\t\tretina = vec3(.0, .3, .5) + vec3(.0*glo2, .5*glo2, .5*glo) + vec3(1.)*specularh*.95;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfinalCol += retina;\n\t#if spp != 1\n\t}\n\t#endif\n\tfinalCol /= float(spp);\n\tfragColor = vec4(finalCol, 1.);/*/\n\tfloat phaselvl[phaselen];\n\tvec2 screen = (fragCoord.xy-iResolution.xy/2.)/iResolution.y;\n\tvec3 z = vec3(screen.xy*5., 0.);\n\tz = inv_f(z, phaselvl);\n\tfloat a = mod(z.x, 1.);\n\tfloat b = mod(z.y, 1.);\n\tfragColor = vec4(min(a, b), a, max(a, b), 1.);\n\t/**/\n}\n\n\n\n\n\n\n\n\n\n\n\n// Old code for: \"some circle inversion nonsense\"\n// Created: 2019-07-01\n// Tags: blue, circleinversion, cyan, inversegeometry\n// Description: \"inverting points across a circle whose\n//               center and radius vary by the mouse position\n//               and then finding what their colors are on the\n//               tiling of the plane\"\n// // speeds can be anything from -1 to 1\n// \n// \n// float speedx = 0.25;\n// float speedy = 0.25;\n// \n// vec2 invrted(vec2 p, vec2 cc, float cr) {\n// \tfloat r2 = cr*cr/length(p-cc);\n// \treturn cc+r2*vec2(p-cc)/length(p-cc);\n// }\n// \n// vec3 col(vec2 p) {\n//     p.x = mod(p.x+1000.0+iTime*speedx, 1.0);\n//     p.y = mod(p.y+1000.0+iTime*speedx, 1.0);\n//     float th = sin(atan(p.y-0.5, p.x-0.5)*2.0+iTime*5.0)/2.0+0.5;\n//     float rd = length(vec2(p.x-0.5, p.y-0.5))*sqrt(2.0);\n//     // /*\n//     p.x *= 256.0;\n//     p.y *= 256.0;\n//     th = float(int(p.x)^int(p.y));\n//     rd = mod((p.x+p.y)*2.0, 256.0);\n//     th /= 256.0;\n//     rd /= 256.0;\n// \t/**/\n//     /*\n//     th = p.x;\n//     rd = p.y;\n//     /**/\n//     return vec3(min(th, rd), th, max(th, rd));\n// }\n// \n// void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n//     // Normalized pixel coordinates (from 0 to 1)\n//     vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.x;\n//     \n//     vec2 maus = (iMouse.xy-iResolution.xy/2.0)/iResolution.x;\n//     \n//     vec2 p = invrted(\n//         uv,\n//         maus,\n//         length(maus)*length(maus)*12.0\n//     );\n//     \n//     // Output to screen\n//     fragColor = vec4(col(p),1.0);\n//     \n// \n//}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}