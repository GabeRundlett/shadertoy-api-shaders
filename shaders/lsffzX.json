{
    "Shader": {
        "info": {
            "date": "1497392393",
            "description": "This one was fun to make. I tried to pack a lot more effects into this shader than my usual efforts -- lots of bumpmapping and fake refraction. Plus since there's no \"real\" 3D geometry, it wasn't too hard to antialias.",
            "flags": 0,
            "hasliked": 0,
            "id": "lsffzX",
            "likes": 20,
            "name": "slimy triangular truchet",
            "published": 3,
            "tags": [
                "triangle",
                "truchet",
                "slime",
                "slimy"
            ],
            "usePreview": 1,
            "username": "mattz",
            "viewed": 1266
        },
        "renderpass": [
            {
                "code": "/* slimy triangular truchet, by mattz\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Use mouse to change lighting.\n\n   flockaroo's \"silver tilings\" (https://www.shadertoy.com/view/XsXfz2) got me thinking\n   about triangular truchet tilings, and I ended up with this odd creation.\n\n */\n\nconst float s3 = 1.7320508075688772;\nconst float i3 = 0.5773502691896258;\n\nconst mat2 tri2cart = mat2(1.0, 0.0, -0.5, 0.5*s3);\nconst mat2 cart2tri = mat2(1.0, 0.0, i3, 2.0*i3);\n\n/////////////////////////////////////////////////////////////////////////////\n\n// from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n\n// from https://www.shadertoy.com/view/XsXfRH\n// return value noise (in x) and its derivatives (in yzw)\nvec4 noised( in vec3 x ) {\n    \n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n#if 1\n    // quintic interpolation\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n#endif    \n    \n    \n    float a = hash13(p+vec3(0.0,0.0,0.0));\n    float b = hash13(p+vec3(1.0,0.0,0.0));\n    float c = hash13(p+vec3(0.0,1.0,0.0));\n    float d = hash13(p+vec3(1.0,1.0,0.0));\n    float e = hash13(p+vec3(0.0,0.0,1.0));\n\tfloat f = hash13(p+vec3(1.0,0.0,1.0));\n    float g = hash13(p+vec3(0.0,1.0,1.0));\n    float h = hash13(p+vec3(1.0,1.0,1.0));\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// fractal brownian motion w/ derivative thanks to iq's code above\n\nvec4 fbmd(vec3 p) {\n    \n    vec4 rval = vec4(0);\n    float a = 1.0;\n    \n    vec3 freq = vec3(1.0);\n    vec3 scl = vec3(vec2(2.0), 1.0);\n    \n    for (int i=0; i<4; ++i) {\n        rval += a*noised(p*freq) * vec4(1.0, freq);\n        freq *= scl;\n        p += vec3(1.32, -2.392, 1.392) * freq;\n        a *= 0.2;\n    }\n    \n    return rval;\n    \n}\n\n/////////////////////////////////////////////////////////////////////////////\n// sample texture and fake normal\n\nvec3 sample_bump(in vec2 uv, in vec3 L) {\n    \n    vec3 color = texture(iChannel0, uv).xyz;\n    \n    const vec2 eps = vec2(1.0/1024.0, 0.0);\n    \n    vec3 N = normalize(vec3(texture(iChannel0, uv - eps.xy).x - \n                       texture(iChannel0, uv + eps.xy).x,\n                       texture(iChannel0, uv - eps.yx).x - \n                       texture(iChannel0, uv + eps.yx).x, \n                       0.1));\n    \n    color *= 0.3 + 0.7 * clamp(dot(N, L), 0.0, 1.0);    \n    \n    return color;\n       \n}\n\n/////////////////////////////////////////////////////////////////////////////\n// our main function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    // fit 4 full rows of triangles on screen\n    float scl = 2.0*s3 / iResolution.y;\n    \n    // get 2D scene coords\n \tvec2 p = (fragCoord - 0.5*iResolution.xy) * scl;\n    \n    // fake 3D coordinates for lighting: place hit point on a plane at z=-4\n    vec3 hit = vec3(p, -4.0);\n    \n    // place light at z=10\n    vec3 lpos = vec3(-cos(-iTime*0.047), 0.5*cos(iTime*0.053), 1.0) * 10.0;\n    \n    // handle mouse light position\n    if (iMouse.z > 0.0) {\n        lpos.xy = 20.0*(iMouse.xy - 0.5*iResolution.xy)/iResolution.xy;\n    }\n\n    // light direction and view direction for ray hitting scene\n    vec3 L = normalize(lpos - hit);\n    vec3 V = normalize(hit);\n\n    // get triangular coords\n    vec2 tri_coords = cart2tri * p;\n    vec2 tri_idx = floor(tri_coords);\n    vec2 tri_frac = tri_coords - tri_idx;\n    float top_bottom = step(tri_frac.y, tri_frac.x);\n    \n    // position relative to triangle vertex 0\n    vec2 pdiff = p - tri2cart*tri_idx;\n\n    // vertex 1 and 2, relative to vertex 0\n    const vec2 c1 = vec2(0.5, 0.5*s3);\n    vec2 c2 = tri2cart * vec2(top_bottom, 1.0-top_bottom);\n    \n    // handle growing/shrinking\n    float t = iTime * 0.125;\n    float ft = max(0.0, abs(fract(t) - 0.5) - 0.1666666);\n    ft = smoothstep(0.3333333, 0.0, ft);\n    \n    // minimum radius of \"island\" circles \n    const float rmin = 0.34;\n\n    // how far from the edge does the slopey bit go\n    // should exactly dome off when at minimum radius\n    const float chamfer = rmin - 0.25;\n\n    // maximum radius should be just past closing up chamfers\n    const float rmax = i3 + 1.1*chamfer;\n\n    // actual radius of \"islands\"\n    float rad = mix(rmax, rmin, ft);\n    \n    // generate a random number for this cell at this time\n    float tri_random = hash13(vec3(tri_idx, top_bottom + 2.0*floor(t)));\n    \n    vec2 pts[3];\n    float ds;\n    \n    // bias ever so slightly to type 2 cells \n    if (tri_random < 0.45) { \n        // type 1 cell has arcs of given radius at each corner\n        pts[0] = vec2(0);\n        pts[1] = c1;\n        pts[2] = c2;\n        rad = -rad;\n        ds = 1.0;\n    } else {\n        // type 2 cell has arcs of complement of given radius at current edge\n        pts[0] = 0.5*c1;\n        pts[1] = 0.5*c2;\n        pts[2] = pts[0] + pts[1];\n        rad = 0.5 - rad;\n        ds = -1.0;\n    }\n    \n    // get distance to nearest feature and normal direction\n    vec3 nd = vec3(0, 0, 1e5);\n\n    for (int i=0; i<3; ++i) {\n        vec2 n = ds*(pdiff - pts[i]);\n        float ln = length(n);\n        if (ln < nd.z) {\n            nd = vec3(n/ln, ln);\n        }\n    }\n\n    // signed distance to slime: d < 0 inside slime\n    float d = nd.z*ds + rad; \n    \n    // point coordinates for fbm function\n    // oscillate in x, scroll in y, undulate in time.\n    vec3 pn = vec3(2.0*p + vec2(0.04*sin(0.2*iTime), 0.1*iTime), 0.2*iTime);\n    vec2 f_grad = fbmd(pn).yz;\n       \n    // e is 1 at edge, 0 in center (linearly)\n    // z is 0 at edge, 1 at center (in a circular arc)    \n    float e = clamp((chamfer + d) / chamfer, 0.00001, 0.99999); \n    float z = sqrt(1.0 - e*e);\n    vec2 z_grad = nd.xy * e / z;\n    \n    // make surface normal for fluid and smoothstep at fluid boundary\n    vec2 nxy = z_grad + 0.15*f_grad;\n    vec3 N = normalize(vec3(nxy, 1.0));\n    \n    // smooth blending coefficient between background (k=0) and surface (k=1)\n    float coverage = smoothstep(0.0, scl, -d);    \n\n    // get reflection vector for phong lighting    \n    vec3 R = reflect(L, N);\n\n    // get UV coordinates for background texture\n    vec2 uv = 0.5 + (fragCoord.xy - 0.5*iResolution.xy) * 0.25 / iResolution.y;\n    \n    // sample the background texture \n    vec3 bg = sample_bump(uv, L);\n    \n    // fake refraction perturbs background texture lookup by fluid surface normal\n    vec3 bgR = sample_bump(uv - 0.08*N.xy * N.z, L);\n    \n    // light and shade slime:\n    const vec3 hue = vec3(0.3, 1.0, 0.0);\n    const vec3 surface_color = 0.5*hue;\n    const vec3 transmissive_color = 0.5*hue + 0.5;\n    const vec3 specular_color = 0.2*hue + 0.8;\n    \n    // diffuse + ambient\n    float diffamb = 0.3 + 0.7 * clamp(dot(N, L), 0.0, 1.0);\n    vec3 fg = surface_color * diffamb;\n    \n    // transparent background\n    fg = mix(fg, bgR * transmissive_color, 0.3);\n    \n    // specular\n    fg += 0.5*pow(clamp(dot(V, R), 0.0, 1.0), 10.0)*specular_color;\n       \n    // smoothstep based upon coverage\n    fragColor = vec4(mix(bg, fg, coverage), 1.0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}