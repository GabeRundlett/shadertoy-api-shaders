{
    "Shader": {
        "info": {
            "date": "1480286413",
            "description": "Raymarched procedural height map, distance field fuzzball, and a day/night cycle with sun shadows and light scattering shenanigans.\n\nRequires some power, so you may want to avoid fullscreen.  :)\n\nMouse drag or WASD to move the fuzzball.",
            "flags": 48,
            "hasliked": 0,
            "id": "4ttXRS",
            "likes": 20,
            "name": "Primordial Fuzzball",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "distancefield",
                "interactive"
            ],
            "usePreview": 0,
            "username": "irwatts",
            "viewed": 1274
        },
        "renderpass": [
            {
                "code": "// Post process and present\n\n// PARAM\nconst int SUNSHAFT_NUM_SAMPLES = 64;\nconst float SUNSHAFT_DENSITY = 0.42;\nconst float SUNSHAFT_DECAY = 0.9;\nconst float SUNSHAFT_WEIGHT = 1.0;\nconst float SUNSHAFT_EXPOSURE = 0.25;\nconst float SUNSHAFT_START_DIST = 120.0;\n\nconst float FAR_CLIP = 300.0;\n\n\n// CONST\nconst vec2 txSunUV = vec2(7.0,0.0);\n\n// GENERATED\nvec2 sunUV;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    fragColor = texture( iChannel0, uv );\n    \n    vec4 preColor = fragColor;\n    float occlusionMask = preColor.a;\n    if (occlusionMask == 0.0)\n    {\n        occlusionMask = 1.0;\n    }\n    else\n    {\n        occlusionMask = 1.0-clamp( (occlusionMask/(FAR_CLIP+SUNSHAFT_START_DIST))-0.3, 0.0, 1.0 );\n        occlusionMask = pow( occlusionMask, 8.0 );\n        occlusionMask = 1.0-occlusionMask;\n    }\n    \n    sunUV = texture( iChannel1, (txSunUV+0.5)/iChannelResolution[1].xy, -100.0 ).xy;\n    \n    vec4 sunshaftColor = vec4(vec3(0.0), 1.0);\n    vec2 sunshaftUV = uv;\n    vec2 deltaSunUV = uv - sunUV;\n    deltaSunUV *= 1.0 / float(SUNSHAFT_NUM_SAMPLES) * SUNSHAFT_DENSITY;\n    float illuminationDecay = 1.0;\n\tfor (int i = 0; i < SUNSHAFT_NUM_SAMPLES; i++)\n    {\n        sunshaftUV -= deltaSunUV;\n        vec4 samp = texture( iChannel0, sunshaftUV ) * occlusionMask;\n        samp *= illuminationDecay * SUNSHAFT_WEIGHT;\n        sunshaftColor += samp;\n        illuminationDecay *= SUNSHAFT_DECAY;\n    }\n    sunshaftColor *= SUNSHAFT_EXPOSURE;\n    sunshaftColor -= (fragColor*occlusionMask);\n    fragColor += sunshaftColor;\n    \n    // Visualize sunshaft color\n    //fragColor = sunshaftColor;\n    \n    // Visualize occlusion mask\n    //fragColor = vec4(occlusionMask);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Input\n\n// PARAM\nconst float FUZZBALL_MOVE_SPEED = 200.0;\nconst vec3 FUZZBALL_START_POS = vec3(0, 0, 0);\nconst float FUZZBALL_MAX_Z = 150.0;\nconst float FUZZBALL_MIN_Z = -100.0;\nconst float FUZZBALL_MAX_X_SCALAR = 0.234375;\nconst float FUZZBALL_MAX_X_DISTOFFSET = 200.0;\n\nconst float WORLD_SCALE = 0.42;\nconst float FOV = 90.0;\nconst vec3 CAM_POS = vec3(0, 150.0, -100.0);\nconst vec3 CAM_START_DIR = normalize( vec3(0, -0.1, 0.2) );\n\nconst vec3 SUN_ORBIT_POS = vec3(0.0, -300.0, 200.0);\nconst float SUN_ORBIT_DIST = 500.0;\nconst float SUN_ORBIT_SPEED = 0.1;\nconst float SUN_ORBIT_NIGHT_SPEED = 0.42;\n\nconst vec3 MOON_ORBIT_POS = vec3(0.0, -300.0, 200.0);\nconst float MOON_ORBIT_DIST = 420.0;\nconst float MOON_ORBIT_SPEED = 0.1;\nconst float MOON_ORBIT_NIGHT_SPEED = 0.42;\n\n\n// CONST\nconst float PI = 3.14159;\nconst float TAU = PI * 2.0;\n\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_A  = 65.5/256.0;\nconst float KEY_S  = 83.5/256.0;\nconst float KEY_D  = 68.5/256.0;\n\nconst vec2 txFuzzballPos = vec2(0.0,0.0);\nconst vec2 txCamDir = vec2(1.0,0.0);\nconst vec2 txCamRight = vec2(2.0,0.0);\nconst vec2 txCamUp = vec2(3.0,0.0);\nconst vec2 txCamOrigin = vec2(4.0,0.0);\nconst vec2 txFrustumOrigin = vec2(5.0,0.0);\nconst vec2 txSunPos = vec2(6.0,0.0);\nconst vec2 txSunUV = vec2(7.0,0.0);\nconst vec2 txMoonPos = vec2(8.0,0.0);\n\n\n// GENERATED\nvec3 fuzzballPos = FUZZBALL_START_POS;\nvec3 fuzzballForward = vec3(0, 0, 1);\nvec3 fuzzballUp = vec3(0, 1, 0);\n\nvec3 camDir = CAM_START_DIR;\nvec3 camRight;\nvec3 camUp;\nfloat frustumWidth = 640.0*WORLD_SCALE;\nfloat frustumDist;\n\nfloat sunAngle = PI*0.25;\nvec3 sunPos = SUN_ORBIT_POS+(SUN_ORBIT_DIST*vec3(0, 1, 0));\nvec2 sunUV;\n\nfloat moonAngle = PI*1.25;\nvec3 moonPos = MOON_ORBIT_POS+(MOON_ORBIT_DIST*vec3(0, -1, 0));\n\n\n// Game state logic from Bricks Game by iq (https://www.shadertoy.com/view/MddGzf)\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if ( fragCoord.x > 9.0 || fragCoord.y > 9.0 ) discard;\n    \n    vec3 camOrigin, frustumOrigin;\n    \n     // Load Game State\n    if ( iFrame > 0 )\n    {\n        fuzzballPos =   loadValue( txFuzzballPos ).xyz;\n        camDir =        loadValue( txCamDir ).xyz;\n        camRight =      loadValue( txCamRight ).xyz;\n        camUp =         loadValue( txCamUp ).xyz;\n        camOrigin =     loadValue( txCamOrigin ).xyz;\n        frustumOrigin = loadValue( txFrustumOrigin ).xyz;\n        vec4 sunData =  loadValue( txSunPos );\n        sunPos =        sunData.xyz;\n        sunAngle =      sunData.a;\n        sunUV =         loadValue( txSunUV ).xy;\n        vec4 moonData = loadValue( txMoonPos );\n        moonPos =       moonData.xyz;\n        moonAngle =     moonData.a;\n    }\n    \n    // Camera\n    //camOrigin = CAM_POS;\n    frustumDist = ((frustumWidth*0.5)/sin( FOV*0.5 ));\n    //frustumOrigin = camOrigin+(camDir*frustumDist);   \n    frustumOrigin = CAM_POS;\n    camRight = cross( camDir, vec3(0, 1, 0) );\n\tcamUp = cross( camRight, camDir );\n    camOrigin = frustumOrigin-(camDir*frustumDist);\n    \n    // Move fuzzball with keyboard\n    vec3 fuzzballMoveDir = vec3(0.0, 0.0, 0.0);\n    \n    fuzzballMoveDir.z += texture( iChannel1, vec2(KEY_W,0.25) ).x;\n    fuzzballMoveDir.z -= texture( iChannel1, vec2(KEY_S,0.25) ).x;\n    fuzzballMoveDir.x += texture( iChannel1, vec2(KEY_A,0.25) ).x;\n    fuzzballMoveDir.x -= texture( iChannel1, vec2(KEY_D,0.25) ).x;\n    \n    fuzzballMoveDir.z += texture( iChannel1, vec2(KEY_UP,0.25) ).x;\n    fuzzballMoveDir.z -= texture( iChannel1, vec2(KEY_DOWN,0.25) ).x;\n    fuzzballMoveDir.x += texture( iChannel1, vec2(KEY_LEFT,0.25) ).x;\n    fuzzballMoveDir.x -= texture( iChannel1, vec2(KEY_RIGHT,0.25) ).x;\n    \n    // Move fuzzball with mouse\n    if ( iMouse.z > 0.0 )\n    {\n        vec2 centeredCoord = iMouse.xy-(iResolution.xy*0.5);\n        vec3 rayOrigin = frustumOrigin+((centeredCoord.x*camRight)*WORLD_SCALE)+((centeredCoord.y*camUp)*WORLD_SCALE);\n        vec3 rayDir = normalize( rayOrigin-camOrigin );\n        \n        vec3 flatOrigin = vec3(rayOrigin.x, 0, rayOrigin.z);\n        vec3 flatDir = normalize( vec3(rayDir.x, 0, rayDir.z) );\n        float u = dot( rayDir, flatDir );\n        float t1 = dot( flatOrigin-rayOrigin, rayDir );\n        float t2 = dot( flatOrigin-rayOrigin, flatDir );\n        float d1 = (t1-u*t2)/(1.0-u*u);\n        vec3 targetPos = (rayOrigin+(rayDir*d1));\n        \n        // HACKTASTIC: Make the fuzzball line up better due to the soup offset in Buf D\n        targetPos *= 0.64;\n        targetPos.z -= 80.0;\n        \n        //*/ \n        fuzzballMoveDir = targetPos-fuzzballPos;\n        /*/\n        fuzzballPos = targetPos;\n        //*/\n    }\n    \n    if ( length( fuzzballMoveDir ) > 0.0 )\n    {\n        fuzzballMoveDir = normalize( fuzzballMoveDir );\n        fuzzballPos += fuzzballMoveDir * FUZZBALL_MOVE_SPEED * iTimeDelta;\n        \n        // Keep fuzzball in screen bounds\n        if ( fuzzballPos.z > FUZZBALL_MAX_Z )\n        {\n            fuzzballPos.z = FUZZBALL_MAX_Z;\n        }\n        else if ( fuzzballPos.z < FUZZBALL_MIN_Z )\n        {\n            fuzzballPos.z = FUZZBALL_MIN_Z;\n        }\n        float maxX = iResolution.x*FUZZBALL_MAX_X_SCALAR; \n        maxX += (fuzzballPos.z-FUZZBALL_MIN_Z)/(FUZZBALL_MAX_Z-FUZZBALL_MIN_Z)*FUZZBALL_MAX_X_DISTOFFSET;\n        if ( fuzzballPos.x > maxX )\n        {\n            fuzzballPos.x = maxX;\n        }\n        else if ( fuzzballPos.x < -maxX )\n        {\n            fuzzballPos.x = -maxX;\n        }\n    }\n    \n    // Sun\n    sunPos = SUN_ORBIT_POS+(SUN_ORBIT_DIST*vec3(cos( sunAngle ), sin( sunAngle ), 0.0));\n    vec3 sunFrustumPos = camOrigin+(normalize( sunPos - camOrigin )*frustumDist);\n    vec3 sunFrustumDelta = sunFrustumPos - frustumOrigin;\n    \n    // Sun UV\n    mat3 camM;\n    camM[0] = camRight;\n    camM[1] = camUp;\n    camM[2] = camDir;\n    sunFrustumDelta *= camM;\n    // HACKTASTIC: Make it line up better until I get the transform correct \n    sunUV = vec2(sunFrustumDelta.x, sunFrustumDelta.y)/(iResolution.xy*WORLD_SCALE*0.6)+vec2(0.5, 0.5);\n    \n    // Sun Orbit\n    float sunOrbitNightAmount = pow( (dot( normalize( sunFrustumDelta ), -camUp )*0.5)+0.5, 2.0 );\n    \n    //*/ // remove first '/' for linear speed day/night cycle\n    sunAngle += SUN_ORBIT_SPEED*iTimeDelta+(sunOrbitNightAmount*SUN_ORBIT_NIGHT_SPEED*iTimeDelta);\n    /*/ // linear speed day/night cycle\n\tsunAngle += SUN_ORBIT_SPEED*iTimeDelta;\n    //*/\n\tif ( sunAngle > TAU )\n    {\n        sunAngle -= TAU;\n    }\n    \n    // Moon\n    moonPos = MOON_ORBIT_POS+(MOON_ORBIT_DIST*vec3(cos( sunAngle+PI ), sin( sunAngle+PI ), 0.0));\n    vec3 moonFrustumPos = camOrigin+(normalize( moonPos - camOrigin )*frustumDist);\n    vec3 moonFrustumDelta = moonFrustumPos - frustumOrigin;\n    moonAngle = sunAngle+PI;\n    \n    \n    // Store Game State\n    fragColor = vec4(0.0);\n    storeValue( txFuzzballPos,      vec4(fuzzballPos, 0.0),     fragColor, fragCoord );\n    storeValue( txCamDir,           vec4(camDir, 0.0),          fragColor, fragCoord );\n    storeValue( txCamRight,         vec4(camRight, 0.0),        fragColor, fragCoord );\n    storeValue( txCamUp,            vec4(camUp, 0.0),           fragColor, fragCoord );\n    storeValue( txCamOrigin,        vec4(camOrigin, 0.0),       fragColor, fragCoord );\n    storeValue( txFrustumOrigin,    vec4(frustumOrigin, 0.0),   fragColor, fragCoord );\n    storeValue( txSunPos,           vec4(sunPos, sunAngle),     fragColor, fragCoord );\n    storeValue( txSunUV,            vec4(sunUV, 0.0, 0.0),      fragColor, fragCoord );\n    storeValue( txMoonPos,          vec4(moonPos, moonAngle),   fragColor, fragCoord );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Noise - Dust and Soup\n\n// CONST\nconst float PI = 3.14159;\nconst float HALF_PI = PI*0.5;\n\n// Worley Noise\nfloat randFloat( float n )\n{\n \treturn fract( sin( n*64.19 )*420.82 );\n}\nvec2 randVec2( vec2 uv )\n{\n \treturn vec2(randFloat( uv.x*12.95+uv.y*43.72 ), randFloat( uv.x*16.21+uv.y*90.23 )); \n}\nfloat worley( vec2 n, float s )\n{\n    float dist = 2.0;\n    for( int x=-1;x<=1;x++ )\n    {\n        for( int y=-1;y<=1;y++ )\n        {\n            vec2 p = floor( n/s )+vec2(x,y);\n            float d = length( randVec2( p )+vec2(x,y)-fract( n/s ) );\n            if ( d < dist )\n            {\n             \tdist = d;   \n            }\n        }\n    }\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = fract( uv+vec2(0.42, 0.2) );\n    \n    float tilingOffset = 0.33;\n    vec2 tilingUV = uv;\n    if (uv.x < tilingOffset)\n    {\n        tilingUV.x += 1.0;\n    }\n    tilingUV.x -= 1.0;\n    if (uv.y < tilingOffset)\n    {\n        tilingUV.y += 1.0;\n    }\n    tilingUV.y -= 1.0;\n    \n    float tilingOffset2 = 0.66;\n    vec2 tilingUV2 = uv;\n    if (uv.x < tilingOffset2)\n    {\n        tilingUV2.x += 1.0;\n    }\n    tilingUV2.x -= 1.0;\n    if (uv.y < tilingOffset2)\n    {\n        tilingUV2.y += 1.0;\n    }\n    tilingUV2.y -= 1.0;\n    \n    fragColor = vec4(1.0);\n    \n    float texScale = 512.0;\n    float macroScale = 0.25;\n    float microScale = 4.0;\n    float fNoise1 = randFloat( fragCoord.x*12.95+fragCoord.y*43.72 );\n    float wNoise1 = worley( uv*texScale, 32.0 );\n    float wNoise2 = worley( tilingUV*texScale, 32.0 );\n    float wNoise3 = worley( tilingUV2*texScale, 32.0 );\n    float wNoiseMicro1 = worley( uv*texScale*microScale, 32.0 );\n    float wNoiseMicro2 = worley( tilingUV*texScale*microScale, 32.0 );\n    float wNoiseMicro3 = worley( tilingUV2*texScale*microScale, 32.0 );\n    float wNoiseMacro1 = worley( uv*texScale*macroScale, 32.0 );\n    float wNoiseMacro2 = worley( tilingUV*texScale*macroScale, 32.0 );\n    float wNoiseMacro3 = worley( tilingUV2*texScale*macroScale, 32.0 );\n    \n    // Dust\n    float dust = fNoise1;\n    if ( dust - 0.999 < 0.0 )\n    {\n        dust = 0.0;\n    }\n    float dustDepth = fNoise1*fNoise1;\n    \n    // Soup\n    float soup = 0.0;\n    float soupMask = 0.0;\n    \n    float fade = min( sin( uv.x*PI ), sin( uv.y*PI ) );\n    float tilingFade = 1.0 - max( abs( sin( (uv.x+tilingOffset*0.5)*PI ) ), abs( sin( (uv.y+tilingOffset*0.5)*PI ) ) );\n    float tilingFade2 = 1.0 - max( abs( sin( (uv.x+tilingOffset2*1.25)*PI ) ), abs( sin( (uv.y+tilingOffset2*1.25)*PI ) ) );\n    \n    soup += 0.64*(wNoise1+(wNoiseMicro1*0.2))*fade;\n    float tilingSoup = 0.42*(wNoise2+(0.2*wNoiseMicro2*tilingFade))*tilingFade;\n    float tilingSoup2 = 0.28*(wNoise3+(0.2*wNoiseMicro3*tilingFade2))*tilingFade2;\n    soup = max( soup, tilingSoup );\n    soup = max( soup, tilingSoup2 );\n    soup += tilingSoup*0.1;\n    soup += tilingSoup2*0.1;\n    \n    soupMask += ((wNoiseMacro1*0.8)+0.1)*fade;\n    soupMask = max( soupMask, ((wNoiseMacro2*0.8)+0.1)*tilingFade );\n    soupMask = max( soupMask, ((wNoiseMacro3*0.8)+0.1)*tilingFade2 );\n    soupMask += 0.64;\n    soupMask -= fNoise1*0.1;\n    \n    fragColor.r = dust;\n    fragColor.g = dustDepth;\n    fragColor.b = soup;\n    fragColor.a = soupMask;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Height - Ripples and Soup\n\n// PARAM\nconst float RIPPLE_DAMPING = 0.995;\nconst float RIPPLE_HEIGHT = 1.0;\nconst float FUZZBALL_RADIUS = 20.0;\n\nconst float FAR_CLIP = 300.0;\n\n// CONST\nconst vec2 txFuzzballPos = vec2(0.0,0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s = -0.5+2.0*fract(float(iFrame)/2.0);\n    vec2 uv = (fragCoord.xy + s) / iResolution.xy;\n    \n    vec2 uv1 = (fragCoord.xy + vec2(-1, 0.0) + s) / iResolution.xy;\n    vec2 uv2 = (fragCoord.xy + vec2(1, 0.0) + s) / iResolution.xy;\n    vec2 uv3 = (fragCoord.xy + vec2(0.0, 1) + s) / iResolution.xy;\n    vec2 uv4 = (fragCoord.xy + vec2(0.0, -1) + s) / iResolution.xy;\n\n    fragColor = texture( iChannel2, uv );\n    \n    fragColor.g = ((texture( iChannel2, uv1 ).r +\n                   \ttexture( iChannel2, uv2 ).r +\n                   \ttexture( iChannel2, uv3 ).r +\n                   \ttexture( iChannel2, uv4 ).r) * 0.5) - fragColor.g;\n    fragColor.rg *= RIPPLE_DAMPING;\n    \n    float r = fragColor.r;\n    fragColor.r = fragColor.g;\n    fragColor.g = r;\n    \n    vec3 fuzzballPos = texture( iChannel0, (txFuzzballPos+0.5)/iChannelResolution[1].xy, -100.0 ).xyz;\n    \n    vec2 fuzzballCoord = vec2(fuzzballPos.x, fuzzballPos.z);\n    fuzzballCoord += iResolution.xy * 0.5;\n    \n    float fuzzballDist = distance( fuzzballCoord, fragCoord.xy );\n    float fuzzballIntensity = 0.0;\n    if (fuzzballDist < FUZZBALL_RADIUS )\n    {\n        fuzzballIntensity = 1.0-(0.3*fuzzballDist/FUZZBALL_RADIUS);\n        fragColor.rg = vec2(fuzzballIntensity);\n        \n        // fade in at start\n        fragColor.rg *= clamp( iTime, 0.0, 1.0 );\n    }\n    \n    // Soup\n    float soupH = 0.0;\n    vec4 soup1 = texture( iChannel1, fract( uv*0.72 + vec2(-iTime*0.042, iTime*0.01) ) );\n    vec4 soup2 = texture( iChannel1, fract( uv*0.42 + vec2(0.0, soup1.b*0.2) + vec2(iTime*0.042, -iTime*0.0042) ) );\n\tsoupH = min( (soup2.b*soup1.a), 0.2+2.0*(1.0-(soup1.b-soup2.a)) );\n    soupH -= fuzzballIntensity*0.2;\n    \n    fragColor.b = soupH;\n    fragColor.a = soupH+(fragColor.r*RIPPLE_HEIGHT);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Main rendering\n\n// CONST\nconst float PI = 3.14159;\nconst float TAU = PI * 2.0;\n\nconst vec2 txFuzzballPos = vec2(0.0,0.0);\nconst vec2 txCamDir = vec2(1.0,0.0);\nconst vec2 txCamRight = vec2(2.0,0.0);\nconst vec2 txCamUp = vec2(3.0,0.0);\nconst vec2 txCamOrigin = vec2(4.0,0.0);\nconst vec2 txFrustumOrigin = vec2(5.0,0.0);\nconst vec2 txSunPos = vec2(6.0,0.0);\nconst vec2 txSunUV = vec2(7.0,0.0);\nconst vec2 txMoonPos = vec2(8.0,0.0);\n\n// PARAM\nconst float TERRAIN_HEIGHT = 80.0;\nconst float WORLD_SCALE = 0.42;\n\nconst float FRESNEL_INTENSITY = 2.0;\nconst float FRESNEL_POW = 8.0;\n\nconst float SHADOWS_MAX_DIST = 200.0;\n\nconst vec4 DIST_FOG_DAY_COLOR = vec4(0.2);\nconst vec4 DIST_FOG_SUN_COLOR = vec4(1.0, 0.194, 0.0, 1.0);\nconst vec4 DIST_FOG_NIGHT_COLOR = vec4(0.08, 0.0, 0.2, 1.0);\nconst float DIST_FOG_START = 64.0;\nconst float DIST_FOG_DENSITY = 0.003;\n\nconst vec4 HEIGHT_FOG_COLOR = vec4(0.149, 0.788, 0.722, 1.0);\nconst float HEIGHT_FOG_Y = 64.0;\n\nconst float SAMP_DIST = 0.5;\n\nconst float FUZZBALL_RADIUS = 20.0;\nconst vec4 FUZZBALL_COLOR = vec4(0.8, 0.1, 0.2, 1.0);\nconst vec4 FUZZBALL_COLOR2 = vec4(0.2, 0.1, 0.8, 1.0);\n\nconst float DUST_RADIUS = 1.0;\nconst float DUST_MIN_DIST = 30.0;\nconst float DUST_MAX_DIST = 200.0;\nconst float DUST_MOVE_SPEED = 0.08;\nconst float DUST_MOVE_DIST = 0.1;\nconst float DUST_MOVE_MAX_ANGLE = PI;\n\nconst float RAY_STEP = 0.2;\nconst float NEAR_CLIP = 0.01;\nconst float FAR_CLIP = 300.0;\n\n\n// GENERATED\nvec2 halfTexelOffset;\n\nvec3 camDir;\nvec3 camRight;\nvec3 camUp;\n\nvec3 sunPos;\nvec3 moonPos;\nvec3 fuzzballPos;\nvec3 fuzzballSoupPos;\n\nvec4 dustTex;\n\n\nfloat randFloat( float n )\n{\n \treturn fract( sin( n*64.19 )*420.82 );\n}\nvec3 randVec3( vec2 uv )\n{\n \treturn vec3(randFloat( uv.x*12.95+uv.y*43.72 ), randFloat( uv.x*16.21+uv.y*90.23 ), randFloat( uv.x*78.62+uv.y*16.48 )); \n}\n\n\nbool sphere( in vec3 p, in vec3 sphereP, in float radius, out vec3 resN )\n{\n    vec3 deltaP = p - sphereP;\n    if ( length( deltaP ) < radius )\n    {\n        resN = normalize( deltaP );\n        return true;\n    }\n\treturn false;\n}\n\nbool sphere2D( in vec3 ro, in vec3 rd, in vec3 sphereP, in float radius, out vec3 resN )\n{\n    vec3 deltaP = sphereP - ro;\n    vec3 sphereDir = normalize( deltaP );\n    float sphereDot = dot( rd, sphereDir );\n    float dotThreshold = 1.0-(0.0002*radius);\n    if ( sphereDot > dotThreshold )\n    {\n        vec3 p = ro+rd*length( deltaP );\n        vec3 deltaSurfP = p-sphereP;\n        float surfDist = length( deltaSurfP );\n        vec3 surfDir = normalize( deltaSurfP );\n        resN = vec3(0.0);\n        resN.x = dot( surfDir, vec3(1.0, 0.0, 0.0) )*0.5+0.5;\n        resN.y = dot( surfDir, vec3(0.0, 1.0, 0.0) )*0.5+0.5;\n      \tfloat smoothFront = sin( surfDist/(radius) );\n        resN = (resN*smoothFront)+(vec3(0.0, 0.0, -1.0)*(1.0-smoothFront));\n        resN = normalize( resN );\n        return true;\n    }\n    return false;\n}\n\nfloat fuzzballDisplace( in vec3 p )\n{\n    float mult = 1.0;\n    float rand0 = 0.5*randFloat( p.x*0.01+p.y*0.023 );\n    float warble = 0.5*pow( sin( p.x )+sin( p.y )+sin( p.z ), 2.0 );\n    float displace = pow( sin( mult*p.x+warble+rand0 )+sin( mult*p.y+warble+rand0 )+sin( mult*p.z+warble+rand0 ), 1.5 );\n    displace *= (0.5+4.0*randFloat( p.x*54.74+p.y*76.23 ));\n    return displace;\n}\n\nbool fuzzball( in vec3 p, in vec3 sphereP, in float radius, out vec3 resN, out float resDisp )\n{\n    vec3 deltaP = p - sphereP;\n    vec3 sphereN = normalize( deltaP );\n    vec3 sphereSurfP = (sphereN*radius);\n    sphereSurfP += (0.1*sphereP)+vec3(0.0,iTime*1.4,0.0);\n    float moveRotSpeed = 0.0001;\n    float rotZTime = (sphereP.x*moveRotSpeed);\n    mat3 rotZM = mat3(\n        vec3( cos(rotZTime), sin(rotZTime), 0.0),\n        vec3(-sin(rotZTime), cos(rotZTime), 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n    sphereSurfP = rotZM*sphereSurfP;\n    float rotYTime = -iTime*0.2;\n    mat3 rotYM = mat3(\n        vec3( cos(rotYTime), sin(rotYTime), 0.0),\n        vec3(0.0, 0.0, 1.0),\n        vec3(-sin(rotYTime), cos(rotYTime), 0.0)\n    );\n    sphereSurfP = rotYM*sphereSurfP;\n    float rotXTime = -(sphereP.z*moveRotSpeed);\n    mat3 rotXM = mat3(\n        vec3(0.0, 0.0, 1.0),\n        vec3(-sin(rotXTime), cos(rotXTime), 0.0),\n        vec3( cos(rotXTime), sin(rotXTime), 0.0)\n    );\n    sphereSurfP = rotXM*sphereSurfP;\n    float displace = fuzzballDisplace( sphereSurfP );\n    float dist = length( deltaP );\n    if ( dist < radius+displace )\n    {\n        resDisp = displace;\n\n        return true;\n    }\n\treturn false;\n}\n\nfloat soup( in float x, in float y )\n{\n    vec2 uv = (vec2(x, y)/iResolution.xy)+vec2(0.5, 0.5);\n    \n    vec4 soup = texture( iChannel2, uv );\n    \n    return soup.a * TERRAIN_HEIGHT;\n}\n\nvec3 soupNormal( in float x, in float y )\n{\n    return normalize( vec3(soup(x-SAMP_DIST,y) - soup(x+SAMP_DIST,y),\n                           2.0*SAMP_DIST, \n                           soup(x,y-SAMP_DIST) - soup(x,y+SAMP_DIST)) );\n}\n\nbool sunRay( in vec3 ro, in vec3 rd, out float resS )\n{\n    const float rayStep = 10.0;\n    const float nearClip = 0.1;\n    const float farClip = 100.0;\n    float t = 0.1;\n    vec3 p = ro + rd*t;\n    float h = soup( p.x, p.z );\n    if ( p.y < h )\n    {\n        resS = 0.42;\n\n        return true;\n    }\n    vec3 fuzzballN;\n    float fuzzballDisp;\n    if ( fuzzball( p, fuzzballSoupPos, FUZZBALL_RADIUS, fuzzballN, fuzzballDisp ) )\n    {\n        resS = 0.42;\n\n        return true;\n    }\n    \n    // cast larger shadow from fuzzball\n    float fuzzballDist = length( fuzzballSoupPos-ro );\n    p = ro+rd*fuzzballDist;\n    if ( fuzzball( p, fuzzballSoupPos, FUZZBALL_RADIUS, fuzzballN, fuzzballDisp ) )\n    {\n        resS = 0.42;\n\n        return true;\n    }\n    \n    resS = 1.0;\n    \n    return false;\n}\n\nbool castRay( in vec3 ro, in vec3 rd, out float resT, out float resH, out vec3 resN, out float resS, out vec4 resC )\n{    \n    for( float t = NEAR_CLIP; t < FAR_CLIP; t += RAY_STEP )\n    {\n        vec3 p = ro + rd*t;\n        float h = soup( p.x, p.z );\n        if ( p.y < h )\n        {\n            if ( t == NEAR_CLIP )\n            {\n                resT = 0.0;\n                resH = h;\n                resN = vec3(0.0, 0.0, -1.0);\n                resC = HEIGHT_FOG_COLOR*0.1;\n                resS = 1.0;\n                \n                return true;\n            }\n            \n            resT = t - 0.5*RAY_STEP;\n            resH = h;\n            resN = soupNormal( p.x, p.z );\n            // soup color\n            resC = vec4(vec3(0.64), 1.0);\n            \n            if (p.z < SHADOWS_MAX_DIST)\n            {\n                float sunRayS;\n                vec3 sunDir = normalize( sunPos - p ); \n                //*/\n                if ( sunRay( p, sunDir, sunRayS ) )\n                {\n                    resS = sunRayS;\n                    // shadow color\n                    resC = vec4(0.42, 0.0, 1.0, 1.0);\n                }\n                else\n                {\n                    resS = 1.0;\n                }\n                /*/\n                resS = 1.0;\n                //*/ \n                \n                // scatter some fuzzball color in there\n                float scatterRadius = 128.0;\n                float fuzzballDist = length( fuzzballSoupPos-p );\n                if ( fuzzballDist < scatterRadius )\n                {\n                    float blend = fuzzballDist/scatterRadius;\n                    resC = (resC*blend)+(FUZZBALL_COLOR*(1.0-blend));\n                }\n            }\n\n            return true;\n        }\n        \n        if (dustTex.r > 0.0)\n        {            \n            if (t > (DUST_MIN_DIST + (dustTex.g*(DUST_MAX_DIST-DUST_MIN_DIST))))\n            {\n                resT = t - 0.5*RAY_STEP;\n                resH = h;\n                resN = vec3(0.0, 0.5, 0.5);\n                resS = 1.0;\n                // dust color\n                resC = vec4(0.0, 0.8, 0.8, 1.0);  \n                \n                return true;\n            }\n        }\n        \n        // Player fuzzball\n        vec3 fuzzballN;\n        float fuzzballDisp;\n        if ( fuzzball( p, fuzzballSoupPos, FUZZBALL_RADIUS, fuzzballN, fuzzballDisp ) )\n        {\n            resT = t - 0.5*RAY_STEP;\n            resH = h;\n            //resN = fuzzballN;\n            float sampDist = 0.1;\n            float x1, x2, y1, y2, z1, z2;\n            float disp;\n            x1 = fuzzball( p+vec3(sampDist,0.0,0.0), fuzzballSoupPos, FUZZBALL_RADIUS, fuzzballN, disp ) ? 1.0 : 0.0;\n            x2 = fuzzball( p+vec3(-sampDist,0.0,0.0), fuzzballSoupPos, FUZZBALL_RADIUS, fuzzballN, disp ) ? 1.0 : 0.0;\n            y1 = fuzzball( p+vec3(0.0,sampDist,0.0), fuzzballSoupPos, FUZZBALL_RADIUS, fuzzballN, disp ) ? 1.0 : 0.0;\n            y2 = fuzzball( p+vec3(0.0,-sampDist,0.0), fuzzballSoupPos, FUZZBALL_RADIUS, fuzzballN, disp ) ? 1.0 : 0.0;\n            z1 = fuzzball( p+vec3(0.0,0.0,sampDist), fuzzballSoupPos, FUZZBALL_RADIUS, fuzzballN, disp ) ? 1.0 : 0.0;\n            z2 = fuzzball( p+vec3(0.0,0.0,-sampDist), fuzzballSoupPos, FUZZBALL_RADIUS, fuzzballN, disp ) ? 1.0 : 0.0;\n            resN = vec3((x1-x2)/(2.0*sampDist), (y1-y2)/(2.0*sampDist), (z1-z2)/(2.0*sampDist));\n            \n            if ( resN == vec3(0.0) )\n            {\n                resN = vec3(0.0, 0.0, -1.0);\n            }\n            resN = normalize( resN );\n            if (p.z < SHADOWS_MAX_DIST)\n            {\n                float sunRayS;\n                vec3 sunDir = normalize( sunPos - p ); \n                if ( sunRay( p, sunDir, sunRayS ) )\n                {\n                    resS = sunRayS;\n                    // shadow color\n                    resC = vec4(0.42, 0.0, 1.0, 1.0);\n                }\n                else\n                {\n                    resS = 1.0;\n                }\n            }\n            // fuzzball color\n            float blend = (0.42+0.042*fuzzballDisp);\n            blend = 1.0 - blend;\n            blend = pow( blend, 2.0 );\n            blend = 1.0 - blend;\n            resC = (FUZZBALL_COLOR*blend)+(FUZZBALL_COLOR2*(1.0-blend));\n\n            return true;\n        }\n    }\n    \n    // Draw sun and moon in background\n    vec3 sphereN;\n    if ( sphere2D( ro, rd, sunPos, 100.0, sphereN ) )\n    {\n        resT = 0.0;\n        resH = sunPos.y+200.0;\n        resN = sphereN;\n        resS = 1.0;\n        // sun color\n        resC = vec4(2.0, 0.8, 0.4, 0.0);\n\n        return true;\n    }\n    if ( sphere2D( ro, rd, moonPos, 42.0, sphereN ) )\n    {\n        resT = 0.0;\n        resH = moonPos.y+200.0;\n        resN = sphereN;\n        resS = 1.0;\n        // moon color\n        resC = vec4(0.42, 0.42, 0.42, 0.0);\n\n        return true;\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float s = -0.5+2.0*fract(float(iFrame)/2.0);\n    halfTexelOffset = (vec2(s) / iResolution.xy) * 0.5;\n    \n    vec4 prevFragColor = texture( iChannel3, uv+halfTexelOffset );\n    \n    float soupSamp = DUST_MOVE_MAX_ANGLE*soup( -fragCoord.x+(iResolution.xy*0.5).x, fragCoord.y-(iResolution.xy*0.5).y )/TERRAIN_HEIGHT;\n    vec2 dustOffset = vec2(iTime*DUST_MOVE_SPEED + DUST_MOVE_DIST*(cos( soupSamp )+1.0), DUST_MOVE_DIST*sin( soupSamp ));\n    dustTex = texture( iChannel1, fract( uv+halfTexelOffset+dustOffset ) );\n    dustTex += texture( iChannel1, fract( uv+halfTexelOffset+(vec2(-0.2,1.0)*dustOffset) ) );\n    \n    fuzzballPos = texture( iChannel0, (txFuzzballPos+0.5)/iChannelResolution[1].xy, -100.0 ).xyz;\n    fuzzballSoupPos = fuzzballPos;\n    fuzzballSoupPos += vec3(0.0, soup( fuzzballPos.x, fuzzballPos.z )*0.8, 0.0);\n    fuzzballSoupPos += 1.0*soupNormal( fuzzballPos.x, fuzzballPos.z );\n    \n    vec4 sunData = texture( iChannel0, (txSunPos+0.5)/iChannelResolution[1].xy, -100.0 );\n    sunPos = sunData.xyz;\n    vec2 sunUV = texture( iChannel0, (txSunUV+0.5)/iChannelResolution[1].xy, -100.0 ).xy;\n    \n    float dayTime = (sin(sunData.a)*0.5)+0.5;\n    float sunFogBlend = 1.0-clamp( distance( uv, sunUV )*0.9, 0.0, 1.0 );\n    vec4 distFogDayColor = (DIST_FOG_SUN_COLOR*sunFogBlend)+(DIST_FOG_DAY_COLOR*(1.0-sunFogBlend));\n    vec4 distFogColor = (distFogDayColor * dayTime) + (DIST_FOG_NIGHT_COLOR * (1.0 - dayTime));\n   \t\n    vec4 moonData = texture( iChannel0, (txMoonPos+0.5)/iChannelResolution[1].xy, -100.0 );\n    moonPos = moonData.xyz;\n    \n    camDir = texture( iChannel0, (txCamDir+0.5)/iChannelResolution[1].xy, -100.0 ).xyz;\n    camRight = texture( iChannel0, (txCamRight+0.5)/iChannelResolution[1].xy, -100.0 ).xyz;\n    camUp = texture( iChannel0, (txCamUp+0.5)/iChannelResolution[1].xy, -100.0 ).xyz;\n    vec3 camOrigin = texture( iChannel0, (txCamOrigin+0.5)/iChannelResolution[1].xy, -100.0 ).xyz;\n    vec3 frustumOrigin = texture( iChannel0, (txFrustumOrigin+0.5)/iChannelResolution[1].xy, -100.0 ).xyz;\n    \n    vec2 centeredCoord = fragCoord-(iResolution.xy*0.5);\n    vec3 rayOrigin = frustumOrigin+((centeredCoord.x*camRight)*WORLD_SCALE)+((centeredCoord.y*camUp)*WORLD_SCALE);\n    vec3 rayDir = normalize( rayOrigin-camOrigin );\n    \n    float resDepth, resHeight, resShadow;\n    vec3 resNormal;\n    vec4 resColor;\n    resShadow = 1.0;\n    if ( castRay( rayOrigin, rayDir, resDepth, resHeight, resNormal, resShadow, resColor ) )\n    {\n        // Base Color\n        fragColor = resColor;\n        \n        // Fresnel Light\n        fragColor += pow( (1.0-abs( dot( -rayDir, resNormal ) )), FRESNEL_POW )*FRESNEL_INTENSITY;\n        \n        // Sun Shadows\n        fragColor *= (resShadow*dayTime)+(0.42*(1.0-dayTime));\n        \n        // Height Fog\n        float heightFog = 1.0 - clamp( (resHeight/HEIGHT_FOG_Y), 0.0, 1.0 );\n        fragColor = (fragColor*(1.0-heightFog))+(HEIGHT_FOG_COLOR*heightFog);\n        \n        // Distance Fog\n        float distFog = clamp( (resDepth-DIST_FOG_START)*DIST_FOG_DENSITY, 0.0, 1.0 );\n        fragColor = (fragColor*(1.0-distFog))+(distFogColor*distFog);\n        \n        // Store depth in alpha\n        fragColor.a = resDepth;\n    }\n    else\n    {\n        fragColor = distFogColor*(0.1+(0.9*dustTex.g));\n        fragColor.a = FAR_CLIP;\n    }\n    \n    if ( iFrame > 0 )\n    {\n        // Blur using some of previous frame\n    \tfloat prevFrameAmount = 0.2 + (0.5*(1.0-((fragColor.a-NEAR_CLIP)/FAR_CLIP)));\n    \tfragColor.rgb = (prevFragColor.rgb*prevFrameAmount)+(fragColor.rgb*(1.0-prevFrameAmount)); \n    }\n    \n    // Visualize Normal\n    //fragColor = vec4(resNormal, 1);\n    \n    // Visualize Depth\n    //fragColor = vec4(vec3(fragColor.a/FAR_CLIP), 1.0);\n    \n    // Visualize Soup\n    //fragColor = vec4(vec3(soup( -fragCoord.x+(iResolution.xy*0.5).x, fragCoord.y-(iResolution.xy*0.5).y )/TERRAIN_HEIGHT), 1.0);\n    \n    // Visualize Buf A\n\t//fragColor = texture( iChannel0, uv );\n    \n    // Visualize Buf B\n    //fragColor = texture( iChannel1, uv );\n    \n    // Visualize Buf C\n    //fragColor = texture( iChannel2, uv );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}