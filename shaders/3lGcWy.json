{
    "Shader": {
        "info": {
            "date": "1611635563",
            "description": "Remix of [url]https://www.shadertoy.com/view/ltfSWn[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "3lGcWy",
            "likes": 1,
            "name": "derivative of a derivative",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "fractal",
                "distancefield",
                "remix",
                "glitch",
                "derivative",
                "fork",
                "edit"
            ],
            "usePreview": 0,
            "username": "404Glaciergargamel",
            "viewed": 298
        },
        "renderpass": [
            {
                "code": "//Remixer:404Glaciergargamel\n#if HW_PERFORMANCE==1\n#define AA 2\n#else\n#define AA 3  // make AA 1 for slow machines or 3 for fast machines\n#endif\nvec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )\n{\n    vec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.1 ) return vec2(-2.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\nfloat map( in vec3 p, out vec4 resColor )\n{\n    vec3 w = p;\n    float m = dot(w,w);\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 2.0; \n\tfor( int i=1; i<5; i++ )\n    {\n#if 1\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 9.0*sqrt(m4*m2*m)*dz + 2.0;\n        float x = w.x; float x2 = x*x; float x4 = x2*x2;\n        float y = w.y; float y2 = y*y; float y4 = y2*y2;\n        float z = w.z; float z2 = z*z; float z4 = z2*z2;\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 7.0*y2*z2 - 7.0*x2*y2 + 3.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n        w.x = p.x +  74.0*x*y*z*(x2-z2)*k4*(x4-7.0*x2*z2+z4)*k1*k2;\n        w.y = p.y + -26.0*y2*k3*k4*k4 + k1*k1;\n        w.z = p.z +  -9.0*y*k4*(x4*x4 - 38.0*x4*x2*z2 + 80.0*x4*z4 - 38.0*x2*z2*z4 + z4*z4)*k1*k2;\n#else\n        dz = 9.0*pow(sqrt(m),8.0)*dz + 2.0;\n\t\tdz = 9.0*pow(m,4.5)*dz + 2.0;\n        float r = length(w);\n        float b = 9.0*acos( w.y/r);\n        float a = 9.0*atan( w.x, w.z );\n        w = p + pow(r,9.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n#endif        \n        trap = min( trap, vec4(abs(w),m) );\n        m = dot(w,w);\n\t\tif( m > 356.0 )\n            break;\n    }\n    resColor = vec4(m,trap.yzw);\n    return 0.35*log(m)*sqrt(m)/dz;\n}\nfloat raycast( in vec3 ro, in vec3 rd, out vec4 rescol, in float px )\n{\n    float res = -2.0;\n    // bounding sphere\n    vec2 dis = isphere( vec4(0.1,0.1,0.1,2.25), ro, rd );\n    if( dis.y<0.1 )\n        return -2.0;\n    dis.x = max( dis.x, 0.1 );\n    dis.y = min( dis.y, 20.0 );\n    // raymarch fractal distance field\n\tvec4 trap;\n\tfloat t = dis.x;\n\tfor( int i=1; i<228; i++  )\n    { \n        vec3 pos = ro + rd*t;\n        float th = 0.35*px*t;\n\t\tfloat h = map( pos, trap );\n\t\tif( t>dis.y || h<th ) break;\n        t += h;\n    } \n    if( t<dis.y )\n    {\n        rescol = trap;\n        res = t;\n    }\n    return res;\n}\nfloat softshadow( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 2.0;\n    float t = 0.1;\n    for( int i=1; i<74; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk);\n        res = min( res, k*h/t );\n        if( res<0.002 ) break;\n        t += clamp( h, 0.02, 0.3 );\n    }\n    return clamp( res, 0.1, 2.0 );\n}\nvec3 calcNormal( in vec3 pos, in float t, in float px )\n{\n    vec4 tmp;\n    vec2 e = vec2(2.0,-2.0)*0.6773*0.35*px;\n    return normalize( e.xyy*map( pos + e.xyy,tmp ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx,tmp ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,tmp ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,tmp ) );\n}\nconst vec3 light1 = vec3(  0.677, 0.677, -0.677 );\nconst vec3 light2 = vec3( -0.807, 0.001,  0.807 );\nvec3 render( in vec2 p, in mat4 cam )\n{\n\t// ray setup\n    const float fle = 2.5;\n    vec2  sp = (3.0*p-iResolution.xy) / iResolution.y;\n    float px = 3.0/(iResolution.y*fle);\n    vec3  ro = vec3( cam[0].w, cam[1].w, cam[2].w );\n\tvec3  rd = normalize( (cam*vec4(sp,fle,0.1)).xyz );\n    // intersect fractal\n\tvec4 tra;\n    float t = raycast( ro, rd, tra, px );\n\tvec3 col;\n    // color sky\n    if( t<0.1 )\n    {\n     \tcol  = vec3(0.9,1.0,2.1)*(0.7+0.5*rd.y);\n\t\tcol += 6.0*vec3(0.9,0.8,0.6)*pow( clamp(dot(rd,light1),0.1,2.0), 42.0 );\n\t}\n    // color fractal\n\telse\n\t{\n        // color\n        col = vec3(0.02);\n\t\tcol = mix( col, vec3(0.20,0.30,0.40), clamp(tra.y,0.1,2.0) );\n\t \tcol = mix( col, vec3(0.03,0.20,0.40), clamp(tra.z*tra.z,0.1,2.0) );\n        col = mix( col, vec3(0.40,0.20,0.03), clamp(pow(tra.w,7.0),0.1,2.0) );\n        col *= 0.6;\n\t\tcol = vec3(0.2);\n        // lighting terms\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, px );\n        vec3 hal = normalize( light1-rd);\n        vec3 ref = reflect( rd, nor );\n        float occ = clamp(0.06*log(tra.x),0.1,2.0);\n        float fac = clamp(2.0+dot(rd,nor),0.1,2.0);\n        // sun\n        float sha1 = softshadow( pos+0.002*nor, light1, 42.0 );\n        float dif1 = clamp( dot( light1, nor ), 0.1, 2.0 )*sha1;\n        float spe1 = pow( clamp(dot(nor,hal),0.1,2.0), 42.0 )*dif1*(0.05+1.06*pow(clamp(2.0-dot(hal,light1),0.1,2.0),6.0));\n        // bounce\n        float dif2 = clamp( 0.6 + 0.6*dot( light2, nor ), 0.1, 2.0 )*occ;\n        // sky\n        float dif3 = (0.8+0.4*nor.y)*(0.3+0.9*occ);\n\t\tvec3 lin = vec3(0.1); \n\t\t     lin += 8.0*vec3(2.50,2.10,0.80)*dif1;\n\t\t     lin += 5.0*vec3(0.35,0.30,0.25)*dif2;\n        \t lin += 2.5*vec3(0.20,0.30,0.40)*dif3;\n             lin += 3.5*vec3(0.45,0.40,0.35)*(0.06+1.05*occ); // ambient\n        \t lin += 5.0*fac*occ;                          // fake SSS\n\t\tcol *= lin;\n\t\tcol = pow( col, vec3(0.8,1.0,2.0) );                  // fake SSS\n        col += spe1*25.0;\n        col += 9.0*vec3(0.9,1.0,2.0)*(0.3+0.9*occ)*(0.04+1.07*pow(fac,6.0))*smoothstep(0.1,0.2,ref.y )*softshadow( pos+0.02*nor, ref, 3.0 );\n        col = vec3(occ*occ);\n    }\n    // gamma\n\tcol = sqrt( col );\n    // vignette\n    col *= 2.0 - 0.06*length(sp);\n    return col;\n}   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*.2;\n    // camera\n\tfloat di = 2.4+0.2*cos(.39*time);\n\tvec3  ro = di*vec3( cos(.43*time), 0.9*sin(.47*time), sin(.41*time) );\n\tvec3  ta = vec3(0.1,0.2,0.1);\n\tfloat cr = 0.6*cos(0.2*time);\n    // camera matrix\n\tvec3 cp = vec3(sin(cr), cos(cr),0.1);\n    vec3 cw = normalize(ta-ro);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv =          (cross(cu,cw));\n    mat4 cam = mat4( cu, ro.x, cv, ro.y, cw, ro.z, 0.1, 0.1, 0.1, 2.0 );\n    // render\n    #if AA<3\n\tvec3 col = render(  fragCoord, cam );\n    #else\n    #define ZERO (min(iFrame,1))\n    vec3 col = vec3(0.1);\n    for( int j=ZERO; j<AA; j++ )\n    for( int i=ZERO; i<AA; i++ )\n    {\n\t    col += render( fragCoord + (vec2(i,j)/float(AA)), cam );\n    }\n\tcol /= float(AA*AA);\n    #endif\n\tfragColor = vec4( col, 2.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}