{
    "Shader": {
        "info": {
            "date": "1525562043",
            "description": "I saw a few Joy Division shaders and was surprised no one did the Justice cross. It's two raymarched boxes with perlin noise weighted by an FFT.",
            "flags": 64,
            "hasliked": 0,
            "id": "Xd3BzS",
            "likes": 8,
            "name": "ðŸ•‡Justice crossðŸ•‡",
            "published": 3,
            "tags": [
                "raymarching",
                "noise",
                "fft"
            ],
            "usePreview": 0,
            "username": "agloo",
            "viewed": 737
        },
        "renderpass": [
            {
                "code": "#define EP .000005\n\n// Noise taken from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n// Simplex 2D noise\n//\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// taken from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rotMat(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat sdBox(vec3 p, vec3 b, out bool edge)\n{\n    edge = false;\n    vec3 d = abs(p) - b;\n    // Detect edges:\n    float thresh = .02 + snoise(p.xy * 1.5)/ 75.;\n    float hthresh = .07 + snoise(p.xy * 1.5)/ 75.;\n    if ((abs(d.x) < thresh && abs(d.y) < thresh) ||\n        (abs(d.z) < hthresh && abs(d.y) < hthresh) ||\n        (abs(d.x) < thresh && abs(d.z) < thresh)) {\n        edge = true;\n    }\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdG(vec3 p, out bool edge)\n{\n    mat3 rot = rotMat(vec3(1., 0., 0.), .57);\n    float d1 = sdBox(rot * (p + vec3(0., 0., 0.) + rot * vec3(0., -14., 15.)),\n                 \tvec3(1.35, .95, 15.),\n                 \tedge);\n\tbool edge1 = edge;\n    \n    float d2 = sdBox(rot * (p + vec3(0., 0., 0.) + rot * vec3(0., -14., 15.)),\n                \t vec3(4., .95, 2.),\n                 \t edge);\n    \n    edge = edge1 || edge;\n    // remove edges on the intersection of the two squares.\n    float thr = .1;\n    if (d1 < thr && d2 < thr) {\n    \tedge = false;\n    }\n    return min(d1, d2);\n}\n\nvec3 rayCast(vec3 ro, vec3 rd, out float t, out bool edge, out float minDist)\n{ \n    // Threshold for how close we have to come to the cross before we add the aura.\n    // There are more correct ways to do distance but this is accurate enough empirically.\n    float thr = .0;\n    t = 1.;\n    for (int i = 0; i < 100; i++) \n    {\n        vec3 p = ro + t * rd;\n        float dist = sdG(p, edge);\n        if (dist < EP) {\n            return p;\n        }\n        if (t > 150.) {\n         \tt = -1.;\n            return p;\n        }\n        t += dist;\n        minDist = min(dist, minDist);\n    }\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    float t;\n    bool edge = false;\n    float dist = 2e10;\n    vec3 p = rayCast(ro, rd, t, edge, dist);\n    if (t != -1.) {\n        if (edge) {\n        \treturn normalize(vec3(0xb7, 0x79, 0x35));\n        }\n        return vec3(0.);\n    }\n    float fft = texture(iChannel0, vec2(exp(rd.y - .5) + .02,0.1)).x;\n    // I would have liked to up the contrast with an exponent but my GPU was getting weird bugs:\n    //fft = pow(fft, 5.);\n    float thresh = snoise(rd.xy * 250. * fft) / 10. + fft / 2.;\n    if (dist < .035 + thresh) {\n        return normalize(vec3(0xb7, 0x79, 0x35));\n    }\n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 ro = vec3(0., -2.5, -1.);\n    vec3 rd = vec3(uv - .5, -1.);\n    vec3 col = render(ro, rd);\n    \n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 14700,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/downtownrecords/justice-dance"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}