{
    "Shader": {
        "info": {
            "date": "1583529610",
            "description": "Tried out a different method of modelling the face. Made it a lot more rugged loooking, so finished it off with some warpaint. Just don't feel like working on the ears though.",
            "flags": 0,
            "hasliked": 0,
            "id": "wlKSDy",
            "likes": 10,
            "name": "facepaint",
            "published": 3,
            "tags": [
                "sdf",
                "3dmodel"
            ],
            "usePreview": 0,
            "username": "samhattangady",
            "viewed": 419
        },
        "renderpass": [
            {
                "code": "/*\n * 01 Mar 2020\n * Just want to make something from scratch again. I think building on the things\n * that I have built before may not be the best approach for every single model,\n * because it doesn't always allow me to get the practice in, and I stick to doing\n * things the same way every time, and don't have an oppurtunity to improve the base\n * framework... ‾\\_(ツ)_/‾\n * As far as possible, apart from the sdf functions, I want to rewrit the whole thing\n * from scratch, just to see where the whole thing can be simpler.\n*/\n\n#define RAYMARCH_STEPS 100\n#define MAX_RAYMARCH_DISTANCE 15.0\n#define RAYMARCH_SURFACE_DISTANCE 0.01\n#define PI 3.14159\nvec3 rotate3D(vec3 point, vec3 rotation) {\n    vec3 r = rotation;\n\tmat3 rz = mat3(cos(r.z), -sin(r.z), 0,\n                   sin(r.z),  cos(r.z), 0,\n                   0,         0,        1);\n    mat3 ry = mat3( cos(r.y), 0, sin(r.y),\n                    0       , 1, 0       ,\n                   -sin(r.y), 0, cos(r.y));\n    mat3 rx = mat3(1, 0       , 0        ,\n                   0, cos(r.x), -sin(r.x),\n                   0, sin(r.x),  cos(r.x));\n    return rx * ry * rz * point;\n}\nfloat sdfSphere(vec3 position, vec3 center, float radius) {\n    return distance(position, center) - radius;\n}\nfloat sdfEllipsoid(vec3 position, vec3 center, vec3 radii) {\n    position -= center;\n    float k0 = length(position/radii);\n    float k1 = length(position/(radii*radii));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdfEllipsoidRotated(vec3 position, vec3 center, vec3 radii, vec3 rotation) {\n\tposition -= center;\n    position = rotate3D(position, rotation);\n    float k0 = length(position/radii);\n    float k1 = length(position/(radii*radii));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdfPlane( vec3 position, vec4 n ) {\n    return dot(position, normalize(n.xyz)) + n.w;\n}\nfloat sdfRoundBoxRotated(vec3 position, vec3 center, vec3 box, vec3 rotation, float radius) {\n    position -= center;\n    position = rotate3D(position, rotation);\n    vec3 q = abs(position) - box;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius;\n}\nfloat dot2(vec2 v) {\n\treturn dot(v, v);\n}\nvec4 sdfJoint3DSphere(vec3 position, vec3 start, vec3 rotation, float len, float angle, float thickness) {\n    vec3 p = position;\n    float l = len;\n    float a = angle;\n    float w = thickness;\n    p -= start;\n    p = rotate3D(p, rotation);\n\n    if( abs(a)<0.001 ) {\n        return vec4( length(p-vec3(0,clamp(p.y,0.0,l),0))-w, p );\n    }\n\n    vec2  sc = vec2(sin(a),cos(a));\n    float ra = 0.5*l/a;\n    p.x -= ra;\n    vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n    float u = abs(ra)-length(q);\n    float d2 = (q.y<0.0) ? dot2( q+vec2(ra,0.0) ) : u*u;\n    float s = sign(a);\n    return vec4( sqrt(d2+p.z*p.z)-w,\n               (p.y>0.0) ? s*u : s*sign(-p.x)*(q.x+ra),\n               (p.y>0.0) ? atan(s*p.y,-s*p.x)*ra : (s*p.x<0.0)?p.y:l-p.y,\n               p.z );\n}\nfloat sdfCappedCone( vec3 p, vec3 origin, vec3 scale, float h, float r1, float r2, float radius )\n{\n    p*=scale;\n    p -= origin;\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) ) - radius;\n}\nfloat smin(float d1, float d2, float k) {\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\nfloat smax(float d1, float d2, float k) {\n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n}\nvec2 distanceField(vec3 pos) {\n    //pos = rotate3D(pos, vec3(0.0, 0.0, -0.2));\n    float material = 1.0;\n    float d, d1, d2;\n    vec3 t1, symx;\n    d = MAX_RAYMARCH_DISTANCE;\n    // base head\n    d1 = sdfCappedCone(pos, vec3(0.0, -0.0, 0.0), vec3(1.0, 1.0, 1.0), 1.0, 0.5, 0.3, 0.9);\n    d = smin(d, d1, 0.001);\n    d1 = sdfSphere(pos, vec3(0.0, 0.5, 0.4), 1.6);\n    d = smin(d, d1, 0.4);\n\n    // eyesockets\n    d1 = sdfRoundBoxRotated(pos, vec3(0.0, 0.6, -1.2), vec3(2.0, 0.0, 0.0), vec3(0.0, 0.0, 0.12), 0.4);\n    d2 = sdfRoundBoxRotated(pos, vec3(0.0, 1.2, -1.2), vec3(2.5, 0.4, 0.4), vec3(-0.4, 0.0, 0.18), 0.1);\n    d1 = smax(d1, -d2, 0.1);\n    d = smax(d, -d1, 0.2);\n\n    // cheekbones\n    symx = vec3(abs(pos.x), pos.yz);\n    d1 = sdfSphere(symx, vec3(0.8, -0.25, -0.8), 0.3);\n    d = smin(d, d1, 0.4);\n\n    // chin\n    d1 = sdfRoundBoxRotated(pos, vec3(0.0, -1.4, -1.05), vec3(0.4, 0.2, 0.2), vec3(0.3, 0.0, 0.0), 0.04);\n    d = smin(d, d1, 0.5);\n\n    // jaw\n    symx = vec3(abs(pos.x), pos.yz);\n    d1 = sdfRoundBoxRotated(symx, vec3(0.8, -1.0, -0.4), vec3(0.3, 0.2, 0.6), vec3(-0.3, 0.8, 0.3), 0.01);\n    d = smin(d, d1, 0.5);\n\n    // nose\n    t1 = pos-vec3(0.0, 0.4, -1.0);\n    t1 = rotate3D(t1, vec3(0.4, 0.0, 0.0));\n    symx = vec3(abs(t1.x), t1.yz);\n    d1 = sdfRoundBoxRotated(t1, vec3(0.0), vec3(0.1, 0.4, 0.2), vec3(-0.2, 0.0, 0.0), 0.05);\n    d2 = sdfRoundBoxRotated(t1, vec3(0.0, -0.4, 0.0), vec3(0.06, 0.4, 0.2), vec3(0.2, 0.0, 0.0), 0.05);\n    d1 = smin(d1, d2, 0.1);\n    d2 = sdfSphere(t1, vec3(0.0, -0.72, -0.23), 0.1);\n    d1 = smin(d1, d2, 0.2);\n    d2 = sdfSphere(t1, vec3(0.22, -0.64, -0.2), 0.12);\n    d1 = smin(d1, d2, 0.2);\n    d2 = sdfSphere(t1, vec3(-0.23, -0.66, -0.2), 0.13);\n    d1 = smin(d1, d2, 0.2);\n    d = smin(d, d1, 0.2);\n\n    //eyes\n    d1 = sdfSphere(pos, vec3(0.44, 0.5, -0.8), 0.35);\n    if (d1<d)\n        material = 2.0;\n    d = smin(d, d1, 0.02);\n    d1 = sdfSphere(pos, vec3(-0.44, 0.5, -0.8), 0.35);\n    if (d1<d)\n        material = 2.0;\n    d = smin(d, d1, 0.02);\n    d1 = sdfSphere(pos, vec3(0.48, 0.49, -1.0), 0.20);\n    if (d1<d)\n        material = 3.0;\n    d = smin(d, d1, 0.02);\n    d1 = sdfSphere(pos, vec3(-0.42, 0.46, -1.0), 0.19);\n    if (d1<d)\n        material = 3.0;\n    d = smin(d, d1, 0.02);\n\n\n    // mouth\n    d1 = sdfSphere(pos, vec3(-0.48, -0.82, -1.4), 0.12);\n    d = smax(d, -d1, 0.23);\n    d1 = sdfSphere(pos, vec3(0.48, -0.82, -1.4), 0.12);\n    d = smax(d, -d1, 0.23);\n    t1 = rotate3D(pos, vec3(0.3, 0.0, -0.1));\n    d1 = sdfCappedCone(t1, vec3(0.1, -0.95, -0.84), vec3(1.0, 1.0, 1.0), 0.2, 0.5, 0.3, 0.0);\n    d = smin(d, d1, 0.12);\n    t1 = rotate3D(pos, vec3(0.27, 0.0, -0.14));\n    d1 = sdfCappedCone(t1, vec3(0.1, -1.35, -0.84), vec3(1.0, 1.0, 1.0), 0.1, 0.3, 0.5, 0.0);\n    d = smin(d, d1, 0.23);\n\n    // neck\n    d1 = sdfCappedCone(pos, vec3(0.0, -1.5, 0.4), vec3(1.0, 1.0, 1.0), 0.9, 1.3, 1.1, 0.1);\n    d = smin(d, d1, 0.05);\n\n    // ears\n    symx = vec3(abs(pos.x), pos.yz);\n    symx = rotate3D(symx, vec3(0.0, 0.0, -0.1));\n    symx.y /= 1.2;\n    t1 = symx - vec3(1.5, 0.13, 0.0);\n    d1 = sdfSphere(t1, vec3(0.0), 0.5);\n    d2 = sdfRoundBoxRotated(t1, vec3(0.0), vec3(0.1, 2.0, 2.0), vec3(0.0, 0.9, 0.0), 0.0);\n    d1 = smax(d2, d1, 0.05);\n    d2 = sdfSphere(t1, vec3(0.25, 0.1, 0.0), 0.1);\n    d1 = smax(-d2, d1, 0.3);\n    d2 = sdfSphere(t1, vec3(0.21, -0.1, -0.01), 0.1);\n    d1 = smax(-d2, d1, 0.1);\n    d = smin(d, d1, 0.05);\n\n    // warpaint\n    symx = vec3(abs(pos.x), pos.yz);\n    d1 = sdfRoundBoxRotated(symx, vec3(0.74, 0.1, -1.0), vec3(0.25, 0.04, 1.0), vec3(0.0, 0.0, 0.2), 0.1);\n    if (d1<d)\n        material = 4.0;\n\n\n    return vec2(d, material);\n}\n\nvec2 raymarch(vec3 point, vec3 direction) {\n    // return type: vec2(distance, material);\n    float dist = 0.0;\n    vec2 d;\n    for (int i=0; i<RAYMARCH_STEPS; i++) {\n        d = distanceField(point);\n        dist += d.x;\n        point += d.x * direction;\n        if (d.x < RAYMARCH_SURFACE_DISTANCE)\n            return vec2(dist, d.y);\n        if (dist > MAX_RAYMARCH_DISTANCE)\n            return vec2(dist, 0.0);\n    }\n    return vec2(dist, 0.0);\n}\n\nvec3 calculate_normal(vec3 pos) {\n    vec3 h = vec3(0.001, 0.0, 0.0);\n    float d = distanceField(pos).x;\n    return normalize(vec3(\n                d-distanceField(pos+h.xyy).x,\n                d-distanceField(pos+h.yxy).x,\n                d-distanceField(pos+h.yyx).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)*2.0 - vec2(1.0);\n    uv.y *= iResolution.y / iResolution.x;\n    vec3 point = vec3(uv, -5.0);\n    vec3 camera = vec3(0.0, 0.0, -6.0);\n    float mouseX = ((-iMouse.x/iResolution.x)+0.5)*PI/1.5;\n    mouseX = 0.3 + 0.3*sin(iTime/2.0);\n\n    point = rotate3D(point, vec3(0.0, mouseX, 0.0));\n    camera = rotate3D(camera, vec3(0.0, mouseX, 0.0));\n    vec3 light_position = vec3(1.0, 1.0, -3.0);\n    vec3 ray_direction = normalize(point-camera);\n    vec2 obj = raymarch(point, ray_direction);\n    float dist = obj.x;\n    float material = obj.y;\n    vec3 color = vec3(0.01);\n    if (dist < MAX_RAYMARCH_DISTANCE) {\n        vec3 surface_point = point + ray_direction*dist;\n        vec3 normal = calculate_normal(surface_point);\n        float light = dot(normal, normalize(surface_point-light_position));\n        light = max(0.0, light);\n        if (material < 1.5) {\n            color = vec3(0.38, 0.22, 0.15);\n            color += vec3(0.18) * smoothstep(0.1, 1.0, light);\n            color += vec3(0.05) * smoothstep(0.3, 1.0, light);\n        } else if (material < 2.5) {\n            color = vec3(0.25, 0.28, 0.34);\n            color += vec3(0.33) * smoothstep(0.1, 1.0, light);\n        } else if (material < 3.5) {\n            color = vec3(0.03, 0.025, 0.02);\n            color += vec3(0.2) * smoothstep(0.9, 1.0, light);\n        } else if (material < 4.5) {\n            color = vec3(0.002, 0.002, 0.002);\n            color += vec3(0.1) * smoothstep(0.1, 1.0, light);\n        }\n    }\n    color = pow( color, vec3(1.0/2.2) );\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}