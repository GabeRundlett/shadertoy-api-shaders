{
    "Shader": {
        "info": {
            "date": "1660326492",
            "description": "cccccccc",
            "flags": 32,
            "hasliked": 0,
            "id": "fl3yRl",
            "likes": 13,
            "name": "Day 967",
            "published": 3,
            "tags": [
                "voxel",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 509
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 C, vec2 U){\n    vec2 uv = (U)/R.xy;\n\n    vec3 col = vec3(0);\n    \n    vec2 st = (0.5)/R.xy;\n\n    \n    float l = \n        Ta(uv + vec2(st.x,0)).x-(Ta(uv - vec2(st.x,0))).x +\n        Ta(uv + vec2(0,st.y)).x-(Ta(uv - vec2(0,st.y))).x +\n        Ta(uv + vec2(st.xy)).x -(Ta(uv - vec2(st.xy))).x +\n        Ta(uv + vec2(st.x,-st.y)).x-(Ta(uv - vec2(st.x,-st.y))).x\n    ;\n    \n    l = clamp(abs(l),0.,1.);\n    \n    C = Ta(uv);\n    \n    \n    float dith = texture(iChannel1,U.xy/vec2(textureSize(iChannel1,0).xy*(1 + 0*int(fract(iTime*0.1) < 0.2)))).x;\n    \n    \n    float quant = 6. - float(fract(iTime/3./2.) > 0.8)*2.;\n    float recipQuant = 1./quant;\n    \n    vec4 s = Ta(uv);\n    vec3 currColHsv = rgb2hsv(s.xyz);\n    //s = hsv2rgbSmooth(currColHsv*vec3(1,0.2,1.) + vec3(0.3,0.,0.)).xyzz;\n    //s = vec4(luma(s));\n    vec4 currC = floor(s*quant)/quant;\n    vec4 nextC = clamp(currC + recipQuant,0.,1.);\n    float perc = fract(luma(s)*quant);\n    \n    \n    vec2 nuv = (U - 0.5*R.xy)/max(R.x,R.y);\n    \n    \n    float bmod = float(lightMode==0.)*float(fract(iTime*0.125)<0.5);\n    float db = sdBox(nuv + vec2(0,-bmod*0.6),vec2(0.45,0.25 - bmod*0.24)*1.1);\n    \n\n    if(perc>dith){\n        C = nextC;\n    } else{\n        C = currC;\n    }\n    \n    \n    //C = mix(C,1.-C,smoothstep(dFdx(nuv.x),0.,abs(db) - 0.001 - 0.4*float(enva(iTime)>0.9)));\n    \n    \n    C = mix(C,1.-C,smoothstep(0.001,0.,abs(db) - 0.001 - 0.4*float(enva(iTime)>0.9)));\n    \n    \n    // outlines\n    if( db < 0.)\n        C = mix(C,-(0. + 14.*float(fract(iTime*0.25) < 0.5))*C,l);\n    else  \n        C = pow(abs(C),vec4(0.4545));\n        \n    \n    \n  \n    //C = abs(C);\n    \n    if(fract(iTime*0.33/2.) < 0.25 && hash11(floor(iTime)) < 0.2){\n        C = 1.-C;\n        C = pow(abs(C),vec4(0.454545));\n    }\n    if(fract(iTime*0.1) < 0.5){\n        float dbb = sdBox(nuv + vec2(0.4,0.2),vec2(0.45,0.25 - bmod*0.24)*0.1);\n        \n        if(dbb<0.&& hash11(floor(iTime)) < 0.2)\n            C *= 0.;\n        dbb = sdBox(nuv - vec2(0.4,0.),vec2(0.02,0.2 - bmod*0.));\n        \n        if(dbb<0.&& hash11(floor(iTime*0.99 + 0.06) + 150.) < 0.1)\n            C *= 0.;\n        // ui col blocks\n        vec2 p = nuv;\n        \n        float md = 0.0156;\n        \n        vec2 id = floor(p/md);\n        p = pmod(p,md); \n        \n        float d = length(p.xy) - 0.004;\n        \n        float ra = hash12(id + 10.);\n        vec2 r = hash22(id + 200. + floor(iTime*1.5 + ra*1.));\n        \n        \n        \n        if(abs(id.y-14.) <2.  && abs(id.x) < 18.){\n            if(sin(iTime + sin(r.y*3.)*4.)> 0.){\n                if(r.y < 0.5){\n                    int cidx = int(r.x*4.*4.);\n                    vec3 c = palAppleII[cidx];\n\n                    c = rgb2hsv(c);\n                    c = hsv2rgbSmooth( c *vec3(1,0.1 + lightMode,1));\n\n                    C.xyz = c;\n                \n                } else{\n                    C = vec4(0);\n                }\n            \n            \n            } else{\n                C = 1.- C;\n            }\n            \n            \n               \n        }\n\n         \n    }     \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi acos(-1.)\n#define R iResolution.xy\n#define iTime (iTime + 20.)\n\n\n#define pi acos(-1.)\n\n#define R iResolution.xy\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define Ta(u) texture(iChannel0,u)\n#define Tb(u) texture(iChannel1,u)\n#define Tc(u) texture(iChannel2,u)\n#define Td(u) texture(iChannel3,u)\n\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n\nfloat enva(float t){\n    return (fract(t*0.25) );\n}\n#define lightMode float(fract(iTime*0.1) <0.5 )\nfloat sdBox(vec2 c, vec2 s){\n    c = abs(c) - s; return max(c.x,c.y);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nfloat noise(vec3 p_, float t){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.+ (t + sin(t))*0.4);\n    p.xy *= rot(1.4);\n    p.x *= 3.;\n    for(float i = 0.; i < 2.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(1.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 2.4;\n        p *= 1.5;\n    }\n    \n    //n = n * 0.9;\n    //n = sin(n*2.);\n    return n;\n}\n\n\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luma(vec3 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n// from iq\nvec3 hsv2rgbSmooth( in vec3 hsv )\n{\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\n\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\n}\n\n\nvec3[4*4] palAppleII = vec3[](\n    vec3(217, 60, 240)/255.,\n    vec3(64, 53, 120)/255.,\n    vec3(108, 41, 64)/255.,\n    vec3(0, 0, 0)/255.,\n\n    vec3(236, 168, 191)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(217, 104, 15)/255.,\n    vec3(64, 75, 7)/255.,\n\n    vec3(191, 180, 248)/255.,\n    vec3(38, 151, 240)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(19, 87, 64)/255.,\n\n    vec3(255, 255, 255)/255.,\n    vec3(147, 214, 191)/255.,\n    vec3(191, 202, 135)/255.,\n    vec3(38, 195, 15)/255.\n);\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Fork of \"Day 966\" by jeyko. https://shadertoy.com/view/fltcRf\n// 2022-08-12 07:41:35\n\n\nfloat pixelScale = 4.;\n\nvec3 camPos;\n\nfloat map(vec3 p){\n    p *= 1./pixelScale;\n    float n = noise(p*(2. + 15.*floor(fract(iTime*0.05)*3.)),iTime);\n    float cbox = -length(p-camPos) +0.3;\n    \n   \n    //p.y += sin(p.x + cos(p.z*2.)*4.  + cos(p.z*2.)*4.)*0.2;\n    \n    float d = p.y;\n    \n    d = min(d, abs(p.y -1.8) - 0.1*sin(iTime));\n    \n    \n    d = n;\n    //d = max(d, (p.y+0.4));\n    \n    //d -= dot(p.xz,p.xz)*0.01;\n    d = max(d,cbox);\n    \n    //d = max(d,-length(p - vec3(0,sin(iTime*0.5 + sin(iTime*0.5)),0)) +0.4);\n    return d;\n}\n\nfloat mapQuantized(vec3 p){\n    return map(floor(p));\n}\n\nvec3 getRd(vec3 ro, vec3 target, vec2 uv){\n    vec3 dir = normalize(target - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up * uv.y);\n}\n\n\nvec3 getNormal(vec3 p){\n    vec2 t= vec2(0.001,0.);\n    return normalize(vec3(\n        map(p + t.xyy) - map(p - t.xyy),\n        map(p + t.yxy) - map(p - t.yxy),\n        map(p + t.yyx) - map(p - t.yyx)\n    ));\n}\n\n\nvec3 getNormalQuantized(vec3 p, int hitAxis){\n    vec2 t= vec2(0.04,0.);\n    vec3 hitVec = vec3(0);\n    hitVec[hitAxis] = 1.;\n    hitVec = mix(hitVec,vec3(1),0.05);\n    return normalize(vec3(\n        mapQuantized(p + t.xyy*hitVec) - mapQuantized(p - t.xyy*hitVec),\n        mapQuantized(p + t.yxy*hitVec) - mapQuantized(p - t.yxy*hitVec),\n        mapQuantized(p + t.yyx*hitVec) - mapQuantized(p - t.yyx*hitVec)\n    ));\n}\n\nvoid mainImage( out vec4 C, vec2 U){\n\n    if(fract(iTime*0.1) > 0.5)\n        pixelScale = 1.;\n    vec2 uv = (U-0.5*R.xy)/R.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0);\n    \n    vec2 muv = iMouse.xy/R.xy;\n    float rotEnv = (iTime + sin(iTime + sin(iTime*0.7)*0.4)*0.4)*0.2;\n    ro.xz = vec2(cos(rotEnv +muv.x*pi),sin(rotEnv +muv.x*pi));\n    ro.y = 0.9;\n    \n    ro.y += sin(iTime*0.5)*0.2 - muv.y*2. + 0.;\n    \n    \n    \n    if(fract(iTime*0.15) > 0.5)\n        ro.y = -0.2;\n    camPos = ro;\n    ro *= pixelScale;\n    \n    //ro = floor(ro); // truley amazine\n    vec3 p = ro;\n    \n    \n    vec3 rd = getRd(ro, sin(vec3(3,2,1)*iTime*0.1)*pixelScale*.3,uv);\n    \n    float t = 0.;\n    bool hit = false;\n    \n    \n    int hitAxis = 0;\n    \n\n    float fZ;\n    float fX;\n    float fY;\n\n    float mn = 100.;\n    float i = 0.;\n    // voxel march\n    {\n\n        // basic trigonometry used to calculate the step size in each dir.\n        // sin(angle) = opposite/hypotenuse\n        // hypotenuse = 1./sin(angle)\n        \n        float zHypot;\n        float xHypot;\n        float yHypot;\n        \n        {\n            float zAngle = atan(rd.x/rd.z);\n            if(rd.z < 0.)\n                zAngle *= -1.;\n            if(rd.x < 0.)\n                zAngle *= -1.;\n\n            zHypot = 1./sin(zAngle);\n        }\n        {\n            float xAngle = atan(rd.z/rd.x);\n            if(rd.z < 0.)\n                xAngle *= -1.;\n            if(rd.x < 0.)\n                xAngle *= -1.;\n\n            xHypot = 1./sin(xAngle);\n        }\n        \n        {\n            float yAngle = acos(rd.y);\n            yHypot = 1./sin(yAngle); \n        }\n        \n        \n        \n        const float maxFractalD = 5.;\n        float currFractalD = 1.;\n        float[int(maxFractalD + 2.)] walkTillExit;\n        float[int(maxFractalD + 2.)] currDWalk;\n        for(int i = 0; i < walkTillExit.length(); i++){walkTillExit[i] = 0.;}\n        for(int i = 0; i < currDWalk.length(); i++){walkTillExit[i] = 0.;}\n        walkTillExit[1] = 10000.;\n        \n        for( i = 0.; i < 4414.; i++){\n            vec3 fracP = fract(p*currFractalD);\n            \n            float d = map(floor(p*currFractalD ));\n            \n           \n            if(d < 0.){\n                // EXIT HIT FINAL\n                if(currFractalD > maxFractalD){\n                    //p *= currFractalD;\n                    hit = true;\n                    break;\n                }\n            }             \n            if(rd.z < 0.){\n                fracP.z = 1. - fracP.z;\n            }\n            if(rd.x < 0.){\n                fracP.x = 1. - fracP.x;\n            }\n            if(rd.y < 0.){\n                fracP.y = 1. - fracP.y;\n            }\n            \n            const float overStepFac = 1.0001;\n            fZ = xHypot*(overStepFac-fracP.z);\n            fX = zHypot*(overStepFac-fracP.x);\n            fY = yHypot*(overStepFac-fracP.y);\n            \n            float minWalk = min(min(fZ,fX),fY);\n            \n            if(d < 0. && currFractalD <= maxFractalD){\n                // HIT CURR\n                currFractalD += 1.;\n                walkTillExit[int(currFractalD)] = minWalk;\n                currDWalk[int(currFractalD)] = 0.;\n            } else {\n                // WALK\n                float stepSz = minWalk / currFractalD;\n                currDWalk[int(currFractalD)] += stepSz;\n                t += stepSz;\n                p += rd * stepSz;\n                \n                // REDUCE D\n                if(currDWalk[int(currFractalD)] + 0.4 > walkTillExit[int(currFractalD)]){\n                    currFractalD -= 1.;\n                    p += rd * (0.001 + 0.5*float(fract(iTime*0.1)<0.1));\n                                        \n                    if(currFractalD == 0.){\n                        break;\n                    }\n                }\n            }\n            \n            \n            \n            \n        }    \n\n    }\n    \n    if(fZ < mn){\n        mn = fZ;\n        hitAxis = 2;\n    }if(fX < mn){\n        mn = fX;\n        hitAxis = 0;\n    }if(fY < mn){\n        mn = fY;\n        hitAxis = 1;\n    }    \n    \n    col = vec3(1);\n    \n    \n    #define ao(p,n,d,amt) mix(1.,clamp(map(p+n*d)/d/pixelScale,0.,1.),amt)\n    \n    // sghading\n    if(hit){\n        \n        float normalSign = sign(fract(p[hitAxis]) - 0.5);\n        \n        vec3 n = getNormal(p);\n        vec3 nq = vec3(0);\n        nq[hitAxis] = 1.;\n        nq *= normalSign;\n        \n        \n        vec3 q = abs(fract(p) - 0.5)*1.5;\n        q[hitAxis] = 0.;\n        \n        \n        //col = mix(col,col*-(0. + float(fract(iTime*0.1) < 0.5)),max(q.x,max(q.y,q.z)));\n        //col = mix(col,col*0.,max(q.x,max(q.y,q.z)));\n        \n        col = 0.5*nq + 0.5;\n        \n        \n        col = abs(col);\n        \n        \n        col = palAppleII[int(floor(p.x)*14. + nq.x + nq.y*10.)%16];\n        col = pow(abs(col),vec3(.4545));\n        \n        float AO = 1. \n            //ao(p + nq*0.,nq,0.6*pixelScale,0.9)\n            * ao(p + nq*0.,nq,40.*pixelScale,0.5)\n            * ao(p + nq*0.,nq,1.*pixelScale,0.7)\n            * ao(p,nq,1.4*pixelScale,0.5)\n            //* ao(p + nq*0.,n,0.2*pixelScale,0.5)\n            //* ao(p + nq*0. + vec3(0.5,0.4,0)*pixelScale,n,1.*pixelScale,.4)\n            //* ao(p,normalize(mix(n,vec3(1,1,0),1.)),1.4*pixelScale,0.8)\n            \n            ;\n        {\n        if(fract(iTime*0.125) < 0.2)\n            col *= 1. * AO;\n        }\n        col *= smoothstep(-80.5,40.,p.y);\n        col *= 1.3;\n    }\n    \n    \n    col = mix(\n        col,\n        sin(col*1. + i*(.04 + 0.4*float(fract(iTime*0.4) < 0.5)))*0.5 + 0.5,\n        exp(-i*(0.01+ 0.*float(fract(iTime*0.1)> 0.89)))\n    );\n    col = mix(col, vec3(1),\n        smoothstep(1.,5.,t*0.4)    \n        );\n    \n    col *= 1. - dot(uv,uv)*0.7;\n    \n    C = 1.-exp(-abs(C));\n    C = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}