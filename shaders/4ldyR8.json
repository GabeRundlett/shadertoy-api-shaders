{
    "Shader": {
        "info": {
            "date": "1531575221",
            "description": "My take on BigWings' voronoi-pattern tutorial available here https://www.youtube.com/watch?v=l-07BXzNdPw\n\nDoing it in the fragment-shader is so much easier than the \"traditional\" way with polygonal data! Next step 3D and more colors.",
            "flags": 0,
            "hasliked": 0,
            "id": "4ldyR8",
            "likes": 9,
            "name": "My take on BigWings' voronoi-tut",
            "published": 3,
            "tags": [
                "2d",
                "voronoi"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 761
        },
        "renderpass": [
            {
                "code": "vec2 noise2d (in vec2 p)\n{\n\tvec3 v = fract (p.xyx*vec3(123.34, 234.34, 345.65));\n\tv += dot (v, v + 34.45);\n\treturn fract (vec2 (v.x*v.y, v.y*v.z));\n}\n\nmat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n    float c = cos (rad);\n    float s = sin (rad);\n    return mat2 (c, s, -s, c);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat time = iTime + 3.;\n\n    // normalize and aspect-correct UVs\n    vec2 uv = fragCoord/iResolution.xy*2. - 1.;\n\tfloat aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n\n    // rotate and move the canvas\n    uv *= r2d (24.*time);\n    uv += vec2 (.2*cos (time), .3*sin(time));\n\n    // cause the canvas to 'zoom'\n    float scale = 3. + 3.*(.5 + .5*cos(time));\n    uv *= scale;\n    float rowSize = scale *.5;\n\n    // split canvas up\n    vec2 gv = fract (uv) - .5;\n    vec2 id = floor (uv);\n\n    float cellIndex = .0; \n    float minDist = 2.;\n\n    // check only the adjacent grid-cells\n    for (float y = -1.; y <= 1.; ++y) {\n        for (float x = -1.; x <= 1.; ++x) {\n            vec2 offset = vec2 (x, y); \n            vec2 n = noise2d (id + offset);\n            vec2 p = offset + .5*sin (n*(time + 22.75));\n            float d = dot (gv - p, gv - p);\n            if (d < minDist) {\n                minDist = d;\n                cellIndex = (id.y + y) * rowSize + (id.x + x); \n            }\n        }\n    }   \n\n    // 'color' cells in different styles\n    float brightColor = (1. - minDist)*(1. - minDist);\n    float darkColor = minDist*minDist;\n    float flatColor = abs (cellIndex) / (scale*scale);\n    float invertedFlatColor = 1. - flatColor;\n\n    // blend between the four different style-variations\n    float colorOne = mix (brightColor, darkColor, (.5 + .5*cos(1.75*time)));\n    float colorTwo = mix (flatColor, invertedFlatColor, (.5 + .5*cos(1.75*time)));\n    vec3 colorFinal = vec3 (mix (colorOne, colorTwo, .5 + .5*cos(.35*time)));\n\n    // tone-map, gamma-correct\n    //colorFinal = colorFinal / (1. + colorFinal);\n    colorFinal = pow (colorFinal, vec3 (1./2.2));\n\n    fragColor = vec4 (colorFinal, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}