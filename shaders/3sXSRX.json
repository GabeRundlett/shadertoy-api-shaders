{
    "Shader": {
        "info": {
            "date": "1551735390",
            "description": "Volumetric cloud marching based off of https://shaderbits.com/blog/creating-volumetric-ray-marcher/",
            "flags": 0,
            "hasliked": 0,
            "id": "3sXSRX",
            "likes": 12,
            "name": "Volumetric Cloud Marching",
            "published": 3,
            "tags": [
                "raymarching",
                "cloud",
                "volumetric"
            ],
            "usePreview": 0,
            "username": "BackwardsCap",
            "viewed": 1394
        },
        "renderpass": [
            {
                "code": "//Sam Gates\n\n#define MAX_STEPS 48\n#define SHADOW_STEPS 12\n#define VOLUME_LENGTH 15.\n#define SHADOW_LENGTH 2.\n\n//FBM taken from XT95 https://www.shadertoy.com/view/lss3zr\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\n//--------------------------------------------------\n\nfloat map(vec3 p){\n    \n    float f = fbm(p-vec3(0,0.5,1.0)*iTime*.25);\n    \n    float sph = 1.0-length(p*vec3(.5,1,.5))+f*3.5;\n    \n    return min(max(0.0,sph),1.0);\n    \n}\n\nfloat jitter;\n\nvec4 cloudMarch(vec3 p, vec3 r){\n    \n    float density = 0.0;\n    float stepLen = VOLUME_LENGTH/float(MAX_STEPS);\n    float shadowStepLength = SHADOW_LENGTH/float(SHADOW_STEPS);\n    \n    float cloudDensity =20.0;\n  \tvec3 cloudColor = vec3(1.0,.9,.8);\n    \n    vec3 light = vec3(1.,2.,1.);\n    \n    vec4 sum = vec4(vec3(0.),1.);\n    \n    vec3 pos = p+r*jitter*stepLen;\n    \n    for(int i=0;i<MAX_STEPS;i++){\n        \n        if(sum.a<.1)break;\n        \n        float d = map(pos);\n        \n        if(d>0.001){\n            \n            vec3 lp = pos+light*jitter*shadowStepLength;\n            float shadow=0.;\n            \n            for(int x=0;x<SHADOW_STEPS;x++){\n                \n                lp+=light*shadowStepLength;\n                float lightSample = map(lp);\n                shadow+=lightSample;\n                \n                \n            }\n            \n            density = clamp((d/float(MAX_STEPS))*cloudDensity,0.0,1.0);\n            float s = exp((-shadow/float(SHADOW_STEPS))*3.);\n            \n            sum.rgb += vec3(s*density)*cloudColor*sum.a;\n            \n            sum.a*=1.-density;\n            sum.rgb+=exp(-map(pos+vec3(0,.25,0.0))*.2)*density*vec3(.15,.45,1.1)*sum.a;\n        }\n        pos+=r*stepLen;\n        \n    }\n    return sum;\n    \n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr){\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr),cos(cr),0.);\n    vec3 cu = normalize(cross(cw,cp));\n    vec3 cv = normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);\n    jitter = hash(p.x+p.y*57.0+iTime);\n    vec3 ro = vec3(sin(iTime*.5)*10.,-1,cos(iTime*.5)*10.);\n    vec3 ta = vec3(0,1,0);\n    mat3 cam = camera(ro,ta,0.0);\n    vec3 ray = cam*normalize(vec3(p,1.75));\n\n\tvec4 res = cloudMarch(ro,ray);\n    res = pow(res,vec4(2.0/2.2));\n    vec3 col = res.rgb+mix(vec3(0.),vec3(0.,0,.1),res.a);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}