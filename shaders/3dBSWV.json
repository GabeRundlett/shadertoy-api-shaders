{
    "Shader": {
        "info": {
            "date": "1554918246",
            "description": "ok... not the first one! :D\nvery stolen code here and there .. just for fun.\nfrom this shader https://www.shadertoy.com/view/ldjSDc ...i tried to seize the moment :D\nand the blurring shader is https://www.shadertoy.com/view/4lXXWn .",
            "flags": 32,
            "hasliked": 0,
            "id": "3dBSWV",
            "likes": 19,
            "name": "look Ma a black hole!",
            "published": 3,
            "tags": [
                "photo",
                "blackhole",
                "hole",
                "black"
            ],
            "usePreview": 0,
            "username": "pellicus",
            "viewed": 1155
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = texture(iChannel0,fragCoord/iResolution.xy)*.54;\n    float color =(c.r+c.g)*.5;\n    color*=color; color=color * 3.*length(fragCoord/iResolution.xy - vec2(0.5));\n    fragColor=vec4( color, pow(max(color,0.),2.)*0.4, pow(max(color,0.),3.)*0.15 , 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\nBlack hole with gravitational lensing and accretion disc.\n\nReference: \n  Bozza, Valerio. \"Gravitational lensing by black holes.\" General Relativity and Gravitation 42.9 (2010): 2269-2300.\n\nJun 2014.11.24\n\n*/\n\n#define MOVE_CAMERA\n#define GRAV_LENSING\n#define PI 3.14159\n\nvec3 bh=vec3(0.0);\nconst float bh_M=1.2; // G=1,c=1\nconst float r_bar=2.7*bh_M;\nconst float disc_r_orig=r_bar * 2.1;\nvec3 disc_n=vec3(0.,1.,0.);\nvec3 disc_s=vec3(1.,0.,0.);\nvec3 eye=vec3(0.,0.4,10.);\nvec3 up=normalize(vec3(0.08,1.,0.));\nmat3 cam_mat;// camera -> world\nconst float tan_half_vfov=1.0;\n\nvec3 rot_x(vec3 v,float theta)\n{\n    float s=sin(theta),c=cos(theta);\n    return vec3(v.x,c*v.y-s*v.z,s*v.y+c*v.z);\n}\nvec3 rot_y(vec3 v,float theta)\n{\n    float s=sin(theta),c=cos(theta);\n    return vec3(c*v.x+s*v.z,v.y,c*v.z-s*v.x);    \n}\nvec3 rot_z(vec3 v,float theta)\n{\n    float s=sin(theta),c=cos(theta);\n    return vec3(c*v.x-s*v.y,s*v.x+c*v.y,v.z);\n}\nvoid setupCamera()\n{\n#ifdef MOVE_CAMERA\n    vec2 rxy=(iMouse.xy / iResolution.xy-0.5) * PI;\n    eye=rot_x(eye,rxy.y); // fixed target(0,0,0)\n    eye=rot_y(eye,-rxy.x);\n    //up=rot_z(up,-rxy.x);\n#endif\n\tvec3 n=normalize(eye-bh);\n\tvec3 s=normalize(cross(up,n));\n\tvec3 t=cross(n,s);\n    cam_mat[0]=s;\n    cam_mat[1]=t;\n    cam_mat[2]=n;\n}\n\nvec4 disc_color(vec3 p_disc, float disc_r)\n{\n    float time =iTime;\n    vec3 v=p_disc-bh;\n    float d=length(v);v/=d;\n    if(d<disc_r)\n    {   \n        //return vec4(1.0,0.,0.,1.);\n   \t \tvec2 uv=vec2((atan(dot(v,disc_s),dot(v,cross(disc_s,disc_n)))/(2.*PI)*1.-time*0.03),\n                 (d-r_bar)/(disc_r-r_bar));    \n    \treturn 3.*texture(iChannel0,uv)*smoothstep(disc_r,r_bar,d);\n    }\n    else return vec4(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setupCamera();\n\tfloat ruv = length((fragCoord.xy-0.5*iResolution.xy)/iResolution.y);\n    vec4 color=vec4(0.7,0.6,0.8,1.) * exp(-ruv*1.1)*1.15;\n    \n    \n \tvec2 iplane_size=2.*tan_half_vfov*vec2(iResolution.x/iResolution.y,1.);\n    vec2 ixy=(fragCoord.xy/iResolution.xy - 0.5)*iplane_size;\n    vec3 ray_dir=cam_mat*normalize(vec3(ixy,-1.));\n    vec3 h2e=eye-bh;\n    float l2_h2e=dot(h2e,h2e);\n    float rm=length(cross(ray_dir,h2e)); // smallest distance\n    float t_cp=sqrt(l2_h2e-rm*rm); // t of closest point\n    \n\tfloat disc_r=disc_r_orig;\n    \n    //if(rm>r_bar)\n    {\n#ifdef GRAV_LENSING\n        float alpha=4.*bh_M/rm;   \n        disc_r=disc_r_orig;\n        if(rm<r_bar) // hack\n            alpha*=(1.-abs(dot(disc_n,up))),disc_r*=1.25;\n#else\n        float alpha=0.;\n#endif\n        float tan_a_2=tan(alpha*0.5);\n        \n        vec3 cp=eye+ray_dir*t_cp;// closest point\n        vec3 coord_origin=cp+ray_dir*(rm*tan_a_2);\n        vec3 x_axis=normalize(bh-coord_origin);\n        vec3 y_axis=normalize(ray_dir+tan_a_2*normalize(bh-cp));\n       \tvec3 z_axis=cross(x_axis,y_axis);\n       \t\n        float c=length(bh-coord_origin);\n        float k=tan_a_2; // a/b\n        \n        // the intersection line pass through bh\n        vec3 iline_r=normalize(cross(z_axis,disc_n));\n        \n        float x1=-1.,x2=-1.,y1,y2;\n\n#ifdef GRAV_LENSING\n\t\tfloat k2=k*k;\n        float b2=c*c/(1.0+k2);\n        float a2=k2*b2;\n        float a=sqrt(a2);\n        // x^2/a2 - y^2/b2 = 1\n\n        float denom=dot(x_axis,iline_r);\n        if(denom==0.)\n        {\n            x1=x2=c;\n            y1=-b2/sqrt(a2);\n            y2=-y1;\n        }\n        else\n        {\n            float slope=dot(y_axis,iline_r)/denom; // y=slope*(x-c)\n            k2=slope*slope; // override k2\n            float A=a2*k2-b2;\n            float B=-2.*a2*k2*c;\n            float C=a2*(k2*c*c+b2);\n            // B*B-4AC>=0\n            float delta=sqrt(B*B-4.*A*C);\n            x1=(-B-delta)/(2.*A);\n\t\t\tx2=(-B+delta)/(2.*A);\n\t\t\ty1=slope*(x1-c);\n            y2=slope*(x2-c);\n        }\n#else\n        float denom=dot(x_axis,iline_r);\n        if(denom!=0.) // else no intersection\n        {\n            float slope=dot(y_axis,iline_r)/denom;\n            x1=0.;y1=-slope*c;\n        }\n#endif\n        \n        vec3 o2e=eye-coord_origin;\n        float yeye=dot(o2e,y_axis);\n        vec3 p1=coord_origin+x1*x_axis+y1*y_axis,\n            p2=coord_origin+x2*x_axis+y2*y_axis;\n        if(x1>=0.&&y1>=yeye && ((y1<0.&&length(p1-bh)>r_bar)||rm>r_bar))\n        {\n           color+=disc_color(p1, disc_r);\n        }\n        if(x2>=0.&&y2>=yeye && ((y2<0.&&length(p2-bh)>r_bar) ||rm>r_bar))\n        {\n           color+=disc_color(p2, disc_r);\n        }\n    }\n    \n    fragColor=color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec3 draw(vec2 uv) {\n    return texture(iChannel0,vec2(uv.x,1.-uv.y)).rgb;   \n    //return texture(iChannel0,uv).rgb;  \n}\n\nfloat grid(float var, float size) {\n    return floor(var*size)/size;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    \n    float bluramount =  0.1;// sin(time)*0.1;\n    if (iMouse.w >= 1.) {\n    bluramount = (iMouse.x/iResolution.x)/10.;\n    }\n\n    //float dists = 5.;\n    vec3 blurred_image = vec3(0.);\n    #define repeats 60.\n    for (float i = 0.; i < repeats; i++) { \n        //Older:\n        //vec2 q = vec2(cos(degrees((grid(i,dists)/repeats)*360.)),sin(degrees((grid(i,dists)/repeats)*360.))) * (1./(1.+mod(i,dists)));\n        vec2 q = vec2(cos(degrees((i/repeats)*360.)),sin(degrees((i/repeats)*360.))) *  (rand(vec2(i,uv.x+uv.y))+bluramount); \n        vec2 uv2 = uv+(q*bluramount);\n        blurred_image += draw(uv2)/2.;\n        //One more to hide the noise.\n        q = vec2(cos(degrees((i/repeats)*360.)),sin(degrees((i/repeats)*360.))) *  (rand(vec2(i+2.,uv.x+uv.y+24.))+bluramount); \n        uv2 = uv+(q*bluramount);\n        blurred_image += draw(uv2)/2.;\n    }\n    blurred_image /= repeats;\n        \n    fragColor = vec4(blurred_image,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}