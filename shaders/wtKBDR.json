{
    "Shader": {
        "info": {
            "date": "1614201172",
            "description": "Quickly thrown together shader to play around with abs() to get the 'onion skin' effect (see https://iquilezles.org/articles/distfunctions/distfunctions.htm). Added a pillar and some domain repetition to not look too boring.",
            "flags": 64,
            "hasliked": 0,
            "id": "wtKBDR",
            "likes": 4,
            "name": "Marble Onion Skin",
            "published": 3,
            "tags": [
                "3d",
                "fbm",
                "marble",
                "skin",
                "onion",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 1260
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Marble Onion Skin - Trying out the 'onion effect' as stated on iq's website,\n// see https://iquilezles.org/articles/distfunctions for\n// details. The code is almost not commented at all, thus not the best example\n// to learn from.\n//\n// Copyright 2021 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 r2d (float deg) {\n    float r = radians (deg);\n    float c = cos (r);\n    float s = sin (r);\n    return mat2 (c, s, -s, c);\n}\n\nfloat smin (float d1, float d2, float k) {\n    float h = clamp (.5 + .5*(d2 - d1)/k, .0, 1.);\n    return mix (d2, d1, h) - h*k*(1. - h);\n}\n\n// hash(), noise(), fbm() are from an example by iq and/or Shane\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3. - 2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p ) {\n    float f;\n    mat2 m = r2d (1.1);\n\n    f  = .5*noise( p ); p.xz *= m*2.02;\n    f += .25*noise( p ); p.xy *= m*2.23;\n    f += .125*noise( p ); p.yz *= m*2.71;\n    f += .0625*noise( p );\n\n    return f;\n}\n\n#define PI 3.14159265\n\nfloat modPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat opSlice (float dist, float thickness) {\n\treturn abs (dist) - thickness;\n}\n\nfloat cylinderd = .0;\n\nfloat map (vec3 p, inout vec3 pout, inout int id) {\n    p.xy *= r2d (12.*cos(iTime));\n    p.xz *= r2d (45.*iTime);\n\n    vec2 cell = vec2(2.5);\n    p.xz = mod (p.xz + .5*cell, cell) - .5*cell;\n\n\tvec3 boxCutterSize = vec3 (.7, .6, .7);\n\tvec3 tmp = abs (p - vec3(.0, 2.25 + .75*(.5+.5*cos(iTime)), .0)) - boxCutterSize;\n\tfloat boxCutter = length (max (vec3 (.0), tmp)) +\n\t\t\t\t\t\t\t  min (max (tmp.x, max (tmp.y, tmp.z)), .0);\n\tfloat ball = opSlice (length (p - vec3(.0, 1.6, .0)) - .5, .1);\n\tball = opSlice (ball, .05);\n\tball = opSlice (ball, .025);\n\tball = opSlice (ball, .0125);\n\tball = max (ball, -boxCutter);\n\n    float ground = p.y + 1.;\n    vec3 size = vec3 (.7, .1, .7);\n\tfloat plate = length (max (vec3 (.0), abs (p - vec3(.0, 1., .0)) - size)) - .025;\n\n    float cyl = sdCappedCylinder (p, vec2 (.5, 1.));\n    modPolar (p.xz, 9.);\n    float cut = sdVerticalCapsule (p - vec3 (.55, -1., .0), 1.6, .1);\n\n    float d = smin (cyl, -cut, -.02);\n\tcylinderd = d;\n    d = min (d, plate);\n    d = min (d, ground);\n    d = min (d, ball);\n\n\tif (d == cyl) id = 1;\n\tif (d == plate) id = 2;\n\tif (d == ground) id = 3;\n\tif (d == ball) id = 4;\n\n    pout = p;\n    return d;\n}\n\nfloat march (vec3 ro, vec3 rd, inout vec3 pout, inout int id) {\n    float t = .0;\n    float d = .0;\n    for (int i = 0; i < 48; ++i) {\n        t = map (ro+d*rd, pout, id);\n        if (abs (t) < .0001*(1. + .126*t)) break;\n        d += t*.95;\n    }\n    return  d;\n}\n\nvec3 norm (vec3 p) {\n    vec3 dummy;\n\tint dummy2;\n    float d = map (p, dummy, dummy2);\n    vec2 e = vec2 (.001, .0);\n    return normalize (vec3 (map (p + e.xyy, dummy, dummy2), map (p + e.yxy, dummy, dummy2), map (p + e.yyx, dummy, dummy2))  - d);\n}\n\n// hard shadows\nfloat sha (vec3 p, vec3 n, vec3 ldir, float ldist) {\n    vec3 dummy;\n    int dummy2;\n    float d2w = march (p  + .01*n, ldir, dummy, dummy2);\n    return ldist < d2w ? 1. : .3;\n}\n\nvec3 shade (vec3 ro, vec3 rd, float d, vec3 p, vec3 n, vec3 lp, vec3 lc, vec3 pout, int id) {\n    float v = fbm (30.*pout);\n    vec3 mat = mix (vec3 (.0), vec3 (1.), v);\n\tif (id == 4) mat = vec3 (1., .0, .0);\n    vec3 am = vec3 (.05);\n    vec3 ldir = normalize (lp - p);\n    vec3 h = normalize (-rd + ldir);\n\tif (id != 4) n = normalize (n + .125*vec3 (fbm (20.*pout), .0, fbm (10.*pout)));\n\tif (id == 3) {\n\t\tfloat m = smoothstep (.9, 1., fract (7.*cylinderd));\n\t\tmat = mix (vec3 (0.), vec3 (1.), m);\n\t}\n    float sp = pow (max (.0, dot (n, h)), 80.*v);\n    float ldist = distance (lp, p);\n    float s = sha (p, n, ldir, ldist);\n    float att = 3. / (ldist*ldist);\n    float li = 2.;\n    float diff = v*max (.0, dot (n, ldir));\n    return att*s*(am + diff*mat*li*lc + sp*vec3 (1.));\n}\n\nvec3 cam (vec2 uv, vec3 ro, vec3 aim, float z) {\n    vec3 f = normalize (aim - ro);\n    vec3 wu = vec3 (.0, 1., .0);\n    vec3 r = normalize (cross (wu, f));\n    vec3 u = normalize (cross (f, r));\n    vec3 c = ro + f*z;\n    return normalize (c + r*uv.x + u*uv.y - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvRaw = uv;\n    uv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 1. + .35*length (uv);\n\n    vec3 ro = vec3 (-.3, 2.75, 1.);\n    vec3 aim = vec3 (.0, 1.25, .0);\n    float z = 1.25;\n    vec3 rd = cam (uv, ro, aim, z);\n    vec3 pout;\n\tint id;\n    float d = march (ro, rd, pout, id);\n    float fog = 1. / (1. + d*d*.1);\n    vec3 p = ro+d*rd;\n    vec3 n = norm (p);\n    vec3 lp1 = vec3 (1.0, 3.0, 2.);\n    vec3 lp2 = vec3 (2.0, 2.5, 5.);\n    vec3 lp3 = vec3 (.1, 4.0, 7.);\n    vec3 lc1 = vec3 (.9, .8, .7);\n    vec3 lc2 = vec3 (.2, .3, .9);\n    vec3 lc3 = vec3 (.9, .3, .2);\n    vec3 col = shade (ro, rd, d, p, n, lp1, lc1, pout, id);\n    col += shade (ro, rd, d, p, n, lp2, lc2, pout, id);\n    col += shade (ro, rd, d, p, n, lp3, lc3, pout, id);\n\n    ro = p +.01*n;\n    rd = normalize (reflect (rd, n));\n    d = march (ro, rd, pout, id);\n    p = ro+d*rd;\n    n = norm (p);\n\n    vec3 rcol = shade (ro, rd, d, p, n, lp1, lc1, pout, id);\n    rcol += shade (ro, rd, d, p, n, lp2, lc2, pout, id);\n    rcol += shade (ro, rd, d, p, n, lp3, lc3, pout, id);\n    col += .25*rcol;\n\n    col *= fog;\n    col = col / (1. + col);\n    col *= 1. - .2*length (uv);\n    col = pow (col, vec3 (1./2.2));\n\n    fragColor = vec4 (col, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 25489,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/michaelschofield/jinny-keep-warm"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}