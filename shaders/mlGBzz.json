{
    "Shader": {
        "info": {
            "date": "1705315862",
            "description": "Obviously based on Toy Story's aliens.\nAnimated reproduction of this image:  https://oliphillips.tumblr.com/post/1690341150/minimalist-toy-story-poster \nIt seems to be made by Oliver Phillips.\nBy the way you can move the eyes using your mouse left click.",
            "flags": 0,
            "hasliked": 0,
            "id": "mlGBzz",
            "likes": 0,
            "name": "The clawwwwwwwww",
            "published": 3,
            "tags": [
                "animated",
                "alien",
                "movie",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "Saimon",
            "viewed": 119
        },
        "renderpass": [
            {
                "code": "/* \"Le grappiiiiiiin\"\n * I wanted to practice GLSL and the primitives describe in https://thebookofshaders.com/07/\n * so I started looking for art images to try to reproduce.\n * This one is part of my practice serie, it is based on this image: \n * https://oliphillips.tumblr.com/post/1690341150/minimalist-toy-story-poster\n * It seems to be made by Oliver Phillips.\n * (November 2023)(started with 2250 char - Updated 12/01/24)\n */\n\n// Clamp the color to make sure it's between [0;1]\n#define clampColor(C) clamp(C,0.,1.)\n#define R       iResolution.xy\n//https://www.shadertoy.com/view/XlsyWX\n#define rot(a)  mat2(cos(a+vec4(0,33,11,0)))\n\nvec3 ellipse(vec2 uv, vec2 radius){\n    // Calculate the distance from the fragment to the center of the ellipse\n    // here we assume center is vec2(0.) wichi simplify the calcul\n    // vec2 dist = (uv - center) / radius;\n    // The translation is done outside the function\n    vec2 dist = uv / radius;\n    float distanceSquared = dot(dist, dist);\n    return (distanceSquared <= 1.0)? vec3(0.): vec3(1.);\n}\n\nfloat sdCircle(vec2 p, float r){\n  float w = .8/R.y;\n  return smoothstep(-w,w, length(p) - r);\n}\n\n// Source of code: https://easings.net/\nfloat easeOutExpo(float t) {\n  return 1. - exp2(-10. * t);\n}\n\n#define tweenEOE(t) easeOutExpo(min(t, 1. -t)/0.5)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 st = ( fragCoord.xy*2. -R.xy ) /R.y,\n       mouse = ( iMouse.xy*2. -R.xy ) /R.y ;\n  \n  // Increase the size by 2.\n  st /= 2.;\n  mouse/=2.;\n\n  // Define the size and radius of the eye\n  float t = fract((-iTime)/3.),\n        size = 0.380;\n  vec2 radius = vec2(0.3, -tweenEOE(t)*(0.135)-abs(sin(4.*t))*0.04)*size;\n  \n  // Side pupil info\n  vec2 pos = vec2(0.195,(0.2955));\n  float angle = 0.196;\n\n  vec2 eye1 = vec2(-pos.x, pos.y), // Left eye\n       eye2 = vec2(0.0,(0.288)), // Center eye\n       eye3 = vec2(pos.x, pos.y - 0.0075); //Right eye; correct a small offset\n                                           //\n  vec3 pupilsColor = ellipse(rot(angle) * st - eye1, radius)\n                     * ellipse(st - eye2, radius)\n                     * ellipse(rot(-angle) * st - eye3, radius);\n\n  vec3 GREEN = vec3(0.725,0.749,0.122);\n  vec3 color = mix(pupilsColor + vec3(1.), GREEN, pupilsColor);\n  // (mouse - eye) represent the distance between each eye and the mouse\n  fragColor.rgb = mix(\n                    sdCircle(rot(angle)*st - eye1 - (mouse - eye1)/20., 0.028)\n                      * sdCircle(st - eye2 - (mouse - eye2)/20., 0.028)\n                      * sdCircle(rot(-angle)*st - eye3 - (mouse - eye3)/20., 0.028)\n                      + vec3(0.),\n                    color,\n                    pupilsColor\n                  );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}