{
    "Shader": {
        "info": {
            "date": "1591201965",
            "description": "A simple raytracer demo based on Inigo Quilez' youtube tutorial https://www.youtube.com/watch?v=9g8CdctxmeU.",
            "flags": 0,
            "hasliked": 0,
            "id": "tsjfDt",
            "likes": 3,
            "name": "A simple raytracer ",
            "published": 3,
            "tags": [
                "raytracing",
                "blinnphongmodel"
            ],
            "usePreview": 0,
            "username": "chen1180",
            "viewed": 316
        },
        "renderpass": [
            {
                "code": "// Global setting for raytracing\n#define BlinnPhongShading true \n#define Samples 5\n#define MaxDepth 5\n#define T_MIN 0.0001\n#define T_MAX 1000.0\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\nfloat g_seed = 0.0;\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n//\n// Ray trace helper functions\n//\n\nvec3 random_cos_weighted_hemisphere_direction( const vec3 n, inout float seed ) {\n  \tvec2 r = hash2(seed);\n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    return normalize(rr);\n}\n#define LAMBERTIAN 0\n#define METAL 1\n#define DIELETRIC 2\nstruct Material{\n\tint matType;\n    vec3 albedo;\n    float ior;\n};\nstruct Sphere{\n\tvec3 center;\n    float radius;\n    Material material;\n};\n struct Plane{\n\tvec3 p;\n    vec3 normal;\n    Material material;\n};\nSphere sceneList[] =Sphere[](Sphere(vec3(1.0,0.0,-3.0),0.5,Material(METAL,vec3(0.8,0.8,0.8),0.0)),\n    Sphere(vec3(1.5,0.0,-1.0),0.5,Material(DIELETRIC,vec3(0.5,.5,.5),1.3)),\n    Sphere(vec3(-0.5,0.0,-2.0),0.5,Material(LAMBERTIAN,vec3(0.1,1.0,0.1),0.0)),\nSphere(vec3(-1.0,0.0,0.0),0.5,Material(METAL,vec3(0.2,0.2,0.8),0.0)));\nPlane p=Plane(vec3(0,0.5,0.0),vec3(0.0,1.0,0.0),Material(LAMBERTIAN,vec3(0.5,0.5,0.5),0.0));\n\nstruct HitRecord{\n    //Type 1: sphere\n    //Type 2: plane\n    int type; \n    bool isHit;\n    vec3 p;\n    vec3 normal;\n    Material material;\n    \n};\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n    };\nfloat intersectSphere(Ray r,Sphere s){\n    vec3 oc=r.origin-s.center;\n    vec3 t=r.direction;\n\tfloat a=dot(t,t);\n    float b=2.0*dot(t,oc);\n    float c=dot(oc,oc)-s.radius*s.radius;\n    float discriminant=b*b-4.0*a*c;\n    if (discriminant<=0.0)\n        return -1.0;\n    else\n    {\n    \tfloat x1=(-b-sqrt(discriminant))/(2.0*a);\n        if(x1>T_MIN&&x1<T_MAX)\n        \treturn x1;\n        x1=(-b+sqrt(discriminant))/(2.0*a);\n         if(x1>T_MIN&&x1<T_MAX)\n        \treturn x1;\n    }\n}\nvec3 getSphereNormal(vec3 hitPoint,Sphere s){\n\treturn normalize(hitPoint-s.center);\n}\nfloat intersectPlane(Ray r,Plane s){\n\tvec3 op=r.origin-s.p;\n    float d=dot(op,s.normal)/dot(r.direction,s.normal);\n    return d;\n\n}\n\nvec3 getPlaneNormal(vec3 hitPoint,Plane p){\n\treturn normalize(hitPoint+p.normal);\n}\n\nvec3 skyColor(float t){\n    return (1.0-t)*vec3(1.0)+t*vec3(0.2,0.5,0.7);\n\t\n}\n\n\nHitRecord intersectScene(Ray r){\n    float tMax=T_MAX;\n    float tMin=T_MIN;\n    HitRecord hit_record;\n    hit_record.isHit=false;\n    for (int i=0;i<sceneList.length();i++)\n    {\n    \tfloat ts=intersectSphere(r, sceneList[i]);\n   \t\t if (ts>tMin && ts<tMax){\n            tMax=ts;\n            hit_record.type=1;\n             hit_record.p=r.origin+r.direction*ts;\n             vec3 normal=getSphereNormal(hit_record.p,sceneList[i]);\n            hit_record.normal=getSphereNormal(hit_record.p,sceneList[i]);\n             hit_record.material=sceneList[i].material;\n             hit_record.isHit=true;\n         }\n        \n    }\n     float tp=intersectPlane( r,p);\n\t if (tp>tMin&&tp<tMax){\n        tMax=tp;\n          hit_record.type=2;\n         hit_record.p=r.origin+r.direction*tp;\n        hit_record.normal=getPlaneNormal(hit_record.p,p);\n          hit_record.material=p.material;\n          hit_record.isHit=true;\n     }\n    return hit_record;\n\n}\n//BlinnPhong model\nvec3 blinnPhong(HitRecord hit_record,vec3 rayDir,vec2 uv){\n  \tvec3 col=vec3(1.0);\n    vec3 lightPos=vec3(1.0,1.0,-3.0);\n    vec3 lightDir=normalize(lightPos-hit_record.p);\n    if (hit_record.type==1){\n        float diff=clamp(dot(hit_record.normal,lightDir),0.0,1.0);\n        float ambient=0.4;\n        vec3 reflectDir=reflect(lightDir,hit_record.normal);\n        vec3 bisector=(reflectDir+rayDir)*0.5;\n        float specular=pow(max(dot(reflectDir,bisector),0.0),16.0);\n        col=(diff*ambient+ambient+specular)*hit_record.material.albedo;\n        \n    }else if (hit_record.type==2){\n        float diff=clamp(dot(hit_record.normal,lightDir),0.0,1.0);\n        float ambient=0.0;\n        for (int i=0;i<sceneList.length();i++)\n        {\n             ambient+= smoothstep(0.0,sceneList[i].radius,length(hit_record.p.xz-sceneList[i].center.xz));\n        }\n        col=vec3(0.2*ambient);\n        \n    }else\n        col=skyColor(uv.y);\n    return col;\n}\nfloat schlick(float cos_theta, float n2)\n{\n    const float n1 = 1.0f;  // refraction index for air\n\n    float r0s = (n1 - n2) / (n1 + n2);\n    float r0 = r0s * r0s;\n\n    return r0 + (1.0f - r0) * pow((1.0f - cos_theta), 5.0f);\n}\nbool refractVec(vec3 v, vec3 n, float ni_over_nt, out vec3 refracted)\n{\n    vec3 uv = normalize(v);\n\n    float dt = dot(uv, n);\n\n    float discriminant = 1.0 - ni_over_nt * ni_over_nt * (1.0f - dt * dt);\n\n    if (discriminant > 0.0f)\n    {\n        refracted = ni_over_nt*(uv - n * dt) - n * sqrt(discriminant);\n\n        return true;\n    }\n    else\n        return false;\n}\nbool material_bsdf(HitRecord hit_record,Ray inRay, out Ray outRay,out vec3 attenuation){\n    vec3 col=vec3(0.0);\n    //lambertian\n    if(hit_record.material.matType==LAMBERTIAN){\n        vec3 ray_origin=hit_record.p;\n        vec3 ray_dir=random_cos_weighted_hemisphere_direction(hit_record.normal,g_seed);\n        outRay=Ray(ray_origin,ray_dir);\n        attenuation=hit_record.material.albedo;\n        return true;\n    }else if(hit_record.material.matType==METAL){\n     //metal\n        vec3 reflected=reflect(inRay.direction,hit_record.normal);\n        outRay=Ray(hit_record.p,reflected);\n        attenuation=hit_record.material.albedo;\n         return true;\n    }else if(hit_record.material.matType==DIELETRIC){\n     //dieletric\n        vec3 outward_normal,refracted;\n        float ni_over_nt,cosine,reflect_prob;\n        vec3 reflected=reflect(inRay.direction,hit_record.normal);\n        if (dot(inRay.direction,hit_record.normal)>0.0){\n        \toutward_normal=-hit_record.normal;\n            ni_over_nt=hit_record.material.ior;\n            cosine=dot(inRay.direction,hit_record.normal)/length(inRay.direction);\n            cosine=sqrt(1.0-ni_over_nt*ni_over_nt*(1.0-cosine*cosine));\n            \n        }else{\n            outward_normal=hit_record.normal;\n        \tni_over_nt = 1.0f / hit_record.material.ior;\n            cosine=-dot(inRay.direction,hit_record.normal)/length(inRay.direction);\n        }\n        if (refractVec(inRay.direction, outward_normal, ni_over_nt, refracted))\n            reflect_prob = schlick(cosine, hit_record.material.ior);\n        else\n            reflect_prob = 1.0f;\n  \n        if (hash1(g_seed)<reflect_prob)\n        {\n        \toutRay=Ray(hit_record.p,reflected);\n\n        } \t\n        else\n        {\n\n            outRay=Ray(hit_record.p,refracted);\n        }\n        attenuation=hit_record.material.albedo;\n        return true;\n\n        \n    }\n    return false;\n\n}\n\nvec3 radiance(Ray r,vec2 uv){\n  \tvec3 col=vec3(1.0);\n    HitRecord hit_record;\n    for(int bounce=0;bounce<MaxDepth;bounce++)\n    {\n        hit_record=intersectScene(r);\n\n        if (hit_record.isHit)\n        {\n\t\t\t\n            Ray outRay;\n            vec3 color;\n            bool scattered=material_bsdf(hit_record,r,outRay,color);\n            r.origin=outRay.origin;\n            r.direction=outRay.direction;\n            if (scattered)\n            {\n                col*=color;\n            }\n            \n            else\n            {\n            \tcol*=vec3(0.0);\n                break;\n            }\n               \n  \n        }else\n        {\n            col*=skyColor(uv.y);\n        \tbreak;\n        }\n        \n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    g_seed = float(base_hash(floatBitsToUint(fragCoord.xy)))/float(0xffffffffU)+iTime;\n    //camera ray calculation\n    vec3 cameraPos=vec3(5.0*cos(iTime),0,5.0*sin(iTime));\n    vec3 cameraLookAt=vec3(0.0,0.0,-1.0);\n    float ratio=iResolution.x/iResolution.y;\n    vec3 t=normalize(cameraLookAt-cameraPos);\n    vec3 up=vec3(0.0,1.0,0.0);\n    vec3 h=normalize(cross(t,up));\n    vec3 v=normalize(cross(h,t));\n\n    vec3 leftBotCorner=cameraPos+t-ratio*1.0/2.0*h-1.0/2.0*v;\n    vec3 rayDir=leftBotCorner+ratio*uv.x*h+uv.y*v-cameraPos;\n    Ray r=Ray(cameraPos,rayDir);\n    //sphere move\n    for (int i=0;i<sceneList.length();i++)\n    {\n         if ( sceneList[i].material.matType==METAL)\n             continue;\n         //sceneList[i].center.x+=sin(iTime);\n         //sceneList[i].center.z+=cos(iTime);\n    }\n    //shading\n    if (BlinnPhongShading){\n        vec3 col=vec3(0.0);\n    \tHitRecord rec=intersectScene(r);\n    \tcol=blinnPhong(rec,rayDir,uv);\n         // Output to screen\n    \tfragColor = vec4(col,1.0);\n    }\n    else{\n        vec3 col=vec3(0.0);\n        for(int i=0;i<Samples;i++){\n            float x=(fragCoord.x+ hash1(g_seed))/iResolution.x;\n            float y=(fragCoord.y+ hash1(g_seed))/iResolution.y;\n            col+=radiance(r,vec2(x,y));\n        }\n        col/=float(Samples);\n        // Output to screen\n    \tfragColor = vec4(pow(col,vec3(1.0/2.2)),1.0);\n       \t\n\n    } \n    \n   \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}