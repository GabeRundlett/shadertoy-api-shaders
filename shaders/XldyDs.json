{
    "Shader": {
        "info": {
            "date": "1534689035",
            "description": "Maps your face from a webcam image onto a sphere. Displaces the sphere surface to create an indent based on the shape of your face in the image.",
            "flags": 2,
            "hasliked": 0,
            "id": "XldyDs",
            "likes": 12,
            "name": "Face Mapping",
            "published": 3,
            "tags": [
                "raymarching",
                "uv",
                "sphere",
                "mapping",
                "webcam",
                "face"
            ],
            "usePreview": 0,
            "username": "jackdavenport",
            "viewed": 1445
        },
        "renderpass": [
            {
                "code": "#define MAX_ITER 256\n#define MAX_DIST 100.\n#define MIN_DIST .01\n\nfloat luma(vec3 v) {\n    return .2126*v.x + .7152*v.y + .0722*v.z;\n}\n\nfloat dstFace(vec3 p, float r) {\n    float d = length(p)-r;\n    \n    vec2 uv = acos(p.xy)/3.14159;\n    d -= luma(texture(iChannel0, vec2(uv.x,1.-uv.y)).xyz) * .2;\n    \n    return d;\n}\n\nfloat dstScene(vec3 p) {\n    return min(dstFace(p, 1.), p.y + 1.);\n}\n\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.;\n    for(int i = 0; i < MAX_ITER; i++) {\n        float d = dstScene(ro+rd*t);\n        if(d < MIN_DIST || t > MAX_DIST) {\n            break;\n        }\n        t += d * .75;\n    }\n    return t;\n}\n\nvec3 calcNormal(vec3 p, float t) {\n    vec2 e = vec2(MIN_DIST*t,0.);\n    vec3 n = vec3(dstScene(p+e.xyy)-dstScene(p-e.xyy),\n                  dstScene(p+e.yxy)-dstScene(p-e.yxy),\n                  dstScene(p+e.yyx)-dstScene(p-e.yyx));\n    return normalize(n);\n}\n\nvec3 pixel(vec3 ro, vec3 rd) {\n    float t = raymarch(ro, rd);\n    if(t < MAX_DIST) {\n        vec3 p = ro+rd*t;\n        vec3 n = calcNormal(p,t);\n        vec3 r = normalize(reflect(rd,n));\n        \n        vec3  l = normalize(vec3(45.,30.,-45.));\n        float d = max(dot(l,n),.2);\n        float s = pow(max(dot(l,r),0.),45.);\n        \n        float a = 1.;\n        if(raymarch(p+l*.05,l) < MAX_DIST) {\n            a = 0.;\n        }\n        d *= a; s *= a;\n        \n        vec3 albedo = vec3(0.,1.,0.);\n        if(p.y > -.9) {\n        \tvec2 uv = acos(p.xy)/3.14159;\n        \talbedo = texture(iChannel0,vec2(uv.x,1.-uv.y)).xyz;\n        }\n        return albedo*d+s;\n    }\n    return vec3(pow(max(dot(rd,vec3(0.,0.,1.)),0.),5.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 ro = vec3(0., 0., -3.);\n    vec3 rd = vec3(uv, 1.);\n    \n    vec2 nuv = fragCoord/iResolution.xy;\n    if(nuv.x < .2 && nuv.y < .2) {\n        nuv /= .2;\n        fragColor = texture(iChannel0, nuv);\n        if(nuv.x < .3 || nuv.x > .7) {\n         \tfragColor.xyz *= vec3(.5,.2,.2);   \n        }\n    } else {\n    \tfragColor = vec4(pixel(ro, normalize(rd)), 1.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}