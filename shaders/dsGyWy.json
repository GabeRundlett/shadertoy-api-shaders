{
    "Shader": {
        "info": {
            "date": "1696538779",
            "description": "Visualisation of the relative solid angle of texels from a cubemap. The reference is shown on the left, and an approximation is proposed on the right. The error between the reference and the approximation is shown as well.",
            "flags": 0,
            "hasliked": 0,
            "id": "dsGyWy",
            "likes": 4,
            "name": "Cubemap texel solid angle",
            "published": 3,
            "tags": [
                "cubemap",
                "solidangle"
            ],
            "usePreview": 0,
            "username": "Zavie",
            "viewed": 176
        },
        "renderpass": [
            {
                "code": "/*\n\nThis shader visualises the relative solid angle of the texels\nof the face of a cubemap (compared to the center texel).\n\nA very simple approximation is proposed. The approximation is\ntoo crude for very low resolutions, but beyond 8x8 it seems\nto result in under 1% error.\n\nMaybe a fitting or offset could correct the error for the\nvery low resolutions as well?\n\n\nTop center: texels of the cubemap face.\nBottom left: relative solid angle of the texels.\nBottom right: approximation of the relative solid angle.\nCenter: (200x exaggerated) error of the approximation.\n\nThe bottom histogram shows the error accross the diagonal, on\na squeezed scale. The short dashed graduations indicate the\n0.125%, 0.25%, 0.5%, 1% and 2% error. The longer dashed\ngraduations indicate the 10%, 20%, 40% and 80% error.\n\nLicense: CC BY 4.0\n\n-- \nZavie\n*/\n\nfloat approximateRelativeSolidAngle(vec2 uv, float resolution)\n{\n    vec2 p = uv * 2. - 1.;\n\n#if 0\n    // Verbose version:\n\n    // The more off-center the texel, the further the distance.\n    // So we scale by the inverse square distance.\n    float invSqrDist = 1. / (dot(p, p) + 1.);\n\n    // The more off-center the texel, the more it's facing away.\n    // So we scale by the cosine.\n    float cos_factor = 1. / sqrt(dot(p, p) + 1.);\n\n    // Combine the two factors:\n    return invSqrDist * cos_factor;\n#else\n    // Short version:\n\n    // After derivation, the whole thing becomes just\n    float sqrDist = dot(p, p) + 1.;\n    return 1. / sqrt(sqrDist * sqrDist * sqrDist);\n#endif\n}\n\n//\n// areaElement and texelSolidAngle are adapted from\n// AMD cubemapgen source code:\n// https://code.google.com/archive/p/cubemapgen/\n//\n// See the derivation here:\n// https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\n//\nfloat areaElement(float x, float y)\n{\n    return atan(x * y, sqrt(x * x + y * y + 1.));\n}\n\nfloat texelSolidAngle(vec2 uv, float resolution)\n{\n    vec2 p = uv * 2. - 1.;\n\n    float invResolution = 1. / resolution;\n \n    // p is the -1..1 texture coordinate on the current face.\n    // Get projected area for this texel\n    vec2 pmin = p - invResolution;\n    vec2 pmax = p + invResolution;\n    float solidAngle = (\n        areaElement(pmin.x, pmin.y) -\n        areaElement(pmin.x, pmax.y) -\n        areaElement(pmax.x, pmin.y) +\n        areaElement(pmax.x, pmax.y));\n \n    return solidAngle;\n}\n\nfloat exactRelativeSolidAngle(vec2 uv, float resolution)\n{\n    return texelSolidAngle(uv, resolution) / texelSolidAngle(vec2(0.5), resolution);\n}\n\n// ----------------------------------------------------------\n\nvec2 remap(vec2 a, vec2 b, vec2 u)\n{\n    return (u - a) / (b - a);\n}\n\nvec2 getMask(vec2 uv)\n{\n    vec2 du = 2.*vec2(dFdx(uv.x), dFdy(uv.y));\n    return smoothstep(vec2(0.), du, uv) * (1. - smoothstep(vec2(1.) - du, vec2(1.), uv));\n}\n\nvec2 getRectangle(vec2 uv, float x, float y, float width, float height)\n{\n    vec2 p = vec2(x, y);\n    vec2 size = vec2(width, height);\n    return remap(p - size/2., p + size/2., uv);\n}\n\nvec2 getSquare(vec2 uv, float x, float y, float size)\n{\n    vec2 p = vec2(x, y);\n    return remap(p - size/2., p + size/2., uv);\n}\n\nvec2 discretise(vec2 uv, float resolution)\n{\n    return (floor(uv * resolution) + 0.5) / resolution;\n}\n\nvec3 errorToColor(float error)\n{\n    // Colours picked from:\n    // https://www.kennethmoreland.com/color-advice/\n    // The publication explains how to properly interpolate,\n    // but I was too lazy to implement it.\n    vec3 midPoint = vec3(0.865, 0.865, 0.865);\n    vec3 positive = vec3(0.230, 0.299, 0.754);\n    vec3 negative = vec3(0.706, 0.016, 0.150);\n\n    if (error > 0.)\n    {\n        if (error <= 1.)\n            return mix(midPoint, positive, error);\n        // Saturate to blue above 1:\n        return vec3(0., 0., 1.);\n    }\n    else\n    {\n        if (error >= -1.)\n            return mix(midPoint, negative, -error);\n        // Saturate to red below -1:\n        return vec3(1., 0., 0.);\n    }\n}\n\nfloat logScale(float x)\n{\n    float scale = 9.;\n    return (exp(scale * x) - 1.) / (exp(scale) - 1.);\n}\n\nvec4 errorHistogram(vec2 uvPlot, vec2 uvFace, float error)\n{\n    float x = uvPlot.x;\n    float dx = dFdy(x);\n    float y = logScale(uvPlot.y);\n    float dy = dFdy(y);\n    vec4 color = vec4(errorToColor(0.), 0.1);\n    if (error > 0.)\n    {\n        float e = (error);\n        color = mix(color, vec4(errorToColor(200. * error), 1.), smoothstep(y, y + dy, e));\n    }\n    else if (error < 0.)\n    {\n        float e = (-error);\n        color = mix(color, vec4(errorToColor(200. * -error), 1.), smoothstep(y, y + dy, e));\n    }\n\n    // Draw graduations at 0.125%, 0.25%, 0.5%, 1% and 2%\n    for (float graduation = 0.00125; graduation <= 0.02; graduation *= 2.)\n    {\n        float line = smoothstep(y - dy, y, graduation) * (1. - smoothstep(y, y + dy, graduation));\n        float dotted = fract(100. * x);\n        float dottedLine = line * smoothstep(0., dx, dotted) * (1. - smoothstep(0.75, 0.75 + dx, dotted));\n        color = mix(color, vec4(1. - color.rgb, 1.), 0.5*dottedLine);\n    }\n\n    // Draw graduations at 10%, 20%, 40% and 80%\n    for (float graduation = 0.1; graduation < 1.0; graduation *= 2.0)\n    {\n        float line = smoothstep(y - dy, y, graduation) * (1. - smoothstep(y, y + dy, graduation));\n        float dotted = fract(25. * x);\n        float dottedLine = line * smoothstep(0., dx, dotted) * (1. - smoothstep(0.85, 0.85 + dx, dotted));\n        color = mix(color, vec4(1. - color.rgb, 1.), 0.5*dottedLine);\n    }\n\n    return color;\n}\n\n// ----------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float evolution = abs(fract(iTime * 0.05) * 2. - 1.);\n    float cubeMapResolution = pow(2., 1. + floor(evolution * 10.));\n\n    vec2 uv = fragCoord/iResolution.x;\n    vec3 color = vec3(0.2);\n\n    // Visualise the texels depending on the cubemap resolution\n    {\n        vec2 uvFace = getSquare(uv, 0.5, 0.45, 0.22);\n        vec2 mask = getMask(uvFace);\n        uvFace = discretise(uvFace, cubeMapResolution);\n\n        vec3 texels = vec3(uvFace, 0.);\n        color = mix(color, texels, mask.x * mask.y);\n    }\n\n    // Visualise the texel relative solid angle\n    {\n        vec2 uvFace = getSquare(uv, 0.2, 0.32, 0.35);\n        vec2 mask = getMask(uvFace);\n        uvFace = discretise(uvFace, cubeMapResolution);\n\n        float ersa = exactRelativeSolidAngle(uvFace, cubeMapResolution);\n        color = mix(color, vec3(ersa), mask.x * mask.y);\n    }\n\n    // Visualise the approximated texel relative solid angle\n    {\n        vec2 uvFace = getSquare(uv, 1. - 0.2, 0.32, 0.35);\n        vec2 mask = getMask(uvFace);\n        uvFace = discretise(uvFace, cubeMapResolution);\n\n        float arsa = approximateRelativeSolidAngle(uvFace, cubeMapResolution);\n        color = mix(color, vec3(arsa), mask.x * mask.y);\n    }\n\n    // Visualise the difference between the texel relative\n    // solid angle and the approximation\n    {\n        vec2 uvFace = getSquare(uv, 0.5, 0.22, 0.22);\n        vec2 mask = getMask(uvFace);\n        uvFace = discretise(uvFace, cubeMapResolution);\n\n        float arsa2 = approximateRelativeSolidAngle(uvFace, cubeMapResolution);\n        float ersa2 = exactRelativeSolidAngle(uvFace, cubeMapResolution);\n        float error = ersa2 - arsa2;\n        color = mix(color, errorToColor(200. * error), mask.x * mask.y);\n    }\n    \n    // Visualise more precisely the error across the diagonal\n    {\n        vec2 uvPlot = getRectangle(uv, 0.5, 0.05, 1., 0.1);\n        vec2 mask5 = getMask(uvPlot);\n        vec2 uvFace = vec2(uvPlot.x);\n        uvFace = discretise(uvFace, cubeMapResolution);\n\n        float arsa2 = approximateRelativeSolidAngle(uvFace, cubeMapResolution);\n        float ersa2 = exactRelativeSolidAngle(uvFace, cubeMapResolution);\n        float error = ersa2 - arsa2;\n\n        vec4 histogram = errorHistogram(uvPlot, uvFace, error);\n        color = mix(color, histogram.rgb, mask5.x * mask5.y * histogram.a);\n    }\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}