{
    "Shader": {
        "info": {
            "date": "1657666959",
            "description": "Visualization of Spherical Harmonics for illustrative purposes",
            "flags": 32,
            "hasliked": 0,
            "id": "7sKfzR",
            "likes": 1,
            "name": "Spherical Harmonic Irradiance",
            "published": 3,
            "tags": [
                "visualization",
                "spherical",
                "harmonics"
            ],
            "usePreview": 0,
            "username": "BeardThings",
            "viewed": 388
        },
        "renderpass": [
            {
                "code": "\n#define DISTANCE 7.0\n#define VIEW_IRRADIANCE_CURVE\n//#define VIEW_THETA\n#define VIEW_PHI\n\nconst int VIEW_SH = 0;\nconst int VIEW_IRRADIANCE = 1;\n\nconst int view = VIEW_SH;\n\nvec3 irradiance(vec3 n)\n{\n    float theta = acos(n.y);\n    float phi = atan(n.z,n.x);\n    phi = phi < 0.0 ? 2.0*PI + phi : phi;\n    return texture(iChannel1,vec2(phi/(2.0*PI), theta/PI)).rgb;\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nvec4 sh_cosine_projected(vec3 d)\n{\n    vec4 coefs = vec4(\n        0.88622692545,\n        -1.02332670795,\n        1.02332670795,\n        -1.02332670795);\n   return vec4(1.0,d.zyx) * coefs;\n}\n\nfloat SDF(vec3 p, out vec3 c)\n{\n    vec3 d = normalize(p);\n    vec3 r = irradiance(d);\n    \n    vec4 sh = texelFetch(iChannel2, ivec2(0,0), 0);\n    float shR = dot(sh_cosine_projected(d),sh);\n    \n    float radius = 0.0;\n    if(view == VIEW_IRRADIANCE)\n    {\n        radius = r.r;\n    }\n    else if(view == VIEW_SH)\n    {\n        radius = shR;\n    }\n\n    c = vec3(1.0,1.0,1.0) * radius/PI;\n    return sphere(p, radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 screenSpace = uv * 2.0 - 1.0;\n\t\n    float time = iTime * 0.25;\n    vec3 o = vec3(sin(time), 0.0, cos(time)) * DISTANCE;\n    \n    vec3 f = normalize(-o);\n    vec3 u = vec3(0,1,0);\n    vec3 r = normalize(cross(f, u));\n    \n    vec3 direction = normalize(f * 2.0 + \n                         r * screenSpace.x * iResolution.x / iResolution.y +\n                         u * screenSpace.y);\n\n    fragColor = texture(iChannel0,direction);\n    \n    float d = 0.0;\n    for(float i = 0.; i < 64.; ++i)\n    {\n        vec3 pos = o + direction * d;\n\n        vec3 c;\n        float sdf = SDF(pos, c);\n        d += sdf*0.4;\n        \n        const float EPSILON = 0.01;\n        if(sdf < EPSILON)\n        {   \n            fragColor.rgb = c;\n            break;\n        }\n    }\n    \n#ifdef VIEW_IRRADIANCE_CURVE\n    {\n#ifdef VIEW_PHI\n        vec3 li = texture(iChannel1,vec2(uv.x,iMouse.x/iResolution.x)).rgb/PI;\n#elif defined(VIEW_THETA)\n        vec3 li = texture(iChannel1,vec2(iMouse.x/iResolution.x,uv.x)).rgb/PI;\n#endif\n        float r = clamp(1.0-abs(li.r - uv.y)*(iResolution.y/3.0),0.0,1.0);\n        float g = clamp(1.0-abs(li.g - uv.y)*(iResolution.y/3.0),0.0,1.0);\n        float b = clamp(1.0-abs(li.b - uv.y)*(iResolution.y/3.0),0.0,1.0);\n        fragColor.rgb = vec3(r,g,b)+fragColor.rgb*0.75;\n    }\n#endif // VIEW_IRRADIANCE_CURVE\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Irradiance calculation\n\nconst float golden = (1.0 + sqrt(5.0))/2.0;\nfloat N = 256.0 * 32.0;\n// Progressively refine our integration\nfloat NPerFrame = 64.0;\n\n// http://extremelearning.com.au/how-to-evenly-distribute-points-on-a-sphere-more-effectively-than-the-canonical-fibonacci-lattice/\nvec3 hemisphere_fibonacci(float i)\n{\n\tvec2 uv = vec2(fract(i/golden),i/N);\n    vec2 s = vec2(2.0*PI*uv.x,acos(1.0-uv.y));\n\n\treturn vec3(cos(s.x)*sin(s.y), cos(s.y), sin(s.x)*sin(s.y));\n}\n\nvec3 irradiance(vec3 n, float prevN)\n{\n    vec3 r = n.x < 0.99999 ? vec3(1.0,0.0,0.0) : vec3(0.0,-1.0,0.0);\n    vec3 f = normalize(cross(n,r));\n    r = normalize(cross(f,n));\n    vec3 u = n;\n    \n    vec3 ir = vec3(0.0,0.0,0.0);\n    \n    for(float n = prevN; n < prevN + NPerFrame; n += 1.0)\n    {\n        vec3 d = hemisphere_fibonacci(n);\n        vec3 rd = normalize(d.x * r + d.y * u + d.z * f);\n        ir += srgb_to_linear(texture(iChannel0, rd).rgb) * d.y;\n    }\n    ir *= 2.0 * PI;\n    \n    return ir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 s = vec2(uv.x * 2.0 * PI, uv.y * PI);\n\n    vec3 n = vec3(cos(s.x)*sin(s.y),cos(s.y),sin(s.x)*sin(s.y));\n\n    vec4 prev = texelFetch(iChannel1, ivec2(fragCoord), 0);\n\n    if(prev.a < N)\n    {\n        float newN = prev.a + NPerFrame;\n        vec3 prevIrradiance = prev.rgb * prev.a;\n        fragColor.rgb = (prevIrradiance + irradiance(n, prev.a)) / newN;\n        fragColor.a = newN;\n    }\n    else\n    {\n        fragColor = prev;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define PI 3.1415926\nint factorial(int v)\n{\n    int t = 1;\n    for(int i = 2; i < v; i++)\n    {\n        t *= i;\n    }\n    return t;\n}\n\n// Adapted from https://patapom.com/blog/SHPortal/\n// \"Evaluate an Associated Legendre Polynomial P(l,m,x) at x\n// For more, see “Numerical Methods in C: The Art of Scientific Computing”, Cambridge University Press, 1992, pp 252-254\" \nfloat P(int l, int m, float x )\n{\n    float pmm = 1.0;\n    \n    float somx2 = sqrt((1.0-x)*(1.0+x));\n    float fact = 1.0;\n    for ( int i=1; i<=m; i++ ) {\n        pmm *= (-fact) * somx2;\n        fact += 2.0;\n    }\n    \n    if( l == m )\n        return pmm;\n\n    float pmmp1 = x * (2.0*float(m)+1.0) * pmm;\n    if ( l == m+1 )\n        return pmmp1;\n\n    float pll = 0.0;\n    for ( float ll=float(m+2); ll<=float(l); ll+=1.0 ) {\n        pll = ( (2.0*ll-1.0)*x*pmmp1-(ll+float(m)-1.0)*pmm ) / (ll-float(m));\n        pmm = pmmp1;\n        pmmp1 = pll;\n    }\n\n    return pll;\n}\n\n\nfloat K(int l, int m)\n{\n    float n = float((2*l+1)*factorial(l - m));\n    float d = 4.0 * PI * float(factorial(l + m));\n    return sqrt(n/d);\n}\n\nfloat y(int l, int m, float cosTheta, float phi)\n{\n    float v = K(l, abs(m)) * P(l, abs(m), cosTheta);\n    if(m != 0)\n        v *= sqrt(2.0);\n    \n    if(m > 0)\n        v *= cos(float(m)*phi);\n    if(m < 0)\n        v *= sin(float(-m)*phi);\n    \n    return v;\n}\n\nvec3 srgb_to_linear(vec3 srgb)\n{\n    return pow(srgb, vec3(2.2));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame<=10)\n    {\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        vec2 s = vec2(uv.x * 2.0 * PI, uv.y * PI);\n\n        vec3 n = vec3(cos(s.x)*sin(s.y),cos(s.y),sin(s.x)*sin(s.y));\n\n        float phiSlice = 2.0 * PI / iResolution.x;\n        float thetaSlice = PI / iResolution.y;\n        float w = phiSlice * thetaSlice * sin(s.y);\n\n        vec3 t = srgb_to_linear(texture(iChannel0,n).rgb);\n        float l0m0 = t.r * y(0,  0, cos(s.y), s.x) * w;\n        float l1m0 = t.r * y(1, -1, cos(s.y), s.x) * w;\n        float l1m1 = t.r * y(1,  0, cos(s.y), s.x) * w;\n        float l1m2 = t.r * y(1,  1, cos(s.y), s.x) * w;\n\n        fragColor = vec4(l0m0, l1m0, l1m1, l1m2);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame <= 10)\n    {\n        vec4 l1 = vec4(0.0,0.0,0.0,0.0);\n        if(int(fragCoord.x)==0 && int(fragCoord.y)==0)\n        {\n            for(int y = 0; y < int(iResolution.y); y++)\n            {\n                for(int x = 0; x < int(iResolution.x); x++)\n                {\n                    l1 += texelFetch(iChannel0, ivec2(x,y), 0);\n                }\n            }\n        }\n        fragColor = l1;\n    }\n    else\n    {\n        fragColor = texelFetch(iChannel1, ivec2(0.0,0.0), 0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}