{
    "Shader": {
        "info": {
            "date": "1611461582",
            "description": "My one-week artwork! An underwater scene.",
            "flags": 0,
            "hasliked": 0,
            "id": "WtKczc",
            "likes": 20,
            "name": "Fork Underwater leecorn 572",
            "published": 3,
            "tags": [
                "waves",
                "light",
                "underwater",
                "bubbles",
                "shafts"
            ],
            "usePreview": 0,
            "username": "leecorn",
            "viewed": 1012
        },
        "renderpass": [
            {
                "code": "// Created by Yilin Yan aka greenbird10\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nfloat hash(vec2 p) {\n\treturn 0.5*(\n    sin(dot(p, vec2(271.319, 413.975)) + 1217.13*p.x*p.y)\n    ) + 0.5;\n}\n\nfloat noise(vec2 p) {\n  vec2 w = fract(p);\n  w = w * w * (3.0 - 2.0*w);\n  p = floor(p);\n  return mix(\n    mix(hash(p+vec2(0,0)), hash(p+vec2(1,0)), w.x),\n    mix(hash(p+vec2(0,1)), hash(p+vec2(1,1)), w.x), w.y);\n}\n\n// wave octave inspiration\n// Alexander Alekseev - Seascape\n// https://www.shadertoy.com/view/Ms2SD1\nfloat map_octave(vec2 uv) {\n  uv = (uv + noise(uv)) / 2.5;\n  uv = vec2(uv.x*0.6-uv.y*0.8, uv.x*0.8+uv.y*0.6);\n  vec2 uvsin = 1.0 - abs(sin(uv));\n  vec2 uvcos = abs(cos(uv));\n  uv = mix(uvsin, uvcos, uvsin);\n  float val = 1.0 - pow(uv.x * uv.y, 0.65);\n  return val;\n}\n\nfloat map(vec3 p) {\n  vec2 uv = p.xz + iTime/2.;\n  float amp = 0.6, freq = 2.0, val = 0.0;\n  for(int i = 0; i < 3; ++i) {\n    val += map_octave(uv) * amp;\n    amp *= 0.3;\n    uv *= freq;\n    // uv = vec2(uv.x*0.6-uv.y*0.8, uv.x*0.8+uv.y*0.6);\n  }\n  uv = p.xz - 1000. - iTime/2.;\n  amp = 0.6, freq = 2.0;\n  for(int i = 0; i < 3; ++i) {\n    val += map_octave(uv) * amp;\n    amp *= 0.3;\n    uv *= freq;\n    // uv = vec2(uv.x*0.6-uv.y*0.8, uv.x*0.8+uv.y*0.6);\n  }\n  return val + 3.0 - p.y;\n}\n\nvec3 getNormal(vec3 p) {\n  float eps = 1./iResolution.x;\n  vec3 px = p + vec3(eps, 0, 0);\n  vec3 pz = p + vec3(0, 0, eps);\n  return normalize(vec3(map(px),eps,map(pz)));\n}\n\n// raymarch inspiration\n// Alexander Alekseev - Seascape\n// https://www.shadertoy.com/view/Ms2SD1\nfloat raymarch(vec3 ro, vec3 rd, out vec3 outP, out float outT) {\n    float l = 0., r = 26.;\n    int i = 0, steps = 16;\n    float dist = 1000000.;\n    for(i = 0; i < steps; ++i) {\n        float mid = (r+l)/2.;\n        float mapmid = map(ro + rd*mid);\n        dist = min(dist, abs(mapmid));\n        if(mapmid > 0.) {\n        \tl = mid;\n        }\n        else {\n        \tr = mid;\n        }\n        if(r - l < 1./iResolution.x) break;\n    }\n    outP = ro + rd*l;\n    outT = l;\n    return dist;\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n\t\ttotal += noise(n) * amplitude; \n\t\tn += n;\n\t\tamplitude *= 0.4; \n\t}\n\treturn total;\n}\n\nfloat lightShafts(vec2 st) {\n    float angle = -0.2;\n    vec2 _st = st;\n    float t = iTime / 16.;\n    st = vec2(st.x * cos(angle) - st.y * sin(angle), \n              st.x * sin(angle) + st.y * cos(angle));\n    float val = fbm(vec2(st.x*2. + 200. + t, st.y/4.));\n    val += fbm(vec2(st.x*2. + 200. - t, st.y/4.));\n    val = val / 3.;\n    float mask = pow(clamp(1.0 - abs(_st.y-0.15), 0., 1.)*0.49 + 0.5, 2.0);\n    mask *= clamp(1.0 - abs(_st.x+0.2), 0., 1.) * 0.49 + 0.5;\n\treturn pow(val*mask, 2.0);\n}\n\nvec2 bubble(vec2 uv, float scale) {\n    if(uv.y > 0.2) return vec2(0.);\n    float t = iTime/4.;\n    vec2 st = uv * scale;\n    vec2 _st = floor(st);\n    vec2 bias = vec2(0., 4. * sin(_st.x*128. + t));\n    float mask = smoothstep(0.1, 0.2, -cos(_st.x*128. + t));\n    st += bias;\n    vec2 _st_ = floor(st);\n    st = fract(st);\n    float size = noise(_st_)*0.07+0.01;\n    vec2 pos = vec2(noise(vec2(t, _st_.y*64.1)) * 0.8 + 0.1, 0.5);\n    if(length(st.xy - pos) < size) {\n        return (st + pos) * vec2(.1, .2) * mask;\n    }\n    return vec2(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ro = vec3(0.,0.,2.);\n    vec3 lightPos = vec3(8, 3, -3);\n    vec3 lightDir = normalize(lightPos - ro);\n\n    // adjust uv\n    vec2 uv = fragCoord;\n    uv = (-iResolution.xy + 2.0*uv) / iResolution.y;\n    uv.y *= 0.5;\n    uv.x *= 0.45;\n    uv += bubble(uv, 12.) + bubble(uv, 24.); // add bubbles\n\n    vec3 rd = normalize(vec3(uv, -1.));\n    vec3 hitPos;\n    float hitT;\n    vec3 seaColor = vec3(11,82,142)/255.;\n    vec3 color;\n    \n    // waves\n    float dist = raymarch(ro, rd, hitPos, hitT);\n    float diffuse = dot(getNormal(hitPos), rd) * 0.5 + 0.5;\n    color = mix(seaColor, vec3(15,120,152)/255., diffuse);\n    color += pow(diffuse, 12.0);\n\t// refraction\n    vec3 ref = normalize(refract(hitPos-lightPos, getNormal(hitPos), 0.05));\n    float refraction = clamp(dot(ref, rd), 0., 1.0);\n    color += vec3(245,250,220)/255. * 0.6 * pow(refraction, 1.5);\n\n    vec3 col = vec3(0.);\n    col = mix(color, seaColor, pow(clamp(0., 1., dist), 0.2)); // glow edge\n    col += vec3(225,230,200)/255. * lightShafts(uv); // light shafts\n\n    // tone map\n    col = (col*col + sin(col))/vec3(1.8, 1.8, 1.9);\n    \n    // vignette\n    // inigo quilez - Stop Motion Fox \n    // https://www.shadertoy.com/view/3dXGWB\n    vec2 q = fragCoord / iResolution.xy;\n    col *= 0.7+0.3*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.2);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}