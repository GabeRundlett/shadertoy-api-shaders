{
    "Shader": {
        "info": {
            "date": "1723213458",
            "description": "I was thinking about adding AA to my ray tracing shader but I want to try somthing fun with ray direction, this is it.\n\nmouse.x: adjust dot size?\nmouse.y:  adjust filter strength",
            "flags": 0,
            "hasliked": 0,
            "id": "XcffRn",
            "likes": 1,
            "name": "ray direction distort filter",
            "published": 3,
            "tags": [
                "filter",
                "distort",
                "raytrace"
            ],
            "usePreview": 0,
            "username": "silica163",
            "viewed": 75
        },
        "renderpass": [
            {
                "code": "float diffuse(vec3 N, vec3 L){\n    return clamp(dot(N,L), 0.,1.);\n}\n\nvec3 getColor(vec2 i, vec3 rp, vec3 rd){\n    vec3 c = vec3(0);\n    if(i.y == 0.){\n        N = nSphere(rp, sp[0]);\n        c = vec3(1);\n    }\n    if(i.y == 1.){\n        N = nSphere(rp, sp[1]);\n        c = vec3(0);\n        c += .1*diffuse(N,L);\n    }\n    if(i.y == 2.){\n        N = nPlane(p[0]);\n        float grid = ceil(sin(rp.x*2.)*sin(rp.z*2.));\n        c = vec3(0);\n        c += grid*diffuse(N, L);\n    }\n    \n    if(i.y == 3.)\n        N = nPlane(p[1]);\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (2.*fragCoord.xy - R.xy)/R.y;\n    vec2 m = (2.*iMouse.xy - R.xy)/R.y;\n    vec3 c = vec3(0);\n    vec3 ro = vec3(0,0,1);\n    \n\n// generating rd\n    vec2 settings = vec2(R.y/100., .01);\n    if(iMouse.z > 0.){\n        settings.x *= 0.9 + (iMouse.x/R.x)/8.;\n        settings.y *= iMouse.y/R.y;\n    }\n    vec3 rd = normalize(vec3(uv,0) - ro);\n    rd.xy += cos(fragCoord.xy*settings.x)*settings.y;\n    rd = normalize(rd);\n//\n\n    sp[0] = vec4(1.5,0,-2.5,1);\n    sp[1] = vec4(-1.5,0,-1.5,1);\n    p[1] = Plane(sp[0].xyz, normalize(vec3(0,0,1)), -2.);\n    p[0] = Plane(vec3(0), normalize(vec3(0,1,0)), -1.);\n    vec3 light = vec3(sp[0].xyz);\n\n\n    vec2 i = intersect(ro, rd);\n    vec3 rp = ro + rd * i.x;\n    L = normalize(light - rp);\n    \n    float shadow = 1.;\n    if(dot(N,L) > 0. && i.y == 2.){\n        vec2 ss = intersect(rp + L*.001, L);\n        if(ss.y == 1.)shadow = min(ss.x/3., 1.);\n    }\n    \n    c = shadow * getColor(i, rp, rd);\n    \n    for(int j = 0;j < 3; j++)if(i.y != 0.){\n        Rfl = reflect( rd, N);\n        i = intersect(rp+Rfl*.001, Rfl);\n        rp = rp + Rfl*(i.x+.001);\n        L = normalize(light - rp);\n        rd = Rfl;\n        shadow = 1.;\n        if(dot(N,L) > 0. && i.y == 2.){\n            vec2 ss = intersect(rp + L*.001, L);\n            if(ss.y == 1.)shadow = min(ss.x/3., 1.);\n        }\n        c = shadow * getColor(i, rp, Rfl)/(float(j+1)*4.) + c;\n        if(i.y == -1.)break;\n    }\n    \n    c = sqrt(c);\n    fragColor = vec4(c,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R iResolution\n#define MAX 40.\n\nstruct Plane {\n    vec3 pos;\n    vec3 normal;\n    float shift;\n};\nvec4 sp[2];\nPlane p[2];\n\nvec3 N, L, Rfl;\n\nfloat iPlane(vec3 ro, vec3 rd, Plane p){\n    return (p.shift - dot(ro - p.pos,p.normal))/dot(rd,p.normal);\n}\n\nvec3 nPlane(Plane p){\n    return p.normal;\n}\n\nfloat iSphere(vec3 ro, vec3 rd, vec4 sp){\n    float t = dot(rd, sp.xyz - ro);\n    vec3 rs = ro + rd * t - sp.xyz;\n    float k = sp.w*sp.w - dot(rs,rs);\n    float h = MAX;\n    if( k < 0.){\n        h = -1.;\n    } else {\n        h = sqrt(k);\n        h = min(t - h, t + h);\n    }\n    return h;\n}\n\nvec3 nSphere(vec3 rp, vec4 sp){\n    return (rp - sp.xyz)/sp.w;\n}\n\nvec2 intersect(vec3 ro, vec3 rd){\n    int mat = 0;\n    float d = MAX;\n\n    float s = iSphere(ro, rd, sp[0]);\n    float f = iPlane(ro, rd, p[0]);\n    if(f <= 0.)f = MAX;\n    if(s <= 0.)s = MAX;\n    \n    float s2 = iSphere(ro, rd, sp[1]);\n    float f2 = iPlane(ro, rd, p[1]);\n    if(s2 <= 0.)s2 = MAX;\n\n    d = min(d,s);\n    d = min(d,f);\n    d = min(d, s2);\n\n\n    if(d == s)mat = 0;\n    if(d == s2)mat = 1;\n    if(d == f)mat = 2;\n    if(d == MAX)mat = -1;\n    return vec2(d, mat);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}