{
    "Shader": {
        "info": {
            "date": "1702073007",
            "description": "cosmic style",
            "flags": 1,
            "hasliked": 0,
            "id": "clVBDW",
            "likes": 26,
            "name": "glittery",
            "published": 3,
            "tags": [
                "cineshader"
            ],
            "usePreview": 0,
            "username": "pxlmage",
            "viewed": 1399
        },
        "renderpass": [
            {
                "code": "/* original https://www.shadertoy.com/view/lslyRn  https://www.shadertoy.com/view/lscczl and orher*/\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n//get coords and direction\nvec3 dir=rd;\nvec3 from=ro;\n\n//volumetric rendering\nfloat s=0.1,fade=1.;\nvec3 v=vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p=from+s*dir*.5;\np = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np=abs(p)/dot(p,p)-formuparam; // the magic formula\na+=abs(length(p)-pa); // absolute sum of average change\npa=length(p);\n}\nfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\na*=a*a; // add contrast\nif (r>6) fade*=1.1; // dark matter, don't render near\n//v+=vec3(dm,dm*.5,0.);\nv+=fade;\nv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\nfade*=distfading; // distance fading\ns+=stepsize;\n}\nv=mix(vec3(length(v)),v,saturation); //color adjust\nfragColor = vec4(v*.03,1.);\n}\nconst float pi = 3.14159265359;\nconst float triangleScale = 0.816497161855865; // ratio of edge length and height\nconst vec3 orange = vec3(0.937, 0.435, 0.0);\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec4 getTriangleCoords(vec2 uv) {\n    uv.y /= triangleScale;\n    uv.x -= uv.y / 2.0;\n    vec2 center = floor(uv);\n    vec2 local = fract(uv);\n   \n    center.x += center.y / 2.0;\n    center.y *= triangleScale;\n   \n    if (local.x + local.y > 1.0) {\n    local.x -= 1.0 - local.y;\n        local.y = 1.0 - local.y;\n        center.y += 0.586;\n        center.x += 1.0;\n    } else {\n        center.y += 0.287;\n    center.x += 0.5;\n    }\n   \n    return vec4(center, local);\n}\n\nvec4 getLoader(vec4 triangle) {\n    if (length(triangle.xy) > 1.6) {\n        return vec4(0.0);\n    }\n   \n    float angle = atan(triangle.x, triangle.y);\n    float seed = rand(triangle.xy);\n    float dst = min(triangle.z, min(triangle.w, 1.0 - triangle.z - triangle.w)) * 15.0;\n    float glow = dst < pi ? pow(sin(dst), 1.5) : 0.0;\n   \n    return vec4(mix(orange, vec3(1.0), glow * 0.07), pow(0.5 + 0.5 * sin(angle - iTime * 6.0 + seed), 2.0));\n}\n\nfloat getBackground(vec4 triangle) {\n    float dst = min(triangle.z, min(triangle.w, 1.0 - triangle.z - triangle.w)) - 0.05;\n\n    if (triangle.y > 1.9 || triangle.y < -2.4 || dst < 0.0) {\n        return 0.0;\n    }\n\n    float value = pow(0.5 + 0.5 * cos(-abs(triangle.x) * 0.4 + rand(triangle.xy) * 2.0 + iTime * 4.0), 2.0) * 0.08;    \n    return value * (dst > 0.05 ? 0.65 : 1.0);\n}\n\nvec3 getColor(vec2 uv) {\n    uv *= 2.0 / iResolution.y;\n   \n    vec3 background = vec3(getBackground(getTriangleCoords(uv * 6.0 - vec2(0.5, 0.3))));\n  vec4 loader = getLoader(getTriangleCoords(uv * 11.0));\n   \n    vec3 color = mix(background, loader.rgb, loader.a);\n    return color;\n}\n#define S(a, b, t) smoothstep(a, b, t)\n\nfloat distLine(vec2 p, vec2 a, vec2 b){\nvec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*t);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){\nfloat d = distLine(p, a, b);\n    float m = S(0.03, 0.01, d);\n    float d2 =  length(a - b);\n    m *= S(1.2, 0.8, d2) * 0.5 + S(0.05, 0.03, abs(d2 - 0.75));\n    return m;\n}\n\nfloat distTriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\nvec2 e0 = p1 - p0;\nvec2 e1 = p2 - p1;\nvec2 e2 = p0 - p2;\n\nvec2 v0 = p - p0;\nvec2 v1 = p - p1;\nvec2 v2 = p - p2;\n\nvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\nvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\nvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n   \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\nreturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat triangle(vec2 p, vec2 a, vec2 b, vec2 c){\nfloat d = distTriangle(p, a, b, c);\n    float m = S(0.03, 0.01, d);\n    float d2 =  length(a - b);\n    m *= S(1.2, 0.8, d2) * 0.5 + S(0.05, 0.03, abs(d2 - 0.75));\n    return m;\n}\n\nfloat N21(vec2 p){\np = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nvec2 N22(vec2 p){\nfloat n = N21(p);\n    return vec2(n, N21(p + n));\n}\n\nvec2 getPos(vec2 id, vec2 offset){\n    vec2 n = N22(id + offset) * iTime;\n    return offset + sin(n) * 0.4;\n}\n\nfloat layer(vec2 uv){\nvec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n\n    vec2 p[9];\n    int i = 0;\n    for(float y = -1.0; y <= 1.0; y++){\n    for(float x = -1.0; x <= 1.0; x++){\n        p[i++] = getPos(id, vec2(x, y));\n    }    \n    }\n   \n   \n    float t = iTime * 10.0;\n    float m = 0.0;\n    for(int i = 0; i < 9; i++){\n    m += line(gv, p[4], p[i]);\n       \n        vec2 j = (p[i] - gv) * 20.0;\n        float sparkle = 1.0 / dot(j, j);\n       \n        m += sparkle * (sin(t + fract(p[i].x) * 10.0) * 0.5 + 0.5);\n       \n        for(int yi= i + 1; yi < 9; yi++){\n    for(int zi= yi + 1; zi < 9; zi++){\n               \n                float len1 = abs(length(p[i] - p[yi]));\n                float len2 = abs(length(p[yi] - p[zi]));\n                float len3 = abs(length(p[i] - p[zi]));\n               \n                if((len1 + len2 + len3) < 2.8){\n                m += triangle(gv, p[i], p[yi], p[zi]) * 0.8;\n                }\n    }\n    }\n    }\n    m += line(gv, p[1], p[3]);\n    m += line(gv, p[1], p[5]);\n    m += line(gv, p[7], p[3]);\n    m += line(gv, p[7], p[5]);\n\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//get coords and direction\nvec2 uv=fragCoord.xy/iResolution.xy-.5;\nuv.y*=iResolution.y/iResolution.x;\nvec3 dir=vec3(uv*zoom,(iTime*0.002));\nfloat time=iTime*speed+.25;\n float m = 0.0;\n    float t = iTime * 0.1;\n   \n    float gradient = uv.y;\n   \n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    uv *= rot;\n   \n    for(float i = 0.0; i < 1.0; i += 1.0 / 4.0){\n        float z = fract(i + t);\n        float size = mix(10.0, 0.5, z);\n        float fade = S(0.0, 0.5, z) * S(1.0, 0.8, z);\n       \n        m += layer(uv * size + i * 20.0) * fade;\n    }\n   \n   \n    vec3 base = sin(t * 5.0 * vec3(0.345, 0.456, 0.567)) * 0.4 + 0.6;\n    vec3 col = m * base;\n   \n    col -= gradient * base;\n   \n    //vec2 gv = fract(uv) - 0.5;\n    //if(gv.x > 0.48 || gv.y > 0.48){\n    // col = vec3(1.0, 0.0, 0.0);\n    //}\n   \n    fragColor = vec4(col,1.0);\nfragCoord = fragCoord - 0.5 * iResolution.xy;\nfragColor.rgb = 0.25 * (getColor(fragCoord)\n                            + getColor(fragCoord + vec2(0.5, 0.0))\n                            + getColor(fragCoord + vec2(0.5, 0.5))\n                            + getColor(fragCoord + vec2(0.0, 0.5)));\n\nvec3 from=vec3(1.,.5,0.5)+fragColor.rgb;\nfrom+=vec3(time*2.,time,-2.);\n\n\nmainVR(fragColor, fragCoord, from, dir);\n    fragColor*=vec4(col,1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}