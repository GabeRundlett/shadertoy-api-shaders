{
    "Shader": {
        "info": {
            "date": "1581343477",
            "description": "based on: shadertoy.com/view/XlKSDR \n\nI use randomized sampled to implement some effects including:\nbokeh blur\nchromatic aberration\n6-way star filter\ndifferential grating filter\n\nedit \"maxSamples\" in Buffer B to adjust the sample rate",
            "flags": 32,
            "hasliked": 0,
            "id": "ttcSR2",
            "likes": 8,
            "name": "random sample bokeh blur",
            "published": 3,
            "tags": [
                "bokeh"
            ],
            "usePreview": 0,
            "username": "battlebottle",
            "viewed": 464
        },
        "renderpass": [
            {
                "code": "\n//Edit this to adjust the sample rate\nconst float maxSamples = pow(2.0, 7.0);\n\n//by default rbg channels are samples indidually\nconst bool sampleIndividualChannels = true;\n\n\nconst float PI = 3.14159265359;\n\n\n// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\n\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 rotate(vec2 vecToRotate, float angleInRadians) {\n    float s = sin(angleInRadians);\n    float c = cos(angleInRadians);\n    mat2 m = mat2(c, -s, s, c);\n    return m * vecToRotate;\n}\n\nvec2 sampleTransform(int channel, float rand[4]) {\n    \n    float blurRadMax = 0.08;\n    float blurRadius = blurRadMax * ((sin(iTime / 2.0) + 1.0) / 2.0);\n    \n    if (iMouse.z > 0.0) {\n        blurRadius = blurRadMax * (iMouse.x / iResolution.x);\n    }\n    \n    //simulate chromatic abbration\n    float caFactor = 1.0;\n    if (channel == 1) {\n        caFactor = 1.05;\n    } else if (channel == 3) {\n        caFactor = 0.92;\n        \n    }\n    blurRadius *= caFactor;\n    \n    \n    \n    float sampleRadius = sqrt( rand[0]) * blurRadius;\n    vec2 samplePoint = vec2(0.0, sampleRadius);\n\n    float angle = (2.0 * PI) * rand[1];\n\n    samplePoint = rotate(samplePoint, angle);\n    \n    //an attempt at some diffraction grating\n    float diffractionLineAnlgeRadians = (PI * 1.0) / 3.0 + (PI * mod(iTime / 5.0, 2.0));\n    if (rand[2] < 0.1) {\n        float mult = (rand[2] < 0.05) ? 1.0 : -1.0;\n        samplePoint *= rotate(vec2(3.5,1.0), diffractionLineAnlgeRadians);\n        samplePoint += rotate(vec2((0.6 + 4.0 * rand[2]) * pow(caFactor, 3.0) * mult,0.0), diffractionLineAnlgeRadians);\n    }\n    \n    //an attempt at star filter\n    \n    vec2 starLines[] = \n        vec2[](\n            rotate(vec2(1.0,0.0), (PI * 1.0) / 3.0 + (PI * mod(iTime / 5.0, 2.0))),\n            rotate(vec2(1.0,0.0), (PI * 2.0) / 3.0 + (PI * mod(iTime / 5.0, 2.0))),\n            rotate(vec2(1.0,0.0), (PI * 3.0) / 3.0 + (PI * mod(iTime / 5.0, 2.0)))\n        );\n    \n    if (rand[2] >= 0.1 && rand[2] < 0.2 ) {\n        int starLineIndex = int (floor(rand[0] * 3.0));\n        \n        vec2 starLine = starLines[starLineIndex];\n        \n        float rnd = rand[3];\n        starLine *= 3.0;\n        samplePoint += starLine * rnd - (starLine / 2.0);\n    }\n    \n\n    samplePoint *= vec2(iResolution.y / iResolution.x, 1.0);\n    return samplePoint;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy ;\n    \n    vec3 colAcum2 = vec3(0.0);\n    for(float sampleIndex = 0.0; sampleIndex < maxSamples; sampleIndex++) {\n        \n        \n        \n    \tvec2 texRand = mod(texture(iChannel1, fragCoord.xy / 256.0 + vec2(sampleIndex) / 256.0).rg, 1.0);   \n        float rand[4];\n        \n        for (int i = 0; i < 4; i++) {\n            rand[i] = random(texRand * (sampleIndex / (maxSamples * 2.0) + float(i)) + mod(iTime, 1.0));\n        }\n        \n        \n        int channel = int(mod(sampleIndex, 3.0)) + 1;\n        if (!sampleIndividualChannels){\n         \tchannel = 0;   \n        }\n        \n        \n        vec2 samplePoint = sampleTransform(channel, rand);\n        \n        float blurRadMax = 0.08;\n        float blurRadius = blurRadMax * ((sin(iTime / 2.0) + 1.0) / 2.0);\n        if (channel == 0) { //all colors\n        \tcolAcum2 += textureLod(iChannel0, uv + samplePoint, blurRadius * 30.0).rgb;\n        } else if (channel == 1) { //r\n        \tcolAcum2 += vec3(textureLod(iChannel0, uv + samplePoint, blurRadius * 30.0).r, 0.0, 0.0);\n        } else if (channel == 2) { //g\n        \tcolAcum2 += vec3(0.0, textureLod(iChannel0, uv + samplePoint, blurRadius * 30.0).g, 0.0);\n        } else if (channel == 3) { //b\n        \tcolAcum2 += vec3(0.0, 0.0, textureLod(iChannel0, uv + samplePoint, blurRadius * 30.0).b);\n        }\n\n        \n    }\n    \n    \n    fragColor =  vec4(colAcum2 / (maxSamples * (sampleIndividualChannels ? (1.0/3.0) : 1.0)), 1.0);\n    \n    fragColor = vec4(OECF_sRGBFast(ACESFitted(fragColor.rgb)), 1.0);\n    //add some noise\n    //fragColor -= vec4( texture(iChannel1, fragCoord.xy / 256.0).rgb / 64.0, 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Render the scene\n//Code taken from: https://www.shadertoy.com/view/XlKSDR\n\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265359\n\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}\n\n//------------------------------------------------------------------------------\n// Distance field functions\n//------------------------------------------------------------------------------\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t) {\n    return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec2 scene(in vec3 position) {\n    vec2 scene = opUnion(\n          vec2(sdPlane(position), 1.0),\n          vec2(sdSphere(position - vec3(0.0, 0.4, 0.0), 0.4), 12.0)\n    );\n    return scene;\n}\n\n//------------------------------------------------------------------------------\n// Ray casting\n//------------------------------------------------------------------------------\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        float h = scene(origin + direction * t).x;\n        if (h < 0.001) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = -1.0;\n\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        vec2 hit = scene(origin + direction * t);\n        if (hit.x < 0.002 || t > 20.0) break;\n        t += hit.x;\n        material = hit.y;\n    }\n\n    if (t > 20.0) {\n        material = -1.0;\n    }\n\n    return vec2(t, material);\n}\n\nvec3 normal(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          scene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x,\n          scene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x,\n          scene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);\n    return normalize(n);\n}\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / PI;\n}\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//------------------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------------------\n\nvec3 render(in vec3 origin, in vec3 direction, out float distance) {\n    \n    float brightnessMult = (sin(iTime) + 1.0) / 2.0 + 0.5;\n\n    if (iMouse.z > 0.0) {\n        brightnessMult = (iMouse.y / iResolution.y) * 2.0;\n    }\n    // Sky gradient\n    vec3 color = vec3(0.65, 0.85, 1.0) + direction.y * 0.72;\n\n    // (distance, material)\n    vec2 hit = traceRay(origin, direction);\n    distance = hit.x;\n    float material = hit.y;\n\n    // We've hit something in the scene\n    if (material > 0.0) {\n        vec3 position = origin + distance * direction;\n\n        vec3 v = normalize(-direction);\n        vec3 n = normal(position);\n        vec3 l = normalize(vec3(0.6, 0.7, -0.7));\n        vec3 h = normalize(v + l);\n        vec3 r = normalize(reflect(direction, n));\n\n        float NoV = abs(dot(n, v)) + 1e-5;\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n\n        vec3 baseColor = vec3(0.0);\n        float roughness = 0.0;\n        float metallic = 0.0;\n        \n\n        float intensity = (brightnessMult + 0.0) * 1.0;\n        float indirectIntensity = 0.64 * (brightnessMult + 0.0) * .5;\n\n        if (material < 4.0)  {\n            // Checkerboard floor\n            float f = mod(floor(6.0 * position.z) + floor(6.0 * position.x), 2.0);\n            baseColor = 0.4 + f * vec3(0.6);\n            roughness = 0.1;\n        } else if (material < 16.0) {\n            // Metallic objects\n            baseColor = hueShift(vec3(0.1, 0.6, 0.05),iTime);\n            roughness = 0.2;\n        }\n\n        float linearRoughness = roughness * roughness;\n        vec3 diffuseColor = (1.0 - metallic) * baseColor.rgb;\n        vec3 f0 = 0.04 * (1.0 - metallic) + baseColor.rgb * metallic;\n\n        float attenuation = shadow(position, l);\n\n        // specular BRDF\n        float D = D_GGX(linearRoughness, NoH, h);\n        float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n        vec3  F = F_Schlick(f0, LoH);\n        vec3 Fr = (D * V) * F;\n\n        // diffuse BRDF\n        vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n\n        color = Fd + Fr;\n        color *= (intensity * attenuation * NoL) * vec3(0.98, 0.92, 0.89);\n\n        // diffuse indirect\n        vec3 indirectDiffuse = Irradiance_SphericalHarmonics(n) * Fd_Lambert();\n\n        vec2 indirectHit = traceRay(position, r);\n        vec3 indirectSpecular = vec3(0.65, 0.85, 1.0) + r.y * 0.72;\n        if (indirectHit.y > 0.0) {\n            if (indirectHit.y < 4.0)  {\n                vec3 indirectPosition = position + indirectHit.x * r;\n                // Checkerboard floor\n                float f = mod(floor(6.0 * indirectPosition.z) + floor(6.0 * indirectPosition.x), 2.0);\n                indirectSpecular = 0.4 + f * vec3(0.6);\n            } else if (indirectHit.y < 16.0) {\n                // Metallic objects\n                indirectSpecular = vec3(0.3, 0.0, 0.0);\n            }\n        }\n\n        // indirect contribution\n        vec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n        vec3 specularColor = f0 * dfg.x + dfg.y;\n        vec3 ibl = diffuseColor * indirectDiffuse + indirectSpecular * specularColor;\n\n        color += ibl * indirectIntensity;\n    }\n\n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Setup and execution\n//------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized coordinates\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    // Aspect ratio\n    p.x *= iResolution.x / iResolution.y;\n\n    // Camera position and \"look at\"\n    vec3 origin = vec3(0.0, 0.8, 0.0);\n    vec3 target = vec3(0.0);\n\n    origin.x += 1.7 * cos(iTime * 0.2);\n    origin.z += 1.7 * sin(iTime * 0.2);\n\n    mat3 toWorld = setCamera(origin, target, 0.0);\n    vec3 direction = toWorld * normalize(vec3(p.xy, 2.0));\n\n    // Render scene\n    float distance;\n    vec3 color = render(origin, direction, distance);\n\n    //// Tone mapping\n    //if (iMouse.z > 0.0) {\n    //    if (iMouse.x < fragCoord.x) {\n    //    \tcolor = ACESFitted(color);\n    //    }\n    //} else {\n    //    color = ACESFitted(color);\n    //}\n\n    // Exponential distance fog\n    color = mix(color, 0.8 * vec3(0.7, 0.8, 1.0), 1.0 - exp2(-0.011 * distance * distance));\n\n    // Gamma compression\n    //color = OECF_sRGBFast(color);\n    \n    \n\n    fragColor = vec4(color, distance);\n    \n    //add some noise\n    //fragColor -= vec4( texture(iChannel0, fragCoord.xy / 256.0).rgb / 64.0, 0.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}