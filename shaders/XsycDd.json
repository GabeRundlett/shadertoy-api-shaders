{
    "Shader": {
        "info": {
            "date": "1524317037",
            "description": "Expanding on Tomkh's previous work by constructing a dual Voronoi graph from the Delaunay triangulation of random points.",
            "flags": 0,
            "hasliked": 0,
            "id": "XsycDd",
            "likes": 24,
            "name": "Triangle-Voronoi Graph Weave",
            "published": 3,
            "tags": [
                "voronoi",
                "triangle",
                "edge",
                "graph",
                "dual",
                "delaunay",
                "weave",
                "circumcenter"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1433
        },
        "renderpass": [
            {
                "code": "/*\n\n\tTriangle-Voronoi Graph Weave\n\t----------------------------\n\n\tExpanding on Tomkh's previous work by constructing a dual Voronoi graph from the Delaunay \n\ttriangulation of random points. It's mainly a proof of concept, but in order to make it\n\tslightly more interesting, I went to the extra trouble to weave the graph components.\n\n\tThis turned out to be a trickier exercise than I expected. Obtaining the Voronoi information\n\trequired a little extra work -- due to the necessity to determine neighboring triangle \n\tinformation, but overall, it wasn't too bad. However, creating the weave required unique \n\tID's for neighboring edges, which required a whole bunch of point IDs, etc.\n\n\tI wouldn't call this a lot of code, but it's probably a little more than someone with better\n\tthings to do would like to decipher. I thought it would be novel to weave the dual graph, \n\tbut that complicated things and added a lot of extra code. The extra window dressing also \n\tadded to the line count. With that in mind, I'll put together a much more concise and easier \n\tto consume version pretty soon. In the meantime, it's still possible to use this in \n\tconjunction with Tomkh's or my previous example to get the general idea.\n\n\tThe logic for this seems to be sound, but was rushed, so it wouldn't surprise me if there are\n\tbetter ways to go about it. Having said that, the routine consists of just four checks, plus \n\ta bit of decision making and variable setting, so it should suffice.\n\n\tBy the way, I'm pretty sure that the Delaunay triangulation will break with too much of a \n\tpoint spread, so a pretty tight restriction has been set, which in turn, has resulted in boxy\n\tlooking cell sites. At some stage, I'll try to improve on that... or just wait for someone \n\tmore clever on Shadertoy to do it -- You'd be amazed at how often that strategy works. :D\n\t\n\n\tBased on:\n\n\t// I'd been wanting to see a geometric Delaunay triangulation example on Shadertoy for ages,\n\t// so Tomkh (Tomasz Dobrowolski) was kind enough to whip one up in virtually no time. In\n\t// addition to helping me out, I really like the way this is presented.\n\tRandom Delaunay Triangulation - Tomkh\n\thttps://www.shadertoy.com/view/4sKyRD\n\n\tAnother example:\n    \n\t// Really nice screensaver-like example. To my knowledge, Mattz was the first to put up a \n\t// quasi-randomized 2D triangle mesh. However, his particular example uses the same diagonal\n\t// orientation on each quadrilateral.\n\tice and fire - mattz\n\thttps://www.shadertoy.com/view/MdfBzl\n\n\n*/\n\n// Color palette. The default red and gold trim (0), a four-colored pastel palette (1), greyscale with\n// color (2), or just greyscale (3).\n#define PALETTE 0 \n//#define GREY_LINES // Grey triangle lines.\n\n// Fixed unanimated triangles, if you don't like the triangle popping effect. :)\n#define FIXED\n\n\n// A visual aid to show the physical square grid.\n//#define SHOW_GRID_CELLS\n\n\n// Greyscale.\nvec3 grey(vec3 col){ return vec3(1)*dot(col, vec3(.299, .587, .114)); }\n\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(11, 157)));\n    #ifdef FIXED\n    return (fract(vec2(262144, 32768)*n) - .5)*2.*.24;\n    #else\n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".35,\" insted of \".5\" that you'd expect to see. .\n    return sin(p*6.2831853 + iTime/2.)*.24;\n    #endif\n}\n\n\n// vec2 to vec2 hash.\nfloat hash21(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    return fract(sin(dot(p, vec2(113.927, 1.763)))*43758.5453);\n} \n\n\n// The triangle line pattern.\nfloat linePattern(vec2 p, vec2 a, vec2 b){\n  \n    // Determine the angle between the vertical 12 o'clock vector and the edge\n    // we wish to decorate (put lines on), then rotate \"p\" by that angle prior\n    // to decorating. Simple.\n    vec2 v1 = vec2(0, 1);\n    vec2 v2 = (b - a);\n\n    if(a.x>b.x) v2.y = -v2.y;\n\n    // Angle between vectors.\n    //float ang = acos(dot(v1, v2)/(length(v1)*length(v2))); // In general.\n    float ang = acos(v2.y/length(v2)); // Trimed down.\n    p = rot2(ang - .2)*p; // Putting the angle slightly past 90 degrees is optional.\n\n    float ln = clamp(cos(p.y*64.*2.)*1. - .5, 0., 1.);\n\n    return ln*.25 + clamp(sin(p.y*64.)*3. + 2.95, 0., 1.)*.75 + .15; // Ridges.\n \n}\n\n\n// Signed distance to the segment joining \"a\" and \"b.\" We need this one to determine\n// which side of the line a point is on.\n//\n// From Tomkh's original example. I trimmed it a bit, but for all I know, I might have\n// made is slower. :)\nfloat sDistLine(vec2 a, vec2 b) {\n       \n    b -= a; return dot(a, vec2(-b.y, b.x)/length(b)); //return dot(a, normalize(vec2(-b.y, b.x)));\n    \n}\n\n// Unsigned distance to the segment joining \"a\" and \"b.\"\nfloat distLine(vec2 a, vec2 b){\n    \n\tb = a - b;\n\tfloat h = clamp(dot(a, b) / dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n\n// From the the following example:\n// Random Delaunay Triangulation - Tomkh\n// https://www.shadertoy.com/view/4sKyRD\n//\n// Use \"parabolic lifting\" method to calculate if two triangles are about to flip.\n// This is actually more reliable than circumscribed circle method.\n// The technique is based on duality between Delaunay Triangulation\n// and Convex Hull, where DT is just a boundary of convex hull\n// of projected seeds onto paraboloid.\n// We project (h1 h2 h3) triangle onto paraboloid\n// and return the distance of the origin\n// to a plane crossing projected triangle.\nfloat flipDistance(vec2 h1, vec2 h2, vec2 h3)\n{\n   // Projects triangle on paraboloid.\n   vec3 g1 = vec3(h1, dot(h1, h1));\n   vec3 g2 = vec3(h2, dot(h2, h2));\n   vec3 g3 = vec3(h3, dot(h3, h3));\n   // Return signed distance of (g1, g2, g3) plane to the origin.\n   //#if FLIP_ANIMATION\n    // return dot(g1, normalize(cross(g3-g1, g2-g1)));\n   //#else\n     // If we don't do animation, we are only interested in a sign,\n     // so normalization is unnecessary.\n   \t return dot(g1, cross(g3-g1, g2-g1));\n   //#endif\n}\n\n\n// IQ's triangle hit routine.\nbool insideTri(vec2 p, vec2 a, vec2 b, vec2 c){\n    \n \t// Compute vectors        \n    vec2 v0 = c - a;\n    vec2 v1 = b - a;\n    vec2 v2 = p - a;\n\n    // Compute dot products\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n\n    // Compute barycentric coordinates\n    float invDenom = 1./(dot00*dot11 - dot01*dot01);\n    float u = (dot11*dot02 - dot01*dot12)*invDenom;\n    float v = (dot00*dot12 - dot01*dot02)*invDenom;\n\n    // Check if point is in triangle\n    return (u>0. && v>0. && (u + v)<1.)? true : false;  \n    \n}\n\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n// IQ's point in a quadrilateral routine -- IQ's original is more sophisticated, but\n// I only needed to return a hit, so I hacked at it a bit. There are probably faster \n// routines, especially since the UV coordinates aren't required. However, I might use them\n// later, so I'll leave it as is for now. By the way, if someone has a fast \"point inside a\n// quad\" algorithm, I'd like to hear about it.\n//\n// Given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\nbool insideQuad(in vec2 a, in vec2 b, in vec2 c, in vec2 d){\n\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = -a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n\n    // otherwise, it's a quadratic\n    float w = k1*k1 - 4.0*k0*k2;\n    if( w<0.0 ) return false; //vec2(-1.0);\n    w = sqrt( w );\n\n\n    float ik2 = 0.5/k2;\n    float v = (-k1 - w)*ik2; if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;\n    float u = (h.x - f.x*v)/(e.x + g.x*v);\n    if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return false;//vec2(-1.0);\n    //res = vec2( u, v );\n    \n    return true;\n}\n\n    \n// The center of a triangle's circumcircle. Also, the intersection of the perpendicular bisectors.\nvec2 circCent(vec2 a, vec2 b, vec2 c){\n    \n    float d = (a.x*(b.y - c.y) + b.x*(c.y - a.y) + c.x*(a.y - b.y))*2.;\n\n    vec2 a2 = a*a, b2 = b*b, c2 = c*c, u;\n    \n    u.x =  (a2.x + a2.y)*(b.y - c.y) + (b2.x + b2.y)*(c.y - a.y) + (c2.x + c2.y)*(a.y - b.y);\n    u.y =  (a2.x + a2.y)*(c.x - b.x) + (b2.x + b2.y)*(a.x - c.x) + (c2.x + c2.y)*(b.x - a.x);\n\n    return u/d;\n\n}\n\n/*\n// Circum radius -- A circle that encloses the triangle and passes through all vertices. \nfloat circumR(vec2 p0, vec2 p1, vec2 p2){\n\n    // Side lengths.\n    float a = length(p0 - p1), b = length(p1 - p2),  c = length(p2 - p0);\n    \n    float s = (a + b + c)/2.; // Semiperimeter.\n    float area = sqrt(s*(s - a)*(s - b)*(s - c)); // Area.\n    \n    return a*b*c/(4.*area);// Circumradius.\n}\n\n*/ \n\n// The triangle object. A lot of these variables were hacked in as they were needed, so it lacks\n// naming consistency, etc. I'll tidy this up later though.\nstruct triObj{\n    \n    vec2 p0, p1, p2; // The triangle vertices.\n    \n    vec2 id0, id1, id2; // The triangle vertice IDs.\n    \n    // l - Diagonal opposite, m - top or bottom neighbor, n - left or right neighbor.\n    vec2 l, l1, l2, m, m1, m2, n, n1, n2; // Three neighboring triangle vertices.\n    \n    vec2 lID[3], mID[3], nID[3]; // Three neighboring triangle vertices IDs.\n    \n    // Unique triangel ID. and one of four triangle cell IDs that identify the \n    // particular triangle's quadrilateral arrangement.\n    vec2 id, cID; \n    \n};\n    \n \n    \n\n// The triangle mesh routine: Iterate through the cell and it's neighbors until we hit a quadrilateral, \n// then determine which triangle information to return. By that I mean, triangle vertices and IDs, plus\n// the neighboring triangle vertices and IDs. It was exhausting to write out, but logically, not all that\n// complicated.\n//\n// I wrote this from scratch, but basically adapted the logic from Tomkh's Delaunay triangle mesh example.\n// It was surprisingly easy to write, but if it were not for his example, I wouldn't have known where to begin. :)\ntriObj triangulate(in vec2 p){\n    \n    // I'm declaring the vertices outside the loop, because it looks neater, but I hear it's faster to declare them\n    // as locally as possible.\n    vec2 o, o1, o2, o3, o4, o5;\n    vec2 id0, id1, id2, id3, id4, id5;\n\t\n    // Cell identifier and fractional position.\n    vec2 g = floor(p); p -= g + .5;\n \n    // Main triangle vertices, and its neighboring vertices. These particular variables are stored in the\n    // triangle object. The only reason they're declared here is to save writing \"tri..\"\n    vec2 h = vec2(1e8), h1 = vec2(1e8), h2 = vec2(1e8);\n    vec2 l = vec2(1e8), l1 = vec2(1e8), l2 = vec2(1e8);\n    vec2 m = vec2(1e8), m1 = vec2(1e8), m2 = vec2(1e8);\n    vec2 n = vec2(1e8), n1 = vec2(1e8), n2 = vec2(1e8);\n    \n    \n    \n    triObj tri; // The triangle object.\n    tri.cID = vec2(-1); // Not necessary, since we're guaranteed a hit, but it's a raytracing habit.\n    tri.id0 = tri.id1 = tri.id2 = vec2(1e8); // Main triangle vertice IDs.\n    \n/*    \n    // Precalculating the hash values so as not to recalculate too many in the main loop. Basically, I'm setting \n    // up an extra loop, an array, plus indexing, etc, in order to cut down from a possible 36 hash calculations \n    // to 16. Not to mention, making thing less readable... Therefore, it might be a case of diminishing returns. \n    // I'd like to hear what the experts have to say about this, because I'm on the fence as to whether I should\n    // be complicating things and wasting resources with this step. :)\n    //\n    vec2 aO[16];\n    for(int j=0; j<=3; j++){\n\t\tfor(int i=0; i<=3; i++){\n            \n            aO[j*4 + i] = vec2(i - 1, j - 1) + hash22(g + vec2(i - 1, j - 1)) - p;            \n        }\n    }\n\n*/\n    \n    \n    // Iterate through the cell and its neighbors until we hit a quadrilateral, then determine which\n    // triangle to return. I've allowed the grid vertices to randomly move further away from their original\n    // positions, which requires 9 cell checks, instead of just 4.\n    //\n    // By the way, once a triangle has been found, we break from the loop to avoid further redundant \n    // calculations. This means fewer than 9 checks are performed on average -- A rough guess would be an\n    // average of 5 checks per pass which I'd expect most GPUs can handle in their sleep.\n    //\n\tfor(int j=0; j<=1; j++){\n\t\tfor(int i=0; i<=1; i++){\n            \n \t\t\t// The four quadrilateral vertices for this particular cell. Clockwise arrangement.\n            // o -- o1\n            // |    |\n            // o3-- o2\n            id0 = vec2(i - 1, j);\n            id1 = vec2(i, j);\n            id2 = vec2(i, j - 1);\n            id3 = vec2(i - 1, j - 1);\n            o = id0 + hash22(g + id0) - p; // Origin -- Top left.\n            o1 = id1 + hash22(g + id1) - p; // Top right.\n            o2 = id2 + hash22(g + id2) - p; // Bottom right.\n            o3 = id3 + hash22(g + id3) - p; // Bottom left.\n            //o = aO[(j+1)*4 + i]; // Origin -- Top left.\n            //o1 = aO[(j+1)*4 + i + 1]; // Top right.\n            //o2 = aO[j*4 + i + 1]; // Bottom right.\n            //o3 = aO[j*4 + i]; // Bottom left.\n\n            // Quad and four neighboring arrangements.\n            //\n            //     4  5\n\n\t\t\t//\t4  0  1  4\n\n\t\t\t//  5  3  2  5\n\n\t\t\t//\t   4  5\n            \n    \n            // If the point resides in this particular cell's quad, determine which triangle it resides in, then \n            // determine it's neighboring triangles. Return all relevant vertex points, ID, etc.\n            if(insideQuad(o, o1, o2, o3)){\n                \n                // Applying the Delaunay rule to the quad: Basically, split the quad along an arbitrary diagonal to form\n                // a triangle. Circumscribe a circle around them, then determine whether the excluded fourth point lies \n                // within the circle. If it does, then flip the diagonal. There's a bit of math and theory behind it, but \n                // thankfully, Tomkh took care of that bit. :)\n                //\n                // By the way, there's no rule that says you need to do it this way -- You could restric the vertice\n                // movement more, then simply flip the diagonal on a random basis. However, the following tends to look \n                // better. Plus, if you wish to put together a Delaunay triangulation for various reasons -- like \n                // constructing the dual Voronoi representation -- this step is necessary.\n                float f = flipDistance(o - o2, o1 - o2, o3 - o2)<0.? 1. : -1.;\n                 \n                \n\t\t\t\tif(f>0.){ // Diagonal runs from the top right vertex to the bottom left vertex.\n                    \n                     // Determining which side of the diagonal quadrilateral line the point is on. In other words,\n                     // determine which of the two triangles that make up the quad the point is in.\n                     if(sDistLine(o1, o3)>0.){\n                         // o3, o, o1 triangle.\n                         tri.cID = vec2(0); // Red\n                         h = o3, h1 = o, h2 = o1;\n                         l = o1, l1 = o2, l2 = o3;\n                         \n                         // Top triangle.\n                         id4 = vec2(i - 1, j + 1);\n                         id5 = vec2(i, j + 1);\n                         o4 = id4 + hash22(g + id4) - p; \n            \t\t\t o5 = id5 + hash22(g + id5) - p; \n                         f = flipDistance(o4 - o1, o5 - o1, o - o1)<0.? 1. : -1.;\n                         if(f>0.){ m = o, m1 = o5, m2 = o1; tri.mID[0] = id0; tri.mID[1] = id5; tri.mID[2] = id1; }                         \n                         else { m = o, m1 = o4, m2 = o1; tri.mID[0] = id0; tri.mID[1] = id4; tri.mID[2] = id1; }\n                         \n                         // Left triangle.\n                         id4 = vec2(i - 2, j);\n                         id5 = vec2(i - 2, j);\n                         o4 = id4 + hash22(g + id4) - p; \n            \t\t\t o5 = id5 + hash22(g + id5) - p;\n                         f = flipDistance(o4 - o3, o - o3, o5 - o3)<0.? 1. : -1.;\n                         if(f>0.){ n = o3, n1 = o5, n2 = o; tri.nID[0] = id3; tri.nID[1] = id5; tri.nID[2] = id0; }\n                         else { n = o3, n1 = o4, n2 = o; tri.nID[0] = id3; tri.nID[1] = id4; tri.nID[2] = id0; }\n                         \n                         tri.id0 = id3; tri.id1 = id0; tri.id2 = id1; \n                         tri.lID[0] = id1; tri.lID[1] = id2; tri.lID[2] = id3;\n                         \n                         \n                    }\n                    else {\n                         // o1, o2, o3 triangle.\n                         tri.cID = vec2(1); // Blue.\n                        \n                         h = o1, h1 = o2, h2 = o3;\n                         l = o3, l1 = o, l2 = o1;                        \n                        \n                         // Bottom triangle.\n                         id4 = vec2(i - 1, j - 2);\n                         id5 = vec2(i, j - 2);\n                         o4 = id4 + hash22(g + id4) - p; \n            \t\t\t o5 = id5 + hash22(g + id5) - p;\n                         f = flipDistance(o3 - o5, o2 - o5, o4 - o5)<0.? 1. : -1.;\n                         if(f<0.){ m = o2, m1 = o5, m2 = o3; tri.mID[0] = id2; tri.mID[1] = id5; tri.mID[2] = id3; }\n                         else { m = o2, m1 = o4, m2 = o3; tri.mID[0] = id2; tri.mID[1] = id4; tri.mID[2] = id3; }\n                        \n                         // Right triangle.\n                         id4 = vec2(i + 1, j);\n                         id5 = vec2(i + 1, j - 1);\n                         o4 = id4 + hash22(g + id4) - p; \n            \t\t\t o5 = id5 + hash22(g + id5) - p;\n                         f = flipDistance(o1 - o5, o4 - o5, o2 - o5)<0.? 1. : -1.;\n                         if(f>0.){ n = o1, n1 = o4, n2 = o2; tri.nID[0] = id1; tri.nID[1] = id4; tri.nID[2] = id2; }\n                         else { n = o1, n1 = o5, n2 = o2; tri.nID[0] = id1; tri.nID[1] = id5; tri.nID[2] = id2; } \n                        \n                         tri.id0 = id1; tri.id1 = id2; tri.id2 = id3; \n                         tri.lID[0] = id3; tri.lID[1] = id0; tri.lID[2] = id1;\n                         \n                    }\n                    \n                }\n                else { // Diagonal runs from the top left vertex to the bottom right vertex.\n                   \n                    // If we have the flipped diagonal arrangement, determine which triangle the point is in.\n                    if(sDistLine(o, o2)>0.){\n                         //o1 = o2; o2 = o3; // o2, o3, o triangle.\n                         tri.cID = vec2(2); // Orange.\n                         h = o2, h1 = o3, h2 = o;\n                         l = o, l1 = o1, l2 = o2;\n                        \n                         // Bottom triangle.\n                         id4 = vec2(i - 1, j - 2);\n                         id5 = vec2(i, j - 2);\n                         o4 = id4 + hash22(g + id4) - p; \n            \t\t\t o5 = id5 + hash22(g + id5) - p;\n                         f = flipDistance(o3 - o5, o2 - o5, o4 - o5)<0.? 1. : -1.;\n                         if(f<0.){ m = o2, m1 = o5, m2 = o3; tri.mID[0] = id2; tri.mID[1] = id5; tri.mID[2] = id3; }\n                         else { m = o2, m1 = o4, m2 = o3; tri.mID[0] = id2; tri.mID[1] = id4; tri.mID[2] = id3; }\n                         \n                         // Left triangle.\n                         id4 = vec2(i - 2, j);\n                         id5 = vec2(i - 2, j - 1);\n                         o4 = id4 + hash22(g + id4) - p; \n            \t\t\t o5 = id5 + hash22(g + id5) - p;\n                         f = flipDistance(o4 - o3, o - o3, o5 - o3)<0.? 1. : -1.;\n                         if(f>0.){ n = o3, n1 = o5, n2 = o; tri.nID[0] = id3; tri.nID[1] = id5; tri.nID[2] = id0; }\n                         else { n = o3, n1 = o4, n2 = o; tri.nID[0] = id3; tri.nID[1] = id4; tri.nID[2] = id0; }\n                         \n                         tri.id0 = id2; tri.id1 = id3; tri.id2 = id0;\n                         tri.lID[0] = id0; tri.lID[1] = id1; tri.lID[2] = id2;\n                        \n                         \n                    }\n                    else {\n                        \n                        // o, o1, o2 triangle.\n                         tri.cID = vec2(3); // Green.\n                         h = o, h1 = o1, h2 = o2;\n                         l = o2, l1 = o3, l2 = o;\n                        \n                         // Top triangle.\n                         id4 = vec2(i - 1, j + 1);\n                         id5 = vec2(i, j + 1);\n                         o4 = id4 + hash22(g + id4) - p; \n            \t\t\t o5 = id5 + hash22(g + id5) - p;\n                         f = flipDistance(o4 - o1, o5 - o1, o - o1)<0.? 1. : -1.;\n                         if(f>0.){ m = o, m1 = o5, m2 = o1; tri.mID[0] = id0; tri.mID[1] = id5; tri.mID[2] = id1; }\n                         else { m = o, m1 = o4, m2 = o1; tri.mID[0] = id0; tri.mID[1] = id4; tri.mID[2] = id1; }\n                         \n                         // Right triangle.\n                         id4 = vec2(i + 1, j);\n                         id5 = vec2(i + 1, j - 1);\n                         o4 = id4 + hash22(g + id4) - p; \n            \t\t\t o5 = id5 + hash22(g + id5) - p;\n                         f = flipDistance(o1 - o5, o4 - o5, o2 - o5)<0.? 1. : -1.;\n                         if(f>0.){ n = o1, n1 = o4, n2 = o2; tri.nID[0] = id1; tri.nID[1] = id4; tri.nID[2] = id2; }\n                         else { n = o1, n1 = o5, n2 = o2; tri.nID[0] = id1; tri.nID[1] = id5; tri.nID[2] = id2; } \n                        \n                          \n                         tri.id0 = id0; tri.id1 = id1; tri.id2 = id2; \n                         tri.lID[0] = id2; tri.lID[1] = id3; tri.lID[2] = id0;\n                        \n                    }                  \n                }\n\n                \n                tri.p0 = h; tri.p1 = h1; tri.p2 = h2; // Triangle vertices.\n                tri.id = tri.cID + g + vec2(i - 1, j); // Triangle ID.\n                \n                tri.id0 += g; tri.id1 += g; tri.id2 += g; // Individual triangle vertex IDs.\n                \n                // Neighboring triangle vertices.\n                tri.l = l; tri.l1 = l1; tri.l2 = l2;\n                tri.m = m; tri.m1 = m1; tri.m2 = m2;\n                tri.n = n; tri.n1 = n1; tri.n2 = n2;\n                \n                // Neighboring triangle vertex IDs.\n                tri.lID[0] += g; tri.lID[1] += g; tri.lID[2] += g;\n                tri.mID[0] += g; tri.mID[1] += g; tri.mID[2] += g;\n                tri.nID[0] += g; tri.nID[1] += g; tri.nID[2] += g;\n\n\n                \n                // Once we've effectively hit a triangle, break to save further calculations.\n                break;\n                \n            }\n            \n                       \n\t\t}\n\t}\n    \n     \n    \n    // Return the triangle object -- Vertices, IDs, etc.\n    return tri;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // COORDINATES AND SETUP\n    //\n    // Screen coordinates. Note that I've put restrictions on the resolution. I coded this for\n    // the 800 by 450 canvas, so the image looks a little bloated in fullscreen. Therefore, I've\n    // attempted to counter that by restricting is to 800 pixels... It kind of works. :)\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5)/clamp(iResolution.y, 350., 800.);\n    \n    // Subtle convex screen bulge for a bit of visual variance and that slightly dizzying effect. :)\n    vec2 uv2 = uv*vec2(iResolution.y/iResolution.x, 1);\n    uv *= .95 + dot(uv2, uv2)*.1;\n    \n    \n    #ifdef FIXED\n    // Basic diagonal scrolling.\n    vec2 p = uv*5. - vec2(2, 1)*iTime/8.;\n    #else \n    // Moving everything down slightly to give the mild impression that the structure is\n    // slowly sliding down a wall... or something. I make this up as I go along. :)\n    vec2 p = uv*5. - vec2(0, -1)*iTime/8. - vec2(0, 1);\n    #endif\n    \n    \n\n    // DUEL TRIANGLE AND VORONOI PROCESSING\n    //\n    // Perform the triangulation: This function returns the triangle object struct, which consists of the\n    // three triangle vertices, the unique cell ID, and another triangle ID for coloring.\n    triObj tri = triangulate(p);\n    \n    \n    // Calculating the circumcenters of the central triangle and its neighbors. Connecting the central\n    // circumcenter to the neighboring ones produce the dual Voronoi edges. A few other connections need\n    // to made -- due to the grid nature of this example, but that's the gist of it.\n    vec2 cC = circCent(tri.p0, tri.p1, tri.p2);\n    vec2 cC0 = circCent(tri.l, tri.l1, tri.l2);\n    vec2 cC1 = circCent(tri.m, tri.m1, tri.m2);\n    vec2 cC2 = circCent(tri.n, tri.n1, tri.n2);\n   \n/*\n    // Distances from our pixel to the three edges. Since we're weaving lines, each have to be accounted\n    // for seperately.\n    float d0 = distLine(tri.p0, tri.p1); \n    float d1 = distLine(tri.p1, tri.p2);\t\n    float d2 = distLine(tri.p2, tri.p0);\n    \n        // Depending on quad arrangement (diagonal arrangement), \"d0\" and \"d1\" need to be swapped in order to\n    // match the correct edges... Like too many things, I found that out the hard way. :D\n    if(tri.cID.x<1.5){\n        \n        float temp = d0;\n        d0 = d1;\n        d1 = temp;\n        \n    }\n*/\n\n    // Distances from our pixel to the three edges. Since we're weaving lines, each have to be accounted\n    // for seperately. We're using the shared neighboring edge coordinates, since they're oriented \n    // correctly.\n    float d2 = distLine(tri.l, tri.l2); \n    float d1 = distLine(tri.n, tri.n2);\t\n    float d0 = distLine(tri.m, tri.m2);\n    \n\n    \n    // Triangle line identification. We need to identify which line we're rendering in order to randomly \n    // render it above or below the Voronoi lines.\n    float lineID = (d0<d1 && d0<d2)? 0. : d1<d2? 1. : 2.;\n    \n    // The triangle distance field value, for shading purposes.\n    float triDist = min(min(d0, d1), d2);\n    \n\n    // Cell color, based on the four triangle arrangements: Top-left, top-right, bottom-left and bottom-right.\n    vec3 cellCol;\n    \n    if(tri.cID.x == 3.) cellCol = vec3(1, 1.3, .6); // Green.\n    else if(tri.cID.x == 2.) cellCol = vec3(1.4, 1, .6); // Orangey brown.\n    else if(tri.cID.x == 1.) cellCol = vec3(.6, 1, 1.4); // Blue.\n    else cellCol = vec3(1.4, .7, .8); // Pinkish red.\n    \n    //if(hash21(tri.id)>.4) cellCol = grey(cellCol);\n    \n    #if PALETTE==0\n    // The less complicated default palette. For amateurs like myself, fewer colors are easier to work with. :)\n    if(hash21(tri.id)>.25) cellCol = grey(cellCol); // Greyscale.\n    else cellCol = mix(vec3(1.3, .2, .1), vec3(1.3, .5, .3), dot(sin(p*3. - cos(p.yx*3.)), vec2(.25)) + .5);\n    \n    /*\n    // Blinking color version.\n    float blink = smoothstep(.65, .75, sin(hash21(tri.id)*6.283 + iTime));\n    vec3 col1 = grey(cellCol); \n    vec3 col2 =  mix(vec3(1.3, .2, .1), vec3(1.3, .5, .3), dot(sin(p*3. - cos(p.yx*3.)), vec2(.25)) + .5);\n    cellCol = mix(col1, col2, blink);\n    */\n        \n    #elif PALETTE==2\n    if(tri.cID.x == 1. || tri.cID.x == 3.) cellCol = grey(cellCol);\n    #elif PALETTE==3\n    cellCol = grey(cellCol);\n    #endif\n    \n    // The triangle cell background.\n    // Mixing in a bit of the edge color with the cell color to give the impression that some mild lighting \n    // is occurring.\n    vec3 bg = mix(cellCol, vec3(1, .9, .7), .25);\n    // Mutliplying by a factor of the triangular distance for a bit of shading.\n    bg *= (triDist*.7 + .3)*1.55;\n    \n    // Start the layering process by initating to the triangle cell background.\n    vec3 col = bg;\n    \n        \n    // Cell background lines: Apologies for the compiler directive mess below. :) Basically, I wanted\n    // a triangle pattern in the colored triangles and diagonal hash lines in the greyscale ones.\n    #if PALETTE==1 || PALETTE==3\n    //float str = clamp(sin((rot2(tri.id.x)*p).x*6.283*20.)*1.5 + 1.35, 0., 1.); // Cell rotated lines.\n    #if PALETTE==1\n    float str = clamp(sin((triDist)*6.283*16.)*1.5 + 1.25, 0., 1.); // Triangle lines.\n    #else\n    float str = clamp(sin((p.y - p.x)*6.283*14.)*1.5 + 1.35, 0., 1.);\n    str = max(str, hash21(floor((p)*96.)) - .35);\n    #endif\n    col *= str*.35 + .65; // Diagonal lines.\n    #else\n    float str;\n    #if PALETTE==0\n    if(hash21(tri.id)<=.25)\n    #elif PALETTE==2\n    if(tri.cID.x == 0. || tri.cID.x == 2.)\n    #endif\n        str = clamp(sin((triDist)*6.283*16.)*1.5 + 1.25, 0., 1.); // Triangle lines.\n    else {\n        str = clamp(sin((p.y - p.x)*6.283*14.)*1.5 + 1.35, 0., 1.);\n        str = max(str, hash21(floor((p)*96.)) - .35);\n    }\n    col *= str*.35 + .65; // Diagonal lines.\n    #endif\n     \n  \n    \n \n////    \n    \n    // BOTTOM TRIANGLE LINES    \n \n    vec3 lCol = vec3(1, .8, .6); // Line color.\n    #ifdef GREY_LINES \n    lCol = grey(lCol);\n    #endif\n    \n    // Layering order flags to determine whether to render a particular triangle line under the Voronoi line,\n    // or over the top. It took me ages to come up with -- then convince myself -- of this logic: The line \n    // consists of two half edges; The actual triangle edge, and the same shared edge from the neighboring \n    // triangle. The sum of the two point IDs describing the shared edge will be the same for each side of the edge, \n    // which makes it a unique identifier... OK, I'm getting confused again... but it works anyway. :D\n    bool lineFirst[3];\n    lineFirst[2] = hash21(tri.lID[0] + tri.lID[2])>.5? true : false; // Diagonal rendering.\n    lineFirst[1] = hash21(tri.nID[0] + tri.nID[2])>.5? true : false; // Vertical (left\\right) rendering.\n    lineFirst[0] = hash21(tri.mID[0] + tri.mID[2])>.5? true : false; // Horizonal (top\\bottom) rendering.\n     \n    \n    \n    \n    vec2 p0 = vec2(0), p1 = vec2(0);\n    float d = 1e8;\n     \n    // Triangle line logic.\n    if(lineID == 2.) { // Diagonal edge line.\n        \n        // lCol =  lCol.zyx;  // Debug line color.        \n        if(lineFirst[2]){ d = d2; p0 = tri.p0; p1 = tri.p2; }\n        \n    }\n    else if(lineID == 1.){ // Vertical edge line.\n        \n        // lCol =  lCol.xzy;  // Debug line color.        \n        if(lineFirst[1]){ d = d1; p0 = tri.n; p1 = tri.n2; }\n \n    }\n    else { // Horizontal edge line.\n        \n        // lCol =  lCol.zxy;  // Debug line color.        \n        if(lineFirst[0]){ d = d0; p0 = tri.m; p1 = tri.m2; }\n        \n    }\n    \n    // Rendering the triangle lines.\n    const float lw = .03;\n    float lns = linePattern(p, p0, p1);\n    float shade = clamp(1. - d*4., 0., 1.)*.75 + clamp(d*32., 0., 1.)*.4;        \n    d -= lw;\n    col = mix(col, vec3(0), (1. - smoothstep(0., .1, d - .01))*.65);\n    col = mix(col, vec3(0), 1. - smoothstep(0., .015, d - .0225));\n    col = mix(col, lCol*lns*shade*.9, 1. - smoothstep(0., .015, d));\n    col = mix(col, vec3(0), (1. - smoothstep(0., .015, d + .025))*.5);\n     \n     \n    // VORONOI EDGES AND VERTICES\n    \n    float vorDist = 1e8;//tri.circ;// - length(cC - tri.p0);\n    \n    \n    // The lines connecting the circumcenter of the hit triangle to the circumcenters of the three \n    // neighboring triangles. These represent Voronoi edges. Normally, you'd need just these three, \n    // but sometimes a triangle's circumcenter will fall outside the triangle, meaning we have to\n    // render some extra lines. See below.\n    vorDist = min(vorDist, distLine(cC, cC0));\n    vorDist = min(vorDist, distLine(cC, cC1));\n    vorDist = min(vorDist, distLine(cC, cC2));\n\n    // Opposite bisecting sides of the diagonally opposite neighboring triangle... Don't worry. That confuses\n    // me as well, and I wrote it. :D Seriously, just comment out any of the pairs of lines below to see \n    // what they connect, and why they're necessary.\n    vorDist = min(vorDist, distLine(cC0, (tri.l + tri.l1)/2.));\n    vorDist = min(vorDist, distLine(cC0, (tri.l1 + tri.l2)/2.));\n    \n    // Opposite bisecting sides of the top or bottom neighboring triangle.\n    vorDist = min(vorDist, distLine(cC1, (tri.m + tri.m1)/2.));\n    vorDist = min(vorDist, distLine(cC1, (tri.m1 + tri.m2)/2.));\n    \n    // Opposite bisecting sides of the left or right neighboring triangle.\n    vorDist = min(vorDist, distLine(cC2, (tri.n + tri.n1)/2.));\n    vorDist = min(vorDist, distLine(cC2, (tri.n1 + tri.n2)/2.));\n        \n    \n    // Rendering the Voronoi lines.\n    vec3 vorCol = vec3(1, .9, .8);\n    // Dark strip shading.\n    float vShade = clamp(vorDist*40. - .5, 0., 1.);\n    // Alternate light strip shading.\n    //float vShade = clamp(1. - vorDist*8., 0., 1.)*.75 + clamp(.0 + vorDist*32., 0., 1.)*.5;//clamp(vorDist*32. + .5, 0., 1.);\n    vorDist -= .035;\n    col = mix(col, vec3(0), (1. - smoothstep(0., .1, vorDist - .01))*.65);\n    col = mix(col, vec3(0), 1. - smoothstep(0., .015, vorDist - .02));\n    col = mix(col, vorCol*vShade, 1. - smoothstep(0., .015, vorDist));\n    \n    \n    // Individual Voronoi edge vertices.    \n    float verts = 1e8;\n    const float vw = .06; \n    float vertcC = min(verts, length(cC)) - vw;\n    float vert0 = min(verts, length(cC0)) - vw;\n    float vert1 = min(verts, length(cC1)) - vw;\n    float vert2 = min(verts, length(cC2)) - vw;\n    \n \n    // Rendering the Voronoi edge end-point vertices.\n    vec3 vertCol = vec3(1, .96, .92);//vec3(.85, .92, 1)\n    float vertSh = min(min(vertcC, vert0), min(vert1, vert2));\n    col = mix(col, vec3(0), (1. - smoothstep(0., .1, vertSh - .01))*.75);\n     \n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, vert2 - .02));\n    col = mix(col, vertCol, 1. - smoothstep(0., .01, vert2));\n    vert2 += .05;\n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, vert2 - .02));\n\tcol = mix(col, vec3(1, .9, .7), 1. - smoothstep(0., .01, vert2));\n    \n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, vert1 - .02));\n    col = mix(col, vertCol, 1. - smoothstep(0., .01, vert1));\n    vert1 += .05;\n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, vert1 - .02));\n\tcol = mix(col, vec3(1, .9, .7), 1. - smoothstep(0., .01, vert1));\n    \n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, vert0 - .02));\n    col = mix(col, vertCol, 1. - smoothstep(0., .01, vert0));\n    vert0 += .05;\n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, vert0 - .02));\n\tcol = mix(col, vec3(1, .9, .7), 1. - smoothstep(0., .01, vert0));\n    \n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, vertcC - .02));\n    col = mix(col, vertCol, 1. - smoothstep(0., .01, vertcC));\n    vertcC += .05;\n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, vertcC - .02));\n\tcol = mix(col, vec3(1, .9, .7), 1. - smoothstep(0., .01, vertcC));\n    \n    \n    \n    \n   \n    \n    \n    \n    \n    // TOP TRIANGLE LINES     \n    \n    // Triangle line logic.\n    p0 = vec2(0), p1 = vec2(0);\n    d = 1e8;\n     \n    if(lineID == 2.) { // Diagonal edge line.\n        \n        // lCol =  lCol.zyx;  // Debug line color.        \n        if(!lineFirst[2]){ d = d2; p0 = tri.p0; p1 = tri.p2; }\n        \n    }\n    else if(lineID == 1.){ // Vertical edge line.\n        \n        // lCol =  lCol.xzy;  // Debug line color.        \n        if(!lineFirst[1]){ d = d1; p0 = tri.n; p1 = tri.n2; }\n \n    }\n    else { // Horizontal edge line.\n        \n        // lCol =  lCol.zxy;  // Debug line color.        \n        if(!lineFirst[0]){ d = d0; p0 = tri.m; p1 = tri.m2; }\n        \n    }\n    \n    // Rendering the triangle lines.\n    lns = linePattern(p, p0, p1);\n    shade = clamp(1. - d*4., 0., 1.)*.75 + clamp(d*32., 0., 1.)*.4;        \n    d -= lw;\n    col = mix(col, vec3(0), (1. - smoothstep(0., .1, d - .02))*.65);\n    col = mix(col, vec3(0), 1. - smoothstep(0., .015, d - .0225));\n    col = mix(col, lCol*lns*shade, 1. - smoothstep(0., .015, d));\n    col = mix(col, vec3(0), (1. - smoothstep(0., .015, d + .025))*.5);  \n    \n      \n    // Triangle vertices.\n    vertCol = vec3(1, .9, .75);//vec3(.85, .92, 1)\n    float tVerts = min(min(length(tri.p0), length(tri.p1)), length(tri.p2));\n    shade = 1.;//clamp(1.1 - tVerts*4., 0., 1.);\n    tVerts -= .09;\n    //verts = tri.verts - .04;\n    col = mix(col, vec3(0), (1. - smoothstep(0., .1, tVerts - .01))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, tVerts - .02));\n\tcol = mix(col, vertCol*shade, 1. - smoothstep(0., .01, tVerts));//vec3(1, .9, .7)\n    \n    tVerts += .06;\n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, tVerts - .02));\n\tcol = mix(col, vec3(1, .8, .6)*.75, 1. - smoothstep(0., .01, tVerts)); \n    \n    tVerts += .02;\n\tcol = mix(col, vec3(0), (1. - smoothstep(0., .01, tVerts))*.7); \n    \n\n  \n    // SQUARE GRID\n    //\n    // Square grid -- for a visual guide.\n    #ifdef SHOW_GRID_CELLS\n    // Cell borders: If you take a look at the triangles overlapping any individual square cell, \n    // you'll see that several partial triangles contribute, and the vertices that make up each \n    // triangle span the 8 surrounding cells. This is the reason why you have to test for\n    // contributing triangle intersections from all 9 cells.\n    vec2 q = abs(fract(p) - .5);\n    float bord = max(q.x, q.y) - .5;\n    bord = max(bord, -(bord + .008));\n    \n    col = mix(col, vec3(0), (1. - smoothstep(0., .1, bord - .01))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., .01, bord - .015)));\n    col = mix(col, vec3(.8, .9, 1), (1. - smoothstep(0., .01, bord))*1.);\n    #endif     \n    \n    \n    // POSTPROCESSING AND SCREEN PRESENTATION \n     \n    // Vignette.\n    uv = fragCoord/iResolution.xy;\n    col = mix(col*1.05, vec3(0), (1. - pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.125)));\n\n    \n    // Rough gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}