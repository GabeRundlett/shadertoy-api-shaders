{
    "Shader": {
        "info": {
            "date": "1597570058",
            "description": "One more day.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lXBDB",
            "likes": 4,
            "name": "#847 - Daily Experiments",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "experiment",
                "daily"
            ],
            "usePreview": 0,
            "username": "sixclones",
            "viewed": 215
        },
        "renderpass": [
            {
                "code": "// =========\n// CONSTANTS\n// =========\n\n#define QP 0.785398163397448\n#define TRP 1.047197551196598\n#define HP 1.570796326794897\n#define P 3.141592653589793\n#define TP 6.283185307179586\n\n#define t iTime\n#define ht 0.5 * t\n#define tt 0.1 * t\n\n#define EPS 0.001\n#define STEPS 64.0\n#define DIST 0.05\n\n#define S(a, b, t) smoothstep(a, b, t)\n\n// ========\n// UTILS FN\n// ========\n\n/* map a value `n` from a range `start1` -> `stop1` to a range `start2` -> `stop2` */\nfloat map(float n, float start1, float stop1, float start2, float stop2) {\n  return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n}\n\n/* map a value `n` from the range -1.0 -> 1.0 to a range `start2` -> `stop2`\n  to be used with cos/sin\n  e.g.: `map01(sin(x), 0.0, 1.0)` */\nfloat map01(float n, float start2, float stop2) {\n  return (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\n// classical 2d rotation\nvec2 rotate2d(vec2 uv, float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a)) * uv;\n}\n\n// =====\n// SCENE\n// =====\n\n/* scene definition\n  mainly defining a plane deformed to be a wave */\nfloat sceneSDF(vec3 p) {\n  // distance from the point `p` to the center of the XZ plane\n  float d = length(p.xz);\n    \n  // amplitude of the wave (height), smoothly decreased relatively to the center of the plane\n  float amp = S(25.0, 0.0, d);\n  \n  // offset of the frequency, based on the `z` coord of the plane\n  float offset = sin(-t + 0.1 * (p.z));\n  // frequency of the wave\n  float freq = map(\n    S(0.125, 0.875, abs(2.0 * fract((t + offset) / TP) - 1.0)),\n    0.0, 1.0, 0.4, 1.0\n  );\n   \n  /* main equation of the render\n\tcombination of some cos/sin based of `d`, `p.x` and `p.z`\n  */\n  float wave = amp * cos(-t\n    + freq * d\n    + sin(2.0 * t)\n    - 0.5 * cos(-2.0 * t + 0.25 * d)\n    + 0.5 * cos(t + 0.1 * TP * p.x)\n    + 0.25 * sin(-t + 0.125 * TP * p.z)\n  );\n  // sdf of a horizontal plane deformed by a wave\n  float plane = p.y + wave;\n  \n  return plane;\n}\n\n// ======\n// RENDER\n// ======\n\n/* compute normales by an estimation of them, offseting the scene computation\n  more details reading here:\n  http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting */\nvec3 computeNormal(vec3 p) {\n  float center = sceneSDF(p);\n  vec3 offset = vec3(0.0, EPS, 0.0);\n\n  return normalize(vec3(\n    center - sceneSDF(p + offset.yxx),\n    center - sceneSDF(p + offset.xyx),\n    center - sceneSDF(p + offset.xxy)\n  ));\n}\n\n/* compute surface of the object, combining normales, light, ambient etc. */\nvec3 computeSurface(vec3 pos, float f) {\n  vec3 normal = computeNormal(pos);\n\n  vec3 lightPos = vec3(2.5, -25.0, 25.0 * sin(t + 0.05 * (pos.x + pos.z)));\n  float light = max(0.0, dot(normal, lightPos));\n\n  vec3 ambient = vec3(0.2078, 0.2, 0.7725);\n\n  float fog = 5.0 / pow(f, 2.0);\n\n  return vec3(fog * light) + ambient;\n}\n\n// =====\n// MAIN\n// =====\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n  vec3 color = vec3(0.0);\n\n  vec3 rd = normalize((vec3(uv, 1.0)));\n  vec3 ro = vec3(0.0, 0.0, -25.0);\n\n  // rotate camera\n  float angle = map01(sin(t + P * uv.y), 0.75, 1.25) * -QP;\n  rd.yz = rotate2d(rd.yz, angle);\n  ro.yz = rotate2d(ro.yz, angle);\n\n  // raymarching loop\n  float f = 10.0 / STEPS;\n  for (float i = 0.0; i < STEPS; i++) {\n    vec3 pos = ro + f * rd;\n    float scene = sceneSDF(pos);\n    if (scene < DIST) {\n      color = computeSurface(pos, f);\n      break;\n    }\n    f += scene;\n  }\n\n  fragColor = vec4(pow(color, vec3(1.0 / 2.2)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}