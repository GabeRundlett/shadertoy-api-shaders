{
    "Shader": {
        "info": {
            "date": "1594106838",
            "description": "Deep zoom into three different Julia sets using double-precision emulation - see source for activation.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtBcWz",
            "likes": 5,
            "name": "Julia Set Trillion-Fold Zoom",
            "published": 3,
            "tags": [
                "fractal",
                "precision",
                "double"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 324
        },
        "renderpass": [
            {
                "code": "// \"Julia Set Trillion-Fold Zoom\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Deep zoom into three different Julia sets using double-precision emulation -\n see below for activation.\n \n Background discussion appears in \"Mandelbrot Trillion-Fold Zoom\".\n\n Based on original mandelbrot version which was unsuccessful on Windows and had to be\n modified using additional \"fake\" variables to prevent optimizer from ignoring parentheses.\n All this should be unnecessary!\n\n Scale factor is shown (log of value).\n\n Please report success/failure and specify platform; works on linux/nvidia(binary) and\n linux/intel(mesa), but no access to other platforms where the problems may be more serious.\n If ok, I can use this technique in the earlier mandelbrot shader.\n*/\n\n#define DP_VERS  0   // NOTE: must change 0->1 for this to work (not by default) !!!\n\n#define AA       0   // set = 1 for antialiasing (recommended)\n\n#if 0\n#define VAR_ZERO min (nFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 HsvToRgb (vec3 c);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\n\nint nFrame;\nfloat nFrameF, scale, sclTarg, frmCyc;\nconst float pi = 3.1415927;\n\n#if DP_VERS\n\n#define REAL_BAD_FP 1   // set = 0 if the GLSL compiler behaves (else just get sp results), = 0 for linux\n#define LESS_BAD_FP 0   // set = 1 for linux: linux/nvidia(binary) and linux/intel(mesa), else = 0\n\n#define BAD_FP (REAL_BAD_FP || LESS_BAD_FP)\n\n#if LESS_BAD_FP\n\nfloat FFAdd (float a, float b) \n{\n  return mix (b, a + b, (a != 0.) ? 1. : 0.);\n}\n\nfloat FFSub (float a, float b)\n{\n  return mix (- b, a - b, (a != 0.) ? 1. : 0.);\n}\n\n#define FFSub2 FFSub\n\n#endif\n\n#if REAL_BAD_FP \n\nfloat nFrameF1, nFrameF2, nFrameF3;\n\n#define VAR_ZERO1 min (nFrameF1, 0.)  // following iq's suggestion\n#define VAR_ZERO2 min (nFrameF2, 0.)\n#define VAR_ZERO3 min (nFrameF3, 0.)\n\nfloat FFAdd (float a, float b) \n{\n  return mix (b, a + b, (a != 0.) ? 1. : VAR_ZERO1);\n}\n\nfloat FFSub (float a, float b)\n{\n  return mix (- b, a - b, (a != 0.) ? 1. : VAR_ZERO2);\n}\n\nfloat FFSub2 (float a, float b)\n{\n  return mix (- b, a - b, (a != 0.) ? 1. : VAR_ZERO3);\n}\n\n#endif\n\nvec2 DvFromF (float a)\n{\n  return vec2 (a, 0.);\n}\n\nvec2 DvAdd (vec2 va, vec2 vb)\n{\n  vec2 vc;\n  float t1, t2, e;\n#if ! BAD_FP\n  t1 = va.x + vb.x;\n  e = t1 - va.x;\n  t2 = ((vb.x - e) + (va.x - (t1 - e))) + va.y + vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - (vc.x - t1);\n#else\n  t1 = va.x + vb.x;\n  e = FFSub (t1, va.x);\n  t2 = FFAdd (FFSub (vb.x, e), va.x - FFSub2 (t1, e)) + va.y + vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - FFSub (vc.x, t1);\n#endif\n  return vc;\n}\n\nvec2 DvSub (vec2 va, vec2 vb)\n{\n  vec2 vc;\n  float t1, t2, e;\n#if ! BAD_FP\n  t1 = va.x - vb.x;\n  e = t1 - va.x;\n  t2 = ((- vb.x - e) + (va.x - (t1 - e))) + va.y - vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - (vc.x - t1);\n#else\n  t1 = va.x - vb.x;\n  e = FFSub (t1, va.x);\n  t2 = FFAdd (FFSub (- vb.x, e), va.x - FFSub2 (t1, e)) + va.y - vb.y;\n  vc.x = t1 - t2;\n  vc.y = t2 - FFSub (vc.x, t1);\n#endif\n  return vc;\n}\n\n#define DSPLIT 8193.\n\nvec2 DvMul (vec2 va, vec2 vb)\n{\n  vec2 vc;\n  float ma, mb, sa1, sa2, sb1, sb2, c1, c2, t, t1, t2, e;\n#if ! BAD_FP\n  ma = va.x * DSPLIT;\n  mb = vb.x * DSPLIT;\n  sa1 = ma - (ma - va.x);\n  sb1 = mb - (mb - vb.x);\n  sa2 = va.x - sa1;\n  sb2 = vb.x - sb1;\n  c1 = va.x * vb.x;\n  c2 = va.x * vb.y + va.y * vb.x;\n  t = (((sa1 * sb1 - c1) + sa1 * sb2) + sa2 * sb1) + sa2 * sb2;\n  t1 = c1 + c2;\n  e = t1 - c1;\n  t2 = ((c2 - e) + (c1 - (t1 - e))) + t + va.y * vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - (vc.x - t1);\n#else\n  ma = va.x * DSPLIT;\n  mb = vb.x * DSPLIT;\n  sa1 = - FFSub (FFSub2 (ma, va.x), ma);\n  sb1 = - FFSub (FFSub2 (mb, vb.x), mb);\n  sa2 = va.x - sa1;\n  sb2 = vb.x - sb1;\n  c1 = va.x * vb.x;\n  c2 = va.x * vb.y + va.y * vb.x;\n  t = (((sa1 * sb1 - c1) + sa1 * sb2) + sa2 * sb1) + sa2 * sb2;\n  t1 = c1 + c2;\n  e = FFSub (t1, c1);\n  t2 = FFAdd (FFSub (c2, e), c1 - FFSub2 (t1, e)) + t + va.y * vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - FFSub (vc.x, t1);\n#endif\n  return vc;\n}\n\n#endif // DP_VERS\n\nstruct JPar {\n#if DP_VERS\n  vec2 xJulv, yJulv, xMidv, yMidv;\n#else\n  float xJul, yJul, xMid, yMid;\n#endif\n};\n\nvec3 ShowScene (vec2 uv)\n{\n  JPar jPar, jPar1, jPar2, jPar3;\n  vec3 col;\n  float ns, jsTyp;\n#if DP_VERS\n  vec2 x, y, xx, yy, cx, cy, s;\n  float mm;\n#else\n  float x, y, xx, yy, cx, cy, s;\n#endif\n#if DP_VERS\n  mm = 4096. * 4096.;\n#endif\n  jPar1 = JPar (\n#if DP_VERS // (externally) converted values\n     vec2 (-2.9841080000e+06 / mm, 3.0644734555e-08), vec2 (-1.1053949000e+07 / mm, 3.6843623819e-08),\n     vec2 ( 1.1825392000e+07 / mm, 2.7743463415e-08), vec2 ( 1.0691197000e+07 / mm, 9.5534800071e-09)\n#else // original values (extra precision for conversion)\n     -1.7786666667e-01, -6.5886666667e-01, 7.0484831723e-01, 6.3724500896e-01\n#endif\n  );\n  jPar2 = JPar (\n#if DP_VERS\n     vec2 (-2.8856820000e+06 / mm, 5.0544738783e-08), vec2 (-1.0955523000e+07 / mm, 5.6743621801e-08),\n     vec2 ( 1.0162006000e+07 / mm, 3.3276162492e-08), vec2 ( 5.0303820000e+06 / mm, 3.6449204266e-08)\n#else\n     -1.7200000000e-01, -6.5300000000e-01, 6.0570279111e-01, 2.9983416864e-01\n#endif\n  );\n  jPar3 = JPar (\n#if DP_VERS\n     vec2 ( 2.7101420000e+06 / mm, 2.2351880596e-08), vec2 ( 9.9288270000e+06 / mm, 2.4957934830e-08),\n     vec2 (-3.0709070000e+06 / mm, 4.0579411109e-08), vec2 ( 6.7450760000e+06 / mm, 4.2139466805e-08)\n#else\n     1.6153707355e-01, 5.9180423133e-01, -1.8304028029e-01, 4.0203790110e-01\n#endif\n  );\n#if DP_VERS\n  const float nsMax = 4096.;\n#else\n  const float nsMax = 2048.;\n#endif\n  jsTyp = floor (mod (float (nFrame) / frmCyc, 3.));\n  if (jsTyp == 0.) jPar = jPar1;\n  else if (jsTyp == 1.) jPar = jPar2;\n  else jPar = jPar3;\n#if DP_VERS\n  x = DvAdd (DvMul (DvFromF (uv.x), DvFromF (scale)), jPar.xMidv);\n  y = DvAdd (DvMul (DvFromF (uv.y), DvFromF (scale)), jPar.yMidv);\n  cx = jPar.xJulv;\n  cy = jPar.yJulv;\n#else\n  x = uv.x * scale + jPar.xMid;\n  y = uv.y * scale + jPar.yMid;\n  cx = jPar.xJul;\n  cy = jPar.yJul;\n#endif\n  ns = 0.;\n  col = vec3 (0.);\n  for (float n = float (VAR_ZERO); n < nsMax; n ++) {\n    ++ ns;\n#if DP_VERS\n    xx = DvMul (x, x);\n    yy = DvMul (y, y);\n    y = DvMul (x, y);\n    y = DvAdd (DvAdd (y, y), cy);\n    x = DvAdd (DvSub (xx, yy), cx);\n    s = DvAdd (xx, yy);\n    if (s.x + s.y > 256. * 256.) break;\n#else\n    xx = x * x;\n    yy = y * y;\n    y = 2. * x * y + cy;\n    x = xx - yy + cx;\n    s = xx + yy;\n    if (s > 256. * 256.) break;\n#endif\n  }\n  if (ns < nsMax - 1.) {\n#if DP_VERS\n    ns -= log2 (log2 (s.x + s.y)) - 4.;\n#else\n    ns -= log2 (log2 (s)) - 4.;\n#endif\n    col = HsvToRgb (vec3 (mod (0.5 + ns / 512., 1.), 1., 1.));\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 col;\n  vec2 canvas, uv, uvv;\n  float asp, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  nFrame = iFrame;\n  asp = canvas.x / canvas.y;\n  nFrameF = float (nFrame);\n#if DP_VERS\n#if REAL_BAD_FP \n  nFrameF1 = float (nFrame + 1);\n  nFrameF2 = nFrameF1 - 0.1;\n  nFrameF3 = nFrameF1 - 0.2;\n#endif\n#endif\n  frmCyc = 4000.;\n#if DP_VERS\n  sclTarg = 1e-12;\n#else\n  sclTarg = 3e-6;\n#endif\n  scale = 4. * pow (sclTarg, SmoothBump (0.25, 0.75, 0.23, mod (nFrameF / frmCyc, 1.)));\n  if (abs (uv.x) < 1.) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n      col += (1. / naa) * ShowScene (uvv);\n    }\n  } else col = vec3 (0.82);\n  col = mix (col, vec3 (0., 0., 0.5), ShowInt (0.5 * uv - vec2 (0.4 * asp, -0.4),\n     vec2 (0.06 * asp, 0.05), 2., floor (1. - log2 (scale) / log2 (10.))));\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log2 (val) / log2 (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}