{
    "Shader": {
        "info": {
            "date": "1634048629",
            "description": "Testing rendering equations/camera setup/sdf construction/etc",
            "flags": 0,
            "hasliked": 0,
            "id": "7d3SWB",
            "likes": 8,
            "name": "Water Bottle Shape",
            "published": 3,
            "tags": [
                "renderer"
            ],
            "usePreview": 0,
            "username": "orangeflea215",
            "viewed": 338
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n\n#define SAMPLES 1\n#define ZERO (min(iFrame,0))\n\nfloat PI = 3.14159;\nint maxSteps = 256;\nfloat minStepSize = 0.0001;\nfloat e = .0001;\n\nfloat shadowBias = .005;\n\n//Point light\n//Intensity at distance of 1 unit\nfloat lInt = 10.0;\nvec3 lCol = vec3(0.2, 1.0, 0.0);\nvec3 lPos = vec3(-2.0, 2.0, -2.0);\n\n//Point light 2\n//Intensity at distance of 1 unit\nfloat lInt2 = 10.0;\nvec3 lCol2 = vec3(1.0, 0.2, 0.0);\nvec3 lPos2 = vec3(2.0, 2.0, -2.0);\n\n//Ambient light\nvec3 ambCol = vec3(0.2,0.2,0.2);\n\n//Camera\nfloat fov = 50.0 * 2.0 * 3.14159/360.0;\nvec3 camPos = vec3(0.0, 3.0, -9.0);\nvec3 camTar = vec3(0.0, 1.0, 0.0);\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//SDFs\n\n//Sphere\n\nfloat sphereSDF(float d, float r){\n    return d - r;\n}\n\n//Plane\nfloat planeSDF(vec3 d, float l, float w){\n    return max(abs(d.x) - w/2.0,0.0) + max(abs(d.z) - l/2.0,0.0) + abs(d.y);\n}\n\nfloat roundedCylinderSDF (vec3 p, float ra, float rb, float h){\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat cylinderSDF (vec3 p, float ra, float h){\n    vec2 d = vec2( length(p.xz)-2.0*ra, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\n//Map function\nvec3 map(vec3 pos){\n    vec3 result = vec3(10000000000.0,0.0,0.0);\n    float res = 0.0;\n    \n    //    //res = sphereSDF(length(pos - vec3(0.0,0.0,0.0)), 1.00);\n    res = roundedCylinderSDF(pos - vec3(0.0,-0.8,0.0), .3, .1, .05);\n    res = abs(res) -.01;\n    result.x = min(result.x, res);\n    if(res <= e){\n        \n        result.y = 3.0;\n    }\n    \n    //    //res = sphereSDF(length(pos - vec3(0.0,0.0,0.0)), 1.00);\n    res = roundedCylinderSDF(pos - vec3(0.0,-.5,0.0), .3, .1, .050);\n    res = abs(res) -.01;\n    result.x = min(result.x, res);\n    if(res <= e){\n        \n        result.y = 3.0;\n    }\n    \n    //    //res = sphereSDF(length(pos - vec3(0.0,0.0,0.0)), 1.00);\n    res = roundedCylinderSDF(pos - vec3(0.0,-.2,0.0), .3, .1, .050);\n    res = abs(res) -.01;\n    result.x = min(result.x, res);\n    if(res <= e){\n        \n        result.y = 3.0;\n    }\n    res = roundedCylinderSDF(pos - vec3(0.0,.1,0.0), .3, .1, .050);\n    res = abs(res) -.01;\n    result.x = min(result.x, res);\n    if(res <= e){\n        \n        result.y = 3.0;\n    }\n    \n    res = roundedCylinderSDF(pos - vec3(0.0,.4,0.0), .3, .1, .050);\n    res = abs(res) -.01;\n    result.x = min(result.x, res);\n    if(res <= e){\n        \n        result.y = 3.0;\n    }\n    \n    res = cylinderSDF(pos - vec3(0.0,1.0,0.0), .280, .550);\n    res = abs(res) - .01;\n    result.x = min(result.x, res);\n    if(res <= e){\n        \n        result.y = 3.0;\n    }\n    \n     \n   /* res = roundedCylinderSDF(pos - vec3(0.0,1.6,0.0), .3, .1, .050);\n    result.x = min(result.x, res);\n    if(res <= e){\n        \n        result.y = 1.0;\n    }\n    */\n    res = sdRoundCone(pos - vec3(0.0,1.70,0.0), .6, .4, .45);\n    res = abs(res) -.01;\n    result.x = min(result.x, res);\n    if(res <= e){\n        \n        result.y = 3.0;\n    }\n    \n    res = cylinderSDF(pos - vec3(0.0,2.55,0.0), .1250, .08);\n    res = abs(res) - .01;\n    result.x = min(result.x, res);\n    if(res <= e){\n        \n        result.y = 3.0;\n    }\n    res = cylinderSDF(pos - vec3(0.0,2.55,0.0), .120, .175);\n    //res = abs(res) - .01;\n    result.x = max(result.x, -res);\n    if(res <= e){\n        \n        result.y = 3.0;\n    }\n    \n    res = planeSDF(pos - vec3(0.0,-1.0, 0.0), 5.0, 5.0);\n    result.x = min(res, result.x);\n    if(res <= e){\n        result.y = 2.0;\n    }\n    \n    res = cylinderSDF(pos - vec3(0.0,.5,0.0), .275, 1.3);\n   // res = abs(res) - .01;\n    result.x = max(result.x, -res);\n    if(res <= e){\n        \n        result.y = 3.0;\n    }\n    \n    return result;\n}\n\n//Normals\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p, in float t )\n{\n#if 0    \n    float e = 0.00001*t;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n#else    \n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.0001*t).x;\n    }\n    return normalize(n);\n#endif    \n}\n\n//Raymarching function\n//Accepts ray origin and direction\n//Returns intersected position\nvec4 rayMarch(vec3 ro, vec3 rd, int steps){\n    if(steps == 0){\n        steps = maxSteps;\n    }\n    vec3 pos = ro;\n    float dist = (-1.0);\n    vec3 distRes = vec3(0.0,0.0,0.0);\n    for (int i = 0; i < steps; i++){\n        //run sdf\n        //step size is always half of distance\n        distRes = map(pos);\n        dist = distRes.x;\n\n        if(dist < e && dist > 0.0) {\n            pos = pos + rd * dist; \n            if(i < 5){\n            \n                distRes.y = 4.0;\n            \n            }\n            break;\n        }\n        else if(dist < 0.0){\n            \n        }\n        \n        if(dist < minStepSize){\n            dist = minStepSize;\n            \n        }\n        else{\n            dist = dist / 2.0;\n            \n            //return vec4(dist,0.0,0.0,0.0);\n        }\n        pos = pos + rd * dist;\n    }\n    \n    return vec4(pos, distRes.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    \n    float uvFocLen = 0.5 / tan(fov/2.0);\n    float scaleFac = 1.0/uvFocLen;\n    \n    vec2 uvFOV = (uv - vec2(0.5))*scaleFac;\n    \n    \n    vec3 camSpaceUVDir = normalize(vec3(uvFOV.x, uvFOV.y/aspect, 1.0));\n    \n    mat3 ca = setCamera(camPos, camTar, 0.0);\n    \n    vec3 rayDir = ca * camSpaceUVDir;\n    \n    vec4 res = rayMarch(camPos, rayDir, 0);\n    \n    vec3 col = vec3(0.0);\n    if(res.w > 0.0){\n    // Time varying pixel color\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n        \n        //Normal as color\n        vec3 normal = calcNormal(res.xyz, length(camPos - res.xyz));\n        col = normal;\n        \n        \n        \n        //Calculate light intensity given square falloff\n        float dist = length(lPos - res.xyz) ;\n        float pointInt = lInt / pow(max(dist, 1.0) , 2.0);\n        vec3 colInt = lCol * pointInt;\n        \n        \n        \n        //Shadow for light 1\n        vec3 shadRayDir = normalize(lPos - res.xyz);\n        vec4 shadRes = rayMarch(res.xyz - shadowBias * rayDir, shadRayDir, 0);\n        \n        if(shadRes.w > 0.0){\n            colInt = vec3(0.0,0.0,0.0);\n        }\n        \n        //Calculate specular light intensity\n        //Reflected ray for specular\n        vec3 reflRay = normalize(2.0 * dot(normal, shadRayDir) * normal * -1.0 + shadRayDir);\n        float reflInt = max(dot(reflRay, rayDir), 0.0);\n        \n        \n        //point light 2\n        float dist2 = length(lPos2 - res.xyz) ;\n        float pointInt2 = lInt2 / pow(max(dist2, 1.0) , 2.0);\n        vec3 colInt2 = lCol2 * pointInt2;\n        \n        //Shadow for light 2\n        shadRayDir = normalize(lPos2 - res.xyz);\n        shadRes = rayMarch(res.xyz - shadowBias * rayDir, shadRayDir, 0);\n\n        if(shadRes.w > 0.0){\n            colInt2 = vec3(0.0,0.0,0.0);\n        }\n        \n         //Calculate specular light intensity\n        //Reflected ray for specular\n        reflRay = normalize(2.0 * dot(normal, shadRayDir) * normal * -1.0 + shadRayDir);\n        float reflInt2 = max(dot(reflRay, rayDir),0.0);\n        \n       \n        vec3 surfCol = vec3(1.0,1.0,1.0);\n        \n        if(res.w == 4.0){\n            surfCol = vec3(0.0,1.0,0.0);\n        }\n        \n        if(res.w == 1.0){\n            \n            //Assume white sphere surface, for now\n            surfCol = vec3(1.0,1.0,1.0);\n        }\n        else if(res.w == 2.0){\n            //White ground plane\n            surfCol = vec3(1.0,1.0,1.0);\n        }\n        else if(res.w == 3.0){\n            //Compute Refraction\n            //Fraction of light reflected vs refracted given IOR -- lets try 1.45 for plastic bottle\n            //try 4 refractions\n            //loop -- have incident ray dir, normal, IOR -- don't worry about transparent shadows for now\n            //compute fraction of light reflected vs refracted\n            //compute specular light at each point, multiply by percent reflected\n            //for reflected light, multiply colInt and reflInt by amount reflected\n            //raymarch to next point, comput ray dir, normal, ior\n            //if ray count exceeded and no surface found, compute light at final point and exit\n           \n           surfCol = vec3(1.0,1.0,1.0);\n           vec3 calcCol = vec3(0.0,0.0,0.0);\n           float refrInd1 = 1.0;\n           float refrInd2 = 1.5;\n           \n           float reflFrac = 1.0;\n           float transFrac = 0.0;\n           \n           vec3 specRefInt = vec3(0.0);\n           \n           float cosAngle = dot(normal, -1.0 * rayDir);\n           float angle = acos(cosAngle);\n           \n           vec3 transDir = vec3(0.0,0.0,0.0);\n           float transPow = 1.0;\n           \n           vec4 resT = res;\n          \n           int numRefr = 6;\n           for (int j = 0; j < numRefr; j++){\n               \n               reflFrac = pow(abs( (refrInd1*cosAngle - refrInd2 * sqrt(1.0 - pow((refrInd1/refrInd2) * sin(angle), 2.0)))/(refrInd1*cosAngle + refrInd2 * sqrt(1.0 - pow((refrInd1/refrInd2) * sin(angle), 2.0)))), 2.0);\n               //reflFrac = 0.5 * (reflFrac + pow(abs( (-1.0*refrInd2*cosAngle + refrInd1 * sqrt(1.0 - pow((refrInd1/refrInd2) * sin(angle), 2.0)))/(refrInd2*cosAngle + refrInd1 * sqrt(1.0 - pow((refrInd1/refrInd2) * sin(angle), 2.0)))), 2.0));\n\n               //Use schlick instead\n              // float r0 = pow((refrInd1 - refrInd2)/(refrInd1 + refrInd2), 2.0);\n               //reflFrac = r0 + (1.0 - r0)*pow(1.0 - cosAngle, 5.0);\n              // reflFrac *= 1.0;\n               transFrac = 1.0 - reflFrac;\n               \n               specRefInt = surfCol * pow(reflInt, 5.0) * colInt * reflFrac;        \n               specRefInt += surfCol * pow(reflInt2,5.0) * colInt2 * reflFrac;\n               if(j == 0){\n                   specRefInt += surfCol * vec3(0.5,0.5,0.5) * reflFrac;\n               }\n               \n               calcCol += max(specRefInt * transPow, 0.0);\n               //calcCol = resT.xyz + vec3(0.0, 0.0,0.0);\n               //calcCol = transDir;\n              /* if(resT.w == 4.0){\n                   calcCol = vec3(1.0, 0.0,0.0);\n                   break;\n               }*/\n               \n               \n               \n               if(resT.w == 0.0){\n                  calcCol += transPow *  vec3(0.5,0.5,0.5);\n                 // calcCol = vec3(1.0);\n                  break;\n               }\n               \n               else if (resT.w == 2.0){\n                   //Compute diffuse\n                    vec3 difReflInt = surfCol * colInt * max(dot(normal, normalize(lPos - resT.xyz)), 0.0);\n                    difReflInt += surfCol * colInt2 * max(dot(normal, normalize(lPos2 - resT.xyz)), 0.0);\n                    calcCol += transPow * difReflInt;\n                    break;\n               }\n               \n               if(j == numRefr - 1){\n                   break;\n               }\n               transPow *= transFrac;\n               \n               //surfCol = surfCol * reflFrac;\n               transDir = normalize((refrInd1/refrInd2) * rayDir + ((refrInd1/refrInd2) * cosAngle - sqrt(1.0 - pow(refrInd1 / refrInd2, 2.0) * (1.0 - pow(cosAngle, 2.0)))) * normal);\n               //transDir = normalize(sqrt(1.0 - pow(refrInd1/refrInd2, 2.0) * (1.0 - pow(cosAngle, 2.0))) * normal + (refrInd1/refrInd2) * (rayDir - cosAngle * normal));\n              // transDir = (refrInd1/refrInd2) * (rayDir - cosAngle * normal)  + sqrt(1.0 - pow(length((refrInd1/refrInd2) * (rayDir - cosAngle * normal)), 2.0)) * normal;\n\n               vec3 oldPos = resT.xyz;\n               resT = rayMarch(resT.xyz + 80.0 * e * transDir, transDir,256);\n               \n               //Normal\n               normal = calcNormal(resT.xyz, length(camPos - resT.xyz));\n               //col = normal;\n\n                //Calculate light intensity given square falloff\n                dist = length(lPos - resT.xyz) ;\n                pointInt = lInt / pow(max(dist, 1.0) , 2.0);\n                colInt = lCol * pointInt;\n\n\n                //Calculate specular light intensity\n                //Reflected ray for specular\n                shadRayDir = normalize(lPos - resT.xyz);\n                reflRay = normalize(2.0 * dot(normal, shadRayDir) * normal * -1.0 + shadRayDir);\n                reflInt = max(dot(reflRay, transDir), 0.0);\n\n\n                //point light 2\n                dist2 = length(lPos2 - resT.xyz) ;\n                pointInt2 = lInt2 / pow(max(dist2, 1.0) , 2.0);\n                colInt2 = lCol2 * pointInt2;\n\n                 //Calculate specular light intensity\n                //Reflected ray for specular\n                shadRayDir = normalize(lPos2 - resT.xyz);\n                reflRay = normalize(2.0 * dot(normal, shadRayDir) * normal * -1.0 + shadRayDir);\n                reflInt2 = max(dot(reflRay, transDir),0.0);\n        \n                float temp = refrInd1;\n                refrInd1 = refrInd2;\n                refrInd2 = temp;\n                \n                float j_float = float(j);\n                normal *= 1.0 - 2.0 * mod(j_float + 1.0, 2.0);\n\n                cosAngle = dot(normal,-1.0 * transDir);\n                angle = acos(cosAngle);\n\n                rayDir = transDir;\n           }\n           \n           \n           col = calcCol * 1.0;\n           //col = vec3(1.0);\n           \n        }\n        \n        //BRDF\n        vec3 difReflInt = surfCol * colInt * max(dot(normal, normalize(lPos - res.xyz)), 0.0);\n        difReflInt += surfCol * colInt2 * max(dot(normal, normalize(lPos2 - res.xyz)), 0.0);\n        vec3 specRefInt = surfCol * pow(reflInt, 10.0) * colInt;        \n        specRefInt += surfCol * pow(reflInt2, 10.0) * colInt2;\n        if(res.w != 3.0){\n            col = surfCol * ambCol + 0.8 * difReflInt + 0.2 * specRefInt;\n            //col = vec3(1.0);\n        }\n        else{\n            //col += surfCol * ambCol;\n        }\n    }\n    else{\n        col = vec3(0.5,0.5,0.5);\n    }\n\n    //gamma\n    col = sqrt(col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}