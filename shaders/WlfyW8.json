{
    "Shader": {
        "info": {
            "date": "1591894320",
            "description": "just for the look, illustrates random dots in grid as used in 3D VoronoÃ¯ / Worley patterns.\nAnd shake them, because. :-)\n\nNote the plug-and-play shader antialiasing technics at the end.",
            "flags": 0,
            "hasliked": 0,
            "id": "WlfyW8",
            "likes": 22,
            "name": "rand dots in cubic grid",
            "published": 3,
            "tags": [
                "raymarching",
                "voronoi",
                "sdf",
                "antialiasing",
                "tuto",
                "short"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 690
        },
        "renderpass": [
            {
                "code": "#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))\nvoid mainImage0(out vec4 O, vec2 U) {\n    \n    float t=1.,s,C;\n    vec3  R = iResolution, \n          D = normalize(vec3(.2*(U+U-R.xy)/R.y, -1)), // ray direction\n          p = 30./R, T,a,f,q;                         // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 ) {\n        q = p, \n        q.yz *= rot(-.2),                             // rotations\n        q.xz *= rot(.3*iTime),\n        T = q,                                      \n        a = abs(T), C = max(a.x,max(a.y,a.z))-4.03;   // big cube\n        if (C>.2) t = C; else                         // BBox ( omment to compare perfs )\n        {                                             // --- tubes\n          q = mod(q+1.,2.)-1.,                        // 3D tiling (staggered compare to cube)\n          t = min(length(q.xy),                       // cylinders in 3 directions\n              min(length(q.yz),                       // ( cross at middle of cells )\n                  length(q.xz)))-.03,\n                                                      // --- balls\n          f = fract(4e5*sin(ceil(T/2.)*mat3(R,R.zxy,-R.yzx))), // random seed per cell\n          f *= .95+.05*sin(iTime*40.+63.*f.y),        // shake\n       // f *= sin(iTime*5.+63.*f.y),                 // shake variant\n          q = mod(T,2.)-1.,                           // now consider stagered cells (small cubes)\n          t = min( t, s = length(1.4*f-.7 - q) -.2 ), // red ball at random pos\n\n          t = max( t, C );                            // --- intersection with big cube\n        }\n        p += t*D;                                     // step forward = dist to obj\n    }\n    s==t ? O.gba *= 0. : R ;                          // paint red balls\n}\n\n// Antialiasing \"module\" by FabriceNeyret2 https://www.shadertoy.com/view/WlfyW8\n#define AA 2 // antialiasing level ( AA*AA subsamples )\nvoid mainImage(out vec4 O, vec2 U) {\n    vec4 T;  O=vec4(0);                                          \n    for (int k=0; k<AA*AA; k++, O+=T)                  \n        mainImage0(T,U+.33*vec2(k%AA-AA/2,k/AA-AA/2));  \n    O /= float(AA*AA);\n}        \n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}