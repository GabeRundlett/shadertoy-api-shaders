{
    "Shader": {
        "info": {
            "date": "1559659165",
            "description": "yeah",
            "flags": 0,
            "hasliked": 0,
            "id": "tt23WW",
            "likes": 3,
            "name": "line distance",
            "published": 3,
            "tags": [
                "bl"
            ],
            "usePreview": 0,
            "username": "Imsure1200q_1UWE130",
            "viewed": 1886
        },
        "renderpass": [
            {
                "code": "#define squv *= iResolution.x/iResolution.y;\n/*\nfloat map( float a, float a1, float a2, float b1, float b2 ) {\n    return (a - a1) / (a2 - a1) * (b2 - b1) + b1;\n}\n*/\n\nfloat dline( vec2 p, vec2 a, vec2 b ) {\n    \n    //vec2 mx = mix(a, b, clamp( map(p.x, a.x, b.x, 0., 1.), 0., 1. ) );\n    //vec2 my = mix(a, b, clamp( map(p.y, a.y, b.y, 0., 1.), 0., 1. ) );\n    \n    //return min(distance(mx, p),distance(my, p));\n    \n    \n    //v2\n    //float den = distance(a, b);\n    //float num = abs( (b.y-a.y)*p.x - (b.x-a.x)*p.y + b.x*a.y - b.y*a.x );\n    \n    //float d = num / den;\n    \n    //return d;\n    \n    //v3\n    \n    /*\nhttps://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\nfloat minimum_distance(vec2 v, vec2 w, vec2 p) {\n  // Return minimum distance between line segment vw and point p\n  const float l2 = length_squared(v, w);  // i.e. |w-v|^2 -  avoid a sqrt\n  if (l2 == 0.0) return distance(p, v);   // v == w case\n  // Consider the line extending the segment, parameterized as v + t (w - v).\n  // We find projection of point p onto the line. \n  // It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  // We clamp t from [0,1] to handle points outside the segment vw.\n  const float t = max(0, min(1, dot(p - v, w - v) / l2));\n  const vec2 projection = v + t * (w - v);  // Projection falls on the segment\n  return distance(p, projection);\n}\n\n\t*/\n    \n    vec2 v = a, w = b;\n    \n    float l2 = pow(distance(w, v), 2.);\n    if(l2 == 0.0) return distance(p, v);\n    \n    float t = clamp(dot(p - v, w - v) / l2, 0., 1.);\n    vec2 j = v + t * (w - v);\n    \n    return distance(p, j);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    \n    mo.x squv uv.x squv\n\n    // Time varying pixel color\n    ///vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(pow(sin(dline( uv, vec2(0.1), mo )*64.)/2.+0.5, 0.09));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}