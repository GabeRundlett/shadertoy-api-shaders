{
    "Shader": {
        "info": {
            "date": "1682920472",
            "description": "A degenerate torus is a double covered sphere.\nSo a degenerate donut is a double covered iced sphere.\n\nAlso see https://www.shadertoy.com/view/mt3Gzl",
            "flags": 64,
            "hasliked": 0,
            "id": "mtcGzl",
            "likes": 9,
            "name": "Degenerate Donut",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "subsurfacescattering",
                "sss",
                "ray",
                "volume",
                "torus",
                "volumetric",
                "raymarcher",
                "scattering",
                "subsurface",
                "surface",
                "scatter",
                "blender"
            ],
            "usePreview": 0,
            "username": "bub",
            "viewed": 238
        },
        "renderpass": [
            {
                "code": "//██████╗░░█████╗░███╗░░██╗██╗░░░██╗████████╗  ██╗\n//██╔══██╗██╔══██╗████╗░██║██║░░░██║╚══██╔══╝  ██║\n//██║░░██║██║░░██║██╔██╗██║██║░░░██║░░░██║░░░  ██║\n//██║░░██║██║░░██║██║╚████║██║░░░██║░░░██║░░░  ╚═╝\n//██████╔╝╚█████╔╝██║░╚███║╚██████╔╝░░░██║░░░  ██╗\n//╚═════╝░░╚════╝░╚═╝░░╚══╝░╚═════╝░░░░╚═╝░░░  ╚═╝\n\n// wich one do you prefer?\n// inspired by Blender Guru: https://www.youtube.com/@blenderguruofficial\n// move the mouse to rotate the donut\n\n//////////////\n//          //\n// SETTINGS //\n//          //\n//////////////\n\n// donut with ice\n//#define FROZEN_DONUT\n// just the materials color\n//#define MATERIAL_PREVIEW\n\n// antialiasing, icrease it if you have a fast computer\n#define AA 2\n// comment this if you want a concrete donut\n#define SUB_SURFACE_SCATTERING\n// sharpness of the shadows\n#define SHADOW_SHARPNESS 7.\n// pi\n#define PI 3.141592\n\n\n//////////////////////\n//                  //\n// USEFUL FUNCTIONS //\n//                  //\n//////////////////////\n\n\n// ray sphere intersection\n// tnanks to iq: https://iquilezles.org/articles/intersectors/\nvec2 sphIntersect(vec3 ro, vec3 rd, float ra) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - ra*ra;\n    float h = b*b - c;\n    if(h<0.) return vec2(-1); // no intersection\n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}\n\n// rotation function\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a); // sine and cosine\n    return mat2(c, -s, s, c);\n}\n\n// generate a random value\nfloat hash(float n) {return fract(sin(n)*43758.5453123);}\n\n// noise function by iq\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.-2.*f); // S curve\n\n    float n = p.x + p.y*157. + 113.*p.z;\n\n    return mix(mix(mix(hash(n+  0.), hash(n+  1.),f.x),\n                   mix(hash(n+157.), hash(n+158.),f.x),f.y),\n               mix(mix(hash(n+113.), hash(n+114.),f.x),\n                   mix(hash(n+270.), hash(n+271.),f.x),f.y),f.z);\n}\n\n// fractal noise\nfloat fbm(vec3 p) {\n    float f = 0.;\n    f += .5*noise(p);\n    f += .25*noise(2.*p);\n    f += .125*noise(4.*p);\n    return f;\n}\n\n// sphere sdf\nfloat sdSphere(vec3 p, float r) {\n    return length(p)-r;\n}\n\n// torus sdf\nfloat sdTorus(vec3 p, float r1, float r2) {\n    vec2 q = vec2(length(p.xz)-r1, p.y);\n    return length(q)-r2;\n}\n\n// union of two objects\nvec2 opU(vec2 a, vec2 b) {\n    return a.x<b.x ? a : b;\n}\n\n// smooth minimum\n// thanks to iq: https://iquilezles.org/articles/smin/\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5+.5*(b-a)/k, 0., 1.);\n\treturn mix(b, a, h) - k*h*(1.-h);\n}\n\n\n///////////////\n//           //\n// MODELLING //\n//           //\n///////////////\n\n\n// materials idx\n#define MAT_DONUT 0.\n#define MAT_ICING 1.\n#define MAT_SPRINKLES 2.\n\n// polar coorninates\nvec3 polarCoords(vec3 p, float an, out float sector) {\n    an = 2.*PI/an;\n    sector = round(atan(p.z, p.x)/an);\n    p.zx *= rot(sector*an);\n    return p;\n}\n\n// scene\nvec2 map(vec3 p) {\n    vec2 d = vec2(1e10); // big number\n             float size = 0.2;\n           float idk = 1.0;  \n    float majorRadius = idk*size + idk*size*sin(iTime); //major radius\n            \n    // rotate the point\n    p.xz *= rot(.75*PI);\n    p.yz *= rot(.3*PI);\n    \n    // displacement\n    float f = sin(20.*p.x)*sin(20.*p.y)*sin(20.*p.z);\n    // radius of the torus\n    float r = .24-.01*sin(16.*p.y+8.); // this sinus makes the donut less round\n    // donut\n    d = opU(d, vec2(sdTorus(p, majorRadius, r)-.005*f, MAT_DONUT));\n    \n    // icing\n    float i = sdTorus(p, majorRadius, r+.05)-.0035*f;\n    \n    // woobles\n    float an = atan(p.x,p.z); // horizontal axis of the polar coordinates\n    float h = sin(10.*an)*.028;\n    h += .009*sin(24.*an+3.);\n    h *= dot(p.xz, p.xz); // attenuate the wobbles in the hole of the donut\n    i = smin(i, h-p.y, -.06); // cut of the icing\n\n    d = opU(d, vec2(i,MAT_ICING));\n    d.x *= .8; // make the step size smaller\n\n    return d;\n}\n\n\n///////////////\n//           //\n// RENDERING //\n//           //\n///////////////\n\n\n// raymarching loop\n// return the distance and material idx\nvec2 intersect(vec3 ro, vec3 rd, float tmin, float tmax) {\n    float t = tmin;\n    for (int i=0; i<256 && t<tmax; i++) {\n        vec3 p = ro + rd*t; // point\n        \n        vec2 h = map(p); // distance to the scene and material idx\n        if (h.x<.001) return vec2(t,h.y); // we hit the surface!\n        t += h.x; // march\n    }\n    return vec2(-1); // no intersection\n}\n\n// normal estimation\nvec3 calcNormal(vec3 p) {\n    float h = map(p).x;\n    const vec2 e = vec2(.0001,0);\n    \n    return normalize(h - vec3(map(p-e.xyy).x,\n                              map(p-e.yxy).x,\n                              map(p-e.yyx).x));\n}\n\n// soft shadow function\n// thanks to iq: https://iquilezles.org/articles/rmshadows/\n// k is the softness of the shadow\nfloat shadow(vec3 ro, vec3 rd, float tmax, float k) {\n    float res = 1.;\n    for (float t=.005; t<tmax;) {\n        vec3 p = ro + rd*t;\n        \n        float h = map(p).x+.004; // offset to see better the sss\n        if (h<.001) return 0.;\n        res = min(res, k*h/t);\n        t += h;\n    }\n    return res*res*(3.-2.*res); // S curve\n}\n\n// ambient occlusion function\n// k is the radius of AO\nfloat calcAO(vec3 p, vec3 n, float k) {\n    float res = clamp(.5+.5*map(p + n*k).x/k,0.,1.);\n    return res*res*(3.-2.*res); // S curve\n}\n\n// subsurface scattering function\n// thanks to iq: https://www.shadertoy.com/view/llXBWn\n// I used his function but I added small modifications\n// ra is the radius of the subsurface\n// sca is the scattered color under the surface\nvec3 calcSSS(vec3 p, vec3 n, vec3 lig, float ra, vec3 sca) {\n    float dif = dot(n, lig); // diffuse light\n    \n    float pdif = clamp(dif,0.,1.); // positive diffuse\n    float ndif = clamp(-dif,0.,1.); // negative diffuse\n    vec3 sha = vec3(1)*shadow(p, lig, 1., SHADOW_SHARPNESS); // shadow\n    sha = pow(sha, 1./sqrt(sca)); // ading sss also on the shadow\n\n    vec3 col = vec3(0);\n    col += pdif*sha; // diffuse light\n    // aproximation of the scattered light under the surface\n    col += sha*.2*sca*ra*(1.-ndif)*(1.-ndif)*pow(1.-ndif,3./ra);\n        \n    return col;\n}\n\n// rendering function\nvec3 render(vec3 ro, vec3 rd, vec2 uv) {\n    // transition\n    float tr = step(.5,fract((uv.x+uv.y+.05*sin(26.*uv.x))*.1+.1*iTime));\n    \n    // background\n    float stripes = step(0., sin(10.*uv.y+sin(10.*uv.x)+iTime));\n    vec3 pink = mix(vec3(1,.23,.52), vec3(1,.36,.7), stripes);\n    vec3 brown = vec3(.022,.014,.011)*(.5+.5*stripes);\n    vec3 col = mix(pink, brown, tr);\n        \n    // light direction\n    vec3 lig = normalize(vec3(-2,2,-2));\n    \n    // bounding volume\n    vec2 bound = sphIntersect(ro, rd, .81);\n    vec2 tm = vec2(-1);\n    if (bound.x>0.) { // we hit the sphere\n        tm = intersect(ro, rd, bound.x, bound.y); // distance and material idx\n    }\n    float t = tm.x;\n        \n    if (t>0.) { // we hit the surface!\n    \n        // lighting and coloring\n        \n        vec3 p = ro + rd*t; // hit point\n        vec3 n = calcNormal(p); // surface normal\n        vec3 r = reflect(rd, n); // reflected vector\n        \n        // ambient occlusion\n        float occ = 1.;\n        for (int i=0; i<4; i++) {\n            occ *= calcAO(p, n, float(i+1)*.03);\n        }\n        occ *= calcAO(p, n, .5);\n        \n        float dif = clamp(dot(n, lig), 0., 1.); // diffuse light\n        float sha = shadow(p, lig, 1., 8.); // soft shadow\n        float spe = clamp(dot(r, lig), 0., 1.); // specular light\n        float fre = 1.+dot(rd, n); // fresnel\n             \n        vec3 mat, sca, sss; // material sss scatter and sss (diffuse+shadow+sss)\n        col = vec3(0);\n        // some very ugly code, i'm to lazy to make it better\n        if (tm.y == MAT_DONUT) { // donut\n            mat = vec3(1,.55,.3);\n            sca = mat;\n            sss = calcSSS(p, n, lig, .5, sca);\n            fre = .1*pow(fre,1.5);\n            spe = 0.;\n        } else if (tm.y == MAT_ICING) { // icing\n            mat = mix(vec3(1,.3,.8), vec3(1,.72,.55), tr);\n            sca = mat*mix(vec3(1,.8,.3), vec3(1,.55,.55), tr);\n            sss = calcSSS(p, n, lig, .4, sca);\n            \n            fre = .4*pow(fre,2.);\n            spe = 1.5*pow(spe, 48.*fbm(32.*p));\n            \n            vec3 bou = mat;\n            #ifdef SUB_SURFACE_SCATTERING\n            bou *= sca;\n            #endif\n            col += .35*occ*bou*(1.-calcAO(p, n, .8)); // fake global illumination\n        } else if (tm.y == MAT_SPRINKLES) { // sprinkles\n            if (p.z>.48)      mat = vec3(.3,.7,1);\n            else if (p.z>.2)  mat = vec3(.6,.2,1);\n            else if (p.x<-.4) mat = vec3(1,.5,.7);\n            else              mat = vec3(1,.7,.4);\n            mat = mix(mat, .65*vec3(.9,.35,.15), tr);\n            \n            sca = mat*mat;\n            sss = calcSSS(p, n, lig, .3, sca);\n            fre = .3*pow(fre,3.);\n            spe = 2.*pow(spe, 32.);\n        }\n        \n        #ifdef SUB_SURFACE_SCATTERING\n        col += sss; // base layer\n        col += sca*occ*fre; // sss on raising angles\n        #else\n        col += dif*sha; // base layer\n        #endif\n        col += .08*occ; // ambient light\n        col += sss*spe; // specular\n        \n        col *= mat; // coloring\n                \n        // blue rimlight only on the white donut\n        vec3 bac = lig*vec3(-1,-1,1);\n        dif = clamp(dot(n,bac),0.,1.);\n        fre = 1.+dot(rd, n);\n        col += 2.*tr*vec3(.1,.4,1)*occ*pow(fre,4.)*dif*clamp(.2+.8*dot(rd, bac), 0., 1.);\n        \n        // cheap ice effect\n        #ifdef FROZEN_DONUT\n        col += occ*.7*vec3(.3,.7,1)*pow(fre, 3.*pow(fbm(8.*p),.5));\n        #endif\n        #ifdef MATERIAL_PREVIEW\n        col = mat*occ*(.5+.5*n.y);\n        #endif\n    }\n        \n    return col;\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // music frequency\n    float freq = texture(iChannel0, vec2(0,.1)).r;\n    \n    vec3 tot = vec3(0); // accumulated color\n    for (int m=0; m<AA; m++)\n    for (int n=0; n<AA; n++) {\n        vec2 off = vec2(m,n)/float(AA)-.5; // antialiasing offset\n        // pixel coordinates centered at the origin\n        vec2 p = (fragCoord+off - .5*iResolution.xy)/iResolution.y;\n        p *= .9-.2*freq; // music bounce\n        \n        // normalized mouse coordinates\n        vec2 mo = iMouse.xy/iResolution.xy;\n        // normalized pixel coordinates\n        vec2 q = (fragCoord+off)/iResolution.xy;\n\n        // time value\n        float time = .5*iTime + mo.x*PI*2.;\n                                \n        vec3 ro = vec3(0,0,3); // ray origin\n        ro.xz *= rot(time); // rotate the camera\n        vec3 ta = vec3(0); // target\n        mat3 ca = setCamera(ro, ta); // camera matrix\n    \n        vec3 rd = ca * normalize(vec3(p,1.5)); // ray direction\n    \n        vec3 col = render(ro, rd, q);\n        tot += col;\n    }\n    tot /= float(AA*AA);\n    \n    tot = 2.*tot/(1.+tot); // tonemapping\n    tot = pow(tot, vec3(.4545)); // gamma correction\n                    \n    // vignette\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= .5+.5*pow(24. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);\n    // dithering\n    tot += hash(fragCoord.x+13.*fragCoord.y)/255.;\n                \n    fragColor = vec4(tot,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 31270,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/lukrembo/biscuit-3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}