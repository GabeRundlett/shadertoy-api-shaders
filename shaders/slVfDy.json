{
    "Shader": {
        "info": {
            "date": "1665212341",
            "description": "just for the nice \"accidental celtic\"  bug :-)\n\nOk, building fractals by acting on the coordinates it's not the proper way to compute clean SDF...",
            "flags": 0,
            "hasliked": 0,
            "id": "slVfDy",
            "likes": 20,
            "name": "Hilbert c. 5b/ accidental celtic",
            "published": 3,
            "tags": [
                "short",
                "filling",
                "hilbertcurve",
                "celtic"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 284
        },
        "renderpass": [
            {
                "code": "// variant of https://shadertoy.com/view/XtjXW3\n// and https://www.shadertoy.com/view/NtKBRd\n\n#define plot(U,l) ( dot(U,l) > 0.  ? abs( dot(U , vec2(-l.y,l.x)) ) : 0. )\n#define plotC(U,l)  abs( length(U-(l)/2.) - .5 )\n\nvoid iter( inout vec2 U, inout vec2 l, inout vec2 r ) {\n        vec2 I = vec2(1,0), J = vec2(0,1), k,\n           fU = step(.5,U);                                                 // select child\n        bvec2 c = bvec2(fU);     \n        U = 2.*U - fU;                                                      // go to new local frame\n        l = c.x ? c.y ? -J : -I                                             //   node left segment\n                : c.y ?  l :  J;\n        r =  c.x==c.y ?  I : c.y ?-J:J;                                     //   node right segment\n                                                                            // the heart of Hilbert curve : \n        if (c.x) { U.x = 1.-U.x;  l.x=-l.x;  r.x=-r.x;  k=l;l=r;r=k; }      //   sym\n        if (c.y) { U   = 1.-U.yx; l  =-l.yx; r  =-r.yx; }                   //   rot+sym\n}\n\nvoid mainImage( out vec4 O,  vec2 u )\n{\n    O = vec4(0);\n    vec2  R = iResolution.xy,\n          U = u/R.y - vec2(.3,0) + 1e-5, // or bug at depth 2. why ?\n          P = vec2(.5), l=vec2(-1,0),r=l;\n    float T = 2.*ceil( log2(R.y)-4. ), t = floor(mod(iTime,T));\n        t = min(t, T-t);\n        \n#if 1\n    float v, d=9.;\n    for( int k=0; k<9; k++ ) {\n        vec2 D = vec2(k%3-1,k/3-1), \n             V = U+D/exp2(t)/4., l=vec2(-1,0),r=l; //, P = vec2(.5)-D; \n        for( float i=0.; i<t; i++ )\n            iter(V,l,r);\n         // Shane: dot(l,r)==0.\n        v = length(l+r) > 0. ?   plotC (V-P, l+r) :  plot (V-P, l) + plot (V-P, r);\n        d = min(d,v);\n    }\n    v = d;\n#else\n    for( float i=0.; i<t; i++ )\n        iter(U,l,r);\n    float v = length(l+r) > 0. ?   plotC (U-P, l+r) :  plot (U-P, l) + plot (U-P, r); \n#endif\n\n    O = vec4( sin(v*R.y/exp2(t)) ) ;\n/*  P = min(U,1.-U);                               // clamp\n    O = vec4(  smoothstep( 1.5, -1.5, ( v  -.33 ) *R.y/exp2(t) )\n              * step( 0., min(P.x,P.y)  ) );\n*/\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}