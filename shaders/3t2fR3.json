{
    "Shader": {
        "info": {
            "date": "1603738927",
            "description": "Inspired by the 'drain' scene from the Stephen King 'It' movie.\nHappy Halloween everyone!\n(https://youtu.be/HsGZhpXIMBs)",
            "flags": 64,
            "hasliked": 0,
            "id": "3t2fR3",
            "likes": 15,
            "name": "Halloween - 'It' Tribute",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "halloween",
                "scary",
                "movie",
                "it",
                "clown"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 692
        },
        "renderpass": [
            {
                "code": "// 'It' Tribute\n//\n// Inspired by the 'drain' scene from the Stephen King 'It' movie.\n// I'd love to come back to this in the future when a) my modelling\n// skills are improved, and b) my GPU is faster. :o)\n//\n// Concrete texture reused from my earlier shader:\n// https://www.shadertoy.com/view/WllfzB\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST 0.0015\n#define MAX_DIST 64.0\n\n//#define AA  // Enable this line if your GPU can take it!\n\nvec3 rayDir;\nfloat faceVisibility, eyeWonk, headLunge;\n\nstruct MarchData {\n    float d;\n    vec3 mat;        // RGB\n    float specPower; // 0: None, 30.0: Shiny\n    float opacity;   // 1.0: Solid\n};\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat noise(vec3 p) {\n\tconst vec3 s = vec3(7.0, 157.0, 113.0);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\t\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\t\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat fbm(vec3 p) {\n    return noise(p) * noise(p + 0.2) * noise(p + 0.66);\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat opRep(float p, float c) {\n    float c2 = c * 0.5;\n    return mod(p + c2, c) - c2;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0.0, h);\n\treturn length(p) - r;\n}\n\nfloat sdPuddle(vec3 p, float r) {\n    r *= 0.9 + 0.1 * cos(7.0 * atan(p.x, p.y));\n    return sdCappedCylinder(p, r, 0.05);\n}\n\nfloat sdEye(vec3 p, inout vec3 mat, float openness, float maxEyeWonk) {\n    const float r = 0.5;\n    float d = length(p) - r;\n    vec3 pp = p;\n    pp.yz *= rot(0.181);\n    float frontAngle = abs(atan(pp.y, pp.z)) / 3.1415;\n\n    const float pupilSize = 0.1;\n    const float irisSize = 0.3;\n    \n    vec3 eyeRay = rayDir;\n    eyeRay.xz *= rot(0.75 * eyeWonk * maxEyeWonk);\n    vec3 pupilCenter = eyeRay * -r;\n    vec3 pupilToP = p - pupilCenter;\n    float distFromFocus = length(pupilToP);\n    \n    // Corners.\n    mat = mix(mat, vec3(0.3, 0.01, 0.05), smoothstep(0.8, 1.0, abs(p.x / r)));\n    \n    // Iris color.\n    const vec3 irisCol = vec3(0.068, 0.211, 0.18);\n    float radialTint = sin(atan(pupilToP.y, pupilToP.x) * 23.0) * 0.3 + 1.7 - irisSize * distFromFocus;\n    mat *= smoothstep(0.0, 0.05, distFromFocus - irisSize); // Gradient\n    mat = mix(mat,\n              irisCol * radialTint, // Radial lines\n              1.0 - min(distFromFocus / irisSize, 1.0)); // Solid\n    \n    // Iris outer.\n    mat *= mix(0.17, 1.0, smoothstep(0.0, 0.04, abs(distFromFocus - irisSize)));\n    \n    // Pupil.\n    mat = mix(vec3(0.01), mat, smoothstep(0.0, 0.06, distFromFocus - pupilSize));\n    \n    // Open/close eyelids.\n    mat *= smoothstep(0.1, 0.0, mix(1.1, 0.91, openness) - frontAngle);\n    return d;\n}\n\nMarchData sdHead(vec3 p, vec3 eyeMat) {\n    p -= vec3(0.0, 1.2, -2.0);\n    \n    // Eyes.\n    float openness = faceVisibility;\n    float blink = clamp(iTime - 32.0, 0.0, 0.4) / 0.4;\n    openness *= pow(abs(cos(blink * 3.1415)), 2.0);\n    \n    vec3 eyeMat1 = eyeMat;\n    MarchData result = MarchData(sdEye(p - vec3(-0.9, 0.0, 0.0), eyeMat1, openness, 1.0), eyeMat1, 30.0, 1.0);\n    \n    float eye2 = sdEye(p - vec3(0.9, 0.0, 0.0), eyeMat, openness, 0.0);\n    if (eye2 < result.d) {\n        result.d = eye2;\n        result.mat = eyeMat;\n    }\n    \n    // Forehead.\n    float ox = p.x;\n    p.x = abs(p.x);\n    float brow = (1.0 - cos(p.x * 2.9)) * 0.1;\n    float head = sdCapsule(p - vec3(0.0, 0.37 + brow, 0.0), 1.2, 0.2);\n    \n    vec3 pp = p.yxz;\n    pp.xz *= rot(0.6);\n    head = smin(head, sdCapsule(pp - vec3(-0.36, 0.0, 0.2), 0.5, 0.2), 0.5);\n    if (head < result.d) {\n        result.d = head;\n        float noseDim = mix(1.0, smoothstep(-0.4, 0.5, ox), clamp(0.3 - p.y, 0.0, 1.0));\n        result.mat = vec3(0.004 * faceVisibility * noseDim);\n        result.specPower = 1e7;\n    }\n    \n    return result;\n}\n\nfloat getConcreteMaterial(vec3 p, out vec3 mat) {\n    // Mix a couple of shades of grey.\n    float baseColor = smoothstep(0.0, 0.5, noise(p));\n    mat = mix(vec3(0.18, 0.17, 0.17), vec3(0.20, 0.19, 0.19), baseColor);\n\n    // Surface roughness.\n    float rough = noise(p * 60.0) * 0.005 // Base\n         \t\t  + step(0.2, noise(p * 26.666)) * 0.0033; // Pits/dents.\n    mat += rough * 24.0;\n    \n    return rough;\n}\n\nfloat getAsphaltMaterial(vec3 p, out vec3 mat) {\n    // Surface roughness.\n    float rough = abs(fbm(p * 10.0) - 0.5) * 0.1;\n    mat = vec3(rough * 0.3);\n    return rough;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\n// Once it has been hit, we exclude the water from the scene.\nbool refracted = false;\n\n// Map the scene using SDF functions.\nMarchData map(vec3 p) {\n    MarchData result;\n    result.specPower = 1000.0;\n    result.opacity = 1.0;\n    \n    // Concrete texture.\n    vec3 concreteMat;\n    float concreteDisplacement = getConcreteMaterial(p, concreteMat);\n    result.mat = concreteMat;\n\n    // Curb.\n    vec3 rp = p;\n    rp.x = opRep(rp.x, 12.2);\n    const vec3 curbSize = vec3(6.0, 2.0, 1.0);\n    float curb = max(sdBox(rp, curbSize), 0.25 - (sdBox(p, curbSize) - 0.1));\n\n    // Paving.\n    rp.x = opRep(p.x + 2.3, 9.2);\n    float slab = sdBox(rp - vec3(0.0, 1.8, 6.0), vec3(4.5, 0.2, 4.5));\n    rp.x = opRep(p.x - 2.3, 9.2);\n    slab = min(slab, sdBox(rp - vec3(0.0, 1.8, 15.3), vec3(4.5, 0.2, 4.5)));\n    \n    if (slab < curb) {\n        // Black out underside of paving slabs.\n        result.mat *= rayDir.y < 0.0 ? 1.0 : 0.0;\n    }\n    \n\tresult.d = min(slab, curb) - 0.1 - concreteDisplacement;\n    \n    // Drain.\n    p.y += curbSize.y;\n    float drainBox = max(\n        sdBox(p, curbSize * vec3(1.025, 2.0, 1.0)) - 0.1,\n        -sdBox(p, curbSize * vec3(0.9, 1.8, 2.0)));\n    if (drainBox < result.d) {\n    \tresult.d = drainBox;\n        result.mat *= vec3(.439, .157, .035);\n    }\n    \n    // Road.\n    p.yz += vec2(0.5, 10.7);\n    vec3 mm;\n    float road = sdBox(p, vec3(100.0, 0.5 + getAsphaltMaterial(p, mm), 10.0));\n    if (road < result.d) {\n        result.mat = mm;\n        result.d = road;\n        result.specPower = 1.0;\n    }\n\n    // Head.\n    vec3 headMat;\n    vec3 pp = p - vec3(0.0, 0.6 + sin(headLunge * 6.282) * 0.1, -1.0) * headLunge * 2.0;\n    MarchData head = sdHead(pp - vec3(0.0, 0.0, 15.0), concreteMat * 1.3);\n    if (head.d < result.d)\n        result = head;\n    \n    if (!refracted) {\n        // Puddles.\n        vec3 puddleP = p.xzy - vec3(6.0, 6.0, 0.5);\n        float puddles = sdPuddle(puddleP, 1.2);\n        puddles = min(puddles, sdPuddle(puddleP - vec3(2.0, 0.0, 0.0), 2.0));\n        puddles = min(puddles, sdPuddle(puddleP - vec3(5.0, 0.0, 0.0), 1.5));\n        \n        // Stream.\n        float waterClip = sdBox(p - vec3(0.0, 0.0, 61.0), vec3(100.0, 100.0, 50.0));\n        p.xz += vec2(46.25, -151.08);\n        float edgeWave = sin(p.x - iTime * 5.0) * 0.2;\n        float radius = 150.0 + edgeWave;\n        float prad = length(p.xz);\n        float water = max(prad - radius, abs(p.y - 0.6));\n        vec3 wp = p;\n        wp.xz *= rot(iTime * 0.1) * 0.05;\n\n        float wt = iTime * 8.0;\n        float dis = (sin(p.x - wt) + 0.5 * sin((p.x - wt * 0.5) * 1.8)) * 0.25 + 0.5;\n        dis += texture(iChannel0, wp.xz).r * 0.8;\n        dis *= (radius - prad) * 0.2;\n        water -= dis;\n        water = max(water, -waterClip);\n        water = min(water, puddles);\n        \n        if (water < result.d) {\n            result.d = water;\n            result.mat = vec3(0.25, 0.3, 0.4);\n            result.specPower = 3.0;\n            result.opacity = 0.2;\n        }\n    }\n\n    return result;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.005773;\n    return normalize(e.xyy * map(p + e.xyy).d + \n\t\t\t\t\t e.yyx * map(p + e.yyx).d + \n\t\t\t\t\t e.yxy * map(p + e.yxy).d + \n\t\t\t\t\t e.xxx * map(p + e.xxx).d);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n    return map(p + h * n).d / h;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, MarchData data) {\n    vec3 sunCol = vec3(2.0, 1.6, 1.4);\n    vec3 sunPos = vec3(6.0, 3.0, -10.0);\n    vec3 sunDir = normalize(sunPos - p);\n    vec3 n = calcNormal(p);\n    \n    // Ambient occlusion (exluding water).\n    bool b = refracted;\n    refracted = true;\n    float amb = dot(vec3(ao(p, n, 0.2), ao(p, n, 0.5), ao(p, n, 2.0)), vec3(0.2, 0.3, 0.5));\n    refracted = b;\n    \n    // Diffuse color.\n    float diff = max(0.0, dot(sunDir, n));\n    \n    // Primary light.\n    vec3 lig = diff * sunCol * mix(amb, 1.0, iMouse.x/640.0);\n\n    // Specular.\n    float spe = pow(max(0.0, dot(rd, reflect(normalize(sunPos - p), n))), data.specPower);\n    lig += smoothstep(0.5, 1.0, spe) * 10.0;\n\n    float fre = 1.0 + dot(rd, n);\n    float fog = exp(-length(p) * 0.14);\n    return mix(data.mat * lig, vec3(0.0), fre) * fog;\n}\n\nvec3 getSceneColor(vec3 ro, vec3 rd) {\n    // Raymarch.\n    vec3 p;\n    \n    float d = 0.01;\n    float opacity = 1.0;\n    MarchData h;\n    vec3 col = vec3(0.0);\n    for (float steps = 0.0; steps < 90.0; steps++) {\n        p = ro + rd * d;\n        h = map(p);\n        \n        if (abs(h.d) < MIN_DIST) {\n            if (h.opacity > 0.9999 || refracted)\n            \tbreak; // We've hit a solid surface - Stop.\n            opacity = max(0.0, opacity - h.opacity);\n            col = applyLighting(p, rd, h) * h.opacity;\n            refracted = true;\n            rd = refract(rd, calcNormal(p), 0.95);\n        }\n        \n        if (d > MAX_DIST)\n            return vec3(0.0); // Distance limit reached - Stop.\n        \n        d += h.d; // No hit, so keep marching.\n    }\n    \n    // Lighting.\n    return applyLighting(p, rd, h) * opacity + col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Camera.\n    const float stageCount = 3.0;\n    float ft = smoothstep(0.0, 1.0, fract(iTime / 12.0));\n    float phase = mod(floor(iTime / 12.0), stageCount);\n    float dim = 1.0 - pow(abs(cos(iTime * 3.141 / 12.0)), 100.0);\n    \n    vec3 ro, lookAt = vec3(0.0, 0.0, 0.0);\n    faceVisibility = 0.0;\n    headLunge = 0.0;\n    \n    if (phase == 0.0) {\n        ro = vec3(mix(-30.0, -9.0, ft), 7.0, -15.0);\n        lookAt = ro * vec3(1.1, 0.0, 0.0);\n    } else if (phase == 1.0) {\n        ro = mix(vec3(20.0, 8.0, -20), vec3(0.0, 5.0, -10.0), ft);\n        faceVisibility = min(1.0, (ft - 0.3) * 2.0);\n        eyeWonk = 1.0;\n    } else if (phase == 2.0) {\n        float progress = min(1.0, pow(ft * 4.0, 4.0));\n        eyeWonk = 1.0 - smoothstep(0.4, 1.0, (ft - 0.2) * 2.0);\n        faceVisibility = 1.0 + min(sin(eyeWonk * 3.141), 0.5);\n        headLunge = ft;\n        ro = mix(vec3(1.0, 10.0, -20), vec3(-1.0, 0.85, -5.0), progress);\n    }\n    \n    vec3 col = vec3(0.0);\n#ifdef AA\n    for (float dx = 0.0; dx <= 1.0; dx++) {\n        for (float dy = 0.0; dy <= 1.0; dy++) {\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.5;\n#else\n            vec2 coord = fragCoord;\n#endif\n            vec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\n\n            rayDir = getRayDir(ro, lookAt, uv);\n            col += getSceneColor(ro, rayDir);\n#ifdef AA\n            refracted = false;\n        }\n    }\n    col /= 4.0;\n#endif\n    \n    // Output to screen.\n    col = vignette(pow(col * dim, vec3(0.4545)), fragCoord);\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 24113,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/naturesoundsofficial/ambient-stream-1"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}