{
    "Shader": {
        "info": {
            "date": "1459788953",
            "description": "Another toy train; speed and view are user-controlled.",
            "flags": 32,
            "hasliked": 0,
            "id": "MsdSDM",
            "likes": 12,
            "name": "Express Train",
            "published": 3,
            "tags": [
                "simulation",
                "interactive",
                "train"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 993
        },
        "renderpass": [
            {
                "code": "// \"Express Train\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrOBoxDf (vec3 p, vec3 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrOBox2Df (vec2 p, vec2 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat BrickSurfShd (vec2 p)\n{\n  vec2 q, iq;\n  q = p;\n  iq = floor (q);\n  if (2. * floor (iq.y / 2.) != iq.y) {\n    q.x += 0.5;  iq = floor (q);\n  }\n  q = smoothstep (0.015, 0.025, abs (fract (q + 0.5) - 0.5));\n  return 0.5 + 0.5 * q.x * q.y;\n}\n\nfloat BrickShd (vec3 p, vec3 n)\n{\n  return dot (vec3 (BrickSurfShd (p.zy), BrickSurfShd (p.xz), BrickSurfShd (p.xy)),\n     abs (n));\n}\n\nconst float txRow = 64.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\n#define N_CAR 6\n\nvec3 qHit, sunDir;\nvec2 rlSize;\nfloat dstFar, tCur, szFac, angX, rgHSize, trkWid, dR, dB;\nint idObj;\n\nconst int idRail = 1, idRbase = 2, idXingV = 3, idXingB = 4, idPlatB = 5,\n   idPlatU = 6, idCar = 11, idCon = 12, idWhl = 13, idFLamp = 14, idBLamp = 15;\nconst int dirNS = 0, dirEW = 1, dirSW = 2, dirNW = 3, dirSE = 4, dirNE = 5,\n   dirX = 6;\n\nvec3 GrndCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  vec2 w, e;\n  float f;\n  e = vec2 (0.01, 0.);\n  w = 5. * ro.xz;\n  f = Fbm2 (w);\n  vn = normalize (vec3 (f - Fbm2 (w + e), 0.08, f - Fbm2 (w + e.yx)));\n  col = 0.4 * mix (vec3 (0.4, 0.3, 0.1), vec3 (0.4, 0.5, 0.2), f) *\n       (1. - 0.1 * Noisefv2 (31. * w));\n  col *= 0.1 + 0.9 * max (dot (vn, sunDir), 0.);\n  col = mix (col, vec3 (0.15, 0.2, 0.15), pow (1. + rd.y, 16.));\n  return col;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sr, f;\n  ro.xz += 2. * tCur;\n  sr = max (dot (rd, sunDir), 0.);\n  col = vec3 (0.05, 0.1, 0.25) + 0.2 * pow (1. - rd.y, 8.) +\n     0.2 * pow (sr, 6.) + 0.4 * min (pow (sr, 256.), 0.3);\n  f = Fbm2 (0.05 * (ro + rd * (100. - ro.y) / rd.y).xz);\n  col = mix (col, vec3 (1.), clamp (0.1 + 0.8 * f * rd.y, 0., 1.));\n  return col;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  if (rd.y > -0.04 && rd.y < max (0.012 * Fbm1 (20. * abs (atan (rd.z, rd.x))) -\n     0.005, 0.)) {\n    ro -= (ro.y / rd.y) * rd;\n    col = 0.8 * mix (vec3 (0.22, 0.15, 0.15), vec3 (0.15, 0.22, 0.15),\n       Fbm2 (32. * ro.xz));\n  } else if (rd.y > 0.) col = SkyCol (ro, rd);\n  else col = GrndCol (ro - (ro.y / rd.y) * rd, rd);\n  return col;\n}\n\nvoid SimpSeg (vec3 q, int indx)\n{\n  if (indx == dirEW) q.xz = q.zx;\n  else if (indx == dirNW) q.z *= -1.;\n  else if (indx == dirSE) q.x *= -1.;\n  else if (indx == dirNE) q.xz *= -1.;\n  if (indx <= dirEW) {\n    q.x = abs (q.x);\n  } else {\n    q.xz += 0.5;  q.x = abs (length (q.xz) - 0.5);\n  }\n  dB = PrOBox2Df (q.xy, vec2 (2. * trkWid, 0.2 * rlSize.y));\n  q.xy -= vec2 (trkWid, 0.7 * rlSize.y);\n  dR = PrRoundBox2Df (q.xy, rlSize, 0.5 * rlSize.x);\n}\n\nvoid CrossSeg (vec3 q, int indx)\n{\n  vec3 qq;\n  qq = q;\n  q = qq;  q.x = abs (q.x);\n  dB = PrOBoxDf (q, vec3 (2. * trkWid, 0.2 * rlSize.y, 0.5));\n  q = qq;  q.xz = q.zx;   q.x = abs (q.x);\n  dB = min (dB, PrOBoxDf (q, vec3 (2. * trkWid, 0.2 * rlSize.y, 0.5)));\n  qq.y -= 0.7 * rlSize.y;\n  q = qq;  q.x = abs (q.x) - trkWid;  q.z += 0.5;\n  dR = PrRoundBox2Df (q.xy, rlSize, 0.5 * rlSize.x);\n  q = qq;  q.xz = q.zx;  q.z += 0.5;  q.x = abs (q.x) - trkWid;\n  dR = min (dR, PrRoundBox2Df (q.xy, rlSize, 0.5 * rlSize.x));\n  q = qq;  q.xz = abs (q.xz) - trkWid + 2.1 * rlSize.x;\n  dR = max (dR, - min (PrBox2Df (q.xz, vec2 (trkWid, 0.7 * rlSize.x)),\n     PrBox2Df (q.zx, vec2 (trkWid, 0.7 * rlSize.x))));\n}\n\nint GetIx (int isq)\n{\n  int indx;\n  indx = -1;\n  if (isq == 1 || isq == 2 || isq == 3 || isq == 4 || isq == 13 ||\n     isq == 16 || isq == 19 || isq == 22 || isq == 31 || isq == 34) indx = dirEW;\n  else if (isq == 6 || isq == 11 || isq == 24 || isq == 26 || isq == 27 ||\n     isq == 29) indx = dirNS;\n  else if (isq == 12 || isq == 30 || isq == 33) indx = dirSE;\n  else if (isq == 17 || isq == 32 || isq == 35) indx = dirSW;\n  else if (isq == 0 || isq == 15 || isq == 18) indx = dirNE;\n  else if (isq == 5 || isq == 14 || isq == 23) indx = dirNW;\n  else if (isq == 20 || isq == 21) indx = dirX;\n  return indx;\n}\n\nfloat TrackDf (vec3 p)\n{\n  vec3 q;\n  vec2 ip;\n  float dMin, dUsq;\n  int indx, isq;\n  const float sqWid = 0.4999;\n  dMin = dstFar;\n  ip = floor (p.xz);\n  q = p;  q.xz = fract (q.xz) - vec2 (0.5);\n  isq = int (2. * rgHSize * mod (ip.y + rgHSize, 2. * rgHSize) +\n     mod (ip.x + rgHSize, 2. * rgHSize));\n  indx = GetIx (isq);\n  if (indx >= 0 && indx <= dirX) {\n    q.y -= 0.5 * rlSize.y;\n    if (indx < dirX) SimpSeg (q, indx);\n    else CrossSeg (q, indx);\n    dUsq = max (PrOBox2Df (p.xz, vec2 (2. * sqWid * rgHSize)),\n       PrBox2Df (q.xz, vec2 (sqWid)));\n    dR = max (dR, dUsq);\n    if (dR < dMin) { dMin = dR;  idObj = idRail; }\n    dB = max (dB, dUsq);\n    if (dB < dMin) { dMin = dB;  idObj = idRbase; }\n  }\n  return dMin;\n}\n\nfloat TrackRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 srd, dda, h;\n  float dHit, d;\n  const float eps = 0.0001;\n  srd = - sign (rd.xz);\n  dda = - srd / (rd.xz + 0.0001);\n  dHit = max (0., PrBox2Df (ro.xz, vec2 (rgHSize)));\n  for (int j = 0; j < 160; j ++) {\n    p = ro + dHit * rd;\n    h = fract (dda * fract (srd * p.xz));\n    d = TrackDf (p);\n    dHit += min (d, 0.001 + max (0., min (h.x, h.y)));\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nfloat CarDf (vec3 p, float dMin, float dir)\n{\n  vec3 q;\n  float d, s, ds;\n  q = p;\n  s = 0.25;\n  if (q.z * dir > 0.5) {\n    ds = -0.25 * (q.z * dir - 0.5);\n    s += ds;\n    q.y -= ds;\n  }\n  d = PrRoundBoxDf (q, vec3 (0.3, s, 1.55), 0.4);\n  if (d < dMin) { dMin = d;  idObj = idCar;  qHit = p; }\n  q = p;  q.xz = abs (q.xz);  q.z = abs (q.z - 0.9);\n  q -= vec3 (0.39, -0.6, 0.2);\n  d = PrCylDf (q.yzx, 0.15, 0.07);\n  if (d < dMin) { dMin = d;  idObj = idWhl;  qHit = q; }\n  q = p;  q.z = (dir == 0.) ? abs (q.z) - 1.8 : q.z + 1.8 * dir;\n  d = PrCylDf (q.xzy, 0.3, 0.5);\n  if (d < dMin) { dMin = d;  idObj = idCon; }\n  if (dir > 0.) {\n    q = p;  q.yz -= vec2 (-0.25, 1.9);\n    d = PrCylDf (q, 0.1, 0.1);\n    if (d < dMin) { dMin = d;  idObj = idFLamp;  qHit = q; }\n  } else if (dir < 0.) {\n    q = p;  q.x = abs (q.x) - 0.2;  q.yz -= vec2 (-0.25, -1.9);\n    d = PrCylDf (q, 0.08, 0.1);\n    if (d < dMin) { dMin = d;  idObj = idBLamp;  qHit = q; }\n  }\n  return dMin;\n}\n\nfloat SceneDf (vec3 p)\n{\n  vec4 pCar;\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;  q.yz -= vec2 (1.5 * rlSize.y, -2.32);\n  d = PrOBoxDf (q, vec3 (0.9, 1.5 * rlSize.y, 0.12));\n  if (d < dMin) { dMin = d;  idObj = idPlatB; }\n  q.x = abs (q.x) - 0.4;  q.yz -= vec2 (0.07, 0.08);\n  d = max (PrBoxDf (q, vec3 (0.24, 0.09, 0.035)),\n     - PrBoxDf (q, vec3 (0.22, 0.08, 0.04)));\n  if (d < dMin) { dMin = d;  idObj = idPlatU; }\n  q = p;  q.z = abs (q.z - 0.5);\n  d = PrOBoxDf (q, vec3 (0.3, 0.7 * rlSize.y, 0.3));\n  if (d < dMin) { dMin = d;  idObj = idRbase; }\n  q = p;  q.xy -= vec2 (0.27 * sign (q.z - 0.5), 0.05);\n  q.z = abs (q.z - 0.5) - 0.16;\n  d = PrCapsDf (q.xzy, 0.017, 0.05);\n  if (d < dMin) { dMin = d;  idObj = idXingV; }\n  q = p;  q -= vec3 (0.25, 0.03, 0.66);\n  q.xy = Rot2D (q.xy, angX);  q.xy -= vec2 (-0.22, 0.05);\n  d = PrOBoxDf (q, vec3 (0.2, 0.008, 0.005)); \n  if (d < dMin) { dMin = d;  idObj = idXingB;  qHit = q; }\n  q = p;  q -= vec3 (-0.25, 0.03, 0.34);\n  q.xy = Rot2D (q.xy, - angX);  q.xy -= vec2 (0.22, 0.05);\n  q.x *= -1.;\n  d = PrOBoxDf (q, vec3 (0.2, 0.008, 0.005)); \n  if (d < dMin) { dMin = d;  idObj = idXingB;  qHit = q; }\n  dMin /= szFac;\n  for (int k = 0; k < N_CAR; k ++) {\n    pCar = Loadv4 (k);\n    pCar.y = 2.7 * rlSize.y + 0.06;\n    q = p;  q -= pCar.xyz;\n    q.xz = Rot2D (q.xz, pCar.w);\n    dMin = CarDf (q / szFac, dMin, (k > 0) ? ((k < N_CAR - 1) ? 0. : -1.) : 1.);\n  }\n  dMin *= szFac;\n  return dMin;\n}\n\nfloat SceneRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  const float eps = 0.0001;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = SceneDf (ro + dHit * rd);\n    dHit += d;\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  return min (SceneDf (p), TrackDf (p));\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = 0.0001 * vec3 (1., -1., 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.007;\n  for (int j = 0; j < 15; j ++) {\n    h = SceneDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 1., 20. * h / d));\n    d += min (0.016, 3. * h);\n    if (h < 0.001) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec4 CarCol (vec3 vn)\n{\n  vec4 objCol, carCol;\n  carCol = vec4 (0.1, 0.3, 1., 1.);\n  if (idObj == idCar) {\n    if (abs (qHit.y - 0.22) < 0.26)\n       objCol = vec4 (0.2, 0.2, 0.2, 1.);\n    else objCol = (abs (abs (qHit.y - 0.22) - 0.28) < 0.02) ?\n       vec4 (1., 0.2, 0.2, 1.) : carCol;\n  } else if (idObj == idCon) {\n    objCol = carCol;\n  } else if (idObj == idWhl) {\n    objCol = (length (qHit.yz) < 0.07) ? vec4 (0.2, 0.2, 0.2, 0.1) :\n       vec4 (0.6, 0.6, 0.6, 1.);\n  } else if (idObj == idFLamp) {\n    objCol = (qHit.z > 0.1) ? vec4 (1., 1., 0., -1.) : carCol;\n  } else if (idObj == idBLamp) {\n    objCol = (qHit.z < -0.1) ? vec4 (1., 0., 0., -1.) : carCol;\n  }\n  return objCol;\n}\n\nvec4 SceneCol (vec3 ro, vec3 vn)\n{\n  vec4 objCol;\n  if (idObj == idRail) objCol = vec4 (0.7, 0.7, 0.7, 0.8);\n  else if (idObj == idRbase) objCol = vec4 (mix (vec3 (0.25, 0.25, 0.27),\n     vec3 (0.32, 0.32, 0.34), smoothstep (0.6, 0.9, Noisefv2 (500. * ro.xz))), 0.1);\n  else if (idObj == idXingV) objCol = vec4 (0.7, 0.8, 0.7, 0.8);\n  else if (idObj == idXingB) objCol = mix (vec4 (1., 0., 0., 1.),\n     vec4 (1.), step (0.5, mod (10. * qHit.x, 1.)));\n  else if (idObj == idPlatB) objCol = mix (vec4 (0.2, 0.2, 0.22, 0.1),\n     vec4 (0.25, 0.25, 0.2, 0.1), Noisefv2 (1000. * ro.xz));\n  else if (idObj == idPlatU) objCol = vec4 (0.5, 0.3, 0.1, 0.2) *\n     BrickShd (50. * ro, vn);\n  return objCol;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 rdd, qHitT, col, vn;\n  float dstHit, d, reflFac, sh;\n  int idObjT;\n  dstHit = dstFar;\n  d = TrackRay (ro, rd);\n  if (d < dstHit) dstHit = d;\n  idObjT = idObj;\n  qHitT = qHit;\n  d = SceneRay (ro, rd);\n  if (d < dstHit) dstHit = d;\n  else {\n    idObj = idObjT;\n    qHit = qHitT;\n  }\n  reflFac = 0.;\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    qHitT = qHit;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    qHit = qHitT;\n    if (idObj == idCar) {\n      rdd = reflect (rd, vn);\n      reflFac = (abs (qHit.y - 0.22) < 0.26) ? 0.6 : 0.2;\n    }\n    if (idObj < idCar) {\n      if (idObj == idRbase) vn = VaryNf (200. * ro, vn, 2.);\n      objCol = SceneCol (ro, vn);\n    } else objCol = CarCol (vn);\n    col = objCol.rgb;\n    if (objCol.a >= 0.) {\n      sh = ObjSShadow (ro, sunDir);\n      col = col * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.) +\n         objCol.a * sh * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.));\n    }\n  } else if (rd.y <= -0.04) {\n    d = - ro.y / rd.y;\n    ro += d * rd;\n    sh = (d < dstFar) ? ObjSShadow (ro, sunDir) : 1.;\n    col = sh * GrndCol (ro, rd);\n  } else col = BgCol (ro, rd);\n  if (reflFac > 0.) col = mix (col, 0.7 * BgCol (ro, rdd), reflFac);\n  return pow (clamp (col, 0., 1.), vec3 (0.7));\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, float fvVar, int vuMode)\n{\n  vec4 wgBx[2];\n  vec2 ust;\n  float asp;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (0.47 * asp, -0.1, 0.012 * asp, 0.15);\n  wgBx[1] = vec4 (0.47 * asp, -0.4, 0.022, 0.);\n  ust = abs (0.5 * uv - wgBx[0].xy) - wgBx[0].zw;\n  if (max (ust.x, ust.y) < 0.) {\n    if (abs (max (ust.x, ust.y)) * canvas.y < 1.5) col = vec3 (0.8, 0.8, 0.);\n    else col = vec3 (0.8, 0.8, 0.) * mix (1., 0., abs (ust.x) / wgBx[0].z);\n  }\n  ust = 0.5 * uv - wgBx[0].xy;\n  ust.y -= (fvVar - 0.5) * 2. * wgBx[0].w;\n  if (length (ust) < 1.1 * wgBx[0].z) {\n    if (length (ust) < 0.6 * wgBx[0].z)\n       col = (fvVar * canvas.y > 5.) ? vec3 (0.1, 1., 0.1) : vec3 (1., 0.1, 0.1);\n    else col = vec3 (0.8, 0.6, 0.);\n  }\n  if (length (0.5 * uv - wgBx[1].xy) < wgBx[1].z) {\n    if (length (0.5 * uv - wgBx[1].xy) < 0.8 * wgBx[1].z) col =\n       (vuMode == 0 || vuMode == 2) ? vec3 (0.7, 0.7, 0.2) : vec3 (0.2, 0.2, 1.);\n    else col = vec3 (1., 0.2, 0.2);\n  }\n  return col;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., sa.y, 0., 1., 0., - sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, sa.x, 0., - sa.x, ca.x);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, pVu;\n  mat3 vuMat;\n  vec3 ro, rd, col, u, vd;\n  vec2 canvas, uv, uvs;\n  float el, az, zmFac, f, trVar, trMov, trCyc;\n  int vuMode;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dstFar = 30.;\n  rgHSize = 3.;\n  szFac = 0.08;\n  trkWid = 0.03;\n  rlSize = vec2 (0.003, 0.005);\n  stDat = Loadv4 (N_CAR + 1);\n  trMov = stDat.x;\n  trCyc = stDat.w;\n  angX = 0.3 * pi * (1. - SmoothBump (0.55, 0.69, 0.02, mod (trMov / trCyc, 1.)));\n  stDat = Loadv4 (N_CAR + 2);\n  vuMode = int (stDat.x);\n  el = stDat.y;\n  az = stDat.z;\n  trVar = stDat.w;\n  if (vuMode == 0) {\n    vuMat = StdVuMat (clamp (el + 0.1 * pi, 0.02 * pi, 0.45 * pi), az);\n    ro = vuMat * vec3 (0., 0., -10.);\n    zmFac = 5.;\n  } else if (vuMode == 1) {\n    ro = vec3 (0., 1., -5.);\n    vd = normalize (Loadv4 (2).xyz - ro);\n    u = - vd.y * vd;\n    f = 1. / sqrt (1. - vd.y * vd.y);\n    vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n    zmFac = 8. * (atan (length (vd.xz), vd.y) / pi);\n  } else if (vuMode == 2 || vuMode == 3) {\n    pVu = Loadv4 (N_CAR);\n    ro.xz = pVu.xz;\n    ro.y = 0.25;\n    vuMat = StdVuMat (clamp (0.2 * el + 0.07 * pi, -0.25 * pi, 0.15 * pi),\n       az + pVu.w);\n    zmFac = 3.5;\n  }\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  sunDir = normalize (vec3 (1., 1.4, -1.));\n  col = ShowScene (ro, rd);\n  col = ShowWg (uv, canvas, col, trVar, vuMode);\n  fragColor = vec4 (col, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Express Train\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\nconst float pi = 3.14159;\n\nconst float txRow = 64.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\n#define N_CAR 6\n#define TRK_LEN 24\n\nvec3 drP;\nvec2 rP;\nfloat ti[TRK_LEN + 1], tCur, trCyc, rgHSize, tC, aP;\n\n#define SLIN(k,d) ti[k + 1] = ti[k] + d\n#define SCRV(k) ti[k + 1] = ti[k] + tC\n\nvoid TrSetup ()\n{\n  tC = 0.25 * pi;\n  ti[0] = 0.;\n  SCRV(0);  SLIN(1, 4.);  SCRV(2);  SLIN(3, 1.);  SCRV(4);  SLIN(5, 1.);  SCRV(6);\n  SLIN(7, 2.);  SCRV(8);  SLIN(9, 1.);  SCRV(10);  SLIN(11, 1.);  SCRV(12);\n  SLIN(13, 4.);  SCRV(14);  SLIN(15, 1.);  SCRV(16);  SLIN(17, 1.);  SCRV(18);\n  SLIN(19, 2.);  SCRV(20);  SLIN(21, 1.);  SCRV(22);  SLIN(23, 1.);\n  trCyc = ti[TRK_LEN];\n  rgHSize = 3.;\n}\n\nvec2 TrackPath (float t)\n{\n  t = mod (t, trCyc);\n  drP = vec3 (0., 0., 99.);\n  if (t < ti[6]) {\n    if (t < ti[1]) {\n      rP = vec2 (0., 0.);  drP = vec3 (1., 1., 0.5 * tC + 0.25 * (t - ti[0]));\n    } else if (t < ti[2]) {\n      rP = vec2 (1., 0.5);  drP.x = (t - ti[1]);\n    } else if (t < ti[3]) {\n      rP = vec2 (5., 0.);  drP = vec3 (0., 1., 0.75 * tC + 0.25 * (t - ti[2]));\n    } else if (t < ti[4]) {\n      rP = vec2 (5.5, 1.);  drP.y = (t - ti[3]);\n    } else if (t < ti[5]) {\n      rP = vec2 (5., 2.);  drP.z = 0. * tC + 0.25 * (t - ti[4]);\n    } else {\n      rP = vec2 (5., 2.5);  drP.x = - (t - ti[5]);\n    }\n  } else if (t < ti[12]) {\n    if (t < ti[7]) {\n      rP = vec2 (4., 2.);  drP = vec3 (0., 1., 0.75 * tC - 0.25 * (t - ti[6]));\n    } else if (t < ti[8]) {\n      rP = vec2 (3.5, 3.);  drP.y = (t - ti[7]);\n    } else if (t < ti[9]) {\n      rP = vec2 (3., 5.);  drP = vec3 (1., 0., 0.5 * tC - 0.25 * (t - ti[8]));\n    } else if (t < ti[10]) {\n      rP = vec2 (4., 5.5);  drP.x = (t - ti[9]);\n    } else if (t < ti[11]) {\n      rP = vec2 (5., 5.);  drP.z = 0.25 * tC - 0.25 * (t - ti[10]);\n    } else {\n      rP = vec2 (5.5, 5.);  drP.y = - (t - ti[11]);\n    }\n  } else if (t < ti[18]) {\n    if (t < ti[13]) {\n      rP = vec2 (5., 3.);  drP = vec3 (0., 1., 0. * tC - 0.25 * (t - ti[12]));\n    } else if (t < ti[14]) {\n      rP = vec2 (5., 3.5);  drP.x = - (t - ti[13]);\n    } else if (t < ti[15]) {\n      rP = vec2 (0., 3.);  drP = vec3 (1., 1., 0.75 * tC - 0.25 * (t - ti[14]));\n    } else if (t < ti[16]) {\n      rP = vec2 (0.5, 4.);  drP.y = (t - ti[15]);\n    } else if (t < ti[17]) {\n      rP = vec2 (0., 5.);  drP = vec3 (1., 0., 0.5 * tC - 0.25 * (t - ti[16]));\n    } else {\n      rP = vec2 (1., 5.5);  drP.x = (t - ti[17]);\n    }\n  } else {\n    if (t < ti[19]) {\n      rP = vec2 (2., 5.);  drP.z = 0.25 * tC - 0.25 * (t - ti[18]);\n    } else if (t < ti[20]) {\n      rP = vec2 (2.5, 5.);  drP.y = - (t - ti[19]);\n    } else if (t < ti[21]) {\n      rP = vec2 (2., 2.);  drP = vec3 (0., 1., 0. * tC - 0.25 * (t - ti[20]));\n    } else if (t < ti[22]) {\n      rP = vec2 (2., 2.5);  drP.x = - (t - ti[21]);\n    } else if (t < ti[23]) {\n      rP = vec2 (0., 2.);  drP = vec3 (1., 0., 0.25 * tC + 0.25 * (t - ti[22]));\n    } else {\n      rP = vec2 (0.5, 2.);  drP.y = - (t - ti[23]);\n    }\n  }\n  if (drP.z != 99.) {\n    drP.z *= 2. * pi / tC;\n    rP += 0.5 * vec2 (cos (drP.z), sin (drP.z));\n  }\n  rP += drP.xy - rgHSize;\n  return rP;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[2], pCar, pVu, stDat, mPtr, mPtrP;\n  vec2 iFrag, canvas, ust, vo, p1, p2;\n  float el, az, asp, cGap, tCurP, trVar, trSpd, trMov, t1, t2;\n  int pxId, wgSel, wgReg, vuMode;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= N_CAR + 4) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  vuMode = 3;\n  trMov = 0.;\n  trVar = 0.25;\n  el = 0.;\n  az = 0.;\n  wgSel = -1;\n  wgReg = -2;\n  if (iFrame <= 5) {\n    mPtrP = mPtr;\n  } else {\n    stDat = Loadv4 (N_CAR + 1);\n    trMov = stDat.x;\n    trSpd = stDat.y;\n    tCurP = stDat.z;\n    stDat = Loadv4 (N_CAR + 2);\n    vuMode = int (stDat.x);\n    el = stDat.y;\n    az = stDat.z;\n    trVar = stDat.w;\n    stDat = Loadv4 (N_CAR + 3);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.47 * asp, -0.1, 0.012 * asp, 0.15);\n    wgBx[1] = vec4 (0.47 * asp, -0.4, 0.022, 0.);\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[0].xy) - wgBx[0].zw;\n    if (max (ust.x, ust.y) < 0.) wgReg = 0;\n    if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[1].xy) < wgBx[1].z) wgReg = 1;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n    el = 0.;\n    az = 0.;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      az = - 2. * pi * mPtr.x;\n      el = - pi * mPtr.y;\n    }\n  } else if (wgSel == 0) {\n    trVar = clamp (0.5 + 0.5 * (mPtr.y - wgBx[0].y) / wgBx[0].w, 0., 1.);\n  } else if (wgSel == 1) {\n    if (mPtrP.z <= 0.) {\n      vuMode = ++ vuMode;\n      if (vuMode > 3) vuMode = 0; \n      el = 0.;\n      az = 0.;\n    }\n  }\n  trSpd = 1.2 * trVar;\n  if (trSpd < 0.01) trSpd = 0.;\n  TrSetup ();\n  trMov += trSpd * (tCur - tCurP);\n  cGap = 0.33;\n  if (pxId < N_CAR) {\n    t1 = trMov - float (pxId) * cGap;\n    p1 = TrackPath (t1 + 0.3 * cGap);\n    p2 = TrackPath (t1 - 0.3 * cGap);\n    pCar.xz = 0.5 * (p1 + p2);\n    pCar.y = 0.;\n    vo = p1 - p2;\n    pCar.w = atan (vo.x, vo.y);\n  } else if (pxId == N_CAR) {\n    if (vuMode == 2 || vuMode == 3) {\n      if (vuMode == 2) {\n        t1 = trMov - (float (N_CAR - 1) + 2.5) * cGap;\n        t2 = t1 + 2. * cGap;\n      } else {\n        t1 = trMov + 2.5 * cGap;\n        t2 = t1 - 2. * cGap;\n      }\n      p1 = TrackPath (t1);\n      p2 = TrackPath (t2);\n      pVu.xz = p1;\n      pVu.y = 0.;\n      vo = p2 - p1;\n      pVu.w = - atan (vo.x, vo.y);\n    }\n  }\n  tCurP = tCur;\n  if (pxId < N_CAR) stDat = pCar;\n  else if (pxId == N_CAR) stDat = pVu;\n  else if (pxId == N_CAR + 1) stDat = vec4 (trMov, trSpd, tCurP, trCyc);\n  else if (pxId == N_CAR + 2) stDat = vec4 (float (vuMode), el, az, trVar);\n  else if (pxId == N_CAR + 3) stDat = vec4 (mPtr.xyz, float (wgSel));\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}