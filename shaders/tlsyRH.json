{
    "Shader": {
        "info": {
            "date": "1591485701",
            "description": "Use the mouse and arrow keys to move around.\nThe scene's geometry is defined in the \"Common\" buffer.\nThe camera control is based on this shader: https://www.shadertoy.com/view/4lVXRm",
            "flags": 56,
            "hasliked": 0,
            "id": "tlsyRH",
            "likes": 3,
            "name": "3D fractal jungle explorer",
            "published": 3,
            "tags": [
                "raymarching",
                "game",
                "collisiondetection"
            ],
            "usePreview": 0,
            "username": "jarble",
            "viewed": 527
        },
        "renderpass": [
            {
                "code": "const float PI = 3.141592;\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\n\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\n\n//this is based on https://www.shadertoy.com/view/4tcGDr\n\nvec3 ground_color(vec3 p)\n{\n    p /= 2.0;\n    float color1 = length(sin(p/2.0+sin(p.zxy/11.0+sin(p/17.0))))/5.0;\n    return vec3(color1*2.0,color1,color1);\n}\n\nvec3 foliage_color(vec3 p)\n{\n    p /= 1.0;\n    float color1 = length(sin(p/100.0))/2.0;\n    return vec3(color1,color1,0.0);\n}\n\nvec3 spaceship_color(vec3 p)\n{\n    return vec3(0.5,0.5,0.5);\n}\n\nvec3 jungle_color(vec3 p)\n{\n    //p /= scale;\n    p = sin(p/100.0)*100.0;\n    vec2 uv = vec2(p.x,p.y)/(400.0);\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+p.z)/2.0));\n    vec2 col2;\n    for(float i = 1.0; i < 5.0; i++){\n        uv += ceil(col+sin((col.x+col.y)));\n        col /= sin(uv.x);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return sin(vec3(0.5+uv.y/500.0,col2.x,uv.x/500.0))/2.0;\n}\n\n\n\n\n\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    return normalize(vec3((fragCoord - size / 2.0), -size.y / tan(radians(fieldOfView) / 2.0)));\n}\n\nvec3 bump_map(vec3 p3)\n{\n  \t//return vec3(0.0);\n    p3 *= 10.0;\n    return (sin(p3)+sin(p3))/10.0;\n}\n\n\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(normalize(reflect(-L, N)), normalize(eye - p));\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n  \n    return color+phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  eye,\n                                  vec3(0.4, 0.4, 0.4));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy/iResolution.x;\n    \n    \n    vec3 rd = normalize(vec3((fragCoord - iResolution.xy*0.5)/max(iResolution.x, iResolution.y), 0.5));\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    rd = (rotY * rotX) * rd;\n\n    \n\n    //ro /= scale;\n    \n    float dist = shortestDistanceToSurface(ro, rd, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = ro + dist * rd;\n    \n    vec3 K_a;\n    if(color == 3){\n    \tK_a = foliage_color(p);\n    }\n    else if(color == 2){\n    \tK_a = jungle_color(p);\n    }\n    else if(color == 1){\n    \tK_a = ground_color(p);\n    }\n    else if(color == 4){\n    \tK_a = spaceship_color(p);\n    }\n    else{\n    \tK_a = vec3(1.0,1.0,1.0);\n    }\n    \n    vec3 color = phongIllumination(K_a, K_a, vec3(1.0), 10.0, p, ro);\n    \n    fragColor = vec4(color/2.2, 1.0);\n    float gamma = 2.2;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/gamma));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 PMOUSE = ivec2(2, 1);\n\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n// Keyboard constants definition\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const int KEY_BIND_FORWARD = FORWARD; const int KEY_BIND_BACKWARD = BACKWARD; const int KEY_BIND_RIGHT = RIGHT; const int KEY_BIND_LEFT = LEFT;\n\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  ARROWS\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\tvec2 i = vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                  key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(), 0.0).xzy;\n}\n\n\nvoid Collision(vec3 prev, inout vec3 p) {\n    if (p.y < 1.0) p = vec3(prev.xz, min(1.0, prev.y)).xzy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 2.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 2.0, 0.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 5.0;\n    \n    Collision(ptarget, target);\n    \n    position += (target - position) * iTimeDelta * 20.0;\n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n\tif (iMouse.z > 0.0) {\n    \tstore(VMOUSE, vec4(pm + (abs(iMouse.zw) - iMouse.xy), 1.0, 0.0));\n\t}\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = .001;\nint color;\n\n//const float scale = 1.0;\n\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat caves1(vec3 p){\n    float size = 100.0;\n    vec3 p1 = p/size;\n    return length(sin(vec3(sin(p1.x)/p1.x,cos(p1.y)-p1.y,sin(p1.z)+p1.z))*size) - size;\n}\n\nfloat caves(vec3 p) {\n    //p += sin(p.y/100.0)*100.0;\n    float result = caves1(p);\n    for(float i = 1.0; i < 100.0; i *= 10.0){\n        p = p.yxz-p.zyx;\n        result = max(result, caves1(p/i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n\treturn result;\n}\n\nfloat corridor1(vec3 p){\n    float size = 100.0;\n    vec3 p1 = p/size;\n    p = sin(vec3(sin(p1.x)/p1.x,cos(p1.y)-p1.y,sin(p1.z)+p1.z))*size;\n    return length(p) - size;\n}\n\nfloat corridor(vec3 p) {\n    float result = corridor1(p);\n    for(float i = 1.0; i < 1000.0; i *= 10.0){\n    \tresult = max(result, corridor1(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result;\n}\n\nfloat bump(vec3 p3)\n{\n    p3 *= 3.;\n  \t//return vec3(0.0);\n    float distortion = 5.0;\n    p3 *= distortion;\n    return length(sin(p3))/(distortion*4.0);\n}\n\nfloat sceneSDF1(vec3 p) {\n    p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    return  5.0 + sin((p.x*2.0+p.y+p.z/3.0))*3.0+sin(p.z)*1.5;\n}\n\nfloat ground1(vec3 p){\n    vec3 p1 = p/5.0;\n\treturn p.y+10.0+sin(p1.x/10.0+sin(p1.z))+sin(p1.z/10.0+sin(p1.x));\n    //return max(-caves(p),to_return);\n    //return p.y;\n}\n\nfloat ground(vec3 p){\n    vec3 p1 = p/5.0;\n\t//float to_return = p.y+10.0+sin(p1.x/10.0+sin(p1.z))+sin(p1.z/10.0+sin(p1.x));\n    vec3 p2 = p1/5.0;\n    //return  max(ground1(p),-sceneSDF1(p2/100.0))+(bump(p2/40.0)*20.0+bump(p2/20.0)*20.0)+bump(p2/10.0)*10.0;\n    return ground1(p);\n    //return p.y;\n}\n\nfloat jungle(vec3 p) {\n    p /= 100.0;\n    p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    float to_return = 4.2 + sin((p.x/2.0+p.y+p.z/3.0))*3.0+sin(p.z)*1.5+bump(p);\n    return to_return;\n}\n\nfloat foliage1(vec3 p){\n    float size = 100.0;\n    vec3 p1 = p/size;\n    p = sin(vec3(sin(p1.x)-p1.y,cos(p1.y)-p1.z,sin(p1.z)-p1.x))*size;\n    return length(p) - size;\n}\n\nfloat foliage(vec3 p,float jungle) {\n    float result = foliage1(p);\n    for(float i = 1.0; i < 1000.0; i *= 10.0){\n    \tresult = max(result, foliage1(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return max(result,jungle-3.0);\n}\n\nfloat spaceship1(vec3 p){\n    float size = 200.0;\n    vec3 p1 = p/size;\n    p = sin(vec3(sin(p1.x)/p1.x,cos(p1.y+p1.z)-p1.y,sin(p1.z+p1.x)+p1.z))*size;\n    return length(p) - size;\n}\n\nfloat spaceship(vec3 p) {\n    float result = spaceship1(p);\n    for(float i = 1.0; i < 1000.0; i *= 10.0){\n    \tresult = max(result, spaceship1(p*i)/(i*i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result;\n}\n\nfloat sceneSDF(vec3 p){\n    float ground1 = ground(p);\n    float jungle1 = jungle(p);\n    float foliage1 = foliage(p,jungle1);\n    //float spaceship1 = spaceship(p/10.0);\n\tfloat result1 = min(jungle1,min(foliage1,ground1));\n    if(result1 == jungle1){\n    \tcolor = 2;\n    }\n    else if(result1 == ground1){\n    \tcolor = 1;\n    }\n    else if(result1 == foliage1){\n    \tcolor = 3;\n    }\n    //else if(result1 == spaceship1){\n    //\tcolor = 4;\n    //}\n    else{\n    \tcolor = 2;\n    }\n    return result1;\n}\n\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\n\n/*\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n*/\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 estimateNormal(in vec3 p){\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * sceneSDF(p + e.xyy) + e.yyx * sceneSDF(p + e.yyx) + e.yxy * sceneSDF(p + e.yxy) + e.xxx * sceneSDF(p + e.xxx));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float depth, float end) {\n    //float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\n\n// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 8000.0);\n    t = (t>>4&t*5&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 4.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n        //if(i>3){\n        \tresult += sound1(time*factor);\n        //}\n        factor *= 3.1/(result.y+result.x);\n    }\n    return result/1500.0;\n}\n\n/*\nvec2 sound1( float time )\n{\n    int t = int(time * 4000.0);\n    t = (t>>4&t*2&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 1.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n        if(i>3){\n        \tresult += sound1(time*factor)/(factor);\n        }\n        factor *= 1.5;\n    }\n    return result/100.0;\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}