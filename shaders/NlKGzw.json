{
    "Shader": {
        "info": {
            "date": "1639709332",
            "description": "click and drag to look around, wasd to move\nf to enter fly, space to go up, shift to go down\n\nbugs: \ncollision detection fails at triangle edges",
            "flags": 48,
            "hasliked": 0,
            "id": "NlKGzw",
            "likes": 4,
            "name": "basic 3d engine",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "ArmandB",
            "viewed": 378
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    vec3 cross_col = vec3(1.0 - (col.r + col.b + col.g)/3.0);\n    \n    if (abs(iResolution.x/iResolution.y * (uv.x - 0.5)) < 0.003 && abs(uv.y - 0.5) < 0.02){\n        col = cross_col;\n    }\n    if (abs(iResolution.x/iResolution.y * (uv.x - 0.5)) < 0.02 && abs(uv.y - 0.5) < 0.003){\n        col = cross_col;\n    }\n    \n    bool isFly = texelFetch(iChannel1, ivec2(5,0), 0).x == 1.0;\n    if (isFly && floor(fragCoord.y) < 10.0){\n        col = vec3(1);\n    }\n\n    fragColor = vec4(col, 1.0);\n    //activate to see depth info\n    //fragColor = vec4(texture(iChannel0, uv).a*0.1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//frog scene\nvec3 tris[84] = vec3[](\n\tvec3(1.00000, -7.81250, 3.62500), vec3(2.40625, -8.75000, 5.03125), vec3(2.56250, -8.75000, 3.00000),\n\tvec3(1.00000, -9.21875, 1.59375), vec3(2.40625, -8.12500, 1.59375), vec3(2.56250, -8.75000, 3.00000),\n\tvec3(2.40625, -8.75000, 5.03125), vec3(1.00000, -7.81250, 3.62500), vec3(-0.40625, -8.75000, 5.03125),\n\tvec3(2.40625, -8.75000, 5.03125), vec3(-0.40625, -8.75000, 5.03125), vec3(1.00000, -9.68750, 3.00000),\n\tvec3(1.97432, -10.26671, 4.43575), vec3(2.40625, -8.75000, 5.03125), vec3(1.00000, -9.68750, 3.00000),\n\tvec3(1.97432, -10.26671, 4.43575), vec3(1.00000, -9.68750, 3.00000), vec3(2.56250, -8.75000, 3.00000),\n\tvec3(1.97432, -10.26671, 4.43575), vec3(2.56250, -8.75000, 3.00000), vec3(2.40625, -8.75000, 5.03125),\n\tvec3(2.09654, -10.11252, 2.16017), vec3(1.00000, -9.68750, 3.00000), vec3(1.00000, -9.21875, 1.59375),\n\tvec3(2.09654, -10.11252, 2.16017), vec3(1.00000, -9.21875, 1.59375), vec3(2.56250, -8.75000, 3.00000),\n\tvec3(2.09654, -10.11252, 2.16017), vec3(2.56250, -8.75000, 3.00000), vec3(1.00000, -9.68750, 3.00000),\n\tvec3(2.56250, -8.75000, 3.00000), vec3(2.40625, -8.12500, 1.59375), vec3(1.00000, -7.81250, 3.62500),\n\tvec3(2.30131, -7.22539, 1.85546), vec3(1.00000, -7.81250, 3.62500), vec3(2.40625, -8.12500, 1.59375),\n\tvec3(2.30131, -7.22539, 1.85546), vec3(2.40625, -8.12500, 1.59375), vec3(1.00000, -7.50000, 0.81250),\n\tvec3(2.30131, -7.22539, 1.85546), vec3(1.00000, -7.50000, 0.81250), vec3(1.00000, -7.81250, 3.62500),\n\tvec3(1.00000, -7.50000, 0.81250), vec3(2.40625, -8.12500, 1.59375), vec3(1.00000, -9.21875, 1.59375),\n\tvec3(-0.40625, -8.75000, 5.03125), vec3(1.00000, -7.81250, 3.62500), vec3(-0.56250, -8.75000, 3.00000),\n\tvec3(-0.40625, -8.12500, 1.59375), vec3(1.00000, -9.21875, 1.59375), vec3(-0.56250, -8.75000, 3.00000),\n\tvec3(-0.40625, -8.75000, 5.03125), vec3(0.02568, -10.26671, 4.43575), vec3(1.00000, -9.68750, 3.00000),\n\tvec3(1.00000, -9.68750, 3.00000), vec3(0.02568, -10.26671, 4.43575), vec3(-0.56250, -8.75000, 3.00000),\n\tvec3(-0.56250, -8.75000, 3.00000), vec3(0.02568, -10.26671, 4.43575), vec3(-0.40625, -8.75000, 5.03125),\n\tvec3(1.00000, -9.68750, 3.00000), vec3(-0.09654, -10.11252, 2.16017), vec3(1.00000, -9.21875, 1.59375),\n\tvec3(1.00000, -9.21875, 1.59375), vec3(-0.09654, -10.11252, 2.16017), vec3(-0.56250, -8.75000, 3.00000),\n\tvec3(-0.56250, -8.75000, 3.00000), vec3(-0.09654, -10.11252, 2.16017), vec3(1.00000, -9.68750, 3.00000),\n\tvec3(-0.40625, -8.12500, 1.59375), vec3(-0.56250, -8.75000, 3.00000), vec3(1.00000, -7.81250, 3.62500),\n\tvec3(1.00000, -7.81250, 3.62500), vec3(-0.30131, -7.22539, 1.85546), vec3(-0.40625, -8.12500, 1.59375),\n\tvec3(-0.40625, -8.12500, 1.59375), vec3(-0.30131, -7.22539, 1.85546), vec3(1.00000, -7.50000, 0.81250),\n\tvec3(1.00000, -7.50000, 0.81250), vec3(-0.30131, -7.22539, 1.85546), vec3(1.00000, -7.81250, 3.62500),\n\tvec3(-0.40625, -8.12500, 1.59375), vec3(1.00000, -7.50000, 0.81250), vec3(1.00000, -9.21875, 1.59375)\n);\n\nvec3 norms[84] = vec3[](\n\tvec3(0.52592, 0.84957, 0.04046), vec3(0.52592, 0.84957, 0.04046), vec3(0.52592, 0.84957, 0.04046),\n\tvec3(0.56624, -0.72802, -0.38648), vec3(0.56624, -0.72802, -0.38648), vec3(0.56624, -0.72802, -0.38648),\n\tvec3(0.00000, 0.83205, 0.55470), vec3(0.00000, 0.83205, 0.55470), vec3(0.00000, 0.83205, 0.55470),\n\tvec3(0.00000, -0.90796, 0.41906), vec3(0.00000, -0.90796, 0.41906), vec3(0.00000, -0.90796, 0.41906),\n\tvec3(-0.82493, 0.01306, 0.56508), vec3(-0.82493, 0.01306, 0.56508), vec3(-0.82493, 0.01306, 0.56508),\n\tvec3(0.42247, -0.70411, -0.57074), vec3(0.42247, -0.70411, -0.57074), vec3(0.42247, -0.70411, -0.57074),\n\tvec3(0.95125, -0.29963, 0.07317), vec3(0.95125, -0.29963, 0.07317), vec3(0.95125, -0.29963, 0.07317),\n\tvec3(-0.52070, -0.80993, -0.26998), vec3(-0.52070, -0.80993, -0.26998), vec3(-0.52070, -0.80993, -0.26998),\n\tvec3(0.60180, 0.25971, -0.75524), vec3(0.60180, 0.25971, -0.75524), vec3(0.60180, 0.25971, -0.75524),\n\tvec3(0.34510, -0.57517, 0.74167), vec3(0.34510, -0.57517, 0.74167), vec3(0.34510, -0.57517, 0.74167),\n\tvec3(0.57362, 0.77028, 0.27861), vec3(0.57362, 0.77028, 0.27861), vec3(0.57362, 0.77028, 0.27861),\n\tvec3(0.81480, -0.07229, 0.57522), vec3(0.81480, -0.07229, 0.57522), vec3(0.81480, -0.07229, 0.57522),\n\tvec3(0.56020, 0.29097, -0.77558), vec3(0.56020, 0.29097, -0.77558), vec3(0.56020, 0.29097, -0.77558),\n\tvec3(-0.28580, 0.95243, 0.10583), vec3(-0.28580, 0.95243, 0.10583), vec3(-0.28580, 0.95243, 0.10583),\n\tvec3(0.30637, -0.39390, -0.86659), vec3(0.30637, -0.39390, -0.86659), vec3(0.30637, -0.39390, -0.86659),\n\tvec3(-0.52592, 0.84957, 0.04046), vec3(-0.52592, 0.84957, 0.04046), vec3(-0.52592, 0.84957, 0.04046),\n\tvec3(-0.56624, -0.72802, -0.38648), vec3(-0.56624, -0.72802, -0.38648), vec3(-0.56624, -0.72802, -0.38648),\n\tvec3(0.82493, 0.01306, 0.56508), vec3(0.82493, 0.01306, 0.56508), vec3(0.82493, 0.01306, 0.56508),\n\tvec3(-0.42247, -0.70411, -0.57074), vec3(-0.42247, -0.70411, -0.57074), vec3(-0.42247, -0.70411, -0.57074),\n\tvec3(-0.95125, -0.29963, 0.07317), vec3(-0.95125, -0.29963, 0.07317), vec3(-0.95125, -0.29963, 0.07317),\n\tvec3(0.52070, -0.80993, -0.26998), vec3(0.52070, -0.80993, -0.26998), vec3(0.52070, -0.80993, -0.26998),\n\tvec3(-0.60180, 0.25971, -0.75524), vec3(-0.60180, 0.25971, -0.75524), vec3(-0.60180, 0.25971, -0.75524),\n\tvec3(-0.34510, -0.57517, 0.74167), vec3(-0.34510, -0.57517, 0.74167), vec3(-0.34510, -0.57517, 0.74167),\n\tvec3(-0.57362, 0.77028, 0.27861), vec3(-0.57362, 0.77028, 0.27861), vec3(-0.57362, 0.77028, 0.27861),\n\tvec3(-0.81480, -0.07229, 0.57522), vec3(-0.81480, -0.07229, 0.57522), vec3(-0.81480, -0.07229, 0.57522),\n\tvec3(-0.56020, 0.29097, -0.77558), vec3(-0.56020, 0.29097, -0.77558), vec3(-0.56020, 0.29097, -0.77558),\n\tvec3(0.28580, 0.95243, 0.10583), vec3(0.28580, 0.95243, 0.10583), vec3(0.28580, 0.95243, 0.10583),\n\tvec3(-0.30637, -0.39390, -0.86659), vec3(-0.30637, -0.39390, -0.86659), vec3(-0.30637, -0.39390, -0.86659)\n);\nvec2 uvs[84] = vec2[](\n\tvec2(0.25, 0.625), vec2(0.36405968958428014, 0.43703840967234786), vec2(0.4426367015629745, 0.625),\n\tvec2(0.6261209504097085, 0.7778742786007942), vec2(0.5, 0.6520504421433214), vec2(0.6261209504097085, 0.5625),\n\tvec2(0.40625, 0.6434875), vec2(0.265625, 0.8125), vec2(0.125, 0.6434875),\n\tvec2(1, 0.22371874999999997), vec2(0.71875, 0.22371874999999997), vec2(0.859375, 0),\n\tvec2(0.46107340298841437, 1.1102230246251565e-16), vec2(0.6296388466269683, 0), vec2(0.4375, 0.18139861079862452),\n\tvec2(0.9248515993070089, 0.38375422857243824), vec2(0.75, 0.4375), vec2(0.75, 0.25528122641914064),\n\tvec2(0.6685691698949203, 0.182869926324968), vec2(0.5677491036075522, 0.375), vec2(0.5, 0.18286992632496812),\n\tvec2(0, 0.8125), vec2(0, 0.6679910967275718), vec2(0.13174892714297248, 0.735932781003874),\n\tvec2(0.6174575503272173, 0.5279150297458242), vec2(0.5, 0.625), vec2(0.5, 0.4096267860455658),\n\tvec2(0.8125, 0.7171275176968819), vec2(0.7589757097762928, 0.875), vec2(0.6679935867286074, 0.7171275176968819),\n\tvec2(0.4426094069783164, 0.003157947517582582), vec2(0.4426094069783164, 0.15783819684260147), vec2(0.25, 0),\n\tvec2(0.21045709063774487, 0.4375), vec2(0, 0.3514722787666176), vec2(0.2490204152806803, 0.3514722787666176),\n\tvec2(5.551115123125783e-17, 0.1434872040485914), vec2(0.09150304566515644, 0.16617161536589942), vec2(0, 0.3125),\n\tvec2(0.2273628301992232, 0.45598713794783996), vec2(0.2273628301992232, 0.625), vec2(0, 0.4565237710154286),\n\tvec2(0.25, 0.21339403804558854), vec2(0.4225849914036922, 0.21339403804558854), vec2(0.34761101379411197, 0.375),\n\tvec2(0.36405968958428014, 0.43703840967234786), vec2(0.25, 0.625), vec2(0.4426367015629745, 0.625),\n\tvec2(0.5, 0.6520504421433214), vec2(0.6261209504097085, 0.7778742786007942), vec2(0.6261209504097085, 0.5625),\n\tvec2(0.6296388466269683, 0), vec2(0.46107340298841437, 1.1102230246251565e-16), vec2(0.4375, 0.18139861079862452),\n\tvec2(0.75, 0.4375), vec2(0.9248515993070089, 0.38375422857243824), vec2(0.75, 0.25528122641914064),\n\tvec2(0.5677491036075522, 0.375), vec2(0.6685691698949203, 0.182869926324968), vec2(0.5, 0.18286992632496812),\n\tvec2(0, 0.6679910967275718), vec2(0, 0.8125), vec2(0.13174892714297248, 0.735932781003874),\n\tvec2(0.5, 0.625), vec2(0.6174575503272173, 0.5279150297458242), vec2(0.5, 0.4096267860455658),\n\tvec2(0.7589757097762928, 0.875), vec2(0.8125, 0.7171275176968819), vec2(0.6679935867286074, 0.7171275176968819),\n\tvec2(0.4426094069783164, 0.15783819684260147), vec2(0.4426094069783164, 0.003157947517582582), vec2(0.25, 0),\n\tvec2(0, 0.3514722787666176), vec2(0.21045709063774487, 0.4375), vec2(0.2490204152806803, 0.3514722787666176),\n\tvec2(0.09150304566515644, 0.16617161536589942), vec2(5.551115123125783e-17, 0.1434872040485914), vec2(0, 0.3125),\n\tvec2(0.2273628301992232, 0.625), vec2(0.2273628301992232, 0.45598713794783996), vec2(0, 0.4565237710154286),\n\tvec2(0.4225849914036922, 0.21339403804558854), vec2(0.25, 0.21339403804558854), vec2(0.34761101379411197, 0.375)\n);\n\n//rectangle scene\n/*vec3 tris[36] = vec3[](\n\tvec3(28.50000, -7.50000, 38.00000), vec3(28.50000, -10.00000, 38.00000), vec3(28.50000, -7.50000, -32.00000),\n\tvec3(-26.50000, -7.50000, 38.00000), vec3(-26.50000, -10.00000, 38.00000), vec3(-26.50000, -10.00000, -32.00000),\n\tvec3(28.50000, -7.50000, 38.00000), vec3(28.50000, -7.50000, -32.00000), vec3(-26.50000, -7.50000, 38.00000),\n\tvec3(28.50000, -10.00000, 38.00000), vec3(-26.50000, -10.00000, 38.00000), vec3(28.50000, -10.00000, -32.00000),\n\tvec3(28.50000, -7.50000, 38.00000), vec3(-26.50000, -7.50000, 38.00000), vec3(28.50000, -10.00000, 38.00000),\n\tvec3(28.50000, -7.50000, -32.00000), vec3(-26.50000, -7.50000, -32.00000), vec3(-26.50000, -10.00000, -32.00000),\n\tvec3(28.50000, -7.50000, -32.00000), vec3(-26.50000, -7.50000, 38.00000), vec3(-26.50000, -7.50000, -32.00000),\n\tvec3(-26.50000, -10.00000, 38.00000), vec3(28.50000, -10.00000, -32.00000), vec3(-26.50000, -10.00000, -32.00000),\n\tvec3(-26.50000, -7.50000, 38.00000), vec3(-26.50000, -7.50000, -32.00000), vec3(-26.50000, -10.00000, -32.00000),\n\tvec3(28.50000, -7.50000, -32.00000), vec3(28.50000, -10.00000, -32.00000), vec3(-26.50000, -10.00000, -32.00000),\n\tvec3(28.50000, -10.00000, 38.00000), vec3(28.50000, -7.50000, -32.00000), vec3(28.50000, -10.00000, -32.00000),\n\tvec3(-26.50000, -7.50000, 38.00000), vec3(28.50000, -10.00000, 38.00000), vec3(-26.50000, -10.00000, 38.00000)\n);\nvec3 norms[36] = vec3[](\n\tvec3(1.00000, 0.00000, 0.00000), vec3(1.00000, 0.00000, 0.00000), vec3(1.00000, 0.00000, 0.00000),\n\tvec3(1.00000, 0.00000, 0.00000), vec3(1.00000, 0.00000, 0.00000), vec3(1.00000, 0.00000, 0.00000),\n\tvec3(0.00000, 1.00000, 0.00000), vec3(0.00000, 1.00000, 0.00000), vec3(0.00000, 1.00000, 0.00000),\n\tvec3(0.00000, -1.00000, 0.00000), vec3(0.00000, -1.00000, 0.00000), vec3(0.00000, -1.00000, 0.00000),\n\tvec3(0.00000, 0.00000, 1.00000), vec3(0.00000, 0.00000, 1.00000), vec3(0.00000, 0.00000, 1.00000),\n\tvec3(0.00000, 0.00000, 1.00000), vec3(0.00000, 0.00000, 1.00000), vec3(0.00000, 0.00000, 1.00000),\n\tvec3(0.00000, 1.00000, 0.00000), vec3(0.00000, 1.00000, 0.00000), vec3(0.00000, 1.00000, 0.00000),\n\tvec3(0.00000, -1.00000, 0.00000), vec3(0.00000, -1.00000, 0.00000), vec3(0.00000, -1.00000, 0.00000),\n\tvec3(-1.00000, 0.00000, 0.00000), vec3(-1.00000, 0.00000, 0.00000), vec3(-1.00000, 0.00000, 0.00000),\n\tvec3(0.00000, 0.00000, -1.00000), vec3(0.00000, 0.00000, -1.00000), vec3(0.00000, 0.00000, -1.00000),\n\tvec3(-1.00000, 0.00000, 0.00000), vec3(-1.00000, 0.00000, 0.00000), vec3(-1.00000, 0.00000, 0.00000),\n\tvec3(0.00000, 0.00000, -1.00000), vec3(0.00000, 0.00000, -1.00000), vec3(0.00000, 0.00000, -1.00000)\n);\nvec2 uvs[36] = vec2[](\n\tvec2(1.00000, 1.00000), vec2(1.00000, 0.50000), vec2(0.00000, 1.00000),\n\tvec2(0.00000, 1.00000), vec2(0.00000, 0.50000), vec2(1.00000, 0.50000),\n\tvec2(0.00000, 0.00000), vec2(0.00000, 1.00000), vec2(1.00000, 0.00000),\n\tvec2(0.00000, 0.00000), vec2(0.00000, 1.00000), vec2(1.00000, 0.00000),\n\tvec2(0.00000, 1.00000), vec2(1.00000, 1.00000), vec2(0.00000, 0.50000),\n\tvec2(1.00000, 1.00000), vec2(0.00000, 1.00000), vec2(0.00000, 0.50000),\n\tvec2(0.00000, 1.00000), vec2(1.00000, 0.00000), vec2(1.00000, 1.00000),\n\tvec2(0.00000, 1.00000), vec2(1.00000, 0.00000), vec2(1.00000, 1.00000),\n\tvec2(0.00000, 0.93750), vec2(7.00000, 0.93750), vec2(7.00000, 0.68750),\n\tvec2(5.50000, 0.81250), vec2(5.50000, 0.56250), vec2(0.00000, 0.56250),\n\tvec2(0.00000, 0.56250), vec2(7.00000, 0.81250), vec2(7.00000, 0.56250),\n\tvec2(0.00000, 0.81250), vec2(5.50000, 0.56250), vec2(0.00000, 0.56250)\n);*/\n\n//constants\nconst float PI = 3.14159265359;\nconst float playerWalk = 0.01;\nconst float playerSprint = 0.02;\nconst float playerJump = 0.6;\nconst float playerFly = 0.02;\nconst float gravity = 0.02;\nconst float playerHeight = 2.5;\nconst float playerRadius = 0.5;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n//returns a point rotated in 3d (radians)\nvec3 rotate3d(vec3 point, vec3 angle, vec3 origin){ \n    point -= origin; //subtract pivot\n    //calculate consts\n    float cx = cos(angle.x);\n    float sx = sin(angle.x);\n    float cy = cos(angle.y);\n    float sy = sin(angle.y);\n    float cz = cos(angle.z);\n    float sz = sin(angle.z);\n    //rotate point\n    point *= mat3(\n        cy*cz, sx*sy*cz - cx*sz, cx*sy*cz + sx*sz,\n        cy*sz, sx*sy*sz + cx*cz, cx*sy*sz - sx*cz,\n        -sy, sx*cy, cx*cy\n    );\n    point += origin; //add pivot\n    return point;\n}\n\n//returns the normal of 3 points\nvec3 getNormal(vec3 a, vec3 b, vec3 c) { \n    return normalize(cross(c - a, b - a));\n}\n\n//returns the center point of 3 points\nvec3 getCenter(vec3 a, vec3 b, vec3 c){ \n    return (a + b + c)/3.0;\n}\n\n//returns the closest point on a line segment to a point\nvec3 closestOnSegment(vec3 A, vec3 B, vec3 Point) {\n    vec3 AB = B - A;\n    float t = dot(Point - A, AB) / dot(AB, AB);\n    return A + clamp(t,0.0,1.0) * AB; \n}\n\n//returns the barycentric coordinates of a point\nvec3 getBary(in vec3 p1, in vec3 p2, in vec3 p3, in vec3 p0)\n{\n    vec3 a = p2 - p3;\n    vec3 b = p1 - p3;\n    vec3 c = p0 - p3;\n    float ab = dot(a,b);\n    float ac = dot(a,c);\n    float bc = dot(b,c);\n    float m = dot(a,a);\n    float n = dot(b,b);\n    float d = m * n - ab*ab;\n    float u = (m * bc - ab * ac) / d;\n    float v = (n * ac - ab * bc) / d;\n    float w = 1.0 - u - v;\n    return vec3(u,v,w);\n}\n\n//returns a point cast onto a plane\nvec3 castToPlane(vec3 point, vec3 normal, vec3 a) {\n    float dist = dot(normal, point - a);\n    return point - dist * normal; \n}\n\n//returns the intersection of a plane r and a ray\nfloat planeRayIntersect(vec3 rayDir, vec3 rayOrigin, vec3 center, vec3 normal) { \n    float denom = dot(rayDir,normal);\n    if (denom != 0.0){ //ray is parralel if 0\n        float dist = dot(center - rayOrigin, normal)/denom;\n        if (dist >= 0.0){\n            return dist; //distance along ray to intersection point\n        }\n    }\n    return -1.0; //ray doesn't intersect\n}\n\n//returns the distance from a ray to the edges of a triangle (not really)\nfloat getTriEdgeDist(vec3 a, vec3 b, vec3 c, vec3 p){\n    float distAB = distance(p,closestOnSegment(a,b,p));\n    float distBC = distance(p,closestOnSegment(b,c,p));\n    float distCA = distance(p,closestOnSegment(c,a,p));\n    return min(distAB, min(distBC, distCA));\n}\n\n//returns whether  a point lies on a triangle\nbool isInTriangle(vec3 p,vec3 a,vec3 b,vec3 c){\n    vec3 bary = getBary(a,b,c,p);\n    return bary.x > 0.0 && bary.y > 0.0 && bary.x + bary.y < 1.0;\n}\n\n//returns the closest point on a triangle to a point\nvec3 closestPointOnTriangle(vec3 a, vec3 b, vec3 c, vec3 p, vec3 normal){\n    vec3 planePoint = castToPlane(p,normal,a);\n    \n    if (!isInTriangle(planePoint,a,b,c)){\n        float planeDist = distance(planePoint, p);\n\n        vec3 closestAB = closestOnSegment(a,b,p);\n        vec3 closestBC = closestOnSegment(b,c,p);\n        vec3 closestCA = closestOnSegment(c,a,p);\n        \n        float distAB = distance(closestAB,p);\n        float distBC = distance(closestBC,p);\n        float distCA = distance(closestCA,p);\n        \n        if (distAB <= distBC && distAB <= distCA){\n            return closestAB;\n        } else if (distBC <= distAB && distBC <= distCA){\n            return closestBC;\n        } else if (distCA <= distAB && distCA <= distBC){\n            return closestCA;\n        }\n    }\n    return planePoint;\n}\n\n//returns the closest point on a given line segment to a triangle\nvec3 closestPointOnLineSegmentToTri(vec3 a, vec3 b, vec3 c, vec3 p1, vec3 p2, vec3 normal, vec3 center) {\n    float segmentLength = length(p2-p1);\n    vec3 segmentDir = (p2-p1)/segmentLength;\n    float distAlongSegment = clamp(planeRayIntersect(segmentDir,p1,center,normal),0.0,segmentLength);\n    return p1 + segmentDir*distAlongSegment;\n}\n\n// https://iquilezles.org/articles/intersectors/\n// capsule defined by extremes pa and pb, and radious ra\n// Note that only ONE of the two spherical caps is checked for intersections,\n// which is a nice optimization\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float ra )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h >= 0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        // body\n        if( y>0.0 && y<baba ) return t;\n        // caps\n        vec3 oc = (y <= 0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - ra*ra;\n        h = b*b - c;\n        if( h>0.0 ) return -b - sqrt(h);\n    }\n    return -1.0;\n}\n\n//https://www.shadertoy.com/view/Xt3SzX\n// cap normal \n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return (pa - h*ba)/r;\n}\n\n//random functions from //https://www.shadertoy.com/view/4djSRW\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//https://iquilezles.org/articles/smin/\n//power smooth min (k=8)\nfloat smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nfloat voronoi4d(vec4 uv){\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                for (int w = -1; w < 2; w++){\n                    n = smin(n,distance(floor(uv) + vec4(x,y,z,w) + hash44(floor(uv) + vec4(x,y,z,w)),uv),2.0);\n                }\n            }\n        }\n    }\n    return n;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//player movement\n\nconst int W = 87;\nconst int A = 65;\nconst int S = 83;\nconst int D = 68;\nconst int SPACE = 32;\nconst int SHIFT = 16;\nconst int CTRL = 17;\nconst int F = 70;\n\nint keyPressed(int key){\n    return (texelFetch( iChannel1, ivec2(key, 0),0 ).x > 0.0) ? 1 : 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    \n    \n    if (floor(fragCoord) == vec2(0,0)){\n        //fetch last pos and rotation \n        vec3 rotation = texelFetch(iChannel0, ivec2(1,0), 0).xyz;\n        vec3 velocity = texelFetch(iChannel0, ivec2(0,0), 0).xyz;\n        bool grounded = texelFetch(iChannel0, ivec2(3,0), 0).w == 1.0;\n        bool isFly = (texelFetch(iChannel0, ivec2(5,0), 0).x == 1.0);\n        //rotate velocity by camera y rotation\n        velocity += rotate3d( \n            vec3(\n                float(keyPressed(D) - keyPressed(A)),\n                0,\n                float(keyPressed(W) - keyPressed(S))\n            ) * (keyPressed(CTRL) == 1 ? playerSprint : playerWalk), \n            vec3(0, rotation.y, 0), \n            vec3(0)\n        );\n        \n        velocity *= 0.90;\n        \n        if (isFly){\n            velocity.y += float(keyPressed(SPACE) - keyPressed(SHIFT))*playerFly;\n        } else {\n            if (grounded){\n                if (keyPressed(SPACE) == 1){\n                    velocity.y = playerJump;\n                } \n            } else {\n                velocity.y -= gravity;\n            }\n        }\n        \n        col = vec4(velocity,0); \n    }\n    \n    if (floor(fragCoord) == vec2(1,0)){//rotation\n        vec2 draggedMouse = texelFetch(iChannel0, ivec2(4,0), 0).xy/iResolution.xy*2.0 - 1.0;\n        vec3 rotation = vec3(clamp(-draggedMouse.y*PI,-PI/2.0,PI/2.0), draggedMouse.x*PI, 0); \n        col = vec4(rotation,0); \n    }\n    \n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    \n    //collision resolution\n    if (floor(fragCoord) == vec2(3,0)){//position\n        vec3 pos = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n        vec3 vel = texelFetch(iChannel0, ivec2(0,0), 0).xyz;\n        bool grounded = false;\n        \n        pos += vel;\n        \n        if (pos.y < -40.0){\n            pos = vec3(0,5,0);\n        }\n        \n        //vec3 penetrationVec = vec3(-999);\n        for (int i = 0; i < tris.length()/3; i++){\n            //load tri vertices\n            vec3 v1 = tris[i*3];\n            vec3 v2 = tris[i*3+1];\n            vec3 v3 = tris[i*3+2];\n            //caspule collision detection\n            //calculate distance from line segment to triangle, if less than player radius, theres a collision\n            \n            vec3 normal = getNormal(v1,v2,v3);\n            vec3 center = getCenter(v1,v2,v3);\n            //the ends of the line segment\n            vec3 point1 = pos; //head\n            vec3 point2 = pos-vec3(0,playerHeight,0); //feet\n            \n            vec3 closestOnSegment = closestPointOnLineSegmentToTri(v1,v2,v3,point1,point2, center, normal);\n            \n            vec3 closestOnTri = closestPointOnTriangle(v1,v2,v3,closestOnSegment, normal);\n            \n            float dist = distance(closestOnTri, closestOnSegment);\n            \n            if (dist < playerRadius) {\n                grounded = true;\n                vec3 colnorm = normalize(closestOnTri - closestOnSegment);\n                float penetration = playerRadius - dist;\n                pos -= colnorm*penetration;\n            }\n        }\n        \n        col = vec4(pos,grounded);\n    }\n    \n    //dragged mouse pos\n    if (floor(fragCoord) == vec2(4,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(4,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(4,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(4,0), 0);\n        }\n    }\n    \n    if (floor(fragCoord) == vec2(5,0)){ //fly\n        bool isFly = (texelFetch(iChannel0, ivec2(5,0), 0).x == 1.0);\n        bool wasPressed = texelFetch(iChannel0, ivec2(5,0), 0).y == 1.0;\n        bool isPressed = keyPressed(F) == 1;\n        \n        if (isPressed && !wasPressed) {\n            if (isFly) {\n                isFly = false;\n            } else {\n                isFly = true;\n            }\n        }\n        col = vec4(isFly ?1 : 0, isPressed ? 1 : 0, 0, 0); \n    }\n    \n    fragColor = vec4(col);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//main drawing, alpha is depth map\n\nconst vec3 lightDirection = vec3(-0.2,-0.7,-0.1);\nconst vec3 lightColor = vec3(1.0,1.0,0.8);\nconst float diffuseAmount = 0.7; // 0 to 1\nconst float specularAmount = 0.3; // 0 to 1\nconst float ambientAmount = 0.5; // 0 to 1\nconst float shininessAmount = 10.0; // at least 1\nconst int ssao_samples = 10;\nconst float ssao_radius = 0.2;\nconst float shadowStrength = 1.0;\n\nvec3 surf_shader(vec3 v1, vec3 v2, vec3 v3, vec2 texCoord, vec3 bary, vec3 point, vec3 camPos, vec3 incident, vec3 normal, vec3 lightDirection, float depth, vec3 uv){ \n    vec3 col = vec3(0);\n    vec3 texCol = texelFetch(iChannel1, ivec2(texCoord*16.0),0).rgb;\n    lightDirection = normalize(lightDirection);\n    \n    //ssao\n    float intersections = 0.0;\n    for (int samples = 0; samples < ssao_samples; samples ++){\n        vec3 direction = normalize(hash33((point + float(samples))*100.0)*2.0 - 1.0);\n        if (dot(direction,normal) < 0.0){\n            direction = reflect(direction, normal);\n        }\n        vec3 samplePoint = point + direction*ssao_radius;\n        //need to loop for all tris\n        for (int i = 0; i < tris.length()/3; i++){\n            vec3 a = tris[i*3]; \n            vec3 b = tris[i*3+1];\n            vec3 c = tris[i*3+2];\n        \n            vec3 center = (a+b+c)/3.0;\n            vec3 norm = getNormal(a,b,c);\n            float intersect = planeRayIntersect(normalize(samplePoint - uv), uv, center, norm);\n            if (intersect < length(samplePoint - uv) && isInTriangle(uv + intersect*normalize(samplePoint - uv), a,b,c)){\n                intersections ++;\n                break;\n            }\n        }\n    }\n    float shadowing = intersections/float(ssao_samples);\n    \n    //shadows\n    for (int i = 0; i < tris.length()/3; i++){\n        vec3 a = tris[i*3]; \n        vec3 b = tris[i*3+1];\n        vec3 c = tris[i*3+2];\n        \n        vec3 center = (a+b+c)/3.0;\n        vec3 norm = getNormal(a,b,c);\n        float intersect = planeRayIntersect(-lightDirection, point, center, norm);\n        if (intersect > 0.01 && isInTriangle(point - intersect*lightDirection, a,b,c)){\n            shadowing += 1.0;\n            break;\n        }\n    }\n    \n    //lighting\n    float diffuseAngle = max(dot(-lightDirection,normal) - shadowing,0.0);\n    float specularAngle = max(dot(reflect(lightDirection,normal),-incident),0.0);\n    \n    vec3 ambient = texCol*ambientAmount;\n    vec3 diffuse = texCol*diffuseAngle*diffuseAmount;\n    vec3 specular = lightColor*pow(specularAngle,shininessAmount)*specularAmount;\n    \n    col = diffuse + specular + ambient;\n    \n    //fog\n    col = mix(col,vec3(0.8),smoothstep(30.0,40.0,depth));\n    //col = vec3(occlusion);\n    /*vec3 center = (v1+v2+v3)/3.0;\n    vec3 pointOnPlane = uv + planeRayIntersect(incident, uv, center, normal)*incident;\n    col = getTriEdgeDist(v1,v2,v3,pointOnPlane) <= 0.03 ? vec3(1) : col;*/\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camPos = texelFetch(iChannel0, ivec2(3,0), 0).xyz + vec3(0,playerHeight,0);\n    vec3 camRot = texelFetch(iChannel0, ivec2(1,0), 0).xyz;\n\n    vec3 uv = vec3((fragCoord - iResolution.xy*0.5)/iResolution.y * 2.0, 1.0); //center uv on center of screen from 1 to -1\n    float pxunit = 2.0/iResolution.y;\n    vec3 rayDir = normalize(uv); //set the direction of the ray for the pixel\n    uv = rotate3d(uv, camRot, vec3(0));\n    rayDir = rotate3d(rayDir, camRot, vec3(0));\n    uv += camPos; //offset uv by position\n    \n    vec3 col = vec3(0); //set base color to black\n    float depth = -1.0; //set base depth to -1\n    int closestTri = 0;\n    vec3 closestPoint = vec3(0);\n    vec3 closestNormal = vec3(0,1,0);\n    \n    // initialize vertices of triangle\n    vec3 v1 = vec3(0); \n    vec3 v2 = vec3(0);\n    vec3 v3 = vec3(0);\n    \n    //loop through triangles\n    for (int i = 0; i < tris.length()/3; i++){\n        //load tri vertices\n        v1 = tris[i*3]; \n        v2 = tris[i*3+1];\n        v3 = tris[i*3+2];\n        \n        vec3 center = getCenter(v1,v2,v3); // get the center of the triangle\n        vec3 normal = getNormal(v1,v2,v3); // get the normal of the triangle\n        float planeDist = planeRayIntersect(rayDir, uv, center, normal); //get the distance from the ray origin to the plane the triangle lies on\n        vec3 pointOnPlane = uv + rayDir*planeDist; // get the point the ray intersects the plane\n        if (planeDist == -1.0) continue; // skip if ray does not intersect plane\n        \n        if (isInTriangle(pointOnPlane, v1, v2, v3) && (planeDist < depth || depth == -1.0)) { // check if point is on the triangle\n            depth = planeDist; // set the depth of the depthmap\n            closestTri = i;\n            closestPoint = pointOnPlane;\n        }\n    }\n    \n    if (depth != -1.0) { //objects\n        vec3 v1 = tris[closestTri*3];\n        vec3 v2 = tris[closestTri*3+1];\n        vec3 v3 = tris[closestTri*3+2];\n        \n        vec3 bary = getBary(v1, v2, v3, closestPoint);\n        vec2 texCoord = bary.x*uvs[closestTri*3] + bary.y*uvs[closestTri*3+1] + bary.z*uvs[closestTri*3+2];\n        \n        vec3 normal = norms[closestTri*3]*bary.x + norms[closestTri*3+1]*bary.y + norms[closestTri*3+2]*bary.z;\n        col = surf_shader(v1,v2,v3, texCoord, bary, closestPoint, camPos, rayDir, normal, lightDirection, depth, uv);\n    \n    } else { //sky and lines\n        //sky gradient\n        col = mix(vec3(0.6,0.5,0.5), vec3(0.0, 0.5, 1.0), rayDir.y/2.0 +0.5);\n        \n        float rl = dot(rayDir, -lightDirection);\n        \n        //sun\n        col = mix(col,mix(vec3(1,1,0),vec3(1),rl*rl*20.0-9.65),smoothstep(0.0, 0.03, rl-0.7));\n        \n        //clouds\n        float cloudScale = 1.0/rayDir.y;\n        int cloudSteps = 3;\n        float cloudDist = planeRayIntersect(rayDir, uv, vec3(0,50,0), vec3(0,1,0));\n        float cloudDist2 = planeRayIntersect(rayDir, uv, vec3(0,40,0), vec3(0,1,0));\n        if (cloudDist >= 0.0 || cloudDist2 >= 0.0){\n            float cloudStep = cloudDist2 - cloudDist;\n            float n = 0.0;\n            for (int i = 0; i < cloudSteps; i++)\n                n += voronoi4d(vec4(cloudDist*rayDir + cloudStep*rayDir*float(i), 1)*0.01);\n            col = vec3(n/10.0);\n        }\n        /*if (rayDir.y >= 0.0){\n            col = mix(vec3(0.8+n/4.0),col, smoothstep(0.0,0.4, n-0.3));\n        }*/\n        \n        //fog\n        col = mix(vec3(0.8),col,abs(rayDir.y));\n        \n        //axis lines\n        col = mix(vec3(0,1,0),col,smoothstep(0.0, pxunit, abs(rayDir.y)));\n        col = mix(vec3(1,0,0),col,smoothstep(0.0, pxunit, abs(rayDir.x)));\n        col = mix(vec3(0,0,1),col,smoothstep(0.0, pxunit, abs(rayDir.z)));\n    }\n    \n    /*vec3 offset = vec3(-1, 0,0);\n    vec3 point1 = camPos + offset; //head\n    vec3 point2 = vec3(camPos.x,camPos.y+(playerHeight-playerRadius), camPos.z) + offset; //feet\n    float player_render = capIntersect( uv, rayDir, point1, point2, playerRadius);\n    \n    if (player_render != -1.0){\n        vec3 intersect = uv + rayDir*player_render;\n        col = surf_shader(vec3(0), vec3(0), vec3(0), vec2(0), intersect, rayDir, capNormal(intersect, point1, point2, playerRadius), lightDirection, player_render, uv);\n    }*/\n    \n    fragColor = vec4(col,depth);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}