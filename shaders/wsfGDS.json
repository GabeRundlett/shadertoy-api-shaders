{
    "Shader": {
        "info": {
            "date": "1547336790",
            "description": "Been mesmerised since seeing [url=https://www.youtube.com/watch?v=1_pzjvVixL0]this animation by Jason Hise[/url]. Had a few failed attempts at creating it with sphere inversion, but this 4d stereographic projection works well with some hacks.",
            "flags": 0,
            "hasliked": 0,
            "id": "wsfGDS",
            "likes": 100,
            "name": "Clifford Torus Rotation",
            "published": 3,
            "tags": [
                "4d",
                "stereographic"
            ],
            "usePreview": 1,
            "username": "tdhooper",
            "viewed": 4509
        },
        "renderpass": [
            {
                "code": "/*\n\n    Clifford Torus Rotation\n    -----------------------\n\n    Getting a good distance for this 4D stereographic projection was\n    tricky, see the notes in 'Main SDF', or just toggle DEBUG below to\n    see what's going on.\n\n    Big thanks to Matthew Arcus (mla) for providing a better torus\n    equation and improving the projection distance fix.\n\n    See also:\n\n    * Animation by Jason Hise https://www.youtube.com/watch?v=1_pzjvVixL0\n    * Clifford Torus by mla https://www.shadertoy.com/view/3ss3z4\n    * https://en.wikipedia.org/wiki/Clifford_torus\n    * http://virtualmathmuseum.org/Surface/clifford_torus/clifford_torus.html\n\n*/\n\n//#define DEBUG\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 pMod2(inout vec2 p, vec2 size) {\n    vec2 c = floor((p + size*0.5)/size);\n    p = mod(p + size*0.5,size) - size*0.5;\n    return c;\n}\n\nfloat smax(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n    return length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n\n// --------------------------------------------------------\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// Main SDF\n// --------------------------------------------------------\n\n// Inverse stereographic projection of p,\n// p4 lies onto the unit 3-sphere centered at 0.\n// - mla https://www.shadertoy.com/view/lsGyzm\nvec4 inverseStereographic(vec3 p, out float k) {\n    k = 2.0/(1.0+dot(p,p));\n    return vec4(k*p,k-1.0);\n}\n\nfloat fTorus(vec4 p4, out vec2 uv) {\n\n    // Torus distance\n    // We want the inside and outside to look the same, so use the\n    // inverted outside for the inside.\n    float d1 = length(p4.xy) / length(p4.zw) - 1.;\n    float d2 = length(p4.zw) / length(p4.xy) - 1.;\n    float d = d1 < 0. ? -d1 : d2;\n\n    // Because of the projection, distances aren't lipschitz continuous,\n    // so scale down the distance at the most warped point - the inside\n    // edge of the torus such that it is 1:1 with the domain.\n    d /= PI;\n\n    // UV coordinates over the surface, from 0 - 1\n    uv = (vec2(\n        atan(p4.y, p4.x),\n        atan(p4.z, p4.w)\n    ) / PI) * .5 + .5;\n\n    return d;\n}\n\n// Distances get warped by the stereographic projection, this applies\n// some hacky adjustments which makes them lipschitz continuous.\n\n// The numbers have been hand picked by comparing our 4D torus SDF to\n// a usual 3D torus of the same size, see DEBUG.\n\n// vec3 d\n//   SDF to fix, this should be applied after the last step of\n//   modelling on the torus.\n\n// vec3 k\n//   stereographic scale factor\n\nfloat fixDistance(float d, float k) {\n    float sn = sign(d);\n    d = abs(d);\n    d = d / k * 1.82;\n    d += 1.;\n    d = pow(d, .5);\n    d -= 1.;\n    d *= 5./3.;\n    d *= sn;\n    return d;\n}\n\nfloat time;\nvec2 modelUv;\nbool hitDebugTorus = false;\n\nfloat map(vec3 p) {\n\n    #ifdef DEBUG\n        if (p.x < 0.) {\n            hitDebugTorus = true;\n            return fTorus(p.xzy, 1., 1.4145);\n        }\n    #endif\n\n    float k;\n    vec4 p4 = inverseStereographic(p,k);\n\n    // The inside-out rotation puts the torus at a different\n    // orientation, so rotate to point it at back in the same\n    // direction\n    pR(p4.zy, time * -PI / 2.);\n\n    // Rotate in 4D, turning the torus inside-out\n    pR(p4.xw, time * -PI / 2.);\n\n    vec2 uv;\n    float d = fTorus(p4, uv);\n    modelUv = uv;\n\n    #ifdef DEBUG\n        d = fixDistance(d, k);\n        return d;\n    #endif\n\n    // Recreate domain to be wrapped around the torus surface\n    // xy = surface / face, z = depth / distance\n    float uvScale = 2.25; // Magic number that makes xy distances the same scale as z distances\n    p = vec3(uv * uvScale, d);\n\n    // Draw some repeated circles\n\n    float n = 10.;\n    float repeat = uvScale / n;\n\n    p.xy += repeat / 2.;\n    pMod2(p.xy, vec2(repeat));\n\n    d = length(p.xy) - repeat * .4;\n    d = smax(d, abs(p.z) - .013, .01);\n\n    d = fixDistance(d, k);\n\n    return d;\n}\n\nbool hitDebugPlane = false;\n\nfloat mapDebug(vec3 p) {\n    float d = map(p);\n    #ifndef DEBUG\n        return d;\n    #endif\n    float plane = min(abs(p.z), abs(p.y));\n    hitDebugPlane = plane < abs(d);\n    //hitDebugPlane = true;\n    return hitDebugPlane ? plane : d;\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nvec3 calcNormal(vec3 p) {\n  vec3 eps = vec3(.0001,0,0);\n  vec3 n = vec3(\n    map(p + eps.xyy) - map(p - eps.xyy),\n    map(p + eps.yxy) - map(p - eps.yxy),\n    map(p + eps.yyx) - map(p - eps.yyx)\n  );\n  return normalize(n);\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nconst float ITER = 400.;\nconst float MAX_DIST = 12.;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    time = mod(iTime / 2., 1.);\n    #ifdef DEBUG\n        time = iTime / 6.;\n    #endif\n\n    vec3 camPos = vec3(1.8, 5.5, -5.5);\n    vec3 camTar = vec3(.1,0,.1);\n    vec3 camUp = vec3(-1,0,-1.5);\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camUp);\n\n    float focalLength = 2.4;\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n\n    vec3 rayDirection = normalize(camMat * vec3(p, focalLength));\n    vec3 rayOrigin = camPos;\n    vec3 rayPosition = rayOrigin;\n    float rayLength = 0.;\n\n    float distance = 0.;\n    vec3 color = vec3(0);\n\n    for (float i = 0.; i < ITER; i++) {\n        rayLength += distance;\n        rayPosition = rayOrigin + rayDirection * rayLength;\n        distance = mapDebug(rayPosition);\n\n        if (distance < .001) {\n            vec3 normal = calcNormal(rayPosition);\n            color = vec3(dot(normalize(vec3(1,.5,0)), normal) * .5 + .5);\n\n            #ifdef DEBUG\n                if (hitDebugPlane) {\n                    // Display distance\n                    float d = map(rayPosition);\n                    color = vec3(mod(abs(d) * 10., 1.));\n                    color *= spectrum(abs(d));\n                    color = mix(color, vec3(1), step(0., -d) * .25);\n                } else if ( ! hitDebugTorus) {\n                    // Color UVs\n                    float repeat = 1. / 20.;\n                    pMod2(modelUv, vec2(repeat));\n                    color -= color * vec3(0,1,0) * smoothstep(0., .001, abs(modelUv.x) - repeat * .4);\n                    color -= color * vec3(1,0,0) * smoothstep(0., .001, abs(modelUv.y) - repeat * .4);\n                }\n            #endif\n\n            break;\n        }\n\n        if (rayLength > MAX_DIST) {\n            break;\n        }\n    }\n\n    #ifndef DEBUG\n        float fog = pow(smoothstep(7.25, MAX_DIST, rayLength), .25);\n        color = mix(color, vec3(0), fog);\n        color = spectrum((color.r * 2. - 1.) * .2 + .4);\n        color *= mix(1., .025, fog);\n    #endif\n\n    color = pow(color, vec3(1. / 2.2)); // Gamma\n    fragColor = vec4(color, 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}