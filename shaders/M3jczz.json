{
    "Shader": {
        "info": {
            "date": "1727394418",
            "description": "Cross-eyed 3D\nSit as far back from the screen as possible\nSlightly cross your eyes so that there is a third image in the middle.\nRelax your gaze, and concentrate only on that middle image, which is in 3D.\n",
            "flags": 48,
            "hasliked": 0,
            "id": "M3jczz",
            "likes": 5,
            "name": "SDF_Landscape",
            "published": 3,
            "tags": [
                "sdf",
                "stereo"
            ],
            "usePreview": 0,
            "username": "kosalos",
            "viewed": 114
        },
        "renderpass": [
            {
                "code": "// -----------------------------------------------------------\n// region.xy = lower left coord of source region (as 0 ... 1)\n// region.zw = size of source region (as 0 ... 1)\n// destPt    = lower left coord of destination (as 0 ... 1)\n// scale     = 1.0 == source size.  larger values = smaller copies\n// pixels are copied if their .w field > 0.\n\nvoid copyRegion(vec4 region,vec2 destPt,float scale,inout vec4 O, vec2 U) {\n    vec2 R = iResolution.xy;\n    vec2 srcPt = region.xy;\n    vec2 size = region.zw;\n    \n    destPt *= scale;\n    srcPt *= scale;\n    U *= scale;\n    \n    // current point within destination region?\n    vec2 sU = U/R - destPt;\n    if(sU.x < 0. || sU.x > size.x) return;\n    if(sU.y < 0. || sU.y > size.y) return;\n\n    vec4 srcPixel = texelFetch(iChannel0,ivec2(U-R*(destPt-srcPt)),0);\n    if(srcPixel.w > 0.) O = srcPixel;  \n}\n\n// -----------------------------------------------------------\n\nstruct keyFrameData {\n    float xoffset;\n    vec4 region;\n    vec2 dest;\n    float scale;\n};\n\nkeyFrameData[] keyFrames = keyFrameData[](\n    keyFrameData(0.,vec4(0.01,0.,1.05,0.66),vec2(0.,0.32),1.95),\n    keyFrameData(0.,vec4(0.01,0.,1.05,0.66),vec2(-0.02,0.39),1.6),\n    keyFrameData(0.,vec4(0.01,0.,1.05,0.66),vec2(-0.06,0.18),1.25),\n    keyFrameData(0.,vec4(0.01,0.,1.05,0.66),vec2(-0.24,-0.15),0.82));\n\n// -----------------------------------------------------------\n\n//#define DEVELOPMENT\n\nvoid mainImage(out vec4 O, vec2 U) {\n    // view the source image data in BufferA\n#ifdef DEVELOPMENT\n    O = texelFetch(iChannel0,ivec2(U),0);\n    return;\n#endif\n\n    if(keyClick(32,iChannel3)) {\n        O = texelFetch(iChannel0,ivec2(U),0);\n        return;\n    }\n    \n    // sky, ground background \n    O = (U.y > iResolution.y * 0.45) ? vec4(0.,0.,0.5,1.) : vec4(0.4,0.3,0.2,1.);\n\n    // stereo effect, farther back == less X offset\n    float parallax = 0.1;\n    for(int i=0;i<4;++i) {\n        keyFrames[i].xoffset = parallax;\n        parallax *= 1.1;\n     }\n    \n    float percent = float(iFrame % 100) * 0.01;\n    \n    for(int k1=0;k1<3;++k1) {\n        keyFrameData t = keyFrames[k1];\n        keyFrameData t2 = keyFrames[k1+1];\n        t.region = mix(t.region,t2.region,percent);\n        t.dest = mix(t.dest,t2.dest,percent);\n        t.scale = mix(t.scale,t2.scale,percent);\n        t.xoffset = mix(t.xoffset,t2.xoffset,percent);\n        \n        if(U.x < iResolution.x * 0.5) \n            t.dest -= vec2(t.xoffset,0.);  // left parallax offset\n        else\n            t.dest += vec2(0.3+t.xoffset,0.); // right p. offset + right side screen\n        \n        copyRegion(t.region,t.dest,t.scale,O,U);\n    }\n\n    if(abs(U.x - iResolution.x * 0.5) < 2.0) O.xyz = vec3(0.); // black center line\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": " Params t1 = Params(\n    0,0., // level, rndSeed\n    vec2(0.5,0.3), // position\n    0.15,0.03 , 0.7, // len,minLength,lengthShrink\n    PI * 0.5, PI * 0.2, // angle,angleRange\n    0.01,0.7, // thick,thickShrink\n    0.006, // fruit size\n    vec3(0.7,0.4,0.1),vec3(0.6,0.8,0.3), // truck color\n    vec3(0.1,0.9,0.),vec3(0.7,0.7,0.2),  // leaf color\n    vec3(1.,0.3,0.),vec3(0.7,0.7,0.)     // fruit color\n);\n\nvoid draw(inout vec4 O, vec2 U) {\n    vec2 R = iResolution.xy;\n    \n  //  gridBackground(R,O,U);\n  //  ivec2 I = ivec2(U);\n   // if((I.x %2) + (I.y %2) == 2)\n   // O = vec4(0.5);\n\n    for(float x = 0.;x< 1.;x+= 0.2) {\n        t1.position = vec2(x,0.06);\n        paramsPush(t1);\n        ground1(R,iTime,O,U);\n    }\n\n    t1.position = vec2(0.7,0.2);\n    paramsPush(t1);\n    tree1(R,iTime,O,U);\n    \n    t1.position = vec2(0.45,0.16);\n    paramsPush(t1);\n    bush1(R,iTime,O,U);\n    \n    t1.position = vec2(0.2,0.2);\n    t1.len = 0.1;\n    t1.tcolor1 = vec3(0.3,0.3,0.2);\n    t1.lcolor1 = vec3(0.3,0.3,0.2);\n    paramsPush(t1);\n    tree1(R,iTime -40.,O,U);\n    \n    t1.len *= 0.02;\n    t1.thick *= 0.2;\n    for(float x = 0.;x< 1.;x+= 0.2) {\n        t1.position = vec2(x,0.16);\n        paramsPush(t1);\n        rocks1(R,iTime,O,U);\n    } \n    \n    // mark corner for 'resolution changed' detection\n    if(U.x < 2. && U.y < 2.) O = vec4(iResolution.xy,0.,0.);\n}\n\n// ---------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 U) {\n    bool refresh = false;\n    \n    if(iFrame == 0 || keyClick(32,iChannel3)) \n        refresh = true;\n    else {\n        vec4 previousResolution = texelFetch(iChannel0,ivec2(0),0);\n        if(previousResolution.xy != iResolution.xy) refresh = true;\n    }\n\n    if(refresh) draw(O,U); else O = texelFetch(iChannel0,ivec2(U),0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float PI = acos(-1.);\n\nfloat ptLineDistance(vec2 pt,vec2 lineP1,vec2 lineP2) {\n    vec2 ab = lineP2-lineP1;\n    vec2 be = pt-lineP2;     \n    if(dot(ab,be) > 0.) return length(be);\n    vec2 ae = pt-lineP1;    \n    if(dot(ab,ae) < 0.) return length(ae); \n    return abs(ab.x * ae.y - ab.y * ae.x) / length(ab);\n}\n\nvoid drawLine(vec2 p1,vec2 p2, float width, vec3 color,inout vec4 O,vec2 U) {\n    float d = ptLineDistance(U,p1,p2);\n    if(d < width) {\n        float d2 = ptLineDistance(U - vec2(-width * 0.5,width * 0.5),p1,p2);\n        O = vec4(color - vec3(d2 / (width * 10.)),1.);\n    }\n}\n\nvoid drawCircle(vec2 pt, float radius, vec3 color,inout vec4 O,vec2 I) {\n    float d = length(I-pt);\n    if(d < radius) {\n        float d2 = length(I - vec2(-radius * 0.3,radius * 0.3) - pt);\n        O.xyz = color - vec3(d2 / (radius * 3.5));\n    }\n    if(abs(d - radius)< 1.) O.xyz = vec3(0.);\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\n// ---------------------------------------------------------\n// p,a,b,w:  render point, leaf endpoint1, endpoint2, width\n\nfloat sdOrientedVesica( vec2 p, vec2 a, vec2 b, float w ) {\n    float boundingSphere = length(p - a);\n    if(boundingSphere < w*2.) return 100.;\n    float r = 0.5*length(b-a);\n    float d = 0.5*(r*r-w*w)/w;\n    vec2 v = (b-a)/r;\n    vec2 c = (b+a)*0.5;\n    vec2 q = 0.5*abs(mat2(v.y,v.x,-v.x,v.y)*(p-c));\n    vec3 h = (r*q.x<d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n    return length( q-h.xy) - h.z;\n    \n    /* test suite:\n    vec2 R = iResolution.xy;\n    vec2 cc = R * 0.5;\n    vec2 dd = cc + vec2(cos(iTime)* 20.,sin(iTime)* 20.);\n    float d = sdOrientedVesica(U, cc, dd, 3.3);\n    if(d < 5.) O.xyz = vec3(0.8);\n    */\n}\n\n// ---------------------------------------------------------\n\nfloat oldRandom = -1.;\n\nfloat random(vec2 c) { // 0...1\n    oldRandom += sin( dot( vec2(1.317 - c.x,19.753 + c.y), c) * 413.7972); \n    return fract(oldRandom);\n} \n\nfloat randomValue(float seed,float vMax) {\n    return random(vec2(seed,vMax)) * vMax;\n}\n\n// ----------------------------------------------------------\n\nbool keyClick(int ascii,sampler2D channel) {\n    return (texture(channel,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode,sampler2D channel) {\n   return bool(texelFetch(channel, ivec2(keyCode,0), 0).x != 0.);\n}\n   \nbool getKeyClick(int keyCode,sampler2D channel) {\n   return bool(texelFetch(channel, ivec2(keyCode,1), 0).x != 0.);\n}\n\n// ---------------------------------------------------------\n\nbool iMod(int v,int m) { return (v/m)*m == v; }\n\nvoid gridBackground(vec2 R,inout vec4 O, vec2 U) { // R = resolution\n    O = vec4(0.,0.,0.,1.);  // w = 0.  -> transparent pixels\n    ivec2 I = ivec2(U);\n    ivec2 g50 = ivec2(R / 20.);\n    ivec2 g99 = ivec2(R / 10.);    \n    \n    \n    \n    if(iMod(I.x,g99.x) || iMod(I.y,g99.y)) O.xyz = vec3(0.5); else\n    if(iMod(I.x,g50.x) || iMod(I.y,g50.y)) O.xyz = vec3(0.7,0.,0.);\n}\n\n// ---------------------------------------------------------\n\nvec3 levelColor(vec3 c1,vec3 c2,int level) {\n  level = min(level,8);\n  return c1 + (c2-c1)* float(level) * 0.125;\n}\n\nvec3 randomColor(vec3 c1,vec3 c2,float rndSeed) {\n  return c1 + (c2-c1)* randomValue(rndSeed,1.0);\n}\n\n// ---------------------------------------------------------\n\nstruct Params {\n    int level;\n    float rndSeed;\n    vec2 position;\n    float len,minLength,lengthShrink; // trunk length\n    float angle,angleRange;  // trunk branching angle\n    float thick,thickShrink; // trunk thickness\n    float fruitSize;       // 0. == no fruit\n    vec3 tcolor1,tcolor2;  // truck color\n    vec3 lcolor1,lcolor2;  // leaf color\n    vec3 fcolor1,fcolor2;  // fruit color\n};\n\nint datasetIndex = 0;\n#define MAXDATASET 10\nParams[MAXDATASET] datasets;\n\nvoid paramsPush(Params data) { \n    datasetIndex = clamp(datasetIndex,0,MAXDATASET-1);\n    datasets[datasetIndex++] = data; \n    datasetIndex = min(datasetIndex,MAXDATASET-1); \n}\n\nbool paramsPop(inout Params dest) { \n    if(datasetIndex > 0) {\n        dest = datasets[--datasetIndex]; \n        return true;\n    }\n    \n    datasetIndex = 0;\n    return false; \n}\n\n// ---------------------------------------------------------\n\nvoid leaf(vec2 p1, float angle, vec2 R,vec3 color,inout vec4 O, vec2 U) {\n    vec2 p2 = p1 + R * 0.025 * vec2(cos(angle),sin(angle));\n    float d = sdOrientedVesica(U, p1,p2, 0.0025 * R.x);\n    if(d < 5.) {\n        O = vec4(color,1.);\n        if(abs(d - 5.) < 1.) O.xyz = vec3(0.);\n    }\n}\n\n// ---------------------------------------------------------\n\nvoid tree1(vec2 R,float rndSeed,inout vec4 O, vec2 U) { // R = window resolution\n    vec2 p1,p2,p2R;\n    vec3 color;\n    Params q,q2;\n    \n    q.level = 0;\n    q.rndSeed = rndSeed;\n    float ss = sin(rndSeed);\n    \n    while(true) {\n        if(!paramsPop(q)) break;\n        \n        p1 = q.position;\n        p2 = p1 + rotate(vec2(q.len,0.),q.angle);\n        p2R = p2 * R;\n        color = levelColor(q.tcolor1,q.tcolor2,q.level);\n        drawLine(p1 * R,p2R, q.thick * R.x,color,O,U);\n        \n        color = randomColor(q.lcolor1,q.lcolor2,q.rndSeed);        \n        leaf(p2R,q.angle,R,color,O,U);\n        \n        if(q.fruitSize > 0.0 && q.level > 2) {\n            float sz = q.fruitSize * (0.9 + randomValue(q.rndSeed,0.2)) * R.x;\n            color = randomColor(q.fcolor1,q.fcolor2,q.rndSeed);        \n            drawCircle(p2R,sz,color,O,U);\n        }\n        \n        if(q.len >= q.minLength) {\n            q.level += 1;\n            q.rndSeed = randomValue(q.rndSeed,1.);\n            q.len *= q.lengthShrink;\n            q.thick *= q.thickShrink;\n            q2 = q;\n            \n            // left branch\n            q.position = p2;\n            q.angle += 0.4 + ss * 0.1;\n            paramsPush(q);\n\n            // right branch\n            q2.position += (p2 - p1) * 0.6;\n            q2.angle += (-0.5 + ss * 0.14);\n            paramsPush(q2);\n        }\n    }\n}\n\n// ---------------------------------------------------------\n\nvoid bush1(vec2 R,float rndSeed,inout vec4 O, vec2 U) { // R = window resolution\n    vec2 p1,p2,p2R;\n    vec3 color;\n    Params q,q2;\n    \n    while(true) {\n        if(!paramsPop(q)) break;\n        float ss = sin(q.rndSeed);\n        \n        p1 = q.position;\n        p2 = p1 + rotate(vec2(q.len,0.),q.angle);\n        p2R = p2 * R;\n        color = levelColor(q.tcolor1,q.tcolor2,q.level);\n        drawLine(p1 * R,p2R, q.thick * R.x,color,O,U);\n        \n        color = randomColor(q.lcolor1,q.lcolor2,q.rndSeed);        \n        leaf(p2R,q.angle,R,color.zxy,O,U);\n        \n        if(q.fruitSize > 0.0 && q.level > 2 && randomValue(q.rndSeed,1.) < 0.3) {\n            float sz = q.fruitSize * (0.9 + randomValue(q.rndSeed,0.2)) * R.x;\n            color = randomColor(q.fcolor1,q.fcolor2,q.rndSeed);        \n            drawCircle(p2R,sz,color.zyx,O,U);\n        }\n        \n        if(q.len >= q.minLength) {\n            q.level += 1;\n            q.rndSeed = randomValue(q.rndSeed,1.);\n            q.len *= q.lengthShrink * 0.7;\n            q.thick *= q.thickShrink;\n            \n            // left branches\n            q2 = q;\n            q2.position = p2;\n            q2.angle += 0.4 + ss * 0.1;\n            paramsPush(q2);\n            q2 = q;\n            q2.position += (p2 - p1) * 0.6;\n            q2.angle -= (-0.5 + ss * 0.14);\n            paramsPush(q2);\n\n            // right branch\n            q2 = q;\n            q2.position = p2;\n            q2.angle -= (0.4 + ss * 0.1);\n            paramsPush(q2);\n            q2 = q;\n            q2.position += (p2 - p1) * 0.6;\n            q2.angle += (-0.5 + ss * 0.14);\n            paramsPush(q2);\n        }\n    }\n}\n\n// ---------------------------------------------------------\n\nvoid rocks1(vec2 R,float rndSeed,inout vec4 O, vec2 U) { // R = window resolution\n    Params q;    \n    if(!paramsPop(q)) return;\n    vec2 p1,p2;\n    vec3 color;\n    float x,y;\n    float r = random(vec2(q.rndSeed,fract(q.rndSeed)));\n    \n    for(int i=0;i<200;++i) {\n       q.thick = 0.01 + random(vec2(q.rndSeed,r)) * 0.01;\n       r = random(vec2(q.rndSeed,r));\n       x = (-10. + r * 20.) * q.len * 4. + q.thick * 3.;\n       r = random(vec2(q.rndSeed,r));\n       y = (-15. + r * 20.) * q.len * 2. + q.thick * 3.;\n       p1 = q.position + vec2(x,y);\n       p2 = (p1 + vec2(q.len,0.)) * R;\n       color = randomColor(q.tcolor1,q.tcolor2,q.rndSeed);\n       drawLine(p1 * R,p2, q.thick * R.x,color,O,U);\n     }\n     \n    q.tcolor1 = vec3(0.); \n    for(int i=0;i<200;++i) {\n       q.thick = 0.005 + random(vec2(q.rndSeed,r)) * 0.002;\n       r = random(vec2(q.rndSeed,r));\n       x = (-10. + r * 20.) * q.len * 4. + q.thick * 3.;\n       r = random(vec2(q.rndSeed,r));\n       y = (-10. + r * 20.) * q.len * 2. + q.thick * 3.;\n       p1 = q.position + vec2(x,y);\n       p2 = (p1 + vec2(q.len,0.)) * R;\n       color = randomColor(q.tcolor1,q.tcolor2,q.rndSeed);\n       drawLine(p1 * R,p2, q.thick * R.x,color,O,U);\n     }\n}\n\n// ---------------------------------------------------------\n\nvoid ground1(vec2 R,float rndSeed,inout vec4 O, vec2 U) { // R = window resolution\n    Params q;    \n    if(!paramsPop(q)) return;\n    \n    vec2 p1 = q.position;\n    vec2 p2 = (p1 + vec2(q.len,0.)) * R;\n    vec3 color = levelColor(q.tcolor1,q.tcolor2,q.level);\n\n    q.position += vec2(q.len * 0.25); \n    q.len *= 0.02;\n    q.thick *= 0.2;\n    paramsPush(q);\n    rocks1(R,rndSeed,O,U);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}