{
    "Shader": {
        "info": {
            "date": "1675880325",
            "description": "Iterative method to get the distance to a conic section\nComment first line to get a visualization of the method.\n\nThen you see the lagrange curve relative to the mouse in green, its asymptotes in red and the nearest point in black.",
            "flags": 0,
            "hasliked": 0,
            "id": "ctBSWR",
            "likes": 6,
            "name": "Signed distance to conic section",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "conicsection"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 210
        },
        "renderpass": [
            {
                "code": "/*\nAlso see https://www.shadertoy.com/view/mlB3RD\nand https://www.shadertoy.com/view/Dl2Xz1\n\nBasically, the nearest point ist found by\nintersection with a curve derived via lagrange multiplier.\n\nThe iteration is alternately doing a gradient descent\nto the conic and the \"lagrange curve\".\n\nAnother variant of the iteration is\ndoing a step perpendicular to the gradient of the conic\ninstead of the gradient descent step towards the \"lagrange curve\".\n\nThe nearest intersection of the asymptotes of the lagrange\ncurve and the conic is used as initial approximation.\n\nThere are some variants of this method used\nin different cases to ensure proper convergence.\n\nnum_iterations is the number of iterations in\none case, num_iterations2 in another case.\n*/\n\n#define SHOW_DISTANCE_FIELD\n#define ANIMATE\n\nconst int num_iterations = 6;\nconst int num_iterations2 = 10;\n\nfloat a_param = 30.;\nfloat b_param = -30.;\n//float a_param = -3.;\n//float b_param = -10.;\nfloat c_param = 0.;\nfloat d_param = 0.;\n\nvec3 bg_col = vec3(1);\nvec3 conic_col = vec3(0,0,1);\nvec3 lag_curve_col = vec3(0,1,0);\nvec3 asym_col = vec3(1,0,0);\nvec3 dot_col = vec3(0);\n\nfloat line_width = .001;\nfloat dot_size = .01;\n\nfloat zoom = 1.;\n\nconst float pi = 3.1415925;\n\nfloat conic_curve(vec2 p, out vec2 grad){\n\tgrad = vec2(2.*p.x*a_param + c_param, 2.*p.y*b_param + d_param);\n\treturn p.x*(p.x*a_param + c_param) + p.y*(p.y*b_param + d_param) + 1.;\n}\n\nfloat lagrange_curve(vec2 p, vec2 p2, out vec2 grad){\n    grad = vec2(2.*(a_param*(p.y-p2.y)-p.y*b_param) - d_param,\n                2.*(b_param*(p2.x-p.x)+p.x*a_param) + c_param);\n    return 2.*(p.x*a_param*(p.y-p2.y)-p.y*b_param*(p.x-p2.x)) + c_param*(p.y-p2.y) - d_param*(p.x-p2.x);\n}\n\nvec2 iteration(vec2 p, vec2 p2){\n\tfloat p_val1, p_val2;\n\tvec2 p_grad1, p_grad2;\n\n\tp_val2 = lagrange_curve(p,p2,p_grad2);\n\tp -= (p_grad2*p_val2)/dot(p_grad2,p_grad2);\n\n\tp_val1 = conic_curve(p,p_grad1);\n\tp -= (p_grad1*p_val1)/dot(p_grad1,p_grad1);\n\n\treturn p;\n}\n\nvec2 iteration2(vec2 p, vec2 p2){\n\tfloat p_val1, p_val2;\n\tvec2 p_grad1, p_grad2;\n\n\tp_val1 = conic_curve(p,p_grad1);\n\tvec2 tang = vec2(p_grad1.y, -p_grad1.x);\n\tp -= dot(p-p2,tang)/dot(tang,tang) * tang;\n\n\tp_val1 = conic_curve(p,p_grad1);\n\tp -= (p_grad1*p_val1)/dot(p_grad1,p_grad1);\n\n\treturn p;\n}\n\nvec2 nearest_point_to_conic(vec2 uv, out float sgn){\n\t// asymptotes of the lagrange curve\n\tfloat asym_x = -.5*(2.*b_param*uv.x + c_param)/(a_param - b_param);\n\tfloat asym_y = .5*(2.*a_param*uv.y + d_param)/(a_param - b_param);\n\n\tfloat x_discriminant = c_param * c_param - 4. * a_param * ((b_param*asym_y + d_param)*asym_y + 1.);\n\tfloat y_discriminant = d_param * d_param - 4. * b_param * ((a_param*asym_x + c_param)*asym_x + 1.);\n\n\tvec2 nearest_point = uv;\n\tfloat nearest_dist = 1e38;\n\n\tif(x_discriminant > 0.){\n\t\tfloat x_intersection1 = (-c_param + sqrt(x_discriminant))/(2.*a_param);\n\t\tvec2 cur_point1 = vec2(x_intersection1,asym_y);\n\t\tfloat cur_dis1 = distance(cur_point1,uv);\n\t\tif(cur_dis1 < nearest_dist){\n\t\t\tnearest_dist = cur_dis1;\n\t\t\tnearest_point = cur_point1;\n\t\t}\n\n\t\tfloat x_intersection2 = (-c_param - sqrt(x_discriminant))/(2.*a_param);\n\t\tvec2 cur_point2 = vec2(x_intersection2,asym_y);\n\t\tfloat cur_dis2 = distance(cur_point2,uv);\n\t\tif(cur_dis2 < nearest_dist){\n\t\t\tnearest_dist = cur_dis2;\n\t\t\tnearest_point = cur_point2;\n\t\t}\n\t}\n\tif(y_discriminant > 0.){\n\t\tfloat y_intersection1 = (-d_param + sqrt(y_discriminant))/(2.*b_param);\n\t\tvec2 cur_point1 = vec2(asym_x,y_intersection1);\n\t\tfloat cur_dis1 = distance(cur_point1,uv);\n\t\tif(cur_dis1 < nearest_dist){\n\t\t\tnearest_dist = cur_dis1;\n\t\t\tnearest_point = cur_point1;\n\t\t}\n\n\t\tfloat y_intersection2 = (-d_param - sqrt(y_discriminant))/(2.*b_param);\n\t\tvec2 cur_point2 = vec2(asym_x,y_intersection2);\n\t\tfloat cur_dis2 = distance(cur_point2,uv);\n\t\tif(cur_dis2 < nearest_dist){\n\t\t\tnearest_dist = cur_dis2;\n\t\t\tnearest_point = cur_point2;\n\t\t}\n\t}\n\n\tvec2 nor1;\n\tfloat val1 = conic_curve(uv, nor1);\n    sgn = sign(val1);\n\n\tif(distance(uv,iteration(uv,uv)) < distance(nearest_point,iteration(nearest_point,uv))){\n\t\tnearest_point = uv;\n\t}\n\n\tif(sign(a_param) != sign(b_param) || sgn < 0.){\n\t\tfor(int i=0;i<num_iterations;i++){\n\t\t\tnearest_point = iteration(nearest_point, uv);\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=0;i<num_iterations2;i++){\n\t\t\tnearest_point = iteration2(nearest_point, uv);\n\t\t}\n\t}\n\n\treturn nearest_point;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    #ifdef ANIMATE\n    a_param = mix(30.,-5.,sin(iTime));\n    b_param = mix(-30.,-10.,sin(iTime));\n    c_param = 0.;\n    d_param = 0.;\n    #endif\n\n\tvec2 uv = gl_FragCoord.xy/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n\tmouse -= .5;\n    mouse.x *= iResolution.x/iResolution.y;\n\n\tfloat border = 2./iResolution.y;\n\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\n\tuv *= zoom;\n\tmouse *= zoom;\n\tborder *= zoom;\n\n\tvec3 color = bg_col;\n\tfloat dis = 1e38;\n\n\tvec2 conic_grad;\n\tfloat conic_val = conic_curve(uv, conic_grad);\n\n\tdis = min(dis, abs(conic_val / length(conic_grad)) - line_width);\n\tcolor = mix(conic_col,color,smoothstep(0.,border,dis));\n\tdis = 1e38;\n    \n    float asym_x = -.5*(2.*b_param*mouse.x + c_param)/(a_param - b_param);\n    float asym_y = .5*(2.*a_param*mouse.y + d_param)/(a_param - b_param);\n    dis = min(dis,abs(uv.x-asym_x));\n    dis = min(dis,abs(uv.y-asym_y));\n    \n    color = mix(asym_col,color,smoothstep(0.,border,dis));\n    dis = 1e38;\n\n\tvec2 lag_curve_grad;\n\tfloat lag_curve_val = lagrange_curve(uv,mouse,lag_curve_grad);\n\n\tdis = min(dis, abs(lag_curve_val / length(lag_curve_grad)) - line_width);\n\tcolor = mix(lag_curve_col,color,smoothstep(0.,border,dis));\n\tdis = 1e38;\n\n    float sgn;\n\tvec2 nearest_point = nearest_point_to_conic(mouse, sgn);\n\n    dis = min(dis, distance(uv,nearest_point) - dot_size);\n\tcolor = mix(dot_col,color,smoothstep(0.,border,dis));\n    \n\t#ifdef SHOW_DISTANCE_FIELD\n\tnearest_point = nearest_point_to_conic(uv, sgn);\n\tdis = distance(uv, nearest_point);\n\tcolor = vec3(1.0) - sgn*vec3(0.1,0.4,0.7);\n\tcolor *= 1.0 - exp(-8.0*dis);\n\tcolor *= 0.8 + 0.2*cos(480.0*dis*sgn);\n\tcolor = mix( color, vec3(1.0), 1.0-smoothstep(0.0,0.005,dis) );\n\t#endif\n\n\tfragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}