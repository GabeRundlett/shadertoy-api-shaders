{
    "Shader": {
        "info": {
            "date": "1468939823",
            "description": "A warped lattice structure, very loosely based on the 256b Puls demo by Rrrola.",
            "flags": 0,
            "hasliked": 0,
            "id": "lttGDn",
            "likes": 40,
            "name": "Lattice Framework",
            "published": 3,
            "tags": [
                "raymarch",
                "warp",
                "edges",
                "lattice"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 2133
        },
        "renderpass": [
            {
                "code": "/*\n\n\tLattice Framework\n\t-----------------\n\n\tI coded up a simple lattice the other day, complete with some joins to jazz it up a \n\tbit. At that point, I realized that it had a bit of a \"Puls 256b\" feel, so added in \n\tsome bolts to complete the process. I've never looked at the original Puls code, but \n\tit'd be interesting to see if it's more efficient. At 256 bytes, it's definitely \n\tmore compact. :)\n\n\tThe structure in this particular example is wrapped around a path then rotated about \n\tthe XY plane according to Z distance. Other than that, it's a very rudimentary scene.\n\n\tFor anyone interested, the relevant code is contained in the distance function.\n\n\t// Very cool 256b demo, and definitely worth a look, if you haven't seen it before.\n\tPuls (256b) by Rrrola\n\thttp://www.pouet.net/prod.php?which=53816\n\n\t// Cool and informative lattice example.\n\tCC / FCC / BCC Lattices - Paniq\n\thttps://www.shadertoy.com/view/llfGRj\n\n*/\n\n#define FAR 20. // Far plane, or maximum distance.\n\nfloat objID = 0.; // Object ID - Lattice: 0.; Joins: 1.; Bolts: 2..\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n  \n    //return vec3(0, 0, t); // Straight path.\n    return vec3(-sin(t/2.), sin(t/2.)*.5 + 1.57, t); // Windy path.\n    \n}\n\n\n// The lattice structure.\nfloat map(in vec3 p){\n    \n    // Using the Z value to offset the structure by the camera path. Pretty standard.\n    p.xy -= camPath(p.z).xy;\n    \n    // Rotating the structure about the XY plane by an angle dependent on the Z value.\n    // Also a pretty standard move that you'll see from time to time.\n\tvec2 a = sin(vec2(1.57, 0) + p.z*1.57/10.);\n    p.xy = mat2(a, -a.y, a.x)*p.xy;\n    \n    // Rounded cubes, just for fun, and to help visualize things.\n    //p = abs(fract(p) - .5);\n    //return max(p.x, max(p.y, p.z))*.7 + length(p)*.3 - .2;\n    \n    // Using repeat properties to produce the octahedral joins. There's probably a \n    // clever way to do both simultaneously, but the following works well enough.\n    vec3 q = abs(fract(p + vec3(.5, 0, .5)) - .5);\n    float joins = (q.x + q.y + q.z) - .16; // Half of the joins.\n    \n    p = abs(fract(p + vec3(0, .5, 0)) - .5);\n    joins =  min(joins, (p.x + p.y + p.z) - .16); // The other half.\n    \n    \n    // Reusing \"p\" above to produce the lattice structure. This particular one is called\n    // a body-centered lattice, which I think relates back to some form of nomenclature\n    // regarding crystalline structure. I was already familiar with the structure, but \n    // learned that it had a fancy name via Paniq's really informative shader here:\n    //\n    // CC / FCC / BCC Lattices - https://www.shadertoy.com/view/llfGRj\n    //\n    // Body-centered lattice. My take on it, anyway. I like it because it's cheap and it\n    // looks interesting. Basically, you get your money's worth. :)\n    //p = abs(p - dot(p, vec3(.333)));\n    //float lat = dot(p, vec3(.5)) - 0.034;\n    p = abs(p - (p.x + p.y + p.z)*.3333);\n    float lat = (p.x + p.y + p.z)*.5 - 0.034;\n    \n    // Bolts. Constructed by enlarging the lattice tubes and the octahedral joins, then\n    // taking the difference.\n    float bolts = max(lat - .015, -(joins - .48));\n    \n    // Object ID. Octahedral joins are blue, and the lattice itself will be white.\n    objID = step(joins, lat) + step(bolts, lat)*2.;\n    \n    // Combined objects and joins.\n    return min(min(joins, lat), bolts);\n    \n    \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.35/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n// The normal function with some edge detection rolled into it.\nvec3 nr(vec3 p, inout float edge) { \n\t\n    vec2 e = vec2(.003, 0);\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\t// The hit point itself - Doubled to cut down on calculations. See below.\n     \n    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    // curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    // do that is up to you. This is what I came up with for now, but I might tweak it later.\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\t\n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    for(int i = 0; i < 128; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*(t*.125 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*.85;\n        \n    }\n\n    return min(t, FAR);\n}\n\n\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 20; \n\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n\n        dist += clamp(h, 0.005, 0.16);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (abs(h)<0.001 || dist > end) break; \n    }\n    \n    return max(shade, 0.); \n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tpl(tx, p - e.xyy, n), tpl(tx, p - e.yxy, n), tpl(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tpl(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.25;\n    rd *= 3.;\n    \n    //vec3 tx = tpl(iChannel1, rd/3., sn).zyx;\n    //tx = smoothstep(0.2, 1., tx*2.); \n    //float c = dot(tx, vec3(.299, .587, .114));\n    \n    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n    c = smoothstep(0.4, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    //vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.\n    vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)); // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.25+.25); \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    float speed = 1.;\n    vec3 o = camPath(iTime*speed); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*speed + .1);  // \"Look At\" position.\n    vec3 l = camPath(iTime*speed + 1.); // Light position, somewhere near the moving camera.\n\t\n    // Light postion offset. Since the lattice structure is rotated about the XY plane, the light\n    // has to be rotated to match. See the \"map\" equation.\n    vec3 loffs =  vec3(0, 1, 0);\n    vec2 a = sin(vec2(1.57, 0) - l.z*1.57/10.);\n    loffs.xy = mat2(a, -a.y, a.x)*loffs.xy; \n    l += loffs;\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; ///3. FOV - Field of view.\n    vec3 fwd = normalize(lk - o);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    //vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    //r = normalize(vec3(r.xy, (r.z - length(r.xy)*.25)));\n\n\n    // Raymarch.\n    float t = trace(o, r);\n    \n    // Save the object ID directly after the raymarching equation, since other equations that\n    // use the \"map\" function will distort the results. I leaned that the hard way. :)\n    float sObjID = objID;\n\n    // Initialize the scene color to the background.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position and normal.\n        vec3 p = o + r*t;\n        \n        float ed; // Edge variable.\n        vec3 n = nr(p, ed);\n        \n        // Texture bump the normal.\n        float sz = 2./1.;\n        n = db(iChannel0, p*sz, n, .01/(1. + t/FAR));\n\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n        float at = 1./(1. + d*.25 + d*d*.05); // Light attenuation.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n);\n        float sh = sha(p, l, 0.04, d, 8.);\n        \n        // Diffuse, specular, fresnel. Only the latter is being used here.\n        float di = max(dot(l, n), 0.);\n        float sp = pow(max( dot( reflect(r, n), l ), 0.0 ), 16.); // Specular term.\n        //float fr = clamp(1.0 + dot(r, n), 0.0, 1.0); // Fresnel reflection term.\n        \n        // Texturing the surface with some tri-planar mapping..\n        vec3 tx = tpl(iChannel0, p*sz, n); // Lattice coloring.\n        if(sObjID>1.5) tx *= vec3(1.5); // Lighten the bolts a bit.\n        else if(sObjID>.5) tx *= vec3(.5, .7, 1);// Color the joins blue.\n\n\t\t// Very simple coloring.\n        col = tx*(di*sh + vec3(.75, .75, 1)*.25 + vec3(.5, .7, 1)*sp*sh*3.);\n        \n        // Edges.\n        col *= 1. - ed*.7; // Darker edges.\n        //col += ed*.5; // Lighter edges.\n\n        // Fake environment mapping.\n        vec3 em = eMap(reflect(r, n), n); \n        col += col*em*2.;\n        \n        // Apply some shading.\n        col *= ao*at;\n\n        \n    }\n    \n    // If we've hit the far plane, calulate \"l\" only.\n    if(t>=FAR) l = normalize(l - o - r*FAR);\n \t\n    // Produce some colored fog.\n    vec3 bg = mix(vec3(.5, .7, 1), vec3(1, .5, .6), l.y*.5 + .5);\n    col = mix(clamp(col, 0., 1.), bg, smoothstep(0., FAR-2., t));\n    \n     \n    \n    // Rough gamma correction, and we're done.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}