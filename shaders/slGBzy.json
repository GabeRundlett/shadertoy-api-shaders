{
    "Shader": {
        "info": {
            "date": "1664732708",
            "description": "PC 4k Intro for Linux released at deadline 2022.\nBy juvi and me of epoqe\nPouet: https://www.pouet.net/prod.php?which=92439",
            "flags": 64,
            "hasliked": 0,
            "id": "slGBzy",
            "likes": 6,
            "name": "dottiverse",
            "published": 3,
            "tags": [
                "2d",
                "intro",
                "4k",
                "demoscene",
                "halftone",
                "dots",
                "deadline"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 342
        },
        "renderpass": [
            {
                "code": "/*\nI reused some code from two older shaders of mine:\n\nhttps://www.shadertoy.com/view/Wd2cRG\nhttps://www.shadertoy.com/view/3tsXDB\n*/\n\nfloat tr = .3; // time raster\n\nfloat event2, event3, event4, event5, event6, event7, event8, event9, event10, event11, event11p5, event12, event13, event14, event15, event16, event17, event18, event19, event20, event20p5, event21, event22, event23, event24, event25, event26, event27, event27p5, event28, event29, event30, event31, event32, event33, event34, event35, event35p5, event36, event37;\n#define Z(a,b,c,d) mix(a,b,smoothstep(0.,d-c,clamp(iTime-c,0.,d-c)))\n\nfloat tau = 6.283185;\n\nint num_iterations = 3;\nint num_start_params = 25;\n\nmat2 rot(float t){return mat2(cos(t),sin(t),-sin(t),cos(t));}\n\nvec2 parametric(float t, float t1){\n\tt *= tau;\n\n\tif(t1 == 0.){\n\t\tfloat x = (1.5 + cos(10.*t)) * cos(3.*t);\n\t\tfloat y = (1.5 - cos(10.*t)) * sin(3.*t);\n\n\t\treturn .1 * vec2(x,y);\n\t}\n\n    float x = sin(2.*t);\n    float y = sin(3.*t+tau/4.+mod(t1*.5,tau));\n\n\treturn 1./7.*vec2(x,y);\n}\n\nvec2 parametric_diff(float t, float t1){\n\tt *= tau;\n\n\tif(t1 == 0.){\n\t\tfloat x = -10.*cos(3.*t)*sin(10.*t) - 3.*cos(10.*t)*sin(3.*t) - 4.5*sin(3.*t);\n\t\tfloat y = -3.*cos(10.*t)*cos(3.*t) + 10.*sin(10.*t)*sin(3.*t) + 4.5*cos(3.*t);\n\n\t\treturn tau * .1 * vec2(x,y);\n\t}\n\n\tfloat x = 2. * cos(2.*t);\n    float y = 3. * cos(3.*t+tau/4.+mod(t1*.5,tau));\n\n\treturn 1./7. * tau * vec2(x,y);\n}\n\nfloat parametric_normal_iteration(float t, vec2 uv, float t1){\n\tvec2 uv_to_p = parametric(t,t1)-uv;\n\tvec2 tang = parametric_diff(t,t1);\n\n\tfloat l_tang = dot(tang,tang);\n\treturn t - dot(tang,uv_to_p)/l_tang;\n}\n\nfloat parametric_dis_approx(vec2 uv, float t1){\n\tfloat d0 = 1e38;\n\n\tfloat t0 = 0.;\n\tfloat t;\n\n\tfor(int i=0;i<num_start_params;i++){\n\t\tt = t0;\n\t\tfor(int j=0;j<num_iterations;j++){\n\t\t\tt = parametric_normal_iteration(t,uv,t1);\n\t\t}\n\t\tt = clamp(t,0.,1.);\n\t\tvec2 uv_to_p = parametric(t,t1)-uv;\n\t\td0 = min(d0,dot(uv_to_p,uv_to_p));\n\n\t\tt0 += 1./float(num_start_params-1);\n\t}\n\n\treturn sqrt(d0);\n}\n\nfloat sgn(float a){\n\tif(a<0.){\n\t\treturn -1.;\n\t}\n\telse{\n\t\treturn 1.;\n\t}\n}\n\nvec2 from_projective(vec3 p, float radius, float stretch_factor){\n\tbool flip = false;\n\tif(p.xy == vec2(0)) return vec2(0);\n\tif(p.x == 0.){\n\t\tp=p.yxz;\n\t\tflip=true;\n\t}\n\tfloat a=p.x*p.x+p.y*p.y;\n\tfloat b=p.z*p.x/(stretch_factor*stretch_factor);\n\tfloat c=-p.x*p.x*radius*radius;\n\n\tfloat discriminant=max(0.,b*b-4.*a*c);\n\n\tfloat int_x=(-b+sgn(p.x)*sqrt(discriminant))/(2.*a);\n\tfloat int_y=int_x*p.y/p.x;\n\n\tif(flip) return vec2(int_y,int_x);\n\treturn vec2(int_x,int_y);\n}\n\nvec3 to_projective(vec2 p, float radius, float stretch_factor){\n\treturn vec3(p.xy,stretch_factor*stretch_factor*(radius*radius-dot(p,p)));\n}\n\nmat2x3 to_projective_jacobi(vec2 p, float radius, float stretch_factor){\n\tvec3 column1 = vec3(1,0,-2.*stretch_factor*stretch_factor*p.x);\n\tvec3 column2 = vec3(0,1,-2.*stretch_factor*stretch_factor*p.y);\n\n\treturn mat2x3(column1, column2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tevent2 = 33.*tr; // dots starting to appear\n\tevent3 = event2 + 33.*tr; // start zooming out (and beat starts)\n\tevent4 = event3 + 28.*tr; // end zooming out\n\tevent5 = event4 + 12.*tr; // start moving left\n\tevent6 = event5 + 2.*tr; // end moving left\n\tevent7 = event6 + 6.*tr; // start zooming in\n\tevent8 = event7 + 14.*tr; // end zooming in\n\tevent9 = event8 + 11.*tr; // start zooming in\n\tevent10 = event9 + 14.*tr; // end zooming in\n\tevent11 = event10 + 7.*tr; // start moving right\n\tevent11p5 = event10 + 7.*tr; // chromatic abberation start\n\tevent12 = event11 + 2.*tr; // end moving right\n\tevent13 = event12 + 6.*tr; // start zooming in\n\tevent14 = event13 + 14.*tr; // end zooming in\n\tevent15 = event14 + 11.*tr; // start zooming out\n\tevent16 = event15 + 28.*tr; // end zooming out\n\tevent17 = event16 + 7.*tr; // start moving up\n\tevent18 = event17 + 2.*tr; // end moving up\n\tevent19 = event18 + 6.*tr; // start zooming in\n\tevent20 = event19 + 14.*tr; // end zooming in\n\tevent20p5 = event19 + 20.*tr; // end zooming in\n\tevent21 = event20 + 11.*tr; // start zooming out\n\tevent22 = event21 + 28.*tr; // end zooming out\n\tevent23 = event22 + 7.*tr; // start moving right\n\tevent24 = event23 + 2.*tr; // end moving right\n\tevent25 = event24 + 6.*tr; // start zooming in\n\tevent26 = event25 + 14.*tr; // end zooming in\n\tevent27 = event26 + 11.*tr; // start zooming out\n\tevent27p5 = event26 + 34.*tr; // chromatic abberation start\n\tevent28 = event27 + 28.*tr; // end zooming out\n\tevent29 = event28 + 7.*tr; // start moving right\n\tevent30 = event29 + 2.*tr; // end moving right\n\tevent31 = event30 + 6.*tr; // start zooming in\n\tevent32 = event31 + 14.*tr; // end zooming in\n\tevent33 = event32 + 11.*tr; // start zooming out\n\tevent34 = event33 + 28.*tr; // end zooming out\n\tevent35 = event34 + 6.*tr; // start zooming out even more\n\tevent35p5 = event34 + 22.*tr; // radius offset start\n\tevent36 = event35 + 28.*tr; // end zooming out even more\n\tevent37 = event36 + 19.*tr; // black hole\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-=.5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec2 old_uv = uv;\n\n\tfloat grid_size = .2;\n\n\tfloat radius_animation = exp(Z(4.,Z(0.,Z(4.,Z(0.,Z(4.,Z(0.,Z(4.,Z(0.,Z(4.,Z(0.,Z(4.,Z(0.,-3.5,event35,event36),event33,event34),event31,event32),event27,event28),event25,event26),event21,event22),event19,event20),event15,event16),event13,event14),event9,event10),event7,event8),event3,event4));\n\n\tfloat stretch_factor = 1./radius_animation;\n\tfloat radius = .3*radius_animation;\n\n\tfloat line_width = .001;\n\tfloat circle_width = .005;\n\tfloat curve_width = .001;\n\n\tfloat meta_grid_size = 2.2 * radius;\n\n\tvec3 bg_col = vec3(1);\n\tvec3 dot_col = vec3(0);\n\n    float border = 2./iResolution.y;\n\n\tuv += Z(vec2(0),Z(vec2(-meta_grid_size,0),Z(vec2(meta_grid_size,0),Z(vec2(meta_grid_size),Z(vec2(meta_grid_size,2.*meta_grid_size),vec2(2.*meta_grid_size),event29,event30),event23,event24),event17,event18),event11,event12),event5,event6);\n\n\tvec2 meta_dot_index = round(uv/meta_grid_size);\n\n\tfloat fac = fract(.05*max(0.,iTime-event3));\n\tfloat radius_perturbation = smoothstep(.7,.0,abs(fac+length(meta_dot_index*.3)-round(length(meta_dot_index*.3)+fac)));\n\n\tradius *= radius_perturbation;\n\tstretch_factor /= radius_perturbation;\n\n\tuv = uv - meta_dot_index * meta_grid_size;\n\n\tvec3 color = bg_col;\n\n\tfloat circ_width_offset = Z(0.,1.,event35p5,event36);\n\n\tvec3 uv_p = to_projective(uv,radius,stretch_factor);\n\n\tmat2x3 jac = to_projective_jacobi(uv, radius, stretch_factor);\n\n\tfloat circle_rad = .002;\n\tvec2 circle_index = round(uv_p.xy/uv_p.z/grid_size);\n\tvec2 circle_mid = circle_index*grid_size;\n\n\tvec2 int_p1 = from_projective(vec3(circle_mid,1),radius,stretch_factor);\n\n\tfloat dot_size;\n\n\tfloat nth = max(0.,floor((iTime-event3)/16./tr));\n\tfloat t0 = iTime-event3-nth*16.*tr;\n\tfloat beat = nth*3.5;\n\tbeat += .5 * smoothstep(0.,.2,t0);\n\tbeat += .5 * smoothstep(0.,.2,t0-2.*tr);\n\tbeat += .5 * smoothstep(0.,.2,t0-4.*tr);\n\tbeat += .5 * smoothstep(0.,.2,t0-6.*tr);\n\tbeat += .5 * smoothstep(0.,.2,t0-8.*tr);\n\tbeat += .5 * smoothstep(0.,.2,t0-11.*tr);\n\tbeat += .5 * smoothstep(0.,.2,t0-12.*tr);\n\n\tfloat t1 = iTime+beat;\n\t\n\tfloat index_mod = mod(dot(meta_dot_index,vec2(1)),6.);\n\tif(index_mod == 0.){\n \t\tdot_size = grid_size/2.*(.5-.5*cos(max(0.,t1+4.*int_p1.x-event2)));\n\t}\n\tif(index_mod == 1.){\n\t\tdot_size = grid_size/2.*(.5-.5*sin(t1+.5*circle_mid.x+1.*sin(1.*circle_mid.y)));\n\t}\n\telse if(index_mod == 2.){\n\t\tdot_size = grid_size/2. * smoothstep(.4,0.,abs(-fract(t1*.2)+length(circle_mid)-round(length(circle_mid)-fract(t1*.2))));\n\t}\n\telse if(index_mod == 3.){\n\t\tdot_size = grid_size/2. * smoothstep(.03,0.,parametric_dis_approx(circle_mid*.05*rot(t1*.5),0.));\n\t}\n\telse if(index_mod == 4.){\n\t\tdot_size = grid_size/2. * smoothstep(.03,0.,parametric_dis_approx(circle_mid*.05,t1));\n\t}\n\telse if(index_mod == 5.){\n\t\tdot_size = grid_size/2.*(.5-.5*sin(t1+circle_mid.x))*(.5-.5*cos(t1+circle_mid.y));\n\t}\n\n\tvec3 grid_grad_x = vec3(1./uv_p.z,0.,-uv_p.x/(uv_p.z*uv_p.z));\n\tvec3 grid_grad_y = vec3(0.,1./uv_p.z,-uv_p.y/(uv_p.z*uv_p.z));\n\n\tmat2x3 jac2 = to_projective_jacobi(int_p1, radius, stretch_factor);\n\tfloat jac_fac = max(length(grid_grad_x*jac),length(grid_grad_y*jac));\n\n\tdot_size /= jac_fac;\n\tdot_size -= border/2.;\n\n\tif(iTime < event20p5){\n\t\tnth =clamp(floor((iTime-event11p5)/16./tr),0.,3.);\n\t\tt0 = iTime-event11p5-nth*16.*tr;\n\t}\n\telse if(iTime < event27p5){\n\t\tnth = clamp(floor((iTime-event20p5)/16./tr),0.,1.);\n\t\tt0 = iTime-event20p5-nth*16.*tr;\n\t}\n\telse if(iTime > event27p5){\n\t\tnth = clamp(floor((iTime-event27p5)/16./tr),0.,3.);\n\t\tt0 = iTime-event27p5-nth*16.*tr;\n\t}\n\n\tfloat chromatic_abberation = 0.;\n\tchromatic_abberation += (t0 > 0. && t0 < 5.*tr) ? .003 : 0.;\n\tchromatic_abberation += (t0 > 8.*tr && t0-8.*tr < tr) ? .003 : 0.;\n\tchromatic_abberation += (t0 > 11.*tr && t0-11.*tr < 3.*tr) ? .003 : 0.;\n\n\tfor(int i=0;i<3;i++){\n\t\tvec2 cuv = uv+float(i-1)*chromatic_abberation;\n\t\tfloat dis = abs(length(cuv)-radius+radius*circ_width_offset)-circle_width-radius*circ_width_offset;\n\t\tdis = min(dis,distance(cuv,int_p1)-dot_size);\n\n\t\tfloat d0=length(cuv)-radius;\n\t\tdis = max(d0,dis);\n\n\t\tdis = min(dis,length(old_uv+2.*meta_grid_size)-3.*max(0.,iTime-event37));\n\n\t\tcolor[i] = mix(dot_col[i],color[i],smoothstep(-border/2., border/2., dis));\n\t}\n\n\tfragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 29913,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/epoqe/dottiverse"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}