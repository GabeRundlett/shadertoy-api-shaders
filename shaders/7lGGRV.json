{
    "Shader": {
        "info": {
            "date": "1637982326",
            "description": "they're gears, you dolt!",
            "flags": 0,
            "hasliked": 0,
            "id": "7lGGRV",
            "likes": 4,
            "name": "eindacor_gears",
            "published": 3,
            "tags": [
                "gears"
            ],
            "usePreview": 0,
            "username": "Eindacor_DS",
            "viewed": 526
        },
        "renderpass": [
            {
                "code": "#define AA .002\n#define PI 3.1415926\n#define MIN_GEAR_RADIUS .1\n#define MIN_GEAR_DIVISION 16.\n#define TOOTH_LENGTH .01\n#define GEAR_ROTATION_SPEED .5\n#define SHADOW_MODIFIER .8\n\n#define CYAN vec3(0., 1., 1.)\n#define MAGENTA vec3(1., 0., 1.)\n#define YELLOW vec3(1., 1., 0.)\n#define RED vec3(1., 0., 0.)\n#define GREEN vec3(0., 1., 0.)\n#define BLUE vec3(0., 0., 1.)\n#define ORANGE vec3(1., .75, .25)\n#define PINK vec3(1., .25, .75)\n#define WHITE vec3(1.)\n#define BLACK vec3(0.)\n\n#define PEG_COLOR vec3(1.)\n#define BACKGROUND_COLOR vec4(.05)\n\n#define DRAW_SHADOWS false\n\n/*\n    TODO:\n        - reduce draw passes by incorporated shadow pass into gear/peg process\n*/\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nfloat getGearRadius(float gearIndex) {\n    float randValue = hash(vec2(gearIndex, gearIndex));\n    if (randValue < .333) {\n        return MIN_GEAR_RADIUS;\n    } else if (randValue < .666) {\n        return MIN_GEAR_RADIUS * 2.;\n    } else {\n        return MIN_GEAR_RADIUS * 4.;\n    }\n}\n\nvec4 getGearLocations(float gearLinkValue, float firstIndex, float secondIndex) {\n    vec2 first = vec2(0.);\n    \n    float radialOffsetIncrement = PI / MIN_GEAR_DIVISION * 2.;\n    float maxOffset = PI / 4.;\n    float maxIncrements = 4.;\n    float radialOffset = radialOffsetIncrement * floor(maxIncrements * hash(vec2(gearLinkValue * gearLinkValue, gearLinkValue * 2.)));\n    float rotationVariance = PI / 2.;\n    float rotation = mix(rotationVariance / -2., rotationVariance / 2., hash(vec2(gearLinkValue * gearLinkValue, gearLinkValue * 2.)));\n  \n    mat2x2 rotationMatrix = createRotationMatrix(radialOffset);\n    \n    float dist = getGearRadius(firstIndex) + getGearRadius(secondIndex);\n    \n    vec2 second = (vec2(dist, 0.) * rotationMatrix) + first;\n    \n    return vec4(first.x, first.y, second.x, second.y);\n}\n\nvec3 getRandomColor(float seed) {\n    seed = clamp(seed, 0., 1.);\n    float colorCount = 6.;\n    float colorIncrement = 1.f / colorCount;\n    float seedFloor = floor(seed / colorIncrement) * colorIncrement;\n    float lerpVal = smoothstep(seedFloor, seedFloor + colorIncrement, seed);\n\n    if (seed <= colorIncrement * 1.) {\n        return mix(RED, YELLOW, lerpVal);\n    } else if (seed <= colorIncrement * 2.) {\n        return mix(YELLOW, GREEN, lerpVal);\n    } else if (seed <= colorIncrement * 3.) {\n        return mix(GREEN, CYAN, lerpVal);\n    } else if (seed <= colorIncrement * 4.) {\n        return mix(CYAN, BLUE, lerpVal);\n    } else if (seed <= colorIncrement * 5.) {\n        return mix(BLUE, MAGENTA, lerpVal);\n    } else {\n        return mix(MAGENTA, vec3(1.), lerpVal);\n    }\n}\n\nfloat getPegSmoothStep(vec2 uv, vec2 gearLocation, float gearIndex) {\n    float dist = distance(uv, gearLocation);\n    float holeRadius = .03;\n    \n    if (dist < holeRadius) {\n        return smoothstep(holeRadius - AA, holeRadius - AA * 2., dist);\n    }\n}\n\nbool getHasSpokes(float gearIndex) {\n    return hash(vec2(gearIndex * .23, gearIndex + 89.)) < .75;\n}\n\nvec2 rotateAroundPoint (vec2 anchor, vec2 p, float rads) {\n    mat2x2 rotationMatrix = createRotationMatrix(rads);\n    return (p - anchor) * rotationMatrix + anchor;\n}\n\nint getSpokeCount(float gearIndex) {\n    return int(mix(3., 8., hash(vec2(gearIndex * -.118, gearIndex + 2.))));\n}\n\nfloat getGearSmoothStep(vec2 uv, vec2 gearLocation, float gearIndex, mat2x2 rotationMatrix) {\n    float dist = distance(uv, gearLocation);\n\n    float gearRadius = getGearRadius(gearIndex);\n\n    float gearProportion = gearRadius / MIN_GEAR_RADIUS;\n    float gearDivisions = gearProportion * MIN_GEAR_DIVISION * 2.;\n    \n    uv = ((uv - gearLocation) * rotationMatrix) + gearLocation;\n    \n    float rads = atan(uv.y - gearLocation.y, uv.x - gearLocation.x);\n    \n    float minVal = gearRadius - TOOTH_LENGTH;\n    float maxVal = gearRadius + TOOTH_LENGTH;\n\n    float val = 0.;\n    int spokeCount = getSpokeCount(gearIndex);\n    float innerRadiusDimension = minVal * .4 * hash(vec2(gearIndex, gearIndex));\n    float outerRadiusDimension = minVal * mix(.7, .85, hash(vec2(-gearIndex, -gearIndex)));\n    float spokeWidth = minVal * mix(.02, .1, hash(vec2(gearIndex, -gearIndex)));\n    if (getHasSpokes(gearIndex)) {\n        bool renderRadius = false;\n        for (int i=0; i<spokeCount && !renderRadius; ++i) {\n            vec2 rotatedUv = rotateAroundPoint(gearLocation, uv, float(i) * 2. * PI / float(spokeCount));\n            if (rotatedUv.x < gearLocation.x && abs(rotatedUv.y - gearLocation.y) < spokeWidth) {\n                renderRadius = true;\n            }\n        }\n        \n        if (!renderRadius) {\n            if (dist < innerRadiusDimension) {\n                return smoothstep(innerRadiusDimension, innerRadiusDimension - 2. * AA, dist);\n            }\n            \n            if (dist > outerRadiusDimension && dist <= minVal) {\n                return smoothstep(outerRadiusDimension, outerRadiusDimension + 2. * AA, dist);\n            }\n            \n            if (dist < minVal) {\n                float spokeVal = 0.;\n                for (int i=0; i<spokeCount && !renderRadius; ++i) {\n                    vec2 rotatedUv = rotateAroundPoint(gearLocation, uv, float(i) * 2. * PI / float(spokeCount));\n                    if (rotatedUv.x < gearLocation.x) {\n                        spokeVal = mix(spokeVal, 1., smoothstep(spokeWidth + AA, spokeWidth, abs(rotatedUv.y - gearLocation.y)));\n                    }\n                }\n            \n                return spokeVal;\n            }\n        }\n    }\n    \n    float radIncrements = 2. * PI / gearDivisions;\n    \n    float radIndex = floor(rads / radIncrements);\n    float toothPos = fract(rads / radIncrements);\n\n    // max tooth width is .5\n    float toothWidth = .4;\n    \n    if (mod(radIndex, 2.) == 0.) {\n        float toothVal = smoothstep(toothWidth / 2., 1. - toothWidth / 2., toothPos);\n        gearRadius = mix(minVal, maxVal, toothVal);\n    } else {\n        float toothVal = smoothstep(toothWidth / 2., 1. - toothWidth / 2., toothPos);\n        gearRadius = mix(maxVal, minVal, toothVal);\n    }\n   \n    return mix(val, 1., smoothstep(gearRadius + AA, gearRadius - AA, dist));\n}\n\nvec3 getNextGearLocationAndIndex(float previousIndex, vec2 previousGearLocation) {\n    float gearIndex = previousIndex + 1.;\n    float gearLinkValue = hash(vec2(previousIndex, gearIndex));\n    vec4 gearLocations = getGearLocations(gearLinkValue, previousIndex, gearIndex);\n    vec2 gearLocation = previousGearLocation + (gearLocations.zw - gearLocations.xy);\n    \n    return vec3(gearLocation.x, gearLocation.y, gearIndex);\n}\n\nfloat circleSmoothStepFill(vec2 center, float radius, vec2 p, float antiAlias) {\n\treturn 1.f - smoothstep(radius - antiAlias, radius + antiAlias, distance(center, p));\n}\n\nfloat lineSegmentSmoothStep(vec2 start, vec2 end, vec2 p, float lineThickness, float antiAlias, bool roundEnds) {\n    float halfThickness = lineThickness / 2.f;\n    if (dot(p-end, start - end) < 0.f || dot(p - start, end - start) < 0.f) {\n        return !roundEnds ? 0.f : max(\n\t\t\tcircleSmoothStepFill(start, halfThickness, p, antiAlias),\n\t\t\tcircleSmoothStepFill(end, halfThickness, p, antiAlias)\n        );  \n    }\n    \n    vec2 lineVec = normalize(end - start);\n    vec2 pVec = normalize(p - start);\n\n    float angle = acos(dot(lineVec, pVec) / length(lineVec) * length(pVec));\n    float distFromLine = sin(angle) * distance(start, p);\n    \n    return 1.f - smoothstep(lineThickness / 2.f - antiAlias, halfThickness + antiAlias, distFromLine);\n}\n\nvec4 getPreceedingGearsColor(\n    vec4 inColor,\n    float referenceFirstIndex, \n    float referenceSecondIndex,\n    vec4 referenceLocations,\n    int gearsToRender,\n    vec2 uv,\n    float rotationSpeed,\n    bool isShadow) {\n    \n    vec4 outColor = inColor;\n    \n    for (int i=0; i<gearsToRender; i++) {\n        float targetIndex = referenceFirstIndex - 1.;\n        float linkValue = hash(vec2(targetIndex, referenceFirstIndex));\n        \n        bool isEven = floor(mod(targetIndex, 2.)) <= 0.1;\n        \n        float gearRadius = getGearRadius(targetIndex);\n        float gearProportion = gearRadius / MIN_GEAR_RADIUS;\n        float gearDivisions = gearProportion * MIN_GEAR_DIVISION * 2.;\n        \n        float startingAngle = isEven ? PI / gearDivisions : PI / gearDivisions;\n        \n        float gearSizeSpeedAmplification = MIN_GEAR_RADIUS / gearRadius;\n        \n        float rotation = rotationSpeed * gearSizeSpeedAmplification;\n        if (isEven) {\n            rotation *= -1.;\n        }\n        \n        mat2x2 rotationMatrix = createRotationMatrix(startingAngle + rotation);\n        \n        vec3 gearColor = isShadow ? (outColor * SHADOW_MODIFIER).rgb : getRandomColor(linkValue);\n        \n        vec4 targetReferenceFirstLocations = getGearLocations(linkValue, targetIndex, referenceFirstIndex);\n        vec2 targetLocation = targetReferenceFirstLocations.xy - targetReferenceFirstLocations.zw + referenceLocations.xy;\n        \n        outColor = mix(outColor, vec4(gearColor, 1.), getGearSmoothStep(uv, targetLocation, targetIndex, rotationMatrix)); \n        \n        referenceFirstIndex = targetIndex;\n        referenceSecondIndex = targetIndex - 1.;\n        referenceLocations = vec4(targetLocation.x, targetLocation.y, referenceLocations.x, referenceLocations.y);\n    }\n    \n    return outColor;\n}\n\nvec4 getPreceedingPegsColor(\n    vec4 inColor,\n    float referenceFirstIndex, \n    float referenceSecondIndex,\n    vec4 referenceLocations,\n    int gearsToRender,\n    vec2 uv,\n    bool isShadow) {\n    \n    vec4 outColor = inColor;\n    \n    vec3 pegColor = isShadow ? (outColor * SHADOW_MODIFIER).rgb : PEG_COLOR;\n    \n    for (int i=0; i<gearsToRender; i++) {\n        float targetIndex = referenceFirstIndex - 1.;\n        float linkValue = hash(vec2(targetIndex, referenceFirstIndex));\n        \n        vec4 targetReferenceFirstLocations = getGearLocations(linkValue, targetIndex, referenceFirstIndex);\n        vec2 targetLocation = targetReferenceFirstLocations.xy - targetReferenceFirstLocations.zw + referenceLocations.xy;\n        \n        outColor = mix(outColor, vec4(pegColor, 1.), getPegSmoothStep(uv, targetLocation, targetIndex)); \n        \n        referenceFirstIndex = targetIndex;\n        referenceSecondIndex = targetIndex - 1.;\n        referenceLocations = vec4(targetLocation.x, targetLocation.y, referenceLocations.x, referenceLocations.y);\n    }\n    \n    return outColor;\n}\n\nvec4 getSucceedingGearsColor(\n    vec4 inColor,\n    float referenceFirstIndex, \n    float referenceSecondIndex,\n    vec4 referenceLocations,\n    int gearsToRender,\n    vec2 uv,\n    float rotationSpeed,\n    bool isShadow) {\n    \n    vec4 outColor = inColor;\n    \n    for (int i=0; i<gearsToRender; i++) {\n        float linkValue = hash(vec2(referenceFirstIndex, referenceSecondIndex));\n        \n        bool isEven = floor(mod(referenceFirstIndex, 2.)) <= 0.1;\n        \n        float gearRadius = getGearRadius(referenceFirstIndex);\n        float gearProportion = gearRadius / MIN_GEAR_RADIUS;\n        float gearDivisions = gearProportion * MIN_GEAR_DIVISION * 2.;\n        \n        float startingAngle = isEven ? PI / gearDivisions : PI / gearDivisions;\n        \n        float gearSizeSpeedAmplification = MIN_GEAR_RADIUS / gearRadius;\n        \n        float rotation = rotationSpeed * gearSizeSpeedAmplification;\n        if (isEven) {\n            rotation *= -1.;\n        }\n\n        mat2x2 rotationMatrix = createRotationMatrix(startingAngle + rotation);\n        \n        vec3 gearColor = isShadow ? (outColor * SHADOW_MODIFIER).rgb : getRandomColor(linkValue);\n        \n        outColor = mix(outColor, vec4(gearColor, 1.), getGearSmoothStep(uv, referenceLocations.xy, referenceFirstIndex, rotationMatrix)); \n        \n        vec3 nextLocationAndIndex = getNextGearLocationAndIndex(referenceSecondIndex, referenceLocations.zw);\n        \n        referenceFirstIndex = referenceSecondIndex;\n        referenceSecondIndex = referenceSecondIndex + 1.;\n        referenceLocations = vec4(referenceLocations.z, referenceLocations.w, nextLocationAndIndex.x, nextLocationAndIndex.y);\n    }\n    \n    return outColor;\n}\n\nvec4 getSucceedingPegsColor(\n    vec4 inColor,\n    float referenceFirstIndex, \n    float referenceSecondIndex,\n    vec4 referenceLocations,\n    int gearsToRender,\n    vec2 uv,\n    bool isShadow) {\n    \n    vec4 outColor = inColor;\n    \n    vec3 pegColor = isShadow ? (outColor * SHADOW_MODIFIER).rgb : PEG_COLOR;\n    \n    for (int i=0; i<gearsToRender; i++) {  \n        outColor = mix(outColor, vec4(pegColor, 1.), getPegSmoothStep(uv, referenceLocations.xy, referenceFirstIndex)); \n        \n        vec3 nextLocationAndIndex = getNextGearLocationAndIndex(referenceSecondIndex, referenceLocations.zw);\n        \n        referenceFirstIndex = referenceSecondIndex;\n        referenceSecondIndex = referenceSecondIndex + 1.;\n        referenceLocations = vec4(referenceLocations.z, referenceLocations.w, nextLocationAndIndex.x, nextLocationAndIndex.y);\n    }\n    \n    return outColor;\n}\n\nfloat sinestep(float edge1, float edge2, float val) {\n    float lower = edge1 < edge2 ? edge1 : edge2;\n    float upper = edge1 < edge2 ? edge2 : edge1;\n\n    if (val < lower) {\n        return 0.;\n    } else if (val > upper) {\n        return 1.;\n    }\n    \n    return -1. * cos(1. / (upper - lower));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    uv.x *= aspectRatio;\n    \n    float travelTime = 2.;\n    \n    float dotRadius = .1;\n    \n    float timelerp = fract(iTime / travelTime);\n    \n    int gearsToRender = 16;\n    \n    float originFirstIndex = floor(iTime / travelTime);\n    float originSecondIndex = originFirstIndex + 1.;\n    float linkValue = hash(vec2(originFirstIndex, originSecondIndex));\n    vec4 originLocations = getGearLocations(linkValue, originFirstIndex, originSecondIndex);\n    vec2 firstLocation = originLocations.xy;\n    vec2 secondLocation = originLocations.zw;\n    \n    float previousIndex = originFirstIndex - 1.;\n    float prevLinkValue = hash(vec2(previousIndex, originFirstIndex));\n    vec4 prevFirstLocations = getGearLocations(prevLinkValue, previousIndex, originFirstIndex);\n    vec2 previousLocation = prevFirstLocations.xy - prevFirstLocations.zw + firstLocation;\n    \n    vec2 prevFirstMid = mix(previousLocation, firstLocation, .5);\n    vec2 firstSecondMid = mix(firstLocation, secondLocation, .5);\n    \n    vec2 lerpA = mix(prevFirstMid, firstLocation, timelerp);\n    vec2 lerpB = mix(firstLocation, firstSecondMid, timelerp);\n    vec2 lerpC = mix(lerpA, lerpB, timelerp);\n \n    // modify uv's by bezier curves between midpoints for smooth transitions\n    uv += lerpC - vec2(.5 * aspectRatio, .5);\n    \n    float rotation = 15. * sin(iTime / 5.);\n\n    fragColor = BACKGROUND_COLOR;\n    \n    float shadowDepth = .02;\n    vec2 shadowUv = uv + vec2(shadowDepth);\n    \n    if (DRAW_SHADOWS) {\n        fragColor = getSucceedingGearsColor(\n            fragColor,\n            originFirstIndex, \n            originSecondIndex,\n            originLocations,\n            gearsToRender / 2,\n            shadowUv, \n            rotation,\n            true);\n\n        fragColor = getPreceedingGearsColor(\n            fragColor,\n            originFirstIndex, \n            originSecondIndex,\n            originLocations,\n            gearsToRender / 2,\n            shadowUv,\n            rotation,\n            true);\n    }\n    \n    fragColor = getPreceedingGearsColor(\n        fragColor,\n        originFirstIndex, \n        originSecondIndex,\n        originLocations,\n        gearsToRender / 2,\n        uv,\n        rotation,\n        false);\n        \n    fragColor = getSucceedingGearsColor(\n        fragColor,\n        originFirstIndex, \n        originSecondIndex,\n        originLocations,\n        gearsToRender / 2,\n        uv, \n        rotation,\n        false);\n        \n    if (DRAW_SHADOWS) {\n        fragColor = getSucceedingPegsColor(\n            fragColor,\n            originFirstIndex, \n            originSecondIndex,\n            originLocations,\n            gearsToRender / 2,\n            mix(uv, shadowUv, .35),\n            true);\n\n        fragColor = getPreceedingPegsColor(\n            fragColor,\n            originFirstIndex, \n            originSecondIndex,\n            originLocations,\n            gearsToRender / 2,\n            mix(uv, shadowUv, .35),\n            true);\n    }\n        \n    fragColor = getSucceedingPegsColor(\n        fragColor,\n        originFirstIndex, \n        originSecondIndex,\n        originLocations,\n        gearsToRender / 2,\n        uv,\n        false);\n        \n    fragColor = getPreceedingPegsColor(\n        fragColor,\n        originFirstIndex, \n        originSecondIndex,\n        originLocations,\n        gearsToRender / 2,\n        uv,\n        false);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}