{
    "Shader": {
        "info": {
            "date": "1597480289",
            "description": "A GPU version of the Squares Random Noise Generator. The next step is to generate some terrain with it and try some raymarching.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tlfRs",
            "likes": 6,
            "name": "Fast Noise - GPU Squares RNG",
            "published": 3,
            "tags": [
                "procedural",
                "noise",
                "fast",
                "rng",
                "squaresrng",
                "statelessrng"
            ],
            "usePreview": 0,
            "username": "km",
            "viewed": 909
        },
        "renderpass": [
            {
                "code": "// A webgl2 implementation of the Squares RNG\n// algorithm https://squaresrng.wixsite.com/rand\n//\n// Copyright (c) 2020 Bernard Widynski: original implementation in C\n// Copyright (c) 2020 Kyle Marshall: implementation in OpenGL ES 3   \n//                                                                          \n//  This code can be used under the terms of the GNU General Public License \n//  as published by the Free Software Foundation, either version 3 of the   \n//  License, or any later version. See the GPL license at URL               \n//  http://www.gnu.org/licenses\n//\n// Original source code is available here:\n// https://squaresrng.wixsite.com/rand\n//\n// I'm looking to use it as my go to noise function\n// It is simple and only uses mult/adds, bitshifts,\n// and bitwise ORs. With no state, it was trivially\n// parallelizable to the GPU.\n\nprecision highp float;\nprecision highp int;\n\n// provides 16 psuedo-random bits\n// conviently packaged in a float\n// in the [0,1] range.\nfloat squares16(uint ctr) {\n    const uint key = uint(0x7a1a912f);\n    const float two16 = 65536.0;\n\n    uint x, y, z;\n\n    // initialize\n    // ==================================\n    // Weyl sequence vars, y and z\n    y = ctr * key;\n    z = (ctr + uint(1)) * key;\n\n    // init the mixing var, x\n    x = y;\n\n    // begin the mixing rounds\n    // ===================================\n\n    // round 1\n    x = x*x + y; x = (x>>16) | (x<<16);\n\n    // round 2\n    x = x*x + z; x = (x>>16) | (x<<16);\n\n    // round 3\n    x = (x*x + y) >> 16;\n\n    return float(x)/two16;\n}\n\nfloat pixel_id(vec2 fragCoord) {\n    return dot(fragCoord.xy,\n               vec2(1, iResolution.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float id = pixel_id(fragCoord);\n    int cnt_pixels = int(iResolution.x * iResolution.y);\n\n    vec3 col = vec3(squares16(uint(id)+uint(iFrame*cnt_pixels)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}