{
    "Shader": {
        "info": {
            "date": "1523377707",
            "description": "A sandbox for exploring star and polygon formulas",
            "flags": 0,
            "hasliked": 0,
            "id": "ldGcDK",
            "likes": 8,
            "name": "Stars & Polygons",
            "published": 3,
            "tags": [
                "stars",
                "polygons"
            ],
            "usePreview": 0,
            "username": "tayloia",
            "viewed": 710
        },
        "renderpass": [
            {
                "code": "const float PI = 3.1415927;\n\nfloat smoothfill(in float a, in float b, in float epsilon)\n{\n    // A resolution-aware smooth edge for (a < b)\n    return smoothstep(0., epsilon / iResolution.y, b - a);\n}\n\nfloat disc(in vec2 uv, in float radius)\n{\n    // Function for a circular disc\n    return smoothfill(length(uv), radius, 10.);\n}\n\nfloat box(in vec2 uv, in vec2 size)\n{\n    // Function for an axis-aligned rectangle\n    // We have to do this independently for x- and y-direction to get smooth edging correct\n    vec2 t = abs(uv / size);\n    return smoothfill(t.x, 1., 10. / size.x) * smoothfill(t.y, 1., 10. / size.y);\n}\n\nfloat polygon(vec2 uv, in int sides, in float size, in float rotation)\n{\n    // Function for an N-sided regular polygon\n\tfloat repeat = PI / float(sides);\n\tfloat theta = atan(uv.x, uv.y) + rotation;\n\tfloat t = cos(repeat - mod(theta, repeat * 2.)) * length(uv) / cos(repeat);\n    return smoothfill(t, size, 10.);\n}\n\nfloat curved(vec2 uv, in int points, in float size)\n{\n    // Function for an N-pointed star approximation that produces curved edges\n\tfloat repeat = 2. * PI / float(points);\n\tfloat theta = atan(uv.x, uv.y);\n\tfloat t = cos(repeat - mod(theta, repeat) * 2.) * length(uv) / cos(repeat);\n    return smoothfill(t, size, 50.);\n}\n\nfloat straight(vec2 uv, in int points, in float size)\n{\n    // Function for an N-pointed star with straight edges\n\tfloat repeat = 2. * PI / float(points);\n    float theta = abs(mod(atan(uv.x, uv.y) + repeat * 0.5, repeat) - repeat * 0.5) - repeat;\n\tfloat t = cos(theta) * length(uv) / cos(repeat);\n    return smoothfill(t, size, 25.);\n}\n\nfloat star(vec2 uv, in int points, in float outer, in float inner, in float rotation)\n{\n    // Function for a fully-specified N-pointed star\n\tfloat repeat = PI / float(points);\n\tfloat theta = atan(uv.x, uv.y) + rotation;\n\tfloat t1 = cos(repeat - mod(theta, repeat * 2.));\n    float t2 = cos(repeat - mod(theta + repeat, repeat * 2.));\n    float t = (t1 * outer - t2 * (outer - inner)) * length(uv) / (cos(repeat) * outer - (outer - inner));\n    return smoothfill(t, outer, 25.);\n}\n\nfloat golf(vec2 uv, in float size)\n{\n    // Short function for a 5-pointed star\n\tfloat t = cos(abs(fract(atan(uv.x, uv.y) * .8 + .5) - .5) / .8 - 1.26) * length(uv) / .3;\n    return smoothfill(t, size, 33.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    const int ROWS = 3;\n    const int COLUMNS = 4;\n    const float GAP = 0.1;\n    vec2 uv = fragCoord / iResolution.y;\n    uv.x -= (iResolution.x / iResolution.y - float(COLUMNS) / float(ROWS)) * 0.5;\n    vec3 col = vec3(0.1);\n    uv = uv * (float(ROWS) + GAP) - GAP;\n    if ((uv.x >= 0.) && (uv.y >= 0.) && (uv.x < float(COLUMNS)))\n    {\n        ivec2 iuv = ivec2(uv);\n        uv = fract(uv) * (2. + GAP * 2.) - 1.;\n        if (max(abs(uv.x), abs(uv.y)) < 1.)\n        {\n\t        int panel = iuv.x + iuv.y * COLUMNS;\n            float size1 = sin(iTime + float(panel)) * 0.4 + 0.6;\n            float size2 = sin(iTime * 0.7 + float(panel)) * 0.3 + 0.7;\n            switch (panel)\n            {\n                case 0:\n                    col = vec3(1,0,0) * disc(uv, size1);\n                    break;\n                case 1:\n                    col = vec3(0,1,0) * box(uv, vec2(size1, size2));\n                    break;\n                case 2:\n                    col = vec3(1,1,0) * polygon(uv, 5, size1, 0.);\n                    break;\n                case 3:\n                    col = vec3(0,0,1) * polygon(uv, 6, size2, iTime);\n                    break;\n                case 4:\n                    col = vec3(1,0,1) * curved(uv, 5, size1);\n                    break;\n                case 5:\n                    col = vec3(0,1,1) * curved(uv, 6, size2);\n                    break;\n                case 6:\n                    col = vec3(1,0,0) * straight(uv, 5, size1);\n                    break;\n                case 7:\n                    col = vec3(0,1,0) * straight(uv, 6, size2);\n                    break;\n                case 8:\n                    col = vec3(1,1,0) * star(uv, 5, size1, size1 * 0.382, 0.);\n                    break;\n                case 9:\n                    col = vec3(0,0,1) * star(uv, 6, size2, size1, 0.);\n                    break;\n                case 10:\n                    col = vec3(1,0,1) * star(uv, 7, 0.6, size1, iTime);\n                    break;\n                case 11:\n                    col = vec3(0,1,1) * golf(uv, size1);\n                    break;\n                default:\n                \tcol = vec3(0);\n                \tbreak;\n            }\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}