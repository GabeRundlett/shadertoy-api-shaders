{
    "Shader": {
        "info": {
            "date": "1587891653",
            "description": "Ramanujan died exactly 100 years ago today:\n\n[url]https://en.wikipedia.org/wiki/Srinivasa_Ramanujan[/url]\n[url]https://trinitycollegelibrarycambridge.wordpress.com/2020/04/24/remembering-ramanujan/[/url]\n",
            "flags": 16,
            "hasliked": 0,
            "id": "wdlfz4",
            "likes": 10,
            "name": "Srinivasa Ramanujan, 1887-1920",
            "published": 3,
            "tags": [
                "partition",
                "1729",
                "ramanujan"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 418
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Srinivasa Ramanujan, 22 December 1887 â€“ 26 April 1920.\n//\n// https://en.wikipedia.org/wiki/Srinivasa_Ramanujan\n//\n// Here we have a 12x12x12 cube, total volume 1728, that can be dissected and,\n// with an extra piece, reassembled into a 9x9x9 cube and a 10x10x10 cube,\n// Key 'x' shows the 10x10x10 cube.\n//\n// Some of Ramanujan's more profound work was in the area of partition theory,\n// for example, Ramanujan's Congruences concerning p(n), the number of\n// partitions of integer n (ie. the number of ways of expressing positive n as a\n// sum of positive integers):\n//\n// https://en.wikipedia.org/wiki/Ramanujan%27s_congruences:\n//\n// p(5k+4) = 0 mod 5\n// p(7k+5) = 0 mod 7\n// p(11k+6) = 0 mod 11\n//\n// The first two are nicely illustrated with p(19) = 490 and all 490\n// partitions appear in the background, grouped appropriately. (Key 'b'\n// shows just the background).\n//\n// Matthew Arcus, mla, 26th April 2020\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint AA = 2; // Set to 1 if too slow.\n\nfloat eyedist = 40.0;     // Eye is at (0,0,eyedist);\nvec3 light = normalize(vec3(0,1,3)); // Direction of light\nbool dorotate = true;\n\nfloat PI = 3.1415927; \n\n// Raymarching configuration.\nint maxsteps = 100;\nfloat precis = 1e-3; \n\nint cubesize = 6; // Half width of cube\nfloat dicesize = 0.4; // \nfloat de(vec3 p) {\n  vec3 p0 = abs(p);\n  p = fract(p);\n  p -= 0.5;\n  p = abs(p);\n  float d = -1e8;\n  d = max(d,p.x-dicesize);\n  d = max(d,p.y-dicesize);\n  d = max(d,p.z-dicesize);\n  // Clip to cubesize\n  d = max(d,p0.x-float(cubesize));\n  d = max(d,p0.y-float(cubesize));\n  d = max(d,p0.z-float(cubesize));\n  return d;\n}\n\nvec3 getnormal(vec3 p, vec3 rd) {\n  // Repeat DE calculation, but return normal to closest plane.\n  p = fract(p);\n  p -= 0.5;\n  p = abs(p);\n  float d1, d = -1e8;\n  vec3 n = vec3(0);\n  d1 = p.x-dicesize;\n  if (d1 > d) { d = d1; n = vec3(1,0,0); }\n  d1 = p.y-dicesize;\n  if (d1 > d) { d = d1; n = vec3(0,1,0); }\n  d1 = p.z-dicesize;\n  if (d1 > d) { d = d1; n = vec3(0,0,1); }\n  // Make sure normal points the right way.\n  return dot(n,rd) < 0.0 ? n : -n;\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Rotate according to mouse position\nvec3 transformframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  // autorotation\n  if (dorotate) {\n    p.yz = rotate(p.yz,-iTime*0.125);\n    p.zx = rotate(p.zx,iTime*0.1);\n  }\n  return p;\n}\n\nvec3 colours[] =\n  vec3[](vec3(0,0,1),\n         vec3(1,0,0),\n         vec3(1,1,0),\n         vec3(0,1,0),\n         vec3(1));\n\n// p is integer coordinates of 'dice'.\nvec3 getdicecolor(ivec3 p) {\n  p += cubesize;\n  int t = int(p.x >= 9) + int(p.y >= 9) + int(p.z >= 9);\n  return colours[t+int(cubesize == 5)];\n}\n\nfloat march(vec3 q, vec3 r) {\n  float maxdist = 2.0*eyedist;\n  float t = 0.0;\n  for (int i = 0; i < maxsteps; i++) {\n    vec3 p = q+t*r;\n    float d = de(p);\n    if (abs(d) < precis) return t; // Close enough to the surface.\n    t += d;\n    if (t > maxdist) break;\n  }\n  return -1.0;\n}\n\nbool raycolor(vec3 q, vec3 r, out vec3 color) {\n  float t = march(q,r);\n  if (t < 0.0) return false;\n  // Get the surface point that has been hit,\n  vec3 p = q+t*r;\n  // and the normal at that point.\n  vec3 normal = getnormal(p,r);\n  \n  // Apply lighting. This is a basic \"Lambertian\" model.\n  color = 0.2+0.8*getdicecolor(ivec3(floor(p)));\n  float ambient = 0.3;\n  float diffuse = 0.7*clamp(dot(normal,light),0.0,1.0);\n  color *= ambient+ diffuse;\n  return true;\n}\n\n// Partitions. p(n,m) = number of partitions of n with parts no larger than m\n// p(0,_) = 1\n// p(n,0) = 0\n// p(n,m) = p(n,m-1) + p(n-m,m)\n\nconst int ptable[20*20] =\n  int[] (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,\n         2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 3, 3, 3,\n         3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 4, 5, 5, 5, 5, 5,\n         5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 3, 5, 6, 7, 7, 7, 7, 7, 7, 7,\n         7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 4, 7, 9, 10, 11, 11, 11, 11, 11, 11,\n         11, 11, 11, 11, 11, 11, 11, 11, 11, 1, 4, 8, 11, 13, 14, 15, 15, 15,\n         15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 1, 5, 10, 15, 18, 20,\n         21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 1, 5, 12,\n         18, 23, 26, 28, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n         1, 6, 14, 23, 30, 35, 38, 40, 41, 42, 42, 42, 42, 42, 42, 42, 42,\n         42, 42, 42, 1, 6, 16, 27, 37, 44, 49, 52, 54, 55, 56, 56, 56, 56,\n         56, 56, 56, 56, 56, 56, 1, 7, 19, 34, 47, 58, 65, 70, 73, 75, 76,\n         77, 77, 77, 77, 77, 77, 77, 77, 77, 1, 7, 21, 39, 57, 71, 82, 89,\n         94, 97, 99, 100, 101, 101, 101, 101, 101, 101, 101, 101, 1, 8, 24,\n         47, 70, 90, 105, 116, 123, 128, 131, 133, 134, 135, 135, 135, 135,\n         135, 135, 135, 1, 8, 27, 54, 84, 110, 131, 146, 157, 164, 169, 172,\n         174, 175, 176, 176, 176, 176, 176, 176, 1, 9, 30, 64, 101, 136, 164,\n         186, 201, 212, 219, 224, 227, 229, 230, 231, 231, 231, 231, 231, 1,\n         9, 33, 72, 119, 163, 201, 230, 252, 267, 278, 285, 290, 293, 295,\n         296, 297, 297, 297, 297, 1, 10, 37, 84, 141, 199, 248, 288, 318,\n         340, 355, 366, 373, 378, 381, 383, 384, 385, 385, 385, 1, 10, 40,\n         94, 164, 235, 300, 352, 393, 423, 445, 460, 471, 478, 483, 486, 488,\n         489, 490, 490, 1, 11, 44, 108, 192, 282, 364, 434, 488, 530, 560,\n         582, 597, 608, 615, 620, 623, 625, 626, 627\n);\n\nint pcount(int n, int m) {\n  if (n == 0) return 1;\n  if (m == 0) return 0;\n  return ptable[20*(n-1)+m-1];\n}\n\n// Recurrence:\n// parts(0,_) = [[]]\n// parts(_,0) = []\n// parts(n,m) = parts(n,m-1) + parts(n-m,m)\n// Use p(n,m) to decide which branch of the recursion to follow.\nint unrank(int n, int k, int t) {\n  int m = n, i = 0;\n  while (true) {\n    int k1 = pcount(n,m-1);\n    if (k < k1) m = m-1;\n    else {\n      t -= m;\n      if (t < 0) return i;\n      i++; n -= m; k -= k1;\n    }\n  }\n}\n\nvec3 bgcolor(vec2 fragCoord) {\n  // 490 = 2*5*7*7 items, each 19 squares, arranged in 14 rows of 7\n  // blocks of 5 subrows of 19 square. With a border.\n  ivec2 pdim = ivec2(iResolution.xy);\n  ivec2 pcoord = ivec2(fragCoord);\n  pcoord.y = pdim.y-1-pcoord.y;\n  vec3 col = vec3(0.2);\n  // Width is 7 blocks of 19, plus 8 separators\n  // Height is 14 blocks of 5, plus 15 separators\n  int W = 7, W1 = 19;\n  int H = 14, H1 = 5;\n  int M = 1;\n  ivec2 bdim = ivec2(W*(W1+M)+M, H*(H1+M)+M); //7*19+8;\n  ivec2 bcoord = pcoord*bdim/pdim;\n  int nwidth = bdim.x; //14*5+15;\n  int nheight = bdim.y; //14*5+15;\n  int i = bcoord.x, j = bcoord.y;\n  int i1 = (i+W1)%(W1+M); // Index within a horizontal block\n  int j1 = (j+H1)%(H1+M);   // Index within a vertical block\n  if (i1 < W1 && j1 < H1) {\n    int p = unrank(19,(i-M)/(W1+M)*(H*H1)+(j-M)/(H1+M)*H1+j1,i1);\n    if (p%2 != 0) col = vec3(0.8);\n    else col = vec3(0.5);\n  }\n  ivec2 boffset = (bcoord*pdim+bdim-1)/bdim; // Index of 1st pixel in block\n  if (bcoord.x > 0 && j1 < H1 && pcoord.x == boffset.x) col = vec3(0);\n  if (bcoord.y > 0 && i1 < W1 && pcoord.y == boffset.y) col = vec3(0);\n  return col;\n}\n\nconst int CHAR_B = 66;\nconst int CHAR_R = 82;\nconst int CHAR_X = 88;\n\nbool key(int code) {\n  return texelFetch(iChannel3, ivec2(code,2),0).x != 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  if (key(CHAR_X)) cubesize = 5;\n  dorotate = !key(CHAR_R);\n  vec3 eye = vec3(0,0,eyedist);\n  eye = transformframe(eye);\n  light = transformframe(light);\n  vec3 bgcol = bgcolor(fragCoord);\n  vec3 col = vec3(0);\n  if (key(CHAR_B)) {\n    col = bgcol;\n  } else {\n    for (int i = 0; i < AA; i++) {\n      for (int j = 0; j < AA; j++) {\n        vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n        vec3 ray = vec3(z,-4);\n        ray = transformframe(ray);\n        ray = normalize(ray);\n        vec3 raycol;\n        if (!raycolor(eye,ray,raycol)) raycol = bgcol;\n        col += raycol;\n      }\n    }\n    col /= float(AA*AA);\n  }\n  col = pow(col,vec3(0.4545)); // Gamma\n  fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}