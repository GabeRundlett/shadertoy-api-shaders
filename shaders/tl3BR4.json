{
    "Shader": {
        "info": {
            "date": "1612328100",
            "description": "Revised Volumetric Path-Tracing with a new sky from LoicVDB (https://www.shadertoy.com/user/loicvdb) with more optimizations and visual enhancements. It is using the built-in Noise volume, because other options for 3D Noise are either slow or obfuscated.",
            "flags": 32,
            "hasliked": 0,
            "id": "tl3BR4",
            "likes": 14,
            "name": "Path-Tracing: Volumetric Cloud",
            "published": 3,
            "tags": [
                "raymarching",
                "ray",
                "raymarch",
                "clouds",
                "clouds",
                "volumetric",
                "raymarcher",
                "pathtrace",
                "pathtracing",
                "pathtracer",
                "path",
                "volumetrics"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 2056
        },
        "renderpass": [
            {
                "code": "// ##### Path-Tracing: Volumetric Cloud #####\n// Made by Zi7ar21 on February 2nd, 2020\n// Last updated: February 2nd, 2020 21:50 Mountain Time\n\n// If you found this anywhere other than Shadertoy, a possibly updated version can be found at:\n// https://www.shadertoy.com/view/tl3BR4\n\n// Common is for Parameters, Constants, and Other Functions.\n// Buffer A is for Path-Tracing the scene.\n// Buffer B is for Exporting a 32-BPC Floating Point OpenEXR Image.\n// This is for Drawing the main image.\n\n// ##### Contributors #####\n// LoicVDB Made the Sky Background for this, check his profile out:\n// https://www.shadertoy.com/user/loicvdb\n\n// Michael0884 has helped with other things, check his profile out:\n// https://www.shadertoy.com/user/michael0884\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This is for Parameters, Constants, and Other Functions.\n// ##### General Parameters #####\n// Controls Sensitivity of the Mouse Input\n#define mousesensitivity 4.0\n// Controls the Camera Field of View\n#define camfov 1.0\n// Controls the Maximum Number of the Path-Tracing Steps\n#define maxsteps 1024\n// Controls the Size of the Path-Tracing Steps\n#define stepsize 0.05\n// Controls the Maximum Distance from the Scene\n#define scenesize 4.0\n// Controls the Maximum Distance Travelled\n#define maxdist 32.0\n// Controls the Maximum Number of Bounces\n#define maxbounces 128U\n// Controls the Density of the Volume\n#define volumedensity 128.0\n// Controls the Scattering of the Volume\n#define scattering 1.0\n// Controls the Detail of the FBM Noise\n#define octaves 8\n\n// ##### LoicVDB's Sky Parameters #####\n// Controls Sky Quality\n#define SkySamples 8\n// Controls Sky Color\n#define SkyColor vec3(0.25, 0.5, 1.0)\n// Controls Light Color\n#define LightColor vec3(1.0, 1.0, 1.0)\n// Controls Sky Direction\n#define SkyUp vec3(0.0, 1.0, 0.0)\n// Controls Light Direction\n#define LightDirection normalize(vec3(1.0, 1.0, -1.0))\n// Controls Sky Intensity\n#define SkyIntensity 0.2\n// Controls Light Intensity\n#define LightIntensity 1.0\n// Controls the Radius of the Light\n#define LightRadius 0.125\n// Controls Mie Scattering Intensity\n#define MieIntensity 0.05\n// Controls Mie Scattering Anisotropy\n#define MieAnisotropy 0.6\n\n// ##### Constants and Functions #####\n// Pi (Quadruple Precision Float Future-Proof)\n#define pi 3.1415926535897932384626433832795028\n#define quarterpi pi*0.25\n#define twopi pi*2.0\n\n// LoicVDB's (Slightly Modified) Sky Functions (Loic's Profile: https://www.shadertoy.com/user/loicvdb)\n// (I don't know where to link to other than his profile page, since this\n// is from a Fragmentarium shader he shared on the Marble Marcher Discord)\nfloat anisotropicWeight(vec3 dirI, vec3 dirO, float a){\n \treturn quarterpi*(1.0-a*a)/pow(1.0+a*(a-2.0*dot(dirI, dirO)), 1.5);\n}\n\nvec3 skyDirectLight(vec3 pos, int i) {\n    if(dot(LightDirection, SkyUp) < 0.0){return vec3(0.0);}\n    vec3 volAbs = vec3(1.0), stepAbsRay, stepAbsMie;\n    float alt, dist, ds;\n    for(; i < SkySamples; i++){\n        alt = -log(1.0-sign(dot(LightDirection, SkyUp))*float(i)/float(SkySamples));\n    \tdist = alt/dot(LightDirection, SkyUp);\n        ds = exp(-dot(pos, SkyUp));\n        stepAbsRay = exp(-ds*dist*SkyColor*SkyIntensity);\n        stepAbsMie = exp(-ds*dist*MieIntensity*vec3(1.0));\n        volAbs *= stepAbsMie*stepAbsRay;\n        pos += LightDirection*dist;\n    }\n    return LightColor.rgb*LightColor*volAbs;\n}\nvec3 backgroundDirectLight(vec3 dir) {\n\tif(dot(dir, LightDirection) < cos(LightRadius)){return vec3(0.0);}\n\tfloat sphericalCapArea = sin(LightRadius)*sin(LightRadius);\n\tfloat lightStrength = LightIntensity/(sphericalCapArea);\n\treturn lightStrength*LightColor.rgb;\n}\n\nvec3 skyScatter(vec3 dir, bool hasSun) {\n    vec3 pos = vec3(0.0), volCol = vec3(0.0), volAbs = vec3(1.0);\n    vec3 stepAbsRay, stepAbsMie, stepColRay, stepColMie;\n    float alt, dist, ds;\n    float aw = anisotropicWeight(dir, LightDirection, MieAnisotropy);\n    for(int i = 0; i < SkySamples; i++) {\n        alt = -log(1.0-sign(dot(dir, SkyUp))*float(i)/float(SkySamples));\n    \tdist = min(alt/dot(dir, SkyUp), 5.0);\n        ds = exp(-dot(pos, SkyUp));\n        stepAbsRay = exp(-ds*dist*SkyColor.rgb*SkyIntensity);\n        stepAbsMie = exp(-ds*dist*MieIntensity*vec3(1.0));\n        stepColRay = (1.0-stepAbsRay);\n        stepColMie = (1.0-stepAbsMie)*aw;\n        volCol += (stepColMie+stepColRay)*volAbs*skyDirectLight(pos, i);\n        volAbs *= stepAbsRay*stepAbsMie;\n        pos += dir*dist;\n    }\n    return volCol+(hasSun ? backgroundDirectLight(dir)*volAbs:vec3(0.0));\n}\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x+fragCoord.y*iResolution.x);\n\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u)) ^ state)*277803737u;\n    ns = (word >> 22u) ^ word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\n//vec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random, also from Michael0884: https://www.shadertoy.com/view/WttyWX\n/*float ErfInv(float x){\n   float lnx = log((1.0-x)*(1.0+x));\n   float tt1 = 4.3308+0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1+sqrt(tt1*tt1-tt2)));\n}*/\n\n//float nrand(){return ErfInv(rand()*2.0-1.0);}\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// This is for Path-Tracing the scene.\n// 3D FBM: https://www.shadertoy.com/view/3dSBRh\nfloat fbm(vec3 x){\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0; i < octaves; i++){\n\t\tv += a*texture(iChannel1, x).r;\n\t\tx = x.zyx*2.0;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n// Alternate Noise, Slower than Sampling Built-In Noise\n// (I would use Nimitz's Cyclic Noise but it's hard to understand / the mat3 random numbers it uses seem sub-optimal)\n/*// Hash: https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 pos){\n\tpos =  fract(pos*vec3(0.1031, 0.1030, 0.0973));\n    pos += dot(pos, pos.yxz+33.33);\n    return fract((pos.xxy+pos.yxx)*pos.zyx);\n}\n\n// Gradient Noise: https://iquilezles.org/articles/gradientnoise\nfloat noise(vec3 x){\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 ga = hash(p+vec3(0.0,0.0,0.0));\n    vec3 gb = hash(p+vec3(1.0,0.0,0.0));\n    vec3 gc = hash(p+vec3(0.0,1.0,0.0));\n    vec3 gd = hash(p+vec3(1.0,1.0,0.0));\n    vec3 ge = hash(p+vec3(0.0,0.0,1.0));\n    vec3 gf = hash(p+vec3(1.0,0.0,1.0));\n    vec3 gg = hash(p+vec3(0.0,1.0,1.0));\n    vec3 gh = hash(p+vec3(1.0,1.0,1.0));\n    float va = dot(ga, w-vec3(0.0,0.0,0.0));\n    float vb = dot(gb, w-vec3(1.0,0.0,0.0));\n    float vc = dot(gc, w-vec3(0.0,1.0,0.0));\n    float vd = dot(gd, w-vec3(1.0,1.0,0.0));\n    float ve = dot(ge, w-vec3(0.0,0.0,1.0));\n    float vf = dot(gf, w-vec3(1.0,0.0,1.0));\n    float vg = dot(gg, w-vec3(0.0,1.0,1.0));\n    float vh = dot(gh, w-vec3(1.0,1.0,1.0));\n    return va+\n    u.x*(vb-va)+\n    u.y*(vc-va)+\n    u.z*(ve-va)+\n    u.x*u.y*(va-vb-vc+vd)+\n    u.y*u.z*(va-vc-ve+vg)+\n    u.z*u.x*(va-vb-ve+vf)+\n    u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}\n\n// 3D FBM: https://www.shadertoy.com/view/3dSBRh\nfloat fbm(vec3 x){\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0; i < octaves; i++){\n\t\tv += a*noise(x+vec3(8.0));\n\t\tx = x.zyx*2.0;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}*/\n\n// Volumetric Density Function, outputs: (vec3 Volume Color, float Density)\nvec4 densityfunction(vec3 pathpos){\n    vec3 color = vec3(1.0);\n    float density = max(0.0, fbm(pathpos*0.1)-(length(pathpos)*0.75));\n    return vec4(color, density*volumedensity);\n}\n\n// Volumetric Path-Tracing\nvec3 pathtrace(vec3 pathdir, vec3 pathori){\n    vec4 density;\n    float absorbance, disttrav = 0.0;\n    vec3 attenuation = vec3(1.0);\n    vec3 pathpos = pathori+(pathdir*stepsize*rand());\n    uint bounces = 0U;\n    for(int i = 0; i < maxsteps; i++){\n        density = densityfunction(pathpos);\n        absorbance = exp(-density.w*stepsize);\n        if(absorbance < rand()){\n            attenuation *= clamp(density.rgb*scattering, 0.0, 1.0);\n            pathdir = normalize(nrand3(1.0, vec3(0.0)));\n            bounces++;\n        }\n        pathpos += pathdir*stepsize;\n        disttrav += stepsize;\n        if(length(pathpos) > scenesize || disttrav > maxdist || bounces > maxbounces){break;}\n    }\n    return skyScatter(pathdir, true)*attenuation;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Progressive Rendering\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0){oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}\n    fragColor = oldFragColor;\n    if(iMouse.z > 0.0){fragColor = vec4(0.0);}\n\n    // Initialize Random Number Generator\n    INIT_RNG;\n\n    vec2 uv = 2.0*((fragCoord+nrand2(0.5, vec2(0.0)))-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n    vec2 mouse = ((iMouse.xy/iResolution.xy)-0.5)*pi*mousesensitivity;\n    //vec2 mouse = vec2(iTime*pi*0.125, 0.0);\n    mat3 rotmat = mat3(cos(mouse.x), 0.0, -sin(mouse.x), 0.0, 1.0, 0.0, sin(mouse.x), 0.0, cos(mouse.x));\n    vec3 pathdir = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n    vec3 pathtraced = pathtrace(pathdir, vec3(-sin(mouse.x)*2.0, 0.0, -cos(mouse.x)*2.0));\n    fragColor += vec4(clamp(pathtraced, 0.0, 32.0), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This is for Exporting a 32-BPC Floating Point OpenEXR Image.\n/* Look at the bottom of the editor, there is a little Image icon. If\nyou click it, then Shadertoy will save a 32-Bit-Per-Channel Floating Point\nOpenEXR Image. It is more optimal for Image editing than right-clicking\nthe canvas and pressing copy/save image (as).*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}