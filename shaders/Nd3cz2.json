{
    "Shader": {
        "info": {
            "date": "1653701130",
            "description": "Was browsing around to see what approaches there were for cracked/shattered glass and really liked this one, so I messed with ways to improve the look a bit. Could still be much better. Use the mouse to move the center point.",
            "flags": 0,
            "hasliked": 0,
            "id": "Nd3cz2",
            "likes": 22,
            "name": "Enhanced Voronoi Cracks",
            "published": 3,
            "tags": [
                "voronoi",
                "glass"
            ],
            "usePreview": 1,
            "username": "kg",
            "viewed": 672
        },
        "renderpass": [
            {
                "code": "// Based on original code by by inigo quilez - iq/2013 https://www.shadertoy.com/view/ldl3W8\n// Then modified by hadyn lander (https://www.shadertoy.com/view/ll3SD2)\n// https://iquilezles.org/articles/voronoilines\n\n#define PHASE_POWER 2.0\n\nvec2 hash2( vec2 p )\n{\n    // texture based white noise\n    return texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n    \n    // procedural white noise   \n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec4 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    vec2 o;\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n    vec2 mg, mr;\n    float oldDist;\n    \n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n    \n    oldDist = md;\n    \n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n        o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec4( md, mr, oldDist );\n}\n\nvoid eval (vec2 xy, float timeStep, out vec4 c, out float cellPhase, out float edgePhase, out float phase) {\n    vec2 p = (xy/iResolution.xx);\n    p *= 16.0; // higher values zoom out further - don't go too high or the sine waves will become quite obvious...\n    vec2 unscaledPos = xy/iResolution.xy;\n    // c = (min distance, ???, ???)\n    c = voronoi( p );\n    c.x = 1.0-pow(1.0-c.x, 2.0);\n    \n    \n    float dist = length((iMouse.xy - xy) / iResolution.xy),\n        distanceScale = 0.75,\n        waveScale = 0.025,\n        // lower values will make the band of unbroken surface larger\n        bandSizeFactor = 2.0,\n        bandSizeFactor2 = 2.0,\n        // higher value = more prominent sine wave ripple\n        sineStrength = 3.0,\n        // higher value = higher sine wave frequency and weirder output\n        sineRate = 1.0,\n        // raising this value expands the wave so it covers more of the screen\n        modulus = 1.25;\n    \n    timeStep -= (dist * distanceScale);\n\n    // decreases 1->0 as cell falls away from the surface\n    float s1 = sineStrength*sin(((p.y + c.z)*0.8 + (p.x + c.y)*0.4) * sineRate);\n    cellPhase = p.x + c.y + s1;\n    cellPhase *= waveScale;\n    cellPhase = clamp(abs(mod(cellPhase -timeStep, modulus) / modulus -0.5) * bandSizeFactor, 0.0, 1.0);\n    cellPhase = pow(clamp(cellPhase*bandSizeFactor2-0.5, 0.0, 1.0), PHASE_POWER);\n    \n    // fades smoothly 1->0 as breaking wave travels across it\n    float s2 = sineStrength*sin((p.y*0.8 + p.x*0.4) * sineRate);\n    edgePhase = p.x + s2;\n    edgePhase *= waveScale;\n    edgePhase = clamp(abs(mod(edgePhase -timeStep, modulus) / modulus -0.5) * bandSizeFactor, 0.0, 1.0);\n    edgePhase = pow(clamp(edgePhase*bandSizeFactor2-0.5, 0.0, 1.0), PHASE_POWER);\n    \n    phase = mix(edgePhase, cellPhase, smoothstep(0.0,0.2, edgePhase));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float edgeSizeDivisor = 0.25, edgeAmplification = 2.2,\n        edgeSuppressionPower = 2.0;\n    // float timeStep = clamp(iTime / 2.5, 0.0, 1.525) + 2.1;\n    float timeStep = iTime / 3.0;\n    \n    float cellPhase, edgePhase, phase;\n    vec4 c;\n    eval(fragCoord.xy, timeStep, c, cellPhase, edgePhase, phase);\n\n    vec3 col, fill, bg;\n    float \n        // as the pieces first start to fall we darken the edges to create the illusion\n        //  of a shadow and distinguish them from the surface\n        edgeDarkness = (1.0 - clamp((c.x - cellPhase) / edgeSizeDivisor, 0.0, 1.0)) * cellPhase * edgeAmplification,\n        // as the piece falls away we want to stop darkening the edges\n        edgeSuppression = pow(1.0 - clamp(cellPhase, 0.0, 1.0), edgeSuppressionPower),\n        // and then we darken the entire pieces instead\n        darkness = max(edgeDarkness * edgeSuppression, cellPhase);\n\n    bg = vec3(0.0,0.33,0.5);\n    fill = mix(vec3(1, 1, 1), vec3(0, 0, 0), clamp(darkness, 0.0, 1.0));    \n    col = mix(bg, fill, smoothstep( phase-0.025, phase, c.x ) );\n    \n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}