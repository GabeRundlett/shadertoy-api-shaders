{
    "Shader": {
        "info": {
            "date": "1689114039",
            "description": "Credits to Suboptimal Engineer's youtube tutorial on Perlin noise shaders https://www.youtube.com/watch?v=7fd331zsie0\n",
            "flags": 0,
            "hasliked": 0,
            "id": "dsfBDS",
            "likes": 1,
            "name": "PERLIN NOISE EXAMPLE",
            "published": 3,
            "tags": [
                "noise",
                "perlin",
                "billow",
                "ridged"
            ],
            "usePreview": 0,
            "username": "jackjackdev",
            "viewed": 200
        },
        "renderpass": [
            {
                "code": "// PERLIN NOISE EXAMPLE\n// Credits to Suboptimal Engineer's youtube tutorial https://www.youtube.com/watch?v=7fd331zsie0\n\nvec2 randomGradient(vec2 p) {\n  p = p + 0.02;\n  float x = dot(p, vec2(123.4, 234.5));\n  float y = dot(p, vec2(234.5, 345.6));\n  vec2 gradient = vec2(x, y);\n  gradient = sin(gradient);\n  gradient = gradient * 43758.5453;\n\n  // update noise function with time\n  gradient = sin(gradient + iTime);\n  return gradient;\n}\n\n// inigo quilez - https://iquilezles.org/articles/distfunctions2d/\nfloat sdfCircle(in vec2 p, in float r) {\n  return length(p) - r;\n}\n\n// inigo quilez - https://iquilezles.org/articles/distfunctions2d/\nfloat sdfOrientedBox(in vec2 p, in vec2 a, in vec2 b, float th) {\n  float l = length(b - a);\n  vec2 d = (b - a) / l;\n  vec2 q = (p - (a + b) * 0.5);\n  q = mat2(d.x, -d.y, d.y, d.x) * q;\n  q = abs(q) - vec2(l, th) * 0.5;\n  return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nvec2 cubic(vec2 p) {\n  return p * p * (3.0 - p * 2.0);\n}\n\nvec2 quintic(vec2 p) {\n  return p * p * p * (10.0 + p * (-15.0 + p * 6.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // set up uv + colors\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  uv = fragCoord.xy / iResolution.y;\n\n  vec3 black = vec3(0.0);\n  vec3 white = vec3(1.0);\n  vec3 color = black;\n\n  // set up a grid\n  uv = uv * 4.0;\n  vec2 gridId = floor(uv);\n  vec2 gridUv = fract(uv);\n  color = vec3(gridId, 0.0);\n  color = vec3(gridUv, 0.0);\n\n  // coords of grid corners\n  vec2 bl = gridId + vec2(0.0, 0.0);\n  vec2 br = gridId + vec2(1.0, 0.0);\n  vec2 tl = gridId + vec2(0.0, 1.0);\n  vec2 tr = gridId + vec2(1.0, 1.0);\n\n  // random gradient for each grid corner\n  vec2 gradBl = randomGradient(bl);\n  vec2 gradBr = randomGradient(br);\n  vec2 gradTl = randomGradient(tl);\n  vec2 gradTr = randomGradient(tr);\n\n  // visualize gradients\n  vec2 gridCell = gridId + gridUv;\n  float distG1 = sdfOrientedBox(gridCell, bl, bl + gradBl / 2.0, 0.02);\n  float distG2 = sdfOrientedBox(gridCell, br, br + gradBr / 2.0, 0.02);\n  float distG3 = sdfOrientedBox(gridCell, tl, tl + gradTl / 2.0, 0.02);\n  float distG4 = sdfOrientedBox(gridCell, tr, tr + gradTr / 2.0, 0.02);\n  if (distG1 < 0.0 || distG2 < 0.0 || distG3 < 0.0 || distG4 < 0.0) {\n    color = vec3(1.0);\n  }\n\n  // visualize a single center pixel on each grid cell\n  float circleRadius = 0.025;\n  vec2 circleCenter = vec2(0.5, 0.5);\n  float distToCircle = sdfCircle(gridUv - circleCenter, circleRadius);\n  color = distToCircle > 0.0 ? color : white;\n\n  // find distance from current pixel to each grid corner\n  vec2 distFromPixelToBl = gridUv - vec2(0.0, 0.0);\n  vec2 distFromPixelToBr = gridUv - vec2(1.0, 0.0);\n  vec2 distFromPixelToTl = gridUv - vec2(0.0, 1.0);\n  vec2 distFromPixelToTr = gridUv - vec2(1.0, 1.0);\n\n  // calculate the dot products of gradients + distances\n  float dotBl = dot(gradBl, distFromPixelToBl);\n  float dotBr = dot(gradBr, distFromPixelToBr);\n  float dotTl = dot(gradTl, distFromPixelToTl);\n  float dotTr = dot(gradTr, distFromPixelToTr);\n\n  // smooth out gridUvs\n  // gridUv = smoothstep(0.0, 1.0, gridUv);\n  // gridUv = cubic(gridUv);\n  gridUv = quintic(gridUv);\n\n  // linear interpolation between 4 dot products\n  float b = mix(dotBl, dotBr, gridUv.x);\n  float t = mix(dotTl, dotTr, gridUv.x);\n  float perlin = mix(b, t, gridUv.y);\n  \n  \n\n  // display perlin noise (comment out the ridged noise and uncomment this next line for a pure perlin noise)\n  // color = vec3(perlin + 0.2);\n  \n  // display dots & arrows for visualizing the noise\n  // color = distToCircle > 0.0 ? color : white;\n  // if (distG1 < 0.0 || distG2 < 0.0 || distG3 < 0.0 || distG4 < 0.0) {\n  //   color = vec3(1.0);\n  // }\n\n  // billow noise\n  // float billow = abs(perlin);\n  // color = vec3(billow);\n\n  // ridged noise\n  vec2 spec = 1.0*texture(iChannel0, vec2(0.25,5.)).xx;\n  float ridgedNoise = 1.0 - abs(perlin);\n  ridgedNoise = pow(ridgedNoise, 5.); // + sin(iTime + uv.x)*spec.y;;\n  color = vec3(ridgedNoise, sin(iTime + uv.x)*spec.y, 0); // red-only right now\n\n  fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}