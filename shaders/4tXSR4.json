{
    "Shader": {
        "info": {
            "date": "1434635317",
            "description": "http://research.microsoft.com/en-us/um/people/johnsny/papers/arealights.pdf for reference solution (Arvo 1995)\nhttp://pascal.lecocq.home.free.fr/publications/lecocq_i3D2016_specularAreaLighting.pdf for Accurate Analytic Approximation",
            "flags": 0,
            "hasliked": 0,
            "id": "4tXSR4",
            "likes": 32,
            "name": "Analytic Area Light ",
            "published": 3,
            "tags": [
                "arealight"
            ],
            "usePreview": 0,
            "username": "dys129",
            "viewed": 1979
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n\n#define MAT_ID_LIGHT 3.\n#define saturate(a) clamp(a, 0.,1.)\n\n/*\nSet USE_APPROX to 0 to use reference solution (Arvo 1995)\nSet USE_APPROX to 1 to use Siggraph 2015: Accurate Analytic Approximations for Real-Time Specular Area Lighting\n*/\n#define USE_APPROX 1\n\n//0 - for triangle area light\n//1 - for quad area light\n#define AREA_LIGHT_TYPE 0\n\nvec3 lightClr = vec3(1.0, 0.0, 0.0);\n\n//specular power\nconst int N = 65; \n\n#if AREA_LIGHT_TYPE==0\n#define NUM_VERTS 3\nvec3 get_arr(int i)\n{  \n \tif(i == 0) return vec3(0.1,  0.01, 0.01);  \n \tif(i == 1) return vec3(-0.5, 2.0,  0.02);\n \tif(i == 2) return vec3(0.5, 2.0,0.03);\n    \n   \treturn vec3(0.);\n}\n#elif AREA_LIGHT_TYPE==1\n#define NUM_VERTS 6\nvec3 get_arr(int i)\n{  \n \tif(i == 0) return vec3(1.0,  0.1, 0.0);  \n \tif(i == 1) return vec3(-1.0, 0.1,  0.0);\n \tif(i == 2) return vec3(-1.0, 2.0,0.0);\n    \n    if(i == 5) return vec3(-1.0,  2.0, 0.0);  \n \tif(i == 3) return vec3(1.0, 2.0,  0.0);\n \tif(i == 4) return vec3(1.0, 0.1,0.0);\n    \n   \treturn vec3(0.);\n}\n#endif\n\n\nfloat plane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sphere(vec3 ro, float r)\n{\n return length(ro) - r;   \n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nvec2 scene(vec3 ro)\n{\n    vec2 polygon = vec2(1000.0, 0.);\n    \n    for(int i = 0; i < NUM_VERTS; i += 3)\n    {\n    \tpolygon = opU(polygon, vec2(udTriangle(ro, get_arr(i), get_arr(i+1), get_arr(i+2)), MAT_ID_LIGHT));\n    }\n    vec2 pl0 = vec2(plane(ro), 0.0);\n\n return opU(polygon, pl0);  \n}\n\nvec4 getMaterial(float mat_id)\n{\n\tif(mat_id == 0.0) return vec4(1.0, 1.0, 1.0, 0.0);\n    else if(mat_id == 1.0) return vec4(0.0, 1.0, 0.0, 0.0);\n    else if(mat_id == 2.0) return vec4(1.0, 0.0, 0.0, 0.0);  \n    else if(mat_id == MAT_ID_LIGHT) return vec4(1.0, 1.0, 1.0, 0.0);\n        return vec4(0.0);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n\t    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n\t    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nfloat cosine_sine_power_integral_sum(float theta,float cos_theta,float sin_theta,\nint n,float a,float b)\n{\n    float f = a*a + b*b;\n    float g = a*cos_theta + b*sin_theta;\n    float gsq = g*g;\n    float asq = a*a;\n    float h = a*sin_theta - b*cos_theta;\n    float T,Tsum;\n    float l,l2;\n    int start;\n    /* initial conditions for recurrence */\n    //if (n&1) {\n    /*T = h+b;\n    l = gsq*h;\n    l2 = b*asq;\n    start = 1;*/\n    /*} else { */\n    T = theta;\n    l = g*h;\n    l2 = b*a;\n    start = 0;\n    //}\n    Tsum = T;\n    for (int i = 2; i <= N-1; i += 2) \n    {\n        T = (l + l2 + f*(float(i)-1.)*T)/float(i);\n        l *= gsq;\n        l2 *= asq;\n        Tsum += T;\n    }\n    return Tsum;\n}\n\nfloat P(float theta, float a)\n{\n\treturn 1.0 / (1.0 + a * theta * theta);    \n}\n\nfloat I_org(float theta, float c, float n)\n{\n    float cCos = c * cos(theta);\n    return (pow(cCos, n+2.) - 1.0) / (cCos * cCos  - 1.)-1.0;\n}\n\nfloat evaluateXW(float c, float n)\n{\n\treturn PI/4.*pow(1. - pow(c - c /(n-1.), 2.5), 0.45);   \n}\n\n\nfloat shd_edge_contribution_approx(vec3 v0, vec3 v1, vec3 n, int e)\n{\n   float f;\n    float cos_theta,sin_theta;\n    vec3 q = cross(v0,v1);\n    sin_theta = length(q);\n    q = normalize(q);\n    cos_theta = dot(v0,v1);\n    \n    if (e == 1) {\n        f = acos(cos_theta);\n    } else {\n        vec3 w;\n        float theta;\n        theta = acos(cos_theta);\n        w = cross(q,v0);\n       \n        float a = dot(v0,n);\n        float b = dot(w,n);\n        float x = theta;\n        float delta = atan(b, a);\n        float c = sqrt(a*a + b*b);\n        \n        float xw = evaluateXW(c, float(N));\n        \n        float bias = -0.01; //?\n        \n        float s = (pow(c, float(e)+2.) - 1.) / (c*c - 1.)-1.;\n        float Io = I_org(xw, c, float(e));\n        \n        float A = (s-Io)/(Io*(xw + bias)*(xw + bias));\n \n        float integral =  1. / sqrt(A) * atan(sqrt(A) * x , (1. - A * delta * (x - delta))); \n        \n        float vShift = P(PI/2., A);\n        float d = 1. - vShift;\n        float sNorm = s / d;\n                        \n        f  = sNorm * (integral - x * vShift)+x;\n        f = max(theta,f);\n    }\nreturn f*dot(q,n); \n}\n\nfloat shd_edge_contribution(vec3 v0,vec3 v1,vec3 n,int e)\n{\n    float f;\n    float cos_theta,sin_theta;\n    vec3 q = cross(v0,v1);\n    sin_theta = length(q);\n    q = normalize(q);\n    cos_theta = dot(v0,v1);\n    \n    if (e == 1) {\n        f = acos(cos_theta);\n    } else {\n        vec3 w;\n        float theta;\n        theta = acos(cos_theta);\n        w = cross(q,v0);\n        f = cosine_sine_power_integral_sum(theta,cos_theta,sin_theta,e-1,dot(v0,n),dot(w,n));\n    }\nreturn f * dot(q,n);\n}\n\n\n\nvoid seg_plane_intersection(vec3 v0, vec3 v1, vec3 n, out vec3 q)\n{\n vec3 vd;\n float t;\n vd = v1 - v0;\n t = -dot(v0,n)/(dot(vd, n));\n q = v0 + t * vd;\n}\n\nfloat shd_polygonal(vec3 p, vec3 n, bool spc)\n{\n    int i,i1;\n    int J = 0;\n    float sum = 0.;\n    vec3 ui0,ui1; /* unnormalized vertices of edge */\n    vec3 vi0,vi1; /* unit-length vector vertices of edge */\n    int belowi0 = 1,belowi1 = 1; /* flag for whether last vertex was below pointâ€™s \"horizon\" */\n    /* find first vertex above horizon */\n    for (int j = 0; j < NUM_VERTS; j++) {\n        vec3 u;\n        u = get_arr(j) - p;\n        if (dot(u,n) >= 0.0) {\n            ui0 = u;\n            vi0 = u;\n            vi0 = normalize(vi0);\n            belowi0 = 0;\n            J = j;\n            break;\n        }\n    } \n    \n    if (J >= NUM_VERTS) return 0.;\n    \n    i1 = J;\n\tfor (int i = 0; i < NUM_VERTS; i++) \n    {\n        i1++;\n        if (i1 >= NUM_VERTS) i1 = 0;\n        \n        ui1 = get_arr(i1) - p;\n        belowi1 = int(dot(ui1,n) < 0.);\n        \n        if (belowi1 == 0) {\n            vi1 = ui1;\n            vi1 = normalize(vi1);\n        }\n \n        if (belowi0!=0 && belowi1==0) {\n            vec3 vinter;\n            seg_plane_intersection(ui0,ui1,n,vinter);\n            vinter = normalize(vinter+0.01);                        \n            sum += shd_edge_contribution(vi0,vinter,n,1);            \n            vi0 = vinter;\n        }  else if (belowi0==0 && belowi1!=0) {\n            seg_plane_intersection(ui0,ui1,n,vi1);\n            vi1 = normalize(vi1);\n        }\n     \tint K = spc ? N : 1;\n        #if USE_APPROX\n       \tif (belowi0==0 || belowi1==0) sum += shd_edge_contribution_approx(vi0,vi1,n,K);\n        #else\n        if (belowi0==0 || belowi1==0) sum += shd_edge_contribution(vi0,vi1,n,K);\n        #endif\n        \n\t\tui0 = ui1;\n\t\tvi0 = vi1;\n\t\tbelowi0 = belowi1;\n    }\n    \n    if (sum < 0.) sum = -sum;\n    \n    return sum / (2.0 * PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{     \n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n   // vec2 mo = -1.0 + 2.0 * iMouse.xy/iResolution.xy;\n   \n\n    vec3 ro = vec3(6.0 * sin(iTime), 2.2, 6.0 * cos(iTime));\n\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n    \n    float t = 1.0;\n    vec4 clr = vec4(0.0);\n    for(int i =0; i<64; i++)\n    {\n        vec2 hit = scene(ro+t*rd);\n        float eps = 0.001;\n        if(hit.x < eps)\n        {\n            vec4 mat = getMaterial(hit.y);\n            if(hit.y ==  MAT_ID_LIGHT)\n            {\n                clr.rgb = lightClr;\n                break;\n            }\n                 \n        \tvec3 pos = ro + t*rd;\n        \tvec3 nrm = calcNormal( pos );\n        \tvec3 rfl = reflect( rd, nrm );   \n             vec3 test_out;           \n            float diff = shd_polygonal(pos, nrm, false);\n            \n            \n            float spc = saturate(shd_polygonal(pos, rfl, true));\n\t\t\tclr.rgb = lightClr * (diff+spc) * mat.rgb;\n            break;\n        }\n        \n        t += max(hit.x, 0.001);\n    }\n   \n    clr.rgb = pow(clr.rgb, vec3(1.0 / 2.2));\n    \n\tfragColor = clr;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}