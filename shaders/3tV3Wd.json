{
    "Shader": {
        "info": {
            "date": "1580352445",
            "description": " I wanted to render something large scale and play around with camera animations. It's far from perfect, but I have some ideas on how to do it way better. I wanna make this thing look HUGE.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tV3Wd",
            "likes": 15,
            "name": "Ringworld",
            "published": 3,
            "tags": [
                "3d",
                "color",
                "space",
                "animation",
                "ring",
                "glow",
                "world"
            ],
            "usePreview": 0,
            "username": "Plento",
            "viewed": 423
        },
        "renderpass": [
            {
                "code": "// Plento\nvec2 R;\n\nvec3 cm(vec3 p){p.yz *= rot(-0.6); return texture(iChannel2, p).xyz;}\nvec3 t1(vec2 p){return texture(iChannel1, p).xyz;}\n\n//  from iQ's website\nvec2 opRevolution( in vec3 p, float w ){\n    return vec2( length(p.xz) - w, p.y );\n}\n\nfloat sdBox2D( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\n// the ring\nfloat ring(vec3 rp){\n    rp.xy *= rot(pi/2.);\n    return sdBox2D(opRevolution(rp,180.0), vec2(0.1, 16.0));\n}\n\n\nfloat map(vec3 rp){\n    float d = 999.0;\n   \n    vec3 p0 = rp - vec3(16.25, 0.25, 0.);\n    vec3 p1 = rp - vec3(-16.25, 0.25, 0.);\n    \n    // main ring\n    d = ring(rp);\n    \n\t// outer walls\n    p0.xy*=rot(pi/2.); p1.xy*=rot(pi/2.);\n    d = min(d, sdBox2D(opRevolution(p0,180.0), vec2(.4, .25)));\n    d = min(d, sdBox2D(opRevolution(p1,180.0), vec2(.4, .25)));\n    \n    return d;\n}\n\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nvec2 march(vec3 rd, vec3 ro){\n    float t = 0., d = 0., md = 999.;\n   \n    for(int i = 0; i < 100; i++){\n    \td = map(ro + rd*t); \t   \n        md = min(d, md);\n        \n        if(abs(d) < 0.002){break;}\n        if(t >= FAR){t = FAR; break;}\n      \t\n        t += d * 0.75;\n    }   \n    return vec2(t, md);\n}\n\n// Bump map stuff\nfloat height(vec2 p){\t\n    return t1(p).r;\n}\n\nvec3 TextureBump(vec2 uv, float strength){\n    float h = 0.002;\n    vec3 p = vec3(0);\n    \n    p = t1(uv);\n    \n    float dx = height(uv) - height(uv + vec2(h, .0));\n    float dy = height(uv) - height(uv + vec2(0., h));\n    \n    return normalize( vec3(0., 0., -1.) + vec3(dx, dy, 0.)*strength);\n}\n\n// inside or outside ring\nfloat checkside(vec3 rd, vec3 ro){\n    float d = 0., t = 0.;\n    \n    for(int i = 0; i < 10; i++){\n    \td = ring(ro + rd*t); \t   \n        if(abs(d) < .0001){break;}\n        t += d;\n    }   \n    return t;\n}\n\n// Stars and dust\nvec3 space(vec3 rd){\n    float star = smoothstep(.55,.62, simplex3d(rd*150.));\n    float dust = texture(iChannel0, vec3(rd.x, rd.y-.2, rd.z) + simplex3d(rd*10.)*.22 ).r;\n    return mix(vec3(star), vec3(dust), .07);\n}\n\n// Object color\nvec3 render(vec3 ro, vec3 rd, vec3 n, float t, float md){\n    vec3 p = ro + rd*t;\n    vec3 ref = reflect( rd, n );\n    \n    // Light direction for water (we need a real sun)\n    vec3 ld = vec3(0., 7., 3.5);\n    ld = max(normalize(ld), vec3(.001));\n    \n    vec3 col = vec3(0);\n    \n    if(t < FAR){\n    \t// uvs for ring\n    \tfloat theta = atan(p.y, p.z);\n    \tvec2 uv = vec2(p.x, theta * 100.) * .095;\n    \n    \t// bumpy normals for water\n    \tvec3 bnw = TextureBump((3.*vec2(uv.x, uv.y*2. +iTime*.02) * .35), 5.);\n    \t\n    \t// Water specular\n    \tfloat spec = pow(max(dot(reflect(-ld,normalize(n+bnw)), -rd ),.0),8.);\n        \n        // Diffuse walls\n        float waldif = clamp(dot(n,ld), 0.17, 1.0 );\n        \n    \t// noise values\n    \tfloat nse = 1.-exp(-octnse(vec2(0.4, 1.)*uv + vec2(0.6, 5.4), 7)); \n    \tfloat nse2 = 1.-exp(-octnse(3.*vec2(uv.x, uv.y*2.), 4)); \n    \t\n    \t// land blend value\n    \tfloat ls = ss(.62, .62 + .004, nse); \n    \n    \t// textures\n    \tvec3 dirt = mix(vec3(0.4, 0.1, 0.)*.4, vec3(0.2, 0.2, 0.2), nse2);\n    \tvec3 grass = mix(vec3(0.4, 0.6, 0.), vec3(0.2, 0.2, 0.), nse2);\n        vec3 water = mix(vec3(.0, .21, .6), cm(abs(rd) + bnw*.4), 0.23);\n    \tvec3 wall = vec3(0.8);\n        \n    \t// dirt grass blend value\n    \tfloat ds = ss(.534, .534 + .1, nse);\n    \n    \t// land color\n    \tvec3 land = mix(grass, dirt, ds);\n        \n    \t// add specular to water\n    \twater += vec3(0.7, 0.5, 0.1) * spec*.75;\n        \n    \t// main color for water, land and walls\n    \tcol = mix(mix(land, water, ls), wall, step(16., abs(p.x)));\n    \t\n        // distance blueing\n        col = mix( col, vec3(0.4, 0.6, 0.9), min(.7,1. - exp( -0.000001*t*t*t)));     \n        float dom = ss(-0.1, 0.1, ref.y);\n        col += .05*dom*vec3(0.4,0.6,1.3)*dom;\n        \n    \t// ring side color\n    \tcol = mix(col, wall*waldif, step(.9, abs(n.x)));\n    \n        // underside color\n    \trd = normalize(-p);\n    \tfloat undr = checkside(rd, p);\n        col = mix(wall*(.06+bnw.x*.6), col, step(.009, undr));\n         \n    }\n    else\n    \tcol = space(rd);\n    \n    \n\treturn col;   \n}\n\n// Perhaps not the most optimal way to do camera animation but I'll keep it till I come up with a better way \nmat2x3 camera(vec2 uv, float t){\n    vec3 forward = vec3(0., 0., 1.);\n    vec3 rd = normalize(vec3(uv, .75));\n    \n    vec3 pos = cs1;\n    vec3 lookAt = vec3(0);\n    \n    // v = 0-1 smoothstep based on time, r = rotation animation based on v, z = fov animation based on v\n    float v = 0., r = 0., z = 0.;\n    \n    t = mod(t, 18.);\n    \n    if(t < 1.){\n     \tv = ss(0., 1., t);\n        z = mix(.05, .75, v);\n        rd = normalize(vec3(uv, z));\n    }\n    if(t <= 5.){ \n     \tpos = mix(mix(cs1, cs1, ss(0., 1., t)), cs2, ss(1., 5., t));\n        // simple pointing camera towards origin. Only works for xz rotations lol\n        lookAt = normalize(-pos);\n        float ct = dot(forward, lookAt);\n        float aX = acos(ct);\n        rd.xz *= rot(aX * sign(pos.x));\n    }\n    if(t >= 5. ){ \n     \tpos = mix(cs3, cs4, ss(5., 7., t));\n        rd.yz *= rot(-.4);\n    }\n    if(t >= 7. ){ \n        v = ss(7., 9., t); // Interp value\n        z = mix(.75, .55, v); // new fov\n     \tpos = mix(cs4, cs5, v); // new position\n        \n        rd = normalize(vec3(uv, z)); // set fov\n        rd.yz *= rot(-.4); // do rotations\n        rd.yz *= rot(-v*.2);\n    }\n\tif(t >= 9. ){ \n        v = ss(9., 11., t);\n        r = mix(0., 1.17, v);\n        \n        rd.yz *= rot(-r);\n        rd.xz *= rot(-r*1.34);\n    }\n\tif(t >= 11. ){ \n        v = ss(11., 13., t);\n        r = mix(0., 1.17, v);\n        \n        rd.xz *= rot(-r*1.34);\n        rd.yz *= rot(-r*1.2);\n    }\n    if(t >= 14. ){ \n        v = ss(14., 20., t);\n        \n        rd = normalize(vec3(uv, 1.));\n        rd.xz *= rot(-1.1);\n        pos = mix(cs6, cs7, v);\n    }\n    \n\treturn mat2x3 (pos, rd);\n}\n\n// Simple lil fade in out\nfloat fade(float time, float x, float dur){\n \treturn 1.-exp(-dur*pow(time - x, 2.));\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n  \t\n    float time = mod(iTime, 18.);\n    \n    vec3 col = vec3(0);\n\t\n    // Camera stuff\n    mat2x3 cam = camera(uv, iTime);\n    \n    vec3 ro = cam[0];\n    vec3 rd = cam[1];\n    \n    // March stuff\n    vec2 t = march(rd, ro);\n    vec3 n = normal(ro + rd*t.x);\n    \n    // Object color\n    col = render(ro, rd, n, t.x, t.y);\n    \n    // cloud noise and color\n    float clouds = 1.-exp(-octnse3D(3.*vec3(rd.x, rd.y, rd.z-time*.16), 4));\n    vec3 blue = mix(vec3(0., 0., 0.9), vec3(0.3, 0.3, 0.9), step(6., time)-step(14., time));\n    vec3 skycol = mix(blue, vec3(1), clouds);\n    \n    // Change amout of glow depending on x position which gives transition from space to sky\n    float dcs = mix(20., ro.x, step(4., time));\n    float gval = mix(1., .00001, ss(30., 0., abs(dcs)));\n    float glow = exp(-t.y*gval);\n    \n    \n    vec3 closecol = mix(skycol, col, exp(-.006*t.x)); // clouds + geometry\n    vec3 farcol = vec3(0);\n    \n    // add glow if miss object\n    if(t.y > .01)farcol = mix(col, skycol, exp(-t.y*.23));else farcol = col;\n    \n    // Determine final color based on where we are \n    col = mix(closecol, farcol, ss(0., 10., abs(dcs)));\n    \n    // Do fades\n    col *= fade(time, 0., 8.);\n    col *= fade(time, 5., 8.);\n    col *= fade(time, 14., 8.);\n    col *= fade(time, 18., 6.);\n    \n    //col = pow(col,vec3(1./2.2));\n    \n    f = vec4(col, 1.0);\n    \n}\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define ss(a, b, t) smoothstep(a, b, t)\n#define FAR 800.\n\n#define cs1 vec3(-300., 0., -310.)\n#define cs2 vec3(300., 0., -310.)\n#define cs3 vec3(50., -178., 0.)\n#define cs4 vec3(0., -178., 0.)\n#define cs5 vec3(0., -175., 20.)\n#define cs6 vec3(-60., 0., 100.)\n#define cs7 vec3(-60., 0., 170.)\n\nconst float pi = 3.14159;\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n\n// Lots of noise \n\nvec2 hash22( vec2 x ){\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n// Gradient noise\nfloat gdns(vec2 p ){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = ss(0., 1., f);\n    \n    vec2 a = hash22(i);\n    vec2 b = hash22( i + vec2(1.,0.));\n    vec2 c = hash22( i + vec2(.0,1.));\n    vec2 d = hash22( i + vec2(1));\n    \n    float nse = mix( mix( dot( a, f - vec2(0.0,0.0) ), \n                     dot( b, f - vec2(1.0,0.0) ), u.x),\n                mix( dot( c, f - vec2(0.0,1.0) ), \n                     dot( d, f - vec2(1) ), u.x), u.y);\n    return nse + 0.5;\n}\n\n\n// 3D simplex noise stuff from: https://www.shadertoy.com/view/XsX3zB\nconst float F3 =  .3333333;\nconst float G3 =  .1666667;\nvec3 random3(vec3 c) {\n\tfloat j = 4096.*sin(dot(c,vec3(17., 59.4, 15.)));\n\tvec3 r;\n\tr.z = fract(512.*j);\n\tj *= .125;\n\tr.x = fract(512.*j);\n\tj *= .125;\n\tr.y = fract(512.*j);\n\treturn r-.5;\n}\n\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t vec3 e = step(vec3(0.), x - x.yzx);\n\t vec3 i1 = e*(1. - e.zxy);\n\t vec3 i2 = 1. - e.zxy*(1. - e);\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.*G3;\n\t vec3 x3 = x - 1. + 3.*G3;\n\t vec4 w, d;\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t w = max(.6 - w, 0.);\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.), x3);\n\t w *= w;\n\t w *= w;\n\t d *= w;\n    \n     float nse = dot(d, vec4(52.));\n    \n\t return 1.-exp(-(nse+1.)*.5);\n  \n}\n\n// octave noise for 2d and 3d. Coulda done with 1 but oh well\nfloat octnse(vec2 p, int oct){\n    float a = 1.;\n    float n = 0.;\n    \n    for(int i = 0; i < oct; i++){\n     \tn += gdns(p) * a;\t\n        p*=2.;\n        a *= .5;\n    }\n    \n    return n;\n}\nfloat octnse3D(vec3 p, int oct){\n    float a = 1.;\n    float n = 0.;\n    \n    for(int i = 0; i < oct; i++){\n     \tn += simplex3d(p) * a;\n        p*=2.;\n        a *= .35;\n    }\n    \n    return n;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}