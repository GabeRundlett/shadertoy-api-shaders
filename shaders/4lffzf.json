{
    "Shader": {
        "info": {
            "date": "1514395814",
            "description": "The logo of the hackerspace \"Hackafe\" from the city of Plovdiv, Bulgaria and it's sad story, told by one of the last survivors.",
            "flags": 8,
            "hasliked": 0,
            "id": "4lffzf",
            "likes": 4,
            "name": "Hackafe Logo",
            "published": 3,
            "tags": [
                "fire",
                "blocks",
                "wind",
                "gas",
                "story",
                "burst",
                "hackafe"
            ],
            "usePreview": 0,
            "username": "twenkid",
            "viewed": 968
        },
        "renderpass": [
            {
                "code": "/*\n  [\"Hackafe Logo\"] Exercise #1. Version: 27.12.2017\n\n  [Author]: Todor \"Tosh\" Arnaudov (Twenkid) http://artificial-mind.blogspot.bg | http://research.twenkid.com\n  [Credits and Thanks]: Shadertoy community, iq, Dave Hoskins, rear, LeGuignon; BigWings; Phong; CG pioneers and mathematicians from the past \n                        \"Hackafe\" existed in Plovdiv, Bulgaria. Currently it's hibernated: http://www.hackafe.org/\n  [Story]\n\n  Hackafe - \"The Plovdiv's Hackerspace\" - was established in 2013 A.D. with love and enthusiasm.\n  It had a youth of passion and sailed in an ocean of expectations, but the Water happened to be\n  too deep and stormy, thus the cruise was quite short.\n  The sailors and captains weren't strong enough to sustain...\n  Their relationships and activities became increasingly dysfunctional.\n  The atmosphere went worse and worse, and the hackerspace irreversibly declined\n  to its shameful oblivion and death.\n\n  After a long painful agony the last survivors put Hackafe to sleep in October 2017.\n  \n  A few genes lasted, though. They were launched deep into the Cyberspace \n  to find a better planet where to bloom and live again...   \n\n  [Future work:]\n\n      1. Antialiasing and motion blur\n      2. More spatial artifacts in the background (specfic stars/larger variety of brightness/color, comets, planets, black hole, asteroids flying)\n      3. Cloud/fog\n      4. Icy/semi-transparent \"bumpy\" blocks (like for example the IcePrimitives shader) to exercise refraction, subsurface scattering\n      5. More freedom for the blocks - more rotations, phsysics, bouncing; interactivity through the mouse, hitting by asteroids, laser beams\n      6. Electricity arcs around the blocks, lightning strikes\n      7. Raining lava?, blocks reacting to the hits - heating/cooling ...\n      8. More complex and varying sound\n      9. More complex lighting, Fresnel equations, shadows, ...\n      10. Story, travelling, scene changes, action\n                        \n*/\n\nfloat z = 0.05;\nfloat StepDiv = 35.;\nfloat StepBase = 0.30; //Blocks\nconst float cube = 3.; //(~) distance to distinguish the cube from space\nfloat step = 0.8; //Blocks\nconst vec2 cameraYz = vec2(2.65,-5.5); //the X is animated\nfloat cameraSpeed = 2.4; //2.7;\n\nconst int STEPS = 50; //ray marching steps\nconst float EPS = 0.001; //precision (epsilon)\n\n// from iq's \"Anels\", from Kali's Lonely Tree shader, from Analytical geometry textbooks - rotation around axis\nmat3 rotationMat(in vec3 v, in float angle) //, in out vec3 vOut)\n{\n    float c = cos(angle), s = sin(angle);\n    return mat3(c + (1.0 - c) * v.x * v.x, \n                (1.0 - c) * v.x * v.y - s * v.z,\n                (1.0 - c) * v.x * v.z + s * v.y,\n                \n                (1.0 - c) * v.x * v.y + s * v.z,\n                c + (1.0 - c) * v.y * v.y,\n                (1.0 - c) * v.y * v.z - s * v.x,\n                \n                (1.0 - c) * v.x * v.z - s * v.y,\n                (1.0 - c) * v.y * v.z + s * v.x,\n                c + (1.0 - c) * v.z * v.z);\n}\n\n// jerome, Electricity\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm8(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i < 8; i++) {\n        total += noise(n)/2. * amplitude;\n        n += n;\n        amplitude *= 0.5;\n    }\n    return total;\n}\n\n//Based on Electricity, but modified by Twenkid to look somewhat like a burst of hot gas.\n//Should be optimized and varied - e.g. arrays and cycles/more streams/more adjustible\nvec3 electricity(vec2 uv ){    \n   vec2 t = uv * vec2(2.0,1.0) - iTime*4.0;      \n   float ybase = 0.30, ystep = 0.03;\n   float ycenter = ybase+fbm8(t)*0.35;\n    \n   float ycenter2 = ybase+ystep+fbm8(t)*0.5;\n   float ycenter3 = ybase-ystep+fbm8(t)*0.5;    \n   float diff = abs(uv.y - ycenter);\n   float c1 = 1.0 - mix(0.0,0.3,diff*21.0);\n     \n    c1 = clamp(c1, 0., 1.);\n    vec3 col = vec3(c1*0.9, 0.9*c1,c1*0.2);\n        \n    float diff2 = abs(uv.y - ycenter2);\n    float c2 = 1.0 - mix(0.0,0.2,diff2*21.0);    \n    col = mix(col, vec3(c2*0.7, 0.4*c2, c2*0.1), 0.7);\n    \n    float d3 = abs(uv.y - ycenter3);\n    float c3 = 1.0 - mix(0.0,0.3,diff2*21.0);\n    col = mix(col, vec3(c3*0.5, 0.3*c3, c3*0.1), 0.5);\n    //col = mix(col, vec3(c3*0.7+abs(noise(uv)/5.), 0.3*c3, c3*0.1), 0.5); //noise - no, too jaggy\n   // col = min(col, vec3(c3*0.7+abs(fbm8(uv)/5.), 0.3*c3, c3*0.1));\n    col = max(vec3(0.), col); //avoid negative color - electricity is multiplied in the render\n    return col;\n}\n// jerome's end\n\n//// Dave Hoskins's? noise\nfloat N1(float t) { return fract(sin(t*10234.324)*123423.23512);  }\n\nvec2 N22(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW   //modified to vec2, vec2\n\tvec2 p2  = fract(vec2(p.xyx) * vec2(443.897, 441.423)); // 437.195));\n    p2 += dot(p2, p2.yx + 19.19);\n    return fract(vec2((p2.x + p2.y)*p2.x, (p2.y+p2.y)*p2.x));\n}\n\nvec2 fbm(vec2 v){ return N22(v)*0.5 + vec2(0.25*N1(v.x)) + vec2(0.25*N1(v.y)); }\n\n//iq's box\nfloat sdBox( vec3 p, vec3 b ) { // float zoom = 3.;   \n    vec3 d = (abs(p) - b);\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n//float sdPlane(vec3 p){return p.y;} //future use - grid plane?\n\nfloat distLimitBorder(vec3 r){ //26-12-2017\n   //float step = StepBase + sin(iTime)/STEPDIV;\n   //float d3 = sdBox(r-vec3(1.0,0.25, 0.0), vec3(0.1, 0.1, z));\n   //return d3;\n    \n   vec3 axis = normalize(vec3(1.0, 0.25, 0.0));  \n   r*= rotationMat(axis, mod(fract(iTime)*6.28, 6.28));    \n   float d1 = sdBox(r-vec3( 1.0,0.25, 0.0), vec3(0.1, 0.1, z));  \n   return d1;    \n}  \n/*\nfloat distLimitBig(vec3 r){ //26-12-2017 - right border/curtain\n   float step = StepBase+ sin(iTime)/StepDiv;\n   float d3 = sdBox(r-vec3(10.0,StepBase, 0.0), vec3(9., 10., z));\n   return d3;\n}\n*/\n  \n//Distance from the objects. Should be optimized, could use one or a few common formulas,\n//except for the rotating block.\nfloat dist(vec3 r)\n{      \n   float step = StepBase + sin(iTime)/StepDiv;           \n    vec3 axis = normalize(vec3(1.0, 0.25, 0.0));     \n    vec3 r1 = r * rotationMat(axis, mod(fract(iTime)*6.28, 6.28));    \n    float d1 = sdBox(r1-vec3( 1.0,0.25, 0.0), vec3(0.1, 0.1, z));  \n    \n    float d2 = sdBox(r-vec3(1.0-step,0.25, 0.0), vec3(0.1, 0.1, z));\n    float d3 = sdBox(r-vec3(1.0-step-step,0.25, 0.0), vec3(0.1, 0.1, z));\n        \n    float d4 = sdBox(r-vec3(1.0,0.25+step, 0.0), vec3(0.1, 0.1, z));\n    float d5 = sdBox(r-vec3(1.0-step,0.25+step, 0.0), vec3(0.1, 0.1, z));\n    float d6 = sdBox(r-vec3(1.0-step-step,0.25+step, 0.0), vec3(0.1, 0.1, z));\n    \n    float d7 = sdBox(r-vec3(1.0,0.25-step, 0.0), vec3(0.1, 0.1, z));   \n    float d8 = sdBox(r-vec3(1.0-step-step,0.25-step, 0.0), vec3(0.1, 0.1, z));\n    \n    float d = min(d1,d2);\n    d = min(d, min(d3,d4));\n    d = min(d, min(d5,d6));\n    d = min(d, min(d7,d8));       \n    return d;\n}\n\n// Normal vector - http://www.pouet.net/topic.php?which=7920&page=10 by rear\nvec3 normal(vec3 p)\n{\n\t#define dr 1e-5\n\tvec3 drx = vec3(dr,0,0);\n\tvec3 dry = vec3(0,dr,0);\n\tvec3 drz = vec3(0,0,dr);\n\treturn ( vec3( dist(p+drx), dist(p+dry), dist(p+drz) ) - dist(p)) / dr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(0.);    \n    vec2 r = (fragCoord.xy / iResolution.xy);\n\tr.x*=(iResolution.x/iResolution.y);\t           \n    r -=vec2(0.1, 0.8);    \t\t    \n    vec3 camera = vec3(1.05+(sin(iTime))*cameraSpeed,cameraYz); //more to the center      \t\n    vec3 ro =  vec3(r.x, r.y+1.0, -1.0);       \n    vec3 p = ro;  //ray origin          \n\tvec3 dir = normalize(p-camera); //ray direction\n    float d; //distance\n    \n\tfor(int i=0; i<STEPS; i++) //Ray marching\n\t{\n\t\td = dist(p);\n\t\tif(d < EPS) break;\n\t\tp = p+dir*d;\n\t}\n\n    vec3 materialcolor=vec3(0.);        \n    int m;  \n    if (d<=cube) { m = 0; materialcolor = vec3(0.9,.9,.2);} //cube;\n    else { m = 1; } //materialcolor = vec3(0.);}\n            \n\tvec3 nor = normal(p);  // normal vector\n    vec3 lightpos = vec3(1.5-sin(iTime)*5., 0.1+sin(iTime), 3.5+sin(iTime)*5.);           \n    lightpos.y +=sin(iTime); // [-1., +1]\n         \n    vec3 lightdir = normalize(vec3(0.3,0.3,0.3)-lightpos);\n   \t\n    float light = 1.0 + 0.01*(dot(nor,lightpos)); //intensity\n    \n    light *=  pow(dist(lightdir-p), 2.);\n    \n\t//vec3 color = vec3(light);\n    vec3 color = vec3(1.0-light/5.); //vec3(1.0, 1.0, 1.0);\n    color = clamp( materialcolor*color, 0., 1.0);\n    \n    //Phong\n    float dif = clamp( dot( nor, lightdir ), 0.0, 1.0 ); //iq diffuse\n    vec3  ref = reflect( dir, nor );  //reflection\n    float spe = pow(clamp( dot( ref, lightdir ), 0.0, 1.0 ),16.0); //specular component\n        \n    color+=dif/3. + spe/2.;\n        \n\tfragColor = vec4(color, 1.0);\n    fragColor.xyz = vec3(color);\n    fragColor.w = m ==0 ? 1. : 0.; //\n             \n    vec2 pos = 2.0 * vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n   //The space, stars... #28-11-2017 & electricity\n   if ( fragColor.r < 0.001 && m==1)\n    {     \n        //To do: add more effects: specific stars, nebullas, planets, comets, black hole etc.... had meteors, but were removed;    \n        vec2 n1 = N22(pos);\n        float star = n1.x < 0.07 ? 0.1 : 0.;        \n        star+= n1.y > 0.97 ? N1(n1.x)/1.0*(max(star, sin(iTime))) : 0.0;\n        vec2 fb = fbm(pos);\n        star*=max(fb.x, fb.y);       \n        fragColor += star*1.4; //brighter stars\n        fragColor.a = 1.0;                                 \n        fragColor.xyzw+=vec4(clamp(abs(cos(iTime/3.5))*4.28, 1., 3.)*electricity(uv), 1.0); //thick line        \n    }\n    else //The blocks\n    {     \n     const float EPSLIMIT = EPS*5.; //0.06;\n     float limit = 0.0;     \n     ro =  vec3(r.x, r.y+1.0, -1.0);    \n     p = ro;\n\t dir = normalize(p-camera);                     \n\t for(int i=0; i<STEPS/3; i++)  //Second marching for the rotating block and the burst. Fewer steps and lower precision are enough.\n\t {\n        d = distLimitBorder(p);\n\t\tif(d < EPSLIMIT) break;\n\t\tp = p + dir * d;\n\t  }\n        \n      if (d<EPSLIMIT) fragColor.xyz += electricity(uv);\n            \n      fragColor.w = 1.0; //Alpha\n      \n    }\n   \n    //Gamma correction\n     fragColor.xyz=pow(fragColor.xyz, vec3(1.4));\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/* \n  \"Hackafe Logo\" - exercise #1. Version: 27.12.2017\n  \"Author\"/(formulas player) - Todor \"Tosh\" Arnaudov, 27-12-2017\n   Hackafe hackerspace - Plovdiv, Bulgaria. Currently hibernated: http://www.hackafe.org/\n*/\n\n//jerome, Electricity\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm8(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i < 16; i++) {\n        total += noise(n)/2. * amplitude;\n        n += n;\n        amplitude *= 0.5;\n        //amplitude *= 0.33;\n    }\n    return total;\n}\n\nfloat fbm16(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i < 16; i++) {\n        total += noise(n)/2. * amplitude;\n        n += n;\n        amplitude *= 0.25;\n        //amplitude *= 0.33;\n    }\n    return total;\n}\n\n\nvec2 mainSound( in int samp, float time )\n{\n    //vec2 s1 = vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n    //vec2 s2 = vec2(sin(440.+fbm8(vec2(time))*100.*mod(time,10.))+fbm8(vec2(time)))*2.;\n    //vec2 s2 = vec2(sin(440.+fbm8(vec2(time))*100.*exp(fract(time)*12.))+fbm8(vec2(time)))*1.;\n   // vec2 s2 = vec2(sin(440.+fbm8(vec2(time))*100.*sin(exp(fract(time)*12.)))+fbm8(vec2(time)))*1.; //laser :))\n    //vec2 s1 = vec2(sin(440.+fbm8(vec2(time/3.))*200.*exp(fract(time/20.)*12.))+fbm16(vec2(time)))*((1.+cos(time))*sin(time+3.1415));    \n    vec2 s1 = vec2(sin(440.+fbm8(vec2(time/2.))*70.*exp(fract(time/20.)*12.))+fbm16(vec2(time)))*2.;\n   // vec2 s2 = vec2(sin(440.+fbm16(vec2(time/3.))*100.*exp(fract(time/20.)*12.))+fbm8(vec2(time)))*1.;\n    //s1 = smoothstep(0.5, 0., s1);\n//    float x = remap(0., 1., 0., 0.5, s1.x);\n   \n   // float t = sin(time);\n   //if (time>25.) vec2 s = mix(s1, s2, abs(time/));\n   // vec2 s2 = vec2(sin(880.+fbm8(vec2(time))/10.*440.*mod(time,10.)));\n    vec2 s2 = vec2(sin(220.+fbm8(vec2(time))*70.*exp(fract(time/40.)*12.))+fbm8(vec2(time)))*1.;\n    //float f3 = sin(tone[i]*fract(fbm8(vec2(time)))*0.2;\n    s1 = mix(s1, s2, 0.5);\n    //s1 = mix(s1, vec2(s1.x, f3), 0.1);\n    s1 = vec2(s1.x)*0.15;  \n    \n    return s1;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}