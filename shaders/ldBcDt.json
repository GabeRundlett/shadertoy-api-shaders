{
    "Shader": {
        "info": {
            "date": "1494328876",
            "description": "Example Path Tracer which does Next Event Estimation and Multiple Importance Sampling.\nCheck direct light demo with MIS here : https://www.shadertoy.com/view/4sSXWt ",
            "flags": 0,
            "hasliked": 0,
            "id": "ldBcDt",
            "likes": 44,
            "name": "Path Tracer MIS",
            "published": 3,
            "tags": [
                "pathtracer",
                "microfacet",
                "pbr",
                "pt",
                "render",
                "ggx",
                "lightpathtracing"
            ],
            "usePreview": 1,
            "username": "koiava",
            "viewed": 3861
        },
        "renderpass": [
            {
                "code": "#define PIXEL_SAMPLES \t\t1\t\t//samples per pixel. Increase for better image quality\n#define DL_SAMPLES\t\t\t1\t\t//direct light samples\n#define MAX_DEPTH\t\t\t3\t\t//GI depth\n#define LENS_SIZE\t\t\t0.2\t\t//depth of field\n#define CLAMP_VALUE\t\t\t2.0\t\t//biased rendering\n#define CLAMP_CAUSTICS\t\t\t\t//biased rendering\n//#define TEXTURES\t\t\t//uncomment to enable textures\n//#define NORMAL_MAPS\t\t//uncomment to enable normal mapping(textures are necessery for normal mapping)\n\n#define SPHERE_LIGHT\n\nconst vec3 backgroundColor = vec3( 0.0 );\n\n//used macros and constants\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.0001 \n#define EQUAL_FLT(a,b,eps)\t(((a)>((b)-(eps))) && ((a)<((b)+(eps))))\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n//********************************************\n\nbool is_inf(float val) {\n\treturn val != val;\n    //return isinf(val);\t//webGL 2.0 is required\n}\n\n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n//////////////////////////////////////////////////////////////////////////\n// Converting PDF from Solid angle to Area\nfloat PdfWtoA( float aPdfW, float aDist2, float aCosThere ){\n    if( aDist2 < EPSILON )\n        return 0.0;\n    return aPdfW * abs(aCosThere) / aDist2;\n}\n\n// Converting PDF between from Area to Solid angle\nfloat PdfAtoW( float aPdfA, float aDist2, float aCosThere ){\n    float absCosTheta = abs(aCosThere);\n    if( absCosTheta < EPSILON )\n        return 0.0;\n    \n    return aPdfA * aDist2 / absCosTheta;\n}\n\nfloat misWeight( in float a, in float b ) {\n    float a2 = a*a;\n    float b2 = b*b;\n    float a2b2 = a2 + b2;\n    return a2 / a2b2;\n}\n//////////////////////////////////////////////////////////////////////////\n\nvec3 toVec3( vec4 v ) {\n    if( IS_ZERO( v.w ) ) {\n        return v.xyz;\n    }\n    \n    return v.xyz*(1.0/v.w);\n}\n\nmat3 mat3Inverse( in mat3 m ) {\n    return mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n\t\t\t\t\tvec3( m[0][1], m[1][1], m[2][1] ),\n                    vec3( m[0][2], m[1][2], m[2][2] ) );\n}\n\n//fast inverse for orthogonal matrices\nmat4 mat4Inverse( in mat4 m ) {\n    mat3 rotate_inv = mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n                          \tvec3( m[0][1], m[1][1], m[2][1] ),\n                          \tvec3( m[0][2], m[1][2], m[2][2] ) );\n    \n    return mat4(\tvec4( rotate_inv[0], 0.0 ),\n                \tvec4( rotate_inv[1], 0.0 ),\n                \tvec4( rotate_inv[2], 0.0 ),\n              \t\tvec4( (-rotate_inv)*m[3].xyz, 1.0 ) );\n}\n      \nstruct SurfaceHitInfo {\n    vec3 position_;\n\tvec3 normal_;\n    vec3 tangent_;\n    vec2 uv_;\n    int mtl_id_;\n};\n    \n#define SURFACE_ID_BASE\t0\n#define LIGHT_ID_BASE\t64\n\n#define MTL_LIGHT \t\t0\n#define MTL_DIFFUSE\t\t1\n    \n\n#define OBJ_PLANE\t\t0\n#define OBJ_SPHERE\t\t1\n#define OBJ_CYLINDER\t2\n#define OBJ_AABB\t\t3\n#define OBJ_DISK\t\t4\n#define OBJ_TORUS\t\t5\n    \nstruct Object {\n    int type_;\n    int mtl_id_;\n    mat4 transform_;\n    mat4 transform_inv_;\n    \n    float params_[6];\n};\n\n//Weighted sum of Lambertian and Blinn brdfs\nstruct Material {\n    vec3 diffuse_color_;\n    int diffuse_color_tex_;\n    vec3 specular_color_;\n    float specular_roughness_;\n    int specular_roughness_tex_;\n    float specular_weight_;\n    int specular_weight_tex_;\n    int normal_map_;\n    float tex_scale_;\n};\n    \nstruct Light {\n    vec3 color_;\n    float intensity_;\n};\n    \nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \nstruct Camera {\n    mat3 rotate;\n    vec3 pos;\n    float fovV;\n    float lensSize;\n    float focusDist;\n};\n    \nstruct LightSamplingRecord {\n    vec3 w;\n    float d;\n    float pdf;\n};\n    \n// ************ SCENE ***************\nLight lights[2];\nMaterial materials[7];\nObject objects[8];\nCamera camera;\n//***********************************\nMaterial getMaterial(int i) {\n    if(i==0) return materials[0]; else\n        if(i==1) return materials[1]; else\n            if(i==2) return materials[2]; else\n                if(i==3) return materials[3]; else\n                    if(i==4) return materials[4]; else\n                        if(i==5) return materials[5]; else\n                            return materials[6];\n    //return materials[i];\t//webGL 2.0\n}\n\nLight getLight(int i) {\n    if(i==0) return lights[0]; else\n        return lights[1];\n    //return lights[i];\n}\n\nvec3 getColor(vec2 uv, int tex) {\n#ifdef TEXTURES\n    if(tex==0)\treturn texture( iChannel0, uv).xyz; else\n    if(tex==1)\treturn texture( iChannel1, uv).xyz; else\n    \t\t\treturn texture( iChannel2, uv).xyz;\n#else\n    if(tex==0)\treturn vec3(0.8, 0.5, 0.3);\n    if(tex==1)\treturn vec3(0.5, 0.5, 0.6);\n\t\t\t\treturn vec3(0.7, 0.7, 0.7);\n#endif\n}\n\nvec3 getNormal(vec2 uv, int tex ) {\n#ifdef NORMAL_MAPS\n    float heightScale = 0.004;\n    float dHdU, dHdV;\n    \n    float hpx, hmx, hpy, hmy, h0;\n    vec3 c, c1, c2, c3, c4;\n    vec2 duv;\n    \n    if(tex==0){\n        vec2 res = iChannelResolution[0].xy;\n    \tduv = vec2(1.0) / res.xy;\n \t\tc = texture( iChannel0, uv).xyz;\n        c1 = texture( iChannel0, uv + vec2(duv.x, 0.0)).xyz;\n        c2 = texture( iChannel0, uv - vec2(duv.x, 0.0)).xyz;\n        c3 = texture( iChannel0, uv + vec2(0.0, duv.y)).xyz;\n        c4 = texture( iChannel0, uv - vec2(0.0, duv.y)).xyz;\n    } else if(tex==1) {\n        vec2 res = iChannelResolution[1].xy;\n    \tduv = vec2(1.0) / res.xy;\n        c = texture( iChannel1, uv).xyz;\n        c1 = texture( iChannel1, uv + vec2(duv.x, 0.0)).xyz;\n        c2 = texture( iChannel1, uv - vec2(duv.x, 0.0)).xyz;\n        c3 = texture( iChannel1, uv + vec2(0.0, duv.y)).xyz;\n        c4 = texture( iChannel1, uv - vec2(0.0, duv.y)).xyz;\n        res = iChannelResolution[1].xy;\n    } else {\n        vec2 res = iChannelResolution[2].xy;\n    \tduv = vec2(1.0) / res.xy;\n        c = texture( iChannel2, uv).xyz;\n        c1 = texture( iChannel2, uv + vec2(duv.x, 0.0)).xyz;\n        c2 = texture( iChannel2, uv - vec2(duv.x, 0.0)).xyz;\n        c3 = texture( iChannel2, uv + vec2(0.0, duv.y)).xyz;\n        c4 = texture( iChannel2, uv - vec2(0.0, duv.y)).xyz;\n        res = iChannelResolution[2].xy;\n    }\n    \n    h0\t= heightScale * dot(c , vec3(1.0/3.0));\n    hpx = heightScale * dot(c1, vec3(1.0/3.0));\n    hmx = heightScale * dot(c2, vec3(1.0/3.0));\n    hpy = heightScale * dot(c3, vec3(1.0/3.0));\n    hmy = heightScale * dot(c4, vec3(1.0/3.0));\n    dHdU = (hmx - hpx) / (2.0 * duv.x);\n    dHdV = (hmy - hpy) / (2.0 * duv.y);\n    \n    return normalize(vec3(dHdU, dHdV, 1.0));\n#else\n    return vec3(0.0, 0.0, 1.0);\n#endif\n}\n\nvec3 getRadiance(vec2 uv) {\n    return /*getColor(uv, 2)*lights[0].color_**/vec3(1.0, 1.0, 1.0)*lights[0].intensity_;\n}\n\nvoid createMaterial(vec3 diff,\n                    int diff_tex,\n                    vec3 spec,\n                    float roughness,\n                    int roughness_tex,\n                   \tfloat weight,\n                    int weight_tex,\n                    int normal_map,\n                    float tex_scale,\n                    out Material mtl) {\n    mtl.diffuse_color_ = diff;\n    mtl.diffuse_color_tex_ = diff_tex;\n    mtl.specular_color_ = spec;\n    mtl.specular_roughness_ = roughness;\n    mtl.specular_roughness_tex_ = roughness_tex;\n    mtl.specular_weight_ = weight;\n    mtl.specular_weight_tex_ = weight_tex;\n    mtl.normal_map_ = normal_map;\n    mtl.tex_scale_ = tex_scale;\n}\n\nvoid createLight(vec3 color, float intensity, out Light light) {\n    light.color_ = color;\n    light.intensity_ = intensity;\n}\n\nvoid createAABB( mat4 transform, vec3 bound_min, vec3 bound_max, int mtl, out Object obj) {\n    vec3 xAcis = normalize( vec3( 0.9, 0.0, 0.2 ) );\n    vec3 yAcis = vec3( 0.0, 1.0, 0.0 );\n    obj.type_ = OBJ_AABB;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = bound_min.x;\n    obj.params_[1] = bound_min.y;\n    obj.params_[2] = bound_min.z;\n    obj.params_[3] = bound_max.x;\n    obj.params_[4] = bound_max.y;\n    obj.params_[5] = bound_max.z;\n}\n\nvoid createTorus( mat4 transform, float R, float r, int mtl, out Object obj) {\n    vec3 xAcis = normalize( vec3( 0.9, 0.0, 0.2 ) );\n    vec3 yAcis = vec3( 0.0, 1.0, 0.0 );\n    obj.type_ = OBJ_TORUS;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = R*R;\n    obj.params_[1] = r*r;\n}\n\nvoid createPlane(mat4 transform, float minX, float minY, float maxX, float maxY, int mtl, out Object obj) {\n    obj.type_ = OBJ_PLANE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = minX;\t\t\t//min x\n    obj.params_[1] = minY;\t\t\t//min y\n    obj.params_[2] = maxX;\t\t\t//max x\n    obj.params_[3] = maxY;\t\t\t//max y\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createDisk(mat4 transform, float r, float R, int mtl, out Object obj) {\n    obj.type_ = OBJ_DISK;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r*r;\n    obj.params_[1] = R*R;\n}\n\nvoid createSphere(mat4 transform, float r, int mtl, out Object obj) {\n    obj.type_ = OBJ_SPHERE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = r*r;\t\t//radius^2\n    obj.params_[2] = 0.0;\t\t//not used\n    obj.params_[3] = 0.0;\t\t//not used\n    obj.params_[4] = 0.0;\t\t//not used \n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createCylinder(mat4 transform, float r, float minZ, float maxZ, float maxTheta, int mtl, out Object obj) {\n    obj.type_ = OBJ_CYLINDER;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = minZ;\t\t//min z\n    obj.params_[2] = maxZ;\t\t//max z\n    obj.params_[3] = maxTheta;\t//max phi\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nmat4 createCS(vec3 p, vec3 z, vec3 x) {\n    z = normalize(z);\n    vec3 y = normalize(cross(z,x));\n    x = cross(y,z);\n    \n    return mat4(\tvec4( x, 0.0 ), \n    \t\t\t \tvec4( y, 0.0 ),\n    \t\t\t\tvec4( z, 0.0 ),\n    \t\t\t\tvec4( p, 1.0 ));\n}\n\n// Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(1.0 - Xi1);\n    float theta = Xi2*TWO_PI;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\n//taken from: https://www.shadertoy.com/view/4sSSW3\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n    if(n.z < -0.999999) {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    } else {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n}\n\nmat3 mat3FromNormal(in vec3 n) {\n    vec3 x;\n    vec3 y;\n    basis(n, x, y);\n    return mat3(x,y,n);\n}\n\nvec3 localToWorld( in vec3 localDir, in vec3 normal ) {\n    vec3 a,b;\n    basis( normal, a, b );\n\treturn localDir.x*a + localDir.y*b + localDir.z*normal;\n}\n\nvoid cartesianToSpherical( \tin vec3 xyz,\n                         \tout float rho,\n                          \tout float phi,\n                          \tout float theta ) {\n    rho = sqrt((xyz.x * xyz.x) + (xyz.y * xyz.y) + (xyz.z * xyz.z));\n    phi = asin(xyz.y / rho);\n\ttheta = atan( xyz.z, xyz.x );\n}\n\nvec3 sphericalToCartesian( in float rho, in float phi, in float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvec3 sampleHemisphereCosWeighted( in vec3 n, in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return localToWorld( sphericalToCartesian( 1.0, phi, theta ), n );\n}\n\nvec3 sampleHemisphereCosWeighted( in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return sphericalToCartesian( 1.0, phi, theta );\n}\n\nvec3 randomDirection( in float Xi1, in float Xi2 ) {\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n//*****************************************************************************\n\n// ************************   Scattering functions  *************************\nbool sameHemisphere(in vec3 n, in vec3 a, in vec3 b){\n\treturn ((dot(n,a)*dot(n,b))>0.0);\n}\n\nbool sameHemisphere(in vec3 a, in vec3 b){\n\treturn (a.z*b.z>0.0);\n}\n\nfloat cosTheta(vec3 w) { return w.z; }\nfloat cosTheta2(vec3 w) { return cosTheta(w)*cosTheta(w); }\nfloat absCosTheta(vec3 w) { return abs(w.z); }\nfloat sinTheta2(vec3 w) { return max(0.0, 1.0 - cosTheta2(w)); }\nfloat sinTheta(vec3 w) { return sqrt(sinTheta2(w)); }\nfloat tanTheta2(vec3 w) { return sinTheta2(w) / cosTheta2(w); }\nfloat tanTheta(vec3 w) { return sinTheta(w) / cosTheta(w); }\n\nfloat cosPhi(vec3 w) { float sin_Theta = sinTheta(w); return (sin_Theta == 0.0) ? 1.0 : clamp(w.x / sin_Theta, -1.0, 1.0); }\nfloat sinPhi(vec3 w) { float sin_Theta = sinTheta(w); return (sin_Theta == 0.0) ? 0.0 : clamp(w.y / sin_Theta, -1.0, 1.0); }\nfloat cosPhi2(vec3 w) { return cosPhi(w) * cosPhi(w); }\nfloat sinPhi2(vec3 w) { return sinPhi(w) * sinPhi(w); }\n\nfloat ggx_eval(vec3 wh, float alphax, float alphay) {\n    float tan2Theta = tanTheta2(wh);\n    if (is_inf(tan2Theta)) return 0.;\n    float cos4Theta = cosTheta2(wh) * cosTheta2(wh);\n    float e = ((cosPhi2(wh) + sinPhi2(wh)) / (alphax * alphay)) * tan2Theta;\n    return 1.0 / (PI * (alphax * alphay) * cos4Theta * (1.0 + e) * (1.0 + e));\n}\n\nvec3 ggx_sample(vec3 wi, float alphax, float alphay, float Xi1, float Xi2) {\n    //stretch view\n    vec3 v = normalize(vec3(wi.x * alphax, wi.y * alphay, wi.z));\n\n    //orthonormal basis\n    vec3 t1 = (v.z < 0.9999) ? normalize(cross(v, vec3(0.0, 0.0, 1.0))) : vec3(1.0, 0.0, 0.0);\n    vec3 t2 = cross(t1, v);\n\n    //sample point with polar coordinates\n    float a = 1.0 / (1.0 + v.z);\n    float r = sqrt(Xi1);\n    float phi = (Xi2 < a) ? Xi2 / a*PI : PI + (Xi2 - a) / (1.0 - a) * PI;\n    float p1 = r*cos(phi);\n    float p2 = r*sin(phi)*((Xi2 < a) ? 1.0 : v.z);\n\n    //compute normal\n    vec3 n = p1*t1 + p2*t2 + v*sqrt(1.0 - p1*p1 - p2*p2);\n\n    //unstretch\n    return normalize(vec3(n.x * alphax, n.y * alphay, n.z));\n}\n\n\nfloat ggx_lambda(vec3 w, float alphax, float alphay) {\n    float absTanTheta = abs(tanTheta(w));\n    if (is_inf(absTanTheta)) return 0.;\n    // Compute _alpha_ for direction _w_\n    float alpha_ = sqrt((cosPhi2(w) + sinPhi2(w)) * (alphax * alphay));\n    float alpha2Tan2Theta = (alpha_ * absTanTheta) * (alpha_ * absTanTheta);\n    return (-1.0 + sqrt(1.0 + alpha2Tan2Theta)) / 2.0;\n}\n\nfloat ggx_g1(vec3 w, float alphax, float alphay) {\n    return 1.0 / (1.0 + ggx_lambda(w, alphax, alphay));\n}\n\nfloat ggx_g(vec3 wo, vec3 wi, float alphax, float alphay) {\n    return 1.0 / (1.0 + ggx_lambda(wo, alphax, alphay) + ggx_lambda(wi, alphax, alphay));\n}\n\nfloat ggx_pdf(vec3 wi, vec3 wh, float alphax, float alphay) {\n    return ggx_eval(wh, alphax, alphay) * ggx_g1(wi, alphax, alphay) * abs(dot(wi, wh)) / abs(wi.z);\n}\n\nvec3 fresnelConductor( float cosTheta, vec3 eta, vec3 k ) {\n\tvec3 tmp = (eta*eta + k*k) * (cosTheta * cosTheta);\n\n\tvec3 rParl2 = \t(tmp - (eta * (2.0 * cosTheta)) + vec3(1.0)) /\n        \t\t\t(tmp + (eta * (2.0 * cosTheta)) + vec3(1.0));\n\n\tvec3 tmpF = eta*eta + k*k;\n\n\tvec3 rPerp2 = \t(tmpF - (eta * (2.0 * cosTheta)) + vec3(cosTheta*cosTheta)) /\n\t\t\t\t\t(tmpF + (eta * (2.0 * cosTheta)) + vec3(cosTheta*cosTheta));\n\n\treturn (rParl2 + rPerp2) / 2.0;\n}\n\nvec3 mtlEval(Material mtl, in vec3 Ng, in vec3 Ns, in vec3 E, in vec3 L) {\n    mat3 trans = mat3FromNormal(Ns);\n    mat3 inv_trans = mat3Inverse( trans );\n    \n    vec3 E_local = inv_trans * E;\n    vec3 L_local = inv_trans * L;\n    \n    float alpha = mtl.specular_roughness_;\n    \n    if(!sameHemisphere(E_local, L_local)) {\n        return vec3(0.0);\n    }\n    \n    //Specular reflection ***********************************\n    float cosThetaO = abs(E_local.z), cosThetaI = abs(L_local.z);\n    vec3 wh = L_local + E_local;\n    // Handle degenerate cases for microfacet reflection\n    if (cosThetaI == 0.0 || cosThetaO == 0.0) return vec3(0.);\n    if (wh.x == 0.0 && wh.y == 0.0 && wh.z == 0.0) return vec3(0.);\n    \n    wh = normalize(wh);\n    \n    vec3 F = fresnelConductor(dot(L_local, wh), vec3(1.5/1.0), vec3(1.0));\n    vec3 spec_Refl = \tmtl.specular_color_ * \n        \t\t\t\tggx_eval(wh, alpha, alpha) *\n        \t\t\t\tggx_g(E_local, L_local, alpha, alpha) *\n        \t\t\t\tF / (4.0 * cosThetaI * cosThetaO);\n    \n    vec3 diff_refl = \tvec3(INV_PI) * \n        \t\t\t\tmtl.diffuse_color_ * \n        \t\t\t\t(vec3(1.0) - F);\n    \n    return \tmix(diff_refl, spec_Refl, mtl.specular_weight_);\n}\n\nvec3 mtlSample(Material mtl, in vec3 Ng, in vec3 Ns, in vec3 E, in float Xi1, in float Xi2, out vec3 L, out float pdf, out float spec) {\n    mat3 trans = mat3FromNormal(Ns);\n    mat3 inv_trans = mat3Inverse( trans );\n    \n    //convert directions to local space\n    vec3 E_local = inv_trans * E;\n    vec3 L_local;\n    \n    float alpha = mtl.specular_roughness_;\n    // Sample microfacet orientation $\\wh$ and reflected direction $\\wi$\n    if (E_local.z == 0.0) return vec3(0.);\n    vec3 wh = ggx_sample(E_local, alpha, alpha, Xi1, Xi2);\n    if (!sameHemisphere(vec3(0.0, 0.0, 1.0), E_local, wh)) {\n        wh = -wh;\n    }\n    \n    float F = length(fresnelConductor(dot(L_local, wh), vec3(1.5/1.0), vec3(1.0)));\n    //Sample specular or diffuse lobe based on fresnel\n    if(rnd() < F) {\n        L_local = reflect(E_local, wh);\n    \n        if(!sameHemisphere(E_local, L_local)){\n           L_local = -L_local;\n        }\n\n        if (!sameHemisphere(E_local, L_local)) {\n            pdf = 0.0;\n        } else {\n            // Compute PDF of _wi_ for microfacet reflection\n            pdf = ggx_pdf(E_local, wh, alpha, alpha) / (4.0 * dot(E_local, wh));\n        }\n        //pdf *= F;\n    } else {\n        L = sampleHemisphereCosWeighted( Xi1, Xi2 );\n    \tpdf = INV_PI;\n        //pdf *= 1.0 - F;\n    }\n    \n    //convert directions to global space\n    L = trans*L_local;\n    \n    if(!sameHemisphere(Ns, E, L) || !sameHemisphere(Ng, E, L)) {\n        pdf = 0.0;\n    }\n    \n    return mtlEval(mtl, Ng, Ns, E, L);\n}\n\nfloat mtlPdf(Material mtl, in vec3 Ng, in vec3 Ns, in vec3 E, in vec3 L) {\n    mat3 trans = mat3FromNormal(Ns);\n    mat3 inv_trans = mat3Inverse( trans );\n    float alpha = mtl.specular_roughness_;\n    \n    vec3 E_local = inv_trans * E;\n    vec3 L_local = inv_trans * L;\n    \n    if(!sameHemisphere(Ng, E_local, L_local)) {\n        return 0.0;\n    }\n    float diff_pdf = abs(L_local.z)*INV_PI;\n    \n    if (!sameHemisphere(E_local, L_local)) return 0.0;\n    vec3 wh = normalize(E_local + L_local);\n    float spec_pdf = ggx_pdf(E_local, wh, alpha, alpha) / (4.0 * dot(E_local, wh));\n    \n    return mix(diff_pdf, spec_pdf, mtl.specular_weight_);\n}\n\n\n// ************************  INTERSECTION FUNCTIONS **************************\nbool solveQuadratic(float A, float B, float C, out float t0, out float t1) {\n\tfloat discrim = B*B-4.0*A*C;\n    \n\tif ( discrim <= 0.0 )\n        return false;\n    \n\tfloat rootDiscrim = sqrt( discrim );\n    \n    float t_0 = (-B-rootDiscrim)/(2.0*A);\n    float t_1 = (-B+rootDiscrim)/(2.0*A);\n    \n    t0 = min( t_0, t_1 );\n    t1 = max( t_0, t_1 );\n    \n\treturn true;\n}\n\nbool rayAABBIntersection( in Ray ray, float minX, float minY, float minZ, float maxX, float maxY, float maxZ, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    vec3 boxMin = vec3( minX, minY, minZ );\n    vec3 boxMax = vec3( maxX, maxY, maxZ );\n    \n    vec3 OMIN = ( boxMin - ray.origin ) / ray.dir;\n    vec3 OMAX = ( boxMax - ray.origin ) / ray.dir;\n    vec3 MAX = max ( OMAX, OMIN );\n    vec3 MIN = min ( OMAX, OMIN );\n    float t1 = min ( MAX.x, min ( MAX.y, MAX.z ) );\n    t = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) );\n    \n    if ( t1 <= t )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        \n        if( EQUAL_FLT( isect.position_.x, minX, EPSILON ) ) {\n            isect.normal_ =  vec3( -1.0, 0.0, 0.0 );\n            isect.tangent_ \t\t= vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.x, maxX, EPSILON ) ) {\n            isect.normal_ =  vec3( 1.0, 0.0, 0.0 );\n            isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.y, minY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, -1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.y, maxY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.z, minZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, -1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.z, maxZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, 1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        }\n        \n        isect.uv_ /= 2.0;\n    }\n    \n    return true;\n}\n\nbool raySphereIntersection( in Ray ray, in float radiusSquared, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    float t0, t1;\n    vec3 L = ray.origin;\n    float a = dot( ray.dir, ray.dir );\n    float b = 2.0 * dot( ray.dir, L );\n    float c = dot( L, L ) - radiusSquared;\n    \n    if (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n    \n    if( t0 > 0.0 ) {\n    \tt = t0;\n    } else {\n        if ( t1 > 0.0 ) {\n            t = t1;\n        } else {\n            return false;\n        }\n    }\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        isect.normal_ = normalize( isect.position_ );\n\n        float rho, phi, theta;\n        cartesianToSpherical( isect.normal_, rho, phi, theta );\n        isect.uv_.x = phi/PI;\n        isect.uv_.y = theta/TWO_PI;\n\n        isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n        vec3 tmp = cross( isect.normal_, isect.tangent_ );\n        isect.tangent_ = normalize( cross( tmp, isect.normal_ ) );\n    }\n\t\n\treturn true;\n}\n\nbool rayAAPlaneIntersection( in Ray ray, in float min_x, in float min_y, in float max_x, in float max_y, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    if ( IS_ZERO( ray.dir.z ) )\n    \treturn false;\n    \n    t = ( -ray.origin.z ) / ray.dir.z;\n    \n    isect.position_ = ray.origin + ray.dir*t;\n    \n    if( (isect.position_.x < min_x) ||\n       \t(isect.position_.x > max_x) ||\n      \t(isect.position_.y < min_y) ||\n      \t(isect.position_.y > max_y) )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.uv_.x \t\t= (isect.position_.x - min_x)/(max_x - min_x);\n        isect.uv_.y \t\t= (isect.position_.y - min_y)/(max_y - min_y);\n        isect.normal_ \t\t= vec3( 0.0, 0.0, 1.0 );\n        isect.tangent_ \t\t= vec3( 1.0, 0.0, 0.0 );\n    }\n    \n    return true;\n}\n\nbool rayDiskIntersection( in Ray ray, in float r2, in float R2, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    if ( IS_ZERO( ray.dir.z ) )\n    \treturn false;\n    \n    t = ( -ray.origin.z ) / ray.dir.z;\n    \n    isect.position_ = ray.origin + ray.dir*t;\n    \n    float d2 = dot(isect.position_, isect.position_);\n    \n    if( d2 < r2 || d2 > R2 )\n        return false;\n    \n    if( !forShadowTest ) {\n        float R = sqrt(R2);\n        isect.uv_.x \t\t= (isect.position_.x - R)/(2.0*R);\n        isect.uv_.y \t\t= (isect.position_.y - R)/(2.0*R);\n        isect.normal_ \t\t= vec3( 0.0, 0.0, 1.0 );\n        isect.tangent_ \t\t= vec3( 1.0, 0.0, 0.0 );\n    }\n    \n    return true;\n}\n\nbool rayCylinderIntersection( in Ray r, in float radius, in float minZ, in float maxZ, in float maxPhi, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n\tfloat phi;\n\tvec3 phit;\n    \n\t// Compute quadratic cylinder coefficients\n\tfloat a = r.dir.x*r.dir.x + r.dir.y*r.dir.y;\n\tfloat b = 2.0 * (r.dir.x*r.origin.x + r.dir.y*r.origin.y);\n\tfloat c = r.origin.x*r.origin.x + r.origin.y*r.origin.y - radius*radius;\n \n\t// Solve quadratic equation for _t_ values\n\tfloat t0, t1;\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n\n    if ( t1 < 0.0 )\n        return false;\n    \n\tt = t0;\n    \n\tif (t0 < 0.0)\n\t\tt = t1;\n\n\t// Compute cylinder hit point and $\\phi$\n\tphit = r.origin + r.dir*t;\n\tphi = atan(phit.y,phit.x);\n    phi += PI;\n    \n\tif (phi < 0.0)\n        phi += TWO_PI;\n \n\t// Test cylinder intersection against clipping parameters\n\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) ) {\n\t\tif (t == t1)\n            return false;\n\t\tt = t1;\n\t\t// Compute cylinder hit point and $\\phi$\n\t\tphit = r.origin + r.dir*t;\n\t\tphi = atan(phit.y,phit.x);\n        phi += PI;\n\n\t\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) )\n\t\t\treturn false;\n\t}\n    \n    if( !forShadowTest ) {\n        isect.position_ = phit;\n        isect.uv_.x = (phit.z - minZ)/(maxZ - minZ);\n        isect.uv_.y = phi/maxPhi;\n        isect.normal_ = normalize( vec3( phit.xy, 0.0 ) );\n        isect.tangent_ = vec3( 0.0, 0.0, 1.0 );\n    }\n    \n\treturn true;\n}\n\nbool rayObjectIntersect( in Ray ray, in Object obj, in float distMin, in float distMax, in bool forShadowTest, out SurfaceHitInfo hit, out float dist ) {\n    bool hitResult = false;\n    float t;\n    SurfaceHitInfo currentHit;\n\n    //Convert ray to object space\n    Ray rayLocal;\n    rayLocal.origin = toVec3( obj.transform_inv_*vec4( ray.origin, 1.0 ) );\n    rayLocal.dir \t= toVec3( obj.transform_inv_*vec4( ray.dir   , 0.0 ) );\n\n    if( obj.type_ == OBJ_PLANE ) {\n        hitResult = rayAAPlaneIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_SPHERE ) {\n        hitResult = raySphereIntersection( \trayLocal, obj.params_[1], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_CYLINDER ) {\n        hitResult = rayCylinderIntersection(rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_AABB ) {\n        hitResult = rayAABBIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], obj.params_[4], obj.params_[5], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_DISK ) {\n        hitResult = rayDiskIntersection( rayLocal, obj.params_[0], obj.params_[1], forShadowTest, t, currentHit );\n    }\n\n    if( hitResult && ( t > distMin ) && ( t < distMax ) ) {\n        //Convert results to world space\n        currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );\n        currentHit.normal_   = toVec3( obj.transform_*vec4( currentHit.normal_  , 0.0 ) );\n        currentHit.tangent_  = toVec3( obj.transform_*vec4( currentHit.tangent_ , 0.0 ) );\n\n        dist = t;\n        hit = currentHit;\n        hit.mtl_id_ = obj.mtl_id_;\n        \n        return true;\n    } else {\n    \treturn false;\n    }\n}\n\n#define CHECK_OBJ( obj ) { SurfaceHitInfo currentHit; float currDist; if( rayObjectIntersect( ray, obj, distMin, nearestDist, forShadowTest, currentHit, currDist ) && ( currDist < nearestDist ) ) { nearestDist = currDist; hit = currentHit; } }\nbool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {\n    nearestDist = 10000.0;\n    \n    for(int i=0; i<8; i++ ) {\n        CHECK_OBJ( objects[i] );\n    }\n    return ( nearestDist < 1000.0 );\n}\n// ***************************************************************************\n\n\nvoid initScene() {\n    float time = 100.0;//iTime;\n    \n    //create lights\n    createLight(vec3(1.0, 1.0, 0.9), 40.0, lights[0]);\n    \n    //Create materials\n    createMaterial(vec3(0.6, 1.0, 0.6), -1, vec3(0.5, 1.0, 0.5), 0.15, -1, 0.6, -1, -1, 1.0, materials[0]);\n    createMaterial(vec3(1.0, 1.0, 1.0), 0, vec3(1.0, 1.0, 1.0), 0.0, 0, 0.2, -1, 0, 2.0, materials[1]);\n    createMaterial(vec3(0.3, 0.5, 1.0), 1, vec3(1.0, 1.0, 1.0), 0.0, 1, 0.4, 1, 1, 1.0, materials[2]);\n    createMaterial(vec3(0.5, 0.5, 0.5), -1, vec3(0.9, 0.9, 1.0), 0.03, -1, 1.0, -1, -1, 1.0, materials[3]);\n    createMaterial(vec3(1.0, 1.0, 1.0), 2, vec3(1.0, 1.0, 1.0), 0.0, 2, 0.4, 2, 2, 1.0, materials[4]);\n    \n    //init lights\n    float r = 1.0;\n    float xFactor = (iMouse.x==0.0)?0.0:2.0*(iMouse.x/iResolution.x) - 1.0;\n    float yFactor = (iMouse.y==0.0)?0.0:2.0*(iMouse.y/iResolution.y) - 1.0;\n    float x = xFactor*7.0;\n    float z = -3.0-yFactor*5.0;\n    float a = -1.2+sin(time*0.23);\n    mat4 trans = createCS(\tvec3(x, 5.0+sin(time), z),\n                          \tvec3(0.0, sin(a), cos(a)),\n                  \t\t\tvec3(1.0, 0.0, 0.0));\n#ifdef SPHERE_LIGHT\n    createSphere(trans, r, LIGHT_ID_BASE+0, objects[0] );\n#else\n    createPlane(trans, -2.0, -1.0, 2.0, 1.0, LIGHT_ID_BASE+0, objects[0]);\n#endif\n    \n    \n    //plane 1\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 0.0, 5.0, -10.0, 1.0 ));\n    createPlane(trans, -10.0, -2.0, 10.0, 4.0, SURFACE_ID_BASE+1, objects[1]);\n   \n    //plane 2\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, -1.0, 0.0 ),\n                    vec4( 0.0, -1.0, 0.0, 0.0 ),\n                    vec4( 0.0, -1.0, -4.0, 1.0 ));\n    createPlane(trans, -10.0, -4.0, 10.0, 2.0, SURFACE_ID_BASE+1, objects[2]);\n \n    //Cylinder\n    trans = mat4(\tvec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( -0.0, 3.0, -6.0, 1.0 ));\n    createCylinder(trans, 4.0, -10.0, 10.0, PI/2.0, SURFACE_ID_BASE+1, objects[3] );\n    \n    //sphere 1\n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 1.5, -0.3, -2.0, 1.0 ));\n\n    createSphere(trans, 0.7, SURFACE_ID_BASE+2, objects[4] );\n    \n    //sphere 2\n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 0.0, 0.0, -4.5, 1.0 ));\n\n    createSphere(trans, 1.0, SURFACE_ID_BASE+3, objects[5] );\n    \n    //box\n    trans = createCS(\tvec3(-1.5, -1.0, -3.0),\n                     \tvec3(0.0, 1.0, 0.0),\n                     \tvec3(0.2, 0.0, -0.7));\n    createAABB( trans, -vec3(0.5, 0.5, 0.0), vec3(0.5, 0.5, 2.5), SURFACE_ID_BASE+0, objects[6]);\n    \n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 3.5, 0.5, -4.2, 1.0 ));\n\n    createSphere(trans, 1.5, SURFACE_ID_BASE+4, objects[7] );\n    /*\n    //torus\n    trans = createCS(\tvec3(3.0, 1.0, -4.0),\n                        vec3(-0.5, 0.0, 0.5),\n                  \t    vec3(1.0, 0.0, 0.0));\n    createTorus(trans, 1.5, 0.3, SURFACE_ID_BASE+4, objects[7]);*/\n}\n\n///////////////////////////////////////////////////////////////////////\nvoid initCamera( \tin vec3 pos,\n                \tin vec3 target,\n                \tin vec3 upDir,\n                \tin float fovV,\n                \tin float radius,\n                \tin float focus_dist\n               ) {\n\tvec3 back = normalize( pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n    camera.fovV = fovV;\n    camera.pos = pos;\n    camera.focusDist = focus_dist;\n    camera.lensSize = radius;\n}\n\nvoid updateCamera( int strata ) {\n    float strataSize = 1.0/float(PIXEL_SAMPLES);\n    float r1 = strataSize*(float(strata)+rnd());\n    //update camera pos\n    float cameraZ = 4.0;\n    vec3 upDir = vec3( 0.0, 1.0, 0.0 );\n    vec3 pos1, pos2;\n    pos1 = vec3( 0.3, 1.0 + 2.0, cameraZ + 0.8 );\n\n    camera.pos = pos1;\n    \n    vec3 target = vec3( 0.3, 0.4, -5.0 );\n    \n\tvec3 back = normalize( camera.pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n}\n\nRay genRay( in vec2 pixel, in float Xi1, in float Xi2 ) {\n    Ray ray;\n\t//vec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\t//vec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    //ray.origin = camera.pos;\n    //ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n    \n    \n    vec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    \n    if( camera.lensSize > EPSILON ) {\n        vec2 uv = uniformPointWithinCircle( camera.lensSize, rnd(), rnd() );\n        vec3 newPos = camera.pos + camera.rotate[0]*uv.x*camera.lensSize + camera.rotate[1]*uv.y*camera.lensSize;\n        vec3 focusPoint = camera.pos - camera.focusDist*camera.rotate[2];\n        vec3 newBack = normalize(newPos - focusPoint);\n        vec3 newRight = normalize( cross( camera.rotate[1], newBack ) );\n        vec3 newUp = cross( newBack, newRight );\n        mat3 newRotate;\n        newRotate[0] = newRight;\n        newRotate[1] = newUp;\n        newRotate[2] = newBack;\n\n\n        ray.origin = newPos;\n        ray.dir = newRotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n    } else {\n        ray.origin = camera.pos;\n        ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n    }\n\n\treturn ray;\n}\n\n#ifdef SPHERE_LIGHT\nvec3 sampleLightSource( \tin vec3 x,\n                          \tfloat Xi1, float Xi2,\n                          \tout LightSamplingRecord sampleRec ) {\n    float sph_r2 = objects[0].params_[1];\n    vec3 sph_p = toVec3( objects[0].transform_*vec4(vec3(0.0,0.0,0.0), 1.0) );\n    \n    vec3 w = sph_p - x;\t\t\t//direction to light center\n\tfloat dc_2 = dot(w, w);\t\t//squared distance to light center\n    float dc = sqrt(dc_2);\t\t//distance to light center\n    \n    \n    float sin_theta_max_2 = sph_r2 / dc_2;\n\tfloat cos_theta_max = sqrt( 1.0 - clamp( sin_theta_max_2, 0.0, 1.0 ) );\n    float cos_theta = mix( cos_theta_max, 1.0, Xi1 );\n    float sin_theta_2 = 1.0 - cos_theta*cos_theta;\n    float sin_theta = sqrt(sin_theta_2);\n    sampleRec.w = uniformDirectionWithinCone( w, TWO_PI*Xi2, sin_theta, cos_theta );\n    sampleRec.pdf = 1.0/( TWO_PI * (1.0 - cos_theta_max) );\n        \n    //Calculate intersection distance\n\t//http://ompf2.com/viewtopic.php?f=3&t=1914\n    sampleRec.d = dc*cos_theta - sqrt(sph_r2 - dc_2*sin_theta_2);\n    \n    return lights[0].color_*lights[0].intensity_;\n}\n\nfloat sampleLightSourcePdf( in vec3 x,\n                            in vec3 wi,\n                           \tin float d,\n                            in float cosAtLight ) {\n    float sph_r2 = objects[0].params_[1];\n    vec3 sph_p = toVec3( objects[0].transform_*vec4(vec3(0.0,0.0,0.0), 1.0) );\n    float solidangle;\n    vec3 w = sph_p - x;\t\t\t//direction to light center\n\tfloat dc_2 = dot(w, w);\t\t//squared distance to light center\n    float dc = sqrt(dc_2);\t\t//distance to light center\n    \n    if( dc_2 > sph_r2 ) {\n    \tfloat sin_theta_max_2 = clamp( sph_r2 / dc_2, 0.0, 1.0);\n\t\tfloat cos_theta_max = sqrt( 1.0 - sin_theta_max_2 );\n    \tsolidangle = TWO_PI * (1.0 - cos_theta_max);\n    } else { \n    \tsolidangle = FOUR_PI;\n    }\n    \n    return 1.0/solidangle;\n}\n#else\nvec3 sampleLightSource(\t\tin vec3 x,\n                          \tfloat Xi1, float Xi2,\n                       out LightSamplingRecord sampleRec) {\n    float min_x = objects[0].params_[0];\t\t\t//min x\n    float min_y = objects[0].params_[1];\t\t\t//min y\n    float max_x = objects[0].params_[2];\t\t\t//max x\n    float max_y = objects[0].params_[3];\t\t\t//max y\n    float dim_x = max_x - min_x;\n    float dim_y = max_y - min_y;\n    vec3 p_local = vec3(min_x + dim_x*Xi1, min_y + dim_y*Xi2, 0.0);\n    vec3 n_local = vec3(0.0, 0.0, 1.0);\n    vec3 p_global = toVec3( objects[0].transform_*vec4(p_local, 1.0) );\n    vec3 n_global = toVec3( objects[0].transform_*vec4(n_local, 0.0) );\n    \n    float pdfA = 1.0 / (dim_x*dim_y);\n    sampleRec.w = p_global - x;\n    sampleRec.d = length(sampleRec.w);\n    sampleRec.w = normalize(sampleRec.w);\n    float cosAtLight = dot(n_global, -sampleRec.w);\n    vec3 L = cosAtLight>0.0?getRadiance(vec2(Xi1,Xi2)):vec3(0.0);\n    sampleRec.pdf = PdfAtoW(pdfA, sampleRec.d*sampleRec.d, cosAtLight);\n    \n\treturn L;\n}\n\nfloat sampleLightSourcePdf( in vec3 x,\n                               in vec3 wi,\n                             \tfloat d,\n                              \tfloat cosAtLight\n                             ) {\n    float min_x = objects[0].params_[0];\t\t\t//min x\n    float min_y = objects[0].params_[1];\t\t\t//min y\n    float max_x = objects[0].params_[2];\t\t\t//max x\n    float max_y = objects[0].params_[3];\t\t\t//max y\n    float dim_x = max_x - min_x;\n    float dim_y = max_y - min_y;\n    float pdfA = 1.0 / (dim_x*dim_y);\n    return PdfAtoW(pdfA, d*d, cosAtLight);\n}\n#endif\n\nbool isLightVisible( Ray shadowRay ) {\n    float distToHit;\n    SurfaceHitInfo tmpHit;\n    \n    raySceneIntersection( shadowRay, EPSILON, true, tmpHit, distToHit );\n    \n    return ( tmpHit.mtl_id_ >= LIGHT_ID_BASE );\n}\n\nLight pickOneLight(out float lightPickingPdf) {\n    lightPickingPdf = 1.0;\n    return lights[0];\n}\n\nvoid fixMtl(inout Material mtl, vec2 uv, out vec3 ns) {\n    uv *= mtl.tex_scale_;\n    if(mtl.diffuse_color_tex_!=-1){\n        mtl.diffuse_color_ = getColor(uv, mtl.diffuse_color_tex_);\n    }\n    \n    if(mtl.specular_roughness_tex_!=-1){\n        mtl.specular_roughness_ = (1.0 - sqrt(getColor(uv, mtl.specular_roughness_tex_).x))*0.8;\n    } else {\n        mtl.specular_roughness_ = sqrt(mtl.specular_roughness_);\n    }\n    \n    if(mtl.specular_weight_tex_!=-1){\n        mtl.specular_weight_ = (getColor(uv, mtl.specular_weight_tex_).x)*0.6;\n    }\n    if(mtl.normal_map_!=-1){\n        ns = getNormal(uv, mtl.normal_map_ );\n    } else {\n        ns = vec3(0.0, 0.0, 1.0);\n    }\n}\n\nvec3 sampleBSDF(\tin vec3 x,\n                  \tin vec3 ng,\n                  \tin vec3 ns,\n                \tin vec3 wi,\n                  \tin Material mtl,\n                  \tin bool useMIS,\n                  \tin int strataCount,\n                  \tin int strataIndex,\n                \tout vec3 wo,\n                \tout float brdfPdfW,\n                \tout vec3 fr,\n                \tout bool hitRes,\n                \tout SurfaceHitInfo hit,\n               \t\tout float spec) {\n    vec3 Lo = vec3(0.0);\n    for(int i=0; i<DL_SAMPLES; i++){\n        float Xi1 = rnd();\n        float Xi2 = rnd();\n        float strataSize = 1.0 / float(strataCount);\n        Xi2 = strataSize * (float(strataIndex) + Xi2);\n        fr = mtlSample(mtl, ng, ns, wi, Xi1, Xi2, wo, brdfPdfW, spec);\n        \n        //fr = eval(mtl, ng, ns, wi, wo);\n\n        float dotNWo = dot(wo, ns);\n        //Continue if sampled direction is under surface\n        if ((dot(fr,fr)>0.0) && (brdfPdfW > EPSILON)) {\n            Ray shadowRay = Ray(x, wo);\n\n            //abstractLight* pLight = 0;\n            float cosAtLight = 1.0;\n            float distanceToLight = -1.0;\n            vec3 Li = vec3(0.0);\n\n            {\n                float distToHit;\n\n                if(raySceneIntersection( shadowRay, EPSILON, false, hit, distToHit )) {\n                    if(hit.mtl_id_>=LIGHT_ID_BASE) {\n                        distanceToLight = distToHit;\n                        cosAtLight = dot(hit.normal_, -wo);\n                        if(cosAtLight > 0.0) {\n                            Li = getRadiance(hit.uv_);\n                            //Li = lights[0].color_*lights[0].intensity_;\n                        }\n                    } else {\n                        hitRes = true;\n                    }\n                } else {\n                    hitRes = false;\n                    //TODO check for infinite lights\n                }\n            }\n\n            if (distanceToLight>0.0) {\n                if (cosAtLight > 0.0) {\n                    vec3 contribution = (Li * fr * dotNWo) / brdfPdfW;\n\n                    if (useMIS/* && !(mtl->isSingular())*/) {\n                        float lightPickPdf = 1.0;//lightPickingPdf(x, n);\n                        float lightPdfW = sampleLightSourcePdf( x, wi, distanceToLight, cosAtLight );\n                        //float lightPdfW = sphericalLightSamplingPdf( x, wi );//pLight->pdfIlluminate(x, wo, distanceToLight, cosAtLight) * lightPickPdf;\n\n                        contribution *= misWeight(brdfPdfW, lightPdfW);\n                    }\n\n                    Lo += contribution;\n                }\n            }\n        }\n    }\n\n    return Lo*(1.0/float(DL_SAMPLES));\n}\n\nvec3 salmpleLight(\tin vec3 x,\n                  \tin vec3 ng,\n                  \tin vec3 ns,\n                  \tin vec3 wi,\n                  \tin Material mtl,\n                  \tin bool useMIS,\n                  \tin int strataCount,\n                  \tin int strataIndex ) {\n    vec3 Lo = vec3(0.0);\t//outgoing radiance\n\n    for(int i=0; i<DL_SAMPLES; i++) {\n        float lightPickingPdf;\n        Light light = pickOneLight(lightPickingPdf);\n\n        vec3 wo;\n        float lightPdfW, lightDist;\n\n        LightSamplingRecord rec;\n        float Xi1 = rnd();\n        float Xi2 = rnd();\n        float strataSize = 1.0 / float(strataCount);\n        Xi2 = strataSize * (float(strataIndex) + Xi2);\n\n        vec3 Li = sampleLightSource( x, Xi1, Xi2, rec );\n        //vec3 Li = sampleSphericalLight( x, Xi1, Xi2, rec );\n        wo = rec.w;\n        lightPdfW = rec.pdf;\n        lightDist = rec.d;\n        lightPdfW *= lightPickingPdf;\n\n        float dotNWo = dot(wo, ns);\n\n        if ((dotNWo > 0.0) && (lightPdfW > EPSILON)) {\n            vec3 fr = mtlEval(mtl, ng, ns, wi, wo);\n            if(dot(fr,fr)>0.0) {\n                Ray shadowRay = Ray(x, wo);\n                if (isLightVisible( shadowRay )) {\n                    vec3 contribution = (Li * fr * dotNWo) / lightPdfW;\n\n                    if (useMIS /*&& !(light->isSingular())*/) {\n                        float brdfPdfW = mtlPdf(mtl, ng, ns, wi, wo);\n                        contribution *= misWeight(lightPdfW, brdfPdfW);\n                    }\n\n                    Lo += contribution;\n                }\n            }\n        }\n    }\n\n    return Lo*(1.0/float(DL_SAMPLES));\n}\n\nvec3 Radiance( in Ray r, int strataCount, int strataIndex ) {\n    vec3 Lo = vec3(0.0), fr, directLight, pathWeight = vec3(1.0, 1.0, 1.0);\n    vec3 wo;\n    float woPdf;\n    float dotWoN;\n    bool hitResult;\n\n    //Calculate first intersections to determine first scattering event\n    Ray ray = r;\n    SurfaceHitInfo event;\n    SurfaceHitInfo nextEvent;\n    float dist;\n    if(!raySceneIntersection( ray, 0.0, false, event, dist )) {\n        return Lo;\n    } else {\n        //We have to add emmision component on first hit\n        if( event.mtl_id_ >= LIGHT_ID_BASE ) {\n            Light light = getLight(event.mtl_id_ - LIGHT_ID_BASE);\n            float cosAtLight = dot(event.normal_, -ray.dir);\n            if(cosAtLight > 0.0) {\n                Lo = getRadiance(event.uv_);\n                //Lo = light.color_*light.intensity_;\n            }\n        }\n    }\n    \n    float prev_spec;\n\n    for (int i = 0; i < MAX_DEPTH; i++) {\n        if(event.mtl_id_>=LIGHT_ID_BASE){\n        \tbreak;\n    \t}\n        \n        vec3 x = event.position_;\n        vec3 wi = -ray.dir;\n        if(dot(wi, event.normal_) < 0.0) {\n            event.normal_ *= -1.0;\n        }\n        \n        Material mtl = getMaterial(event.mtl_id_);\n    \tvec3 ng = event.normal_, ns;\n    \tfixMtl(mtl, event.uv_, ns);\n    \n        mat3 frame;\n        frame[0] = event.tangent_;\n        frame[1] = cross( ng, event.tangent_ );\n        frame[2] = ng;\n        ns = frame*ns;\n        \n        if (dot(wi,ns) < 0.0) { break; }\n        \n        if(i!=0) {\n            strataCount = 1; strataIndex = 0;\n        }\n        \n        float spec;\n\n        //Calculate direct light with 'Light sampling' and 'BSDF sampling' techniques\n        //In addition BSDF sampling does next event estimation and returns all necessary values which corresponds to next event\n       \tdirectLight  = salmpleLight (x, ng, ns, wi, mtl, true, strataCount, strataIndex);\n        directLight += sampleBSDF   (x, ng, ns, wi, mtl, true, strataCount, strataIndex, wo, woPdf, fr, hitResult, nextEvent, spec);\n       \n#ifdef CLAMP_CAUSTICS\n        if(i!=0) {\n            if(prev_spec < spec) {\n                break;\n            }\n        }\n        prev_spec = spec;\n#endif\n        if(pathWeight.x > 1.0 || pathWeight.y > 1.0 || pathWeight.z > 1.0)\n            break;\n        \n        Lo += directLight*pathWeight;\n\n        if (!hitResult || (dotWoN = dot(event.normal_, wo))<0.0) { break; }\n        if (woPdf == 0.0) { break; }\n        pathWeight *= fr*dotWoN / woPdf;\n\n        //Update values for next iteration\n        ray = Ray(event.position_, wo);\n        event = nextEvent;\n    }\n\n    return Lo;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n    float fov = radians(45.0);\n    initCamera( vec3( 0.0, 0.0, 0.0 ),\n               vec3( 0.0, 0.0, 0.0 ),\n               vec3( 0.0, 1.0, 0.0 ),\n               fov,\n               LENS_SIZE,\n               9.0\n              );\n\n    initScene();\n\n    vec3 accumulatedColor = vec3( 0.0 );\n    float oneOverSPP = 1.0/float(PIXEL_SAMPLES);\n    float strataSize = oneOverSPP;\n    Ray ray;\n\n    for( int si=0; si<PIXEL_SAMPLES; ++si ){\n        updateCamera( si );\n\n        vec2 screenCoord = fragCoord.xy + vec2( strataSize*( float(si) + rnd() ), rnd() );\n        ray = genRay( screenCoord, rnd(), rnd() );\n\n        if( length( ray.dir ) < 0.2 ) {\n            accumulatedColor = vec3( 0.0 );\n        } else {\n            vec3 Li = Radiance( ray, PIXEL_SAMPLES, si );\n            Li = vec3(min(Li.x, CLAMP_VALUE), min(Li.y, CLAMP_VALUE), min(Li.z, CLAMP_VALUE));\n            accumulatedColor += Li;\n        }\n    }\n\n    //devide to sample count\n    accumulatedColor = accumulatedColor*oneOverSPP;\n    accumulatedColor = pow(accumulatedColor, vec3(1.0/2.2));\n    //accumulatedColor = accumulate(fragCoord, accumulatedColor);\n\n    fragColor = vec4( accumulatedColor, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}