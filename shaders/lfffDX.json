{
    "Shader": {
        "info": {
            "date": "1724439768",
            "description": "originals https://www.shadertoy.com/view/MdXSzS",
            "flags": 0,
            "hasliked": 0,
            "id": "lfffDX",
            "likes": 3,
            "name": "crystalized cosmos",
            "published": 3,
            "tags": [
                "cosmos",
                "universe"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 93
        },
        "renderpass": [
            {
                "code": "const float PI = acos(-1.);\n\nmat2 rotate(in float r) { float c=cos(r), s=sin(r); return mat2(c,-s,s,c); }\nvec2 rotate(in vec2 p, in float r) { return p * rotate(r); }\nvec3 rotate(in vec3 p, in vec3 r) { p.xy = rotate(p.xy, r.z); p.yz = rotate(p.yz, r.x); p.zx = rotate(p.zx, r.y); return p; }\nvec3 rotate(in vec3 p, in float r) { return rotate(p, vec3(r)); }\n\nfloat sphere(in vec3 p, in float r) { return length(p)-r; }\nfloat box(in vec3 p, in vec3 b) { vec3 d = abs(p)-b; return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.); }\nfloat box(in vec3 p, in float b) { return box(p, vec3(b));}\n\nfloat map(in vec3 p) {\n    float r = 1.5;\n    vec3 q = p;\n    vec3 c = vec3(4.0);\n    q = mod(q-0.5*c, c) - 0.5*c;\n    \n    float d = sphere(q, .5);\n\tfor(int i=0;i<6;i++) {\n    \tfloat fi = float(i);\n        q = abs(q) - r;\n        q.xyz = q.zxy;\n        q = rotate(q, PI/4.);\n        r *= mix(0.55, 0.6, 0.5+0.5*sin(iTime*0.04));\n    }\n    d = max(-d, box(q,r));\n\treturn d;\n}\n\n#define MARCH_THR 5e-4\nfloat trace(in vec3 ro, in vec3 rd, in vec2 tmm) {\n\tfloat t = tmm.x;\n    for(int i=0;i<100;i++) {\n    \tfloat tmp = map(ro + rd*t);\n        if(tmp<MARCH_THR || tmm.y<t) break;\n        t += tmp;\n    }\n    return t;\n}\n\n\nvec3 normal(in vec3 p) {\n\tvec2 e = vec2(1., -1.)*1e-4;\n    return normalize(\n    \te.xyy*map(p+e.xyy) +\n    \te.yxy*map(p+e.yxy) +\n    \te.yyx*map(p+e.yyx) +\n    \te.xxx*map(p+e.xxx)\n    );\n}\n\n\n#define MATERIAL_COLOR vec3(0.8,0.9,1.0)\n#define MATERIAL_BRIGHTNESS 2.0\n#define BACKGROUND_COLOR vec3(0.)\n#define REFLECTION 0.5+0.3*sin(iTime*0.25*PI)\nvec3 render(in vec3 ro, in vec3 rd, in vec2 tmm) {\n    vec3 res = vec3(0.);\n    \n\tfloat t = trace(ro, rd, tmm);\n    if(tmm.y<t) return BACKGROUND_COLOR;\n    \n\tvec3 pos = ro + rd*t;\n\tvec3 nor = normal(pos);\n    vec3 ref = reflect(rd, nor);\n    \n    vec3 lp = vec3(-1.);\n    //lp = ro;\n    vec3 ld = normalize(lp-pos);\n    \n    vec3 col = MATERIAL_COLOR * MATERIAL_BRIGHTNESS;\n    col *= clamp(dot(nor, ld)-exp(-1.*length(lp-pos)), 0., 1.);\n    col += pow(clamp(dot(ref, ld), 0., 1.), 30.);\n\n    res += col;\n\n    \n    float theta = 0.5*PI - acos(dot(ref, nor));\n    float tmmx = MARCH_THR / sin(theta);\n    \n    t = trace(pos, ref, vec2(tmmx, tmm.y));\n    if(tmm.y<t) {\n    \tcol = BACKGROUND_COLOR;\n    } else {\n        pos = pos + nor*t;\n        nor = normal(pos);\n        ref = reflect(rd, nor);\n\n        col =  MATERIAL_COLOR * MATERIAL_BRIGHTNESS;\n        col *= clamp(dot(nor, ld), 0., 1.);\n        col += pow(clamp(dot(ref, ld), 0., 1.), 50.);\n    }\n\n    res = mix(res, col, REFLECTION);\n    \n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    vec2 p = (fragCoord.xy*2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tfloat t = iTime*.01 + 0.;\n    \n    vec3 ro = 0.025*vec3(cos(t*0.0), 0., sin(t*0.0));\n   \n    vec3 ta = 0.25*vec3(cos(-t*0.001), sin(t*0.0*PI), sin(-t*0.050));\nfloat t2 = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + 0.27)) * 3.2;\n\tfloat si = sin(t2);\n\tfloat co = cos(t2);\n\tmat2 ma = mat2(co, si, -si, co);\n\n  float cr = (t*0.00);\n  ro.zx*=ma;\n    vec3 cz = normalize(ta - ro);\n    vec3 cx = normalize(cross(cz, vec3(sin(1.), cos(1.), 0.)));\n    vec3 cy = normalize(cross(cx, cz));\n    vec3 rd = normalize(mat3(cx, cy, cz) * vec3(p, 2.));\n    \n    vec3 col = render(ro, rd, vec2(0., 10.));\n\tfloat v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\n\t\n\tfloat s = 0.0;\n\tfor (int i = 0; i < 50; i++)\n\t{\n\t\tvec3 p = s * vec3(uv, 0.0)*col;\n\t\n\t\tp += vec3(.22, .3, s - 1.5 - sin(iTime * .0) * .1)*col;\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) - 0.659;\n\t\tv1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .0));\n\t\tv2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .0));\n\t\tv3 += length(p.xy*10.) * .0003;\n\t\ts  += .035;\n\t}\n\t\n\tfloat len = length(uv);\n\tv1 *= smoothstep(.5, .1, len);\n\tv2 *= smoothstep(0.455, 0.2, len);\n\tv3 *= smoothstep(0.7, .1, len);\n\t\n\tvec3 col3 = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n\t\t\t\t\t(v1 + v3) * .3,\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\n  \n\n    // Output to screen\n    fragColor = vec4( col3,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}