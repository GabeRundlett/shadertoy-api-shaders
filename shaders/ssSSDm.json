{
    "Shader": {
        "info": {
            "date": "1620350489",
            "description": "Challenger -Nes",
            "flags": 0,
            "hasliked": 0,
            "id": "ssSSDm",
            "likes": 6,
            "name": "Challenger -Nes",
            "published": 3,
            "tags": [
                "2d",
                "nes",
                "poly",
                "challenger"
            ],
            "usePreview": 0,
            "username": "jorge2017a1",
            "viewed": 215
        },
        "renderpass": [
            {
                "code": "//por jorge2017a1 ----jorgeFloresP---5/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\n\nconst vec3 colPelo=vec3(0.79,0.51,0.37);\nconst vec3 colPiel=vec3(0.98,0.92,0.82);\nconst vec3 colPiel2=vec3(0.88,0.82,0.72);\nconst vec3 colNegro=vec3(0.0);\nconst vec3 colGris=vec3(0.49,0.49,0.49);\nconst vec3 colGris2=vec3(0.6);\nconst vec3 colBlanco=vec3(1.0);\nconst vec3 colRojo=vec3(1.0,0.0,0.0);\nconst vec3 colAzul=vec3(0.0,0.0,1.0);\n\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\nfloat sdPoly8 POLY(8)\nvec2 pt8[ 8]=vec2[](  \nvec2(.27,.43),vec2(.52,.94),vec2(.77,.43),vec2(.58,.43),vec2(.58,.52),\nvec2(.45,.52),vec2(.42,.43),vec2(.27,.43) );\n\nfloat sdPoly4 POLY(4)\nvec2 pt4[ 4]=vec2[](  \nvec2(.52,.94),vec2(.89,.55),vec2(.77,.43),vec2(.52,.94) );\n\n\nfloat sdPoly4b POLY(4)\nvec2 pt4b[ 4]=vec2[](  \nvec2(.42,.42),vec2(.45,.46),vec2(.45,.52),vec2(.42,.42) );\n\nfloat sdPoly5 POLY(5)\nvec2 pt5[ 5]=vec2[](  \nvec2(.45,.52),vec2(.48,.52),vec2(.49,.46),vec2(.45,.46),vec2(.45,.52) );\n\nfloat sdPoly5b POLY(5)\nvec2 pt5b[ 5]=vec2[](  \nvec2(.54,.52),vec2(.58,.52),vec2(.58,.46),vec2(.55,.46),vec2(.54,.52) );\n\nfloat sdPoly5c POLY(5)\nvec2 pt5c[ 5]=vec2[](  \nvec2(.48,.52),vec2(.54,.52),vec2(.55,.46),vec2(.49,.46),vec2(.48,.52) );\n\nfloat sdPoly5d POLY(5)\nvec2 pt5d[ 5]=vec2[](  \nvec2(.48,.52),vec2(.54,.52),vec2(.55,.46),vec2(.49,.46),vec2(.48,.52) );\n//***------------****-----------****------------******-------\n//piramide II\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.10,.39),vec2(.21,.67),vec2(.66,.67),vec2(.77,.39),vec2(.49,.39),\nvec2(.49,.50),vec2(.37,.50),vec2(.35,.39),vec2(.10,.39) );\n\n\nfloat sdPoly5e POLY(5)\nvec2 pt5e[ 5]=vec2[](  \nvec2(.25,.60),vec2(.23,.57),vec2(.28,.57),vec2(.29,.60),vec2(.25,.60) );\n\nfloat sdPoly5f POLY(5)\nvec2 pt5f[ 5]=vec2[](  \nvec2(.58,.60),vec2(.56,.57),vec2(.61,.57),vec2(.63,.60),vec2(.58,.60) );\n\nfloat sdPoly5g POLY(5)\nvec2 pt5g[ 5]=vec2[](  \nvec2(.31,.81),vec2(.77,.81),vec2(.66,.67),vec2(.21,.67),vec2(.31,.81) );\n\n\nfloat sdPoly5h POLY(5)\nvec2 pt5h[ 5]=vec2[](  \nvec2(.32,.80),vec2(.73,.80),vec2(.65,.68),vec2(.24,.68),vec2(.32,.80) );\n\nfloat sdPoly5i POLY(5)\nvec2 pt5i[ 5]=vec2[](  \nvec2(.66,.68),vec2(.77,.40),vec2(.95,.62),vec2(.77,.81),vec2(.66,.68) );\n//***------------****-----------****------------******-------\n// piramide 3\n\nfloat sdPoly5j POLY(5)\nvec2 pt5j[ 5]=vec2[](  \nvec2(.03,.45),vec2(.53,.45),vec2(.41,.73),vec2(.16,.73),vec2(.03,.45) );\n\nfloat sdPoly5k POLY(5)\nvec2 pt5k[ 5]=vec2[](  \nvec2(.21,.81),vec2(.16,.73),vec2(.40,.73),vec2(.47,.81),vec2(.21,.81) );\n\nfloat sdPoly5l POLY(5)\nvec2 pt5l[ 5]=vec2[](  \nvec2(.53,.45),vec2(.66,.59),vec2(.47,.81),vec2(.41,.74),vec2(.53,.45) );\n\nfloat sdPoly5m POLY(5)\nvec2 pt5m[ 5]=vec2[](  \nvec2(.22,.79),vec2(.43,.79),vec2(.40,.76),vec2(.19,.76),vec2(.22,.79) );\n\nfloat sdPoly5n POLY(5)\nvec2 pt5n[ 5]=vec2[](  \nvec2(.20,.66),vec2(.18,.63),vec2(.23,.63),vec2(.25,.66),vec2(.20,.66) );\n\nfloat sdPoly5o POLY(5)\nvec2 pt5o[ 5]=vec2[](  \nvec2(.33,.66),vec2(.31,.63),vec2(.36,.63),vec2(.38,.66),vec2(.33,.66) );\n\nfloat sdPoly5p POLY(5)\nvec2 pt5p[ 5]=vec2[](  \nvec2(.33,.63),vec2(.33,.65),vec2(.37,.65),vec2(.36,.63),vec2(.33,.63) );\n\n//***------------****-----------****------------******-------\n\nvec3 Piramide1(in vec2 pp, vec3 col) \n{\n  vec2 p=pp;\n  \n   \n   float sd1 = sdPoly8(p, pt8);\n   float sd2 = sdPoly4(p, pt4);\n   float sd3 = sdPoly4b(p, pt4b);\n   float sd4 = sdPoly5(p, pt5);\n   float sd5 = sdPoly5b(p, pt5b);\n   float sd6 = sdPoly5c(p, pt5c);\n   col= ponerBorde(colGris,col,sd1); //\n   col= ponerBorde(colNegro,col,sd2); //\n   col= ponerBorde(colNegro,col,sd3); // triangulo ch\n   col= ponerBorde(colGris,col,sd4); // pared ch1\n   col= ponerBorde(colGris,col,sd5); // pared ch2\n   col= mix(col,colNegro ,S( sd6,0.0)); //puerta\n  return col;\n}\n\n\nvec3 piramide2(in vec2 p, vec3 col) \n{\n  float sd1 = sdPoly9(p, pt9);\n  float sd2 = sdPoly5e(p, pt5e);\n  float sd3 = sdPoly5f(p, pt5f);\n  float sd4 = sdPoly5g(p, pt5g);\n  float sd5 = sdPoly5h(p, pt5h);\n  float sd6 = sdPoly5i(p, pt5i);\n  col= ponerBorde(colGris,col,sd1);\n  col= ponerBorde(colAzul,col,sd2); //ventana izq\n  col= ponerBorde(colAzul,col,sd3); //ventana der\n  col= ponerBorde(colGris2,col,sd4);  //techo\n  col= ponerBorde(colGris,col,sd5);  //marco\n  col= ponerBorde(colNegro,col,sd6);  //marco\n  return col;\n}\n\nvec3 piramide3(in vec2 p, vec3 col) \n{\n  float sd1 = sdPoly5j(p, pt5j);\n  float sd2 = sdPoly5k(p, pt5k);\n  float sd3 = sdPoly5l(p, pt5l);\n  float sd4 = sdPoly5m(p, pt5m);\n  float sd5 = sdPoly5n(p, pt5n);\n  float sd6 = sdPoly5o(p, pt5o);\n  float sd7 = sdPoly5p(p, pt5p);\n  \n  col= ponerBorde(colGris,col,sd1); //frente\n  col= ponerBorde(colGris,col,sd2);\n  col= ponerBorde(colNegro,col,sd3); //lateral\n  col= ponerBorde(colGris2,col,sd4); //techo\n  col= ponerBorde(colGris,col,sd5); //ventana izq\n  col= ponerBorde(colGris,col,sd6); //ventana der\n  col= ponerBorde(colAzul,col,sd7); /// ventana vidrio\n  \n  return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = (fragCoord-iResolution.xy)/iResolution.y;\n    //posicion\n    float t=iTime*1.0;\n    vec2 p=uv+vec2(1.5+0.5*sin(t),0.9+0.5*cos(t));\n    vec3 col=colGris;\n     col= Piramide1( p,col);\n     col= piramide2(p-vec2(-1.0,0.0), col);\n     col= piramide2(p-vec2(1.0,0.0), col);\n     col= piramide3(p-vec2(0.5,0.55), col);\n     col= piramide3(p-vec2(0.5,-0.55), col);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}