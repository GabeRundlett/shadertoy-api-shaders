{
    "Shader": {
        "info": {
            "date": "1588368654",
            "description": "Sadly it did not improve my playing. ",
            "flags": 40,
            "hasliked": 0,
            "id": "3slfWM",
            "likes": 20,
            "name": "New Chess Set",
            "published": 3,
            "tags": [
                "chess"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 724
        },
        "renderpass": [
            {
                "code": "//New Chess Set - by eiffie (sadly the new board didn't improve my playing)\n// Global Illumination and the very beginnings of a chess engine in a single frag\n// running nicely on a $150 2in1. This was just a speed test before trying to\n// port a CPU based 4 or 5 turn minmax to glsl.\nvoid mainImage(out vec4 O, in vec2 U){\n  if(U.x<9. && U.y<8.)O=vec4(0.);//hide 'logic'\n  else O=texture(iChannel0,U/iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//adjust ENDFRAME, if it runs too fast make it higher\n#define ENDFRAME 54.\n#define rez iResolution\n#define TAU 6.283\n#define PAWN 1.0\n#define ROOK 5.0\n#define KNIGHT 4.0\n#define BISHOP 3.0\n#define QUEEN 9.0\n#define KING 100.0\n#define ILLEGAL -1000.0\n#define half 0.5\n#define wid 8.0\n#define zero 0.0\n#define one 1.0\n#define two 2.0\n#define get(v) texture(iChannel0,(vec2(floor((v).x),floor((v).y))+vec2(half))/iResolution.xy)\n#define same(x,y) all(equal(floor(x),floor(y)))\n#define fsame(x,y) (floor(x)==floor(y))\n#define isZero(x) (abs(x)<half)\n#define STATEVEC (rez.xy-vec2(one))\n#define SCOREFRAME ENDFRAME-3.\n#define BESTFRAME ENDFRAME-2.\n#define ssgn(x) ((x)-.1>0.?1.:(x)+.1<0.?-1.:0.)\n\n//random seed and generator\nvec2 randv2;\nvec2 rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n randv2+=vec2(1.0,1.0);\n return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 4375.5453),\n  fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 2342.631));\n}\nfloat legal(float t, float p, vec2 p1, vec2 p2){//this only handles computer moves! \n  if(p2.x<zero||p2.x>=wid||p2.y<zero||p2.y>wid)return ILLEGAL;//off board\n  if(same(p1,p2))return ILLEGAL;\n  float cap=get(p2).x;\n  if(cap!=zero){//not empty \n    if(sign(cap)==p)return ILLEGAL;//landed on own piece  \n  }\n  cap=abs(cap);\n  if(t==PAWN){//pawn needs special checks\n    vec2 a=abs(p2-p1);\n    if((fsame(a.x,one) && cap==zero) || (isZero(a.x) && cap!=zero))return ILLEGAL;//only captures diag\n    //if(a.y==2)if(!(p1.y==d.y || p1.y==7+d.y))return -1;//can only jump 2 at start\n  }//no long jumping pawn or castling king so we can bail here\n  if(t==KNIGHT || t==PAWN ||t==KING)return cap;//can not be blocked so the move is good\n  vec2 d=vec2(ssgn(p2.x-p1.x),ssgn(p2.y-p1.y)),w=p1+d;\n  for(int i=0;i<8;i++){\n  \tif(same(w,p2))break;\n    if(get(w).x!=zero)return ILLEGAL;//blocked\n    w+=d;\n  }\n  return cap;//other pieces are good, no checks for castling or en passant\n}\n//CHEBYSHEV rotations for KING and KNIGHT moves\n#define cPi (two*two)\nfloat cCos(float a){return clamp(abs(mod(a,two*cPi)-cPi)-cPi/two,-one,one);}\nfloat cSin(float a){return cCos(a-cPi/two);}\nvec2 rookMove(float j, vec2 p){return j<wid?vec2(j-p.x,zero):vec2(zero,j-wid-p.y);}\nvec2 bishopMove(float j, vec2 p){return j<wid?vec2(j-p.x):vec2(j-wid-p.x,p.x-j+wid);}\n//this would only be used on the last leaf, otherwise score all moves (not best)\nvoid scoreMoves(inout vec4 b, vec2 p1, float p, float lvl){//b.x=piece,b.y=score,b.zw=p2, p1=square, p=player (-1,1)\n  if(lvl==1.){b.y=ILLEGAL;b.z=b.w=zero;}//no move\n  else if(b.y==ILLEGAL)return;//first move couldn't be competed\n  if(!fsame(sign(b.x),p) || b.x==zero)return;//empty or wrong player's piece\n  vec2 fp1=floor(p1);\n  float t=abs(b.x), bw=ILLEGAL,w,qw;//type of piece,best score (weight)\n  for(float m=0.;m<16.;m+=1.){\n    if((t==PAWN && m>two) || ((t==KING || t==KNIGHT) && m>=wid))break;//fewer moves\n    vec2 d=vec2(zero);w=ILLEGAL;//delta of move, default is illegal\n    if(t==PAWN){d.y=-p;if(m==one)d.x=-one;else if(m==two)d.x=one;} \n    else if(t==ROOK || t==QUEEN)d=rookMove(m,fp1);//queen (also bishopMoves below) \n    else if(t==BISHOP)d=bishopMove(m,fp1);\n    else if(t==KNIGHT){\n      float a=m*cPi/4.+cPi/8.;d=vec2(cCos(a)*2.,cSin(a)*2.);\n    }else if(t==KING){\n      float a=m*cPi/4.;d=vec2(cCos(a),cSin(a)); \n    }\n    w=legal(t,p,p1,p1+d);//get score weight/illegal move\n    if(t==QUEEN){//check bishopMoves for queen\n      vec2 d2=bishopMove(m,fp1);qw=legal(t,p,p1,p1+d);\n      if(qw>w){w=qw;d=d2;}//swap rook type movefor bishop type\n    }\n    if(w>bw){bw=w;if(lvl==1.){b.z=p1.x+d.x;b.w=p1.y+d.y;}}\n  }\n  b.y=(lvl==1.?bw:b.y-=bw);\n}\nvec4 setup1(vec2 p){//find starting positions\n  vec4 v=vec4(zero,zero,zero,one);\n  vec2 ap=floor(abs(p-vec2(4.)));\n  p=floor(p);\n  if(ap.y==3.){\n    if(ap.x==3.)v.x=ROOK;\n    else if(ap.x==two)v.x=KNIGHT;\n    else if(ap.x==one)v.x=BISHOP;\n    else if(p.x<4.)v.x=QUEEN;\n    else v.x=KING;\n  }else if(ap.y==two)v.x=PAWN;\n  if(v.x>0.)v.x*=sign(p.y-4.);\n  return v;\n}\nvec4 findBestInBoard(vec2 U,vec2 dir){//2 directional search x then y\n  vec4 b=vec4(zero);vec2 dd;float best=ILLEGAL;\n  if(dir.x>zero)dd=vec2(half,U.y);else dd=vec2(U.x,half);\n  for(int i=0;i<8;i++){\n    vec4 v=get(dd);\n    if(v.y+sin(float(i)+iDate.w)>best){\n      best=v.y;\n      if(dir.x>zero)b=vec4(v.x,v.y,dd.x,dd.y);\n      else b=v;\n    }\n    dd+=dir;\n  }\n  return b;\n}\nvoid doMove(inout vec4 O, vec2 U){\n  vec4 m=get(vec2(wid,zero));//p1 in zw\n  vec4 m2=get(vec2(m.z,m.w));//p2 in zw\n  if(same(U,vec2(m.z,m.w)))O=vec4(zero);//remove from p1\n  else if(same(U,vec2(m2.z,m2.w))){\n    O=get(vec2(m.z,m.w));//replace at p2\n  }\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n  vec4 st=vec4(zero);\n  randv2=fract(cos(vec2(iTime)+vec2(dot(U.xy,vec2(113.0,107.0)),dot(U.yx,vec2(43.1,13.7))))*4231.8413);\n  O=get(U);//texture(iChannel0,U/rez.xy);\n  if(same(U,STATEVEC)){//state vector rez.x,??,frame,player\n    if(!fsame(O.x,rez.x))O=vec4(rez.x,zero,zero,one);\n    else if(O.z<ENDFRAME)O.z+=one;\n    else{O.y+=one;O.z=one;O.w=-O.w;if(O.y>30.)O=vec4(rez.x,zero,zero,one);}\n    return;//done with state\n  }else st=get(STATEVEC);\n  float frame=floor(st.z+0.1),player=st.w;\n  if(U.y<wid){//very dumb chess game\n    if(U.x>wid+one)return;//not needed\n    //vec2 mu=mod(U,vec2(wid));\n    if(frame==0. && U.x<wid)O=setup1(U);//setup/reset\n    else if(frame==SCOREFRAME && U.x<wid){scoreMoves(O,U,player,1.);scoreMoves(O,U,-player,2.);}\n    else if((frame>=BESTFRAME && frame<ENDFRAME) && fsame(U.x,wid)){\n      vec2 v=vec2(1.,0.);O=findBestInBoard(U,(frame==BESTFRAME?v:vec2(v.y,v.x)));\n    }else if(frame==ENDFRAME && U.x<wid)doMove(O,U);\n  }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//the instruments need an update!\n#define bps 7.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n= 0.0; \n  else if(n<2.0)n= 2.0; \n  else if(n<3.0)n= 4.0; \n  else if(n<4.0)n= 5.0; \n  else if(n<5.0)n= 4.0; \n  else if(n<6.0)n= 3.0; \n  else if(n<7.0)n= 2.0; \n  else n=1.0;\n  return vec2(n,r); \n} \nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100;//pentatonic minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//blues  \n //if((n2==1.)||(n2==2.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//country \n //if((n2==1.)||(n2==4.)||(n2==7.)||(n2==10.))note=-100.;//diminished whole/half \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//pentatonic major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//harmonic minor \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//melodic minor ascending \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//whole tone \n //if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole \n if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian   \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//dorian \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==10.))note=-100.;//lydian   \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian Major \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//locrian \n //if((n2==2.)||(n2==4.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//lydian dominant \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//double harmonic \n //if((n2==2.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.))note=-100.;//enigmatic \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//neapolitan  \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//neapolitan minor \n //if((n2==1.)||(n2==4.)||(n2==5.)||(n2==9.)||(n2==10.))note=-100.;//hungarian minor \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n)); \n} \nvec2 mainSound( in int samp,float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(0.5,0.05,1.5,0.1,0.505,0.001);//silly fm synth instruments \n instr sitar=instr(100.0,0.25,4.0,0.0,0.2525,0.0025); \n instr bassdrum=instr(500.0,1.0,4.0,0.75,1.0,0.0125); \n instr stick=instr(100.0,30.0,10.5,0.0,2.3131,1000.0); \n instr pluckbass=instr(10.0,0.2,1.5,0.0,0.25,0.005); \n instr bass=instr(20.0,0.2,1.5,0.0,0.2525,0.005); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=vec2(0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+72.0,time,t0,sitar)*n0.y*0.25;\n   if(mod(i,3.)<1.)a+=I(n0.x+93.0,time+Sin(t0*272.0),t0,stick)*n0.y*0.3;  \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i; \n     a+=I(n1.x+56.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+60.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+51.0,time,t1,pluckbass)*n1.y;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       \n       a+=I(n2.x+44.0,time,t2,bass)*n2.y*4.0; \n       a+=I(n2.x+24.0,time+0.008*sin(t2*15.0),t2,bassdrum)*n2.y*4.0; \n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/24.0,-1.,1.); \n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "//adjust ENDFRAME, if it runs too fast make it higher\n#define ENDFRAME 54.\n#define rez iResolution\n#define TAU 6.283\n#define PAWN 1.0\n#define ROOK 5.0\n#define KNIGHT 4.0\n#define BISHOP 3.0\n#define QUEEN 9.0\n#define KING 100.0\n#define ILLEGAL -1000.0\n#define half 0.5\n#define wid 8.0\n#define zero 0.0\n#define one 1.0\n#define two 2.0\n#define get(v) texture(iChannel0,(vec2(floor((v).x),floor((v).y))+vec2(half))/iResolution.xy)\n#define same(x,y) all(equal(floor(x),floor(y)))\n#define fsame(x,y) (floor(x)==floor(y))\n#define isZero(x) (abs(x)<half)\n#define STATEVEC (rez.xy-vec2(one))\n#define SCOREFRAME ENDFRAME-3.\n#define BESTFRAME ENDFRAME-2.\n#define ssgn(x) ((x)-.1>0.?1.:(x)+.1<0.?-1.:0.)\n\n//random seed and generator\nvec2 randv2;\nvec2 rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n randv2+=vec2(1.0,1.0);\n return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 4375.5453),\n  fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 2342.631));\n}\nfloat legal(float t, float p, vec2 p1, vec2 p2){//this only handles computer moves! \n  if(p2.x<zero||p2.x>=wid||p2.y<zero||p2.y>wid)return ILLEGAL;//off board\n  if(same(p1,p2))return ILLEGAL;\n  float cap=get(p2).x;\n  if(cap!=zero){//not empty \n    if(sign(cap)==p)return ILLEGAL;//landed on own piece  \n  }\n  cap=abs(cap);\n  if(t==PAWN){//pawn needs special checks\n    vec2 a=abs(p2-p1);\n    if((fsame(a.x,one) && cap==zero) || (isZero(a.x) && cap!=zero))return ILLEGAL;//only captures diag\n    //if(a.y==2)if(!(p1.y==d.y || p1.y==7+d.y))return -1;//can only jump 2 at start\n  }//no long jumping pawn or castling king so we can bail here\n  if(t==KNIGHT || t==PAWN ||t==KING)return cap;//can not be blocked so the move is good\n  vec2 d=vec2(ssgn(p2.x-p1.x),ssgn(p2.y-p1.y)),w=p1+d;\n  for(int i=0;i<8;i++){\n  \tif(same(w,p2))break;\n    if(get(w).x!=zero)return ILLEGAL;//blocked\n    w+=d;\n  }\n  return cap;//other pieces are good, no checks for castling or en passant\n}\n//CHEBYSHEV rotations for KING and KNIGHT moves\n#define cPi (two*two)\nfloat cCos(float a){return clamp(abs(mod(a,two*cPi)-cPi)-cPi/two,-one,one);}\nfloat cSin(float a){return cCos(a-cPi/two);}\nvec2 rookMove(float j, vec2 p){return j<wid?vec2(j-p.x,zero):vec2(zero,j-wid-p.y);}\nvec2 bishopMove(float j, vec2 p){return j<wid?vec2(j-p.x):vec2(j-wid-p.x,p.x-j+wid);}\n//this would only be used on the last leaf, otherwise score all moves (not best)\nvoid scoreMoves(inout vec4 b, vec2 p1, float p){//b.x=piece,b.y=score,b.zw=p2, p1=square, p=player (-1,1)\n  b.y=ILLEGAL;b.z=b.w=zero;//no move\n  if(!fsame(sign(b.x),p) || b.x==zero)return;//empty or wrong player's piece\n  vec2 fp1=floor(p1);\n  float t=abs(b.x), bw=ILLEGAL,w,qw;//type of piece,best score (weight)\n  for(float m=0.;m<16.;m+=1.){\n    if((t==PAWN && m>two) || ((t==KING || t==KNIGHT) && m>=wid))break;//fewer moves\n    vec2 d=vec2(zero);w=ILLEGAL;//delta of move, default is illegal\n    if(t==PAWN){d.y=-p;if(m==one)d.x=-one;else if(m==two)d.x=one;} \n    else if(t==ROOK || t==QUEEN)d=rookMove(m,fp1);//queen (also bishopMoves below) \n    else if(t==BISHOP)d=bishopMove(m,fp1);\n    else if(t==KNIGHT){\n      float a=m*cPi/4.+cPi/8.;d=vec2(cCos(a)*2.,cSin(a)*2.);\n    }else if(t==KING){\n      float a=m*cPi/4.;d=vec2(cCos(a),cSin(a)); \n    }\n    w=legal(t,p,p1,p1+d);//get score weight/illegal move\n    if(t==QUEEN){//check bishopMoves for queen\n      vec2 d2=bishopMove(m,fp1);qw=legal(t,p,p1,p1+d);\n      if(qw>w){w=qw;d=d2;}//swap rook type movefor bishop type\n    }\n    if(w>bw){b.z=p1.x+d.x;b.w=p1.y+d.y;bw=w;}\n  }\n  b.y=bw;\n}\nvec4 setup1(vec2 p){//find starting positions\n  vec4 v=vec4(zero,zero,zero,one);\n  vec2 ap=floor(abs(p-vec2(4.)));\n  p=floor(p);\n  if(ap.y==3.){\n    if(ap.x==3.)v.x=ROOK;\n    else if(ap.x==two)v.x=KNIGHT;\n    else if(ap.x==one)v.x=BISHOP;\n    else if(p.x<4.)v.x=QUEEN;\n    else v.x=KING;\n  }else if(ap.y==two)v.x=PAWN;\n  if(v.x>0.)v.x*=sign(p.y-4.);\n  return v;\n}\nvec4 findBestInBoard(vec2 U,vec2 dir){//2 directional search x then y\n  vec4 b=vec4(zero);vec2 dd;float best=ILLEGAL;\n  if(dir.x>zero)dd=vec2(half,U.y);else dd=vec2(U.x,half);\n  for(int i=0;i<8;i++){\n    vec4 v=get(dd);\n    if(v.y+sin(float(i)+iDate.w)>best){\n      best=v.y;\n      if(dir.x>zero)b=vec4(v.x,v.y,dd.x,dd.y);\n      else b=v;\n    }\n    dd+=dir;\n  }\n  return b;\n}\nvoid doMove(inout vec4 O, vec2 U){\n  vec4 m=get(vec2(wid,zero));//p1 in zw\n  vec4 m2=get(vec2(m.z,m.w));//p2 in zw\n  if(same(U,vec2(m.z,m.w)))O=vec4(zero);//remove from p1\n  else if(same(U,vec2(m2.z,m2.w))){\n    O=get(vec2(m.z,m.w));//replace at p2\n  }\n}\n\n//now the graphics, trying to mimick a packet of photons\nconst float fov = 4.0,blurAmount = 0.0005;\nconst int RaySteps=100, maxBounces=8;\nconst vec3 ior=vec3(1.0,2.0,1.0/2.0);//water=1.33,glass=1.52,diamond=2.42\n\nstruct material {vec3 color;float refrRefl,difExp,spec,specExp;};\nfloat board(vec2 v){//read buffer for piece at this position\n  if(max(abs(v.x),abs(v.y))>4.0)return 0.;\n  return get(v+vec2(4.)).r;\n}\nvec4 mcol; \nfloat DE(vec3 p0){ \n  vec3 p=vec3(fract(p0.x)-0.5,p0.y,fract(p0.z)-0.5); \n  float id=board(p0.xz),tp=abs(id); \n  float mx=0.65-max(abs(p.x),abs(p.z)); \n  if(tp==0.)return mx;//don't step too far into the next square \n  float f0=0.46,f1=2.7,f2=0.0,f3=0.25,f4=0.66,f5=-1.,f6=2.;//base config \n  float da=1.0,ds=1.0;//bits to add and subtract to the dif type pieces \n  if(tp==PAWN || tp==ROOK || tp==KNIGHT){p.y+=0.14;f6*=1.5;}//smaller pieces \n  p*=f6; \n  float r=length(p.xz); \n  if(p.y>0.8){f5=1.;f0=0.;//swap base for head config \n    if(tp==PAWN || tp==BISHOP){ \n      f1=3.3;f2=1.1;f3=(tp<4.?.3:.22);f4=1.57; \n      if(tp<BISHOP)da=length(p-vec3(0.,1.56,0.))-0.08; \n      else ds=max(-p.y+1.0,abs(p.z-p.y*0.5+.5)-0.05); \n    }else if(tp==ROOK){\n      f1=2.6;f2=8.;f3=.5;f4=1.3; \n      ds=max(-p.y+1.,min(r-.37,min(abs(p.x),abs(p.z))-0.09)); \n    }else if(tp>ROOK){//queen and king \n      f1=3.3;f2=0.81;f3=.28;f4=1.3; \n      if(tp<KING){ \n        da=length(vec3(abs(p.x)-.19,p.y-1.33,abs(p.z)-.19))-0.1; \n      }else{ \n        da=max(p.y-1.75,min(r-0.02,max(abs(p.x)-.2,length(p.yz-vec2(1.59,0.))-0.02))); \n      } \n    }else{//knight \n      f1=2.,f2=3.4,f3=.31,f4=1.5; \n      float az=abs(p.z)-(p.y-1.)*0.18; \n      da=max(az-.16-p.x*.25,max(abs(p.x+.2-az*.17)-.34,abs(p.y-p.x*.16-1.19-az*.24)-.29-p.x*.16*2.)); \n      ds=min(length(p.xy-vec2(-.53,1.09)),length(p.xy-vec2(0.,1.3)))-.07;\n    } \n  }  \n  float d=r-f0+sin(p.y*f1+f2)*f3; \n  d=max(d,p.y*f5-f4); \n  da=min(da,length(max(vec2(r-0.28,abs(p.y-0.8)),0.))-0.05); \n  d=max(min(d,da),-ds); \n  mcol=vec4(vec3(id<0.?0.2:1.),-sign(id)*0.005); \n  return min(0.83*d/f6,mx);\n}\n\nmaterial getMaterial( in vec3 p, in vec3 nor, in int i ){//return material properties\n  float dif=12.;\n  if(i==0){//board\n    vec2 v=(floor(mod(p.xz,vec2(2.0)))-vec2(0.5))*2.;\n    float d=v.x*v.y;if(d<0.){dif=5.;d=0.05;}\n    mcol=vec4(d,d,d,max(0.5,d));\n  }else if(mcol.g<0.5)dif=7.;\n  //diffExp=inverse spread, specExp=at what spread does reflected light not lose energy\n  return material(mcol.rgb,mcol.w,pow(2.,dif),1.0,pow(2.,13.0));\n}\n\nvec3 getBackground( in vec3 rd ){//the background has a seam?? not from here though\n  rd.z=abs(rd.z);\n  float d=0.5+0.5*dot(rd,vec3(0.57735));\n  return rd*0.1+max(d*rd.y,0.)*vec3(1.5,1.6,1.75)+vec3(2.,1.,.2)*pow(d,100.)*4.*rd;\n}\n\nvec3 powDir(vec3 nor, vec3  dir, float power) \n{//creates a spread of photons bouncing off the surface without penetrating the surface\n float ddn=max(0.01,abs(dot(dir,nor)));\n vec2 r=rand2()*vec2(TAU,1.0);\n vec3 nr=(ddn<0.99)?nor:((abs(nor.x)<0.5)?vec3(1.0,0.0,0.0):vec3(0.0,1.0,0.0));\n vec3 sdir=normalize(cross(dir,nr));\n r.y=pow(r.y,1.0/power);\n vec3 ro=normalize(sqrt(1.0-r.y*r.y)*(cos(r.x)*sdir+sin(r.x)*cross(dir,sdir)*ddn)+r.y*dir);\n return (dot(ro,nor)<0.0)?reflect(ro,nor):ro;\n}\nvec3 scene(vec3 ro, vec3 rd) {// find color of pixel by following light backwards in time\n vec3 fcol=vec3(1.0);//light energy per frequency, light will bounce around and then be energized by the background\n float HitDistance=1.0/rez.x;\n vec2 rnd=rand2(),e=vec2(HitDistance,-HitDistance);//a couple random numbers,epsilon for normals\n float d,t=DE(ro)*rnd.x,side=sign(DE(ro+t*rd));//dist to obj, total ray len, len to first obj, -inside or +outside of obj\n float mxt=(-0.33-ro.y)/rd.y;if(mxt<0.)mxt=1000.;//distance to ground\n float mxmt=min(mxt,20.0);//max distance to march\n material m;vec3 nor;\n int iHitCount=0;\n for(int i=0; i<RaySteps; i++ ){//march loop\n   t+=d=DE(ro+t*rd)*side;//march\n   if(t>mxmt && rd.y>0.)break;//nothing left to intersect so bail\n   if(abs(d)<HitDistance*t || t>mxmt){//hit something\n     if(t>mxmt){d=0.;nor=vec3(0.,1.,0.);ro+=rd*mxt;if(max(abs(ro.x),abs(ro.z))>4.){fcol=vec3(0.1,0.15,0.12);break;}}\n     else{\n       ro+=rd*t;// advance ray position to hit point\n       vec4 v=vec4(DE(ro+e.xxx),DE(ro+e.xyy),DE(ro+e.yxy),DE(ro+e.yyx));//from dr2 \n       nor=side*normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w));\n       if(nor!=nor)nor=-rd;//is this !isNum(nor) which usually happens when nor is approx -rd\n     }\n     m=getMaterial(ro,nor,t>mxt?0:1);\n     rnd=rand2();//a couple more random numbers\n     vec3 refl=reflect(rd,nor),newRay=refl;//setting up for a new ray direction and defaulting to a reflection\n     if(m.refrRefl<0.0){//if the material refracts use the fresnel eq. to determine refr vs refl\n       vec3 refr=refract(rd,nor,(side>=0.0)?ior.z:ior.y);//calc the probabilty of reflecting instead\n       vec2 ca=vec2(dot(nor,rd),dot(nor,refr)),n=(side>=0.0)?ior.xy:ior.yx,nn=vec2(n.x,-n.y);\n       if(rnd.y+rnd.x>pow(dot(nn,ca)/dot(n,ca),2.0)+pow(dot(nn,ca.yx)/dot(n,ca.yx),2.0)){newRay=refr;nor=-nor;}\n     }\n     rd=powDir(nor,newRay,m.difExp);//redirect the ray\n     //the next line calcs the amount of energy left in the ray based on how it bounced (diffuse vs specular)\n     //in other words how many photons did we lose by bouncing diffusely vs. in a perfect reflection (specular diretion)\n     fcol*=mix(m.color,vec3(1.0),min(pow(max(0.0,dot(rd,refl)),m.specExp)*m.spec+abs(m.refrRefl),1.0));\n     if(iHitCount++>maxBounces || dot(fcol,fcol)<0.01 || dot(ro,ro)>400.)break;//lots of reasons to bail\n     t=max(d*side*5.0,HitDistance);//hopefully pushs thru the surface\n     mxt=(-0.33-ro.y)/rd.y;if(mxt<0.001){mxt=1000.;if(rd.y<0.)rd.y=-rd.y;}//new ground distance\n     mxmt=min(mxt,20.0);//..and march distance\n     side=sign(DE(ro+t*rd));//keep track of which side you are on for glass objects\n   }\n }\n return clamp(fcol*getBackground(rd),0.0,1.0);//light the scene\n} \nmat3 lookat(vec3 fw){\n  fw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw); \n}\nvoid Setup(float t, out vec3 eye, out vec3 tgt){//camera setup, boring\n  eye=vec3(.22+sin(t),2.84+cos(t*2.)*2.,-6.22)*(0.9+0.25*cos(t*1.3));tgt=vec3(.0,-1.2,0.);\n  if(mod(t,2.)>0.)eye.z=-eye.z;\n}\nvoid mainImage(out vec4 O, in vec2 U) {\n  O=texture(iChannel1,U/iResolution.xy);\n  vec4 st=vec4(zero);\n  randv2=fract(cos(vec2(iTime)+vec2(dot(U.xy,vec2(113.0,107.0)),dot(U.yx,vec2(43.1,13.7))))*4231.8413);\n  st=get(STATEVEC);\n  float frame=floor(st.z+0.1),player=st.w;\n  if(frame==0.){O=vec4(0.25);return;}\n  vec3 eye,tgt;\n  Setup(st.y,eye,tgt);tgt-=eye;\n  float focusDistance=length(tgt)*0.5;\n  mat3 looky=lookat(tgt);\n  vec2 pxl=(-rez.xy+2.0*(U.xy+rand2()))/rez.y;\n  vec3 er = normalize( vec3( pxl.xy, fov ) );\n  vec3 go = blurAmount*focusDistance*vec3( -1.0 + 2.0*rand2(), 0.0 );\n  vec3 gd = normalize( er*focusDistance - go );gd.z=0.0;\n  if(frame<5.)O=mix(vec4(.25),O,frame/5.);\n  O=O*(1.-1./frame)+vec4(scene(eye+looky*go,looky*normalize(er+gd)),1.0)/frame;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}