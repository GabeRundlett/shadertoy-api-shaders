{
    "Shader": {
        "info": {
            "date": "1525537852",
            "description": "a skybox version of https://www.shadertoy.com/view/MllXz4",
            "flags": 0,
            "hasliked": 0,
            "id": "MsdBD7",
            "likes": 1,
            "name": "Warmified Skybox",
            "published": 3,
            "tags": [
                "skybox"
            ],
            "usePreview": 0,
            "username": "jherico",
            "viewed": 96
        },
        "renderpass": [
            {
                "code": "// skybox version of https://www.shadertoy.com/view/MllXz4\n//noise function taken from https://www.shadertoy.com/view/XslGRr\n\nfloat hash( float n ){\n\treturn fract(sin(n)*43758.5453);\n}\n\n//this noise function was originally 3D noise, \n//but I am just setting z to 0 for the sake of simplicity here\n//also cause most effects only care about 2D noise\nfloat noise( vec2 uv ){\n\tvec3 x = vec3(uv, 0);\n\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf       = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\t\n\treturn mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),\n\t\t\t\t   mix( hash(n+57.0), hash(n+58.0),f.x),f.y),\n\t\t\t   mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nfloat ring( float angle, float dist, float ANG, float THICKNESS, float POS, float SIZE ) {\n    //angles between 4 and 15 are good\n    //negative thickness makes it black, values around 0.02 are good\n    \n    float ZIGZAG = abs( mod( angle, ANG ) - ANG * 0.5 ) * SIZE;\n    return ceil( dist - POS + ZIGZAG) - ceil( dist - (POS+THICKNESS) + ZIGZAG);   \n}\nfloat burst( float angle, float dist, float ANG ) {\n    float B = abs( mod( angle, ANG ) - ANG * 0.5 );\n    return B;\n}\nfloat lim( float IN, float amount ) {\n\treturn IN * amount + (1.0 - amount);   \n}\nfloat inv( float IN ) {\n \treturn 1.0 - IN;   \n}\nfloat ppp( float IN ) {\n \treturn IN * IN * IN;   \n}\nfloat dots( float angle, float dist, float ANG, float POS ) {\n    return ppp(7.5*burst( angle, dist, ANG )/ANG) * ppp(inv(ANG*1.5*distance( dist, POS )));\n}\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvec4 myoutput( vec2 spherical )\n{\n   \n   \tfloat dist = spherical.y;\n    float angle = spherical.x;\n    \n    float TIMESCALE = 0.3;\n    float T = iTime * TIMESCALE * 2.0;\n    \n    \n    float n = noise( vec2( dist, T ) );\n    float slow_n = noise( vec2( dist, T * 0.2) );\n    float fast_n = noise( vec2( dist, T * 2.0) );\n    float vslow_n = noise( vec2( dist, T * 0.01) );\n    float vfast_n = noise( vec2( dist, T * 50.0) );\n    float t = noise( vec2( iTime, T ) );\n    \n    float rand_r = noise( vec2( -T, T ) );\n    float slow_r = noise( vec2( -T * 0.5, 1.0 ) );\n    float vslow_r = noise( vec2( -T * 0.2, 1.0 ) );\n    float vvslow_r = noise( vec2( -T* 0.05, 1.0 ) );\n    \n    float div = 7.0;\n    float m = sin ( mod( angle, div )/(div*0.5) * 3.14 * 0.5 );\n    float a = mod( angle, 10.0 ) * noise( vec2( T, angle ) );\n        \n    float TIME_MOD_SCALE = 1.0;\n    float TIME_MOD = floor(0.5+sin( noise( vec2(-iTime + 1000.0, 1.0 )) ))*0.5*TIMESCALE*TIME_MOD_SCALE;\n\n    TIMESCALE = TIMESCALE * TIME_MOD;\n    \n    float GRANULARITY = 1.75;\n    float GRAN_DIST_FALLOFF = 0.5;\n    float GRAN_DIST_FALLOFF_MOD = tan(noise (vec2( 500.0, -T ) ));\n    GRAN_DIST_FALLOFF = GRAN_DIST_FALLOFF + GRAN_DIST_FALLOFF_MOD * 0.5;\n    \n    float Gr = (GRANULARITY-(dist * GRANULARITY * GRAN_DIST_FALLOFF)) * 50.0;\n    float Gg = (GRANULARITY-(dist * GRANULARITY * GRAN_DIST_FALLOFF)) * 80.0;\n    float Gb = (GRANULARITY-(dist * GRANULARITY * GRAN_DIST_FALLOFF)) * 100.0;\n    \n    float Gsign = clamp( sign( noise (vec2( T * 0.22, -T * 1.5 )) -0.5 ), -1.0, 0.0 );\n    \n    float rn = 360.0 / (ceil( noise(vec2( sin(T*0.1), 0.5 ) ) * 50.0) * 2.0 );\t//randomly some divisor of 360\n    float rd1 = ceil( noise(vec2( tan(T/10.0), 1.0 ) ) * 2.0 );\t//randomly either 1 or 2\n    float rd2 = ceil( noise(vec2( sin(T/10.0), 1.0 ) ) * 2.0 );\t//randomly either 1 or 2\n    float rd3 = ceil( noise(vec2( cos(T/10.0), 1.0 ) ) * 2.0 );\t//randomly either 1 or 2\n    float rd4 = ceil( noise(vec2( tan(T*0.0075+99.0), 1.0 ) ) * 1.2 );\t//randomly either 1 or 2\n    float rd5 = ceil( noise(vec2( tan(T*0.008+124.0), 1.0 ) ) * 1.5 );\t//randomly either 1 or 2\n    float rd6 = ceil( noise(vec2( tan(T*0.007+24.0), 1.0 ) ) * 1.7 );\t//randomly either 1 or 2\n    float rd7 = ceil( noise(vec2( tan(T*0.005), 1.0 ) ) * 1.4 );\t//randomly either 1 or 2\n    float exp4 = ceil( noise(vec2( tan(T*0.5), 1.0 ) ) * 2.0 ) * rd1;\n    float coarse3 = ceil( noise(vec2( cos(T), 1.0 ) ) * 3.0 );\n    float coarse10 = ceil( noise(vec2( cos(T), 1.0 ) ) * 10.0 );\n    \n    vec3 RING1 = rd2 * 0.5 * ring( angle, dist,6.0, 0.02, n, 0.01) * vec3( 1.0, 1.0, 1.0 ) * floor( n + 0.5 );\n    vec3 RING2 = ring( angle, dist,10.0, 0.01, n/2.0, 0.01) * vec3( 1.0, 1.0, 1.0 ) * ceil( n - 0.3 );\n    vec3 RING3 = ring( angle+(vslow_n*200.0*coarse3)*(2.0+n), dist,90.0*rd1/rd4, (0.02 + rand_r*0.01 + ppp(slow_r)*0.011)*ppp(rd4), n, 0.01) * vec3( 1.0, 1.0, 1.0 ) * 0.5;\n    vec3 RING4 = ring( angle-iTime*(5.0*n), dist,10.0, 0.05, n, 0.01) * vec3( sin(T), cos(T), 0.1 ) * 0.5;\n    vec3 RING5 = ring( angle, dist,30.0, n*20.0, n+0.3, 0.01) * vec3( 1.0, 1.0, 1.0 ) * 0.05 + (dist)*0.05;\n    vec3 BURST1 = burst( angle, dist, rn * rd1 ) * vec3( 1.0, 1.0, 1.0 ) * 0.03 * (1.0 - dist);\n    vec3 RING6 = max(ring( angle-(vslow_n*200.0*coarse3)*(2.0+vslow_n), dist,45.0*rd1, 0.3, n, 0.01),0.0) * vec3( sin(T), tan(T) * 0.5, rand_r ) * (rd7 - 1.0) * inv(dist) * 0.5;\n    vec3 DOTS1 = max(ceil(dots( angle + T*30.0, dist, 10.0, 0.25 + rand_r*0.1 )-24.5 * (1.0+rand_r)),0.0) * vec3( rand_r, inv(rand_r), n ) * 0.15;\n    vec3 DOTS2 = max(ceil(dots( angle - T*35.0, dist, 10.0, 0.3 + rand_r*0.2 )-16.4 * (2.0-rand_r)),0.0) * vec3( n, rand_r, inv(rand_r) ) * 0.15;\n    vec3 DOTS3 = clamp( 1.0 * dots( angle + T * 45.0, dist, 15.0, 0.9 ), 0.0, 1.0) * vec3( 1.0, 1.0, 1.0 ) * 0.05;\n    vec3 DOTS4 = clamp( 1.0 * dots( angle - T * 45.0, dist, 15.0, 0.82 ), 0.0, 1.0) * vec3( 1.0, 1.0, 1.0 ) * 0.025;\n    vec3 RING = RING1 + RING2 + RING3 + RING4 + RING5 + BURST1 + DOTS1 + DOTS2 + RING6 + DOTS3 + DOTS4;\n    \n    float r = RING.r + max((1.0 - dist * 2.0),-0.5) + noise( vec2( dist * Gr * sin( noise(vec2( iTime * 8.0 * TIMESCALE, -iTime )) ), dist ) );;//floor(n*2.0) * a;\n    float g = RING.g + max((1.0 - dist * 3.5),-1.5) + noise( vec2( dist * Gg * TIMESCALE * cos( noise(vec2( iTime * 12.0 * TIMESCALE, -iTime )) ), dist ) );;//ceil(n/3.0 - 0.1) - a;\n    float b = RING.b + max((1.0 - dist * 2.5),-1.0) + noise( vec2( dist * Gb * tan( noise(vec2( iTime * 1.0 * TIMESCALE, -iTime )) ), dist ) );;//ceil(n/3.0 - 0.2) - a;\n    \n    vec3 boost = vec3( 1.3, 1.3 - slow_r * 0.3, 0.4 + slow_n * 0.3);    \n       \n\treturn vec4(r*boost.r,g*boost.g,b*boost.b,1.0) * mix(dist,1.0,0.7);\n    \n    float over = DOTS3.x + DOTS4.x;\n}\n\nvec3 getOutput(vec3 d) {\n    vec2 spherical;\n    spherical.x = degrees(atan(d.x, d.z));\n    spherical.y = (acos(d.y) + 1.0) / 4.0;\n    return myoutput(spherical).rgb;\n}\n\n\nmat3 rot(vec3 a, float b) {\n    a = normalize(a);\n    float s = sin(b);\n    float c = cos(b);\n    float d = 1.0 - c;\n    return mat3(d * a.x * a.x + c, d * a.x * a.y - a.z * s, d * a.z * a.x + a.y * s, d * a.x * a.y + a.z * s, d * a.y * a.y + c,\n                d * a.y * a.z - a.x * s, d * a.z * a.x - a.y * s, d * a.y * a.z + a.x * s, d * a.z * a.z + c);\n}\n\nfloat e = 2.3, p = atan(1.) * 4.;\n\nvec3 getPixelDirection(in vec2 fragCoord) {\n    vec2 R = iResolution.xy, u = fragCoord / R;\n    vec4 m = iMouse / R.xyxx;\n    mat3 rmx = rot(vec3(0, 1, 0), clamp(-m.w * R.x, 0., 1.) * 3.14 / 10. + m.x * p * 2.);\n    rmx *= rot(cross(vec3(0, 1, 0), vec3(0, 0, 1) * rmx), m.y * p - p / 2.);\n    vec3 d = normalize(vec3((u * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1), 1)) * rmx;\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 d = getPixelDirection(fragCoord);\n    fragColor = vec4(getOutput(d), 1.0);\t\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}