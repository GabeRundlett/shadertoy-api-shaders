{
    "Shader": {
        "info": {
            "date": "1698288135",
            "description": "An experiment in tonemapping",
            "flags": 0,
            "hasliked": 0,
            "id": "DdKBDw",
            "likes": 2,
            "name": "Tonemapping comparisons",
            "published": 3,
            "tags": [
                "color",
                "tonemapping",
                "tonemapper",
                "tonemap",
                "aces",
                "tmo"
            ],
            "usePreview": 0,
            "username": "fishy",
            "viewed": 195
        },
        "renderpass": [
            {
                "code": "/*\n    Comparison of global tonemapping operators.\n    \n    Mouse to select an operator to show larger on top. Click on the red circle to\n    return.\n    \n    Options:\n        HUE_MODE:\n            When 0, instead of mapping the sine wave from -1 to 1 to 0 to 1,\n            it clips at 0 creating a sort of \"worst case\" for the Reinhard\n            operator which operatres purely per-component, making fully saturated values of\n            red, green, or blue look bad.\n            When 1, it maps the -1 to 1 range to 0 to 1 \"properly\"\n        \n        SHOW_MORE:\n            Show more operators\n        \n        IMAGE:\n            Instead of a rainbow, show a psychedelic oil-slick-like moving image\n    \n    From left to right:\n        when SHOW_MORE = 0:\n        Clipped values:\n            The simplest tonemapping operator which is no tonemapping operator, it just\n            clips values above 1 to 1 per-component.\n        Reinhard\n            Another simple tonemapping operator, this time performing the operation\n            x / (1.0 + x) per component.\n        ACES\n            From https://www.shadertoy.com/view/XsGfWV. Looks great!\n        My tonemapping operator\n            ACES-like.\n            Each component going out is a combination of the three, allowing proper desaturation\n            when used in combination with a Reinhard operator.\n            I think the blue and green components also desaturate in a nicer looking manner,\n            as the blue doesn't turn purple. Might also be cheaper as it only involves a single\n            matrix multiplication rather than the two the ACES tonemapper uses to transform from\n            RGB to XYZ and back. Also includes a contrast adjustment at the end to make it look\n            more like the ACES operator.\n            Plus, if you want to adjust the look, you can do so by changing the values in the\n            matrix.\n\n        when SHOW_MORE = 1:\n            Clipped values\n            Reinhard\n            Reinhard extended(?)\n                Instead of dividing by the components divide by the luminance\n            ACES\n            My tonemapping operator\n            Reinhard ACES\n                Like Reinhard but it mixes toward the luminance to achieve a similar look to ACES.\n                Also made by me.\n                Doesn't look super great IMO, might even be more expensive than the other one I\n                made.\n    \n    Also I didn't mean for this to become so large oops ðŸ˜ž\n*/\n\n#define HUE_MODE 0\n#define SHOW_MORE 0\n//#define IMAGE\n\n#define lum(x) dot(x, vec3(0.2126, 0.7152, 0.0722))\n\nvec3 gamma(vec3 c)\n{\n    return pow(c, vec3(0.4545));\n}\n\nvec3 clip(vec3 c)\n{\n    return clamp(c, 0.0, 1.0);\n}\n\nvec3 reinhard(vec3 c)\n{\n    return c / (1.0 + c);\n}\n\nvec3 reinhardExtended(vec3 c)\n{\n    return c / (1.0 + lum(c));\n}\n\nvec3 aces(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn clamp(m2 * (a / b), 0.0, 1.0);\t\n}\n\nvec3 reinhardAces(vec3 c)\n{\n    c = pow(c, vec3(1.5));\n    vec3 g = vec3(lum(c));\n    c = mix(g / (g + 1.0), c / (c + 1.0), exp2(-g*0.2));\n    return c;\n}\n\nvec3 reinhardSpill(vec3 c)\n{\n    c *= mat3(vec3(1.000, 0.100, 0.025),\n              vec3(0.075, 1.000, 0.050),\n              vec3(0.030, 0.050, 1.000));\n    c = 1.0 - exp(-c * 1.0);\n    return 3.0*c*c-2.0*c*c*c;\n}\n\nvec3 hue(float x)\n{\n#if HUE_MODE == 0\n    return max(vec3(0), sin((x+0.125+vec3(0.0, 0.33, 0.66)) * 6.2832));\n#else\n    return pow(sin((x+0.125+vec3(0.0, 0.33, 0.66)) * 6.2832)*0.5+0.5, vec3(3));\n#endif\n}\n\n#define TMO(a, f) case a: c = f (c); break;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n#if SHOW_MORE == 0\n#define TMO_COUNT 3.0\n#else\n#define TMO_COUNT 5.0\n#endif\n    \n#ifdef IMAGE\n    vec3 c = hue(noise(uv, iTime)*5.0) / pow(abs(uv.y-0.5)*5.0, 2.0);\n#else\n    vec3 c = hue(uv.x*TMO_COUNT+iTime*0.2);\n#endif\n    float v = abs(uv.y*2.0-1.0);\n    c /= v/(1.0-v);\n    int tmo = int(fract(uv.x)*(TMO_COUNT+1.0));\n    if(length(iMouse.xy) > 20.0 && uv.y > 0.5)\n    {\n        tmo = int(fract(m.x)*(TMO_COUNT+1.0));\n    }\n    \n    switch(tmo)\n    {\n        TMO(0, clip);\n#if SHOW_MORE == 1\n        TMO(1, reinhard)\n        TMO(2, reinhardExtended)\n        TMO(3, aces)\n        TMO(4, reinhardSpill)\n        TMO(5, reinhardAces)\n#else\n        TMO(1, reinhard)\n        TMO(2, aces)\n        TMO(3, reinhardSpill)\n#endif\n    }\n    \n    c = mix(c, vec3(1, 0, 0), smoothstep(20.0, 18.0, length(fragCoord.xy)));\n    fragColor = vec4(gamma(c),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Noise taken from https://www.shadertoy.com/view/Nl3BRM (mine)\n\nfloat erp(float x, float k)\n{\n    return x < 0.5 ? pow(2.0*x, k)*0.5  : 1. - pow(2.0*(1.0-x), k) / 2.;\n}\n\nvec2 hash(vec2 p)\n{\n    vec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat perlinNoise(vec2 p, float s)\n{\n    vec2 tlVal = hash(vec2(floor(p.x),  ceil(p.y)));\n    vec2 blVal = hash(vec2(floor(p.x), floor(p.y)));\n    vec2 trVal = hash(vec2( ceil(p.x),  ceil(p.y)));\n    vec2 brVal = hash(vec2( ceil(p.x), floor(p.y)));\n    \n    vec2 tlOffset = p - vec2(floor(p.x),  ceil(p.y));\n    vec2 blOffset = p - vec2(floor(p.x), floor(p.y));\n    vec2 trOffset = p - vec2( ceil(p.x),  ceil(p.y));\n    vec2 brOffset = p - vec2( ceil(p.x), floor(p.y));\n    \n    float tl = dot(tlOffset, tlVal);\n    float bl = dot(blOffset, blVal);\n    float tr = dot(trOffset, trVal);\n    float br = dot(brOffset, brVal);\n    \n    float a = mix(bl, tl, erp(fract(p.y), s));\n    float b = mix(br, tr, erp(fract(p.y), s));\n    \n    return mix(a, b, erp(fract(p.x), s)) / 2.0 + 0.5;\n}\n\n\n\nfloat fbm(in vec2 x, float s, in float H)\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        t += a*perlinNoise(f*x, s);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nfloat noise(vec2 uv, float t)\n{\n    uv *= 0.1;\n\n    uv.x += fbm((uv + t*0.01) * 1.0,           1.0, 1.0);\n    uv.y += fbm((uv + t*0.01) * 1.0 + 100.0, 1.0, 1.0);\n    uv.x += fbm((uv + t*0.01) * 1.0,           1.0, 1.0);\n    uv.y += fbm((uv + t*0.01) * 1.0 + 100.0, 1.0, 1.0);\n    uv.x += fbm((uv + t*0.01) * 1.0,           1.0, 1.0);\n    uv.y += fbm((uv + t*0.01) * 1.0 + 10.0,  1.0, 1.0);\n    uv.x += fbm((uv + t*0.01) * 1.0,           1.0, 1.0);\n    uv.y += fbm((uv + t*0.01) * 1.0 + 100.0,  1.0, 1.0)*5.0;\n\n    float value = fbm(uv * 20.0, 1.0, 1.0);\n\n    return value;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}