{
    "Shader": {
        "info": {
            "date": "1496809328",
            "description": "Play with Bezier curve",
            "flags": 0,
            "hasliked": 0,
            "id": "MdlfzS",
            "likes": 20,
            "name": "28/100",
            "published": 3,
            "tags": [
                "bezier"
            ],
            "usePreview": 0,
            "username": "yahe",
            "viewed": 798
        },
        "renderpass": [
            {
                "code": "const float Pi = 3.1415926535;\n\nfloat Point(vec2 uv, vec2 P)\n{\n    return smoothstep(0.035, 0.005, distance(uv, P));   \n}\n\nfloat cbrt(float x)\n{\n    return sign(x) * pow(abs(x), 1.0/3.0);\n}\n\n// http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Solve cubic ax^3 + bx^2 + cx + d = 0 \n// Returns amount of roots\nint SolveCubic(vec4 coeffs, out vec3 roots)\n{\n    int nS = 0;  \n    // normal form: x^3 + Ax^2 + Bx + C = 0 \n    vec4 N = coeffs / coeffs[0];\n\n    // substitute x = y - A/3 \n    // depressed cubic: x^3 + px + q = 0 \n    float sqA = N[1]*N[1];\n    float p = (N[2] - sqA/3.0) / 3.0;\n    float q = ( (N[1] * sqA)/13.5 - (N[1] * N[2])/3.0 + N[3]) * 0.5;\n\n    // Use Cardano's formula \n    float cbP = p * p * p;\n    float D = q * q + cbP;\n\n    if (abs(D) < 1e-20)\n    {\n\t\tif (q == 0.0)  \n            nS = 1;\n\t\t   \n\t\telse // one single and one double solution\n\t\t{\n\t\t    float u = cbrt(-q);\n\t\t    roots[0] = 2.0 * u;\n\t\t    roots[1] = -u;\n\t\t    nS = 2;\n\t\t}\n    }\n    \n    else if (D < 0.0) // Casus irreducibilis: three real solutions\n    {\n\t\tfloat phi = acos(-q / sqrt(-cbP)) / 3.0;\n\t\tfloat t = 2.0 * sqrt(-p);\t\n\t\troots[0] = t * cos(phi);\n\t\troots[1] = -t * cos(phi + Pi/3.0);\n\t\troots[2] = -t * cos(phi - Pi/3.0);\n\t\tnS = 3;\n    }\n    \n    else // one real solution \n    {\n\t\tfloat sqrtD = sqrt(D);\n\t\troots[0] = cbrt(sqrtD - q) - cbrt(sqrtD + q);\n\t\tnS = 1;\n    }\n\n    roots -= N[1] / 3.0;\n    \n    return nS;\n}\n\nvec2 QuadraticBezier(float t, vec2 p0, vec2 p1, vec2 p2)\n{\n\treturn mix((mix(p0, p1, t)),(mix(p1, p2, t)), t);\n}\n\n// x is a point\n// {a, b, c} are the control points\nfloat DistanceQuadraticBezier(vec2 x, vec2 a, vec2 b, vec2 c)\n{\n    float aa = dot(a,a);\tfloat bc = dot(b,c);\tfloat cc = dot(c,c);\n    float ab = dot(a,b);\tfloat bb = dot(b,b);   \tfloat cx = dot(c,x);\n    float ac = dot(a,c);\tfloat bx = dot(b,x);\n    float ax = dot(a,x);\n           \n    // Cubic coefficients\n    float cu = 4.0*(aa + cc) + 16.0*(bb - ab - bc) + 8.0*ac;\n    // Quadratic coefficients\n\tfloat qu = 12.0*(bc - ac - aa) - 24.0*bb + 36.0*ab;\n    // Linear coefficients\n    float li = 4.0*(ac - ax - cx) + 8.0*(bx + bb) + 12.0*aa - 24.0*ab;\n    // Constant terms\n    float C = 4.0*(ab + ax - aa - bx);\n    vec3 roots;\n    vec4 coeffs = vec4(cu, qu, li, C);\n    \n    int nS = SolveCubic(coeffs, roots);  \n    float t;\n\n   \tfloat Dist1 = distance(x, QuadraticBezier(clamp(roots.x, 0.0, 1.0), a, b, c));\n    float Dist2 = distance(x, QuadraticBezier(clamp(roots.y, 0.0, 1.0), a, b, c));\n    float Dist3 = distance(x, QuadraticBezier(clamp(roots.z, 0.0, 1.0), a, b, c));\n    \n    return min(Dist3, min(Dist1, Dist2));\n}                 \n\nvec2 Mouse()\n{\n    vec2 a = 2.0 *(iMouse.xy / iResolution.xy) - 1.0;\n    a.x *= iResolution.x / iResolution.y;\n    return a;\n    \n}\n\nvec3 Curves(vec2 uv)\n{\n    float t = iTime * 7.0;\n    \n    float P = 0.0;\n    vec3 L = vec3(0.0);\n    \n    vec2 p0 = vec2(uv.x, -1.);\n    \n    for (float i = 0.0; i < 50.; i++) {\n    \n    vec2 p2 = vec2(1.5*sin(t*.5+i), 1.5*cos(t*.1+i)); \n    vec2 p4 = -p2;\n    vec2 p5 = vec2(-p2.y, p2.x);\n        \n        vec2 p = vec2(1.5*sin((t*0.04+i)), sin((t*.1+i) - 1.));\n    \tfloat d1 = smoothstep(0.02, 0.00, DistanceQuadraticBezier(uv, p0, p2, p));\n    \tfloat d2 = smoothstep(0.03, 0.00, DistanceQuadraticBezier(uv, p0, p4, p));\n    \tfloat d3 = smoothstep(0.05, 0.00, DistanceQuadraticBezier(uv, p0, p5, p));\n        \n    vec3 L1 = d1 * vec3(0.2 , 0.4, 0.4+ .5*sin(i));\n    vec3 L2 = d2 * vec3(0.3, 0.2, 0.4+ .2*cos(i));\n        \n        L += L1 + L2;\n    }\n    \n    return P + L;\n}   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    vec2 q = 2.0*p - 1.0;\n    q.x *= iResolution.x / iResolution.y;   \n    \n    vec3 col = vec3(0.15, 0.15, 0.19);\n    col = max(col, Curves(q));\n       \n    col = sqrt(col) * .7;\n    col = col * (1.0 - 0.2*dot(q,q));\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}