{
    "Shader": {
        "info": {
            "date": "1685141943",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!\n(mouseable)",
            "flags": 0,
            "hasliked": 0,
            "id": "DtK3WK",
            "likes": 18,
            "name": "Year of Truchets #025",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "truchet"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 280
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #025\n    05/26/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n\n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.141592653\n#define PI2        6.283185307\n\n#define MAX_DIST   50.\n#define MIN_DIST   1e-4\n\n// rotation and hash and lerp functions\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.73,59.71)+iDate.z))*4832.3234); }\nfloat lsp(float b, float e, float t){return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t = t-1.)*t*t+1.; }\n\n//@iq sdf's + extrude\nfloat opx(in float d, in float z, in float h){\n    vec2 w = vec2( d, abs(z) - h ); return min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\nfloat box(vec2 p,vec2 b){\n    vec2 d = abs(p)-b; return length(max(d,0.)) + min(max(d.x,d.y),0.);\n}\nfloat box(vec3 p, vec3 b){\n  vec3 q = abs(p)-b;return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\n// globals\nfloat tspeed=0.,tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.,gtk,stk;\n\n// constants\nconst float sz = 3.5;\nconst float db = sz*4.;\nconst float hf = sz/2.;\nconst float rd = .025;\nconst float thict = .275;\n\nvec2 map (in vec3 p) {\n \tvec2 res = vec2(1e5,0);\n    p += hf;\n    // movement\n    p.z  += ga1;\n    p.x  += ga2;\n    \n    // sizing and mixdown\n    float thick = .14+.1*sin(p.z*.5+p.y*.75+T*1.75);\n    thick -= .1+.05*sin(p.x*1.25+T);\n    thick = mix(thict,thick,.5+.5*sin(T*.2));\n    gtk=thick;\n    \n    // id grid\n    vec3 q = p, id = floor((q + hf)/sz);\n    // 3d checkerd \n    float chk = mod(id.y+mod(id.z+id.x,2.),2.)*2.-1.;\n    q = mod(q+hf,sz)-hf;\n    \n    float hs = hash21(id.xz+id.y);\n    float xhs = fract(35.37*hs);\n\n    if (hs>.5) q.y=-q.y;\n    if (chk>.5) q.xy=-q.xy;\n\n    vec3 q1,q2,q3;\n    float trh,trx,jre;\n    //draw\n    if(xhs>.75) {\n        q1 = q;\n        q2 = q + vec3(0,hf,hf);\n        q3 = q - vec3(0,hf,hf);\n        \n        trh = opx(box(q1.xz,vec2(sz,thick)),q1.y,thick)-rd;\n        trx = opx(abs(length(q2.yz)-hf)-thick,q.x,thick)-rd;\n        jre = opx(abs(length(q3.yz)-hf)-thick,q.x,thick)-rd;\n    } else {\n        q1 = q + vec3(hf,0,-hf);\n        q2 = q + vec3(0,hf,hf);\n        q3 = q - vec3(hf,hf,0);\n \n        trh = opx(abs(length(q1.xz)-hf)-thick,q.y,thick)-rd;\n        trx = opx(abs(length(q2.yz)-hf)-thick,q.x,thick)-rd;\n        jre = opx(abs(length(q3.xy)-hf)-thick,q.z,thick)-rd;\n    }\n    \n    if(trh<res.x) res = vec2(trh,2.);\n    if(trx<res.x) res = vec2(trx,3.);\n    if(jre<res.x) res = vec2(jre,4.);\n\n \treturn res;\n}\n\n// surface normal yo\nvec3 normal(vec3 p, float t) {\n    t*=MIN_DIST;\n    float d = map(p).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n        );\n    return normalize(n);\n}\n\n//@iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1., 0., 1.0 );\n    return c.z * mix( vec3(1), rgb, c.y);\n}\n\nvec4 FC = vec4(.005);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec3 p = ro;\n    float m;\n    // ray marcher\n    for(int i=0;i<80;i++) {\n        p=ro+rd*d;\n        vec2 ray = map(p);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST)break;\n        d+= i<30? ray.x*.35 : ray.x * .9;\n        m = ray.y;\n    }\n    stk=gtk;\n    if(d<MAX_DIST) {\n        vec3 n = normal(p,d);\n        vec3 lpos = vec3(hf,hf,-hf);\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),.05,1.);\n        float spec = pow(max(dot(reflect(l, n), rd ), .1), 25.)*.75;\n        vec3 clr = hsv2rgb(vec3(p.z*.062+stk*1.5+T*.02,.75,.35));\n        vec3 h = clr*clamp(diff+spec,0.,1.);\n        ref = h*.65;\n        C = h;\n        \n        ro = p+n*MIN_DIST;\n        rd = reflect(rd,n);\n    } \n    C = mix(FC.rgb,C,exp(-.00055*d*d*d));\n    // fog level\n    return vec4(C,1.);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n\n    // precal\n    tspeed = T*.65;\n    tmod = mod(tspeed,12.);\n    \n    float t1 = lsp(00.,03.,tmod);\n    t1 = eoc(t1); t1 = t1*t1*t1;\n    \n    float t2 = lsp(03.,06.,tmod);\n    t2 = eoc(t2); t2 = t2*t2*t2;\n    \n    float t3 = lsp(06.,9.,tmod);\n    t3 = eoc(t3); t3 = t3*t3*t3;\n    \n    float t4 = lsp(9.,12.,tmod);\n    t4 = eoc(t4); t4 = t4*t4*t4;\n    \n    ga1 = (t1*db)-(t3*db);\n    ga2 = (t2*db)-(t4*db);\n    \n    ga3 = (t1-t3)*PI;\n    ga4 = (t2-t4)*PI;\n\n    // screen uv\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    uv*=rot(ga3+ga4);\n    \n    // ray order+direction\n    vec3 ro = vec3(0,0,.1);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    // mouse //\n    float x = M.xy==vec2(0) || M.z <1. ? 0. : (M.y/R.y*.5-.25)*PI2;\n    float y = M.xy==vec2(0) || M.z <1. ? 0. : -(M.x/R.x*.5-.25)*PI2;\n\n    mat2 rx = rot(x+ga3), ry = rot(y-ga4);\n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n    \n    // reflection loop (@BigWings)\n    vec3 C=vec3(0), ref=vec3(0), fil=vec3(1);\n    float d=0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i==2.-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        // first bounce - get fog layer\n        if(i==0.) FC = vec4(FC.rgb,exp(-.00055*d*d*d));\n    }\n\n    //layer fog in   \n    C = mix(C,FC.rgb,1.-FC.w);\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}