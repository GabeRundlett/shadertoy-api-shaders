{
    "Shader": {
        "info": {
            "date": "1703009533",
            "description": "A trip to the world's bathtub.",
            "flags": 0,
            "hasliked": 0,
            "id": "dt3fRs",
            "likes": 11,
            "name": "Finally Free",
            "published": 3,
            "tags": [
                "raymarching",
                "water",
                "duck"
            ],
            "usePreview": 1,
            "username": "alexwerner9",
            "viewed": 267
        },
        "renderpass": [
            {
                "code": "#define AMPLITUDE .78 // the height of the waves\nfloat PI = 3.14159;\n\nstruct Hit {\n    vec3 point;\n    vec3 dir;\n    int material;\n};\n\nstruct OceanHit {\n    float d;\n    int material;\n};\n\nstruct DuckHit {\n    float d;\n    int material;\n};\n\nstruct WaterHit {\n    float ocean;\n    float duckie;\n};\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r)\n{\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\n// some of this inspired by https://www.shadertoy.com/view/MdXyzX\nWaterHit calcHeight(vec3 p, float iterations) {\n    float iter = 0.;\n    float addedNoiseW = 0.;\n    float addedNoiseD = 0.;\n    float frequency = .7;\n    float weight = 1.;\n    float timeMultiplier = 2.6;\n    float sumW = 0.;\n    float sumD = 0.;\n    for(float i = 1.; i < iterations; i += 1.) {\n        vec2 p2 = vec2(sin(iter), cos(iter));\n        vec3 waveDirection = vec3(p2.x, 0., p2.y);\n        // line of wave: waveDirection.x * x + waveDirection.z * y + 0\n        // therefore the distance from our current point to this line is\n        float a = waveDirection.x;\n        float b = waveDirection.z;\n        float distToLine = abs(a * p.x + b * p.z + 15.) / sqrt(a*a + b*b);\n        \n        float additionW = pow(3.5, sin(distToLine*frequency+iTime*timeMultiplier)-1.) * (weight);\n        addedNoiseW += additionW;\n        \n        if(i < 7.) {\n            vec3 dp = p;\n            dp.y += 1.5;\n            dp.z += 1.5;\n            vec3 pd = vec3(0.,dp.y+0.8,dp.z-2.);\n            distToLine = abs(a * pd.x + b * pd.z + 15.) / sqrt(a*a + b*b);\n            float additionD = pow(3.5, sin(distToLine*frequency+iTime*timeMultiplier)-1.) * (weight);\n\n            addedNoiseD += additionD;\n            sumD += weight;\n        }\n        \n        iter += 0.399963;\n        weight *= 0.79;\n        frequency *= 1.22;\n        timeMultiplier /= 1.1;\n        sumW += weight;\n    }\n    \n    WaterHit waterHit;\n    waterHit.ocean = addedNoiseW*AMPLITUDE / sumW;\n    waterHit.duckie = addedNoiseD*AMPLITUDE / sumD;\n    \n    return waterHit;\n}\n\nvec4 translate(vec4 v, vec3 t) {\n    mat4 translation = mat4(\n        1., 0., 0., t.x,\n        0., 1., 0., t.y,\n        0., 0., 1., t.z,\n        0., 0., 0., 1.\n    );\n    return v * translation;\n}\n\nvec4 rotateY(vec4 v, float theta) {\n    float s = sin(PI * theta);\n    float c = cos(PI * theta);\n    mat4 rotX = mat4(\n          c,  0.,  s, 0.,\n          0., 1.,  0., 0.,\n         -s,  0.,  c, 0.,\n          0., 0.,  0.,  1.\n    );\n    return v * rotX;\n}\n\nvec4 rotateZ(vec4 v, float theta) {\n    float s = sin(PI * theta);\n    float c = cos(PI * theta);\n    mat4 rotX = mat4(\n          c, -s,  0., 0.,\n          s,  c,  0., 0.,\n          0., 0., 1., 0.,\n          0., 0., 0.,  1.\n    );\n    return v * rotX;\n}\n\nDuckHit sdDuck(vec3 p) {\n\n    vec4 dp = vec4(p.xyz, 1.);\n    dp = translate(dp, vec3(0.,0.8,3.));\n    float dBody = sdEllipsoid(dp.xyz, vec3(2., 1.3, 1.));\n    \n    vec4 head = vec4(p.xyz, 1.);\n    head = translate(head, vec3(0.5,0.8-1.8,3.));\n    head = rotateZ(head, 0.2);\n    float dHead = sdEllipsoid(head.xyz, vec3(1., 1.05, 1.));\n    \n    vec4 wing1 = vec4(p.xyz, 1.);\n    wing1 = translate(wing1, vec3(-0.3,0.7,2.));\n    wing1 = rotateZ(wing1, -.3);\n    wing1 = rotateY(wing1, 0.1);\n    float dWing1 = sdEllipsoid(wing1.xyz/.1, vec3(5.,4.,2.))*.1;\n    \n    vec4 tail = vec4(p.xyz, 1.);\n    tail = translate(tail, vec3(-1.8,0.3,3.));\n    tail = rotateZ(tail, 0.7);\n    float dTail = sdEllipsoid(tail.xyz/.1, vec3(4.6,2.,3.))*.1;\n    \n    vec4 beak1 = vec4(p.xyz, 1.);\n    beak1 = translate(beak1, vec3(0.9, 0.8-2.,3.));\n    beak1 = rotateZ(beak1, 0.15);\n    float dBeak1 = sdEllipsoid(beak1.xyz/.2, vec3(5.,1.,3.))*.2;\n    \n    vec4 beak2 = vec4(p.xyz, 1.);\n    beak2 = translate(beak2, vec3(0.9, 0.8-2.,3.));\n    beak2 = rotateZ(beak2, -0.);\n    float dBeak2 = sdEllipsoid(beak2.xyz/.2, vec3(5.,1.,3.))*.2;\n\n    vec4 eye1 = vec4(p.xyz, 1.);\n    eye1 = translate(eye1, vec3(.87, 0.8-2.4, 2.2));\n    eye1 = rotateY(eye1, -0.2);\n    eye1 = rotateZ(eye1, 0.2);\n    float dEye1 = sdEllipsoid(eye1.xyz/.05, vec3(1., 3., 3.))*.05;\n    \n    float d = opSmoothUnion(dBody, dWing1, 0.1);\n    d = opSmoothUnion(d, dHead, 0.1);\n    d = opSmoothUnion(d, dTail, 0.4);\n    d = opSmoothUnion(d, dBeak1, 0.1);\n    d = opSmoothUnion(d, dBeak2, 0.1);\n    \n    DuckHit duckHit;\n    if(dBeak2 <= 0.05 || dBeak1 <= 0.05) {\n        duckHit.material = 2;\n    } else if(dEye1 <= 0.05) {\n        duckHit.material = 3;\n    } else {\n        duckHit.material = 1;\n    }\n    duckHit.d = d;\n    return duckHit;\n}\n\nOceanHit sceneOpaque(vec3 p) {\n    vec3 np = p;\n    np.y += 11.7;\n    \n    WaterHit calcedHeight = calcHeight(np,20.);\n    \n    float oceanLocation = sdBox(np, vec3(40., 10., 40.))\n                          -calcedHeight.ocean;\n    \n    vec3 dp = p;\n    dp.y += 1.4;\n    dp.z += 1.5;\n    float duckieLocation = 10.;\n    DuckHit duckHit;\n    dp.y -= calcedHeight.duckie;\n    duckHit = sdDuck(dp/.2);\n    duckHit.d *= .2;\n    duckieLocation = duckHit.d;\n    OceanHit oceanHit;\n    oceanHit.material = duckHit.material * int(step(duckieLocation-oceanLocation,0.));\n    oceanHit.d = min(oceanLocation, duckieLocation);\n    return oceanHit;\n}\n\nOceanHit sceneWater(vec3 p) {\n    //return opSmoothUnion(sceneOpaque(p), sdOrca(p), 1.);\n    return sceneOpaque(p);\n}\n\nfloat sceneFull(vec3 p) {\n    return sceneWater(p).d;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 h = vec2(.0001, 0); // Epsilon vector for swizzling\n    vec3 normal = vec3(\n       sceneFull(p+h.xyy) - sceneFull(p-h.xyy),   // x gradient\n       sceneFull(p+h.yxy) - sceneFull(p-h.yxy),   // y gradient\n       sceneFull(p+h.yyx) - sceneFull(p-h.yyx)    // z gradient\n    );\n    return normalize(normal);\n}\n\n\n// return where we hit, and the direction to move from there\nHit newHit(Hit h) {\n    Hit hit;\n    hit.point = vec3(-111.);\n    hit.dir = h.dir;\n    hit.material = 0;\n    \n    vec3 ogPoint = h.point;\n    vec3 ogDir = h.dir;\n    \n    ogPoint += normalize(ogDir)*0.011;\n    for(int i = 0; i < 100; i++) {\n        OceanHit oceanHit = sceneWater(ogPoint);\n        float distToWater = oceanHit.d;\n        if(distToWater <= 0.01) {\n            vec3 d = normalize(ogDir);\n            vec3 n = calcNormal(ogPoint);\n            \n            hit.point = ogPoint;\n            hit.dir = reflect(normalize(ogDir), n);\n            hit.material = oceanHit.material;\n            \n            break;\n        }\n        ogPoint += normalize(ogDir)*distToWater;\n    }\n    return hit;\n}\n\nvec3 colors[4];\n\nvec3 calcSkyColor(Hit hit, float damper, int material) {\n    vec3 dir = hit.dir;\n    vec3 ret = vec3(0.);\n    \n    colors[1] = vec3(1.,1.,0.2);\n    colors[2] = vec3(1.,0.2,0.2);\n    colors[3] = vec3(0.);\n    \n    vec3 color1;\n    if(material == 1 || material == 2 || material == 3) {\n        vec3 duckColor = colors[material];\n        vec3 n = calcNormal(hit.point);\n        vec3 lightDir = normalize(vec3(0.,1.,0.));\n        float diffuse = clamp(dot(n, lightDir),0.,1.)*2.;\n        vec3 fc = duckColor * diffuse;\n        fc = max(fc, duckColor*0.67);\n        color1 = clamp(fc+0.1*duckColor, 0., 1.);\n    }\n    \n    \n    dir.y -= sin(iTime/4.)/5.;\n    ret.rg = vec2((.8-abs(dir.y/1.5)));\n    ret.g -= 0.15;\n    ret.b += 0.3;\n    \n    vec3 newDir = vec3(dir.xy*6., dir.z);\n    float dotProduct = dot(normalize(newDir), normalize(vec3(0.,0.,1.)));\n    \n    vec3 newRet = vec3(1.)*pow(-dotProduct, 7.)*5.;\n    ret += newRet;\n    \n    vec3 color2 = clamp(ret / damper, 0., 1.);\n    return mix(color1, color2, step(float(material), .5));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate uv\n    vec2 uv = (fragCoord / iResolution.xy - .5) * 2.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 lightPos = vec3(-0.8,-0.1,1.);\n    vec3 lightColor = vec3(.8,0.8,0.3);\n   \n    vec3 cam_origin = vec3(0.,0.,1.);\n    vec3 rayDir = normalize(vec3(uv,0.) - cam_origin);\n    vec3 camPos = cam_origin;\n    vec3 color = vec3(0.);\n    float blurFactor = 0.;\n    \n    vec3 d;\n    vec3 n;\n    vec3 r;\n    float distToWater;\n    \n    Hit hit;\n    hit.point = camPos;\n    hit.dir = rayDir;\n    if(rayDir.y > 0.) {\n        color = calcSkyColor(hit, 1., -1);\n        \n        color -= mod(color,.1);\n        fragColor = vec4(color, 1.);\n        return;\n    }\n    \n    Hit secondHit;\n    secondHit.material = 0;\n    hit = newHit(hit);\n    if(hit.material != 0 || hit.dir.y > 0. || hit.dir.x > 0.3 || hit.dir.x < -0.3) {\n        color = calcSkyColor(hit, 1., hit.material);\n    } else {\n        vec3 waterColor = calcSkyColor(hit, 1., hit.material);\n        Hit secondHit;\n        secondHit = newHit(hit);\n        if(secondHit.material != 0) {\n            vec3 duckieColor = calcSkyColor(secondHit, 1., secondHit.material);\n            color = mix(waterColor, duckieColor, 0.7);\n            fragColor = vec4(color,1.);\n            return;\n        } else {\n            color = waterColor;\n        }\n    }\n    \n    if(hit.point != vec3(-111.) && hit.material == 0) {\n        // genius by https://www.shadertoy.com/view/MdXyzX\n        vec3 n = calcNormal(hit.point);\n        n.y = abs(n.y);\n        float dist = distance(camPos, hit.point);\n        n = mix(n, vec3(0.0, 1.0, 0.0), min(1.0, sqrt(dist*0.5) * 1.1));\n        float fres = (0.1 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-n, rayDir)), 1.0)));\n        \n        vec3 scattering = vec3(0.0493, 0.1598, 0.317)*2.4;\n        if(secondHit.material != 0) {\n            scattering = vec3(0.3, 0.3, 0.15)*2.4;\n        }\n        \n        color = fres * color + (1.0 - fres) * scattering;\n        \n    }\n    \n    color -= mod(color,.1);\n\tfragColor = vec4(color,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}