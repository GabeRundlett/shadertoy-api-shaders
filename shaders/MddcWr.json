{
    "Shader": {
        "info": {
            "date": "1518885688",
            "description": "ref: [url]http://www.jeux-gratuits.com/jeu-bubbles-bubble-shooter.html[/url]\nhard variant: [url]http://www.jeuxclic.com/jeux.php?id=19636[/url]\n\n",
            "flags": 32,
            "hasliked": 0,
            "id": "MddcWr",
            "likes": 34,
            "name": "Bubble Shooter / Puzzle Bobble ",
            "published": 3,
            "tags": [
                "game"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 3701
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 O, vec2 U )\n{\n    R = iResolution.xy;\n\n    // --- draw still balls\n    O = texelFetch(iChannel0, ivec2(U), 0); \n    // O += float(O.a!=0.);                 // for debug\n    // O += float(O.a>float(iFrame)-4.);\n    // if (O.rgb == vec3(0)) O++;\n    // if (O.a!=0.) O.rgb = col(.2*O.a);\n    \n    // --- draw moving balls\n    U = map(U);\n    vec2 P = T(0,0).xy;\n    draw( O, U- P,         T(1,0).z);       // draw current ball\n    draw( O, U-vec2(1,17), T(1,0).w);       // draw next balls to launch\n\n    // --- end of game\n    float v = T(2,0).y;\n\tif ( v < 0. && O.rgb == vec3(.4) )      // flash screen. slow=win fast=lose\n        O.rgb = col( (v==-2. ? 3. : 30. ) *iTime );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define outside(U)  U.x < -.1 || U.x > 17.6 || U.y > 18. || abs(U.y-16.) < .05\n    \n// === test whether P touch a still ball\nbool contact( vec2 P ) {\n    if ( P.y > 15.3 ) return false;          // the grey line doesn't count :-)\n    for (float a = 0.; a < 6.3; a += .393)   // inspect screen under ball's border\n        if ( slot( P +.5*vec2(cos(a),sin(a)) ).rgb != vec3(0) ) return true;\n    return false;                            // only black below ball\n}\n\n// === check for same-color neighbors: return number + P2 = one of the id\n//     If one marked for erase, n=negative and P2=this one.\n//     Also used to compute connection stamp t = max(stamps around)\nint neighbor( vec2 P, vec3 C, out vec2 P2, out float t ) {\n    int n = 0; t = 0.;\n    vec2 N, D=vec2(-1); vec4 T;\n#define neigh(i,j)  N = P+vec2(i,j); T= slot( N+.5 ); t=max(t,T.w);    \\\n                if (length((T.rgb-C)) < .3) { n++, P2=N; if (T.w<0.) D=N; }\n    neigh(-.5, 1); neigh(.5, 1);\n    neigh(-1 , 0); neigh(1 , 0);\n    neigh(-.5,-1); neigh(.5,-1);\n    if ( D.x != -1. ) { P2 = D; n = -n; } // signal marked same-color (chain erase)\n    return n;\n}\n\nfloat Frame, r;\n// === initialize a field of static balls\nvoid setBalls( inout vec4 O, vec2 U, bool scroll) {\n    U = map(U);                                    // field cell id\n    if( outside(U) ) { O = vec4(.4,.4,.4,0); return; }\n    float d = .5* step(1.,mod(U.y+r,2.));\n    vec2 P = floor(U+vec2(d,0))-vec2(d,0)+.5;      // if scroll, create no orphin ball\n    U.x -= d; vec2 C = floor(U); \n    if ( C.x<0. || C.x==17.|| U.y > 9. ) return;   // initial ball grid\n    if (scroll && slot(P+vec2(-.5,0)).w==0. && slot(P+vec2(.5,0)).w==0. ) return;\n    draw( O, fract(U)-.5, floor( 6.*rnd(C+Frame)) ); // draw local ball\n    if ( length(O) > .9 ) O.w = Frame+1.;          // mark: connected\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    R = iResolution.xy;\n    Frame = float(iFrame), \n    r = T(3,0).x;                                  // .5 offset or not at line 0\n    \n    // === initialization \n    if ( T(1,0).xy != R ) {                        // start or resize\n        O -= O; r = 0.;\n        if ( U.y==.5 ) {                           // --- state flags:\n            U -= .5;\n            if (U.x==0.) O = vec4(8.5,17,0,0);     // ball pos and direction\n            if (U.x==1.) O = vec4(R,0,1);          // R, next+current balls color\n            //  U.x==2.                            // erase delay, end game, end delay\n            //  U.x==3.                            // line 0 offset, shot count\n        }         \n        else setBalls(O,U,false);                  // create block of balls\n        return;\n    }\n    \n    O = texelFetch(iChannel0, ivec2(U), 0);        // restore state from previous frame \n    \n    // === scroll down all static balls every few shots\n    if ( T(3,0).y < 0. ) {                         // scroll requested\n        if ( map(U).y < 15.9 )\n            O = texelFetch(iChannel0, ivec2(U.x,U.y+R.y/S/2.), 0);\n        if ( map(U).y < 1.) setBalls(O,U,true);    // create new line 0\n        if ( U==vec2(3.5,.5) ) O.y = 0.;           // reset request\n        return;                                    // restart the frame\n    }\n\n    vec2 M,N,N0, \n    // === process current ball\n         P = T(0,0).xy;                            // current ball\n\n    // --- current ball collides still balls\n    if ( contact(P) || P.y < .4 ) {\n        float d = .5* step(1.,mod(P.y+r,2.));      // === process ball\n        P.x -= d; P = floor(P); P.x += d;          // cell id (=corner pos)\n        float t, c = T(1,0).z;                     // current color\n        draw( O, map(U)-P-.5, c);                  // draw new still ball \n        if (onBall(U,P)) {\n            O.w = Frame;                           // mark connected\n            int n = neighbor(P, col(c), N,t);      // test chain of color\n            if (n == 1 ) n = neighbor(N, col(c), N0,t) +1;// does neighbor has neighbor ?\n            if (n >= 2 ) O.w = -1.;                // mark to erase\n        }\n        if (U.y==.5) {                             // === process flags\n            if ( U.x ==  .5 ) O = vec4(8.5,17,0,0);// restart current ball\n            if ( U.x == 1.5 ) O.z = O.w, O.w = floor(6.*rnd(vec2(Frame))); // next colors\n            if ( U.x == 2.5 ) O.x = float((iFrame-1)%10);// sync delay\n            if ( U.x == 2.5 && P.y > 14.) O.y = -1., O.z = Frame; // lose display\n            if ( U.x == 3.5 && O.y>= 16.) O.y = -1., O.x = 1.-O.x;// triger scrolling\n        }\n    }\n    \n    // === process state flags & variables\n    if ( U.y==.5 ) { \n        // --- current ball dynamics\n        if ( U.x==.5 ) {\n            if ( iMouse.z > 0. && O.zw == vec2(0) ) {  // mouse launch\n                M = map(iMouse.xy);\n                O.zw = normalize( M - vec2(8.5,17) );  // launch direction\n            }\n            O.xy += O.zw*s;                            // move\n            if ( O.x < .8 || O.x > 16.8 ) O.z = -O.z;  // bounce on sides\n            if ( O.y > 15.5 && O.w > 0. ) O.w = -O.w;\n        }\n        // === count shots. Scrolling every few shots\n        if ( U.x==3.5 && iMouse.z > 0. && T(0,0).zw == vec2(0) ) O.y++;// shot++\n            \n        // === process end of game\n        vec4 T = T(2,0);\n        // --- reset after end flash\n        if ( T.y < 0. && Frame-T.z > 250. )        // flash set, for long\n            if (U.x==2.5 || U.x==1.5 ) O -= O;     // reset flash and game\n        // --- test if win        \n        if ( U.x==2.5 && T.y >= 0.) {              // flash not set\n            int n = 0;\n            for ( float i=0.; i<17.; i++ )         // count balls on line 0\n                if ( slot( vec2(i+.5*r,0) +.5 ).w != 0. ) n++;\n            if (n==0) O.y = -2., O.z = Frame;      // win display\n          }\n    }\n\n    // === process local still ball\n    P = map(U); \n    if( outside(P) ) return; \n    float t, d = .5* step(1.,mod(P.y+r,2.));\n    P.x -= d; P = floor(M=P); P.x += d;\n    vec4 C = slot(P+.5);                           // col and state of local ball\n    \n    // --- propagate connection signal\n    if (onBall(U,P) && C.w > 0.)       // O.w\n        if (P.y==0.) O.w = C.w+1.;     // O.w++    // line 0 triggers connection signal\n        else neighbor(P,vec3(0),N,t), O.w = max(t,O.w);    // propagate from best neighbor\n    \n    if ( iFrame%10 == int(T(2,0).x) )                      // for progressive collapse\n    // --- still ball to be erased\n        if ( C.w < 0. || ( C.w > 0. && Frame-C.w > 60. ) ) // marked or deconnected    \n            draw( O, fract(M)-.5, -1.);\n    // --- same-color neighbor of an erasable ball: mark to erase\n        else if ( onBall(U,P) && neighbor(P, C.rgb, N,t) < 0 ) O.w = -1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float s = .3,   // ball speed in cells unit\n            S = 10.,  // scaling: windows height = 2*S rows. Ball radius ~ R.y/S\n       scroll = 12.;  // scroll every few shots\nvec2 R;\n\n#define rnd(v) fract(sin(dot(v, vec2(12.9898, 78.233))) * 43758.5453)\n\n// === convert screen to row/col coordinates and back (without odd-lines shift)\nvec2    map(vec2 U) { U = S*(U+U-R)/R.y;    return vec2( U.x+S*.85, S-U.y); }\nivec2 unmap(vec2 U) { U = vec2( U.x-S*.85, S-U.y); return ivec2(U*R.y/S+R)/2; }\n\n#define T(i,j)   texelFetch( iChannel0, ivec2(i,j), 0 ) // to access state flags\n#define slot(P)  texelFetch( iChannel0, unmap(P)  , 0 ) // to access cells\n\n// --- current pixel is on ball(N) marking zone (w channel at ball center)\n  #define onBall(U,N) length(U-.5-vec2(unmap(N+.5))) < 2.   \n//#define onBall(U,N) U-.5 == vec2(unmap(N+.5)) \n\n// === RGB color associated to color number\n#define col(v)   ( .5 + .5 * cos( v + vec3(0,23,21) ) )\n\n// === draw or erase a ball\nvoid draw( inout vec4 O, vec2 U, float c ) {\n    float v = 1. -3.5 * (dot(U,U));      // attention to not cover neighor cells\n    if ( v > .2 ) {            \n        U = 4.*(U+.12); \n        if ( c < 0. ) O =  vec4(0);                              // erase\n        else O.rgb = v * col(c) + .8* max( 0., 1.-3.*dot(U,U) ); // draw\n          // O.w = step(.9,v);                                   // mark active\n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}