{
    "Shader": {
        "info": {
            "date": "1596492314",
            "description": "simple raytracer, uses importance sampling with four different sampling methods.\n\nnow with multiple importance sampling!\n\nClick to reset the accumulation buffer.",
            "flags": 32,
            "hasliked": 0,
            "id": "3tffRN",
            "likes": 2,
            "name": "joes raytracer / pathtracer",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 1,
            "username": "copperbotte",
            "viewed": 484
        },
        "renderpass": [
            {
                "code": "\n//include common\n\nvec3 saturationClip(vec3 rgb)\n{\n    vec3 hsv = rgb2hsv(rgb);\n    \n    if(1.0 < hsv.z)\n        hsv.yz /= hsv.z;\n    \n    return hsv2rgb(hsv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    \n    //saturation projection\n    col = saturationClip(col);\n    \n    //convert color space from lsrgb to srgb\n    col = lsrgb2srgb(col);\n    \n\t//output image\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Changelog, since the description has a character limit.\n// TODO: Fill changelog with old \"commits\"\n// 9/14/2020 - Added simple, non PBR fog\n// 1/16/2021 - Fixed MIS\n// 1/25/2021 - Corrected light sampler, no more brightness issues\n// 2/24/2021 - Reworked fog sampling\n\n// random number generator **\n// taken from iq :)\nfloat seed;    //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\n//another random number generator\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat hashrandom( float x )\n{\n    return floatConstruct(hash(floatBitsToUint(x)));\n}\n\n///////////////////\n// Scene Structs //\n///////////////////\n\nstruct Material\n{\n    vec3 emission;\n    vec3 albedo;\n    vec3 reflectivity;\n    float power; // vec3 requires 1 sample per color\n};\n\n//sky + fog + 2 planes + 11 spheres + triangle // + bunny\nconst int MatNum = 1 + 1 + 2 + 11 + 1;//5 + 10 + 1;\nMaterial Materials[MatNum];\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n} Spheres[2 + 9];\n\nstruct Plane\n{\n    vec3 normal;\n    float offset;\n} Planes[2];\n\nstruct Tri\n{\n    Plane plane; // metadata\n    vec3 vertex[3];\n} Tris[1];\n\n\nconst int iFrameStart = 0;\n\n//to World\nvec3 toWorld(vec3 dir, vec3 normOut)\n{\n    //todo: do this properly using quaternions\n    vec3 normDir = vec3(0,0,1);\n    \n    float epsilon = 1.0 - 1e-5;\n    if(epsilon < dot(normDir, normOut))\n        return dir;\n        \n    if(dot(normDir, normOut) < -epsilon)\n        return -dir;\n    \n    //make a pair of bases that are orthogonal to the output normal\n    vec3 a = cross(normDir, normOut);\n    a = normalize(a);\n    \n    vec3 b = cross(a, normOut);\n    b = normalize(b);\n    \n    mat3 M = mat3(a, b, normOut);\n    \n    return normalize(M * dir);\n}\n\n//random point in lat/long coords (naiive implementation)\nvec3 randMercator(out float pdf)\n{\n    float xi1 = rnd();\n    float xi2 = rnd();\n\t\n    float psi = xi1 * 3.141592;\n    float theta = xi2 * 2.0 * 3.141592;\n    \n    float x = sin(psi) * cos(theta);\n    float y = sin(psi) * sin(theta);\n    float z = cos(psi);\n\n    pdf = sin(psi);\n    \n    return vec3(x, y, z);\n}\n\n//random point in sphere\nvec3 randSphere()\n{\n    float xi1 = rnd() * 2.0 - 1.0;\n    float xi2 = rnd();\n\n    float theta = xi2 * 2.0 * 3.141592;\n    float sinp = sqrt(1.0 - xi1*xi1);\n\n    float x = sinp * cos(theta);\n    float y = sinp * sin(theta);\n    float z = xi1;\n\n    return vec3(x, y, z);\n}\n\nvec3 randLambert(vec3 normal)\n{\n    float xi1 = rnd();\n    float xi2 = rnd();\n\n    float theta = xi2 * 2.0 * 3.141592;\n    float cosp = sqrt(xi1);\n    float sinp = sqrt(1.0 - cosp*cosp);\n\n    float x = sinp * cos(theta);\n    float y = sinp * sin(theta);\n    float z = cosp;\n\n    return toWorld(vec3(x, y, z), normal);\n}\n\n//general case of randLambert\nvec3 randPhongSpec(vec3 normal, vec3 rIn, float power)\n{\n    vec3 refl = reflect(rIn, normal);\n    \n    float xi1 = rnd();\n    float xi2 = rnd();\n    \n    float theta = xi2 * 2.0 * 3.141592;\n    float cosp = pow(xi1, 1.0/power);\n    float sinp = sqrt(1.0 - cosp*cosp);\n\n    float x = sinp * cos(theta);\n    float y = sinp * sin(theta);\n    float z = cosp;\n\n    return toWorld(vec3(x, y, z), refl);\n}\n\nvec3 randScatterGeometric(vec3 rIn)\n{\n    /*\n    //fires a ray within a disc toward a sphere\n    //aligns output ray to input direction\n    \n    //\"normal\" is +z\n    \n    vec3 rSrc = vec3(0,0,1);\n    \n    vec3 norm = randLambert(rSrc); // i can't believe this popped out of the math!\n    \n    vec3 refl = reflect(-rSrc, norm);\n    */\n    \n    //direct formulation\n    float xi1 = rnd();\n    float xi2 = rnd();\n    \n    float theta = 2.0 * 3.141592 * xi1;\n    float phi = pow(xi2, 1.0 / 3.0); //cube root\n    phi = 2.0 * asin(phi);\n    \n    float sinp = sin(phi);\n    float cosp = cos(phi);\n    \n    float x = sinp * cos(theta);\n    float y = sinp * sin(theta);\n    float z = cosp;\n    \n\treturn toWorld(vec3(x,y,z), rIn);\n}\n\nvec2 randTri()\n{\n    //very simple, random triangle in a half unit square.\n    float xi1 = rnd();\n    float xi2 = rnd();\n    \n    float a = sqrt(xi1);\n    \n    return vec2(1.0-a, a*xi2);\n}\n\nstruct Ray\n{\n\tvec3 src;\n    vec3 dir;\n};\n    \nstruct tvHit\n{\n\tRay ray;\n    vec3 normal;\n    int id;\n    float rayDist;\n    float errRtrn; // debug\n};\n\nvoid tvSphere(Ray rIn, vec3 normIn, out tvHit hit, inout float rayDist, int id, float sRad, vec3 sPos)\n{\n    //*\n    //use the closer solution if ray is outside sphere, farther if inside\n    vec3 sDelta = sPos - rIn.src; // delta\n    float sDelta2 = dot(sDelta, sDelta);\n    \n    float sRayClosest = dot(sDelta, rIn.dir); // x\n    float sRad2 = sRad * sRad;\n    \n    //check if ray is outside\n    bool above = sRad2 <= sDelta2; // true if outside\n    bool facing = 0.0 <= sRayClosest;\n    \n    //catch if ray is on surface, and facing surface\n    const float epsilon = 1e-4; // 1e-4 is really high for an epsilon\n    if(abs(sRad2 - sDelta2) < epsilon)\n    {\n        if(dot(normIn, rIn.dir) < 0.0) // if ray points away from the surface it came from\n            return;\n        //adjust which side the ray lies on\n        above = dot(normIn, sDelta) < 0.0;\n        //facing = !above; // redundant?\n    }\n    \n    //catch if ray faces away, and is outside\n    if(above && !facing)\n        return;\n    \n    //ray can miss if r^2 < s^2\n    //find s\n    float sRayClosest2 = sRayClosest * sRayClosest;\n    float s2 = sDelta2 - sRayClosest2;\n    \n    //catch if r^2 < s^2, ray misses sphere\n    if(sRad2 < s2) // check for outside?\n        return;\n    \n    //ray should always hit\n    //find offset\n    float offset = sqrt(sRad2 - s2);\n    if(above) // use closer solution\n        offset = -offset;\n    \n    float rDist = sRayClosest + offset;\n    if(rDist < rayDist && 0.0 <= rDist)\n    {\n        hit.rayDist = rayDist = rDist;\n        hit.ray.src = rIn.src + rIn.dir * rDist;\n        hit.normal = normalize(hit.ray.src - sPos);\n        if(!above)\n            hit.normal = -hit.normal;\n        \n        hit.id = id;\n    }\n    \n    //*/\n    /*\n    vec3 sOffset = sPos - rIn.src; // delta\n    //ray points toward sphere\n    if(0.0 < dot(sOffset, rIn.dir))\n    {\n        float sRayClosest = dot(sOffset, rIn.dir);\n        float sRayClosestDist2 = dot(sOffset, sOffset) - sRayClosest*sRayClosest;\n        float sInnerOffset2 = sRad * sRad - sRayClosestDist2;\n        if(0.0 < sInnerOffset2)\n        {\n            //hit sphere, calculate intersection\n            float rDist = sRayClosest - sqrt(sInnerOffset2);\n            if(rDist < rayDist && 0.0 < rDist)\n            {\n                hit.rayDist = rayDist = rDist;\n                hit.ray.src = rIn.src + rIn.dir * rDist;\n                hit.normal = normalize(hit.ray.src - sPos);\n                //hit.normal /= sqrt(dot(hit.normal, hit.normal));\n                hit.id = id;\n            }\n        }\n    }\n    //*/\n}\n\nvoid tvPlane(Ray rIn, out tvHit hit, inout float rayDist, int id, vec3 normal, float off)\n{\n    //test if ray is above surface\n    float side = dot(rIn.src, normal);\n    bool above = off < side;\n    \n    //test if ray points toward surface\n    float proj = dot(rIn.dir, normal); //not the adjusted normal\n    bool facing = proj < 0.0;\n    \n    if(above == facing)\n    {\n        Ray rDst = rIn;\n        rDst.src = rIn.src + rIn.dir * ((off - side) / proj);\n\n        vec3 diff = rDst.src - rIn.src;\n        float dist = length(diff); //sqrt(dot(diff, diff));\n\n        if(dist < rayDist)\n        {\n            hit.rayDist = rayDist = dist;\n            hit.ray = rDst;\n            hit.normal = normal;\n            hit.id = id;\n            \n            if(!above)\n                hit.normal = -normal;\n        }\n    }\n}\n\nbool pointInTri(Tri tri, vec3 point, out vec2 coords)\n{\n    //v1 and v2 form a basis space, whose linear combination is vt. vt = a*v1 + b*v2.\n    //Since vt is guaranteed to be on the plane between the two, its psuedoinverse is its inverse.\n    //moore-penrose psuedoinverse: (MT*M)^-1 * MT = M+\n    \n    //move space toward first vertex\n    //maybe use a mul?\n    mat3 verts = mat3(tri.vertex[0], tri.vertex[1], tri.vertex[2]);\n    verts -= mat3(vec3(0.0), tri.vertex[0], tri.vertex[0]);\n    \n    mat2x3 space = mat2x3(verts[1], verts[2]); // can this be truncated from tri?\n    mat3x2 st = transpose(space);\n    mat2x2 inv = st * space;\n    \n    //if the inverse's inputs has no determinant, it covers no area, and has no inverse.\n    if(determinant(inv) == 0.0)\n        return false;\n    \n    mat3x2 mpi = inverse(inv) * st;\n    vec2 mpipt = mpi * (point - verts[0]); // move into basis space\n    \n    //if the point does not lie within the unit triangle, it misses.\n    if(mpipt.x < 0.0)\n        return false;\n    if(mpipt.y < 0.0)\n        return false;\n    if(1.0 < dot(mpipt, vec2(1,1)))\n       return false;\n    \n    coords = mpipt;\n    return true;\n}\n\nvoid tvTri(Ray rIn, out tvHit hit, inout float rayDist, int id, Tri tri)\n{\n    //this uses code from my one shader rasterizer for a point in triangle test, with the plane traverse above.\n    //https://www.shadertoy.com/view/wdGyWR\n    //ideally, models are arranged in a heirarchical format to accellerate raytracing, but doing that per frame\n    //    isn't ideal. Much more managable on a cpu / gpu system.\n    \n    //traverse toward plane\n    tvHit pHit;\n    pHit.ray = rIn;\n    pHit.normal = vec3(0,0,0);\n    pHit.id = 0; // id of the sky\n    \n    float dist = rayDist;\n    tvPlane(rIn, pHit, dist, id, tri.plane.normal, tri.plane.offset);\n    if(pHit.id == 0) // miss\n        return;\n    \n    if(rayDist <= dist)\n        return;\n    \n    vec2 coords;\n    if(!pointInTri(tri, pHit.ray.src, coords))\n        return;\n    \n    //lerp to find position\n    //Ray rDst = rIn;\n    //rDst.src = verts * vec3(1.0, coords);\n    \n    //if(dist < rayDist)\n    rayDist = dist;\n    hit = pHit;\n    //hit.ray = rDst;\n}\n/*\nvoid tvFog(Ray rIn, out tvHit hit, inout float rayDist, int id)\n{\n    float absorbtion = Materials[1].albedo.x;\n    if(absorbtion == 0.0)\n        return;\n    \n    float epsilon = rnd();\n    float x = log(epsilon) / absorbtion;\n    \n    Ray rDst = rIn;\n    rDst.src = rIn.src + rIn.dir * x;\n    \n    if(x < rayDist)\n    {\n        hit.rayDist = rayDist = x;\n        hit.ray = rDst;\n        hit.normal = rIn.dir; // hit.normal isn't used in BSDFs, only in and out directions.\n        hit.id = id;\n    }\n}\n*/\ntvHit traverse(Ray rIn, vec3 normIn, int inid) // normal is required to prevent the ray from going backwards from its surface\n{\n    tvHit hit;\n    hit.ray = rIn;\n    hit.normal = vec3(0);\n    hit.id = 0; // id of the sky\n    float rayDist = 1.0e30;\n    hit.rayDist = rayDist;\n    \n    //check if ray fires below current surface\n    if(dot(rIn.dir, normIn) < 0.0)\n    {\n        //hit nothing, return a bunch of zeroes\n        hit.rayDist = rayDist = 0.0;\n        hit.normal = normIn;\n        hit.id = inid;\n        return hit;\n    }\n    \n    \n    //raytrace fog\n    //fog can collide with itself\n    //tvFog(rIn, hit, rayDist, 1);\n    \n    //moved tvFog to outside traverse, to allow it to work with light sampling techniques.\n    //is this a two-bounce sampler?\n    //equi-angular sampling seems superior\n    \n    //plane\n    if(inid != 2)\n        tvPlane(rIn, hit, rayDist, 2, Planes[0].normal, Planes[0].offset);\n        //tvPlane(rIn, hit, rayDist, 2, normalize(vec3(-2,1,1)), vec3(0,0,-0.7));\n    \n    //other plane\n    if(inid != 3)\n    {\n        tvHit h = hit;\n        float rd = rayDist;\n    \ttvPlane(rIn, h, rayDist, 3, Planes[1].normal, Planes[1].offset);\n        vec2 p = h.ray.src.xy+vec2(0,-5);\n        //if(dot(p,p) <= 10.0*10.0) hit = h;\n        if(dot(p,p) > 10.0*10.0) h.id = 0;\n        if(rd > rayDist)\n            hit = h;\n    }\n    \n    \n    //raytrace sphere\n    //if(inid != 4)\n        //tvSphere(rIn, hit, rayDist, 4, 1.0, vec3(-1.0,3.0,-0.5 + 1.0 - 0.5 + 0.0*sin(iTime)));\n        tvSphere(rIn, normIn, hit, rayDist, 4, Spheres[0].radius, Spheres[0].position);\n    \t\n    //raytrace other sphere\n    if(inid != 5)\n    \ttvSphere(rIn, normIn, hit, rayDist, 5, Spheres[1].radius, Spheres[1].position);\n    //{\n    //    float sRad = 0.25;\n    //    tvSphere(rIn, hit, rayDist, 5, sRad, vec3(2.0*cos(iTime) - 1.0,3.0 + 2.0*sin(iTime),-1.0 + sRad));\n    //}\n    \n    for(int i=0; i<11 - 2; ++i)\n    \ttvSphere(rIn, normIn, hit, rayDist, i + 6, Spheres[i+2].radius, Spheres[i+2].position);\n    \n    if(inid != 15)\n        tvTri(rIn, hit, rayDist, 15, Tris[0]);\n    /*\n    if(hit.id == 3)\n    {\n        float p = 0.0;\n        vec2 xy = hit.ray.src.xy;\n        vec2 ixy = xy - vec2(ivec2(xy + vec2(10000.0)) - ivec2(10000.0));\n        if(0.5 < ixy.x) p = 1.0 - p;\n        if(0.5 < ixy.y) p = 1.0 - p;\n        \n        if(p == 1.0)\n        {\n            p = 0.0;\n            xy /= 20.0;\n            ixy = xy - vec2(ivec2(xy + vec2(10000.0)) - ivec2(10000.0));\n            if(19.0/20.0 < ixy.x && 19.0/20.0 < ixy.y) p = 1.0 - p;\n            if(p == 1.0)\n                hit.id = 0;\n        }\n    }*/\n    \n    return hit;\n}\n\nfloat brdfLambert(tvHit Hit, Ray rOut)\n{\n    float diffuse = dot(Hit.normal, rOut.dir) / 3.141592;\n    diffuse = clamp(diffuse, 0.0, 1.0);\n    return diffuse;\n}\n\nfloat brdfPhongSpecular(tvHit Hit, Ray rIn, Ray rOut, float power)\n{\n    vec3 refl = reflect(rIn.dir, Hit.normal);\n    \n    float specular = dot(rOut.dir, refl);\n    specular = clamp(specular, 0.0, 1.0);\n    \n    specular = pow(specular, power);\n    specular *= (power + 2.0) / (2.0 * 3.141592);\n  \treturn specular;\n}\n\nvec3 brdfPhong(tvHit Hit, Ray rIn, Ray rOut, Material Mat)\n{\n    vec3 albedo = Mat.albedo;\n    vec3 reflectivity = Mat.reflectivity;\n    float power = Mat.power;\n    \n    float diffuse = brdfLambert(Hit, rOut);\n    float specular = brdfPhongSpecular(Hit, rIn, rOut, power);\n    \n    vec3 brdf = (1.0 - reflectivity) * albedo*diffuse + reflectivity * specular;\n    \n    return brdf;\n}\n\nfloat bsdfUniform(tvHit Hit, Ray rOut)\n{\n    return 1.0 / (4.0 * 3.141592);\n}\n\nfloat bsdfGeometric(tvHit Hit, Ray rOut)\n{\n    //Cardioid!\n    //uses ray.dir instead of normal\n    float cosp = -dot(Hit.ray.dir, rOut.dir);\n    \n    //this can produce NaNs\n    //cosp out of bounds?\n    //if(sinp != sinp)\n    //    return 0.0;\n    cosp = clamp(cosp, -1.0, 1.0);\n    \n    float sinp = sin(acos(cosp)/2.0);\n    \n    return sinp / (8.0 * 3.141592 / 3.0);\n    \n    //geometric sampling is acting strange\n    //return bsdfUniform(Hit, rOut);\n\n    float normalizer = 1.0 / (4.0 * 3.141592);\n}\n\nfloat bsdfRayleigh(tvHit Hit, Ray rOut)\n{\n    //Spherical harmonics?\n    float cosp = -dot(Hit.ray.dir, rOut.dir);\n    \n    float bsdf = 1.0 + cosp*cosp;\n    \n    return bsdf / (16.0 * 3.141592 / 3.0);\n}\n\nfloat bvtfHomogenous(float fDist, float fpdf) // bidirectional volume transmission function\n{\n    float absorbtion = Materials[1].albedo.x;\n    if(absorbtion == 0.0) // no fog\n        return 1.0;\n    \n    fpdf += 1e-31;\n    \n    float ret = absorbtion*exp(-absorbtion * fDist) / fpdf;\n    \n    if(ret != ret)\n        return 0.0;\n    return ret;\n}\n\nvec3 sampleMercator(tvHit Hit, out float pdf)\n{\n  \tpdf = 1.0;\n    vec3 rOut = randMercator(pdf);\n    \n    if(dot(rOut, Hit.normal) < 0.0)\n        rOut = reflect(rOut, Hit.normal);\n    \n    pdf = 1.0 / pdf; // numerator pdf when multiplied\n    \n    //should these be packed into the sampler?\n    pdf /= (2.0 * 3.141592) * (3.141592 / 2.0); // sample space pdf: theta, psi\n    \n    return rOut;\n}\n\nvec3 sampleSphere(tvHit Hit, out float pdf)\n{\n  \tpdf = 1.0;\n    vec3 rOut = randSphere();\n    \n    if(dot(rOut, Hit.normal) < 0.0)\n        rOut = reflect(rOut, Hit.normal);\n    \n    //should these be packed into the sampler?\n    //float pdf = 1.0; // no numerator pdf\n    pdf /= 2.0 * 3.141592; // 4pi r^2 / 2, half a sphere's area (clamped)\n    \n    return rOut;\n}\nfloat pdfSphere(tvHit Hit, Ray rOut)\n{\n    return 1.0 / (2.0 * 3.141592);\n}\n\n\nvec3 sampleLambert(tvHit Hit, out float pdf)\n{\n  \t//pdf = 1.0; // no pdf at all, due to importance sampling\n    //this is absolutely wrong, the pdf is equal to the brdf so they cancel\n    //however, when the pdf is zero it should return 0 juuuust in case haha\n    \n    //if(0.0 < dot(Hit.normal, Hit.ray.dir))\n    //    Hit.normal *= -1.0;\n    \n    //Hit.normal *= -1.0;\n    \n    Ray ray;\n    ray.dir = randLambert(Hit.normal);\n    \n    pdf = brdfLambert(Hit, ray);\n    \n    return ray.dir;\n}\n\nfloat pdfLambert(tvHit Hit, Ray rOut)\n{\n    return brdfLambert(Hit, rOut);\n}\n\nvec3 samplePhongSpec(tvHit Hit, out float pdf, Ray rIn, float power)\n{\n    Ray ray;\n    \n    ray.dir = randPhongSpec(Hit.normal, rIn.dir, power);\n    pdf = brdfPhongSpecular(Hit, rIn, ray, power);\n\t\n    return ray.dir;\n}\n\nfloat pdfPhongSpec(tvHit Hit, Ray rIn, Ray rOut, float power)\n{\n    if(brdfLambert(Hit, rOut) <= 0.0)\n        return 0.0;\n    return brdfPhongSpecular(Hit, rIn, rOut, power);\n}\n\nvec3 samplePhongOld(tvHit Hit, out float pdf, Ray rIn, vec3 reflectivity, float power)\n{\n    Ray ray;\n    \n    //can this be done better by treating it as an MIS?\n    \n    //float refl = dot(reflectivity, vec3(1,1,1)) / 3.0;\n    \n    float refl = 0.5;\n    \n    if( refl < rnd()) // diffuse\n    {\n        ray.dir = sampleLambert(Hit, pdf);\n    \t//pdf *= 1.0 - refl;\n    }\n    else // specular\n    {\n        ray.dir = samplePhongSpec(Hit, pdf, rIn, power);\n    \t//pdf *= refl;\n    }\n    \n    return ray.dir;\n}\n\nvec3 samplePhong(tvHit Hit, out float pdf, Ray rIn, Material mat)\n{\n    return samplePhongOld(Hit, pdf, rIn, mat.reflectivity, mat.power);\n    float reflectivity = 0.25; // hardcoded\n    Ray ray;\n    \n    //can this be done better by treating it as an MIS?\n    float pdfLambert = 1.0;\n    float pdfPhongSpec = 1.0;\n    \n    vec3 samLambert = sampleLambert(Hit, pdfLambert);\n    vec3 samPhongSp = samplePhongSpec(Hit, pdfPhongSpec, rIn, mat.power);\n    \n    float misWeight = (1.0 - reflectivity)*pdfLambert + reflectivity*pdfPhongSpec;\n    float wLambert = pdfLambert / misWeight + 1e-10;\n    float wPhongSpec = pdfPhongSpec / misWeight + 1e-10;\n    \n    if(wLambert < rnd()) // diffuse\n    {\n        pdf = pdfLambert * wLambert;\n        ray.dir = samLambert;\n    }\n    else // specular\n    {\n        pdf = pdfPhongSpec * wPhongSpec;\n        ray.dir = samPhongSp;\n    }\n    \n    return ray.dir;\n}\n\nfloat pdfPhong(tvHit Hit, Ray rIn, Ray rOut, Material mat)\n{\n    float diffuse = pdfLambert(Hit, rOut);\n    return diffuse;\n    \n    //if(diffuse == 0.0)\n    //    return 0.0;\n    float specular = pdfPhongSpec(Hit, rIn, rOut, mat.power);\n    float refl = dot(mat.reflectivity, vec3(1,1,1)) / 3.0;\n    return refl*specular + (1.0-refl)*diffuse;\n}\n\nvec3 sampleLightSingular(tvHit Hit, out float pdf, out vec3 samPos, vec3 sPos, float sRad)\n{\n    //selects a random point on the light to raytrace towards\n    vec3 rPos = randSphere();\n    vec3 rNorm = rPos;\n    \n    //finds the vector from the ray source to this sample\n    rPos *= sRad;\n    rPos += sPos;\n    \n    samPos = rPos; // useful for fog sampling\n    \n    rPos -= Hit.ray.src;\n    \n    //pdf is the probability area projected toward from point\n    float r2 = dot(rPos, rPos);\n    vec3 rOut = rPos / sqrt(r2);\n    \n    float area = 2.0 * 3.141592 * sRad * sRad; // hemisphere? area\n    area *= abs(dot(rNorm, rOut)); // projected area\n    pdf = r2 / area; // 1/area, in case r2 is near zero it works better here\n    \n    /*\n    //repeat for the sample on the other side of the sphere, to find the complete pdf\n    rNorm = -reflect(rNorm, rOut); // other side\n    rPos = rNorm * sRad;\n    rPos += sPos;\n    rPos -= Hit.ray.src;\n    r2 = dot(rPos, rPos);\n    area = 4.0 * 3.141592 * sRad * sRad;\n    area *= abs(dot(rNorm, rOut));\n    pdf += r2 / area;\n    */\n    \n    if(pdf != pdf) // if r2 and the dot are both 0, pdf becomes NaN.\n        pdf = 0.0; // 0/0 == 0 haha\n    \n    return rOut;\n}\n\nfloat pdfLightSingular(tvHit Hit, Ray rOut, vec3 sPos, float sRad)\n{\n    vec3 delta = sPos - rOut.src;\n    vec3 ndelta = normalize(delta);\n    float delta2 = dot(delta, delta);\n    float r2 = sRad * sRad;\n    float proj = dot(ndelta, rOut.dir);\n    \n    if(proj < 0.0) // sphere is below ray\n        return 0.0;\n    \n    if(delta2 < r2) // ray is within sphere\n        return 0.0; // harder to code\n    \n    if(proj * proj <= (1.0 - (r2 / delta2))) // if the ray misses the sphere\n        return 0.0;\n    \n    //find intersection\n    float mdelta = sqrt(delta2);\n    float mmid = dot(delta, rOut.dir); // proj * mdelta // length of line that makes a right angle to the sphere\n    float mmid2 = mmid * mmid;\n    float mdev2 = r2 + mmid2 - delta2;\n    if(mdev2 < 0.0)\n        return 0.0;\n        \n    //mdev is the little length difference between mid and dist\n    float mdev = sqrt(mdev2);\n    \n    float dist1 = mmid - mdev; // is this a complex root?\n    float dist2 = mmid + mdev; // a sqrt's involved, and there's two conjugates\n    \n    vec3 sHit1 = dist1 * rOut.dir + rOut.src; // oh shit\n    vec3 sHit2 = dist2 * rOut.dir + rOut.src;\n    \n    vec3 n1 = normalize(sHit1 - sPos);\n    vec3 n2 = normalize(sHit2 - sPos);\n    \n    //find projected areas\n    float pdf = 0.0;\n\tfloat SA = 4.0 * 3.141592 * r2;\n\t\n\tfloat A1 = SA * abs(dot(n1, rOut.dir));\n\tfloat A2 = SA * abs(dot(n2, rOut.dir));\n\t\n\t// area facing the ray, over the distance ^2\n\tfloat pdf1 = (dist1 * dist1) / A1;\n\tfloat pdf2 = (dist2 * dist2) / A2;\n\t\n    pdf = pdf1 + pdf2;\n    \n    if(pdf != pdf) // if r2 and the dot are both 0, pdf becomes NaN.\n        pdf = 0.0; // 0/0 == 0 haha\n    \n    return pdf;\n}\n\nvec3 sampleTri(tvHit Hit, out float pdf, out vec3 samPos, Tri tri)\n{\n    vec2 uv = randTri();\n    \n    //build basis space\n    mat3 space = mat3(tri.vertex[0], tri.vertex[1], tri.vertex[2]);\n    space -= mat3(vec3(0.0), tri.vertex[0], tri.vertex[0]);\n    \n    //lerp into real space\n    vec3 rPos = space * vec3(1.0, uv);\n    \n    samPos = rPos; // useful for fog sampling\n    \n    rPos -= Hit.ray.src;\n    \n    //pdf is the probability area projected toward from point\n    float r2 = dot(rPos, rPos);\n    vec3 rOut = rPos / sqrt(r2);\n    \n    // there's gotta be an easier way to find this\n    float area = length(cross(space[1], space[2])) / 2.0; \n    \n    area *= abs(dot(tri.plane.normal, rOut)); // projected area\n    pdf = r2 / area; // 1/area, in case r2 is near zero it works better here\n    \n    return rOut;\n}\n\nfloat pdfTri(tvHit Hit, Ray rOut, Tri tri)\n{\n    //find if rOut hits the tri\n    tvHit hit;\n    hit.ray = rOut;\n    hit.normal = vec3(0,0,0);\n    hit.id = 0; // id of the sky\n    float rayDist = 1.0e30;\n    \n    tvTri(rOut, hit, rayDist, 1, Tris[0]); // id doesn't really matter\n    if(hit.id == 0)\n        return 0.0; // miss\n    \n    //build basis space\n    mat3 space = mat3(tri.vertex[0], tri.vertex[1], tri.vertex[2]);\n    space -= mat3(vec3(0.0), tri.vertex[0], tri.vertex[0]);\n    \n    //pdf is the probability area projected toward from point\n    float r2 = rayDist * rayDist;\n    \n    // there's gotta be an easier way to find this\n    float area = length(cross(space[1], space[2])) / 2.0; \n    \n    area *= abs(dot(tri.plane.normal, rOut.dir)); // projected area\n    float pdf = r2 / area; // 1/area, in case r2 is near zero it works better here\n    \n    return pdf;\n}\n\nvec3 sampleLight(tvHit Hit, out float pdf, out vec3 samPos)\n{\n    vec3 Out;\n    vec3 spos = vec3(0);\n    \n    //sample uniformly\n    //float pick = rnd();\n    //if(pick < 1.0 / 3.0)\n    //    Out = sampleLightSingular(Hit, pdf, Spheres[0].position, Spheres[0].radius);\n    //else if(pick < 2.0 / 3.0)\n    //    Out = sampleLightSingular(Hit, pdf, Spheres[3].position, Spheres[3].radius);\n    //else\n    //    Out = sampleTri(Hit, pdf, Tris[0]);\n    //pdf /= 3.0;\n    \n    //sample via a sample space\n    float samples[4];\n    float sample_sum = 0.0;\n    \n    int sn = 10; // 3\n    int mn = sn + 4;\n    \n    //surface area\n    samples[0] = 4.0 * 3.141592 * Spheres[0].radius * Spheres[0].radius;\n    samples[1] = 4.0 * 3.141592 * Spheres[3].radius * Spheres[3].radius;\n    samples[2] = 4.0 * 3.141592 * Spheres[sn].radius * Spheres[sn].radius;\n    samples[3] = length(cross(Tris[0].vertex[1]-Tris[0].vertex[0], Tris[0].vertex[2]-Tris[0].vertex[1]));\n    \n    //luminous flux (intensity * area)\n    sample_sum += samples[0] *= dot(vec3(1), Materials[4].emission);\n    sample_sum += samples[1] *= dot(vec3(1), Materials[7].emission);\n    sample_sum += samples[2] *= dot(vec3(1), Materials[mn].emission);\n    sample_sum += samples[3] *= dot(vec3(1), Materials[15].emission);\n    \n    float pick = rnd();\n    float samplespace = 0.0;\n    int i=0;\n    \n    for(i=0; i<4; ++i)\n    {\n        samplespace += samples[i] / sample_sum;\n        if(pick < samplespace)\n            break;\n    }\n    \n    if(i==0)\n        Out = sampleLightSingular(Hit, pdf, samPos, Spheres[0].position, Spheres[0].radius);\n    else if(i==1)\n        Out = sampleLightSingular(Hit, pdf, samPos, Spheres[3].position, Spheres[3].radius);\n    else if(i==2)\n        Out = sampleLightSingular(Hit, pdf, samPos, Spheres[sn].position, Spheres[sn].radius);\n    else\n        Out = sampleTri(Hit, pdf, samPos, Tris[0]);\n    \n    pdf *= samples[i] / sample_sum;\n    \n    Ray rOut = Hit.ray;\n    rOut.dir = Out;\n    \n    return Out;\n}\n\nvec3 sampleLight(tvHit Hit, out float pdf)\n{\n    vec3 samPos = vec3(0); // not needed here\n    return sampleLight(Hit, pdf, samPos);\n}\n\nfloat pdfLight(tvHit Hit, Ray rOut) // this should be below sampleLight when its done\n{\n    float pdf0 = pdfLightSingular(Hit, rOut, Spheres[0].position, Spheres[0].radius);\n    \n    //return pdf0;\n    //are multiple pdfs weighted averages, like in MIS?\n    \n    int sn = 10;\n    int mn = sn + 4;\n    \n    float pdf3 = pdfLightSingular(Hit, rOut, Spheres[3].position, Spheres[3].radius);\n    \n    float pdfn = pdfLightSingular(Hit, rOut, Spheres[sn].position, Spheres[sn].radius);\n    \n    //return (pdf0 + pdf3) / 2.0;\n    \n    float pdfT = pdfTri(Hit, rOut, Tris[0]);\n    \n    //sample uniformly\n    //return (pdf0 + pdf3 + pdfT) / 3.0;\n    \n    //sample via a sample space\n    float samples[4];\n    float sample_sum = 0.0;\n    \n    //surface area\n    samples[0] = 4.0 * 3.141592 * Spheres[0].radius * Spheres[0].radius;\n    samples[1] = 4.0 * 3.141592 * Spheres[3].radius * Spheres[3].radius;\n    samples[2] = 4.0 * 3.141592 * Spheres[sn].radius * Spheres[sn].radius;\n    samples[3] = length(cross(Tris[0].vertex[1]-Tris[0].vertex[0], Tris[0].vertex[2]-Tris[0].vertex[1]));\n    \n    //luminous flux (intensity * area)\n    sample_sum += samples[0] *= dot(vec3(1), Materials[4].emission);\n    sample_sum += samples[1] *= dot(vec3(1), Materials[7].emission);\n    sample_sum += samples[2] *= dot(vec3(1), Materials[mn].emission);\n    sample_sum += samples[3] *= dot(vec3(1), Materials[15].emission);\n    \n    float tpdf[4] = float[4](pdf0, pdf3, pdfn, pdfT);\n    float pdf = 0.0;\n    for(int i=0; i<4; ++i)\n        pdf += tpdf[i] * samples[i] / sample_sum;\n    \n    return pdf;\n    \n}\n\nvec3 sampleScatterUniform(tvHit Hit, out float pdf)\n{\n  \tpdf = 1.0;\n    vec3 rOut = randSphere();\n    \n    pdf /= 4.0 * 3.141592; // 4pi r^2, a sphere's area\n    \n    //pdf = bsdfUniform(Hit, ray);\n    \n    return rOut;\n}\n\nfloat pdfScatterUniform(tvHit Hit, Ray rOut)\n{\n    return 1.0 / (4.0 * 3.141592);\n}\n\nvec3 sampleScatterGeometric(tvHit Hit, out float pdf)\n{\n    Ray ray;\n    ray.dir = randScatterGeometric(Hit.normal);\n    \n    pdf = bsdfGeometric(Hit, ray);\n    \n    return ray.dir;\n}\n\nfloat pdfScatterGeometric(tvHit Hit, Ray rOut)\n{\n    return bsdfGeometric(Hit, rOut);\n}\n\nfloat sampleFogDistance(Ray rIn, out float fpdf)\n{\n    float absorbtion = Materials[1].albedo.x;\n    if(absorbtion == 0.0)\n    {\n        fpdf = 1.0;\n        return 1.0e31;\n    }\n    \n    float epsilon = rnd();\n    float x = -log(epsilon) / absorbtion;\n    \n    //find pdf\n    //fpdf = absorbtion * exp(-absorbtion * x); // epsilon\n    //fpdf = exp(-absorbtion * x); // epsilon\n    //fpdf = epsilon; // this absorbtion term vanishes somehow. \n    fpdf = absorbtion * epsilon; // Found it! This is because im using the integral, not the pdf in the bvtf.\n    return x;\n}\n\nfloat pdfFogDistance(float depth)\n{\n    float absorbtion = Materials[1].albedo.x;\n    if(absorbtion == 0.0)\n        return 0.0;\n    \n    return bvtfHomogenous(depth, 1.0);\n}\n\nfloat sampleFogEquiAngular(Ray rIn, out float fpdf)\n{ // egsr2012_volume.pdf\n    //pick a point on a light\n    tvHit Hit;\n    Hit.ray = rIn;\n    \n    float absorbtion = Materials[1].albedo.x;\n    if(absorbtion == 0.0)\n    {\n        fpdf = 1.0;\n        return 1.0e31;\n    }\n    \n    float lpdf = 1.0;\n    vec3 samPos = vec3(0);\n    vec3 lHit = sampleLight(Hit, lpdf, samPos);\n    \n    //find angle to sample pos\n    //find closest distance to sample\n    vec3 delta = samPos - rIn.src;\n    float mDelta = length(delta);\n    vec3 ndelta = delta / mDelta;\n    float x = dot(delta, rIn.dir);\n    float theta = acos(x / mDelta);\n    float D = mDelta * sin(theta);\n    float a = -(3.141592 / 2.0 - theta);\n    float b = 3.141592 / 2.0; // all fograys should go on forever\n    \n    //pick a point\n    float xi = rnd();\n    float t = xi*(b-a) + a;\n    float dist = D * tan(t); // move ray onto line\n    \n    delta = rIn.src + dist*rIn.dir;\n    \n    //find pdf\n    fpdf = D / (dot(delta, delta) * (b-a)); // this doesn't work?\n    //fpdf = (b-a) / (dot(delta, delta) * D); // but this one does?\n    //fpdf *= lpdf;\n    \n    return dist;\n    \n}\n\nfloat pdfFogEquiAngular(float depth)\n{\n    return 0.0; // oh god\n    // this needs the pdf to *all* lights along the entire path\n    // jesus christ\n}\n\nMaterial matTexture(tvHit Hit) // this function allows for material texturing\n{\n    Material mOut = Materials[Hit.id];\n    if(Hit.id == 0)\n    {\n        vec3 ldir = Hit.ray.dir;//rIn.dir;\n        ldir = vec3(ldir.x, ldir.z, -ldir.y);\n        mOut.emission = srgb2lsrgb(texture(iChannel1, ldir).xyz);\n        //mOut.emission = vec3(0.5,0.5,1) * 0.1;\n        //mOut.emission = vec3(0.0,0.0,0.0);\n        return mOut;\n    }\n    \n    if(Hit.id == 2)\n    {\n        mOut.albedo = srgb2lsrgb(texture(iChannel3, Hit.ray.src.xy).xyz);\n        return mOut;\n    }\n    \n    if(Hit.id == 3)\n    {\n        float p = 0.0;\n        vec2 xy = Hit.ray.src.xy;\n        vec2 ixy = xy - vec2(ivec2(xy + vec2(10000.0)) - ivec2(10000.0));\n        if(0.5 < ixy.x) p = 1.0 - p;\n        if(0.5 < ixy.y) p = 1.0 - p;\n        mOut.albedo = vec3((0.75-0.25)*p + 0.25);\n        //mOut.power = (10000.0-100.0)*(1.0-p) + 100.0;\n        return mOut;\n    }\n    \n    if(Hit.id == 15)\n    {\n        //vec3 c = srgb2lsrgb(texture(iChannel1, Hit.ray.dir).xyz);\n        //return mOut;\n        \n        vec2 coords;\n        pointInTri(Tris[0], Hit.ray.src, coords);\n        \n        vec3 c = srgb2lsrgb(texture(iChannel2, coords).xyz);\n        ///*\n        //hue-hue chroma key\n        vec3 c_hsv = rgb2hsv(c);\n        float adj = 0.8;\n        c_hsv.r += adj; if(1.0 < c_hsv.r) c_hsv.r -= 1.0;\n        if(c_hsv.r < 0.33) c_hsv.r += 0.33; // blue screen\n        c_hsv.r -= adj;\n        \n        c = hsv2rgb(c_hsv);\n        //*/\n        c *= dot(Materials[Hit.id].emission, vec3(1.0/3.0));\n        \n        mOut.emission = c;\n        return mOut;\n    }\n    \n    return mOut;\n}\n\nvec3 raytrace2(Ray rIn, vec3 normIn, int inid)\n{\n    tvHit Hit = traverse(rIn, normIn, inid);\n    \n    float fDist = Hit.rayDist;\n    float fpdf = 1.0;\n    \n    fDist = sampleFogDistance(rIn, fpdf);\n    //fDist = sampleFogEquiAngular(rIn, fpdf);\n    if(fDist < Hit.rayDist)\n    {\n        Hit.rayDist = fDist;\n        Hit.ray = rIn;\n        Hit.ray.src = rIn.src + rIn.dir * fDist;\n        Hit.normal = rIn.dir; // hit.normal isn't used in BSDFs, only in and out directions.\n        Hit.id = 1;\n    }\n    \n    /*\n    if(Hit.rayDist <= 0.0)\n    {\n        if(dot(rIn.dir, normIn) > 0.0)\n            return vec3(1,0.5,0);\n        return vec3(1,0,0);\n    }\n    */\n    /*\n    if(Hit.errRtrn > 0.0)\n        return vec3(1,0,1);\n    \n    if(Hit.rayDist < 0.0)\n        return vec3(1,0,0);\n    if(Hit.rayDist == 0.0 && Hit.id == 0)\n        return vec3(0,1,0);\n    if(Hit.rayDist > 1e10)\n        return vec3(0,0,1);\n    \n    return vec3(1) / log(Hit.rayDist + 1.0);\n    //return vec3(1) * max(0.0, dot(-rIn.dir, Hit.normal));\n    //return Hit.normal*0.5 + 0.5;\n    */\n    //vec3 refl = reflect(rIn.dir, Hit.normal);\n    //return refl*0.5 + 0.5;\n    //return srgb2lsrgb(texture(iChannel1, refl.xzy).xyz);\n    \n    vec3 Out = matTexture(Hit).emission;\n    \n    float transmission = bvtfHomogenous(fDist, fpdf);\n    Out *= transmission;\n    \n    //if(Hit.id == 0)\n    //    return Out;\n    \n    /*\n    if(Hit.id == 2)\n        Out = vec3(0,0,1);\n    \n    if(Hit.id == 3)\n        Out = vec3(0,1,0);\n    \n    if(Hit.id == 1)\n        Out = vec3(1,0,0);\n    */\n    return Out;\n}\n\nvec3 raytrace_fundamental(Ray rIn)\n{\n    tvHit Hit = traverse(rIn, rIn.dir, 0);\n    \n    Material Mat = matTexture(Hit);\n    vec3 Out = Mat.emission;\n    if(Hit.id == 0)\n        return Out;\n    \n    Ray rOut = Hit.ray;\n    float pdf = 1.0;\n    vec3 brdf = vec3(0);\n    \n    if(Hit.id == 1)// fog\n    {\n        rOut.dir = sampleScatterUniform(Hit, pdf);\n        brdf = vec3(1,1,0) * bsdfGeometric(Hit, rOut);\n        brdf+= vec3(0,0,1) * bsdfRayleigh(Hit, rOut);\n    }\n    else\n    {\n        rOut.dir = sampleSphere(Hit, pdf);\n        brdf = brdfPhong(Hit, rIn, rOut, Mat);\n    }\n    \n    vec3 rtrace = raytrace2(rOut, Hit.normal, Hit.id);\n    \n    pdf += 1e-10; // corrects for a division by zero error\n    \n    return Out + rtrace * brdf / pdf; \n}\n\nvec3 raytrace_fundamental_fog(Ray rIn)\n{\n    tvHit Hit = traverse(rIn, rIn.dir, 0);\n    \n    //fog, using tvFog in its current implementation, is a hardcoded importance sample for distance sampling.\n    //This is why the following code has the if statement, its a binary operation.\n    float fDist = Hit.rayDist;\n    float fpdf = 1.0;\n    \n    //fDist = sampleFogDistance(rIn, fpdf);\n    fDist = sampleFogEquiAngular(rIn, fpdf);\n    if(fDist < Hit.rayDist)\n    {\n        Hit.rayDist = fDist;\n        Hit.ray = rIn;\n        Hit.ray.src = rIn.src + rIn.dir * fDist;\n        Hit.normal = rIn.dir; // hit.normal isn't used in BSDFs, only in and out directions.\n        Hit.id = 1;\n    }\n    \n    float transmission = bvtfHomogenous(fDist, fpdf);\n    \n    Ray rOut = Hit.ray;\n    float pdf = 1.0;\n    vec3 brdf = vec3(0);\n    \n    Material Mat = matTexture(Hit);\n    vec3 Out = Mat.emission;\n    \n    if(Hit.id == 0)\n        return Out * transmission;\n\n    if(Hit.id == 1)// fog\n    {\n        //fpdf = 1.0;\n        rOut.dir = sampleScatterUniform(Hit, pdf);\n        brdf = vec3(1,1,0) * bsdfGeometric(Hit, rOut);\n        brdf+= vec3(0,0,1) * bsdfRayleigh(Hit, rOut);\n    }\n    else\n    {\n        //fpdf = 1.0;\n        rOut.dir = sampleSphere(Hit, pdf);\n        brdf = brdfPhong(Hit, rIn, rOut, Mat);\n    }\n\n    vec3 rtrace = raytrace2(rOut, Hit.normal, Hit.id);\n\n    //pdf *= fpdf;\n    pdf += 1e-10; // corrects for a division by zero error\n\n    Out += rtrace * brdf / pdf;\n    Out *= transmission;\n    \n    return Out; \n}\n\n\nvec3 raytrace_importance(Ray rIn)\n{\n    tvHit Hit = traverse(rIn, rIn.dir, 0);\n    \n    float fDist = Hit.rayDist;\n    float fpdf = 1.0;\n    \n    //fDist = sampleFogDistance(rIn, fpdf);\n    fDist = sampleFogEquiAngular(rIn, fpdf);\n    if(fDist < Hit.rayDist)\n    {\n    \n        float t = bvtfHomogenous(fDist, fpdf);\n        if(rnd() < t)\n        {\n            Hit.rayDist = fDist;\n            Hit.ray = rIn;\n            Hit.ray.src = rIn.src + rIn.dir * fDist;\n            Hit.normal = rIn.dir; // hit.normal isn't used in BSDFs, only in and out directions.\n            Hit.id = 1;\n        \n        }\n    }\n    \n    float transmission = bvtfHomogenous(fDist, fpdf);\n    \n    //return vec3(transmission);\n    \n    //return vec3(1) / Hit.rayDist;\n    //return vec3(1) * max(0.0, dot(-rIn.dir, Hit.normal));\n    //return Hit.normal*0.5 + 0.5;\n    \n    //vec3 refl = reflect(rIn.dir, Hit.normal);\n    //return srgb2lsrgb(texture(iChannel1, refl.xzy).xyz);\n    \n    Ray rOut = Hit.ray;\n    float pdf = 1.0;\n    \n    vec3 brdf = vec3(0);\n    \n    Material Mat = matTexture(Hit);\n    vec3 Out = Mat.emission;\n    \n    if(Hit.id == 0)\n        return Out * transmission;\n    \n    //rOut.dir = sampleSphere(Hit, pdf);\n    //rOut.dir = sampleLambert(Hit, pdf);\n    //rOut.dir = samplePhongSpec(Hit, pdf, rIn, Mat.power);\n    //rOut.dir = samplePhong(Hit, pdf, rIn, Mat);\n    //rOut.dir = sampleLight(Hit, pdf);\n    \n    if(Hit.id == 1)// fog\n    {\n        float pick = rnd();\n        pick = 1.0;\n        if(pick < 1.0 / 3.0) rOut.dir = sampleScatterUniform(Hit, pdf);\n        else if(pick < 2.0 / 3.0) rOut.dir = sampleScatterGeometric(Hit, pdf);\n        else rOut.dir = sampleLight(Hit, pdf);\n        brdf = vec3(1,1,0) * bsdfGeometric(Hit, rOut);\n        brdf+= vec3(0,0,1) * bsdfRayleigh(Hit, rOut);\n        //pdf *= 1.0-exp(-Hit.rayDist); // fog experiment\n    }\n    else\n    {\n        float pick = rnd();\n        pick = 1.0;\n        if(pick < 1.0 / 3.0) rOut.dir = sampleLambert(Hit, pdf);\n        else if(pick < 2.0 / 3.0) rOut.dir = samplePhongSpec(Hit, pdf, rIn, Mat.power);\n        else rOut.dir = sampleLight(Hit, pdf);\n        //pdf /= 3.0;\n\n        //float tpdf = pdfLight(Hit, rOut);\n        //pdf = tpdf;\n\n        //brdf = vec3(1) * brdfPhongSpecular(Hit, rIn, rOut, Mat.power);\n        //brdf *= Materials[Hit.id].reflectivity;\n        //brdf = vec3(1) * brdfLambert(Hit, rOut);\n        //brdf *= 1.0 - Materials[Hit.id].reflectivity;\n\n        brdf = brdfPhong(Hit, rIn, rOut, Mat);\n\n    }\n    \n    vec3 rtrace = raytrace2(rOut, Hit.normal, Hit.id);\n    \n    pdf += 1e-10; // corrects for a division by zero error\n       \n    // correct for pdf weirdness\n    if(pdf < 2e-10)\n    {\n        pdf = 1.0e31;\n    }\n    \n    Out += rtrace * brdf / pdf;\n    return Out * transmission;\n}\n\nconst int sa_BRDF = 4;\nconst int sa_BRDF_Spec = 4;\nconst int sa_Light = 4;\nconst int sa_Sphere = 4;\n\nvec3 raytrace_multiple_importance(Ray rIn)\n{\n    tvHit Hit = traverse(rIn, rIn.dir, 0);\n    \n    Material Mat = matTexture(Hit);\n    vec3 Out = Mat.emission;\n    if(Hit.id == 0)\n        return Out;\n    \n    Ray rOut = Hit.ray;\n    float pdf = 1.0;\n    \n    //MIS algo:\n    //collect samples from different sources\n    //for each dissimilar method, collect pdfs from each to find weighted pdf\n    //use wpdf instead for sum\n    \n    Ray rOutBRDF[sa_BRDF];\n    float pdfBRDF[sa_BRDF];\n    vec3 brdfBRDF[sa_BRDF];\n    vec3 rtBRDF[sa_BRDF];\n    \n    Ray rOutBRDF_Spec[sa_BRDF_Spec];\n    float pdfBRDF_Spec[sa_BRDF_Spec];\n    vec3 brdfBRDF_Spec[sa_BRDF_Spec];\n    vec3 rtBRDF_Spec[sa_BRDF_Spec];\n    \n    Ray rOutLight[sa_Light];\n    float pdf_Light[sa_Light];\n    vec3 brdfLight[sa_Light];\n    vec3 rtLight[sa_Light];\n    \n    // get samples for BRDF\n    for(int i=0; i<sa_BRDF; ++i)\n    {\n        rOutBRDF[i] = Hit.ray;\n        pdfBRDF[i] = 1.0;\n    \n        //rOutBRDF[i].dir = samplePhong(Hit, pdfBRDF[i], rIn, Mat);\n        rOutBRDF[i].dir = sampleLambert(Hit, pdfBRDF[i]);\n        brdfBRDF[i] = brdfPhong(Hit, rIn, rOutBRDF[i], Mat);\n        rtBRDF[i] = raytrace2(rOutBRDF[i], Hit.normal, Hit.id);\n    }\n    \n    // get samples for BRDF Specular\n    for(int i=0; i<sa_BRDF_Spec; ++i)\n    {\n        rOutBRDF_Spec[i] = Hit.ray;\n        pdfBRDF_Spec[i] = 1.0;\n    \n        rOutBRDF_Spec[i].dir = samplePhongSpec(Hit, pdfBRDF_Spec[i], rIn, Mat.power);\n        brdfBRDF_Spec[i] = brdfPhong(Hit, rIn, rOutBRDF_Spec[i], Mat);\n        rtBRDF_Spec[i] = raytrace2(rOutBRDF_Spec[i], Hit.normal, Hit.id);\n    }\n    \n    // get samples for Light\n    for(int i=0; i<sa_Light; ++i)\n    {\n        rOutLight[i] = Hit.ray;\n        pdf_Light[i] = 1.0;\n    \n        rOutLight[i].dir = sampleLight(Hit, pdf_Light[i]);\n        brdfLight[i] = brdfPhong(Hit, rIn, rOutLight[i], Mat);\n        rtLight[i] = raytrace2(rOutLight[i], Hit.normal, Hit.id);\n    }\n    \n    //accumulate MIS pass\n    vec3 MIS = vec3(0,0,0);\n    float sum_samples = float(sa_BRDF + sa_Light);\n    \n    //accumulate over BRDF\n    for(int i=0; i<sa_BRDF; ++i)\n    {\n        //find wpdf\n        float wpdf = 0.0;\n        \n        //this pdf was already precomputed\n        wpdf += float(sa_BRDF) * pdfBRDF[i];\n        \n        //compute other methods\n        wpdf += float(sa_BRDF_Spec) * pdfPhongSpec(Hit, rIn, rOutBRDF[i], Mat.power);\n        wpdf += float(sa_Light) * pdfLight(Hit, rOutBRDF[i]); // this right here is the problem\n        //wpdf += float(sa_Light) / (2.0 * 3.141592);\n        \n        wpdf += 1e-10; // corrects for a division by zero error\n        \n        // correct for pdf weirdness\n        if(wpdf < 2e-10)\n        {\n            wpdf = 1.0e31;\n        }\n        \n        //sample * brdf / weighted pdf\n        MIS += rtBRDF[i] * brdfBRDF[i] / wpdf;\n    }\n    \n    //accumulate over BRDF Specular\n    for(int i=0; i<sa_BRDF_Spec; ++i)\n    {\n        //find wpdf\n        float wpdf = 0.0;\n        \n        //this pdf was already precomputed\n        wpdf += float(sa_BRDF_Spec) * pdfBRDF_Spec[i];\n        \n        //compute other methods\n        wpdf += float(sa_BRDF) * pdfLambert(Hit, rOutBRDF_Spec[i]);\n        wpdf += float(sa_Light) * pdfLight(Hit, rOutBRDF_Spec[i]);\n        \n        wpdf += 1e-10; // corrects for a division by zero error\n        \n        // correct for pdf weirdness\n        if(wpdf < 2e-10)\n        {\n            wpdf = 1.0e31;\n        }\n        \n        //sample * brdf / weighted pdf\n        MIS += rtBRDF_Spec[i] * brdfBRDF_Spec[i] / wpdf;\n    }\n    \n    \n    //accumulate over Light\n    for(int i=0; i<sa_Light; ++i)\n    {\n        //find wpdf\n        float wpdf = 0.0;\n        \n        //this pdf was already precomputed\n        wpdf += float(sa_Light) * pdf_Light[i];\n        \n        //compute other methods\n        wpdf += float(sa_BRDF) * pdfLambert(Hit, rOutLight[i]);\n        wpdf += float(sa_BRDF_Spec) * pdfPhongSpec(Hit, rIn, rOutLight[i], Mat.power);\n        \n        wpdf += 1e-10; // corrects for a division by zero error\n        \n        // correct for pdf weirdness\n        if(wpdf < 2e-10)\n        {\n            wpdf = 1.0e31;\n        }\n        \n        //sample * brdf / weighted pdf\n        MIS += rtLight[i] * brdfLight[i] / wpdf;\n    }\n    \n    \n    return Out + MIS; \n}\n\nvec3 sample_MIS(tvHit Hit, Material Mat, out float pdf, int mode)\n{\n    Ray rOut = Hit.ray;\n    pdf = 1.0;\n    \n    //MIS one sample algo:\n    //same as MIS, but you randomly select the method, according to method space\n    \n    //build method space\n    const int methodCount = 4;\n    const float f_mC = float(methodCount);\n    float c_Sphere = 1.0 / 4.0;\n    float c_Lambert = 1.0 / 4.0;\n    float c_Specular = 1.0 / 4.0;\n    float c_Light = 1.0 / 4.0;\n    \n    float refl = dot(vec3(1), Mat.reflectivity) / 3.0;\n    \n    //bias toward more smooth samples, but still stick to 0 or 1 in edge cases\n    //refl = 2.0*refl - 1.0;\n    //refl *= refl*refl;\n    //refl = (refl + 1.0) / 2.0;\n    \n    c_Lambert = (1.0 - refl) * (2.0 / f_mC);\n    c_Specular = refl * (2.0 / f_mC);\n    \n    //c_Sphere =   0.5 / 3.0;\n    //c_Lambert =  0.5 / 3.0;\n    c_Sphere =   0.0 / 3.0;\n    c_Lambert =  1.0 / 3.0;\n    c_Specular = 1.0 / 3.0;\n    c_Light =    1.0 / 3.0;\n    \n    float methodSpace[methodCount];\n        methodSpace[0] = c_Sphere; methodSpace[1] = c_Lambert;\n        methodSpace[2] = c_Specular; methodSpace[3] = c_Light;\n    \n    //pick a method from methodspace\n    int c = 0;\n    float pick = rnd();\n    float methodSum = 0.0;\n    \n    if(mode < 0)\n    {\n        for(c=0; c<methodCount; ++c)\n        {\n            methodSum += methodSpace[c];\n            if(methodSum > pick)\n                break;\n        }\n    }\n    else\n    {\n        c = mode;\n        for(int i=0; i<methodCount; ++i)\n            methodSpace[c] = 1.0 / float(methodCount);\n    }\n    \n    //find a sample from the chosen method\n    if(c == 0)\n        rOut.dir = sampleSphere(Hit, pdf);\n    if(c == 1)\n        rOut.dir = sampleLambert(Hit, pdf);\n    else if(c == 2)\n        rOut.dir = samplePhongSpec(Hit, pdf, Hit.ray, Mat.power);\n    else //if(c == 3)\n        rOut.dir = sampleLight(Hit, pdf);\n    \n    \n    //Seperating the resulting samples, but still using weighted PDFs are useful for denoising, \n    //    while retaining MIS's variance reduction effects. Probably.\n    //if(rnd() < 0.5)\n    //rOut.dir = sampleLambert(Hit, pdf);\n    //else\n    //rOut.dir = sampleLight(Hit, pdf);\n    //rOut.dir = samplePhongSpec(Hit, pdf, Hit.ray, Materials[Hit.id].power);\n    \n    //fill wpdf using other methods\n    //sum(c * pdf(x)) / c\n    \n    //this pdf was already precomputed\n    pdf *= methodSpace[c]; \n    \n    for(int i=0; i<methodCount-1; ++i)\n    {\n        int j = (i+c+1) % methodCount; // skips the precomputed method\n        \n        if(j == 0)\n            pdf += methodSpace[j] * pdfSphere(Hit, rOut);\n        else if(j == 1)\n            pdf += methodSpace[j] * pdfLambert(Hit, rOut);\n        else if(j == 2)\n            pdf += methodSpace[j] * pdfPhongSpec(Hit, Hit.ray, rOut, Mat.power);\n        else //if(j == 3)\n            pdf += methodSpace[j] * pdfLight(Hit, rOut);\n    }\n    \n    //end of line\n    return rOut.dir;\n}\n\nvec3 sample_MIS(tvHit Hit, Material Mat, out float pdf)\n{\n    return sample_MIS(Hit, Mat, pdf, -1);\n}\n\nvec3 sample_fog_MIS(tvHit Hit, out float pdf)\n{\n    Ray rOut = Hit.ray;\n    pdf = 1.0;\n    \n    //MIS one sample algo:\n    //same as MIS, but you randomly select the method, according to method space\n    \n    //build method space\n    float c_Uniform = 1.0 / 3.0;\n    float c_Geometric = 1.0 / 3.0;\n    float c_Light = 1.0 / 3.0;\n    \n    float methodSpace[3]; methodSpace[0] = c_Uniform; methodSpace[1] = c_Geometric; methodSpace[2] = c_Light;\n    \n    //pick a method from methodspace\n    int c = 0;\n    float pick = rnd();\n    float methodSum = 0.0;\n    \n    for(c=0; c<3; ++c)\n    {\n        methodSum += methodSpace[c];\n        if(methodSum > pick)\n            break;\n    }\n    \n    //find a sample from the chosen method\n    if(c == 0)\n        rOut.dir = sampleScatterUniform(Hit, pdf);\n    else if(c == 1)\n        rOut.dir = sampleScatterGeometric(Hit, pdf);\n    else //if(c == 1)\n        rOut.dir = sampleLight(Hit, pdf);\n    \n    //this pdf was already precomputed\n    pdf *= methodSpace[c]; \n    \n    for(int i=0; i<3-1; ++i)\n    {\n        int j = (i+c+1) % 3; // skips the precomputed method\n        \n        if(j == 0)\n            pdf += methodSpace[j] * pdfScatterUniform(Hit, rOut);\n        else if(j == 1)\n            pdf += methodSpace[j] * pdfScatterGeometric(Hit, rOut);\n        else //if(j == 2)\n            pdf += methodSpace[j] * pdfLight(Hit, rOut); // use a special one for fog?\n    }\n    \n    //end of line\n    return rOut.dir;\n}\n\nfloat sample_fog_depth_MIS(Ray rIn, out float fpdf)\n{\n    float depth = 1.0e31;\n    fpdf = 1.0;\n    \n    //MIS one sample algo:\n    //same as MIS, but you randomly select the method, according to method space\n    \n    //build method space\n    float c_Depth = 1.0 / 2.0;\n    float c_EquiAngular = 1.0 / 2.0;\n    \n    float methodSpace[3]; methodSpace[0] = c_Depth; methodSpace[1] = c_EquiAngular;\n    \n    //pick a method from methodspace\n    int c = 0;\n    float pick = rnd();\n    float methodSum = 0.0;\n    \n    for(c=0; c<2; ++c)\n    {\n        methodSum += methodSpace[c];\n        if(methodSum > pick)\n            break;\n    }\n    \n    //find a sample from the chosen method\n    if(c == 0)\n        depth = sampleFogDistance(rIn, fpdf);\n    else // if(c == 1)\n        depth = sampleFogEquiAngular(rIn, fpdf);\n    \n    //this pdf was already precomputed\n    fpdf *= methodSpace[c]; \n    \n    for(int i=0; i<2-1; ++i)\n    {\n        int j = (i+c+1) % 2; // skips the precomputed method\n        \n        if(j == 0)\n            fpdf += methodSpace[j] * pdfFogDistance(depth);\n        else //if(j == 1)\n            fpdf += methodSpace[j] * pdfFogEquiAngular(depth);\n    }\n    \n    //end of line\n    return depth;\n}\n\nvec3 raytrace_MIS_sample(Ray rIn)\n{\n    tvHit Hit = traverse(rIn, rIn.dir, 0);\n    \n    float fDist = Hit.rayDist;\n    float fpdf = 1.0;\n    \n    //fDist = sampleFogDistance(rIn, fpdf);\n    //fDist = sampleFogEquiAngular(rIn, fpdf);\n    fDist = sample_fog_depth_MIS(rIn, fpdf);\n    if(fDist < Hit.rayDist)\n    {\n        float t = bvtfHomogenous(fDist, fpdf);\n        if(rnd() < t)\n        {\n            Hit.rayDist = fDist;\n            Hit.ray = rIn;\n            Hit.ray.src = rIn.src + rIn.dir * fDist;\n            Hit.normal = rIn.dir; // hit.normal isn't used in BSDFs, only in and out directions.\n            Hit.id = 1;\n        }\n    }\n    \n    float transmission = bvtfHomogenous(fDist, fpdf);\n    \n    Material Mat = matTexture(Hit);\n    vec3 Out = Mat.emission;\n    if(Hit.id == 0)\n        return Out * transmission;\n    \n    Ray rOut = Hit.ray;\n    float pdf = 1.0;\n    vec3 brdf = vec3(0);\n    \n    vec3 accum = vec3(0);\n    for(int i = 0; i<4; ++i) // deterministic mode, move some samples to specific methods\n    {\n    \n    if(Hit.id == 1)// fog\n    {\n        //rOut.dir = sampleScatterUniform(Hit, pdf);\n        //rOut.dir = sampleScatterGeometric(Hit, pdf);\n        rOut.dir = sample_fog_MIS(Hit, pdf);\n        brdf = vec3(1,1,0) * bsdfGeometric(Hit, rOut);\n        brdf+= vec3(0,0,1) * bsdfRayleigh(Hit, rOut);\n        //pdf *= 1.0-exp(-Hit.rayDist); // fog experiment\n    }\n    else\n    {\n        //rOut.dir = sampleSphere(Hit, pdf);\n        //rOut.dir = sample_MIS(Hit, Mat, pdf);\n        rOut.dir = sample_MIS(Hit, Mat, pdf, int(float(i)/1.0));\n        brdf = brdfPhong(Hit, rIn, rOut, Mat);\n        //pdf *= exp(-Hit.rayDist);\n    }\n    \n    vec3 rtrace = raytrace2(rOut, Hit.normal, Hit.id);\n    \n    pdf += 1e-10; // corrects for a division by zero error\n    \n    // correct for pdf weirdness\n    if(pdf < 2e-10)\n    {\n        pdf = 1.0e31;\n    }\n    \n    vec3 res = Out; // emission\n    res += rtrace * brdf / pdf;\n    res *= transmission;\n    \n    accum += res;\n    \n    //accum += rtrace * brdf / pdf;\n    \n    }\n    Out = accum / 4.0;\n    //Out += accum / 4.0;\n    //Out += rtrace * brdf / pdf;\n    \n    return Out;\n}\n\nvec3 Refract(vec3 rIn, vec3 normal, float eta)\n{\n    vec3 rOut = refract(rIn, normal, eta);\n    if(rOut == vec3(0))\n        return reflect(rIn, normal);\n    return rOut;\n}\n\nvec3 raytracePath(Ray rIn)\n{\n\t//raytracing with bounces, using a for loop instead of recusion\n    //const int maxBounces = 4;\n    const int maxBounces = 4;\n    int bounces = 0;\n        \n    vec3 emissive[maxBounces + 1];\n    vec3 brdf[maxBounces + 1];\n    \n    tvHit Hit;\n    Hit.id = 0;\n    Hit.normal = rIn.dir;\n    Ray ray = rIn;\n    \n    float ior = 1.0/1.33; // water\n    //float ior = 1.0/1.0003; // air\n    \n    for(bounces=0; bounces < maxBounces + 1; ++bounces)\n    {\n        Hit = traverse(ray, Hit.normal, Hit.id);\n        \n        emissive[bounces] = vec3(0,0,0);\n        \n        Material Mat = matTexture(Hit);\n        emissive[bounces] = Mat.emission;\n        if(Hit.id == 0)\n            break;\n        \n        //if(Hit.id == 3)\n        //    emissive[bounces] = vec3(0,1,0) / (0.25*0.25);\n        \n        Ray rold = ray;\n        ray = Hit.ray;\n        float pdf = 1.0;\n        /*\n        bool shiny = 0.5 < rnd();\n        float albedo = 1.0;\n        \n        if(Hit.id == 1 && !shiny)\n        \tif(sin(Hit.ray.src.x * 3.141592) * sin(Hit.ray.src.y * 3.141592) < 0.0)\n                albedo = 0.0;\n          \n        //if(Hit.id == 1 || shiny)//Hit.id == 2 || Hit.id == 3)\n       \tif(false && shiny && (Hit.id == 2 || Hit.id == 3))\n        {\n        \tpdf = 1.0 / (2.0 * 3.141592);\n            ray.dir = reflect(rold.dir, Hit.normal);\n        }\n        else\n        */\n        //if(bounces + 1 == maxBounces)\n       \t//\tray.dir = sampleLight(Hit, pdf);\n        //else\n        \n        if(Hit.id == 1)// fog\n        {\n            //rOut.dir = sampleScatterUniform(Hit, pdf);\n            //brdf = vec3(1,1,1) * bsdfUniform(Hit, rOut);\n            \n            //ray.dir = sampleScatterGeometric(Hit, pdf);\n            ray.dir = sample_fog_MIS(Hit, pdf);\n            //brdf[bounces] = vec3(1,1,1) * bsdfGeometric(Hit, ray);\n            //brdf[bounces] = vec3(1,1,1) * bsdfRayleigh(Hit, ray);\n            brdf[bounces] = vec3(1,1,0) * bsdfGeometric(Hit, ray);\n            brdf[bounces]+= vec3(0,0,1) * bsdfRayleigh(Hit, ray);\n        }\n        else if(4 <= Hit.id && Hit.id <= 14) // triangle\n        {\n            pdf = 1.0;\n            //ray.dir = reflect(ray.dir, Hit.normal);\n            ray.dir = Refract(ray.dir, Hit.normal, ior);\n            ior = 1.0 / ior;\n            //ray.dir = reflect(ray.dir, Hit.normal);\n            Hit.normal = -Hit.normal;\n            \n            brdf[bounces] = vec3(1);//brdfPhong(Hit, rold, ray, Mat);\n            \n        \n        }\n        else\n        {\n            //ray.dir = sampleLambert(Hit, pdf);\n        \t//ray.dir = samplePhong(Hit, pdf, rIn, Materials[Hit.id]);\n        \t//ray.dir = sampleLight(Hit, pdf);\n        \t//ray.dir = sampleMercator(Hit, pdf);\n        \t//ray.dir = sampleSphere(Hit, pdf);\n            ray.dir = sample_MIS(Hit, Mat, pdf);\n        \n        \t//brdf[bounces] = vec3(1,1,1) * brdfLambert(Hit, ray);\n        \tbrdf[bounces] = brdfPhong(Hit, rold, ray, Mat);\n        }\n        \n        if(pdf != pdf)\n            pdf = 1e-30;\n            \n        if(brdf[bounces] != brdf[bounces])\n            return vec3(1,0,0);\n        \n        if(1e-8 < pdf)\n            brdf[bounces] /= pdf;\n        else\n            brdf[bounces] = vec3(0,0,0);\n        \n        if(brdf[bounces] == vec3(0,0,0))\n            break;\n        \n        //brdf[bounces] = albedo;\n        \n    }\n    \n    //bounces--;\n    vec3 col = emissive[bounces];\n    bounces--;\n    \n    for(; 0<=bounces; --bounces)\n        col = emissive[bounces] + brdf[bounces] * col;\n        \n    return col;\n}\n\nvec3 raytrace(Ray rIn, vec2 fragCoord)\n{\n    //this function switches between different raytracing modes\n    \n    //if(fragCoord.x < 0.3333)// || 0.6666 < fragCoord.x) \n    //if(fragCoord.y < 0.3333)// || 0.6666 < fragCoord.x) \n        //return raytrace_fundamental(rIn);\n    //    return raytrace_importance(rIn);\n    /*if(0.6666 < fragCoord.x)\n        return raytraceLight(rIn);\n\t*/    \n\t\n    //return raytrace_fundamental(rIn);\n    //return raytrace_fundamental_fog(rIn);\n    //return raytrace_importance(rIn);\n    //return raytrace_multiple_importance(rIn); // use MIS sample below\n    return raytrace_MIS_sample(rIn);\n    //return raytracePath(rIn);\n}\n\nvoid initScene(in float rTime, in vec2 uv)\n{\n    \n    //rTime += (rnd() - 0.5) / 60.0; //const motion blur\n    rTime += (rnd() - 0.5) * iTimeDelta; // full frame adaptive motion blur\n    //rTime += (rnd() - 0.5) * iTimeDelta / 2.0; // half frame adaptive motion blur // this is how cameras work!\n\n    //setup materials\n    //sky\n    Materials[0].emission = vec3(0); // sky and fog only emit\n    \n    //fog\n    Materials[1].emission = vec3(0);\n    \n    //I'm not a fan of this formulation, I should redo it at some point\n    float f_n = 1000.0; //particle density\n    float f_r = 0.0005; //particle radius, 0.5mm\n    float f_c_vol = 1.0; //control volume, 1 cubic meter\n    \n    float f_crs_c_vol = pow(f_c_vol, 2.0 / 3.0); // v^(2/3)\n    float f_p_area = 3.141592 * f_r*f_r;\n    float f_denom = 1.0 - f_p_area / f_crs_c_vol;\n    float f_absorbtion = -log(f_denom) * f_n * f_crs_c_vol;\n    \n    //f_absorbtion *= 1000.0;\n    f_absorbtion *= 100.0;\n    //f_absorbtion *= (0.5 + 0.5*sin(iTime));\n    f_absorbtion = 0.0;\n    \n    //f_absorbtion *= 2000.0;\n    \n    //f_absorbtion *= 10.0;\n    \n    Materials[1].albedo = vec3(f_absorbtion); // repurpose\n    \n    ////////////\n    // planes //\n    ////////////\n    \n    //plane 0\n    Materials[2].emission     = vec3(0,0,0);\n    Materials[2].albedo       = vec3(1,1,1);\n    Materials[2].reflectivity = vec3(1,1,1) * 0.25;// * 4.0 * 0.99;\n    Materials[2].power        =               1000.0; // 1000.0;\n    //Materials[2].power        =               pow(10.0, sin(iTime / 5.0) + 3.0); // 1000.0;\n    //Materials[2].power        =               10000000.0; // 1000.0;\n    //Materials[2].power        =               10.0; // 1000.0;\n    //Materials[2].power        =               10000.0;\n    //Materials[2].power = 100.0;\n    \n    //Materials[2].power = 1000.0;\n    \n    for(int i=2+1; i<MatNum; ++i)\n        Materials[i] = Materials[2];\n    \n    //other plane\n    Materials[3] = Materials[2];\n    \n    //Materials[3].emission = vec3(1,1,1) * 10000.0;\n    \n    //setup planes\n    Planes[0].normal = vec3(0,0,1);\n    Planes[0].offset = dot(Planes[0].normal, vec3(0,0,-1.0));\n    Planes[1].normal = vec3(0,0,1);\n    Planes[1].offset = dot(Planes[1].normal, vec3(0,0, 1.75)); // fog -8.0+1.75\n    \n    /////////////\n    // spheres //\n    /////////////\n    \n    //large sphere\n    Materials[4] = Materials[2];\n    Materials[4].emission     = vec3(1,1,1) * 1.0;// / 100.0;\n    //Materials[4].power = 100000.0;\n    \n    //first sphere\n    Materials[5] = Materials[4];\n    Materials[5].emission     = vec3(0,1,0) * 100.0 * 0.0;\n    \n    //setup spheres\n    Spheres[0].radius = 1.0;//3.175 - 0.0;\n    Spheres[0].position = vec3(-1.0,3.0,0.0);\n    Spheres[1].radius = 0.25;\n    Spheres[1].position = vec3(1.0,3.0,-1.0 + Spheres[1].radius);\n    \n    //other spheres\n    float aTime = rTime + 4.1;\n    \n    for(int i=0; i<9; i++)\n    {\n        Spheres[2+i] = Spheres[1];\n        Materials[4+2+i] = Materials[5];\n        Spheres[2+i].position += vec3(0,i+1,0);\n        Spheres[2+i].position += vec3(2.0 * 0.3*float(i+1)*cos(aTime + float(i) / 2.0), 0.0, 0.0);\n    }\n    \n    Materials[7].emission = vec3(0,1,0) * 100.0;// / 1000.0;\n    //Materials[14].emission = vec3(1,1,1) * 10000.0;// / 1000.0;\n    //Spheres[3].position += vec3(2.0 * cos(iTime), 0.0, 0.0);\n    \n    float fTime = 0.0*rTime * 0.1 - 0.1;// + 3.141592;\n    \n    //Materials[14].emission = vec3(1,1,1) * 1000.0;//  10000.0;\n    \n    //Spheres[10].position.xy *= 2.0;\n    //Materials[14].emission *= 4.0 * 10.0;\n    \n    //Spheres[10].radius /= 5.0;\n    //Materials[14].emission *= 25.0;\n    //Spheres[10].position.z *= -1.0;\n    \n    mat2x2 fogrotate = mat2x2(vec2(cos(fTime), sin(fTime)), vec2(-sin(fTime), cos(fTime)));\n    //Spheres[10].position.xy = fogrotate * Spheres[10].position.xy;\n    \n    //////////\n    // tris //\n    //////////\n    \n    //setup tris\n    Materials[15] = Materials[2];\n    Materials[15].emission = vec3(0,0,1) * 10.0;// / 10.0;\n    //Materials[15].emission = vec3(1) * 100.0; // caustic scene\n    \n    //setup tris\n    float pTime = rTime;// + 4.1;\n    float speed = 1.0 * 0.25; //0.2;\n    float off = 0.33;\n    \n    pTime = off+speed*pTime;\n    \n    Tris[0].vertex[0] = vec3(3,4,1.0  + sin(pTime));\n    Tris[0].vertex[1] = vec3(1,5,1.0 + sin(pTime + 2.0*3.141592 / 3.0));\n    Tris[0].vertex[2] = vec3(4,7,1.0  + sin(pTime + 4.0*3.141592 / 3.0));\n    Tris[0].plane.normal = normalize(cross(Tris[0].vertex[1]-Tris[0].vertex[0], Tris[0].vertex[2]-Tris[0].vertex[0]));\n    Tris[0].plane.offset = dot(Tris[0].plane.normal, Tris[0].vertex[0]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //seed = fract(iTime) + iResolution.y * uv.x + uv.y;\n    //seed = iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n    seed = hashrandom(iTime + iResolution.y * uv.x + uv.y);\n    \n    float rTime = iTime;// + 14.61;// + 2.0;\n    //float rTime = iTime * 0.0 + 23.14;// + 2.0;\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(rnd(), rnd(), rnd());\n    \n    initScene(rTime, uv);\n    \n    //render\n    \n    float x = fragCoord.x / iResolution.x;\n    float y = fragCoord.y / iResolution.y;\n    \n    x = x * 2.0 - 1.0;\n    y = y * 2.0 - 1.0;\n    y *= iResolution.y / iResolution.x;\n    \n    Ray ray;\n    col = vec3(0,0,0);\n    const int samples = 4; // *4 mis subsamples\n    for(int smp=0; smp<samples; ++smp)\n    {\n        seed += 1.0;\n        float dx = 2.0 * rnd() - 1.0;\n        float dy = 2.0 * rnd() - 1.0;\n        \n        dx /= iResolution.x;\n        dy /= iResolution.x;\n        \n        //dx = 0.0;\n        //dy = 0.0;\n        \n        ray.src = vec3(0,0,0);\n        ray.dir = vec3(x + dx,1,y + dy);\n        float cTime = rTime / 5.0;\n        float cCos = cos(cTime);\n        float cSin = sin(cTime);\n        mat4x4 t1 = mat4x4(vec4(1,0,0,0),vec4(0,1,0,0),vec4(0,0,1,0),vec4(0,5,0,1));\n        mat4x4 t2 = mat4x4(vec4(1,0,0,0),vec4(0,1,0,0),vec4(0,0,1,0),vec4(0,-5,0,1));\n        mat4x4 rotate = mat4x4(vec4(cCos, cSin, 0,0), vec4(-cSin, cCos, 0,0), vec4(0,0,1,0), vec4(0,0,0,1));\n        rotate = t1 * rotate * t2;\n        ray.src = (rotate * vec4(ray.src, 1.0)).xyz;\n        ray.dir = (rotate * vec4(ray.dir, 0.0)).xyz;\n        \n        ray.dir = normalize(ray.dir);\n        //ray.dir /= sqrt(dot(ray.dir, ray.dir));\n\n        vec3 clr = raytrace(ray, fragCoord / iResolution.xy);\n        col += clr / float(samples);\n    }\n    \n    //convert color space from lsrgb to srgb\n    //good enough\n    //col = sqrt(col);\n    \n    // Output to screen\n    \n    vec3 colacc = col;\n    \n    bool progressiveRendering = false;\n    vec4 tprev = texture(iChannel0, fragCoord/iResolution.xy);\n    int iFrameStart = int(tprev.w);\n    if(0.5 < iMouse.z)\n    {\n        iFrameStart = iFrame;\n     \tcolacc = col;   \n    }\n    if(progressiveRendering)\n    {\n        float spp1 = float(iFrame - iFrameStart);\n        float spp2 = float(iFrame - iFrameStart + 1);\n        vec3 colprev = tprev.xyz;\n        colacc = (col / spp2) + (colprev * (spp1/spp2));\n    }\n    \n    fragColor = vec4(colacc,float(iFrameStart)); // store start frame in alpha channel\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n//color space transforms\nfloat lsrgb2srgb(float lsrgb)\n{\n    if(lsrgb < 0.0031308)\n        return lsrgb * 12.92;\n    float a = 1.055;\n    return a * pow(lsrgb, 1.0/2.4) - (a - 1.0);\n}\n\nvec3 lsrgb2srgb(vec3 lsrgb)\n{\n    return vec3(lsrgb2srgb(lsrgb.x),lsrgb2srgb(lsrgb.y),lsrgb2srgb(lsrgb.z));\n}\n\nfloat srgb2lsrgb(float srgb)\n{\n    if(srgb < 0.04045)\n        return srgb / 12.92;\n    float a = 1.055;\n    return pow(1.0 + (srgb - 1.0) / a, 2.4);\n}\n\nvec3 srgb2lsrgb(vec3 srgb)\n{\n    return vec3(srgb2lsrgb(srgb.x),srgb2lsrgb(srgb.y),srgb2lsrgb(srgb.z));\n}\n\n//https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(vec3 rgb)\n{\n\tvec4 k = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, k.wz), vec4(rgb.gb, k.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n    \n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    \n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 hsv)\n{\n\tvec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(hsv.xxx + k.xyz) * 6.0 - k.www);\n    return hsv.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), hsv.y);    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}