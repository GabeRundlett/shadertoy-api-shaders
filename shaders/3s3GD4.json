{
    "Shader": {
        "info": {
            "date": "1569033546",
            "description": "ray marching test2",
            "flags": 32,
            "hasliked": 0,
            "id": "3s3GD4",
            "likes": 3,
            "name": "ray marching test2",
            "published": 3,
            "tags": [
                "ray"
            ],
            "usePreview": 0,
            "username": "1337_shader",
            "viewed": 236
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord/iResolution.xy);\n \nvec4 tot = texture(iChannel0,uv);\n\tfragColor = vec4( tot );\t\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_STEPS 100.\n#define AA 1\n#define MAX_DIST 100.\n#define SURF_DIST 0.001\n#define pi 3.14159\n#define ieTime 5.*(iTime/(iTime*iTime)*iTime*(iTime*0.05))\n#define mouse vec2(iMouse.xy/iResolution.xy) \n\n\n\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n\n\n\n\n\n\nvec4 orb;\n\n\n\n\n\n\n\nfloat GetDist(in vec3 pos ) {\n     \n    vec3 p = pos;\n     \n    vec3 ph = p;\n///ph.xy += (iTime);\n    \n  float s = 1.7;\n     float scale = 1.;\n      orb = vec4(1000.);\n    float r2;\n    int i;\n\n  p = (ph);\n     \n        for(  i =0; i < 10; i++)\n        {\n      \n            p = 1. - 2.*fract(0.5*p+0.5);\n            p = (p);\n            \n           \n             r2 = dot(p,p);\n\n            orb = min( orb, vec4(abs(p),r2) );\n            \n            float k = s/r2;\n            p *= k;\n        \n            scale = (scale*k);\n        }\n  p = (abs(p)/scale);\n\treturn ( (0.25*length(p) ))-0.0002 ;\n  \n\n    //return length(pos)-2.;\n    \n\n}  \n    \n\n\n\n\n\n\n\n\n\n\nfloat iter;\n\n\n\nfloat RayMarch(in vec3 ro, in vec3 rd) {\n  float dO=0.;\n    orb = vec4(1000.);\n    float co;\n    float dmax= 30.;\n\n   \n    float h;\n    float dS;\n    vec4 orb;\n    for( iter=0.; iter<float(MAX_STEPS); iter++) {\n        vec3 p = ro + rd*dO;\n         dS = GetDist(p);\n        dO += dS;\n        if(dO>=MAX_DIST || dS<=SURF_DIST)  break;\n\n    }\n\n    if( dO>dmax ) dO = -1.;\n  \n    \n    return dO;\n}\n\n\n\nvec3 GetNormal(vec3 p, float d) {\n     vec4 tmp;\n   \n   float precis = 0.001 * d;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*GetDist( p + e.xyy ) + \n\t\t\t\t\t  e.yyx*GetDist( p + e.yyx ) + \n\t\t\t\t\t  e.yxy*GetDist( p + e.yxy ) + \n                      e.xxx*GetDist( p + e.xxx) );\n   \n}\n\n\nfloat softshadow(  vec3 ro,  vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        vec4 kk;\n        float h = GetDist(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y));\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 getcol (vec3 p , vec3 n, float d, vec3 rd,vec4 tra)\n{\n    \n\n      \n       vec3 col;\n\n   \n\n        \n   float time = iTime*100.;\n  \n        \n  vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n      float key = clamp( dot( light1, n ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, n ), 0.0, 1.0 );\n   \n   //float ce  = dot(rd,lp2);\n    \n    \n float sha1 = softshadow( p+0.001*n, light1,0.01,20., 32.0 );\n   // float sha2 = softshadow( pn+0.01*pr, light1,0.01,20., 32.0 );\nkey *= sha1;\n  // ce *=sha2;\n    \n  col = vec3(1.0);\n    \n     col = mix( col, vec3(1.0,0.80,0.2), clamp(2.*sin(tra.y*6.),0.0,1.0) );\n        col = mix( col, vec3(1.0,0.55,0.0), pow(clamp(1.0-2.0*tra.z,0.0,1.0),8.0) );\n\n \n float amb = (0.7+0.3*dot(n,n));\n   float ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\n       \n  \n    \n        vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n     brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n    brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n vec3 hal = normalize(light1-rd);\n    float spec1 =   pow( clamp(dot(n,hal),0.0,1.0), 10. )*key*(0.04+0.96*pow(clamp(1.0-dot(hal,light1),0.0,1.0),5.0)); \n\t\n       \n       col =  ((col*brdf*exp(-0.2*d)));\n     return col;\n}\n\nvec3 render(vec3 ro,vec3 rd, vec3 b)\n{\n  \nvec3 sky;\n\n  \n   float d = RayMarch(ro, rd);\n       vec3 p = ro + rd * d;\n \n vec4 tra = orb;; \n        \n\n\n    \n    vec3 n = GetNormal(p, d);\n    vec3 col = getcol(p,n,d,rd,tra);\n    \n      \tvec3 rfd = normalize(reflect(rd,n));\n\t\tvec3 sp =  p+rfd*0.1;\n\t\t\n    \n    float fre = clamp(1.7+dot(n,rd),0.,1.);\n   /* float se = (RayMarch(sp,rfd));\n    vec4 tra2 = orb;\n    float s2 = se;\n  \tvec3 pr = sp+rfd*s2;\n    vec3 pn = GetNormal(pr,s2);\n    */\n    vec3 ce = getcol(p,n,d,rd,tra);\n    \n   // vec3 co = getcol (pn,pr,s2,rfd,tra2)/200.;\n    \n    //co = 1.-1./(co);\n   // ce = mix(co,ce,fre);\n//col = mix(col,vec3(ce),d/100.);\n\n   \n  return sqrt(ce);\n\n      \n   \n   \n    \n \n        }\n\n    \n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n \n   float time = ieTime/(ieTime/50.);\n    \n     \n  vec3 ro = vec3( 2.8*sin(0.1+.33*time), 0.4 + 0.30*sin(0.37*iTime), 2.8*cos(0.5+0.35*time) );\n      \n ro.x *= ieTime*5.;\n\n\n\n    \n    ro.x += sin(time);\n    ro.z += cos(time);\n    ro.x\n        += iTime;\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n vec3 rd2 = rd;\n \n\n  \n   rd.xz *= Rot(iTime/10.);\n   rd .xz *=Rot(iTime/5.);\n    rd.yx *= Rot(mix(cos(ieTime/10.)*0.3,sin(ieTime/10.)*pi*2., sin(ieTime/time*50.)));\n     rd.yz *= Rot(mix(cos(ieTime/10.)*0.3,sin(ieTime/10.)*pi*2., sin(ieTime/time*50.)));\n   vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = AA, jj = AA;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n       \n      \n\n        tot += render( ro, rd , rd2);\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}