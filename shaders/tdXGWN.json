{
    "Shader": {
        "info": {
            "date": "1546245415",
            "description": "Camera animation experiment with fbm function.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdXGWN",
            "likes": 0,
            "name": "Camera animation test with Fbm",
            "published": 3,
            "tags": [
                "camera"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 439
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define degToRad (PI * 2.0) / 360.0\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nmat3 matRotateX(float rad)\n{\n    return mat3(1,       0,        0,\n                0,cos(rad),-sin(rad),\n                0,sin(rad), cos(rad));\n}\n\nmat3 matRotateY(float rad)\n{\n    return mat3(cos(rad), 0, -sin(rad),\n\t\t\t\t\t0, 1, 0,\n\t\t\t\t\tsin(rad), 0, cos(rad));\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) return val1;\n    return val2;\n}\n\nvec4 map(vec3 p){\n    float speed = iTime*3.0;\n    p.z += speed;\n    vec3 prevP = p;\n    \n    p.z = mod(p.z,3.0)-1.5;\n    p.y += 0.5;\n    float h = 0.15-sin(iTime)*0.15;\n    vec3 q = p - clamp( p, -h, h );\n    float d = length(q)-0.15;\n\n    vec4 res = combine(vec4(vec3(0.3,0.3,0.3),d),vec4(vec3(0.98,0.98,0.98),prevP.y+3.0));\n    \n    return res;\n}\n\nvec3 normalMap(vec3 p){\n\tfloat d = 0.0001;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n\t\tmap(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n\t\tmap(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n\t));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n\tfloat h = 0.0;\n\tfloat c = 0.001;\n\tfloat r = 1.0;\n\tfloat shadow = 0.5;\n\tfor(float t = 0.0; t < 30.0; t++){\n\t\th = map(ro + rd * c).w;\n\t\tif(h < 0.001){\n\t\t\treturn shadow;\n\t\t}\n\t\tr = min(r, h * 16.0 / c);\n\t\tc += h;\n\t}\n\treturn 1.0 - shadow + r * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float time = mod(iTime,20.0);\n    \n    float deg = 0.0;\n    if(time<=12.0){\n        deg = time/12.0*360.0;\n    }\n    \n    float handShakeY = fbm(vec3(iTime,iTime*1.1,iTime*1.2))*10.0;\n    float handShakeX = fbm(vec3(iTime*1.1,iTime*1.2,iTime))*12.0;\n\tmat3 camRotY = matRotateY((sin(iTime)*10.0+handShakeY)*degToRad+(deg*degToRad))*matRotateX((10.+handShakeX)*degToRad);\n    \n\tvec3 ro=vec3(0.,-.1,-8.);\n    vec3 rd=normalize(vec3(p,1.8));\n\t\n    float t, dist;\n\tt = 0.0;\n\tvec3 distPos = vec3(0.0);\n\tvec4 distCl = vec4(0.0);\n\tfor(int i = 0; i < 60; i++){\n\t\tdistCl = map(distPos);\n\t\tdist = distCl.w;\n\t\tif(dist < 1e-4){break;}\n        if(t>13.)break;\n\t\tt += dist;\n\t\tdistPos = (ro+rd*t)*camRotY;\n\t}\n\n\tvec3 color;\n\tfloat shadow = 1.0;\n\t\n\tif(t < 13.){\n\t\t// lighting\n\t\tvec3 lightDir = vec3(1.0, 10.0, 1.0);\n\t\tvec3 light = normalize(lightDir);\n\t\tvec3 normal = normalMap(distPos);\n\n\t\t// difuse color\n\t\tfloat diffuse = clamp(dot(light, normal), 1.0, 1.0);\n\t\tfloat lambert = max(.0, dot( normal, light));\n\t\t\n\t\t// shadow\n\t\tshadow = shadowMap(distPos + normal * 0.001, light);\n\n\t\t// result\n\t\tcolor += vec3(lambert);\n\t\tcolor = diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n\t}else{\n        color =.84*max(mix(vec3(1.1,1.31,1.35)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n\t}\n\n\t// rendering result\n\tfloat brightness = 1.0;\n\tvec3 dst = (color * max(0.5, shadow))*brightness;\n\tfragColor = vec4(dst, 1.0);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}