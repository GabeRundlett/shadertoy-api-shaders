{
    "Shader": {
        "info": {
            "date": "1597254144",
            "description": "Source Link : https://www.youtube.com/watch?v=tdwXMtnuuXg\nMy Onet Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect",
            "flags": 0,
            "hasliked": 0,
            "id": "3tXfRX",
            "likes": 2,
            "name": "11. Drive Home 2 - Street Lights",
            "published": 3,
            "tags": [
                "drivehome"
            ],
            "usePreview": 0,
            "username": "altera0",
            "viewed": 285
        },
        "renderpass": [
            {
                "code": "\n#define S( a , b , t ) smoothstep( a , b , t )\n\nstruct Ray {\n\tvec3 ro;\t\t// Ray Origin\n    vec3 rd;\t\t// Ray Direction\n};\n\n// RAY\nRay GetRay( vec2 uv , vec3 camPos , float camZoom , vec3 lookAt ) {\n \n    Ray ray;\n     \n    ray.ro = camPos;\n    \n    vec3 F = normalize( lookAt - camPos );\n    vec3 R = normalize( cross( vec3( 0 , 1 , 0 ) , F ) );\n    vec3 U = cross( F , R );\n    \n    vec3 center  = camPos + F * camZoom;\n    vec3 intersectionPoint = center + uv.x * R  + uv.y * U;\n    \n    // rd have to do normalized.\n    // because where GetClosestPoint() , dot ( target - ro , rd ) * rd.\n    ray.rd = normalize( intersectionPoint - camPos );\n    \n    return ray;\n}\n\n\n// \nvec3 GetClosestPoint( Ray ray , vec3 targetPos ) {\n   \n    // 이때 반드시, rd가 노멀라이즈 되어 있어야,\n    // dot( targetPos - ray.ro , ray.rd )가 정확하게 계산이 된다.\n    return ray.ro + max( 0.0f , dot( targetPos - ray.ro , ray.rd ) ) * ray.rd;\n}\n\n\n// \nfloat GetDistance( Ray ray , vec3 targetPos ) {\n\tfloat d = length( targetPos - GetClosestPoint( ray , targetPos ) );\n    return d;\n}\n\n\n// BOKE\nfloat Boke( float d , float lightDiameter , float blur ) {\n\t\n      \n\tfloat c = S( lightDiameter , lightDiameter * ( 1.0f - blur ) , d );\n    c *= mix( 0.7f , 1.0f , S( lightDiameter * 0.8f , lightDiameter , d ) );\n    return c;\n}\n\nfloat Noise(float t) {\n    float n;\n\n    n = sin( t + 2379. ) ;\n    \n    return n;\n}\n\n// Street Light\nfloat StreetLight( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n    float c = 0.0f;\n    \n    float t = time * 0.1f;\n    float s = 1.0f / 10.0f; // in 1 sec, 100 count.\n    float side = step( ray.rd.x , 0.0f );\n    ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t\n        float ti = fract(t + i + side * s * 0.5f );\n        vec3 targetPos = vec3( 2.0f , 2.0f , 100.0f - ti * 100.0f );\n    \tfloat d = GetDistance( ray , targetPos );\n    \t\n        //lightDiameter *= length( targetPos );\n\n        float expandLight = lightDiameter * length( targetPos );\n        c += Boke( d , expandLight , bokeBlur ) * ti * ti * ti;\n    }\n    \n    return c;\n}\n\n// MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5f * iResolution.xy) / min( iResolution.x, iResolution.y);\n    \n\n\tvec3 camPos = vec3( 0 , 0.2f , 0.0f );\n    vec3 lookAt = vec3( 0 , 0.2f , 1.0f );\n    float camZoom = 2.0f;\n    \n    \n    float lightDiameter = 0.05f;\n    float bokeBlur = 0.1f;\n    \n    \n    Ray ray = GetRay( uv , camPos , camZoom , lookAt );\n\n\tfloat c = StreetLight( ray , lightDiameter , bokeBlur, iTime );\n    \n    \n    \n    vec3 col = vec3( 1.0f , 0.7f , 0.3f) * c;\n    fragColor = vec4( col ,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}