{
    "Shader": {
        "info": {
            "date": "1692651978",
            "description": "What if we used square waves instead of (co)sine waves in Fourier transforms?\nSee sqsin() and sqcos() at the end of Common.\n\n- Enable fft_preview_input in the Common tab to see the input shapes.\n\n- You can also change the resolution in the Common tab.",
            "flags": 32,
            "hasliked": 0,
            "id": "DlfBzN",
            "likes": 5,
            "name": "Square Fourier Transform?",
            "published": 3,
            "tags": [
                "2d",
                "fft",
                "experiment",
                "square",
                "fourier"
            ],
            "usePreview": 0,
            "username": "beans_please",
            "viewed": 161
        },
        "renderpass": [
            {
                "code": "/* -----------------------------------------------\n  Shadertoy Unit: Image\n  Description: None\n  iChannel0: Buffer A\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nvec2 screen_to_uv(vec2 coord)\n{\n    return (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvec3 view_transform(vec3 col)\n{\n\t// OETF (Gamma)\n    return pow(col, vec3(1.0 / 2.5));\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // UV\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Render\n    vec3 col = vec3(0.0);\n    if (max(abs(uv.x), abs(uv.y)) < 1.0)\n    {\n        col = texture(iChannel0, vec2(uv * 0.5 + 0.5) * vec2(fft_res) / iResolution.xy).rgb;\n        \n        vec3 tint = rgb_sweep(iTime * 0.14) + 0.03;\n        tint /= dot(tint, vec3(0.3, 0.59, 0.12));\n        col *= tint;\n    }\n    else\n    {\n        col = vec3(0);\n        //col = vec3(0.005, 0.01, 0.02);\n    }\n    \n    // Output\n    col = view_transform(col);\n    frag_col = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/* -----------------------------------------------\n  Shadertoy Unit: Common\n----------------------------------------------- */\n\nconst ivec2 fft_res = ivec2(150);\nconst bool fft_preview_input = bool(0);\nconst float fft_mul = 50.0 / float(fft_res.x * fft_res.y);\n\n\n\n// -----------------------------------------------\n// What to define\n// -----------------------------------------------\n\n/* Math Utils */\n#define MATH_UTILS 1\n\n/* Pseudo-Random Number Generator */\n#define PRNG 0\n\n/* Color Utils (requires MATH_UTILS) */\n#define COLOR_UTILS 1\n\n/* Keyboard Utils */\n#define KEYBOARD_UTILS 0\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Math Utils\n// -----------------------------------------------\n\n#if MATH_UTILS\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n#define DEG_TO_RAD 0.01745329251994329576923690768\n#define RAD_TO_DEG 57.2957795130823208767981548141\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_MAP_RANGE(T) \\\nT map_range(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_MAP_RANGE_CLAMP(T) \\\nT map_range_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_MAP_RANGE(float)\nFUNC_MAP_RANGE(vec2)\nFUNC_MAP_RANGE(vec3)\nFUNC_MAP_RANGE(vec4)\n\nFUNC_MAP_RANGE_CLAMP(float)\nFUNC_MAP_RANGE_CLAMP(vec2)\nFUNC_MAP_RANGE_CLAMP(vec3)\nFUNC_MAP_RANGE_CLAMP(vec4)\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Pseudo-Random Number Generator\n// Source: https://www.shadertoy.com/view/WdSSRt\n// -----------------------------------------------\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\n#if PRNG\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return float(result) / float(0xffffffffu);\n}\n\nvoid prng_init(vec3 seed)\n{\n    seed.xy *= (seed.z + 10.258);\n    seed += 3.49276101561702;\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    random();\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Color Utils (requires MATH_UTILS)\n// -----------------------------------------------\n\n#if COLOR_UTILS\n\nconst vec3 lum_linear_bt709 = vec3(0.2126, 0.7152, 0.0722);\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), map_range_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), map_range_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), map_range_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), map_range_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), map_range_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), map_range_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\nfloat rgb_variance(vec3 a, vec3 b)\n{\n    a = max(a, 0.0);\n    b = max(b, 0.0);\n    \n    a += 0.001;\n    b += 0.001;\n    \n    float v = dot(abs(log2(a / b)), vec3(0.3, 0.59, 0.11));\n    return v*v;\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Keyboard Utils\n// -----------------------------------------------\n\n#if KEYBOARD_UTILS\n\n#define KEY_BACKSPACE 8\n#define KEY_TAB 9\n#define KEY_ENTER 13\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_PAUSE_BREAK 19\n#define KEY_CAPS_LOCK 20\n#define KEY_ESC 27\n#define KEY_SPACE 32\n#define KEY_PAGE_UP 33\n#define KEY_PAGE_DOWN 34\n#define KEY_END 35\n#define KEY_HOME 36\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_PRINT_SCREEN 44\n#define KEY_INSERT 45\n#define KEY_DELETE 46\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_LWIN 91\n#define KEY_RWIN 92\n#define KEY_POPUP 93\n#define KEY_NUMPAD_0 96\n#define KEY_NUMPAD_1 97\n#define KEY_NUMPAD_2 98\n#define KEY_NUMPAD_3 99\n#define KEY_NUMPAD_4 100\n#define KEY_NUMPAD_5 101\n#define KEY_NUMPAD_6 102\n#define KEY_NUMPAD_7 103\n#define KEY_NUMPAD_8 104\n#define KEY_NUMPAD_9 105\n#define KEY_NUMPAD_ASTERISK 106 \n#define KEY_NUMPAD_PLUS 107\n#define KEY_NUMPAD_MINUS 109\n#define KEY_NUMPAD_PERIOD 110\n#define KEY_NUMPAD_SLASH 111\n#define KEY_F1 112\n#define KEY_F2 113\n#define KEY_F3 114\n#define KEY_F4 115\n#define KEY_F5 116\n#define KEY_F6 117\n#define KEY_F7 118\n#define KEY_F8 119\n#define KEY_F9 120\n#define KEY_F10 121\n#define KEY_F11 122\n#define KEY_F12 123\n#define KEY_NUM_LOCK 144\n#define KEY_SCROLL_LOCK 145\n#define KEY_LSHIFT 160\n#define KEY_RSHIFT 161\n#define KEY_LCTRL 162\n#define KEY_RCTRL 163\n\nbool key_is_down(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 0), 0).x != 0.0;\n}\n\nbool key_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 1), 0).x != 0.0;\n}\n\nbool key_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 2), 0).x != 0.0;\n}\n\nfloat fkey_is_down(int key, sampler2D keyboard_channel)\n{\n    return key_is_down(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return key_got_pressed(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return key_toggle_state(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// Just linear mapping\nfloat not_so_smoothstep(float e0, float e1, float x)\n{\n    return clamp((x - e0) / (e1 - e0), 0.0, 1.0);\n}\n\n// 1D slit function\nfloat slit(float x, float center, float half_width, float fade_width)\n{\n    return not_so_smoothstep(-half_width - fade_width, -half_width, x - center)\n        * not_so_smoothstep(half_width + fade_width, half_width, x - center);\n}\n\n// Regular polygon\n// Source: https://www.shadertoy.com/view/tdsXz8\nfloat sd_npoly(float n, float radius, float rotation, vec2 p)\n{\n    n *= .5;\n    float o = PI_OVER_2 / n;\n    float a = atan(p.y / p.x);\n    if(p.x < 0.)\n        a += PI;\n    float s = round((a + rotation) / PI * n) / n * PI - rotation;\n    float d = round((a + o + rotation) / PI * n) / n * PI - o - rotation;\n    vec2 c = vec2(cos(d), sin(d)) * radius;\n    vec2 f = vec2(cos(s), sin(s));\n    float b = length(p - c);\n    float l = dot(p, f);\n    l -= cos(o) * radius;\n    float m = b;\n    if(abs(dot(vec2(p.x, -p.y), f.yx)) <= sin(o) * radius)\n        m = l;\n    return m;\n}\n\nfloat sqsin(float x)\n{\n    return mod(x / TAU, 1.) < .5 ? 1. : -1.;\n}\n\nfloat sqcos(float x)\n{\n    return mod((x / TAU) + .25, 1.) < .5 ? 1. : -1.;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/* -----------------------------------------------\n  Shadertoy Unit: Buffer A\n  Description: FFT is performed in this buffer.\n  iChannel0: None\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nfloat shape0_radius;\nfloat shape1_slit1_half_width;\nfloat shape1_slit2_center;\nfloat shape1_slit2_fade;\nfloat shape1_cutout_radius;\n\nfloat fft_input(vec2 uv)\n{\n    int shape = int(floor(0.34 * iTime)) % 3;\n    if (shape == 0)\n    {\n        // Circle\n        return not_so_smoothstep(shape0_radius, shape0_radius - 0.02, distance(uv, vec2(0.5, 0.5)));\n    }\n    else if (shape == 1)\n    {\n        // Double slit\n        float v = slit(uv.x, 0.44, shape1_slit1_half_width, 0.004);\n        v += slit(uv.x, shape1_slit2_center, 0.02, shape1_slit2_fade);\n        v *= slit(uv.y, 0.5, 0.25, 0.004);\n        float d = distance(uv, vec2(0.5, 0.5));\n        v *= not_so_smoothstep(shape1_cutout_radius, shape1_cutout_radius - 0.01, d);\n        v *= not_so_smoothstep(0.3, 0.01, d) * 0.5 + 0.5;\n        return v;\n    }\n    else if (shape == 2)\n    {\n        // Pentagon\n        return not_so_smoothstep(0.01, 0.0, sd_npoly(5.0, 0.15, iTime * 0.25, uv - 0.5));\n    }\n    return 0.0;\n}\n\n// How much of this frequency is present in fft_input?\nvec2 freq_amount(ivec2 freq)\n{\n    const vec2 uv00 = 0.5 / vec2(fft_res);\n    const vec2 uv_step = 1.0 / vec2(fft_res);\n    vec2 f2 = vec2(freq) * TAU;\n    vec2 v = vec2(0.0);\n    float a = 0.0;\n    for (float y = uv00.y; y < 1.0; y += uv_step.y)\n    {\n        for (float x = uv00.x; x < 1.0; x += uv_step.x)\n        {\n            a = dot(vec2(x, y), f2);\n            v += fft_input(vec2(x, y)) * vec2(sqcos(a), sqsin(a));\n        }\n    }\n    return v * fft_mul;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // If iResolution is not large enough\n    if (int(floor(iResolution.x)) < fft_res.x || int(floor(iResolution.y)) < fft_res.y)\n    {\n        frag_col = vec4(1, 0, 1, 1);\n        return;\n    }\n    \n    // Integer coordinates & UV\n    ivec2 icoord = ivec2(floor(frag_coord));\n    vec2 uv = (vec2(icoord) + 0.5) / vec2(fft_res);\n    \n    // If outside the region of interest\n    if (icoord.x >= fft_res.x || icoord.y >= fft_res.y)\n    {\n        frag_col = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    // Init variables for fft_input\n    float t = TAU * iTime;\n    shape0_radius = 0.16 + 0.07 * cos(t * 0.2);\n    shape1_slit1_half_width = 0.02 + 0.007 * cos(t * 0.2286);\n    shape1_slit2_center = 0.56 + 0.01 * cos(t * 0.4);\n    shape1_slit2_fade = 0.005 + 0.004 * cos(t * 0.3772);\n    shape1_cutout_radius = 0.254 + 0.02 * cos(t * 0.1689);\n    \n    float v = 0.0;\n    if (fft_preview_input)\n    {\n        // Preview FFT input\n        v = fft_input(uv);\n    }\n    else\n    {\n        // What 2D frequency to check\n        ivec2 freq = icoord - (fft_res / 2);\n        \n        // How much of the frequency is present\n        v = length(freq_amount(freq));\n    }\n    \n    // Output\n    frag_col = vec4(v, v, v, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}