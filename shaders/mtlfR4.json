{
    "Shader": {
        "info": {
            "date": "1692696832",
            "description": "A shiny diamond, use mouse for orbit controls.\nMainly based on this tutorial: https://www.youtube.com/watch?v=0RWaR7zApEo&ab_channel=TheArtofCode",
            "flags": 0,
            "hasliked": 0,
            "id": "mtlfR4",
            "likes": 3,
            "name": "Shiny Diamond",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "alphardex",
            "viewed": 172
        },
        "renderpass": [
            {
                "code": "#define IS_IN_SHADERTOY 1\n#if IS_IN_SHADERTOY==1\n#define iChannel0Cube iChannel0\n#endif\n\nconst float PI=3.14159265359;\n\nconst float TWO_PI=6.28318530718;\n\nmat2 rotation2d(float angle){\n    float s=sin(angle);\n    float c=cos(angle);\n    \n    return mat2(\n        c,-s,\n        s,c\n    );\n}\n\nmat4 rotation3d(vec3 axis,float angle){\n    axis=normalize(axis);\n    float s=sin(angle);\n    float c=cos(angle);\n    float oc=1.-c;\n    \n    return mat4(\n        oc*axis.x*axis.x+c,oc*axis.x*axis.y-axis.z*s,oc*axis.z*axis.x+axis.y*s,0.,\n        oc*axis.x*axis.y+axis.z*s,oc*axis.y*axis.y+c,oc*axis.y*axis.z-axis.x*s,0.,\n        oc*axis.z*axis.x-axis.y*s,oc*axis.y*axis.z+axis.x*s,oc*axis.z*axis.z+c,0.,\n        0.,0.,0.,1.\n    );\n}\n\nvec2 rotate(vec2 v,float angle){\n    return rotation2d(angle)*v;\n}\n\nvec3 rotate(vec3 v,vec3 axis,float angle){\n    return(rotation3d(axis,angle)*vec4(v,1.)).xyz;\n}\n\n// Credit: https://www.shadertoy.com/view/ltfXDM\nfloat sdDiamond(in vec3 p){\n    vec3 normalTopA=normalize(vec3(0.,1.,1.4));\n    vec3 normalTopB=normalize(vec3(0.,1.,1.));\n    vec3 normalTopC=normalize(vec3(0.,1.,.5));\n    vec3 normalBottomA=normalize(vec3(0.,-1.,1.));\n    vec3 normalBottomB=normalize(vec3(0.,-1.,1.6));\n    float topCut=p.y-1.;\n    // float angleStep=PI/(iMouse.z<.5?8.:2.+floor(18.*iMouse.x/iResolution.x));\n    float angleStep=PI/20.;\n    float angle=angleStep*(.5+floor(atan(p.x,p.z)/angleStep));\n    vec3 q=rotate(p,vec3(0.,1.,0),angle);\n    float topA=dot(q,normalTopA)-2.;\n    float topC=dot(q,normalTopC)-1.5;\n    float bottomA=dot(q,normalBottomA)-1.7;\n    q=rotate(p,vec3(0.,1.,0),-angleStep*.5);\n    angle=angleStep*floor(atan(q.x,q.z)/angleStep);\n    q=rotate(p,vec3(0.,1.,0),angle);\n    float topB=dot(q,normalTopB)-1.85;\n    float bottomB=dot(q,normalBottomB)-1.9;\n    \n    return max(topCut,max(topA,max(topB,max(topC,max(bottomA,bottomB)))));\n}\n\nfloat opUnion(float d1,float d2)\n{\n    return min(d1,d2);\n}\n\nvec2 opUnion(vec2 d1,vec2 d2)\n{\n    return(d1.x<d2.x)?d1:d2;\n}\n\nfloat opIntersection(float d1,float d2)\n{\n    return max(d1,d2);\n}\n\nfloat opSubtraction(float d1,float d2)\n{\n    return max(-d1,d2);\n}\n\nfloat opSmoothUnion(float d1,float d2,float k){\n    float h=clamp(.5+.5*(d2-d1)/k,0.,1.);\n    return mix(d2,d1,h)-k*h*(1.-h);\n}\n\nfloat opSmoothSubtraction(float d1,float d2,float k){\n    float h=clamp(.5-.5*(d2+d1)/k,0.,1.);\n    return mix(d2,-d1,h)+k*h*(1.-h);\n}\n\nfloat opSmoothIntersection(float d1,float d2,float k){\n    float h=clamp(.5-.5*(d2-d1)/k,0.,1.);\n    return mix(d2,d1,h)+k*h*(1.-h);\n}\n\nconst float gamma=2.2;\n\nfloat toGamma(float v){\n    return pow(v,1./gamma);\n}\n\nvec2 toGamma(vec2 v){\n    return pow(v,vec2(1./gamma));\n}\n\nvec3 toGamma(vec3 v){\n    return pow(v,vec3(1./gamma));\n}\n\nvec4 toGamma(vec4 v){\n    return vec4(toGamma(v.rgb),v.a);\n}\n\nmat3 setCamera(in vec3 ro,in vec3 ta,float cr)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(sin(cr),cos(cr),0.);\n    vec3 cu=normalize(cross(cw,cp));\n    vec3 cv=(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\nvec3 getRayDirection(vec2 p,vec3 ro,vec3 ta,float fl){\n    mat3 ca=setCamera(ro,ta,0.);\n    vec3 rd=ca*normalize(vec3(p,fl));\n    return rd;\n}\n\nvec2 map(vec3 p){\n    vec2 d=vec2(1e10,0.);\n    \n    float d1=sdDiamond(p);\n    d=opUnion(d,vec2(d1,3.));\n    \n    return d;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    const float h=.0001;\n    const vec2 k=vec2(1,-1);\n    return normalize(k.xyy*map(p+k.xyy*h).x+\n    k.yyx*map(p+k.yyx*h).x+\n    k.yxy*map(p+k.yxy*h).x+\n    k.xxx*map(p+k.xxx*h).x);\n}\n\nfloat softshadow(in vec3 ro,in vec3 rd,float mint,float maxt,float k)\n{\n    float res=1.;\n    float t=mint;\n    for(int i=0;i<256&&t<maxt;i++)\n    {\n        float h=map(ro+rd*t).x;\n        if(h<.001)\n        return 0.;\n        res=min(res,k*h/t);\n        t+=h;\n    }\n    return res;\n}\n\nvec2 raycast(vec3 ro,vec3 rd,float side){\n    vec2 result=vec2(-1.,-1.);\n    float depth=0.;\n    for(int i=0;i<128;i++){\n        vec3 p=ro+rd*depth;\n        // float d=map(p);\n        vec2 res=map(p)*side;\n        float d=res.x;\n        float m=res.y;\n        \n        depth+=d;\n        if(d<.01){\n            result=vec2(depth,m);\n            break;\n        }\n    }\n    return result;\n}\n\nvec3 getRdOut(vec3 rdIn,vec3 norExit,float ior){\n    vec3 rdOut=refract(rdIn,norExit,ior);\n    if(dot(rdOut,rdOut)==0.){\n        rdOut=reflect(rdIn,norExit);\n    }\n    return rdOut;\n}\n\nvec3 RGBShift(samplerCube tex,vec3 rUv,vec3 gUv,vec3 bUv){\n    float r=texture(tex,rUv).r;\n    float g=texture(tex,gUv).g;\n    float b=texture(tex,bUv).b;\n    return vec3(r,g,b);\n}\n\nfloat fresnel(float bias,float scale,float power,vec3 I,vec3 N)\n{\n    return bias+scale*pow(1.-dot(I,N),power);\n}\n\nvec3 lighting(in vec3 col,in vec3 pos,in vec3 rd,in vec3 nor,in float t){\n    vec3 lin=col;\n    \n    // refraction\n    {\n        float ior=1.49;\n        float ca=.01;\n        vec3 reflTex=vec3(0.);\n        \n        // do refraction\n        vec3 rdIn=refract(rd,nor,1./ior);// ray direction when entering\n        vec3 pEnter=pos-nor*.001*t*3.;\n        float dIn=raycast(pEnter,rdIn,-1.).x;// inside the object\n        \n        vec3 pExit=pEnter+rdIn*dIn;// 3d position of exit\n        vec3 norExit=-calcNormal(pExit);\n        \n        // vec3 rdOut=getRdOut(rdIn,norExit,ior);\n        // reflTex=texture(iChannel0Cube,rdOut).xyz;\n        \n        // chromatic aberration\n        vec3 rUv=getRdOut(rdIn,norExit,ior-ca);\n        vec3 gUv=getRdOut(rdIn,norExit,ior);\n        vec3 bUv=getRdOut(rdIn,norExit,ior+ca);\n        vec3 rgbTex=RGBShift(iChannel0Cube,rUv,gUv,bUv);\n        reflTex=rgbTex;\n        \n        // color\n        // vec3 gemColor=vec3(1.,.05,.2);\n        // reflTex*=gemColor;\n        \n        // optical Density\n        float dens=.1;\n        float optDist=exp(-dIn*dens);\n        reflTex*=optDist;\n        \n        // fresnel\n        float fre=fresnel(0.,1.,5.,-rd,nor);\n        // reflTex=vec3(fre);\n        vec3 reflOutside=texture(iChannel0Cube,reflect(rd,nor)).xyz;\n        reflTex=mix(reflTex,reflOutside,fre);\n        \n        lin=reflTex;\n    }\n    \n    return lin;\n}\n\nvec3 getSceneColor(vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    uv=(uv-.5)*2.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 ro=vec3(0.,4.,8.);\n    vec3 ta=vec3(0.,0.,0.);\n    const float fl=3.;\n    \n    vec2 mouse=iMouse.xy/iResolution.xy;\n    ro.yz=rotate(ro.yz,-mouse.y*PI+1.);\n    ro.xz=rotate(ro.xz,-mouse.x*TWO_PI);\n    \n    vec3 rd=getRayDirection(uv,ro,ta,fl);\n    \n    vec3 col=vec3(0.);\n    \n    vec2 res=raycast(ro,rd,1.);\n    float d=res.x;\n    float m=res.y;\n    if(m>-.5){\n        vec3 p=ro+rd*d;\n        \n        // col=vec3(1.);\n        col=vec3(0.);\n        vec3 normal=(m<1.5)?vec3(0.,1.,0.):calcNormal(p);\n        \n        // vec3 objectColor=vec3(1.);\n        // vec3 lightColor=vec3(.875,.286,.333);\n        \n        // // ambient\n        // float ambIntensity=.2;\n        // vec3 ambient=lightColor*ambIntensity;\n        // col+=ambient*objectColor;\n        \n        // // diffuse\n        // vec3 lightPos=vec3(10.,10.,10.);\n        // vec3 lightDir=normalize(lightPos-p);\n        // float diff=dot(normal,lightDir);\n        // diff=max(diff,0.);\n        // vec3 diffuse=lightColor*diff;\n        // float shadow=softshadow(p,lightDir,.01,10.,16.);\n        // col+=diffuse*objectColor*shadow;\n        \n        // // specular\n        // vec3 reflectDir=reflect(-lightDir,normal);\n        // vec3 viewDir=normalize(ro-p);\n        // vec3 halfVec=normalize(lightDir+viewDir);\n        // float spec=dot(normal,halfVec);\n        // spec=max(spec,0.);\n        // float shininess=32.;\n        // spec=pow(spec,shininess);\n        // vec3 specular=lightColor*spec;\n        // col+=specular*objectColor;\n        \n        col=lighting(col,p,rd,normal,d);\n    }\n    \n    col=toGamma(col);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec3 tot=vec3(0.);\n    \n    float AA_size=2.;\n    float count=0.;\n    for(float aaY=0.;aaY<AA_size;aaY++)\n    {\n        for(float aaX=0.;aaX<AA_size;aaX++)\n        {\n            tot+=getSceneColor(fragCoord+vec2(aaX,aaY)/AA_size);\n            count+=1.;\n        }\n    }\n    tot/=count;\n    \n    fragColor=vec4(tot,1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}