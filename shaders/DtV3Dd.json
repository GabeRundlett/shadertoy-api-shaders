{
    "Shader": {
        "info": {
            "date": "1685049288",
            "description": "Pathtracing a distance field!\nHalf of the code is from other places; I listed attributions above the functions I used.\nI came up with this UV-to-starfield function using a noise texture that makes plausible-looking stars.\nUses the Preetham sky model.",
            "flags": 0,
            "hasliked": 0,
            "id": "DtV3Dd",
            "likes": 5,
            "name": "Pathmarched Sculpture",
            "published": 3,
            "tags": [
                "3d",
                "raymarcher",
                "stars",
                "pathtracer",
                "sculpture",
                "preetham",
                "pathmarcher"
            ],
            "usePreview": 1,
            "username": "isaacchurchill",
            "viewed": 312
        },
        "renderpass": [
            {
                "code": "#define SAMPLES 1\n\n#define RAYMARCH_MAX 250\n#define RAYMARCH_MAX_DIST 100.0\n#define RAYMARCH_EPS 0.001\n\n#define PATHTRACE_MAX 3\n\n#define MAT_DIFFUSE 0\n#define MAT_METAL 1\n\n#define PI 3.14159265\n\nmat2 planetRot;\nvec3 sunDir = normalize(vec3(0.2, -0.5, -1.0));\n\nmat2 rotmat(float theta)\n{\n    return mat2(cos(theta), sin(theta),\n                -sin(theta), cos(theta));\n}\n\n\n\n\n\n\n/////////////////////////////////////////////////////////////\n// The functions in this section are from\n// https://www.shadertoy.com/view/XdyyDd\n// Copyright Â© 2019 Markus Moenig Distributed under The MIT License.\n/////////////////////////////////////////////////////////////\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p) {\n    vec3 p3 = fract(vec3(p) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n/////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////\n// The functions in this section are from\n// https://www.shadertoy.com/view/llyGDR\n//////////////////////////////////////////////////////////////////////////\n\nfloat saturatedDot( in vec3 a, in vec3 b )\n{\n\treturn max( dot( a, b ), 0.0 );   \n}\n\nvec3 YxyToXYZ( in vec3 Yxy )\n{\n\tfloat Y = Yxy.r;\n\tfloat x = Yxy.g;\n\tfloat y = Yxy.b;\n\n\tfloat X = x * ( Y / y );\n\tfloat Z = ( 1.0 - x - y ) * ( Y / y );\n\n\treturn vec3(X,Y,Z);\n}\n\nvec3 XYZToRGB( in vec3 XYZ )\n{\n\t// CIE/E\n\tmat3 M = mat3\n\t(\n\t\t 2.3706743, -0.9000405, -0.4706338,\n\t\t-0.5138850,  1.4253036,  0.0885814,\n \t\t 0.0052982, -0.0146949,  1.0093968\n\t);\n\n\treturn XYZ * M;\n}\n\n\nvec3 YxyToRGB( in vec3 Yxy )\n{\n\tvec3 XYZ = YxyToXYZ( Yxy );\n\tvec3 RGB = XYZToRGB( XYZ );\n\treturn RGB;\n}\n\nvoid calculatePerezDistribution( in float t, out vec3 A, out vec3 B, out vec3 C, out vec3 D, out vec3 E )\n{\n\tA = vec3(  0.1787 * t - 1.4630, -0.0193 * t - 0.2592, -0.0167 * t - 0.2608 );\n\tB = vec3( -0.3554 * t + 0.4275, -0.0665 * t + 0.0008, -0.0950 * t + 0.0092 );\n\tC = vec3( -0.0227 * t + 5.3251, -0.0004 * t + 0.2125, -0.0079 * t + 0.2102 );\n\tD = vec3(  0.1206 * t - 2.5771, -0.0641 * t - 0.8989, -0.0441 * t - 1.6537 );\n\tE = vec3( -0.0670 * t + 0.3703, -0.0033 * t + 0.0452, -0.0109 * t + 0.0529 );\n}\n\nvec3 calculateZenithLuminanceYxy( in float t, in float thetaS )\n{\n\tfloat chi  \t \t= ( 4.0 / 9.0 - t / 120.0 ) * ( PI - 2.0 * thetaS );\n\tfloat Yz   \t \t= ( 4.0453 * t - 4.9710 ) * tan( chi ) - 0.2155 * t + 2.4192;\n\n\tfloat theta2 \t= thetaS * thetaS;\n    float theta3 \t= theta2 * thetaS;\n    float T \t \t= t;\n    float T2 \t \t= t * t;\n\n\tfloat xz =\n      ( 0.00165 * theta3 - 0.00375 * theta2 + 0.00209 * thetaS + 0.0)     * T2 +\n      (-0.02903 * theta3 + 0.06377 * theta2 - 0.03202 * thetaS + 0.00394) * T +\n      ( 0.11693 * theta3 - 0.21196 * theta2 + 0.06052 * thetaS + 0.25886);\n\n    float yz =\n      ( 0.00275 * theta3 - 0.00610 * theta2 + 0.00317 * thetaS + 0.0)     * T2 +\n      (-0.04214 * theta3 + 0.08970 * theta2 - 0.04153 * thetaS + 0.00516) * T +\n      ( 0.15346 * theta3 - 0.26756 * theta2 + 0.06670 * thetaS + 0.26688);\n\n\treturn vec3( Yz, xz, yz );\n}\n\nvec3 calculatePerezLuminanceYxy( in float theta, in float gamma, in vec3 A, in vec3 B, in vec3 C, in vec3 D, in vec3 E )\n{\n\treturn ( 1.0 + A * exp( B / cos( theta ) ) ) * ( 1.0 + C * exp( D * gamma ) + E * cos( gamma ) * cos( gamma ) );\n}\n\nvec3 calculateSkyLuminanceRGB( in vec3 s, in vec3 e, in float t )\n{\n\tvec3 A, B, C, D, E;\n\tcalculatePerezDistribution( t, A, B, C, D, E );\n\n\tfloat thetaS = acos( saturatedDot( s, vec3(0,1,0) ) );\n\tfloat thetaE = acos( saturatedDot( e, vec3(0,1,0) ) );\n\tfloat gammaE = acos( saturatedDot( s, e )\t\t   );\n\n\tvec3 Yz = calculateZenithLuminanceYxy( t, thetaS );\n\n\tvec3 fThetaGamma = calculatePerezLuminanceYxy( thetaE, gammaE, A, B, C, D, E );\n\tvec3 fZeroThetaS = calculatePerezLuminanceYxy( 0.0,    thetaS, A, B, C, D, E );\n\n\tvec3 Yp = Yz * ( fThetaGamma / fZeroThetaS );\n\n\treturn YxyToRGB( Yp );\n}\n\n//////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////\n// From https://www.gamedev.net/forums/topic/687535-implementing-a-cube-map-lookup-function/5337472/\n//////////////////////////////////////////////////////////////////////////\n\nvec2 sampleCube(in vec3 v, out int faceIndex)\n{\n\tvec3 vAbs = abs(v);\n\tfloat ma;\n\tvec2 uv;\n\tif(vAbs.z >= vAbs.x && vAbs.z >= vAbs.y)\n\t{\n\t\tfaceIndex = v.z < 0.0 ? 5 : 4;\n\t\tma = 0.5 / vAbs.z;\n\t\tuv = vec2(v.z < 0.0 ? -v.x : v.x, -v.y);\n\t}\n\telse if(vAbs.y >= vAbs.x)\n\t{\n\t\tfaceIndex = v.y < 0.0 ? 3 : 2;\n\t\tma = 0.5 / vAbs.y;\n\t\tuv = vec2(v.x, v.y < 0.0 ? -v.z : v.z);\n\t}\n\telse\n\t{\n\t\tfaceIndex = v.x < 0.0 ? 1 : 0;\n\t\tma = 0.5 / vAbs.x;\n\t\tuv = vec2(v.x < 0.0 ? v.z : -v.z, -v.y);\n\t}\n\treturn uv * ma + 0.5;\n}\n\n//////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n\n// I tried to come up with an improved stars-from-noise algorithm\n// and I came up with this. \n// instead of just directly sampling from the noise texture and\n// raising it to a high power to only allow bright texels through,\n// it snaps the input UV to the center of each pixel (effectively\n// forcing nearest-sampling) and then uses the distance from the\n// actual UV coord to the centered UV coord to make the stars circular.\n// This has the effect of eliminating the artifacts from the other\n// method where stars sort of blend into each other and have weird shapes.\nvec3 calcStars(vec3 dir)\n{\n    const vec3 moonCol = vec3(1.0, 1.0, 0.85);\n    const float moonSize = 0.04;\n    const vec2 moonPos = vec2(0.25, 0.2);\n    \n    vec2 noiseTexRes = iChannelResolution[0].xy;\n\n    dir.yz *= transpose(planetRot);\n    int faceIndex;\n    vec2 uv = sampleCube(dir, faceIndex);\n    vec2 starsUV = (floor(uv * noiseTexRes) + 0.5) / noiseTexRes; // Snaps the uv to a texel center\n    vec2 texelOffset = (uv - starsUV) * noiseTexRes;\n    float starIntensity = pow(clamp(texture(iChannel0, starsUV).x, 0.0, 1.0), 50.0);\n\n    starIntensity *= 1.0 - pow(min(length(texelOffset * 4.0), 1.0), starIntensity);\n    vec3 col = vec3(starIntensity);\n    if (faceIndex == 5) {\n        float moonDist1 = length(uv - moonPos) - moonSize;\n        float moonDist2 = length(uv - moonPos - vec2(moonSize * 0.35)) - moonSize;\n        \n        float moonFactor1 = smoothstep(-0.003, 0.003, -moonDist1);\n        float moonFactor2 = smoothstep(-0.003, 0.003, moonDist2);\n        col = mix(col, moonCol * moonFactor1 * moonFactor2, moonFactor1);\n    }\n    return col;\n}\n\nvec3 sky(vec3 dir)\n{\n    \n    vec3 stars;\n    if (dir.y > 0.0) {\n        stars = calcStars(dir);\n        stars *= smoothstep(-0.1, 0.4, sunDir.y); // Fade out stars for daytime\n    }\n    dir.y = max(dir.y, 0.001);\n    vec3 preetham = max(calculateSkyLuminanceRGB(-sunDir, dir, 2.5) / 25.0, 0.0);\n    preetham *= clamp(0.3-sunDir.y, 0.0, 1.0) * 0.5 + 0.5; // Darken sky more during night\n    return preetham + stars;\n}\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////\n// The following code is from\n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\n//////////////////////////////////////////////////////////////////////////\n\nvec2 seed = vec2(0.0);\n\nvec2 rand2n() {\n    seed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n\t\tfract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 ortho(vec3 v) {\n    //  See : http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getSampleBiased(vec3  dir, float power) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = rand2n();\n\tr.x=r.x*2.*PI;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\n//vec3 getSample(vec3 dir) {\n//\treturn getSampleBiased(dir,0.0); // <- unbiased!\n//}\n\nvec3 getCosineWeightedSample(vec3 dir) {\n\treturn getSampleBiased(dir,1.0);\n}\n\nvec3 getConeSample(vec3 dir, float extent) {\n        // Formula 34 in GI Compendium\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  rand2n();\n\tr.x=r.x*2.*PI;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n\n// By iq\n// from https://iquilezles.org/articles/distfunctions/\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\n\n// By iq\n// from https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// By iq (modified)\n// from https://iquilezles.org/articles/distfunctions/\nvec3 opRep( in vec3 p, in vec3 c )\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// By iq\n// from https://iquilezles.org/articles/distfunctions/\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\n\n\n\n\n\n\n\nstruct Material {\n    vec3 col;\n    int type;\n};\n\nstruct SceneObj {\n    float dist;\n    Material mat;\n};\n\nSceneObj opUnion(in SceneObj a, in SceneObj b)\n{\n    if (a.dist <= b.dist) {\n        return a;\n    } else {\n        return b;\n    }\n}\n    \nSceneObj sculptureDE(vec3 p)\n{\n    Material redmat = Material(vec3(1.0, 0.05, 0.05), MAT_DIFFUSE);\n    Material whitemat = Material(vec3(1.0), MAT_METAL);\n\n    vec3 z = p;\n    z.yz *= rotmat(-0.6);\n    float cupDist = sdCutHollowSphere(z, 1.0, 0.3, 0.03);\n    SceneObj cup = SceneObj(cupDist, redmat);\n    \n    const float k = 0.3;\n    float metalDist = length(p) - 0.8;\n    metalDist = min(metalDist, length(p - vec3(0.0, 1.0, 0.0)) - 0.7);\n    metalDist = opSmoothUnion(metalDist,\n        sdTorus(p.yzx - vec3(2.0,0.0,0.0), vec2(0.7, 0.2)),\n        k);\n    const vec3 c = vec3(0.2);\n    float balls = length(opRep(p, c)) - 0.1;\n    metalDist = max(metalDist, balls);\n    SceneObj metal = SceneObj(metalDist, whitemat);\n    metal.mat.col = (0.5 + 0.5 * cos(round(p / c))).zyy;\n    \n    SceneObj sculp = opUnion(cup, metal);\n    \n    return sculp;\n}\n\nfloat sceneDE(vec3 p, out Material mat)\n{\n    SceneObj sculpObj = sculptureDE(p);\n\n    Material floorMat = Material(vec3(1.0), MAT_METAL);\n    float floorDispl = sin(length(p.xz * 10.0) - iTime) * 0.03;\n    floorDispl /= max(length(p.xz), 1.0);\n    float floorDist = p.y + 1.0 + floorDispl;\n    SceneObj floorObj = SceneObj(floorDist, floorMat);\n    \n    SceneObj scene = opUnion(sculpObj, floorObj);\n    mat = scene.mat;\n    return scene.dist * 0.5;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    const vec2 eps = vec2(0.001, 0.0);\n    Material temp = Material(vec3(0.0), 0);\n    float centerDist = sceneDE(p, temp);\n    vec3 v = vec3(sceneDE(p + eps.xyy, temp),\n                  sceneDE(p + eps.yxy, temp),\n                  sceneDE(p + eps.yyx, temp)) - centerDist;\n    \n    return normalize(v);\n    \n}\n\nbool raymarch(in vec3 ro, in vec3 rd, out vec3 hit, out vec3 norm, out Material mat)\n{\n    float t = 0.0;\n    vec3 p = ro;\n    for (int i = 0; i < RAYMARCH_MAX && t < RAYMARCH_MAX_DIST; i++) {\n        float dist = sceneDE(p, mat);\n        if (dist < RAYMARCH_EPS) {\n            norm = calcNormal(p);\n            hit = p;\n            return true;\n        }\n        t += dist;\n        p += dist * rd;\n    }\n    return false;\n}\n\n\n\n\n\n\n/////////////////////////////////////////////////////////////////////\n// Most of this function was taken from\n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\n/////////////////////////////////////////////////////////////////////\n\nvec3 pathtrace(vec3 ro, vec3 rd)\n{\n    float sunSize = 1E-3; // Hemisphere area covered by the sun\n    float sunStrength = max(-sunDir.y, 0.0); // To make sunsets be darker then midday\n    \n    vec3 luminance = vec3(1.0);\n    vec3 direct = vec3(0.0);\n    \n    for (int i = 0; i < PATHTRACE_MAX; i++) {\n        vec3 hit = vec3(0.0);\n        vec3 norm = vec3(0.0);\n        Material mat = Material(vec3(0.0), 0);\n        if (raymarch(ro, rd, hit, norm, mat)) {\n            vec3 newStartPos = hit + norm * RAYMARCH_EPS * 2.0;\n            if (mat.type == MAT_DIFFUSE) {\n                rd = getCosineWeightedSample(norm);\n                luminance *= mat.col;\n                // Direct lighting\n                vec3 sunSampleDir = getConeSample(-sunDir,sunSize);\n                float sunLight = dot(norm, sunSampleDir);\n                vec3 temp1;\n                vec3 temp2;\n                Material temp3;\n                if (sunLight>0.0 && !raymarch(newStartPos,sunSampleDir, temp1, temp2, temp3)) {\n                    direct += luminance*sunLight*sunStrength;\n                }\n                ////////////////////////////\n            } else if (mat.type == MAT_METAL) {\n                rd = reflect(rd, norm);\n                luminance *= mat.col;\n            }\n            ro = newStartPos;\n        } else {\n            vec3 backgroundCol = sky(rd) + pow(max(dot(rd, -sunDir), 0.0), 200.0);\n            return direct + luminance * backgroundCol;\n        }\n    }\n\n    return direct;\n}\n\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 c = (2.0 * fragCoord - iResolution.xy ) / iResolution.y;\n\n    planetRot = rotmat(iTime * 0.25);\n    sunDir.yz *= planetRot;\n\n    vec3 ro = vec3(0.0, 0.0, -3.0); // Camera position\n    vec3 rd = normalize(vec3(c, 1.0));\n\n    vec3 col = vec3(0.0);\n    for (int samp = 0; samp < SAMPLES; samp++) {\n        seed = hash21(hash12(fragCoord) + float(samp) * 0.0123398 + float(iFrame));\n        col += pathtrace(ro, rd);\n    }\n    col /= float(SAMPLES);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}