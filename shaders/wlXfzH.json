{
    "Shader": {
        "info": {
            "date": "1595974454",
            "description": "Testing camera rotation",
            "flags": 0,
            "hasliked": 0,
            "id": "wlXfzH",
            "likes": 6,
            "name": "Camera Movement Test",
            "published": 3,
            "tags": [
                "3d",
                "ray",
                "ray",
                "raymarch",
                "mandelbulb",
                "sphere",
                "marcher",
                "epic",
                "yeet"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 359
        },
        "renderpass": [
            {
                "code": "// Fork of \"My Very First Working Fractal\" by Zi7ar21. https://shadertoy.com/view/ttBcWR\n// 2020-07-28 21:58:56\n\n// Zi7ar21's Mandelbulb Ray Marcher -- July 6th, 2020\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I urge you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/ttBcWR\n// Fork of \"My Very First Working Raymarcher\" by Zi7ar21. [2020-07-06 23:50:09]\n// https://shadertoy.com/view/WlBcDz\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// Change these Parameters to Your Liking!\n#define MAX_MARCHES 32\n#define MAX_DISTANCE 32.0\n#define COLLISION_DISTANCE 0.01\n#define Bailout 16.0\n#define Iterations 6\n\n// Mandelbulb Distance Estimator\n// Adapted from:\n// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat sphere(vec3 pos) {\n\tfloat Power = float((sin(iTime * 2.5) * 0.5) + 8.0);\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// Convert to Polar Coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// Scale and Rotate the Point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// Convert Back to Cartesian Coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n// Compute/March the Ray\nfloat raymarch(vec3 camerapos, vec3 raydir) {\n\tfloat distorigin=0.0;\n    \n    for(int i=0; i<MAX_MARCHES; i++) {\n    \tvec3 raypos = camerapos + raydir*distorigin;\n        float distsurface = sphere(raypos);\n        distorigin += distsurface;\n        if(distorigin>MAX_DISTANCE || distsurface<COLLISION_DISTANCE) break;\n    }\n    \n    return distorigin;\n}\n\n// Get Normal\nvec3 normal(vec3 raypos) {\n\tfloat dis = sphere(raypos);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 normal = dis - vec3(\n        sphere(raypos-e.xyy),\n        sphere(raypos-e.yxy),\n        sphere(raypos-e.yyx));\n    \n    return normalize(normal);\n}\n\n// Shade Scene\nvec3 shade(vec3 march) {\n\t// Light Positions\n    vec3 lightpositiona = vec3(0, 8, 0);\n\tvec3 lightpositionb = vec3(0, 0, 0);\n    vec3 lightpositionc = vec3(0, -8, 0);\n\t// Animate Lights\n    lightpositiona.xz += vec2(sin(iTime * 4.0), cos(iTime * 4.0))*4.0;\n    lightpositionb.xz += vec2(sin(iTime * 4.0), cos(iTime * 4.0))*4.0;\n    lightpositionc.xz += vec2(sin(iTime * 4.0), cos(iTime * 4.0))*4.0;\n\t// Compute Lighting\n    vec3 lightinga = normalize(lightpositiona-march);\n    vec3 lightingb = normalize(lightpositionb-march);\n    vec3 lightingc = normalize(lightpositionc-march);\n\t// Compute Surface Normal\n    vec3 surfacenormal = normal(march);\n\t// Compute Diffuse\n    float diffuseshader = clamp(dot(surfacenormal, lightinga), 0.0, 1.0);\n    float diffuseshadeg = clamp(dot(surfacenormal, lightingb), 0.0, 1.0);\n    float diffuseshadeb = clamp(dot(surfacenormal, lightingc), 0.0, 1.0);\n\t// Compute Geometry\n    float distancesurfa = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightinga);\n    float distancesurfb = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightingb);\n    float distancesurfc = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightingc);\n\t// Shade Geometry\n    if(distancesurfa<length(lightpositiona-march)) diffuseshader *= 1.0;\n    if(distancesurfa<length(lightpositionb-march)) diffuseshadeg *= 1.0;\n    if(distancesurfb<length(lightpositionc-march)) diffuseshadeb *= 1.0;\n    // Return Shading\n    return vec3(diffuseshader, diffuseshadeg, diffuseshadeb);\n}\n\n// ACES Tone Curve\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0);\n}\n\n// Render the Image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Camera Orientation\n\tvec3 xdir = vec3(1,0,0);\n\tvec3 ydir = vec3(0,1,0);\n\tvec3 zdir = vec3(0,0,1);\n\tfloat FOV = 1.0;\n\tvec3 camerapos = vec3(0.0, 0.0, -4.5);\n    camerapos = vec3(camerapos.x+((-iMouse.x+iResolution.x/2.0)/iResolution.x), camerapos.y+((-iMouse.y+iResolution.y/2.0)/iResolution.x), -4.5);\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n\tvec3 raydir = normalize(FOV*(uv.x*xdir + uv.y*ydir) + zdir);\n\tfloat collide = raymarch(camerapos, raydir);\n\n    // Pixel Color\n    vec3 col = vec3(collide / 4.0);\n\n\t// Compute and Shade\n\tfloat spheredistance = raymarch(camerapos, raydir);\n    vec3 march = camerapos + raydir * spheredistance;\n    vec3 diffuse = shade(march);\n\t\n\t// Finish the Image and Apply Tone Map\n    col = vec3(acesFilm(diffuse));\n\n    // Output to Screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}