{
    "Shader": {
        "info": {
            "date": "1693167728",
            "description": "A way to compute bent normals.\nAs always, Distance Field have amazing properties to get a nice approximation!",
            "flags": 0,
            "hasliked": 0,
            "id": "dtsfzS",
            "likes": 55,
            "name": "Bent Normals for SDF",
            "published": 3,
            "tags": [
                "normal",
                "ibl",
                "bent"
            ],
            "usePreview": 1,
            "username": "XT95",
            "viewed": 1971
        },
        "renderpass": [
            {
                "code": "// --------------------------------------------\n// A way to compute bent normals for SDF\n// --------------------------------------------\n//\n// How it works ?\n//\n// - Start by computing the normal, tangent, and bitangent\n//   at the intersection point.\n//\n// - Send a few rays into the hemisphere\n//   (spherical Fibonacci is used here to obtain a good distribution).\n//\n//    - Raymarch a few steps into the SDF\n//      (we don't care to intersect the surface, and that is the whole point!)\n//\n// - Compute the bent normal by summing\n//   all the rays weighted by the distance they traveled.\n//\n// - The sum of the distances of each ray also gives a nice approximation\n//   of ambient occlusion.\n//\n//\n// Why it works ?\n//\n// Raymarching a SDF takes more iterations when some geometries \n// are around.\n// For a fixed iteration count, if a ray goes farther than \n// an other, it mean that this direction is globally less\n// occluded than the other one.\n// By this fact, we can easily approximate the best unoccluded\n// direction without tracing a lot of rays. \n// We don't even need to raymarch rays until they hit the surface.\n//\n//\n// Shaders used here :\n//\n// SH code taken from https://www.shadertoy.com/view/Mt23zW\n// Scene taken from https://www.shadertoy.com/view/ldScDh\n// Specular occlusion factor from https://twitter.com/FewesW/status/1162341793721126913\n// --------------------------------------------\n\n#define AO_FACTOR 40.\n\nvoid normalBentAO(vec3 p, out vec3 n, out vec3 bent, out float ao) {\n    // init data\n    bent = vec3(0.);\n    ao = 0.;\n    \n    // compute the normal\n    float d = map(p);\n    vec2 eps = vec2(0.005,0.);\n    n = normalize(vec3(d-map(p-eps.xyy),d-map(p-eps.yxy),d-map(p-eps.yyx)));\n    \n    // orthonormal basis\n    vec3 nt,nb;\n    basis(n,nt,nb);\n    p += n * eps.x;\n    \n    \n    const int RayCount = 16;\n    const int RaymarchCount = 16;\n    \n    // send few rays\n    for(int j=0; j<RayCount; j++) {\n        vec3 fib = sphericalFibonacci(float(j),float(RayCount*2));\n        vec3 dir = fib.z * n + fib.x * nt + fib.y * nb;\n        \n        // raymarch few steps\n        float t = 0.025;\n        for(int i=0; i<RaymarchCount; i++) {\n            float dd = map(p + dir * t);\n            t += dd;\n            if (abs(dd)<eps.x) break;\n        }\n        \n        bent += dir * t;\n    }\n    \n    // normalize\n    float mag = length(bent);\n    ao = 1.-exp(-mag/float(RayCount)/AO_FACTOR);\n    bent /= mag;\n}\n\n\n\nvec3 shade(vec3 ro, vec3 rd, float depth, vec2 uv) {\n    float t = mod(iTime,9.5);\n    \n    // background\n    if (depth<0.) return ACES(texture(iChannel0, rd).xyz) *(smoothstep(3.5,3., t)+smoothstep(9.,9.5, t));\n    \n    // get data at intersection point\n    vec3 p = ro + rd * depth;\n    vec3 n, bent;\n    float ao;\n    normalBentAO(p, n,bent,ao);\n\n    // compute diffuse & specular term\n    float fre = pow(1.-max(0.,dot(-rd,n)),5.);\n    vec3 refDir = reflect(rd,n);\n    float specOcc = mix(max(dot(refDir,bent),0.), 1., ao); // from https://twitter.com/FewesW/status/1162341793721126913\n    \n    vec3 diff = calcIrradiance(bent) * ao * (1.-fre);\n    vec3 spec = texture(iChannel1,refDir).rgb * specOcc * fre;\n    \n    // display bent / AO / render\n    vec3 col1 = vec3(bent*.5+.5); col1 *= col1;\n    vec3 col2 = vec3(ao);\n    vec3 col3 = ACES(diff + spec);\n    \n    vec3 col = col3 * (smoothstep(3.5,3., t)+smoothstep(9.,9.5, t));\n    col += col1 * smoothstep(3.,3.5, t) * smoothstep(6.5,6., t);\n    col += col2 * smoothstep(6.,6.5, t) * smoothstep(9.5,9., t);\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 v = uv*2.-1.;\n    v.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.,-1.,-30.);\n    vec3 rd = normalize(vec3(v,1.5));\n    ro.xz = rot(iTime*.25) * ro.xz;\n    rd.xz = rot(iTime*.25) * rd.xz;\n    \n    float depth = trace(ro, rd, vec2(0.,50.));\n    vec3 col = shade(ro,rd, depth, uv);\n\n    fragColor = vec4(pow(col,vec3(1./2.2)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ---------------------------------------------\n// Maths toolbox\n// ---------------------------------------------\n#define PI 3.14159265\n#define saturate(x) clamp(x,0.,1.)\n\nvec3 sphericalFibonacci(float i, float n) {\n    const float PHI = sqrt(5.) * 0.5 + 0.5;\n#   define madfrac(A, B) ((A)*(B)-floor((A)*(B)))\n    float phi = 2.0 * PI * madfrac(i, PHI - 1.);\n    float cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);\n    float sinTheta = sqrt(saturate(1.0 - cosTheta * cosTheta));\n\n    return vec3( cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n\n#   undef madfrac\n}\n\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nvoid basis(in vec3 n, out vec3 b1, out vec3 b2) \n{\n    if(n.z<0.){\n        float a = 1.0 / (1.0 - n.z);\n        float b = n.x * n.y * a;\n        b1 = vec3(1.0 - n.x * n.x * a, -b, n.x);\n        b2 = vec3(b, n.y * n.y*a - 1.0, -n.y);\n    }\n    else{\n        float a = 1.0 / (1.0 + n.z);\n        float b = -n.x * n.y * a;\n        b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n        b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n    }\n}\n\nmat2 rot(float v) {\n    float a = cos(v);\n    float b = sin(v);\n    \n    return mat2(a,-b,b,a);\n}\n\n\nvec3 ACES(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n\n\n// ---------------------------------------------\n// SH of the scene\n// from https://www.shadertoy.com/view/Mt23zW\n// ---------------------------------------------\nstruct SHCoefficients {\n    vec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\n};\n\n// These constants have been calculated with a light probe from this website:\n// http://www.pauldebevec.com/Probes/\n// The light probe image used is St. Peter's Basilica.\nconst SHCoefficients stpeter = SHCoefficients(\n    vec3( 0.3623915,  0.2624130,  0.2326261 ),\n    vec3( 0.1759131,  0.1436266,  0.1260569 ),\n    vec3(-0.0247311, -0.0101254, -0.0010745 ),\n    vec3( 0.0346500,  0.0223184,  0.0101350 ),\n    vec3( 0.0198140,  0.0144073,  0.0043987 ),\n    vec3(-0.0469596, -0.0254485, -0.0117786 ),\n    vec3(-0.0898667, -0.0760911, -0.0740964 ),\n    vec3( 0.0050194,  0.0038841,  0.0001374 ),\n    vec3(-0.0818750, -0.0321501,  0.0033399 )\n);\n\nvec3 calcIrradiance(vec3 nor) {\n    const SHCoefficients c = stpeter;\n    const float c1 = 0.429043;\n    const float c2 = 0.511664;\n    const float c3 = 0.743125;\n    const float c4 = 0.886227;\n    const float c5 = 0.247708;\n    return (\n        c1 * c.l22 * (nor.x * nor.x - nor.y * nor.y) +\n        c3 * c.l20 * nor.z * nor.z +\n        c4 * c.l00 -\n        c5 * c.l20 +\n        2.0 * c1 * c.l2m2 * nor.x * nor.y +\n        2.0 * c1 * c.l21  * nor.x * nor.z +\n        2.0 * c1 * c.l2m1 * nor.y * nor.z +\n        2.0 * c2 * c.l11  * nor.x +\n        2.0 * c2 * c.l1m1 * nor.y +\n        2.0 * c2 * c.l10  * nor.z\n    );\n}\n\n\n\n// ---------------------------------------------\n// Raytracing\n// ---------------------------------------------\nfloat map(vec3 p);\nfloat trace(vec3 ro, vec3 rd, vec2 nearFar) {\n    float t = nearFar.x;\n    \n    for(int i=0; i<128; i++) {\n        float d = map(ro+rd*t);\n        t += d;\n        if (abs(d) < 0.001) break;\n    }\n    if (t > nearFar.y) return -1.;\n    return t;\n}\n\n\n// ---------------------------------------------\n// SDF Scene\n// https://www.shadertoy.com/view/ldScDh\n// ---------------------------------------------\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p);\n    float h = clamp( (-2.0*ndot(q,b) + ndot(b,b) )/dot(b,b), -1.0, 1.0 );\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    d *= sign( q.x*b.y + q.y*b.x - b.x*b.y );\n\treturn d - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opRepLim( in float p, in float s, in float lima, float limb, out float id )\n{\n    id = round(p/s);\n    return p-s*clamp(id,-lima,limb);\n}\n\nvec2 opRepLim( in vec2 p, in float s, in vec2 lim, out vec2 id )\n{\n    id = round(p/s);\n    return p-s*clamp(id,-lim,lim);\n}\n\nvec2 opRepLim( in vec2 p, in float s, in vec2 limmin, in vec2 limmax, out vec2 id )\n{\n    id = round(p/s);\n    return p-s*clamp(id,-limmin,limmax);\n}\nfloat opExtrussion( in float sdf, float z, in float h )\n{\n    vec2 w = vec2( sdf, abs(z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat hash1( vec2 p ) { p = 50.0*fract( p*0.3183099 ); return fract( p.x*p.y*(p.x+p.y) ); }\nfloat map( in vec3 p )\n{\n    vec3 op = p;\n    p.y += 2.0;\n    float ma = 0.0;\n\n    // columns\n    vec2 id;\n    vec3 q = p; q.xz = opRepLim( q.xz, 4.0, vec2(4.0,2.0), id );\n    float d = length(q.xz) - 0.9 + 0.05*p.y;\n    d = max(d,p.y-6.0);\n    d = max(d,-p.y-5.0);\n    d -= 0.05*pow(0.5+0.5*sin(atan(q.x,q.z)*16.0),2.0);\n    d -= 0.15*pow(0.5+0.5*sin(q.y*3.0+0.6),0.12) - 0.15;\n    ma = floor(50.0*hash1( id + 11.2*floor(0.25 + (q.y*3.0+0.6)/6.2831) ));\n    d *= 0.85;\n    vec3 w = vec3(q.x,abs(q.y-0.3)-5.5, q.z );\n    d = min( d,  sdBox(w,vec3(1.4,0.2,1.4)+sign(q.y-0.3)*vec3(0.1,0.05,0.1))-0.1 ); // base\n    d = max( d, -sdBox(p,vec3(14.0,10.0,6.0)) ); // clip in\n\n    // floor\n    p.y -= 0.1;\n    float bb1 = op.y+7.0;\n    if( bb1<d ) //  bounding plane\n    {\n        vec2 id0 = round(p.xz/4.0);\n        vec2 off = step(vec2(0.0), p.xz/4.0-id0);\n        for( int j=0; j<2; j++ )\n        for( int i=0; i<2; i++ )\n        {\n            vec2 id = id0 + vec2(i,j) - off;\n            id = clamp( id, -vec2(4.0,3.0), vec2(4.0,3.0) );\n            vec2 ce = id*4.0;\n            q = p-vec3(ce.x,0.0,ce.y);\n\n            float ra = 1.0*0.05 * hash1(id+vec2(1.0,3.0));\n            float b = sdBox( q-vec3(0.0,-6.0-ra,0.0), vec3(2.0,0.5,2.0)-0.1-ra )-0.1;\n            if( b<d ) { d = b; ma = floor(20.0*hash1(id)); }\n        }\n    }\n\n    float bb2 = op.y+8.0;\n    if( bb2<d ) //  bounding plane\n    {\n        p.xz -= 2.0;\n        \n        vec2 id0 = round(p.xz/4.0);\n        vec2 off = step(vec2(0.0), p.xz/4.0-id0);\n        for( int j=0; j<2; j++ )\n        for( int i=0; i<2; i++ )\n        {\n            vec2 id = id0 + vec2(i,j) - off;\n            id = clamp( id, -vec2(5.0,4.0), vec2(4.0,3.0) );\n            vec2 ce = id*4.0;\n            q = p-vec3(ce.x,0.0,ce.y);\n            \n            float ra = 0.15 * hash1(id+vec2(1.0,3.0)+23.1);\n            float b = sdBox( q-vec3(0.0,-7.0-ra,0.0), vec3(2.0,0.6,2.0)-0.1-ra )-0.1;\n            if( b<d ) { d = b; ma = floor(20.0*hash1( id + 13.5 )); }\n        }\n        p.xz += 2.0;\n    }    \n     \n    float bb3 = op.y+9.0;\n    if( bb3<d ) //  bounding plane\n    {\n        vec2 id0 = round(p.xz/4.0);\n        vec2 off = step(vec2(0.0), p.xz/4.0-id0);\n        for( int j=0; j<2; j++ )\n        for( int i=0; i<2; i++ )\n        {\n            vec2 id = id0 + vec2(i,j) - off;\n            id = clamp( id, -vec2(5.0,4.0), vec2(5.0,4.0) );\n            vec2 ce = id*4.0;\n            q = p-vec3(ce.x,0.0,ce.y);\n\n            float ra = 0.15 * hash1(id+vec2(1.0,3.0)+37.7);\n            float b = sdBox( q-vec3(0.0,-8.0-ra-1.0,0.0), vec3(2.0,0.6+1.0,2.0)-0.1-ra )-0.1;\n            if( b<d ) { d = b; ma = floor(20.0*hash1( id*7.0 + 31.1 )); }\n        }\n    }\n\n    // roof\n    float bb4 = -(op.y-4.0);\n    if( bb4<d ) //  bounding plane\n    {\n        {\n        float id1;\n        q = vec3(p.x,p.y,abs(p.z))-vec3(0.0,0.0,9.0);\n        q.x = opRepLim( q.x, 4.0, 4.0, 4.0, id1 );\n        float b = sdBox( q-vec3(0.0,7.0,0.0), vec3(1.95,1.0,0.95)-0.1 )-0.1;\n        if( b<d ) { d = b; ma = floor(20.0*(id1+6.0)); }\n        }\n        {\n        float id1;\n        q = vec3(abs(p.x)+1.0,p.y,p.z-2.0)-vec3(17.0,0.0,0.0);\n        q.z = opRepLim( q.z, 4.0, 2.0, 1.0, id1 );\n        float b = sdBox( q-vec3(0.0,7.0,0.0), vec3(1.95,1.0,1.95)-0.1 )-0.1;\n        if( b<d ) { d = b; ma = floor(30.0*(id1+6.0)); }\n        }\n\n        q = p; q.xz = opRepLim( q.xz+0.5, 1.0, vec2(18,10),vec2(19,11), id );\n        float b = sdBox( q-vec3(0.0,8.0,0.0), vec3(0.45,0.2,0.47)-0.05 )-0.05;\n        if( b<d ) { d = b; ma = floor(20.0*hash1( id + 7.8 )); }\n\n        b = sdRhombus( p.yz-vec2(8.2,0.0), vec2(3.0,10.8), 0.0 ) ;\n        b = opExtrussion( b, p.x, 19.0-0.1 )-0.1;\n        q = vec3( mod(p.x+1.0,2.0)-1.0, p.y, mod(p.z+1.0,2.0)-1.0 );\n        b = max( b, -sdBox( vec3( abs(p.x)-20.0,p.y,q.z)-vec3(0.0,8.0,0.0), vec3(2.0,5.0,0.1) )-0.05 );\n        b = max( b, -p.y+8.2 );\n        \n        float bma = 13.0;\n        float c = sdRhombus( p.yz-vec2(8.2,0.0), vec2(2.25,8.7), 0.05 );\n        c = opExtrussion( c, abs(p.x)-19.0, 2.0 );\n        if( -c>b ) { b=-c; bma = 12.0; }\n        \n        b = max( b,-sdBox(p-vec3(0.0,9.5,0.0),vec3(15.0,2.0,9.0)) );\n        if( b<d ) { d=b; ma=bma; }\n    }\n\n    return d;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}