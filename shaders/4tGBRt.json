{
    "Shader": {
        "info": {
            "date": "1543535028",
            "description": "A GPU-based entry for the Digital Legends Entertainment christmas tree decoration competition.",
            "flags": 0,
            "hasliked": 0,
            "id": "4tGBRt",
            "likes": 2,
            "name": "Christmas Pong",
            "published": 3,
            "tags": [
                "tree",
                "digital",
                "compo",
                "competition",
                "dle",
                "legends",
                "decoration"
            ],
            "usePreview": 0,
            "username": "merry",
            "viewed": 459
        },
        "renderpass": [
            {
                "code": "const float kToneMapA =.15;\nconst float kToneMapB =.50;\nconst float kToneMapC =.10;\nconst float kToneMapD =.20;\nconst float kToneMapE =.02;\nconst float kToneMapF =.30;\nconst float kToneMapW =.8;\n\nvec4 tonemap(vec4 x)\n{\n   return ( (x * (kToneMapA * x + kToneMapC * kToneMapB) + kToneMapD * kToneMapE)  /\n            (x * (kToneMapA * x + kToneMapB            ) + kToneMapD * kToneMapF)) -\n            kToneMapE / kToneMapF;\n}\n\n    const float kNearPlaneDist =   0.1;\t\nconst float kFarPlaneDist  =  50.0;\t\nconst float kEpsilon       = 0.001;\t\nconst float kPi\t\t\t   = 3.14159265359;\nconst int   kMaxSteps      =    128;\nconst int   kMaxLightSteps =    16; \nconst float kAmbientLevel  = .01;\nconst vec3  kAmbientColor  = vec3(.1,.1,.3);\n\nfloat sdSphere(vec3 p, float s) { return length(p) - s; }\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n \tfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nvec3 opRot(vec3 p, float a) { return vec3(cos(a) * p.xy + sin(a) * vec2(p.y, -p.x), p.z); }\n\n\n\n\n#define MIN(dst, src) dst = mix(src, dst, step(dst.x, src.x))\nvec2 map(vec3 pos)\n{\n    vec2  a = vec2(kFarPlaneDist - 40., 0.), b = a;\n    \nvec3 rotpos=pos;\n    rotpos.x += (length(mod(iTime, 4.)-2.)-1.)*3.;\n    rotpos.y -= -1.+abs(sin(iTime*5.))*1.5;\nrotpos=opRot(rotpos.xyz,-kPi*.5+sin(iTime)*.3);\nrotpos=opRot(rotpos.zyx,iTime);\nrotpos=opRot(rotpos.yzx,kPi+sin(iTime+.3)*.2);\n\n    \n    b = vec2(sdSphere(rotpos, 2.0), 1.); MIN(a, b);\n    b = vec2(sdCappedCylinder(rotpos+vec3(0,-2,0), vec2(.3, .3)), 2.); MIN(a,b);\n    b = vec2(sdTorus(rotpos.xzy+vec3(0,0,-2.5), vec2(.4, .02)), 2.); MIN(a, b);\n\treturn a;\n}\n\nvec2  gTexelSize  ;\nfloat gTexelRadius; \n\nvec4 castRay(vec3 ro, vec3 rd)\n{\n\tgTexelSize    = 1. / iResolution.xy;\n\tgTexelRadius  = length(gTexelSize) ;\n    \n    float t   = kNearPlaneDist, stepLength = 0., prevRad = kFarPlaneDist, prevErr = kFarPlaneDist, err, k = 1.2;\n    vec2  res = vec2(kFarPlaneDist, 0);\n\tint   r   = kMaxSteps;\n    for (int i = 0; i < kMaxSteps; ++i)\n    {\n        if (i < 0) break;\n        if (t >= kFarPlaneDist) break;\n        res = map(ro + rd * t);\n        bool  sor = (k > 1.) && ((prevRad + res.x) < stepLength);\n        if (sor)\n        {\n            stepLength-= k * stepLength;\n            k = 1.;            \n        }        \n        else\n            stepLength = res.x * k;\n\n        prevRad = res.x;\n        err = res.x / t;\n        if (!sor)\n        {\n            if (err < prevErr     ) { res.x = t; prevErr = err; }\n            if (err < gTexelRadius) break;\n        }\n        t  += stepLength;\n    }\n    return vec4(t, res.xy, kMaxSteps - r);\n}\n\n\n\n\nvoid nuv (vec3 p, vec3 rd, vec3 rdy, out vec3 n, out vec3 u, out vec3 v)\n{\n   \tvec2 e = vec2(.0001, -.0001);\n\tvec4 o = vec4(map(p + e.xyy).x, map(p +  e.yyx).x, map(p + e.yxy).x, map(p + e.xxx).x);\n\tn = (o.wzy + o.xww - o.zxz - o.yyx) / (4. * e.x);\n\n    vec3 dpdy = (rdy * dot(rd, n) / dot(rdy, n) - rd);\n    \n    u = normalize(cross(dpdy, n));\n    v = cross(n, u);\n}\n\n\nmat3 computeCameraMatrix(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3 (sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\n\nstruct TMaterial { vec3 mAlbedo; float mRoughness; float mAnisotropy; float mReflectivity; float mFresnel; float mMetalness; };\n/*\n    const TMaterial[3] gMaterials = TMaterial[3]\n    (\n        TMaterial(vec3(0,0,0), 0.0, 0.0, 0.0, 0.0, 0.0),\n        TMaterial(vec3(3,0,0), 0.4, 0.0, 1.0, 0.4, 0.0),\n        TMaterial(vec3(237,206,137)/64., 0.4, 0.5, 1.0, 0.3, 1.0)\n        );\n*/    \n\nTMaterial GetMaterialAt(int matID)\n{\n        if (0 == matID) return TMaterial(vec3(0,0,0), 0.0, 0.0, 0.0, 0.0, 0.0); \n        if (1 == matID) return TMaterial(vec3(3,0,0), 0.4, 0.0, 1.0, 0.4, 0.0);\n        if (2 == matID) return TMaterial(vec3(237,206,137)/64., 0.4, 0.5, 1.0, 0.3, 1.0);\n        return TMaterial(vec3(0),0.,0.,0.,0.,0.);\n}\n\nvec3 GetLightPosAt(int litID)\n{\n\t\tif (0 == litID) return vec3(4, 5,4);\n\t    if (1 == litID) return vec3(5, 5, 8);\n        return vec3(0);\n}\n\nvec3 GetLightColAt(int litID)\n{\n    \tif (0 == litID) return vec3(1,.75,.5)*.5;\n\t\tif (1 == litID) return vec3(.5,.75, 1)*.5;\n\t\treturn vec3(0);\n}\n\n/*\nvec3[2] gLightPos   = vec3[2](vec3(4, 5,4), vec3(5, 5, 8));\nvec3[2] gLightCol   = vec3[2](vec3(1,.75,.5)*.5, vec3(.5,.75, 1)*.5);\n*/\nvec3   gAmbientCol = vec3(.1,.2,.3);\nfloat sq(float a) { return a*a;}\n\nvec3 computeSpecular(vec3 ro, vec3 vv, vec3 p, vec3 n, vec3 u, vec3 v, int matID, int lightID)\n{\n    TMaterial mat = GetMaterialAt(matID);\n    vec3 lightCol = GetLightColAt(lightID);\n    vec3 lp = GetLightPosAt(lightID);\n    vec3 l  = normalize(lp - p);\n    vec3 h  = normalize(vv + l);\n\nfloat F0 = mat.mFresnel;\nfloat f = pow( 1.0 - dot(vv,h), 5. ) * (1.0 - F0) + F0;\n \n    float a = mat.mRoughness;\n\n    float a2=sq(a);\n    float aspect = sqrt(1. - mat.mAnisotropy*.9); \n    float ax   = max(.001, sq(a2)/aspect);\n    float ay   = max(.001, sq(a2)*aspect);\n    float d   = 1. / (kPi * ax * ay * sq(sq(dot(h, u) / ax) + sq(dot(h, v) / ay) + dot(n,h) * dot(n,h)));\n        \n    float k = (mat.mRoughness+1.)*(mat.mRoughness+1.)/8.;\n    \nfloat g=     sq(1. / (dot(h , l) * (1. - a2 * .5) + a2 * .5));\n        vec3 cuv = reflect(normalize(p-ro),n);\n\nvec3 baseColor = \n    lightCol * (1.0 - mat.mMetalness) \n    + lightCol * mat.mAlbedo * mat.mMetalness;\n    \n    return \ntexture(iChannel0, cuv, .5+mat.mRoughness*1./mat.mReflectivity).xyz*f * baseColor        \n+texture(iChannel1, cuv, mat.mRoughness*1./mat.mReflectivity).xyz*f * baseColor        \n        + baseColor * d*g*f/kPi;\n}\n\nvec3 computeDiffuse(vec3 n, vec3 v,int matID, int lightID)\n{\n    TMaterial mat = GetMaterialAt(matID);\n    return \n    ((max(0., dot(n, v)) * GetLightColAt(lightID) * mat.mAlbedo / kPi)\n        +  mat.mAlbedo * kAmbientLevel * kAmbientColor\n     )\n        * (1.- mat.mMetalness)\n     ;\n    \n}\n\nvec3 pad(vec2 p, vec2 s, vec2 uv)\n{\n    return\n\t((uv.x >= (p.x - s.x*.5)) &&\n    (uv.x <= (p.x + s.x*.5)) && \n\t(uv.y >= (p.y - s.y*.5)) &&\n    (uv.y <= (p.y + s.y*.5))) ? vec3(10): vec3(0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy; \n\tvec2 p  = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y; \n        vec2 qv  = uv * 2. - 1.;\n    vec3 pos, nor, uu, vv, col;\n    vec4 res;\n\n\n    vec3 ro =vec3(0,0,9);\n    vec3 ta = vec3(0);\n    mat3 ca = computeCameraMatrix(ro, ta, 0.0);\n    vec3 rd = ca * normalize(vec3(p.xy,  2.5));\n    vec3 rdy = ca * normalize(vec3(p.xy + vec2(0, 1./iResolution.y), 2.5));\n    \n    res = castRay(ro, rd);\n    pos = ro + rd * res.x;    \n    \n  \n    float coneSize  = tan(kPi / 6.) / (iResolution.y);\n    float error     = 0.;\n    for (int  i = 0; i < 3; ++i)\n    {\n        pos    -= rd *    (error - map(pos).x);\n        error   = coneSize * length(ro  - pos);\n    }\n\n \n    nuv(pos, rd, rdy, nor, uu, vv);\n    \n  \n    if (0 != int(res.z))\n    {\n    for (int i = 0; i < 2; ++i)\n    {\ncol+= computeSpecular(ro, -rd, pos, nor, uu, vv, int(res.z),i);\ncol+= computeDiffuse(nor, -rd, int(res.z), i);\n        \n        col = mix(col, vec3(1), pow(abs((length(mod(iTime, 4.)-2.)-1.)),100.));\n        \n    }\n    }\n    else\n        \n    {\n        col = mix(vec3(.3,.4,.5), vec3(.1,.3,.6), uv.y);\n        if ((p.x > -.05) && (p.x < .05))\n            col += step(mod(p.y+.05,.2), .1) * vec3(1);\n        col+=pad(vec2(-1.54,(sin(iTime*2.))*.35),vec2(.1,.75),p);\ncol+=pad(vec2(1.54,(sin(iTime*3.))*.4),vec2(.1,.75),p);\n}\n    col+=.15*pow(res.w/25.,2.);\n    \n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n float tone = max(max(col.x, col.y), col.z);\n\tvec4 rgba = col.xyzz * tonemap(vec4(tone)) / tonemap(vec4(kToneMapW)); // Tonemapping.\n    rgba = rgba* (1./ pow(1. + pow(sqrt(dot(qv, qv)) * .3, 3.), 22.)); // Vignetting.\n    //col = pow(col, vec4(1./2.2)); // CorrecciÃ³n Gamma.    \nrgba*=min(mod(fragCoord.y,3.)+.5,1.);\n    fragColor = rgba;\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}