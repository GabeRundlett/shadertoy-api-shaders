{
    "Shader": {
        "info": {
            "date": "1667896008",
            "description": "I saw this YouTube video and I was inspired to experiment with slime mold simulation.\nhttps://youtu.be/X-iSQQgOd1A\n*mouse to clear trails*\n*space to reset*\n*left and right arrow keys to switch demos*",
            "flags": 48,
            "hasliked": 0,
            "id": "Ddj3RG",
            "likes": 20,
            "name": "Slime Mold Variations",
            "published": 3,
            "tags": [
                "2d",
                "voronoi",
                "simulation",
                "particles",
                "slime",
                "mold",
                "slimemold"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 522
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  I saw this YouTube video and I was inspired to experiment with slime mold simulation.\n//\n//      https://youtu.be/X-iSQQgOd1A\n//\n//  The idea is that particles are attracted to their own trails, and repelled by\n//  trails of different colors. Up to four colors are supported (one per channel).\n//\n//  I tried to find some settings and color combinations that looked cool together,\n//  and I'm cycling between 14 demos defined at the bottom of the common tab. You can\n//  change demos with the left and right arrow keys, clear trails with the mouse, and\n//  reset everything with space.\n// \n//  Buffer A computes the particle positions and neighbors\n//  Buffer B does a traditional voronoi search to help out building neighborhoods\n//  Buffer C renders the particles\n//\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    \n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    \n    initGlobals(iResolution, state);\n    \n    vec4 colors = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor.xyz = sqrt(max(max(max(colors.r * g_ColorR,\n                         colors.g * g_ColorG),\n                         colors.b * g_ColorB),\n                         colors.a * g_ColorA));\n    fragColor.w = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//global variables, initialized per demo\nint g_MaxParticles = 100000; \nfloat g_ParticleSize = .03;\nfloat g_ParticleSpeed = .005;\nfloat g_ParticleTurn = .8;\nvec3 g_ColorR, g_ColorG, g_ColorB, g_ColorA;\nint g_NumColors = 2;\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return (p + 1.0) * 0.5 * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution) * 2.0 - 1.0;\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution, out vec2 closest)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy / resolution.y;\n    return dot(closestDelta, closestDelta);\n}\n\nfloat distanceFromWalls(vec2 point, vec3 resolution, float time)\n{\n    float minDist = 1e30;\n    minDist = min(minDist, point.x + resolution.x / resolution.y);\n    minDist = min(minDist, resolution.x / resolution.y - point.x);\n    minDist = min(minDist, point.y + 1.0);\n    minDist = min(minDist, 1.0 - point.y);\n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution, float time )\n{\n\tvec2 tinyChangeX = vec2( 0.001, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + tinyChangeX, resolution, time ); \n    float downTinyChangeInX = distanceFromWalls( point - tinyChangeX, resolution, time ); \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = distanceFromWalls( point + tinyChangeY, resolution, time ); \n    float downTinyChangeInY = distanceFromWalls( point - tinyChangeY, resolution, time ); \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define POS_VEL 0\n#define NUM_PARTICLE_DATA_TYPES 1\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n\n    fxParticle particle;\n    particle.pos = particleData0.xy;\n    particle.vel = particleData0.zw;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nconst float PI = 3.141592653589793;\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n#define KEY_LEFT 37\n#define KEY_RIGHT 39\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nvec4 colorFromId(int id)\n{\n    int index = id % g_NumColors;\n    \n    switch (index)\n    {\n    case 0: return vec4(1,0,0,0);\n    case 1: return vec4(0,1,0,0);\n    case 2: return vec4(0,0,1,0);\n    case 3: return vec4(0,0,0,1);\n    }\n}\n\nstruct Demo\n{\n    float used;\n    float size;\n    float speed;\n    float turn;\n    int colors;\n    vec3 colorR;\n    vec3 colorG;\n    vec3 colorB;\n    vec3 colorA;\n};\n\nconst int NUM_DEMOS = 14;\nDemo DEMOS[NUM_DEMOS] = Demo[](\n    Demo( .5,   .003, .002, 1.2, 4, vec3(.8,.3,0),   vec3(.7,.6,.3),  vec3(0,.2,.7),  vec3(.9,.3,.6)), // intro\n    Demo( .01,  .01,  .01,   .5, 1, vec3(0,.4,.1),   vec3(0),         vec3(0),        vec3(0)),        // oscilloscope\n    Demo( .003, .01,  .003,  .3, 2, vec3(0,1,1),     vec3(1,0,0),     vec3(0),        vec3(0)),        // branching\n    Demo( .003, .01,  .003,  .9, 3, vec3(0,1,1),     vec3(1,0,0),     vec3(1, .7, 0), vec3(0)),        // looping\n    Demo(1.,    .004, .005,  .5, 3, vec3(0,.2,.6),   vec3(.6,0,.3),   vec3(.2,.6,.6), vec3(0)),        // blizzard\n    Demo(1.,    .004, .001, 1. , 4, vec3(.8,.7,.6),  vec3(.9,.8,.1),  vec3(.9,.5,.0), vec3(.5,0,0)),   // solar flare\n    Demo( .8,   .005, .005, 1.5, 1, vec3(1,.2,.1),   vec3(0),         vec3(0),        vec3(0)),        // fire\n    Demo( .4,   .01,  .001,  .5, 2, vec3(.6,.1,.05), vec3(.2,.3,.1),  vec3(0),        vec3(0)),        // sprouting\n    Demo( .4,   .007, .001,  .5, 4, vec3(.5,0,0),    vec3(.1,.2,.0),  vec3(.3,.5,.4), vec3(.5,.2,1)),  // celestial\n    Demo( .01,  .01,  .002,  .5, 3, vec3(.3,.2,.1),  vec3(.2,.3,.1),  vec3(.2,.5,.3), vec3(0)),        // arboreal\n    Demo(1.,    .005, .001,  .9, 4, vec3(.2,.2,.5),  vec3(.3,.3,.5),  vec3(.4,.4,.5), vec3(.5)),       // climactic\n    Demo( .2,   .01,  .005, 1.5, 2, vec3(.05,.1,.2), vec3(.1,.2,.05), vec3(0),        vec3(0)),        // two-color slow\n    Demo( .05,  .007, .01,  1.5, 2, vec3(0,.4,0),    vec3(.4,0,.2),   vec3(0),        vec3(0)),        // two-color fast\n    Demo( .05,  .007, .003,  .3, 1, vec3(.6,.8,1),   vec3(0),         vec3(0),        vec3(0))         // ice\n);\n\nvoid initGlobals(vec3 res, vec4 state)\n{\n    Demo demo = DEMOS[int(state.w) % NUM_DEMOS];\n    Demo nextDemo = DEMOS[int(state.w + 1.) % NUM_DEMOS];\n    \n    float used = fract(state.w) > .9 ? min(demo.used, nextDemo.used) : demo.used;\n    g_MaxParticles = int(res.x * res.y * used) / NUM_PARTICLE_DATA_TYPES;\n    \n    float transition = smoothstep(.9, 1., fract(state.w));\n    g_NumColors = demo.colors;\n    g_ParticleSize = mix(demo.size, nextDemo.size, transition);\n    g_ParticleSpeed = mix(demo.speed, nextDemo.speed, transition);\n    g_ParticleTurn = mix(demo.turn, nextDemo.turn, transition);\n    g_ColorR = mix(demo.colorR, nextDemo.colorR, transition);\n    g_ColorG = mix(demo.colorG, nextDemo.colorG, transition);\n    g_ColorB = mix(demo.colorB, nextDemo.colorB, transition);\n    g_ColorA = mix(demo.colorA, nextDemo.colorA, transition);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Computes particle positions and velocities\n// ---------------------------------------------------------------------------------------\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    initGlobals(iResolution, state);\n\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;    \n\n    fxParticle data = fxGetParticle(id);\n    \n    if (iFrame == 0 || state.x < 0. || id >= g_MaxParticles)\n    {\n        vec3 h = hash3(uvec3(iFragCoord.x*iFragCoord.y, iFragCoord.y, iFrame*iFragCoord.x));\n        vec3 h2 = hash3(uvec3(iFragCoord.y, iFrame + int(iDate.w), iFragCoord.x));\n        data.pos = vec2(iResolution.x / iResolution.y, 1) * (h2.xy * 2. - 1.);\n        data.vel = g_ParticleSpeed*normalize((vec2(h.x, h.y) - .5));\n    }\n    else\n    {\n        // probe the density texture ahead of us, to the left and to the right\n        vec2 p = data.pos * .5 * vec2(iResolution.y / iResolution.x, 1) + .5;\n        vec4 fwdC = texture(iChannel2, p + data.vel * 2.);\n        vec2 leftV = data.vel * rot2(g_ParticleTurn);\n        vec4 leftC = texture(iChannel2, p + leftV * 3.);\n        vec2 rightV = data.vel * rot2(-g_ParticleTurn);\n        vec4 rightC = texture(iChannel2, p + rightV * 2.);\n        \n        vec4 color = colorFromId(id);\n        color = color * 2. - 1.;\n        \n        float fwd = dot(color, fwdC);\n        float left = dot(color, leftC);\n        float right = dot(color, rightC);\n\n        // turn towards our color and away from other colors\n        if (fwd < left || fwd < right)\n        {\n            if (left < right)\n            {\n                data.vel = mix(data.vel, rightV, 0.3*right / (fwd + right));\n            }\n            else\n            {\n                data.vel = mix(data.vel, leftV, 0.3*left / (fwd + left));\n            }\n        }\n\n        // always move at g_ParticleSpeed\n        if (length(data.vel) > 1e-10)\n        {\n            data.vel = normalize(data.vel) * g_ParticleSpeed;\n        }\n        else\n        {\n                    \n            vec3 h = hash3(uvec3(iFragCoord.x*iFragCoord.y, iFragCoord.y, iFrame*iFragCoord.x));\n            data.vel = g_ParticleSpeed*normalize((vec2(h.x, h.y) - .5));\n        }\n\n        // integrate position\n        data.pos = data.pos + data.vel;\n\n        // boundary\n        float distToScene = distanceFromWalls(data.pos, iResolution, iTime);\n        float distToSceneOld = distanceFromWalls(data.pos, iResolution, iTime - iTimeDelta);\n        vec2 distNormal = getNormalFromWalls(data.pos, iResolution, iTime);\n\n        if (distToScene < 0.001)\n        {\n            data.pos = clamp(data.pos, vec2(-iResolution.x / iResolution.y, -1.0), vec2(iResolution.x / iResolution.y, 1.0));\n            float dp = dot(data.vel, distNormal);\n            if (dp < 0.)\n            {\n                data.vel = reflect(data.vel, distNormal);\n            }\n        }\n\n    }\n\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Computes the nearest particles to each screen pixel\n// ---------------------------------------------------------------------------------------\n\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = (fxGetParticleData(id, POS_VEL).xy * vec2(iResolution.y / iResolution.x, 1.0))-fragCoord;\n    return dot(delta, delta);\n}\n\nconst float FRAMES_PER_DEMO = 1000.;\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    initGlobals(iResolution, state);\n\n    if (ivec2(fragCoord) == ivec2(0))\n    {\n        if (iResolution.x * iResolution.y != abs(state.x) || iFrame == 0 || keyDown(KEY_SPACE))\n        {\n            state = vec4(-iResolution.x * iResolution.y, .5, .5, 0);\n        }\n        else\n        {\n            state.x = abs(state.x);\n\n\n            state.w += 1. / FRAMES_PER_DEMO;\n            \n            if (keyClick(KEY_LEFT))\n            {\n                state.w = trunc(state.w - 1.);\n            }\n            if (keyClick(KEY_RIGHT))\n            {\n                state.w = trunc(state.w + 1.);\n            }\n        }\n        \n        fragColor = state;\n        return;\n    }\n    \n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    \n    if (iFrame > 0)\n    {\n        //in this vector the distance to these particles will be stored \n        vec4 dis = vec4(1e6);\n\n        int RANGE = 2;\n        for(int x=-RANGE; x<=RANGE; x++){\n            for(int y=-RANGE; y<=RANGE; y++){\n                ivec4 old   = fxGetClosest( iFragCoord + ivec2( x, y) );      \n\n                for(int j=0; j<4; j++){\n                    int id = old[j];\n                    float dis2 = distance2Particle(id, screen2world(fragCoord));\n                    insertion_sort( new, dis, id, dis2 );\n                }\n            }\n        }\n\n        int searchIterations = 3;\n        if (iFrame < 5)\n        {\n            searchIterations = 10;\n        }\n        for(int k = 0; k < searchIterations; k++){\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y) +\n                k\n            );\n\n            int p = int(h*float(g_MaxParticles));\n            insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n        }\n    }\n    \n    fragColor = vec4(new); \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Particle render\n// ---------------------------------------------------------------------------------------\n\nvoid renderParticle(in fxParticle p, int id, in vec2 fragCoord, inout vec4 fragColor)\n{   \n    vec2 closest;\n    p.pos.x *= iResolution.y / iResolution.x;\n    float dist = linePointDist2(p.pos, p.pos - 1.5 * p.vel, fragCoord, iResolution, closest);\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, g_MaxParticles);\n\n    vec4 color = colorFromId(id) *.03;\n    fragColor += color * max(0.0, g_ParticleSize - sqrt(dist)) / g_ParticleSize;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    initGlobals(iResolution, state);\n    fragColor = vec4(0.0);\n  \tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n        \n    // diffuse colors\n    for (int x = -1; x <= 1; ++x)\n    for (int y = -1; y <= 1; ++y)\n    {\n        vec4 n = texelFetch(iChannel2, ivec2(fragCoord) + ivec2(x, y), 0);\n        fragColor += n / (1.08 + 100.*dot(vec2(x, y), vec2(x, y)));\n    }\n\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n    \n    // draw the particles\n    for(int i = 0; i < 4; i++)\n    {\n        int id = ids[i];\n        if (id < 0 || id >= g_MaxParticles) continue;\n        fxParticle particle = fxGetParticle(id);\n\n        renderParticle(particle, id, p, fragColor);\n    }\n    \n    // reset\n    if (iFrame == 0 || state.x < 0. ||\n        (iMouse.z > 0. && distance(fragCoord, iMouse.xy) < 0.1*iResolution.y))\n    {\n        fragColor = vec4(0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}