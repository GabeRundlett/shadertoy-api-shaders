{
    "Shader": {
        "info": {
            "date": "1639136718",
            "description": "It's been a while since I wrote a simple effect.",
            "flags": 0,
            "hasliked": 0,
            "id": "NldSD4",
            "likes": 9,
            "name": "光の鞠 -- Light Ball",
            "published": 3,
            "tags": [
                "pattern"
            ],
            "usePreview": 0,
            "username": "IWBTShyGuy",
            "viewed": 309
        },
        "renderpass": [
            {
                "code": "// Copyright © 2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\nconst int UN = 40;\nconst int VN = 16;\n\nvec2 nearUVN(in vec3 p, in float radius) {\n    vec3 n = normalize(p);\n\n    vec2 x = normalize(n.zx);\n    float u = acos(clamp(x.x, -1.0, 1.0)) * sign(x.y);\n    float v = n.y;\n\n    float un = floor(float(UN) * radius);\n    u = (1.0 + u / PI) * 0.5;\n    u = floor(u * un + 0.5);\n\n    float vn = floor(float(VN) * radius);\n    v = (1.0 + v) * 0.5;\n    v = floor(v * vn + 0.5);\n\n    return vec2(u, v);\n}\n\nvec3 getPoint(in vec2 uvn, in float radius) {\n    float un = floor(float(UN) * radius);\n    float vn = floor(float(VN) * radius);\n\n    vec2 uv = vec2(\n        uvn.x / un,\n        clamp(uvn.y, 1.0, vn - 1.0) / vn\n    );\n    uv.x = (2.0 * uv.x - 1.0) * PI;\n    uv.y = 2.0 * uv.y - 1.0;\n    float r = sqrt(1.0 - uv.y * uv.y);\n    return vec3(r * sin(uv.x), uv.y, r * cos(uv.x)) * radius;\n}\n\nfloat halfMap(in Ray ray, in vec3 p0, in float radius) {\n    float c0 = 0.0;\n    vec2 uvn0 = nearUVN(p0, radius);\n    for (int i = 0; i < 49; i++) {\n        vec2 e = vec2(i / 7 - 3, i % 7 - 3);\n        vec3 p = getPoint(uvn0 + e, radius);\n        float dist = dot(p - ray.origin, ray.direction);\n        dist = length(ray.origin + dist * ray.direction - p);\n        float c = clamp(1.0e-4 / (1.0e-5 + dist * dist), 0.0, 1.0);\n        dist = clamp(dist / 0.05, 0.0, 1.0);\n        dist = dist * dist;\n        c = mix(c * c, 0.0, dist);\n        c0 = max(c0, c);\n    }\n    return c0;\n}\n\nfloat sphereMap(in Camera camera, in vec2 uv, in float theta, in float radius) {\n    Ray ray = cameraRay(camera, uv);\n\n    ray.origin = rot(vec3(0, 1, 0), theta) * ray.origin;\n    ray.direction = rot(vec3(0, 1, 0), theta) * ray.direction;\n\n    float midDist = -dot(ray.origin, ray.direction);\n    float r0 = length(ray.origin + midDist * ray.direction);\n    if (r0 > radius + 0.05) return 0.0;\n\n    float diff = radius + 0.05;\n    diff = sqrt(diff * diff - r0 * r0);\n    vec3 p0 = ray.origin + (midDist - diff) * ray.direction;\n    vec3 p1 = ray.origin + (midDist + diff) * ray.direction;\n\n    float c = 0.0;\n    c = max(c, halfMap(ray, p0, radius));\n    c = max(c, halfMap(ray, p1, radius));\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 dir = normalize(vec3(0, sin(iTime * 0.3) * 0.2, 1));\n    Camera camera = Camera(\n        dir * 3.0,\n        -dir,\n        vec3(0, 1, 0),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n\n    vec2 uv = fragCoord / iResolution.xy;\n    float c = max(\n        sphereMap(camera, uv, -iTime * 0.4, 1.0),\n        sphereMap(camera, uv, iTime * 0.7, 0.7)\n    );\n\n    c = pow(c, 0.4545);\n    fragColor = vec4(c, c, c, 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\nmat3 rot(vec3 axis, float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat3(\n        axis[0] * axis[0] * (1.0 - c) + c,\n        axis[0] * axis[1] * (1.0 - c) + axis[2] * s,\n        axis[0] * axis[2] * (1.0 - c) - axis[1] * s,\n        axis[0] * axis[1] * (1.0 - c) - axis[2] * s,\n        axis[1] * axis[1] * (1.0 - c) + c,\n        axis[1] * axis[2] * (1.0 - c) + axis[0] * s,\n        axis[0] * axis[2] * (1.0 - c) + axis[1] * s,\n        axis[1] * axis[2] * (1.0 - c) - axis[0] * s,\n        axis[2] * axis[2] * (1.0 - c) + c\n    );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}