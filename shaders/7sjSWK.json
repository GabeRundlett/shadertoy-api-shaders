{
    "Shader": {
        "info": {
            "date": "1621084943",
            "description": "Mapping a realtime Belousov-Zhabotinsky reaction onto an extruded hexagon grid. The pattern takes about 20 seconds to stabilize.",
            "flags": 0,
            "hasliked": 0,
            "id": "7sjSWK",
            "likes": 70,
            "name": "Belousov-Zhabotinsky Extrusion",
            "published": 3,
            "tags": [
                "hexagon",
                "diffusion",
                "belousovzhabotinsky",
                "reaction",
                "extrusion"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1418
        },
        "renderpass": [
            {
                "code": "/*\n\n\n    Belousov-Zhabotinsky Extrusion\n    ------------------------------\n\n\tFlexMonkey put together a really cool diffusion based example a while back\n    that I thought was pretty awesome, so I wanted to make a version of it. The\n    original is a Belousov–Zhabotinsky reaction mapped to a 2D hexagonal grid, \n    so I was curious as to how it would look in extruded form.\n    \n    I used a simpler and somewhat less sophisticated method to create the \n    Belousov–Zhabotinsky reaction pattern itself, but it's essentially the same \n    thing -- By the way, the link to FlexMonkey's original is below.\n    \n    Codewise, there's nothing particularly exciting in here, but I thought I'd\n    post it for anyone interested in this kind of thing.\n    \n    \n\n\tBased on:\n    \n\t// FlexMonkey (A.K.A Simon Gladman) has a heap of nice diffusion related \n    // examples on here.\n    Pixelated Belousov–Zhabotinsky - FlexMonkey\n\thttps://www.shadertoy.com/view/ltlfWn \n    \n    Other examples:\n    \n    // A really nice concise version.\n    Belousov-Zhabotinsky Reaction - Cornusammonis\n    https://www.shadertoy.com/view/XtcGD2\n    \n    // The smallest Turing routine you're likely to find. If you set the \n    // texture to multicolor and uncomment the Belousov–Zhabotinsky line,\n    // you'll see a rough hardware version of this pattern.\n    Two Tweet Turing Texture - Shane\n    https://www.shadertoy.com/view/4ldcWS\n\n*/\n\n\n\n// Max ray distance.\n#define FAR 20.\n\n// Hollow out the pylon center -- Kind of intersting.\n//#define HOLLOW\n\n// Flatten the scene, but give the pylons just a tiny variation for lighting.\n//#define FLAT\n\n// Greyscale.\n//#define GREYSCALE\n        \n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// 2D Texture routine.\nvec3 getTex2D(vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iChannel1, fract(p)).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n\n// Cube map texture reader.\nvec3 getTex(vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n  \n    p /= 4.;\n    //p = (mod(floor(p*1024.), 1024.) + .5)/1024.;\n    return texture(iChannel0, vec3(fract(p) - .5, .5)).xyz;\n \n\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(p), vec3(.299, .587, .114)); }\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .025;\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2. );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n\n// Signed distance to a regular hexagon, with a hacky smoothing variable thrown\n// in. -- It's based off of IQ's more exact pentagon method, which is here:\nfloat sHexS(in vec2 p, float r, in float sf){\n    \n  const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n\n  // X and Y reflection.  \n  p = abs(p); \n  p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n   \n \n  r -= sf;\n  // Polygon side.\n  return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r) - sf;\n    \n}\n \n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n    // Scale.\n    //#define STRETCH\n    #ifdef STRETCH\n\tconst vec2 scale = vec2(1./12., 1./16.);\n     // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 l = vec2(scale.x*1.732/2., scale.y);\n    #else\n    const float scale = 1./16.;\n     // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 l = vec2(scale*1.732/2., scale);\n    #endif\n    \n   \n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = l*2.;\n    \n    // Distance.\n    float d = 1e5;\n    // Local coordinates, cell center, and overall cell IDs.\n    vec2 p, cntr, id = vec2(0), idi = vec2(0);\n    \n\n    \n    \n    // Four block corner postions.\n    const vec2 ll = vec2(.5);\n    //vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll, vec2(ll.x, -ll.y));\n    // Pointed top.\n    //vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll + vec2(ll.x, 0), vec2(ll.x, -ll.y) + vec2(ll.x, 0));\n    // Flat top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll + vec2(0., ll.y), -ll, vec2(ll.x, -ll.y) + vec2(0., ll.y));\n    \n    float boxID = 0.; // Box ID. Not used in this example, but helpful.\n    \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.;\n\n        // Local coordinates.\n        p = q3.xy;\n        //ip = floor(p/s - cntr) + .5 + cntr; // Local tile ID.\n        // Correct positional individual tile ID.\n        idi = (floor(p/s - cntr) + .5 + cntr)*s;\n        p -= idi; // New local position.\n\n                    \n \n        // The extruded block height. See the height map function, above.\n        float h = hm(idi)*.5 + .5;\n        \n        // Block width -- Normally set to one, but I'm using the underlying color\n        // to change the width.\n        float w = max(1. - h*h*2.2, .1);\n        \n        // Tempering the height.\n        #ifdef FLAT\n        h *= .05; // Relatively flat. Just a tiny variation for lighting.\n        #else\n        h *= .3;\n        #endif\n        \n        \n            \n        // The hexagonal cross section. The corners are slightly rounded on this\n        // version, but they don't have to be.\n        #ifdef STRETCH\n        vec2 lu = l/vec2(1.732/2., 1);\n        vec2 pStretch = lu.x<lu.y? vec2(1, lu.x/lu.y) : vec2(lu.y/lu.x, 1);\n        float r = min(lu.x, lu.y)/2.;\n        float di2D = sHexS(p*pStretch, r*(.5 - w)*2., .2*r*(.5 - w));\n        #else\n        float di2D = sHexS(p, scale*(.5 - w), .2*scale*(.5 - w));\n        //float di2D = sCylS(p, scale*(.5 - w));\n        #endif\n        \n        #ifdef HOLLOW\n        // Hollow out the pylon center.\n        di2D = abs(di2D + .14*scale) - .14*scale;\n        #endif\n\n        // The extruded distance function value.\n        float di = opExtrusion(di2D, (q3.z + h), h);\n        \n        //di = min(di, length(vec3(p, q3.z + h*2.)) - (scale/2. - w/2.*scale/2.)*.98);\n        di += di2D/6.;\n\n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di<d){\n            d = di;\n            id = idi;\n            // BoxID.\n            boxID = di2D;\n        }\n        \n    }\n    \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, boxID);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec3 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z + .03;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yzw; // Individual block ID.\n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.75 : d; \n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), \n                          map(p + e.yxy) - map(p - e.yxy),\t\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, \n    //anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n/*\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 3.;\n    p.y += iTime;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.4, 1., c); // Putting in some dark space.\n    \n    p = vec3(c, c*c, c*c*c); // Redish tinge.\n    \n    return mix(p, p.xzy, n3D2*.4); // Mixing in a bit of purple.\n\n}\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, iTime/8., -4.25); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, .07, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.5, 2, 3);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .5; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime)/32. );\n\n    \n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    vec3 svGID = gID;\n    \n    float svObjID = objID;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        // Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        //sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n        /*\n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. + dot(sn, rd), 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.     \n        */\n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            // Coloring the individual blocks with the saved ID.\n            \n            vec3 tx = getTex(svGID.xy); // See scale in the distance function.\n            //vec3 tx2 = vec3(hash21(svGID.xy + .1), hash21(svGID.xy + .2), hash21(svGID.xy + .3));\n            vec3 tx2 = getTex2D(svGID.xy/2.); // Texture based color.\n            tx = smoothstep(0., .5, tx);\n            tx2 = smoothstep(0., .5, tx2);\n            \n            #ifdef GREYSCALE\n            // Greyscale value.\n            float gr = clamp(dot(tx*2. - .25, vec3(.299, .587, .114)), 0., 1.);\n            texCol = tx2*gr*1.5;\n            #else\n            // Applying some color. \n            texCol = tx*.8 + .2;\n            texCol = .53 + .42*cos(-texCol*6.2831/2.8 + vec3(0, 1, 2) + 2.5);\n            texCol *= tx2*3.;\n            #endif\n            \n            // Central dots.\n            //vec2 svP = sp.xy - svGID.xy;\n            //texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .005, length(svP) - .04/8.));\n            \n            /*\n            // Hexagonal face value.\n            float ht = (hm(svGID.xy)*.5 + .5)*.3;\n            float hex = svGID.z;\n   \n            float hex2 = hex;\n            hex = max(abs(hex), abs(sp.z + ht*2.)) - .004; // Face border.\n            //hex = min(hex, abs(hex2 + .01) - .00125); // Extra border.\n            // Applying the face border.\n            texCol = mix(texCol, texCol/8., (1. - smoothstep(0., .002, hex)));\n            */\n        }\n        else {\n            \n            // The dark floor in the background. Hiddent behind the pylons, but\n            // you still need it.\n            texCol = vec3(.05);\n        }\n       \n    \t\n   \n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .25 + vec3(1, .7, .4)*spec*2.*sh);\n        \n        // Fake environment mapping.\n        //vec3 cTex = envMap(reflect(rd, sn));\n        //col += col*cTex.zyx*sh*5.;\n\n        // Shading.\n        col *= ao*atten;\n        \n        \n\t\n\t}\n    \n          \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Global scale.\nfloat gSc = 512.;\n\n// IQ's vec2 to float with wrapping.\nfloat hash21(vec2 p) {\n\n    p = mod(p, gSc);\n    return fract(sin(dot(p, vec2(42.5137, 13.7963)))*43758.5453); \n}\n \n// Cube texture read.\nvec4 tx(vec2 p){ \n    \n    return texture(iChannel0, vec3(fract(p) - .5, .5));\n}\n\n/*\n// Blur function. Pretty standard.\nvec4 bTx(in vec2 p, const int N){\n    \n    // Result.\n\tvec4 c = vec4(0);\n    float sum = 0.;\n\n    // NxN blur.\n    for(int i = 0; i<N*N; i++) {\n        vec2 offs = vec2(i/N, i%N) - floor(float(N) - .5)/2.;\n        float l = max(length(vec2(N)/2.) - length(offs), 0.); l *= l;\n        //float l = exp(-(dot(offs, offs)/float(N*N))/2.)/float(N)*.39894;\n        //float l = 1./(1. + dot(offs, offs)*.5);\n        c += tx(p - (offs)/iResolution.y)*l;\n        sum += l;\n    }\n    \n    return c/sum; \n    \n}\n*/\n\n// Circle blur function -- Not as common, but you see it around. Sometimes,\n// taking a sweep at a certain radius can give you a blurrier result\n// without the cost. It's especially efficient when taking the difference\n// between different size filters.\nvec4 bTxCir(in vec2 p, float r){\n    \n\n    // Result.\n\tvec4 c = vec4(0);\n    float sum = 0.;\n    \n    const int N = 12;\n\n    // NxN blur.\n    for(int i = 0; i<N; i++) {\n        float ang = float(i)*6.2831/float(N);\n        vec2 offs = vec2(cos(ang), sin(ang))*r;\n        float l = 1.;//max(length(vec2(N)/2.) - length(offs), 0.); l *= l;\n        //float l = exp(-(dot(offs, offs)/float(N*N))/2.)/float(N)*.39894;\n        //float l = 1./(1. + dot(offs, offs)*.5);\n        c += tx(p - (offs)/iResolution.y)*l;\n        sum += l;\n    }\n    \n    return c/sum; \n    \n}\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    //float a = mod(float(iFrame), 8.)*3.14159/4.;// + rot2(a)*vec2(0, .5)\n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n    \n    gSc = 1.;\n \n    // Pixel storage.\n    vec4 col;\n   \n    // Initial conditions -- Performed upon initiation.\n    if(abs(tx(uv).w - iResolution.y)>.001){\n    \n        // Initial conditions: Fill each channel in each cell with some random values.\n        col = vec4(hash21(uv), hash21(uv + .17), hash21(uv + .23), 1.);\n        col.w = iResolution.y;\n    }\n    else {\n    \n        // A very rough Belousov–Zhabotinsky reaction approximation -- Feel free to look\n        // up the process in detail, but it's similar to many reaction diffusion like\n        // examples: Start off with an initial solution in the form of noise in one or \n        // some of the channels, use filters to blur it over time to similute dispersion,\n        // then mix the result with the previous frame. In this case, we can simulate \n        // non-equilibrium by sprinkling in extra noise for volatility... As mentioned,\n        // there are others on the net and on Shadertoy who can give you more detail, but\n        // that's the general gist of it.\n        \n        // Thinking a little outside the box, it's possible to use a much cheaper \n        // radial boundary blur with a larger radius to mickick a larger block blur. \n        // It doesn't work in all situations, but it works well enough here.\n        vec4 val = bTxCir(uv, 5.); // 12 Taps.\n        val = mix(val, tx(uv), 1./25.); // Adding the center pixel.\n        //vec4 val = bTx(uv, 7); // Box blur: 49 taps -- Requires rescaling.\n        \n        //#if 0\n        // Alternate, simpler equation.\n        //col = clamp(tx(uv) + .08*(val.zxyw - val.yzxw), 0., 1.);\n        //#else\n        float reactionRate = val.x*val.y*val.z; // Self explanitory.\n        //float reactionRate = smoothstep(0., 1., val.x*val.y*val.z); \n\n        // Producing the new value: For an explanation, you can look up the chemical\n        // reaction it pertains to and the mathematical translation which is pretty\n        // interesting. From a visual perspective, however, it's just a cute calculus \n        // based equation that produces a cool pattern over time.\n        vec4 res = val - reactionRate + val*(val.yzxw - val.zxyw);\n        //vec4 params = vec4(1, 1, 1, 0);//\n        //vec4 res = val - reactionRate + val*(params*val.yzxw - params.zxyw*val.zxyw);\n        \n        \n \n\n        // Adding some volatile noise to the system. \n        vec3 t = vec3(1.01, 1.07, 1.03)*fract(iTime);\n        vec4 ns = vec4(hash21(uv + .6 + t.x), hash21(uv + .2 + t.y), hash21(uv + .7 + t.z), 0);\n        \n        // Mixing the new value and noise with the old value. \n        col = mix(tx(uv), res*(.9 + ns*.3), .2*iTimeDelta*60.);\n        //#endif\n        \n \n        // Using the fourth channel to store resolution.\n        col.w = iResolution.y;\n    \n    }\n    \n    // Recording the new value and clamping it to a certain range.\n    fragColor = vec4(clamp(col.xyz, -1., 1.), iResolution.y);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}