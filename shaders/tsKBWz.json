{
    "Shader": {
        "info": {
            "date": "1606942537",
            "description": "I had fun with 2D SDF collisions so I moved up to 3D!",
            "flags": 32,
            "hasliked": 0,
            "id": "tsKBWz",
            "likes": 10,
            "name": "3D SDF Collisions",
            "published": 3,
            "tags": [
                "3d",
                "sdf",
                "physics",
                "collisiondetection"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 401
        },
        "renderpass": [
            {
                "code": "/*\nThis shader uses my Raymarcher Template shader (https://www.shadertoy.com/view/3styDs).\n*/\n\n// Viewing Modes\n//#define CUTAWAY\n// See through has some ugly artifacts but is pretty neat.\n#define SEETHROUGH\n\n// Set to 2 if your computer is fast enough.\n#define ANTIALIASING 1\n\n// Screen variables:\nvec3 backgroundColor = vec3(0.0, 0.0, 0.0);\nvec2 antialiasing = vec2(ANTIALIASING);\n\n// Light variables:\nvec3 lightDirection = normalize(vec3(-1.5, 0.0, 2.0));\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n// Camera variables:\nvec3 cameraPosition = vec3(0.0, 0.0, 1000.0);\nvec3 cameraRight = vec3(1.0, 0.0, 0.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraForward = vec3(0.0, 0.0, -1.0);\nfloat cameraFocalLength = 400.0;\n\n// Ray marching constants:\nconst vec3 GRADIENT_STEP = vec3(0.01, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 1500.0;\nconst float MIN_HIT_DISTANCE = 0.001;\n\n#ifdef CUTAWAY\nconst int MAX_INTERSECTIONS = 1;\n#endif\n\n#ifdef SEETHROUGH\nconst int MAX_INTERSECTIONS = 2;\n#endif\n\nconst int MAX_STEPS = 300;\n\n// Raymarching structures:\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Surface {\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float shininess;\n    float signedDistance;\n};\n\n// Constructive Solid Geometry (CSG) Operators:\nSurface Union(in Surface surface1, in Surface surface2) {\n    Surface surfaceUnion = surface1;\n    if (surface2.signedDistance < surfaceUnion.signedDistance) {\n        surfaceUnion = surface2;\n    }\n    return surfaceUnion;\n}\n\n// Scene mapping function:\nSurface mapScene(in vec3 p) {\n    vec2 mouseRotation = (iMouse.yx - 0.5 * iResolution.yx) * vec2(0.5, -0.5);\n    p = Rotate(p, vec3(mouseRotation, 0.0));\n\n    #ifdef CUTAWAY\n    float cutaway = sdBox(Translate(p, vec3(-15.0)), vec3(200.0, 100.0, 150.0));\n    Surface environment = Surface(vec3(0.0, 0.0, 0.0),\n                                  vec3(0.0, 0.7, 0.9),\n                                  vec3(1.0, 1.0, 1.0), 32.0,\n                                  max(mapEnvironment(p), cutaway));\n    #endif\n\n    #ifdef SEETHROUGH\n    Surface environment = Surface(vec3(0.0, 0.0, 0.0),\n                                  vec3(0.0, 0.7, 0.9),\n                                  vec3(1.0, 1.0, 1.0), 32.0,\n                                  mapEnvironment(p));\n    #endif\n\n    vec3 ballPos = getBallPos();\n    Surface ball = Surface(vec3(0.0, 0.0, 0.0),\n                           vec3(1.0, 0.0, 0.0),\n                           vec3(1.0, 1.0, 1.0), 8.0,\n                           sdBall(Translate(p, ballPos), BALL_RADIUS));\n\n    return Union(environment, ball);\n}\n\n// Normal calculation function (using gradient):\nvec3 calculateNormal(in vec3 p) {\n    float gradientX = mapScene(p + GRADIENT_STEP.xyy).signedDistance - mapScene(p - GRADIENT_STEP.xyy).signedDistance;\n    float gradientY = mapScene(p + GRADIENT_STEP.yxy).signedDistance - mapScene(p - GRADIENT_STEP.yxy).signedDistance;\n    float gradientZ = mapScene(p + GRADIENT_STEP.yyx).signedDistance - mapScene(p - GRADIENT_STEP.yyx).signedDistance;\n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n// Surface shader (uses the Phong illumination model):\nvec3 shadeSurface(in Surface surface, in vec3 hitPosition, in Ray ray, in vec3 normal) {\n    vec3 illuminationAmbient = surface.ambientColor * lightColor;\n\n    float lambertian = max(0.0, dot(normal, lightDirection));\n    vec3 illuminationDiffuse = lambertian * surface.diffuseColor * lightColor;\n\n    vec3 reflection = reflect(lightDirection, normal);\n    float specularAngle = max(0.0, dot(reflection, ray.direction));\n    vec3 illuminationSpecular = clamp(pow(specularAngle, surface.shininess), 0.0, 1.0) * surface.specularColor * lightColor;\n\n    return illuminationAmbient + illuminationDiffuse + illuminationSpecular;\n}\n\n// Raymarching loop:\nvec4 rayMarch(in Ray ray) {\n    float distanceTraveled = 0.0;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    int intersections = 0;\n    for (int steps=0; steps < MAX_STEPS; steps++) {\n        vec3 currentPosition = ray.origin + ray.direction * distanceTraveled;\n        Surface sceneSurface = mapScene(currentPosition);\n        if (abs(sceneSurface.signedDistance) < MIN_HIT_DISTANCE) {\n            vec3 normal = calculateNormal(currentPosition);\n            color += shadeSurface(sceneSurface, currentPosition, ray, normal);\n            distanceTraveled += 20.0;\n            intersections++;\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE || intersections == MAX_INTERSECTIONS) {\n            break;\n        }\n\n        distanceTraveled += sceneSurface.signedDistance;\n    }\n\n    return vec4(color / float(MAX_INTERSECTIONS), 1.0);\n}\n\n// Pixel shader output function:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    for (float yOffset=0.0; yOffset < antialiasing.y; yOffset++) {\n        for (float xOffset=0.0; xOffset < antialiasing.x; xOffset++) {\n            vec2 pixel = fragCoord + vec2(xOffset, yOffset) / antialiasing - 0.5 * iResolution.xy;\n            vec3 rayOrigin = cameraPosition + cameraForward * cameraFocalLength;\n            vec3 rayDirection = normalize(rayOrigin - (cameraPosition - cameraRight * pixel.x - cameraUp * pixel.y));\n            fragColor += rayMarch(Ray(rayOrigin, rayDirection));\n        }\n    }\n\n    fragColor /= antialiasing.y * antialiasing.x;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Starting values:\n    if (ivec2(fragCoord) == ivec2(0, 0)) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n\n    if (ivec2(fragCoord) == ivec2(1, 0)) {\n        fragColor = vec4(-3.0, 3.0, 1.0, 1.0);\n    }\n\n    if (iFrame > 0) {\n        // Update values (after initializing them):\n        vec3 ballPos = getBallPos();\n        vec3 ballVel = getBallVel();\n\n        ballVel.y -= GRAVITY;\n        ballPos += ballVel;\n\n        float distToEnv = mapEnvironment(ballPos);\n        if (distToEnv < BALL_RADIUS) {\n            vec3 hitNormal = getNormal(ballPos);\n            ballPos += hitNormal * (BALL_RADIUS - distToEnv);\n            ballVel = reflect(ballVel, hitNormal);\n            ballVel *= DECAY;\n        }\n\n        if (ivec2(fragCoord) == ivec2(0, 0)) {\n            fragColor = vec4(ballPos, 1.0);\n        }\n\n        if (ivec2(fragCoord) == ivec2(1, 0)) {\n            fragColor = vec4(ballVel, 1.0);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Variable retrieval functions:\n#define getBallPos() texelFetch(iChannel0, ivec2(0, 0), 0).xyz\n#define getBallVel() texelFetch(iChannel0, ivec2(1, 0), 0).xyz\n\n#define BALL_RADIUS 10.0\n\n#define GRAVITY 0.1\n#define DECAY 0.98\n\n// 3D Box SDF Inigo Quilez's 3D SDFs article (https://iquilezles.org/articles/distfunctions):\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdBall(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Transformations:\nvec3 Translate(in vec3 p, in vec3 t) {\n    return p - t;\n}\n\nvec3 Rotate(in vec3 p, in vec3 r) {\n    vec3 rad = radians(-r);\n    vec3 cosRad = cos(rad);\n    vec3 sinRad = sin(rad);\n\n    mat3 xRotation = mat3(1.0,      0.0,       0.0,\n                          0.0, cosRad.x, -sinRad.x,\n                          0.0, sinRad.x,  cosRad.x);\n\n    mat3 yRotation = mat3( cosRad.y, 0.0, sinRad.y,\n                                0.0, 1.0,      0.0,\n                          -sinRad.y, 0.0, cosRad.y);\n\n    mat3 zRotation = mat3(cosRad.z, -sinRad.z, 0.0,\n                          sinRad.z,  cosRad.z, 0.0,\n                               0.0,       0.0, 1.0);\n\n    return zRotation * yRotation * xRotation * p;\n}\n\n// Functions defining the environment the ball bounces in:\nfloat mapEnvironment(in vec3 p) {\n    float wall = abs(sdBox(p, vec3(200.0, 100.0, 150.0))) - 1.0;\n    float box = sdBox(Rotate(Translate(p, vec3(100.0, 0.0, 0.0)), vec3(45.0, 35.0, 0.0)), vec3(50.0));\n    float ballDisplacement = (sin(p.x * 0.1) + sin(p.y * 0.1) + sin(p.z * 0.1)) * 6.0;\n    float ball = sdBall(Translate(p, vec3(-100.0, 0.0, 0.0)), 50.0) + ballDisplacement;\n    return min(wall, min(box, ball));\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapEnvironment(p + vec3(0.001, 0.0, 0.0)) - mapEnvironment(p - vec3(0.001, 0.0, 0.0)),\n                          mapEnvironment(p + vec3(0.0, 0.001, 0.0)) - mapEnvironment(p - vec3(0.0, 0.001, 0.0)),\n                          mapEnvironment(p + vec3(0.0, 0.0, 0.001)) - mapEnvironment(p - vec3(0.0, 0.0, 0.001))));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}