{
    "Shader": {
        "info": {
            "date": "1484594273",
            "description": "tunnel test from iq's demo",
            "flags": 0,
            "hasliked": 0,
            "id": "XtVXWw",
            "likes": 46,
            "name": "Scrolling Squound Tunnel",
            "published": 3,
            "tags": [
                "tunnel",
                "arrows"
            ],
            "usePreview": 0,
            "username": "cacheflowe",
            "viewed": 3494
        },
        "renderpass": [
            {
                "code": "#define PI 3.141592653589793\n#define TAU 6.283185307179586\n\nfloat polygon(vec2 p, int vertices, float size) {\n    float a = atan(p.x, p.y) + 0.2;\n    float b = 6.28319 / float(vertices);\n    return cos(floor(0.5 + a / b) * b - a) * length(p) - size;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.5;\n    \n    //////////////////////////////////////////////////////\n    // Create tunnel coordinates (p) and remap to normal coordinates (uv)\n    // Technique from @iq: https://www.shadertoy.com/view/Ms2SWW\n\t// and a derivative:   https://www.shadertoy.com/view/Xd2SWD\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\t\t// normalized coordinates (-1 to 1 vertically)\n    vec2 uvOrig = p;\n    // added twist by me ------------\n    float rotZ = 1. - 0.07 * sin(1. * sin(length(p * 1.5)));\n    p *= mat2(cos(rotZ), sin(rotZ), -sin(rotZ), cos(rotZ));\n\t//-------------------------------\n    float a = atan(p.y,p.x);\t\t\t\t\t\t\t\t\t\t\t\t// angle of each pixel to the center of the screen\n    float rSquare = pow( pow(p.x*p.x,4.0) + pow(p.y*p.y,4.0), 1.0/8.0 );\t// modified distance metric (http://en.wikipedia.org/wiki/Minkowski_distance)\n    float rRound = length(p);\n    float r = mix(rSquare, rRound, 0.5 + 0.5 * sin(time * 2.)); \t\t\t// interp between round & rect tunnels\n    vec2 uv = vec2( 0.3/r + time, a/3.1415927 );\t\t\t\t\t\t\t// index texture by (animated inverse) radious and angle\n    //////////////////////////////////////////////////////\n\n    // subdivide to grid\n    uv += vec2(0., 0.25 * sin(time + uv.x * 2.));\t\t\t// pre-warp\n    vec2 uvDraw = fract(uv * 7. + 5. * sin(time)) - 0.5;\t// create grid\n\n    // alter polygon direction by pre-rotating coords\n    float rot = PI/2.;\n    uvDraw *= mat2(cos(rot), sin(rot), -sin(rot), cos(rot));\n\n    // draw arrow\n    float antialias = 8./iResolution.y;\n    vec2 rectPos = uvDraw + vec2(0., -0.08);\n    float col = smoothstep(antialias, 0., polygon(rectPos, 4, 0.12)); \t // antialiased rect\n    vec2 triPos = uvDraw + vec2(-0.047, 0.15);\n    col = max(col, smoothstep(antialias, 0., polygon(triPos, 3, 0.12))); // antialiased triangle\n\n    // darker towards center, light towards outer\n    col = col * r * 1.5;\n    col += 0.15 * length(uvOrig);\n    fragColor = vec4(vec3(col), 0.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}