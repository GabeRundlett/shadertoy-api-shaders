{
    "Shader": {
        "info": {
            "date": "1631143271",
            "description": "check out Slowtember by megaelod on IG\nhttps://www.instagram.com/p/CSCRu85jWe0/",
            "flags": 0,
            "hasliked": 0,
            "id": "fdyGRD",
            "likes": 10,
            "name": "Slowtember 07-09: Garden/Texting",
            "published": 3,
            "tags": [
                "slowtember"
            ],
            "usePreview": 0,
            "username": "klemek",
            "viewed": 233
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415927\n#define E .001\n\nfloat n(float c) {\n    return min(1., max(.0, c));\n}\n\nfloat estep(float threshold, float x, float e) {\n    return smoothstep(threshold + e, threshold - e, x);\n}\n\nvec3 n3(vec3 c) {\n    return min(vec3(1), max(vec3(0), c));\n}\n\nvec3 mask(vec3 c0, vec3 c1, float m) {\n    return n3(c0 * (1.0 - m) + c1 * m);\n}\n\nfloat rand(float seed) {\n    float v = pow(seed, 6.0 / 7.0);\n    v *= sin(v) + 1.;\n    return v - floor(v);\n}\n\nvec3 col(float x) {\n    return vec3(\n        .5 * (sin(x * 2. * PI) + 1.),\n        .5 * (sin(x * 2. * PI + 2. * PI / 3.) + 1.),\n        .5 * (sin(x * 2. * PI - 2. * PI / 3.) + 1.)\n    );\n}\n\nvec2 rot(vec2 uv, float angle) {\n    return vec2(\n        cos(angle * 2. * PI) * uv.x - sin(angle * 2. * PI) * uv.y,\n        sin(angle * 2. * PI) * uv.x + cos(angle * 2. * PI) * uv.y\n    );\n}\n\nfloat h(vec2 uv, float y0, float height, float e) {\n    return estep(y0 - height * .5, uv.y, -e) * estep(y0 + height * .5, uv.y, e);\n}\n\nfloat v(vec2 uv, float x0, float width, float e) {\n    return estep(x0 - width * .5, uv.x, -e) * estep(x0 + width * .5, uv.x, e);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat circle(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    return estep(min(size.x, size.y) * .5, length(uv), e * 2.);\n}\n\nfloat rect(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return \n        estep(size.x * .5, uv.x, e) *\n        estep(-size.x * .5, uv.x, -e) *\n        estep(size.y * .5, uv.y, e) *\n        estep(-size.y * .5, uv.y, -e);\n}\n\nfloat tri(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    uv += vec2(0, size.y * .5);\n    return\n        estep(-size.x * .5, uv.x - uv.y * size.x * .5 / size.y, -e * 2.) *\n        estep(-size.x * .5, - uv.x - uv.y * size.x * .5 / size.y, -e * 2.) *\n        estep(.0, uv.y, -e);\n}\n\nfloat ell(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    float t;\n    float c;\n    vec2 p;\n    if (size.x >= size.y) {\n        t = size.x;\n        c = pow(pow(size.x * .5, 2.) - pow(size.y * .5, 2.), .5);\n        p = vec2(c, .0);\n    } else {\n        t = size.y;\n        c = pow(pow(size.y * .5, 2.) - pow(size.x * .5, 2.), .5);\n        p = vec2(.0, c);\n    }\n    return estep(t, length(uv - p) + length(uv + p), e * 4.);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat circleh(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    return n(\n        circle(uv, vec2(.0), size, .0, .0, e) - \n        circle(uv, vec2(.0), size - vec2(r), .0, .0, e)\n    );\n}\n\nfloat recth(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        rect(uv, vec2(.0), size, .0, .0, e) - \n        rect(uv, vec2(.0), size - vec2(r), .0, .0, e)\n    );\n}\n\n// WIP\nfloat trih(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        tri(uv, vec2(.0), size, .0, .0, e) - \n        tri(uv, vec2(.0, -r * .2), size - vec2(r * pow(2., .5)), .0, .0, e)\n    );\n}\n\nfloat ellh(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        ell(uv, vec2(.0), size, .0, .0, e) - \n        ell(uv, vec2(.0), size - vec2(r), .0, .0, e)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat line(vec2 uv, vec2 p1, vec2 p2, float size, float e) {\n    vec2 diff = p2 - p1;\n\n    float angle = atan(diff.y, diff.x) / (2. * PI);\n    return n(\n        circle(uv, p1, vec2(size), .0, .0, e) +\n        circle(uv, p2, vec2(size), .0, .0, e) +\n        rect(uv, (p1 + p2) * .5, vec2(length(diff), size), .0, -angle, e)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat rectr(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    vec2 isize = size - vec2(r);\n    vec2 v1 = isize * .5;\n    vec2 v2 = v1 * vec2(-1, 1);\n    return n(\n        circle(uv, + v1, vec2(r), .0, .0, e) +\n        circle(uv, - v1, vec2(r), .0, .0, e) +\n        circle(uv, + v2, vec2(r), .0, .0, e) +\n        circle(uv, - v2, vec2(r), .0, .0, e) +\n        rect(uv, vec2(.0), vec2(size.x, isize.y), .0, .0, e) + \n        rect(uv, vec2(.0), vec2(isize.x, size.y), .0, .0, e)\n    );\n}\n\nfloat rectr2(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        rectr(uv, vec2(.0), size, r, .0, E) +\n        rect(uv, vec2(.0, - size.y * .5 + r * .5), vec2(size.x, r), .0, .0, E)\n    );\n}\n\nfloat trir(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    vec2 isize = size - vec2(r);\n    vec2 v1 = isize * .5;\n    vec2 v2 = v1 * vec2(-1, 1);\n    vec2 v3 = (v1 + v2) * .5;\n    return n(\n        line(uv, -v1, v3, r, e) +\n        line(uv, -v1, -v2, r, e) +\n        line(uv, v3, -v2, r, e) +\n        tri(uv, vec2(.0), size - vec2(r), .0, .0, e)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat rectrh(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        rectr(uv, vec2(.0), size, r, .0, e) -\n        rectr(uv, vec2(.0), size - vec2(r), r, .0, e)\n    );\n}\n\n// WIP\nfloat trirh(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        trir(uv, vec2(.0), size, r, .0, e) -\n        trir(uv, vec2(.0, -r * .2), size - vec2(r), r, .0, e)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n#define SHADOW vec2(-.03, .03)\n#define SHADOW_V .3\n\nfloat bubble_bg(vec2 uv) {\n    return n(\n        line(uv, vec2(-.12, .0), vec2(.12, .0), .3, E) +\n        circle(uv, vec2(-.22, -.1), vec2(.13), .0, .0, E) +\n        circle(uv, vec2(-.32, -.18), vec2(.07), .0, .0, E)\n    );\n}\n\n#define DOT_TIME .3\n\n#define BG vec3(.8)\n#define DOT_DARK vec3(.4)\n#define DOT_LIGHT vec3(.6)\n\nvec3 bubble(vec3 c, vec2 uv, float t0, bool last_dot) {\n    c = mask(c, vec3(.0), SHADOW_V * bubble_bg(uv + SHADOW));\n    c = mask(c, BG, bubble_bg(uv));\n    \n    float t1 = mod(t0, DOT_TIME * 3.);\n    \n    c = mask(c, t1 < DOT_TIME ? DOT_DARK : DOT_LIGHT, circle(uv, vec2(-.12, .0), vec2(.1), .0, .0, E));\n    c = mask(c, t1 > DOT_TIME && t1 < DOT_TIME * 2. ? DOT_DARK : DOT_LIGHT, circle(uv, vec2(.0), vec2(.1), .0, .0, E));\n    if (last_dot)\n        c = mask(c, t1 > DOT_TIME * 2. ? DOT_DARK : DOT_LIGHT, circle(uv, vec2(.12, .0), vec2(.1), .0, .0, E));\n    \n    return c;\n}\n\nfloat letter_open_mask(vec2 uv, float he) {\n    return n(trir(uv, vec2(.0, .14 + .1 * he), vec2(.53, max(.05, .2 * he)), .05, .0, E) * h(uv, .29, .2, E));\n}\n\n#define LETTER_TIME 1.\n\nvec3 letter(vec3 c, vec2 uv, float t0) {\n    float letter_bg = rectr(uv, vec2(.0), vec2(.54, .4), .1, .0, E);\n    float letter_inside = letter_bg * trir(uv, vec2(.0, .1), vec2(.53, .2), .05, .5, E);\n    float letter_closed = .0;\n    float letter_open = .0;\n    float letter_shadow = rectr(uv + SHADOW, vec2(.0), vec2(.54, .4), .1, .0, E);\n    \n    float he;\n    \n    if (t0 < LETTER_TIME * .5) {\n        he = min(1., 4. * (LETTER_TIME * .5 - t0));\n        letter_closed = rectr(uv, vec2(.0), vec2(.54, .4), .1, .0, E) * trir(uv, vec2(.0, .23 - .1 * he), vec2(.53, max(.05, .2 * he)), .05, .5, E);\n    } else {\n        he = min(1., 4. * (t0 - LETTER_TIME * .5));\n        letter_open = letter_open_mask(uv, he);\n        letter_shadow = n(letter_shadow + letter_open_mask(uv + SHADOW, he));\n    }\n    \n    c = mask(c, vec3(.0), SHADOW_V * letter_shadow);\n    c = mask(c, vec3(.9), letter_bg);\n    c = mask(c, vec3(.7), letter_inside);\n    c = mask(c, vec3(.9), letter_closed);\n    c = mask(c, vec3(.7), letter_open);\n    \n    return c;\n}\n\nvec3 letter_front(vec3 c, vec2 uv, float t0) {\n    float letter_bg = rectr(uv, vec2(.0), vec2(.54, .4), .1, .0, E);\n    float letter_inside = letter_bg * trir(uv, vec2(.0, .1), vec2(.53, .2), .05, .5, E);\n\n    return mask(c, vec3(.9), n(letter_bg - letter_inside));\n}\n\n#define DOT_AFTER vec3(.9, .8, .1)\n\nvec3 free_dot(vec3 c, vec2 uv, float t0) {\n\n    uv -= vec2(.12, .0) * (2.0 - t0) * .5;\n\n    for (float v = .0; v < 1.; v += .11)\n        c = mask(c, vec3(1.), line(uv, vec2(.0), rot(vec2(n(t0 - .5) * .06), v), .05, E));\n\n    c = mask(c, mask(DOT_DARK, DOT_AFTER, n(t0 * 2.)), circle(uv, vec2(.0), vec2(.1), .0, .0, E));\n    \n    return c;\n}\n\nvec3 stamp(vec3 c, vec2 uv, float t0) {\n    \n    uv *= min(1., t0 * .9);\n    \n    float heart = n(\n        circle(uv, vec2(.02, .03), vec2(.07), .0, .0, E) +\n        circle(uv, vec2(-.02, .03), vec2(.07), .0, .0, E) +\n        trir(uv, vec2(0, -.01), vec2(.09, .06), .02, .5, E)\n    );\n\n    c = mask(c, vec3(.9, .0, .0), n(t0) * heart);\n    \n    return c;\n}\n\nvec3 image(vec2 uv, float t0) {\n    vec3 c = vec3(.1, .6, .3);\n    \n    float t1 = mod(t0, 8.);\n\n    c = bubble(c, uv + vec2(t1 < 2. ? .0 : (t1 < 4. ? t1 - 2. : t1 - 8.), .0), t1 + .5, t1 < 2. || t1 > 6.);\n    \n    float letter_x = t1 < 4. ? t1 - 4. : (t1 < 6. ? .0 : t1 - 6.);\n    \n    c = letter(c, uv + vec2(letter_x, .0), 4.5 - t1);\n    \n    if (t1 > 2. && t1 < 4.1)\n        c = free_dot(c, uv - vec2(.0, sin((t1 - 2.) * .5 * PI) * .6), (t1 - 2.));\n    \n    c = letter_front(c, uv + vec2(letter_x, .0), 4.5 - t1);\n    \n    c = stamp(c, uv + vec2(letter_x, .0), t1 - 4.5);\n    \n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    vec3 c = image(uv, iTime * .8);\n    \n    fragColor = vec4(c,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}