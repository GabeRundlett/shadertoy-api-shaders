{
    "Shader": {
        "info": {
            "date": "1725194432",
            "description": "Gaussian-filtered Dirac comb and square wave.",
            "flags": 0,
            "hasliked": 0,
            "id": "4c2BRG",
            "likes": 2,
            "name": "Gaussian-filtered comb&sq. wave",
            "published": 3,
            "tags": [
                "wave",
                "filtering",
                "square",
                "analytical",
                "gaussian",
                "comb"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 90
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Gaussian-filtered Dirac comb and square wave.\n\n// It is somewhat well-known that sum and integral\n// of gaussians match surprisingly well (for typographical\n// convenience all sums and integrals in this description\n// are from -∞ to +∞, unless otherwise stated):\n//     ∫ exp(-x^2) dx = sqrt(π)   = 1.7724538509...\n//     Σ exp(-k^2)    = ϑ₃(0,1/e) = 1.7726372048...\n// See https://mathworld.wolfram.com/JacobiThetaFunctions.html\n// for definition of ϑ₃. The small discrepancy is surprising,\n// and indeed far less than a standard upper bound\n// for midpoint rule from numerical integration theory\n//     Error ⩽ max(|exp(-x^2)''|)/24=1/12\n// The discrepancy tends to be similar in magnitude for\n// offset sum, and decreases rapidly for wider gaussians.\n// We will now provide a brief explaination, which will\n// precisely quantify the above statement. Consider an offset\n// sum of normalized gaussians\n//     S(σ,x) = 1/(sqrt(2*π)*|σ|) * Σ exp(-(x-k)^2/(2*σ^2))\n// which can also be written as a convolution with a Dirac comb\n//     S(σ,x) = conv(Ш(t-x),1/(sqrt(2*π)*|σ|)*exp(-t^2/(2*σ^2)))\n// making it a gaussian-filtered version of said comb.\n// The behaviour becomes rather obvious when we consider\n// its Fourier transform. Since the function is a periodic\n// sum, we can use Poisson summation formula to obtain\n//     S(σ,x) = 1/(sqrt(2*π)*|σ|) * Σ exp(-(x-k)^2/(2*σ^2))\n//            = 1/(sqrt(2*π)*|σ|) * Σ F{exp(-(x-t)^2/(2*σ^2))}(k)\n//            = 1/(sqrt(2*π)*|σ|) * Σ exp(-2*π*i*k*x)*F{exp(-t^2/(2*σ^2))}(k)\n//            = Σ exp(-2*π*i*k*x) * exp(-2*π^2*σ^2*k^2)\n//            = Σ exp(-2*(π*σ*k)^2)*cos(2*π*k*x)\n//            = 1 + 2*(exp(- 1*2*(π*σ)^2)*cos(2*π*x)+\n//                     exp(- 4*2*(π*σ)^2)*cos(4*π*x)+\n//                     exp(- 9*2*(π*σ)^2)*cos(6*π*x)+\n//                     exp(-16*2*(π*σ)^2)*cos(8*π*x)+...)\n// which makes the magnitude of the discrepancy and the\n// oscillating nature of the expression immediately apparent.\n// Using these expressions, we can write an implementation of S(σ,x)\n// computing it in either time or frequency formulation, whichever\n// takes fewer terms (in float32 at most 4 terms are needed).\n// Very similarly we can obtain an expression for an alternating sum:\n//     s(σ,x) = 1/(sqrt(2*π)*|σ|) * Σ ((-1)^k)*exp(-(x-k)^2/(2*σ^2))\n//            = (S(σ/2,x/2)-S(σ/2,(1-x)/2))/2 =\n//            = 2*(exp(- 1/2*(π*σ)^2)*cos(1*π*x)+\n//                 exp(- 9/2*(π*σ)^2)*cos(3*π*x)+\n//                 exp(-25/2*(π*σ)^2)*cos(5*π*x)+...)\n// We can also use this approach to get expressions for\n// gaussian-filtered square wave\n//     Q(σ,x) = 1/(sqrt(2*π)*|σ|) * ∫ sgn(cos(2*π*x))*exp(-(t-x)^2/(2*σ^2)) dx\n// in both \"time-based\" and \"frequency-based\" versions.\n// NOTE: written this way (instead of almost identical (-1)^round(x), for\n// example), square wave matches its Fourier expansion everywhere, including\n// points of discontinuity.\n// Integrating time-based version we may arrive at\n//     Q(σ,x) = Σ (-1)^k erf((x+k/2+1/4)/(sqrt(2)*|σ|))\n// which doesn't converge in conventional sense, however, a more carefully\n// constructed version, e.g.\n//     Q(σ,x) = -1 + Σ (erf((x+k+1/4)/(sqrt(2)*|σ|))-erf((x+k-1/4)/(sqrt(2)*|σ|)))\n//            = -1 + Σ (erfc((x+k-1/4)/(sqrt(2)*|σ|))-erfc((x+k+1/4)/(sqrt(2)*|σ|)))\n// does.\n// Integrating frequency-based version we obtain\n//     Q(σ,x) = 4*( exp(- 2*(π*σ)^2)/(1*π)*cos( 2*π*x)\n//                 -exp(-18*(π*σ)^2)/(3*π)*cos( 6*π*x)\n//                 +exp(-50*(π*σ)^2)/(5*π)*cos(10*π*x)\n//                 -exp(-98*(π*σ)^2)/(7*π)*cos(14*π*x)\n//                 +...)\n// Note that, unlike time-based version, it does not require special functions.\n// Using these expression we also can write an implementation computing Q(σ,x)\n// in either time or frequency formulation, whichever takes fewer terms (in\n// float32 at most 4 terms are needed).\n//\n// These results are, presumably, well-known in signal processing (and\n// numerical analysis).\n// See (and hear) also\n//     \"Gaussian Filtered Square Wave\" by oneshade\n//     https://www.shadertoy.com/view/NdKSzd\n// which has time-based formulation only.\n\n//==============================================================================\n\nconst float pi=3.14159265358979;\n\n// Approximation of complementary error function from\n// \"Numerical Recipes in Fortran 77: The Art of Scientific Computing\" (ISBN 0-521-43064-X), 1992, page 214, Cambridge University Press.\n// See also https://www.shadertoy.com/view/ml3yWj\nfloat erfc(float x)\n{\n    float t=1.0/(1.0+0.5*abs(x));\n    float y=t*exp(\n        -x*x-1.26551223\n        +t*(+1.00002368\n        +t*(+0.37409196\n        +t*(+0.09678418\n        +t*(-0.18628806\n        +t*(+0.27886807\n        +t*(-1.13520398\n        +t*(+1.48851587\n        +t*(-0.82215223\n        +t*(+0.17087277))))))))));\n    return x<0.0?2.0-y:y;\n}\n\n//==============================================================================\n\n// Compute 1/(sqrt(2*π)*|σ|) * Σ exp(-(x-k)^2/(2*σ^2)) = ϑ₃(π*x,exp(-2*π^2*σ^2))\nfloat gauss_comb(float sigma,float x)\n{\n    sigma=abs(sigma);\n    x=fract(abs(x));\n    x=min(x,1.0-x);\n    if(sigma<0.33)\n    {\n        float a=1.0/(2.0*sigma*sigma);\n        return (exp(-a*(x-2.0)*(x-2.0))\n               +exp(-a*(x+1.0)*(x+1.0))\n               +exp(-a*(x-1.0)*(x-1.0))\n               +exp(-a*(x-0.0)*(x-0.0)))/(sigma*sqrt(2.0*pi));\n    }\n    else\n    {\n        float a=exp(-2.0*(pi*sigma)*(pi*sigma)),b=cos(2.0*pi*x);\n        return 1.0+2.0*a*(b+a*a*a*(2.0*b*b-1.0));\n    }\n}\n\n// Compute 1/(sqrt(2*π)*|σ|) * ∫ sgn(cos(2*π*x))*exp(-(t-x)^2/(2*σ^2)) dx\n// NOTE: we only call erfc() with non-negative argument, so an implementation\n// on [0;+∞) suffices.\nfloat gauss_square_wave(float sigma,float x)\n{\n    sigma=abs(sigma);\n    x=fract(abs(x));\n    x=min(x,1.0-x);\n    if(sigma<0.18)\n    {\n        float s=sign(0.25-x);\n        x=min(x,0.5-x);\n        float a=sqrt(0.5)/sigma;\n        return s*(      (erfc(a*(x+0.75))+erfc(a*(0.75-x)))\n                  +(1.0-(erfc(a*(0.25-x))+erfc(a*(x+0.25)))));\n    }\n    else\n    {\n        float a=exp(-2.0*(pi*sigma)*(pi*sigma)),a2=a*a,a4=a2*a2;\n        float b=cos(2.0*pi*x);\n        return 4.0*a*b/pi*(1.0-a4*a4*(4.0/3.0*b*b-1.0));\n\n    }\n}\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    float x=fragCoord.x/iResolution.x;\n    float y=fragCoord.y/iResolution.y;\n    float sigma=0.5*(1.0+sin(iTime));\n    x=4.0*x+iTime;\n    vec3 col=vec3(0.06125);\n    if(y>0.5) col+=vec3(0.05,0.5,0.05)*smoothstep(0.0,1.5*fwidth(y),0.5*gauss_comb       (sigma,x)-(2.5*y-1.375));\n    else      col+=vec3(0.05,0.5,0.05)*smoothstep(0.0,1.5*fwidth(y),0.5*gauss_square_wave(sigma,x)-(2.5*y-0.625));\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}