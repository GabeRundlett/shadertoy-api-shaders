{
    "Shader": {
        "info": {
            "date": "1634068235",
            "description": "This is the same code from Log Polar Test (forked), but without the log polar stuff - no idea how to make the right side not buggy, leaving it here to come back to later\n\nbetter starting point:\nhttps://www.shadertoy.com/view/NdsfWs",
            "flags": 0,
            "hasliked": 0,
            "id": "sdcSDX",
            "likes": 9,
            "name": "Egg Yolks",
            "published": 3,
            "tags": [
                "e"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 334
        },
        "renderpass": [
            {
                "code": "#define pi 3.14159\n\n// Code modified from here:\n// https://thebookofshaders.com/edit.php#09/marching_dots.frag\n// https://www.osar.fr/notes/logspherical/\n\n// used for generating random radii for each tile\nfloat h21 (float a, float b, float zoom) {\n    a = mod(a, zoom); b = mod(b, zoom);\n    return fract(sin(dot(vec2(a, b), vec2(12.9898, 78.233)))*43758.5453123);\n}\n\n// Determines how tiles move\n// (modified bookofshaders code, replaced if statements with step functions)\nvec2 movingTiles(vec2 _st, float _zoom, float _speed){\n    //_st.x = fract(2. * _st.x);\n    //_st.y = fract(2. * _st.y);\n    float time = iTime * _speed;\n    \n    // Change me for different patterns\n    float ft = fract(2. * abs(_st.x - 0.5) + 2. * abs(_st.y - 0.5) + time);\n    \n    // e.g.\n    // float ft = fract(2. * abs(_st.x) + 2. * abs(_st.y) + time);\n    // float ft = fract(2. * max(abs(_st.x - 0.5), abs(_st.y - 0.5)) + time);\n    // float ft = .5 + .5 * cos(length(_st-0.5) - 8. * time);\n    \n    _st *= _zoom;//sqrt(_zoom);\n    \n    float k = step(0.5, ft);\n    _st.x +=      k * sign(fract(_st.y * 0.5) - 0.5) * ft * 2.;\n    _st.y += (1.-k) * sign(fract(_st.x * 0.5) - 0.5) * ft * 2.;\n\t\n    // Multiply _st here to get more than 1 shape per tile\n    return fract(_st * 1.);\n}\n\n// Provides the shape in each tile\nfloat circle(vec2 uv, float r){\n    uv = uv - .5;\n    return smoothstep(1.0-r, 1.0-r+r*0.2, 1.-dot(uv,uv)*3.14);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord / iResolution.xy;\n    st.x *= iResolution.x / iResolution.y;\n    \n    float zoom = 16.;\n    \n    // Cut uv into smaller uvs\n    vec2 uv = fract(vec2(st.x * zoom, st.y * zoom));\n    vec2 ft = floor(st * zoom);\n    \n    // Generate values for each corner of uv, used for circle radii\n    float l  = h21(ft.x + 1., ft.y,      zoom);\n    float t  = h21(ft.x,      ft.y + 1., zoom);\n    float tl = h21(ft.x + 1., ft.y + 1., zoom);\n    float id = h21(ft.x,      ft.y,      zoom);\n\n    // Smooth the cut uvs so different uvs meet continuously on the edges\n    uv = uv * uv * (3. - 2. * uv);\n    \n    // Box lerp between the corner values to get a radius value for this pixel\n    float v = l * uv.x * (1.-uv.y)\n     \t    + t * (1.-uv.x) * uv.y\n     \t    + tl * uv.x * uv.y\n      \t    + id * (1.-uv.x) * (1.-uv.y);\n        \n    // Do the tile pattern\n    st = movingTiles(st, zoom, 0.2);\n\n    // Generate circle using radius we've obtained\n    vec3 color = vec3( circle(st, 0.7 * v) - circle(st, 0.2 * v) );\n    color += vec3(circle(st, 0.2 * v),circle(st, 0.18 * v),0.);\n\t\n    //color += (0.3 + .7 * h21(-10.*ft.x,ft.y)) * vec3(st.xy,1.);\n  \n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}