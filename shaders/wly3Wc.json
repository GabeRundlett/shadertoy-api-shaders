{
    "Shader": {
        "info": {
            "date": "1580053922",
            "description": "Shader Sundays 04! This time trying to focus on learning how to model a basic scene.",
            "flags": 32,
            "hasliked": 0,
            "id": "wly3Wc",
            "likes": 5,
            "name": "Arriving late to a Movie.",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "pathtraced"
            ],
            "usePreview": 0,
            "username": "angelo12",
            "viewed": 560
        },
        "renderpass": [
            {
                "code": "/*\n\tShader Sundays! (4/52) \n\t\"Walking into a Film\"\n\t\n\tSo for this week I tried to focus on learning how to model a scene from a reference image. \n\tI picked this image as my starting point since I thought I would be able to model it pretty easily:\n\thttps://flic.kr/p/JYJJ4E . (Insert suprise pikachu) As a sdf noob this turned out to be more challenging than\n\tI thought it was gonna be. I couldn't quite get the stairs to look right, in fact they still kinda don't.\n\tAt one point it did start to look more like the entrance of a movie theater and I liked that a lot more\n\tso that's what I'm calling it now so that you also imagine it :) \n\n\tNo idea yet of what I'll do next week but it should be fun!\n\t\n\tReferences:\n\thttps://www.shadertoy.com/view/3dyXzD\n*/\n\n\n#define INV_GAMMA 0.4545454\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = vec3(0.0);\n    if(iFrame > 0)\n    {\n        col = texture(iChannel0, uv).xyz;\n        col /= float(iFrame);\n    }\n\n    col *= 3.5;\n    col = pow(col, vec3(INV_GAMMA));\n    fragColor = vec4(col, 1.0); \n    fragColor = smoothstep(0.,1.0,fragColor);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define M_PI 3.1415926535\n#define M_TAU M_PI*2.0\n\n#define DEBUG 0\n\nfloat rng_ = 0.0;\n\nmat3\nSetCamera(vec3 eye, vec3 target, float roll)\n{\n    vec3 f, temp, r, u;\n    f = normalize(target - eye);\n    temp = normalize(vec3(sin(roll), cos(roll), 0.0));\n    r = normalize(cross(temp, f));\n    u = cross(f, r); \n\n    return mat3(r, u, f);\n}\n\nfloat\nhash(float p)\n{\n    p = fract(p *0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat\nsdBox(vec3 p, vec3 sides)\n{\n    vec3 q = abs(p) - sides;\n    return length(max(q, 0.0)) - min(max(q.z, max(q.x, q.y)), 0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat\nsdRail(vec3 p)\n{\n    vec3 r1A = vec3(0.0, 0.0, -1.0);\n    vec3 r1B = vec3(0.0, 0.0, 0.1);\n    float r1r = 0.02;\n\n    vec3 r2B = vec3(0.0, 1.7, 04.0);\n\n    float r1 = sdCapsule(p - vec3(0.45, 0.2, 0.0), // pos\n                             r1A, // start\n                             r1B, // end\n                             r1r); // radius\n\n    float r2 = sdCapsule(p - vec3(0.45, 0.2, 00.0), // pos\n                             r1B, // start\n                             r2B, // end\n                             r1r); // radius\n    \n    r1 = min(r1, r2);\n\n    vec3 r3B = vec3(r2B.xy, r2B.z + 0.5);\n\n    r2 = sdCapsule(p - vec3(0.45, 0.2, 00.0), // pos\n                             r2B, // start\n                             r3B, // end\n                             r1r); // radius\n    r1 = min(r1, r2);\n\n    vec3 r4B = vec3(r3B.x, r3B.y + r2B.y + 0.20, r3B.z + 4.0);\n\n    r2 = sdCapsule(p - vec3(0.45, 0.2, 00.0), // pos\n                             r3B, // start\n                             r4B, // end\n                             r1r); // radius\n    r1 = min(r1, r2);\n\n    vec3 r5B = vec3(r4B.x, r4B.y , r4B.z + 4.0);\n\n    r2 = sdCapsule(p - vec3(0.45, 0.2, 00.0), // pos\n                             r4B, // start\n                             r5B, // end\n                             r1r); // radius\n    r1 = min(r1, r2);\n\n    return r1;\n}\n\nfloat\nsdGround(vec3 p)\n{\n    float d = p.y;\n\n    float steps = floor(p.z* 5.0);\n\n    if ( p.z > 0.0 && p.z < 10.0)\n    {\n        d -= steps * 0.08 - 0.0 ;\n    }\n\n    //IQ steps https://www.shadertoy.com/view/ttBXRG\n    float i = floor(d);\n    float f = fract(d);\n    float k = 4.0;\n    float a = 0.5*pow(2.0*((f<0.5)?f:1.0-f), k);\n    f = (f<0.5)?a:1.0-a;\n    \n    return i+f;\n}\n\n//union op\nvec2\nuop(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\n//mirror op\nvec3\nmop(vec3 p)\n{\n    float off = 0.2;\n    p.x = abs(p.x + off)- off;\n    return p;\n}\n\n#define UOP(dist, id) res = uop(res, vec2(dist, id))\n\n#define BOX_ID 0.0\n\n#define GROUND_ID 1.0\n#define LEFT_ID 2.0\n#define RIGHT_ID 3.0\n#define STAIRS_ID 4.0\n#define RAIL_ID 5.0\n#define ROOM_ID 6.0\n#define CEIL_ID 7.0\n\n#define EPSI 0.004\nvec2\nMap(vec3 p)\n{\n    vec2 res = vec2(1e10, -1.0);\n\n    float o = -1.4; //side offset\n    float h = 300.5; // height of staircase walls\n    UOP(sdGround(p - vec3(0.0, -0.1, 0.0)), GROUND_ID); \n    UOP(sdBox(p - vec3(0.02 + o, 0.0, 0.0), vec3(EPSI, h, 20.0)), LEFT_ID); \n    UOP(sdBox(p - vec3(1.99 + o, 0.0, 0.0), vec3(EPSI, 2., 20.0)), RIGHT_ID); \n    UOP(sdBox(p - vec3(0.0, 09.1, 0.0), vec3(20.0,EPSI, 25.0)), CEIL_ID); \n    UOP(sdBox(p - vec3(0.0, 10.1, 20.1), vec3(20.0,20.0, EPSI)), ROOM_ID); \n    UOP(sdBox(p - vec3(o, 7.9, 17.0), vec3(0.1, 0.1, 0.2)), BOX_ID);\n    UOP(sdRail(mop(p)), RAIL_ID);\n\n\n    return res;\n}\n\n#define MAX_STEPS 2000\n#define MIN_DIST 0.001\n#define MAX_DIST 50.0\nvec2\nRayMarch(vec3 ro, vec3 rd)\n{\n    vec2 res = vec2(-1.0, -1.0);\n    float t = 0.0;\n\n    for(int i = 0; i < MAX_STEPS && t < MAX_DIST; ++i)\n    {\n        vec2 hit = Map(ro + t*rd);\n\n        if(abs(hit.x) < t*MIN_DIST)\n        {\n            res = vec2(t, hit.y);\n            break;\n        }\n        t += hit.x;\n    }\n\n    return res;\n}\n\nvec3\nCalcNormal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(Map(p + e.xyy).x - Map(p - e.xyy).x,\n                          Map(p + e.yxy).x - Map(p - e.yxy).x,\n                          Map(p + e.yyx).x - Map(p - e.yyx).x));\n}\n\nstruct Material\n{\n    vec3 col; //r,g,b\n    float emi;\n    float rough;\n    vec3 pad;\n};\n\nvec3 roomCol = vec3(0.08, 0.08, 0.7);\n\nMaterial\nGetMaterialFromID(float id, vec3 p, vec3 N)\n{\n    Material mat;\n    //Default\n    mat.col = vec3(1.0);\n    mat.emi = 0.0;\n    mat.rough = 1.0; //1.0 is maximum roughness 0.0 is perfectly reflective\n\n    if(id == BOX_ID)\n    {\n        mat.col = vec3(0.0, 0.8, 0.0);\n        mat.emi = 2.6;\n    }\n    else if(id == RAIL_ID) \n    {\n        float r = length(p.xy);\n        float a = atan(p.y, p.x);\n\n        float dir = dot(N, vec3(0.0, -1.0, 0.0));\n        if(abs(dir - 1.0) < 0.4)\n        {\n            mat.emi = 1.6;\n            mat.col = vec3(1.0, 0.0, 0.0);\n        }\n        else\n        {\n            mat.col = vec3(0.5);\n            mat.rough = 0.2;\n        }\n    }\n    else if (id == ROOM_ID)\n    {\n        mat.col = roomCol;\n        mat.emi = 1.0;\n    }\n    else if(id == LEFT_ID || id == RIGHT_ID)\n    {\n        mat.col = vec3(0.27, 0.27, 0.27);\n        mat.rough = 0.6;\n    }\n    else if(id == CEIL_ID)\n    {\n        mat.rough = 0.5;\n    }\n    return mat;\n}\n\nvec3\nCosineWeightedRay(vec3 n , float seed)\n{\n    float u = hash(seed + 82.753);\n    float v = hash(seed + 18.902);\n\n    float a = M_TAU * v;\n    u = 2.0*u - 1.0;\n\n\n    return normalize(n + vec3(sqrt(1.0 - u*u) * vec2(cos(a), sin(a)),u));\n}\n\nfloat\nCalcShadows(vec3 ro, vec3 rd)\n{\n    float k = 2.0;\n    float res = 1.0;\n    for(float t = 0.012; t < MAX_DIST;)\n    {\n        float h = Map(ro + t*rd).x;\n        \n        if(h < MIN_DIST) return 0.0;\n        res = min(res, h*k/t);\n        t += h;\n    }\n\n    return res;\n}\n\n#define saturate(val) clamp(0.0, 1.0, val)\n\nvec3\nCalcRayDirection(vec3 originalRd, vec3 reflectionDir, vec3 normal, float rough, float seed)\n{\n    vec3 newRd = vec3(0.0);\n    vec3 randDir = CosineWeightedRay(normal, seed);\n    if(rough >= 1.0)\n    {\n        newRd = randDir;\n    }\n    else\n    {\n        newRd = reflectionDir*(saturate(1.0 - rough)) + rough * randDir;\n        newRd = normalize(newRd);\n    }\n\n    return newRd;\n}\n\nvec3 sunCol = vec3(0.8, 0.7, 0.8);\nvec3 skyCol = vec3(0.0, 0.2, 0.8);\nvec3 sunDir = vec3(1.0, 1.3, 0.0);\n\n#define GI_BOUNCES 2\nvec3\nRender(vec3 ro, vec3 rd)\n{\n    //Global illumination tracking vars\n    vec3 tot = vec3(0.0);\n    vec3 rayCol = vec3(1.0);\n\n    //Original data\n    vec3 oro = ro;\n    vec3 ord = rd;\n    float depth = 0.0;\n    float t = 0.0;\n\n    for(int bounce = 0; bounce < GI_BOUNCES; ++bounce)\n    {\n        //Scene traversal\n        vec2 res = RayMarch(ro, rd);\n        t = res.x;\n        float id = res.y;\n\n        //First hit\n        if (id < 0.0)\n        {\n            //you hit the sky\n            if (bounce == 0)\n            {\n                //If you hit it on the first bounce that's your final color\n                tot = skyCol;\n            }\n            break;\n        }\n        if(bounce == 0) depth = t;\n\n        //Geometry\n        vec3 P = ro + t*rd;\n        vec3 N = CalcNormal(P);\n        vec3 R = reflect(rd, N);\n\n        //Material\n        Material mat = GetMaterialFromID(id, P, N);\n        rayCol *=mat.col;\n\n        //Lighting\n        vec3 lAcc =  vec3(0.0);\n        vec3 L = normalize(sunDir);\n        float diff = saturate(dot(N, L));\n\n        vec3 indirect = rayCol * mat.emi;\n\n        //Shadowing\n        float shadowed = CalcShadows(P, L);\n\n        //Shading\n        #if DEBUG\n            tot = N;\n            break;\n        #else\n            //lAcc += shadowed * diff * sunCol;\n            lAcc += indirect;\n            tot += lAcc * rayCol;\n        #endif\n\n        //Next Ray bounce\n        ro = P;\n        float timeSeed =  76.2 + 73.1*float(bounce) + rng_ + 17.7*float(iFrame);\n        //rd = CosineWeightedRay(N, timeSeed);\n        rd = CalcRayDirection(rd, R, N, mat.rough, timeSeed);\n    }\n\n    //Fog\n    tot = mix(tot, vec3(roomCol), 1.0 - exp(-0.0008*depth*depth));\n\n    return tot;\n}\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Seeding rng per pixel per frame\n    rng_ = hash(dot(vec2(12.9898, 78.233), fragCoord)+ 1113.1*float(iFrame));\n\n    //Camera setup\n    float nearP = 0.79;\n    float roll = 0.0;\n    vec2 offset = - 0.5 + vec2(hash(rng_ + 10.852), hash(rng_ + 56.266));\n    vec2 uv = ((fragCoord+offset) - 0.5*iResolution.xy)/iResolution.y;\n    vec3 ta = vec3(0.0, 0.6, 00.0);\n    vec3 ro = vec3(0.0, 0.4, -1.0);\n    mat3 cam = SetCamera(ro, ta, roll);\n    vec3 rd = cam * normalize(vec3(uv, nearP));\n\n    //Adding to prev color\n    vec2 screen = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, screen).xyz;\n    if( iFrame == 0) col = vec3(0.0); \n\n    //Render\n    col += Render(ro, rd);\n\n    //Noise debug\n    //col += vec3(rng_);\n\n    fragColor = vec4(col, 1.0);    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}