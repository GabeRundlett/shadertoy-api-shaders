{
    "Shader": {
        "info": {
            "date": "1680139921",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!",
            "flags": 0,
            "hasliked": 0,
            "id": "mtfXW7",
            "likes": 13,
            "name": "Year of Truchets #006",
            "published": 3,
            "tags": [
                "raymarching",
                "truchet",
                "tiles",
                "truchetcore"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 242
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #006\n    03/29/2023  @byt3_m3chanic\n    \n    Back from a little break - continuing the truchet shaders for the year!\n    Truchet Core \\M/->.<-\\M/ 2023 \n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n\n#define MAX_DIST    100.\n#define MIN_DIST    .0001\n\n// globals\nvec3 hit=vec3(0),hitPoint=vec3(0);\nmat2 ria,gia,turn,spin;\n\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(26.34,45.32)))*4424.23);}\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n//@iq all SDFs\nfloat box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\nfloat box(vec2 p, vec2 a) {\n    vec2 q = abs(p)-a;\n    return length(max(q,0.)) + min(max(q.x,q.y),0.);\n}\n\nvec2 map(vec3 p, float sg) {\n    vec2 res = vec2(1e5,0.);\n    vec3 q = p+vec3(0,0,3.*sin(T*.3));\n    \n    q.yx *= spin;\n    q.zx *= turn;\n\n    float d1 = box(abs(q)-1.5,vec3(1))-.005;\n    if(d1<res.x){\n        res = vec2(d1,2.);\n        hit = q+.5;\n    }\n\n    float f1 = box(vec3(abs(p.x)-6.5,p.yz),vec3(.1,22,22))-.005;\n    if(f1<res.x){\n        res = vec2(f1,1.);\n        hit = p;\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps, float sg){\n\tfloat d = 0., m = 0.;\n    for(int i=0;i<maxsteps;i++){\n    \tvec2 ray = map(ro + rd * d, sg);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += ray.x;\n        m  = ray.y;\n    }\n\treturn vec2(d,m);\n}\n\nvec3 getFace(int face, vec3 p) {\n\n    vec2 uv = p.xy;\n    float wd = .1, sc = 4., hf = sc/2., px = .25/R.x;\n    \n    vec2 xd = floor(uv*hf);\n    vec2 id = floor((uv*sc)+float(face));\n    \n    vec2 r = fract(uv*hf)-.5;\n    uv = fract(uv*sc)-.5;\n    \n    float h3 = hash21(xd);\n    float hs = hash21(id);\n    if(hs>.5) uv *= rot(1.5707);\n    \n    vec2 sp = vec2(length(uv-.5),length(uv+.5));\n    vec2 q = sp.x<sp.y? uv-.5 : uv+.5;\n    \n    float d = length(q)-.5;\n    d = abs(d)-wd;\n    \n    if (hs>.7) d = min(length(uv.x)-wd,length(uv.y)-wd);\n    if (hs<.1) d = min(abs(length(uv)-.375)-wd,max(d,-(length(uv)-.375)));\n    \n    float pd = smoothstep(.1+px,-px,d);\n    d = smoothstep(px,-px,d);\n\n    bool isRed = (h3>.35&&h3<.75);\n    float b = box(r,vec2(.35))-wd;    \n    b = isRed ? smoothstep(px,-px,b) : 0.;\n    \n    float cd = 0.;\n    if (hs>.2&&hs<.6&&!isRed) {\n        cd = length(uv)-.4;\n        cd = smoothstep(px,-px,cd);\n    }\n    return vec3(d,cd,b);\n}\n\nvec4 FC = vec4(.02,.02,.02,0.);\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,100, 1.);\n    float m = ray.y;\n    d = ray.x;\n    hitPoint = hit;\n\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 l = normalize(vec3(-2.,12,7.)-p);\n \n        vec3 h = vec3(.5), hp = hitPoint, \n           cuv = vec3(0), sface = vec3(0), tn = n;\n \n        float diff = clamp(dot(n,l),0.,1.),\n              shdw = 1.;\n        for( float t=.01; t < 12.; ) {\n            float h = map(p + l*t,0.).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 16.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>24. ) break;\n        }\n        \n        diff = mix(diff,diff*shdw,.5);\n   \n        int face = 0;\n        if(m==1.){\n            cuv = hp.yzx;\n            cuv.x+=T;\n            sface =getFace(2, cuv*.2);\n            \n            vec3 c2 = texture(iChannel0,cuv.xy*.25).rgb*vec3(.8,.4,0);\n            vec3 c1 = texture(iChannel1,cuv.xy*.25).rgb;\n\n            h = mix(c1,clamp(c1+.2,c1,vec3(1)),sface.b>.1?1.:0.);\n            h = mix(h, vec3(.8,.2,.01) ,sface.g>.1?1.:0.);\n            h = mix(h,c2 ,sface.r>.1?1.:0.);\n            \n            h = (diff*h);\n            ref = h;\n        }\n        \n        if(m==2.){\n            tn.yx*=spin;\n            tn.zx*=turn;\n            //https://www.shadertoy.com/view/3sVBDd\n            //finding the face of a cube using normal\n            vec3 aN = abs(tn);\n            ivec3 idF = ivec3(tn.x<-.25? 0 : 5, tn.y<-.25? 1 : 4, tn.z<-.25? 2 : 3);\n            face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z;\n    \n            if(face==0) cuv = hp.yzx;\n            if(face==1) cuv = hp.xzy;\n            if(face==2) cuv = hp.xyz;\n            if(face==3) cuv = hp.xyz;\n            if(face==4) cuv = hp.xzy;\n            if(face==5) cuv = hp.yzx;\n\n            sface =getFace(face, cuv);\n            \n            vec3 c1 = texture(iChannel0,cuv.xy*.25).rgb*vec3(.8,.4,0);\n            vec3 c2 = texture(iChannel1,cuv.xy*.25).rgb;\n\n            h = mix(c1,clamp(c1+.2,c1,vec3(1)),sface.b>.1?1.:0.);\n            h = mix(h, vec3(.01,.2,.8) ,sface.g>.1?1.:0.);\n            h = mix(h,c2 ,sface.r>.1?1.:0.);\n            \n            h = (diff*h);\n            ref = h;\n        }\n        \n        C += h;\n        C = mix(FC.rgb,C,exp(-.0001*d*d*d));\n        ro = p+n*.001;\n        rd = reflect(rd,n);\n        \n    } \n    \n    C = clamp(C,vec3(0),vec3(1));\n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {   \n\n    vec3 C = vec3(0);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,-.25,10);\n    vec3 rd = normalize(vec3(uv,-1));\n    \n    FC = mix(vec4(0.184,0.161,0.133,0),vec4(0.122,0.114,0.078,0),clamp(uv.y*.8,0.,1.));\n    \n    //mouse\n    float x = M.xy == vec2(0) ? 1. :-(M.y/R.y*1.-.5)*PI;\n    float y = M.xy == vec2(0) ? 1. :-(M.x/R.x*1.-.5)*PI;\n   \n    mat2 rx = rot(.28);\n    \n    turn = rot(x+T*20.*PI/180.);\n    spin = rot(y+T*12.*PI/180.);\n    \n    ro.yz *= rx, rd.yz *= rx;\n    \n    // reflection loop (@BigWings)\n    vec3 ref = vec3(0), fil = vec3(1);\n    float d = 0.,b = 3.;\n    for(float i=0.; i<b; i++) {\n        vec4 pass = render(ro, rd, ref, i==b-1., d, uv);\n        C += pass.rgb*fil;\n        fil=ref;\n        if(i==0.) FC = vec4(FC.rgb,exp(-.0001*d*d*d));\n    }\n    C = mix(C,FC.rgb,1.-FC.w);\n\n    // gamma\n    C = pow(clamp(C,vec3(0),vec3(1)),vec3(.4545));\n    O = vec4(C,1.);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}