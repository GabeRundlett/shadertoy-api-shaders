{
    "Shader": {
        "info": {
            "date": "1530567305",
            "description": "The Problem of Apollonius is a famous geometry problem from antiquity, named after Apollonius of Perga. It can be stated as \"Given three circles, find a fourth circle that is simultaneously tangent to the other circles.\" \n\nSee comments for more.",
            "flags": 0,
            "hasliked": 0,
            "id": "XsKBWV",
            "likes": 17,
            "name": "Problem of Apollonius, splitview",
            "published": 3,
            "tags": [
                "circles",
                "math",
                "geometry",
                "tangent",
                "split",
                "apollonius"
            ],
            "usePreview": 0,
            "username": "mv",
            "viewed": 974
        },
        "renderpass": [
            {
                "code": "/*\n\tThe Problem of Apollonius is a famous geometry problem from antiquity, \n    named after Apollonius of Perga. It can be stated as \n\n\t\t\"Given three circles, find a fourth circle that is simultaneously \n\t\t tangent to the other circles.\" \n\n\tThe problem is equivalent to finding the the simultaneous solution of \n    three quadratic equations:\n\n\t\t(x - x_1)² + (y - y_1)² = (r - s_1*r_1)²\n\t\t(x - x_2)² + (y - y_2)² = (r - s_2*r_2)²\n\t\t(x - x_3)² + (y - y_3)² = (r - s_3*r_3)²\n\n\tfor some combination of signs s_1, s_2 and s_3. \n\n\tThe signs decide if the tangency is *external* (i.e. the solution \n\tcircle touches the other circle on the outside), or if it is internal \n\t(i.e. the solution circle touches the other circle on the inside. \n\n\tThrough the last couple millennia a myriad of solution strategies has\n\tbeen introduced, many of them geometric (solved with a compass and\n\tstraight edge). The solution used here is a purely arithmetic one. \n\n\tFor more information on this solution strategy, see\n\t\n\t\thttps://www.sharelatex.com/read/mxqspwvsbhny\n\n\t---\n\n\tIn this shader we show all 4 solution pairs at the same time in four\n\tseparate panels. This is less cluttered than showing all 8 solutions\n\tat the same time. The two solutions in each panel is related to each\n\tother by a simple sign change, turning every externally tangent\n\tcircle into internally tangent, and vice-versa. \n\t\n\t---\n\n\tSome caveats:\n\n\t\t1. The number of unique solutions is at most 8. If some circles\n\t\t   overlap, or if the radius of one or more circles become \n\t\t   zero (a point) or infinite (a line), multiple solutions \n\t\t   become the same. \n\t\t\n\t\t2. The solution might result in a negative radius. This still\n\t\t   results in a drawable circle if one uses the absolute value,\n\t\t   but externally tangent circles becomes internally tangent, \n\t\t   and vice-versa. \n\n\t\t3. Due to the quadratic nature of the equations there are always\n\t\t   two solutions of the radius (as long as they are not complex). \n\t\t   This means that flipping all the tangency signs gives the same\n\t\t   pair of solutions, only with their order interchanged and the\n           sign flipped. \n*/\n\n// declarations\nfloat sdDisk(vec2 p, float r);\nfloat sdCircle(vec2 p, float r, float t);\n\nvec3 compose(vec3 old, vec3 col, float d);\n\nfloat perpdot(vec2 u, vec2 v);\nvoid solveApollonius(in vec2 P1,  in vec2 P2,  in vec2 P3, \n                     in float s1, in float s2, in float s3, \n                     in float R1, in float R2, in float R3, \n                     out vec2 p1, out vec2 p2, \n                     out float r1, out float r2);\n\n#define ANIMATE\n\n\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // constants\n    vec2 C1 = vec2(-0.45, -0.45);\n    vec2 C2 = vec2( 0.5, -0.55);\n    vec2 C3 = vec2( 0.0,  0.55);\n    \n    #ifdef ANIMATE\n    C1 = C1 - 0.2*vec2(sin(iTime), cos(iTime));\n\t#endif \n    \n    float R1 = 0.3;\n    float R2 = 0.4;\n    float R3 = 0.5;\n\n    // split into 4 panels, 2x2\n    vec2 res = 0.5*iResolution.xy;\n    vec2 coord = mod(fragCoord.xy, res);\n\n    // integers to identify subwindows\n    uvec2 xy = uvec2(2.0*(fragCoord.xy/iResolution.xy));\n\n    // aspect-ratio corrected position in each panel\n    vec2 uv = (2.0 * coord - res)/res.yy;\n    uv *= 1.2;\n    \n\n    // background color\n    vec3 col = vec3(1.0);\n    \n    // base circles\n    col = compose(col, vec3(0.0), sdCircle(uv - C1, R1, 0.01));\n    col = compose(col, vec3(0.0), sdCircle(uv - C2, R2, 0.01));\n    col = compose(col, vec3(0.0), sdCircle(uv - C3, R3, 0.01));\n    \n    // apollonius circles\n    vec2 p1, p2;\n    float r1, r2;\n    if (xy == uvec2(0, 0)) {\n        // blue: externally tangent to all circles\n        // red:  internally tangent to all circles\n    \tsolveApollonius(C1, C2, C3, 1.0, 1.0, 1.0, R1, R2, R3, p1, p2, r1, r2);\n    } else if (xy == uvec2(1, 0)) {\n        // blue: first circle internally tangent, rest externally tangent\n        // red:  first circle extnally tangent, rest internally tangent\n    \tsolveApollonius(C1, C2, C3, -1.0, 1.0, 1.0, R1, R2, R3, p1, p2, r1, r2);\n    } else if (xy == uvec2(0, 1)) {\n        // blue: second circle internally tangent, rest externally tangent\n        // red:  second circle extnally tangent, rest internally tangent\n    \tsolveApollonius(C1, C2, C3, 1.0, -1.0, 1.0, R1, R2, R3, p1, p2, r1, r2);\n    } else if (xy == uvec2(1, 1)) {\n        // blue: third circle internally tangent, rest externally tangent\n        // red:  third circle extnally tangent, rest internally tangent\n    \tsolveApollonius(C1, C2, C3, 1.0, 1.0, -1.0, R1, R2, R3, p1, p2, r1, r2);\n    }\n    col = compose(col, vec3(1.0, 0.0, 0.0), sdCircle(uv - p1, abs(r1), 0.01)); \n    col = compose(col, vec3(0.0, 0.0, 1.0), sdCircle(uv - p2, abs(r2), 0.01)); \n    \n    \n    // borders for each subwindow\n    if (coord.x < 1.0 || \n        coord.y < 1.0 || \n        coord.x >= res.x-2.0 || \n        coord.y >= res.y-2.0 ||\n        fragCoord.x < 3.0 || \n        fragCoord.y < 3.0 || \n        fragCoord.x >= iResolution.x-3.0 || \n        fragCoord.y >= iResolution.y-3.0) {\n    \tcol = vec3(0.0);   \n    }\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n//\nfloat sdDisk(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdCircle(vec2 p, float r, float t) {\n    return abs(length(p) - r) - t;\n}\n\nvec3 compose(vec3 old, vec3 col, float d) {\n    float w = 1.5*fwidth(d);\n    float s = smoothstep(-w/2.0, w/2.0, d);\n    return old*s + col*(1.0 - s);\n}\n\n\nfloat perpdot(vec2 u, vec2 v) {\n \treturn u.x*v.y - u.y*v.x;   \n}\n\nvoid solveApollonius(in vec2 P1,  in vec2 P2,  in vec2 P3, \n                     in float s1, in float s2, in float s3, \n                     in float R1, in float R2, in float R3, \n                     out vec2 p1, out vec2 p2, \n                     out float r1, out float r2) {\n    // see https://www.sharelatex.com/read/mxqspwvsbhny\n    \n    // NOTE: optimized by shifting one of the points to the origin\n    P1 = P1 - P3;\n    P2 = P2 - P3;\n    \n    float A1 = (dot(P1, P1) - R1*R1 + R3*R3)/2.0;\n    float A2 = (dot(P2, P2) - R2*R2 + R3*R3)/2.0;\n    \n    float B1 = (s1*R1 - s3*R3);\n    float B2 = (s2*R2 - s3*R3);\n    \n    float D = perpdot(P1, P2);\n    \n    float M = (A1*P2.y - A2*P1.y)/D;\n    float N = (B1*P2.y - B2*P1.y)/D;\n    float P = (-A1*P2.x + A2*P1.x)/D;\n    float Q = (-B1*P2.x + B2*P1.x)/D;\n    \n    float a = N*N + Q*Q - 1.0;\n    float b = 2.0*(M*N + P*Q + s3*R3);\n    float c = M*M + P*P - R3*R3;\n    \n    // WARNING: Complex solutions? \n    r1 = (-b - sqrt(b*b - 4.0*a*c))/(2.0*a);\n    r2 = (-b + sqrt(b*b - 4.0*a*c))/(2.0*a);\n    \n    p1 = P3 + vec2(M + N*r1, P + Q*r1);\n    p2 = P3 + vec2(M + N*r2, P + Q*r2);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}