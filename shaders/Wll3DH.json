{
    "Shader": {
        "info": {
            "date": "1556224365",
            "description": "wobbly shiny metaballs. metalballs lmaooo my 2nd ever shader",
            "flags": 32,
            "hasliked": 0,
            "id": "Wll3DH",
            "likes": 5,
            "name": "shiny blobby",
            "published": 3,
            "tags": [
                "metaballs",
                "bloom",
                "reflections"
            ],
            "usePreview": 0,
            "username": "MrsBeanbag",
            "viewed": 675
        },
        "renderpass": [
            {
                "code": "// HDR Bloom borrowed from https://www.shadertoy.com/view/XdG3zd\n\n#define KERNEL_SIZE 4\n#define KERNEL_SIZE_F float(KERNEL_SIZE)\nconst float PI = 3.14159265359;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec3 vResult = vec3(0.0);\n    \n    float fTot = 0.0;\n    float fY = -KERNEL_SIZE_F;\n    for( int y=-KERNEL_SIZE; y<=KERNEL_SIZE; y++ )\n    {      \n        vec2 vOffset = vec2( 0.0, fY );\n        vec2 vTapUV =  (fragCoord.xy + vOffset) / iResolution.xy;\n\n        vec3 vTapSample = texture( iChannel0, vTapUV ).rgb;\n        vTapSample -= vec3(1.0);\n        vTapSample = max(vTapSample.rgb, vec3(0.0));\n            \n        float f = fY / KERNEL_SIZE_F;\n            \n        float fWeight = cos(f*PI) + 1.0;\n        vResult += vTapSample * fWeight;\n        fTot += fWeight;\n        fY += 1.0;\n    }\n    vResult *= (2.0) / fTot;\n        \n    vec2 vTapUV = fragCoord.xy / iResolution.xy;\n\tvResult += texture( iChannel0, vTapUV ).rgb;\n    vec3 overbright = max(vResult - vec3(1.0), 0.0);\n    vResult += length(overbright * vec3(0.5, 1.0, 0.3)) * 0.25;\n\n\tfragColor = vec4(vResult, 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// ray marching\nconst int max_iterations = 256;\nconst float grad_step = 0.0001;\nconst float min_dist = 0.0005;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nconst vec3 sky_colour = vec3(0.2, 0.6, 1.0);\nconst vec3 clouds_colour = vec3(1.0);\n//const vec3 sky_colour = vec3(0.0, 0.0, 0.3);\n//const vec3 clouds_colour = vec3(0.3);\nconst vec3 sun_colour = 32.0 * vec3(1.0, 1.0, 0.0);\nconst vec3 sun_pos = normalize(vec3( 20.0, 20.0, 30.0 ));\n\nvec3 diffuse_colour = vec3(0.0);\nvec3 specular_colour = vec3(0.0);\nvec3 reflect_colour = vec3(0.0);\nvec3 final_diff_colour = vec3(0.0);\nvec3 final_spec_colour = vec3(0.0);\nvec3 final_refl_colour = vec3(0.0);\n\n//get a scalar random value from a 3d value\nfloat rand3dTo1d(vec3 value, vec3 dotDir) {\n    //make value smaller to avoid artefacts\n    vec3 smallValue = sin(value);\n    //get scalar value from 3d vector\n    float random = dot(smallValue, dotDir);\n    //make value more random by making it bigger and then taking the factional part\n    random = fract(sin(random) * 143758.5453);\n    return random;\n}\n\nvec3 rand3dTo3d(vec3 value){\n    return vec3(\n        rand3dTo1d(value, vec3(12.989, 78.233, 37.719)),\n        rand3dTo1d(value, vec3(39.346, 11.135, 83.155)),\n        rand3dTo1d(value, vec3(73.156, 52.235, 09.151))\n    );\n}\n\nfloat easeIn(float interpolator){\n    return interpolator * interpolator;\n}\n\nfloat easeOut(float interpolator){\n    return 1.0 - easeIn(1.0 - interpolator);\n}\n\nfloat easeInOut(float interpolator){\n    float easeInValue = easeIn(interpolator);\n    float easeOutValue = easeOut(interpolator);\n    return mix(easeInValue, easeOutValue, interpolator);\n}\n\nfloat perlinNoise(vec3 value){\n    vec3 fraction = fract(value);\n\n    float interpolatorX = easeInOut(fraction.x);\n    float interpolatorY = easeInOut(fraction.y);\n    float interpolatorZ = easeInOut(fraction.z);\n\n    float cellNoiseZ[2];\n    for(int z=0;z<=1;z++){\n        float cellNoiseY[2];\n        for(int y=0;y<=1;y++){\n            float cellNoiseX[2];\n            for(int x=0;x<=1;x++){\n                vec3 cell = floor(value) + vec3(x, y, z);\n                vec3 cellDirection = rand3dTo3d(cell) * 2.0 - 1.0;\n                vec3 compareVector = fraction - vec3(x, y, z);\n                cellNoiseX[x] = dot(cellDirection, compareVector);\n            }\n            cellNoiseY[y] = mix(cellNoiseX[0], cellNoiseX[1], interpolatorX);\n        }\n        cellNoiseZ[z] = mix(cellNoiseY[0], cellNoiseY[1], interpolatorY);\n    }\n    float noise = mix(cellNoiseZ[0], cellNoiseZ[1], interpolatorZ);\n    return noise;\n}\n\n// https://iquilezles.org/articles/smin\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat smax( float a, float b, float k ) {\n    return -smin(-a, -b, k);\n}\n\nfloat metaball(vec3 p) {\n    return 1.0 / dot(p, p);\n}\n\n// get distance in the world\nfloat dist_field( vec3 p ) {\n\tdiffuse_colour = vec3( 0.3);\n\tspecular_colour = vec3( 1.0 );\n    reflect_colour = vec3(0.7);\n\n\tfloat d = 0.0;\n\t{\n        vec3 pb = p + 1.5 * sin(vec3(0.58, 0.71, 0.59) * iTime);\n        d += metaball(pb);\n    }\n\t{\n        vec3 pb = p + 1.5 * sin(vec3(0.47, 1.84, 1.16) * iTime);\n        d += metaball(pb);\n    }\n\t{\n        vec3 pb = p + 1.5 * sin(vec3(0.83, 0.94, 0.52) * iTime);\n        d += metaball(pb);\n    }\n\t{\n        vec3 pb = p + 1.5 * sin(vec3(1.21, 0.92, 0.74) * iTime);\n        d += metaball(pb);\n    }\n    d = 1.0/sqrt(d) - 0.8 + sin(iTime * 2.1) * 0.2;\n    \n    float lp = length(p);\n\n    d = smax(lp-2.7, d, 0.01);\n    \n    float d2 = -(lp-1.5);\n    if (d2 > d) {\n        specular_colour = vec3(0.0);\n\t    reflect_colour = vec3(0.0);\n        diffuse_colour = vec3(0.2);\n        d = d2;\n    }\n\n    float d3 = (lp-1.2);\n    if (d3 < d) {\n        specular_colour = vec3(1.0);\n        reflect_colour = vec3(0.7, 0.2, 0.01);\n        diffuse_colour = vec3(0.3, 0.1, 0.0);\n        d = d3;\n    }\n        \n    return d;\n}\n\nfloat ray_sphere(float rSq, vec3 p, vec3 dir) {\n    float pSq = dot(p, p);\n    if (pSq <= rSq) {\n        return 0.0;\n    }\n    \n    float b = dot(dir, p);\n    float ac = dot(dir, dir) * (pSq - rSq);\n    float h = b*b - ac;\n\n    if (h < 0.0) {\n        return clip_far;\n    } else {\n        return (-b - sqrt(h));\n    }\n}\n\nfloat ray_field(vec3 p, vec3 dir) {\n    float r = ray_sphere(2.7 * 2.7, p, dir);\n    \n    return r;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 p ) {\n    const vec2 k = vec2(1,-1);\n    const vec2 kg = vec2(grad_step,-grad_step);\n    return vec3( k.xyy*dist_field( p + kg.xyy) +\n                 k.yyx*dist_field( p + kg.yyx) +\n                 k.yxy*dist_field( p + kg.yxy) +\n                 k.xxx*dist_field( p + kg.xxx) );\n}\n\n// parallel light source\nvec3 shading( vec3 v, vec3 n, vec3 dir, vec3 eye ) {\n\tvec3 light_pos   = vec3( 20.0, 20.0, 30.0 );\n\tvec3 light_colour = vec3( 1.0 );\n\n\tfloat diffuse  = max( 0.0, dot( sun_pos, n ) );\n\n\treturn light_colour * final_diff_colour * diffuse;\n}\n\nfloat inner_sphere(float rSq, vec3 p, vec3 dir) {\n    float pSq = dot(p, p);\n    \n    float b = dot(dir, p);\n    float ac = dot(dir, dir) * (pSq - rSq);\n    float h = b*b - ac;\n\n    return (-b + sqrt(h));\n}\n\nvec3 skybox(vec3 dir) {\n    if (dir.y >= 0.0) {\n        float r = 1.0;\n        vec3 c = vec3(0.0, 0.9999, 0.0);\n        float i = inner_sphere(r*r, c, dir);\n        vec3 v = 10000.0 * (i * dir - c);\n        float cloud = perlinNoise(v);\n        //cloud = fract(v.y);\n        cloud = smoothstep(0.0, 1.0, cloud);\n        float horizon = smoothstep(0.0, 0.25, dir.y);\n        cloud = mix(0.8, cloud, horizon);\n        vec3 sky = mix(sky_colour, clouds_colour, cloud);\n\n        float sun = max( 0.0, dot( dir, sun_pos ) );\n\t\tsun = smoothstep( 0.99, 1.0, sun);\n        sun = pow(sun, 20.0);\n\n        return sky + sun * sun_colour;\n    } else {\n        vec3 floor = vec3(dir.x, dir.z, sin(iTime* 0.1));\n        floor /= dir.y;\n        float noise = perlinNoise(4.0*floor);\n        noise *= noise;\n        float fog = exp(-0.05*length(floor.xy));\n        vec3 ground = mix(vec3(0.0, 0.3, 0.4), vec3(2.0), noise);\n        return mix(sky_colour, ground, fog);\n    }\n}\n\n// Calculate a fresnel term for reflections\nfloat fresnelTerm(in vec3 dir, in vec3 n) {\n\tfloat fresnel = min(1., dot(dir, n) + 1.0);\n    return fresnel * fresnel;\n}\n\n// ray marching\n// Enhanced Sphere Tracing:\n// http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\nvec3 ray_marching(vec3 o, vec3 dir) {\n    vec3 colour = vec3(0.0);\n    vec3 acc_refl = vec3(1.0);\n    for (int j = 0; j < 4; j++) {\n      \tfloat t = ray_field(o, dir);\n       \tif (t >= clip_far || t < 0.0) {\n            colour += acc_refl * skybox(dir);\n           \treturn colour;\n        }\n\t    t = max(t-min_dist*2.0, min_dist*2.0);\n            \n        vec3 v;\n        float overstep = 0.0;\n    \tfor (int i = 0; i < max_iterations; i++) {\n        \tfloat d = dist_field(v = o + dir * t);\n            if (overstep > 0.0 && d < overstep) {\n                t -= overstep;\n                overstep = 0.0;\n                continue;\n            }\n            \n            if (d <= min_dist) {\n                break;\n            }\n        \tif ((t+=d) >= clip_far) {\n                colour += acc_refl * skybox(dir);\n            \treturn colour;\n\t        }\n            overstep = d*0.618;\n            t+=overstep;\n    \t}\n\t\tfinal_diff_colour = diffuse_colour;\n\t\tfinal_spec_colour = specular_colour;\n    \tfinal_refl_colour = reflect_colour;\n        vec3 g = gradient(v);\n        if (!(g == g)) {\n            return vec3(0.0);\n        }\n    \tvec3 n = normalize( g );\n\n    \tcolour += acc_refl * shading( v, n, dir, o );\n        \n        float fresnel = fresnelTerm(dir, n);\n        final_refl_colour = mix(final_refl_colour,\n                                final_spec_colour,\n                                fresnel);\n        \n        if (final_refl_colour == vec3(0.0)) {\n            break;\n        } else {\n            acc_refl *= final_refl_colour;\n            dir = reflect(dir, n);\n            o = v;\n        }\n    }\n    \n    return colour;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2( sin(iTime * 0.31)*0.3, iTime * 0.2 ) );\n\t//mat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 6.0 );\n\teye = rot * eye;\n\n    // default ray dir\n\tvec3 dir = rot * ray_dir( 60.0, iResolution.xy, fragCoord.xy + vec2(-0.5, -0.5));\n\tvec3 color = ray_marching(eye, dir);\n\n\tfragColor = vec4(color, 1.0);\n    return;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// This is a duplicate of Buffer A with a half-pixel offset\n// in order to do anti-aliasing lmao\n\n// ray marching\nconst int max_iterations = 256;\nconst float grad_step = 0.0001;\nconst float min_dist = 0.0005;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nconst vec3 sky_colour = vec3(0.2, 0.6, 1.0);\nconst vec3 clouds_colour = vec3(1.0);\n//const vec3 sky_colour = vec3(0.0, 0.0, 0.3);\n//const vec3 clouds_colour = vec3(0.3);\nconst vec3 sun_colour = 32.0 * vec3(1.0, 1.0, 0.0);\nconst vec3 sun_pos = normalize(vec3( 20.0, 20.0, 30.0 ));\n\nvec3 diffuse_colour = vec3(0.0);\nvec3 specular_colour = vec3(0.0);\nvec3 reflect_colour = vec3(0.0);\nvec3 final_diff_colour = vec3(0.0);\nvec3 final_spec_colour = vec3(0.0);\nvec3 final_refl_colour = vec3(0.0);\n\n//get a scalar random value from a 3d value\nfloat rand3dTo1d(vec3 value, vec3 dotDir) {\n    //make value smaller to avoid artefacts\n    vec3 smallValue = sin(value);\n    //get scalar value from 3d vector\n    float random = dot(smallValue, dotDir);\n    //make value more random by making it bigger and then taking the factional part\n    random = fract(sin(random) * 143758.5453);\n    return random;\n}\n\nvec3 rand3dTo3d(vec3 value){\n    return vec3(\n        rand3dTo1d(value, vec3(12.989, 78.233, 37.719)),\n        rand3dTo1d(value, vec3(39.346, 11.135, 83.155)),\n        rand3dTo1d(value, vec3(73.156, 52.235, 09.151))\n    );\n}\n\nfloat easeIn(float interpolator){\n    return interpolator * interpolator;\n}\n\nfloat easeOut(float interpolator){\n    return 1.0 - easeIn(1.0 - interpolator);\n}\n\nfloat easeInOut(float interpolator){\n    float easeInValue = easeIn(interpolator);\n    float easeOutValue = easeOut(interpolator);\n    return mix(easeInValue, easeOutValue, interpolator);\n}\n\nfloat perlinNoise(vec3 value){\n    vec3 fraction = fract(value);\n\n    float interpolatorX = easeInOut(fraction.x);\n    float interpolatorY = easeInOut(fraction.y);\n    float interpolatorZ = easeInOut(fraction.z);\n\n    float cellNoiseZ[2];\n    for(int z=0;z<=1;z++){\n        float cellNoiseY[2];\n        for(int y=0;y<=1;y++){\n            float cellNoiseX[2];\n            for(int x=0;x<=1;x++){\n                vec3 cell = floor(value) + vec3(x, y, z);\n                vec3 cellDirection = rand3dTo3d(cell) * 2.0 - 1.0;\n                vec3 compareVector = fraction - vec3(x, y, z);\n                cellNoiseX[x] = dot(cellDirection, compareVector);\n            }\n            cellNoiseY[y] = mix(cellNoiseX[0], cellNoiseX[1], interpolatorX);\n        }\n        cellNoiseZ[z] = mix(cellNoiseY[0], cellNoiseY[1], interpolatorY);\n    }\n    float noise = mix(cellNoiseZ[0], cellNoiseZ[1], interpolatorZ);\n    return noise;\n}\n\n// https://iquilezles.org/articles/smin\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat smax( float a, float b, float k ) {\n    return -smin(-a, -b, k);\n}\n\nfloat metaball(vec3 p) {\n    return 1.0 / dot(p, p);\n}\n\n// get distance in the world\nfloat dist_field( vec3 p ) {\n\tdiffuse_colour = vec3( 0.3);\n\tspecular_colour = vec3( 1.0 );\n    reflect_colour = vec3(0.7);\n\n\tfloat d = 0.0;\n\t{\n        vec3 pb = p + 1.5 * sin(vec3(0.58, 0.71, 0.59) * iTime);\n        d += metaball(pb);\n    }\n\t{\n        vec3 pb = p + 1.5 * sin(vec3(0.47, 1.84, 1.16) * iTime);\n        d += metaball(pb);\n    }\n\t{\n        vec3 pb = p + 1.5 * sin(vec3(0.83, 0.94, 0.52) * iTime);\n        d += metaball(pb);\n    }\n\t{\n        vec3 pb = p + 1.5 * sin(vec3(1.21, 0.92, 0.74) * iTime);\n        d += metaball(pb);\n    }\n    d = 1.0/sqrt(d) - 0.8 + sin(iTime * 2.1) * 0.2;\n    \n    float lp = length(p);\n\n    d = smax(lp-2.7, d, 0.01);\n    \n    float d2 = -(lp-1.5);\n    if (d2 > d) {\n        specular_colour = vec3(0.0);\n\t    reflect_colour = vec3(0.0);\n        diffuse_colour = vec3(0.2);\n        d = d2;\n    }\n\n    float d3 = (lp-1.2);\n    if (d3 < d) {\n        specular_colour = vec3(1.0);\n        reflect_colour = vec3(0.7, 0.2, 0.01);\n        diffuse_colour = vec3(0.3, 0.1, 0.0);\n        d = d3;\n    }\n        \n    return d;\n}\n\nfloat ray_sphere(float rSq, vec3 p, vec3 dir) {\n    float pSq = dot(p, p);\n    if (pSq <= rSq) {\n        return 0.0;\n    }\n    \n    float b = dot(dir, p);\n    float ac = dot(dir, dir) * (pSq - rSq);\n    float h = b*b - ac;\n\n    if (h < 0.0) {\n        return clip_far;\n    } else {\n        return (-b - sqrt(h));\n    }\n}\n\nfloat ray_field(vec3 p, vec3 dir) {\n    float r = ray_sphere(2.7 * 2.7, p, dir);\n    \n    return r;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 p ) {\n    const vec2 k = vec2(1,-1);\n    const vec2 kg = vec2(grad_step,-grad_step);\n    return vec3( k.xyy*dist_field( p + kg.xyy) +\n                 k.yyx*dist_field( p + kg.yyx) +\n                 k.yxy*dist_field( p + kg.yxy) +\n                 k.xxx*dist_field( p + kg.xxx) );\n}\n\n// parallel light source\nvec3 shading( vec3 v, vec3 n, vec3 dir, vec3 eye ) {\n\tvec3 light_pos   = vec3( 20.0, 20.0, 30.0 );\n\tvec3 light_colour = vec3( 1.0 );\n\n\tfloat diffuse  = max( 0.0, dot( sun_pos, n ) );\n\n\treturn light_colour * final_diff_colour * diffuse;\n}\n\nfloat inner_sphere(float rSq, vec3 p, vec3 dir) {\n    float pSq = dot(p, p);\n    \n    float b = dot(dir, p);\n    float ac = dot(dir, dir) * (pSq - rSq);\n    float h = b*b - ac;\n\n    return (-b + sqrt(h));\n}\n\nvec3 skybox(vec3 dir) {\n    if (dir.y >= 0.0) {\n        float r = 1.0;\n        vec3 c = vec3(0.0, 0.9999, 0.0);\n        float i = inner_sphere(r*r, c, dir);\n        vec3 v = 10000.0 * (i * dir - c);\n        float cloud = perlinNoise(v);\n        //cloud = fract(v.y);\n        cloud = smoothstep(0.0, 1.0, cloud);\n        float horizon = smoothstep(0.0, 0.25, dir.y);\n        cloud = mix(0.8, cloud, horizon);\n        vec3 sky = mix(sky_colour, clouds_colour, cloud);\n\n        float sun = max( 0.0, dot( dir, sun_pos ) );\n\t\tsun = smoothstep( 0.99, 1.0, sun);\n        sun = pow(sun, 20.0);\n\n        return sky + sun * sun_colour;\n    } else {\n        vec3 floor = vec3(dir.x, dir.z, sin(iTime* 0.1));\n        floor /= dir.y;\n        float noise = perlinNoise(4.0*floor);\n        noise *= noise;\n        float fog = exp(-0.05*length(floor.xy));\n        vec3 ground = mix(vec3(0.0, 0.3, 0.4), vec3(2.0), noise);\n        return mix(sky_colour, ground, fog);\n    }\n}\n\n// Calculate a fresnel term for reflections\nfloat fresnelTerm(in vec3 dir, in vec3 n) {\n\tfloat fresnel = min(1., dot(dir, n) + 1.0);\n    return fresnel * fresnel;\n}\n\n// ray marching\n// Enhanced Sphere Tracing:\n// http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\nvec3 ray_marching(vec3 o, vec3 dir) {\n    vec3 colour = vec3(0.0);\n    vec3 acc_refl = vec3(1.0);\n    for (int j = 0; j < 4; j++) {\n      \tfloat t = ray_field(o, dir);\n       \tif (t >= clip_far || t < 0.0) {\n            colour += acc_refl * skybox(dir);\n           \treturn colour;\n        }\n\t    t = max(t-min_dist*2.0, min_dist*2.0);\n            \n        vec3 v;\n        float overstep = 0.0;\n    \tfor (int i = 0; i < max_iterations; i++) {\n        \tfloat d = dist_field(v = o + dir * t);\n            if (overstep > 0.0 && d < overstep) {\n                t -= overstep;\n                overstep = 0.0;\n                continue;\n            }\n            \n            if (d <= min_dist) {\n                break;\n            }\n        \tif ((t+=d) >= clip_far) {\n                colour += acc_refl * skybox(dir);\n            \treturn colour;\n\t        }\n            overstep = d*0.618;\n            t+=overstep;\n    \t}\n\t\tfinal_diff_colour = diffuse_colour;\n\t\tfinal_spec_colour = specular_colour;\n    \tfinal_refl_colour = reflect_colour;\n        vec3 g = gradient(v);\n        if (!(g == g)) {\n            return vec3(0.0);\n        }\n    \tvec3 n = normalize( g );\n\n    \tcolour += acc_refl * shading( v, n, dir, o );\n        \n        float fresnel = fresnelTerm(dir, n);\n        final_refl_colour = mix(final_refl_colour,\n                                final_spec_colour,\n                                fresnel);\n        \n        if (final_refl_colour == vec3(0.0)) {\n            break;\n        } else {\n            acc_refl *= final_refl_colour;\n            dir = reflect(dir, n);\n            o = v;\n        }\n    }\n    \n    return colour;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2( sin(iTime * 0.31)*0.3, iTime * 0.2 ) );\n\t//mat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 6.0 );\n\teye = rot * eye;\n\n    float aa = 1.0;\n    // default ray dir\n\tvec3 dir = rot * ray_dir( 60.0, iResolution.xy, fragCoord.xy);\n\tvec3 color = ray_marching(eye, dir);\n\n    // the channel has linear filter so this should the the average\n    // of four pixels\n    vec2 vTapUV = (fragCoord.xy + vec2(0.5, 0.5)) / iResolution.xy;\n\tcolor += aa * texture( iChannel0, vTapUV ).rgb;\n\n    color /= 1.0 + aa;\n    \n\tfragColor = vec4(color, 1.0);\n    return;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// HDR Bloom borrowed from https://www.shadertoy.com/view/XdG3zd\n\n#define KERNEL_SIZE 4\n#define KERNEL_SIZE_F float(KERNEL_SIZE)\nconst float PI = 3.14159265359;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec3 vResult = vec3(0.0);\n    \n    float fTot = 0.0;\n    float fX = -KERNEL_SIZE_F;\n\tfor( int x=-KERNEL_SIZE; x<=KERNEL_SIZE; x++ )\n    {            \n        vec2 vOffset = vec2( fX, 0.0 );\n        vec2 vTapUV =  (fragCoord.xy + vOffset) / iResolution.xy;\n\n        vec3 vTapSample = texture( iChannel0, vTapUV ).rgb;\n        vTapSample -= vec3(1.0);\n        vTapSample = max(vTapSample.rgb, vec3(0.0));\n            \n        float f = fX / KERNEL_SIZE_F;\n            \n        float fWeight = cos(f*PI) + 1.0;\n        vResult += vTapSample * fWeight;\n        fTot += fWeight;\n\t    fX += 1.0;\n    }\n    vResult *= (2.0) / fTot;\n        \n    vec2 vTapUV = fragCoord.xy / iResolution.xy;\n\tvResult += texture( iChannel0, vTapUV ).rgb;\n\n\tfragColor = vec4(vResult, 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}