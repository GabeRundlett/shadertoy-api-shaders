{
    "Shader": {
        "info": {
            "date": "1637499519",
            "description": "ray march",
            "flags": 0,
            "hasliked": 0,
            "id": "styGRm",
            "likes": 7,
            "name": "Ray March glass and mirror",
            "published": 3,
            "tags": [
                "raymarch"
            ],
            "usePreview": 0,
            "username": "yurka",
            "viewed": 371
        },
        "renderpass": [
            {
                "code": "vec3 light = vec3(1.0, 1.0, 1.0);\n\nstruct scene_sf \n{\n    float d;\n    float depth;\n    vec3 col;\n    int type; // 0 - regular, 1 - mirror, 2 glass\n    vec3 n;\n};\n\nscene_sf scene_dist(vec3 ap)\n{\n    const float gridsteps = 11.0;\n    scene_sf rs;\n    //vec3 so = vec3(sin(iTime*0.4) * 0.3, sin(iTime*3.14*0.4)*0.1, cos(iTime*0.4) * 3.7 + 3.0);\n    vec3 so = vec3(sin(iTime*0.4) * 0.2, 0.1, cos(iTime*0.4) * 0.2);\n    rs.d = length(ap - so) - 0.1;\n    vec3 pn = -normalize(ap - so);\n    float ldot = dot(pn, light);\n    if (ldot < 0.0) ldot = 0.0;\n    float vdot = dot(pn, vec3(0.0, -sin(iTime * 1.2), cos(iTime * 1.2)));\n    float hdot = dot(pn, vec3(0.0, cos(iTime * 1.2), sin(iTime * 1.2)));\n    float sdot = dot(pn, vec3(1.0, 0.0, 0.0));\n    float vang = acos(vdot);\n    float hang = acos(hdot);\n    float sang = acos(sdot);\n    rs.col = vec3(1.0, 1.0, 1.0);\n    if (int(hang * gridsteps / 3.14) % 2 == 0)\n        rs.col = rs.col - vec3(1.0, 0.0, 0.0);\n    if (int(vang * gridsteps / 3.14) % 2 == 0)\n        rs.col = rs.col - vec3(0.0, 1.0, 0.0);\n    if (int(sang * gridsteps / 3.14) % 2 == 0)\n        rs.col = rs.col - vec3(0.0, 0.0, 1.0);\n    rs.type = 0;\n    rs.n = -pn;\n    //ldot = 1.0;\n    \n    so = vec3(sin(iTime*0.4 + 2.093) * 0.2, 0.1, cos(iTime*0.4 + 2.093) * 0.2);\n    float glsd = length(ap - so) - 0.1;\n    if (glsd < rs.d) {\n        rs.d = glsd;\n        pn = -normalize(ap - so);\n        ldot = dot(pn, light);\n        if (ldot < 0.0) ldot = 0.0;\n        rs.col = vec3(0.0, 0.5, 1.0);\n        rs.type = 1;\n        rs.n = -pn;\n    }\n    \n    so = vec3(sin(iTime*0.4 + 4.186) * 0.2, 0.1, cos(iTime*0.4 + 4.186) * 0.2);\n    glsd = length(ap - so) - 0.1;\n    if (glsd < rs.d) {\n        rs.d = glsd;\n        pn = -normalize(ap - so);\n        ldot = dot(pn, light);\n        if (ldot < 0.0) ldot = 0.0;\n        rs.col = vec3(0.0, 0.5, 1.0);\n        rs.type = 2;\n        rs.n = -pn;\n    }\n    \n    float plane_h = 0.7;\n    if ((ap.y + plane_h) < rs.d) {\n        vec3 plnorm = vec3(0.0, 1.0, 0.0);\n        rs.d = (ap.y + plane_h);\n        if ((int(floor(ap.x)) % 2 + 2) % 2 == (int(floor(ap.z)) % 2 + 2) % 2 )\n            rs.col = vec3(1.0, 1.0, 1.0);\n        else\n            rs.col = vec3(0.0, 0.0, 0.0);\n        //rs.col = vec3(1.0, 0.0, 0.0);\n        ldot = -dot(plnorm, light);\n        if (ldot < 0.0) ldot = 0.0;\n        rs.type = 0;\n        rs.n = plnorm;\n    }\n    \n    float athmo_r = 5.0;\n    if (athmo_r - length(ap) < rs.d) {\n        rs.d = athmo_r - length(ap);\n        float ag = atan(ap.x, ap.z) / 3.14;\n        float cr = 1.0 - 30.0 * abs(fract(ag * 36.0) - 0.5);\n        if (cr < 0.0) cr = 0.0;\n        float agv = atan(sqrt(ap.z*ap.z + ap.x*ap.x), ap.y) / 3.14;\n        float cg = 1.0 - 30.0 * abs(fract(agv * 36.0) - 0.5);\n        if (cg < 0.0) cg = 0.0;\n        rs.col = vec3(cr, cg, ap.y / athmo_r);\n        ldot = 1.0;//-dot(vec3(0.0, 1.0, 0.0), light);\n        if (ldot < 0.0) ldot = 0.0;\n        rs.type = 0;\n        rs.n = -normalize(ap);\n    }\n    \n    rs.col= rs.col * ldot;\n    return rs; // sphere\n}\n\nscene_sf rmarch(vec3 aro, vec3 ard) \n{\n    vec3 p = aro;\n    float depth = 0.0;\n    scene_sf sf;\n    float prefsfd = 1.0;\n    for (int i = 0; i < 250; i++) {\n        sf = scene_dist(p);\n        float ds = abs(sf.d);\n        if (ds < 0.0001) ds = 0.0001;\n        p += ds * ard;\n        depth += ds;\n        if (depth > 100.0)\n           break;\n        if (sf.type == 1 && sf.d < 0.000) {\n            if (dot(ard, sf.n) < 0.0) {\n                ard = reflect(ard, sf.n);\n            }\n        }\n        else\n        if (sf.type == 2) {\n            if (prefsfd > 0.0 && sf.d <= 0.0) {\n                ard = refract(ard, sf.n, 1.0/1.6290);\n            }\n            if (prefsfd <= 0.0 && sf.d > 0.0) {\n                ard = refract(ard, -sf.n, 1.6290);\n            }\n        }\n        else\n        if (sf.d < 0.000)\n            break;\n\n        prefsfd = sf.d;\n    }\n    if (depth > 100.0)\n        depth = 100.0;\n    sf.depth = depth;\n    return sf;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //light = vec3(sin(iTime*2.1), -1.0, cos(iTime*2.1));\n    light = vec3(1.0, -1.0, 1.0);\n    light = normalize(light);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.x;\n    vec2 muv = iMouse.xy/iResolution.x;\n    \n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0.0) - ro);\n    \n    scene_sf sf = rmarch(ro, rd);\n    \n    float smoge = 1.0 - pow(0.93, sf.depth);\n    \n    vec3 col = vec3(0.88, 0.88, 0.88);\n    //if (sf.d < 0.001) \n    col = col * smoge + sf.col * (1.0 - smoge);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}