{
    "Shader": {
        "info": {
            "date": "1557734410",
            "description": "cheap spikeyHexScale uv+Id\n\nplaying around with hex uv, i found some crunching potential.\nthere is some semi-bilinear conditioning, and its inputs can be squared.",
            "flags": 0,
            "hasliked": 0,
            "id": "3ll3W2",
            "likes": 2,
            "name": "please fix these NaNs",
            "published": 3,
            "tags": [
                "scale",
                "hexagonal",
                "kerning"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 416
        },
        "renderpass": [
            {
                "code": "//get inner uv.xy (or barycentric) AND ger a 3d tileID\n//this is VERY arbitiary.\n//i prefer carthesian here, if only for compression.\n\n//a nice shape for very basic crowd-scene (without NaNs)\n//#define KeyholeCircles\n\n\n#define dd(a) dot(a,a)\n\nfloat mi(vec2 a){return min(a.x,a.y);}\nfloat mi(vec4 a){return min(mi(a.xy),mi(a.zw));}\nvec2 cs(float a){return vec2(cos(a),sin(a));}\n\nvec4 hex2(out vec4 o,vec2 i//https://www.shadertoy.com/view/4lt3DX\n){const float w=1.53,q=w*.5\n ;vec2 v=iResolution.xy\n ,u=i=(i-v/2.)/v.y*5.*q //center\n ;//if(u.x!=u.x)u.x=1.//not busting a NaN!\n ;//if(u.y!=u.y)u.y=1.//not busting a NaN!\n ;u*=mat2(1.,-1./w,0.,2./w)\n ;vec3 g=vec3(u,1.-u.xy)//to hex\n ;u=floor(g).xy*mat2(1.,.5,0.,q)//cell id\n ;vec2 a=u+vec2(1,0)\n      ,b=u+vec2(.5,q)\n      ,c=u+vec2(1.5,q)\n ;//4 SQUARED screenspace distances to nodes:\n ;vec4 f=vec4(dd(b-i),dd(a-i),dd(u-i),dd(c-i))\n ;f.w=mi(f)//set .w to shortest of 4 distances  \n ;//if(f.w!=f.w)f.w=0.//not busting a NaN!\n ;vec2 m=iMouse.xy/iResolution.xy\n ;if(iMouse.z<=0.)m.xy=cs(iTime)*.5+.5\n #ifdef KeyholeCircles\n ;f.w=exp2(-23.)//optional cheap keyhole-circles\n #endif\n ;//if(iMouse.z<=0.) m.x=1.//results in a NaN\n ;//m.x=1.//overwrites a NaN to 1.0\n     //its an uninitialized mouse thing?\n ;//m.x=1.//this overwrites a NaN to 1.0\n ;if(f.w!=0.&&m.x!=0.)f.w=pow(abs(f.w),m.x)//not busting a NaN!\n ;else f.w=.5\n ;f.xyz=step(vec3(0),f.w-f.xyz)\n //i guess the step() function is a bit nan?\n ;//if(f.x!=f.x)f.x=0.//not busting a NaN!\n ;//if(f.y!=f.y)f.y=0.//not busting a NaN!\n ;//if(f.z!=f.z)f.z=0.//not busting a NaN!\n /*\n ;vec2 z=c+(b-c)*l.x //mix(c,b,f.x)\n ;vec2 y=z+(a-z)*l.y //mix(z,a,f.y) \n ;vec2 t=y+(u-y)*l.z //mix(y,u,f.z)/**/\n //above looked very semi-bilinear, it simplifies to the below:\n ;b=(b-c)*f.x\n ;a=(a-c-b)*f.y \n ;c=c+b+a\n ;vec2 t=mix(c,u,f.z) //c+(u-c)*l.z   \n ;u=i-t \n ;return vec4(u,t)//unformatted output\n  /*   \n ;return vec4(u.xy+vec2(.5,.0)\n              ,0,0).xzyw  //*.5\n         +fract(vec4(0,1,0,0)*t.x     *.5)\n          +fract(vec4(1,1,0,0)*t.y)//uv,tileix (both in carthesian)\n ;//below is more colorful:\n ;return vec4(u,t)//uv,tileix (both in carthesian)\n ;t=t*.25+vec2(.5)//shift to visible range\n ;return vec4(fract(length(u.xy)*6.),t,1)\n/**/\n ;}\n\n\nvoid mainImage( out vec4 o, in vec2 u\n){float t=iTime\n ;vec3 r=iResolution\n ;o=hex2(o,u)\n     \n\n/* ;o=0.//o.xzyw  //*.5\n         +fract(vec4(0,1,0,0)*o.z     *.5)\n          +fract(vec4(1,1,0,0)*o.w)*/\n    /**/\n ;float a=length(o.xy)//euclidean distance to center\n\n ;a=smoothstep(.05,-.05,a-.1)//smooth circle in hex center\n ;vec2 id=fract(o.zw*.5)//tileID gets fractured\n ;o.xz=o.xy*.5+.5//show uv in redBlue, shift negative into visible.\n ;//o.y=0.\n ;o.y=mix(0.,id.x,a)//greenness of dots is set by id.x\n ;o.z=mix(o.z,(id.y),a)//blueness of id.x is set by id.y\n \n\n ;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\ndumped older versions\n*/\n\n/*\nvec4 hex1(out vec4 o,vec2 i//https://www.shadertoy.com/view/4lt3DX\n){const float w=1.53,q=w*.5\n ;vec2 v=iResolution.xy\n ,u=i=(i-v/2.)/v.y*5.*q //center\n ;u*=mat2(1.,-1./w,0.,2./w)\n ;vec3 g=vec3(u,1.-u.xy)//to hex\n ;u=floor(g).xy*mat2(1.,.5,0.,q)//cell id\n ;vec2 a=u+vec2(1,0)\n      ,b=u+vec2(.5,q)\n      ,c=u+vec2(1.5,q)\n ;float f=length(u-i)\n ,k=length(a-i)\n ,h=length(b-i)\n ,j=length(c-i)//screenspace distance to nodes\n ,d=(min(min(f,k),min(h,j)))//closest node: d=dist, t=TileCoord\n ;\n ;vec2 z=b;if(d!=h)z=c//z=d==h?b:c;//f(d==f)z=u//z=(d==f)?u:d\n ;vec2 y=a;if(d!=k)y=z//y=d==k?a:z\n ;vec2 t=u;if(d!=f)t=y//((d==f)?u:y)\n ;u=i-t\n ;return vec4(u.xy+.5,0,0).xzyw  *.5\n          +vec4(0,1,0,0)*t.x     *.5\n          +vec4(1,1,0,0)*t.y//uv,tileix (both in carthesian)\n ;//below is more colorful:\n ;return vec4(u,t)//uv,tileix (both in carthesian)\n ;t=t*.25+vec2(.5)//shift to visible range\n ;return vec4(fract(length(u.xy)*6.),t,1)\n ;}\n\nvec4 hex0(out vec4 o,vec2 i//https://www.shadertoy.com/view/4lt3DX\n){const float w=1.53,q=w*.5\n ;vec2 v=iResolution.xy\n ,u=i=(i-v/2.)/v.y*5.*q //center\n ;u*=mat2(1.,-1./w,0.,2./w)\n ;vec3 g=vec3(u,1.-u.xy)//to hex\n ;u=floor(g).xy*mat2(1.,.5,0.,q)//cell id\n ;vec2 a=u+vec2(1,0),b=u+vec2(.5,q),c=u+vec2(1.5,q)\n ;float f=(dd(u-i))\n ,k=(dd(a-i))\n ,h=(dd(b-i))\n ,j=(dd(c-i))//screenspace distance to nodes\n ,d=(min(min(f,k),min(h,j)))//closest node: d=dist, t=TileCoord\n ;vec2 t=(d==f?u:d==k?a:d==h?b:c);u=i-t\n ;//return vec4(u.x,0,u.y,0)+vec4(0)//uv,tileix (both in carthesian)\n ;//below is more colorful:\n ;t=t*.25+vec2(.5)//shift to visible range\n ;return vec4(fract(length(u.xy)*6.),t,1)\n ;}\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}