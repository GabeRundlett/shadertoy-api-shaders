{
    "Shader": {
        "info": {
            "date": "1590655124",
            "description": "See [url]http://paulbourke.net/fractals/wada/[/url]\n\nA tetrahedron of shiny spheres.\n\nup/down to zoom, mouse to rotate, c,d for background colour, v to vary sphere radius,",
            "flags": 48,
            "hasliked": 0,
            "id": "Wdjfzt",
            "likes": 13,
            "name": "The Spheres of Wada",
            "published": 3,
            "tags": [
                "reflection",
                "spheres",
                "wada"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 425
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// The Spheres of Wada\n//\n// Matthew Arcus, mla, 2020.\n//\n// Something that I haven't seen on Shadertoy:\n// http://paulbourke.net/fractals/wada/\n//\n// Repeated reflections in tangential spheres produces Apollonian-\n// like fractal patterns.\n//\n// mouse + up/down to rotate and zoom\n// left/right to vary attenuation\n// c and d affect background colour\n// v to vary sphere radius for extra weirdness\n// r to stop autorotation\n// h to move viewpoint to centre with almost enclosing spheres\n//\n// Different base polyhedra also available.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n#if 1\nconst float K = 0.5*sqrt(2.0);\nconst int NSPHERES = 4;\nvec4 spheres[NSPHERES] =\n  vec4[](vec4(1,0,K,1),vec4(-1,0,K,1),vec4(0,1,-K,1),vec4(0,-1,-K,1));\n#elif 1\n// Octahedron\nconst int NSPHERES = 6;\nvec4 spheres[NSPHERES] =\n  vec4[](vec4(1,0,1,1),vec4(-1,0,1,1),vec4(1,0,-1,1),vec4(-1,0,-1,1),\n         vec4(0,sqrt(2.0),0,1),vec4(0,-sqrt(2.0),0,1));\n#else\n// Cube\nconst int NSPHERES = 8;\nvec4 spheres[NSPHERES] =\n  vec4[](vec4(1,1,1,1),vec4(-1,1,1,1),vec4(1,1,-1,1),vec4(-1,1,-1,1),\n         vec4(1,-1,1,1),vec4(-1,-1,1,1),vec4(1,-1,-1,1),vec4(-1,-1,-1,1));\n#endif\n\nconst int MAXSTEPS = 50;\n\nfloat intersectsphere(vec3 p, vec3 r, vec4 sphere) {\n  p -= sphere.xyz; // Centre on sphere\n  float r2 = sphere.w; // Sphere radius squared\n  // Want dot(p+t*r,p+t*r) = r2\n  // ie. p.p - r2 + 2tp.r + t^2 = 0\n  float A = 1.0;\n  float B = dot(p,r);\n  float C = dot(p,p)-r2;\n  float D = B*B - C;\n  if (D < 0.0) return -1.0;\n  D = sqrt(D);\n  float t,t1;\n  if (B >= 0.0) {\n    t = -B-D; t1 = C/t;\n  } else {\n    t1 = -B+D; t = C/t1;\n  }\n  //if (t < 0.0) t = t1;\n  return t;\n}\n\nvec3 transform(in vec3 p) {\n  if (!key(CHAR_R)) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.zx = rotate(p.zx,phi);\n    p.yz = rotate(p.yz,-theta);\n  }\n  return p;\n}\n\nvec3 skycolor(vec3 r) {\n  vec3 col = vec3(1);\n  if (!key(CHAR_C)) col *= pow(abs(r),vec3(2.0));\n  if (!key(CHAR_D)) col *= texture(iChannel0,r).rgb;\n  return col;\n}\n\nfloat attenuation = 1.0;\n\nvec3 raycolor(vec3 p, vec3 r) {\n  int lastsphere = -1;\n  float att = 1.0;\n  for (int i = 0; i < MAXSTEPS; i++) {\n    float t = 1e8;\n    int hitsphere = -1;\n    for (int j = 0; j < NSPHERES; j++) {\n      if (j == lastsphere) continue;\n      float t1 = intersectsphere(p,r,spheres[j]);\n      if (t1 > 0.0 && t1 < t) {\n        t = t1;\n        hitsphere = j;\n      }\n    }\n    if (hitsphere == -1) return att*skycolor(r);\n    lastsphere = hitsphere;\n    p += t*r;\n    att *= attenuation;\n    r = reflect(r,normalize(p-spheres[hitsphere].xyz)); // Normal is just direction from sphere centre\n  }\n  return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  for (int i = 0; i < NSPHERES; i++) {\n    spheres[i].xyz = transform(spheres[i].xyz);\n    if (key(CHAR_V)) spheres[i].w *= 1.0 + 0.35*sin(0.5*iTime);\n    else if (key(CHAR_H)) spheres[i].w = 1.25;\n  }\n  float camera = key(CHAR_H) ? 0.0 : 1.0;\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  attenuation *= exp(0.05*float(keycount(KEY_RIGHT)-keycount(KEY_LEFT)-2));    \n  vec3 p = vec3(0,0,camera);\n  //p = transform(p);\n  vec3 col = vec3(0);\n  float AA = 2.0;\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 r = vec3(uv,-2);\n      //r = transform(r);\n      r = normalize(r);\n      col += raycolor(p,r);\n    }\n  }\n  col /= AA*AA;\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n  if (check) fragColor = vec4(1,0,0,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }     \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float PI = 3.14159;\nbool check = false;\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvoid assert(bool b) { if (!b) check = true; }\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_H = 72;\nconst int CHAR_J = 74;\nconst int CHAR_L = 76;\nconst int CHAR_P = 80;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}