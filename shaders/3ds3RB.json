{
    "Shader": {
        "info": {
            "date": "1546769613",
            "description": "Trying to see how short a tetris game could be (not bullet-proof, no end).\nKeys:   left/right : move, up/down: rotate\nspeed: change delay line bfA:27.\n\nNB: Piece collision is based on MIPmap which is bugged on Windows Angle, so it might not work for you.\n",
            "flags": 48,
            "hasliked": 0,
            "id": "3ds3RB",
            "likes": 9,
            "name": "Short tetris (947 chars) ",
            "published": 3,
            "tags": [
                "short",
                "tetris",
                "tetrix"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 774
        },
        "renderpass": [
            {
                "code": "// display grid bg (O.b) + old pieces (O.g) + currently falling piece (O.r, type T(C).a)\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = u * 20./R.y;\n     ( U.x += 5. - 10.*R.x/R.y ) > 0. ?\n        O = T(U),\n        v = O.g + O.r * T(C).a,\n        v > 0. ? O = .6 + .6 * cos( .8*v  + vec4(0,23,21,0) ) :O:O; }",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define K(a)    texelFetch( iChannel3, ivec2(a,1), 0 ).x       // keyDown\n#define N       fract( 1e4* sin( U.x+17.7*U.y - 99.*iTime ) )  // random value\n//int S[] = int[]( 0x0f, 0x66, 0x36, 0x63, 0x17, 0x71, 0x27 ); // tetris pieces\nvec4 P;             // cur element P = ( pos, angle, id ).\n\n                    // --- get current piece of element (P) at pixel U+d\n#define D(d) \\\n    ( V = (d+U-P.xy) * mat2( cos( P.z*1.57 + vec4(0,33,11,0)) ),          \\\n      abs(V.x) < 2. && abs(V.y) < 1.                                      \\\n      && ( int[]( 0x0f, 0x66, 0x36, 0x63, 0x17, 0x71, 0x27 ) [int(P.a)-1] \\\n           >> int(2.+V.x)+4*int(1.+V.y)  & 1 ) > 0                        \\\n      ? 1.: 0. )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    P = T(C);                                 // cur piece state\n    bool e = P.y < -2. ||                     // piece stopped ?\n             texelFetch(iChannel0,ivec2(0),5).a > 0.; // collision detection         // piece stop\n    int  x, t = iFrame;\n    O = T(U);                                 // prev pixel state\n    \n    U == C ?                                  // --- commands\n        O.x += K(39) - K(37),                 // go left/right\n        O.z += K(40) - K(38),                 // rotate\n        e ? O.y = 20., O.x = 1.+ceil(8.*N),   // make new piece\n            U++, O.a = ceil(7.*N)               \n          : t%12 == 0 ? O.y-- : v             // fall \n        : v;\n\n    if (U.x<10.)                              // --- terrain\n    {   \n        for (v=0.; v < U.y; v++) {            // --- search full lines\n            for ( x=0; T(vec2(x,v)).g > 0.; x++ );\n            x==10 ? O = T(U+h) : O;           // full: erase line & offset all above\n          }\n        // O.r: cur falling piece. O.g: frozen pieces O.a: collision detection\n        e && O.r > 0.                         // --- draw piece\n           ? O.g = P.a , O.r = 0.: v;         // stop: freeze piece                           \n        !e ? O.a = D(h) *O.g,                 // else: test collisions\n             O.a += D(-h*floor(U.y)),         //          + bottom\n             O.r = D() : v;                   //       & trace\n         e ? O.a = 0. : v;          // strange: had to be added in 08/2021\n    } \n    \n    t < 1 ?                                   // --- init  \n            U.x < 10. ? O.b = .5*N : v,       // background blue  \n            U == C ? O = vec4(4,19,0,1) : O   // make piece x,y,ang,id\n          : O;\n                                              // --- debug section :\n // for( x=1; x<8; x++) P = vec4(17,22-3*x,0,x), D()>0. ? O.g = float(x) : 0.;    \n // U==vec2(16.5) ? O.r = 1.: v;\n // U==vec2(17.5) ? O.g = P.a,O.r=0.: v;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2     C = vec2(99.5),       // current piece state.\n      V, h = vec2(0,1);\nfloat v;\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )   /*\n\n\n\n\n\n// could golf more, but won't for readability:\n\n//  -2: (float) ,Z=0.\n//  -3: #def D  float( abs(V=...).x\n// -14: transform mainImage into #define\n\n\n// could golf more, won't for features:\n\n//  -9: dealing with escaped pieces trough sides: P.y < -2. ||\n//  -1: keep precise centering: -10.*R.x/R.y\n// -16-3: keep (dark) background  : .5*N\n//  -3: keep colors, and well separated color pieces cos(.8*v\n\n/**/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}