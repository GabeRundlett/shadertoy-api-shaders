{
    "Shader": {
        "info": {
            "date": "1499736323",
            "description": "gradient descent on color similarity objective w.r.t. fragment color and neighbor positions, regularized by local blur\n\nfullscreen me!",
            "flags": 32,
            "hasliked": 0,
            "id": "MsByRc",
            "likes": 16,
            "name": "rainbow descent",
            "published": 3,
            "tags": [
                "gradient",
                "feedback",
                "cellular",
                "deterministic"
            ],
            "usePreview": 0,
            "username": "victor_shepardson",
            "viewed": 900
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 d = 1./iResolution.xy;\n\tvec2 uv = fragCoord.xy * d;\n    \n    /*if(uv.x > uv.y){\n        vec4 c = texture(iChannel1, uv).rgba;\n\t\tfragColor = 0.5+sign(c)*log(1.+abs(c))/log(1.+iResolution.xyxy);\n                        }\n    else*/\n    fragColor = texture(iChannel0, uv);\n    fragColor /= 1.+abs(fragColor);\n    fragColor = fragColor*0.5+0.5;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// LICENSE:\n// Creative Commons Attribution 4.0 International License.\n// https://creativecommons.org/licenses/by/4.0/\n\n// fragment colors\n\nconst float lambda_c = 1e-2;//0.;//5e-2;//2e-1;\nconst float lambda_b = 0.5;//8e-1;\nconst float alpha = 0.25;\nconst float pi = 3.141592;\n\nfloat gamma(vec3 x){\n    float y = 1.+dot(x, x);\n    return -1./(y*y);\n}\n\nvec3 term(vec3 x){\n    return x*gamma(x);\n}\n\nvec3 conv(vec2 uv){\n    vec3 d = vec3(1./iResolution.xy, 0.);\n    return 0.25*(\n        texture(iChannel0, fract(uv+d.xz))\n        + texture(iChannel0, fract(uv-d.xz))\n        + texture(iChannel0, fract(uv+d.zy)) \n        + texture(iChannel0, fract(uv-d.zy))\n\t).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 d = vec3(1./iResolution.xy, 0.);\n    vec2 uv = fragCoord.xy * d.xy;\n    \n    vec4 r = texture(iChannel1, uv);\n    vec2 r1 = r.xy;\n    vec2 r2 = r.zw;\n    vec3 c0 = texture(iChannel0, uv).rgb;\n    vec3 c1 = texture(iChannel0, fract(uv+r1*d.xy)).rgb;\n    vec3 c2 = texture(iChannel0, fract(uv+r2*d.xy)).rgb;\n    \n    vec3 dJdc = -term(c0-c1) + term(c0-c2) + lambda_c*c0;\n    \n    dJdc -= lambda_b*(conv(uv)-c0);\n    //dJdc -= term(c0 - conv(uv));\n    \n    fragColor = vec4(c0 - alpha*dJdc, 1.);\n    \n    if(iFrame<2){ //initial condition\n        fragColor = vec4(sin(pi*2.*(uv.xxy+vec3(0.,0.5,0.75))).gbr, 0.);\n    \t//fragColor = vec4(sin(pi*2.*vec3(1.,6.,7.)*(uv.yxx+vec3(0.,0.,0.25))).gbr, 0.);\n        //fragColor = texture(iChannel2, uv)*2.-1.;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Displacements to neighbors\n\nconst float lambda_r = 0.;//1e-3;\nconst float lambda_b = 0.5;//8e-1;\nconst float alpha = 1.;//0.5;\nconst float knee = 0.5;\nconst float pi = 3.141592;\n\nmat3x2 grad(vec2 uv){\n    vec3 d = vec3(1./iResolution.xy, 0.);\n    return mat3x2(\n        texture(iChannel0, fract(uv+d.xz))\n        - texture(iChannel0, fract(uv-d.xz)),\n        texture(iChannel0, fract(uv+d.zy)) \n        - texture(iChannel0, fract(uv-d.zy))\n\t);\n}\n\nvec4 conv(vec2 uv){\n    vec3 d = vec3(1./iResolution.xy, 0.);\n    return 0.25*(\n        texture(iChannel1, fract(uv+d.xz))\n        + texture(iChannel1, fract(uv-d.xz))\n        + texture(iChannel1, fract(uv+d.zy)) \n        + texture(iChannel1, fract(uv-d.zy))\n\t);\n}\n\nfloat gamma(vec3 x){\n    float y = 1.+dot(x, x);\n    return -1./(y*y);\n}\nfloat gamma(vec4 x){\n    float y = 1.+dot(x, x);\n    return -1./(y*y);\n}\n\nvec3 term(vec3 x){\n    return x*gamma(x);\n}\nvec4 term(vec4 x){\n    return x*gamma(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 d = vec3(1./iResolution.xy, 0.);\n    vec2 uv = fragCoord.xy * d.xy;\n    \n    vec4 r = texture(iChannel1, uv);\n    vec2 r1 = r.xy;\n    vec2 r2 = r.zw;\n    vec3 c0 = texture(iChannel0, uv).rgb;\n    vec3 c1 = texture(iChannel0, fract(uv+r1*d.xy)).rgb;\n    vec3 c2 = texture(iChannel0, fract(uv+r2*d.xy)).rgb;\n    mat3x2 dc1dr1 = grad(uv+r1*d.xy);//mat3x2(dFdx(c1), dFdy(c1));\n    mat3x2 dc2dr2 = grad(uv+r2*d.xy);//mat3x2(dFdx(c2), dFdy(c2));\n    \n    vec3 delta_10 = c1-c0;\n    vec3 delta_12 = c1-c2;\n    vec3 delta_20 = c2-c0;\n    vec3 delta_21 = -delta_12;\n    \n    vec3 dJdc1 = term(c1-c0) - term(c1-c2);\n    vec3 dJdc2 = -term(c2-c0) + term(c2-c1);\n    \n    vec2 dJdr1 = dc1dr1 * dJdc1;\n    vec2 dJdr2 = dc2dr2 * dJdc2;\n    \n    //dJdr1 = normalize(dJdr1);\n    //dJdr2 = normalize(dJdr2);\n    dJdr1 /= length(dJdr1) + knee;\n    dJdr2 /= length(dJdr2) + knee;\n    \n    vec4 dJdr = vec4(dJdr1, dJdr2) ;\n        \n    dJdr += lambda_r*dJdr;\n    dJdr -= lambda_b*(conv(uv)-r);\n    //dJdr -= term(r - conv(uv));\n\n    \n    fragColor = r - alpha*dJdr;\n    //fragColor = (fract(fragColor*d.xyxy+0.5)-0.5)*iResolution.xyxy;\n    \n    if(iFrame<2){ //initial condition\n        //fragColor = (iResolution*0.5-1.).xyxy*vec4(1., 1., 1., -1.);\n        fragColor = (iResolution*0.125).xyxy*vec4(1., 0., 0., -1.);\n        //vec2 m = pow(vec2(2.), 4.*sin(pi*2.*(uv.y+vec2(0.5,0.75))));\n    \t//fragColor = m.xxyy*iResolution.xyxy*0.03125*sin(2.*pi*(uv.x+vec2(0.5,0.25))).xyyx*vec4(1.,1.,1.,-1.);\n        //fragColor = iResolution.xyxy*0.0625*(2.+sin(pi*2.*(uv.x+vec4(0.,0.25,0.5,0.75))))*vec4(1., 1., 1., -1.);\n    \t//fragColor = 32.*vec4(1., 1., 1., -1.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}