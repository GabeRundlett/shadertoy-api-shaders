{
    "Shader": {
        "info": {
            "date": "1692598879",
            "description": "Ray march warped (by gravity) as it passes the singularity. Drag mouse to change view.",
            "flags": 0,
            "hasliked": 0,
            "id": "dtXfzH",
            "likes": 11,
            "name": "Bent Ray March Black Hole",
            "published": 3,
            "tags": [
                "raymarch"
            ],
            "usePreview": 0,
            "username": "Blindman67",
            "viewed": 385
        },
        "renderpass": [
            {
                "code": "#define CAMERA_DIST 20.0\n#define SINGULARITY_RADIUS 1.0\n#define MASS 0.1  \n#define DISK_RADIUS 10.0 \n#define MAX_STEPS 105\n#define MAX_DIST ((DISK_RADIUS + CAMERA_DIST) * 1.4)\n#define MIN_DIST 0.01\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\n#define RAY_SRC_DISK 1u\n#define RAY_SRC_HORIZON 2u\n#define RAY_SRC_SPACE 3u\nuint raySrc = 0u;\n\nfloat rayDistance = 0.0;\n\nRay camera = Ray(vec3(0), vec3(0));\nRay plane = Ray(vec3(0, 0, 0), vec3(0,-1,0));\nvec3 srcPos;\nfloat Plane(vec3 origin, vec3 dir, Ray plane){\n    float d = dot(plane.dir, dir);\n    return abs(d) > 0.0001 ? dot(plane.origin - origin, plane.dir) / d : MAX_DIST;\n}\nfloat GetDist(vec3 origin, vec3 dir) {\n    float pDist = Plane(origin, dir, plane);\n    rayDistance = length(origin);\n    float hDist = rayDistance - SINGULARITY_RADIUS;\n    if (pDist < hDist) {\n        float dDist = length(origin + dir * pDist);\n        if (dDist < DISK_RADIUS) {\n            raySrc = RAY_SRC_DISK;\n            return pDist;\n        }\n    } \n    raySrc = RAY_SRC_HORIZON;\n    return hDist;\n}\nfloat Temp(float dist) { return pow(e, -pow(((PI * (dist - 0.5)) / (dist - 0.1)), 2.0)); }\nvec4 GetSpace() { return vec4(0.0, 0.01, 0.02, 1); }\nvec4 GetDisk(vec3 pos) {\n   float dir = atan(pos.x, pos.z) + PI + TAU; \n   float dist = (length(pos) - SINGULARITY_RADIUS) / (DISK_RADIUS - SINGULARITY_RADIUS);\n   if (dist > 1.0) { return GetSpace(); }\n   vec3 n = Noise2D(vec2(sin(dir + iTime * (1.0 - dist)), dist*10.0));\n   float temp = (Temp(dist + 0.35)- 0.01) * (1.0 - (n.x + n.y));\n   float idx = temp * 38.0;\n   uint i1 = uint(idx);\n   uint i2 = i1 + 1u;\n   vec3 c1 = Uint2RGB(BLACK_BODY[i1]);\n   vec3 c2 = Uint2RGB(BLACK_BODY[i2]);\n   float f = fract(idx);\n   vec3 c = ((c2 - c1) * f + c1) * (1.0 + temp* 2.0);\n   return vec4(c, temp);\n}\nvec4 March(Ray camera) {\n\tfloat dist = 0.0; \n    float stepDist;\n    vec3 pos = camera.origin;\n    int i;\n    for(i = 0; i < MAX_STEPS; i++){\n        stepDist = GetDist(pos, camera.dir);\n        camera.dir = normalize(camera.dir - normalize(pos) * (MASS / (rayDistance * rayDistance)));\n        pos += camera.dir * stepDist;\n        dist += stepDist;\n        if (dist > MAX_DIST || dist < MIN_DIST) { break; }\n    }\n    if (dist > MAX_DIST) { raySrc = RAY_SRC_SPACE; }\n    srcPos = pos;\n    if (raySrc == RAY_SRC_DISK) { return GetDisk(srcPos); }\n    if (raySrc == RAY_SRC_HORIZON) { return vec4(0); } \n    return GetSpace();    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 look = iMouse.x <= 1.0 && iMouse.y <= 1.0 ? iResolution.xy * vec2(0.5, 0.45) : iMouse.xy;\n    mat3 vmat = lookMouse(look / iResolution.xy);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    camera.origin =  - vmat[2] * 20.0;\n    camera.dir = normalize(vmat * vec3(uv, 2.0));\n    \n    fragColor = vec4(pow(March(camera).xyz, vec3(1)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI = 3.14159;\nconst float e = 2.71828182846;\n\nconst float TAU = PI * 2.0;\nconst float INV_255 = 1.0 / 255.0;\nconst uint BLACK_BODY[38] = uint[](0u,  // high 8 bits are alph, then red, green, and blue\n    0x44270800u, 0x884e1001u, 0xAA751802u, 0xCC9c2103u, 0xEEc42903u, 0xFFeb3104u, 0xFFff3605u, 0xFFff6200u, \n    0xFFff7c00u, 0xFFff8f1du, 0xFFffa042u, 0xFFffb05eu, 0xFFffbc76u, 0xFFffc78bu, 0xFFffd09fu, 0xFFffd8b1u, \n    0xFFffe0c0u, 0xFFffe7d0u, 0xFFffeddeu, 0xFFfff1eau, 0xFFfff6f5u, 0xFFfff9feu, 0xFFf7f5ffu, 0xFFeff0ffu, \n    0xFFe8ecffu, 0xFFe2e9ffu, 0xFFdce5ffu, 0xFFd7e2ffu, 0xFFd3dfffu, 0xFFcfddffu, 0xFFcbdbffu, 0xFFc8d9ffu, \n    0xFFc5d7ffu, 0xFFc3d5ffu, 0xFFc0d4ffu, 0xFFbed2ffu, 0xFFbbd1ffu\n);\nvec3 Uint2RGB(uint col) {\n    return vec3(\n        float((col >> 16u) & 0xFFu) * INV_255,\n        float((col >> 8u) & 0xFFu) * INV_255,\n        float(col & 0xFFu) * INV_255\n    );\n}\nvec4 Uint2RGBA(uint col) {\n    return vec4(\n        float((col >> 16u) & 0xFFu) * INV_255,\n        float((col >> 8u) & 0xFFu) * INV_255,\n        float(col & 0xFFu) * INV_255,\n        float(col >> 24u) * INV_255\n    );\n}\nmat3 camMatrix(in float yaw, in float pitch) {\n    vec3 forward = normalize(vec3(sin(yaw), sin(pitch), cos(yaw)) * cos(pitch));\n    vec3 right = normalize(cross(vec3(0, 1, 0), forward));   \n    return mat3(right, cross(forward, right), forward);\n}\n\nmat3 lookMouse(in vec2 unitMouse) {\n    return camMatrix((unitMouse.x * 1.2 - 0.1) * PI, (unitMouse.y + 0.5) * PI);\n}\n\nfloat Hash(vec2 pos) {\n    pos = fract(pos * 13.654678) * 65.247743;\n    float f = fract((pos.x + pos.y) * pos.x * pos.y);\n    return f * f;\n}\nvec3 Noise2D(vec2 pos) {  /* returns vec3 where 2D noise is return.xy  */\n    vec2 fPos = floor(pos);\n    float a = Hash(fPos);\n    float b = Hash(fPos + vec2(1, 0));\n    float c = Hash(fPos + vec2(0, 1));\n    float d = Hash(fPos + vec2(1, 1));\n    vec2 f = fract(pos);\n    vec2 u = f * f * (3.0 - 2.0 * f), u1 = 1.0 - u;\n    float ca = c - a;\n    float ba = b - a;\n    return vec3(\n        6.0 * u * u1 * (vec2(ba, ca) + u.yx * (a - b - c + d)),\n        a + ba * u.x * u1.y + ca * u1.x * u.y + (d - a) * u.x * u.y        \n    );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}