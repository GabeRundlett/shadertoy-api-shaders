{
    "Shader": {
        "info": {
            "date": "1593877944",
            "description": "Computes closest positive ray-box intersection, if exist.\nComment line 23 for just that. Default = BBox mode: d = 0 inside.\nClick + drag mouse to chose a ray start + dir.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "wtjyRW",
            "likes": 9,
            "name": "box nearest intersection",
            "published": 3,
            "tags": [
                "raytracing",
                "intersection",
                "mm",
                "bbox"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 466
        },
        "renderpass": [
            {
                "code": "const float r0 = .3, r1 = .5 /* , r2 */;\nconst vec2  P = vec2(1.1,.3),                        // bounding box at P, axis X0,X1\n      A = cos( -.5 + vec2(0,1.57) ),                 // ex: defined by angle -> frame <A,Aortho> \n     X0 = r0*A, X1 = r1*vec2(-A.y,A.x) /* , X2 */;   // axis X0,X1\n\n#define S(d) smoothstep( 1.5/R.y, 0., d )     // --- draw antialiased\nfloat line(vec2 p, vec2 a,vec2 b) {           // --- segment with disc ends: seamless distance to segment\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n}\n\n#define spot(P)  S( length( P - U ) -.01 )            // draw dot\n\n// --- v2. maybe a bit cheaper\nfloat intersect(vec2 C, vec2 D) {                     // --- camera, direction. Return closest hit or -1\n    // you probably want to precompute these 2 : \n    vec2  L = vec2(length(X0), length(X1) /* , length(X2) */ ), I; // box radii \n    mat2  F = mat2( X0/dot(X0,X0), X1/dot(X1,X1) /* , X2/dot(X2,X2) */ );   // orthogonal normalized box frame\n    float d = 1e5, l;\n    \n    C = (C-P) * F;    D *= F;                         // to normalized coordinates in box frame\n    I = abs(C-.5); if ( /*max(I.z,*/ max(I.x,I.y) <=.5 ) return 0.; // if inside the Bbox. Comment for box intersection\n    // C+lD = 0|1 -> l = ( 0|1 - C ) / D    We want smallest positive l\n\n#define test(i)                                                                \\\n    /* first, get the nearest positive per direction */                        \\\n    l =  D[i] > 0. ?  C[i] < 0. ? -C[i]   : C[i] < 1. ? 1.-C[i] : -1.          \\\n                   :  C[i] > 1. ? 1.-C[i] : C[i] > 0. ? -C[i]   :  1.;         \\\n    l /= D[i];                                                                 \\\n    /* second, takes the min l>0 such that C+lD fits is inside the box */      \\\n    I = (C+l*D)*L;                                                             \\\n    if ( l > 0. &&  l < d                                                      \\\n         && I[(i+1)%2] >= 0. && I[(i+1)%2] <= L[(i+1)%2]                       \\\n                /*  ^     3 in 3D       ^             ^     */                 \\\n      /* && I[(i+2)%3] >= 0. && I[(i+2)%3] <= L[(i+2)%3] */                    \\\n       ) d = l\n        \n    test(0); // test in each directions\n    test(1);\n /* test(2); */\n    return d==1e5 ? -1. : d;\n}\n\n/* // --- first version ( costlier ? )\nfloat intersect(vec2 C, vec2 D) {                     // --- camera, direction. Return closest hit or -1\n    // you probably want to precompute these 2 : \n    vec2  L = vec2(length(X0), length(X1) /* , length(X2) * / ), I; // box radii \n    mat2  F = mat2( X0/L.x, X1/L.y /* , X2/L.z * / ); // orthogonal unitary box frame\n    float d = 1e5, l;\n    \n    C = (C-P) * F;    D *= F;                         // to box frame\n    // C+lD = 0|L -> l = ( 0|L - C ) / D    We want smallest positive l\n\n#define test(i)                                                                \\\n    /* first, get the nearest positive per direction * /                        \\\n    l =  D[i] > 0. ?  C[i] < 0.   ? -C[i]     : C[i] < L[i] ? L[i]-C[i] : -1.  \\\n                   :  C[i] > L[i] ? L[i]-C[i] : C[i] > 0.   ? -C[i]     :  1.; \\\n    l /= D[i];                                                                 \\\n    /* second, takes the min l>0 such that C+lD fits is inside the box * /      \\\n    I = C+l*D;                                                                 \\\n    if ( l > 0. &&  l < d                                                      \\\n         && I[(i+1)%2] >= 0. && I[(i+1)%2] <= L[(i+1)%2]                       \\\n                /*  ^     3 in 3D       ^             ^    * /                  \\\n      /* && I[(i+2)%3] >= 0. && I[(i+2)%3] <= L[(i+2)%3] * /                    \\\n       ) d = l\n        \n    test(0); // test in each directions\n    test(1);\n /* test(2); * /\n    return d==1e5 ? -1. : d;\n}\n*/\n    \nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = u/R.y,\n         M1 = iMouse.xy/R.y,\n         M0 = iMouse.zw/R.y, C = M0,\n          D = normalize(M1-M0);\n    if (M1==vec2(0)) M1 = vec2(.4);\n    if (M0.x<=0.) C = M1, D = cos(iTime+vec2(0,11)), M1=M0+.2*D;     \n    O-=O;\n    O += S( min ( min ( line(U,P,P+X0),  line(U,P+X0,P+X0+X1) ), // draw box\n                  min ( line(U,P+X1,P),  line(U,P+X0+X1,P+X1) ) \n          )     );\n\n    if (D == vec2(0)) return;   \n    O.r += spot(C);\n    O.r += S( line(U, C, C+D ) );              // draw cam\n    \n    float d = intersect( C, D );               // shortest distance or -1.\n    if (d<0.) return;\n    \n    O.g += spot( C + d*D );                    // draw hit point ( if exist )\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}