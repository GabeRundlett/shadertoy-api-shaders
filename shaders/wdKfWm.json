{
    "Shader": {
        "info": {
            "date": "1624970877",
            "description": "dilation method for isoline interpolate",
            "flags": 32,
            "hasliked": 0,
            "id": "wdKfWm",
            "likes": 0,
            "name": "test about face isoline",
            "published": 3,
            "tags": [
                "isolineinterpolate"
            ],
            "usePreview": 0,
            "username": "firegump",
            "viewed": 501
        },
        "renderpass": [
            {
                "code": "//#define AA\n\nvec3 AAfilter(vec2 uv)\n{\n    vec3 col = vec3(0.,0.,0.);\n    for(int i = -1;i<2;i++)\n    {\n        for(int j = - 1; j<2 ;j++)\n        {\n            vec2 ouv = uv + vec2(i,j)/512.;\n            col += texture(iChannel2, ouv).xyz;\n        \n        }\n    \n    }\n    return col/9.0;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 c = texture(iChannel3,uv).xyz;\n#ifdef AA\n    c = AAfilter(uv);\n#endif\n\n    //animation\n    float sm =(sin(iTime)+1.)*.5;\n    //c = smoothstep(sm,sm+0.02,c); \n    \n\n    fragColor =fragColor = vec4(c, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define G true\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \t\n\n\n\t//base\n\n\tfloat c = uv.x;\n    \n    c = floor(c*4.)/4.;\n    \n    \n\n    \n    c = c+ step(uv.x,0.1) + step(0.9,uv.x);\n\n    c = min(c,1.);\n\n    //face simulate\n    \n   \tvec2 suv = 2.*(uv -0.5);\n    \n    suv.x = pow(abs(suv.x),1.1/(2.-abs(suv.y))) *sign(suv.x);\n    \n    suv = 0.5*(suv + 1.);\n    \n    float d = floor(suv.x*8.)/8.;\n\t\n    // cycle image\n    \n    float e = length(uv-0.5)*2.;\n    \n    e = floor(e*7.)/7.;\n\t//black outline\n   \tvec2 ouv = uv;\n    ouv = (ouv-0.5)*2.;\n    ouv = abs(ouv);\n    \n    float outlineS = 0.95;\n    float outline = step(ouv.x,outlineS)*step(ouv.y,outlineS);\n    \n    \n    // face----------------------------------------------------------------------------\n\tvec3 col = vec3(0.);\n    \n    float offy = \n    \n    uv.y *= 1.05;\n    uv.y -= 0.025;\n    uv.x *= 1.2;\n    uv.x -= 0.1;\n    \n    float xO = abs(uv.y - 0.5);// y =0.5 0 0.5\n    xO *= 2.;// y = 1 0 1;\n    \n   \n    xO = pow(xO,20.);//near the top bottom, lines can be closer\n   \n    uv.x = (uv.x*2.-1.);\n    float s = uv.x/abs(uv.x);\n    \n    uv.x = abs(uv.x) + xO;\n    \n    \n    uv.x *= s;\n    \n    uv.x = uv.x*0.5 + 0.5;\n    \n    \n    \n    \n    float f= floor(uv.x*13.5)/13.5;\n        \n        \n    c = f*outline;\n    \n    c = min(1.,c);\n    //face2-------------------------------------------------------------------------------\n    vec2 uvface2 = fragCoord/iResolution.xy;\n    \n    float offsetx = pow((1.-abs(uvface2.y -0.5)*2.),4.);\n    offsetx = mix(offsetx, 0., pow(2.*abs(uvface2.x-0.5),0.05)  );\n    uvface2.x += offsetx*0.2;\n    \n    float b = uvface2.y;\n    \n    b = pow(b , .4);\n    b = smoothstep(0.,1.,b);\n    \n    \n    float a = uvface2.x*2.-1.;\n    a = (pow(abs(a)/b ,2.) * sign(a))*.5 + .5;\n   \n    \n    float finalCol = a;\n    \n    \n    if(G){ \n    //Gradient line\n    float GVal = 8.;\n    finalCol = ceil(finalCol*GVal)/(GVal);}\n    \n    //cycle\n    vec2 cuv = uvface2;\n    \n    \n    float cycleSample = length(cuv - vec2(0.40,0.5));\n    float cycle = step(cycleSample,0.07);\n    \n    float cmodify = floor((1.-cycleSample)*40.)/40.;\n    \n    c = mix(finalCol ,finalCol+(cmodify-0.89)*14./8.,cycle);\n    //+(cmodify-0.89)*14./8.\n    \n    //c = cycle;\n    //c = offsetx;\n    c = min(1.,c);\n    fragColor = vec4(vec3(c,c,c),1.0);\n    \n    \n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define MaxSteps 512.\n#define TextureSize 512.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \t\n\n\n    \n    \n    //sdf\n    float threshold = 0.0;\n    float Sample = texture(iChannel0,uv).x;\n    \n\t\n    float texelsize = 1. / TextureSize;\n\tfloat mindist = 10000000.;\n    float MaxS = 0.;\n\tfloat MinS = 0.;\n    //vec2 offsets[16] = vec2[](vec2(1.0,0.0),vec2(0.92388,0.382683),vec2(0.707107,0.707107),vec2(0.382683,0.92388),vec2(-0.0,1.0),vec2(-0.382683,0.92388),vec2(-0.707107,0.707107),vec2(-0.923879,0.382684),vec2(-1.0,0.0),vec2(-0.92388,-0.382683),vec2(-0.707107,-0.707107),vec2(-0.382684,-0.923879),vec2(-0.0,-1.0),vec2(0.382683,-0.92388),vec2(0.707107,-0.707107),vec2(0.923879,-0.382684));\n    vec2 offsets[8] = vec2[](vec2(-1,0), vec2(1,0), vec2(0,1), vec2(0,-1), vec2(-1,1), vec2(1,1), vec2(1,-1), vec2(-1,-1));\n   \tbool findMax = false;\n    float distMax = 0.;\n\tbool findMin = false;\n    float distMin = 0.;\n\tfloat c = 0.;\n    float k = 0.;\n    bool ifTop = false;\n    \n\n    \n    float cull = 0.3;\n    \n    if(abs(Sample-0.5) <  cull+200.){//cull two side\n    \t\n\t\t\n    \tfloat i = 0.;\n\t    while(i<MaxSteps)\n\t\t{\n           if(findMax&&findMin) break;//if find both the maximum and the minimum,if only find one, keep going\n           i++;\n            float j = 0.;\n            while(j<8.)\n            {\n                \n            \tvec2 cuv = uv + normalize(offsets[int(j)]) * texelsize * i;\n                if(cuv.x<0.||cuv.x>1.||cuv.y<0.||cuv.y>1.) break;//if out the uv break loop\n                \n                \n                \n                float offsetSample = texture(iChannel0,cuv).x;\n                \n                if(Sample - offsetSample > threshold && !findMin)\n                {\n                \tMinS = offsetSample;\n                \tfindMin = true;\n                    distMin =  texelsize * i;\n                    break;\n                }\n\t\t\t\telse if(Sample - offsetSample < threshold && !findMax)\n                {\n                \tMaxS = offsetSample;\n                    findMax = true;\n                    distMax =  texelsize * i;\n                    break;\n                }\n\n                \n             \n\t\t\t\n                j++;\n            }//inside loop\n        \n        \n        }//out loop\n    \n    //calculate result\n    k = distMin/(distMax + distMin);\n    //k = ifTop?1.- k:k;\n    \n    k = pow(k,1.);\n  \n    \t\n     c = Sample*k + MinS*(1.-k);\n    \t\n    \n    \n    //modify result to 0 -1\n    \n    c = abs(c - 0.5)*(0.5/cull)*sign(c - 0.5) +0.5;\n    \t\n     //c = distMax;\n    \n  }//endif\n\n   \n\t//c = k;\n   \t//comparison\n    float t = (sin(iTime)+1.)*.5;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    t = 0. + m.y;\n\tc = mix(c,Sample,step(uv.y,t));   \n    \n    //debug line\n    float d = uv.x;\n    \n    d = step(0.001,fract(d*4.)/4.);\n    \n     \n    \n     \n   \t //c= MinS;\n\t//c = Sample;\n    vec3 color = vec3(c,c,c);\n    //vec3 color = mix(vec3(1,0,0),vec3(c,c,c), d);\n    \n    \n    \n\n    fragColor =fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define AA\nvec3 AAfilter(vec2 uv)\n{\n    vec3 col = vec3(0.,0.,0.);\n    for(int i = -1;i<2;i++)\n    {\n        for(int j = - 1; j<2 ;j++)\n        {\n            vec2 ouv = uv + vec2(i,j)/512.;\n            col += texture(iChannel1, ouv).xyz;\n        \n        }\n    \n    }\n    return col/9.0;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\n   vec3 c = texture(iChannel1,uv).xyz;\n#ifdef AA\n    c = AAfilter(uv);\n#endif\n\n\n    \n\n    fragColor =fragColor = vec4(c, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define threshold 0.4\nvec3 correctionFilter(vec2 uv)\n{\n    float c = 0.;\n    float current = 0.;\n    for(int i = -1;i<2;i++)\n    {\n        for(int j = - 1; j<2 ;j++)\n        {\n            if(i == 0 && j == 0)\n            {\n            \n                current = texture(iChannel1, uv).x;\n            }\n            vec2 ouv = uv + vec2(i,j)/512.;\n            c += texture(iChannel1, ouv).x;\n        \n        }\n    \n    }\n    \n    if( abs(current - (c/8.0))> threshold)\n    {\n        c = c/8.0;\n    }\n    else\n    {\n        c = current;\n    }\n    vec3 col = vec3(c,c,c);\n    return  col;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 c = texture(iChannel1,uv).xyz;\n    \n    c = correctionFilter(uv);\n    \n\n    fragColor =fragColor = vec4(c, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}