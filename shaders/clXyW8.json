{
    "Shader": {
        "info": {
            "date": "1690646857",
            "description": "Analytic box occlusion with clipping optimized using less acos / conditions. It's based on the cube's perimeter instead of the individual faces' perimeter.\nFork of : https://www.shadertoy.com/view/4djXDy",
            "flags": 0,
            "hasliked": 0,
            "id": "clXyW8",
            "likes": 0,
            "name": "Box - occlusion clipping optimiz",
            "published": 3,
            "tags": [
                "3d",
                "occlusion",
                "analytic"
            ],
            "usePreview": 0,
            "username": "clem494949",
            "viewed": 73
        },
        "renderpass": [
            {
                "code": "// Forked from https://www.shadertoy.com/view/4sSXDV\n\n// MIT License\n\n// Analytic box occlusion with clipping optimized using less acos / conditions. \n// It's based on the cube's perimeter instead of the individual faces' perimeter.\n\n//=====================================================\n\nfloat sacos( float x ) { return acos( min(max(x,-1.0),1.0) ); }\n\nvec3 clip( in vec3 a, in vec3 b, in vec4 p )\n{\n    return a - (b-a)*(p.w + dot(p.xyz,a))/dot(p.xyz,(b-a));\n    //return ( a*dot(p.xyz,b) - b*dot(p.xyz,a)  - (b-a)*p.w ) / dot(p.xyz,(b-a));\n}\n\nfloat fedgeOcclusion(in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1)\n{\n    vec3 nv0 = normalize(v0 - pos);\n    vec3 nv1 = normalize(v1 - pos);\n    return dot(nor, normalize(cross(nv0,nv1))) * sacos(dot(nv0,nv1)) / 6.283185;\n}\n\nfloat edgeOcclusion(in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, inout vec3 c0, inout vec3 c1, in vec4 plane)\n{\n    float s0 = dot(vec4(v0,1.0), plane);\n    float s1 = dot(vec4(v1,1.0), plane);\n    float sn = sign(s0) + sign(s1);\n\n    vec3 c = clip( v0, v1, plane );\n    \n    float occ = 0.0;\n    // All vertices above horizon\n    if(sn>1.0) \n    {\n        occ += fedgeOcclusion(pos, nor, v0, v1);\n    }\n    // 1 vertex above horizon\n    else if(sn>-1.0) \n    {\n        vec3 pa, pb;\n        if(s0 > 0.0 )        { pa = v0; pb = c;  }\n        else/*if( s1>0.0 )*/ { pa = c;  pb = v1; }\n        occ += fedgeOcclusion(pos, nor, pa, pb);\n        \n        // Save the intersection\n        if(dot(c0, c0) != 0.0) { c1 = c; } \n        else { c0 = c; }\n    }\n    // zero (no) vertices above horizon\n    return occ;\n}\n\nfloat boxOcclusion( in vec3 pos, in vec3 nor, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n\tvec3 p = (txx*vec4(pos,1.0)).xyz;\n\tvec3 n = (txx*vec4(nor,0.0)).xyz;\n    vec4 w = vec4( n, -dot(n,p) ); // clipping plane\n    \n    // Orient the hexagon based on p\n    vec3 sp = sign(p);\n    vec3 f = rad * sp;\n    \n    // Make sure the hexagon is always convex\n    vec3 s = sign(rad - abs(p));\n    \n    // 6 verts\n    vec3 v0 = vec3( 1.0, 1.0, min(s.x,s.y))*f;\n    vec3 v1 = vec3( 1.0, s.x, s.x)*f;\n    vec3 v2 = vec3( 1.0, min(s.x,s.z), 1.0)*f;\n    vec3 v3 = vec3( s.z, s.z, 1.0)*f;\n    vec3 v4 = vec3( min(s.y,s.z), 1.0, 1.0)*f;\n    vec3 v5 = vec3( s.y, 1.0, s.y)*f;\n    \n    // Points of intersection with the plane\n    vec3 c0 = vec3(0.0);\n    vec3 c1 = vec3(0.0);\n    \n    // 6 edges\n    float occ = edgeOcclusion(p, n, v0, v1, c0, c1, w);\n    occ += edgeOcclusion(p, n, v1, v2, c0, c1, w);\n    occ += edgeOcclusion(p, n, v2, v3, c0, c1, w);\n    occ += edgeOcclusion(p, n, v3, v4, c0, c1, w);\n    occ += edgeOcclusion(p, n, v4, v5, c0, c1, w);\n    occ += edgeOcclusion(p, n, v5, v0, c0, c1, w);\n    occ *= sp.x * sp.y * sp.z;\n    // 1 edge for intersection with plane\n    occ += abs(fedgeOcclusion(p, n, c0, c1));\n    return max(0.0, occ);\n}\n\n//-----------------------------------------------------------------------------------------\n\n// https://iquilezles.org/articles/boxfunctions\nvec4 boxIntersect( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\n//-----------------------------------------------------------------------------------------\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    float s = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    if( iMouse.z<0.001 ) s=0.0;\n\n\tvec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n\t\n    // box animation\n\tmat4 rot = rotationAxisAngle( normalize(vec3(1.0,0.9,0.5)), 0.5*iTime );\n\tmat4 tra = translate( 0.0, 0.0, 0.0 );\n\tmat4 txi = tra * rot; \n\tmat4 txx = inverse( txi );\n\tvec3 box = vec3(0.2,0.7,2.0) ;\n\n    vec4 rrr = textureLod( iChannel0, (fragCoord.xy)/iChannelResolution[0].xy, 0.0  ).xzyw;\n\n    vec3 col = vec3(0.0);\n\n    float tmin = 1e10;\n    \n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + tmin*rd;\n        vec3 nor = vec3(0.0,1.0,0.0);\n        float occ = 0.0;\n        \n        if( p.x > s )\n        {\n            occ = boxOcclusion( pos, nor, txx, txi, box );\n        }\n        else\n        {\n   \t\t    vec3  ru  = normalize( cross( nor, vec3(0.0,1.0,1.0) ) );\n\t\t    vec3  rv  = normalize( cross( ru, nor ) );\n\n            occ = 0.0;\n            for( int i=0; i<256; i++ )\n            {\n                vec2  aa = hash2( rrr.x + float(i)*203.1 );\n                float ra = sqrt(aa.y);\n                float rx = ra*cos(6.2831*aa.x); \n                float ry = ra*sin(6.2831*aa.x);\n                float rz = sqrt( 1.0-aa.y );\n                vec3  dir = vec3( rx*ru + ry*rv + rz*nor );\n                vec4 res = boxIntersect( pos, dir, txx, txi, box );\n                occ += step(0.0,res.x);\n            }\n            occ /= 256.0;\n        }\n\n        col = vec3(1.2);\n        col *= 1.0 - occ;\n    }\n\n    vec4 res = boxIntersect( ro, rd, txx, txi, box );\n    float t2 = res.x;\n    if( t2>0.0 && t2<tmin )\n    {\n        tmin = t2;\n        float t = t2;\n        vec3 pos = ro + t*rd;\n        vec3 nor = res.yzw;\n\t\tcol = vec3(1.4);//vec3(1.0,0.85,0.6);\n        col *= 0.6 + 0.4*nor.y;\n\t}\n\n\tcol *= exp( -0.05*tmin );\n\n    float e = 2.0/iResolution.y;\n    col *= smoothstep( 0.0, 2.0*e, abs(p.x-s) );\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}