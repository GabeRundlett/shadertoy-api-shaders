{
    "Shader": {
        "info": {
            "date": "1582036063",
            "description": "A small one, just to practice patterns.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lyXzz",
            "likes": 7,
            "name": "Motion Loop #003",
            "published": 3,
            "tags": [
                "2d",
                "loop",
                "motion",
                "ease"
            ],
            "usePreview": 0,
            "username": "lsdlive",
            "viewed": 674
        },
        "renderpass": [
            {
                "code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nMotion Loop #003\n\nCheckout the ISF port: https://github.com/theotime/isf_shaders/blob/master/shaders/motiongraphics_003.fs\n\nWith the help of: https://thebookofshaders.com/examples/?chapter=motionToolKit\nWith the help of: https://patriciogonzalezvivo.github.io/PixelSpiritDeck/\n\n*/\n\n#define bpm 120.\n#define speed .25\n#define cross_height .1\n#define cross_width .4\n#define circle_radius .25\n#define circle_stroke .2\n\n#define AA 5.\n\n#define pi 3.141592\n#define time (speed*(bpm/60.)*iTime)\n\n// https://lospec.com/palette-list/1bit-monitor-glow\nvec3 col1 = vec3(.133, .137, .137);\nvec3 col2 = vec3(.941, .965, .941);\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat fill(float d) {\n    return 1. - smoothstep(0., AA / iResolution.x, d);\n}\n\n// inspired by Pixel Spirit Deck: https://patriciogonzalezvivo.github.io/PixelSpiritDeck/\n// + https://www.shadertoy.com/view/tsSXRz\nfloat stroke(float d, float width) {\n\treturn 1. - smoothstep(0., AA / iResolution.x, abs(d) - width * .5);\n}\n\nfloat bridge(float mask, float sdf, float w) {\n    mask *= 1. - stroke(sdf, w * 2.);\n    return mask + stroke(sdf, w);\n}\n\nfloat circle(vec2 p, float radius) {\n  return length(p) - radius;\n}\n\nfloat rect(vec2 p, vec2 size) {\n  vec2 d = abs(p) - size;\n  return min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.) < 1.) {\n        return .5 * t * t;\n    } else {\n        return -.5 * ((t - 1.) * (t - 3.) - 1.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float t1 = fract(time * .25);// sliding\n    float t2 = fract(time);// rotation\n    t2 = easeInOutQuad(t2);\n    \n    uv *= r2d(pi * .25);\n    vec2 uv1 = fract((uv + t1) * 4.) - .5;\n    vec2 uv2 = fract(((uv-vec2(t1, 0)) * 4.)+.5) - .5;\n\n    // layer1 - cross\n    float mask = fill(rect(uv1 * r2d(t2 * pi), vec2(cross_height, cross_width)));\n    mask += fill(rect(uv1 * r2d(t2 * pi), vec2(cross_width, cross_height)));\n    \n    // layer2 - circle\n    mask = bridge(mask, circle(uv2, circle_radius), circle_stroke) ;\n    \n    mask = clamp(mask, 0., 1.);\n    vec3 col = mix(col1, col2, mask);\n    \n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}