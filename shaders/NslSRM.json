{
    "Shader": {
        "info": {
            "date": "1618416899",
            "description": "potate",
            "flags": 32,
            "hasliked": 0,
            "id": "NslSRM",
            "likes": 9,
            "name": "Day 482",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 415
        },
        "renderpass": [
            {
                "code": "// THE FRACTAL FORMULA IN THE BACKGROUND IS MODIFIED \"FoldcutToy.frag\" from Fragmentarium by DarkBeam\n\n\nvec4 n14(float f){ return texture(iChannel0,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\nfloat text(vec2 p, float[8] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x)];\n    //char += 112. ;\n    if(scrobble)\n        char += floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y*pow(abs(sin(iTime + id.x*0.2)),14.) ) ;\n    \n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    \n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 8.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 uvn = fragCoord/iResolution.xy;\n    float pxsz = fwidth(uvn.x);\n\n    \n    vec3 col = texture(iChannel0,uvn).xyz;\n    \n    \n    col += 3.6*texture(iChannel1,uvn).xyz;\n    \n    col = pow(col,vec3(0.9,1.4,0.8));\n    \n    col = max(col,0.003);\n    \n    \n    \n{\n        vec2 p = uv;\n        vec2 md = vec2(0.08,0.05);\n        \n        p.x += 0.67 + md.x*1.;\n        p.y += md.y*0.5+0.2;\n        \n        vec3 c = vec3(1.3,1.35,1.46)*col*2. + (0.4-col*0.5)*1.4;\n        c = c*1.*(0.1-col);\n        //c = min(c,1.);\n        \n        {\n            vec2 id = floor(p/md);\n            vec2 q = pmod(p,md);\n            float d = sdBox(q, vec2(0.1,0.002));\n            \n            d = xor(d,sdBox(q + vec2(+ sin(14.*id.y + iTime*3. + sin(id.y + iTime))*0.04,0.), vec2(0.01 ,0.01)));\n            \n            //d = xor(d,0.0+sdBox(p - 0.0 , vec2(0.01 ,0.6)));\n            \n            \n            float cnd = float(abs(id.x) == 0. && abs(id.y) < 4.);\n            \n            //col = mix(col,c,cnd*smoothstep(pxsz,0.,d));\n        \n            float od = d;\n            \n            d = sdBox(p - vec2(-0.062,0) , vec2(0.001 ,0.2));\n            \n            \n            \n            //col = mix(col,c,smoothstep(pxsz,0.,d));\n        \n            float db = sdBox(uv + vec2(0.01,0.401) , vec2(0.6 ,0.415));\n            //col = mix(col,c,smoothstep(pxsz,0.,db));\n            \n        }\n        \n        //d = min(d, sdBox(uv + vec2(0.1), vec2(0.0,0.04)));\n        \n    }\n\n    {\n        float oo = 10e5;\n    \n            float ob = (sdBox(uv,vec2(1.45,0.46)));\n            \n            float cutout = sdBox(uv - vec2(0.5,0.4),vec2(0.6 + sin(iTime)*0.1,0.5));\n            \n            cutout = xor(cutout, sdBox(uv + vec2(0.3,0.4),vec2(0.6 + sin(iTime)*0.2,0.5)));\n            \n            float outerBox = max(abs(ob),-cutout);\n            outerBox = min(outerBox, max(abs(ob + 0.04), -cutout + 0.3));\n            \n            outerBox = min(outerBox, max(abs(ob + 0.01), -cutout + 0.3));\n            \n            oo = min(oo,outerBox) - 0.001;\n            {\n                vec2 p = uv;\n                float m = sin(iTime*0.4 + sin(iTime));\n                float b = sdBox(p - vec2(0.5 + m*0.1,0.4),vec2(0.3,0.5));\n                b = xorb(b,(sdBox(p - vec2(0.2,0.4),vec2(0.2,0.5))),0.1);\n                b = xorb(b,(sdBox(p - vec2(0.2,0.4),vec2(0.4,0.2))),0.1);\n                b = xorb(b,abs(sdBox(p - vec2(0.+m*0.2,0.4),vec2(0.4,0.1))),0.1);\n                b = xorb(b,(sdBox(p - vec2(0.-m*0.2 - 0.1,0.4),vec2(0.6,0.005))),0.1);\n                \n                oo = min(oo,abs(b) - 0.004);\n            \n                \n            }\n            {\n                vec2 p = uv + vec2(0.1,0.5);\n                p.x += iTime*0.2+ sin(iTime)*0.5;\n                p.x = pmod(p.x,2.);\n                float m = sin(iTime*0.3 + sin(iTime) );\n                float b = sdBox(p - vec2(0.5 + m*0.1,0.4),vec2(0.3,0.5));\n                b = xorb(b,(sdBox(p - vec2(0.2,0.4),vec2(0.2,0.5))),0.1);\n                b = xorb(b,(sdBox(p - vec2(0.1,0.4),vec2(0.4,0.2))),0.1);\n                b = xorb(b,abs(sdBox(p - vec2(0.+m*0.2,0.4),vec2(0.4,0.1))),0.1);\n                b = xorb(b,(sdBox(p - vec2(0.-m*0.2 - 0.1,0.4),vec2(0.6,0.00))),0.1);\n                \n                oo = min(oo,abs(b) - 0.03);\n            \n                \n            }   \n            {\n                vec2 p = uv + vec2(0.1,0.76);\n                p *= rot(0.*pi);\n                float m = sin(iTime*0.3 + 4. + sin(iTime+1.) );\n                float b = sdBox(p - vec2(0.5 + m*0.1,0.4),vec2(0.3,0.5));\n                b = xorb(b,(sdBox(p - vec2(0.4,0.4),vec2(0.,0.6))),0.1);\n                b = xorb(b,(sdBox(p - vec2(0.1,0.4),vec2(0.4,0.4))),0.1);\n                b = xorb(b,abs(sdBox(p - vec2(0.+m*0.2,0.4),vec2(0.4,0.1))),0.1);\n                b = xorb(b,(sdBox(p - vec2(0.-m*0.2 - 0.1,0.4),vec2(0.6,0.00))),0.1);\n                \n                oo = min(oo,abs(b) - 0.001);\n            \n                \n            }            \n            col = mix(col,(0.5-col) ,smoothstep(pxsz*2.,0., oo));\n            \n            float t = 10e5;\n            \n            for(float i = 0.; i < 4.; i++){\n                float m = sin(iTime*0.4 + sin(iTime)+i);\n                t = min(t,text(uv + vec2(0,sin(i+ m)*0.1), float[8](135.,130.,121.,119.,120.,132.,117.,130.), 0.04 +m*0.5 , 0.5 , true, 0.004, 0.3 + 0.1*sin(iTime+i*0.4), false));\n                \n                \n            }\n            {\n                float m = sin(iTime*0.4 + sin(iTime));\n                vec2 p = uv + vec2(0.7,-0.2);\n                p *= rot(0.5*pi);\n                p.x += (iTime + sin(iTime))*0.3;\n                p.x = pmod(p.x,2.);\n                t = min(t,text(p, float[8](128.,127.,132.,113.,132.,117.,1117.,1130.), 0.01 +m*0.4 , 0.4 , true, 0.0001, 0.4 + 0.*sin(iTime*0.3 + 0.4), true));\n            }   \n             \n            \n            col = mix(col,(0.5-col) ,smoothstep(pxsz + 0.054,0., t));\n            \n\n            \n    }\n     \n    \n    if(mod(iTime,6.)>5.5)\n        col = 1. - col*vec3(1,1,1.5);\n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define T(a) texture(iChannel1,(a)/iResolution.xy)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,a) mod(p,a) - 0.5*a\n#define xorb(a,b,c) min(max(a + c,-(b)),max(b,-(a)))\n#define pi acos(-1.)\n\nmat3 orthogonalBasis(vec3 ro, vec3 lookAt){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir, right));\n    return mat3(right, up, dir);\n}\nmat3  rotationMatrix3(vec3 v, float angle)\n{\n\tfloat c = cos(radians(angle));\n\tfloat s = sin(radians(angle));\n\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n\n\nfloat sdBox(vec2 p, vec2 s){p = abs(p) -s; return max(p.y,p.x);}\n\n#define xor(a,b) min(max(a,-(b)),max(b,-(a) +0.02))\n\nvec3 pal(float m){\n    vec3 c = 0.5+0.5*sin(m + vec3(1.5,0.,-0.5));\n    c = pow(c, vec3( .5));\n    \n    return c;\n}\n\n\n\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n\nmat3 fracRotation1;\n\n\nfloat glow = 0.;\nfloat DE(vec3 z)\n{\nvec3 p = z;\n    float m = sin(iTime+sin(iTime)*1.)*0.5 + sin(iTime);\n    z.yz*=rot(.5 );\n    int Iterations = 5;\n    vec3 Offset = vec3(1.376,1.1,1.);\n    vec3 Offset2 = vec3(1.4+(m)*.4,.58,-0.4); \n    float Angle1 = -33.513514 + 5.*sin(m+iTime);\n    vec3 Rot1 = vec3(.96, -2.38 + (m), .19);\n    float Scale = 1.3686;\n\n\tfracRotation1 = Scale* rotationMatrix3(normalize(Rot1), Angle1);\n    float t; int n = 0;\n    float scalep = 1.;\n    float DE1 = 1e4;\n    vec3 z0=z;\n    for(int n = 0; n < Iterations; n++){\n        z *= fracRotation1;\n        //z = abs(z);\n           z -= Offset;\n        if (z.y>z.x) z.xy =z.yx;\n        if (z.z>z.x) z.xz = z.zx;\n        if (z.y>z.x) z.xy =z.yx;\n           z -= Offset2;\n        if (z.y>z.x) z.xy =z.yx;\n        if (z.z>z.x) z.xz = z.zx;\n        if (z.y>z.x) z.xy =z.yx;\n        \n        scalep *= Scale;\n        if(n == 3 || n == 1)\n            glow += exp(-length(z.z+ vec2(1.5,sin(m+iTime + p.x)*1. -0.))/scalep*16.);\n        if(n<3)\n            DE1 = min(DE1,abs(z.x/scalep));\n        else {\n            DE1 = max(DE1,-(z.x/scalep) );\n        \n        \n            //DE1 = max(DE1,-length(z.yz/scalep) + 0.1 );\n        \n        }\n        \n    }\n\t\n\t\t\n\t//Distance to the plane going through vec3(Size,0.,0.) and which normal is plnormal\n\treturn DE1;\n}\n\nvec2 map(vec3 _p){\n    vec2 d = vec2(10e4);\n    \n    //vec4 p = vec4(_p,1.);\n    \n    _p = abs(_p);\n    _p.xz *= rot(-3.);\n    _p.yz *= rot(3.);\n    //d.x = length(_p) - 1.;\n    d.x = DE(_p);\n\n    return d;\n}\n// fast normals, by tdhooper i think.\nconst int NORMAL_STEPS = 6;\nvec3 getNormal(vec3 pos) {\n\n    vec3 eps = vec3(.0001, 0, 0);\n\t\n\tvec3 nor = vec3(0);\n\tfloat invert = 1.;\n\tfor (int i = 0; i < NORMAL_STEPS; i++) {\n\t\tnor += map(pos + eps * invert).x * eps * invert;\n\t\teps = eps.zxy;\n\t\tinvert *= -1.;\n\t}\n\treturn normalize(nor);\n}\n\nvec3 getNormala(vec3 p){\n    vec2 t = vec2(0.001,0.);\n    return normalize(vec3( \n        map(p+t.xyy).x -map(p-t.xyy).x,\n        map(p+t.yxy).x -map(p-t.yxy).x,\n        map(p+t.yyx).x -map(p-t.yyx).x\n    ));\n}\n\n\nfloat cyclicNoise(vec3 _p){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(_p,1.+iTime*1.);\n    for(int i = 0; i < 4; i++){\n        p.xw *= rot(0.5);\n        p.yw *= rot(.5);\n        p.yz*= rot(1.5);\n        p -= sin(p + vec4(3,2,1.,3. + iTime))*.05*amp;\n        n += dot(sin(p),cos(p))*amp;\n        p *= 1.5;\n        amp *= 0.8;\n    }\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n    vec3 col = vec3(0,0.004,0.004);\n    \n    vec3 ro = vec3(0.907761491,4.,3.55399078);\n    vec3 lookAt = vec3(-1.0086998,.8070591066,1.223318864);\n    ro.xz *= rot(sin(iTime*0.5 + cos(iTime/2.)*0.5)*.4 + 2.1  + 0.*(iMouse.x/iResolution.y*2. - 1.));\n    ro.z += 1.7;\n    vec3 rd = orthogonalBasis(ro, lookAt)*normalize(vec3(uv,1.));\n    \n    rd.yz *= rot(0.);\n    vec3 p = ro; float t = 0.; bool hit = false;\n    vec2 d;\n    for(int i = 0; i < 110; i++){\n        d = map(p);\n        if(d.x < 0.0006){\n            hit = true;\n            break;\n        }\n        p = ro + rd*(t+=d.x*0.4);\n    }\n    float fog = 0.;\n    vec3 fp = ro;\n    float ft = 0.;\n    float fogStSz = 0.05;\n    for(int i = 0; i < 0; i++){\n        float dens = cyclicNoise(fp*6.);\n        dens = max(dens,0.);\n        fog += (1.-fog)*dens*fogStSz;\n        if(ft > t){\n            break;\n        }\n        fp = ro + rd*(ft+=fogStSz);\n    }\n    \n    col += mix(vec3(0.,0.1,1.),vec3(1. + sin(iTime +uv.x*0.4)*0.2,0.5,1.),glow*1.6)*glow*0.1;\n    \n    \n    //col += fog*0.1*vec3(0.1,0.5,0.6);\n    if(hit){\n        vec3 n = getNormal(p);\n        \n        bool debug = false;\n        if(debug){\n            col = 0.5 + 0.5*n;\n        }else {\n            vec3 albedo = vec3(.1,0.9,.5);\n            vec3 lCol = vec3(0.2,0.5,0.9);\n            vec3 ldir = normalize(vec3(-1,1.,4.));\n            vec3 hf = normalize(n+ldir);\n            float diff = max(dot(ldir,n),0.);\n            float spec = pow(max(dot(hf,-rd),0.),15.)*1.4;\n            float fres = pow(1.-max(dot(-rd,n),0.),3.);\n            //spec = fres;\n            spec = mix(spec,fres,fres);\n            #define ao(a) smoothstep(0.,1.,map(p+n*a).x/a)\n            float AO = ao(0.3)*ao(4.1)*ao(0.9)+0.;\n            \n            col += 16.*mix(diff*0.02*albedo,lCol*spec,spec)*AO;\n        \n        }\n    \n        \n    } else{\n    \n        //col += sin(rd + vec3(3,4,1))*0.004;\n    }\n    \n    {\n        float pl = plaIntersect(  ro - 4.,  rd, vec4(1,0.,0,0) );\n        vec3 pp = ro +rd*pl;\n\n        vec2 p = pp.yz;\n        p.y += iTime*0. + sin(iTime)*0.0;\n        float md = 1.;\n        vec2 id = floor(p/md);\n        p = pmod(p,md);\n        float d = abs(p.y);\n        d = min(d,abs(p.x));\n        float m = sin(id.y + iTime + cos(id.x*20. +sin(id.y + iTime*0.5)*13.))*0.0;\n        d -= m*0.1;\n        d = max(d,-abs(length(p) - 0.01 -m) + 0.2);\n        //col = mix(col,vec3(0.6,0.7,0.4)*2.*col,col*smoothstep(pxsz,0.,uv.y + 0.3 + 0.04*7.*noise(vec3(uv*4.,1. + iTime))));\n        \n    }\n    \n    //col = clamp(col,0.,1.);\n    \n    col =0.5 - col*4.;\n    \n    //col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    C -= C;\n    vec2 kernSz = vec2(4.);\n    float iters = kernSz.x * kernSz.y;\n    float thresh = 0.1;\n    for(float x = 0.; x < iters; x++){\n            vec2 offs = vec2(\n                mod(x,kernSz.x) - 0.5*kernSz.x,\n                floor(x/kernSz.x) - 0.5*kernSz.y\n                );\n            vec4 t = texture(iChannel0,(U + offs*14.)/iResolution.xy,1.); \n            C += smoothstep(thresh,thresh+1.,t)*(1.-3.*dot(offs/kernSz,offs/kernSz));\n    \n\n    }\n    C = max(C,0.);\n    C /= iters;\n    //C = T(a);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}