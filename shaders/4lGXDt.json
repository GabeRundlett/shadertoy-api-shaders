{
    "Shader": {
        "info": {
            "date": "1488442979",
            "description": "Well I think its done now. The segment operators have been upgraded to return all possibilities, letting you build hollow and complex shapes. One problem is the exponentially growing number of segment operations per object...",
            "flags": 48,
            "hasliked": 0,
            "id": "4lGXDt",
            "likes": 4,
            "name": "CSG segment tracer",
            "published": 3,
            "tags": [
                "ray",
                "csg",
                "geometry",
                "tracer",
                "segment",
                "solid",
                "constructive"
            ],
            "usePreview": 0,
            "username": "KylBlz",
            "viewed": 638
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0,uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//seperate distance from normal calcs for speed\n//use ___2gen() functions with t functions\n\n#define BOUNCE_PXL\t1\n#define GAMMA\t\t1.\n#define EXPOSURE\t1.\n\n#define vec3max(a) max(a.x, max(a.y, a.z))\n#define vec2max(a) max(a.x, a.y)\n#define vec3min(a) min(a.x, min(a.y, a.z))\n#define vec2min(a) min(a.x, a.y)\n\n#define valid(a) (a.t.y < zfar)\n#define inRange(a,x,b) (step(a, x) * step(x, b))\n#define overlap(a, b) ((a.t.y > b.t.x) && (a.t.x < b.t.y))\n#define contains(a, b) ((a.t.x > b.t.x) && (a.t.y < b.t.y))\n#define minT(a) (a.y<a.x)? zfar: (a.x<0.)? (a.y<0.)? zfar: a.y: a.x\n\nconst float zfar = 1000.,\n\t\t\teps  = .00001, ieps = .99999,\n\t\t\tsml  = .005, isml = .995,\n\t\t\tsc45 = .7071067,\n\t\t\tpi_5 = 1.5707963, pi2  = 6.2831853,\n\t\t\tpi   = 3.1415926, pi_rcp = .3183098;\n\n// storage addresses\nconst vec2  txVel = vec2( .5,.5),\n\t\t\ttxLoc = vec2(1.5,.5),\n\t\t\ttxRot = vec2(2.5,.5),\n\t\t\ttxMou = vec2(3.5,.5);\n\n//Absorb, Emit rgb wavelengths, Surface scatter, sUbsurface scatter, Refractive index, Emission Uniformity, unique iDentifier\nstruct mat { vec3 a, e; vec2 s, u; float r, eu; int d; };\n//1D line segment with ids for each end point\nstruct seg { vec2 t; ivec2 d; };\n//Location, Normal, Info(distance, thickness, nothing), material\nstruct hit { vec3 l, n; float d; mat m; };\n//Origin, Direction, Color, current material\nstruct ray { vec3 o, d, c; mat m; };\n//center Location, Radius, Material\nstruct sph { vec3 l; float r; mat m; int d; };\n//Location, Normal, Info(size x,y,'depth'), Material\nstruct pln { vec3 l, n, i; mat m; int d; };\n//center, size, Material\nstruct box { vec3 c, s; vec2 t; mat m; int d; };\n\nconst mat nullMat = mat(vec3(0.), vec3(0.), vec2(0.), vec2(0.), 0., 0., 0);\nconst seg nullSeg = seg(vec2(zfar), ivec2(0));\nconst hit nullHit = hit(vec3(0.), vec3(0.), zfar, nullMat);\nconst vec2 nullT = vec2(zfar, 0.);\n\n////////////////////// Materials\nconst mat\n\t_air = mat(vec3(.99), vec3(0.), vec2(.01), vec2(.1), 1.0003, 0., 1),\n\t_nrm = mat(vec3(0.), vec3(0.), vec2(0.), vec2(0.), 1., 0., 40),\n    _dst = mat(vec3(0.), vec3(0.), vec2(0.), vec2(0.), 1., 0., 41);\n\n////////////////////// Dynamic material implementation\nmat nrm(in ray r, inout hit h) {\n    return mat(h.n, vec3(0.), vec2(0.), vec2(0.), 1., 0., _nrm.d);\n}\nmat dst(in ray r, inout hit h) {\n    return mat(vec3(h.d*.025), vec3(0.), vec2(0.), vec2(0.), 1., 0., _dst.d);\n}\n\n////////////////////// Primitives\nsph sph0 = sph(vec3(0.), 2., _nrm, 1),\n    sph1 = sph(vec3(0.,2.,0.), 2., _nrm, 2);\nbox box0 = box(vec3(0.), vec3(1.71), vec2(0., 0.), _nrm, 20),\n    box1 = box(vec3(0.), vec3(5.), vec2(0.), _nrm, 21),\n\tbox2 = box(vec3(0.), vec3(4.5), vec2(0.), _nrm, 22),\n\tbox3 = box(vec3(5.), vec3(5.), vec2(0.), _dst, 23);\n\n////////////////////// Tools\nvec3 rotateY(vec3 p, float angle) {\n    float c = cos(angle), s = sin(angle);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\nvec3 rotateXY(in vec3 p, in vec2 angle) {\n    vec2 c=cos(angle), s=sin(angle); vec3 o = p;\n    o.yz *= mat2(c.x,s.x,-s.x,c.x); o.xz *= mat2(c.y,s.y,-s.y,c.y);\n    return o;\n}\nvec2 pickXLT(in seg l, in seg r) {\n    if (l.t.x < r.t.x) return vec2(l.t.x, float(l.d.x));\n    return vec2(r.t.x, float(r.d.x));\n}\nvec2 pickYLT(in seg l, in seg r) {\n    if (l.t.y < r.t.y) return vec2(l.t.y, float(l.d.y));\n    return vec2(r.t.y, float(r.d.y));\n}\nvec2 pickXGT(in seg l, in seg r) {\n    if (l.t.x > r.t.x && l.t.x < zfar) return vec2(l.t.x, float(l.d.x));\n    else if (r.t.x < zfar) return vec2(r.t.x, float(r.d.x));\n    return nullT;\n}\nvec2 pickYGT(in seg l, in seg r) {\n    if (l.t.y > r.t.y && l.t.y < zfar) return vec2(l.t.y, float(l.d.y));\n    else if (r.t.y < zfar) return vec2(r.t.y, float(r.d.y));\n    return nullT;\n}\n\n////////////////////// Normal functions\nvec3 nSphere(in vec3 l, in sph s) {\n    return (l - s.l) / s.r;   \n}\nvec3 nPlane(in pln p) {\n    return p.n;\n}\nvec3 nBox(in vec3 l, in box b) {\n    vec3 a = l - b.c;\n    return normalize(step(b.s*isml, abs(a)) * sign(a));\n}\n\n////////////////////// Segment operators\nvec2 lt(in seg s) {\n    if (s.t.x < s.t.y && s.t.x > 0.) return vec2(s.t.x, float(s.d.x));\n    else if (s.t.y > 0.) return vec2(s.t.y, float(s.d.y));\n    return nullT;\n}\nvoid tIntersect(in seg l, in seg r, out seg o) {\n    o = nullSeg;\n\tif (!overlap(l, r) || !valid(l) || !valid(r)) return;\n    vec2 t1 = pickXGT(l, r), t2 = pickYLT(l, r);\n    o = seg(vec2(t1.x, t2.x), ivec2(int(t1.y), int(t2.y)));\n}\nvoid tUnion(in seg l, in seg r, out seg o, out seg p) {\n\to = nullSeg; p = nullSeg;\n    if (!overlap(l, r)) { o = l; p = r; return; }\n    vec2 t1 = pickXLT(l, r), t2 = pickYGT(l, r);\n    o = seg(vec2(t1.x, t2.x), ivec2(int(t1.y), int(t2.y)));\n}\nvoid tDiff(in seg l, in seg r, out seg o, out seg p) {\n    o = nullSeg; p = nullSeg;\n    if (!overlap(l, r)) { o = l; return; }\n    if (contains(l, r)) return;\n    if (contains(r, l)) {\n\t\tvec2 t1 = pickXLT(l, r), t2 = pickXGT(l, r), t3 = pickYLT(l, r), t4 = pickYGT(l, r);\n\t    o = seg(vec2(t1.x, t2.x), ivec2(int(t1.y), int(t2.y)));\n\t    p = seg(vec2(t3.x, t4.x), ivec2(int(t3.y), int(t4.y)));\n        return;\n    }\n    vec2 t1 = nullT, t2 = nullT;\n    if (l.t.x < r.t.x) { t1 = pickXLT(l, r); t2 = pickXGT(l, r);\n    } else { t1 = pickYLT(l, r); t2 = pickYGT(l, r); } \n    o = seg(vec2(t1.x, t2.x), ivec2(int(t1.y), int(t2.y)));\n}\n\n////////////////////// Segment functions\nseg lt(in seg l, in seg r) {\n    if (l.t.x < r.t.x && l.t.y > 0.) return l;\n    else if (r.t.y > 0.) return r;\n    return nullSeg;\n}\nseg tSphere(in ray r, in sph s) {\n    vec3 oc = r.o - s.l;\n    float c = dot(oc, oc) - s.r * s.r,\n          b = -dot(oc, r.d),\n          h = b*b - c;\n    if (h < 0.) return nullSeg;\n    h = sqrt(h);\n    return seg(vec2(b-h,b+h), ivec2(s.d, -s.d));\n}\nseg tPlane(in ray r, in pln p) {\n    float t = dot(p.n, p.l - r.o) / dot(p.n, r.d);\n    return seg(vec2(t, t+eps), ivec2(p.d, -p.d));\n}\nseg tBox(in ray r, in box b) {\n    vec3 t1 = (b.c-b.s - r.o)/r.d,\n         t2 = (b.c+b.s - r.o)/r.d;\n    float tn = vec3max(min(t1, t2)),\n          tx = vec3min(max(t1, t2));\n    if (tx<tn || tx<0.) return nullSeg;\n    return seg(vec2(tn, tx), ivec2(b.d, -b.d));\n}\n\n////////////////////// Constructive Solid Geometry implementation\nhit lt(in hit l, in hit r) {\n    if (l.d < r.d && l.d > 0.) return l;\n    return r;\n}\nhit lens1(in ray r) {\n    //get segments of shapes\n    seg a = tSphere(r, sph0),\n        b = tSphere(r, sph1),\n        s = nullSeg;\n    tIntersect(a,b, s);\n    //choose lowest non negitive point\n    vec2 g = lt(s);\n    //if t point object is not defined\n    if (g.y == 0.) return nullHit;\n    //point properties\n    mat o = nullMat;\n    g.x = minT(vec2(g.x, zfar));\n    vec3 n = vec3(0.), l = r.o + r.d * g.x;\n    //get id of chosen hit and 'first' hit\n    int id = abs(int(g.y));\n    //check item\n    if (id == sph0.d) {\n        o = sph0.m; n = nSphere(l, sph0);\n    } else if (id == sph1.d) {\n        o = sph1.m; n = nSphere(l, sph1);\n    } else return nullHit;\n    return hit(l, n * sign(g.y), g.x, o); \n}\nhit room1(in ray r) {\n\t//get segments of shapes\n    seg a = tBox(r, box1), b = tBox(r, box2), c = tBox(r, box3);\n    seg[] s = seg[6](nullSeg, nullSeg, nullSeg, nullSeg, nullSeg, nullSeg);\n    tDiff(a,b, s[0], s[1]);\n    tDiff(s[0],c, s[2], s[3]);\n    tDiff(s[1],c, s[4], s[5]);\n    //choose lowest non negitive point\n    vec2 g = lt(lt(s[2], lt(s[3], lt(s[4], s[5]))));\n    //if t point object is not defined\n    if (g.y == 0.) return nullHit;\n    //point properties\n    mat o = nullMat;\n    g.x = minT(vec2(g.x, zfar));\n    vec3 n = vec3(0.), l = r.o + r.d * g.x;\n    //get id of chosen hit and 'first' hit\n    int id = abs(int(g.y));\n    //choose material\n    if (id == box1.d) {\n        o = box1.m; n = nBox(l, box1);\n    } else if (id == box2.d) {\n        o = box2.m; n = nBox(l, box2);\n    } else if (id == box3.d) {\n        o = box3.m; n = nBox(l, box3);\n\t} else return nullHit;\n    //invert normal if t is the second intersection\n    return hit(l, n * sign(g.y), g.x, o);\n}\n\n////////////////////// Scene functions\nvoid updateMaterials(in ray r, inout hit h) {\n    if (h.m.d < 40) return;\n    else if (h.m.d == _nrm.d) h.m = nrm(r, h);\n    else if (h.m.d == _dst.d) h.m = dst(r, h);\n}\n\n//calculates where the ray intersects\nhit traceScene(in ray r) {\n    hit o = nullHit;\n    o = lt(o, lens1(r));\n    o = lt(o, room1(r));\n    return o;\n}\n\n//here we go\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    //get input, update camera\n    vec3 l = texture(iChannel1, txLoc/iChannelResolution[1].xy ).xyz,\n    \t v = texture(iChannel1, txVel/iChannelResolution[1].xy ).xyz,\n    \t o = texture(iChannel1, txRot/iChannelResolution[1].xy ).xyz;\n\t\n    hit h = nullHit;\n    //final color\n    vec3 final = vec3(0.);\n    //scene\n\tif (uv.y < 0.5) {\n        //start the ray at the camera in starting material\n        ray r = ray(l, rotateXY(normalize(vec3(uv, 1.)), o.xy), vec3(1.), _air);\n        h = traceScene(r);\n        //if collision\n        if (h.d < zfar) {\n            //update dynamic materials\n            updateMaterials(r, h);\n            //add colors\n            final += h.m.a;\n        }\n        final = pow(final*EXPOSURE, vec3(GAMMA));\n        //crosshair\n        if (length(uv)<0.01) fragColor = vec4(1.-final, 1.);\n        else fragColor = vec4(final, 1.);\n    } else {\n        //start the ray\n        ray r = ray(l, rotateXY(vec3(0., 0., 1.), o.xy), vec3(1.), _air);\n        //get segments of shapes\n        seg a = tBox(r, box1), b = tBox(r, box2), c = tBox(r, box3);\n        seg[] s = seg[6](nullSeg, nullSeg, nullSeg, nullSeg, nullSeg, nullSeg);\n        tDiff(a,b, s[0], s[1]);\n        tDiff(s[0],c, s[2], s[3]);\n        tDiff(s[1],c, s[4], s[5]);\n        a = tSphere(r, sph0);\n        b = tSphere(r, sph1);\n        tIntersect(a,b, s[1]);\n        vec3 col = vec3(1.,vec2(float((uv.x+.25)>0.)));\n        float x = (uv.x+.25)*15.;\n        //render segments\n        fragColor = vec4(.3) + vec4((\n            inRange(s[1].t.x, x, s[1].t.y)+\n            inRange(s[2].t.x, x, s[2].t.y)+\n            inRange(s[3].t.x, x, s[3].t.y)+\n            inRange(s[4].t.x, x, s[4].t.y)+\n            inRange(s[5].t.x, x, s[5].t.y)\n        )*col.grb, .7);\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define MAX_ACCELERATION      16.\n#define MAX_VELOCITY          4.\n#define FRICTION              8.\n\n#define VALUE_VELOCITY        0\n#define VALUE_POSITION        1\n#define VALUE_ROTATION        2\n#define VALUE_MOUSE           3\n\n//half pi\nconst float pi = 3.1415926,\n    \t\tpi_5 = 1.5707963;\n\nconst vec2 KEY_W \t = vec2(87.5 / 256., 0.),\n    \t   KEY_S \t = vec2(83.5 / 256., 0.),\n    \t   KEY_A \t = vec2(65.5 / 256., 0.),\n    \t   KEY_D \t = vec2(68.5 / 256., 0.),\n\t\t   KEY_LEFT  = vec2(37.5 / 256., 0.),\n\t\t   KEY_UP    = vec2(38.5 / 256., 0.),\n\t\t   KEY_RIGHT = vec2(39.5 / 256., 0.),\n\t\t   KEY_DOWN  = vec2(40.5 / 256., 0.),\n    \t   KEY_SHIFT = vec2(16.0 / 256., 0.),\n    \t   KEY_SPACE = vec2(32.0 / 256., 0.);\n\nconst vec4 INIT_POS = vec4(8., 6., 10., 0.),\n    \t   INIT_VEL = vec4(0., 0., 0., 0.),\n    \t   INIT_ROT = vec4(-.4, 3.85, 0., 0.),\n    \t   INIT_MOU = vec4(0.);\n\nvec3 vRotateY(vec3 p, float angle) {\n    float c = cos(angle), s = sin(angle);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec3 getAcceleration() {\n    return vec3(\n        texture(iChannel1, KEY_D).x - texture(iChannel1, KEY_A).x + texture(iChannel1, KEY_RIGHT).x - texture(iChannel1, KEY_LEFT).x,\n        texture(iChannel1, KEY_SPACE).x - texture(iChannel1, KEY_SHIFT).x,\n        texture(iChannel1, KEY_W).x - texture(iChannel1, KEY_S).x + texture(iChannel1, KEY_UP).x - texture(iChannel1, KEY_DOWN).x\n    );\n}\n\nvec4 getValue(int a) {\n    vec2 q = vec2(float(a) + 0.5, 0.0) / iResolution.x;\n    return texture(iChannel0, q);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (fragCoord.y > 1.) discard;\n    \n    int a = int(fragCoord.x);\n    float q = fragCoord.x / iResolution.x;\n    vec4 value = texture(iChannel0, vec2(q, 0.));\n    \n    //set initial values\n    if (iFrame == 0) {\n        if (a == VALUE_ROTATION) {\n            value = INIT_ROT;\n        } else if (a == VALUE_MOUSE) {\n            value = INIT_MOU;\n        } else if (a == VALUE_VELOCITY) {\n            value = INIT_VEL;\n        } else if (a == VALUE_POSITION) {\n            value = INIT_POS;\n        }    \n    }\n    \n    if (a == VALUE_ROTATION && iMouse.z > 0.) {\n        vec4 mouse = 2.0 * abs(iMouse) / iResolution.y;\n        vec4 rot = getValue(VALUE_MOUSE);\n        value.y = mouse.x - mouse.z + rot.y;\n        value.x = clamp(mouse.y - mouse.w + rot.x, -pi_5, pi_5);\n        \n    } else if (a == VALUE_MOUSE && iMouse.z < 0.) {\n        value = getValue(VALUE_ROTATION);\n        \n    } else if (a == VALUE_VELOCITY) {\n        float rot = getValue(VALUE_ROTATION).y;\n        vec3 acc = vRotateY(getAcceleration(), rot);\n        value.xyz += acc * MAX_ACCELERATION * iTimeDelta;\n        float speed = length(value.xyz);\n        //limit speed\n        if (speed > MAX_VELOCITY) {\n            value.xyz *= MAX_VELOCITY / speed;\n        } else if (speed > FRICTION * iTimeDelta) {\n            value.xyz *= (speed - FRICTION * iTimeDelta) / speed;\n        } else {\n            value.xyz = vec3(0.0, 0.0, 0.0);\n        }\n    } else if (a == VALUE_POSITION) {\n        vec3 velocity = getValue(VALUE_VELOCITY).xyz;\n        value.xyz += velocity * iTimeDelta;\n    }\n    \n    fragColor = vec4(value);\n    return;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}