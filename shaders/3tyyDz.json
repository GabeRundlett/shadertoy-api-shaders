{
    "Shader": {
        "info": {
            "date": "1610818807",
            "description": "my first 2021 shader, inspired by Fantasy Crystals from cabbibo.\nUse the mouse to control.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tyyDz",
            "likes": 23,
            "name": "Kryptonite",
            "published": 3,
            "tags": [
                "refraction",
                "volumetric",
                "convex",
                "glass",
                "smoke",
                "gem",
                "crystal",
                "kryptonite",
                "quartz"
            ],
            "usePreview": 0,
            "username": "xjorma",
            "viewed": 758
        },
        "renderpass": [
            {
                "code": "// Created by David Gallardo - xjorma/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define AA      0\n#define GAMMA   1\n#define ANIMATE 1\n\nconst float cref = 0.95;\nconst float speed = -0.02;\n\n\nconst float fltMax = 1000000.;\nconst float fltMin = -1000000.;\n\n// from xjorma https://www.shadertoy.com/view/3tVcDh\n\nbool convexIntersect( in vec3 ro, in vec3 rd, out vec2 oDis, out vec3 oNor)\n{\n    oDis = vec2(fltMin, fltMax);\n    for(int i = 0 ;i < numPlanes; i++)\n    {\n        vec4 plane = planes[i];\n        float t = -(plane.w + dot(plane.xyz, ro)) / dot(plane.xyz, rd);\n        if(dot(plane.xyz, rd) < 0.) // enter\n        {\n            if(t > oDis.x)\n            {\n                oDis.x = t;\n                oNor = plane.xyz;\n            }\n        }\n        else  // exit\n        {\n            oDis.y = min(oDis.y, t);\n        }\n    }\n    if(oDis.x < oDis.y)\n    {\n        return true;\n    }\n    return false;\n}\n\n\n// Noise from Nimitz https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x)\n{\n    return abs(fract(x) - .5);\n}\nvec3 tri3(in vec3 p)\n{\n    return vec3( tri(p.z + tri(p.y * 1.)), tri(p.z + tri(p.x * 1.)), tri(p.y + tri(p.z * 1.)));\n}\n                                 \n\nfloat triNoise3d(in vec3 p, in float inter)\n{\n    float z= 1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i = 0.; i <= inter; i++)\n\t{\n        p += tri3(bp * 2.);\n#if ANIMATE\n        p += iTime * speed;\n#endif\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        \n        rz+= (tri(p.z + tri(p.x + tri(p.y)))) / z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nfloat map(in vec3 p)\n{\n    return pow(triNoise3d(p * 0.1, 3.), 1.);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\n\n// from Guil https://www.shadertoy.com/view/MtX3Ws\nvec4 raymarch( in vec3 ro, inout vec3 rd, float mind, float maxd)\n{\n    float t = mind;\n    float dt = .02;\n    vec4 col= vec4(0.);\n    float c = 0.;\n    for( int i=0; i < 128; i++ )\n\t{\n        t+=dt*exp(-2.*c);\n        if( t > maxd)\n            break;\n        vec3 pos = ro+t*rd;\n        \n        c = map(pos);\n        \n        rd = normalize(mix(rd, -calcNormal(pos), 0.0003));  // Little refraction effect\n        \n        col = 0.99*col + .03 * vec4(c*c, c, c*c*c, c);\t\n    }    \n    return col;\n}\n\nvec4 textureGamma(samplerCube sampler, vec3 v)\n{\n    vec4 col = texture(sampler, v);\n    #if GAMMA\n    \treturn pow(col, vec4(2.2));\n    #else\n        return col;\n    #endif\n}\n\nvec3 render(in vec3 ro,in vec3 rd)\n{\n    vec3 col;\n    vec3  n;\n    vec2  d;\n    if(convexIntersect(ro, rd, d, n))\n    {\n        vec3 refl = reflect(rd, n);\n        vec3 refr = refract(rd, n, cref);\n        vec3 nout;\n        vec2 dout;\n        convexIntersect(ro + rd * d.x + refr * 20., -refr, dout, nout);\n        dout.x = 20. - dout.x;\n        vec4 c = raymarch(ro + rd * d.x, refr, 0., dout.x);\n        nout *= -1.;    // If want the normal in the opposite direction we are inside not outside\n        vec3 refrOut = refract(refr, nout, mix(1. / cref, 1., smoothstep(0.35, 0.20, dot(refr, -nout))));   // Dirty trick to avoid refract returning a zero vector when nornal and vector are almost perpendicular and eta bigger than 1.\n        col = mix(textureGamma(iChannel0, refrOut).rgb, c.rgb, c.a);\n        float fresnel = 1.0 - pow(dot(n, -rd), 2.);\n        col += textureGamma(iChannel0, refl).rgb * fresnel;   // add reflexion\n    }\n    else\n    {\n        col = textureGamma(iChannel0, rd).rgb;\n    }\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);      \n#if AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n        // camera        \n        float theta\t= radians(360.) * (iMouse.x/iResolution.x-0.5) + iTime*.2;\n        float phi\t= radians(70.) * (iMouse.y/iResolution.y-0.5) - radians(60.);\n        vec3 ro = 3. * vec3( sin(phi) * cos(theta), cos(phi), sin(phi) * sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        vec3 col = render(ro ,rd);  \n        tot += col;            \n#if AA\n    }\n    tot /= 4.;\n#endif\n    #if GAMMA\n    \ttot = pow(tot, vec3(1. / 2.2));\n    #endif\n    tot = vignette(tot, fragCoord / iResolution.xy, 0.6);\n    fragColor = vec4( tot, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Exported from Houdini\n\n/*\nimport sys\n\nnode = hou.pwd()\ngeo = node.geometry()\n\nprims = geo.prims()\n\nbbox =  geo.boundingBox();\nmaxPos = bbox.maxvec()\nminPos = bbox.minvec()\n\noutput = \"const int numPlanes = \" + str(len(prims)) + \";\\n\\n\"\noutput += \"const vec4 planes[numPlanes] = vec4[](\\n\"\nvector = []\nfor prim in prims:\n    normal = prim.attribValue(\"N\")\n    normal = hou.Vector3(normal[0], normal[1], normal[2])\n    points = prim.points()\n    point = points[0].position()\n    d = normal.dot(point)\n    vector.append(\"vec4(\" + str(normal.x()) + \", \" + str(normal.y()) + \", \" + str(normal.z()) + \", \" + str(-d) + \")\")\n    \noutput += \",\\n\".join(vector) + \" );\\n\\n\"\n\noutput = output + \"const vec3 bboxSiz = vec3(\" + str(bbox.sizevec().x() / 2.) + \", \" + str(bbox.sizevec().y() / 2.) + \", \" + str(bbox.sizevec().z() / 2.) + \");\\n\"\noutput = output + \"const vec3 bboxCtr = vec3(\" + str(bbox.center().x()) + \", \" + str(bbox.center().y()) + \", \" + str(bbox.center().z()) + \");\\n\"\n\nprint(output)\n*/\n\nconst int numPlanes = 17;\n\nconst vec4 planes[numPlanes] = vec4[](\nvec4(0.0, 1.0, 0.0, -1.75),\nvec4(0.0, -1.0, 0.0, -1.75),\nvec4(0.865558981895, 0.0, -0.500807106495, -0.742628234022),\nvec4(-0.353560000658, -1.80422770057e-08, -0.935411810875, -0.880737701417),\nvec4(-0.999897956848, -1.36637803294e-08, 0.0142883695662, -0.894969639267),\nvec4(-0.358315140009, 1.2375285692e-11, 0.933600723743, -0.848164967797),\nvec4(0.862004518509, 3.33596505975e-09, 0.50690060854, -0.81893926951),\nvec4(0.781055212021, 0.623916983604, 0.0260841995478, -1.22853477631),\nvec4(0.276541233063, 0.654822647572, -0.703372061253, -1.37026202368),\nvec4(-0.653981924057, 0.653027355671, -0.381919920444, -1.36055210583),\nvec4(-0.651714146137, 0.676901042461, 0.342160224915, -1.30437838268),\nvec4(0.32613825798, 0.617486417294, 0.715782403946, -1.26344136905),\nvec4(0.835819482803, -0.545120954514, 0.065184481442, -1.06336148713),\nvec4(0.240880459547, -0.629201292992, -0.738973855972, -1.31147556665),\nvec4(-0.596318423748, -0.65652692318, -0.461927205324, -1.35845409037),\nvec4(-0.591593742371, -0.707991778851, 0.385700017214, -1.36638951145),\nvec4(0.33144068718, -0.517934799194, 0.788600444794, -1.33775803516) );\n\nconst vec3 bboxSiz = vec3(0.903634905815, 1.75, 1.03868842125);\nconst vec3 bboxCtr = vec3(0.0, 0.0, 0.0);",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}