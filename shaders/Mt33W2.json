{
    "Shader": {
        "info": {
            "date": "1472141156",
            "description": "\nTiled floor, camera and lighting practice with the DNA from other shaders added The shader will \"run out of color\" at around 5 - 10 minutes. Haven't figured that part out yet, maybe it's the noise function.",
            "flags": 0,
            "hasliked": 0,
            "id": "Mt33W2",
            "likes": 116,
            "name": "GCLH [Commented]",
            "published": 3,
            "tags": [
                "plane",
                "helix",
                "tiling",
                "tile",
                "ground",
                "dna"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 7476
        },
        "renderpass": [
            {
                "code": "\n//take in vec2 return random float 0 - 1\nfloat rnd(vec2 p)\n{\n    vec2 seed = vec2(13.234, 72.1849);\n    return fract(sin(dot(p,seed))*43251.1234);    \n}\n\n//rounded box from iq\nfloat roundBox(vec3 p, vec3 b, float r)\n{\n    return length(max(abs(p)-b,0.0))-r;   \n}\n\n//rotation matrix (clockwise)\nmat2 rot(float a)\n{\n     float c = cos(a),s = sin(a);\n     return mat2(c, -s, s, c);\n}\n\n\n/*\n//makes the dna strands\nvec2 helix(vec3 p )\n{\n    //repeat space on xz\n    p.xz = mod(p.xz, 20.) -10.;\n    //rotate each cell based on y for helix shape\n    p.xz*=rot(p.y*3.14159/7.);\n    \n    //create two cylinders which will be twisted\n    vec2 t = vec2(length(p.xz + vec2(1.0,0.0)) - 0.2, 1.);\n    t.x = min(t.x,length(p.xz - vec2(1.0, 0.0)) - 0.2);\n    \n    vec2 h = vec2(length(p.xz + vec2(1.3,0.0)) - 0.1, 2.);\n    h.x = min(h.x,length(p.xz - vec2(1.3, 0.0)) - 0.1);\n    \n    t.y = t.x < h.x ? t.y : h.y; t.x = min(t.x,h.x);\n    //mod space on y for bars\n    p.y = mod(p.y,.4)-.2;\n    //create y repeated cylinders cut at abs(p.x etc)\n    h = vec2(max(length(p.yz) - 0.07, abs(p.x) - .9), 3.) ;\n    t.y = t.x < h.x ? t.y : h.y;  t.x = min(t.x,h.x);\n    //return helix (union of cylinders and bars)\n\treturn t;\n}\n*/\n//makes the dna strands\nfloat helix(vec3 p )\n{\n    //repeat space on xz\n    p.xz = mod(p.xz, 20.) -10.;\n    //rotate each cell based on y for helix shape\n    p.xz*=rot(p.y*3.14159/7.);\n    //create two cylinders which will be twisted\n    float cyl1 = length(p.xz + vec2(1.0,0.0)) - 0.2 ;\n    float cyl2 = length(p.xz - vec2(1.0, 0.0)) - 0.2 ;;\n    //mod space on y for bars\n    p.y = mod(p.y,.4)-.2;\n    //create y repeated cylinders cut at abs(p.x etc)\n    float bar = max(length(p.yz) - 0.07, abs(p.x) - .9) ;\n    //return helix (union of cylinders and bars)\n\treturn min(min(cyl1, bar), cyl2);\n}\n\nfloat tile(vec3 p){\n     //repeat xz \n     p.xz = mod(p.xz, 1.)-0.5;\n     //create rounded boxes for tiles and return\n     return roundBox(p,vec3(0.47), 0.019);\n}\n\n//map function\nfloat map(vec3 p)\n{\n //the union of tiles and dna\n     return min(tile(p),helix(p));    \n}\n\n//basic raymarch\nfloat trace(vec3 ro, vec3 rd)\n{\n   \tfloat t = 0.0,dist;\n    for(int i=0; i<96; i++)\n    {\n     dist = map(ro + rd*t);\n     if(dist<0.0001 || t > 120.){break;}\n     t += dist*0.75;\n    }\n return t;   \n}\n\n//reflection trace (see shanes reflection shader)\nfloat rtrace(vec3 ro, vec3 rd)\n{\n   \tfloat t = 0.0,dist;\n    for(int i=0; i<48; i++)\n    {\n     dist = map(ro + rd*t);\n     if(dist<0.0001 || t > 120.){break;}\n     t += dist;\n    }\n return t;   \n}\n\n//basic normal calculation \nvec3 normal(vec3 sp)\n{\n    //we swizzel a vec2 epsilon to get vec3\n    vec2 e = vec2(.0001, 0.0);\n    return normalize (\n    vec3(map(sp+e.xyy) - map(sp-e.xyy),\n         map(sp+e.yxy) - map(sp-e.yxy),\n         map(sp+e.yyx) - map(sp-e.yyx))\n    );\n}\n\n//ao from shane\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n//based on shanes lighting function\nvec3 lighting(vec3 sp, vec3 sn, vec3 lp, vec3 rd)\n{\n    vec3 color;\n    //vector from hit position to light position\n    vec3 lv = lp - sp;\n    //length of that vector\n    float ldist = max(length(lv), 0.001);\n    //direction of that vector\n    vec3 ldir = lv/ldist;\n    //attenuation\n    float atte = 1.0/(1.0 + 0.002*ldist*ldist );\n    //diffuse color\n    float diff = dot(ldir, sn);\n    //specular reflection\n    float spec = pow(max(dot(reflect(-ldir, sn), -rd), 0.0), 10.);\n    //fresnel\n    float fres = pow(max(dot(rd, sn) + 1., 0.0), 1.);\n\t//ambient occlusion\n    float ao = calculateAO(sp, sn);\n    //reflecton\n    vec3 refl = reflect(rd, sn);\n    //id for random tile color\n    float rndTile = rnd(floor(sp.xz));\n    //color options\n    vec3 color2 =vec3(rndTile*rndTile, .0, rndTile/90.);\n    //getting reflected and refracted color froma cubemap, only refl is used\n    vec4 reflColor = texture(iChannel0, refl);\n    //orage specular\n    vec3 hotSpec = vec3(0.9,0.5, 0.2);\n    //apply color options and add refl/refr options\n    color = (diff*color2 +  spec*hotSpec +reflColor.xyz*0.2 )*atte;\n    //apply ambient occlusion and return.\n    return color*ao;   \n}\n\n//rotation matrix\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) - a);\treturn mat2(v, -v.y, v.x); }\n\n//path from shane's abstract plane shader\nvec2 path(in float z){ float s = sin(z/36.)*cos(z/18.); return vec2(s*16., 0.); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    //fisheye\n\tuv = normalize(uv) * tan(asin(length(uv) * 1.));\n    \n\t// Camera Setup.\n\tvec3 lk = vec3(0, 3.7, iTime*6.);  \n    lk.xy += path(lk.z);\n\tvec3 ro = lk + vec3(0, .05, -.25); \n \tvec3 lp = ro + vec3(0, 3.75, 10);\n    \n    \n    //camera\n    float FOV = 1.57;\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt); \n    vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);    \n\trd.xy *= rot( path(lk.z).x/64. );\n\n    \n    //distance to closest hit\n    float t = trace(ro, rd);\n    //normalized distance\n    float far = smoothstep(0.0, 1.0, t/120.);\n    //hit point\n    vec3 sp = ro + rd*t;\n    //normal\n    vec3 sn = normal(sp);\n    \n    vec4 cubeColor = texture(iChannel0, rd);\n    //lighting\n    vec3 color = lighting(sp, sn, lp, rd);\n    //reflection based on shanes reflection shader\n    vec3 refRay = reflect(rd, sn);\n    \n    //trace reflection\n    float rt = rtrace(sp+sn*0.01, refRay);\n    //relection hit point\n    vec3 rsp = (sp+refRay*0.01) + refRay*rt;\n    //reflection surfact normal\n    vec3 rsn = normal(rsp);\n    //add reflection lighting\n    color += lighting(rsp, rsn, lp, refRay)*0.3;\n    \n    //accidental solar halo\n    vec3 sky = mix(vec3(0.9, 0.5, 0.2)*4., vec3(0.0)-0.4, pow(abs(rd.y), 1./3.))*(1./pow(abs(length(rd.xy)-0.4), 1./3.))/8.;\n    \n    //add cube color\n    sky += cubeColor.xyz*0.1;\n    color = mix(color, sky, far);\n    \n    //naive vignette\n    float vig = 1.0-smoothstep(1.0,3.5, length(uv));\n    color.xyz *= mix( 0.8, 1.0, vig);\n\n\tfragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//OldVersion\n\n/*\n#define SCALE 1.\n\nfloat rnd(vec2 p)\n{\n //return fract(sin(dot(p, vec2(13.234, 72.1849))*43251.1234));   \n return fract(sin(dot(p, vec2(13.234, 72.1849)))*43251.1234);    \n}\n\n//\nvec3 stripes(vec3 p)\n{\n    vec3 color;\n    \n  //makes a chess pattern\n    float zTo2 = fract(p.x/2.)*2.;\n    float negOTo1 = 1.0-fract(p.x);\n   float  oTo1 = fract(p.x);\n    float bw = floor( fract(p.z)*2.);\n    \t\n    float s = abs(((zTo2 + negOTo1) - bw ) -1.);\n    \n    //this was a weird experimental thing\n\n    //float s2 = smoothstep(0.45, 0.5, p.x);\n    color = vec3(s);\n return color;\n    \n}\n\n\n//not really used.\nfloat plane(vec3 p, vec4 n)\n{\n    \n return dot(p, n.xyz) + n.w;   \n}\n\nfloat roundBox(vec3 p, vec3 b, float r)\n{\n    \n return length(max(abs(p)-b,0.0))-r;   \n}\n\nmat2 rot(float a)\n{\n float cs = cos(a);\n    float si = sin(a);\n    \n    return mat2(cs, -si, si, cs);\n}\n\n\n//makes the dna strands\nfloat helix(vec3 p )\n{\n    vec2 id = floor(p.xz/20.-10.);\n    float idr = fract(sin(dot(floor(p.xz/20.-10.), vec2(12.23432, 73.24234)))*412343.2);\n     //p.xy*=rot(1./sin(idr));\n    //p.xz*=rot(.01);\n     \n    vec3 oldp = p;\n    float iz =floor(p.z);\n \tfloat ix =floor(p.x);\n   \n//if(iz > 0. && iz < 20.)\n    p.xz = mod(p.xz, 20.) -10.;\n    \n   // p.xy+=idr;\n   p.xz*=rot(p.y*3.14159/7.);\n   \t\n\t//p.xy*=rot(0.3);\n    \n    float cyl1 = length(p.xz + vec2(1.0,0.0)) - 0.2 ;\n    float cyl2 = length(p.xz - vec2(1.0, 0.0)) - 0.2 ;;\n    \n     p.y = mod(p.y,.4)-.2;\n    float bar = max(length(p.yz) - 0.07, abs(p.x) - .9) ;\n    \n\t\n\tfloat dna =  min(min(cyl1, bar), cyl2);\n\n    \n    return dna;\n}\n    \n//Map function is pretty simple I do a mod of rounded boxes on xz plane to make tiles\n//and add dna strands, and then return. I commented out some other experiments\nfloat map(vec3 p)\n{\n    \n float plane = plane(p, vec4(0.0, 1., 0.0, .9  ));//+stripes(p)/20.));\n    \n    \n    //these are options to deform the plane.\n   // p.y+=sin(p.x+sin(p.z))/5.+sin(p.z/2.+sin(p.z/9.)*10.)/20.;//+sin(p.z/3.)/4.;\n   // p.y+=(floor(abs(p.x))/1.);\n\n    \n    //I use a scale factor so I can change the size of the tiling with one variable defined at top.\n    float sca = SCALE;\n    \n    //this line does something interesting\n   //p.x += +sin(iTime*floor(p.y)/10.)*8.;\n    \n    //this line not so much\n   //p.y += +sin(iTime*floor(p.x)/100.)*8.;\n    \n    //height variable not used because changing the heights of blocks based on floor doesn't work out.\n    //it creates really bad aliasing and I'm not sure why just yet.\n    float height = sin(iTime*floor(p.x))*1.;\n    \n    \n\t vec3 fp;\n\n    fp.xyz = mod(p.xyz, 1./sca)-0.5/sca;\n  \n\n  //another option for height variation, also not used.\n  height = ((rnd(floor( p.xz/8.)))  )/10.;\n    \n    \n //creates the boxes\n float tiles = roundBox(vec3(fp.x, p.y, fp.z), \n                       vec3(0.47/sca, 0.47/sca, 0.47/sca), 0.019/sca);\n    \n //creates the dna\n float dna = helix(p);\n\n\n                        //vec3(0.43, 0.028+sin(p.z*0.3)/40.-cos(p.x*1.7)/60., 0.43), 0.0157);\n \n    \n//more not used stuff\n\n    \n  return min(tiles,dna); \n      \n}\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    float eps = 0.0001;\n    float dist;\n   \tfloat t = 0.0;\n    \n    for(int i=0; i<96; i++)\n    {\n     dist = map(ro + rd*t);\n        if(dist<eps || t > 120.)\n            break;\n        \n      t += dist*0.75;\n        \n    }\n    \n    \n return t;   \n}\n\n//based on shanes reflection tutorial\nfloat rtrace(vec3 ro, vec3 rd)\n{\n    float eps = 0.0001;\n    float dist;\n   \tfloat t = 0.0;\n    \n    for(int i=0; i<48; i++)\n    {\n     dist = map(ro + rd*t);\n        if(dist<eps || t > 120.)\n            break;\n        \n      t += dist;\n        \n    }\n    \n    \n return t;   \n}\n\n//can find explaination in my earlier shaders\nvec3 normal(vec3 sp)\n{\n    vec3 eps = vec3(.0001, 0.0, 0.0);\n    \n    vec3 normal = normalize (vec3( map(sp+eps) - map(sp-eps)\n                       ,map(sp+eps.yxz) - map(sp-eps.yxz)\n                       ,map(sp+eps.yzx) - map(sp-eps.yzx) ));\n    \n    \n return normal;   \n}\n\n//guess who this is from...shane\n// \"I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\"\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n//based on shanes lighting function but i added reflections using a cubemap\nvec3 lighting(vec3 sp, vec3 sn, vec3 lp, vec3 rd)\n{\nvec3 color;\n    \n    //some other experiemnts\n    //where the id's are based on cells you don't need to pass the id variable around\n    //you can just recreate it where needed.\n\n    \n    //vec3 tex = texture(iChannel0, sp.xz).xyz*one;\n    vec3 lv = lp - sp;\n    float ldist = max(length(lv), 0.001);\n    vec3 ldir = lv/ldist;\n    \n    float atte = 1.0/(1.0 + 0.002*ldist*ldist );\n    \n    float diff = dot(ldir, sn);\n    float spec = pow(max(dot(reflect(-ldir, sn), -rd), 0.0), 10.);\n    float fres = pow(max(dot(rd, sn) + 1., 0.0), 1.);\n\tfloat ao = calculateAO(sp, sn);\n    \n    vec3 refl = reflect(rd, sn);\n    vec3 refr = refract(rd, sn, 0.7);\n    \n    \n    vec3 str = stripes(sp);\n    vec3 chessFail = vec3(floor(mod(sp.z, 2.))+floor(mod(sp.x, 2.)));\n    float rndTile = rnd(floor(sp.xz*SCALE ));//+ iTime/10.);\n    \n    \n    //color options\n    vec3 color1 = vec3(rndTile*2., rndTile*rndTile, 0.1);\n    vec3 color2 =vec3(rndTile*rndTile, .0, rndTile/90.);\n    vec3 color3 =mix(vec3(0.9, 0., 0.), vec3(1.4), 1.0-floor(rndTile*2.));\n    \n    //getting reflected and refracted color froma cubemap, only refl is used\n    vec4 reflColor = texture(iChannel1, refl);\n    vec4 refrColor = texture(iChannel2, refr);\n     \n    //blue vs orage specular, orange all the way.\n    vec3 coolSpec = vec3(.3, 0.5, 0.9);\n    vec3 hotSpec = vec3(0.9,0.5, 0.2);\n   \n    \n    //apply color options and add refl/refr options\n    color = (diff*color2 +  spec*hotSpec +reflColor.xyz*0.2 )*atte;\n\t\n    \n    //apply ambient occlusion and return.\n return color*ao;   \n}\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) - a);\treturn mat2(v, -v.y, v.x); }\n\n//path from shane's abstract plane shader\nvec2 path(in float z){ float s = sin(z/36.)*cos(z/18.); return vec2(s*16., 0.); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv=uv*2.0-1.0;\n    \n    uv.x*=iResolution.x/iResolution.y;\n    \n    ///this way doesn't work for some reason..////////////////////\n    //it causes weird alliasing and doesn't look good.\n    vec3 ro = vec3(0.0, 4.0, -1.0+iTime*2.0); //*(sin(iTime)*0.5+0.5)\n    vec3 rd = vec3(uv.x, uv.y, 2.7);//*(sin(iTime)*0.5+0.5)\n    \n    vec3 lp =  ro + vec3(0., 1.2, 2.5);\n    \n    //////////////////////SO I USE THIS////////////////////////////////////////////////////////////\n    //which is from shanes abstract plane shader so it uses a pathand FOV and the basic camera \n    //variables fwd, up, and right. Shanes comments.\n    uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    //fisheye - Update 2021 06 17\n\tuv = normalize(uv) * tan(asin(length(uv) * 1.));\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 3.5, iTime*6.);  // \"Look At\" position.\n\t ro = lk + vec3(0, .25, -.25); // Camera position, doubling as the ray origin.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \t lp = ro + vec3(0, 3.75, 10);// Put it a bit in front of the camera.\n\t\n\t// Sending the camera, \"look at,\" and two light vectors across the plain. The \"path\" function is \n\t// synchronized with the distance function.\n\tlk.xy += path(lk.z);\n\tro.xy += path(ro.z);\n\tlp.xy += path(lp.z);\n\n    \tlk.y+=0.2;\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.57; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalizaztion is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy *= rot2( path(lk.z).x/64. );\n\n\n    /////////////////////////////////////////////////////////\n    \n    float t = trace(ro, rd);\n    vec3 sp = ro + rd*t;\n    vec3 sn = normal(sp);\n   \t\n    float far = smoothstep(0.0, 1.0, t/120.);\n    \n    //get cube color from cubemap again this time to apply to the sky,\n    //really just so that the reflections on the ground make sense\n    \n    vec4 cubeColor = texture(iChannel1, rd);\n    vec3 color = lighting(sp, sn, lp, rd);//mix(stripes(ro+rd*t),vec3(t), far);\n    \n    //reflection trace based on shanes reflection tutorial\n    vec3 refRay = reflect(rd, sn);\n    float rt = rtrace(sp+sn*0.01, refRay);\n    vec3 rsp = (sp+refRay*0.01) + refRay*rt;\n    vec3 rsn = normal(rsp);\n     color += lighting(rsp, rsn, lp, refRay)*0.3;\n    \n    //here i did this weird thing that resulted in an arc shape and I just kept it.\n    vec3 sky = mix(vec3(0.9, 0.5, 0.2)*4., vec3(0.0)-0.4, pow(abs(rd.y), 1./3.))*(1./pow(abs(length(rd.xy)-0.4), 1./3.))/8.;//-sin(atan(rd.y, rd.x)*20.+iTime*8.)/200., 1./5.));\n   // sky += (pow(length(rd.xy)-0.3+sin(atan(rd.y, rd.x)*20.+iTime*8.)/200., 1./3.));;//*vec3(0.1, 0.5, 0.9);\n   \n    float c = 1.0-smoothstep(0.1, 0.15,length(rd.xy)-0.01);\n    \n    \n    sky += cubeColor.xyz*0.1;// + c*vec3(0.2, 0.5, 0.9);\n    color = mix(color, sky, far);\n    \n    float vignette = 1.0-smoothstep(1.0,3.5, length(uv));\n    color.xyz *= mix( 0.8, 1.0, vignette);\n    \n    \n\tfragColor = vec4(color,1.0);\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}