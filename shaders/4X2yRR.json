{
    "Shader": {
        "info": {
            "date": "1726848888",
            "description": "originals  https://www.shadertoy.com/view/XlfGRj  https://www.shadertoy.com/view/dldyDX and other",
            "flags": 1,
            "hasliked": 0,
            "id": "4X2yRR",
            "likes": 1,
            "name": "cosmic creation",
            "published": 3,
            "tags": [
                "fractal",
                "stars",
                "universe"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 94
        },
        "renderpass": [
            {
                "code": "\n#define iterations 15\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n#define time iTime\n#define resolution iResolution.xy\nfloat cheap_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.01),sin(iTime*0.01),-sin(iTime*0.01),cos(iTime*0.01));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>1) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.025,1.);\t\n}\n\n// glslsandbox uniforms\n\n\n// shadertoy emulation\n#define time iTime\n\n// --------[ Original ShaderToy begins here ]---------- //\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*7.3+vec3(0,23,21))*.7+.7)\n#define R2 iResolution.xy\n#define PI 3.14159265358979\n#define N 12\n#define resolution iResolution.xy\n// https://www.shadertoy.com/view/4sfGzS\nfloat hash( ivec3 p )    // this hash is not production ready, please\n{                        // replace this by something better\n\n    // 3D -> 1D\n    int n = p.x*3 + p.y*113 + p.z*311;\n\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\nfloat noise( in vec3 x )\n{\n    ivec3 i = ivec3(floor(x));\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+ivec3(0,0,0)), \n                        hash(i+ivec3(1,0,0)),f.x),\n                   mix( hash(i+ivec3(0,1,0)), \n                        hash(i+ivec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+ivec3(0,0,1)), \n                        hash(i+ivec3(1,0,1)),f.x),\n                   mix( hash(i+ivec3(0,1,1)), \n                        hash(i+ivec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\nmat2 r(float a){ return mat2( cos(a), sin(a)*.9, -sin(a)*.9, cos(a));}\nvec2 r(vec2 p, float a) { return p*mat2(cos(a), sin(a), -sin(a), cos(a)); }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\nvec2 uPos = ( gl_FragCoord.xy / resolution.y );//normalize wrt y axis\n\tuPos -= vec2((resolution.x/resolution.y)/2.0, 0.5);//shift origin to center\n    vec2 u =fragCoord;\n\t vec2 R3 = iResolution.xy, U = ( u - .5*R3 ) / R3.x;//*.06;\n    vec4 O4=fragColor;\n    float d2=1., t3=0., T=iTime, i=t3, shape = 1.7;\n    \n\tvec3 p22 = -50.*vec3(.9*sin(T),0,cos(T)), q2,\n         n3 = normalize(p22),\n         X = vec3(n3.z,0,-n3),\n         Y = cross(X,n3),         \n         D = normalize( U.x*X + U.y*Y - n3*3. );\n         \n    for(O4-=O4; i<12. && d2>.02 && d2<32.; i++){\n        q2 = p22;\n        for( int i = 0; i++<8;){\n            q2.yz *= r(shape+sin(T)*.2); //shape\n            q2.xz *= r(1.); \n            q2.xz = abs(q2.xz) - .2; //scale\n            }\n        t3 += d2 = dot(sign(q2),q2)/1.;  \n        p22 += d2*D;\n        O4.rgb += mix(vec3(0.,.6,.9), vec3(1,0,1), length(p22)*.03 )/d2/64.;        \n    }\n\tfloat multiplier = 0.0005; // Grosseur\n\tconst float step = 0.006; //segmentation\n\tconst float loop = 80.0; //Longueur\n\tconst float timeSCale = 0.5; // Vitesse\n\t\n\tvec3 blueGodColor = vec3(0.0);\n\tfor(float i=1.0;i<loop;i++){\t\t\n\t\tfloat t = time*0.02*timeSCale-step*i*i;\n\t\tvec2 point = vec2(0.75*sin(t), 0.5*sin(t));\n\t\tpoint += vec2(0.75*cos(t*4.0), 0.5*sin(t*3.0));\n\t\tpoint /= 11. * sin(i);\n\t\tfloat componentColor= multiplier/((uPos.x-point.x)*(uPos.x-point.x) + (uPos.y-point.y)*(uPos.y-point.y))/i;\n\t\tblueGodColor += vec3(componentColor/3.0, componentColor/3.0, componentColor);\n\t}\n\tvec4 O = fragColor;\n    vec2 C =fragCoord;\n\t O-=O;\n    vec2 p2 = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n\tvec3 color1 = vec3(0.0, 0.3, 0.5);\n\tvec3 color2 = vec3(0.5, 0.0, 0.3);\n\t\n\tfloat f2 = 0.0;\n\tfloat g2 = 0.0;\n\tfloat h2 = 0.0;\n\n\tfor(float i = 0.0; i < 4.0; i++){\n\t\t\n\t\tfloat s2 = sin(time + i * PI / 2.0) * 0.8;\n\t\tfloat c2 = cos(time + i * PI / 2.0) * 0.8;\n\t\tfloat d2 = abs(p2.x + c2);\n\t\tfloat e2 = abs(p2.y + s2);\n\t\tf2 += 0.001 / d2;\n\t\tg2 += 0.001 / e2;\n\t\th2 += 0.00003 / (d2 * e2);\n\t}\n    \n    vec3 c23=vec3(f2 * color1 + g2 * color2 + vec3(h2));\n    \n     float lambda = time*2.5;\n  vec2 p3 = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n    float t =0.02/abs(tan(lambda) - length(p3));\n    float t2 = atan(p3.y, p3.x) + time;\n\n    vec2 something = vec2(1., (sin(time)+ 1.)*0.5);\n    \n    vec2 I =C;\n    vec4 O2 = fragColor;\n vec2 uv2 = I/R2;\n    vec2 p4 = (2.*I - R2) / R2.y * 1.5;\n    \n    float fp = pow(.5/length(pow(abs(r(p4,.43))\n        *vec2(2,1),vec2(.5))),4.5);\n       \n    p4 *= mat2(.7,-.5,-.4,1.2);    \n    vec3 pos = normalize(vec3(r(p4,-.4/length(p4)),.25));\n    pos.z -= iTime*2.;\n    \n    vec3 q = 6.*pos;\n    float f  = 0.5000*noise( q ); q = q*2.;\n          f += 0.2500*noise( q ); q = q*2.;\n          f += 0.1250*noise( q ); q = q*2.;\n          f += 0.0625*noise( q );\n    \n    vec2 n = uv2*(1.-uv2)*3.; float v = pow(n.x*n.y,.8);\n    \n    float fr = .6/length(p4);\n    f = smoothstep(-.4,2.,f*f) * fr*fr + fp;\n    \n    O2 = vec4(aces_tonemap(\n        pow(f*f * vec3(2., .05, 1.0)*v,vec3(.45))*3.5),0);\n    float dotProduct = dot(vec2(t),something)/length(p3);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));\n    float g=0.,e,s;\n    for(float i=0.;i<100.;++i)\n    {\n        p=g*d;\n        for(float i=0.;i<2.;i++){\n\t \n\t} \n        p.z-=.6;\n        p=R(p,normalize(vec3(i,1,10.)),i);\n           p=R(p,normalize(vec3(O4.x*O2.y,O4.y,10.)),iTime*.211);\n           \n        s=4.;\n        for(int j=0;j<7;++j)\n            p=abs(p),p=p.x<p.y?p.zxy:p.zyx,\n            s*=e=1.8/min(dot(p,p),1.2),\n            p=p*e-vec3(5,1.5,12.02+cos(time*0.01)/0.1096);\n        g+=e=length(p.xz)/s;\n        O.rgb+=mix(r/r,H(log(s)),.7)*.08*exp(-i*i*e);\n    }\n    O=pow(O,vec4(5));\n\n \n\tvec3 color = vec3(0,0,1.0);\n\tcolor += pow(blueGodColor,vec3(0.1,0.3,1.2));\n\t//mouse rotation\n\tfloat a1=.5+iMouse.x/iResolution.x*2.;\n\tfloat a2=.8+iMouse.y/iResolution.y*2.;\n\tvec4 o = fragColor;\n    vec2 F =fragCoord;\n vec2 R = iResolution.xy; \n    o-=o;\n    for(float d,t = iTime*.01, i = 0. ; i > -1.; i -= .06 )          \t\n    {   d = fract( i -3.*t );                                          \t\n        vec4 c = vec4( ( F - R *.5 ) / R.y *d ,i,0 ) * 28.;            \t\n        for (int j=0 ; j++ <20; )                                      \t\n            c.xzyw = abs( c / dot(c,c)                                 \t\n                    -vec4( 7.-.2*sin(t) , 6.3 , .7 , 1.-cos(t/.8))/7.);\t\n       o -= c * c.yzww  * d--*d  / vec4(3,5,1,1)*0.2;                 \n    }\n    \n   \n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n\n\n\n\tvec3 from=vec3(1.,.5,0.5)*O.xyz;\n\n\n\tfloat intensity = 0.7; // Bright effect\n\tvec2 offset = vec2(0 , 0); // x / y offset\n\tvec3 light_color = vec3(1, 0.5, 0.5); // RGB, proportional values, higher increases intensity\n\tfloat master_scale = 0.2 + 0.02*sin(time); // Change the size of the effect\n\tfloat c = pow(master_scale/(length(uv+offset)), -0.1*sin(time) + intensity);\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\n  fragColor+=O4*0.1;\n      fragColor+= vec4(cheap_star(uv, anim) * vec3(0.35,0.2,0.55)*0.05, 1.0);\n    \n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}