{
    "Shader": {
        "info": {
            "date": "1683855154",
            "description": "Sampling: Hold B to increase smoothness, N to decrease smoothness\nMoving: Arrow keys as well as W/S to move around camera\nCamera: Z/X to adjust focal distance, C/V to adjust aperature \nANGLES: 1/2, 3/4, 5/6\nJULIA: 7/8, 9/0, -/=\nSCALARS: R/F, T/G, Y/H,U/J\n",
            "flags": 48,
            "hasliked": 0,
            "id": "Dty3zh",
            "likes": 14,
            "name": "Interactive Fractal Folding!",
            "published": 3,
            "tags": [
                "mandelbulb",
                "dof",
                "pathtracing",
                "de",
                "rt",
                "mc"
            ],
            "usePreview": 0,
            "username": "ShelbyLynn",
            "viewed": 356
        },
        "renderpass": [
            {
                "code": "// for font https://www.shadertoy.com/view/stVBRR\n#define C(c) O += char(U,64+c).x ; U.x-=.5\n\n#define LF (U.y++)\n#define CR (U.x = (( uv.x - position.x)*64.0/FontSize))\n#define NL (CR,LF)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\n// --- display int4\n#if 0\nvec4 pInt(vec2 p, float n) {  // webGL2 variant with dynamic size\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ i%10 );\n    return v;\n}\n#else\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n#endif\n\n// --- display float4.4\nvec4 pFloat(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    float upper = floor(n);\n    float lower = fract(n)*1e4 + .5;  // mla fix for rounding lost decimals\n    if (lower >= 1e4) { lower -= 1e4; upper++; }\n    v += pInt(p,upper); p.x -= 2.;\n    v += char(p, 46);   p.x -= .5;\n    v += pInt(p,lower);\n    return v;\n}\n\nvoid mainImage( out vec4 O, in vec2 uv )\n{\n    \n    if (texelFetch(iChannel1, ivec2(3, 0), 0).r > 0. && 1. - (uv.y / iResolution.y) < 0.2) {\n        \n        //vec3 srgb = ;\n        //vec3 srgb = post_process(col / float(SAMPLES));\n        // Output to screen\n        O = vec4(0.,0.,0.,1.);\n\n    \n        uv /= iResolution.y;\n        float FontSize = 2.5;\n        vec2 position = vec2(0,1.0 - FontSize / 64.0);\n        vec2 U = ( uv - position)*64.0/FontSize;\n        NL;U.x-=.5;U.x-=.5;\n\n        C(3);C(1);C(13);U.x-=.5;C(24);U.x-=.5;\n            O +=   pFloat(U, texelFetch(iChannel1, ivec2(0, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(3);C(1);C(13);U.x-=.5;C(25);U.x-=.5;\n            O +=   pFloat(U, texelFetch(iChannel1, ivec2(1, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(3);C(1);C(13);U.x-=.5;C(26);U.x-=.5;\n            O +=   pFloat(U, texelFetch(iChannel1, ivec2(2, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(6);C(4);U.x-=.5;\n            O +=    pFloat(U, texelFetch(iChannel1, ivec2(5, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(1);C(16);C(20);U.x-=.5;\n            O +=    pFloat(U, texelFetch(iChannel1, ivec2(6, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(2);C(21);C(6);U.x-=.5;\n            O +=  pFloat(U, texelFetch(iChannel1, ivec2(7, 0), 0).r).xxxx;NL;U.x-=.5;U.x-=.5;\n        C(1);U.x-=.5;\n            O +=   pFloat(U, texelFetch(iChannel1, ivec2(8, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(2);U.x-=.5;\n            O +=    pFloat(U, texelFetch(iChannel1, ivec2(9, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(3);U.x-=.5;\n            O +=   pFloat(U, texelFetch(iChannel1, ivec2(10, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(4);U.x-=.5;\n            O +=  pFloat(U, texelFetch(iChannel1, ivec2(11, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(1);U.x-=.5;\n            O +=    pFloat(U, texelFetch(iChannel1, ivec2(12, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(2);U.x-=.5;\n            O +=    pFloat(U, texelFetch(iChannel1, ivec2(13, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(3);U.x-=.5;\n            O +=   pFloat(U, texelFetch(iChannel1, ivec2(14, 0), 0).r).xxxx;NL;U.x-=.5;U.x-=.5;\n        C(1);U.x-=.5;\n            O +=  pFloat(U, texelFetch(iChannel1, ivec2(15, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(2);U.x-=.5;\n            O +=   pFloat(U, texelFetch(iChannel1, ivec2(16, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(3);U.x-=.5;\n            O +=  pFloat(U, texelFetch(iChannel1, ivec2(17, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        O = vec4(O.xyz, 1.);\n            \n    } else {\n    vec4 col = texture(iChannel0, uv / iResolution.xy);\n        col /= col.w;\n        //vec3 srgb = ;\n        //vec3 srgb = post_process(col / float(SAMPLES));\n        // Output to screen\n        O = vec4(post_process(col.xyz),1.);\n    }\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 getCoord() {\n    return vec3(\n    \ttexelFetch(iChannel1, ivec2(0, 0), 0).r,\n        texelFetch(iChannel1, ivec2(1, 0), 0).r,\n        texelFetch(iChannel1, ivec2(2, 0), 0).r\n    );\n}\n\nvec2 getAngle() {\n    return vec2(\n    \ttexelFetch(iChannel1, ivec2(3, 0), 0).r,\n        texelFetch(iChannel1, ivec2(4, 0), 0).r\n    );\n}\n\nfloat getAperture() {\n    return (\n    \ttexelFetch(iChannel1, ivec2(6, 0), 0).r\n    );\n}\n\nfloat getFocal() {\n    return (\n    \ttexelFetch(iChannel1, ivec2(5, 0), 0).r\n    );\n}\n\n\n\n\nInputs getInputs() {\n    Inputs outputs;\n    outputs.a = vec4(\n    \ttexelFetch(iChannel1, ivec2(8, 0), 0).r,\n    \ttexelFetch(iChannel1, ivec2(9, 0), 0).r,\n    \ttexelFetch(iChannel1, ivec2(10, 0), 0).r,\n    \ttexelFetch(iChannel1, ivec2(11, 0), 0).r\n    );\n    outputs.b = vec3(\n        texelFetch(iChannel1, ivec2(12, 0), 0).r,\n    \ttexelFetch(iChannel1, ivec2(13, 0), 0).r,\n    \ttexelFetch(iChannel1, ivec2(14, 0), 0).r\n    );\n    outputs.j = vec3(\n        texelFetch(iChannel1, ivec2(15, 0), 0).r,\n    \ttexelFetch(iChannel1, ivec2(16, 0), 0).r,\n    \ttexelFetch(iChannel1, ivec2(17, 0), 0).r\n    );\n    return outputs;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint rand =  uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n    //float t = iMouse.x / iResolution.x * 2. - 1.;\n    vec2 mp = iMouse.xy / iResolution.xy;\n    //float t = ((1. - (iMouse.x / iResolution.x)) * 2. - 1.) * PI + PI_2;\n    float t = (iMouse.x / iResolution.x) * 6.;\n    float t2 = (iMouse.y / iResolution.y);\n    //vec3 ro = -mix(1.,1.2,t) * vec3(abs(cos(t)*cos(t)),mix(0.0,-0.1,t)-abs(sin(t) * sin(t)) * 0.5,1. + abs(sin(t) * sin(t)));\n    //vec3 o = 5. * vec3(mp.x,0.0,mp.y);\n    vec3 p = getCoord();\n    \n    //vec3 o = (t+1.) * vec3(-1.,0.,-1.);\n    \n    vec3 wu = vec3(0., 1., 0.);\n    //vec3 la = vec3(cos(t), t2 * 2. - 0.3 ,sin(t));\n    vec2 ang = getAngle();\n    //vec3 la = normalize(vec3(cos(ang.y)*sin(ang.x),sin(ang.y) * sin(ang.x),cos(ang.x)));\n    vec3 o = vec3(p.x,p.y,p.z);\n    vec3 la = (vec3(0.,0.0,0.));\n    vec3 cf = normalize(la - o);\n    vec3 cr = cross(wu, cf);\n    vec3 cu = cross(cf, cr);\n    \n    \n    \n    \n    vec3 col = vec3(0.);\n    int s = 0;\n    //vec4 old = texture(iChannel0, fragCoord / iResolution.xy);\n   //while (s < 1) {\n        vec2 offset = plastic(int(texture(iChannel0, fragCoord / iResolution.xy).w) + iFrame);\n        vec2 uv =  1.25*((fragCoord + 0.5 + offset)/iResolution.xy - 0.5);\n        uv.y *= iResolution.y / iResolution.x;\n        \n        vec3 sp =  cr * uv.x + cu * uv.y;\n        \n        float fd = (getFocal())*dot(normalize(sp +cf), cf);\n       // uv *= fd;\n        //sp =  cr * uv.x + cu * uv.y;\n        float apt_r =getAperture();\n\n        float r = fsqrt(random_float_01(rand)) * apt_r;\n        float theta = random_float_01(rand) * 2.f * PI;\n        //vec2 aps = vec2(0.);\n        //if (texelFetch(iChannel1, ivec2(7, 0), 0).r <= 0.9) {\n        //    aps = 2.*(plastic(int(texture(iChannel0, fragCoord / iResolution.xy).w)+ abs(int(hash(rand))%int(iFrameRate))+iFrame)-0.5) ;\n       // } else {\n        //    aps = 2.*(plastic(int(texture(iChannel0, fragCoord / iResolution.xy).w)+iFrame)-0.5);\n        //}\n        //vec2 ap = map_disk_lookup(aps) ;\n       // vec2 apt_o = apt_r * (ap.x)*vec2( cos(ap.y),sin(ap.y));\n        //if (fragCoord.y / iResolution.y > 0.5) {\n          vec2  apt_o = vec2(cos(theta),sin(theta)) * r;\n        //}\n        vec3 aperature = (cr * apt_o.x+cu * apt_o.y);\n\n        vec3 sensor =  (sp + cf * fd) ;\n\n        vec3 ro = sensor  + o + aperature;\n        vec3 rd = normalize( sensor - aperature  );  \n        \n        //col += skybox_test(ro, rd);\n        vec4 new_c = vec4(rt(getInputs(), rand, ro, rd) ,1.);\n       if (iMouse.z > 0. && iMouse.w > 0.) {\n           fragColor = new_c;\n        } else {\n        float s = texelFetch(iChannel1, ivec2(7, 0), 0).r;\n            fragColor = ( s*texture(iChannel0, fragCoord / iResolution.xy))+( new_c);\n        }\n        //s += 1;\n    //}\n    \n    // Output to screen\n    //fragColor = vec4(srgb,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define MAX_STEPS 64\n#define STOP_DIST 0.002\n#define NORM_SCALE 0.000001\n#define MAX_DIST 16.\n\n#define AO_STEPS 8\n#define AO_SCALE 0.1\n\n#define SHADOW_STEPS 32\n#define SHADOW_SOFT 5.\n\n#define BOUNCES 0\n#define ROUGHNESS 0.1\n#define SAMPLES 1\n\n#define EXPOSURE 4.4\n#define GAMMA 2.2\n\n#define PI   3.1415926535\n#define PI_2 1.5707963267\n\n// Set to 32 or higher for more clarity\n#define FOLD_STEPS 10\n\nfloat linear_rgb_c(float v) {\n  if (v <= 0.04045) {\n    return (v / 12.92);\n  }\n  else {\n    return pow((v + 0.005) / 1.055f, 2.4);\n  }\n}\n\nvec3 linear_rgb(vec3 rgba) {\n  return pow(rgba, vec3(2.2));\n}\n#define R_2_2 1.0f / 2.2f\nvec3 nonlinear_rgb(vec3 rgb) {\n    return pow(rgb, vec3(R_2_2));\n}\n\nvec3 rgb_to_xyz(vec3 rgba) {\n  vec3 srgb = linear_rgb(rgba);\n  return vec3(\n    dot(vec3(0.4124564, 0.3575761, 0.1804375), srgb),\n    dot(vec3(0.2126729, 0.7151522, 0.0721750), srgb),\n    dot(vec3(0.0193339, 0.1191920, 0.9503041), srgb));\n}\n\nvec3 xyz_to_rgb(vec3 xyz) {\n  return nonlinear_rgb(\n    vec3(dot(vec3(3.2404542, -1.5371385, -0.4985314), xyz),\n      dot(vec3(-0.9692660, 1.8760108, 0.0415560), xyz),\n      dot(vec3(0.0556434, -0.2040259, 1.0572252), xyz)));\n}\n\nstruct Inputs {\n    vec4 a;\n    vec3 b;\n    vec3 j;\n};\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat fsqrt(float x) {\n    float c = 1.41421356237;\n    float x0 = c * x;\n    float nx = 0.5*(x0 + (x / x0));\n    return 0.5*(nx + (x / nx));\n}\n\nfloat flength(vec3 p) {\n    float s = max(max(abs(p.x),abs(p.y)), abs(p.z));\n    vec3 np = p / s;\n    return fsqrt(dot(np,np)) * s;\n}\n\n\nfloat atan2(float y, float x) {\n    return atan(y / (x+0.000001)) + (PI_2*sign(y)*sign(x)*(sign(x) - 1.));\n}\n// 315, 45, 135, 225\n#define pi_7_4 PI * 7. / 4.\n#define pi_1_4 PI * 1. / 4.\n#define pi_3_4 PI * 3. / 4.\n#define pi_5_4 PI * 5. / 4.\nvec2 map_disk_lookup(vec2 p) {\n    float theta = atan2(p.y, p.x);\n    float radius = fsqrt(p.x * p.x + p.y * p.y);\n    if (pi_7_4 < theta && theta < pi_1_4) {   \n         return vec2(p.x,pi_1_4 * (p.y / p.x));\n    } else if (pi_1_4 < theta && theta <= pi_3_4) {\n         return vec2(p.y,pi_1_4 * (2. - (p.x / p.y)));\n    } else if (pi_3_4 < theta && theta <= pi_5_4) {\n         return vec2(-p.x,pi_1_4 * (4. + (p.y / p.x)));\n    } else {\n         return vec2(-p.y,pi_1_4 * (6. - (p.x / p.y)));\n    }\n}\n\nvec4 box_fold(vec4 z, float l) {\n    return vec4(clamp(z.xyz, -l, (l))* 2. - z.xyz, z.w) ;\n}\n\nvec4 ball_fold(vec4 z, vec2 m) {\n    float r2 = dot(z.xyz, z.xyz);\n    if (r2 < m.x) {\n        return z * m.y / m.x;\n    } else if (r2 < m.y) {\n        return z * m.y / r2;   \n    } else {\n        return z;\n    }\n}\n\nvec2 fold(vec2 p, float theta) {\n    vec2 n = vec2(cos(-theta), sin(-theta));\n    float v = min(0., dot(p, n));\n    return p - (2. * v * n);\n}\n\n\nvec3 fold3d(vec3 p, vec3 theta) {\n    vec3 np = p;\n    np.xy = fold(np.xy, theta.x);\n    np.xz = fold(np.xz, theta.y);\n    np.yz = fold(np.yz, theta.z);\n    return np;\n}\nvec4 menger(vec3 point, Inputs inputs) {\n    vec3  pos = point * 0.5 + 0.5;\n    //let ( x, y, z) = (pos.0,pos.1,pos.2);\n\n    float xx = abs(pos.x - 0.5) - 0.5;\n    float yy = abs(pos.y - 0.5) - 0.5;\n    float zz = abs(pos.z - 0.5) - 0.5;\n\n    float d1 = max(xx,max(yy,zz));\n    float d = d1;\n    float p = 1.;\n    \n    int i = 0;\n    int steps = 3;\n    while (i < steps) {\n        i += 1;\n        float xa = mod(3. * pos.x * p, 3.) ;\n        float ya = mod(3. * pos.y * p, 3.);\n        float za = mod(3. * pos.z * p, 3.);\n        p *= 3.;\n\n        xx = 0.5 - abs(xa - 1.5);\n        yy = 0.5 - abs(ya - 1.5); \n        zz = 0.5 - abs(za - 1.5);\n\n        d1 = min(max(xx,zz),min(max(xx,yy),max(yy,zz))) / p;\n        d = max(d,d1);\n        \n    }\n    \n    return vec4(1.,1.,1., d * 2.);\n}\n\nvec4 mandelbulb(vec3 p, Inputs inputs) {\n    vec3 c = p.xzy;\n    c.z = -c.z;\n    vec3 z = c;\n     //c = inputs.j;\n    int i = 0;\n    float r = 0.;\n    float dr = 1.;\n    float s = 0.;\n    while (i < 16) {\n        r = dot(z, z);\n        if (r > 16.) break;\n        r = fsqrt(r);\n        float theta = acos(z.z / r);\n        float phi = atan2(z.y, z.x);\n       float r2 = r * r;\n       float r4 = r2 * r2;\n        float r5 = r4 * r;\n        dr = r5*  6. * dr +1.;\n        float zr = r5 * r;\n        theta *= 6.;\n        phi *= 6.;\n        \n        z = zr * vec3(\n            sin(theta) * cos(phi),\n            sin(phi) * sin(theta),\n            cos(theta)\n        ) + c;\n        \n        //z = zr * vec3( cos(phi)*cos(theta), sin(theta), sin(phi) ) + c ;\n        \n        i += 1;\n        s += exp(-r);\n    }\n    r = length(z);\n    float theta = s * PI * 2.;\n    float red = (sin(theta) + 1.0) * 0.5;\n    float blu = (cos(theta) + 1.0) * 0.5;\n    float grn = (red + blu) * 0.5;\n    vec3 color =  clamp(vec3(red, grn, blu), 0.0, 1.0);\n    //color = vec3(1.);\n    return vec4(color, 0.25 * r * log(r) / abs(dr ));\n}\nvec4 mandelbox2(vec3 p, Inputs inputs) {\n    vec3 c = p;\n    vec3 last_z = vec3(0.);\n    vec4 z = vec4(c, 1.);\n    int counter = 0;\n    int min_period = 1;\n    int i = 0;\n    //vec3 point = vec3(0.);\n    float mn = 1000.;\n    float mx = -1000.;\n    float avg = 0.;\n    while (i < FOLD_STEPS) {\n    \n        z.xyz = fold3d(z.xyz, inputs.b * PI * 2.);\n        //z = box_fold(z, inputs.a.z);\n        z.xyz = clamp(z.xyz, -inputs.a.z, inputs.a.z)* 2. - z.xyz;\n        z = ball_fold(z, vec2(inputs.a.x, inputs.a.y));\n        //z.xyz = fold3d(z.xyz, inputs.b);\n        \n        //z = inputs.a.w * ball_fold(box_fold(z, inputs.a.z), vec2(inputs.a.x, inputs.a.y));\n        z.xyz = z.xyz * inputs.a.w + inputs.j;\n        z.w = abs(inputs.a.w) * z.w + 1.;\n        \n        //float nm = flength(z.xyz - c);\n        float nm = flength(c)/flength(z.xyz);\n        if (nm > mx) {mx = nm;}\n        if (nm < mn) {mn = nm;}\n        avg += nm;\n        i += 1;\n    }\n    avg /= float(i);\n    float m = length(z.xyz);\n    float x = m / abs(z.w);\n    //float x2 =  0.1 - abs( sdTorus(z.xyz, vec2(0.,1.1))) ;\n    //vec4 res = menger(0.25*z.xyz, inputs);\n    //return vec4(res.xyz,abs(res.w/z.w));\n    float v = (avg-mn) / (mx-mn);\n    float theta = 4. * v  * PI * 2.;\n    float red = (sin(theta) + 1.0) * 0.5;\n    float blu = (cos(theta) + 1.0) * 0.5;\n    float grn = (red + blu) * 0.5;\n    return vec4(red,grn,blu,x);\n}\n\n\n\nfloat de(vec3 p, Inputs inputs) {\n    return mandelbox2(p, inputs).w;\n}\n\nvec3 set_color(vec3 p, Inputs inputs) {\n    return rgb_to_xyz(mandelbox2(p, inputs).rgb);\n}\nfloat huh(float d) {\n//return STOP_DIST+STOP_DIST * (log(d+1.) / log(2.));// \nreturn STOP_DIST + max(0., 0.01*(1.-exp2(-(d)*0.01)));\n\n    //return STOP_DIST + STOP_DIST * (1. - (1. / (1.+exp(d*d))));\n    //return STOP_DIST * (1. - (1. / (1.+exp(d))));\n}\nfloat trace(Inputs inputs, int steps, float sd, vec3 ro, vec3 rd, vec3 co) {\n    float d = sd;\n    vec3 p = ro + (sd * rd);\n    int s = 0;\n    while (s < steps) {\n        p = ro + (d * rd);\n        float de = de(p, inputs);\n        d += de;\n        if (de < huh(length(p-co)) ) break;\n        if (d > MAX_DIST) break;\n        s+=1;\n    }\n    return d;\n}\n\n\nvec3 ortho(vec3 v)\n{\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)\n                               : vec3(0.0, -v.z, v.y);\n}\n\n\nvec3 calcNormal( Inputs inputs, float d, vec3 p) // for function f(p)\n{\n    const float h = NORM_SCALE; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*de( p + k.xyy*h, inputs ) + \n                      k.yyx*de( p + k.yyx*h, inputs ) + \n                      k.yxy*de( p + k.yxy*h, inputs ) + \n                      k.xxx*de( p + k.xxx*h, inputs ) );\n}\n\n\nvec3 norm(Inputs inputs, float d, vec3 p) {\n    return normalize(vec3(\n        de(p + vec3(STOP_DIST, 0.,0.), inputs),\n        de(p + vec3(0.,STOP_DIST, 0.), inputs),\n        de(p + vec3(0.,0., STOP_DIST), inputs)\n    ) - d );\n}\n\n// Wang hash\nuint hash(inout uint  state) {\n\tstate = (state ^ 61U) ^ (state >> 16U);\n\tstate = state * 9U;\n\tstate = state ^ (state >> 4);\n\tstate = state * 0x27d4eb2dU;\n\tstate = state ^ (state >> 15);\n\treturn state;\n}\n\nfloat random_float_01(inout uint  state) {\n    return float(hash(state)) / float(0xFFFFFFFFU);\n}\n\nvec3 sphere_rand(inout uint  state) {\n    float z = random_float_01(state) * 2. - 1.;\n    float theta = random_float_01(state) * 2. * PI;\n    float mu2sqrt = fsqrt(1. - (z * z));\n    return vec3(\n        mu2sqrt * cos(theta),\n        mu2sqrt * sin(theta),\n        z\n    );\n}\n\nfloat schlick(float ior, float theta) {\n    float coeff = (1. - ior) / (1. + ior);\n    coeff *= coeff;\n    return coeff + ((1.- coeff)*pow(1. - theta,5.));\n}\n\nfloat ao(Inputs inputs, int steps, float sd, vec3 ro, vec3 rd, vec3 co) {\n    float d = sd ;\n    int i = 0;\n    float mn = 0.;\n    float mx = 0.;\n    while (i < steps) {\n        vec3 p = ro + (rd * float(i + 1) * AO_SCALE);\n        float de = 0.125 * de(p, inputs);\n        float decay = 1. / pow(2.,float(i + 1));\n        mn += de *decay;\n        mx +=  float(i + 1) * AO_SCALE * decay ; \n        \n        i += 1;\n    }\n    return   clamp(mn/mx, 0., 1.);\n}\n\nfloat soft_shadow(Inputs inputs, int steps, float sd, vec3 ro, vec3 rd, vec3 co)\n{\n\tfloat res = 1.0;\n    float d = sd;\n    for( int i=SHADOW_STEPS; i>0; i-- )\n    {\n        vec3 p = ro + rd*d;\n\t\tfloat dist = de(p, inputs);\n        res = min( res, SHADOW_SOFT*dist/d );\n        d += dist;\n        if( res<huh(length(co - p))|| d>MAX_DIST ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n//https://iquilezles.org/articles/fog/\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float d, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0 - exp( -d*1. );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(1.0,0.9,0.7), // yellowish\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec3 skybox_test(vec3 ro, vec3 rd) {\n    vec3 sky_dir = normalize(vec3(0.0, 1., 0.));\n    vec3 sun_dir = normalize(vec3(0.0, 0., -1.));\n    \n    float grnrd = max(0., -dot(rd, sky_dir));\n    float skyrd = max(0., dot(rd, sky_dir));\n    float sunrd = max(0., dot(rd, sun_dir));\n    \n    vec3 bmax = vec3( 92., 151., 247.) / 255.;\n    vec3 bmin = pow(bmax, vec3(0.2)) / 3.;\n    \n    vec3 omax = vec3(207., 130., 6.) / 255.;\n    vec3 omin = omax;\n    \n    float sky_pow = pow(skyrd, 0.5);\n    float sun_pow = pow(sunrd, 1.);\n    \n    return \n    sky_pow * mix(5.*mix(omin, bmax, sky_pow ), 5.*mix(bmax, omax, sun_pow), sky_pow);\n    //mix(vec3(0.),\n        //mix(\n            \n            //pow((sun_pow ),8./(sky_pow) )\n        //), pow((sky_pow ), 0.75));\n}\nvec3 rt(Inputs inputs, inout uint rand, vec3 ro, vec3 rd) {\n    vec3 co = ro;\n    vec3 throughput = vec3(1.);\n    //vec3 il = vec3(0.);\n    float t = 1.;\n    vec3 lp = vec3(-t,t, -3.);\n    int b = 0;\n   \n    while (b < BOUNCES+1) {\n        float d = trace(inputs, MAX_STEPS, 0., ro, rd, co);\n        vec3 n = vec3(0.);\n        vec3 p = ro + (rd * d);\n        float tde = de(p, inputs);\n        float rough = ROUGHNESS;\n        float hh = huh(length(co-p));\n        vec3 nrd = rd;\n        if (tde <  hh*MAX_DIST) {\n            n = calcNormal(inputs, tde, p);\n            p += n * hh;\n            \n            vec3 ord = normalize(ro - p);\n            rough = (1. - rough) * mix(0., 1., schlick(1.5, max(0.,-dot(ord, n))));\n            vec3 sphere = sphere_rand(rand);\n            vec3 hemi = sphere * sign(dot(sphere, n));\n            vec3 ray_diff = normalize(hemi);\n            vec3 ray_spec = rd - (2. * n * dot(rd,n));\n            \n            nrd = normalize((1. -rough) * ray_diff + ( rough) * ray_spec);\n            \n            throughput *= pow(max(0., 1.0-acos(dot(nrd,n))/PI),4.);\n            \n            \n            vec3 color = mix(vec3(1.),set_color(p, inputs),1. -  rough);\n            #if (BOUNCES == 0)\n            float ao = ao(inputs, AO_STEPS, STOP_DIST, p, n, co);\n            float soft_shadow = soft_shadow(inputs, SHADOW_STEPS, STOP_DIST, p, nrd, co);\n            color *= soft_shadow;\n            color += 0.1 * vec3( ao);\n            #endif\n            throughput *= (color);\n            \n            //throughput *= mix(color*texture(iChannel0, n).w,vec3(texture(iChannel0, n).xyz),rough)   + 0.2 * ao * color;\n        } else {\n            break;\n        }\n        rd = nrd;\n        if (b > 2) {\n            float pp = max(max(throughput.x, throughput.y), throughput.z);\n            if (random_float_01(rand) > pp) {\n                break;\n            }\n            throughput *= 1. / pp;\n        }\n        ro = p;\n        \n        b+=1;\n    }\n    return throughput*rgb_to_xyz(skybox_test(ro, rd));\n    //return throughput;\n}\n\n#define ACES\n#define ACES_IN  mat3(vec3(0.59719f, 0.35458f, 0.04823f),vec3(0.07600f, 0.90834f, 0.01566f),vec3(0.02840f, 0.13383f, 0.83777f))\n#define ACES_OUT mat3(vec3(1.60475f,-0.53108f,-0.07367f),vec3(-0.10208f,1.10813f,-0.00605f),vec3(-0.00327f,-0.07276f,1.07602f))\nvec3 post_process(vec3 color) {\n    color *= EXPOSURE;\n    #ifdef REINHARDT\n    color = color / (1.f + color);\n    #endif\n    #ifdef EXP_TM\n    color = 1.f - exp2(-color*EXPOSURE);\n    color.xyz = mix(color.xyz, smoothstep(0.f,1.f, color.xyz), .7f);\n    #endif\n    #ifdef ACES\n    vec3 col = (color).xyz * ACES_IN;\n    vec3 a = col * (col + 0.0245786f) - 0.000090537f;\n    vec3 b = col * (0.983729f * col + 0.4329510f) + 0.238081f;\n    color = (a / b) * ACES_OUT;\n    #endif\n    return xyz_to_rgb(color);\n//  return xyz_to_rgb(1. - exp2(-color*EXPOSURE));\n}\n\nfloat tridist(float f) {\n    float o = f * 2. - 1.;\n    float v = o * fsqrt(abs(o));\n    v = max(v, -1.f);\n    return v - sign(o);\n}\nfloat fract_fr(float x) {\n    return x - floor(x);\n}\nvec2 plastic(int s)  {\n    float g = 1.324717957244f;\n    float a1 = 1.f / g;\n    float a2 = 1.f / (g * g);\n    return vec2(\n        tridist(fract_fr(0.5f + a1 * float(s + 1))),\n        tridist(fract_fr(0.5f + a2 * float(s + 1)))\n    );\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}  \n\nfloat plane_intersect(vec3 po, vec3 n, vec3 rd, vec3 ro) {\n    float denom = max(0., -dot(n, rd));\n    if (denom > 0.)\n    {\n        float t = max(0., -dot(po - ro, n)) / denom;\n        if (t >= 0.)\n        {\n            return t;\n        }\n    }\n    return 100.;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Camera pan LEFT/RIGHT\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\n// Camera pan FORWARD/BACK\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\n// Camera pan UP/DOWN\nconst int KEY_W  = 87;\nconst int KEY_S    = 83;\n\n\n// Focal Distance Up/Down\nconst int KEY_Z  = 90;\nconst int KEY_X = 88;\n// Aperature Size Up/Down\nconst int KEY_C  = 67;\nconst int KEY_V = 86;\n// Buffer Flow\nconst int KEY_B  = 66;\nconst int KEY_N = 78;\n\n\n// SCALAR A\nconst int KEY_R  = 82;\nconst int KEY_F = 70;\n// SCALAR B\nconst int KEY_T  = 84;\nconst int KEY_G = 71;\n// SCALAR C\nconst int KEY_Y  = 89;\nconst int KEY_H = 72;\n// SCALAR D\nconst int KEY_U  = 85;\nconst int KEY_J = 74;\n\n// ANGLE 1\nconst int KEY_1  = 49;\nconst int KEY_2 = 50;\n// ANGLE 2\nconst int KEY_3  = 51;\nconst int KEY_4 = 52;\n// ANGLE 3\nconst int KEY_5  = 53;\nconst int KEY_6 = 54;\n\n// JULIA 1\nconst int KEY_7  = 55;\nconst int KEY_8 = 56;\n// JULIA 2\nconst int KEY_9  = 57;\nconst int KEY_0 = 48;\n// JULIA 3\nconst int KEY_MNS  = 173;\nconst int KEY_EQS = 61;\n\nconst int KEY_SPACE = 32;\n\n\nconst float speed = 3.;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    float outData = 0.0;\n    float initData = 0.0;\n    \n    switch(int(fragCoord.x)) {\n        case 0:\n            // Camera X\n        \toutData = texelFetch(iChannel0, ivec2(0), 0).r +\n                (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).r -\n                (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).r;\n            initData =-4.7231;\n        \tbreak;\n        \n        case 1:\n            // Camera Y\n        \toutData = texelFetch(iChannel0, ivec2(1, 0), 0).r +\n                (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r -\n        \t\t(iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r;\n            initData = 1.2520;\n        \tbreak;\n        case 2:\n            // Camera Z\n            outData = texelFetch(iChannel0, ivec2(2, 0), 0).r +\n                    (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_W, 0), 0).r -\n                    (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_S, 0), 0).r;\n            initData = -4.2027;\n                break;\n        case 3:\n            if (texelFetch(iChannel1, ivec2(KEY_SPACE, 0), 0).r > 0.) {\n                outData = 1.;\n            } else {\n                outData = -1.;\n            }\n            initData = -1.;\n            break;\n        \n        case 5:\n            // Focal Distance\n            outData = texelFetch(iChannel0, ivec2(5, 0), 0).r +\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_Z, 0), 0).r -\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_X, 0), 0).r;\n           outData = max(0., outData);\n           initData = 1.9004;\n            break;\n        case 6:\n            // Aperature\n            outData = texelFetch(iChannel0, ivec2(6, 0), 0).r +\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_C, 0), 0).r -\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_V, 0), 0).r;\n            outData = max(0.000001, outData);\n            initData = 0.0201;\n            break;\n        case 7:\n            // Buffer Flow\n            outData = texelFetch(iChannel0, ivec2(7, 0), 0).r +\n                (iTimeDelta * 0.1) * texelFetch(iChannel1, ivec2(KEY_B, 0), 0).r -\n                (iTimeDelta * 0.1) * texelFetch(iChannel1, ivec2(KEY_N, 0), 0).r;\n            outData = clamp(outData, 0., 1.);\n            initData = 0.8;\n            break;\n        case 8:\n            outData = texelFetch(iChannel0, ivec2(8, 0), 0).r +\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_R, 0), 0).r -\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_F, 0), 0).r;\n            initData = 0.0;\n            break;\n        case 9:\n            outData = texelFetch(iChannel0, ivec2(9, 0), 0).r +\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_T, 0), 0).r -\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_G, 0), 0).r;\n            initData = 0.0;\n            break;\n        case 10:\n            outData = texelFetch(iChannel0, ivec2(10, 0), 0).r +\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_Y, 0), 0).r -\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_H, 0), 0).r;\n            initData = 0.35;\n            break;\n        case 11:\n            outData = texelFetch(iChannel0, ivec2(11, 0), 0).r +\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_U, 0), 0).r -\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_J, 0), 0).r;\n            initData = 2.25;\n            break;\n        case 12:\n            outData = texelFetch(iChannel0, ivec2(12, 0), 0).r +\n                (iTimeDelta * 0.1) * texelFetch(iChannel1, ivec2(KEY_1, 0), 0).r -\n                (iTimeDelta * 0.1) * texelFetch(iChannel1, ivec2(KEY_2, 0), 0).r;\n            initData =  0.07;\n            break;\n        case 13:\n            outData = texelFetch(iChannel0, ivec2(13, 0), 0).r +\n                (iTimeDelta * 0.1) * texelFetch(iChannel1, ivec2(KEY_3, 0), 0).r -\n                (iTimeDelta * 0.1) * texelFetch(iChannel1, ivec2(KEY_4, 0), 0).r;\n            initData =   0.33;\n            break;\n        case 14:\n            outData = texelFetch(iChannel0, ivec2(14, 0), 0).r +\n                (iTimeDelta * 0.1) * texelFetch(iChannel1, ivec2(KEY_5, 0), 0).r -\n                (iTimeDelta * 0.1) * texelFetch(iChannel1, ivec2(KEY_6, 0), 0).r;\n            initData =  -0.05;\n            break;\n        case 15:\n            outData = texelFetch(iChannel0, ivec2(15, 0), 0).r +\n                (iTimeDelta * 1.) * texelFetch(iChannel1, ivec2(KEY_7, 0), 0).r -\n                (iTimeDelta * 1.) * texelFetch(iChannel1, ivec2(KEY_8, 0), 0).r;\n            initData = 0.;\n            break;\n        case 16:\n            outData = texelFetch(iChannel0, ivec2(16, 0), 0).r +\n                (iTimeDelta * 1.) * texelFetch(iChannel1, ivec2(KEY_9, 0), 0).r -\n                (iTimeDelta * 1.) * texelFetch(iChannel1, ivec2(KEY_0, 0), 0).r;\n            initData = 1.75;\n            break;\n        case 17:\n            outData = texelFetch(iChannel0, ivec2(17, 0), 0).r +\n                (iTimeDelta * 1.) * texelFetch(iChannel1, ivec2(KEY_MNS, 0), 0).r -\n                (iTimeDelta * 1.) * texelFetch(iChannel1, ivec2(KEY_EQS, 0), 0).r;\n            initData = -1.5;\n            break;\n    }\n    if (iFrame > 0) {\n        fragColor = vec4(outData, 0.0, 0.0, 1.0);\n        \n    } else {\n        fragColor = vec4(initData, 0.0, 0.0, 1.0);\n    \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}