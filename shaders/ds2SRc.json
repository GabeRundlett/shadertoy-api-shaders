{
    "Shader": {
        "info": {
            "date": "1670667432",
            "description": "CC0: Max Drekker Triangles\n I liked Max's tweet: https://twitter.com/MaxDrekker/status/1601166513079484416?s=20&t=utQa4fiuhtOThlkZv7Rvig\n Simple and sweet.\n Inspired by the tweet I created this shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "ds2SRc",
            "likes": 17,
            "name": "Max Drekker Triangles",
            "published": 3,
            "tags": [
                "triangles",
                "twitter"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 494
        },
        "renderpass": [
            {
                "code": "// CC0: Max Drekker Triangles\n//  I liked Max's tweet: https://twitter.com/MaxDrekker/status/1601166513079484416?s=20&t=utQa4fiuhtOThlkZv7Rvig\n//  Simple and sweet.\n//  Inspired by the tweet I created this shader.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define SCA(a)      vec2(sin(a), cos(a))\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define LW          0.00666\n#define MOD         0.025\n#define MAX         20.0 \n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pref(inout vec2 p, vec2 r, float sm) {\n  float d = dot(p, r);\n  p -= r*pmin(0.0, d, sm)*2.0;\n  return d < 0.0 ? 0.0 : 1.0;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 dtri(vec2 p) {\n  const vec2 n = SCA(PI/3.0);\n  const float sm = 0.02;\n  vec2 p0 = p;\n  p0.y = -pabs(p0.y, sm);\n  pref(p0, n, 0.5*sm);\n  float n0 = mod1(p0.x, MOD);\n  float d0 = abs(p0.x)-(LW*n0/MAX);\n  float d = d0;\n  return vec2(d, n0);\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 2.0/RESOLUTION.y;\n  \n  vec3 col = vec3(0.025*smoothstep(2.0, 0.25, length(p-vec2(0.0, -0.2))));\n  const mat2 r =ROT(PI/6.0);\n  p -= vec2(0.15, -0.2);\n  p *= r;\n  vec3 bcol = vec3(1.0, 0.0, 0.25);\n  const vec2 off = vec2(4.0*MOD, 0.)+vec2(0.0, MOD/3.0)*r;\n  for (int i = 0; i < 3; ++i) {\n    bcol = bcol.yzx;\n    vec2 tp = p+off*float(i);\n    \n    vec2 d2 = dtri(tp);\n    vec3 tcol = bcol;\n    tcol *= smoothstep(0.0, MAX, d2.y);\n    tcol *= step(d2.y, MAX);\n    tcol *= smoothstep(aa, -aa, d2.x);\n    col += tcol;\n  }\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, pp);\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}