{
    "Shader": {
        "info": {
            "date": "1664225577",
            "description": "nothing interesting here !\nJust had to publish to help inspect a GLSL bug.\n\nThe real comparative shader was [url] https://shadertoy.com/view/NtcfDn [/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "7lyBRw",
            "likes": 4,
            "name": "3efficient poisson distribution",
            "published": 3,
            "tags": [
                "glsl",
                "bug"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 281
        },
        "renderpass": [
            {
                "code": "// DEBUG sub-part3 \"efficient poisson distribution\" by FabriceNeyret2. https://shadertoy.com/view/NtcfDn\n//#define sqrt(x) sqrt(max(x,0.))\n//#define log(x)  log(clamp(x,1e-9,1.))   // debug crash <><><>\n\n// top-left: Brute force distribution of all points is way too costly\n// bottom-right: smaller distrib or N=Poisson points per cell is equivalent but hugely cheaper ( as in Cell noise Workey paper: http://www.rhythmiccanvas.com/research/papers/worley.pdf )\n// top-right: fix density small distrib per cell is ok if the number of points per cell is big enough.\n//                                but for small density it lacks lacunarity. cf https://www.desmos.com/calculator/sjjo3qgnfp\n#define Z     min(0.,iTime)\n#define H(p)  fract(sin( (p) * vec2(12.9898, 78.233) ) * 43758.5453)\n#define H2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\n#define Poisson(n, seed)  Normal(n,sqrt(n),seed)               // approx valid for n not too small https://en.wikipedia.org/wiki/Poisson_distribution#Related_distributions\n#define Normal(m,s,seed)  m + s * Gauss(seed)\n#define Gauss(u)          sqrt(-2.*log(u.x)) * cos(6.283*u.y ) // takes u = rand2_uniform()\n\n#define D(seed,aa) O += max(0., 1.- R.y/3./aa * length( abs(U) - H(seed)*R/R.y ) ) // * H(seed+7.5).x // variant with varying intensity\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, I,\n          U = ( 2.*u - R ) / R.y;\n    float d = ( length(iMouse.xy)<20. ? .5+.5*sin(iTime) : iMouse.y/R.y ) * min(R.x*R.y, 1e6) / 100., // min(): debug Windows crash\n          S = 1.; // put 0 to use same seed in each cell\n    O-=O;  // if ( iTime<.1 || ( iTime >= 10. && iTime < 10.3 )) return; // debug Windows crash\n    if ( U.y < 0. ) \n       if ( U.x > 0. ) {\n            I = floor( U *= 8. ); U = fract(U);       // --- bottom right: accurate draw Poisson(Npix*d/64) points per cell\n            if (H2(I).x==0.) { O=vec4(1,0,0,1); return; };  // debug crash <><><>\n            d = Poisson(d/64., H2(I)) -.5;\n         // if( isnan(d) ) { O=vec4(1,0,0,1); return; };  // debug crash <><><>\n         // if( isnan(d) ) { O=vec4(0,1,0,1); return; };  // debug crash <><><>\n         // if( d > 1000.) { O=vec4(0,0,1,1); return;  }; // debug crash <><><>\n            for( float k=Z; k < d; k++ )\n                D( k - S*(7.7*I.x-13.3*I.y) , 8. );\n        }\n    O = sqrt(O);                                      // to sRGB\n    if ( int(u.x) == int(R.x)/2 || int(u.y) == int(R.y)/2 ) O = vec4(1,0,0,1);  // red separator \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}