{
    "Shader": {
        "info": {
            "date": "1696981800",
            "description": "Reproduction of this tweet by dave @beesandbombs \n\nhttps://twitter.com/beesandbombs/status/1376676133425590278",
            "flags": 0,
            "hasliked": 0,
            "id": "dd3fzN",
            "likes": 35,
            "name": "Peeling Squares (482 chars)",
            "published": 3,
            "tags": [
                "loop",
                "codegolf",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 371
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Reproduction of this tweet by Dave @beesandbombs \n//\n//  https://twitter.com/beesandbombs/status/1376676133425590278\n//\n//  To generate the correct order to animate the squares, I started with the code from\n//  elenzil's Ulam Spiral. However, I did apparently run into a bug...I had to add 2\n//  to the diagonal case, or else my squares animated out of order.\n//\n//  To speed it up, instead of iterating over all 81 squares, I only iterate over the\n//  25 squares crossing each quadrant. I feel like there's probably a way to render\n//  this with even fewer loops, although I think there has to be some because the squares\n//  cross each other's paths.\n//\n//  I tried golfing it, but please feel free to try to reduce the character count if you\n//  have any ideas!\n//\n// ---------------------------------------------------------------------------------------\n\n// From SnoopethDuckDuck: 482 chars!\n//*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    float t = fract(iTime * .13);\n    \n    vec2 R = iResolution.xy, \n         U = 20. * exp(-t * 2.2) * (R-u-u) / R.y - t / 22.,\n         v,\n         z = fract(U / 3.6 + .5) * 3.6 - 1.8,\n         w = sign(z);\n    \n    O = 0.*O;\n    \n    for (int x; x < 5; x++)\n    for (int y; y < 5; y++)\n    {\n        int I = x * int(w.x),\n            J = y * int(w.y),\n            K = 4*J*J,\n            L = 4*I*I,\n            m = I > 0 && I == -J     ? K - 4*J + 3 :     // squares diagonal - bottom right\n                I > 0 && I >= abs(J) ? L - 3*I + J + 1 : // right region\n                J > 0 && J >= abs(I) ? K - I - J + 1 :   // top region\n                I < 0 && J >= I      ? L - I - J + 1 :   // left region\n                                       K + I - 3*J + 3;  // bottom region\n\n        // inject for -2 (scary)\n        v = mix(v = vec2(I, J) * .1 - .05,\n                v * 4. + .15,\n                clamp(vec2(m) / 6. - 16. + 18.*t - length(U-z)/4., 0., 1.));\n                          \n        O += smoothstep(3./R.y, 0., length(max(abs(z-v)-.05, 0.)));\n    }\n}\n/**/\n\n// My golf attempt: 550 chars\n/*\n#define s(X) (X) * (X)\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    float t = fract(iTime * .13);\n    vec2 R = iResolution.xy, U = 40. * exp(-t * 2.2) * (.5 * R - u) / R.y - t / 22.,\n         v, z = fract(U / 3.6 + .5) * 3.6 - 1.8;\n    O = vec4(0);\n    \n    for (int y, x = 0; x < 5; x++)\n    for (y = 0; y < 5; y++)\n    {\n        ivec2 w = ivec2(x, y) * ivec2(sign(z));\n        int I = w.x,\n            J = w.y,\n            m = I > 0 && I == -J     ? s(1 - 2 * J) + 2 :         // squares diagonal - bottom right\n                I > 0 && I >= abs(J) ? s(2 * I - 1) + I + J :     // right region\n                J > 0 && J >= abs(I) ? s(2 * J - 1) + 3 * J - I : // top region\n                I < 0 && J >= I      ? s(-2 * I) - I - J + 1 :    // left region\n                                       s(-2 * J) + I - 3 * J + 3; // bottom region\n\n        v = mix(v = vec2(w) * .1 - .05,\n                          v * 4. + .15,\n                          clamp(float(m) / 6. - 16. + 18. * t - length(U - z) * .25, 0., 1.));\n                          \n        O += smoothstep(3. / R.y, 0.,\n                        length(max(v = abs(z - v) - .05, 0.)) +\n                               min(max(v.x,v.y), 0.));\n    }\n}\n/**/\n\n// Original: 797 chars\n/*\n#define R iResolution.xy\n\nint sqr(int x) { return x*x; }\n\n// from Ulam Spiral by elenzil\n// https://www.shadertoy.com/view/ssjBRm\nint ulam(int I, int J)\n{\n    int n = 0;\n        \n    // center\n    if (I == 0 && J == 0) {\n        n = 1;\n    }\n    // squares diagonal - bottom right\n    else if (I > 0 && I == -J) {\n        n = sqr((1 - 2 * J)) + 2;\n    }\n    // right region\n    else if (I > 0 && I >= abs(J)) {\n        n = sqr(2 * I - 1) + I + J;\n    }\n    // top region\n    else if (J > 0 && J >= abs(I)) {\n        n = sqr(2 * J - 1) + 3 * J - I;\n    }\n    // left region\n    else if (I < 0 && J >= I) {\n        n = sqr(-2 * I) - I - J + 1;\n    }\n    // bottom region\n    else {\n        n = sqr( - 2 * J) + I - 3 * J + 3;\n    }\n    \n    return n;\n}\n\nvoid mainImage(out vec4 O, vec2 U )\n{\n    float t = fract(float(iFrame) / 500.);\n    U = exp(-t * 2.2) * ((U - .5 * R) / R.y) - t * .0011;\n    float f = .045;\n    vec2 u = mod(U + f, vec2(f + f)) - f;\n    vec2 d = U - u;\n    float o = length(d);\n    u *= 40.;\n    \n    O = vec4(0);\n    \n    for (float x = 0.; x < 5.; x++)\n    for (float y = 0.; y < 5.; y++)\n    {\n        vec2 v = vec2(x, y) * sign(u) + 4.;\n        int m = ulam(4 - int(v.x), 4 - int(v.y));\n\n        float a = v == vec2(4) ? 0. : clamp(float(m) / 6. - 16. + 18. * t - o * 10., 0., 1.);\n        v = (v - 4.5) * .1;\n        v = mix(v, v * 4. + .15, a);\n        vec2 e = abs(u - v)-.05;\n        float d = length(max(e,0.0)) + min(max(e.x,e.y),0.0);\n        O += smoothstep(3./R.y, 0., d);\n    }\n}\n/**/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}