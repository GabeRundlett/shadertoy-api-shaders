{
    "Shader": {
        "info": {
            "date": "1714188081",
            "description": "Bresenham Line Algorithm Demo\n- Controls (For Desktop/Laptop only): \n  Left Mouse Button + hold on any pixel - drag to any pixel - mouse release.\n- Modify pixel resolution by updating \"pxRes\" variable in the code.",
            "flags": 0,
            "hasliked": 0,
            "id": "MfdSRj",
            "likes": 3,
            "name": "Bresenham's Line Algorithm",
            "published": 3,
            "tags": [
                "line",
                "rasterization",
                "algorithm",
                "bresenham"
            ],
            "usePreview": 0,
            "username": "isekai",
            "viewed": 244
        },
        "renderpass": [
            {
                "code": "/*\n\nAuthor: Pratik Dilip Dhende\nLinkedIn: https://www.linkedin.com/in/pratik-dhende/\n\nMIT License\n\nCopyright (c) 2024 Pratik Dilip Dhende\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n*/\n\nfloat sdCircle(vec2 p, float radius) {\n    return length(p - 0.5) - radius;\n}\n\nfloat plot(vec2 st, float fx, float border){\n    return smoothstep( fx-border*0.5, fx, st.y) - smoothstep( fx, fx+border*0.5, st.y);\n}\n\nvoid drawGrid(vec2 st, float border, inout vec3 col) {\n    col *= 1.0 - vec3(plot(st, 0.0, border*0.5));\n    col *= 1.0 - vec3(plot(st, 1.0, border*0.5));\n    \n    col *= 1.0 - vec3(plot(st.yx, 0.0, border*0.5));\n    col *= 1.0 - vec3(plot(st.yx, 1.0, border*0.5));\n}\n\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat bresenhamLow(vec2 s, vec2 e, vec2 px){\n    // Function needs delta.x >= 0\n    \n    vec2 delta = e - s;\n    \n    float incr = 1.0;\n    \n    if (delta.y < 0.0) {\n        delta.y = -delta.y;\n        incr = -1.0;\n    }\n    \n    float d = delta.x - 2.0*delta.y;\n    float y = s.y;\n    \n    for(float x = s.x; x <= e.x; x++){\n        if (length(px - vec2(x, y)) < 0.00001){\n            // Pixel = Bresenham line pixel\n            return 1.0;\n        }\n        if (d > 0.0){\n            d -= 2.0 * delta.y;\n        }\n        else{\n            y += incr;\n            d-= 2.0 * (delta.y - delta.x);\n        }\n    }\n    \n    return 0.0;\n}\n\nfloat bresenham(vec2 s, vec2 e, vec2 px) {    \n    vec2 delta = abs(e - s);\n    \n    if (delta.y > delta.x) {\n        // Slope > 1.\n        s = s.yx;\n        e = e.yx;\n        px = px.yx;\n    }\n    \n    // Makes sure delta.x >= 0.\n    if (e.x >= s.x) {\n        return bresenhamLow(s, e, px);\n    }\n    else {\n        return bresenhamLow(e, s, px);\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale between 0 and 1.\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 ms = iMouse.xy / iResolution.xy; // Current mouse position.\n    vec2 lms = abs(iMouse.zw) / iResolution.xy; // Last mouse click position.\n    \n    // Adjust for aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    ms.x *= aspectRatio;\n    lms.x *= aspectRatio;\n    \n    // Adjust this value to increase pixels in the grid.\n    float pxRes = 5.0;\n    \n    // Scale the space for tiling.\n    uv *= pxRes;\n    ms *= pxRes;\n    lms *= pxRes;\n    \n    // Get start, end and pixel positions for bresenham.\n    vec2 a = floor(lms) + 0.5;\n    vec2 b = floor(ms) + 0.5;\n    vec2 px = floor(uv) + 0.5;\n    \n    // Mask telling whether pixel belongs to bresenham line.\n    float bpx = bresenham(a, b, px);\n    \n    vec3 col = vec3(1.0);\n    \n    // Tile the space.\n    vec2 st = fract(uv);\n    \n    // Draw dot.\n    float dotRadius = 0.1;\n    float distDot = sdCircle(fract(st), dotRadius);\n    col *= vec3(smoothstep(0.0, 0.02, distDot));\n    \n    float borderResFactor = 397320.0 / (iResolution.x * iResolution.y);\n    float gridBorder = 0.015 * pxRes * borderResFactor;\n    float subGridBorder = 0.007 * pxRes * borderResFactor;\n\n    // Draw main grid.\n    drawGrid(st, max(0.006 * pxRes, min(0.018 * pxRes, gridBorder)), col);\n    // Draw sub-grid.\n    drawGrid(st - 0.5, max(0.007 * pxRes, min(0.014 * pxRes, subGridBorder)), col);\n    \n    // Highlight bresenham pixel.\n    col = mix(col, vec3(1.0 - bpx), 0.5 * bpx);\n    \n    // Draw line\n    vec3 lineColor = vec3(1.0, 1.0,0.0);\n    float lineTransparency = 0.9;\n    float lineRoundness = dotRadius * 0.01 * pxRes;\n    float d = distanceToSegment(a, b, uv) - lineRoundness;\n    col = mix( col, mix(col, lineColor, lineTransparency), 1.0-smoothstep(.01,0.01 + pxRes*0.002, d) );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}