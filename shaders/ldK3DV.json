{
    "Shader": {
        "info": {
            "date": "1456591392",
            "description": "The ultimate adventure.",
            "flags": 48,
            "hasliked": 0,
            "id": "ldK3DV",
            "likes": 76,
            "name": "Find the Restroom",
            "published": 3,
            "tags": [
                "game",
                "maze"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 8325
        },
        "renderpass": [
            {
                "code": "//Find the Restroom by eiffie based on Basic Maze Generator by stb https://www.shadertoy.com/view/XdKGWK\n//Just playing with different maze styles.\n\nconst vec2 MazeSize = 4. * vec2(16., 9.);\n\n#define rotateTo(p, a) mat2(a.y, a.x, -a.x, a.y) * p\nvec2 tx_cos(vec2 a){return abs(mod(a,4.0)-2.0)-1.0;}\nvec2 tx_cossin(float a){return tx_cos(vec2(a,a-1.0));}\n\nfloat drawWall(in vec2 p, vec2 dr) {\n    p = fract(rotateTo(p, dr)) - .5;\n    p.y = max(0., -p.y);\n    return length(p)-0.1;\n}\n\n#define t2D(o) textureLod(iChannel0, (o)/iResolution.xy, 0.0)\n//clamp(o,vec2(.5), MazeSize-.5)/iResolution.xy)\nfloat dot2(vec2 a){return dot(a,a);}\n#define eq2(a,b) (dot2(a-(b))<0.01)\nfloat RoundedIntersection(float a, float b, float r) {//modified from Mercury SDF http://mercury.sexy/hg_sdf/\n\treturn max(max(a,b),length(max(vec2(0.0),vec2(r+a,r+b)))-r);\n}\nfloat Round(float a, float b, float r){return max(min(a,b),r)-length(max(vec2(0.0),vec2(r-a,r-b)));}\n// From IQ's original 3D noise function. Ripped from Desert Canyon\nfloat noise3D(in vec3 p){\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);p -= ip;p = p*p*(3. - 2.*p);\n\tvec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h)*4375.5453), fract(sin(h + s.x)*4375.5453), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\nfloat ecyl(vec3 z, vec4 r){\n\tfloat f=length(z.xz*r.xy);\n\treturn length(max(vec2(abs(z.y)-r.w,f*(f-r.z)/length(z.xz*r.xy*r.xy)),0.0));\n}\nfloat smin(float a,float b,float k){float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);}\n\nconst mat2 rm1=mat2(0.5403,-0.8415,0.8415,0.5403);\nvec2 rts=vec2(0.0);\nvec3 st1;\nfloat DEP(vec3 z0){\n\tz0-=st1;\n\tz0*=20.0;\n\tz0.xz=rotate(z0.xz,rts.x+z0.y*rts.y/(1.0+length(z0.xz)));\n\tvec3 z=z0;z.y-=0.05;z.x=abs(z.x)-z.y*0.08;\n\tfloat d=ecyl(z,vec4(0.57,1.0,0.21,1.34))-0.48;//torso\n\tfloat x=abs(z0.x);\n\tz=vec3(x-0.6,z0.y+3.41,z0.z+0.12);\n\tfloat dl=ecyl(z,vec4(1.0,1.0,0.325,1.75))-0.23;//legs\n\tz=vec3(x-0.52,z0.y+1.32,z0.z+0.33);z.y*=0.8;\n\tfloat de=length(z)-0.6;//buns\n\tz=vec3(x-1.34,z0.y-0.85,z0.z+0.27);\n\tz.xy=z.xy*rm1;\n\tfloat da=ecyl(z.yxz,vec4(1.2,1.0,0.1-z.x*0.04,0.9))-0.17;//shoulders\n\tz.x-=0.95;\n\tfloat df=length(max(vec2(abs(z.y-0.82)-0.7-sin(z.x*50.0)*(z.y*0.01),length(z.xz)-0.02-abs(z.y-0.8)*0.05),0.0))-0.21;//forearm\n\tfloat dg=length(max(abs(z.xyz+vec3(0.22,-1.8,-0.05))-vec3(0.05,0.35,0.05),0.0))-0.05;//guns\n\tz=vec3(z0.x,z0.y-2.3,z0.z+0.14);\n\tfloat dn=length(max(vec2(abs(z.y)-0.5,length(z.xz)-0.1),0.0))-0.24;//neck\n\td=smin(min(min(d,df),dl),min(de,min(da,dn)),0.24-max(0.16-da-0.4*abs(z0.y-0.9),0.0));\n\tz.y+=-0.47;z.y*=0.79;\n\td=min(min(d,dg),length(z)-0.57);//head\n\treturn d*0.05;\n}\nfloat id=0.0;\nfloat DE(vec3 p0){\n\tfloat dgnd=p0.y+1.0,dtop=0.25-p0.y;\n\tvec2 p=p0.xz,fp=floor(p)+vec2(0.5);\n\tfloat wall=drawWall(p, t2D(fp).rg);\n\tfor(float i=0.0; i<4.0; i++){\n\t\tvec2 dr=tx_cossin(i),dr2=t2D(fp-dr).rg;\n       \tif eq2(dr, dr2) wall = min(wall, drawWall(p, -dr2));\n\t}\n\tdgnd=min(dgnd,Round(wall,dtop,0.4));//edIntersection\n\tid=wall;\n\tdtop=DEP(p0);\n\tif(dtop<dgnd){dgnd=dtop;id=-1.0;}\n\treturn min(dgnd,0.44);\n}\nvec2 brownConradyDistortion(vec2 uv)\n{//from meshula https://www.shadertoy.com/view/MlSXR3\n    // positive values of K1 give barrel distortion, negative give pincushion\n    //float barrelDistortion1 = 1.0; // K1 in text books\n    //float barrelDistortion2 = 1.0; // K2 in text books\n    float r2 = uv.x*uv.x + uv.y*uv.y;\n    //uv *= 1.0 + barrelDistortion1 * r2 + barrelDistortion2 * r2 * r2;\n    uv*=1.0+r2+r2*r2;\n    // tangential distortion (due to off center lens elements)\n    // is not modeled in this function, but if it was, the terms would go here\n    return uv;\n}\nfloat rnd,GoldenAngle;\nfloat rand(){return fract(rnd+=GoldenAngle);}\nvoid randomize(vec3 t){\n\tGoldenAngle=2.0-0.5*(1.0+sqrt(5.0));rnd=fract(sin(dot(t,vec3(13.13,117.17,43.34)))*4132.231);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\trandomize(vec3(fragCoord,iTime));\n\tvec2 uv=brownConradyDistortion((fragCoord-0.5*iResolution.xy)/iResolution.y);\n\tst1=texture(iChannel0,vec2(0.5,100.5)/iResolution.xy).rgb;\n\tvec4 st2=texture(iChannel0,vec2(1.5,100.5)/iResolution.xy);\n\trts=st2.xy;\n\tvec3 ro=vec3(0.125*sin(iTime*0.25),0.1,-0.15),rd=normalize(vec3(uv,0.5));\n\trd.yz=rotate(rd.yz,-0.1);\n\tro.xz=rotate(ro.xz,-st2.w);rd.xz=rotate(rd.xz,-st2.w);\n\tro+=st1;st1.y+=abs(cos(rts.y))*0.025;rts.y=sin(rts.y)*0.25;\n\tfloat t=0.0,d,od=1.0;\n\tfor(int i=0;i<64;i++){\n\t\tt+=d=DE(ro+rd*t);\n\t\tif(d<0.001 || t>20.0)break;\n\t\tod=d;\n\t}\n\tro+=rd*t;\n\tt=min(t,10.0);\n\tt/=10.0;\n\tvec3 col=vec3(0.1)*t;\n\tif(d<0.2){\n\t\tfloat dif=1.0-clamp(d/od,0.0,1.0);\n\t\tvec3 scol=vec3(1.0);\n\t\tif(id==-1.0){\n\t\t\tscol=vec3(0.9,0.6,0.3);\n\t\t\tro-=st1;\n\t\t\tro*=20.0;\n\t\t\tro.xz=rotate(ro.xz,rts.x+ro.y*rts.y/(1.0+length(ro.xz)));\n\t\t\tfloat f=abs(ro.x)+ro.y*0.3;\n\t\t\tfloat d2=min(max(abs(ro.y)-2.0,f-1.0),2.2-f);\n\t\t\tscol=mix(vec3(0.2),scol,smoothstep(0.0,0.05,d2));\n\t\t\tif(ro.y>2.175)scol*=noise3D(vec3(atan(ro.x,ro.z)*10.0,ro.y,0.0));\n\t\t\tscol*=dif;\n\t\t}else{\n\t\t\tdif*=(1.5+rd.y)*clamp(0.2+id*3.0+abs(ro.y+1.0)*10.0,0.0,1.0);\n\t\t\tscol=vec3(0.5);\n\t\t\tif(ro.y<-0.9){\n\t\t\t\tvec2 p=abs(fract((ro.xz+vec2(ro.z,-ro.x))*5.0)-0.5);\n\t\t\t\tdif*=2.0*(0.5+abs(min(p.x,p.y)-0.25)-0.01);\n\t\t\t\tscol.gb*=dif*vec2(1.2,1.4);\n\t\t\t}else if(ro.y<-0.185){\n\t\t\t\tvec3 p=abs(fract(ro*vec3(4.0,8.0,4.0))-0.5);\n\t\t\t\tdif*=1.0+clamp(3.0*min(p.x,min(p.y,p.z)),0.0,0.1);\n\t\t\t\tscol=vec3(0.5,0.45,0.4);\n            }else if(ro.y>0.24){\n                vec2 p=abs(fract(ro.xz)-0.5);\n                scol+=clamp(1.0-8.0*max(p.x,p.y),0.0,1.0);\n            }\n\t\t\tscol*=dif;\n\t\t\tscol+=col;\n\t\t}\n\t\tcol=mix(scol,col,t);\n\t}\n\tfragColor=vec4(col*(0.9+rand()*0.1),1.0);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//the maze code is from Basic Maze Generator by stb https://www.shadertoy.com/view/XdKGWK\n\n#define LONG_CORRIDORS\n#define ADD_ROOMS\n\n#define PI 3.14159265\n#define KEY_UP 38\n#define KEY_DOWN 40\n#define KEY_LEFT 37\n#define KEY_RIGHT 39\n#define KEY_R 82\n\nbool KeyDown(in int key){\n\treturn (texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x>0.0);\n}\n\nconst vec2 MazeSize = 4. * vec2(16., 9.);\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n#define rotateTo(p, a) mat2(a.y, a.x, -a.x, a.y) * p\nvec2 tx_cos(vec2 a){return abs(mod(a,4.0)-2.0)-1.0;}\nvec2 tx_cossin(float a){return tx_cos(vec2(a,a-1.0));}\n\nfloat drawWall(in vec2 p, vec2 dr) {\n    p = fract(rotateTo(p, dr)) - .5;\n    p.y = max(0., -p.y);\n    return length(p) - 0.15;\n}\n\n#define t2D(o) textureLod(iChannel0, (o)/iResolution.xy, 0.0)\n#define eq(a,b) (abs(a-b)<0.01)\nfloat dot2(vec2 a){return dot(a,a);}\nfloat sgn(float x){return (x<0.0?-1.:1.);}\n#define eq2(a,b) (dot2(a-(b))<0.01)\n\nfloat DE(vec2 p){\n\tvec2 fp=floor(p)+vec2(0.5);\n\tfloat wall=drawWall(p, t2D(fp).rg);\n\tfor(float i=0.0; i<4.0; i++){\n\t\tvec2 dr=tx_cossin(i),dr2=t2D(fp-dr).rg;\n       \tif eq2(dr, dr2) wall = min(wall, drawWall(p, -dr2));\n\t}\n\treturn wall;\n}\nvoid GoGoGo(inout vec4 st1, inout vec4 st2, float dt, float fw){\n\tvec3 dr=vec3(-sin(st2.x),cos(st2.x),0.0)*fw;\n\tvec2 p=st1.xz+dr.xy*0.1;\n\tfloat d=DE(p);\n\tif(d>0.15){\n\t\tst1.xz+=dr.xy*min(d,dt*2.0);\n\t\tst2.y+=dt*10.0;\n\t}else{//Dave's sliding trick works well here\n\t\tp=st1.xz+dr.xz*0.1;\n\t\td=DE(p);\n\t\tif(d>0.15){\n\t\t\tst1.xz+=dr.xz*min(d,dt*2.0);\n\t\t\tst2.y+=dt*10.0;\n\t\t}else{\n\t\t\tp=st1.xz+dr.zy*0.1;\n\t\t\td=DE(p);\n\t\t\tif(d>0.15){\n\t\t\t\tst1.xz+=dr.zy*min(d,dt*2.0);\n\t\t\t\tst2.y+=dt*10.0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if(iFrame<5){fragColor=vec4(0);return;}\n    vec4 st2=texture(iChannel0,vec2(1.5,100.5)/iResolution.xy);\n\tif(floor(fragCoord.y)==100.0 && fragCoord.x<2.0){//walking\n\t\tvec4 st1;\n\t\tif(iFrame==5|| KeyDown(KEY_R)){\n\t\t\tst1=vec4(1.1,-0.4,1.1,iTime);//pos,time\n\t\t\tst2=vec4(0.0,0.0,0.0,0.0);//dir,anim,frame,cam dir\n\t\t}else{\n\t\t\tst1=texture(iChannel0,vec2(0.5,100.5)/iResolution.xy);\n\t\t}\n\t\tfloat dt=iTime-st1.w;\n\t\t\n\t\tif(KeyDown(KEY_UP))GoGoGo(st1,st2,dt,1.0);\n\t\tif(KeyDown(KEY_DOWN))GoGoGo(st1,st2,dt,-1.0);\n\t\tif(KeyDown(KEY_LEFT))st2.x+=dt*2.0;\n\t\tif(KeyDown(KEY_RIGHT))st2.x-=dt*2.0;\n        if(iMouse.z>0.0)st2.x-=(iMouse.x-iMouse.z)*dt*0.02;\n\n        st2.z+=1.;\n\t\tst2.w+=(st2.x-st2.w)*min(dt*10.0,1.0);\n\t\tst1.w=iTime;\n\t\tfragColor=(fragCoord.x<1.0?st1:st2);\n\t\treturn;\n\t}\n\tif(fragCoord.y>MazeSize.y || fragCoord.x>MazeSize.x){fragColor=vec4(0.0);return;}\n\t\n    //maze by stb\n\t\n    vec2 fg = floor(fragCoord);\n\n    // saving a few chars\n    vec3 o = vec3(1., -1., 0.);\n    \n    // wall direction (will be stored)\n    vec2 wdir = o.zz;\n    \n    // initialize wall boundaries\n    if(iFrame==5 || KeyDown(KEY_R)) {\n        if(fg.y==0.)\n            wdir = o.xz;\n        if(fg.y==MazeSize.y-1.)\n            wdir = o.yz;\n        if(fg.x==0.)\n            wdir = o.zx;\n        if(fg.x==MazeSize.x-1.)\n            wdir = o.zy;\n        if(fg.x==MazeSize.x/2. && abs(fg.y-MazeSize.y/2.0)<MazeSize.y/4.0)\n            wdir = o.zx;\n    }\n    // create maze walls\n    else {\n\tfg+=vec2(0.5);\n        // this cell's stored wall direction, if any\n        wdir = t2D(fg).rg;\n        \n        // is this cell empty?\n        if(st2.z<1000. && dot2(wdir)<0.01)\n#ifdef ADD_ROOMS\n            if(length(abs(fg-0.5*MazeSize)-0.25*MazeSize)>3.0) \n#endif\n            {\n            \n            // a random, cardinal direction\n\t\t\tfloat a=floor(4.0*hash12(fg+mod(iDate.w/100., 100.)));\n\t\t\tvec2 r=tx_cossin(a);//i was trying diagonal walls... nope (eiffie)\n\n\t\t\t// if wall exists in direction r, make a new wall using that direction\n            if(dot2(t2D(fg+r).rg)>0.01)\n                //if(.5>dot(r, t2D(fg+r).rg))\n#ifdef LONG_CORRIDORS\n\t\t\t\tif(dot(r, t2D(fg+r).rg)>.5 || .9<hash12(-fg-mod(iTime/100., 100.)))\n#endif\n\t\t\t\t\twdir = r;\n        }\n    }\n    \n    // store wall direction\n    fragColor = vec4(wdir,0.0,0.0);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}