{
    "Shader": {
        "info": {
            "date": "1575710770",
            "description": "Messed around with cogwheels distance functions and applied it the IQ's Fractal Nyancat",
            "flags": 0,
            "hasliked": 0,
            "id": "3tc3zN",
            "likes": 33,
            "name": "Infinite cogwheels",
            "published": 3,
            "tags": [
                "2d",
                "julia"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 692
        },
        "renderpass": [
            {
                "code": "// Created by mrange/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Technique from: https://www.shadertoy.com/view/4slGWH\n\n// Messed around with cogwheels distance functions and applied it the IQ's Fractal Nyancat \n\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\nconst float cogRadius = 0.02;\nconst float smallWheelRadius = 0.30;\nconst float bigWheelRadius = 0.55;\nconst float wheelOffset = smallWheelRadius + bigWheelRadius -cogRadius;\nconst vec3 baseCol = vec3(240.0, 115.0, 51.0)/vec3(255.0);\n\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat unevenCapsule(vec2 p, float r1, float r2, float h) {\n  p.x = abs(p.x);\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(p,vec2(-b,a));\n  if( k < 0.0 ) return length(p) - r1;\n  if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n  return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(p.x*c + p.y*s, -p.x*s + p.y*c);\n}\n\nfloat softMin(float a, float b, float k) {\n  float res = exp( -k*a ) + exp( -k*b );\n  return -log( res )/k;\n}\n\nfloat smallCogwheel(vec2 p) {\n  rot(p, -iTime*2.0 + TAU/32.0);\n  vec2 op  = p;\n  float dc = circle(p, 0.25);  \n  vec2 pp = toPolar(p);\n  mod1(pp.y, TAU/16.0);\n  pp.y += PI/2.0;\n  vec2 cp = toRect(pp);\n  float ds = unevenCapsule(cp, 0.05, cogRadius, smallWheelRadius);\n  float dcw = softMin(ds, dc, 100.0);\n  float dic = circle(p, 0.125/2.0);\n  pp = toPolar(p);\n  mod1(pp.y, TAU/6.0);\n  vec2 ip = toRect(pp);\n  float dic2 = circle(ip - vec2(0.15, 0.0), 0.125/2.0);\n  float di = min(dic, dic2);\n  return max(dcw, -di);\n}\n\nfloat bigCogwheel(vec2 p) {\n  rot(p, iTime);\n  vec2 op  = p;\n  float dc = circle(p, 0.5);  \n  vec2 pp = toPolar(p);\n  mod1(pp.y, TAU/32.0);\n  pp.y += PI/2.0;\n  vec2 cp = toRect(pp);\n  float ds = unevenCapsule(cp, 0.1, cogRadius, bigWheelRadius);\n  float dcw = softMin(ds, dc, 100.0);\n  float dic = circle(p, 0.125);\n  pp = toPolar(p);\n  mod1(pp.y, TAU/6.0);\n  vec2 ip = toRect(pp);\n  float dic2 = circle(ip - vec2(0.3, 0.0), 0.125);\n  float di = min(dic, dic2);\n  return max(dcw, -di);\n}\n\nfloat cogwheels(vec2 p) {\n  p.x += wheelOffset*0.5;\n  float dsc = smallCogwheel(p - vec2(wheelOffset, 0.0));\n  float dbc = bigCogwheel(p);\n  return min(dsc, dbc);\n}\n\n\nfloat df(vec2 p) {\n  float i = modMirror1(p.x, wheelOffset);\n  float sy = mix(1.0, -1.0, mod(i, 2.0));\n  p.y *= sy;\n  float dcs = cogwheels(p);\n  return dcs;\n}\n\nvec4 sample_(vec2 p) {\n  const float borderStep = 0.001;\n  vec3 col = baseCol;  \n  p *= 4.0;\n  float d = df(p);\n  float t = smoothstep(-borderStep, 0.0, -d);\n  t *= exp(-dot(p, p)*0.005);\n  return vec4(col, t);\n}\n\nvec3 saturate(vec3 col) {\n  return clamp(col, 0.0, 1.0);\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)  {\n  col = saturate(col);\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n  p = vec2(0.5, -0.05) + p*0.75*pow(0.9, 20.0*(0.5+0.5*cos(0.3*sqrt(2.0)*iTime*sqrt(0.5))));\n\n  vec4 col = vec4(0.0);\n  vec3 ss = mix(vec3(0.2, 0.2, 0.5), vec3(0.2,-0.2,1.0), 2.2 + 1.25*sin(iTime*0.5));\n\n  vec2 c = vec2(-0.76, 0.15);\n  rot(c, 0.2*sin(iTime*sqrt(3.0)/12.0));\n  float f = 0.0;\n  vec2 z = p;\n\n  float transparency = 1.0;\n\n  vec3 bg = vec3(0.0);\n\n  float minTrap = 10000.0;\n\n  const int maxIter = 100;\n  const float maxIterF = float(maxIter);\n  for(int i=0; i<=maxIter; ++i)\n  {\n    if (transparency < 0.05) break;\n    float re2 = z.x*z.x;\n    float im2 = z.y*z.y;\n    if((re2 + im2>4.0) || (transparency<0.1)) break;\n    float reim = z.x*z.y;\n\n    z = vec2(re2 - im2, 2.0*reim) + c;\n    minTrap = min(minTrap, length(z - c));\n\n    float fi = f/maxIterF;\n    float shade = pow(1.0-0.5*fi, 1.5);\n\n    vec4 sample_ = sample_(ss.xy + ss.z*z);\n    float ff = mix(0.0, 0.5, pow(fi, 0.5));\n    sample_.xyz = pow(sample_.xyz, mix(vec3(1.0), vec3(75.0, 0.5, 0.0), ff));\n    sample_.xyz = mix(bg, sample_.xyz, shade);\n\n    transparency *= 1.0 - clamp(sample_.w, 0.0, 1.0);\n    vec4 newCol = vec4(col.xyz + sample_.xyz*(1.0 - col.w)*sample_.w, 1.0 - transparency);\n\n    col = newCol;\n    \n    f += 1.0;\n  }\n  \n  bg= vec3(0.3, 0.25, 0.4)*max(0.5 - sqrt(minTrap), 0.0);\n  col.xyz = mix(bg, col.xyz, col.w);\n  float fade = smoothstep(0.0, 3.0, iTime);\n  fragColor = vec4(fade*postProcess(col.xyz, q), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}