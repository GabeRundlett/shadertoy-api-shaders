{
    "Shader": {
        "info": {
            "date": "1475874012",
            "description": "The result of mapping an ellipse through a homography (2D perspective warp) is generally another ellipse. Note the center of the new ellipse (dark red) is not the same as the transformed center (green).",
            "flags": 0,
            "hasliked": 0,
            "id": "MlGGz3",
            "likes": 56,
            "name": "transforming ellipses",
            "published": 3,
            "tags": [
                "ellipse",
                "perspective",
                "homography"
            ],
            "usePreview": 0,
            "username": "mattz",
            "viewed": 25656
        },
        "renderpass": [
            {
                "code": "/* transforming ellipses, by mattz.\n   License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Demonstrates how to map an ellipse through a homography (2D perspective transform).\n   Implements math from https://en.wikipedia.org/wiki/Ellipse\n\n*/\n\n\n\n\n// Construct a 3x3 matrix for a 2D rotation \nmat3 rot(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(c, s, 0.0,\n                -s, c, 0.0,\n                0.0, 0.0, 1.0);\n}\n\n// Construct a 3x3 matrix for a 2D axis-aligned scale\nmat3 scale(vec2 s) {\n    return mat3(s.x, 0.0, 0.0,\n                0.0, s.y, 0.0,\n                0.0, 0.0, 1.0);\n}\n\n// Construct a 3x3 matrix for a 2D perspective distortion\nmat3 distort(vec2 k) {\n    return mat3(1.0, 0.0, k.x,\n                0.0, 1.0, k.y,\n                0.0, 0.0, 1.0);\n                \n}\n\n// Construct a 3x3 matrix for a 2D translation\nmat3 translate(vec2 t) {\n    return mat3(1.0, 0.0, 0.0,\n                0.0, 1.0, 0.0,\n                t.x, t.y, 1.0);\n}\n\n// Warp a point thru a homography \nvec2 warp(mat3 H, vec2 p) {\n    vec3 Hp = H * vec3(p, 1.0);\n    return Hp.xy / Hp.z;\n}\n\n\n// Convert matrix form of implicit conic parameters to canonical parameters:\n// center, semimajor/semiminor axis lengths, and principal axis direction.\nvoid gparams_from_conic(in mat3 M,\n                        out vec2 ctr,\n                       \tout vec2 ab, \n                       \tout vec2 axis) {\n    \n    float A = M[0][0];\n    float B = M[0][1]*2.0;\n    float C = M[1][1];\n    float D = M[0][2]*2.0;\n    float E = M[1][2]*2.0;\n    float F = M[2][2];\n    \n    float T = B*B - 4.0*A*C;\n    float S = A*E*E + B*B*F + C*D*D - B*D*E - 4.0*A*C*F;\n    float U = sqrt((A-C)*(A-C) + B*B);\n    \n    ab = sqrt(vec2(2.0*S*(A+C+U), 2.0*S*(A+C-U)))/T;\n    ctr = vec2(2.0*C*D - B*E, 2.0*A*E - B*D)/T;\n    axis = normalize(vec2(B, C-A-U));\n       \n}\n\n// Convert the other way from above function.\nmat3 conic_from_gparams(vec2 ctr,\n                        vec2 ab,\n                        vec2 axis) {\n    \n    float a = ab.x;\n    float b = ab.y;\n    float c = axis.x;\n    float s = axis.y;\n    float xc = ctr.x;\n    float yc = ctr.y;\n    \n    float A = a*a*s*s + b*b*c*c;\n    float B = 2.0*(b*b - a*a) * s * c;\n    float C = a*a*c*c + b*b*s*s;\n    float D = -2.0*A*xc - B*yc;\n    float E = -B*xc - 2.0*C*yc;\n    float F = A*xc*xc + B*xc*yc + C*yc*yc - a*a*b*b;\n    \n    return mat3(A, 0.5*B, 0.5*D,\n                0.5*B, C, 0.5*E,\n                0.5*D, 0.5*E, F);\n    \n}\n\n// Return distance of point uv from ellipse in implicit form.\nfloat ellipse_dist(vec2 uv, mat3 M) {\n    \n    vec3 uv1 = vec3(uv, 1.0);\n    \n    float k = dot(uv1, M * uv1);\n    \n    float dist = k / length(vec2(dFdx(k), dFdy(k)));\n    \n    return abs(dist)-0.5;\n    \n}\n\n// Return distance to line segment\nfloat seg_dist(vec2 ba, vec2 pa) {\n    float u = clamp(dot(ba,pa)/dot(ba,ba), 0.0, 1.0);\n    return length(pa-u*ba);\n}\n\n\n// Return distances to points in quadrilateral.\nfloat quad_dist(vec2 uv, vec2 p[5], float scl) {\n    \n    float d_quad = 1e5;\n    \n    for (int i=0; i<4; ++i) {\n        d_quad = min(d_quad, length(uv-p[i])/scl-3.0);\n        d_quad = min(d_quad, seg_dist(p[i+1]-p[i], uv-p[i])/scl-0.5);\n    }\n    \n    return d_quad;\n    \n}\n\n// Return grid distances\nvec2 grid_fract(vec2 x, vec2 i) {\n    return (fract(x/i+0.5)-0.5)*i;\n}\n\n// For mixing colors\nvec3 color_dist_mix(vec3 bg, vec3 fg, float dist, float alpha) {\n    float d = smoothstep(0.0, 0.75, dist); \n    return mix(bg, fg, alpha*(1.0-d));\n}\n\n\n// Do the things now.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Set up coordinate frame (4 units tall window, square pixels).\n\tvec2 uv = (fragCoord.xy + 0.5 - 0.5*iResolution.xy);\n    float scl = 4.0 / iResolution.y;\n    uv *= scl;\n    \n    // Construct a continuously changing homography.\n    float u = iTime;\n    \n    vec2 t = vec2(2.0*cos(0.17*u+0.32), sin(0.13*u+0.45));\n    vec2 k = vec2(0.4*cos(0.19*u+0.57), 0.3*sin(0.21*u+0.92));\n    vec2 s = 1.0 + vec2(0.5*cos(0.27*u+0.34), 0.3*sin(0.23*u+0.12));\n\tfloat a = 0.75*sin(0.07*u);\n    \n    mat3 H = translate(t) * distort(k) * rot(a) * scale(s);\n        \n    // Invert it\n    mat3 Hinv = inverse(H);\n    \n    // Construct a quadrilateral \n    vec2 p[5], Hp[5];\n    \n    p[0] = vec2(1.0, 0.5);\n    p[1] = vec2(-1.0, 0.5);\n    p[2] = vec2(-1.0, -0.5);\n    p[3] = vec2(1.0, -0.5);\n    p[4] = p[0];\n    \n    // Map it through the homography.\n    for (int i=0; i<5; ++i) {\n        Hp[i] = warp(H, p[i]);\n    }\n\n    // Set up our original ellipse\n    vec2 ctr = vec2(0), ab = p[0], axis = vec2(1.0, 0.0);\n    mat3 M = conic_from_gparams(ctr, ab, axis);\n    \n    // Warp ellipse through homography\n    mat3 M2 = transpose(Hinv) * M * Hinv;\n\n    // Get canonical params of warped ellipse\n    vec2 ctr2, ab2, axis2;\n    gparams_from_conic(M2, ctr2, ab2, axis2);\n    \n    //////////////////////////////////////////////////\n    // The rest is just drawing...\n\n    // Get distances to quadrilaterals.\n    float d_quad = quad_dist(uv, p, scl);\n    float d_quad2 = quad_dist(uv, Hp, scl);\n\n    // Sample points along both quadrilaterals\n    float d_stretch = 1e5;\n    \n    for (int i=0; i<32; ++i) {\n        float theta = float(i)*6.283185307179586/32.0;\n        vec2 v = vec2(cos(theta), sin(theta));\n        vec2 p0 = v * ab;\n        vec2 p1 = warp(H, p0);\n        d_stretch = min(d_stretch, seg_dist(p1-p0, uv-p0)/scl-0.5);\n    }\n    \n    // Green stuff\n    vec2 pcw = warp(H, ctr);\n    float d_pcw = length(uv-pcw)/scl-3.0;\n    d_pcw = min(d_pcw, seg_dist(Hp[0]-Hp[2], uv-Hp[2])/scl-0.5);\n    d_pcw = min(d_pcw, seg_dist(Hp[1]-Hp[3], uv-Hp[3])/scl-0.5);\n   \n    // Original ellipse & center\n    float d_ell = ellipse_dist(uv, M);\n    d_ell = min(d_ell, length(uv-ctr)/scl-3.0);\n    \n    // New ellipse & center\n    float d_ell2 = ellipse_dist(uv, M2);\n    d_ell2 = min(d_ell2, length(uv-ctr2)/scl-3.0);\n    \n    // Grid\n    vec2 grid = abs(grid_fract(uv, vec2(0.5)))/scl;\n    float d_grid = min(grid.x, grid.y);\n\n    vec3 color = vec3(1.0);\n    \n    color = color_dist_mix(color, vec3(0.8), d_grid, 1.0);\n    color = color_dist_mix(color, vec3(1.0, 0.7, 1.0), d_stretch, 0.2);\n    color = color_dist_mix(color, vec3(0.7, 0.7, 1.0), d_quad, 1.0);\n    color = color_dist_mix(color, vec3(1.0, 0.7, 0.7), d_ell, 1.0);\n    color = color_dist_mix(color, vec3(0, 0.7, 0), d_pcw, 0.5);\n    color = color_dist_mix(color, vec3(0, 0, 0.7), d_quad2, 1.0);\n    color = color_dist_mix(color, vec3(0.7, 0, 0), d_ell2, 1.0);\n    \n    fragColor = vec4(color, 1.0);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}