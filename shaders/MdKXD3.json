{
    "Shader": {
        "info": {
            "date": "1467572410",
            "description": "Make the code as small as you can while maintaining content equivalence (less than a 1% of different looking pixel are allowed to accommodate for precision errors. See [url]https://www.shadertoy.com/events/competition2016[/url] for more info.",
            "flags": 0,
            "hasliked": 0,
            "id": "MdKXD3",
            "likes": 14,
            "name": "[SH16A] Challenge",
            "published": 3,
            "tags": [
                "challenge",
                "sizecoding",
                "shadertoycompetition"
            ],
            "usePreview": 1,
            "username": "shadertoy",
            "viewed": 14268
        },
        "renderpass": [
            {
                "code": "float sdPlane( in vec3 p, in vec4 s )\n{\n\treturn p.y + s.w;\n}\n\nfloat sdSphere( in vec3 p, in float s )\n{\n    return sqrt(p.x*p.x+p.y*p.y+p.z*p.z)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nvec2 opU( in vec2 d1, in vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( sdPlane(pos,vec4(0.0,1.0,0.0,0.0)), 13.0 );\n\n    res = opU( res, vec2( sdSphere( pos-vec3(-2.0,0.40,-2.0), 0.40 ), 0.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3(-2.0,0.25,-1.0), 0.25 ), 0.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3(-2.0,0.40, 0.0), 0.40 ), 1.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3(-2.0,0.25, 1.0), 0.25 ), 1.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3(-2.0,0.40, 2.0), 0.40 ), 2.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3(-1.0,0.25,-2.0), 0.25 ), 2.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3(-1.0,0.40,-1.0), 0.40 ), 3.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3(-1.0,0.25, 0.0), 0.25 ), 3.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3(-1.0,0.40, 1.0), 0.40 ), 4.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3(-1.0,0.25, 2.0), 0.25 ), 4.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 0.0,0.40,-2.0), 0.40 ), 5.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 0.0,0.25,-1.0), 0.25 ), 5.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 0.0,0.40, 0.0), 0.40 ), 6.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 0.0,0.25, 1.0), 0.25 ), 6.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 0.0,0.40, 2.0), 0.40 ), 7.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 1.0,0.25,-2.0), 0.25 ), 7.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 1.0,0.40,-1.0), 0.40 ), 8.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 1.0,0.25, 0.0), 0.25 ), 8.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 1.0,0.40, 1.0), 0.40 ), 9.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 1.0,0.25, 2.0), 0.25 ), 9.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 2.0,0.40,-2.0), 0.40 ), 10.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 2.0,0.25,-1.0), 0.25 ), 10.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 2.0,0.40, 0.0), 0.40 ), 11.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 2.0,0.25, 1.0), 0.25 ), 11.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 2.0,0.40, 2.0), 0.40 ), 12.0 ) );\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n    float m = 0.0;\n    for( int i=0; i<=63; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<0.0 || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float t = mint;\n    for( int i=0; i<64; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<0.0 || t>tmax ) break;\n        t += res.x;\n    }\n\n    if( t>tmax ) return 1.0;\n    return 0.0;\n}\n\nfloat calcOcclusionArlo( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        float h = 0.005 + 0.25*float(i)/7.0;\n        vec3 dir = normalize( sin( float(i)*73.4 + vec3(0.0,2.1,4.2) ));\n        dir = normalize( nor + dir );\n        occ += (h-map( pos + h*dir ).x);\n    }\n    return clamp( 1.0 - 9.0*occ/8.0, 0.0, 1.0 );    \n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) + rd.y*vec3(0.8,0.8,0.8);\n    vec2 res = castRay(ro,rd, 0.0, 20.0);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3  pos = ro + t*rd;\n        vec3  nor = calcNormal( pos );\n        vec3  ref = reflect( rd, nor );\n        float ang = 5.0*atan( pos.x, pos.z );\n        float coa = cos(ang);\n\n             if( m< 0.5 ) col = vec3(1.00, 0.00, 0.00);\n        else if( m< 1.5 ) col = vec3(0.92, 0.03, 0.06);\n        else if( m< 2.5 ) col = vec3(0.84, 0.06, 0.12);\n        else if( m< 3.5 ) col = vec3(0.76, 0.09, 0.18);\n        else if( m< 4.5 ) col = vec3(0.68, 0.12, 0.24);\n        else if( m< 5.5 ) col = vec3(0.60, 0.15, 0.30);\n        else if( m< 6.5 ) col = vec3(0.52, 0.18, 0.36);\n        else if( m< 7.5 ) col = vec3(0.44, 0.21, 0.42);\n        else if( m< 8.5 ) col = vec3(0.36, 0.24, 0.48);\n        else if( m< 9.5 ) col = vec3(0.28, 0.27, 0.54);\n        else if( m<10.5 ) col = vec3(0.20, 0.30, 0.60);\n        else if( m<11.5 ) col = vec3(0.12, 0.33, 0.66);\n        else if( m<12.5 ) col = vec3(0.04, 0.36, 0.72);\n\t\telse \n        {\n            if( mod( mod(floor(pos.x),2.0) + mod(floor(pos.z),2.0), 2.0 ) < 0.5 )\n            {\n                col = vec3(0.4, 0.4, 0.4);\n            }\n            else\n            {\n                col = vec3(0.5, 0.5, 0.5);\n                vec2 uv = 256.0*0.1*pos.xz + vec2(37.0,17.0);\n            \tcol *= texture( iChannel0, (floor(uv)+ 0.5)/256.0, -100.0 ).y;\n            }\n\n            if( max( abs(pos.x), abs(pos.z)) < 1.5 )\n            {\n                vec2 q = mod(pos.xz+0.5,1.0)-0.5;\n                col *= smoothstep( 0.0, 0.5, sqrt(q.x*q.x+q.y*q.y) );\n            }\n\n            col *= pow(abs(tan(ang)*coa),2.0) + pow(abs(coa),2.0);\n        }\n        \n\n        // lighitng        \n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = 0.5+0.5*nor.y; if( amb<0.0 ) amb=0.0; else if( amb>1.0 ) amb=1.0;\n        float dif = dot( normalize(nor), lig ); if( dif<0.0 ) dif=0.0; else if( dif>1.0 ) dif=1.0;\n\t\tfloat spe = pow(clamp( dot(normalize(ref), lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= shadow( pos, lig, 0.01, 2.5 );\n\n\t\tvec3 lin = vec3(0.0, 0.0, 0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n        lin += 0.50*amb*vec3(0.50,0.70,1.00);\n\t\tcol = col*lin;\n\t\tcol += 1.0*spe*dif*vec3(1.0,1.0,1.0);\n    }\n\n\treturn col;\n}\n\nvec3 cross_product( in vec3 a, in vec3 b )\n{\n    return vec3( a.y*b.z - a.z*b.y,\n                -a.x*b.z + a.z*b.x,\n                 a.x*b.y - a.y*b.x );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross_product(cw,cp) );\n\tvec3 cv = normalize( cross_product(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n\tfloat time = 50.0;\n\n\t// camera\t\n\tvec3 ro = vec3( 3.0*cos(0.1*time), 2.0, 3.0*sin(0.1*time) );\n\tvec3 ta = vec3( 0.0, -0.2, 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 6.283185 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.5) );\n    \n    fragColor=vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}