{
    "Shader": {
        "info": {
            "date": "1604222968",
            "description": "mouse control 3D\n\n10 first steps of the crane origami ( indeed, common with many others).",
            "flags": 0,
            "hasliked": 0,
            "id": "ws3fRn",
            "likes": 7,
            "name": "origami tuto (first steps)",
            "published": 3,
            "tags": [
                "raytracing",
                "folding",
                "paper",
                "short",
                "origami",
                "origami",
                "crane"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 423
        },
        "renderpass": [
            {
                "code": "vec3 point[9];                                                            // list of points\nvec2    uv[9];                                                            // list of uv attributes\nivec3  tri[8];                                                            // list of triangle\n\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )                          // --- 2D rotation         \n\nmat3 rot3( vec3 v, float a )                                              // --- 3D rotation around axe\n{\n    v = normalize(v);\n    float s = sin(a), c = cos(a), ic = 1. - c;\n                                                 //    / cross( mat3(1) , v )\n    return mat3(c) + ic * outerProduct(v,v) - s * mat3(   0 ,  v.z, -v.y,\n                                                        -v.z,   0 ,  v.x,\n                                                         v.y, -v.x,   0    );\n//  return mat3( v.x*v.x*ic +   c  ,  v.y*v.x*ic - s*v.z,   v.z*v.x*ic + s*v.y,\n//               v.x*v.y*ic + s*v.z,  v.y*v.y*ic +   c  ,   v.z*v.y*ic - s*v.x,\n//               v.x*v.z*ic - s*v.y,  v.y*v.z*ic + s*v.x,   v.z*v.z*ic +   c    );\n}\n\n#define fan(p,n)  for( int k=0; k<n; k++ )       \\\n                      tri[k] = ivec3( p, L[k], L[(k+1)%8] );              // --- set triangles: fan around pivot p\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = mod(iTime, 17.) -2., \n          T = mod(t,2.)*1.4-.4; T = clamp( min(T,2.4-T), 0.,1.);  // ------ prepare geometry ------\n    int s; vec3 Z = vec3(0,0,1.4), P, m;\n    if (t<0.) T=0.;\n    if (t<7.) {                                                           // === phases 1.a-e ===\n        for( int k=0; k<9; k++ )                                          // --- set coordinates\n            s = sign(k-4), P = vec3( k%3-1, k/3-1, 0 ),\n            point[k] = t< 1. ? P * rot3( vec3(1, 1,0),-3.14*T*sign(P.y-P.x) ) // 1.ab: 2 diagonal pre-folds\n                     : t< 2. ? P * rot3( vec3(1,-1,0),-3.14*T*sign(P.y+P.x) )\n                     : t< 3. ? P * rot3( vec3(0,-1,0), 3.14*T* P.x )          // 1.cd: 2 median pre-folds\n                     : t< 4. ? P * rot3( vec3(1, 0,0), 3.14*T* P.y )          \n                     : mix( P,                                            // init pos\n                            k==4 ? vec3(0) : k%2<1 ? Z : .5*vec3(s,s,1.4),// folds-collapse pos\n                            T ),                                          // 1.e: morphing between those.\n            uv[k] = abs(P.xy);                                            // uv attribute\n        int L[8] = int[]( 0,1,2, 5, 8,7,6, 3 );                           // fan indices\n        fan(4,8);                                                         // --- set triangles\n    } \n      else {                                                              // === phase 2.ab ===\n        if (t>13.) T=1.;\n        for( int k=0; k<9; k++ )                                          // --- set coordinates\n            s = sign(k-4), P = .5*vec3(s,s,1.4), m = P*.59, // 2-sqrt2 \n            P = k==0||k==8 ? m : k==4 ? vec3(0) : k%2<1 ? Z : P,          // init pos\n            s = sign(abs(k-4)-2),\n            point[k] = t < 10. ? k%2 < 1 ? P\n                                 : Z + ( P - Z )  * rot3(  m - Z  , 3.14*(1.-T) * float(s) ) // 2.a: rotation around 4 side folds\n                               : k == 4  ? m  - m * rot3( vec3(1,1,0), -3.1*T ) // 2.b: rotation around top fold\n                                 : k%2 < 1 ? P : vec3( 0, .001*float(s), m.z ),\n            uv[k] = abs( vec2(-P.x,P.z*.7) * mat2(1,-1,1,1) );            // uv attribute\n        int L[7] = int []( 1, 3,0,4,8,7, 5 );                             // fan indices\n        fan(6,6);                                                         // --- set triangles\n        tri[0].z = 0; tri[5].y = 8;                                       // fix 2 rear wings\n        tri[2].z = 8; tri[3].x = 0;                                       // swap faces to allow 2.b rotation\n    }\n                                                                  // ------ ray-trace geometry ------\n    vec3  R = iResolution,\n          M = ( length(iMouse.xy) > 10. ? iMouse.xyz/R -.5\n                                        : vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0))-.3\n              ) * -6. ,\n          D = normalize(vec3( U+U, -5.*R.y ) - R ),                       // ray direction\n          p = vec3(0,-.5,5), F,r, A,B,C;   \n    D.yz *= rot(M.y),   p.yz *= rot(M.y),                                 // camera rotations\n    D.xy *= rot(M.x),   p.xy *= rot(M.x);\n\n    int f=-1; float z=99.; // ,S, s=1.;\n // for( ; s > -2.; s-=2., D.xy*=s, p.xy*=s ) {                           // add symmetric shape\n    for ( int k=0; k<8; k++ ) {                                           // --- test all triangles for intersection\n        ivec3 T = tri[k];\n        A = point[T.x], B = point[T.y], C = point[T.z];\n        r = inverse(mat3(B-A,C-A,-D)) * ( p-A );                          // intersection r = (u,v,z)\n        if ( r.z>0. && r.x>0. && r.x <1. && r.y>0. && r.y <1. && r.x+r.y < 1. ) // hit \n            if (r.z < z ) z = r.z, F=r, f=k; //, S=s;                           // get closest\n    } //}\n\n    O -= O;\n    if (z < 99.) {                                                        // --- hit: compute pixel color\n        ivec3 T = tri[f];\n        A = point[T.x], B = point[T.y], C = point[T.z];\n        U = uv[T.x]*(1.-F.x-F.y) + F.x * uv[T.y] + F.y * uv[T.z];         // reconstruct uv attribute\n        O = texture(iChannel0, U )                                        // texturing\n           * ( .5 + abs( dot( normalize(cross(B-A,C-A)), vec3(0,1,2))) ); // Lambert shading\n    }                                                   //      S\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}