{
    "Shader": {
        "info": {
            "date": "1712311244",
            "description": "landscape go vrouuum",
            "flags": 32,
            "hasliked": 0,
            "id": "lcdGzl",
            "likes": 1,
            "name": "finalhomework-2024",
            "published": 3,
            "tags": [
                "newlandscape"
            ],
            "usePreview": 1,
            "username": "leborgnekevin",
            "viewed": 133
        },
        "renderpass": [
            {
                "code": "float PI = 3.14;\nvec3 ro = vec3(0, -21., -2.);                                          // ray origin that represents camera position\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(vec3(1, 0, 0), vec3(0, c, -s), vec3(0, s, c));\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(vec3(c, 0, s), vec3(0, 1, 0), vec3(-s, 0, c));\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(vec3(c, -s, 0), vec3(s, c, 0), vec3(0, 0, 1));\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1));\n}\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.004;\nconst float EPSILON = 0.005;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nvec2 hash22b(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return 2.0 * fract((p3.xx + p3.yz) * p3.zy) - 1.0;\n}\n\nfloat noise(vec2 p) {\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n\n    float a = dot(hash22b(ip + vec2(0, 0)), fp - vec2(0, 0));\n    float b = dot(hash22b(ip + vec2(1, 0)), fp - vec2(1, 0));\n    float c = dot(hash22b(ip + vec2(0, 1)), fp - vec2(0, 1));\n    float d = dot(hash22b(ip + vec2(1, 1)), fp - vec2(1, 1));\n\n    vec2 t = smoothstep(vec2(0), vec2(1), fp);\n    float res = mix(mix(a, b, t.x), mix(c, d, t.x), t.y);\n    return 0.5 + 0.5 * res;\n}\n\nfloat fbm(vec2 p) {\n    float res = 0.0;\n    float amp = 0.9;\n    float freq = 0.9;\n    for(int i = 0; i < 10; ++i) {\n        res += amp * noise(freq * p);\n        amp /= 2.0;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nSurface sdFloor(vec3 p) {\n    vec3 col;\n    float d = p.y + 2.;\n\n    // Add some noise\n    d += 2. * fbm(p.xz * 0.5);\n    d += 15. * fbm(p.xz * 0.08);\n    d += 15. * fbm(p.xz * 0.08);\n    float height = p.y + 2. + 2. * fbm(p.xz * 0.5);\n    \n\n    //the sunset effect\n    if (height > -25. && (length(p - ro) >=30.0 )) {\n        // Color gradient: make a gradient color based on the height of the floor from red to orange \n        vec3 gradientColor = mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 0.5, 0.0), smoothstep(-25., -20., height));\n        \n        // Texture blending factor: blend the texture with the gradient color smoothly\n        float textureBlend = smoothstep(-25., -20., height);\n\n        // Use texture from iChannel0\n        vec4 textureColor = texture(iChannel0, p.xz * 0.1); // Adjust texture coordinate as needed\n        \n        // Darken the texture color\n        textureColor.rgb *= 0.5;\n\n        // Blend the texture color with the gradient color\n        col = mix(gradientColor, textureColor.rgb, textureBlend);\n        \n        \n        \n        \n     //add the floor texture   \n    } else if (length(p - ro) < 30.0) { // Check if the distance from the point to the camera is less than 30 units\n        // Use texture from iChannel0\n        vec4 textureColor = texture(iChannel0, p.xz * 0.1); // Adjust texture coordinate as needed\n        \n        // Darken the texture color\n        textureColor.rgb *= 0.6;\n\n        col = textureColor.rgb;\n    }\n\n    return Surface(d, col);\n}\n\nSurface sdSea(vec3 p, vec3 col) {\n    float d = p.y + 18.0;\n    d += 0.003 * sin(10.0 * p.x + iTime) * cos(10.0 * p.z + iTime) + 0.14;\n    col = vec3(0.0, 0.0, 0.7);\n    return Surface(d, col);\n\n}\n\n\n\nSurface sdSphere(vec3 p, float r, vec3 offset, vec3 col) {\n    p = (p - offset);\n    float d = length(p) - r;\n    return Surface(d, col);\n}\n\nSurface sdPandora(vec3 p, float r, vec3 offset, vec3 col) {\n    p = (p - offset);\n    float d = length(p) - r;\n    // Calculate the texture coordinates based on the 3D position of p\n    vec2 texCoord = vec2(atan(p.z, p.x) / (2.0 * PI) + 0.5, asin(p.y / r) / PI + 0.5);\n    vec4 texColor = texture(iChannel2, texCoord); // Sample the texture\n    col = texColor.rgb;\n    return Surface(d, col);\n}\n\nSurface sdlittleBlue(vec3 p, float r, vec3 offset, vec3 col) {\n    p = (p - offset);\n    float d = length(p) - r;\n    // Calculate the texture coordinates based on the 3D position of p\n    vec2 texCoord = vec2(atan(p.z, p.x) / (2.0 * PI) + 0.5, asin(p.y / r) / PI + 0.5);\n    vec4 texColor = texture(iChannel3, texCoord); // Sample the texture\n    col = texColor.rgb;\n    return Surface(d, col);\n}\n\n\n\nSurface opUnion(Surface obj1, Surface obj2) {\n    if(obj2.sd < obj1.sd)\n        return obj2;\n    return obj1;\n}\n\nSurface scene(vec3 p) {\n\n    Surface floor = sdFloor(p + vec3(0., -4., 0.)); // Floor\n    Surface sea = sdSea(p + vec3(0., 10., 0.), vec3(0.0, 0.0, 0.5)); // Sea\n\n    // Combine the floor and sea surfaces\n    Surface combinedSurface = opUnion(floor, sea);\n\n    // Add the Pandora sphere\n    float t = iTime / 3.; // Timer\n    vec3 sphereOffset = vec3(-5.0 + 30.0 * cos(iTime / 16.0), -15.0 + 35. * sin(iTime / 16.0), -120.0); // Offset the sphere position with timer\n    combinedSurface = opUnion(combinedSurface, sdPandora(p, 30., sphereOffset, vec3(1.0, 1.0, 0.0))); // Pandora sphere\n    \n    \n    // Add litle blue sphere\n    float t2 = iTime / 16.; // Timer\n    vec3 sphereOffset2 = vec3( 90.0 * cos(t2-0.75*PI), 5.,-2.0 + 90.0 * sin(t2-0.75*PI));\n    combinedSurface = opUnion(combinedSurface, sdlittleBlue(p, 5., sphereOffset2, vec3(1.0, 1.0, 0.0))); // little blue sphere\n\n  \n\n    return combinedSurface;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n    float depth = MIN_DIST;\n    Surface co; // closest object\n\n    for(int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + depth * rd;\n        co = scene(p);\n        depth += co.sd;\n        if(co.sd < PRECISION || depth > MAX_DIST)\n            break;\n    }\n\n    co.sd = depth;\n\n    return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(e.xyy * scene(p + e.xyy).sd +\n        e.yyx * scene(p + e.yyx).sd +\n        e.yxy * scene(p + e.yxy).sd +\n        e.xxx * scene(p + e.xxx).sd);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax) {\n    float res = 1.0;\n    float t = mint;\n\n    for(int i = 0; i < 16; i++) {\n        float h = scene(ro + rd * t).sd;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if(h < 0.001 || t > tmax)\n            break;\n    }\n\n    return clamp(res, 0.0, 1.0);\n}\n\nvoid drawStars(vec2 uv, inout vec3 background) {\n    float threshold = 0.998; // density\n    float randValue = fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n\n    if(randValue > threshold) {\n        vec3 starColor = vec3(1.0);\n\n        float sizeRand = 0.1; // Declare and initialize sizeRand variable\n        float starSize = mix(.5, 3.0, sizeRand);\n\n        // Add twinkle effect\n        float twinkle = 1.+sin(iTime * 5. + uv.x * 100.0 + uv.y * 50.0);\n        starColor *= twinkle;\n\n        background += starColor / (starSize * starSize);\n       // float starSize = mix(.5, 3.0, sizeRand);\n\n        background += starColor / (starSize * starSize);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n        vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 rd = normalize(vec3(uv, -1));\n\n    vec3 topColor = vec3(1., 0.25, 0.0); // Color at the top of the gradient (orange)\n    vec3 bottomColor = vec3(0.000, 0.000, 0.000); // Color at the bottom of the gradient (black)\n    vec3 backgroundColor = mix(bottomColor, topColor, rd.y);\n    vec3 fogColor = vec3(0.5, 0.5, 0.5);\n\n    vec3 col = vec3(0);\n\n\n    vec2 mouse;\n    if(iMouse.x == 0. && iMouse.y == 0.) {\n        mouse = vec2(0.0, 0.0); // Replace with your desired initial rotation\n    } else {\n        mouse = iMouse.xy / iResolution.xy - 0.5; // <-0.5,0.5>\n    }\n\n    rd *= rotateY(mouse.x) * rotateX(mouse.y); // apply yaw and pitch\n    Surface co = rayMarch(ro, rd); // closest object\n\n    if(co.sd > MAX_DIST) {\n        col = backgroundColor; // ray didn't hit anything\n        drawStars(uv, col);\n    } else {\n        vec3 p = ro + rd * co.sd; // point discovered from ray marching\n        vec3 normal = calcNormal(p);\n\n        vec3 lightPosition = vec3(10., 0., 10.);\n        vec3 lightDirection = normalize(lightPosition - p);\n\n        float dif = clamp(dot(normal, lightDirection), 0., 1.) + 0.5; // diffuse reflection\n\n        float softShadow = clamp(softShadow(p, lightDirection, 0.02, 2.5), 0.1, 1.0);\n\n        col = dif * co.col * softShadow;\n\n    // Check if the color of the closest object matches the color of the sea\n        vec3 seaColor = vec3(0.0, 0.0, .70); // Replace with the actual color of the sea\n        if(length(co.col - seaColor) < 0.01) {\n        // Calculate the reflected ray\n            vec3 reflection = reflect(rd, normal);\n\n        // Perform a second ray march along the reflected ray\n            float t2 = 0.0;\n            for(int i = 0; i < 256; i++) {\n                vec3 p2 = p + t2 * reflection;\n                Surface co2 = rayMarch(p2, reflection);\n                if(co2.sd < 0.00001 || t2 > 5.0)\n                    break;\n                t2 += co2.sd;\n            }\n\n        // If the second ray march hit something, add the reflection color\n            if(t2 < 5.0) {\n                vec3 reflectionColor = vec3(1.0, 1.0, 1.0); // Color of the reflection\n                float reflectionStrength = 0.5; // Strength of the reflection\n                col = mix(col, reflectionColor, reflectionStrength);\n            }\n        }\n    }\n\n    float fogHeightStart = 0.0; // Set the starting height of the fog\n    float fogHeightEnd = 2.0; // Set the ending height of the fog\n    float fogDensity = 0.00004; // Set the desired fog density\n\n    float fogFactor = .5 - exp(-fogDensity * co.sd * co.sd * co.sd);\n    fogFactor = clamp(fogFactor, 0.0, 1.0); // Clamp the fog factor between 0 and 1\n\n    vec3 p; // Declare the variable 'p' as a vector or structure\n    if(p.y > fogHeightStart && p.y < fogHeightEnd) {\n        fogFactor = 0.0; // Disable fog within the specified height range\n    }\n\n    col = mix(col, fogColor, fogFactor); // Apply fog using the fog color\n    col = pow(col, vec3(1.0 / 2.2)); // Gamma correction\n    fragColor = vec4(col, 1.0);\n   //fragColor = texture(iChannel2,uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// https://www.shadertoy.com/view/4sfGzS\nfloat noise(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise2(in vec3 uv) {\n    float p = 2.35;\n    float n = 0.0;\n    \n    n += 0.500000 * noise(uv * p); p *= 2.01;\n    n += 0.250000 * noise(uv * p); p *= 2.02;\n    n += 0.125000 * noise(uv * p); p *= 1.99;\n    n += 0.062500 * noise(uv * p); p *= 1.97;\n    n += 0.031250 * noise(uv * p); p *= 1.98;\n    n += 0.015625 * noise(uv * p);\n    n /= 0.884375;\n    \n    return n;\n}\n\n// https://iquilezles.org/articles/functions\nfloat cpulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvec3 texture(in vec3 uv) {\n    uv += noise2(vec3(noise2(uv - 1532.0), noise2(uv + 786.0), 0.0));\n    float n = noise2(uv);\n    \n    vec3 col = vec3(0.0);\n    \n    col += vec3(96.0, 91.0, 86.0)    / 256.0 * cpulse(0.15, 0.25, n);\n    col += vec3(100.0, 94.0, 157.0)  / 256.0 * cpulse(0.45, 0.15, n);\n    col += vec3(172.0, 193.0, 138.0) / 256.0 * cpulse(0.5, 0.03, n);\n    col += vec3(238.0, 184.0, 104.0) / 256.0 * cpulse(0.55, 0.15, n);\n    col += vec3(73.0, 220.0, 177.0)  / 256.0 * cpulse(0.85, 0.25, n);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = -1.0 + 2.0 * uv;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = texture(vec3(uv - vec2(0.0, 16.0),  64.0));\n    col = sqrt(col);\n    \n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2 hash2(vec2 p){\n\treturn fract(sin(vec2(dot(p,vec2(123.4,748.6)),dot(p,vec2(547.3,659.3))))*5232.85324);\n}\nfloat hash(vec2 p){\n\treturn fract(sin(dot(p,vec2(43.232,75.876)))*4526.3257);\n}\n\nfloat voronoi(vec2 p){\n\tvec2 n=floor(p);\n\tvec2 f=fract(p);\n\tfloat md=5.0;\n\tvec2 m=vec2(0.0);\n\n\tfor(int i=-1;i<=1;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tvec2 g=vec2(i,j);\n\t\t\tvec2 o=hash2(n+g);\n\t\t\to=0.5+0.5*sin(5.038*o);\n\t\t\tvec2 r=g+o-f;\n\t\t\tfloat d=dot(r,r);\n\t\t\tif(d<md){\n\t\t\t\tmd=d;\n\t\t\t\tm=n+g+o;\n\t\t\t}\n\t\t}\n\t}\n\treturn md;\n}\n\nfloat ov(vec2 p){\n\tfloat v=0.0;\n\tfloat a=0.4;\n\tfor(int i=0;i<3;i++){\n\t\tv+=voronoi(p)*a;\n\t\tp*=2.0;\n\t\ta*=0.5;\n\t}\n\treturn v;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tvec4 a=vec4(0.0,0.65,1.0,1.0);\n\tvec4 b=vec4(0.85,0.9,1.0,1.0);\n\tfragColor=vec4(mix(a,b,smoothstep(0.0,0.5,ov(uv*5.0))));\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}