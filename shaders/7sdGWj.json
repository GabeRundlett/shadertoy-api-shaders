{
    "Shader": {
        "info": {
            "date": "1630822762",
            "description": "Sometimes you step back from a shader and go - WHAT was I thinking? Some tricks in finite domain rep and noise. Bars are stationary and only move 1 rep - [mouse/able] - explore the noise!",
            "flags": 0,
            "hasliked": 0,
            "id": "7sdGWj",
            "likes": 11,
            "name": "Cube & Noise Experiment",
            "published": 3,
            "tags": [
                "cubicnoiseexperiment"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 370
        },
        "renderpass": [
            {
                "code": "/**\n\n    Cube & Noise Experiment / mouse-able\n    \n    Tricks in finite domain rep and noise. \n    Some motion tricks with the bars using fract(t) and the noise\n    vector jumping in time. Otherwise just starting to messa round.\n    \n    @byt3_m3chanic | 09/04/21\n\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MIN_DIST .0001\n#define MAX_DIST 20.\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\n\n// @Shane - tightly compacted, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    const vec3 s = vec3(113, 57, 27);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother alternative.\n    h = mix(fract(sin(h)*4378.5453), fract(sin(h + s.x)*4378.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n// @iq fbm generator\nfloat fbmd( in vec3 x, float oct ) {\n    const float scale  = .8;\n    float a = .0,b = .5,f = 2.;\n    vec3  d = vec3(0.);\n    for( float i=0.; i<oct; i++ ) {      \n        float n = n3D(f*x*scale);\n        a += b*n;\n        b *= 0.5;\n        f *= 1.8;\n    }\n\treturn a;\n}\n// @iq sdf's\nfloat cap( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat octa( vec3 p, float s){\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n// globals\nmat2 turn,pulse,ry;\nvec3 hit,hitPoint,sto,gto;\nvec2 gid,sid;\nfloat time,shs,ghs,mofs,mofx,ftm,otm;\n// consts\nconst float c = .4, c2=c/2.;\n\n// scene\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0);\n    vec3 f =p;\n    vec3 sf=f;\n    p+=vec3(0,ftm*c,0);\n    p.x=abs(p.x)-3.25;\n    p.xz*=ry;\n    f.x=abs(f.x)-3.25;\n    f.xz*=ry;\n    vec3 q = p;\n    vec3 id =floor((p-c2)/c);\n    float wd  = 11.;\n    float hgt = 15.;\n    q.x = q.x - c*clamp(round(q.x/c),-wd,wd);\n    q.y = q.y - c*clamp(round(q.y/c),-hgt,hgt);\n\n    float nz = fbmd((id*.055)+vec3(mofx,otm,mofs),4.);\n\n    // blocks\n    float sfct = c2*.75;\n    float d2 =  nz>.5 ? cap(q.yzx,c2*.7,sfct*.5) : box(q,vec3(sfct*1.28,sfct*.25,sfct*.5));\n    if(d2<res.x) {\n        res = vec2(d2,2.);\n    \thit=p;\n        ghs=nz;\n    }\n    \n    f.y=abs(f.y);\n    float d5 =  box(f-vec3(2.5,5.,2.5),vec3(7,.05,1.));\n    if(d5<res.x) {\n        res = vec2(d5,1.);\n    \thit=sf;\n    }  \n\n    sf.yz*=pulse;\n    sf.xz*=turn;\n    sf=abs(sf);\n    \n    float d8 =  octa(sf,3.5);\n    sf.xz*=ry;\n    d8 =  min(octa(sf,3.5),d8);\n    if(d8<res.x) {\n        res = vec2(d8,4.);\n    \thit=sf;\n    }  \n    \n    return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\n//@iq https://iquilezles.org/articles/palettes\nvec3 hue(float t){ \n    return .525 + .475*cos(PI2*t*(vec3(0.145,0.831,0.663)+vec3(0.847,0.667,0.933)) ); \n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec3 p = ro;\n    \n    for(int i=0;i<100;i++)\n    {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<32? ray.x*.5: ray.x;\n        m  = ray.y;\n    } \n\n    hitPoint = hit;\n    sid = gid;\n    shs = ghs;\n    \n    float alpha = 0.;\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(1,3,9);\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),0.,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n        fresnel = mix(.01, .7, fresnel);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), 14.);\n\n        vec3 h = vec3(.5);\n        \n        if(m==1.) {\n            vec3 hp = hitPoint+vec3(.0,0,.2);\n            hp.xz*=rot(.785312);\n            h = vec3(0.929,0.929,0.929);\n            vec2 f = fract(hp.xz*.74)-.5;\n            if(f.x*f.y>0.) h=vec3(0.090,0.090,0.090);\n            ref = vec3(.4)-fresnel;\n        }\n        \n        if(m==2.) {\n            h=shs<.5?vec3(.05):hue(floor(shs*15.)*.05);\n            ref = vec3(0);\n        }\n        if(m==4.) {\n            h=vec3(.0);\n            ref = vec3(.25)-fresnel;\n        }\n        \n        C = diff*h+spec;\n        ro = p+n*.01;\n        rd = reflect(rd,n);\n        \n    }else{\n        C = mix(vec3(0.059,0.059,0.059),hue(.34),(uv.y+.5)*.5);\n    } \n    \n    return vec4(clamp(C,vec3(.03),vec3(1.)),alpha);\n}\n\nvoid overLay(inout vec3 C, vec2 uv, float d) {\n    float scl=40.;\n    float px = fwidth(uv.x);\n    vec2 id = floor(uv*scl);\n    vec2 grid=fract(uv*scl)-.5;\n    float hs = fbmd((id.xyx*.065)+vec3(mofx,T*.15,mofs),4.);\n    if((uv.x>0.7 && uv.x<.975 || uv.x<-.7 && uv.x>-.975 ) && (uv.y>-.4 &&uv.y<.4)) {\n        float b= (hs>.5) ? length(grid)-.35:box(grid,vec2(.35));\n        if(hs<.5)b=abs(b)-.05;\n        b=smoothstep(.05+px,-px,b);\n        C =mix(C,hs>.5? hue(.1-floor(hs*15.)*.05)+.2 :vec3(.035),b);\n    }\n    \n    float bs = length(uv)-.39;\n    bs=smoothstep(.3+px,-px,bs);\n    C=mix(C, C+.05,d*.05>1.?bs:0.);  \n    vec3 uclr = hue(23.);\n    \n    bs = length(uv)-.51;\n    bs=abs(abs(bs)-.015)-.005;\n    bs=smoothstep(px,-px,bs);\n    C=mix(C, uclr,d*.05>1.?bs*.75:0. );  \n\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) \n{\n    // precal / chew your vars!\n    mofx = (M.y/R.y)*2.;\n    mofs = (M.x/R.x)*2.;\n    \n    float my = M.xy==vec2(0) ? 0.2 : (2.*M.y-R.y)/R.y;\n    pulse = rot(my);\n    turn = rot(-T*30.*PI/180.);\n    ry =rot(.7851);\n    \n    ftm = fract(T);\n    otm = (((T*.35)-ftm/6.)*c);\n    //\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 ro = vec3(0, 0, 13.);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0); \n    vec3 fil=vec3(1);\n    \n    float d =0.;\n    float alpha =1.;\n    for(float i=0.; i<2.; i++) {\n        d =0.;\n        C += render(ro, rd, ref, d, uv).rgb*fil;\n        fil*=ref;\n        if(i==0.) alpha+=d;\n    }\n\n    overLay(C,uv,alpha);\n    \n    C = mix(C,C+.035,hash21(uv));\n    C = clamp(C,vec3(.03),vec3(.9));\n\n    // gamma correction\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}