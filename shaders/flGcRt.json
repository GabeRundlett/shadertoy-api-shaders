{
    "Shader": {
        "info": {
            "date": "1662330301",
            "description": "This is a concept able to render a mandelbrot set with a really high precision (192 bits) (ends at 360 seconds)\n\nI challenge anyone to improve this project\n\nIf you want a more detailed mandelbrot check https://www.shadertoy.com/view/slyyWc",
            "flags": 32,
            "hasliked": 0,
            "id": "flGcRt",
            "likes": 5,
            "name": "Almost Infinite Mandelbrot Zoom",
            "published": 3,
            "tags": [
                "mandelbrot",
                "zoom"
            ],
            "usePreview": 1,
            "username": "Ric3cir121",
            "viewed": 326
        },
        "renderpass": [
            {
                "code": "// This program is able to render a mandelbrot set with a really high resolution\n// I have never decided to make it readable for others but here are a few things to know\n\n// number is a type of number with a really high precision using an array of uint\n// newnum( int | float | void ): used to create a number with the specified value, 0 if not specified\n// operators: sum(a,b): a+b, sub(a,b): a-b, mult(a,b): a*b\n// other functions: rshift(a): a>>1, neg(a): -a\n// solve(a): solves all numbers in the array above 65535\n// negate(a): flips all the bits and the .neg value\n\n// each uint in the arrays stores 16 bits\n// the first 2 elements are in the positive range while the others in the negative one\n\n// uint number.num: the array\n// bool number.neg: if true the value is negative\n// bool number.int: the number is infinite (not used)\n// int number.int: how many elements in the array are in the positive range (not used)\n\nvec2 map(int i){\n    i-=4;\n    if(i<0){\n        vec2 r = vec2(1);\n        if(i%4<2)return r*(i%2==0?1.:-1.);\n        else return r*vec2(1,-1)*(i%2==0?1.:-1.);\n    }\n    int k = i/4;\n    for(int j=2;j<100;j++){\n        if(k<1){\n            vec2 r = vec2(i/4-(j*(j-2)),j-1);\n            if(i%4<2)return r*(i%2==0?1.:-1.);\n            else return r.yx*vec2(1,-1)*(i%2==0?1.:-1.);\n        }\n        k-=j*2;\n    }\n    return vec2(1);\n}\n\nvoid mainImage(out vec4 o, vec2 u){\n    vec2 p = ((u-iResolution.xy/2.)/exp2(fract(iTime/speed)+.5)+iResolution.xy/2.)/iResolution.xy;\n    o = texture(iChannel0,p);\n    ivec2 s[] = ivec2[](ivec2(1),ivec2(1,0),ivec2(0,1),ivec2(-1,1),ivec2(1,-1),ivec2(-1,0),ivec2(0,-1),ivec2(-1));\n    bool empty = o.w<1.;\n    if(!empty)for(int i=0;i<8;i++)\n    if(texelFetch(iChannel0,ivec2(p*iResolution.xy)+s[i],0).w<1.){empty=true;break;}\n    if(empty){\n        for(int i=0;i<6*4;i++){\n            p = (((u+map(i))-iResolution.xy/2.)/exp2(fract(iTime/speed)+.5)+iResolution.xy/2.);\n            o = texelFetch(iChannel0,ivec2(p),0)/1.;\n            if(o.w>0.)break;\n        }\n        if(o.w<=0.)o=vec4(.5);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define siz 6\n//(4+int(iTime/50.))\nstruct number{\n    uint num[10];\n    bool inf;\n    bool neg;\n    int ints;\n};\n\nnumber newnum(){\n    number a;\n    for(int i=0;i<siz;i++)a.num[i]=uint(0);\n    a.inf=false;\n    a.ints=2;\n    a.neg=false;\n    return a;\n}\nnumber newnum(int b){\n    number a;\n    for(int i=0;i<siz;i++)a.num[i]=uint(0);\n    a.inf=false;\n    a.ints=2;\n    a.neg=b<0;\n    a.num[a.ints-1] = uint(abs(b));\n    return a;\n}\nnumber newnum(float b){\n    number a;\n    for(int i=0;i<siz;i++)a.num[i]=uint(0);\n    a.inf=false;\n    a.ints=2;\n    a.neg=b<0.;\n    a.num[a.ints-1] = uint(abs(b));\n    a.num[a.ints] = uint(fract(abs(b))*65536.);\n    return a;\n}\n\nnumber mult(number a,number b){\n    number ret = newnum();\n    \n    for(int i=0;i<siz;i++){\n        for(int j=0;j<siz;j++){\n            uint mul = a.num[(siz-1)-i]*b.num[(siz-1)-j];\n            uint mul1 = mul%uint(65536);\n            uint mul2 = mul/uint(65536);\n            int slot1 = (siz*2-3)-i-j;\n            int slot2 = slot1-1;\n            if(slot1>=0&&slot1<=siz)ret.num[slot1] += mul1;\n            if(slot2>=0&&slot2<=siz)ret.num[slot2] += mul2;\n        }\n    }\n    for(int i=siz-1;i>=0;i--){\n        if(ret.num[i]>uint(65535)){\n            if(i>0)ret.num[i-1]+=ret.num[i]/uint(65536);\n            ret.num[i]%=uint(65536);\n        }\n    }\n    ret.neg=a.neg^^b.neg;\n    return ret;\n}\nnumber rshift(number a){\n    for(int i=siz-1;i>=0;i--){\n        a.num[i] /= uint(2);\n        if(i>0)if(a.num[i-1]%uint(2)==uint(1))a.num[i]+=uint(65536/2);\n    }\n    return a;\n}\nnumber negate(number a){\n    for(int i=0;i<siz;i++)a.num[i]=uint(65535)-a.num[i];\n    a.num[siz-1]++;\n    a.neg=!a.neg;\n    return a;\n}\nnumber neg(number a){\n    a.neg=!a.neg;\n    return a;\n}\nnumber solve(number a){\n    for(int i=siz-1;i>=0;i--){\n        if(a.num[i]>uint(65535)){\n            if(i>0)a.num[i-1]+=a.num[i]/uint(65536);\n            else if(uint(a.num[i]/uint(65536))>uint(0))a.neg=a.neg^^true;\n            a.num[i]%=uint(65536);\n        }\n    }\n    return a;\n}\nnumber sum(number a,number b){\n    number ret = newnum();\n    ret.neg=a.neg^^b.neg;\n    if(a.neg)a=negate(a);\n    if(b.neg)b=negate(b);\n    for(int i=siz-1;i>=0;i--){\n        ret.num[i]+=a.num[i]+b.num[i];\n        if(ret.num[i]>uint(65535)){\n            if(i>0)ret.num[i-1]+=ret.num[i]/uint(65536);\n            else if(uint(ret.num[i]/uint(65536))>uint(0))ret.neg=ret.neg^^true;\n            ret.num[i]%=uint(65536);\n        }\n    }\n    if(ret.neg)ret=solve(negate(neg(ret)));\n    return ret;\n}\nnumber sub(number a,number b){return sum(a,neg(b));}\nbool greater(number a,number b){\n    if(a.neg&&!b.neg)return false;\n    if(!a.neg&&b.neg)return true;\n    if(!a.neg)for(int i=0;i<siz;i++){\n        if(a.num[i]>b.num[i])return true;\n        if(a.num[i]<b.num[i])return false;\n    }\n    else for(int i=siz-1;i>=0;i--){\n        if(a.num[i]>b.num[i])return true;\n        if(a.num[i]<b.num[i])return false;\n    }\n    return false;\n}\nfloat nfloat(number a){\n    float r = 0.;\n    float m = 65536.;\n    for(int i=0;i<siz;i++){\n        r += float(a.num[i])*m;\n        m/=65536.;\n    }\n    return r*(a.neg?-1.:1.);\n}\nint nint(number a){\n    return int(a.num[a.ints-2]*uint(65536)+a.num[a.ints-1])*(a.neg?-1:1);\n}\n\n\n//\n\n\nfloat mandelbrot(vec2 u,float zoom){\n    int size = int(floor(iTime/speed)+zoom);\n    number uvx = newnum((u.x-iResolution.x/2.)/iResolution.x*16.);\n    number uvy = newnum((u.y-iResolution.y/2.)/iResolution.x*16.);\n    for(int i=0;i<size;i++){\n        uvx = rshift(uvx);\n        uvy = rshift(uvy);\n    }\n    \n    number limit = newnum(65535);\n    number two = newnum(2);\n    number pos = newnum(.51178137);\n    pos.num = uint[](uint(0),uint(0),uint(34401),uint(12),uint(32610),uint(10990),uint(0),uint(0),uint(0),uint(0));\n    \n    number px = newnum();\n    number py = newnum();\n    uvx = sub(uvx,pos);\n    uvy = sub(uvy,pos);\n    \n    float it = 0.;\n    number npx;\n    for(it=0.;it<floor(iTime/speed*4.)*2.+100.;it++){ \n        npx = sum( sub(mult(px,px),mult(py,py)) , uvx );\n        py = sum( mult(two,mult(px,py)) , uvy );\n        px = npx;\n        if(greater(sum(mult(px,px),mult(py,py)),limit))break;\n    }\n    return it-log2(log2(nfloat(sum(mult(px,px),mult(py,py)))));\n}\n\nvec2 map(int i){\n    i-=4;\n    if(i<0){\n        vec2 r = vec2(1);\n        if(i%4<2)return r*(i%2==0?1.:-1.);\n        else return r*vec2(1,-1)*(i%2==0?1.:-1.);\n    }\n    int k = i/4;\n    for(int j=2;j<100;j++){\n        if(k<1){\n            vec2 r = vec2(i/4-(j*(j-2)),j-1);\n            if(i%4<2)return r*(i%2==0?1.:-1.);\n            else return r.yx*vec2(1,-1)*(i%2==0?1.:-1.);\n        }\n        k-=j*2;\n    }\n    return vec2(1);\n}\n\nfloat hash(float b){return fract(sin(b*12.45872)*48123.5832);}\n\nvoid mainImage(out vec4 o, vec2 u){\n    vec2 uv = (mod(u*2.,iResolution.xy)-iResolution.xy/2.)/iResolution.x*4.;\n    o = texelFetch(iChannel0,ivec2(u),0);\n    \n    vec2 reg = floor(u/iResolution.xy*2.);\n    float zooma = mod( (reg.x+reg.y*2.) +floor(iTime/speed)*3.,4.)+1.;\n    float zoom = mod( (reg.x+reg.y*2.),4.)+1.;\n    vec2 rp = mod(u-.5,floor(iResolution.xy/2.))*2.;\n    \n    if(hash(dot(u,vec2(1.598184,1.3893889))+fract(iTime))>.99+length(uv*(fract(iTime/speed)+1.))*.005)\n    o = vec4(mandelbrot(rp,zooma),zooma,floor(zooma-iTime/speed),1);\n    if(zooma==4.&&floor(zooma-(iTime-iTimeDelta)/speed)!=o.z)o=vec4(0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float speed = 6.;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec2 map(int i){\n    i-=4;\n    if(i<0){\n        vec2 r = vec2(1);\n        if(i%4<2)return r*(i%2==0?1.:-1.);\n        else return r*vec2(1,-1)*(i%2==0?1.:-1.);\n    }\n    int k = i/4;\n    for(int j=2;j<100;j++){\n        if(k<1){\n            vec2 r = vec2(i/4-(j*(j-2)),j-1);\n            if(i%4<2)return r*(i%2==0?1.:-1.);\n            else return r.yx*vec2(1,-1)*(i%2==0?1.:-1.);\n        }\n        k-=j*2;\n    }\n    return vec2(1);\n}\n\nvoid mainImage(out vec4 o, vec2 u){\n    vec4 r = vec4(0.);\n    float tot = 0.;\n    for(int i=0;i<6*4+1;i++){\n        vec2 m = floor(u);\n        if(i!=0)m += map(i-1);\n        float t = clamp(1.-length(m-floor(u))/(length((u-iResolution.xy/2.)/iResolution.x*8.)+2.-fract(iTime/speed)),0.,1.);\n        if(t<=0.)continue;\n        \n        float zoom = mod(floor(m.x)+floor(m.y*2.),4.);\n        float zooma = mod(floor(m.x)+floor(m.y*2.)+1.*floor(iTime/speed),4.);\n        vec2 rl = ((m-iResolution.xy/2.)*exp2(zoom)+iResolution.xy/2.);\n        if(rl == clamp(rl,vec2(0.),vec2(iResolution.xy-1.))){\n            vec2 loc = floor(rl/2.)+vec2(mod(zooma,2.),floor(zooma/2.))*floor(iResolution.xy/2.);\n            vec4 q = texelFetch(iChannel0,ivec2(loc),0);\n            if(q.w==1.){\n                if(isnan(q.x))q.xyz = vec3(.05,.1,.15);\n                else q.xyz = vec3(sin(q.x/16.+vec3(0,.3,.4)*6.28-iTime/4.-2.)/2.+.5);\n                r+=q*t;\n                tot+=t;\n            }\n            \n        }\n    }\n    o = r/tot;\n    if(tot==0.)o.w=0.;\n    else o.w=1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}