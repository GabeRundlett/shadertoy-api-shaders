{
    "Shader": {
        "info": {
            "date": "1714092746",
            "description": "cube and sphere",
            "flags": 0,
            "hasliked": 0,
            "id": "XfdXzB",
            "likes": 3,
            "name": "4d Cube search distfunc",
            "published": 3,
            "tags": [
                "cube",
                "4d"
            ],
            "usePreview": 0,
            "username": "sanderoneil",
            "viewed": 155
        },
        "renderpass": [
            {
                "code": "const float pi=3.141592653589793;\nconst float r = .5;\nfloat sum4(vec4 v){\nreturn abs(v.x)+abs(v.y)+abs(v.z)+abs(v.w);\n}\nvec3 mainloop(vec4 model_origin,vec4 ray,vec4 ray_origin, inout float lowest_d, vec3 col,inout vec4 reflected_ray,  inout vec4 reflected_ray_origin)\n{\n    float side_length = 5.;\n    for (float w = 0.; w<side_length; w++)\n    for (float z = 0.; z<side_length; z++)\n    for (float x = 0.; x<side_length; x++)\n    for (float y = 0.; y<side_length; y++)\n    {\n    vec4 p = vec4 (x,y,z,w)-(side_length-1.)/2.;\n    //p.x /= 3.;\n    //p*= 4.;\n    //p.x -= iMouse.x/1000.;\n    //p.y -= iMouse.x/1000.;\n    //p.z -= iMouse.x/1000.;\n    //p.w -= iMouse.x/1000.;\n    //p-=-2.5;\n    if (length(p)>side_length/2.){\n    col = col_return_cube(p+model_origin-.5,.99, ray,ray_origin, lowest_d, col,reflected_ray,reflected_ray_origin);\n   }\n    }\n    float s= 27.;\n    col = col_return_cube(model_origin-s/2.-2.,s, ray,ray_origin, lowest_d, col,reflected_ray,reflected_ray_origin);\n    //col=sphere_inside_search(model_origin,ray,ray_origin,lowest_d,col,20.,reflected_ray,reflected_ray_origin);\n    col = sphere_search(model_origin,ray,ray_origin,lowest_d,col,1.2,reflected_ray,reflected_ray_origin);\n    for (int d = 0; d<4; d++)\n    {\n        \n        for (int neg = 0; neg<2; neg++)\n        {\n        vec4 a = vec4(0,0,0,0);\n        a.x = float(d==0);\n        a.y = float(d==1);\n        a.z = float(d==2);\n        a.w = float(d==3);\n        \n        a = a -2.*float(neg)*a;\n        //col=sphere_inside_search(model_origin,ray,ray_origin,lowest_d,col,14.,reflected_ray,reflected_ray_origin);\n        //col = sphere_search(model_origin+a*side_length/2.,ray,ray_origin,lowest_d,col,1.8,reflected_ray,reflected_ray_origin);\n        }\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y ;\n    \n    vec2 M = iMouse.xy/iResolution.xy*4.;\n    float t = iTime/10.;\n    vec4 v = eulerto4(0. + M.x,0.,0.);\n    vec4 r = eulerto4(pi/2.+ M.x,0.,0.);\n    vec4 u = eulerto4(0.+ M.x,pi/2.,0.);\n    v = rot(v,0.,M.y,0.,0.,0.);\n    r = rot(r,0.,M.y,0.,0.,0.);\n    u = rot(u,0.,M.y,0.,0.,0.);\n    //v = rot(v,0.,0.,0.,0.,0.+t);\n    //r = rot(r,0.,0.,0.,0.,0.+t);\n    //u = rot(u,0.,0.,0.,0.,0.+t);\n    v = rot(v,0.+t/2.,0.,0.,0.,0.);\n    r = rot(r,0.+t/2.,0.,0.,0.,0.);\n    u = rot(u,0.+t/2.,0.,0.,0.,0.);\n    //v = rot(v,0.,0.,0.,0.+t/7.,0.);\n    //r = rot(r,0.,0.,0.,0.+t/7.,0.);\n    //u = rot(u,0.,0.,0.,0.+t/7.,0.);\n    v = rot(v,0.,M.y,M.y,0.+t,0.+M.x);\n    r = rot(r,0.,M.y,M.y,0.+t,0.+M.x);\n    u = rot(u,0.,M.y,M.y,0.+t,0.+M.x);\n    vec4 ray = normalize(v + r*uv.x + u * uv.y);\n    vec4 ray_origin = vec4(0,0,0,0);\n    \n    vec4 next_ray = ray+0.;\n    vec4 next_ray_origin = ray_origin+0.;\n    \n    vec4 norms[8];\n    \n    vec4 model_origin = v*11.;\n    \n\n    vec3 col = ray.xyz;\n    \n    // Time varying pixel color\n    float lowest_d = 1000000000000.;\n\n    vec3 totalcol=vec3(0);\n    for (float reflection_depth = 0.; reflection_depth < 6.; reflection_depth++){\n    col = mainloop(model_origin,ray,ray_origin,lowest_d,col,next_ray, next_ray_origin);\n    \n    totalcol+=col/3./(reflection_depth+1.4);\n    \n    ray = next_ray+0.;\n    ray_origin = next_ray_origin + 0.;\n    lowest_d = 1000000000000.;\n    }\n\n    fragColor = vec4(totalcol,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 eulerto4( float a, float c ,float b)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    float cb = cos(b);\n    float sb = sin(b);\n    float cc = cos(c);\n    float sc = sin(c);\n    \n    return normalize(vec4(ca*cc,sa*cc,cb*sc,sb*sc));\n}\nvec4 rot(vec4 p,float a, float b,float c,float d,float e)\n{\n\n vec4 pt;\n float co = cos(a);\n float si = sin(a);\n \n pt = vec4(co*p.x - si*p.y,si*p.x + co*p.y,p.z,p.w);\n p = pt+0.;\n co = cos(b);\n si = sin(b);\n pt = vec4(co*p.x - si*p.z,p.y,si*p.x + co*p.z,p.w);\n p = pt+0.;\n \n co = cos(c);\n si = sin(c);\n pt = vec4(co*p.x - si*p.w,p.y,p.z,si*p.x + co*p.w);\n p = pt+0.;\n \n co = cos(d);\n si = sin(d);\n pt = vec4(p.x,co*p.y - si*p.w,p.z,si*p.y + co*p.w);\n p = pt+0.;\n \n co = cos(e);\n si = sin(e);\n pt = vec4(p.x,p.y,co*p.z - si*p.w,si*p.z + co*p.w);\n p = pt+0.;\n \n return p;\n \n}\nvec4 ref(vec4 ray, vec4 norm){\nreturn ray - 2.*dot(ray,norm)*norm;\n}\nvec3 cube_search(vec4 cube,vec4 ray,vec4 ray_origin, vec4 norms[8],inout float lowest_d, vec3 col, vec4 total_center,inout vec4 reflected_ray,  inout vec4 reflected_ray_origin)\n{\nfor (int plane_number = 0; plane_number<8; plane_number ++)\n{\n    vec4 n = norms[plane_number];\n    vec4 p0 = cube + n - ray_origin;\n    \n    float d = dot(p0, n)/ dot(ray,n);\n    \n    vec4 p = ray*d;\n    \n    vec4 intersect_to_cube_center = p - p0;\n    bool any_dimension_above_1 = any(greaterThan(abs(intersect_to_cube_center), vec4(1.00001)));\n    //intersect_to_cube_center < vec4(1,1,1,1);\n    \n    if(!any_dimension_above_1){\n    if(d<lowest_d && d>0.00010){\n    col = n.xyz + n.w + .5;\n    vec4 totald = p - total_center  +ray_origin;\n    //col = (totald.xyz+totald.w+ .5 )/3.;//n.xyz + n.w + .5 ;\n    lowest_d = min(d,lowest_d);\n    reflected_ray = ref(ray,normalize(n));\n    reflected_ray_origin = p +ray_origin ;\n    }}\n    \n    }\n    return col;\n}\n\nfloat maxmin(vec4 v, vec4 b){\n\nreturn max (max (min (v.x, b.x), min (v.y, b.y)),  max(min (v.z, b.z),min (v.w, b.w)));\n\n}\nfloat minmax(vec4 v, vec4 b){\n\nreturn min (min (max (v.x, b.x), max (v.y, b.y)), min(max (v.z, b.z),max (v.w, b.w)));\n\n}\nfloat invert_avoidzero (float a) {return 1./(a + float(a==0.)*.001);}\nvec4 invert_ray (vec4 v) {\nreturn vec4( invert_avoidzero(v.x), invert_avoidzero(v.y), invert_avoidzero(v.z), invert_avoidzero(v.w));\n}\n\n\nfloat cube_dist(vec4 ray_inverse, vec4 cube_lower_corner,float size){\n    vec4 cube_upper_corner = cube_lower_corner + 1.;\n    vec4 dist_low = cube_lower_corner*ray_inverse;\n    //vec3 sine_transform = sine(dist_low);\n    \n    vec4 dist_high = dist_low+ray_inverse*size;\n    //vec3 minimums = min2(dist_low,dist_high);\n    //vec3 maximums = max2(dist_low,dist_high);\n    \n    //float maximalMinimum = max3(minimums);\n    //float minimalMaximum = min3(maximums);\n    float minimalMaximum = minmax(dist_low,dist_high);\n    float maximalMinimum = maxmin(dist_low,dist_high);\n    \n    if (minimalMaximum>maximalMinimum){\n    if (maximalMinimum<=0.)\n    {return minimalMaximum;}\n    return maximalMinimum ;}\n   return 10000000000000.;\n}\nvec3 col_return_cube(vec4 cube,float size,vec4 ray,vec4 ray_origin,inout float lowest_d, vec3 col,inout vec4 reflected_ray,  inout vec4 reflected_ray_origin)\n{\n    vec4 ray_inverse = invert_ray(ray);\n    cube-=ray_origin;\n    float d = cube_dist(ray_inverse,cube,size);\n    \n    if(d<lowest_d && d>0.)\n    {\n        lowest_d = d;\n        vec4 cube_lower_corner = cube;\n        vec4 dist_low = cube_lower_corner*ray_inverse;\n        vec4 dist_high = dist_low+ray_inverse*size;\n        \n        vec4 n  = vec4(dist_low.x == d, dist_low.y == d, dist_low.z == d, dist_low.w == d);\n        n -= vec4(dist_high.x == d, dist_high.y == d, dist_high.z == d, dist_high.w == d);\n        col = (n.xyz*1. + n.w*0.4 + 0.5);\n        \n        reflected_ray = ref(ray,n);\n        reflected_ray_origin = ray*d +ray_origin + reflected_ray*.001;\n        \n    }\n    return col;\n}\nvec3 col_return_cube(vec4 cube,vec4 ray,vec4 ray_origin,inout float lowest_d, vec3 col,inout vec4 reflected_ray,  inout vec4 reflected_ray_origin)\n{\n    return col_return_cube(cube,1.0,ray,ray_origin,lowest_d,col, reflected_ray, reflected_ray_origin);\n}\n\n\nvec3 sphere_search(vec4 sphere,vec4 ray,vec4 ray_origin, inout float lowest_d, vec3 col, float r, inout vec4 reflected_ray,  inout vec4 reflected_ray_origin)\n{\n    vec4 p0 = sphere - ray_origin;\n    float gradient = dot(ray, -p0)*dot(ray, -p0) - (dot(-p0,-p0) - r*r);\n    \n    float d = -dot(ray, -p0) - sqrt(gradient);\n    \n    vec4 p = ray*d;\n    \n    vec4 intersect_to_sphere_center = p - p0;\n   \n    if(d<lowest_d&& d>0.00010){\n        col =  intersect_to_sphere_center.xyz + intersect_to_sphere_center.w + .5;//intersect_to_sphere_center.xyz + intersect_to_sphere_center.w + .5;\n        reflected_ray = ref(ray,normalize(intersect_to_sphere_center));\n    reflected_ray_origin = p +ray_origin;\n    \n    lowest_d = min(d,lowest_d);}\n    \n    //col = vec3(gradient,mod(gradient,100.),0);\n    return col;\n}\n\nvec3 sphere_inside_search(vec4 sphere,vec4 ray,vec4 ray_origin, inout float lowest_d, vec3 col, float r, inout vec4 reflected_ray,  inout vec4 reflected_ray_origin)\n{\n    vec4 p0 = sphere - ray_origin;\n    float gradient = dot(ray, -p0)*dot(ray, -p0) - (dot(-p0,-p0) - r*r);\n    \n    float d = -dot(ray, -p0) + sqrt(gradient);\n    \n    vec4 p = ray*d;\n    \n    vec4 intersect_to_sphere_center = -p + p0;\n   \n    if(d<lowest_d&& d>0.00010){\n        col =  intersect_to_sphere_center.xyz + intersect_to_sphere_center.w + .5;//intersect_to_sphere_center.xyz + intersect_to_sphere_center.w + .5;\n        reflected_ray = ref(ray,normalize(intersect_to_sphere_center));\n    reflected_ray_origin = p +ray_origin;\n    \n    lowest_d = min(d,lowest_d);}\n    \n    //col = vec3(gradient,mod(gradient,100.),0);\n    return col;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}