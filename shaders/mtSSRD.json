{
    "Shader": {
        "info": {
            "date": "1675907238",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!",
            "flags": 0,
            "hasliked": 0,
            "id": "mtSSRD",
            "likes": 23,
            "name": "Year of Truchets #005",
            "published": 3,
            "tags": [
                "raymarching",
                "truchet",
                "tiles",
                "truchetcore"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 257
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #005\n    02/08/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.141592653\n#define PI2         6.283185307\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p+iDate.z,vec2(23.43,84.21))) *4832.3234); }\nfloat lsp(float b, float e, float t) { return clamp((t - b) / (e-b), 0., 1.); }\nfloat eoc(float t) { return (t = t - 1.) * t * t + 1.; }\n\n//@iq https://iquilezles.org/articles/palettes/\nvec3 hue(float t){ \n    return .6+.55*cos(PI2*t+iDate.z*(vec3(1.,.99,.95)+vec3(0.329,0.851,0.529))); \n}\n\nfloat tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.,ga5=0.,ga6=0.,ga7=0.,ga8=0.,lhsh,ghsh;\nvec2 lid,gid;\nmat2 ry,rx,r1,r2,r3,r4,r5,r6;\n\n#define SCALE 1.\nconst float scale = 2./SCALE;\nconst float xf = scale*.5;\nconst vec2 l = vec2(scale);\nconst vec2 s = l*2.;\nconst float sl = l.x*4.;\nconst vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5),   vec2(.5, -.5), vec2(-.5));\n\n//@iq sdf \nfloat torus( vec3 p, vec2 a ){\n  return length(vec2(length(p.xz)-a.x,p.y))-a.y;\n}\n\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat tbox( vec3 p ) {\n    vec2 d2 = vec2(length(p.xz-xf), length(p.xz+xf));\n    vec2 gx = d2.x<d2.y ? vec2(p.xz-xf) : vec2(p.xz+xf);\n    vec3 pv = vec3(gx.x,p.y,gx.y);\n    float d = torus(pv,vec2(xf,.2));\n    float b = box(p,vec3(xf));\n    d=max(abs(d)-.085,-d);\n    d=max(d,b);\n    return d;\n}\nfloat flt( vec3 p ) {\n    float d = min(length(p.yz)-.2,length(p.yx)-.2);\n    float b = box(p,vec3(xf));\n    d=max(abs(d)-.085,-d);\n    d=max(d,b);\n    return d;\n}\nvec2 map(vec3 p) {\n    vec2 res =vec2(1e5,0.);\n\n    mat2 rz = rot((ga7-ga8)*PI);\n    p.xz*=rz;\n\n    vec2 r,ip,ct = vec2(0);\n\n    //@Shane - multi tap grid\n    for(int i =0; i<4; i++){\n        ct = ps4[i]/2.;              // Block center.\n        r = p.xz - ct*s;             // Local coordinates. \n        ip = floor(r/s) + .5;        // Local tile ID. \n        r -= (ip)*s;                 // New local position.   \n        vec2 idi = (ip*s) + ct;\n \n        float hs = hash21(idi);\n        \n        vec3 q = vec3(r.x,p.y,r.y);\n        \n        float chx = mod(idi.x,2.) * 2. - 1.;\n        float chy = mod(idi.y,2.) * 2. - 1.;\n        \n        float chk = (chy<1. ^^ chx<1.) ? 1. : .0;\n        \n        if(chk>.5) { \n            q.xz*=r1; \n            q.xy*=r5;\n            q.xy*=r3;\n        } else { \n            q.xz*=r2; \n            q.xy*=r4;\n            q.xy*=r6;\n        }\n\n        if(hs>.5) q.z*=-1.;\n        \n        float frame2 = (hs>.8) ? flt(q):tbox(q);\n        if(frame2<res.x) {\n            float nf = fract(hs*32.);\n            lid=idi;\n            lhsh=hs;\n            res = vec2(frame2,nf<.175?4.:2.);\n        }\n\n    }\n    \n    float ff = p.y+2.;\n        if(ff<res.x) {\n        res = vec2(ff,1.);\n    }\n        \n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n                      h.yyx*map( p + h.yyx*e ).x + \n                      h.yxy*map( p + h.yxy*e ).x + \n                      h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n, inout float fresnel) {\n    n = normal(p,d);\n    vec3 lpos =  vec3(8,5,0);\n    vec3 l = normalize(lpos-p);\n    float diff = clamp(dot(n,l),0.,1.);\n\n    vec3 h=vec3(.01);\n    if(m==1.) {\n        //p.xz-=T*vec2(.5,-.5);\n        vec2 id = floor(p.xz*1.25);\n        vec2 uv = fract(p.xz*1.25)-.5;\n        float hs = hash21(id);\n        if(hs>.5) uv.x*=-1.;\n        \n        float px = 10./R.x;\n        \n        vec2 d2 = vec2(length(uv-.5), length(uv+.5));\n        vec2 nv = d2.x<d2.y? vec2(uv-.5) : vec2(uv+.5);\n        float d = length(nv)-.5;\n        d=smoothstep(px,-px,abs(abs(d)-.2)-.075);\n        h=mix(h,vec3(.075),d);\n        \n    } else {\n        h = m==2. ? hue(ghsh*.3) : vec3(.075);\n    }\n    \n    return diff*h;\n}\n\nfloat zoom = 7.;\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // precal\n    float time = T;\n    \n    float x = M.xy == vec2(0) ? 0. : -(M.y/R.y * 3. - 1.5) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * 1. - .5) * PI;\n    \n    zoom = 7.-x;\n    \n    tmod = mod(time, 16.);\n    float t1 = lsp(2.0, 4.0, tmod);\n    float t2 = lsp(10.0, 12.0, tmod);\n    float t3 = lsp(4.0, 8.0, tmod);\n    float t4 = lsp(5.0, 8.0, tmod);\n    float t5 = lsp(13.0, 15.0, tmod);\n    float t6 = lsp(8.0, 10.0, tmod);\n    float t7 = lsp(7.0, 11.0, tmod);\n    float t8 = lsp(1.0, 5.0, tmod);\n    \n    ga1 = eoc(t1);\n    ga1 = ga1*ga1*ga1;\n\n    ga2 = eoc(t2);\n    ga2 = ga2*ga2*ga2;\n    \n    ga3 = eoc(t3);\n    ga3 = ga3*ga3*ga3;\n    \n    ga4 = eoc(t4);\n    ga4 = ga4*ga4*ga4;\n    \n    ga5 = eoc(t5);\n    ga5 = ga5*ga5*ga5;\n    \n    ga6 = eoc(t6);\n    ga6 = ga6*ga6*ga6;\n    \n    ga7 = eoc(t7);\n    ga7 = ga7*ga7*ga7;\n    \n    ga8 = eoc(t8);\n    ga8 = ga8*ga8*ga8;\n\n    r1=rot(ga1*PI); \n    r2=rot(ga2*PI); \n    r3=rot(ga3*PI);\n    r4=rot(ga4*PI);\n    r5=rot(ga5*PI);\n    r6=rot(ga6*PI);\n            \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    //orthographic camera\n    vec3 ro = vec3(uv*zoom,-zoom-5.);\n    vec3 rd = vec3(0,0,1.);\n\n    rx = rot(.615);\n    ry = rot(-.785+y);\n    \n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C = vec3(.0);\n    vec3  p = ro + rd;\n    float atten = .95;\n    \n    float k = 1.,d = 0.,b = 4.;\n    \n    for(int i=0;i<80;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float m = ray.y;\n\n        d = i<32 ? ray.x*.5 : ray.x;\n        p += rd * d *k;\n        \n        gid=lid;\n        ghsh=lhsh;\n            \n        if (d*d < 1e-6) {\n  \n            float fresnel=0.;\n            C+=render(p,rd,ro,d,ray.y,n,fresnel)*atten;\n            b--;\n            \n            if(m==1.||b<0.) break;\n            \n            atten *= ray.y==4.?.95:.65;\n            p += rd*.01;\n            k = sign(map(p).x);\n\n            vec3 rr = vec3(0);\n            \n            if(m==2.) {\n                rd=reflect(-rd,n);\n                p+=n*.035;\n                b-=2.;\n            } else {\n                rr = refract(rd,n,.55);\n                rd=mix(rr,rd,.5-fresnel);\n            }\n\n        } \n       \n        if(distance(p,rd)>35.) { break; }\n    }\n\n    if(C.r<.008&&C.g<.008&&C.b<.008) C = hash21(uv)>.85 ? C+.015 : C;\n    C = pow(C, vec3(.4545));\n    O = vec4(C*vec3(0.494,0.655,0.827),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}