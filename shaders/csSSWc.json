{
    "Shader": {
        "info": {
            "date": "1670962902",
            "description": "CC0: Neon city for Windows Terminal\nBased on an older shader of mine seems to have some fans that really seem to like it.\nI personally feel I evolved beyond the techniques of the shader but it seems to appeal\nto some people.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "csSSWc",
            "likes": 34,
            "name": "Neon city for Windows Terminal",
            "published": 3,
            "tags": [
                "2d",
                "neonwave"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 981
        },
        "renderpass": [
            {
                "code": "// CC0: Neon city for Windows Terminal\n//  Based on an older shader of mine seems to have some fans that really seem to like it.\n//  I personally feel I evolved beyond the techniques of the shader but it seems to appeal\n//  to some people.\n//  This is a recreation for windows terminal\n//  Hopefully I didn't destroy what people like about it in the process :)\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3 shineCol = HSV2RGB(vec3(0.55, 0.5, 0.75));\nconst vec3 gridCol  = HSV2RGB(vec3(0.60, 0.5, 1.0));\nconst vec3 cityCol  = HSV2RGB(vec3(0.55, 0.25, 0.4));\nconst vec3 skyCol1  = HSV2RGB(vec3(283.0/360.0, 0.83, 0.16));\nconst vec3 skyCol2  = HSV2RGB(vec3(297.0/360.0, 0.79, 0.43));\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat planex(vec2 p, float w) {\n  return abs(p.y) - w;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat sun(vec2 p) {\n  const float ch = 0.0125;\n  vec2 sp = p;\n  vec2 cp = p;\n  mod1(cp.y, ch*6.0);\n\n  float d0 = circle(sp, 0.5);\n  float d1 = planex(cp, ch);\n  float d2 = p.y+ch*3.0;\n\n  float d = d0;\n  d = pmax(d, -max(d1, d2), ch*2.0);\n\n  return d;\n}\n\nfloat city(vec2 p) {\n  float fd = -(p.y+0.4);\n  float cd = 1E6;\n\n  const float count = 5.0;\n  const float width = 0.1;\n\n  for (float i = 0.0; i < count; ++i) {\n    vec2 pp = p;\n    pp.x += i*width/count;\n    float nn = mod1(pp.x, width);\n    float rr = hash(nn+sqrt(3.0)*i);\n    float dd = box(pp-vec2(0.0, -0.5), vec2(0.02, 0.35*(1.0-smoothstep(0.0, 10.0, abs(nn)))*rr+0.1));\n    cd = min(cd, dd);\n  }\n  \n  return max(fd, cd);\n}\n\nvec3 cityEffect(vec2 p, float dc) {\n  float aa = 2.0 / RESOLUTION.y;\n  dc = abs(dc)-aa;\n  vec3 col = vec3(0.0);\n  col = mix(col, cityCol*0.75, smoothstep(aa, -aa, dc));\n  return col;\n}\n\nvec3 sunEffect(vec2 p, float dc) {\n  float aa = 4.0 / RESOLUTION.y;\n\n  vec3 col = vec3(0.1);\n  col = mix(skyCol1, skyCol2, pow(clamp(0.5*(1.0+p.y+0.1*sin(4.0*p.x+TIME*0.5)), 0.0, 1.0), 4.0));\n  \n  p.y -= 0.49;\n  float ds = sun(p);\n\n  float dd = circle(p, 0.5);\n \n  vec3 sunCol = mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 1.0), clamp(0.5 - 1.0*p.y, 0.0, 1.0));\n  vec3 glareCol = sqrt(sunCol);\n  vec3 cityCol = sunCol*sunCol;\n  \n  col += glareCol*(exp(-30.0*ds))*step(0.0, ds);\n  \n\n  float t1 = smoothstep(0.0, 0.075, -dd);\n  float t2 = smoothstep(0.0, 0.3, -dd);\n  col = mix(col, sunCol, smoothstep(-aa, 0.0, -ds));   \n  col = mix(col, glareCol, smoothstep(-aa, 0.0, -dc)*t1);   \n  col += vec3(0.0, 0.25, 0.0)*(exp(-90.0*dc))*step(0.0, dc)*t2;\n  return col;\n}\n\nfloat ground(vec2 p) {\n  p.y += TIME*40.0;\n  p *= 0.075;\n  vec2 gp = p;\n  gp = fract(gp) - vec2(0.5);\n  float d0 = abs(gp.x);\n  float d1 = abs(gp.y);\n  float d2 = circle(gp, 0.05);\n\n  const float rw = 2.5;\n  const float sw = 0.0125;\n\n  vec2 rp = p;\n  mod1(rp.y, 12.0);\n  float d3 = abs(rp.x) - rw;\n  float d4 = abs(d3) - sw*2.0;\n  float d5 = box(rp, vec2(sw*2.0, 2.0));\n  vec2 sp = p;\n  mod1(sp.y, 4.0);\n  sp.x = abs(sp.x);\n  sp -= vec2(rw - 0.125, 0.0);\n  float d6 = box(sp, vec2(sw, 1.0));\n\n  float d = d0;\n  d = pmin(d, d1, 0.1);\n  d = max(d, -d3);\n  d = min(d, d4);\n  d = min(d, d5);\n  d = min(d, d6);\n  \n  return d;\n}\n\nvec3 groundEffect(vec2 p) {\n  vec3 ro = vec3(0.0, 20.0, 0.0);\n  vec3 ww = normalize(vec3(0.0, -0.025, 1.0));\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n\n  float distg = (-9.0 - ro.y)/rd.y;\n\n  vec3 col = vec3(0.0);\n  if (distg > 0.0) {\n    vec3 pg = ro + rd*distg;\n    float aa = length(dFdx(pg))*0.0002*RESOLUTION.x;\n    \n    float dg = ground(pg.xz);\n    \n    col = mix(col, gridCol, smoothstep(-aa, 0.0, -(dg+0.0175)));   \n    col += shineCol*(exp(-10.0*clamp(dg, 0.0, 1.0)));\n    col = clamp(col, 0.0, 1.0);\n    \n    col *= pow(1.0-smoothstep(ro.y*3.0, 220.0+ro.y*2.0, distg), 2.0);\n  }\n  \n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q)  {\n  col = clamp(col,0.0,1.0);\n  // No Gamma correction\n  // col = pow(col, 1.0/vec3(2.2));\n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  vec3 col = vec3(0.0);\n\n  vec2 off = vec2(0.0, 0.15);\n  \n  float dc = city(p-vec2(0.0, 0.375)+off);\n  col += cityEffect(p+off,dc );\n  col += sunEffect(p+off,dc);\n  col += groundEffect(p+off);\n\n  col = postProcess(col, q);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x / RESOLUTION.y;\n \n  vec3 col = effect(p, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}