{
    "Shader": {
        "info": {
            "date": "1635773776",
            "description": "Mandelbulb fractal.",
            "flags": 32,
            "hasliked": 0,
            "id": "fl3Gz4",
            "likes": 10,
            "name": "Mandelbulb fractal",
            "published": 3,
            "tags": [
                "fractal",
                "mandelbrot",
                "mandelbulb"
            ],
            "usePreview": 0,
            "username": "busybeaver",
            "viewed": 378
        },
        "renderpass": [
            {
                "code": "#define enable_color_correction 1\n\n#if enable_color_correction\nfloat gamma = 2.2; // For gamma correction.\nfloat exposure = 0.6;\nfloat tone_pow = 0.3; // Represents how strong the tone mapping is.\n\nvec3 correct_color(vec3 c) {\n    c *= exposure;\n    c = pow(c, vec3(1. / tone_pow));\n    c = pow(c / (c + 1.), vec3(tone_pow));\n    c = pow(c, vec3(1. / gamma));\n    return c;\n}\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    #if enable_color_correction\n    fragColor = vec4(correct_color(texture(iChannel0, fragCoord.xy/iResolution.xy).xyz), 1.);\n    #else\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float pi = 3.1415926;\n\nfloat n = 8.; // n is the power. Change it to get different fractals. Classic power is 8.\n\nint start_frame = 0; // The frame from which the rendering starts. Increase it to have time to turn on full-screen mode.\n#define seed_type 0 // 0 - different seeds for different pixels and frames (noisy), 1 - different seeds for different frames.\n#define slice 0 // 0 - no slice, 1 - slice z, 2 - slice y, 3 - slice x\n#define rot 0 // 0 - no rotation, 1 - flip x and y, 2 - flip x and z, 3 - flip y and z\nfloat rotation_x = .7;\nfloat rotation_y = .1;\nfloat rotation_y_2 = .015;\nfloat w = 2.3;\nfloat cam_dist = 4.4;\nfloat floor_h = -0.92;\nint max_iters = 150;\nint max_steps = 400;\nfloat min_dist = 0.0006;\nfloat close_dist = 0.001;\nfloat max_dist = 1000.;\n\nuint rand_seed;\n\n// There are 3 variants of the power function.\n// 1-st is from russian Wiki (https://ru.wikipedia.org/wiki/Оболочка_Мандельброта). The best formula.\n// 2-nd is from this shader: https://www.shadertoy.com/view/ltfSWn . It is the common used formula.\n// but it seems not to work well. A slice of mandelbulb made with that formula does not look like the mandelbrot set.\n// you can see it by setting slice = 1 or 2 or 3.\n// 3-rd is from english Wiki (https://en.wikipedia.org/wiki/Mandelbulb). It does not work at all.\n// Another seems to be used in famous picture from Wiki (https://en.wikipedia.org/wiki/File:Power_8_mandelbulb_fractal_overview.jpg)\n// But I do not know it.\n\nvec3 power(vec3 z, float p) {\n    float o = p * atan(z.y, z.x);\n    float f = p * atan(z.z, length(z.xy));\n    return pow(length(z), p) * vec3(cos(o)*cos(f), sin(o)*cos(f), sin(f));\n}\n\n/*\nvec3 power(vec3 z, float p) {\n    float r = length(z);\n    float b;\n    if(r != 0.) b = p * acos(z.y / r);\n    else b = 0.;\n    float a = p * atan(z.x, z.z );\n    return pow(r, p) * vec3(sin(b) * sin(a), cos(b), sin(b) * cos(a));\n}\n*/\n/*\nvec3 power(vec3 z, float p) {\n    float o = p * atan(length(z.xy), z.z);\n    float f = p * atan(z.y, z.x);\n    return pow(length(z), p) * vec3(cos(f) * sin(o), sin(f) * cos(o), sin(o));\n}\n*/\n\nvec3 iter(vec3 z, vec3 c) {\n    return power(z, n) + c;\n}\n\n// Distance estimator was taken from here: http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat dist(vec3 c, vec3 ray) {\n    #if slice == 0\n    float d2 = -1.;\n    #endif\n    #if slice == 1\n    float d2 = (c.z > 0.) ? ((ray.z < 0.) ? - c.z / ray.z * .9999 : 100.) : -1.;\n    #endif\n    #if slice == 2\n    float d2 = (c.y > 0.) ? ((ray.y < 0.) ? - c.y / ray.y * .9999 : 100.) : -1.;\n    #endif\n    #if slice == 3\n    float d2 = (c.x > 0.) ? ((ray.x < 0.) ? - c.x / ray.y * .9999 : 100.) : -1.;\n    #endif\n    if(length(c) > 3. && dot(c, ray) < 0.) return length(c) - 2.;\n    vec3 z = vec3(0.0, 0.0, 0.0);\n    float dr = 0.;\n    float r;\n    for(int i = 0; i < max_iters; i ++) {\n        r = length(z);\n        if(r > 2.001) {\n            float d = 0.5 * log(r) * r / dr;\n            return (d < close_dist) ? max(d2, d * .5) : max(d2, d);\n        }\n        dr = n * pow(r, n - 1.) * dr + 1.;\n        #if rot == 0\n        z = iter(z, c);\n        #endif\n        #if rot == 1\n        z = iter(z.yxz, c.yxz).yxz;\n        #endif\n        #if rot == 2\n        z = iter(z.zyx, c.zyx).zyx;\n        #endif\n        #if rot == 3\n        z = iter(z.xzy, c.xzy).xzy;\n        #endif\n    }\n    return max(d2, 0.);\n}\n\nfloat rand() {\n    rand_seed += (rand_seed << 10u);\n    rand_seed ^= (rand_seed >>  6u);\n    rand_seed += (rand_seed <<  3u);\n    rand_seed ^= (rand_seed >> 11u);\n    rand_seed += (rand_seed << 15u);\n    return float(rand_seed % 10000000u) * .0000001;\n}\n\nvec3 rand_ray() {\n    float d = rand() * pi * 2.;\n    float y = rand() * 2. - 1.;\n    float r = sqrt(1. - y * y);\n    return vec3(sin(d) * r, y, cos(d) * r);\n}\n\nvec3 march(vec3 ray, vec3 cam) {\n    vec3 pos = cam;\n    vec3 prev_pos = pos;\n    vec3 k = vec3(1., 1., 1.);\n    int b = 0;\n    for(int i = 0; i < max_steps; i ++) {\n        float d = dist(pos, ray);\n        if(d < min_dist) {\n            k *= vec3(.4, smoothstep(.6, 1.2, length(pos)) * .3 + .3, .4);\n            ray = rand_ray();\n            if(dist(pos + ray * min_dist * .01, ray) < d) {\n                ray = rand_ray();\n                if(dist(pos + ray * min_dist * .01, ray) < d) {\n                    ray = rand_ray();\n                    if(dist(pos + ray * min_dist * .01, ray) < d) return vec3(0., 0., 0.);\n                }\n            }\n            pos = prev_pos;\n            b += 1;\n            if(b > 5) return vec3(0., 0., 0.);\n        }\n        float floor_d = (floor_h - pos.y) / ray.y * .995;\n        prev_pos = pos;\n        if(floor_d < d && floor_d > min_dist * .1) {\n            pos += ray * floor_d;\n            ray.y *= -1.;\n            float r = rand();\n            if(r < .4) ray = normalize(ray + rand_ray() * .06);\n            else if(r < .6) ray = rand_ray();\n            if(ray.y < 0.) return vec3(0., 0., 0.);\n            k *= .4;\n        } else {\n            pos += d * ray;\n        }\n        if(d > max_dist)\n            return (vec3(5., 4., 4.) * smoothstep(.55, .6, ray.y) +\n                    vec3(0., 0., 6.) * smoothstep(.83, .85, ray.x) +\n                    vec3(4., 2., 0.) * smoothstep(.83, .85, ray.z) +\n                    vec3(0., 0., 3.) * (1. - smoothstep(-.95, -.93, ray.x)) +\n                    vec3(2., 1., 0.) * (1. - smoothstep(-.95, -.93, ray.z)) +\n                    vec3(0.1, 0.15, 0.15)) * k;\n    }\n    return vec3(0., 0., 0.);\n}\n\nvec2 rotate(vec2 v, float a) {\n    vec2 x = vec2(cos(a), sin(a));\n    vec2 y = vec2(cos(a + pi * 0.5), sin(a + pi * 0.5));\n    return v.x * x + v.y * y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * .5) / (iResolution.x + iResolution.y) * 4.;\n    #if seed_type == 1\n    rand_seed = uint(iFrame);\n    #endif\n    #if seed_type == 0\n    rand_seed = uint(iFrame) + uint(abs(uv.x * 10000. + uv.y * 1000000000.));\n    rand();\n    rand_seed += uint(iFrame) + uint(abs(uv.x * uv.y) * 10000.);\n    #endif\n\n    vec3 ray = normalize(vec3(w, uv.yx)) +\n               vec3(rand() / iResolution.x * .7,\n                    rand() / iResolution.x * .7,\n                    rand() / iResolution.x * .7);\n    ray = vec3(rotate(ray.xy, - pi * (rotation_y + rotation_y_2)), ray.z);\n    ray = vec3(rotate(ray.xz, - pi * rotation_x).x, ray.y, rotate(ray.xz, - pi * rotation_x).y);\n\n    vec3 pos = vec3(rotate(vec2(-cam_dist, 0.), - pi * rotation_y), 0.);\n    pos = vec3(rotate(pos.xz, - pi * rotation_x).x, pos.y, rotate(pos.xz, - pi * rotation_x).y);\n\n    vec3 col;\n\n    col = march(ray, pos);\n\n    if(iFrame > start_frame) fragColor = vec4(col, 1.0) / float(iFrame - start_frame) + texture(iChannel0, fragCoord.xy/iResolution.xy) * (1. - 1. / float(iFrame - start_frame));\n    fragColor.r = min(.99, max(.01, fragColor.r));\n    fragColor.g = min(.99, max(.01, fragColor.g));\n    fragColor.b = min(.99, max(.01, fragColor.b));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}