{
    "Shader": {
        "info": {
            "date": "1458439051",
            "description": "Some Menger Sponges. Space Bar restarts rendering.",
            "flags": 48,
            "hasliked": 0,
            "id": "lddXRM",
            "likes": 16,
            "name": "Sponge Collection",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "pathtracing",
                "montecarlo",
                "mengersponge"
            ],
            "usePreview": 0,
            "username": "mgattis",
            "viewed": 2190
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    fragColor = vec4(color.rgb, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_DISTANCE        (8.0)\n#define MIN_DELTA           (0.0008)\n#define MAX_RAYITERATIONS   (192)\n#define MAX_REFLECTIONS     (2)\n\n#ifndef M_PI\n#define M_PI                (3.1415926535897932384626433832795)\n#endif\n\n#define Iterations          (6)\n#define Scale               (2.0)\n#define Offset              (1.0)\n#define minRadius2          (0.5)\n#define fixedRadius2        (1.0)\n#define foldingLimit        (1.0)\n\n// Brightness of the sun. Higher value means brighter light.\n// Negative numbers create a pretty cool painted-like effect.\n#define SUN_INTENSITY       (2.81)\n#define SUN_COLOR           vec3(1.0, 0.875, 0.7)\n\nvec3 lightvec;\nvec2 seed;\n\nfloat rand(float p)\n{\n    return fract(sin(dot(vec2(p - 1.0, p + 1.0) ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rand2n()\n{\n    seed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n        fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n \nvec3 ortho(vec3 v)\n{\n    //  See : http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getSampleBiased(vec3 dir, float power)\n{\n    dir = normalize(dir);\n    vec3 o1 = normalize(ortho(dir));\n    vec3 o2 = normalize(cross(dir, o1));\n    vec2 r = rand2n();\n    r.x=r.x*2.*M_PI;\n    r.y=pow(r.y,1.0/(power+1.0));\n    float oneminus = sqrt(1.0-r.y*r.y);\n    return cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n \nvec3 getSample(vec3 dir)\n{\n    return getSampleBiased(dir,0.0); // <- unbiased!\n}\n\nvec3 getCosineWeightedSample(vec3 dir)\n{\n    return getSampleBiased(dir,1.0);\n}\n\nvec3 getConeSample(vec3 dir, float extent)\n{\n    // Formula 34 in GI Compendium\n    dir = normalize(dir);\n    vec3 o1 = normalize(ortho(dir));\n    vec3 o2 = normalize(cross(dir, o1));\n    vec2 r =  rand2n();\n    r.x=r.x*2.*M_PI;\n    r.y=1.0-r.y*extent;\n    float oneminus = sqrt(1.0-r.y*r.y);\n    return cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 vRotateX(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(p.x, c*p.y + s*p.z, -s*p.y + c*p.z);\n}\n\nvec3 vRotateY(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c*p.x - s*p.z, p.y, s*p.x + c*p.z);\n}\n\nvec3 vRotateZ(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c*p.x + s*p.y, -s*p.x + c*p.y, p.z);\n}\n\nfloat sphere(in vec3 p, in float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec3 DE( in vec3 p )\n{\n\tp.xy = mod(p.xy, 2.44) - 1.22;\n    \n   float d = sdBox(p,vec3(1.0));\n   vec3 res = vec3( d, 1.0, 0.0 );\n\n   float s = 1.0;\n   for( int m=0; m<Iterations; m++ )\n   {\n       /*p = vRotateX(p, rand(float(m)) * M_PI * 2.0);\n       p = vRotateY(p, rand(float(m + Iterations)) * M_PI * 2.0);\n       p = vRotateY(p, rand(float(m + Iterations * 2)) * M_PI * 2.0);*/\n       \n      vec3 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = abs(1.0 - 3.0*abs(a));\n\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float c = (min(da,min(db,dc))-1.0)/s;\n\n      if( c>d )\n      {\n          d = c;\n          res = vec3( d, 0.2*da*db*dc, (1.0+float(m))/4.0 );\n      }\n   }\n\n   return res;\n}\n\nfloat getMap(in vec3 p, out int object)\n{\n    float distance = 0.0;\n    float tempdist = 0.0;\n    \n    distance = p.z + 1.0;// - texture(iChannel1, p.xy).r * 0.1;\n    \n    p -= vec3(0.0, 2.5, 0.0);\n    p = vRotateZ(p, -M_PI / 16.0);\n    tempdist = DE(p).x;\n    distance = min(distance, tempdist);\n    object = 1;\n    \n    \n    return distance;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 s = p;\n    float h = MIN_DELTA;\n    int object;\n    return normalize(vec3(\n            getMap(p + vec3(h, 0.0, 0.0), object) - getMap(p - vec3(h, 0.0, 0.0), object),\n            getMap(p + vec3(0.0, h, 0.0), object) - getMap(p - vec3(0.0, h, 0.0), object),\n            getMap(p + vec3(0.0, 0.0, h), object) - getMap(p - vec3(0.0, 0.0, h), object)));\n}\n\nfloat castRay(in vec3 origin, in vec3 direction, out int object)\n{\n    float rayDistance = 0.0;\n    float rayDelta = 0.0;\n    vec3 rayPosition;\n    object = 0;\n    \n    rayPosition = origin;\n    \n    for (int i = 0; i < MAX_RAYITERATIONS; i++)\n    {\n        rayDelta = getMap(rayPosition, object);\n        \n        rayDistance += rayDelta;\n        rayPosition = origin + direction * rayDistance;\n        if (rayDelta <= MIN_DELTA)\n        {\n            return rayDistance;\n        }\n        if (rayDistance >= MAX_DISTANCE)\n        {\n            object = 0;\n            return MAX_DISTANCE;\n        }\n    }\n    \n    object = 0;\n    return MAX_DISTANCE;\n}\n\nvec3 getBackground(in vec3 direction)\n{\n    vec3 color = vec3(0.6, 0.8, 1.0);\n    \n    vec3 bgDirection = lightvec;\n    float bgVal = pow(dot(bgDirection, direction) * 1.001, 256.0);\n    bgVal = clamp(bgVal, 0.0, 1.0);\n    color = mix(color, vec3(1.0, 1.0, 1.0), bgVal);\n\n    bgVal = dot(-bgDirection, direction);\n    if (bgVal > 0.0)\n    {\n    \tcolor = mix(vec3(0.6, 0.8, 1.0), vec3(0.45, 0.6, 0.75), bgVal);\n    }\n                      \n    return color;\n}\n\nvec3 getColor(in vec3 position, in vec3 direction, in int object)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    if (object == 0)\n    {\n        color = getBackground(direction);\n    }\n    else if (object == 1)\n    {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    return color;\n}\n\nvec3 drawScene(in vec3 origin, in vec3 direction)\n{\n    vec3 finalColor = vec3(1.0, 1.0, 1.0);\n    vec3 directLight = vec3(0.0, 0.0, 0.0);\n    float albedo = 0.9;\n    float firstRayDistance;\n    vec3 firstRayDirection;\n    int object = 0;\n\n    vec3 rayOrigin = origin;\n    vec3 rayDirection = direction;\n    firstRayDirection = rayDirection;\n\n    seed = direction.xy * (float(iFrame) + 1.0);\n\n    for (int i = 0; i < MAX_REFLECTIONS; i++)\n    {\n        float rayDistance = castRay(rayOrigin, rayDirection, object);\n        if (i == 0)\n        {\n            firstRayDistance = rayDistance;\n        }\n        if (object != 0)\n        {\n            vec3 rayPosition = rayOrigin + rayDistance * rayDirection;\n\n            vec3 surfaceColor = getColor(rayPosition, rayDirection, object);\n            finalColor *= surfaceColor * albedo;\n\n            vec3 rayNormal = getNormal(rayPosition);\n            vec3 rayNewDirection = normalize(getSample(rayNormal));\n\n            rayOrigin = rayPosition + rayNormal * MIN_DELTA * 2.0;\n            rayDirection = rayNewDirection;\n\n            vec3 sunDirection = lightvec;\n            vec3 sunSampleDirection = getConeSample(sunDirection, 0.001);\n            float sunLight = dot(rayNormal, sunSampleDirection);\n            if (sunLight > 0.0)\n            {\n                castRay(rayOrigin, sunSampleDirection, object);\n                if (object == 0)\n                {\n                    directLight += finalColor * sunLight * SUN_INTENSITY * SUN_COLOR;\n                }\n            }\n        }\n        else\n        {\n            finalColor = directLight + finalColor * getBackground(rayDirection);\n            float fogVal = pow(clamp(firstRayDistance / MAX_DISTANCE, 0.0, 1.0), 4.0);\n            finalColor = mix(finalColor, getBackground(firstRayDirection), fogVal);\n            return finalColor;\n        }\n    }\n\n    float fogVal = pow(clamp(firstRayDistance / MAX_DISTANCE, 0.0, 1.0), 4.0);\n    finalColor = mix(vec3(0.0, 0.0, 0.0), getBackground(firstRayDirection), fogVal);\n    return finalColor;\n}\n\nbool keyPressed(int key)\n{\n    return texture(iChannel1, vec2(float(key) / 256.0, 0.0)).x != 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = fragCoord.xy * (float(iFrame) + 1.0);\n    vec2 offset = rand2n() * 1.0;\n    vec2 uv = 2.0 * (fragCoord.xy + offset) / iResolution.y;\n    uv -= vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 q = fragCoord.xy / iResolution.xy;\n    \n    lightvec = normalize(vec3(1.0, -1.0, 1.0));\n    \n    vec3 origin = vec3(0.0, 0.0, 2.0);\n    vec3 direction = vec3(uv.x, 1.0, uv.y);\n    direction = vRotateX(direction, M_PI / 3.0);\n    direction = normalize(direction);\n    \n    vec3 color = drawScene(origin, direction);\n    color = pow(color, vec3(1.0 / 1.8));\n    \n    int frameNumber = int(texture(iChannel0, q).a);\n    // Hack this in here real quick. Space Bar restarts rendering.\n    // Save the frame number in the alpha channel.\n    if (texture(iChannel1, vec2(0.125, 0.0)).x != 0.0)\n    {\n        frameNumber = iFrame;\n    }\n    \n    if ((iFrame - frameNumber) > 0)\n    {\n    \tvec3 lastcolor = texture(iChannel0, q).rgb;\n        color = mix(lastcolor, color, 1.0 / float((iFrame - frameNumber) + 1));\n    }\n    \n    fragColor = vec4(color.rgb, frameNumber);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}