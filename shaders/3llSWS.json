{
    "Shader": {
        "info": {
            "date": "1564235862",
            "description": "Scene from the ICY Teaser: [url=https://www.youtube.com/watch?v=j_uctCZuB-s&t=13s]Youtube video[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "3llSWS",
            "likes": 15,
            "name": "ITZY - ICY",
            "published": 3,
            "tags": [
                "icy",
                "jype",
                "kpop",
                "itzy",
                "jyp"
            ],
            "usePreview": 0,
            "username": "dubu",
            "viewed": 509
        },
        "renderpass": [
            {
                "code": "#define DISPLAY_GAMMA 1.8\n#define USE_CHROMATIC_ABBERATION\n\nvec2 uvsToUv(vec2 uvs){\n    return uvs*vec2(iResolution.y/iResolution.x,1.0)+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvs = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n    \n    float t = iTime;\n\n    #ifdef USE_CHROMATIC_ABBERATION\n    vec3 color = vec3(0,0,0);\n   \tfloat ca = 0.002+0.0004*sin(t*1717.3)*cos(t);\n    color.x += texture(iChannel0, uvsToUv(uvs)).x*.66;\n    color.xy += texture(iChannel0, uvsToUv(uvs*(1.-1.*ca))).xy*.33;\n    color.y += texture(iChannel0, uvsToUv(uvs*(1.-2.*ca))).y*.33;\n    color.yz += texture(iChannel0, uvsToUv(uvs*(1.-3.*ca))).yz*.33;\n    color.z += texture(iChannel0, uvsToUv(uvs*(1.-4.*ca))).z*.66;\n    #else\n    vec3 color = texture(iChannel0, uvsToUv(uvs)).rgb;\n    #endif\n    \n    color = vec3(1.9,1.95,2.4)*color/(1.0+color);\n    \n  \tcolor *= 0.2 + 0.8 * saturate(pow(128. * uv.x * uv.y * (1.-uv.x) * (1.-uv.y), 0.2));\n    \n    fragColor = vec4(pow(color, vec3(1.0/DISPLAY_GAMMA)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265\n#define TAU (2.*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n#define DOF_STRENGTH (0.1)\n#define DOF_THRESHOLD 0.5\n#define DOF_NUM_ITERATIONS 10.0\n\n// sane functions\nfloat saturate(float x){\n    return clamp(x,0.0,1.0);\n}\nfloat map(float value, float low1, float high1, float low2, float high2){\n\treturn low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\n// Triplanar mapping\nvec3 BlendNormal(vec3 normal){\n\tvec3 blending = abs(normal);\n\tblending = normalize(max(blending, 0.00001));\n\tblending /= vec3(blending.x + blending.y + blending.z);\n\treturn blending;\n}\nvec3 TriplanarMapping (sampler2D tex, vec3 normal, vec3 position) {\n\tvec3 normalBlend = BlendNormal(normal);\n\tvec3 xColor = texture(tex, position.yz).rgb;\n\tvec3 yColor = texture(tex, position.xz).rgb;\n\tvec3 zColor = texture(tex, position.xy).rgb;\n\n  \treturn (xColor * normalBlend.x + yColor * normalBlend.y + zColor * normalBlend.z);\n}\n\n\n// SDF\nfloat sgn(float x) {\n\treturn (x<0.0)?-1.0:1.0;\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n#if 1\nfloat fBoxCheap(vec3 p, vec3 b) {\n\treturn vmax(abs(p) - b);\n}\n#else\nfloat fBoxCheap(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n#endif\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// combination operations\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nstruct Hit{\n \tfloat d;\n    int ID;\n} _Hit;\n\nHit OpUnionHit(Hit a, Hit b){\n    if(a.d < b.d)return a;\n    return b;\n}\n\n\n// PBR\n#define PBR_EPSILON 1e-4\n\nstruct Material{\n    vec3 albedo;\n    vec3 metallic;\n    float roughness;\n} _Material;\n    \nstruct GeometricContext{\n    vec3 position;\n    vec3 normal;\n    vec3 viewDir;\n} _GeometricContext;\n\nstruct IncidentLight{\n\tvec3 direction;\n    vec3 color;\n    bool visible;\n} _IncidentLight;\n\nstruct PointLight{\n    vec3 position;\n    vec3 color;\n    float visibleDistance;\n    float decay;\n} _PointLight;\n\nstruct ReflectedLight{\n    vec3 directDiffuse;\n    vec3 directSpecular;\n    vec3 indirectDiffuse;\n    vec3 indirectSpecular;\n} _ReflectedLight;\n\n\nbool TestLightInRange(const in float lightDistance, const in float cutoffDistance){\n    return any(bvec2(cutoffDistance == 0.0, lightDistance < cutoffDistance));\n}\nfloat punctualLightIntensityToIrradianceFactor(const in float lightDistance,\n                                               const in float cutoffDistance,\n                                               const in float decayExponent){\n    if(decayExponent > 0.0){\n     \treturn pow(saturate(-lightDistance / cutoffDistance + 1.0), decayExponent);   \n    }\n    \n    return 1.0;\n}\nvoid GetPointDirectLightIrradiance( const in PointLight pointLight,\n                                    const in vec3 geometryPosition,\n                                    out IncidentLight directLight){\n    vec3 L = pointLight.position - geometryPosition;\n    directLight.direction = normalize(L);\n    \n    float lightDistance = length(L);\n    if(TestLightInRange(lightDistance, pointLight.visibleDistance)){\n        directLight.color = pointLight.color;\n        directLight.color *= punctualLightIntensityToIrradianceFactor(lightDistance, pointLight.visibleDistance, pointLight.decay);\n        directLight.visible = true;\n    }else{\n        directLight.color = vec3(0.0);\n        directLight.visible = false;\n    }\n}\n\nvec3 DiffuseColor(vec3 albedo, vec3 metallic){\n    return mix(albedo, vec3(0.0), metallic);\n}\nvec3 SpecularColor(vec3 albedo, vec3 metallic){\n    return mix(vec3(0.04), albedo, metallic);\n}\nvec3 DiffuseBRDF(vec3 diffuseColor){\n    return diffuseColor / PI;\n}\n\nvec3 F_Schlick(vec3 specularColor, vec3 V, vec3 H){\n    return (specularColor + (1.0 - specularColor) * pow(1.0 - saturate(dot(V,H)), 5.0));\n}\nfloat D_GGX(float a, float dotNH){\n \tfloat a2 = a*a;\n    float dotNH2 = dotNH*dotNH;\n    float d = dotNH2 * (a2 - 1.0) + 1.0;\n    return a2 / (PI*d*d);\n}\nfloat G_SmithSchlickGGX(float a, float dotNV, float dotNL){\n    float k = a*a*0.5 + PBR_EPSILON;\n    float gl = dotNL / (dotNL * (1.0 - k) + k);\n    float gv = dotNV / (dotNV * (1.0 - k) + k);\n    return gl*gv;\n}\n\nvec3 SpecularBRDF(const in IncidentLight directLight,\n                  const in GeometricContext geometry,\n                  vec3 specularColor,\n                  float roughnessFactor){\n    vec3 N = geometry.normal;\n    vec3 V = geometry.viewDir;\n    vec3 L = directLight.direction;\n    \n    float dotNL = saturate(dot(N, L));\n    float dotNV = saturate(dot(N, V));\n    vec3 H = normalize(L+V);\n    float dotNH = saturate(dot(N, H));\n    float dotVH = saturate(dot(V, H));\n    float dotLV = saturate(dot(L, V));\n    float a = roughnessFactor * roughnessFactor;\n    \n    vec3 F = F_Schlick(specularColor, V, H);\n    float D = D_GGX(a, dotNH);\n    float G = G_SmithSchlickGGX(a, dotNV, dotNL);\n    \n    return (F*(G*D)) / (4.0 * dotNL * dotNV + PBR_EPSILON);\n}\n\nvoid RE_Direct(const in IncidentLight directLight,\n               const in GeometricContext geometry,\n               const in Material material,\n               inout ReflectedLight reflectedLight){\n\tfloat dotNL = saturate(dot(geometry.normal, directLight.direction));\n    vec3 irradiance = dotNL * directLight.color;\n    \n    irradiance *= PI;\n    \n    vec3 diffuse = DiffuseColor(material.albedo, material.metallic);\n    vec3 specular = SpecularColor(material.albedo, material.metallic);\n    \n    reflectedLight.directDiffuse += irradiance * DiffuseBRDF(diffuse);\n    \n    float roughness = map(material.roughness, 0., 1., 0.025, 1.);\n    reflectedLight.directSpecular += irradiance * SpecularBRDF(directLight, geometry, specular, roughness);\n}\n\n// PBR Utils\nfloat GetMipFromRoughness(float roughness){\n\tfloat level = 3.0 - 1.15 * log2( roughness );\n\treturn 10.0 - 1.0 - level;\n}\n\n\n// Utils\n\nconst mat2 m2 = mat2(1.6,-1.2,1.2,1.6);\nfloat noi( in vec2 p )\n{\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\n}\nfloat smoothNoise( vec2 p )\n{\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<2; i++ )\n\t{\n        t += s*noi( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*m2*p + (t-0.5)*0.2;\n\t}\n\treturn t;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define FOV\t\t\t0.45\n#define NUM_BOUNCES\t2\n\n#define MAX_STEPS\t\t\t512\n#define SURFACE_DIST\t\t1e-4\n#define MAX_DIST\t\t\t100.0\n#define NUM_AO_STEPS\t\t8.\n#define NUM_SHADOW_STEPS\t32\n\n#define MAT_BUILDING\t1\n#define MAT_CONCRETE\t2\n#define MAT_WALL\t\t3\n#define MAT_POLE\t\t4\n#define MAT_AC\t\t\t5\n#define MAT_AC_GRILL\t6\n#define MAT_YEJI\t\t7\n#define MAT_RYUJIN\t\t8\n#define MAT_YUNA\t\t9\n#define MAT_LIA\t\t\t10\n#define MAT_CHAERYOUNG\t11\n\nconst int NUM_LIGHTS = 3;\nPointLight pointLights[NUM_LIGHTS];\n\n\nvec3 SampleCubemap(vec3 rd, in float mip){\n    pR(rd.xz, 0.5);\n    return texture(iChannel0, rd, mip).xyz * vec3(0.1, 0.4, 0.45);\n}\n\nHit Building(vec3 p){\n    float wall = fBoxCheap(p - vec3(0., 0., 6.), vec3(50., 50., 1.));\n    \n    return Hit(\n        wall,\n        MAT_BUILDING\n    );\n}\nHit AirConditioners(vec3 p){\n    p -= vec3(0.3, 1.9, 5.0);\n    vec2 c = pMod2(p.xy, vec2(2.86, 1.59));\n    \n\tp.z -= step(0.5, smoothNoise(c.xy*1000.+c.y*600.)*0.5+0.5);\n    \n    float box = fBoxCheap(p, vec3(0.19, 0.15, 0.2));\n    float grill = fBoxCheap(p, vec3(0.17, 0.13, 0.21));\n    float grillCutout = fBoxCheap(p-vec3(0., 0.13, 0.0), vec3(0.07, 0.03, 0.22));\n\n    grill = max(grill, -grillCutout);\n    \n    return OpUnionHit(\n        Hit(box, MAT_AC),\n        Hit(grill, MAT_AC_GRILL)\n    );\n}\nHit Concrete(vec3 p){\n    float concrete = fPlane(p, vec3(0.0, 1.0, 0.0), 0.0);\n    \n    return Hit(\n        concrete,\n        MAT_CONCRETE\n    );\n}\nHit Wall(vec3 p){\n    float wall = fBoxCheap(p - vec3(0., 0., 3.), vec3(15., 0.8, 0.05));\n    float cutout = fBoxCheap(p - vec3(22.5, 0.8, 3.), vec3(20., 0.2, 0.2));\n    \n    return Hit(\n        max(wall, -cutout),\n        MAT_WALL\n    );\n}\nHit Pole(vec3 p){\n    vec3 q = p - vec3(-0.5, 0.6, 2.8);\n    pMod1(q.x, 6.0);\n    vec3 q1 = q;\n    float multiplier = saturate((1.0 - pow(-4.0*q.y, 2.0)) * 0.075 + 1.0);\n    q1.xz *= multiplier;\n    float pole = fCylinder(q1, 0.05, 0.6) / multiplier;\n    float hat1 = fCylinder(q - vec3(0., 0.6, 0.), 0.125, 0.05);\n    float hat2 = fCylinder(q - vec3(0., 0.7, 0.), 0.19, 0.06);\n    \n    return Hit(\n        min(fOpUnionChamfer(pole, hat1, 0.04), hat2),\n        MAT_POLE\n    );\n}\nHit Members(vec3 p){\n    float yeji = fCapsule(p-vec3(-1.5, 0.75, 1.), 0.15, 0.6);\n    float ryujin = fCapsule(p-vec3(-0.75, 0.75, 1.5), 0.15, 0.6);\n    float yuna = fCapsule(p-vec3(-0., 0.45, 0.5), 0.3, 0.15);\n    float lia = fCapsule(p-vec3(0.75, 0.7, 1.5), 0.15, 0.55);\n    float chaeryoung = fCapsule(p-vec3(1.75, 0.7, 1.), 0.15, 0.55);\n    \n    return OpUnionHit(\n        Hit(chaeryoung, MAT_CHAERYOUNG),\n        OpUnionHit( \n            OpUnionHit(Hit(yeji, MAT_YEJI),Hit(ryujin, MAT_RYUJIN)),\n            OpUnionHit(Hit(yuna, MAT_YUNA),Hit(lia, MAT_LIA))\n        )\n\t);\n}\n\nHit GetDist(vec3 p){\n    Hit dBuilding = Building(p);\n    Hit dAC = AirConditioners(p);\n    Hit dConcrete = Concrete(p);\n    Hit dWall = Wall(p);\n    Hit dPole = Pole(p);\n    Hit dMembers = Members(p);\n    \n    return OpUnionHit(\n        OpUnionHit(OpUnionHit(dBuilding, dAC), dConcrete),\n        OpUnionHit(OpUnionHit(dWall, dMembers), dPole)\n    );\n}\n\nMaterial GetMaterial(in vec3 p, inout vec3 n, in Hit hit){\n    Material mat;\n    \n    if(hit.ID == MAT_BUILDING){\n        const vec2 tileSize = vec2(0.35, 0.63);\n        const vec2 tileOffset = vec2(0.375, 0.1);\n        const vec2 tilePadding = vec2(1.25, 1.4);\n        vec2 gv = fract(p.xy * tileSize - tileOffset) * tilePadding;\n        vec2 tileID = floor(p.xy * tileSize - tileOffset);\n        \n        if(gv.x > 1.0 || gv.y > 1.0){\n            mat.albedo = vec3(0.06, 0.45, 0.9);\n            if(p.x*tileSize.x < tileOffset.x-1.2 && p.y*tileSize.y > tileOffset.y+1.7){\n                mat.albedo = vec3(0.01, 0.12, 0.5);\n            }\n            \n            float f = smoothstep(0., 0.37, texture(iChannel1, p.xy*vec2(0.02, 0.5)+p.y*0.5).r)*0.7+0.3;\n            \n            mat.albedo *= f;\n            mat.metallic = vec3(0.0);\n            mat.roughness = 1.0;\n        }else{\n            vec2 section = fract(gv*vec2(3.0, 1.0))*1.05-0.025;\n            vec2 sectionID = floor(gv*vec2(3.0, 1.0));\n            if(section.x < 0. || section.x > 1. || section.y < 0. || section.y > 1.){\n                mat.albedo = vec3(0.01);\n                mat.metallic = vec3(0.0);\n                mat.roughness = 1.0;\n            }else{\n                vec2 panel = fract(section*vec2(4.0, 4.0))*1.1-0.05;\n                if(panel.x < 0. || panel.x > 1. || panel.y < 0. || panel.y > 1.){\n                    mat.albedo = vec3(0.01);\n                    mat.metallic = vec3(0.0);\n                    mat.roughness = 1.0;\n                }else{\n                    vec2 panelID = floor(section*vec2(4.0, 4.0))+sectionID+tileID;\n                    float displace = length(sin(panelID*2.));\n                    n.y += displace*0.1;\n                    n = normalize(n);\n                    float glassTex = saturate(texture(iChannel1, p.xy*0.1).r - 0.5);\n                    mat.albedo = vec3(0.5, 0.8, 1.0);\n                    mat.metallic = vec3(1.0);\n                    mat.roughness = glassTex*0.2;\n                }\n            }   \n        }\n    }else if(hit.ID == MAT_CONCRETE){\n        float tex = length(texture(iChannel1, p.xz*0.2).rgb)*0.5+0.5;\n        mat.albedo = vec3(0.7);\n        mat.albedo *= tex;\n        \n        mat.metallic = vec3(0.0);\n        mat.roughness = 1.0;\n    }else if(hit.ID == MAT_WALL){\n        float upness = dot(n, vec3(0., 1., 0.));\n        if(upness > 0.9){\n            float tex = length(texture(iChannel1, p.xz*0.2).rgb)*0.5+0.5;\n            mat.albedo = vec3(0.9);\n            mat.albedo *= tex;\n            \n            mat.metallic = vec3(0.0);\n            mat.roughness = 1.0;\n        }else{\n            float f0 = \n                saturate(smoothNoise(p.xy*vec2(700., 100.)-vec2(0., 400.)))*\n                saturate(smoothNoise(p.xy*vec2(15000., 500.)-vec2(0., 400.)));\n            \n            f0 = smoothstep(0.0, 0.4, f0);\n\n            float brush = length(texture(iChannel1, p.xy*0.02).rgb)-0.5;\n            float line = smoothstep(2.48, 2.43, p.x)*0.2+0.5;\n            float f1 = smoothstep(line-0.02, line+0.02, p.y - brush * 0.2);\n            float f2 = smoothstep(0.1, 0.08, p.y - brush * 0.2);\n            \n            float f = max(max(f0, f1), f2);\n            \n            float tex = length(texture(iChannel1, p.xy*0.2).rgb)*0.7+0.5;\n            \n            mat.albedo = (vec3(0.05, 0.1, 0.15) + vec3(f*2.0)) * tex;\n            mat.metallic = vec3(0.0);\n            mat.roughness = 1.0;\n        }\n    }else if(hit.ID == MAT_POLE){\n        float f = saturate(smoothNoise(p.xy*vec2(2000., 1000.)));\n        \n        float tex = length(texture(iChannel1, p.xy*vec2(0.03, 0.4)).rgb);\n        \n        mat.albedo = (vec3(0.025, 0.095, 0.12) + vec3(f)*2.0) * tex;\n        mat.metallic = vec3(1.0);\n        mat.roughness = 0.95;\n    }else if(hit.ID == MAT_AC){\n        mat.albedo = vec3(0.9);\n        mat.metallic = vec3(1.0);\n        mat.roughness = 0.9;\n    }else if(hit.ID == MAT_AC_GRILL){\n        mat.albedo = vec3(0.2) * (0.5+0.5*sin(p.y*300.));\n        mat.metallic = vec3(1.0);\n        mat.roughness = 0.9;\n    }else if(hit.ID == MAT_YEJI){\n        vec3 col = vec3(0.0);\n        p.y/=1.5;\n        col = vec3(1.0);\n        col = mix(col, vec3(0.9\t, 0.55, 0.53), smoothstep(0.3, 0.32, p.y)); \n        col = mix(col, vec3(0.9, 0.2, 0.6), smoothstep(0.4, 0.42, p.y));\n        col = mix(col, vec3(1.0, 0.2, 0.1), smoothstep(0.55, 0.57, p.y));\n        col = mix(col, vec3(0.95, 0.6, 0.6), smoothstep(0.8, 0.82, p.y)); \n        col = mix(col, vec3(0.01), smoothstep(0.9, 0.92, p.y)); \n        \n        mat.albedo = col;\n        mat.metallic = vec3(0.0);\n        mat.roughness = 0.975;\n    }else if(hit.ID == MAT_RYUJIN){\n        vec3 col = vec3(0.0);\n        p.y/=1.5;\n        col = vec3(1.0);\n        col = mix(col, vec3(0.01), smoothstep(0.3, 0.32, p.y)); \n        col = mix(col, vec3(1.0), smoothstep(0.35, 0.37, p.y));\n        col = mix(col, vec3(1.0, 1.0, 0.1), smoothstep(0.55, 0.57, p.y));\n        col = mix(col, vec3(0.95, 0.6, 0.6), smoothstep(0.7, 0.72, p.y)); \n        col = mix(col, vec3(0.8, 0.1, 0.5), smoothstep(0.9, 0.92, p.y)); \n        \n        mat.albedo = col;\n        mat.metallic = vec3(0.0);\n        mat.roughness = 0.975;\n    }else if(hit.ID == MAT_YUNA){\n        vec3 col = vec3(0.0);\n        p.y/=0.9;\n        col = vec3(0.01);\n        col = mix(col, vec3(1.0, 0.1, 0.1), smoothstep(0.15, 0.17, p.y)); \n        col = mix(col, vec3(0.9\t, 0.55, 0.53), smoothstep(0.4, 0.42, p.y));\n        col = mix(col, vec3(1.0), smoothstep(0.45, 0.47, p.y));\n        col = mix(col, vec3(0.95, 0.6, 0.6), smoothstep(0.7, 0.72, p.y)); \n        col = mix(col, vec3(0.9, 0.7, 0.5), smoothstep(0.9, 0.92, p.y)); \n        \n        mat.albedo = col;\n        mat.metallic = vec3(0.0);\n        mat.roughness = 0.975;\n    }else if(hit.ID == MAT_LIA){\n        vec3 col = vec3(0.0);\n        p.y/=1.4;\n        col = vec3(1.0);\n        col = mix(col, vec3(0.9\t, 0.55, 0.53), smoothstep(0.2, 0.22, p.y)); \n        col = mix(col, vec3(1.0), smoothstep(0.4, 0.42, p.y));\n        col = mix(col, vec3(0.9, 0.2, 0.6), smoothstep(0.55, 0.57, p.y));\n        col = mix(col, vec3(0.95, 0.6, 0.6), smoothstep(0.75, 0.77, p.y)); \n        col = mix(col, vec3(0.01), smoothstep(0.9, 0.92, p.y)); \n        \n        mat.albedo = col;\n        mat.metallic = vec3(0.0);\n        mat.roughness = 0.975;\n    }else if(hit.ID == MAT_CHAERYOUNG){\n        vec3 col = vec3(0.0);\n        p.y/=1.4;\n        col = vec3(0.01);\n        col = mix(col, vec3(1.0), smoothstep(0.05, 0.07, p.y)); \n        col = mix(col, vec3(1.0), smoothstep(0.35, 0.37, p.y));\n        col = mix(col, vec3(0.8, 1.0, 0.1), smoothstep(0.55, 0.57, p.y));\n        col = mix(col, vec3(0.95, 0.6, 0.6), smoothstep(0.75, 0.77, p.y)); \n        col = mix(col, vec3(0.25, 0.2, 0.15), smoothstep(0.9, 0.92, p.y)); \n        \n        mat.albedo = col;\n        mat.metallic = vec3(0.0);\n        mat.roughness = 0.975;\n    }\n    \n    return mat;\n}\n\nvec3 GetNormal(vec3 pos){\n \tvec2 e = vec2(1.0,-1.0)*0.00001;\n    return normalize( e.xyy*GetDist( pos + e.xyy ).d + \n\t\t\t\t\t  e.yyx*GetDist( pos + e.yyx ).d + \n\t\t\t\t\t  e.yxy*GetDist( pos + e.yxy ).d + \n\t\t\t\t\t  e.xxx*GetDist( pos + e.xxx ).d );\n}\n\nfloat CalcAO(vec3 ro, vec3 rd){\n    float k = 1.0;\n    float occ = 0.0;\n    for(float i = 0.0; i < NUM_AO_STEPS; ++i){\n        float len = 0.15 * i + 0.125;\n        float dist = GetDist(rd * len + ro).d;\n        occ += k * (len - dist);\n        k *= 0.5;\n    }\n    return saturate(1.0-occ);\n}\n\nfloat CalcShadow(in vec3 ro, in vec3 rd, in float maxT){\n    float res = 1.0;\n    float t = 0.01;\n    float ph = 1e10;\n    \n    for(int i = 0; i < NUM_SHADOW_STEPS; ++i){\n        float h = GetDist(rd * t + ro).d;\n        \n        if(h < SURFACE_DIST)return 0.;\n        \n        float y = h*h/(2.*ph);\n        float d = sqrt(h*h-y*y);\n        res = min(res, 5.*d/max(0.,t-y));\n        ph = h;\n        \n        t += h*0.95;\n        \n        if(res < SURFACE_DIST || t >= maxT) break;\n    }\n    \n    return saturate(res);\n}\n\nHit RayMarch(vec3 ro, vec3 rd, int bounce){\n\tfloat dO = 0.;\n    Hit hit;\n    \n    int steps = MAX_STEPS;\n    \n    if(bounce > 0){\n        steps /= bounce*4;\n    }\n    \n    for(int i = 0; i < steps; i++){\n        vec3 p = dO*rd+ro;\n        hit = GetDist(p);\n        dO += hit.d;\n        if(hit.d < SURFACE_DIST || dO > MAX_DIST){\n            break;\n        }\n    }\n    return Hit(dO, hit.ID);\n}\n\nvec4 GetColor(vec3 ro, vec3 rd){\n    int bounce = 0;\n    float depth = 0.;\n    \n    vec3 res = vec3(0.0);\n    \n    vec3 carry = vec3(1.0);\n    float lastRoughness = 0.0;\n    \n    for(int bounce = 0; bounce <= NUM_BOUNCES; ++bounce){\n        Hit hit = RayMarch(ro, rd, bounce);\n        if(bounce == 0)depth = hit.d;\n\n        if(hit.d >= MAX_DIST){\n            float mip = GetMipFromRoughness(lastRoughness);\n            res += SampleCubemap(rd, mip) * carry;\n            break;\n        }\n\n        vec3 p = rd * hit.d + ro;\n        vec3 n = GetNormal(p);\n        vec3 v = normalize(ro-p);\n        \n        GeometricContext geometry;\n        geometry.position = p;\n        geometry.normal = n;\n        geometry.viewDir = v;\n\n        Material material = GetMaterial(p, n, hit);\n        \n        \n        ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n        IncidentLight directLight;\n        \n        vec3 s = vec3(0.0);\n        for(int lightIndex = 0; lightIndex < NUM_LIGHTS; ++lightIndex){\n            GetPointDirectLightIrradiance(pointLights[lightIndex], geometry.position, directLight);\n            \n            if(directLight.visible){\n                vec3 L = pointLights[lightIndex].position - geometry.position;\n            \tfloat shadow = CalcShadow(p, normalize(L), length(L));\n            \n                directLight.color *= shadow;\n                \n                RE_Direct(directLight, geometry, material, reflectedLight);\n            }\n        }\n        \n        vec3 specular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n        vec3 diffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n        \n        vec3 col = vec3(0.0);\n        col += specular;\n        col += diffuse;\n        \n        col += vec3(0.02) * material.albedo;\n        \n        float ao = CalcAO(p, n);\n        col *= ao*ao;\n        \n        res += col * carry;\n        \n        carry = material.albedo * carry * (1.0 - material.roughness);\n        lastRoughness = material.roughness;\n\n        // bounce ray\n        rd = rd - 2.0*dot(rd, n)*n;\n        ro = p + rd*0.01;\n    }\n    \n    return vec4(res, depth);\n}\n\nvoid InitLights(){\n    pointLights[0].color = vec3(1.0, 1.0, 0.8)*1.;\n    pointLights[0].position = vec3(10.0, 15., 1.);\n    pointLights[0].visibleDistance = 100.0;\n    pointLights[0].decay = 0.25;\n    \n    pointLights[1].color = vec3(1.0, 1.0, 0.7 );\n    pointLights[1].position = vec3(5., 5.5, 0.);\n    pointLights[1].visibleDistance = 100.0;\n    pointLights[1].decay = 0.25;\n    \n    pointLights[2].color = vec3(1.0, 0.7, 0.9 );\n    pointLights[2].position = vec3(-2., 1.5, -2.);\n    pointLights[2].visibleDistance = 10.0;\n    pointLights[2].decay = 2.0;\n}\n\nvec4 CalcImage(in vec2 fragCoord){\n    vec2 uvs = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    uv *= 1.+0.02*dot(uv,uv);\n\t\n    float t = iTime;\n    \n\tfloat fbm1 = smoothNoise(vec2(t*100.))*0.1;\n    float fbm2 = smoothNoise(vec2(t*90.+100.))*0.5;\n    float fbm3 = smoothNoise(vec2(t*80.+200.))*0.1;\n    float fbm4 = smoothNoise(vec2(t*70.+300.))*0.5;\n    \n    float zpos = -3.0;\n    float camHeight = .8;\n    \n    vec3 lookAt = vec3(0.0, camHeight*1.75+fbm1, 4.0+zpos);\n    vec3 cameraPosition = vec3(0.+fbm2, camHeight+fbm3, 0.+fbm4+zpos);\n    \n    vec3 forward = normalize(lookAt-cameraPosition);\n    vec3 right = normalize(vec3(forward.z, fbm2*0.1, -forward.x ));\n    vec3 up = normalize(cross(forward,right));\n\n    vec3 ro = cameraPosition; \n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    vec4 tot = GetColor(ro, rd);\n    \n    vec3 color = tot.rgb;\n    float depth = tot.a;\n    \n    float fbmDof = smoothNoise(vec2(t*50.));\n    float focusPoint = 5. + fbmDof*2.;\n    float focusField = 100.;\n    \n    float focus = mix(0., 1., abs(depth - focusPoint)/focusField);\n    focus = saturate(focus);\n    \n    vec4 final = vec4(color, focus);\n    return final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    InitLights();\n    \n    vec4 color = CalcImage(fragCoord);\n    \n    fragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}