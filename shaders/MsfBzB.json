{
    "Shader": {
        "info": {
            "date": "1496709650",
            "description": "My first attempt at writing an sdf ray marching shader. 3 spheres smooth min-ed with pseudo random-ish movements. Stratified jittered AA. PBR w/ Burley diffuse & Karis prefiltered environment BRDF for IBL. Soft Shadows. Gamma correction and Tone Mapping.",
            "flags": 0,
            "hasliked": 0,
            "id": "MsfBzB",
            "likes": 15,
            "name": "Blobby-ball thingies",
            "published": 3,
            "tags": [
                "raymarching",
                "blobs",
                "sdf",
                "metaballs",
                "ibl",
                "pbr"
            ],
            "usePreview": 0,
            "username": "piyushslayer",
            "viewed": 1132
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n\n// Comment/uncomment this to disable/enable anti-aliasing.\n// #define AA\n\n// The scene renderer averages pow(AA_SAMPLES, 2) random ray-marched samples for anti-aliasing.\n#define AA_SAMPLES 4\n\n// Enable or disable the rotating of the camera\n#define ROTATE_CAMERA 1\n\n// Material properties. Play around with these to change the way how the spheres are shaded.\nconst vec3 LIGHT_INTENSITY = vec3 (6.0);\nconst float INDIRECT_INTENSITY = 0.55;\nconst vec3 INDIRECT_SPECULAR_OFFSET = vec3(0.45, 0.65, 0.85);\n\nconst vec3 SPHERE0_RGB = vec3(0.4, 0.5, 0.0);\nconst vec3 SPHERE1_RGB = vec3(0.5, 0.0, 0.4);\nconst vec3 SPHERE2_RGB = vec3(0.0, 0.4, 0.5);\n\nconst float SPHERE_METALLIC = 0.99;\nconst float SPHERE_ROUGHNESS = 0.11;\n\n// If you decrease metalness factor above, make sure to also change this to something\n// non-metallic. Sample values can be found at: https://learnopengl.com/PBR/Theory\nconst vec3 SILVER_F0 = vec3(0.988, 0.98, 0.96);\n\n\n// Modified version of Íñigo Quílez's integer hash3 function (https://www.shadertoy.com/view/llGSzw).\nvec2 Hash2(uint n) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec2 k = n * uvec2(n,n*16807U);\n    return vec2( k & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat UniformHash(vec2 xy)\n{\n\treturn fract(sin(dot(xy.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat SdPlane(vec3 p)\n{\n    return p.y;\n}\n\nfloat SdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;  \n}\n\nvec2 SdUnion(vec2 d1, vec2 d2)\n{\n\treturn d1.x < d2.x ? d1 : d2;   \n}\n\nfloat SdSmoothMin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat SdSmoothMin(float a, float b, vec3 mtl1, vec3 mtl0, inout vec3 mtl)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    float s = mix(b, a, h) - k * h * (1.0 - h);\n    float sA = s - a;\n    float sB = s - b;\n    float r = sA / (sA + sB);\n    mtl = mix(mtl1, mtl0, r);\n    return s;\n}\n\nconst float g_sRepeat = 800.0;\n\nvec2 PosIndex(vec3 pos)\n{\n\tvec2 posIndex;\n\tposIndex.x = floor((pos.x + 0.5 * g_sRepeat) / g_sRepeat);\n\tposIndex.y = floor((pos.y + 0.5 * g_sRepeat) / g_sRepeat);\n\treturn posIndex;\n}\n\nfloat UniformHashFromPos(vec3 pos)\n{\n\tpos.xy = PosIndex(pos);\n\treturn UniformHash(pos.xy);\n}\n\nvec3 VecOsc(vec3 vecFreq, vec3 vecAmp, float dT)\n{\n\treturn vecAmp * sin(vec3((iTime + dT) * 2.0 * PI) * vecFreq);\n}\n\nvec2 SdScene(vec3 p)\n{\n    float uniformRandom = UniformHashFromPos(p);\n    vec3 uSphereOsc1 = VecOsc(vec3(1.02389382 / 2.0, 1.0320809 / 3.0, 1.07381 / 4.0),\n\t\t\t\t\t\t\tvec3(0.25, 0.25, 0.1), uniformRandom);\n    vec3 uSphereOsc2 = VecOsc(vec3(1.032038 / 4.0, 1.13328 / 2.0, 1.09183 / 3.0),\n\t\t\t\t\t\t\tvec3(0.25, 0.25, 0.1), uniformRandom);\n    vec3 uSphereOsc3 = VecOsc(vec3(1.123283 / 3.0, 1.13323 / 4.0, 1.2238 / 2.0),\n\t\t\t\t\t\t\tvec3(0.25, 0.25, 0.1), uniformRandom);\n    return SdUnion(vec2(SdPlane(p), 1.0), \n                   vec2(\n                       SdSmoothMin(\n                           SdSmoothMin(\n                               SdSphere(p - vec3(0.0, 0.5, 0.0) + uSphereOsc1, 0.18),\n                               SdSphere(p - vec3(0.0, 0.5, 0.0) + uSphereOsc2, 0.2)\n\t\t     \t    \t   ),\n                       \t   SdSphere(p - vec3(0.0, 0.5, 0.0) + uSphereOsc3, 0.19)\n                       ),\n                       2.0\n                   )\n           );\n}\n\nvec2 SdScene(in vec3 p, inout vec3 mtl)\n{\n    float uniformRandom = UniformHashFromPos(p);\n    vec3 uSphereOsc1 = VecOsc(vec3(1.02389382 / 2.0, 1.0320809 / 3.0, 1.07381 / 4.0),\n\t\t\t\t\t\t\tvec3(0.25, 0.25, 0.1), uniformRandom);\n    vec3 uSphereOsc2 = VecOsc(vec3(1.032038 / 4.0, 1.13328 / 2.0, 1.09183 / 3.0),\n\t\t\t\t\t\t\tvec3(0.25, 0.25, 0.1), uniformRandom);\n    vec3 uSphereOsc3 = VecOsc(vec3(1.123283 / 3.0, 1.13323 / 4.0, 1.2238 / 2.0),\n\t\t\t\t\t\t\tvec3(0.25, 0.25, 0.1), uniformRandom);\n    \n    float smin1 = SdSmoothMin(\n                             SdSphere(p - vec3(0.0, 0.5, 0.0) + uSphereOsc1, 0.18),\n                             SdSphere(p - vec3(0.0, 0.5, 0.0) + uSphereOsc2, 0.2),\n        \t\t\t\t\t SPHERE0_RGB, SPHERE1_RGB, mtl\n\t\t\t\t  );\n    float smin2 = SdSmoothMin(smin1, SdSphere(p - vec3(0.0, 0.5, 0.0) + uSphereOsc3, 0.19),\n                              mtl, SPHERE2_RGB, mtl);\n    return SdUnion(vec2(SdPlane(p), 1.0), vec2(smin2, 2.0));\n}\n\nvec3 CalcNormal(vec3 p)\n{\n\tvec2 e = vec2(1.0,-1.0) * 0.5773 * 0.0005;\n    return normalize( e.xyy * SdScene( p + e.xyy ).x + \n\t\t\t\t\t  e.yyx * SdScene( p + e.yyx ).x + \n\t\t\t\t\t  e.yxy * SdScene( p + e.yxy ).x + \n\t\t\t\t\t  e.xxx * SdScene( p + e.xxx ).x );\n}\n\nfloat ShadowMarch(in vec3 origin, in vec3 rayDirection)\n{\n\tfloat result = 1.0;\n    float t = 0.01;\n    for (int i = 0; i < 64; ++i)\n    {\n        float hit = SdScene(origin + rayDirection * t).x;\n        if (hit < 0.001)\n            return 0.0;\n        result = min(result, 5.0 * hit / t);\n        t += hit;\n        if (t >= 1.5)\n            break;\n    }\n    \n    return clamp(result, 0.0, 1.0);\n}\n    \nvec2 RayMarch(in vec3 origin, in vec3 rayDirection, inout vec3 mtl)\n{\n    float material = -1.0;\n    float t = 0.01;\n\tfor(int i = 0; i < 64; ++i)\n    {\n        vec3 p = origin + rayDirection * t;\n        vec2 hit = SdScene(p, mtl);\n        if (hit.x < 0.001 * t || t > 50.0)\n\t\t\tbreak;\n        t += hit.x;\n        material = hit.y;\n    }\n    \n    if (t > 50.0)\n    {\n     \tmaterial = -1.0;   \n    }\n    return vec2(t, material);\n}\n\n//-----------------------------------------PBR Functions-----------------------------------------------//\n\n// Trowbridge-Reitz GGX based Normal distribution function\nfloat NormalDistributionGGX(float NdotH, float roughness)\n{    \n    float a = roughness * roughness;\n    float a2 = a * a;\n    float NdotH2 = NdotH * NdotH;\n    \n    float numerator = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom *= denom * PI;\n    \n    return numerator / denom;\n}\n\n// Schlick-Beckmann GGX approximation used for smith's method\nfloat GeometrySchlickGGX(float NdotX, float k)\n{\n    float numerator   = NdotX;\n    float denom = NdotX * (1.0 - k) + k;\n\n    return numerator / denom;\n}\n\n// Smith's method for calculating geometry shadowing\nfloat GeometrySmith(float NdotV, float NdotL, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n    //float k = (r*r) * sqrt(2.0 / PI);\n    \n    float ggx2 = GeometrySchlickGGX(NdotV, k);\n    float ggx1 = GeometrySchlickGGX(NdotL, k);\n\n    return ggx1 * ggx2;\n}\n\n// Schlick's approximation for Fresnel equation\nvec3 FresnelSchlick(float dotProd, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - dotProd, 5.0);\n}\n\nfloat FresnelSchlick(float dotProd, float F0, float F90)\n{\n    return F0 + (F90 - F0) * pow(1.0 - dotProd, 5.0);\n}\n\n// Burley 2012, \"Physically-Based Shading at Disney\"\nfloat DiffuseBurley(float linearRoughness, float NdotV, float NdotL, float LdotH)\n{\n    float f90 = 0.5 + 2.0 * linearRoughness * LdotH * LdotH;\n    float lightScatter = FresnelSchlick(NdotL, 1.0, f90);\n    float viewScatter  = FresnelSchlick(NdotV, 1.0, f90);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\n// Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\nvec3 DiffuseIrradiance(const vec3 n) \n{\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\n// Karis 2014, \"Physically Based Material on Mobile\"\nvec2 PrefilteredEnvApprox(float roughness, float NoV) \n{\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//-----------------------------------------------------------------------------------------------------//\n\n// Handle the shading of the scene.\nvec3 RenderScene(in vec3 origin, in vec3 rayDirection, out float hitDistance)\n{\n    vec3 finalColor = vec3(0.0);\n    vec3 albedo = vec3(0.0);\n    vec3 sphereMaterial = vec3(0.0);\n\n    // returns distance and material\n    vec2 hit = RayMarch(origin, rayDirection, sphereMaterial);\n    hitDistance = hit.x;\n    float material = hit.y;\n    \n    vec3 sphereColor = vec3(0.13, 0.0, 0.5);\n    \n    if (material > 0.0)\n    {\n        // Essential vectors and scalars for lighting calculation\n        vec3 position = origin + hitDistance * rayDirection;\n        vec3 normal\t= CalcNormal(position);\n        vec3 viewDir = normalize(-rayDirection);\n        vec3 lightDir = normalize(vec3(20.6, 20.7, -20.7) - position);\n        vec3 halfVec = normalize(viewDir + lightDir);\n        vec3 reflectDir = normalize(reflect(rayDirection, normal));\n        \n        float NdotL = max(dot(normal, lightDir), 0.0);\n        float NdotV = max(dot(normal, viewDir), 0.0);\n        float NdotH = max(dot(normal, halfVec), 0.0);\n        float LdotH = max(dot(lightDir, halfVec), 0.0);\n        float VdotH = max(dot(halfVec, viewDir), 0.0);\n        \n        float roughness = 0.0, metallic = 0.0;\n        vec3 F0 = vec3(0.0);\n        \n        if (material < 2.0)\n        {\n            // Checkerboard floor\n        \tfloat f = mod(floor(7.5 * position.z) + floor(7.5 * position.x), 2.0);\n\t\t\talbedo = 0.4 + f * vec3(0.6);\n            roughness = (f > 0.5 ? 1.0 : 0.18);\n            metallic = 0.4;\n            // Plastic/Glass F0 value\n            F0 = mix(vec3(0.04), albedo, metallic);\n        } \n        else if (material < 3.0)\n        {\n            // Spheres\n         \talbedo =  sphereMaterial;\n            roughness = clamp(SPHERE_ROUGHNESS, 0.0, 1.0);\n            metallic = clamp(SPHERE_METALLIC, 0.0, 1.0);\n            // Silver F0 value\n            F0 = mix(SILVER_F0, albedo, metallic);\n        }\n         \n        \n        // Calculate radiance\n        //float lightDistance = length(lightDir);\n        //float attenuation = 1.0 / (lightDistance * lightDistance);\n        float attenuation = ShadowMarch(position, lightDir);\n        vec3 radiance = LIGHT_INTENSITY * attenuation;\n        \n        // Cook-Torrence specular BRDF\n        float ndf = NormalDistributionGGX(NdotH, roughness);\n        float geometry = GeometrySmith(NdotV, NdotL, roughness);\n        vec3 fresnel = FresnelSchlick(VdotH, F0);\n        \n        vec3 numerator = ndf * geometry * fresnel;\n        float denominator = 4.0 * NdotV * NdotL;\n        \n        vec3 specular = numerator / max(denominator, 0.0001);\n        \n        // Burley Diffuse BRDF\n        float diffuse = DiffuseBurley(roughness * roughness, NdotV, NdotL, LdotH);\n        \n        // Energy conservation\n        vec3 kS = fresnel;\n        vec3 kD = vec3(1.0) - kS;\n        // Diffuse light decreases as \"metal-ness\" increases (and vice versa).\n        kD *= 1.0 - metallic;\n        \n        vec3 ambient = 0.05 * albedo;\n            \n        // Note to self: Hmm, not sure whether to divide diffuse by PI or not. Some implementations\n        // do while others don't seem to.\n        // Also, note to self: We don't multiply by kS here because it's already done in the calculation\n        // of the numerator part of the specular component.\n        finalColor += (kD * albedo * diffuse / PI + specular + ambient) * radiance * NdotL;\n        \n        \n        // Indirect Lighting\n        sphereMaterial = vec3(0.0);\n        vec2 indirectHit = RayMarch(position, reflectDir, sphereMaterial);\n        vec3 indirectDiffuse = DiffuseIrradiance(normal) / PI;\n        vec3 indirectSpecular = INDIRECT_SPECULAR_OFFSET + reflectDir.y * 0.72;\n        \n        if (indirectHit.y > 0.0)\n        {\n            if (indirectHit.y < 2.0)\n            {\n                vec3 indirectPosition = position + indirectHit.x * reflectDir;\n                // Checkerboard floor\n                float f = mod(floor(7.5 * indirectPosition.z) + floor(7.5 * indirectPosition.x), 2.0);\n\t\t\t\tindirectSpecular = 0.4 + f * vec3(0.6);\n            }\n            else if (indirectHit.y < 3.0)\n            {\n                // Spheres\n                indirectSpecular = sphereMaterial;\n            }\n        }\n        \n        vec2 prefilteredSpecularBRDF = PrefilteredEnvApprox(roughness, NdotV);\n        vec3 indirectSpecularColor = F0 * prefilteredSpecularBRDF.x + prefilteredSpecularBRDF.y;\n        vec3 ibl = (1. - metallic) * albedo * indirectDiffuse + indirectSpecular * indirectSpecularColor;\n        \n        finalColor += ibl * INDIRECT_INTENSITY;\n    }\n    \n    return finalColor;\n}\n\n// Gamma correction\nvec3 LinearTosRGB(const vec3 linear)\n{\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n// Tone mapping\nvec3 AcesFilmicToneMap(const vec3 x)\n{\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n// Generate the camera view matrix\nmat3 SetCamera(in vec3 origin, in vec3 target, float rotation)\n{\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Set up the camera view matrix\n    vec3 lookAt = vec3(0.0, 0.25, 0.0);\n    float phi = iTime * 0.25 + PI; // horizontal plane angle\n    float theta = 0.3; // left-right (around y-axis) angle\n#if ROTATE_CAMERA\n    vec3 eyePosition = vec3(cos(theta)*cos(phi), sin(theta), cos(theta)*sin(phi)) * 4.0;\n#else\n    vec3 eyePosition = vec3(0.0, 1.0, -4.0);\n#endif\n    \n    // Calculate the camera matrix.\n    mat3 cameraToWorld = SetCamera(eyePosition, lookAt, 0.0);\n    \n    vec3 color = vec3(0.0);\n    float t;\n    \n#ifdef AA\n    \n    int totalAASamples = AA_SAMPLES*AA_SAMPLES;\n    for (int i = 0; i < totalAASamples; ++i)\n    {\n        \n        // Shamelessly plugged and modified from demofox's reflection/refraction shader.\n        // Calculates stratified subpixel jitter for anti-aliasing.\n        float x = mod(float(i), float(AA_SAMPLES));\n        float y = mod(float(i / AA_SAMPLES), float(AA_SAMPLES));\n        \n        vec2 jitter = (Hash2(uint(i)) + vec2(x, y)) / float(AA_SAMPLES);\n\n        vec2 uv = 2.0 * (fragCoord.xy + jitter) / iResolution.xy - 1.0;\n        uv.x *= iResolution.x / iResolution.y;\n\n#else\n        vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n        uv.x *= iResolution.x / iResolution.y;\n\n#endif    \n        // Ray direction starts from camera's current position\n        vec3 rayDirection = cameraToWorld * normalize(vec3(uv, 5.0));\n\n        // Ray march the scene using sdfs\n        color += RenderScene(eyePosition, rayDirection, t);    \n#ifdef AA\n    }\n    \n    color /= float(totalAASamples);\n#endif\n    \n    // Add a simple distance fog to the scene\n    float fog = 1.0 - exp2(-0.012 * t * t);\n    color = mix(color, 0.8 * vec3(0.6, 0.8, 1.0), fog);\n    \n    // Tone mapping\n    color = AcesFilmicToneMap(color);\n\n    // Gamma correction\n    color = LinearTosRGB(color);\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}