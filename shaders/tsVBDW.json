{
    "Shader": {
        "info": {
            "date": "1607906423",
            "description": "Randomly generated Truchet tilings of spherical polyhedra. Mouse rotates. Press E to toggle edges.\n\nHappy noodling!",
            "flags": 16,
            "hasliked": 0,
            "id": "tsVBDW",
            "likes": 32,
            "name": "rainbow noodle orbs",
            "published": 3,
            "tags": [
                "truchet",
                "tiling",
                "spherical",
                "polyhedron",
                "woven",
                "wythoff"
            ],
            "usePreview": 0,
            "username": "mattz",
            "viewed": 657
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////////////////////////\n//\n// \"rainbow noodle orbs\" by mattz\n// License https://creativecommons.org/licenses/by/4.0/\n//\n// What it does: woven Truchet tilings of spherical polyhedra.\n//\n// Why: Looks neat\n//\n// This one was fun to write! Lots of technical challenges along the \n// way, but especially figuring out how to address all of the \n// polygon vertices of a particular polygon face, and also figuring\n// out how to do G1 continuous splines on the surface of a sphere\n// with analytic distance functions.\n//\n//////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.141592653589793;\nconst float TOL = 1e-5;\n\n#define MAX_POLYGON 10\n\n//////////////////////////////////////////////////////////////////////\n// from https://www.shadertoy.com/view/XlGcRh \n// original by Dave Hoskins\n\nvec3 hashwithoutsine31(float p) {\n   vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hashwithoutsine33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat hashwithoutsine11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//////////////////////////////////////////////////////////////////////\n// some more hash and RNG functions\n\n// get random color from a sphere vec\nvec3 random_color_from_sphere(vec3 x) {\n    return hashwithoutsine33(floor(25.*x + 0.5));    \n}\n\n// fisher-yates shuffle of array\nvoid shuffle(inout int idx[2*MAX_POLYGON], in int cnt, in float seed) {\n    \n    int i = cnt - 1;\n \n    for (int iter=0; iter<2*MAX_POLYGON; ++iter) {\n        if (i < 1) { break; }\n        int j = int(floor(hashwithoutsine11(seed) * float(i+1)));\n        if (j < 0 || j > i) {\n            for (int k=0; k<2*MAX_POLYGON; ++k) {\n                idx[k] = k % 2;\n            }\n            return;\n        }\n        int tmp = idx[i];\n        idx[i] = idx[j];\n        idx[j] = tmp;\n        i -= 1;\n        seed += 1.0;\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// if point p lies opposite m, mirror it. return the transform that\n// accomplishes this.\n\nmat3 mirror(inout vec3 p, in vec3 m) {\n    \n    float d = dot(p, m);\n    mat3 rval = mat3(1.) - (2. * step(d, 0.)) * outerProduct(m, m);\n        \n    p = (rval * p);\n        \n    return rval;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// modify the vector m to halve the angle with respect to the y\n// axis (assume that m.z == 0)\n\nvec3 half_angle(in vec3 m) {\n    return normalize(vec3(m.x - 1.0, m.y, 0.0));\n}\n\n//////////////////////////////////////////////////////////////////////\n// rotate about arbitrary axis/angle\n\nmat3 rotate(in vec3 k, in float t) {\n    \n    if (abs(t) < TOL) {\n        return mat3(1.);\n    }\n    \n    mat3 K = mat3(0, k.z, -k.y,\n                  -k.z, 0, k.x,\n                  k.y, -k.x, 0);\n                  \n    return mat3(1.) + (mat3(sin(t)) + (1. - cos(t))*K)*K;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// wythoff construction - mammoth function using code stolen\n// from https://www.shadertoy.com/view/Md3yRB\n\nvoid construct(in vec3 pqr, in int spoint, in vec3 pos,\n               out mat3 tri_verts, \n               out mat3 tri_edges, \n               out vec3 poly_vertex, \n               out mat3 poly_edges, \n               out int Q_vidx, \n               out int Q_vidx2, \n               out int Q_eidx, \n               out mat3 M, \n               out float pdist_poly_edge) { \n\n    //////////////////////////////////////////////////////////////////////\n    // part 1: construct the Schwartz triangle \n\n\n    mat4x3 spoints;\n    bvec3 is_face_normal;\n\n    float p = pqr.x;\n    float q = pqr.y;\n    float r = pqr.z;\n\n    float tp = PI / p;\n    float tq = PI / q;\n    float tr = PI / r;\n\n    float cp = cos(tp), sp = sin(tp);\n    float cq = cos(tq);\n    float cr = cos(tr);\n\n    vec3 lr = vec3(1, 0, 0);\n    vec3 lq = vec3(-cp, sp, 0);\n    vec3 lp = vec3(-cq, -(cr + cp*cq)/sp, 0);\n    \n    lp.z = sqrt(1.0 - dot(lp.xy, lp.xy));\n    \n    tri_edges = mat3(lp, lq, lr);\n    \n    vec3 vP = normalize(cross(lr, lq));\n    vec3 vR = normalize(cross(lq, lp));\n    vec3 vQ = normalize(cross(lp, lr));\n    \n    tri_verts = mat3(vP, vQ, vR);\n\n    if (spoint < 3) {\n        poly_vertex = tri_verts[spoint];\n    } else if (spoint == 3) {\n        poly_vertex = normalize(cross(lq - lr, lp));\n    } else if (spoint == 4) {\n        poly_vertex = normalize(cross(lr - lp, lq));\n    } else if (spoint == 5) {\n        poly_vertex = normalize(cross(lp - lq, lr));\n    } else {\n        poly_vertex = normalize(cross(lp-lq, lr-lp));\n    }\n    \n    is_face_normal = bvec3(true);\n    \n    for (int i=0; i<3; ++i) {\n        poly_edges[i] = normalize(cross(poly_vertex, tri_edges[i]));\n        for (int j=0; j<2; ++j) {\n            int vidx = (i+j+1)%3;\n            if (abs(dot(tri_verts[vidx], poly_edges[i])) < TOL) {\n                is_face_normal[vidx] = false;\n            }\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    // part 2: use space folding to make sure pos lies in the triangular \n    // cone whose edge planes are given by tri_edges\n    //\n    // this part of the function was largely determined by trial and\n    // error. possibly if I understood more about symmetry I would be\n    // able to get it a little simpler\n\n    \n    ////////////////////////////////////////////////////\n    // part 2a: guarantee that the point lives inside\n    // the cluster of p triangles that share the vertex\n    // (0, 0, 1)\n    \n    M = mirror(pos, vec3(1, 0, 0));\n    \n    vec3 m = tri_edges[0];\n\n    for (float i=0.; i<5.; ++i) {\n\n        // mirror\n        M *= mirror(pos, m);\n        m -= tri_edges[1] * 2.0 * dot(m, tri_edges[1]);\n\n        M *= mirror(pos, m);\n        m -= tri_edges[2] * 2.0 * dot(m, tri_edges[2]);\n\n    }\n\n    ////////////////////////////////////////////////////\n    // part 2b: fold in the XY plane to make sure the \n    // point lives in the triangular cone just to the\n    // right of the y axis\n       \n    M *= mirror(pos, vec3(1, 0, 0));\n    \n    //float p = pqr.x;\n    float k = p >= 5.0 ? 4. : p >= 3.0 ? 2. : 1.;\n    \n    float theta = k * PI / p;\n\n    m = vec3(-cos(theta), sin(theta), 0); // lq\n    \n    if (p >= 5.0) {        \n        M *= mirror(pos, m);\n        m = half_angle(m);\n    }\n    \n    if (p >= 3.0) {\n        M *= mirror(pos, m);\n        m = half_angle(m);\n    }\n    \n    M *= mirror(pos, m);    \n\n    //////////////////////////////////////////////////////////////////////\n    // part 3 - fill in the rest of the query\n       \n    // position relative to vertex\n    vec3 rel_pos = pos - poly_vertex;\n    \n    // closest vertices and edge\n    Q_vidx = -1;\n    Q_eidx = -1;\n    Q_vidx2 = -1;\n             \n    // for each potential face edge (perpendicular to each tri. edge)\n    for (int eidx=0; eidx<3; ++eidx) {   \n        \n        vec3 tri_edge = tri_edges[eidx];\n                        \n        // polyhedron edge cut plane (passes thru origin and V, perpendicular\n        // to triangle edge)\n        vec3 poly_edge = poly_edges[eidx];\n                                \n        // signed distance from point to face edge\n        float poly_edge_dist = dot(pos, poly_edge);\n\n        // triangle vertex on the same side of face edge as point\n        int vidx = (eidx + (poly_edge_dist > 0. ? 2 : 1)) % 3;\n        \n        // triangle vertex on opposite side of face edge as point\n        int vidx2 = (eidx + (poly_edge_dist > 0. ? 1 : 2)) % 3;\n        if (!is_face_normal[vidx2]) { vidx2 = vidx; }\n                       \n        // construct at the other polyhedron edge associated with the given\n        // triangle vertex\n        vec3 other_poly_edge = poly_edges[3-eidx-vidx];\n        \n        // construct the plane that bisects the two polyhedron edges\n        vec3 bisector = cross(poly_vertex, poly_edge - other_poly_edge);\n        \n        float bisector_dist = dot(pos, bisector);\n             \n        if (bisector_dist >= 0.) {\n            // if we are on the correct side of the associated\n            // bisector, than we have found the closest triangle\n            // edge & vertex.\n            \n            //Q.pdist_bisector = bisector_dist;\n            pdist_poly_edge = poly_edge_dist;\n            Q_eidx = eidx;\n            Q_vidx = vidx;\n            Q_vidx2 = vidx2;\n            \n        }\n \n    }\n    \n}   \n\n//////////////////////////////////////////////////////////////////////\n// make a spherical polygon by repeated reflection across 2 edges\n//\n// inputs:\n//\n//   v: initial vertex position inside original triangle\n//   a: first edge of orig. triangle to reflect across\n//   b: second edge of orig. triangle to reflect across\n//   M: transformation matrix that maps original verts to dst pos\n//   \n\nint make_polygon(vec3 v, vec3 a, vec3 b, mat3 M, out vec3 polygon[MAX_POLYGON]) {\n    \n    // polygon always includes the starting position\n    polygon[0] = v;\n\n    // index of last set polygon vertex\n    int k = 0;\n    \n    // hold pair of edges and swap back and forth\n    vec3 edges[2] = vec3[2]( a, b );\n    \n    // always start by mirroring across the edge v is not on\n    int cur_edge = (abs(dot(v, edges[0])) < 0.01) ? 1 : 0;\n            \n    // we can get 0 or 1 vertex per iter, up to 10 vertices\n    for (int i=0; i<MAX_POLYGON; ++i) {\n        \n        // reflect vertex across cur edge\n        v = normalize(reflect(v, edges[cur_edge]));\n        \n        // reflect other edge across cur edge\n        edges[1-cur_edge] = normalize(reflect(edges[1-cur_edge], edges[cur_edge]));\n        \n        if (dot(v, polygon[0]) > 0.99) {\n            // if we have wrapped around back to the start, done!\n            break;\n        } else if (dot(v, polygon[k]) < 0.99) {\n            // if the vertex was moved by the last reflection add it to the polygon\n            k += 1;\n            polygon[k] = v;\n        }\n        \n        // swap edges\n        cur_edge = 1 - cur_edge;\n        \n    }\n    \n    int npoly = k + 1;\n    if (npoly < 3) { return npoly; }\n    \n    // determine winding order (CW or CCW) and flip if necessary \n    bool flip = dot(M*polygon[0], cross(M*polygon[1], M*polygon[2])) < 0.;\n    \n    // transform points from orig triangle to dst pos\n    // and invert order if necessary; also figure out which is\n    // canonical index 0 using a hash function\n    vec3 Mpolygon[MAX_POLYGON];\n    \n    float dmin = 1e5;\n    \n    const vec3 dir = vec3(0.7027036 , 0.68125974, 0.56301879);\n    \n    int imin = 0;\n\n    for (int i=0; i<MAX_POLYGON; ++i) {\n        if (i >= npoly) { break; }\n        Mpolygon[i] = M * polygon[flip ? npoly - i - 1 : i];\n        float d = dot(dir, Mpolygon[i]);\n        if (d < dmin) {\n            imin = i;\n            dmin = d;\n        }\n    }\n    \n    // shift elements to start at index 0\n    for (int i=0; i<MAX_POLYGON; ++i) {\n        if (i >= npoly) { break; }\n        polygon[i] = Mpolygon[(i + imin) % npoly];\n    }\n    \n    // number of points in the polygon\n    return npoly;\n    \n}\n\n\n\n//////////////////////////////////////////////////////////////////////\n// distance between points on sphere\n\nfloat sdist(vec3 a, vec3 b) {\n    return acos(clamp(dot(a, b), -1.0, 1.0));\n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to arc on sphere\n//\n// inputs: \n//\n//   p: query point (unit vector)\n//   c: arc center point (unit vector)\n//   r: arc radius in radians\n//   l: lower tangent (unit vector)\n//   w: upper tangent (unit vector)\n\nfloat darc(vec3 p, vec3 p0, vec3 c, float r, vec3 l, vec3 w, vec3 p1) {\n    \n    if (dot(p, l) < 0.) {\n        return sdist(p, p0);\n    } else if (dot(p, w)*dot(p0, w) < 0.) {\n        return sdist(p, p1);\n    } else {\n        return abs(sdist(p, c) - r);\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n//\n// adapted from https://www.shadertoy.com/view/3dVfzc with some\n// bugfixes and improvements\n//\n// compute a spline on the sphere made of two arcs that are tangent \n// to each other have desired tangents at given points\n//\n// inputs:\n//\n//    p: query point on sphere\n//\n//   p0: first point on sphere (unit vector)\n//   l0: tangent vector at p0 (unit vector with dot(p0, l0) = 0)\n//   p1: second point on sphere (unit vector) \n//   l1: tangent vector at p1 (unit vector with dot(p1, l1) = 0)\n//\n// output: distance to spline\n\nfloat compute_spline(in vec3 p,\n                     in vec3 p0, in vec3 l0,\n                     in vec3 p1, in vec3 l1) {\n                         \n    // compute the line connecting p0 & p1\n    vec3 tmp = normalize(cross(p0, p1));\n    \n    vec3 c0, c1, m, w;\n    float r;\n\n    // special case: p0, p1 coincident\n    if (dot(p0, p1) > 0.999) {\n        return sdist(p, p0);\n    }\n    \n    vec3 q = normalize(cross(l0, l1));\n\n    bool single_arc = false;\n\n    // special case: p0 and p1 are connected by a segment of a great circle\n    // the line from p0 to p1 hits them at the correct tangents \n    if (max(abs(dot(tmp, l0)), abs(dot(tmp, l1))) < 0.001) {\n    \n        c0 = normalize(cross(l0, l1));\n        c1 = c0;\n        \n        r = 0.5*PI;\n        \n        m = normalize(l0 + l1);\n        w = normalize(cross(m, c0));\n        \n        single_arc = true;\n        \n    } else if (dot(l0, l1) > 0.999) {\n        \n        // special case: single arc along common edge\n        c0 = normalize(p0 + p1);\n        c1 = c0;\n        \n        float c = dot(c0, p0);\n        \n        r = acos(c);\n        \n        m = c * c0 + sqrt(1.0 - c*c) * l0;\n        w = normalize(cross(l0, c0));\n                \n        single_arc = true;\n        \n    } else if (abs(dot(q, p0) - dot(q, p1)) < 1e-3) {\n    \n        // special case: single arc around intersection of edges\n\n        c0 = q;\n        c1 = q;\n        \n        float c = dot(c0, p0);\n        \n        r = acos(c);\n        \n        vec3 l = normalize(l0 + l1);\n        \n        m = c*q + sqrt(1.0 - c*c)*l;\n        w = normalize(cross(c0, m));\n        \n        single_arc = true;\n        \n    }\n    \n    if (single_arc) {\n    \n        vec3 P, L;\n\n        if (dot(p, w) * dot(p0, w) > 0.) {\n            P = p0;\n            L = l0;\n        } else {\n            P = p1;\n            L = l1;\n        }\n\n        if (dot(p, L) < 0.) {\n            return sdist(p, P);\n        } else {\n            return abs(sdist(p, c0) - r);\n        }\n        \n    }\n    \n    // compute the points orthogonal to (l0, p0) and (l1, p1), respectively\n    vec3 a0 = cross(l0, p0);\n    vec3 a1 = cross(l1, p1);\n    \n    // we will construct arc centers \n    //\n    //   c0 = cos(r) * p0 + sin(r) * a0\n    //   c1 = cos(r) * p1 + sin(r) * a1\n    //\n    // which are a distance r away from p0 & p1 respectively\n    // by construction, dot(c0, l0) = dot(c1, l1) = 0\n    //\n    // now we want to solve for r such that dot(c0, c1) = cos(2*r)\n    //\n    // start by observing that \n    //\n    //   (cos(r)²       * a +\n    //    cos(r)*sin(r) * b\n    //    sin(r)²       * c) = cos(2r)\n    //\n    // where a = dot(p0, p1), b = dot(p0, a1) + dot(p1, a0), and \n    // c = dot(a0, a1).\n    //\n    // applying the half angle identities and setting θ = 2r, we find\n    //\n    //   a*(1 + cos(θ))/2 + b*sin(θ)/2 + c*(1 - cos(θ))/2 = cos(θ)\n    //   a*(1 + cos(θ)) + b*sin(θ)+ c*(1 - cos(θ)) = 2*cos(θ)\n    //   (a - c - 2)*cos(θ) + b*sin(θ) = -(a + c)\n    //\n    // we can rewrite that as\n    //\n    //   d*cos(θ) + b*sin(θ) = e\n    //\n    // where d = a - c - 2 and e = -(a + c).\n    //\n    // finally, we can rewrite that as\n    //\n    //   α*cos(θ - φ) = e\n    //\n    // where α = sqrt(d² + b²) and φ = atan(b, d).\n    // the solution is given by\n    //\n    //   θ = φ ± acos(e / α)\n    //\n    // and r = 0.5 * θ.\n    \n    float a = dot(p0, p1);\n    float b = dot(p0, a1) + dot(p1, a0);\n    float c = dot(a0, a1);\n    \n    float d = (a - c - 2.);\n    float e = -(a + c);\n    \n    float alpha = length(vec2(d, b));\n    float phi = atan(b, d); // in [-pi, pi]\n    float tau = acos(e/alpha); // in [0, pi]\n\n    // we want the r with the least magnitude so choose tau with the \n    // opposite sign as phi\n    r = 0.5 * (phi > 0. ? phi - tau : phi + tau);\n\n    // now get c0 & c1\n    float cr = cos(r);\n    float sr = sin(r);\n\n    c0 = normalize(cr*p0 + sr*a0);\n    c1 = normalize(cr*p1 + sr*a1);\n    \n    // m is the midpoint of c0 & c1, the point\n    // of mutual tangency of the two arcs\n    m = normalize(c0 + c1);\n    \n    // get the line connecting c0 & c1\n    w = normalize(cross(c0, c1));\n    \n    // no longer need the sign of r, want it positive to compute distances later\n    r = abs(r);\n    \n    float d0 = darc(p, p0, c0, r, l0, w, m);\n    float d1 = darc(p, p1, c1, r, l1, w, m);\n        \n    return min(d0, d1);\n                     \n}\n\n//////////////////////////////////////////////////////////////////////\n// make a nice saturated color from a random color\n\nvec3 saturate_color(vec3 c) {\n    \n    float lo = min(c.x, min(c.y, c.z));\n    float hi = max(c.x, max(c.y, c.z));\n    \n    lo = min(lo, hi-0.05);\n    \n    return (c - lo) / (hi - lo);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// draw the Truchet tiling given unique id for the sphere\n\nvec3 draw_truchet(vec3 p, float id, float aa_scl) {\n\n    // generate some random variables for this sphere\n    vec3 r = hashwithoutsine31(19.*id + 101.);\n        \n    // choose tetraheral, octohedral, or icosahedral symmetry\n    float pqr_p = 3.0 + floor(r.x * 3.0);\n\n    // which of the 7 key points to place the vertex at?\n    int spoint = int(floor(r.y * 7.0));\n\n    // random bits used to influence shuffling & per-tile colors\n    float extra = r.z * 1024.;\n\n    // generate a random rotation for this sphere\n    vec3 axis_angle = 2.*PI*hashwithoutsine31(id);\n    \n    float angle = length(axis_angle);\n    vec3 axis = axis_angle / angle;\n    \n    // rotate the point\n    p = rotate(axis, angle)*p;\n    \n    \n    //////////////////////////////////////////////////\n    // do wythoff construction for this sphere\n        \n    mat3 verts, edges, poly_edges, M;\n    vec3 poly_vertex;\n    int vidx, eidx, vidx2;\n    float pdist_poly_edge;\n    \n    construct(vec3(pqr_p, 3, 2), spoint, p, \n              verts, edges, poly_vertex, poly_edges, \n              vidx, vidx2, eidx, M, pdist_poly_edge);\n    \n    \n    // get face background color\n    vec3 tri_vert = M * verts[vidx];\n    \n    vec3 face = M * verts[vidx];\n    vec3 face2;\n    \n    if (vidx2 == vidx) {\n        face2 = M * reflect(verts[vidx], poly_edges[eidx]);\n    } else {\n        face2 = M * verts[vidx2]; \n    }\n        \n    face = random_color_from_sphere(face);\n    face2 = random_color_from_sphere(face2);\n    \n    face = mix(face2, face, smoothstep(-0.5*aa_scl, 0.5*aa_scl, abs(pdist_poly_edge)));\n    \n    vec3 color = 0.3*face + 0.65;\n       \n    //////////////////////////////////////////////////\n    // construct the polygon by mirroring the \n    // polygon vertex around the triangle vertex\n    // until we get back to where we started\n       \n    vec3 polygon[MAX_POLYGON];\n    \n    int a_eidx = (vidx + 1) % 3;\n    int b_eidx = 3 - vidx - a_eidx;\n\n    vec3 a = edges[a_eidx];\n    vec3 b = edges[b_eidx];\n    \n    int npoly = make_polygon(poly_vertex, a, b, M, polygon);\n    \n    // get the lines / tangent vectors for each polygon\n    // edge, and get two node points per polygon edge    \n    vec3 pedges[MAX_POLYGON];\n    vec3 nodes[2*MAX_POLYGON];\n    \n    // array of indices that will be shuffled to \n    // connect pairs of nodes\n    int idx[2*MAX_POLYGON];\n\n    // precompute some coefficients to do \n    // spherical linear interpolation (slerp)\n    // along polygon edge\n    float p0p1 = dot(polygon[0], polygon[1]);\n    \n    float phi = acos(p0p1);\n    float sphi = sqrt(1.0 - p0p1*p0p1);\n    float u = 0.3;\n    \n    // here's the slerp weights!\n    float w0 = sin(u*phi)/sphi;\n    float w1 = sin((1.-u)*phi)/sphi;\n\n    // loop around the polygon generating nodes\n    // and edges\n    for (int i=0; i<MAX_POLYGON; ++i) {\n        \n        if (i >= npoly) { break; }\n        \n        vec3 p0 = polygon[i];\n        vec3 p1 = polygon[(i+1) % npoly];\n        \n        pedges[i] = normalize(cross(p0, p1));\n        \n        nodes[2*i+0] = w0*p0 + w1*p1;\n        nodes[2*i+1] = w1*p0 + w0*p1;\n        \n        idx[2*i+0] = 2*i+0;\n        idx[2*i+1] = 2*i+1;  \n        \n    }\n    \n    // now generate a random seed for this polygon face\n    const vec3 dir = vec3(0.876096, 0.80106629, 0.13512217);\n    float seed = floor(63.*dot(tri_vert, dir)+0.5) + extra;\n\n    // shuffle the order of nodes (we will connect up \n    // nodes with successive indices)\n    shuffle(idx, 2*npoly, seed);    \n\n    //////////////////////////////////////////////////\n    // time to draw the splines between the nodes\n\n    // for computing shadowing \n    float shadow = 1.0;\n    bool was_painted = false;\n    \n    // half-width of splines that connect the nodes\n    float width = 0.09*acos(p0p1);\n\n    // shadow size\n    float sz = 0.04 + 0.5*width;\n\n    // for each pair of nodes\n    for (int i=0; i<MAX_POLYGON; ++i) {\n    \n        if (i >= npoly) { break; }       \n        \n        // get points and tangent vectors\n        vec3 p0 = nodes[idx[2*i+1]];\n        vec3 l0 = pedges[idx[2*i+1]/2];\n\n        vec3 p1 = nodes[idx[2*i+0]];\n        vec3 l1 = pedges[idx[2*i+0]/2];\n \n        // compute distance to spline\n        float d = compute_spline(p, p0, l0, p1, l1);\n        \n        // deal with shadowing previously-drawn splines\n        bool is_painted = d < width + 0.005;\n        \n        if (is_painted) {\n            // current pixel in current spline, clear shadow\n            shadow = 1.0;\n            was_painted = true;\n        } else if (was_painted) {\n            // current pixel outside spline, shadow non-background pixels\n            shadow = min(shadow, smoothstep(width - 0.25*sz, width + sz, d));\n        }\n        \n        // pick a spline color\n        vec3 src_color = saturate_color(hashwithoutsine31(seed));\n        seed += 1.0;\n    \n        // draw outline and spline\n        color *= smoothstep(0.0, aa_scl, d-width-0.01);        \n        color = mix(src_color, color, smoothstep(0.0, aa_scl, d-width));\n\n    }\n    \n    // deal with shadowing\n    color *= shadow;\n    \n    if (texture(iChannel0, vec2(69.5/256.0, 0.75)).x > 0.) {\n        color *= smoothstep(0.0, aa_scl, abs(pdist_poly_edge)-0.005);\n    }\n        \n    // done!\n    return color;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// ray-sphere intersection\n\nconst vec4 miss = vec4(-1);\n\nvec4 trace_sphere(in vec3 o, in vec3 d, in vec3 ctr, in float r, \n                  out float edge) {\n\t\n    vec3 oc = o - ctr;\n    \n    float a = dot(d, d);\n    float b = 2.0*dot(oc, d);\n    float c = dot(oc, oc) - r*r;\n        \n    float D = b*b - 4.0*a*c;\n    \n    float tc = -dot(oc, d) / a;\n    \n    // distance from ray to sphere center, minus radius\n    // should be zero for rays tangent to sphere\n    edge = length(oc + tc*d) - r;\n        \n    if (D > 0.0) {\n        \n        float sqrtD = sqrt(D);\n        \n        float t = 0.5 * ( -b - sqrtD ) / a;\n        \n        if (t >= 0.0) {\n            vec3 n = normalize( oc + t*d );\n            return vec4(n, t);\t\n        }\n        \n    }\n    \n    return miss;\n\t\t\n}\n\n//////////////////////////////////////////////////////////////////////\n// do the things\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // distance from camera to sphere centers\n    const float cdist = 10.0;\n    \n    // focal length in pixels\n    float f = 0.25/iResolution.y;\n    \n    // pixel size on center of sphere for antialiasing\n    float aa_scl = (cdist - 1.0)*f;\n\n    // rotation vector\n    vec2 theta;\n    \n    // phase\n    float t = iTime;\n    \n    // default rotation\n    theta.y = 2.*PI*t/4.;\n    theta.x = 2.*PI*t/16.0; // note we add a wiggle to this below\n   \n    // scroll speed \n    float shift = 0.25*t;\n    \n    // mouse sets rx & ry\n    bool mouse_is_down = false;\n\n    if (max(iMouse.z, iMouse.w) > 0.05*iResolution.y) { \n        theta.x = (iMouse.y - .5*iResolution.y) * -5.0/iResolution.y; \n        theta.y = (iMouse.x - .5*iResolution.x) * 10.0/iResolution.x; \n        mouse_is_down = true;;\n    }\n\n    // integer and fractional part for drawing scrolling spheres\n    float scroll = shift - floor(shift+0.5);\n    float base_idx = -floor(shift+0.5);\n\n    // light direction\n    const vec3 L = normalize(vec3(-0.75, 1, -0.75));\n\n    // ray origin and direction\n    vec3 rd = normalize(vec3(f*(fragCoord.xy - 0.5*iResolution.xy), 1));\n    vec3 ro = vec3(0, 0, -cdist);\n    \n    // for drawing circle edges\n    float edge_min = 1e5;\n    vec3 color = vec3(1);\n    \n    // sphere spacing\n    const float spacing = 2.5;\n    \n    // max # of spheres\n    const float max_spheres = 3.0;\n    \n    // draw spheres (note we will intersect at most one of them)\n    for (float i=0.0; i<max_spheres; ++i) {\n    \n        // x coordinate of sphere center\n        float cx = (i - 0.5*max_spheres+0.5 + scroll)*spacing;\n\n        // raytrace to sphere\n        float edge;\n        vec4 intersect = trace_sphere(ro, rd, vec3(cx, 0, 0), 1.0, edge);\n        edge_min = min(edge, edge_min);\n\n        if (intersect.w >= 0.0) { // did we hit?\n                        \n            // figure out unique sphere id\n            float hit_idx = i + base_idx;\n        \n            // figure out whether to wiggle x rotation\n            float rx;\n        \n            if (mouse_is_down) {\n                rx = theta.x;\n            } else {\n                rx = 0.35*PI*sin(theta.x + 2.0*PI*hit_idx/8.);\n            }\n            \n            // intersection normal\n            vec3 p = intersect.xyz;\n\n            // rotate on sphere\n            vec3 Rp = rotate(vec3(0, 1, 0), theta.y)*rotate(vec3(1, 0, 0), rx)*p;\n\n            // draw our truchet tiling\n            color = draw_truchet(Rp, hit_idx, aa_scl);\n\n            // fake wrapped cosine lighting\n            color *= 0.2*dot(p, L) + 0.8;\n\n            // gentle specular highlight\n            vec3 h = normalize(L - rd);\n            float specAngle = max(dot(h, p), 0.0);\n            float specular = pow(specAngle, 30.0);\n\n            color = mix(color, vec3(1.0), 0.5*specular);\n\n            // no more spheres to hit, done!\n            break;\n            \n        } \n        \n    }\n\n    // draw sphere outline\n    color *= smoothstep(0.0, aa_scl, abs(edge_min)-0.005);\n\n    // \"gamma correct\" :P\n    color = pow(color, vec3(0.7));\n\n    fragColor = vec4(color, 1);\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}