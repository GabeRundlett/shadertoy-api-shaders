{
    "Shader": {
        "info": {
            "date": "1667308587",
            "description": "While I was creating another LEGO shader I decided to play around with domain repetition and ended up creating something that reminded me of a sea so I pushed the idea further and actually made a sea. ",
            "flags": 0,
            "hasliked": 0,
            "id": "mdS3zD",
            "likes": 19,
            "name": "Calm sea of LEGOÂ®",
            "published": 3,
            "tags": [
                "raymarching",
                "water",
                "lego",
                "ripple"
            ],
            "usePreview": 0,
            "username": "LongJohnny",
            "viewed": 530
        },
        "renderpass": [
            {
                "code": "// The sea of LEGOS\n//\n// While I was creating another LEGO shader I decided\n// to play around with domain repetition and ended up \n// creating something that reminded me of a sea so \n// I pushed the idea further and actually made a sea. \n//\n// The ripples are actually a very simple function, its a sine wave whose domain is clamped and\n// shifted over time. You can combine multiple similar functions and create the waves.\n//\n// The animation will change from smooth to stop-motion like\n// and then back to smooth every now and then because I explored\n// both effects and was torn between them so I decided to leave both :).\n//\n// I hope you enjoy it!\n// ----------------------------------------\n\nvec4 sdScene(vec3 p);\n\nvec4 rayMarch(vec3 ro, vec3 rd, out bool hit) {\n    \n    vec4 res = vec4(-1.); // color = xyz, distance = w \n    \n    float t = 0.;\n    for (int i = 0; i < MAX_MARCH_STEPS && t<MAX_MARCH_DIST; ++i) {\n        \n        vec4 ds = sdScene(ro + rd*t);   \n        if(ds.w*ds.w < 1e-6) {\n            res = vec4(ds.xyz, t);\n            hit = true;\n            break;\n        }\n        \n        t += ds.w;\n    }\n    \n    return res;\n}\n\n// Adapted from this shader by blackle: https://www.shadertoy.com/view/3lcBD2\nvec2 edge(vec2 p, float l) {\n    vec2 p2 = abs(p);\n    if (p2.x > p2.y) return vec2((p.x < 0.) ? -l : l, 0.);\n    else             return vec2(0., (p.y < 0.) ? -l : l);\n}\n\nfloat ripple(float x, float sc, float at, float t) {\n\n    // First wave\n    float w1 = sin(2.*clamp(x - t, -2.*PI*0.5, 0.));\n    \n    // Second wave\n    float w2 = (sin(2.*clamp(x - t, -4.5*PI*0.5, -2.5*PI*0.5))*0.5 + 0.5)*0.7;\n   \n    return (w1 + w2)*exp(-abs(x)*at)*sc;\n}\n\nfloat wave(float x, float z, float t) {\n    float ir = cos(z/5.)*0.5;\n    x += ir;\n    return exp(-max(0., (x - t)*2.))*(cos(clamp(x - t, -PI, 0.))*0.5 + 0.5);\n}\n\nvec4 sdScene(vec3 p) {\n    \n    // Repeat domain on the X and Z axis \n    float domainRepeat = BRICK_WIDTH*1.06;\n    vec3 p2 = p;\n    p2.xz = mod(p2.xz + 0.5*domainRepeat, domainRepeat) - 0.5*domainRepeat;\n    vec2 s = (p.xz - p2.xz);\n    vec2 e = edge(p.xz - s, domainRepeat);\n    vec2 s2 = s + e;\n    \n    // Base water movement\n    float h = (1. - texture(iChannel1, s.xy*0.1 - vec2(iTime*0.02)).r)*0.7;\n    \n    // Wave\n    float wt = mod(iTime, 20.);\n    float wh = max(.7, hash1(iTime - wt)*1. + 0.4);\n    float wv = wave((-s.y+s.x*0.2)*0.4 + 4.*PI, s.x, wt*2.)*wh;\n    h += wv;\n    \n    const float MAX_HEIGHT = 3.;\n    \n    float ds = 1000.;\n    vec3 col;\n    \n    // Falling brick\n    {\n        // Frequency of falling brick\n        float time = iTime*5.;\n        float t = mod(time,10.); \n        float ph = time - t;\n        \n        // Random value\n        vec2 r = hash21(round(ph + 100.));\n        float r2 = r.x;\n        \n        // Place where brick will fall\n        r.x *= 2.*PI; // Random angle\n        r.y *= 2.0 - 1.0; // Random offset\n        vec3 pos = vec3(cos(r.x)*3., 0., sin(r.x)) * (7.*r.y);\n        \n        // Brick transformations\n        vec3 p3 = p;\n        p3 -= vec3(0., 10.5 - pow(t, 0.5)*15., 0.) + pos;\n        p3.xy *= rot(t*PI + ph);\n        p3.xz *= rot(t*PI);\n        ds = sd1by1Brick(p3);\n        col = vec3(1., r2, 0.); \n        \n        // Ripple\n        float x = length(pos.xz - s.xy);\n        h += ripple(x, 2., .3, t*1.6);\n    }\n    \n    /*\n    // Falling brick 2\n    {\n        float time = iTime*5. - 5.;\n        float t = mod(time,20.); \n        float ph = time - t;\n\n        vec2 r = hash21(round(ph + 300.));\n        r.x *= 2.*PI; // Random angle\n        r.y *= 2.0 - 1.0; // Random offset\n\n        vec3 pos = vec3(cos(r.x)*3., 0., sin(r.x)) * (12.*r.y);\n        vec3 p3 = p;\n        p3 -= vec3(0., 10.5 - pow(t, 0.5)*20., 0.) + pos;\n        p3.xy *= rot(t*PI + ph);\n        p3.xz *= rot(t*PI);\n        ds = min(ds, sd1by1Brick(p3)*1.);\n        col = vec3(1., 1., 0.);\n        float x = length(pos.xz - s.xy);\n        h += ripple(x, 1., .3, t*1.6);\n    }\n    \n    // Falling brick 3\n    {\n        float time = iTime*5. - 10.;\n        float t = mod(time,20.); \n        float ph = time - t;\n\n        vec2 r = hash21(round(ph + 600.));\n        r.x *= 2.*PI; // Random angle\n        r.y *= 2.0 - 1.0; // Random offset\n\n        vec3 pos = vec3(cos(r.x)*3., 0., sin(r.x)) * (3.*r.y);\n        vec3 p3 = p;\n        p3 -= vec3(0., 10.5 - pow(t, 0.5)*15., 0.) + pos;\n        p3.xy *= rot(t*PI + ph);\n        p3.xz *= rot(t*PI);\n        ds = min(ds, sd1by1Brick(p3)*1.);\n        col = vec3(1., 0., 0.);\n        float x = length(pos.xz - s.xy);\n        h += ripple(x, 2., .4, t*1.6);\n    }\n    \n    // Falling brick 4\n    {\n        float time = iTime*5. - 16.;\n        float t = mod(time,20.); \n        float ph = time - t;\n\n        vec2 r = hash21(round(ph + 1000.));\n        r.x *= 2.*PI; // Random angle\n        r.y *= 2.0 - 1.0; // Random offset\n\n        vec3 pos = vec3(cos(r.x)*3., 0., sin(r.x)) * (3.*r.y);\n        vec3 p3 = p;\n        p3 -= vec3(0., 10.5 - pow(t, 0.5)*15., 0.) + pos;\n        p3.xy *= rot(t*PI + ph);\n        p3.xz *= rot(t*PI);\n        ds = min(ds, sd1by1Brick(p3)*1.);\n        col = vec3(1., 1., 0.);\n        float x = length(pos.xz - s.xy);\n        h += ripple(x, 3., .5, t*1.6);\n    }*/\n    \n    if ( mod(floor(iTime/15.),2.) != 0.) h = round(h*3.)/3.; \n    \n    // Ocean distance\n    float ds2 = sd1by1PlateInf(p - vec3(s.x, h, s.y));\n    ds2 = min(ds2, sd1by1PlateInf(p - vec3(s2.x, MAX_HEIGHT, s2.y)));    \n    if (ds2 < ds) {\n        col = mix(vec3(5.,63.,79.)/255., vec3(135.,159.,168.)/255.*2., smoothstep(0.65, 1.0, ((h/MAX_HEIGHT)*0.5 + 0.5)));\n        float tones = 20.;\n        col = ceil(col * tones) / tones;\n        col += hash12(s.xy*0.1)*0.02;\n        ds = ds2;\n    }\n    \n    return vec4(col, ds - 0.2*PIECES_SCALE);\n\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(vec3 p) // for function f(p)\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdScene( p + k.xyy*h ).w + \n                      k.yyx*sdScene( p + k.yyx*h ).w + \n                      k.yxy*sdScene( p + k.yxy*h ).w + \n                      k.xxx*sdScene( p + k.xxx*h ).w );\n}\n\n// iq's noise\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel2, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.27*mix( rg.x, rg.y, f.z );\n}\n\n// duke's stars\nvec3 stars(vec3 rd) {\n    vec3 stars = vec3(pn(rd*100.0)*0.4+0.5);\n    vec3 starbg = vec3(0.0);\n    starbg = mix(starbg, \n        vec3(255.,247.,90.)/255., \n        smoothstep(0.99, 1.0, stars)\n        );\n    return starbg;\n}\n\nvec3 renderScene(vec3 ro, vec3 rd, vec3 sky) {\n    \n    vec3 col = sky;\n    vec4 obj = vec4(0., 0., 0., 40.);\n\n    bool hit = false;\n    obj = rayMarch(ro, rd, hit);\n\n    if (hit) {\n        col = vec3(0.);\n\n        vec3 p = ro + rd*obj.w;\n        //vec3 p = obj.xyz;\n        vec3 n = calcNormal(p);\n        vec3 objCol = obj.xyz;\n\n        float R0 = pow((1. - 1.333)/(1. + 1.333),2.);        \n\n        // Side Light\n        {\n            vec3 ld = normalize(vec3(0.0, 0.3, 1.0));\n            float dif = max(0., dot(n, ld));\n\n            vec3 hlf = normalize(-rd + ld);\n            float spe = pow(max(0., dot(n, hlf)), 16.);\n            \n            float fr = R0 + (1. - R0)*pow(1. - dif, 5.);\n            \n            col += spe * vec3(250.,193.,138.)/255. * dif;\n            col += fr  * dif;\n        }\n        \n        // Sky light\n        {\n            vec3 ld = normalize(vec3(0.0, 1.0, 0.0));\n            float dif = max(0., dot(n, ld));\n\n            col += dif * objCol * 0.9;\n            col += sky * .2;\n        }\n\n        col = pow(col, vec3(1./.4545));\n        col = mix(sky, col, (MAX_MARCH_DIST - obj.w) / MAX_MARCH_DIST);\n\n    } else {    \n        obj.w = 40.;\n        col = col = mix(sky, col, (MAX_MARCH_DIST - obj.w) / MAX_MARCH_DIST);\n        col += stars(rd);// * sky * 5.;\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec3 origin = vec3(0.);\n   \n    vec3 ro = vec3(2.,7., -12.);\n    //ro.x += sin(iTime*0.2)*0.3;\n    //ro.y += cos(iTime*0.1)*1.; \n    \n    vec3 rd = rayDir(ro, origin, uv);\n    \n    vec3 sky = mix(vec3(250.,193.,138.)/255.*0.4, vec3(72.,74.,93.)/255.*0.4, uv.y*0.5 + 0.5);\n    \n    vec3 col = renderScene(ro, rd, sky);\n    \n    // Contrast\n    col.r = smoothstep(0.11, 1., col.r);\n    col.b = smoothstep(0.1, 1., col.b);\n    col.g = smoothstep(0.11, 1., col.g);\n    \n    // Vignette\n    col *= pow(-length(uv)+2., 0.6);\n    \n    // Gamma correct ^(1/2.2)\n    col = pow(col, vec3(.4545));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_MARCH_STEPS 400\n#define MAX_MARCH_DIST 30.\n#define MIN_MARCH_DIST 0.0001\n\n#define PI 3.14159265359\n\n#define PIECES_SCALE 0.1\n\n#define PLATE_HEIGHT (3.2 * PIECES_SCALE)\n#define BRICK_WIDTH (8. * PIECES_SCALE)\n#define BRICK_HEIGHT (9.6 * PIECES_SCALE)\n#define STUD_HEIGHT (1.6 * PIECES_SCALE)\n#define STUD_RADIUS (2.4 * PIECES_SCALE)\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\nvec3 rayDir(vec3 ro, vec3 origin, vec2 uv) {\n    \n    vec3 d = normalize(origin - ro);\n    \n    vec3 r = normalize(cross(vec3(0.,1.,0.), d));\n    vec3 u = cross(d, r);\n    \n    return normalize(d + r*uv.x + u*uv.y); \n}\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nbool intersectSphere(vec3 ro, vec3 rd, vec3 p, float r) {\n    vec3 oc = ro - p;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - r*r;\n    float h = b*b - c;\n    if( h<0.0 ) return false;\n    return true;\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\n/* ----- Iq's SDF functions (https://iquilezles.org/articles/distfunctions/) ---------- */\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox2( vec3 p, vec3 b )\n{\n  p.xz = abs(p.xz);\n  vec3 q = p - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  // return length(max(q,0.0)) + min(max(q.x,q.y,q.z),0.0) -> Pyramid top\n}\n\n\nfloat sdCappedCylinder( vec3 p, float r, float h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat dot2(in vec2 v) {\n    return dot(v,v);\n}\n\nfloat bb( vec2 p, vec2 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n// Awsome LEGO logo by mmalex: https://www.shadertoy.com/view/MsX3W2\nfloat lego(vec2 uv) { // x is -2 to 2\n    uv.x+=uv.y*-0.1; // italic\n    float oldx=uv.x;\n    uv.x=fract(uv.x)-0.5; // letter repeat\n    if (abs(oldx)>2.0) return 0.0; // clip!\n    float l;\n    if( oldx<0.0) {\n        // l and e\n        float e0=bb(uv-vec2(-0.15,0.0),vec2(0.2,0.0)); // cross of e \n        if (oldx>-1.0) uv.y=-abs(uv.y); else e0=1.0;\n        float l0=bb((uv)-vec2(0.0,-0.75),vec2(0.35,0.0)); // bottom of l\n        float l1=bb((uv)-vec2(-0.35,0.0),vec2(0.0,0.75)); // left of l                                              \n        l0=min(l0,e0);\n        l=min(l0,l1);                                        \n    } else {\n        l=abs(bb(uv,vec2(0.1,0.5))-0.25); // round o\n        if (oldx<1.0) {\n            // g - ugh nasty\n            if (uv.x>0.0 && uv.y>0.0 && uv.y<0.5)                                    \n                            l=bb((uv)-vec2(0.35,0.6),vec2(0.0,0.1));\n            float e0=bb(uv-vec2(0.2,0.0),vec2(0.15,0.0));\n            l=min(l,e0);\n        }\n    }              \n    return smoothstep(0.1,0.05,l);   \n}\n\n/* --- LEGO Common SDFs ---- */\nfloat sdStud(vec3 p) {\n    float ds = sdCappedCylinder(p - vec3(0.0, lego(p.xz*10.)*0.006, 0.0), STUD_RADIUS, .5*STUD_HEIGHT);  \n    return ds;\n}\n\nfloat sd1by1Plate(vec3 p) {\n    float ds = sdBox(p, vec3(.5*BRICK_WIDTH, .5*PLATE_HEIGHT, .5*BRICK_WIDTH ));\n    ds = min(ds, sdStud(p - vec3(0.0, .5*PLATE_HEIGHT + .5*STUD_HEIGHT, 0.0)));\n    return ds;\n}\n\nfloat sd1by1PlateInf(vec3 p) {\n    float ds = sdBox2(p, vec3(.5*BRICK_WIDTH, .5*PLATE_HEIGHT, .5*BRICK_WIDTH ));\n    ds = min(ds, sdStud(p - vec3(0.0, .5*PLATE_HEIGHT + .5*STUD_HEIGHT, 0.0)));\n    return ds;\n}\n\nfloat sd1by1Brick(vec3 p) {\n    float ds = sdBox(p, vec3(.5*BRICK_WIDTH, .5*BRICK_HEIGHT, .5*BRICK_WIDTH ));\n    ds = min(ds, sdStud(p - vec3(0.0, .5*BRICK_HEIGHT + .5*STUD_HEIGHT, 0.0)));\n    return ds;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}