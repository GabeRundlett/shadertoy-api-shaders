{
    "Shader": {
        "info": {
            "date": "1718004298",
            "description": "1",
            "flags": 0,
            "hasliked": 0,
            "id": "XXVGz3",
            "likes": 1,
            "name": "cube with spiral part",
            "published": 3,
            "tags": [
                "noise",
                "fbm",
                "star",
                "cinesahder"
            ],
            "usePreview": 0,
            "username": "nnew",
            "viewed": 77
        },
        "renderpass": [
            {
                "code": "vec2 kink(vec2 p, vec2 c, float k) {\n    p -= c;\n    //to polar coordinates\n    float ang = atan(p.x, p.y);\n    float len = length(p);\n    //warp angle with sigmoid function\n    ang -= ang/sqrt(1.+ang*ang)*(1.-k);\n    //to cartesian coordiantes\n    return vec2(sin(ang),cos(ang))*len + c;\n}\n\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// from iq\nfloat sdSine( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n\n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<24; i++ ) // 24 bit precision\n    {\n        float x = 0.5*(xa+xb);\n        float y = x-p.x+b*c*sin(x)*(p.y-b*c*cos(x));\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n   \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\n#define xor(a,b,c) min(max(a,-b), max(-a + c,b))\n\n#define pi acos(-1.)\n#define rmod(a,uv,md,amt) max(a, -abs(mod(atan((uv).y,(uv).x),md*pi) - md*pi*0.5) + md*pi*amt)\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\nreturn\n        mix(\n            mix(\n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            smoothstep(0.,1.,fr.y)\n            ),\n            mix(\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            smoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\nvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\nn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n   \n   \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n\nfloat df = 0.;\n\n// ----------\n\n\nvec2 guv;\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode){\n    //float dea = smoothstep(df,0.,da );\n    float deb = smoothstep(df,0.,db );\n   \n    //vec3 oa = mix(vec3(0),ca,dea);\n    vec3 ob = mix(vec3(0),cb,deb);\n    vec3 co = vec3(0);\n   \n    vec4 t = texture(iChannel2,guv);\n   \n    cb*=1. - smoothstep(1.,0.,abs(db)*7. + t.z*1.53)*0.2;\n   \n   \n    if(mode == 0){\n   \n        // 0 replace\n       \n    co = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.8), 4.25), 0.));\n    //co = mix( oa, cb, deb);\n\n    } else if(mode == 1){\n   \n        // 1 multiply\n   \n        co = mix(ca, ca*cb, deb);\n    } else if(mode == 2){\n   \n        // 2 overlay\n       \n        if (length(ca) < 0.5){\n    co = mix(ca, 2.*ca*cb, deb);    \n        } else {\n    co = mix(ca, 1. - 2.*(1. - ca)*(1. - cb), deb);\n       \n        }\n    } else if(mode == 3){\n   \n        // 3 darken\n       \n    co = mix(ca, min(ca,cb)*length(ca /* cb */), deb);\n    } else if(mode == 4){\n   \n        // 4 burn\n       \n    co = mix(ca, clamp(1.0 - (1.0 - ca) / cb,0.,1.), deb);\n    } else if(mode == 5){\n   \n        // 5 linear burn\n       \n    co = mix(ca, ca + cb - 1., deb);\n    } else if(mode == 6){\n   \n        // 6 color dodge\n       \n    co = mix(ca, length(ca) > .5 ? 1.0 - 2.0 * (1.0 - ca) * (1.0 - cb) : 2.0 * ca * cb, deb);\n    }\n    // return ;\n\n       \n    return co;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    df = dFdx(uv.x);\n   \n    guv = uv;\n    uv *= 0.5;\n    uv *= rot(-0.25*pi);\n    //uv = kink( uv, vec2(0.1), 0.5);\n   \n    uv += texture(iChannel1,uv).xy*0.003 + texture(iChannel2,uv*0.05).xy*0.01;\n\n    vec3 col = vec3(1.);\n\n   \n    vec2 A = vec2(-0.5,0.);\n    vec2 B = vec2(0.5,2.);\n   \n    vec2 offs = vec2(0.01,0.0);\n   \n   \n    float d = 10e5;\n   \n   \n    // -- //\n    d = 10e5;\n    //d = length(uv) - 0.15;\n\n    col = colour( d, col, vec3(0.1,0.5,0.1), 0);\n   \n    float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + 0.07)) * 2.2;\nfloat si = sin(t);\nfloat co = cos(t);\nmat2 ma = mat2(co, si, -si, co);\n    float iters = 5.;\n    for(float i = 0.; i < iters; i++){\n       \n        vec2 luv = uv*ma - vec2(cos(i/iters*pi*2.),sin(i/iters*pi*2.))*0.15;\n        luv*=2.;\n       \n    d = min(d,length(luv*ma) - 0.18);\n       \n    }\n    float db = 10e5;\n   \n    d = xor(d,sdBox(uv,vec2(0.13)),0.02);\n   \n    db = min(db,d);\n    col = colour( d, col, vec3(0.72,0.5,0.4), 3);\n   \n   \n    d = sdLine( uv - 0.1, vec2(-0.5,0.) , vec2(0.5,0.)) - 0.003;\n\n    db = min(db,d);\n    col = colour( d, col, vec3(0.7,0.5,0.1), 4);\n\n    d = sdLine( uv + 0.06, vec2(-0.5,0.) , vec2(0.5,0.)) - 0.003;\n\n    db = min(db,d);\n    col = colour( d, col, vec3(0.7,0.5,0.1), 4);\n\n   \n    d = sdLine( uv + vec2(0.09,0.06), vec2(-0.5,0.) , vec2(0.5,0.)) - 0.001;\n\n    db = min(db,d);\n    //col = colour( d, col, vec3(0.1,0.2,0.4)*5., 1);\n\n   \n   \n    d = sdLine( uv - vec2(0.09,0.21), vec2(-0.5,0.) , vec2(0.5,0.)) - 0.1;\n\n    db = min(db,d);\n    col = colour( d, col, vec3(0.1,0.0,0.1)*5., 2);\n\n    d = sdLine( uv + vec2(0.09,0.14), vec2(-0.5,0.) , vec2(0.5,0.)) - 0.1;\n\n    db = min(db,d);\n    col = colour( d, col, vec3(0.1,0.0,0.1)*3., 2);\n\n    d = xor(d,sdBox(uv,vec2(0.13)),0.02);\n   \n    col = colour( d, col, vec3(0.32,0.3,0.3)*2.4, 4);\n   \n   \n    d = xor(db,sdBox(uv*rot(-0.25*pi),vec2(0.49)),0.02);\n\n    float od = d;\n    //d = max(d, uv.x - 0.44);\n   \n    col = colour( d, col, vec3(0.42,0.14,0.1)*7.1, 1);\n   \n   \n    //od = abs(od + 0.04) + 0.00;\n    //col = colour( od, col, vec3(0.42,0.14,0.1)*1.1, 2);\n   \n   \n   \n    d = -sdBox((uv-0.01)*rot(-0.25*pi),vec2(0.26));\n   \n   \n   \n    //col = colour( d, col, vec3(0.05,0.14,0.1)*1.1, 3);\n    //col = colour( d, col, vec3(0.05,0.14,0.1)*0.1, 0);\n   \n   \n   \n   \n    col = colour( d, col, vec3(0.1,0.1,0.2)*4., 2);\n   \n   \n   \n   \n   \n   \n   \nvec4 f = smoothstep(0.,1.,fbm(uv*50.));\nvec4 g = smoothstep(0.,1.,fbm(uv*60. - 0.4));\n   \n    f.x = pow(f.x, 5.);\n   \n    float n = 0.;\n    n += f.x*.5;\n    n += pow(f.y,7.)*2.5;\n    n += pow(f.z,6.)*2.5;\n    n += pow(f.w,3.)*0.1;\n       \n    n += pow(g.x,6.)*3.;\n    n += pow(g.y,4.)*1.;\n    n += pow(g.z,4.)*1.;\n       \n   \n    n = min(n,0.5);\n   \n   \n    col = max(col,0.002);\n   \n    if(length(col) > 0.2){\n        vec3 nn = vec3(n*0.6,n,n)*1.4;\n        col *= 1. - nn;\n        //col -= pow(g,5.)*2.5;\n        //col -= pow(g,2.)*.9;\n    }\n    else{\n        col += pow(n,2.)*0.1;\n    //col += f*4.;\n   \n    }    \n   \n    col *= vec3(1.06,0.98,1.9);\n\n   \n    col = pow(col,vec3(0.5545));\n   \n   \n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}