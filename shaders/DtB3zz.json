{
    "Shader": {
        "info": {
            "date": "1672726547",
            "description": "Just playing around! Each pixel determines its probable color by comparing its surroundings to a reference bitmap (Buffer A). See options in the common script.",
            "flags": 32,
            "hasliked": 0,
            "id": "DtB3zz",
            "likes": 10,
            "name": "Beachgoers",
            "published": 3,
            "tags": [
                "ca",
                "cellularautomata",
                "annealing"
            ],
            "usePreview": 0,
            "username": "Zanzlanz",
            "viewed": 290
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // This is just to flip and rescale the image.\n    fragColor = vec4(texture(iChannel0, (1.0-fragCoord/iResolution.xy)/ZOOM).xyz, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Color index per pixel\nint f[240] = int[240](\n    0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,1,1,1,1,0,0,0,0,0,0,\n    0,1,2,1,2,1,1,0,0,0,0,0,\n    0,1,1,1,1,1,1,0,0,0,0,0,\n    0,1,1,2,2,1,1,0,0,0,0,0,\n    0,0,1,1,1,1,0,0,0,0,0,0,\n    0,0,0,1,1,0,0,0,0,0,0,0,\n    0,0,0,1,1,0,0,0,1,1,1,0,\n    0,0,1,1,1,0,0,1,2,1,2,1,\n    0,0,1,1,1,0,0,1,1,1,1,1,\n    0,0,1,1,1,0,0,1,1,2,2,1,\n    0,0,1,1,1,1,0,0,1,1,1,1,\n    0,0,0,1,1,1,0,0,0,1,1,0,\n    3,3,3,3,3,3,3,3,3,3,3,3,\n    0,0,0,0,3,3,3,0,0,3,3,3,\n    3,3,3,3,3,3,3,3,3,0,0,0,\n    0,3,0,0,0,3,3,3,0,0,3,3,\n    3,3,3,3,3,3,3,3,3,0,0,0,\n    3,0,0,0,3,0,0,0,0,3,3,3\n);\n\n// Index to color\nvec3 c[4] = vec3[4](\n    vec3(1.0, 1.0, 1.0),\n    vec3(.63, .21, .34),\n    vec3(.17, 0.0, 0.0),\n    vec3(.47, .69, .83)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Stretch the image across the whole buffer. I guess I could make it 1:1 pixel, but this is convenient for wrapping\n    int index = int(fragCoord.x/iResolution.x*INPUT_WIDTH)\n              + int(fragCoord.y/iResolution.y*INPUT_HEIGHT)*int(INPUT_WIDTH);\n    fragColor = vec4(c[f[index]], 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n * License:\n * Use freely!\n * \n * But I'd appreciate keeping a comment attributing @Zanzlanz or the ShaderToy link:\n * https://www.shadertoy.com/view/DtB3zz\n */\n\n\n// Any ol' noise function\nvec2 noise(vec2 v) {\n    v = fract(v) + fract(v*1e4) + fract(v*1e-4);\n    v += vec2(0.12345, 0.6789);\n    v = fract(v*dot(v, v)*123.456);\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Clips the output to the zoom level\n    if(fragCoord.x > iResolution.x/ZOOM || fragCoord.y > iResolution.y/ZOOM) discard;\n    \n    // Adds noise at the start and in the wave pattern to create chaos\n    if(iTime < .5 || abs(fragCoord.y + sin(iTime*.3+fragCoord.x*ZOOM/200.0)*iResolution.y/ZOOM*.4 - iResolution.y/ZOOM/2.0) < WAVE * 6.0) {\n        fragColor = vec4(texture(iChannel0, noise(fragCoord.xy/iResolution.xy).rg).rgb, 1.0);\n        return;\n    }\n    \n    // Calculate the most likely color based on the surroundings\n    int bestScore = 0;\n    vec2 bestScoreColor = vec2(0.0);\n    for(int inputX = 0; inputX < int(INPUT_WIDTH); inputX++) {\n        for(int inputY = 0; inputY < int(INPUT_HEIGHT); inputY++) {\n            int score = 0;\n            for(int kernelX = -KERNEL_SIZE; kernelX <= KERNEL_SIZE; kernelX++) {\n                for(int kernelY = -KERNEL_SIZE; kernelY <= KERNEL_SIZE; kernelY++) {\n                    if(kernelX == 0 && kernelY == 0) continue;\n                    if(\n                        texture(iChannel0, vec2((float(inputX+kernelX)+.5)/INPUT_WIDTH, (float(inputY+kernelY)+.5)/INPUT_HEIGHT))\n                        == texture(iChannel1, (fragCoord + vec2(float(kernelX), float(kernelY))) / iResolution.xy) ) {\n                        // I considered using a normal/gaussian distribution, but the results weren't worth it tbh\n                        score++;\n                    }\n                }\n            }\n            if(score > bestScore) {\n                bestScore = score;\n                bestScoreColor = vec2((float(inputX)+.5)/INPUT_WIDTH, (float(inputY)+.5)/INPUT_HEIGHT);\n            }\n        }\n    }\n    fragColor = texture(iChannel0, bestScoreColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// If you create a new picture in Buffer A, be sure to update these\n#define INPUT_WIDTH 12.0\n#define INPUT_HEIGHT 20.0\n\n// Zooms in to help with readability and speed\n#define ZOOM 4.0\n// This determines how many neighbors each pixel checks when annealing\n#define KERNEL_SIZE 4\n\n// You can turn off the wave by setting it to 0\n#define WAVE 1.0",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}