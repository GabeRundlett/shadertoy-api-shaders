{
    "Shader": {
        "info": {
            "date": "1658661170",
            "description": "CC0: Weird sunday shader\nI saw some pretty neat logo art and tried to recreate my old (1993) hacker handle (Lance) in that style\nKind of succeeded but then it was much more fun distorting the coordinate system\nThought it looks kind of neat so ",
            "flags": 0,
            "hasliked": 0,
            "id": "NdyBRd",
            "likes": 8,
            "name": "Weird sunday shader",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 301
        },
        "renderpass": [
            {
                "code": "// CC0: Weird sunday shader\n// I saw some pretty neat logo art and tried to recreate my old (1993) hacker handle (Lance) in that style\n// Kind of succeeded but then it was much more fun distorting the coordinate system\n// Thought it looks kind of neat so sharing it.\n\n\n// 0.45 looks neat too\n#define COLORTUNE   0.0\n\n\n#define TIME        iTime\n#define TTIME       (TAU*TIME)\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define SCA(a)      vec2(sin(a), cos(a))\n\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float df_size = 0.2;\nconst float df_linew = 0.04*df_size;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat arc(vec2 p, vec2 sc, float ra, float rb) {\n  p.x = abs(p.x);\n  return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                abs(length(p)-ra)) - rb;\n}\n\nfloat segmentx(vec2 p, float l) {\n  p.x = abs(p.x);\n  p.x -= 0.5*l;\n  float d0 = abs(p.y);\n  float d1 = length(p);\n  float d = p.x > 0.0 ? d1 : d0;\n  return d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r) {\n  const vec3 k = 0.5*vec3(-sqrt(3.0), 1.0, sqrt(4.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nvec2 toSmith(vec2 p)  {\n  // z = (p + 1)/(-p + 1)\n  // (x,y) = ((1+x)*(1-x)-y*y,2y)/((1-x)*(1-x) + y*y)\n  float d = (1.0 - p.x)*(1.0 - p.x) + p.y*p.y;\n  float x = (1.0 + p.x)*(1.0 - p.x) - p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 fromSmith(vec2 p)  {\n  // z = (p - 1)/(p + 1)\n  // (x,y) = ((x+1)*(x-1)+y*y,2y)/((x+1)*(x+1) + y*y)\n  float d = (p.x + 1.0)*(p.x + 1.0) + p.y*p.y;\n  float x = (p.x + 1.0)*(p.x - 1.0) + p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nfloat df_fork(vec2 p) {\n  const vec2 n = SCA(-PI/12.0);\n  p.x = abs(p.x);\n  p -= n*min(0.0, dot(p, n))*2.0;\n  return abs(p.x);\n}\n\nfloat df_l(vec2 p) {\n  vec2 p0 = p;\n  p0.x -= -df_size*sqrt(2.0/3.0);\n  p0 = p0.yx;\n  float d0 = segmentx(p0, df_size*2.0);\n  \n  vec2 p1 = p;\n  p1.y -= -df_size;\n  float d1 = segmentx(p1, df_size*sqrt(8.0/3.0));\n  \n  float d = d0;\n  d = min(d, d1);\n  \n  return d-df_linew;\n}\n\nfloat df_a(vec2 p) {\n  const float sc = sqrt(43.0/24.0);\n  const vec2 n = SCA(-PI/6.0);\n  p.y -= -df_size*sqrt(11.0/96.0);\n\n  vec2 p0 = p;\n  p0.x = abs(p0.x);\n  p0 -= n*min(0.0, dot(p0, n))*2.0;\n  float d0 = df_fork(p0-vec2(0.0, sc*df_size));\n\n  vec2 p1 = p;\n  float d1 = segmentx(p1, sqrt(4.0/3.0)*sc*df_size);\n  float d = d0;\n  d = min(d, d1);\n  return d-df_linew;\n}\n\nfloat df_n(vec2 p) {\n  vec2 p0 = p;\n  p0.x = abs(p0.x);\n  p0.x -= df_size*sqrt(2.0/3.0);\n  p0 = p0.yx;\n  float d0 = segmentx(p0, df_size*2.0);\n  \n  vec2 p1 = p;\n  p1 *= ROT(-PI/4.0);\n  float d1 = segmentx(p1, df_size*2.0);\n  \n  float d = d0;\n  d = min(d, d1);\n  \n  return d-df_linew;\n}\n\nfloat df_c(vec2 p) {\n  p = -p.yx;\n  return arc(p, SCA(5.0*PI/6.0), df_size, df_linew);\n  \n}\n\nfloat df_e(vec2 p) {\n  vec2 p0 = p;\n  p0.x -= -df_size*sqrt(2.0/3.0);\n  p0 = p0.yx;\n  float d0 = segmentx(p0, df_size*2.0);\n  \n  vec2 p1 = p;\n  p1.y = abs(p1.y);\n  p1.y -= df_size;\n  float d1 = segmentx(p1, df_size*sqrt(8.0/3.0));\n  \n  vec2 p2 = p;\n  float d2 = segmentx(p2, df_size);\n  \n  float d = d0;\n  d = min(d, d1);\n  d = min(d, d2);\n  \n  return d-df_linew;\n}\n\nvec3 df(vec2 p) {\n  vec2 op = p;\n  p.y -= df_size*sqrt(11.0/96.0);\n\n  const float sz = df_size*2.4;\n  p.x -= sz;\n  vec2 pl = p;\n  pl.x -= -2.0*sz;\n  float dl = df_l(pl);\n\n  vec2 pa = p;\n  pa.x -= -1.0*sz;\n  float da = df_a(pa);\n\n  vec2 pn = p;\n  pn.x -= 0.0*sz;\n  float dn = df_n(pn);\n  \n  vec2 pc = p;\n  pc.x -= 1.0*sz;\n  float dc = df_c(pc);\n  \n  vec2 pe = p;\n  pe.x -= 2.0*sz;\n  float de = df_e(pe);\n\n  vec2 ph = op;\n  ph.y -= -0.025;\n  ph = ph.yx;\n  float dh = -hexagon(ph, 1.99);\n  \n  float d = dl;\n  d = min(d, da);\n  d = min(d, dc);\n  d = min(d, dn);\n  d = min(d, de);\n  \n  return vec3(d, length(pa), dh);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\nvec2 transform(vec2 p) {\n  float a = TTIME/55.0;\n  p *= 3.3;\n  vec2 p0 = toSmith(p);\n  p0 += vec2(1.0, -1.0)*mix(-1.0, 1.0, smoothstep(-0.25, 0.25, -sin(0.5*a)));\n  vec2 p1 = toSmith(p);\n  p1 *= ROT(-a);\n  p = fromSmith(p0*p1.yx);\n  p *= ROT(0.5*dot(p, p));\n  p -= -TIME*0.1;\n  return p;\n}\n\nvec3 effect(vec2 p) {\n  const float iz = 4.0;\n  p = transform(p);\n  float aa = iz*length(fwidth(p))*sqrt(0.5);\n  vec2 n = hextile(p);\n  p *= iz;\n  vec3 d3 = df(p);\n  float d = d3.x;\n  float g = d3.y;\n  float dd = d3.z;\n  const float hoff = COLORTUNE;\n  const vec3 bcol  = HSV2RGB(vec3(hoff+0.64, 0.9, 1.5));\n  const vec3 gcol  = HSV2RGB(vec3(hoff+0.61, 0.9, 1.0));\n  const vec3 bbcol = HSV2RGB(vec3(hoff+0.64, 0.75, 0.66));\n  const vec3 scol  = HSV2RGB(vec3(hoff+0.55, 0.925, 3.0));\n \n  float amb = mix(0.025, 0.1, tanh_approx(0.1+0.25*g+0.33*p.y));\n\n  vec3 col = vec3(0.0);\n  \n  col = mix(col, 5.0*sqrt(amb)*bcol, smoothstep(aa, -aa, d));\n  col = mix(col, 4.0*sqrt(amb)*bbcol, smoothstep(aa, -aa, dd));\n  col += 0.125*bcol*exp(-12.0*max(min(d, dd), 0.0));\n  col += gcol*amb;\n  col += scol*aa;\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);;\n  col *= smoothstep(0.0, 4.0, TIME-dot(p, p));\n  col = aces_approx(col);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}