{
    "Shader": {
        "info": {
            "date": "1464734529",
            "description": "Style practice. based on http://patriciogonzalezvivo.com/2015/thebookofshaders/07/ ",
            "flags": 0,
            "hasliked": 0,
            "id": "MsyXDw",
            "likes": 38,
            "name": "Gear Designs [Commented]",
            "published": 3,
            "tags": [
                "2d",
                "gears",
                "smoothstep",
                "variation"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 2243
        },
        "renderpass": [
            {
                "code": "\n//Refactored 2023\n\n//define smoothstep as S so less typing\n#define S smoothstep \n//define PI hardcoded or slower way acos(-1.)\n#define PI 3.14159265359 \n\n//Colors\nvec3 white = vec3(1.0,1.0,1.0);\nvec3 grey = vec3(0.5,0.5,0.5);\nvec3 lightgrey = vec3(0.8,0.8,0.8);\nvec3 darkgrey = vec3(0.2,0.2,0.2);\nvec3 blue = vec3(.0,0.2,0.9);\n\n//Random Function (google the book of shaders)\nfloat rnd(float a){\n    return fract(sin(a*245.33)*43254.452);\n}\n\n//p = uv, spoke we know,spike num is random, thickness is how hollowed out\n//the shape is\nvec3 outerGear(vec2 p, vec3 spoke, float spikenum, float thickness){\n\n    // get polar coordinates \n    // \"a\" = angle of pixel around center, \n    // \"l\" = pixel distance/length to center   \n    float a = atan(p.y, p.x)+ iTime;//iTime to rotate\n    float l = length(p)*2.0;\n    \n    //create the main gear shape\n    float mainShape = cos(a*spikenum);\n    \n    //smooth function on the shape\n    float g = S(-.95, -.5, mainShape)*0.06+0.5;\n    \n    \n    float midgear = 1.0-S(g-0.02,g+0.03, l*1.1);\n    \n    //create a cutout shape also smoothed\n    float xshole = 1.0-S(g,g+0.03, l*thickness);\n    \n    //subtract the hole from the midgear to get the final outegear shape\n    vec3 outegearShape = vec3(midgear-xshole)*vec3(1.0,1.0,1.0);\n    \n    //add outegearShape and spokes naively and return\n    vec3 outcolor =  outegearShape  + spoke;\n    return outcolor;\n    }\n\n//This creates the blue spokes\n//it takes in position of the pixel in which ever\n//cell it's in (0 - 8)\n//a random number of spokes\n//and an id (0 - 8)\nvec3 spokes(vec2 p, float spokenum, float id){\n\n    // get polar coordinates \n    // \"a\" = angle of pixel around center, \n    // \"l\" = pixel distance/length to center   \n    float a = atan(p.y, p.x)+ iTime;//iTime to rotate\n    float l = length(p)*2.0;\n    \n    //adjust id from (1,2...9) to be 1,2 or 3 using mod\n    id = mod(id,3.);\n    \n    //We start with a blue circle and turn it into spokes\n    //by calculating h (height from center) using the angle around \n    //the center for each pixel (google the book of shaders)\n    float h = 0.;\n    \n    //Here are our three spoke variations using lot's of magic numbers\n    // but there are the same in each column which follows the mod 3 \n    // operation we did to our id. It makes sense when you know how the \n    //origional id was calculated\n    if(id < 1.){\n        h = pow(abs(fract(a*spokenum)*2.000-1.000)+0.236,3.976)/6.976+.128;\n    }\n    else if(id <2.){\n        h =  pow(abs(fract(a*spokenum)*2.-0.848),-0.136)/5.992;\n    }\n    else{\n        h = (abs(fract(a*spokenum+l*4.)*2.-1.)-0.240)*0.456+0.1828;\n    }\n    \n    //then we smoothstep that spoke shape with some magic numbers\n    float spokes = 1.0-S(h-0.09,h+0.03, l);\n    \n    //multiply the color in and return\n    vec3 spokes3 = blue*spokes; \n    return spokes3; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //we use the non adjusted uv so we can mod with 3 later\n    vec2 uv = (fragCoord.xy)/iResolution.xy;\n    \n    //need aspect ratio to fix the cell heights after creating them\n    float asp = iResolution.x/iResolution.y;\n    \n    //staring color\n    vec3 color = darkgrey;\n    \n    //we mod with 3 to get 3 rows\n    vec2 fuv = mod(uv*3.,1.)-0.5;\n    \n    //adjust the y with aspect ratio to fix dimentions\n    fuv.y/=asp;\n    \n    //calculate ids based on x + y*3 to get 0,2...8\n    float id = floor(uv.x*3.)+floor(uv.y*3.)*3.;\n    \n    //create just the blue spokes\n    vec3 spoke = spokes(fuv,2.10, id);\n    \n    //pass the blue spoke and some random values in to the outerGear \n    //function to create the white outer gear shape\n    color+=outerGear(fuv, spoke, rnd(id+34.23)*40., 1.+rnd(id));\n\n    //final color\n\tfragColor = vec4(color,1.0);\n}\n\n\n/*\n//Original\n//we now write smoothstep with only one letter; S!\n#define S smoothstep \nvec3 white = vec3(1.0,1.0,1.0);\nvec3 grey = vec3(0.5,0.5,0.5);\nvec3 lightgrey = vec3(0.8,0.8,0.8);\nvec3 darkgrey = vec3(0.2,0.2,0.2);\n\nvec3 gear2(vec2 p, vec3 s, float spikenum, float thickness){\n\n        float a = atan(p.y, p.x)+ iTime;\n        float l = length(p)*2.0;\n        float g = S(-.95, -.5, cos(a*spikenum))*0.06+0.5;\n            \n            //float gear = 1.0-S(g,g+0.03, l);   //takes waveform as bounds\n            float midgear = 1.0-S(g-0.02,g+0.03, l*1.1);\n            //float biggear = 1.0-S(g,g+0.0003, l);\n            float xshole = 1.0-S(g,g+0.03, l*thickness);//or3\n                \n          \n    \n    vec3 mainplates = vec3(midgear-xshole)*vec3(1.0,1.0,1.0);\n   // vec3 rims = vec3(gear-biggear)*vec3(0.3,0.0,1.0) ;\n    //vec3 spokes3 = s;// vec3(.0,0.2,0.9)*spokes;  \n    vec3 outcolor =  mainplates  + s;//spokes3;\n    \n    return outcolor;\n \n    }\n\nvec3 spokes1(vec2 p, float spokenum){\n    float a = atan(p.y, p.x)+ iTime;\n    float l = length(p)*2.0;\n    \n    float h = (abs(fract(a*spokenum+l*4.)*2.-1.)-0.240)*0.456+0.1828;\n    float spokes = 1.0-S(h-0.09,h+0.03, l);\n    vec3 spokes3 = vec3(.0,0.2,0.9)*spokes; \n    \n    return spokes3; \n}\n\nvec3 spokes2(vec2 p, float spokenum){\n    float a = atan(p.y, p.x)+ iTime;\n    float l = length(p)*2.0;\n    \n    float h =  pow(abs(fract(a*spokenum)*2.-0.848),-0.136)/5.992;\n    float spokes = 1.0-S(h-0.09,h+0.03, l);\n    vec3 spokes3 = vec3(.0,0.2,0.9)*spokes; \n    \n    return spokes3; \n}\n\nvec3 spokes3(vec2 p, float spokenum){\n    float a = atan(p.y, p.x)+ iTime;\n    float l = length(p)*2.0;\n    \n    float h = pow(abs(fract(a*spokenum)*2.000-1.000)+0.236,3.976)/6.976+.128;\n    float spokes = 1.0-S(h-0.09,h+0.03, l);\n    vec3 spokes3 = vec3(.0,0.2,0.9)*spokes; \n    \n    return spokes3; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n    \n    vec3 color = darkgrey;\n    \n\n    //1.752 for 1\n    //2.208 for2\n    //1.752 for 3\n    color+=gear2(vec2(pos.x + 1.2, pos.y+ 0.6), spokes1(vec2(pos.x + 1.2, pos.y+ 0.6),2.10/4.0), 10.0, 1.8);\n    color+=gear2(vec2(pos.x + 0.0, pos.y+ 0.6), spokes2(vec2(pos.x + 0.0, pos.y+ 0.6),2.208), 20.0, 1.0);\n    color+=gear2(vec2(pos.x - 1.2, pos.y+ 0.6), spokes3(vec2(pos.x - 1.2, pos.y+ 0.6),0.632), 40.0, 1.3);\n    color+=gear2(vec2(pos.x + 1.2, pos.y+ 0.0), spokes1(vec2(pos.x + 1.2, pos.y+ 0.0),2.208*2.0), 20.0, 1.4);\n    color+=gear2(vec2(pos.x + 0.0, pos.y+ 0.0), spokes2(vec2(pos.x + 0.0, pos.y+ 0.0),2.208), 5.0, 2.4);\n    color+=gear2(vec2(pos.x - 1.2, pos.y+ 0.0), spokes3(vec2(pos.x - 1.2, pos.y+ 0.0),0.632), 25.0, 1.9);\n    color+=gear2(vec2(pos.x + 1.2, pos.y- 0.6), spokes1(vec2(pos.x + 1.2, pos.y- 0.6),2.208), 35.0, 1.1);\n    color+=gear2(vec2(pos.x + 0.0, pos.y- 0.6), spokes2(vec2(pos.x + 0.0, pos.y- 0.6),2.208), 15.0, 1.7);\n    color+=gear2(vec2(pos.x - 1.2, pos.y- 0.6), spokes3(vec2(pos.x - 1.2, pos.y- 0.6),0.632), 3.0, 1.4);\n   \n\n\tfragColor = vec4(color,1.0);\n}\n\n\n*/\n\n/*\n//extra stuff part 1\nvec3 makespokes(float h){\n    float a = atan(p.y, p.x)+ iTime;\n    float l = length(p)*1.0;\n\tfloat spokes = 1.0-smoothstep(h-0.09,h+0.03, l);\n    vec3 spokes3 = vec3(.0,0.2,0.9)*spokes;\n    return 1.;\n    \n}*/\n\n/*\n//extra stuff part 2\nvec3 gear1(vec2 p){\n\n        //rotate based on time\n        float a = atan(p.y, p.x)+ iTime;\n        //make that circular gradient\n        float l = length(p)*1.0;\n        \n        float g = S(-.5, 1.0, cos(a*10.0))*0.13+0.5;\n            \n            float gear = 1.0-S(g,g+0.03, l);   //takes waveform as bounds\n            float midgear = 1.0-S(g-0.02,g+0.03, l*1.1);\n            float biggear = 1.0-S(g,g+0.03, l*1.05);\n            float xshole = 1.0-S(g,g+0.03, l*2.0);//or3\n                \n            float outline = 1.0-S(g-0.2, g-0.1, l) - S(g-0.1, 0.4,  l); \n            float outline2 = 1.0-S(g-0.2, g-0.1, l) - S(g-0.1, 0.4,  l); \n\n    float h = S(-2.5,1.1, cos(a*10.0+3.1))*.25+0.02;\n    \tfloat spokes = 1.0-S(h-0.09,h+0.03, l);\n    \n    \n    \n    vec3 fullgear = vec3(gear-biggear+midgear-xshole+spokes)*vec3(1.0,1.0,1.0);\n    vec3 mainplates = vec3(midgear-xshole)*vec3(1.0,1.0,1.0);\n    vec3 rims = vec3(gear-biggear)*vec3(0.3,0.0,1.0) ;\n    vec3 spokes3 = vec3(.0,0.2,0.9)*spokes;  \n    vec3 outcolor =  mainplates + rims + spokes3;\n    \n    return outcolor;\n \n    }\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}