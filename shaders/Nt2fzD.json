{
    "Shader": {
        "info": {
            "date": "1652713172",
            "description": "Space donuts - cause time has stopped moving for me..",
            "flags": 0,
            "hasliked": 0,
            "id": "Nt2fzD",
            "likes": 25,
            "name": "Space Donuts Yumm",
            "published": 3,
            "tags": [
                "reflection",
                "torus",
                "raymarcing",
                "donuts"
            ],
            "usePreview": 1,
            "username": "byt3_m3chanic",
            "viewed": 389
        },
        "renderpass": [
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n        \n    Space Donuts | 5/15/22  \n    byt3_m3chainc\n\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.1415926535\n#define PI2 6.2831853071\n\n#define MIN_DIST .0001\n#define MAX_DIST 90.\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(215.23,41.232)))*4123.2323); }\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.-2.*f);\n    return mix( mix( hash21( i + vec2(0,0) ), \n                     hash21( i + vec2(1,0) ), u.x),\n                mix( hash21( i + vec2(0,1) ), \n                     hash21( i + vec2(1,1) ), u.x), u.y);\n}\n\n//@iq torus\nfloat torus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 hit,hitPoint,sto,gto;\nvec2 gid,sid;\nfloat time;\nmat2 r90;\nfloat zoom = 35.;\nconst vec2 sc = vec2(.125), hsc = .5/sc; \n\nvec2 map(vec3 p) {\n    p.y+=1.;\n    p.x+=T*1.5;\n    \n    vec3 qq=p;\n    vec2 id=floor((p.xz-7.)/14.);\n    float hs = hash21(id);\n    p.xz=mod(p.xz-7.,14.)-7.;\n    \n    vec2 res = vec2(1e5,0);\n    vec3 q = p-vec3(0,1.05,0);\n    \n    float fs = (.1+hs);\n    float rbase = (fs*2.)+T;\n    q.yz*=rot(rbase*fs);\n    q.xy*=rot(rbase*.75*fs);\n\n    float ns = noise(q.xz)*2.;\n    float b2 = torus(q,vec2(2.75 ,1.25 ))-(ns*.15);\n    float b3 = torus(q,vec2(2.75 ,1.265 ))-(ns*.2);\n    float wv = .2*sin(q.x*3.2)+.2*cos(q.z*2.2);\n    float fq = q.y -wv;\n    b3=max(fq,b3);\n    \n    if(b2<res.x) {\n        res = vec2(b2,3.);\n    \thit=q;\n        gid=id;\n        gto=vec3(id,.5);\n    }\n\n    if(b3<res.x) {\n        res = vec2(b3,4.);\n    \thit=q;\n        gid=id;\n        gto=vec3(id,.5);\n    }\n\n    // I am clueles on how to place ojects on the\n    // surface - so here I make a circle of sprinkles\n    // in a circle around the torus..\n    \n    // it's hacky - so if there is a better way let\n    // me know\n    \n    vec3 q1=q;\n    float amount = 32.;\n    //@Shane polar rep\n    float a = atan(q1.z, q1.x);\n    float ia = floor(a/PI2*amount);\n    ia = (ia + .5)/amount*PI2;\n\n    float qd = -mod(ia,.0);\n\n    mat2 rxa = rot(ia);\n    q1.xz *= rxa;\n    q1.xy -= vec2(2.715,0);\n\n    amount = 12.;\n    vec3 q2 = q1;\n    \n    q2.xz*=r90;\n    \n    a = atan(q2.z, q2.y);\n    float da = floor(a/PI2*amount);\n    da = (da + .5)/amount*PI2;\n    float dd = mod(da,.0);\n\n    rxa = rot(da);\n    q2.yz *= rxa;\n    q2.yx -= vec2(1.4+(ns*.15),0);\n    \n    float xs = hash21(vec2(qd,dd));\n    \n    float d5 = length(q2)-.115;\n\n    if(xs<.6) d5=1.;\n    \n    if(d5<res.x &&q.y<0.) {\n        res = vec2(d5,6.);\n    \thit=q;\n        gid=vec2(qd,dd)+id;\n        gto=vec3(id,.5);\n    }\n    \n    // floor\n    float d9 = qq.y;\n    d9 = max(d9,-(length(q)-5.25));\n    if(d9<res.x) {\n        res = vec2(d9,1.);\n    \thit=qq;\n        gid=id;\n        gto=vec3(id,.5);\n    }\n\n    return res;\n}\n\n// Tri-Planar blending function. Ryan Geiss: \n// https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;//vec3(noise(p.yz*22.));\n    vec3 ty = texture(t, p.zx).xyz;//vec3(noise(p.zx*22.)); \n    vec3 tz = texture(t, p.xy).xyz;//vec3(noise(p.xy*22.)); \n    //return mat3(tx*tx, ty*ty, tz*tz)*n;\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n// https://www.shadertoy.com/view/ld3yDn\nvec3 doBumpMap( sampler2D tx, vec3 p, vec3 n, float bf, float per){\n    vec2 e = vec2(per*MIN_DIST, 0);   \n    mat3 m = mat3( \n        tex3D(tx, p - e.xyy, n), \n        tex3D(tx, p - e.yxy, n), \n        tex3D(tx, p - e.yyx, n)\n    );\n\n    const vec3 gn = vec3(0.580,0.839,0.420);\n    vec3 g = gn* m; \n    g = (g - dot(tex3D(tx,  p , n), gn) )/e.x; g -= n*dot(n, g);  \n    return normalize( n + g*bf );\n}\n\nvec3 normal(vec3 p, float t){\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec3 hue(float t, vec3 d) { \n    return .375 + .375*cos(PI2*t*(vec3(.985,.98,.95)+d)); \n}\n\nvec4 FC = vec4(0.306,0.337,0.353,0.);\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec3 p = ro;\n    \n    for(int i=0;i<75;i++)\n    {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<32? ray.x*.5: ray.x;\n        m  = ray.y;\n    } \n\n    hitPoint = hit;\n    sid = gid;\n    sto = gto;\n    \n    float alpha = 0.;\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(1,18,-13);\n        vec3 l = normalize(lpos-p);\n\n        if(m==3.){\n            vec3 hp = hitPoint;\n            n = doBumpMap(iChannel0, hp*.075, n, .005 ,d);\n        }\n        \n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = 1.0;\n        for( float t=.01; t < 18.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), 14.);\n\n        vec3 h = vec3(.5);\n        \n        if(m==1.) {\n            vec3 hp = hitPoint*sc.xxx;\n            h = vec3(.7);\n            vec2 f = fract(hp.xz*3.)-.5;\n            if(f.x*f.y>0.) h=clamp( hue( sin(hp.x*.25),vec3(0.961,0.541,0.220) )+.2,vec3(0),vec3(1) );\n            if(hp.y<.0)h=vec3(.8);\n            ref = vec3(h*.5);\n        }\n        \n        if(m==2.) {\n            h=vec3(.5);\n            ref = h;\n        }\n        \n        if(m==3.) {\n            h=mix(vec3(0.573,0.310,0.008),vec3(0.914,0.714,0.169),clamp((hitPoint.y-.25)*.5,0.,1.));\n            ref = vec3(.001);\n        }\n        \n        if(m==4.) {\n            h=hue(3.+hash21(sid)*1.3,vec3(0.220,0.875,0.961));\n            ref = h;\n        }\n        \n        if(m==6.) {\n            h=hue(3.+hash21(sid)*.25,vec3(0.914,0.169,0.753));\n            ref = h;\n        }\n        \n        C = h*diff+min(shdw,spec);\n        C = mix(FC.rgb,C,  exp(-.0000025*d*d*d));\n    \n        ro = p+n*.01;\n        rd = reflect(rd,n);\n    \n    }\n    \n    return vec4(clamp(C,vec3(.03),vec3(1.)),alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    time = T*.75;\n    r90=rot(1.5707);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    if(uv.x>0.)zoom=20.;\n    vec3 ro = vec3(uv*zoom,-zoom);\n    vec3 rd = vec3(0,0,1.);\n    mat2 rx = rot(-45.*PI/180.);\n    mat2 ry = rot(-.78*sin(T*2.*PI/180.));\n    ro.yz *= rx;ro.xz *= ry;\n    rd.yz *= rx;rd.xz *= ry;\n\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0); \n    vec3 fil=vec3(1);\n    \n    float d =0.;\n    float bnc = 2.;\n    \n    for(float i=0.; i<bnc; i++) {\n        d =0.;\n        vec4 pass = render(ro, rd, ref, i==bnc-1., d);\n        C += pass.rgb*fil;\n        fil*=ref;\n    }\n\n    C=clamp(C,vec3(.01),vec3(1.));\n    if(uv.x<.001&&uv.x>-.001)C=vec3(1);\n    // gamma correction\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}