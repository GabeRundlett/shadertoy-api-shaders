{
    "Shader": {
        "info": {
            "date": "1623129208",
            "description": "Some nice path-traced clouds.",
            "flags": 32,
            "hasliked": 0,
            "id": "7tfGDs",
            "likes": 17,
            "name": "Colorfully Lit Clouds",
            "published": 3,
            "tags": [
                "raymarching",
                "ray",
                "raymarch",
                "raymarched",
                "gi",
                "volumetric",
                "raymarcher",
                "pathtrace",
                "pathtracing",
                "pathtracer",
                "trace",
                "path",
                "pathtraced"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 554
        },
        "renderpass": [
            {
                "code": "// ####### Colorfully Lit Clouds #######\n// Made by Jacob Bingham (Zi7ar21) on June 7th, 2021\n// Last Updated on June 7th, 2021 at 11:10 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/7tfGDs\n\n// Check out my friends!\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n// Dumb_Psycho\n// https://www.shadertoy.com/user/Dumb_Psycho\n\n// Image Preview\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Final Image\n    vec3 color = texel0.rgb;\n\n    // HDR Tonemapping\n    color = HDRtoLDR(color);\n\n    // Output the Image Preview\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ##### Parameters #####\n\n// Gamma Correction (Affects Preview Only, Image Export is Linear)\n#define gamma 2.2\n\n// Camera Field of View\n#define camfov 1.0\n\n// 1U = Direct Lighting\n// 4U = Eh, at least it's lit up\n// 8U = Good Global Illumination\n// 32U = Great Global Illumination\n// 128U = Perfect Global Illumination\n// 1024U = Absolutely no sane reason to go any higher\n#define maxBounces 8U\n\n// 0.25 = Garbage Density\n// 0.125 = Poor Density\n// 0.0625 = Great Density\n// 0.01 = Unreasonable and Very Slow, don't go any lower unless you are sampling really close objects\n//#define stepSize 0.0625\n#define stepSize 0.0625\n\n// 128U = Garbage Sampling\n// 1024U = OK Sampling\n// 8192U = Great Sampling\n// 65536U = Perfect Sampling, no need to go any higher\n#define maxStep 8192U\n// Note: use a low value and adjust the stepSize first, and then increase until nothing changes\n\n// ##### Constants #####\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n\n// ##### Shortcuts #####\n\n// Traditional Input Names\n#define resolution iResolution\n#define frame iFrame\n\n// Sample Buffer\n#define texel0 texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0)\n#define texel1 texelFetch(iChannel1, ivec2(gl_FragCoord.xy), 0)\n#define texel2 texelFetch(iChannel2, ivec2(gl_FragCoord.xy), 0)\n#define texel3 texelFetch(iChannel3, ivec2(gl_FragCoord.xy), 0)\n\n// ##### Color Management #####\n\n// HDR Tonemapping Function\nvec3 HDRtoLDR(vec3 color)\n{\n    // Ensures that there is no values less than 0.0\n    color = max(color, 0.0);\n\n    // Sh*t Color Space Thing\n    color = vec3(\n    (color.r*1.00)+(color.g*0.05)+(color.b*0.03),\n    (color.r*0.05)+(color.g*1.00)+(color.b*0.04),\n    (color.r*0.03)+(color.g*0.04)+(color.b*1.00));\n\n    // Fit values to 0.0-1.0 and apply Gamma Correction\n    color = pow(color/(color+1.0), vec3(1.0/gamma));\n\n    // Return the Color\n    return clamp(color, 0.0, 1.0);\n}\n\n// ##### Random Number Generator #####\n\n// triple32 \"Best\" Integer Hash: https://www.shadertoy.com/view/WttXWX\nuint triple32(uint x)\n{\n    x ^= x >> 17U;\n    x *= 0xED5AD4BBU;\n    x ^= x >> 11U;\n    x *= 0xAC4C1B51U;\n    x ^= x >> 15U;\n    x *= 0x31848BABU;\n    x ^= x >> 14U;\n    return x;\n}\n// Honestly you should look into PCG Random for your own projects\n// I just used triple32 because the code looks elegant\n\n// Random Number Generator Seed\nuint ns;\n\n// Initialize Seed\n#define initializeRNG ns = uint(frame)*uint(resolution.x*resolution.y)+uint(gl_FragCoord.x+gl_FragCoord.y*resolution.x)\n//#define initializeRNG ns = uint(frame)\n\n// Random Scalar from 0.0 to 1.0\nfloat rand()\n{\n    ns = triple32(ns);\n    return float(ns)/float(0xFFFFFFFFU);\n}\n\n// Random Vectors\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand2(), rand());}\nvec4 rand4(){return vec4(rand3(), rand());}\n\n// Normalized Random Vectors: https://www.shadertoy.com/view/WttyWX\nvec2 nrand2(float sigma, vec2 mean)\n{\n    vec2 z = rand2();\n    return mean+sigma*sqrt(-2.0*log(z.x   ))*vec2(cos(2.0*pi*z.y), sin(2.0*pi*z.y));\n}\n\nvec3 nrand3(float sigma, vec3 mean)\n{\n    vec4 z = rand4();\n    return mean+sigma*sqrt(-2.0*log(z.xxy ))*vec3(cos(2.0*pi*z.z), sin(2.0*pi*z.z), cos(2.0*pi*z.w));\n}\n\nvec4 nrand4(float sigma, vec4 mean)\n{\n    vec4 z = rand4();\n    return mean+sigma*sqrt(-2.0*log(z.xxyy))*vec4(cos(2.0*pi*z.z), sin(2.0*pi*z.z), cos(2.0*pi*z.w), sin(2.0*pi*z.w));\n}\n\n// Uniform Random Vectors\nvec2 urand2()\n{\n    vec2 z = rand2();\n    return normalize(sqrt(-2.0*log(z.x   ))*vec2(cos(2.0*pi*z.y), sin(2.0*pi*z.y)));\n}\n\nvec3 urand3()\n{\n    vec4 z = rand4();\n    return normalize(sqrt(-2.0*log(z.xxy ))*vec3(cos(2.0*pi*z.z), sin(2.0*pi*z.z), cos(2.0*pi*z.w)));\n}\n\nvec4 urand4()\n{\n    vec4 z = rand4();\n    return normalize(sqrt(-2.0*log(z.xxyy))*vec4(cos(2.0*pi*z.z), sin(2.0*pi*z.z), cos(2.0*pi*z.w), sin(2.0*pi*z.w)));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ##### Rendering #####\n\n/*\n// Noise (from Sampler)\nfloat noise(vec3 pos)\n{\n    return texture(iChannel1, pos/32.0).x;\n}\n*/\n\n// Dot Product on a Vector\n// (E.G. dotp(vector0-vector1) vs. dot(vector0-vector1, vector0-vector1))\nfloat dotp(vec3 vec)\n{\n    return dot(vec, vec);\n}\n\n// hash33 Hash without Sine: https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3*vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yxx)*p3.zyx);\n}\n\n// Worley Noise\nfloat noise(vec3 pos)\n{\n    // Scale\n    pos = pos/32.0;\n\n    // Set-Up Variables\n    float minDist = 1000.0;\n\n    // Loop over 3x3x3 Volume\n    for(int x = -1; x <= 1; x++) {\n    for(int y = -1; y <= 1; y++) {\n    for(int z = -1; z <= 1; z++) {\n        // Nearest Point's Distance\n        minDist = min(dotp(fract(pos)-(vec3(x, y, z)+hash33(floor(vec3(x, y, z)+pos)/32.0))), minDist);\n    }\n    }\n    }\n\n    // Return the Value (Inverted for Cloud-like effect)\n    return max(1.0-sqrt(minDist), 0.0);\n}\n\n// Fractal Brownian Motion\nfloat fbm(vec3 pos)\n{\n    // Set-Up Variables\n    float value = 0.0;\n    float scale = 1.0;\n    float atten = 0.5;\n\n    // Octaves\n    for(uint i = 0U; i < 4U; i++)\n    {\n        // Add Octave\n        value += noise(pos*scale)*atten;\n\n        // Increase Frequency\n        scale *= 2.0;\n\n        // Decrease Contribution of Next Octave\n        atten *= 0.5;\n    }\n\n    // Return the Final Value\n    return value;\n}\n\n// Volumetric Density Function\nfloat getVolume(vec3 pos, out vec3 volumeColor)\n{\n    // Default Color\n    volumeColor = vec3(0.8);\n\n    // Skip Sampling Noise Where it isn't Needed (Performance Increase)\n    if(dot(pos, pos) > 2.0 || pos.y > 0.16)\n    {\n        return 0.0;\n    }\n\n    float falloff = pos.y+0.6;\n\n    // Calculate Density\n    float density = max(fbm(pos*50.0)-falloff, 0.0)*256.0;\n\n    // blue fog test\n    //volumeColor = density > 0.0 ? vec3(0.5) : vec3(0.6, 0.8, 1.0);\n\n    // Return the Density\n    return density;\n}\n\n// Color of the Sky\nvec3 skyColor(vec3 dir)\n{\n    // Light\n    if(dot(normalize(vec3(1.0, 0.5, 1.0)), dir) > 0.95)\n    {\n        return vec3(10.0);\n    }\n\n    // Simple Atmosphere Effect\n    //return vec3(max(dot(vec3(0.0, 1.0, 0.0), dir)*0.8, 0.0)+0.2);\n\n    // Black Sky\n    return vec3(0.0);\n}\n\n// Light Collision Checker\nbool lightSource(vec3 pos, out vec3 color)\n{\n    color = vec3(10.0);\n\n    // Light Positions\n    vec3 light0 = vec3(-1.0, 0.0,-1.0);\n    vec3 light1 = vec3( 1.0, 0.0,-1.0);\n    vec3 light2 = vec3(-1.0, 0.0, 1.0);\n    vec3 light3 = vec3( 1.0, 0.0, 1.0);\n\n    // Find the Nearest Light\n    float minDist = min(min(dotp(pos-light0), dotp(pos-light1)), min(dotp(pos-light2), dotp(pos-light3)));\n\n    // Light Colors\n    color = minDist == dotp(pos-light0) ? vec3(2.00, 0.05, 0.05) : color;\n    color = minDist == dotp(pos-light1) ? vec3(2.00, 2.00, 0.05) : color;\n    color = minDist == dotp(pos-light2) ? vec3(0.05, 2.00, 0.05) : color;\n    color = minDist == dotp(pos-light3) ? vec3(0.05, 0.05, 2.00) : color;\n\n    // Return Collision\n    return minDist < 0.1;\n}\n\n// Volumetric Path-Tracing\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    // Set-Up Variables\n    vec3 raypos = ro;\n\n    // Initial Ray Length\n    float t = rand()*stepSize;\n\n    vec3 attenuation = vec3(1.0);\n    vec3 volumeColor = vec3(0.0);\n    uint bounces = 0U;\n\n    // Ray-Marching\n    for(uint i = 0U; i < maxStep; i++)\n    {\n        if(bounces > maxBounces)\n        {\n            break;\n        }\n\n        if(dot(raypos+rd*t, raypos+rd*t) > 2.5)\n        {\n            return attenuation*skyColor(rd);\n        }\n\n        vec3 lightColor;\n\n        if(lightSource(raypos+rd*t, lightColor))\n        {\n            return attenuation*lightColor;\n        }\n\n        float density = getVolume(raypos+rd*t, volumeColor);\n\n        float absorbance = exp(-density*stepSize);\n\n        if(absorbance < rand())\n        {\n            attenuation = clamp(attenuation*volumeColor, 0.0, 1.0);\n            raypos += rd*t;\n            t = 0.0;\n            rd = urand3();\n            bounces++;\n        }\n\n        t += stepSize;\n    }\n\n    // Sample Never Hit Anything, values below 0.0 will be discarded\n    return vec3(-1.0);\n}\n\n// Render and Output the Frame\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Progressive Rendering\n    fragColor = frame != 0 ? texel0 : vec4(0.0);\n\n    // Initialize the Random Number Generator\n    initializeRNG;\n\n    // Screen UV Coordinates\n    vec2 uv = 2.0*(nrand2(0.5, gl_FragCoord.xy)-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\n    // Set-Up Variables\n    vec3 ro = vec3(0.0, 0.5, -1.5);\n    //mat3 rotmat = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    mat3 rotmat = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.5, 0.0, -0.5, 1.0);\n    rotmat[0] = normalize(rotmat[0]);\n    rotmat[1] = normalize(rotmat[1]);\n    rotmat[2] = normalize(rotmat[2]);\n    vec3 rd = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Render and Output the Frame\n    vec3 color = radiance(ro, rd);\n\n    // Output the Rendered Frame\n    fragColor += any(lessThan(color, vec3(0.0))) || any(isinf(color)) || any(isnan(color)) ? vec4(0.0) : vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ##### Image Export #####\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Rendering Buffer\n    vec4 texel = texel0;\n\n    // Output the Final Image\n    fragColor = vec4(texel.a != 0.0 ? texel.rgb/texel.a : texel.rgb, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}