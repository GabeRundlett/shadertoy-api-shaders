{
    "Shader": {
        "info": {
            "date": "1590165518",
            "description": "Mandelbulb fractal.",
            "flags": 0,
            "hasliked": 0,
            "id": "Wd2BDw",
            "likes": 4,
            "name": "Mandelbuld",
            "published": 3,
            "tags": [
                "3d",
                "fractal",
                "mandelbulb"
            ],
            "usePreview": 0,
            "username": "kotfind",
            "viewed": 392
        },
        "renderpass": [
            {
                "code": "#define ROTATION\n\n#define M_PI 3.1415926\n\n// setting begin\nconst float FOV   = M_PI / 2.;\nconst float zNear = 1.;\nconst float zFar  = 10.;\n\nconst float colissiondist = 0.01;\nconst int maxIter = 100;\n// setting end\n\nvec3 viewpoint = vec3(0., 0., 6.);\n\nfloat sq(in float n) {\n    return n * n;\n}\n\nfloat f(in vec3 p) {\n    float power = 8. + sin(iTime * 1.) * 5.;\n    vec3 z = p;\n    float dr = 1.;\n    float r = 0.;\n\n    for (int i = 0; i < 10; ++i) {\n        r = length(z);\n        if (r > 4.)\n            break;\n\n        float theta = acos(z.z / r) * power;\n        float phi   = atan(z.y / z.x) * power;\n        float zr    = pow(r, power);\n        dr = pow(r, power - 1.) * power * dr + 1.;\n\n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += p;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\nfloat map(in vec3 p) {\n    return f(p);\n}\n\nvoid mapColor(in vec3 p, out float mind, out vec3 color, out vec3 norm) {\n    mind = map(p);\n\n    color = vec3(max(0.1, min(0.9, 1. - (1. - sin(p.x * 100.)) *\n                                        (1. - sin(p.y * 100.)) *\n                                        (1. - sin(p.z * 100.)))));\n\n    // get normal\n    const float E = 0.0001;\n    norm = normalize(vec3(f(p + vec3(E, 0., 0.)), f(p + vec3(0., E, 0.)), f(p + vec3(0., 0., E))));\n}\n\nvec3 ray_marching(vec3 orig, vec3 dir) {\n    dir = normalize(dir);\n    float len = 0.;\n    //vec3 bg = vec3(min(0.937255, max(0.2, sin(dir.x * 5.) + sin(dir.y * 10.) + cos(dir.x * dir.y * 10.))));\n    vec3 bg = vec3(0.2);\n\n    for (int i = 0; i < maxIter; ++i) {\n        float d;\n        vec3 color;\n        vec3 norm;\n        mapColor(orig, d, color, norm);\n        if (d < colissiondist) return color;\n        if (len > zFar) return bg;\n\n        len += d;\n        orig += dir * d;\n    }\n    return bg;\n}\n\nmat3 rotatey(in float a) {\n    float sina = sin(a);\n    float cosa = cos(a);\n    return mat3(cosa,  0., sina,\n                0.,    1.,   0.,\n                -sina, 0., cosa);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / vec2(min(iResolution.x, iResolution.y));\n    uv -= (iResolution.xy / min(iResolution.x, iResolution.y) - vec2(1.)) / 2.;\n    uv.y = 1. - uv.y;\n\n    #ifdef ROTATION\n        float a = iTime * 0.2;\n    #else\n        float a = 0.;\n    #endif\n    viewpoint.x = sin(a) * 3.;\n    viewpoint.z = cos(a) * 3.;\n    vec3 color = ray_marching(viewpoint, rotatey(-a + M_PI) * vec3(uv - vec2(0.5, 0.5) , zNear));\n\n    fragColor = vec4(color, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}