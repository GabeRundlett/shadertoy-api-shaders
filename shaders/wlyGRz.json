{
    "Shader": {
        "info": {
            "date": "1578229574",
            "description": "Inspired by Andrew Huang's superb introduction to music theory: https://www.youtube.com/watch?v=rgaTLrZGlk0",
            "flags": 8,
            "hasliked": 0,
            "id": "wlyGRz",
            "likes": 38,
            "name": "Procedural Music Sequencer",
            "published": 3,
            "tags": [
                "music"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 892
        },
        "renderpass": [
            {
                "code": "// Procedural Music Sequencer\n// by Hazel Quantock 2020\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\n\n// Sound code is in ^Sound^ tab\n// This just prints the text\n\n\n// text rendering from: https://www.shadertoy.com/view/WdBXWd\n\n// quality of font anti-aliasing - number of samples doubles with each level of quality\n#define AA_QUALITY 3\n\n// allow a little bleed between pixels - this looks more photographic, but blurrier\n#define AA_ROUND false\n#define AA_ROUND_RADIUS 0.7071\n\n\n// Font Definitions\nstruct Typeface\n{\n    vec2 scale;\n    vec2 padding;\n    vec2 bias;\n    float biasAngle;\n    float threshold;\n};\n\nconst Typeface Deco = Typeface( vec2(.6,.7), vec2(0), vec2(-.02,.025), 0., -.02 );\nconst Typeface Deco_Light = Typeface( vec2(.63,.7), vec2(-1,0), vec2(-.01,.04), 0., -.02 );\n\nconst Typeface Impactful = Typeface( vec2(.5,1), vec2(4,2), vec2(-.02,.01), 0., .01 );\n\nconst Typeface Elegant = Typeface( vec2(.6,.9), vec2(-2,0), vec2(.05,-.005), -1.04, -.022 );\nconst Typeface Elegant_Condensed = Typeface( vec2(.5,1.), vec2(0,1), vec2(.0,.1), -1., -.02 );\n\nconst Typeface Timely = Typeface( vec2(.6,.7), vec2(2,1), vec2(-.05,.0), -.5, -.02 );\nconst Typeface Timely_Light = Typeface( vec2(.6,.7), vec2(2,1), vec2(-.02,.02), -.5, -.01 );\nconst Typeface Timely_Heavy = Typeface( vec2(.8,.7), vec2(4,1), vec2(-.03,.02), 2.5, .01 );\n\nconst Typeface Neat = Typeface( vec2(.6,.7), vec2(-1,1), vec2(-.017,.02), -.3, -.02 );\n\nconst Typeface Comic = Typeface( vec2(.8,.7), vec2(2,1), vec2(-.05,.0), 1., -.02 );\nconst Typeface Comic_Title = Typeface( vec2(.6,.7), vec2(2,1), vec2(-.05,.0), 1., .0 );\n\nconst Typeface WildWest = Typeface( vec2(.9), vec2(2,0), vec2(-.05,.0), 0., -.02 );\nconst Typeface WildWest_Wide = Typeface( vec2(1,.7), vec2(0,2), vec2(.05,.0), 0., .02 );\n\nconst Typeface Gothic = Typeface( vec2(.9,.7), vec2(0,2), vec2(.05,.0), 1., .01 );\nconst Typeface Gothic_Light = Typeface( vec2(.9,.7), vec2(0,2), vec2(.05,.0), 1., -.01 );\nconst Typeface Gothic_Condensed = Typeface( vec2(.5,1.), vec2(0), vec2(.05,.0), -1.04, .02 );\nconst Typeface Gothic_Book = Typeface( vec2(.6,.7), vec2(0,2), vec2(.1,.0), 1., .0 );\n\nconst Typeface Haunted = Typeface( vec2(.75,.9), vec2(2,0), vec2(.0,.03), 0., .01 );\nconst Typeface Haunted_Condensed = Typeface( vec2(.5,1), vec2(4,0), vec2(-.02,.03), 0., .01 );\nconst Typeface Haunted_Script = Typeface( vec2(.6,.7), vec2(2,1), vec2(-.05,.05), .7, .0 );\n\n// Round-tipped font (actually not round in close-up)\nconst Typeface Round = Typeface( vec2(1), vec2(0,6), vec2(-.02,-.02), 0., -.01 );\nconst Typeface Round_Bold = Typeface( vec2(1), vec2(4,6), vec2(-.04,-.04), 0., -.01 );\n\n\n\nfloat RenderFont_NoAA\n    (\n        vec2 uv,\n        Typeface font,\n        uint text[10]\n    )\n{\n    // each char is in a 64x64 space, trim off the white boundary\n    vec2 charBottomLeft = vec2(18,3) - font.padding/2.;\n    vec2 charDims = vec2(28,52) + font.padding;\n\n    uv = uv/font.scale; //+vec2(iTime*200.,0);\n    \n    if ( uv.x < 0. || uv.y < .0 || uv.y >= charDims.y ) return 1.;\n    \n    uint index = uint(uv.x/charDims.x);\n    ivec2 res = ivec2(iResolution.xy);\n    uint index4 = index/4u;\n\n    if ( index4 >= uint(text.length()) ) return 1.;\n    \n    uint char = ( text[index4] >> (8u*(index&3u)) )&0xffu;\n    \n    char = char^0xf0u; // flip the y coord\n    \n    uv.x = fract(uv.x/charDims.x)*charDims.x;\n    uv += vec2(ivec2(char&0xfu,char>>4u)) * iChannelResolution[0].xy/16.;\n    uv += charBottomLeft;\n                            \n    vec4 v = texture( iChannel0, uv/iChannelResolution[0].xy ) -.5;\n                            \n    vec2 bias = 2.*v.yz;\n    bias = bias*cos(font.biasAngle) + bias.yx*sin(font.biasAngle)*vec2(1,-1);\n    bias = pow(abs(bias),vec2(3));\n    \n    // view the SDF\n//    float f = v.w + dot( font.bias, bias ) - font.threshold; return .5+.5*f/(abs(f)+.04);\n    \n    return step( font.threshold, v.w + dot( font.bias, bias ) );\n}\n\n\n\n// RenderFont\n//\n// Output:\n//\t\tA linear brightness value where 0 = text, 1 = background.\n//\t\tI recommend applying a gamma curve before displaying.\n//\n// uv\n//\t\tRelative to the bottom left of the line of text, most fonts are about 40 units tall\n//\n// font\n//\t\tOne of the Typefaces defined earlier\n//\n// text\n//\t\tA line of text, encoded using my tool here: https://tekf.github.io/Misc-Tools/StringToHex.html\n//\t\tEach byte is 4-bit u, 4-bit v coord of a character in the font texture.\n//\nfloat RenderFont\n    (\n        vec2 uv,\n        Typeface font,\n\t\tuint text[10]\n    )\n{\n    const int numSamples = 1<<(AA_QUALITY);\n    \n    float sum = 0.;\n    vec2 duvdx = dFdx(uv); // adjust anti aliasing without needing to know what scale we're working at!\n    vec2 duvdy = dFdy(uv);\n\n    // anti-alias the font\n    // this would be more efficient run per-character inside the font render function\n    // (the SDFs on some of the fonts are good enough that I could probably just soften the step function)\n    for ( int i=0; i < numSamples; i++ )\n    {\n        // ideal 2D quasirandom sequence from http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n        uvec2 quasi2 = uvec2(0xC13FA9A9u,0x91E10DA5u);\n        uint seed = uint(i);\n        //seed += uint(iFrame*numSamples); // randomize per frame - causes shimmering\n        //seed += uint(fragCoord.x)*quasi2.x+uint(fragCoord.y)*quasi2.y; // randomize per pixel - this looks bad at low sample counts (and at high counts it's less important)\n        vec2 jitter = vec2( quasi2 * seed ) / exp2(32.);\n\n        if ( AA_ROUND )\n        {\n            // circle of confusion slightly bigger than a pixel - should look more photographic\n            jitter.x *= 6.283185;\n            jitter = AA_ROUND_RADIUS*(1.-jitter.y*jitter.y)*vec2(cos(jitter.x),sin(jitter.x));\n        }\n        else\n        {\n            jitter -= .5;\n        }\n\n        sum += RenderFont_NoAA( uv + jitter.x*duvdx + jitter.y*duvdy, font, text );\n    }\n   \n    return sum/float(numSamples);\n}\n\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-vec2(20,0))*400./iResolution.y;\n\n    // Text encoded using my tool here: https://tekf.github.io/Misc-Tools/StringToHex.html\n\tfloat f = RenderFont( uv-vec2(135,160), Round_Bold, uint[]( 0x6f53200bU, 0x20646e75U, 0x0b206e4fU, 0x20202020u, 0x20202020u, 0x20202020u, 0x20202020u, 0x20202020u, 0x20202020u, 0x20202020u ) );\n    \n    if ( iTime > 5. )\n    \tf = min( f, RenderFont( uv-vec2(0,0), Neat,\n            // It used to regenerate on rewind, but apparently iDate is now captured when the page loads\n            //uint[]( 0x72502013U, 0x20737365U, 0x69776572U, 0x7420646eU, 0x6567206fU, 0x20612074U, 0x66666964U, 0x6e657265U, 0x75742074U, 0x2021656eU )\n            uint[]( 0x65522020U, 0x64616f6cU, 0x67617020U, 0x6f742065U, 0x74656720U, 0x64206120U, 0x65666669U, 0x746e6572U, 0x6e757420U, 0x20202165U ) // length 40 = 0x28\n        ) );\n    \n    // Output to screen\n    fragColour.rgb = mix( vec3(0), vec3(1), f );\n    \n    // flash the screen when we start to give visual feedback when people press rewind\n    fragColour.rgb *= smoothstep(0.,1.,iTime);\n    \n    fragColour.rgb = pow( fragColour.rgb, vec3(1./2.2) );\n    fragColour.a = 1.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Procedural Music Sequencer\n// by Hazel Quantock 2020\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\n// random hash from here: https://www.shadertoy.com/view/4dVBzz\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 (1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) ((p)*M1)\n#define coord2(p) ((p).x*M1^(p).y*M2)\n#define coord3(p) ((p).x*M1^(p).y*M2^(p).z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\n\n\nint key;\nfloat bps;\n\nint majorScale( int index )\n{\n    return (index*12)/7; //0,2,4,6,7,9,11,12,14,16,18,19,...\n}\n\nint pentatonicScale( int index )\n{\n    return (index*12)/5; //0,2,4,7,9,12,14,16,19,...\n}\n\nfloat frequency( int note )\n{\n    return 440. * exp2( float(note + key) / 12. );\n}\n\nvec2 triangleWave( int note, float time )\n{\n    return fract(vec2(0,0)+frequency(note)*time)*2.-1.;\n}\n\nvec2 squareWave( int note, float time )\n{\n    return step(.5,fract(vec2(0,0)+frequency(note)*time))*2.-1.;\n}\n\nvec2 sineWave( int note, float time )\n{\n    return sin(6.283185*( vec2(0,0)+frequency(note)*time ));\n}\n\nvoid beat( out int i, out float f, float beatLength, float time )\n{\n    f = time*bps/beatLength;\n    i = int(floor( f ));\n    f -= float(i);\n}\n\nint invert( int note, int inversion )\n{\n    return ((note+48-inversion)%12)+inversion;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n\t// emulate lower sample rate\n//\ttime = floor(time*5000.f)/5000.f;\n\t// emulate lower quality float (gradually loses precision over time)\n//\tfloat e = exp2( floor(log2(time)) - 16. ); // number of mantissa bits (roughly)\n//\ttime = floor( time/e ) * e;\n    \n    // YES!! iDate.w changes every time and sound is regenerated on rewind!\n    uint seed = coord1(uint(iDate.w));//uvec3(iDate));\n    vec4 rand = hash4(seed);\n    seed = coord1(seed);\n    \n    // todo: vary these on initialisation\n    key = int(rand.x*12.999)-15;//-9; // relative to middle A\n    int inversion = int(rand.y*12.999)-5;\n    bps = 140./60.;\n    ivec4 triads = ivec4(hash4(seed)*6.999);\n    seed = coord1(seed);\n    \n    int beatsPerBar = 4*int(exp2(floor(rand.y*2.999)));\n    int barsPerPhrase = 4; // this currently has to match the number of triads\n    \n    // timings\n// this would be neater with a function taking number of beats returning int and float\n// which would also work for arp\n    int beat = int(floor(time*bps));\n    float beatf = time*bps-float(beat);\n    int bar = beat/beatsPerBar;\n    float barf = (float(beat-bar*beatsPerBar)+beatf)/float(beatsPerBar);\n    int phrase = bar/barsPerPhrase;\n    float phrasef = (float(bar-phrase*barsPerPhrase)+barf)/float(barsPerPhrase);\n// todo: have verse phrase, chorus phrase alternate a few times, then bridge phrase and final chorus phrase\n// only difference between phrases should be random seed\n\n    int barInPhrase = bar%barsPerPhrase;\n    int beatInBar = beat%beatsPerBar;\n    int beatInPhrase = beat%(beatsPerBar*barsPerPhrase);\n\n    // note frequencies are: exp2(i/12.+octave)*baseFreq\n    \n    // 6 triads = alternate notes in the scale, starting on the first 6 notes\n    \n    // pick a triad for the bar\n    int triadBaseNote = triads[barInPhrase];\n\n    // invert the triads into the same range\n    ivec3 triad =\n        ivec3(\n        \tinvert(majorScale(triadBaseNote),inversion),\n        \tinvert(majorScale(triadBaseNote+2),inversion),\n        \tinvert(majorScale(triadBaseNote+4),inversion)\n        );\n    \n    // sort these notes! this is important for arp and bass\n    if ( triad.x < triad.y )\n    {\n        if ( triad.y < triad.z ) triad.xyz = triad.xyz;\n        else if ( triad.x < triad.z ) triad.xyz = triad.xzy;\n            else triad.xyz = triad.zxy;\n    }\n    else\n    {\n        if ( triad.x < triad.z ) triad.xyz = triad.yxz;\n        else if ( triad.y < triad.z ) triad.xyz = triad.yzx;\n            else triad.xyz = triad.zyx;\n    }\n\n    vec2 f = vec2(0);\n    \n    // play the chord as pads\n    float padAmp = .1*smoothstep(0.,.15,barf)*smoothstep(1.,.5,barf);\n    f += (triangleWave(triad[0],time) + triangleWave(triad[1],time) + triangleWave(triad[2],time))*padAmp;\n    \n    // arpeggiator\n    int arpPerBeat = int(floor(pow(rand.w,2.)*4.999))+2; // I thought 5 would sound bad but it's ok actually\n    float arpf = time*bps * float(arpPerBeat);\n    int arpb = int(floor(arpf));\n    arpf -= float(arpb);\n    \n    // run through the notes of the triad\n    vec4 randArp = hash4(seed);\n    vec4 randArp2 = hash4(coord2(uvec2(seed,barInPhrase)));\n    seed = coord1(seed);\n    int range = int(randArp2.y*5.999+3.); // use arp2 so range changes from bar to bar, sounds more interesting\n    int arpNote =\n        randArp.z > .5 ?\n        abs(((arpb+int(randArp.x*100.999))%(range*2))-(range-1)) // yoyo\n    \t: arpb%range; // ascending\n    arpNote += int(randArp.w*5.999)-2;\n    float arpAmp = .1*step(arpf,.5);//smoothstep(0.,.001,arpf)*smoothstep(.5,.499,arpf);//pow(1.-arpf,2.);\n    \n    int octFudge = 2; // mods go wrong on -ves\n    arpNote += octFudge*3;\n    f += squareWave(triad[arpNote%3] + 12*(arpNote/3 - octFudge),time)*arpAmp;\n    \n    \n    // bass line - play the bottom note of the chord in a random rhythm\n\t// it's ok but the randomness is a bit too random\n    if ( hash1(coord2(uvec2(seed,barInPhrase)))*.9+.1 > hash1(coord2(uvec2(beatInBar,seed)))*2.*float(beatInBar)/float(beatsPerBar) )\n    {\n        float bassAmp = .25*smoothstep(.0,.001,beatf)*pow(1.-beatf,1.);\n        int note = triad[0];\n        int vary = int(20.999*hash1(coord2(uvec2(beatInPhrase,seed))));\n        // I thought this would sound good but it really doesn't\n        //if ( vary < 5 ) note = invert( pentatonicScale(vary), inversion-6 );\n        if ( vary < 5 ) note = triad[2]-12;\n        if ( vary < 2 ) note = triad[1];\n        f += mix(\n            \tsineWave(note-12,time)*3.,\n            \ttriangleWave(note-24,time),\n            //mix(0.,.5,pow(1.-beatf,2.))) // quite a nice pluck effect\n            mix(0.,.3+.4*hash1(coord1(uint(beat))),pow(1.-beatf,3.))) // add a little randomness to the \"harshness\" of the pluck\n            * bassAmp;\n    }\n    \n    \n    // todo: Melody\n    // more complicated rhyhm than bass\n    // pick notes randomly from the pentatonic scale for the melody\n    // but start and end each phrase with a note from the triad\n    \n    \n    return f*.3;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}