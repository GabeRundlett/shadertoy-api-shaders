{
    "Shader": {
        "info": {
            "date": "1646759564",
            "description": "A fractal waffle.\nClick to drag.",
            "flags": 0,
            "hasliked": 0,
            "id": "7d2BRV",
            "likes": 6,
            "name": "Fractal Waffle",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "waffle"
            ],
            "usePreview": 0,
            "username": "lwswl",
            "viewed": 231
        },
        "renderpass": [
            {
                "code": "float t=0.0;\nvec3 o;\nvec3 d;\nfloat i=0.0;\n#define e 0.002\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x));\n#define PI 3.1415926\nfloat table(vec3 p)\n{\n  vec3 v=abs(p+vec3(2.45,0,0))-vec3(2,3,4)*0.9;\n  return length(max(v,0.0))+min(max(v.z,max(v.x,v.y)),0.);\n}\nfloat cloth(vec3 p){ \n      vec3 curl=vec3(0,sin(p.z*4.)*0.2*(p.x+0.3),sin(p.y*4.)*0.2*(p.x+0.3));\n      vec3 v=abs(p+vec3(2.45,0,0)+curl)-vec3(2,3,4);\n      vec3 t=(p+curl)*4.0;\n      float ret=max(abs(min(max(v.y,max(v.z,v.x)),0.)+length(max(v,0.)))-0.04,-(2.+p.x));\n      \n      \n      return ret*0.5;\n\n}\nfloat plate(vec3 p){\n    float d=dot(p.yz,p.yz);\n    return max(length(p.yz)-2.0,abs(p.x-d*0.1-0.001*d*d*sin(40.*atan(p.y/p.z)))-0.04*clamp(1./d,0.5,1.));\n}\nfloat map(vec3 p){\n    \n    i=0.0;\n    float d=100.;\n    vec3 o=vec3(0);\n    float r=0.5;\n    float f=0.0;\n    if(length(p)<20.){\n        while(i<8.){\n            vec3 on=vec3(0);\n            vec3 k=vec3(0,3.,0)*r;\n            k.xy*=rot(i*0.5);\n            k.xz*=rot(i*0.3); \n            r*=0.5;\n            d*=2.;\n            \n            for(float j=0.0;j<7.0;j++){\n                k.yz*=rot(2.*PI/7.0);\n                f=length(p+o+k*0.5)-r;if(f<d){d=f;on=+k*0.5;}\n                f=length(p+o-k*0.5)-r;if(f<d){d=f;on=-k*0.5;}\n\n            }\n            o+=on;\n            if(on==vec3(0)){\n                d*=0.5;\n                break;\n            }\n            i++;\n            if(d<e)break;\n            if(d>2.)break;\n                \n          \n\n            \n        }\n    }\n    if(i<2.0)d-=fbm(p*10.,1.0,2)*0.05;\n    if(i>4.0)d-=fbm(p*100.,0.43,5)*0.004*(1./i);\n    if(i==3.0)d-=fbm(p*21.,1.2,3)*0.01-0.005;\n    \n    float saucer=plate(p+vec3(0.61,0,0));\n    float tablecloth=cloth(p+vec3(0.1,0,0));\n    \n    if(saucer<d){\n        \n        \n        if(tablecloth<saucer){\n            i=-3.;\n            float Table=table(p);\n            if(Table<tablecloth)return Table;\n            i=-1.;\n            return tablecloth;\n        }\n        i=-2.;\n        return saucer;\n    }\n    if(tablecloth<d){\n        float Table=table(p);\n        i=-3.;\n        if(Table<tablecloth)return Table;\n        i=-1.;\n        return tablecloth;\n    }\n    \n\n    return d;\n}\nvec3 norm(vec3 p){\n    float f=map(p);\n    return normalize(vec3(f-map(vec3(p.x-0.002,p.yz)),f-map(vec3(p.x,p.y-0.002,p.z)),f-map(vec3(p.xy,p.z-0.002))));\n}\nvoid march(){\n    float x=1.0;\n    t=0.01;\n    while(x>e&&t<100.0){\n        x=map(o+d*t);\n        t+=x*0.9;\n    }\n\n}\nfloat shadow(vec3 o, vec3 d){\n    float x=1.0;\n    t=0.04;\n    float ret=1.0;\n    while(x>e&&t<10.0){\n        x=map(o+d*t);\n        t+=x;\n        ret=min(ret,x/t);\n        if(x<e)return 0.0;\n    }\n    //if(t>mt)return 0.0;\n    return ret;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv=(fragCoord.yx/iResolution.yx-0.5)*normalize(iResolution.yx);\n    d=vec3(uv,-1);\n    o=vec3(0,0,sin(iTime*0.4)*3.+4.);\n    //o.z+=10.;\n    if(iMouse.z>0.1){\n        d.xz*=rot(-1.8+iMouse.y*0.01);\n        o.xz*=rot(-1.8+iMouse.y*0.01);\n\n        d.yz*=rot(iMouse.x*0.01);\n        o.yz*=rot(iMouse.x*0.01);\n    }else{\n        d.xz*=rot(-0.8+sin(iTime*0.4+0.7)-0.2);\n        o.xz*=rot(-0.8+sin(iTime*0.4+0.7)-0.2);\n\n        d.yz*=rot(iTime*0.1-1.0);\n        o.yz*=rot(iTime*0.1-1.0);\n    }\n    fragColor.rgb=vec3(0);\n    march();\n    if(t<100.0){\n        vec3 albedo;\n        float spec;\n        float rough;\n        float sharp=0.0;\n        if(i==-3.0)albedo=vec3(0.5),spec=0.;\n        else if(i==-2.0)albedo=vec3(0.5),spec=1.;\n        else if(i==-1.0)albedo=vec3(0.8,0.7,0.5),spec=0.;\n        else if(i<2.0)albedo=vec3(0.5,0.4,0.3),spec=0.;\n        else if(i==3.0)albedo=vec3(0.04,0.02,0.3),spec=0.3;\n        else if(i==2.0||i==4.)albedo=vec3(0.1,0.04,0.02),spec=0.2;    \n        else albedo=vec3(0.25,0.11,0.04),spec=0.27;\n        {\n            //vec3 p=floor(o+d*t*2.);\n            //albedo=vec3(1)*mod(p.x+p.y+p.z,2.);\n            //albedo*=mod(p,5.);\n            //albedo=vec3(0);\n        }\n        vec3 N=norm(o+d*t);\n        vec3 ld=normalize(vec3(0.5,1,0));\n        spec=pow(0.5*max(0.,dot(reflect(o,N),ld)),1.+spec+sharp)*spec*0.1;\n        float shad=shadow(o+d*t,ld);\n        float l=clamp(dot(N,ld),0.0,1.0)*shad;\n        fragColor.rgb*=albedo;\n        fragColor.rgb+=spec*l;\n        fragColor.rgb+=spec*shad;\n        fragColor.rgb+=albedo*l;\n        \n        if(t<10.)t*=0.0;\n        \n        //fragColor.rgb=N*0.5+0.5;\n    }\n    \n    fragColor=sqrt(fragColor);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float hash(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}//from DaveH\n// returns 3D value noise (in .x)  and its derivatives (in .yzw)\n// returns 3D value noise\nfloat noise(vec3 x)\n {\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float a = hash( p+vec3(0,0,0) );\n    float b = hash( p+vec3(1,0,0) );\n    float c = hash( p+vec3(0,1,0) );\n    float d = hash( p+vec3(1,1,0) );\n    float e = hash( p+vec3(0,0,1) );\n    float f = hash( p+vec3(1,0,1) );\n    float g = hash( p+vec3(0,1,1) );\n    float h = hash( p+vec3(1,1,1) );\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n            \n}//from iq, for waffle texture\n\nfloat fbm(vec3 x,float H,int octaves)\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<octaves; i++ )\n    {\n        t += a*noise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}//from iq, for waffle texture\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}