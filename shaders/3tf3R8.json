{
    "Shader": {
        "info": {
            "date": "1555558748",
            "description": "I'm sure this has been done much better before.  Not actually solving a cube, just rotating it a bunch.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tf3R8",
            "likes": 18,
            "name": "Fake Rubik's Cube",
            "published": 3,
            "tags": [
                "raymarching",
                "rubix"
            ],
            "usePreview": 0,
            "username": "zackpudil",
            "viewed": 874
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    \n    return mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat box(vec2 p, vec2 b) {\n    vec2 q = abs(p) - b;\n    return max(q.x, q.y);\n}\n\nvec2 opU(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat ac[16]; // store rotations.\n\nvec2 de(vec3 p) {\n    vec3 op = p;\n    float at = mod(iTime*3.0, PI*9.0);\n    \n    float j = 0.0;\n    for(int i = 0; i < 16; i++) {\n        float s = i < 8 ? 1.0 : -1.0;\n        ac[i] = s*PI*smoothstep(j*PI, (j+0.5)*PI, at);\n        j += 0.5;\n    }\n    \n    // I hate this, but I can't find a better way to do it.\n    // do the rotations in reverse so the steps() don't interfer with eachother.\n    p.xz *= rot(ac[15]*step(0.6, p.y)); // last rotation to happen chronologically\n    p.xy *= rot(ac[14]*step(0.6, p.z));\n    p.yz *= rot(ac[13]*step(0.6, p.x));\n    p.xz *= rot(ac[12]*step(0.6, -p.y));\n    p.xy *= rot(ac[11]*step(0.6, -p.z));\n    p.yz *= rot(ac[10]*step(0.6, -p.x));\n    p.xz *= rot(ac[9]*step(0.6, p.y));\n    p.xy *= rot(ac[8]*step(0.6, p.z));\n    \n    p.xy *= rot(ac[7]*step(0.6, p.z));\n    p.xz *= rot(ac[6]*step(0.6, p.y));\n    p.yz *= rot(ac[5]*step(0.6, -p.x));\n    p.xy *= rot(ac[4]*step(0.6, -p.z));\n    p.xz *= rot(ac[3]*step(0.6, -p.y));\n    p.yz *= rot(ac[2]*step(0.6, p.x));\n    p.xy *= rot(ac[1]*step(0.6, p.z));\n    p.xz *= rot(ac[0]*step(0.6, p.y)); // first rotation to happen chronologically\n    \n    // hacky way to get the different colors.\n    float m = 0.0;\n    if(p.x > 1.73) m = 1.0;\n    else if(p.y > 1.73) m = 2.0;\n    else if(p.z > 1.73) m = 3.0;\n    else if(p.x < -1.73) m = 4.0;\n    else if(p.z < -1.73) m = 5.0;\n    else if(p.y < -1.73) m = 6.0;\n    \n    // these two lines turn one cube into 27.\n    p = abs(p) - vec3(0.6);\n    p = abs(p) - vec3(0.6);\n\n    float b = box(p, vec3(0.55)) - 0.03; // the actual rubik cube.\n        \n    // this distance is for the black border around the cube.\n\tfloat c = box(p, vec3(0.56)) - 0.03;\n\tc = max(c, -box(p.xz, vec2(0.47)));\n    c = max(c, -box(p.xy, vec2(0.47)));\n    c = max(c, -box(p.yz, vec2(0.47)));\n        \n    vec2 t = vec2(b, m);\n    vec2 s = vec2(length(op) - 1.7, 7.0);\n    vec2 u = vec2(c, 7.0);\n    \n    return opU(t, opU(s, u));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    vec3 bcol = col = vec3(0.3, 0.4, 1.0);\n    \n    float a = 6.7;\n    float at = iTime*0.6;\n    \n    vec3 ro = vec3(a*cos(at), 3, -a*sin(at));\n    vec3 ww = normalize(vec3(0, 0, 0)-ro);\n    vec3 uu = cross(vec3(0, 1, 0), ww);\n    vec3 vv = cross(ww, uu);\n    vec3 rd = normalize(mat3(uu, vv, ww)*vec3(uv, 1.0));\n    \n    float t = 0.0, m = -1.0, mx = 50.0;\n    for(int i = 0; i < 300; i++) {\n        vec2 d = de(ro + rd*t);\n        if(abs(d.x) < 0.0001 || t >= mx) break;\n        t += d.x*0.5;\n        m = d.y;\n    }\n    \n    vec3 ld = normalize(vec3(0.6, 0.5, -0.5));\n    \n    if(t < mx) {\n        vec3 p = ro + rd*t;\n        vec2 h = vec2(0.001, 0.0);\n        vec3 n = normalize(vec3(\n        \tde(p + h.xyy).x - de(p - h.xyy).x,\n            de(p + h.yxy).x - de(p - h.yxy).x,\n            de(p + h.yyx).x - de(p - h.yyx).x\n        ));\n                \n        vec3 ld = normalize(p);\n        \n        float glo = 16.0;\n        vec3 alb = vec3(0.9);\n        \n        if(m == 1.0) alb = vec3(1.0, 0.3, 0.3);\n        else if(m == 2.0) alb = vec3(0.3, 1.0, 0.3);\n        else if(m == 3.0) alb = vec3(0.3, 0.3, 1.0);\n        else if(m == 4.0) alb = vec3(3.0);\n        else if(m == 5.0) alb = vec3(1.0, 1.0, 0.3);\n        else if(m == 6.0) alb = vec3(1.0, 0.3, 1.0);\n        else if(m == 7.0) alb = vec3(0);\n        \n        float occ = exp2(-pow(max(0.0, 1.0 - de(p + n*0.05).x/0.05), 2.0));\n        float dif = max(0.0, dot(ld, n));\n        float spe = pow(max(0.0, dot(reflect(-ld, n), -rd)), glo);\n        float fre = pow(1.0 + dot(rd, n), 4.0);\n        \n        col = 0.5*mix(occ*(alb*(0.25 + dif) + spe), bcol, fre);\n    }\n    \n    fragColor = vec4(pow(col, vec3(0.4545)), 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}