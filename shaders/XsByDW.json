{
    "Shader": {
        "info": {
            "date": "1491999652",
            "description": "The default \"New shader\" is pretty useless.\nIt lacks framing (and mouse input) with aspect ratio\nand does not explain the very CORE functions of ALL distance fields.\n\nThat makes the very first steps harder.\nThis at least  comes with a core 2d library.",
            "flags": 0,
            "hasliked": 0,
            "id": "XsByDW",
            "likes": 2,
            "name": "2d preset tutorial & intro",
            "published": 3,
            "tags": [
                "2d",
                "tutorial",
                "start",
                "introduction",
                "preset"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 745
        },
        "renderpass": [
            {
                "code": "/*\nThis is a very basic tutorial and 2d library \n...that ends up being in almost all shadertoy shaders.\n\nTo learn basics, by changing functional code keeps making sense,\nwhile changing|removing|(un)commenting core parts of it.\n\nThis tutorializs very basic distanceField functions in 2d within df().\nThis stores and modifies 2 distances:\n[d] =distance to point (0.,0.)        in red , and \n[di]=distance to distance field df(p) in grey\nBlue and green display the orthogonal carthesian xy axes.\n\n*/\n\n////A define is identical to an \"alias\" or \"bind\", a useful shorthand.\n#define zoom 5.\n\n////A list of useful constants: acos(-1.)=3.14=pi | acos(0.)=3.14*0.5=pih\n#define pi acos(-1.)\n#define pih acos(0.)\n////phi=golden-Ratio: 1/phi=1-phi\n#define phi (sqrt(5.)*.5-.5)\n////phi is good for hashes and to avoid overlapping.\n\n////Aliases such as \"phi\" may need to be in (or contain) round brackets: \"()\" around them,\n////becase order of operations matters for commutativity.\n\n////A define can have parameters, and these parameters have no types, \n////because their parameters are aliases, too.\n////defines are basic Genetal-Type functions:\n\n////return a sinusoid over time with range.y [-1 .. 1] & wavelength of 1 second.\n#define hz sin(iTime*pi*2.)\n////return a sinusoid over time with range.y [ 0 .. 1] & wavelength of 1 second.\n#define hz1 (hz*.5+.5)\n\n////By discarding the whole part (of a line) with x=fract(x), you get a seesaw with range.y [0 .. 1];\n#define frac(a) a=fract(a)\n////ss2t(a) changes a seesaw waves output (range [0..1]) to a triangle wave.\n#define ss2t(a) a=abs(a*2.-1.)\n\n////return 2x2matrix that mirrors a point on a line, that is rotated by r*0.5 radians.\n#define r2(r) mat2(sin(r+vec4(pih,0,0,-pih)))\n////r2(r) is equal to the matrix of a SINGLE rotation by [r], but (a*r2(r))*r2(r)=a is a double,refletion back and forth.\n////see \"complex number rotation in 2d\", which also uses \"half-angles\"\n\n//return polar (distamce,angle) coordinates of carthesian (x,y) input.\nvec2 c2p(vec2 p){return vec2(length(p),atan(p.y,p.x));}\n//return carthesian (x,y) coordinates of polar (distamce,angle) input.\nvec2 p2c(vec2 p){return p.x*vec2(cos(p.y),sin(p.y));}\n\n////Below this line, all lines that do not start with a purple word can be commented out by \"//\" to see what they change.\n////And all commented-out lines can be commented back in, so see what that will (un)do.\n////\n////Learn stuff just by removing any \"//\" in the code below.\n////And by trying out many different combinations of disabled and enabled lines.\n////A lot of it is just disabledas suggestion that would be \"too much at once\"\n\n////This frame() function scales and transforms a point to scale and center it \n////to the viewFrame|screen\n////and to \"fix\" aspect ratio stretching.\nvec2 frame(vec2 p){p/=iResolution.xy;\n    p-=vec2(.5);//move xy=vec2(0,0) to the center of range [0 .. 1].xy\n    p*=zoom;//scale by [zoom]\n    p.x*=iResolution.x/iResolution.y;//m.x scales by aspect ratio.\n  //p=p*r2(iTime);//rotation transform, clockwise over time\n  p=p*r2(sin(iTime*phi*2.)*.1);//rotation transform, PENDULUM over time\n  //p.x-=p.y;//skew transform\n\n//polar coordinates:\n  //p=c2p(p);\n////welcome to polar coordinates\n  //p.y+=iTime;//y dimension  rotates\n  //p.x*=2.+hz1*5.;  //x dimensions scales\n  //p=p2c(p);\n////back to carthesian coordiantes\nreturn p;}//with mouse input, frame() is used twice.\n////Matrix transformations affect mouse input!\n////other transformations are left out of this one, but could go in here.\n////see https://en.wikipedia.org/wiki/List_of_common_coordinate_transformations\n\n\n////This function [df(p)] is a distance field\n////It returns the shortest distance of [p] to a shape that is defined by its functions.\n////For a  SIGNED  distance field, a negative distance is \"inside of\" the shape.\n////For a (signed) distance BOUND, the function may return smaller values\n//// ...than the intended distance. This is fine, often much faster.\n////for an OVERSTEPPING distance field, the function may returns a larger value than intended. This is bad.\nfloat df(vec2 p){\n    vec2 mouse=frame(iMouse.xy)-p;\n    float DitanceToMouse =length(mouse);//distance of p to framed-mouse\n    float DitanceToMetaball=DitanceToMouse*length(p);//simple metaball.\n    float d=0.;\n////Uncomment some \"d+=\" lines to see what the others do:\n////Multiple \"d+=\" lines can be accumulated,sometimes useful, sometimes useless.\n////In 2d, sums of distance fields are silly fun. But in 3d, this too easily causes \"oversteppig\"\n////Summing up distance fields is BAD STYLE, but it is good enough to teach basics here.\n\n////A \"-x\" substraction increases the returned distance to the object, \n////because it makes the object \"thinner\" by [x].\n  d-=hz*.1;//oscillate [d] a little bit over time. (larger oscillations distract too much)\n  //d+=DitanceToMouse;\n  \n  d+=max(abs(mouse.x),abs(mouse.y));//distance to square\n  //d+=min(abs(p.x),abs(p.y));//distance to cross\n  //d+=max(abs(p.x),abs(p.y))*(3.-hz1)-min(abs(mouse.x),abs(mouse.y));//distance to (distorting) star.\n  \n  //d+=DitanceToMetaball-2.;\n  //d+=min(length(p),DitanceToMouse)*phi*4.-2.;//union of 2 distances to 2 points via min(a,b)\n  //d+= min(DitanceToMouse*1.5,DitanceToMetaball)-2.;//union of 2 distances \n////mix(a,b,c) does linear interpolation on a line trough a and b, c=0.0 returns a,c=1.0 returns b:\n  //d+= mix(DitanceToMetaball,min(DitanceToMouse*1.5,DitanceToMetaball),hz)-2.;\n////max(a,b) returns the UNION of 2 distance fields [a] and [b]\n  //d+=max(length(p),  DitanceToMouse     )-1.;//distance to union\n////max(a,-b) returns the distance to shpe [a], substracted by distance to shape [b].\n////(but that is for distances to volumes, in 2d we need an offset (here -2.)):\n  //d+=max(length(p)-2.,-(DitanceToMouse-2.));\n  //d+=(DitanceToMouse+length(p))-2.;//(poorly scaled) oval\n  //d+= DitanceToMouse/length(p)+length(p)-2.;//hearty\n    return d;//return distance to mouse\n}////see http://mercury.sexy/hg_sdf/\n\n\nvoid mainImage(out vec4 Out,in vec2 In){vec2 p=frame(In);\n    vec2 p2=p;//we change p soon, and copy a backup of it here.\n    float c=length(p);//length(a.xyzw) returns euclidean distance, pythagrean, squareroot of sum of squares.\n    frac(p);//.xy grid <- seesaw\n    ss2t(p);//.xy grid    seesaw <- triangle\n    p*=p*p; //f(p)=p*p*p; simple way to make p more exponential (for p range[0 .. 1])\n                               \n    frac(c);//distance to point (0,0) <- seesaw\n  //ss2t(c);//distance to point (0,0)    seesaw <- triangle\n  //c*=c;   //f(c)=c*c; simple way to make d more exponential (for p range[0 .. 1])\n  //c=step(c,.5);\n    c*=hz1;//multiply [c] by a sinusoid over time see \"#define hz...\"\n    Out=vec4(c,p,1.);//set the \"out vec4 Out\" value, \n////[Out] is the \"return Out;\" value of this function.\n////above code sets up a coordinate system\n                                        \n////below code adds a 2d distance-field to play around with\n    float di=df(p2);//di stores [distance of [p2] to distance field df()\n  //di+=hz1;//Oscillates [di] a bit over time (outside of distance field == better style)                   \n    frac(di);//display distance fiels just as we display distance to point (0,0)\n  //di=step(di+hz1,1.);//display distance field as \"inside and outside of distance 1.0\"\n  //di=1.-di;//optional inversion, with offset\n    Out.xyz+=di*.5;//show distance field. Additive visualization is lazy and fast (and bad style)\n///end of distance field code\n                                        \n////post processing:\n    Out*=Out;//f(Out)=Out*Out; simple way to increase contrast.\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}