{
    "Shader": {
        "info": {
            "date": "1703397611",
            "description": "An example of a very simple dithering algorithim i came up with. There are two lines that can be (un)commeted in/out that make the shader a bit more interesting, both have a slight performance impact. Try switching iChannel0 to the 1961 commercial! ",
            "flags": 0,
            "hasliked": 0,
            "id": "lcl3Rs",
            "likes": 4,
            "name": "moduloDither",
            "published": 3,
            "tags": [
                "dither",
                "modulus",
                "dithering"
            ],
            "usePreview": 0,
            "username": "natet",
            "viewed": 229
        },
        "renderpass": [
            {
                "code": "// This function returns an integer to use as the modulus value for a given pixel. \n//  The brighter this pixel, the smaller this integer is, relative to the width of the image (so that a black pixel returns\n//  the image width as an integer)\nint ditherModFactor(float val, vec2 imgSize){\n    return int(floor((1.0-pow(val,0.01)) * imgSize.x));\n    //The pow here applies an aggressive log curve to the greyscale colour of the image. This is needed due to \n    // multiplying the 0-1 greyscale value by such a large number (screen width in pixels). An exponent of 0.01 happens to work \n    // very well here, but playing around with the exponent can be interesting. \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Load a pixel from the image and write it to a variable\n    vec4 pix = texture(iChannel0,uv);\n    \n    //If the green channel of this pixel is more than a small value, and the red and blue are less than a threshold, make this \n    // pixel black.\n    if(pix.y > 0.01 && pix.x < 0.2 && pix.z < 0.2){pix = vec4(0.0,0.0,0.0,1.0);} //uncomment to chroma key (for black background) \n    \n    //Store a float of the average value of all three colour channels of this pixel\n    float pixVal = (pix.x+pix.y+pix.z)/3.0;\n    \n    //Work out what number/index pixel this is in the image. It is also interesting to use the x or y coordinate of the current\n    // pixel (not normalised) in place of i (**try replacing i on line 39 with fragCoord.x or fragCoord.y!**).\n    float i = uv.x + (uv.y * iResolution.y);\n    \n    //Get the modulo value for this pixel\n    int shadeMod = ditherModFactor(pixVal, iResolution.xy);\n        \n    //Compare the modulo value for this pixel with it's number/index - if the pixel index is a multiple of the modulo, \n    // output a white pixel - if not, black. This means that brighter pixels in the original image both have more white \n    // neighbours and are more likely to be white themselves, based on where they fall in the image. This is why it's important\n    // to scale the modulo to the image width so that no repeating patterns of white appear in parts of the image that should be \n    // black. When this is done, the only black/dark pixels in the original image that will return white in the modulo check are \n    // the pixels that have the \"address\" (index or x or y coord) equal to the max value in range of values that address can be. \n    if(int(i) % shadeMod == 0){\n        fragColor = vec4(1.0);\n    } else {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    //if((1.0-uv.x) < uv.y){fragColor = vec4(pixVal,pixVal,pixVal,1.0);} //uncommenting shows undithered b&w image on half of screen\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}