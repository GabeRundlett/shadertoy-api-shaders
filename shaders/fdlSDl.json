{
    "Shader": {
        "info": {
            "date": "1619458567",
            "description": "License CC0: Cloudy crystal\nLate to the party I discovered: https://www.shadertoy.com/view/MtX3Ws\nPlayed around with it for a bit and thought it looked quite nice so I shared\n",
            "flags": 0,
            "hasliked": 0,
            "id": "fdlSDl",
            "likes": 136,
            "name": "Cloudy crystal",
            "published": 3,
            "tags": [
                "raytracing",
                "crystal"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 3056
        },
        "renderpass": [
            {
                "code": "// License CC0: Cloudy crystal\n// Late to the party I discovered: https://www.shadertoy.com/view/MtX3Ws\n// Played around with it for a bit and thought it looked quite nice so I shared\n\n#define TIME              iTime\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define L2(x)             dot(x, x)\n\n#define RAYSHAPE(ro, rd)  raySphere4(ro, rd, 0.5)\n#define IRAYSHAPE(ro, rd) iraySphere4(ro, rd, 0.5)\n\nconst float miss          = 1E4;\nconst float refrIndex     = 0.85;\nconst vec3  lightPos      = 2.0*vec3(1.5, 2.0, 1.0);\nconst vec3  skyCol1        = pow(vec3(0.2, 0.4, 0.6), vec3(0.25))*1.0;\nconst vec3  skyCol2        = pow(vec3(0.4, 0.7, 1.0), vec3(2.0))*1.0;\nconst vec3  sunCol         = vec3(8.0,7.0,6.0)/8.0;\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Various ray object intersection from IQ:\n//  https://iquilezles.org/articles/intersectors\nfloat raySphere4(vec3 ro, vec3 rd, float ra) {\n    float r2 = ra*ra;\n    vec3 d2 = rd*rd; vec3 d3 = d2*rd;\n    vec3 o2 = ro*ro; vec3 o3 = o2*ro;\n    float ka = 1.0/dot(d2,d2);\n    float k3 = ka* dot(ro,d3);\n    float k2 = ka* dot(o2,d2);\n    float k1 = ka* dot(o3,rd);\n    float k0 = ka*(dot(o2,o2) - r2*r2);\n    float c2 = k2 - k3*k3;\n    float c1 = k1 + 2.0*k3*k3*k3 - 3.0*k3*k2;\n    float c0 = k0 - 3.0*k3*k3*k3*k3 + 6.0*k3*k3*k2 - 4.0*k3*k1;\n    float p = c2*c2 + c0/3.0;\n    float q = c2*c2*c2 - c2*c0 + c1*c1;\n    float h = q*q - p*p*p;\n    if (h<0.0) return miss; //no intersection\n    float sh = sqrt(h);\n    float s = sign(q+sh)*pow(abs(q+sh),1.0/3.0); // cuberoot\n    float t = sign(q-sh)*pow(abs(q-sh),1.0/3.0); // cuberoot\n    vec2  w = vec2( s+t,s-t );\n    vec2  v = vec2( w.x+c2*4.0, w.y*sqrt(3.0) )*0.5;\n    float r = length(v);\n    return -abs(v.y)/sqrt(r+v.x) - c1/r - k3;\n}\n\nvec3 sphere4Normal(vec3 pos) {\n  return normalize( pos*pos*pos );\n}\n\nfloat iraySphere4(vec3 ro, vec3 rd, float ra) {\n  // Computes inner intersection by intersecting a reverse outer intersection\n  vec3 rro = ro + rd*ra*4.0;\n  vec3 rrd = -rd;\n  float rt = raySphere4(rro, rrd, ra);\n\n  if (rt == miss) return miss;\n  \n  vec3 rpos = rro + rrd*rt;\n  return length(rpos - ro);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p ) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 sunDir = normalize(lightPos);\n  float sunDot = max(dot(rd, sunDir), 0.0);  \n  vec3 final = vec3(0.);\n\n  final += mix(skyCol1, skyCol2, rd.y);\n  final += 0.5*sunCol*pow(sunDot, 20.0);\n  final += 4.0*sunCol*pow(sunDot, 400.0);    \n\n  float tp  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 0.505));\n  if (tp > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    vec3 ld   = normalize(lightPos - pos);\n    float ts4 = RAYSHAPE(pos, ld);\n    vec3 spos = pos + ld*ts4;\n    float its4= IRAYSHAPE(spos, ld);\n    // Extremely fake soft shadows\n    float sha = ts4 == miss ? 1.0 : (1.0-1.0*tanh_approx(its4*1.5/(0.5+.5*ts4)));\n    vec3 nor  = vec3(0.0, 1.0, 0.0);\n    vec3 icol = 1.5*skyCol1 + 4.0*sunCol*sha*dot(-rd, nor);\n    vec2 ppos = pos.xz*0.75;\n    ppos = fract(ppos+0.5)-0.5;\n    float pd  = min(abs(ppos.x), abs(ppos.y));\n    vec3  pcol= mix(vec3(0.4), vec3(0.3), exp(-60.0*pd));\n\n    vec3 col  = icol*pcol;\n    col = clamp(col, 0.0, 1.25);\n    float f   = exp(-10.0*(max(tp-10.0, 0.0) / 100.0));\n    return mix(final, col , f);\n  } else{\n    return final;\n  }\n}\n\n// Marble fractal from https://www.shadertoy.com/view/MtX3Ws\nvec2 cmul(vec2 a, vec2 b) { \n  return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x); \n}\n\nvec2 csqr(vec2 a) { \n  return vec2(a.x*a.x - a.y*a.y, 2.*a.x*a.y); \n}\n\nfloat marble_df(vec3 p) {  \n  float res = 0.;\n\n  vec3 c = p;\n  float scale = 0.72;\n  const int max_iter = 10;\n  for (int i = 0; i < max_iter; ++i) {\n    p    = scale*abs(p)/dot(p,p) - scale;\n    p.yz = csqr(p.yz);\n    p    = p.zxy;\n    res  += exp(-19. * abs(dot(p,c)));\n  }\n  return res;\n}\n\nvec3 marble_march(vec3 ro, vec3 rd, vec2 tminmax) {\n  float t   = tminmax.x;\n  float dt  = 0.02;\n  vec3 col  = vec3(0.0);\n  float c   = 0.;\n  const int max_iter = 64;\n  for(int i = 0; i < max_iter; ++i) {\n      t += dt*exp(-2.0*c);\n      if(t>tminmax.y) { \n        break; \n      }\n      vec3 pos = ro+t*rd;\n        \n      c = marble_df(ro+t*rd); \n      c *= 0.5;\n        \n      float dist = (abs(pos.x + pos.y-0.15))*10.0;\n      vec3 dcol = vec3(c*c*c-c*dist, c*c-c, c);\n      col = col + dcol;\n  }    \n  const float scale = 0.005;\n  float td = (t - tminmax.x)/(tminmax.y - tminmax.x);\n  col *= exp(-10.0*td);\n  col *= scale;\n  return col;\n}\n\nvec3 render1(vec3 ro, vec3 rd) {\n  vec3 ipos = ro;\n  vec3 ird  = rd;\n  \n  float its4  = IRAYSHAPE(ipos, ird);\n  return marble_march(ipos, ird, vec2(0.0, its4));\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 skyCol = skyColor(ro, rd);\n  vec3 col = vec3(0.0);\n\n  float t   = 1E6;\n  float ts4 = RAYSHAPE(ro, rd);\n  if (ts4 < miss) {\n    t = ts4;\n    vec3 pos  = ro + ts4*rd;\n    vec3 nor  = sphere4Normal(pos);\n    vec3 refr = refract(rd, nor, refrIndex);\n    vec3 refl = reflect(rd, nor);\n    vec3 rcol = skyColor(pos, refl);\n    float fre = mix(0.0, 1.0, pow(1.0-dot(-rd, nor), 4.0));\n\n    vec3 lv   = lightPos - pos;\n    float ll2 = L2(lv);\n    float ll  = sqrt(ll2);\n    vec3 ld   = lv / ll;\n\n    float dm  = min(1.0, 40.0/ll2);\n    float dif = pow(max(dot(nor,ld),0.0), 8.0)*dm;\n    float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 100.);\n    float l   = dif;\n\n    float lin = mix(0.0, 1.0, l);\n    const vec3 lcol = 2.0*sqrt(sunCol);\n    col = render1(pos, refr);\n    vec3 diff = hsv2rgb(vec3(0.7, fre, 0.075*lin))*lcol;\n    col += fre*rcol+diff+spe*lcol;\n    if (refr == vec3(0.0)) {\n      // Not expected to happen as the refraction index < 1.0\n      col = vec3(1.0, 0.0, 0.0);\n    }\n    \n  } else {\n    // Ray intersected sky\n    return skyCol;\n  }\n\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) { \n  vec3 ro = 0.6*vec3(2.0, 0, 0.2)+vec3(0.0, 0.75, 0.0);\n  ro.xz *= ROT(PI/2.0+sin(TIME*0.05));\n  ro.yz *= ROT(0.5+0.25*sin(TIME*0.05*sqrt(0.5))*0.5);\n\n  vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  float rdd = 2.0;\n  vec3 rd = normalize( p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}