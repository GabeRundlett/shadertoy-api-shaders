{
    "Shader": {
        "info": {
            "date": "1668076011",
            "description": "Quick test showing off a rational quadratic bezier curve, with the two weights on the endpoints set to 1 and the weight at the control\npoint can be altered by going up and down with mouse after clicking.\n\nClicking in the bottom left starts animation again",
            "flags": 0,
            "hasliked": 0,
            "id": "md2GRt",
            "likes": 9,
            "name": "Rational quad bezier",
            "published": 3,
            "tags": [
                "2d",
                "bezier",
                "implicit",
                "quadratic",
                "parametric",
                "rational"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 387
        },
        "renderpass": [
            {
                "code": "/*\n\nThe idea of rational bezier curves is basically that you\ndefine the points in homogenic coordinates, different\nrepresentatives of the same affine points correspond to different\nweighted points. The curve is then also computed in homogenic coordinates\nand then you divide by the third coordinate to get an affine point.\n\nSo instead of a parametric polynomial function,\nyou get a parametric rational function.\n\nEvery three points have a weight associated a priori.\n\nBut scaling all three weights by the same factor doesn't change the curve.\nSo you can set one of the weights to 1.\n\nI decided to set two weights to 1 and only change the weight at the\ncontrol point, but i'm loosing a degree of freedom with that.\n\nI compute the approximated signed distance to the curve by using the implicitization\nand gradient distance estimation.\n\nFor more information about all sorts of stuff\nregarding bezier curves i always recommend Sederbergs script:\nhttp://hdl.lib.byu.edu/1877/2822\n\nThere is probably room for improvement at different parts of this shader.\n*/\n\n//#define SHOW_DISTANCE_FIELD\n\nconst bool fill_outer=false;\n\nconst float dot_size=.003;\n\nconst vec3 bg_col=vec3(1);\nconst vec3 dot_col=vec3(0,1,0);\nconst vec3 fill_col=vec3(0);\n\nconst float pi=3.1415925;\n\nconst int num_iterations=3;\nconst int num_start_params=16;\n\nfloat rational_quadratic_bezier_gradient_dis_approx(vec2 uv,vec3 p0,vec3 p1,vec3 p2){\n\tvec3 a2=p0-2.*p1+p2;\n\tvec3 a1=-2.*p0+2.*p1;\n\tvec3 a0=p0;\n\n\tvec2 b2=a2.xy-uv*a2.z;\n\tvec2 b1=a1.xy-uv*a1.z;\n\tvec2 b0=a0.xy-uv*a0.z;\n    \n    float dm21=determinant(mat2(b2,b1));\n    float dm20=determinant(mat2(b2,b0));\n    float dm10=determinant(mat2(b1,b0));\n\n\tmat2 bezout_matrix=mat2(dm21,dm20,dm20,dm10);\n    float val=determinant(bezout_matrix);\n\n\tfloat grad_x=2.*dm20*(a2.z*b0.y - a0.z*b2.y)\n\t             - dm10*(a2.z*b1.y - a1.z*b2.y)\n\t\t\t\t - dm21*(a1.z*b0.y - a0.z*b1.y);\n\n\tfloat grad_y=dm10*(a2.z*b1.x - a1.z*b2.x)\n\t\t\t\t + dm21*(a1.z*b0.x - a0.z*b1.x)\n\t\t\t\t - 2.*dm20*(a2.z*b0.x - a0.z*b2.x);\n\n\treturn val/length(vec2(grad_x,grad_y));\n}\n\n// quartic equation solver by oneshade (see https://www.shadertoy.com/view/fsB3Wt)\nfloat cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\nint solveQuartic(in float a, in float b, in float c, in float d, in float e, inout vec4 roots) {\n    b /= a; c /= a; d /= a; e /= a; // Divide by leading coefficient to make it 1\n\n    // Depress the quartic to x^4 + px^2 + qx + r by substituting x-b/4a\n    // This can be found by substituting x+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float bb = b * b;\n    float p = (8.0 * c - 3.0 * bb) / 8.0;\n    float q = (8.0 * d - 4.0 * c * b + bb * b) / 8.0;\n    float r = (256.0 * e - 64.0 * d * b + 16.0 * c * bb - 3.0 * bb * bb) / 256.0;\n    int n = 0; // Root counter\n\n    // Solve for a root to (t^2)^3 + 2p(t^2)^2 + (p^2 - 4r)(t^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * p;\n    float rb =  p * p - 4.0 * r;\n    float rc = -q * q;\n\n    // Depress using the method above\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = rc - (rb - 2.0 * ra * ra / 9.0) * ru;\n\n    float lambda;\n    float rh = 0.25 * rq * rq + rp * rp * rp / 27.0;\n    if (rh > 0.0) { // Use Cardano's formula in the case of one real root\n        rh = sqrt(rh);\n        float ro = -0.5 * rq;\n        lambda = cbrt(ro - rh) + cbrt(ro + rh) - ru;\n    }\n\n    else { // Use complex arithmetic in the case of three real roots\n        float rm = sqrt(-rp / 3.0);\n        lambda = -2.0 * rm * sin(asin(1.5 * rq / (rp * rm)) / 3.0) - ru;\n    }\n\n    // Newton iteration to fix numerical problems (using Horners method)\n    // Suggested by @NinjaKoala\n    for(int i=0; i < 2; i++) {\n        float a_2 = ra + lambda;\n        float a_1 = rb + lambda * a_2;\n        float b_2 = a_2 + lambda;\n\n        float f = rc + lambda * a_1; // Evaluation of λ^3 + ra * λ^2 + rb * λ + rc\n        float f1 = a_1 + lambda * b_2; // Derivative\n\n        lambda -= f / f1; // Newton iteration step\n    }\n\n    // Solve two quadratics factored from the quartic using the cubic root\n    if (lambda < 0.0) return n;\n    float t = sqrt(lambda); // Because we solved for t^2 but want t\n    float alpha = 2.0 * q / t, beta = lambda + ra;\n\n    float u = 0.25 * b;\n    t *= 0.5;\n\n    float z = -alpha - beta;\n    if (z > 0.0) {\n        z = sqrt(z) * 0.5;\n        float h = +t - u;\n        roots.xy = vec2(h + z, h - z);\n        n += 2;\n    }\n\n    float w = +alpha - beta;\n    if (w > 0.0) {\n        w = sqrt(w) * 0.5;\n        float h = -t - u;\n        roots.zw = vec2(h + w, h - w);\n        if (n == 0) roots.xy = roots.zw;\n        n += 2;\n    }\n\n    return n;\n}\n\nvec2 parametric_rational_quadratic_bezier(float t, vec3 p0, vec3 p1, vec3 p2){\n    vec3 p = mix(mix(p0,p1,t),mix(p1,p2,t),t);\n    return p.xy/p.z;\n}\n\n/* Exact variant, has precision issues */\nfloat rational_quadratic_bezier_dis_exact(vec2 uv,vec3 p0,vec3 p1,vec3 p2){\n\tvec3 a2=p0-2.*p1+p2;\n\tvec3 a1=-2.*p0+2.*p1;\n\tvec3 a0=p0;\n\n\tfloat q4 = (a2.x*a2.x + a2.y*a2.y)*a1.z\n             - (a1.x*a2.x + a1.y*a2.y)*a2.z\n             - (a2.x*a1.z*a2.z - a1.x*a2.z*a2.z)*uv.x\n             - (a2.y*a1.z*a2.z - a1.y*a2.z*a2.z)*uv.y;\n             \n    float q3 = 2.*(a2.x*a2.x + a2.y*a2.y)*a0.z\n             + (a1.x*a2.x + a1.y*a2.y)*a1.z\n             - (a1.x*a1.x + 2.*a0.x*a2.x\n             + a1.y*a1.y + 2.*a0.y*a2.y)*a2.z\n             - (a2.x*a1.z*a1.z - 2.*a0.x*a2.z*a2.z\n             + (2.*a2.x*a0.z - a1.x*a1.z)*a2.z)*uv.x\n             - (a2.y*a1.z*a1.z - 2.*a0.y*a2.z*a2.z\n             + (2.*a2.y*a0.z - a1.y*a1.z)*a2.z)*uv.y;\n\n    float q2 = 3.*((a1.x*a2.x + a1.y*a2.y)*a0.z\n             - (a0.x*a1.x + a0.y*a1.y)*a2.z\n             - (a2.x*a0.z*a1.z - a0.x*a1.z*a2.z)*uv.x\n             - (a2.y*a0.z*a1.z - a0.y*a1.z*a2.z)*uv.y);\n             \n    float q1 = (a1.x*a1.x + 2.*a0.x*a2.x + a1.y*a1.y + 2.*a0.y*a2.y)*a0.z\n             - (a0.x*a1.x + a0.y*a1.y)*a1.z\n             - 2.*(a0.x*a0.x + a0.y*a0.y)*a2.z\n             - (2.*a2.x*a0.z*a0.z + a1.x*a0.z*a1.z\n             - a0.x*a1.z*a1.z - 2.*a0.x*a0.z*a2.z)*uv.x\n             - (2.*a2.y*a0.z*a0.z + a1.y*a0.z*a1.z\n             - a0.y*a1.z*a1.z - 2.*a0.y*a0.z*a2.z)*uv.y;\n\n    float q0 = (a0.x*a1.x + a0.y*a1.y)*a0.z\n             - (a0.x*a0.x + a0.y*a0.y)*a1.z\n             - (a1.x*a0.z*a0.z - a0.x*a0.z*a1.z)*uv.x\n             - (a1.y*a0.z*a0.z - a0.y*a0.z*a1.z)*uv.y;\n\n    vec4 roots;\n    int n_roots = solveQuartic(q4,q3,q2,q1,q0,roots);\n    \n    float dis = 1e38;\n    \n    for(int i=0;i<n_roots;i++){\n        dis = min(dis, distance(uv,parametric_rational_quadratic_bezier(roots[i],p0,p1,p2)));\n    }\n    \n    return dis;\n}\n\nfloat rational_quadratic_bezier_val_grad(vec2 uv,vec3 p0,vec3 p1,vec3 p2, out vec2 grad){\n    vec3 a2=p0-2.*p1+p2;\n\tvec3 a1=-2.*p0+2.*p1;\n\tvec3 a0=p0;\n\n    vec2 b2=a2.xy-uv*a2.z;\n    vec2 b1=a1.xy-uv*a1.z;\n    vec2 b0=a0.xy-uv*a0.z;\n\n    float dm21=determinant(mat2(b2,b1));\n    float dm20=determinant(mat2(b2,b0));\n    float dm10=determinant(mat2(b1,b0));\n\n    mat2 bezout_matrix=mat2(dm21,dm20,dm20,dm10);\n    float val=determinant(bezout_matrix);\n\n    float grad_x=2.*dm20*(a2.z*b0.y - a0.z*b2.y)\n                 - dm10*(a2.z*b1.y - a1.z*b2.y)\n                 - dm21*(a1.z*b0.y - a0.z*b1.y);\n\n    float grad_y=dm10*(a2.z*b1.x - a1.z*b2.x)\n                 + dm21*(a1.z*b0.x - a0.z*b1.x)\n                 - 2.*dm20*(a2.z*b0.x - a0.z*b2.x);\n                         \n    grad = vec2(grad_x,grad_y);\n    \n    return val;\n}\n\nfloat rational_quadratic_bezier_dis_approx2d(vec2 uv,vec3 p0,vec3 p1,vec3 p2){\n    const int num_start_points = 2;\n    const int num_iterations = 10;\n    \n    float dis = 1e38;\n\n    for(int i=0;i<num_start_points;i++){\n        float t = float(i) / float(num_start_points-1);\n        vec2 p = parametric_rational_quadratic_bezier(t,p0,p1,p2);\n        \n        for(int j=0;j<num_iterations;j++){\n            vec2 grad;\n            float val = rational_quadratic_bezier_val_grad(p,p0,p1,p2,grad);\n            vec2 tang = normalize(vec2(grad.y,-grad.x));\n            p += dot(tang,uv-p) * tang;\n            \n            val = rational_quadratic_bezier_val_grad(p,p0,p1,p2,grad);\n            p -= val * grad / dot(grad,grad);\n        }\n        dis = min(dis,distance(uv,p)); \n    }\n\n    return dis;\n}\n\n// Netwon method\nfloat rational_quadratic_bezier_dis_newton(vec2 uv, vec3 p0, vec3 p1, vec3 p2){\n    const float eps = .001;\n    const int num_start_vals = 16;\n    const int num_iterations = 5;\n    \n    float dis = 1e38;\n    \n    for(int i=0;i<num_start_vals;i++){\n        float t = float(i) / float(num_start_vals-1);\n\n        for(int j=0;j<num_iterations;j++){\n            vec3 fp1 = mix(mix(p0,p1,t-eps),mix(p1,p2,t-eps),t-eps);\n            float f1 = dot(uv-fp1.xy/fp1.z,uv-fp1.xy/fp1.z);\n            \n            vec3 fp2 = mix(mix(p0,p1,t),mix(p1,p2,t),t);\n            float f2 = dot(uv-fp2.xy/fp2.z,uv-fp2.xy/fp2.z);\n            \n            vec3 fp3 = mix(mix(p0,p1,t+eps),mix(p1,p2,t+eps),t+eps);\n            float f3 = dot(uv-fp3.xy/fp3.z,uv-fp3.xy/fp3.z);\n            \n            t -= eps * ((-.5 * f1 + .5 * f3) / (f1 - 2.*f2 + f3));\n        }\n        t = clamp(t,0.,1.);\n        vec3 p = mix(mix(p0,p1,t),mix(p1,p2,t),t);\n        float f = dot(uv-p.xy/p.z,uv-p.xy/p.z);\n        \n        dis = min(dis,f);\n    }\n    return sqrt(dis);\n}\n\n//by iq (see https://www.shadertoy.com/view/XsXSz4)\nfloat sdTriangle(vec2 p, vec2 p0, vec2 p1, vec2 p2 ){\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat rational_quadratic_bezier_normal_iteration(float t, vec2 uv, vec3 a0, vec3 a1, vec3 a2){\n\tvec3 eval=(a2*t+a1)*t+a0;\n\n\tvec2 diff_num=((a2.xy*a1.z - a1.xy*a2.z)*t + 2.*(a2.xy*a0.z - a0.xy*a2.z))*t + a1.xy*a0.z - a0.xy*a1.z;\n\n\tvec2 uv_to_p=eval.xy / eval.z - uv;\n\tvec2 tang=diff_num / (eval.z * eval.z);\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat rational_quadratic_bezier_dis_approx(vec2 uv, vec3 p0, vec3 p1, vec3 p2){\n\tvec3 a2 = p0 - 2. * p1 + p2;\n\tvec3 a1 = -2. * p0 + 2. * p1;\n\tvec3 a0 = p0;\n\n\tfloat d0 = 1e38;\n\n\tfloat t0=.0;\n\tfloat t;\n\n\tfor(int i=0;i<num_start_params;i++){\n\t\tt=t0;\n\t\tfor(int j=0;j<num_iterations;j++){\n\t\t\tt=rational_quadratic_bezier_normal_iteration(t,uv,a0,a1,a2);\n\t\t}\n\t\tt=clamp(t,0.,1.);\n\t\tvec3 cur_p=(a2*t+a1)*t+a0;\n\t\tcur_p/=cur_p.z;\n\t\tvec2 uv_to_p = cur_p.xy - uv;\n\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\n\t\tt0+=1./float(num_start_params-1);\n\t}\n\n\treturn sqrt(d0);\n}\n\nfloat rational_quadratic_bezier_sign(vec2 uv,vec3 p0,vec3 p1,vec3 p2){\n\tvec3 a2=p0-2.*p1+p2;\n\tvec3 a1=-2.*p0+2.*p1;\n\tvec3 a0=p0;\n\n\tvec2 b2=a2.xy-uv*a2.z;\n\tvec2 b1=a1.xy-uv*a1.z;\n\tvec2 b0=a0.xy-uv*a0.z;\n\n\tmat2 bezout_matrix=mat2(determinant(mat2(b2,b1)),determinant(mat2(b2,b0)),determinant(mat2(b2,b0)),determinant(mat2(b1,b0)));\n\n\treturn sign(determinant(bezout_matrix));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n    uv.y*=iResolution.y/iResolution.x;\n\n\tvec2 mouse=iMouse.xy/iResolution.xy;\n\tmouse-=.5;\n    mouse.y*=iResolution.y/iResolution.x;\n\n\tvec2 mouse2=abs(iMouse.zw)/iResolution.xy;\n\tmouse2-=.5;\n    mouse2.y*=iResolution.y/iResolution.x;\n\n\tfloat weight = exp(5.*(mouse2.y-mouse.y));\n\n\tvec3 p0=vec3(-.3,-.2,1.);\n\tvec3 p1=vec3(mouse2,1.)*weight;\n\tvec3 p2=vec3(.3,-.2,1.);\n\n\tif(max(iMouse.x, iMouse.y) < 20.){\n\t\tweight=1.+.3*sin(2.*iTime);\n        p1=vec3(.3*sin(iTime),.1+.1*cos(iTime),1.)*weight;\n    }\n\n\tfloat tri_dis=sdTriangle(uv,p0.xy/p0.z,p1.xy/p1.z,p2.xy/p2.z);\n\n    float curve_dis=(fill_outer?1.0:-1.0) * rational_quadratic_bezier_gradient_dis_approx(uv,p0,p1,p2);\n    \n    // The distance approximation using the parametric form doesn't work well here\n    /*\n    float sgn=rational_quadratic_bezier_sign(uv,p0,p1,p2);\n    float curve_dis=(fill_outer?1.0:-1.0) * sgn * rational_quadratic_bezier_dis_approx(uv,p0,p1,p2);\n    */\n    \n    // Exact variant (with numerical precision issues)\n    /*\n    float sgn=rational_quadratic_bezier_sign(uv,p0,p1,p2);\n    float curve_dis=(fill_outer?1.0:-1.0) * sgn * rational_quadratic_bezier_dis_exact(uv,p0,p1,p2);\n    */\n    \n    // Newton method variant\n    /*\n    float sgn=rational_quadratic_bezier_sign(uv,p0,p1,p2);\n    float curve_dis=(fill_outer?1.0:-1.0) * sgn * rational_quadratic_bezier_dis_newton(uv,p0,p1,p2);\n    */\n    \n    #ifdef SHOW_DISTANCE_FIELD\n    float dis = curve_dis;\n    #else\n\tfloat dis=max(tri_dis,curve_dis);\n    #endif\n\n\tvec3 color = bg_col;\n\tcolor=mix(fill_col,color,smoothstep(-border/2.,border/2.,dis));\n    \n    #ifdef SHOW_DISTANCE_FIELD\n    dis*=3.;\n    vec3 col = vec3(1.0) - sign(dis)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(dis));\n\tcol *= 0.8 + 0.2*cos(120.0*dis);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(dis)) );\n    color = col;\n    #endif\n\n\tdis=1e38;\n\n\tdis=min(dis,distance(p0.xy/p0.z,uv)-dot_size);\n\tdis=min(dis,distance(p1.xy/p1.z,uv)-dot_size*weight);\n\tdis=min(dis,distance(p2.xy/p2.z,uv)-dot_size);\n    \n    vec2 p3=parametric_rational_quadratic_bezier(fract(.1*iTime),p0,p1,p2);\n    dis=min(dis,distance(p3,uv)-dot_size);\n\n\tcolor=mix(dot_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\tfragColor=vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}