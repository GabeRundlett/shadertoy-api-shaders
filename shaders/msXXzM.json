{
    "Shader": {
        "info": {
            "date": "1668640426",
            "description": "There is a cruel lack of wildlife documentary on \"shadertoy\" !\n/!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\\n/!\\    restart to get a good sound synchro!!!  /!\\\n/!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\",
            "flags": 40,
            "hasliked": 0,
            "id": "msXXzM",
            "likes": 78,
            "name": "Shadertoy Geographic",
            "published": 3,
            "tags": [
                "penguin",
                "documentary"
            ],
            "usePreview": 1,
            "username": "iapafoto",
            "viewed": 1012
        },
        "renderpass": [
            {
                "code": "// Created by Sebastien Durand - 11/2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//-----------------------------------------------------\n// Sounds based with minor changed on\n//     Dave Hoskins [Frozen wasteland] https://www.shadertoy.com/view/Xls3D2\n// ------------------------------------------------------------\n// Many part of shading based on \n//     iq [Bridge] https://www.shadertoy.com/view/Mds3z2\n// ------------------------------------------------------------\n// Penguin feets and texture bedes on\n//     kuvkar [AngryBird] https://www.shadertoy.com/view/ldKXRz\n// ------------------------------------------------------------\n\n#define WITH_DOF\n\n#ifdef WITH_DOF\n\n// fade in out arround t during dt\n#define fade(t,dt) smoothstep(0.,dt,abs(iTime-t))\n//#define iTime (iTime + 120.)\n\nint[] txt = int[] (83,72,65,68,69,82,84,79,89,0,71,69,79,71,82,65,80,72,73,67,0); \n\n\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sample_dist_gaussian(vec2 uv) {\n    const int nstep = 3;\n    const float w[3] = float[3](1., 2., 1.);\n    float d, wij, dsum = 0., wsum = 0.;    \n    for (int i=0; i<nstep; ++i) {\n        for (int j=0; j<nstep; ++j) {\n            vec2 delta = vec2(float(i-1), float(j-1))/1024.;\n            d = textureLod(iChannel1, uv-delta, 0.).w - 127./255.;\n            wij = w[i]*w[j];\n            dsum += wij * d;\n            wsum += wij;\n        }\n    }\n    return dsum / wsum;\n}\n\nfloat sdFont(vec2 p, int c) {\n    vec2 uv = (p + vec2(float(c%16), float(15-c/16)) + .5)/16.;\n    return max(max(abs(p.x) - .25, max(p.y - .35, -.38 - p.y)), sample_dist_gaussian(uv));\n}\n\nfloat sdMessage(vec2 p, int[21] text, int start, float scale, float bold) {\n    p /= scale;\n    float d = 9999.;\n    vec2 pp;\n\n    for (int i=min(iFrame,0)+start; i<text.length(); i++) {  \n        if (text[i] == 0) break;\n        d = min(d, sdFont(p, text[i]));\n        p.x-=.5;\n\n    }\n    return d*scale - bold;\n}\n\n//-----------------------------------------------\n// Based on Iq Dof\n//-----------------------------------------------\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n    vec2 q = fragCoord / iResolution.xy;\n    \n    if (iTime > 1. && iTime < 158.) {\n\n        float focus = 1.5;\n\n        float gTime = iTime - 40.;\n            \n        if (gTime < 110.) focus = 1.5;\n        if (gTime < 85.) focus = (1.25+.05*gTime); \n        if (gTime < 70.) focus = mix(6.,1.5,smoothstep(50.,60.,gTime));\n        if (gTime < 44.) focus = 10.;\n        if (gTime < 25.) focus = 7.;\n        if (gTime < 20.) focus = 2.;\n        if (gTime < 0.) focus = 5.;\n        if (gTime < -20.) focus = mix(2.,.25,smoothstep(.5,3.,iTime));\n\n        float a = 1.;\n\n        vec4 acc = vec4(0.0);\n        const int N = 12;\n        for( int j=-N; j<=N; j++ )\n        for( int i=-N; i<=N; i++ )\n        {\n            vec2 off = vec2(float(i),float(j));\n            vec4 tmp = texture( iChannel0, q + off/iResolution.xy ); \n            float depth = tmp.w;\n            vec3  color = tmp.xyz;\n            float coc = .001 + 3.*abs(depth-focus)/depth;\n            if( dot(off,off) < (coc*coc) ) {\n                float w = 1.0/(coc*coc); \n                acc += vec4(color*w,w);\n            }\n        }\n\n        vec3 col = acc.xyz / acc.w;\n\n\n        //-----------------------------------------------------\n        // postprocessing\n        //-----------------------------------------------------\n        // gamma\n        col = pow( abs(clamp(col,0.0,1.0)), vec3(0.5) );\n\n        // contrast, desat, tint and vignetting\t\n        col = col*0.8 + 0.2*col*col*(3.0-2.0*col);\n        col = mix( col, vec3(col.x+col.y+col.z)*0.333, 0.25 );\n        col *= vec3(1.0,1.02,0.96);\n        col *= pow(16.0*q.x*q.y*(1.-q.x)*(1.-q.y),.25);\n        col += .05*(vec3(hash22(q*100.),hash12(111.*q)) - .5);\n        fragColor = vec4(col,1.0);\n    \n        fragColor *= fade(20.,1.5); // fondu noir entre scene\n        fragColor *= fade(60.,1.); \n        fragColor *= fade(110.,1.5); \n        fragColor *= fade(125.,2.);\n  //      fragColor *= fade(140.,1.5);\n  //      fragColor *= fade(145.,1.5);\n  //      fragColor *= fade(165.,1.5);\n    } else {\n        vec2 uv = q-vec2(0.5);\n        uv.y /= iResolution.x/iResolution.y;\n        uv.x += .1;\n        float d = max(sdBox(uv-vec2(-.18,0), .6*vec2(.14,.2)), -sdBox(uv-vec2(-.18,0), .6*vec2(.1,.16)));\n        float dTxt = sdMessage(uv-vec2(-.05,.05), txt, 0,.11,0.);\n        dTxt = min(dTxt, sdMessage(uv-vec2(-.05,-.05), txt, 10,.11,0.));\n        vec3 col = mix(vec3(0), vec3(1,1,0),step(d,0.));\n        col = mix(vec3(1.),col, smoothstep(0.,1./iResolution.y,dTxt));\n        fragColor = vec4(col,1.0);\n    }\n}\n\n#else \n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tfragColor= texture(iChannel0, gl_FragCoord.xy/iResolution.xy);\n}\n\n\n#endif",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by Sebastien Durand - 11/2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//-----------------------------------------------------\n// Sounds based with minor changed on\n//     Dave Hoskins [Frozen wasteland] https://www.shadertoy.com/view/Xls3D2\n// ------------------------------------------------------------\n// Many part of shading based on \n//     iq [Bridge] https://www.shadertoy.com/view/Mds3z2\n// ------------------------------------------------------------\n// Penguin feets and texture bedes on\n//     kuvkar [AngryBird] https://www.shadertoy.com/view/ldKXRz\n// ------------------------------------------------------------\n\n#define ZERO min(0,iFrame)\n\n#define MOD2 vec2(.16632,.17369)\n#define MOD3 vec3(.16532,.17369,.15787)\n\n\n//----------------------------------------------------------------------------------------\n// Dave Hoskins Hash functions\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in ...\nfloat hash11(float p) {\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p) {\n    vec3 p3 = fract(vec3(p) * MOD3);\n    p3 += dot(p3.xyz, p3.yzx + 19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\n\nfloat hash12( vec2 p ) {\n    p  = 50.*fract( p*.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\n\n// utilise pour le texture3D\nvec3 noised(in vec2 x) {\n    vec2 p = floor(x),\n         w = fract(x),\n         u = w*w*(3.-2.*w);  \n    float a = hash12(p),\n          b = hash12(p+vec2(1,0)),\n          c = hash12(p+vec2(0,1)),\n          k1 = b - a,\n          k2 = c - a,\n          k4 = a - b - c + hash12(p+vec2(1));\n    return vec3( -1.+2.*(a + k1*u.x + k2*u.y + k4*u.x*u.y), \n                 12.*w*(1.-w) * vec2(k1 + k4*u.y, k2 + k4*u.x) );\n}\n\nfloat noise3D(in vec3 p){\n\tconst vec3 s = vec3(113, 157, 1);\n\tvec3 ip = floor(p); \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; \n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    float n = mix(h.x, h.y, p.z);\n    return n;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Created by Sebastien Durand - 11/2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//-----------------------------------------------------\n// Sounds based with minor changed on\n//     Dave Hoskins [Frozen wasteland] https://www.shadertoy.com/view/Xls3D2\n// ------------------------------------------------------------\n// Many part of shading based on \n//     iq [Bridge] https://www.shadertoy.com/view/Mds3z2\n// ------------------------------------------------------------\n// Penguin feets and texture bedes on\n//     kuvkar [AngryBird] https://www.shadertoy.com/view/ldKXRz\n// ------------------------------------------------------------\n\nvec2 add = vec2(1,0);\n\n\n\nfloat tri(in float x) { \n    return abs(fract(x)-.5)*2.;\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nfloat Noise11(float x) {\n    float p = floor(x), f = fract(x);\n    f = f*f*(3.-2.*f);\n    return mix( hash11(p), hash11(p + 1.), f)-.5;\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 Noise21(float x) {\n    float p = floor(x), f = fract(x);\n    f = f*f*(3.-2.*f);\n    return  mix( hash21(p), hash21(p + 1.), f)-.5;\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 2 in...\nvec2 Noise22(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.-2.*f);\n    vec2 res = mix(mix( hash22(p),          hash22(p + add.xy),f.x),\n                   mix( hash22(p + add.yx), hash22(p + add.xx),f.x),f.y);\n    return res-.5;\n}\n\n//----------------------------------------------------------------------------------------\n// Fractal Brownian Motion...\nvec2 FBM22(vec2 x) {\n    vec2 r = vec2(0);\n    float a = .6;\n    for (int i = 0; i<8; i++) {\n        r += Noise22(x * a) / a;\n        a += a;\n    }\n    return r;\n}\n\n\n\nvec2 mainSound( in int samp, float time) {\n    float gTime = time - 40.;\n\n    int sceneId = 6;\n         if (gTime <-20.) sceneId = -2;\n    else if (gTime <  1.) sceneId = -1;\n    else if (gTime < 20.) sceneId = 0;\n    else if (gTime < 25.) sceneId = 1;\n    else if (gTime < 44.) sceneId = 2;\n    else if (gTime < 70.) sceneId = 3;\n    else if (gTime < 85.) sceneId = 4;\n    else if (gTime < 105.) sceneId = 5;\n    else sceneId = 6;\n\n\n    vec2 audio = vec2(.0);\n    \n    // le vent    \n    for (float t = 0.0; t < 1.0; t+=.5)\n    {\n        time = time+t;\n        vec2 n1 = FBM22( time*(Noise21(time*3.25)*40.0+Noise21(time*.03)*5500.0+9500.0)) * (abs(Noise21(time)))*1.5;\n        vec2 n2 = FBM22( time*(Noise21(time*.4)+1900.0))*abs(Noise21(time*1.5))*1.5;\n        vec2 n3 = FBM22( time*(Noise21(time*1.3)+Noise21(-time*.03)*200.0+1940.0))*(.5+abs(Noise21(time-99.)))*1.5;\n        vec2 s1 = sin(time*3300.+(Noise21(time*.23))*(Noise21(-time*.12)*3000.0+4000.0))*abs(Noise21(time*32.3+199.))*abs(Noise21(-time*.04+9.)+.5)*3.;\n\n        audio += (n1+n2+n3+s1)/8.0;\n    }\n    \n    if (sceneId == -1) {\n        audio *= .1;\n    } else if (sceneId == 5) {\n        audio *= 2.; // bcp de event\n    }\n    // Les pas\n    if (sceneId > -2 && sceneId < 3 || sceneId == 5) { \n        float foot = tri(time*(sceneId == 1 ? 3.7 : 1.85));\n        audio += 6. * Noise11(time*10.0)*Noise11(time*500.0)*Noise11(time*3000.0)* smoothstep(0.6,1.,abs(foot));\n\n        if (sceneId > -1) { // + de pas\n            foot = tri(time*1.85+.8);\n            audio += 6. * Noise11(time*10.0)*Noise11(time*500.0)*Noise11(time*3000.0)* smoothstep(0.6,1.,abs(foot));\n        }\n        if (sceneId == 5) { // + de pas\n            foot = tri(time*1.85+1.2);\n            audio += 6. * Noise11(time*10.0)*Noise11(time*500.0)*Noise11(time*3000.0)* smoothstep(0.6,1.,abs(foot));\n        }\n    }\n    if (sceneId == -2) audio *= .25 +.15*cos(time*1.5);  // ocean\n    if (sceneId == 1) audio *= .05; // glissades\n  \n    return .15*clamp(audio, -1.0, 1.0); \n    \n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "// Created by Sebastien Durand - 11/2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//-----------------------------------------------------\n// Sounds based with minor changed on\n//     Dave Hoskins [Frozen wasteland] https://www.shadertoy.com/view/Xls3D2\n// ------------------------------------------------------------\n// Many part of shading based on \n//     iq [Bridge] https://www.shadertoy.com/view/Mds3z2\n// ------------------------------------------------------------\n// Penguin feets and texture bedes on\n//     kuvkar [AngryBird] https://www.shadertoy.com/view/ldKXRz\n// ------------------------------------------------------------\n//#define iTime (iTime + 120.)\n\n\n#define FAR 30.\n\n#define  GROUND 0.\n#define  BODY 1.\n#define  BROW 2.\n#define  BEAK 3.\n#define  EGG 4.\n#define  HEAD 5.\n#define  FEET 6.\n#define  AILE 7.\n#define  COU 8.\n\n#define PI 3.141592653592\n\n#define WITH_SHADOW\n\nfloat gTime;\n\nint sceneId = 0;\nbool withBBox = true;\nbool isStanding = true;\nbool isWalking = false;\n\n\nfloat fogmap(in vec3 p, in float d) {\n    float time = 5.*iTime;\n    p.xz -= time*7.+(sin(p.z)+1.2+cos(p.x))*3.;\n    p.y -= time*.5;\n    return (max(noise3D(p*.008+.1),.0)*noise3D(p*.1))*.3;\n}\n\n\n// b(t) = (1-t)^2*A + 2(1-t)t*B + t^2*C\nvec3 bezier( vec3 A, vec3 B, vec3 C, float t ) {\n    return (1.-t)*(1.-t)*A + 2.*(1.-t)*t*B + t*t*C;\n}\n// b'(t) = 2(t-1)*A + 2(1-2t)*B + 2t*C\nvec3 bezier_dx( vec3 A, vec3 B, vec3 C, float t ) {\n    return 2.*((t-1.)*A + (1.-2.*t)*B + t*C);\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvec2 opSunFlowerRep(in vec2 p, inout vec2 id, bool norot, vec2 k) {\n    float a = atan(p.x, p.y);\n    vec2 b = vec2(0, length(p))/k.y + a/(2.*PI);\n    b.x = ceil(b.y) - b.x;\n    b.x *= b.x * 2.*1.618/k.x;\n    id = vec2(floor(b)); // x: pos from center, y: id of circle\n    b = k.y*(fract(b)-.5); // [-1:1] o n y and y\n    b.x *= k.x;\n    if (norot) b *= rot(a);\n    return b;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*.5,\n\t      c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) {\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c < start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n//////////////\n// distance functions from from https://iquilezles.org/articles/distfunctions\n/////////////\n\nfloat smin(float a, float b , float s){\n    float h = clamp(.5 + .5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.-h)*s;\n}\n\nfloat smax(float a, float b, float s){\n    float h = clamp(.5 + .5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.-h)*s;\n}\n\n// iq - https://www.shadertoy.com/view/Wdjfz3\nfloat sdEgg(vec3 q, float sz) {\n    const float k = sqrt(3.);\n    float r = sz*(.6 - .3);\n    vec2 p = vec2(length(q.xz), .9*q.y);    \n    return (p.y<0. ? length(p) - r : k*(p.x+r)<p.y ? length(vec2(p.x,  p.y-k*r)) : length(vec2(p.x+r,p.y)) - 2.*r) - sz*.3;\n}\n\n// iq - https://www.shadertoy.com/view/ldj3Wh\nvec2 sdBezier(vec3 p, vec3 b0, vec3 b1, vec3 b2) {\n    b0 -= p; b1 -= p; b2 -= p;\n    vec3 b01 = cross(b0,b1), b12 = cross(b1,b2), b20 = cross(b2,b0),\n         n =  b01+b12+b20;\n    float a = -dot(b20,n), b = -dot(b01,n), d = -dot(b12,n), m = -dot(n,n);\n    vec3  g =  (d-b)*b1 + (b+a*.5)*b2 + (-d-a*.5)*b0;\n    float t = clamp((a*.5+b-.5*(a*a*.25-b*d)*dot(g,b0-2.*b1+b2)/dot(g,g))/m, 0., 1.);\n    return vec2(length(mix(mix(b0,b1,t), mix(b1,b2,t),t)),t);\n}\n\nvec3 sdBezierUV(vec3 p, vec3 a, vec3 b, vec3 c, vec2 h) {\n    vec3 bb = normalize(cross(b-a,c-a)),\n         qq = bezier(a,b,c,h.y),\n         tq = normalize(bezier_dx(a,b,c,h.y));  \n    return vec3(dot(p-qq, normalize(cross(bb,tq))), h.y, dot(p-qq,bb));\n}   \n\nfloat sdSegment(vec3 p, vec3 a, vec3 b) {\n    vec3 pa = p - a, ba = b - a;\n    return length(pa - ba*clamp(dot(pa,ba)/dot(ba,ba), 0., 1. ));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r) {\n    float k0 = length(p/r), k1 = length(p/(r*r));\n    return k0*(k0-1.)/k1;\n}\n\nvec3 bend(vec3 p, float angle){\n\tfloat c = cos(angle*p.z), s = sin(angle*p.z);\n    return vec3(mat2(c,-s,s,c)*p.yz,p.x);\n}\n\nfloat hGround(vec3 p) {\n    p.zx = p.xz;\n    p.y *= 1.5;\n    float tx = .1*(cos(p.x*.03))*(textureLod(iChannel1, p.xz/16. + p.xy/80., 0.0).x);\n    vec3 q = p*.25;\n    float h = tx + .5*(dot(sin(q)*cos(q.yzx), vec3(.222))) + dot(sin(q*1.3)*cos(q.yzx*1.4), vec3(.111));\n    return (sceneId == -1 ? -2.7 : sceneId == 3 ? -.5 : -1.) * smin(0.,smoothstep(.2,3., abs(p.z))*h*5.,.2);\n}\n\n\n///////////////////////////\n///////////////////////////\n///////////////////////////\n\n\n// kuvkar [AngryBird] https://www.shadertoy.com/view/ldKXRz\nfloat sdToes( vec3 p, vec2 h) {\n  p.x += sin(p.x * 40.) * .007 + cos(p.y * 600.) * .001;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\n// kuvkar [AngryBird] https://www.shadertoy.com/view/ldKXRz\nfloat sdFeet(vec3 rp, inout float body, float dfeet, float side) {\n    vec3 legpos = vec3(side*.055, -.16, 0.),\n     nFeet = vec3(0., .12, .01);\n    float a = -.5*dfeet;\n    nFeet.yz *= rot(a);\n    vec3 footpos = legpos - nFeet;\n    float leg = sdSegment(rp, -legpos, mix(legpos, footpos,.45)) - .03;\n    body = smin(body, leg,.02);\n    vec3 pFeet = rp - footpos;\n    pFeet.yz *= rot(-a);\n    float d = sdToes( (pFeet + vec3(0, -.03, -.01)), vec2(.012, .01)) - .008;\n    pFeet.x = abs(pFeet.x); \n    d = smin(d, sdToes( bend (pFeet + vec3(0, -.02, .01) , 4.), vec2(.01, .045)), .01);\n    pFeet = bend(pFeet + vec3(-0.015, -.02, .02), 12.);\n    pFeet.zy *= rot(-.4);\n    return smin(d, sdToes(pFeet, vec2(.009, .03)), .01);\n}\n\n\nfloat sdPenguin(in vec3 rp, in vec3 p0, float hG, float id, inout vec4 r) {\n    rp.y -= hG + .27;\n  \n    float Time = (sceneId ==-2 || sceneId == 3 ? .3*iTime : iTime) + .2*id,\n         t = 1.85*Time,\n         k = cos(PI*t);\n\n    if (!isStanding) {\n        rp.z = -rp.z;\n    }\n    if (isWalking) {   \n        rp.z += .02*cos(1.57+PI*t*2.);  // avance de la marche\n        rp.x += .1*hash11(10.*id); // position decalle suivant id\n    }\n    rp.x *= .9+.2*hash22(vec2(id,id)).x; // +/- gros et grands suivant id\n\n    if (!isStanding) {\n        rp.xyz = rp.xzy + vec3(0,0,.22);\n    }\n    \n    // Fastest thanks to this bounding box\n    if (withBBox) {\n        float dBox = sdEllipsoid(rp-vec3(0,.025,0), isStanding?vec3(.3,.35,.2):vec3(.5,.4,.3));\n        if (dBox > 0.) return dBox + .005+.01*hash12(p0.xz+p0.y);\n    }\n    \n    vec3 headPos = vec3(0, .26, -.05), \n         peak = - .14 * vec3(0.,0.,1.),\n         legpos1 = vec3(.055, -0.16, -.02),\n         legpos2 = vec3(-.055, -0.16, -.02),\n         nFeet1 = vec3(0., .12, .01),\n         nFeet2 = vec3(0., .12, .01);\n    float up = 0., dfeet = 0., dfeet1 = 0., dfeet2 = 0.,\n          k0 = cos(PI*t), k1 = cos(PI*t+.25), k2 = cos(PI*t-.25);\n    \n    if (isWalking) {    \n         dfeet = .5*sign(k)*pow(abs(k),1.5);\n         dfeet1 = .5*sign(k1)*pow(abs(k1),1.5);\n         dfeet2 = .5*sign(k1)*pow(abs(k2),1.5);\n         up = rp.x>0. ? .2 - .2*dfeet : .2 + .2*dfeet; \n         nFeet1.yz *= rot(.5*(.6+dfeet1));\n         nFeet2.yz *= rot(-.5*(.6-dfeet2));\n    }\n    \n    float body = 999.; \n        \n    if (isWalking) {    \n        vec3 rotPos = mix(legpos1 - nFeet1, legpos2 - nFeet2, .5+.5*k);\n        rp -= rotPos; \n        rp.yz *= rot(-.1);  // penche en avant pendant la marche\n        rp.xy *= rot(.25*.25*dfeet); // penche sur le coté\n        rp.xz *= rot(-.5*dfeet); // tourne autour du pied\n        rp += rotPos;\n    }\n    \n    vec3 rpHead = rp - headPos;\n    if (!isStanding) {\n        headPos.z += .15;\n        rpHead.yz *= rot(4.84);\n        rpHead.y -= .15;\n    }    \n    if (sceneId == 4) {\n        rpHead.yz *= rot(1.+.05*cos(.3*iTime)); // rotation haut bas\n        rpHead += vec3(0,-.025,.035);\n        \n    } else if (sceneId == 5) {\n        rpHead.xz *= rot(-.5*cos(2.*Time)); // droite gauche\n        rpHead.yz *= rot(.5+.2*cos(Time)); // rotation haut bas\n        rpHead += vec3(0,-.01,.02);\n    } else {        \n        rpHead.yz *= rot(-.06*cos(5.*Time+cos(Time))); // rotation haut bas\n        rpHead.xz *= rot(-.5*cos(2.*Time)); // droite gauche\n    }\n   // rpHead.zy += .02*headup;\n    \n    vec3 rp_real = rp;\n\trp.x = -abs(rp.x); // most of the stuff is just mirrored\n\n    // body\n    body = min(body, sdEllipsoid(rp, vec3(.12,.22,.1)));\n    // pectoraux\n    body = smin(body, sdEllipsoid(rp-vec3(-0.0,.105,-.03), vec3(0.1-.005*up,.08,.055-.005*up)), .02);\n    // queu\n    body = smin(body, sdSegment(rp, vec3(0,-.18,.05), vec3(0,-.28,.12)) + .3*(rp.z -.12)-.01, .05);\n\n    float body0 = body;\n    \n    // aile\n    vec3 pa = rp - vec3(-.1,.125,.02);\n    pa.xz *= rot(.2); // rotation axe \n    \n    if (sceneId == 4) {\n        pa.zy *= rot(.3+.3*cos(.5*iTime+id));\n        pa.xy *= rot(.5-.03*cos(.41*iTime+2.*id)); // Leves\n    } else {\n        pa.zy *= rot((isStanding ? -1.5*up : 0.) +.3);//+.1*cos(8.*Time)); // Avant arriere\n        pa.xy *= rot(isStanding ? .3 : .5-.3*k1); // Leves\n    }\n    pa += vec3(-.01+.02*up,.16,.0);  \n     \n    float aile = sdEllipsoid(pa, vec3(.025,.15,.06));\n    aile = smin(aile, -sdEllipsoid(pa-vec3(.04,-.037,.03), vec3(.054,.17,.08)), -.03);\n    body = smin(body, aile, .03*smoothstep(.07,.15,pa.y));\n    \n    // head\n    float head = sdEllipsoid(rpHead, vec3(.04,.04,.06));\n    body = min(body, head);\n    // bec\n    vec2 bez = sdBezier(rpHead, .4*peak, peak, peak + vec3(0,-.02,-.001));\n    body = smin(body, (bez.x - .002-.01*smoothstep(1.,.3, bez.y)), .03);\n   \n    // oeil\n    rpHead.x = abs(rpHead.x);\n    vec3 eyePos = vec3(.019, .01, -.04);\n   \n    float dEye = length(rpHead - eyePos-vec3(-.007,0,0)) - .012;\n     \n    vec3 uvEye = rpHead - eyePos;\n    float dEyeHole = max(length(rpHead - eyePos-vec3(0,.007,0)), \n                         length(rpHead - eyePos+vec3(0,.007,0)))- .015;  \n    \n    // cou\n    vec2 cou = sdBezier(rp_real, headPos, vec3(0, .2,.02), vec3(.0, .15,.03));\n   \n    body = smin(body, cou.x-.04,.01);\n    body = max(body, -dEyeHole);\n    body = min(body, dEye);\n     // legs\n    float feet = min(sdFeet(rp_real, body, .6+dfeet1, 1.), sdFeet(rp_real, body, .6-dfeet2, -1.)); \n    \n    float d = body0;\n    r = vec4(BODY, rp);\n\n    if (head < d) {\n        d = head; r = vec4(HEAD, rpHead);\n    }\n    if (aile < d) {\n        d = aile; r = vec4(AILE, pa);\n    }\n    if (feet < d) {\n        d = feet; r = vec4(FEET, rp);\n    } \n    if (cou.x-.04<d) {\n        vec3 uvCou = sdBezierUV(rp_real, headPos, vec3(0, .2,.02), vec3(.0, .15,.03), cou);\n        d = cou.x-.04; \n        r = vec4(COU, isStanding ? uvCou : vec3(-uvCou.x, uvCou.y, uvCou.z));\n    } \n\n    return min(feet, body);\n}\n\n\nvec4 rColor;\n\n\nfloat mapGround(in vec3 p0) {\n    return p0.y - hGround(p0);\n}\n\nfloat map(in vec3 p0) {\n    float hG = hGround(p0),\n          dGround = p0.y - hG;\n\n    vec3 p = p0;\n    float id = 0.;\n    if (sceneId == 4) {\n        p.z +=.1;\n        id = sign(p.z);\n        p.z = abs(p.z);\n        p.z -=.16;\n        p.x += .01*id;\n        \n    } else if (sceneId == 3) {\n        vec2 id3 = vec2(0);\n        vec3 p1 = p0;\n        p1.xz += 20.;\n        p.xz = opSunFlowerRep(p1.xz, id3, false, vec2(2.5,1.1));\n        // Couples\n        if (mod(id3.y,2.) <.5) p.z = -p.z;\n        p.z += .35*smoothstep(25.,35., gTime);\n        id = id3.x;\n        \n    } else if (sceneId == 5) {\n        vec2 id3 = vec2(0);\n        vec3 p1 = p0;\n     //   p1.xz -= vec2(3.,9.);\n        if (length(p1.xz)>5.2) return 999.;\n        p.xz = opSunFlowerRep(p1.xz, id3, false, vec2(.7,.4));\n        p.xz = p.zx;\n        //p.x += .05;\n        id = id3.x;\n        if (id < 5. /*|| id>700.*/) return 1.;\n        \n    } else if (sceneId != -2) {\n         float dz = sceneId == -1 || sceneId == 6 ? .29*gTime-2. : .14*gTime;\n         if (sceneId == 1) {\n             p = p0;\n             p.x -= 5.;\n             dz *= 6.;  // 6 fois plus rapide en glissades\n         }\n        \n         if (sceneId == 6) {\n             p.z = -p.z + dz;\n         } else {\n             p.z += dz;\n         }\n         float id2 = 0.;\n         if (sceneId == 2) {\n             p.x += .8*cos(.5*p.z+cos(.1*p.z));\n             id2 = pModInterval1(p.x, .45, -1.,1.);\n             p.z += .6*hash11(id2+1.2);\n         }\n\n//p.z = mod(p.z +.45, .9) - .45;\n         id = id2*100.+ pModInterval1(p.z, sceneId == -1 ? 16. : sceneId == 6 ? 3.8 : .9, -58.,58.);\n         if (sceneId == 6) p.xz += vec2(3,2)*(.5-hash22(vec2(id, id2)));\n         if (sceneId == 1 || id>2. && id<4.) isStanding = false;\n     }\n          \n     float d = sdPenguin(p, p0, hG, id, rColor);\n     isStanding = true;\n     if (sceneId == 4) {\n        float d0 = sdEgg(p0-vec3(-.04,.085,-.04),.075);\n        if (d0<d) {\n            d = d0;\n            rColor = vec4(EGG,p0);\n        }\n     }\n     return d * (sceneId == 3 ? .45 : .7);\n\n}\n\n//-------------------------------------------------------------\n//     Textures 3D (Shane)\n//-------------------------------------------------------------\n\nvec3 tex3D(in vec3 p, in vec3 n){\n    p += 10.;\n    p *= 100.;\n    n = max(n*n, .001);\n    n /= (n.x + n.y + n.z );  \n\treturn noised(p.yz)*n.x + noised(p.zx)*n.y + noised(p.xy)*n.z;\n}\n\n// Grey scale.\nfloat grey(vec3 p) { return dot(p, vec3(.299, .587, .114)); }\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap(vec3 p, vec3 n, float k){\n    const float ep = .001;\n    vec3 grad = vec3(grey(tex3D(vec3(p.x-ep, p.y, p.z), n)),\n                     grey(tex3D(vec3(p.x, p.y-ep, p.z), n)),\n                     grey(tex3D(vec3(p.x, p.y, p.z-ep), n)));\n    grad = (grad - grey(tex3D(p, n)))/ep;             \n    grad -= n*dot(n, grad);          \n    return normalize(n + grad*k);\n}\n\n//---------------------------------------------------------------------\n//   Calculate normal\n// inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n//---------------------------------------------------------------------\nvec3 normal(in vec3 pos, vec3 rd, float t, float k) {\n    withBBox = false;\n    vec3 n = vec3(0);\n    for( int i=ZERO; i<4; i++) {\n        vec3 e = .5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n        n += e*map(pos+k*e);\n    }\n\treturn normalize(n - max(0., dot(n,rd))*rd);\n}\n\nvec3 normalGround(in vec3 pos, vec3 rd, float t, float k) {\n    vec3 n = vec3(0);\n    for( int i=ZERO; i<4; i++) {\n        vec3 e = .5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n        n += e*mapGround(pos+k*e);\n    }\n\treturn normalize(n - max(0., dot(n,rd))*rd);\n}\n\n#ifdef WITH_SHADOW\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k ) {\n    withBBox = false;\n    float res=1., t=.05+.1*hash22(rd.xy).x, h=1.;\n    for(int i=ZERO; i<48; i++ ) {\n        h = min(map(ro + rd*t), mapGround(ro + rd*t));\n        res = min( res, k*h/t );\n\t\tt += clamp( h, .01, .1);\n\t\tif (h<.005) break;\n    }    \n    return clamp(res,0.,1.);\n}\n\n#endif\n\nvec3 skyColor(vec3 col, vec3 ro, vec3 rd, float sun) {\n    vec2 cuv = ro.xz + rd.xz*(100.-ro.y)/rd.y;\n    float cc = texture( iChannel1, .0003*cuv + .1+ .0023*iTime ).x;\n    cc = .65*cc + .35*texture( iChannel1, .0006*cuv + .00115*iTime ).x;\n    cc = smoothstep( .3, 1., cc );        \n    return mix( col, vec3(.95+.20*(1.-cc)*sun), .7*cc );\n}\n\n\nfloat trace(vec3 ro, vec3 rd, inout vec3 col) {\n   // vec3 ro = rp;\n\n\tfloat d, precis = .006, t = 0., tg = 0., m = -1., fog = 0.;\n\n    for (int i=ZERO; i<200; i++) {\n        t += d;\n\t    d = map(ro+rd*t);     \n        if (sceneId>4) fog += fogmap(ro+rd*t, t);\n        if (abs(d) < 1e-2*t*precis || t>FAR) \n            break;\n    }\n\n    for( int i=ZERO; i<300; i++) {\n\t    d = mapGround(ro+rd*tg);\n        tg += d;\n        if (abs(d) < 1e-2*tg*precis || tg>t) \n            break;        \n    }\n    fog = min(1., .05*fog);\n    \n    vec3 pos, nor;\n    \n    if (tg < t) {\n        pos = ro+rd*tg;\n        rColor = vec4(GROUND, pos);\n        t = tg;\n        nor = normalGround(pos, rd, t, .05);\n    } else {\n        pos = ro+rd*t;\n        withBBox = false;\n        map(pos); // To get Color in rColor\n        nor = normal(pos, rd, t, .007);\n    }\n \n    vec3 lig = normalize(vec3(-.5,.25,-.3));\n    col = .9*(2.5*vec3(.18,.33,.45) - rd.y*1.5);\n    \n    float sun = clamp( dot(rd,lig), 0., 1.);\n\tcol += vec3(2,1.5,0)*.8*pow( sun, 32.);\n    \n    vec3 bgcol = col, color = bgcol, mate2 = vec3(0);\n    bool isSea = false;\n\n    if (t<FAR) {\n        vec3 ch = vec3(.04), cb = vec3(.1), cw = vec3(1),\n             uvw = rColor.yzw;\n       \n        float kspe = .1; // coeff specularity\n        if (rColor.x == BEAK) {\n            kspe = 1.;\n        }\n        if (rColor.x != BEAK && rColor.x != EGG && rColor.x != GROUND) {\n            nor = doBumpMap(rColor.yzw*3.1*vec3(1,.2,1)+2., nor, .0005); \n            cb += .05*tex3D(5.*rColor.yzw*vec3(1.,.25,1.), nor).x;\n        }\n       \n        color = vec3(.7);\n        \n        if (rColor.x == EGG) {\n            color = vec3(.9,1.,.8);\n            \n        } else if (rColor.x == HEAD) {\n            color = mix(ch, .5*vec3(1,.55,.5), smoothstep(.03,.025, length(vec2(9.,1.)*(rColor.zw-vec2(-.008,-.107)))));\n            \n            vec2 eyePos = rColor.zw - vec2(.014,-.038);\n            float dEye = max(length(eyePos-vec2(.003,0)), length(eyePos+vec2(.003,0)))- .007;  \n            kspe = dEye < 0. ? 2. : .1; \n            vec3 colEye = mix(vec3(0), .1*vec3(1,.7,.5), .6+.4*smoothstep(.0,.001, length(eyePos+vec2(0,.006))-.004));\n            color = mix(colEye, color, smoothstep(.0,.001, dEye));\n            \n        } else if (rColor.x == AILE) {\n            color = mix(cb, cw, smoothstep(.001,.02,rColor.y+.1*(rColor.w-rColor.z)));\n           \n        } else if (rColor.x == BODY) {\n            \n            color = vec3(1);\n          \n            color = mix(color, vec3(1,.5,0), smoothstep(.14,.2, rColor.z));\n            color = mix(color, vec3(1,1.,0), smoothstep(.17,.2, rColor.z));\n            \n            color = mix(cb, color, smoothstep(.03,.04,-rColor.w+.03 -.024*sin(.7+12.*uvw.y)));\n            \n            color = mix(mix(vec3(1,1,0),vec3(1,1,1), smoothstep(.0,.01, length(rColor.z)-.199)),\n            color, smoothstep(.039,.042, length(rColor.zw-vec2(.235,0))+.003));\n            // le petit trait noir des epaules\n            color = mix(ch, color, smoothstep(.0,.005, sdSegment(vec3(0,rColor.z,rColor.w), vec3(0,.1,-.024), vec3(0,.195,-.01))-.05*(rColor.z-.1)));\n            \n        } else if (rColor.x == COU) {\n        \n            color = .5+.5*cos(vec3(200,20,200)*rColor.yzw);\n            vec3 uv = vec3(200,20,200)*rColor.yzw - vec3(0,8,0);\n\n            color = mix(cw, vec3(1,1,.001), smoothstep(-2.,2., -uv.y));\n            color = mix(color, vec3(1,.5,.001), smoothstep(-1.,5., -uv.y));\n            color = mix(color, mix(ch,cb, smoothstep(-4.,8.,uv.y)), smoothstep(.4,.0, 4.+uv.y+1.8*cos(.6*uv.z)-20.*smoothstep(.1,8.,-uv.x)));\n       \n       } else if (rColor.x == FEET) {\n            color = vec3(.3);\n            kspe = .2;\n            \n        } else if (rColor.x == GROUND) {\n            color = vec3(.97);\n            float dSea = pos.y - (.02 + .005+.005*cos(1.5*iTime+length(pos.xz)));\n            isSea = (sceneId == -2 && pos.z>-3. && dSea<.007);\n\n            if (isSea) {\n               color = mix(color,.2*vec3(.5,.7,.9), smoothstep(.012, .0, dSea));\n           //  color = mix(color+.1*vec3(0,1,1), color, smoothstep(.0, .01, dSea+.02+.001*cos(iTime)));\n            }\n           \n            kspe = .5;\n            nor = doBumpMap(rColor.yzw*.7, nor, .0003); \n\n            float iss = smoothstep( .5, .9, nor.y );\n            iss = 2.*mix( iss, .9, .75*smoothstep( .1, 1., noise3D(.25*pos)));\n            vec3 cnor = normalize( -1. + 2.*texture( iChannel2, .25*pos.xz).xyz );\n            cnor.y = abs(cnor.y);\n            float spe2 = max(0., pow( clamp( dot(lig,reflect(rd,cnor)), 0., 1.), 16.));\n            mate2.y = spe2*iss*(.5+.5*cos(20.*iTime+6.28*hash12(pos.xz)));\n        }\n\n\t\t// lighting\n        float sky = .6 + .4*nor.y,\n             bou = clamp(-nor.y,0.,1.),\n             dif = max(dot(nor,lig),0.),\n             bac = max(.2 + .8*dot(nor,normalize(vec3(-lig.x,0,-lig.z))),0.);\n\t\t\n#ifdef WITH_SHADOW\n        float sha = 0.;\n        if (dif > 0.) {\n            sha = softshadow( pos+.075*nor*hash12(10.*pos.xy+1.234*pos.z), lig, 4.);\n        }\n#else         \n        float sha = 1.;\n#endif\n        float fre = pow(clamp(1.+ dot(nor,rd), .01, 1. ), 3. ),\n              spe = pow(max( dot( reflect(-lig, nor), -rd ), 0.), 16.); // Specular term.\n\t\t// lights\n\t\tvec3 lin = dif*vec3(1.7,1.15,.7)*pow(vec3(abs(sha)),vec3(1.,1.2,2.));\n\t\tlin += 1.2*bou*vec3(.15,.2,.2);\n        lin += fre*vec3(1,1.25,1.3)*.5*(.5+.5*dif*sha)\n                    +sky*vec3(.05,.20,.45)\n\t\t\t\t\t+bac*vec3(.2,.25,.25);\n \n        lin += mate2.y*vec3(1,.6,.5)*4.*dif*(.1+.9*sha);\n        col = color*lin + (.5+.5*color)*spe*kspe;//*sha;\n    \n        if (rColor.x == GROUND) {\n            vec3 ref = reflect(rd, nor);\n            col += .2*col*skyColor(bgcol, pos, ref, clamp(dot(ref,lig), 0.0, 1.0 )); \n        }\n        col = mix( col, bgcol, smoothstep(15.,FAR,t) );\n\n        if (isSea) {\n           col += skyColor(col, pos, reflect(rd, nor), sun);\n        }\n    } else {\n        col = skyColor(col, ro, rd, sun);\n    }\n\n\t// sun glow\n    col += vec3(1,.6,.2)*.4*pow( abs(sun), 4.);\n  \n    if (sceneId >= 5) {\n       col = mix(.7*col, vec3(0.6, .65, .7), sqrt(fog));\n       col = length(col)*.2 + .8*col;\n    }\n    \n    return t;\n}\n\nmat3 lookat(vec3 from, vec3 to) {\n    vec3 f = normalize(to - from),\n         u = normalize(cross(normalize(cross(f, vec3(0,1,0))), f));\n    return mat3(normalize(cross(u, f)),u,f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    rColor = vec4(0);\n\n\tvec2 q = fragCoord.xy / iResolution.xy,\n         uv = q-.5;\n    uv.y /= iResolution.x / iResolution.y;\n\n    vec3 rd = normalize(vec3(uv, 1)),\n         rp = vec3(0, 1, -2.2);\n    \n    vec2 im = iMouse.xy / iResolution.xy;\n    \n    gTime = iTime - 40.;\n    \n    sceneId = 6; \n   \n    if (gTime < -20.) sceneId = -2;\n    else if (gTime < 1.)  sceneId = -1;\n    else if (gTime < 20.) sceneId = 0;\n    else if (gTime < 25.) sceneId = 1;\n    else if (gTime < 44.) sceneId = 2;\n    else if (gTime < 70.) sceneId = 3;\n    else if (gTime < 85.) sceneId = 4;\n    else if (gTime < 105.) sceneId = 5;\n    else sceneId = 6;\n    \n    isWalking = true;\n\n    if (sceneId == 5) {\n        float dd = smoothstep(135.,145., iTime);\n        if (uv.x<mix(.7,-.7,dd)-uv.y*.25) { \n            uv *= mix(1.,2.,dd);\n        } else {\n            uv.x -= mix(.5,0.,dd);\n            sceneId = 6;         \n        }\n    }\n    \n    if (sceneId == -2) { \n        gTime = iTime;\n        isWalking = false;\n        gTime = iTime;\n        withBBox = false;\n        rp = vec3(.0,.57,-.15) + mix(.2,.7,gTime/20.)* vec3(-cos(.1*gTime), -.05, sin(.1*gTime));\n        rp.y = max(rp.y, hGround(rp) + .1);\n        rd = lookat(rp, vec3(.0,.57,-.15)) * normalize(vec3(uv, 1.));\n        \n    } else if (sceneId == -1) { \n        gTime = iTime-20.;\n        rp = mix(vec3(2.7,.5,-4.), vec3(20,7.,33), smoothstep(7.,27.,gTime));\n        rp.y = max(rp.y, hGround(rp) + .1);\n        rd = lookat(rp, vec3(0,1.,-2)) * normalize(vec3(uv, 1.));\n        \n    } else if (sceneId == 0) {\n        // Marche petit groupe\n        if (sceneId == 6) gTime = iTime - 145.;\n        rp = vec3(2.7-.05*gTime,-1.+.035*gTime,1.7);\n        rp.y = max(rp.y, hGround(rp) + .1);\n        rd = lookat(rp, vec3(0,0.5,0)) * normalize(vec3(uv, 1.));\n        \n    } else if (sceneId == 6) {\n        // Marche petit groupe retour\n        gTime = iTime - 145.;\n        rp = vec3(.7,.7+.035*gTime,-36.+.39*gTime);\n        rp.y = max(rp.y, hGround(rp) + .1);\n        rd = lookat(rp, vec3(0,0.5,-38.+.39*gTime)) * normalize(vec3(uv, 1.));\n\n    } else if (sceneId == 1) {\n        // Glissades\n        rp = vec3(3.7,1.,-18.7);\n        rp.y = max(rp.y, hGround(rp) + .1);\n        rd = lookat(rp, vec3(5,0.5,-15.)) * normalize(vec3(uv, 1.));\n        \n    } else if (sceneId == 2) {\n        // Marche en grand groupes\n        rp = vec3(12.7,3.5+.035*gTime,.7-.5*gTime); \n        rp.y = max(rp.y, hGround(rp) + .1);\n        rd = lookat(rp, vec3(-2.,.5,10.-1.*gTime)) * normalize(vec3(uv, 1.));\n        \n    }  else if (sceneId == 3) {\n        // Rassemblement + rencontre\n        gTime = iTime - 58.;\n        rp = vec3(27.7+.3*gTime+5.*sin(.2*gTime), 8.+cos(.31*gTime),1.7-.5*gTime+5.*cos(.2*gTime));\n        rp.y = max(rp.y, hGround(rp) + .1);\n        \n        vec3 ta = vec3(-16.-.5*gTime,.05, -23.+.3*gTime),\n        rp2, ta2 = vec3(1.3,.45,17.1);\n        rp2 = ta2 + vec3(cos(.6*gTime+1.7),-.05+.05*cos(iTime), sin(.6*gTime+1.7)); \n        rp = mix(rp,rp2,smoothstep(20.,40.,gTime));\n        ta = mix(ta,ta2,smoothstep(20.,40.,gTime));\n        rd = lookat(rp, ta) * normalize(vec3(-uv.x, uv.y, 1.1));\n        \n     } else if (sceneId == 4) {\n        gTime = iTime-70.;\n        isWalking = false;\n        withBBox = false;\n        rp = vec3(0,.5,-.15) + (1.25+.05*gTime)*vec3(-cos(-.1*gTime), .01, sin(-.1*gTime));\n        rp.y = max(rp.y, hGround(rp) + .1);\n        rd = lookat(rp, vec3(0,.5,-.15)) * normalize(vec3(uv, 1.));\n        \n     } else if (sceneId == 5) {\n        // froid\n        gTime -= 70.;\n        isWalking = true;\n        rp = vec3(4.*sin(-.02*gTime), 1.2, 5.*cos(-.02*gTime));\n        rp.y = hGround(rp) + 1.1+.1+.2*cos(.2*iTime);\n        vec3 ta = vec3(2.5*sin(-.02*gTime-1.)-1.6+.1*gTime, .5, 2.5*cos(-.02*gTime-1.));\n        rd = lookat(rp, ta) * normalize(vec3(-uv.x, uv.y, 1.1));\n     } \n    \n    vec3 col; \n    float dist = trace(rp, rd, col);\n    fragColor = vec4(col, dist);\n}\n\n// undersea\n// https://www.shadertoy.com/view/llcSz8",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}