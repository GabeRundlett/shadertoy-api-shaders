{
    "Shader": {
        "info": {
            "date": "1638272016",
            "description": "A moving picture in animation（Magical King Granzort）",
            "flags": 0,
            "hasliked": 0,
            "id": "7lG3zd",
            "likes": 0,
            "name": "Magical King Granzort",
            "published": 3,
            "tags": [
                "2dcirletesttime"
            ],
            "usePreview": 0,
            "username": "luolin",
            "viewed": 262
        },
        "renderpass": [
            {
                "code": "float isInSector(vec2 tex, vec2 center, float dis, float t) // 是否在扇形中\n{\n\tfloat res = 0.;\n\tfloat theta = radians(clamp(t, 0., 360.));\n    \n\tfloat rotate_x = sin(theta/2.) + center.x;\n\tfloat rotate_y = cos(theta/2.) + center.y;\n\tvec2 half_theta_v = normalize(vec2(rotate_x, rotate_y) - center);\n\tvec2 c_top = vec2(0, 1);\n\tvec2 cur_v = normalize(tex - center);\n\tfloat cur_theta = acos(dot(half_theta_v, cur_v));\n\treturn step(cur_theta, theta/2.) * step(0., -length(vec2(tex - center)) + dis);\n}\n\nfloat sdfCircle(vec2 tex, vec2 center, float dis)\n{\n    return dis - length(vec2(tex - center)) ;\n}\n\nfloat getPointLineDis(vec2 tex, vec2 p1, vec2 p2)\n{\n\tif((tex.y - p2.y)*(p1.x - p2.x) == (p1.y - p2.y) * (tex.x - p2.x))\n\t{\n\t\treturn 0.0;//共线\n\t}\n\tfloat len1 = length(tex -p1);\n\tfloat len2 = length(tex -p2);\n\tfloat len3 = length(p1 -p2);\n\tfloat half_p = 0.5 * (len1 + len2 + len3);\n\tfloat s = sqrt(half_p * (half_p - len1) * (half_p-len2) * (half_p-len3));\n\tfloat dis = s * 2. / len3;\n\treturn dis;\n}\n\n\nfloat sdfPloygon(mat4x4 points, vec2 tex, float is_in ) // 计算多边形距离场\n{\n\tfloat c=0.;\n\tfloat cur_dis = 100.;\n\n\tint j=0;\n\tint k=0;\n\tint temp_j = 0;\n\tint temp_k = 0;\n\tfor (int i = 0; i < 3; i++) \n\t{\t\n\t\tj = (i*2) / 4;\n\t\ttemp_j = i*2 - i*2 / 4 * 4;\n\t\tvec2 p = vec2(points[j][temp_j], points[j][temp_j + 1]);\n\t\tk = (i*2 + 2) / 4;\n\t\ttemp_k = (i+1)*2 - (i+1)*2 / 4 * 4;\n\t\tvec2 p1 = vec2(points[k][temp_k], points[k][temp_k + 1]);\n\t\n\t\tfloat tmp = p1.x - p.x;\n\t\tvec2 cur_center = 0.5 *(p + p1);\n\t\tfloat dis_c = length(cur_center - tex);\n\t\tfloat length_line = length(p1 - p);\n\t\tfloat dis_l = getPointLineDis(tex, p, p1);\n\t\tfloat dis_2p = min(length(tex - p), length(tex - p1));\n\t\tfloat flag_in_range_line = dot(p-tex, p-p1) * dot(p1-tex, p1-p);\n        cur_dis = min(cur_dis, max(dis_l * step(0., flag_in_range_line),  dis_2p * step(flag_in_range_line, 0.)));\n    }\n\n\treturn cur_dis * (1. - 2. *step(is_in, 0.5));\n}\n\nfloat IsInPloygon(mat4x4 points, vec2 tex ) // 判断是否在多边形内\n{\n\tfloat c=0.;\n\tint j=0;\n\tint k=0;\n\tint temp_j = 0;\n\tint temp_k = 0;\n\tfor (int i = 0; i < 3; i++) \n\t{\t\n\t\tfloat flag = 1.0f;\n\t\tj = (i*2) / 4;\n\t\ttemp_j = i*2 - (i*2 / 4) * 4;\n\t\tvec2 p = vec2(points[j][temp_j], points[j][temp_j + 1]);\n\t\tk = (i*2 + 2) / 4;\n\t\ttemp_k = (i+1)*2 - (i+1)*2 / 4 * 4;\n\t\tvec2 p1 = vec2(points[k][temp_k], points[k][temp_k + 1]);\n\t\tfloat tmp = p1.x - p.x;\n\t\tflag = step(0.00001, abs(tmp));\n\t\tfloat slope = (p1.y - p.y) / tmp;\n\t\tfloat cond1 = step(p.x, tex.x) * step(tex.x, p1.x);\n\t\tfloat cond2 = step(p1.x, tex.x) * step(tex.x, p.x);\n\t\tfloat above = step(tex.y, (slope * (tex.x - p.x) + p.y));\n\t\tfloat cur_val = above* flag *(cond1 + cond2);\n\t\tc = c + cur_val;\n    }\n\treturn mod(c, 2.);\n}\n\nfloat sdfTrigle(vec2 tex, vec2 p0, vec2 p1, vec2 p2)\n{\n\tmat4x4 points;\n\tpoints[0].xy = p0;\n\tpoints[0].zw = p1;\n\tpoints[1].xy = p2;\n\tpoints[1].zw = p0;\n\n\tfloat is_in_tri = IsInPloygon(points, tex);\n\tfloat res = sdfPloygon(points, tex,  is_in_tri );\n\treturn res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    vec2 center = 0.5 * iResolution.xy;\n    vec3 background_color = vec3(0.5, 0.5, 0.5);\n    vec3 c1 = vec3(1.0, 0., 0.);\n    vec3 c2 = vec3(0., 1., 0.);\n    vec3 c3 = vec3(0., 0., 1.);\n\tfloat edge_width =iResolution.y * 0.025; \n\tfloat radius = iResolution.y * 0.25;\n    \n    float cir_d = sdfCircle(uv, center, radius);\n    float anti = fwidth(cir_d);\n\tvec3 col =  mix(background_color, c1, smoothstep(-anti, anti, cir_d ));\n    float d1 = sdfCircle(uv, center, radius - edge_width);\n\tfloat anti1 = fwidth(d1);\n\tfloat edge_alpha = smoothstep(-anti1, anti1, d1);\n\tcol = mix(col, background_color, edge_alpha);\n    // Output to screen\n\n\tfloat is_in_0 = isInSector(uv, center, radius + anti, iTime*100.);\n\n\tif(is_in_0 <= 0.)\n\t{\n\t\tcol = background_color.xyz;\n\t}\n\n\tfloat tri_d0 = 0.;\n\tfloat tri1_anti = 0.;\n\tfloat tri1_anti1 = 0.;\n\n\tfloat tri2_anti = 0.;\n\tfloat tri2_anti1 = 0.;\n\n\tvec3 col1 = col;\n\tvec3 col2 = col;\n\tfloat tri_radius = radius - edge_width - anti1;\n\n\tif((cir_d > (edge_width + anti1) || cir_d <0. - anti )&& iTime*100. > 360.)\n\t{\n\t\tvec2 p0 = vec2(center.x, center.y + tri_radius);\n\t\tvec2 p1 = vec2(center.x + tri_radius * cos(radians(30.)), center.y - tri_radius* sin(radians(30.)));\n\t\tvec2 p2 = vec2(center.x - tri_radius * cos(radians(30.)), center.y - tri_radius* sin(radians(30.)));\n\n\t\ttri_d0 = sdfTrigle(uv, p0, p1, p2);\n\t\ttri1_anti = fwidth(tri_d0);\n\t\tcol1 = mix(background_color, c2, smoothstep(-tri1_anti, tri1_anti,tri_d0 ));\n\n\t\ttri1_anti1 = fwidth(tri_d0 - edge_width);\n\t\tcol1 = mix(col1, background_color, smoothstep(-tri1_anti1, tri1_anti1,tri_d0 - edge_width ));\n\n\t\tfloat is_in_1 = isInSector(uv, center, radius + tri1_anti, iTime*100. - 360.);\n\n\t\tif(is_in_1 <= 0.)\n\t\t{\n\t\t\tcol1 = background_color.xyz;\n\t\t}\n\t\tcol = col1;\n\t}\n\n\tvec2 p0 = vec2(center.x - tri_radius * cos(radians(30.)),  center.y + tri_radius * sin(radians(30.)));\n\tvec2 p1 = vec2(center.x + tri_radius * cos(radians(30.)), center.y + tri_radius* sin(radians(30.)));\n\tvec2 p2 = vec2(center.x , center.y  - tri_radius);\n\n\tfloat tri_d1 = sdfTrigle(uv, p0, p1, p2);\n\ttri2_anti = fwidth(tri_d1);\n\ttri2_anti1 = fwidth(tri_d1 - edge_width);\n\n\tbool flag0 = tri_d0 > edge_width + tri1_anti || tri_d0 < 0. - tri1_anti1;\n\tbool flag1 = (tri_d0 <= edge_width + tri1_anti && tri_d0 >= 0. - tri1_anti1) &&  (tri_d1 <= edge_width + tri2_anti && tri_d1 >= 0. - tri2_anti1);\n\n\tif((cir_d > (edge_width + anti1) || cir_d < 0. - anti ) && (flag0 || flag1 ) && iTime*100. > 720.)\n\t{\n        \n        if(flag1)\n        {\n            col2 = mix(col, c3, smoothstep(-tri2_anti, tri2_anti,tri_d1 ));\n            col2 = mix(col2, col, smoothstep(-tri2_anti1, tri2_anti1,tri_d1 - edge_width ));\n        }\n        else\n        {\n            col2 = mix(background_color, c3, smoothstep(-tri2_anti, tri2_anti,tri_d1 ));\n            col2 = mix(col2, background_color, smoothstep(-tri2_anti1, tri2_anti1,tri_d1 - edge_width ));\n        }\n\n\t\tfloat is_in_2 = isInSector(uv, center, radius + tri2_anti1, iTime*100. - 720.);\n\n\t\tif(is_in_2 <= 0.)\n\t\t{\n\t\t\tcol2 = col;\n\t\t}\n\t\tcol = col2;\n\t}\n\t\n    fragColor = vec4(col,1.0);\n   }",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}