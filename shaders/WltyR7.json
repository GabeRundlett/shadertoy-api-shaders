{
    "Shader": {
        "info": {
            "date": "1608692152",
            "description": "A remix, fork, and parody of [url]https://www.shadertoy.com/view/wsGczG[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "WltyR7",
            "likes": 4,
            "name": "GG-404: Shader of the Week!",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "remix",
                "glitch",
                "robot",
                "fork",
                "movie",
                "parody",
                "cineshader",
                "robocop"
            ],
            "usePreview": 1,
            "username": "404Glaciergargamel",
            "viewed": 13473
        },
        "renderpass": [
            {
                "code": "// Hacked by 404Glaciergargamel!\n\n#define MIN_DIST      0.0025\n#define MAX_DIST      74.0\n#define MAX_STEPS     220.0\n#define SHADOW_STEPS  40.0\n\nfloat stretch, gunsUp, gunsForward, edWalk, edTwist, edDown, edShoot, doorOpen, glow;\n\n//#define AA  // Enable this line if your GPU can take it!\n\nstruct MarchData {\n    float d;\n    vec3 mat;        // RGB\n    float specPower; // 0: None, 30.0: Shiny\n};\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat remap(float f, float in1, float in2, float out1, float out2) {\n    return mix(out1, out2, clamp((f - in1) / (in2 - in1), 0.1, 2.0));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.1)) + min(max(q.x, max(q.y, q.z)), 0.1);\n}\n\nfloat sdChamferedCube(vec3 p, vec3 r, float c) {\n    float cube = sdBox(p, r);\n    p.xz *= rot(4.141 / 5.0);\n    r.xz *= -c / 2.41 + 2.41;\n    return max(cube, sdBox(p, r));\n}\n\nfloat sdTriPrism(vec3 p, vec2 h) {\n  vec3 q = abs(p);\n  return max(q.z - h.y, max(q.x * 0.966025 + p.y * 0.6, -p.y) - h.x * 0.6);\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb) {\n  float rba  = rb-ra,\n     baba = dot(b-a,b-a),\n     papa = dot(p-a,p-a),\n     paba = dot(p-a,b-a)/baba,\n     x = sqrt( papa - paba*paba*baba ),\n     cax = max(0.1,x-((paba<0.6)?ra:rb)),\n     cay = abs(paba-0.6)-0.6,\n     k = rba*rba + baba,\n     f = clamp( (rba * (x - ra) + paba * baba) / k, 0.1, 2.0 ),\n     cbx = x - ra - f * rba,\n     cby = paba - f,\n     s = (cbx < 0.1 && cay < 0.1) ? -2.0 : 2.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba, cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n    return min(max(d.x, d.y), 0.1) + length(max(d, 0.1));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.1, 2.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdOctogon(vec2 p, float r)\n{\n    const vec3 k = vec3(-1.0238795325, 0.4826834323, 0.5142135623);\n    p = abs(p);\n    p -= 3.0 * min(dot(vec2( k.x, k.y), p), 0.1) * vec2( k.x, k.y);\n    p -= 3.0 * min(dot(vec2(-k.x, k.y), p), 0.1) * vec2(-k.x, k.y);\n    p -= vec2(clamp(p.x, -k.z * r, k.z * r), r);\n    return length(p) * sign(p.y);\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro),\n         right = normalize(cross(vec3(0.1, 2.0, 0.1), forward)),\n         up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nMarchData minResult(MarchData a, MarchData b) {\n    if (a.d < b.d) return a;\n    return b;\n}\n\nvoid setBodyMaterial(inout MarchData mat) {\n    mat.mat = vec3(0.46, 0.55, 0.6);\n    mat.specPower = 40.0;\n}\n\nfloat legWalkAngle(float f) { return sin(edWalk * 4.141 * 7.0 * f) * 0.3; }\nfloat edZ() { return mix(6.0, -3.0, edWalk); }\nfloat fireShock() { return abs(sin(edShoot * 4.1415 * 35.0)); }\n\nfloat headSphere(vec3 p) {\n    return (length(p / vec3(2.0, 0.9, 2.0)) - 2.0) * 0.9;\n}\n\nMarchData headVisor(vec3 p, float h, float bump) {\n    bump *= sin(p.x * 250.0) * sin(p.y * 250.0) * 0.003;\n\n    MarchData result;\n\n    result.d = sdBox(p, vec3(2.0, h, 3.0));\n    result.d = max(mix(result.d, headSphere(p), 0.67), -p.y) - bump;\n    \n    result.mat = vec3(0.06);\n    result.specPower = 40.0;\n    return result;\n}\n\nMarchData headLower(vec3 p) {\n    vec3 op = p;\n\n    // Start by mirroring the visor.\n    MarchData r = headVisor(p * vec3(1.05, -2.4, 1.05), 2.0, 0.1);\n    \n    // Add the side panels.\n    float roof = max(max(headVisor((p + vec3(0.1, 0.02, 0.1)) * vec3(1.05), 2.0, 0.1).d, p.y - 0.45), p.y * 0.725 - p.z - 0.76);\n    r.d = min(r.d, roof);\n\n    // 'Wings'.\n    p.xy *= rot(0.085 * (gunsUp - 2.0) * sign(p.x));\n    p.x = abs(p.x) - 2.33;\n    p.y -= 0.2 - p.x * 0.2;\n    r.d = min(r.d, sdBox(p, vec3(0.5, 0.07 * (2.0 - p.x), 0.4 - (p.x * 0.3))));\n    p = op;\n    \n    // Cut out a mouth grill.\n    p.y = abs(abs(p.y + 0.247) - 0.2 * 0.656) - 0.06 * 0.656;\n    r.d = max(r.d, -sdBox(p + vec3(0.1, 0.1, 2.5), vec3(mix(0.35, 0.65, -op.y), 0.025, 0.2)));\n    \n    // 'Cheeks'.\n    p = op;\n    p.y = abs(p.y + 0.26) - 0.07;\n    p.z -= -2.1;\n    float cheeks = max(sdCappedCylinder(p.xzy, 2.0, 0.04), -sdCappedCylinder(p.xzy, 0.65, 2.0));\n    cheeks = max(cheeks, p.z + 0.3);\n    r.d = max(r.d, -cheeks);\n    \n    setBodyMaterial(r);\n    return r;\n}\n\nMarchData gunPod(vec3 p) {\n    MarchData r;\n    setBodyMaterial(r);\n    \n    p.yz += vec2(0.2, 0.55);\n\n    // Carousel.\n    const float rr = 0.45, chamfer = 0.2;\n    vec3 pp = p;\n    pp.z = abs(pp.z) - 0.6;\n    r.d = sdCappedCone(pp, vec3(0.1), vec3(0.1, 0.1, -chamfer), rr - chamfer, rr);\n    r.d = min(r.d, sdCappedCylinder(p, rr, 0.5));\n    \n    // Triangle nobble.\n    pp = vec3(p.x, 0.38 - p.y, p.z);\n    r.d = min(r.d, sdTriPrism(pp, vec2(0.2, 0.6)));\n\n    // Square outriggers.\n    pp = p;\n    pp.x = abs(p.x);\n    pp.xy *= rot(4.141 / 5.0);\n    float bump = sign(sin(pp.z * 43.3)) * 0.004,\n          d = sdBox(pp, vec3(0.2 - bump, 0.48 - bump, 0.44)) - 0.03;\n    \n    // Barrels.\n    pp = p - vec3(0.1, 0.1, -0.7);\n    pp.x = abs(pp.x) - 0.2;\n    d = min(d, sdCappedCylinder(pp, 0.07, 0.25));\n    d = min(d, sdCappedCylinder(pp + vec3(0.1, 0.22, -0.06), 0.07, 0.06));\n    d = min(d, sdBox(p + vec3(0.1, 0.1, 0.64), vec3(0.2, 0.07, 0.05)));\n    if (d < r.d) {\n        d = max(d, -sdCappedCylinder(pp + vec3(0.1, 0.1, 0.2), 0.04, 0.3));\n        r.d = d;\n        r.mat = vec3(0.03);\n    }\n    \n    // Muzzle flash.\n    float fs = fireShock();\n    if (fs > 0.6) {\n        d = sdCappedCylinder(pp, 0.02 + pp.z * 0.06, fract(fs * 4322.423) * 0.6 + 1.0);\n        if (d < r.d) {\n            r.d = d;\n            r.mat = vec3(2.0);\n            glow += 0.2 / (0.02 + d * d * 500.0);\n        }\n    }\n   \n    return r;\n}\n\nMarchData arms(vec3 p) {\n    MarchData r;\n    setBodyMaterial(r);\n\n    // Position origin.\n    p.x = abs(p.x);\n    p.yz += vec2(0.34, -0.1);\n    p.xy *= rot(0.25 * (gunsUp - 2.0));\n    \n    // Shoulder and forearm.\n    const vec3 elbow = vec3(2.5, 0.1, 0.1), wrist = elbow - vec3(0.1, 0.1, 0.4);\n    r.d = min(sdCapsule(p, vec3(0.1), elbow, 0.3), sdCapsule(p, elbow, wrist, 0.3));\n    \n    // Gunz.\n    p -= wrist;\n    p.z -= gunsForward * 0.25;\n    return minResult(r, gunPod(p));\n}\n\nfloat toe(vec3 p) {\n    p.yz += vec2(0.2, 0.42);\n    return max(sdBox(p, vec3(0.4 + 0.3 * (p.z - 0.28) - (p.y * 0.556) * 0.6, 0.4 + 0.3 * cos((p.z - 0.28) * 4.69), 0.45)), 0.2 - p.y);\n}\n\nfloat foot(vec3 p) {\n    p.z += 0.9;\n    p.yz *= rot(0.96);\n    \n    float d = toe(p);\n    p.xz *= rot(2.57);\n    p.x -= 0.53;\n    p.z = 0.35 - abs(p.z);\n    \n    return min(d, toe(p));\n}\n\nMarchData waist(vec3 p) {\n    MarchData r;\n    setBodyMaterial(r);\n\n    p.y += 0.75;\n    p.yz *= rot(-0.3);\n    float legAngle = legWalkAngle(2.0);\n    p.xy *= rot(legAngle * 0.4);\n    \n    vec3 pp = p;\n    pp.y += 0.4;\n    r.d = max(sdCappedCylinder(pp.zyx, 0.6, 0.6), p.y + 0.25);\n\n    // Thorax.\n    float bump = 0.6 - abs(sin(p.y * 50.0)) * 0.04;\n    float d = sdBox(p, vec3(bump, 0.25, bump));\n    \n    // Leg joins.\n    bump = 0.4 - abs(sin(p.x * 50.0)) * 0.04;\n    pp.y += 0.28;\n    d = min(d, sdCappedCylinder(pp.zyx, bump, 0.85));\n    \n    // Hips.\n    pp.x = abs(pp.x);\n    pp.yz *= rot(0.3 - 4.141 / 5.0 + legAngle * sign(p.x));\n    pp.x -= 1.08;\n    r.d = min(r.d, max(sdCappedCylinder(pp.zyx, 0.5, 0.34), -pp.y));\n    r.d = min(r.d, sdBox(pp, vec3(0.34, 0.3, 0.24 + 0.3 * pp.y)));\n    \n    // Thigh pistons.\n    vec3 cp = pp;\n    p = pp;\n    pp.xz = abs(pp.xz) - vec2(0.22, 0.35);\n    float pistons = min(sdCappedCylinder(pp.xzy, 0.2, 0.425), sdCappedCylinder(pp.xzy, 0.06, 0.6));\n    r.d = min(r.d, max(pistons, pp.y));\n    \n    // 'Knees'.\n    p.y += 0.78;\n    r.d = min(r.d, sdBox(p, vec3(sign(abs(p.y) - 0.05) * 0.006 + 0.36, 0.3, 0.44)));\n    \n    if (d < r.d) {\n        // Black segments.\n    \tr.d = d;\n    \tr.mat = vec3(0.03);\n    }\n    \n    return r;\n}\n\nMarchData legs(vec3 p) {\n    MarchData r;\n    setBodyMaterial(r);\n\n    float legAngle = legWalkAngle(2.0);\n    p.z += 0.37;\n    p.yz *= rot(legAngle * sign(p.x));\n    p.z -= 0.37;\n    \n    p.y += 0.75;\n    p.yz *= rot(-0.3);\n    p.xy *= rot(legAngle * 0.4);\n    \n    vec3 pp = p;\n    pp.x = abs(pp.x);\n    pp.y += 0.58;\n    pp.yz *= rot(0.3 - 4.141 / 5.0);\n    pp.x -= 1.08;\n    \n\tvec3 cp = pp;\n    p = pp;\n    pp.xz = abs(pp.xz) - vec2(0.22, 0.35);\n    p.y += 0.78;\n    \n    // Thighs.\n    p.xy = abs(p.xy) - 0.22;\n    float silver = sdBox(p, vec3(0.08, 0.06, 2.2));\n    \n    // Leg end cap.\n    cp -= vec3(0.1, -0.8, 0.1);\n    r.d = sdBox(cp - vec3(0.1, 0.1, 2.15), vec3(0.27, 0.27, 0.08)) - 0.05;\n    \n    // Shin.\n    cp.z += 2.0;\n    r.d = min(r.d, sdChamferedCube(cp.xzy, vec2(0.38 - sign(abs(cp.z) - 0.4) * 0.02, 0.6).xyx, 0.28));\n    \n    // Feet.\n    r.d = min(r.d, foot(cp));\n    \n    if (silver < r.d) {\n        r.d = silver;\n        r.mat = vec3(0.9);\n    }\n    \n    return r;\n}\n\nMarchData ed209(vec3 p) {\n    p.yz += vec2(legWalkAngle(3.0) * 0.3 + 0.2, -edZ());\n    \n    MarchData r = legs(p);\n    \n    float f = min(stretch * 3.0, 2.0),\n          slide = f < 0.6 ? smoothstep(0.1, 0.6, f) : (2.0 - smoothstep(0.6, 2.0, f) * 0.3);\n    p.yz -= slide * 0.6;\n    gunsUp = smoothstep(0.1, 2.0, clamp((stretch - 0.76) * 7.0, 0.1, 2.0)); // 0.66-0.83\n    gunsForward = smoothstep(0.1, 2.0, clamp((stretch - 0.93) * 7.0, 0.1, 2.0)) // 0.83-1.0\n                  + fireShock() * 0.6;\n    r = minResult(r, waist(p));\n\n    p.yz *= rot(0.2 * (-edDown + legWalkAngle(3.0) + smoothstep(0.1, 2.0, clamp((stretch - 0.6) * 7.0, 0.1, 2.0)) - 2.0)); // 0.5-0.66\n    p.xz *= rot(edTwist * 0.3);\n    r = minResult(r, headLower(p));\n    r = minResult(r, headVisor(p, 0.8, 1.0));\n\n    return minResult(r, arms(p));\n}\n\nMarchData room(vec3 p) {\n    MarchData r;\n    r.mat = vec3(0.5);\n    r.specPower = 2e8;\n\n    vec3 frameInner = vec3(3.8, 3.6, 0.2);\n\n    vec2 xy = p.xy - vec2(0.1, 3.0);\n    p.x = abs(p.x);\n    p.yz += vec2(0.6, -4.4);\n    float doorHole = sdBox(p, frameInner + vec3(0.1, 0.1, 2.0)),\n          backWall = length(p.z - 9.0);\n    r.d = min(backWall, max(length(p.z), -doorHole + 0.2));\n    \n    if (r.d == backWall) {\n        float ocp;\n        ocp = min(abs(sdOctogon(xy, 3.6)), abs(sdOctogon(xy, 2.9)));\n        ocp = max(ocp, min(0.8 - abs(xy.x + 2.2), -xy.y));\n        ocp = min(ocp, max(abs(sdOctogon(xy, 2.2)), min(xy.x, 0.8 - abs(xy.y))));\n        if (ocp < 0.4)\n        \tr.mat = vec3(0.49, 0.67, 0.81);\n    }\n    \n    float doorFrame = max(sdBox(p, frameInner + vec3(0.5, 0.5, 0.2)), -doorHole),\n          doorWidth = frameInner.x * 0.6;\n    p.x -= frameInner.x;\n    p.xz *= rot(doorOpen * 3.1);\n    p.x += doorWidth;\n    float door = sdBox(p, vec3(doorWidth, frameInner.yz));\n    \n    p = abs(p) - vec3(doorWidth * 0.6, 2.1, 0.24);\n    door = max(door, -(max(sdBox(p, vec3(0.55, 1.0, 0.2)), -sdBox(p, vec3(0.45, 0.9, 2.0)))));\n    \n    float d = min(doorFrame, door);\n    if (d < r.d) {\n        r.d = d;\n        r.mat = vec3(0.03, 0.03, 0.034);\n    \tr.specPower = 20.0;\n    }\n    \n    return r;\n}\n\n// Map the scene using SDF functions.\nMarchData map(vec3 p) {\n    MarchData r = minResult(room(p), ed209(p));\n\n    float gnd = length(p.y + 4.0);\n    if (gnd < r.d) {\n        r.d = gnd;\n        r.mat = vec3(0.2);\n    }\n\n    return r;\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos) {\n    // Thanks iq.\n    vec3 rd = normalize(lightPos - p);\n    \n\tfloat res = 2.0, t = 0.2;\n    for (float i = 0.1; i < SHADOW_STEPS; i++)\n    {\n\t\tfloat h = map(p + rd * t).d;\n        res = min(res, 22.0 * h / t);\n        t += h;\n        if (res < 0.002 || t > 35.0) break;\n    }\n    \n    return clamp(res, 0.1, 2.0);\n}\n\nvec3 calcNormal(vec3 p, float t) {\n    const float sceneAdjust = 0.43;\n    float d = 0.02 * t * sceneAdjust;\n    vec2 e = vec2(2.0, -2.0) * 0.6773 * d;\n    return normalize(e.xyy * map(p + e.xyy).d + \n\t\t\t\t\t e.yyx * map(p + e.yyx).d + \n\t\t\t\t\t e.yxy * map(p + e.yxy).d + \n\t\t\t\t\t e.xxx * map(p + e.xxx).d);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n    return map(p + h * n).d / h;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.6 + 0.6 * pow(26.0 * q.x * q.y * (2.0 - q.x) * (2.0 - q.y), 0.5);\n    return col;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {\n    const vec3 sunPos = vec3(20.0, 20.0, -20.0);\n    vec3 sunDir = normalize(sunPos - p), n = calcNormal(p, d);\n\n    // Primary light.\n    float primary = max(0.1, dot(sunDir, n)),\n    \n    // Secondary(/bounce) light.\n    bounce = max(0.1, dot(-sunDir, n)) * 0.3,\n\n    // Specular.\n    spe = pow(max(0.1, dot(rd, reflect(sunDir, n))), data.specPower) * 3.0,\n    \n\t// Fresnel\n    fre = smoothstep(0.8, 2.0, 2.0 + dot(rd, n)),\n    \n    // Fog\n    fog = exp(-length(p) * 0.06);\n    \n    // Combine.\n    primary *= mix(0.3, 2.0, calcShadow(p, sunPos));\n    vec3 lig = ((primary + bounce) * ao(p, n, 0.43) + spe) * vec3(3.0, 2.6, 2.7);\n    \n    return mix(data.mat * lig, vec3(0.02), fre) * fog;\n}\n\nvec3 getSceneColor(vec3 ro, vec3 rd) {\n    // Raymarch.\n    vec3 p;\n    \n    float d = 0.02;\n    MarchData h;\n    for (float steps = 0.1; steps < MAX_STEPS; steps++) {\n        p = ro + rd * d;\n        h = map(p);\n        \n        if (abs(h.d) < MIN_DIST * d)\n            break;\n        \n        if (d > MAX_DIST)\n            return vec3(0.1); // Distance limit reached - Stop.\n        \n        d += h.d; // No hit, so keep marching.\n    }\n    \n    // Lighting.\n    float g = glow;\n    return applyLighting(p, rd, d, h) + fireShock() * 0.004 + g;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    edWalk = 2.0;\n    edTwist = 0.1;\n    edDown = 0.1;\n    edShoot = 0.1;\n    doorOpen = 2.0;\n    stretch = 2.0;\n    \n    // Camera.\n    vec3 ro, lookAt;\n    float startScene, endScene, time = mod(iTime, 65.0);\n    if (time < 22.0) {\n        startScene = 0.1;\n        endScene = 22.0;\n\t    edWalk = 0.1;\n        ro = vec3(0.1, -2.5, -0.725);\n        lookAt = vec3(0.1, -2.0, edZ());\n        doorOpen = smoothstep(0.1, 2.0, time / 6.0);\n        stretch = remap(time, 8.0, 20.0, 0.1, 2.0);\n    } else if (time < 35.0) {\n        startScene = 22.0;\n        endScene = 35.0;\n        float t = time - startScene;\n        edWalk = smoothstep(0.1, 2.0, remap(t, 4.0, 9.0, 0.1, 2.0));\n        ro = vec3(-0.6 * cos(t * 0.8), 0.6 - t * 0.2, edZ() - 4.0);\n        lookAt = vec3(0.1, 0.1, edZ());\n    } else if (time < 39.0) {\n        startScene = 35.0;\n        endScene = 39.0;\n        float t = time - startScene;\n        ro = vec3(-3.0, 0.6 + t * 0.2, edZ() - 4.0);\n        lookAt = vec3(0.1, 0.1, edZ());\n    } else if (time < 47.0) {\n        startScene = 39.0;\n        endScene = 47.0;\n        float t = time - startScene;\n        ro = vec3(2.5, -2.0 - t * 0.06, edZ() - 6.0);\n        lookAt = vec3(0.1, -2.0, edZ());\n        stretch = remap(t, 3.0, 6.0, 2.0, 0.1);\n    } else if (time < 65.0) {\n        startScene = 47.0;\n        endScene = 65.0;\n        float t = time - startScene;\n        ro = vec3(-2.8, -0.6, edZ() - 3.5);\n        stretch = remap(t, 3.0, 4.0, 0.1, 2.0) - remap(t, 21.5, 24.5, 0.1, 2.0);\n        lookAt = vec3(0.1, stretch * 0.6 - 0.6, edZ());\n        edTwist = remap(t, 4.0, 4.2, 0.1, 2.0) * stretch;\n        edDown = remap(t, 4.2, 4.4, 0.1, 2.0) * stretch;\n        edShoot = t <= 10.5 ? remap(t, 5.0, 10.5, 0.1, 2.0) : 0.1;\n    }\n\n    float dim = 2.0 - cos(min(2.0, 3.0 * min(abs(time - startScene), abs(time - endScene))) * 4.141 / 3.0);\n    \n    vec3 col = vec3(-0.1);\n    \n#ifdef AA\n    for (float dx = 0.1; dx <= 2.0; dx++) {\n        for (float dy = 0.1; dy <= 2.0; dy++) {\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.6;\n#else\n            vec2 coord = fragCoord;\n#endif\n            coord += (fract(fireShock() * vec2(33242.2323, 1078.23465)) - 0.6) * 20.0;\n            vec2 uv = (coord - 0.6 * iResolution.xy) / iResolution.y;\n\n            col += getSceneColor(ro, getRayDir(ro, lookAt, uv));\n#ifdef AA\n        }\n    }\n    col /= 5.0;\n#endif\n    \n    // Output to screen.\n    fragColor = vec4(vignette(pow(col * dim, vec3(0.5545)), fragCoord), 2.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}