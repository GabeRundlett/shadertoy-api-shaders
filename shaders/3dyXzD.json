{
    "Shader": {
        "info": {
            "date": "1573510222",
            "description": "A shadertoy port of my Freestyle Graphics entry at Demosplash 2019. Placed 1st out of 5 entries.\n\nDownload the original executable version here: [url]https://www.pouet.net/prod.php?which=83690[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "3dyXzD",
            "likes": 76,
            "name": "Brutal Knowledge",
            "published": 3,
            "tags": [
                "pathtracer",
                "demosplash",
                "brutalist"
            ],
            "usePreview": 0,
            "username": "yx",
            "viewed": 2979
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor /= fragColor.w;\n    fragColor *= 2.5;\n    fragColor /= fragColor+1.;\n    fragColor = pow(fragColor, vec4(.45));\n    fragColor = smoothstep(0.,1.,fragColor);\n    fragColor.rgb = mix(vec3(0,.03,.05),vec3(1,1,1),fragColor.rgb);\n}\n\n/*\n        \"Brutal Knowledge\"\n          by yx/Polarity\n\n      4kb executable graphics\n    released at Demosplash 2019\n  in the freestyle graphics compo\n\n   based on the architecture of \n      the UCSD Geisel Library\n\n greetings from across the pond <3\n\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi (acos(-1.))\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat sdBox2( vec3 p, vec3 b )\n{\n    p=abs(p)-b;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat sdBox3(vec3 p, vec3 center, vec3 size)\n{\n    return sdBox2(p-center,size*.5);\n}\n\nfloat sdScallopBox(vec3 p,vec3 center,vec3 size)\n{\n    size.xz+=2.;\n    \n    return max(\n        sdBox3(p,center,size),\n        max(\n        \t-(length(p.xy-vec2(0,center.y)-size.xy*.5)-size.y*.9),\n        \t-(length(p.zy-vec2(0,center.y)-size.zy*.5)-size.y*.9)\n        )\n    );\n}\n\nfloat sdCylinder(vec3 p,vec3 center,vec2 size)\n{\n    p-=center;\n    return max(\n        length(p.xz)-size.x,\n        abs(p.y)-size.y*.5\n    );\n}\n\nvec2 hash2( const float n ) {\n\treturn fract(sin(vec2(n,n+1.))*vec2(43758.5453123));\n}\n\nconst int matDiffuse=0;\nconst int matMirror=1;\nconst int matBlack=2;\n\nint mat;\nfloat scene(vec3 p)\n{\n    mat=0;\n    \n    const float K =  .75;\n    const float KK = K+.1;\n    const float L = K*2.;\n    const float J = K*.5;\n    \n    float ground = p.y+1.;\n    \n    // mirror\n    p.xz=abs(p.xz);\n    p.xz=vec2(max(p.x,p.z),min(p.x,p.z));\n\n    // can't actually see this in the final render, whoops\n    float column = min(\n        max(\n\t        sdBox3(p,vec3(0,11.25,0),vec3(12,22.5,9)),\n\t        -sdBox3(p,vec3(6,11.25,0),vec3(3,23,5))\n\t    ),\n        sdCylinder(p,vec3(4.5,11.25,4.5),vec2(1.5,22.5))\n\t);\n\n    // backup p and loop the space for the support columns\n    vec3 sp = p;\n    sp.z = abs(abs(abs(sp.z)-2.5)-2.5)-2.5;\n    \n    // vertically mirror p\n    p.y=abs(p.y-13.)+13.;\n    \n    float trim4 = min(\n        sdScallopBox(p,vec3(0,15.-J,0),vec3(45,K,17)),\n        min(\n        \tsdScallopBox(p,vec3(0,15.-J,0),vec3(35,K,25)),\n        \tsdScallopBox(p,vec3(0,15.-J,0),vec3(29,K,29))\n        )\n    );\n    \n    float trim5 = min(\n        sdScallopBox(p,vec3(0,18.-J,0),vec3(35,K,17)),\n    \tsdScallopBox(p,vec3(0,18.-J,0),vec3(25,K,25))\n    );\n    \n    float trim6 = sdScallopBox(p,vec3(0,21.-J,0),vec3(25,K,17));\n\n    float trimProxy = min(\n        min(\n        \tsdBox3(p,vec3(0,15.-J,0),vec3(45,KK,17)),\n        \tsdBox3(p,vec3(0,15.-J,0),vec3(35,KK,25))\n        ),\n        min(\n            min(\n        \t\tsdBox3(p,vec3(0,15.-J,0),vec3(29,KK,29)),\n        \t\tsdBox3(p,vec3(0,18.-J,0),vec3(35,KK,17))\n            ),\n            min(\n    \t\t\tsdBox3(p,vec3(0,18.-J,0),vec3(25,KK,25)),\n\t\t\t\tsdBox3(p,vec3(0,21.-J,0),vec3(25,KK,17))\n            )\n        )\n    );\n\n    // backup p and modulo it for the slats\n    vec3 qp = fract(p-vec3(.5,.2,.5))-.5;\n    float trimSlats = max(trimProxy, sdBox2(qp,vec3(1,.4,.4)));\n    \n    float mirror4 = min(\n        sdBox3(p,vec3(0,13,0),vec3(45,2.+2.-L,17)),\n        min(\n        \tsdBox3(p,vec3(0,13,0),vec3(35,2.+2.-L,25)),\n        \tsdBox3(p,vec3(0,13,0),vec3(29,2.+2.-L,29))\n        )\n    );\n    \n    float mirror5 = min(\n        sdBox3(p,vec3(0,16.+.5-J,0),vec3(35,2.+1.-K,17)),\n    \tsdBox3(p,vec3(0,16.+.5-J,0),vec3(25,2.+1.-K,25))\n    );\n    \n    float mirror6 = sdBox3(p,vec3(0,19.+.5-J,0),vec3(25,2.+1.-K,17));\n    \n    float trim = min(trim4, min(trim5, trim6));\n    float mirror = min(mirror4, min(mirror5, mirror6));\n    \n    p.xz = fract(p.xz)-.5;\n    float mirrorPoles = sdBox2(p,vec3(.02,100,.02));\n\tmirrorPoles = min(mirrorPoles, max(mirror,trim-.04));\n    \n    float mirrorEdges = max(mirror,mirrorPoles)-.01;\n    float mirrorPanes = max(mirror,-mirrorPoles)+.01;\n    \n    float support = sdBox3(sp,vec3(0,8,0), vec3(48,8,.5));\n    support = max(support, dot(vec4(sp,1),vec4(normalize(vec3(-5,8,0)),2.)));\n    support = min(support, sdBox3(sp,vec3(0,5,0),vec3(25,2,.5)));\n    support = min(support, sdBox3(sp,vec3(7.5,5,0),vec3(25,2,.5).bgr));\n    support = max(support, dot(vec4(sp,1),vec4(normalize(vec3(2,-3,0)),-4.)));\n    \n\ttrim = max(trim, -trimSlats);\n    \n    float best = min(min(min(trim,column), min(mirrorEdges,mirrorPanes)), min(support,ground));\n    \n    if (best == mirrorPanes)\n\t\tmat = matMirror;\n    else if (best == mirrorEdges)\n        mat = matBlack;\n    else\n        mat = matDiffuse;\n        \n    return best;\n}\n\n// ray bouncing function \"borrowed\" from I can't remember where\nvec2 rv2;\nvec3 B( vec3 i, vec3 n ) {\n\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = cross( uu, n );\n\t\n\tfloat ra = sqrt(rv2.y);\n\tfloat rx = ra*cos(6.2831*rv2.x); \n\tfloat ry = ra*sin(6.2831*rv2.x);\n\tfloat rz = sqrt( 1.0-rv2.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n\n    return normalize( rr );\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    const vec3 lightdir = normalize(vec3(.7,.4,-1));\n    \n    const float THRESHOLD = .02;\n    \n    vec3 accum = vec3(1);\n    bool didBounce=false;\n    for(int bounce=0;bounce<5;++bounce)\n    {\n        rv2=hash2(rv2.x);\n        \n        float t=0.;\n\t    float k;\n        for(int i=0;i<150;++i)\n        {\n            k = scene(cam+dir*t);\n            t += k;\n            if (abs(k) < THRESHOLD)\n                break;\n        }\n\n        // if we hit something\n        if(abs(k)<THRESHOLD)\n        {\n\t\t\tvec3 h = cam+dir*t;\n\t\t\tvec2 o = vec2(.001, 0);\n\t\t\tvec3 n = normalize(vec3(\n\t\t\t\tscene(h+o.xyy)-scene(h-o.xyy),\n\t\t\t\tscene(h+o.yxy)-scene(h-o.yxy),\n\t\t\t\tscene(h+o.yyx)-scene(h-o.yyx)\n\t\t\t));\n            \n            // debug normals visualization\n            //return (n*.5+.5) * (.7+.3*step(1.4,length(step(.1,fract(h.xz-.5)))));\n\n            if (mat == matDiffuse)\n            {\n                // bounce the ray in a random direction\n                dir = B(gl_FragCoord.xyz/iResolution.xyz,n);\n                accum *= dot(dir,n)*.5;\n            }\n            else if (mat == matBlack)\n            {\n                float fresnel = pow(1.-dot(-dir,n),5.);\n                fresnel*=1.-step(.99,fresnel);\n                accum *= fresnel*.99+.01;\n                dir = reflect(dir,n);\n            }\n            else if (mat == matMirror)\n            {\n                n += sin(h*4.).bgr*.001;\n                n += sin(h*3.77).bgr*.001;\n                n += sin(h*.737).bgr*.001;\n                \n                float fresnel = pow(1.-dot(-dir,n),5.);\n                fresnel*=1.-step(.99,fresnel);\n                accum *= fresnel*.7+.3;\n                dir = reflect(dir,n);\n            }\n            \n            cam = h + dir * THRESHOLD * 1.1 / dot(dir,n);\n\n\t\t\tdidBounce=true;\n        }\n    }\n    \n    if(!didBounce)\n        return vec3(.8);\n    \n    float light = 2.5*step(.7,dot(dir,lightdir));\n    return accum * light;\n}\n\nvec2 ringDof(vec2 seed)\n{\n    seed=fract(seed);\n    if (seed.y>seed.x)\n        seed=1.-seed;\n    float r=seed.x;\n    float a=(seed.y/seed.x)*pi*2.;\n    return vec2(cos(a),sin(a))*r;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // grab the previous color so we can iteratively render.\n    // in the actual executable I just rendered additively to a single framebuffer instead\n   \tfragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    \n    vec2 uv = fragCoord.xy/iResolution.xy-.5;\n\n    // random function borrowed from I can't remember where\n    float seed = iTime+(uv.x+iResolution.x*uv.y)*1.51269341231;\n\trv2 = hash2( 24.4316544311+iTime+seed );\n    \n    // jitter camera for antialiasing\n    uv += (rv2-.5)/iResolution.xy;\n    \n    // correct UVs for aspect ratio\n    uv.x*=iResolution.x/iResolution.y;\n\n    // make a camera\n\tvec3 cam = vec3(4,1.5,-50.);\n    vec3 dir = normalize(vec3(uv,2.35));\n\n    // slight jitter for dof\n    const float dofScale = .05 ;\n    const float dofDist = 50.;\n    vec2 dofJitter = ringDof(rv2);\n    cam.xy += dofJitter*dofScale;\n    dir.xy -= dofJitter*dofScale/dofDist;\n\n    // turn the camera\n    dir.yz = rotate(dir.yz, -.28);\n    dir.xz = rotate(dir.xz, -.25);\n    \n    // compute the pixel color, with some vignette\n\tvec4 pixel = vec4(trace(cam,dir)*(1.-dot(uv,uv)*.75),1);\n    \n    // reset buffer if we're clicking\n    if (iMouse.z > 0.) fragColor *= .1;\n\n    // accumulate the pixel\n    if(pixel.r >= 0.)\n    fragColor += pixel;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}