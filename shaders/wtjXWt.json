{
    "Shader": {
        "info": {
            "date": "1567530103",
            "description": "This is a port of my 10kb Linux submission to the Xenium 2019 demoparty (https://xenium.rocks). This is my first PC demo made in a few days before the party, so don't expect any breakthroughs :)\n\nAlso on pouÃ«t: https://www.pouet.net/prod.php?which=82781",
            "flags": 8,
            "hasliked": 0,
            "id": "wtjXWt",
            "likes": 17,
            "name": "ONE (10kb Linux demo port)",
            "published": 3,
            "tags": [
                "3d",
                "sound",
                "music",
                "demoscene",
                "demo",
                "square",
                "ambientocclusion",
                "aesthetic",
                "spheremarching",
                "pastel"
            ],
            "usePreview": 1,
            "username": "szczm_",
            "viewed": 1028
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_SHADOW_STEPS 100\n#define MAX_REFLECTION_STEPS 40\n#define MIN_DIST 0.0\n#define MAX_DIST 40.0\n#define EPSILON 1e-2\n#define SHADOW_EPSILON 1e-4\n#define NORMAL_EPSILON 5e-4\n#define REFLECTION_DEPTH 2\n\n#define MAT_NONE -1\n\n#define MAT_SPHERE 0\n#define MAT_PILLAR 1\n#define MAT_FLOOR 2\n#define MAT_WALLS 3\n#define MAT_FLOOR2 4\n#define MAT_SPHERE2 5\n#define MAT_BUILDING 6\n#define MAT_BUILDING2 7\n#define MAT_FERRO 8\n#define MAT_FLOOR3 9\n#define MAT_PIPE 10\n#define MAT_METAL 11\n\n#define MAX_MAT MAT_METAL+1\n\nconst vec3 albedo[MAX_MAT] = vec3[MAX_MAT](\n\tvec3(0.9),             // MAT_SPHERE\n\tvec3(0.9),             // MAT_PILLAR\n\tvec3(0.08),            // MAT_FLOOR\n\tvec3(1.02, 0.2, 0.13), // MAT_WALLS\n\tvec3(0.9),             // MAT_FLOOR2\n\tvec3(1.0, 0.6, 0.15),  // MAT_SPHERE2\n\tvec3(0.2, 0.2, 0.4),   // MAT_BUILDING\n\tvec3(0.1),             // MAT_BUILDING2\n\tvec3(0.9),             // MAT_FERRO\n\tvec3(0.18, 0.33, 0.9), // MAT_FLOOR3\n\tvec3(1.0, 0.15, 0.1),  // MAT_PIPE\n\tvec3(1.0)              // MAT_METAL\n);\n\nconst float metallic[MAX_MAT] = float[MAX_MAT](\n\t0.3,  // MAT_SPHERE\n\t0.2,  // MAT_PILLAR\n\t0.0,  // MAT_FLOOR\n\t0.4,  // MAT_WALLS\n    0.0,  // MAT_FLOOR2\n\t0.0,  // MAT_SPHERE2\n\t0.95, // MAT_BUILDING\n\t0.0,  // MAT_BUILDING2\n\t0.0,  // MAT_FERRO\n\t0.0,  // MAT_FLOOR3\n\t0.0,  // MAT_PIPE\n\t0.95  // MAT_METAL\n);\n\nstruct DistMat {\n    float dist;\n    int mat;\n};\n\nstruct HitInfo {\n    float dist;\n    int steps;\n    int mat;\n};\n\nstruct Light {\n\tvec3 pos;\n\tvec3 col;\n\tfloat size;\n\tfloat inten;\n\tfloat amb;\n};\n\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414 + iTime))) * 43758.5453);\n}\n\nconst Light lights[14] = Light[14](\n\t// 0\n\tLight(vec3(-1.0, -1.0, 1.0), vec3(1.0, 0.8, 0.7), 0.1, 5.0, 0.02),\n\tLight(vec3(-1.0, -1.0, -1.0), vec3(0.7, 1.0, 0.8), 0.1, 5.0, 0.02),\n\tLight(vec3(1.0, -1.0, 0.0), vec3(0.8, 0.7, 0.9), 0.1, 5.0, 0.02),\n\n\t// 1\n    Light(vec3(0.0, -2.0, 2.0), vec3(0.5, 0.6, 1.0), 0.16, 8.0, 0.12),\n    Light(vec3(2.0, -3.0, 0.0), vec3(0.9, 0.7, 0.8), 0.12, 9.0, 0.09),\n    Light(vec3(-2.0, -4.0, -2.0), vec3(0.8, 1.0, 0.4), 0.08, 8.0, 0.09),\n\n\t// 2\n\tLight(vec3(4.0, -2.0, 3.0), vec3(1.0, 0.4, 1.0), 0.16, 20.0, 0.03),\n\tLight(vec3(4.0, -2.0, -3.0), vec3(0.4, 1.0, 1.0), 0.12, 20.0, 0.04),\n\tLight(vec3(-4.0, -2.0, 0.0), vec3(1.0, 1.0, 1.0), 0.12, 5.0, 0.00),\n\n\t// 3\n\tLight(vec3(4.0, -2.0, 3.0), vec3(1.0, 0.9, 0.4), 0.16, 20.0, 0.03),\n\tLight(vec3(4.0, -2.0, -3.0), vec3(0.4, 0.8, 1.0), 0.12, 20.0, 0.03),\n\n\t// 4\n    Light(vec3(-1.0, -1.0, 1.0), vec3(1.0, 0.8, 0.7), 0.1, 5.0, 0.02),\n    Light(vec3(-1.0, -1.0, -1.0), vec3(0.7, 1.0, 0.8), 0.1, 5.0, 0.02),\n    Light(vec3(1.0, -1.0, 0.0), vec3(0.8, 0.7, 1.0), 0.1, 5.0, 0.02)\n);\n\nconst vec3 bgColor[5] = vec3[5](\n\tvec3(0.1), // 3\n\tvec3(1.0, 0.85, 0.5), // 1\n\tvec3(0.1), // 2\n\tvec3(0.95, 0.45, 0.4), // 0\n\tvec3(0.98) // 4\n);\n\n\nint sceneIndex() {\n\tfloat t2 = step(80., iTime);\n\treturn int(floor(mod(iTime/(16. - 15.*t2) + 4., 5. - 1.*t2)));\n}\n\n// https://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat planeSDF(vec3 p, vec3 n) {\n    return -dot(p, n);\n}\n\nfloat boxSDF(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat box2SDF(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n}\n\nfloat torusSDF(vec3 p, float r)\n{\n    return length(p.xz) - r;\n}\n\nfloat ringSDF(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.yz)-t.y,p.x);\n  return length(q)-t.x;\n}\n\nfloat cylinderSDF(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hexprismSDF(vec3 p, vec2 h) {\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat octahedronSDF(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n// iq smoothmin\nfloat smin( float a, float b ) { const float k = 1.0; float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 ); return mix( b, a, h ) - k*h*(1.0-h); }\n\nDistMat sum(DistMat a, DistMat b) {\n    if (a.dist < b.dist)\n        return a;\n    else\n        return b;\n}\n\nDistMat intersect(DistMat a, DistMat b) {\n    if (a.dist > b.dist)\n        return a;\n    else\n        return b;\n}\n\nDistMat sceneSDF(vec3 p)\n{\n    int sceneInd = sceneIndex();\n\n    float time = max(mod(iTime, 16.) - 8.0, 0.);\n    time *= smoothstep(0.0, 1.0, time);\n\n    DistMat scene;\n\n    if (sceneInd == 3) {\n        scene = DistMat(planeSDF(p - vec3(3.2), vec3(0.0, 1.0, 0.0)), MAT_FLOOR);\n\n        p -= vec3(0.0, 2.4, 0.0);\n\n        float t = mod(time, 8.);\n\n        float body1 = hexprismSDF(p.xzy, vec2(1., 1.));\n        float body2 = sphereSDF(p, 1.);\n        float body3 = ringSDF(p.yzx, vec2(.3, .9));\n        float body4 = boxSDF(p, vec3(1.));\n\n        float body = mix(body1, body2, smoothstep(0.0, 1.0, t));\n        body = mix(body, body3, smoothstep(2.0, 3.0, t));\n        body = mix(body, body4, smoothstep(4.0, 5.0, t));\n        body = mix(body, body1, smoothstep(6.0, 7.0, t));\n\n        scene = sum(scene, DistMat(body, MAT_PIPE));\n    }\n\n    if (sceneInd == 1) {\n        scene = DistMat(planeSDF(p - vec3(3.9), vec3(0.0, 1.0, 0.0)), MAT_FLOOR2);\n\n        float dominoes = 10e5;\n\n        for (float i = -1.6; i < 1.9; i += 0.4) {\n            float sz = smoothstep(-0.3, 1.0, sin(time * 2.0 * 3.1415 + i)) * 0.8;\n            dominoes = min(dominoes, box2SDF(p - vec3(i, 2.4, 0.0), vec3(0.1, 0.3 + sz, 0.4)) - 0.02);\n        }\n\n        scene = sum(scene, DistMat(dominoes, MAT_SPHERE2));\n    }\n\n    if (sceneInd == 2) {\n        scene = DistMat(planeSDF(p - vec3(3.9), vec3(0.0, 1.0, 0.0)), MAT_FLOOR2);\n\n        float building = boxSDF(p - vec3(0.0, 2.4, 0.0), vec3(0.8, 1.5, 0.8));\n        building = max(building, planeSDF(p - vec3(0.0, 1.2, 0.0), vec3(sin(0.3), cos(0.3), 0.0)));\n\n        float a = atan(p.z, p.x) + time + sin(time * 2.0 * 3.1415 - 1.57) * .2;\n        float l = length(p.xz);\n        float s = sin(a + time) * .3;\n\n        a = mod(a, 6.28/3.);\n\n        vec3 p = vec3(cos(a) * l - 1.0, p.y * .7 - 1.5 + s, sin(a) * l - 2.0);\n\n        building = min(building, octahedronSDF(p, 0.42) - .03);\n\n        DistMat build = DistMat(building, MAT_BUILDING);\n        scene = sum(scene, build);\n    }\n\n    if (sceneInd == 0) {\n        scene = DistMat(planeSDF(p - vec3(3.9), vec3(0.0, 1.0, 0.0)), MAT_FLOOR2);\n\n        p.y += .5;\n\n        scene = sum(scene, DistMat(boxSDF(p - vec3(0.0, 1.0, 0.0), vec3(2.2, 0.05, 0.1)) - .05, MAT_FLOOR2));\n\n        float spheres = 10e5;\n        float ropes = 10e5;\n\n        for (float i = -2.; i < 3.; i += 1.) {\n\n            vec3 p = p - vec3(i, 1.15, 0.0);\n\n            float t = 0.;\n\n            if (abs(i) == 2.) {\n                t = max(0., sin(time*3.1415*2.) * .5 * sign(i)) * sign(i);\n            }\n\n            float ts = sin(t);\n            float tc = cos(t);\n\n            p = vec3(p.x*tc-p.y*ts, p.x*ts+p.y*tc, p.z);\n\n            spheres = min(spheres, sphereSDF(p - vec3(0.0, 2.4, 0.0), 0.5));\n            ropes = min(ropes, torusSDF(p, 0.015));\n        }\n\n        ropes = max(ropes, boxSDF(p - vec3(0.0, 2.0, 0.0), vec3(3.0, 1.0, 2.0)));\n\n        scene = sum(scene, DistMat(spheres, MAT_METAL));\n        scene = sum(scene, DistMat(ropes, MAT_FLOOR));\n    }\n\n    if (sceneInd == 4) {\n        scene = DistMat(planeSDF(p - vec3(3.2), vec3(0.0, 1.0, 0.0)), MAT_FLOOR3);\n        scene = sum(scene, DistMat(sphereSDF(p - vec3(0.0, 2.5, 0.0), 1.), MAT_FERRO));\n    }\n\n    return scene;\n}\n\nfloat sceneDist(vec3 p) {\n    return sceneSDF(p).dist;\n}\n\nvec3 lightDir(vec3 point, Light light) {\n\tvec3 dir = light.pos - point;\n\n\treturn normalize(mix(normalize(dir), normalize(light.pos), light.size));\n}\n\nfloat lightIntensity(vec3 point, Light light) {\n\tfloat dist = distance(point, light.pos);\n\n\treturn light.inten / mix(dist * dist, 1.0, light.size);\n}\n\nHitInfo shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end, int steps) {\n    float depth = start;\n    int i;\n    int mat;\n    \n    for (i = 0; i < steps; i++) {\n        DistMat dist = sceneSDF(eye + depth * marchingDirection);\n        dist.dist *= 0.7;\n        \n        depth += dist.dist;\n        mat = dist.mat;\n        \n        if (dist.dist < EPSILON) {\n\t    break;\n        }\n        \n        if (depth >= end) {\n            depth = end;\n            mat = MAT_NONE;\n            break;\n        }\n    }\n    \n    return HitInfo(depth, i, mat);\n}      \n\n\nfloat shadow(in vec3 eye, vec3 marchingDirection, vec3 normal, float end) {\n    eye += normal * SHADOW_EPSILON * 2.0;\n    float depth = 0.0;\n\n    float shad = 1.0;\n    float ph = 1e10;\n\n    for (int i = 0; i < MAX_SHADOW_STEPS; i++) {\n        DistMat distMat = sceneSDF(eye + depth * marchingDirection);\n        float dist = distMat.dist;\n\n        if (dist < SHADOW_EPSILON) {\n\t        shad = 0.0;\n\t        break;\n        }\n\n        if (depth > end) {\n            break;\n        }\n\n        float y = dist * dist / (2.0 * ph);\n        float d = sqrt(dist * dist - y*y);\n        shad = min(shad, 4.0 * d / max(0.0, depth - y));\n        ph = dist;\n\n        depth += dist;\n    }\n\n    return clamp(shad, 0.0, 1.0);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 normal(vec3 p, vec3 dir) {\n    vec3 n = vec3(\n        sceneDist(vec3(p.x + NORMAL_EPSILON, p.y, p.z)) - sceneDist(vec3(p.x - NORMAL_EPSILON, p.y, p.z)),\n        sceneDist(vec3(p.x, p.y + NORMAL_EPSILON, p.z)) - sceneDist(vec3(p.x, p.y - NORMAL_EPSILON, p.z)),\n        sceneDist(vec3(p.x, p.y, p.z  + NORMAL_EPSILON)) - sceneDist(vec3(p.x, p.y, p.z - NORMAL_EPSILON))\n    );\n\n    return normalize(n - max(0.0, dot(n, dir)) * dir);\n}\n\nfloat ao(vec3 eye, vec3 norma, float scale) {\n    float depth = scale;\n    float accum = 0.0;\n    for (int i = 0; i < 5; i++) {\n        float dist = sceneDist(eye + depth * norma);\n        accum = max(accum, (depth - dist) / depth);\n        depth += scale;\n    }\n    return clamp(1.0 - accum, 0.0, 1.0);\n}\n\nfloat lambert(vec3 normal, vec3 lightPos) {\n\treturn clamp(dot(normal, lightPos), 0.0, 1.0);\n}\n\nfloat fresnel(vec3 dir, vec3 normal) {\n//\treturn 0.0;\n\treturn pow(1.0 - clamp(dot(dir, -normal), 0.0, 1.0), 4.);\n}\n\nivec2 lightIndices() {\n\tint scene = sceneIndex();\n\tif (scene == 3) return ivec2(0, 3);\n\telse if (scene == 1) return ivec2(3, 6);\n\telse if (scene == 2) return ivec2(6, 8);\n\telse if (scene == 0) return ivec2(9, 11);\n\telse if (scene == 4) return ivec2(11, 14);\n}\n\nvec3 color(vec3 position, vec3 normal, vec3 dir, HitInfo hitInfo) {\n\tvec3 col = vec3(0.0);\n\n\tif (hitInfo.mat == MAT_NONE) {\n\t\treturn vec3(0.);\n\t}\n\t\n\tif (hitInfo.mat > MAT_NONE) {\n\t\tvec3 alb = albedo[hitInfo.mat];\n\n\t\tvec3 diff = vec3(0.0);\n\t\tvec3 sdiff = vec3(0.0);\n\n                ivec2 lightind = lightIndices();\n\n\t\tfor (int i = lightind.x; i < lightind.y; i++)\n\t\t{\n\t\t\tLight light = lights[i];\n\t\t\t\n\t\t\tfloat shad = shadow(position, lightDir(position, light), normal, distance(position, light.pos));\n\t\t\tfloat lamb = lambert(normal, light.pos);\n\t\t\tfloat fres = fresnel(dir, normal);\n\n\t\t\tdiff += ((lightIntensity(position, light) * lamb + fres) * shad + light.amb) * (alb * light.col);\n\t\t}\n\n\t\tfloat a1 = 0.3 * ao(position, normal, 0.001);\n\t\tfloat a2 = 0.3 * ao(position, normal, 0.01);\n\t\tfloat a3 = 0.2 * ao(position, normal, 0.04);\n\t\tfloat a4 = 0.2 * ao(position, normal, 0.2);\n\n\t\tfloat aa = a1 + a2 + a3 + a4;\n\n\t\tcol = diff * aa;\n\t}\n\n\treturn col;\n}\n\nvec3 transformForReflection(vec3 p, vec3 dir, vec3 refl) {\n    float dist = sceneDist(p);\n\n    return p + 2.0 * dist * (dir + refl);\n}\n      \nvec3 transformForRefraction(vec3 p, vec3 dir, vec3 refr) {\n    return p + EPSILON * (dir + refr);\n}\n      \nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nfloat samarLogo(vec2 p) {\n\tp.y += 0.1;\n\n\tfloat outer = smoothstep(0.201, 0.2, abs(p.x) + 1.9 * abs(p.y));\n\tfloat inner = smoothstep(0.12, 0.121, abs(p.x) + 1.9 * abs(p.y));\n\n\tfloat mid = 0.0;\n\n\tfor (float i = -.182; i < .3; i += .182) {\n\t\tmid += (1.0 - step(0.017, abs(p.x + i)));\n\t}\n\n\tp.y -= 0.17;\n\tfloat outer2 = smoothstep(0.211, 0.21, abs(p.x) + 1.9 * abs(p.y));\n\tp.y += 0.04;\n\tfloat inner2 = smoothstep(0.21, 0.211, abs(p.x -0.01) + 1.9 * abs(p.y));\n\n\tp.y += 0.045;\n\tfloat outer3 = smoothstep(0.361, 0.36, abs(p.x) + 1.9 * abs(p.y));\n\n\tfloat clip = (1.0 - step(0.074, abs(p.x + 0.091))) * step(0.05, p.y);\n\n\tfloat dist = (outer * inner + mid * (1. - outer) + outer2 * inner2 * clip) * outer3;\n\n\treturn clamp(dist, 0.0, 1.0);\n}\n\nfloat oneLogo(vec2 p) {\n\tp.x += 0.07;\n\n\tfloat o = smoothstep(0.1, 0.101, length(p));\n\to *= smoothstep(0.151, 0.15, length(p));\n\n\tp.x -= 0.33;\n\n\tfloat n = 1. - step(0.025, abs(p.x - 0.13));\n\tn += 1. - step(0.025, abs(p.x + 0.13));\n        n += 1. - smoothstep(0.037, 0.038, abs(p.y - p.x * 1.2));\n\tn *= step(-0.15, -abs(p.x));\n\n\tp.x -= 0.33;\n\n\tfloat e = 1. - step(0.025, abs(p.x + 0.13));\n\te += 1. - step(0.025, abs(p.y + 0.13));\n\te += 1. - step(0.025, abs(p.y + 0.));\n\te += 1. - step(0.025, abs(p.y - 0.13));\n\te *= step(-0.15, -abs(p.x));\n\n\treturn clamp(o + n + e, 0.0, 1.0) * step(-0.15, -abs(p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord.y = iResolution.y - fragCoord.y;\n\n    vec3 viewDir = rayDirection(90.0, iResolution.xy, fragCoord);\n\n    float fade = smoothstep(4.0, 6.0, iTime);\n\n    float st = sin(iTime * .5);\n    float ct = cos(iTime * .5);\n\n    float start = 1.0 - step(16., iTime);\n\n    float move = sin(smoothstep(8.0, 11.0, iTime) * 1.57) * 3.3 * start;\n    float onet = sin(smoothstep(10.0, 12.0, iTime) * 1.57) * start;\n\n    vec3 eye = vec3(5.0, -1.5, -move);\n    eye = vec3(eye.x*st-eye.z*ct, eye.y, eye.x*ct+eye.z*st);\n\n    vec2 coord = fragCoord / iResolution.xy;\n    vec2 screen = (coord - .5) * vec2(iResolution.x/iResolution.y, 1.0);\n\n    vec3 bgc = bgColor[sceneIndex()];\n\n    vec3 movevec = vec3(move * sin(iTime * .5 + 1.57), 0., move * cos(iTime * .5 + 1.57));\n\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 2.6, 0.0) + movevec, vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    HitInfo hitInfo = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST, MAX_STEPS);\n    float dist = hitInfo.dist;\n    int steps = hitInfo.steps;\n \n    vec3 pp = eye + dist * worldDir;\n    \n    vec3 n = normal(pp, worldDir);\n\n    vec3 col = vec3(0.0);\n\n    col = mix(col, vec3(1.0), smoothstep(1.0, 3.0, iTime));\n\n    col = mix(col, color(pp, n, worldDir, hitInfo), fade);\n\n    float met = metallic[hitInfo.mat];\n\n    for (int i = 0; i < REFLECTION_DEPTH; i++) {\n\n        if (met == 0.0) break;\n\n        worldDir = reflect(worldDir, n);\n\t    pp = transformForReflection(pp, n, worldDir);\n        hitInfo = shortestDistanceToSurface(pp, worldDir, EPSILON * 5.0, MAX_DIST / 5., MAX_REFLECTION_STEPS);\n\n\t    pp += hitInfo.dist * worldDir;\n\t    n = normal(pp, worldDir);\n\t    col *= mix(vec3(1.0), color(pp, n, worldDir, hitInfo), met);\n\n\t    met *= (hitInfo.mat != MAT_NONE ? metallic[hitInfo.mat] : 0.0);\n    }\n\n    col = pow(col, vec3(1./2.2));\n    col = clamp(col, vec3(0.0), vec3(1.0));\n\n    col = mix(col, bgc, oneLogo(screen) * onet);\n\n    float finish = step(96., iTime);\n    float v = 1. - max(bgc.r, max(bgc.g, bgc.b));\n    vec3 hsvcol = hsv2rgb(vec3(iTime, 0.3, 0.95));\n    vec3 logc = mix(bgc, hsvcol, finish);\n    vec3 colc = mix(vec3(v), vec3(0.02), finish);\n    bgc = mix(bgc, vec3(0.02), finish);\n\n    col = mix(col, colc, step(80., iTime) * .5 + finish * .5);\n    col = mix(col, logc, samarLogo(screen * .7) * step(80., iTime));\n\n    col = mix(col, bgc, step(0.4, abs(coord.y - 0.5)) * fade);\n\n    col = mix(col, vec3(clamp(rand(coord), 0.0, 1.0)), 0.05 * pow(1.0 - max(col.r, max(col.g, col.b)), 2.5));\n\n    col = mix(col, vec3(0.0), step(100., iTime));\n\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define TAU 6.2831853071\n\nfloat modfix(float phase) {\n    return mod(phase, TAU);\n}\n\nfloat sinf(float t, float freq) {\n\treturn sin(modfix(TAU * t * freq));\n}\n\nfloat sawf(float t, float freq) {\n    return 2. * fract(t * freq) - 1.;\n}\n\nfloat squaref(float t, float freq) {\n    return 2. * step(0., sawf(t, freq)) - 1.;\n}\n\nfloat noise(float t) {\n    return fract(sinf(t, 25214.25012) * 82195.29521);\n}\n\nfloat kick(float t) {\n    return clamp(2.5 * sinf(t, 85. * exp(-t * 5.0)) * exp(-t * 5.), -1.0, 1.0) * smoothstep(0.001, 0.003, t);\n}\n\nfloat snare(float t) {\n    return mix(sinf(t,48.), noise(t), 0.9) * exp(-t * 5.);\n}\n\nfloat hat(float t) {\n    return noise(t) * step(-0.19, -t) * smoothstep(0.0, 0.1, t);\n}\n\nfloat tick(float t) {\n    return sinf(t, 200.) * smoothstep(0.07, 0.065, abs(t - 0.1));\n}\n\nconst float[4] startNotes = float[4]( 70., 80., 90., 100. );\n\nfloat pitch(float p) {\n\treturn pow(1.059460646483, p) * 440.0;\n}\n\nconst float introChord[4] = float[4](0., 4., 7., 11.);\n\nfloat intro(float t) {\n    float s=0.;\n    \n    for (float oct = -2.; oct < 1.; oct += 1.) {\n    \tfor (int i = 0; i < 4; i++) {\n            float note = pitch(oct * 12. + introChord[i] - 9.);\n\t        s += mix(sinf(t, note), sawf(t, note * 2.), .2);\n\t    }\n    }\n        \n    return s * 1./(5.*4.);\n}\n\nconst float bassChord1[4] = float[4](0., 0., 3., 5.);\nconst float bassChord2[4] = float[4](0., 0., 3., -2.);\n\nfloat bass(float t) {\n    float s = 0.0;\n\n    float base = -30.;\n    float note1 = bassChord1[int(mod(t, 4.))];\n    float note2 = bassChord2[int(mod(t, 4.))];\n    \n  \tfloat note = mix(note1, note2, 1. - step(48., t));\n    \n    float anticlick = smoothstep(0.49, 0.48, abs(mod(t, 1.) - .5));\n    int topOct = t > 48. ? 2 : 1;\n    \n    for (int i = -1; i <= topOct; i++) {\n        float pit = pitch(base + float(i) * 12. + note);\n    \ts += squaref(t, pit);\n    }\n    \n    return s / float(2 + topOct);\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float beat = mod(time * 2., 1.);\n    \n    float tKick = beat;\n    float tSnare = mod(time * 2. - 1., 2.);\n    float tHat = mod(time * 4. + 1., 1.);\n    float tTick = mod(time, 1.);\n    \n    int nStart = int(mod(floor(time*4.), 4.));\n    \n    float vTick = step(14., time) * step(-16., -time) * 0.6;\n    float vKick = step(16., time) * .43 * (1.0 - 0.13 * step(.5, mod(time, 1.)));\n    float vSnare = step(32., time) * (.13 + .11 * step(79., time));\n    float vHat = step(48., time) * .03;\n    float vBass = 1.4 * step(16., time) * (.2 - .07*cos(modfix(time * 3. * TAU + .4))) * mix(.2  * sinf(time, 3.), .23, smoothstep(96., 96.2, time));\n    \n    float dBass = 1. - exp(-mod(time * 3., 1.) * 4.);\n    \n    float vIntro = pow(smoothstep(9., 10.3, time) * smoothstep(13., 11., time), 2.) * 0.6;\n    \n    float perc;\n    \n    perc = kick(tKick) * vKick;\n    perc += tick(tTick) * vTick;\n    \n    float snaare = snare(tSnare) * vSnare;\n    float hat = hat(tHat) * vHat;\n\n    float basss;\n    basss = bass(time) * vBass;\n    \n    float melody;\n    melody = intro(time) * vIntro;\n    \n    float percBreak = 1. - step(7.5, mod(time, 8.));\n  \n    \n    float sound = perc * step(-79., -time)\n        \t\t+ snaare * step(-95., -time) * percBreak\n        \t\t+ hat * step(-88., -time) * percBreak\n        \t\t+ melody\n        \t\t+ basss\n        \t\t+ noise(time) * 0.001 * (1.0 - step(16., time));\n\n    return vec2(sound * (1.0 - step(100.0, time)) + .7*kick(.4*max(time - 100., 0.)));\n}\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}