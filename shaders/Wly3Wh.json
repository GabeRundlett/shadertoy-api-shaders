{
    "Shader": {
        "info": {
            "date": "1586757408",
            "description": "I really really really wanted to replicate the TRSi Megademo colored bouncing scroller some day :D\n\nRe-play audio and re-wind the shader.\n\nhttps://youtu.be/oTmpqBn4dfA?t=1204",
            "flags": 64,
            "hasliked": 0,
            "id": "Wly3Wh",
            "likes": 3,
            "name": "TRSi Megademo bouncing scroller",
            "published": 3,
            "tags": [
                "amiga",
                "megademo",
                "trsi",
                "redsector",
                "tristar"
            ],
            "usePreview": 0,
            "username": "toomuchvoltage",
            "viewed": 469
        },
        "renderpass": [
            {
                "code": "/***********************************************************\n\n   I really really really wanted to replicate the TRSi Megademo colored bouncing scroller :D\n   See the demo here: https://youtu.be/oTmpqBn4dfA?t=1204\n   2D Simplex by iq: https://www.shadertoy.com/view/Msf3WH\n   3D Simplex by nikat: https://www.shadertoy.com/view/XsX3zB\n\n   Everything else covered under the MIT license:\n\n   Copyright (c) 2020 Baktash Abdollah-shamshir-saz.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n#define M_PI 3.1415926535\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nvec2 toSpherical(vec3 inpVec)\n{\n\tvec2 inpVecOnXZ = ((inpVec.xz == vec2 (0.0)) ? vec2 (0.0) : normalize (inpVec.xz));\n\tfloat phi = acos(clamp (inpVecOnXZ.x, -1.0, 1.0));\n\tif (inpVecOnXZ.y < 0.0) phi = (2.0 * M_PI) - phi;\n\tfloat theta = acos(clamp (inpVec.y, -1.0, 1.0));\n\treturn vec2(phi / (2.0*M_PI), theta / M_PI);\n}\n\nconst uint textArr0[34] = uint[](3503345872u,2511917264u,2558840969u,3734340245u,3000032990u,2441386897u,2563807363u,3516236437u,2194717136u,2627506581u,2508378249u,2308742289u,2442494672u,3498679452u,2224984455u,2228262037u,2508378271u,2510000541u,2576909520u,2676215939u,2496697757u,3504245137u,2241319097u,3498279829u,2224134276u,2308019408u,3498285520u,2442436484u,3100696201u,3499458719u,3498418057u,2510002588u,3498351056u,3504265674u);\n\n#define _1_OVER_16 0.0625\n\nfloat worldDensity (vec3 inpCoord, vec3 scale, out float azimuth)\n{\n    if ( iChannelTime[0] > 38.0 )\n    {\n        float fieldForce = pow ((dot (normalize (inpCoord), vec3 (sign(sin(iTime * 5.0)), 0.0, 0.0)) + 1.0) * 0.5, 1.0);\n        float fieldForceRemap = (clamp (fieldForce, 0.5, 1.0) - 0.5) * 2.0;\n        inpCoord = normalize (inpCoord) * (length(inpCoord) + fieldForceRemap * 0.7 * abs(sin(iTime * 5.0))); // Apply force to field\n    \n\t    inpCoord.x -= sin(iTime * 5.0);\n    }\n\n    float icLen = length (inpCoord);\n    if ( icLen < 1.0 || icLen > 2.0 ) return 0.0;\n    vec3 icNorm = inpCoord / icLen;\n    vec2 icNormSph = toSpherical (icNorm);\n    azimuth = icNormSph.x;\n    vec3 sphCoord = vec3 (icNormSph, icLen) * scale;\n    float timeTnt;\n    if ( iChannelTime[0] > 7.75 ) sphCoord.y += sin(iChannelTime[0] + sphCoord.x * 3.0) * 0.5;\n    if ( iChannelTime[0] > 23.0 ) sphCoord.y += sin(iChannelTime[0] + sphCoord.x * 15.0) * 0.1;\n    vec3 intPart;\n    vec3 localCoord = modf (sphCoord, intPart);\n    if ( intPart.y != 5.0 ) return 0.0;\n   \n\n    float textOffset = sphCoord.x + iTime;\n    float textOffsetIntPart;\n    float textOffsetFractPart = modf (textOffset, textOffsetIntPart);\n    int charIndex = int(textOffsetIntPart);\n    int arrIndex = (charIndex / 4) % 34;\n    uint wordFetch = textArr0[arrIndex];\n    uint charFetch = (wordFetch >> ((charIndex % 4) * 8)) & 0x000000FFu;\n    float charX = float (int (charFetch & 0x0000000Fu)     );\n    float charY = float (int (charFetch & 0x000000F0u) >> 4);\n    vec2 charCoords = vec2(charX, charY);\n    \n    vec2 charUVBase = vec2 (_1_OVER_16, _1_OVER_16) * charCoords;\n\tcharUVBase.y = 1.0 + charUVBase.y;\n    return texture (iChannel1, charUVBase + vec2 (textOffsetFractPart, localCoord.z) * vec2(_1_OVER_16, _1_OVER_16)).x;\n}\n\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat worldOpaque (vec3 inpCoord, out float azimuth)\n{\n\treturn worldDensity (inpCoord, vec3 (10.0, 10.0, 1.0), azimuth) > 0.5 ? 1.0 : 0.0;\n}\n\nvec2 rotate(vec2 v, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    vec3 curEye = vec3 (0.0, 3.0, -3.0);\n    float timeInt;\n    vec3 curLook = normalize (-curEye);\n    vec3 curSide = normalize (cross (curLook, vec3 (0.0, 1.0, 0.0)));\n    vec3 curUp = cross (curSide, curLook);\n    \n    vec3 sampleDirNorm = normalize (curLook + curUp * uv.y + curSide * uv.x);\n    vec3 sampleDir = sampleDirNorm * 0.01;\n    vec3 samplePt = curEye + sampleDir;\n\n    for (int i = 0; i != 650; i++)\n    {\n        float hitAzimuth;\n        if ( worldOpaque (samplePt, hitAzimuth) == 1.0 )\n        {\n            vec3 azimuthColor;\n            azimuthColor.x = abs (noise(vec2 (iTime * 0.25)));\n            azimuthColor.y = abs (noise(vec2 (iTime * 0.25 + 100.0)));\n            azimuthColor.z = abs (noise(vec2 (iTime * 0.25 + 200.0)));\n            azimuthColor = azimuthColor * 3.0;\n            fragColor.rgb = clamp (samplePt.y + 1.0, 0.0, 1.0) * azimuthColor;\n            return;\n        }\n        samplePt += sampleDir;\n    }\n    \n    float shiftedTime = iTime + 1000.0; // Better noise around here...\n    vec3 tunnelDir = normalize (vec3 (uv.x, uv.y, 1.0));\n    tunnelDir.xy = rotate(tunnelDir.xy, shiftedTime);\n\n    float uvLen = length(tunnelDir.xy);\n    if ( uvLen == 0.0 )\n    {\n        fragColor.rgb = vec3 (0.0);\n        return ;\n    }\n\tvec3 sampleLoc = (10.0 / uvLen) * tunnelDir;\n    sampleLoc.z += shiftedTime * 60.0;\n    fragColor.rgb = vec3 (max(simplex3d(sampleLoc) - 0.75, 0.0) * 10.0) * uvLen;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 21942,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/user-322280034/scrollertrsimegademo"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}