{
    "Shader": {
        "info": {
            "date": "1725915394",
            "description": "very low quality rn, maybe improve later",
            "flags": 0,
            "hasliked": 0,
            "id": "lcBBDd",
            "likes": 2,
            "name": "Katana (low quality, no bend)",
            "published": 3,
            "tags": [
                "sdf",
                "lighting",
                "shadows"
            ],
            "usePreview": 0,
            "username": "helloy90",
            "viewed": 105
        },
        "renderpass": [
            {
                "code": "// --------- Constants ---------\n\nconst float kPi = 3.14159265359;\n\nconst int kMaxSteps = 256;\nconst int kMaxShadowSteps = 32;\nconst float kPresicion = 0.001;\nconst float kMinDist = 0.0;\nconst float kMaxDist = 100.0;\n\nconst mat3 kIdentityMat = mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n);\n\n// --------- Structs ---------\n\nstruct Material {\n    vec3 ambient_color; // ambient reflection * ambient lighting\n    vec3 diffuse_color; // diffuse reflection * light intensity\n    vec3 specular_color; // specular reflection * specular light\n    float shininess;\n};\n\nstruct Surface {\n    int id;\n    float sd;\n    Material material;\n};\n\nstruct Light {\n    vec3 pos;\n    float intensity;\n};\n\n// --------- Materials ---------\n\nMaterial guard() {\n  vec3 aCol = 0.4 * vec3(0.8);\n  vec3 dCol = 0.5 * vec3(0.7);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial handle() {\n  vec3 aCol = 0.9 * vec3(0.1);\n  vec3 dCol = 0.9 * vec3(0.5);\n  vec3 sCol = 0.6 * vec3(0);\n  float a = 1.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial blade() {\n  vec3 aCol = 0.7 * vec3(0.7, 0, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0, 0);\n  vec3 sCol = 0.9 * vec3(1, 1, 1);\n  float a = 500.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial plane(vec3 p) {\n  vec3 aCol = 0.6 * vec3(0.835, 1, 1);\n  vec3 dCol = 0.1 * vec3(1.0);\n  vec3 sCol = 0.1 * vec3(1.0);\n  float a = 15.0;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\n// --------- Utils ---------\n\n// --- Rotations ---\n\nmat3 rotateX(in float angle) {\n    float angle_cos = cos(angle);\n    float angle_sin = sin(angle);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, angle_cos, -angle_sin),\n        vec3(0, angle_sin, angle_cos)\n    );\n}\n\nmat3 rotateY(in float angle) {\n    float angle_cos = cos(angle);\n    float angle_sin = sin(angle);\n    return mat3(\n        vec3(angle_cos, 0, angle_sin),\n        vec3(0, 1, 0),\n        vec3(-angle_sin, 0, angle_cos)\n    );\n}\n\nmat3 rotateZ(in float angle) {\n    float angle_cos = cos(angle);\n    float angle_sin = sin(angle);\n    return mat3(\n        vec3(angle_cos, -angle_sin, 0),\n        vec3(angle_sin, angle_cos, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nmat2 rotate2d(in float angle) {\n    float angle_cos = cos(angle);\n    float angle_sin = sin(angle);\n    return mat2(\n        vec2(angle_cos, angle_sin),\n        vec2(-angle_sin, angle_cos)\n    );\n}\n\n// --- SDF operations ---\n\nSurface opUnion(Surface first_sur, Surface second_sur) {\n    if (second_sur.sd < first_sur.sd) {\n        return second_sur;\n    }\n    return first_sur;\n}\n\nSurface opSmoothUnion(Surface first_sur, Surface second_sur, in float coeff) {\n    float h = clamp( 0.5 + 0.5 * (second_sur.sd - first_sur.sd) / coeff, 0.0, 1.0 );\n    return Surface(second_sur.id, mix(second_sur.sd, first_sur.sd, h) - coeff * h * (1.0 - h), second_sur.material);\n}\n\n// --------- Metrics ---------\n\nfloat lengthInf(in vec2 vector) {\n    return max(abs(vector.x), abs(vector.y));\n}\n\nfloat lengthInf(in vec3 vector) {\n    return max(abs(vector.x), max(abs(vector.y), abs(vector.z)));\n}\n\n// --------- Objects ---------\nfloat sdTriPrism(in vec3 pos, in vec2 h, in vec3 offset, mat3 transform) {\n  vec3 q = abs(pos - offset);\n  return max(q.z - h.y, max(q.x * 0.866025 + pos.y * 0.5, -pos.y) - h.x * 0.5);\n}\n\nfloat sdPlane(in vec3 pos, in vec3 normal, in float offset) {\n    return dot(pos, normal) + offset;\n}\n\nfloat sdSphere(in vec3 pos, in vec3 center, in float radius) {\n    return length(pos - center) - radius;\n}\n\nfloat sdTor(in vec3 p, in vec2 t, mat3 transform) {\n    p = p * transform;\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return lengthInf(q) - t.y;\n}\n\nfloat sdBox(in vec3 pos, in vec3 size, in vec3 offset, mat3 transform) {\n    vec3 adj_pos = abs((pos - offset) * transform) - size;\n    return length(max(adj_pos, 0.0)) + min(max(adj_pos.x, max(adj_pos.y, adj_pos.z)), 0.0);\n}\n\n// --------- Camera ---------\n\nmat3 camera(in vec3 camera_pos, in vec3 look_at_point) {\n    vec3 camera_dir = normalize(look_at_point - camera_pos);\n    vec3 camera_right = normalize(cross(vec3(0, 1, 0), camera_dir));\n    vec3 camera_up = normalize(cross(camera_dir, camera_right));\n    \n    return mat3(-camera_right, camera_up, -camera_dir);\n}\n\n\n// --------- Render ---------\n\n\nSurface sdScene(in vec3 pos) {\n    Surface outer_shell = Surface(1, sdPlane(pos, vec3(0.0, 0.0, 1.0), 20.0), plane(pos));\n    outer_shell = opSmoothUnion(Surface(1, sdPlane(pos, vec3(0.0, 1.0, 0.0), 1.0), plane(pos)), outer_shell, 0.9); // floor plane\n    outer_shell = opSmoothUnion(Surface(1, sdPlane(pos, vec3(1.0, 0.0, 0.0), 20.0), plane(pos)), outer_shell, 0.9);\n    outer_shell = opSmoothUnion(Surface(1, sdPlane(pos, vec3(0.0, 0.0, -1.0), 20.0), plane(pos)), outer_shell, 0.9);\n    outer_shell = opSmoothUnion(Surface(1, sdPlane(pos, vec3(0.0, -1.0, 0.0), 20.0), plane(pos)), outer_shell, 0.9);\n    outer_shell = opSmoothUnion(Surface(1, sdPlane(pos, vec3(-1.0, 0.0, 0.0), 20.0), plane(pos)), outer_shell, 0.9);\n    \n    Surface guard = Surface(2, sdTor(pos, vec2(0.55, 0.1), rotateX(kPi / 2.0)), guard());\n    Surface upper_blade = Surface(2, sdBox(pos, vec3(0.1, 3, 0.1), vec3(0, 0.2, 3), rotateX(kPi / 2.0)), blade());\n    Surface lower_blade = Surface(2, sdBox(pos, vec3(0.05, 3, 0.1), vec3(0, 0, 3), rotateX(kPi / 2.0)), blade());\n    Surface blade = opSmoothUnion(upper_blade, lower_blade, 0.1);\n    Surface handle = Surface(2, sdBox(pos, vec3(0.2, 1, 0.2), vec3(0, 0, -1), rotateX(kPi / 2.0)), handle());\n    Surface lower = opSmoothUnion(guard, handle, 0.7);\n    Surface res = opUnion(opUnion(lower, blade), outer_shell);\n\n    return res;\n}\n\nSurface trace(in vec3 ray_origin, in vec3 ray_dir) {\n    vec3 pos = ray_origin;\n    float total_depth = kMinDist;\n    Surface closest_object;\n\n    for (int steps = 0; steps < kMaxSteps; steps++) {\n        closest_object = sdScene(pos);\n        if (closest_object.sd < kPresicion) {\n            break;\n        }\n\n        total_depth += closest_object.sd;\n\n        if (total_depth > kMaxDist) {\n            break;\n        }\n\n        pos += closest_object.sd * ray_dir;\n    }\n    \n    closest_object.sd = total_depth;\n\n    return closest_object;\n}\n\nvec3 generateNormal(in vec3 pos, in float offset) {\n    float dx1 = sdScene(pos + vec3(offset, 0, 0)).sd;\n    float dx2 = sdScene(pos - vec3(offset, 0, 0)).sd;\n    float dy1 = sdScene(pos + vec3(0, offset, 0)).sd;\n    float dy2 = sdScene(pos - vec3(0, offset, 0)).sd;\n    float dz1 = sdScene(pos + vec3(0, 0, offset)).sd;\n    float dz2 = sdScene(pos - vec3(0, 0, offset)).sd;\n\n    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));\n}\n\nfloat softShadow(vec3 ray_origin, vec3 ray_direction, float mint, float tmax) { //unused rn\n  float result = 1.0;\n  float t = mint;\n\n  for(int i = 0; i < kMaxShadowSteps; i++) {\n    float h = sdScene(ray_origin + ray_direction * t).sd;\n      result = min(result, 8.0 * h / t);\n      t += clamp(h, 0.02, 0.10);\n      if(h < kPresicion || t > tmax) break;\n  }\n\n  return clamp( result, 0.0, 1.0 );\n}\n\nvec3 lightCalc(vec3 light_dir, vec3 pos, vec3 normal, vec3 ray_dir, Light light, Material material) {\n  vec3 ambient = material.ambient_color;\n  \n  vec3 new_ray_origin = pos + normal * kPresicion * 2.0;\n  float shadow_ray_length = trace(new_ray_origin, light_dir).sd; // hard shadows\n\n  float normal_lighting = clamp(dot(light_dir, normal), 0., 1.);\n  \n  vec3 diffuse = material.diffuse_color * normal_lighting;\n  if (shadow_ray_length < length(light.pos - new_ray_origin)) {\n      diffuse *= 0.2;\n  }\n\n  float specular_lighting = clamp(dot(reflect(light_dir, normal), -ray_dir), 0., 1.);\n  vec3 specular = material.specular_color * pow(specular_lighting, material.shininess);\n  if (shadow_ray_length < length(light.pos - new_ray_origin)) {\n      specular *= 0.2;\n  }\n\n  return ambient + diffuse + specular;\n}\n\n\nvec3 render(in vec3 ray_origin, in vec3 ray_dir) {\n    vec3 background_color = vec3(1, .341, .2);\n    vec3 color = background_color; // default color\n    \n    // Set up lights\n    Light light = Light(vec3(2, 2, 5), 1.0);\n    \n    Surface closest_object = trace(ray_origin, ray_dir);\n\n    if(closest_object.sd < kMaxDist) {\n        vec3 pos = ray_origin + ray_dir * closest_object.sd;\n        vec3 normal = generateNormal(pos, kPresicion);\n        \n        vec3 light_dir = normalize(light.pos - pos);\n        \n        color = lightCalc(light_dir, pos, normal, ray_dir, light, closest_object.material);\n        color = mix(color, background_color, 1.0 - exp(-0.0002 * closest_object.sd * closest_object.sd * closest_object.sd));\n    }\n    return color;\n}\n\nvec3 postfx(vec3 color) {\n    //color = pow(color, vec3(1.0/2.2)); //gamma correction\n    return color;\n}\n\n// --------- Main ---------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //camera setup\n    vec3 camera_origin = vec3(0.0, 5.0, 0.0);\n    float camera_radius = 2.0;\n    vec3 look_at_point = vec3(0.0, 0.0, 2.0);\n\n    vec2 uv_coord = (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    camera_origin.yz = camera_origin.yz * camera_radius * rotate2d(mix(kPi / 2.0, 0.0, mouse.y));\n    camera_origin.xz = camera_origin.xz * rotate2d(mix(-kPi, kPi, mouse.x)) + vec2(look_at_point.x, look_at_point.z);\n    \n    vec3 ray_dir = camera(camera_origin, look_at_point) *  normalize(vec3(uv_coord, -1));\n    \n    vec3 background_color = mix(vec3(1, .341, .2), vec3(0, 1, 1), uv_coord.y) * 1.6;\n    vec3 color = background_color; // default color\n\n    color = render(camera_origin, ray_dir);\n    color = postfx(color);\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}