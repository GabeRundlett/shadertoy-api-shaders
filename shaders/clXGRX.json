{
    "Shader": {
        "info": {
            "date": "1672088259",
            "description": "Because the curtain can be opened, and it can be rendered (fast). Featuring:\n\nknarkowics's Cloth Shading: https://shadertoy.com/view/4tfBzn\nwnu's sparkle commented: https://shadertoy.com/view/Ndlczs\n\n*mouse, up/down cam*\n*left/right draw*\n*space to reset*",
            "flags": 48,
            "hasliked": 0,
            "id": "clXGRX",
            "likes": 25,
            "name": "Drawable Curtains",
            "published": 3,
            "tags": [
                "dynamics",
                "physics",
                "glitter",
                "quadtree",
                "cloth",
                "sheen",
                "curtain",
                "velvet"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 391
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  It's another cloth shader, and you know what that means...the comments here may be\n//  threaded with puns. Proceed at your own risk. My previous cloth shaders:\n//\n//      Tearable 3D Fishnet         https://shadertoy.com/view/NlKBW3\n//      Cloth Draping + Shadows     https://shadertoy.com/view/cdjGRR\n//      Textured Cloth              https://shadertoy.com/view/Ddj3Wh\n//      Quadtree Tapestry           https://shadertoy.com/view/mlXGzN\n//\n//  Much credit is due to two other shaders that I borrowed code from, for the \"Charlie\n//  Sheen\" velvet cloth and glittered stars respectively:\n//\n//    knarkowics's Cloth Shading    https://shadertoy.com/view/4tfBzn\n//    wnu's sparkle commented       https://shadertoy.com/view/Ndlczs  \n//\n//  The sky and moon are borrowed from my own\n//\n//    Arctic Fireflies              https://shadertoy.com/view/cssSRs\n//\n//  The title of this shader by itself has a double meaning, because 1) I am simulating\n//  curtains that can be drawn, aka opened, and 2) the cloth is able-to-be-drawn faster\n//  than ever before, now.\n//\n//  I was attempting a \"traditional\" quadtree traveral using a stack, and it worked. You\n//  can see an early version at least in my previous cloth shader \"Quadtree Tapestry\".\n//  But, I wasn't able to beat the performance of archee's amazing shader:\n//\n//      curtain and ball            https://shadertoy.com/view/MldXWX\n//\n//  So, I threw my stack-based traversal out the window, you could say, and went with\n//  archee's general method. I still think I am pushing the state of the art here, though,\n//  because I found a couple of optimizations to archee's code (e.g. only doing one texel\n//  fetch instead of two per iteration). I also massaged the code to hopefully be more\n//  readable and draped it with comments (ahem).\n//\n//  I felt that the speed was sufficient to keep cloth shadows enabled, but if your FPS is\n//  not silky smooth you might want to disable SHADOW_FROM_CLOTH. I guess it's time to bring\n//  this comment to a close. It was fun pulling this together!\n//\n// ---------------------------------------------------------------------------------------\n\n#define SHADOW_FROM_CLOTH 1\n\nconst float FAR_CLIP = 30.;\n\n#define CLOTH_POS_UNCLAMPED(X) texture(iChannel0, ((X)+.5)/iResolution.xy).xyz\n#define CLOTH_POS_CLAMPED(X) texture(iChannel0, (clamp(X, vec2(0), vec2(CLOTH_SIDE_LEN)+.5)/iResolution.xy)).xyz\n\nvec4 getClothNormalGrad(vec2 uv)\n{\n    vec2 delta = vec2(1, 0);\n    vec3 clothPosX0 = CLOTH_POS_CLAMPED(uv + delta.xy);\n    vec3 clothPosX1 = CLOTH_POS_CLAMPED(uv - delta.xy);\n    vec3 deltaX = clothPosX0 - clothPosX1;\n    vec3 clothPosY0 = CLOTH_POS_CLAMPED(uv + delta.yx);\n    vec3 clothPosY1 = CLOTH_POS_CLAMPED(uv - delta.yx);\n    vec3 deltaY = clothPosY0 - clothPosY1;\n    vec3 normal = normalize(cross(deltaX, deltaY));\n    vec3 clothPos = CLOTH_POS_CLAMPED(uv);\n    float grad = dot(normal, clothPosX0 - clothPos) +\n                 dot(normal, clothPosX1 - clothPos) +\n                 dot(normal, clothPosY0 - clothPos) +\n                 dot(normal, clothPosY1 - clothPos);\n\n    return vec4(normal, grad);\n}\n\n// enable to see visualization of quadtree query counts per pixel\n#define DEBUG_NUM_PROC 0\n\n#if DEBUG_NUM_PROC\n#define DEBUG_NUM_PROC_ONLY(X) X\n#else\n#define DEBUG_NUM_PROC_ONLY(X)\n#endif\n\nDEBUG_NUM_PROC_ONLY(int numProc = 0;)\n\n// originally from archee's curtain and ball: https://www.shadertoy.com/view/MldXWX\n//\n// with optimizations:\n//    * only one texel fetch per loop\n//    * compute d2 only once\n//    * removed square roots (length)\n// \n// also, updated variable names and types, added comments\nvec3 quadtreeRender(vec3 cameraPos, vec3 rayDir, float minSize, bool side)\n{\n    vec3 uvz = vec3(0, 0, FAR_CLIP);\n\n    const float STRETCH_RATIO = 3.;\n    const float voxelK2 = (STRETCH_RATIO / CLOTH_SIDE_LEN_F) * (STRETCH_RATIO / CLOTH_SIDE_LEN_F);\n    float voxelsize2 = (minSize * minSize * voxelK2);\n    \n    vec2 corner = vec2(0); // corner of current quad being considered\n    float size = CLOTH_SIDE_LEN_F / 2.; // size of quad being considered\n    float end = size;\n    if (side)\n    {\n        corner = vec2(size, 0);\n        end = CLOTH_SIDE_LEN_F;\n    }\n    bool levelup = false;\n    \n    for (int i = 0; i < 5000; ++i) // less than 200 iterations for most pixels\n    {\n        DEBUG_NUM_PROC_ONLY(++numProc;)\n\n        vec3 boundingcenter = CLOTH_POS_UNCLAMPED(corner + size * .5);\n        float d2 = length2(cross(boundingcenter - cameraPos, rayDir));\n\n        if (size <= minSize)\n        {\n        \tif (d2 <= voxelsize2 &&\n                floor(corner.x + 1.) != CLOTH_SIDE_LEN_F / 2.) // missing between left and right sides\n        \t{\n                // found small enough quadrant to render it\n                float dept = dot(rayDir, boundingcenter - cameraPos);\n                uvz = dept < uvz.z ? vec3(corner + .5 * size, dept) : uvz;\n\t        }\n          \n            levelup = true; // don't bother to descend, we've already rendered\n        }\n\n        if (d2 > size * size * voxelK2 * .5)\n        {\n            levelup = true; // not near this quadrant, don't descend into here\n        }\n        \n        if (levelup)\n        {\n            levelup = false;\n            \n            if (fract(corner.y / size / 2.) < .25)\n            {\n                corner.y += size; // we're on the top...go to the bottom\n            }\n            else\n            {\n                corner.y -= size; // we're on the bottom...go back to the top\n\n                if (fract(corner.x / size / 2.) < .25)\n                {\n                    corner.x += size; // go from right to left\n                }\n                else\n                {\n                    corner.x -= size; // done with this quad, go up a level\n                    size *= 2.0;\n                    levelup = true;\n                }\n            }\n        }\n        else\n        {\n            if (size > minSize) size /= 2.;\n        }\n        \n        if (corner.x >= end) break;    \n    }\n    \n    return uvz;\n}\n\nvoid fxCalcCamera(in vec3 cameraLookAt, in vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-cameraLeft, 0.0),\n        vec4(-cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\nvec3 fxGetParticlePos(int id)\n{\n    ivec2 addr = ivec2(id % CLOTH_SIDE_LEN, id / CLOTH_SIDE_LEN);\n    return texelFetch(iChannel0, addr, 0).xyz;\n}\n\n#define MAX_STEPS 100\n#define SURF_DIST .001\n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n\tfloat d = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n    \tvec3 p = ro + rd * d;\n        float dS = scene(p, true);\n        d += dS;\n        if(d > FAR_CLIP || abs(dS) < SURF_DIST) break;\n    }\n    \n    return min(FAR_CLIP, d);\n}\n\nconst vec3 FILL_LIGHT_DIR = normalize(vec3(-1, 0.75, 1));\n\nbool shadowScene(vec3 p, vec3 lightDir)\n{\n    return rayMarch(p, lightDir) < FAR_CLIP;\n}\n\n#if SHADOW_FROM_CLOTH\nbool shadowCloth(vec3 p, vec3 lightDir)\n{\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    \n    cameraPos = p;\n    cameraLookAt = p + lightDir;\n\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n    vec3 rayDir = cameraFwd;\n\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n    vec3 uvz1 = quadtreeRender(cameraPos, rayDir, 1./4., false); // right side\n    vec3 uvz2 = quadtreeRender(cameraPos, rayDir, 1./4., true); // left side\n    vec3 uvz = uvz1.z < uvz2.z ? uvz1 : uvz2;\n\n    return uvz.z > 0. && uvz.z < FAR_CLIP;\n}\n#endif // SHADOW_FROM_CLOTH\n\nvec3 light(vec3 n, vec3 pointLightDir, bool shadow)\n{\n    return vec3(abs(dot(n, FILL_LIGHT_DIR)) * .05) + float(!shadow) * max(0., dot(n, pointLightDir)) * .9;\n}\n\nvec2 noise( in vec3 x )\n{\n    vec3 ip = floor(x);\n    vec3 fp = fract(x);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec4 rz = textureLod( iChannel1, (tap+0.5)/256.0, 0.0 );\n\treturn mix( rz.yw, rz.xz, fp.z );\n}\n\n// from sparkle commented by wnu: https://www.shadertoy.com/view/Ndlczs\nvec3 glitter(vec3 rayHit, vec3 normal, vec3 camDir)\n{\n    float t = iTime;\n    vec3 n = normal;\n\n    /////BASE COLOR\n\n    //FRESNEL \n\n    float fre = clamp(1. + dot(camDir,normal),-1.,1.);\n    float edge = sqrt(1.2-pow(fre,1./4.2));\n\n    //PICK YOUR COLOR\n\n    vec3 colorPick = vec3(.65, .45, 0.);\n\n    //COLOR FROM NORMALS AND FRESNEL\n\n    vec3 c = 2.25*-sin(sin(t*0. + n.x*1.+ 1.57 + sin(n.z*1. + 0.76)) + n.y + t*0.+  colorPick);\n    float ss = min(.5 - edge, smoothstep(.45 - edge, 1., edge));\n    c *= ss;\n\n    ///////GLINTS/GLITTER COMPUTATION\n\n    #define PRIMARY_INTENSITY 2.3\n    #define PRIMARY_CONCENTRATION 6.\n    #define SECONDARY_INTENSITY 10.\n    #define SECONDARY_CONCENTRATION 0.9\n\n    // HOW BIG THE GLITTER SPECKS ARE ; BIGGER -> SMALLER SPECKS\n    // (7 is probably the smallest I would go)\n\n    float scale = 400.;\n    rayHit = floor(rayHit*scale)/scale;\n\n    vec3 ligt = vec3(1.);\n    vec3 h = normalize(ligt-camDir);\n    float nl = dot(n,ligt);\n\n    vec3 coord = rayHit*.5;\n    coord.xy = coord.xy*.7071+coord.yx*.7071*vec2(1,-1);\n    coord.xz = coord.xz*.7071+coord.zx*.7071*vec2(1,-1);\n    vec3 coord2 = coord;\n\n    //first layer (inner glints)\n    float pw = .5*((iResolution.x));\n    vec3 aniso = vec3( noise((coord*pw)), noise((coord.yzx*pw)) )*2.0-1.0;\n    aniso -= n*dot(aniso,n);\n    float anisotropy = min(1.,length(aniso));\n    aniso /= anisotropy;\n    anisotropy = .55;\n    float ah = abs(dot(h,aniso));\n    float nh = abs(dot(n,h));\n    float qa = exp2((1.1-anisotropy)*3.5);\n    nh = pow( nh, qa*PRIMARY_CONCENTRATION );\n    nh *= pow( 1.-ah*anisotropy, 10.0 );\n    vec3 glints = c*nh*exp2((1.2-anisotropy)*PRIMARY_INTENSITY);\n\n    //second layer (outer glints)\n    pw = .145*((iResolution.x));\n    vec3 aniso2 = vec3( noise(coord2*pw), noise(coord2.yzx*pw).x )*2.0-1.0;\n    anisotropy = .6;\n    float ah2 = abs(dot(h,aniso2));\n    float nh2 = abs(dot(n,h));\n    float q2 = exp2((.1-anisotropy)*3.5);\n    nh2 = pow( nh, q2*SECONDARY_CONCENTRATION );\n    nh2 *= pow( 1.-ah2*anisotropy, 150.0 );\n    vec3 glints2 = c*nh2*((1.-anisotropy)*SECONDARY_INTENSITY);\n\n    ///// ADD BASE COLOR AND GLINTS/GLITTER LAYERS   \n\n    vec3 col = vec3(c)/4.;\n    col += (glints+glints2);\n\n    return col*col;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.), vec3(1.));\n}\n\n// From Cloth Shading by knarkowics: https://www.shadertoy.com/view/4tfBzn\nvec3 FresnelTerm(vec3 specularColor, float vdoth)\n{\n\tvec3 fresnel = specularColor + (1. - specularColor) * pow((1. - vdoth), 5.);\n\treturn fresnel;\n}\n\nfloat CharlieD(float roughness, float ndoth)\n{\n    float rcpR  = 1. / roughness;\n    float cos2h = ndoth * ndoth;\n    float sin2h = 1. - cos2h;\n    return (2. + rcpR) * pow(sin2h, rcpR * .5) / (2. * PI);\n}\n\nfloat L(float x, float r)\n{\n\tr = saturate(r);\n\tr = 1.0 - (1. - r) * (1. - r);\n\n\tfloat a = mix( 25.3245,  21.5473, r);\n\tfloat b = mix( 3.32435,  3.82987, r);\n\tfloat c = mix( 0.16801,  0.19823, r);\n\tfloat d = mix(-1.27393, -1.97760, r);\n\tfloat e = mix(-4.85967, -4.32054, r);\n\n\treturn a / (1. + b * pow(x, c)) + d * x + e;\n}\n\nfloat CharlieV(float roughness, float ndotv, float ndotl)\n{\n\tfloat visV = ndotv < .5 ? exp(L(ndotv, roughness)) : exp(2. * L(.5, roughness) - L(1. - ndotv, roughness));\n\tfloat visL = ndotl < .5 ? exp(L(ndotl, roughness)) : exp(2. * L(.5, roughness) - L(1. - ndotl, roughness));\n\n\treturn 1. / ((1. + visV + visL) * (4. * ndotv * ndotl));\n}\n\nconst vec3 MOON_DIR = normalize(vec3(1, 2, -1));\nconst vec3 MOON_COLOR = vec3(.1, .15, .3);\n\nvec3 velvet(vec4 normalGrad, vec3 rayDir, vec3 hit, vec3 baseColor)\n{\n    if (dot(normalGrad.xyz, rayDir) > 0.) normalGrad.xyz = -normalGrad.xyz;\n\n    vec3 viewDir = -rayDir;\n    vec3 lightDir = MOON_DIR;\n\n    vec3 halfVec = normalize(viewDir + lightDir);\n    float vdoth = saturate(dot(viewDir, halfVec));\n    float ndoth\t= saturate(dot(normalGrad.xyz, halfVec));\n    float ndotv = saturate(dot(normalGrad.xyz, viewDir));\n    float ndotl = saturate(abs(dot(normalGrad.xyz, lightDir)));\n\n    vec3 diffuseColor  = 0.25 * baseColor;\n    vec3 specularColor = sqrt(baseColor);\n    float roughness    = 0.5;\n\n    vec3 diffusePoint = diffuseColor * saturate(dot(normalGrad.xyz, lightDir));\n    vec3 diffuseFill = diffuseColor * saturate(dot(normalGrad.xyz, FILL_LIGHT_DIR));\n\n    vec3 f = FresnelTerm(specularColor, vdoth);\n\n    float d = CharlieD(roughness, ndoth);\n    float v = CharlieV(roughness, ndotv, ndotl);\n\n    vec3 specular = f * (d * v * PI * ndotl);\n\n    vec3 color = diffusePoint + diffuseFill + specular;\n    return color;\n}\n\n// From jarble's Glacial valleys: https://www.shadertoy.com/view/NscGWl\n// (used for moon)\nfloat fbm(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    uv *= 1.25;\n    float value = 0.;\n    float amplitude = 1.2;\n    float freq = 0.5,n2=0.;\n    vec2 n1 = vec2(0.);\n    for (int i = 0; i < octaves; i++)\n    {\n        n2 = sin(uv.x*freq)+cos(uv.y*freq);\n\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = abs(value-abs(n2-value) * amplitude);\n        amplitude *= .37;\n        freq *= 2.05;\n        uv = vec2(uv.y,uv.x+n2/(freq));\n    }\n    \n    return value;\n}\n\nfloat fbm(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nvec3 sky(vec3 rayDir)\n{\n    vec3 stars = vec3(smoothstep(.5, .8, pow(float(hash(uvec4(rayDir * iResolution.y + 4000., 1)).r) / 4.35e9, 50.))) * 4.;\n    float d = distance(rayDir, MOON_DIR);\n    if (d > .03 + + 2./iResolution.y) return stars;\n    vec3 moon = MOON_COLOR * (1. + fbm(rayDir.xxy * 100., 3));\n    return mix(moon, stars, smoothstep(.03, .03 + 2./iResolution.y, d));\n}\n\nvec4 hash4(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return vec4(x) * (1./float(0xffffffffU));\n}\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\n// From iq's Star - distance 2d: https://www.shadertoy.com/view/3tSGDy\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nvec4 renderCurtain(vec2 fragCoord)\n{\n    vec4 fragColor = vec4(.15, .0, .2, 0);\n    \n    vec2 u = fragCoord;\n    \n#if 0 // animated stars\n    float t = iTime;\n    u.y += t * .05;\n#else\n    const float t = 1.;\n#endif\n    \n    vec2 r;\n    u = modf(u * 8., r) / 8.;\n    vec4 h1 = hash4(uvec4(r.xyxy * 1000.));\n    vec4 h2 = hash4(uvec4(h1 * 1000.));\n    u.x *= iResolution.x / iResolution.y;\n    fragColor = mix(vec4(1,1,0,1), fragColor, smoothstep(0., .001, sdStar((u - .0125 - h1.yz * .1) * rot2(h1.x * 2. * PI + t), .015, h2.x < .5 ? 5 : 6, 3. + 2. * h1.w)));\n    fragColor = mix(vec4(1,1,0,1), fragColor, smoothstep(0., .001, sdStar((u - .0125 - h2.yz * .1) * rot2(h2.x * 2. * PI - t), .015, 5, 3. + 2. * h2.w)));\n    \n    return fragColor;\n}\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    DEBUG_NUM_PROC_ONLY(numProc = 0);\n    vec2 u = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxState state = fxGetState(iFrame);\n    \n    cameraPos = -state.orbit * vec3(sin(state.camera.x) * sin(state.camera.y), cos(state.camera.y), cos(state.camera.x) * sin(state.camera.y));\n    cameraLookAt = vec3(0, .3, 0);\n    cameraPos += cameraLookAt;\n\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    vec3 color = MOON_COLOR;\n    float d = rayMarch(cameraPos, rayDir);\n    bool s = false;\n    float ao = 0.;\n    \n    // render scene\n    if (d < FAR_CLIP)\n    {\n        vec3 hit = cameraPos + rayDir * d;\n        vec3 normal = getSceneNormal(hit, true);\n        vec3 offsetPos = hit + normal * 2. * SURF_DIST;\n        s = shadowScene(offsetPos, MOON_DIR);\n#if SHADOW_FROM_CLOTH\n        s = s || shadowCloth(offsetPos, MOON_DIR);\n#endif\n        fragColor.xyz = (light(normal, MOON_DIR, s) - ao) * color;\n    }\n    else\n        fragColor.xyz = sky(rayDir);\n\n    // render cloth\n    vec3 uvz1 = quadtreeRender(cameraPos, rayDir, 1./16., false); // right side\n    vec3 uvz2 = quadtreeRender(cameraPos, rayDir, 1./16., true); // left side\n    vec3 uvz = uvz1.z < uvz2.z ? uvz1 : uvz2;\n    if (uvz.z < d)\n    {\n        vec4 normalGrad = getClothNormalGrad(uvz.xy);\n        vec3 normal = normalGrad.xyz;\n        vec3 hit = cameraPos + rayDir * uvz.z;\n        float ao = .5 + .5 *smoothstep(.2, 0.1, -normalGrad.w);\n\n        vec3 lightColor = MOON_COLOR * ao;\n\n#if 0 // enable shadows on cloth\n        vec3 offsetPos = hit + normal * 2. * SURF_DIST;\n        s = shadowScene(offsetPos, MOON_DIR);\n#if SHADOW_FROM_CLOTH\n        //s = s || shadowCloth(offsetPos, MOON_DIR); // self-shadowing adds a lot of cost, not a lot of effect\n#endif\n        if (s) lightColor *= .25;\n#endif\n       // if (dot(normal, cameraFwd) < 0.) lightColor *= .1;\n        \n        vec4 colorGlitter = renderCurtain(uvz.xy / CLOTH_SIDE_LEN_F);\n        //colorGlitter.a = 1.; // gold sparkly curtains\n        vec3 color = velvet(normalGrad, rayDir, hit, colorGlitter.rgb) * lightColor;\n        if (colorGlitter.a > 0.)\n        {\n            color = mix(color, glitter(hit, normal, -rayDir), colorGlitter.a);\n        }\n        fragColor = vec4(color, 1);\n    }\n    \n    fragColor.xyz = ACESFilm(pow(fragColor.xyz, vec3(1./2.2)));\n    fragColor.w = 1.;\n\n    DEBUG_NUM_PROC_ONLY(fragColor = sin(float(numProc) * vec4(1, 11, 13, 0)) * sqrt(vec4(numProc)) / 10.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int CLOTH_SIDE_LEN = 128;\nconst float CLOTH_SIDE_LEN_F = float(CLOTH_SIDE_LEN);\nconst float PI = 3.141592653589793;\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\nvec4 noise(uvec4 p){\n    const float scale = 1.0/float(0xffffffffU);\n    uvec4 h = hash(p);\n    return vec4(h)*scale;\n}\n\nfloat length2(vec3 v) { return dot(v, v); }\nfloat length2(vec2 v) { return dot(v, v); }\n\nfloat sdBox(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n// IQ's 3D line segment formula. Simpler and cheaper, but doesn't orient carved cross-sections.\nfloat sdCapsule(vec3 p, vec3 a, vec3 b){\n\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    pa = abs(pa - ba*h);\n    return length( pa );\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat scene(vec3 p, bool rod)\n{\n    float d = 1e6;\n    \n    d = min(d, sdBox(p - vec3(-.9,.05,.1), vec3(.1,.9,.1))); // wall\n    d = min(d, sdBox(p - vec3(.9,.05,.1), vec3(.1,.9,.1))); // wall\n    d = min(d, sdBox(p - vec3(0,1.,.1), vec3(1.,.1,.1))); // wall\n    d = min(d, sdBox(p - vec3(0,-.8,.1), vec3(1.,.1,.1))); // wall\n    d = min(d, sdBox(p - vec3(0,-.65,.1), vec3(.9,.05,.2))); // sill\n    d = min(d, sdBox(p + vec3(0,3.5,0), vec3(10.,1.,10.))); // floor\n    if (rod)\n    {\n        d = min(d, sdCapsule(p, vec3(-.85, .95, -.02), vec3(.85, .95, -.01)) - .01); // rod\n        d = min(d, sdSphere(p - vec3(-.85, .95, -.02), .03)); // right side ball\n        d = min(d, sdSphere(p - vec3( .85, .95, -.02), .03)); // left side ball\n    }\n    \n    return d;\n}\n\n// // https://iquilezles.org/articles/normalsSDF\nvec3 getSceneNormal(vec3 p, bool rod)\n{\n    const vec2 e = vec2(1.0,-1.0)*0.000005773;\n    return normalize( e.xyy*scene(p + e.xyy, false ) + \n\t\t\t\t\t  e.yyx*scene(p + e.yyx, false ) + \n\t\t\t\t\t  e.yxy*scene(p + e.yxy, false ) + \n\t\t\t\t\t  e.xxx*scene(p + e.xxx, false ) );\n}\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n#define keyDownImpl(sampler, ascii)    ( texelFetch(sampler,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n\nstruct fxState\n{\n    float draw;\n    float attractCurtain;\n    float attractCamera;\n    float orbit;\n    vec2 camera;\n    vec2 lastMouse;\n};\n\nvoid initState(inout fxState state)\n{\n    state.draw = .75;\n    state.attractCurtain = 15.;\n    state.attractCamera = 1.;\n    state.orbit = 2.2;\n    state.camera = vec2(sin(.0004), cos(.0002) * .25 + PI*.5);\n    state.lastMouse = vec2(0);\n}\n\nfxState fxGetStateImpl(sampler2D sampler, int iFrame)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0, CLOTH_SIDE_LEN * 2), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, CLOTH_SIDE_LEN * 2), 0);\n    \n    fxState state;\n    state.draw = data0.x;\n    state.attractCurtain = data0.y;\n    state.attractCamera = data0.z;\n    state.orbit = data0.w;\n    state.camera = data1.xy;\n    state.lastMouse = data1.zw;\n    if (iFrame == 0) initState(state);\n    return state;\n}\n\n#define fxGetState(iFrame) fxGetStateImpl(iChannel0, iFrame)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0, CLOTH_SIDE_LEN * 2))\n        return vec4(state.draw, state.attractCurtain, state.attractCamera, state.orbit);\n    else\n        return vec4(state.camera, state.lastMouse);\n}\n\nvec4 updateState(fxState state, sampler2D keySampler, ivec2 ifc, int iFrame, vec4 iMouse, vec3 iResolution, float iTime)\n{\n    if (iFrame == 0 || keyDownImpl(keySampler, KEY_SPACE))\n    {\n        initState(state);\n    }\n    else\n    {\n        if (keyDownImpl(keySampler, KEY_LEFT))\n        {\n            state.draw += .0025;\n            state.attractCurtain = 0.;\n        }\n        if (keyDownImpl(keySampler, KEY_RIGHT))\n        {\n            state.draw -= .0025;\n            state.attractCurtain = 0.;\n        }\n        if (keyDownImpl(keySampler, KEY_UP))\n        {\n            state.orbit -= .0025;\n            state.attractCamera = 0.;\n        }\n        if (keyDownImpl(keySampler, KEY_DOWN))\n        {\n            state.orbit += .0025;\n            state.attractCamera = 0.;\n        }\n        if (state.attractCurtain != 0.)\n        {\n            state.attractCurtain = mod(state.attractCurtain, 30.) + .005;\n            state.draw = smoothstep(10., 15., state.attractCurtain) * smoothstep(30., 25., state.attractCurtain) * .5 + .3;\n        }\n        state.draw = clamp(state.draw, .3, .8);\n\n        if (iMouse.z > 0.)\n        {\n            state.attractCamera = 0.;\n            \n            if (iMouse.w < 0.)\n            {\n                state.camera += 10. * ((iMouse.xy / iResolution.x) - state.lastMouse);\n                state.camera.y = clamp(state.camera.y, PI*.1, PI*.9);\n            }\n\n            state.lastMouse = iMouse.xy / iResolution.x;\n        }\n        \n        if (state.attractCamera > 0.)\n        {\n            state.attractCamera += 1.;\n            state.camera = vec2(sin(state.attractCamera * .0004), cos(state.attractCamera * .0002) * .25 + PI*.5);\n            state.orbit = 1.7 + cos(state.attractCamera * .0003) * .5;\n        }\n    }\n    \n    return fxPutState(state, ifc);\n}\n\nvec3 fxGetParticlePos(sampler2D sampler, int id)\n{\n    ivec2 addr = ivec2(id % CLOTH_SIDE_LEN, id / CLOTH_SIDE_LEN);\n    return texelFetch(sampler, addr, 0).xyz;\n}\n\nvoid horizConstraint(sampler2D sampler, ivec2 nb, int dist, inout vec3 pos)\n{\n    vec3 nbPos = texelFetch(sampler, nb, 0).xyz;\n    vec3 delta = pos - nbPos;\n    float deltaLen = length(delta);\n    float idealDist = float(dist) * 2.7 / float(CLOTH_SIDE_LEN - 1);\n    float f = .4;\n    if (deltaLen > idealDist) f = .6;\n    pos = mix(nbPos + normalize(delta) * idealDist, pos, f);\n}\n\nvoid vertConstraint(sampler2D sampler, ivec2 nb, int dist, float f, inout vec3 pos)\n{\n    const float Y_STRETCH = 1.47;\n\n    vec3 nbPos = texelFetch(sampler, nb, 0).xyz;\n    vec3 delta = pos - nbPos;\n    float deltaLen = length(delta);\n    if (deltaLen > Y_STRETCH * float(dist) / float(CLOTH_SIDE_LEN - 1))\n    {\n        pos = mix(nbPos + normalize(delta) * Y_STRETCH * float(dist) / float(CLOTH_SIDE_LEN - 1), pos, f);\n    }\n}\n\nvec3 initVert(ivec2 v, fxState state)\n{\n    vec2 vert = vec2(v);\n    vert.y = CLOTH_SIDE_LEN_F - (CLOTH_SIDE_LEN_F - vert.y)*.83;\n    vec3 pos = (vec3(((vert - float(CLOTH_SIDE_LEN - 1) * .5))*2./CLOTH_SIDE_LEN_F, -.01) + vec3(0, .05, 0)) * vec3(state.draw, .95, 1);\n    \n    // split down the middle\n    if (v.x < CLOTH_SIDE_LEN / 2) pos.x -= .8 - state.draw;\n    else pos.x += .8 - state.draw;\n    \n    // wavy top to set up the pleats\n    float s = sin(float(v.x) * 3.14 / 4.);\n    //if (abs(s) > 1e-6) s /= sqrt(abs(s));\n    pos.z -= (1. + s) * .03;\n    return pos;\n}\n\n#define CLOTH_POS(X) texture(sampler, clamp((X+.5)/res.xy, vec2(0), vec2(CLOTH_SIDE_LEN))).xyz\n\nvec3 getClothNormal(sampler2D sampler, vec3 res, ivec2 ifc)\n{\n    vec2 uv = vec2(ifc);\n    vec2 delta = vec2(1, 0);\n    vec3 clothPosX0 = CLOTH_POS(uv + delta.xy);\n    vec3 clothPosX1 = CLOTH_POS(uv - delta.xy);\n    vec3 deltaX = clothPosX0 - clothPosX1;\n    vec3 clothPosY0 = CLOTH_POS(uv + delta.yx);\n    vec3 clothPosY1 = CLOTH_POS(uv - delta.yx);\n    vec3 deltaY = clothPosY0 - clothPosY1;\n    return normalize(cross(deltaX, deltaY));\n}\n\nvoid clothBufferMainImpl( out vec4 fragColor, vec2 fragCoord, sampler2D vertexSampler, sampler2D keySampler, int iFrame, vec4 iMouse, vec3 iResolution, float iTime)\n{\n    ivec2 ifc = ivec2(fragCoord);\n    \n    fxState state = fxGetStateImpl(vertexSampler, iFrame);\n    \n    if (ifc == ivec2(0, CLOTH_SIDE_LEN * 2) || ifc == ivec2(1, CLOTH_SIDE_LEN * 2))\n    {\n        fragColor = updateState(state, keySampler, ifc, iFrame, iMouse, iResolution, iTime);\n        return;\n    }\n    \n    if (any(greaterThan(ifc, CLOTH_SIDE_LEN * ivec2(2, 1))))\n    {\n        fragColor = vec4(0); // discard all unneeded pixels\n        return;\n    }\n    \n    if (iFrame == 0 || keyDownImpl(keySampler, KEY_SPACE))\n    {\n        // init cloth positions\n        ifc.x = (ifc.x % CLOTH_SIDE_LEN);\n        fxState initState;\n        initState.draw = .8;\n        fragColor.xyz = initVert(ifc, initState);\n        fragColor.w = 1.;\n\n        return;\n    }\n    \n    if (ifc.x >= CLOTH_SIDE_LEN)\n    {\n        // store last position on right side\n        fragColor = texelFetch(vertexSampler, ifc - ivec2(CLOTH_SIDE_LEN, 0), 0);\n        return;\n    }\n    \n    vec3 pos = texelFetch(vertexSampler, ifc, 0).xyz;\n    if (ifc.y >= CLOTH_SIDE_LEN - 6)\n    {\n        pos = initVert(ifc, state); // top six rows are pinned\n    }\n    else\n    {\n        vec3 oldPos = texelFetch(vertexSampler, ifc + ivec2(CLOTH_SIDE_LEN, 0), 0).xyz;\n        \n        pos += (pos - oldPos) * .9; // integration\n        pos += vec3(0, -.1, 0); // gravity\n        \n        // wind\n        vec3 normal = getClothNormal(vertexSampler, iResolution, ifc);\n        pos.z += sin(pos.x*.3 + iTime*.2) * .03 * normal.z;\n\n        // vertical constraints\n        for (int i = 0; i < 5; ++i)\n        {\n            float Y_STRETCH = 1.47;\n            ivec2 nbU = ifc + ivec2(0, i);\n            if (nbU.y <= CLOTH_SIDE_LEN - 1) vertConstraint(vertexSampler, nbU, i, .5, pos);\n            ivec2 nbD = ifc - ivec2(0, i);\n            if (nbD.y >= 0) vertConstraint(vertexSampler, nbD, i, .99, pos);\n        }\n\n        // horizontal constraints\n        int endL = ifc.x < CLOTH_SIDE_LEN / 2 ? CLOTH_SIDE_LEN / 2 - 1 : CLOTH_SIDE_LEN - 1;\n        int endR = ifc.x >= CLOTH_SIDE_LEN / 2 ? CLOTH_SIDE_LEN / 2 : 0;\n        for (int i = 0; i < 3; ++i)\n        {\n            ivec2 nbL = ifc + ivec2(i, 0);\n            ivec2 nbR = ifc - ivec2(i, 0);\n            if (nbL.x <= endL) horizConstraint(vertexSampler, nbL, i, pos);\n            if (nbR.x >= endR) horizConstraint(vertexSampler, nbR, i, pos);\n        }\n\n        // collision with scene\n        pos -= min(0., scene(pos, false) - .01) * getSceneNormal(pos, false);\n\n    }\n\n    fragColor = vec4(pos, 1);\n}\n\n#define clothBufferMain(fragColor, fragCoord) clothBufferMainImpl( fragColor, fragCoord, iChannel0, iChannel3, iFrame, iMouse, iResolution, iTime)\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Cloth simulation. Left side is current position, right side is last position.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    clothBufferMain(fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Cloth simulation. Left side is current position, right side is last position.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    clothBufferMain(fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Cloth simulation. Left side is current position, right side is last position.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    clothBufferMain(fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Cloth simulation. Left side is current position, right side is last position.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    clothBufferMain(fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}