{
    "Shader": {
        "info": {
            "date": "1611893600",
            "description": "I guess this is a meme on Shadertoy now (at least for today, and hopefully for a long time to come...)\nI used my new Cornell Box I made today. Long live the bunny!\nThe original Stanford Bunny Neural SDF by blackle: https://www.shadertoy.com/view/wtVyWK",
            "flags": 32,
            "hasliked": 0,
            "id": "wtVyW3",
            "likes": 18,
            "name": "Path-Tracing: Stanford Bunny",
            "published": 3,
            "tags": [
                "raymarching",
                "ray",
                "raymarcher",
                "pathtracing",
                "pathtracer",
                "path",
                "neural",
                "bunny",
                "neuralnetwork",
                "stanford",
                "stanfordbunny"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 1202
        },
        "renderpass": [
            {
                "code": "// Fork of Path-Tracer Cornell Box by Zi7ar21: https://shadertoy.com/view/3lGyDc\n// January 29th, 2020 13:00\n\n// Common contains adjustable parameters and RNG functions\n// Buffer A contains the Path-Tracer\n// Buffer B contains an image export\n// This contains the output to the screen\n\n// ATTENTION! Mega-Poggers Neural Network Distance Estimator from blackle: https://www.shadertoy.com/view/wtVyWK\n// Path-Tracing: Stanford Bunny by Zi7ar21 --- January 28th, 2020\n// Last Updated: January 28th, 2020 21:10 Mountain Time\n\n// If you didn't find this on ShaderToy there may be an updated version at:\n// https://www.shadertoy.com/view/wtVyW3\n\n// Michael0884 fixed this like a lot, check him out:\n// https://www.shadertoy.com/user/michael0884\n\n// Also check out LoicVDB, who offered other advice:\n// https://www.shadertoy.com/user/loicvdb\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This contains adjustable parameters and RNG functions\n\n// Camera Settings\n#define camerafov 0.35\n#define camerapos vec3(0.0, -0.4, -8.0)\n\n// Adjustable Path-Tracing Settings\n#define maxbounces 32\n#define maxmarches 1024\n#define collisiondist 1e-4\n#define scenesize 6.0\n#define ditherradius 0.5\n\n// PBR Not Fully Implemented Yet, Going to Work From This:\n// PBR Theory (Albedo, Normal, Metallic, Roughness)\n// https://learnopengl.com/PBR/Theory\n\n// Material (Albedo, Roughness)\nvec4 materialproperties(vec3 pos, int material){\n    // Material of the Fractal\n    if(material == 0){\n        //return vec4(vec3(1.0), clamp((fbm(pos*8.0)-0.2)/8.0, 0.0, 0.5));\n        return vec4(vec3(1.0, 1.0, 0.5), 0.125);\n    }\n    // Material of the Podium\n    if(material == 1){\n        return vec4(vec3(1.0, 1.0, 1.0), 0.125);\n    }\n    // White Diffuse\n    if(material == 2){\n        return vec4(vec3(1.0), 0.5);\n    }\n    // Red Diffuse\n    if(material == 3){\n        return vec4(vec3(1.0, 0.25, 0.25), 0.5);\n    }\n    // Green Diffuse\n    if(material == 4){\n        return vec4(vec3(0.25, 1.0, 0.25), 0.5);\n    }\n    // Non-Defined Material\n    return vec4(0.0);\n}\n\n// Constants (ShaderToy uses Single Precision which can represent Pi as 3.14159265 whilst Double Precision\n// can encode pi as 3.141592653589793, who knows maybe in the future ShaderToy will support Double so why not\n// include the 3589793)\n#define pi 3.141592653589793\n#define twopi pi*2.0\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state>>((state>>28u)+4u))^state)*277803737u;\n    ns = (word>>22u)^word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\n//vec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Nor3alized Random also from Michael0884: https://www.shadertoy.com/view/WttyWX\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// This contains the Path-Tracer\n\n// https://www.shadertoy.com/view/wtVyWK\nfloat scene(vec3 p){\n    p += vec3(0.08, 0.475, 0.0);\n    p = p.zxy;\n    // SDF is undefined outside the unit sphere, uncomment to witness the abominations\n    if(length(p) > 1.0){\n        return length(p)-0.8;\n    }\n    // Neural Networks can be really compact... When they want to be\n    vec4 f00=sin(p.y*vec4(-3.02,1.95,-3.42,-.60)+p.z*vec4(3.08,.85,-2.25,-.24)-p.x*vec4(-.29,1.16,-3.74,2.89)+vec4(-.71,4.50,-3.24,-3.50));\n    vec4 f01=sin(p.y*vec4(-.40,-3.61,3.23,-.14)+p.z*vec4(-.36,3.64,-3.91,2.66)-p.x*vec4(2.90,-.54,-2.75,2.71)+vec4(7.02,-5.41,-1.12,-7.41));\n    vec4 f02=sin(p.y*vec4(-1.77,-1.28,-4.29,-3.20)+p.z*vec4(-3.49,-2.81,-.64,2.79)-p.x*vec4(3.15,2.14,-3.85,1.83)+vec4(-2.07,4.49,5.33,-2.17));\n    vec4 f03=sin(p.y*vec4(-.49,.68,3.05,.42)+p.z*vec4(-2.87,.78,3.78,-3.41)-p.x*vec4(-2.65,.33,.07,-.64)+vec4(-3.24,-5.90,1.14,-4.71));\n    vec4 f10=sin(mat4(-.34,.06,-.59,-.76,.10,-.19,-.12,.44,.64,-.02,-.26,.15,-.16,.21,.91,.15)*f00+\n        mat4(.01,.54,-.77,.11,.06,-.14,.43,.51,-.18,.08,.39,.20,.33,-.49,-.10,.19)*f01+\n        mat4(.27,.22,.43,.53,.18,-.17,.23,-.64,-.14,.02,-.10,.16,-.13,-.06,-.04,-.36)*f02+\n        mat4(-.13,.29,-.29,.08,1.13,.02,-.83,.32,-.32,.04,-.31,-.16,.14,-.03,-.20,.39)*f03+\n        vec4(.73,-4.28,-1.56,-1.80))/1.0+f00;\n    vec4 f11=sin(mat4(-1.11,.55,-.12,-1.00,.16,.15,-.30,.31,-.01,.01,.31,-.42,-.29,.38,-.04,.71)*f00+\n        mat4(.96,-.02,.86,.52,-.14,.60,.44,.43,.02,-.15,-.49,-.05,-.06,-.25,-.03,-.22)*f01+\n        mat4(.52,.44,-.05,-.11,-.56,-.10,-.61,-.40,-.04,.55,.32,-.07,-.02,.28,.26,-.49)*f02+\n        mat4(.02,-.32,.06,-.17,-.59,.00,-.24,.60,-.06,.13,-.21,-.27,-.12,-.14,.58,-.55)*f03+\n        vec4(-2.24,-3.48,-.80,1.41))/1.0+f01;\n    vec4 f12=sin(mat4(.44,-.06,-.79,-.46,.05,-.60,.30,.36,.35,.12,.02,.12,.40,-.26,.63,-.21)*f00+\n        mat4(-.48,.43,-.73,-.40,.11,-.01,.71,.05,-.25,.25,-.28,-.20,.32,-.02,-.84,.16)*f01+\n        mat4(.39,-.07,.90,.36,-.38,-.27,-1.86,-.39,.48,-.20,-.05,.10,-.00,-.21,.29,.63)*f02+\n        mat4(.46,-.32,.06,.09,.72,-.47,.81,.78,.90,.02,-.21,.08,-.16,.22,.32,-.13)*f03+\n        vec4(3.38,1.20,.84,1.41))/1.0+f02;\n    vec4 f13=sin(mat4(-.41,-.24,-.71,-.25,-.24,-.75,-.09,.02,-.27,-.42,.02,.03,-.01,.51,-.12,-1.24)*f00+\n        mat4(.64,.31,-1.36,.61,-.34,.11,.14,.79,.22,-.16,-.29,-.70,.02,-.37,.49,.39)*f01+\n        mat4(.79,.47,.54,-.47,-1.13,-.35,-1.03,-.22,-.67,-.26,.10,.21,-.07,-.73,-.11,.72)*f02+\n        mat4(.43,-.23,.13,.09,1.38,-.63,1.57,-.20,.39,-.14,.42,.13,-.57,-.08,-.21,.21)*f03+\n        vec4(-.34,-3.28,.43,-.52))/1.0+f03;\n    f00=sin(mat4(-.72,.23,-.89,.52,.38,.19,-.16,-.88,.26,-.37,.09,.63,.29,-.72,.30,-.95)*f10+\n        mat4(-.22,-.51,-.42,-.73,-.32,.00,-1.03,1.17,-.20,-.03,-.13,-.16,-.41,.09,.36,-.84)*f11+\n        mat4(-.21,.01,.33,.47,.05,.20,-.44,-1.04,.13,.12,-.13,.31,.01,-.34,.41,-.34)*f12+\n        mat4(-.13,-.06,-.39,-.22,.48,.25,.24,-.97,-.34,.14,.42,-.00,-.44,.05,.09,-.95)*f13+\n        vec4(.48,.87,-.87,-2.06))/1.4+f10;\n    f01=sin(mat4(-.27,.29,-.21,.15,.34,-.23,.85,-.09,-1.15,-.24,-.05,-.25,-.12,-.73,-.17,-.37)*f10+\n        mat4(-1.11,.35,-.93,-.06,-.79,-.03,-.46,-.37,.60,-.37,-.14,.45,-.03,-.21,.02,.59)*f11+\n        mat4(-.92,-.17,-.58,-.18,.58,.60,.83,-1.04,-.80,-.16,.23,-.11,.08,.16,.76,.61)*f12+\n        mat4(.29,.45,.30,.39,-.91,.66,-.35,-.35,.21,.16,-.54,-.63,1.10,-.38,.20,.15)*f13+\n        vec4(-1.72,-.14,1.92,2.08))/1.4+f11;\n    f02=sin(mat4(1.00,.66,1.30,-.51,.88,.25,-.67,.03,-.68,-.08,-.12,-.14,.46,1.15,.38,-.10)*f10+\n        mat4(.51,-.57,.41,-.09,.68,-.50,-.04,-1.01,.20,.44,-.60,.46,-.09,-.37,-1.30,.04)*f11+\n        mat4(.14,.29,-.45,-.06,-.65,.33,-.37,-.95,.71,-.07,1.00,-.60,-1.68,-.20,-.00,-.70)*f12+\n        mat4(-.31,.69,.56,.13,.95,.36,.56,.59,-.63,.52,-.30,.17,1.23,.72,.95,.75)*f13+\n        vec4(-.90,-3.26,-.44,-3.11))/1.4+f12;\n    f03=sin(mat4(.51,-.98,-.28,.16,-.22,-.17,-1.03,.22,.70,-.15,.12,.43,.78,.67,-.85,-.25)*f10+\n        mat4(.81,.60,-.89,.61,-1.03,-.33,.60,-.11,-.06,.01,-.02,-.44,.73,.69,1.02,.62)*f11+\n        mat4(-.10,.52,.80,-.65,.40,-.75,.47,1.56,.03,.05,.08,.31,-.03,.22,-1.63,.07)*f12+\n        mat4(-.18,-.07,-1.22,.48,-.01,.56,.07,.15,.24,.25,-.09,-.54,.23,-.08,.20,.36)*f13+\n        vec4(-1.11,-4.28,1.02,-.23))/1.4+f13;\n    return dot(f00,vec4(.09,.12,-.07,-.03))+dot(f01,vec4(-.04,.07,-.08,.05))+\n        dot(f02,vec4(-.01,.06,-.02,.07))+dot(f03,vec4(-.05,.07,.03,.04))-0.16;\n}\n\n// Cube Distance Estimator\nfloat sdBox(vec3 p){\n  p += vec3(0.0, 1.5, 0.0);\n  vec3 b = vec3(0.5);\n  vec3 q = abs(p)-b;\n  return length(max(q, 0.0))+min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// Infinite Plane Distance Estimators\nfloat plane      (vec3 pos){return  pos.y+2.0;}\nfloat leftplane  (vec3 pos){return  pos.x+2.0;}\nfloat rightplane (vec3 pos){return -pos.x+2.0;}\nfloat backplane  (vec3 pos){return -pos.z+2.0;}\n\n// Nearest Distance Estimator\nfloat DE(vec3 pos){\n    float DE0 = sdBox(pos);\n    float DE1 = plane(pos);\n    float DE2 = backplane(pos);\n    float DE3 = leftplane(pos);\n    float DE4 = rightplane(pos);\n    float fractal = scene(pos);\n    return min(min(fractal, DE0), min(min(DE1, DE2), min(DE3, DE4)));\n}\n\nint getmat(vec3 pos){\n    float DE0 = sdBox(pos);\n    float DE1 = plane(pos);\n    float DE2 = backplane(pos);\n    float DE3 = leftplane(pos);\n    float DE4 = rightplane(pos);\n    float fractal = scene(pos);\n    float hit = min(min(fractal, DE0), min(min(DE1, DE2), min(DE3, DE4)));\n    if(hit == fractal){return 0;}\n    if(hit == DE0){return 1;}\n    if(hit == DE1 || hit == DE2){return 2;}\n    if(hit == DE3){return 3;}\n    if(hit == DE4){return 4;}\n    return -1;\n}\n\nfloat light(vec3 pos){\n  return -pos.y+2.0;\n}\n\n// Tetrahedron Normal Function\nvec3 normal(vec3 pos){\n    float normprecision = collisiondist*0.1;\n    vec2 k = vec2(1.0, -1.0);\n    return normalize(k.xyy*DE(pos+k.xyy*normprecision)+\n                     k.yyx*DE(pos+k.yyx*normprecision)+\n                     k.yxy*DE(pos+k.yxy*normprecision)+\n                     k.xxx*DE(pos+k.xxx*normprecision));\n}\n\n// Forward and Central Differences Normal Function (Alternate Option, Slower)\n/*vec3 normal(vec3 pos){\n    const vec2 diff = vec2(collisiondist*0.1, 0.0);\n    return normalize(vec3(DE(pos+diff.xyy)-DE(pos-diff.xyy),\n                          DE(pos+diff.yxy)-DE(pos-diff.yxy),\n                          DE(pos+diff.yyx)-DE(pos-diff.yyx)));\n}*/\n\n// Path-Tracing\nvec3 raymarch(vec3 pathdir, vec3 pathorig){\n    vec3 pathpos = pathorig;\n    pathpos += pathdir*6.0;\n    vec3 surfnormal;\n    float distest, lightdistest;\n    int bounces = 0;\n    int object = 0;\n    vec3 closestpos = pathpos;\n    vec3 outCol = vec3(1.0);\n    for(int i = 0; i < maxmarches; i++){\n        // Check if the path is done\n        if(length(pathpos) > scenesize || pathpos.z < -4.0 || bounces > maxbounces){break;}\n        if(light(pathpos) < collisiondist){return outCol*vec3(1.0);}\n\n        // Find the distance to the scene\n        distest = DE(pathpos);\n        lightdistest = light(pathpos);\n\n        // Michael0884: Closest Non-Colliding Position\n        if(distest > min(collisiondist, lightdistest)){closestpos = pathpos;}\n\n        // Bounce the Path if it hits something\n        if(distest < collisiondist){\n            int object = getmat(pathpos);\n            vec4 matprops = materialproperties(pathpos, object);\n            outCol *= matprops.rgb;\n            surfnormal = normal(pathpos);\n            pathpos = closestpos;\n            pathdir = reflect(pathdir, normalize(nrand3(matprops.w, surfnormal)));\n            bounces++;\n        }\n\n        // Otherwise just keep going\n        else{pathpos += pathdir*min(distest, lightdistest);}\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Progressive Rendering\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0){oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}\n    fragColor = oldFragColor;\n\n    // Initialize RNG\n    INIT_RNG;\n\n    // Screen UV Coordinates, centered on [0.0, 0.0] and extends to 1.0 x or y, so that it looks fine no matter the aspect ratio.\n    vec2 uv = 2.0*((fragCoord.xy+nrand2(ditherradius*0.5, vec2(0.0)))-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    // Rotation Matrix\n    mat3 rotmat = mat3(\n    1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0);\n\n    // Direction of the path\n    vec3 pathdir = normalize(camerafov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Run the Path-Tracing\n    vec3 raymarched = raymarch(pathdir, camerapos);\n\n    fragColor += vec4(max(vec3(0.0), raymarched), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This contains an image export\n\n// Along the bottom at the right of this editor, there is a little image icon.\n// If you click it, ShaderToy will save a 32-Bit Floating Point OpenEXR Image.\n// A 32-Bit OpenEXR is much better for editing than saving an 8-BPC PNG Image.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    fragColor = vec4(fragColor.a != 0.0 ? fragColor.rgb / fragColor.a : fragColor.rgb, 1.0);\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}