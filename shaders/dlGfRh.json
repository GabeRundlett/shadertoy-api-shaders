{
    "Shader": {
        "info": {
            "date": "1701923337",
            "description": "Practicing intentionally timed animation with easing.",
            "flags": 0,
            "hasliked": 0,
            "id": "dlGfRh",
            "likes": 7,
            "name": "bound-heart",
            "published": 3,
            "tags": [
                "animation"
            ],
            "usePreview": 0,
            "username": "LydianLights",
            "viewed": 149
        },
        "renderpass": [
            {
                "code": "const float loopTime = 5.5;\nconst vec2 daggerPivot = vec2(0.0, -0.8);\n\nconst float tDag1 = 0.5;\nconst float tDag2 = tDag1 + 0.9;\nconst float tDag3 = tDag2 + 0.9;\n\nconst float impact1 = tDag1 + 0.6;\nconst float impact2 = tDag2 + 0.6;\nconst float impact3 = tDag3 + 0.9;\n\nconst float tScaleOut = impact3 + 1.0;\nconst float tScaleIn = tScaleOut + 0.5;\n\nfloat motion(float t, float start, float duration) {\n    return saturate(map01(t, start, start + duration));\n}\n\nfloat shake(float t, float start, float duration, float freq, float decay) {\n    float q = map01(t, start, start + duration);\n    if (q < 0.0 || q > 1.0) return 0.0;\n    return exp(-decay * q) * sin(freq * PI * q);\n}\n\nfloat sdDagger(in vec2 p) {\n    p *= 1.4;\n    const float width = 0.025;\n    const float blade = 1.25;\n    const float point = 0.4;\n    const float guard = 0.15;\n    const float handle = 0.1;\n    const float flare = 1.7;\n    \n    float d = sdBox(p + vec2(0.0, blade / 2.0 - point / 2.0 - handle), vec2(width, blade / 2.0 - point / 2.0 + handle));\n    d = min(d, sdTriangleIsosceles(p + vec2(0.0, blade), vec2(width, point)));\n    d = min(d, sdBox(p + vec2(0.0, 0.0), vec2(guard, width)));\n    d = min(d, sdTrapezoid((p + vec2(guard + width, 0.0)).yx, flare * width, width, width));\n    d = min(d, sdTrapezoid((p - vec2(guard + width, 0.0)).yx, width, flare * width, width));\n    d = min(d, sdTrapezoid((p - vec2(0.0, 2.0 * handle + width)), width, flare * width, width));\n    return d;\n}\n\nfloat dagger1(vec2 uv, float t) {\n    float m1 = motion(t, tDag1, 0.5); m1 = easeInOut(m1, 4.0);\n    float m2 = motion(t, tDag1 + 0.55, 0.1); m2 = easeInOut(m2, 4.0);\n    \n    vec3 a = vec3(-0.3, -0.4, -0.6);\n    a = mix(a, vec3(0.0, -1.1, 0.0), m1);\n    a = mix(a, vec3(0.0, -0.22, 0.0), m2);\n    \n    uv += a.xy;\n    uv = rotate(uv, a.z, daggerPivot);\n    return sdDagger(uv);\n}\n\nfloat dagger2(vec2 uv, float t) {\n    float m1 = motion(t, tDag2, 0.5); m1 = easeOut(m1, 4.0);\n    float m2 = motion(t, tDag2 + 0.55, 0.1); m2 = easeInOut(m2, 4.0);\n    \n    vec3 a = vec3(-0.7, 0.5, 0.0);\n    a = mix(a, vec3(0.2, -0.37, -0.7), m1);\n    \n    vec2 b = vec2(0.0, -0.9);\n    b = mix(b, vec2(0.0, 0.025), m2);\n    \n    uv += a.xy;\n    uv = rotate(uv, a.z, daggerPivot);\n    uv += b.xy;\n    return sdDagger(uv);\n}\n\nfloat dagger3(vec2 uv, float t) {\n    float m1 = motion(t, tDag3, 0.8); m1 = easeOut(m1, 6.0);\n    float m2 = motion(t, tDag3 + 0.85, 0.1); m2 = easeInOut(m2, 4.0);\n    \n    vec3 a = vec3(0.7, 0.5, 0.0);\n    a = mix(a, vec3(-0.2, -0.37, 0.7), m1);\n    \n    vec2 b = vec2(0.0, -0.9);\n    b = mix(b, vec2(0.0, 0.025), m2);\n    \n    uv += a.xy;\n    uv = rotate(uv, a.z, daggerPivot);\n    uv += b.xy;\n    return sdDagger(uv);\n\n}\n\nfloat drip(vec2 uv, float t, float start, vec2 pos, vec2 slideTo) {\n    const float cycleTime = 2.0;\n    const float slideTime = 0.5;\n    const float overlapTime = 0.15;\n    \n    float dripT = mod(t - start, cycleTime);\n    float m = motion(dripT, 0.0, slideTime); m = easeOut(m, 2.0);\n    \n    vec2 o = mix(pos, slideTo, m);\n    if (dripT > slideTime - overlapTime) {\n        float fallT = dripT - slideTime + overlapTime;\n        o.y += 2.0 * fallT * fallT;\n    }\n    \n    uv += o;\n    uv *= 30.0;\n    return sdEgg(uv, 1.0, -3.0);\n}\n\nfloat heart(vec2 uv0, float t) {\n    vec2 uv = uv0;\n    uv.y += 0.2;\n    uv = 2.0 * uv + vec2(0.0, 0.5);\n    uv.y *= 0.9;\n    uv = scale(uv, 0.1 * (0.2 * sin(PI * t * loopTime / 6.0) + 0.5) + 1.0, vec2(0.0, 0.5));\n    float d = sdHeart(uv);\n    \n    if (t < tScaleIn) {\n        d = smin(d, drip(uv0, t, 0.0, vec2(0.13, 0.22), vec2(0.10, 0.35)), 0.9);\n        d = smin(d, drip(uv0, t, 0.4, vec2(-0.23, 0.10), vec2(-0.15, 0.25)), 0.9);\n    }\n    \n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float px = 2.0 / iResolution.y;\n    vec2 uv0 = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    uv0.y += -0.1;\n    uv0 *= 0.7;\n    vec2 uv = uv0;\n    \n    float t = mod(iTime, loopTime);\n    \n    vec2 s1 = 0.3 * shake(t, impact1, 0.7, 20.0, 5.0) * vec2(0.0, 1.0);\n    vec2 s2 = 0.3 * shake(t, impact2, 0.7, 20.0, 5.0) * vec2(HALF_ROOT_2, HALF_ROOT_2);\n    vec2 s3 = 0.3 * shake(t, impact3, 0.7 + 0.3, 30.0, 5.0) * vec2(-HALF_ROOT_2, HALF_ROOT_2);\n    vec2 s = s1 + s2 + s3;\n    uv += s;\n    \n    if (t > tScaleOut) {\n        float tScale = t - tScaleOut;\n        uv = scale(uv0, 1.0 / (1.0 + 20.0 * tScale), vec2(0.0, -0.1));\n    }\n    if (t > tScaleIn) {\n        float tScale = t - tScaleIn;\n        float s = motion(tScale, 0.0, 0.5); s = easeOut(s, 3.0);\n        uv = scale(uv0, 1.0 / s, vec2(0.0, -0.1));\n    }\n    \n    float d = heart(uv, t);\n    if (t > tDag1 && t < tScaleIn) { d = min(d, dagger1(uv, t)); }\n    if (t > tDag2 && t < tScaleIn) { d = min(d, dagger2(uv, t)); }\n    if (t > tDag3 && t < tScaleIn) { d = min(d, dagger3(uv, t)); }\n    \n    bool invert = false;\n    if (t > impact1 - 0.01 && t < impact1 - 0.01 + 0.05) { invert = true; }\n    if (t > impact2 - 0.01 && t < impact2 - 0.01 + 0.05) { invert = true; }\n    if (t > impact3 && t < tScaleIn) { invert = true; }\n    \n    // antialias\n    d = smoothstep(0.0, 2.0 * px, d);\n    vec3 color;\n    if (invert) { color = vec3(d); }\n    else { color = vec3(1.0 - d); }\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.141592654\n#define ROOT_2 1.4142135\n#define HALF_ROOT_2 0.7071068\n\nfloat map01 (float t, float t0, float t1) {return (t - t0) / (t1 - t0); }\nfloat saturate (float x) { return min(max(x, 0.0), 1.0); }\nfloat dot2(vec2 v) { return dot(v,v); }\n\n// thx iq, as always:\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTriangleIsosceles(in vec2 p, in vec2 q) {\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdTrapezoid(in vec2 p, in float r1, in float r2, in float he) {\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdHeart(in vec2 p) {\n    p.x = abs(p.x);\n    if (p.y+p.x>1.0) return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat sdEgg(in vec2 p, in float ra, in float rb) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    float r = ra - rb;\n    return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n            (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\n\n// sdf union\nfloat smin(float a, float b, float k) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n\n// easing\nfloat easeIn(float x, float q) {\n    return pow(x, q);\n}\n\nfloat easeOut(float x, float q) {\n    return 1.0 - pow(1.0 - x, q);\n}\n\nfloat easeInOut(float x, float q) {\n    return x < 0.5\n        ? pow(2.0 * x, q) / 2.0\n        : 1.0 - pow(2.0 * (1.0 - x), q) / 2.0;\n}\n\n// transform\nvec2 rotate(vec2 v, float angle, vec2 pivot) {\n    v -= pivot;\n    v *= mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    v += pivot;\n    return v;\n}\n\nvec2 scale(vec2 v, float s, vec2 pivot) {\n    v -= pivot;\n    v *= s;\n    v += pivot;\n    return v;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}