{
    "Shader": {
        "info": {
            "date": "1696097825",
            "description": "same as CG2, but per-branch IDs.",
            "flags": 0,
            "hasliked": 0,
            "id": "DscyRX",
            "likes": 35,
            "name": "coiled grove 3",
            "published": 3,
            "tags": [
                "tree",
                "twist",
                "rope",
                "braid",
                "understepping",
                "grove",
                "futurehardware"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 392
        },
        "renderpass": [
            {
                "code": "// Optional: Set iChannel0 to the keyboard for some key controls.\n//           (I keep keyboard off so it looks nice in the iOS ShaderToy app)\n//           key controls (if enabled)\n//           1 - heat map\n//           2 - shadows\n//           3 - reflections\n//           4 - branch height variation\n\n\nconst uint  march_MaxSteps  = 250u;\nconst float march_epsilon   = 0.01;\n      float march_understep = 0.25;\nconst float normal_epsilon  = 0.05;\n\n// set in readKeyboard().\nbool do_Shadows;\nbool do_Reflections;\nbool do_HeatMap;\nbool do_BranchHeightVariety;\n\n\nfloat gMapCount = 0.0;\n\nint  gId        = 0;\nint  gIdEnd     = 0;\nbool gTrackId   = !false;\n\nvoid updateId(in vec3 q) {\n    if (gTrackId) {\n        gIdEnd = gIdEnd * 4 + 4;\n        gId *= 4;\n        gId += int(sign(q.x) * 0.5 + 0.5);\n        gId += int(sign(q.z) * 1.0 + 1.0);\n    }\n}\n\nfloat idToUnit() {\n    float f = float(gId) / float(gIdEnd - 1);\n    return f;\n}\n\nfloat gBigDir1;\nfloat gBigDir2;\nfloat gT;\n\nvoid setupScene() {\n    gT = iTime * 0.3 - 10.0;\n    gBigDir1 = 0.05 * cos(gT * 0.3);\n    gBigDir2 = 0.05 * sin(gT * 0.3 + 1.0);\n    \n    gTrackId = do_BranchHeightVariety;\n}\n\nfloat sdScene(in vec3 p) {\n\n    vec4  mp = repeated_mirrored(p.xz, 60.0);\n    float cellDist = dot(mp.zw, mp.zw);\n    \n\n    if (p.y < 0.0) {\n        // nothing below the floor\n        return 1e9;\n    }\n    \n    gMapCount += 1.0;\n    \n    float t = gT + mp.z + mp.w * 0.5;\n    \n    p.xz = mp.xy;\n\n    float d = 1e9;\n    \n    gId    = 0;\n    gIdEnd = 0;\n    \n    vec3 q = p;\n    \n    float h = 45.0 / (1.0 - .3 * dot(mp.zw, mp.zw));\n    float r =  1.0;\n    \n    if (cellDist > 3.5) {\n        return p.y;\n    }\n\n    \n    float f;\n  \n    if (cellDist < 1.0) {\n        q.xz *= rot2(q.y * gBigDir1);\n        updateId(q);\n        f = smoothstep(h * 0.1, h * 1.1, q.y);\n        q.xz = abs(q.xz) - h * 0.25 * f;\n        r *= 1.0 - 0.1 * f;\n    }\n    else {\n        t *= 0.11;\n    }\n\n    q.xz *= rot2(q.y * gBigDir2 + t * 1.5);\n    updateId(q);\n    f = smoothstep(h * 0.3, h * 0.7, q.y);\n    q.xz = abs(q.xz) - h * 0.08 * f;\n    r *= 1.0 - 0.1 * f;\n\n\n    q.xz *= rot2(q.y * 0.08 + t * 1.2);\n    updateId(q);\n    f = smoothstep(h * 0.4, h, q.y);\n    q.xz = abs(q.xz) - h * 0.04 * f;\n    r *= 1.0 - 0.75 * f;\n\n    if (do_BranchHeightVariety) {\n        f = float(gId % 13) / 12.0;\n    }\n    else {\n        f = 0.9;\n    }\n\n\n    h += -3.0 + 6.0 * f;\n    \n    r *= 1.0 + 1.5 * smoothstep(-0.5, 0.0, q.y - h * 0.98 + 3.0 * (f - 1.0));\n\n    float dCap = sdDisk(q.xz, r);\n    float dBox = sdBox(q, vec3(r - 0.2, h, r - 0.2)) - 0.1;\n    \n    float dTree = mix(dCap, dBox, smoothstep(0.0, h, q.y));\n    \n    d = min(d, dTree);\n    \n    /*\n    q = p;\n    float s = 25.0;\n    q.xz = mod(q.xz, s) - s/2.0;\n    float sr = 30.0 / (1.0 + length(p.xz));\n    q.y -= sr;\n    d = min(d, sdSphere(q, sr));*/\n    \n    if (dot(p.xz, p.xz) < 50.0) {\n        d = smin(d, p.y, 4e0);\n    }\n    \n    \n    return d;\n}\n\nvec3 gradientScene(in vec3 p) {\n    if (p.y < march_epsilon) {\n        // cheat for floor\n        return vY;\n    }\n    float d = sdScene(p);\n    return vec3(\n        sdScene(p + vX * normal_epsilon) - d,\n        sdScene(p + vY * normal_epsilon) - d,\n        sdScene(p + vZ * normal_epsilon) - d\n    );\n}\n\nvec3 normalScene(in vec3 p) {\n    return normalize(gradientScene(p));\n}\n\nfloat rayVsScene(in vec3 ro, in vec3 rd, out bool outOfSteps) {\n\n    // analytic ground plane in addition to the raymarched one.\n    float pt = rayVsPlane(ro, rd, vY, 0.0);\n    \n    outOfSteps = false;\n\n    float t = 0.0;\n\n    for (uint n = 0u; n < march_MaxSteps; ++n) {\n        vec3  p = ro + t * rd;\n        float d = sdScene(p);\n        if (d < march_epsilon) {\n            return min(pt, t);\n        }\n        if (dot(p.xz, p.xz) > 60000.0) {\n            return pt;\n        }\n        \n        t += d * march_understep;\n    }\n   \n    outOfSteps = true;\n    return pt;\n}\n\nconst vec3 lightDir = normalize(vec3(1.0, 1.5, 1.9));\n\nvec3 sky(in vec3 ro, in vec3 rd) {\n    vec3 c = v1 * (1.0 - (0.2 + 0.8 * saturate(rd.y)));\n    c.r *= 0.2;\n    c.g *= 0.4;\n    \n    float d = dot(rd, lightDir) * 0.5 + 0.5;\n    \n    c = mix(c, v1, sqr(sqr(sqr(d))) * 0.85);\n    \n    float dddd = d * d;\n    dddd *= dddd;\n    c *= mix(sin(dddd * dddd * 30.0 + gT) * 0.5 + 0.5, 1.0, 1.0 - dddd * 0.1);\n    \n    float a = atan(rd.z, rd.x);\n    \n    c = mix(c, v1 * (1.0 - sqrt(d)), 0.3 * smoothstep(0.06 + (1.0 - d) * 0.02 * cos(a * 23.0), 0.0, abs(rd.y)));\n    return c;\n}\n\nvec3 calcAlbedo(in vec3 p) {\n    gTrackId = true;\n    sdScene(p);\n    \n    bool outerTree = dot(p.xz, p.xz) > 1200.0;\n    \n    vec3 pop = outerTree ? vec3(0.4, 0.0, 0.5) : vX;\n    vec3 a;\n    /*\n    float f = idToUnit();\n    albedo.r = sin(f * 1211.23);\n    albedo.g = sin(f * 1315.43);\n    albedo.b = sin(f * 1416.63);\n    albedo = mix(albedo * 0.7, v1, 0.4);\n    */\n    float noise  = whangHashNoise(0u, 0u, uint(gId));\n    float bNoise = step(0.3, noise);\n    a = mix(pop, v1, bNoise);\n    a = mix(a, 0.1 * mix(pop, v1, 0.5), smoothstep(40.0, 20.0, p.y));\n    \n    if (outerTree) {\n        a *= 0.3;\n    }\n    \n    a = mix(a, v1 * 1.0, smoothstep( 2.0, -3.0, p.y));\n    \n    return a;\n}\n\nvec3 calcDiffuse(in vec3 p, in vec3 rd, in vec3 n, in vec3 albedo) {\n    vec3 c = albedo * (saturate(dot(n, lightDir)));\n    \n    float redness = albedo.r - albedo.g;\n    c.r += 1.0 * redness * smoothstep(1.0, 10.0, p.y) * 0.9 * (sqr((sqr(saturate(dot(n, -rd))))));\n\n    return c;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    bool outOfSteps;\n    float t = rayVsScene(ro, rd, outOfSteps);\n    if (t > 1e8) {\n        return sky(ro, rd);\n    }\n    \n    vec3 p;\n    vec3 n;\n    \n    p = ro + t * rd;\n    n = normalScene(p);\n    \n    vec3 a = calcAlbedo(p);\n    vec3 c = calcDiffuse(p, rd, n, a);\n\n    // shadow and one reflection bounce\n    ro = p + n * march_epsilon * 1.5;\n    \n\n    \n    if (do_Shadows) {\n        // shadow\n        \n        // use less precision for shadows\n        march_understep = mix(march_understep, 1.0, 0.5);\n        \n        float ts = rayVsScene(ro, lightDir, outOfSteps);\n        p = ro + ts * lightDir;\n\n        if (ts < 1e9 || outOfSteps) {\n            c *= 0.4;\n        }\n    }\n\n    if (do_Reflections) {\n        // reflect\n        \n        // use even less precision for shadows\n        march_understep = mix(march_understep, 1.0, 0.5);\n        \n        const float reflectMin = 0.07;\n        const float reflectMax = 0.9;\n        float fres = mix(reflectMin, reflectMax, smoothstep(0.9, 0.1, abs(dot(rd, n))));\n\n        vec3 c2;\n        rd = reflect(rd, n);\n        \n        if (t > 170.0) {\n            c2 = sky(ro, rd);\n        }\n        else {\n            t = rayVsScene(ro, rd, outOfSteps);\n            if (t > 1e8) {\n                c2 = sky(ro, rd);\n            }\n            else {\n                p = ro + t * rd;\n                n = normalScene(p);\n                a = calcAlbedo(p);\n                c2 = calcDiffuse(p, rd, n, a);\n            }\n        }\n\n\n        c = mix(c, c2, fres);\n    }\n    \n    return c;\n}\n\nvec3 getRayDir(in vec2 xy, in vec3 ro, in vec3 lookTo, in float fov) {\n    vec3 camFw = normalize(lookTo - ro);\n    vec3 camRt = normalize(cross(camFw, vY));\n    vec3 camUp = cross(camRt, camFw);\n    \n    vec3 rd;\n    rd = camFw + fov * (camRt * xy.x + camUp * xy.y);\n    rd = normalize(rd);\n    \n    return rd;\n}\n\nbool keyboardNumberToggle(int number) {\n    const int k0_regular = 48;\n    const int k0_numPad  = 96;\n    \n    bool regular = bool(texelFetch(iChannel0, ivec2(k0_regular + number, 2), 0).x);\n    bool numPad  = bool(texelFetch(iChannel0, ivec2(k0_numPad  + number, 2), 0).x);\n    \n    return regular ^^ numPad;\n}\n\nvoid readKeyboard() {\n    do_HeatMap             =  keyboardNumberToggle(1);\n    do_Shadows             = !keyboardNumberToggle(2);\n    do_Reflections         = !keyboardNumberToggle(3);\n    do_BranchHeightVariety = !keyboardNumberToggle(4);\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    readKeyboard();\n    \n    const float zoom = 0.8;\n    \n    vec2 xy = (XY * 2.0 - RES) / MINRES / zoom;\n    \n    const float heatMapSize = 0.35;\n    bool isHeatMap = do_HeatMap && XY.x < RES.x * heatMapSize && XY.y < RES.y * heatMapSize;\n    if (isHeatMap) {\n        xy = (XY * 2.0 - RES * heatMapSize) / MINRES / heatMapSize / zoom;\n    }\n    \n    setupScene();\n    \n    vec2 M = iMouse.xy;\n    if (length(M) < 100.0) {\n        M = RES/2.0;\n        M.x += gT * 21.0;\n        M.y *= 1.5 + 0.3 * sin(iTime * 0.05);\n    }\n    \n    vec3 ro = vec3(0.0, 40.0 - 50.0 * (M.y / RES.y - 0.5), -80.0);\n    ro.xz *= rot2(3.141 + (M.x / RES.x - 0.5) * -7.0);\n    vec3 lt = vY * 26.0;\n    vec3 rd = getRayDir(xy, ro, lt, 0.3);\n    \n    \n    RGBA.rgb = render(ro, rd);\n    \n    if (isHeatMap) {\n        float h = saturate(gMapCount / 500.0);\n        vec3 cool = vec3(0.0, 0.0, 0.7);\n        vec3 warm = vec3(1.0, 0.9, 0.0);\n        RGBA.rgb = mix(cool, warm, h);\n    }\n    \n    // gamma\n    RGBA.rgb = pow(RGBA.rgb, vec3(1.0/2.2));\n    \n    RGBA.a   = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\nconst vec3 vX = vec3(1.0, 0.0, 0.0);\nconst vec3 vY = vX.yxy;\nconst vec3 vZ = vX.yyx;\nconst vec3 v0 = vX.yyy;\nconst vec3 v1 = vX.xxx;\n\nmat2 rot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nfloat saturate(float v) { return clamp(v, 0.0, 1.0); }\nvec2  saturate(vec2  v) { return clamp(v, 0.0, 1.0); }\nvec3  saturate(vec3  v) { return clamp(v, 0.0, 1.0); }\n\nfloat sqr(float a) {\n    return a * a;\n}\n\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdDisk(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// iq\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a-b), 0.) / k;\n    return min(a, b) - h*h*h*k*1./6.;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/sdfrepetition/\n// fast space repetition by mirroring every other instance\n// returns (vec2 space, vec2 id)\nvec4 repeated_mirrored( vec2 p, float s )\n{\n    vec2 id = round(p/s);\n    vec2  r = p - s*id;\n    vec2  m = vec2( ((int(id.x)&1)==0) ? r.x : -r.x,\n                   ((int(id.y)&1)==0) ? r.y : -r.y );\n    return vec4(m, id);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nfloat rayVsPlane(in vec3 ro, in vec3 rd, in vec3 n, in float d) {\n    float t = -(dot(ro, n) + d) / (dot(rd, n));\n    if (t < 0.0) {\n        t = 1e9;\n    }\n    return t;\n}\n\n\n//--------------------------------------------------------------------------------\n\n// SebH\n// https://www.shadertoy.com/view/ldjczd\nfloat whangHashNoise(uint u, uint v, uint s)\n{\n    uint seed = (u*1664525u + v) + s;\n    \n    seed  = (seed ^ 61u) ^(seed >> 16u);\n    seed *= 9u;\n    seed  = seed ^(seed >> 4u);\n    seed *= uint(0x27d4eb2d);\n    seed  = seed ^(seed >> 15u);\n    \n    float value = float(seed) / (4294967296.0);\n    return value;\n}\n\n//--------------------------------------------------------------------------------\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}