{
    "Shader": {
        "info": {
            "date": "1585350908",
            "description": "just a laser grid",
            "flags": 0,
            "hasliked": 0,
            "id": "tsXcRX",
            "likes": 2,
            "name": "lasergrid",
            "published": 3,
            "tags": [
                "raymarching",
                "lasers"
            ],
            "usePreview": 0,
            "username": "benhardy",
            "viewed": 368
        },
        "renderpass": [
            {
                "code": "#define MAX_DIST 100.0\n#define MAX_STEPS 100\n#define EPSILON 0.001\n#define STEP_RATIO 0.5\n\n\n#define NORMAL_DELTA 0.001\nvec2 measure(vec3 point) {\n    vec3 v = vec3(mod(point.x+5.0, 10.0)-5.0, point.y, mod(point.z+5.0, 10.0)-5.0);\n    float h = length(v.xy) - 0.1;\n    float j = length(v.zy) - 0.1;\n    float m = blend(h, j, 0.4);\n    float n = length(point.xz) - 0.1;\n    float r = blend(m, n, 0.4);\n    return vec2(r, 1.0);\n}\n\nvec3 calc_surface_normal(vec3 hit) {\n\treturn normalize(vec3(\n            measure(hit+vec3(NORMAL_DELTA, 0.0, 0.0)).x - measure(hit-vec3(NORMAL_DELTA, 0.0, 0.0)).x,\n            measure(hit+vec3(0.0, NORMAL_DELTA, 0.0)).x - measure(hit-vec3(0.0, NORMAL_DELTA, 0.0)).x,\n            measure(hit+vec3(0.0, 0.0, NORMAL_DELTA)).x - measure(hit-vec3(0.0, 0.0, NORMAL_DELTA)).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(sin(iTime*0.11)*10.0+15.0,\n                    sin(iTime*0.05)*10.0+14.0,\n                    cos(iTime*0.13)*10.0-15.0);\n    vec3 look_at = vec3(0,0,0);\n    vec3 up = Y;\n    vec3 ray = calculateRay(iResolution, fragCoord, eye, look_at, up);\n    \n\n    vec3 where = eye;\n    float total_dist = 0.0;\n    vec2 current;\n    int who = 0;\n    float current_dist = 0.0;\n    float best_dist = MAX_DIST;\n    for(int steps =0;steps < MAX_STEPS; steps++) {\n        current = measure(where);\n        current_dist = current.x;\n        if (current_dist < EPSILON) {\n            who = int(current.y);\n            break;\n        }\n        if (current_dist < best_dist) {\n            best_dist = current_dist;\n        }\n        total_dist += current_dist * STEP_RATIO;\n        if (total_dist > MAX_DIST) {\n            break;\n        }\n        where = eye + total_dist * ray;\n    }\n\n    vec3 fog_color = vec3(0,0,0);\n    if (who == 0){\n        float glow = clamp(1.0 - best_dist, 0.0, 1.0);\n        vec3 pink = vec3(1.0, 0.6, 0.5);\n        fragColor = vec4(glow * pink, 1.0);\n        return;\n    }\n\tvec3 hit = where;\n    vec4 the_paint = vec4(1,1,1,1); //paint(current, where);\n    vec3 to_light = normalize(vec3(-10,5,-1));\n    //float shadow = calcSoftshadow(hit, to_light, 0.0, total_dist);\n    vec3 surface_normal = calc_surface_normal(hit);\n    float dotty = dot(to_light, surface_normal);\n    float light_amount = max(0.0, dotty);\n    float light_fade = 1.0;\n    float ambient = the_paint.w;\n    float lighting = ambient + (1.0-ambient); // \n   //     * (shadow*0.5 * (1.0 + light_amount * light_fade));\n\n\tvec3 coloring = light_fade *(the_paint.xyz * lighting)\n        + fog_color * (1.0-light_fade);\n    vec3 reflected = surface_normal * 2.0 * dotty - to_light;\n    vec3 toEye = normalize(-ray);\n\tfloat specular = pow(max(0.0, dot(toEye, reflected)), 32.0);\n//\tcoloring += shadow*vec3(specular, specular, specular);\n    fragColor = vec4(coloring,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_FLOAT 3.402823466e+38\n#define MIN_FLOAT 1.175494351e-38\n#define MAX_DOUBLE 1.7976931348623158e+308\n#define MIN_DOUBLE 2.2250738585072014e-308\n\n// Indicate to 'repeat' function that we don't wish to\n#define NEVER 1000000.0\n\n/**\n * Common vectors\n */\nconst vec3 ORIGIN = vec3(0,0,0);\nconst vec3 X = vec3(1,0,0);\nconst vec3 Y = vec3(0,1,0);\nconst vec3 Z = vec3(0,0,1);\n\n/**\n * Common color values\n */\nconst vec3 BLACK = vec3(0,0,0);\nconst vec3 WHITE = vec3(1,1,1);\nconst vec3 RED   = vec3(1,0,0);\nconst vec3 GREEN = vec3(0,1,0);\nconst vec3 BLUE  = vec3(0,0,1);\nconst vec3 YELLOW  = vec3(1,1,0);\nconst vec3 CYAN    = vec3(0,1,1);\nconst vec3 MAGENTA = vec3(1,0,1);\n\n/**\n * For the given 2d screen position, figure out the ray vector\n */\nvec3 calculateRay(vec3 res, vec2 screenPos, \n                  vec3 eye, vec3 look_at, vec3 up) {\n\tvec2 screen_pos = screenPos.xy / res.xy;\n    float aspect = res.y / res.x;\n    screen_pos -= 0.5;\n    screen_pos.y *= aspect;\n    vec3 look_center = normalize(look_at - eye);\n    vec3 look_right = cross(up, look_center);\n    vec3 look_up = cross(look_center, look_right);\n        \n\tvec3 newRay = normalize(look_center + screen_pos.x * look_right + screen_pos.y * look_up);\n    return newRay;\n}\n\n\n\n/*\n * Signed distance functions for object primitives\n */\nfloat sphere(vec3 where, vec3 center, float radius) {\n  return length(where - center) - radius;\n}\n\n//float torus_around_x(vec3 where, float major, float minor) {\n    \n\nfloat round_box( vec3 where, vec3 sizes, float roundness ) {\n\treturn length(max(abs(where)-sizes,0.0))-roundness;\n}\n\nvec3 repeat(vec3 where, vec3 repetition) {\n\n    return mod(where, repetition);\n}\nvec3 repeat_x(vec3 where, float r) {\n\n    where.x = mod(where.x, r);\n    return where;\n}\n\n\n#define PI 3.141592653589793\nvec3 radial_symmetry_xz(vec3 where, float count) {\n    float ang = mod(atan(where.x, where.z) + PI, 2.0 *PI /count);\n    float r = length(where.xz);\n    return vec3(r *cos(ang), where.y, r * sin(ang));\n}\n\n// polynomial smooth min (k = 0.1);\nfloat blend( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\n\nint hash(int x) {\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = (x >> 16) ^ x;\n    return x;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}