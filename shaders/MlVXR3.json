{
    "Shader": {
        "info": {
            "date": "1485302187",
            "description": "Static supernova",
            "flags": 56,
            "hasliked": 0,
            "id": "MlVXR3",
            "likes": 5,
            "name": "Supernova 2017PM",
            "published": 3,
            "tags": [
                "supernova"
            ],
            "usePreview": 0,
            "username": "Antrague",
            "viewed": 901
        },
        "renderpass": [
            {
                "code": "//-------------------------------------------------------------------------------------\n// Based on \"Supernova remnant\" by Duke  https://www.shadertoy.com/view/MdKXzc\n//\"Dusty nebula 4\" (https://www.shadertoy.com/view/MsVXWW) \n// and \"Protoplanetary disk\" (https://www.shadertoy.com/view/MdtGRl) \n// otaviogood's \"Alien Beacon\" (https://www.shadertoy.com/view/ld2SzK)\n// and Shane's \"Cheap Cloud Flythrough\" (https://www.shadertoy.com/view/Xsc3R4) shaders\n// Some ideas came from other shaders from this wonderful site\n// Press 1-2-3 to zoom in and zoom out.\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Sound by iq: https://www.shadertoy.com/view/llj3Rz\n//-------------------------------------------------------------------------------------\n\n#define DITHERING\n#define BACKGROUND\n#define TONEMAPPING\n#define pi 3.14159265359\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(-p.y, p.x)\n\n// iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+ 1.5)/256.0, -100.0 ).yx;\n\treturn 1. - 0.82*mix( rg.x, rg.y, f.z );\n}\n\n\nfloat fbm(vec3 p)\n{\n   return noise(p*.062)*.5 + noise(p*.125)*.25 + noise(p*.25)*.125 + noise(p*.4)*.2;\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n\nfloat Disk( vec3 p, vec3 t )\n{\n    vec2 q = vec2(length2(p.xy)-t.x,p.z*0.5);\n    return max(length8(q)-t.y, abs(p.z) - t.z);\n}\n\n//==============================================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 1.5;\t// size of perpendicular vector\nfloat normalizer = 1.1 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.6;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.735;\n    }\n    return n;\n}\n\nfloat NebulaNoise(vec3 p)\n{\n    float final = Disk(p.xzy,vec3(2.0,1.8,1.25));\n    final += fbm(p*30.);\n    final += SpiralNoiseC(p.zxy*0.5123+100.0)*3.0;\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\tR(p.yz, iMouse.x*0.008*pi+iTime*0.2);\n\n\tfloat NebNoise = abs(NebulaNoise(p/0.5)*0.5);\n    \n\treturn NebNoise+0.07;\n}\n//--------------------------------------------------------------\n\n// assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( vec3(2.4,0.2,0.8), vec3(0.4,0.15,0.1), density );\n\t\n\t// color added to the media\n\tvec3 colCenter = 2.*vec3(0.53,2.04,2.55);\n\tvec3 colEdge = 1.8*vec3(0.48,0.53,0.5);\n\tresult *= mix( colCenter, colEdge, min( (radius+.05)/.9, 1.6 ) );\n\t\n\treturn result;\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 10.;\n\tfloat delta = b*b - c;\n\tif( delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\n// Applies the filmic curve from John Hable's presentation\n// More details at : http://filmicgames.com/archives/75\nvec3 ToneMapFilmicALU(vec3 _color)\n{\n\t_color = max(vec3(0), _color - vec3(0.004));\n\t_color = (_color * (6.5*_color + vec3(0.2))) / (_color * (5.5 * _color + vec3(2.7)) + vec3(0.6));\n\treturn _color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    const float KEY_1 = 51.5/256.0;\n\t\n    float key = 0.0;\n    key += 0.8*texture(iChannel1, vec2(KEY_1,0.25)).x;\n\n\n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n\tvec3 ro = vec3(0., 0., -6.+key*1.6);\n    \n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0., td=0., w=0.5;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=1., t=0.5;\n    \n    const float h = 0.11;\n    R(rd.yz, -iMouse.y*h);\n    R(rd.xz,  iMouse.x*h);\n    R(ro.yz, -iMouse.y*h);\n    R(ro.xz,  iMouse.x*h);\n   \n\tvec4 sum = vec4(0.0);\n   \n    float min_dist=0.0, max_dist=0.0;\n\n    if(RaySphereIntersect(ro, rd, min_dist, max_dist))\n    {\n       \n\tt = min_dist*step(t,min_dist);\n   \n\t// raymarch loop\n\tfor (int i=0; i<64; i++) \n\t{\n\t \n\t\tvec3 pos = ro + t*rd;\n  \n\t\t// Loop break conditions.\n\t    if(td>0.9 || d<0.1*t || t>10. || sum.a > 0.99 || t>max_dist) break;\n        \n        // evaluate distance function\n        float d = map(pos);\n\t\t       \t\t        \n        // point light calculations\n        vec3 ldst = vec3(0.0)-pos;\n        float lDist = max(length(ldst), 0.001);\n\n        // the color of light \n        vec3 lightColor=vec3(0.2,0.7,0.9);\n        \n        sum.rgb+=(vec3(0.67,0.95,1.00)/(lDist*lDist*4.)/35.); // star itself\n        sum.rgb+=(lightColor/exp(lDist*lDist*lDist*.06)/25.); // bloom\n        \n\t\tif (d<h) \n\t\t{\n\t\t\t// compute local density \n\t\t\tld = h - d;\n            \n            // compute weighting factor \n\t\t\tw = (1.2 - td) * ld;\n     \n\t\t\t// accumulate density\n\t\t\ttd += w + 1./200.;\n\t\t\n\t\t\tvec4 col = vec4( computeColor(td,lDist), td );\n            \n            // emission\n            sum += sum.a * vec4(sum.rgb, 0.0) * 0.2;\t\n            \n\t\t\t// uniform scale density\n\t\t\tcol.a *= 0.25;\n\t\t\t// colour by alpha\n\t\t\tcol.rgb *= col.a;\n\t\t\t// alpha blend in contribution\n\t\t\tsum = sum + col*(1.0 - sum.a);  \n       \n\t\t}\n      \n\t\ttd += 1./70.;\n\n        #ifdef DITHERING\n        //idea from https://www.shadertoy.com/view/lsj3Dw\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        uv.y*=120.;\n        uv.x*=280.;\n         d=abs(d)*(.8+0.08*texture(iChannel2,vec2(uv.y,-uv.x+0.5*sin(4.*iTime+uv.y*4.0))).r);\n        #endif \n\t\t\n        // trying to optimize step size near the camera and near the light source\n        t += max(d * 0.1 * max(min(length(ldst),length(ro)),1.0), 0.01);\n    }  \n    \n    // simple scattering\n\tsum *= 1. / exp( ld * 0.2 ) * 0.7;\n        \n   \tsum = clamp( sum, 0.0, 1.0 );\n   \n    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*sum.xyz);\n        \n    \n\t}\n\n    #ifdef BACKGROUND\n    // stars background\n    if (td<.10)\n    {\n        vec3 stars = vec3(noise(rd*500.0)*0.5+0.5);\n        vec3 starbg = vec3(0.0);\n        starbg = mix(starbg, vec3(0.2,1.2,1.7), smoothstep(0.99, 1.0, stars)*clamp(dot(vec3(0.0),rd)+0.75,0.0,1.0));\n        starbg = clamp(starbg, 0.0, 1.0);\n        sum.xyz += starbg; \n    }\n\t#endif\n\n   \n  #ifdef TONEMAPPING\n    fragColor = vec4(ToneMapFilmicALU(sum.xyz*2.2),1.0);\n\t#else\n    fragColor = vec4(sum.xyz,1.0);\n\t#endif\n    \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Bell-shaped curve with maximum value 1.0\nfloat bell(float x, float center, float stretch) {\n    return exp(-pow((x - center) / stretch, 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //Center the origin\n    uv -= 0.2; \n    \n    //Fix aspect ratio\n    float aspect_ratio = iResolution.x / iResolution.y;\n    uv.x *= aspect_ratio;\n    \n    //Distance from center\n    float dist_center = length(uv);\n    \n    // Iterate over the color components\n    for (int i = 0; i < 6; i++) {\n        //Each\n        float phase_shift = float(i) * 6.13;\n        \n    \t//wrap the time value to a range [0.0, 1.5]\n    \t//this is slightly greater than size of the window\n    \t//so it makes the animation smoother. This will be\n    \t//used for the radius of animated pulses\n    \tfloat pulse_radius = mod(iTime + phase_shift, 1.5);\n    \n    \t//how much to stretch the pulse (which takes the form of a bell-shaped\n    \t//curve with respect to distance from center.\n    \tfloat pulse_stretch = 0.2;\n     \n        //Make a bell curve pulsing outwards from the center of the screen.\n        fragColor[i] = bell(dist_center, pulse_radius, pulse_stretch);\n    }\n    fragColor.a = 0.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2 mainSound( in int samp, float time )\n{\n\tvec2 y = vec2( 0.0 );\n\t\n    float d = 1.0;\n    for( int j=0; j<4; j++ )\n    {\n\n        float base = 112.0 + 512.0*sin( time * 0.25 );\n\n        for(int i=0; i<256; i++ )\n        {\n            float h = float(i)/256.0;\n\n            vec2 ti = texture( iChannel0, vec2(h,time*0.1)).xy;\n\n            float a = ti.x*ti.x/(0.1+h*h);\n\n            y += d * a * cos( vec2(3.0*h,0.0) + 2.2831*time*base*h + ti.y*100.0 );\n        }\n        time += 0.15;\n        d *= 0.9;\n    }    \n\n    y /= 256.0;\n    y /= 2.0;\n    \n    y = sin(1.57*y);\n    \n    return y;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    }
                ],
                "name": "Sound",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 38
                    }
                ],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}