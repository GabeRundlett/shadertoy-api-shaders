{
    "Shader": {
        "info": {
            "date": "1696933937",
            "description": "A nice way to map the entire Euclidean plane to the unit circle. Useful for filing an infinite amount of data.\n\nControls: up/down,mouse,m,r,s,t,x. See code for details.",
            "flags": 48,
            "hasliked": 0,
            "id": "msS3DD",
            "likes": 6,
            "name": "Infinite Rolodex",
            "published": 3,
            "tags": [
                "mapping",
                "stereographic",
                "gnomonic",
                "rolodex"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 218
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////\n//\n// Infinite Rolodex. mla, 2023\n//\n// Map unit circle to plane with mapping z -> z/(1-|z|Â²),\n// geometrically this is like doing a stereographic projection\n// from the circle to a hemisphere, then a gnomonic\n// projection from the hemisphere to the entire plane.\n//\n// The plane is divided into cells, each containing mysterious\n// images & writing, every one different, at least up to the\n// limitations of the hash function.\n//\n// <mouse> to scroll\n// <up/down> to zoom in and out\n// 'm': mouse selection\n// 'r': y-rotation\n// 's': scroll text\n// 't': use tan map\n// 'x': transform\n//\n////////////////////////////////////////////////////////////////\n\nint textchar(ivec2 cindex, ivec2 ix) {\n  uint h = ihash(ivec4(cindex,ix));\n  return int(256.0*hfloat(h));\n}\n\nfloat text(vec2 pos, ivec2 ix) {\n  if (key(CHAR_S)) pos.y += 0.25*iTime;\n  vec4 metrics = vec4(0.25,0.75,0,1);\n  float cwidth = metrics.y-metrics.x;\n  float cheight = metrics.w-metrics.z;\n  float ar = cheight/cwidth;\n  int nrows = 10; \n  int ncols = int(float(nrows)*ar);\n  // Grid structure\n  vec2 cellsize = 1.0/vec2(ncols,nrows);\n  ivec2 cellindex = ivec2(pos/cellsize);\n  cellindex.y = nrows-cellindex.y-1; // Reverse order of rows\n  int c = textchar(cellindex,ix);\n  if (c < 0) return 0.0;\n  vec2 p = mod(pos,cellsize)/cellsize.y;\n  vec2 dx = dFdx(pos), dy = dFdy(pos);\n  // Draw the character\n  int charpos = int(p.x/cwidth);\n  float charstart = cwidth*float(charpos); // character start\n  vec2 uv = char(vec2(p.x-charstart+metrics.x,p.y),c);\n  return textureGrad(iChannel1,uv,dx/16.0,dy/16.0).x;  \n}\n\nvec3 pcolor(vec2 pos, vec2 mpos) {\n  vec3 col = vec3(0,0,0.1);\n  float scale = exp(0.1*(float(keycount(KEY_DOWN)-keycount(KEY_UP))));\n  if (!key(CHAR_X)) {\n    if (length(pos) > 1.0) return col;\n    if (!key(CHAR_T)) {\n      // Inverse stereographic followed by gnomonic projection.\n      pos /= 1.0-dot(pos,pos);\n    } else {\n      float t = tan(0.5*PI*length(pos));\n      pos *= t/length(pos);\n    }\n    if (dot(mpos,mpos) < 1.0) {\n      mpos /= 1.0-dot(mpos,mpos);\n    }\n  }\n  pos *= scale;\n  if (!key(CHAR_M)) pos -= mpos;\n  //pos *= scale;\n  if (!key(CHAR_R) && iMouse.z <= 0.0) pos.y += 10.0*iTime;\n  ivec2 ix = ivec2(floor(pos));\n  pos = fract(pos);\n  col = texture(iChannel0,pos).xyz;\n  col *= 1.2;\n  col = pow(col,vec3(2.2));\n  col *= 0.5+0.5*h2rgb(rand(ix));\n  col = mix(col,vec3(0),text(pos,ix));\n  float d = min(pos.x,pos.y);\n  float px = fwidth(pos.x);\n  float py = fwidth(pos.y);\n  pos = fract(pos);\n  pos = min(pos,1.0-pos);\n  col *= 0.25+0.75*smoothstep(0.0,0.05,min(pos.x,pos.y));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 mpos = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  float AA = 2.0;\n  vec3 aacol = vec3(0);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 pos = ((2.0*(fragCoord+vec2(i,j)/AA))-iResolution.xy)/iResolution.y;\n      aacol += pcolor(pos,mpos);\n    }\n  }\n  aacol /= AA*AA;\n  aacol = pow(aacol,vec3(0.4545));\n  fragColor = vec4(aacol,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float PI = 3.141592654;\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nuint ihash(ivec4 t) {\n  uint h = 0u;\n  // Need a better 4->1 hash\n  h = ihash(h^uint(t.x));\n  h = ihash(h^uint(t.y));\n  h = ihash(h^uint(t.z));\n  h = ihash(h^uint(t.w));\n  return h;\n}\n\nfloat hfloat(uint h) {\n  return float(h)/exp2(32.0);\n}\n\nfloat rand(ivec2 ix) {\n uint h = ihash(uint(ix.x));\n h = ihash(h^uint(ix.y));\n return hfloat(h);\n}\n\n// https://www.shadertoy.com/view/4sBfRd\nvec2 char(vec2 p, int c) {\n  // Compute uv for font texture.\n  // p is [0,1] coordinates in square character\n  return (p + vec2(c,15-c/16))/16.0;\n}\n\nconst int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\nconst int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}