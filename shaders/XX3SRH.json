{
    "Shader": {
        "info": {
            "date": "1718565505",
            "description": "add slider",
            "flags": 32,
            "hasliked": 0,
            "id": "XX3SRH",
            "likes": 1,
            "name": "240617 breathing",
            "published": 3,
            "tags": [
                "raymarchingsdf"
            ],
            "usePreview": 0,
            "username": "cinmin",
            "viewed": 107
        },
        "renderpass": [
            {
                "code": "\n#ifdef GL_ES\nprecision mediump float;\n#endif\n#define PI 3.141592654\n#define TWOPI 6.283185308 \n\n\nvec3 normalMap(vec3 p, vec3 n);\nfloat calcAO( in vec3 pos, in vec3 nor );\nfloat noise_3(in vec3 p); //亂數範圍 [0,1]\nvec3 FlameColour(float f);\n\n// read UI\nfloat readFloat(float address) { return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; }\nvec4 readVec4(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\n\n\nvec2 SphereMap( vec3 ray){\t\t//ray mapping to UV\n   vec2 st;\n   ray=normalize(ray);\n   float radius=length(ray);\n   st.y = acos(ray.y/radius) / PI;\n   if (ray.z >= 0.0) st.x = acos(ray.x/(radius * sin(PI*(st.y)))) / TWOPI;\n   else st.x = 1.0 - acos(ray.x/(radius * sin(PI*(st.y)))) / TWOPI;\n   return st;\n}\n\nvec4 warpcolor(in vec2 uv, float t){   //Normalized uv[0~1]\n    float strength=mix(0.1,0.7,readFloat(3.));\n            \n\t\tvec3 col = vec3(0);\n\t\t//pos coordinates (from -1 to 1)\n\t\tvec2 pos = uv*2.0-1.0;\n            \n\t\tfor(int i = 1; i < 6; i++){ \n\t\tpos.x += strength * sin(2.0*t+float(i)*1.5 * pos.y)+t*0.5;\n\t\tpos.y += strength * cos(2.0*t+float(i)*1.5 * pos.x);}\n\n\t\t//Time varying pixel colour\n\t\tcol += 0.5 + 0.5*cos(t+pos.xyx+vec3(0,2,4));\n\t\t//Gamma\n        float gamma=mix(0.1,0.9,readFloat(4.));      \n\t\tcol = pow(col, vec3(gamma));\n\t\treturn vec4(col,1.0) ;\n}\n\nvec3 warpSky(vec3 e){\n    vec2 ST = SphereMap(e);\n    vec4 color =warpcolor(ST, iTime*0.1);\n    return color.xyz;\n}\n\n\nvec3 phong(vec3 p, vec3 n, vec3 v){\n    vec3 final = vec3(0.0);\n    vec3 ambient_color=vec3(0.351,0.900,0.955);\n\n    vec2 mouse=(iMouse.xy/iResolution.xy)*2.0-1.0;\n    {\n    vec3 light_pos = vec3(mouse.x,mouse.y,2.0);\n    vec3 light_color = vec3(0.245,0.194,0.241);\n    vec3 light_vector =normalize(light_pos-p);\n    vec3 reflection = normalize(reflect(-light_pos,n));  \n    float ka=0.620, ks=1.5, kd= 2.;//各參數權重\n    float shineness=5.160;\n    \n    vec3 diffuse, specular, ambient;\n    ambient = ka*ambient_color;\n    diffuse= kd*dot(light_vector,n)*light_color;\n    specular= ks*pow(max(dot(reflection,v),0.),shineness)*light_color;\n    final=ambient_color+diffuse+specular;\n    }\n    {\n  \n    vec3 light_pos = vec3(-5.,15.,2.0);\n    vec3 light_color = vec3(0.920,0.266,0.258);\n    vec3 light_vector =normalize(light_pos-p);\n    vec3 reflection = normalize(reflect(-light_pos,n));  \n    float ka=0.320, ks=0.8, kd= 0.8;//各參數權重\n    float shineness=2.568;\n    \n    vec3 diffuse, specular, ambient;\n    ambient = ka*ambient_color;\n    diffuse= kd*dot(light_vector,n)*light_color;\n    specular= ks*pow(max(dot(reflection,v),0.),shineness)*light_color;\n    final+=(diffuse+specular)*0.6;\n    }\n    // final+=ambient_color;\n    vec3 refl = reflect(-v,n);\n    vec3 refl_clr=warpSky(refl);\n    float F =1.0-dot(n,v);\n    final = mix(final,refl_clr,F);\n    return final;\n}\n\n//=== distance functions ===\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n\t//p += 0.015 * (noise_3(p*60.0)*2.0-1.0);\n\treturn length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat map(in vec3 p)\n{\nfloat bump=-0.288 * (noise_3(p*3.0)*2.0-1.0);\nvec3 p1 = p + bump;\nfloat adjustSize=mix(0.1,1.,readFloat(2.));\n\nreturn sdTorus(p1+vec3(sin(iTime*0.3)*0.2,sin(iTime)*0.5,0.0),vec2(0.4*adjustSize,0.2*adjustSize));\n\n}\n\n//=== gradient functions ===\nvec3 gradient( in vec3 p ) //尚未normalize\n{\n\tconst float d = 0.001;\n\tvec3 grad = vec3(map(p+vec3(d,0,0))-map(p-vec3(d,0,0)),\n                     map(p+vec3(0,d,0))-map(p-vec3(0,d,0)),\n                     map(p+vec3(0,0,d))-map(p-vec3(0,0,d)));\n\treturn grad;\n}\n\n\n// === raytrace functions===\nfloat trace(vec3 o, vec3 r, out vec3 p)\n{\nfloat d=0.0, t=0.0;\nint step=int(mix(10.,20.,readFloat(5.)));      \n\nfor (int i=0; i<step; ++i)\n{\n\n\tp= o+r*t;\n\td=map(p);\n\tif(d<0.0) break;\n\tt += d*0.3; //影響輪廓精準程度\n\t}\nreturn t;\n}\n\n\n//=== sky ===\nfloat fbm(in vec2 uv);\nvec3 getSkyFBM(vec3 e) {\t//二維雲霧\n\tvec3 f=e;\n\tfloat m = 2.0 * sqrt(f.x*f.x + f.y*f.y + f.z*f.z);\n\tvec2 st= vec2(-f.x/m + .5, -f.y/m + .5);\n\t//vec3 ret=texture2D(iChannel0, st).xyz;\n\tfloat fog= fbm(0.6*st+vec2(-0.2*iTime, -0.02*iTime))*0.5+0.3;\n    return vec3(fog);\n}\n\nvec3 sky_color(vec3 e) {\t//漸層藍天空色\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    //ret.x = pow(1.0-e.y,3.0);\n    //ret.y = pow(1.0-e.y, 1.2);\n    //ret.z = 0.8+(1.0-e.y)*0.3;\n    ret=FlameColour(e.y);\n    return ret;\n}\n\nvec3 getSkyALL(vec3 e)\n{\t\n\treturn sky_color(e);\n}\n\n//=== camera functions ===\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// math\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    vec3 m0 = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    vec3 m1 = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    vec3 m2 = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n    return mat3(m0, m1, m2);\n}\n\n\n\n\n\n\n// ================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = gl_FragCoord.xy/iResolution.xy;\n    uv = uv*2.0-1.0;\n    uv.x*= iResolution.x/iResolution.y;\n    uv.y*=1.0;//校正 預設值uv v軸朝下，轉成v軸朝上相同於y軸朝上為正\n    vec2 mouse=(iMouse.xy/iResolution.xy)*2.0-1.0;\n\n// camera option1  (模型應在原點，適用於物件)\n\tvec3 CameraRot=vec3(0.0, mouse.y, mouse.x); \n\tvec3 ro= vec3(0.0, 0.0, 2.0)*fromEuler(CameraRot);//CameraPos;\n\tvec3 ta =vec3(0.0, 0.0, 0.0); //TargetPos; //vec3 ta =float3(CameraDir.x, CameraDir.z, CameraDir.y);//UE座標Z軸在上\n\tmat3 ca = setCamera( ro, ta, 0.0 );\n\tvec3 RayDir = ca*normalize(vec3(uv, 2.0));//z值越大，zoom in! 可替換成iMouse.z\n\tvec3 RayOri = ro;\n\n// camera option2 (攝影機在原點，適用於場景)\n/*\t\n\tvec3 CameraRot=vec3(0.0, -iMouse.y, -iMouse.x);\n\tvec3 RayOri= vec3(0.0, 0.0, 0.0);\t//CameraPos;\n\tvec3 RayDir = normalize(vec3(uv, -1.))*fromEuler(CameraRot);\n*/\n\t\n\tvec3 p,n;\n\tfloat t = trace(RayOri, RayDir, p);\n\tn=normalize(gradient(p));\n    vec3 bump=normalMap(p*1.652,n);\n    float adjustBump=mix(0.,0.2,readFloat(1.));\n    n=n+bump*adjustBump;\n    \n    float edge= dot(-RayDir, n);\n    //edge = step(0.2, edge);\n    edge = smoothstep(-0.072, 0.956, edge);\n    \n    \n\t\t\n//SHADING\n    vec3 result=n;\n    vec3 ao = vec3(calcAO(p,n));\n    //result = vec3(edge);\n    result= phong(p,n,-RayDir)*ao;  //攝影機觀看視角(V)要轉負的，因為是方向是從物體發出到攝影機  //需要外接的話燈光另外寫\n    //result*=(1.-edge);\n//HDR環境貼圖\n    vec3 refl = reflect(RayDir,n);\n    vec3 refl_clr=warpSky(refl);\n\t//vec3 BG=vec3(0.99);\t   \n    vec3 BG=refl_clr;\n\n    vec4 ui = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 col;\n    if(t<2.5) col = vec4(vec3(result),1.0); else col = vec4(BG,1.0);//測試n, n_bump, fresnel, BG, color, fog, F, I, SS, reflectedCol\n    fragColor = mix(col, ui, ui.a);\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//=== 3d noise functions ===\nfloat hash11(float p) {\n    return fract(sin(p * 727.1)*43758.5453123);\n}\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nvec3 hash31(float p) {\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\n    return fract(sin(h)*43758.543123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n//=== glow functions ===\nfloat glow(float d, float str, float thickness){\n    return thickness / pow(d, str);\n}\n\n//=== 2d noise functions ===\nvec2 hash2( vec2 x )\t\t\t//亂數範圍 [-1,1]\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\nfloat gnoise( in vec2 p )\t\t//亂數範圍 [-1,1]\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash2( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     \t    dot( hash2( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                \t     mix( dot( hash2( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     \t    dot( hash2( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat fbm(in vec2 uv)\t\t//亂數範圍 [-1,1]\n{\n\tfloat f;\t\t\t\t//fbm - fractal noise (4 octaves)\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf   = 0.5000*gnoise( uv ); uv = m*uv;\t\t  \n\tf += 0.2500*gnoise( uv ); uv = m*uv;\n\tf += 0.1250*gnoise( uv ); uv = m*uv;\n\tf += 0.0625*gnoise( uv ); uv = m*uv;\n\treturn f;\n}\n\n//=== 3d noise functions p/n ===\nvec3 smoothSampling2(vec2 uv)\n{\n    const float T_RES = 32.0;\n    return vec3(gnoise(uv*T_RES)); //讀取亂數函式\n}\n\nfloat triplanarSampling(vec3 p, vec3 n)\n{\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    return  (abs(n.x)*smoothSampling2(p.yz).x\n            +abs(n.y)*smoothSampling2(p.xz).x\n            +abs(n.z)*smoothSampling2(p.xy).x)/fTotal;\n}\n\nconst mat2 m2 = mat2(0.90,0.44,-0.44,0.90);\nfloat triplanarNoise(vec3 p, vec3 n)\n{\n    const float BUMP_MAP_UV_SCALE = 0.2;\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    float f1 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.xy = m2*p.xy;\n    p.xz = m2*p.xz;\n    p *= 2.1;\n    float f2 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.yx = m2*p.yx;\n    p.yz = m2*p.yz;\n    p *= 2.3;\n    float f3 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    return f1+0.5*f2+0.25*f3;\n}\n\nvec3 normalMap(vec3 p, vec3 n)\n{\n    float d = 0.005;\n    float po = triplanarNoise(p,n);\n    float px = triplanarNoise(p+vec3(d,0,0),n);\n    float py = triplanarNoise(p+vec3(0,d,0),n);\n    float pz = triplanarNoise(p+vec3(0,0,d),n);\n    return normalize(vec3((px-po)/d,\n                          (py-po)/d,\n                          (pz-po)/d));\n}\n\n//=== iq’s calc AO ===\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n\n\tvec3 v = normalize(vec3(0.7,-0.1,0.1));\n\tfor( int i=0; i<12; i++ )\n\t{\n\t\tfloat h = abs(sin(float(i)));\n\t\tvec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));\n\t\tao += clamp( map(pos+nor*0.01+kv*h*0.08)*3.0, 0.0, 1.0 );\n\t\tv = v.yzx; //if( (i&2)==2) v.yz *= -1.0;\n\t}\n\tao /= 12.0;\n\tao = ao + 2.0*ao*ao;\n\treturn clamp( ao*5.0, 0.0, 1.0 );\n}\n\n//=== flame color ===\n//thanks iq..\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 hsv2rgb_trigonometric( in vec3 c )\n{\n    vec3 rgb = 0.5 + 0.5*cos((c.x*6.0+vec3(0.0,4.0,2.0))*3.14159/3.0);\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 FlameColour(float f)\n{\n\treturn hsv2rgb_smooth(vec3((f-(2.25/6.))*(1.25/6.),f*1.25+.2,f*.95));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define UI_COLOR vec3(1,1,1)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloat(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  \n    \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloat(data.r, 3., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n    \n}\n\n\nvec4 bounds = vec4(10,180,140,18);\n#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n    \n    //define sliders    \n    EASYSLIDER(1,.25)  _B U M P\n    EASYSLIDER(2,1.)  _C E N T E R _ _S I Z E   \n    EASYSLIDER(3,.5)  _C O L O R _ _D E N S I T Y\n    EASYSLIDER(4,.5)  _G A M M A    \n    EASYSLIDER(5,.5)  _S T E P   \n    //EASYSLIDER(6,.32)  _D _F _ _V I S I B I L I T Y  \n          \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    \n    fragColor=result;    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}