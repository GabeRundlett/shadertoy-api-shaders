{
    "Shader": {
        "info": {
            "date": "1543874197",
            "description": "Random discs in a bivariate Gaussian distribution.",
            "flags": 16,
            "hasliked": 0,
            "id": "4lKfWG",
            "likes": 14,
            "name": "Bivariate Gaussian",
            "published": 3,
            "tags": [
                "random",
                "gaussian",
                "points",
                "wang",
                "lcg",
                "bivariate"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 723
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Created 2018 by Matthew Arcus\n//\n// Bivariate Gaussian\n//\n// Draw random discs in a bivariate Gaussian (normal) distribution, with\n// a variable correlation.\n//\n// Use Wang hash to seed LCG for per-cell randomization\n// Multi-layer grid for better distribution\n//\n// Mouse y to zoom in, mouse x to change density\n// 'c' toggle variable width circles\n// 'g' toggle construction grid\n// 'n' toggle Gaussian\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Numerical Recipes 32-bit Linear Congruential Generator\nuint seed = 1U;\nuint lcg() {\n  seed *= 1664525U;\n  seed += 1013904223U;\n  return seed;\n}\n\n// Wang Hash, used to seed LCG\nuint ihash(uint a) {\n  a = (a ^ 61U) ^ (a >> 16);\n  a *= 9U;\n  a = a ^ (a >> 4);\n  a = a * 0x27d4eb2dU;\n  a = a ^ (a >> 15);\n  return a;\n}\n\n// Note that we convert from float to integer to unsigned\nuint ihash(ivec2 p) {\n  uint i = uint(p.x), j = uint(p.y);\n  return ihash((i << 16) ^ j);\n}\n\n// Uniform random float in [0,1)\nfloat rand() {\n  return float(lcg())/pow(2.0,32.0);\n}\n\n// Bivariate Gaussian (unnormalized, but should be constant integral with varying rho).\n// x,y,standard deviations and correlation\nfloat bivariate(vec2 p, vec2 sd, float rho) {\n  float k = 1.0-rho*rho;\n  float x = p.x, y = p.y, sx = sd.x, sy = sd.y;\n  float sx2 = sx*sx, sy2 = sy*sy, sxsy = sx*sy;\n  return 1.0/sqrt(k)*exp(-0.5/k*(x*x/sx2 + y*y/sy2 - 2.0*rho*x*y/sxsy));\n}\n\nconst int CHAR_C = 67;\nconst int CHAR_G = 71;\nconst int CHAR_N = 78;\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return v * mix( vec3(1.0), rgb, s);\n}\n\nfloat PI = 3.14159;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float scale = 2.5;\n  float gridsize = 8.0; // Cells per unit distance\n  float pdfbase = 0.25; // 1 in 4 chance of finding a disc.\n  vec2 sd = gridsize*vec2(2,1); // Standard deviation for x and y\n  float rho = sin(0.1*PI*iTime);  // Correlation\n\n  if (iMouse.x != 0.0) {\n    scale *= 2.0*iMouse.x/iResolution.x;\n    pdfbase *= 2.0*iMouse.y/iResolution.y;\n  }\n  vec3 basecolor = vec3(0.2);\n  vec2 pos  = (2.0*fragCoord - iResolution.xy)/ iResolution.y;\n  pos *= scale;\n  pos *= gridsize;\n  // Find nearest grid point\n  vec2 grid = round(pos);\n  // And iterate through the 4 cells meeting there.\n  for (float i = 0.0; i < 2.0; i++) {\n    for (float j = 0.0; j < 2.0; j++) {\n      vec2 cell = grid - vec2(i,j);\n      seed = ihash(ivec2(cell)); // Seed RNG for this cell\n      float pdf = pdfbase;\n      if (!keypress(CHAR_N)) pdf *= bivariate(cell,sd,rho);\n      // 4 layers of circles\n      for (int k = 0; k < 4; k++) {\n        // See if we have a circle in this cell in this layer.\n        float h = rand();\n        if (h < pdf) {\n          // Yes, we do\n          float x = rand();\n          float y = rand();\n          float hue = fract(rand());\n          vec3 color = hsv2rgb(hue,1.0,1.0);\n          vec2 centre = cell+vec2(x,y);\n          float diameter = 0.5;\n          if (!keypress(CHAR_C)) diameter *= 0.5*(1.0+rand());\n          basecolor = mix(color,basecolor,\n                          smoothstep(0.9*diameter,diameter,length(pos-centre)));\n        }\n      }\n    }\n  }\n  // Draw grid\n  if (keypress(CHAR_G)) {\n    vec2 gpos = pos-floor(pos); // Distance to cell wall\n    gpos = min(gpos,1.0-gpos);\n    basecolor = mix(vec3(0),basecolor,smoothstep(0.04,0.05,min(gpos.x,gpos.y)));\n  }\n  fragColor = vec4(basecolor,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}