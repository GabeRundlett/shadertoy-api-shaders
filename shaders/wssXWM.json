{
    "Shader": {
        "info": {
            "date": "1551535970",
            "description": "trying to figure out how to cheaply simulate joints, click to push",
            "flags": 32,
            "hasliked": 0,
            "id": "wssXWM",
            "likes": 7,
            "name": "joint circle 2d physics",
            "published": 3,
            "tags": [
                "2d",
                "circle",
                "physics",
                "joint"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 524
        },
        "renderpass": [
            {
                "code": "/*Ethan Alexander Shulman 2019\n\nImage - Renders circles, mouse indicator and world border.\n*/\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 uv = ASPECT(u);\n    if (max(abs(uv.x),abs(uv.y)) > 1.-BORDER_SIZE/WORLD_SIZE) {\n        o = BORDER_COLOR;\n        return;\n    }\n    \n    //mouse force indicator\n    vec4 rep = vec4(0);\n    if (iMouse.w > 0.) rep.x += max(0.,1.-pow(length(ASPECT(iMouse.xy)-uv),.33));\n    \n    //distance to nearest circle center\n    vec2 wuv = uv*WORLD_SIZE;\n    float cd = 1e7;\n    for (int i = 0; i < NBODY; i++) cd = min(cd,length(texelFetch(iChannel0,ivec2(i,0),0).xy-wuv));\n    \n    //draw circles and outline using distance\n    cd = clamp(max(0.,cd-BODY_RADIUS)/OUTLINE_SIZE,0.,1.);\n    o = mix(BACKGROUND_COLOR+rep,\n            mix(CIRCLE_COLOR,OUTLINE_COLOR,cd),\n            1.-cd);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*Ethan Alexander Shulman 2019\n\nBuf A - Simulates individual 2d circle rigid bodies, very basic physics no velocity transfer \nand fixed timestep if velocities to high they can miss collisions. The 'joint' part is done in Buf B.\n\nOutputs:\nxy - Body position.\nzw - Body velocity.\n*/\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    if (u.x > float(NBODY) || u.y >= 1.) return;\n    \n    if (iFrame < 20) {\n        //initialize row of circles\n        o = vec4((u.x-float(NBODY)/2.)*(BODY_RADIUS*2.+JOINT_ROOM),0,0,0);\n        return;\n    }\n    \n    //get bodies state from pixel\n    int cid = int(u.x);\n    vec4 c = texelFetch(iChannel0,ivec2(cid,0),0);\n    \n    //if velocity non-zero try move and check for collisions\n    if (dot(c.zw,c.zw) > 0.) {        \n        vec2 np = c.xy+c.zw*TIMESTEP, cnrm = vec2(0);\n\n        //check for collision against static border\n        vec2 bdif = abs(np)-WORLD_SIZE+BORDER_SIZE+BODY_RADIUS;\n        if (max(bdif.x,bdif.y) > 0.) {\n            if (bdif.x > bdif.y) cnrm = vec2(sign(np.x),0.);\n            else cnrm = vec2(0.,sign(np.y));\n        }\n\n        //check collisions against other circles except self\n        for (int i = 0; i < NBODY; i++) {\n            if (i == cid) continue;\n            vec4 t = texelFetch(iChannel0,ivec2(i,0),0);\n            t.xy -= np;\n            t.zw = t.xy+t.zw*TIMESTEP;\n            float l1 = length(t.xy), l2 = length(t.zw);\n            if (min(l1,l2) < BODY_RADIUS*2.) {\n             \tif (l1 < l2) cnrm = t.xy/l1;\n                else cnrm = t.zw/l2;\n            }\n        }\n\n        //collision reflection and velocity loss\n        if (dot(cnrm,cnrm) > 0.) c.zw = reflect(normalize(c.zw),cnrm)*length(c.zw)*BOUNCE;\n        else c.xy = np;\n    }\n    \n    //add gravity force\n    c.zw += GRAVITY*TIMESTEP;\n    \n    //add mouse force\n    if (iMouse.z > 0.) {\n     \tvec2 mp = ASPECT(iMouse.xy)*WORLD_SIZE,\n            df = c.xy-mp;\n        if (dot(df,df) > 0.) c.zw += 200.*normalize(df)*max(0.,1.-pow(length(df/WORLD_SIZE),.33))*TIMESTEP;\n    }\n    \n    o = c;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define ASPECT(q) ((q*2.-iResolution.xy)/iResolution.y)\n\n#define TIMESTEP (1./60.)\n#define GRAVITY vec2(0,-10)\n#define WORLD_SIZE 10.\n#define BORDER_SIZE 1.\n\n#define NBODY 16\n#define BODY_RADIUS .3\n#define BOUNCE .5\n#define JOINT_BODIES\n#define JOINT_ROOM .1\n\n#define BORDER_COLOR vec4(0)\n#define BACKGROUND_COLOR vec4(.15)\n#define CIRCLE_COLOR vec4(1.)\n#define OUTLINE_COLOR vec4(0,0,1,1)\n#define OUTLINE_SIZE .2",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*Ethan Alexander Shulman 2019\n\nBuf B - Joins bodies after individual movements and transfers velocities to neighbouring bodies.\nCurrently doesn't do collision detection so circles sometimes pass through the walls and\nother circles.\n\nOutputs:\nxy - Body position.\nzw - Body velocity.\n*/\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    if (u.x > float(NBODY) || u.y >= 1.) return;\n    \n    #ifndef JOINT_BODIES\n    o = texelFetch(iChannel0,ivec2(u),0);\n    return;\n    #endif\n    \n    //get bodies states from pixel\n    int cid = int(u.x);\n    vec4 c = texelFetch(iChannel0,ivec2(cid,0),0),\n         cl = texelFetch(iChannel0,ivec2(cid-1,0),0),\n         cr = texelFetch(iChannel0,ivec2(cid+1,0),0);\n    \n    //teleport body to the side of left/right neighbour, alternate between left/right each frame so that both ends of the joints can lead movements\n    if (iFrame%2 == 0) {\n        vec2 r = texelFetch(iChannel0,ivec2(0),0).xy;\n        for (int i = 1; i < cid+1; i++) r += normalize(texelFetch(iChannel0,ivec2(i,0),0).xy-r)*(BODY_RADIUS*2.+JOINT_ROOM);\n        c.xy = r;\n    } else {\n        vec2 r = texelFetch(iChannel0,ivec2(NBODY-1,0),0).xy;\n        for (int i = NBODY-2; i > cid-1; i--) r += normalize(texelFetch(iChannel0,ivec2(i,0),0).xy-r)*(BODY_RADIUS*2.+JOINT_ROOM);\n        c.xy = r;\n    }\n    \n    //mix neighbour velocities\n    vec3 vsum = vec3(c.zw,1);\n    if (cid != 0) vsum += vec3(cl.zw,1);\n    if (cid != NBODY-1) vsum += vec3(cr.zw,1);\n    c.zw = vsum.xy/vsum.z;\n\n    o = c;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}