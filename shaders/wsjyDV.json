{
    "Shader": {
        "info": {
            "date": "1587383050",
            "description": "Computes decimals in base 16 with Plouffe's formula.\n\nGoal: visualize pi's decimals in 3D with https://github.com/voidstarHQ/voidstar",
            "flags": 0,
            "hasliked": 0,
            "id": "wsjyDV",
            "likes": 1,
            "name": "Ï€ decimals in 2D & color",
            "published": 3,
            "tags": [
                "pi",
                "plouffe",
                "spigot"
            ],
            "usePreview": 0,
            "username": "fenoll",
            "viewed": 291
        },
        "renderpass": [
            {
                "code": "// https://www.shadertoy.com/view/wsjyDV\n// Inspired from https://www.shadertoy.com/view/XsyyzW\n// Pi by Plouffe spigot algorithm:\n// See also (en & fr) https://en.wikipedia.org/wiki/Bailey%E2%80%93Borwein%E2%80%93Plouffe_formula\n// Adapted from C code:  http://www.experimentalmath.info/bbp-codes/piqpr8.c\n// Another PI method (not parallel): https://www.shadertoy.com/view/MdtXWj\n// See also https://github.com/voidstarHQ/voidstar\n\n#define double float\n#define pow16(x) exp2(4.*(x))\n\n// expm = 16^p mod ak.\n// This routine uses the left-to-right binary exponentiation scheme.\ndouble expm(double p, double ak) {\n  int i, j;\n  double p1, pt, r;\n#define ntp 25\n#define tp(i) exp2(float(i))\n  if (ak == 1.) return 0.;\n\n  // Find the greatest power of two less than or equal to p.\n  // $FaN: why not using floor(log2(p)) ?\n  for (i = 0; i < ntp; i++)\n      if (tp(i) > p) break;\n\n  pt = tp(i-1);\n  p1 = p;\n  r = 1.;\n  // Perform binary exponentiation algorithm modulo ak.\n  for (j = 1; j <= i; j++){\n    if (p1 >= pt){\n      r = 16. * r;\n      r = mod(r,ak); // $FaN: is mod reliable ?\n      p1 -= pt;\n    }\n    pt /= 2.;\n    if (pt >= 1.){\n      r = r * r;\n      r = mod(r,ak);\n    }\n  }\n  return r;\n}\n\n// This routine evaluates the series  sum_k 16^(id-k)/(8*k+m)\n// using the modular exponentiation technique.\ndouble series(int m, int id) {\n  int k;\n  double ak, p, s, t;\n#define eps 1e-17 // maybe we could shorten it when using floats\n  s = 0.;\n\n  // Sum the series up to id.\n  for (k = 0; k < id; k++){\n    ak = float(8 * k + m);\n    p = float(id - k);\n    t = expm (p, ak) / ak;\n    s = fract(s+t);\n  }\n\n  // Compute a few terms where k >= id.\n#define M 8  // was 100. 8 seems sufficient to have the whole 10 hex digit ok ! 1 is still ok for 3 digits\n  for (k = id; k <= id + M; k++){\n    ak = float(8 * k + m);\n    t = pow16( float(id - k)) / ak;\n    if (t < eps) break;\n    s = fract(s+t);\n  }\n  return s;\n}\n\n// id is the digit position. Digits generated follow immediately after id.\nfloat digit(int id) {\n  if (id<0) return .1415926535897; // for test ( = ref )\n  double s1 = series(1, id);\n  double s2 = series(4, id);\n  double s3 = series(5, id);\n  double s4 = series(6, id);\n  double pid = 4. * s1 - 2. * s2 - s3 - s4;\n  return fract(pid);// NB: pid always <0 ?\n}\n\n\nvoid mainImage( out vec4 O, vec2 U ) {\n    O -= O;\n    ivec2 iU = ivec2(U/8.);\n    ivec2 iW = ivec2(iResolution.xy/32.);\n    if (iU.x>=iW.x || iU.y>=iW.y) return;\n\n    // Since only the fractional part is accurate,\n    // extracting the wanted digit requires that one removes\n    // the integer part of the final sum and multiplies by 16\n    // to \"skim off\" the hexadecimal digit at this position\n    // (in theory, the next few digits up to the accuracy of\n    // the calculations used would also be accurate).\n    //float r = 16. * digit(0 + iU.x + W.x*iU.y);\n    float r = digit(0 + iU.x + iW.x*iU.y);\n    float g = fract(100. * r);\n    float b = fract(100. * g);\n\n    O = vec4(r,g,b,1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}