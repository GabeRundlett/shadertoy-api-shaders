{
    "Shader": {
        "info": {
            "date": "1635253149",
            "description": "using the Worley/Voronoi seed-per-cell trick\n\nMouse controls camera.",
            "flags": 0,
            "hasliked": 0,
            "id": "7sKXDG",
            "likes": 21,
            "name": "sea of balls",
            "published": 3,
            "tags": [
                "raymarching",
                "voronoi",
                "worley",
                "short"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 566
        },
        "renderpass": [
            {
                "code": "// utils from https://www.shadertoy.com/view/llySRh\n#define rot(a)   mat2(cos(a+vec4(0,11,33,0)))                          // rotation\n#define H(p)     fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nfloat map(vec3 q, out vec2 _I) {      // --- scene. return SDF, out = ID.\n    vec2 I = floor(q.yx), F = fract(q.yx), D,H;\n    float d, l=9.;\n    for( int k=0; k < 9; k++ )        // find closest seed within neihbors\n        D = vec2(k%3,k/3) -1.,\n        H = H(I+D+.5),                // motion parameters\n        d = length( D + H(I+D) - F    // offset to seed\n                      + .8*cos( 15.*iTime*(H.y-.5) + 6.3*H.x + vec2(0,11) ) // seed rotation\n                  ),\n        d < l ? l = d, _I = I+D : I;  // keep closest dist + its id.\n    return length(vec2(l,q.z)) - .3;\n}\n\nvoid mainImage(out vec4 O, vec2 U)    // --- renderer\n{\n    float t=9.; \n    vec3  R = iResolution, N, e = vec3(1,-1,0)/1e2, \n          D = normalize(vec3((U+U-R.xy)/R.y, -2.)),   // ray direction\n          p = vec3(0,-2,22), q,                       // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(10,12,0)/1e2*cos(.3*iTime+vec3(0,11,0))+vec3(0,.12,0); \n    vec2 C;\n    for ( O=vec4(1); O.x > 0. && t > .005; O-=.005 )  \n        q = p,\n        q.yz *= rot(.5-6.3*M.y),                      // rotations\n        q.xz *= rot(-6.3*M.x),\n        t = map(q,C),                                 // SDF\n        p += .25*t*D;                                 // step forward = dist to obj\n\n    O *= hue(H(C).x);                 // coloring from ID\n                                      // optional: true shading\n    if (O.a>0.) N = normalize(   map(q+e.xyy,C)/e.xyy +  map(q+e.yxy,C)/e.yxy\n                               + map(q+e.yyx,C)/e.yyx +  map(q+e.xxx,C)/e.xxx ),\n                O *= vec4( .3 + .7*max(0.,N.z) )*1.3;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}