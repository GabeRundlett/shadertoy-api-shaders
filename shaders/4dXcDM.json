{
    "Shader": {
        "info": {
            "date": "1492632205",
            "description": "shadows\n\nClick on screen!!",
            "flags": 0,
            "hasliked": 0,
            "id": "4dXcDM",
            "likes": 0,
            "name": "Shadow Glim",
            "published": 3,
            "tags": [
                "shadows"
            ],
            "usePreview": 0,
            "username": "Glim888",
            "viewed": 590
        },
        "renderpass": [
            {
                "code": "#define STEPS 10\n\nconst float LIGHT_RANGE \t= 0.6;\n\nconst vec3  LIGHT_COLOR\t\t= vec3(0.9,0.9,0.9);\n\nconst int   LIGHT_NUMBER    = 1;\n\nconst vec2[] LIGHT_POS = vec2[] (vec2(0.0),vec2(0.8));\n///lengthdir_x\nfloat lengthdir_x(float _dir, float _dist)\n{\n return sin(radians (_dir)) * _dist;   \n}\n\n///lengthdir_y\nfloat lengthdir_y(float _dir, float _dist)\n{\n return cos(radians (_dir)) * _dist;   \n}\n\n\n///point_distance\nfloat point_distance(vec2 startPoint, vec2 endPoint)\n{\n return sqrt(\n     \t\tpow((endPoint.x-startPoint.x),2.0)+\n     \t\tpow((endPoint.y-startPoint.y),2.0)\n     \t\t);   \n}\n\n///point_direction\nfloat point_direction(vec2 v1, vec2 v2)\n{\n  float ang = degrees (\n      \t\t\tacos(\n          \t\t\tdot(v1,v2) / (length(v1) * length(v2) )\n      \t  \t\t\t)\n       \t\t\t );\n  if(v2.x < 0.0)\n  {\n  return  360.0 - ang;    \n  }else{\n  return  ang; \n  }\n}\n\n\n//converts a value from a range A to a range B\nfloat map(float val, float min1, float max1, float min2, float max2)\n{\n   return (val/max1 - min1) * (max2 - min2); \n}\n\nvec3 circle (vec2 _uv, vec2 pos )\n{\n    ///distance between the current pixel and the lightcenter\n    float _dist = distance(_uv,pos);\n        \n    return clamp(LIGHT_COLOR / pow((_dist / LIGHT_RANGE),3.5),0.,1.);\n       \n}\n\nvec3 wall_box(vec2 _uv, vec2 pos, float size)\n{\n    if(abs(_uv.x - pos.x ) < size && abs(_uv.y - pos.y ) < size)\n    {\n     return vec3(0.0);   \n    }else{\n     return vec3(1.0);   \n    }\n}\n\nvec3 wall_circle(vec2 _uv, vec2 pos, float rad)\n{\n\n    if(distance(_uv,pos) < rad) \n    {\n     return vec3(0.0);   \n    }else{\n     return vec3(1.0);   \n    }\n}\n\nvec3 calcShadow(vec2 _uv, vec2 pos,float d)\n{\n    bool isInShadow = false;\n    for(int i=0;i<LIGHT_NUMBER;i++)\n        {\n        float dist2Light = 0.3 / length(pos-LIGHT_POS[i]);\n        float dist = length(_uv-pos) + d;\n        float dir = point_direction(vec2(0.0,1.0),pos);\n\n        //circle\n\n        vec2 new_pos = vec2(0.0);\n        new_pos.x = pos.x + lengthdir_x(dir,dist);\n        new_pos.y = pos.y + lengthdir_y(dir,dist);\n\n        if(distance(_uv,new_pos) < 0.1 + dist * dist2Light)\n            {\n              isInShadow = false;\n            }else{\n              isInShadow = true;\n            }\n        }\n    return vec3(isInShadow);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //View-Ratio \n\tvec2 uv = (fragCoord.xy - (iResolution.xy * 0.5)) / iResolution.xy;\n    uv *= 2.0;    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    //mouseCoords to View-Ratio\n    vec2 mouse = (iMouse.xy - (iResolution.xy * 0.5)) / iResolution.xy;\n    mouse *= 2.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    \n    ///////\n    //Start\n    ///////\n    \n    \n    ///load texture\n    vec3 canvasCol = texture(iChannel0,uv).rgb; \n    \n    //add lights\n    vec3 light1 = vec3(0.0);\n    vec3 light2 = vec3(0.0);\n    \n    //light3, light4;\n    \n    light1 = circle(uv, LIGHT_POS[0]);\n    //light2 = circle(uv, LIGHT_POS[1]);\n    //light3 = circle(uv, POS3);\n    //light4 = circle(uv, mouse.xy);\n    \n    vec3 shadow1 = vec3(1.0);\n    vec3 shadow2 = vec3(1.0);\n    \n    shadow1 = wall_circle(uv,mouse.xy,0.1);\n    //shadow2 = wall_circle(uv,vec2(0.3,0.3),0.1);\n        vec3 penumbra = vec3(1.0);    \n        for(int i=0;i<STEPS;i++)\n        {\n        float d = 0.03 * float(i);\n        penumbra += calcShadow(uv, mouse.xy,d);\n        //penumbra += calcShadow(uv, vec2(0.3),d);\n        }\n        penumbra /= vec3(STEPS);\n    \n    //multiply all layers\n    canvasCol *= (light1+light2);\n    \n    canvasCol *= shadow1;\n    canvasCol *= shadow2;\n    canvasCol *= penumbra;\n    \n    //\"print to screen\"\n    fragColor = vec4(canvasCol,1.0);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}