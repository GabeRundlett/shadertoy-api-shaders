{
    "Shader": {
        "info": {
            "date": "1476747141",
            "description": "Reactive Voronoi by glk7 remixed. \nWhat's new: softer shadows, color phase modulation by music, simple beat detection, grid-hack, lighting tweaks. \nThe track is Neptune Project - John O'Callaghan vs Neptune Project - Rhea.",
            "flags": 64,
            "hasliked": 0,
            "id": "MlGGDK",
            "likes": 13,
            "name": "Reactive Voronoi (T-Remix) ",
            "published": 3,
            "tags": [
                "3d",
                "voronoi",
                "raymarch",
                "visualization",
                "reactive",
                "shadows",
                "palette",
                "trance"
            ],
            "usePreview": 0,
            "username": "TimoKinnunen",
            "viewed": 1336
        },
        "renderpass": [
            {
                "code": "// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\nconst float PI = 3.1416;\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),\n                          dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// From https://iquilezles.org/articles/voronoilines\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\n\n// Modified version of the above iq's voronoi borders. \n// Returns the distance to the border in a given direction.\nvec3 voronoi( in vec2 x, in vec2 dir)\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 1e5;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n\n    \n \t\tif( dot(r-mr,r-mr) > 1e-5 ) {\n            \n            vec2 f = r-mr;\n            \n            if (dot(dir, f) > 1e-5) {\n            \tvec2 m = 0.5*(mr+r);\n   \t \t\t\tfloat c = m.x*(m.y + f.x) - m.y*(m.x - f.y);\n            \tfloat d = 1.0 / dot(dir, f);\n                \n            \tmd = min(md, dot(dir, dir*c*d));\n            }\n        }\n        \n    }\n    \n    return vec3( md, n+mg);\n}\nfloat gridWidth = 1.25;\nbool IRayAABox(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, \n               out vec3 p0, out vec3 p1) \n{\n    vec3 orig = .5*bmin+.5*bmax+vec3(iTime*2.5,0,0);\n    vec2 grid = (bmax.xz-bmin.xz)*gridWidth;\n    vec3 plane = (orig.y-ro.y)*invrd.y*rd+ro;\n    vec2 cell = floor((plane.xz+orig.xz)/grid+0.5);\n    vec2 srcCell = floor((ro.xz+orig.xz)/grid+0.5);\n    //vec2 m = cell*0.1;\n    //mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    //mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    bmin.xz+=cell*grid-vec2(iTime*2.5,0);\n    bmax.xz+=cell*grid-vec2(iTime*2.5,0);\n    //bmin.y+= floor(distance(cell,srcCell));\n    //bmax.y+= floor(distance(cell,srcCell));\n    \n    //bmin.yzx*=rotY;\n    //bmax.yzx*=rotY;\n    //bmin.zyx*=rotX;\n    //bmax.zyx*=rotX;\n\n    vec3 t0 = (bmin - ro) * invrd;\n    vec3 t1 = (bmax - ro) * invrd;\n\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(max(tmin.x, tmin.y), tmin.z);\n    float fmax = min(min(tmax.x, tmax.y), tmax.z);\n    \n    p0 = ro + rd*fmin;\n    p1 = ro + rd*fmax;\n \n    //p0.y-= floor(distance(cell,srcCell));\n    //p1.y-= floor(distance(cell,srcCell));\n    return fmax >= fmin;   \n}\n\nvec3 AABoxNormal(vec3 bmin, vec3 bmax, vec3 p) \n{\n    vec3 n1 = -(1.0 - smoothstep(0.0, 0.03, p - bmin));\n    vec3 n2 = (1.0 -  smoothstep(0.0, 0.03, bmax - p));\n    \n    return normalize(n1 + n2);\n}\n\nconst vec3 background = vec3(0.04);\nconst vec3 scmin = vec3(-2.0, -0.5, -2.0);\nconst vec3 scmax = vec3(+2.0, +1.5, +2.0);\n\nvec3 frequency = vec3(1.0,0.7,0.4);\n// From https://iquilezles.org/articles/palettes\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+frequency*mod(t,10.0)+d) );\n}\nvec4 max2(float a, vec4 b){return max(vec4(a),b);}\nvec4 sound(vec2 v) {\n    vec4 bass = max2(0.02,log2(.5+texture(iChannel0, vec2(1./iChannelResolution[0].x,0))));\n    vec4 treble = max2(0.02,texture(iChannel0, vec2(hash2(v).x, 0.0))*2.0-1.0);\n    return treble+bass;\n}\nvec3 color(vec2 p) {\n    //const float varia = 0.02;\n    const float varia = 0.3;\n    return pal(2.+iTime/3.434+hash2(p).x*varia, \n               vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20)+(sound(p).x-0.5)*2.0  );\n}\n\nfloat disp(vec3 v) {\n    return (0.0*smoothstep(0.05,0.08,v.x)+1.0)*(scmin.y + 0.5* (0.1 + hash2(v.yz).x * 0.5 + sound(v.yz).r*2.0));\n}\nvec4  saturate(vec4  a) { return clamp(a, 0.0, 1.0); }\nvec3  saturate(vec3  a) { return clamp(a, 0.0, 1.0); }\nvec2  saturate(vec2  a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec4 doMap(vec3 voro) {\n    vec3 v = voro*0.5;\n    float height = 0.1+0.9*disp(v);\n    //v.x=(-0.05+v.x);\n    return vec4(v, height);\n}\nvec4 map(in vec2 p, in vec2 dir) {\n    return doMap(voronoi(p*2.0, dir));\n}\nvec4 map(in vec2 p) {\n    return doMap(voronoi(p*2.0));\n}\n\nfloat wrappedDiffuse(vec3 N, vec3 L, float w, float n) {\n\treturn pow(saturate((dot(N, L)+ w)/ (1.0+ w)), n)* (1.0+ n)/ (2.0* (1.0+ w));\n}\nfloat ShadowFactor(in vec3 ro, in vec3 rd) {\n\tvec3 p0 = vec3(0.0);\n    vec3 p1 = vec3(0.0);\n    \n    IRayAABox(ro, rd, 1.0/rd, scmin, scmax, p0, p1);\n    vec2 dir = normalize(rd.xz);\n    float rs = map(ro.xz, dir).x;\n    p0 = ro + rd*0.02;\n    \n    float sf = rd.y / length(rd.xz);\n\n    float m = -1e5;\n    \n    vec4 v;\n    const int max_steps = 32;\n    for (int i = max_steps; i > 0; --i) {\n        \n        if (dot((p1 - p0), rd) < 0.0) return 1.0;\n  \n        v = map(p0.xz, dir);\n        \n        m = v.w;\n        if (p0.y < m) break;// return 0.0;\n        \n        p0 += rd*(length(vec2(v.x, v.x*sf)) + 0.01);\n    }\n    vec3 i1 = vec3(1,0,0);\n    vec3 i2 = vec3(0,1,0);\n    vec3 j1 = (p1 - p0);\n    return (1.0-smoothstep(1.5,0.1,v.x));\n    \n}\n\nvec3 Shade(in vec3 p, in vec3 n, in vec3 ld, in vec2 c) {\n    vec3 col = color(c);\n\treturn col *\n        (\n        0.15 + \n        (0.85+0.95*wrappedDiffuse(n,ld,1.,35.0)) * \n        (0.05+0.95*smoothstep(0.0,0.5,(p.y-scmin.y)/(scmax.y-scmin.y))) * \n        (0.25+0.75*ShadowFactor(p, ld)) * \n        0.85\n    )\n       // * 3.5\n        ;\n}\n\nvec3 Render(in vec3 ro, in vec3 rd, in vec3 ld) {\n    vec3 p0 = vec3(0.0);\n    vec3 p1 = vec3(0.0);\n    \n    if (!IRayAABox(ro, rd, 1.0/rd, scmin, scmax, p0, p1)) return background;\n    \n    vec2 dir = normalize(rd.xz);\n    float sf = rd.y / length(rd.xz);\n    \n    vec2 lvp = vec2(0);\n    vec2 vp = p0.xz;\n    \n    float m = -1e5;\n    \n    const int max_steps = 32;\n    for (int i = max_steps; i > 0; --i) {\n        if (p0.y < m) {\n            p0 += rd * (-p0.y + m)/rd.y;\n            if (dot((p1 - p0), rd) < 0.0) return background;\n            break;\n        }\n        \n        if (dot((p1 - p0), rd) < 0.0) return background;\n  \n        vec4 v = map(p0.xz, dir);\n\t\t\n        lvp = vp;\n        vp = v.yz;\n        \n        m = v.w;\n        if (p0.y < m) break;\n        \n        p0 += rd*(length(vec2(v.x, v.x*sf)) + 0.01);\n    }\n    \n   \n    vec2 eps = vec2(0,.1);\n    vec4 voro00 = map(p0.xz);\n    vec4 voro01 = map(p0.xz+eps.yx);\n    vec4 voro10 = map(p0.xz+eps);\n    float dist = voro00.x;\n    float p2x = voro01.x;\n    float p2y = voro10.x;\n    \n    vec2 side = normalize(vec2(p2x,p2y)-dist);\n    dist=clamp(dist*10.0,0.0,1.0);\n    vec3 sideN = vec3((1.0-dist)*side, dist).xzy;\n    vec3 n = normalize(sideN);\n    if (all(equal(p0.xz, lvp))) {\n        n = AABoxNormal(scmin, scmax, p0); \n    }\n    vec3 col = Shade(p0, n, ld, vp);\n    return col;\n}\nmat3 fromEuler(vec3 ang) {\n#ifdef EULER_2\n\tvec3 s = sin(ang);\n\tvec3 c = cos(ang);\n\tmat3 m = mat3(\n\tc.x* c.z+ s.x* s.y* s.z,c.x* s.y* s.z+ c.z* s.x,-c.y* s.z,\n\t-c.y* s.x,c.x* c.y,s.y,\n\tc.z* s.x* s.y+ c.x* s.z,s.x* s.z- c.x* c.z* s.y,c.y* c.z);\n\treturn m;\n#else\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n\tvec2 a2 = vec2(sin(ang.y),cos(ang.y));\n\tvec2 a3 = vec2(sin(ang.z),cos(ang.z));\n\tmat3 m;\n\tm[0] = vec3(a1.y* a3.y+ a1.x* a2.x* a3.x,a1.y* a2.x* a3.x+ a3.y* a1.x,-a2.y* a3.x);\n\tm[1] = vec3(-a2.y* a1.x,a1.y* a2.y,a2.x);\n\tm[2] = vec3(a3.y* a1.x* a2.x+ a1.y* a3.x,a1.x* a3.x- a1.y* a3.y* a2.x,a2.y* a3.y);\n\treturn m;\n#endif\n}\nfloat rotating = 0.0;\nvoid CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, \n                    out vec3 ro, out vec3 rd, out mat3 t) \n{\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n \n    ro = vec3(0.0, 0.0, -d);\n    \n    vec2 iM = vec2(iTime*5.0+mod(iTime,10.0)*rotating,iResolution.y*.8);\n    float ff = min(1.0, step(0.001, iM.x) + step(0.001, iM.y));\n    vec2 m = PI*ff + vec2(((iM.xy + 0.1) / iResolution.xy) * (PI*2.0));\n    m.y = -m.y;\n    m.y = sin(m.y*0.5)*0.6 + 0.6;\n        \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    t = rotY * rotX;\n    \n    ro = t * ro;\n    ro = c + ro;\n\n    rd = t * rd;\n    \n    rd = normalize(rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ro;\n    vec3 rd;\n    mat3 t = mat3(1.0);\n    float dur = 5.0;\n    float segment = mod(floor(iTime/dur*2.5),12.0);\n    float segs = mod(iTime,dur)/dur*5.0;\n    float swapA = smoothstep(0.0,1.0,-0.5+segs);\n    float swapB = smoothstep(0.0,1.0,-2.0+segs);\n    float swapC = smoothstep(0.0,1.0,-3.5+segs);\n\n    float row0 = step(fragCoord.y,iResolution.y/4.0);\n    float row3 = step(iResolution.y*3.0/4.0,fragCoord.y);\n    float col3 = step(iResolution.x*3.0/4.0,fragCoord.x);\n    float col7 = step(iResolution.x*7.0/8.0,fragCoord.x);\n    float col6 = col3-col7;\n    float seg0 = float(segment==0.0);\n    float seg1 = float(segment==1.0);\n    float seg2 = float(segment==2.0);\n    float seg4 = float(segment==4.0);\n    float seg5 = float(segment==5.0);\n    float seg7 = float(segment==7.0);\n    float seg9 = float(segment==9.0);\n    float seg11 = float(segment==11.0);\n    float t1 = seg2*swapB+seg7*swapB+seg11*swapB;\n    float t2 = seg4*swapB+seg9*swapB;\n    float t3 = float(mod(segment+0.0,3.0)==0.0)*swapA;\n    float t4 = seg0*swapB+seg1+seg5*swapB+seg9*swapC;\n    float t5 = seg0*swapC+seg1+seg5*swapB+seg9*swapC;\n\n    vec2 frag = mod(fragCoord,iResolution.xy/(1.0+3.0*t1));\n    frag.x = mod(frag.x+iResolution.x/(1.0-0.5*t2),iResolution.x/(1.0+3.0*t2));\n    frag.x = mix(frag.x, mod(frag.x, iResolution.x/8.0), col3*t3);\n    frag.y = mix(frag.y, iResolution.y*3.0/4.0+mod(frag.y-iResolution.y*2.0*t4*seg9, iResolution.y/4.0), row3*t4);\n    frag.y = mix(frag.y, mod(frag.y-iResolution.y*7.0/4.0*t5*seg9, iResolution.y/4.0), row0*t5);\n    \n    float zooming = 1.0;\n    float near = 7.0;\n    float far = 7.0;\n    float turner = 0.0;\n    frequency = vec3(vec2(1.0,0.7)*floor(fragCoord/(iResolution.xy/(1.0+3.0*t1)))*0.25*t1,0.4)*t1;\n    frequency = mix(frequency, vec3(0.4,1.0,0.7), fragCoord.y/iResolution.y*col3*t3);\n    gridWidth = mix(gridWidth,0.25,step(0.1,t1+col3*t3));\n    near = mix(near, near+20.0, floor(fragCoord.x/(iResolution.x/(1.0+3.0*t1)))*0.25*t1);\n    zooming = mix(zooming, zooming*0.25, row3*t4);\n    zooming = mix(zooming, zooming*0.25, row0*t5);\n    zooming = mix(zooming, zooming*8.0*(1.5*col6+col7), col3*t3);\n    zooming = mix(zooming, zooming*0.1, floor(fragCoord.y/(iResolution.y/(1.0+3.0*t1)))*0.25*t1);\n    near = mix(near, near+3.0, row3*t4);\n    near = mix(near, near+180.0*col6+280.0*col7, col3*t3);\n    near = mix(near, near+8.0, row0*t5);\n    rotating = mix(rotating, -15.0, col3*t3);\n    turner = mix(turner, 0.25, (1.0-floor(fragCoord.y/(iResolution.y/(1.0+3.0*t1)))*0.25)*t2);\n    \n    float borders = float(frag.x>=5.0&&frag.x<iResolution.x-5.0&&frag.y>=5.0&&frag.y<iResolution.y-5.0);//sign(1.0-dot(vec2(1),step(frag,vec2(5))+step(iResolution.xy-5.0,frag))));\n    borders *= mix(1.0,clamp(abs(iResolution.y/4.0-frag.y)-2.5,0.0,1.0),t5);\n    borders *= mix(1.0,clamp(abs(iResolution.y*3.0/4.0-frag.y)-2.5,0.0,1.0),t4);\n    borders *= mix(1.0,clamp(abs(iResolution.x*3.0/4.0-fragCoord.x)-2.5,0.0,1.0),t3);\n    borders *= mix(1.0,clamp(abs(iResolution.x*3.0/4.0-frag.x)-2.5,0.0,1.0),t2);\n    borders *= mix(1.0,clamp(abs(iResolution.x*2.0/4.0-frag.x)-2.5,0.0,1.0),t2);\n    borders *= mix(1.0,clamp(abs(iResolution.x*1.0/4.0-frag.x)-2.5,0.0,1.0),t2);\n    float circling = segment*10.0*0.5+segs*(0.5+turner);\n    CameraOrbitRay(frag, zooming, vec3(0.0), near+far*(1.0+cos(circling)), ro, rd, t);\n    vec3 ld = normalize(vec3(4,4,-1)*fromEuler(vec3(0,0,5)*circling-4.0*turner));\n\tfragColor = vec4(pow(mix(background,Render(ro, rd, ld),borders), vec3(0.5454)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 5436,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/neptune-project/neptune-project-feat-polly"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}