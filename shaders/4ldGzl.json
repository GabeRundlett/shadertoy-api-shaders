{
    "Shader": {
        "info": {
            "date": "1471044759",
            "description": "Wibbly Wobbly? ;)",
            "flags": 32,
            "hasliked": 0,
            "id": "4ldGzl",
            "likes": 1,
            "name": "Wibbly Wobbly EyeBrow",
            "published": 3,
            "tags": [
                "procedural",
                "raymarched"
            ],
            "usePreview": 0,
            "username": "BeardThings",
            "viewed": 447
        },
        "renderpass": [
            {
                "code": "#define BLUR_DISTANCE 2.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;    \n    vec4 centerSample = texture(iChannel0, uv);\n    fragColor = centerSample;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "struct Material\n{\n    vec4\tm_Color;\n    vec4\tm_EmissiveColor;\n    float \tm_Specular;\n    float \tm_Reflection;\n    float \tm_Opacity;\n    float\tm_Refraction;\n};\n\nstruct WorldObject\n{\n    vec3 \t\tm_Position;\n    float \t\tm_Scale;\n    Material \tm_Material;\n    float \t\tm_DistanceField;\n};\n\n//#define REFLECTION\n//#define TRANSPARANCY\n//#define SHADOWS\n    \n// Constants\nconst float EPSILON = 0.001;\nconst int MAX_STEPS = 64;\nconst int SHADING_MAX_STEPS = 32;\nconst int SECONDARY_MAX_STEPS = 32;\nconst int SECONDARY_RAY_COUNT = 1;\nconst float STEP_REDUCTION = 0.8;\n\n// Declarations\nvec4 PointLight(in vec3 point, in vec3 lightPosition, in Material color);\nvoid RenderImage(in vec3 point, out float stepSize, out Material color);\n\n// Math methods\nfloat LengthSquared(in vec3 vector)\n{\n    return vector.x * vector.x + vector.y * vector.y + vector.z * vector.z;\n}\n\nfloat ShiftRange(in vec2 sourceRange, \n                 in vec2 destRange, \n                 in float value)\n{\n    float sourceMagnitude \t= sourceRange.y - sourceRange.x;\n    float destMagnitude \t= destRange.y - destRange.x;\n    \n    float unitValue = (value - sourceRange.x) / sourceMagnitude;\n    float shiftedValue = (value * destMagnitude) + destRange.x;\n    \n    return shiftedValue;\n}\n\nfloat Equal(in float left, \n            in float right)\n{\n    float under = step(left - EPSILON * 0.001, right);\n    float over \t= step(right, left + EPSILON * 0.001);\n    \n    return under * over;\n}\n\nvec2 ShiftRange(in vec2 sourceRange, \n                 in vec2 destRange, \n                 in vec2 value)\n{\n    float sourceMagnitude \t= sourceRange.y - sourceRange.x;\n    float destMagnitude \t= destRange.y - destRange.x;\n    \n    vec2 unitValue = (value - sourceRange.x) / sourceMagnitude;\n    vec2 shiftedValue = (value * destMagnitude) + destRange.x;\n    \n    return shiftedValue;\n}\n\nstruct Camera\n{\n    vec3 \tm_Position;\n    vec3 \tm_Up;\n    vec3 \tm_Forward;\n    vec3 \tm_Right;\n    float \tm_FocalDistance;\n};\n    \n// Global\nCamera g_MainCamera;\n\nvec3 RayDirection(in vec3 \tforward,\n                  in float \tfocalDistance,\n                  in vec3 \tright,\n                  in vec3 \tup,\n                  in vec2 \tscreenSpaceCoord,\n                  in float \taspectRatioXOverY)\n{\n    return normalize(forward * focalDistance + \n                     right * screenSpaceCoord.x * aspectRatioXOverY +\n                     up * screenSpaceCoord.y);\n}\n\nvec3 CalculateWorldPoint(in vec3 origin, \n                         in vec3 direction, \n                         in float stepSize)\n{\n    return origin + direction * stepSize;\n}\n\n    \n// Distance Field Methods:\n    \nfloat SphereDistanceField(in vec3 point, \n                         in float radius)\n{\n    \n    return length(point) - radius;\n}\n\nfloat BoxDistanceField(in vec3 point,\n                       in vec3 bounds)\n{\n    return length(max(abs(point)-bounds, 0.0));\n}\n\nfloat PlaneDistanceField(in vec3 point,\n                         in vec3 axis)\n{\n    return distance(point * axis, axis);\n}\n\nfloat CylinderDistanceField( vec3 point, float bounds )\n{\n  return length(point.xz)-bounds;\n}\n\nfloat CappedCylinderDistanceField( vec3 point, vec2 bounds )\n{\n  vec2 dist = abs(vec2(length(point.xz),point.y)) - bounds;\n  return min(max(dist.x,dist.y),0.0) + length(max(dist,0.0));\n}\n\nfloat EllipsoidDistanceField( in vec3 point, in vec3 bounds )\n{\n    return (length( point/bounds ) - 1.0) * min(min(bounds.x,bounds.y),bounds.z);\n}\n\nfloat CapsuleDistanceField( vec3 point, vec3 capsuleStart, vec3 capsuleEnd, float radius )\n{\n    vec3 pa = point - capsuleStart, ba = capsuleEnd - capsuleStart;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - radius;\n}\n                         \n                         \n          \n// Distortion Methods\n\nvec3 Translate(in vec3 point,\n               in WorldObject object)\n{\n    return point - object.m_Position;\n}\n\nvec3 Scale(in vec3 point,\n           in WorldObject object)\n{\n    return point / object.m_Scale;\n}\n               \n\nvec3 Repeat(in vec3 point,\n            in vec3 axis,\n            in vec3 repeatFactor)\n{\n    vec3 repeatedPoint;\n    repeatedPoint = mod(point, repeatFactor) - repeatFactor * 0.5;\n    repeatedPoint = repeatedPoint * axis + (vec3(1) - axis) * point;\n    \n    return repeatedPoint;\n}\n\n// Scene creation\nfloat Union(float left, float right)\n{\n    return min(left, right);\n}\n\nfloat Substraction(float source, float substract)\n{\n    return max(source, -substract);\n}\n\nfloat Intersection(float left, float right)\n{\n    return max(left, right);\n}\n\n// Retrieve the normal for the world\nvec3 CalculateWorldNormal(in vec3 point)\n{\n    const float SAMPLE_SIZE = 0.0001;\n    vec3 gradient = vec3(0);\n    \n    float leftStep = 0.0;\n    float rightStep = 0.0;\n    Material unusedColor;\n    \n    RenderImage(point + vec3(SAMPLE_SIZE, 0,0), leftStep, unusedColor);\n    RenderImage(point - vec3(SAMPLE_SIZE, 0,0), rightStep, unusedColor);\n    gradient.x = leftStep - rightStep;\n    \n    RenderImage(point + vec3(0, SAMPLE_SIZE,0), leftStep, unusedColor);\n    RenderImage(point - vec3(0, SAMPLE_SIZE,0), rightStep, unusedColor);\n    gradient.y = leftStep - rightStep;\n    \n    RenderImage(point + vec3(0, 0,SAMPLE_SIZE), leftStep, unusedColor);\n    RenderImage(point - vec3(0, 0,SAMPLE_SIZE), rightStep, unusedColor);\n    gradient.z = leftStep - rightStep;\n    \n    return normalize(gradient);\n}\n\nMaterial DetermineFieldMaterial(in float fieldValue, \n                    \t\t\tin WorldObject object)\n{\n    Material determinedMaterial;\n    determinedMaterial.m_Color = object.m_Material.m_Color * Equal(object.m_DistanceField, fieldValue);\n\tdeterminedMaterial.m_EmissiveColor = object.m_Material.m_EmissiveColor * Equal(object.m_DistanceField, fieldValue);\n    determinedMaterial.m_Specular = object.m_Material.m_Specular * Equal(object.m_DistanceField, fieldValue);\n    determinedMaterial.m_Reflection = object.m_Material.m_Reflection * Equal(object.m_DistanceField, fieldValue);\n    determinedMaterial.m_Refraction = object.m_Material.m_Refraction * Equal(object.m_DistanceField, fieldValue);\n    determinedMaterial.m_Opacity = object.m_Material.m_Opacity * Equal(object.m_DistanceField, fieldValue);\n    return determinedMaterial;\n}\n\nMaterial AddMaterial(in Material left,\n                     in Material right)\n{\n    Material result;\n    result.m_Color = left.m_Color + right.m_Color;\n    result.m_EmissiveColor = left.m_EmissiveColor + right.m_EmissiveColor;\n    result.m_Specular = left.m_Specular + right.m_Specular;\n    result.m_Reflection = left.m_Reflection + right.m_Reflection;\n    result.m_Refraction = left.m_Refraction + right.m_Refraction;\n    result.m_Opacity = left.m_Opacity + right.m_Opacity;\n    return result;\n}\n\nvoid RenderImage(in vec3 point, \n                 out float stepSize, \n                 out Material material)\n{\n    \n    vec3 monsterPosition = vec3(sin(iTime), cos(iTime) - 2.0, -2.0) * 0.1;\n    vec3 monsterPoint = point- monsterPosition;\n    \n    // Create the monster body\n    WorldObject monsterBody;\n    monsterBody.m_Position = vec3(0.0, 0.0, 2.0);\n    \n    float colorAmplitude = max(cos(iTime*1.2), 0.4);\n    monsterBody.m_Material.m_Color = texture(iChannel3, monsterPoint.xy * 0.05) * colorAmplitude;\n    monsterBody.m_Material.m_Specular = 1000.0;\n    monsterBody.m_Material.m_Opacity = 1.0;\n    \n    vec3 shapePoint = monsterPoint;\n    vec3 pointDistortion = monsterPoint;\n    float monsterRadius = 0.5;\n    pointDistortion.y *= step(pointDistortion.y, monsterRadius);\n    float monsterBottom = 1.0;\n    pointDistortion.y *= step(-monsterBottom, pointDistortion.y);\n    \n    \n    // Calculate the \"blobiness\"\n    float blobOffset = 0.3 + sin(iTime) * 0.1;\n    blobOffset = blobOffset;\n    \n    float pointHeight = sin(pointDistortion.y * 3.14159) * blobOffset;\n    pointDistortion.y = mix(pointHeight, pointDistortion.y, 0.5);\n    \n    monsterRadius -= pointDistortion.y;\n    \n    shapePoint = Translate(shapePoint, monsterBody);\n    \n    monsterBody.m_DistanceField = SphereDistanceField(shapePoint, monsterRadius);\n    \n    \n    // Create the monster's mouth\n    WorldObject monsterMouth;\n    monsterMouth.m_Position = monsterBody.m_Position - vec3(-0.3, 0.4 - max(sin(iTime * 4.0)* 0.02, 0.0),monsterRadius - 0.05);\n    \n    shapePoint = monsterPoint;\n    shapePoint = Translate(shapePoint, monsterMouth);\n    monsterMouth.m_DistanceField = SphereDistanceField(shapePoint, 0.1);\n    \n    monsterBody.m_DistanceField = Union(monsterBody.m_DistanceField, monsterMouth.m_DistanceField);\n    \n    monsterMouth.m_Position = monsterBody.m_Position - vec3(-0.3, 0.53 + max(sin(iTime* 4.0)* 0.02, 0.0),monsterRadius - 0.1);\n    \n    shapePoint = monsterPoint;\n    shapePoint = Translate(shapePoint, monsterMouth);\n    monsterMouth.m_DistanceField = SphereDistanceField(shapePoint, 0.1);\n    \n    monsterBody.m_DistanceField = Union(monsterBody.m_DistanceField, monsterMouth.m_DistanceField);\n    \n    float handHeight \t= (iMouse.y / iResolution.y) * 0.4;\n    float handSide\t\t= (iMouse.x / iResolution.x) * 0.3;\n    \n    // Create the monster hand\n    WorldObject monsterHand;\n    monsterHand.m_Position = monsterBody.m_Position + vec3(1.0 + handSide * 0.5, -0.5 + handHeight, -0.5);\n    \n    shapePoint = monsterPoint;\n    shapePoint = Translate(shapePoint, monsterHand);\n    monsterHand.m_DistanceField = SphereDistanceField(shapePoint, 0.2);\n    \n    monsterBody.m_DistanceField = Union(monsterBody.m_DistanceField, monsterHand.m_DistanceField);\n    \n    \n    // Create the left monster hand\n    monsterHand.m_Position = monsterBody.m_Position + vec3(-1.0 + handSide * 0.5, -0.5 + handHeight, -0.5);\n    \n    shapePoint = monsterPoint;\n    shapePoint = Translate(shapePoint, monsterHand);\n    monsterHand.m_DistanceField = SphereDistanceField(shapePoint, 0.2);\n    \n    monsterBody.m_DistanceField = Union(monsterBody.m_DistanceField, monsterHand.m_DistanceField);\n    \n    // Create the monster eye\n    WorldObject monsterEye;\n    monsterEye.m_Position = vec3(0.0, cos(iTime* 1.2) * 0.1 + 0.3, 1.5);\n    \n    // Calculate the eye and color\n    vec4 eyeLidColor =texture(iChannel3, monsterPoint.xy * 0.05) * colorAmplitude;\n    vec4 eyeColor = vec4(1.0);\n    \n    float irisRadius \t= 0.1;\n    vec2 irisPosition = monsterEye.m_Position.xy - vec2(-0.05, 0.1);\n    \n\tvec2 uv = iMouse.xy / iResolution.xy;\n    vec2 screenSpace = ShiftRange(vec2(0, 1), vec2(-1, 1), uv);\n    \n    irisPosition += screenSpace * 0.1;\n    \n    float inEyeLid = step(irisPosition.y + irisRadius * 0.6, monsterPoint.y);\n    vec4 currentEyeColor = eyeLidColor * inEyeLid + eyeColor * (1.0 - inEyeLid);\n    \n    float irisDistance \t= distance(monsterPoint.xy, irisPosition);\n    \n    float retinaLength = 0.05;\n    vec4 irisColor \t\t= vec4(0);\n    vec4 retinaColor \t= texture(iChannel3, point.xy) * 3.0 * vec4(0.2, 0.3, 0.5, 1.0) * (cos((max(irisDistance - (irisRadius - retinaLength),0.0) / retinaLength) * (3.14/2.0)) * 0.6 + 0.4);\n    float retinaRadius\t= irisRadius - retinaLength;\n    \n    float inRetina \t\t= step(irisDistance, retinaRadius);\n    irisColor \t\t\t= irisColor * inRetina + retinaColor * (1.0 - inRetina);\n    float inIris \t\t= step(irisDistance, irisRadius);\n    \n    float inIrisNotEyeLid = inIris * (1.0 - inEyeLid);\n    currentEyeColor = currentEyeColor * (1.0 - inIrisNotEyeLid) + irisColor * inIrisNotEyeLid;\n    \n    monsterEye.m_Material.m_Color = currentEyeColor;\n    monsterEye.m_Material.m_Specular = 1000.0;\n    monsterEye.m_Material.m_Opacity = 1.0;\n    \n    \n    shapePoint = monsterPoint;\n    vec3 monsterEyeBounds = vec3(0.2, 0.3, 0.2);\n    \n    shapePoint = Translate(shapePoint, monsterEye);\n    monsterEye.m_DistanceField = EllipsoidDistanceField(shapePoint, monsterEyeBounds);\n    \n    \n    WorldObject monsterEyeBrow;\n    monsterEyeBrow.m_Position = vec3(0.0, cos(iTime* 1.2) * 0.1 + 0.8, 1.5);\n    \n    monsterEyeBrow.m_Material.m_Specular =40.0;\n    monsterEyeBrow.m_Material.m_Opacity = 1.0;\n    \n    shapePoint = monsterPoint;\n    \n    shapePoint.y += sin(shapePoint.x * 10.0 + iTime * 3.0) * 0.05;\n    shapePoint = Translate(shapePoint, monsterEyeBrow);\n    float browLength = 0.3;\n    float browRadius = 0.1;\n    monsterEyeBrow.m_DistanceField = CapsuleDistanceField(shapePoint, vec3(-browLength / 2.0, 0.0, 0.0),\n                                                          vec3(browLength / 2.0, 0.0, 0.0), browRadius);\n    \n    monsterEyeBrow.m_Material.m_Color = texture(iChannel2, shapePoint.xy);\n    \n    // Create a floor\n    WorldObject floorPlane;\n    floorPlane.m_Position = vec3(0, -2.5, 0);\n    floorPlane.m_Material.m_Color = texture(iChannel0, point.xz * 0.5);\n    floorPlane.m_Material.m_Specular = 40.0;\n    floorPlane.m_Material.m_Opacity = 1.0;\n    floorPlane.m_Material.m_Reflection = 1.0;\n    \n    shapePoint = point;\n    \n    shapePoint = Translate(shapePoint, floorPlane);\n    floorPlane.m_DistanceField = PlaneDistanceField(shapePoint, vec3(0, 1,0));\n    \n    // Create a back wall\n    WorldObject backWall;\n    backWall.m_Position = vec3(0, 0, 5);\n    backWall.m_Material.m_Color = texture(iChannel1, point.xy * 0.25);\n    backWall.m_Material.m_Specular = 40.0;\n    backWall.m_Material.m_Reflection = 0.0;\n    backWall.m_Material.m_Opacity = 1.0;\n    \n    shapePoint = point;\n    shapePoint = Translate(shapePoint, backWall);\n    \n    backWall.m_DistanceField = PlaneDistanceField(shapePoint, vec3(0, 0, 1));\n    \n    \n    stepSize = 1000000.0;\n    stepSize = Union(stepSize, floorPlane.m_DistanceField);\n    stepSize = Union(stepSize, backWall.m_DistanceField);\n    stepSize = Union(stepSize, monsterBody.m_DistanceField);\n    stepSize = Union(stepSize, monsterEye.m_DistanceField);\n    stepSize = Union(stepSize, monsterEyeBrow.m_DistanceField);\n    \n    material = AddMaterial(material, DetermineFieldMaterial(stepSize, floorPlane));\n    material = AddMaterial(material, DetermineFieldMaterial(stepSize, backWall));\n    material = AddMaterial(material, DetermineFieldMaterial(stepSize, monsterBody));\n    material = AddMaterial(material, DetermineFieldMaterial(stepSize, monsterEye));\n    material = AddMaterial(material, DetermineFieldMaterial(stepSize, monsterEyeBrow));\n    \n}\n\nstruct PointLightData\n{\n    vec3 \tm_Position;\n    float \tm_AttenuationRadius;\n    float \tm_AttenuationExponent;\n    vec4 \tm_Color;\n};\n\n    \nvec4 CalculatePointLight(in vec3 point,\n                in PointLightData light,\n                in Material material,\n                in vec3 normal)\n{\n    vec3 worldNormal = normal;\n    vec3 surfaceToLight = normalize(light.m_Position - point);\n    vec3 surfaceToEye = normalize(g_MainCamera.m_Position -  point);\n    \n    float distanceToLight = length(light.m_Position - point);\n    float shiftedLightDistance = distanceToLight / light.m_AttenuationRadius;\n    float unitDistance = (1.0 - shiftedLightDistance);\n    unitDistance = 1.0 / (distanceToLight);\n    \n    // Calculate how much diffuse\n    float diffuseFactor = dot(surfaceToLight, worldNormal) * 0.5 + 0.5;\n    vec4 diffuseColor = material.m_Color * diffuseFactor * unitDistance * (vec4(1.0) + light.m_Color);\n    \n    // Calculate the specular factor\n    vec3 halfVector = (surfaceToLight + surfaceToEye) / 2.0;\n    float specularFactor = dot(halfVector, worldNormal) * 0.5 + 0.5;\n    specularFactor = pow(specularFactor, material.m_Specular);\n    vec4 specularColor = normalize(light.m_Color) * specularFactor;\n    \n    return diffuseColor + specularColor;\n    \n}\n\nvoid CalculateShadingFactor(in vec3 point,\n                            in vec3 lightPos,\n                            out float shadingFactor)\n{\n    const float SHADING_EPSILON = EPSILON * 0.001;\n    const float PRENUMBRA_FACTOR = 0.02;\n    const float PRENUMBRA_DISTANCE = 0.007;\n    \n    \n    vec3 direction = normalize(lightPos - point);\n    vec3 origin = point;\n    Material unusedColor;\n    \n    shadingFactor = 0.0;\n    \n    float distanceToLight = distance(point, lightPos);\n    float currentStep = 0.0;\n    for(int i = 0; i < SHADING_MAX_STEPS; ++i)\n    {\n        // March the ray and check if we intersect\n        vec3 currentPoint = point + direction * currentStep;\n        float stepSize = 0.0;\n        RenderImage(currentPoint, stepSize, unusedColor);\n        \n        if(stepSize < SHADING_EPSILON *float(i))\n        {\n            float softness = max(1.0 - (stepSize / PRENUMBRA_DISTANCE), 0.0);\n            shadingFactor += PRENUMBRA_FACTOR * softness * pow(unusedColor.m_Opacity, 3.0);\n        }\n        \n        stepSize = distanceToLight / float(SHADING_MAX_STEPS);\n        currentStep += stepSize;\n    }\n    \n    shadingFactor = max(1.0 - shadingFactor, 0.0);\n    \n}\n\nvec4 RenderLighting(in vec3 point,\n                    in Material material,\n                    in vec3 normal)\n{\n    PointLightData centerLight;\n    centerLight.m_Position = vec3(0.5,1.0, -1.0);\n    centerLight.m_AttenuationRadius = 20.0;\n    centerLight.m_AttenuationExponent = 2.0;\n    centerLight.m_Color = vec4(vec3(5.0, 5.0, 3.5), 0.0);\n    \n    vec4 lighting = CalculatePointLight(point, centerLight, material, normal);\n    \n    #ifdef SHADOWS\n    float shading = 0.0;\n    CalculateShadingFactor(point, centerLight.m_Position, shading);\n    lighting *= shading;\n    #endif\n    \n    \n    return lighting;\n}\n\nvec4 RenderScene(in vec3 point,\n                 in vec3 direction,\n                 out vec3 normal,\n\t\t\t\t out vec3 position,\n                 out Material material)\n{\n    vec4 finalColor;\n    \n    float currentStep = 0.0;\n    for(int i = 0; i < SECONDARY_MAX_STEPS; ++i)\n    {\n        vec3 worldPoint = CalculateWorldPoint(point, direction, currentStep);\n        \n        float stepSize = 0.0;\n        Material objectMaterial;\n        \n        RenderImage(worldPoint, stepSize, objectMaterial);\n        \n        if(stepSize < EPSILON * float(i))\n        {\n            vec3 normal = CalculateWorldNormal(worldPoint);\n            vec4 lightingColor = RenderLighting(worldPoint, objectMaterial, normal);\n            \n            finalColor \t= lightingColor;\n            position \t= worldPoint;\n            normal \t\t= CalculateWorldNormal(worldPoint);\n            material \t= objectMaterial;\n            break;\n        }\n        \n        currentStep += stepSize * STEP_REDUCTION;\n        \n    }\n    \n    return finalColor;\n}\n\nconst vec4 WORLD_COLOR = vec4(0, 0, 0, 1);\n                                  \nvoid mainImage(out vec4 fragColor, \n               in vec2 fragCoord )\n{\n    \n    vec4 finalColor = WORLD_COLOR;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 screenSpace = ShiftRange(vec2(0, 1), vec2(-1, 1), uv);\n    \n    Camera camera;\n    camera.m_Up \t\t\t= vec3(0,1,0);\n    camera.m_Forward \t\t= vec3(0,0,1);\n    camera.m_Right\t\t\t= normalize(cross(camera.m_Up, camera.m_Forward));\n    camera.m_FocalDistance \t= 1.0;\n    camera.m_Position \t\t= vec3(0,0,-1);\n    vec3 cameraRay = RayDirection(camera.m_Forward,\n                                  camera.m_FocalDistance,\n                                  camera.m_Right,\n                                  camera.m_Up,\n                                  screenSpace,\n                                  iResolution.x / iResolution.y);\n    \n    g_MainCamera = camera;\n    \n    float previousStep = 0.0;\n    float currentStep = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; ++i)\n    {\n        vec3 worldPoint = CalculateWorldPoint(camera.m_Position, cameraRay, currentStep);\n        \n        Material objectMaterial;\n        float renderStep = 0.0;\n        \n        RenderImage(worldPoint, renderStep, objectMaterial);\n        \n        // multiply the epsilon to be more lenient towards the back\n        if(renderStep < EPSILON * float(i))\n        {\n            vec3 normal = CalculateWorldNormal(worldPoint);\n            vec4 lightingColor =  RenderLighting(worldPoint, objectMaterial, normal);\n            \n            finalColor = lightingColor;\n            finalColor += objectMaterial.m_EmissiveColor;\n            \n            #ifdef REFLECTION\n            vec3 reflectionNormal \t= vec3(0);\n            vec3 reflectionPoint \t= vec3(0);\n            Material reflectionMaterial;\n\t\t\tvec4 reflectionColor = RenderScene(worldPoint, reflect(cameraRay, normal), \n                                               reflectionNormal, reflectionPoint, reflectionMaterial);\n            \n            finalColor = mix(finalColor, reflectionColor, objectMaterial.m_Reflection);\n            \n            for(int i = 1; i < SECONDARY_RAY_COUNT; i++)\n            {\n                float reflectionFactor = reflectionMaterial.m_Reflection;\n                reflectionColor = RenderScene(reflectionPoint, reflect(cameraRay, reflectionNormal), \n                                               reflectionNormal, reflectionPoint, reflectionMaterial);\n            \n            \tfinalColor = mix(finalColor, reflectionColor, reflectionFactor);\n            }\n            \n            #endif\n            \n            \n            #ifdef TRANSPARANCY\n            vec3 transNormal = vec3(0);\n            vec3 transPoint  = vec3(0);\n            vec3 transDirection = vec3(0);\n            Material transMaterial;\n            \n            // jump past the object for transparancy\n            transPoint = CalculateWorldPoint(camera.m_Position, cameraRay, currentStep * 3.1);\n            vec4 transparancyColor = RenderScene(transPoint, refract(cameraRay, normal, objectMaterial.m_Refraction),\n                                                transNormal, transPoint, transMaterial);\n            \n            \n            \n            finalColor = mix(transparancyColor, finalColor, objectMaterial.m_Opacity);\n            \n            transDirection = cameraRay;\n            \n            for(int i = 1; i < SECONDARY_RAY_COUNT; i++)\n            {\n                float opacityFactor = transMaterial.m_Opacity;\n                // jump past the object for transparancy\n            \ttransPoint = CalculateWorldPoint(transPoint, transDirection, currentStep + 0.5);\n                \n                transDirection = refract(cameraRay, transNormal, transMaterial.m_Refraction);\n            \tvec4 transparancyColor = RenderScene(transPoint, transDirection,\n                                                transNormal, transPoint, transMaterial);\n            \n            \n            \n            \tfinalColor = mix(transparancyColor, finalColor, opacityFactor);\n            }\n            \n            #endif\n            break;\n        }\n        previousStep = renderStep;\n        currentStep += renderStep * STEP_REDUCTION;\n    }\n    \n\tfragColor = pow(finalColor, vec4(1.0/2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}