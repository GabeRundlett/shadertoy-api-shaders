{
    "Shader": {
        "info": {
            "date": "1709919038",
            "description": "A remake of FEZ, a neat game about perspective.\nUse A and D to rotate, arrow keys to move\n\nmaking the player physics is such a pain",
            "flags": 48,
            "hasliked": 0,
            "id": "MXlSz2",
            "likes": 5,
            "name": "FEZ (engine)",
            "published": 3,
            "tags": [
                "game",
                "voxel",
                "orthographic",
                "fez",
                "polytron",
                "gomez"
            ],
            "usePreview": 0,
            "username": "aerowave",
            "viewed": 267
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord - floor(iResolution.xy * 0.5);\n    \n    vec4 playerData = texelFetch(iChannel0, ivec2(2,0), 0);\n    \n    // dynamic scaling that always is pixel perfect\n    float scale = clamp(round(iResolution.y / 384.0), 1.0, 8.0);\n    uv /= scale;\n    uv.y += 24.0;\n\n    // animation\n    //float rotation = mod(abs(sin(iTime * PI) * 0.5) + iTime * PI * 0.5, PI * 2.0);\n\n    float rotation = texelFetch(iChannel0, ivec2(1,0), 0).x;\n\n    // move the camera back a bunch (avoids clipping)\n    vec3 rayPos = vec3(uv, -float(MAX_STEPS) * 8.0);\n    rotate(rayPos.xz, PI * 0.5 - rotation);\n    vec3 rayDir = vec3(cos(rotation), 0.0, sin(rotation));\n\n    HitInfo info = castRay(rayPos, rayDir);\n    \n    vec3 tileUV = mod(info.pos, vec3(1.0));\n    vec3 col = vec3(0.0);\n    \n    // sky\n    if (info.tile.ID == 0) {\n        col = vec3(0, 0.8, 1.0);\n        //if (mod(playerData.w, 2.0) == 0.0) col *= 0.5;\n    } else {        \n        // apply tile texture\n        //col = vec3(1.0);\n        col = blockTexture(vec2(tileUV.x + tileUV.z, tileUV.y) * 16.0);\n        \n        // add grass texture if tile above is air\n        if (world(floor(info.pos + rayDir * 0.001) + vec3(0,1,0)).ID == 0) {\n            vec4 grass = grassTexture(vec2(tileUV.x + tileUV.z, tileUV.y) * 16.0);\n            if (grass.a == 1.0)\n                col = grass.rgb;\n        }\n        \n        // shadows under tiles\n        if (world(floor(info.pos - rayDir * 0.001) + vec3(0,1,0)).ID != 0) {\n            col *= 1.0 - mod(info.pos.y, 1.0) * 0.5;\n        }\n        // basic directional shading\n        col *= mix(1.0, 0.8, info.normal.z);\n    }\n\n    float playerDepth = dot(playerData.xyz * 0.0625, rayDir);\n    float worldDepth = dot(info.pos, rayDir);\n    \n    //col = vec3(0.2 - worldDepth * 0.1);\n    \n    tileUV = rayPos - playerData.xyz;\n    rotate(tileUV.xz, rotation);\n    vec4 playerColor = playerTexture(tileUV.zy - 8.0);\n    \n\n    \n    \n    if (playerColor.a == 1.0 && abs(tileUV.z) < 8.0 && abs(tileUV.y) < 8.0) {\n        if (mod(playerData.w, 2.0) == 1.0 || playerDepth <= worldDepth) {\n            col = playerColor.xyz;\n        } else {\n            col *= 0.5;\n        }\n        \n    }\n    \n   \n    \n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// rotation matrix thing\nvoid rotate(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nconst float PI = acos(0.0) * 2.0;\nconst int MAX_STEPS = 48;\n\nstruct Tile {\n    int ID;\n};\n\nTile world(vec3 p) {\n    p = floor(p) + 0.5;\n    \n    if (abs(p.y + 6.0) < 1.0 && abs(p.x - 1.0) < 2.0 && abs(p.z - 4.0) < 5.0) return Tile(1);\n    \n    if (abs(p.y + 4.0) < 2.0 && abs(p.x - 3.0) < 2.0 && abs(p.z - 6.0) < 2.0) return Tile(1);\n    \n    if (abs(p.y - 4.0) < 1.0 && abs(p.x + 4.5) < 1.5 && abs(p.z - 5.0) < 1.0) return Tile(1);\n    \n    if (abs(p.y - 0.5) < 6.5 && abs(p.x - 5.0) < 2.0 && abs(p.z + 1.5) < 4.0) return Tile(1);\n            \n    if (abs(p.y - 4.0) < 1.0 && abs(p.x - 4.0) < 1.0 && abs(p.z + 3.0) < 2.0) return Tile(1);\n\n    if (abs(p.y + 1.0) < 1.0 && abs(p.x - 7.0) < 2.0 && abs(p.z + 4.0) < 1.0) return Tile(1);\n    \n    if (length(p.xyz + vec3(8,0,9)) < 2.5) return Tile(1);\n    \n    return Tile(0);\n}\n\nstruct HitInfo {\n    Tile tile;\n    vec3 pos;\n    vec3 normal;\n};\n\nHitInfo castRay(vec3 rayPos, vec3 rayDir) {\n    Tile tile;\n    rayPos *= 0.0625;\n\n    // this entire function was stolen from https://www.shadertoy.com/view/4dX3zl\n    // not too sure how it works, but it's much faster than what i had before\n\tvec3 mapPos = floor(rayPos);\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n\tvec3 rayStep = sign(rayDir);\n\tvec3 sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\tvec3 mask;\n\t\n\tfor (int i = 0; i < MAX_STEPS; i++) {\n        tile = world(mapPos);\n\t\tif (tile.ID != 0) break;\n\t\tmask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy) + 0.000000001; // for some reason some gpus won't render anything if this isn't here, spooky\n\t\tsideDist += mask * deltaDist;\n\t\tmapPos += mask * rayStep;\n\t}\n    \n    rayPos = rayDir / dot(mask * rayDir, vec3(1.0)) * dot(mask * (mapPos + vec3(lessThan(rayDir, vec3(0.0))) - rayPos), vec3(1.0)) + rayPos;\n    rayPos = rayDir / dot(mask * rayDir, vec3(1.0)) * dot(mask * (mapPos + vec3(lessThan(rayDir, vec3(0.0))) - rayPos), vec3(1.0)) + rayPos;\n    \n    return HitInfo(tile, rayPos, mask);\n}\n\n\n// the only way i know how to import custom textures is to hard code them\n// this will definitely change in future versions\nvec3 blockTexture(vec2 p) {\n    vec3[] palette = vec3[](vec3(0.5, 0.25, 0.25), vec3(0.8, 0.5, 0.25), vec3(1,0.75,0.15));\n    int[] pixels = int[](\n        1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n        0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,\n        0,2,1,1,1,1,1,1,1,1,1,1,1,1,0,2,\n        0,2,1,1,2,2,2,2,2,2,2,2,2,1,0,2,\n        0,2,1,0,1,1,1,1,1,1,1,1,2,1,0,2,\n        0,2,1,0,1,1,1,1,1,1,1,1,2,1,0,2,\n        0,2,1,0,1,1,1,1,1,1,1,1,2,1,0,2,\n        0,2,1,0,1,1,1,1,1,1,1,1,2,1,0,2,\n        0,2,1,0,1,1,1,1,1,1,1,1,2,1,0,2,\n        0,2,1,0,1,1,1,1,1,1,1,1,2,1,0,2,\n        0,2,1,0,1,1,1,1,1,1,1,1,2,1,0,2,\n        0,2,1,0,1,1,1,1,1,1,1,1,2,1,0,2,\n        0,2,1,0,0,0,0,0,0,0,0,0,1,1,0,2,\n        0,2,1,1,1,1,1,1,1,1,1,1,1,1,0,2,\n        0,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1\n    );\n    return palette[pixels[int(mod(floor(p.x), 16.0) + mod(floor(16.0-p.y), 16.0) * 16.0)]];\n}\n\nvec4 grassTexture(vec2 p) {\n    vec4[] palette = vec4[](vec4(0), vec4(0.8, 1.0, 0.0, 1), vec4(0.4, 0.8, 0.0, 1), vec4(0.3, 0.7, 0.0, 1), vec4(0.5, 0.25, 0.25, 1));\n    int[] pixels = int[](\n        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n        2,1,1,1,2,2,2,2,1,1,2,2,2,2,2,2,\n        2,2,2,2,2,3,3,2,2,2,2,3,3,3,3,3,\n        3,3,3,3,3,4,4,3,3,3,3,4,4,4,4,4,\n        4,4,4,4,4,0,0,4,4,4,4,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n    );\n    return palette[pixels[int(mod(floor(p.x), 16.0) + mod(floor(16.0-p.y), 16.0) * 16.0)]];\n}\n\nvec4 playerTexture(vec2 p) {\n    vec4[] palette = vec4[](vec4(0), vec4(1), vec4(0.8,0.8,0.7,1), vec4(0.7,0.7,0.5,1), vec4(0, 0, 0, 1));\n    int[] pixels = int[](\n        0,3,2,1,1,1,1,1,1,1,1,1,0,0,0,0,\n        3,2,2,1,1,1,1,1,1,1,1,1,1,0,0,0,\n        3,2,1,1,1,1,1,1,1,1,1,1,1,0,0,0,\n        3,2,1,4,1,1,1,1,1,1,1,4,1,0,0,0,\n        3,2,1,1,1,1,1,1,1,1,1,1,1,0,0,0,\n        3,2,2,1,1,1,1,1,1,1,1,1,1,0,0,0,\n        0,3,3,2,1,1,1,1,1,1,1,1,0,0,0,0,\n        0,0,0,0,3,3,2,1,0,0,0,0,0,0,0,0,\n        0,0,0,3,2,1,1,1,1,0,0,0,0,0,0,0,\n        0,0,3,1,1,1,1,1,1,0,0,0,0,0,0,0,\n        0,3,1,3,1,1,1,1,1,3,0,0,0,0,0,0,\n        0,0,0,3,2,1,1,1,1,0,0,0,0,0,0,0,\n        0,0,0,3,2,1,1,1,1,0,0,0,0,0,0,0,\n        0,0,0,3,2,2,1,1,1,0,0,0,0,0,0,0,\n        0,0,0,3,2,0,0,3,2,0,0,0,0,0,0,0,\n        0,0,0,3,0,0,0,0,3,0,0,0,0,0,0,0\n    );\n    return palette[pixels[int(mod(floor(p.x), 16.0) + mod(floor(16.0-p.y), 16.0) * 16.0)]];\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const float EPSILON = 0.001;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    fragCoord -= 0.5;\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    if (fragCoord.y > 1.0) discard;\n\n    // target rotation\n    if (fragCoord.x == 0.0) {\n        vec3 playerPos = texelFetch(iChannel0, ivec2(2,0), 0).xyz;\n        float rotation = (texelFetch(iChannel1, ivec2(68, 1), 0).x - texelFetch(iChannel1, ivec2(65, 1), 0).x) * PI * 0.5;\n        \n        fragColor.x += rotation;\n        fragColor.x = mod(fragColor.x, 2.0 * PI);\n        if (abs(rotation) > 0.0)\n            fragColor.y = iTime;\n    }\n    \n    // actual rotation\n    if (fragCoord.x == 1.0) {\n        if (iFrame == 0)\n            fragColor.x = PI;\n            \n        vec4 target = texelFetch(iChannel0, ivec2(0), 0);\n        \n        fragColor.x = mod(fragColor.x, 2.0 * PI);\n        \n        // calculate shortest distance to rotate to target\n        float difference = target.x - fragColor.x;\n        float difference2 = difference - 2.0 * PI;\n        float difference3 = difference + 2.0 * PI;\n        if (abs(difference) < abs(difference2))\n            if (abs(difference) < abs(difference3))\n                difference = difference;\n            else\n                difference = difference3;\n        else\n            difference = difference2;\n        \n        // rotate\n        fragColor.x += (min(iTime - target.y, iTime * 0.05) * difference) * iTimeDelta * 32.0;\n        \n        // snap to nearest cardinal direction\n        if (mod(fragColor.x, PI * 0.5) < EPSILON || mod(fragColor.x, PI * 0.5) > PI * 0.5 - EPSILON)\n            fragColor.x = mod(round(fragColor.x * 2.0 / PI) * 0.5 * PI, 2.0 * PI);\n        \n    }\n    \n    // player position vec4(x, y, z, w)\n    // w % 2 == 1: playerIsInFront\n    // w % 4 < 2: playerIsGrounded\n    if (fragCoord.x == 2.0) {\n        if (iFrame == 0)\n            fragColor.xyz = vec3(0,-72,0);\n    \n        float rotation = texelFetch(iChannel0, ivec2(1,0), 0).x;\n        \n        // don't move player if rotating\n        if (mod(rotation, PI * 0.5) < EPSILON && mod(rotation, PI * 0.5) < PI * 0.5 - EPSILON) {\n        \n            float leftKey = texelFetch(iChannel1, ivec2(37, 0), 0).x;\n            float rightKey = texelFetch(iChannel1, ivec2(39, 0), 0).x;\n            \n            vec2 trig = vec2(cos(rotation), sin(rotation));\n            vec3 playerVelocity = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n            \n            fragColor.x -= trig.y * (leftKey - rightKey) * (iTimeDelta * 80.0);\n            fragColor.z += trig.x * (leftKey - rightKey) * (iTimeDelta * 80.0);\n\n            fragColor.y += playerVelocity.y * iTimeDelta * 16.0;\n            \n            Tile tile; \n            vec3 samplePos = fragColor.xyz;\n            \n            // check if player is not behind tiles\n            if (mod(fragColor.w, 2.0) == 1.0) {\n                samplePos.xz -= trig * 8.0 * float(MAX_STEPS);\n            } else {\n                for (float steps = 0.0; steps < float(MAX_STEPS); steps++) {\n                    tile = world(samplePos * 0.0625);\n                    if (tile.ID != 0) {\n                        fragColor.w = mod(fragColor.w, 4.0) < 3.0 ? 0.0 : 2.0;\n                        break;\n                    }\n                    samplePos.xz -= trig * 8.0;\n                }\n                if (tile.ID == 0)\n                    fragColor.w = mod(fragColor.w, 4.0) < 3.0 ? 1.0 : 3.0;\n                else\n                    samplePos = fragColor.xyz;\n            }\n            \n            samplePos -= vec3(0,9,0);\n            \n            // ground check: raytrace\n            for (float steps = 0.0; steps < float(MAX_STEPS); steps++) {\n                tile = world(samplePos * 0.0625);\n                if (tile.ID != 0) {\n                    break;\n                }\n                samplePos.xz += trig * 16.0;\n            }\n            // hit\n            if (tile.ID != 0 && world(samplePos * 0.0625 + vec3(0,1,0)).ID == 0 && playerVelocity.y < 0.0) {\n                fragColor.w = mod(fragColor.w, 2.0) == 0.0 ? 2.0 : 3.0;\n                // snap to ground\n                fragColor.y = floor(fragColor.y * 0.0625) * 16.0 + 8.0;\n                \n                if (mod(rotation, PI) == 0.0)\n                    fragColor.x = floor(samplePos.x * 0.0625) * 16.0 + 8.0;\n                else\n                    fragColor.z = floor(samplePos.z * 0.0625) * 16.0 + 8.0;\n            } else {\n                fragColor.w = mod(fragColor.w, 2.0) == 0.0 ? 0.0 : 1.0;\n\n                    \n            }\n\n        } else {\n            // player is rotating\n            fragColor.w = mod(fragColor.w, 4.0) < 3.0 ? 0.0 : 2.0;\n        }\n        // respawn\n        if (fragColor.y < -256.0) {\n            fragColor.xyz = vec3(0,-64,0);\n            fragColor.w = mod(fragColor.w, 4.0) < 3.0 ? 0.0 : 2.0;\n        }\n    }\n    \n    // player velocity\n    if (fragCoord.x == 3.0) {\n        vec4 temp = texelFetch(iChannel0, ivec2(2,0), 0);\n        vec3 playerPos = temp.xyz;\n        \n        float rotation = texelFetch(iChannel0, ivec2(1,0), 0).x;\n        if (mod(rotation, PI * 0.5) < EPSILON && mod(rotation, PI * 0.5) < PI * 0.5 - EPSILON) {        \n            // gravity\n            fragColor.y -= (iTimeDelta * 48.0);\n\n            // check for ground\n            if (mod(temp.w, 4.0) > 1.0) {\n                fragColor.y = 0.0;\n                \n                // jump\n                if (texelFetch(iChannel1, ivec2(32, 0), 0).x > 0.0 || texelFetch(iChannel1, ivec2(38, 0), 0).x > 0.0) {\n                    fragColor.y = 18.0;\n                }\n            }   \n        }\n        \n        if (playerPos.y + fragColor.y < -256.0)\n            fragColor.xyz = vec3(0,-1,0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}