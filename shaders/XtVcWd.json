{
    "Shader": {
        "info": {
            "date": "1538183873",
            "description": "Small iterative rendering demo. Click + drag to change the camera.\n\nIt is a very naive implementation of a scattering model where every ray has a chance to scatter before hitting its target.\n\nI know lots of code is bad, I'm doing jazz.",
            "flags": 32,
            "hasliked": 0,
            "id": "XtVcWd",
            "likes": 5,
            "name": "Foggy Path Tracing",
            "published": 3,
            "tags": [
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "JeroenDStout",
            "viewed": 655
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3  accum  = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz * vec3(1e-2);\n    float weight = texelFetch(iChannel0, ivec2(0, 0), 0).w * 1e-2;\n    \n    accum  += texelFetch(iChannel1, ivec2(fragCoord), 0).xyz;\n    weight += texelFetch(iChannel1, ivec2(0, 0), 0).w;\n    \n    fragColor.xyz = accum / weight * 2.9;\n    \n    \t// cheeky colour grade\n    float lenMul = length(fragColor.xyz);\n    fragColor.xyz *= pow(lenMul, 1.15) / lenMul;\n    fragColor.xyz = pow(fragColor.xyz, vec3(1.2));\n    fragColor.xyz -= 0.05;\n    \n    fragColor.w = 0.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 getHemi(vec3 normal, vec2 uv)\n{\n    vec3 sideX = normalize(normal + vec3(.5));\n    vec3 sideZ = normalize(cross(sideX, normal));\n         sideX = normalize(cross(sideZ, normal));\n    \n    float theta = 2.0 * 3.1415 * uv.x;\n    float psi = acos(2.0 * uv.y - 1.0);\n    float x = cos(theta) * sin(psi);\n    float y = sin(theta) * sin(psi);\n    float z = cos(psi);\n    \n    vec3 result;\n    result = sideX * x;\n    result += sideZ * y;\n    result += normal * z;\n    \n    return result;\n}\n\nvec3 getSphere( inout uint seed )\n{\n    vec2 uv = vec2(FRand( seed ), FRand( seed ));\n    \n    float theta= acos( 2.0 * uv.y - 1.0f );\n    float phi = 2.0f * 3.1415 * uv.x;\n    \n\tfloat sinTheta = sin( theta );\n\n\treturn vec3( cos( phi ) * sinTheta, sin( phi ) * sinTheta, cos( theta ) );\n}\n\nvoid sampleBoard( inout float dist, in vec3 pos, in vec3 dir, inout vec3 norm, inout vec4 colour )\n{\n    if (dir.y >= 0.)\n        return;\n    \n    float nDist = pos.y / -dir.y;\n    \n    if (nDist > dist)\n        return;    \n    \n    pos.xz += dir.xz * nDist;\n    \n\tif (abs(pos.x) > 1.1 || abs(pos.z) > 1.1)\n        return;\n    \n    dist \t= nDist;\n    norm \t= vec3(0., 1., 0.);\n    \n    if (abs(pos.x) > 1.0 || abs(pos.z) > 1.0) {\n        colour  = vec4(0.2, 0.15, 0.05, 1.6);\n    }\n    else {\n        colour  = vec4(0.9, 0.9, 0.9, 1.0);\n\n        if (floor(mod(pos.x * 4., 2.)) != floor(mod(pos.z * 4., 2.))) {\n            colour.xyz *= vec3(0.5);\n            colour.w   = 1.7;\n        }\n\n        float tileA = mod((0.125 + pos.x) * 4., 1.);\n        float tileB = mod((0.125 + pos.z) * 4., 1.);\n\n        norm.x -= (-.5 + tileA * 1.) * max(0., 1. - abs(0.5 - tileA) * 15.) * 5.;\n        norm.z -= (-.5 + tileB * 1.) * max(0., 1. - abs(0.5 - tileB) * 15.) * 5.;\n        norm = normalize(norm);\n    }\n}\n\nvoid sampleSphere( inout float dist, in vec3 pos, in vec3 dir, inout vec3 norm, inout vec4 colour,\n                   in vec3 spPos, in float radius, in vec4 mat, in float noisy )\n{    \n    // don't @ me about this code\n    \n    vec3 relPos = pos - spPos;\n    \n    relPos /= radius;\n    \n    bool inside = length(relPos) < 1.0;\n    \n    float dirDot = -dot(dir, relPos);\n    if (dirDot < 0. && !inside)\n\t\treturn;\n    \n    vec3  inPos = relPos + dir * abs(dirDot);\n    float inner = length(inPos);\n    \n    if (inner > 1.)\n        return;\n    \n    if (inside)\n        dir *= -1.;\n    \n    vec3  hit   = inPos - dir * sqrt(1. - inner * inner);\n    \n    float nDist = length(relPos - hit) * radius;\n    if (nDist >= dist)\n        return;\n    \n    dist      = nDist;\n    norm      = normalize(hit);\n    colour    = mat;\n    \n    if (noisy > 0.) {\n        vec3 onSphere = hit - spPos;\n        \n        norm.x += simplex3d(onSphere *7.) * noisy;\n        norm.y += simplex3d(onSphere *7. + vec3(384., 1012., 2840.)) * noisy;\n        norm.z += simplex3d(onSphere *7. + vec3(3356., 333., 284660.)) * noisy;\n        norm = normalize(norm);\n    }\n}\n\nvoid traceCube( inout float setDist, in vec3 pos, in vec3 dir, inout vec3 setNormal, inout vec4 setColour,\n                 in vec3 cubePos, in vec3 cubDim, mat3x3 align, in vec4 cubeColour)\n{\n    vec3 relPos = (pos-cubePos) * align;\n    vec3 relDir = dir * align;\n    \n    if (abs(relPos.x) > cubDim.x) {\n        vec3 tmpDir = relDir;\n        tmpDir.x *= -sign(relPos.x);\n        if (tmpDir.x > 0.) {\n            float travel = (abs(relPos.x) - cubDim.x) / tmpDir.x;\n            if (travel < setDist) {\n                vec3  chk    = abs(relPos + tmpDir * travel);\n                if (chk.y < cubDim.y && chk.z < cubDim.z) {\n                    setColour = cubeColour;\n                    setDist   = travel;\n                    setNormal = align[0] * sign(relPos.x);\n                    return;\n                }\n            }\n        }\n    }\n    if (abs(relPos.y) > cubDim.y) {\n        vec3 tmpDir = relDir;\n        tmpDir.y *= -sign(relPos.y);\n        if (tmpDir.y > 0.) {\n            float travel = (abs(relPos.y) - cubDim.y) / tmpDir.y;\n            if (travel < setDist) {\n                vec3  chk    = abs(relPos + tmpDir * travel);\n                if (chk.x < cubDim.x && chk.z < cubDim.z) {\n                    setColour = cubeColour;\n                    setDist   = travel;\n                    setNormal = align[1] * sign(relPos.y);\n                    return;\n                }\n            }\n        }\n    }\n    if (abs(relPos.z) > cubDim.z) {\n        vec3 tmpDir = relDir;\n        tmpDir.z *= -sign(relPos.z);\n        if (tmpDir.z > 0.) {\n            float travel = (abs(relPos.z) - cubDim.z) / tmpDir.z;\n            if (travel < setDist) {\n                vec3  chk    = abs(relPos + tmpDir * travel);\n                if (chk.x < cubDim.x && chk.y < cubDim.y) {\n                    setColour = cubeColour;\n                    setDist   = travel;\n                    setNormal = align[2] * sign(relPos.z);\n                    return;\n                }\n            }\n        }\n    }\n}\n\nvoid sampleScene( inout vec3 pos, in vec3 dir, out vec3 norm, out vec4 colour,\n                  out float dist, uint r )\n{\n    dist = 4e0;\n    \n    float cubRot = 0.7;\n    \n    mat3x3 cubeAngA, cubeAngB;\n    cubeAngA[0] = vec3(cos(cubRot), 0., sin(cubRot));\n    cubeAngA[1] = vec3(0., 1., 0.);\n    cubeAngA[2] = vec3(-sin(cubRot), 0., cos(cubRot));\n    \n    traceCube( dist, pos, dir, norm, colour, vec3(-.2, .1, -.4), vec3(0.1, 0.1, 0.1), cubeAngA, vec4(1.0, 0.8, 0.4, 2.5));\n\n    cubRot = 0.24;\n    cubeAngA[0] = vec3(cos(cubRot), 0., sin(cubRot));\n    cubeAngA[1] = vec3(0., 1., 0.);\n    cubeAngA[2] = vec3(-sin(cubRot), 0., cos(cubRot));\n    \n    traceCube( dist, pos, dir, norm, colour, vec3(-.7, .1, -.3), vec3(0.1, 0.1, 0.1), cubeAngA, vec4(9.7, 7.6, 2.2, 11.5));\n\n    cubRot = -0.3;\n    cubeAngA[0] = vec3(cos(cubRot), 0., sin(cubRot));\n    cubeAngA[1] = vec3(0., 1., 0.);\n    cubeAngA[2] = vec3(-sin(cubRot), 0., cos(cubRot));\n    \n    traceCube( dist, pos, dir, norm, colour, vec3(-.35, .25, .35), vec3(0.25, 0.25, 0.25), cubeAngA, vec4(0.98, 0.4, 0.2, 1.0));\n\n    cubRot = 0.2;\n    cubeAngA[0] = vec3(cos(cubRot), 0., sin(cubRot));\n    cubeAngA[1] = vec3(0., 1., 0.);\n    cubeAngA[2] = vec3(-sin(cubRot), 0., cos(cubRot));\n    traceCube( dist, pos, dir, norm, colour, vec3(-.2, .005, -.9), vec3(0.5, 0.005, 0.2), cubeAngA, vec4(1.0, 1.0, 1.0, 9.0));\n\n    cubRot = -0.3;\n    cubeAngA[0] = vec3(cos(cubRot), 0., sin(cubRot));\n    cubeAngA[1] = vec3(0., 1., 0.);\n    cubeAngA[2] = vec3(-sin(cubRot), 0., cos(cubRot));\n    \n    cubRot = 0.8;\n    cubeAngB[0] = vec3(cos(cubRot), sin(cubRot), 0.);\n    cubeAngB[1] = vec3(-sin(cubRot), cos(cubRot), 0.);\n    cubeAngB[2] = vec3(0., 0., 1.);\n    \n    traceCube( dist, pos, dir, norm, colour, vec3(-.74, .3665, -.3), vec3(0.5, 0.01, 0.2), cubeAngA * cubeAngB, vec4(0.95, 0.98, 0.95, 1.01));\n\n    sampleSphere( dist, pos, dir, norm, colour, vec3(-.2, .5, -.4), .3, vec4(0.5, 0.6, 0.95, -1.1), 0.);\n    sampleSphere( dist, pos, dir, norm, colour, vec3(.3, .4, .4), .4, vec4(1.0, 0.6, 0.0, 5.0), 0.);\n\n    sampleSphere( dist, pos, dir, norm, colour, vec3(.3, .2, -.2), .2, vec4(0.8, 0.3, 1.0, 1.1), 0.);\n\n    sampleSphere( dist, pos, dir, norm, colour, vec3(.8, .3, -.1), .3, vec4(0.3, 1.0, 0.3, 1.1), 0.);\n\n    sampleSphere( dist, pos, dir, norm, colour, vec3(.6, .2, -.7), .2, vec4(0.5, 0.96, 0.25, -1.7), .1);\n\n    sampleSphere( dist, pos, dir, norm, colour, vec3(.4, 2., -.2), .4, vec4(60.5, 59.3, 38.0, 11.9), 0.);\n\n\tsampleBoard( dist, pos, dir, norm, colour );\n\n    if (dist == 4e0) {\n        colour.xyz = texture(iChannel1, dir).xyz * 1.0;\n        colour.w = -1e5;\n    }\n}\n\nvoid sampleRay( in vec3 pos, in vec3 dir, out vec3 finColour, out float finWeight,\n               \tinout uint r, float maxScatter )\n{\n    finColour = vec3(0., 0., 0.);\n    finWeight = 1.;\n    \n    vec3 finPassCol = vec3(1., 1., 1.);\n    float curDensity = 1.;\n    \n    float fogY = abs(pos.y * 16.) + 0.15;\n    \n    float lastDensity = log(fogY) / 10. * sign(pos.y);\n    float lastPosY = pos.y;\n\n    for (int i = 0; i < 512; i++) {        \n        r = HashWang( r );\n        \n        vec4 outCol;\n        vec3 outNorm;\n        float outDist;\n        \n        pos += dir * 1e-5;\n        sampleScene(pos, dir, outNorm, outCol, outDist, r);\n        \n        if (curDensity == 1.) {\n            vec3 nPos = pos + dir * outDist;\n    \t\tfogY = abs(nPos.y * 16.) + 0.15;            \n            float nxDensity = log(fogY) / 10. * sign(nPos.y);\n            \n            float densDiff = abs(nxDensity - lastDensity) + 1e-5;\n            densDiff /= abs(lastPosY - nPos.y) + 1e-5;\n            densDiff += 1e-3;\n            lastPosY = nPos.y;\n            \n            lastDensity = nxDensity;\n            \n            float scatterOdds = 1.0 - pow(0.5, outDist * densDiff * 1e1);\n            float mutScatterOdds = scatterOdds;// * (0.2 + 0.8 / (1. + float(i) * 0.1));\n            \n            float scatter = FRand(r);\n            if (scatter < mutScatterOdds) {\n                finWeight *= scatterOdds / mutScatterOdds;\n                \n                vec3 scatFac = vec3(0.45, 0.50, 0.55);\n                if (scatter / mutScatterOdds < 0.2) {\n                    finPassCol *= scatFac;\n                    finWeight *= .5 / .2;\n                }\n                else {\n                    scatter = FRand(r);\n                    \n                    finPassCol *= vec3(1.) - scatFac;\n                    finWeight *= .5 / .8;\n                    \n                    vec2 rnd;\n                    rnd.x = FRand(r);\n                    rnd.y = FRand(r);\n                    pos += dir * outDist * scatter * scatter;\n                    vec3 nDir = getSphere(r);\n                    dir = normalize(nDir + dir * 0.95);// * dot(dir, nDir));\n                    fogY = abs(pos.y * 5.) + .5;            \n                    lastDensity = log(fogY) / 10. * sign(pos.y);\n                    lastPosY = pos.y;\n                    continue;\n                }\n            }\n            else {\n                finWeight *= (1.-scatterOdds) / (1.-mutScatterOdds);\n            }\n    \t\tpos += dir * outDist;\n        }\n        else {\n    \t\tpos += dir * outDist;\n            \n    \t\tfogY = abs(pos.y * 16.) + 0.15;           \n            lastDensity = log(fogY) / 10. * sign(pos.y);\n            lastPosY = pos.y;\n        }\n    \n        \n        if (outCol.w <= -1e5) {\n            finColour += outCol.xyz * finPassCol;\n            break;\n        }\n        if (max(max(finPassCol.x, finPassCol.y), finPassCol.z) < 1e-4) {\n            finColour = vec3(0.);\n            break;\n        }\n        \n        float frenInd  = mod(abs(outCol.w), 10.);\n        float frenR0   = pow((curDensity - frenInd) / (curDensity + frenInd), 2.);\n        float frenCoef = frenR0 + (1. - frenR0) * pow(1. - abs(dot(outNorm, dir)), 5.);\n        \n        float ref = FRand(r);\n        \n        if (ref < frenCoef) {\n            dir = reflect(dir, -outNorm);\n            continue;\n        }\n        \n        if (outCol.w > 10.0) {\n            finColour += outCol.xyz * finPassCol;\n            break;\n        }\n        \n        if (outCol.w < 0. && (FRand(r) < 0.9)) {        \n            float refl = -outCol.w;\n\n            if (curDensity == 1.) {\n                dir = refract(dir, outNorm, 1. / refl);\n                curDensity = frenInd;\n            }\n            else {\n                dir = refract(dir, -outNorm, refl);\n                finPassCol *= pow(outCol.xyz, vec3(outDist * 1.0));\n                curDensity = 1.;\n            }\n            continue;\n        }\n        \n        vec2 rnd;\n        rnd.x = FRand(r);\n        rnd.y = FRand(r);\n        \n        finPassCol *= outCol.xyz;        \n        \n        dir = getHemi(outNorm, rnd);\n        finPassCol *= max(0., dot(dir, outNorm));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float check = texelFetch(iChannel0, ivec2(0, 0), 0).w;\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    if (iMouse.z > 0. || check > 1000.) {\n        fragColor *= vec4(0.0);\n    }\n    float rotYZ = (1.995 - (iMouse.y / iResolution.y * 0.455)) * 3.1415;\n    float rotXZ = iMouse.x / iResolution.x * 4. * 3.1415 * 1. + 3.;\n\n    uint width = uint(iResolution.x);\n    uint height = uint(iResolution.y);\n\n    uint seed = uint(fragColor.w) + uint( iTime * 23.456 ) + uint(fragCoord.x *23.45f) * 12326u + uint(fragCoord.y * 36.43) * 42332u;\n    \n    for (uint q = uint(0); q < uint(1); q++) {    \n        vec3 camFw  = vec3(sin(rotXZ) * cos(rotYZ), sin(rotYZ), -cos(rotXZ) * cos(rotYZ));\n        \n        vec3 camPos = camFw * -0.5;\n    \tcamPos.y += 0.15;\n        \n        vec3 camR   = normalize(cross(camFw, vec3(0., 1., 0.)));\n        camFw += camR * (-.5 + FRand(seed)) * 0.035 * (1. - abs(camFw));\n        camFw += normalize(cross(camR, camFw)) * (-.5 + FRand(seed)) * 0.035 * (1. - abs(camFw));\n        \n        camPos += camFw * -2.25;\n        \n        camFw = normalize(camFw);\n        \n        vec3 camUp  = vec3(0., 1., 0.);\n        camUp -= camFw * dot(camUp, camFw);\n        camUp = normalize(camUp);\n        vec3 camRt  = cross(camFw, camUp);\n        \n        float randU = FRand(seed);\n        float randV = FRand(seed);\n        float randR = FRand(seed);\n\n        vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n        vec2 uv = fragCoord.xy;\n        uv.x += randU;\n        uv.y += randV;\n        uv = (2.0 * (uv / iResolution.xy) - 1.0) * aspect * 0.5;\n        uv *= .5;\n\n        vec3 camDir = normalize(camFw + camRt * uv.x + camUp * uv.y);\n        camPos += camDir;\n\n        vec3 finColour;\n        float finWeight;\n        sampleRay(camPos, camDir, finColour, finWeight, seed, min(0.1, fragColor.w * 1e-1));\n\n        fragColor.xyz += finColour * finWeight;\n        \n        if (fragCoord.x < 1. && fragCoord.y < 1.) {\n        \tfragColor.w += 1.;\n        }\n        else {\n        \tfragColor.w = float(seed);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// All of this is junk patched together ~ next version will do something proper\n//  now I know what a nightmare all of this is.\n\nuint HashWang( uint a )\n{\n\ta = (a ^ 61u) ^ (a >> 16u);\n\ta = a + (a << 3u);\n\ta = a ^ (a >> 4u);\n\ta = a * 0x27d4eb2du;\n\ta = a ^ (a >> 15u);\n\treturn a;\n}\n\nuint Rand( inout uint seed )\n{\n    seed += 13u;\n    return HashWang( seed );\n}\n\nfloat FRand( inout uint seed )\n{\n    uint urand = Rand( seed );    \n    const uint mantissaMask = (0xffffffffu) >> ( 32u - 23u );\n    return fract(float(urand & mantissaMask) / float(mantissaMask)); \n    //return uintBitsToFloat( (urand & mantissaMask) | (127u << 23u) );\n}\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    \n    if (iMouse.z > 0.) {\n        fragColor *= vec4(0.0);\n    }\n    \n    float check = texelFetch(iChannel0, ivec2(0, 0), 0).w;\n    \n    if (check < 1000.) {\n        return;\n    }\n    \n    fragColor += texelFetch(iChannel0, ivec2(fragCoord), 0) * vec4(1e-2);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}