{
    "Shader": {
        "info": {
            "date": "1719568456",
            "description": "Pacman",
            "flags": 0,
            "hasliked": 0,
            "id": "MXcXWj",
            "likes": 5,
            "name": "Pacman ray-marching",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "bandrieu",
            "viewed": 119
        },
        "renderpass": [
            {
                "code": "vec3 light = vec3(1,1,1);\n\nfloat sdf_sphere(in vec3 p, in vec3 c, in float r)\n{\n    return length(p - c) - r;\n}\n\nfloat sdf(in vec3 p, out int i_surf)\n{\n    float PI = 3.1415926535897931;\n    float t = mod(2.*iTime, 12.);\n    vec3 q = p;\n    q.y -= t;\n    \n    float head = sdf_sphere(q, vec3(0,0,0), 0.48);\n    float leye = sdf_sphere(q, vec3(-0.18,0.32,0.18), 0.11);\n    float reye = sdf_sphere(q, vec3( 0.18,0.32,0.18), 0.11);\n    \n    // mouth\n    float yi =  0.258;\n    float zi = -0.128;\n\n    float gamma = 2.03173778224;\n    float delta =  0.5;\n\n    float T = 0.1 + 0.45*(cos(PI*(2.*t+1.)) + 1.);\n    float A1 = cos(gamma + delta*T);\n    float B1 = -sin(gamma + delta*T);\n    float C1 = -(A1*yi + B1*zi);\n\n    float A2 = -cos(gamma - T);\n    float B2 =  sin(gamma - T);\n    float C2 = -(A2*yi + B2*zi);\n\n    float fm1 = A1*q.y + B1*q.z + C1;\n    float fm2 = A2*q.y + B2*q.z + C2;\n    float mouth = -max(fm1, fm2);\n    \n    float pacman = head;\n    i_surf = 0;\n    \n    if (mouth > pacman) {\n        pacman = mouth;\n        i_surf = 4;\n    }\n    \n    //float eye = -min(leye, reye);\n    //if (eye > pacman) {\n    float eye = min(leye, reye);\n    if (eye < pacman) {\n        pacman = eye;\n        i_surf = 3;\n    }\n    \n    // gums\n    float rgum = 0.06;\n    float zgum = zi;\n    float iy = float(int(p.y + .5));\n    \n    float rgum1 = min(0.125*(t - iy - 2.), rgum);\n    \n    if (iy > t - 1.1*rgum) {\n        float gum = sdf_sphere(vec3(p.x,p.y-iy,p.z), vec3(0,0,zgum), rgum);\n        if (gum < pacman) {\n            pacman = gum;\n            i_surf = 1;\n        }\n    }\n    else if (rgum1 > 0.) {\n        \n        float gum = sdf_sphere(vec3(p.x,p.y-iy,p.z), vec3(0,0,zgum), rgum1);\n        if (gum < pacman) {\n            pacman = gum;\n            i_surf = 1;\n        }\n    }\n    \n    float ground = p.z + 0.48;//(zgum - rgum);//0.6;\n    if (ground < pacman) {\n        pacman = ground;\n        i_surf = 2;\n    }\n    \n    return pacman;\n}\n\nvec3 normal(in vec3 p)\n{\n    const float h = 1e-4;\n    int i_surf;\n    \n    float d1 = sdf(vec3(p.x + h, p.y - h, p.z - h), i_surf);\n    float d2 = sdf(vec3(p.x - h, p.y - h, p.z + h), i_surf);\n    float d3 = sdf(vec3(p.x - h, p.y + h, p.z - h), i_surf);\n    float d4 = sdf(vec3(p.x + h, p.y + h, p.z + h), i_surf);\n    \n    vec3 n = vec3(d1 - d2 - d3 + d4, -d1 - d2 + d3 + d4, -d1 + d2 - d3 + d4);\n    n /= length(n);\n    \n    return n;\n}\n\nfloat soft_shadow(in vec3 ray_origin, in vec3 ray_direction, in float k)\n{\n    float res = 1.;\n    float t   = 0.;\n    int   i_surf;\n    \n    for (int i = 0; i < 32; i++) {\n        float h = sdf(ray_origin + t*ray_direction, i_surf);\n        res = min(res, k*h/max(t, 1e-30));\n        if (res < 1e-3) break;\n        t += clamp(h, 1e-2, 0.2);\n        \n    }\n    return clamp(res, 0., 1.);\n}\n\nint ray_march(in vec3 ray_origin, in vec3 ray_direction, out float z, out vec3 n, out float s, out vec3 p, out int i_surf)\n{\n    const int max_iter = 100;\n    const float step_factor = 0.8;\n    const float eps_step = 1e-6;\n    const float far = 100.;\n    \n    vec3 rd = ray_direction/length(ray_direction);\n    \n    p = ray_origin;\n    \n    int stat = -1;\n    \n    z = 0.;\n    \n    for (int iter = 0; iter < max_iter; iter++) {\n        float dist = sdf(p, i_surf);\n        \n        float step_size = dist * step_factor;\n        \n        if (step_size < eps_step) {\n            stat = 1;\n            break;\n        }\n        \n        p += step_size*rd;\n        \n        z += step_size;\n        \n        if (z > far) {\n            stat = 0;\n            break;\n        }\n    }\n    \n    n = normal(p);\n    \n   \n    light /= length(light);\n    \n    s = soft_shadow(p + 1e-3*n, light, 8.);\n    \n    return stat;\n}\n\nvec3 phong(in vec3 light, in vec3 eye, in vec3 pos, in vec3 normal, in vec3 diffuse, in float specularity)\n{\n    float specularExponent = 6.;\n    \n    vec3 l = light;// - pos;\n    l /= length(l);\n    \n    vec3 e = eye - pos;\n    e /= length(e);\n    \n    float ndotl = dot(normal, l);\n    vec3  r     = 2.*ndotl*normal - l;\n    \n    return diffuse * max(ndotl, 0.) + specularity*pow(max(dot(e, r),0.), specularExponent);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 CameraPosition   = vec3(5,12,1);\n    vec3 CameraFocalPoint = vec3(-5,2,0.5);\n    vec3 CameraViewUp     = vec3(0,0,1);\n    float CameraViewAngle = 36.0;\n    \n    vec3 camera_x;\n    vec3 camera_y = CameraViewUp;\n    vec3 camera_z = CameraPosition - CameraFocalPoint;\n\n    camera_y /= length(camera_y);\n    camera_z /= length(camera_z);\n    camera_x = cross(camera_y, camera_z);\n    camera_x /= length(camera_x);\n    \n    int AA_factor = 1;\n    \n    \n    float screen_distance = 0.5/tan(0.5*CameraViewAngle * 3.1415926535897931/180.);\n    vec3 screen_origin = CameraPosition - screen_distance*camera_z;\n    \n    float inv = 1./max(iResolution.x, iResolution.y);\n    float invAA = 1./float(AA_factor);\n    \n    float weight = invAA*invAA;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy - 0.5;\n    vec2 uv0 = fragCoord*inv - 0.5;\n    \n    float z = 0.;\n    vec3  n = vec3(0, 0, 0);\n    float s = 0.;\n    vec3  p = vec3(0, 0, 0);\n    float mask = 0.;\n    float i_surf = 0.;\n    \n    vec2 uv;\n    for (int ii = 0; ii < AA_factor; ii++) {\n    \n        uv.y = uv0.y + ((float(ii)+0.5)*invAA - 0.5)*inv;\n        \n        for (int jj = 0; jj < AA_factor; jj++) {\n        \n            uv.x = uv0.x + ((float(jj)+0.5)*invAA - 0.5)*inv;\n\n            vec3 ray_direction = screen_origin + uv.x*camera_x + uv.y*camera_y - CameraPosition;\n\n\n            float _z;\n            vec3  _n;\n            float _s;\n            vec3  _p;\n            int   _i_surf;\n            int stat = ray_march(CameraPosition, ray_direction, _z, _n, _s, _p, _i_surf);\n            \n            z += weight*_z;\n            n += weight*_n;\n            s += weight*_s;\n            p += weight*_p;\n            mask += weight*float(stat);\n            i_surf += weight*float(_i_surf);\n        }\n    }\n    \n    n /= length(n);\n\n\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float dot_light = clamp(dot(n, light), 0., 1.);\n    float ambient = 0.26;\n    //vec3 col = (2.*vec3(p.x,p.y,p.z) + 1.) * 0.7;\n    //vec3 col = smoothstep(1., 0., clamp(t.zxy, 0., 1.));//0.5*(n + 1.);\n    \n    vec3 col_pacman = vec3(1,0.9, 0.);\n    vec3 col_gum    = vec3(0.4,0.8,0.6);//vec3(1,0.95,0);\n    vec3 col_ground = vec3(0.5, 0.55, 0.65);\n    vec3 col_eye    = vec3(0.2);\n    vec3 col_mouth  = vec3(0.9,0.5,0.4);\n    \n    vec3 col;\n    if (i_surf <= 1.) {\n        col = mix(col_pacman, col_gum, smoothstep(0., 1., i_surf));\n    }\n    else if (i_surf <= 2.) {\n        col = mix(col_gum, col_ground, smoothstep(0., 1., i_surf-1.));\n    }\n    else if (i_surf <= 3.) {\n        col = mix(col_pacman, col_eye, smoothstep(0., 1., i_surf-2.));\n    }\n    else {\n        col = mix(col_pacman, col_mouth, smoothstep(0., 1., i_surf-3.));\n    }\n    \n  \n    //col *= dot_light * (ambient + (1.-ambient)*s);// * clamp(n.z, 0., 1.) + 0.5/z;//(1. - z/100.);\n    //col *= ambient + (1.-ambient)*dot_light*s;\n    float specularity = 0.12;\n    col = phong(light, CameraPosition, p, n, col, specularity);\n    col *= ambient + (1.-ambient)*s;\n\n\n    vec3 col_top    = vec3(0.2,0.3,0.4);\n    vec3 col_bottom = vec3(0.4,0.45,0.6);\n    \n    float v = fragCoord.y/iResolution.y;\n    vec3 bg = (1.-v)*col_bottom + v*col_top;\n    \n    mask = smoothstep(1., 0., z/70.);\n    \n    \n    col = (1. - mask)*bg + mask*col;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}