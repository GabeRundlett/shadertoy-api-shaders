{
    "Shader": {
        "info": {
            "date": "1621779678",
            "description": "\n",
            "flags": 32,
            "hasliked": 0,
            "id": "Nts3RM",
            "likes": 6,
            "name": "Multiple Neighborhood CA",
            "published": 3,
            "tags": [
                "2d",
                "simulation",
                "diffusion",
                "automata",
                "life",
                "chaos",
                "cellular",
                "conway",
                "gameoflife",
                "cellularautomata",
                "cellularautomata",
                "cgol"
            ],
            "usePreview": 1,
            "username": "SlackermanzCA",
            "viewed": 1394
        },
        "renderpass": [
            {
                "code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 bufA = texture(iChannel0, uv);\n\n    // Output to screen\n    fragColor = bufA;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define txdata (iChannel0)\n\nconst uint MAX_NH_SIZE = 16u;\n\nuint u32_upk(uint u32, uint bts, uint off) { return (u32 >> off) & ((1u << bts)-1u); }\n\nfloat tp(uint n, float s) {\n\t\t\tfloat\tpscale\t= s * 0.5;\nreturn (float(n+1u)/256.0) * (pscale/128.0); }\n    \nfloat gdv(ivec2 off, sampler2D tx, int v) {\n//\tGet Div Value: Return the value of a specified pixel\n//\t\tx, y : \tRelative integer-spaced coordinates to origin [ 0.0, 0.0 ]\n//\t\tv\t :\tColour channel [ 0, 1, 2 ]\n\tivec4\tdm\t\t= ivec4(iResolution.x,iResolution.y,1,0);\n\tvec4 \tfc \t\t= gl_FragCoord;\n\tvec2\tdc\t\t= vec2( dm[0]/dm[2], dm[1]/dm[2] );\n\tfloat\tcx\t\t= mod(fc[0]+float(off[0]), dc[0]) + floor(fc[0]/dc[0])*dc[0];\n\tfloat\tcy\t\t= mod(fc[1]+float(off[1]), dc[1]) + floor(fc[1]/dc[1])*dc[1];\n\tvec4 \tpxdata \t= texelFetch( txdata, ivec2(cx, cy), 0);\n\treturn \tpxdata[v]; }\n\nvec2 ring( vec2 r, sampler2D tx, int c ) {\n\tconst\tfloat\tw = 1.0; // atan(1.0*(1.0-(d*PI)/r));\n\tconst\tuint\ttmx = 65536u;\n//\tconst\tuint\tchk = 2147483648u / (\n//\t\t\t\t\t( \tuint(float(r[0])*float(r[0])*PI + float(r[0])*PI + PI\t)\n//\t\t\t\t\t- \tuint(float(r[1])*float(r[1])*PI + float(r[1])*PI\t\t) ) * 128 );\n//\tconst\tfloat\tpsn = (chk >= tmx) ? float(tmx) : float(chk);\n\tconst\tfloat\tpsn = float(tmx);\n\t\t\tfloat \td = 0.0;\n\t\t\tfloat \ta = 0.0;\n\t\t\tfloat \tb = 0.0;\n\t\t\tfloat\tt = 0.0;\n\tfor(float i = -r[0]; i <= r[0]; i+=1.0) {\n\t\tfor(float j = -r[0]; j <= r[0]; j+=1.0) {\n\t\t\td = round(sqrt(i*i+j*j));\n\t\t\tif( d <= r[0] && d > r[1] ) {\n\t\t\t\tt  = gdv( ivec2(i,j), tx, c ) * w * psn;\n\t\t\t\ta += t - fract(t);\n\t\t\t\tb += w * psn; } } }\n\treturn vec2(a, b); }\n                \nfloat sizring(uint r, vec2[MAX_NH_SIZE] rings) {\n\tfloat e0_sum = 0.0;\n\tfloat e1_sum = 0.0;\n\tuint idx_min = MAX_NH_SIZE;\n\tuint idx_max = 0u;\n\tfor(uint i = 0u; i < MAX_NH_SIZE; i++) {\n\t\tif(u32_upk(r,1u,i) == 1u) { \n\t\t\tidx_max = i;\n\t\t\tif(idx_min == MAX_NH_SIZE) { idx_min = i; } } }\n\tfor(uint i = idx_min; i < idx_max; i++) {\n\t\te0_sum += rings[i][0];\n\t\te1_sum += rings[i][1]; }\n\treturn e0_sum / e1_sum; }\n\nfloat bitring(uint r, vec2[MAX_NH_SIZE] rings){\n\tfloat e0_sum = 0.0;\n\tfloat e1_sum = 0.0;\n\tfor(uint i = 0u; i < MAX_NH_SIZE; i++) {\n\t\tif(u32_upk(r,1u,i) == 1u) {\n\t\t\te0_sum += rings[i][0];\n\t\t\te1_sum += rings[i][1]; } }\n\treturn e0_sum / e1_sum; }\n    \n//\tUsed to reseed the surface with lumpy noise\nfloat get_xc(float x, float y, float xmod) {\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0); }\nfloat shuffle(float x, float y, float xmod, float val) {\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val)); }\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc); }\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf; }\nfloat reseed(int seed) {\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1],  2.0, 19.0 + mod(iDate[3]+float(seed),17.0), 23.0 + mod(iDate[3]+float(seed),43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 14.0, 13.0 + mod(iDate[3]+float(seed),29.0), 17.0 + mod(iDate[3]+float(seed),31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1],  6.0, 13.0 + mod(iDate[3]+float(seed),11.0), 51.0 + mod(iDate[3]+float(seed),37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n//  PatternConfigData\n\tuint[4/*48*/] SCD = uint[4/*48*/] (\n\t\t745624173u, 394657945u, 114691695u, 3408256734u/*, \n\t\t3562138900u, 2689676514u, 1537616700u, 514376187u, \n\t\t2561585874u, 1457975831u, 3873655792u, 829274244u, \n\t\t1345991250u, 2384637002u, 3327897501u, 4181019822u, \n\t\t3280585563u, 3404707033u, 3478088402u, 3404599677u, \n\t\t1895706143u, 2111688054u, 711043543u, 170845113u, \n\t\t705654093u, 4286820695u, 1774033677u, 2025664183u, \n\t\t87072028u, 2350900182u, 3118097579u, 2505681268u, \n\t\t442538555u, 527807101u, 3277062214u, 2927821985u, \n\t\t4087906097u, 3986167603u, 3770457043u, 291982664u, \n\t\t2617331523u, 132764912u, 3513872062u, 2912623567u, \n\t\t3126111208u, 3641509413u, 632489908u, 1232640552u*/ );\n\t\t\n\tuint[1/*4*/] UBI = uint[1/*4*/] (\n\t\t2028247922u/*, 1229167981u, 1124204384u, 3289825991u*/ );\n\t\t\n\tuint[8/*48*/] UBV = uint[8/*48*/] (\n\t\t2881800762u, 1689308279u, 207967308u, 403478124u, \n\t\t2024363340u, 1838559275u, 487054279u, 965651142u/*, \n\t\t1303859839u, 3241637042u, 3234350862u, 2128598581u, \n\t\t3821254548u, 1610900416u, 950297306u, 1751528927u, \n\t\t512984747u, 2826875305u, 1534335949u, 653135108u, \n\t\t438611155u, 2121883655u, 335884606u, 2096964339u, \n\t\t291409380u, 1406257945u, 2409962099u, 197265851u, \n\t\t3010279700u, 907997333u, 2168248334u, 1929616449u, \n\t\t1290274009u, 2928033625u, 1749564286u, 626410207u, \n\t\t770787243u, 2662863700u, 697663404u, 3447431416u, \n\t\t3329121672u, 2605203859u, 4129638779u, 1636176142u, \n\t\t2123096153u, 440566377u, 1065434181u, 2065065723u*/ );\n\t\t\n\tfloat SCL = 291.428680;\n    \n\tfloat PZM = 1.600000;\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Setup\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tconst \tivec2\torigin  = ivec2(0, 0);\n\tconst\tfloat \tmnp \t= 1.0 / 65536.0;\t\t\t//\tMinimum value of a precise step for 16-bit channel\n\n            float\tref_r\t= gdv( origin, txdata, 0 );\t//\tOrigin value reference\n            float\tref_g\t= gdv( origin, txdata, 1 );\t//\tOrigin value reference\n            float\tref_b\t= gdv( origin, txdata, 2 );\t//\tOrigin value reference\n\n//\tParameters\n\tconst\tfloat \ts  = 1.0;//mnp *  64.0 *  96.0;\n\tconst\tfloat \tc  = mnp *  32.0 *   4.0;\n\tconst\tfloat \tb  = mnp *  32.0 *  12.0 * 0.0;\n\tconst\tfloat \tn  = mnp *  64.0 *  16.0 * 1.0;\n\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRule Initilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tOutput Values\n\tvec3 res_c = vec3(ref_r, ref_g, ref_b );\n\n//\tNeighbourhood Rings\n\tvec2[MAX_NH_SIZE] rings_r;\n\tfor(uint i = 0u; i < MAX_NH_SIZE; i++) {\n\t\trings_r[i] = ring( vec2(float(i+1u), float(i)), txdata, 0 ); }\n\n//\tGet Neighbourhood Values\n\t \tfloat[4/*48*/] nhv_r = float[4/*48*/] (\n\t\tsizring(SCD[ 0], rings_r), bitring(SCD[ 1], rings_r), \n\t\tsizring(SCD[ 2], rings_r), bitring(SCD[ 3], rings_r)/*, \n\t\tbitring(SCD[ 4], rings_r), bitring(SCD[ 5], rings_r), \n\t\tbitring(SCD[ 6], rings_r), bitring(SCD[ 7], rings_r), \n\t\tsizring(SCD[ 8], rings_r), bitring(SCD[ 9], rings_r), \n\t\tsizring(SCD[10], rings_r), bitring(SCD[11], rings_r), \n\t\tsizring(SCD[12], rings_r), bitring(SCD[13], rings_r), \n\t\tsizring(SCD[14], rings_r), bitring(SCD[15], rings_r), \n\t\tbitring(SCD[16], rings_r), sizring(SCD[17], rings_r), \n\t\tbitring(SCD[18], rings_r), sizring(SCD[19], rings_r), \n\t\tbitring(SCD[20], rings_r), sizring(SCD[21], rings_r), \n\t\tbitring(SCD[22], rings_r), sizring(SCD[23], rings_r), \n\t\tsizring(SCD[24], rings_r), sizring(SCD[25], rings_r), \n\t\tsizring(SCD[26], rings_r), sizring(SCD[27], rings_r), \n\t\tsizring(SCD[28], rings_r), sizring(SCD[29], rings_r), \n\t\tsizring(SCD[30], rings_r), sizring(SCD[31], rings_r), \n\t\tsizring(SCD[32], rings_r), sizring(SCD[33], rings_r), \n\t\tsizring(SCD[34], rings_r), sizring(SCD[35], rings_r), \n\t\tsizring(SCD[36], rings_r), sizring(SCD[37], rings_r), \n\t\tsizring(SCD[38], rings_r), sizring(SCD[39], rings_r), \n\t\tsizring(SCD[40], rings_r), sizring(SCD[41], rings_r), \n\t\tsizring(SCD[42], rings_r), sizring(SCD[43], rings_r), \n\t\tsizring(SCD[44], rings_r), sizring(SCD[45], rings_r), \n\t\tsizring(SCD[46], rings_r), sizring(SCD[47], rings_r)*/ );\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tTransition Functions\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tuint mn = 4u;\n\tuint vc = 48u / mn;\n\tuint bt = 8u;\n    \n/*\tif( nhv_r[0] >= tp(u32_upk(UBV[0],bt,bt*0u),SCL)\t&& nhv_r[0] <= tp(u32_upk(UBV[0],bt,bt*1u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u, 0u)); }\n\tif( nhv_r[0] >= tp(u32_upk(UBV[0],bt,bt*2u),SCL)\t&& nhv_r[0] <= tp(u32_upk(UBV[0],bt,bt*3u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u, 1u)); }\n\tif( nhv_r[0] >= tp(u32_upk(UBV[1],bt,bt*0u),SCL)\t&& nhv_r[0] <= tp(u32_upk(UBV[1],bt,bt*1u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u, 2u)); }\n\tif( nhv_r[0] >= tp(u32_upk(UBV[1],bt,bt*2u),SCL)\t&& nhv_r[0] <= tp(u32_upk(UBV[1],bt,bt*3u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u, 3u)); }\n\n\tif( nhv_r[1] >= tp(u32_upk(UBV[2],bt,bt*0u),SCL)\t&& nhv_r[1] <= tp(u32_upk(UBV[2],bt,bt*1u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u, 4u)); }\n\tif( nhv_r[1] >= tp(u32_upk(UBV[2],bt,bt*2u),SCL)\t&& nhv_r[1] <= tp(u32_upk(UBV[2],bt,bt*3u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u, 5u)); }\n\tif( nhv_r[1] >= tp(u32_upk(UBV[3],bt,bt*0u),SCL)\t&& nhv_r[1] <= tp(u32_upk(UBV[3],bt,bt*1u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u, 6u)); }\n\tif( nhv_r[1] >= tp(u32_upk(UBV[3],bt,bt*2u),SCL)\t&& nhv_r[1] <= tp(u32_upk(UBV[3],bt,bt*3u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u, 7u)); }\n\n\tif( nhv_r[2] >= tp(u32_upk(UBV[4],bt,bt*0u),SCL)\t&& nhv_r[2] <= tp(u32_upk(UBV[4],bt,bt*1u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u, 8u)); }\n\tif( nhv_r[2] >= tp(u32_upk(UBV[4],bt,bt*2u),SCL)\t&& nhv_r[2] <= tp(u32_upk(UBV[4],bt,bt*3u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u, 9u)); }\n\tif( nhv_r[2] >= tp(u32_upk(UBV[5],bt,bt*0u),SCL)\t&& nhv_r[2] <= tp(u32_upk(UBV[5],bt,bt*1u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u,10u)); }\n\tif( nhv_r[2] >= tp(u32_upk(UBV[5],bt,bt*2u),SCL)\t&& nhv_r[2] <= tp(u32_upk(UBV[5],bt,bt*3u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u,11u)); }\n\n\tif( nhv_r[3] >= tp(u32_upk(UBV[6],bt,bt*0u),SCL)\t&& nhv_r[3] <= tp(u32_upk(UBV[6],bt,bt*1u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u,12u)); }\n\tif( nhv_r[3] >= tp(u32_upk(UBV[6],bt,bt*2u),SCL)\t&& nhv_r[3] <= tp(u32_upk(UBV[6],bt,bt*3u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u,13u)); }\n\tif( nhv_r[3] >= tp(u32_upk(UBV[7],bt,bt*0u),SCL)\t&& nhv_r[3] <= tp(u32_upk(UBV[7],bt,bt*1u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u,14u)); }\n\tif( nhv_r[3] >= tp(u32_upk(UBV[7],bt,bt*2u),SCL)\t&& nhv_r[3] <= tp(u32_upk(UBV[7],bt,bt*3u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u,15u)); }\n*/\n\n    if( nhv_r[0] >= 0.262364076538086\t&& nhv_r[0] <= 0.902710297241211 ) { res_c[0] = 0.0; }\n    if( nhv_r[0] >= 0.876029204711914\t&& nhv_r[0] <= 0.764857985839844 ) { res_c[0] = 1.0; }\n    if( nhv_r[0] >= 0.533621850585938\t&& nhv_r[0] <= 0.911603994750977 ) { res_c[0] = 0.0; }\n    if( nhv_r[0] >= 0.787092229614258\t&& nhv_r[0] <= 0.449131724243164 ) { res_c[0] = 0.0; }\n\n    if( nhv_r[1] >= 0.342407354125977\t&& nhv_r[1] <= 0.377982144165039 ) { res_c[0] = 1.0; }\n    if( nhv_r[1] >= 0.453578572998047\t&& nhv_r[1] <= 0.057809033813477 ) { res_c[0] = 1.0; }\n    if( nhv_r[1] >= 0.484706514282227\t&& nhv_r[1] <= 0.671474161987305 ) { res_c[0] = 1.0; }\n    if( nhv_r[1] >= 0.057809033813477\t&& nhv_r[1] <= 0.11117121887207  ) { res_c[0] = 0.0; }\n\n    if( nhv_r[2] >= 0.342407354125977\t&& nhv_r[2] <= 0.382428992919922 ) { res_c[0] = 1.0; }\n    if( nhv_r[2] >= 0.755964288330078\t&& nhv_r[2] <= 0.53806869934082  ) { res_c[0] = 1.0; }\n    if( nhv_r[2] >= 0.195661345214844\t&& nhv_r[2] <= 0.217895588989258 ) { res_c[0] = 0.0; }\n    if( nhv_r[2] >= 0.671474161987305\t&& nhv_r[2] <= 0.489153363037109 ) { res_c[0] = 1.0; }\n\n    if( nhv_r[3] >= 0.889369750976563\t&& nhv_r[3] <= 0.978306726074219 ) { res_c[0] = 1.0; }\n    if( nhv_r[3] >= 0.035574790039063\t&& nhv_r[3] <= 0.133405462646484 ) { res_c[0] = 0.0; }\n    if( nhv_r[3] >= 0.88492290222168\t&& nhv_r[3] <= 0.760411137084961 ) { res_c[0] = 0.0; }\n    if( nhv_r[3] >= 0.635899371948242\t&& nhv_r[3] <= 0.257917227783203 ) { res_c[0] = 1.0; }\n\n\tres_c[1] = res_c[0];\n\tres_c[2] = res_c[0];\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 14.0) {\n        res_c[0] = round(mod(float(iFrame),2.0));\n        res_c[1] = 0.0;\n        res_c[2] = 0.0; }\n    if (iFrame == 0) { res_c[0] = reseed(0); res_c[1] = reseed(1); res_c[2] = reseed(2); }\n    fragColor=vec4(res_c[0],res_c[1],res_c[2],1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}