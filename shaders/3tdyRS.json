{
    "Shader": {
        "info": {
            "date": "1609439728",
            "description": "A buffer of a small Neural networks that learns the output of a 3s shader with a network per frag.  After 60 seconds the training stops and the left image is composed purely from neural-nt.  Feel free to write your own shader, using getT(iTime) in Buff A\n",
            "flags": 32,
            "hasliked": 0,
            "id": "3tdyRS",
            "likes": 35,
            "name": "Neural Net Learn Shader from t",
            "published": 3,
            "tags": [
                "video",
                "neuralnetwork",
                "deeplearning",
                "machinelearning"
            ],
            "usePreview": 0,
            "username": "FrickHazard",
            "viewed": 1032
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 w1_b1_w2_b2 = texture(iChannel1, uv);\n    vec4 w3_b3_w4_b4 = texture(iChannel2, uv);\n    vec4 w5_b5_w6_b6 = texture(iChannel3, uv);\n    float t = getT(iTime);\n    vec3 rgb = forwardPropagationPrediction(t, w1_b1_w2_b2, w3_b3_w4_b4, w5_b5_w6_b6);\n    \n    fragColor = vec4(rgb, 1.);\n    // view weight layers un-comment\n    // fragColor = w1_b1_w2_b2;\n    // fragColor = w3_b3_w4_b4;\n    // fragColor = w5_b5_w6_b6;\n    vec2 mouseCoords = iMouse.xy/iResolution.xy;\n    if ((mouseCoords.x > 0.001 && uv.x > mouseCoords.x) || (mouseCoords.x == 0. && uv.x > 0.5)) {\n      fragColor = texture(iChannel0, uv);\n    }\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// example by iq, put any shader here\n// and switch out iTime with getT(iTime)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = getT(iTime);\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\tuv.x *=  iResolution.x / iResolution.y;\n\n    // background\t \n\tvec3 color = vec3(0.8 + 0.2*uv.y);\n\n    // bubbles\t\n\tfor( int i=0; i<40; i++ )\n\t{\n        // bubble seeds\n\t\tfloat pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;\n\t\tfloat siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );\n\t\tfloat pox =      sin(float(i)*321.55+4.1) * iResolution.x / iResolution.y;\n\n        // buble size, position and color\n\t\tfloat rad = 0.1 + 0.5*siz;\n\t\tvec2  pos = vec2( pox, -1.0-rad + (2.0+2.0*rad)*mod(pha+0.1*t*(0.2+0.8*siz),1.0));\n\t\tfloat dis = length( uv - pos );\n\t\tvec3  col = mix( vec3(0.94,0.3,0.0), vec3(0.1,0.4,0.8), 0.5+0.5*sin(float(i)*1.2+1.9));\n\t\t//    col+= 8.0*smoothstep( rad*0.95, rad, dis );\n\t\t\n        // render\n\t\tfloat f = length(uv-pos)/rad;\n\t\tf = sqrt(clamp(1.0-f*f,0.0,1.0));\n\t\tcolor -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;\n\t}\n\n    // vigneting\t\n\tcolor *= sqrt(1.5-0.5*length(uv));\n\n\tfragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\tvec2 uv = fragCoord / iResolution.xy;\n \n    // init\n    if (iTime == 0. || iFrame == 0){\n        fragColor = vec4(rnd(uv + vec2(2., 2.)), 0., rnd(uv - vec2(2., 2.)), 0.);\n        return;\n    }\n    \n    \n      \n    // apply back propagation\n    vec4 w1_b1_w2_b2 = texture(iChannel1, uv);\n    vec4 w3_b3_w4_b4 = texture(iChannel2, uv);\n    vec4 w5_b5_w6_b6 = texture(iChannel3, uv);\n    vec4 Y = texture(iChannel0, uv);\n    \n    if (iTime > TRAIN_DURATION) {\n        fragColor = w1_b1_w2_b2;\n        return;\n    }\n    \n    float t = getT(iTime);\n    fragColor = updatedParametersBufferB(t, w1_b1_w2_b2, w3_b3_w4_b4, w5_b5_w6_b6, Y.rgb);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n \n    // init\n    if (iTime == 0.|| iFrame == 0){\n        fragColor = vec4(rnd(uv + vec2(4., 4.)), 0., rnd(uv - vec2(4., 4.)), 0.);\n        return;\n    }\n      \n    // apply back propagation\n    vec4 w1_b1_w2_b2 = texture(iChannel1, uv);\n    vec4 w3_b3_w4_b4 = texture(iChannel2, uv);\n    vec4 w5_b5_w6_b6 = texture(iChannel3, uv);\n    vec4 Y = texture(iChannel0, uv);\n    \n    if (iTime > TRAIN_DURATION) {\n        fragColor = w3_b3_w4_b4;\n        return;\n    }\n    \n    float t = getT(iTime);\n    fragColor = updatedParametersBufferC(t, w1_b1_w2_b2, w3_b3_w4_b4, w5_b5_w6_b6, Y.rgb);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//MIT License\n\n//Copyright (c) [2020] [Ender Doe]\n\n//Permission is hereby granted, free of charge, to any person obtaining a copy\n//of this software and associated documentation files (the \"Software\"), to deal\n//in the Software without restriction, including without limitation the rights\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n//copies of the Software, and to permit persons to whom the Software is\n//furnished to do so, subject to the following conditions:\n\n//The above copyright notice and this permission notice shall be included in all\n//copies or substantial portions of the Software.\n\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n//SOFTWARE.\n\n#define LEARNING_RATE 0.005\n#define CLIP_DURATION 3.\n#define TRAIN_DURATION (CLIP_DURATION * 20.)\n#define PI 3.1415926535897932384626433832\n\n// Each frag has an independent neural net composed\n// of relu -> reulu -> (relu, relu, relu); a shape of (1,1,3)\n// Buffer A is the shader being learned\n// Buffer B C D are the bias and weights for nodes per frag\n// There is some duplicated computation, trading storage for re compute\n// Layers are updated one at a time so training is very stochastic\n\nfloat getT(float iTime){\n return 0.5 + 0.5 * cos(iTime * PI);\n}\nfloat rnd(vec2 n) {\n    return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// alternate getT which randomly samples t values, pretty interesting\n// float getT(float iTime){\n// return step(TRAIN_DURATION, iTime) * mod(iTime, CLIP_DURATION) +\n//     (1. - step(TRAIN_DURATION, iTime)) * rnd(vec2(iTime, iTime + 0.3));\n//}\n\n\nfloat relu(float x) {\n    return max(0., x);\n}\n\nfloat reluD(float x) {\n    return step(0., x);\n}\n\n\nfloat meanSquaredError (vec3 groundTruth, vec3 prediction) {\n    vec3 diff = groundTruth - prediction;\n    float loss = ((diff.x * diff.x)+(diff.y * diff.y)+(diff.z*diff.z)) * (1./3.);\n \n return loss;\n}\n\n// CIE XYZ, color space\n//https://arxiv.org/pdf/1902.00267.pdf\nmat3 CIE_XYZ_MAT = mat3(\n    0.489989, 0.310008, 0.2,\n    0.176962, 0.81240, 0.010,\n    0, 0.01, 0.99\n);\nvec3 meanSquaredErrorGrad (vec3 groundTruth, vec3 prediction) {\n    vec3 predXYZ = CIE_XYZ_MAT * prediction;\n    vec3 truthXYZ = CIE_XYZ_MAT * groundTruth;\n    return CIE_XYZ_MAT * vec3(\n        (predXYZ.r - truthXYZ.r),\n        (predXYZ.g - truthXYZ.g),\n        (predXYZ.b - truthXYZ.b) \n    ); \n}\n\n\nvec3 forwardPropagationPrediction(float t, vec4 w1_b1_w2_b2, vec4 w3_b3_w4_b4, vec4 w5_b5_w6_b6)\n{\n    float a1 = relu(w1_b1_w2_b2.x *  t + w1_b1_w2_b2.y);\n    float a2 = relu(w1_b1_w2_b2.z * a1 + w1_b1_w2_b2.w);\n    float a3 = relu(w3_b3_w4_b4.x * a2 + w3_b3_w4_b4.y);\n    \n    float r = relu(w3_b3_w4_b4.z * a3 + w3_b3_w4_b4.w);\n    float g = relu(w5_b5_w6_b6.x * a3 + w5_b5_w6_b6.y);\n    float b = relu(w5_b5_w6_b6.z * a3 + w5_b5_w6_b6.w);\n    \n    return vec3(r, g, b);\n}\n\nvec4 updatedParametersBufferB(float t, vec4 w1_b1_w2_b2, vec4 w3_b3_w4_b4, vec4 w5_b5_w6_b6, vec3 Y){\n    float a1 = relu(w1_b1_w2_b2.x *  t + w1_b1_w2_b2.y);\n    float a2 = relu(w1_b1_w2_b2.z * a1 + w1_b1_w2_b2.w);\n    float a3 = relu(w3_b3_w4_b4.x * a2 + w3_b3_w4_b4.y);\n    float r = relu(w3_b3_w4_b4.z * a3 + w3_b3_w4_b4.w);\n    float g = relu(w5_b5_w6_b6.x * a3 + w5_b5_w6_b6.y);\n    float b = relu(w5_b5_w6_b6.z * a3 + w5_b5_w6_b6.w);\n    \n    vec3 prediction = forwardPropagationPrediction(t, w1_b1_w2_b2, w3_b3_w4_b4, w5_b5_w6_b6);\n    vec3 lossGrad = meanSquaredErrorGrad(Y, prediction);\n    float bD =  reluD(w5_b5_w6_b6.z * a3 + w5_b5_w6_b6.w);\n    float gD =  reluD(w5_b5_w6_b6.x * a3 + w5_b5_w6_b6.y);\n    float rD =  reluD(w3_b3_w4_b4.z * a3 + w3_b3_w4_b4.w);\n    float a3D =  reluD(w3_b3_w4_b4.x * a2 + w3_b3_w4_b4.y);\n    float a2D =  reluD(w1_b1_w2_b2.z * a1 + w1_b1_w2_b2.w);\n    float a1D =  reluD(w1_b1_w2_b2.x *  t + w1_b1_w2_b2.y);\n    float layer3D = dot(vec3(w3_b3_w4_b4.z, w5_b5_w6_b6.x, w5_b5_w6_b6.z), vec3(rD * lossGrad.r, gD * lossGrad.g, bD * lossGrad.z));\n    \n    return vec4(\n        w1_b1_w2_b2.x - LEARNING_RATE * (a1D * (a2D * w1_b1_w2_b2.z) * (a3D * w3_b3_w4_b4.x) * layer3D) * t,\n        w1_b1_w2_b2.y - LEARNING_RATE * (a1D * (a2D * w1_b1_w2_b2.z) * (a3D * w3_b3_w4_b4.x) * layer3D),\n        w1_b1_w2_b2.z - LEARNING_RATE * (a2D * (a3D * w3_b3_w4_b4.x) * layer3D) * a1,\n        w1_b1_w2_b2.w - LEARNING_RATE * (a2D * (a3D * w3_b3_w4_b4.x) * layer3D)\n    );\n}\nvec4 updatedParametersBufferC(float t, vec4 w1_b1_w2_b2, vec4 w3_b3_w4_b4, vec4 w5_b5_w6_b6, vec3 Y){\n    float a1 = relu(w1_b1_w2_b2.x *  t + w1_b1_w2_b2.y);\n    float a2 = relu(w1_b1_w2_b2.z * a1 + w1_b1_w2_b2.w);\n    float a3 = relu(w3_b3_w4_b4.x * a2 + w3_b3_w4_b4.y);\n    float r = relu(w3_b3_w4_b4.z * a3 + w3_b3_w4_b4.w);\n    float g = relu(w5_b5_w6_b6.x * a3 + w5_b5_w6_b6.y);\n    float b = relu(w5_b5_w6_b6.z * a3 + w5_b5_w6_b6.w);\n    \n    vec3 prediction = forwardPropagationPrediction(t, w1_b1_w2_b2, w3_b3_w4_b4, w5_b5_w6_b6);\n    vec3 lossGrad = meanSquaredErrorGrad(Y, prediction);\n    \n    float bD =  reluD(w5_b5_w6_b6.z * a3 + w5_b5_w6_b6.w);\n    float gD =  reluD(w5_b5_w6_b6.x * a3 + w5_b5_w6_b6.y);\n    float rD =  reluD(w3_b3_w4_b4.z * a3 + w3_b3_w4_b4.w);\n    float a3D =  reluD(w3_b3_w4_b4.x * a2 + w3_b3_w4_b4.y);\n    float layer3D = dot(vec3(w3_b3_w4_b4.z, w5_b5_w6_b6.x, w5_b5_w6_b6.z), vec3(rD * lossGrad.r, gD * lossGrad.g, bD * lossGrad.b));\n    \n    return vec4(\n        w3_b3_w4_b4.x - LEARNING_RATE * (a3D * layer3D) * a2,\n        w3_b3_w4_b4.y - LEARNING_RATE * (a3D * layer3D),\n        w3_b3_w4_b4.z - LEARNING_RATE * (rD * lossGrad.r) * a3,\n        w3_b3_w4_b4.w - LEARNING_RATE * (rD * lossGrad.r)\n    );\n}\nvec4 updatedParametersBufferD(float t, vec4 w1_b1_w2_b2, vec4 w3_b3_w4_b4, vec4 w5_b5_w6_b6, vec3 Y){\n    float a1 = relu(w1_b1_w2_b2.x *  t + w1_b1_w2_b2.y);\n    float a2 = relu(w1_b1_w2_b2.z * a1 + w1_b1_w2_b2.w);\n    float a3 = relu(w3_b3_w4_b4.x * a2 + w3_b3_w4_b4.y);\n    float r  = relu(w3_b3_w4_b4.z * a3 + w3_b3_w4_b4.w);\n    float g  = relu(w5_b5_w6_b6.x * a3 + w5_b5_w6_b6.y);\n    float b  = relu(w5_b5_w6_b6.z * a3 + w5_b5_w6_b6.w);\n    \n    vec3 prediction = forwardPropagationPrediction(t, w1_b1_w2_b2, w3_b3_w4_b4, w5_b5_w6_b6);\n    vec3 lossGrad = meanSquaredErrorGrad(Y, prediction);\n    \n    float bD =  reluD(w5_b5_w6_b6.z * a3 + w5_b5_w6_b6.w);\n    float gD =  reluD(w5_b5_w6_b6.x * a3 + w5_b5_w6_b6.y);\n   \n    return vec4(\n        w5_b5_w6_b6.x - LEARNING_RATE * (gD * lossGrad.g) * a3,\n        w5_b5_w6_b6.y - LEARNING_RATE * (gD * lossGrad.g),\n        w5_b5_w6_b6.z - LEARNING_RATE * (bD * lossGrad.b) * a3,\n        w5_b5_w6_b6.w - LEARNING_RATE * (bD * lossGrad.b)\n    );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n \n    // init\n    if (iTime == 0.|| iFrame == 0){\n        fragColor = vec4(rnd(uv + vec2(6., 6.)),0., rnd(uv - vec2(6., 6.)), 0.);\n        return;\n    }\n      \n    // apply back propagation\n    vec4 w1_b1_w2_b2 = texture(iChannel1, uv);\n    vec4 w3_b3_w4_b4 = texture(iChannel2, uv);\n    vec4 w5_b5_w6_b6 = texture(iChannel3, uv);\n    vec4 Y = texture(iChannel0, uv);\n    \n    if (iTime > TRAIN_DURATION) {\n        fragColor = w5_b5_w6_b6;\n        return;\n    }\n    \n    float t = getT(iTime);\n    fragColor = updatedParametersBufferD(t, w1_b1_w2_b2, w3_b3_w4_b4, w5_b5_w6_b6, Y.rgb);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}