{
    "Shader": {
        "info": {
            "date": "1565724640",
            "description": "A tool for comparing different pseudo-random number generators (PRNG). And a PRNG that I designed for GPU / shaders.",
            "flags": 32,
            "hasliked": 0,
            "id": "wljXDz",
            "likes": 36,
            "name": "Randomness Test",
            "published": 3,
            "tags": [
                "random",
                "hash",
                "integer",
                "stochastic"
            ],
            "usePreview": 1,
            "username": "otaviogood",
            "viewed": 1519
        },
        "renderpass": [
            {
                "code": "/* License CC0 - http://creativecommons.org/publicdomain/zero/1.0/ To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n\n* Except for Inigo's PRNG, which is MIT license.\n-Otavio Good\n-----------------------------------------------------------------\n\nA tool for comparing different pseudo-random number generators (PRNG).\nAnd a PRNG that I designed for GPU / shaders.\n\nThe generators are:\nflt: RandFloat() - my PRNG that returns 1 float, range [0..1]\nv2x, v2y: RandVec2() - my PRNG that returns 2 floats, range [0..1]\nv3x, v3y, v3z: RandVec3() - my PRNG that returns 3 floats, range [0..1]\nxor: \"xor shift\" PRNG  https://en.wikipedia.org/wiki/Xorshift\niq: Inigo's Integer Hash, adapted for this shader.  https://www.shadertoy.com/view/llGSzw\nLCG: A popular simple PRNG called Linear congruential generator  https://en.wikipedia.org/wiki/Linear_congruential_generator\n\nI'm now suspicious of any random number generator that only\nhas a 32-bit state. There is no way to win. But I did my best\nand this is the result.\n\nThe top visualization, labeled \"Zero\", is a sequence of random\nnumbers generated from a seed of 0. *** Watch out, some PRNGs don't\nrecover from having a zero state (xorshift and LCG). ***\n\nThe next visualization, \"Mean x256\", is supposed to visualize\nbias in the random number generator. This sums samples over time\nand then increases their contrast. A perfect generator would\neventually match the background color of 0.5 with enough samples.\n\nThe \"Seq\" visualization is a sequence of calls to the PRNG, shown\nleft-to-right. Some PRNGs will take some time to \"spin up\", and\nothers will fall into a bad state after taking many samples.\n\nThe \"Rand\" visualization is just the output of the random\nnumber generator on some pixels. Nothing too fancy here,\nbut you can see patterns if it's a bad generator.\n\nThere are 2 buttons at the top. By default, the random numbers here\nwill use a sequential seed. That means the seed on the first image pixel\nwill be 0, then to the right of that, 1,2,3,4 and so on. This might not\nbe the ideal way to init your seed in your application, but it does\nhelp to visualize the health of the PRNG. The \"Hashed seed\" button will\ntake that same seed, but do a single call to a PRNG on the result to\nget the final seed. That is only as good as the PRNG, but then after\nthat, things will tend to look good.\n\nFor debugging a PRNG algorithm, there is a #define BIT_BY_BIT_DEBUG\nthat will visualize the randomness of each bit in your 32 bit state.\n\nMy hash function looks like it's producing random numbers, but it\nactually makes very structured numbers. The top 16ish bits\nlook very random. It takes 2^31 iterations to repeat. If it was more\nrandom-looking, with a 32 bit state, it would repeat much sooner. This\nnon-randomness should actually be good for some applications because\nit takes so long to repeat. It's like:\nhttps://en.wikipedia.org/wiki/Pseudorandom_binary_sequence\n\nExample:\nf(x) = (x^2 + x + 1) & 0xff\nWhen called with its own output for input, this equation will start\nrepeating its sequence at iteration 128, but by then\nit will have generated every odd number from 1 to 255, just not in\norder. The order will look slightly random, but it will never repeat\na number. As you get into higher and higher bits, where there's more\nwrap-around from the x^2 being masked, things look more and more random.\n\nIt turns out that there are many ways to do this same trick, and if you\nmix in some other operations, like multiplies and xors, you can get it\nto look more random while still not repeating any numbers and covering\nevery odd number. So that's what my main hash function does. Which means\nthat as long as that is the only thing to change the random state, my\nPRNG integer state should only repeat after 2^31 or 2 billion calls.\n\nHopefully that's enough for applications doing stochastic things. The\nbad news is, it takes less than 100th of a second for a good GPU to\ngenerate those 2 billion randoms using this method, so it won't take\nlong to repeat. Also, since the float random function masks off bits,\nit will have more collisions than the integer state. You still might\nhave to be careful. :P\n\nAnyway, I tried to design my random/hash functions so they'd have good\ntradeoffs between performance, randomness, cycle length, bias, and\nwith no failures like getting stuck in a zero-state. From what I\ncan tell, I have found a good balance for most applications compared to\nwhat was already out there for the GPU. Please give me feedback. :D\n\nLinks:\nSome notes about random numbers in shadertoy:\nhttps://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n\nRandom 32 bit primes from this site:\nhttps://asecuritysite.com/encryption/random3?val=32\nMore big primes:\nhttp://compoasso.free.fr/primelistweb/page/prime/liste_online_en.php\n\nAlso, wang hashing seems really good...\nhttp://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool hashedSeed = HashedSeedButton(iMouse.xy, iResolution.xy);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // get random pixels that were rendered to BufferA\n    vec4 bufB = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    float col = bufB.x / bufB.w;\n\n    // UI layout zones\n\tfloat orig = col;\n    // Contrast enhance the random pixels labeled Mean x256\n    if (uv.y >= spacing.y/0.125) col = (col-0.5)*256.0+0.5;\n    if (fragCoord.y > iResolution.y * 0.8) {\n        col = mix(0.5, 0.0, saturate((uv.y-0.865)*1024.0));\n        // Little notches separating the different PRNG algo labels\n    \tif (fragCoord.y > iResolution.y * 0.82) col *= (fract(-uv.x / spacing.x)-0.95)*1000.0;\n    }\n    // Zero seed section\n    if ((fragCoord.y > iResolution.y * 0.82) &&\n        (fragCoord.y < iResolution.y * 0.84)) col = orig;\n    // Little circles around each zone of random pixels\n    vec2 rep = abs(fract((uv * vec2(1.0, 0.25))/spacing)-0.5)*2.0;\n    if ((length(rep) > 1.15) && (fragCoord.y < iResolution.y * 0.8)) col = 0.5;\n#ifndef BIT_BY_BIT_DEBUG\n    // Left side bar\n    if (uv.x < spacing.x) col = 0.5+(uv.x-spacing.x)/spacing.x*0.5;\n#endif\n\n    // ---- Button UI ----\n    vec3 rgb = vec3(0.0);\n    float buttonx = hashedSeed ? 0.42 : 0.0;\n    vec3 buttonCol = vec3(0.1, 0.2, 0.6);\n    if (iMouse.x == iMouse.z) buttonCol *= 2.0;\n    float line = FillLine(uv, vec2(0.135,0.967),\n                                    vec2(0.54, 0.967),\n                                    vec2(0.0, 0.026), 0.02);\n    rgb += buttonCol*(1.0-line);\n    line = FillLine(uv, vec2(0.135 + 0.42,0.967),\n                                    vec2(0.54 + 0.42, 0.967),\n                                    vec2(0.0, 0.026), 0.02);\n    rgb += buttonCol*(1.0-line);\n    line = DrawOutline(uv, vec2(0.135 + buttonx,0.967),\n                                    vec2(0.54 + buttonx, 0.967),\n                                    vec2(0.0, 0.03), 0.02, 0.002);\n    rgb += vec3(1.0, 1.0, 1.0)*(1.0-line);\n\n    // Set up UV coords to be a letter grid for printing letters\n    uv = fragCoord.xy / iResolution.xy;\n    uv *= 15.0;\n    uv.x *= 8.0/3.0;\n    vec2 uvf = fract(uv);\n    uvf.x = (uvf.x-0.5)*0.5+0.5;  // stretch letters on x axis\n    vec2 uvi = floor(uv);\n\n    // -------- print letters --------\n    int letter = 32;\n    if (floor(uvi.y) == 13.0) {\n#ifndef BIT_BY_BIT_DEBUG\n        // labels for each different PRNG algorithm\n        letter = (letterArray[int(floor(uvi.x))]);\n#else\n        // Label each bit of the random state\n        vec2 uvTemp = uv;\n        uvTemp.x /= 40.0;\n        uvTemp.x *= 32.0;\n        uvi = floor(uvTemp);\n        uvf = fract(uvTemp);\n        letter = ((31 - int(floor(uvi.x))) % 10) + 48;\n#endif\n    }\n    // button labels\n    if (floor(uvi.y) == 14.0) {\n        letter = (buttons[int(floor(uvi.x))]);\n    }\n    // Left side row labels\n    else if (floor(uvi.y) == 2.0) {\n    \tif (floor(uvi.x) == 0.0) letter = (_R);\n    \tif (floor(uvi.x) == 1.0) letter = (_a);\n    \tif (floor(uvi.x) == 2.0) letter = (_n);\n    \tif (floor(uvi.x) == 3.0) letter = (_d);\n    }\n    else if (floor(uvi.y) == 10.0) {\n    \tif (floor(uvi.x) == 0.0) letter = (_M);\n    \tif (floor(uvi.x) == 1.0) letter = (_e);\n    \tif (floor(uvi.x) == 2.0) letter = (_a);\n    \tif (floor(uvi.x) == 3.0) letter = (_n);\n    }\n    else if (floor(uvi.y) == 9.0) {\n    \tif (floor(uvi.x) == 0.0) letter = (_x);\n    \tif (floor(uvi.x) == 1.0) letter = (_2);\n    \tif (floor(uvi.x) == 2.0) letter = (_5);\n    \tif (floor(uvi.x) == 3.0) letter = (_6);\n    }\n    else if (floor(uvi.y) == 6.0) {\n    \tif (floor(uvi.x) == 0.0) letter = (_S);\n    \tif (floor(uvi.x) == 1.0) letter = (_e);\n    \tif (floor(uvi.x) == 2.0) letter = (_q);\n    }\n    else if (floor(uvi.y) == 12.0) {\n    \tif (floor(uvi.x) == 0.0) letter = (_Z);\n    \tif (floor(uvi.x) == 1.0) letter = (_e);\n    \tif (floor(uvi.x) == 2.0) letter = (_r);\n    \tif (floor(uvi.x) == 3.0) letter = (_o);\n    }\n\n    // look up font texture\n    vec2 charPos = vec2(letter % 16, (255-letter) / 16);\n    vec4 tex = texture(iChannel1, (uvf + charPos) / 16.0f, -100.0);\n\tfloat letters = saturate(1.0-tex.w+0.4);\n    rgb += 1.0-saturate((tex.w-0.48)*40.0);\n\n    // Colorize fonts\n    uv = fragCoord.xy / iResolution.xy;\n#ifndef BIT_BY_BIT_DEBUG\n    if ((uv.y >= 0.86) && (uv.y < 0.93)) {\n        if (uv.x < spacing.x*2.0) rgb *= vec3(1.0, 0.1, 0.1);\n        else if (uv.x < spacing.x*4.0) rgb *= vec3(0.4, 1.0, 0.1);\n        else if (uv.x < spacing.x*7.0) rgb *= vec3(0.1, 0.7, 0.9);\n        else if (uv.x < spacing.x*8.0) rgb *= vec3(1.0, 0.6, 0.1);\n        else if (uv.x < spacing.x*9.0) rgb *= vec3(0.6, 0.3, 1.0);\n        else rgb *= vec3(0.1, 0.3, 1.0);\n    }\n#endif\n\trgb += col;\n    rgb = saturate(rgb);\n\n    //rgb = vec3(Hashf1i2(ivec2(fragCoord.xy-100.0)));\n    // Gamma correct\n    fragColor = vec4(sqrt(rgb), 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// **** This is for testing each number in the 32 bit uint random state individually. ****\n//#define BIT_BY_BIT_DEBUG\n\n#define saturate(a) clamp(a, 0.0, 1.0)\n\n// ---- Random functions use one 32 bit state var to change things up ----\n// This is the single state variable for the random number generator.\nuint randomState = 4056649889u;\n// 0xffffff is biggest 2^n-1 that 32 bit float does exactly.\n// Check with Math.fround(0xffffff) in javascript.\nconst float invMax24Bit = 1.0 / float(0xffffff);\n\n// This is the main hash function that should produce a non-repeating\n// pseudo-random sequence for 2^31 iterations.\nuint SmallHashA(in uint seed) {\n    return (seed ^ 1057926937u) * 3812423987u ^\n            ((seed*seed) * 4000000007u);\n}\n// This is an extra hash function to clean things up a little.\nuint SmallHashB(in uint seed) {\n    return (seed ^ 2156034509u) * 3699529241u;\n}\n\n// Hash the random state to get a random float ranged [0..1]\nfloat RandFloat() {\n    randomState = SmallHashA(randomState);\n    // Add these 2 lines for extra randomness. And change last line to tempState.\n    //uint tempState = (randomState << 13) | (randomState >> 19);\n    //tempState = SmallHashB(tempState);\n    return float((randomState>>8) & 0xffffffu) * invMax24Bit;\n}\n// Hash the random state to get 2 random floats ranged [0..1]\n// Reduced precision to 16 bits per component.\nvec2 RandVec2() {\n    randomState = SmallHashA(randomState);\n    uint tempState = (randomState << 13) | (randomState >> 19);\n    tempState = SmallHashB(tempState);\n    return vec2(tempState & 0xffffu,\n                (tempState >> 16) & 0xffffu) / float(0xffff);\n}\n// Hash the random state to get 3 random floats ranged [0..1]\n// Reduced precision to 10 bits per component.\nvec3 RandVec3() {\n    randomState = SmallHashA(randomState);\n    uint tempState = (randomState << 13) | (randomState >> 19);\n    tempState = SmallHashB(tempState);\n    return vec3((tempState >> 2) & 0x3ffu,\n                (tempState >> 12) & 0x3ffu,\n                (tempState >> 22) & 0x3ffu) / float(0x3ffu);\n}\n\n// Returns a random float from [0..1]\nfloat HashFloat(uint seed) {\n    seed = SmallHashA(seed);\n    return float((seed >> 8) & 0xffffffu) * invMax24Bit;\n}\nvec2 HashVec2(uint seed) {\n    seed = SmallHashA(seed);\n    seed = (seed << 13) | (seed >> 19);\n    seed = SmallHashB(seed);\n    return vec2(seed & 0xffffu,\n                (seed >> 16) & 0xffffu) / float(0xffff);\n}\nvec3 HashVec3(uint seed) {\n    seed = SmallHashA(seed);\n    seed = (seed << 13) | (seed >> 19);\n    seed = SmallHashB(seed);\n    return vec3((seed >> 2) & 0x3ffu,\n                (seed >> 12) & 0x3ffu,\n                (seed >> 22) & 0x3ffu) / float(0x3ffu);\n}\nfloat HashFloatI2(ivec2 seed) {\n    uint seedB = SmallHashA(uint(seed.x ^ (seed.y * 65537)));\n    //seedB ^= SmallHashB(uint(seed.y));\n    return float(seedB & 0xffffffu) * invMax24Bit;\n}\n\nvoid SetRandomSeed(in vec2 fragCoord, in vec2 iResolution,\n                  in int iFrame, in bool hashedSeed) {\n    uint primex = max(uint(iResolution.x), 5003u);  // This prime is far from any 2^x\n    randomState = uint(fragCoord.x);\n    randomState += uint(fragCoord.y) * primex;\n    randomState += uint(iFrame) * primex * uint(iResolution.y);\n    // This shouldn't really be an if condition.\n    // This should be true for any application that's not debugging things.\n    if (hashedSeed) {\n        RandFloat();\n    }\n}\n\n\n\n// --------------------------------- Begin MIT License -----------------------------------\n// Inigo's random number generator\n// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nuint hash1iq_uint( uint n )  // https://www.shadertoy.com/view/llGSzw\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    // Otavio note: The last add makes it unstable so after about\n    // 25 iterations, it goes white. But if it's removed, then the\n    // hash won't recover from a zero-state.\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\nfloat rand1iq()  // https://www.shadertoy.com/view/llGSzw\n{\n\trandomState = hash1iq_uint(randomState);\n    // Otavio note: This float is so big it will lose precision\n    // and never divide to 1.0\n    return float( randomState & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n// ---------------------------------- End MIT License ------------------------------------\n\n// https://en.wikipedia.org/wiki/Linear_congruential_generator\nuint LCGHashI(in uint seed) {\n    return (seed * 16807u) % 2147483647u;\n}\nfloat LCGRandf1() {\n    randomState = LCGHashI(randomState);\n    return float(randomState & 0xffffffu) * invMax24Bit;\n}\n\n// simple xor shift random number generator https://en.wikipedia.org/wiki/Xorshift\nuint XorShiftHash32(in uint seed) {\n    seed ^= seed << 13;\n    seed ^= seed >> 17;\n    seed ^= seed << 5;\n    // xorshift* - Multiplying by a prime makes it better, but still not great. (fails 0 seed)\n    return seed;// * 2156034509u;\n}\nfloat XORRandf1() {\n    randomState = XorShiftHash32(randomState);\n    return float(randomState & 0xffffffu) * invMax24Bit;\n}\n\n// https://en.wikipedia.org/wiki/Permuted_congruential_generator\n// RXS-M-XS algorithm\nuint PCGHashI(in uint seed) {\n    uint count=uint(seed >> 28);\n    seed ^= seed >> (4u + count);\n    seed *= 277803737u;\n    return seed ^ (seed >> 22);\n}\nfloat PCGRandf1() {\n    randomState = PCGHashI(randomState);\n    return float(randomState & 0xffffffu) * invMax24Bit;\n}\n\n// Just for testing. No practical use for this function.\nfloat RandShifted(int shift) {\n    //uint r = randomState;\n    //r = r*r*r*r*r + r*r*r*r*r*r*r*r*r + 1u;\n    //randomState = r;\n\t//randomState = hash1iq_uint(randomState);\n    randomState = SmallHashA(randomState);\n    //randomState = (randomState << 13) | (randomState >> 19);\n    //randomState = SmallHashB(randomState);\n    if (shift < 0)\n\t    return float((randomState<<(-shift)) & 0x800000u) / float(0x800000u);\n    else\n\t    return float((randomState>>shift) & 0x800000u) / float(0x800000u);\n}\n\n\n// ---- Font stuff ----\n// Font rendering macros (ASCII codes)\n#define _SPACE 32\n#define _EXCLAMATION 33\n#define _COMMA 44\n#define _DASH 45\n#define _PERIOD 46\n#define _SLASH 47\n#define _COLON 58\n#define _AT 64\n#define _A 65\n#define _B 66\n#define _C 67\n#define _D 68\n#define _E 69\n#define _F 70\n#define _G 71\n#define _H 72\n#define _I 73\n#define _J 74\n#define _K 75\n#define _L 76\n#define _M 77\n#define _N 78\n#define _O 79\n#define _P 80\n#define _Q 81\n#define _R 82\n#define _S 83\n#define _T 84\n#define _U 85\n#define _V 86\n#define _W 87\n#define _X 88\n#define _Y 89\n#define _Z 90\n\n#define _a 97\n#define _b 98\n#define _c 99\n#define _d 100\n#define _e 101\n#define _f 102\n#define _g 103\n#define _h 104\n#define _i 105\n#define _j 106\n#define _k 107\n#define _l 108\n#define _m 109\n#define _n 110\n#define _o 111\n#define _p 112\n#define _q 113\n#define _r 114\n#define _s 115\n#define _t 116\n#define _u 117\n#define _v 118\n#define _w 119\n#define _x 120\n#define _y 121\n#define _z 122\n\n#define _0 48\n#define _1 49\n#define _2 50\n#define _3 51\n#define _4 52\n#define _5 53\n#define _6 54\n#define _7 55\n#define _8 56\n#define _9 57\n\nconst int numLetters = 40;\nconst int letterArray[numLetters] = int[numLetters]\n    (_SPACE,_SPACE,_SPACE,_SPACE,\n     _f,_l,_t,_SPACE,\n     _v,_2,_x,_SPACE,\n     _v,_2,_y,_SPACE,\n     _V,_3,_x,_SPACE,\n     _V,_3,_y,_SPACE,\n     _V,_3,_z,_SPACE,\n     _x,_o,_r,_SPACE,\n     _i,_q,_SPACE,_SPACE,\n     _L,_C,_G,_SPACE\n    );\nconst int buttons[numLetters] = int[numLetters]\n    (_SPACE, _SPACE, _SPACE, _SPACE, _SPACE, _SPACE,\n    _S, _e, _q, _u, _e, _n, _t, _i, _a, _l, _SPACE, _s, _e, _e, _d,\n    _SPACE, _SPACE, _SPACE, _SPACE,\n    _H, _a, _s, _h, _e, _d, _SPACE, _s, _e, _e, _d,\n    _SPACE, _SPACE, _SPACE, _SPACE);\n\n\n#ifndef BIT_BY_BIT_DEBUG\n// How many different random algorithms should be compared onscreen\nconst vec2 spacing = vec2(1.0/10.0, 1.0/15.0);\n#else\nconst vec2 spacing = vec2(1.0/32.0, 1.0/15.0);\n#endif\n\n// From https://www.shadertoy.com/view/4tc3DX\n// This function will make a signed distance field that says how far you are from the edge\n// of the line at any point U,V.\n// Pass it UVs, line end points, line thickness (x is along the line and y is perpendicular),\n// How rounded the end points should be (0.0 is rectangular, setting rounded to thick.y will be circular),\n// dashOn is just 1.0 or 0.0 to turn on the dashed lines.\nfloat LineDistField(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float dashOn) {\n    // Don't let it get more round than circular.\n    rounded = min(thick.y, rounded);\n    // midpoint\n    vec2 mid = (pB + pA) * 0.5;\n    // vector from point A to B\n    vec2 delta = pB - pA;\n    // Distance between endpoints\n    float lenD = length(delta);\n    // unit vector pointing in the line's direction\n    vec2 unit = delta / lenD;\n    // Check for when line endpoints are the same\n    if (lenD < 0.0001) unit = vec2(1.0, 0.0);\t// if pA and pB are same\n    // Perpendicular vector to unit - also length 1.0\n    vec2 perp = unit.yx * vec2(-1.0, 1.0);\n    // position along line from midpoint\n    float dpx = dot(unit, uv - mid);\n    // distance away from line at a right angle\n    float dpy = dot(perp, uv - mid);\n    // Make a distance function that is 0 at the transition from black to white\n    float disty = abs(dpy) - thick.y + rounded;\n    float distx = abs(dpx) - lenD * 0.5 - thick.x + rounded;\n\n    // Too tired to remember what this does. Something like rounded endpoints for distance function.\n    float dist = length(vec2(max(0.0, distx), max(0.0,disty))) - rounded;\n    dist = min(dist, max(distx, disty));\n\n    // This is for animated dashed lines. Delete if you don't like dashes.\n    //float dashScale = 2.0*thick.y;\n    // Make a distance function for the dashes\n    //float dash = (repeat(dpx/dashScale + iTime)-0.5)*dashScale;\n    // Combine this distance function with the line's.\n    //dist = max(dist, dash-(1.0-dashOn*1.0)*10000.0);\n\n    return dist;\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float scale = abs(dFdy(uv).y);\n    thick = (thick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / scale);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float scale = abs(dFdy(uv).y);\n    thick = (thick * 0.5 - 0.5) * scale;\n    rounded = (rounded * 0.5 - 0.5) * scale;\n    outlineThick = (outlineThick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate((abs(df + outlineThick) - outlineThick) / scale);\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 1.0);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\n// This makes an outlined line in UV units. A 1.0 thick outline will span 0..1 in UV space.\nfloat DrawOutline(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate((abs(df + outlineThick) - outlineThick) / abs(dFdy(uv).y));\n}\n\n// ------------------------------------------------------\nbool HashedSeedButton(vec2 iMouse, vec2 iResolution) {\n    return (iMouse.x / iResolution.x > 0.55) && (iMouse.y > iResolution.y *0.92);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool hashedSeed = HashedSeedButton(iMouse.xy, iResolution.xy);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 backpixel = texture(iChannel0, uv);\n    // If we use the mouse to change the view, reset the pixel accumulation buffer\n    if (iMouse.z > 0.0) backpixel = vec4(0.0);\n\n    SetRandomSeed(fragCoord, iResolution.xy, iFrame, hashedSeed);\n    float col = 0.0;\n    \n    // Make 3 vertical zones for visualizing different things.\n    int zoney = int(floor(uv.y / spacing.y * 0.25));\n    vec2 zoneFract = fract(uv / spacing * vec2(1.0,0.25)) * spacing * iResolution.xy / vec2(1.0,0.25);\n\n    int reps = 1000;\n    if (zoney == 0) reps = 1;\n    if (zoney == 1) {\n        reps = min(reps, int(zoneFract.x)+1);\n        if (!hashedSeed) {\n            randomState = uint(fragCoord.y) + uint(iFrame);\n            //if (iFrame < 60) randomState = 0u;  // Test zero-state recovery\n        }\n    }\n    if (zoney == 3) {\n        reps = min(reps, int(zoneFract.x)+1);\n        randomState = 0u;\n    }\n    for (int i = 0; i < reps; i++) {\n        if (zoney != 2) col = 0.0;\n\n#ifndef BIT_BY_BIT_DEBUG\n        // Visualize all the different PRNG algos\n        if (uv.x < spacing.x*2.0) col += RandFloat();\n        else if (uv.x < spacing.x*3.0) col += RandVec2().x;\n        else if (uv.x < spacing.x*4.0) col += RandVec2().y;\n        else if (uv.x < spacing.x*5.0) col += RandVec3().x;\n        else if (uv.x < spacing.x*6.0) col += RandVec3().y;\n        else if (uv.x < spacing.x*7.0) col += RandVec3().z;\n        else if (uv.x < spacing.x*8.0) col += XORRandf1();\n        else if (uv.x < spacing.x*9.0) col += rand1iq();\n        else if (uv.x < spacing.x*10.0) col += LCGRandf1();\n#else\n        // Visualize each bit of the state independently.\n        int bit = int(floor(uv.x / spacing.x));\n        col += RandShifted(8 - bit);\n#endif\n    }\n    if (zoney == 2) col /= float(reps);\n    col = saturate(col);\n\n\tfragColor = vec4(vec3(saturate(col)),1.0);\n    if (zoney == 2) fragColor += backpixel;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}