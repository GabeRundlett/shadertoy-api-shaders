{
    "Shader": {
        "info": {
            "date": "1548244831",
            "description": "ray marching and shadow",
            "flags": 0,
            "hasliked": 0,
            "id": "3sS3zD",
            "likes": 0,
            "name": "[Ese] shadow",
            "published": 3,
            "tags": [
                "raymarching",
                "shadow"
            ],
            "usePreview": 0,
            "username": "Eseris",
            "viewed": 245
        },
        "renderpass": [
            {
                "code": "const int MARCHING_STEPS = 150;\nconst int ALIASING_STEPS = 2;\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 40.;\nconst float EPSILON = 1e-3;\n\nstruct Light {\n\tvec3 iamb; // ambient intensity\n\tvec3 idiff; // diffuse intensity\n\tvec3 ispec; // specular intensity\n\tvec3 pos;\n\tfloat shininess;\n};\n\nstruct Material {\n\tvec3 amb; // ambient constant\n\tvec3 diff; // diffuse constant\n\tvec3 spec; // specular constant\n};\n\nmat2 rot(float a) {\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat sdSphere(vec3 p, float radius) {\n\treturn length(p) - radius;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nvec3 repeat(vec3 p, vec3 s) {\n    return mod(p, s) - .5 * s;\n}\n\nfloat map(vec3 p) {\n    float d = 1e10;\n    vec3 q = vec3(mod(p.x, 1.), p.yz);\n    d = min(d, sdPlane(p, vec4(0, 1, 0, 1.)));\n    d = min(d, sdBox(p - vec3(-4, 1, 0), vec3(1, 2, 1)));\n    d = min(d, sdSphere(p - vec3(4, 0, 0), 2.));\n\treturn d;\n}\n\nvec3 mapGradient(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n\t));\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, float mint, float maxt, float k) {\n    float res = 1.0;\n    for(float t=mint; t < maxt;) {\n        float h = map(ro + rd*t);\n        if(h < 1e-4)\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph);\n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n   \n#if 1\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.0 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    float res = map( ro+rd*t );\n        if( res<precis || t>tmax ) break;\n        t += res;\n    }\n\n    if( t>tmax ) t=-1.0;\n    return t;\n}\n\nfloat rayProcess(vec3 camPos, vec3 rayDir, float start, float end) {\n\tfloat depth = start;\n\tfor(int i = 0; i < MARCHING_STEPS; ++i) {\n\t\tfloat dist = map(camPos + depth * rayDir);\n\t\tif(dist < EPSILON) return depth;\n\t\tdepth += dist;\n\t\tif(dist >= end) return end;\n\t}\n\treturn end;\n}\n\nvec3 rayDirection(float camAngle, vec2 coord) {\n\tvec2 uv = (coord - .5) * iResolution.xy;\n\tfloat focalDist = iResolution.y / 2. / tan(radians(camAngle) / 2.);\n\treturn normalize(vec3(uv, -focalDist));\n}\n\nvec3 applyLight(Material mat, Light light, vec3 p, vec3 eye) {\n\tvec3 n = mapGradient(p);\n\tvec3 l = normalize(light.pos - p);\n\tvec3 v = normalize(eye - p);\n\tvec3 r = reflect(-l, n);\n\n\t// ambient lighting\n\tvec3 col = mat.amb * light.iamb;\n\n\t// diffuse lighting\n    if(dot(l, n) > 0.) {\n        vec3 scol = vec3(0);\n    \tscol += calcSoftshadow(p, light.pos, MIN_DIST, MAX_DIST, 1);\n\t\tcol += scol * mat.diff * light.idiff * dot(l, n);\n    }\n        \t\n\t// specular lighting\n    if(dot(r, v) > 0.)\n\t\tcol += mat.spec * light.ispec * pow(dot(r, v), light.shininess);\n    \n    return col;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\nvec3 applyLight2(Light light, vec3 p, vec3 eye) {\n    vec3 col = vec3(0.);\n    vec3 pos = p;\n    vec3 nor = mapGradient( pos );\n    vec3 rd  = normalize(p - eye);\n\n    // material        \n    vec3 mate = vec3(0.3);\n\n    // key light\n    vec3  lig = normalize(light.pos);\n    vec3  hal = normalize( lig-rd );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) * \n        calcSoftshadow( pos, lig, 0.01, 3.0, 1);\n    //    softshadow( pos, lig, 0.01, 3.0, 10.);\n\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n        dif *\n        (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 6.0 ));\n\n    col = mate * 4.0*dif*vec3(1.00,0.70,0.5);\n    col +=      12.0*spe*vec3(1.00,0.70,0.5);\n\n    // ambient light\n    float occ = calcAO( pos, nor );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    col += mate*amb*occ*vec3(0.0,0.08,0.1);\n\n    // fog\n    //col *= exp( -0.0005*t*t*t );\n\treturn col;\n}\n\nvec3 shading(vec3 eye, vec3 p) {\n\tMaterial mat;\n\tmat.amb  = vec3(.2);\n\tmat.diff = vec3(.7, .7, .7 ); \n\tmat.spec = vec3(1.);\n\n\tLight light;\n\tlight.iamb = vec3(.5, .6, .7);\n\tlight.idiff = vec3(.5);\n\tlight.ispec = vec3(.4);\n\tlight.pos = vec3(0, 2., -4.);\n\tlight.shininess = 6.;\n\n\t//vec3 col = applyLight(mat, light, p, eye);\n    vec3 col = applyLight2(light, p, eye);\n\treturn col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 tot = vec3(0.);\n    \n    for(int i = 0; i < ALIASING_STEPS; ++i) {\n        for(int j = 0; j < ALIASING_STEPS; ++j) {\n            vec2 offset = vec2(i, j) / 2. - .5;\n            vec3 camPos = vec3(0., 5., 7.);\n            vec3 dir = rayDirection(60., (fragCoord + offset) / iResolution.xy);\n            \n            camPos.zx *= rot(iTime);\n            dir.yz *= rot(.5);\n            dir.zx *= rot(iTime);\n            \n            float depth = rayProcess(camPos, dir, MIN_DIST, MAX_DIST);\n            //float depth = castRay(camPos, dir);\n\n            vec3 col = vec3(0.);\n            if(depth > 0.) col = shading(camPos, camPos + depth * dir);\n            \n            // fog\n            col *= pow(smoothstep(MAX_DIST, 10., depth), 2.);\n            \n            // gamma\n            tot += pow(col, vec3(1. / 1.7));\n        }\n    }\n    \n    tot /= float(ALIASING_STEPS * ALIASING_STEPS);\n\tfragColor = vec4(tot, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}