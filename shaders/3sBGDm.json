{
    "Shader": {
        "info": {
            "date": "1549035892",
            "description": "Steiner Surfaces. [url]http://users.pfw.edu/CoffmanA/steinersurface.html[/url]\n\nMouse/up/down: change viewpoint\n'g': grid\n'q': projective space quaternion transform\n'r': rotation\n",
            "flags": 48,
            "hasliked": 0,
            "id": "3sBGDm",
            "likes": 3,
            "name": "Steiner Surfaces",
            "published": 3,
            "tags": [
                "surfaces",
                "steiner"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 489
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Created by Matthew Arcus, 2019\n// Steiner Surfaces, Raymarched\n//\n// Implicit equations from Adam Coffman:\n// http://users.pfw.edu/CoffmanA/steinersurface.html\n//\n// <mouse>: change viewpoint\n// <up/down arrow>: zoom in and out\n// 'r': rotation\n// 'q': projective space quaternion transform\n// 'g': show grid slices\n// 'a','d','s','m': lighting parameters\n//\n// Steiner surfaces are various representation of the projective plane,\n// including the cross cap and Steiner's Roman Surface.\n//\n// Where the surface intersects itself, there are lines of double\n// roots where both the implicit function and its\n// derivative are zero, so it's quite easy for the root finder to fail\n// here. There are also lines in the zero set spreading\n// out from the main surface that appear as \"whiskers\" here.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n#if __VERSION__ < 300\n#define texelFetch(x,y,z) (vec4(0))\n#endif\n\nconst float PI =  3.141592654;\nconst float TWOPI =  2.0*PI;\n\n// Display parameters\nconst float scale = 1.0;\nconst float camera = 2.0;\nconst float ambient = 0.4;\nconst float diffuse = 0.2;\nconst float specular = 1.0;\nconst float specpow = 25.0;\n\n // Debugging aids\nbool alert = false;\nvoid assert(bool test) {\n  if (!test) alert = true;\n}\n//#define assert(x)\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nfloat Boys(vec3 p) {\n  float t = 0.5-0.5*cos(iTime/PI);\n  // Coefficients from Adam Coffman:\n  // http://users.pfw.edu/CoffmanA/steinersurface.html\n  float x = p.x, y = p.y, z = p.z;\n  float x2 = x*x, y2 = y*y, z2 = z*z, t2 = t*t;\n  float x3 = x2*x, y3 = y2*y, z3 = z2*z, t3 = t2*t;\n  float x4 = x2*x2, y4 = y2*y2, z4 = z2*z2, t4 = t2*t2;\n  float x5 = x2*x3, y5 = y2*y3, z5 = z2*z3, t5 = t2*t3;\n  float x6 = x3*x3, y6 = y3*y3, z6 = z3*z3, t6 = t3*t3;\n  float s = sqrt(2.0);\n  return\n    - 24.0*z6 + 48.0*z5 - 32.0*z4 + 64.0/9.0*z3 - 16.0*y2*z2 - 16.0*z2*x2\n    - 81.0*y6*t2 - 81.0*x6*t2 - (144.0*t2 + 36.0)*y2*z2*x2\n    + (72.0*s*t2 - 72.0*s)*y2*z2*x + (24.0*s - 24.0*s*t2)*z2*x3 - (18.0 + 72.0*t2)*y4*z2\n    + (24.0 - 24.0*t2)*y2*z3 + (24.0 - 24.0*t2)*z3*x2 - (18.0 + 72.0*t2)*z2*x4\n    + (54.0*s*t3 - 54.0*s*t)*z*y5 - (36.0*s*t + 12.0*s*t3)*z3*y3\n    + (108.0*s*t - 108.0*s*t3)*x2*z*y3 + (108.0*s*t + 36.0*s*t3)*x2*z3*y\n    + (162.0*s*t - 162.0*s*t3)*x4*z*y + 72.0*s*y2*z3*x + 48.0*s*y3*z2*t\n    - 144.0*s*y*z2*x2*t - 324.0*s*y4*z*x*t2 - 216.0*s*y2*z*x3*t2 + 36.0*y4*z*t2\n    - 243.0*y2*x4*t2 + 36.0*z4*x2*t2 - 243.0*y4*x2*t2 + 36.0*z*x4*t2 - 24.0*s*z3*x3\n    + 36.0*y2*z4*t2 + 108.0*s*z*x5*t2 + 72.0*y2*z*x2*t2;\n}\n\nfloat Steiner(vec4 pos) {\n  // Coefficients from Adam Coffman:\n  // http://users.pfw.edu/CoffmanA/steinersurface.html\n  //p=cos(t)/sqrt(3) and q=sin(t)\n  //2(pq-p2)y2+(3p-q)xy2-x2y2+(1+2pq-2p2)y4+(p-q)xz2-x2z2+(2-8p2)y2z2+(1-2pq-2p2)z4\n  //(1-2pq-2p2)x4+4pqx2-4p2y2+4(p2-pq)x2y2+4p2y4-2(p+q)x2z+x2z2+y2z2\n  float x = pos.x, y = pos.y, z = pos.z, w = pos.w;\n  float t = 0.2*iTime;\n  float p = cos(t)/sqrt(3.0), q = sin(t);\n  float x2 = x*x, y2 = y*y, z2 =z*z, w2 = w*w, pq = p*q, p2 = p*p;\n  float x4 = x2*x2, y4 = y2*y2, z4 = z2*z2;\n#if 0\n  // Non-compact form\n  return\n    2.0*(pq-p2)*y2*w2 + (3.0*p-q)*x*y2*w - x2*y2 + (1.0+2.0*pq-2.0*p2)*y4\n    + (p-q)*x*z2*w - x2*z2 + (2.0-8.0*p2)*y2*z2 + (1.0-2.0*pq-2.0*p2)*z4;\n#else\n  return\n    (1.0-2.0*pq-2.0*p2)*x4 + 4.0*pq*x2*w2 - 4.0*p2*y2*w2 + 4.0*(p2-pq)*x2*y2\n    + 4.0*p2*y4 - 2.0*(p+q)*x2*z*w + x2*z2 + y2*z2;\n#endif\n}\n\nvec4 quat = vec4(0,0,0,1);\nvec4 qmul(vec4 p, vec4 q) {\n    return vec4(p.w*q.xyz+q.w*p.xyz+cross(p.xyz,q.xyz),\n                p.w*q.w-dot(p.xyz,q.xyz));\n}\n\nbool doquat = false;\n\nvec4 map4 (vec3 p) {\n    vec4 p4 = vec4(p,1);\n    if(doquat) p4 = qmul(p4,quat);\n    return p4;\n}\n\nfloat eval(vec3 p) {\n  return Steiner(map4(p));\n}\n\n// Could do this analytically...\nvec3 grad(vec3 p, float eps) {\n  vec2 e = vec2(0,eps);\n  return vec3(eval(p+e.yxx)-eval(p-e.yxx),\n              eval(p+e.xyx)-eval(p-e.xyx),\n              eval(p+e.xxy)-eval(p-e.xxy))/(2.0*eps);\n}\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_M = 77;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (!keypress(CHAR_R)) {\n    p.xz = rotate(p.xz,0.123*iTime);\n    //p.xy = rotate(p.xy,0.1*iTime);\n  }\n  return p;\n}\n\nfloat gridline(vec3 p) {\n  vec4 p4 = map4(p);\n  vec4 t = fract(p4*8.0);\n  t = min(t,1.0-t);\n  //float d = min(t.x,min(t.y,t.z));\n  float d = t.z;\n  return step(0.2,d);\n}\n\nfloat flip = 1.0;\nfloat map(vec3 pos, vec3 dir) {\n  float k = length(grad(pos,0.001));\n  return max(length(pos)-10.0,flip*eval(pos)/k);\n}\n\nfloat TMAX = 10.0;\nfloat fudge = 1.0;\nfloat hmax = 1.0;\nfloat march(vec3 ro, vec3 rd, float t) {\n  const int N = 200;\n  for(int i = 0; i < N; i++) {\n    //assert(i < 100);\n    float precis = 0.001;\n    float h = map(ro+rd*t,rd);\n    if (h < precis) return t;\n    h = min(h,hmax);\n    t += fudge*h;\n    if (t > TMAX ) break;\n  }\n  return 1e8;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec3 light = normalize(vec3(0.0,1.0,-1.0));\n  vec3 lightcolor = vec3(1);\n  vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n  vec3 p0 = vec3(0,0,-camera);     // point of projection\n  p0 *= 0.1*float(10+keycount(KEY_DOWN)-keycount(KEY_UP));\n  vec3 r = vec3(scale*uv,2);      // ray\n\n  light = transform(light);\n  p0 = transform(p0);\n  r = transform(r);\n  r = normalize(r);\n\n  if (keypress(CHAR_Q)) {\n    vec3 axis = vec3(0,0,1);\n    float theta = 0.2*iTime;\n    quat = vec4(sin(theta)*axis,cos(theta));\n    doquat = true;\n  }\n  float specmix = !keypress(CHAR_M) ? 0.0 : 1.0;\n  vec3 color = vec3(0);\n  float t = 0.1;\n  bool dogrid = !keypress(CHAR_G);\n  for (int i = 0; i < 3; i++) {\n    t = march(p0,r,t);\n    flip = -flip;\n    fudge = 0.5;\n    hmax = 0.25;\n    if (t > TMAX) break;\n    vec3 p = p0+t*r;\n    if (dogrid && gridline(p) != 0.0) {\n      t += 0.01;\n      continue;\n    }\n      float clipsphere = 0.0;\n      if (false && clipsphere > 0.0 && length(p) >= clipsphere) {\n          t += 0.01;\n          continue;\n      }\n    float eps = 0.01;\n    vec3 normal = grad(p,eps);\n    normal = normalize(normal);\n    vec3 basecolor = 0.5+0.5*abs(normal);\n    //vec3 basecolor = vec3(0.5);\n    if (dot(r,normal) > 0.0) normal = -normal;\n    if (!keypress(CHAR_A)) color += basecolor*ambient;\n    if (!keypress(CHAR_D)) color += basecolor*diffuse*(max(0.0,dot(light,normal)));\n    float spec = pow(max(0.0,dot(reflect(light,normal),vec3(r))),specpow);\n    vec3 specularcolor = mix(basecolor,lightcolor,specmix);\n    if (!keypress(CHAR_S)) color += specular*spec*specularcolor;\n    break;\n  }\n\n  color = sqrt(color);\n  if (alert) color.x = 1.0;\n  fragColor = vec4(color,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}