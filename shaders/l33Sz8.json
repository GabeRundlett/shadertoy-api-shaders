{
    "Shader": {
        "info": {
            "date": "1718587073",
            "description": "Implemented \"Trivial Algorithm for Interactive Water Simulation\" \nCheck out https://www.shadertoy.com/view/M33Sz8 for comparison\n\n",
            "flags": 32,
            "hasliked": 0,
            "id": "l33Sz8",
            "likes": 23,
            "name": "Trivial Water 3D",
            "published": 3,
            "tags": [
                "water"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 517
        },
        "renderpass": [
            {
                "code": "\n#define FOV 1.5\n#define R 900.\n#define size iResolution.xy\n\n#define OPAQUE\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 minm(vec2 a, vec2 b)\n{\n    return (a.x < b.x)?a:b;\n}\n\nvec2 suface(vec3 pos, float height, float mat, float thick)\n{\n    return vec2(0.20*sdBox(pos - vec3(size,200.*height - 2.0*thick)*0.5, vec3(size*0.5, thick)), mat);\n}\n\nvec4 getWater(vec3 pos)\n{\n    pos.xy += size*0.5;\n   \treturn pixel(ch0, pos.xy);\n}\n\n\n#define freq 15.\nvec2 DE(vec3 pos)\n{\n    vec4 water = getWater(pos);\n    pos.xy += size*0.5;\n    vec2 de = vec2(1e10, -1.0);\n    #ifdef OPAQUE\n    de = minm(de, suface(pos, water.x + water.y,2.0, 1.0));\n    #else\n    de = minm(de, suface(pos, water.x + water.y,1.0, 1.0));\n    #endif\n    de = minm(de, suface(pos, water.y+0.005, 0.0, 100.0));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx).x +\n\t\t\t K.yyxx*DE(p + K.yyx*dx).x +\n\t\t\t K.yxyx*DE(p + K.yxy*dx).x +\n\t\t\t K.xxxx*DE(p + K.xxx*dx).x)/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define M 512.\n#define min_d 0.1\nvec4 ray_march(vec3 p, vec3 r, out float mat, out float td)\n{\n    vec2 d;\n    td = 0.0;\n    for(float i = 0.; i < M; i++)\n    {\n        d = DE(p + td*r); \n        td += d.x;\n        if(d.x < min_d) break;\n        if(td > size.x*2.0) {\n            d.y = -1.0;\n            break;\n        }\n    }\n    mat = d.y;\n    return vec4(p + td*r, d.x);\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat traceRay(inout vec3 cpos, inout vec3 ray, inout vec3 incom, inout vec3 transm, bool underwater)\n{\n    vec4 fragColor = vec4(0.0);\n    float mat = 0.0;\n    float td = 0.0;\n    vec4 X = ray_march(cpos, ray, mat, td);\n    cpos = X.xyz;\n    if(td < size.x*2.0)\n    {\n        if(underwater)\n        {\n            transm *= 0.9*exp(-0.08*vec3(1.000,0.467,0.180)*max(td+3.0,0.0));\n            mat = 0.0;\n        }\n        vec4 N0 = calcNormal(X.xyz, 1.0);\n        vec3 n = normalize(N0.xyz);\n        vec3 l = normalize(vec3(1,1,1));\n        if(mat == 1.0)\n        {\n            vec3 rd = reflect(ray, n);\n            vec3 col = texture(iChannel2,  rd.yzx).xyz;\n            float K = 0.025+0.975*pow(1. - max(dot(n,rd),0.), 5.0);\n            incom += col*K*transm;\n            //transm *= (1.0 - K);\n            ray = refract(ray, n, 0.85);\n            cpos += ray*8.0;\n        }\n        if(mat == 0.0)\n        {\n            float dn = 0.5*dot(l, n)+0.5;\n            incom += vec3(1,1,1) * dn * transm;\n        }\n        if(mat == 2.0)\n        {\n            vec4 water = getWater(cpos);\n            vec2 vel = water.zw;\n            vec3 color1 = vec3(1,0,0)*max(dot(vel, vec2(-0.5,sqrt(3.0)*0.5)), 0.0);\n            color1 += vec3(0,1,0)*max(dot(vel, vec2(-0.5,-sqrt(3.0)*0.5)), 0.0);\n            color1 += vec3(0,0,1)*max(dot(vel, vec2(1.0,0.0)), 0.0);\n            float dn = 0.5*dot(l, n)+0.5;\n            incom += (vec3(0.412,0.400,1.000) + color1) * dn * transm;\n        }\n    }\n    else\n    {    \n        //background\n        incom += texture(iChannel2,  ray.yzx).xyz * transm;\n    }\n    \n    \n    return mat;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates \n    vec2 pos = (fragCoord - iResolution.xy*0.5)/max(iResolution.x,iResolution.y);\n    \n    vec2 uv = 0.0001*iMouse.xy/iResolution.xy;\n    vec2 angles = vec2(1.5+uv.x*1.5, -0.3+uv.y*0.25)*PI;\n    \n    vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n    vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n    vec3 camera_y = -normalize(cross(camera_x,camera_z));\n    \n    //tracking particle\n    vec4 fp = vec4(size.xyxy*0.5);\n    \n    vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n    vec3 cam_pos = vec3(fp.xy-size.xy*0.5, 0.0) - R*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n    \n    vec4 sphere = vec4(0.,0.,0., 1.);\n    \n    vec3 incom = vec3(0.0);\n    vec3 transm = vec3(1.0);\n    float mat = traceRay(cam_pos, ray, incom, transm,false);\n    \n    if(mat == 1.0) //refraction ray\n    {\n\n        traceRay(cam_pos, ray, incom, transm,true);\n    }\n    \n    //fragColor.xyz = vec3(mat/2.0);\n    fragColor.xyz = incom;\n    //fragColor.xyz = transm;\n    //fragColor.xyz = 0.5+0.5*ray;\n \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    // Compute the new flow\n    pos = floor(pos);\n    Water w = unpackWater(LOAD(ch0, pos), pos);\n    Water wx0 = unpackWater(LOAD(ch0, pos + vec2(-1, 0)), pos + vec2(-1, 0));\n    Water wx1 = unpackWater(LOAD(ch0, pos + vec2(1, 0)), pos + vec2(1, 0));\n    Water wy0 = unpackWater(LOAD(ch0, pos + vec2(0, -1)), pos + vec2(0, -1));\n    Water wy1 = unpackWater(LOAD(ch0, pos + vec2(0, 1)), pos + vec2(0, 1));\n\n    float h0 = w.height;\n    vec4 hxy = vec4(wx0.height, wx1.height, wy0.height, wy1.height);\n    vec4 outflow = max(vec4(0.0), h0 - hxy);\n    const float K = 0.998;\n    const float P = 0.25;\n    w.flow = w.flow * K + outflow * P;\n\n    float localFlow = sum(w.flow);\n    if(localFlow > w.depth) //to prevent the depth from becoming negative\n    {\n        w.flow = w.flow * w.depth / localFlow;\n    }\n    \n    fragColor = packWater(w);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define Bf(p) mod(p,iResolution.xy)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, Bf(p)/iResolution.xy)\n#define LOAD(ch, pos) texelFetch(ch, ivec2(pos), 0)\n\n#define PI 3.14159265\n\n\n#define VOID_POS vec2(250)\n#define VOID_SIZE 150.0\n\n#define SOURCE_POS vec2(R.xy*0.5+200.0*vec2(sin(time),cos(time)))\n#define SOURCE_SIZE 50.0\n\nstruct Water\n{\n    vec4 flow;\n    float depth;\n    float height;\n};\n\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a \n// single unsigned integer.\n\nuint hash(uint x, uint seed) {\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process input\n    uint k = x;\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a  \n// 2-dimensional unsigned integer input vector.\n\nuint hash(uvec2 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process first vector element\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process second vector element\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n\t// some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n\nvec2 gradientDirection(uint hash) {\n    switch (int(hash) & 3) { // look at the last two bits to pick a gradient direction\n    case 0:\n        return vec2(1.0, 1.0);\n    case 1:\n        return vec2(-1.0, 1.0);\n    case 2:\n        return vec2(1.0, -1.0);\n    case 3:\n        return vec2(-1.0, -1.0);\n    }\n}\n\nfloat interpolate(float value1, float value2, float value3, float value4, vec2 t) {\n    return mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y);\n}\n\nvec2 fade(vec2 t) {\n    // 6t^5 - 15t^4 + 10t^3\n\treturn t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlinNoise(vec2 position, uint seed) {\n    vec2 floorPosition = floor(position);\n    vec2 fractPosition = position - floorPosition;\n    uvec2 cellCoordinates = uvec2(floorPosition);\n    float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);\n    float value2 = dot(gradientDirection(hash((cellCoordinates + uvec2(1, 0)), seed)), fractPosition - vec2(1.0, 0.0));\n    float value3 = dot(gradientDirection(hash((cellCoordinates + uvec2(0, 1)), seed)), fractPosition - vec2(0.0, 1.0));\n    float value4 = dot(gradientDirection(hash((cellCoordinates + uvec2(1, 1)), seed)), fractPosition - vec2(1.0, 1.0));\n    return interpolate(value1, value2, value3, value4, fade(fractPosition));\n}\n\nfloat perlinNoise(vec2 position, int frequency, int octaveCount, float persistence, float lacunarity, uint seed) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    float currentFrequency = float(frequency);\n    uint currentSeed = seed;\n    for (int i = 0; i < octaveCount; i++) {\n        currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave\n        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n        amplitude *= persistence;\n        currentFrequency *= lacunarity;\n    }\n    return value;\n}\n\n\n\nfloat terrainHeight(vec2 pos)\n{\n    float h = perlinNoise(pos / 200.0, 1, 6, 0.4, 2.0, 3541u) * 1.0 + 2.0;\n    h -= 2.0*exp(-dot(pos - VOID_POS,pos - VOID_POS)/(VOID_SIZE*VOID_SIZE));\n    return h;\n}\n\nvec2 terrainGrad(vec2 pos)\n{\n    const float eps = 1.0;\n    vec2 n = vec2(terrainHeight(pos + vec2(eps, 0.0)) - terrainHeight(pos - vec2(eps, 0.0)),\n                  terrainHeight(pos + vec2(0.0, eps)) - terrainHeight(pos - vec2(0.0, eps))) / (2.0*eps);\n    return n;\n}\n\n\nvec3 terrainNormal(vec2 pos)\n{\n    const float eps = 1.5;\n    vec3 n = vec3(terrainHeight(pos + vec2(eps, 0.0)) - terrainHeight(pos - vec2(eps, 0.0)),\n                  terrainHeight(pos + vec2(0.0, eps)) - terrainHeight(pos - vec2(0.0, eps)),\n                  1.0*eps);\n    return normalize(n);\n}\n\n//5 bits for shared exponent, 9 bits for each component\nuint packvec3(vec3 v)\n{\n    //get the exponent\n    float maxv = max(abs(v.x), max(abs(v.y), abs(v.z)));\n    int exp = clamp(int(ceil(log2(maxv))), -15, 15);\n    float scale = exp2(-float(exp));\n    vec3 sv = v*scale;\n    sv = round(clamp(sv, -1.0, 1.0) * 255.0);\n    sv = sv + 255.0;\n    uint packed = uint(exp + 15) | (uint(sv.x) << 5) | (uint(sv.y) << 14) | (uint(sv.z) << 23);\n    return packed;\n}\n\nvec3 unpackvec3(uint packed)\n{\n    int exp = int(packed & 0x1Fu) - 15;\n    vec3 sv = vec3((packed >> 5) & 0x1FFu, (packed >> 14) & 0x1FFu, (packed >> 23) & 0x1FFu);\n    vec3 v = (sv - 255.0) / 255.0;\n    v *= exp2(float(exp));\n    return v;\n}\n\nvec4 packWater(Water w)\n{\n    uint packed0 = packvec3(vec3(w.flow.xy, 0.0));\n    uint packed1 = packvec3(vec3(w.flow.zw, 0.0));\n    return vec4(uintBitsToFloat(packed0), uintBitsToFloat(packed1), w.depth, 0.0);\n}\n\nWater unpackWater(vec4 packed, vec2 pos)\n{\n    Water w;\n    w.flow.xy = unpackvec3(floatBitsToUint(packed.x)).xy;\n    w.flow.zw = unpackvec3(floatBitsToUint(packed.y)).xy;\n    w.depth = packed.z;\n    w.height = terrainHeight(pos) + w.depth;\n    return w;\n}\n\nfloat sum(vec4 v)\n{\n    return v.x + v.y + v.z + v.w;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    // Compute the new inertia\n    pos = floor(pos);\n    Water w = unpackWater(LOAD(ch0, pos), pos);\n    Water wx0 = unpackWater(LOAD(ch0, pos + vec2(-1, 0)), pos + vec2(-1, 0));\n    Water wx1 = unpackWater(LOAD(ch0, pos + vec2(1, 0)), pos + vec2(1, 0));\n    Water wy0 = unpackWater(LOAD(ch0, pos + vec2(0, -1)), pos + vec2(0, -1));\n    Water wy1 = unpackWater(LOAD(ch0, pos + vec2(0, 1)), pos + vec2(0, 1));\n    \n    vec4 incomingFlow = vec4(wx1.flow.x, wx0.flow.y, wy1.flow.z, wy0.flow.w);\n    float localFlow = sum(w.flow);\n    float adjacentFlow = sum(incomingFlow);\n    w.depth = max(w.depth - localFlow + adjacentFlow, 0.0);\n    w.flow = mix(w.flow, incomingFlow, 0.0); //tried to add advection, doesnt work well\n\n    if(iMouse.z > 0.0)\n    {\n        vec2 mpos = iMouse.xy;\n        vec2 d = mpos - pos;\n        float r = length(d);\n        w.depth += 0.1 * exp(-r * r / 400.0);\n    }\n    \n    if(pos.x < 1.0 || pos.x > iResolution.x - 2.0 || pos.y < 1.0 || pos.y > iResolution.y - 2.0)\n    {\n        w.depth = 0.0;\n    }\n    \n    fragColor = packWater(w);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//smooth out the heighfield\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n    //render the water depth\n    pos = floor(pos);\n    Water w = unpackWater(LOAD(ch0, pos), pos);\n    float terrh = (w.height - w.depth);\n    col.x = w.depth;\n    col.y = terrh;\n    col.zw = 10.0*vec2(w.flow.y - w.flow.x, w.flow.w - w.flow.z);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}