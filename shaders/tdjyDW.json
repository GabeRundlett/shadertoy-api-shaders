{
    "Shader": {
        "info": {
            "date": "1586693966",
            "description": "Playing around virtual camera and pseudo-3d.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdjyDW",
            "likes": 3,
            "name": "A point of view",
            "published": 3,
            "tags": [
                "pseudo3d",
                "3dtranslation"
            ],
            "usePreview": 0,
            "username": "abelu",
            "viewed": 346
        },
        "renderpass": [
            {
                "code": "#define MAX_ITEMS_HALF 3.0\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvec3 rotate_3d(vec3 item, vec3 rotation) {\n    vec2 x = vec2(cos(rotation.x), sin(rotation.x));\n    vec2 y = vec2(cos(rotation.y), sin(rotation.y));\n    vec2 z = vec2(cos(rotation.z), sin(rotation.z));\n\n    return item *= mat3(\n        1., 0., 0.,\n        0., x.x, -x.y,\n        0., x.y, x.x\n    ) * mat3(\n        y.x, 0., y.y,\n        0., 1., 0.,\n        -y.y, 0., y.x\n    ) * mat3(\n        z.x, -z.y, 0.,\n        z.y, z.x, 0.,\n        0., 0., 1.\n    );\n}\n\nvec3 get_intersection_point(\n    vec2 st,\n    vec3 origin, \n    vec3 look_at, \n    float zoom\n) {\n    vec3 forward = normalize(look_at - origin);\n    vec3 right = cross(forward, vec3(0., 1., 0.));\n    vec3 up = cross(forward, right);\n\n    vec3 center = origin + forward * zoom;\n\n    return center + right * st.x + up * st.y;\n}\n\nfloat get_point_distance(vec3 point, vec3 origin, vec3 direction) {\n    return length(cross(point - origin, direction)) / length(direction);\n}\n\nfloat animate(float from, float to, float current_step) {\n    return sin(smoothstep(from, to, current_step) * PI * 0.5);\n}\n\nfloat get_point_color(\n    vec3 point, \n    vec3 origin, \n    vec3 direction,\n    float animation_step\n) {\n    float distance = get_point_distance(point, origin, direction);\n\n    return \n        smoothstep(0.2, 0.05, distance) * (\n            1.2 -\n            animate(0., 0.5, animation_step) + \n            animate(0.6, 1.0, animation_step)\n        ) +\n        smoothstep(0.1, 0.07, distance);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord/iResolution.xy;\n\n    float animation_step = fract(iTime * 0.2);\n\n    vec3 rotation = vec3(\n        0.0, \n        animate(0.3, 0.6, animation_step) * PI * 0.5,\n        animate(0.6, 1.1, animation_step) * PI * 0.5\n    );\n\n    st -= vec2(0.5);\n    st.x *= iResolution.x / iResolution.y;\n\n    vec3 look_at = vec3(0.0);\n    vec3 ray_origin = rotate_3d(\n        vec3(0.0, 0.0, -0.1 + animate(0.0, 0.33, animation_step) * -4.0),\n        rotation\n    );\n    vec3 intersection = get_intersection_point(\n        st,\n        ray_origin,\n        look_at,\n        1.0\n    );\n    vec3 ray_direction = intersection - ray_origin;\n\n    float color = 0.0;\n\n    color += length(st) * 0.5;\n\n    for (float i = -MAX_ITEMS_HALF; i <= MAX_ITEMS_HALF; i += 1.0) {\n        for (float j = -MAX_ITEMS_HALF; j <= MAX_ITEMS_HALF; j += 1.0) {\n            for (float k = -MAX_ITEMS_HALF; k <= MAX_ITEMS_HALF; k += 1.0) {\n                color += get_point_color(\n                    vec3(i, j, k),\n                    ray_origin, \n                    ray_direction,\n                    animation_step\n                );        \n            }\n        }\n    }\n\n    st += vec2(0.5);\n\n    fragColor = vec4(\n        vec3(color * st.y, color * st.x, color),\n        1.0\n    );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}