{
    "Shader": {
        "info": {
            "date": "1612381184",
            "description": "poato",
            "flags": 32,
            "hasliked": 0,
            "id": "tltfz4",
            "likes": 22,
            "name": "Day 413",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 418
        },
        "renderpass": [
            {
                "code": "\n// Don't fullscreen lol\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    C -= C;\n    \n    C += texture(iChannel1,U/iResolution.xy);\n\n \n    \n     \n    \n    C.xyz *= vec3(1.1,0.7,0.05);\n    C.xyz = pow(C.xyz,vec3(1.4,0.5,0.1));\n    C = pow(C,vec4(0.8));\n    \n    vec2 uv = U/iResolution.y;\n    float df = dFdx(uv.x);\n    /*\n    uv = pmod(uv,0.3);\n    \n    C -= smoothstep(df,0.,abs(uv.x))*0.1;\n    C -= smoothstep(df,0.,abs(uv.y))*0.1;\n    */\n    //C = 1. - C;\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float r11(float i) {return fract(sin(i*125.214)*124.125124);}\nfloat valueNoise(float i) {return mix(r11(floor(i)), r11(floor(i) + 1.),smoothstep(0.,0.3,fract(i)));}\n\n#define boxFold(z, foldingLimit)  z = clamp(z, -(foldingLimit), (foldingLimit)) * 2.0 - z;\nfloat map(vec3 p){\n    float d = 10e5;\n    p.y += 0.1;\n    \n    float rt = iTime/15.; \n    float id = floor(rt);\n    rt = fract(rt);\n    \n    p.yx *= rot(mod(id,4.)*0.25*pi*smoothstep(0.,0.1,rt)*(1. - smoothstep(0.3,0.5,rt)));//\n   \n    \n    p.xz *= rot(-1.2 + iTime*0.3);\n    vec4 q = vec4(p,1);\n    \n    \n    float m = valueNoise(iTime*0.5);\n    float mb = valueNoise(iTime*0.5 + 40. + 0.5);\n    \n    \n    //q = q/dot(q.xyz,q.xyz)/0.2;\n    \n    \n    //q = mix( q, qrev*0.2,1.);\n    \n    rt = fract(iTime/26. + 0.5);\n    //q = mix( q, q / dot(q.xyz,q.xyz)/0.2, smoothstep(0.,0.015,rt)*(1. - smoothstep(0.2,0.22,rt)));\n    \n    for(float i = 0.; i < 7.; i++){\n            \n        \n        if(q.x < q.z) q.xz = q.zx;\n        if(q.z > q.y) q.zy = q.yz;\n        \n        if(q.x > q.y) q.yx = q.xy;\n        \n        q = abs(q);\n         \n        if( i == 1. || i == 2.)\n            pmod(q.y,13.1 + mb*5.);\n        \n        if(i== 1.)\n            boxFold(q.x,4. - 1.*mb);\n        q *= 1.6;\n        \n        //q.xz *= rot(1.5*pi);\n        q.xyz -= vec3(.5,0.- m ,2.5 )*4.;\n    }\n    \n    \n    q.xyz /= q.w;\n    \n    d = length(q.x) - 0.01;\n\n\n    return d;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 t = vec2(0.001,0);\n    return normalize(\n        map(p) - vec3(\n            map(p -t.xyy),\n            map(p -t.yxy),\n            map(p -t.yyx)\n        )\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    \n    vec3 ro = vec3(0);\n    \n    vec3 rd = normalize(vec3(uv,0.4));\n    ro.z -= 2.;\n    \n    vec3 p = ro;\n    float t = 0.;\n    bool hit = false;\n    \n    for(int i = 0; i < 150; i++){\n        float d = map(p);\n        if(d < 0.01){\n            hit = true;\n            break;\n        }\n        \n        p = ro + rd*(t += d*0.5);\n    }\n    \n    \n    vec3 n = getNormal(p);\n    \n    \n    fragColor = vec4(n,t);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define R iResolution.xy\n#define T(a) texture(iChannel0, (a)/R)\n\n#define steps 5.\nvoid getEdge( vec4 me, vec2 U, vec2 dir, inout float dEdge){\n    for(float i = 0.; i < steps; i++){\n        vec2 sampleP = U + dir*i;\n        vec4 t = T(sampleP);\n        //if(abs(t.z - me.t) < 0.5 && dot(me.xyz,t.xyz) < 0.6){\n        if(dot(me.xyz,t.xyz) < 0.95 || abs(t.w - me.w) > 0.15){\n        //if(dot(me.xyz,t.xyz) < 0.95 ){\n        \n            dEdge = min(dEdge, i);\n            break;\n        }\n    }\n\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = U/R;\n    vec2 uvn = (U - 0.5*R)/R.y;\n    vec4 me = T(U);\n        \n    \n    float dEdge = 10e2;\n    getEdge( me, U, vec2(0,1), dEdge);\n    getEdge( me, U, vec2(0,-1), dEdge);\n    getEdge( me, U, vec2(1,0), dEdge);\n    getEdge( me, U, vec2(-1,0), dEdge);\n    \n    getEdge( me, U, vec2(1,1), dEdge);\n    getEdge( me, U, vec2(1,-1), dEdge);\n    getEdge( me, U, vec2(-1,1), dEdge);\n    getEdge( me, U, vec2(1,1), dEdge);\n    \n    \n    dEdge /= (R.y);\n    \n    C += 1.;\n    vec2 nuv = U/R.y*20.;\n    \n    nuv*= rot(0.5);\n    \n    nuv.x  *= 12.;\n    \n    \n    float shading = cyclicNoiseB(vec3(nuv + vec2( floor(iTime*12.5)*0.2,0.),floor(iTime*12.5)*10.1 ), false, 0.)\n        + cyclicNoise(vec3(U/R.y*410. ,floor(iTime*12.5)*10.1 ), false, 0.) - 0.2\n        ;\n    \n    C = mix(C,vec4(shading)*0.8, max(dot(me.xyz,normalize(vec3(1,1,0))),0.1));\n    \n    //C = mix(C,vec4(shading)*1., dot(uvn,uvn*0.3));\n    \n    \n    //dEdge = mix(dEdge,-0., max(dot(me.xyz,normalize(vec3(-1,-1,-1))),0.));\n    \n    //C += me.xyzz;\n    nuv = U/R.y*120.;\n    \n    nuv*= rot(0.5);\n    \n    nuv.x  *= 2.;\n    float n = cyclicNoise(vec3(nuv,4. + floor(iTime*12.5)*10.1 ), false, 0.);\n    n = n*2. - 1.;\n    dEdge += n*0.002;\n    dEdge -= 0.0005;\n    C = mix(C,vec4(0),smoothstep(dFdx(U.x/R.y)*2.25,0.,dEdge + 0.0004)*1.);\n    \n    \n    \n    //C = texture(iChannel0,U/R);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pi acos(-1.)\n\n\n#define pmod(p,a) p = mod(p - 0.5*(a),(a)) - 0.5*(a)\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    p.yz *= rot(0.5);\n    float amp = 1.;\n    float gain = 0.8 + sin(p.z*0.2)*0.2;\n    const float lacunarity = 1.6;\n    const int octaves = 5;\n    \n    const float warp =1.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\nfloat cyclicNoiseB(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    p.yz *= rot(0.5);\n    float amp = 1.;\n    float gain = 0.8 + sin(p.z*0.2)*0.2;\n    const float lacunarity = 1.6;\n    const int octaves = 5;\n    \n    const float warp =2.2;    \n    float warpTrk =1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}