{
    "Shader": {
        "info": {
            "date": "1687015000",
            "description": "A simple analog clock displaying real-time. Smoothing on second hand can be changed around line 55, sizes of the different elements around line 65. Suitable as Lively wallpaper if you so desire. Please note that this AA implementation is bad.",
            "flags": 0,
            "hasliked": 0,
            "id": "cdscz2",
            "likes": 2,
            "name": "Test: Analog clock (MitSync)",
            "published": 3,
            "tags": [
                "test",
                "simple",
                "time",
                "clock",
                "antialiasing",
                "analog",
                "smoothstep",
                "wallpaper",
                "lively"
            ],
            "usePreview": 0,
            "username": "Mitsync",
            "viewed": 208
        },
        "renderpass": [
            {
                "code": "// MitSync, 2023\n\n#define M_PI 3.1415926535897932384626433832795\n\n// Calculates if the uv coordinate is on a hand with a certain angle and length\n// hand_size is a vec3 containing start and end distances from the center and width\n//    eg vec3(0.1, 0.5, 0.01) for a short, thin hand. Negative start distance is allowed\nfloat on_hand( in float hand_angle, in vec3 hand_size, in vec2 uv, in float aa_size )\n{\n    // Calculate vector at the hand angle and normal at 90deg to it\n    vec2 hand = vec2(cos(hand_angle), sin(hand_angle));\n    vec2 hand_normal = vec2(cos(hand_angle + .5*M_PI), sin(hand_angle + .5*M_PI));\n    \n    // Calculate (signed) distance from UV point to infinite line through the hand, and line at 90deg to hand\n    float d_hand = dot(uv, hand_normal);\n    float d_norm = dot(uv, hand);\n    \n    // Distance to the normal should be between hand_size.xy and distance to hand less than width hand_size.z\n    // Calculate AA'd rectangle\n    float lum_width = 1. - smoothstep(hand_size.z-aa_size,hand_size.z, abs(d_hand));\n    float lum_length = smoothstep(hand_size.x-aa_size, hand_size.x, d_norm) - smoothstep(hand_size.y-aa_size, hand_size.y, d_norm);\n    return lum_width * lum_length;\n}\n\n// If you really think about it, ticks are just small, static hands\n// Ok not really but we can use the same code to draw them\nfloat on_tick( in vec3 tick_size, in vec2 uv, in float pix_siz )\n{\n    float num_ticks = 12.;\n    float sum = 0.;\n    for (float i = 0.; i < num_ticks; i++) sum += on_hand(2.*M_PI*i/num_ticks, tick_size, uv, pix_siz);\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates ((0,0) is center, y goes from -1 to 1, aspect ratio preserved)\n    vec2 uv = ((2.0 * fragCoord)-iResolution.xy) / iResolution.y;\n    \n    // Size of pixels in UV, used for my poor-mans AA (smoothstep instead of conditionals)\n    float aa_size = 3. / iResolution.y;\n    \n    // Angles of the three hands: x=hour, y=minute, z=second\n    float t = iDate.w;\n    vec3 angles = vec3(0.0);\n    // Calculate angles from time\n    angles.x = 0.5*M_PI - (2.*M_PI * fract(t/(12.*3600.)));\n    angles.y = 0.5*M_PI - (2.*M_PI * fract(t/3600.));\n    \n    // floor(t) to get snapping motion of second hand, smoothstep(fract(t)) to add smoothing\n    // Change jerk_alignment and jerk_length to change snapping feel\n    float jerk_alignment = 1. / 0.50;\n    float jerk_length = 1.20 / 2.;\n    float jerky_t = (floor(jerk_alignment*t)+smoothstep(0.5-jerk_length, 0.5+jerk_length, fract(jerk_alignment*t))) / jerk_alignment;\n    angles.z = 0.5*M_PI - (2.*M_PI * fract(jerky_t/60.));\n    \n    // Make sure angles are within [0, 2*PI)\n    angles.x = angles.x < 0. ? angles.x + 2.*M_PI : angles.x;\n    angles.y = angles.y < 0. ? angles.y + 2.*M_PI : angles.y;\n    angles.z = angles.z < 0. ? angles.z + 2.*M_PI : angles.z;\n    \n    // Calculate contributions of each element of the clock\n    float uv_dist = length(uv);\n    float edge = smoothstep(0.9-aa_size, 0.9, uv_dist) - smoothstep(0.915-aa_size, 0.915, uv_dist);\n    float hub = 1. - smoothstep(0.03-aa_size, 0.03, uv_dist);\n    float tick = on_tick(vec3(0.83, 0.88, 0.008), uv, aa_size);\n    float hour_hand = on_hand(angles.x, vec3(0.075, 0.45, 0.010), uv, aa_size);\n    float minute_hand = on_hand(angles.y, vec3(0.075, 0.7, 0.008), uv, aa_size);\n    float second_hand = on_hand(angles.z, vec3(-0.075, 0.8, 0.005), uv, aa_size);\n\n    // Merge contributions from the different clock elements and output a final color\n    vec3 edge_col = (edge + tick) * vec3(0.322,0.322,0.322);\n    vec3 hand_col = (hub + hour_hand + minute_hand + second_hand) * vec3(1.000,1.000,1.000);\n\n    fragColor = vec4(edge_col + hand_col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}