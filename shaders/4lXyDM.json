{
    "Shader": {
        "info": {
            "date": "1512724303",
            "description": "just for fun: old school anaglyph version of kleinian variation",
            "flags": 32,
            "hasliked": 0,
            "id": "4lXyDM",
            "likes": 32,
            "name": "Kleinian Anaglyph",
            "published": 3,
            "tags": [
                "anaglyph",
                "kleinian"
            ],
            "usePreview": 0,
            "username": "iapafoto",
            "viewed": 1095
        },
        "renderpass": [
            {
                "code": "//#define WITH_VIGNETING\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 res = iResolution.xy, \n          q = fragCoord/res;\n  \tvec4 buff1 = texture(iChannel0, q);   \t\n    vec4 buff2 = texture(iChannel1, q); \n    \n    float b = (buff1.r + buff1.g + buff1.b)/3.;\n    float r = (buff2.r + buff2.g + buff2.b)/3.;\n    \n    vec4 c = vec4(r*1.5,b,b,1.);\n    \n#ifdef WITH_VIGNETING\n    c.rgb *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .3); \n#endif\n    \n    fragColor = 1.5*pow(c,vec4(.6,.6,.6,1.));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Created by sebastien durand - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n// Text - Thanks to Andre [Shadertext]\n// Andre - https://www.shadertoy.com/view/lddXzM \n//-----------------------------------------------------\n// Music - Yann Tiersen - Summer 78 (10dens remix) (2010)\n//-----------------------------------------------------\n\n#define WITH_SHADOWS\n#define WITH_AO\n#define WITH_VIGNETING\n\n#define BACK_COLOR vec3(.08, .16, .34) \n\n#define PRECISION_FACTOR 5e-4\n#define MIN_DIST_RAYMARCHING .01\n#define MAX_DIST_RAYMARCHING 4.\n#define MAX_RAYMACING_ITERATION 132 \n\n#define MIN_DIST_SHADOW 10.*PRECISION_FACTOR\n#define MAX_DIST_SHADOW .25\n#define PRECISION_FACTOR_SHADOW 3.*PRECISION_FACTOR\n\n#define MIN_DIST_AO .5*PRECISION_FACTOR\n#define MAX_DIST_AO .02\n#define PRECISION_FACTOR_AO PRECISION_FACTOR\n\n#define LIGHT_VEC normalize(vec3(.2,.7, 1.6) )\n\n#define NB_ITERATION 7\n//#define WITH_AA\n\n//-----------------------------------------------\n//                 TEXT by Andre\n//-----------------------------------------------\n// Andre - https://www.shadertoy.com/view/lddXzM \n//-----------------------------------------------\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba)/dot(ba,ba), 0., 1.));\n}\nfloat _u(vec2 uv,float w,float v) {\n    return length(vec2(abs(length(vec2(uv.x,max(0.,-(.4-v)-uv.y) ))-w),max(0.,uv.y-.4)));\n}\nfloat _i(vec2 uv) {\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.4)));\n}\nfloat _l(vec2 uv) {\n    uv.y -= .2;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.6)));\n}\nfloat _o(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25);\n}\nfloat aa(vec2 uv) {\n    uv = -uv;\n    float x = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.2)-.2))));\n    return min(x,(uv.x<0.?uv.y<0.:atan(uv.x,uv.y+0.15)>2.)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254)));\n}\nfloat ee(vec2 uv) {\n    float x = _o(uv);\n    return min(uv.x<0.||uv.y>.05||atan(uv.x,uv.y+0.15)>2.?x:length(vec2(uv.x-.22734,uv.y+.254)),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.05)));\n}\nfloat ii(vec2 uv) {\n    return min(_i(uv),length(vec2(uv.x,uv.y-.7)));\n}\nfloat kk(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.4));\n    x = min(x,line(uv,vec2(-.15,.0), vec2(0.25,-0.4)));\n    uv.x+=.25;\n    return min(x,_l(uv));\n}\nfloat nn(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x+=.25;\n    return min(x,_i(uv));\n}\n\n#define ch(l) if (nr++==ofs) x=min(x,l(uv));\n\nvoid drawText(float time, vec2  uv, inout vec4 color) {\n    if (time>12.6 && time <14.1) {\n        float anim = smoothstep(0.,1.,smoothstep(13.6, 14.1, time));\n\n        uv -= .5*iResolution.xy;\n        uv += (.5 + mix(vec2(-.1,.4), vec2(.2,.3), anim)) * iResolution.xy;\n        uv = (uv-.5*iResolution.xy) / iResolution.x * 22.0 * mix(1.,.5,anim);\n        \n        float ofs = floor(uv.x), x = 1., nr = 0.;\n        uv.x = mod(uv.x,1.)-.5;\n        \n\t\tch(kk);ch(_l);ch(ee);ch(ii);ch(nn);ch(ii);ch(aa);ch(nn); \n        \n        float px = 17./iResolution.x, clr = smoothstep(.06-px,.06+px, x);\n        color = mix(color, mix(vec4(0,0,0,.5), color, clr), smoothstep(12.6, 13., time)*(1.-anim));\n    }\n}\n\n\n//-----------------------------------------------\n\n\nvec2 kColor;\nvec4 mins;\nvec4 maxs;\n\n//knighty's pseudo kleinian\nfloat de(vec3 p) {\n    float k, scale=1.;\n    for(int i=0;i<NB_ITERATION;i++) {\n        p = 2.*clamp(p, mins.xyz,maxs.xyz)-p;\n        k = max(mins.w/dot(p,p), 1.);\n        p *= k;\n        scale *= k;\n    }\n    float rxy = length(p.xy);\n    return .7*max(rxy-maxs.w, /*abs*/(rxy*p.z) / length(p))/scale;\n}\n\nfloat ce(vec3 p) {\n    float k,r2, orb = 1.;\n    for(int i=0;i<NB_ITERATION;i++) {\n        p = 2.*clamp(p, mins.xyz, maxs.xyz)-p;\n        r2 = dot(p,p);\n        orb = min(orb, r2);\n        k = max(mins.w/r2,1.);\n        p *= k;\n    }\n    return kColor.x + kColor.y*sqrt(orb);\n}\n\nfloat rayIntersect(const vec3 ro, const vec3 rd, const float prec, const float mind, const float maxd) {\n    float h, t = mind;\n    for(int i=0; i<MAX_RAYMACING_ITERATION; i++ ) {\n        h = de(ro+rd*t);\n        if (h<prec*t||t>maxd)break;\n        t += h;\n    }\n    return t;\n}\n\nvec2 trace(const vec3 ro, const vec3 rd ) {\n    float d = rayIntersect(ro, rd, PRECISION_FACTOR, MIN_DIST_RAYMARCHING, MAX_DIST_RAYMARCHING);\n    return (d>0.) ? vec2(d, ce(ro+rd*d)) : vec2(-1., 1.);\n}\n\n\n#ifdef WITH_SHADOWS\n\nfloat shadow(vec3 ro, vec3 rd) {\n    float d = rayIntersect(ro, rd, PRECISION_FACTOR_SHADOW, MIN_DIST_SHADOW, MAX_DIST_SHADOW);\n    return (d>0.) ? smoothstep(0., MAX_DIST_SHADOW, d) : 1.;\n}\n\n#endif\n\n\n#ifdef WITH_AO\n\nfloat calcAO4(const vec3 pos, const vec3 nor ) {\n    float hr, occ = 0., sca = 1.;\n    for(int i=0; i<5; i++ ) {\n        hr = MIN_DIST_AO + MAX_DIST_AO*float(i)/4.;\n        occ += -(de( nor * hr + pos)-hr)*sca;\n        sca *= .95;\n    }\n    return clamp(1. - 10.*occ, 0., 1.);    \n}\n\n#endif\n\n\nvec3 calcNormal(const vec3 pos, const float t ){\n    vec3 e = (PRECISION_FACTOR * t * .57) * vec3(1, -1, 0);\n    return normalize(e.xyy*de(pos + e.xyy) + \n\t\t     e.yyx*de(pos + e.yyx) + \n\t\t     e.yxy*de(pos + e.yxy) + \n             e.xxx*de(pos + e.xxx) );\n}\n\nvec3 RD(const vec3 ro, const vec3 ww, const vec3 vv, const vec3 uu, const vec2 xy, const vec2 r, const float fov) { \n    vec3 er = normalize(vec3((2. * (xy.x/r.x) - 1.)* r.x/r.y,  (2. * (xy.y/r.y) - 1.), fov));\n    return normalize( er.x*uu + er.y*vv + er.z*ww );\n}\n\nvec4 renderScene(const vec3 ro, const vec3 rd) {\n    \n    vec3 col = BACK_COLOR;\n    vec2 res = trace(ro, rd);\n    float t = res.x;\n\n\n    vec3 pos = ro + t*rd,\n        nor = calcNormal( pos, t),\n        ref = reflect( rd, nor),\n        lig = LIGHT_VEC;\n    // Color\n    col = .5 + .5*cos( 6.2831*res.y + vec3(0,1,2) ); \n\n    // lighting        \n    #ifdef WITH_AO\n    float occ = calcAO4(pos, nor);\n    #else\n    float occ = 1.;\n    #endif\n\n    #ifdef WITH_SHADOWS\n    float sh = .2+.8*shadow( pos, lig); //, 0.1, t );\n    #else\n    float sh = 1.;\n    #endif\n\n    #ifdef ONLY_AO\n    col = (vec3)occ*(.5+.5*sh);\n    #else\n\n    float amb = .3;\n    float dif = clamp( dot( nor, lig ), 0., 1.);\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.,-lig.z))), 0., 1. )*clamp( 1.-pos.y,0.,1.);\n    float dom = smoothstep( -.1, .1, ref.y );\n    float fre = clamp(1.+dot(nor,rd),0.,1.);\n    fre *= fre;\n    float spe = pow(clamp( dot( ref, lig ), 0., 1. ),99.);\n\n    vec3 lin = vec3(.3) + \n        + 1.3*sh*dif*vec3(1.,0.8,0.55)\n        + 2.*spe*vec3(1.,0.9,0.7)*dif\n        + .5*occ*( .4*amb*vec3(0.4,0.6,1.) +\n                  .5*sh*vec3(0.4,0.6,1.) +\n                  .25*fre*vec3(1.,1.,1.));\n\n    col *= lin;\n\n    #endif\n    // Shading.\n    float atten = 1./(1. + t*.2 + t*.1); // + distlpsp*distlpsp*0.02\n    col *= atten*col*occ;\n    col = mix(col, BACK_COLOR, smoothstep(0.2, 1., t/MAX_DIST_RAYMARCHING));\n\n\n    return vec4((col),t);\n}\n\n\n// - Interpolation ----------------------------------------------\n\n#define NB 16\n\nfloat[] \n    camx = float[] ( .2351, 1.2351, 1.2351, 1., .2, .41, /*.545,.545,*/ .5,.084,.145,  3.04,.12, .44,.44,.416, -1.404, .21,.2351, .2351),\n\tcamy = float[] (-.094,  .35,     .28,  .38,  .04, .11, /*-.44,-.44,*/.35,.0614,.418, 1.,-.96, .67,.8,.0, -1., -.06,-.094),\n\tcamz = float[] ( .608,  .608,    .35,   .3608, -.03, .48,/*.032,.032,*/ .47,0.201,.05,.28,.3, 1.445,1.,1.4, 2.019, .508,.608),\n\n \tlookx = float[] (-.73, -.627, -1., -.3, -1., -.72, /*-.82,-.82,*/-.67,-.5,-.07,-.67,-.27, -.35,-.35,-.775, .08, -.727),\n\tlooky = float[] (-.364, -.2,   -.2,  -.2,  0., -.39, /*-.5, -.5,*/-.56,-.37,-.96,-.74,-.94, -.35,-.35,-.1, .83,-.364),\n\tlookz = float[] (-.582, -.582, -.5, -.35, -.0, -.58, /*-.2776,-.2776,*/-.48,-.79,-.25,.06,-.18, -.87,-.87,.23, .55, -.582),\n\n\tminsx = float[] (-.3252,-.3252,-.3252,-.3252,-.3252,-.3252,/*-.3252,-1.1,*/ -1.05,-1.05,-1.21,-1.22,-1.04,-0.737,-.62,-10., -.653,  -.653, -.3252),\n\tminsy = float[] (-.7862,-.7862,-.7862,-.7862,-.7862,-.7862,/*-.7862,-.787,*/ -1.05,-1.05,-.954,-1.17,-.79,-0.73,-.71,-.75, -2.,   -2., -.7862),\n\tminsz = float[] (-.0948,-.0948,-.0948,-.0948,-.0948,-.0948,/*-.0948,-.095,*/-0.0001,-0.0001,-.0001,-.032,-.126,-1.23,-.85,-.787, -.822, -1.073, -.0948),\n    minsw = float[] ( .69, .69, .69, .69, .69, .678, /*.678,  .678,*/.7,.73,1.684,1.49,.833, .627,.77,.826,  1.8976, 1.8899, .69),\n\n\tmaxsx = float[] ( .35,.3457,.3457,.3457,.3457, .3457,/*.3457,.3457,*/ 1.05,1.05,.39,.85,.3457,.73,.72,5., .888,  .735, .35),\n\tmaxsy = float[] (1.,1.0218,1.0218,1.0218,1.0218,/*1.0218,1.0218,*/1.0218,1.05,1.05,.65,.65,1.0218,0.73,.74,1.67, .1665, 1.),\n\tmaxsz = float[] (1.22,1.2215,1.2215,1.2215,1.2215,1.2215,/*1.2215,1.2215, */1.27,1.4,1.27,1.27,1.2215,.73,.74,.775, 1.2676, 1.22),\n    maxsw = float[] ( .84, .84, .84, .84, .84, .9834,/*.9834,.9834,*/.95,.93,2.74,1.23,.9834, .8335,.14,1.172, .7798, .84);\n\n// Deph of field animation\nfloat[] deph = float[] ( 1.,.65,.6,.4,.2,.4,/*.055,.055,*/.65,.11,.13,1.3,.49,1.2,1.2,.5,.65,.45,1.,1.);\n\n\n#define BPM 127.\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n    float t = .1 * iTime,\n\t\t kt = smoothstep(0.,1.,fract(t));\n\n    // - Interpolate positions and fractal configuration ---------------------\n    int  i0 = int(t)%NB, i1 = i0+1;\n\n    vec4 csum = vec4(0); \n#ifdef WITH_AA\n    for (int ii=0;ii<2;ii++)\n        for (int jj=0;jj<2;jj++) {\n    vec2 res = iResolution.xy, q = (fragCoord+.5*vec2(ii,jj))/res;\n#else\n    vec2 res = iResolution.xy, q = fragCoord/res;\n#endif            \n    \n    vec3 ro = mix(vec3(camx[i0],camy[i0],camz[i0]), vec3(camx[i1],camy[i1],camz[i1]), kt),\n         ww = mix(vec3(lookx[i0],looky[i0],lookz[i0]), vec3(lookx[i1],looky[i1],lookz[i1]), kt), \n         vv = -normalize(cross(ww, vec3(0,1,0))),\n         uu = -normalize(cross(vv,ww)),\n    \t er = vec3((2. * q.x - 1.) * res.x/res.y,  (2. * q.y - 1.), 3.),\n         rd = normalize(er.x*uu + er.y*vv + er.z*ww );\n\n    //---------------------------------------------\n    \n    ro += uu*.0025,\n         ww = mix(vec3(lookx[i0],looky[i0],lookz[i0]), vec3(lookx[i1],looky[i1],lookz[i1]), kt), \n         vv = -normalize(cross(ww, vec3(0,1,0))),\n         uu = -normalize(cross(vv,ww)),\n    \t er = vec3((2. * q.x - 1.) * res.x/res.y,  (2. * q.y - 1.), 3.),\n         rd = normalize(er.x*(uu-.0001) + er.y*vv + er.z*ww );\n\n    \n    //---------------------------------------------\n    \n    \n    mins = mix(vec4(minsx[i0],minsy[i0],minsz[i0],minsw[i0]), vec4(minsx[i1],minsy[i1],minsz[i1],minsw[i1]), kt),\n    maxs = mix(vec4(maxsx[i0],maxsy[i0],maxsz[i0],maxsw[i0]), vec4(maxsx[i1],maxsy[i1],maxsz[i1],maxsw[i1]), kt);\n\n    // - Music light (BPM by iq) ---------------------------------------------\n//\tfloat h = fract( .25 + .5*iChannelTime[1]*BPM/60. ),\n//\t\t  f = (1.-smoothstep( 0., 1., h )) * smoothstep( 4.5, 4.51, iChannelTime[1]),\n//\t\t  r =  exp(-4.*f);\n    \n    kColor = vec2(.25,1.);\n \n    // - Rendering -----------------------------------------------------------    \n    csum += renderScene(ro, rd);\n            \n    // - Adding Text ---------------------------------------------------------\n//\tdrawText(mod(t,float(NB)), fragCoord, c);\n#ifdef WITH_AA\n}\n            csum /= 4.;\n#endif\n    fragColor = csum;\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// Created by sebastien durand - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n// Text - Thanks to Andre [Shadertext]\n// Andre - https://www.shadertoy.com/view/lddXzM \n//-----------------------------------------------------\n// Music - Yann Tiersen - Summer 78 (10dens remix) (2010)\n//-----------------------------------------------------\n\n#define WITH_SHADOWS\n#define WITH_AO\n#define WITH_VIGNETING\n\n#define BACK_COLOR vec3(.08, .16, .34) \n\n#define PRECISION_FACTOR 5e-4\n#define MIN_DIST_RAYMARCHING .01\n#define MAX_DIST_RAYMARCHING 4.\n#define MAX_RAYMACING_ITERATION 132 \n\n#define MIN_DIST_SHADOW 10.*PRECISION_FACTOR\n#define MAX_DIST_SHADOW .25\n#define PRECISION_FACTOR_SHADOW 3.*PRECISION_FACTOR\n\n#define MIN_DIST_AO .5*PRECISION_FACTOR\n#define MAX_DIST_AO .02\n#define PRECISION_FACTOR_AO PRECISION_FACTOR\n\n#define LIGHT_VEC normalize(vec3(.2,.7, 1.6) )\n\n#define NB_ITERATION 7\n//#define WITH_AA\n\n//-----------------------------------------------\n//                 TEXT by Andre\n//-----------------------------------------------\n// Andre - https://www.shadertoy.com/view/lddXzM \n//-----------------------------------------------\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba)/dot(ba,ba), 0., 1.));\n}\nfloat _u(vec2 uv,float w,float v) {\n    return length(vec2(abs(length(vec2(uv.x,max(0.,-(.4-v)-uv.y) ))-w),max(0.,uv.y-.4)));\n}\nfloat _i(vec2 uv) {\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.4)));\n}\nfloat _l(vec2 uv) {\n    uv.y -= .2;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.6)));\n}\nfloat _o(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25);\n}\nfloat aa(vec2 uv) {\n    uv = -uv;\n    float x = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.2)-.2))));\n    return min(x,(uv.x<0.?uv.y<0.:atan(uv.x,uv.y+0.15)>2.)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254)));\n}\nfloat ee(vec2 uv) {\n    float x = _o(uv);\n    return min(uv.x<0.||uv.y>.05||atan(uv.x,uv.y+0.15)>2.?x:length(vec2(uv.x-.22734,uv.y+.254)),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.05)));\n}\nfloat ii(vec2 uv) {\n    return min(_i(uv),length(vec2(uv.x,uv.y-.7)));\n}\nfloat kk(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.4));\n    x = min(x,line(uv,vec2(-.15,.0), vec2(0.25,-0.4)));\n    uv.x+=.25;\n    return min(x,_l(uv));\n}\nfloat nn(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x+=.25;\n    return min(x,_i(uv));\n}\n\n#define ch(l) if (nr++==ofs) x=min(x,l(uv));\n\nvoid drawText(float time, vec2  uv, inout vec4 color) {\n    if (time>12.6 && time <14.1) {\n        float anim = smoothstep(0.,1.,smoothstep(13.6, 14.1, time));\n\n        uv -= .5*iResolution.xy;\n        uv += (.5 + mix(vec2(-.1,.4), vec2(.2,.3), anim)) * iResolution.xy;\n        uv = (uv-.5*iResolution.xy) / iResolution.x * 22.0 * mix(1.,.5,anim);\n        \n        float ofs = floor(uv.x), x = 1., nr = 0.;\n        uv.x = mod(uv.x,1.)-.5;\n        \n\t\tch(kk);ch(_l);ch(ee);ch(ii);ch(nn);ch(ii);ch(aa);ch(nn); \n        \n        float px = 17./iResolution.x, clr = smoothstep(.06-px,.06+px, x);\n        color = mix(color, mix(vec4(0,0,0,.5), color, clr), smoothstep(12.6, 13., time)*(1.-anim));\n    }\n}\n\n\n//-----------------------------------------------\n\n\nvec2 kColor;\nvec4 mins;\nvec4 maxs;\n\n//knighty's pseudo kleinian\nfloat de(vec3 p) {\n    float k, scale=1.;\n    for(int i=0;i<NB_ITERATION;i++) {\n        p = 2.*clamp(p, mins.xyz,maxs.xyz)-p;\n        k = max(mins.w/dot(p,p), 1.);\n        p *= k;\n        scale *= k;\n    }\n    float rxy = length(p.xy);\n    return .7*max(rxy-maxs.w, /*abs*/(rxy*p.z) / length(p))/scale;\n}\n\nfloat ce(vec3 p) {\n    float k,r2, orb = 1.;\n    for(int i=0;i<NB_ITERATION;i++) {\n        p = 2.*clamp(p, mins.xyz, maxs.xyz)-p;\n        r2 = dot(p,p);\n        orb = min(orb, r2);\n        k = max(mins.w/r2,1.);\n        p *= k;\n    }\n    return kColor.x + kColor.y*sqrt(orb);\n}\n\nfloat rayIntersect(const vec3 ro, const vec3 rd, const float prec, const float mind, const float maxd) {\n    float h, t = mind;\n    for(int i=0; i<MAX_RAYMACING_ITERATION; i++ ) {\n        h = de(ro+rd*t);\n        if (h<prec*t||t>maxd)break;\n        t += h;\n    }\n    return t;\n}\n\nvec2 trace(const vec3 ro, const vec3 rd ) {\n    float d = rayIntersect(ro, rd, PRECISION_FACTOR, MIN_DIST_RAYMARCHING, MAX_DIST_RAYMARCHING);\n    return (d>0.) ? vec2(d, ce(ro+rd*d)) : vec2(-1., 1.);\n}\n\n\n#ifdef WITH_SHADOWS\n\nfloat shadow(vec3 ro, vec3 rd) {\n    float d = rayIntersect(ro, rd, PRECISION_FACTOR_SHADOW, MIN_DIST_SHADOW, MAX_DIST_SHADOW);\n    return (d>0.) ? smoothstep(0., MAX_DIST_SHADOW, d) : 1.;\n}\n\n#endif\n\n\n#ifdef WITH_AO\n\nfloat calcAO4(const vec3 pos, const vec3 nor ) {\n    float hr, occ = 0., sca = 1.;\n    for(int i=0; i<5; i++ ) {\n        hr = MIN_DIST_AO + MAX_DIST_AO*float(i)/4.;\n        occ += -(de( nor * hr + pos)-hr)*sca;\n        sca *= .95;\n    }\n    return clamp(1. - 10.*occ, 0., 1.);    \n}\n\n#endif\n\n\nvec3 calcNormal(const vec3 pos, const float t ){\n    vec3 e = (PRECISION_FACTOR * t * .57) * vec3(1, -1, 0);\n    return normalize(e.xyy*de(pos + e.xyy) + \n\t\t     e.yyx*de(pos + e.yyx) + \n\t\t     e.yxy*de(pos + e.yxy) + \n             e.xxx*de(pos + e.xxx) );\n}\n\nvec3 RD(const vec3 ro, const vec3 ww, const vec3 vv, const vec3 uu, const vec2 xy, const vec2 r, const float fov) { \n    vec3 er = normalize(vec3((2. * (xy.x/r.x) - 1.)* r.x/r.y,  (2. * (xy.y/r.y) - 1.), fov));\n    return normalize( er.x*uu + er.y*vv + er.z*ww );\n}\n\nvec4 renderScene(const vec3 ro, const vec3 rd) {\n    \n    vec3 col = BACK_COLOR;\n    vec2 res = trace(ro, rd);\n    float t = res.x;\n\n\n    vec3 pos = ro + t*rd,\n        nor = calcNormal( pos, t),\n        ref = reflect( rd, nor),\n        lig = LIGHT_VEC;\n    // Color\n    col = .5 + .5*cos( 6.2831*res.y + vec3(0,1,2) ); \n\n    // lighting        \n    #ifdef WITH_AO\n    float occ = calcAO4(pos, nor);\n    #else\n    float occ = 1.;\n    #endif\n\n    #ifdef WITH_SHADOWS\n    float sh = .2+.8*shadow( pos, lig); //, 0.1, t );\n    #else\n    float sh = 1.;\n    #endif\n\n    #ifdef ONLY_AO\n    col = (vec3)occ*(.5+.5*sh);\n    #else\n\n    float amb = .3;\n    float dif = clamp( dot( nor, lig ), 0., 1.);\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.,-lig.z))), 0., 1. )*clamp( 1.-pos.y,0.,1.);\n    float dom = smoothstep( -.1, .1, ref.y );\n    float fre = clamp(1.+dot(nor,rd),0.,1.);\n    fre *= fre;\n    float spe = pow(clamp( dot( ref, lig ), 0., 1. ),99.);\n\n    vec3 lin = vec3(.3) + \n        + 1.3*sh*dif*vec3(1.,0.8,0.55)\n        + 2.*spe*vec3(1.,0.9,0.7)*dif\n        + .5*occ*( .4*amb*vec3(0.4,0.6,1.) +\n                  .5*sh*vec3(0.4,0.6,1.) +\n                  .25*fre*vec3(1.,1.,1.));\n\n    col *= lin;\n\n    #endif\n    // Shading.\n    float atten = 1./(1. + t*.2 + t*.1); // + distlpsp*distlpsp*0.02\n    col *= atten*col*occ;\n    col = mix(col, BACK_COLOR, smoothstep(0.2, 1., t/MAX_DIST_RAYMARCHING));\n\n\n    return vec4((col),t);\n}\n\n\n// - Interpolation ----------------------------------------------\n\n#define NB 16\n\nfloat[] \n    camx = float[] ( .2351, 1.2351, 1.2351, 1., .2, .41, /*.545,.545,*/ .5,.084,.145,  3.04,.12, .44,.44,.416, -1.404, .21,.2351, .2351),\n\tcamy = float[] (-.094,  .35,     .28,  .38,  .04, .11, /*-.44,-.44,*/.35,.0614,.418, 1.,-.96, .67,.8,.0, -1., -.06,-.094),\n\tcamz = float[] ( .608,  .608,    .35,   .3608, -.03, .48,/*.032,.032,*/ .47,0.201,.05,.28,.3, 1.445,1.,1.4, 2.019, .508,.608),\n\n \tlookx = float[] (-.73, -.627, -1., -.3, -1., -.72, /*-.82,-.82,*/-.67,-.5,-.07,-.67,-.27, -.35,-.35,-.775, .08, -.727),\n\tlooky = float[] (-.364, -.2,   -.2,  -.2,  0., -.39, /*-.5, -.5,*/-.56,-.37,-.96,-.74,-.94, -.35,-.35,-.1, .83,-.364),\n\tlookz = float[] (-.582, -.582, -.5, -.35, -.0, -.58, /*-.2776,-.2776,*/-.48,-.79,-.25,.06,-.18, -.87,-.87,.23, .55, -.582),\n\n\tminsx = float[] (-.3252,-.3252,-.3252,-.3252,-.3252,-.3252,/*-.3252,-1.1,*/ -1.05,-1.05,-1.21,-1.22,-1.04,-0.737,-.62,-10., -.653,  -.653, -.3252),\n\tminsy = float[] (-.7862,-.7862,-.7862,-.7862,-.7862,-.7862,/*-.7862,-.787,*/ -1.05,-1.05,-.954,-1.17,-.79,-0.73,-.71,-.75, -2.,   -2., -.7862),\n\tminsz = float[] (-.0948,-.0948,-.0948,-.0948,-.0948,-.0948,/*-.0948,-.095,*/-0.0001,-0.0001,-.0001,-.032,-.126,-1.23,-.85,-.787, -.822, -1.073, -.0948),\n    minsw = float[] ( .69, .69, .69, .69, .69, .678, /*.678,  .678,*/.7,.73,1.684,1.49,.833, .627,.77,.826,  1.8976, 1.8899, .69),\n\n\tmaxsx = float[] ( .35,.3457,.3457,.3457,.3457, .3457,/*.3457,.3457,*/ 1.05,1.05,.39,.85,.3457,.73,.72,5., .888,  .735, .35),\n\tmaxsy = float[] (1.,1.0218,1.0218,1.0218,1.0218,/*1.0218,1.0218,*/1.0218,1.05,1.05,.65,.65,1.0218,0.73,.74,1.67, .1665, 1.),\n\tmaxsz = float[] (1.22,1.2215,1.2215,1.2215,1.2215,1.2215,/*1.2215,1.2215, */1.27,1.4,1.27,1.27,1.2215,.73,.74,.775, 1.2676, 1.22),\n    maxsw = float[] ( .84, .84, .84, .84, .84, .9834,/*.9834,.9834,*/.95,.93,2.74,1.23,.9834, .8335,.14,1.172, .7798, .84);\n\n// Deph of field animation\nfloat[] deph = float[] ( 1.,.65,.6,.4,.2,.4,/*.055,.055,*/.65,.11,.13,1.3,.49,1.2,1.2,.5,.65,.45,1.,1.);\n\n\n#define BPM 127.\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n    float t = .1 * iTime,\n\t\t kt = smoothstep(0.,1.,fract(t));\n\n    // - Interpolate positions and fractal configuration ---------------------\n    int  i0 = int(t)%NB, i1 = i0+1;\n    \n    vec4 c = vec4(0); \n#ifdef WITH_AA\n    for (int ii=0;ii<2;ii++)\n        for (int jj=0;jj<2;jj++) {\n    vec2 res = iResolution.xy, q = (fragCoord+.5*vec2(ii,jj))/res;\n#else\n    vec2 res = iResolution.xy, q = fragCoord/res;\n#endif            \n\n            \n    \n    vec3 ro = mix(vec3(camx[i0],camy[i0],camz[i0]), vec3(camx[i1],camy[i1],camz[i1]), kt),\n         ww = mix(vec3(lookx[i0],looky[i0],lookz[i0]), vec3(lookx[i1],looky[i1],lookz[i1]), kt), \n         vv = -normalize(cross(ww, vec3(0,1,0))),\n         uu = -normalize(cross(vv,ww)),\n    \t er = vec3((2. * q.x - 1.) * res.x/res.y,  (2. * q.y - 1.), 3.),\n         rd = normalize(er.x*uu + er.y*vv + er.z*ww );\n\n    //---------------------------------------------\n    \n    ro -= uu*.0025,\n         ww = mix(vec3(lookx[i0],looky[i0],lookz[i0]), vec3(lookx[i1],looky[i1],lookz[i1]), kt), \n         vv = -normalize(cross(ww, vec3(0,1,0))),\n         uu = -normalize(cross(vv,ww)),\n    \t er = vec3((2. * q.x - 1.) * res.x/res.y,  (2. * q.y - 1.), 3.),\n         rd = normalize(er.x*(uu+.0001) + er.y*vv + er.z*ww );\n\n    \n    //---------------------------------------------\n    \n    \n    mins = mix(vec4(minsx[i0],minsy[i0],minsz[i0],minsw[i0]), vec4(minsx[i1],minsy[i1],minsz[i1],minsw[i1]), kt),\n    maxs = mix(vec4(maxsx[i0],maxsy[i0],maxsz[i0],maxsw[i0]), vec4(maxsx[i1],maxsy[i1],maxsz[i1],maxsw[i1]), kt);\n\n    // - Music light (BPM by iq) ---------------------------------------------\n//\tfloat h = fract( .25 + .5*iChannelTime[1]*BPM/60. ),\n//\t\t  f = (1.-smoothstep( 0., 1., h )) * smoothstep( 4.5, 4.51, iChannelTime[1]),\n//\t\t  r =  exp(-4.*f);\n    \n    kColor = vec2(.25,1.);\n \n    // - Rendering -----------------------------------------------------------    \n     c += renderScene(ro, rd);\n    \n    \n    // - Adding Text ---------------------------------------------------------\n//\tdrawText(mod(t,ft(NB)), fragCoord, c);\n#ifdef WITH_AA\n}\n            c /= 4.;\n#endif\n    fragColor = c;\n}",
                "description": "",
                "inputs": [],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}