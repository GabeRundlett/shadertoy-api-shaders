{
    "Shader": {
        "info": {
            "date": "1470073761",
            "description": "No raymarching, raytraycing or rasterization was harmed in the making of this Shadertoy",
            "flags": 0,
            "hasliked": 0,
            "id": "MljXzz",
            "likes": 169,
            "name": "Isometric City 2.5D",
            "published": 3,
            "tags": [
                "2d",
                "isometric",
                "city",
                "tiles"
            ],
            "usePreview": 0,
            "username": "knarkowicz",
            "viewed": 8974
        },
        "renderpass": [
            {
                "code": "#define RGB( r, g, b ) vec3( float( r ) / 255.0, float( g ) / 255.0, float( b ) / 255.0 )\nconst vec3 RGB_WATER\t\t= RGB( 52, 166, 202 );\nconst vec3 RGB_BUILDING \t= RGB( 219, 180, 144 );\nconst vec3 RGB_RIGHT_WALL\t= RGB_BUILDING * 1.1;\nconst vec3 RGB_LEFT_WALL\t= RGB_BUILDING * 0.7;\nconst vec3 RGB_WINDOWS \t\t= RGB( 90, 100, 180 );\nconst vec3 RGB_ROAD \t\t= RGB( 110, 125, 120 ) * 0.7;\nconst vec3 RGB_LANE \t\t= RGB( 255, 255, 255 ) * 0.8;\nconst vec3 RGB_GRASS\t\t= RGB( 129, 164, 66 );\nconst vec3 RGB_TREE_LEAVES\t= RGB( 129, 164, 66 ) * 0.6;\nconst vec3 RGB_TREE_TRUNK\t= RGB( 80, 42, 42 );\nconst float TILE_WATER\t\t= 0.0;\nconst float TILE_GRASS\t\t= 1.0;\nconst float TILE_ISLAND\t\t= 2.0;\nconst float TILE_ROAD_X\t\t= 3.0;\nconst float TILE_ROAD_Y\t\t= 4.0;\nconst float TILE_ROAD_XY\t= 5.0;\nconst float ISO_TILE\t\t= 13.0 * 8.0;\nconst float LARGE_FLOAT\t\t= 1e8;\n\nvoid DrawBuilding( inout vec3 color, inout float zbuffer, vec2 tile, vec2 pixel, vec2 buildingTile, float h )\n{\n    float depth = buildingTile.x + buildingTile.y;\n    if ( depth > zbuffer )\n    {\n        return;\n    }    \n    \n    buildingTile.x += h;\n    buildingTile.y += h;    \n    \n    pixel.y -= ISO_TILE * 0.25;\n    vec2 iso = vec2( ( pixel.x + 2.0 * pixel.y ) / ISO_TILE, ( pixel.x - 2.0 * pixel.y ) / -ISO_TILE );\n    tile = floor( iso );\n    vec2 off = iso - tile;\n    \n\t// roof\n    if ( tile.x == buildingTile.x && tile.y == buildingTile.y && off.x > 0.2 && off.y > 0.2 && off.x < 0.98 && off.y < 0.98 )\n    {\n        zbuffer = depth;\n        color = RGB_BUILDING;\n\n        if ( off.x < 0.28 || off.y < 0.28 || off.x > 1.0 - 0.08 || off.y > 1.0 - 0.08 )\n        {\n            color *= 1.2;\n        }\n    }\n    \n    float px = ( buildingTile.x - buildingTile.y ) * ISO_TILE * 0.5;\n    \n    // right wall\n    if ( pixel.x >= px && pixel.x < px + 0.39 * ISO_TILE && iso.y < buildingTile.y + 0.20 && iso.y > buildingTile.y - h - 0.4 )\n    {\n\t\tzbuffer = depth;\n\t\tcolor = RGB_RIGHT_WALL;\n        \n\t\tif ( mod( iso.y + 0.2, 0.5 ) < 0.25 )\n\t\t{\n\t\t\tcolor *= RGB_WINDOWS;\n\t\t\tcolor *= mod( pixel.x, 16.0 ) < 8.0 ? 1.0 : 0.8;\n\t\t}\n    }\n    \n    // left wall\n    if ( pixel.x >= px - 0.39 * ISO_TILE && pixel.x < px && iso.x < buildingTile.x + 0.20 && iso.x > buildingTile.x - h - 0.4 )\n    {\n        zbuffer = depth;        \n\t\tcolor = RGB_LEFT_WALL;        \n        \n\t\tif ( mod( iso.x + 0.2, 0.5 ) < 0.25 )\n\t\t{\n\t\t\tcolor *= RGB_WINDOWS;\n\t\t\tcolor *= mod( pixel.x, 16.0 ) < 8.0 ? 1.0 : 0.8;\n\t\t}\n    }\n}\n\nvoid DrawTree( inout vec3 color, inout float zbuffer, vec2 tile, vec2 pixel, vec2 treeTile )\n{        \n    float depth = treeTile.x + treeTile.y;\n    if ( depth > zbuffer )\n    {\n        return;\n    }\n    \n    pixel.y -= ISO_TILE * 0.25;\n    vec2 iso = vec2( ( pixel.x + 2.0 * pixel.y ) / ISO_TILE, ( pixel.x - 2.0 * pixel.y ) / -ISO_TILE );\n    tile = floor( iso );\n    vec2 off = iso - tile;\n    \n    float px = ( treeTile.x - treeTile.y ) * ISO_TILE * 0.5;\n    \n    // top leaves\n    if ( iso.x > treeTile.x + 0.2 && iso.y > treeTile.y + 0.2 && iso.x < treeTile.x + 0.45 && iso.y < treeTile.y + 0.45 )\n    {\n\t\tzbuffer = depth;\n\t\tcolor = RGB_TREE_LEAVES * 1.0;\n    }\n    \n\t// left leaves\n    if ( pixel.x >= px - 0.125 * ISO_TILE && pixel.x < px && iso.x > treeTile.x - 0.1 && iso.x < treeTile.x + 0.2 && iso.x > treeTile.x - 0.1 )\n    {\n\t\tzbuffer = depth;\n\t\tcolor = RGB_TREE_LEAVES * 0.8;\n    }\n    \n\t// right leaves\n    if ( pixel.x >= px && pixel.x < px + 0.125 * ISO_TILE && iso.y < treeTile.y + 0.2 && iso.y > treeTile.y - 0.1 )\n    {\n\t\tzbuffer = depth;\n\t\tcolor = RGB_TREE_LEAVES * 1.2;\n    }    \n    \n    // left trunk\n    if ( pixel.x >= px - 0.039 * ISO_TILE && pixel.x < px && iso.x <= treeTile.x - 0.1 && iso.x > treeTile.x - 0.4 )\n    {\n        zbuffer = depth;        \n\t\tcolor = RGB_TREE_TRUNK * 0.8;\n    }    \n    \n    // right trunk\n    if ( pixel.x >= px && pixel.x < px + 0.039 * ISO_TILE && iso.y <= treeTile.y - 0.1 && iso.y > treeTile.y - 0.4 )\n    {\n\t\tzbuffer = depth;\n\t\tcolor = RGB_TREE_TRUNK * 1.1;\n    }\n}\n\nfloat TileID( vec2 tile )\n{\n    float id = TILE_WATER;\n    vec4 tex = texture( iChannel0, tile / ( iChannelResolution[ 0 ].xy * 4.0 ) );\n    id = tex.y > 0.5 ? TILE_WATER \t: TILE_GRASS;\n    id = tex.y > 0.9 ? TILE_ISLAND \t: id;\n    \n    if ( id == TILE_GRASS && mod( tile.x + 1.0, 4.0 ) == 0.0 )\n    {\n        id = TILE_ROAD_X;\n    }\n    \n    if ( mod( tile.y + 1.0, 4.0 ) == 0.0 )\n    {\n        if ( id == TILE_GRASS ) \n        {\n        \tid = TILE_ROAD_Y;\n    \t}\n        \n        if ( id == TILE_ROAD_X ) \n        {\n        \tid = TILE_ROAD_XY;\n    \t}        \n    }\n    \n    return id;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resMult      \t= floor( max( iResolution.x, iResolution.y ) / 800.0 );\n    float resRcp        = 1.0 / max( resMult, 1.0 );\n    //float cameraOffset\t= floor( iTime * 60.0 + 0.5 );\n    float cameraOffset\t= float( iFrame );\n    vec2 pixel \t\t\t= fragCoord * resRcp + cameraOffset - iMouse.xy + vec2( -2000, -2000.0 );\n    \n    vec2 iso\t\t= vec2( ( pixel.x + 2.0 * pixel.y ) / ISO_TILE, ( pixel.x - 2.0 * pixel.y ) / -ISO_TILE );\n    vec2 waterIso\t= vec2( ( pixel.x + 2.0 * pixel.y + 0.15625 * ISO_TILE ) / ISO_TILE, ( pixel.x - 2.0 * pixel.y - 0.15625 * ISO_TILE ) / -ISO_TILE );\n    vec2 isoR\t\t= vec2( ( pixel.x + 2.0 * pixel.y - ISO_TILE * 0.5 ) / ISO_TILE, ( pixel.x - 2.0 * pixel.y + ISO_TILE * 0.5 ) / -ISO_TILE );\n    vec2 tile\t\t= floor( iso );\n    vec2 tileR\t\t= floor( isoR );\n    vec2 waterTile\t= floor( waterIso );\n    vec2 off\t\t= iso - tile;\n    vec2 offR \t\t= isoR - tileR;\n    vec2 waterOff  \t= waterIso - waterTile;\n    \n    vec2 buildingTile0 \t= 2.0 * floor( tile / 2.0 );\n    vec2 buildingTile1 \t= 3.0 * floor( tile / 3.0 );\n    vec2 buildingTile2 \t= 4.0 * floor( tile / 4.0 );\n    vec2 buildingTile3 \t= 5.0 * floor( tile / 5.0 );\n\n    float tileId\t= TileID( tile );\n    float tileLId\t= TileID( vec2( tile.x - 1.0, tile.y ) );\n    float tileRId\t= TileID( vec2( tile.x + 1.0, tile.y ) );\n    float tileTId\t= TileID( vec2( tile.x, tile.y - 1.0 ) );\n    float tileBId\t= TileID( vec2( tile.x, tile.y + 1.0 ) );\n    float tileB0Id\t= TileID( buildingTile0 );\n    float tileB1Id\t= TileID( buildingTile1 );\n    float tileB2Id\t= TileID( buildingTile2 );\n    float tileB3Id\t= TileID( buildingTile3 );\n  \n    // water\n    vec3 waterTexNoise = texture( iChannel0, waterTile /  iChannelResolution[ 0 ].xy + fract( iTime * 0.005 ) ).xyz;    \n    vec3 color = RGB_WATER * mix( 0.8, 1.1, waterTexNoise.z );\n\n    float waterTileId\t= TileID( waterTile );\n    float waterTileLId\t= TileID( vec2( waterTile.x - 1.0, waterTile.y ) );\n    float waterTileRId\t= TileID( vec2( waterTile.x + 1.0, waterTile.y ) );\n    float waterTileTId\t= TileID( vec2( waterTile.x, waterTile.y - 1.0 ) );\n    float waterTileBId\t= TileID( vec2( waterTile.x, waterTile.y + 1.0 ) );\n    float waterTileLTId\t= TileID( vec2( waterTile.x - 1.0, waterTile.y - 1.0 ) );\n    float waterTileLBId\t= TileID( vec2( waterTile.x - 1.0, waterTile.y + 1.0 ) );\n    float waterTileRTId\t= TileID( vec2( waterTile.x + 1.0, waterTile.y - 1.0 ) );\n    float waterTileRBId\t= TileID( vec2( waterTile.x + 1.0, waterTile.y + 1.0 ) );    \n    \n    // water shore shadow\n    if ( waterTileId == TILE_WATER )\n    {\n        if ( ( waterTileLId != TILE_WATER && waterOff.x < 8.0 / 32.0 ) \n            || ( waterTileRId != TILE_WATER && waterOff.x > 24.0 / 32.0 )\n            || ( waterTileTId != TILE_WATER && waterOff.y < 8.0 / 32.0 )\n            || ( waterTileBId != TILE_WATER && waterOff.y > 24.0 / 32.0 )\n            || ( waterTileLTId != TILE_WATER && waterOff.x < 8.0 / 32.0 && waterOff.y < 8.0 / 32.0 )\n            || ( waterTileLBId != TILE_WATER && waterOff.x < 8.0 / 32.0 && waterOff.y > 24.0 / 32.0 )\n            || ( waterTileRTId != TILE_WATER && waterOff.x > 24.0 / 32.0 && waterOff.y < 8.0 / 32.0 )\n            || ( waterTileRBId != TILE_WATER && waterOff.x > 24.0 / 32.0 && waterOff.y > 24.0 / 32.0 )            \n           )\n        {\n            color *= vec3( 0.8 );\n        }\n    }\n    \n    // shores\n    float waterPX = ( waterTile.x - waterTile.y ) * ISO_TILE * 0.5;\n    if ( ( waterTileId != TILE_WATER && pixel.x <= waterPX && waterTileLId == TILE_WATER ) \n        || ( waterTileTId != TILE_WATER && pixel.x > waterPX && waterOff.x < 5.0 / 32.0 ) )\n    {\n\t\tcolor = RGB_GRASS * 0.7;\n\t}\n    if ( ( waterTileId != TILE_WATER && pixel.x > waterPX && waterTileTId == TILE_WATER ) \n        || ( waterTileLId != TILE_WATER && pixel.x <= waterPX && waterOff.x < 5.0 / 32.0 ) )\n    {\n\t\tcolor = RGB_GRASS * 0.9;\n\t}    \n        \n    // grass and road\n    if ( tileId != TILE_WATER )\n    {\n    \tcolor = RGB_GRASS;\n    }\n    \n    float roadWidth = 0.3;\n\tfloat laneWidth = 0.03;\n    if ( ( ( tileId == TILE_ROAD_X || tileId == TILE_ROAD_XY ) && abs( 0.5 - off.x ) < roadWidth ) \n        && ( tileTId != TILE_WATER || tileBId != TILE_WATER ) \n        && ( tileTId != TILE_WATER || off.y >= 0.20 )\n       \t&& ( tileBId != TILE_WATER || off.y <= 0.80 )\n       )\n    {\n\t\tcolor = RGB_ROAD;\n\t\tif ( abs( 0.5 - off.x ) < laneWidth && mod( off.y, 0.5 ) < 0.2 && tileId != TILE_ROAD_XY )\n\t\t{\n\t\t\tcolor = RGB_LANE;\n\t\t}\n    }\n\tif ( ( tileId == TILE_ROAD_Y || tileId == TILE_ROAD_XY ) && abs( 0.5 - off.y ) < roadWidth \n        && ( tileLId != TILE_WATER || tileRId != TILE_WATER )\n        && ( tileLId != TILE_WATER || off.x >= 0.20 ) \n        && ( tileRId != TILE_WATER || off.x <= 0.80 ) )\n    {\n\t\tcolor = RGB_ROAD;\n        if ( abs( 0.5 - off.y ) < laneWidth && mod( off.x, 0.5 ) < 0.2 && tileId != TILE_ROAD_XY )\n        {\n        \tcolor = RGB_LANE;\n\t\t}\n    }\n    \n    if ( tileId == TILE_GRASS && (\n\t\t\t( buildingTile0.x == tile.x && buildingTile0.y == tile.y ) \n        || \t( buildingTile1.x == tile.x && buildingTile1.y == tile.y ) \n        || \t( buildingTile2.x == tile.x && buildingTile2.y == tile.y ) \n        || \t( buildingTile3.x == tile.x && buildingTile3.y == tile.y ) ) )\n    {\n        // building AO\n        vec2 offAO = 7.0 * clamp( ( abs( 0.5 - off ) - 0.35 ), 0.0, 1.0 );\n        color *= clamp( max( offAO.x, offAO.y ), 0.0, 1.0 );\n    }\n    else if ( tileId == TILE_GRASS || tileId == TILE_ISLAND )\n    {\n        // tree AO\n\t\tcolor *= clamp( max( 8.0 * abs( 0.15 - off.x ), 8.0 * abs( 0.15 - off.y ) ), 0.0, 1.0 );        \n    }\n\n    float zbuffer = LARGE_FLOAT;\n    if ( tileB0Id == TILE_GRASS )\n    {\n    \tDrawBuilding( color, zbuffer, tile, pixel, buildingTile0, 0.0 );\n    }\n\n    if ( tileB1Id == TILE_GRASS )\n    {\n    \tDrawBuilding( color, zbuffer, tile, pixel, buildingTile1, 1.0 );\n    }\n    \n    if ( tileB2Id == TILE_GRASS )    \n    {           \n    \tDrawBuilding( color, zbuffer, tile, pixel, buildingTile2, 2.0 );\n    }\n    \n    if ( tileB3Id == TILE_GRASS )\n    {\n    \tDrawBuilding( color, zbuffer, tile, pixel, buildingTile3, 3.0 );\n    }\n    \n    if ( ( tileId == TILE_GRASS || tileId == TILE_ISLAND ) && zbuffer >= LARGE_FLOAT )\n    {    \n        DrawTree( color, zbuffer, tile, pixel, tile );\n    }\n    \n    fragColor = vec4( sqrt( color ), 1.0 );  \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}