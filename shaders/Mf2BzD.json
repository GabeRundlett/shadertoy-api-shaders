{
    "Shader": {
        "info": {
            "date": "1724755229",
            "description": "Simple test of piecewise C1 quadratic interpolation of random points",
            "flags": 0,
            "hasliked": 0,
            "id": "Mf2BzD",
            "likes": 4,
            "name": "Random quadratic spline",
            "published": 3,
            "tags": [
                "spline",
                "quadratic",
                "periodic"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 58
        },
        "renderpass": [
            {
                "code": "/*\nSee https://www.shadertoy.com/view/Dd33zs for C2 cubic spline variant\nSee https://www.shadertoy.com/view/dd3Gzl for cubic cardinal spline variant\nSee https://www.shadertoy.com/view/cstGRs for akima spline variant\n*/\n\nconst vec3 dot_col = vec3(0);\nconst vec3 curve_col = vec3(0,1,0);\nconst vec3 bg_col = vec3(1);\n\nconst float dot_size = .01;\nconst float line_width = .003;\n\nconst float zoom = 2.;\n\nconst int num_splines = 20;\n\nfloat hash1(float v)\n{\n\tuint n = 1103515245u;\n\tuvec2 x = floatBitsToUint(vec2(v));\n\treturn float(n * (((x = n * ((x >> 1) ^ x.yx)).y >> 3) ^ x.x)) / float(-1u);\n}\n\n// compute parameters of quadratic polynomial with end points a b and slope ma in a\nvec3 compute_params(vec2 a, vec2 b, float ma){\n\tmat3 matrix = mat3(a.x * a.x, b.x * b.x, 2. * a.x,\n\t                   a.x, b.x, 1.,\n\t                   1., 1., 0.);\n\n\treturn inverse(matrix) * vec3(a.y, b.y, ma);\n}\n\n// compute slope at end of quadratic piece\nfloat slope_at_end(vec3 params, float end){\n\tfloat diff = end * 2. * params.x + params.y;\n\treturn diff;\n}\n\n// approximate distance to quadratic curve between a and b\nfloat quad_distance_approx(vec2 uv, float a, float b, vec3 params){\n\tfloat val = uv.x * (uv.x * params.x + params.y) + params.z;\n\tfloat diff = uv.x * 2. * params.x + params.y;\n\n\tif(uv.x > a && uv.x < b){\n\t\treturn abs(uv.y-val) / length(vec2(diff,1));\n\t}\n\telse{\n\t\treturn 1e38;\n\t}\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border = 2. / iResolution.x;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= .5;\n    uv.y *= iResolution.y / iResolution.x;\n\n\tborder *= zoom;\n\tuv *= zoom;\n\n\tvec3 color = bg_col;\n\n\tfloat curve_dis = 1e38;\n\tfloat point_dis = 1e38;\n\n\tfloat initial_slope = 0.;\n    float last_slope = initial_slope;\n    \n    vec2 point = vec2(-1,0);\n    vec2 next_point;\n\n    // render splines and dots\n\tfor(int i=0;i<num_splines;i++){\n        next_point = vec2(point.x+.01+.18*hash1(float(33*i)),.07*hash1(float(i)));\n    \n\t\tpoint_dis = min(point_dis, distance(uv,point)-dot_size);\n\n\t\tvec3 params = compute_params(point, next_point, last_slope);\n\t\tcurve_dis = min(curve_dis, quad_distance_approx(uv, point.x, next_point.x, params)-line_width);\n\n\t\tlast_slope = slope_at_end(params, next_point.x);\n        point = next_point;\n\t}\n    point_dis = min(point_dis, distance(uv,next_point)-dot_size);\n\n\tcolor = mix(curve_col, color, smoothstep(-border/2.,border/2.,curve_dis));\n\tcolor = mix(dot_col, color, smoothstep(-border/2.,border/2.,point_dis));\n\n\tfragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}