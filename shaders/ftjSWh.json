{
    "Shader": {
        "info": {
            "date": "1627568742",
            "description": "Oh no!! Dusty is gone...\n...in memoriam Dusty Hill :-(\n\n(...the visual shader is an old one - but added some sound shader - an old zztop classic)\n",
            "flags": 40,
            "hasliked": 0,
            "id": "ftjSWh",
            "likes": 30,
            "name": "RIP Dusty Hill :-(",
            "published": 3,
            "tags": [
                "sound",
                "sad",
                "rip",
                "zztop",
                "dustyhill"
            ],
            "usePreview": 1,
            "username": "flockaroo",
            "viewed": 691
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// in memoriam Dusty Hill :-(\n//\n// zztop intro of \"gimme all your lovin\"\n//\n\n#define Res (iResolution.xy)\n\n#define notes_ 12.\n#define speaker_ 31.\n#define alpha_ 128.\n#define beta_ 129.\n#define gamma_ 130.\n#define psi_ 142.\n#define bo_ 40.\n#define bc_ 41.\n#define ebo_ 91.\n#define ebc_ 93.\n#define cbo_ 123.\n#define cbc_ 125.\n#define or_ 124.\n#define squared_ 178.\n#define space_ 32.\n#define div_ 47.\n#define A_ 65.\n#define B_ 66.\n#define C_ 67.\n#define D_ 68.\n#define E_ 69.\n#define F_ 70.\n#define G_ 71.\n#define H_ 72.\n#define I_ 73.\n#define J_ 74.\n#define K_ 75.\n#define L_ 76.\n#define M_ 77.\n#define N_ 78.\n#define O_ 79.\n#define P_ 80.\n#define Q_ 81.\n#define R_ 82.\n#define S_ 83.\n#define T_ 84.\n#define U_ 85.\n#define V_ 86.\n#define W_ 87.\n#define X_ 88.\n#define Y_ 89.\n#define Z_ 90.\n#define a_ (A_+32.)\n#define b_ (B_+32.)\n#define c_ (C_+32.)\n#define d_ (D_+32.)\n#define e_ (E_+32.)\n#define f_ (F_+32.)\n#define g_ (G_+32.)\n#define h_ (H_+32.)\n#define i_ (I_+32.)\n#define j_ (J_+32.)\n#define k_ (K_+32.)\n#define l_ (L_+32.)\n#define m_ (M_+32.)\n#define n_ (N_+32.)\n#define o_ (O_+32.)\n#define p_ (P_+32.)\n#define q_ (Q_+32.)\n#define r_ (R_+32.)\n#define s_ (S_+32.)\n#define t_ (T_+32.)\n#define u_ (U_+32.)\n#define v_ (V_+32.)\n#define w_ (W_+32.)\n#define x_ (X_+32.)\n#define y_ (Y_+32.)\n#define z_ (Z_+32.)\n\nfloat doffs=0.02;\n\nvoid writeChar(float x, float y, float s, vec3 color, float c, inout vec4 col, vec2 coord)\n{\n    vec2 res2=iChannelResolution[2].xy;\n    //float dist=texture(iChannel2,vec2(c/16.,mod(c,16.)/16.)).x;\n    //col=mix(vec4(1,1,0,1),col,clamp(dist*dist*dist,0.,1.));\n    float d=1000.;\n    if( coord.x>x && coord.y>y && coord.x<x+s && coord.y<y+s )\n    {\n        vec2 dc = coord-vec2(x,y);\n        dc.y=s-dc.y;\n        vec2 uv=\n            vec2(floor(mod(c,16.))/16.,floor(c/16.)/16.)\n            +dc/s/16.;\n        uv.y=1.-uv.y/*+1./16.*/;\n        d=min(d,texture(iChannel1,uv).w-.5);\n        //col=mix(col,1.*vec4(color,1),step(.1,texture(iChannel1,uv).w-.5));\n        //col+=vec4(0,1,0,1);\n    }\n    col=mix(col,1.*vec4(color,1),smoothstep(-0.01,0.01,-d+doffs));\n}\n\nvoid write(float x, float y, float s, vec3 color, mat4 txt,inout vec4 col, vec2 coord)\n{\n    for(int i=0;i<4;i++)\n    {\n    \tfor(int j=0;j<4;j++)\n    \t{\n            float c=txt[i][j];\n            if(c==0.) return;\n    \t\twriteChar(x,y,s,color,c,col,coord); x+=s*.5;\n        }\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = zztop((fragCoord-Res.xy*vec2(.5,.2))/Res.x*10., 1.);\n    \n    float sc=Res.x/600.;\n    write((8.+8.)*sc, (150.-5.)*sc, 64.*sc, vec3(.45,.0,.0), mat4(R_,I_,P_,space_, D_,u_,s_,t_, y_,space_,H_,i_, l_,l_,0,0 ),fragColor, fragCoord+vec2(-fragCoord.y*.3,0));\n    write(8.*sc, 150.*sc, 64.*sc, vec3(1,.8,0), mat4(R_,I_,P_,space_, D_,u_,s_,t_, y_,space_,H_,i_, l_,l_,0,0 ),fragColor, fragCoord+vec2(-fragCoord.y*.3,0));\n    \n    vec4 c=vec4(0);\n    //doffs=.035;\n    //write(20.*sc, 20.*sc, 50.*sc, vec3(1), mat4(notes_,space_,speaker_,0, 0,0,0,0, 0,0,0,0, 0,0,0,0 ),c,fragCoord);\n    doffs=.0;\n    write(Res.x-60.*sc, Res.y-60.*sc, 50.*sc, vec3(1), mat4(notes_,0.*space_,0.*speaker_,0, 0,0,0,0, 0,0,0,0, 0,0,0,0 ),c,fragCoord);\n\n    vec4 col2=texture(iChannel2,fragCoord/Res);\n    fragColor=mix(fragColor,col2*.9*vec4(.95,1,1.05,1),1.-clamp(fragColor.x*3.,0.,1.));\n    \n    fragColor += -.15*texelFetch(iChannel0,(ivec2(fragCoord)+iFrame/5*50)%256,0);\n    \n    fragColor+=.25*c;\n    \n    vec2 sco=fragCoord/Res-.5;\n    fragColor*=1.-dot(sco,sco);\n    \n\tfragColor.w=1.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// in memoriam Dusty Hill :-(\n//\n// zztop intro of \"gimme all your lovin\"\n//\n\n#define T 2.7\n#define HT 1.059463094\n#define A4 (440.)\n#define B4 (440.*HT*HT)\n#define C4 (440.*HT*HT*HT)\n#define D4 (440.*HT*HT*HT*HT*HT)\n#define E4 (440.*HT*HT*HT*HT*HT*HT*HT)\n#define F4 (440.*HT*HT*HT*HT*HT*HT*HT*HT)\n#define G4 (440.*HT*HT*HT*HT*HT*HT*HT*HT*HT*HT)\n\n#define A0 (A4/16.)\n#define B0 (B4/16.)\n#define C0 (C4/16.)\n#define D0 (D4/16.)\n#define E0 (E4/16.)\n#define F0 (F4/16.)\n#define G0 (G4/16.)\n\n#define A1 (A4/8.)\n#define B1 (B4/8.)\n#define C1 (C4/8.)\n#define D1 (D4/8.)\n#define E1 (E4/8.)\n#define F1 (F4/8.)\n#define G1 (G4/8.)\n\n#define A2 (A4/4.)\n#define B2 (B4/4.)\n#define C2 (C4/4.)\n#define D2 (D4/4.)\n#define E2 (E4/4.)\n#define F2 (F4/4.)\n#define G2 (G4/4.)\n\n#define A3 (A4/2.)\n#define B3 (B4/2.)\n#define C3 (C4/2.)\n#define D3 (D4/2.)\n#define E3 (E4/2.)\n#define F3 (F4/2.)\n#define G3 (G4/2.)\n\n#define A5 (A4*2.)\n#define B5 (B4*2.)\n#define C5 (C4*2.)\n#define D5 (D4*2.)\n#define E5 (E4*2.)\n#define F5 (F4*2.)\n#define G5 (G4*2.)\n\nfloat rand2(float x){\n    //return 2.0*(texelFetch(iChannel0,i);\n    return fract(sin(mod(x*10.0,10.0)*12.9898)*43758.5453)*2.0-1.0;\n}\n\nfloat rand3(float x){\n    float y=0., sum=0.;\n    for(int i=0;i<30;i++) {  y+=cos((float(i))*x+float(i)*.1); sum+=1.; } \n    return y/sum;\n}\n\nfloat rand(float x){\n    x=fract(x);\n    int i=int(x*iSampleRate);\n    return texelFetch(iChannel0,ivec2(i%256,(i/256)%256),0).x-.5;\n}\n\nfloat AttackDecay(float t, float tau)\n{\n    return exp(-t/tau);\n}\n\nvec2 boing(float f, float t, float ph)\n{\n    if(t<0.0) return vec2(0.);\n\tfloat a = 50.0*( 1.0*sin(6.2831*(1.0  *f*t+ph))\n\t                +0.6*sin(6.2831*(1.975*f*t+ph))\n                    +0.3*sin(6.2831*(4.0  *f*t+ph))\n                   );\n\n    return vec2(\n        clamp(a*(exp(-8.0*t)+0.1*exp(-t*3.0)),-1.,1.)\n    );\n}\n\nvec2 brumm(float f, float t, float ph)\n{\n    if(t<0.0) return vec2(0.);\n\tfloat a = 50.0*( 0.6*sin(6.2831*(1.0  *f*t+ph))\n\t                +0.8*sin(6.2831*(1.975*f*t+ph))\n                    +0.4*sin(6.2831*(4.0  *f*t+ph))\n                   );\n\n    return vec2(\n        clamp(a*exp(-1.0*t),-1.,1.)\n    );\n}\n\nfloat fermi(float x)\n{\n    return 1./(1.+exp(x));\n}\n\nvec2 bbbbb(float f1, float f2, float t)\n{\n    // X       X       X       X\n    // a _ a a c a\n    return \n    \t  boing(f1,t-T*0./16.,.0)*fermi((t-T*2./16.)/0.01)\n        + boing(f1,t-T*2./16.,.0)*fermi((t-T*3./16.)/0.01)\n        + boing(f1,t-T*3./16.,.0)*fermi((t-T*4./16.)/0.01)\n        + boing(f2,t-T*4./16.,.4)*fermi((t-T*5./16.)/0.01)\n        + boing(f1,t-T*5./16.,.0);\n}\n\nvec2 tich(float f,float t)\n{\n    float c=0.;\n    float a=0.;\n    for( int i=-512; i<512; i++ )\n    { \n        float t2=float(i)/44000.0;\n        float w=float(128)/44000.0;\n        w=1.0/f;\n        float s=exp(-t2*t2/w/w)*t2/w;\n        //a+=rand(t-t2)*cos(-6.2831*f*(t-t2))*s; c+=s; \n        a+=rand(t-t2)*s; c+=s*s;\n    }\n    a/=sqrt(c);\n    //a=rand(t);\n    a*=(0.5+0.5*sin(2300.*t))*(0.8+0.2*sin(800.*t))*exp(-25.0*mod(t,T/16.));\n    return 1.0*vec2(clamp(a,-1.0,1.0));\n}\n\nvec2 bumm(float f,float t)\n{\n    if(t<0.0) return vec2(0.);\n    return 2.0*vec2(sin(6.2831*f*t)*exp(-18.0*t));\n}\n\nfloat feep(float f1, float f2,float t)\n{\n \tfloat a=clamp(sin(f1*t+1.5*sin(35.0*t)+8.0*sin(6.0*t))*2.0+0.15*rand(t),-1.0,1.0);\n \treturn clamp(a*exp(0.5*t-4.0)*(fermi((t-T*3.5)/T/0.15)),-1.0,1.0);\n}\n\n// iq's polynomial smooth min function\n/*float smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}*/\n\nfloat feep2Map(float t)\n{\n    return smin(t,0.689*(t-T*(3.5+0.05))+T*(3.5-0.05),0.3);\n}\n\nfloat chordMaj(float f, float oct, float t) // FIXME: not really a major chord yet\n{\n    f*=6.2831*pow(2.0,oct);\n    float a=(sin(f*t)+sin(3./2.*f*t)+sin(5./4.*f*t))+0.15*rand(t);\n \ta=clamp(sin(f*t+1.5*sin(35.0*t)+8.0*sin(6.0*t))*2.0+0.15*rand(t),-1.0,1.0);\n    //a=clamp(a*0.3,-1.0,1.0);\n    return a*exp(-t/3.0);\n}\n\n#define Git(fret,string) 110.*exp2((-5.+float(fret)+5.*float(string)-float(string/4))/12.)\n#define GitCont -1.\n#define Ch2(f1,s1,f2,s2) Git(f1,s1),Git(f2,s2)\n#define Ch2Cont -1.,-1.\n#define Ch3(f1,s1,f2,s2,f3,s3) Git(f1,s1),Git(f2,s2),Git(f3,s3)\n#define Ch3Cont -1.,-1.,-1.\n\n#define CHNUM 3\n\n#if CHNUM == 2\nconst float rythm[] = float[32](\nCh2Cont,\nCh2Cont,\nCh2Cont,\nCh2Cont,\nCh2Cont,\nCh2( 3,2, 5,3 ),\nCh2( 3,2, 5,3 ),\nCh2Cont,\nCh2( 3,2, 3,3 ),\nCh2Cont,\nCh2Cont,\nCh2( 3,1, 3,2 ),\nCh2Cont,\nCh2( 3,1, 5,2 ),\nCh2( 3,1, 5,2 ),\nCh2Cont\n);\n\n#else   \n\nconst float rythm[] = float[48](\nCh3( 3,1, 5,2, 5,3 ),\nCh3Cont,\nCh3Cont,\nCh3Cont,\nCh3Cont,\nCh3( 3,1, 3,2, 5,3 ),\nCh3( 3,1, 3,2, 5,3 ),\nCh3( 3,1, 3,2, 3,3 ),\nCh3( 3,1, 3,2, 3,3 ),\nCh3Cont,\nCh3( 3,1, 3,2, 5,3 ),\nCh3( 3,1, 3,2, 5,3 ),\nCh3Cont,\nCh3( 3,1, 5,2, 5,3 ),\nCh3( 3,1, 5,2, 5,3 ),\nCh3Cont\n);\n#endif   \n\nconst float solo[] = float[24](\nGit( 8,5),\nGit(11,4),\nGit( 8,4),\nGit(10,3),\nGit( 8,4),\nGit( 8,5),\nGit( 8,5),\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont\n);\n\nfloat chordMin(float f, float oct, float t) // FIXME: not really a minor chord yet\n{\n    f*=6.2831*pow(2.0,oct);\n    float a=(sin(f*t)+sin(3./2.*f*t)+sin(5./4.*f*t))+0.15*rand(t);\n \ta=clamp(sin(f*t+1.5*sin(35.0*t)+8.0*sin(6.0*t))*2.0+0.15*rand(t),-1.0,1.0);\n    //a=clamp(a*0.3,-1.0,1.0);\n    return a*exp(-t/3.0);\n}\n\nfloat string(float freq, float t)\n{\n    float sum=0., s=0.;\n    freq*=1.57*4.;\n    for(float fm=1.;fm<10.;fm+=1.)\n    {\n        //float fact=sqrt(1./fm);\n        float fact=exp(-float(fm)/15.);\n    \ts+=sin(freq*fm*t)*fact;\n        sum+=fact;\n    }\n    return s/sum;\n}\n\nfloat overdrive(float a, float ovr)\n{\n    // transistor\n    //return clamp(a*ovr,-1.,1.);\n    // tube-ish\n    return sign(a)*(1.-exp(-abs(a)*ovr));\n}\n\nvec2 mainSound( int samp, float t )\n{\n    float t0=t;\n    float f1=0.01;\n    float s=0.;\n    float tact=2.;\n    t-=.5*tact;\n    float bumm1=(rand(f1*1.*t)+.5*rand(f1*10.*t)+.3*rand(f1*100.*t));\n    float bumm2=(rand(f1*2.*t)+.5*rand(f1*20.*t)+.3*rand(f1*100.*t));\n    s+=.5*bumm1*AttackDecay(mod(t+ tact* 0.,tact/2.),.05);\n    s+=1.*bumm2*AttackDecay(mod(t+ tact/ 4.,tact/2.),.05);\n    s+=1.*bumm2*AttackDecay(mod(t+ tact/ 8.,tact*2.),.05);\n    s+=1.*bumm2*AttackDecay(mod(t+ tact/16.,tact*2.),.05);\n    s+=.25*rand(f1*100.*t)*AttackDecay(mod(t+ tact* 0.,tact/8.),.08);\n    int n[16] = int[](-100, 6, 7, 0, -100, 9, 9, 9, 10, -100, 10, 9, -100, 7, 7, -100);\t\n    t=t0;\n    \n    float s1=0.;\n    int actTact4=int(t/tact*8.);\n    int actTact3=int(t/tact*8.*3./2.);\n\n    for(int i=0;i<2;i++)\n    {\n    int note=n[(actTact4-i)%16];\n    float nStart=(float(actTact4-i)*tact/8.);\n    float amp=1.;\n    if(note==-100) { note=n[actTact4-i-1]; nStart-=tact/8.; }\n    if(note==-100) { note=n[actTact4-i-2]; nStart-=tact/8.; }\n    //s=0.;\n    float key=110.*exp2(3./12.);\n    if(t>tact*4.)\n    s1 += amp*string(key*exp2(float(note)/12.),t)*exp(-(t-nStart)/.3);\n    }\n    //s1= 1.-exp(-s1*3.);\n\n    float ryth=0.;\n    for(int j=0;j<CHNUM;j++)\n    for(int i=0;i<1;i++)\n    {\n        int idx=(actTact4-i)%16;\n    float f=rythm[idx*CHNUM+j];\n    float nStart=(float(actTact4-i)*tact/8.);\n    float amp=1.;\n    for(int k=0;k<20;k++) { if(f==-1.) { idx=(idx-1)%16; f=rythm[idx*CHNUM+j]; nStart-=tact/8.; } }\n    //if(f==-1.) { idx=(idx-1)%16; f=rythm[idx*2+j]; nStart-=tact/4.; }\n    //if(f==-1.) { idx=(idx-1)%16; f=rythm[idx*2+j]; nStart-=tact/4.; }\n    if(t>tact*4.+1.)\n    ryth += amp*clamp(string(f,t),-.25,.25)*exp(-(t-nStart)/.3);\n    }\n    ryth = overdrive(1.*ryth+2.*s1,50.);\n\n    float sol=0.;\n    {\n    int i=0;\n    int idx=(actTact3-i)%24;\n    float f=solo[idx];\n    float nStart=(float(actTact3-i)*tact/8.*2./3.);\n    float amp=1.;\n    for(int j=0;j<20;j++) { if(f==-1.) { idx=(idx-1)%24; f=solo[idx]; nStart-=tact/8.*2./3.; } }\n    if(t>tact*4.+1.)\n    sol += amp*string(f,t+.001*(sin(t*12.)+.5))*exp(-(t-nStart)/1.);\n    }\n    sol = overdrive(sol,10.);\n\n    \n    //s = sin(key*1.57*4.*t);\n    //s=rand(t);\n    return vec2(s*1.+ryth*.25+sol*.25);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// zztop ford eliminator\n\n// helper functions\n\n//uncomment to precalc logo as texture\n//#define ZZT_AS_TEX\n\n#define PI2 6.283185\n\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n\nvec3 getLightDir() { return normalize(1.*vec3(cos(1.+/*iTime+*/vec2(0,1.6)),.81)); }\n\nvec2 scuv(vec2 uv) {\n    float zoom=1.;\n    return (uv-.5)*1.2*zoom+.5; \n}\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    // no interpolation\n    //return uv;\n    // sinus interpolation\n    return uv+1.*sin(uv*res*PI2)/(res*PI2);\n    // iq's polynomial interpolation\n    vec2 f = fract(uv*res);\n    return (uv*res+.5-f+3.*f*f-2.0*f*f*f)/res;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return (v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v ));\n}\n\nvec4 angVec2Quat(vec3 ang)\n{\n    float lang=length(ang);\n    return vec4(ang/lang,1) * sin(vec2(lang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\n/////////////// iq's distance funs\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdRoundRect( vec2 p, vec2 b, float r )\n{\n  vec2 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\nvec2 sdRoundRect2( vec4 p, vec4 b, vec2 r )  // variation - eval 2 boxes at once\n{\n  vec4 q = abs(p) - (b-r.xxyy);\n  vec4 qp=max(q,0.0);\n  return sqrt(qp.xz*qp.xz+qp.yw*qp.yw) + min(max(q.xz,q.yw),vec2(0)) - r;\n}\n\nfloat sdHalfRoundBox( vec3 p, vec3 b, float r )   // variation - clamped box\n{\n  vec3 q = abs(p) - (b-r);\n  return max((length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r),-p.z);\n}\n\nfloat sdRoundedCylinder( vec3 p, float R, float r, float h )\n{\n  vec2 d = vec2( length(p.xz)-R, abs(p.y) - h*.5 );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\nfloat distTorus(vec3 p, float R, float r)\n{\n    return length(p-vec3(normalize(p.xy),0)*R)-r;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n  // c is the sin/cos of the angle\n  float q = length(p.xy);\n  return dot(c,vec2(q,p.z));\n}\n\nfloat dDirLine(vec3 p, vec3 c, vec3 dir, float l)\n{\n    p-=c;\n    dir=normalize(dir);\n    float dp=dot(p,dir);\n    //return length(p-dp*dir);\n    return max(max(length(p-dp*dir),-dp),dp-l);\n}\n\n// iq's exponantial smooth-min func\nfloat smin( float a, float b, float k )\n{\n    k=3./k;\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// iq's polynomial smooth-min func\nfloat smin_( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n#if 0\nbool intersectBox(vec3 p, vec3 dir, vec3 size)\n{\n    //vec3 n=cross(cross(dir,p),dir);\n    //return length(p-dot(p,n)*n/dot(n,n))<size.y;\n\n    //return true;\n    \n    size*=.5;\n    float tmin, tmax, tymin, tymax, tzmin, tzmax; \n    \n    vec3 s=sign(dir);\n    vec3 invdir=1./dir;\n\n    tmin  = (-size.x*s.x - p.x) * invdir.x; \n    tmax  = ( size.x*s.x - p.x) * invdir.x; \n    tymin = (-size.y*s.y - p.y) * invdir.y; \n    tymax = ( size.y*s.y - p.y) * invdir.y; \n \n    if ((tmin > tymax) || (tymin > tmax)) return false; \n    if (tymin > tmin) tmin = tymin; \n    if (tymax < tmax) tmax = tymax; \n \n    tzmin = (-size.z*s.z - p.z) * invdir.z; \n    tzmax = ( size.z*s.z - p.z) * invdir.z; \n \n    if ((tmin > tzmax) || (tzmin > tmax)) return false; \n    if (tzmin > tmin) tmin = tzmin; \n    if (tzmax < tmax) tmax = tzmax; \n \n    return true; \n}\n#endif\nbool intersectBox(vec3 p, vec3 dir, vec3 size)\n{\n    size*=.5*sign(dir);\n\n    vec3 vmin = (-size-p)/dir;\n    vec3 vmax = ( size-p)/dir;\n    \n    float tmin=vmin.x, tmax=vmax.x;\n    \n    if ((tmin > vmax.y) || (vmin.y > tmax)) return false; \n    tmin=max(tmin,vmin.y);\n    tmax=min(tmax,vmax.y);\n \n    if ((tmin > vmax.z) || (vmin.z > tmax)) return false; \n    tmin=max(tmin,vmin.z);\n    tmax=min(tmax,vmax.z);\n \n    return true; \n}\n\nfloat zmask(vec2 p)\n{\n    float skew=1.;\n    p.x += skew*p.y;\n    return step(p.y,step(-.35,p.x)-.5+.1)\n          -step(p.y,step( .35,p.x)-.5-.1);\n}\n\nvec4 zztop(vec2 p, float s_)\n{\n    float s=-1.;\n    p.x=-p.x;\n    vec2 p0=p;\n    p0*=-s_;\n    float s1=step(-12.6+2.9+2.9*s,-s_*((p.x)+s*.17*p0.y));\n    float z1 = zmask(p0+vec2(.25,.1))*step(-3.5,-p0.x-p0.y)*s1;\n    float d1=-.25*p.y+z1;\n    float z2 = zmask(p0-vec2(.25,.1))*step(-6.,-p0.x-p0.y)*s1;\n    float d2=.25*p.y+z2;\n    float bgm=step(0.,-s_*s*p.x)*step(-.7,-abs(p.y));\n    p.y=abs(p.y);\n    bgm=max(bgm,step(.5,exp(-(p.y-.8)*(p.y-.8)/.017)));\n    bgm*=step(-29.,-s_*(s*(p.x)-30.*p0.y));\n    bgm*=step(-15.,-s_*(s*(p.x)+15.*p0.y));\n    bgm*=step(-12.75,-s_*(-s*(p.x)-.17*p0.y));\n    bgm=0.;\n    vec4 bg=vec4(.5);\n    bg=clamp(bg,0.,1.);\n    vec4 col=vec4(.5,0,0,1);\n    if(d2<d1) col=vec4(1,.8,0,1);\n    col = mix(vec4(vec3(.8,0,.2)*0.,1),col,max(z1,z2));\n    col.w=max(bgm,max(z1,z2));\n    return col;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// zztop ford eliminator\n\n//#define RENDERED_REFECTIONS\n#define SHADOW\n#define SCRATCHES\n//#define STREET\n#define RENDER_GLASS\n//#define WET_ASPHALT\n//#define RENDER_BBOX\n#define RUMPFW 1.3\n#define ALLW (RUMPFW*1.3)\n\n#define Res  (iResolution.xy)\n\n#define RandTex iChannel0\n\n#ifdef SHADEROO\n#include Include_A.glsl\n#endif\n\n#define BG 0.\n#define CARBODY 1.\n#define TIRE 2.\n#define RIM 3.\n#define HEADLIGHTS 4.\n#define FLOOR 5.\n#define GRILL 6.\n#define RUMPF 7.\n#define INTERIOR 8.\n#define GLASS 9.\n#define WATER 10.\n#define CHASSIS 11.\n#define GUMMI 12.\n#define DESERT 13.\n\n//#define SET_PREV_MAT(x) mat=(abs(d-d_mat)>.0001)?(x):mat; d_mat=d;\n//#define SET_PREV_MAT(x) mat=mix(mat,x,step(.0001,abs(d-d_mat))); d_mat=d;\n//#define SET_PREV_MAT(x) mat+=step(.0001,abs(d-d_mat))*(-mat+x); d_mat=d;\n#define SET_PREV_MAT(x) if(abs(d-d_mat)>.0001) mat=(x); d_mat=d;\n\nstruct Material{\n    vec3 col;\n    float refl;\n    float scratchy;\n    vec2  scratchScale;\n};\n\n#define MAT_BG         Material(vec3(-1,-1,-1),       -1.,   0.0, vec2(1,.01))\n#define MAT_CARBODY    Material(vec3(.8, .05, .1),    -1.,   0.6, vec2(1,.01))\n#define MAT_TIRE       Material(vec3(.15,.15,.15),    -0.35, 1.0, vec2(1,.1)*.3)\n#define MAT_RIM        Material(vec3(1,1,1),           1.,   0.2, vec2(1,.01))\n#define MAT_HEADLIGHTS Material(vec3(.8),              1.,   0.2, vec2(1,.01))\n#ifdef WET_ASPHALT\n#define MAT_FLOOR      Material(vec3(.35),            -0.05, 0.0, vec2(1,.01))\n#else\n#define MAT_FLOOR      Material(vec3(.36,.35,.34)*1.2,            -0.2, 0.0, vec2(1,.01))\n#endif\n#define MAT_GRILL      Material(vec3(.8),              1.,   0.1, vec2(1,.1))\n#define MAT_RUMPF      Material(vec3(.8, .05, .1),    -1.,   0.6, vec2(1,.01))\n#define MAT_INTERIOR   Material(vec3(.9,.7,.5)*.3,    -0.0,  0.0, vec2(1,.01))\n#define MAT_GLASS      Material(vec3(1),              -1.,   0.6, vec2(1,.01))\n#define MAT_WATER      Material(vec3(.1),             -1.,   0.0, vec2(1,.01))\n#define MAT_CHASSIS    Material(vec3(.4),              0.5,  1.0, vec2(1,.01)*.5)\n#define MAT_GUMMI      Material(vec3(.3),             -0.1,  1.0, vec2(1,.01))\n#define MAT_DESERT     Material(vec3(.58,.55,.53)*.85,-0.2,  0.0, vec2(1,.01))\n\n#define USE_MTL_ARRAY \n#ifdef USE_MTL_ARRAY\nconst Material mat[14] = Material[] (\nMAT_BG        ,\nMAT_CARBODY   ,\nMAT_TIRE      ,\nMAT_RIM       ,\nMAT_HEADLIGHTS,\nMAT_FLOOR     ,\nMAT_GRILL     ,\nMAT_RUMPF     ,\nMAT_INTERIOR  ,\nMAT_GLASS     ,\nMAT_WATER     ,\nMAT_CHASSIS   ,\nMAT_GUMMI     ,\nMAT_DESERT\n);\nMaterial getMaterial(float mtl) { return mat[int(mtl)]; }\n#else\nMaterial getMaterial(float mtl)\n{\n    if(mtl==BG)           return MAT_BG        ;\n    if(mtl==CARBODY)      return MAT_CARBODY   ;\n    if(mtl==TIRE)         return MAT_TIRE      ;\n    if(mtl==RIM)          return MAT_RIM       ;\n    if(mtl==HEADLIGHTS)   return MAT_HEADLIGHTS;\n    if(mtl==FLOOR)        return MAT_FLOOR     ;\n    if(mtl==GRILL)        return MAT_GRILL     ;\n    if(mtl==RUMPF)        return MAT_RUMPF     ;\n    if(mtl==INTERIOR)     return MAT_INTERIOR  ;\n    if(mtl==GLASS)        return MAT_GLASS     ;\n    if(mtl==WATER)        return MAT_WATER     ;\n    if(mtl==CHASSIS)      return MAT_CHASSIS   ;\n    if(mtl==GUMMI)        return MAT_GUMMI     ;\n    if(mtl==DESERT)       return MAT_DESERT    ;\n}\n#endif\n\nbool enable_glass=true;\n\n#ifndef RandTex \n#define RandTex iChannel1\n#endif\n\nvec4 getRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(RandTex,coord+.003*iTime);\n    c+=texture(RandTex,coord/2.+.003*iTime)*2.;\n    c+=texture(RandTex,coord/4.+.003*iTime)*4.;\n    c+=texture(RandTex,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\n#define FloorZ -.66\n//#define HomePos vec3(0,0,-FloorZ*1.5)\n//#define CamDist0 18.\n\n// envoronment just a sky and some floor grid...\nvec4 myenv(vec3 pos, vec3 dir, float period_)\n{\n    vec3 sun = normalize(getLightDir());\n    vec3 skyPos=pos+dir/abs(dir.z)*(120.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.0002).x-.5));\n    vec3 colHor=vec3(.3,.4,.5)+.4;\n    float dirl=dot(dir,sun);\n    vec3 clouds=mix(vec3(1.)*(1.-2.*dirl),vec3(.8,1.,1.2),cloudPat);\n    vec3 colSky=mix(vec3(1.5,.75,0.)*3.,clouds,clamp(7.*dir.z,0.,1.));\n    vec3 colFloor=vec3(.45);\n    \n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*5.)-.1,0.,1.));\n    \n    col*=.9;\n    \n    //float sunang=acos(dot(dir,sun));\n    float sunang=atan(length(cross(dir,sun)),dot(dir,sun));\n    col+=15.*clamp(2.*exp(-sunang/.02),0.,1.);\n    col+=2.*clamp(2.*exp(-sunang/.20),0.,1.);\n    \n    return vec4(col,1);\n}\n\n\nfloat distTire(vec3 p, float r)\n{\n    p=abs(p);\n    float d=1000.;\n    d=min(d,length(p)-r);\n    d=max(d,distTorus(p.yzx,r*.75,r*.38));\n    d=max(d,-length(p.yz)+r*.61);\n    float dx=.07;\n    float xfr=mod(p.x,dx);\n    float x=p.x-xfr+dx*.5;\n    d=max(d,-distTorus(p.yzx-vec3(0,0,x),sqrt(r*r-x*x),.015));\n    return d;\n}\nfloat distRim(vec3 p, float r)\n{\n    r*=.6;\n    p=abs(p);\n    p=p.zxy;\n    float d=1000.;\n    d=min(d,sdRoundedCylinder(p,r,.01,1.1*r));\n    p-=vec3(0,.6*r,0);\n    d=-smin(-d,sdRoundedCylinder(p,.97*r,.01,.1*r),.005);\n    d=-smin(-d,sdRoundedCylinder(p,.89*r,.01,.4*r),.005);\n    d=-smin(-d,sdRoundedCylinder(p,.77*r,.01,.8*r),.005);\n    d=min(d,sdCone(p.xzy-vec3(0,0,-.2*r),cos(1.1-vec2(0,1.57))));\n    float mang,ang;\n    float ang0 = atan(p.z,p.x);\n    mang=mod(ang0,PI2/12.);\n    ang=ang0-mang+PI2/12.*.5;\n    d=-smin(-d,(length(p.xz-.58*r*cos(ang-vec2(0,1.57)))-.1*r),.005);\n    mang=mod(ang0,PI2/24.);\n    ang=ang0-mang+PI2/24.*.5;\n    d=min(d,max(abs(p.y+.6*r)-.22*r,(length(p.xz-.73*r*cos(ang-vec2(0,1.57)))-.035*r)));\n    return d;\n}\n\nconst vec3 bbpos=vec3(0,-.06,.07);\nconst vec3 bbsize=vec3(ALLW*1.12,3.63,1.5);\nconst vec3 bbpos1=vec3(0,-.0,-.11);\nconst vec3 bbsize1=vec3(ALLW*1.12,3.73,1.13);\nconst vec3 bbpos2=vec3(0,.23,.47);\nconst vec3 bbsize2=vec3(ALLW*.83,1.25,.7);\n\nfloat rille2(float d, float w)\n{ \n    return w*exp2(-d*d*2./w/w);\n}\nfloat rille(float d, float w)\n{\n    ///// gauss\n    //return w*exp2(-d*d*2./w/w);\n    ///// exp\n    return w*exp2(-abs(d)*1.44/w);\n    ///// linear\n    //return max(abs(d)-w,0.);\n}\n\n#define USE_SIMDATA\n#ifdef USE_SIMDATA\n#define SteerAng (texelFetch(iChannel1,ivec2(4,0),0).x)\n#define WheelRot (texelFetch(iChannel1,ivec2(5,0),0))\n#define CamDistFact (texelFetch(iChannel1,ivec2(4,0),0).y)\n#else\nuniform float SteerAng;\nconst vec4 WheelRot=vec4(0);\n#define CamDistFact 1.0\n#endif\n\nvec2 distCar(vec3 p)\n{\n    vec3 p0rot=p;\n    p=transformVecByQuat(p,axAng2Quat(vec3(1,0,0),-.023));\n    float d=1000., d_mat=1001., mat=-1.;\n    SET_PREV_MAT(BG);\n    p*=2.;\n    if(p.x<0.) p.x=-p.x;\n    vec3 p0=p;\n    //d=min(d,length(p)-.5);\n    p=p0+vec3(0,.1,0);\n    float drumpf=sdRoundBox( p, vec3(RUMPFW+p.y*.15-p.y*p.y*.04+p.z*p.y*.03, \n                                 3.2-p.z*.3+p.z*p.z*.1 - step(0.,-p.y)*p.x*.3-step(0.,p.y)*.4*p.z, \n                                 .8+p.y*.02-p.x*p.x*.05*(1.+.01*(p.y*p.y*p.y*p.y))),\n                             max(p.y*.04,mix(.25+p.y*.05,.07,-p.z*1.5+.5)))*.7;\n    p=p0-vec3(0,.5,.87);\n    float dcabin = sdRoundBox( p, vec3(RUMPFW*1.05+p.y*.07-p.y*p.y*.08+p.z*.0, \n                                       1.2-p.z*.3,\n                                       .7+p.y*.07-p.x*p.x*.05-p.y*p.y*.05),\n                               .33+.15*p.y )*.7;\n    d=min(d,dcabin);\n    // rear front screen\n    p=p0-vec3(0,.4,.88+.10-.06*p.x*p.x);\n    //float dfrontscr=sdRoundBox( p, vec3(RUMPFW*.4-step(0.,p.y)*.2,2.,.1-step(0.,p.y)*.03)*2., .1 )*.7;\n    // only 2d needed - not sure if rect is faster - maybe some compilers can optimize something out...\n    float sy=step(0.,p.y);\n    float dfrontscr=sdRoundRect( p.xz-vec2(0,sy*.1), vec2(RUMPFW*.4-sy*.2,.14-step(0.,p.y)*.07)*2., .14-sy*.04 )*.7;\n    dfrontscr=max(dfrontscr,-(drumpf-.07));\n    d=-smin(-d,dfrontscr,.03);\n    //d+=rille(dfrontscr-.03,.007);\n    // side screens\n    p=p0-vec3(0,.23,.96);\n    vec3 sidebox=vec3(2.,.35-p.z*.1,.105+p.y*.008-.05*p.y*p.y*step(0.,p.z))*2.;\n    //float dsidescr=sdRoundBox( p-vec3(0,.1*p.z,.015*p.y), sidebox, .13+.04*p.y )*.7;\n#if 0\n    float dsidescr=sdRoundRect( p.yz-vec2(.1*p.z,.015*p.y), sidebox.yz, .13+.04*p.y )*.7;\n    //p.z+=.25;\n    //float ddoor   =sdRoundBox( p-vec3(0,.1*p.z,.015*p.y)+vec3(0,0,.59), sidebox+vec3(0,0,.59), .13+.04*p.y )*.7;\n    float ddoor   =sdRoundRect( p.yz-vec2(.1*p.z,.015*p.y)+vec2(0,.59), sidebox.yz+vec2(0,.59), .13+.04*p.y )*.7;\n#else\n    // not sure if even making 2 rects at once is really faster...\n    vec2 dssdoor=sdRoundRect2( (p.yz-vec2(.1*p.z,.015*p.y)).xyxy+vec4(0,0,0,.59), sidebox.yzyz+vec4(0,0,0,.59), vec2(.13+.04*p.y) )*.7;\n    float dsidescr=dssdoor.x;\n    float ddoor=dssdoor.y;\n#endif\n    ddoor-=.07;\n    p=p0-vec3(0,-2.05,.77)*1.;\n    p=transformVecByQuat(p-vec3(0,p.x*.25,0),axAng2Quat(vec3(1,0,0),.28));\n    //float dhood   =sdRoundBox( p,vec3(ALLW,.9,1.),.18)*.7;\n    float dhood   =sdRoundRect( p.yz,vec2(.9,1.),.18)*.7;\n    d=-smin(-d,dsidescr,.05);\n    //d=-smin(-d,abs(dsidescr-.03),.02);\n    d-=clamp((abs(dsidescr-.03)-.016)*.2,-0.02,0.);\n    p=p0;\n    p-=vec3(0,0,-.77);\n    float dz1=.5*(cos(p.x*4./ALLW)-1.)*(cos(p.y*1.5-2.-step(2.86,-p.y)*.8*(p.y+2.86)*(p.y+2.86))*.4+.4)*step(.766,-p.y);\n    float dz2=.5*(cos(p.x*3.3/ALLW)-1.)*clamp((cos(p.y*.6-1.5)*2.5-2.)*1.7,0.,1.);\n    p.z+=dz1+dz2;\n    p-=vec3(0,-.07,0);\n    //float dfender = sdHalfRoundBox( p, vec3(ALLW+p.y*.05,\n    //                            3.5-.12*cos(p.x*p.x*3.3/ALLW*(.85+.15*step(0.,-p.y)))*(.3+.7*step(0.,-p.y)),.16),\n    //                            .16 )*.7;\n    float dfender = sdRoundBox( p-vec3(0,0,-.3), vec3(ALLW+p.y*.05,\n                                3.5-.1*cos(p.x*p.x*3.3/ALLW*(.85+.15*step(0.,-p.y)))*(.3+.7*step(0.,-p.y)),.16+.3),\n                                .16 )*.7;\n    float ss=1.-smoothstep(-3.,-1.8,p.y);\n    float fz0=p.z-dz1*(exp2(-ss*7.));\n    dfender=min(dfender,(sqrt(dfender*dfender+fz0*fz0)-.01)*.7);\n    dfender=max(dfender,-(fz0)*.7);\n    d=min(d,dfender);\n    SET_PREV_MAT(CARBODY);\n    //drumpf-=clamp(abs(dhood)-.005,-0.02,0.);\n    drumpf+=rille(dhood,.005);\n    //side stripe\n    p=p0+vec3(0,.1,0);\n    drumpf-=.6*rille2(p.z-.4+.03*p.y-.1*p.x,.02)*(1.-smoothstep(2.4,2.6,abs(p0.y+.3)));\n    //*clamp((abs(p.z-.55)-.02)*.5,-0.02,0.);\n    d=smin(d,drumpf,.03);\n    //d=-smin(-d,abs(ddoor),.01);\n    //d-=clamp(abs(ddoor)-.005,-0.02,0.);\n    d+=rille(ddoor,.005);\n    SET_PREV_MAT(RUMPF);\n    d=min(d,dfender+.01-.03*smoothstep(-1.45,-1.4,-p0.y)*smoothstep(-.95,-.9,p0.y));\n    SET_PREV_MAT(TIRE);\n    d=min(d,step(0.,p.y)+length(vec2(dfrontscr-.01,dcabin+.01))-.015);\n    SET_PREV_MAT(GUMMI);\n    d=min(d,step(0.,p.y)+length(vec2(dfrontscr-.02,dcabin+.01))-.02);\n    SET_PREV_MAT(GRILL);\n    float z=p.z+.2;\n    float dgrillhole=sdRoundBox( p-vec3(0,-3.,-.02), vec3(.18*.9*RUMPFW-step(0.,-z)*z*z*.58*RUMPFW,.5,.33)*2., .1 );\n    d=-smin(-d,dgrillhole,.04);\n    SET_PREV_MAT(CARBODY);\n    //SET_PREV_MAT(TIRE);\n\n    p=p0-vec3( 0, -3.26+.3*p.z+.35*p.x-.1*p.z*p.z, 0);\n    p.x=mod(p.x+.005,.025)-.0125;\n    d=min(d,max(dgrillhole,(length(p.xy)-.007)*.8));\n    SET_PREV_MAT(GRILL);\n\n    p=p0-vec3(0,.7,.87-.2);\n    d=max(d,-dcabin-.06);\n    SET_PREV_MAT(INTERIOR);\n    \n#ifdef RENDER_GLASS\n    // window glass\n    //if(enable_glass)\n    {\n        d=min(d,dcabin+.035+(enable_glass?0.:1000.));\n        SET_PREV_MAT(GLASS);\n    }\n#endif\n    \n    #define PF (vec3(ALLW*.39,-1.43,-.33)*2.)\n    #define PR (vec3(ALLW*.48,1.23,-.35)*2.)\n    vec3 pf=p0-PF;\n    vec3 pr=p0-PR;\n    \n    // check tire only once\n    //bool rear = (dot(pr,pr)<dot(pf,pf));\n    float rear = step(0.,p0rot.y);\n    float left = step(0.,p0rot.x);\n    float leftSgn=sign(p0rot.x);\n    p=mix(pf,pr,rear); float siz=mix(.62,.7,rear);\n    \n    // steering rotation of front wheels\n    vec4 q=axAng2Quat(vec3(0,0,1),leftSgn*(1.-.1*leftSgn*sign(SteerAng))*SteerAng*(1.-rear));\n#if 0\n    p+=vec3(.07,0,0);\n    p = (p + 2.0 * cross( q.xyz, cross( q.xyz, p ) + q.w*p ));\n    p-=vec3(.07,0,0);\n#else\n    // the above is exactly this below... why is this not working... bug in nvidia pipeline?! or am i missing sth here??\n    p=transformVecByQuat(p+vec3(.07,0,0),q)-vec3(.07,0,0);\n#endif\n\n#ifdef USE_SIMDATA\n    float rot=WheelRot.x;\n    p=transformVecByQuat(p,axAng2Quat(vec3(1,0,0),rot));\n#endif\n\n    d=min(d, distTire(p,siz));\n    SET_PREV_MAT(TIRE);\n    d=min(d, distRim(p,siz));\n    SET_PREV_MAT(RIM);\n    \n    p=p0;\n    float xx=p.x*p.x;\n    p=pf+vec3(ALLW*.38,0,+.1-xx*.03-step(ALLW*.6,p.x)*(p.x-ALLW*.6)*.3)*2.;\n    d=min(d,max(length(p.yz)-.05,p.x-ALLW*.7));\n    d=min(d,dDirLine(pf,vec3(-.4,-.1,-.1),vec3(-1,0,1.5),.5)-.04);\n    d=min(d,dDirLine(pf,vec3(-.3,.1,-.14),vec3(-.0,1,0.05),1.5)-.02);\n    SET_PREV_MAT(CHASSIS);\n    \n    p=p0-vec3(.37,-1.57,0.1)*2.;\n    float d1=1000.;\n    d1=min(d1, length(p)-.11*2.1);\n    d1=-smin(-d1, (length(p+vec3(0,.35,0))-.17*2.1),.02);\n    d=min(d,d1);\n    SET_PREV_MAT(HEADLIGHTS);\n    \n    #ifdef RENDER_BBOX\n    //if(enable_glass)\n    {\n        p=p0;\n        d=min(d,abs(sdRoundBox( p0rot-bbpos1, bbsize1*.5, .0))+(enable_glass?0.:1000.));\n        d=min(d,abs(sdRoundBox( p0rot-bbpos2, bbsize2*.5, .0))+(enable_glass?0.:1000.));\n        SET_PREV_MAT(GLASS);\n    }\n    #endif\n    \n    return vec2(d*.5,mat);\n}\n\nbool enable_car=true;\n\nfloat lorentz(float x) { return 1./(1.+x*x); }\n\n#define RND_SC 1.\nfloat hTerr(vec3 p)\n{\n    vec4 rTerr=.8*textureLod(iChannel0,p.xy*.00006*RND_SC,0.)+.4*textureLod(iChannel0,p.xy*.00012*RND_SC,0.);\n    float pp=dot(p.xy,p.xy)/(200.*200.);\n    return rTerr.x*min(pp*pp,40.);\n}\n\nvec4 getTiltQuat(vec3 pos)\n{\n    float h0 =hTerr(pos);\n    vec2  dh=vec2(hTerr(pos+vec3(2,0,0))-h0,\n    \t\t\t  hTerr(pos+vec3(0,2,0))-h0)*.5;\n    \n    //return axAng2Quat(normalize(vec3(dh.y,-dh.x,0)),atan(length(dh)));\n    // same as above axAng2Quat(...) - but less angle back/forth conversions\n    float ch = sqrt(.5+.5/sqrt(1.+dot(dh,dh)));      // cos(ang/2)\n    return vec4(vec3(dh.y,-dh.x,0)*(ch-.5/ch),ch);  // (ch-.5/ch) == sin(ang/2)/tan(ang);\n}\n\nvec3 carTrafo(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(iChannel1,ivec2(3,0),0);\n    vec3 offs=texelFetch(iChannel1,ivec2(0,0),0).xyz;\n    offs.z=-hTerr(-offs);\n    q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p+translate*offs,inverseQuat(q));\n#else\n    return p;\n#endif\n}\n\nvec3 carTrafo(vec3 p)\n{\n    return carTrafo(p,1.0);\n}\n\nvec3 carTrafoInv(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(iChannel1,ivec2(3,0),0);\n    vec3 offs=texelFetch(iChannel1,ivec2(0,0),0).xyz;\n    offs.z=-hTerr(-offs);\n    q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p,q)-offs*translate;\n#else\n    return p;\n#endif\n}\n\nvec2 distM(vec3 p)\n{\n    float d=1000., mat=-1., d_mat=d;\n    if(enable_car)\n    {\n        vec2 dm=distCar(carTrafo(p));\n        d=dm.x; mat=dm.y; d_mat=d;\n    }\n    vec4 r=texture(iChannel0,p.xy*1.5*RND_SC,0.)-.5;\n    vec4 r2=texture(iChannel0,(p.xy*.005*RND_SC),-.5)-.5;\n    vec4 r3=texture(iChannel0,(p.xy*.015*RND_SC),-.0)-.5;\n    vec4 r4=texture(iChannel0,(p.xy*.03*RND_SC),-.0)-.5;\n    vec4 r5=texture(iChannel0,(p.xy*.06*RND_SC),-.0)-.5;\n    float rm=r3.y*1.+r4.y*.5+r5.y*.25;\n    float rm2=r3.z*.7+r4.z*.5;\n    float pp=dot(p.xy,p.xy)/(200.*200.);\n    #ifdef STREET\n    float streetstep=smoothstep(4.5,5.5,abs(p.x-2.));\n    #else\n    float streetstep=0.;\n    #endif\n    d=min(d,p.z\n    +.66\n    #ifndef STREET\n    -hTerr(p)\n    #endif\n    //+.015*(r3.y-.2)\n    #ifdef WET_ASPHALT\n    +lorentz(-rm/.06/r2.x)*.05*(r2.x+.3)\n    #else\n    -.02-min(-abs(rm)*.06,.04-exp(-abs(rm/(r2.x+.15)*.25)*3.)*.07)-r.x*.0035\n    #endif\n    );\n    SET_PREV_MAT(FLOOR);\n    \n    #ifdef STREET\n    d=min(d,p.z\n    +.73\n    +r2.z*.1+r.z*.01\n    -streetstep*.2\n    -hTerr(p)\n    );\n    SET_PREV_MAT(DESERT);\n    #endif\n    #ifdef WET_ASPHALT\n    d=min(d,p.z+.665+pp*16./*-.02*/);\n    SET_PREV_MAT(WATER);\n    if(mat==FLOOR) d-=r.x*.0035;\n    #endif\n    \n    return vec2(d,mat);\n}\n\nfloat dist(vec3 p) { return distM(p).x; }\n\nvec3 getGradOld(vec3 p,float delta)\n{\n    float v=dist(p);\n    vec2 d=vec2(delta,0); return vec3( dist(p+d.xyy)-v,\n                                       dist(p+d.yxy)-v,\n                                       dist(p+d.yyx)-v )/delta;\n}\n\n/// my own version of a looped getGrad()\nvec3 getGrad(vec3 p,float delta)\n{\n    vec4 d=vec4(0,0,0,1); \n    vec3 s=vec3(0);\n    // use a loop here keep compiler from inlining this in win (thanks iq for the hint!)\n    for(int i=min(0,iFrame);i<4;i++)\n    {\n      \ts+=(d.xyz-d.w)*dist(p+d.xyz*delta);\n        d=d.wxyz;\n    }\n    return s/delta;\n}\n\n/// klems' getGrad - slightly modified to avoid div by 0\nvec3 getGrad2(vec3 p,float delta)\n{\n    // use loop here to keep compiler from inlining this in win (thanks iq for the hint!)\n    // btw very interesting function that...\n    vec4 n = vec4(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += delta;\n        n[i] = dist(s.xyz);\n    }\n    n-=n.w;\n    return n.xyz/(length(n.xyz)+.0001); // added some small epsilon to avoid division by 0\n}\n\nfloat march(inout vec3 p, vec3 dir)\n{\n    //if(!intersectBox(p-bbpos,dir,bbsize)) { enable_car=false; }\n    vec3 pc=carTrafo(p);\n    vec3 pdir=carTrafo(dir,0.);\n    //enable_car=true;\n    if(!(intersectBox(pc-bbpos1,pdir,bbsize1)||intersectBox(pc-bbpos2,pdir,bbsize2))) { enable_car=false; }\n    vec3 p0=p;\n    float eps=.001;\n    float dmin=1000.;\n    bool findmin=false;\n    float d=dist(p);\n    vec3 pmin=p;\n    for(int i=0;i<150;i++)\n    {\n        float dp=d;\n        d=dist(p);\n        p+=dir*d*.8;\n#ifdef SHADOW\n        if (d<dp) findmin=true;\n        if (findmin && d<dmin) { dmin=d; pmin=p; }\n#endif\n        if (d<eps) return 0.;\n        if (d>300.) break;\n    }\n    return clamp(dmin/length(pmin-p0)/.05,0.,1.);\n}\n\nfloat wstep(float w, float thr, float x)\n{\n    return smoothstep(thr-w*.5,thr+w*.5,x);\n}\n\nfloat getAO(vec3 pos, vec3 n)\n{    \n    float ao=1.;\n    float sc=.025;\n    float amb=.3;\n    // use loop here to keep compiler from inlining this in win (thanks iq for the hint!)\n    for( int i=min(iFrame,0); i<5; i++ )\n    {\n    \tao*=mix(dist(pos+n*sc)/sc*1.4,1.,amb);\n    \tao=clamp(ao,0.,1.);\n        sc*=2.;\n        amb=min(amb+.1,.5);\n    }\n    return ao;\n   \t/*\n    ao*=dist(pos+n*.02)/.02*1.4*.7+.3;\n   \tao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.05)/.05*1.4*.6+.4;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.1)/.1*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.2)/.2*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.4)/.4*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);*/\n}\n\nvec3 lighting(vec3 pos, vec3 dir, vec3 pos0, float reflections, inout float outfres, inout float outao)\n{\n    vec3 pc=carTrafo(pos);\n    vec3 glasspos=vec3(1000.);\n    vec3 glassn=vec3(0.);\n    float mat=distM(pos).y;\n    if(mat==GLASS)\n    {\n        glasspos=pos;\n        glassn=normalize(getGrad(pos,.001));\n        enable_glass=false;\n        march(pos,dir);\n    }\n    mat=distM(pos).y;\n    \n    vec3 light=getLightDir();\n    float sh=1.;\n#ifdef SHADOW\n    vec3 posS=pos+.017*light;\n    enable_car=true;\n    sh=march(posS,light);\n#endif\n    enable_car=true;\n    vec3 n=getGrad(pos,.001);\n    if (length(n)<.001) n=vec3(0,0,1);\n    n=normalize(n);\n    if(mat==BG) n=vec3(0,0,1);\n\n    float ao=getAO(pos,n);\n    ao=sqrt(ao);\n    ao=ao*.7+.3;\n\n    float diff=clamp(dot(n,light),0.,1.);\n\n    diff=min(diff,sh);\n    \n    // no ao in lighted areas\n    ao=mix(ao,1.,diff);\n    ao=clamp(ao,0.,1.);\n    //return vec3((diff*.6+.4)*(ao));\n    \n\n    Material mtrl=getMaterial(mat);\n\n    // evironmental reflection\n    n=normalize(n);\n    vec3 R=reflect(dir,n);\n    vec3 refl=myenv(pos,R.xyz,1.).xyz;\n    //refl=refl*1.2+.3;\n    float fres=abs(dot(R,n));\n    fres=1.-fres;\n    fres*=fres*fres;\n    fres=fres*.9+.1;\n    float fres0=fres;\n    #ifdef SCRATCHES\n    vec3 n0=n;\n    int numscr=7;\n    float dang=1.57*2./float(numscr);\n    float ang=.5;\n    refl*=1.;\n    vec3 drefl=vec3(0);\n    float sum=0.;\n    vec3 pi=pc;\n    vec3 heading=vec3(0,0,1);\n    vec3 tan1=vec3(1,0,0);\n    vec3 tan2=vec3(0,1,0);\n    // ...trying to implement some micro scratches\n    for(int i=0;i<numscr*3;i++)\n    {\n        n=n0;\n        vec2 cs=cos(ang+vec2(0,-1.57));\n        mat2 m=mat2(cs,cs.yx*vec2(-1,1));\n        //dFdx()\n        vec2 dn2d=(texture(iChannel0,(m*pi.xy)*vec2(6.,.1)*mtrl.scratchScale+vec2(0,.5/256.)).x-.5)*mtrl.scratchScale;\n        dn2d=pow(abs(dn2d),vec2(.7))*sign(dn2d);\n        dn2d=dn2d*m;\n        //dn2d=dn2d.yx*vec2(1,-1);\n        n+=abs(dot(n0,heading))*carTrafoInv(dn2d.x*tan1+dn2d.y*tan2,0.);\n        n=normalize(n);\n        R=reflect(dir,n);\n        float fres=abs(dot(R,n));\n        fres=1.-fres;\n        fres*=fres*fres;\n        fres=fres*.4+.6;\n        float fact=(abs(dot(n0,-dir))*.8+.2)*fres;\n        //fact=.2;\n        drefl+=fact*myenv(pos,R.xyz,1.).xyz;\n        sum+=fact;\n        ang+=dang;\n        pi=pi.zxy;\n        heading=heading.yzx;\n        tan1=tan1.yzx;\n        tan2=tan2.yzx;\n    }\n    drefl/=float(numscr);\n    refl=mix(refl,drefl,mtrl.scratchy);\n    #endif\n    \n    #ifdef RENDER_GLASS\n    vec3 Rg=reflect(dir,glassn);\n    vec3 glassrefl=myenv(pos,Rg.xyz,1.).xyz;\n    //glassrefl=glassrefl*1.2+.3;\n    float glassfres=abs(dot(Rg,glassn));\n    glassfres=1.-glassfres;\n    glassfres*=glassfres*glassfres;\n    glassfres=glassfres*.85+.15;\n    if(glassn==vec3(0)) glassfres=0.;\n    #endif\n\n    vec3 rcol=vec3(1);\n    fres=(mtrl.refl<0.)?fres*-mtrl.refl:mtrl.refl;\n    rcol=(mtrl.refl<0.)?vec3(1):mtrl.col;\n    vec3 col=mtrl.col;\n    if(mat==FLOOR) {\n        col+=(texture(iChannel0,pos.xy*2.,-1.2).x-.5)*.3;\n        col*=.9+.2*texture(iChannel2,pos.xy*.2).xyz;\n        #ifdef WET_ASPHALT\n        col*=.35+.65*step(-.66,pos.z);\n        fres=fres0*mix(-mtrl.refl,1.,(1.-smoothstep(-.661,-.659,pos.z))*exp(-length(pos.xy)/50.));\n        #endif\n    }\n\n    vec4 zzt=vec4(0);\n    {\n        vec3 p=carTrafo(pos);\n    #ifndef ZZT_AS_TEX\n \t    float sp=sign(p.x); // windows not able to compile if i substitute this directly below... [rolleyes]\n        zzt=zztop((p.yz*8.5*vec2(sp,1)-vec2(sp,.9))*vec2(1,1.-.15*p.y),sp);\n    #else\n        vec2 uv=(vec2(-1,1)*(p.yz*8.5-vec2(1,.9))*vec2(1,1.-.15*p.y)/11.+.75)*.5;\n        uv=clamp(uv,0.,1.);\n        zzt=texture(iChannel1,uv);\n    #endif\n    }\n    if(mat==RUMPF) { \n        col=mix(col,zzt.xyz,zzt.w);\n        if(zzt.xyz==vec3(1)) { fres=.6; col*=.0; }\n    }\n    //col-=n*.05;\n    \n    float zr=length(pos-pos0)/300.;\n    //diff=sqrt(diff);\n\n    outfres=fres;\n    if(glassfres!=0.) outfres=glassfres;\n    fres*=reflections;\n    glassfres*=reflections;\n\n    outao=ao;\n    \n\tvec3 bg=myenv(pos0,dir,1.).xyz;\n\t// diff, ao, refl\n\tvec3 finalcol = mix(col,rcol*refl,fres)*mix(vec3(1.2,1.4,1.5)*.5,vec3(1.,1,.9),diff)*ao*1.3;\n\t//finalcol=col;\n\t// fog\n\t//finalcol = mix(finalcol,bg,1.-exp(-zr));\n\tfinalcol = mix(finalcol,bg,1.-clamp(exp(-zr+.1),0.,1.));\n\t#ifdef RENDER_GLASS\n\tfinalcol=mix(finalcol,glassrefl,glassfres);\n\t#endif\n\treturn finalcol;\n}\n\nvec4 camAnim[8] = vec4[] (\n    vec4( 1.5, -2.75,-0.25 ,1.), vec4(0,1.,.1, 0.),\n    vec4(-1.5, -2.75,-0.25 ,1.), vec4(.5,1.,.1, 0.),\n    //vec4(-2., -1.5,-0.25 ,1.), vec4(1.,0.,.1, 0.),\n    vec4(-2., 3.,-0.35 ,1.), vec4(.5,-1,.1, 0.),\n    vec4(-2., 3.,-0.35 ,1.), vec4(.5,-1,.1, 0.)\n    );\n    \nvec3 getCamAnimPos(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2].xyz,camAnim[i_c*2].xyz,fact);\n}\n\nvec3 getCamAnimDir(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2+1].xyz,camAnim[i_c*2+1].xyz,fact);\n}\n\nfloat getCamAnimBr(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2].w,camAnim[i_c*2].w,fact);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 sc=(fragCoord-Res*.5)/Res.x;\n    \n    float zoom=1.;\n    #ifdef SHADEROO\n    zoom=exp(-iMouseData.z/5000.);\n    #endif\n    zoom*=CamDistFact;\n\n    vec3 CarPos = carTrafoInv(vec3(0),1.);\n    vec3 pos=vec3(0,0,4.5)*zoom;\n    vec3 dir=normalize(vec3(sc,-.8));\n    \n    vec4 q=vec4(0,0,0,1);\n    float th=-(iMouse.y-Res.y*.5)/Res.y*6.;\n    float ph=-(iMouse.x-Res.x*.5)/Res.x*10.;\n    //if(iMouse.x<1.) \n    { th=1.45; ph=-iTime*.25; }\n    th=clamp(th,-1.65,1.65);\n    q=multQuat(q,axAng2Quat(vec3(0,0,1),ph));\n    q=multQuat(q,axAng2Quat(vec3(1,0,0),th));\n    pos=transformVecByQuat(pos,q)-vec3(0,0,.2);\n    dir=transformVecByQuat(dir,q);\n    pos=carTrafoInv(pos,1.);\n    dir=carTrafoInv(dir,0.);\n\n    //if(iMouse.x<1.)\n    {\n    pos=getCamAnimPos(iTime);\n    pos+=.015*sin(iTime*vec3(1,1.3,1.7)*1.);\n    dir=normalize(getCamAnimDir(iTime));\n    vec3 right=normalize(cross(dir,vec3(0,0,1)));\n    vec3 up=cross(right,dir);\n    dir=normalize(dir+right*sc.x+up*sc.y);\n    }\n    \n    vec3 pos0=pos;\n    float m=march(pos,dir);\n    \n    float refl=1.;\n    #ifdef RENDERED_REFECTIONS\n    refl=0.;\n    #endif\n    float fres=0., ao=0.;\n    fragColor.xyz=lighting(pos,dir,pos0,refl,fres,ao);\n    #ifdef RENDERED_REFECTIONS\n    enable_glass=true;\n    vec3 n=getGrad(pos,.001);\n    if (length(n)<.001) n=vec3(0,0,1);\n    n=normalize(n);\n    dir=reflect(dir,n);\n    pos+=dir*.003;\n    /*fres=abs(dot(dir,n));\n    fres=1.-fres;\n    fres*=fres*fres;\n    fres=fres*.9+.1;*/\n    float mat=distM(pos).y;\n    march(pos,dir);\n    float dummyfres,dummyao;\n    vec3 lcol=lighting(pos,dir,pos0,1.,dummyfres,dummyao);\n    fragColor.xyz=mix(fragColor.xyz,lcol,(m!=0.)?0.:fres);\n    #endif\n    \n    fragColor*=1.-exp(-getCamAnimBr(iTime)*getCamAnimBr(iTime)/.01);\n    \n\tfragColor.w=1.;\n}\n\n#if 0\nvoid mainImageXX( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0);\n    float snum=0.;\n    for(int i=0;i<max(int(snum),1);i++)\n    {\n        enable_glass=true;\n        vec4 col=vec4(0);\n        vec2 r = (texelFetch(iChannel0,ivec2(mod(fragCoord+vec2(i*5+iFrame*13,0)+.1,256.0))&255,0).xy-.5)*1.;\n        //vec2 r = getRand(i+int(fragCoord.x+fragCoord.y*iResolution.x)).xy-.5;\n        mainImageS(col,fragCoord+r*((snum>0.)?1.:0.3));\n        fragColor+=col;\n        vec4 r2=texture(iChannel0,fragCoord/Res0*.707+iTime*4.5+float(i)*.1)-.5;\n        fragColor+=.05*r2;\n    }\n    fragColor/=floor(max(snum,1.));\n}\n#endif\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}