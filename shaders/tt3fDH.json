{
    "Shader": {
        "info": {
            "date": "1612631555",
            "description": "By subtracting the low-pass component from regular noise (L), we get the high-pass component (C). Since the low-pass filter removes gradients, the high-pass noise behaves well even when repeated in small textures. Comparison with blue noise (R).",
            "flags": 0,
            "hasliked": 0,
            "id": "tt3fDH",
            "likes": 6,
            "name": "High-Pass Noise",
            "published": 3,
            "tags": [
                "noise",
                "tileable",
                "highpass"
            ],
            "usePreview": 1,
            "username": "spawner64",
            "viewed": 567
        },
        "renderpass": [
            {
                "code": "// High-Pass Noise\n//\n// By subtracting the low-pass component from the noise, we get the high-pass component, which seems to behave well\n// when repeated, therefore being a good candidate for small tileable noise textures.\n//\n// Top    : Repeated (64x64) noise.\n// Bottom : Continuous, unbounded noise.\n//\n// Left   : Regular analytical noise.\n// Center : High-pass noise (of regular analytical noise).\n// Right  : Blue noise.\n//\n// TBD: Perhaps would be interesting to render the high-pass component of blue noise as well.\n\n// ------------------------------------------------------------------------- //\n\n// abstraction of the high-passed noise function\n// plug-in your custom RGB noise function\n#define RGB_NOISE_FUNCTION(uv) (randRGB(uv))\n\n// simulates tiling noise in a texture of size TILE_SIZE x TILE_SIZE\n#define TILE_SIZE (64)\n\n// thickness of split lines\n#define SPLIT_LINE_THICKNESS (4.0)\n\n// background gray color of Shadertoy web page\n#define TOY_BG_AVER_GRAY (209.0 / 255.0)\n\n// background gray color variation of Shadertoy web page\n#define TOY_BG_GRAY_VAR (0.1)\n\n// split coordinates\n#define H_SPLIT_A (0.5)\n#define V_SPLIT_A (0.333)\n#define V_SPLIT_B (0.666)\n\n// ------------------------------------------------------------------------- //\n\n// https://www.shadertoy.com/view/Md2cRt\nfloat rand(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575);\n}\n\nvec3 randRGB(vec2 uv) {\n    return vec3(\n        fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),\n        fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),\n        fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)\n    );\n}\n\n// ------------------------------------------------------------------------- //\n\nvec3 lowPassRandRGB(vec2 uv) {\n    // 3x3 convolution (average)\n    // can be implemented as separable with an extra buffer for a total of 6 samples instead of 9\n\n    vec3 result = vec3(0);\n\n    result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));\n    result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));\n    result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));\n\n    result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));\n    result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));\n    result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));\n\n    result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));\n    result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));\n    result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));\n\n    result *= 0.111111111; // 1.0 / 9.0\n\n    return result;\n}\n\nvec3 highPassRandRGB(vec2 uv) {\n    // by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal\n    // hp(x) = x - lp(x)\n    return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;\n}\n\n// ------------------------------------------------------------------------- //\n\nvec4 floatToColor(float value) {\n    return vec4(value, value, value, 1.0);\n}\n\n// ------------------------------------------------------------------------- //\n\nfloat getShaderToyBackgroundGray(vec2 screenSpaceUV) {\n    return TOY_BG_AVER_GRAY + (rand(screenSpaceUV) - 0.5) * TOY_BG_GRAY_VAR;\n}\n\n// ------------------------------------------------------------------------- //\n\nvec4 renderHSplitLine(vec4 fragColor, vec2 screenSpaceUV, float splitScreenSpaceY) {\n    if (abs(screenSpaceUV.y - splitScreenSpaceY) < SPLIT_LINE_THICKNESS) {\n        return floatToColor(getShaderToyBackgroundGray(screenSpaceUV));\n\t}\n\n    return fragColor;\n}\n\nvec4 renderVSplitLine(vec4 fragColor, vec2 screenSpaceUV, float splitScreenSpaceX) {\n    if (abs(screenSpaceUV.x - splitScreenSpaceX) < SPLIT_LINE_THICKNESS) {\n        return floatToColor(getShaderToyBackgroundGray(screenSpaceUV));\n\t}\n\n    return fragColor;\n}\n\n// ------------------------------------------------------------------------- //\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenSpaceUV = fragCoord.xy;\n    vec2 normalizedSpaceUV = screenSpaceUV / iResolution.xy;\n    vec2 repeatedScreenSpaceUV = mod(screenSpaceUV, vec2(TILE_SIZE));\n    vec3 rand = vec3(0);\n\n    if (normalizedSpaceUV.x < V_SPLIT_A) {\n        // analytical noise\n        if (normalizedSpaceUV.y < H_SPLIT_A) {\n            // continuous\n            rand = RGB_NOISE_FUNCTION(screenSpaceUV);\n        } else {\n            // repeated\n            rand = RGB_NOISE_FUNCTION(repeatedScreenSpaceUV);\n        }\n    } else {\n        if ((normalizedSpaceUV.x >= V_SPLIT_A) && (normalizedSpaceUV.x < V_SPLIT_B)) {\n            // high-pass analytical noise\n            if (normalizedSpaceUV.y < H_SPLIT_A) {\n                // continuous\n                rand = highPassRandRGB(screenSpaceUV);\n            } else {\n                // repeated\n                rand = highPassRandRGB(repeatedScreenSpaceUV);\n            }\n        } else {\n            // blue noise\n            if (normalizedSpaceUV.y < H_SPLIT_A) {\n                // continuous\n                rand = texelFetch(iChannel0, ivec2(screenSpaceUV) % 1024, 0).rgb;\n            } else {\n                // repeated\n                rand = texelFetch(iChannel0, ivec2(repeatedScreenSpaceUV) % 1024, 0).rgb;\n            }\n        }\n    }\n\n    // render output\n    fragColor = vec4(rand, 1.0);\n\n    // overlay the split lines\n    fragColor = renderHSplitLine(fragColor, screenSpaceUV, iResolution.y * H_SPLIT_A);\n    fragColor = renderVSplitLine(fragColor, screenSpaceUV, iResolution.x * V_SPLIT_A);\n    fragColor = renderVSplitLine(fragColor, screenSpaceUV, iResolution.x * V_SPLIT_B);\n}\n\n// ------------------------------------------------------------------------- //",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}