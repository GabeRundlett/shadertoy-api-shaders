{
    "Shader": {
        "info": {
            "date": "1567014102",
            "description": "A small fan art for a game that was just announced.\n\nIt's a bit heavy on branching.",
            "flags": 0,
            "hasliked": 0,
            "id": "WljXzy",
            "likes": 12,
            "name": "HMNKD",
            "published": 3,
            "tags": [
                "raymarching",
                "hex",
                "fanart"
            ],
            "usePreview": 0,
            "username": "antonOTI",
            "viewed": 629
        },
        "renderpass": [
            {
                "code": "//Shader by Anton.\n\n//#define SHADOW\n//#define CLOUDS\n\n#define PI 3.14159\n#define HPI 1.570796\n#define REP(p, r) (mod(p + r/2.,r) - r/ 2.)\n\n// smin by iq\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// hash and noise from shane's : https://www.shadertoy.com/view/ldscWH\nvec3 hash33(vec3 p) { \n\n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.;\n}\n\nfloat tetraNoise(in vec3 p)\n{\n    vec3 i = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    \n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n  \n    vec4 v = max(0.5 - vec4(dot(p,p), dot(p1,p1), dot(p2,p2), dot(p3,p3)), 0.0);\n    vec4 d = vec4(dot(p, hash33(i)), dot(p1, hash33(i + i1)), dot(p2, hash33(i + i2)), dot(p3, hash33(i + 1.)));\n    \n    return clamp(dot(d, v*v*v*8.)*1.732 + .5, 0., 1.); \n}\n\n\nmat2 mrn = mat2(0.8, -0.6, 0.6,0.8);\nfloat animatedNoise(vec2 p)\n{\n    p*= .25;\n    float t = iTime * .04;\n\tfloat h =0.;\n    float amp = 1.;\n    float freq = 1.;\n    for(float i = 1.; i < 4.; ++i)\n    {\n    \tamp *= .9; \n        freq *= 2.5;\n        h += sin(p.x * freq * .5) * amp;\n        p*= mrn;\n     \tp += t * (i-1.);\n        h+= sin(p.y * freq * .45) * amp;\n    }\n    \n    return h;\n}\n\n// Hexagonal Prism - exact by iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    \n    return c;\n}\nvec4 hexCoord(vec2 uv)\n{\n    vec2 r = vec2(1.,1.73);\n    vec2 h = r * .5;\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - h, r) - h;\n    \n    vec2 gv;\n    if(length(a) < length(b))\n    {\n        gv = a;\n    }\n    else\n    {\n        gv = b;\n    }\n    \n    vec2 id = uv - gv;\n    \n    return vec4(gv, id);\n}\n\nfloat getTileType(vec2 p)\n{\n    float id = floor(tetraNoise(p.xyy) * 4.);\n\n    id = min(id, 2.);\n    return id;\n}\n\nfloat sqLength(vec2 v)\n{\n    return dot(v,v);\n}\n\nfloat upCurve(float t)\n{\n    return sin(t * HPI);\n}\n\nfloat underCurve(float t)\n{\n    return 1. - upCurve(1. - t);\n}\n\nconst vec4 idDelta = vec4(1.,0.,-1.,0.);\nconst vec4 idDeltb = vec4(.5,.866,-.5,-.866);\n\nconst vec4 tileDelta = vec4(.5, 0., -.5, 0.);\nconst vec4 tileDeltb = vec4(.25,.433,-.25,-.433) ;\n\n#define FLOAT_EQ(a ,b) (abs(a-b) < .1)\n\n#define BPM (90. / 60.)\nfloat bpmTime(float t)\n{\n    float ft = fract(t);\n    return floor(t) + ft * ft;\n}\n\nconst float gridScale = 10.;\n\nint idMat = 0;\nvec2 mat = vec2(0.,0.);\nfloat morph;\n\nfloat travellingSpeed = ( BPM * 7.);\n\nfloat map(vec3 p)\n{\n    float basePlan = p.y + 1.;\n    float timeTraveling = iTime * travellingSpeed;\n    p.z += timeTraveling;\n    \n    \n    vec4 hg = hexCoord(p.xz / gridScale);\n    float tideTime = timeTraveling / gridScale + hash11(hg.z) * 2.35;\n    //tideTime = floor(tideTime);\n    float stepLength = 1. / .557 * .5;\n    //tideTime = bpmTime(tideTime / stepLength) * stepLength;\n    float ti = hg.w  - (tideTime) - .5;\n    float tide = max(0., ti) * 10.;\n    \n    morph = 1. - clamp(ti, 0., 1.);\n    \n    p.y /= upCurve(morph);\n    \n    \n    float baseHeight = p.y;\n    float hexHeight = smoothstep(hg.y - .0001, -.005, .005);\n    \n    float id = getTileType(hg.zw);\n    bool id_tl = FLOAT_EQ( id, getTileType(hg.zw + idDeltb.zy));\n    bool id_tr = FLOAT_EQ( id, getTileType(hg.zw + idDeltb.xy));\n    bool id_ml = FLOAT_EQ( id, getTileType(hg.zw + idDelta.zw));\n    bool id_mr = FLOAT_EQ( id, getTileType(hg.zw + idDelta.xy));\n    bool id_bl = FLOAT_EQ( id, getTileType(hg.zw + idDeltb.zw));\n    bool id_br = FLOAT_EQ( id, getTileType(hg.zw + idDeltb.xw));\n    \n    bool c_up = id_tl && id_tr;\n    bool c_tr = id_tr && id_mr;\n    bool c_br = id_mr && id_br;\n    bool c_do = id_br && id_bl;\n    bool c_bl = id_bl && id_ml;\n    bool c_tl = id_ml && id_tl;\n    \n    float innerRadius = 60.;\n    float innerSmoothFactor = 10.;\n    \n    float elevation = sqLength(hg.xy) * innerRadius;\n    \n    // top left\n    if(id_tl)\n    {\n        elevation = smin(elevation, sqLength(hg.xy + tileDeltb.xw) * innerRadius, innerSmoothFactor);\n    }\n    //top right\n    if(id_tr)\n    {\n        elevation = smin(elevation, sqLength(hg.xy + tileDeltb.zw) * innerRadius, innerSmoothFactor);\n    }\n    //middle_left\n    if(id_ml)\n    {\n        elevation = smin(elevation, sqLength(hg.xy + tileDelta.xy) * innerRadius, innerSmoothFactor);\n    }\n    //middle right\n    if(id_mr)\n    {\n        elevation = smin(elevation, sqLength(hg.xy + tileDelta.zw) * innerRadius, innerSmoothFactor);\n    }\n    //bottom left\n    if(id_bl)\n    {\n        elevation = smin(elevation, sqLength(hg.xy + tileDeltb.xy) * innerRadius, innerSmoothFactor);\n    }\n    //bottom right\n    if(id_br)\n    {\n        elevation = smin(elevation, sqLength(hg.xy + tileDeltb.zy) * innerRadius, innerSmoothFactor);\n    }\n\n    // up\n    if(c_up)\n    {\n        elevation = smin(elevation, sqLength(hg.xy - tileDelta.yx) * innerRadius, innerSmoothFactor);\n    }\n    // corner top right\n    if(c_tr)\n    {\n        elevation = smin(elevation, sqLength(hg.xy - tileDeltb.yx) * innerRadius, innerSmoothFactor);\n    }\n    // corner bottom right\n    if(c_br)\n    {\n        elevation = smin(elevation, sqLength(hg.xy - tileDeltb.yz) * innerRadius, innerSmoothFactor);\n    }\n    // corner bottom\n    if(c_do)\n    {\n        elevation = smin(elevation, sqLength(hg.xy - tileDelta.yz) * innerRadius, innerSmoothFactor);\n    }\n    // corner bottom left\n    if(c_bl)\n    {\n        elevation = smin(elevation, sqLength(hg.xy - tileDeltb.wz) * innerRadius, innerSmoothFactor);\n    }\n    // corner top left\n    if(c_tl)\n    {\n        elevation = smin(elevation, sqLength(hg.xy - tileDeltb.wx) * innerRadius, innerSmoothFactor);\n    }\n    \n    if(c_up && c_tr && c_br && c_do && c_bl && c_tl)\n    {\n        elevation -= pow((1.-sqLength(hg.xy * 1.8)) * 2.8,2.);\n    }\n    \n    idMat = 0;\n    if( FLOAT_EQ( id, 2.))\n    {\n        float max_depth = .3;\n        \n        \n        elevation = smin(elevation - 2.9, .0, 1.8);\n        elevation = -smin(-elevation, max_depth, .4);\n    \tidMat = 2;\n        mat.y = elevation;\n        \n        float wave = animatedNoise(p.xz);\n        wave = pow(wave, 2.) * .025;\n        elevation += wave * step(elevation, -.15);\n        p.y -= elevation;\n    }\n    \n    else if( FLOAT_EQ( id, 1.))\n    {\n        elevation = 2.- (elevation);\n        elevation = elevation * 5.;\n    \televation += tetraNoise(p.xzz * 5. / gridScale ) * 7.-3.5;\n        elevation = -smin(0.,-elevation, 15.);\n        \n        p.y -=  elevation *.15;\n        \n        idMat = 1;\n        mat.y = elevation;\n    }\n    \n    float dist = sdHexPrism(vec3(hg.yx * 10.5 , p.y*2. + 3.), vec2(5.)) -.25;\n    \n    if(basePlan < .01)\n    {\n        idMat = 3;\n    \tmat.xy = hg.xy;\n    }\n    \n    dist = min(dist, basePlan);\n    \n    return dist; \n}\n\nvec3 normal(vec3 p, float cd)\n{\n    vec2 e = vec2(0.,.1);\n    return normalize(vec3(\n    \tcd - map(p + e.yxx),\n    \tcd - map(p + e.xyx),\n    \tcd - map(p + e.xxy)\n    ));\n}\n\nvoid ray(in vec3 ro, in vec3 rd, out vec3 cp, out float st, out float cd, out float dist)\n{\n    dist = 0.;\n    for(; st < 1.; st += 1. /128.)\n    {\n        cp = ro + rd * dist; \n        cd = map(cp);\n        if(cd < .01)\n        {\n            break;\n        }\n        \n        dist += cd * st;\n    }\n}\n\nvec3 lookAt(vec3 target, vec3 cp, vec2 uv)\n{\n    vec3 fd = normalize(target - cp);\n    vec3 up = cross(fd, vec3(1.,0.,0.));\n    vec3 ri = cross(up, fd);\n    return normalize(fd + up * uv.y + ri * uv.x);\n}\n\n#define MOUSE (iMouse.x / iResolution.x)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - vec2(iResolution * .5))/iResolution.y;\n\t\n    vec3 tar = vec3(100.,0.,0.);\n    vec3 ro = tar + vec3(0.,12.,-20.);\n   \tvec3 rd = lookAt(tar, ro, uv);\n   \tvec3 cp;\n    float st, cd, dist;\n    \n    ray(ro, rd, cp, st, cd, dist);\n    int selectedMat = idMat;\n    vec2 material = mat;\n    float mo = morph;\n\n    vec3 backCol = vec3(.3,.3,.7);\n    vec3 col;\n    if(cd < .01)\n    {\n        vec3 norm = normal(cp, cd);\n        vec3 ld = normalize(vec3(-14.,-6.,2.));\n        float li = clamp(dot(ld, norm),0.,1.);\n\t\t\n        vec3 plainColor = vec3(.075,.09,.001);\n        vec3 rockColor = vec3(.04,.02,.035);\n        vec3 snowColor = vec3(.6);\n        vec3 waterColor =vec3(.003,.0046,.094);\n        \n        vec3 tileColor = plainColor;\n        \n        if(selectedMat == 1)\n        {\n            vec3 bottomColor = tileColor;\n            \n            float elevation = clamp(material.y / 40., 0. ,1.) ;\n            //elevation\n            \n            float rockFactor = smoothstep(-.025,.025, elevation - .015);\n            tileColor = mix(tileColor,rockColor, rockFactor);\n            \n            elevation += norm.y*.25 ;\n\t\t\tfloat snowFactor = smoothstep(-.1, .1, elevation-.125);\n            snowFactor -= .35 - abs(norm.y) * .2;\n            \n            snowFactor = clamp(snowFactor, 0., 1.) * .5;\n            tileColor += vec3(.5,.5,.45) * snowFactor;\n        }\n        else if(selectedMat == 2)\n        {\n            float depth = clamp(-material.y* 50., .0, 1.);\n            tileColor = mix(tileColor, waterColor, depth);\n        }\n        \n#ifdef SHADOW\n        vec3 ncp;\n        cd = st = 0.;\n        float ndist;\n\t\tray(cp - ld * .05, - ld, ncp, cd,st, ndist);        \n        if(cd < 1.)\n        {\n        \ttileColor *= .7;\n        }\n        else\n        {\n      \t\ttileColor +=  vec3(.810,.800,.620) * li * .125;\n        }\n\n#else\n\t\ttileColor +=  vec3(.810,.800,.620) * li * .125;\n#endif\n        \n        col = mix(backCol, tileColor, underCurve(mo));\n        \n    }\n    else\n    {\n        col = backCol;\n    }\n    \n    if(selectedMat == 3)\n    {\n        float grid = hexDist(material.xy * 2.);\n        grid = 1. - smoothstep(-.05,.02,grid - .94);\n        col = mix(backCol * 1.5, backCol*1.2, grid);\n    }\n    \n#ifdef CLOUDS\n    // 2D cloud experiment\n\tvec2 shiftedPosition = cp.xz + vec2(0.,iTime * travellingSpeed);\n    col -= upCurve((animatedNoise(shiftedPosition * .25) + 1.) * .02);\n#endif\n    \n    // fog\n\tcol = mix(backCol, col, exp(min(-dist * .05 +2.5,0.)));\n    \n    // color grading\n    col = col*vec3(1.15,1.29,.9) * 1.3;\n\n    \n    // compress        \n    // col = 1.35*col/(1.0+col);\n        \n    \n    // gama correction\n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}