{
    "Shader": {
        "info": {
            "date": "1424137102",
            "description": "ray trace sphere 3d procedural texture",
            "flags": 0,
            "hasliked": 0,
            "id": "4tX3zl",
            "likes": 1,
            "name": "Ethereal sphere",
            "published": 3,
            "tags": [
                "3d",
                "raytracing"
            ],
            "usePreview": 0,
            "username": "rcread",
            "viewed": 167
        },
        "renderpass": [
            {
                "code": "// Created by randy read - rcread/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define N normalize\n\nfloat t;\nmat3 mm;\n\nfloat s( float b ) { return abs( b / 2. - mod( t, b ) ); }\n\nvec3 sphere( vec3 ro, vec3 rd, vec3 center, float radius ) {\n    vec3 color;\n\tfloat t\t\t\t\t= dot( center - ro, rd );\t\t//\tdistance from ray origin to nearest point to center along ray\n    if ( t < 0. ) vec3( 0. );\n\tvec3 ip\t\t\t\t= ro + t * rd;\t\t\t\t\t//\tnearest point to center along ray\n    float perp_dist\t\t= length( center - ip );\t\t//\tperpendicular distance from ray to center\n\tfloat pixel_size\t= t / iResolution.y;\t\t\t//\tpixel size at intersect point\n\tfloat alpha\t\t\t= 1. - clamp( ( perp_dist - radius ) / pixel_size, 0., 1. );\t//\talpha for antialiasing\n\tif ( alpha < 0.001 ) return vec3( 0. );\n\tif ( perp_dist < radius ) {\n\t\tt\t\t\t\t-= sqrt( radius * radius - perp_dist * perp_dist );\t\t\t\t//\tdistance from ray origin to near ray sphere intersect by pythagorean\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t//\tmust leave t alone in antialias zone\n\tip\t\t\t\t\t= ro + t * rd;\t\t\t\t\t//\tnear intersect point\n\tcolor\t\t\t\t= N( mm * ip );\t\t\t\t\t//\tcolor at edge\n\treturn mix( vec3( 0 ), color, alpha );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tt\t\t\t\t\t= iTime * 5.;\n\tmm\t\t\t\t\t= mat3( s(2.), s(17.), s(23.), s(11.), s(13.), s(7.), s(19.), s(3.), s(5.) );\n    vec2 p\t\t\t\t= ( fragCoord.xy - iResolution.xy / 2. ) / iResolution.y;\n    vec3 v\t\t\t\t= vec3( -1., 0., 1. );\n\tvec3 ro\t\t\t\t= vec3( 0., 0., 2.3 );\n    vec3 rd \t\t\t= N( v.yyx + p.x * v.xyy + p.y * v.yzy );\n    fragColor.rgb = sphere( ro, rd, v.yyy, 1. );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}