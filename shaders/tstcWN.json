{
    "Shader": {
        "info": {
            "date": "1600981646",
            "description": "cf [url]https://horizonofreason.com/culture/vanuatu-sand-drawings-sandroing/[/url]\nref:\n[img]https://horizonofreason.com/images/sandroings/deacon.jpg[/img]",
            "flags": 0,
            "hasliked": 0,
            "id": "tstcWN",
            "likes": 12,
            "name": "vanuatu sand drawing: turtle",
            "published": 3,
            "tags": [
                "turtle",
                "ethnomathematics"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 385
        },
        "renderpass": [
            {
                "code": "#define SQR(x)  ( (x)*(x) )\n#define rot(a)    mat2(cos(a+vec4(0,11,33,0)))   \n#define C0(U,v,h) max(0., 1. - abs( length( U ) - v ) *h )\n#define C(X,Y)    C0( U - vec2(X,Y) , .7 , h )\n\nfloat line(vec2 p, vec2 a,vec2 b) { // https://www.shadertoy.com/view/llySRh\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, V,\n         U = 4.* ( 2.*u - R ) /R.y; U.y-= .5;\n    float h = R.y/12., l = 1e5;\n    O-=O;\n                                                                // --- all circles + arcs\n#  define C4(X)    C(X,.5) + C(X,1.5) + C(X,-.5) + C(X,-1.5)    // column of 4 circles\n    O += C4(.5) + C4(-.5);\n    U.x = abs(U.x);\n    if ( abs(U.y) < 2.) O += C(.5,2.5) + C(.5,-2.5);\n    if (U.x<1.) O += C4(1.5);\n    \n                                                                // lemniscate\n#   define L(Y) if (U.x>1.) V = U-vec2(1,Y), V *= V*3., V.y*=2.,  l = min(l, .1*sqrt(abs((V.x+V.y)*(V.x+V.y)-(V.x-V.y))) -.005 )\n    for (float j,i=-2.; i<2.; i++) {                            // --- lines + small loops\n        l = min(l, line(U, vec2(0, i ), vec2(1.5,1.5+i)) ),\n        j = i == -1. ? 2. : i==-2. ? 0. : i,\n        l = min(l, line(U, vec2(0, j ), vec2(1.5,-1.5+j)) );\n        L(i);\n    }\n    l = min(l, line(U, vec2(.5,-2.5), vec2(1.5,-1.5)) );\n    l = min(l, line(U, vec2( 1, 2  ), vec2(1.5, 1.5)) );\n    l = min(l, line(U, vec2( 0,-2  ), vec2( .5,-2.5)) );\n    l = min(l, line(U, vec2( 0,-1  ), vec2(1.2,-2.2)) );\n    L(2);\n                                                                // --- head and tail: Bernouilli lemniscate\n    if (U.y<-2.) V = SQR( U-vec2(0,-2) )*3., V.x*=2.,  l = min(l, .1*sqrt(abs(SQR(V.x+V.y)-(V.y-V.x))) -.005 );\n    if (U.y> 2.) V = SQR( U-vec2(0, 2) )*.7, V.x*=2.,  l = min(l, .1*sqrt(abs(SQR(V.x+V.y)-(V.y-V.x))) -.005 );\n\n    O += max(0., 1. - l * h);\n                                                                // --- shell: Joukovsky airfoil\n    if ( U.y <-2.  ) O += C0( ( U - vec2(0,-2.4) )*vec2(1,1.7), 1.2 , h/1.3 );\n    if ( U.y < 2.5 ) O += C0( ( U * vec2(1.5,1)  )            , 3.4 , h/1.5 );\n    O += Joukowsky((U-vec2(2.1, 1.2))*rot(-.3) *vec2(-1.7,1.7), vec2(-.1,.7), 1.5) / h/3.; // --- fins\n    O += Joukowsky((U-vec2(1.3,-3.2))*rot(-1.) *vec2(-2,2)    , vec2(-.1,.7), 1.5) / h/3.; \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Joukowsky inverse transform : cf https://www.shadertoy.com/view/wdtyDM\n\n// complex ops: https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n#define CS(a)        vec2( cos(a), sin(a) )\n#define cart2pol(U)  vec2( length(U), atan((U).y,(U).x) )\n#define pol2cart(U) ( (U).x * CS( (U).y ) )\n#define cmod(Z)     length(Z)\n#define carg(Z)     atan( (Z).y, (Z).x )\n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) )  // by deMoivre formula\n#define cinv(Z)   ( vec2( (Z).x, -(Z).y ) / dot(Z,Z) ) \n#define cpow(Z,v)   pol2cart( vec2( pow(cmod(Z),v) , (v) * carg(Z) ) )\n//#define cpow(A,B)   cexp( cmul( B, clog(A) ) )\n#define cexp(Z)     pol2cart( vec2( exp((Z).x), (Z).y ) )\n#define clog(Z)     vec2( log(cmod(Z)), carg(Z) )\n\n#define sat(x) clamp(x,0.,1.)\n\nfloat Joukowsky(vec2 U, vec2 C, float r) {\n    vec2 V1 = .5*( U + cpow( cmul(U,U) - 4., .5) ), // zÂ² - Z.z + 1 = 0 (  Z = z + 1/z )\n         V2 = U - V1;           \n    return   1./abs( max( length(C-V1), length(C-V2) ) - r );\n        //   1./abs(length(C-V1)-r) \n        // + 1./abs(length(C-V2)-r);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}