{
    "Shader": {
        "info": {
            "date": "1662833840",
            "description": "absolute simplest raymarching program for educational purposes, with no additional features besides basic optimizations.\nSee https://www.shadertoy.com/view/dtjSDy for a golfed version.",
            "flags": 0,
            "hasliked": 0,
            "id": "NltfzM",
            "likes": 2,
            "name": "Simplest Raymarching",
            "published": 3,
            "tags": [
                "raymarching",
                "basic",
                "tutorial"
            ],
            "usePreview": 0,
            "username": "01000001",
            "viewed": 152
        },
        "renderpass": [
            {
                "code": "int maxSteps = 200;\n//max steps the loop will take.  try setting this really low, like 2 steps.\nfloat maxDepth = 10.0;\n//camera far plane pretty much.  See line 42.  This is usually around 500\n//but for this example we can make it tiny to boost performance.\nfloat minDist = 0.001;\n//distance from a surface at which the ray stops\n\nfloat DF(vec3 p)\n{\n    return length(p)-1.0;\n    //this is the distance function of a sphere.  Finds the distance to the centre,\n    //then subtracts the radius of the sphere\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y*2.0;\n    //default UVs are fragCoord/iResolution.xy, which gives 0-1 coords from left to right and bottom to top.\n    //Non-default UVs.  Cartesian coordinates instead, (0,0) is the centre of the screen\n    \n    float depth = 0.0;\n    //how far along the ray is currently\n    vec3 o = vec3(0, -2, 0);\n    //origin point of the rays.  Camera position.\n    vec3 dirV = vec3(uv.x, 1.0, uv.y);\n    //Directional vector.  Added to the origin vector, to get a point in space offset from the camera\n    //You may want to normalize this vector to avoid future issues.\n    \n    for (int i = 0; i < maxSteps; i++)\n    {\n        vec3 p = o + dirV * depth;\n        //This is a ray.  \n        //p is a point in space of a ray going in direction dirV, starting from o, with a length of depth\n        float d = DF(p);\n        //finding the scene distance function\n        \n        depth += d;\n        //now we step forward by the minimum distance to the scene\n        \n        if (depth > maxDepth)\n        //Effectively camera far plane.  It's not completely necessary but it provides \n        //a performance boost and prevents random noise in the sky\n        {\n            depth = maxDepth; // this prevents random noise in the sky\n            break;\n        }\n        \n        if (d < minDist)\n        //Stop the ray once it hits something.  Important for performance to stop the ray from\n        //digging into a surface after it's close enough.  Sub pixel precision can almost always be discarded\n        //and in fact, removing sub pixel precision tends to reduce noise in complex geometry.\n        {\n            break;\n        }\n    }\n    \n    //screen output\n    fragColor = vec4(vec3(depth*2.0-2.0 /*bit of math that shifts the depth \n    to go from 0-1 from the front to the edge of the sphere.*/),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}