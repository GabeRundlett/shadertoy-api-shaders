{
    "Shader": {
        "info": {
            "date": "1674286643",
            "description": "practice shader made while going through thebookofshaders.com",
            "flags": 0,
            "hasliked": 0,
            "id": "ddB3Rw",
            "likes": 0,
            "name": "2.01-ShapingFunctions",
            "published": 3,
            "tags": [
                "thebookofshaders"
            ],
            "usePreview": 0,
            "username": "retonym",
            "viewed": 145
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n\nfloat plot(vec2 uv, float line)\n{\n    //takes a vector 2 and uses it to plot a line\n    //that reflects an externally-applied mathematical relationship between x and y.\n    \n    return smoothstep(line - 0.02, line, uv.y) - \n           smoothstep(line, line + 0.02, uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= (iResolution.x/iResolution.y);//2.0;\n    uv.x -= .85;\n    uv *= 1.2;\n    \n    //BASIC CURVES\n    //float y = pow(uv.x, 5.0);\n    //float y = exp(-5.0 * uv.x);\n    //float y = log(uv.x * PI); \n    //float y = sqrt(uv.x * 1.0); \n    \n    //STEPS\n    //float y = step(0.5, uv.x);\n    //float y = smoothstep(0.1, 0.9, uv.x);\n\n    //SIN AND COS\n    //sin and cos are handy, they give you nice, neat, 0-1, x and y values of points on the outer edge of a circle, based on the degree!\n    //float y = sin(uv.x * PI);\n    //float y = cos(uv.x * PI) * .5 + .5;\n    \n    \n    //INIGO QUILEZ SHAPER FUNCTIONS\n    //float y = exp(-10.0 * pow(uv.x, 2.0));  //\"Impulse\" -- change the last value to change the 'mouth' of the slide\n    \n    \n    \n    \n    \n    //HOMEWORK TIME! replicate the shapes in this image: \n    //https://thebookofshaders.com/05/kynd.png\n    //try to hide the formulas and figure out first before just copying!\n    \n    float y = uv.x;\n    \n    //ROW 1\n    float a = 0.5;\n    //y = 1.0 - pow(abs(uv.x), a);\n    \n    //ROW 2\n    //NOTE THE DIFFERENCE between these 2:\n    //y = sin(uv.x);\n    //y = pow(sin(uv.x), .5);  \n    //you can add get a quarter circle lookin curve by raising cos/sin x to the power of .5!\n    //pow adds a horizontal bulge-out/suck-in effect.\n    float b = 0.5;\n    //y = pow(cos(uv.x * .5 * PI), b);\n    \n    //ROW 3\n    float c = 1.5;\n    //y = 1.0 - pow(abs(sin((uv.x) * .5 * PI)), c);\n    \n    //ROW 4\n    float d = 0.5;\n    //i think i stumbled onto a shorter version of this formula than on the kynd sheet?\n    //y = pow(1.0 - abs(uv.x), d);\n    \n    //ROW 5\n    float e = 3.5;\n    //y = 1.0 - max(0.01, pow(uv.x * 2.0 + .2f, e));\n    //y *= .5f;\n\n    //Inigo Quilez impulse:\n    float k = 8.0f;\n    float h = k * (uv.x + .05f);\n    y = h * exp(1.0f - h);\n\n    \n    float line = plot(uv, y);\n    \n    float gradientY = step(uv.x, 0.0f);\n    vec3 gradientColor = vec3(gradientY);\n    vec3 lineColor = vec3(0.0, 1.0, 0.0);\n    vec3 color = ((1.0 - line) * gradientColor) + (line * lineColor);\n\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}