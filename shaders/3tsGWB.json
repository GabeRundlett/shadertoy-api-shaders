{
    "Shader": {
        "info": {
            "date": "1557495717",
            "description": "Don't judge the code, i did it a while ago :p",
            "flags": 0,
            "hasliked": 0,
            "id": "3tsGWB",
            "likes": 7,
            "name": "Snake Donut",
            "published": 3,
            "tags": [
                "raymarching",
                "bezier",
                "donut"
            ],
            "usePreview": 0,
            "username": "z0rg",
            "viewed": 307
        },
        "renderpass": [
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat minDotSize = 0.005;\nfloat maxDotSize = 0.01;\nfloat dotSpacing = 0.02;\nint marchSteps = 64;\nfloat marchDist = 12.0;\nconst int bezierSphCnt = 15;\nvec3 bezierCol = vec3(0.978, 0.13, 0.57);\n\nfloat EPS = 0.0001;\n\nstruct bezier\n{\n  vec3 p0;\n  vec3 p1;\n  vec3 p2;\n  vec3 p3;\n};\nfloat sat(float a)\n{\n    return clamp(a, 0.0,1.0);\n}\nvec3 sat(vec3 v)\n{\n    return vec3(sat(v.x), sat(v.y), sat(v.z));\n}\n    \nvec2 rot(vec2 v, float a)\n{\n    float cosa=cos(a);float sina=sin(a);\n    mat2 r=mat2(cosa,-sina,sina,cosa);\n    return v*r;\n}\n\nvec3 calculateBezierPoint(bezier bz, float t)\n{\n  float oneMt = 1.0 - t;\n\n  return bz.p0 * pow(oneMt,3.0) +\n     3.0 *bz.p1*t*pow(oneMt,2.0) +\n       3.0*bz.p2*t*t*oneMt +\n         bz.p3*t*t*t;\n}\n\nfloat sdf_sphere(vec3 p, vec3 orig, float rad)\n{\n  return distance(p, orig) - rad;\n}\n\nfloat sdf_torus(vec3 p, vec3 orig, vec2 size)\n{\n  vec3 pt = p-orig;\n  vec2 q = vec2(length(pt.xz)-size.x,pt.y);\n  return length(q)-size.y;\n}\n\nfloat sdf_union(float d1, float d2)\n{\n  return min(d1,d2);\n}\n\nvec3 sdf_torus_normal(vec3 p, vec3 o, vec2 s)\n{\n  vec3 xeps = vec3(EPS, 0.0, 0.0);\n  vec3 yeps = vec3(0.0, EPS, 0.0);\n  vec3 zeps = vec3(0.0, 0.0, EPS);\n  vec3 n = vec3(sdf_torus(p+xeps, o, s) - sdf_torus(p-xeps, o, s),\n    sdf_torus(p+yeps, o, s) - sdf_torus(p - yeps, o, s),\n    sdf_torus(p+zeps, o, s) - sdf_torus(p- zeps, o, s));\n  return normalize(n);\n}\n\n\nvec2 render(vec2 uv, vec3 orig, vec3 dir)\n{\n  float gradient = clamp(0.0,1.0, sin(uv.y));\n  vec3 p = orig;\n\nvec3 light = vec3(5.0*sin(iTime), 5.0*cos(iTime),0.0);\n  int step = 0;\n  float totalDist = 0.0;\n  while (step < marchSteps && totalDist < marchDist)\n  {\n    float d = sdf_torus(p, vec3(0.0), vec2(2.0, 1.0));\n    //float d = sdf_sphere(p, vec3(0.0), 2.0);\n    if (d < EPS)\n    {\n      vec3 n = sdf_torus_normal(p, vec3(0.0), vec2(2.0, 1.0));\n      return vec2(dot(n, p-light)*0.2 + 0.2,totalDist+d);\n    }\n    p += dir * d;\n    step++;\n    totalDist += d;\n  }\n\n  return vec2(gradient,0.0);\n}\n\nvec4 renderAsDot(vec2 uv, vec2 center, float angle, vec3 orig, vec3 vec)\n{\n  float cosA = cos(angle);\n  float sinA = sin(angle);\n  mat2 rot = mat2(cosA, -sinA, sinA, cosA);\n  uv -= center;\n  vec2 rdrV = render(uv, orig, vec);\n  float curSize = mix(minDotSize, maxDotSize, rdrV.x);\n  uv = uv * rot;\n  vec2 uvMod = mod(uv, dotSpacing);\n  float size = minDotSize;\n  return vec4(sat(vec3(-(length(uvMod-(dotSpacing/2.0))-curSize)/size)*5.),rdrV.y);\n}\n\nvec4 renderBezier(vec2 uv, vec3 orig, vec3 dir)\n{\n  bezier bz;\n  vec3 bezierPts[bezierSphCnt];\n  float distSph[bezierSphCnt];\n  vec3 p = orig;\n  vec3 off = vec3(2.0,0.0,0.0);\n  float cosA = cos(-0.3);\n  float sinA = sin(-0.3);\n  float exce = 1.9;\n  mat2 rot = mat2(cosA, -sinA, sinA, cosA);\n  bz.p0 = off + vec3(sin(iTime), cos(iTime), 0.0)*exce;\n  bz.p1 = off + vec3(sin(iTime+1.0), cos(iTime+1.0), 0.0)*exce;\n  bz.p2 = off + vec3(sin(iTime+2.0), cos(iTime+2.0), 0.0)*exce;\n  bz.p3 = off + vec3(sin(iTime+3.0), cos(iTime+3.0), 0.0)*exce;\n\n  vec2 p02 = bz.p0.xz * rot;\n  vec2 p12 = bz.p1.xz * rot;\n  bz.p0 = vec3(p02.x, bz.p0.y, p02.y);\n  for (int iBz = 0; iBz < bezierSphCnt; ++iBz)\n    bezierPts[iBz] = calculateBezierPoint(bz, float(iBz) / float(bezierSphCnt));\n\n  int step = 0;\n  float totalDist = 0.0;\n  while (step < marchSteps && totalDist < marchDist)\n  {\n    float nearest = -1.0;\n    int idxHit = -1;\n    for (int iBz = 0; iBz < bezierSphCnt; ++iBz)\n    {\n      float d = sdf_sphere(p, bezierPts[iBz], 0.2);\n      if (idxHit == -1 || (d < nearest))\n      {\n        nearest = d;\n        idxHit = iBz;\n      }\n    }\n    if (nearest < EPS)\n    {\n    //  vec3 n = sdf_torus_normal(p, vec3(0.0), vec2(2.0, 1.0));\n      return vec4(bezierCol,totalDist+nearest);//dot(n, p-light)*0.2 + 0.2;\n    }\n    p += dir * nearest;\n    step++;\n    totalDist += nearest;\n  }\n  return vec4(0.0);\n}\n\nvec3 renderAnim(vec2 uv, vec2 center, vec3 orig, vec3 vec)\n{\n  float theta = 3.1415927 * sin(0.1*iTime);\n  float way = (sin(iTime)-sin(iTime+0.1))*0.1;\n  vec4 outCol = renderAsDot(uv,center,theta, orig, vec);\n    \n  vec4 bzCol = renderBezier(uv - center, orig, vec);\n  if (outCol.w < EPS)\n    return bzCol.xyz;\n  if(bzCol.w < EPS || outCol.w < bzCol.w)\n     return outCol.xyz;\n  return bzCol.xyz;\n}\n\nvec3 negate(vec3 c)\n{\n  return vec3(1.0) - c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  float ratio = iResolution.x/iResolution.y;\n  uv = vec2(uv.x * ratio, uv.y);\n\n\n  vec3 origin =vec3(0.0, 10.0, 0.0);\n  vec3 vec = vec3(1.0, 0.0, 0.0);\n  vec3 rightVec = vec3(0.0,0.0,-1.0);\n  vec3 upVec = vec3(0.0,1.0,0.0);\n\n  float yaw = 3.1415927/2.0;\n  float pitch = 0.0;\n\n  float cosYaw = cos(yaw);\n  float sinYaw = sin(yaw);\n  float cosPitch = cos(pitch);\n  float sinPitch = sin(pitch);\n\n  mat3 rotY = mat3(cosPitch,  0.0, sinPitch,\n                   0.0, 1.0, 0.0,\n                   -sinPitch,  0.0, cosPitch);\n  mat3 rotZ = mat3(cosYaw, -sinYaw, 0.0,\n                   sinYaw, cosYaw, 0.0,\n                   0.0,  0.0, 1.0);\n  vec2 center = vec2(0.5*ratio, 0.5);\n  vec2 cuv = uv -center;\n    cuv *= sin(iTime)*0.5+1.;\n    cuv = rot(cuv, -iTime*0.5);\n  vec = rotZ * (rotY * (vec + rightVec * cuv.x + upVec * cuv.y));\n  vec = normalize(vec);\n\n    \n  vec3 col = renderAnim(uv,center, origin, vec);\n    col += vec3(0.22,0.12,0.42)*pow(1.-length(cuv),0.5);\n  fragColor = vec4((col), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}