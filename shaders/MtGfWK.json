{
    "Shader": {
        "info": {
            "date": "1544045371",
            "description": "Experimenting dFdx() and fwidth() on map gen",
            "flags": 0,
            "hasliked": 0,
            "id": "MtGfWK",
            "likes": 45,
            "name": "dFdx terrain gen",
            "published": 3,
            "tags": [
                "noise",
                "fbm",
                "dfdx",
                "fwidth"
            ],
            "usePreview": 0,
            "username": "ocb",
            "viewed": 1591
        },
        "renderpass": [
            {
                "code": "// Author: ocb\n\n/*****************************************************************************/\n/* dFdx Terrain Gen\n/* First try to use dFdx() and fwidth()\n/* dFdx/dFdy is used to find local normal on a value noise.\n/* fwidth() is used as an indicator of slope (ex. to avoid forest or snow on steep slope\n/*****************************************************************************/\n\n\n#define R iResolution\n#define STEP 9.\n\nfloat H2(in vec2 st) { \t\t\t\t\t\t\n    return fract(sin(dot(st,vec2(12.9898,8.233))) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ti = iTime*.2;\n    vec2 uv = (2.*fragCoord-R.xy)/R.y;\n    uv.y += ti+2.;\n    float h = 0., hsea = 0.;\n    vec3 col = vec3(.5);\n    vec3 lit = normalize(vec3(.5,.0,1.));\n    \n\tfloat a = 1., Hz = 1., m = 1.;\t\t\t\t\t// fbm\n    vec2 d = vec2(1.,0.);\n    for(float i=1.;i<=STEP; i++){\n        vec2 e = floor(uv*Hz), f = fract(uv*Hz);\n        f = smoothstep(0.,1.,f);\n        h += mix(\n            \tmix(H2(e),H2(e+d.xy),f.x)*a,\n            \tmix(H2(e+d.yx),H2(e+d.xx),f.x)*a,\n            \tf.y);\n        \n        a *= .3+.1*h+.015*i;\n        //a *= .5;\n        Hz *= 2.;\n        m += a;\n        \n        hsea += .1*h;\t\t// kind of integrated h to smooth the sea bottom\n    }\n    h/=m;\n    h = h-.5;\n    \n    \n\n    float below = step(h,0.), above = 1.-below;\t\t// above and below sea level\n    float fwdh = R.x*fwidth(h);\t\t// fwidth is used to reduce or avoid snow or trees on steep slope\n\n    col.b += .4*below;\t\t\t\t\t\t\t\t// sea water\n    col.g += .6*smoothstep(.4,.8,hsea)*below;\n        \n    col += vec3(smoothstep(.2,.4-.02*fwdh,h));\t\t// snow\n    \n    col -= vec3(.3-h,.25,.35)*(1.-smoothstep(.1,.2,h))*above*(1.-smoothstep(1.,6.,(h*h+.9)*fwdh));\t// forest\n\n    float dx= R.x*dFdx(h)*above + R.x*dFdx(hsea)*below;\t\t\t// derivatives\n    float dy= R.y*dFdy(h)*above + R.y*dFdy(hsea)*below;\n    vec3 n = normalize(cross(vec3(1.,dx,0.),vec3(0.,dy,1.)));\t// local normal\n    float shad = (.5+.5*dot(n,-lit));\t\t\t\t\t\t\t// shadowing\n    col *= shad*smoothstep(-.3,.0,h)*(.2+.8*above);\n    col += vec3(.2,.15,.0)*(shad-.5)*above;\t\t\t\t// warmer the light on the sunny side \n\n    col += .03*max(0.,-dx)*fwdh*below*smoothstep(-.02,0.,h)*shad;\t// wave foam along coast\n    \n\tfragColor = vec4(1.7*col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}