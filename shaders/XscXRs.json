{
    "Shader": {
        "info": {
            "date": "1460756607",
            "description": "Move mouse with click to move the sun, I love this noise functions and things that can be done with it",
            "flags": 0,
            "hasliked": 0,
            "id": "XscXRs",
            "likes": 36,
            "name": "Clouds with shadow",
            "published": 3,
            "tags": [
                "procedural",
                "clouds",
                "sky"
            ],
            "usePreview": 0,
            "username": "afl_ext",
            "viewed": 2763
        },
        "renderpass": [
            {
                "code": "// afl_ext 2016\n\n#define HOW_CLOUDY 0.4\n#define SHADOW_THRESHOLD 0.2\n#define SHADOW 0.2\n#define SUBSURFACE 1.0\n#define WIND_DIRECTION 2.0\n#define TIME_SCALE 0.7\n#define SCALE 0.5\n#define ENABLE_SHAFTS\n\nmat2 RM = mat2(cos(WIND_DIRECTION), -sin(WIND_DIRECTION), sin(WIND_DIRECTION), cos(WIND_DIRECTION));\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nfloat hash( float n )\n{\n    return fract(sin(n)*758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x); \n    float n = p.x + p.y*57.0 + p.z*800.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t    mix(mix( hash(n+800.0), hash(n+801.0),f.x), mix( hash(n+857.0), hash(n+858.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = p*2.02;\n    f -= 0.25000*noise( p ); p = p*2.03;\n    f += 0.12500*noise( p ); p = p*3.01;\n    f += 0.06250*noise( p ); p = p*3.04;\n    f += 0.03500*noise( p ); p = p*4.01;\n    f += 0.01250*noise( p ); p = p*4.04;\n    f -= 0.00125*noise( p );\n    return f/0.984375;\n}\n\nfloat cloud(vec3 p)\n{\n\tp-=fbm(vec3(p.x,p.y,0.0)*0.5)*1.25;\n\tfloat a = min((fbm(p*3.0)*2.2-1.1), 0.0);\n\treturn a*a;\n}\n\nfloat shadow = 1.0;\n\n\nfloat clouds(vec2 p){\n\tfloat ic = cloud(vec3(p * 2.0, iTime*0.01 * TIME_SCALE)) / HOW_CLOUDY;\n\tfloat init = smoothstep(0.1, 1.0, ic) * 10.0;\n\tshadow = smoothstep(0.0, SHADOW_THRESHOLD, ic) * SHADOW + (1.0 - SHADOW);\n\tinit = (init * cloud(vec3(p * (6.0), iTime*0.01 * TIME_SCALE)) * ic);\n\tinit = (init * (cloud(vec3(p * (11.0), iTime*0.01 * TIME_SCALE))*0.5 + 0.4) * init);\n\treturn min(1.0, init);\n}\nfloat cloudslowres(vec2 p){\n\tfloat ic = 1.0 - cloud(vec3(p * 2.0, iTime*0.01 * TIME_SCALE)) / HOW_CLOUDY;\n\tfloat init = smoothstep(0.1, 1.0, ic) * 1.0;\n\treturn min(5.0, init);\n}\n\nvec2 ratio = vec2(1.0, 1.0);\n\nvec3 getresult(){\n\tvec2 surfacePosition = ((( gl_FragCoord.xy / iResolution.xy ) * vec2(iResolution.x / iResolution.y, 1.0)) * 2.0 - 1.0)*SCALE;\n\tvec2 position = RM*( surfacePosition);\n\tvec2 sun = RM * ((iMouse.xy/ iResolution.xy)* vec2(iResolution.x / iResolution.y, 1.0)*2.0-1.0) * SCALE;\n\tfloat dst = distance(sun * ratio, position * ratio);\n\tfloat suni = pow(dst + 1.0, -10.0);\n\tfloat shaft =0.0;\n\tfloat st = 1.0;\n\tvec2 dir = sun - position;\n\tfloat c = clouds(position);\n\t#ifdef ENABLE_SHAFTS\n\tfor(int i=0;i<20;i++){\n\t\tfloat occl = cloudslowres(position + dir * st);\n\t\tst *= 0.8;\n\t\tshaft += max(0.0, (1.0 - occl));\n\t}\n\t#endif\n    shadow = min(1.0, shadow + suni * suni * 0.2 * SUBSURFACE);\n\tsuni *= (shaft * 0.1);\n\treturn pow(mix(vec3(shadow), pow(vec3(0.23, 0.33, 0.48), vec3(2.2)) + suni, c), vec3(1.0/2.2));\t\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = getresult().xyzz;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}