{
    "Shader": {
        "info": {
            "date": "1457437258",
            "description": "Surace waves; see source for details (mousing enabled).",
            "flags": 32,
            "hasliked": 0,
            "id": "MdtSzn",
            "likes": 28,
            "name": "Wave Tank",
            "published": 3,
            "tags": [
                "waves",
                "interference",
                "diffraction"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 1598
        },
        "renderpass": [
            {
                "code": "// \"Wave Tank\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  The underlying model is a square array of vertically oscillating masses\n  coupled to their neighbors by simple springs (for small oscillations the\n  forces depend only on height difference). The surface is based on\n  (nonplanar) quadrilaterals with vertices at the mass positions, and the\n  normals are interpolated so that it appears smooth. Surface waves are driven\n  by inputs at one or more narrow slits, and are damped near the boundaries to\n  reduce reflection. Diffraction and interference effects are demonstrated.\n\n  Restarts with different number of slits when waves reach far end.\n*/\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float pi = 3.14159;\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec3 ltDir;\nvec2 gHit;\nfloat txRow, tCur, dstFar, gSizef, nSlit;\nint idObj, gSize, igHit;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nfloat SurfHt (vec2 p)\n{\n  vec2 cg;\n  float h;\n  gHit = (p + 0.5) * (gSizef - 1.);\n  cg = floor (gHit);\n  if (min (cg.x, cg.y) >= 0. && max (cg.x, cg.y) < gSizef - 1.) {\n    gHit -= cg;\n    igHit = int (gSizef * cg.y + cg.x);\n    h = mix (mix (Loadv4 (igHit).x, Loadv4 (igHit + gSize).x, gHit.y),\n       mix (Loadv4 (igHit + 1).x, Loadv4 (igHit + gSize + 1).x, gHit.y), gHit.x);\n    h = clamp (h, -0.02, 0.02);\n  } else h = 0.;\n  return h;\n}\n\nfloat SurfRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + s * rd;\n    h = p.y - SurfHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.01, 0.5 * h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - SurfHt (p.xz));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return (max (abs (p.x), abs (p.z)) > 0.5 * (1. - 6. / gSizef)) ? dstFar : dHit;\n}\n\nvec3 SurfNf ()\n{\n  vec2 vn;\n  vn = mix (mix (Loadv4 (igHit).zw, Loadv4 (igHit + gSize).zw, gHit.y),\n     mix (Loadv4 (igHit + 1).zw, Loadv4 (igHit + gSize + 1).zw, gHit.y), gHit.x);\n  return normalize (vec3 (vn.x, 1., vn.y));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, ds, w, b, s;\n  dMin = dstFar;\n  w = 0.5 * (1. - 6. / gSizef);\n  q = p;\n  q.xy -= vec2 (- w + 0.002, -0.005);\n  b = q.z;\n  s = 1. / (nSlit + 1.);\n  if (2. * floor (0.5 * nSlit) != nSlit) q.z += 0.5 * s;\n  q.z = mod (q.z, s) - 0.5 * s;\n  ds = max (PrCylDf (q.xzy, 0.01, 0.03), abs (b) - 0.45);\n  q = p;\n  q.y -= -0.01;\n  d = max (max (PrBoxDf (q, vec3 (w + 0.015, 0.04, w + 0.015)),\n     - PrBox2Df (q.xz, vec2 (w))), - ds);\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstSurf, dstObj;\n  ltDir = normalize (vec3 (0.3, 1., 0.));\n  dstObj = ObjRay (ro, rd);\n  dstSurf = SurfRay (ro, rd);\n  if (min (dstObj, dstSurf) < dstFar) {\n    if (dstSurf < dstObj) {\n      vn = SurfNf ();\n      col = vec3 (0.4, 0.4, 1.);\n    } else {\n      vn = ObjNf (ro + rd * dstObj);\n      col = vec3 (0.7, 0.4, 0.2);\n    }\n    col = col * (0.2 + 0.3 * max (dot (vn, vec3 (- ltDir.x, 0., - ltDir.z)), 0.) +\n       0.8 * max (dot (vn, ltDir), 0.)) +       \n       0.15 * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.);\n    col = pow (clamp (col, 0., 1.), vec3 (0.7));\n  } else col = vec3 (0.1, 0.2, 0.4);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  int gSizeSq;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = (canvas.y > 160.) ? 160 : 40;\n  txRow = float (gSize);\n  dstFar = 60.;\n  gSizef = float (gSize);\n  gSizeSq = gSize * gSize;\n  nSlit = Loadv4 (gSizeSq).y;\n  el = 0.27 * pi;\n  az = 0.5 * pi;\n  if (mPtr.z > 0.) {\n    el = clamp (el - 1.5 * mPtr.y, 0.1 * pi, 0.35 * pi);\n    az -= 7. * mPtr.x;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  ro = vec3 (0., -0.02, -3.) * vuMat;\n  rd = normalize (vec3 (uv, 6.6)) * vuMat;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Wave Tank\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float pi = 3.14159;\nfloat txRow, tCur, nStep;\nfloat gSizef, kCon, vAmp, dt, cDamp, nSlit, wdSlit;\nconst float mxSlit = 5.;\nint gSize;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nvoid Step (int sId, inout vec4 p)\n{\n  vec2 sv;\n  float h, hv, ha, sIdf, fc, kf;\n  sIdf = float (sId);\n  sv = vec2 (mod (sIdf, gSizef), floor (sIdf / gSizef));\n  h = p.x;\n  hv = p.y;\n  ha = 0.;\n  if (sv.x > 0.) ha += (Loadv4 (int (sv.x - 1. + gSizef * sv.y)).x - h);\n  if (sv.x < gSizef - 1.) ha += (Loadv4 (int (sv.x + 1. + gSizef * sv.y)).x - h);\n  if (sv.y > 0.) ha += (Loadv4 (int (sv.x + gSizef * (sv.y - 1.))).x - h);\n  if (sv.y < gSizef - 1.) ha += (Loadv4 (int (sv.x + gSizef * (sv.y + 1.))).x - h);\n  ha *= kCon;\n  if (cDamp > 0. && (sv.x >= gSizef - 3. || sv.y <= 2. || sv.y >= gSizef - 3.)) {\n    fc = 0.;\n    if (sv.x == gSizef - 1. || sv.y == 0. || sv.y == gSizef - 1.) fc = 1.;\n    else if (sv.x == gSizef - 2. || sv.y == 1. || sv.y == gSizef - 2.) fc = 0.5;\n    else if (sv.x == gSizef - 3. || sv.y == 2. || sv.y == gSizef - 3.) fc = 0.25;\n    ha -= fc * cDamp * hv;\n  }\n  if (sv.x == 0.) hv = vAmp * cos (2. * pi * nStep * dt * sqrt (kCon / gSizef));\n  else hv += ha * dt;\n  h += hv * dt;\n  if (sv.x == 0.) {\n    kf = 0.;\n    for (float ns = 0.; ns < mxSlit; ns ++) {\n      if (ns == nSlit || abs (sv.y - 2. * (ns + 1.) * gSizef /\n         (2. * nSlit + 2.)) < wdSlit) break;\n      ++ kf;\n    }\n    if (kf == nSlit) h = 0.;\n  }\n  p.xy = vec2 (h, hv);\n}\n\nvoid Norm (int sId, inout vec4 p)\n{\n  vec3 vn;\n  vec2 sv;\n  float sIdf, s, h, hp, hm, dhx, dhz;\n  sIdf = float (sId);\n  sv = vec2 (mod (sIdf, gSizef), floor (sIdf / gSizef));\n  s = 1. / gSizef;\n  h = p.x;\n  if (sv.x > 0.) hm = Loadv4 (int (sv.x - 1. + gSizef * sv.y)).x;\n  if (sv.x < gSizef - 1.) hp = Loadv4 (int (sv.x + 1. + gSizef * sv.y)).x;\n  dhx = (sv.x > 0. && sv.x < gSizef - 1.) ? 0.5 * (hp - hm) :\n     ((sv.x > 0.) ? hp - h: h - hm);\n  if (sv.y > 0.) hm = Loadv4 (int (sv.x + gSizef * (sv.y - 1.))).x;\n  if (sv.y < gSizef - 1.) hp = Loadv4 (int (sv.x + gSizef * (sv.y + 1.))).x;\n  dhz = (sv.y > 0. && sv.y < gSizef - 1.) ? 0.5 * (hp - hm):\n     ((sv.y > 0.) ? hp - h: h - hm);\n  vn = cross (normalize (vec3 (s, dhx, 0.)), normalize (vec3 (0., dhz, s)));\n  p.zw = vn.xz / vn.y;\n}\n\nvoid Init (int sId, out vec4 p)\n{\n  vec2 sv;\n  float h, hv, sIdf;\n  sIdf = float (sId);\n  sv = vec2 (mod (sIdf, gSizef), floor (sIdf / gSizef));\n  h = 0.;\n  hv = (sv.x == 0.) ? vAmp : 0.;\n  p = vec4 (h, hv, 0., 0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, p;\n  vec2 iFrag, canvas;\n  float mxStep;\n  int sId, gSizeSq;\n  bool doInit;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  gSize = (canvas.y > 160.) ? 160 : 40;\n  txRow = float (gSize);\n  iFrag = floor (fragCoord);\n  sId = int (iFrag.x + txRow * iFrag.y);\n  gSizeSq = gSize * gSize;\n  if (iFrag.x >= txRow || sId > gSizeSq) discard;\n  gSizef = float (gSize);\n  nSlit = 5.;\n  kCon = 0.05;\n  vAmp = 0.01;\n  dt = 0.4;\n  cDamp = 4.;\n  wdSlit = 2.;\n  mxStep = (canvas.y > 160.) ? 2000. : 500.;\n  doInit = false;\n  if (iFrame <= 5) doInit = true;\n  else {\n    p = Loadv4 (gSizeSq);\n    nStep = p.x;\n    nSlit = p.y;\n    ++ nStep;\n    if (nStep < mxStep) {\n      p = Loadv4 (sId);\n      Step (sId, p);\n      Norm (sId, p);\n    } else doInit = true;\n  }\n  if (doInit) {\n    nStep = 0.;\n    if (sId < gSizeSq) Init (sId, p);\n    nSlit = mod (nSlit, 5.) + 1.;\n  }\n  if (sId == gSizeSq) stDat = vec4 (nStep, nSlit, 0., 0.);\n  Savev4 (sId, ((sId < gSizeSq) ? p : stDat), fragColor, fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Wave Tank\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float pi = 3.14159;\nfloat txRow, tCur, nStep;\nfloat gSizef, kCon, vAmp, dt, cDamp, nSlit, wdSlit;\nconst float mxSlit = 5.;\nint gSize;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nvoid Step (int sId, inout vec4 p)\n{\n  vec2 sv;\n  float h, hv, ha, sIdf, fc, kf;\n  sIdf = float (sId);\n  sv = vec2 (mod (sIdf, gSizef), floor (sIdf / gSizef));\n  h = p.x;\n  hv = p.y;\n  ha = 0.;\n  if (sv.x > 0.) ha += (Loadv4 (int (sv.x - 1. + gSizef * sv.y)).x - h);\n  if (sv.x < gSizef - 1.) ha += (Loadv4 (int (sv.x + 1. + gSizef * sv.y)).x - h);\n  if (sv.y > 0.) ha += (Loadv4 (int (sv.x + gSizef * (sv.y - 1.))).x - h);\n  if (sv.y < gSizef - 1.) ha += (Loadv4 (int (sv.x + gSizef * (sv.y + 1.))).x - h);\n  ha *= kCon;\n  if (cDamp > 0. && (sv.x >= gSizef - 3. || sv.y <= 2. || sv.y >= gSizef - 3.)) {\n    fc = 0.;\n    if (sv.x == gSizef - 1. || sv.y == 0. || sv.y == gSizef - 1.) fc = 1.;\n    else if (sv.x == gSizef - 2. || sv.y == 1. || sv.y == gSizef - 2.) fc = 0.5;\n    else if (sv.x == gSizef - 3. || sv.y == 2. || sv.y == gSizef - 3.) fc = 0.25;\n    ha -= fc * cDamp * hv;\n  }\n  if (sv.x == 0.) hv = vAmp * cos (2. * pi * nStep * dt * sqrt (kCon / gSizef));\n  else hv += ha * dt;\n  h += hv * dt;\n  if (sv.x == 0.) {\n    kf = 0.;\n    for (float ns = 0.; ns < mxSlit; ns ++) {\n      if (ns == nSlit || abs (sv.y - 2. * (ns + 1.) * gSizef /\n         (2. * nSlit + 2.)) < wdSlit) break;\n      ++ kf;\n    }\n    if (kf == nSlit) h = 0.;\n  }\n  p.xy = vec2 (h, hv);\n}\n\nvoid Norm (int sId, inout vec4 p)\n{\n  vec3 vn;\n  vec2 sv;\n  float sIdf, s, h, hp, hm, dhx, dhz;\n  sIdf = float (sId);\n  sv = vec2 (mod (sIdf, gSizef), floor (sIdf / gSizef));\n  s = 1. / gSizef;\n  h = p.x;\n  if (sv.x > 0.) hm = Loadv4 (int (sv.x - 1. + gSizef * sv.y)).x;\n  if (sv.x < gSizef - 1.) hp = Loadv4 (int (sv.x + 1. + gSizef * sv.y)).x;\n  dhx = (sv.x > 0. && sv.x < gSizef - 1.) ? 0.5 * (hp - hm) :\n     ((sv.x > 0.) ? hp - h: h - hm);\n  if (sv.y > 0.) hm = Loadv4 (int (sv.x + gSizef * (sv.y - 1.))).x;\n  if (sv.y < gSizef - 1.) hp = Loadv4 (int (sv.x + gSizef * (sv.y + 1.))).x;\n  dhz = (sv.y > 0. && sv.y < gSizef - 1.) ? 0.5 * (hp - hm):\n     ((sv.y > 0.) ? hp - h: h - hm);\n  vn = cross (normalize (vec3 (s, dhx, 0.)), normalize (vec3 (0., dhz, s)));\n  p.zw = vn.xz / vn.y;\n}\n\nvoid Init (int sId, out vec4 p)\n{\n  vec2 sv;\n  float h, hv, sIdf;\n  sIdf = float (sId);\n  sv = vec2 (mod (sIdf, gSizef), floor (sIdf / gSizef));\n  h = 0.;\n  hv = (sv.x == 0.) ? vAmp : 0.;\n  p = vec4 (h, hv, 0., 0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, p;\n  vec2 iFrag, canvas;\n  float mxStep;\n  int sId, gSizeSq;\n  bool doInit;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  gSize = (canvas.y > 160.) ? 160 : 40;\n  txRow = float (gSize);\n  iFrag = floor (fragCoord);\n  sId = int (iFrag.x + txRow * iFrag.y);\n  gSizeSq = gSize * gSize;\n  if (iFrag.x >= txRow || sId > gSizeSq) discard;\n  gSizef = float (gSize);\n  nSlit = 5.;\n  kCon = 0.05;\n  vAmp = 0.01;\n  dt = 0.4;\n  cDamp = 4.;\n  wdSlit = 2.;\n  mxStep = (canvas.y > 160.) ? 2000. : 500.;\n  doInit = false;\n  if (iFrame <= 5) doInit = true;\n  else {\n    p = Loadv4 (gSizeSq);\n    nStep = p.x;\n    nSlit = p.y;\n    ++ nStep;\n    if (nStep < mxStep) {\n      p = Loadv4 (sId);\n      Step (sId, p);\n      Norm (sId, p);\n    } else doInit = true;\n  }\n  if (doInit) {\n    nStep = 0.;\n    if (sId < gSizeSq) Init (sId, p);\n    nSlit = mod (nSlit, 5.) + 1.;\n  }\n  if (sId == gSizeSq) stDat = vec4 (nStep, nSlit, 0., 0.);\n  Savev4 (sId, ((sId < gSizeSq) ? p : stDat), fragColor, fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}