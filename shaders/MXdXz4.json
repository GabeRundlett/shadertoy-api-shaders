{
    "Shader": {
        "info": {
            "date": "1718736526",
            "description": "Proof of concept. You may recognize the paragraph from Ender's Game.",
            "flags": 0,
            "hasliked": 0,
            "id": "MXdXz4",
            "likes": 47,
            "name": "Hand Written",
            "published": 3,
            "tags": [
                "animated",
                "organic",
                "hand",
                "calligraphy",
                "writing",
                "cursive",
                "written"
            ],
            "usePreview": 0,
            "username": "milkfat",
            "viewed": 423
        },
        "renderpass": [
            {
                "code": "#define SUBDIVISIONS 8\n#define COLUMNS 60\n#define ROWS 30\n#define INVERT\n#define SHARPNESS 1.\n#define THICKNESS 1.\n#define CALIGRAPHY_AMOUNT .06\n//#define PARTIAL_DRAW\n#define SMOOTH_MOTION\n\n#define FCOLUMNS float(COLUMNS)\n#define FROWS float(ROWS)\nconst float PI = 355./113.;\n\nvec2 rotate(vec2 p, float a) {return vec2 (cos(a)*p.x - sin(a)*p.y, sin(a)*p.x + cos(a)*p.y);}\n\nfloat hash(float n) {return fract(n*fract(n*.133929));}\n\nint ipow(int a, int b)\n{\n    return int(pow(float(a),float(b)));\n}\n\nfloat line_seg_sdf(vec3 p, vec3 a, vec3 b)\n{\n    float d = distance(a.xy,b.xy);\n    float ang = -atan((b.y-a.y),(b.x-a.x));\n    p.xy = rotate((p-a).xy, ang);\n    float x = min(max(p.x,0.0),d);\n    float thick = dot(normalize(a.xy-b.xy), normalize(vec2(-.5,.7)));\n    return max(0.0,distance(p.xy,vec2(x,0.0))-abs(thick)*CALIGRAPHY_AMOUNT);\n}\n\nfloat cell_time(int cell_id) {return (iTime)*5.0+10.0*hash(10.0*float(cell_id-1));}\n\nvec3 get_point(int pp, vec3 offset, int i, int cell_id)\n{\n    int v = pp;\n    vec3 point = vec3((v/256)*10-200,((v/4)%64)*10-200,v%4);\n    point=point/vec3(300.0,300.0,300.0)+offset;\n    float time = floor(cell_time(cell_id))*.9717; //time ticks in discrete steps\n    float timef = fract(cell_time(cell_id));      //fractional time between steps\n    float char = float(i);\n    vec2 p = (vec2( hash(time*fract(char*.79331))*.1,hash(time*fract(char*.979331)))-.5);\n#ifdef SMOOTH_MOTION\n    vec2 p1 = (vec2( hash((time+.9717)*fract(char*.79331))*.1,hash((time+.9717)*fract(char*.979331)))-.5);\n    p = p*(1.0-timef)+p1*timef;\n#endif\n    point.xy += p*.15;\n    return point;\n}\n\nfloat curve_sdf(vec3 CC, vec3 a0, vec3 a1, vec3 a2, vec3 a3) \n{\n\n    float l0 = length(a0-a1);\n    float l1 = length(a1-a2);\n    float l2 = length(a2-a3);\n    \n    //return early if not in range\n    float check = line_seg_sdf(CC,a1,a2);\n    if(check>l1) return check;\n    \n    float r1 = l0/(l0+l1);\n    float r2 = l2/(l1+l2);\n    \n    vec3 v1 = (normalize(a1-a0)*(1.0-r1)+normalize(a2-a1)*(r1)); //tangent\n    vec3 v2 = (normalize(a2-a3)*(1.0-r2)+normalize(a1-a2)*(r2));\n    \n    vec3 lv1 = v1*min(l1,(l1+l0)*.5);\n    vec3 lv2 = v2*min(l1,(l1+l2)*.5);\n\n    vec3 last_aa3;\n    float min_d = 10000.0;\n    float c;\n    for(int i = 0; i <= SUBDIVISIONS; i++) {\n        float p = float(i)/float(SUBDIVISIONS);\n        \n        vec3 aa0 = (lv1*p)+a1;\n        vec3 aa2 = (lv2*(1.0-p))+a2;\n        vec3 aa3 = (aa2-aa0)*smoothstep(0.0,1.0,p)+aa0;\n        float d = abs(line_seg_sdf(CC, aa3, last_aa3));\n        min_d = (i==0)?min_d:min(d,min_d);\n        c = (d==min_d)?p:c;\n        last_aa3 = aa3;\n        \n    }\n    \n    //return early if not in range\n    if(min_d > .05) return min_d;\n    \n    //add extra precision\n    min_d=10000.0;\n    for(int i = 0; i <= SUBDIVISIONS; i++) {\n        float mn = max(c-(1.0/float(SUBDIVISIONS)),0.0);\n        float mx = min(c+(1.0/float(SUBDIVISIONS)),1.0);\n        float p = mn+(float(i)/float(SUBDIVISIONS))*(mx-mn);\n        \n        vec3 aa0 = (lv1*p)+a1;\n        vec3 aa2 = (lv2*(1.0-p))+a2;\n        vec3 aa3 = (aa2-aa0)*smoothstep(0.0,1.0,p)+aa0;\n        float d = abs(line_seg_sdf(CC, aa3, last_aa3));\n        min_d = (i==0)?min_d:min(d,min_d);\n        last_aa3 = aa3;\n        \n    }\n    return min_d;\n}\n\nvoid mainImage( out vec4 FF, in vec2 CC )\n{\n    \n    FF=vec4(1);\n#ifdef INVERT\n    FF=vec4(0);\n#endif\n    vec2 Ci = vec2(CC.x,iResolution.y-CC.y);\n    vec2 _uv = Ci/iResolution.x;\n    ivec2 cell = ivec2(_uv*vec2(COLUMNS,ROWS));\n    int cell_id = cell.x+cell.y*COLUMNS;\n    vec2 uv = fract(_uv*vec2(COLUMNS,ROWS));\n    uv.y = 1.0-uv.y;\n    uv.y*=2.0;\n    uv.y-=.6;\n    float scale = iResolution.x/FCOLUMNS;\n    \n    int text_len = _TEXT.length()*6-2;\n    //cell_id%=text_len;\n    if(cell_id >= text_len) return;\n    int id0 = cell_id/6;\n    int id1 = (cell_id+1)/6;\n    int id2 = (cell_id+2)/6;\n    \n    int idr0 = (cell_id%6);\n    int idr1 = (cell_id+1)%6;\n    int idr2 = (cell_id+2)%6;\n    \n    uint idd0 = (_TEXT[id0]>>(idr0*5))%32u;\n    uint idd1 = (_TEXT[id1]>>(idr1*5))%32u;\n    uint idd2 = (_TEXT[id2]>>(idr2*5))%32u;\n    \n    int n0 = _POS[idd0];\n    int n1 = _POS[idd1];\n    int n2 = _POS[idd2];\n    \n    int nl0 = _LEN[idd0];\n    int nl1 = _LEN[idd1];\n    int nl2 = _LEN[idd2];\n\n    vec3 ps[20];\n    int len = 0;\n\n    {\n        int pval = _LETTERS[n0+(nl0-1)];\n        int ppval= _LETTERS[n0+(nl0-2)];\n        int val0 = pval%16384;\n        int val1 = pval/16384;\n        if(val1==0)\n        {\n            val1 = val0;\n            val0 = ppval/16384;\n        }\n        ps[len++]=get_point(val0, vec3(-1,0,0), nl0-2, cell_id-1);\n        ps[len++]=get_point(val1, vec3(-1,0,0), nl0-1, cell_id-1);\n    }\n    for (int i = 0; i < nl1; i++) \n    {\n        int val = _LETTERS[n1+i];\n        ps[len++]=get_point(val%16384,       vec3(0,0,0),  i,     cell_id  );\n        val/=16384;\n        if(val > 0)\n        {\n            ps[len++]=get_point(val,       vec3(0,0,0),  i,     cell_id  );\n        }\n    }\n    for (int i = 0; i < 2;   i++)\n    {\n        int val = _LETTERS[n2+i];\n        ps[len++]=get_point(val%16384,       vec3(1,0,0),  i,     cell_id+1);\n        val/=16384;\n        if(val > 0)\n        {\n            ps[len++]=get_point(val,       vec3(1,0,0),  i,     cell_id+1);\n        }\n    }\n    \n    //draw curve\n    float d = 10000.0;\n    float c;\n    float td = 0.0;\n    bool black = false;\n    for(int i = 0; i < len-3; i++)\n    {\n        float dd = curve_sdf(vec3(uv,0),ps[i],ps[i+1],ps[i+2],ps[i+3]);\n        int flag1 = int(ps[i+1].z*300.0+.5);\n        int flag2 = int(ps[i+2].z*300.0+.5);\n        if(flag2==0 || (flag1==0 && flag2==2))\n        d = min(d,dd);\n        c = (dd==d)?distance(vec3(uv,0),ps[i+1])+td:c;\n        if(i>0)\n        td+=distance(ps[i+1],ps[i+2]);\n    }\n    \n    d*=scale*SHARPNESS;\n    d=d+1.0-THICKNESS;\n    \n    float lim = 1.0;\n#ifdef PARTIAL_DRAW\n    c/=td;\n    c/=float(text_len);\n    c+=float(cell_id)/float(text_len);\n    lim = sin(iTime*.035)*.5+.5;\n    lim-=c;\n    lim*=100000.0;\n    lim= clamp(lim,0.,1.);\n#endif \n\n#ifdef INVERT\n    lim*=-1.0;\n#endif\n    \n    FF-=vec4(clamp(1.0-d,0.0,1.0))*lim; //draw line\n    FF=pow(FF,vec4(1.0/2.2)); //to sRGB\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//vec3(x,y,z)\n//x = x-coordinate from 0-30\n//y = y-coordinate from 0-60\n//z = flag: 0 = draw, 1 = don't draw, 2 = refer to the flag of the previous point\n//vec3 a\n//vec3 b\n//encoded = b.x*pow(2,22) + b.y*pow(2,16) + b.z*pow(2,14) + a.x*pow(2,8) + a.y*pow(2,2) + a.z\n#define __  127490406,169436005,11621\n#define _A  170402716,148446072,170403952,11108\n#define _B  129767780,148446700,170403980,10892\n#define _C  170402716,166145432,8548\n#define _D  170402716,148446072,171714672,11108\n#define _E  157818488,127474052\n#define _F  146545780,138748384,136127008,161030508\n#define _G  170402716,148446072,170403952,159852564,10320\n#define _H  133962084,127475428,170401420,11620\n#define _I  132389220,133504969,133308884,148447137\n#define _J  132651364,133308349,133112264,130359185,148446492\n#define _K  133962084,127344348,157818508,128132480,11356\n#define _L  142287856,9060\n#define _M  106502560,149428592,148644708,190393760\n#define _N  127475360,178790000,10852\n#define _O  162012308,140057748,162014860,11672\n#define _P  117775520,170400880,127478412,9060\n#define _Q  174596508,140056952,178857584,185214996,190392420\n#define _R  145170060,178463648,140061064\n#define _S  166207096,178464932,119089260,8548\n#define _T  149757816,151086064,116348605,200239804,150758405,177808288\n#define _U  128458136,169877092,182200992\n#define _V  140713632,174071396,178662048,11148\n#define _W  107485336,140515684,152642464,191376256,11888\n#define _X  159522472,191393145,128343656,190457353\n#define _Y  127475360,174598528,160049172,10852\n#define _Z  161752736,161226084,147465492,10340\n#define _PE  165239142,169420645,11621\n#define _CO  165566822,127165244,11621\n#define _QU  127490406,129130105,130113264,171731205,169765064,11621\n#define _AP  127490406,150758405,148792264,11621\n\n#define _l int[](__).length()\n#define Al int[](_A).length()\n#define Bl int[](_B).length()\n#define Cl int[](_C).length()\n#define Dl int[](_D).length()\n#define El int[](_E).length()\n#define Fl int[](_F).length()\n#define Gl int[](_G).length()\n#define Hl int[](_H).length()\n#define Il int[](_I).length()\n#define Jl int[](_J).length()\n#define Kl int[](_K).length()\n#define Ll int[](_L).length()\n#define Ml int[](_M).length()\n#define Nl int[](_N).length()\n#define Ol int[](_O).length()\n#define Pl int[](_P).length()\n#define Ql int[](_Q).length()\n#define Rl int[](_R).length()\n#define Sl int[](_S).length()\n#define Tl int[](_T).length()\n#define Ul int[](_U).length()\n#define Vl int[](_V).length()\n#define Wl int[](_W).length()\n#define Xl int[](_X).length()\n#define Yl int[](_Y).length()\n#define Zl int[](_Z).length()\n#define PEl int[](_PE).length()\n#define COl int[](_CO).length()\n#define QUl int[](_QU).length()\n#define APl int[](_AP).length()\n\n#define _p 0\n#define Ap _p + _l\n#define Bp Ap + Al\n#define Cp Bp + Bl\n#define Dp Cp + Cl\n#define Ep Dp + Dl\n#define Fp Ep + El\n#define Gp Fp + Fl\n#define Hp Gp + Gl\n#define Ip Hp + Hl\n#define Jp Ip + Il\n#define Kp Jp + Jl\n#define Lp Kp + Kl\n#define Mp Lp + Ll\n#define Np Mp + Ml\n#define Op Np + Nl\n#define _Pp Op + Ol\n#define Qp _Pp + Pl\n#define Rp Qp + Ql\n#define Sp Rp + Rl\n#define Tp Sp + Sl\n#define Up Tp + Tl\n#define Vp Up + Ul\n#define Wp Vp + Vl\n#define Xp Wp + Wl\n#define Yp Xp + Xl\n#define Zp Yp + Yl\n#define PEp Zp + Zl\n#define COp PEp + PEl\n#define QUp COp + COl\n#define APp QUp + QUl\n\n#define _ 0\n#define A 1\n#define B 2\n#define C 3\n#define D 4\n#define E 5\n#define F 6\n#define G 7\n#define H 8\n#define I 9\n#define J 10\n#define K 11\n#define L 12\n#define M 13\n#define N 14\n#define O 15\n#define P 16\n#define Q 17\n#define R 18\n#define S 19\n#define T 20\n#define U 21\n#define V 22\n#define W 23\n#define X 24\n#define Y 25\n#define Z 26\n#define PE 27\n#define CO 28\n#define QU 29\n#define AP 30\n\n//#define TEXT T,H,E,N,_,E,N,D,E,R,_,L,O,O,K,E,D,_,A,T,_,T,H,E,_,O,T,H,E,R,S,_,C,O,L,D,L,Y,PE,_,QU,Y,O,U,_,M,I,G,H,T,_,B,E,_,H,A,V,I,N,G,_,S,O,M,E,_,I,D,E,A,_,O,F,_,G,A,N,G,I,N,G,_,U,P,_, \\\n//O,N,_,M,E,PE,_,Y,O,U,_,C,O,U,L,D,_,P,R,O,B,A,B,L,Y,_,B,E,A,T,_,M,E,_,U,P,_,P,R,E,T,T,Y,_,B,A,D,PE,_,B,U,T,_,J,U,S,T,_,R,E,M,E,M,B,E,R,_,W,H,A,T,_,I,_,D,O,_,T,O,_,P,E,O,P,L,E,_, \\\n//W,H,O,_,T,R,Y,_,T,O,_,H,U,R,T,_,M,E,PE,_,F,R,O,M,_,T,H,E,N,_,O,N,_,Y,O,U,AP,D,_,B,E,_,W,O,N,D,E,R,I,N,G,_,W,H,E,N,_,I,AP,D,_,G,E,T,_,Y,O,U,CO,_,A,N,D,_,H,O,W,_,B,A,D,_,I,T,_, \\\n//W,O,U,L,D,_,B,E,PE,QU,_,H,E,_,K,I,C,K,E,D,_,S,T,I,L,S,O,N,_,I,N,_,T,H,E,_,F,A,C,E,PE,_,B,L,O,O,D,_,F,R,O,M,_,H,I,S,_,N,O,S,E,_,S,P,A,T,T,E,R,E,D,_,T,H,E,_,G,R,O,U,N,D,_, \\\n//N,E,A,R,B,Y,PE,_,QU,I,T,_,W,O,U,L,D,N,AP,T,_,B,E,_,T,H,I,S,_,B,A,D,CO,QU,_,E,N,D,E,R,_,S,A,I,D,PE,_,QU,I,T,_,W,O,U,L,D,_,B,E,_,W,O,R,S,E,PE,QU\n\n//six 5-bit uints are packed into each 32-bit uint\n#define TEXT 436380288u, 620373455u, 26346880u, 139863475u, 26810048u, 851610926u, 671234080u, 139873967u, 269067520u, 470829345u, 143707140u, 148960284u, 302931122u, 520640096u, 26311859u, 529554926u, 335727573u, 68178549u, 189444595u, 110723884u, 268647435u, 7808705u, 269092116u, 4508239u, 524597741u, 408650610u, 268731276u, 510662337u, 777453711u, 19373043u, 671995385u, 516968488u, 19386670u, 317948521u, 16384238u, 503494115u, 150602389u, 191917857u, 510662238u, 524295625u, 21615936u, 302165044u, 276088852u, 961199124u, 334641184u, 1021828116u, 690659348u, 680591392u, 168820667u, 470357134u, 910332047u, 57692448u, 314573843u, 6783877u, 188306915u, 672419868u, 527454496u, 703009173u, 21583104u, 927238145u, 638211136u, 33721801u, 20591268u, 663805313u, 4490879u, 176915081u, 772416526u, 317948513u, 16384238u, 30034600u, 720470184u, 720470156u, 15172238u, 638190868u, 181588020u, 19956366u, 103842241u, 1046087253u, 110237264u, 503790900u, 5525510u, 187355814u, 181914651u, 20100404u, 772379948u, 516953669u, 542245042u, 404787653u, 471093253u, 671261312u, 1068782258u, 16380959u, 721191113u, 715141534u, 452035219u, 609958917u, 945362176u, 186791968u, 659882903u, 21285908u, 21241138u, 609485333u, 671562757u, 58884264u, 249870637u, 180422272u, 5526523u, 620367332u, 12986080u, 14975138u, 173638132u, 302694176u, 516949006u, 1002059949u, 671120415u, 485916840u, 235486857u, 168662479u, 671683726u, 671225138u, 236364815u, 289412553u, 692367365u, 743571628u, 315626601u, 7808627u, 671530566u, 101777576u, 268647435u, 106397289u, 434406251u, 415746060u, 19061216u, 26640847u, 302353442u, 4360206u, 680530369u, 703020768u, 620762176u, 249876069u, 186819200u, 527442971u, 174085070u, 21266821u, 314816820u, 148962542u, 479561344u, 671634439u, 39059624u, 475290644u, 512327968u, 903351u\n\nconst int[] _LEN = int[](_l,Al,Bl,Cl,Dl,El,Fl,Gl,Hl,Il,Jl,Kl,Ll,Ml,Nl,Ol,Pl,Ql,Rl,Sl,Tl,Ul,Vl,Wl,Xl,Yl,Zl,PEl,COl,QUl,APl,_l);\nconst int[] _POS = int[](_p,Ap,Bp,Cp,Dp,Ep,Fp,Gp,Hp,Ip,Jp,Kp,Lp,Mp,Np,Op,_Pp,Qp,Rp,Sp,Tp,Up,Vp,Wp,Xp,Yp,Zp,PEp,COp,QUp,APp,_p);\nconst int[] _LETTERS = int[](__,_A,_B,_C,_D,_E,_F,_G,_H,_I,_J,_K,_L,_M,_N,_O,_P,_Q,_R,_S,_T,_U,_V,_W,_X,_Y,_Z,_PE,_CO,_QU,_AP,__);\nconst uint[] _TEXT =  uint[](TEXT,0u);\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}