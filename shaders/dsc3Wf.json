{
    "Shader": {
        "info": {
            "date": "1678096146",
            "description": "For screwed engine",
            "flags": 0,
            "hasliked": 0,
            "id": "dsc3Wf",
            "likes": 0,
            "name": "Work in progress WIiiwiidajsjdas",
            "published": 3,
            "tags": [
                "shader"
            ],
            "usePreview": 0,
            "username": "Wither362",
            "viewed": 95
        },
        "renderpass": [
            {
                "code": "#define pi 3.145191\n#define wither 1.7825638\n#define mzkzoz 4.2396529\n#define euler 2.64\n#define res 1.24536783\n#define less 0.5\n\n\n\nconst int SHADER_TYPE_MOVING              = 0;\nconst int SHADER_TYPE_DISTORTION_GLITCH   = 1;\nconst int SHADER_TYPE_VERTICAL_LINEAR     = 2;\nconst int SHADER_TYPE_HORIZONTAL_LINEAR   = 3;\nconst int SHADER_TYPE_CENTER_LINEAR       = 4;\nconst int SHADER_TYPE_CURTAIN             = 5;\n\n\n\nconst int HUD_TYPE_BORDERS                 = 0;\nconst int HUD_TYPE_ROUNDED_BORDERS         = 1;\nconst int HUD_TYPE_CENTER_COLUMN           = 2;\nconst int HUD_TYPE_CRAZY_LINES             = 3;\nconst int HUD_TYPE_MAYBE_VERTICAL_DIRTY    = 4;\nconst int HUD_TYPE_MAYBE_VERTICAL          = 5;\nconst int HUD_TYPE_HALF                    = 6;\n\n\nconst int HUD_TYPE_DISTORTION_GLITCH_NORMAL        = 7;\nconst int HUD_TYPE_DISTORTION_GLITCH_EXTENDED      = 10;\nconst int HUD_TYPE_DISTORTION_GLITCH_FADE_IN       = 11;\nconst int HUD_TYPE_DISTORTION_GLITCH_FADE_IN_DIRTY = 12;\n\n\nconst int HUD_TYPE_CURTAIN_RED_HEATED      = 13;\nconst int HUD_TYPE_CURTAIN_GREEN_HEATED    = 14;\nconst int HUD_TYPE_CURTAIN_BLUE_HEATED     = 15;\nconst int HUD_TYPE_CURTAIN_MIXED           = 16;\nconst int HUD_TYPE_CURTAIN_GREEN_YELLOW    = 17;\nconst int HUD_TYPE_CURTAIN_YELLOW_GREEN    = 18;\nconst int HUD_TYPE_CURTAIN_BLUE_PINK       = 19;\nconst int HUD_TYPE_CURTAIN_WHITE_PINK      = 21;\n\n\n//uniform float iTime;\n\n\n\n//uniform int shaderType;\n//uniform int hudType;\n/**\n * Use this to customize the shader if DISTORTION GLITCH\n */\n//uniform int distortionGlitchType;\n/**\n * If the shader is paused. Use it for a non-changing texture.\n */\n//uniform bool shaderPaused;\n/**\n * How much time does the shader have if paused.\n */\n//uniform float shaderPausedValue;\nconst int shaderType = SHADER_TYPE_CURTAIN;\nconst int hudType = HUD_TYPE_CURTAIN_BLUE_PINK;\nconst int distortionGlitchType = HUD_TYPE_DISTORTION_GLITCH_NORMAL;\nconst bool shaderPaused = false;\nconst float shaderPausedValue = 12.32;\n\n\n/**\n * Frequency the shader has.\n */\n//uniform float uFrequency;\nconst float uFrequency = 1.0;\n\n\n//uniform float velocity;\nconst float velocity = 100.0;\n/**\n * Only in LINEAR\n */\n//uniform float amount\nconst float amount = 1.0;\n//uniform bool horizontalLines;\nconst bool horizontalLines = false;\n//uniform bool coloredBorders;\nconst bool coloredBorders = false;\n\n\n\n//uniform int amplitudeType;\n// 0 is none, 1 is sine, 2 is cosine, 3 is tan, 4 is asin, 5 is acos, 6 is atan, 7 is sinh, 8 is cosh, 9 is tanh, 10 is asinh, 11 is acosh, 12 is atanh\nconst int amplitudeType     = 0; // 0 is none, 1 is sine, 2 is cosine, 3 is tan, 4 is asin, 5 is acos, 6 is atan, 7 is sinh, 8 is cosh, 9 is tanh, 10 is asinh, 11 is acosh, 12 is atanh\n// Wave and Saturation type\nconst int WAS               = 0; // 0 is none, 1 is sine, 2 is cosine, 3 is tan, 4 is asin, 5 is acos, 6 is atan, 7 is sinh, 8 is cosh, 9 is tanh, 10 is asinh, 11 is acosh, 12 is atanh\nconst int redPower          = 0; // 0 is none, 1 is sine, 2 is cosine, 3 is tan, 4 is asin, 5 is acos, 6 is atan, 7 is sinh, 8 is cosh, 9 is tanh, 10 is asinh, 11 is acosh, 12 is atanh\n/**\n * This one changes entirely the shader if its distortion glitch\n */\nconst int greenPower        = 0; // 0 is none, 1 is sine, 2 is cosine, 3 is tan, 4 is asin, 5 is acos, 6 is atan, 7 is sinh, 8 is cosh, 9 is tanh, 10 is asinh, 11 is acosh, 12 is atanh\nconst int bluePower         = 0; // 0 is none, 1 is sine, 2 is cosine, 3 is tan, 4 is asin, 5 is acos, 6 is atan, 7 is sinh, 8 is cosh, 9 is tanh, 10 is asinh, 11 is acosh, 12 is atanh\n\n\n// 0 is none, 1 is pi, 2 is wither, 3 is mzkzoz, 4 is euler, 5 is res, 6 is less\nconst int amplitudeMultiplier   = 0; // 0 is none, 1 is pi, 2 is wither, 3 is mzkzoz, 4 is euler, 5 is res, 6 is less\nconst int WASMultiplier         = 0; // 0 is none, 1 is pi, 2 is wither, 3 is mzkzoz, 4 is euler, 5 is res, 6 is less\nconst int redMultiplier         = 0; // 0 is none, 1 is pi, 2 is wither, 3 is mzkzoz, 4 is euler, 5 is res, 6 is less\nconst int greenMultiplier       = 0; // 0 is none, 1 is pi, 2 is wither, 3 is mzkzoz, 4 is euler, 5 is res, 6 is less\nconst int blueMultiplier        = 0; // 0 is none, 1 is pi, 2 is wither, 3 is mzkzoz, 4 is euler, 5 is res, 6 is less\n\nconst float alpha               = 1.0;\n\nfloat hudMulti(float var) {\n    switch (hudType) {\n        case HUD_TYPE_ROUNDED_BORDERS:return sin(var * pi);\n        case HUD_TYPE_CENTER_COLUMN:return cos(var);\n        case HUD_TYPE_CRAZY_LINES:return tan(var);\n        case HUD_TYPE_MAYBE_VERTICAL_DIRTY:return sinh(var);\n        case HUD_TYPE_MAYBE_VERTICAL:return cosh(var);\n        case HUD_TYPE_HALF:return asin(var);\n    }\n    return sin(var);\n}\nfloat convertible(float var, int use){\n    switch (use) {\n        case 1:return sin(var);\n        case 2:return cos(var);\n        case 3:return tan(var);\n\n        case 4:return asin(var);\n        case 5:return acos(var);\n        case 6:return atan(var);\n\n        case 7:return sinh(var);\n        case 8:return cosh(var);\n        case 9:return tanh(var);\n\n        case 10:return asinh(var);\n        case 11:return acosh(var);\n        case 12:return atanh(var);\n    }\n    return var;\n}\nfloat multiply(int multi){switch (multi) {\n        case 1:return pi;\n        case 2:return wither;\n        case 3:return mzkzoz;\n        case 4:return euler;\n        case 5:return res;\n        case 6:return less;\n    }\n    return 1.0;\n}\nfloat hudGlitchType(float var) {\n    switch (distortionGlitchType) {\n        case HUD_TYPE_DISTORTION_GLITCH_EXTENDED:return tan(var);\n        case HUD_TYPE_DISTORTION_GLITCH_FADE_IN:return cos(var);\n        case HUD_TYPE_DISTORTION_GLITCH_FADE_IN_DIRTY:return asinh(var);\n    }\n    return var;\n}\n\n\n// main code\nfloat color(float colorIn){\n   return abs(/*hudMulti*/sin(pi * abs(colorIn * pi /** sin(res)*/)) / sin(cos(wither) * euler));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float r = 1.0;\n    float g = 1.0;\n    float b = 1.0;\n    if (shaderType == SHADER_TYPE_MOVING) {\n        float data = uv.x;\n        float yData = uv.y;\n        bool thing = coloredBorders;\n        if (horizontalLines == true) {\n            data = uv.y;\n            thing = !thing;\n        }\n        \n        \n        if (coloredBorders == true) {\n            yData = uv.x;\n        }\n        \n        if (shaderPaused == true) {\n            r = abs(color(abs(color(yData) * (shaderPausedValue * velocity))));\n        } else {\n            r = abs(color(abs(color(yData) * (iTime * velocity))));\n        }\n        g = color(data); // DONT MODIFY IT\n        b = mod(color(\n            r * uFrequency) * convertible(mzkzoz * pi, WAS) * multiply(WASMultiplier),\n            sin(convertible(g * wither / euler, amplitudeType) * multiply(amplitudeMultiplier)) /** sin(uv.x + uv.y)*/);\n            \n    } else if (shaderType == SHADER_TYPE_DISTORTION_GLITCH) {\n        float lines = 3.0;\n        float data = uv.x;\n        float notData = uv.y;\n        if (horizontalLines == false) {\n            data = uv.y;\n            notData = uv.x;\n        }\n        \n        if (shaderPaused == true) {\n            r = abs(data * convertible(data * fragColor.x * shaderPausedValue * data, redPower) * hudMulti(uFrequency));\n            g = color(data * convertible(shaderPausedValue * tan(dot(velocity, hudGlitchType(wither)) * sin(mod(shaderPausedValue, notData))), greenPower));\n            b = abs(hudMulti(shaderPausedValue) * velocity * convertible(tanh(notData) * wither * euler * lines * sin(fragColor.z * pi), bluePower));\n        } else {\n            r = abs(data * convertible(data * fragColor.x * iTime * data, redPower) * hudMulti(uFrequency));\n            g = color(data * convertible(iTime * tan(dot(velocity, hudGlitchType(wither)) * sin(mod(iTime, notData))), greenPower));\n            b = abs(hudMulti(iTime) * velocity * convertible(tanh(notData) * wither * euler * lines * sin(fragColor.z * pi), bluePower));\n        }\n    } else if(shaderType == SHADER_TYPE_VERTICAL_LINEAR) {\n        if (shaderPaused == true) {\n            r = abs(shaderPausedValue * uv.x * (velocity * amount) * multiply(amplitudeMultiplier));\n        } else {\n            r = abs(iTime * uv.x * (velocity * amount) * multiply(amplitudeMultiplier));\n        }\n        g = sin((r));\n        b = cos(g);\n    } else if(shaderType == SHADER_TYPE_HORIZONTAL_LINEAR) {\n        if (shaderPaused == true) {\n            r = abs(shaderPausedValue * uv.y * (velocity * amount) * multiply(amplitudeMultiplier));\n        } else {\n            r = abs(iTime * uv.y * (velocity * amount) * multiply(amplitudeMultiplier));\n        }\n        g = sin((r));\n        b = cos(g);\n    } else if(shaderType == SHADER_TYPE_CENTER_LINEAR) {\n        if (shaderPaused == true) {\n            r = abs(shaderPausedValue * uv.x * uv.y * (velocity * amount) * multiply(amplitudeMultiplier));\n        } else {\n            r = abs(iTime * uv.x * uv.y * (velocity * amount) * multiply(amplitudeMultiplier));\n        }\n        g = sin((r));\n        b = cos(g);\n    } else if(shaderType == SHADER_TYPE_CURTAIN) {\n        switch(hudType) {\n            case HUD_TYPE_CURTAIN_GREEN_YELLOW:\n                if (horizontalLines) {\n                    if(shaderPaused) {\n                        r = mod(uv.y * shaderPausedValue, uv.x) * uFrequency;\n                    } else {\n                        r = mod(uv.y * iTime, uv.x) * uFrequency;\n                    }\n                } else {\n                    if(shaderPaused) {\n                        r = mod(uv.x * shaderPausedValue, uv.y) * uFrequency;\n                    } else {\n                        r = mod(uv.x * iTime, uv.y) * uFrequency;\n                    }\n                }\n                g = 0.0;\n                b = 1.0;\n            case HUD_TYPE_CURTAIN_YELLOW_GREEN:\n                if (horizontalLines) {\n                    if(shaderPaused) {\n                        r = mod(uv.y * shaderPausedValue, uv.x) * uFrequency;\n                    } else {\n                        r = mod(uv.y * iTime, uv.x) * uFrequency;\n                    }\n                } else {\n                    if(shaderPaused) {\n                        r = mod(uv.x * shaderPausedValue, uv.y) * uFrequency;\n                    } else {\n                        r = mod(uv.x * iTime, uv.y) * uFrequency;\n                    }\n                }\n                g = 0.0;\n                b = 0.0;\n            case HUD_TYPE_CURTAIN_BLUE_PINK:\n                if (horizontalLines) {\n                    if(shaderPaused) {\n                        r = mod(uv.y * shaderPausedValue, uv.x) * uFrequency;\n                    } else {\n                        r = mod(uv.y * iTime, uv.x) * uFrequency;\n                    }\n                } else {\n                    if(shaderPaused) {\n                        r = mod(uv.x * shaderPausedValue, uv.y) * uFrequency;\n                    } else {\n                        r = mod(uv.x * iTime, uv.y) * uFrequency;\n                    }\n                }\n                g = 1.0;\n                b = 1.0;\n                \n            case HUD_TYPE_CURTAIN_WHITE_PINK:\n                if (horizontalLines) {\n                    if(shaderPaused) {\n                        g = mod(uv.y * shaderPausedValue, uv.x) * uFrequency;\n                    } else {\n                        r = mod(uv.y * iTime, uv.x) * uFrequency;\n                    }\n                } else {\n                    if(shaderPaused) {\n                        g = mod(uv.x * shaderPausedValue, uv.y) * uFrequency;\n                    } else {\n                        g = mod(uv.x * iTime, uv.y) * uFrequency;\n                    }\n                }\n                r = 1.0;\n                b = 1.0;\n        }\n    }\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(\n        convertible(r, redPower)   * multiply(redMultiplier),\n        convertible(g, greenPower) * multiply(greenMultiplier),\n        convertible(b, bluePower)  * multiply(blueMultiplier),\n        alpha\n    );\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}