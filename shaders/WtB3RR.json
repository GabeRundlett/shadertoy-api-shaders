{
    "Shader": {
        "info": {
            "date": "1558170623",
            "description": "i originally set out to model a teacup, so this is named 'tea'.\n\nmouse left gutter = soft shadow width\nmouse right gutter = display number of march steps",
            "flags": 32,
            "hasliked": 0,
            "id": "WtB3RR",
            "likes": 8,
            "name": "tea",
            "published": 3,
            "tags": [
                "raymarching",
                "grimoire"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 500
        },
        "renderpass": [
            {
                "code": "/*\n    orion elenzil 2019\n    first marcher with shadows.\n    https://www.shadertoy.com/view/WtB3RR\n\n    click on the far right to show the marching steps.\n\n    todo:\n    * materials!\n    * reflections\n    * improved shadows\n    * worry about efficiency of gradient()\n    * fisheye camera\n    * AA\n    * AO\n*/\n\n// boiler-plate\nconst vec3 fv3_1    = vec3(1.0, 1.0, 1.0);\nconst vec3 fv3_0    = vec3(0.0, 0.0, 0.0);\nconst vec3 fv3_x    = vec3(1.0, 0.0, 0.0);\nconst vec3 fv3_y    = vec3(0.0, 1.0, 0.0);\nconst vec3 fv3_z    = vec3(0.0, 0.0, 1.0);\nconst vec2 fv2_1    = vec2(1.0, 1.0);\nconst vec2 fv2_0    = vec2(0.0, 0.0);\nconst vec2 fv2_x    = vec2(1.0, 0.0);\nconst vec2 fv2_y    = vec2(0.0, 1.0);\nconst float PI      = 3.14159265359;\nconst float TAU     = PI * 2.0;\n\nconst float rmMaxSteps   = 180.0;\nconst float rmMaxDistReg =  32.0;       // max distance for marching for surfaces\nconst float rmMaxDistShd =  10.0;       // max distance for marching for shadows\nconst float rmEpsilon    =   0.002;\nconst float grEpsilon    =   0.0001;\n\nconst float gutterWidth  =   50.0;\n\n\nvec3 rayDir(in vec2 uv, in vec3 ro, in vec3 lookTo, in vec3 worldUp, float zoom) {\n    vec3 vOL = normalize(lookTo - ro);\n    vec3 vRt = cross(vOL, worldUp);\n    vec3 vUp = cross(vRt, vOL);\n    vec3 vRy = normalize(vRt * uv.x + vUp * uv.y + vOL * zoom);\n    return vRy;\n}\n\nfloat sdfGround(in vec3 p, float altitude) {\n    return p.y - altitude;\n}\n\nfloat sdfSphere(in vec3 p, in vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat sdfColumn(in vec3 p, in vec3 c, float r) {\n    return length(p.xz - c.xz) - r;\n}\n\nfloat sdfScene(in vec3 p) {\n    float dist = 1e20;\n    float t    = iTime * TAU / 30.0;\n    float rad  = 1.2;\n    float sep  = (sin(t) * 0.5 + 0.5) + rad;\n\n    // four spheres\n    dist = min(dist, sdfSphere(vec3(abs(p.x), p.y, abs(p.z)), vec3(sep, rad, sep), rad));\n    \n    // minus a wavy plane\n    float cutPlaneSize = (sin(t * 0.72 - PI/2.0) * 0.51 + 0.5) * rad * 2.5;\n    float cutPlaneDisp = (sin(p.x * 4.0) + sin(p.z * 4.0)) * 0.1;\n    cutPlaneDisp += sin(length(p.xz) * 20.0 - t * 20.0) * 0.015;\n    float cutPlane = max((p.y + cutPlaneDisp) - rad - cutPlaneSize * 0.5, -(p.y + cutPlaneDisp) + rad - cutPlaneSize * 0.5);    \n//  cutPlane = max(-sdfColumn(vec3(abs(p.x), p.y, abs(p.z)), vec3(sep, rad, sep), rad * 0.03), cutPlane);\n    dist = max(-cutPlane, dist);\n\n    // ground\n    float ground = sdfGround(p, 0.0);\n    // dimples\n    float dimples = sdfSphere(mod(p + vec3(0.0, 1.0, 0.0), vec3(10.0)), vec3(5.0, 5.0, 5.0), 4.5);\n    ground = max(-dimples, ground);\n    dist = min(dist, ground);\n\n    return dist;\n}\n\nvec3 sdfGradient(in vec3 p) {\n    return vec3(sdfScene(p + fv3_x * grEpsilon) - sdfScene(p - fv3_x * grEpsilon),\n                sdfScene(p + fv3_y * grEpsilon) - sdfScene(p - fv3_y * grEpsilon),\n                sdfScene(p + fv3_z * grEpsilon) - sdfScene(p - fv3_z * grEpsilon));\n}\n\nvoid march(in vec3 ro, in vec3 rd, float stepFactor, float maxDist, out float hitDist, out float steps, out float minDist) {\n    \n    minDist = 1e20;\n    hitDist = 0.0;\n\n    for (steps = 0.0; (steps < rmMaxSteps) && (hitDist < maxDist); ++steps) {\n        float dist = sdfScene(ro + rd * hitDist);\n        minDist = min(minDist, dist);\n        if (dist < rmEpsilon) {\n            return;\n        }\n        hitDist += dist * stepFactor;\n    }\n\n    hitDist = maxDist;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    RGBA.a   = 1.0;\n    vec2  uv = (XY * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    float t  = iTime * TAU / 100.0;\n    \n    vec4 ms = texelFetch(iChannel0, ivec2(0), 0);\n\n    float mouseAlt = ms.z / iResolution.y * 2.0 - 1.0;\n    float mouseAng = ms.y * TAU / iResolution.x;\n\n    float leftMouseY = ms.r;\n\n\n    float softShadowWidth = max(0.0, leftMouseY / iResolution.y * 1.0);\n\n    vec3  ro = vec3(vec2(cos(t + mouseAng), sin(t + mouseAng)) * 13.0, 7.0 + mouseAlt * -5.0).xzy;\n    vec3  lt = vec3(0.0, 1.0, 0.0);\n    float zm = 4.0;\n    vec3  rd = rayDir(uv, ro, lt, fv3_y, zm);\n\n    float hitDist, steps, minDist;\n    march(ro, rd, 1.0, rmMaxDistReg, hitDist, steps, minDist);\n    vec3  hitPoint = ro + rd * hitDist;\n    vec3  gradient = sdfGradient(hitPoint);\n    vec3  normal   = normalize(gradient);\n\n    vec3  lgtDir = vec3(cos(t * 2.0), -(sin(t * 0.2) * 0.5 + 0.6), sin(t * 2.0));\n//  lgtDir.y = -0.3;\n    lgtDir = normalize(lgtDir);\n    float lgtDot = dot(normal, -lgtDir);\n\n    float b = max(0.0, lgtDot);\n\n    if (hitPoint.y < rmEpsilon * 1.1) {\n        // floor\n        float check = float(fract(hitPoint.x / 5.0) > 0.5 ^^ fract(hitPoint.z / 5.0) > 0.5);\n        b *= check * 0.1 + 0.9;\n    }\n\n    if (lgtDot > 0.0) {\n        // check for shadows\n        float hitDist2, steps2, minDist2;\n        float backAway = softShadowWidth * 1.01;\n        vec3  startPnt = hitPoint + normal * backAway;\n        // use finer stepsize when marching for shadows,\n        // also reduced horizon distance.\n        march(startPnt, -lgtDir, 0.5, rmMaxDistShd, hitDist2, steps2, minDist2);\n        float shadowAmt = float(hitDist2 > rmMaxDistShd * 0.96);\n        if (softShadowWidth > 0.09) {\n            shadowAmt *= smoothstep(0.0, softShadowWidth, minDist2);\n        }\n        shadowAmt = shadowAmt * 0.9 + 0.1;\n        b *= shadowAmt;\n        steps += steps2;\n    }\n\n    vec3  rgb    = vec3(b);\n\n    // fog\n    float fogStart = 6.0;\n    float fogAmt = clamp((hitDist - fogStart) / (rmMaxDistReg - fogStart), 0.0, 1.0);\n    vec3  fogClr = vec3(0.0, 0.07, 0.2);\n    rgb = mix(rgb, fogClr, fogAmt);\n\n    // some UI\n\n    // \"heatmap\" of number of marching steps\n    if (iMouse.z > iResolution.x - gutterWidth) {\n        rgb   *= 0.15;\n        rgb.r += (steps)/2.0/rmMaxSteps * 0.85;\n        if (abs((iResolution.x - gutterWidth) - XY.x) < 1.1) {\n            rgb.r += 0.1;\n        }\n        if (XY.x > iResolution.x - gutterWidth) {\n            rgb.rgb *= 0.8;\n        }\n    }\n\n    // soft shadows.\n    if (iMouse.z > 0.0 && iMouse.z < gutterWidth) {\n        rgb   *= 0.9;\n        if (abs(gutterWidth - XY.x) < 1.1) {\n            rgb.gb += vec2(0.05);\n        }\n        if (XY.x < gutterWidth) {\n            rgb.rgb *= 0.8;\n        }\n    }\n\n    // gamma\n    rgb = pow(rgb, vec3(0.4545));\n\n\n\n    RGBA.rgb = rgb;\n}\n\n// grimoire bindings\n// out vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float gutterWidth  =   50.0;\n\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    ivec2 IJ = ivec2(XY);\n    if (IJ.x + IJ.y > 0) {\n        discard;\n    }\n\n    RGBA = texelFetch(iChannel0, IJ, 0);\n\n    if (iFrame < 5) {\n        RGBA.r = 50.0;\n    }\n    \n    if (iMouse.z > 0.0 && iMouse.z < gutterWidth) {\n        RGBA.r = iMouse.y;\n    }\n    \n    RGBA.gb = mix(RGBA.gb, iMouse.xy, 0.05);\n\n}\n\n// grimoire bindings\n// out vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}