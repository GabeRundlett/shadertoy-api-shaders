{
    "Shader": {
        "info": {
            "date": "1571939164",
            "description": "it's repeated cubes, repeated cylinder substraction  in boolean and sin wave deformation for tunnel shape\n\nforget tu publish it in public",
            "flags": 0,
            "hasliked": 0,
            "id": "3stXzN",
            "likes": 1,
            "name": "Shadertober 20 Tread",
            "published": 3,
            "tags": [
                "raymarching",
                "tunnel",
                "inktober"
            ],
            "usePreview": 0,
            "username": "GreenChicken",
            "viewed": 418
        },
        "renderpass": [
            {
                "code": "// SHADERTOBER 20 Tread\n// Poulet vert 20-10-2019\n// thanks iq, leon, and you because why not\n\n\n#define PI 3.14159\n#define MAXSTEP 64\n\nfloat ThirdRules(vec2 uv)\n{\n    float r = 0.; // final rule output\n    float rs = 0.005; // rule line size\n    float ds = 0.5; // dot size\n    \n    float hr = 0.0;\n    hr = step(fract(uv.x * 3.), rs);\n    hr *= 1. - step(uv.x, .1);\n    float d = step(fract(uv.y * 100.), ds);\n    hr = min(hr, d);\n    \n    float vr = 0.0;\n    d = step(fract(uv.x * 100.), ds);\n    vr = min(step(fract(uv.y * 3.), rs), d);\n    vr *= 1. - step(uv.y, .1);\n    \n    return max(hr, vr);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat uSDF(float s1, float s2) { return min(s1, s2);}\n\nfloat sSDF( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\n\nvec3 opRep(vec3 p, vec3 c)\n{\n     return mod(p+0.5*c,c)-0.5*c;\n}\n\nfloat opU(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nvec2 opU2( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n// Scene setup\nvec2 map(vec3 pos)\n{\n    vec2 scene = vec2(0.0, 0.0);\n    \n    float time = iTime*4.0;\n    \n    pos.z += time;\n    pos.y += sin(pos.z)*.5;\n    \n    vec3 fwp = pos+vec3(0.0);\n    fwp = opRep(fwp, vec3(0.0, 0.0, 1.0));\n    float fw = sdBox(fwp, vec3(1.5));\n    \n    vec3 sfwp = pos+vec3(0.0);\n    sfwp.zy *= rot(PI/2.0);\n    sfwp.x += sin(pos.z*5.0)*.1;\n    sfwp = opRep(sfwp, vec3(0.0, 1.0, 0.0));\n    float sfw = sdCappedCylinder(sfwp, 1.0, 2.0);\n    \n    fw = max(fw, -sfw);\n    \n    // heart\n    vec3 hp = pos + vec3(0.0, 0.0, -time);\n    hp.xz *= rot(iTime*.9);\n    hp.yx *= rot(iTime*.74);\n    hp.x += sin(iTime)*.3;\n    hp.z += sin(iTime)*.4;\n    float heart = sdOctahedron(hp, .4+abs(sin(iTime*10.)*.1));\n    \n    \n    // materials\n    scene = vec2(fw, 0.0);\n    scene = opU2(scene, vec2(heart, 1.0));\n    \n    return scene;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<128 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(float(i)/128., ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = vec3(ro + rd * t.x);\n    \n    vec3 col = vec3(0.0);\n    vec3 polyCol = palette(t.x+fract(iTime), vec3(.5), vec3(.5), vec3(1.0), vec3(0.0, 0.33, 0.67));\n    \n    if(t.x == -1.0)\n    {\n        \n        col = vec3(.1)*(length(uv)-.4);\n        \n    }\n    else\n    {\n        float depth = 1.0 - t.x;\n        \n        if(t.y == 0.0)\n        {\n            col = vec3(depth)*.4;\n        }\n        else if(t.y == 1.0)\n        {\n            col = polyCol - depth*.5;\n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 2.0 * forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    vec3 cp = vec3(0.0, sin(iTime*2.0)*.25, -5.0);\n    vec3 ct = vec3(0.0, 0.0, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = Render(cp, vd, uv);\n    \n    col.r -= uv.y*.5;\n    \n    col -= ThirdRules(screenUV)*.1;\n    \n    col -= clamp((length(uv))*.3, 0.0, 1.0);\n    \n    fragColor = vec4(sqrt(clamp(col, 0.0, 1.0)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}