{
    "Shader": {
        "info": {
            "date": "1710781681",
            "description": "use tranditional noise to simulate wave effect",
            "flags": 0,
            "hasliked": 0,
            "id": "X3SXzV",
            "likes": 15,
            "name": "colored wave effect",
            "published": 3,
            "tags": [
                "wave"
            ],
            "usePreview": 0,
            "username": "rockhard",
            "viewed": 272
        },
        "renderpass": [
            {
                "code": "   float rand(vec3 p) {\n    return fract(sin(dot(p, vec3(12.345, 67.89, 412.12))) * 42123.45) * 2.0 - 1.0;\n}\n// A perlin noise function. Since we are not using textures, we am gonna sample 8 corners of a cube.\nfloat noise(vec3 p) {\n    vec3 u = floor(p);\n    vec3 v = fract(p);\n    vec3 s = smoothstep(0.0, 1.0, v);\n    \n    float a = rand(u);\n    float b = rand(u + vec3(1.0, 0.0, 0.0));\n    float c = rand(u + vec3(0.0, 1.0, 0.0));\n    float d = rand(u + vec3(1.0, 1.0, 0.0));\n    float e = rand(u + vec3(0.0, 0.0, 1.0));\n    float f = rand(u + vec3(1.0, 0.0, 1.0));\n    float g = rand(u + vec3(0.0, 1.0, 1.0));\n    float h = rand(u + vec3(1.0, 1.0, 1.0));\n    \n    return mix(mix(mix(a, b, s.x), mix(c, d, s.x), s.y),\n               mix(mix(e, f, s.x), mix(g, h, s.x), s.y),\n               s.z);\n}\nfloat fbm(vec3 p) {   \n    vec3 q = p+vec3(0.0, 0.4, 0.26) * iTime;\n    float f = 0.5 * noise(q); \n    return clamp(f - p.y, 0.0, 1.0);\n}\nfloat map(vec3 p){ return fbm(p)+p.x; }\n\nvec3 normal(vec3 p){float t=map(p);\n    return normalize(vec3(t-map(vec3(p.x-0.0002,p.y,p.z)),\n    t-map(vec3(p.x,p.y-0.0002,p.z)),t-map(vec3(p.x,p.y,p.z-0.0002))));\n}\n#define MAXD 40.0\nfloat trace(inout vec3 p,vec3 ro, vec3 rd){  \n   float dd=0.0;      \n       for(float i = 0.0; i<16.0; i++){\n            p =ro+ rd*dd;\n            float d = map(p);dd+=d*0.6;\n            if(abs(d)<0.004) break;\n            if(dd>MAXD ){ dd = MAXD ; break; }\n        }\n        return dd;\n}\nfloat getWave(vec3 uv,vec3 camPos){\n    vec2 a = vec2(0.0,-1.2);\n    vec2 d = vec2(-1.0,1.0);\n    camPos.yz = camPos.yz*cos(a.x) + camPos.zy*d.xy*sin(a.x);\n    camPos.zx = camPos.zx*cos(a.y) + camPos.xz*d.xy*sin(a.y);\n        \n    vec3 camK = -normalize(camPos);\n    vec3 camI = normalize(cross(vec3(0.0,1.0,0.0),camK));\n    vec3 camJ = cross(camK,camI);    \n    vec3 ray = uv.x*camI + uv.y*camJ + uv.z*camK;\n    ray = normalize( ray );\n    vec3 p = vec3(0.0);\n    vec3 ro=camPos;\n    vec3 rd=ray;\n    float t = trace(p,ro,rd);  \n    vec3 n =normal(p);  \n    return 1.0- n.x;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 UV=gl_FragCoord.xy/iResolution.xy;\n vec3 uv = vec3((gl_FragCoord.xy-iResolution.xy*.5)/iResolution.x, 1.0);     \n     vec3  camPos = vec3( 0.0, 1.0, -2.6);    \n     float v=getWave(uv,camPos)*0.2;\n     camPos = vec3( 1.6, 1.0, -1.0);    \n     v+=getWave(uv,camPos)*0.6;    \n   vec3 col=vec3(UV.x*UV.x*4.4,2.6*UV.y,4.2*(1.0-UV.x))*v;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}