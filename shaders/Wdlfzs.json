{
    "Shader": {
        "info": {
            "date": "1588885209",
            "description": "weyl sequences in 1,2,3,4, and 9 dimensions\ncode to help generate it from: http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/",
            "flags": 32,
            "hasliked": 0,
            "id": "Wdlfzs",
            "likes": 7,
            "name": "Weyl sequences",
            "published": 3,
            "tags": [
                "weyl"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 444
        },
        "renderpass": [
            {
                "code": "//based on https://www.shadertoy.com/view/4dtBWH\n//see \"Common\" for the weyl functions\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat sphere(vec3 p) {\n    return length(p)-1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.x*2.;\n    bool fix = uv.x > 0.;\n    uv.x = fract(uv.x)-0.5;\n    \n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-5,0,0);\n    cam = erot(cam, vec3(0,1,0), cos(iTime));\n    init = erot(init, vec3(0,1,0), cos(iTime));\n    cam = erot(cam, vec3(0,0,1), iTime);\n    init = erot(init, vec3(0,0,1), iTime);\n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 100; i++) {\n        float dist = sphere(p);\n        if (dist*dist < 0.00001) {hit = true; break;}\n        p+=dist*cam;\n    }\n    \n    if (hit) {\n        vec2 uv = map_from_sphere(p);\n        if (fix) {\n    \t\tfragColor = vec4(1)-texture(iChannel0, uv);\n        } else {\n    \t\tfragColor = vec4(1)-texture(iChannel1, uv);\n        }\n    } else {\n        fragColor.xyz = vec3(1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float weyl_1d(int n) {\n    return fract(float(n*10368871)/exp2(24.));\n}\n\nvec2 weyl_2d(int n) {\n    return fract(vec2(n*12664745, n*9560333)/exp2(24.));\n}\n\nvec3 weyl_3d(int n) {\n    return fract(vec3(n*13743434, n*11258243, n*9222443)/exp2(24.));\n}\n\nvec4 weyl_4d(int n) {\n    return fract(vec4(n*14372619, n*12312662, n*10547948, n*9036162)/exp2(24.));\n}\n\nmat3 weyl_9d(int n) {\n    return mat3(fract(vec3(n*15595598, n*14497202, n*13476166)/exp2(24.)),\n                fract(vec3(n*12527041, n*11644764, n*10824624)/exp2(24.)),\n                fract(vec3(n*10062247, n*9353565,  n*8694794 )/exp2(24.)));\n}\n\nconst float PI = 3.141592653;\nvec3 map_to_sphere(vec2 p)\n{\n    float theta = (p.x-0.5)*PI*2.;\n    float phi = (p.y-0.5)*PI*2.;\n    return vec3(sin(phi)*sin(theta), sin(phi)*cos(theta), cos(phi));\n}\n\nvec2 map_from_sphere(vec3 p)\n{\n    p = normalize(p);\n    return vec2(atan(p.x,p.y)/PI/2.+0.5, acos(p.z)/PI/2.+0.5);\n}\n\nvec4 bufferImage( vec2 uv, vec4 data, int frame, bool type ) {\n    for (int i = 0; i < 10; i++) {\n        vec3 point;\n        if (type) {\n            vec2 weyl = weyl_2d(frame*10+i)*2.-1.;\n            float theta = 3.1415*weyl.x;\n            float yy = sqrt(1.-weyl.y*weyl.y);\n            point = vec3(weyl.y, yy*cos(theta), yy*sin(theta));\n        } else {\n            point = normalize(tan(weyl_3d(frame*10+i)*2.-1.));\n        }\n        vec3 proj = map_to_sphere(uv);\n        data *= smoothstep(0.01, 0.015, distance(point, proj));\n    }\n    return data;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    if (iFrame == 0) data = vec4(1.);\n    \n    fragColor = bufferImage(uv, data, iFrame, false);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    if (iFrame == 0) data = vec4(1.);\n    \n    fragColor = bufferImage(uv, data, iFrame, true);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}