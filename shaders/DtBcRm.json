{
    "Shader": {
        "info": {
            "date": "1691574149",
            "description": "A analytic ray intersection with a extruded checker tunnel.",
            "flags": 0,
            "hasliked": 0,
            "id": "DtBcRm",
            "likes": 4,
            "name": "ray tunnel intersection",
            "published": 3,
            "tags": [
                "tunnel",
                "light",
                "disco",
                "analytic",
                "loopless"
            ],
            "usePreview": 0,
            "username": "me_123",
            "viewed": 176
        },
        "renderpass": [
            {
                "code": "\n#define PI 3.14159525\n#define eps 0.0001\n\nfloat time = 0.0;\nconst int samples = 1; //AA samples\nconst float motionBlur = 0.0;\nvec3 tex(in vec3 p, in vec3 color0, in vec3 color1) {\n    ivec3 z = ivec3(floor(p));\n    return (z.x+z.y+z.z)%2==0?color0:color1;\n}\nstruct hit {\n    float dist;\n    vec3 normal;\n    int id;\n    vec2 extra;\n};\nhit tunnel(vec3 o, vec3 d, float count, float r1) {\n    float freq = count/PI;\n    float cellSize = 1./freq;\n    float a = 2.0*dot(d.yz, d.yz);\n    float ai = 1./a;\n    float b = 2.0*dot(o.yz, d.yz);\n    float c = dot(o.yz, o.yz)-1.0;\n    float k = (-b - sqrt(b*b-2.0*a*c))*ai;\n    float d1 = k;\n    o += d*k;\n    vec2 t = vec2(atan(o.y, o.z), o.x);\n    vec2 fc = vec2(floor(t*freq)/freq);\n    \n    if (int(freq*(fc.x+fc.y))%2 != 0) return hit(-k, vec3(0, o.yz), 0, fc);\n    \n    float plainX = -(o.x-fc.y-cellSize*0.5+cellSize*sign(d.x)*0.5)/d.x;\n    \n    float m = (count-1.0)*PI/(count*2.0);\n    vec2 dir = vec2(sin(fc.x-m), cos(fc.x-m));\n    float j = 0.5*length(vec2(sin(PI/count)-sin(2.0*PI/count), cos(PI/count)-cos(2.0*PI/count)));\n    float dp = dot(d.yz, dir);\n    float plainY = -(dot(o.yz, dir)+j*sign(dp))/dp;\n    float k1 = max(plainY, plainX)+k;\n    o -= d*k;\n    vec3 kp = o+d*k1;\n    if (length(kp.yz) < 1.0+r1) return hit(-k1, k1==(plainX+k)?vec3(sign(d.x), 0, 0):vec3(0, dir*sign(-dp)), 2, fc);\n    c += 1.0;\n    c -= (r1+1.0)*(r1+1.0);\n    float dd = (-b - sqrt(b*b-2.0*a*c))*ai;\n    k1 = max(k1, dd);\n    return hit(-k1, vec3(0, (o.yz+d.yz*dd)/(1.+r1)), 1, fc);//hit(-k1, vec3(k1==dd?vec3(0, (o.yz+d.yz*dd)/(1.0+r1)):(k1==(plainX+k)?vec3(sign(d.x), 0, 0):vec3(0, dir*sign(-dp)))), k1==dd?1:2);//sin(50.*(o+d*k1));\n}\nvec3 getColor(in vec3 o, in vec3 d) {\n    float k = 0.09;//0.5*(sin(iTime)+1.01);\n    const float mm = 10.0;\n    hit t = tunnel(o, d, mm, k);\n    float m = 1.0+k;\n    vec3 r = hash(uvec3(t.extra.xyx*100.+10000.));\n    vec3 p = o-d*t.dist;\n    float len = length(p.yz);\n    float l = 0.3/((m-len)/k+eps)-0.3;\n    return mix(mix(vec3(mix(r, r*0.8+0.2, l))*l, vec3(0.0, 0.1, 0.5), 1.-exp(-t.dist*0.1)), t.normal, 0.5);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 mr = 1./iResolution.xy;\n    vec2 mouse;\n    mouse = vec2(-PI*0.5+cos(iTime*0.1), sin(iTime*0.5)*0.1);\n    if (iMouse.z > 0.0) mouse = (iMouse.xy*mr - 0.5 - vec2(1.75, 1.0))*vec2(PI*2.0, -PI);\n    vec3 at = vec3(\n        sin(mouse.x)*cos(mouse.y),\n        cos(mouse.x)*cos(mouse.y),\n        sin(mouse.y)\n    );\n    time = iTime;\n    vec2 uv = ((fragCoord)-iResolution.xy*0.5)*max(mr.x, mr.y);\n    vec3 ro = vec3(time, sin(time)*0.5, cos(time*0.5)*0.9);\n\n    vec3 xPlain = vec3(normalize(vec2(at.y, -at.x)), 0);\n    vec3 yPlain = cross(xPlain, at);\n    vec3 rd = vec3(at + xPlain*uv.x + yPlain*uv.y);\n    fragColor = vec4(clamp(getColor(ro, rd), 0.0, 1.0), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}