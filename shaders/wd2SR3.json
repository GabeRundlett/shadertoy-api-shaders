{
    "Shader": {
        "info": {
            "date": "1554572003",
            "description": "When I started learning ray marching I basically just wanted pre-built \"scene\" that I could dive into and start tinkering with, so here is a simple example that does exactly that! No step-by-step tutorial, just simple explanations of what everything does.",
            "flags": 0,
            "hasliked": 0,
            "id": "wd2SR3",
            "likes": 13,
            "name": "Simple Raymarching Example Scene",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "tutorial"
            ],
            "usePreview": 0,
            "username": "samlo",
            "viewed": 1205
        },
        "renderpass": [
            {
                "code": "// Title: Simple Raymarching Example Scene\n// Author: Sam Loeschen https://twitter.com/samloeschen\n\n// Description:\n// When I started learning raymarching I basically just wanted pre-built \"scene\" that I could dive into and start tinkering with,\n// so here is a simple example that does exactly that! No step-by-step tutorial, just simple explanations of what everything does.\n// If you want to start messing around, the first thing I would do is modify the scene() function with more shapes. You can find \n// more primitive at https://iquilezles.org/articles/distfunctions. \n\n// Things to try:\n// 1. Check out ourBox() and ourSphere() to see how I animated the primitives and gave them material IDs.\n// 2. See if you can add a shape and material of your own.\n// 3. Play with the camera and directional light, and see if you can animate them.\n\n#define RAYMARCH_STEPS 50\n#define EPSILON 0.005\n#define BACKGROUND vec4(0, 0.3, 0.3, 1) // windows 95?\n#define MIN_DIST 0.01\n#define MAX_DIST 100.0\n\n#define BLUE_MATERIAL_ID 0.5\n#define RED_MATERIAL_ID 1.0\n\n// iq's axis to direction rotation. Aligns an axis (z) to point along a direction (d)\nmat3 rotationAlign(vec3 d, vec3 z) {\n    vec3  v = cross( z, d );\n    float c = dot( z, d );\n    float k = 1.0/(1.0+c);\n\n    return mat3(v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n                v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n                v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\n\n\n// composes a view matrix for a direction and global up vector\n// based on gluLookAt man page\nmat4 viewMatrix (vec3 dir, vec3 up) { \n    vec3 f = normalize(dir);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n// simple box sdf. for a library of other primitives, see https://iquilezles.org/articles/distfunctions\nfloat box (vec3 pos, vec3 size) {\n  vec3 d = abs(pos) - size;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n// simple sphere sdf. for a library of other primitives, see https://iquilezles.org/articles/distfunctions\nfloat sphere(vec3 pos, float radius) {\n  return length(pos) - radius;\n}\n\n// returns the distance to our rotating box and the its associated material ID packed into a vec2\nvec2 ourBox (vec3 pos) {\n\n    // get a rotation matrix for our box's rotation\n    vec3 dir = normalize(vec3(cos(iTime * 0.5), 0.0, sin(iTime * 0.5)));\n    vec3 axis = normalize(vec3(0.0, 1.0, 0.0)); // up\n    mat3 rotation = rotationAlign(dir, axis);\n\n    // rotate our world point with the box's rotation matrix\n    pos *= rotation;\n    return vec2(box(pos, vec3(1.0)), BLUE_MATERIAL_ID);\n}\n\n// returns the distance to our moving sphere and the its associated material ID packed into a vec2\nvec2 ourSphere (vec3 pos) {\n\n    // just translate the sphere up and down\n    vec3 offset = vec3(sin(iTime * 0.5), sin(iTime) * 3.0, cos(iTime) * 3.0);\n    pos += offset;\n    \n    return vec2(sphere(pos, 1.0), RED_MATERIAL_ID);\n}\n\n// this is the combined scene sdf function! if you want to add shapes, put them in here.\n// it returns a vec2 containing a depth value for the x coordinate, and a material ID for the y coordinate.\nvec2 scene (vec3 pos) {\n    // test our shapes\n    vec2 boxTest        = ourBox(pos);\n    vec2 sphereTest     = ourSphere(pos);\n    vec2 result         = boxTest;\n\n    // we want to return the nearest surface, so we sort by distance\n    result = mix(result, sphereTest, step(sphereTest.x, result.x));\n\n    // if you want to add more shapes, modify the result like so:\n    // result = mix(result, yourNewShapeTest, step(yourNewShapeTest.x, result.x));\n    return result;\n}\n\n// creates a view space ray going out from the camera\nvec3 calcRay (float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size * 0.5;\n    float z = size.y / tan(radians(fieldOfView) * 0.5);\n    return normalize(vec3(xy, -z));\n}\n\n// gets an estimated normal of the scene sdf at a given point\n// we use the x coord because that is the depth value that is returned from the scene\nvec3 calcNormal (vec3 pos) {\n    const vec2 eps = vec2(EPSILON, 0);\n    return normalize(vec3(scene(pos + eps.xyy).x - scene(pos - eps.xyy).x,\n                          scene(pos + eps.yxy).x - scene(pos - eps.yxy).x,\n                          scene(pos + eps.yyx).x - scene(pos - eps.yyx).x));\n}\n\n// returns a color based on the material id from the scene sample\n// right now it uses gross branching, but this could be eliminated with clever usage of step()\nvec3 calcMaterial (float id) {\n    if (id == RED_MATERIAL_ID)      return vec3(1, 0, 0);\n    if (id == BLUE_MATERIAL_ID)     return vec3(0, 0, 1);\n    return vec3(1);\n}\n\n// raymarches our scene with a provided camera position, camera direction, and simple directional light\nvec4 marchScene (vec2 fragCoord, vec3 camPos, vec3 camDir, vec3 lightDir) {\n    \n    // calculate the world direction of the ray at this pixel\n    vec3 viewDir = calcRay(45.0, iResolution.xy, fragCoord.xy);\n    mat4 viewMat = viewMatrix(\n        camDir,\n        vec3(0.0, 1.0, 0.0)\n    );\n    vec3 worldDir = (viewMat * vec4(viewDir, 1)).xyz;\n\n    // do our raymarching!\n    float depth = MIN_DIST;\n    for (int i = 0; i < RAYMARCH_STEPS; i++) {\n        vec3 rayPos = camPos + depth * worldDir;\n\n        // sample the scene at this point in the ray.\n        // the sample's x coord is our distance value, and the y coord is the material id\n        vec2 sceneSample = scene(rayPos);\n        float shortestDist = sceneSample.x;\n        float materialId = sceneSample.y;\n\n        if (shortestDist < EPSILON) {\n\n            // we hit something, so get estimate our normal to do lighting and return a material color\n            vec3 normal = calcNormal(rayPos);\n            float light = max(dot(lightDir, normal) * 0.5 + 0.5, 0.15); // half lambert with a floor\n            vec3 surfaceColor = calcMaterial(materialId);\n            vec4 outputColor = vec4(surfaceColor * light, 1.0);\n            return outputColor;\n        }\n\n        // increase the depth of our ray by the shortest distance to an object in the scene.\n        // since we know how far away everything is, we don't need to increment our ray in tiny steps!\n        depth += shortestDist;\n\n        // we reached our max distance and didn't hit anything, so just return the background\n        if (depth > MAX_DIST - EPSILON) {\n            return BACKGROUND;\n        }\n    }\n    return BACKGROUND;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // let's place the camera 20 units away from the origin on the negative z axis,\n    // and orient it to look at the center of the scene\n    vec3 camPos = vec3(0, 0, 20); \n    vec3 camDir = normalize(-camPos);\n\n    // we'll have our light coming from above and behind us\n    vec3 lightDir = normalize(vec3(0, 1, 1));\n\n    fragColor = marchScene(fragCoord, camPos, camDir, lightDir);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}