{
    "Shader": {
        "info": {
            "date": "1706118402",
            "description": "Flow and Rotation is hard to properly unify. So I build a little shader to show all the wierd ways to work with vectors all working in sync.",
            "flags": 0,
            "hasliked": 0,
            "id": "lfjGW3",
            "likes": 1,
            "name": "Vector Rotation & Animation Sync",
            "published": 3,
            "tags": [
                "normals",
                "animation",
                "flow",
                "vector",
                "rotation",
                "debug",
                "quiver",
                "quiverplot"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 180
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2024 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis shader shows a collection of handling various vector operations all \nsynchronized with each other. It also has mouse controls to modivy the \ncurrent direction.\n\nThe operations include:\n- Flow animation\n- Quiver Plot for debugging\n- Rotating Coordinates\n- Rotating Vectors\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Square UVs with (0,0) in the center\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y + 0.5; \n    \n    // If the mouse was not clicked, animate\n    vec2 direction;\n    if (iMouse.x > 0.0) {\n        // scale mouse coords to 0-1 range of screen\n        vec2 mouse = iMouse.xy / iResolution.xy;\n                \n        // Normalize the vector\n        direction = safeNormalize(mouse - 0.5);\n        \n    } else {\n        // Animated zoom\n        float myTime = iTime * 0.2;\n        \n        // rotate vector\n        direction = vec2(cos(myTime), sin(myTime));        \n    }\n    \n    // translate vector to color\n    vec3 color = vec3(direction *0.5+0.5, 0.5);\n\n    // Simple quasi noise\n    vec2 phaseOffset = sin(uv *6.2831 * 0.5)*0.25+0.25;\n    float phase = phaseOffset.x + phaseOffset.y;\n    \n    // Flow animation\n    float flow = flowmap(iChannel1, uv, direction, iTime*0.5).x;\n    color += (0.5 - flow) * 0.75; // apply flowmap to background\n\n    // Mask for 0-1 uv coords\n    float mask = step(.5, max(abs(uv.x-0.5), abs(uv.y-0.5)));\n\n    // Quiver Plot for debugging\n    float arrows = quiverPlot(uv, direction, 5.);    \n    color += arrows * mask;\n        \n    // cat is running left so 90 deg cc rotation\n    direction = vec2(-direction.y, direction.x);\n    \n    // Rotate UVs around the 0.5 coordinate\n    vec2 center = vec2(0.5);\n    vec2 rotatedUV = rotateUV(uv - center, direction.xy) + center;    \n    \n    // Sample cat texture (inverted uv so cat runs against direction)\n    vec4 cat = nyanCat(iChannel0, 1.-rotatedUV, iTime * 12.);\n    \n     // Blend Cat with Background\n    color = mix(color, cat.xyz, cat.w);\n    \n    // Sample Normal \"Texture\"\n    vec3 normal = debugNormal(rotatedUV);\n    \n    // Rotate Normal vector by the rotation as well\n    normal = rotateNormal(normal, direction);\n    \n    // Apply lighting to show the normals too\n    color = phongLighting(color, normal, vec3(0,0,1), normalize(vec3(1,0,1)));\n    \n    // Output to screen\n    fragColor = vec4(color,1);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Generic Functions ___________________________________________________________\n\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\n// Normalization while handling zero vectors\nvec2 safeNormalize(vec2 vector) {\n    // Calculate the square of the length of the vector\n    float lenSq = dot(vector, vector);\n    \n    // Check if the squared length is greater than a tiny threshold\n    if (lenSq > SMALLESTFLOAT) {\n        // If so, normalize the vector resuing the squared length\n        return vector / sqrt(lenSq);\n        \n    } else {\n        // Otherwise, return a default vector\n        return vec2(1.0, 0.0);\n    }\n}\n\n// Rotate UV in vector direction\nvec2 rotateUV(vec2 uv, vec2 direction) {\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2( direction.y, direction.x,\n                                -direction.x, direction.y );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// Rotate vec3 normal in vec2 direction\nvec3 rotateNormal(vec3 normal, vec2 direction) {\n    // rotate the texture counter to coordinate rotation\n    vec2 cDirection = vec2(-direction.x, direction.y);\n\n    // Rotate the XY part of the normal\n    return vec3(rotateUV(normal.xy, cDirection), normal.z);\n}\n\n// Lighting Functions _________________________________________________________________\n\n#define SUN_COLOR vec3(1.000,0.949,0.702)\n// Phong lighting model\nvec3 phongLighting(vec3 albedo, vec3 normal, vec3 cameraDir, vec3 lightDir) {\n    // Ambient\n    float ambientStrength = 0.1;\n    vec3 ambient = ambientStrength * albedo;\n\n    // Diffuse \n    float diff = clamp(dot(normal, lightDir), 0.0, 1.0);\n    vec3 diffuse = diff * albedo;\n\n    // Specular\n    float specularStrength = 1.0;\n    vec3 viewDir = normalize(cameraDir);\n    vec3 reflectDir = reflect(-lightDir, normal);  \n    float spec = pow(clamp(dot(viewDir, reflectDir), 0.0, 1.0), 36.0);\n    vec3 specular = specularStrength * spec * SUN_COLOR;  \n\n    // Combine results\n    return ambient + diffuse + specular;\n}\n\n// Texture Sample Functions __________________________________________________________\n\n// temporal Flowmap\nvec3 flowmap(sampler2D tex, vec2 uv, vec2 direction, float time) {    \n    //generate timers \n    float timeA = fract(time);\n    float timeB = fract(time +0.5);\n    \n    // sample color texture using different timers to scale offset strength\n    vec3 colorA = texture(tex, uv -((timeA-0.5) * direction)).xyz;\n    vec3 ColorB = texture(tex, uv -((timeB-0.5) * direction) +0.5).xyz;\n    \n    //float alpha = (sin((time+.25)*6.28) +1.) *0.5; // sine alpha test\n    float alpha = abs(timeA *2.-1.); \n\n    // Interpolate the two offset samples\n    vec3 color = mix(colorA, ColorB, alpha);\n    \n    // NB: trick published in https://hal.inria.fr/inria-00536064v2\n    // Modified version of FabriceNeyret2 https://www.shadertoy.com/view/4dcSDr \n    vec2 weights = vec2(alpha, 1.-alpha);    \n    float squaredAlphaSum = dot(weights, weights);       \n\n    // Sampling mips lowest level to get the mean. Can be a constant if known.\n    vec3 mean = textureLod(tex, uv, 12.).xyz; \n\n    // Variance restoration with normalization (very visible in the Stars)\n    color = mean + (color - mean) / sqrt(squaredAlphaSum);\n\n    // clamping because histogram correction sometimes overdoes it\n    return clamp(color, 0., 1.);\n}\n\n// applies Anti Aliasing to texture samples meant for pixel art\nvec4 aaTextureSample(sampler2D tex, vec2 uv) {\n    // Get the size of the texture in pixels\n    vec2 texsize = vec2(textureSize(tex, 0));\n        \n    // Scale the UV coordinates by the texture size and shift by 0.5\n    vec2 scaledUV = uv * texsize - 0.5;\n    \n    // Calculate the rate of change of `uv` to apply anti-aliasing\n\tvec2 fw = fwidth(scaledUV);\n    \n    // Apply smooth stair like pattern to the UV coordinates\n    // for the math see: https://www.desmos.com/calculator/0p2hp7look\n    vec2 uvAA = (floor(scaledUV) + smoothstep(0.5 - fw, 0.5 + fw, fract(scaledUV)) + 0.5) / texsize;\n    \n    // Sample the texture at the anti-aliased UV coordinates\n\treturn textureLod(tex, uvAA, 0.);\n}\n\n// Flipbook animation nyan cat from IQ: https://www.shadertoy.com/view/lsX3Rr\nvec4 nyanCat(sampler2D tex, vec2 uv, float time) {\n    // prevent repetition\n    vec2 catUV = clamp( uv, 0.0, 1.0 );\n    \n    // offset for flipbook animation\n\tfloat offset = floor( mod( time, 6.0 ) );\n\n    // scale cat to full uv size\n\tfloat scale = 40.0/256.0;\n    \n    // apply flipbook offset\n\tcatUV.x = catUV.x * scale + offset * scale;\n    \n    // Sample Cat texture\n    return aaTextureSample(tex, catUV);\n}\n\n// Generates a normal pattern of an elevated tile and bubble\nvec3 debugNormal(vec2 uv) {\n    // center and scale UVs\n    //uv = fract(uv);    \n    uv = ((uv) - 0.5) * 3.0; \n    \n    float blur = 0.05; // amount of blur from smoothstep\n    \n    // Masks for mooth transitions of normals\n    float diagonalA = smoothstep(-blur, blur, uv.x + uv.y);\n    float diagonalB = smoothstep(-blur, blur, uv.x - uv.y);\n    \n    float height = 1.; // 1= 45deg, less makes it flatter, more makes it steeper\n    \n    // square dent Normals\n    vec3 roof = vec3( 1, 0,height) * (    diagonalA *     diagonalB)    // Right\n              + vec3( 0, 1,height) * (    diagonalA * (1.-diagonalB))   // Up\n              + vec3( 0,-1,height) * ((1.-diagonalA) *    diagonalB)    // Down\n              + vec3(-1, 0,height) * ((1.-diagonalA) * (1.-diagonalB)); // Left\n    roof = normalize(roof);\n    \n    // Square Mask\n    float square = smoothstep(0.2+blur, 0.2-blur, abs(1.25 - max(abs(uv.x), abs(uv.y))));\n    \n    // bubble normal\n    vec3 bubble;\n    bubble.xy = sqrt(uv * uv) * sign(uv);\n    bubble.z = sqrt(abs(1.0 - dot(bubble.xy,bubble.xy)));\n    \n    // Circle Mask of the bubble\n    float circle = smoothstep(1.,1.-blur*4.,dot(uv,uv));\n    \n    // Default normal\n    vec3 normal = vec3(0,0,1);\n    \n    // Mix in the square dent normals\n    normal = mix(normal, roof, square);\n    \n    // Mix in the bubble Normals\n    normal = mix(normal, bubble, circle);\n    \n    return normal;\n}\n\n// Debug Functions _________________________________________________________________\n\n// Generates a grid of arrows that point in the direction\nfloat quiverPlot(vec2 uv, vec2 direction, float gridSize) {\n    float lineThickness = 0.03;    // Thickness of the arrow line\n    float tipSteepness = 3.0;      // Controls the angle of the arrow tip\n\n    float maxSize = 0.9;           // Maximum arrow length (1 should be the max)\n    float minSize = 0.2;           // Minimum arrow length\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(direction, direction);\n    \n    // Check if the direction vector length is almost 0\n    if (lenSq > SMALLESTFLOAT) {\n    \n        // break UV coordinates into grid sections\n        uv = fract(uv * gridSize) - 0.5;\n\n        // caculate the direction vector length    \n        float vectorLen = sqrt(lenSq); \n\n        // Scale uv by vector size\n        float size = mix(minSize, maxSize, clamp(vectorLen, 0.,1.)); \n        uv /= size;\n\n        // Rotate UV coordinates based on the normalized direction vector\n        uv = rotateUV(uv, direction / vectorLen);\n\n        // absolute position\n        float absV = abs(uv.x);\n\n        // Calculate center line of the arrow shape\n        float lineOffset = tipSteepness * lineThickness; // offset so lines doesn't go over the tip\n        float line = max(absV, abs(uv.y + lineOffset) - 0.5 + lineOffset);\n\n        // Caculation of the Arror Tip\n        float tip = max(abs((uv.y / tipSteepness) + absV - (0.5 / tipSteepness) + lineThickness), -uv.y + 0.1);\n\n        // Combine line and tip to create the arrow shape\n        float arrowDist = min(tip, line) - lineThickness;\n\n        // Create a mask based on the arrow shape\n        //return step(arrowDist, 0.0); // no AA\n        float blur = (gridSize * 1.0)/(size * 420.);\n        return  smoothstep(blur, -blur, arrowDist) ; // cheap AA\n        \n    } else {\n        // if the direction length is 0. then no arrows\n        return 0.;\n    }    \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}