{
    "Shader": {
        "info": {
            "date": "1545226746",
            "description": "A quick test scene",
            "flags": 32,
            "hasliked": 0,
            "id": "Xd2fzR",
            "likes": 80,
            "name": "Some boxes",
            "published": 3,
            "tags": [
                "3d",
                "gi",
                "pathtracing",
                "reprojection",
                "taa"
            ],
            "usePreview": 1,
            "username": "iq",
            "viewed": 5583
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2018 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // source\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n    \n    // gain\n    col *= 1.7/(1.0+col);\n    \n    // burn the highlights\n    float g = dot(col,vec3(0.3333));\n    col = mix( col, vec3(g), min(g*0.2,1.0) );\n    \n    // gamma\n    col = pow( col, vec3(0.4545) );\n\n    // instafilter\n    col = 1.15*pow( col, vec3(0.9,0.95,1.0) ) + vec3(-0.04,-0.04,0.0);\n\n    // vignete     \n\tvec2 q = fragCoord / iResolution.xy;\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    \n    // output\n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash1( uint n ) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return 1.0 - float(n&0x7fffffffU)/float(0x7fffffff);\n}\n\nvec2 hash2( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec2 k = n * uvec2(n,n*16807U);\n    return vec2( k & 0x7fffffffU)/float(0x7fffffff);\n}\n\nuint ihash1( uint n ) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nvec3 uniformVector( in uint seed)\n{\n    vec2 ab = hash2( seed*7U+11U );\n    float a = 3.141593*ab.x;\n    float b = 6.283185*ab.y;\n    return vec3( sin(b)*sin(a), cos(b)*sin(a), cos(a) );\n}\n\nvec3 cosineDirection( in uint seed, in vec3 nor)\n{\n    vec2 r = hash2( seed*7U+11U );\n\n    // by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853 * r.y;\n    float u = 2.0*r.x - 1.0;\n    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\nfloat iBox( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) tN = -1.0;\n\treturn tN;\n}\n\n// returns normal, st and face\nvoid nBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad, out vec3 outNor, out vec2 outST, out uint outFaceID ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    // intersect and select\n    vec3 s = -sign(rdd);\n    vec3 t = (-roo + s*rad)/rdd;\n    \n    // compute normal in world space\n         if( t.x>t.y && t.x>t.z ) { outNor = txi[0].xyz*s.x; outST = roo.yz+rdd.yz*t.x; outFaceID=uint(1+int(s.x))/2U; /* 0, 1 */ } \n    else if( t.y>t.z )            { outNor = txi[1].xyz*s.y; outST = roo.zx+rdd.zx*t.y; outFaceID=uint(5+int(s.y))/2U; /* 2, 3 */ }\n    else                          { outNor = txi[2].xyz*s.z; outST = roo.xy+rdd.xy*t.z; outFaceID=uint(9+int(s.z))/2U; /* 4, 5 */ }\n}\n\n//------------------------\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( in vec3 t )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t t.x, t.y, t.z, 1.0 );\n}\n\n\n#define NUMBOXES 22U\n\n// 7 are manually placed\nconst vec3 possiz[14] = vec3[14](\n    vec3(  0.0, 0.0,  0.0), vec3(10.5,0.1,10.5),\n    vec3(  0.0, 0.0,-10.0), vec3(10.5,7.5, 0.1),\n    vec3(  0.0, 0.0, 10.0), vec3(10.5,7.5, 0.1),\n    vec3( 10.0, 0.0,  0.0), vec3( 0.1,7.5,10.5),\n    vec3(-10.0, 0.0,  0.0), vec3( 0.1,7.5,10.5),\n    vec3( -7.0,-7.0,  0.0), vec3( 4.0,0.1,10.5),\n    vec3(  7.0,-7.0,  0.0), vec3( 4.0,0.1,10.5)\n    );\n\nvoid getLocation( uint id, out mat4 resMat, out vec3 resSiz )\n{\n    if( id<7U )\n    {\n        resMat = translate( possiz[2U*id+0U] );\n        resSiz = possiz[2U*id+1U];\n    }\n    else\n    {\n        resMat = rotationAxisAngle(vec3(0.3,0.4,0.5)*1.41421, -float(id*13U))* translate(vec3(0.0,-2.5,0.0)-vec3(5.0,2.0,5.0)*sin(vec3(id*43U,id*23U,id*137U)));\n        resSiz = vec3(1.1,1.6,0.08);\n    }\n}\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oNor, out vec2 oUV, out uint oID )\n{\n    float tmi = 1e20;\n    mat4  cma; \n    vec3  csi; \n    uint  cin = 0xffffffffU;    \n    \n    for( uint i=0U; i<NUMBOXES; i++ )\n    {\n        mat4 ma; vec3 si; getLocation(i, ma, si);\n\n        float res = iBox( ro, rd, ma, si );\n        if( res>0.0 && res<tmi )\n        {\n            cma = ma;\n            csi = si;\n            cin = i;\n            tmi = res;\n        }\n    }\n\n    uint resID;\n    nBox( ro, rd, cma, inverse(cma), csi, oNor, oUV, resID );\n    oID = cin*6U + resID;\n    \n    return (cin==0xffffffffU) ? -1.0 : tmi;\n}\n\nfloat castShadowRay( in vec3 ro, in vec3 rd )\n{\n    for( uint i=0U; i<NUMBOXES; i++ )\n    {\n        mat4 ma; vec3 si; getLocation(i, ma, si);\n\n        if( iBox( ro, rd, ma, si )>0.0 )\n            return 0.0;\n    }\n\treturn 1.0;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\n\nvec3 sunDir = normalize(vec3(0.5,0.9,-0.2));\nvec3 sunCol =  vec3(1.7,0.8,0.6)*10.0; \n\nvec3 doSkyCol( in vec3 rd )\n{\n    return vec3(0.3,0.4,1.20);\n}    \n\nvec4 render( in vec3 ro, in vec3 rd, uint sa, out uint oID )\n{\n    const float epsilon = 0.001;\n\n    vec3 colorMask = vec3(1.0);\n    vec3 accumulatedColor = vec3(0.0);\n    vec3 oro = ro;\n    vec3 ord = rd;\n\n    oID = (NUMBOXES+10U);\n    \n    float fdis = 0.0;\n    \n    const uint numRays = 4U;\n    \n    for( uint k=0U; k<numRays; k++ )\n    {\n        ro = oro;\n        rd = ord;\n        colorMask = vec3(1.0);\n\n        for( uint bounce = 0U; bounce<3U; bounce++ ) // bounces of GI\n        {\n            vec3 nor;\n            vec2 st;\n            uint id;\n            float t = castRay( ro, rd, nor, st, id );\n            if( t < 0.0 )\n            {\n                if( k==0U && bounce==0U ) \n                { \n                    accumulatedColor = doSkyCol(rd) * float(numRays) * 3.14;\n                    oID = (NUMBOXES+10U);\n                    fdis = 1000.0;\n                }\n                break;\n            }\n\n            uint obj = id/6U;\n            vec3 pos = ro + rd*t;\n\n            if( k==0U && bounce==0U )\n            { \n                fdis = t;\n                oID = id;\n            }\n\n\n\n            uint kid = id/6U;\n\n            vec3 surfaceColor = vec3(0.4);\n            vec3 tex = texture( iChannel3, st.yx*0.3 ).xyz;\n            if( kid>=1U && kid<=4U) tex = texture( iChannel2, st*0.2 ).xyz*vec3(0.7,0.8,0.8);\n            surfaceColor *= tex;\n\n            //-----------------------\n            // add direct lighitng\n            //-----------------------\n            colorMask *= surfaceColor;\n\n            vec3 iColor = vec3(0.0);\n\n            #if 1\n            // light 1        \n            vec3 ssundir = normalize( sunDir + 0.01*uniformVector(sa + 11U + 45U*(bounce+11U*k)) );\n\n            float sunDif =  max(0.0, dot(ssundir, nor));\n            float sunSha = 1.0; if( sunDif > 0.00001 ) sunSha = castShadowRay( pos + nor*epsilon, ssundir);\n            iColor += sunCol * sunDif * sunSha;\n            vec3 h = normalize( sunDir - rd );\n\n            float shl = 0.04 + 0.96*pow( 1.0-clamp(dot(h,-rd),0.0,1.0), 5.0 );\n            float spe = tex.x*30.0*pow( clamp( dot( nor, h ), 0.0, 1.0 ), 24.0*tex.x );\n            iColor += spe * shl * sunCol * sunSha * sunDif;\n            #endif\n\n            #if 1\n            // light 2\n            for( int i=min(0,iFrame); i<2; i++ )\n            {\n            vec3 skyPoint = cosineDirection( sa + 7U*uint(iFrame) + 47U*(k) + 13U*uint(i) + bounce*92U, nor);\n            float skySha = castShadowRay( pos + nor*epsilon, skyPoint);\n            vec3  skyCol = doSkyCol(skyPoint);\n            iColor += skyCol * skySha / 2.0;\n\n\n            vec3 h = normalize( skyPoint - rd );\n            float shl = 0.04 + 0.96*pow( 1.0-clamp(dot(h,-rd),0.0,1.0), 5.0 );\n            float spe = tex.x*250.0*pow( clamp( dot( nor, h ), 0.0, 1.0 ), 24.0*tex.x );\n            iColor += spe * shl * skyCol * skySha / 2.0;\n            }\n            #endif\n\n\n            accumulatedColor += colorMask * iColor;\n\n            //-----------------------\n            // calculate new ray\n            //-----------------------\n            float isDif = 0.8;\n            if( hash1(sa + 1U + 7U*bounce + 91U*k + 31U*uint(iFrame)) < isDif )\n            {\n               rd = cosineDirection(76U + 73U*(bounce+5U*k) + sa + 17U*uint(iFrame), nor);\n            }\n            else\n            {\n                float glossiness = 0.4;\n                rd = normalize(reflect(rd, nor)) + uniformVector(sa + 111U + 65U*(bounce+7U*k)+87U*uint(iFrame)) * glossiness;\n            }\n\n            ro = pos + epsilon*nor;\n        }\n    }\n    accumulatedColor /= float(numRays);\n   \n    return vec4( clamp(accumulatedColor,0.0,10.0), fdis );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // inputs\t\n\tvec2 off = hash2(uint(iFrame)) - 0.5;\n    vec2 p = (2.0*(fragCoord+off)-iResolution.xy)/iResolution.y;\n    uint sa = ihash1( uint(iFrame)*11U + uint(fragCoord.x) + uint(fragCoord.y)*113U );\n\t\n    // camera movement\n    float time = -2.0 + (iTime-10.0)*0.03;\n\tfloat cr = 0.1*cos(0.1);\n\tvec3 ro = vec3(8.0*cos(time), 1.0, 8.0*sin(time) );\n\tvec3 ta = vec3(0.0,3.0,0.0);\n    float fl = 1.8;\n\n\t// camera\n    mat3 cam = setCamera( ro, ta, cr );\n    vec3 rd = normalize( cam * vec3(p,-fl) );\n\n    // raytrace scene    \n    uint id;\n    vec4 ren = render( ro, rd, sa, id );\n    vec3 col = ren.xyz;\n    float t = ren.w;\n\n     \n    //------------------------------------------\n\t// reproject from previous frame and average\n    //------------------------------------------\n\n    mat4 oldCam = mat4( texelFetch(iChannel1,ivec2(0,0), 0),\n                        texelFetch(iChannel1,ivec2(1,0), 0),\n                        texelFetch(iChannel1,ivec2(2,0), 0),\n                        0.0, 0.0, 0.0, 1.0 );\n    \n    // world space\n    vec4 wpos = vec4(ro + rd*t,1.0);\n    // camera space\n    vec3 cpos = (wpos*oldCam).xyz; // note inverse multiply\n    // ndc space\n    vec2 npos = -fl * cpos.xy / cpos.z;\n    // screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0);\n    // undo dither\n    spos -= off/iResolution.xy;\n\t// raster space\n    vec2 rpos = spos * iResolution.xy - .5;\n    ivec2 ipos = ivec2(floor(rpos));\n    // blend pixel color history\n    if( (ipos.y>0 || ipos.x>2) && iFrame>0 )\n    {\n        #if 1\n        vec2 fuv = rpos - vec2(ipos);\n        vec4 odata1 = texelFetch( iChannel1, ipos+ivec2(0,0), 0 );\n        vec4 odata2 = texelFetch( iChannel1, ipos+ivec2(1,0), 0 );\n        vec4 odata3 = texelFetch( iChannel1, ipos+ivec2(0,1), 0 );\n        vec4 odata4 = texelFetch( iChannel1, ipos+ivec2(1,1), 0 );\n        vec4 ocol = vec4(0.0);\n        int n = 0;\n        if( id==uint(odata1.w) ) { ocol += vec4( odata1.xyz, 1.0)*(1.0-fuv.x)*(1.0-fuv.y); n++; }\n        if( id==uint(odata2.w) ) { ocol += vec4( odata2.xyz, 1.0)*(    fuv.x)*(1.0-fuv.y); n++; }\n        if( id==uint(odata3.w) ) { ocol += vec4( odata3.xyz, 1.0)*(1.0-fuv.x)*(    fuv.y); n++; }\n        if( id==uint(odata4.w) ) { ocol += vec4( odata4.xyz, 1.0)*(    fuv.x)*(    fuv.y); n++; }\n        if( n>2 ) col = mix( max(ocol.xyz/ocol.w,0.0), col, 0.1 );\n        else      col = mix( textureLod( iChannel1, spos, 0.0 ).xyz, col, 0.3 );\n\t\t#else\n        col = mix( textureLod( iChannel1, spos, 0.0 ).xyz, col, 0.1 );\n        #endif\n\n    }\n\n    //----------------------------------\n    // output\n\tivec2 ifc = ivec2(floor(fragCoord));\n\tif( ifc.y==0 && ifc.x<=2 )\n    {\n        // camera\n        fragColor = vec4( cam[ifc.x], -dot(cam[ifc.x],ro) );\n    }\n    else\n    {\n        // color\n        fragColor = vec4( col, id );\n    }\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}