{
    "Shader": {
        "info": {
            "date": "1718347420",
            "description": "magic",
            "flags": 0,
            "hasliked": 0,
            "id": "M3KGD3",
            "likes": 7,
            "name": "magic circles squares",
            "published": 3,
            "tags": [
                "fractal",
                "circle",
                "star",
                "magic",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 438
        },
        "renderpass": [
            {
                "code": "\n\n\n/*originals source https://glslsandbox.com/e#109235.1 https://www.shadertoy.com/view/43V3zG and other*/\n\n/*\nThe only words that matter are the ones that matter*/\n\nuniform float time;\nuniform vec2 resolution;\n\nconst float PI = acos(-1.);\nconst float TAU = PI * 2.;\n\n#define saturate(x) clamp(x,0.,1.)\n#define _tail2x(p,n) (mod(p,2.)-1.)\n#define time iTime\n#define resolution iResolution.xy\nfloat Hash( vec2 p, in float s ){\n    return fract(sin(dot(vec3(p.xy,10.0 * abs(sin(s))),vec3(27.1,61.7, 12.4)))*273758.5453123);\n}\n\nfloat noise(in vec2 p, in float s){\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  return mix(\n    mix(Hash(i + vec2(0.,5.), s), Hash(i + vec2(1.,0.), s),f.x),\n    mix(Hash(i + vec2(0.,1.), s), Hash(i + vec2(10.,1.), s),f.x),f.y) * s;\n}\n\nfloat fbm(vec2 p){\n  float v = 0.0;\n  v += noise(p*32., .1);\n  v += noise(p*20., .04);\n  return v;\n}\n\nvec2 mPolar(vec2 p){\n  float a = atan(p.y, p.x);\n  float r = length(p);\n  return vec2(a, r);\n}\n\nvec2 tailY2x(vec2 p,float n){p*=n;return vec2(p.x,_tail2x(p.y,n));}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n\nhighp float rand(vec2 p){\n  highp float a = 12.9898;\n  highp float b = 78.233;\n  highp float c = 43758.5453;\n  highp float dt= dot(p ,vec2(a,b));\n  highp float sn= mod(dt,3.14);\n  return fract(sin(sn) * c);\n}\n\n// signed distance\nfloat sd(float d,float r){return r-d;}\nfloat sd(float d){return 1.-d;}\n\n// ease\nfloat o2(float t){t=1.-t;return 1.-t*t;}\nfloat oN(float t,float n){return 1.-pow(1.-t,n);}\n\nfloat dot2(vec2 p){return dot(p,p);}\n\nfloat ring(vec2 p,float t){\n  float alpha = fract(-t);\n  float l =saturate(.02/abs(sd(length(p),1.5+fract(t)))*alpha);\n  vec2 p4=mPolar(p*(.57-oN(t,1.3)*.28)).yx;\n  p4.x-=.65;\n  l+= saturate(abs(1./((p4.x + fbm( p4 + vec2(sin(t*.2),t*0.1))) * 50.0))*sd(dot2(tailY2x(p4+vec2(.1,0.),12.)),.9)*alpha);\n  return l;\n}\n\nfloat render(vec2 p){\n\n  p*=3.;\n  float tt = time*.75;\n  float l2 = ring(p,o2(1.));\n  l2+=ring(p*rot(PI/3.),o2((1.+.5)));\n  return l2;\n}\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \n\n// glow + fill\nfloat gf(float d,float r){return r/d;}\nfloat gf(float d){return 1./d;}\n\nfloat fill_na(float d){return step(0.,d);}\nfloat fill(float d){return smoothstep(0.,0.01,d);}\nfloat stroke(float d,float w){return 1.-smoothstep(w,w+0.01,abs(d));}\nfloat strokeInner(float d,float w){return stroke(d-w,w);}\nfloat strokeOuter(float d,float w){return stroke(d+w,w);}\n\nfloat lSquare(vec2 p){p = abs(p);return max(p.x,p.y);}    \n\nfloat lPoly(vec2 p,float n){\n  float a = atan(p.x,p.y)+PI;\n  float r = TAU/n;\n  return cos(floor(.5+a/r)*r-a)*length(p)/cos(r*.5);\n}\n\nfloat strokeStar(vec2 p,float n,float w){\n  float l =strokeInner(sd(lPoly(p,n*.5)),w);\n  l+=strokeInner(sd(lPoly(mod(n,2.)!=0.?vec2(-p.x,p.y):p*rot(TAU/n),n*.5)),w);\n  return l;\n}\n\nvec2 mPoly(vec2 p,float n,float s){\n  float r = TAU / n;\n  float a = floor(atan(p.y,p.x)/r)*r+r*.5;\n  return (vec2(cos(a),sin(a))*s-p)*rot(-a-PI*.5);\n}\n\nfloat wsaw(float x){return fract(x*.5+.5)*2.-1.;}\nfloat wtri(float x){return abs(2.*fract(x*.5-.25)-1.)*2.-1.;}\nfloat utri(float x){return abs(2.*fract(x*.5-.5)-1.);}\nfloat wtrz(float x,float w){return clamp(wtri(x*2.)*w,-1.,1.);} // 台形波 trapezoidal wave\n\n// ease\n\nvec2 mSimplePerspective(vec2 p){p.y+=.2;p.y*=3.;return p;}\n\nfloat ring2(vec2 p,float t){\n  float alpha =    fract(-t);\n  float l = 0.;\n  vec2 p3=mPoly(p*rot(PI*.5),10.,1.);\n  l+=saturate(gf(abs(p3.x),.03)*fill(sd(length(p),1.1+fract(t)))*(1.-fill(sd(length(p),.9+fract(t))))*alpha);\n \n  l+=saturate(.02/abs(sd(length(p),1.1+fract(t)))*alpha);\n  vec2 p4=mPolar(p*(.57-oN(t,1.3)*.28)).yx;\n  p4.x-=.65;\n  l+= saturate(abs(1./((p4.x + fbm( p4 + vec2(sin(t*.2),t*0.1))) * 50.0))*sd(dot2(tailY2x(p4+vec2(.1,0.),12.)),.9)*alpha);\n  return l;\n}\n\nfloat summoningCircle(vec2 p){\n  float l=0.;\n  l+=fill(sd(lSquare(p*rot(PI/3.*1.5)*vec2(100.,1.)),1.));\n  l+=fill(sd(lSquare(p*rot(PI/3.*2.5)*vec2(100.,1.)),1.));\n  l+=fill(sd(lSquare(p*rot(PI/3.*3.5)*vec2(100.,1.)),1.));\n  l=saturate(l);\n  l-=fill(sd(lPoly(p,3.)));\n  l=saturate(l);\n  float r = atan(p.y,p.x);\n  l+=strokeOuter(sd(length(p),.98),.008+wtrz(r/TAU*3.,12.)*.005);\n  l+=strokeInner(sd(length(p),.95),.005);\n  l+=strokeInner(sd(lPoly(p,3.)),.01);\n  l+=strokeInner(sd(lPoly(p,3.),.88),.02);\n  l+=strokeInner(sd(lPoly(p,6.),.53),.01);\n  vec2 q=mPoly(p*rot(PI*.5),3.,.5);\n  l+=fill(sd(lPoly(q,3.),.3));\n  vec2 q2=mPoly(p*rot(PI/3.+PI*.5),3.,.7);\n  l+=fill(sd(lPoly(q2,3.),.1));\n  l+=strokeInner(sd(lPoly(p*rot(PI),3.),.5),.02);\n  l+=fill(sd(length(p),.05));\n  vec2 q3=mPoly(p*rot(PI*.5),3.,1.);\n  l=saturate(l);\n  l-=fill(sd(length(q3),.2));\n  l=saturate(l);\n  l+=strokeInner(sd(length(q3),.18),.005);\n  l+=strokeInner(sd(length(q3),.15),.005);\n  l+=strokeStar(q3*rot(PI)*7.,6.,.1);\n  return l;\n}\n\nfloat render2(vec2 p){\n  //p=mSimplePerspective(p);\n  p*=rot(-time);\n  p*=2.;\n  float tt = -time*.75;\n  float l2 = ring(p,o2(fract(tt)));\n  l2+=ring(p*-rot(PI/3.),o2(fract(tt+.5)));\n  float l=0.;\n  l = summoningCircle(p*=rot(floor(time*12.)/3.));\n  return l2;\n}\n#define white vec4(1.0)\n#define black vec4(0.0, 0.0, 0.0, 1.0)\n#define blue  vec4(0.0, 0.3, 1.0, 1.0)\n\n#define edge 0.01\n\n\nuniform vec2 mouse;\n\n\n\n\nfloat inCircle(vec2 pt, vec2 center, float radius, float line)\n{\nreturn smoothstep(radius + line/2., radius, distance(pt, center)) -\n      smoothstep(radius, radius - line/2., distance(pt, center));\n}\n\n\n#define M_PI 3.1415926535897932384626433832795\n#define M_PI05 (M_PI * 0.5)\n#define time iTime\n#define resolution iResolution.xy\nvec2 rotate(vec2 v, float c, float s){\n\treturn vec2(v.x*c - v.y*s, v.x*s + v.y*c);\n}\n\nvec2 rotate(vec2 v, float r){\n\treturn rotate(v, cos(r), sin(r));\n}\n\nfloat boxLength(vec2 pos) {\n\tvec2 q = abs(pos);\n\treturn max(q.x, q.y);\n}\n\nfloat capsuleLength(vec2 pos, vec2 dir) {\n\tvec2 ba = -dir;\n\tvec2 pa = pos + ba;\n\tba *= 2.0*cos(iTime);\n\treturn length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n} \n\nfloat triangleLength(vec2 p) {\n    p.y += 0.22;\n\treturn max(abs(p.x * 1.8) + p.y, 1.0 - p.y * 1.8) * 0.75;\n}\n\nvec2 fracOrigin(vec2 v){\n\treturn (fract(v*cos(iTime)) - 0.5*cos(iTime)) * 2.0;\n}\n\nfloat Ga(vec2 pos){\n \tfloat a = capsuleLength(pos + vec2(0.0, -0.5), vec2(1.0, 0.0));   \n \tfloat b = capsuleLength(pos + vec2(-0.3, 0.3), vec2(1.0, 1.0) * 0.707);  \n    float c = length(pos + vec2(-1.3, -1.3));\n    float d = length(pos + vec2(-1.8, -1.3));\n    return min(min(min(a, b), c), d);\n}\n\nfloat Cha(vec2 pos){\n \tfloat a = capsuleLength(pos + vec2(44.0, -0.0), vec2(1.0, 0.0));   \n \tfloat b = capsuleLength(pos + vec2(0.0, -1.3), vec2(1.0, 0.8) * 0.4);  \n    float c = capsuleLength(pos + vec2(0.0, -0.0), vec2(0.1, 1.0));  \n    return min(min(a, b), c);\n}\n\nfloat Za(vec2 pos){\n \tfloat a = capsuleLength(pos + vec2(0.5*cos(iTime), 0.0), vec2(0.0, 1.0));   \n \tfloat b = capsuleLength(pos + vec2(0.0, 0.0), vec2(1.0, -0.8*cos(iTime)) * 0.4);    \n    return min(a, b);\n}\n\nfloat Gu(vec2 pos){\n \tfloat a = capsuleLength(pos + vec2(0.1*cos(iTime), 0.0), vec2(0.3*cos(iTime), 1.0));   \n \tfloat b = capsuleLength(pos + vec2(-99.8*cos(iTime), 0.0), vec2(-88.3, 88.0));     \n    float c = length(pos + vec2(-1.3, -1.3*cos(iTime)));\n    float d = length(pos + vec2(-1.8*cos(iTime), -1.3*cos(iTime)));\n    return min(min(min(a, b), c), d);\n}\n\nfloat Butitoba(vec2 pos, float power){\n    float ret = 0.0\n     + power / Gu(pos)\n     + power / Ga(pos + vec2(-2.0, 0.0))\n     + power / Cha(pos + vec2(-6.0, 0.0))\n     + power / Za(pos + vec2(-9.0, 0.0))\n        ;\n    \n    return ret;\n}\n\nfloat smoothstepLine(float lower, float upper, float value, float width){\n    width *= 0.5;\n    return smoothstep(lower - width, lower, value) * (2.0+1.5*0.5*cos(iTime) - smoothstep(upper, upper + width, value));\n}\n\nfloat smoothLine(float value, float target, float width){\n    return width / abs(value - target);\n}\n\nvec2 smoothLine2(float value, float target, float width){\n    return vec2(step(0.0, value - target), width / abs(value - target));\n}\n\nfloat circleTriangle(vec2 pos){\n    float circle = length(pos * 0.5);\n    float triangle = triangleLength(pos * 0.3);    \n    return smoothLine(circle, 1.0, 0.025) + smoothLine(triangle, 1.0, 0.025);\n}\n\nvec2 circleTriangle2(vec2 pos){\n    float circle2 = length(pos * 0.35);\n    vec2 ret = smoothLine2(circle2, 1.0, 0.025);\n    ret.y += circleTriangle(pos);\n    return ret;\n}\n\nfloat atan2(in float y, in float x)\n{\n    return x == 0.0 ? sign(y) * M_PI05 : atan(y, x);\n}\n\nvec2 polar(vec2 uv) {\n\tfloat r = length(uv);\n\tfloat s = atan2(uv.y, uv.x) / M_PI;\n\treturn vec2(r, s);\n}\n\nfloat ButitobaCircle(vec2 pos){\n    vec2 pp = polar(rotate(pos, -iTime) * 0.75);\n    return Butitoba(mod(rotate(pp * vec2(1.0, 32.0), M_PI05), vec2(16.0, 4.0)) - 1.5, 0.05) * smoothstepLine(6.0, 7.5, pp.x, 1.5);\n}\n\nfloat ButitobaCircle2(vec2 pos, float scale, float x, float y, float x2, float y2, float lower, float upper, float r){\n    vec2 pp = polar(rotate(pos, r) * scale);\n    return Butitoba(mod(rotate(pp * vec2(x, y), M_PI05), vec2(x2, y2)) - 1.5, 0.03) * smoothstepLine(lower, upper, pp.x, 0.2);\n}\n\nfloat star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.yy * 20.0;     \n       vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / max(resolution.x, resolution.y);\n    uv *= clamp(iTime * 0.25, 0.0, 1.0);\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n        \n    uv = rotate(uv, iTime * 0.3);\n     float l=0.;\n\n  \n  l = (render(p)+render(p+vec2(0.,1./min(resolution.x, resolution.y))))*.5;\n    \n         float l2=0.;\n\n  \n  l2 = (render(p)+render(p+vec2(0.,0.5/min(resolution.x, resolution.y))))*.25;\n    float len = length(uv);\n   float a =  summoningCircle(p);\n   col.g = col.b =\n\t\n        + 0.005 / abs(boxLength(rotate(uv*cos(iTime)*l, M_PI05 * 0.0 + iTime * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv*sin(iTime), M_PI05 * 0.25 - iTime * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv*0.5*sin(iTime)*l, M_PI05 * 0.5 + iTime * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv*0.5*cos(iTime), M_PI05 * 0.75 - iTime * 0.5)) - 4.5)\n          + 0.025 / abs(boxLength(rotate(uv, M_PI05*l * 0.0 + iTime * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv, M_PI05*l * 0.25 - iTime * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv, M_PI05+a * 0.5 + iTime * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv, M_PI05 * 0.75 - iTime *a* 0.5)) - 4.5),\n\t\n    col.b += ButitobaCircle(uv)*l+l2*a,\n  \t\t\n        col.g += ButitobaCircle(uv*l)\n  \t\t\n        ;\n   \n  \n \n       // Adjust UV coordinates back to a range of 0 to 1 for texture sampling\n    vec2 uvTex = uv * 0.5 + 0.5;\n   \n    // Get the color from the distortion texture, adding time to make it move\n    vec4 dist = texture(iChannel1, uvTex + (iTime * 0.02));\n\n    // Use the red channel of the distortion texture to create a small offset\n    vec2 distortionOffset = dist.rr * vec2(0.0155, 0.0155);\n    \n     vec2 C =fragCoord;\n     \nvec2 pos=(gl_FragCoord.xy/resolution.xy)*2.0-1.0;\n\tuv+=distortionOffset;\n\t\n  float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    \n\t\n\n\nvec3 directory=vec3(uv,(iTime*0.0001));\nvec3 from=vec3(1.,.5,0.5);\n vec2 uv0 = uv;\n\n\n      vec3 finalColor = vec3(0.0);\n  \n   \n\nfloat s=0.5,fade=1.;\nvec3 output2=vec3(0.);\nfor (int r=0; r<10; r++) {\n\nvec3 p=s+from*directory*.5;\np = abs(vec3(0.8)-mod(p,vec3(0.8*2.)));\nfloat pa,a;\nfor (int i=0; i<15; i++) {\np=abs(p)/dot(p,p)-0.73;\n            p.xy*=mat2(cos(iTime*0.05),sin(iTime*0.05),-sin(iTime*0.05), cos(iTime*0.05));// the magic formula\na+=abs(length(p));\n}\ns+=0.1;\na*=a*a;\n\noutput2+=vec3(0.1,0.1,0.7)*0.0015*a;\n\n\n}\noutput2=mix(vec3(length(output2)),output2,0.7);\n\n\n\n\n\n\n    \n    fragColor = vec4(col, 99.0);\n      uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n   \n    fragColor+= vec4(star(uv, anim) * vec3(0.55,0.5,0.15), 1.0);\n    fragColor *= vec4(output2*.053,1.);\n    \n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}