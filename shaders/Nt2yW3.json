{
    "Shader": {
        "info": {
            "date": "1656617803",
            "description": "My second attempt to create a conch after the [url=https://www.shadertoy.com/view/sdVGWh]nautilus shell[/url] shader.\nThe conch was modeled in a functional graphing calculator. Place it on a more decent beach.",
            "flags": 0,
            "hasliked": 0,
            "id": "Nt2yW3",
            "likes": 39,
            "name": "Functional Conch",
            "published": 3,
            "tags": [
                "water",
                "spiral",
                "function",
                "logarithmic",
                "sand",
                "beach",
                "seashell",
                "moana",
                "conch"
            ],
            "usePreview": 1,
            "username": "harry7557558",
            "viewed": 772
        },
        "renderpass": [
            {
                "code": "// Common: Modeling\n// Image: Rendering\n\n// The conch was modeled in a \"graphing calculator\" I made.\n// (see Common for link and details)\n\n// I was inspired by:\n//  - my childhood fascination with the spiral shells of mollusks\n//  - my fascination with the sea that lasts to this day\n//  - a certain Disney movie\n//  - some thoughts when leaving high school for university\n\n// Mouse-able.\n\n// Also check my \"Nautilus Shell\" shader (modeled in GLSL):\n// https://www.shadertoy.com/view/sdVGWh\n\n\n/* CONCH INTERSECTION */\n\n// Intersect with the bounding box, used to speed up rendering\nbool boxIntersection(float offset, vec3 ro, vec3 rd, out float tn, out float tf) {\n    ro -= vec3(-0.1,0.1,0.6); // translation\n    vec3 inv_rd = 1.0 / rd;\n    vec3 n = inv_rd*(ro);\n    vec3 k = abs(inv_rd)*(vec3(0.9,1.3,0.7)+offset); // offset is positive for shadow\n    vec3 t1 = -n - k, t2 = -n + k;\n    tn = max(max(t1.x, t1.y), t1.z);\n    tf = min(min(t2.x, t2.y), t2.z);\n    if (tn > tf) return false;\n    return true;\n}\nbool intersectConch(vec3 ro, vec3 rd, inout float t, float tf, float eps) {\n    // intersect bounding box\n    float t0, t1;\n    if (!boxIntersection(0.0, ro, rd, t0, t1)) return false;\n    t1 = min(t1, tf);\n    if (t1 < t0) return false;\n    t = t0;\n    // raymarching, eps is the minimum step\n    float v0=0.0, v, dt;\n    for (int i=ZERO; i<80; i++) {\n        v = mapShell(ro+rd*t);\n        if (v*v0 < 0.0) { // intersect\n            t -= dt * v/(v-v0); // linear interpolation\n            return true;\n        }\n        dt = max(abs(v), eps);\n        t += dt;\n        if (t > t1) return false; // too far\n        v0 = v;\n    }\n    return true;\n    //return false;\n}\n\n// Soft shadow\nfloat calcShadow(vec3 ro, vec3 rd) {\n    // check bounding box\n    float t0, t1;\n    if (!boxIntersection(0.2, ro, rd, t0, t1)) return 1.0;\n    // https://iquilezles.org/articles/rmshadows\n    float sh = 1.;\n    float t = max(t0, 0.01) + 0.02*hash22(rd.xy).x;\n    for (int i=ZERO; i<40; i++) {\n        float h = 0.8*mapShell(ro + rd*t);\n        sh = min(sh, smoothstep(0., 1., 20.0*h/t));\n        t += clamp(h, 0.02, 0.5);\n        if (h<0.) return 0.0;\n        if (t>t1) break;\n    }\n    return max(sh, 0.);\n}\n\n\n/* BEACH INTERSECTION */\n\nbool intersectBeach(vec3 ro, vec3 rd, out float t, float tf) {\n    //t = -ro.z/rd.z; if (t < 0.0) return false;\n    t = 0.01;\n    float v0 = 0.0, v, dt;\n    for (int i = int(ZERO); i < 50; i++) {  // raymarching\n        if (t>tf) return false;\n        v = mapGround(ro+rd*t).x;\n        if (v*v0 < 0.0) break;\n        dt = i==int(ZERO)?v:dt*v/abs(v-v0); // divide by line derivative\n        dt = sign(dt)*clamp(abs(dt), 0.02, 1.0);\n        t += dt;\n        v0 = v;\n    }\n    t -= dt * clamp(v/(v-v0), 0., 1.); // linear interpolation\n    return true;\n}\n\n\n/* SKY */\n\nvec3 sundir = normalize(vec3(0.3,0.3,1.0));\n\nvec3 getSkyCol(vec3 rd) {\n    rd = normalize(vec3(rd.xy,max(rd.z,0.))); // prevent below horizon\n    vec3 sky = mix(vec3(0.8,0.9,1.0), vec3(0.3,0.6,0.9), rd.z); // higher => darker\n    vec3 sun = 1.5*vec3(0.95,0.9,0.5)*pow(max(dot(rd,sundir),0.), 8.); // warm color\n    return sky + sun;\n}\n\n\n/* MAIN */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // pass uniforms to Common\n    ZERO = min(iFrame, 0);\n    uTime = iTime;\n\n    // set camera\n    float rx = iMouse.z!=0.0 ? 1.65*(iMouse.y/iResolution.y)-0.05 : 0.12; // azimuthal angle\n    float rz = iMouse.z!=0.0 ? -iMouse.x/iResolution.x*4.0*3.14 : 0.5; // polar angle\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));  // far to near\n    vec3 u = vec3(-sin(rz),cos(rz),0);  // left to right\n    vec3 v = cross(w,u);  // down to up\n    vec3 ro = vec3(0,0,0.5)+6.0*w-0.5*u+0.2*v;  // ray origin\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.0*length(iResolution.xy));\n    rd = normalize(rd);  // ray direction\n\n    // ray intersection\n    float t, t1=40.;\n    int intersect_id = -1;\n    if (intersectBeach(ro, rd, t, t1)) intersect_id=0, t1=t;\n    if (intersectConch(ro, rd, t, t1, 0.02)) intersect_id=1, t1=t;\n    t = t1;\n    \n    // shading\n    vec3 p = ro+rd*t;\n    vec3 col; // final color\n    float shadow = calcShadow(p, sundir);\n    if (intersect_id == -1) { // background\n        col = vec3(1.0); // this will be blended to sky color later\n    }\n    if (intersect_id == 0) { // beach/sea\n        vec3 n = normalize(gradGround(p));\n        //n *= -sign(dot(n,rd)); // faceforward\n        vec3 albedo = mapGround(p).yzw; // raw color\n        vec3 amb = 0.2*albedo; // ambient\n        vec3 dif = 0.6*(0.3+0.7*shadow) * max(dot(n,sundir),0.0) * albedo; // diffuse\n        vec3 spc = intersectConch(p,reflect(rd,n),t1,2.,0.05) // reflection\n            ? vec3(0.05,0.045,0.04) // occluded, conch color\n            : vec3(0.2-0.1*tanh(0.5*p.y)) * getSkyCol(reflect(rd,n)); // sky color, wetter reflects more\n        col = amb+dif+spc;\n    }\n    if (intersect_id == 1) { // shell\n        vec3 n0 = gradShell(p); // raw gradient\n        //n0 *= -sign(dot(n0,rd)); // faceforward\n        vec3 n = normalize(n0); // normal\n        vec3 albedo = albedoShell(p, n0); // color based on gradient\n        vec3 amb = (0.4-0.1*dot(rd,n))*albedo; // ambient light\n        vec3 dif = albedo*(\n            vec3(0.45,0.4,0.35)*max(dot(n,sundir),0.0)+ // sunlight, warm\n            vec3(0.2,0.3,0.4)*max(n.z,0.)); // skylight, blueish\n        col = pow(amb+dif, vec3(0.8));\n    }\n    col = mix(getSkyCol(rd), col, exp(-0.04*max(t-5.,0.))); // sky blending/fog\n    col += 0.5*vec3(0.8,0.5,0.6)*pow(max(dot(rd,sundir),0.),1.5);  // sun haze\n    col = pow(0.95*col, vec3(1.25)); // adjustment\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Common: Modeling\n// Image: Rendering\n\n\n// Constants/Uniforms\nint ZERO;\nfloat uTime;\n\n\n/* SHELL */\n\n// Functional shell manually exported from this \"graphing calculator\":\n// https://harry7557558.github.io/tools/raymarching-implicit/index.html\n#define _uv float u, float v\n#define _xyz float x, float y, float z\n#define PI 3.1415926\nconst float a_o = 0.16*PI; // half of opening angle\nconst float b = 0.6; // r=e^bt\nfloat s_min(float a, float b, float k) { return -1./k*log(exp(-k*a)+exp(-k*b)); } // smoothed minimum\n\n// Cross section\nfloat C_m(_uv) { return 1.-(1.-0.01*exp(sin(12.*PI*(u+2.*v))))*exp(-5.*v*5.*v); } // mid rod\nfloat C_s(_uv) { // basic cross section\n    float _x = u-exp(-16.*v);\n    float _y = v*(1.-0.2*exp(-4.*sqrt(u*u+.1*.1)))-0.5+0.5*exp(-v)*sin(4.*u)+.2*cos(2.*u)*exp(-v);\n    return (sqrt(_x*_x+_y*_y)-0.55)*tanh(5.*sqrt(2.*u*u+(v-1.2)*(v-1.2)))+.01*sin(40.*u)*sin(40.*v)*exp(-(u*u+v*v));\n}\nfloat C_0(_uv) { return abs(C_s(u,v))*C_m(u,v); } // single layer\nfloat n_1(_uv) { return log(sqrt(u*u+v*v))/b+2.; } // index of layer\nfloat a_1(_uv) { return atan(v,u)/a_o; } // opening angle, 0-1\nfloat d_1(_uv, float s_d) { // map to layer\n    float n = n_1(u,v);\n    return 0.5*sqrt(u*u+v*v)*C_0(n>0.?n-s_d:fract(n)-s_d,a_1(u,v));\n}\nfloat C(_uv) { return min(d_1(u,v,0.5),d_1(u,v,1.5)); } // result cross section\n\n// Spiral\nfloat l_p(float x, float y) { return exp(b*atan(y,x)/(2.*PI)); } // a multiplying factor\nfloat U(_xyz) { return exp(log(-z)+b*atan(y,x)/(2.*PI)); } // xyz to cross section u\nfloat V(_xyz) { return sqrt(x*x+y*y)*l_p(x,y); } // xyz to cross section v\nfloat S_s(_xyz) { return C(U(x,y,z),V(x,y,z))/l_p(x,y); } // body\nfloat S_o(_xyz) { return sqrt(pow(C(exp(log(-z)-b/2.),-x*exp(-b/2.))*exp(b/2.),2.)+y*y); } // opening\nfloat S_t(_xyz) { return d_1(-z,sqrt(x*x+y*y),0.5); } // tip\nfloat S_a(_xyz) { return -z>0.?min(S_s(x,y,z),S_o(x,y,z)):S_t(x,y,z); } // body+tip\nfloat S_0(_xyz) { return S_a(x,y,z)-0.01-0.01*pow(x*x+y*y+z*z,0.4)\n    -0.02*sqrt(x*x+y*y)*exp(cos(8.*atan(y,x)))\n    -0.007*(0.5-0.5*tanh(10.*(z+1.+8.*sqrt(3.*x*x+y*y)))); } // subtract thickness\nfloat S_r(_xyz) { return -s_min(-S_0(x,y,z),z+1.7,10.); } // clip bottom\nfloat r_a(_xyz) { return -0.1*sin(3.*z)*tanh(2.*(x*x+y*y-z-1.5)); } // thicken the bottom \"rod\"\nfloat S(_xyz) { return S_r(x-r_a(x,y,z)*y,y+r_a(x,y,z)*x,z-0.8); }\n\n\n// Rotation matrices\nmat3 rotx(float a) { return mat3(1, 0, 0, 0, cos(a), sin(a), 0, -sin(a), cos(a)); }\nmat3 rotz(float a) { return mat3(cos(a), sin(a), 0, -sin(a), cos(a), 0, 0, 0, 1); }\n\n// Returns the SDF of the shell\nfloat mapShell(vec3 p) {\n    // position and orientation\n    vec3 q = rotz(0.125*PI)*rotx(0.38*PI)*(0.7*p-vec3(0,0,0.26));\n    // a relatively cheap bounding box to speed up rendering and reduce discontinuities\n    float bound = length(vec3(vec2(1.2,1.4)*exp(q.z*q.z),1.)*q)/exp(q.z*q.z)-1.0;\n    bound = max(bound, length(vec3(1.2,1.4,1)*(q+vec3(0,0.1,0)))-1.);\n    float boundw = 0.2;  // padding of the bounding box for continuous transition\n    if (bound > 0.0) return bound+boundw;  // outside bound\n    else {\n        float v = S(q.x,q.y,q.z); // sample raw SDF\n        // do some hacking to reduce the high gradient and discontinuities\n        // Adjusted with the help of this SDF visualizer:\n        // - https://www.shadertoy.com/view/ssKGWR\n        // - https://github.com/harry7557558/Shadertoy/blob/master/spiral/functional_conch.glsl\n        float k = 1.0-0.9/length(vec3(4.*q.xy,1.0*abs(q.z+0.7)+1.));  // reduce gradient at the bottom\n        k = 0.7*mix(k, 1.0, clamp(10.*max(-q.x,q.z-.7*q.x+0.5), 0., 1.));  // reduce a discontinuity\n        v = k*v/0.7;  // dividing by 0.7 is due to scaling\n        // continuous transition between bound and SDF\n        v = mix(v, bound+boundw, smoothstep(0.,1.,(bound+boundw)/boundw));\n        //return v; return min(v,1.0);  // this two are broken in Firefox for me\n        return min(v,0.1);\n    }\n}\n\n// Numerical gradient of the shell SDF\nvec3 gradShell(vec3 p) {\n    // https://iquilezles.org/articles/normalsSDF/\n    const float h = 0.001;\n    vec3 n = vec3(0.0);\n    for(int i=ZERO; i<4; i++) {\n        vec3 e = 2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0;\n        n += e*mapShell(p+e*h);\n    }\n    return n*(.25/h);\n}\n\n// Color calculated from position and gradient\n// Interpolating two colors based on gradient magnitude\nvec3 albedoShell(vec3 p, vec3 g) {\n    // gradient magnitude => interpolation parameter\n    float t = 0.5-0.5*cos(2.0*log(0.6*length(g)));\n    t += 0.05*sin(40.*p.x)*sin(40.*p.y)*sin(20.*p.z); // some noise\n    vec3 col = mix(vec3(0.9,0.9,0.85), vec3(0.75,0.55,0.3), t); // interpolation\n    col = min(1.2*col, vec3(1.0)); // adjustments\n    return col;\n}\n\n\n/* NOISE */\n\n// Hash function by David Hoskins, https://www.shadertoy.com/view/4djSRW, MIT license\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n// Gradient noise\nfloat GradientNoise2D(vec2 xy) {\n    float i0 = floor(xy.x), i1 = i0 + 1.0;\n    float j0 = floor(xy.y), j1 = j0 + 1.0;\n    float v00 = dot(2.0 * hash22(vec2(i0, j0)) - 1.0, xy - vec2(i0, j0));\n    float v01 = dot(2.0 * hash22(vec2(i0, j1)) - 1.0, xy - vec2(i0, j1));\n    float v10 = dot(2.0 * hash22(vec2(i1, j0)) - 1.0, xy - vec2(i1, j0));\n    float v11 = dot(2.0 * hash22(vec2(i1, j1)) - 1.0, xy - vec2(i1, j1));\n    float xf = xy.x - i0; xf = xf * xf * xf * (10.0 + xf * (-15.0 + xf * 6.0));\n    float yf = xy.y - j0; yf = yf * yf * yf * (10.0 + yf * (-15.0 + yf * 6.0));\n    return v00 + (v10 - v00)*xf + (v01 - v00)*yf + (v00 + v11 - v01 - v10) * xf*yf;\n}\n\n\n/* SEA + BEACH */\nvec4 smin(vec4 a, vec4 b, float k) {\n    // smoothed blending with color\n    float h = clamp(0.5 + 0.5 * (b.x - a.x) / k, 0., 1.);\n    float d = mix(b.x, a.x, h) - k * h * (1.0 - h);\n    return vec4(d, mix(b.yzw, a.yzw, h));\n}\nvec4 mapGround(vec3 p) {\n    // returns drgb\n    float time = 0.25*PI*uTime; // animation time\n    float beach = 0.4*tanh(0.2*p.y)-0.2*GradientNoise2D(0.5*p.xy); // height\n    beach *= smoothstep(0.,1., 0.5*(1.+exp(0.3*p.x))\n        * (length(vec2(1.4,1.0)*p.xy-vec2(-0.2,-0.2))-0.5)); // shell \"pit\"\n    float sea = -0.2+0.1*exp(sin(time)); // animated sea level\n    if (abs(p.z-sea)<0.1)  // sea wave\n        sea += 0.005*tanh(2.*max(sea-beach,0.)) * // fade when close to beach\n            sin(10.*(p.x-uTime-sin(p.y)))*sin(10.*(p.y+uTime-sin(p.x)));\n    if (abs(p.z-beach)<0.1)  // sand grains\n        beach += 0.005*tanh(5.*max(beach-sea,0.)) // fade when close to sea\n            * GradientNoise2D(50.0*p.xy);\n    vec3 seacol = mix(vec3(0.65,0.85,0.8),vec3(0.2,0.55,0.45),\n        smoothstep(0.,1.,-0.1*p.y)); // sea color, deeper when further\n    seacol = mix(vec3(1.), seacol, clamp(4.*(sea-beach),0.,1.)); // white foam\n    seacol = mix(vec3(1.1), seacol, clamp(20.*(sea-beach),0.,1.)); // whiter foam\n    vec3 beachcol = mix(vec3(0.7,0.7,0.6),vec3(0.9,0.85,0.8),\n        clamp(5.*(beach-sea),0.,1.)); // beach color, darker when wetter\n    vec4 ground = smin(vec4(-sea,seacol), vec4(-beach,beachcol), // water-sand transition\n        0.01-0.005*cos(time)); // sharper when rising, smoother when falling\n    return vec4(p.z+ground.x, min(ground.yzw,1.));\n}\nvec3 gradGround(vec3 p) {\n    // https://iquilezles.org/articles/normalsSDF/\n    const float h = 0.01;\n    vec3 n = vec3(0.0);\n    for(int i=ZERO; i<4; i++) {\n        vec3 e = 2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0;\n        n += e*mapGround(p+e*h).x;\n    }\n    return n*(.25/h);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}