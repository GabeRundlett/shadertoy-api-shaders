{
    "Shader": {
        "info": {
            "date": "1726846276",
            "description": "originals from glsl sandbox https://www.shadertoy.com/view/4scGWj",
            "flags": 0,
            "hasliked": 0,
            "id": "lXByzz",
            "likes": 1,
            "name": " current conductor",
            "published": 3,
            "tags": [
                "noise",
                "electro"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 47
        },
        "renderpass": [
            {
                "code": "uniform sampler2D texture; \nvec3 rotatex(in vec3 p, float ang) {return vec3(p.x, p.y*cos(ang)-p.z*sin(ang),p.y*sin(ang)+p.z*cos(ang)); }\nvec3 rotatey(in vec3 p, float ang) {return vec3(p.x*cos(ang)-p.z*sin(ang),p.y,p.x*sin(ang)+p.z*cos(ang)); }\nvec3 rotatez(in vec3 p, float ang) {return vec3(p.x*cos(ang)-p.y*sin(ang),p.x*sin(ang)+p.y*cos(ang),p.z); }\n#define time iTime\n#define resolution iResolution.xy\nfloat sdbox( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));}\nfloat sph(vec3 p, float r) { return length(p)-r; }\nfloat plane(vec3 p, vec3 n, float d) { return dot(p,n)-d; }\nfloat hexprism( vec3 p, vec2 h ) { vec3 q = abs(p); return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);}\n\n#define PI 3.141592653589793238486\n// Polar Repeat function by Mercury\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 1.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\nfloat scene(in vec3 p)\n{\n\n\tfloat d = 100.0;\n\tvec3 c2 =hash3(p.xy);\np.xz*= mat2(cos(time), sin(time), -sin(time), cos(time));\n\np.y = mod(p.y+cos(iTime)-0.5,1.0)-0.5;\n\n\tpModPolar(p.xz, 20.0); \n\tpModPolar(p.xy, 5.0); \n   pModPolar(p.zy, 12.0); \n\td = min(d, sdbox(p-vec3(0.5+0.2*cos(iTime),0.0,0),vec3(0.05+0.11,0.05,0.05))); \n    \n\treturn d; \n\t\n}\n\nvec3 get_normal(in vec3 p)\n{\n\n\tvec3 eps = vec3(0.001,0,0); \n\tfloat nx = scene(p+eps.xyy) - scene(p-eps.xyy); \n\tfloat ny = scene(p+eps.yxy) - scene(p-eps.yxy); \n\tfloat nz = scene(p+eps.yyx) - scene(p-eps.yyx); \n\treturn normalize(vec3(nx,ny,nz)); \n}\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise(vec3 m) {\n    return   0.5333333*simplex3d(m)\n\t\t\t+0.2666667*simplex3d(2.0*m)\n\t\t\t+0.1333333*simplex3d(4.0*m)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 p = 2.0*( gl_FragCoord.xy / resolution.xy ) - 1.0;\n\nvec2 uv = fragCoord.xy / iResolution.xy;  \n\tvec3 color = vec3(0.3); \n\t   \n\tvec3 ro = vec3(0,0,5.0);\n   \n\tvec3 rd = normalize(vec3(p.x,p.y,-1.0)); \n uv = uv * 2. -1.;  \nfloat c23=1.55; \nuv.xy*= mat2(cos(c23), sin(c23), -sin(c23), cos(c23));\n  vec2 p2 = fragCoord.xy/iResolution.x;\n  vec3 p3 = vec3(p, iTime*1.4);    \n    \n  float intensity = noise(vec3(p3*10.0+12.0));\n                          \n  float t = clamp((uv.x * -uv.x * 0.16) + 0.15, 0., 1.);                         \n  float y = abs(intensity * -t + uv.y);\n    \n  float g = pow(y, 0.2);\n                          \n  vec3 col = vec3(1.70, 1.48, 1.78);\n  col = col * -g + col;                    \n  col = col * col;\n  col = col * col;\n                          \n                    \n\tvec3 pos = ro; \n    \n\tfloat dist = 0.0; \n\tfloat d; \n\tfor (int i = 0; i < 34; i++) {\n\t\td = scene(pos); \n        \n\t\tpos += rd*d; \n\t\tdist += d; \n\t}\n\tif (dist < 100.0 && abs(d) < 0.01) {\n\t\tvec3 l = normalize(vec3(1,1,1)); \n\t\tvec3 n = get_normal(pos);\n\t\tvec3 r = reflect(rd,n); \n\t\tfloat diff = clamp(dot(n, l), 0.0, 1.0); \n\t\tcolor = 1.0*diff*vec3(0,0,1); \n\t}\n\tfragColor = vec4(color*vec3(0.2,0.5,1.2)*3., 1.0); \n     fragColor.rgb*= col*2.;    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}