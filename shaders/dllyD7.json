{
    "Shader": {
        "info": {
            "date": "1690896230",
            "description": "Rendering a multiscale triangle Truchet pattern on a subdivided triangle grid.",
            "flags": 0,
            "hasliked": 0,
            "id": "dllyD7",
            "likes": 62,
            "name": "Multiscale Triangle Truchet",
            "published": 3,
            "tags": [
                "grid",
                "triangle",
                "simplex",
                "truchet",
                "polar",
                "multiscale",
                "weave"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 597
        },
        "renderpass": [
            {
                "code": "/*\n\n    Multiscale Triangle Truchet\n    ---------------------------\n    \n    I put this together ages ago, but took a while to pretty it up\n    enough to deem it worth releasing. Anyway, if you've ever seen \n    one of these patterns on stock image sites, or wherever, and \n    wondered how they were made, I hope this helps.\n    \n    Construction is reasonably straight forward: Produce a triangle \n    grid, subdivide it, create separate concentric circle arcs around \n    each triangle cell vertex, then render each of them in random \n    order -- A quick way to do that is to randomly rotate the local \n    triangle cell coordinates then render the arcs in their original\n    order.\n    \n    If you investigate these patterns on the net, you'll see that \n    they're all flat in appearance, which look pretty cool as well, \n    however, to differentiate this example from others, I rendered \n    it in a faux 3D style.\n    \n    \n    Other examples:\n    \n    // A simpler to understand square version, for anyone interested.\n    Subdivided Grid Truchet Pattern - Shane\n    https://www.shadertoy.com/view/NdKfRD\n    \n    // An extruded simplex weave. Eventually, I'll convert this\n    // example to the 3D environment.\n    Simplex Weave - Shane\n    https://www.shadertoy.com/view/WdlSWl\n    \n    // There aren't a great deal of subdivided triangle grid examples\n    // on here, but here's a simple one.\n    tritree 2 - FabriceNeyret2 \n    https://www.shadertoy.com/view/MlsBzH\n\n\n*/\n\n// The subdivided triangle grid. Oddly enough, viewing the grid can help\n// facilate a better understanding of how a grid pattern is formed. :)\n//#define GRID \n\n// Number of possible subdivisions. Larger numbers will work,\n// but will slow your machine down. This example is designed to\n// work with numbers 0 to 2. For 3 and 4, etc, you'll need to change\n// the triangle scale variable below.\n#define DIV_NUM 2\n// Triangle scale.\n#define triSc 1./3.\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// Signed distance to a line passing through A and B.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n\n// IQ;s signed distance to an equilateral triangle.\n// https://www.shadertoy.com/view/Xl2yDW\nfloat getTri(in vec2 p, in float r){\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n   \n    p.y = p.y + r/k; \n    if(p.x + k*p.y>0.) p = vec2(p.x - k*p.y, -k*p.x - p.y)/2.;\n    p.x -= clamp(p.x, -2.*r, 0.);\n    return -length(p)*sign(p.y);\n   \n    /*   \n    const float k = sqrt(3.0);\n    p.y = abs(p.y) - r; // This one has been reversed.\n    p.x = p.x + r/k;\n    if( p.y + k*p.x>0.) p = vec2(-k*p.y - p.x, p.y - k*p.x)/2.0;\n    p.y -= clamp( p.y, -2.0, 0.0 );\n    return -length(p)*sign(p.x);\n    */  \n}\n\n\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning. By the way, this\n// will partition all repeat grid triangles, not just equilateral ones.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nconst float scale = triSc;\n\n// Rectangle scale.\nconst vec2 rect = (vec2(1./.8660254, 1))*scale;\n\n// Skewing half way along X, and not skewing in the Y direction.\nconst vec2 sk = vec2(rect.x*.5, 0)/scale;\n\n// Triangle ID.\nfloat gTri;\n\n// Number of random triangle subdivisions.\nfloat subSc = 0.;\n\n// Triangle routine, with additinal subdivision. It returns the \n// local tringle coordinates, the vertice IDs and vertices.\nvec4 getTriVerts(in vec2 p, inout mat3x2 vID, inout mat3x2 v){\n   \n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //gTri = p.x/rect.x < -p.y/rect.y? 1. : -1.;\n    // Base on the bottom (-1.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n    \n    // Vertex IDs for each partitioned triangle: The numbers are inflated\n    // by a factor of 3 to ensure vertex IDs are precisely the same. The\n    // reason behind it is that \"1. - 1./3.\" is not always the same as\n    // \"2./3\" on a GPU, which can mess up hash logic. However, \"3. - 2.\"\n    // is always the same as \"1.\". Yeah, incorporating hacks is annoying, \n    // but GPUs don't work as nicely as our brains do, unfortunately. :)\n    if(gTri<0.){\n        vID = mat3x2(vec2(-1.5, 1.5), vec2(1.5, -1.5), vec2(1.5));\n    }\n    else {\n        vID = mat3x2(vec2(1.5, -1.5), vec2(-1.5, 1.5), vec2(-1.5));\n    }\n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect/3., sk); // Unskew.\n  \n    // Centering at the zero point.\n    vec2 ctr = (v[0] + v[1] + v[2])/3.;\n    p -= ctr;\n    v[0] -= ctr; v[1] -= ctr; v[2] -= ctr;\n    \n     // Centered ID, taking the inflation factor of three into account.\n    vec2 ctrID = (vID[0] + vID[1] + vID[2])/3.;//vID[2]/3.;\n    vec2 tID = id*3. + ctrID;   \n    // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n    vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n    \n    // A number to represent the number of subdivisions a triangle\n    // has undergone.\n    subSc = 0.;\n    \n    /////////////////////////////\n    #if DIV_NUM > 0\n    \n    // The random triangle subdivsion addition. I put this together pretty\n    // quickly, so there'd probably be better ways to do it. By the way, if\n    // you know of ways to improve the following, feel free to let me know.\n    for(int j = 0; j<DIV_NUM; j++){\n    \n        // Randomly subdivide.\n        if(hash21(tID + float(j + 1)/128.)<.4){\n            \n            // Increase the subdivision number.\n            subSc++;\n\n            // Subdividing an equilateral triangle into four smaller \n            // equilateral ones. Use the \"GRID\" define and refer to the \n            // resultant imagery, if you're not sure.\n\n            mat3x2 mid, midID; // Midpoints.\n            vec3 dl; // Divding lines.\n\n            for(int i = 0; i<3; i++){\n                int ip1 = (i + 1)%3;\n                mid[i] = mix(v[i], v[ip1], .5); // Mid points.\n                midID[i] = mix(vID[i], vID[ip1], .5); // Mid point IDs.\n                // Divinding lines -- separating  the midpoints.            \n                dl[i] = distLineS(p, mid[i], mix(v[ip1], v[(i + 2)%3], .5));  \n            }\n\n            // Choosing which of the four new triangles you're in. The top\n            // triangle is above the first midpoint dividing line, the\n            // bottom right is to the right of the next diving line and the\n            // bottom left is to the left of the third one. If you're not in\n            // any of those triangles, then you much be in the middle one...\n            // By the way, if you know of better, faster, logic to subdivide\n            // a triangle into four smaller ones, feel free to let me know. :)\n            //\n            if(dl[0]<0.){ // Top.   \n                v[0] = mid[0]; vID[0] = midID[0];\n                v[2] = mid[1]; vID[2] = midID[1];        \n            }\n            else if(dl[1]<0.){ // Bottom right.   \n                v[1] = mid[1]; vID[1] = midID[1];\n                v[0] = mid[2]; vID[1] = midID[2];        \n            }\n            else if(dl[2]<0.){ // Bottom left.   \n                v[2] = mid[2]; vID[2] = midID[2];\n                v[1] = mid[0]; vID[1] = midID[0];        \n            }  \n            else { // Center.\n               v[0] = mid[0]; vID[0] = midID[0];\n               v[1] = mid[1]; vID[1] = midID[1];\n               v[2] = mid[2]; vID[2] = midID[2];  \n               gTri = -gTri;\n            }\n\n            // Triangle center coordinate.\n            ctr = (v[0] + v[1] + v[2])/3.;\n            // Centering the coordinate system -- vec2(0) is the triangle center.\n            p -= ctr;\n            v[0] -= ctr; v[1] -= ctr; v[2] -= ctr;\n\n             // Centered ID, taking the inflation factor of three into account.\n            ctrID = (vID[0] + vID[1] + vID[2])/3.;//vID[2]/3.;\n            tID += ctrID;   \n            // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n            vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n        }\n    }\n    \n    #endif\n\n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, tID);\n}\n\n//////////\n// Rendering a colored distance field onto a background. I'd argue that\n// this one simple function is the key to rendering most vector styled\n// 2D Photoshop effects onto a canvas. I've explained it in more detail\n// before. Here are the key components:\n//\n// bg: background color, fg: foreground color, sf: smoothing factor,\n// d: 2D distance field value, tr: transparency (0 - 1).\nvec3 blend(vec3 bg, vec3 fg, float sf, float d, float tr){\n\n     return mix(bg, fg, (1. - smoothstep(0., sf, d))*tr);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Global scaling and translation.\n    float gSc = 1.;\n    // Smoothing factor, based on global scaling.\n    float sf = gSc/iResolution.y;\n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera in the north easterly (top right) direction. \n    vec2 p = rot2(-3.14159/12.)*uv*gSc - vec2(-.57735, -1)*iTime/32.;\n    \n \n    // Cell coordinate, ID and triangle orientation id.\n    // Cell vertices and vertex ID.\n    mat3x2 v, vID;\n    \n    // Returns the local coordinates (centered on zero), cellID, the \n    // triangle vertex ID and relative coordinates.\n    vec4 p4 = getTriVerts(p, vID, v);\n    p = p4.xy;\n    vec2 triID = p4.zw;\n    float tri = gTri;\n    \n    float sL = length(v[0] - v[1]);\n    \n    // Grid triangles. Some are upside down.\n    //vec2 q = tri<0.? p*vec2(1, -1) : p;\n    vec2 q = p*vec2(1, tri); // Equivalent to the line above.\n    float tr = getTri(q, length(v[0])*.8660254);\n\n   \n    // Nearest vertex ID.\n    float vert = 1e5;\n    vec3 arc, ang; // Three vertex arcs and corresponding angles.\n   \n    \n    // Random value based on the overall triangle ID.\n    float rnd = hash21(triID + .1);\n    \n    // Random rotation, in incrents of 120 degrees to maintain symmetry.\n    p = rot2(floor(rnd*72.)*6.2831853/3.)*p;\n    \n    \n\n    // Nearest vertex, vertex-arc and angle (subtended from each vertex) calculations.\n    for(int i = 0; i<3; i++){\n    \n        // Current vertex. By the way, you could change this to a hexagon or\n        // dodecahedron metric, and multiply the side length variable, \"sL\" by\n        // \"sqrt(3)/2\" to produce a straight line pattern.\n        float vDist = length(p - v[i]);\n        \n        // Nearest overall vertex.\n        vert = min(vert, vDist); \n        \n \n        // One of three arcs that loop around each vertex. This is still\n        // circle distance at this point, but the rest of the calculations \n        // are performed outside the loop (see below).\n        arc[i] = (vDist - sL*2./3.);\n       \n        // Angle of each pixel on each arc. As above, further calculations\n        // are performed outside the loop for speed.\n        vec2 vp = p - v[i];\n        ang[i] = atan(vp.y, vp.x);\n    }\n    \n\n    \n    // The concentric line number; It needs to be a factor of three. I've opted\n    // for a tightly bound pattern. Using something like \"6.\" will work, but due\n    // to the shading setup, changing the global triangle \"scale\" variable to \n    // something higher will look better.\n    const float lNum = 1.*3.; \n    // Side length factor that halves each time the triangle subdivides.\n    // Using: \"pow(2, a) = exp2(a)\" and \"exp2(a)/exp2(b) = exp2(a - b)\".\n    float sL0 = sL*exp2(subSc - float(DIV_NUM)); \n    float lW = sL0/lNum;// Concentric line width.\n    vec3 ln = abs(mod(arc + lW/2., lW) - lW/2.) - lW/4.; // Repeat lines.\n \n \n     \n    // Restricing the concentric line field to the vertex arc size.\n    ln = max(arc - lW/4., ln);\n    //ln -= lW/4.*.15; // Change the colored line width, if so desired.\n  \n        \n\n\n     // RENDERING.\n    \n    // Background, set to black.\n    vec3 col = vec3(0);\n    \n    // Resolution factor for shadow width -- It's a hack to make sure shadows\n    // have the same area influence at different resolutions. If you think it's\n    // confusing, you'll get no arguments from me. :)\n    float resF = iResolution.y/450.;\n    \n    // Using the angle (subtented to the arc vertex) to create some faux shading.\n    vec3 sh = -cos(ang*6.)*.5 + .5;\n    \n    // Rendering the three sets of double arcs.\n    for(int i = 0; i<3; i++){\n\n\n        // Concentric line color.\n        vec3 lnCol = mix(vec3(1, .6, .2), vec3(1, .1, .2), 1./(1. + sh[i]));\n        lnCol *= sh[i]*.35 + .65;\n \n        // White concentric line color, which some added shading.\n        vec3 lnCol2 = vec3(1)*((sh[i]*sh[i])*.4 + .6);\n        \n        // Just a hack to lighten the spokes around the vertices.\n        // It's not really necessary and not entirely accurate. \n        lnCol2 = blend(lnCol2, lnCol2 + .15, sf*2., vert - lW, 1. - sh[i]);      \n   \n   \n        // Rendering.\n        // Very subtle drop shadows, tapered by the shadow factor, which \n        // was a last minute hack to avoid triangle boundary issues. \n        col = blend(col, lnCol2/32.,  sf*6.*resF, arc[i] - lW/4., sqrt(sh[i]));\n        \n        // Two colored lines and dark edges.\n        col = blend(col, lnCol2, sf, arc[i] - lW/4. + .005, 1.); // Colored line.\n        //col = blend(col, vec3(0), sf*2.*resF, ln[i], sh); // Line shadows.\n        col = blend(col, vec3(0), sf, ln[i], 1.); // Edges.\n        col = blend(col, lnCol, sf, ln[i] + .005, 1.); // White lines.   \n   \n\n    } \n    \n    \n    #ifdef GRID\n    // Grid boundaries.\n    col = blend(col, vec3(0), sf, abs(tr) - .004, 1.);\n    col = blend(col, vec3(1, .6, .2)*1.5, sf, abs(tr) - .0005, 1.);\n    #endif\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./32.);\n    // Colored variation.\n    //col = mix(col.zyx, col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./8.));\n\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}