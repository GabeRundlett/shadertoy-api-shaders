{
    "Shader": {
        "info": {
            "date": "1537827144",
            "description": "Messing around with reflections and fractals. Quite punishing for the GPU.",
            "flags": 0,
            "hasliked": 0,
            "id": "MtVyWK",
            "likes": 21,
            "name": "Reflective fractal",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "reflection"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 664
        },
        "renderpass": [
            {
                "code": "// Created by mrange/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// Messing around with reflections and fractals. I am quite new to shader programming\n//  and raymarching so while I think the code might not be very good I also think that\n//  what makes ShaderToy.com so good is that programmers are sharing what they do, \n//  big and small. I too want to share in the hope it might help someone on my level.\n// \n// Inpiration and code from shaders:\n//  https://www.shadertoy.com/view/4ds3zn (iq, fractal)\n//  https://www.shadertoy.com/view/XljGDz (otaviogood, \"skybox\")\n//  https://www.shadertoy.com/view/Xl2GDW (purton, inspiration for reflection)\n// Blogs:\n//  Raymarching explained: http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\n//  Distance Estimators: iquilezles.org/articles/distfunctions\n//  Cool primitives: http://mercury.sexy/hg_sdf/\n\n\n#define TOLERANCE       0.0005\n#define MAX_RAY_LENGTH  64.0\n#define MAX_BOUNCES     4\n#define MAX_RAY_MARCHES 160\n#define APOLLO          7\n\n#define AA              1 // Set to 0 if the framerate is low\n\n#define FADEINTIME      3.0\n#define FADEOUTTIME     42.0\n\nvec3 saturate(in vec3 a)   { return clamp(a, 0.0, 1.0); }\nvec2 saturate(in vec2 a)   { return clamp(a, 0.0, 1.0); }\nfloat saturate(in float a) { return clamp(a, 0.0, 1.0); }\n\nvoid pR(inout vec2 p, float a) { p = cos(a)*p + sin(a)*vec2(p.y, -p.x); }\n\nfloat maxComp(in vec3 p) { return max(p.x,max(p.y,p.z)); }\n\nfloat sdSphere(in vec3 p, in float r) { return length(p) - r; }\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3  di = abs(p) - b;\n  float mc = maxComp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nfloat sdCross(in vec3 p, float r)\n{\n  float xz = length(p.xz) - r;\n  float xy = length(p.xy) - r;\n  float yz = length(p.yz) - r;\n    \n  return min(min(xz, xy), yz);\n}\n\nfloat hollowBox(in vec3 p)\n{\n  float s = 10.0;\n  p /= s;\n  float t = iTime;\n  pR(p.xz, -t);\n  pR(p.xy, t/3.0);\n  pR(p.yz, t/5.0);\n  \n  float d = max(sdBox(p, vec3(1.0)), -sdCross(p, 0.9));\n\n  return s*d;\n}\n\nfloat apollian(vec3 p, float s)\n{\n  float scale = 1.0;\n\n  for(int i=0; i<APOLLO;i++)\n  {\n    p        = -1.0 + 2.0*fract(0.5*p+0.5);\n\n    float r2 = dot(p,p);\n\t\t\n    float k  = s/r2;\n    p       *= k;\n    scale   *= k;\n  }\n\t\n  return 0.25*abs(p.y)/scale;\n}\n\nfloat obj(in vec3 p, out vec3 col, out float ref)\n{\n  p = vec3(p.z, p.y, p.x);\n  col = vec3(0.75);  \n  ref = 0.4;\n    \n  float b = sdBox(p, vec3(0.45, 0.5, 1.0));\n  if(b >= TOLERANCE*100.0)\n  {\n    return b;\n  }\n  else\n  {\n    float a = apollian(p - vec3(0.0, -0.5, 0.0), 1.17);\n    \n    float rr = 0.24;\n    float s0 = sdSphere(p - vec3(0.45, -0.2, 0.0), rr);\n    float s1 = sdSphere(p - vec3(-0.45, -0.2, 0.0), rr);\n    float s  = min(s0, s1);\n  \n    return max(b, max(a, -s));\n  }\n}\n\nfloat distanceField(in vec3 p, out vec3 col, out float ref)\n{\n  float i   = obj(p, col, ref);\n\n  float c   = sdBox(p - vec3(0.0, -0.7 + 0.01, 0.0), vec3(2.0, 0.2, 2.0));\n\n  float s   = min(i, c);\n    \n  float hb  = hollowBox(p);\n\n  s = min(s, hb);\n\n  if (s == c)\n  {\n    col = vec3(0.75);  \n    ref = 0.4;\n  }\n  else if (s == hb)\n  {\n    col = vec3(0.2);  \n    ref = 0.0;\n  }\n\n  return s;\n\n}\n\nconst vec3 lightPos1 = 20.0*vec3(-0.3, 0.15, 1.0);\nconst vec3 lightPos2 = 20.0*vec3(-0.33,  -0.2, -1.0);\nconst vec3 lightCol1 = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3 lightCol2 = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\n\nvec3 getSkyColor(in vec3 rayDir)\n{\n  vec3 lightDir1 = normalize(lightPos1);\n  vec3 lightDir2 = normalize(lightPos2);\n  float ld1      = max(dot(lightDir1, rayDir), 0.0);\n  float ld2      = max(dot(lightDir2, rayDir), 0.0);\n  vec3 final     = vec3(0.125);\n\n  if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n  float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n  final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n  \n  final += pow(lightCol1, vec3(2.0, 1.5, 1.5)) * pow(ld1, 8.0);\n  final += lightCol1 * pow(ld1, 200.0);\n  final += pow(lightCol2, vec3(2.0, 1.5, 1.5)) * pow(ld2, 8.0);\n  final += lightCol2 * pow(ld2, 200.0);\n  return final;\n}\n\nvec3 normal(in vec3 pos)\n{\n  vec3 col;\n  float ref;\n  vec3  eps = vec3(.0001,0.0,0.0);\n  vec3 nor;\n  nor.x = distanceField(pos+eps.xyy, col, ref) - distanceField(pos-eps.xyy, col, ref);\n  nor.y = distanceField(pos+eps.yxy, col, ref) - distanceField(pos-eps.yxy, col, ref);\n  nor.z = distanceField(pos+eps.yyx, col, ref) - distanceField(pos-eps.yyx, col, ref);\n  return normalize(nor);\n}\n\nfloat rayMarch(in vec3 ro, inout vec3 rd, in float mint, in float maxt, out int rep, out vec3 col, out float ref)\n{\n  float t = mint;\n  for (int i = 0; i < MAX_RAY_MARCHES; i++)\n  {\n    float distance = distanceField(ro + rd*t, col, ref);\n    float tolerance = TOLERANCE * t;\n    if (distance < TOLERANCE || t > maxt) break;\n    t += max(distance, 0.001);\n    rep = i;\n  }\n  return t;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n  vec3 col    = vec3(0.0);\n  float ragg2 = 1.0;\n    \n  for (int i = 0; i < MAX_BOUNCES; ++i)\n  {\n    if (ragg2 < 0.01) break;\n    vec3 mat    = vec3(0.0);\n    float rscale= 0.0;\n    int rep     = 0;\n    float t     = rayMarch(ro, rd, 0.01, MAX_RAY_LENGTH, rep, mat, rscale);\n  \n    vec3 pos    = ro + t*rd;\n    vec3 nor    = vec3(0.0, 1.0, 0.0);\n    \n    if (t < MAX_RAY_LENGTH)\n    {\n      // Ray intersected object\n      nor = normal(pos);\n    }\n    else\n    {\n      // Ray intersected sky\n      col += ragg2*getSkyColor(rd);\n      break;\n    }\n\n    float occ = pow(1.0 - float(rep)/float(MAX_RAY_MARCHES), 1.5);\n\n    vec3 ref  = reflect(rd, nor);\n      \n    vec3 ld1  = normalize(lightPos1 - pos);\n    float dif1= max(dot(nor,ld1),0.0);\n\n    vec3 ld2  = normalize(lightPos2 - pos);\n    float dif2= max(dot(nor,ld2),0.0);\n      \n    vec3 acol = vec3(0.0);\n    acol      += pow(dif1*lightCol1, vec3(0.5));\n    acol      += pow(dif2*lightCol2, vec3(0.5));\n    acol      *= occ;\n    acol      = saturate(acol);\n    acol      = pow(acol, vec3(2.0));\n    acol      *= mat;\n    \n    col        += ragg2*acol*(1.0 - rscale);\n    ragg2      *= rscale;\n\n    ro        = pos;      \n    rd        = ref;\n  }\n    \n \n  return col;\n}\n\nvec3 getSample(in vec2 p)\n{\n  float z = 4.0*(1.0 - smoothstep(0.0, 20.0, iTime)) + 0.55;\n  vec3 ro = vec3(0.0, -0.25 + 0.5*(z - 0.55), z);\n  vec3 la = vec3(0.0, -0.25, 0.25);\n  pR(ro.xz, iTime/4.0);\n    \n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 q=fragCoord.xy/iResolution.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n#if AA == 0\n  vec3 col = getSample(p);\n#elif AA == 1\n  vec3 col  = vec3(0.0);\n  vec2 unit = 1.0/iResolution.xy;\n  for(int y = 0; y < 2; ++y)\n  {\n    for(int x = 0; x < 2; ++x)\n    {\n      col += getSample(p - 0.5*unit + unit*vec2(x, y));\n    }\n  }\n\n  col /= 4.0;\n#endif\n\n  float fadeIn = smoothstep(0.0, FADEINTIME, iTime);\n  //float fadeOut = 1.0 - smoothstep(FADEOUTTIME, FADEOUTTIME + FADEINTIME, iTime);\n  float fadeOut = 1.0;\n\n  fragColor = vec4(col*fadeIn*fadeOut, 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}