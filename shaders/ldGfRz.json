{
    "Shader": {
        "info": {
            "date": "1527424095",
            "description": "Simulates the interference of light reflected by a soap/oil-film.\nThe upper bar shows a film thickness of 0um (left) to 5um (right).\nThe lower bar shows a horizontal cut through the film.\nFluid from flockaroo: https://www.shadertoy.com/view/MsGSRd",
            "flags": 48,
            "hasliked": 0,
            "id": "ldGfRz",
            "likes": 89,
            "name": "Reflective Interference",
            "published": 3,
            "tags": [
                "light",
                "interference",
                "oil",
                "soap",
                "cfg"
            ],
            "usePreview": 1,
            "username": "pyBlob",
            "viewed": 2171
        },
        "renderpass": [
            {
                "code": "const float PI = radians(180.);\n\nfloat height(vec2 uv)\n{\n    float h = length(texture(iChannel0, uv).xyz);\n    return 0.5e-6 + 2.0e-6 * h;\n}\n\nfloat height2(vec2 uv)\n{\n    return 5e-6 * uv.x;\n}\n\nconst int bands = 5;\nconst float f1 = 0.5; // 1st reflection\nconst float f2 = 1.0; // 2nd reflection\n\nvec2 light(float w, float s)\n{\n    s *= 2.0*PI/w;\n    return vec2(cos(s), sin(s));\n}\n\nfloat power(vec2 l)\n{\n    return dot(l, l);\n}\n\nfloat interference(float w, float wd, float h)\n{\n    float tot = 0.0;\n    for (int i=-bands ; i<=bands ; i++)\n    {\n        float id = float(i)/float(bands);\n        float cw = w + wd * id;\n        \n        vec2 l = vec2(0); // light/phase\n        float f = 1.0; // alpha\n\n        // 1st, distance = 0  , shift = PI\n        l += -light(cw, 0.0*h) * f * f1;\n        f *= 1.0-f1;\n\n        // 2nd, distance = 2*h, shift = 0\n        l += +light(cw, 2.0*h) * f * f2;\n        f *= 1.0-f2;\n\n    \tfloat sensitivity = cos(id * PI)+1.0;\n        tot += sensitivity * power(l) / float(bands*2+1);\n    }\n    return tot;\n}\n\nvec3 measure(float h)\n{\n    return vec3(\n        interference(650e-9, 60e-9, h),\n        interference(532e-9, 40e-9, h),\n        interference(441e-9, 30e-9, h)\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0);\n\n    float cut = iMouse.y/iResolution.y;\n    if (cut == 0.0)\n        cut = 0.5;\n    if (uv.y <= 0.1)\n    {\n        col = measure(height(vec2(uv.x, cut)));\n    }\n    else if (uv.y <= 0.2)\n    {\n        float y = (uv.y-0.1)/0.1;\n        vec2 muv = vec2(uv.x, cut);\n        col = measure(height(muv));\n        vec3 dc = \n            measure(height(muv+vec2(0.5/iResolution.x,0.0))) -\n            measure(height(muv-vec2(0.5/iResolution.x,0.0)))\n            ;\n        col = mix(vec3(1.0), vec3(0.0), smoothstep(0.0, 10.0/iResolution.y, abs(col-vec3(y))-abs(dc*0.5)));\n    }\n    else if (uv.y <= 0.8)\n    {\n        col = measure(height(uv));\n        col = sqrt(col);\n        col = mix(vec3(1.0), col, smoothstep(0.0, 0.5/iResolution.y, abs(uv.y-cut)-0.5/iResolution.y));\n    }\n    else if (uv.y <= 0.9)\n    {\n        float y = (uv.y-0.8)/0.1;\n        vec2 muv = uv;\n        col = measure(height2(muv));\n        vec3 dc = \n            measure(height2(muv+vec2(0.5/iResolution.x,0.0))) -\n            measure(height2(muv-vec2(0.5/iResolution.x,0.0)))\n            ;\n        col = mix(vec3(1.0), vec3(0.0), smoothstep(0.0, 10.0/iResolution.y, abs(col-vec3(y))-abs(dc*0.5)));\n    }\n    else\n    {\n        col = measure(height2(uv));\n    }\n\n    fragColor = vec4(pow(col, vec3(1./2.2)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = m*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = m*p;\n        }\n        b*=2.0;\n    }\n    \n    fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n    vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n    fragColor.xy += (0.01*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n    if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}