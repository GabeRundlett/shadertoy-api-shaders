{
    "Shader": {
        "info": {
            "date": "1501794700",
            "description": "I saw a gif and just wanted to make a shader of it. Code is far from being nice or efficient, but i don't care... ^_^\n[url]http://gph.is/2vGZBdt[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "ldjfzd",
            "likes": 27,
            "name": "Stereo boxes",
            "published": 3,
            "tags": [
                "projection",
                "box",
                "orthographic",
                "symmetry",
                "gif",
                "boxes",
                "gifs",
                "copies",
                "reproductions"
            ],
            "usePreview": 0,
            "username": "danb",
            "viewed": 1476
        },
        "renderpass": [
            {
                "code": "const int MAX_ITER = 1000;\nconst float MAX_DIST = 20.0;\nconst float EPSILON = 0.001;\n\nconst float pi = 3.14159;\n\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n\nmat2 rot(float phi)\n{\n    return mat2(cos(phi), -sin(phi),\n                sin(phi),  cos(phi));\n}\n\nfloat wave_model(float phi)\n{\n    phi = mod(phi, 4.0 * pi);\n    \n    return   phi <= pi / 2. ? phi\n           : phi <= 2. * pi ? pi / 2.\n           : phi <= 5.0 * pi / 2. ? pi / 2. - (phi - 2. * pi)\n           : 0.;\n}\n\n#define W(dt) smoothstep(0.0, 1.0, wave_model(t + dt)) * cube_dist_param + 0.2\n\nfloat cube_size = 0.1;\nfloat cube_dist_param = 0.21;\nfloat scale = 0.75;\nfloat distfunc(vec3 pos)\n{\n\tfloat t = iTime * 2.0;\n    \n    float last_dist = 10000.0;\n    for (float i = -1.0; i < 2.0; i += 1.0)\n    {\n        for (float j = -1.0; j < 2.0; j += 1.0)\n    \t{\n            for (float k = -1.0; k < 2.0; k += 1.0)\n    \t\t{\n                float a = W(pi / 2.0);\n                float b = W(pi);\n                float c = W(0.0);\n                vec3 rotpos = pos;\n                rotpos.yz *= rot(-pi / 5.0);\n                rotpos.xz *= rot(pi / 4.0);\n        \t\tfloat next_dist = box(rotpos + vec3(i * a, j * b, k * c), vec3(cube_size)) * scale;\n        \t\tlast_dist = min(last_dist, next_dist);\n            }\n        }\n    }\n    \n    return last_dist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat t = iTime;\n    \n    vec3 color = vec3(0.1484375, 0.140625, 0.15234375);\n    \n    // screenPos can range from -1 to 1\n    vec2 s_pos =  (2.0 * fragCoord - iResolution.xy)  / iResolution.y;\n    \n    // up vector\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // camera position\n\tvec3 c_pos = vec3(0.0, 0.0, 8.0);\n    // camera target\n    vec3 c_targ = vec3(0.0, 0.0, 0.0);\n    // camera direction\n    vec3 c_dir = normalize(c_targ - c_pos);\n    // camera right\n    vec3 c_right = cross(c_dir, up);\n    // camera up\n    vec3 c_up = cross(c_right, c_dir);\n    // camera to screen distance\n    float c_sdist = 2.0;\n    \n    // compute the ray direction\n    vec3 r_dir = normalize(c_dir);\n    // ray progress, just begin at the cameras position\n    vec3 r_prog = c_pos + c_right * s_pos.x + c_up * s_pos.y;\n    \n    float total_dist = 0.0;\n    float dist = EPSILON;\n    \n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        if (dist < EPSILON || total_dist > MAX_DIST)\n        {\n            break;\n        }\n        \n        dist = distfunc(r_prog);\n        total_dist += dist;\n        r_prog += dist * r_dir;\n    }\n    \n    if (dist < EPSILON)\n    {   \n        vec2 eps = vec2(0.0, EPSILON);\n        vec3 normal = normalize(vec3(distfunc(r_prog + eps.yxx) - distfunc(r_prog - eps.yxx),\n                                     distfunc(r_prog + eps.xyx) - distfunc(r_prog - eps.xyx),\n                                     distfunc(r_prog + eps.xxy) - distfunc(r_prog - eps.xxy)));\n        \n        vec3 l1_col = vec3(0.83203125, 0.21875, 0.19921875);\n        vec3 l1_dir = normalize(vec3(4.0, 1.95, -1.0));\n        \n        vec3 l2_col = vec3(0.109375, 0.5546875, 0.59375);\n        vec3 l2_dir = normalize(vec3(0.0, -1.0, -0.35));\n        \n        vec3 l3_col = vec3(0.8984375, 0.59765625, 0.05078125);\n        vec3 l3_dir = normalize(vec3(-4.0, 1.95, -1.0));\n        \n        float l1_diffuse = max(0.0, dot(-l1_dir, normal));\n\t\tfloat l1_specular = pow(l1_diffuse, 32.0);\n\n        float l2_diffuse = max(0.0, dot(-l2_dir, normal));\n\t\tfloat l2_specular = pow(l2_diffuse, 32.0);\n\n        float l3_diffuse = max(0.0, dot(-l3_dir, normal));\n\t\tfloat l3_specular = pow(l3_diffuse, 32.0);\n\n        color = (l1_col * (l1_diffuse + l1_specular) +\n                 l2_col * (l2_diffuse + l2_specular) +\n                 l3_col * (l3_diffuse + l3_specular));\n    }\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}