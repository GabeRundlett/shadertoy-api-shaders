{
    "Shader": {
        "info": {
            "date": "1505460357",
            "description": "GI Rendering for more complex procedural 'table pool' scene. Try it on fullscreen.\nYou can control light position using mouse.",
            "flags": 32,
            "hasliked": 0,
            "id": "llfyRj",
            "likes": 29,
            "name": "Let's play!!",
            "published": 3,
            "tags": [
                "gi",
                "lighting",
                "rendering",
                "pt"
            ],
            "usePreview": 1,
            "username": "koiava",
            "viewed": 1531
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Display : average down and do gamma adjustment\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    \n    if( iFrame>0 )\n    {\n        col = texture( iChannel0, uv ).xyz;\n        col = pow( col, vec3(0.4545) );\n    }\n    \n    \n    // color grading and vigneting\n    col = pow( col, vec3(0.8,0.85,0.9) );\n    \n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\"Cloth Texture Simulation\" by Emmanuel Keller aka Tambako - February 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\nconst float tbrl = 3.;\nconst float difi = 0.73;\nconst float specint = 0.002;\nconst float specshin = 0.8;\nconst float aoint = 0.42;\nconst float ssstrmr = 0.18;\nconst float sssInt = 0.35;\n\nconst float txti0 = 0.4;\nconst float txtf = 30.;\n\nfloat normdelta = 0.00002;\n\nconst float fr0 = 0.022;\nfloat fr;\nconst float fe = 0.057;\nconst float fd = 0.395;\nconst float fds = 0.176;\nconst float twf = 65.;\nconst float twfs = -110.;\nconst float clsize = 60.;\nconst float tdv = 0.22;\nconst float tdd = 0.15;\nconst float ttwd = 0.002;\nconst float crv = 0.2;\nconst vec2 ffa = vec2(0.14, 0.37);\nconst float fft = 0.68;\n\nconst float maxdist = 1500.;\n\n\n#define SPECULAR\n#define SH_OA\n#define SS_SCATERING\n#define COL_TEXTURE\n#define POSSIZE_VAR\n\nfloat gtf;\nfloat gtf2;\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\n// Simple \"random\" function\nfloat random(float co)\n{\n    return fract(sin(co*752.19) * 238.5);\n}\n\nfloat map_f_hor(vec3 pos, vec2 delta, float n)\n{\n    return length(vec2(mod(pos.y + delta.x, fe) - fe*0.6, pos.z + delta.y + fr*sin((pos.x + fe*2. + fe*floor(pos.y/fe))/fe*pi))) - fr*fds*0.86;\n}\n\nfloat hsf;\nfloat map_hor_small(vec3 pos, vec2 delta, float n)\n{\n    float fy = 132.*random(12.54*floor(pos.y/fe));\n    float ad = 1. + ttwd*hsf;\n                          \n    float angle = ad*twf*pos.x;\n    vec2 d1 = rotateVec(vec2(fr*fd, fr*fd), angle);\n    vec2 d2 = d1.yx*vec2(1., -1);\n    return min(min(min(map_f_hor(pos, d1 + delta, n + 1.), map_f_hor(pos, d2 + delta, n + 2.)), map_f_hor(pos, -d2 + delta, n + 3.)), map_f_hor(pos, -d1 + delta, n + 4.)); \n}\n\nfloat pyd;\nfloat map_hor(vec3 pos)\n{  \n    float fy = 132.*random(1.254*floor(pos.y/fe));\n\n    fy = 17.5*random(2.452*floor(pos.y/fe));\n    pyd = fe*tdd*(1. - 0.45*0.5*sin(pos.x*2.15 + 13.*fy) - 0.3*0.5*sin(pos.x*4.12 + 42.*fy) - 0.25*0.5*sin(pos.y*8.72 + 70.*fy));\n    pos.y+= pyd;\n\n    hsf = 0.35*sin(pos.x*4.3 + 20.*fy) + 0.4*sin(pos.x*5.7 + 45.*fy) + 0.25*sin(pos.x*8.48 + 55.*fy);\n    fr = fr0*(-tdv*0.5 + 1. - 0.5*tdv*hsf);\n    \n    float angle = twfs*pos.x;\n    vec2 d1 = rotateVec(vec2(fr*fds, fr*fds), angle);\n    vec2 d2 = d1.yx*vec2(1., -1);\n    return min(min(min(map_hor_small(pos, d1, 1.), map_hor_small(pos, d2, 5.)), map_hor_small(pos, -d2, 9.)), map_hor_small(pos, -d1, 13.)); \n}\n\nfloat map_f_ver(vec3 pos, vec2 delta, float n)\n{\n    return length(vec2(mod(pos.x + delta.x, fe) - fe*0.6, pos.z + delta.y - fr*sin((pos.y + fe*2. + fe*floor(pos.x/fe))/fe*pi))) - fr*fds*0.86;\n}\n\nfloat vsf;\nfloat map_ver_small(vec3 pos, vec2 delta, float n)\n{    \n    float fx = 145.*random(19.36*floor(pos.x/fe));\n    float ad = 1. + ttwd*vsf;            \n    \n    float angle = ad*twf*pos.y;\n    vec2 d1 = rotateVec(vec2(fr*fd, fr*fd), angle);\n    vec2 d2 = d1.yx*vec2(1., -1);\n    return min(min(min(map_f_ver(pos, d1 + delta, n + 1.), map_f_ver(pos, d2 + delta, n + 2.)), map_f_ver(pos, -d2 + delta, n + 3.)), map_f_ver(pos, -d1 + delta, n + 4.)); \n}\n\nfloat pxd;\nfloat map_ver(vec3 pos)\n{   \n    float fx = 145.*random(1.936*floor(pos.x/fe));\n    \n    fx = 45.8*random(1.885*floor(pos.x/fe)); \n    pxd = fe*tdd*(1. + 0.45*0.5*sin(pos.y*1.3 + 27.*fx) + 0.3*0.5*sin(pos.y*3.7 + 74.*fx) - 0.25*0.5*sin(pos.y*9.48 + 112.*fx));\n    pos.x+= pxd;\n    \n    vsf = 0.35*tdv*sin(pos.y*4.3 + 31.*fx) - 0.4*tdv*sin(pos.y*5.7 + 58.*fx) - 0.25*tdv*sin(pos.y*8.48 + 38.*fx);\n    fr = fr0*(-tdv*0.5 + 1. - 0.5*tdv*vsf);\n    \n    float angle = twfs*pos.y;\n    vec2 d1 = rotateVec(vec2(fr*fds, fr*fds), angle);\n    vec2 d2 = d1.yx*vec2(1., -1);\n    return min(min(min(map_ver_small(pos, d1, 1.), map_ver_small(pos, d2, 5.)), map_ver_small(pos, -d2, 9.)), map_ver_small(pos, -d1, 13.)); \n}\n\nfloat map_s(vec3 pos)\n{  \n    vec3 pos0 = pos;\n    float fy = 132.*random(1.254*floor(pos.y/fe));\n    fr = fr0*(-tdv*0.5 + 1. - 0.5*hsf);\n\n    pos.y+= pyd;\n    float fh = length(vec2(mod(pos.y, fe) - fe*0.6, pos.z + fr*sin((pos.x + fe*2. + fe*floor(pos.y/fe))/fe*pi))) - fr*1.1;\n \n    pos = pos0;\n    \n    float fx = 145.*random(1.936*floor(pos.x/fe));\n    fr = fr0*(-tdv*0.5 + 1. - 0.5*vsf);\n    \n    pos.x+= pxd;\n    \n    float fv = length(vec2(mod(pos.x, fe) - fe*0.6, pos.z - fr*sin((pos.y + fe*2. + fe*floor(pos.x/fe))/fe*pi))) - fr*1.1;\n    return min(fh, fv);\n}\n\nfloat map_s2(vec3 pos)\n{\n    return mix(map_s(pos), abs(pos.z) - fr*1.1, smoothstep(14., 23., iTime));\n}\n\nfloat map(vec3 pos)\n{\n    float disth = map_hor(pos);\n    float distv = map_ver(pos);\n    return mix(min(disth, distv), map_s2(pos), gtf);\n}\n\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float o;\n    float t = -cam.z/ray.z -0.05;\n    \n  \tfor (int i = 0; i < 64; ++i)\n    {\n    \tvec3 pos = ray*t + cam;\n    \tfloat dist = map(pos);\n        if (dist<0.0006 || dist>maxdist)\n        {\n            o = (abs(dist-map_ver(pos))<abs(dist-map_hor(pos))?1.:0.);\n            break;\n        }\n        t+= dist*(0.85 + float(i)*0.02);\n  \t}\n  \treturn vec2(t, o);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\nvec3 getNormal(vec3 pos, float e, float o)\n{\n    vec2 q = vec2(0., e); //vec2(0.,distance(campos, pos)*0.0005);\n    return normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),\n                          map(pos + q.xyx) - map(pos - q.xyx),\n                          map(pos + q.xxy) - map(pos - q.xxy)));\n}\n\nvec4 char(vec2 pos, float c) {\n    pos = clamp(pos,0.,1.);  // would be more efficient to exit if out.\n\n    vec4 tx= texture( iChannel3, pos/16. + fract( floor(vec2(c, 15.999-c/16.)) / 16. ) )*2. ;\n    vec4 ty= texture( iChannel3, pos/16.012 + fract( floor(vec2(c, 15.999-c/16.012)) / 16.012 ) )/3.0 ;\n  \n    vec4 tz= texture( iChannel2,pos);\n    \n    return  vec4((tx+ty)/(tz*3.0));\n    // possible variants: (but better separated in an upper function) \n    //     - inout pos and include pos.x -= .5 + linefeed mechanism\n    //     - flag for bold and italic \n}\n\nbool is_inf(float val) {\n#if __VERSION__ >= 300\n    return isinf(val);\t//webGL 2.0 is required\n#else\n\treturn val != val;\n#endif\n}\n\nvec3 getBallTexture(vec2 uv, vec3 color, bool solid, int number) {\n    uv = uv.yx;\n    \n    //const float PI = 3.1415926;\n    //const float HPI = PI * 0.5;\n    //uv -= vec2(0.5);\n    //uv /= vec2(cos(uv.x*HPI), cos(uv.y*HPI));\n    //uv /= vec2(2.0,3.0);\n    //uv += vec2(0.5);\n    \n    vec2 dirToCenter = vec2(0.5, 0.5) - vec2(uv.x + (0.5-uv.x)*0.5, uv.y);\n    float d = sqrt(dot(dirToCenter, dirToCenter));\n    vec3 white = vec3(1.0, 1.0, 0.9);\n    float edgeBlend = 0.003;\n    float r = 0.07;\n    \n    if(d > r + edgeBlend) {\n        if(solid) {\n            return color;\n        } else {\n            d = abs(uv.x - 0.5);\n            if(d < 0.18 - edgeBlend) {\n                return color;\n            } else if(d > 0.18 + edgeBlend) {\n                return white;\n            } else {\n                vec3 c = texture(iChannel2,uv*1.5).xyz;\n                \n                float dirt= length(c);\n                float blend = ((d - (0.18 - edgeBlend))/(2.0*edgeBlend))*dirt;\n        \t\treturn mix(color, white, blend);\n            }\n        }\n    } else if(d < r - edgeBlend){\n        vec2 scale = vec2(5.0, 8.0);\n        vec4 num = char(uv*scale - 0.5*scale + vec2(0.5), 48.0 + float(number));\n        num.xyz = vec3(1.0) - num.xxx*2.0;\n        return mix(white, num.xyz, num.w);\n    } else {\n        vec3 c = texture(iChannel2,uv*1.5).xyz;\n        float dirt= length(c);\n        float blend = ((d - (r - edgeBlend))/(2.0*edgeBlend))*dirt;\n        return mix(white, color, blend);\n    }\n}\n\nvec3 getCueTexture(vec2 uv) {\n    vec3 wood = texture( iChannel1, uv.yx ).xyz;\n    \n    if(uv.y > 1.0)\n        return wood;\n    \n    float k = fract(uv.x / 0.2);\n    \n    if(k < 0.5) {\n        return wood * (((0.5-k)*0.4 < uv.y-0.5)?vec3(1.0):vec3(0.01));\n    }else {\n        return wood * (((k-0.5)*0.4 < uv.y-0.5)?vec3(1.0):vec3(0.01));\n    }\n}\n\nvec3 getCueNormal(vec2 uv) {\n    const float heightScale = 0.004;\n\n    vec2 res = vec2(256.0, 256.0);\n    vec2 duv = vec2(1.0) / res.xy;\n    vec3 c  = getCueTexture( uv).xyz;\n    vec3 c1 = getCueTexture( uv + vec2(duv.x, 0.0)).xyz;\n    vec3 c2 = getCueTexture( uv - vec2(duv.x, 0.0)).xyz;\n    vec3 c3 = getCueTexture( uv + vec2(0.0, duv.y)).xyz;\n    vec3 c4 = getCueTexture( uv - vec2(0.0, duv.y)).xyz;\n    \n    float h0\t= heightScale * dot(c , vec3(1.0/3.0));\n    float hpx = heightScale * dot(c1, vec3(1.0/3.0));\n    float hmx = heightScale * dot(c2, vec3(1.0/3.0));\n    float hpy = heightScale * dot(c3, vec3(1.0/3.0));\n    float hmy = heightScale * dot(c4, vec3(1.0/3.0));\n    float dHdU = (hmx - hpx) / (2.0 * duv.x);\n    float dHdV = (hmy - hpy) / (2.0 * duv.y);\n    \n    return normalize(vec3(dHdU, dHdV, 1.0));\n}\n\n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n    vec2 uv = (fragCoord.xy + vec2(rnd(),rnd())) / iResolution.xy;\n    if(uv.x > 0.9 && uv.y > 0.6) {\n        //uv = clamp(uv, vec2(0.9, 0.6), vec2(1.0));\n        vec2 uv2 = uv*2.0 - 1.0;\n        uv2.x*= iResolution.x/iResolution.y;\n        uv2.x *= 0.97;\n        uv2.y *= 1.13;\n\n        vec3 campos = vec3(uv2, 10.0);\n        vec3 ray = vec3(0.0, 0.0, -1.0);\n        vec2 t = trace(campos, ray, maxdist);\n        float tx = t.x;\n        vec3 col;\n        vec3 n = vec3(0.0, 0.0, 1.0);\n\n        if (tx<maxdist)\n        {\n            vec3 pos = campos + tx*ray;\n\n            if (abs(pos.x)>clsize || abs(pos.y)>clsize)\n                n = vec3(0.0, 0.0, 1.0);\n\n            n = getNormal(pos, normdelta, t.y);\n        }\n\n        if(uv.y > 0.8){\n            n.y = -n.y;\n    \t\tn.z += 0.1;\n        \tfragColor = vec4((n+vec3(1.0))*0.5,1.0);\n        } else {\n            float depth;\n            if (tx<maxdist) {\n                depth = (1.0 - ((tx - 9.95) * 15.0));//*n.z;\n            } else {\n                depth = 0.03;\n            }\n            \n            vec3 green = vec3(0.2, 1.0, 0.3)*depth;\n            if(depth > 0.6) {\n            \tvec3 yellow = vec3(0.5, 6.0, 0.2)*0.35;\n                green = mix(green, yellow, max(0.0, depth - 0.6)/0.4);\n            }\n            \n            fragColor = vec4(green,1.0);\n        }\n    } else if(uv.x > 0.6 && uv.y > 0.6) {\n        uv.x -= 0.6;\n        uv.y -= 0.6;\n        uv /= vec2(0.3, 0.4);\n        fragColor = vec4(getBallTexture(uv, vec3(0.0, 0.1, 0.4), false, 1),1.0);\n    } else if(uv.x > 0.3 && uv.y > 0.6) {\n        uv.x -= 0.3;\n        uv.y -= 0.6;\n        uv /= vec2(0.3, 0.4);\n        fragColor = vec4(getBallTexture(uv, vec3(0.5, 0.0, 0.0), false, 8),1.0);\n    } else if(uv.y > 0.6) {\n        uv.y -= 0.6;\n        uv /= vec2(0.3, 0.4);\n        fragColor = vec4(getBallTexture(uv, vec3(0.6, 0.6, 0.1), true, 3),1.0);\n    } else if(uv.y > 0.3) {\n        uv.y -= 0.3;\n        uv /= vec2(1.0, 0.3);\n        fragColor = vec4(getCueTexture(uv.yx),1.0);\n    } else  {\n        uv.y -= 0.3;\n        uv /= vec2(1.0, 0.3);\n        fragColor = vec4((getCueNormal(uv.yx)+vec3(1.0))*0.5,1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define PIXEL_SAMPLES \t\t1\n#define DL_SAMPLES\t\t\t1\n#define MAX_DEPTH\t\t\t3\n#define LENS_SIZE\t\t\t0.3\n#define CLAMP_VALUE\t\t\t2.0\n#define CLAMP_CAUSTICS\n#define TEXTURES\n\n//#define SPHERE_LIGHT\n\nconst vec3 backgroundColor = vec3( 0.0 );\n\nbool is_inf(float val) {\n#if __VERSION__ >= 300\n    return isinf(val);\t//webGL 2.0 is required\n#else\n\treturn val != val;\n#endif\n}\n\n\n//used macros and constants\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.0001 \n#define EQUAL_FLT(a,b,eps)\t(((a)>((b)-(eps))) && ((a)<((b)+(eps))))\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n//********************************************\n\n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n//////////////////////////////////////////////////////////////////////////\n// Converting PDF from Solid angle to Area\nfloat PdfWtoA( float aPdfW, float aDist2, float aCosThere ){\n    if( aDist2 < EPSILON )\n        return 0.0;\n    return aPdfW * abs(aCosThere) / aDist2;\n}\n\n// Converting PDF between from Area to Solid angle\nfloat PdfAtoW( float aPdfA, float aDist2, float aCosThere ){\n    float absCosTheta = abs(aCosThere);\n    if( absCosTheta < EPSILON )\n        return 0.0;\n    \n    return aPdfA * aDist2 / absCosTheta;\n}\n\nfloat misWeight( in float a, in float b ) {\n    float a2 = a*a;\n    float b2 = b*b;\n    float a2b2 = a2 + b2;\n    return a2 / a2b2;\n}\n//////////////////////////////////////////////////////////////////////////\n\nvec2 rotateVec(vec2 v, float angle) {\n    vec2 cs = vec2(cos(angle), sin(angle));\n    return vec2(dot(v, cs), dot(v, vec2(cs.y, -cs.x)));\n}\n\nvec3 toVec3( vec4 v ) {\n    if( IS_ZERO( v.w ) ) {\n        return v.xyz;\n    }\n    \n    return v.xyz*(1.0/v.w);\n}\n\nvec3 orthogonalize(in vec3 n, in vec3 v) {\n    return v - n * dot(n, v);\n}\n\n#if __VERSION__ >= 300\nmat3 mat3Inverse( in mat3 m ) { return inverse(m); }\nmat4 mat4Inverse( in mat4 m ) {return inverse(m);}\n#else\nmat3 mat3Inverse( in mat3 m ) {\n    return mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n\t\t\t\t\tvec3( m[0][1], m[1][1], m[2][1] ),\n                    vec3( m[0][2], m[1][2], m[2][2] ) );\n}\n\n//fast inverse for orthogonal matrices\nmat4 mat4Inverse( in mat4 m ) {\n    mat3 rotate_inv = mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n                          \tvec3( m[0][1], m[1][1], m[2][1] ),\n                          \tvec3( m[0][2], m[1][2], m[2][2] ) );\n    \n    return mat4(\tvec4( rotate_inv[0], 0.0 ),\n                \tvec4( rotate_inv[1], 0.0 ),\n                \tvec4( rotate_inv[2], 0.0 ),\n              \t\tvec4( (-rotate_inv)*m[3].xyz, 1.0 ) );\n}\n#endif\n      \nstruct SurfaceHitInfo {\n    vec3 position_;\n\tvec3 normal_;\n    vec3 tangent_;\n    vec2 uv_;\n    int mtl_id_;\n};\n    \n#define SURFACE_ID_BASE\t0\n#define LIGHT_ID_BASE\t64\n\n#define MTL_LIGHT \t\t0\n#define MTL_DIFFUSE\t\t1\n    \n\n#define OBJ_PLANE\t\t0\n#define OBJ_SPHERE\t\t1\n#define OBJ_CYLINDER\t2\n#define OBJ_AABB\t\t3\n#define OBJ_DISK\t\t4\n#define OBJ_CONE\t\t5\n    \nstruct Object {\n    int type_;\n    int mtl_id_;\n    mat4 transform_;\n    mat4 transform_inv_;\n    \n    float params_[6];\n};\n\n//Weighted sum of Lambertian and Blinn brdfs\nstruct Material {\n    vec3 diffuse_color_;\n    int diffuse_color_tex_;\n    vec3 specular_color_;\n    float specular_roughness_;\n    int specular_roughness_tex_;\n    float specular_weight_;\n    int specular_weight_tex_;\n    int normal_map_;\n    float tex_scale_;\n};\n    \nstruct Light {\n    vec3 color_;\n    float intensity_;\n};\n    \nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \nstruct Camera {\n    mat3 rotate;\n    vec3 pos;\n    float fovV;\n    float lensSize;\n    float focusDist;\n};\n    \nstruct LightSamplingRecord {\n    vec3 w;\n    float d;\n    float pdf;\n};\n    \n// ************ SCENE ***************\nLight lights[2];\nMaterial materials[7];\nObject objects[8];\nCamera camera;\n//***********************************\nMaterial getMaterial(int i) {\n#if __VERSION__ >= 300\n    return materials[i];\t//webGL 2.0\n#else\n    if(i==0) return materials[0]; \n    if(i==1) return materials[1]; \n    if(i==2) return materials[2]; \n    if(i==3) return materials[3]; \n    if(i==4) return materials[4]; \n    if(i==5) return materials[5]; \n    return materials[6];\n#endif \n}\n\nLight getLight(int i) {\n#if __VERSION__ >= 300\n    return lights[i];\n#else\n    if(i==0) return lights[0]; else\n        return lights[1];\n#endif\n}\n\nvec3 getBallTexture(vec2 uv, int number) {\n    uv = uv.yx;\n    \n    const float HPI = PI * 0.5;\n    //uv -= vec2(0.5);\n    //uv *= vec2(acos(uv.x)/HPI, cos(uv.y)/HPI);\n    //uv *= vec2(2.0,3.0);\n    //uv += vec2(0.5);\n    \n    uv *= vec2(0.3, 0.4);\n    if(number == 1) {\n        uv += vec2(0.6, 0.6);\n    }else if(number == 8) {\n        uv += vec2(0.3, 0.6);\n    } else {//ball number 3\n        uv += vec2(0.0, 0.6);\n    }\n    return texture(iChannel2,uv).xyz;\n}\n\nvec3 getCueColor(vec2 uv) {\n    uv = uv.yx;\n    uv *= vec2(1.0, 0.3);\n    uv += vec2(0.0, 0.3);\n    return texture(iChannel2,uv).xyz;\n}\n\nvec3 getCueNormal(vec2 uv) {\n    uv = uv.yx;\n    uv *= vec2(1.0, 0.3);\n    uv += vec2(0.0, 0.3);\n    return texture(iChannel2,uv).xyz*2.0 - vec3(1.0);\n}\n\nconst float fabric_tex_rot = 0.13;\nconst vec2 fabric_tex_scale = vec2(120.0, 80.0);\nvec3 getFabricColor(vec2 uv) {\n    float aa = texture(iChannel1,uv).r*0.5 + texture(iChannel1,uv.yx).r*0.5;//add some more inperfection\n    aa = aa*0.5 + 0.2;\n    //return vec3(0.2, 0.7, 0.3);\n    uv = rotateVec(uv, fabric_tex_rot);\n    uv *= fabric_tex_scale;\n    uv = mod(uv, vec2(1.0, 1.0));\n    uv *= vec2(0.1, 0.2);\n    uv += vec2(0.9, 0.6);\n    uv = clamp(uv, vec2(0.901, 0.601), vec2(1.0, 0.796));\n    vec3 c = texture(iChannel2,uv).xyz*aa;\n    return c;//normalize(c*2.0 - vec3(1.0));\n}\n\nvec3 getFabricNormal(vec2 uv) {\n    //return vec3(.0, .0, 1.);\n    uv = rotateVec(uv, fabric_tex_rot);\n    uv *= fabric_tex_scale;\n    uv = mod(uv, vec2(1.0, 1.0));\n    uv *= vec2(0.1, 0.2);\n    uv += vec2(0.9, 0.8);\n    uv = clamp(uv, vec2(0.901, 0.801), vec2(1.0, 0.996));\n    vec3 n = texture(iChannel2,uv).xyz*2.0 - vec3(1.0);\n    return normalize(n);\n}\n\nvec3 getColor(vec2 uv, int tex) {\n    vec3 c;\n#ifdef TEXTURES\n    if(tex==0) c = texture( iChannel0, uv ).xyz; else\n    if(tex==1) c = texture( iChannel1, uv ).xyz; else\n    if(tex==2) c = texture( iChannel2, uv ).xyz; else\n    if(tex==3) c = texture( iChannel3, uv ).xyz; else\n    if(tex==4) c = getBallTexture(uv, 1); else\n    if(tex==5) c = getBallTexture(uv, 8); else\n    if(tex==6) c = getBallTexture(uv, 3); else\n    if(tex==7) c = getCueColor(uv); else\n    if(tex==8) c = getFabricColor(uv); else\n    c = vec3(0.0);\n#else\n    c = vec3(1.0, 1.0, 1.0);\n#endif\n    \n    return clamp(c, 0.0, 1.0);\n}\n\nvec2 getTexRes(int tex) {\n#if __VERSION__ >= 300\n    if(tex>=0 && tex < 4){\n        return iChannelResolution[tex].xy;\n    }\n#else\n    if(tex==0) return iChannelResolution[0].xy;\n    if(tex==1) return iChannelResolution[1].xy;\n    if(tex==2) return iChannelResolution[2].xy;\n    if(tex==3) return iChannelResolution[3].xy;\n#endif\n    \n    return vec2(2048, 2048);\n}\n\nvec3 getNormal(vec2 uv, int tex ) {\n    if(tex == 8) {return getFabricNormal(uv);}\n    if(tex == 7) {return getCueNormal(uv);}\n    return vec3(0.0, 0.0, 1.0);\n}\n\nvec3 getRadiance(vec2 uv) {\n    return vec3(1.0, 1.0, 1.0)*lights[0].intensity_;\n}\n\nvoid createMaterial(vec3 diff,\n                    int diff_tex,\n                    vec3 spec,\n                    float roughness,\n                    int roughness_tex,\n                   \tfloat weight,\n                    int weight_tex,\n                    int normal_map,\n                    float tex_scale,\n                    out Material mtl) {\n    mtl.diffuse_color_ = diff;\n    mtl.diffuse_color_tex_ = diff_tex;\n    mtl.specular_color_ = spec;\n    mtl.specular_roughness_ = roughness;\n    mtl.specular_roughness_tex_ = roughness_tex;\n    mtl.specular_weight_ = weight;\n    mtl.specular_weight_tex_ = weight_tex;\n    mtl.normal_map_ = normal_map;\n    mtl.tex_scale_ = tex_scale;\n}\n\nvoid createLight(vec3 color, float intensity, out Light light) {\n    light.color_ = color;\n    light.intensity_ = intensity;\n}\n\nvoid createAABB( mat4 transform, vec3 bound_min, vec3 bound_max, int mtl, out Object obj) {\n    vec3 xAcis = normalize( vec3( 0.9, 0.0, 0.2 ) );\n    vec3 yAcis = vec3( 0.0, 1.0, 0.0 );\n    obj.type_ = OBJ_AABB;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = bound_min.x;\n    obj.params_[1] = bound_min.y;\n    obj.params_[2] = bound_min.z;\n    obj.params_[3] = bound_max.x;\n    obj.params_[4] = bound_max.y;\n    obj.params_[5] = bound_max.z;\n}\n\nvoid createPlane(mat4 transform, float minX, float minY, float maxX, float maxY, int mtl, out Object obj) {\n    obj.type_ = OBJ_PLANE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = minX;\t\t\t//min x\n    obj.params_[1] = minY;\t\t\t//min y\n    obj.params_[2] = maxX;\t\t\t//max x\n    obj.params_[3] = maxY;\t\t\t//max y\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createDisk(mat4 transform, float r, float R, int mtl, out Object obj) {\n    obj.type_ = OBJ_DISK;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r*r;\n    obj.params_[1] = R*R;\n}\n\nvoid createSphere(mat4 transform, float r, int mtl, out Object obj) {\n    obj.type_ = OBJ_SPHERE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = r*r;\t\t//radius^2\n    obj.params_[2] = 0.0;\t\t//not used\n    obj.params_[3] = 0.0;\t\t//not used\n    obj.params_[4] = 0.0;\t\t//not used \n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createCylinder(mat4 transform, float r, float minZ, float maxZ, float maxTheta, int mtl, out Object obj) {\n    obj.type_ = OBJ_CYLINDER;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = minZ;\t\t//min z\n    obj.params_[2] = maxZ;\t\t//max z\n    obj.params_[3] = maxTheta;\t//max phi\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createCone(mat4 transform, float r, float height, float height1, int mtl, out Object obj) {\n    obj.type_ = OBJ_CONE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = height;\t//heigt\n    obj.params_[2] = height1;\t//heigt 1\n}\n\nmat4 createCS(vec3 p, vec3 z, vec3 x) {\n    z = normalize(z);\n    \n    x = normalize(orthogonalize(z, x));\n    vec3 y = cross(z,x);\n    \n    //vec3 y = normalize(cross(z,x));\n    //x = cross(y,z);\n    \n    return mat4(\tvec4( x, 0.0 ), \n    \t\t\t \tvec4( y, 0.0 ),\n    \t\t\t\tvec4( z, 0.0 ),\n    \t\t\t\tvec4( p, 1.0 ));\n}\n\n\n\nvoid initScene() {\n    float time = 100.0;//iTime;\n    \n    //create lights\n    createLight(vec3(1.0, 1.0, 0.9), 40.0, lights[0]);\n    \n    //Create materials\n    // diff color, diff_tex, spec, roughness, roughness_tex, weight, weight_tex, normal_map, tex_scale, Material\n    createMaterial(vec3(0.2, 0.6, 0.3),  8, vec3(1.0, 1.0, 1.0), 0.015, -1, 0.0, -1,  8, 1.0, materials[0]);//fabric\n    createMaterial(vec3(1.0, 1.0, 1.0),  7, vec3(1.0, 1.0, 1.0), 0.000,  1, 0.5, -1,  1, 1.0, materials[1]);\n    createMaterial(vec3(0.3, 0.5, 1.0),  5, vec3(1.0, 1.0, 1.0), 0.001, -1, 0.6, -1, -1, 1.0, materials[2]);//ball\n    createMaterial(vec3(0.0, 0.2, 0.4),  4, vec3(1.0, 1.0, 1.0), 0.001, -1, 0.6, -1, -1, 1.0, materials[3]);//ball\n    createMaterial(vec3(1.0, 1.0, 1.0),  6, vec3(1.0, 1.0, 1.0), 0.001, -1, 0.5, -1, -1, 1.0, materials[4]);//ball\n    createMaterial(vec3(0.2, 0.5, 0.8), -1, vec3(1.0, 1.0, 1.0), 0.400, -1, 0.6, -1, -1, 1.0, materials[5]);\n    \n    //init lights\n    float r = 1.5;\n    float xFactor = (iMouse.x==0.0)?0.0:2.0*(iMouse.x/iResolution.x) - 1.0;\n    float yFactor = (iMouse.y==0.0)?0.0:2.0*(iMouse.y/iResolution.y) - 1.0;\n    float x = xFactor*15.0;\n    float z = -3.0-yFactor*15.0;\n    float a = -1.2+sin(time*0.23);\n    mat4 trans = createCS(\tvec3(x, 30.0, z),\n                          \tvec3(0.0, sin(a), cos(a)),\n                  \t\t\tvec3(1.0, 0.0, 0.0));\n#ifdef SPHERE_LIGHT\n    createSphere(trans, r, LIGHT_ID_BASE+0, objects[0] );\n#else\n    createPlane(trans, -15.0, -3.0, 15.0, 3.0, LIGHT_ID_BASE+0, objects[0]);\n#endif\n    \n    \n    //plane 1\n    trans = createCS(\tvec3(-9.66, -0.2, 15.0),\n                     \tvec3(0.5, -0.02, -1.0),\n                     \tvec3(0.1, 1.0, 0.3));\n    createCone(trans, 0.3, 70.0, 32.0, SURFACE_ID_BASE+1, objects[1]);\n    \n    //plane 2\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, -1.0, 0.0 ),\n                    vec4( 0.0, -1.0, 0.0, 0.0 ),\n                    vec4( 0.0, -1.0, -4.0, 1.0 ));\n    createPlane(trans, -15.0, -6.0, 15.0, 10.0, SURFACE_ID_BASE+0, objects[2]);\n \n    //Cylinder\n    trans = mat4(\tvec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( -0.0, 3.0, -6.0, 1.0 ));\n    //createCylinder(trans, 4.0, -10.0, 10.0, PI/2.0, SURFACE_ID_BASE+1, objects[3] );\n    \n    //sphere 1\n    trans = createCS(\tvec3(1.5, 0.0, -2.0),\n                     \tvec3(0.1, 0.0, 0.0),\n                     \tvec3(0.1, 1.0, 0.3));\n\n    createSphere(trans, 1.0, SURFACE_ID_BASE+2, objects[4] );\n    \n    //sphere 2\n    trans = createCS(\tvec3(-1.1, 0.0, -4.5),\n                     \tvec3(0.3, 0.8, 0.0),\n                     \tvec3(0.1, 0.0, 0.2));\n\n    createSphere(trans, 1.0, SURFACE_ID_BASE+3, objects[5] );\n    \n    //box\n    trans = createCS(\tvec3(-3.1, -0.7, -3.0),\n                     \tvec3(0.0, 1.0, 0.0),\n                     \tvec3(0.2, 0.0, -0.7));\n    createAABB( trans, -vec3(0.3), vec3(0.3), SURFACE_ID_BASE+5, objects[6]);\n    \n    trans = createCS(\tvec3(3.5, 0.0, -4.2),\n                     \tvec3(0.1, 0.5, -0.2),\n                     \tvec3(-0.3, 0.2, 0.5));\n\n    createSphere(trans, 1.0, SURFACE_ID_BASE+4, objects[7] );\n    /*\n    //torus\n    trans = createCS(\tvec3(3.0, 1.0, -4.0),\n                        vec3(-0.5, 0.0, 0.5),\n                  \t    vec3(1.0, 0.0, 0.0));\n    createTorus(trans, 1.5, 0.3, SURFACE_ID_BASE+4, objects[7]);*/\n}\n\n// Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(1.0 - Xi1);\n    float theta = Xi2*TWO_PI;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\n//taken from: https://www.shadertoy.com/view/4sSSW3\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n    if(n.z < -0.999999) {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    } else {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n}\n\nmat3 mat3FromNormal(in vec3 n) {\n    vec3 x;\n    vec3 y;\n    basis(n, x, y);\n    return mat3(x,y,n);\n}\n\nvec3 localToWorld( in vec3 localDir, in vec3 normal ) {\n    vec3 a,b;\n    basis( normal, a, b );\n\treturn localDir.x*a + localDir.y*b + localDir.z*normal;\n}\n\nvoid cartesianToSpherical( \tin vec3 xyz,\n                         \tout float rho,\n                          \tout float phi,\n                          \tout float theta ) {\n    rho = sqrt((xyz.x * xyz.x) + (xyz.y * xyz.y) + (xyz.z * xyz.z));\n    phi = asin(xyz.y / rho);\n\ttheta = atan( xyz.z, xyz.x );\n}\n\nvec3 sphericalToCartesian( in float rho, in float phi, in float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvec3 sampleHemisphereCosWeighted( in vec3 n, in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return localToWorld( sphericalToCartesian( 1.0, phi, theta ), n );\n}\n\nvec3 sampleHemisphereCosWeighted( in float Xi1, in float Xi2 ) {\n    float theta = acos(clamp(sqrt(1.0-Xi1),-1.0, 1.0));\n    float phi = TWO_PI * Xi2;\n\n    return sphericalToCartesian( 1.0, phi, theta );\n}\n\nvec3 randomDirection( in float Xi1, in float Xi2 ) {\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n//*****************************************************************************\n\n// ************************   Scattering functions  *************************\nbool sameHemisphere(in vec3 n, in vec3 a, in vec3 b){\n\treturn ((dot(n,a)*dot(n,b))>0.0);\n}\n\nbool sameHemisphere(in vec3 a, in vec3 b){\n\treturn (a.z*b.z>0.0);\n}\n\nfloat cosTheta(vec3 w) { return w.z; }\nfloat cosTheta2(vec3 w) { return cosTheta(w)*cosTheta(w); }\nfloat absCosTheta(vec3 w) { return abs(w.z); }\nfloat sinTheta2(vec3 w) { return max(0.0, 1.0 - cosTheta2(w)); }\nfloat sinTheta(vec3 w) { return sqrt(sinTheta2(w)); }\nfloat tanTheta2(vec3 w) { return sinTheta2(w) / cosTheta2(w); }\nfloat tanTheta(vec3 w) { return sinTheta(w) / cosTheta(w); }\n\nfloat cosPhi(vec3 w) { float sin_Theta = sinTheta(w); return (sin_Theta == 0.0) ? 1.0 : clamp(w.x / sin_Theta, -1.0, 1.0); }\nfloat sinPhi(vec3 w) { float sin_Theta = sinTheta(w); return (sin_Theta == 0.0) ? 0.0 : clamp(w.y / sin_Theta, -1.0, 1.0); }\nfloat cosPhi2(vec3 w) { return cosPhi(w) * cosPhi(w); }\nfloat sinPhi2(vec3 w) { return sinPhi(w) * sinPhi(w); }\n\nfloat ggx_eval(vec3 wh, float alphax, float alphay) {\n    float tan2Theta = tanTheta2(wh);\n    if (is_inf(tan2Theta)) return 0.;\n    float cos4Theta = cosTheta2(wh) * cosTheta2(wh);\n    float e = ((cosPhi2(wh) + sinPhi2(wh)) / (alphax * alphay)) * tan2Theta;\n    return 1.0 / (PI * (alphax * alphay) * cos4Theta * (1.0 + e) * (1.0 + e));\n}\n\nvec3 ggx_sample(vec3 wi, float alphax, float alphay, float Xi1, float Xi2) {\n    //stretch view\n    vec3 v = normalize(vec3(wi.x * alphax, wi.y * alphay, wi.z));\n\n    //orthonormal basis\n    vec3 t1 = (v.z < 0.9999) ? normalize(cross(v, vec3(0.0, 0.0, 1.0))) : vec3(1.0, 0.0, 0.0);\n    vec3 t2 = cross(t1, v);\n\n    //sample point with polar coordinates\n    float a = 1.0 / (1.0 + v.z);\n    float r = sqrt(Xi1);\n    float phi = (Xi2 < a) ? Xi2 / a*PI : PI + (Xi2 - a) / (1.0 - a) * PI;\n    float p1 = r*cos(phi);\n    float p2 = r*sin(phi)*((Xi2 < a) ? 1.0 : v.z);\n\n    //compute normal\n    vec3 n = p1*t1 + p2*t2 + v*sqrt(1.0 - p1*p1 - p2*p2);\n\n    //unstretch\n    return normalize(vec3(n.x * alphax, n.y * alphay, n.z));\n}\n\n\nfloat ggx_lambda(vec3 w, float alphax, float alphay) {\n    float absTanTheta = abs(tanTheta(w));\n    if (is_inf(absTanTheta)) return 0.;\n    // Compute _alpha_ for direction _w_\n    float alpha_ = sqrt((cosPhi2(w) + sinPhi2(w)) * (alphax * alphay));\n    float alpha2Tan2Theta = (alpha_ * absTanTheta) * (alpha_ * absTanTheta);\n    return (-1.0 + sqrt(1.0 + alpha2Tan2Theta)) / 2.0;\n}\n\nfloat ggx_g1(vec3 w, float alphax, float alphay) {\n    return 1.0 / (1.0 + ggx_lambda(w, alphax, alphay));\n}\n\nfloat ggx_g(vec3 wo, vec3 wi, float alphax, float alphay) {\n    return 1.0 / (1.0 + ggx_lambda(wo, alphax, alphay) + ggx_lambda(wi, alphax, alphay));\n}\n\nfloat ggx_pdf(vec3 wi, vec3 wh, float alphax, float alphay) {\n    return ggx_eval(wh, alphax, alphay) * ggx_g1(wi, alphax, alphay) * abs(dot(wi, wh)) / abs(wi.z);\n}\n\nfloat pow2(in float x) { return x*x; } \nfloat pow5(in float x) { return pow2(x*x)*x; } \nfloat SchlickFresnel(in float IOR, float cosTheta) {\n    float R0 = pow2((1.0 - IOR) / (1.0 + IOR));\n    return R0 + pow5(1.0 - cosTheta) * (1.0 - R0);\n}\n\nvec3 mtlEval(Material mtl, in vec3 Ng, in vec3 Ns, in vec3 E, in vec3 L) {\n    if(!sameHemisphere(Ns, E, L) || !sameHemisphere(Ng, E, L)) {\n        return vec3(0.0);\n    }\n    mat3 trans = mat3FromNormal(Ns);\n    mat3 inv_trans = mat3Inverse( trans );\n    \n    vec3 E_local = inv_trans * E;\n    vec3 L_local = inv_trans * L;\n    \n    float alpha = mtl.specular_roughness_;\n    \n    if(!sameHemisphere(E_local, L_local)) {\n        return vec3(0.0);\n    }\n    \n    //Specular reflection ***********************************\n    float cosThetaO = abs(E_local.z), cosThetaI = abs(L_local.z);\n    vec3 wh = L_local + E_local;\n    // Handle degenerate cases for microfacet reflection\n    if (cosThetaI == 0.0 || cosThetaO == 0.0) return vec3(0.);\n    if (wh.x == 0.0 && wh.y == 0.0 && wh.z == 0.0) return vec3(0.);\n    \n    wh = normalize(wh);\n    \n    float F = SchlickFresnel(1.5, dot(L_local, wh));\n    float D = ggx_eval(wh, alpha, alpha);\n    float G = ggx_g(E_local, L_local, alpha, alpha);\n    vec3 ks = mtl.specular_color_;\n    \n    vec3 spec_Refl = \t(ks * D * G * F) / (4.0 * cosThetaI * cosThetaO);\n    vec3 diff_refl = \tmtl.diffuse_color_ * vec3(INV_PI) * (vec3(1.0) - F);\n    \n    return \tmix(diff_refl, spec_Refl, mtl.specular_weight_);\n}\n\nfloat pdfDiffuse(in vec3 L_local) {\n    return INV_PI * L_local.z;\n}\n\nfloat pdfSpecular(in vec3 E_local, in vec3 L_local, in float alpha) {\n    vec3 wh = normalize(E_local + L_local);\n    return ggx_pdf(E_local, wh, alpha, alpha) / (4.0 * dot(E_local, wh));\n}\n\nvec3 mtlSample(Material mtl, in vec3 Ng, in vec3 Ns, in vec3 E, in float Xi1, in float Xi2, out vec3 L, out float pdf, out float spec) {\n    mat3 trans = mat3FromNormal(Ns);\n    mat3 inv_trans = mat3Inverse( trans );\n    \n    //convert directions to local space\n    vec3 E_local = inv_trans * E;\n    vec3 L_local;\n    \n    float alpha = mtl.specular_roughness_;\n    // Sample microfacet orientation $\\wh$ and reflected direction $\\wi$\n    if (E_local.z == 0.0) return vec3(0.);\n    vec3 wh = ggx_sample(E_local, alpha, alpha, Xi1, Xi2);\n    if (!sameHemisphere(vec3(0.0, 0.0, 1.0), E_local, wh)) {\n        wh = -wh;\n    }\n    \n    //vec3 fr = fresnelConductor(dot(L_local, wh), vec3(1.5/1.0), vec3(1.0));\n    float F = 0.5;//min(fr.x, min(fr.y, fr.z));\n    //Sample specular or diffuse lobe based on fresnel\n    if(rnd() < F) {\n        L_local = reflect(E_local, wh);\n    \n        if(!sameHemisphere(E_local, L_local)){\n           L_local = -L_local;\n        }\n    } else {\n        L_local = sampleHemisphereCosWeighted( Xi1, Xi2 );\n    }\n    \n    if (!sameHemisphere(E_local, L_local)) {\n        pdf = 0.0;\n    } else {\n        // Compute PDF of _wi_ for microfacet reflection\n        pdf = \tpdfSpecular(E_local, L_local, alpha) * F +\n            \tpdfDiffuse(L_local) * (1.0 - F);\n    }\n  \n    //convert directions to global space\n    L = trans*L_local;\n    \n    if(!sameHemisphere(Ns, E, L) || !sameHemisphere(Ng, E, L)) {\n        pdf = 0.0;\n        return vec3(0.0);\n    }\n    \n    return mtlEval(mtl, Ng, Ns, E, L);\n}\n\nfloat mtlPdf(Material mtl, in vec3 Ng, in vec3 Ns, in vec3 E, in vec3 L) {\n    if(!sameHemisphere(Ns, E, L) || !sameHemisphere(Ng, E, L)) {\n        return 0.0;\n    }\n    \n    mat3 trans = mat3FromNormal(Ns);\n    mat3 inv_trans = mat3Inverse( trans );\n    float alpha = mtl.specular_roughness_;\n    \n    vec3 E_local = inv_trans * E;\n    vec3 L_local = inv_trans * L;\n    \n    vec3 wh = normalize(E_local + L_local);\n    //vec3 fr = fresnelConductor(dot(L_local, wh), vec3(1.5/1.0), vec3(1.0));\n    float F = 0.5;//min(fr.x, min(fr.y, fr.z));\n    \n    return pdfSpecular(E_local, L_local, alpha) * F +\n           pdfDiffuse(L_local)*(1.0 - F);\n}\n\n// ************************  INTERSECTION FUNCTIONS **************************\nbool solveQuadratic(float A, float B, float C, out float t0, out float t1) {\n\tfloat discrim = B*B-4.0*A*C;\n    \n\tif ( discrim <= 0.0 )\n        return false;\n    \n\tfloat rootDiscrim = sqrt( discrim );\n    \n    float t_0 = (-B-rootDiscrim)/(2.0*A);\n    float t_1 = (-B+rootDiscrim)/(2.0*A);\n    \n    t0 = min( t_0, t_1 );\n    t1 = max( t_0, t_1 );\n    \n\treturn true;\n}\n\nbool rayAABBIntersection( in Ray ray, float minX, float minY, float minZ, float maxX, float maxY, float maxZ, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    vec3 boxMin = vec3( minX, minY, minZ );\n    vec3 boxMax = vec3( maxX, maxY, maxZ );\n    \n    vec3 OMIN = ( boxMin - ray.origin ) / ray.dir;\n    vec3 OMAX = ( boxMax - ray.origin ) / ray.dir;\n    vec3 MAX = max ( OMAX, OMIN );\n    vec3 MIN = min ( OMAX, OMIN );\n    float t1 = min ( MAX.x, min ( MAX.y, MAX.z ) );\n    t = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) );\n    \n    if ( t1 <= t )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        \n        if( EQUAL_FLT( isect.position_.x, minX, EPSILON ) ) {\n            isect.normal_ =  vec3( -1.0, 0.0, 0.0 );\n            isect.tangent_ \t\t= vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.x, maxX, EPSILON ) ) {\n            isect.normal_ =  vec3( 1.0, 0.0, 0.0 );\n            isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.y, minY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, -1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.y, maxY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.z, minZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, -1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.z, maxZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, 1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        }\n        \n        isect.uv_ /= 2.0;\n    }\n    \n    return true;\n}\n\nbool raySphereIntersection( in Ray ray, in float radiusSquared, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    float t0, t1;\n    vec3 L = ray.origin;\n    float a = dot( ray.dir, ray.dir );\n    float b = 2.0 * dot( ray.dir, L );\n    float c = dot( L, L ) - radiusSquared;\n    \n    if (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n    \n    if( t0 > 0.0 ) {\n    \tt = t0;\n    } else {\n        if ( t1 > 0.0 ) {\n            t = t1;\n        } else {\n            return false;\n        }\n    }\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        isect.normal_ = normalize( isect.position_ );\n\n        float rho, phi, theta;\n        cartesianToSpherical( isect.normal_, rho, phi, theta );\n        isect.uv_.x = clamp((phi+PI*0.5)/PI, 0.0, 1.0);\n        isect.uv_.y = clamp((theta+PI)/TWO_PI, 0.0, 1.0);\n\n        isect.tangent_ = normalize(orthogonalize(isect.normal_, vec3( 0.0, 1.0, 0.0 )));\n    }\n\t\n\treturn true;\n}\n\nbool rayAAPlaneIntersection( in Ray ray, in float min_x, in float min_y, in float max_x, in float max_y, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    if ( IS_ZERO( ray.dir.z ) )\n    \treturn false;\n    \n    t = ( -ray.origin.z ) / ray.dir.z;\n    \n    isect.position_ = ray.origin + ray.dir*t;\n    \n    if( (isect.position_.x < min_x) ||\n       \t(isect.position_.x > max_x) ||\n      \t(isect.position_.y < min_y) ||\n      \t(isect.position_.y > max_y) )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.uv_.x \t\t= (isect.position_.x - min_x)/(max_x - min_x);\n        isect.uv_.y \t\t= (isect.position_.y - min_y)/(max_y - min_y);\n        isect.normal_ \t\t= vec3( 0.0, 0.0, 1.0 );\n        isect.tangent_ \t\t= vec3( 1.0, 0.0, 0.0 );\n    }\n    \n    return true;\n}\n\nbool rayDiskIntersection( in Ray ray, in float r2, in float R2, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    if ( IS_ZERO( ray.dir.z ) )\n    \treturn false;\n    \n    t = ( -ray.origin.z ) / ray.dir.z;\n    \n    isect.position_ = ray.origin + ray.dir*t;\n    \n    float d2 = dot(isect.position_, isect.position_);\n    \n    if( d2 < r2 || d2 > R2 )\n        return false;\n    \n    if( !forShadowTest ) {\n        float R = sqrt(R2);\n        isect.uv_.x \t\t= (isect.position_.x - R)/(2.0*R);\n        isect.uv_.y \t\t= (isect.position_.y - R)/(2.0*R);\n        isect.normal_ \t\t= vec3( 0.0, 0.0, 1.0 );\n        isect.tangent_ \t\t= vec3( 1.0, 0.0, 0.0 );\n    }\n    \n    return true;\n}\n\nbool rayCylinderIntersection( in Ray r, in float radius, in float minZ, in float maxZ, in float maxPhi, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n\tfloat phi;\n\tvec3 phit;\n    \n\t// Compute quadratic cylinder coefficients\n\tfloat a = r.dir.x*r.dir.x + r.dir.y*r.dir.y;\n\tfloat b = 2.0 * (r.dir.x*r.origin.x + r.dir.y*r.origin.y);\n\tfloat c = r.origin.x*r.origin.x + r.origin.y*r.origin.y - radius*radius;\n \n\t// Solve quadratic equation for _t_ values\n\tfloat t0, t1;\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n\n    if ( t1 < 0.0 )\n        return false;\n    \n\tt = t0;\n    \n\tif (t0 < 0.0)\n\t\tt = t1;\n\n\t// Compute cylinder hit point and $\\phi$\n\tphit = r.origin + r.dir*t;\n\tphi = atan(phit.y,phit.x);\n    phi += PI;\n    \n\tif (phi < 0.0)\n        phi += TWO_PI;\n \n\t// Test cylinder intersection against clipping parameters\n\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) ) {\n\t\tif (t == t1)\n            return false;\n\t\tt = t1;\n\t\t// Compute cylinder hit point and $\\phi$\n\t\tphit = r.origin + r.dir*t;\n\t\tphi = atan(phit.y,phit.x);\n        phi += PI;\n\n\t\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) )\n\t\t\treturn false;\n\t}\n    \n    if( !forShadowTest ) {\n        //isect.position_ = phit;\n        isect.uv_.x = (phit.z - minZ)/(maxZ - minZ);\n        isect.uv_.y = phi/maxPhi;\n        isect.normal_ = normalize( vec3( phit.xy, 0.0 ) );\n        isect.tangent_ = vec3( 0.0, 0.0, 1.0 );\n    }\n    \n\treturn true;\n}\n\nbool rayConeIntersection( in Ray r, in float radius, in float height, in float height1, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n\tfloat phi;\n\tvec3 phit;\n    \n    float k = radius / height;\n    k = k * k;\n    \n    float a = r.dir.x * r.dir.x + r.dir.y * r.dir.y - k * r.dir.z * r.dir.z;\n    float b = 2.0 * (r.dir.x * r.origin.x + r.dir.y * r.origin.y - k * r.dir.z * (r.origin.z - height));\n    float c = r.origin.x * r.origin.x + r.origin.y * r.origin.y - k * (r.origin.z - height) * (r.origin.z - height);\n    \n\t// Compute quadratic cylinder coefficients\n \n\t// Solve quadratic equation for _t_ values\n\tfloat t0, t1;\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n\n    if ( t1 < 0.0 )\n        return false;\n    \n\tt = t0;\n    \n\tif (t0 < 0.0)\n\t\tt = t1;\n\n\t// Compute cylinder hit point and $\\phi$\n\tphit = r.origin + r.dir*t;\n\tphi = atan(phit.y,phit.x);\n    phi += PI;\n    \n\tif (phi < 0.0)\n        phi += TWO_PI;\n \n\t// Test cylinder intersection against clipping parameters\n\tif ( (phit.z < 0.0) || (phit.z > height1) ) {\n\t\tif (t == t1)\n            return false;\n\t\tt = t1;\n\t\t// Compute cylinder hit point and $\\phi$\n\t\tphit = r.origin + r.dir*t;\n\t\tphi = atan(phit.y,phit.x);\n        phi += PI;\n\n\t\tif ( (phit.z < 0.0) || (phit.z > height1) )\n\t\t\treturn false;\n\t}\n    \n    if( !forShadowTest ) {\n        //isect.position_ = phit;\n        isect.uv_.x = phi/TWO_PI;//(maxZ - minZ);\n        isect.uv_.y = (phit.z)/(height1);///maxPhi;\n        isect.normal_ = normalize( vec3( phit.xy, 0.0 ) );\n        isect.tangent_ = vec3( 0.0, 0.0, 1.0 );\n    }\n    \n\treturn true;\n}\n\nbool rayObjectIntersect( in Ray ray, in Object obj, in float distMin, in float distMax, in bool forShadowTest, out SurfaceHitInfo hit, out float dist ) {\n    bool hitResult = false;\n    float t;\n    SurfaceHitInfo currentHit;\n\n    //Convert ray to object space\n    Ray rayLocal;\n    rayLocal.origin = toVec3( obj.transform_inv_*vec4( ray.origin, 1.0 ) );\n    rayLocal.dir \t= toVec3( obj.transform_inv_*vec4( ray.dir   , 0.0 ) );\n\n    if( obj.type_ == OBJ_PLANE ) {\n        hitResult = rayAAPlaneIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_SPHERE ) {\n        hitResult = raySphereIntersection( \trayLocal, obj.params_[1], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_CYLINDER ) {\n        hitResult = rayCylinderIntersection(rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_AABB ) {\n        hitResult = rayAABBIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], obj.params_[4], obj.params_[5], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_DISK ) {\n        hitResult = rayDiskIntersection( rayLocal, obj.params_[0], obj.params_[1], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_CONE ) {\n        hitResult = rayConeIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], forShadowTest, t, currentHit );\n    }\n\n    if( hitResult && ( t > distMin ) && ( t < distMax ) ) {\n        //Convert results to world space\n        currentHit.position_ = ray.origin + ray.dir * t;\n        //currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );\n        currentHit.normal_   = toVec3( obj.transform_*vec4( currentHit.normal_  , 0.0 ) );\n        currentHit.tangent_  = toVec3( obj.transform_*vec4( currentHit.tangent_ , 0.0 ) );\n\n        dist = t;\n        hit = currentHit;\n        hit.mtl_id_ = obj.mtl_id_;\n        \n        return true;\n    }\n    \n    return false;\n}\n\n#define CHECK_OBJ( obj ) { SurfaceHitInfo currentHit; float currDist; if( rayObjectIntersect( ray, obj, distMin, nearestDist, forShadowTest, currentHit, currDist ) && ( currDist < nearestDist ) ) { nearestDist = currDist; hit = currentHit; } }\nbool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {\n    nearestDist = 10000.0;\n    for(int i=0; i<8; i++) {\n        CHECK_OBJ( objects[i] );\n    }\n    return ( nearestDist < 1000.0 );\n}\n// ***************************************************************************\n\n///////////////////////////////////////////////////////////////////////\nvoid initCamera( \tin vec3 pos,\n                \tin vec3 target,\n                \tin vec3 upDir,\n                \tin float fovV,\n                \tin float radius,\n                \tin float focus_dist\n               ) {\n\tvec3 back = normalize( pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n    camera.fovV = fovV;\n    camera.pos = pos;\n    camera.focusDist = focus_dist;\n    camera.lensSize = radius;\n}\n\nvoid updateCamera( int strata ) {\n    vec3 upDir = vec3( 0.0, 1.0, 0.0 );\n    vec3 target = vec3( 0.3, -1.0, -4.0 );\n    \n    camera.pos = vec3( 0.3, 6.0, 4.8 );\n\tvec3 back = normalize( camera.pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n}\n\nRay genRay( in vec2 pixel, in float Xi1, in float Xi2 ) {\n    Ray ray;\n\t//vec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\t//vec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    //ray.origin = camera.pos;\n    //ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n    \n    \n    vec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    \n    if( camera.lensSize > EPSILON ) {\n        vec2 uv = uniformPointWithinCircle( camera.lensSize, rnd(), rnd() );\n        vec3 newPos = camera.pos + camera.rotate[0]*uv.x*camera.lensSize + camera.rotate[1]*uv.y*camera.lensSize;\n        vec3 focusPoint = camera.pos - camera.focusDist*camera.rotate[2];\n        vec3 newBack = normalize(newPos - focusPoint);\n        vec3 newRight = normalize( cross( camera.rotate[1], newBack ) );\n        vec3 newUp = cross( newBack, newRight );\n        mat3 newRotate;\n        newRotate[0] = newRight;\n        newRotate[1] = newUp;\n        newRotate[2] = newBack;\n\n\n        ray.origin = newPos;\n        ray.dir = newRotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n    } else {\n        ray.origin = camera.pos;\n        ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n    }\n\n\treturn ray;\n    \n    \n\treturn ray;\n}\n\n#ifdef SPHERE_LIGHT\nvec3 sampleLightSource( \tin vec3 x,\n                          \tfloat Xi1, float Xi2,\n                          \tout LightSamplingRecord sampleRec ) {\n    float sph_r2 = objects[0].params_[1];\n    vec3 sph_p = toVec3( objects[0].transform_*vec4(vec3(0.0,0.0,0.0), 1.0) );\n    \n    vec3 w = sph_p - x;\t\t\t//direction to light center\n\tfloat dc_2 = dot(w, w);\t\t//squared distance to light center\n    float dc = sqrt(dc_2);\t\t//distance to light center\n    \n    \n    \tfloat sin_theta_max_2 = sph_r2 / dc_2;\n\t\tfloat cos_theta_max = sqrt( 1.0 - clamp( sin_theta_max_2, 0.0, 1.0 ) );\n    \tfloat cos_theta = mix( cos_theta_max, 1.0, Xi1 );\n        float sin_theta_2 = 1.0 - cos_theta*cos_theta;\n    \tfloat sin_theta = sqrt(sin_theta_2);\n        sampleRec.w = uniformDirectionWithinCone( w, TWO_PI*Xi2, sin_theta, cos_theta );\n    \tsampleRec.pdf = 1.0/( TWO_PI * (1.0 - cos_theta_max) );\n        \n        //Calculate intersection distance\n\t\t//http://ompf2.com/viewtopic.php?f=3&t=1914\n        sampleRec.d = dc*cos_theta - sqrt(sph_r2 - dc_2*sin_theta_2);\n    \n    return lights[0].color_*lights[0].intensity_;\n}\n\nfloat sampleLightSourcePdf( in vec3 x,\n                            in vec3 wi,\n                           \tin float d,\n                            in float cosAtLight ) {\n    float sph_r2 = objects[0].params_[1];\n    vec3 sph_p = toVec3( objects[0].transform_*vec4(vec3(0.0,0.0,0.0), 1.0) );\n    float solidangle;\n    vec3 w = sph_p - x;\t\t\t//direction to light center\n\tfloat dc_2 = dot(w, w);\t\t//squared distance to light center\n    float dc = sqrt(dc_2);\t\t//distance to light center\n    \n    if( dc_2 > sph_r2 ) {\n    \tfloat sin_theta_max_2 = clamp( sph_r2 / dc_2, 0.0, 1.0);\n\t\tfloat cos_theta_max = sqrt( 1.0 - sin_theta_max_2 );\n    \tsolidangle = TWO_PI * (1.0 - cos_theta_max);\n    } else { \n    \tsolidangle = FOUR_PI;\n    }\n    \n    return 1.0/solidangle;\n}\n#else\nvec3 sampleLightSource(\t\tin vec3 x,\n                          \tfloat Xi1, float Xi2,\n                       out LightSamplingRecord sampleRec) {\n    float min_x = objects[0].params_[0];\t\t\t//min x\n    float min_y = objects[0].params_[1];\t\t\t//min y\n    float max_x = objects[0].params_[2];\t\t\t//max x\n    float max_y = objects[0].params_[3];\t\t\t//max y\n    float dim_x = max_x - min_x;\n    float dim_y = max_y - min_y;\n    vec3 p_local = vec3(min_x + dim_x*Xi1, min_y + dim_y*Xi2, 0.0);\n    vec3 n_local = vec3(0.0, 0.0, 1.0);\n    vec3 p_global = toVec3( objects[0].transform_*vec4(p_local, 1.0) );\n    vec3 n_global = toVec3( objects[0].transform_*vec4(n_local, 0.0) );\n    \n    float pdfA = 1.0 / (dim_x*dim_y);\n    sampleRec.w = p_global - x;\n    sampleRec.d = length(sampleRec.w);\n    sampleRec.w = normalize(sampleRec.w);\n    float cosAtLight = dot(n_global, -sampleRec.w);\n    vec3 L = cosAtLight>0.0?getRadiance(vec2(Xi1,Xi2)):vec3(0.0);\n    sampleRec.pdf = PdfAtoW(pdfA, sampleRec.d*sampleRec.d, cosAtLight);\n    \n\treturn L;\n}\n\nfloat sampleLightSourcePdf( in vec3 x,\n                               in vec3 wi,\n                             \tfloat d,\n                              \tfloat cosAtLight\n                             ) {\n    float min_x = objects[0].params_[0];\t\t\t//min x\n    float min_y = objects[0].params_[1];\t\t\t//min y\n    float max_x = objects[0].params_[2];\t\t\t//max x\n    float max_y = objects[0].params_[3];\t\t\t//max y\n    float dim_x = max_x - min_x;\n    float dim_y = max_y - min_y;\n    float pdfA = 1.0 / (dim_x*dim_y);\n    return PdfAtoW(pdfA, d*d, cosAtLight);\n}\n#endif\n\nbool isLightVisible( Ray shadowRay ) {\n    float distToHit;\n    SurfaceHitInfo tmpHit;\n    \n    raySceneIntersection( shadowRay, EPSILON, true, tmpHit, distToHit );\n    \n    return ( tmpHit.mtl_id_ >= LIGHT_ID_BASE );\n}\n\nLight pickOneLight(out float lightPickingPdf) {\n    lightPickingPdf = 1.0;\n    return lights[0];\n}\n\nvoid fixMtl(inout Material mtl, vec2 uv, out vec3 ns) {\n    uv *= mtl.tex_scale_;\n    if(mtl.diffuse_color_tex_!=-1){\n        mtl.diffuse_color_ = getColor(uv, mtl.diffuse_color_tex_);\n    }\n    \n    if(mtl.specular_roughness_tex_!=-1){\n        mtl.specular_roughness_ = (1.0 - sqrt(getColor(uv, mtl.specular_roughness_tex_).x));\n    } else {\n        mtl.specular_roughness_ = sqrt(mtl.specular_roughness_);\n    }\n    \n    if(mtl.specular_weight_tex_!=-1){\n        mtl.specular_weight_ = (getColor(uv, mtl.specular_weight_tex_).x);\n    }\n    if(mtl.normal_map_!=-1){\n        ns = getNormal(uv, mtl.normal_map_ );\n    } else {\n        ns = vec3(0.0, 0.0, 1.0);\n    }\n}\n\nvec3 sampleBSDF(\tin vec3 x,\n                  \tin vec3 ng,\n                  \tin vec3 ns,\n                \tin vec3 wi,\n                  \tin Material mtl,\n                  \tin bool useMIS,\n                  \tin int strataCount,\n                  \tin int strataIndex,\n                \tout vec3 wo,\n                \tout float brdfPdfW,\n                \tout vec3 fr,\n                \tout bool hitRes,\n                \tout SurfaceHitInfo hit,\n               \t\tout float spec) {\n    vec3 Lo = vec3(0.0);\n    for(int i=0; i<DL_SAMPLES; i++){\n        float Xi1 = rnd();\n        float Xi2 = rnd();\n        float strataSize = 1.0 / float(strataCount);\n        Xi2 = strataSize * (float(strataIndex) + Xi2);\n        fr = mtlSample(mtl, ng, ns, wi, Xi1, Xi2, wo, brdfPdfW, spec);\n        \n        //fr = eval(mtl, ng, ns, wi, wo);\n\n        float dotNWo = dot(wo, ns);\n        //Continue if sampled direction is under surface\n        if ((dot(fr,fr)>0.0) && (brdfPdfW > EPSILON)) {\n            Ray shadowRay = Ray(x, wo);\n\n            //abstractLight* pLight = 0;\n            float cosAtLight = 1.0;\n            float distanceToLight = -1.0;\n            vec3 Li = vec3(0.0);\n\n            {\n                float distToHit;\n\n                if(raySceneIntersection( shadowRay, EPSILON, false, hit, distToHit )) {\n                    if(hit.mtl_id_>=LIGHT_ID_BASE) {\n                        distanceToLight = distToHit;\n                        cosAtLight = dot(hit.normal_, -wo);\n                        if(cosAtLight > 0.0) {\n                            Li = getRadiance(hit.uv_);\n                            //Li = lights[0].color_*lights[0].intensity_;\n                        }\n                    } else {\n                        hitRes = true;\n                    }\n                } else {\n                    hitRes = false;\n                    //TODO check for infinite lights\n                }\n            }\n\n            if (distanceToLight>0.0) {\n                if (cosAtLight > 0.0) {\n                    vec3 contribution = (Li * fr * dotNWo) / brdfPdfW;\n\n                    if (useMIS/* && !(mtl->isSingular())*/) {\n                        float lightPickPdf = 1.0;//lightPickingPdf(x, n);\n                        float lightPdfW = sampleLightSourcePdf( x, wi, distanceToLight, cosAtLight );\n                        //float lightPdfW = sphericalLightSamplingPdf( x, wi );//pLight->pdfIlluminate(x, wo, distanceToLight, cosAtLight) * lightPickPdf;\n\n                        contribution *= misWeight(brdfPdfW, lightPdfW);\n                    }\n\n                    Lo += contribution;\n                }\n            }\n        }\n    }\n\n    return Lo*(1.0/float(DL_SAMPLES));\n}\n\nvec3 salmpleLight(\tin vec3 x,\n                  \tin vec3 ng,\n                  \tin vec3 ns,\n                  \tin vec3 wi,\n                  \tin Material mtl,\n                  \tin bool useMIS,\n                  \tin int strataCount,\n                  \tin int strataIndex ) {\n    vec3 Lo = vec3(0.0);\t//outgoing radiance\n\n    for(int i=0; i<DL_SAMPLES; i++) {\n        float lightPickingPdf;\n        Light light = pickOneLight(lightPickingPdf);\n\n        vec3 wo;\n        float lightPdfW, lightDist;\n\n        LightSamplingRecord rec;\n        float Xi1 = rnd();\n        float Xi2 = rnd();\n        float strataSize = 1.0 / float(strataCount);\n        Xi2 = strataSize * (float(strataIndex) + Xi2);\n\n        vec3 Li = sampleLightSource( x, Xi1, Xi2, rec );\n        //vec3 Li = sampleSphericalLight( x, Xi1, Xi2, rec );\n        wo = rec.w;\n        lightPdfW = rec.pdf;\n        lightDist = rec.d;\n        lightPdfW *= lightPickingPdf;\n\n        float dotNWo = dot(wo, ns);\n\n        if ((dotNWo > 0.0) && (lightPdfW > EPSILON)) {\n            vec3 fr = mtlEval(mtl, ng, ns, wi, wo);\n            if(dot(fr,fr)>0.0) {\n                Ray shadowRay = Ray(x, wo);\n                if (isLightVisible( shadowRay )) {\n                    vec3 contribution = (Li * fr * dotNWo) / lightPdfW;\n\n                    if (useMIS /*&& !(light->isSingular())*/) {\n                        float brdfPdfW = mtlPdf(mtl, ng, ns, wi, wo);\n                        contribution *= misWeight(lightPdfW, brdfPdfW);\n                    }\n\n                    Lo += contribution;\n                }\n            }\n        }\n    }\n\n    return Lo*(1.0/float(DL_SAMPLES));\n}\n\nvec3 Radiance( in Ray r, int strataCount, int strataIndex ) {\n    vec3 Lo = vec3(0.0), fr, directLight, pathWeight = vec3(1.0, 1.0, 1.0);\n    vec3 wo;\n    float woPdf;\n    float dotWoN;\n    bool hitResult;\n\n    //Calculate first intersections to determine first scattering event\n    Ray ray = r;\n    SurfaceHitInfo event;\n    SurfaceHitInfo nextEvent;\n    float dist;\n    if(!raySceneIntersection( ray, 0.0, false, event, dist )) {\n        return Lo;\n    } else {\n        //We have to add emmision component on first hit\n        if( event.mtl_id_ >= LIGHT_ID_BASE ) {\n            Light light = getLight(event.mtl_id_ - LIGHT_ID_BASE);\n            float cosAtLight = dot(event.normal_, -ray.dir);\n            if(cosAtLight > 0.0) {\n                Lo = getRadiance(event.uv_);\n                //Lo = light.color_*light.intensity_;\n            }\n        }\n    }\n    \n    float prev_spec;\n\n    for (int i = 0; i < MAX_DEPTH; i++) {\n        if(event.mtl_id_>=LIGHT_ID_BASE){\n        \tbreak;\n    \t}\n        \n        vec3 x = event.position_;\n        vec3 wi = -ray.dir;\n        event.normal_ = -faceforward(event.normal_, wi, event.normal_);\n        \n        Material mtl = getMaterial(event.mtl_id_);\n    \tvec3 ng = event.normal_, ns;\n    \tfixMtl(mtl, event.uv_, ns);\n    \n        mat3 frame;\n        frame[0] = event.tangent_;\n        frame[1] = cross( ng, event.tangent_ );\n        frame[2] = ng;\n        ns = frame*ns;\n        \n        if (dot(wi,ns) < 0.0) { break; }\n        \n        if(i!=0) {\n            strataCount = 1; strataIndex = 0;\n        }\n        \n        float spec;\n\n        //Calculate direct light with 'Light sampling' and 'BSDF sampling' techniques\n        //In addition BSDF sampling does next event estimation and returns all necessary values which corresponds to next event\n       \tdirectLight  = salmpleLight (x, ng, ns, wi, mtl, true, strataCount, strataIndex);\n        directLight += sampleBSDF   (x, ng, ns, wi, mtl, true, strataCount, strataIndex, wo, woPdf, fr, hitResult, nextEvent, spec);\n       \n#ifdef CLAMP_CAUSTICS\n        if(i!=0) {\n            if(prev_spec < spec) {\n                break;\n            }\n        }\n        prev_spec = spec;\n#endif\n        \n        Lo += directLight*pathWeight;\n\n        if (!hitResult || (dotWoN = dot(event.normal_, wo))<0.0) { break; }\n        if (woPdf == 0.0) { break; }\n        pathWeight *= fr*dotWoN / woPdf;\n\n        //Update values for next iteration\n        ray = Ray(event.position_, wo);\n        event = nextEvent;\n    }\n\n    return Lo;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n    float fov = radians(30.0);\n    initCamera( vec3( 0.0, 0.0, 0.0 ),\n               vec3( 0.0, 0.0, 0.0 ),\n               vec3( 0.0, 1.0, 0.0 ),\n               fov,\n               LENS_SIZE,\n               9.0\n              );\n\n    initScene();\n\n    vec3 accumulatedColor = vec3( 0.0 );\n    float oneOverSPP = 1.0/float(PIXEL_SAMPLES);\n    float strataSize = oneOverSPP;\n    Ray ray;\n\n    for( int si=0; si<PIXEL_SAMPLES; ++si ){\n        updateCamera( si );\n\n        vec2 screenCoord = fragCoord.xy + vec2( strataSize*( float(si) + rnd() ), rnd() );\n        ray = genRay( screenCoord, rnd(), rnd() );\n\n        if( length( ray.dir ) < 0.2 ) {\n            accumulatedColor = vec3( 0.0 );\n        } else {\n            vec3 Li = Radiance( ray, PIXEL_SAMPLES, si );\n            Li = vec3(min(Li.x, CLAMP_VALUE), min(Li.y, CLAMP_VALUE), min(Li.z, CLAMP_VALUE));\n            accumulatedColor += Li;\n        }\n    }\n\n    //devide to sample count\n    accumulatedColor = accumulatedColor*oneOverSPP;\n    \n    vec3 col_acc;\n    vec2 coord = floor(fragCoord.xy);\n    if(all(equal(coord.xy,vec2(0)))) {\n        if( iMouse.z > 0.0 ) {\n            col_acc = vec3(iFrame);\n        } else {\n            discard;\n            //col_acc = texture( iChannel0, vec2(0.5, 0.5)/iResolution.xy ).xyz;\n        }\n    } else {\n        if(iFrame == 0) {\n            col_acc = accumulatedColor;\n        } else {\n            int frame_start = int(texture( iChannel0, vec2(0.5, 0.5) / iResolution.xy ).x);\n            int spp1 = iFrame - frame_start;\n            int spp2 = 1;\n            vec3 col_new = accumulatedColor;\n            col_acc = texture( iChannel0, fragCoord/iResolution.xy ).xyz;\n            col_acc = mix(col_acc, col_new, float(spp2)/float(spp1+spp2));\n        }\n    }\n    \n    fragColor = vec4( col_acc, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}