{
    "Shader": {
        "info": {
            "date": "1685631469",
            "description": ".",
            "flags": 0,
            "hasliked": 0,
            "id": "DlcXzf",
            "likes": 18,
            "name": "Quadratic approx of cubic spline",
            "published": 3,
            "tags": [
                "bezier",
                "spline",
                "curve",
                "cubic",
                "catmullrom",
                "hermite"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 338
        },
        "renderpass": [
            {
                "code": "// A (simplified a bit) implementation of this paper - https://ttnghia.github.io/posts/quadratic-approximation-of-cubic-curves/\n// I recommend running the demo .exe to get a feel of how it works.\n// Green is catmull rom spline, black is its tangents and points, orange is the bezier spline.\n// Bezier generation on line 130.\n\n#define CATMULL_ROM 0\n#define BEZIER 1\n\nvec2[] pts = vec2[](\n    vec2(0.1,0.2),\n    vec2(0.5,0.1),\n    vec2(0.2,-0.3),\n    vec2(-0.2,0.2),\n    vec2(-0.4,0.2),\n    vec2(-0.5,0.4),\n    vec2(-0.6,-0.2),\n    vec2(-0.8,-0.3),\n    vec2(-0.3,-0.4),\n    vec2(-0.2,-0.3),\n    vec2(-0.8,-0.3),\n    vec2(-0.3,-0.4)\n);\n\nvec2 get_pt(int i){\n    return pts[(i+pts.length())%pts.length()];\n}\n\n// Characteristic matrices\nconst float[] bezier = float[16](\n    1.,  0.,  0.,  0.,\n    -2., 2.,  0.,  0.,\n    1., -2.,  1.,  0.,\n    0., 0., 0.,  0.\n);\nconst float[] hermite = float[16](\n    1.,  0.,  0.,  0.,\n    0.,  1.,  0.,  0.,\n    -3.,-2.,  3., -1.,\n    2.,  1., -2.,  1.\n);\n\n\nfloat sdLine(vec2 uv, vec2 a, vec2 b){\n    vec2 ab = b - a;\n    vec2 p = a + ab*clamp(dot(uv-a, ab)/dot(ab,ab),0.,1.);\n    return length(uv-p);\n}\n\n\n\nvec2 curve_sample(float[16] m, float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3){\n    return (P0*m[0]  + P1*m[1]  + P2*m[2]  + P3*m[3] ) +\n        t*     (P0*m[4]  + P1*m[5]  + P2*m[6]  + P3*m[7] ) +\n        t*t*   (P0*m[8]  + P1*m[9]  + P2*m[10] + P3*m[11]) +\n        t*t*t* (P0*m[12] + P1*m[13] + P2*m[14] + P3*m[15]);\n}\n\nvoid draw_curve(\n    inout vec3 col, vec2 uv, vec3 curve_col, float[16] m, vec2 P0, vec2 P1, vec2 P2, vec2 P3\n){\n    const float its = 44.;\n    float sd_curve = 1000.;\n    vec2 prev_p;\n    for(float t = 0. ; t <= 1. + 0.01/its; t+=1./its){\n        vec2 p = curve_sample(m,t,P0,P1,P2,P3);\n\n        if(t < 0.01/its)\n            prev_p = p;\n\n        sd_curve = min(sd_curve,sdLine(uv,prev_p,p) - 0.002);   \n        prev_p = p;\n    }\n    col = mix(col,curve_col,smoothstep(fwidth(uv.y),0.,sd_curve));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.95);\n    \n    // Draw background\n    vec2 uvb = mod(uv, 0.1) - 0.05;\n    float sd_bg = 1000.;\n    sd_bg = min(sd_bg,abs(uvb.x));\n    sd_bg = min(sd_bg,abs(uvb.y));\n    col = mix(col,vec3(0.6),smoothstep(fwidth(uv.y),0.,sd_bg));\n    \n    \n    // Offset points\n    for(float i = 0.; i < float(pts.length()); i++){\n        pts[int(i)] += vec2(sin(i+iTime*cos(i)),cos(i+iTime*sin(i)))*0.2;\n    }\n    \n    // Generate catmull rom tangents\n    vec2[pts.length()] tangents;\n    const float visc = 0.5;\n    for(int i = 0; i < tangents.length(); i++){\n        tangents[i] = (get_pt(i+1) - get_pt(i-1))*visc;\n    }\n    \n    const vec3 bezier_col = vec3(1,0.2,0);\n    const vec3 catmull_rom_col = vec3(0.1,0.5,0.);\n    \n    float sd_black_lines = 1000.;\n    float sd_bez_stuff = 1000.;\n    float sd_points = 1000.;\n    \n    for(int spline = 0; spline < 2 + min(iFrame,0); spline++){\n        for(int pid = 0; pid < pts.length(); pid++){\n            // Get catmull rom points\n            vec2 P0 = get_pt(pid);\n            vec2 P1 = tangents[pid];\n            vec2 P2 = get_pt(pid+1);\n            vec2 P3 = tangents[(pid + 1)%tangents.length()];\n            if(spline == CATMULL_ROM){\n                // Draw\n                sd_black_lines = min(sd_black_lines,sdLine(uv,P0,P0+P1));\n                sd_black_lines = min(sd_black_lines,sdLine(uv,P2,P2+P3));\n                draw_curve(col, uv, catmull_rom_col, hermite, P0, P1, P2, P3);\n            } else if (spline == BEZIER){\n                vec2 mid_point = curve_sample(hermite,0.5,P0,P1,P2,P3); \n                \n                P3 = vec2(0);\n                \n                // Calculate beziers\n                const float k = 0.25;\n                \n                vec2 bez_a_P0 = get_pt(pid);\n                vec2 bez_a_P1 = P0 + k*tangents[pid];\n                vec2 bez_a_P2 = mid_point;\n                \n                vec2 bez_b_P0 = mid_point;\n                vec2 bez_b_P2 = get_pt(pid+1);\n                vec2 bez_b_P1 = P2 - k*tangents[(pid+1)%tangents.length()];\n                \n                // Draw\n                draw_curve(col, uv, bezier_col, bezier, bez_a_P0, bez_a_P1, bez_a_P2, P3);\n                \n                draw_curve(col, uv, bezier_col, bezier, bez_b_P0, bez_b_P1, bez_b_P2, P3);\n                \n                sd_bez_stuff = min(sd_bez_stuff, length(bez_a_P1 - uv) - 0.01);\n                sd_bez_stuff = min(sd_bez_stuff, length(bez_b_P1 - uv) - 0.01);\n                sd_bez_stuff = min(sd_bez_stuff, sdLine(uv,bez_a_P1,mid_point));\n                sd_bez_stuff = min(sd_bez_stuff, sdLine(uv,bez_b_P1,mid_point));\n                sd_bez_stuff = min(sd_bez_stuff, sdLine(uv,bez_b_P2,P2 - k*tangents[(pid+1)%tangents.length()]));\n                \n            }\n        }\n    }\n    \n    col = mix(col,bezier_col,smoothstep(fwidth(uv.y),0.,sd_bez_stuff));\n    \n    for(int p = 0; p < pts.length(); p++){\n        sd_points = min(sd_points,length(uv - pts[p]) - 0.01);\n    }\n    sd_points = min(sd_points,sd_black_lines);\n    col = mix(col,vec3(0.0),smoothstep(fwidth(uv.y),0.,sd_points));\n    \n    \n    col = pow(col,vec3(0.454545));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}