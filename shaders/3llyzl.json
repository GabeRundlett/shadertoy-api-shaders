{
    "Shader": {
        "info": {
            "date": "1593112526",
            "description": "SDF for the Julia set of  f(z) = z^3+C, used for the intro of [url=https://www.youtube.com/watch?v=rQ2bnU4dkso]Geodes[/url]. More info: [url]https://iquilezles.org/articles/distancefractals/distancefractals.htm[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "3llyzl",
            "likes": 29,
            "name": "Julia - Distance 2",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "julia",
                "sdf",
                "juliaset",
                "distance",
                "orbittrap",
                "traps",
                "orbittraps",
                "cubic",
                "distanceestimator"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 2515
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// The Julia set of f(z) = z^3+c, as rendered for the video\n// \"Geodes\": https://www.youtube.com/watch?v=rQ2bnU4dkso\n\n// It uses the distance to the Julia set for coloring\n// More info:\n// https://iquilezles.org/articles/distancefractals\n\n// Related:\n//\n// Julia - Distance 1 : https://www.shadertoy.com/view/Mss3R8\n// Julia - Distance 2 : https://www.shadertoy.com/view/3llyzl\n// Julia - Distance 3 : https://www.shadertoy.com/view/4dXGDX\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch(iChannel0,ivec2(fragCoord),0).xyz;\n    \n    // vignetting    \n    vec2 p = fragCoord/iResolution.xy;\n    col *= 0.5+0.5*pow(16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y),0.1);\n\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// The Julia set of f(z) = z^3+c, as rendered for the video\n// \"Geodes\": https://www.youtube.com/watch?v=rQ2bnU4dkso\n\n// It uses the distance to the Julia set for coloring\n// More info:\n// https://iquilezles.org/articles/distancefractals\n\n// Related:\n//\n// Julia - Distance 1 : https://www.shadertoy.com/view/Mss3R8\n// Julia - Distance 2 : https://www.shadertoy.com/view/3llyzl\n// Julia - Distance 3 : https://www.shadertoy.com/view/4dXGDX\n\n\n// 0: bright\n// 1: dark\n#define COLOR_SCHEMA 0\n// 0: off\n// 1: on\n#define TAA          1\n\n#if HW_PERFORMANCE==0\n#define AA 2\n#else\n#define AA 5\n#endif\n\n\n// --------------------------------------\n// Visual Studio rand()\n// --------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n// --------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n// --------------------------------------\nint hash( int n )\n{\n    n = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n// --------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\n// --------------------------------------\n\n// pixel to z-plane transform\nmat3x3 pixel2z( in float time )\n{\n    // rotation\n    float an = 0.021*time;\n    float co = cos(an), si=sin(an);\n    // scale\n    float  sc = 1.2*pow(0.95,time);\n    // translation\n    vec2   tr = vec2(0.0,0.17);\n    \n    return mat3x3( sc*co, sc*si, 0.0,\n                  -sc*si, sc*co, 0.0,\n                   tr.x,  tr.y,  1.0 );\n}\n\nvec3 render( in vec2 fragCoord, in float gtime )\n{\n    vec4 col = vec4(0.0);\n    \n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // 2.5 pixel wide filter footprint, cubic falloff\n        const float fw = 2.5;\n        vec2 o = fw*(vec2(float(m),float(n)) / float(AA) - 0.5);\n        float w = smoothstep(fw*0.5,0.0,length(o));\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // motion blur\n        float time = gtime + (0.5/24.0)*frand();\n\t\t#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        float w = 1.0;\n        float time = gtime;\n\t\t#endif\n\n        // pixel to z\n        vec2 z = (pixel2z(time)*vec3(p,1.0)).xy;\n\n        // compute Julia set\n        const float threshold = 64.0;\n        const vec2  kC = vec2(0.105,0.7905);\n        const int   kNumIte = 200;\n\n        float it = 0.0;\n        float dz2 = 1.0;\n        float m2 = 0.0;\n        for( int i=0; i<kNumIte; i++ )\n        {\n            // df(z)/dz = 3*z^2\n            dz2 *= 9.0*dot2(vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y));\n            // f(z) = z^3 + c\n            z = vec2( z.x*z.x*z.x - 3.0*z.x*z.y*z.y, 3.0*z.x*z.x*z.y - z.y*z.y*z.y ) + kC;\n            // check divergence\n            it++;\n            m2 = dot2(z);\n            if( m2>threshold ) break;\n        }\n        \n        // distance\n        float d = 0.5 * log(m2) * sqrt(m2/dz2);\n        // interation count\n        float h = it - log2(log2(dot(z,z))/(log2(threshold)))/log2(3.0); // https://iquilezles.org/articles/msetsmooth\n        \n        // coloring\n        vec3 tmp = vec3(0.0);\n        if( it<(float(kNumIte)-0.5) )\n        {\n            #if COLOR_SCHEMA==0\n            tmp = 0.5 + 0.5*cos( 5.6 + sqrt(h)*0.5 + vec3(0.0,0.15,0.2));\n            tmp *= smoothstep(0.0,0.0005,d);\n            tmp *= 1.2/(0.3+tmp);\n            tmp = pow(tmp,vec3(0.4,0.55,0.6));\n            #else\n            tmp = vec3(0.12,0.10,0.09);\n            tmp *= smoothstep(0.005,0.020,d);\n            float f = smoothstep(0.0005,0.0,d);\n            tmp += 3.0*f*(0.5+0.5*cos(3.5 + sqrt(h)*0.4 + vec3(0.0,0.5,1.0)));\n            tmp = clamp(tmp,0.0,1.0);\n\t\t\t#endif\n        }\n        \n        col += vec4(tmp*w,w);\n\t#if AA>1\n    }\n    col /= col.w;\n\t#endif\n\n    return col.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(1117*iFrame))));\n    \n    // draw Julia set (supersampled)\n    vec3 col = render(fragCoord,iTime);\n    \n    //----------------------\n    // temporal reprojection\n    //----------------------\n#if TAA==1\n    // new pixel to old pixel transform (velocity vector)\n    mat3x3    z_from_pnew = pixel2z(iTime);\n    mat3x3 pold_from_z    = inverse(pixel2z(iTime - iTimeDelta +  (0.25/24.0) )); // from previous frame\n    mat3x3 pold_from_pnew = pold_from_z*z_from_pnew;\n    \n    // reproject\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 op = (pold_from_pnew*vec3(p,1.0)).xy;\n    vec2 sp = 0.5*(iResolution.y*op + iResolution.xy);\n    \n    // blend color\n    vec4 data = texture(iChannel0,sp/iResolution.xy);\n  \tcol = mix(col,data.xyz,0.8);\n#endif    \n    // output\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}