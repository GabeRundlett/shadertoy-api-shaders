{
    "Shader": {
        "info": {
            "date": "1667886046",
            "description": "Creating an algorithm to get the nearest neighbor to an occupied pixel.\nPart of this algorithm involves a creating a fast way to calculate the nearest N integer coordinates from a given central coordinate.\nUse the mouse to test this part of the algorithm.",
            "flags": 32,
            "hasliked": 0,
            "id": "cd2GzK",
            "likes": 3,
            "name": "Precise Sampling Order",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "distance",
                "field"
            ],
            "usePreview": 0,
            "username": "Hatchling",
            "viewed": 210
        },
        "renderpass": [
            {
                "code": "const ivec2 TestImageSize = ivec2(16,9);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//debugAllData(DATA, fragColor, fragCoord / vec2(1, 100));\n    //return;\n    \n    fragColor = vec4(0, 0, 0, 1);\n    \n    vec2 fragUV = fragCoord / iResolution.xy;\n    vec2 fragTestCoord = fragUV * vec2(TestImageSize);\n    ivec2 fragTestIntCoord = floorToInt(fragTestCoord);\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    vec2 mouseTestCoord = mouseUV * vec2(TestImageSize);\n    ivec2 mouseTestIntCoord = floorToInt(mouseTestCoord);\n    \n    for(int iCoord = 0; iCoord < SamplingOrderCount; iCoord++)\n    {\n        ivec2 samplingCoord = mouseTestIntCoord + GetSamplingOrderCoord(iCoord, DATA).xy;\n        \n        if(fragTestIntCoord != samplingCoord)\n            continue;\n            \n        float hue = float(iCoord) / float(SamplingOrderCount);\n        \n        fragColor.rgb = hsv2rgb(vec3(hue, 1.0, 1.0));\n        return;\n    }\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "///////////////////////////////////////////////\n// HELPER FUNCTIONS\n///////////////////////////////////////////////\n\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) retType lengthSqr(type a) { type t = a; return dot2(t,t); }\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) retType distSqr(type a, type b) { type diff = a-b; return lengthSqr(diff); }\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n// I don't trust int(floor(x)).\n// So, for positive values:\n//\n// x = floor(x)\n//\n// Add 0.5 in case floor(x) rounded it to some floating point garbage like 23.99999\n// x += 0.5\n//\n// ix = int(x) // THEN cast to an int.\n//\n// Similar thing happens for negative values.\n#define decl_floorToInt(retType, type) retType floorToInt(type a) { return retType(floor(a) + sign(a) * type(0.5)); }\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n    \n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n\n///////////////////////////////////////////////\n// DATA\n///////////////////////////////////////////////\n\n#define DATA iChannel3\n\nconst int DataCompleteFrame = 4;\n\n// Sampling Order -------------------------------\n// Frame 0: Imprecise version calculated.\n// Frane 2: Precise version calculated.\n//     Depends on:\n//         - Sampling Order, Frame 0\n//         - Sampling Distance, Frame 1\n// Frame 3: Ready.\n\nconst int SamplingOrderRow = 0;\nconst int SamplingOrderCount = 101;\nconst int SamplingOrderFrameImprecise = 0;\nconst int SamplingOrderFramePrecise = 2;\n\n\nivec3 GetSamplingOrderCoord(int n, sampler2D data)\n{\n    ivec2 coord = ivec2(n, SamplingOrderRow);\n    \n    return ivec3(texelFetch(data, coord, 0));\n}\n\nvec4 DebugSamplingOrderCoord(int n, sampler2D data)\n{\n    ivec3 d = GetSamplingOrderCoord(n, data);\n    \n    \n    vec4 color = vec4\n    (\n        vec3(d.xyz) / vec3(vec2(10), 5), \n        1\n    );\n    \n    color.xyz /= (1.0 + abs(color.xyz));\n    color.xy += 0.5;\n    return color;\n}\n\n// Cached Sampling Distances -------------------------------\n// Frame 1: Calculate minimum distance between Pixel[0] and Pixel[N].\n//     Depends on:\n//         - Sampling Order, Frame 0\n// Frame 3: Recalculate distances with new precise ordering.\n//     Depends on:\n//         - Sampling Order, Frame 2\nconst int SamplingDistanceRow = 1;\nconst int SamplingDistanceFrameImprecise = 1;\nconst int SamplingDistanceFramePrecise = 3;\nfloat GetSamplingDistance(int n, sampler2D data)\n{\n    ivec2 coord = ivec2(n, SamplingDistanceRow);\n    \n    return texelFetch(data, coord, 0).x;\n}\n\nvec4 DebugSamplingDistance(int n, sampler2D data)\n{\n    float d = GetSamplingDistance(n, data);\n    \n    d *= 0.01;\n    d = d / (1.0 + d);\n    \n    vec4 color = vec4(1);\n    color.rgb = hsv2rgb(vec3(d, 1.0, 1.0));\n    return color;\n}\n\n\n\nvoid debugAllData( sampler2D dataChannel, out vec4 fragColor, in vec2 fragCoord )\n{      \n    ivec2 iCoord = floorToInt(fragCoord);\n    \n    switch(iCoord.y)\n    {\n        case SamplingOrderRow: fragColor = DebugSamplingOrderCoord(iCoord.x, dataChannel); return;\n        case SamplingDistanceRow: fragColor = DebugSamplingDistance(iCoord.x, dataChannel); return;\n    }\n    \n    fragColor = texelFetch(dataChannel, iCoord, 0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Cached data buffer.\n// Things that only need to be calculated once will be stored here.\n\nvoid getSamplingCoords(out ivec3 coords[SamplingOrderCount], int maxIndex)\n{\n    // coordinate:\n    // x, y: position\n    // z:    layer\n    \n    // NOTE: SamplingOrderCount and maxIndex are evaluated\n    // separately in hopes that the compiler\n    // will unroll the for loops\n    // and break early given one of the\n    // arguments is a constant.\n    // If we combine the two limits,\n    // it might be dumb and assume that\n    // the breaking condition is non-constant\n    // and therefore,\n    // there is no definite upper bound\n    // to the number of iterations,\n    // thus preventing the loop from being unrolled.\n    \n    int iCoord = 0;\n    if(iCoord>=SamplingOrderCount) return;\n    if(iCoord>=maxIndex) return;\n    \n    coords[iCoord++] = ivec3(0);\n    if(iCoord>=SamplingOrderCount) return;\n    if(iCoord>=maxIndex) return;\n    \n    for(int iLayer = 1; ; iLayer++)\n    {\n        // Add primaries (left, right, down, up).\n        {\n            ivec3 swizzler = ivec3(-iLayer, iLayer, 0);\n            \n            coords[iCoord++] = ivec3(swizzler.xzy); // left\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.yzy); // right\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.zxy); // bottom\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.zyy); // top\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n        }\n        \n        // Add coordinates between corners and primaries.\n        for(int iMinor = 1; iMinor < iLayer; iMinor++)\n        {\n            // iLayer = length of longer (major) arm.\n            // iMinor = length of shorter (minor) arm.\n            \n            ivec4 swizzler = ivec4(iLayer, iMinor, -iLayer, -iMinor);\n            \n            coords[iCoord++] = ivec3(swizzler.xyx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.xwx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.zyx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.zwx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            \n            coords[iCoord++] = ivec3(swizzler.yxx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.wxx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.yzx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.wzx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n        }\n        \n        // Add corners.\n        {\n            ivec2 swizzler = ivec2(-iLayer, iLayer);\n            \n            coords[iCoord++] = ivec3(swizzler.xxy); // left bottom\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.xyy); // left top\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.yxy); // right bottom\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.yyy); // right top\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n        }\n    }\n}\n\n\nvoid UpdateSamplingOrderData( out vec4 fragColor, in ivec2 iCoord )\n{\n    switch(iFrame)\n    {\n        case SamplingOrderFrameImprecise:\n        {\n            ivec3 coords[SamplingOrderCount];\n            int coordComputeCount = min(SamplingOrderCount, iCoord.x+1);\n            getSamplingCoords(coords, coordComputeCount);\n            fragColor.xyz = vec3(coords[coordComputeCount-1]);\n            fragColor.w = 1.0;\n            return;\n        }\n        case SamplingOrderFramePrecise:\n        {\n        \nint n = min(SamplingOrderCount, iCoord.x+1);\nint maxN = min(SamplingOrderCount, int(float(n)*1.5));\nivec3 closestNCoords[SamplingOrderCount];\nfloat closestNDistances[SamplingOrderCount];\nint closestNIndices[SamplingOrderCount];\nint closestNCount = 0;\n\n// TODO: Skip more comparisons by better exploiting\n//       the fact the list is already\n//       semi-sorted.\n\nfor(int thisIndex = 0; thisIndex < maxN; thisIndex++)\n{\n    ivec3 thisCoord = GetSamplingOrderCoord(thisIndex, DATA);\n    float thisDist = GetSamplingDistance(thisIndex, DATA);\n    if(closestNCount < n)\n    {\n        // Add it to the list.\n        closestNCoords[closestNCount] = thisCoord;\n        closestNDistances[closestNCount] = thisDist;\n        closestNIndices[closestNCount] = thisIndex;\n        closestNCount++;\n    }\n    else\n    {\n        // Replace the furthest one in the list if it is better.\n        \n        int elementToReplace = 0;\n        int furthestIndex = closestNIndices[0];\n        float furthestDistance = closestNDistances[0];\n        {\n            for(int j = 1; j < n; j++)\n            {\n                if(furthestDistance < closestNDistances[j])\n                {\n                    elementToReplace = j;\n                    furthestIndex = closestNIndices[j];\n                    furthestDistance = closestNDistances[j];\n                }\n                else if(furthestDistance == closestNDistances[j])\n                {\n                    // In the case where distances are identical,\n                    // use their position in the original list instead.\n                    // This ensures that all elements have\n                    // a unique rank and thus are kept.\n                    if(furthestIndex < closestNIndices[j])\n                    {\n                        elementToReplace = j;\n                        furthestIndex = closestNIndices[j];\n                        furthestDistance = closestNDistances[j];\n                    }\n                }\n            }\n        }\n        \n        if(thisDist < furthestDistance)\n        {   \n            closestNCoords[elementToReplace] = thisCoord;\n            closestNDistances[elementToReplace] = thisDist;\n            closestNIndices[elementToReplace] = thisIndex;\n        }\n        else if(thisDist == furthestDistance)\n        {\n            // In the case where distances are identical,\n            // use their position in the original list instead.\n            // This ensures that all elements have\n            // a unique rank and thus are kept.\n            if(thisIndex < furthestIndex)\n            {\n                closestNCoords[elementToReplace] = thisCoord;\n                closestNDistances[elementToReplace] = thisDist;\n                closestNIndices[elementToReplace] = thisIndex;\n            }\n        }\n    }\n}\n\n// Our list contains the N closest coordinates.\n// The furthest in this list is the Nth closest element.\n// This will be the coordinate for this fragment.\nint resultElement = 0;\n{\n    int furthestIndex = closestNIndices[0];\n    float furthestDistance = closestNDistances[0];\n    {\n        for(int j = 1; j < n; j++)\n        {\n            if(furthestDistance < closestNDistances[j])\n            {\n                resultElement = j;\n                furthestIndex = closestNIndices[j];\n                furthestDistance = closestNDistances[j];\n            }\n            else if(furthestDistance == closestNDistances[j])\n            {\n                // In the case where distances are identical,\n                // use their position in the original list instead.\n                // This ensures that all elements have\n                // a unique rank and thus are kept.\n                if(furthestIndex < closestNIndices[j])\n                {\n                    resultElement = j;\n                    furthestIndex = closestNIndices[j];\n                    furthestDistance = closestNDistances[j];\n                }\n            }\n        }\n    }\n}\n\n\n            fragColor.xyz = vec3(closestNCoords[resultElement]);\n            fragColor.w = 1.0;\n            return;\n        }\n    }\n    \n    fragColor = texelFetch(DATA, iCoord, 0);\n}\n\nfloat MinimumDistanceBetweenSquares(in ivec2 p1, in ivec2 p2)\n{\n    vec2 p1Center = vec2(p1) + vec2(0.5);\n    vec2 p2Center = vec2(p2) + vec2(0.5);\n    vec2 p1ToP2 = p2Center - p1Center;\n    vec2 offset = clamp(p1ToP2, vec2(-1.0), vec2(1.0));\n    return lengthSqr(p1ToP2 - offset);\n}\n\nvoid UpdateSamplingDistanceData( out vec4 fragColor, in ivec2 iCoord )\n{\n    switch(iFrame)\n    {\n        case SamplingDistanceFrameImprecise:\n        case SamplingDistanceFramePrecise:\n        {\n            ivec2 neighbor = GetSamplingOrderCoord(iCoord.x, DATA).xy;\n            ivec2 me = ivec2(0);\n            fragColor = vec4(0);\n            fragColor.x = MinimumDistanceBetweenSquares(me, neighbor);\n            return;\n        }\n    }\n    \n    fragColor = texelFetch(DATA, iCoord, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCoord = floorToInt(fragCoord);\n    \n    switch(iCoord.y)\n    {\n        case SamplingOrderRow: UpdateSamplingOrderData(fragColor, iCoord); return;\n        case SamplingDistanceRow: UpdateSamplingDistanceData(fragColor, iCoord); return;\n    }\n    \n    fragColor = texelFetch(DATA, iCoord, 0);\n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}