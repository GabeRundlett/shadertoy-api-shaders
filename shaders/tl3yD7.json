{
    "Shader": {
        "info": {
            "date": "1609219012",
            "description": "Working on this big-time to make it fast",
            "flags": 32,
            "hasliked": 0,
            "id": "tl3yD7",
            "likes": 2,
            "name": "Volumetric Nebula",
            "published": 3,
            "tags": [
                "volumetric",
                "nebula",
                "volumetrics",
                "spectral"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 470
        },
        "renderpass": [
            {
                "code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// Common is for Settings and Global Functions\n// Buffer A is for Rendering\n// Buffer B is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\n// Zi7ar21's Spectral Volumetric Nebula --- December 28th, 2020\n// Updated December 31st, 2020 00:15 Mountain Time\n\n// Made with the help of The Marble Marcher Community Edition Discord\n// https://discord.gg/r3XrJxH\n// https://github.com/WAUthethird/Marble-Marcher-Community-Edition\n\n// ##### LICENSE #####\n// I Deem You Allowed to Use My Code, even Commercially, and also Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms.\n\n// You do not have to keep my credits, however I kindly ask you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/tl3yD7\n// Fork of \"Fluffy Cloud\" by Zi7ar21.\n// https://www.shadertoy.com/view/WlcyDn\n// December 27th, 2020\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// ##### EPIC PEOPLE #####\n// Michael Moroz's Improvements\n// Fork of \"Nebula++\" by Michael0884. https://www.shadertoy.com/view/wtdcRS --- December 31st, 2020\n\n// LoicVDB's Improvements\n// Fork of \"cscsdc\" by loicvdb. https://shadertoy.com/view/wlSfRt --- August 8th, 2020\n// Fork of \"dsdfqdf\" by loicvdb. https://www.shadertoy.com/view/tdGyRm --- October 11th, 2020 / December 28th, 2020\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Rendering\n\n// Oof ugly mess below watch out lol\n\n// ##### NOISE #####\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*2.0;\n\nvoid cyclicOctave(inout vec3 p, inout float rz, inout float z, inout float trk, inout float dspAmp){\n    p += sin(p.yzx*0.25*trk-trk*6.0+cos(p*0.1+0.5))*dspAmp;\n    float ofst = 4.5;\n    vec3 s = sin(p*1.25);\n    rz += smoothstep(-1.1, 0.5, dot(s, cos(p.yzx+s.xyz+ofst)))*z;\n    dspAmp *= 0.6;\n    z *= 0.6;\n    trk *= 1.5;\n    p *= m3;\n}\n\nfloat cyclic3D(vec3 p){\n    vec3 bp = p;\n    float rz = 0.0;\n    vec3 drv = vec3(0.0);  \n    float z = 1.4;\n    float trk= 1.0;\n    float dspAmp = 1.0;\n    for (int i = 0; i<=NUM_OCTAVES; i++){cyclicOctave(p, rz, z, trk, dspAmp);}\n    rz -= 1.25;\n    return rz;\n}\n//blue in screen, white in time\nvec4 rand4blue()\n{\n    return texelFetch(iChannel1, shift2(), 0);\n}\n\n// Nebula Noise\nvec3 nebulanoise(vec3 raypos){\n    float density = max(0.0, cyclic3D(raypos)-(distance(raypos, vec3(0.0))*2.0));\n    //vec3 rgb = vec3(clamp(-distance(raypos, vec3(0.0))+1.0, 0.0, 1.0)); // Debug Density Function\n    return density*vec3(0.239, 0.569, 1.000);\n}\n\n// ##### RAYMARCHING #####\nvec3 directLight(vec3 raypos, float dither){\n    vec3 LightColor = vec3(1.0);\n    #ifdef realtime\n    vec3 LightDirection = normalize(vec3(1.0, -0.5, 1.0));\n    #endif\n    #ifndef realtime\n    vec3 LightDirection = normalize(vec3(1.0, -0.5, 1.0)+((rand4().yzw-0.5)*1.5));\n    #endif\n    float distorigin = 0.0;\n    vec3 density = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n    raypos += (LightDirection*(dither-0.5)*STEP_SIZE);\n    for(int i=0; i<MAX_MARCHES; i++){\n        raypos = raypos+(LightDirection*STEP_SIZE);\n        density = nebulanoise(raypos)*DENSITY;\n        vec3 absorbance = exp(-density*STEP_SIZE);\n        attenuation *= absorbance;}\n    return LightColor*attenuation;\n}\n\n// Compute/March the Ray\nvec3 raymarch(vec3 camerapos, vec3 raydir, vec2 coord){\n    float distorigin = 0.0;\n    #ifdef realtime\n    float dither = rand4blue().x;\n    vec3 raypos = camerapos+(raydir*((dither-0.5)*2.0)*STEP_SIZE);\n    #endif\n    #ifndef realtime\n    float dither = rand();\n    vec3 raypos = camerapos+(raydir*((rand()-0.5)*2.0)*STEP_SIZE);\n    #endif\n    vec3 outCol = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n    for(int i=0; i<MAX_MARCHES; i++){\n        raypos = raypos+(raydir*STEP_SIZE);\n        vec3 density = nebulanoise(raypos)*DENSITY;\n        vec3 absorbance = exp(-density*STEP_SIZE);\n        vec3 transmittance = 1.0-absorbance;\n        vec3 directlighting = attenuation*transmittance;\n        if((density.r+density.g+density.b) > 0.0){\n            directlighting = directlighting*directLight(raypos, dither);\n        }\n        outCol += directlighting;\n        attenuation *= absorbance;\n        distorigin = distance(raypos, camerapos);\n        if(distorigin>MAX_DISTANCE) break;\n    }\n    return outCol;\n}\n\n// ##### RENDERING #####\n// Render the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    #ifndef realtime\n    // LoicVDB: I store the number of samples in the alpha channel\n    // LoicVDB: take the previous color and sample count (black and 0 if on first frame)\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    // LoicVDB: I put it in the fragColor var because I want to keep it even if it's not in a tile\n    fragColor = oldFragColor;\n    // LoicVDB's Hyper Epic Tiles Function\n    int index = int(fragCoord.x/iResolution.x*float(TILES))+int(fragCoord.y/iResolution.y*float(TILES))*TILES;\n    if(iFrame-(TILES*TILES*(iFrame/(TILES*TILES))) != index) return;\n    // Start RNG\n    INIT_RNG;\n    #endif\n    #ifdef realtime\n    // Start Blue Noise RNG\n    rng_initialize(fragCoord, 0);\n    #endif\n    // Camera Orientation\n    #ifdef ROTATION_MATRIX\n        vec3 camerapos = vec3(2.0, -2.0, 2.0);\n\t    // Dumb rotation matrix hecking Michael made me make\n\t    float xrot = atan(sqrt(2.0));\n\t    float yrot = pi;\n\t    float zrot = -pi/4.0;\n\t    // Camera Orientation (Cursed)\n        mat3 dir;\n\t    dir[0] = vec3(cos(yrot)*cos(zrot),-cos(yrot)*sin(zrot),sin(yrot));\n\t    dir[1] = vec3(cos(xrot)*sin(zrot)+sin(xrot)*sin(yrot)*cos(zrot),cos(xrot)*cos(zrot)-sin(xrot)*sin(yrot)*sin(zrot),-sin(xrot)*cos(yrot));\n\t    dir[2] = vec3(sin(xrot)*sin(zrot)-cos(xrot)*sin(yrot)*cos(zrot),sin(xrot)*cos(zrot)+cos(xrot)*sin(yrot)*sin(zrot),cos(xrot)*cos(yrot));\n    #endif\n    #ifndef ROTATION_MATRIX\n        vec3 camerapos = vec3(0.0, -2.0, 0.0);\n        vec3 xdir = vec3(1.0,0.0,0.0);\n        vec3 ydir = vec3(0.0,0.0,1.0);\n        vec3 zdir = vec3(0.0,1.0,0.0);\n    #endif\n    #ifdef realtime\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    #endif\n    #ifndef realtime\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 fragCoordDithered = fragCoord+(rand2()-0.5);\n    vec2 uv = (fragCoordDithered-0.5*iResolution.xy)/iResolution.x;\n    #endif\n    #ifdef ROTATION_MATRIX\n    \tvec3 raydir = normalize(FOV*(uv.x*dir[0]+uv.y*dir[1])+dir[2]);\n    #endif\n    #ifndef ROTATION_MATRIX\n        vec3 raydir = normalize(FOV*(uv.x*xdir+uv.y*ydir)+zdir);\n    #endif\n    vec3 raymarched = raymarch(camerapos, raydir, vec2(fragCoord));\n    \n    // Output\n    fragColor += vec4(raymarched, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Exporting a 32-Bit Floating Point OpenEXR Image using the Button on the Bottom of the Editor\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // LoicVDB: take the color from the A buffer\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // LoicVDB: divide it by the sample count (the alpha channel)\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    \n    // Output to screen\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Settings and Global Functions\n\n// ##### COMMON VALUES #####\n// Change these Parameters to Your Liking!\n\n// Maximum Number of Marches,\n// You want it to limit the raymarcher before the max distance parameter or it will look bad.\n#define MAX_MARCHES 8\n\n// Redundant for this idk if the max marches are large and you see ugly stuff then increase this\n#define MAX_DISTANCE 4.0\n\n// Size of Steps, smaller means more sampling over depth but also means more computation.\n// Increase max marches if the scene goes invisible.\n#define STEP_SIZE 0.35\n\n// Camera's FOV\n#define FOV 1.0\n\n// Uncomment to enable rotation matrix for rotating camera, currently too slow\n//#define ROTATION_MATRIX\n\n// Density of the volume. Changes how much light it absorbs.\n#define DENSITY 32.0\n\n// fBm Noise Octaves, more is more detailed with exponentially deminishing return.\n#define NUM_OCTAVES 16\n\n// Tiles, more means easier on the Hardware\n#define TILES 4 // Set to 1 if you have a computer that can handle it so it will render faster\n// So kindly made by LoicVDB uwu\n\n// Realtime\n#define realtime\n\n// Yummy, Pi! 32-Bit Floating Point Precision limits us to 3.14159265, but hey one day Shadertoy\n// may support double precision so why not throw in 3589793.\n#define pi 3.141592653589793\n\n/* High-Quality Noises from Michael Moroz \nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\n// https://www.pcg-random.org/\nvoid pcg(){\n    uint state = ns * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    ns = (word >> 22u) ^ word;\n}\n\nfloat rand(){\n    pcg(); return float(ns)/float(0xffffffffu);\n}\n\nvec2 rand2(){\n    return vec2(rand(), rand());\n}\n\nvec3 rand3(){\n    return vec3(rand(), rand(), rand());\n}\n\nvec4 rand4(){\n    return vec4(rand(), rand(), rand(), rand());    \n}*/\n\n#ifdef realtime\n// Blue Noise for Real-Time dithering (Renders must be viewed 1:1 scale!)\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n}\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1);\n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}\n#endif",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}