{
    "Shader": {
        "info": {
            "date": "1705078060",
            "description": "this is actually super fun\ncomments generated by chatGPT and formatted by chatGPT because my normal code is formatted horribly without any comments",
            "flags": 0,
            "hasliked": 0,
            "id": "XclSR4",
            "likes": 2,
            "name": "Ray tracing- many Balls.",
            "published": 3,
            "tags": [
                "raytracingraytracingballssphere"
            ],
            "usePreview": 0,
            "username": "UsamagorQ",
            "viewed": 105
        },
        "renderpass": [
            {
                "code": "uint seed;\n\n// Random number generator\nfloat random() {\n    seed = seed * 747796405u + 2891336453u;\n    uint result = ((seed >> ((seed >> 28) + 4U)) ^ seed) * 277803737u;\n    result = (result >> 22) ^ result;\n    return float(result) / 4294967295.0;\n}\n\n// Ray structure\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\n// Material structure\nstruct Material {\n    vec3 color;\n};\n\n// Sphere structure\nstruct Sphere {\n    vec3 position;\n    float radius;\n};\n\n// Structure to hold hit information\nstruct HitInfo {\n    bool didHit;\n    float dst;\n    vec3 hitPoint;\n    vec3 normal;\n    Material material;\n};\n\n// Function to check ray-sphere intersection\nHitInfo RaySphere(Ray ray, vec3 sphereCenter, float sphereRadius) {\n    HitInfo hitInfo;\n    vec3 offsetRayOrigin = ray.origin - sphereCenter;\n\n    float a = dot(ray.dir, ray.dir);\n    float b = 2. * dot(offsetRayOrigin, ray.dir);\n    float c = dot(offsetRayOrigin, offsetRayOrigin) - sphereRadius * sphereRadius;\n    float discriminant = b * b - 4. * a * c;\n\n    if (discriminant >= 0.) {\n        float dst = (-b - sqrt(discriminant)) / (2. * a);\n\n        if (dst >= 0.) {\n            hitInfo.didHit = true;\n            hitInfo.dst = dst;\n            hitInfo.hitPoint = ray.origin + ray.dir * dst;\n            hitInfo.normal = normalize(hitInfo.hitPoint - sphereCenter);\n        }\n    }\n\n    return hitInfo;\n}\n\n// Function to check ray-sphere intersections for a scene\nHitInfo Scene(Ray ray) {\n    HitInfo closestHit;\n    closestHit.dst = 1e5;\n\n    HitInfo hitInfo;\n\n    // Call RaySphere for each sphere in the scene\n    hitInfo = RaySphere(ray, vec3(0.25, 1., -1.), 0.25);\n    if (hitInfo.didHit && hitInfo.dst < closestHit.dst) {\n        closestHit = hitInfo;\n        closestHit.material = Material(vec3(0., 1., 0.)); // Set material color\n    }\n\n    hitInfo = RaySphere(ray, vec3(cos(iTime), 0.3, sin(iTime)), 0.5);\n    if (hitInfo.didHit && hitInfo.dst < closestHit.dst) {\n        closestHit = hitInfo;\n        closestHit.material = Material(vec3(0., 0., 1.)); // Set material color\n    }\n    \n    hitInfo = RaySphere(ray, vec3(0., 0., 0.), 0.55);\n    if (hitInfo.didHit && hitInfo.dst < closestHit.dst) {\n        closestHit = hitInfo;\n        closestHit.material = Material(vec3(normalize(cos(iTime)), normalize(cos(iTime/2.)), 0.75)); // Set material color\n    }\n\n    return closestHit;\n}\n\n// Main function for rendering\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Initialize ray and seed\n    Ray ray;\n    ray.origin = vec3(0, 0, 5);\n    seed = floatBitsToUint(texture(iChannel0, fragCoord / iResolution.xy).x + iTime);\n\n    // Generate a random offset\n    vec2 of = -0.5 + vec2(random(), random());\n\n    // Calculate the pixel position in normalized device coordinates\n    vec2 p = (2.0 * (fragCoord + of) - iResolution.xy) / iResolution.y;\n\n    // Calculate the direction from the camera to the view point\n    vec3 viewPoint = vec3(p, 1.);\n    ray.dir = normalize(viewPoint - ray.origin);\n\n       // Set the pixel color based on the material color from the scene\n    HitInfo hi = Scene(ray);\n    fragColor = vec4(hi.material.color, 1.0);\n    //Thanks elenzil for the code for shadows and shading. Very appreciated\n    vec3 lightDir = normalize(vec3(sin(iTime),cos(iTime),1.));    \n    float light = dot(hi.normal, lightDir);\n    ray.origin = hi.hitPoint + lightDir * 0.001;\n    ray.dir    = lightDir;\n    if (Scene(ray).didHit) {\n        light = 0.0;\n    }\n    light = clamp(light, 0.1, 1.0);\n    fragColor.rgb *= light;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}