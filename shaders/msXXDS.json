{
    "Shader": {
        "info": {
            "date": "1675862011",
            "description": "A physically-based atmosphere rendering technique, featuring a multiple scattering approximation and spectral rendering with only four samples.",
            "flags": 32,
            "hasliked": 0,
            "id": "msXXDS",
            "likes": 19,
            "name": "Physically-based sky",
            "published": 3,
            "tags": [
                "sky",
                "volumetric",
                "atmosphere",
                "participatingmedia"
            ],
            "usePreview": 0,
            "username": "fgarlin",
            "viewed": 1021
        },
        "renderpass": [
            {
                "code": "/*\n * Copyright (c) 2023 Fernando García Liñán\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/*\n * You can have a look at all the configurable parameters in the Common tab. \n *\n * This shader is the final result of my Master's Thesis.\n * The main contributions are:\n *\n * 1. A spectral rendering technique that only requires 4 wavelength samples to\n *    get accurate results.\n * 2. A multiple scattering approximation.\n *\n * Both of these approximations rely on an analytical fit, so they only work for\n * Earth's atmosphere. We make up for it by using a very flexible atmosphere\n * model that is able to represent a wide variety of atmospheric conditions.\n *\n * The path tracer that has been used as a ground truth can be found at:\n * https://github.com/fgarlin/skytracer\n */\n \n//------------------------------------------------------------------------------\n\n/*\n * ACES tonemapping fit for the sRGB color space\n * https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n */\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst mat3 aces_input_mat = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n    );\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 aces_output_mat = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n    );\n\nvec3 rrt_and_odt_fit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 aces_fitted(vec3 color)\n{\n\tcolor = aces_input_mat * color;\n    color = rrt_and_odt_fit(color);\n    color = aces_output_mat * color;\n    return clamp(color, 0.0, 1.0);\n}\n\n//-----------------------------------------------------------------------------\n\nvec3 gamma_correct(vec3 linear_srgb)\n{\n    vec3 a = 12.92 * linear_srgb;\n    vec3 b = 1.055 * pow(linear_srgb, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linear_srgb);\n    return mix(a, b, c);\n}\n\nvoid fisheye_camera(in vec2 fragCoord, out float phi, out float theta)\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    if (aspect_ratio < 1.0) {\n        uv.y *= 1.0 / aspect_ratio;\n    } else {\n        uv.x *= aspect_ratio;\n    }\n    phi = atan(uv.y, uv.x);\n    theta = PI * (0.5 - length(uv));\n}\n\nvoid equirectangular_camera(in vec2 fragCoord, out float phi, out float theta)\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    phi = 2.0 * PI * uv.x;\n    theta = PI * uv.y;\n}\n\nmat3 rotX(float a) { float s = sin(a), c = cos(a); return mat3(1.,0.,0.,0.,c,-s,0.,s,c); }\nmat3 rotY(float a) { float s = sin(a), c = cos(a); return mat3(c,0.,s,0.,1.,0.,-s,0.,c); }\nmat3 rotZ(float a) { float s = sin(a), c = cos(a); return mat3(c,-s,0.,s,c,0.,0.,0.,1.); }\n\nvoid projection_camera(in vec2 fragCoord, out float phi, out float theta)\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ray_dir = vec3(1.0 / tan(radians(CAMERA_FOV) * 0.5), uv.x, uv.y);\n    ray_dir = normalize(ray_dir);\n    ray_dir *= rotY(radians(CAMERA_PITCH)) * rotZ(radians(CAMERA_YAW)) * rotX(radians(CAMERA_ROLL));\n\n    phi = atan(ray_dir.y, ray_dir.x);\n    theta = asin(ray_dir.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float phi, theta;\n#if CAMERA_TYPE == 0\n    equirectangular_camera(fragCoord, phi, theta);\n#elif CAMERA_TYPE == 1\n    fisheye_camera(fragCoord, phi, theta);\n#else\n    projection_camera(fragCoord, phi, theta);\n#endif\n\n    float azimuth = phi / PI * 0.5 + 0.5;\n    // Undo the non-linear transformation from the sky-view LUT\n    float elev = sqrt(abs(theta) / (PI * 0.5)) * sign(theta) * 0.5 + 0.5;\n\n    vec3 col = texture(iChannel0, vec2(azimuth, elev)).rgb;\n\n#if SHOW_RELATIVE_LUMINANCE == 0\n#if TONEMAPPING_TECHNIQUE == 0\n    // Apply exposure\n    col = col * exp2(EXPOSURE);\n    // Tonemap\n    col = aces_fitted(col);\n    // Apply the sRGB transfer function (gamma correction)\n    col = clamp(gamma_correct(col), 0.0, 1.0);\n#elif TONEMAPPING_TECHNIQUE == 1\n    const float k = 0.05;\n    col = 1.0 - exp(-k * col);\n    col = clamp(gamma_correct(col), 0.0, 1.0);\n#endif\n#else\n    const mat3 srgb_to_xyz = mat3(0.4124564, 0.2126729, 0.0193339,\n                                  0.3575761, 0.7151522, 0.1191920,\n                                  0.1804375, 0.0721750, 0.9503041);\n    vec3 xyz = srgb_to_xyz * col;\n    float lum = xyz.y * (1.0 / 17.4862339609375);\n    col = vec3(lum);\n#endif\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n * Buffer A: Transmittance LUT\n *\n * In this buffer we precompute the transmittance to the top of the atmosphere.\n * We use the same technique as in \"Precomputed Atmospheric Scattering\"\n * by Eric Bruneton and Fabrice Neyret (2008).\n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float sun_cos_theta = uv.x * 2.0 - 1.0;\n    vec3 sun_dir = vec3(-sqrt(1.0 - sun_cos_theta*sun_cos_theta), 0.0, sun_cos_theta);\n\n    float distance_to_earth_center = mix(EARTH_RADIUS, ATMOSPHERE_RADIUS, uv.y);\n    vec3 ray_origin = vec3(0.0, 0.0, distance_to_earth_center);\n\n    float t_d = ray_sphere_intersection(ray_origin, sun_dir, ATMOSPHERE_RADIUS);\n    float dt = t_d / float(TRANSMITTANCE_STEPS);\n\n    vec4 result = vec4(0.0);\n\n    for (int i = 0; i < TRANSMITTANCE_STEPS; ++i) {\n        float t = (float(i) + 0.5) * dt;\n        vec3 x_t = ray_origin + sun_dir * t;\n\n        float altitude = length(x_t) - EARTH_RADIUS;\n\n        vec4 aerosol_absorption, aerosol_scattering;\n        vec4 molecular_absorption, molecular_scattering;\n        vec4 extinction;\n        get_atmosphere_collision_coefficients(\n            altitude,\n            aerosol_absorption, aerosol_scattering,\n            molecular_absorption, molecular_scattering,\n            extinction);\n\n        result += extinction * dt;\n    }\n\n    vec4 transmittance = exp(-result);\n    fragColor = transmittance;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Configurable parameters\n\n#define ANIMATE_SUN 1\n// 0=equirectangular, 1=fisheye, 2=projection\n#define CAMERA_TYPE 2\n// 0=Background, 1=Desert Dust, 2=Maritime Clean, 3=Maritime Mineral,\n// 4=Polar Antarctic, 5=Polar Artic, 6=Remote Continental, 7=Rural, 8=Urban\n#define AEROSOL_TYPE 8\n\nconst float SUN_ELEVATION_DEGREES = 0.0;    // 0=horizon, 90=zenith\nconst float EYE_ALTITUDE          = 0.5;    // km\nconst int   MONTH                 = 0;      // 0-11, January to December\nconst float AEROSOL_TURBIDITY     = 1.0;\nconst vec4  GROUND_ALBEDO         = vec4(0.3);\n// Ray marching steps. More steps mean better accuracy but worse performance\nconst int TRANSMITTANCE_STEPS     = 32;\nconst int IN_SCATTERING_STEPS     = 32;\n// Camera settings\nconst float EXPOSURE              = -4.0;\n// For the \"projection\" type camera\nconst float CAMERA_FOV   =  90.0;\nconst float CAMERA_YAW   =  15.0;\nconst float CAMERA_PITCH = -12.0;\nconst float CAMERA_ROLL  =   0.0;\n\n// Debug\n#define ENABLE_SPECTRAL 1\n#define ENABLE_MULTIPLE_SCATTERING 1\n#define ENABLE_AEROSOLS 1\n#define SHOW_RELATIVE_LUMINANCE 0\n#define TONEMAPPING_TECHNIQUE 0 // 0=ACES, 1=simple\n\n//-----------------------------------------------------------------------------\n// Constants\n\n// All parameters that depend on wavelength (vec4) are sampled at\n// 630, 560, 490, 430 nanometers\n\nconst float PI = 3.14159265358979323846;\nconst float INV_PI = 0.31830988618379067154;\nconst float INV_4PI = 0.25 * INV_PI;\nconst float PHASE_ISOTROPIC = INV_4PI;\nconst float RAYLEIGH_PHASE_SCALE = (3.0 / 16.0) * INV_PI;\nconst float g = 0.8;\nconst float gg = g*g;\n\nconst float EARTH_RADIUS = 6371.0; // km\nconst float ATMOSPHERE_THICKNESS = 100.0; // km\nconst float ATMOSPHERE_RADIUS = EARTH_RADIUS + ATMOSPHERE_THICKNESS;\nconst float EYE_DISTANCE_TO_EARTH_CENTER = EARTH_RADIUS + EYE_ALTITUDE;\nconst float SUN_ZENITH_COS_ANGLE = cos(radians(90.0 - SUN_ELEVATION_DEGREES));\nconst vec3 SUN_DIR = vec3(-sqrt(1.0 - SUN_ZENITH_COS_ANGLE*SUN_ZENITH_COS_ANGLE), 0.0, SUN_ZENITH_COS_ANGLE);\n\n#if ENABLE_SPECTRAL == 1\n// Extraterrestial Solar Irradiance Spectra, units W * m^-2 * nm^-1\n// https://www.nrel.gov/grid/solar-resource/spectra.html\nconst vec4 sun_spectral_irradiance = vec4(1.679, 1.828, 1.986, 1.307);\n// Rayleigh scattering coefficient at sea level, units km^-1\n// \"Rayleigh-scattering calculations for the terrestrial atmosphere\"\n// by Anthony Bucholtz (1995).\nconst vec4 molecular_scattering_coefficient_base = vec4(6.605e-3, 1.067e-2, 1.842e-2, 3.156e-2);\n// Ozone absorption cross section, units m^2 / molecules\n// \"High spectral resolution ozone absorption cross-sections\"\n// by V. Gorshelev et al. (2014).\nconst vec4 ozone_absorption_cross_section = vec4(3.472e-21, 3.914e-21, 1.349e-21, 11.03e-23) * 1e-4f;\n#else\n// Same as above but for the following \"RGB\" wavelengths: 680, 550, 440 nm\n// The Sun spectral irradiance is also multiplied by a constant factor to\n// compensate for the fact that we use the spectral samples directly as RGB,\n// which is incorrect.\nconst vec4 sun_spectral_irradiance = vec4(1.500, 1.864, 1.715, 0.0) * 150.0;\nconst vec4 molecular_scattering_coefficient_base = vec4(4.847e-3, 1.149e-2, 2.870e-2, 0.0);\nconst vec4 ozone_absorption_cross_section = vec4(3.36e-21f, 3.08e-21f, 20.6e-23f, 0.0) * 1e-4f;\n#endif\n\n// Mean ozone concentration in Dobson for each month of the year.\nconst float ozone_mean_monthly_dobson[] = float[](\n    347.0, // January\n    370.0, // February\n    381.0, // March\n    384.0, // April\n    372.0, // May\n    352.0, // June\n    333.0, // July\n    317.0, // August\n    298.0, // September\n    285.0, // October\n    290.0, // November\n    315.0  // December\n);\n\n/*\n * Every aerosol type expects 5 parameters:\n * - Scattering cross section\n * - Absorption cross section\n * - Base density (km^-3)\n * - Background density (km^-3)\n * - Height scaling parameter\n * These parameters can be sent as uniforms.\n *\n * This model for aerosols and their corresponding parameters come from\n * \"A Physically-Based Spatio-Temporal Sky Model\"\n * by Guimera et al. (2018).\n */\n#if   AEROSOL_TYPE == 0 // Background\nconst vec4 aerosol_absorption_cross_section = vec4(4.5517e-19, 5.9269e-19, 6.9143e-19, 8.5228e-19);\nconst vec4 aerosol_scattering_cross_section = vec4(1.8921e-26, 1.6951e-26, 1.7436e-26, 2.1158e-26);\nconst float aerosol_base_density = 2.584e17;\nconst float aerosol_background_density = 2e6;\n#elif AEROSOL_TYPE == 1 // Desert Dust\nconst vec4 aerosol_absorption_cross_section = vec4(4.6758e-16, 4.4654e-16, 4.1989e-16, 4.1493e-16);\nconst vec4 aerosol_scattering_cross_section = vec4(2.9144e-16, 3.1463e-16, 3.3902e-16, 3.4298e-16);\nconst float aerosol_base_density = 1.8662e18;\nconst float aerosol_background_density = 2e6;\nconst float aerosol_height_scale = 2.0;\n#elif AEROSOL_TYPE == 2 // Maritime Clean\nconst vec4 aerosol_absorption_cross_section = vec4(6.3312e-19, 7.5567e-19, 9.2627e-19, 1.0391e-18);\nconst vec4 aerosol_scattering_cross_section = vec4(4.6539e-26, 2.721e-26, 4.1104e-26, 5.6249e-26);\nconst float aerosol_base_density = 2.0266e17;\nconst float aerosol_background_density = 2e6;\nconst float aerosol_height_scale = 0.9;\n#elif AEROSOL_TYPE == 3 // Maritime Mineral\nconst vec4 aerosol_absorption_cross_section = vec4(6.9365e-19, 7.5951e-19, 8.2423e-19, 8.9101e-19);\nconst vec4 aerosol_scattering_cross_section = vec4(2.3699e-19, 2.2439e-19, 2.2126e-19, 2.021e-19);\nconst float aerosol_base_density = 2.0266e17;\nconst float aerosol_background_density = 2e6;\nconst float aerosol_height_scale = 2.0;\n#elif AEROSOL_TYPE == 4 // Polar Antarctic\nconst vec4 aerosol_absorption_cross_section = vec4(1.3399e-16, 1.3178e-16, 1.2909e-16, 1.3006e-16);\nconst vec4 aerosol_scattering_cross_section = vec4(1.5506e-19, 1.809e-19, 2.3069e-19, 2.5804e-19);\nconst float aerosol_base_density = 2.3864e16;\nconst float aerosol_background_density = 2e6;\nconst float aerosol_height_scale = 30.0;\n#elif AEROSOL_TYPE == 5 // Polar Arctic\nconst vec4 aerosol_absorption_cross_section = vec4(1.0364e-16, 1.0609e-16, 1.0193e-16, 1.0092e-16);\nconst vec4 aerosol_scattering_cross_section = vec4(2.1609e-17, 2.2759e-17, 2.5089e-17, 2.6323e-17);\nconst float aerosol_base_density = 2.3864e16;\nconst float aerosol_background_density = 2e6;\nconst float aerosol_height_scale = 30.0;\n#elif AEROSOL_TYPE == 6 // Remote Continental\nconst vec4 aerosol_absorption_cross_section = vec4(4.5307e-18, 5.0662e-18, 4.4877e-18, 3.7917e-18);\nconst vec4 aerosol_scattering_cross_section = vec4(1.8764e-18, 1.746e-18, 1.6902e-18, 1.479e-18);\nconst float aerosol_base_density = 6.103e18;\nconst float aerosol_background_density = 2e6;\nconst float aerosol_height_scale = 0.73;\n#elif AEROSOL_TYPE == 7 // Rural\nconst vec4 aerosol_absorption_cross_section = vec4(5.0393e-23, 8.0765e-23, 1.3823e-22, 2.3383e-22);\nconst vec4 aerosol_scattering_cross_section = vec4(2.6004e-22, 2.4844e-22, 2.8362e-22, 2.7494e-22);\nconst float aerosol_base_density = 8.544e18;\nconst float aerosol_background_density = 2e6;\nconst float aerosol_height_scale = 0.73;\n#elif AEROSOL_TYPE == 8 // Urban\nconst vec4 aerosol_absorption_cross_section = vec4(2.8722e-24, 4.6168e-24, 7.9706e-24, 1.3578e-23);\nconst vec4 aerosol_scattering_cross_section = vec4(1.5908e-22, 1.7711e-22, 2.0942e-22, 2.4033e-22);\nconst float aerosol_base_density = 1.3681e20;\nconst float aerosol_background_density = 2e6;\nconst float aerosol_height_scale = 0.73;\n#endif\nconst float aerosol_background_divided_by_base_density = aerosol_background_density / aerosol_base_density;\n\n//-----------------------------------------------------------------------------\n\nvec3 get_sun_direction(float time)\n{\n#if ANIMATE_SUN == 0\n    return SUN_DIR;\n#else\n    float a = sin(time*0.5 - 1.5) * 0.55 + 0.45;\n    return vec3(-sqrt(1.0 - a*a), 0.0, a);\n#endif\n}\n\n/*\n * Helper function to obtain the transmittance to the top of the atmosphere\n * from Buffer A.\n */\nvec4 transmittance_from_lut(sampler2D lut, float cos_theta, float normalized_altitude)\n{\n    float u = clamp(cos_theta * 0.5 + 0.5, 0.0, 1.0);\n    float v = clamp(normalized_altitude, 0.0, 1.0);\n    return texture(lut, vec2(u, v));\n}\n\n/*\n * Returns the distance between ro and the first intersection with the sphere\n * or -1.0 if there is no intersection. The sphere's origin is (0,0,0).\n * -1.0 is also returned if the ray is pointing away from the sphere.\n */\nfloat ray_sphere_intersection(vec3 ro, vec3 rd, float radius)\n{\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - radius*radius;\n    if (c > 0.0 && b > 0.0) return -1.0;\n    float d = b*b - c;\n    if (d < 0.0) return -1.0;\n    if (d > b*b) return (-b+sqrt(d));\n    return (-b-sqrt(d));\n}\n\n/*\n * Rayleigh phase function.\n */\nfloat molecular_phase_function(float cos_theta)\n{\n    return RAYLEIGH_PHASE_SCALE * (1.0 + cos_theta*cos_theta);\n}\n\n/*\n * Henyey-Greenstrein phase function.\n */\nfloat aerosol_phase_function(float cos_theta)\n{\n    float den = 1.0 + gg + 2.0 * g * cos_theta;\n    return INV_4PI * (1.0 - gg) / (den * sqrt(den));\n}\n\nvec4 get_multiple_scattering(sampler2D transmittance_lut, float cos_theta, float normalized_height, float d)\n{\n#if ENABLE_MULTIPLE_SCATTERING == 1\n    // Solid angle subtended by the planet from a point at d distance\n    // from the planet center.\n    float omega = 2.0 * PI * (1.0 - sqrt(d*d - EARTH_RADIUS*EARTH_RADIUS) / d);\n\n    vec4 T_to_ground = transmittance_from_lut(transmittance_lut, cos_theta, 0.0);\n\n    vec4 T_ground_to_sample =\n        transmittance_from_lut(transmittance_lut, 1.0, 0.0) /\n        transmittance_from_lut(transmittance_lut, 1.0, normalized_height);\n\n    // 2nd order scattering from the ground\n    vec4 L_ground = PHASE_ISOTROPIC * omega * (GROUND_ALBEDO / PI) * T_to_ground * T_ground_to_sample * cos_theta;\n\n    // Fit of Earth's multiple scattering coming from other points in the atmosphere\n    vec4 L_ms = 0.02 * vec4(0.217, 0.347, 0.594, 1.0) * (1.0 / (1.0 + 5.0 * exp(-17.92 * cos_theta)));\n\n    return L_ms + L_ground;\n#else\n    return vec4(0.0);\n#endif\n}\n\n/*\n * Return the molecular volume scattering coefficient (km^-1) for a given altitude\n * in kilometers.\n */\nvec4 get_molecular_scattering_coefficient(float h)\n{\n    return molecular_scattering_coefficient_base * exp(-0.07771971 * pow(h, 1.16364243));\n}\n\n/*\n * Return the molecular volume absorption coefficient (km^-1) for a given altitude\n * in kilometers.\n */\nvec4 get_molecular_absorption_coefficient(float h)\n{\n    h += 1e-4; // Avoid division by 0\n    float t = log(h) - 3.22261;\n    float density = 3.78547397e20 * (1.0 / h) * exp(-t * t * 5.55555555);\n    return ozone_absorption_cross_section * ozone_mean_monthly_dobson[MONTH] * density;\n}\n\nfloat get_aerosol_density(float h)\n{\n#if AEROSOL_TYPE == 0 // Only for the Background aerosol type, no dependency on height\n    return aerosol_base_density * (1.0 + aerosol_background_divided_by_base_density);\n#else\n    return aerosol_base_density * (exp(-h / aerosol_height_scale)\n        + aerosol_background_divided_by_base_density);\n#endif\n}\n\n/*\n * Get the collision coefficients (scattering and absorption) of the\n * atmospheric medium for a given point at an altitude h.\n */\nvoid get_atmosphere_collision_coefficients(in float h,\n                                           out vec4 aerosol_absorption,\n                                           out vec4 aerosol_scattering,\n                                           out vec4 molecular_absorption,\n                                           out vec4 molecular_scattering,\n                                           out vec4 extinction)\n{\n    h = max(h, 0.0); // In case height is negative\n#if ENABLE_AEROSOLS == 0\n    aerosol_absorption = vec4(0.0);\n    aerosol_scattering = vec4(0.0);\n#else\n    float aerosol_density = get_aerosol_density(h);\n    aerosol_absorption = aerosol_absorption_cross_section * aerosol_density * AEROSOL_TURBIDITY;\n    aerosol_scattering = aerosol_scattering_cross_section * aerosol_density * AEROSOL_TURBIDITY;\n#endif\n    molecular_absorption = get_molecular_absorption_coefficient(h);\n    molecular_scattering = get_molecular_scattering_coefficient(h);\n    extinction = aerosol_absorption + aerosol_scattering + molecular_absorption + molecular_scattering;\n}\n\n//-----------------------------------------------------------------------------\n// Spectral rendering stuff\n\nconst mat4x3 M = mat4x3(\n    137.672389239975, -8.632904716299537, -1.7181567391931372,\n    32.549094028629234, 91.29801417199785, -12.005406444382531,\n    -38.91428392614275, 34.31665471469816, 29.89044807197628,\n    8.572844237945445, -11.103384660054624, 117.47585277566478\n);\n\nvec3 linear_srgb_from_spectral_samples(vec4 L)\n{\n    return M * L;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*\n * Buffer B: Sky texture\n *\n * \"A Scalable and Production Ready Sky and Atmosphere Rendering Technique\"\n * by Sébastien Hillaire (2020).\n *\n * We render the sky to a texture instead of raymarching on the entire screen.\n * This is not very useful in Shadertoy, but very useful for someone looking\n * to implement this on a real application.\n *\n * It is important to note that quality decreases significantly when rendering\n * space views. To avoid this, the compute_inscattering() function can be used\n * directly when rendering to a fullscreen quad.\n */\n \nvec4 compute_inscattering(vec3 ray_origin, vec3 ray_dir, float t_d, out vec4 transmittance)\n{\n    vec3 sun_dir = get_sun_direction(iTime);\n    float cos_theta = dot(-ray_dir, sun_dir);\n\n    float molecular_phase = molecular_phase_function(cos_theta);\n    float aerosol_phase = aerosol_phase_function(cos_theta);\n\n    float dt = t_d / float(IN_SCATTERING_STEPS);\n\n    vec4 L_inscattering = vec4(0.0);\n    transmittance = vec4(1.0);\n\n    for (int i = 0; i < IN_SCATTERING_STEPS; ++i) {\n        float t = (float(i) + 0.5) * dt;\n        vec3 x_t = ray_origin + ray_dir * t;\n\n        float distance_to_earth_center = length(x_t);\n        vec3 zenith_dir = x_t / distance_to_earth_center;\n        float altitude = distance_to_earth_center - EARTH_RADIUS;\n        float normalized_altitude = altitude / ATMOSPHERE_THICKNESS;\n\n        float sample_cos_theta = dot(zenith_dir, sun_dir);\n\n        vec4 aerosol_absorption, aerosol_scattering;\n        vec4 molecular_absorption, molecular_scattering;\n        vec4 extinction;\n        get_atmosphere_collision_coefficients(\n            altitude,\n            aerosol_absorption, aerosol_scattering,\n            molecular_absorption, molecular_scattering,\n            extinction);\n\n        vec4 transmittance_to_sun = transmittance_from_lut(\n            iChannel0, sample_cos_theta, normalized_altitude);\n\n        vec4 ms = get_multiple_scattering(\n            iChannel0, sample_cos_theta, normalized_altitude,\n            distance_to_earth_center);\n\n        vec4 S = sun_spectral_irradiance *\n            (molecular_scattering * (molecular_phase * transmittance_to_sun + ms) +\n             aerosol_scattering   * (aerosol_phase   * transmittance_to_sun + ms));\n\n        vec4 step_transmittance = exp(-dt * extinction);\n\n        // Energy-conserving analytical integration\n        // \"Physically Based Sky, Atmosphere and Cloud Rendering in Frostbite\"\n        // by Sébastien Hillaire\n        vec4 S_int = (S - S * step_transmittance) / max(extinction, 1e-7);\n        L_inscattering += transmittance * S_int;\n        transmittance *= step_transmittance;\n    }\n\n    return L_inscattering;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float azimuth = 2.0 * PI * uv.x;\n\n    // Apply a non-linear transformation to the elevation to dedicate more\n    // texels to the horizon, where having more detail matters.\n    float l = uv.y * 2.0 - 1.0;\n    float elev = l*l * sign(l) * PI * 0.5; // [-pi/2, pi/2]\n\n    vec3 ray_dir = vec3(cos(elev) * cos(azimuth),\n                        cos(elev) * sin(azimuth),\n                        sin(elev));\n\n    vec3 ray_origin = vec3(0.0, 0.0, EYE_DISTANCE_TO_EARTH_CENTER);\n\n    float atmos_dist  = ray_sphere_intersection(ray_origin, ray_dir, ATMOSPHERE_RADIUS);\n    float ground_dist = ray_sphere_intersection(ray_origin, ray_dir, EARTH_RADIUS);\n    float t_d;\n    if (EYE_ALTITUDE < ATMOSPHERE_THICKNESS) {\n        // We are inside the atmosphere\n        if (ground_dist < 0.0) {\n            // No ground collision, use the distance to the outer atmosphere\n            t_d = atmos_dist;\n        } else {\n            // We have a collision with the ground, use the distance to it\n            t_d = ground_dist;\n        }\n    } else {\n        // We are in outer space\n        if (atmos_dist < 0.0) {\n            // No collision with the atmosphere, just return black\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n            return;\n        } else {\n            // Move the ray origin to the atmosphere intersection\n            ray_origin = ray_origin + ray_dir * (atmos_dist + 1e-3);\n            if (ground_dist < 0.0) {\n                // No collision with the ground, so the ray is exiting through\n                // the atmosphere.\n                float second_atmos_dist = ray_sphere_intersection(\n                    ray_origin, ray_dir, ATMOSPHERE_RADIUS);\n                t_d = second_atmos_dist;\n            } else {\n                t_d = ground_dist - atmos_dist;\n            }\n        }\n    }\n\n    vec4 transmittance;\n    vec4 L = compute_inscattering(ray_origin, ray_dir, t_d, transmittance);\n\n#if ENABLE_SPECTRAL == 1\n    fragColor = vec4(linear_srgb_from_spectral_samples(L), 1.0);\n#else\n    fragColor = vec4(L.rgb, 1.0);\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}