{
    "Shader": {
        "info": {
            "date": "1493316975",
            "description": "no description",
            "flags": 0,
            "hasliked": 0,
            "id": "4dBcRd",
            "likes": 7,
            "name": "Trypophobia Nightmare",
            "published": 3,
            "tags": [
                "procedural",
                "distancefields"
            ],
            "usePreview": 0,
            "username": "Karambit",
            "viewed": 613
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n\n#define Scale vec3(.8, .8, .8)\n#define K 19.19\n\n\nvec3 hash(vec3 p3)\n{\n\tp3 = fract(p3 * Scale);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec3 noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nvec3 fbm(in vec3 q)\n{\n            vec3 f  = 0.5000*noise( q ); q = m*q*2.01;\n            f += 0.2500*noise( q ); q = m*q*2.02;\n            f += 0.1250*noise( q ); q = m*q*2.03;\n            f += 0.0625*noise( q ); q = m*q*2.01; \n            f += 0.03125*noise( q ); q = m*q*2.01; \n    return vec3(f);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec3 repeatDomain(in vec3 p, in vec3 m)\n{\n    return p = mod(p, m) - 0.5*m;\n}\n\nfloat map(in vec3 p)\n{\n    vec3 q = repeatDomain(p, vec3(12.0, 0.5, 0.5));\n    \n    float s = sdSphere(q, 0.35);\n    float b = udBox(q, vec3(0.3, 1000, 100));\n    \n    q = repeatDomain(p, vec3(0.01, 8.5, 8.5));\n    float s2 = sdSphere(q, 0.8);\n    \n    \n    return smin(max(-s, b), s2, 2.5);\n}\n\nfloat intersect(in vec3 ro, in vec3 rd)\n{\n    const int MAXITERATIONS = 80;\n    float maxD = 30.0;\n    float minD = 0.001;\n    float t = 0.0;\n    float h = 1.0;\n    for(int i = 0 ; i < MAXITERATIONS; ++i)\n    {\n        if(h < minD || t > maxD)\n            break;\n        h = map(ro+rd*t);\n        t += h;\n    }\n    if( t>maxD ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nvec3 lighting(vec3 p, vec3 ro, vec3 rd)\n{\n    vec3 n = normalize(calcNormal(p));\n    vec3 l = -normalize(ro + vec3(0.,0., -5.0) - p );\n    float d = max(dot(-l, n), 0.0);\n    \n    float s = pow(max(dot(reflect(-l, n), rd), 0.0), 16.0);\n    \n    float a = 1.0 / length(ro - p);\n    \n    return vec3(s+d) * a * 4.0;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.25*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(sin(iTime*0.1)*50.0,cos(iTime*0.1)*50.0, -sin(iTime*0.8));\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    float d = intersect(ro, rd);\n    vec3 p = ro+rd*d;\n    \n    vec3 fg = rd+ro;\n    \n    vec3 fgc = mix(vec3(2.0), vec3(0.5), smoothstep(0.0, 1.0, length(uv-vec2(0.0, 1.0))));\n    \n    vec3 color = vec3(fbm(vec3(vec2(fg.x+iTime*0.1, fg.y)*0.1, 1.0)*2.0).rrg) * fgc;\n    \n    vec3 s = vec3(fbm(p.bbb*2.0).r);\n\n    \n    if(d > 0.0)\n    {\n    \tvec3 l = lighting(p, ro, rd);     \n        vec3 n = calcNormal(p);\n    \n    \tvec3 t = texture(iChannel0, normalize(normalize(reflect(normalize(n), normalize(rd))))).rgb;\n        \n        color = mix(vec3(t*l*s), color, smoothstep(0.3, 1.0, d/20.0));\n    }\n    \n\tfragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}