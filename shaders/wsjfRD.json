{
    "Shader": {
        "info": {
            "date": "1589650755",
            "description": "Dissecting iq's clouds - https://www.shadertoy.com/view/XslGRr and here's what I get by far. No fancy lods or textures. There aren't even lighting! But I am kinda satisfied with this, and will post a lighted up one next morning :P",
            "flags": 0,
            "hasliked": 0,
            "id": "wsjfRD",
            "likes": 29,
            "name": "Simple LoDless Volumetric Clouds",
            "published": 3,
            "tags": [
                "raymarching",
                "simple",
                "clouds",
                "volumetric",
                "iq",
                "lodless"
            ],
            "usePreview": 0,
            "username": "42yeah",
            "viewed": 2165
        },
        "renderpass": [
            {
                "code": "// Created by 42yeah - 42yeah/2020\n// Ripped off from inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Simple LoDless Volumetric clouds. It does NOT perform level of detail (LOD) for faster rendering\n\n// A white noise function.\nfloat rand(vec3 p) {\n    return fract(sin(dot(p, vec3(12.345, 67.89, 412.12))) * 42123.45) * 2.0 - 1.0;\n}\n\n// A perlin noise function. Since we are not using textures, we am gonna sample 8 corners of a cube.\nfloat perlin(vec3 p) {\n    vec3 u = floor(p);\n    vec3 v = fract(p);\n    vec3 s = smoothstep(0.0, 1.0, v);\n    \n    float a = rand(u);\n    float b = rand(u + vec3(1.0, 0.0, 0.0));\n    float c = rand(u + vec3(0.0, 1.0, 0.0));\n    float d = rand(u + vec3(1.0, 1.0, 0.0));\n    float e = rand(u + vec3(0.0, 0.0, 1.0));\n    float f = rand(u + vec3(1.0, 0.0, 1.0));\n    float g = rand(u + vec3(0.0, 1.0, 1.0));\n    float h = rand(u + vec3(1.0, 1.0, 1.0));\n    \n    return mix(mix(mix(a, b, s.x), mix(c, d, s.x), s.y),\n               mix(mix(e, f, s.x), mix(g, h, s.x), s.y),\n               s.z);\n}\n\n// The fbm function. iq unrolled the loop, so I am doing it too.\n// If you wonder what fbm is, check this out: https://thebookofshaders.com/13/\nfloat fbm(vec3 p) {\n    vec3 off = vec3(0.0, 0.1, 1.0) * iTime;\n    vec3 q = p - off;\n    \n    // fbm\n    float f = 0.5 * perlin(q); q *= 2.0;\n    f += 0.25 * perlin(q); q *= 2.0;\n    f += 0.125 * perlin(q); q *= 2.0;\n    f += 0.06250 * perlin(q); q *= 2.0;\n    f += 0.03125 * perlin(q);\n    return clamp(f - p.y, 0.0, 1.0);\n}\n\n// volmetric raymarching, which is kinda like the core algorithm.\n// I ripped lighting calculations and other stuffs off, so this is bare bones raymarching\nvec3 volumetricTrace(vec3 ro, vec3 rd) {\n    // at first there's no depth\n    float depth = 0.0;\n    \n    // and the color's black\n    vec4 sumColor = vec4(0.0);\n    \n    // then we begin to march\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + depth * rd;\n        \n        // and we get the cloud density at said position\n        float density = fbm(p);\n        // if there is an unignorable amount of density (the cloud is thick enough) then\n        if (density > 1e-3) {\n            // we estimate the color with density (the thicker, the whiter)\n            vec4 color = vec4(mix(vec3(0.0), vec3(1.0), density), density);\n            // and we multiply it by a factor so it makes the clouds softer\n            color.w *= 0.4;\n            color.rgb *= color.w;\n            // sumColor.w will rise steadily, which stands for when the ray hits thick enough cloud,\n            // its color won't change anymore\n            sumColor += color * (1.0 - sumColor.a);\n        }\n        // we march forward\n        depth += max(0.05, 0.02 * depth);\n    }\n    return clamp(sumColor.rgb, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // standard raymarching routine\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n\n    vec3 ro = vec3(0.0, 1.0, 5.0);\n    vec3 center = vec3(0.0);\n    \n    vec3 front = normalize(center - ro);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    \n    mat4 lookAt = mat4(\n        vec4(right, 0.0),\n        vec4(up, 0.0),\n        vec4(front, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    vec3 rd = normalize(vec3(lookAt * vec4(uv, 2.0, 1.0)));\n\n    vec3 objColor = volumetricTrace(ro, rd);\n    \n    // gamma correction (yeah, that's definitely not needed here)\n    objColor = pow(objColor, vec3(0.4545));\n\n    fragColor = vec4(objColor, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}