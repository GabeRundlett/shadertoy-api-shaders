{
    "Shader": {
        "info": {
            "date": "1688262173",
            "description": "Long exposure of star trails around Polaris, the North Star, Click/tap mouse to move the star, drag for pointless rotations.",
            "flags": 0,
            "hasliked": 0,
            "id": "cd2yW3",
            "likes": 4,
            "name": "Polaris Star Trails",
            "published": 3,
            "tags": [
                "camera",
                "space",
                "stars"
            ],
            "usePreview": 0,
            "username": "13rac1",
            "viewed": 200
        },
        "renderpass": [
            {
                "code": "/*\n * Polaris Star Trails\n * \n * My first shader\n *\n * Inspired by:\n * https://www.rmg.co.uk/sites/default/files/styles/large/public/2023-06/BN-256390-11%20Radio%20Polaris%20by%20Jo%C3%A3o%20Yordanov%20Serralheiro.jpg?itok=nlSUd2Ms\n * https://image.winudf.com/v2/image/Y29tLkRyZWFtV2FsbHBhcGVycy5TdGFyVHJhaWwwMV9zY3JlZW5zaG90c18zXzU5NGJhZmQ3/screen-3.jpg?fakeurl=1&type=.jpg\n */\n\n#define PI 3.1415926538\n#define TWOPI 2.0 * PI\n#define VIEW_SCALE 13.0\n#define TRAIL_COUNT 60.0\n// Radian length of the star trails, aka \"exposure time\"\n#define TRAIL_RAD TWOPI * 0.05\n#define TRAIL_LAYERS 18.0\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n\n// Screen Blend Mode\n// src: https://www.shadertoy.com/view/4tSGWV\nvec3 screen(vec3 target, vec3 blend){\n    return 1.0 - (1.0 - target) * (1.0 - blend);\n}\n\n// src: https://iquilezles.org/articles/palettes/\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( TWOPI*(c*t+d) );\n}\n\nvec3 pSky(in float t) {    \n    // [[0.138 0.668 0.408] [0.000 0.500 0.500] [0.000 0.178 0.178] [0.000 0.338 1.148]]    \n    return palette(t,\n        vec3(0.138, 0.668, 0.408),\n        vec3(0.000, 0.500, 0.500),\n        vec3(0.000, 0.178, 0.178),\n        vec3(0.000, 0.338, 1.148)\n    );\n}\n\nvec3 pStars(in float t) {        \n    // [[0.718 0.718 1.388] [-0.922 -0.922 0.725] [-0.060 -0.060 1.028] [0.738 0.738 -0.072]]\n    return palette(t,\n        vec3(0.718, 0.718, 1.388),\n        vec3(-0.922, -0.922, 0.725),\n        vec3(-0.060, -0.060, 1.028),\n        vec3(0.738, 0.738, -0.072)\n    );\n}\n\nvec3 drawStarTrail(vec2 randSeed, float starTrail, float trailId, float dist, vec2 cStarUv) {\n    // Not all of them\n    if (random(sin(randSeed)) < 0.3) {\n        return vec3(0);\n    }\n\n    // TEST - Change all star trail starts with time\n    //float radStart = mod(0.0 + iTime, TWOPI);\n    // Radians around the circle where the star starts    \n    float radStart = random(cos(randSeed)) * TWOPI;\n    // starRadStart will never be greater than TWOPI, but starRadEnd can be\n    float radEnd = radStart + TRAIL_RAD;\n\n    // Find the coordinates of the star trail start\n    vec2 posStart = vec2(dist * cos(radStart), dist * sin(radStart));\n    // Find the coordinates of the star trail end\n    vec2 posEnd = vec2(dist * cos(radEnd), dist * sin(radEnd));\n\n    // Find the angle of the current coord, range [0, TWOPI]\n    float radCurrent = PI + atan(cStarUv.y, cStarUv.x);\n    // Find the coordinates of the current star trail\n    vec2 posCurrent= vec2(dist * cos(radCurrent), dist * sin(radCurrent));\n\n    // If the current is less than the start value, then atan() looped.\n    if (radCurrent < radStart) {\n        // Add TWOPI to also push it out of bounds.\n        // range [0, TWOPI + TRAIL_RAD]\n        radCurrent += TWOPI;\n    }\n\n    // Return nothing if we are anywhere other than the star trail\n    if (radStart > radCurrent || radCurrent > radEnd) {\n        return vec3(0);\n    }\n    \n    // Find a reasonable star trail edge fade lenth\n    // TODO: Is there a better option for this calculation?\n    float edgeSize = sqrt(dist/1000.0);\n    \n    // Find the start/end edge distance\n    float edgeStart = distance(posStart, posCurrent);\n    float edgeEnd = distance(posCurrent, posEnd);\n    \n    // Default to no fade\n    float edgeDistance = 1.0;\n    // Fade near the start and end to avoid flat edges to star trails\n    if (edgeStart < edgeSize) {\n        edgeDistance = edgeStart/edgeSize;\n    }\n    else if (edgeEnd < edgeSize) {\n        edgeDistance = edgeEnd/edgeSize;\n    }\n    \n    // Fill star trail\n    float rand = random(randSeed * trailId);\n    // Fade out the selected color by distance to all edges\n    return edgeDistance * pow(starTrail+0.1,2.0) * pStars(rand);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Find the diviser to handle vertical and horizontal screens.\n    float resolutionDiviser = min(iResolution.y,iResolution.x);\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/resolutionDiviser;\n    \n    // Sky Palette [0,1]\n    vec3 col = pSky(uv.y+.5);\n    \n    uv *= VIEW_SCALE;\n   \n    // Draw Center Star\n    vec2 cStarPos = -(iMouse.xy-iResolution.xy*.5)/resolutionDiviser*VIEW_SCALE;\n    // Center the star at startup\n    if (iMouse.x < 0.00001 && iMouse.y < 0.00001) {\n        cStarPos.x = -(iResolution.x/2.0-iResolution.x*.5)/resolutionDiviser*VIEW_SCALE;\n        cStarPos.y = -(iResolution.y/2.0-iResolution.y*.5)/resolutionDiviser*VIEW_SCALE;\n    }\n    vec2 cStarUv = uv + cStarPos;\n        \n    vec2 scaledMouse = iMouse.xy/resolutionDiviser;\n    // Rotate around the center start\n    cStarUv = rotate(cStarUv, iTime/(10.) + length(scaledMouse.xy)*5.);\n    // Draw the center star\n\tfloat cStar = sdCircle(cStarUv,0.13);    \n    col += vec3(smoothstep(0.0,0.15,-cStar));\n        \n    // Find distance to center star\n    float dist = distance(-cStarPos,uv);\n               \n    // Create a unique ID for each trail\n    float trailId = floor(dist * TRAIL_COUNT/PI) + 1.0;\n    \n    // Create star trails from a sine wave emanating from the center star\n    float starTrail = abs(sin(dist * TRAIL_COUNT));\n        \n    // TEST - Select a color for the trail background\n    //vec3 trailColor = (mod(trailId, 2.0) < 0.5) ? vec3(0,0.7,0.2) : vec3(0,1,0.8);    \n    // TEST - Draw star trails\n    //col += trailColor * step(0.6, starTrail);\n    \n    vec2 randSeed = vec2(sin(trailId), cos(trailId));\n    \n    // Draw a few bright layers\n    for(float i = 1.0; i<3.0; i++) {\n        randSeed = tan(randSeed);\n        col = screen(col, drawStarTrail(randSeed, starTrail, trailId, dist, cStarUv));\n    }\n    // Draw many dim layers for depth\n    for(float i = 1.0; i<TRAIL_LAYERS; i++) {\n        randSeed = tan(randSeed);\n        col = screen(col, i/TRAIL_LAYERS*0.6 * drawStarTrail(randSeed, starTrail, trailId, dist, cStarUv));\n    }\n     \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}