{
    "Shader": {
        "info": {
            "date": "1494160600",
            "description": "A day at sea.",
            "flags": 32,
            "hasliked": 0,
            "id": "4d2cDy",
            "likes": 93,
            "name": "OceanView",
            "published": 3,
            "tags": [
                "sea",
                "sun",
                "clouds",
                "fbm",
                "water"
            ],
            "usePreview": 0,
            "username": "kuvkar",
            "viewed": 12618
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n    \n    vec3 rd = texture(iChannel0, vec2(0.5)).rgb;\n    \n    float res = .4;\n    float steps = 3.14159*2.;\n    float focus = 3.;\n \tfloat depth = fragColor.a;\n    \n    float dist = smoothstep(0.0, 2., depth-focus)*3.*dFdx(uv.x);\n    vec3 tcol = vec3(.0);\n    for (float i = 0.; i < steps; i = i + res)\n    {\n        vec2 _uv = uv+vec2(cos(i), sin(i))*dist;\n        tcol += texture(iChannel0, _uv).rgb;    \n    }\n\n    fragColor.rgb = tcol/(steps/res);\n    fragColor.rgb = smoothstep(0.0, 1.0, fragColor.rgb); // contrast\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265358\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\nvec3 lightDir = normalize(vec3(0.0, 1.0, 1.0));\n\nfloat hash( vec2 p ) {\n    return fract(sin(dot(p,vec2(1177.1,2711.7)))*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f * f * (3.0-2.0 * f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat wv(in vec2 uv, vec2 d, float t, float A)\n{\n    return (sin ( dot(d, uv) / 4.0 + t)) * A;\n}\n\n\nfloat fbmClouds(in vec2 uv)\n{\n    uv *= 1.0;\n    \n    float f = texture(iChannel3, uv).r ;\n    \n    // whipping up the clouds a little so they would not look too much like generic fbm\n\tvec2 _uv = uv*10.;\n    mat2 rm  = mat2 (vec2(-sin(f+_uv.y), cos(f+_uv.x)), vec2(cos(f+_uv.y), sin(f+_uv.x)));  \n    uv += .1*uv*rm;\n    \n    f*=.5;\n    f += texture(iChannel3, uv*2.0).r * 0.5*0.5;\n    f += texture(iChannel3, uv*4.0).r * 0.5*0.5*0.5;\n    f += texture(iChannel3, uv*32.0).r * 0.5*0.5*0.5*0.5*0.5;//*0.5;\n    f += texture(iChannel3, uv*8.0).r * 0.5*0.5*0.5*0.5;\n    f += texture(iChannel3, uv*64.0).r * 0.5*0.5*0.5*0.5*0.5;//*0.5;\n    return f;\n}\n\n// water\nfloat fbm(in vec2 uv, float lod)\n{\t\n    float f =  textureLod(iChannel2, uv, lod).r * 0.5;\n    \t  f += textureLod(iChannel2, uv*2.0, lod).r * 0.5*0.5;\n    \t  f += textureLod(iChannel2, uv*4.0, lod).r * 0.5*0.5*0.5;\n    \t  f += textureLod(iChannel2, uv*8.0, lod).r * 0.5*0.5*0.5*0.5;\n\n    f = f*f*f*f;\n    return f;\n}\n\nfloat wavesLo(const in vec3 rp, float t, float A, float lod)\n{\n    vec2 uv = rp.xz;\n    \n    uv.y += pow(max(rp.y + 0.4, 0.0), 10.) * 1.5;\n    float w00 = noise(uv * 1.2 * vec2(.2,  2.2) + vec2(0.20 * t, t * 1.5));\n    float w01 = fbm(uv*.05+vec2(0.0, iTime*.01), lod);\n    float w02 = fbm(uv*.1 +vec2(iTime*.002, iTime*.014), lod);\n    return w00*.12+w01*.1+w02*.1;\n}\n\n// high detail waves\nfloat waves(const in vec3 rp, float t, float A)\n{\n    vec2 uv = rp.xz;\n    vec2 nuv2 = uv+0.05*vec2(noise(uv*5.+t*.03), noise(uv*2.+t*.04));\n    \n    float w3 = wv(nuv2 * 170.0, vec2( -0.1, 0.6), t * 4.5, A) * 0.03;\n\tfloat w4 = wv(nuv2 * 170.0, vec2( 0.1, 0.6) , t * 6.,  A) * 0.03;\n    float w7 = wv(nuv2 * 570.0, vec2( 0.05, 0.4), t * 15., A) * 0.02;\n    float w8 = wv(nuv2 * 570.0, vec2( -0.05, 0.3) , t * 15.,  A) * 0.02;\n    float w5 = -wv(nuv2 * 1670.0, vec2(-0.1, 0.4), t * 63., A) * 0.007;\n    float w6 = -wv(nuv2 * 1670.0, vec2( 0.1, 0.5) ,  t * 63.,  A) * 0.007;\n    \n    return wavesLo(rp, t, A, 0.0) +w3+w4+w7+w8+w5+w6;\n}\n\nfloat mapLo(in vec3 rp)\n{\n    return rp.y - wavesLo(rp, 2.0+iTime*.5, .04, 4.0);\n}\n\n\nfloat map(in vec3 rp)\n{\n    return rp.y - waves(rp, 2.0+iTime*.5, .04);\n}\n\n\nvec3 grad(vec3 rp, float preci)\n{\n    vec2 off = vec2(preci, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n\t\t\t\t  map(rp + off.yxy) - map(rp - off.yxy),                  \n\t\t\t\t  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\n// scanning the surroundings for differences in heights on the heightmap\nvec2 sub(vec3 rp, float preci)\n{\n    vec2 off = vec2(preci, 0.0);\n    vec2 g = vec2(map(rp + off.xyy) + map(rp - off.xyy),\n\t\t\t\t  map(rp + off.yyx) + map(rp - off.yyx));\n    return g;\n}\n\n// for the spec bump \nvec3 texGrad(in vec2 uv)\n{\n    vec2 offset = vec2(0.01, 0.0);\n    uv *= .5;\n    float h0 = texture(iChannel0, uv).r;\n    float h1 = h0-texture(iChannel0, uv+offset.xy).r;\n    float h2 = h0-texture(iChannel0, uv+offset.yx).r;\n    \n    float bump = .4;\n    vec3 g = cross(normalize(vec3(bump, h1, 0.0)), normalize(vec3(0.0, h2, bump)));\n    return g;\n}\n\n\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec3 sun = normalize(vec3(0.0, 0.1, 1.0));\nconst vec3 horizonColor = vec3(.66, .9, 1.0);\n\n\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    // bg\n    vec3 col = horizonColor;\n    color.rgb = mix(col, vec3(0.3, 0.55, .96)*.9, smoothstep(-.15, .2, rd.y));\n    \n    // sun\n    float s = pow(max(dot(rd, normalize(vec3(0.0, 0.7, 1.0))), 0.), 14.0);\n    color.rgb += vec3(.9, .9, 1.0)*s*.3;\n    vec3 sunCenterDir = normalize(vec3(0.0, 0.7, 1.0));\n    vec3 diffV = rd-sunCenterDir;\n    float diffVLen = length(diffV);\n    \n    color.rgb += max(0.0, smoothstep(.0, .3, .11-diffVLen));\n    color.rgb += max(0.0, smoothstep(.0, .02, .03-diffVLen));;\n    \n    float a = atan(diffV.y, diffV.x);\n    float st = iTime*.05;\n    float sl = .8+.2*sin(iTime*.4);\n    float cl = .8+.2*cos(iTime*.2);\n    a += iTime*.01;\n    color += smoothstep(0., .3, (.25*sl)-diffVLen)*max(0.0, .25-abs(sin(a*8.+st)))*(0.2+0.8*max(0., sin(a*2.)));\n    color += smoothstep(0., .4, (.35*cl)-diffVLen)*max(0.0, .25-abs(sin(1.5+a*4.+st)))*(0.3+0.7*max(0., sin(a*3.)));\n    \n    \n    // trace to plane on top of waves\n    vec3 ro = rp;\n    float t = -(0.155+dot(rp, -up)) / dot(-up, rd);\n    if (t < 0.0) \n    {\n        return;\n    }\n    \n\trp += rd*t;    \n    bool hit = false;\n    float dist = 0.0;\n    \n    // actual tracing\n    \n    // low freq\n    for (int i = 0; i < 55; ++i)\n    {\n        float travelledSq=dot(ro-rp, ro-rp);\n        dist = mapLo(rp);\n        \n        if(dist < 0.01)\n        {\n            hit = true;\n            break;\n        }\n        rp += rd * max(dist * (log2(2.+travelledSq)), 0.01);\n        if(travelledSq > 9000.0) break;\n    }\n    \n    //detail tracing\n    for (int i = 0; i < 10; ++i)\n    {\n        rp += dist * rd;\n        if (abs(dist) < 0.0001) break;\n        dist = map(rp);\n    }\n    \n    // shadings\n    if(hit)\n    {        \n        vec3 g = grad(rp, 0.002 * (1.0+log2(length(ro-rp) * 100.)));\n        \n        // base color\n        color = vec4(.05, 0.22, .4, 0.0);\n        \n        // diffuse\n        float d = max(0.0, dot(g, lightDir));\n        color *= mix(1.0, d, .4);\n        \n        // top\n        vec2 heights = sub(rp, 0.3);\n        float sst = length(max(vec2(0.00001), heights));\n        float sunD = -1.*(dot(sun, g));\n        color.rgb = mix(color.rgb, vec3(.2, 0.5, 0.72)*.5, smoothstep(0., .4, sunD));\n        \n        // bottom\n        float ssb = length(min(vec2(0.0), heights));\n        color.rgb = mix(color.rgb, vec3(.05, 0.22, .4)*.5, smoothstep(0.0, 0.4, ssb));\n        \n        // foam\n        vec3 pw = vec3(1.+2.3/(sst*1.+.001))*2.2;\n        vec3 texcol1 = texture(iChannel0, rp.xz*.5+vec2(.0, .07*iTime)).rgb;\n        \n        vec3 pw2 = vec3(1.+.7/(sst*1.2+.01));\n        vec3 texcol2 = texture(iChannel0, rp.xz*.5+vec2(.0, .07*iTime)).rgb*1.;\n        \n        color.rgb += max(pow(texcol1, pw).rrr, pow(texcol2, pw2).rrr);\n        \n        \n        // fresnel\n        vec3 H = normalize(-rd + normalize(sun));\n        float F = clamp(max(0.0, 1.0+dot(rd, g)), 0., 1.);\n        color.rgb += .2*pow(F, 6.)*textureLod(iChannel1, reflect(rd, g), 0.0).rgb;//*vec3(.45, .7, 1.);\n        color.rgb += .4*pow(F, 5.)*vec3(.3, .5, .5)*.5;\n        \n        // spec\n        // +bump        \n        vec3 tg =  texGrad (rp.xz*5.1 + vec2(-iTime*.15, iTime*.6));\n        vec3 tg2 = texGrad (rp.xz*6.2 + vec2( iTime*.1,  iTime*.6));\n        tg = normalize(tg+tg2);\n        tg = normalize(tg+texGrad(rp.xz*4.2 + vec2( iTime*.01, iTime*.5))*0.3);\n        \n        vec3 sg = grad(rp, 0.001);\n        sg = normalize(sg+tg*.3);\n        \n        H = normalize(-rd + normalize(vec3(0.0, 1.0, 1.5)));\n        \n        float specD = max(0.0, dot(H, sg));\n        float spec =  pow(specD, 100.0);\n        color.rgb += spec * vec3(1., .8, .7)*.7;\n    }\n    color.a = length(ro-rp);\n    \n}\n\n\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, .999, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n\tvec2 uv = (fragCoord.xy-iResolution.xy*.5) / iResolution.x;\n    vec2 im = 4.0 * ((iMouse.xy / iResolution.xy) - vec2(0.5));\n    \n    if (iMouse.z <= 0.0)\n    {\n        im = vec2(.1, .2);\n    }\n    \n    vec3 rd = normalize(vec3(uv, (1.0-.2*length(uv))));\n    vec3 rp = vec3(0.0, .3, -1.0);\n    vec3 _rp = rp;\n    rp = roty(im.x) * rp;\n    \n    mat3 lkat = lookat(rp, vec3(0.0, .0+im.y*1., 0.0));\n    rd = lkat * rd;\n\t    \n    trace(rp, rd, fragColor);\n    fragColor.rgb = mix(fragColor.rgb, horizonColor, 0.3 * smoothstep(0.05, 0., abs(rd.y-0.01)));\n    \n    ///////////////\n    // clouds\n    float t = -(6.5+dot(rp, -up)) / dot(-up, rd);\n    if (t>0.)\n    {\n    \t_rp += rd*t;\n        vec2 cuv = iTime*.0004+_rp.xz*.001;\n        float f = fbmClouds(cuv);\n        float f3 = fbmClouds(cuv+vec2(0., -.007));\n        f = max(0.0, f-0.5)/0.5;\n        f3 = max(0.0, f3-0.5)/0.5;\n        f3 = 1.+(f3-f)*.8;\n        f3 = max(f3, .0);\n        fragColor.rgb = mix(fragColor.rgb, f3*vec3(1.0-smoothstep(0.1, .6, f)*.1), f);\n        fragColor.a = t;\n\t}\n    fragColor.rgb = clamp(fragColor.rgb, 0.0, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}