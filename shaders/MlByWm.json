{
    "Shader": {
        "info": {
            "date": "1510430949",
            "description": "2 plane raycasts and 2 cylinder raycasts combined to make a torus looking shape.",
            "flags": 0,
            "hasliked": 0,
            "id": "MlByWm",
            "likes": 11,
            "name": "square ring truchet",
            "published": 3,
            "tags": [
                "3d",
                "raycast",
                "torus",
                "truchet"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 685
        },
        "renderpass": [
            {
                "code": "#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\n#define reflections 3\n\n#define rots mat3(\t\\\n    -1, 0, 1,\t\t\\\n     1,-1, 0,\t\t\\\n     0, 1,-1)\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n//sphere intersection by iq\n//modified to raycast the outside of a circle\nfloat sphIntersect( in vec2 ro, in vec2 rd, float rad)\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro )-rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0||b>0.0) return 1e2;\n\treturn -b - sqrt( h );\n}\n\n//sphere intersection by iq\n//modified to raycast the inside of a circle\nfloat sphIntersect2( in vec2 ro, in vec2 rd, float rad)\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro )-rad*rad;\n\tfloat h = b*b - c;\n\tif(h<0.0) return 1e2;\n\treturn -b + sqrt( h );\n}\n\n//raycasts the outside of a square torus\nfloat torus(vec3 ro, vec3 rd, vec3 rdnorm, vec2 area, float rad) {\n    vec3 normal = vec3(-1);\n    float dist;\n    float a = -ro.y/rd.y;\n    if (a < 0.0 && abs(ro.y) > area.y) return 10.0;\n    float b = abs(area.y/rd.y);\n    float len = max(a-b,0.0);\n    \n    ro += rd*len;\n    dist += len;\n    \n    float len3 = length(ro.xz)-rad;\n    \n    if (len3 > area.x) {\n        float len2 = sphIntersect(ro.xz,rd.xz*rdnorm.y, rad+area.x)*rdnorm.y;\n        ro += rd*len2;\n        dist += len2;\n    }\n    \n    else if (len3 < -area.x) {\n        float len2 = sphIntersect2(ro.xz,rd.xz*rdnorm.y, rad-area.x)*rdnorm.y;\n        ro += rd*len2;\n        dist += len2;\n    }\n    \n    if (abs(ro.y) > area.y+0.001) return 10.0;\n    return dist;\n}\n\n//finds the normal of a square torus\nvec3 torusnormal(vec3 ro, vec2 area, float rad) {\n    vec2 p = vec2(length(ro.xz)-rad,ro.y)*area;\n    vec3 normal = vec3(-1);\n    \n    if (abs(p.x) > abs(p.y)) {\n        normal = vec3(normalize(ro.xz),0.0).xzy*sign(p.x);\n    } else {\n        normal = vec3(0,sign(p.y),0);\n    }\n    \n    return normal;\n}\n\n//my shading function, it isn't very effective since i have almost no experience with shading.\nvec4 shade(vec3 p, vec3 d, vec3 objnorm, float depth) {\n    vec3 sun = normalize(textureLod(iChannel0,vec3(0.0,0.0,iTime*0.01),0.0)).xyz;\n    //vec3 sun = normalize(textureLod(iChannel0,vec3(0,0,iTime*0.01),0.0)).xyz;\n    vec3 reflectnorm = reflect(d,objnorm);\n    vec3 color = clamp(textureLod(iChannel0,p/iChannelResolution[0],0.0).xyz*3.0-1.0,0.0,1.0);\n    \n    vec4 fragColor = vec4(color*max(0.2,2.0*dot(objnorm,-sun)),1.0);\n    \n    fragColor += clamp((dot(reflectnorm,-sun)-0.9)*12.0,0.0,1.0);\n    \n    fragColor = fragColor*clamp(1.4-depth*0.1,0.0,1.0);\n    return clamp((fragColor),0.0,1.0);\n}\n\n//the main function, here is the voxel traverser\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    //if (abs(uv.x-1.0) < 10.0/iResolution.x) uv.x = 1.0;\n    fragColor = vec4(0);\n    \n    vec3 start = vec3(iTime*0.2);\n    vec3 ro = start;\n    vec3 rd = normalize(vec3(uv,1));\n    vec3 rdnorm = 1.0/vec3(\n        length(rd.yz),\n        length(rd.xz),\n        length(rd.xy));\n    \n    vec3 floorro = floor(ro*0.5);\n    vec3 signrd = sign(rd);\n    vec3 invrd = 1.0/(abs(rd)+0.0001);\n    vec3 mask;\n    vec3 dists = abs(-signrd*0.5-0.5+ro*0.5-floorro)*invrd;\n    float colorsize = 0.0;\n    float dist = 0.0;\n    float len2;\n    bool hit = false;\n    vec3 pos;\n    vec3 dir;\n    vec3 normal;\n    int reflects = 0;\n    \n    for (int i = 0; i < 100; i++) {\n        mask = vec3(lessThanEqual(dists,min(dists.yzx,dists.zxy)));\n        if (dist > 20.0) break;\n        float len = min(min(dists.x,dists.y),dists.z);\n        //float len = dot(dists,mask)/dot(mask,vec3(1.0));\n\t\t\n    \tvec3 flipping = floor(hash33(floorro)+0.5)*2.0-1.0;\n        \n        vec3 d = rd;\n        vec3 p = (ro-floorro*2.0-1.0);\n        \n        len2 = len*2.0;\n        \n        vec3 t = vec3(\n        \ttorus((p-rots[0]*flipping).xyz,rd.xyz,rdnorm.xyz,vec2(0.1),1.0),\n        \ttorus((p-rots[1]*flipping).yzx,rd.yzx,rdnorm.yzx,vec2(0.1),1.0),\n        \ttorus((p-rots[2]*flipping).zxy,rd.zxy,rdnorm.zxy,vec2(0.1),1.0));\n        float closest = min(min(t.x,t.y),t.z);\n        len2 = min(len2,closest);\n        dist += len2;\n        \n        ro += len2*rd;\n        \n        if (len2 < len*2.0) {\n            hit = true;\n            p = ro-floorro*2.0-1.0;\n            vec3 normal2;\n            if (t[0] == closest) normal = torusnormal((p-rots[0]*flipping).xyz,vec2(0.1),1.0).xyz;\n            if (t[1] == closest) normal = torusnormal((p-rots[1]*flipping).yzx,vec2(0.1),1.0).zxy;\n            if (t[2] == closest) normal = torusnormal((p-rots[2]*flipping).zxy,vec2(0.1),1.0).yzx;\n            \n            vec4 col = shade(ro,rd,normal,dist);\n        \tfragColor = mix(fragColor,col,0.15);\n            if (reflects == 0) fragColor = col;\n            \n            reflects++;\n            if (reflects > reflections) break;\n            //dist = 0.0;\n            rd = normalize(reflect(rd,normal));\n            ro += rd*0.01;\n            signrd = sign(rd);\n            invrd = 1.0/(abs(rd)+0.0001);\n            dists = abs(-signrd*0.5-0.5+ro*0.5-floorro)*invrd;\n        } else {\n            floorro += mask*signrd;\n            dists -= len;\n            dists += mask*invrd;\n        }\n    }\n    fragColor = sqrt(fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}