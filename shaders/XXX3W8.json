{
    "Shader": {
        "info": {
            "date": "1707380853",
            "description": "throwing in some color into opiumShader\nMouse zoom/rotates and tweaks palette",
            "flags": 0,
            "hasliked": 0,
            "id": "XXX3W8",
            "likes": 9,
            "name": "LSD+opiumShader+mouse",
            "published": 3,
            "tags": [
                "teste"
            ],
            "usePreview": 0,
            "username": "timmaffett",
            "viewed": 204
        },
        "renderpass": [
            {
                "code": "// Fork of \"opiumShader...rs\" by noidnoidnoid. https://shadertoy.com/view/mtGfzV\n// 2024-02-08 08:19:35\n\n//#define USEPALETTE\n#ifdef USEPALETTE\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.5, 0.5, 0.5);\n\n    return a + b * cos(6.28318*(c*t+d) );\n}\n#endif\n\nvec3 hsb2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return (c.z * mix( vec3(1.0), rgb, c.y));\n}\n\n// customizable color from @WhiteTophat  in https://www.shadertoy.com/view/dlBczW\nvec4 lerp(vec4 a, vec4 b, float t) {\n    return (a * vec4(t)) + (b * vec4(1.0-t));\n}\nvec4 lerp(vec4 a, vec4 b, vec4 t) {\n    return (a * t) + (b * (vec4(1.0) * t));\n}\n\nvec4 hue2rgb(float hue) {\n    hue = fract(hue); //only use fractional part of hue, making it loop\n    float r = abs(hue * 6.0 - 3.0) - 1.0; //red\n    float g = 2.0 - abs(hue * 6.0 - 2.0); //green\n    float b = 2.0 - abs(hue * 6.0 - 4.0); //blue\n    vec4 rgb = vec4(r,g,b, 1.0); //combine components\n    rgb = clamp(rgb, 0.0, 1.0); //clamp between 0 and 1\n    return rgb;\n}\nvec4 hsv2rgb(vec3 hsv) {\n    vec4 rgb = hue2rgb(hsv.x); //apply hue\n    rgb = lerp(vec4(1.0), rgb, 1.0 - hsv.y); //apply saturation\n    rgb = rgb * hsv.z; //apply value\n    return rgb;\n}\n\n// simple mouse rotate and zoom for shader\n#define pi 3.14159265359 \n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec2 mouseRotZoom(vec2 uv) {\n    // allow mouse zoom and rotate    \n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0) : iMouse.xy/iResolution.xy;\n    uv.xy *= r2d(-(mouse.x)*pi*2.);\n    uv *= (1./(1.0*mouse.y));\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    vec4 mouseColor;\n    if(iMouse.xy!=vec2(0.)) {\n      vec2 mouseUV = iMouse.xy / iResolution.xy;\n      mouseColor = hsv2rgb(vec3(mouseUV.x, mouseUV.y, 1.0));\n      fragColor *= mouseColor;\n    } else {\n      mouseColor = vec4(1.);\n    }\n    \n    uv = mouseRotZoom(uv);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        //tweak fractal subdivision and center, respectively\n        uv = fract(uv * 2.0) ; // - 0.5 in the end\n\n        float d = length(uv) * exp(-length(uv0));\n\n#ifdef USEPALETTE\n        vec3 col = mouseColor.rgb * hsb2rgb(palette(length(uv) + i*0.4 + iTime));\n#else\n        vec3 col = mouseColor.rgb * hsb2rgb(vec3(length(uv0) + i*0.4 + iTime,0.9,0.9));\n#endif\n\n        d = sin(d*8.0 + iTime*2.)/8.0;\n        d = abs(d);\n\n        //tweak power parameter to rise contrast\n        d = pow(0.01 / d, 1.0);\n\n        finalColor += col * d;\n    }\n    \n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}