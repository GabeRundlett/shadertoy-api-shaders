{
    "Shader": {
        "info": {
            "date": "1385788431",
            "description": "z=vec4(z.x*z.x-z.y*z.y-z.z*z.z+z.w*z.w,2.0*(z.x*z.y-z.z*z.w),2.0*(z.x*z.z-z.y*z.w),2.0*(z.x*z.w+z.y*z.z))+c;//tetrabrot",
            "flags": 0,
            "hasliked": 0,
            "id": "MdSGWR",
            "likes": 3,
            "name": "BiComplex Tetrabrot",
            "published": 3,
            "tags": [
                "fractal",
                "mandelbrot",
                "mandelbulb",
                "bicomplex",
                "tetrabrot"
            ],
            "usePreview": 0,
            "username": "matthewwachter",
            "viewed": 954
        },
        "renderpass": [
            {
                "code": "const int MaxSteps = 128;//basicly viewdistance\nconst int MaxIterations = 40;\nconst float AcceptableDis = 0.0001;\nfloat n = 2.;\n\nconst bool Diffusion = true;\n\n//Camera\nvec3 CameraPos = vec3(0,-10,-5);\nvec3 CameraLookPos = vec3(0,0,0);\nconst vec3 Upwards = vec3(0, -1, 0);\n\n\n//Scene\nfloat MandelBrot(vec3 pos){\n\tvec3 c = pos;\n\tvec3 z = c;\n\tfloat w = 0.0;\n\tfloat distance = 1.0;//final distance calculations\n\tfloat radius = -2.;//radius \n\n\t//vec4 x = vec4(z, (sin(iTime/3.0))*1.1);\n\tvec4 x = vec4(z, w);\n\t\n\tfor (int i = 0; i < MaxIterations ; i++) {\t\t\n\t\t// convert to r,t,p coordinates\n\t\tradius = length(x);\n\t\t\n\t\t//left the system\n\t\tif (radius>2.0) break;\n\t\t\n\t\t//magic distance calculations\n\t\tdistance = pow(radius,n-1.0)*n*distance+1.;\n\t\t\n\t\t// mandelbrot algorithm\n\t\tradius = pow( radius,n);\n\t\t\n\t\t// convert back to x,y,z coordinates\n\t\t\n\t\t//vec4 x = vec4(z, (sin(iTime/3.0))*1.1);\n\t\t\n\t\t\n\t\t// {x,y,z,w}2 = {x2-y2-z2+w2, 2(xy-zw), 2(xz-yw), 2(xw+yz)} tetrabrot\n\t\tx = vec4((x.x*x.x)-(x.y*x.y)-(x.z*x.z)+(x.w*x.w), 2.0*(x.x*x.y-x.z*x.w), 2.0*(x.x*x.z-x.y*x.w), 2.0*(x.x*x.w+x.y*x.z));\n\t\t\n\t\t//eiffie's variation\n\t\t//x = vec4(x.x*x.x-x.y*x.y-x.z*x.z+x.w*x.w,-2.0*(x.x*x.y-x.z*x.w),-2.0*(x.x*x.z-x.y*x.w),2.0*(x.x*x.w+x.y*x.z));//eiffel\n\t\t//x = sqrt(x);\n\t\t//z = x.xyz;\n\t\t//more mandelbrot algorithm\n\t\tx += vec4(c,w);\n\t}\n\t//more magic\n\treturn .5*log(radius)*radius/distance;\n}\nvec3 GetNormal( vec3 pos ){//gets surface normal (it works, but i don't know why)\n\tvec2 d = vec2(.001, 0);\n\tvec3 n;\n    //i think it's creates the normalized surfacevector of a 'created' 'triangle' at the position\n\tn.x = MandelBrot( pos + vec3(d.x,d.y,d.y) ) - MandelBrot( pos - vec3(d.x,d.y,d.y) );\n\tn.y = MandelBrot( pos + vec3(d.y,d.x,d.y) ) - MandelBrot( pos - vec3(d.y,d.x,d.y) );\n\tn.z = MandelBrot( pos + vec3(d.y,d.y,d.x) ) - MandelBrot( pos - vec3(d.y,d.y,d.x) );\n\t//added abs() to normalize function\n\treturn normalize(n);\n}\n\n\n//RayMarch\nvec3 RayMarch(vec3 rp, vec3 rd){\n\tfloat t = AcceptableDis;//begin value of step\n\tfor (int s=0;s<MaxSteps;s++){//go through all steps\n\t\tvec3 nrp = rp+rd*t;//new ray position\n\t\tfloat dis = MandelBrot(nrp);\n\t\tif(dis<AcceptableDis){//if distance is within the hit value\n\t\t\tbreak;//break step loop, there has been a hit\n\t\t}\n\t\tt += dis;//no hit, go futher!\n\t}\n\t\n\treturn(rp+rd*t);//return final ray position\n}\n\nvec3 getFinalColor(vec3 rp, vec3 rd){\n\trp = RayMarch(rp,rd);\n\t\n\tvec3 color = vec3(.01,.01,.01);\n\t//rp.x += (iMouse.x / iResolution.x)-.5;\n\t//rp.y += (iMouse.y / iResolution.y)-.5;\n\tfloat dis = MandelBrot(rp);\n\tif (dis<AcceptableDis){\n\t\tcolor = normalize(sqrt(rp));\n\t\t\n        vec3 surfaceVector = GetNormal(rp);\n\t\tvec3 lightVector = vec3(.5,.5,.5);\n\t\t\n        //diffusion\n        if (Diffusion){\n            float diff = dot(surfaceVector, lightVector)*0.5+0.9;\n\t\t\tif (diff<1.){\n\t\t\t\t color *= diff;\n\t\t\t}\n        }\n\t}else{\n\t\tcolor = vec3(0.0);\n\t}\n\treturn color;\n}\n\n\n\n//main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t//animations\n\tCameraPos = vec3((cos(iTime/10.)*1.2)-.5,-0.4,sin(iTime/10.)*1.2);\n\t\n\t//Camera Recalculations\n\tvec3 CameraLookVector = normalize(CameraLookPos-CameraPos);\n\tvec3 CalculationX = normalize(cross(Upwards, CameraPos));\n\tvec3 CalculationY = normalize(cross(CameraLookVector, CalculationX));\n\t\n\t//Backgroundcolor\n\tvec3 FinalColor = vec3(0,0,0);\n\t\n\t//Scaling\n\tvec2 ScaledPixelPos = (fragCoord.xy / iResolution.xy)*2.0-1.0;//scaling from -1 to 1\n\t     ScaledPixelPos.x *= iResolution.x/iResolution.y;//screen ratio isn't 1:1, scaling can't be from -1 to 1 on both sides, so x has to be a bit longer\n\t\n\t//Ray\n\tvec3 RayPos = CameraPos;\n\tvec3 RayLookVector = normalize(CameraLookVector+CalculationX*ScaledPixelPos.x+CalculationY*ScaledPixelPos.y);//Angle CoÃ«fficiÃ«nct in 3D\n\t\n\tFinalColor = getFinalColor(RayPos, RayLookVector);\n\t\t\n\tfragColor = vec4(FinalColor,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}