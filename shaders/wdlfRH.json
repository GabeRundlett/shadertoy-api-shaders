{
    "Shader": {
        "info": {
            "date": "1587718489",
            "description": "A basic loading ellipse for flat design ",
            "flags": 0,
            "hasliked": 0,
            "id": "wdlfRH",
            "likes": 1,
            "name": "Loading Ellipse Flat",
            "published": 3,
            "tags": [
                "loading"
            ],
            "usePreview": 0,
            "username": "Paltoquet",
            "viewed": 336
        },
        "renderpass": [
            {
                "code": "\n/***\nAuthor: Thibault Ober\nThere is no license attach feel free to enjoy  \n***/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float PI = 3.14159;\n    \n    vec3 color = vec3(0.448,0.800,0.785);\n    vec3 background = vec3(0.418,0.421,0.440);\n    \n    float width = iResolution.x;\n    float height = iResolution.y;\n    float ellipseScale = 2.0;\n    \n    float scale = 1.3;\n    float borderWidthRatio = 0.06;\n    float glowWidthRatio = 1.58;\n    float animationSpeed = 0.42;\n\t\n    float x = (fragCoord.x / iResolution.x);\n    float y = (fragCoord.y / iResolution.y);\n    \n    x = (x * 2.0) - 1.0;\n    y = (y * 2.0) - 1.0;\n    \n\tfloat theta = atan(y, x);\n    float tanTheta = y/x;\n\n    float a = width / scale;\n    float b = height / scale;\n\n    //intersections with the ellipse and the function y = x * tan(theta) https://math.stackexchange.com/questions/22064/calculating-a-point-that-lies-on-an-ellipse-given-an-angle\n    float x1 = a*b / sqrt(b*b + a*a * tanTheta * tanTheta);\n    float y1 = a*b*tanTheta / sqrt(b*b + a*a * tanTheta * tanTheta);\n\n    vec2 point = vec2(x, y) * max(width, height); // work in a square space\n    vec2 pointOnEllipse = vec2(x1, y1);\n\n    float distanceToEllipse = abs(length(pointOnEllipse) - length(point)) / max(width, height);\n    float r = (distanceToEllipse / borderWidthRatio);\n\n    float progress = mod(iTime * animationSpeed, 1.0);\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); //ratio for animation\n\t\n    \n    vec3 currentColor = current <= progress  ? color.xyz : background.xyz;\n    float glowRatio = current <= progress ? 1.0 / glowWidthRatio : 3.0;\n\n    if(r < 1.0){\n        fragColor = vec4(currentColor, 1.0);\n    } else {\n        float alpha = 1.0 - (r - 1.0) * glowRatio;\n        fragColor = vec4(vec3(currentColor * alpha), alpha);\n    }\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}