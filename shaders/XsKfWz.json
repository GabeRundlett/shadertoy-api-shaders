{
    "Shader": {
        "info": {
            "date": "1528479944",
            "description": "Atmospheric scattering code example for a blog post: https://provod.works/blog/2018-06-11-scattering/",
            "flags": 0,
            "hasliked": 0,
            "id": "XsKfWz",
            "likes": 13,
            "name": "Simple atmospheric scattering",
            "published": 3,
            "tags": [
                "example",
                "scattering"
            ],
            "usePreview": 0,
            "username": "w23",
            "viewed": 3636
        },
        "renderpass": [
            {
                "code": "const float R0 = 6360e3; // Earth surface radius\nconst float Ra = 6380e3; // Earth atmosphere top raduis\nconst vec3 bR = vec3(58e-7, 135e-7, 331e-7); // Rayleigh scattering coefficient\nconst vec3 bMs = vec3(2e-5); // Mie scattering coefficients\nconst vec3 bMe = bMs * 1.1;\nconst float I = 10.; // Sun intensity\nconst vec3 C = vec3(0., -R0, 0.); // Earth center point\n\n// Calculate densities $\\rho$.\n// Returns vec2(rho_rayleigh, rho_mie)\n// Note that intro version is more complicated and adds clouds by abusing Mie scattering density. That's why it's a separate function\nvec2 densitiesRM(vec3 p) {\n\tfloat h = max(0., length(p - C) - R0); // calculate height from Earth surface\n\treturn vec2(exp(-h/8e3), exp(-h/12e2));\n}\n\n// Basically a ray-sphere intersection. Find distance to where rays escapes a sphere with given radius.\n// Used to calculate length at which ray escapes atmosphere\nfloat escape(vec3 p, vec3 d, float R) {\n\tvec3 v = p - C;\n\tfloat b = dot(v, d);\n\tfloat det = b * b - dot(v, v) + R*R;\n\tif (det < 0.) return -1.;\n\tdet = sqrt(det);\n\tfloat t1 = -b - det, t2 = -b + det;\n\treturn (t1 >= 0.) ? t1 : t2;\n}\n\n// Calculate density integral for optical depth for ray starting at point `p` in direction `d` for length `L`\n// Perform `steps` steps of integration\n// Returns vec2(depth_int_rayleigh, depth_int_mie)\nvec2 scatterDepthInt(vec3 o, vec3 d, float L, float steps) {\n\t// Accumulator\n\tvec2 depthRMs = vec2(0.);\n\n\t// Set L to be step distance and pre-multiply d with it\n\tL /= steps; d *= L;\n\t\n\t// Go from point P to A\n\tfor (float i = 0.; i < steps; ++i)\n\t\t// Simply accumulate densities\n\t\tdepthRMs += densitiesRM(o + d * i);\n\n\treturn depthRMs * L;\n}\n\n\n// Global variables, needed for size\nvec2 totalDepthRM;\nvec3 I_R, I_M;\n\nvec3 sundir;\n\n// Calculate in-scattering for ray starting at point `o` in direction `d` for length `L`\n// Perform `steps` steps of integration\nvoid scatterIn(vec3 o, vec3 d, float L, float steps) {\n\n\t// Set L to be step distance and pre-multiply d with it\n\tL /= steps; d *= L;\n\n\t// Go from point O to B\n\tfor (float i = 0.; i < steps; ++i) {\n\n\t\t// Calculate position of point P_i\n\t\tvec3 p = o + d * i;\n\n\t\t// Calculate densities\n\t\tvec2 dRM = densitiesRM(p) * L;\n\n\t\t// Accumulate T(P_i -> O) with the new P_i\n\t\ttotalDepthRM += dRM;\n\n\t\t// Calculate sum of optical depths. totalDepthRM is T(P_i -> O)\n\t\t// scatterDepthInt calculates integral part for T(A -> P_i)\n\t\t// So depthRMSum becomes sum of both optical depths\n\t\tvec2 depthRMsum = totalDepthRM + scatterDepthInt(p, sundir, escape(p, sundir, Ra), 4.);\n\n\t\t// Calculate e^(T(A -> P_i) + T(P_i -> O)\n\t\tvec3 A = exp(-bR * depthRMsum.x - bMe * depthRMsum.y);\n\n\t\t// Accumulate I_R and I_M\n\t\tI_R += A * dRM.x;\n\t\tI_M += A * dRM.y;\n\t}\n}\n\n// Final scattering function\n// O = o -- starting point\n// B = o + d * L -- end point\n// Lo -- end point color to calculate extinction for\nvec3 scatter(vec3 o, vec3 d, float L, vec3 Lo) {\n\n\t// Zero T(P -> O) accumulator\n\ttotalDepthRM = vec2(0.);\n\n\t// Zero I_M and I_R\n\tI_R = I_M = vec3(0.);\n\n\t// Compute T(P -> O) and I_M and I_R\n\tscatterIn(o, d, L, 16.);\n\n\t// mu = cos(alpha)\n\tfloat mu = dot(d, sundir);\n\n\t// Calculate Lo extinction\n\treturn Lo * exp(-bR * totalDepthRM.x - bMe * totalDepthRM.y)\n\n\t// Add in-scattering\n\t\t+ I * (1. + mu * mu) * (\n\t\t\tI_R * bR * .0597 +\n\t\t\tI_M * bMs * .0196 / pow(1.58 - 1.52 * mu, 1.5));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    \n    // Fix aspect\n    uv.x *= iResolution.x / iResolution.y;\n    \n    sundir = normalize(vec3(.5, .4 * (1. + sin(.5 * iTime)), -1.));\n    \n    vec3 O = vec3(0., 0., 0.);\n    vec3 D = normalize(vec3(uv, -2.));\n    \n    vec3 col = vec3(0.);\n    float L = escape(O, D, Ra);\n    col = scatter(O, D, L, col);\n\n    fragColor = vec4(sqrt(col), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}