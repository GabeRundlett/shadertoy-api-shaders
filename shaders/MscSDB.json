{
    "Shader": {
        "info": {
            "date": "1463060978",
            "description": "Using a cheaply constructed 3D cellular tile to emulate a 2nd order Voronoi surface in realtime.",
            "flags": 0,
            "hasliked": 0,
            "id": "MscSDB",
            "likes": 202,
            "name": "Cellular Tiled Tunnel",
            "published": 3,
            "tags": [
                "3d",
                "voronoi",
                "tunnel",
                "cellular",
                "tile",
                "2ndorder"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 10752
        },
        "renderpass": [
            {
                "code": "/*\n\n    Cellular Tiled Tunnel\n    ---------------------\n    \n    I've always liked the look of a 2nd order Voronoi surface. IQ's Leizex demo is a great\n\tprerendered example, and for anyone who can remember, Tomasz Dobrowolski's Suboceanic\n\twas cutting edge back in the day.\n\n\tAnyway, I've always wanted to get a proper example working in a shader... Yeah, I need\n\tbigger dreams. :) Unfortunately, I kind of realized that it wasn't going to be possible \n\tuntil GPUs become even faster than they already are, so I figured I'd try the next best \n\tthing and come up with a way to emulate the look with something cheap. This is the \n\tresult. It's not perfect, but it looks surprisingly similar.\n\n\tThe regular 2nd order Voronoi algorithm involves a \"lot\" of operations. In general,\n\t27 cell checks - all involving a bunch of vector arithmetic, fract, sin, floor, \n\tcomparisons, etc... It's possible to cut down on cell checks, perform a bunch of\n\toptimizations, etc, but it's still too much work for a raymarcher.\n\n\tThe surface here is produced via a repeat 3D tile approach. The look is achieved by \n\tperforming 2nd order distance checks on the tiles. I used a highly scientific approach\n\twhich involved crossing my fingers, doing the distance checks and hoping for the best. :)\n\tAmazingly, it produced the result I was looking for.\n\n\tI covered the tile construction in other \"cell tile\" examples, so I'll spare you the \n\tdetails, but it's pretty simple. The only additions here are the second order distance\n\tchecks.\n\n\tIn order to show the surface itself, I've made the example geometric looking - I hope\n\tyou like brown, or whatever color that is. :) Note that individual cell regions are \n\tcolored\tdifferently. I did that to show that it could be done, but I'm not convinced \n\tthat it adds to the aesthetics in any meaningful way.\n\n\tAnyway, I have a few more interesting examples that I'll put up pretty soon.\n\t\n    Related examples: \n\n    Cellular Tiling - Shane\n    https://www.shadertoy.com/view/4scXz2\n\n\t// For comparison, this example uses the standard 2nd order Voronoi algorithm. For fun,\n\t// I dropped the cell tile routine into it and it ran a lot faster.\n\tVoronoi - rocks - iq\n\thttps://www.shadertoy.com/view/MsXGzM\n\n\trgba leizex - Inigo Quilez\n\thttp://www.pouet.net/prod.php?which=51829\n\thttps://www.youtube.com/watch?v=eJBGj8ggCXU\n\thttps://iquilezles.org/prods/index.htm\n\n\tTomasz Dobrowolski - Suboceanic\n\thttp://www.pouet.net/prod.php?which=18343\n\n*/\n\n#define PI 3.14159265358979\n#define FAR 50. // Maximum allowable ray distance.\n\n// Grey scale.\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\n// Non-standard vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// 2x2 matrix rotation.\nmat2 rot2(float a){\n    \n    float c = cos(a); float s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\tvec3 tx = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return tx*tx;\n}\n\n\n// The cellular tile routine. Draw a few objects (four spheres, in this case) using a minumum\n// blend at various 3D locations on a cubic tile. Make the tile wrappable by ensuring the \n// objects wrap around the edges. That's it.\n//\n// Believe it or not, you can get away with as few as three spheres. If you sum the total \n// instruction count here, you'll see that it's way, way lower than 2nd order 3D Voronoi.\n// Not requiring a hash function provides the biggest benefit, but there is also less setup.\n// \n// The result isn't perfect, but 3D cellular tiles can enable you to put a Voronoi looking \n// surface layer on a lot of 3D objects for little cost.\n//\nfloat drawSphere(in vec3 p){\n    \n    // Anything that wraps the domain will suffice, so any of the following will work.\n    //p = cos(p*3.14159)*0.5; \n    //p = abs(cos(p*3.14159)*0.5);    \n    p = fract(p)-.5;    \n    \n    return dot(p, p);\n    \n    // Other metrics to try.\n    \n    //p = abs(fract(p)-.5);\n    //return dot(p, vec3(.5));\n    \n    //p = abs(fract(p)-.5);\n    //return max(max(p.x, p.y), p.z);\n    \n    //p = cos(p*3.14159)*0.5; \n    //p = abs(cos(p*3.14159)*0.5);\n    //p = abs(fract(p)-.5);\n    //return max(max(p.x - p.y, p.y - p.z), p.z - p.x);\n    //return min(min(p.x - p.y, p.y - p.z), p.z - p.x);\n    \n}\n\n// Faster (I'm assuming), more streamlined version. See the comments below for an expanded explanation.\n// The function below is pretty quick also, and can be expanded to include more spheres. This one\n// takes advantage of the fact that only four object need sorting. With three spheres, it'd be even\n// better.\nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawSphere(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawSphere(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawSphere(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    d.x =  min(v.z, v.w) - min(v.x, v.y); // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n    //d.x =  min(v.x, v.y);\n        \n    return (d.x*2.66); // Normalize... roughly.\n    \n}\n\n/*\n// Draw some spheres throughout a repeatable cubic tile. The offsets were partly based on \n// science, but for the most part, you could choose any combinations you want. Note the \n// normalized planar positional roation between sphere rendering to really mix things up. This \n// particular function is used by the raymarcher, so involves fewer spheres.\n//\nfloat cellTile(in vec3 p){\n\n    // Storage for the closest distance metric, second closest and the current\n    // distance for comparisson testing.\n    //\n    // Set the maximum possible value - dot(vec3(.5), vec3(.5)). I think my reasoning is\n    // correct, but I have lousy deductive reasoning, so you may want to double check. :)\n    vec3 d = (vec3(.75)); \n   \n    \n    // Draw some overlapping objects (spheres, in this case) at various positions on the tile.\n    // Then do the fist and second order distance checks. Very simple.\n    d.z = drawSphere(p - vec3(.81, .62, .53));\n    d.x = min(d.x, d.z); //d.y = max(d.x, min(d.y, d.z)); // Not needed on the first iteration.\n    \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawSphere(p - vec3(.39, .2, .11));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071; \n    d.z = drawSphere(p - vec3(.2, .82, .64));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n\n     \n\t// More spheres means better patterns, but slows things down.\n    //p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    //d.z = drawSphere(p - vec3(.48, .29, .2));\n    //d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    //p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    //d.z = drawSphere(p - vec3(.06, .87, .78));\n    //d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z); \n\t\n\n    \n    // Returning what I'm hoping is a normalized result. Not that it\n    // matters too much, but I'd like it normalized.\n    // 2.66 seems to work, but I'll double check at some stage.\n    // d.x: Minimum distance. Regular round Voronoi looking.\n    // d.y - d.x - Maximum minus minimum, for that beveled Voronoi look.\n    //\n    return (d.y - d.x)*2.66; \n    //return 1. - d.x*2.66;\n    //return 1. - sqrt(d.x)*1.63299; // etc.\n\n    \n}\n*/\n\n// Just like the function above, but used to return the regional cell ID...\n// kind of. Either way, it's used to color individual raised sections in\n// the same way that a regular Voronoi function can. It's only called once,\n// so doesn't have to be particularly fast. It's kept separate to the\n// raymarched version, because you don't want to be performing ID checks\n// several times a frame when you don't have to. By the way, that applies\n// to identifying any object in any scene.\n//\n// By the way, it's customary to bundle the respective distance and cell\n// ID into a vector (vec3(d.x, d.y, cellID)) and return that, but I'm \n// keeping it simple here.\n//\nint cellTileID(in vec3 p){\n    \n    int cellID = 0;\n    \n    // Storage for the closest distance metric, second closest and the current\n    // distance for comparisson testing.\n    vec3 d = (vec3(.75)); // Set the maximum.\n    \n    // Draw some overlapping objects (spheres, in this case) at various positions on the tile.\n    // Then do the fist and second order distance checks. Very simple.\n    d.z = drawSphere(p - vec3(.81, .62, .53)); if(d.z<d.x) cellID = 1;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawSphere(p - vec3(.39, .2, .11)); if(d.z<d.x) cellID = 2;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06)); if(d.z<d.x) cellID = 3;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n   \n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071; \n    d.z = drawSphere(p - vec3(.2, .82, .64)); if(d.z<d.x) cellID = 4;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n\n/* \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawSphere2(p - vec3(.48, .29, .2)); if(d.z<d.x) cellID = 5;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere2(p - vec3(.06, .87, .78)); if(d.z<d.x) cellID = 6;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z); \n*/ \n    \n    return cellID;\n    \n}\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ float s = sin(z/24.)*cos(z/16.); return vec2(s*9., 0); }\n\n// Standard tunnel distance function with some perturbation thrown into the mix. A tunnel is just a tube \n// with a smoothly shifting center as you traverse lengthwise. The walls of the tube are perturbed by the\n// cheap 3D surface function I described above.\nfloat map(vec3 p){\n\n    \n    float sf = cellTile(p/2.5);\n    \n    // Tunnel bend correction, of sorts. Looks nice, but slays framerate, which is disappointing. I'm\n    // assuming that \"tan\" function is the bottleneck, but I can't be sure.\n    //vec2 g = (path(p.z + 0.1) - path(p.z - 0.1))/0.2;\n    //g = cos(atan(g));\n    p.xy -= path(p.z);\n    //p.xy *= g;\n  \n    // Round tunnel.\n    // For a round tunnel, use the Euclidean distance: length(p.xy).\n    return 1.- length(p.xy*vec2(0.5, 0.7071)) + (0.5-sf)*.35;\n\n    \n/*\n    // Rounded square tunnel using Minkowski distance: pow(pow(abs(tun.x), n), pow(abs(tun.y), n), 1/n)\n    vec2 tun = abs(p.xy)*vec2(0.5, 0.7071);\n    tun = pow(tun, vec2(8.));\n    float n =1.-pow(tun.x + tun.y, 1.0/8.) + (0.5-sf)*.35;\n    return n;//min(n, p.y + FH);\n*/\n    \n/*\n    // Square tunnel.\n    // For a square tunnel, use the Chebyshev(?) distance: max(abs(tun.x), abs(tun.y))\n    vec2 tun = abs(p.xy - path(p.z))*vec2(0.5, 0.7071);\n    float n = 1.- max(tun.x, tun.y) + (0.5-sf)*.5;\n    return n;\n*/\n \n}\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    for(int i = 0; i < 96; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.002*(t*.125 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*.8;\n        \n    }\n\n    return min(t, FAR);\n    \n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. By the way, there is an \n// aesthetic difference between this and the regular six tap version. Sometimes, it's noticeable,\n// and other times, like this example, it's not.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n/*\n// Standard normal function. 6 taps.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// From an intuitive sense, the function returns a weighted difference between a surface \n// value and some surrounding values. Almost common sense... almost. :)\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.125/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\n/*\n// Oldschool hatching effect. Interesting under the right circumstances.\nvec3 ch(in vec3 col, in vec2 fragCoord){\n    \n    vec3 fColor = col;\n    \n    float lum = dot(col, vec3(.299, .587, .114));// length(col);\n\tfloat mx = 1./7.; // 1.732/7.;\n    \n    float rgt = fragCoord.x + fragCoord.y;\n    float lft = fragCoord.x - fragCoord.y;\n    \n    fColor = col*4.; col *= .6;\n    \n    if (lum < mx*6. && mod(rgt, 8.) == 0.) fColor = col;\n    if (lum < mx*5. && mod(lft, 8.) == 0.) fColor = col;\n    if (lum < mx*4. && mod(rgt, 4.) == 0.) fColor = col;\n    if (lum < mx*3. && mod(lft, 4.) == 0.) fColor = col;\n    if (lum < mx*2. && mod(rgt, 2.) == 0.) fColor = col;\n    if (lum < mx*1. && mod(lft, 2.) == 0.) fColor = col;\n    \n    return min(fColor, 1.);\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lookAt = vec3(0.0, 0.0, iTime*6.);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.1, -0.5); // Camera position, doubling as the ray origin.\n \n    // Light positioning. One is a little behind the camera, and the other is further down the tunnel.\n \tvec3 light_pos = camPos + vec3(0.0, 0.125, 4.125);// Put it a bit in front of the camera.\n\tvec3 light_pos2 = camPos + vec3(0.0, 0.0, 8.0);// Put it a bit in front of the camera.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlight_pos.xy += path(light_pos.z);\n\tlight_pos2.xy += path(light_pos2.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Swiveling the camera from left to right when turning corners.\n    rd.xy = rot2( path(lookAt.z).x/32. )*rd.xy;\n\t\t\n    // Standard ray marching routine.\n    float t = trace(camPos, rd);\n\t\n    // The final scene color. Initated to black.\n\tvec3 sceneCol = vec3(0.);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n\t\n    \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n\t    vec3 sn = calcNormal(sp);\n        \n        // Texture scale factor.\n        const float tSize0 = 1./1.; \n        const float tSize1 = 1./1.;\n    \t\n    \t// Texture-based bump mapping.\n\t    //if (sp.y<-(FH-0.005)) sn = doBumpMap(iChannel1, sp*tSize1, sn, 0.025); // Floor.\n\t    //else sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.025); // Walls.\n        \n        sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.02);\n        //sn = doBumpMap(sp, sn, 0.01);\n\t    \n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);\n    \t\n    \t// Light direction vectors.\n\t    vec3 ld = light_pos-sp;\n\t    vec3 ld2 = light_pos2-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDdist = max(length(ld), 0.001);\n\t    float lDdist2 = max(length(ld2), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDdist;\n\t    ld2 /= lDdist2;\n\t    \n\t    // Light attenuation, based on the distances above. In case it isn't obvious, this\n        // is a cheap fudge to save a few extra lines. Normally, the individual light\n        // attenuations would be handled separately... No one will notice, or care. :)\n\t    float atten = 1./(1. + lDdist*.125 + lDdist*lDdist*.05);\n        float atten2 =  1./(1. + lDdist2*.125 + lDdist2*lDdist2*.05);\n    \t\n    \t// Ambient light.\n\t    float ambience = 0.75;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n\t    float diff2 = max( dot(sn, ld2), 0.0);\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n\t    float spec2 = pow(max( dot( reflect(-ld2, sn), -rd ), 0.0 ), 32.);\n    \t\n    \t// Curvature.\n\t    float crv = clamp(curve(sp, 0.125)*0.5+0.5, .0, 1.);\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n \n        \n        vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\n        texCol = min(texCol*1.5, 1.);\n        //texCol = vec3(1)*dot(texCol, vec3(0.299, 0.587, 0.114));\n        //texCol = smoothstep(-.0, .6, texCol); // etc.\n        \n        //texCol = texCol*vec3(1., .5, .2); \n        int id = cellTileID(sp/2.5);\n        if(id == 4) texCol = texCol*vec3(.8, .6, .4); \n        if(id == 3) texCol = texCol*.5 + texCol*vec3(.5, .35, .2); \n        \n    \t\n    \t// Darkening the crevices. Otherwise known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading =  crv*0.75+0.25; \n    \t\n    \t// Combining the above terms to produce the final color. It was based more on acheiving a\n        // certain aesthetic than science.\n        //\n        // Shiny.\n        sceneCol = (texCol*(diff + ambience + spec) + spec*vec3(.7, .9, 1))*atten;\n        sceneCol += (texCol*(diff2 + ambience + spec2) + spec2*vec3(.7, .9, 1))*atten2;\n        //\n        // Other combinations:\n        //\n        // Glow.\n        //float gr = dot(texCol, vec3(0.299, 0.587, 0.114));\n        //sceneCol = (gr*(diff + ambience*0.25) + spec*texCol*2. + fre*crv*texCol.zyx*2.)*atten;\n        //sceneCol += (gr*(diff2 + ambience*0.25) + spec2*texCol*2. + fre*crv*texCol.zyx*2.)*atten2;\n        \n        // Shading.\n        sceneCol *= shading*ao;\n        \n        // Drawing the lines on the surface.      \n        sceneCol *= clamp(abs(curve(sp, 0.035)), .0, 1.)*.5 + 1.;  // Glow lines.\n        sceneCol *= 1. - smoothstep(0., 4., abs(curve(sp, 0.0125)))*vec3(.82, .85, .88); // Darker.\n\t   \n\t\n\t}\n    \n    // Some simple post processing effects.\n    //float a = dot(sceneCol, vec3(0.299, 0.587, 0.114));\n    //sceneCol = min(vec3(a*3., pow(a, 2.5)*2., pow(a, 6.)), 1.); // Fire palette.\n    //sceneCol = floor(sceneCol*15.999)/15.; // Oldschool effect.  \n    // Oldschool hatching effect. Uncomment the \"ch\" function to use this one.\n    //sceneCol = ch(clamp(sceneCol, 0., 1.), fragCoord); \n\t\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n    \n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}