{
    "Shader": {
        "info": {
            "date": "1640067157",
            "description": "turing pattern generator to show a friend of mine how differential equations work.\n\nSet it to fullscreen while its running!",
            "flags": 32,
            "hasliked": 0,
            "id": "7lySRz",
            "likes": 1,
            "name": "Turing pattern generator",
            "published": 3,
            "tags": [
                "math",
                "physics"
            ],
            "usePreview": 0,
            "username": "copperbotte",
            "viewed": 130
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float c = texture(iChannel0, fragCoord / iResolution.xy).x;\n    if(0.0 < c)\n        col = vec3(0, c, 0.0);\n    else\n        col = vec3(-c, 0, 0.0);\n    \n    // Output to screen\n    fragColor = vec4(lsrgb2srgb(col), 1.0);\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = computeDeltas(fragCoord, iResolution, iTime, iTimeDelta, iFrame, iChannel0, iChannel1);\n    \n    //if(iTime < 5.0)\n    //    uv = texture(iChannel2, fragCoord / iResolution.xy).xy;\n    \n    fragColor = vec4(vec3(uv.x), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n//another random number generator\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat hashrandom( float x )\n{\n    return floatConstruct(hash(floatBitsToUint(x)));\n}\n\n// random number generator **\n// taken from iq :)\nfloat seed;    //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\nfloat laplacian(in sampler2D iChannel, in vec2 uv, in vec3 iResolution)\n{\n    mat3x3 f;\n    for(int i=0; i<3; ++i)\n        for(int j=0; j<3; ++j)\n            f[i][j] = texture(iChannel, uv + vec2(ivec2(i,j) - 1)/iResolution.xy).x;\n    \n    float dx = f[0][1] - 2.0*f[1][1] + f[2][1];\n    float dy = f[1][0] - 2.0*f[1][1] + f[1][2];\n    \n    //return dot(vec2(dx, dy) * (iResolution.xy*iResolution.xy), vec2(1));\n    return (dx + dy)*(450.0); \n}\n\nvec2 computeDeltas(in vec2 fragCoord, in vec3 iResolution, float iTime, float iTimeDelta, int iFrame, sampler2D iChannel0, sampler2D iChannel1)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    seed = hashrandom(iTime + iResolution.y * uv.x + uv.y);\n\n    float u, v; // \"random\" lmao\n    //u = clamp(u, 0.0, 1.0);\n    //v = clamp(v, 0.0, 1.0);\n    \n    if(1.0 < iTime )\n    {\n        u = texture(iChannel0, fragCoord / iResolution.xy).x;\n        v = texture(iChannel1, fragCoord / iResolution.xy).x;\n    }\n    \n    if(u == 0.0)\n        u = rnd();\n    if(v== 0.0)\n        v = rnd();\n    \n    float delu = laplacian(iChannel0, fragCoord / iResolution.xy, iResolution);\n    float delv = laplacian(iChannel1, fragCoord / iResolution.xy, iResolution);\n\n    float tau = 1.0; // 0.1 // 1.0 very cool\n    float sigma = 1.0;\n    float lambda = 1.0;\n    float k = -0.05;\n    float cu = 2.8e-4 * 5.0;\n    float cv = 5e-3 * 5.0;\n\n    float du = cu*delu + lambda*u-u*u*u-k - sigma*v;\n    float dv =(cv*delv + u - v)/tau;\n\n    float rate = 100.0;\n    //if(1.0 < iTime)\n    //if(1.0 < float(iFrame)/240.0)\n    //    rate = 50.0;\n    rate = mix(50.0, 100.0, smoothstep(480.0, 240.0, float(iFrame)));\n\n    u += du / rate;\n    v += dv / rate;\n    \n    return vec2(u, v);\n}\n\n\n\n\n\n// Color space transforms\nfloat lsrgb2srgb(in float lsrgb)\n{\n    if(lsrgb < 0.0031308)\n        return lsrgb * 12.92;\n    float a = 1.055;\n    return a * pow(lsrgb, 1.0/2.4) - (a - 1.0);\n}\n\nvec3 lsrgb2srgb(in vec3 lsrgb)\n{\n    return vec3(lsrgb2srgb(lsrgb.x),lsrgb2srgb(lsrgb.y),lsrgb2srgb(lsrgb.z));\n}\n\nfloat srgb2lsrgb(in float srgb)\n{\n    if(srgb < 0.04045)\n        return srgb / 12.92;\n    float a = 1.055;\n    return pow(1.0 + (srgb - 1.0) / a, 2.4);\n}\n\nvec3 srgb2lsrgb(in vec3 srgb)\n{\n    return vec3(srgb2lsrgb(srgb.x),srgb2lsrgb(srgb.y),srgb2lsrgb(srgb.z));\n}\n\n//https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(in vec3 rgb)\n{\n\tvec4 k = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, k.wz), vec4(rgb.gb, k.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n    \n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    \n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(in vec3 hsv)\n{\n\tvec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(hsv.xxx + k.xyz) * 6.0 - k.www);\n    return hsv.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), hsv.y);    \n}\n\nvec3 saturationClip(in vec3 rgb)\n{\n    vec3 hsv = rgb2hsv(rgb);\n    \n    if(1.0 < hsv.z)\n        hsv.yz /= hsv.z;\n    \n    return hsv2rgb(hsv);\n}\n\n\n\n\n\nfloat cielab_decode(in float lab)\n{\n    float delta = 6.0/29.0;\n    if(delta < lab)\n        return lab * lab * lab;\n    else\n        return 3.0*delta*delta*(lab - 4.0/29.0);\n}\n\nvec3 cieLAB2cieXYZ(in vec3 lab)\n{\n    // Decode lab to ciexyz\n    lab = (lab + vec3(0.16,0.0,0.0)) / vec3(1.16,5.00,2.00);\n    lab = transpose(mat3(1.0, 1.0, 0.0,\n               1.0, 0.0, 0.0,\n               1.0, 0.0,-1.0)) * lab;\n    return vec3(cielab_decode(lab.x),cielab_decode(lab.y),cielab_decode(lab.z));\n}\n\nvec3 cieXYZ2lsrgb(in vec3 xyz)\n{\n    return transpose(mat3(3.2406,-1.5372,-0.4986,\n                -0.9689, 1.8758, 0.0415,\n                 0.0557,-0.2040, 1.0570)) * xyz;\n}\n\n//     Uses a pair of PadÃ© approximants to approximate matplotlib's viridis \n// color map. Computed by converting viridis into cieLAB, where L is linear, and\n// used gradient descent to compute the coefficients.  a* and b* have 0.0091 and\n// 0.0073 max absolute errors.  This colormap undoes the transform into linear\n// srgb color space.\n\nvec3 colorMap( in float scalar )\n{\n    float l_a[9] = float[9](0.80213256, 0.50558149, -0.00293372, 0.01460916, -0.01709858, 0., 0., 0., 0.);\n\n    float a_a[9] = float[9](-0.42688488, -0.87879584, 0.52822597, 0.17720305, 0.37109753, 0., 0., 0., 0.);\n    float a_b[9] = float[9](1., -0.17339854, 0.14818623, 0.04694771, 0.28992562, 0.02420924, 0.29365531, -0.01061596, 0.27261829);\n    \n    float b_a[9] = float[9](-0.08560176, 0.99106308, 0.29440914, 0.21043724, 0.14043312, -0.09626866, 0.07279252, 0., 0.);\n    float b_b[9] = float[9](1., -0.21130356, -0.04647037, 0.00883619, 0.19551535, 0.08748587, 0.28251813, 0., 0.);\n    \n    float t = clamp(scalar, 0.0, 1.0)*2.0 - 1.0;\n    \n    float L = l_a[8];\n    vec4 pade = vec4(a_a[8], a_b[8], b_a[8], b_b[8]);\n    for(int i=7; 0<=i; i--)\n    {\n        L = l_a[i] + t*L;\n        pade = vec4(a_a[i], a_b[i], b_a[i], b_b[i]) + t*pade;\n    }\n    float a = pade.x/pade.y;\n    float b = pade.z/pade.w;\n    \n    vec3 lab = vec3(L/1.3, a, b); // this 1.3 isn't originally part of viridis, but it looks ugly without it\n    vec3 xyz = cieLAB2cieXYZ(lab);\n    vec3 lsrgb = cieXYZ2lsrgb(xyz);\n    return clamp(srgb2lsrgb(lsrgb), 0.0, 1.0); // I thought I compensated for color space in the original computation? Its weird that this is needed here\n    \n    return lsrgb;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = computeDeltas(fragCoord, iResolution, iTime, iTimeDelta, iFrame, iChannel0, iChannel1);\n    \n    //if(iTime < 5.0)\n    //    uv = texture(iChannel2, fragCoord / iResolution.xy).xy;\n    \n    fragColor = vec4(vec3(uv.y), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}