{
    "Shader": {
        "info": {
            "date": "1459780217",
            "description": "Implicit trace using a second order approximation for the distance. Exact gradient/hessian is generated using a forward autodiff scheme. Move the camera by holding down the left mouse button and drag it around. More in the instructions at the top",
            "flags": 16,
            "hasliked": 0,
            "id": "MdtXWM",
            "likes": 16,
            "name": "2nd Order Implicit Approximation",
            "published": 3,
            "tags": [
                "distancefield",
                "spheretracing",
                "implicit",
                "hessian",
                "autodiff",
                "automaticdifferentiation"
            ],
            "usePreview": 0,
            "username": "sibaku",
            "viewed": 1101
        },
        "renderpass": [
            {
                "code": "//*************** INSTRUCTIONS **********************\n//\n// Press and hold 'f' to use the usual first order approximation\n//\n// Press and hold 'p' to use an eigenvalue estimate instead of the frobenius\n// norm (not really a noticeable effect...)\n//\n// Change the value of 'SCENE' just below to switch to different implicits\n//\n// Move the camera by dragging the mouse with left button held down\n//\n//***************************************************\n\n// Scene from 0 to 6\n// Strongest effects are seen in 1,4,5,6\n// Scene 6 was originally a sphere. Same technique can be used to slightly\n// rectify distorted distance fields. As an alternative to computing maximum\n// jacobian derivatives\n#define SCENE 4\n\n//********************************************************************\n//\n// Global defines\n//\n//********************************************************************\n\n// Infinity\n#define AUTO_INFINITY 3.402823e+38\n\nconst float eps = 0.00001;\nconst float pi = 3.14159265359;\n\n// Maximum number of sphere trace steps\nconst int maxSteps = 150;\n\nbool useFirstOrder = false;\nbool usePowerMethod = false;\n\nbool isPressed(int key) {\n  float val = texture(iChannel0, vec2((float(key) + 0.5) / 256.0, 0.25)).x;\n  return val > 0.5;\n}\n\nbool isToggled(int key) {\n  float val = texture(iChannel0, vec2((float(key) + 0.5) / 256.0, 0.75)).x;\n  return val > 0.5;\n}\n\n//********************************************************************\n//\n// Non autodiff code\n//\n//********************************************************************\n\nfloat frobenius(in mat3 m) {\n  return sqrt(dot(m[0], m[0]) + dot(m[1], m[1]) + dot(m[2], m[2]));\n}\n\n// Simple power iteration to find the eigenvalue with largest absolute value\nfloat powerNorm(in mat3 m) {\n  vec3 bk = vec3(1.);\n  bk = normalize(m * bk);\n  bk = normalize(m * bk);\n  bk = normalize(m * bk);\n  bk = normalize(m * bk);\n  return length(m * bk);\n}\n\nfloat calcNorm(in mat3 m) {\n  if (usePowerMethod)\n    return powerNorm(m);\n  else\n    return frobenius(m);\n}\n// Different implicit functions f(x,y,z)\nHNum3 implicit(in HNum3 x, in HNum3 y, in HNum3 z) {\n\n#if SCENE == 0\n  return sub(a_sqrt(add(add(mult(x, x), mult(y, y)), mult(z, z))), constH3(1.));\n#elif SCENE == 1\n  return sub(y, a_sin(add(x, y)));\n#elif SCENE == 1\n\n  return sub(add(mult(x, x), mult(z, z)),\n             mult(z, sub(constH3(1.), mult(y, y))));\n\n#elif SCENE == 2\n  return sub(add(add(a_ipow(x, 4), a_ipow(y, 4)), a_ipow(z, 4)), constH3(1.));\n#elif SCENE == 3\n\n  return sub(sub(a_ipow(sub(add(add(mult(2., mult(x, x)), mult(2., mult(z, z))),\n                                mult(y, y)),\n                            constH3(1.)),\n                        3),\n                 mult(0.1, mult(mult(x, x), a_ipow(y, 3)))),\n             mult(mult(z, z), a_ipow(y, 3)));\n#elif SCENE == 4\n  HNum3 c2 = constH3(2.);\n  HNum3 f1 = mult(a_ipow(sub(x, c2), 2), a_ipow(add(x, c2), 2));\n  HNum3 f2 = mult(a_ipow(sub(y, c2), 2), a_ipow(add(y, c2), 2));\n  HNum3 f3 = mult(a_ipow(sub(z, c2), 2), a_ipow(add(z, c2), 2));\n  HNum3 f4 = mult(\n      3., add(add(mult(mult(x, x), mult(y, y)), mult(mult(x, x), mult(z, z))),\n              mult(mult(y, y), mult(z, z))));\n\n  HNum3 f5 = mult(mult(mult(6., x), y), z);\n  HNum3 f6 = mult(-10., add(add(mult(x, x), mult(y, y)), mult(z, z)));\n\n  return add(add(add(add(add(add(f1, f2), f3), f4), f5), f6), constH3(22.));\n#elif SCENE == 5\n  return add(add(add(mult(mult(a_sin(x), a_sin(y)), a_sin(z)),\n                     mult(mult(a_sin(x), a_cos(y)), a_cos(z))),\n\n                 mult(mult(a_cos(x), a_sin(y)), a_cos(z))),\n\n             mult(mult(a_cos(x), a_cos(y)), a_sin(z)));\n#else\n  HNum3 noise = mult(0.4 * cos(iTime / 10.),\n                     mult(mult(a_cos(mult(22., y)), a_sin(mult(15., y))),\n                          a_sin(mult(14., z))));\n\n  noise = add(noise, mult(0.4 * sin(iTime / 5.), a_cos(mult(2., z))));\n  return add(noise, sub(a_sqrt(add(add(mult(x, x), mult(y, y)), mult(z, z))),\n                        constH3(1.)));\n#endif\n}\nvoid getEye(out vec3 eye, out vec3 center) {\n\n#if SCENE == 4\n  eye = vec3(7., 4., 5.);\n  center = vec3(0.);\n#elif SCENE == 1\n  eye = vec3(7., 5., 3.);\n  center = vec3(0.);\n#else\n  eye = vec3(3., 1., 0.);\n  center = vec3(0.);\n#endif\n}\n\nfloat DE(vec3 p) {\n  HNum3 result;\n  HESSIAN3(implicit, p.x, p.y, p.z, result);\n\n  float g2 = dot(result.g, result.g);\n  float g = sqrt(g2);\n  float v = result.val;\n\n  // First order distance estimation\n  if (useFirstOrder) {\n    if (g < eps) {\n      return v;\n    } else\n      return v / g;\n  } else {\n\n    // Second order uses any compatible matrix norm\n    // Default here is frobenius ->  fast and simple\n    // power method assumes the hessian to be symmetric to calculate spectral\n    // norm (should be for functions with continuous second order partials)\n    float m = calcNorm(result.h);\n\n    // Special cases for zero values\n    if (m < eps) {\n      if (g < eps)\n        return v;\n\n      return v / g;\n    } else if (g < eps) {\n\n      return sqrt(2. * abs(v) / m) * sign(v);\n    }\n\n    return (sqrt(g2 / m / m + 2. * abs(v) / m) - g / m) * sign(v);\n  }\n}\n\nbool trace(in vec3 p, in vec3 dir, out float t, out float dist, out int steps,\n           out vec3 pos) {\n\n  steps = 0;\n  dist = 10000.0;\n  t = 0.;\n\n  float lastT = 0.;\n  for (int i = 0; i < maxSteps; i++) {\n    pos = p + t * dir;\n    float d = DE(pos);\n\n    if (d < eps) {\n      dist = 0.;\n      t = lastT;\n      return true;\n    }\n\n    lastT = t;\n    t += d;\n    steps++;\n    if (t > 100.)\n      return false;\n  }\n\n  return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  fragColor = vec4(uv, 0.5 + 0.5 * sin(iTime), 1.0);\n\n  vec2 camRes = vec2(2., 2. * iResolution.y / iResolution.x);\n  float focal = 1.;\n\n  useFirstOrder = isPressed(70);\n  usePowerMethod = isPressed(80);\n  vec3 eye;\n  vec3 center;\n  getEye(eye, center);\n  // eye += vec3(sin(2.*pi/10.*iTime),0.,cos(2.*pi/10.*iTime))*0.5;\n  // Camera thanks to stb\n  vec2 relativeMouse = iMouse.z <= 0. ? vec2(.5 / iResolution.xy)\n                                      : iMouse.xy / iResolution.xy - .5;\n  eye += vec3(0., relativeMouse.yx) * 12.;\n\n  vec3 dir = normalize(center - eye);\n\n  vec3 up = vec3(0., 1., 0.);\n\n  vec3 right = cross(dir, up);\n\n  vec3 p = eye + focal * dir - right * camRes.x / 2.0 - up * camRes.y / 2.0 +\n           uv.x * camRes.x * right + uv.y * camRes.y * up;\n\n  vec3 rayDir = normalize(p - eye);\n\n  vec3 LPos = vec3(2., 5., 2.);\n  LPos += vec3(0., sin(2. * pi / 10. * iTime), 0.) * 1.5;\n  vec3 col;\n  float t;\n  int steps;\n  float d;\n  vec3 P;\n\n  if (trace(p, rayDir, t, d, steps, P)) {\n    // float stepv = float(steps)/float(maxSteps);\n    // col = vec3(min(1.,exp(-20.*stepv*stepv)));\n    col = vec3(0.8);\n  } else {\n    col = vec3(0.);\n  }\n\n  HNum3 result;\n  HESSIAN3(implicit, P.x, P.y, P.z, result);\n\n  vec3 L = normalize(LPos - P);\n  col *= max(dot(L, normalize(result.g)), 0.) + 0.1;\n\n  fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// My very simple (and probably not overly great) forward-autodiff code from:\n// https://github.com/sibaku/glsl-autodiff\n#ifndef HESSNUM_3_H_\n#define HESSNUM_3_H_\n\n// This file contains methods to compute the gradient and hessian \n// of a scalar valued 3 dimensional function using automatic forward differentiation\n\n//--------------------------------\n// Types\n//--------------------------------\n\n// Data type to hold information about a scalar valued 3 dimensional function\n// These should be created by the constH3 (for constants) and varH3 (for variables) helpers\nstruct HNum3\n{\n    // The current value\n    float val;\n    // The current gradient\n    vec3 g;\n    // The current hessian\n    mat3 h;\n};\n\n//--------------------------------\n// Prototypes\n//--------------------------------\n\n/**\n* Creates a constant HNum3\n* @param val The current value of the constant\n*/\nHNum3 constH3(in float val);\n/**\n* Creates a HNum3 corresponding to the variable with the given index\n* @param val The current value of the variable\n* @param index The variable's index\n*/\nHNum3 varH3(in float val, in int index);\n/**\n* Creates a HNum3 corresponding to the variable x (index = 0)\n* @param val The current value of the variable\n*/\nHNum3 varH3x(in float val);\n/**\n* Creates a HNum3 corresponding to the variable y (index = 1)\n* @param val The current value of the variable\n*/\nHNum3 varH3y(in float val);\n/**\n* Creates a HNum3 corresponding to the variable z (index = 2)\n* @param val The current value of the variable\n*/\nHNum3 varH3z(in float val);\nHNum3 add(in HNum3 a, in HNum3 b);\nHNum3 add(in HNum3 a, in float b);\nHNum3 add(in float a, in HNum3 b);\nHNum3 sub(in HNum3 a, in HNum3 b);\nHNum3 sub(in HNum3 a, in float b);\nHNum3 sub(in float a, in HNum3 b);\nHNum3 mult(in HNum3 a, in HNum3 b);\nHNum3 mult(in HNum3 a, in float b);\nHNum3 mult(in float a, in HNum3 b);\nHNum3 neg(in HNum3 a);\nHNum3 div(in HNum3 a, in HNum3 b);\nHNum3 div(in HNum3 a, in float b);\nHNum3 div(in float a, in HNum3 b);\nHNum3 inv(in HNum3 a);\nHNum3 a_pow(in HNum3 a, in HNum3 b);\nHNum3 a_pow(in HNum3 a, in float b);\nHNum3 a_pow(in float a, in HNum3 b);\nHNum3 a_ipow(in HNum3 x, in int n);\nHNum3 a_min(in HNum3 a, in HNum3 b);\nHNum3 a_max(in HNum3 a, in HNum3 b);\nHNum3 a_exp2(in HNum3 a);\nHNum3 a_inversesqrt(in HNum3 a);\nHNum3 a_atan(in HNum3 a);\nHNum3 a_sqrt(in HNum3 a);\nHNum3 a_sinh(in HNum3 a);\nHNum3 a_ceil(in HNum3 a);\nHNum3 a_tan(in HNum3 a);\nHNum3 a_asinh(in HNum3 a);\nHNum3 a_asin(in HNum3 a);\nHNum3 a_acosh(in HNum3 a);\nHNum3 a_abs(in HNum3 a);\nHNum3 a_exp(in HNum3 a);\nHNum3 a_cosh(in HNum3 a);\nHNum3 a_floor(in HNum3 a);\nHNum3 a_log(in HNum3 a);\nHNum3 a_atanh(in HNum3 a);\nHNum3 a_log2(in HNum3 a);\nHNum3 a_acos(in HNum3 a);\nHNum3 a_tanh(in HNum3 a);\nHNum3 a_cos(in HNum3 a);\nHNum3 a_sin(in HNum3 a);\nHNum3 a_atan2(in HNum3 y, in HNum3 x);\nHNum3 a_atan2(in HNum3 y, in float x);\nHNum3 a_atan2(in float y, in HNum3 x);\nHNum3 a_mix(in HNum3 a, in HNum3 b, in HNum3 t);\nHNum3 a_mix(in HNum3 a, in HNum3 b, in float t);\nHNum3 a_mix(in HNum3 a, in float b, in HNum3 t);\nHNum3 a_mix(in HNum3 a, in float b, in float t);\nHNum3 a_mix(in float a, in HNum3 b, in HNum3 t);\nHNum3 a_mix(in float a, in HNum3 b, in float t);\nHNum3 a_mix(in float a, in float b, in HNum3 t);\n\n//--------------------------------\n// Macros\n//--------------------------------\n\n#define HESSIAN3(f,x, y, z,result)  {     result = f(varH3x(x), varH3y(y), varH3z(z)); }\n\n//--------------------------------\n// Utilities prototypes\n//--------------------------------\n\nmat3 a_outerProduct(in vec3 a, in vec3 b);\n\n//--------------------------------\n// Implementation\n//--------------------------------\n\nHNum3 constH3(in float val)\n{\n    return HNum3(val, vec3(0.0), mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3(in float val, in int index)\n{   \n    vec3 g = vec3(0.0);\n    g[index] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3x(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[0] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3y(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[1] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3z(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[2] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 add(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val + b.val , a.g + b.g, a.h + b.h);\n}\n//--------------------------------\nHNum3 add(in HNum3 a, in float b)\n{\n    return HNum3(a.val + b , a.g, a.h);\n}\n//--------------------------------\nHNum3 add(in float a, in HNum3 b)\n{\n    return HNum3(a + b.val , b.g, b.h);\n}\n//--------------------------------\nHNum3 sub(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val - b.val , a.g - b.g, a.h - b.h);\n}\n//--------------------------------\nHNum3 sub(in HNum3 a, in float b)\n{\n    return HNum3(a.val - b , a.g, a.h);\n}\n//--------------------------------\nHNum3 sub(in float a, in HNum3 b)\n{\n    return HNum3(a - b.val , - b.g, - b.h);\n}\n//--------------------------------\nHNum3 mult(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val * b.val, \n        a.val*b.g + b.val*a.g, \n        a.val*b.h + b.val*a.h + a_outerProduct(b.g,a.g) + a_outerProduct(a.g,b.g)\n    );\n}\n//--------------------------------\nHNum3 mult(in HNum3 a, in float b)\n{\n    return HNum3(a.val * b, b*a.g, b*a.h);\n}\n//--------------------------------\nHNum3 mult(in float a, in HNum3 b)\n{\n    return HNum3(a * b.val, a*b.g, a*b.h);\n}\n//--------------------------------\nHNum3 neg(in HNum3 a)\n{\n    return mult(-1.0,a);\n}\n//--------------------------------\nHNum3 div(in HNum3 a, in HNum3 b)\n{\n    float b1 = b.val;\n    float b2 = b1*b1;\n    float b3 = b2*b1;\n\n    return HNum3(a.val / b.val , \n        (b.val*a.g - a.val*b.g)/b2, \n        2.0*a.val/b3*a_outerProduct(b.g,b.g) \n        - a.val/b2*b.h\n        + a.h/b1 \n        - a_outerProduct(b.g/b2, a.g)\n        - a_outerProduct(a.g/b2, b.g)\n    );\n}\n//--------------------------------\nHNum3 div(in HNum3 a, in float b)\n{\n    return HNum3(a.val / b, a.g/b, a.h/b);\n}\n//--------------------------------\nHNum3 div(in float a, in HNum3 b)\n{\n    float b1 = b.val;\n    float b2 = b1*b1;\n    float b3 = b2*b1;\n\n    return HNum3(a / b.val, \n        -a*b.g/b2, \n        2.0*a/b3*a_outerProduct(b.g,b.g) - a/b2*b.h\n    );\n}\n//--------------------------------\nHNum3 inv(in HNum3 a)\n{\n    return div(1.0, a);\n}\n//--------------------------------\nHNum3 a_pow(in HNum3 a, in HNum3 b)\n{\n    return a_exp(mult(b,a_log(a)));\n}\n//--------------------------------\nHNum3 a_pow(in HNum3 a, in float b)\n{\n    // constant exponent -> make special case\n    float v = pow(a.val, b); // value f(a(x))\n    float da = b*pow(a.val,b-1.0); // first derivative f'(a(x))\n    float dda = b*(b-1.0)*pow(a.val,b-2.0); // second derivative f''(a(x))\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_pow(in float a, in HNum3 b)\n{\n    return a_exp(mult(b,log(a)));\n}\n//--------------------------------\nHNum3 a_ipow(in HNum3 x, in int n)\n{\n    // based on https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    if (n < 0)\n    {   \n        x = div(1.0,x);\n        n = -n;\n    }\n    if (n == 0) \n    {\n        return constH3(1.0);\n    }\n    HNum3 y = constH3(1.0);\n    while (n > 1)\n    {\n        if (n % 2 == 0)\n        {   \n            x = mult(x,x);\n            \n        }\n        else\n        {    \n            y = mult(x, y);\n            x = mult(x, x);\n        }\n\n        n = n / 2;\n    }\n    \n    return mult(x, y);\n}\n\n//--------------------------------\nHNum3 a_min(in HNum3 a, in HNum3 b)\n{\n    if(a.val < b.val)\n    {\n        return a;\n    }\n    return b;\n}\n//--------------------------------\nHNum3 a_max(in HNum3 a, in HNum3 b)\n{\n    if(a.val > b.val)\n    {\n        return a;\n    }\n    return b;\n}\n//--------------------------------\nHNum3 a_exp2(in HNum3 a)\n{\n    float v = exp2(a.val); // value f(a(x))\n    float da = log(2.0)*exp2(a.val); // first derivative f'(a(x))\n    float dda = log(2.0)*log(2.0)*exp2(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_inversesqrt(in HNum3 a)\n{\n    float v = inversesqrt(a.val); // value f(a(x))\n    float da = -0.5/pow(sqrt(a.val),3.0); // first derivative f'(a(x))\n    float dda = 0.75/pow(sqrt(a.val),5.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atan(in HNum3 a)\n{\n    float v = atan(a.val); // value f(a(x))\n    float da = 1.0/(1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -2.0*a.val/pow(1.0 + a.val * a.val, 2.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sqrt(in HNum3 a)\n{\n    float v = sqrt(a.val); // value f(a(x))\n    float da = 0.5/sqrt(a.val); // first derivative f'(a(x))\n    float dda = -0.25/pow(sqrt(a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sinh(in HNum3 a)\n{\n    float v = sinh(a.val); // value f(a(x))\n    float da = cosh(a.val); // first derivative f'(a(x))\n    float dda = sinh(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_ceil(in HNum3 a)\n{\n    float v = ceil(a.val); // value f(a(x))\n    float da = 0.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_tan(in HNum3 a)\n{\n    float v = tan(a.val); // value f(a(x))\n    float da = 1.0 + pow(tan(a.val),2.0); // first derivative f'(a(x))\n    float dda = 2.0*tan(a.val)*(1.0 + pow(tan(a.val),2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_asinh(in HNum3 a)\n{\n    float v = asinh(a.val); // value f(a(x))\n    float da = 1.0/sqrt(1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(1.0 + a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_asin(in HNum3 a)\n{\n    float v = asin(a.val); // value f(a(x))\n    float da = 1.0/sqrt(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = a.val/pow(sqrt(1.0 - a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_acosh(in HNum3 a)\n{\n    float v = acosh(a.val); // value f(a(x))\n    float da = 1.0/sqrt(-1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(-1.0 + a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_abs(in HNum3 a)\n{\n    float v = abs(a.val); // value f(a(x))\n    float da = a.val < 0.0 ? -1.0 : 1.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_exp(in HNum3 a)\n{\n    float v = exp(a.val); // value f(a(x))\n    float da = exp(a.val); // first derivative f'(a(x))\n    float dda = exp(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_cosh(in HNum3 a)\n{\n    float v = cosh(a.val); // value f(a(x))\n    float da = sinh(a.val); // first derivative f'(a(x))\n    float dda = cosh(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_floor(in HNum3 a)\n{\n    float v = floor(a.val); // value f(a(x))\n    float da = 0.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_log(in HNum3 a)\n{\n    float v = log(a.val); // value f(a(x))\n    float da = 1.0/a.val; // first derivative f'(a(x))\n    float dda = -1.0/(a.val * a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atanh(in HNum3 a)\n{\n    float v = atanh(a.val); // value f(a(x))\n    float da = 1.0/(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = 2.0*a.val/pow(1.0 - a.val * a.val,2.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_log2(in HNum3 a)\n{\n    float v = log2(a.val); // value f(a(x))\n    float da = 1.0/(a.val * log(2.0)); // first derivative f'(a(x))\n    float dda = -1.0/(a.val * a.val * log(2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_acos(in HNum3 a)\n{\n    float v = acos(a.val); // value f(a(x))\n    float da = -1.0/sqrt(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(1.0 - a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_tanh(in HNum3 a)\n{\n    float v = tanh(a.val); // value f(a(x))\n    float da = 1.0 - pow(tanh(a.val),2.0); // first derivative f'(a(x))\n    float dda = -2.0*tanh(a.val)*(1.0 - pow(tanh(a.val),2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_cos(in HNum3 a)\n{\n    float v = cos(a.val); // value f(a(x))\n    float da = -sin(a.val); // first derivative f'(a(x))\n    float dda = -cos(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sin(in HNum3 a)\n{\n    float v = sin(a.val); // value f(a(x))\n    float da = cos(a.val); // first derivative f'(a(x))\n    float dda = -sin(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atan2(in HNum3 y, in HNum3 x)\n{\n    const float pi = 3.14159265; \n    // from https://en.wikipedia.org/wiki/Atan2\n    if(x.val > 0.0)\n    {\n        HNum3 n = a_sqrt(add(mult(x,x),mult(y,y)));\n        HNum3 inner = div(y, add(n,x));\n        \n        return mult(2.0,a_atan(inner));\n        \n    }else if(x.val <= 0.0 && abs(y.val) > 1E-6)\n    {\n        HNum3 n = a_sqrt(add(mult(x,x),mult(y,y)));\n        HNum3 inner = div(sub(n,x),y);\n         return mult(2.0,a_atan(inner));\n    }else if(x.val < 0.0 && abs(y.val) <= 1E-6)\n    {\n        return constH3(pi);\n    }\n    // return 0 for undefined\n    return constH3(0.0); \n}\n//--------------------------------\nHNum3 a_atan2(in HNum3 y, in float x)\n{\n    return a_atan2(y,constH3(x));\n}\n//--------------------------------\nHNum3 a_atan2(in float y, in HNum3 x)\n{\n    return a_atan2(constH3(y),x);\n}\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in HNum3 b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in HNum3 b, in float t)\n{\n    return add(mult(a, 1.0 - t), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in float b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in float b, in float t)\n{\n    return add(mult(a, 1.0 - t), b*t);\n}\n\n//--------------------------------\nHNum3 a_mix(in float a, in HNum3 b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in float a, in HNum3 b, in float t)\n{\n    return add(a * (1.0 - t), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in float a, in float b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n\n//--------------------------------\n// Implementation prototypes\n//--------------------------------\n\nmat3 a_outerProduct(in vec3 a, in vec3 b)\n{\n    return mat3(a * b[0], a * b[1], a * b[2]);\n}\n\n\n#endif // HESSNUM_3_H_",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}