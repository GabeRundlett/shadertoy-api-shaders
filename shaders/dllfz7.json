{
    "Shader": {
        "info": {
            "date": "1692814897",
            "description": "Windows 10 inspired wallpaper for Nixos",
            "flags": 0,
            "hasliked": 0,
            "id": "dllfz7",
            "likes": 11,
            "name": "NixOS 10",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 1,
            "username": "El_Sargo",
            "viewed": 517
        },
        "renderpass": [
            {
                "code": "const mat2 r = mat2(cos(-0.7),-sin(-0.7),sin(-0.7),cos(-0.7));\nconst vec2 ta = vec2(0.,-20.)*r;\nconst vec3 tar = vec3(ta.x,0.,ta.y);\nconst vec3 ro = vec3(-1.7, 0., 4.5);\nconst vec2 rop = ro.xz * r;\nconst vec3 ror = vec3(rop.x,ro.y,rop.y);\n\n\nfloat sdNix(vec3 p){\n    p.xy += vec2(0.25,0.47);\n    vec2[] verts = vec2[](\n        vec2(11.,0.0 * 0.75*4.472135956) * 0.053,\n        vec2(7.0,0.0 * 0.75*4.472135956) * 0.053,\n        vec2(5.0,1.0 * 0.75*4.472135956) * 0.053,\n        vec2(3.0,0.0 * 0.75*4.472135956) * 0.053,\n        vec2(1.0,0.0 * 0.75*4.472135956) * 0.053,\n        vec2(0.0,0.5 * 0.75*4.472135956) * 0.053,\n        vec2(3.0,2.0 * 0.75*4.472135956) * 0.053,\n        vec2(1.0,3.0 * 0.75*4.472135956) * 0.053,\n        vec2(3.0,4.0 * 0.75*4.472135956) * 0.053\n    );\n\n    ivec3[] tris = ivec3[](\n        ivec3( 0, 1, 6),\n        ivec3( 0, 6, 8),\n        ivec3( 6, 7, 8),\n        ivec3( 2, 6, 3),\n        ivec3( 3, 4, 5),\n        ivec3( 3, 5, 6)\n    );\n    \n    float d = sdTriangle(p.xy, \n        verts[tris[0].x],\n        verts[tris[0].y],    \n        verts[tris[0].z]    \n    );\n    if (d > 0.8) {\n        return d;\n    }\n    for (int i=1;i<tris.length();i++) {\n        d = min(d,sdTriangle(p.xy, \n            verts[tris[i].x],\n            verts[tris[i].y],    \n            verts[tris[i].z]    \n        ));\n        \n    }\n\n    d = opExtrusion(p,d,.1);\n    return d-0.04;\n}\n\n\nfloat sdFlake(vec3 p){\n    float d = 10e10;\n\n    for (float r = 0.0;r<2.0;r += 1.0 / 3.0){\n        vec2 z = p.xy * rot(-pi*r) - vec2(-0.3,-0.4);\n        d = min(d,sdNix(vec3(z.x,z.y,p.z)));\n    }\n    return d;\n}\n\nfloat map(vec3 p){\n    \n    p.xz *= r;\n    vec3 rt = normalize(tar-p);\n    vec3 ps = p + p.z * rt * 0.15;\n      \n    float d = 10e10;\n    if (p.z > -0.) {\n        d = sdFlake(vec3(ps.xy,0.));    \n    }\n    float b = 0.;\n   \n    if (d < 0.) {\n        float m = p.z;\n        b = exp(-0.7-m*0.1)*0.1;\n    }\n\n    return b*(0.7+fbmd(p*5.).x-p.y*0.5);\n}\n\nvoid mainImage( out vec4 fragColor , in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 nuv = (uv-0.5)*vec2(1.,iResolution.y/iResolution.x);\n    vec3 rd = normalize(vec3(nuv, -0.7));    \n\n    vec3 col = vec3(0.);\n    float g = 0.0;\n    float dt = 0.03;\n    uvec2 xh = uvec2(uint(fragCoord.x),uint(fragCoord.y));\n    for (float T = hash12(xh)*dt; T < 6.; T += dt ){\n        vec3 p = ro+rd*T;\n        float d = map(p);\n        col += dt*100.0*d*vec3(0.01,0.5,1.0)*exp(-g*0.1);\n        if (d > 0.) {\n            g += dt;\n        }\n    }\n    col = mix(col,vec3(0.016,0.184,0.290)*(0.9+0.1*fbmd(vec3(nuv*20.,0.)).x),exp(-g*0.1));\n    vec2 rc = rd.xy * r;\n    vec3 rdr = vec3(rc.x,rd.y,rc.y);\n    vec3 s = ro + rd * (ror.z);\n    float d = sdFlake(vec3(s.x+0.0,s.y,0.)*1.3);\n    col +=  vec3(.2,1.,3.4)*smoothstep(0.01,0.0,abs(d));\n    col +=  vec3(.02,0.5,1.4)*(-1.02+nuv.x*6.0)*smoothstep(0.01,0.0,d);\n\n    col *= smoothstep(.9,0.,length(uv-0.5));\n    fragColor =  vec4(aces_tonemap(col),1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UIF (1.0 / float(0xffffffffU))\nfloat hash12(uvec2 q) {\n\tq *= UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nconst float pi = 3.14159265359;\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ) {\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nfloat opExtrusion( in vec3 p, in float sdf, in float h ) {\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n\nfloat hash(vec2 p){\n\treturn fract(3.12312*dot(p,p*01.123));\n}\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\nfloat hash13(uvec3 q)\n{\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\n\n\nfloat smix(float a,float b,float t){\n\treturn mix( a, b, smoothstep(0.,1.,t) ) ;\n}\n\nfloat n(vec2 p){\n\tvec2 f = floor(p);\n\tvec2 t = fract(p);\n\tvec2 tr = f + vec2(1.,1.);\n\tvec2 tl = f + vec2(0.,1.);\n\tvec2 br = f + vec2(1.,0.);\n\tvec2 bl = f;\n\tfloat htr = hash(tr);\n\tfloat htl = hash(tl);\n\tfloat hbr = hash(br);\n\tfloat hbl = hash(bl);\n\tfloat mt = smix(htl,htr,t.x);\n\tfloat mb = smix(hbl,hbr,t.x);\n\treturn smix(mb,mt,t.y);\n\t\n}\n\nvec4 nd( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float a = hash( p+vec3(0,0,0) );\n    float b = hash( p+vec3(1,0,0) );\n    float c = hash( p+vec3(0,1,0) );\n    float d = hash( p+vec3(1,1,0) );\n    float e = hash( p+vec3(0,0,1) );\n    float f = hash( p+vec3(1,0,1) );\n    float g = hash( p+vec3(0,1,1) );\n    float h = hash( p+vec3(1,1,1) );\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z),\n                 2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                 k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                 k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\n\nvec4 fbmd( in vec3 x )\n{\n\n    float f = 1.78;  // could be 2.0\n    float s = 0.54;  // could be 0.5\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n    0.0,1.0,0.0,\n    0.0,0.0,1.0);\n    for( int i=0; i < 9; i++ )\n    {\n\t    \n        vec4 n = nd(x);\n        a += b*n.x;          // accumulate values\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        x = f*m*x;\n\tx.xy *= rot(1.23123);\n\tx.zy *= rot(-2.23123);\n        //m = f*m*mat3(1.,-1.,1.,-1,1.,-1.,1.,-1.,1.);\n    }\n    return vec4( a, d );\n}\n\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}