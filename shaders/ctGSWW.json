{
    "Shader": {
        "info": {
            "date": "1686081514",
            "description": "asdfasdf",
            "flags": 0,
            "hasliked": 0,
            "id": "ctGSWW",
            "likes": 2,
            "name": "aaaaaghhhh",
            "published": 3,
            "tags": [
                "aggghhh"
            ],
            "usePreview": 0,
            "username": "zimbolt",
            "viewed": 156
        },
        "renderpass": [
            {
                "code": "//\n// PUBLIC DOMAIN CRT STYLED SCAN-LINE SHADER\n//\n//\t by Timothy Lottes\n//\n// This is more along the style of a really good CGA arcade monitor.\n// With RGB inputs instead of NTSC.\n// The shadow mask example has the mask rotated 90 degrees for less chromatic aberration.\n//\n// Left it unoptimized to show the theory behind the algorithm.\n//\n// It is an example what I personally would want as a display option for pixel art games.\n// Please take and use, change, or whatever.\n//\n\n#define RGBA(r, g, b, a)\tvec4(float(r)/255.0, float(g)/255.0, float(b)/255.0, float(a)/255.0)\n\nconst vec3 kBackgroundColor = RGBA(0x00, 0x60, 0xb8, 0xff).rgb; // medium-blue sky\n//const vec3 kBackgroundColor = RGBA(0xff, 0x00, 0xff, 0xff).rgb; // test magenta\n\n// Emulated input resolution.\n#if 1\n\t// Fix resolution to set amount.\n\t// Note: 256x224 is the most common resolution of the SNES, and that of Super Mario World.\n\tvec2 res = vec2(\n\t\t1280.0 / 1.0,\n\t\t720.0 / 1.0\n\t);\n#else\n\t// Optimize for resize.\n\tvec2 res = iResolution.xy / 6.0;\n#endif\n\n// Hardness of scanline.\n//\t-8.0 = soft\n// -16.0 = medium\nfloat sHardScan = -16.0;\n\n// Hardness of pixels in scanline.\n// -2.0 = soft\n// -4.0 = hard\nconst float kHardPix = -4.0;\n\n// Display warp.\n// 0.0 = none\n// 1.0 / 8.0 = extreme\nconst vec2 kWarp = vec2(0.2 / 32.0, 0.2 / 24.0);\n//const vec2 kWarp = vec2(0);\n\n// Amount of shadow mask.\nfloat kMaskDark = 1.0;\nfloat kMaskLight = 3.0;\n\n//------------------------------------------------------------------------\n\n// sRGB to Linear.\n// Assuing using sRGB typed textures this should not be needed.\nfloat toLinear1(float c) {\n\treturn (c <= 0.04045) ?\n\t\t(c / 12.92) :\n\t\tpow((c + 0.055) / 1.055, 2.4);\n}\nvec3 toLinear(vec3 c) {\n\treturn vec3(toLinear1(c.r), toLinear1(c.g), toLinear1(c.b));\n}\n\n// Linear to sRGB.\n// Assuing using sRGB typed textures this should not be needed.\nfloat toSrgb1(float c) {\n\treturn(c < 0.0031308 ?\n\t\t(c * 12.92) :\n\t\t(1.055 * pow(c, 0.41666) - 0.055));\n}\nvec3 toSrgb(vec3 c) {\n\treturn vec3(toSrgb1(c.r), toSrgb1(c.g), toSrgb1(c.b));\n}\n\n// Nearest emulated sample given floating point position and texel offset.\n// Also zero's off screen.\nvec4 fetch(vec2 pos, vec2 off)\n{\n\tpos = floor(pos * res + off) / res;\n\tif (max(abs(pos.x - 0.5), abs(pos.y - 0.5)) > 0.5)\n\t\treturn vec4(vec3(0.0), 0.0);\n   \t\n    vec4 sampledColor = texture(iChannel0, pos.xy, -16.0);\n    \n    sampledColor = vec4(\n        (sampledColor.rgb * sampledColor.a) +\n        \t(kBackgroundColor * (1.0 - sampledColor.a)),\n        1.0\n    );\n    \n\treturn vec4(\n        toLinear(sampledColor.rgb),\n        sampledColor.a\n    );\n}\n\n// Distance in emulated pixels to nearest texel.\nvec2 dist(vec2 pos) {\n\tpos = pos * res;\n\treturn -((pos - floor(pos)) - vec2(0.5));\n}\n\n// 1D Gaussian.\nfloat gaus(float pos, float scale) {\n\treturn exp2(scale * pos * pos);\n}\n\n// 3-tap Gaussian filter along horz line.\nvec3 horz3(vec2 pos, float off)\n{\n\tvec3 b = fetch(pos, vec2(-1.0, off)).rgb;\n\tvec3 c = fetch(pos, vec2( 0.0, off)).rgb;\n\tvec3 d = fetch(pos, vec2(+1.0, off)).rgb;\n\tfloat dst = dist(pos).x;\n\t// Convert distance to weight.\n\tfloat scale = kHardPix;\n\tfloat wb = gaus(dst - 1.0, scale);\n\tfloat wc = gaus(dst + 0.0, scale);\n\tfloat wd = gaus(dst + 1.0, scale);\n\t// Return filtered sample.\n\treturn (b * wb + c * wc + d * wd) / (wb + wc + wd);\n}\n\n// 5-tap Gaussian filter along horz line.\nvec3 horz5(vec2 pos, float off)\n{\n\tvec3 a = fetch(pos, vec2(-2.0, off)).rgb;\n\tvec3 b = fetch(pos, vec2(-1.0, off)).rgb;\n\tvec3 c = fetch(pos, vec2( 0.0, off)).rgb;\n\tvec3 d = fetch(pos, vec2(+1.0, off)).rgb;\n\tvec3 e = fetch(pos, vec2(+2.0, off)).rgb;\n\tfloat dst = dist(pos).x;\n\t// Convert distance to weight.\n\tfloat scale = kHardPix;\n\tfloat wa = gaus(dst - 2.0, scale);\n\tfloat wb = gaus(dst - 1.0, scale);\n\tfloat wc = gaus(dst + 0.0, scale);\n\tfloat wd = gaus(dst + 1.0, scale);\n\tfloat we = gaus(dst + 2.0, scale);\n\t// Return filtered sample.\n\treturn (a * wa + b * wb + c * wc + d * wd + e * we) / (wa + wb + wc + wd + we);\n}\n\n// Return scanline weight.\nfloat scan(vec2 pos, float off) {\n\tfloat dst = dist(pos).y;\n\treturn gaus(dst + off, sHardScan);\n}\n\n// Allow nearest three lines to effect pixel.\nvec3 tri(vec2 pos)\n{\n\tvec3 a = horz3(pos, -1.0);\n\tvec3 b = horz5(pos,  0.0);\n\tvec3 c = horz3(pos, +1.0);\n\tfloat wa = scan(pos, -1.0);\n\tfloat wb = scan(pos,  0.0);\n\tfloat wc = scan(pos, +1.0);\n\treturn a * wa + b * wb + c * wc;}\n\n// Distortion of scanlines, and end of screen alpha.\nvec2 warp(vec2 pos)\n{\n\tpos = pos * 2.0 - 1.0;\n\tpos *= vec2(\n\t\t1.0 + (pos.y * pos.y) * kWarp.x,\n\t\t1.0 + (pos.x * pos.x) * kWarp.y\n\t);\n\treturn pos * 0.5 + 0.5;\n}\n\n// Shadow mask.\nvec3 mask(vec2 pos)\n{\n\tpos.x += pos.y * 3.0;\n\tvec3 mask = vec3(kMaskDark, kMaskDark, kMaskDark);\n\tpos.x = fract(pos.x / 6.0);\n\tif (pos.x < 0.333)\n\t\tmask.r = kMaskLight;\n\telse if (pos.x < 0.666)\n\t\tmask.g = kMaskLight;\n\telse\n\t\tmask.b = kMaskLight;\n\treturn mask;\n}\n\n// Draw dividing bars.\nfloat bar(float pos, float bar) {\n\tpos -= bar;\n\treturn (pos * pos < 4.0) ? 0.0 : 1.0;\n}\n\nfloat rand(vec2 co) {\n\treturn fract(sin(dot(co.xy , vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Entry.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pos = warp(fragCoord.xy / iResolution.xy);\n    vec4 unmodifiedColor = fetch(pos, vec2(0));\n    \n\t// Unmodified.\n\tif (fragCoord.x < iResolution.x * 4.333)\n\t{\n\t\tfragColor.rgb = tri(pos) * mask(fragCoord.xy);\n\t}\n\telse\n\t{\n\t\tif (fragCoord.x < iResolution.x * 0.666) {\n\t\t\tsHardScan = -12.0;\n\t\t\tkMaskDark = kMaskLight = 1.0;\n\t\t}\n\t\tfragColor.rgb = tri(pos) * mask(fragCoord.xy);\n\t}\n\t//fragColor.rgb *=\n\t//\tbar(fragCoord.x, iResolution.x * 0.333) *\n\t//\tbar(fragCoord.x, iResolution.x * 0.666);\n\tfragColor = vec4(\n        toSrgb(fragColor.rgb),\n        1.0\n    );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}