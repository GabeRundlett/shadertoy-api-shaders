{
    "Shader": {
        "info": {
            "date": "1723883678",
            "description": "originals  https://glslsandbox.com/e#65963.0",
            "flags": 0,
            "hasliked": 0,
            "id": "McXfD7",
            "likes": 1,
            "name": "cosmic ying yang",
            "published": 3,
            "tags": [
                "cosmos",
                "yingyang"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 76
        },
        "renderpass": [
            {
                "code": "\n\n#define iterations 11\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n#define time iTime*0.5\n#define resolution iResolution.xy\n\nfloat random (in vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  float a = random(i);\n  float b = random(i + vec2(1., 0.));\n  float c = random(i + vec2(0., 1.));\n  float d = random(i + vec2(1., 1.));\n\n  vec2 u = f * f * (3. - 2. * f);\n\n  return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n#define octaves 10\n\nfloat fbm (in vec2 p) {\n  float value = 0.;\n  float freq = 0.6;\n  float amp = .5;\n\n  for (int i = 0; i < octaves; i++) {\n    value += amp * (noise((p - vec2(1.)) * freq));\n    freq *= 1.9;\n    amp *= .6;\n  }\n\n  return value;\n}\n\nfloat pattern(in vec2 p) {\n  vec2 offset = vec2(-.5);\n\n  vec2 aPos = vec2(sin(time * .05), sin(time * .0)) * 6.;\n  vec2 aScale = vec2(3.);\n  float a = fbm(p * aScale + aPos);\n\n  vec2 bPos = vec2(sin(time * .1), sin(time * .0)) * 1.;\n  vec2 bScale = vec2(.5);\n  float b = fbm((p + a) * bScale + bPos);\n\n  vec2 cPos = vec2(-.6, -.5) + vec2(sin(-time * .01), sin(time * .0)) * 2.;\n  vec2 cScale = vec2(2.);\n  float c = fbm((p + b) * cScale + cPos);\n\n  return c;\n}\n\nvec3 palette(in float t) {\n  vec3 a = vec3(.5, .5, 1.5);\n  vec3 b = vec3(.45, .25, .14);\n  vec3 c = vec3(1. ,1., 1.);\n  vec3 d = vec3(10., 0.1, 1.2);\n\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\n    vec3 dir=vec3(uv*zoom,1.);\n\t vec2 p2 = gl_FragCoord.xy / resolution.xy;\n  p2.x *= resolution.x / resolution.y;\nfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n   \n  float value = pow(pattern(p2), 2.);\n  vec3 color  = palette(value);\n\n\n\nvec2 u = 10.0 * (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y) ;\n   u.xy*=mat2(cos(iTime*1.025),sin(iTime*1.025),-sin(iTime*1.025),cos(iTime*1.025));\n  \n float speed3 = 3.5;\n float speed2 = 2.5;\n \n vec2 cPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    // distance of current pixel from center\n\tfloat cLength = length(cPos);\n\n\t\n vec2 o = vec2(sin(length(u) - time* speed3),  cos( length(u) - time * speed3));\n vec2 ux = u + vec2(1.4, 4.6);\n o +=(cPos/cLength)*cos(cLength*12.0-iTime*4.0) * 0.03;\n  ux *=(cPos/cLength)*cos(cLength*12.0-iTime*4.0) * 0.03;\n vec2 d = vec2(sin(length(ux) - time * speed3), cos( length(ux) - time * speed3));\n  d +=(cPos/cLength)*cos(cLength*12.0-iTime*4.0) * 0.03;\n d*=ma;\n vec2 uy = u + vec2(-1.5, -1.8);\n vec2 l = vec2(sin(length(uy) - time / speed2), cos( length(uy) - time * speed2));\n vec2 uz = u + vec2(-2.0, 1.0 );\n vec2 r = vec2(sin(length(uz) - time / speed3), cos(length(uz) - time * speed3));\n vec2 ua = u + vec2(2.0, -1.0 );\n vec2 r2 = vec2(sin(length(ua) - time / speed3), cos(length(ua) - time * speed3));\n \n\n vec2 c = o / d / l * r - vec2(0.4, 0.8);\n  c *=(cPos/cLength)*cos(cLength*12.0-iTime*4.0) * 0.03;\n\n float cx = o.y * d.y * r.x /  + l.y / r.x * ua.y;\nvec4 fc2 = vec4( cx * 0.3, cx * 0.2 - 0.2, cx / 0.65, 1.0 );\n\tvec3 from=vec3(1.,.5,0.0);\n\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n    \n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n        \n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n       \n\t\t\tp=abs(p)/dot(p,p)-formuparam+fc2.xyz;\n             p.xy*=mat2(cos(iTime*0.025),sin(iTime*0.025),-sin(iTime*0.025),cos(iTime*0.025));\n           // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.3-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03+color*fc2.xyz,1.);\t\n\t\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}