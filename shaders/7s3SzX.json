{
    "Shader": {
        "info": {
            "date": "1633610777",
            "description": "Simplifying and testing;\nUsing the euclidean rhythms formula to generate some programmatic melodies.see: \nhttps://www.youtube.com/watch?v=vwigqSwYNaQ\nhttps://www.youtube.com/watch?v=vwigqSwYNaQ\nhttps://twitter.com/boggodan/status/1277738002270298112",
            "flags": 8,
            "hasliked": 0,
            "id": "7s3SzX",
            "likes": 7,
            "name": "Fork EuclideanRythm",
            "published": 3,
            "tags": [
                "sound",
                "music",
                "euclideanbeats",
                "generativemusic",
                "euclideanrythm"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 433
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n   ;vec3 col =vec3(0.7,0.34,0.49) //default\n   ;float on = iTime              //default\n\n   ;float steps=floor(iResolution.x/3.)//this may not be the way to ensure uniform line widths\n   ;float stp = floor(uv.x*steps);\n\n   ;if(uv.y<0.33            ){on+=16.33;col=vec3(.2,.5,.9)\n   ;}if(uv.y>0.66){on+=25.50;col=vec3(0.5,0.9,0.3)\n   ;}//if(uv.y<=0.66           ){          col=vec3(0.7,0.34,0.49);}\n   ;on = euclidean(stp, getWangSteps(on)*steps/16.,steps); //full overwrite changes meaning of [on]\n\n    float playhead = mod(iTime*tempo_mult,steps)/steps;\n    float muchness = 1.0 - clamp((playhead*steps-stp),0.0,1.0);\n    \n    if(playhead*16.0>stp)\n        col = mix(col,vec3(1.0),muchness);\n        \n    fragColor = vec4(col,1.0)*on;\n    \n    if(abs(uv.x - playhead)<0.001)\n       fragColor += vec4(1.0);\n    \n    fragColor += vec4(0.1,0.11,0.09,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float ftom(float note)\n{\n    return 440.0 * pow(2.0,((note-12.0)/12.0));\n}\n\n//lol, there has to be a nice shadery solution\nfloat mapPenta(int note)\n{\n//return  floor(float(note-1))*5./12.)*12.; //or something like that, seems less efficient.\n    switch(note)\n    {\n        case 0: return 0.0;\n        case 1: return 2.0;\n        case 2: return 5.0;\n        case 3: return 7.0;\n        case 4: return 10.0;\n        case 5: return 12.0;\n        default: return 0.0;\n    }\n}\n\nvec2 boop(float time, float freq, float ph)\n{\n    return vec2( sin(6.2831*freq*mod(time,16.0))*exp(-3.0*ph) );\n}\n\nfloat getEuclideanSine(float time, float beats, float steps)\n{\n    float stp = floor(mod((time*tempo_mult),steps));\n    float on = euclidean(stp,beats,steps);\n    \n    float freq = ftom(mapPenta(int(beats)%6));\n    float octave = mod(getWangSteps(beats)-1.0,3.0); //haxor\n    octave = pow(2.0,octave);\n    return on*float(boop(time, freq*octave, mod(time*tempo_mult,1.0f)))*0.15;\n}\n\nfloat getSines(float time)\n{\n    return \n    getEuclideanSine(time, getWangSteps(time),16.0f) +\n    getEuclideanSine(time, getWangSteps(time+25.5),16.0f) +\n    getEuclideanSine(time, getWangSteps(time+16.33),16.0f);\n}\n\nconst int DELAY_TAPS = 4;\n\n//sound + sound from a while ago x DELAY_TAPS\nvec2 getWithFX(float time)\n{\n    vec2 outp = vec2(0.0);\n    for(int i =0; i<DELAY_TAPS; i++)\n    {\n        //stereo delay by simulating entire output back DELAY_TAPS times lol\n        outp += \n        vec2(getSines(time - 2.5f * float(i))/float(i*3+1),\n        getSines(time - 3.0f * float(i))/float(i*3+1));\n    }\n    \n    return outp;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    return getWithFX(time);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "const float tempo_mult = 5.0;\n\n//euclidean beats formula, from\n//https://twitter.com/mmalex/status/1177617079119286272\n\n#define unequal(a,b,c)   mix(a,b,step(floor(u*l/r),0.)+step(0.,c)-1.)//(c!=0)?a:b\n  \nfloat euclidean(float u, float l, float r){//uv,lines/intervalRes\n  //;float c=floor(u*l/r)-floor((u-1.)*l/r) ;//return unequal(c,0.,1.) //fails terribly.\n //;if (c!=1.) return .25;return .5;//matte test 1 to prove thew precision of the below\n //;if (c!=0.) return .5;return .25;//matte test 2 to prove thew precision of the below\n //\n ;return     floor(u*l/r)-floor((u-1.)*l/r) //surprisingly, this is precise and sufficient!\n //;if (floor(u*l/r)-floor((u-1.)*l/r)!=0.) return 1.; return 0.;//identical\n //;if (floor(u*l/r)!=floor((u-1.)*l/r)   ) return 1.; return 0.;//identical\n //;return floor(u*l/r)!=floor((u-1.)*l/r)?1.0:0.0               //source\n ;}\n\nfloat wang(uint u)\n{\n    uint seed = (u*1664525u);\n    \n    seed  = (seed ^ 61u) ^(seed >> 16u);\n    seed *= 9u;\n    seed  = seed ^(seed >> 4u);\n    seed *= uint(0x27d4eb2d);\n    seed  = seed ^(seed >> 15u);\n    \n    float value = float(seed) / (4294967296.0);\n    return mod(value,1.0);\n}\n\nfloat getWangSteps(float iTime)\n{\n    return floor(wang(uint(iTime*0.25))*10.0)+2.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}