{
    "Shader": {
        "info": {
            "date": "1710048225",
            "description": "A Hyperboloid subtracted from a Sphere, as first proposed by Erich Loftis here: [url]https://twitter.com/ErichLoftis/status/1766120974263394390[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "lXsXD2",
            "likes": 35,
            "name": "SphereHyperboloid - intersection",
            "published": 3,
            "tags": [
                "3d",
                "sphere",
                "hyperboloid",
                "intersction"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 822
        },
        "renderpass": [
            {
                "code": "\n// A Hyperboloid subtracted from a Sphere, as first proposed by\n// Erich Loftis here https://twitter.com/ErichLoftis/status/1766120974263394390\n//\n// I have added independent controls for (extenral) radius, hole and height.\n//\n// Implementation mostly from https://www.shadertoy.com/view/fddBD2\n\n\n\n// returns t=-1 if no intersection\n\n#if 1\n\nfloat iSphereHyperboloid(\n              in vec3 ro, in vec3 rd,\n              in float ra, // radius\n              in float ho, // hole\n              in float he, // height\n              out vec3 oNor, out float oSur )\n{\n    vec3 roro = ro*ro;\n    vec3 rord = ro*rd;\n    vec3 rdrd = rd*rd;\n\n\tfloat t = 1e20;\n    \n\t// Sphere\n\tfloat bs = rord.x + rord.y + rord.z;\n\tfloat cs = roro.x + roro.y + roro.z - ra*ra;\n\tfloat hs = bs*bs - cs;\n    if( hs<0.0 ) return -1.0;     // early exit (sphere is bounding volume)\n    float ts = -bs - sqrt(hs);\n\tif( ts>0.0 )\n\t{\n\t\tvec3 pos = ro + rd * ts;\n\t\tif( abs(pos.y)<he )\n\t\t{\n            t = ts;\n\t\t\toNor = pos/ra;\n            oSur = 1.0;\n\t\t}\t\t\n\t}\n\n    \n\t// Hyperboloid\n    float kh = (ra*ra-ho)/(he*he) - 1.0; // can avoid division by propagating he*he forwards to (ah,bh,ch)\n\tfloat ah = rdrd.x - kh*rdrd.y + rdrd.z;\n\tfloat bh = rord.x - kh*rord.y + rord.z;\n\tfloat ch = roro.x - kh*roro.y + roro.z - ho;\n   \n\tfloat hh = bh*bh - ah*ch;\n    if( hh>0.0 )\n    {\n        float th = (-bh + sqrt(hh))/ah;\n        if( th>0.0 && th<t )\n        {\t\n            vec3 pos = ro + rd * th;\n            if( abs(pos.y) < he )\n            {\n                t = th;\n                oNor = -normalize(pos*vec3(1.0,-kh*kh,1.0));\n                oSur = -1.0;\n            }\t\n        }\n    }\n\n    return (t>1e19) ? -1.0 : t;\n}\n\n\n#else\n/*\nfloat iSphereHyperboloid(\n              in vec3 ro, in vec3 rd,\n              in float ra, // radius\n              in float ho, // hole\n              in float he, // height\n              out vec3 oNor, out float oSur )\n{\n\t// Sphere\n\tfloat as = 1.0;\n\tfloat bs = dot(rd, ro);\n\tfloat cs = dot(ro, ro) - ra*ra;\n\tfloat hs2 = bs*bs - cs;\n    \n    if( hs2<0.0 ) return -1.0;     // early exit\n    \n\tfloat hs = sqrt(hs2);\n    vec2 ts = -bs + vec2(-hs,hs);\n\tfloat t = 1e20;\n    \n\tif( ts.x>0.0 )\n\t{\n\t\tvec3 pos = ro + rd * ts.x;\n\t\tif( abs(pos.y) < he )\n\t\t{\n            t = ts.x;\n\t\t\toNor = pos/ra;\n            oSur = 1.0;\n\t\t}\t\t\n\t}\n\tif( ts.y>0.0 && ts.y<t )\n\t{\t\n\t\tvec3 pos = ro + rd * ts.y;\n\t\tif( abs(pos.y) < he )\n\t\t{\n            t = ts.y;\n\t\t\toNor = pos/ra;\n            oSur = 1.0;\n\t\t}\t\n\t}\n\n    \n\t// Hyperboloid\n    float kh = (ra*ra-ho)/(he*he) - 1.0;\n\tfloat ah = rd.x*rd.x - kh*rd.y*rd.y + rd.z*rd.z;\n\tfloat bh = rd.x*ro.x - kh*rd.y*ro.y + rd.z*ro.z;\n\tfloat ch = ro.x*ro.x - kh*ro.y*ro.y + ro.z*ro.z - ho;\n   \n\tfloat hh2 = bh*bh - ah*ch;\n    if( hh2>0.0 )\n    {\n        float hh = sqrt(hh2);\n        vec2 th = vec2(-bh - hh,-bh + hh)/ah;\n        if( th.x>0.0 && th.x<t )\n        {\n            vec3 pos = ro + rd * th.x;\n            if( abs(pos.y) < he )\n            {\n                t = th.x;\n                oNor = -normalize(pos*vec3(1.0,-k*k,1.0));\n                oSur = -1.0;\n            }\t\t\n        }\n        if( th.y>0.0 && th.y<t )\n        {\t\n            vec3 pos = ro + rd * th.y;\n            if( abs(pos.y) < he )\n            {\n                t = th.y;\n                oNor = -normalize(pos*vec3(1.0,-kh*kh,1.0));\n                oSur = -1.0;\n            }\t\n        }\n    }\n\n    return (t>1e19) ? -1.0 : t;\n}\n*/\n#endif\n\n//--------------------------------------------------------\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n    float an1 = 0.3 + 0.3*sin(6.283185*iTime/30.0);\n\tfloat an2 = 6.283185*iTime/30.0;\n\tvec3 ro = 8.0*vec3( cos(an1)*sin(an2), sin(an1), cos(an1)*cos(an2) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    float ra = 2.0;// + 0.5*sin(iTime*1.3+0.0);\n    float ho = 0.6 + 0.4*sin(iTime*2.0+1.0);\n    float he = 0.7 + 0.3*sin(iTime*1.1+2.0);\n   \n    // render\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*q-res)/res.y;\n        #endif\n\n\t    // create view ray\n\t    vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n\n        // background\n\t    vec3 col = vec3(0.08) * (1.0-0.3*length(p));\n        //col += 0.1*cos( float(5*id.y+id.x)+vec3(0,2,4));\n \n        // raytrace\n        vec3 nor;\n        float sur;\n        float t = iSphereHyperboloid( ro, rd, ra, ho, he, nor, sur );\n        if( t>0.0 )\n        {\n            vec3 pos = ro + t*rd;\n\n            // material\n            float le = length(pos.xz);\n            vec2 uv = vec2(atan(pos.z,pos.x), ((sur<0.0)?(le+pos.y)*0.4:atan(pos.y,le)));\n            vec3 mate = 0.5 + 0.5*nor;\n            mate = mix(mate,vec3(0.0),smoothstep(-0.01,0.01,cos(uv.x*20.0)*cos(uv.y*20.0)));\n            \n            // lighting (ambient)\n            float amb = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );\n            col = mate* vec3(0.1,0.2,0.3)*amb;\n            // lighting (key)\n            vec3 lig = normalize(vec3(0.7,0.5,0.4));\n            vec3 hal = normalize(-rd+lig);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            if( dif>0.0001 )\n            {\n                vec3 kknor; float kksur;\n                if( iSphereHyperboloid( pos+0.01*nor, lig, ra, ho, he, kknor, kksur )>0.001 ) dif *= 0.0;\n            }\n            col += vec3(1.0,0.9,0.7)*dif*( mate + 1.0*pow(clamp(dot(hal,nor),0.0,1.0),32.0));\n       }\n \t\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n     \n    // tonemap\n    tot *= 3.5/(3.0+tot);\n    \n    // gamma\n    tot = pow( tot, vec3(0.4545) );\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n    \n\tfragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}