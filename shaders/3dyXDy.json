{
    "Shader": {
        "info": {
            "date": "1574843608",
            "description": "memory variant  (mouseY)\n\nIf no scrambling matrix is used between scales (i.e. original Perlin noise), the noise is exactly 0 on grid vertex.\nThis can be used to stochastically interpolate a mesh or polyline, still passing through control points",
            "flags": 32,
            "hasliked": 0,
            "id": "3dyXDy",
            "likes": 18,
            "name": "Perlin noise vs interpolation 4",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "noise",
                "perlin",
                "gradient",
                "lightning",
                "flownoise"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 866
        },
        "renderpass": [
            {
                "code": "// memory variant of https://shadertoy.com/view/WsGXDy\n// flownoise variant of https://shadertoy.com/view/WdGXWG\n// curve variant of 2D https://shadertoy.com/view/wdKXzd\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = texelFetch(iChannel0, ivec2(u), 0);\n/*\n    vec2 R = iResolution.xy,\n         U = ( u -.5*R ) / R.y * 2. + offset,\n         M = texelFetch(iChannel0, ivec2(0), 0).ba; // mouse\n    float pix = 3./R.y;\n\n#define S(v) smoothstep( pix, 0., v )\n    O = mix(O, vec4(0,1,0,1), S(length(U)-.03) );   // vertices\n    O = mix(O, vec4(1,0,0,1), S(length(U-vec2(1,M.y))-.03) ); \n    O = mix(O, vec4(0,0,1,1), S(length(U+vec2(1,M.y))-.03) );\n*/\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// gradient noise derived from https://www.shadertoy.com/view/XdXGW8\n\nfloat _z;\nvec2 hash( vec2 x ) \n{\n // float s = 0.;                      // standard Perlin noise\n    float s = mod(x.x+x.y,2.)*2.-1.;   // flow noise checkered rotation direction\n // float s = 5.;                      // flow noise universal rotation direction\n // s *= iTime;                        // same rotation speed at all scales\n    s *= iTime/ _z;                    // rotation speed increase with small scale\n    const vec2 k = vec2( .3183099, .3678794 );\n    x = x*k + k.yx;\n    return ( -1. + 2.*fract( 16. * k*fract( x.x*x.y*(x.x+x.y)) ) ) \n        *  mat2(cos( s + vec4(0,33,11,0))); // rotating gradients. rot: https://www.shadertoy.com/view/XlsyWX\n}\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor( p ),\n         f = fract( p ),\n\t     u = f*f*(3.-2.*f);\n\n#define P(x,y) dot( hash( i + vec2(x,y) ), f - vec2(x,y) )\n    return mix( mix( P(0,0), P(1,0), u.x),\n                mix( P(0,1), P(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 p )  //fractal noise\n{\t\n    mat2 m = mat2(2.); // mat2( 1.6,  1.2, -1.2,  1.6 );\n    float v  = 0.,s = 1.;\n    for( int i=0; i < 7; i++, s /= 2. ) { _z = s; // for flownoise\n        v += s*noise( p ); p *= m;\n    }\n    return v;\n}\n\n#define S(v) smoothstep( pix, 0., v )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u -.5*R ) / R.y * 2. + offset,\n         M =  length(iMouse.xy) > 10. \n          ? ( iMouse.xy -.5*R ) / R.y * 2. + offset\n          : vec2(.2*sin(iTime));\n \n    float pix = 3./R.y,\n          y = perlin(vec2(U.x,0)) + U.x*M.y;\n    \n    O = texelFetch(iChannel0, ivec2(u)-ivec2(-1,1), 0) * .98*vec4(1,.99,.98,0)  // coloring fading memory\n        + S(abs(y - U.y));\n\n    O = mix(O, vec4(0,1,0,1), S(length(U)-.03) );   // vertices\n    O = mix(O, vec4(1,0,0,1), S(length(U-vec2(1,M.y))-.03) ); \n    O = mix(O, vec4(0,0,1,1), S(length(U+vec2(1,M.y))-.03) );\n    \n    if ( u == vec2(.5) ) O.ba = M;                  // save mouse\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define offset vec2(0,.5)",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}