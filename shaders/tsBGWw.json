{
    "Shader": {
        "info": {
            "date": "1566874616",
            "description": "Playing around with the mandelbox fractal",
            "flags": 0,
            "hasliked": 0,
            "id": "tsBGWw",
            "likes": 10,
            "name": "Dark MandelBox",
            "published": 3,
            "tags": [
                "fractal",
                "mandelbox"
            ],
            "usePreview": 0,
            "username": "thiagoborn",
            "viewed": 1626
        },
        "renderpass": [
            {
                "code": "\n#define ITERS 6\n\nfloat SCALE=0.0;\nfloat MR2=0.0;\n\nfloat mandelbox(vec3 position){\n  vec4 scalevec = vec4(SCALE, SCALE, SCALE, abs(SCALE)) / MR2;\n  float C1 = abs(SCALE-1.0), C2 = pow(abs(SCALE), float(1-ITERS));\n  vec4 p = vec4(position.xyz, 1.0), p0 = vec4(position.xyz, 1.0);  // p.w is knighty's DEfactor\n  for (int i=0; i<ITERS; i++) {\n    p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;  // box fold: min3, max3, mad3\n    float r2 = dot(p.xyz, p.xyz);  // dp3\n    p.xyzw *= clamp(max(MR2/r2, MR2), 0.0, 1.0);  // sphere fold: div1, max1.sat, mul4\n    p.xyzw = p*scalevec + p0;  // mad4\n  }\n  return (length(p.xyz) - C1) / p.w - C2;\n}\n\nfloat color(vec3 p){\n    vec3 op = p;\n    for (int i=0; i<ITERS; i++) {\n        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;  // box fold: min3, max3, mad3\n        float r2 = dot(p.xyz, p.xyz);  // dp3\n        p.xyz *= clamp(max(MR2/r2, MR2), 0.0, 1.0);  // sphere fold: div1, max1.sat, mul4\n        p.xyz = p*SCALE/MR2 + op;  // mad4\n    }\n  \treturn length(p);\n}\n\nfloat trace(vec3 o,vec3 d){\n    float v=0.0;\n    for(int i=0;i<74;i++){\n        vec3 p=o+d*v;\n        float mv=mandelbox(p);        \n        if(mv<0.01){\n            return v;\n        }\n        v+=mv *.9;\n    }\n    return 0.;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 6.0;\n   //SCALE = 2.5 + iMouse.x * 2.0;\n   // MR2 = iMouse.x * iMouse.x;\n    //SCALE = 2.9 + sin(iTime*10.0)*.0;\n    SCALE = 2.5;\n    float mr = 0.5;\n    MR2 = mr * mr;\n    \n      \n    vec3 lookingTo = vec3(0.,0.,0.);\n    float it = iTime / 5.;\n    vec3 viewer = vec3(\n        sin(iTime*.1) * 6.0,\n        cos(iTime*.17) * 5.0,\n        cos(iTime*.1) * 7.0\n    );\n    \n    vec3 forward = normalize(lookingTo-viewer);\n    vec3 rigth = cross(vec3(0.0,1.0,0.0),forward);\n    vec3 up = cross(forward,rigth);\n    \n    vec3 direction = normalize(forward * 5.0 + rigth * uv.x + up * uv.y);\n    \n    float dist = trace(viewer,direction);\n    vec3 col=vec3(0.0);\n     vec3 p = viewer + direction * dist;\n    \n    \n    if(dist!=0.) {\n        \n         float c = color(p);\n        \n   \t\t col = pal(c/50.0, \n                   vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20)\n                  //vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25)\n                   //vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25)\n                  );\n\n        //col = vec3(1.0);\n    };\n\n    \n   \n   \n    float fog = 1.0 / (1.0 + (dist));\n    fragColor.rgb = vec3(col * fog);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}