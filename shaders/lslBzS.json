{
    "Shader": {
        "info": {
            "date": "1497544679",
            "description": "Implementing the visualization of iq's [url=https://iquilezles.org/articles/functions/functions.htm]Useful Little Functions[/url], using Flyguy's [url=https://www.shadertoy.com/view/4tB3WV]Implicit Plotter[/url]",
            "flags": 16,
            "hasliked": 0,
            "id": "lslBzS",
            "likes": 4,
            "name": "Useful Little Functions From iq",
            "published": 3,
            "tags": [
                "iq",
                "functions",
                "almostidentity"
            ],
            "usePreview": 0,
            "username": "starea",
            "viewed": 715
        },
        "renderpass": [
            {
                "code": "// https://iquilezles.org/articles/functions\n// Reimplemented by starea @ shadertoy using Flyguy's Implicit Plotter https://www.shadertoy.com/view/4tB3WV\n#define PI 3.14159265359\n\n//Implicit / f(x) plotter thing.\n\n//XY range of the display.\n#define DISP_SCALE 3.0 \n\n//Line thickness (in pixels).\n#define LINE_SIZE 2.0\n\n//Grid line & axis thickness (in pixels).\n#define GRID_LINE_SIZE 1.0\n#define GRID_AXIS_SIZE 2.0\n\n//Number of grid lines per unit.\n#define GRID_LINES 1.0\n\n//Clip areas outside DISP_SCALE\n//#define CLIP_EDGES\n\nconst vec2 GRAD_OFFS = vec2(0.001, 0);\n\n#define GRAD(f, p) (vec2(f(p) - f(p + GRAD_OFFS.xy), f(p) - f(p + GRAD_OFFS.yx)) / GRAD_OFFS.xx)\n\n//PLOT(Function, Color, Destination, Screen Position)\n#define PLOT(f, c, d, p) d = mix(c, d, smoothstep(0.0, (LINE_SIZE / iResolution.y * DISP_SCALE), abs(f(p) / length(GRAD(f,p)))))\n\n\n\nfloat exponential_fog(float x) {\n    return (1.0 - exp(-x * 3.0));\n}\n\nfloat linear_fog(float x) {\n    return x;\n}\n\nfloat alphaImpulse( float x, float k )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat Fog(vec2 p) {\n\tfloat y = exponential_fog(p.x);\n\treturn p.y - y;\n}\nfloat LinearFog(vec2 p) {\n\tfloat y = linear_fog(p.x);\n\treturn p.y - y;\n}\n\nfloat SlowRaise(vec2 p) {\n    float shift = 0.1;\n    float slope = 3.0;\n    float x = p.x;\n    float y = (step(0.0, x - shift) * (1.0 - cos(slope * (x - shift))));\n\treturn p.y - y;\n}\n\n\n//>>>>>>>>>>>>>>>>> iq's little functions starts >>>>>>>>>>>>>>>>>>>>\n\nfloat almostIdentity( float x, float m, float n )\n{\n    if( x>m ) return x;\n\n    float a = 2.0f*n - m;\n    float b = 2.0f*m - 3.0f*n;\n    float t = x/m;\n\n    return (a*t + b)*t*t + n;\n}\n\nfloat impulse( float k, float x )\n{\n    float h = k*x;\n    return h*exp(1.0f-h);\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0f;\n    x /= w;\n    return 1.0f - x*x*(3.0f-2.0f*x);\n}\n\nfloat pcurve( float x, float a, float b )\n{\n    float k = pow(a+b,a+b) / (pow(a,a)*pow(b,b));\n    return k * pow( x, a ) * pow( 1.0-x, b );\n}\n\nfloat expStep( float x, float k, float n )\n{\n    return exp( -k*pow(x,n) );\n}\n\n\nfloat parabola( float x, float k )\n{\n    return pow( 4.0f*x*(1.0f-x), k );\n}\n\n//>>>>>>>>>>>>>>>>> iq's little functions ends >>>>>>>>>>>>>>>>>>>>\n// starea's Print-friendly Color Palette: https://www.shadertoy.com/view/4ltSWN\nvec3 RGBLabel(int i) {\n\tif (i == 0) return vec3(1.000, 1.000, 0.701);  else\n\tif (i == 1) return vec3(0.988, 0.834, 0.898);  else\n\tif (i == 2) return vec3(0.992, 0.805, 0.384); else\n\tif (i == 3) return vec3(0.775, 0.779, 0.875); else\n\tif (i == 4) return vec3(0.701, 0.871, 0.312); else\n\tif (i == 5) return vec3(0.553, 0.827, 0.780); else\n\tif (i == 6) return vec3(0.502, 0.694, 0.827); else\n\tif (i == 7) return vec3(0.984, 0.502, 0.347);\n\treturn vec3(0.0);\n}\n\n// 0.\n// When you don't want to change a value unless it's too small.\n// Rather than doing a sharp conditional branch, you can blend your value with a threshold smoothly with a cubic polynomial. \n// m: f(x) = x, x > m\n// n: f(0) = n\nfloat AlmostIdentity(vec2 p) {\n\tfloat y = almostIdentity(p.x, 0.5, 0.1);\n\treturn p.y - y;\n}\n\n// 1.\n// Great for triggering behaviours or making envelopes for music or animation, \n// and for anything that grows fast and then slowly decays. \nfloat Impulse(vec2 p)\n{\t\n\treturn p.y - impulse(p.x, 5.0);\n}\n\n// 2.\n// Of course you found yourself doing smoothstep(c-w,c,x)-smoothstep(c,c+w,x) very often, probably cause you were trying to isolate some features.\n// Then this cubicPulse() is your friend. Also, why not, you can use it as a cheap replacement for a gaussian.\nfloat CubicPulse(vec2 p)\n{\n\treturn p.y - cubicPulse(0.5, 0.2, p.x);\n}\n\n// 3.\n// A natural attenuation is an exponential of a linearly decaying quantity\nfloat ExpStep(vec2 p)\n{\n\treturn p.y - expStep(0.00005, 0.005, -p.x);\n}\n\nfloat Decay(in float dist, in float gradient, in float cutoff) {\n  float x = dist + gradient;\n  float y = x * step(cutoff, x) / gradient;\n  return exp(1.0 - y) * y;\n}\n\nfloat DrawDecay(vec2 p)\n{\n\treturn p.y - Decay(p.x, 0.05, 0.05);\n}\n\n\t\nfloat gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\n//float Gain(vec2 p) {\n//    return p.y - gain(p.x, 3.0);\n//}\nfloat Gain(vec2 p) {\n    return p.y - alphaImpulse(p.x, 3.0) * 1.0;\n}\n\n\nfloat Parabola(vec2 p)\n{\n\treturn p.y - parabola(p.x, 5.0);\n}\n\n// A nice choice to remap the 0..1 interval into 0..1, such that the corners are remapped to 0. \n// Very useful to skew the shape one side or the other in order to make leaves, eyes, and many other interesting shapes\nfloat PowerCurve(vec2 p)\n{\n\treturn p.y - pcurve(p.x, 1.0, 2.0);\n}\n\nfloat grid(vec2 p);\n\nfloat grid(vec2 p)\n{\n\tvec2 uv = mod(p,1.0 / GRID_LINES);\n\t\n\tfloat halfScale = 1.0 / GRID_LINES / 2.0;\n\t\n\tfloat gridRad = (GRID_LINE_SIZE / iResolution.y) * DISP_SCALE;\n\tfloat grid = halfScale - max(abs(uv.x - halfScale), abs(uv.y - halfScale));\n\tgrid = smoothstep(0.0, gridRad, grid);\n\t\n\tfloat axisRad = (GRID_AXIS_SIZE / iResolution.y) * DISP_SCALE;\n\tfloat axis = min(abs(p.x), abs(p.y));\n\taxis = smoothstep(axisRad-0.05, axisRad, axis);\n\t\n\treturn min(grid, axis);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = ( fragCoord.xy / iResolution.y ) - aspect / 2.0;\n\tuv *= DISP_SCALE;\n\t\n\tvec3 col = vec3(grid(uv) * 0.25);\n    \n    //PLOT(Fog, RGBLabel(0), col, uv);\n    //PLOT(LinearFog, RGBLabel(1), col, uv);\n    \n    \n    //PLOT(SlowRaise, RGBLabel(2), col, uv);\n    \n    //PLOT(SlowRaise, RGBLabel(5), col, uv);\n    \n    //PLOT(AlmostIdentity, RGBLabel(0), col, uv);\n    \n    //PLOT(Impulse, RGBLabel(1), col, uv);\n    \n    //PLOT(CubicPulse, RGBLabel(2), col, uv);\n    \n    PLOT(Gain, RGBLabel(6), col, uv);\n    \n    //PLOT(ExpStep, RGBLabel(3), col, uv);\n    \n    //PLOT(Parabola, RGBLabel(4), col, uv);\n    \n    //PLOT(PowerCurve, RGBLabel(5), col, uv);\n    \n\t#ifdef CLIP_EDGES \n\t\tcol *= 1.0 - step(DISP_SCALE / 2.0, abs(uv.x));    \n\t#endif\n\t\n\tfragColor = vec4( vec3(col), 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}