{
    "Shader": {
        "info": {
            "date": "1531592526",
            "description": "Variation of https://www.shadertoy.com/view/4ldyR8 with some coloring and a first go at a height-map.",
            "flags": 0,
            "hasliked": 0,
            "id": "MldcR8",
            "likes": 7,
            "name": "Voronoi height-map & color-test",
            "published": 3,
            "tags": [
                "2d",
                "voronoi",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 1675
        },
        "renderpass": [
            {
                "code": "const vec3 col1 = vec3 (6./255., 23./255., 102./255.);\nconst vec3 col3 = vec3 (76./255., 12./255., 130./255.);\nconst vec3 col5 = vec3 (194./255., 1./255., 101./255.);\nconst vec3 col7 = vec3 (217./255., 59./255., 10./255.);\nconst vec3 col9 = vec3 (255./255., 156./255., .0/255.);\nconst vec3 col2 = mix (col1, col3, .5);\nconst vec3 col4 = mix (col3, col5, .5);\nconst vec3 col6 = mix (col5, col7, .5);\nconst vec3 col8 = mix (col7, col9, .5);\nconst vec3 colA = mix (col9, col1, .5);\n\nvec3 gradient (float v) {\n    float steps = 10.;\n    float step = 1. / steps;\n    vec3 col = vec3 (.4);\n\n    if (v >= .0 && v < step) {\n        col = mix (col1, col2, v * steps);\n    } else if (v >= step && v < 2.0 * step) {\n        col = mix (col2, col3, (v - step) * steps);\n    } else if (v >= 2.0 * step && v < 3.0 * step) {\n        col = mix (col3, col4, (v - 2.0 * step) * steps);\n    } else if (v >= 3.0 * step && v < 4.0 * step) {\n        col = mix (col4, col5, (v - 3.0 * step) * steps);\n    } else if (v >= 4.0 * step && v < 5.0 * step) {\n        col = mix (col5, col6, (v - 4.0 * step) * steps);\n    } else if (v >= 5.0 * step && v < 6.0 * step) {\n        col = mix (col6, col7, (v - 5.0 * step) * steps);\n    } else if (v >= 6.0 * step && v < 7.0 * step) {\n        col = mix (col7, col8, (v - 6.0 * step) * steps);\n    } else if (v >= 7.0 * step && v < 8.0 * step) {\n        col = mix (col8, col9, (v - 7.0 * step) * steps);\n    } else if (v >= 8.0 * step && v < 9.0 * step) {\n        col = mix (col9, colA, (v - 8.0 * step) * steps);\n    }\n\n    return col;\n}\n\nvec2 noise2d (in vec2 p)\n{\n\tvec3 v = fract (p.xyx*vec3(123.34, 234.34, 345.65));\n\tv += dot (v, v + 34.45);\n\treturn fract (vec2 (v.x*v.y, v.y*v.z));\n}\n\nmat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n    float c = cos (rad);\n    float s = sin (rad);\n    return mat2 (c, s, -s, c);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat time = iTime + 5.;\n\n    // normalize and aspect-correct UVs\n    vec2 uv = fragCoord/iResolution.xy*2. - 1.;\n    vec2 uvRaw = uv;\n\tfloat aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n\n    // rotate and move the canvas\n    uv *= r2d (24.*time);\n    uv += vec2 (.2*cos (time), .3*sin(time));\n\n    // cause the canvas to 'zoom'\n    float scale = 6. + 3.*(.5 + .5*cos(time));\n    uv *= scale;\n    float rowSize = scale *.5;\n\n    // split canvas up\n    vec2 gv = fract (uv) - .5;\n    vec2 id = floor (uv);\n\n    float cellIndex = .0; \n    float minDist = 2.;\n\n    // check only the adjacent grid-cells\n    for (float y = -1.; y <= 1.; ++y) {\n        for (float x = -1.; x <= 1.; ++x) {\n            vec2 offset = vec2 (x, y); \n            vec2 n = noise2d (id + offset);\n            vec2 p = offset + .5*vec2 (cos (3.*sin(.005*time)*n.x*(time + 22.75)), sin (2.*cos(.007*time)*n.y*(time + 22.75)));\n            float d = dot (gv - p, gv - p);\n            if (d < minDist) {\n                minDist = d;\n                cellIndex = (id.y + y) * rowSize + (id.x + x); \n            }\n        }\n    }   \n\n    // 'color' cells in different styles\n    float brightColor = (1. - minDist)*(1. - minDist);\n    float darkColor = minDist*minDist;\n    float flatColor = abs (cellIndex) / (scale*scale);\n    float invertedFlatColor = 1. - flatColor;\n\n    // blend between the four different style-variations\n    float colorOne = mix (brightColor, darkColor, .25);\n    vec3 colorTwo;\n\n    if (uvRaw.x < sin (iTime + 6.25)) {\n        colorTwo = mix (gradient (flatColor), vec3 (invertedFlatColor), .035);\n    } else {\n        colorTwo = mix (vec3 (flatColor), vec3 (invertedFlatColor), .035);\n    }\n\n    vec3 colorFinal = mix (vec3 (colorOne), vec3 (colorTwo), .9);\n\n    // gamma-correct\n    colorFinal = pow (colorFinal, vec3 (1./2.2));\n\n    fragColor = vec4 (colorFinal, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}