{
    "Shader": {
        "info": {
            "date": "1611245729",
            "description": "3hour livecoding at January 22,2021 on https://youtu.be/8EC1wdPHiTs\n",
            "flags": 32,
            "hasliked": 0,
            "id": "WlKcRG",
            "likes": 10,
            "name": "Desolate planet",
            "published": 3,
            "tags": [
                "raymarching",
                "livecoding"
            ],
            "usePreview": 0,
            "username": "butadiene",
            "viewed": 439
        },
        "renderpass": [
            {
                "code": "//Copyright (c) 2021 Butadiene\n//Released under the MIT license\n//https://opensource.org/licenses/mit-license.php\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    \n    fragColor = texture(iChannel0,uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat rand(vec2 p){\n  return fract(sin(dot(p,vec2(12.9898,78.233)))*43578.543123);\n}\nfloat PI = acos(-1.);\nfloat noise(vec2 st){\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  \n  float a = rand(i);\n  float b = rand(i+vec2(1,0));\n  float c = rand(i+vec2(0,1));\n  float d = rand(i+vec2(1,1));\n  \n  vec2 u = f*f*(3.0-2.0*f);\n  \n  return mix(a,b,u.x)+(c-a)*u.y*(1.0-u.x)+(d-b)*u.x*u.y;\n}\n\nfloat fbm(vec2 st){\n  float v = 0.0;\n  float a = 0.5;\n  for(int i = 0;i<4;i++){\n    v += a*noise(st);\n    st *=2.0;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat cube(vec3 p,vec3 s){\n  vec3 q = abs(p);\n  vec3 m = max(s-q,0.0);\n  return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\n\nfloat cyl(vec3 p,float ln,float r){\n  \n  float s = max(length(p.xy)-r,0.);\n  \n  return length(vec2(max(abs(p.z)-ln,0.0),s))-min(max(ln-abs(p.z),0.),max(r-length(p.xy),0.));\n  \n}\n\nfloat  calcZ(){\n  float klt = mod(iTime*0.5,5.);\nreturn 40.0*pow(sin(klt)*exp(-klt),1.);\n}\n\nfloat  calcsZ(){\n  float klt = mod((iTime+0.7)*0.5,5.);\nreturn 40.0*pow(sin(klt)*exp(-klt),1.);\n}\n\nvec4 dist(vec3 p){\n  float k = 0.5;\n  vec3 sp = p;\n  \nfloat d2 =999.;\n\np = sp;\nfloat kt = 0.2*iTime;\n\n\np.xy += 1.*vec2(cos(kt),sin(kt));\n\np.xy *= rot(iTime*0.6+sin(iTime));\n\nfloat ksz = calcZ();\n\np.z += ksz;\n\nvec3 srp = p;\n\np.z -= 1.2;\nfloat s6 = cyl(p,.4,0.1*(0.5-abs(p.z)));\n\np=srp;\n\n\np.x = abs(p.x)-1.;\np.xz *= rot(0.25*PI);\nfloat d4 = cube(p,vec3(0.6,0.01,0.6));\np = srp;\n\np.z = abs(p.z)-1.;\nfloat d5 = cube(p,vec3(4.0,100.,0.4));\n\nd4 = max(d4,-d5);\n\np = srp;\np.xz *= rot(0.5*PI);\np.xy *= rot(-0.6);\np.zy *= rot(-0.5);\np.xz *= rot(2.05);\n\n//d4 = min(d4,s6);\n\nfor(int i = 0;i<4;i++){\n  vec3 ssp = p;\n  p.xz *= rot(PI*0.25);\n\n  d2 = cube(p,vec3(0.4,0.01,0.2));\n  p = ssp;\n  p.y += 0.05;\n  p.xz *= rot(1.7);\n  p.xy *= rot(PI*0.25); p.yz *= rot(PI*0.25);\n  float d3 = cube(p,vec3(0.2,0.2,0.2)*0.6);\n  d2 = min(d2,d3);\n  p.x = abs(p.x)-0.07;\n  p.z = abs(p.z)-0.2;\n  p.y = abs(p.y)-0.2;\n}\n\nd2 = min(d4,d2);\n\n  p = sp;\n\n  p.z -= 5.*iTime;\n  \n  float d1 = p.y+3.+0.3*fbm(p.xz*4.)*noise(p.xz)+2.*noise(p.xz*0.5+100.);\n  \n  float d = length(p)-0.1;\n  vec3 col = vec3(s6,d2,ksz);\n  \n  return vec4(col,min(d1,d2));\n}\n\nvec3 getNormal(vec3 p){\n  vec2 e = vec2(0.001,0.0);\n  return normalize(vec3(\n    dist(p+e.xyy).w-dist(p-e.xyy).w,\n    dist(p+e.yxy).w-dist(p-e.yxy).w,\n    dist(p+e.yyx).w-dist(p-e.yyx).w\n    \n    ));\n}\n\nvec3 cloud(vec3 rd,vec3 col,float s){\n  float acyz = length(rd.xz)/abs(rd.y);\n  col = mix(col,vec3(0.3),fbm(iTime+s*vec2(rd.xz*2.*acyz)));\n  col =  mix(col,vec3(0.1),fbm(iTime+s*vec2(rd.xz*4.*acyz)));\n  col = mix(vec3(0.5),col,exp(-0.2*abs(acyz)));\n  return col;\n}\n\nvec3 LightDir = normalize(vec3(0.0,-1.0,1.0));\nvec3 getSky(vec3 rd){\n  vec3 col = vec3(0.4,0.4,0.5);\n  float sun = 0.004/(1.-dot(-rd,LightDir));\n  col += clamp(sun,0.0,1.3);\n  col = cloud(rd,col,1.0);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\nvec2 r=iResolution.xy,p=(fragCoord.xy*2.-r)/min(r.x,r.y);\nfloat nt = fbm(p*10.3);\n\n\nfloat krt = iTime*0.+0.5*PI;\nfloat ra = 4.0;\nfloat kss = 1.;\nvec3 st = vec3(0);\nfloat kf = max(calcsZ(),0.);\nst = vec3(0,-2.-sin(iTime*0.7),-1)+0.3*vec3(fbm(vec2(iTime*kss)),fbm(vec2(iTime*kss+100.)),fbm(vec2(kss*iTime+1000.)));\nif(mod(iTime,34.)>14.){\n  st += vec3(0,sin(iTime*0.7)+4.,-calcZ());\n  float kt= 0.2*iTime;\n  st.xy += vec2(cos(kt),sin(kt));\n  krt = iTime*0.2;\n  ra = 1.;\n}else{\n  \n}\nvec3 ro =st+ vec3(cos(krt)*ra,0.5,ra*sin(krt));\nvec3 ta = st+vec3(0,0,0);\n\nvec3 cdir = normalize(ta-ro);\nvec3 side = cross(cdir,vec3(0,1,0));\nvec3 up = cross(side,cdir);\nfloat fov = 1.;\n\nvec3 rd = normalize(p.x*side+p.y*up+fov*cdir);\n\nfloat d,t= 0.0;\n\nvec4 tdr;\n\nfloat thr = 0.001;\n\n\nvec3 ac = vec3(0.);\n\nfor(int i =0;i<108;i++){\n  tdr = dist(ro+rd*t);\n  d = tdr.w;\n  float sc = max(tdr.x,0.02);\n  d = min(sc,d);\n  t += d*0.7;\n  ac += (1.0+3.0*max(tdr.z,-0.2))*exp(sc*-4.)*vec3(0.6,0.4,0.05)+0.15*exp(tdr.y*-1.)*vec3(0.3,0.4,0.6);\n  if(thr>d||t>100.)break;\n}\nvec3 col = vec3(0.);\nif(thr>d){\n  vec3 normal = getNormal(ro+rd*t);\n  \n  float lm = max(dot(-LightDir,normal),0.);\n\n\n\n  col = vec3(lm);\n  \n  col += ac*0.3;\n  \n  //col = cloud(-LightDir+0.*fbm((ro+rd*t).xz),col,100.);\n  \n  col = mix(vec3(getSky(normal+rd*0.01).y),col,exp((-0.3*fbm((ro+rd*t).xz-vec2(0,2.*iTime)))*t));\n  col = mix(col,vec3(0.49),1.-clamp(exp(-0.05*(t-5.)),0.0,1.0));\n  \n}else{\n  if(thr<d) col = getSky(rd);\n}\n vec2 uv = fragCoord/iResolution.xy;\n\n  col =mix(col,texture(iChannel0,uv).xyz,0.3+0.05*kf);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}