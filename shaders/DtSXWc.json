{
    "Shader": {
        "info": {
            "date": "1676655844",
            "description": "Walk on spheres algorithm that takes into account Neumann boundary conditions",
            "flags": 32,
            "hasliked": 0,
            "id": "DtSXWc",
            "likes": 13,
            "name": "Walk on spheres - Neumann BC",
            "published": 3,
            "tags": [
                "laplace",
                "neumann",
                "wos",
                "dirichet"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 431
        },
        "renderpass": [
            {
                "code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 vec2Color(vec2 v)\n{\n    float m = length(v);\n    float ang = atan(v.x, v.y)/TWO_PI;\n    return hsv2rgb(vec3(ang, 1.0, m));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitRNG(fragCoord, iFrame);\n    \n    fragColor = vec4(0.5*abs(texelFetch(iChannel0, ivec2(fragCoord), 0).x));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define TWO_PI (2.0 * 3.14159)\n#define MAX_WOS_STEPS 250\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec2 minSD(vec2 a, vec2 b)\n{\n    return (a.x < b.x)?a:b;\n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(TWO_PI * ang), sin(TWO_PI * ang));\n}\n\n\n//https://www.shadertoy.com/view/XlGcRh\n\n#define c1 0xcc9e2d51u\n#define c2 0x1b873593u\n\nuint rotl(uint x, uint r)\n{\n\treturn (x << r) | (x >> (32u - r));\n}\n\nuint fmix(uint h)\n{\n    h ^= h >> 16;\n    h *= 0x85ebca6bu;\n    h ^= h >> 13;\n    h *= 0xc2b2ae35u;\n    h ^= h >> 16;\n    return h;\n}\n\nuint murmur3(uint seed)\n{\n    uint h = 0u;\n    uint k = seed;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    h ^= 4u;\n\n    return fmix(h);\n}\n\nuint murmur3(uvec4 seed)\n{\n    uint h = 0u;\n    uint k = seed.x;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.y;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.z;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.w;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    h ^= 16u;\n\n    return fmix(h);\n}\n\nuint _seed; \n\nvoid InitRNG(vec2 p, int frame)\n{\n    _seed = murmur3(uvec4(p, uint(frame), uint(p.x) + uint(p.y)));\n}\n\nfloat rand()\n{\n    _seed = murmur3(_seed);\n    return float(_seed)*(1.0/float(0xffffffffu));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Pseudocode recursive implementation\n//float estimateNeumannU(vec2 p)\n//{\n//  //inverse gradient estimate\n//  vec2 normal = SDF_grad(p);\n//  //gradient is = (u(p + eps*normal) - u(p))/eps = A \n//  // -> u(x) = u(p + eps*normal) - eps*A;\n//  return estimateU(p + eps*normal) - eps * getNeumannBC(p);\n//}\n//\n//float estimateU(vec2 p)\n//{\n//  vec2 sd = SDF(p);\n//  if(sd < eps) \n//  {\n//    if(sd.y == DIRICHLET) return getDirichetU(p);\n//    if(sd.y == NEUMANN) return estimateNeumannU(p);\n//  }\n//  else return estimateU(p + sd.x*Dir(rand()));\n//}\n\n\n#define EPS 5.0\n#define NEPS 15.0\n\nvec2 Boundary(in vec2 p, in vec2 R)\n{\n    vec2 edge = vec2(-sdBox(p - vec2(0.5)*R, R*vec2(0.49)), 0);\n    vec2 obj0 = vec2(sdCircle(p - vec2(0.75)*R, 0.1*R.y),1);\n    vec2 obj1 = vec2(sdBox(p - vec2(0.3)*R, 0.15*R),1);\n    return minSD(edge, minSD(obj0, obj1));\n}\n\nvec2 BoundaryNormal(vec2 p, vec2 R) \n{\n\tconst vec3 k = vec3(1,-1,0);\n\treturn normalize(vec2(Boundary(p + k.xz,R).x - Boundary(p + k.yz,R).x, Boundary(p + k.zx,R).x - Boundary(p + k.zy,R).x));\n}\n\nfloat NeumannBC(vec2 p, vec2 normal)\n{\n    return 0.025*dot(Dir(0.25*iTime), normal);\n}\n\nfloat WOS(vec2 p)\n{\n    float U = 0.0;\n\n    for(int i = 0; i < MAX_WOS_STEPS; i++)\n    {\n        vec2 boundary = Boundary(p, iResolution.xy);\n        float sd = boundary.x;\n        float type = boundary.y;\n        \n        //if(sd < 0.0) return 1.0; //inside of boundary\n        \n        if(sd < 1.0)\n        {\n            if(type == 0.0) //dirichlet \n            {\n                return U;\n            }\n            if(type == 1.0) //neumann \n            {\n                vec2 normal = BoundaryNormal(p, iResolution.xy);\n                U += NeumannBC(p, normal) * NEPS;\n                p += normal * NEPS;\n            }\n        }\n        else p += Dir(rand())*sd;\n    }\n    \n    return 0.0;\n}\n\nvec2 EstimateU(vec2 p)\n{\n    vec2 est = vec2(0.0, 0.00001);\n    vec2 prev = texelFetch(iChannel0, ivec2(p), 0).xy*0.95;\n    est += prev.xy * vec2(prev.y, 1.0);\n    for(int i = 0; i < 8; i++)\n    {\n        est += vec2(WOS(p), 1.0);\n    }\n    return vec2(est.x/est.y, est.y);\n}\n\nvec3 EstimateGradU(vec2 p)\n{\n    vec3 est = vec3(0.0, 0.0, 0.00001);\n    float sd = Boundary(p, iResolution.xy).x;\n    if(sd <= 0.0) return vec3(0.0);\n    for(int i = 0; i < 1; i++)\n    {\n        vec2 n = Dir(rand());\n        est += vec3(100.0* n * WOS(p + n*sd) / sd, 1.0);\n    }\n    return vec3(est.xy/est.z, est.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitRNG(fragCoord, iFrame);\n    \n    fragColor.xy = EstimateU(fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}