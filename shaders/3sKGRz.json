{
    "Shader": {
        "info": {
            "date": "1569599356",
            "description": "Itâ€™s a lego brick! It seemed a fitting subject for learning raymarching sdfs and csg.",
            "flags": 0,
            "hasliked": 0,
            "id": "3sKGRz",
            "likes": 3,
            "name": "Lumpy Elongated Gutted Object",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "sdf",
                "lego"
            ],
            "usePreview": 0,
            "username": "adurdin",
            "viewed": 470
        },
        "renderpass": [
            {
                "code": "// Lighting and camera stuff from https://www.shadertoy.com/view/lt33z7\n// SDF primitives from https://iquilezles.org/articles/distfunctions\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// NOTE: modified from iq's, because his seems to have b be halfsize, not size!\nfloat sdCube( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - 0.5*b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with width = height = length = 2.0\n */\nfloat cubeSDF2(vec3 p, vec3 b) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - b;\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n// NOTE: modified from iq's, because his seemed to have radius doubled, and\n// height doubled too!?\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-ra+rb, abs(p.y) - 0.5*h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n// NOTE: modified from iq's, because his seemed to have height and radius swapped,\n// and height doubled!?\nfloat sdCappedCylinder( vec3 p, float r, float h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,0.5*h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// ---------------------------------------------------\n\nfloat sdIntersect(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat sdUnion(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat sdDifference(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n// ---------------------------------------------------\n\nfloat sdStud(vec3 p, vec3 brickSize, float x, float z)\n{\n    float studRadius = 2.4;\n    float studHeight = 1.8;\n    vec3 studOrigin = vec3(0.0, 0.5*studHeight + 0.5*brickSize.y, 0.0);\n    return sdRoundedCylinder(p - studOrigin + vec3(x*4.0, 0.0, z*4.0),\n        studRadius, 0.1, studHeight);\n}\n\nfloat sdStudHollow(vec3 p, vec3 brickSize, float x, float z)\n{\n    float radius = 1.3;\n    float height = 1.7;\n    vec3 origin = vec3(0.0, 0.5*height + 0.5*brickSize.y - 1.01, 0.0);\n    return sdCappedCylinder(p - origin + vec3(x*4.0, 0.0, z*4.0), radius, height);\n}\n\nfloat sdButtressZ(vec3 p, vec3 brickSize, float z)\n{\n    float buttWidth = 0.6;\n    float buttDepth = 0.4;\n    return sdCube(\n        p - vec3(0.0, 0.0, z*(0.5*brickSize.z-1.2)),\n        vec3(buttWidth, brickSize.y, buttDepth)\n        );\n}\n\nfloat sdButtressX(vec3 p, vec3 brickSize, float x, float z)\n{\n    float buttWidth = 0.6;\n    float buttDepth = 0.4;\n    return sdCube(\n        p - vec3(x*(0.5*brickSize.x-1.2), 0.0, z*4.0),\n        vec3(buttDepth, brickSize.y, buttWidth)\n        );\n}\n\nfloat sdSupport(vec3 p, vec3 brickSize, float z)\n{\n    float radius = 3.255;\n    float height = brickSize.y;\n    return sdCappedCylinder(p - vec3(0.0, 0.0, z*4.0), radius, height);\n}\n\nfloat sdSupportHollow(vec3 p, vec3 brickSize, float z)\n{\n    float radius = 2.4;\n    float height = brickSize.y;\n    return sdCappedCylinder(p - vec3(0.0, -1.0, z*4.0), radius, height);\n}\n\nfloat sceneSDF(vec3 p) {\n    vec3 brickSize = vec3(15.8, 9.6, 31.8);\n    float brickBody = sdDifference(\n        sdCube(p, brickSize),\n        sdCube(p - vec3(0.0, -1.0, 0.0), brickSize - vec3(2.4, 0.0, 2.4))\n        );\n    float crossBeam = sdCube(p - vec3(0.0, 1.65-0.1, 0.0), vec3(13.8, 9.6-3.3, 0.8));\n    float studs = sdUnion(\n        sdUnion(\n            sdUnion(\n                sdStud(p, brickSize, 1.0, -3.0),\n                sdStud(p, brickSize, 1.0, -1.0)\n            ),\n            sdUnion(\n                sdStud(p, brickSize, 1.0, 1.0),\n                sdStud(p, brickSize, 1.0, 3.0)\n            )\n        ),\n        sdUnion(\n            sdUnion(\n                sdStud(p, brickSize, -1.0, -3.0),\n                sdStud(p, brickSize, -1.0, -1.0)\n            ),\n            sdUnion(\n                sdStud(p, brickSize, -1.0, 1.0),\n                sdStud(p, brickSize, -1.0, 3.0)\n            )\n        )\n    );\n    float studHollows = sdUnion(\n        sdUnion(\n            sdUnion(\n                sdStudHollow(p, brickSize, 1.0, -3.0),\n                sdStudHollow(p, brickSize, 1.0, -1.0)\n            ),\n            sdUnion(\n                sdStudHollow(p, brickSize, 1.0, 1.0),\n                sdStudHollow(p, brickSize, 1.0, 3.0)\n            )\n        ),\n        sdUnion(\n            sdUnion(\n                sdStudHollow(p, brickSize, -1.0, -3.0),\n                sdStudHollow(p, brickSize, -1.0, -1.0)\n            ),\n            sdUnion(\n                sdStudHollow(p, brickSize, -1.0, 1.0),\n                sdStudHollow(p, brickSize, -1.0, 3.0)\n            )\n        )\n    );\n    float buttresses = sdUnion(\n        sdUnion(\n            sdUnion(\n                sdUnion(\n                    sdButtressX(p, brickSize, 1.0, -3.0),\n                    sdButtressX(p, brickSize, 1.0, -1.0)\n                ),\n                sdUnion(\n                    sdButtressX(p, brickSize, 1.0, 1.0),\n                    sdButtressX(p, brickSize, 1.0, 3.0)\n                )\n            ),\n            sdUnion(\n                sdUnion(\n                    sdButtressX(p, brickSize, -1.0, -3.0),\n                    sdButtressX(p, brickSize, -1.0, -1.0)\n                ),\n                sdUnion(\n                    sdButtressX(p, brickSize, -1.0, 1.0),\n                    sdButtressX(p, brickSize, -1.0, 3.0)\n                )\n            )\n        ),\n        sdUnion(\n            sdButtressZ(p, brickSize, 1.0),\n            sdButtressZ(p, brickSize, -1.0)\n        )\n    );\n    float supports = sdUnion(\n        sdSupport(p, brickSize, 0.0),\n        sdUnion(\n            sdSupport(p, brickSize, -2.0),\n            sdSupport(p, brickSize, 2.0)\n        )\n    );\n    float supportHollows = sdUnion(\n        sdSupportHollow(p, brickSize, 0.0),\n        sdUnion(\n            sdSupportHollow(p, brickSize, -2.0),\n            sdSupportHollow(p, brickSize, 2.0)\n        )\n    );\n    float brick = sdDifference(\n        sdUnion(\n            sdUnion(\n                brickBody,\n                crossBeam\n            ),\n            sdUnion(\n                buttresses,\n                supports\n            )\n        ),\n        sdUnion(\n            studHollows,\n            supportHollows\n        )\n    );\n    return sdUnion(brick, studs);\n}\n\n// ---------------------------------------------------\n\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define MAX_MARCHING_STEPS 255\n#define EPSILON 0.0001\n\nvec3 estimateNormal(vec3 p)\n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z))\n            - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z))\n            - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON))\n            - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 N, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 n, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(36.0, 24.0, 36.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, n, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(-24.0, -24.0, -24.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, n, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nstruct raymarch_result {\n    float depth;\n    int steps;\n};\n\nraymarch_result raymarch(\n    vec3 eye, vec3 direction, float start, float end)\n{\n    raymarch_result result;\n    float depth = start;\n    int stepCount = 0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        stepCount = i;\n        float dist = sceneSDF(eye + depth * direction);\n        if (dist < EPSILON) {\n            result.depth = depth;\n            result.steps = stepCount;\n            return result;\n        }\n        depth += dist;\n        if (depth >= end) {\n            result.depth = end;\n            result.steps = stepCount;\n            return result;\n        }\n    }\n    result.depth = end;\n    result.steps = stepCount;\n    return result;\n}\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float time = iTime;\n    float fov = 80.0;\n    vec3 dir = rayDirection(fov, iResolution.xy, gl_FragCoord.xy);\n    float cameraDistance = 100.0;\n    float cameraSpeed = 0.5;\n    vec3 eye = vec3(\n        0.5*cameraDistance * sin(cameraSpeed*time),\n        cameraDistance / 1.5 * sin(1.5*cameraSpeed*time),\n        0.5*cameraDistance * cos(cameraSpeed*time)\n        );\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(dir, 0.0)).xyz;\n    \n    raymarch_result result = raymarch(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (result.depth > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }\n\n    vec3 p = eye + result.depth * worldDir;\n    vec3 n = estimateNormal(p);\n\n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(1.0, 0.0, 0.0);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 30.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, n, eye);\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}