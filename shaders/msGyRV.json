{
    "Shader": {
        "info": {
            "date": "1696747248",
            "description": "Click & drag to rotate color wheel!\nGenerated by squaring a complex number repeatedly. White boundary between frag positions starting stable orbits & ones diverging to infinity.\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "msGyRV",
            "likes": 10,
            "name": "Fractal of Julia",
            "published": 3,
            "tags": [
                "orbit",
                "derivative",
                "complex",
                "dual",
                "trap",
                "imaginary",
                "automatic",
                "differential",
                "chaotic"
            ],
            "usePreview": 0,
            "username": "domrally",
            "viewed": 189
        },
        "renderpass": [
            {
                "code": "/// by Dom Mandy in 2023\n\n\n/*\nComplex arithmetic.\n*/\nvec2 power(vec2 a, float b) { \n    float angle = atan(a.y, a.x);\n    vec2 direction = vec2(\n        cos(b * angle), \n        sin(b * angle) \n    ); \n    \n    return direction * pow(dot(a, a), b / 2.);\n}\nvec2 divide(vec2 a, vec2 b)  { \n    vec2 dividend = vec2( \n        dot(a, b), \n        dot(vec2(a.y, -a.x), b)\n    );\n    \n    return dividend / dot(b, b);\n}\nvec2 multiply(vec2 a, vec2 b) { \n    return vec2( \n        a[0] * b[0] - a[1] * b[1], \n        a[0] * b[1] + a[1] * b[0]\n    ); \n}\n\n\n/*\nDifferential multiplication.\n*/\nmat4x2 multiply(mat4x2 a, mat4x2 b) {\n    mat4x2 products;\n    int degree, i, j;\n    // Wedge product.\n    for (; degree < 4; degree++) {\n        for (i = 0; i <= degree; i++) {\n            j = degree - i;\n            // Differential product rule.\n            products[degree] += multiply(a[i], b[j]);\n        }\n    }\n    \n    return products;\n}\n\n\n/*\nBöttcher's Map\n*/\nvec2 bottcher(vec2 a, vec2 b, float count) {\n    vec2 base = divide(a, a - b);\n    float exponent = pow(.5, count);\n    return power(base, exponent);        \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Zoom pixel space to view space\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.x;\n    vec2 uvStart = 2.2 * (2. * fragCoord - iResolution.xy) / iResolution.x;\n    vec2 uvEnd = (uvStart * .03) + vec2(.4, .5);\n    vec2 uvMouse = 2. * iMouse.xy - iResolution.xy;\n    uv = mix(uvStart, uvEnd, .5 - .5 * cos(iTime / 4.));\n    \n    // 4th order differential supernumbers as higher order differential forms\n    mat4x2 orbit, offset;\n    vec2 mapped;\n\n    // Rules for mandelbrot set\n    orbit[0] = mapped = uv;\n    // Image space is a linear grid, so it has constant 1st order derivatives.\n    // No higher order derivatives (those grow while orbiting).\n    orbit[1] = vec2(1.);\n    \n    float time = 1.3 + iTime / 2.;\n    float r = .618;\n    offset[0] = vec2(\n        r * cos(time),\n        r * sin(time)\n    );\n    \n    // Simulate the trajectory for this pixel relative to the center of the image.\n    vec2 trapped;\n    float radius = 9e9;\n    for (float i; i < 47.; i++) {\n        // This recursion generates chaotic behavior\n        orbit = multiply(orbit, orbit) + offset;\n        // Track coordinate deformation\n        mapped = multiply(mapped, bottcher(orbit[0], offset[0], i));\n        // We want to record the nearest approach as the pixel orbits around the image center.\n        float flyby = dot(orbit[0], orbit[0]);\n        radius = min(radius, flyby);\n        // The closest point is called the orbit trap.\n        trapped = trapped * float(radius != flyby) + float(radius == flyby) * orbit[0];\n        // Stop in case of overflow\n        if(flyby > 9e7) break;\n    }\n    \n    // The derivatives need to be scaled by their binomial taylor coefficients\n    vec4 differentials = vec4(\n        length(orbit[0]),\n        length(orbit[1]),\n        2. * length(orbit[2]),\n        6. * length(orbit[3])\n    );\n    \n    // The solution curve is everywhere flat.\n    // This means that the ratios of the derivatives should be \n    // the same for all degrees when we are close to the solution.\n    vec3 estimates = vec3(\n        differentials[0] / differentials[1], \n        differentials[1] / differentials[2], \n        differentials[2] / differentials[3]\n    );\n    // Weight by relative convergence rate\n    vec3 weights = vec3(2., 3., 4.);\n    // Combine for smoother distance estimate.\n    float est = dot(estimates, weights) / dot(weights, vec3(1.));\n    // Distance = log|f| |f|/|f'|\n    float dist = est * log(differentials[0]);\n    float lightness = smoothstep(1.3, 0., pow(dist, .1));\n    // Grid\n    float approach = length(trapped);\n    float scale = 64.;\n    float grid = .5 + .5 * pow(clamp(max(cos(scale * mapped.x), cos(scale * mapped.y)), 0., 1.), 99.);\n    float outside = float(lightness > 0.);\n    lightness = outside * mix(lightness, 2.2 * lightness, grid * smoothstep(0., 1.4, log(approach)));\n    // Highlight the chaotic tree structure inside the fractal\n    float inside = float(dist < 0. || lightness <= 0.);\n    lightness += inside * smoothstep(.8, .0, approach);\n    lightness = clamp(lightness, 0., 1.);\n    // Find the angle of closest approach of the orbit trap\n    float angle = atan(trapped.y, trapped.x);\n    // Match the angle to the color wheel\n    float hue = angle - atan(uvMouse.y, uvMouse.x) + iTime;\n    // The pixel gets greyer the farther the orbit trap\n    float chroma = mix(.95, .3, smoothstep(0., 3., approach));\n    \n    // Paint the pixel\n    fragColor.rgb = oklch2rgb(lightness, chroma, hue);\n    fragColor.a = 1.;\n}\n\n\n/*\nREFERENCES\n\ncolor\n\nbjornornorn 2022\nhttps://www.shadertoy.com/view/flSyWz\n\ndomain warping\n\ngcgac 2022\nhttps://www.shadertoy.com/view/NtyfWD\n\niq 2013\nhttps://www.shadertoy.com/view/MdX3zN\n\ndistance\n\niq 2013\nhttps://www.shadertoy.com/view/lsX3W4\n\norbit traps\n\nDeltaT 2023\nhttps://www.shadertoy.com/view/csSyzy\n\nathibaul 2021\nhttps://www.shadertoy.com/view/fdt3zX\n\npiotrekli 2016\nhttps://www.shadertoy.com/view/4lK3Dc\n\nKramin 2015\nhttps://www.shadertoy.com/view/4st3Wn\n*/\n\n\n/*\nFUTHER READING\n\nnumbers\n\nhttps://en.wikipedia.org/wiki/Dual_number#Differentiation\nhttps://en.wikipedia.org/wiki/Grassmann_number#Generalisations\nhttps://en.wikipedia.org/wiki/Complex_number#Multiplication_and_square\n\nfractals\n\nhttps://en.wikipedia.org/wiki/Julia_set\nhttps://en.wikipedia.org/wiki/Bifurcation_diagram\nhttps://en.wikipedia.org/wiki/Orbit_trap#Point_based\n\ndifferentials\n\nhttps://en.wikipedia.org/wiki/Product_rule\nhttps://en.wikipedia.org/wiki/Gradient_descent\nhttps://en.wikipedia.org/wiki/Newton%27s_method\nhttps://en.wikipedia.org/wiki/Householder%27s_method\nhttps://en.wikipedia.org/wiki/Automatic_differentiation\nhttps://en.wikipedia.org/wiki/Exterior_algebra#Oriented_areas_in_space\n\ncolor mapping\n\nhttps://en.wikipedia.org/wiki/Color_wheel\nhttps://en.wikipedia.org/wiki/Versine#Definitions\nhttps://en.wikipedia.org/wiki/Argument_(complex_analysis)\n*/\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/// This page of color space tools adapted from (2022): \n///    https://www.shadertoy.com/view/flSyWz\n/// by Björn Ottosson: \n///    https://www.shadertoy.com/user/bjornornorn\n\n\nconst float M_PI = 3.1415926535897932384626433832795;\n\nfloat cbrt( float x )\n{\n    return sign(x)*pow(abs(x),1.0f/3.0f);\n}\n\nfloat srgb_transfer_function(float a)\n{\n\treturn .0031308f >= a ? 12.92f * a : 1.055f * pow(a, .4166666666666667f) - .055f;\n}\n\nfloat srgb_transfer_function_inv(float a)\n{\n\treturn .04045f < a ? pow((a + .055f) / 1.055f, 2.4f) : a / 12.92f;\n}\n\nvec3 linear_srgb_to_oklab(vec3 c)\n{\n\tfloat l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;\n\tfloat m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;\n\tfloat s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;\n\n\tfloat l_ = cbrt(l);\n\tfloat m_ = cbrt(m);\n\tfloat s_ = cbrt(s);\n\n\treturn vec3(\n\t\t0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,\n\t\t1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,\n\t\t0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_\n\t);\n}\n\nvec3 oklab_to_linear_srgb(vec3 c)\n{\n\tfloat l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n\tfloat m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n\tfloat s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n\tfloat l = l_ * l_ * l_;\n\tfloat m = m_ * m_ * m_;\n\tfloat s = s_ * s_ * s_;\n\n\treturn vec3(\n\t\t+4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,\n\t\t-1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,\n\t\t-0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s\n\t);\n}\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n\t// Max saturation will be when one of r, g or b goes below zero.\n\n\t// Select different coefficients depending on which component goes below zero first\n\tfloat k0, k1, k2, k3, k4, wl, wm, ws;\n\n\tif (-1.88170328f * a - 0.80936493f * b > 1.f)\n\t{\n\t\t// Red component\n\t\tk0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n\t\twl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n\t}\n\telse if (1.81444104f * a - 1.19445276f * b > 1.f)\n\t{\n\t\t// Green component\n\t\tk0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n\t\twl = -1.2684380046f; wm = +2.6097574011f; ws = -0.3413193965f;\n\t}\n\telse\n\t{\n\t\t// Blue component\n\t\tk0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n\t\twl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n\t}\n\n\t// Approximate max saturation using a polynomial:\n\tfloat S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n\t// Do one step Halley's method to get closer\n\t// this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n\t// this should be sufficient for most applications, otherwise do two/three steps \n\n\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t{\n\t\tfloat l_ = 1.f + S * k_l;\n\t\tfloat m_ = 1.f + S * k_m;\n\t\tfloat s_ = 1.f + S * k_s;\n\n\t\tfloat l = l_ * l_ * l_;\n\t\tfloat m = m_ * m_ * m_;\n\t\tfloat s = s_ * s_ * s_;\n\n\t\tfloat l_dS = 3.f * k_l * l_ * l_;\n\t\tfloat m_dS = 3.f * k_m * m_ * m_;\n\t\tfloat s_dS = 3.f * k_s * s_ * s_;\n\n\t\tfloat l_dS2 = 6.f * k_l * k_l * l_;\n\t\tfloat m_dS2 = 6.f * k_m * k_m * m_;\n\t\tfloat s_dS2 = 6.f * k_s * k_s * s_;\n\n\t\tfloat f = wl * l + wm * m + ws * s;\n\t\tfloat f1 = wl * l_dS + wm * m_dS + ws * s_dS;\n\t\tfloat f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n\t\tS = S - f * f1 / (f1 * f1 - 0.5f * f * f2);\n\t}\n\n\treturn S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n\t// First, find the maximum saturation (saturation S = C/L)\n\tfloat S_cusp = compute_max_saturation(a, b);\n\n\t// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n\tvec3 rgb_at_max = oklab_to_linear_srgb(vec3( 1, S_cusp * a, S_cusp * b ));\n\tfloat L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n\tfloat C_cusp = L_cusp * S_cusp;\n\n\treturn vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by \n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0, vec2 cusp)\n{\n\t// Find the intersection for upper and lower half seprately\n\tfloat t;\n\tif (((L1 - L0) * cusp.y - (cusp.x - L0) * C1) <= 0.f)\n\t{\n\t\t// Lower half\n\n\t\tt = cusp.y * L0 / (C1 * cusp.x + cusp.y * (L0 - L1));\n\t}\n\telse\n\t{\n\t\t// Upper half\n\n\t\t// First intersect with triangle\n\t\tt = cusp.y * (L0 - 1.f) / (C1 * (cusp.x - 1.f) + cusp.y * (L0 - L1));\n\n\t\t// Then one step Halley's method\n\t\t{\n\t\t\tfloat dL = L1 - L0;\n\t\t\tfloat dC = C1;\n\n\t\t\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\t\t\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\t\t\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t\t\tfloat l_dt = dL + dC * k_l;\n\t\t\tfloat m_dt = dL + dC * k_m;\n\t\t\tfloat s_dt = dL + dC * k_s;\n\n\n\t\t\t// If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n\t\t\t{\n\t\t\t\tfloat L = L0 * (1.f - t) + t * L1;\n\t\t\t\tfloat C = t * C1;\n\n\t\t\t\tfloat l_ = L + C * k_l;\n\t\t\t\tfloat m_ = L + C * k_m;\n\t\t\t\tfloat s_ = L + C * k_s;\n\n\t\t\t\tfloat l = l_ * l_ * l_;\n\t\t\t\tfloat m = m_ * m_ * m_;\n\t\t\t\tfloat s = s_ * s_ * s_;\n\n\t\t\t\tfloat ldt = 3.f * l_dt * l_ * l_;\n\t\t\t\tfloat mdt = 3.f * m_dt * m_ * m_;\n\t\t\t\tfloat sdt = 3.f * s_dt * s_ * s_;\n\n\t\t\t\tfloat ldt2 = 6.f * l_dt * l_dt * l_;\n\t\t\t\tfloat mdt2 = 6.f * m_dt * m_dt * m_;\n\t\t\t\tfloat sdt2 = 6.f * s_dt * s_dt * s_;\n\n\t\t\t\tfloat r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.f;\n\t\t\t\tfloat r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n\t\t\t\tfloat r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n\t\t\t\tfloat u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n\t\t\t\tfloat t_r = -r * u_r;\n\n\t\t\t\tfloat g = -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s - 1.f;\n\t\t\t\tfloat g1 = -1.2684380046f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n\t\t\t\tfloat g2 = -1.2684380046f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n\t\t\t\tfloat u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n\t\t\t\tfloat t_g = -g * u_g;\n\n\t\t\t\tfloat b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.f;\n\t\t\t\tfloat b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n\t\t\t\tfloat b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n\t\t\t\tfloat u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n\t\t\t\tfloat t_b = -b * u_b;\n\n\t\t\t\tt_r = u_r >= 0.f ? t_r : 10000.f;\n\t\t\t\tt_g = u_g >= 0.f ? t_g : 10000.f;\n\t\t\t\tt_b = u_b >= 0.f ? t_b : 10000.f;\n\n\t\t\t\tt += min(t_r, min(t_g, t_b));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t;\n}\n\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n\t// Find the cusp of the gamut triangle\n\tvec2 cusp = find_cusp(a, b);\n\n\treturn find_gamut_intersection(a, b, L1, C1, L0, cusp);\n}\n\nvec3 softSaturate(vec3 x, vec3 a)\n{\n    a = 1.0+a;\n    x = min(x, a);\n    vec3 b = (a-1.0)*sqrt(a/(2.0-a));\n    return 1.0 - (sqrt((x-a)*(x-a) + b*b) - b)/(sqrt(a*a+b*b)-b);\n}\n\nvec3 softClipColorOutsideGamutOnly(vec3 color)\n{\n    // soft clipping scaled to only have an effect if the color is outside the gamut\n    \n    float middle = 0.2;\n    \n    vec3 x = color-middle;\n\n    vec3 xsgn = sign(x);\n    vec3 xscale = 0.5 + xsgn*(0.5-middle);\n    x /= xscale;\n    \n    vec3 absX = abs(x);\n    \n    float maxX = max(max(1.0,absX.r), max(absX.g, absX.b));\n    \n    float softness_scale = 0.5;\n    float softness = softness_scale*(maxX-1.0);\n    softness = softness/(1.0+softness);\n    \n    return middle + xscale*xsgn*softSaturate(absX, vec3(softness));\n}\n\nvec2 approximateShape(float a, float b)\n{\n    float C = sqrt(a*a+b*b);\n    a /= C;\n    b /= C;\n    \n    float a2 = 2.0*a*b;\n    float b2 = a*a - b*b;\n    float a3 = 3.0*a - 4.0*a*a*a;\n    float b3 = -3.0*b + 4.0*b*b*b;    \n  \n    // softness_scale 0.0\n    // Estimated using https://colab.research.google.com/drive/1qQA3xhBX3iB8FT8558e5QQnmVZ5Jh1Fb?usp=sharing\n    return vec2(\n        1.63804674 + -0.08431713*a +  0.27624179*b +  0.08737741*a2 +  0.13917503*b2 + 0.03691021*a3 +  0.03060615*b3,\n        0.23438507 + 0.05736278*a  +  -0.09674117*b +  0.024447*a2 + 0.00469441*b2 + 0.01253234*a3 + 0.00741058*b3\n    );\n}\n\nfloat Srgb1(float c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nvec3 Srgb3(vec3 c){return vec3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\nvec3 oklch2rgb(float lightness, float chroma, float hue) {\n    chroma = mix(.0, -.25 * log(.55), chroma);\n    // Translate to Lab color space\n    float a = cos(hue);\n    float b = sin(hue);\n    vec2 gamut = approximateShape(a, b);\n    float saturation = 1. / (gamut.y / (1. - lightness) + gamut.x / lightness);\n    float colorfulness = min(chroma, saturation);\n    a *= colorfulness;\n    b *= colorfulness;\n    vec3 color = oklab_to_linear_srgb(vec3(lightness, a, b));\n    color = softClipColorOutsideGamutOnly(color);\n    color = clamp(color, 0., 1.);\n    color = Srgb3(color);\n    \n    return color;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}