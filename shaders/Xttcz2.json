{
    "Shader": {
        "info": {
            "date": "1533252118",
            "description": "Volumetric Clouds Experiment - more info: https://github.com/valentingalea/shaderbox",
            "flags": 0,
            "hasliked": 0,
            "id": "Xttcz2",
            "likes": 125,
            "name": "Volumetric Overcast Clouds",
            "published": 3,
            "tags": [
                "clouds",
                "sky",
                "volumetric",
                "atmosphere"
            ],
            "usePreview": 0,
            "username": "valentingalea",
            "viewed": 8578
        },
        "renderpass": [
            {
                "code": "//\n// Volumetric Clouds Experiment\n//\n//                 _                                  \n//               (`  ).                   _           \n//              (     ).              .:(`  )`.       \n// )           _(       '`.          :(   .    )      \n//         .=(`(      .   )     .--  `.  (    ) )      \n//        ((    (..__.:'-'   .+(   )   ` _`  ) )                 \n// `.     `(       ) )       (   .  )     (   )  ._   \n//   )      ` __.:'   )     (   (   ))     `-'.-(`  ) \n// )  )  ( )       --'       `- __.'         :(      )) \n// .-'  (_.'          .')                    `(    )  ))\n//                   (_  )                     ` __.:'          \n//                                         \n// --..,___.--,--'`,---..-.--+--.,,-,,..._.--..-._.-a:f--.\n//\n// A mashup of ideas from different sources:\n// * Magnus Wrenninge - Production Volume Rendering \n//\t http://magnuswrenninge.com/productionvolumerendering\n// * Andrew Schneider - The Real-time Volumetric Cloudscapes of Horizon: Zero Dawn\n//   http://advances.realtimerendering.com/s2015/The%20Real-time%20Volumetric%20Cloudscapes%20of%20Horizon%20-%20Zero%20Dawn%20-%20ARTR.pdf\n// * Scratchapixel - Simulating the Colors of the Sky\n//   https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky\n// * Ian McEwan, Ashima Arts - Array and textureless GLSL 2D/3D/4D simplex \n//   https://github.com/ashima/webgl-noise\n// * and of course lots of iteration and tweaking\n//   https://github.com/valentingalea/shaderbox\n//\t\n#define SHADERTOY\n\n#ifdef __cplusplus\n#define _in(T) const T &\n#define _inout(T) T &\n#define _out(T) T &\n#define _begin(type) type {\n#define _end }\n#define _mutable(T) T\n#define _constant(T) const T\n#define mul(a, b) (a) * (b)\n#endif\n\n#if defined(GL_ES) || defined(GL_SHADING_LANGUAGE_VERSION)\n#define _in(T) const in T\n#define _inout(T) inout T\n#define _out(T) out T\n#define _begin(type) type (\n#define _end )\n#define _mutable(T) T\n#define _constant(T) const T\n#define mul(a, b) (a) * (b)\nprecision mediump float;\n#endif\n\n#ifdef HLSL\n#define _in(T) const in T\n#define _inout(T) inout T\n#define _out(T) out T\n#define _begin(type) {\n#define _end }\n#define _mutable(T) static T\n#define _constant(T) static const T\n#define vec2 float2\n#define vec3 float3\n#define vec4 float4\n#define mat2 float2x2\n#define mat3 float3x3\n#define mat4 float4x4\n#define mix lerp\n#define fract frac\n#define mod fmod\n#pragma pack_matrix(row_major)\n#endif\n\n#ifdef HLSLTOY\ncbuffer uniforms : register(b0) {\n\tfloat2 u_res;\n\tfloat u_time;\n\tfloat2 u_mouse;\n};\nvoid mainImage(_out(float4) fragColor, _in(float2) fragCoord);\nfloat4 main(float4 uv : SV_Position) : SV_Target{ float4 col; mainImage(col, uv.xy); return col; }\n#endif\n\n#if defined(__cplusplus) || defined(SHADERTOY)\n#define u_res iResolution\n#define u_time iTime\n#define u_mouse iMouse\n#endif\n\n#ifdef GLSLSANDBOX\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define u_res resolution\n#define u_time time\n#define u_mouse mouse\nvoid mainImage(_out(vec4) fragColor, _in(vec2) fragCoord);\nvoid main() { mainImage(gl_FragColor, gl_FragCoord.xy); }\n#endif\n\n#ifdef UE4\n_constant(vec2) u_res = vec2(0, 0);\n_constant(vec2) u_mouse = vec2(0, 0);\n_mutable(float) u_time = 0;\n#endif\n\n#define PI 3.14159265359\n\nstruct ray_t {\n\tvec3 origin;\n\tvec3 direction;\n};\n#define BIAS 1e-4 // small offset to avoid self-intersections\n\nstruct sphere_t {\n\tvec3 origin;\n\tfloat radius;\n\tint material;\n};\n\nstruct plane_t {\n\tvec3 direction;\n\tfloat distance;\n\tint material;\n};\n\nstruct hit_t {\n\tfloat t;\n\tint material_id;\n\tvec3 normal;\n\tvec3 origin;\n};\n#define max_dist 1e8\n_constant(hit_t) no_hit = _begin(hit_t)\n\tfloat(max_dist + 1e1), // 'infinite' distance\n\t-1, // material id\n\tvec3(0., 0., 0.), // normal\n\tvec3(0., 0., 0.) // origin\n_end;\n\n// ----------------------------------------------------------------------------\n// Various 3D utilities functions\n// ----------------------------------------------------------------------------\n\nray_t get_primary_ray(\n\t_in(vec3) cam_local_point,\n\t_inout(vec3) cam_origin,\n\t_inout(vec3) cam_look_at\n){\n\tvec3 fwd = normalize(cam_look_at - cam_origin);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 right = cross(up, fwd);\n\tup = cross(fwd, right);\n\n\tray_t r = _begin(ray_t)\n\t\tcam_origin,\n\t\tnormalize(fwd + up * cam_local_point.y + right * cam_local_point.x)\n\t_end;\n\treturn r;\n}\n\n_constant(mat3) mat3_ident = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n\n\nmat2 rotate_2d(\n\t_in(float) angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat2(_cos, -_sin, _sin, _cos);\n}\n\nmat3 rotate_around_z(\n\t_in(float) angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, -_sin, 0, _sin, _cos, 0, 0, 0, 1);\n}\n\nmat3 rotate_around_y(\n\t_in(float) angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, 0, _sin, 0, 1, 0, -_sin, 0, _cos);\n}\n\nmat3 rotate_around_x(\n\t_in(float) angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(1, 0, 0, 0, _cos, -_sin, 0, _sin, _cos);\n}\n\n// http://http.developer.nvidia.com/GPUGems3/gpugems3_ch24.html\nvec3 linear_to_srgb(\n\t_in(vec3) color\n){\n\tconst float p = 1. / 2.2;\n\treturn vec3(pow(color.r, p), pow(color.g, p), pow(color.b, p));\n}\nvec3 srgb_to_linear(\n\t_in(vec3) color\n){\n\tconst float p = 2.2;\n\treturn vec3(pow(color.r, p), pow(color.g, p), pow(color.b, p));\n}\n\n#ifdef __cplusplus\nvec3 faceforward(\n\t_in(vec3) N,\n\t_in(vec3) I,\n\t_in(vec3) Nref\n){\n\treturn dot(Nref, I) < 0 ? N : -N;\n}\n#endif\n\nfloat checkboard_pattern(\n\t_in(vec2) pos,\n\t_in(float) scale\n){\n\tvec2 pattern = floor(pos * scale);\n\treturn mod(pattern.x + pattern.y, 2.0);\n}\n\nfloat band (\n\t_in(float) start,\n\t_in(float) peak,\n\t_in(float) end,\n\t_in(float) t\n){\n\treturn\n\tsmoothstep (start, peak, t) *\n\t(1. - smoothstep (peak, end, t));\n}\n\n// from https://www.shadertoy.com/view/4sSSW3\n// original http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\nvoid fast_orthonormal_basis(\n\t_in(vec3) n,\n\t_out(vec3) f,\n\t_out(vec3) r\n){\n\tfloat a = 1. / (1. + n.z);\n\tfloat b = -n.x*n.y*a;\n\tf = vec3(1. - n.x*n.x*a, b, -n.x);\n\tr = vec3(b, 1. - n.y*n.y*a, -n.y);\n}\n\n// ----------------------------------------------------------------------------\n// Analytical surface-ray intersection routines\n// ----------------------------------------------------------------------------\n\n// geometrical solution\n// info: http://www.scratchapixel.com/old/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/\nvoid intersect_sphere(\n\t_in(ray_t) ray,\n\t_in(sphere_t) sphere,\n\t_inout(hit_t) hit\n){\n\tvec3 rc = sphere.origin - ray.origin;\n\tfloat radius2 = sphere.radius * sphere.radius;\n\tfloat tca = dot(rc, ray.direction);\n\tif (tca < 0.) return;\n\n\tfloat d2 = dot(rc, rc) - tca * tca;\n\tif (d2 > radius2) return;\n\n\tfloat thc = sqrt(radius2 - d2);\n\tfloat t0 = tca - thc;\n\tfloat t1 = tca + thc;\n\n\tif (t0 < 0.) t0 = t1;\n\tif (t0 > hit.t) return;\n\n\tvec3 impact = ray.origin + ray.direction * t0;\n\n\thit.t = t0;\n\thit.material_id = sphere.material;\n\thit.origin = impact;\n\thit.normal = (impact - sphere.origin) / sphere.radius;\n}\n\n// Plane is defined by normal N and distance to origin P0 (which is on the plane itself)\n// a plane eq is: (P - P0) dot N = 0\n// which means that any line on the plane is perpendicular to the plane normal\n// a ray eq: P = O + t*D\n// substitution and solving for t gives:\n// t = ((P0 - O) dot N) / (N dot D)\nvoid intersect_plane(\n\t_in(ray_t) ray,\n\t_in(plane_t) p,\n\t_inout(hit_t) hit\n){\n\tfloat denom = dot(p.direction, ray.direction);\n\tif (denom < 1e-6) return;\n\n\tvec3 P0 = vec3(p.distance, p.distance, p.distance);\n\tfloat t = dot(P0 - ray.origin, p.direction) / denom;\n\tif (t < 0. || t > hit.t) return;\n\t\n\thit.t = t;\n\thit.material_id = p.material;\n\thit.origin = ray.origin + ray.direction * t;\n\thit.normal = faceforward(p.direction, ray.direction, p.direction);\n}\n\n// ----------------------------------------------------------------------------\n// Volumetric utilities\n// ----------------------------------------------------------------------------\n\nfloat isotropic_phase_func(float mu)\n{\n\treturn\n\t           1.\n\t/ //-------------------\n\t        4. * PI;\n}\n\nfloat rayleigh_phase_func(float mu)\n{\n\treturn\n\t        3. * (1. + mu*mu)\n\t/ //------------------------\n\t           (16. * PI);\n}\n\nfloat henyey_greenstein_phase_func(float mu)\n{\n\t// Henyey-Greenstein phase function factor [-1, 1]\n\t// represents the average cosine of the scattered directions\n\t// 0 is isotropic scattering\n\t// > 1 is forward scattering, < 1 is backwards\n\tconst float g = 0.76;\n\n\treturn\n\t                     (1. - g*g)\n\t/ //---------------------------------------------\n\t     ((4. + PI) * pow(1. + g*g - 2.*g*mu, 1.5));\n}\n\nfloat schlick_phase_func(float mu)\n{\n\t// Schlick Phase Function factor\n\t// Pharr and  Humphreys [2004] equivalence to g from Henyey-Greenstein\n\tconst float g = 0.76;\n\tconst float k = 1.55*g - 0.55 * (g*g*g);\n\n\treturn\n\t                  (1. - k*k)\n\t/ //-------------------------------------------\n\t     (4. * PI * (1. + k*mu) * (1. + k*mu));\n}\n\nstruct volume_sampler_t {\n\tvec3 origin; // start of ray\n\tvec3 pos; // current pos of acccumulation ray\n\tfloat height;\n\n\tfloat coeff_absorb;\n\tfloat T; // transmitance\n\n\tvec3 C; // color\n\tfloat alpha;\n};\n\nvolume_sampler_t begin_volume(\n\t_in(vec3) origin,\n\t_in(float) coeff_absorb\n){\n\tvolume_sampler_t v = _begin(volume_sampler_t)\n\t\torigin, origin, 0.,\n\t\tcoeff_absorb, 1.,\n\t\tvec3(0., 0., 0.), 0.\n\t_end;\n\treturn v;\n}\n\nfloat illuminate_volume(\n\t_inout(volume_sampler_t) vol,\n\t_in(vec3) V,\n\t_in(vec3) L\n);\n\nvoid integrate_volume(\n\t_inout(volume_sampler_t) vol,\n\t_in(vec3) V,\n\t_in(vec3) L,\n\t_in(float) density,\n\t_in(float) dt\n){\n\t// change in transmittance (follows Beer-Lambert law)\n\tfloat T_i = exp(-vol.coeff_absorb * density * dt);\n\t// Update accumulated transmittance\n\tvol.T *= T_i;\n\t// integrate output radiance (here essentially color)\n\tvol.C += vol.T * illuminate_volume(vol, V, L) * density * dt;\n\t// accumulate opacity\n\tvol.alpha += (1. - T_i) * (1. - vol.alpha);\n}\n\n\n#define cld_march_steps (50)\n#define cld_coverage (.3125)\n#define cld_thick (90.)\n#define cld_absorb_coeff (1.)\n#define cld_wind_dir vec3(0, 0, -u_time * .2)\n#define cld_sun_dir normalize(vec3(0, 0/*abs(sin(u_time * .3))*/, -1))\n_mutable(float) coverage_map;\n\n// ----------------------------------------------------------------------------\n// Noise function by iq from https://www.shadertoy.com/view/4sfGzS\n// ----------------------------------------------------------------------------\n\nfloat hash(\n\t_in(float) n\n){\n\treturn fract(sin(n)*753.5453123);\n}\n\nfloat noise_iq(\n\t_in(vec3) x\n){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0 - 2.0*f);\n\n#if 1\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n#else\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+.5)/256., 0.).yx;\n\treturn mix(rg.x, rg.y, f.z);\n#endif\n}\n\n#define gnoise(x) noise_iq(x)\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0, 0, 0, 0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n#define noise(x) snoise(x)\n\n// ----------------------------------------------------------------------------\n// Fractional Brownian Motion\n// depends on custom basis function\n// ----------------------------------------------------------------------------\n\n#define DECL_FBM_FUNC(_name, _octaves, _basis) float _name(_in(vec3) pos, _in(float) lacunarity, _in(float) init_gain, _in(float) gain) { vec3 p = pos; float H = init_gain; float t = 0.; for (int i = 0; i < _octaves; i++) { t += _basis * H; p *= lacunarity; H *= gain; } return t; }\n\nDECL_FBM_FUNC(fbm, 4, noise(p))\nDECL_FBM_FUNC(fbm_clouds, 5, abs(noise(p)))\n\nvec3 render_sky_color(\n\t_in(vec3) eye_dir\n){\n\t_constant(vec3) sun_color = vec3(1., .7, .55);\n\tfloat sun_amount = max(dot(eye_dir, cld_sun_dir), 0.);\n\n\tvec3 sky = mix(vec3(.0, .1, .4), vec3(.3, .6, .8), 1.0 - eye_dir.y);\n\tsky += sun_color * min(pow(sun_amount, 1500.0) * 5.0, 1.0);\n\tsky += sun_color * min(pow(sun_amount, 10.0) * .6, 1.0);\n\n\treturn sky;\n}\n\nfloat density_func(\n\t_in(vec3) pos,\n\t_in(float) h\n){\n\tvec3 p = pos * .001 + cld_wind_dir;\n\tfloat dens = fbm_clouds(p * 2.032, 2.6434, .5, .5);\n\t\n\tdens *= smoothstep (cld_coverage, cld_coverage + .035, dens);\n\n\t//dens *= band(.2, .3, .5 + coverage_map * .5, h);\n\n\treturn dens;\n}\n\nfloat illuminate_volume(\n\t_inout(volume_sampler_t) cloud,\n\t_in(vec3) V,\n\t_in(vec3) L\n){\n\treturn exp(cloud.height) / 1.95;\n}\n\nvec4 render_clouds(\n\t_in(ray_t) eye\n){\n\tconst int steps = cld_march_steps;\n\tconst float march_step = cld_thick / float(steps);\n\n\tvec3 projection = eye.direction / eye.direction.y;\n\tvec3 iter = projection * march_step;\n\n\tfloat cutoff = dot(eye.direction, vec3(0, 1, 0));\n\n\tvolume_sampler_t cloud = begin_volume(\n\t\teye.origin + projection * 100.,\n\t\tcld_absorb_coeff);\n\n\t//coverage_map = gnoise(projection);\n\t//return vec4(coverage_map, coverage_map, coverage_map, 1);\n\n\tfor (int i = 0; i < steps; i++) {\n\t\tcloud.height = (cloud.pos.y - cloud.origin.y)\n\t\t\t/ cld_thick;\n\t\tfloat dens = density_func(cloud.pos, cloud.height);\n\n\t\tintegrate_volume(\n\t\t\tcloud,\n\t\t\teye.direction, cld_sun_dir,\n\t\t\tdens, march_step);\n\n\t\tcloud.pos += iter;\n\n\t\tif (cloud.alpha > .999) break;\n\t}\n\n\treturn vec4(cloud.C, cloud.alpha * smoothstep(.0, .2, cutoff));\n}\n\nvoid setup_camera(\n\t_inout(vec3) eye,\n\t_inout(vec3) look_at\n){\n\teye = vec3(0, 1., 0);\n\tlook_at = vec3(0, 1.6, -1);\n}\n\nvoid setup_scene()\n{\n}\n\nvec3 render(\n\t_in(ray_t) eye_ray,\n\t_in(vec3) point_cam\n){\n\tvec3 sky = render_sky_color(eye_ray.direction);\n\tif (dot(eye_ray.direction, vec3(0, 1, 0)) < 0.05) return sky;\n\n\tvec4 cld = render_clouds(eye_ray);\n\tvec3 col = mix(sky, cld.rgb, cld.a);\n\n\treturn col;\n}\n\n#define FOV 1. // 45 degrees\n// ----------------------------------------------------------------------------\n// Main Rendering function\n// depends on external defines: FOV\n// ----------------------------------------------------------------------------\n\nvoid mainImage(\n\t_out(vec4) fragColor,\n#ifdef SHADERTOY\n\tvec2 fragCoord\n#else\n\t_in(vec2) fragCoord\n#endif\n){\n\t// assuming screen width is larger than height \n\tvec2 aspect_ratio = vec2(u_res.x / u_res.y, 1);\n\n\tvec3 color = vec3(0, 0, 0);\n\n\tvec3 eye, look_at;\n\tsetup_camera(eye, look_at);\n\n\tsetup_scene();\n\n\tvec2 point_ndc = fragCoord.xy / u_res.xy;\n#ifdef HLSL\n\t\tpoint_ndc.y = 1. - point_ndc.y;\n#endif\n\tvec3 point_cam = vec3(\n\t\t(2.0 * point_ndc - 1.0) * aspect_ratio * FOV,\n\t\t-1.0);\n\n\tray_t ray = get_primary_ray(point_cam, eye, look_at);\n\n\tcolor += render(ray, point_cam);\n\n\tfragColor = vec4(linear_to_srgb(color), 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}