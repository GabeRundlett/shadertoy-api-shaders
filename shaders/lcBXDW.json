{
    "Shader": {
        "info": {
            "date": "1706317693",
            "description": "A simple framework for handling Gabor blobs.",
            "flags": 0,
            "hasliked": 0,
            "id": "lcBXDW",
            "likes": 8,
            "name": "Gabor blobs",
            "published": 3,
            "tags": [
                "ray",
                "gabor"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 229
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// A simple framework for handling Gabor blobs.\n// See https://www.shadertoy.com/view/Mf2XWz for background\n// and motivation.\n// Briefly, what I call a Gabor blob (inspired by the Gabor\n// function exp(-t^2/R^2)*exp(A*t+B), etc.) is a 3D scalar field \n// in a shape of gaussian ellipsoid, modulated by a plane wave.\n// An analytical expression for line integral in such field is\n// obtained, which allows relatively cheap computation. This can\n// be used for things like light beams and fog density. Since\n// the integrals are additive, the result is order-independent,\n// which is both strength and weakness. A Gabor basis is\n// reasonably easy to work with.\n\n//==============================================================================\n// Essential functions.\n\nconst float pi=3.14159265358979;\n\n// Approximation of exp(-Im(z)^2)*erf(z).\n// Abs. error ~0.025.\n// See https://www.shadertoy.com/view/Mf2XWz for more\n// accurate version.\nvec2 F(vec2 z)\n{\n    float x=z.x,y=z.y,x2=x*x,y2=y*y;\n    float D=3.0*y*(4.0+y2)/(12.0+y2*(11.0+6.0*y2)); // Approx. of Dawson integral.\n    float E=tanh(x*(1.129675826+x2*0.099792702));   // Approx. of erf(x), see https://www.shadertoy.com/view/ml3yWj.\n    float w=1.12837*D*exp(-x2)/sqrt(1.0+0.363*x2);\n    float a=(1.0-0.590/(1.0+0.119*x2+0.538*y2))*2.0*x*y;\n    return vec2(E*exp(-y2)+w*sin(a),w*cos(a));\n}\n\n// ∫ exp(-P^2*t^2-Q*t-R)*cos(A*t+B) dt on (-∞;+∞).\nfloat K(float P,float Q,float R,float A,float B)\n{\n    return sqrt(pi)*cos(0.5*A*Q/(P*P)-B)*exp(-R+(Q*Q-A*A)/(4.0*P*P))/P;\n}\n\n// ∫ exp(-P^2*t^2-Q*t-R)*cos(A*t+B) dt on [L;H].\nfloat I(float P,float Q,float R,float A,float B,float L,float H)\n{\n    float X=0.5*Q/P;\n    float Y=0.5*A/P;\n    float Z=2.0*X*Y-B;\n    vec2 Fl=F(vec2(P*L+X,Y));\n    vec2 Fh=F(vec2(P*H+X,Y));\n    return (0.5*sqrt(pi)/P)*exp(X*X-R)*dot(vec2(cos(Z),-sin(Z)),Fh-Fl);\n}\n\n//==============================================================================\n// Data and functions for Gabor blobs.\n\n// A structure that describes a Gabor blob,\n// which defines a scalar field, with value\n// at point r being\n//     A*exp(-transpose(r-c)*M*(r-c))*cos(dot(k,r-c)+P)\n// NOTE: M is required to be positive semi-definite,\n// but is not required to by symmetric, though you might\n// just as well symmetrize it, seeing as (M+transpose(M))/2\n// defines the same field.\n// Examples:\n//   1. mat3(X,0,0,\n//           0,Y,0,\n//           0,0,Z)\n//      describes an axis-aligned ellipsoid with radii sqrt(1/X), sqrt(1/Y), sqrt(1/Z).\n//   2. mat3(D,0,0,\n//           0,D,0,\n//           0,0,0)\n//      describes a beam of radius sqrt(1/D) along z axis.\n//   3. mat3(0,0,0,\n//           0,0,0\n//           0,0,D)\n//      describes an xy plane of thickness sqrt(1/D).\n// All of these are valid values.\nstruct Blob\n{\n    float A; // Amplitude.\n    vec3  c; // Center.\n    mat3  M; // Quadratic form.\n    vec3  k; // Wave vector.\n    float P; // Phase offset.\n};\n\n// Evaluate blob's field at point r.\nfloat BlobG(Blob b,vec3 r)\n{\n    return b.A*exp(-dot((r-b.c)*b.M,r-b.c))*cos(dot(b.k,r-b.c)+b.P);\n}\n\n// Calculate derivative of blob's field at point r.\nvec3 BlobD(Blob b,vec3 r)\n{\n    return -b.A*exp(-dot((r-b.c)*b.M,r-b.c))*(\n        (b.M+transpose(b.M))*(r-b.c)*cos(dot(b.k,r-b.c)+b.P)\n        +b.k*sin(dot(b.k,r-b.c)+b.P));\n}\n\n// Integrate blob's field along the\n// ray ro+t*rd, on (-∞;+∞).\nfloat BlobK(Blob b,vec3 ro,vec3 rd)\n{\n    return b.A*K(\n        sqrt(dot((rd*b.M),rd)),\n        (dot((ro-b.c)*b.M,rd)+dot(rd*b.M,ro-b.c)),\n        dot((ro-b.c)*b.M,ro-b.c),\n        dot(b.k,rd),\n        dot(b.k,ro-b.c)+b.P);\n}\n\n// Integrate blob's field along the\n// ray ro+t*rd, on [L,H].\nfloat BlobI(Blob b,vec3 ro,vec3 rd,float L,float H)\n{\n    return b.A*I(\n        sqrt(dot((rd*b.M),rd)),\n        (dot((ro-b.c)*b.M,rd)+dot(rd*b.M,ro-b.c)),\n        dot((ro-b.c)*b.M,ro-b.c),\n        dot(b.k,rd),\n        dot(b.k,ro-b.c)+b.P,\n        L,H);\n}\n\n// Expressions for product of 2 blobs.\n// Handy for (Blob(...))^2, producing\n// a non-negative field.\n\nfloat BlobProductG(Blob f,Blob g,vec3 r)\n{\n    return BlobG(f,r)*BlobG(g,r);\n}\n\nfloat BlobProductK(Blob f,Blob g,vec3 ro,vec3 rd)\n{\n    float P=sqrt(dot((rd*f.M),rd)+dot((rd*g.M),rd));\n    float Q=\n        (dot((ro-f.c)*f.M,rd)+dot(rd*f.M,ro-f.c))+\n        (dot((ro-g.c)*g.M,rd)+dot(rd*g.M,ro-g.c));\n    float R=dot((ro-f.c)*f.M,ro-f.c)+dot((ro-g.c)*g.M,ro-g.c);\n    float Am=dot(f.k-g.k,rd),Ap=dot(f.k+g.k,rd);\n    float Bm=(dot(f.k,ro-f.c)+f.P)-(dot(g.k,ro-g.c)+g.P);\n    float Bp=(dot(f.k,ro-f.c)+f.P)+(dot(g.k,ro-g.c)+g.P);\n    return 0.5*f.A*g.A*(K(P,Q,R,Am,Bm)+K(P,Q,R,Ap,Bp));\n}\n\nfloat BlobProductI(Blob f,Blob g,vec3 ro,vec3 rd,float L,float H)\n{\n    float P=sqrt(dot((rd*f.M),rd)+dot((rd*g.M),rd));\n    float Q=\n        (dot((ro-f.c)*f.M,rd)+dot(rd*f.M,ro-f.c))+\n        (dot((ro-g.c)*g.M,rd)+dot(rd*g.M,ro-g.c));\n    float R=dot((ro-f.c)*f.M,ro-f.c)+dot((ro-g.c)*g.M,ro-g.c);\n    float Am=dot(f.k-g.k,rd),Ap=dot(f.k+g.k,rd);\n    float Bm=(dot(f.k,ro-f.c)+f.P)-(dot(g.k,ro-g.c)+g.P);\n    float Bp=(dot(f.k,ro-f.c)+f.P)+(dot(g.k,ro-g.c)+g.P);\n    return 0.5*f.A*g.A*(I(P,Q,R,Am,Bm,L,H)+I(P,Q,R,Ap,Bp,L,H));\n}\n\nBlob Blob_translate(Blob b,vec3 r)\n{\n    return Blob(b.A,b.c+r,b.M,b.k,dot(b.k,r)+b.P);\n    \n}\n\nBlob Blob_rotate(Blob b,mat3 R)\n{\n    return Blob(b.A,b.c,transpose(R)*b.M*R,transpose(R)*b.k,b.P);\n}\n\n//==============================================================================\n// Terrain texture.\n\nfloat rnd(vec2 v) {return sin(dot(sin(v*vec2(13.7,37.1)),1.0+71.3*v.yx));}\n\nfloat vnoise(vec2 v)\n{\n    vec2 i=vec2(floor(v)),e=vec2(0,1);\n    v=smoothstep(0.0,1.0,v-i);\n    return mix(\n        mix(rnd(i+e.xx),rnd(i+e.yx),v.x),\n        mix(rnd(i+e.xy),rnd(i+e.yy),v.x),v.y);\n}\n\nfloat fbm(vec2 v)\n{\n    float ret=0.0,w=2.0;\n    for(int i=0;i<5;++i) ret+=(w*=0.5)*vnoise(v*=mat2(1.6,1.2,-1.2,1.6));\n    return ret;\n}\n\n//==============================================================================\n// Main image.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy=(2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tfloat a=0.25*iTime;\n    vec3 col=vec3(0.25,0.5,0.75);\n    // Camera setup.\n    // +x=East, +y=North, +z=Up.\n\tvec3 ro=vec3(7.0*cos(a)+sin(1.3*a),8.0*sin(0.7*a),3.5*sin(a)+cos(1.3*a)+5.0);\n    vec3 ta=vec3(0.0,0.0,0.0);\n    vec3 ww=normalize(ta-ro);\n    vec3 uu=normalize(cross(ww,vec3(0.0,0.0,1.0)));\n    vec3 vv=normalize(cross(uu,ww));\n\tvec3 rd=normalize(xy.x*uu+xy.y*vv+1.5*ww);\n    // Blobs.\n    // b0,b1 is stripey green beam.\n    // We express non-negative 1+cos(...) field as 2 blobs.\n    // NOTE: or you can use BlobProduct for (cos(...))^2 instead.\n    Blob b0=Blob(1.0,vec3(0),mat3(0.4,0,0,0,0.4,0,0,0,0.0),vec3(0),0.0);\n    Blob b1=Blob(1.0,vec3(0),mat3(0.4,0,0,0,0.4,0,0,0,0.0),vec3(2),0.1*iTime);\n    // b2,b3 is a spinning red donut.\n    Blob b2=Blob(+4.0,vec3(5,5,2),mat3(0.2,0,0,0,0.2,0,0,0,1.0),vec3(0),0.0);\n    Blob b3=Blob(-4.0,vec3(5,5,2),mat3(1.0,0,0,0,1.0,0,0,0,1.0),vec3(0),0.0);\n    // b4,b5 is blue skyward pipe.\n    Blob b4=Blob(+50.0,vec3(-5,5,1),mat3(0.49,0,0,0,0.0,0,0,0,0.49),vec3(0,0,0),0.0);\n    Blob b5=Blob(-50.0,vec3(-5,5,1),mat3(0.50,0,0,0,0.0,0,0,0,0.50),vec3(0,0,0),0.0);\n    if(true)\n    {\n        float c=cos(iTime),s=sin(iTime);\n        b2=Blob_rotate(b2,mat3(c,0,s,0,1,0,-s,0,c));\n        b3=Blob_rotate(b3,mat3(c,0,s,0,1,0,-s,0,c));\n        c=cos(0.1);s=sin(0.1);\n        b4=Blob_rotate(b4,mat3(1,0,0,0,c,s,0,-s,c));\n        b5=Blob_rotate(b5,mat3(1,0,0,0,c,s,0,-s,c));\n    }\n    // Ray-ground intersection.\n    float t=-ro.z/rd.z;\n    if(t>0.0)\n    {\n        vec3 v=ro+t*rd;\n        col=mix(col,vec3(0.8,0.4,0.2)*(0.5+0.25*exp(-length(v-ro)/32.0)*fbm(v.xy)),exp(-length(v-ro)/512.0));\n        col*=(1.0+5.0*vec3(0.2,0.7,0.2)*(BlobG(b0,v)+BlobG(b1,v)));\n    }\n    else t=1e7;\n    col+=vec3(0.2,0.7,0.2)*(BlobI(b0,ro,rd,0.0,t)+BlobI(b1,ro,rd,0.0,t));\n    col+=vec3(0.7,0.2,0.2)*(BlobI(b2,ro,rd,0.0,t)+BlobI(b3,ro,rd,0.0,t));\n    col+=vec3(0.0,0.2,0.7)*(BlobI(b4,ro,rd,0.0,t)+BlobI(b5,ro,rd,0.0,t));\n    col.xyz=mix(12.92*col.xyz,1.055*pow(col.xyz,vec3(1.0/2.4))-0.055,step(0.0031308,col.xyz)); // sRGB\n\tfragColor=vec4(col.xyz,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}