{
    "Shader": {
        "info": {
            "date": "1656691738",
            "description": "Fork of [url]https://www.shadertoy.com/view/7dyyWm[\\url].\nThe three possible variations of the 3-mirror kaleidoscope - see code comments. \nBrightness is attenuated by the number of reflections. \nUse mouse to manually scroll the texture.",
            "flags": 0,
            "hasliked": 0,
            "id": "sdKyWG",
            "likes": 17,
            "name": "kaleidoscope variations 2",
            "published": 3,
            "tags": [
                "reflection",
                "interactive",
                "folding",
                "kaleidoscope",
                "tiling",
                "symmetry"
            ],
            "usePreview": 1,
            "username": "hnh",
            "viewed": 487
        },
        "renderpass": [
            {
                "code": "\n// The three possible variations of the 3-mirror kaleidoscope [1,2].\n// The image is composed by reflections of a base triangle, tiling the plane.\n// Here, I adopted the folding scheme [3,4] for the Euclidean plane whereas\n// in general it also works for the spherical and hyperbolic case. \n// A similar example with good comments is also found in [5]. \n// You may also try using the webcam in iChannel0\n// (don't forget setting Filter->mipmap and Wrap->repeat).\n// Note: lines marked by '//o' are comment-switchable (optional).\n// '//p' indicates parameters for manual tuning.\n// Shadertoy plugin: use Alt + R/L arrows to switch modes\n//\n// See also https://www.shadertoy.com/view/ssyyRG for a visualization of the folding scheme.\n//\n// [1] https://en.wikipedia.org/wiki/Kaleidoscope#Different_versions_suggested_by_Brewster\n// [2] https://en.wikipedia.org/wiki/Triangle_group\n// [3] mla, Wythoffian Tiling Generator, https://shadertoy.com/view/wlGSWc\n// [4] knighty, Tilings, https://www.shadertoy.com/view/4sf3zX\n// [5] TotallyReal, Euclidean triangle groups, https://www.shadertoy.com/view/7lV3Wy\n// [6] Artleet, The most compact hueshift, https://www.shadertoy.com/view/3tjGWm\n// [7] https://de.wikipedia.org/wiki/Datei:Kaleidoscope-abc.jpg\n\n#define C .03  // emphasize parent tile\n#define H 1.  // hold between transitions\n\n#define PI 3.14159265\n#define R iResolution\n\n// The angles are defined by divisors of PI in each row (1st row: classical kaleidoscope, [1]).\n// In the Euclidean plane their inverses must sum to one.\nconst mat3 D = mat3(\n    3,3,3,\n    2,4,4,\n    2,3,6);\n\nvec3 hs(vec3 c, float s) {  // hue shift [6]\n    vec3 m = vec3(cos(s), s=sin(s)*.5774, -s);\n    return c*mat3(m+=(1.-m.x)/3., m.zxy, m.yzx);\n}\n\n// Iterative folding/reflection adopted from [3,4] and streamlined for the Euclidean case.\n// The fold count (nf) can be useful, e.g. to attenuate reflections as in a real kaleidoscope [7].\nvec4 fold(vec2 p, float sc, vec3 ang, out int nf) {\n    vec3 c = cos(ang), s = sin(ang);\n    mat3 N = mat3(1, 0, C,\n                 -c.x, s.x, 0,\n                 -c.z, -(c.y+c.x*c.z)/s.x, 1);  // normals\n    sc *= s.z;  // set longest edge to unit length\n    vec3 u, q = vec3(p,sc);\n    nf = 0;  // fold counter\n    for(int i=0; i<9999; i++) {\n        for(int j=0; j<3; j++) {\n            u[j] = dot(q, N[j]);\n            if(u[j] < 0.) {q -= 2.*u[j]*N[j]*vec3(1,1,0); nf++;}\n        }\n        if(i >= nf) break;  // base triangle is reached\n    }\n    return vec4(q.xy, u.yz);  // q.xy: cartesian coords, u.xyz: trilinear coords, note that u.x = q.x\n}\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    const float sc = 5.;  //p scale\n    float t = iTime*.2;  //p global speed\n        \n    int m = 2, mm = m;  //p reflection mode (0,1,2)\n    m = int(t)%3, mm = int(t+1.)%3;  //o cycle modes\n    //m = int(U.x*3./R.x); mm = m;  //o simultaneous view    \n        \n    U = sc*(U*2. - R.xy)/R.y;\n        \n    int nf;    \n    float f = smoothstep(0.,1.,mod(t,1.)*(H+1.)-H);  // blending\n    O = fold(U, 1., mix(PI/D[m],PI/D[mm],f), nf);\n    U = O.xy;\n    vec3 u = O.xzw;\n        \n    if(iMouse.z>0.) U -= (iMouse.xy*2.-R.xy)/R.y;\n    else U -= t*.5; //o auto-scroll\n    //U += vec2(nf)*.01;  //o reflection shift\n    O = texture(iChannel0,U);\n    O.rgb = hs((O.bgr-.25)*2., PI*(1.-.5*mix(float(m),float(mm),f)));  //o color modes\n    //O = vec4(1);  //o monochrome background\n    \n    O *= exp(-float(nf)/sc*.4)*1.5;  //o attenuate reflections\n    //O *= .6 + .4*float(nf%2);  //o 'checkerboard'\n    //O *= .9 + .15*(dFdx(U.x)-.3*dFdy(U.x))/sc*R.y;  //o relief (cheap)\n    O *= smoothstep(-1.,1.,(min(u.x,min(u.y,u.z))-.01)*R.y/(sc*2.));  //o edges\n    \n    O.a= 1.;  // who knows...\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}