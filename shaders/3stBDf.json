{
    "Shader": {
        "info": {
            "date": "1607544452",
            "description": "Attempting to combine a couple of different scenes from 'The Shining' movie (or Ready Player One, if you prefer...)\nMain goals were to keep the frame rate up (even when anti-aliased), and the code small (but readable!).\nOh - And to have fun, obv.  :)",
            "flags": 0,
            "hasliked": 0,
            "id": "3stBDf",
            "likes": 30,
            "name": "The Shining",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "horror",
                "movie",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "dean_the_coder",
            "viewed": 13184
        },
        "renderpass": [
            {
                "code": "// The Shining\n//\n// Attempting to combine a couple of different scenes from 'The Shining'\n// movie (or Ready Player One, if you prefer...)\n// Main goals were to keep the frame rate up (even when anti-aliased),\n// and the code small (but readable!).\n// Oh - And to have fun, obv.  :)\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat g, time,\n\t  opn; // Door open-ness\n\n#define AA  // Comment-out to improve frame rate.\n\nstruct Hit {\n\tfloat d;\n\tint id;\n};\n\n#define ax(p) vec3(abs(p.x), p.yz)\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 0)); }\n\nfloat n11(float n) {\n\tfloat flr = floor(n);\n\tn = fract(n);\n\tvec2 r = fract(sin(vec2(flr, flr + 1.) * 12.3456) * 43758.5453);\n\treturn mix(r.x, r.y, n * n * (3. - 2. * n));\n}\n\nHit minH(Hit a, Hit b) {\n\tif (a.d < b.d) return a;\n\treturn b;\n}\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat sdHex(vec2 p, float r)\n{\n\tp = abs(p);\n\treturn -step(max(dot(p, normalize(vec2(1, 1.73))), p.x), r);\n}\n\nfloat sdSph(vec3 p, float r) { return length(p) - r; }\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max2(q.yz)), 0.);\n}\n\nfloat sdCyl(vec3 p, float h, float r) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n\treturn min(max2(d), 0.) + length(max(d, 0.));\n}\n\nfloat sdCoving(vec3 p) {\n\tp.y -= .02;\n\treturn max(sdBox(p, vec3(.04, .04, 15)), .07 - length(p.xy + .042));\n}\n\nfloat sdBin(vec3 p) {\n\tp -= vec3(.82, -.8, 5.2);\n\treturn max(abs(sdCyl(p, .06, .25)) - .002, .05 - length(p.xy + vec2(.07, -.15)));\n}\n\nvec3 getRayDir(vec3 ro, vec2 uv) {\n\tvec3 f = normalize(vec3(0, -.25, 66) - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvoid splat(vec2 p, out float i, out float o) {\n\ti = max(0., -sign(sdHex(p, 1.)));\n\to = max(0., sign(sdHex(p, 2.)) - sign(sdHex(p, 3.)));\n}\n\n// Carpet texture.\nvec3 carpet(vec2 p) {\n\tp.x = mod(p.x, 7.) - 3.5;\n\tp.y = mod(p.y, 10.) - 10.;\n\n\tfloat i, o, i2, o2,\n\tc = (1. - step(.5, abs(p.x))) * (1. - step(2., abs(p.y)));\n\n\tp.x = abs(p.x) - 3.5;\n\n\tc += (1. - step(.5, abs(p.x))) * (1. - step(2., abs(p.y + 2.)));\n\n\tvec2 op = p;\n\n\tp.y = abs(p.y + 5.) - 5.;\n\tsplat(p, i2, o2);\n\n\top.x = mod(p.x, 7.) - 3.5;\n\top.y += 3.8;\n\tsplat(op, i, o);\n\n\ti = sign(i + i2);\n\to = sign(o + o2) * (1. - c);\n\n\treturn vec3(1, .01, .01) * i +\n\t\t   vec3(1, .1, .01) * o +\n\t\t   vec3(.05, .01, .01) * (1. - i - o);\n}\n\nvec3 wood(vec3 p) {\n\treturn mix(vec3(.17, .1, .05), vec3(.08, .05, .03), vec3(n11(n31(p * vec3(1, 2, 50)) * 30.)));\n}\n\nHit sdBlood(vec3 p) {\n\tif (opn < .01)\n\t\treturn Hit(1e7, 1); // Door not open => No blood required.\n\n\tp.y += 5.4;\n\tp.z -= 12.8 - opn * 7.;\n\n\tfloat a = atan(p.y, p.z) * 40.,\n\t\t  bmp = (n21(2.02 * vec2(a - time * 4., p.x * 5.)) + n21(vec2(a - time * 8., p.x))) / 20.;\n\n\treturn Hit(\n\t\tmin(\n\t\tsdSph(p, 5.) + sin(time * 2. + p.z) * .07 - // Main blood pile (Sphere)\n\t\tsmoothstep(0., 1., max(0., cos((p.x + .5) * 4.) * .3 * (1. + p.z * .18))) // Bulge out of the door gap.\n\t\t- bmp, // Surface bumps.\n\t\tmax(length(p.xz) - mix(2.9, 10., opn), p.y - 4.4 - bmp * .6)), // Blood disc near floor.\n\t\t9); // Blood ID.\n}\n\n// Map the scene using SDF functions, minus blood.\nHit mapq(vec3 p) {\n\tHit h = Hit(-sdBox(p, vec3(.9, 1, 9.6)), 1); // Corridor.\n\n\tfloat nb, dr, el, wd, bn = sdBin(p), shf, dkwd;\n\n\tvec3 op = p;\n\tconst vec3 ws = vec3(.1, .7, .4); // Door size.\n\tp.x = abs(p.x) - .9;\n\tp.y += .96;\n\tp.z = mod(p.z - 3.5, 4.) - 2.;\n\twd = sdBox(p, vec3(.01, .04, 66.6)); // Skirting.\n\th.d = min(h.d, min(bn, sdBox(p, vec3(.05, 66.6, .08)))); // Pillars.\n\tp.y -= 1.9;\n\th.d = min(h.d, sdBox(p, vec3(1, .1, .08))); // Arches.\n\n\t// Coving.\n\tp.x += .04;\n\tp.z += .12;\n\th.d = min(h.d, min(sdCoving(p), sdCoving(p.zyx)));\n\n\t// Room doors.\n\tp = op;\n\tp.y += .3;\n\tp.z = mod(clamp(p.z, 0., 9.) + .5, 2.) - 1.;\n\th.d = max(min(h.d, wd), -sdBox(p, vec3(66.6, .7, .4))); // Doorway.\n\tp.x = abs(p.x) - 1.07;\n\tdr = sdBox(p, ws); // Door.\n\tnb = sdSph(p + vec3(.12, .04, -.28), .03); // Knob.\n\n\t// Elevator.\n\tp = op;\n\tp.y += .3;\n\tp.z -= 9.68;\n\tshf = sdBox(p - vec3(0, 0, .3), vec3(.5, .7, .5)) - .001; // Shaft.\n\tdkwd = min(sdBox(p - vec3(0, .8, 0), vec3(.7, .1, .1)),\n\t\t\t   sdBox(ax(p) - vec3(.6, 0, 0), vec3(.1, .7, .1))); // Mantle\n\tvec2 sl = vec2(opn - .09, 0);\n\tel = sdBox(p - vec3(sl, .1), ws.zyx) + n21((p.xy - sl) * 100.) * .001; // Sliding door.\n\tp.x -= .5;\n\tp.z -= .05;\n\tel = min(el, sdBox(p, ws.zyx) + n21(p.xy * 100.) * .001); // Fixed door.\n\th.d = min(max(h.d, -shf), dkwd);\n\tshf = max(abs(shf), -p.z);\n\n\t// Assign materials.\n\th.d = min(h.d, min(min(min(dr, el), nb), shf));\n\tif (abs(op.y + 1.) < .002) h.id = 2; // Carpet.\n\telse if (h.d == min(wd, dr)) h.id = 3; // Wood.\n\telse if (h.d == nb) h.id = 4; // Gold.\n\telse if (h.d == bn) h.id = 5; // Bin.\n\telse if (h.d == el) h.id = 6; // Elevator.\n\telse if (h.d == shf) h.id = 7; // Elevator shaft.\n\telse if (h.d == dkwd) h.id = 8; // Dark wood - Elevator top.\n\n\treturn h;\n}\n\n// Map the scene using SDF functions, with blood.\nHit map(vec3 p) {\n\treturn minH(mapq(p), sdBlood(p));\n}\n\n// Get normal for scene, excluding blood.\nvec3 calcN(vec3 p) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * mapq(p + e * .25).d;\n\t}\n\n\treturn normalize(n);\n}\n\n// Get normal for blood.\nvec3 calcNb(vec3 p) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdBlood(p + e * .25).d;\n\t}\n\n\treturn normalize(n);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n\treturn map(p + h * n).d / h;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .5);\n\treturn c;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, Hit h) {\n\tvec3 n, col = vec3(1), sunDir;\n\tfloat sp = .4; // Specular.\n\n\t// Apply material properties.\n\tif (h.id == 9) {\n\t\tcol = vec3(.25, .003, .003) * .4;\n\t\tn = calcNb(p);\n\t\tsp = 1.;\n\n\t\tcol += pow(max(0., normalize(reflect(rd, n)).y), 100.) * .2;\n\t\tcol *= .2 + .8 * sdBlood(p + normalize(vec3(0, .5, 8) - p) * .08).d / .08;\n\t} else n = calcN(p);\n\n\tif (h.id == 1)\n\t\tn += (n21(p.yz * vec2(8, 18)) - .5) * .015; // Walls (with bump)\n\telse if (h.id == 2) {\n\t\t// Carpet.\n\t\tcol = carpet(p.xz * 10.);\n\t\tn += .2 * n21(mod(p.xz * 106.78, 200.)) - .25;\n        sp *= 0.1;\n\t} else if (h.id == 3)\n\t\t// Wood.\n\t\tcol = wood(p);\n\telse if (h.id == 4)\n\t\t// Gold\n\t\tcol = vec3(.5, .4, .2), sp = .8;\n\telse if (h.id == 5) {\n\t\t// Bin\n\t\tcol = vec3(.06, .03, .03);\n\t\tn += n21(p.xz * vec2(90, 180));\n\t} else if (h.id == 6)\n\t\t// Elevator.\n\t\tcol = vec3(.15, .001, .001);\n\telse if (h.id == 7)\n\t\t// Elevator shaft.\n\t\tcol = vec3(.01);\n\telse if (h.id == 8)\n\t\t// Dark wood.\n\t\tcol = wood(p * vec3(1, 20, 1)) * .05;\n\n\tfloat ao = .4 + (ao(p, n, .035) + ao(p, n, .5)) * .6, l = 0., spe = 0.;\n\n\tfor (float i = .0; i < 3.; i++) {\n\t\tl += max(0., dot(sunDir = normalize(vec3(0, .5, i * 4.) - p), n)) / (1. + dot(vec3(0, .5, i * 4.) - p, vec3(0, .5, i * 4.) - p)) * 1.5;\n\t\tspe += smoothstep(0., 1., pow(max(0., dot(rd, reflect(sunDir, n))), 90.)) * sp;\n\t}\n    \n    return col * (l * ao + spe) * vec3(2, 1.8, 1.7);\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p;\n\n\tfloat d = .01;\n\tHit h;\n\tfor (float i = .0; i < 120.; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\n\t\t// Ceiling lights.\n\t\tfor (float i = .0; i < 3.; i++) {\n\t\t\tfloat l = sdSph(p - vec3(0, 1., i * 4.), .1);\n\t\t\tg += .05 / (.01 + l * l);\n\t\t}\n\n\t\tif (h.d < .0015)\n\t\t\tbreak;\n\n\t\td += h.d;\n\t}\n\n\t// Lighting.\n\treturn applyLighting(p, rd, h) *\n\t\texp(-d * .14) + // Fog.\n\t\tg * .004; // Glow around lights.\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\ttime = mod(iTime, 30.);\n\n\t// Camera.\n\tvec3 ro = vec3(0, -.5, .35);\n\tfloat t = min(min(min(iTime, abs(time - 3.)), abs(time - 6.)), abs(time - 30.)),\n\t\t  dim = 1. - pow(abs(cos(clamp(t, -1., 1.) * 1.57)), 10.);\n\n\tif (time < 3.) ro.z = time * .3;\n\telse if (time < 6.) ro.z = 2. + time * .3;\n\telse ro.z = mix(7., 7.8, smoothstep(-1., 3., time - 6.));\n\tif (time > 13.) ro.z -= smoothstep(13., 17., time) * 3.;\n\n\topn = smoothstep(0., 1., (time - 8.8) * .2) * .45;\n\n\tvec3 col = vec3(0);\n#ifdef AA\n\tfor (float dx = .0; dx <= 1.; dx++) {\n\t\tfor (float dy = .0; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fc + vec2(dx, dy) * .5 - .5 * iResolution.xy) / iResolution.y;\n#else\n\t\t\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n#endif\n\n\t\t\tcol += march(ro, getRayDir(ro, uv));\n#ifdef AA\n\t\t}\n\t}\n\tcol /= 4.;\n#endif\n\n\t// Output to screen.\n\tfragColor = vec4(vignette(pow(col * dim, vec3(.45)), fc), 0.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}