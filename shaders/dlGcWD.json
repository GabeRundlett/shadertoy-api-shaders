{
    "Shader": {
        "info": {
            "date": "1715983642",
            "description": "The Pappus configuration, on a flat torus in four dimensional space, stereographically projected.",
            "flags": 16,
            "hasliked": 0,
            "id": "dlGcWD",
            "likes": 20,
            "name": "Pappus on a Torus",
            "published": 3,
            "tags": [
                "torus",
                "pappus"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 175
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Pappus on a Torus, mla, 2024.\n//\n// I think the idea is from Coxeter.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nbool dorotate = false;  // Autorotate scene\nbool doclifford = true; // Do Clifford translation\n\nfloat eyedist = 5.0;     // Distance of eye from origin\nvec3 light = vec3(0,2,1); // Light direction\nint numsteps = 200;       // Maximum raymarching steps\nfloat precis = 1e-3;      // Raymarching precision\nfloat lfactor = 0.2;      // \"Lipschitz\" factor (note new fudge calculation in march())\nfloat eradius = 0.05;    // Radius of edge\nfloat pradius = 0.15;     // Radius of point\n\n// Auxiliary functions\nvec4 stereographic(vec3 p3, inout float scale); // Stereographic projection\nvec4 qmul(vec4 p, vec4 q); // Quaternion multiplication\n\n// Distance of point p from the circle through P,Q,R. This is for\n// 4 dimensional space, but the calculation is much the same as\n// in 3 dimensions. It's not impossible that this can be optimized a little.\nfloat circle(vec4 p, vec4 P, vec4 Q, vec4 R) {\n  p -= R; P -= R; Q -= R; // Rebase at R\n  float PP = dot(P,P), PQ = dot(P,Q), QQ = dot(Q,Q);\n  // Project p onto P,Q plane\n  // p' = aP + bQ = (P,Q)(a,b)\n  // p'.P = (aP.P+bQ.P)\n  // p'.Q = (aP.Q+bQ.Q)\n  // Use this matrix both for mapping p onto PQ plane\n  // and for determining the circle centre\n  mat2 m = inverse(mat2(PP,PQ,PQ,QQ));\n  vec2 ab = m*vec2(dot(p,P),dot(p,Q)); // Or use Cramer here?\n  vec4 p1 = mat2x4(P,Q)*ab;\n  vec4 centre = 0.5*mat2x4(P,Q)*m*vec2(PP,QQ);\n  float radius = distance(centre,P);\n  // Now find closest point to p1 on circle\n  p1 -= centre;\n  p1 *= radius/length(p1);\n  p1 += centre;\n  return distance(p,p1);\n}\n\nvec4 points(int i) {\n  const float a = TWOPI/3.0;\n  const vec4 POINTS[] =\n    vec4[](\n         normalize(vec4(cos(-a),sin(-a),cos(-a),sin(-a))),\n         normalize(vec4(cos(-a),sin(-a),1,0)),\n         normalize(vec4(cos(-a),sin(-a),cos(a),sin(a))),\n         normalize(vec4(1,0,cos(-a),sin(-a))),\n         normalize(vec4(1,0,1,0)),\n         normalize(vec4(1,0,cos(a),sin(a))),\n         normalize(vec4(cos(a),sin(a),cos(-a),sin(-a))),\n         normalize(vec4(cos(a),sin(a),1,0)),\n         normalize(vec4(cos(a),sin(a),cos(a),sin(a)))\n         );\n  return POINTS[i];\n}\n\nfloat de(vec3 p3, out int type) {\n  float scale = 1.0;\n  float t = 0.1*iTime;\n  vec4 p = stereographic(p3,scale);\n\n  if (doclifford) {\n    float t = 0.25*iTime;\n    vec4 Q = vec4(-sin(t)*vec3(0,0,1),cos(t));\n    p = qmul(Q,p);\n  }\n  \n  float d = 1e8,d0 = d;\n  for (int i = 0; i < 9; i++) {\n    vec4 P = points(i);\n    d = min(d,distance(p,P)-pradius);\n  }\n  if (d < d0) type = 1;\n  d0 = d;\n    d = min(d,circle(p,points(0),points(1),points(2))-eradius);\n    d = min(d,circle(p,points(3),points(4),points(5))-eradius);\n    d = min(d,circle(p,points(6),points(7),points(8))-eradius);\n    if (d < d0) { type = 2; d0 = d; }\n\n    d = min(d,circle(p,points(0),points(3),points(6))-eradius);\n    d = min(d,circle(p,points(1),points(4),points(7))-eradius);\n    d = min(d,circle(p,points(2),points(5),points(8))-eradius);\n    if (d < d0) { type = 3; d0 = d; }\n\n    d = min(d,circle(p,points(0),points(4),points(8))-eradius);\n    d = min(d,circle(p,points(1),points(5),points(6))-eradius);\n    d = min(d,circle(p,points(2),points(3),points(7))-eradius);\n    if (d < d0) { type = 4; d0 = d; }\n\n  // Finally return the distance, but taking into account the\n  // scaling factor from the stereographic projection.\n  return d/scale;\n}\n\nfloat de(vec3 p) { int t; return de(p,t); }\n\nfloat march(vec3 q, vec3 r) {\n  float a = TWOPI/3.0;\n  float t = 0.01; // Total distance so far.\n  float maxdist = eyedist + 10.0;\n  for (int i = 0; i < numsteps; i++) {\n    //assert(i < 20);\n    vec3 p = q+t*r;\n    float d = de(p);\n    if (abs(d) < t*precis) return t;\n    t += d/(1.0+lfactor*d);\n    if (t < 0.0 || t > maxdist) break;\n  }\n  return -1.0;\n}\n\n// Get the normal of the surface at point p.\nvec3 getnormal(vec3 p, float t) {\n  float eps = 1e-3;\n  vec2 e = vec2(eps,0);\n  return normalize(vec3(de(p + e.xyy) - de(p - e.xyy),\n                        de(p + e.yxy) - de(p - e.yxy),\n                        de(p + e.yyx) - de(p - e.yyx)));\n}\n\nvec4 invert(vec4 p, vec4 q, float r2, inout float scale) {\n  // Invert p in circle, centre q, radius square r2.\n  // Return inverted point and multiply scale by scaling factor.\n  p -= q;\n  float k = r2/dot(p,p);\n  p *= k;\n  scale *= k;\n  p += q;\n  return p;\n}\n\nvec4 stereographic(vec3 p, inout float scale) {\n  return invert(vec4(p,0),vec4(0,0,0,-1),2.0,scale);\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Quaternion multiplication\n// (p+P)(q+Q) = pq + pQ + qP + PQ\nvec4 qmul(vec4 p, vec4 q) {\n  vec3 P = p.xyz, Q = q.xyz;\n  return vec4(p.w*Q+q.w*P+cross(P,Q),p.w*q.w-dot(P,Q));\n}\n\nvec3 getbackground(vec3 r) {\n  return vec3(0.5,0.8,0.5);\n  return r; // Colourful fun\n  return vec3(0); // The more sober option.\n}\n\nvec3 getbasecolor(int type) {\n  assert(type >= 0);\n  if (type == 0) return vec3(1,1,0.45);\n  if (type == 1) return vec3(0.2);\n  if (type == 2) return vec3(1,0,0);\n  if (type == 3) return vec3(1,1,0);\n  if (type == 4) return vec3(0,0,1);\n  return vec3(1,0,1);\n}\n\n// Rotate according to mouse position\nvec3 transformframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  // autorotation\n  if (dorotate) {\n    p.yz = rotate(p.yz,iTime*0.125);\n    p.zx = rotate(p.zx,iTime*0.1);\n  }\n  return p;\n}\n\n// Follow ray from q, direction r.\nvec3 raycolor(vec3 q, vec3 r) {\n  float t = march(q,r);\n  if (t < 0.0) return getbackground(r);\n  vec3 p = q+t*r;\n  vec3 normal = getnormal(p,t);\n  int type;\n  de(p,type); // Just to get the object type\n  vec3 color = getbasecolor(type);\n  float ambient = 0.3;\n  float specular = type == 0 ? 0.0 : 0.1;\n  vec3 speccolor = type == 1 ? color : vec3(1);\n  float specularpow = 4.0;\n  vec3 lightdir = normalize(light);\n  float diffuse = 0.7*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+ diffuse;\n  float s = pow(max(0.0,dot(reflect(light,normal),r)),specularpow);\n  color += specular*s*speccolor;\n  //color = mix(color,getbackground(r),t/maxdist);\n  return color;\n}\n\n// Get the colour for a screen point (with normalized coordinates)\nvec3 screencolor(vec2 z) {\n  vec3 eye = vec3(0,0,eyedist);\n  vec3 ray = vec3(z,-2);\n  eye = transformframe(eye);\n  ray = transformframe(ray);\n  light = transformframe(light);\n  ray = normalize(ray);\n  vec3 col = raycolor(eye,ray);\n  col = pow(col,vec3(0.4545)); // Gamma correction - see elsewhere\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  dorotate = !key(CHAR_R);\n  doclifford = !key(CHAR_C);\n  eyedist *= 1.0+0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP));\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 col = screencolor(z);\n  if (alert) col.r = 1.0; // Check nothing has gone wrong.\n  fragColor = vec4(col,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI = 3.1415927;\nconst float TWOPI = 2.0*PI;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_R = 82;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\n\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}