{
    "Shader": {
        "info": {
            "date": "1473690967",
            "description": "This is a multipass inverse sphere music visualizer.",
            "flags": 96,
            "hasliked": 0,
            "id": "4lGGRw",
            "likes": 1,
            "name": "sphere visualizer",
            "published": 3,
            "tags": [
                "music",
                "visualizer"
            ],
            "usePreview": 0,
            "username": "hopskotchrainbow",
            "viewed": 930
        },
        "renderpass": [
            {
                "code": "float maxAng = radians(360.0);\n\nvoid rotateXY(out vec2 vec, float angle) {\n    float rad = radians(angle);\n    vec2 res = vec2(vec.x*cos(rad)+vec.y*sin(rad),vec.x*sin(rad)-vec.y*cos(rad));\n    vec = res;\n}\nvoid rotateUV(out vec3 vec, vec2 angle) {\n    rotateXY(vec.zy, angle.x);\n    rotateXY(vec.xz, angle.y);\n}\n\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\n\nfloat iqnoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\t\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return va/wt;\n}\n\nvec3 SphereMap(vec3 vert) {\n    vec3 inormal = normalize(vert);\n    float ndist = length(inormal);\n    float ncross = atan(inormal.x, inormal.z);\n    float ncross2 = atan(length(inormal.xz), inormal.y);\n    vec2 ncase = vec2(ncross, ncross2)/vec2(-maxAng, -maxAng);\n    vec4 wmap = texture(iChannel0, ncase+0.5);\n    return wmap.rgb;\n}\n\nfloat iDiffuse(vec3 norm, vec3 light) {\n    vec3 nsw = normalize(normalize(norm)-normalize(light));\n    return pow(dot(normalize(norm), nsw),2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ms = iMouse.xy/iResolution.xy;\n    vec3 nsw = vec3(uv*2.-1.,1.2);\n    rotateUV(nsw, ms.yx*vec2(180.0,360.0)-vec2(90.0,180.0));\n    vec3 rgb = SphereMap(nsw);\n    rgb *= 0.5+iDiffuse(-nsw, vec3(1.,1.,1.))*0.5;\n\tfragColor = vec4(rgb,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Official HSV to RGB conversion \nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat viz(float xm) {\n    vec4 nw = texture(iChannel0, vec2(fract(xm), 0.75));\n    return nw.r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 ang = uv*vec2(360.0,180.0);\n    vec2 rad = vec2(radians(ang.x), radians(ang.y));\n    vec3 asph = vec3(cos(rad.x)*sin(rad.y), cos(rad.y), sin(rad.x)*sin(rad.y));\n    float nw = viz(uv.x);\n    vec3 c = hsv2rgb_smooth(vec3(uv.x, 1.0, 1.0));\n    if (asph.y <= 0.5+0.2*nw) {\n        c = vec3(1.0);\n    }\n    fragColor = vec4(c,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 4708,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/the-8-bit-dj-player/i-dont-care-fall-out-boy-8-bit"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}