{
    "Shader": {
        "info": {
            "date": "1596140196",
            "description": "Shadertoy implementation of Peter Shirley's Ray Tracing One Weekend. First time playing around with shaders, so a lot of things here are hacks. Tried to keep it close to the book whenever I could. \n\nTakes about 15s to compile the code.",
            "flags": 48,
            "hasliked": 0,
            "id": "wtlBzn",
            "likes": 7,
            "name": "Ray Tracing One Weekend - jvbs96",
            "published": 3,
            "tags": [
                "raytracing",
                "petershirley",
                "rtow"
            ],
            "usePreview": 1,
            "username": "joaovbs96",
            "viewed": 956
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////////////////////////////////\n//\t\t\t\t\tRay Tracing in One Weekend\n//\t\t\t\tShadertoy port by JoÃ£o V. B. Silva\n//\n// \tThis is my first time doing anything remotely related to shaders, so you\n// might see a lot of hacks and non-recommended things here. Tried to stay as\n// close to Peter Shirley's book as I could. Feedback is appreciated :)\n//\n//  The scene (i.e. geometries & BRDFs) is generated by a Python script. You \n// can find it (as well as a copy of these files) on this repository:\n// https://github.com/joaovbs96/shadertoy_raytracer\n//\n//////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n    // Accumulate and output to screen\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 oldColor = texture(iChannel0, uv);\n    \n    fragColor = vec4(sqrt(oldColor.rgb / float(iFrame)), 1.0f);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ===================== Ray =====================\nstruct Ray {\n\tvec3 origin;\n    vec3 direction;\n};\n\n// p = o + t * d\nvec3 pointAt(Ray r, float t) {\n\treturn r.origin + t * r.direction;\n}\n\n\n// ===================== Camera =====================\nstruct Camera {\n    vec3 origin;\n    vec3 hor, vert;\n    vec3 llc;\n    vec3 u, v, w;\n    float lens_radius;\n};\n\n// Creates new Camera\nCamera newCamera(vec3 lookfrom, vec3 lookat, \n                 vec3 vup, float vfov, \n                 float aRatio, float aperture, float focus_dist) {\n    float theta = radians(vfov);\n    float vpH = 2.0f * tan(theta / 2.0f);\n    float vpW = aRatio * vpH;\n    \n\tvec3 w = normalize(lookfrom - lookat);\n    vec3 u = normalize(cross(vup, w));\n    vec3 v = cross(w, u);\n    \n\tvec3 o = lookfrom;\n    vec3 hh = focus_dist * vpW * u;\n    vec3 vv = focus_dist * vpH* v;\n    vec3 llc = o - hh/2.0f - vv/2.0f - focus_dist * w;\n    return Camera(o, hh, vv, llc, u, v, w, aperture / 2.0f);\n}\n\n// Generates a new ray leaving from the camera\nRay getRay(Camera c, float s, float t) {\n    vec3 rd = c.lens_radius * randomInUnitDisk();\n    vec3 offset = c.u * rd.x + c.v * rd.y;\n    return Ray(c.origin + offset, c.llc + s * c.hor + t * c.vert - c.origin - offset);\n}\n\n// ===================== Hit Record =====================\n\nstruct HitRecord {\n    vec3 p;\n    vec3 n;\n    bool front_face;\n    float t;\n    int index;\n};\n    \n// TODO: add brdfIdx to the geometry, allowing us to reuse BRDFs accross several geometries\n    \n// ===================== Sphere =====================\n    \nstruct Sphere{\n    vec3 center;\n    float r;\n};\n    \nbool hitSphere(Sphere s, Ray r, float t_min, float t_max, out HitRecord rec){\n\tvec3 oc = r.origin - s.center;\n    float a = squaredLength(r.direction);\n    float hb = dot(oc, r.direction);\n    float c = squaredLength(oc) - s.r * s.r;\n    float d = hb*hb - a * c;\n    \n    // if the descriminant is > 0, we might have a hit\n    if(d > 0.0f){\n        float root = sqrt(d);\n        \n        float t = (-hb - root) / a;\n        if(t < t_max && t > t_min){\n            vec3 p = pointAt(r, t);\n            vec3 n = (p - s.center) / s.r;\n            rec = HitRecord(p, faceforward(n, r.direction, n), dot(r.direction, n) < 0.0f, t, 0);\n            return true;\n        }\n        \n        t = (-hb + root) / a;\n        if(t < t_max && t > t_min){\n            vec3 p = pointAt(r, t);\n            vec3 n = (p - s.center) / s.r;\n            rec = HitRecord(p, faceforward(n, r.direction, n), dot(r.direction, n) < 0.0f, t, 0);\n            return true;\n        }\n        \n        // if neither of the t's is in the (t_min, t_max) range, it's not a hit\n    }\n    \n    // else, not a hit\n    return false;\n}\n\n// List of Geometries - must have one BRDF per geometry\nSphere spheres[148] = Sphere[](Sphere(vec3(0.0f, -1000.0f, 0.0f), 1000.0f),\tSphere(vec3(-16.32f,0.2f,-16.2f), 0.2f),\tSphere(vec3(-16.93f,0.2f,-14.8f), 0.2f),\n                               Sphere(vec3(-16.19f,0.2f,-12.17f), 0.2f),\tSphere(vec3(-16.43f,0.2f,-10.84f), 0.2f),\tSphere(vec3(-16.72f,0.2f,-8.63f), 0.2f),\n                               Sphere(vec3(-16.67f,0.2f,-6.33f), 0.2f),\t\tSphere(vec3(-16.81f,0.2f,-4.89f), 0.2f),\tSphere(vec3(-16.23f,0.2f,-2.25f), 0.2f),\n                               Sphere(vec3(-16.16f,0.2f,-0.3f), 0.2f),\t\tSphere(vec3(-16.15f,0.2f,1.3f), 0.2f),\t\tSphere(vec3(-16.92f,0.2f,3.47f), 0.2f),\n                               Sphere(vec3(-16.22f,0.2f,5.57f), 0.2f),\t\tSphere(vec3(-14.5f,0.2f,-16.55f), 0.2f),\tSphere(vec3(-14.84f,0.2f,-14.86f), 0.2f),\n                               Sphere(vec3(-14.86f,0.2f,-12.63f), 0.2f),\tSphere(vec3(-14.77f,0.2f,-10.79f), 0.2f),\tSphere(vec3(-14.11f,0.2f,-8.96f), 0.2f),\n                               Sphere(vec3(-14.36f,0.2f,-6.92f), 0.2f),\t\tSphere(vec3(-14.28f,0.2f,-4.61f), 0.2f),\tSphere(vec3(-14.21f,0.2f,-2.19f), 0.2f),\n                               Sphere(vec3(-14.85f,0.2f,-0.49f), 0.2f),\t\tSphere(vec3(-14.33f,0.2f,1.82f), 0.2f),\t\tSphere(vec3(-14.84f,0.2f,3.28f), 0.2f),\n                               Sphere(vec3(-14.79f,0.2f,5.62f), 0.2f),\t\tSphere(vec3(-12.7f,0.2f,-16.97f), 0.2f),\tSphere(vec3(-12.97f,0.2f,-14.72f), 0.2f),\n                               Sphere(vec3(-12.1f,0.2f,-12.76f), 0.2f),\t\tSphere(vec3(-12.85f,0.2f,-10.97f), 0.2f),\tSphere(vec3(-12.36f,0.2f,-8.51f), 0.2f),\n                               Sphere(vec3(-12.61f,0.2f,-6.9f), 0.2f),\t\tSphere(vec3(-12.81f,0.2f,-4.4f), 0.2f),\t\tSphere(vec3(-12.36f,0.2f,-2.22f), 0.2f),\n                               Sphere(vec3(-12.37f,0.2f,-0.63f), 0.2f),\t\tSphere(vec3(-12.69f,0.2f,1.11f), 0.2f),\t\tSphere(vec3(-12.17f,0.2f,3.8f), 0.2f),\n                               Sphere(vec3(-12.13f,0.2f,5.58f), 0.2f),\t\tSphere(vec3(-10.81f,0.2f,-16.69f), 0.2f),\tSphere(vec3(-10.51f,0.2f,-14.18f), 0.2f),\n                               Sphere(vec3(-10.73f,0.2f,-12.68f), 0.2f),\tSphere(vec3(-10.29f,0.2f,-10.26f), 0.2f),\tSphere(vec3(-10.72f,0.2f,-8.65f), 0.2f),\n                               Sphere(vec3(-10.14f,0.2f,-6.72f), 0.2f),\t\tSphere(vec3(-10.38f,0.2f,-4.77f), 0.2f),\tSphere(vec3(-10.32f,0.2f,-2.55f), 0.2f),\n                               Sphere(vec3(-10.97f,0.2f,-0.27f), 0.2f),\t\tSphere(vec3(-10.44f,0.2f,1.34f), 0.2f),\t\tSphere(vec3(-10.81f,0.2f,3.26f), 0.2f),\n                               Sphere(vec3(-10.25f,0.2f,5.69f), 0.2f),\t\tSphere(vec3(-8.45f,0.2f,-16.27f), 0.2f),\tSphere(vec3(-8.19f,0.2f,-14.33f), 0.2f),\n                               Sphere(vec3(-8.11f,0.2f,-12.69f), 0.2f),\t\tSphere(vec3(-8.6f,0.2f,-10.5f), 0.2f),\t\tSphere(vec3(-8.89f,0.2f,-8.72f), 0.2f),\n                               Sphere(vec3(-8.74f,0.2f,-6.89f), 0.2f),\t\tSphere(vec3(-8.64f,0.2f,-4.46f), 0.2f),\t\tSphere(vec3(-8.22f,0.2f,-2.4f), 0.2f),\n                               Sphere(vec3(-8.65f,0.2f,-0.12f), 0.2f),\t\tSphere(vec3(-8.51f,0.2f,1.35f), 0.2f),\t\tSphere(vec3(-8.65f,0.2f,3.6f), 0.2f),\n                               Sphere(vec3(-8.12f,0.2f,5.31f), 0.2f),\t\tSphere(vec3(-6.44f,0.2f,-16.18f), 0.2f),\tSphere(vec3(-6.44f,0.2f,-14.48f), 0.2f),\n                               Sphere(vec3(-6.89f,0.2f,-12.51f), 0.2f),\t\tSphere(vec3(-6.47f,0.2f,-10.12f), 0.2f),\tSphere(vec3(-6.12f,0.2f,-8.35f), 0.2f),\n                               Sphere(vec3(-6.56f,0.2f,-6.62f), 0.2f),\t\tSphere(vec3(-6.49f,0.2f,-4.67f), 0.2f),\t\tSphere(vec3(-6.28f,0.2f,-2.25f), 0.2f),\n                               Sphere(vec3(-6.57f,0.2f,-0.27f), 0.2f),\t\tSphere(vec3(-6.55f,0.2f,1.11f), 0.2f),\t\tSphere(vec3(-6.19f,0.2f,3.62f), 0.2f),\n                               Sphere(vec3(-6.88f,0.2f,5.48f), 0.2f),\t\tSphere(vec3(-4.99f,0.2f,-16.8f), 0.2f),\t\tSphere(vec3(-4.28f,0.2f,-14.23f), 0.2f),\n                               Sphere(vec3(-4.91f,0.2f,-12.98f), 0.2f),\t\tSphere(vec3(-4.8f,0.2f,-10.87f), 0.2f),\t\tSphere(vec3(-4.22f,0.2f,-8.99f), 0.2f),\n                               Sphere(vec3(-4.66f,0.2f,-6.84f), 0.2f),\t\tSphere(vec3(-4.93f,0.2f,-4.96f), 0.2f),\t\tSphere(vec3(-4.63f,0.2f,-2.57f), 0.2f),\n                               Sphere(vec3(-4.39f,0.2f,-0.97f), 0.2f),\t\tSphere(vec3(-4.83f,0.2f,1.6f), 0.2f),\t\tSphere(vec3(-4.99f,0.2f,3.42f), 0.2f),\n                               Sphere(vec3(-4.21f,0.2f,5.42f), 0.2f),\t\tSphere(vec3(-2.28f,0.2f,-16.8f), 0.2f),\t\tSphere(vec3(-2.95f,0.2f,-14.18f), 0.2f),\n                               Sphere(vec3(-2.49f,0.2f,-12.86f), 0.2f),\t\tSphere(vec3(-2.2f,0.2f,-10.78f), 0.2f),\t\tSphere(vec3(-2.35f,0.2f,-8.14f), 0.2f),\n                               Sphere(vec3(-2.17f,0.2f,-6.33f), 0.2f),\t\tSphere(vec3(-2.18f,0.2f,-4.96f), 0.2f),\t\tSphere(vec3(-2.81f,0.2f,-2.72f), 0.2f),\n                               Sphere(vec3(-2.29f,0.2f,-0.47f), 0.2f),\t\tSphere(vec3(-2.19f,0.2f,1.72f), 0.2f),\t\tSphere(vec3(-2.16f,0.2f,3.08f), 0.2f),\n                               Sphere(vec3(-2.13f,0.2f,5.57f), 0.2f),\t\tSphere(vec3(-0.93f,0.2f,-16.37f), 0.2f),\tSphere(vec3(-0.2f,0.2f,-14.6f), 0.2f),\n                               Sphere(vec3(-0.16f,0.2f,-12.83f), 0.2f),\t\tSphere(vec3(-0.12f,0.2f,-10.63f), 0.2f),\tSphere(vec3(-0.19f,0.2f,-8.48f), 0.2f),\n                               Sphere(vec3(-0.12f,0.2f,-6.29f), 0.2f),\t\tSphere(vec3(-0.38f,0.2f,-4.51f), 0.2f),\t\tSphere(vec3(-0.63f,0.2f,-2.32f), 0.2f),\n                               Sphere(vec3(-0.43f,0.2f,-0.22f), 0.2f),\t\tSphere(vec3(-0.13f,0.2f,1.65f), 0.2f),\t\tSphere(vec3(-0.81f,0.2f,3.17f), 0.2f),\n                               Sphere(vec3(-0.98f,0.2f,5.45f), 0.2f),\t\tSphere(vec3(1.59f,0.2f,-16.7f), 0.2f),\t\tSphere(vec3(1.56f,0.2f,-14.79f), 0.2f),\n                               Sphere(vec3(1.55f,0.2f,-12.72f), 0.2f),\t\tSphere(vec3(1.65f,0.2f,-10.3f), 0.2f),\t\tSphere(vec3(1.56f,0.2f,-8.77f), 0.2f),\n                               Sphere(vec3(1.45f,0.2f,-6.86f), 0.2f),\t\tSphere(vec3(1.8f,0.2f,-4.45f), 0.2f),\t\tSphere(vec3(1.6f,0.2f,-2.87f), 0.2f),\n                               Sphere(vec3(1.73f,0.2f,-0.62f), 0.2f),\t\tSphere(vec3(1.53f,0.2f,1.46f), 0.2f),\t\tSphere(vec3(1.11f,0.2f,3.41f), 0.2f),\n                               Sphere(vec3(1.02f,0.2f,5.43f), 0.2f),\t\tSphere(vec3(3.5f,0.2f,-16.62f), 0.2f),\t\tSphere(vec3(3.2f,0.2f,-14.96f), 0.2f),\n                               Sphere(vec3(3.12f,0.2f,-12.36f), 0.2f),\t\tSphere(vec3(3.74f,0.2f,-10.69f), 0.2f),\t\tSphere(vec3(3.34f,0.2f,-8.54f), 0.2f),\n                               Sphere(vec3(3.66f,0.2f,-6.5f), 0.2f),\t\tSphere(vec3(3.88f,0.2f,-4.34f), 0.2f),\t\tSphere(vec3(3.55f,0.2f,-2.33f), 0.2f),\n                               Sphere(vec3(3.37f,0.2f,-0.69f), 0.2f),\t\tSphere(vec3(3.85f,0.2f,1.23f), 0.2f),\t\tSphere(vec3(3.08f,0.2f,3.22f), 0.2f),\n                               Sphere(vec3(3.22f,0.2f,5.45f), 0.2f),\t\tSphere(vec3(5.02f,0.2f,-16.42f), 0.2f),\t\tSphere(vec3(5.53f,0.2f,-14.65f), 0.2f),\n                               Sphere(vec3(5.19f,0.2f,-12.15f), 0.2f),\t\tSphere(vec3(5.27f,0.2f,-10.96f), 0.2f),\t\tSphere(vec3(5.43f,0.2f,-8.32f), 0.2f),\n                               Sphere(vec3(5.5f,0.2f,-6.92f), 0.2f),\t\tSphere(vec3(5.88f,0.2f,-4.37f), 0.2f),\t\tSphere(vec3(5.61f,0.2f,-2.77f), 0.2f),\n                               Sphere(vec3(5.13f,0.2f,-0.34f), 0.2f),\t\tSphere(vec3(5.79f,0.2f,1.71f), 0.2f),\t\tSphere(vec3(5.53f,0.2f,3.34f), 0.2f),\n                               Sphere(vec3(5.19f,0.2f,5.52f), 0.2f),\t\tSphere(vec3(-4.0f, 1.0f, 0.0f), 1.0f),\t\tSphere(vec3(4.0f, 1.0f, 0.0f), 1.0f),\n                               Sphere(vec3(0.0f, 1.0f, 0.0f), 1.0f)\n);\n\n// ===================== BRDFs =====================\nstruct BRDF {\n    // Common params\n\tint type; // 0 - Lambertian, 1 - Metal, 2 - Dielectric\n    vec3 color;\n    \n    // Metal Params\n    float fuzz;\n    \n    // dielectric\n    float ior;\n};\n\n// List of BRDFs - must have one BRDF per geometry\nBRDF brdfs[148] = BRDF[](BRDF(0, vec3(0.5f), 0.0f, 0.0f),\t\t\t\tBRDF(0, vec3(0.14f, 0.46f, 0.02f), 0.0f, 0.0f),\tBRDF(1, vec3(0.88f, 0.57f, 0.73f), 0.5f, 0.0f),\n                         BRDF(1, vec3(0.51f, 0.83f, 0.75f), 0.5f, 0.0f),BRDF(1, vec3(0.73f, 0.86f, 0.69f), 0.5f, 0.0f),\tBRDF(0, vec3(0.43f, 0.22f, 0.01f), 0.0f, 0.0f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(1, vec3(0.88f, 0.88f, 0.66f), 0.5f, 0.0f),\tBRDF(1, vec3(0.69f, 0.78f, 0.52f), 0.5f, 0.0f),\n                         BRDF(0, vec3(0.37f, 0.09f, 0.27f), 0.0f, 0.0f),BRDF(0, vec3(0.02f, 0.03f, 0.06f), 0.0f, 0.0f),\tBRDF(0, vec3(0.05f, 0.57f, 0.29f), 0.0f, 0.0f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.22f, 0.11f, 0.61f), 0.0f, 0.0f),\tBRDF(0, vec3(0.0f, 0.12f, 0.26f), 0.0f, 0.0f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.03f, 0.33f, 0.06f), 0.0f, 0.0f),\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\n                         BRDF(0, vec3(0.05f, 0.45f, 0.3f), 0.0f, 0.0f),\tBRDF(0, vec3(0.42f, 0.19f, 0.45f), 0.0f, 0.0f),\tBRDF(0, vec3(0.14f, 0.19f, 0.07f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.38f, 0.06f, 0.03f), 0.0f, 0.0f),BRDF(1, vec3(0.69f, 0.76f, 0.57f), 0.5f, 0.0f),\tBRDF(0, vec3(0.47f, 0.33f, 0.14f), 0.0f, 0.0f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.68f, 0.26f, 0.01f), 0.0f, 0.0f),\tBRDF(1, vec3(0.57f, 0.67f, 0.58f), 0.5f, 0.0f),\n                         BRDF(0, vec3(0.04f, 0.62f, 0.14f), 0.0f, 0.0f),BRDF(1, vec3(0.64f, 0.81f, 0.75f), 0.5f, 0.0f),\tBRDF(0, vec3(0.44f, 0.12f, 0.32f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.3f, 0.21f, 0.47f), 0.0f, 0.0f),\tBRDF(1, vec3(0.82f, 0.61f, 0.69f), 0.5f, 0.0f),\tBRDF(1, vec3(0.69f, 0.73f, 0.84f), 0.5f, 0.0f),\n                         BRDF(0, vec3(0.14f, 0.55f, 0.48f), 0.0f, 0.0f),BRDF(0, vec3(0.78f, 0.87f, 0.47f), 0.0f, 0.0f),\tBRDF(0, vec3(0.31f, 0.05f, 0.75f), 0.0f, 0.0f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.17f, 0.41f, 0.44f), 0.0f, 0.0f),\tBRDF(0, vec3(0.38f, 0.41f, 0.12f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.66f, 0.16f, 0.23f), 0.0f, 0.0f),BRDF(0, vec3(0.31f, 0.23f, 0.03f), 0.0f, 0.0f),\tBRDF(0, vec3(0.66f, 0.0f, 0.14f), 0.0f, 0.0f),\n                         BRDF(1, vec3(0.94f, 0.91f, 0.55f), 0.5f, 0.0f),BRDF(0, vec3(0.27f, 0.03f, 0.04f), 0.0f, 0.0f),\tBRDF(0, vec3(0.05f, 0.44f, 0.16f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.05f, 0.77f, 0.13f), 0.0f, 0.0f),BRDF(1, vec3(0.53f, 0.51f, 0.8f), 0.5f, 0.0f),\tBRDF(0, vec3(0.64f, 0.13f, 0.59f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.03f, 0.0f, 0.13f), 0.0f, 0.0f),\tBRDF(1, vec3(0.78f, 0.59f, 0.59f), 0.5f, 0.0f),\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\n                         BRDF(0, vec3(0.04f, 0.91f, 0.02f), 0.0f, 0.0f),BRDF(0, vec3(0.08f, 0.62f, 0.16f), 0.0f, 0.0f),\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\n                         BRDF(0, vec3(0.12f, 0.03f, 0.22f), 0.0f, 0.0f),BRDF(0, vec3(0.04f, 0.36f, 0.73f), 0.0f, 0.0f),\tBRDF(0, vec3(0.18f, 0.68f, 0.08f), 0.0f, 0.0f),\n                         BRDF(1, vec3(0.67f, 0.86f, 0.88f), 0.5f, 0.0f),BRDF(0, vec3(0.05f, 0.18f, 0.19f), 0.0f, 0.0f),\tBRDF(1, vec3(0.84f, 0.78f, 0.61f), 0.5f, 0.0f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.1f, 0.0f, 0.08f), 0.0f, 0.0f),\tBRDF(1, vec3(0.56f, 0.81f, 0.69f), 0.5f, 0.0f),\n                         BRDF(0, vec3(0.32f, 0.25f, 0.01f), 0.0f, 0.0f),BRDF(0, vec3(0.09f, 0.14f, 0.47f), 0.0f, 0.0f),\tBRDF(0, vec3(0.57f, 0.46f, 0.01f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.09f, 0.14f, 0.69f), 0.0f, 0.0f),BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.12f, 0.32f, 0.37f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.67f, 0.66f, 0.03f), 0.0f, 0.0f),BRDF(0, vec3(0.12f, 0.74f, 0.07f), 0.0f, 0.0f),\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.35f, 0.35f, 0.32f), 0.0f, 0.0f),\tBRDF(0, vec3(0.53f, 0.04f, 0.27f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.01f, 0.55f, 0.26f), 0.0f, 0.0f),BRDF(0, vec3(0.45f, 0.07f, 0.24f), 0.0f, 0.0f),\tBRDF(0, vec3(0.01f, 0.02f, 0.08f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.03f, 0.06f, 0.16f), 0.0f, 0.0f),BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.24f, 0.07f, 0.61f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.14f, 0.2f, 0.16f), 0.0f, 0.0f),\tBRDF(0, vec3(0.03f, 0.55f, 0.03f), 0.0f, 0.0f),\tBRDF(0, vec3(0.17f, 0.12f, 0.15f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.09f, 0.21f, 0.0f), 0.0f, 0.0f),\tBRDF(0, vec3(0.1f, 0.02f, 0.1f), 0.0f, 0.0f),\tBRDF(0, vec3(0.04f, 0.02f, 0.18f), 0.0f, 0.0f),\n                         BRDF(1, vec3(0.84f, 0.67f, 0.96f), 0.5f, 0.0f),BRDF(0, vec3(0.31f, 0.12f, 0.45f), 0.0f, 0.0f),\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\n                         BRDF(0, vec3(0.15f, 0.45f, 0.07f), 0.0f, 0.0f),BRDF(1, vec3(0.63f, 0.62f, 0.93f), 0.5f, 0.0f),\tBRDF(0, vec3(0.06f, 0.18f, 0.0f), 0.0f, 0.0f),\n                         BRDF(1, vec3(0.94f, 0.5f, 0.56f), 0.5f, 0.0f),\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.27f, 0.12f, 0.09f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.25f, 0.08f, 0.28f), 0.0f, 0.0f),BRDF(1, vec3(0.63f, 0.76f, 0.97f), 0.5f, 0.0f),\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\n                         BRDF(0, vec3(0.21f, 0.0f, 0.09f), 0.0f, 0.0f),\tBRDF(0, vec3(0.26f, 0.43f, 0.03f), 0.0f, 0.0f),\tBRDF(0, vec3(0.44f, 0.73f, 0.4f), 0.0f, 0.0f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(1, vec3(0.82f, 0.8f, 0.94f), 0.5f, 0.0f),\tBRDF(0, vec3(0.17f, 0.04f, 0.6f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.51f, 0.44f, 0.07f), 0.0f, 0.0f),BRDF(0, vec3(0.37f, 0.17f, 0.11f), 0.0f, 0.0f),\tBRDF(1, vec3(0.91f, 0.83f, 0.56f), 0.5f, 0.0f),\n                         BRDF(0, vec3(0.07f, 0.44f, 0.16f), 0.0f, 0.0f),BRDF(0, vec3(0.58f, 0.01f, 0.04f), 0.0f, 0.0f),\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\n                         BRDF(0, vec3(0.27f, 0.01f, 0.01f), 0.0f, 0.0f),BRDF(0, vec3(0.59f, 0.24f, 0.17f), 0.0f, 0.0f),\tBRDF(0, vec3(0.1f, 0.03f, 0.3f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.02f, 0.66f, 0.28f), 0.0f, 0.0f),BRDF(1, vec3(0.83f, 0.78f, 0.73f), 0.5f, 0.0f),\tBRDF(0, vec3(0.76f, 0.14f, 0.31f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.09f, 0.15f, 0.19f), 0.0f, 0.0f),BRDF(1, vec3(0.71f, 0.58f, 0.81f), 0.5f, 0.0f),\tBRDF(1, vec3(0.91f, 0.99f, 0.83f), 0.5f, 0.0f),\n                         BRDF(0, vec3(0.53f, 0.47f, 0.25f), 0.0f, 0.0f),BRDF(0, vec3(0.27f, 0.09f, 0.53f), 0.0f, 0.0f),\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\n                         BRDF(0, vec3(0.15f, 0.14f, 0.26f), 0.0f, 0.0f),BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.32f, 0.05f, 0.18f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.61f, 0.4f, 0.42f), 0.0f, 0.0f),\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(1, vec3(0.59f, 0.98f, 0.89f), 0.5f, 0.0f),\n                         BRDF(0, vec3(0.09f, 0.45f, 0.33f), 0.0f, 0.0f),BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\n                         BRDF(0, vec3(0.13f, 0.87f, 0.33f), 0.0f, 0.0f),BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.64f, 0.31f, 0.38f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.34f, 0.04f, 0.63f), 0.0f, 0.0f),BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.66f, 0.01f, 0.07f), 0.0f, 0.0f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(1, vec3(0.99f, 0.62f, 0.87f), 0.5f, 0.0f),\tBRDF(0, vec3(0.13f, 0.02f, 0.73f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.35f, 0.06f, 0.3f), 0.0f, 0.0f),\tBRDF(0, vec3(0.37f, 0.69f, 0.02f), 0.0f, 0.0f),\tBRDF(0, vec3(0.38f, 0.11f, 0.16f), 0.0f, 0.0f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.4f, 0.2f, 0.1f), 0.0f, 0.0f),\tBRDF(1, vec3(0.7f, 0.6f, 0.5f), 0.0f, 0.0f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f)\n);\n\nfloat schlick(float cosine, float ref_idx) {\n  float r0 = (1.0f - ref_idx) / (1.0f + ref_idx);\n  r0 = r0 * r0;\n  return r0 + (1.0f - r0) * pow((1.0f - cosine), 5.0f);\n}\n\n// Samples BRDF\nvec3 sampleBRDF(Ray r, HitRecord rec) {\n\tswitch(brdfs[rec.index].type) {\n        case 0: // Lambertian\n        \treturn rec.n + randomUnitVector();\n        \tbreak;\n        \n        case 1: // Metal\n        \treturn reflect(normalize(r.direction), normalize(rec.n)) + brdfs[rec.index].fuzz * randomInUnitSphere();\n        \tbreak;\n        \n        case 2: // Dielectric\n        \tfloat ior = brdfs[rec.index].ior;\n        \tfloat etai_over_etat = rec.front_face ? (1.0f / ior) : ior;\n        \n        \tvec3 dir = normalize(r.direction);\n        \tvec3 nn = normalize(rec.n);\n        \n        \tfloat cos_theta = min(dot(-dir, nn), 1.0f);\n        \tfloat sin_theta = sqrt(1.0f - cos_theta * cos_theta);\n        \tif(etai_over_etat * sin_theta > 1.0f) {\n        \t\treturn normalize(reflect(dir, nn));\n            }\n        \n        \treturn normalize(refract(dir, nn, etai_over_etat));\n        \n        \tbreak;\n    }\n    \n}\n\n// Evaluates BRDF\nvec3 evalBRDF(Ray r, HitRecord rec) {\n    switch(brdfs[rec.index].type) {\n        case 0: // Lambertian\n        \treturn brdfs[rec.index].color;\n        \tbreak;\n        \n        case 1: // Metal\n        \treturn brdfs[rec.index].color;\n        \tbreak;\n        \n        case 2: // Dielectric\n        \treturn brdfs[rec.index].color;\n        \tbreak;\n    }\n}\n\n// ===================== Main =====================\n\n// Iterates over a list of geometries and tries to find a hit\nbool hitWorld(Ray r, float t_min, float t_max, out HitRecord rec) {\n    HitRecord temp;\n    bool hitAnything = false;\n    float closest = t_max;\n    \n    for(int i = 0; i < spheres.length(); i++){\n        if(hitSphere(spheres[i], r, t_min, t_max, temp)){\n            if(temp.t < closest){\n                hitAnything = true;\n                closest = temp.t;\n                rec = temp;\n                rec.index = i;\n            }\n        }\n    }\n    \n    return hitAnything;\n}\n\n// Traces ray\nvec3 trace(Ray r) {\n    vec3 throughput = vec3(1.0f);\n    \n    // iterative version of recursion\n    for(int i = 0; i < 50; i++){\n        HitRecord rec;\n        \n        // ray hit\n        if(hitWorld(r, 0.001f, FLT_MAX, rec)) {\n            vec3 wi = sampleBRDF(r, rec);\n            throughput *= evalBRDF(r, rec);\n            \n            r = Ray(rec.p, wi);\n        } \n        \n        // ray miss\n        else {\n            vec3 uDirection = normalize(r.direction);\n        \tfloat t = 0.5f * (uDirection.y + 1.0f);\n        \tvec3 color = (1.0f - t) * vec3(1.0f) + t * vec3(0.5f, 0.7f, 1.0f);\n            return throughput * color;\n        }           \n    }\n    \n    \n    return vec3(0.0f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n    // rnd seed\n    seed = tea(int(iResolution.x) * int(fragCoord.y) + int(fragCoord.x), iFrame);\n    \n    // camera\n    float aRatio = iResolution.x/iResolution.y;\n    vec3 lookfrom = vec3(13.0f, 2.0f, 3.0f);\n    vec3 lookat = vec3(0.0f, 0.0f, 0.0f);\n    vec3 vup = vec3(0.0f, 1.0f, 0.0f);\n    Camera c = newCamera(lookfrom, lookat, vup, 20.0f, aRatio, 0.1f, 10.0f);\n    \n    // shoot a ray\n    float u = (fragCoord.x + rnd()) / iResolution.x;\n    float v = (fragCoord.y + rnd()) / iResolution.y;\n    Ray r = getRay(c, u, v);\n\n    // Accumulate and output to screen\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 oldColor = texture( iChannel0, uv );\n    \n    // initiates buffer if we are on frame 0\n    if(iFrame == 0) oldColor = vec4(0.0f);\n    \n    // TODO: Fix. The reset on keypress works, but we need to save the current frame \n    // somewhere so we can do accum /(currentFrame - savedFrame).\n    //if(KeyPressed(82)) oldColor = vec4(0.0f); // Press R to reset\n    \n    fragColor = oldColor + vec4(de_nan(trace(r)), 0.0f);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ===================== Math Defines =====================\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\n#define FLT_MAX 3.402823466e+38\n#define FLT_MIN 1.175494351e-38\n\n#define squaredLength(x) pow(length(x), 2.0f)\n\n// ===================== Random Generator =====================\n// RNG adapted from the random generator used by NVidia in their OptiX's samples.\n// The following licence only applies to the functions tea, rnd and lcg.\n\n//////////////////////////////////////////////////////////////////////////////////////\n// ******************************************************************************** //\n/*\n * Copyright (c) 2018, NVIDIA CORPORATION. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *  * Neither the name of NVIDIA CORPORATION nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\nint seed;\n\nint tea(int val0, int val1) {\n  int v0 = val0;\n  int v1 = val1;\n  int s0 = 0;\n\n  for (int n = 0; n < 16; n++) {\n    s0 += 0x9e3779b9;\n    v0 += ((v1 << 4) + 0xa341316c) ^ (v1 + s0) ^ ((v1 >> 5) + 0xc8013ea4);\n    v1 += ((v0 << 4) + 0xad90777d) ^ (v0 + s0) ^ ((v0 >> 5) + 0x7e95761e);\n  }\n\n  return v0;\n}\n\nint lcg() {\n  int LCG_A = 1664525;\n  int LCG_C = 1013904223;\n  seed = (LCG_A * seed + LCG_C);\n  return seed & 0x00FFFFFF;\n}\n\nfloat rnd() {\n  return (float(lcg()) / float(0x01000000));\n}\n\n\n// ******************************************************************************** //\n//////////////////////////////////////////////////////////////////////////////////////\n\n// ===================== Sampling =====================\n\nvec3 randomInUnitSphere() {\n  \tfloat z = rnd() * 2.f - 1.f;\n\n  \tfloat t = rnd() * 2.f * PI;\n  \tfloat r = sqrt((0.f > (1.f - z * z) ? 0.f : (1.f - z * z)));\n\n  \tfloat x = r * cos(t);\n  \tfloat y = r * sin(t);\n\n  \tvec3 res = vec3(x, y, z);\n  \tres *= pow(rnd(), 1.f / 3.f);\n\n  \treturn res;\n}\n\nvec3 randomUnitVector() {\n    float a = rnd() * TWOPI;\n    float z = (rnd() * 2.0f) - 1.0f;\n    float r = sqrt(1.0f - z * z);\n    \n    return vec3(r * cos(a), r * sin(a), z);\n}\n\nvec3 randomInUnitDisk() {\n\tfloat a = rnd() * TWOPI;\n\tvec3 xy = vec3(sin(a), cos(a), 0.0f);\n\txy *= sqrt(rnd());\n\treturn xy;\n}\n\n// ===================== Removing NaNs =====================\n\n// Source: https://stackoverflow.com/a/34276047\nbool isNan(float val) {\n  return (val < 0.0 || 0.0 < val || val == 0.0) ? false : true;\n\n}\n\nvec3 de_nan(vec3 c) {\n  vec3 temp = c;\n  if (isNan(temp.x)) temp.x = 0.0f;\n  if (isNan(temp.y)) temp.y = 0.0f;\n  if (isNan(temp.z)) temp.z = 0.0f;\n  return temp;\n}\n\n// ===================== Keyboard Input =====================\n#define keyChannel iChannel1\n#define KeyPressed(key) _keyPressed(keyChannel, key)\n\n// Return true if given key is pressed\n// Source: https://www.shadertoy.com/view/XsycWw\nbool _keyPressed(sampler2D keyChannel, int key) {\n  return texelFetch(keyChannel, ivec2(key,0), 0).x > 0.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}