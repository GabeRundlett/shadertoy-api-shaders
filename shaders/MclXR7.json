{
    "Shader": {
        "info": {
            "date": "1705094770",
            "description": "this is actually super fun\ncomments generated by chatGPT and formatted by chatGPT because my normal code is formatted horribly without any comments",
            "flags": 0,
            "hasliked": 0,
            "id": "MclXR7",
            "likes": 1,
            "name": "Ray tracing - bouncing rays",
            "published": 3,
            "tags": [
                "raytracing",
                "rays",
                "sphere",
                "balls"
            ],
            "usePreview": 0,
            "username": "UsamagorQ",
            "viewed": 117
        },
        "renderpass": [
            {
                "code": "uint seed;\nint maxBounceCount = 5;\nfloat raysPerPixel = 100.;\n// Random number generator\nfloat random() {\n    seed = seed * 747796405u + 2891336453u;\n    uint result = ((seed >> ((seed >> 28) + 4U)) ^ seed) * 277803737u;\n    result = (result >> 22) ^ result;\n    return float(result) / 4294967295.0;\n}\n\n// Ray structure\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\n// Material structure\nstruct Material {\n    vec3 color;\n    vec3 emissionColor;\n    float emissionStrength;\n};\n\n// Sphere structure\nstruct Sphere {\n    vec3 position;\n    float radius;\n};\n\n// Structure to hold hit information\nstruct HitInfo {\n    bool didHit;\n    float dst;\n    vec3 hitPoint;\n    vec3 normal;\n    Material material;\n};\n\n// Function to check ray-sphere intersection\nHitInfo RaySphere(Ray ray, vec3 sphereCenter, float sphereRadius) {\n    HitInfo hitInfo;\n    vec3 offsetRayOrigin = ray.origin - sphereCenter;\n\n    float a = dot(ray.dir, ray.dir);\n    float b = 2. * dot(offsetRayOrigin, ray.dir);\n    float c = dot(offsetRayOrigin, offsetRayOrigin) - sphereRadius * sphereRadius;\n    float discriminant = b * b - 4. * a * c;\n\n    if (discriminant >= 0.) {\n        float dst = (-b - sqrt(discriminant)) / (2. * a);\n\n        if (dst >= 0.) {\n            hitInfo.didHit = true;\n            hitInfo.dst = dst;\n            hitInfo.hitPoint = ray.origin + ray.dir * dst;\n            hitInfo.normal = normalize(hitInfo.hitPoint - sphereCenter);\n        }\n    }\n\n    return hitInfo;\n}\n\n// Function to check ray-sphere intersections for a scene\nHitInfo Scene(Ray ray) {\n    HitInfo closestHit;\n    closestHit.dst = 1e5;\n\n    HitInfo hitInfo;\n\n    // Call RaySphere for each sphere in the scene\n    hitInfo = RaySphere(ray, vec3(-4, -2., 7.), 5.);\n    if (hitInfo.didHit && hitInfo.dst < closestHit.dst) {\n        closestHit = hitInfo;\n        closestHit.material = Material(vec3(0., -15., 0.), vec3(1.), 100.); // Set material color\n    }\n\n    hitInfo = RaySphere(ray, vec3(cos(iTime), 0.3, sin(iTime)), 0.5);\n    if (hitInfo.didHit && hitInfo.dst < closestHit.dst) {\n        closestHit = hitInfo;\n        closestHit.material = Material(vec3(0., 0., 1.), vec3(0.), 0.); // Set material color\n    }\n    \n    hitInfo = RaySphere(ray, vec3(0., 0., 0.), 0.55);\n    if (hitInfo.didHit && hitInfo.dst < closestHit.dst) {\n        closestHit = hitInfo;\n        closestHit.material = Material(vec3(normalize(cos(iTime)), normalize(cos(iTime/2.)), 0.75), vec3(0.), 0.); // Set material color\n    }\n\n    return closestHit;\n}\nvec3 randomDirection()\n{\nfloat x = random();\nfloat y = random();\nfloat z = random();\nreturn normalize(vec3(x, y, z));\n}\nvec3 randomHemisphereDirection(vec3 normal)\n{\nvec3 dir = randomDirection();\nreturn dir * sign(dot(normal, dir));\n}\nvec3 Trace(Ray ray)\n{\n    vec3 rayColor = vec3(1.);\n    \n    vec3 incomingLight = vec3(0.);\nfor(int i = 0; i<maxBounceCount; i++)\n{\n    \n    HitInfo hitinfo = Scene(ray);\n    \n    if(hitinfo.didHit) {\n \n        ray.origin = hitinfo.hitPoint;\n        ray.dir = randomHemisphereDirection(hitinfo.normal);\n        \n        Material material = hitinfo.material;\n        vec3 emittedLight = material.emissionColor * material.emissionStrength;\n        incomingLight += emittedLight * rayColor;\n        rayColor *= material.color;\n                       }\nelse {\n    break;\n    }\n}\nreturn incomingLight;\n}\n// Main function for rendering\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Initialize ray and seed\n    Ray ray;\n    ray.origin = vec3(0, 0, 5);\n    seed = floatBitsToUint(texture(iChannel0, fragCoord / iResolution.xy).x + iTime);\n\n    // Generate a random offset\n    vec2 of = -0.5 + vec2(random(), random());\n\n    // Calculate the pixel position in normalized device coordinates\n    vec2 p = (2.0 * (fragCoord + of) - iResolution.xy) / iResolution.y;\n\n    // Calculate the direction from the camera to the view point\n    vec3 viewPoint = vec3(p, 1.);\n    ray.dir = normalize(viewPoint - ray.origin);\n    vec3 totalIncomingLight;\n    for (int rayIndex = 0; rayIndex < int(raysPerPixel); rayIndex++)\n    {\n    totalIncomingLight += Trace(ray);\n    }\n    vec3 pixelCol = totalIncomingLight / raysPerPixel;\n    // Set the pixel color based on the material color from the scene\n    fragColor = vec4(pixelCol, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}