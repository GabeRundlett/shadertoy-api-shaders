{
    "Shader": {
        "info": {
            "date": "1690154307",
            "description": "it's a pattern you dolt!",
            "flags": 0,
            "hasliked": 0,
            "id": "msSBDV",
            "likes": 1,
            "name": "hex_morph",
            "published": 3,
            "tags": [
                "shader"
            ],
            "usePreview": 0,
            "username": "Eindacor_DS",
            "viewed": 122
        },
        "renderpass": [
            {
                "code": "\n\n#define TWOPI 6.28318530718f\n#define AA 0.001f\n#define SIXTY_DEGREES 1.0471975512f\n\n#define u_TimeScaleModifier 0.1f\n#define u_HexRadius .15f\n\nstruct HexData {\n    // value (0 -> 1) representing the uv's value in radial space, origin is (1, 0)\n    float radialVal; \n    \n    // value (0 -> 1) representing approximity to center compared to hex radius\n    float distFromHexCenter;  \n    \n    // center vertex of the hexagon\n    vec2 hexCenter;           \n    \n    // locations of each vertex of the hex\n    vec2[6] hexVertices;      \n    \n    // value (0 -> 1) representing approximity to center compared to hexagon's edge\n    float edgeCoefficient;  \n    \n    // value (0 -> 1) representinglinear interpolation of radians between local triangle vertices\n    float radialLerp;         \n    \n    // value (0 -> 1) representing the sumtotal of each hex vertex's distance to the uv compared\n    //       to the maximum sumtotal distance possible\n    float sumDistCoefficient; \n};\n\nfloat circleSmoothStepFill(vec2 center, float radius, vec2 p, float antiAlias) {\n\treturn 1.f - smoothstep(radius - antiAlias, radius + antiAlias, distance(center, p));\n}\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n    float val = sin(dot(p, vec2(12.9898f, 78.233f))) * 43758.5453f;\n    return val - floor(val);\n}\n\nvec2 rotateAroundAxis(vec2 point, vec2 axis, float angle) \n{\n    point -= axis;\n    float x = point.x * cos(angle) - point.y * sin(angle);\n    float y = point.y * cos(angle) + point.x * sin(angle);\n    return vec2(x, y) + axis;\n}\n\nfloat lineSegmentSmoothStep(vec2 start, vec2 end, vec2 p, float lineThickness, float antiAlias, bool roundEnds) {\n    float halfThickness = lineThickness / 2.f;\n    if (dot(p-end, start - end) < 0.f || dot(p - start, end - start) < 0.f) {\n        return !roundEnds ? 0.f : max(\n\t\t\tcircleSmoothStepFill(start, halfThickness, p, antiAlias),\n\t\t\tcircleSmoothStepFill(end, halfThickness, p, antiAlias)\n        );  \n    }\n    \n    vec2 lineVec = normalize(end - start);\n    vec2 pVec = normalize(p - start);\n\n    float angle = acos(dot(lineVec, pVec) / length(lineVec) * length(pVec));\n    float distFromLine = sin(angle) * distance(start, p);\n    \n    return 1.f - smoothstep(lineThickness / 2.f - antiAlias, halfThickness + antiAlias, distFromLine);\n}\n\nstruct AspectRatioData {\n    mat2x2 scaleMatrix;\n    mat2x2 inverseScaleMatrix;\n    float aspectRatio;\n};\n\nAspectRatioData getAspectRatioData(vec2 uvSize) {\n    float aspectRatio = uvSize.x / uvSize.y;\n    AspectRatioData aspectRatioData;\n    aspectRatioData.aspectRatio = aspectRatio;\n    aspectRatioData.scaleMatrix = mat2x2(\n        aspectRatio, 0.f,\n        0.f, 1.f\n    );\n    \n    aspectRatioData.inverseScaleMatrix = mat2x2(\n        1.f / aspectRatio, 0.f,\n        0.f, 1.f\n    );\n\n    return aspectRatioData;\n}\n\nbool isHexCenter(vec2 pos, float hexXIncrement, float hexYIncrement) {\n    float columnIndex = round(pos.x / hexXIncrement);\n    float rowIndex = round(pos.y / hexYIncrement);\n    return int(round(mod(abs(columnIndex), 2.f))) == int(round(mod(abs(rowIndex), 2.f)));\n}\n\nfloat getOffsetAngle(vec2 first, vec2 second) {\n    vec2 offsetVec = second - first;\n    float angle = atan(offsetVec.y / offsetVec.x);\n    \n    \n    if (first.x < second.x) {\n        angle = TWOPI / 2.f + angle;\n    } else if (first.y > second.y) {\n        angle = TWOPI + angle;\n    }\n    \n    return angle;\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nfloat getHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\nvec3 vec2Tovec3(vec2 vec) {\n    return vec3(vec.x, vec.y, 0.f);\n}\n\nvec2 getHexCenter(vec2 aspectUV, \n                    vec2 leftBottom, \n                    vec2 leftTop, \n                    vec2 rightBottom, \n                    vec2 rightTop,\n                    float aspectHexGridXIncrement, \n                    float hexGridYIncrement,\n                    float aspectHexRadius) {\n    vec2 hexCenter = vec2(-1.f, -1.f); \n\n    if (isHexCenter(leftBottom, aspectHexGridXIncrement, hexGridYIncrement)) {\n        vec2 hexDiagRight = leftBottom + vec2(aspectHexRadius, 0.f);\n        vec2 hexDiagLeft = leftTop + vec2(aspectHexRadius / 2.f, 0.f);\n        vec2 sharedEdgeVector = normalize(vec2(hexDiagLeft - hexDiagRight));\n        vec2 sharedToRightTopVector = normalize(vec2(rightTop - hexDiagRight));\n        vec2 sharedToUVVector = normalize(vec2(aspectUV - hexDiagRight));\n\n        vec3 crossRightTop = cross(vec2Tovec3(sharedEdgeVector), \n                                    vec2Tovec3(sharedToRightTopVector));\n        vec3 crossUV = cross(vec2Tovec3(sharedEdgeVector), \n                                vec2Tovec3(sharedToUVVector));\n\n        hexCenter = (crossRightTop.z == crossUV.z) || \n            (crossRightTop.z < 0.f && crossUV.z < 0.f) || \n            (crossRightTop.z > 0.f && crossUV.z > 0.f) ? rightTop : leftBottom;\n    } else {\n        vec2 hexDiagRight = leftTop + vec2(aspectHexRadius, 0.f);\n        vec2 hexDiagLeft = rightBottom - vec2(aspectHexRadius, 0.f);\n        vec2 sharedEdgeVector = normalize(vec2(hexDiagRight - hexDiagLeft));\n        vec2 sharedToRightBottomVector = normalize(vec2(rightBottom - hexDiagLeft));\n        vec2 sharedToUVVector = normalize(vec2(aspectUV - hexDiagLeft));\n\n        vec3 crossRightBottom = cross(vec2Tovec3(sharedEdgeVector), \n                                        vec2Tovec3(sharedToRightBottomVector));\n        vec3 crossUV = cross(vec2Tovec3(sharedEdgeVector), \n                                vec2Tovec3(sharedToUVVector));\n\n        hexCenter = crossRightBottom.z == crossUV.z || \n            (crossRightBottom.z < 0.f && crossUV.z < 0.f) || \n            (crossRightBottom.z > 0.f && crossUV.z > 0.f) ? rightBottom : leftTop;\n    }\n\n    return hexCenter;\n}\n\nvec2[6] getHexVertices(vec2 hexCenter, float hexRadius) {\n    vec2[6] hexVertices;\n    \n    float rotationIncrement = TWOPI / 6.;\n    \n    vec2 firstVertex = vec2(hexRadius, 0.) * createRotationMatrix(rotationIncrement * 2.);\n    \n    for (int i=0; i<6; ++i) {\n        hexVertices[i] = firstVertex * createRotationMatrix(rotationIncrement * float(i)) + hexCenter;\n    }\n    \n    return hexVertices;\n}\n\nfloat getEdgeCoefficient(vec2 uv, vec2 hexCenter, float hexRadius, float radialVal) {\n    vec2 adjustedUv = uv - hexCenter;\n    float adjustmentRotation = mod(radialVal, TWOPI / 6.);\n    mat2x2 adjsutmentRotationMatrix = createRotationMatrix(adjustmentRotation);\n    adjustedUv = adjustedUv * adjsutmentRotationMatrix;\n    \n    float radialLerp = mod(radialVal, 1./6.) / (1./6.);\n    radialLerp = .5 - (radialLerp > .5 ? 1. - radialLerp : radialLerp);\n    float operativeAngle = radialLerp * TWOPI / 6.;\n    \n    float tangentDistance = cos(TWOPI / 12.) * hexRadius;\n    \n    float maxToEdge = tangentDistance / cos(operativeAngle);\n    return distance(uv, hexCenter) / maxToEdge;\n}\n\nfloat getRadialVal(vec2 hexCenter, vec2 p) {\n    float offsetAngle = getOffsetAngle(hexCenter, p);\n    offsetAngle = mod(TWOPI - offsetAngle + 3.f * TWOPI / 6.f, TWOPI);\n    return offsetAngle / TWOPI;\n}\n\nHexData getHexData(\n    vec2 uv, \n    float hexRadius, \n    float hexGridXIncrement,\n    float hexGridYIncrement) \n{\n    float aspectHexGridXIncrement = hexGridXIncrement;\n\n    float leftEdge = floor(uv.x / aspectHexGridXIncrement) * aspectHexGridXIncrement;\n    float rightEdge = leftEdge + aspectHexGridXIncrement;\n    float bottomEdge = floor(uv.y / hexGridYIncrement) * hexGridYIncrement;\n    float topEdge = bottomEdge + hexGridYIncrement;\n\n    \n    vec2 leftBottom = vec2(leftEdge, bottomEdge);\n    vec2 leftTop = vec2(leftEdge, topEdge);\n    vec2 rightTop = vec2(rightEdge, topEdge);\n    vec2 rightBottom = vec2(rightEdge, bottomEdge);\n\n    float aspectHexRadius = hexRadius;\n    vec2 hexCenter = getHexCenter(uv,\n                            leftBottom, \n                            leftTop, \n                            rightBottom, \n                            rightTop, \n                            aspectHexGridXIncrement, \n                            hexGridYIncrement,\n                            aspectHexRadius);\n    \n    float distMin = 6. * u_HexRadius;\n    float distMax = 4. * u_HexRadius + 4. * cos(SIXTY_DEGREES / 2.) * u_HexRadius;\n    \n    HexData hexData;\n    hexData.radialVal = getRadialVal(hexCenter, uv);\n    hexData.hexCenter = hexCenter;\n    hexData.distFromHexCenter = distance(uv, hexCenter) / hexRadius;\n    hexData.hexVertices = getHexVertices(hexCenter, hexRadius);\n    hexData.edgeCoefficient = getEdgeCoefficient(uv, hexCenter, hexRadius, hexData.radialVal);\n    hexData.radialLerp = mod(hexData.radialVal, 1./6.) / (1./6.);\n     \n    float distTotal = 0.;\n    for (int i=0; i<6; ++i) {\n        distTotal += distance(uv, hexData.hexVertices[i]);\n    }\n    hexData.sumDistCoefficient = (distTotal - distMin) / (distMax - distMin);\n    \n    return hexData;\n}\n\nfloat getVal(HexData hexData, vec2 uv, float timeOffset) {\n    vec2 hexCenter = hexData.hexCenter;\n    float pointRadius = u_HexRadius * .1;\n    \n    float timeVal = (sin((iTime * .5) + timeOffset * TWOPI) + 1.) / 2.;\n    float timeIncrement = 8.;\n    //timeVal = getHoldTransitionValue(0., 1., timeIncrement / 4., timeIncrement / 4., iTime * .25 + (timeIncrement * timeOffset));\n    \n    vec2 farRightPoint = hexData.hexCenter + vec2(u_HexRadius, 0.);\n    float shortSide = cos(TWOPI/12.) * u_HexRadius;\n    vec2 secondPoint = rotateAroundAxis(hexData.hexCenter + vec2(shortSide, 0.), hexData.hexCenter, TWOPI / 12.);\n    vec2 thirdPoint = rotateAroundAxis(hexData.hexCenter + vec2(shortSide, 0.), hexData.hexCenter, TWOPI / -12.);\n    vec2 fourthPoint = farRightPoint - vec2(2. * (farRightPoint.x - secondPoint.x), 0.);\n    vec2 fifthPoint = rotateAroundAxis(fourthPoint, hexData.hexCenter, TWOPI / -6.);\n    vec2 sixthPoint = rotateAroundAxis(farRightPoint, hexData.hexCenter, TWOPI / -6.);\n \n    //float val = circleSmoothStepFill(secondPoint, pointRadius, uv, AA);\n    float val = max(0., circleSmoothStepFill(thirdPoint, pointRadius, uv, AA));\n    val = max(val, circleSmoothStepFill(fourthPoint, pointRadius, uv, AA));\n    val = max(val, circleSmoothStepFill(farRightPoint, pointRadius, uv, AA));\n    val = max(val, circleSmoothStepFill(fifthPoint, pointRadius, uv, AA));\n    val = max(val, circleSmoothStepFill(sixthPoint, pointRadius, uv, AA));\n    val = 0.;\n    \n    vec2 connectionPoint = mix(fourthPoint, farRightPoint, timeVal);\n    vec2 connectionPoint2 = mix(fifthPoint, sixthPoint, timeVal);\n    \n    float lineThickness = pointRadius * .4;\n    val = max(val, lineSegmentSmoothStep(thirdPoint, connectionPoint, uv, lineThickness, AA, true));\n    val = max(val, lineSegmentSmoothStep(thirdPoint, connectionPoint2, uv, lineThickness, AA, true));\n    return val;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    AspectRatioData aspectRatioData = getAspectRatioData(iResolution.xy);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * aspectRatioData.scaleMatrix;\n    \n    uv += vec2(iTime * .05, sin(iTime * .05));\n\n    float hexGridXIncrement = 1.5f * u_HexRadius;\n    float hexGridYIncrement = u_HexRadius * sin(SIXTY_DEGREES);\n    \n    HexData hexData = getHexData(\n        uv, \n        u_HexRadius, \n        hexGridXIncrement,\n        hexGridYIncrement);\n        \n    for (int i=0; i<6; i++) {\n        vec2 hexVertex = hexData.hexVertices[i];\n    }\n   \n    \n    int offset = int(hexData.radialVal * 6.);\n    vec2 originalUV = uv;\n    uv = rotateAroundAxis(uv, hexData.hexCenter, (float(offset) * TWOPI / 6.));\n    \n    float timeOffset = hexData.radialVal;\n    \n    float val = getVal(hexData, uv, timeOffset);\n    float val2 = getVal(hexData, uv, timeOffset * -1.);\n    float val3 = getVal(hexData, uv, 0.);\n    float val4 = getVal(hexData, uv, hexData.radialLerp);\n    \n    vec4 color1 = vec4(vec3(0., 0., mix(.5, 1., val4)), 1.0);\n    \n    float colorMix = getHoldTransitionValue(0., 1., 10., 2., iTime);\n    vec4 color2 = vec4(vec3(val * .8, val2 * .8, .5), 1.0);\n    vec4 color3 = vec4(vec3(0., val2 * .8, .5), 1.0);\n    vec4 color4 = vec4(vec3(val * .8, 0., .5), 1.0);\n    \n    vec4 oscillateColor = mix(color3, color4, colorMix);\n    vec4 oscCombined = mix(color2, oscillateColor, getHoldTransitionValue(0., 1., 5., 1., iTime));\n\n    fragColor = mix(color1, color2, vec4(getHoldTransitionValue(0., 1., 10., 2., iTime)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}