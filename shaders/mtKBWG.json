{
    "Shader": {
        "info": {
            "date": "1702446860",
            "description": "the goal was to compress a dual-quaternion down to 7 components instead of 8.\n\na \"heptanion\" can be blended with other heptanions\n\nclick to add a spinning transform to the heptanion applied to the gizmo",
            "flags": 0,
            "hasliked": 0,
            "id": "mtKBWG",
            "likes": 4,
            "name": "HEPTANION transformation",
            "published": 3,
            "tags": [
                "3d",
                "vector",
                "quaternion",
                "rotation",
                "transformation",
                "pga",
                "heptanion"
            ],
            "usePreview": 0,
            "username": "ENDESGA",
            "viewed": 261
        },
        "renderpass": [
            {
                "code": "// HEPTANION\n// compressing a dual-quaternion down to 7 elements\n// copyright @ENDESGA\n\n#define tau 6.283185307179586476925286766559\n\n// Euler Colourspace https://www.shadertoy.com/view/mtsBDl\n#define e (exp(1.))\n#define E(x) ((e - exp(1. - x)) / (e - 1.))\n\n#define quat vec4\n#define lquat vec3\n\nquat quat_add( quat a, quat b ) { return quat( a.xyz + b.xyz, a.w + b.w ); }\nquat quat_mul( quat a, quat b ) { return quat( a.w * b.xyz + b.w * a.xyz + cross( a.xyz, b.xyz ), a.w * b.w - dot( a.xyz, b.xyz ) ); }\n\nquat new_quat( vec3 axis, float angle )\n{\n\treturn quat( normalize( axis ) * sin( angle / 2. ), cos( angle / 2. ) );\n}\n\nlquat quat_to_lquat( quat q )\n{\n\tfloat a = acos( clamp( q.w, -1.0, 1.0 ) );\n\tfloat sina = sin( a );\n\tif( sina < .0001 ) return lquat( 0 );\n\treturn normalize( q.xyz ) * a;\n}\n\nquat lquat_to_quat( lquat lq )\n{\n\tfloat len = length( lq );\n\tif( len < .0001 ) return quat( 0, 0, 0, 1 );\n\treturn quat( normalize( lq ) * sin( len ), cos( len ) );\n}\n\n// the heptanion structure :: 3 + 4\nstruct hepta\n{\n\tlquat r;\n\tquat d;\n};\n\nlquat lquat_mul( lquat a, lquat b )\n{\n\tfloat l = length( a );\n\tquat q1 = quat( normalize( a ) * sin( l ), cos( l ) );\n\n\tl = length( b );\n\tvec3 axis2 = ( l < .0001 ) ? vec3( 0 ) : normalize( b );\n\tquat q2 = quat( axis2 * sin( l ), cos( l ) );\n\n\treturn normalize( q1.w * q2.xyz + q2.w * q1.xyz + cross( q1.xyz, q2.xyz ) ) *\n\t\tacos( clamp( q1.w * q2.w - dot( q1.xyz, q2.xyz ), -1.0, 1.0 ) );\n}\n\nhepta hepta_mul( hepta a, hepta b )\n{ // within functions the log-quat multiply can be simplied to a+b\n\treturn hepta( a.r + b.r, quat_add( quat_mul( lquat_to_quat( a.r ), b.d ), quat_mul( a.d, lquat_to_quat( b.r ) ) ) );\n}\n\nhepta hepta_trans( hepta a, hepta b )\n{\n\treturn hepta( lquat_mul( a.r, b.r ), quat_add( quat_mul( lquat_to_quat( a.r ), b.d ), quat_mul( a.d, lquat_to_quat( b.r ) ) ) );\n}\n\nvec3 vec_trans( vec3 p, hepta d )\n{\n\treturn hepta_mul( hepta_mul( d, hepta( lquat( 0 ), quat( p, 0 ) ) ), hepta( -d.r, quat( d.d.xyz, -d.d.w ) ) ).d.xyz;\n}\n\nhepta hepta_slerp( hepta dq1, hepta dq2, float t )\n{\n\tquat dq1r = lquat_to_quat( dq1.r );\n\tquat dq2r = lquat_to_quat( dq2.r );\n\n\tfloat dp = dot( dq1r, dq2r );\n\n\tif( dp < 0. )\n\t{\n\t\tdq1r = -dq1r;\n\t\tdq1.d = -dq1.d;\n\t\tdp = -dp;\n\t}\n\n\tfloat o = acos( clamp( dp, -1., 1. ) );\n\tfloat iso = 1./sin( o );\n\n\tif( iso > 10000. )\n\t{\n\t\tdq1r = mix( dq1r, dq2r, t );\n\t\tdq1.d = mix( dq1.d, dq2.d, t );\n\t}\n\telse\n\t{\n\t\tfloat s1 = sin( ( 1. - t ) * o ) * iso;\n\t\tfloat s2 = sin( t * o ) * iso;\n\n\t\tdq1r = s1 * dq1r + s2 * dq2r;\n\t\tdq1.d = s1 * dq1.d + s2 * dq2.d;\n\t}\n\n\tdq1.r = quat_to_lquat( dq1r );\n\n\treturn dq1;\n}\n\nhepta new_hepta_ypr( float yaw, float pitch, float roll, vec3 pos )\n{\n\tquat dir = quat_mul(\n\t\tnew_quat( vec3( 0, 0, 1 ), yaw ),\n\t\tquat_mul(\n            new_quat( vec3( 1, 0, 0 ), pitch ),\n\t\t\tnew_quat( vec3( 0, 1, 0 ), roll )\n\t\t)\n\t);\n\treturn hepta( quat_to_lquat( dir ), quat_mul( quat( pos, 0 ), dir ) * .5 );\n}\n\nhepta new_hepta( vec3 axis, float angle, vec3 pos )\n{\n\tquat dir = new_quat( axis, angle );\n\treturn hepta( quat_to_lquat( dir ), quat_mul( quat( pos, 0 ), dir ) * .5 );\n}\n\n//\n\nvec3 light_dir = vec3( 0 );\n\nvoid sphere( vec3 ro, vec3 rd, vec3 pos, float rad, vec3 rgb, inout vec4 rgbd )\n{\n\tvec3 oc = ro - pos;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - rad * rad;\n\tfloat h = b * b - c;\n\tif( h < 0. ) return;\n\n\th = sqrt( h );\n\tfloat t = -b - h;\n\tvec3 p = ro + t * rd;\n\tvec3 normal = normalize( p - pos );\n\n\tfloat diff = max( dot( normal, light_dir ), .2 );\n\tfloat d = 1. - ( 1. / distance( ro, p ) );\n\tif( d <= rgbd.w )\n\t{\n\t\trgbd.w = d;\n\t\trgbd.rgb = diff * rgb;\n\t}\n}\n\nvoid cylinder( vec3 ro, vec3 rd, vec3 pos_a, vec3 pos_b, float rad, vec3 rgb, inout vec4 rgbd )\n{\n\tvec3 ba = pos_b - pos_a;\n\tvec3 oa = ro - pos_a;\n\tvec3 ob = ro - pos_b;\n\n\tvec3 m0 = cross( rd, ba );\n\tvec3 m1 = cross( oa, ba );\n\tfloat md = dot( m0, m0 );\n\tfloat b = 2. * dot( m0, m1 );\n\tfloat bd = dot( ba, ba );\n\n\tfloat h = b * b - 4. * md * ( dot( m1, m1 ) - rad * rad * bd );\n\tif( h < 0. ) return;\n\n\th = sqrt( h );\n\tfloat t = ( -b - h ) / ( 2. * md );\n\tfloat y = dot( oa, ba ) + t * dot( rd, ba );\n\n\tif( y > 0. && y < bd )\n\t{\n\t\tvec3 p = ro + rd * t;\n\t\tfloat d = 1. - ( 1. / distance( ro, p ) );\n\t\tif( d <= rgbd.w )\n\t\t{\n\t\t\trgbd.w = d;\n\t\t\trgbd.rgb = max( dot( normalize( p - ( pos_a + ba * y / bd ) ), light_dir ), .2 ) * rgb;\n\t\t}\n\t}\n}\n\nvec4 hash( float n )\n{\n\tvec4 x = fract( sin( vec4( n + 1., n + 3., n + 5., n + 7. ) ) * 43758.5453 );\n\treturn 2. * x - 1.;\n}\n\nvoid mainImage( out vec4 C, in vec2 F, in float T )\n{\n\tfloat time = T;\n\tvec2 uv = ( F - iResolution.xy * .5 ) / iResolution.y;\n\tvec3 ro = vec3(cos(T * -.25) * 3.0, sin(T * -.25) * 3.0, 0.0);\n    vec3 center_dir = normalize(-ro);\n\n    vec3 right = normalize(cross(center_dir, vec3(0.0, 0.0, 1.0)));\n\n    float scale = tan(tau*.125);\n\n    vec3 rd = normalize(uv.x * scale * right + center_dir + uv.y * scale * vec3(0,0,1));\n\n\n\tlight_dir = normalize((-rd + ( vec3( -1, -1, 1 ) )) * .5);\n\n\t//\n\n    vec3 tlogquat00 = normalize( hash( floor( time ) ).xyz );\n    vec3 tlogquat0 = normalize( hash( floor( time ) + 1.).xyz );\n\tvec3 tlogquat1 = normalize( hash( floor( time ) + 2.).xyz );\n\tvec3 tlogquat2 = normalize( hash( floor( time ) + 3. ).xyz );\n\tvec3 tlogquat3 = normalize( hash( floor( time ) + 4. ).xyz );\n    vec3 tlogquat4 = normalize( hash( floor( time ) + 5. ).xyz );\n    vec3 tlogquat5 = normalize( hash( floor( time ) + 6.).xyz );\n    \n    vec3 logquat0 = (tlogquat00 + tlogquat1) * tau;\n    vec3 logquat1 = (tlogquat0 +  tlogquat2) * tau;\n    vec3 logquat2 = (tlogquat1 +  tlogquat3) * tau;\n    vec3 logquat3 = (tlogquat2 +  tlogquat4) * tau;\n    vec3 logquat4 = (tlogquat3 +  tlogquat5) * tau;\n    \n    vec3 tpos00 = normalize( hash( floor( time ) ).xyz );\n    vec3 tpos0 = normalize( hash( floor( time ) + 1. ).xyz );\n\tvec3 tpos1 = normalize( hash( floor( time ) + 2. ).xyz );\n\tvec3 tpos2 = normalize( hash( floor( time ) + 3. ).xyz );\n\tvec3 tpos3 = normalize( hash( floor( time ) + 4. ).xyz );\n    vec3 tpos4 = normalize( hash( floor( time ) + 5. ).xyz );\n    vec3 tpos5 = normalize( hash( floor( time ) + 6. ).xyz );\n    \n    vec3 pos0 = (tpos00 + tpos0 + tpos1) * .5;\n    vec3 pos1 = (tpos0 + tpos1 + tpos2) * .5;\n    vec3 pos2 = (tpos1 + tpos2 + tpos3) * .5;\n    vec3 pos3 = (tpos2 + tpos3 + tpos4) * .5;\n    vec3 pos4 = (tpos3 + tpos4 + tpos5) * .5;\n\n    hepta tdq0 = new_hepta_ypr( logquat0.x, logquat0.y, logquat0.z, pos0 );\n\thepta tdq1 = new_hepta_ypr( logquat1.x, logquat1.y, logquat1.z, pos1 );\n\thepta tdq2 = new_hepta_ypr( logquat2.x, logquat2.y, logquat2.z, pos2 );\n\thepta tdq3 = new_hepta_ypr( logquat3.x, logquat3.y, logquat3.z, pos3 );\n    hepta tdq4 = new_hepta_ypr( logquat4.x, logquat4.y, logquat4.z, pos4 );\n    \n    hepta dq1 = hepta_slerp( tdq0, tdq2, .5 );\n    hepta dq2 = hepta_slerp( tdq1, tdq3, .5 );\n    hepta dq3 = hepta_slerp( tdq2, tdq4, .5 );\n\n\tfloat smoothtime = (mod(time, 1.) + smoothstep( 0., 1., fract( time ) )) * .5;\n\n\thepta h1 = hepta_slerp(dq1, dq2, smoothtime);\n\thepta h15 = hepta_slerp( dq2, dq3, smoothtime * .5 );\n\thepta h2 = hepta_slerp( dq2, dq3, smoothtime );\n\n\tif( iMouse.z > 0. ) h1 = hepta_trans( h1, new_hepta( vec3( 1 ), time * 12., vec3( 0 ) ) );\n\n\tvec4 rgbd = vec4( 0, 0, 0, 1 );\n\n\tvec3 s1 = vec_trans( vec3( 0 ), h1 );\n\tvec3 s15 = vec_trans( vec3( 0 ), h15 );\n\tvec3 s2 = vec_trans( vec3( 0 ), h2 );\n\n\tvec3 ds1 = vec_trans( vec3( 0 ), dq1 );\n\tvec3 ds2 = vec_trans( vec3( 0 ), dq2 );\n\tvec3 ds3 = vec_trans( vec3( 0 ), dq3 );\n\n    vec3 ds15 = mix( ds1, ds2, smoothtime );\n\n\tsphere( ro, rd, ds15, .00625, vec3( 1, 1, 0 ), rgbd );\n\tcylinder( ro, rd, ds15, ds2, .0125, vec3( 1, 1, 0 ), rgbd );\n\tsphere( ro, rd, ds2, .025, vec3( 1, 1, 0 ), rgbd );\n\n\tcylinder( ro, rd, s1, ds15, .0125, vec3( 1, 1, 0 ), rgbd );\n\tsphere( ro, rd, ds15, .0125, vec3( 1, 1, 0 ), rgbd );\n\n\tcylinder( ro, rd, ds2, s15, .00625, vec3( 1, 0, 1 ), rgbd );\n\tsphere( ro, rd, s15, .00625, vec3( 1, 0, 1 ), rgbd );\n\tcylinder( ro, rd, s15, s2, .00625, vec3( 1, 0, 1 ), rgbd );\n\tsphere( ro, rd, s2, .00625, vec3( 1, 0, 1 ), rgbd );\n\n\tsphere( ro, rd, ds3, .025, vec3( 1,0,1 ), rgbd );\n\n\t//\n\n\tsphere( ro, rd, s1, .15, vec3( 1 ), rgbd );\n    \n    {\n        vec3 sx = vec_trans( vec3( .25, 0, 0 ), dq2 );\n        cylinder( ro, rd, ds2, sx, .0125, vec3( 1, 0, 0 ), rgbd );\n        sphere( ro, rd, sx, .025, vec3( 1., 0, 0 ), rgbd );\n\n        vec3 sy = vec_trans( vec3( 0, .25, 0 ), dq2 );\n        cylinder( ro, rd, ds2, sy, .0125, vec3( 0, 1, 0 ), rgbd );\n        sphere( ro, rd, sy, .025, vec3( 0, 1, 0 ), rgbd );\n\n        vec3 sz = vec_trans( vec3( 0, 0, .25 ), dq2 );\n        cylinder( ro, rd, ds2, sz, .0125, vec3( 0, 0, 1 ), rgbd );\n        sphere( ro, rd, sz, .025, vec3( 0, 0, 1 ), rgbd );\n    }\n\n    {\n        vec3 sx = vec_trans( vec3( .5, 0, 0 ), h1 );\n        cylinder( ro, rd, s1, sx, .05, vec3( 1, 0, 0 ), rgbd );\n        sphere( ro, rd, sx, .075, vec3( 1., 0, 0 ), rgbd );\n\n        vec3 sy = vec_trans( vec3( 0, .5, 0 ), h1 );\n        cylinder( ro, rd, s1, sy, .05, vec3( 0, 1, 0 ), rgbd );\n        sphere( ro, rd, sy, .075, vec3( 0, 1, 0 ), rgbd );\n\n        vec3 sz = vec_trans( vec3( 0, 0, .5 ), h1 );\n        cylinder( ro, rd, s1, sz, .05, vec3( 0, 0, 1 ), rgbd );\n        sphere( ro, rd, sz, .075, vec3( 0, 0, 1 ), rgbd );\n    }\n\n\t//\n\n\tC = vec4( E(rgbd.rgb), 1.0 );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "int _N = 3;\n#define mainImage mainImage0(out vec4 O, vec2 U, float T);        \\\nvoid mainImage(out vec4 O, vec2 U) {                     \\\n    vec4 o; O = vec4(0);                                 \\\n    for (int k=0; k < _N*_N; k++ )                       \\\n      { mainImage0(o,U+vec2(k%_N-_N/2,k/_N-_N/2)/float(_N),iTime+sqrt(float(k)*.0001)); O += o; }  \\\n    O /= float(_N*_N);                                   \\\n} \\\nvoid mainImage0",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}