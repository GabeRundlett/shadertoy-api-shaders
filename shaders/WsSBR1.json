{
    "Shader": {
        "info": {
            "date": "1589439593",
            "description": "The principle is at the base of sphere-marching / sphere-surfing of scenes using optimization 3D structure  which coarse voxels contains biggest sphere radius not intersecting geometry. When scene is directly defined with SDF, it's even more direct :-)",
            "flags": 0,
            "hasliked": 0,
            "id": "WsSBR1",
            "likes": 8,
            "name": "short ray-marching of SDF : tuto",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "short"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 612
        },
        "renderpass": [
            {
                "code": "// variant of https://shadertoy.com/view/XsdBW8\n\n#define PI     3.1415927\n#define rot(a)  mat2(cos(a + vec4(0,PI/2.,-PI/2.,0) ) )         // rotation matrix.  golf: https://www.shadertoy.com/view/XlsyWX\n#define hue(v) ( .5 + .5 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) ) // https://www.shadertoy.com/view/ll2cDc\n\nvoid mainImage(out vec4 O, vec2 u) {\n    \n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y;                  // normalized screen coordinates\n    vec3  D = normalize ( vec3(U, -3) ),           // ray direction. 3 = zoom (narrow opening angle)\n          P = vec3(0,0,5),                         // camera pos, then marching point along ray \n          q,a;\n    \n    mat2 M = rot(.5*iTime);\n    P.xy*= M, P.yz *= M; D.xy*= M, D.yz *= M;     // camera transform\n    \n    float d = 1e5,_d, id, obj = -1., i;\n    for ( i=0.; i < 100.  && d > .01 ; i++ )       // === march the ray\n    {\n        q = P;                                     // --- transforms\n      //q.xy*= M, q.yz *= M;                       // inv camera transform better factored out of loop\n        id = dot(floor((q+5.)/10.),vec3(1,17.3,27.1));  // obj id (random hash of 3D tile position )\n        q  = mod(q+5.,10.) - 5.;                        // tiling space with shapes\n        q.xy*= rot(id), q.yz *= rot(id);           // object rotation (different for each)\n      //q += sin(id);                              // object translation\n        \n        _d = d;                                    // --- dist to closest geometry\n        d = length(q) - 1.;                        // dist to SDF to sphere\n        d = max(d, - ( length(q) - .8 ) );         // max(-): substract: SDF to smaller sphere\n        a = abs(q);\n      //d = min(d,  max(a.x,max(a.y,a.z)) - .7 );  // min: add. SDF to box\n      //d = max(d,  max(a.x,max(a.y,a.z)) - .7 );  // max(+): intersect. SDF to box\n        d = max(d,  min(a.x,min(a.y,a.z)) - .1 );  // max(+): intersect. SDF to antibox\n        if (d!=_d) obj = id;                       // obj = closest object id\n        \n        P += d*D;                                  // --- step forward = dist to closest obj\n    }\n    O =    hue(obj)                                // coloring = hue( object id ).\n        * ( 1.-i/67.);                             // pseudo-shading = 1. - iterations\n                   // since the less iterations, the most facing object ( distance vect parallel to ray )\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}