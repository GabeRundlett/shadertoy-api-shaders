{
    "Shader": {
        "info": {
            "date": "1416962893",
            "description": "Cheap FM based Reverberation effect.\nBasic idea - modulate carrier signal with low frequency noise.",
            "flags": 8,
            "hasliked": 0,
            "id": "MdjXWc",
            "likes": 52,
            "name": "FM Reverb",
            "published": 3,
            "tags": [
                "sound",
                "fft",
                "fm",
                "reverb",
                "spectrogram"
            ],
            "usePreview": 0,
            "username": "and",
            "viewed": 3047
        },
        "renderpass": [
            {
                "code": "// FM Reverb\n// Created by Dmitry Andreev - and'2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.1415927\n\n// Hash from https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float tt = fract(t);\n    float tn = t - tt;\n    tt = smoothstep(0.0, 1.0, tt);\n\n    vec2 n0 = noise(floor(tn + 0.0) / fq);\n    vec2 n1 = noise(floor(tn + 1.0) / fq);\n\n    return mix(n0, n1, tt);\n}\n\nfloat sine(float x)\n{\n    return sin(2.0 * PI * x);\n}\n\nvec2 sine(vec2 v) { return vec2(sine(v.x), sine(v.y)); }\n\nvec2 synthWave(float t)\n{\n    bool do_reverb = mod(t, 8.0) > 4.0;\n    t = mod(t, 2.0);\n\n    float f0 = 880.0;\n\n    vec2 w = vec2(sine(t * f0) * exp(-t * 2.5));\n\n    if (do_reverb)\n    {\n        vec2 r = lpnoise(t,  100.0)\n               + lpnoise(t,  550.0) * 0.2\n               + lpnoise(t, 1050.0) * 0.1 * exp(-t * 5.0);\n\n        w += sine(t * f0 + r * 0.1) * exp(-t * 2.0);\n        w -= sine(t * f0          ) * exp(-t * 2.0);\n    }\n\n    w *= 1.0 - exp(-t * 800.0);\n\n    return w;\n}\n\n//\n\nfloat remap(float low, float high, float x)\n{\n    return clamp((x - low) / (high - low), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  uv = fragCoord.xy / iResolution.xy;\n    float gt = (uv.x - 1.0) * 5.0 + mod(iTime, 8.0);\n\n    // Fourier transform\n    const float n = 256.0;\n    float fi = floor(uv.y * n * 0.5);\n    float angle = 2.0 * PI * fi / n;\n    vec2  di = vec2(cos(angle), sin(angle));\n    vec2  df = vec2(1.0, 0.0);\n    vec2  f  = vec2(0.0, 0.0);\n\n    for (int i = 0; i < int(n); i++)\n    {\n        float x = float(i) / n;\n\n        float t = x * 0.05 + gt;\n        vec2  w = synthWave(t);\n        float v = (w.x + w.y) * 0.5;\n\n        // Hann window\n        v *= 0.5 * (1.0 - cos(2.0 * PI * x));\n\n        f += df * v;\n        df = df.xy * di.x + vec2(-1.0, 1.0) * df.yx * di.y;\n    }\n\n    float y = 0.5 * length(f);\n    y = sqrt(y / (1.0 + y));\n    y = clamp(y, 0.0, 1.0);\n\n    vec3 clr = vec3(0.0);\n    clr = mix(clr, vec3(0.2, 0.2, 0.7), remap(0.00, 0.25, y));\n    clr = mix(clr, vec3(0.9, 0.1, 0.0), remap(0.25, 0.50, y));\n    clr = mix(clr, vec3(1.0, 1.0, 0.3), remap(0.50, 0.75, y));\n    clr = mix(clr, vec3(1.0, 1.0, 1.0), remap(0.75, 1.00, y));\n\n    fragColor = vec4(clr, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "// FM Reverb\n// Created by Dmitry Andreev - and'2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.1415927\n\n// Hash from https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float tt = fract(t);\n    float tn = t - tt;\n    tt = smoothstep(0.0, 1.0, tt);\n\n    vec2 n0 = noise(floor(tn + 0.0) / fq);\n    vec2 n1 = noise(floor(tn + 1.0) / fq);\n\n    return mix(n0, n1, tt);\n}\n\nfloat sine(float x)\n{\n    return sin(2.0 * PI * x);\n}\n\nvec2 sine(vec2 v) { return vec2(sine(v.x), sine(v.y)); }\n\nvec2 synthWave(float t)\n{\n    bool do_reverb = mod(t, 8.0) > 4.0;\n    t = mod(t, 2.0);\n    \n    float f0 = 880.0;\n\n    vec2 w = vec2(sine(t * f0) * exp(-t * 2.5));\n    \n    if (do_reverb)\n    {\n        vec2 r = lpnoise(t,  100.0)\n               + lpnoise(t,  550.0) * 0.2\n               + lpnoise(t, 1050.0) * 0.1 * exp(-t * 5.0);\n\n    \tw += sine(t * f0 + r * 0.1) * exp(-t * 2.0);\n    \tw -= sine(t * f0          ) * exp(-t * 2.0);\n    }\n\n    w *= 1.0 - exp(-t * 800.0);\n\n    return w;\n}\n\n//\n\nvec2 mainSound( in int samp,float t)\n{\n    vec2 w = synthWave(t);\n    \n    w *= smoothstep(0.0, 0.04, t);\n    w *= smoothstep(60.0, 58.0, t);\n    \n    return w;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}