{
    "Shader": {
        "info": {
            "date": "1519187915",
            "description": "This looked cooler in my head. I'm so bad at shaders",
            "flags": 0,
            "hasliked": 0,
            "id": "XddcDM",
            "likes": 2,
            "name": "4P_Test",
            "published": 3,
            "tags": [
                "trianglesiguess"
            ],
            "usePreview": 0,
            "username": "FiveOutOfKevin",
            "viewed": 547
        },
        "renderpass": [
            {
                "code": "vec3 color1 = vec3(113.0/255.0, 165.0/255.0, 16.0/255.0);\nvec3 color2 = vec3(64.0/255.0, 126.0/255.0, 10.0/255.0);\nvec3 color3 = vec3(29.0/255.0, 87.0/255.0, 5.0/255.0);\nvec3 color4 = vec3(173.0/255.0, 203.0/255.0, 24.0/255.0);\nvec3 color5 = vec3(7.0/255.0, 48.0/255.0, 2.0/255.0);\nint numColors = 4;\n\n//size of the side of each triangle (in screen space)\nfloat triEquLen = 0.2;\n\nfloat constTimeMod = .1;\n\nint getUVTriColorIndex(vec2 uv)\n{\n    float halfLen = triEquLen * .5;\n    //fake it 'till you make it\n    float triHeight = sqrt(.8*halfLen);\n    \n    //need to do this before collecting my fake \"tri-space\" transforms\n    uv.y += iTime*constTimeMod;\n    \n    //0 or 1\n    int rowFlip = int(floor(uv.y / triHeight))%2;\n    \n    uv.x += -iTime*.1+(halfLen*float(rowFlip));\n\t\n     //the remainder (in a weird-space, basically halftri, maintri, halftri)\n    vec2 triRemainder = vec2(mod(uv.x, triEquLen), mod(uv.y, triHeight));\n\n    //get which \"half\" of the tri we are in. < 1 we're in the left half, > 1 we're in the right half\n    float triHalfX = triRemainder.x / halfLen;\n    \n    //0=bottom-up, 1=top-down\n    float triSide = min(floor(triHalfX), 1.0);\n    \n    float triLocX = mod(triRemainder.x, halfLen);\n    \n    //mod of the half-x will always return between 0 and 1)\n    //% of distance on X to half + % of distance to full on Y\n\tfloat modSideFloat = (triLocX / halfLen) + \n        \t(abs( (triHeight*triSide) - triRemainder.y) / triHeight);\n    \n    //should be between 0 and 1 and 2??\n    float flooredSideFloat = floor(modSideFloat);\n    \n    int retSideVal = int( modSideFloat + triSide) % 2;\n    \n    //How did I get here?\n\treturn retSideVal + (rowFlip*2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Yes, this is dumb. No, I don't care\n    vec3[] triColors = vec3[](color1,color2,color3, color4, color5);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = vec4(triColors[getUVTriColorIndex(uv)],1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}