{
    "Shader": {
        "info": {
            "date": "1501942245",
            "description": "Quake's gateway to another dimension! Some Intel GPUs may not render the portal's interior - see PortalVortex function for comment and a fix.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdjBWG",
            "likes": 4,
            "name": "Quake Teleporter",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "sdf",
                "portal",
                "quake"
            ],
            "usePreview": 0,
            "username": "k_kondrak",
            "viewed": 1069
        },
        "renderpass": [
            {
                "code": "// ----------------------------------------------------\n//  \"Quake Teleporter\" by Krzysztof Kondrak @k_kondrak\n// ----------------------------------------------------\n\nconst float M_PI = 3.141592;\n\n// --------------------------------------\n// Texture swirl from \"Lava Pool\": \n// https://www.shadertoy.com/view/XdBBDG\n// --------------------------------------\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = smoothstep(0.0, 1.0, f);\n    \n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = texture(iChannel1, (uv + 0.5) / 256.0, -100.0).yx;\n    return mix(rg.x, rg.y, f.z) * 2.0 - 1.0;\n}\n\nvec2 swirl(in vec2 p)\n{\n    return vec2(noise(vec3(p.xy, .33)), noise(vec3(p.yx, .66)));\n}\n\n// ---------------------------------\n//  draw the swirling portal vortex\n// ---------------------------------\nvec3 VortexTexture(in vec2 p)\n{\n    p *= vec2(0.93, -0.93);\n    vec4 col = vec4(1.0);\n\n    for(int i = 0; i < 3; i++) \n        col += texture(iChannel1, p + 0.02 * swirl(3.66 * p + iTime * 0.33)) * col * col;\n\n    // used noise texture has only one channel\n    return (col * 0.033).xxx;\n}\n\n// --------------------------------\n// light and specularity functions\n// --------------------------------\nfloat VisibilityTerm(in float roughness, in float ndotv, in float ndotl)\n{\n    float m2    = roughness * roughness;\n    float visV    = ndotl * sqrt(ndotv * (ndotv - ndotv * m2) + m2);\n    float visL    = ndotv * sqrt(ndotl * (ndotl - ndotl * m2) + m2);\n    return 0.5 / max(visV + visL, 0.00001);\n}\n\nfloat DistributionTerm(in float roughness, in float ndoth)\n{\n    float m2 = roughness * roughness;\n    float d     = (ndoth * m2 - ndoth) * ndoth + 1.0;\n    return m2 / (d * d * M_PI);\n}\n\nvec3 FresnelTerm(in vec3 specularColor, in float vdoth)\n{\n    return clamp(50.0 * specularColor.y, 0.0, 1.0) * specularColor + (1.0 - specularColor) * pow(1.0 - vdoth, 5.0);\n}\n\nvec3 LightSpecular(in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in float roughness, in vec3 specularColor)\n{\n    vec3 halfVec = normalize(viewDir + lightDir);\n\n    float vdoth = clamp(dot(viewDir, halfVec ), 0.0, 1.0);\n    float ndoth = clamp(dot(normal,     halfVec ), 0.0, 1.0);\n    float ndotv = clamp(dot(normal,     viewDir ), 0.0, 1.0);\n    float ndotl = clamp(dot(normal,     lightDir), 0.0, 1.0);\n    \n    vec3  f = FresnelTerm(specularColor, vdoth);\n    float d = DistributionTerm(roughness, ndoth);\n    float v = VisibilityTerm(roughness, ndotv, ndotl);\n    \n    return lightColor * f * (d * v * M_PI * ndotl);\n}\n\n// ---------------------------\n//  signed distance functions\n// ---------------------------\n// see https://iquilezles.org/articles/distfunctions for more!\nfloat Box(in vec3 p, in vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat Subtract(in float a, in float b)\n{\n    return max(a, -b);\n}\n\n// ------------------------\n//  swirling portal vortex\n// ------------------------\nfloat PortalVortex(in vec3 p)\n{\n    // hack for some Intel GPUs that don't render a plain box with no transformation\n    return Subtract(Box(p, vec3(0.4, 0.6, 0.01)), Box(p, vec3(0.001, 0.001, 0.01)));\n    //return Box(p, vec3(0.4, 0.6, 0.01));\n}\n\n// --------------------\n//  outer portal frame\n// --------------------\nfloat PortalFrame(in vec3 p)\n{\n    return Subtract(Box(p, vec3(0.5, 0.66, 0.03)),\n                    Box(p, vec3(0.35, 0.55, 0.55)));\n}\n\n// -----------\n//  rotation\n// -----------\nmat3 rotY(in float a)\n{\n    return mat3(cos(a), 0.0, sin(a),\n                   0.0, 1.0, 0.0,\n               -sin(a), 0.0, cos(a));\n}\n\n// -------------------\n//  portal raymarcher\n// -------------------\n#define MIN_DIST  0.001\n#define MAX_DIST  3.0\n#define NUM_STEPS 40\n#define PORTAL_FRAME  0\n#define PORTAL_VORTEX 1\nfloat Raymarch(in vec3 from, in vec3 to, in mat3 matrix, in int objId)\n{\n    float dist  = MIN_DIST;\n    float depth = 0.0;\n\n    for(int i = 0; i < NUM_STEPS; ++i)\n    {\n        if(dist < MIN_DIST || depth > MAX_DIST) \n            break;\n\n        if(objId == PORTAL_FRAME)\n            dist = PortalFrame((from + to * depth) * matrix);\n        else\n            dist = PortalVortex((from + to * depth) * matrix);\n        depth += dist;\n\n        // past maximum raymarch distance - no surface hit\n        if(depth > MAX_DIST)\n            return 0.0;\n    }\n\n    return depth;\n}\n\n// ----------------\n//  surface normal\n// ----------------\nvec3 SurfaceNormal(in vec3 p, in mat3 matrix, in int objId)\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 v1 = (p + eps.xyy) * matrix;\n    vec3 v2 = (p - eps.xyy) * matrix;\n    vec3 v3 = (p + eps.yxy) * matrix;\n    vec3 v4 = (p - eps.yxy) * matrix;\n    vec3 v5 = (p + eps.yyx) * matrix;\n    vec3 v6 = (p - eps.yyx) * matrix;\n    \n    if(objId == PORTAL_FRAME)\n    {\n        return normalize(-vec3(PortalFrame(v1) - PortalFrame(v2),\n                               PortalFrame(v3) - PortalFrame(v4),\n                               PortalFrame(v5) - PortalFrame(v6)));\n    }\n    else\n    {\n        return normalize(-vec3(PortalVortex(v1) - PortalVortex(v2),\n                               PortalVortex(v3) - PortalVortex(v4),\n                               PortalVortex(v5) - PortalVortex(v6)));\n    }\n}\n\n// -----------------------------\n//  Quake-ish purple cloudy sky\n// -----------------------------\nvec3 Sky(in vec2 p)\n{\n    vec2 offset = vec2(0.0,0.01 * iTime);\n    vec3 color  = vec3(1.0);\n\n    for(int i = 0; i < 3; i++) \n    {\n        color += mix(texture(iChannel2, p - 0.25 * offset + 0.5),\n                     texture(iChannel2, 0.5 * p - offset), \n                     abs(mod(float(i) * 0.666, 2.0) - 1.0)).xyz * color * color;\n    }\n\n    return color * vec3(.0555, .0444, .0666);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv  = fragCoord.xy / iResolution.xy;\n    vec2 pos = (-iResolution.xy + 2.0 * fragCoord.xy)/iResolution.y;\n\n    // raymarch vectors and initial background pixel color\n    vec3 from  = vec3(0.0, 0.0, -1.466);\n    vec3 to    = normalize(vec3(pos.xy, 1.666));\n    vec3 color = Sky(-uv.yx);\n    vec3 lightDir = normalize(vec3(1.0 + sin(0.99 * iTime), 0.5, 1.0 + cos(0.99 * iTime)));\n\n    // any extra rotations/shifts\n    mat3 transform = mat3(1.0); //rotY(0.35 * iTime);\n\n    int objId = PORTAL_FRAME;\n    float t = Raymarch(from, to, transform, objId);\n    \n    if(t == 0.0)\n    {\n        objId = PORTAL_VORTEX;\n        t = Raymarch(from, to, transform, objId);\n    }\n\n    // surface hit?\n    if(t > 0.0)\n    {\n        vec3 p = from + t * to;\n        vec3 n = SurfaceNormal(p, transform, objId);\n        vec3 w = max(abs(n * transform), 0.00001);\n        w /= w.x + w.y + w.z;\n        \n        p *= transform;\n\n        if(objId == PORTAL_FRAME)\n        {\n            vec3 tx = texture(iChannel0, p.yz).xyz;\n            vec3 ty = texture(iChannel0, p.xz).xyz;\n            vec3 tz = texture(iChannel0, p.xy).xyz;\n\n            vec3 tex = tx*w.x + ty*w.y + tz*w.z;\n            \n            // rusty color: \"Quake Logo\" - https://www.shadertoy.com/view/4dKXDy\n            float rustMask     = clamp(tex.r * 3.0 - 0.5, 0.0, 1.0);\n            float roughness    = mix(0.2, 0.6, rustMask);           \n            vec3 diffuseColor  = mix(vec3( 0.0 ), tex, rustMask);\n            vec3 specularColor = mix(tex, vec3(0.04), rustMask);\n            vec3 lightColor    = vec3(1.6);\n            vec3 diffuse = lightColor * clamp(dot(n, lightDir), 0.0, 1.0);\n            \n            diffuseColor *= diffuseColor * vec3(0.94, 0.72, 0.47) * 1.5;\n            color = diffuseColor * (diffuse + 0.2);\n            color *= clamp(abs(sin(0.77 * iTime)) + 0.44, 0.0, 1.0);\n            color += LightSpecular(n, to, lightDir, lightColor, roughness, specularColor);\n        }\n        else\n        {\n            color = VortexTexture(p.yz)*w.x + \n                    VortexTexture(p.xz)*w.y + \n                    VortexTexture(p.xy)*w.z;\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}