{
    "Shader": {
        "info": {
            "date": "1457307847",
            "description": "Simple shader to illustrate and explain in human words the maths behind a possible blob merging equation (there are many possible equations).",
            "flags": 0,
            "hasliked": 0,
            "id": "ld3Xzn",
            "likes": 24,
            "name": "Blobs-DistanceMergingTheory",
            "published": 3,
            "tags": [
                "blobs",
                "log",
                "merging"
            ],
            "usePreview": 0,
            "username": "Bers",
            "viewed": 1007
        },
        "renderpass": [
            {
                "code": "// Author : SÃ©bastien BÃ©rubÃ©\n// Created : June 2015\n// Modified : Jan 2016\n//\n// Simple shader to illustrate and explain in human words the maths behind a possible \n// blob merging equation (there are many possible equations).\n//\n// Before anything, an observation :\n// Note : log(exp(a)) = a\t//Reciprocal\n//           let : a = -kx\n//        log(exp(-kx)) = -kx\n//        log(exp(-kx))/k = -x\n//       -log(exp(-kx))/k = x\n// (see also http://www.rapidtables.com/math/algebra/Ln.htm)\n//\n// In other words, log() is the inververse function of exp().\n// (Similar to arccos(cos(x))=x for x=[-PI to PI])\n//\n// Below, in mergeBlobs(), the addition taking place within the log() is \n// done with the intention of combining distances to each blob in a non-linear way.\n// Here, consider the addition is happening in a \"logarithmic scale\" (inside the log). Because of this\n// logarithmic scale, where the addition occur, the closest distance has a much bigger weight, and \n// distances that are farther are almost unsignificant (because of the logarithmic curve shape).\n//\n// Therefore, because the closest blob has so much weight compared to more distant blobs, \n// the \"merge distance\" only occur when distances are very close, within a small margin.\n// This is the \"distance blend window\". Outside of this window, when 2 blobs are too far from each other,\n// the contribution of the farthest quickly (logarithmically) becomes neglectable.\n//\n// The value \"k\" controls the merge distance (the blend window).\n// It is simply a domain scaling constant. It scales input values BEFORE merging, and \n// rescales back to original scale AFTER merging, therefore only affecting the blend window.\n// When k is high, it is similar to \"zooming out\" in the logarithmic curve, the curve is much less linear,\n// and the merge distance is narrower (e.g. > k = 100.0).\n// When k is low, it is similar to \"zooming in\" (domain stretch) in a section of the logarithmic curve,\n// therefore in that case the curve is much more linear, and the merge distance is wider (e.g. < k = 12.0).\n//\n// Smoothing blobs is very similar & related to smooth minumum function in distance fields, see :\n// https://iquilezles.org/articles/smin\n//\n// License : Creative Commons Non-commercial (NC) license\n\n\n//Input [d1,d2,d3] : the 3 distances to the 3blobs.\nfloat mergeBlobs(float d1, float d2, float d3)\n{\n    float k = 22.0;\n    return -log(exp(-k*d1)+exp(-k*d2)+exp(-k*d3))/k;\n}\n\nvec2 randomizePos(vec2 amplitude, float fTime)\n{\n    return amplitude*vec2(sin(fTime*1.00)+cos(fTime*0.51),\n                          sin(fTime*0.71)+cos(fTime*0.43));\n}\n\nvec3 computeColor(float d1, float d2, float d3)\n{\n    float blobDist = mergeBlobs(d1,d2,d3);\n    float k = 7.0; //k=Color blend distance.\n    float w1 = exp(k*(blobDist-d1)); //R Contribution : highest value when no blending occurs\n    float w2 = exp(k*(blobDist-d2)); //G Contribution\n    float w3 = exp(k*(blobDist-d3)); //b Contribution\n    \n    //Color weighting & normalization\n    vec3 pixColor = vec3(w1,w2,w3)/(w1+w2+w3);\n    \n    //2.5 = lightness adjustment.\n    return 2.5*pixColor;\n}\n\nfloat distanceToBlobs(vec2 p, out vec3 color)\n{\n    //Blob movement range.\n    float mvtAmplitude = 0.15;\n    \n    //Randomized positions.\n    vec2 blob1pos = vec2(-0.250, -0.020)+randomizePos(vec2(0.35,0.45)*mvtAmplitude,iTime*1.50);\n\tvec2 blob2pos = vec2( 0.050,  0.100)+randomizePos(vec2(0.60,0.10)*mvtAmplitude,iTime*1.23);\n\tvec2 blob3pos = vec2( 0.150, -0.100)+randomizePos(vec2(0.70,0.35)*mvtAmplitude,iTime*1.86);\n    \n    //Distance from pixel \"p\" to each blobs\n\tfloat d1 = length(p-blob1pos);\n    float d2 = length(p-blob2pos);\n    float d3 = length(p-blob3pos);\n    \n    //Merge distances, return the distorted distance field to the closest blob.\n    float distTotBlob = mergeBlobs(d1,d2,d3);\n    \n    //Compute color, approximating the contribution of each one of the 3 blobs.\n    color = computeColor(d1,d2,d3);\n        \n    return abs(distTotBlob);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-iResolution.xy*0.5) / iResolution.xx;\n    vec3 blobColor;\n    \n    //Distance from this pixel to the blob (range ~= [0-0.5] )\n    float dist = distanceToBlobs(uv,blobColor);\n    \n    float stripeHz = 20.0;//BW Stripe frequency : 20 Hz frequency (cycles/image unit)\n    float stripeTh = 0.25; //Switchover value, in the [0.-0.5] range. (0.25 = right in the middle)\n    float aa = 0.001; //aa = transition width (pixel \"antialiazing\" or smoothness)\n    float stripeIntensity = smoothstep(stripeTh-aa*stripeHz,stripeTh+aa*stripeHz,abs(fract(dist*stripeHz)-0.5));\n    float blobContourIsovalue = 0.113; //Arbitrary distance from center at which we decide to set the blob boundary.\n    float fBlobLerp = smoothstep(blobContourIsovalue-aa,blobContourIsovalue+aa,dist);\n\n    fragColor = mix(vec4(blobColor,1),vec4(stripeIntensity),fBlobLerp);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}