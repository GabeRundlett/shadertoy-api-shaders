{
    "Shader": {
        "info": {
            "date": "1618473911",
            "description": "my task 2",
            "flags": 32,
            "hasliked": 0,
            "id": "7dfSDr",
            "likes": 1,
            "name": "315_filimonov_v3v0",
            "published": 3,
            "tags": [
                "mashgraph"
            ],
            "usePreview": 0,
            "username": "ivanf",
            "viewed": 200
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 glow = fire_color(2.5) * max(0., 1.1 - 1.8 * length(fragCoord - .5 * iResolution.xy ) / iResolution.y );\n\tvec3 col0 = texture(iChannel3, uv).rgb;\n    vec3 col1 = texture(iChannel2, uv).rgb;\n    fragColor = vec4(.06 * glow + max(col0, .8 * col1), 1.0) + texture(iChannel3, uv) + texture(iChannel0, uv) / float(iFrame + 1);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//MATH CONSTANTS\nconst float INF = 1e10;\nconst int rayMachingTimes = 20;\n\n// CAMERA SETTINGS\nconst float camera_x = 8.0;\nconst float camera_y =  1.2;\nconst float camera_z = -2.0;\nconst vec3 CAMERA_POS = vec3(camera_x, camera_y, camera_z);\n\n// FIRST LIGHT SOURCE\nconst vec3  LIGHT1_POS = vec3(-3, 1, -2);\nconst float LIGHT1_RADIUS = 0.4;\nconst vec3  LIGHT1_COLOR = vec3(0, 1.0, 1.0);\nconst float LIGHT1_BRIGHTNESS = 10.0f;\n\n// SECOND LIGHT SOURCE\nconst vec3  LIGHT2_POS = vec3(-2.5, 1.2, 4.0);\nconst float LIGHT2_RADIUS = 0.2;\nconst vec3  LIGHT2_COLOR = vec3(0.6, 1.0, 0.0);\nconst float LIGHT2_BRIGHTNESS = 20.0f;\n\n// CUBEMAP\nconst float CUBEMAP_BRIGHTNESS = 0.05;\n\n// OCTAHEDRON\nfloat octahedronScale = 0.8;\nvec3 octahedronShift = vec3(0.0,0.0,0.0);\n\n// MATERALS\nconst int EMISSION = 0;// majorly it's material of the light source. it's spreading light from itself\nconst int DIFFUSE = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\n\n// RANDOM\nvec3 randVals;\nvec3 randDir;\n\n// REFRACTION\nconst float GLASS_N = 1.5;\nconst float AIR_N = 1.0;\nconst float DIAMOND_N = 2.5;\n\n// MATH FUNCTIONS\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\nfloat pow2(float x) \n{\n    return x * x;\n}\n\n\n\n\n\n\n\n// TRACE FUNCTIONS\nfloat tracePolygon(vec3 pos, vec3 dir, vec3 v0, vec3 v1, vec3 v2, out vec3 normal)\n{\n    // Polygon interception with v = pos + t*dir\n    // \n    // Read more about method here: \n    // http://masters.donntu.org/2015/frt/yablokov/library/transl.htm\n    // result = (t, u, v) \n    \n    vec3 result;\n    \n    vec3 T  = pos - v0;\n    vec3 E1 = v1  - v0;\n    vec3 E2 = v2  - v0;\n    \n    vec3 P  = cross(dir, E2);\n    vec3 Q  = cross(T,   E1);\n    \n    \n    float det = dot(P, E1);\n    \n    float t = dot(Q, E2) / det;\n    float u = dot(P, T)  / det;\n    float v = dot(Q, dir) /det ;\n    \n    \n    float A = (v1.y-v0.y)*(v2.z-v0.z) - (v2.y-v0.y)*(v1.z-v0.z);\n    float B = (v1.z-v0.z)*(v2.x-v0.x) - (v2.z-v0.z)*(v1.x-v0.x);\n    float C = (v1.x-v0.x)*(v2.y-v0.y) - (v2.x-v0.x)*(v1.y-v0.y);\n    \n    normal.x = A;\n    normal.y = B;\n    normal.z = C;\n    \n    normal = normalize(normal);\n    \n    if( u >= 0.0 && v >= 0.0 && u + v <= 1.0 && t > 0.0)\n        return t;\n    \n    return INF;\n}\nfloat traceOctahedron(vec3 pos, vec3 dir, float size, vec3 shift, out vec3 normal)\n{\n    // see function traceTriagle to see more information about \"scale\" parametr\n    float scaleOcta = 1.0/ size;\n    \n    int minIndex = 0;// index of intercepted triagle (from 0 to 7)\n    \n    vec3 normal1;\n    vec3 normal2; \n    vec3 normal3; \n    vec3 normal4; \n    vec3 normal5; \n    vec3 normal6; \n    vec3 normal7; \n    vec3 normal8; \n    \n    \n    \n    ///*\n    vec3 v1 = vec3(shift.x - scaleOcta, shift.y             , shift.z);\n    vec3 v2 = vec3(shift.x            , shift.y - scaleOcta , shift.z);\n    vec3 v3 = vec3(shift.x+scaleOcta  , shift.y             , shift.z);\n    vec3 v4 = vec3(shift.x            , shift.y+scaleOcta   , shift.z);\n    vec3 v5 = vec3(shift.x            , shift.y             , shift.z+scaleOcta);\n    vec3 v6 = vec3(shift.x            , shift.y             , shift.z-scaleOcta);\n    \n    \n    float T1 = tracePolygon (pos, dir, v1, v2, v5, normal1);\n    float T2 = tracePolygon (pos, dir, v2, v3, v5, normal2);\n    float T3 = tracePolygon (pos, dir, v3, v4, v5, normal3);\n    float T4 = tracePolygon (pos, dir, v4, v1, v5, normal4);\n    float T5 = tracePolygon (pos, dir, v1, v2, v6, normal5);\n    float T6 = tracePolygon (pos, dir, v2, v3, v6, normal6);\n    float T7 = tracePolygon (pos, dir, v3, v4, v6, normal7);\n    float T8 = tracePolygon (pos, dir, v4, v1, v6, normal8);\n    //*/\n    /*\n    float T1 = traceTriangle (pos, dir, vec3(scaleOcta, scaleOcta, scaleOcta), shift , normal1);\n    float T2 = traceTriangle (pos, dir, vec3(-scaleOcta, scaleOcta, scaleOcta), shift , normal2);\n    float T3 = traceTriangle (pos, dir, vec3(scaleOcta, -scaleOcta, scaleOcta), shift , normal3);\n    float T4 = traceTriangle (pos, dir, vec3(-scaleOcta, -scaleOcta, scaleOcta), shift , normal4);\n    float T5 = traceTriangle (pos, dir, vec3(scaleOcta, scaleOcta, -scaleOcta), shift , normal5);\n    float T6 = traceTriangle (pos, dir, vec3(-scaleOcta, scaleOcta, -scaleOcta), shift , normal6);\n    float T7 = traceTriangle (pos, dir, vec3(scaleOcta, -scaleOcta, -scaleOcta), shift , normal7);\n    float T8 = traceTriangle (pos, dir, vec3(-scaleOcta, -scaleOcta, -scaleOcta), shift , normal8);\n    */\n    \n    \n    //find min of all this triagles and minIndex\n    vec3[]  arrayN = vec3[] ( normal1,normal2,normal3,normal4,normal5,normal6,normal7,normal8 );\n    float[] arrayD = float[](   T1,     T2,     T3,     T4,     T5,     T6,     T7,     T8    );\n \n \n    float minT = arrayD[0];\n    \n    for (int i = 1; i < 8; i++)\n \n        if (minT > arrayD[i])\n        {\n            minT = arrayD[i];\n            minIndex = i;\n        }\n    \n    \n    \n    \n    // Output values\n    normal = arrayN[minIndex];\n    return arrayD[minIndex];\n    \n    \n    \n    \n    // old version \n    //return min(min(min(min(min(min(min(T1,T2),T3),T4),T5),T6),T7),T8);\n}\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) \n{\n    // pos - позиция камеры\n    // dir - направление\n    // пересечение dir с плоскостью y = -1.5\n    // (СAMERA_POS + t * dir).y == -1.5\n    // t = (-1.5 - pos.y) / dir.y\n    float planePosY = -1.5;\n    float t = (planePosY - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 50.0) {\n        return INF;\n    }\n    \n    normal = vec3(0, 1, 0);\n    \n    return t;\n}\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal )\n{\n    // dot(pos + t*dir, pos + t*dir) == r*r\n    // dot(pos, pos) + 2*t*dot(pos,dir) + t*t*dot(dir,dir) == r*r\n    // because of dot(dir,dir) == 1\n    \n    // t*t + 2*t*dot(pos,dir) + dot(pos, pos) - r*r == 0\n    \n    float b = dot(pos,dir);\n    float D = b * b - dot(pos, pos) + r*r;\n    \n    // if not intercept\n    if (D < 0.0)\n        return INF;\n    \n    \n    // it might be 2 roots. Choise the right one.\n    float t = -b - sqrt(D);\n    \n    if (t > 0.0){\n        normal = normalize(pos + t*dir) ;\n        return t;\n    }\n    \n    t = -b + sqrt(D);\n    if (t < 0.0)\n        return INF;\n    \n    \n    normal = normalize(pos + t*dir) ;\n    return t;\n}\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) \n{\n\n    float h = -1.3;\n    \n    float t = (h - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < 1.0) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - 1.0;\n    \n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    \n    t = (-b - sqrt(D)) / a;\n    \n    if (t > 0.0) {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= h) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    \n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    \n    worldPos = t * dir + pos;\n    if (worldPos.y <= h) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    \n    return INF;\n}\n\n\n\n\n\n\n// SHADOW, LIGHT, REFRACTION FUNCTIONS\nbool isOccluded(vec3 pos, vec3 target) \n{\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n\n      \n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, cylNorm);\n    return (cylT < dist);\n    \n    vec3 octahedronNormal;\n    float octahedronT = traceOctahedron(pos, dir, octahedronScale, octahedronShift, octahedronNormal);\n    if(octahedronT < dist)\n        return true;\n        \n    vec3 octahedron2Normal;\n    float octahedron2T = traceOctahedron(pos, dir, octahedronScale, vec3(1.0, 0.0, 3.0), octahedronNormal);\n    if(octahedron2T < dist)\n        return true;\n        \n        \n    \n}\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal)\n{\n    // use formula from given task\n    // I = emissive + ambient + diffuse* att + speculat*att\n    // att = 1/dist^2\n    \n    \n    // LIGHT 1\n    vec3 toLight1 = LIGHT1_POS - pos;\n    float dist1 = length(toLight1);\n    float att1 = isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS) ? 0.0 : LIGHT1_BRIGHTNESS / (dist1 * dist1);\n    \n    // LIGHT 2 \n    vec3 toLight2 = LIGHT2_POS - pos;\n    float dist2 = length(toLight2);\n    float att2 = isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS) ? 0.0 : LIGHT2_BRIGHTNESS / (dist2 * dist2);\n    \n    \n    // Output\n    return color *( \n    \n          max(0.0, dot(normal, normalize (toLight1) ) ) * att1 * LIGHT1_COLOR\n        + max(0.0, dot(normal, normalize (toLight2) ) ) * att2 * LIGHT2_COLOR\n        + texture(iChannel1, normal).rgb * CUBEMAP_BRIGHTNESS\n    );\n}\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) \n{\n    if (dot(v, normal) < 0.0) {\n        // луч пришёл снаружи\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    // тангенциальная составляющая\n    vec3 tang = normalize(v - cosA * normal);\n    // масштабируем вектора \n    float sinB = sinA / n2 * n1;\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Random numbers \n    randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals);\n    \n    \n    // Anti-aliasing for better image. AA from -1 to 1\n    vec2 AA = (randVals.xy - 0.5 ) * 2.0;\n    \n    \n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - iResolution.xy/2.0 + AA)/iResolution.x;\n\n\n    // Vectors front up and right helps to create viewVec\n    vec3 front = normalize(-CAMERA_POS); //vector from (0,0,0) to CAMERA_POS\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up)); \n    up = normalize(cross(right, front));\n\n\n    // viewVec looks from CAMERA_POS from pixel (uv.x, uv.y) and go forward\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n    \n    // motion blur\n    vec3 LIGHT1_POS = vec3(-1, 1, -2) + vec3(1, 1, 0) * randVals * 0.07;\n    // motion blur in one direction\n    vec3 LIGHT2_POS = vec3(0.4, 1.2, 2) + vec3(0, 1, 0) * randVals.y * 0.06;\n\n\n    // Current camera position and direction \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n\n\n    // For refraction (from physics) \n    float n1 = AIR_N;\n    float nEnter;\n    \n    float DIAMOND_R = pow2(DIAMOND_N - GLASS_N) / pow2(DIAMOND_N + GLASS_N);\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    \n    vec3 colorMult = vec3(1, 1, 1);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    // doing Ray-Marching 20 times\n    for (int i = 0; i < rayMachingTimes; ++i) {\n    \n    \n        // if planeT will equal to distance to table then t = planeT, otherwise t = infinity.\n        float t = INF;\n        \n        // Properties of intercepted surface.\n        int materialType;\n        vec3 color;\n        vec3 normal;\n        \n        // For refraction\n        nEnter = AIR_N;\n        \n        \n        // TABLE RENDERING\n        {\n            vec3 planeNorm;\n            float planeT = tracePlane(curPos, curDir, planeNorm);\n            if (planeT < t) {\n                t = planeT;\n                materialType = DIFFUSE;\n                vec3 worldPos = t * curDir + curPos;\n                color = texture(iChannel0, worldPos.xz * 0.1).rgb;\n                normal = planeNorm;\n\n\n                // for make floor reflaction\n                if(randVals.y < 0.19)\n                    materialType = REFLECTION;\n            }\n        }\n        \n        // LIGHT 1 RENDERING\n        {\n            vec3 l1Norm;\n            float light1T = traceSphere(curPos - LIGHT1_POS, curDir, LIGHT1_RADIUS, l1Norm);\n            if (light1T < t) {\n                t = light1T;\n                materialType = EMISSION;\n                color = LIGHT1_COLOR;\n                normal = l1Norm;\n            }\n        }\n        \n        // LIGHT 2 RENDERING\n        {\n            vec3 l2Norm;\n            float light2T = traceSphere(curPos - LIGHT2_POS, curDir, LIGHT2_RADIUS, l2Norm);\n            if (light2T < t) {\n                t = light2T;\n                materialType = EMISSION;\n                color = LIGHT2_COLOR;\n                normal = l2Norm;\n            }\n        }\n        \n        // OCTAHEDRON RENDERING\n        {\n            vec3 octahedronNormal;\n\n            float octahedronT  = traceOctahedron(curPos, curDir, octahedronScale, octahedronShift, octahedronNormal);\n            // If trace is intercept with octahedron then make t shorter and equal to distance between camera and table.\n            if (octahedronT < t)\n            {\n                t = octahedronT;\n                color = vec3(0.0,0.0,1.0);\n                normal = octahedronNormal;\n\n                //combine reflection and refraction;\n                if(randVals.x*0.2 < GLASS_R)\n                    materialType = REFLECTION;\n\n                else{\n                    materialType = REFRACTION;\n                    // We need to know what is outside the object \n                    if( dot(curDir, normal) > 0.0 )// they not oppodite directed\n                    {\n                        nEnter = AIR_N;\n                    }\n                    else // they opposite directed \n                    {\n                        nEnter = GLASS_N;\n\n                    }\n\n                }\n                //materialType = REFRACTION;\n\n            }\n        }\n        \n        // OCTAHEDRON 2 RENDERING\n        {\n            vec3 octahedron2Normal;\n\n            float octahedron2T  = traceOctahedron(curPos, curDir, octahedronScale, vec3(1.0, 0.0, 3.0), octahedron2Normal);\n            // If trace is intercept with octahedron then make t shorter and equal to distance between camera and table.\n            if (octahedron2T < t)\n            {\n                t = octahedron2T;\n                color = vec3(1.0,0.5,0.0);\n                normal = octahedron2Normal;\n\n                \n                materialType = DIFFUSE;\n\n            }\n        }\n        \n        // CYLINDER RENDERING\n        {\n            vec3 cylNorm;\n            float cylT = traceCylinder(curPos, curDir, cylNorm);\n            if (cylT < t) {\n                t = cylT;\n                materialType = DIFFUSE;\n                vec3 worldPos = t * curDir + curPos;\n                color = texture(iChannel2, worldPos.xz * worldPos.y).rgb;\n                normal = cylNorm;\n            }\n        }\n        \n        \n        \n        \n        \n        \n     \n        // IF WE INTERCEPT SOMETHING\n        {\n            if (t != INF) {\n            \n                vec3 worldPos = t * curDir + curPos;\n                fragColor = texture(iChannel0, worldPos.xz);\n                \n                \n                \n                if (materialType == EMISSION) {\n                    fragColor.rgb = color * colorMult;\n                    break;\n                    \n                    \n                } else if (materialType == DIFFUSE) {\n                    fragColor.rgb = computeLight(worldPos, color, normal) * colorMult;\n                    break;\n                    \n                    \n                } else if (materialType == REFLECTION) {\n                    curDir = reflect(curDir, normal);\n                    curPos = worldPos + curDir * 1e-5;\n                    \n                    \n                } else if (materialType == REFRACTION) {\n                    curDir = refraction(curDir, normal, n1, nEnter);\n                    curPos = worldPos + curDir * 1e-5;\n                    n1 = nEnter;\n                }\n            } \n            else \n                fragColor.rgb = texture(iChannel1, curDir).rgb * colorMult;\n        }\n        \n        \n        \n        \n        \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec3 fire_color(float x)\n{\n\treturn\n        // red\n        vec3(1., 0., 0.) * x\n        // yellow\n        + vec3(1., 1., 0.) * clamp(x - .5, 0., 1.)\n        // white\n        + vec3(1., 1., 1.) * clamp(x - .7, 0., 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float A = 1.;\n\tconst int N = 2;\n\n    vec4 col = vec4(0);\n    for (int yoff = -N; yoff <= N; ++yoff) {\n        for (int xoff = -N; xoff <= N; ++xoff) {\n            vec2 off = vec2(xoff, yoff);\n            vec2 uv = (fragCoord + A * off) / iResolution.xy;\n            col += texture(iChannel0, uv) / (.5 + 1. * length(off / vec2(N, N)));\n        }\n    }\n\n    fragColor = vec4(col.rgb / float((N + N) * (N + N)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "mat4 rotate(float a, vec3 v)\n{\n    float c = cos(a);\n    vec3 ci = (1. - c) * v;\n    vec3 s = sin(a) * v;\n\n    return mat4(\n        ci.x * v.x + c, ci.x * v.y + s.z, ci.x * v.z - s.y, 0,\n        ci.y * v.x - s.z, ci.y * v.y + c, ci.y * v.z + s.x, 0,\n        ci.z * v.x + s.y, ci.z * v.y - s.x, ci.z * v.z + c, 0,\n        0, 0, 0, 1\n\t);\n}\n\nmat4 translate(vec3 v)\n{\n    return mat4(\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        v.x, v.y, v.z, 1\n    );\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat traceSphere(vec3 origin, vec3 target, vec3 center, float radius)\n{\n    vec3 oc = origin - center;\n    float a = dot(target, target);\n    float b = 2. * dot(oc, target);\n    float c = dot(oc, oc) - radius * radius;\n    float disc = b * b - 4. * a * c;\n    if (disc < 0.) {\n        // no intersection\n        return -1.;\n    } else {\n        return (-b - sqrt(disc)) / (2. * a);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4 mvp = rotate(radians(0. * iTime), vec3(0, 1, 0));\n    \n\tvec3 dir = (mvp * vec4(rayDirection(145.0, iResolution.xy, fragCoord), 1.)).xyz;\n    vec3 eye = (mvp * vec4(0., 0., 1.9, 1.)).xyz;\n\n    vec3 sphere_pos = vec3(0., 0., 0.);\n\n    float intensity = 0.;\n    \n    mat4 tex_mat = mat4(1.);\n    mat4 wind_mat = mat4(1.);\n    for (int i = 0; i < 9; ++i) {\n        float t = traceSphere(eye, dir, sphere_pos, 1. - float(i) / 40.);\n\n        if (t > 0.) {\n            vec3 hit_pos = eye + dir * t;\n            vec3 t_hit_pos = (tex_mat * wind_mat * vec4(hit_pos, 1.)).xyz;\n            vec3 normal = normalize(t_hit_pos - sphere_pos);\n\n            float alpha = texture(iChannel0, 1. / float(i) * vec2(atan(normal.z, normal.x) / radians(90.), normal.y)).r;\n\t\t\tintensity += step(1. - float(i) / 6., alpha) * .8 * alpha * max(0., dot(vec3(0, 0, 1.), hit_pos));\n\n            tex_mat = rotate(radians(11.) * iTime, normalize(vec3(.3, -.7, .1))) * tex_mat;\n            wind_mat = rotate(radians(15.) * iTime, normalize(vec3(1., 0., 0.))) * wind_mat;\n        }\n    }\n\n\tfragColor = vec4(fire_color(intensity), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}