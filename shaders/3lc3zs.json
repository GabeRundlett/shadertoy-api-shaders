{
    "Shader": {
        "info": {
            "date": "1577187708",
            "description": "After 5 long years programming databases it's time to have fun with colours.",
            "flags": 48,
            "hasliked": 0,
            "id": "3lc3zs",
            "likes": 13,
            "name": "Shader Vaderz",
            "published": 3,
            "tags": [
                "2d",
                "game",
                "retro",
                "buffer",
                "arcade"
            ],
            "usePreview": 0,
            "username": "ndxbxrme",
            "viewed": 518
        },
        "renderpass": [
            {
                "code": "#define STATE_ATTRACT 0.\n#define STATE_GAME 1.\n#define STATE_READYUP 2.\n#define STATE_GAMEOVER 3.\n#define STATE_WIN 4.\n#define STATE_DEATH 5.\nconst ivec2 txPaddlePos = ivec2(0,0);\nconst ivec2 txBulletPos = ivec2(1,0);\nconst ivec2 txFrame = ivec2(2,0);\nconst ivec2 txInvaderPos = ivec2(3,0);\nconst ivec2 txScore = ivec2(5,0);\nconst ivec2 txState = ivec2(6,0);\nconst ivec2 txSaucerPos = ivec2(7,0);\nconst ivec4 txInvaders = ivec4(0,1,8,6);\nconst ivec4 txRowData = ivec4(0,8,6,1);\nconst ivec4 txCities = ivec4(0,9,16,4);\nconst ivec4 txBombs = ivec4(0,13,3,1);\nconst float[] citiesX = float[](-12., -5., 2., 9.);\nconst float citiesY = 2.;\nconst float paddleY = .4;\nconst int noRows = 6;\nconst int noCities = 4;\nconst int noBombs = 3;\n// Digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\nconst int[] font = int[](0x75557, 0x22222, 0x74717, 0x74747, 0x11574, 0x71747, 0x71757, 0x74444, 0x75757, 0x75747);\nconst int[] powers = int[](1, 10, 100, 1000, 10000);\nfloat hash( in vec3 p ) \n{\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\n}\n\nvec3 hash3( in vec3 p )\n{\n    return vec3(hash(p),hash(p+1.5),hash(p+2.5));\n}\n\nvec3 hue(vec3 color, float shift) {//https://www.shadertoy.com/view/MlSXWd\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI     = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ     = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR   = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG   = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB   = vec3 (1.0, -1.107, 1.704);\n\n    // Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    // Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    // Make the user's adjustments\n    hue += shift;\n\n    // Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    // Convert back to RGB\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\nint PrintInt( in vec2 uv, in int value )\n{\n    const int maxDigits = 5;\n    if( abs(uv.y-0.5)<0.5 )\n    {\n        int iu = int(floor(uv.x));\n        if( iu>=0 && iu<maxDigits )\n        {\n            int n = (value/powers[maxDigits-iu-1]) % 10;\n            uv.x = fract(uv.x);//(uv.x-float(iu)); \n            ivec2 p = ivec2(floor(uv*vec2(4.0,5.0)));\n            return (font[n] >> (p.x+p.y*4)) & 1;\n        }\n    }\n    return 0;\n}\n//i made a little tool to make these guys... https://codepen.io/ndxbxrme/pen/VwYpzPN\nconst int[] title = int[](\n    0xeaacea0, 0x2aaa8c0, 0xeeeaca0, 0x8aaa8a0, 0xeaeeee0,//shader\n    0x4aceae0, 0xaaa8c80, 0xaeaca40, 0xaaa8a20, 0xaeeeee0,//vaders\n    0xa90e8aee, 0xa9028a88, 0xe90eee8c, 0xa908aa88, 0xab8eeeee,//hit space\n    0x138e4aa4, 0x12824ac4, 0x128e4ea4, 0x12884aa4, 0x3b8eeeee,//to start\n    0x1ddd5c, 0x51590, 0x1d1558, 0x111550, 0x1ddddc,//score\n    0x749dc, 0x45504, 0x4559c, 0x45510, 0x455dc,//lives\n    0xef457562, 0xa8464552, 0xac456755, 0x88454555, 0xeee77775,//get ready\n    0xea8b80, 0xaa8a00, 0xaeab00, 0x8aaa00, 0xeefb80,//game\n    0xe4ea00, 0xaa8c00, 0xaaca00, 0xaa8a00, 0xeaee00,//over\n    0x9dc5728, 0x9546428, 0x15545638, 0x15555428, 0x15d57738,//?\n    0x1b529750, 0x15529460, 0x1556b650, 0x155ad450, 0x11529770//?\n    \n    );\nconst int[] invaders = int[](\n    0x420, 0x810, 0x5a0, 0xff0, 0xdb0, 0x7e0, 0x3c0, 0x180,\n    0xa50, 0x5a0, 0x240, 0xff0, 0xdb0, 0x7e0, 0x3c0, 0x180,\n    0x0, 0x0, 0x1dd0, 0x1510, 0x15d0, 0x1450, 0x1dd0, 0x0,\n    0x0, 0x0, 0x1dd0, 0x1510, 0x15d0, 0x1450, 0x1dd0, 0x0,\n    0xc30, 0x1998, 0xe70, 0x3ffc, 0x399c, 0x3ffc, 0x1ff8, 0x3c0,\n    0x300c, 0x1998, 0xe70, 0x3ffc, 0x399c, 0x3ffc, 0x1ff8, 0x3c0,\n    0x0, 0x0, 0x1dd0, 0x1550, 0x1550, 0x1550, 0x1dd0, 0x0,\n    0x0, 0x0, 0x1dd0, 0x1550, 0x1550, 0x1550, 0x1dd0, 0x0,\n    0x6c0, 0x2828, 0x2fe8, 0x3ff8, 0x1bb0, 0xfe0, 0x440, 0x820,\n    0x1010, 0xba0, 0xc60, 0x1ff0, 0x3bb8, 0x2fe8, 0x2448, 0x820,\n    0x0, 0x0, 0xee0, 0xa80, 0xae0, 0xa20, 0xee0, 0x0,\n    0x0, 0x0, 0xee0, 0xa80, 0xae0, 0xa20, 0xee0, 0x0,\n    0x0, 0x1010, 0x3bb8, 0xfffe, 0x6aac, 0x3ff8, 0x1ff0, 0x7c0,\n    0x0, 0x1010, 0x3bb8, 0xfffe, 0x6aac, 0x3ff8, 0x1ff0, 0x7c0,\n    0x0, 0x0, 0x1ddc, 0x1550, 0x155c, 0x1544, 0x1ddc, 0x0,\n    0x0, 0x0, 0x1ddc, 0x1550, 0x155c, 0x1544, 0x1ddc, 0x0,\n    //masks\n    0x420, 0x810, 0x5a0, 0xff0, 0xff0, 0x7e0, 0x3c0, 0x180,\n    0xa50, 0x5a0, 0x3c0, 0xff0, 0xff0, 0x7e0, 0x3c0, 0x180,\n    0x0, 0x0, 0x1dd0, 0x1510, 0x15d0, 0x1450, 0x1dd0, 0x0,\n    0x0, 0x0, 0x1dd0, 0x1510, 0x15d0, 0x1450, 0x1dd0, 0x0,\n    0xc30, 0x1998, 0xff0, 0x3ffc, 0x3ffc, 0x3ffc, 0x1ff8, 0x3c0,\n    0x300c, 0x1998, 0xff0, 0x3ffc, 0x3ffc, 0x3ffc, 0x1ff8, 0x3c0,\n    0x0, 0x0, 0x1dd0, 0x1550, 0x1550, 0x1550, 0x1dd0, 0x0,\n    0x0, 0x0, 0x1dd0, 0x1550, 0x1550, 0x1550, 0x1dd0, 0x0,\n    0x6c0, 0x2828, 0x2fe8, 0x3ff8, 0x1ff0, 0xfe0, 0x440, 0x820,\n    0x1010, 0xba0, 0xfe0, 0x1ff0, 0x3ff8, 0x2fe8, 0x2448, 0x820,\n    0x0, 0x0, 0xee0, 0xa80, 0xae0, 0xa20, 0xee0, 0x0,\n    0x0, 0x0, 0xee0, 0xa80, 0xae0, 0xa20, 0xee0, 0x0,\n    0x0, 0x1010, 0x3bb8, 0xfffe, 0x7ffc, 0x3ff8, 0x1ff0, 0x7c0,\n    0x0, 0x1010, 0x3bb8, 0xfffe, 0x7ffc, 0x3ff8, 0x1ff0, 0x7c0,\n    0x0, 0x0, 0x1ddc, 0x1550, 0x155c, 0x1544, 0x1ddc, 0x0,\n    0x0, 0x0, 0x1ddc, 0x1550, 0x155c, 0x1544, 0x1ddc, 0x0\n);\nconst int[] bullets = int[](\n\t3, 3, 3, 3, 3, 3, 3, 3    \n);\nconst int[] city = int[](\n    0xf000000f, 0xf800001f, 0xf800001f, 0xfe00007f, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x7ffffffe, 0x7ffffffe, 0x3ffffffc, 0xffffff0\n);\nconst int[] player = int[](\n\t0x3ffc, 0x7ffe, 0x7ffe, 0x7ffe, 0x3ffc, 0x3c0, 0x3c0, 0x180    \n);\n    \nfloat printTitle(in vec2 uv, in int offset)\n{\n\tivec2 p = ivec2(floor(uv * vec2(32.,5.)));\n    if(p.x > -1 && p.x < 32 && p.y > -1 && p.y < 5)\n    {\n    \treturn float((title[offset + p.y] >> p.x) & 1);\n    }\n    return 0.;\n}\nfloat printChar(in vec2 uv, in int offset, in int id, in int rowNo)\n{\n    //uv.x += .5;\n    uv.x *= .5;\n    ivec2 p = ivec2(floor(uv * vec2(16., 8.)));\n    float intensity = 1.;\n    if(p.x > -1 && p.x < 16 && p.y > -1 && p.y < 8)\n    {\n        vec2 state = texelFetch( iChannel0, txInvaders.xy + ivec2(id, rowNo), 0).xy;\n        if(state.x==.0) {\n            if(iTime - state.y > 1.) return 0.;\n            offset += 16;\n            intensity = 1.5 + cos(iTime * 60.) * .5;\n        }\n        if(state.y==0.) return 1.;\n    \treturn float((invaders[offset + p.y] >> p.x) & 1) * intensity;\n    }\n    return 0.;\n}    \nfloat printPlayer(in vec2 uv, in vec4 state)\n{\n    //uv.x += .5;\n    if(state.x==STATE_DEATH) {\n    \tuv.y *= exp((iTime - state.z)) * 2.;  \n    }\n    uv.x *= .5;\n    ivec2 p = ivec2(floor(uv * vec2(16., 8.)));\n    if(p.x > -1 && p.x < 16 && p.y > -1 && p.y < 8)\n    {\n    \treturn float((player[p.y] >> p.x) & 1);\n    }\n    return 0.;\n}    \nfloat printBullet(in vec2 uv, in int offset)\n{\n    uv.x *= 4.;\n    ivec2 p = ivec2(floor(uv * vec2(2., 8.)));\n    if(p.x > -1 && p.x < 2 && p.y > -1 && p.y < 8)\n    {\n        return float((bullets[offset + p.y] >> p.x) & 1);\n    }\n    return 0.;\n}\nfloat printCity(in vec2 uv, in int id)\n{\n    uv.x *= .25;\n    uv.y *= .5;\n    ivec2 p = ivec2(floor(uv * vec2(32., 16.)));\n    if(p.x > -1 && p.x < 32 && p.y > -1 && p.y < 16)\n    {\n        int cityBit = int(texelFetch( iChannel0, txCities.xy + ivec2(p.y, id), 0).x);\n        return float((cityBit >> p.x) & 1);\n    }\n    return 0.;\n}\nvec3 printSaucer(in vec2 uv, in int offset, in vec3 col, in float colShift)\n{\n    //uv.x += .5;\n    uv.x *= .5;\n    ivec2 p = ivec2(floor(uv * vec2(16., 8.)));\n    if(p.x > -1 && p.x < 16 && p.y > -1 && p.y < 8)\n    {\n    \treturn hue(col, colShift) * float((invaders[offset + p.y] >> p.x) & 1);\n    }\n    return vec3(0.);\n}    \n\nvec3 printRow(in vec2 uv, in int frame, in float spacing, in int rowNo, in vec3 col, in float colShift)\n{\n    float id = floor(uv.x * 1.0 / spacing);\n    if(id > -1. && id < 8.) return hue(col, colShift) * printChar(uv - vec2(id * spacing, 0.0), frame * 8, int(id), rowNo);\n    else return vec3(0.0);\n}\n\nvec3 printScene(in vec2 uv, in int frame, in ivec3 score, in vec2 invaderPos, in float paddlePos, in vec2 bulletPos, in vec4 saucerPos, in vec3 col, in vec4 state)\n{\n    vec3 f = vec3(0.);\n    for(int i=0; i < noRows; i++) {\n        vec4 rowData = texelFetch(iChannel0, txRowData.xy + ivec2(i,0), 0);\n        f += printRow(uv - vec2(0., rowData.x) + invaderPos, int(rowData.z) + frame, rowData.y, i, col, float(i) * .5);\n    }\n    for(int i=0; i < noCities; i++) {\n        f += hue(col,0.8) * printCity(uv - vec2(citiesX[i], citiesY), i);   \n    }\n    //printChar(uv - vec2(0.0, 8.), frame);\n    //f = max(f, printChar(uv - vec2(1.1,8.), frame));\n    f += col * printPlayer(uv - vec2(paddlePos, paddleY), state);\n    f += col * printBullet(uv - bulletPos, 0);\n    if(saucerPos.z==1. || saucerPos.w > 0.) {\n        int offset = (saucerPos.z==1.) ? 0 : 2;\n    \tf += col * printSaucer(uv - saucerPos.xy, (frame + 12 + offset) * 8, col, 1.);\n    }\n    for(int i=0;i<noBombs;i++) {\n        vec2 bombData = texelFetch(iChannel0, txBombs.xy + ivec2(i,0), 0).xy;\n        f += col * printBullet(uv - bombData, 0);\n    }\n    if(state.x == STATE_GAME) {\n        uv *= 1.6;\n        f += col * printTitle(uv * vec2(-.1,1.) + vec2(-.5, -24), 20);\n        f += col * float(PrintInt(uv + vec2(5.,-24) , score.x));\n        f += col * printTitle(uv * vec2(-.1,1.) + vec2(.8, -24), 25);\n        for(float i=0.; i<float(score.y); i++) {\n        \tf += hue(col, .5 + i * .5) * printPlayer(uv + vec2(-8. - (i * 2.), -24), state);\n        }\n    }\n    return f;\n}\n\nvec3 printMask(in vec2 uv, in int frame, in ivec3 score, in vec2 invaderPos, in float paddlePos, in vec2 bulletPos, in vec3 col, in vec4 state)\n{\n    vec3 f = vec3(0.);\n    for(int i=0; i < noRows; i++) {\n        vec4 rowData = texelFetch(iChannel0, txRowData.xy + ivec2(i,0), 0);\n        f += printRow(uv - vec2(0., rowData.x) + invaderPos, int(rowData.z) + frame + 16, rowData.y, i, vec3(1.), 0.);\n    }\n    return f;\n}\n\nvec3 background(in vec2 uv)\n{\n    uv += vec2(1.4,cos(iTime * .01));\n    uv *= .5;\n    vec3 col = vec3(length(uv) - 0.8);\n    float pa, a=pa=0.;\n    for(int i = 0; i<10; i++) {\n    \tuv = abs(uv)/dot(uv,uv) - 0.42;\n        a += abs(length(uv) - pa);\n        pa = length(uv);\n    }\n    col = vec3(a * .002 * (.6 + (cos(iTime) * .2)));\n\treturn vec3(length(col));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tint myint = 0xffffffff;\n    float flint = float(myint);\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime * .6+uv.xyx+vec3(0,2,4));\n    uv.x -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 bg = background(uv);\n    uv *= 16.;\n    int frame = int(texelFetch( iChannel0, txFrame, 0 ).x);\n    ivec3 score = ivec3(texelFetch( iChannel0, txScore, 0).xyz);\n    vec2 invaderPos = texelFetch( iChannel0, txInvaderPos, 0).xy;\n    float paddlePos = texelFetch( iChannel0, txPaddlePos, 0 ).x;\n    vec2 bulletPos = texelFetch( iChannel0, txBulletPos, 0 ).xy;\n    vec4 saucerPos = texelFetch( iChannel0, txSaucerPos, 0 );\n    vec4 state = texelFetch( iChannel0, txState, 0);\n    float time = iTime - state.z;\n    vec3 f = vec3(0.0);\n    vec3 glow = vec3(0.0);\n    for(float j=-1.;j<=1.;j++)\n    for(float k=-1.;k<=1.;k++) {\n\t\tglow += printScene(uv + (vec2(j,k) * .07), frame, score, invaderPos, paddlePos, bulletPos, saucerPos, col, state) * .1;\n    }\n    f = bg + glow;\n    f = min(1. - printMask(uv, frame, score, invaderPos, paddlePos, bulletPos, col, state), f);\n    vec3 scene = printScene(uv, frame, score, invaderPos, paddlePos, bulletPos, saucerPos, col, state);\n    f = (scene.x + scene.y + scene.z > 0.) ? scene : f;\n    vec2 titleUV = uv;\n    titleUV.x *= titleUV.y * .1;\n    float titleTop = -4.;\n    float flash = smoothstep(-.6, -.5, sin(iTime * 4.));\n    float title = 0.0;\n    if(state.x==STATE_ATTRACT) {\n        titleTop = mix(-4., 0., smoothstep(0., 2., time));\n        f *= 0.6;\n        title += printTitle(uv * vec2(-.2,1.) + vec2(.0, -4.5), 10) * flash;\n        title += printTitle(uv * vec2(-.2,1.) + vec2(1., -4.5), 15) * flash;\n        title += printTitle(titleUV * vec2(-.06,.4) + vec2(.5, -4.5 + titleTop), 0);\n        title += printTitle(titleUV * vec2(-.06,.4) + vec2(.5, -3.0 + titleTop), 5);\n    }\n    else if(state.x==STATE_READYUP) {\n        titleTop = mix(0., -4., smoothstep(0., 2., time));\n        title += printTitle(uv * vec2(-.2,1.) + vec2(0.5, -7.), 30) * flash;\n        title += printTitle(titleUV * vec2(-.06,.4) + vec2(.5, -4. + titleTop), 0);\n        title += printTitle(titleUV * vec2(-.06,.4) + vec2(.5, -2.5 + titleTop), 5);\n    }\n    if(state.x==STATE_WIN) {\n        f *= .6;\n        title += printTitle(titleUV * vec2(-.06,.4) + vec2(.5, -4.5), 45) * flash;\n        title += printTitle(titleUV * vec2(-.06,.4) + vec2(.5, -3.), 50) * flash;\n    }\n    else if(state.x==STATE_GAMEOVER) {\n        f *= .6;\n    \ttitle += printTitle(uv * vec2(-.2,1.) + vec2(0.2, -7.),35) * flash;   \n    \ttitle += printTitle(uv * vec2(-.2,1.) + vec2(0.7, -7.),40) * (1. - flash); \n    }\n    else if(state.x==STATE_DEATH && state.w==STATE_GAME) {\n    \tf = smoothstep(0.9,0.91,1.-f);\n    }\n    else if(state.x==STATE_DEATH && state.w==STATE_ATTRACT) {\n        f *= .6;\n    }\n    f = max(f, title);\n    // Output to screen\n    fragColor = vec4(f ,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define STATE_ATTRACT 0.\n#define STATE_GAME 1.\n#define STATE_READYUP 2.\n#define STATE_GAMEOVER 3.\n#define STATE_WIN 4.\n#define STATE_DEATH 5.\nconst ivec2 txPaddlePos = ivec2(0,0);\nconst ivec2 txBulletPos = ivec2(1,0);\nconst ivec2 txFrame = ivec2(2,0);\nconst ivec2 txInvaderPos = ivec2(3,0);\nconst ivec2 txLastFrame = ivec2(4,0);\nconst ivec2 txScore = ivec2(5,0);\nconst ivec2 txState = ivec2(6,0);\nconst ivec2 txSaucerPos = ivec2(7,0);\nconst ivec2 txGameSpeed = ivec2(8,0);\nconst ivec4 txInvaders = ivec4(0,1,8,6);\nconst ivec4 txRowData = ivec4(0,8,6,1);\nconst ivec4 txCities = ivec4(0,9,16,4);\nconst ivec4 txBombs = ivec4(0,13,3,1);\nconst float[] citiesX = float[](-12., -5., 2., 9.);\nconst float citiesY = 2.;\nconst float paddleY = .4;\nconst float inputSpeed = 8.;\nconst int noRows = 6;\nconst int noCols = 8;\nconst int noCities = 4;\nconst int noBombs = 3;\nconst int KEY_SPACE = 32;\nconst int KEY_A  = 65;\nconst int KEY_D = 68;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nint lastFrame = -1;\n\nconst int[] invaderMasks = int[](\n    0x1c38, 0x810, 0x5a0, 0xff0, 0xff0, 0x7e0, 0x3c0, 0x180,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0x3c3c, 0x1998, 0xff0, 0x3ffc, 0x3ffc, 0x3ffc, 0x1ff8, 0x3c0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0x7c0, 0x2fe8, 0x2fe8, 0x3ff8, 0x3ff8, 0x2fe8, 0x2448, 0x820\n);\n\nfloat hash( in float p ) \n{\n    return fract(sin(p*15.32758341+7.5312) * 43758.236237153)-.5;\n}\n// iq (https://www.shadertoy.com/view/MddGzf)\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = (p==re) ? va : fragColor;\n}\nvoid storeValue( in ivec4 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = ( p.x>=re.x && p.y>=re.y && p.x<=re.z && p.y<=re.w ) ? va : fragColor;\n}\n// ------------------------------------------\nint checkCollisions(inout ivec3 score, in vec2 bulletPos, in vec3 invaderPos, inout vec4 saucerPos, inout vec4 fragColor, in ivec2 ipx)\n{\n    if(bulletPos.y > citiesY && bulletPos.y < citiesY + 3.) {\n        for(int i=0; i<noCities; i++) {\n            float cityX = citiesX[i];\n            if(bulletPos.x > cityX - 0.2 && bulletPos.x < cityX + 3.0) {\n                //checkBits\n                int xBit = int((bulletPos.x - cityX) * 8.);   \n                int yBit = 24 - int((citiesY + 2. - bulletPos.y) * 8. );\n                int collided = 0;\n                for(int f = 0; f<yBit; f++) {\n                    int row = int(loadValue(txCities.xy + ivec2(f,i)).x);   \n                    int c = row & (3 << xBit);\n                    if(c > 0) {\n                        collided = 1;\n                        row = row & (0xffffff - (3 << xBit));\n                        storeValue( txCities.xy + ivec2(f,i), vec4(float(row), 0., 0., 0.), fragColor, ipx);\n                    }\n                }\n                return collided;\n            }\n        }\n        //return 0;\n    }\n    for(int i=0; i < noRows; i++) {\n    \tvec4 rowData = loadValue(txRowData.xy + ivec2(i, 0));\n        if((bulletPos.y)  > (rowData.x - invaderPos.y - 1. ) ) {\n            float ix = invaderPos.x * -1.;\n            if(bulletPos.x > ix) {\n                float id = floor((bulletPos.x - ix) * .5);\n                vec4 invaderState = loadValue(txInvaders.xy + ivec2(id,i));\n                if(invaderState.x > 0.) {\n                    int xBit = int((bulletPos.x - (ix + (rowData.y * id))) * 8.);\n                    int yBit = 8 - int((rowData.x - invaderPos.y - 1. - bulletPos.y) * 8.);\n                    int collided = 0;\n                    for(int f=0; f<yBit; f++) {\n                    \tint row = invaderMasks[(int(rowData.z) * 8) + f]; \n                        int c = row & (3 << xBit);\n                        if(c > 0) {\n                            storeValue(txInvaders.xy + ivec2(id,i), vec4(0., iTime, 0., 0.), fragColor, ipx);\n                            score.x += int(rowData.w);\n                            return 2;\n                        } \n                    }\n                }\n                \n            }\n        }\n    }\n    if(bulletPos.y > saucerPos.y - 1.) {\n        if(bulletPos.x > saucerPos.x - 0.2 && bulletPos.x < saucerPos.x + 2.) {\n        \tscore.x += 500;\n            saucerPos.z = 0.;\n            saucerPos.w = 30.;\n            return 3;\n        }\n    }\n    //score.x = int(bulletPos.y * 10.);\n\treturn 0;   \n}\nint checkBombCollisions(inout ivec3 score, in vec2 bombPos, in float paddlePos, inout vec4 fragColor, in ivec2 ipx)\n{\n    if(bombPos.y > citiesY - 1. && bombPos.y < citiesY + 2.) {\n        for(int i=0; i<noCities; i++) {\n            float cityX = citiesX[i];\n            if(bombPos.x > cityX - 0.2 && bombPos.x < cityX + 3.0) {\n                //checkBits\n                int xBit = int((bombPos.x - cityX) * 8.);   \n                int yBit = 24 - int((citiesY + 3. - bombPos.y) * 8. );\n        \t\t//score.x = yBit;\n                int collided = 0;\n                for(int f = 23; f>=yBit; f--) {\n                    int row = int(loadValue(txCities.xy + ivec2(f,i)).x);   \n                    int c = row & (3 << xBit);\n                    if(c > 0) {\n                        collided = 1;\n                        row = row & (0xffffff - (3 << xBit));\n                        storeValue( txCities.xy + ivec2(f,i), vec4(float(row), 0., 0., 0.), fragColor, ipx);\n                    }\n                }\n                return collided;\n            }\n        }\n    }\n    if(bombPos.y > paddleY - 1. && bombPos.y < paddleY + .7) {\n        if(bombPos.x > paddlePos - 0.2 && bombPos.x < paddlePos + 2.) {\n            return 2;\n        } \n    }\n\treturn 0;   \n}\nvec4 checkInvaderBounds(out float noAlive)\n{\n    vec4 bounds = vec4(16., 8., 0., 0.);\n    for(int r = 0; r < noRows; r++) {\n        for(int c=0; c<noCols; c++) {\n        \tvec4 invaderState = loadValue( txInvaders.xy + ivec2(c, r));\n            if(invaderState.x > 0.) {\n                noAlive += 1.;\n            \tbounds.x = min(bounds.x, float(c) * 2.);   \n                bounds.y = min(bounds.y, float(r));\n                bounds.w = max(bounds.w, float(c + 1) * 2.);\n                bounds.z = max(bounds.z, float(r + 1));\n            }\n        }\n    }\n    return bounds;\n}\n\nvoid changeState(inout vec4 state, in float newState)\n{\n    state.w = state.x;\n    state.x = newState;\n    state.z = iTime;\n}\n\nvoid reset(inout vec2 gameSpeed, inout vec2 bulletPos, inout vec4 saucerPos, out vec3 invaderPos, out vec3 lastFrame, out vec4 state, inout ivec3 score, inout vec4 fragColor, in ivec2 ipx)\n{\n    bulletPos.y = -2.0;   \n    saucerPos = vec4(-20., 13.5, 1.0, 0.0);\n    invaderPos = vec3(8.0, .0, 1.125);\n    lastFrame = vec3(-1.,iTime,.0);\n    //state.x = STATE_ATTRACT;\n    gameSpeed.x = 2.;\n    gameSpeed.y = .1;\n    state.y = 1.; //game speed\n    state.z = iTime;\n    score.z = max(score.z, score.x);//hi score\n    score.y = 3; //no lives\n    score.x = 0;\n    for(int i=0; i<noRows; i++) {\n        for(int f=0; f<8; f++) {\n            storeValue( txInvaders.xy + ivec2(f,i), vec4(1.), fragColor, ipx);\n        }\n    }\n    storeValue( txRowData.xy + ivec2(0,0), vec4(6, 2., 8., 50.), fragColor, ipx);\n    storeValue( txRowData.xy + ivec2(1,0), vec4(7.2, 2., 4., 100.), fragColor, ipx);\n    storeValue( txRowData.xy + ivec2(2,0), vec4(8.4, 2., 0., 150.), fragColor, ipx);\n    storeValue( txRowData.xy + ivec2(3,0), vec4(9.6, 2., 8., 50.), fragColor, ipx);\n    storeValue( txRowData.xy + ivec2(4,0), vec4(10.8, 2., 4., 100.), fragColor, ipx);\n    storeValue( txRowData.xy + ivec2(5,0), vec4(12., 2., 0., 150.), fragColor, ipx);\n    for(int i=0; i<noCities; i++) {\n        storeValue( txCities.xy + ivec2(0,i), vec4(float(0xf0000f), 0., 0., 0.), fragColor, ipx);\n        storeValue( txCities.xy + ivec2(1,i), vec4(float(0xf8001f), 0., 0., 0.), fragColor, ipx);\n        storeValue( txCities.xy + ivec2(2,i), vec4(float(0xf8001f), 0., 0., 0.), fragColor, ipx);\n        storeValue( txCities.xy + ivec2(3,i), vec4(float(0xfe007f), 0., 0., 0.), fragColor, ipx);\n        storeValue( txCities.xy + ivec2(4,i), vec4(float(0xffffff), 0., 0., 0.), fragColor, ipx);\n        storeValue( txCities.xy + ivec2(5,i), vec4(float(0xffffff), 0., 0., 0.), fragColor, ipx);\n        storeValue( txCities.xy + ivec2(6,i), vec4(float(0xffffff), 0., 0., 0.), fragColor, ipx);\n        storeValue( txCities.xy + ivec2(7,i), vec4(float(0xffffff), 0., 0., 0.), fragColor, ipx);\n        storeValue( txCities.xy + ivec2(8,i), vec4(float(0xffffff), 0., 0., 0.), fragColor, ipx);\n        storeValue( txCities.xy + ivec2(9,i), vec4(float(0xffffff), 0., 0., 0.), fragColor, ipx);\n        storeValue( txCities.xy + ivec2(10,i), vec4(float(0xffffff), 0., 0., 0.), fragColor, ipx);\n        storeValue( txCities.xy + ivec2(11,i), vec4(float(0xffffff), 0., 0., 0.), fragColor, ipx);\n        storeValue( txCities.xy + ivec2(12,i), vec4(float(0x7ffffe), 0., 0., 0.), fragColor, ipx);\n        storeValue( txCities.xy + ivec2(13,i), vec4(float(0x7ffffe), 0., 0., 0.), fragColor, ipx);\n        storeValue( txCities.xy + ivec2(14,i), vec4(float(0x3ffffc), 0., 0., 0.), fragColor, ipx);\n        storeValue( txCities.xy + ivec2(15,i), vec4(float(0xffff0), 0., 0., 0.), fragColor, ipx);\n    }   \n    \n    storeValue( txBombs.xy + ivec2(0,0), vec4(0., 20., 0., 0.), fragColor, ipx);\n    storeValue( txBombs.xy + ivec2(1,0), vec4(0., 20., 0., 0.), fragColor, ipx);\n    storeValue( txBombs.xy + ivec2(2,0), vec4(0., 20., 0., 0.), fragColor, ipx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 20.;\n    ivec2 ipx = ivec2(fragCoord-0.5);\n    ivec3 score = ivec3(loadValue(txScore).xyz);\n    float paddlePos = loadValue( txPaddlePos ).x;\n    vec2 bulletPos = loadValue( txBulletPos ).xy;\n    vec3 invaderPos = loadValue( txInvaderPos).xyz;\n    vec4 saucerPos = loadValue( txSaucerPos );\n    vec4 state = loadValue( txState );\n    vec2 gameSpeed = loadValue( txGameSpeed ).xy;\n \n    for(int i=0; i<noRows; i++) {\n        for(int f=0; f<8; f++) {\n            vec4 invaderState = loadValue( txInvaders.xy + ivec2(f,i));\n            storeValue( txInvaders.xy + ivec2(f,i), invaderState, fragColor, ipx);\n        }\n        vec4 rowData = loadValue( txRowData.xy + ivec2(i,0));\n        storeValue( txRowData.xy + ivec2(i,0), rowData, fragColor, ipx);\n    }\n    for(int i=0; i<noCities; i++) {\n        for(int f=0; f<16; f++) {\n        \tvec4 cityData = loadValue( txCities.xy + ivec2(f, i));\n            storeValue(txCities.xy + ivec2(f,i), cityData, fragColor, ipx);\n        }\n    }\n    for(int i=0; i<noBombs; i++) {\n    \tvec4 bombData = loadValue( txBombs.xy + ivec2(i, 0));\n        storeValue( txBombs.xy + ivec2(i, 0), bombData, fragColor, ipx);\n    }\n    vec3 lastFrame = loadValue( txLastFrame).xyz;\n    if(iFrame==0) {\n    \treset(gameSpeed, bulletPos, saucerPos, invaderPos, lastFrame, state, score, fragColor, ipx);\n    }\n    int frame = int(lastFrame.x);\n    if(iTime > lastFrame.y) {\n   \t\tlastFrame.z += 1.;\n        frame = int(mod(lastFrame.z,2.));\n    }\n    float moveRight = max(texelFetch( iChannel1, ivec2(KEY_D, 0), 0).x, texelFetch( iChannel1, ivec2(KEY_RIGHT, 0), 0).x);\n    float moveLeft = max(texelFetch( iChannel1, ivec2(KEY_A, 0), 0).x, texelFetch( iChannel1, ivec2(KEY_LEFT, 0), 0).x);\n    float pressSpace = texelFetch( iChannel1, ivec2(KEY_SPACE, 0), 0).x;\n    if(state.x == STATE_ATTRACT) {\n        if(pressSpace > .5) {\n        \tchangeState(state, STATE_READYUP);  \n            reset(gameSpeed, bulletPos, saucerPos, invaderPos, lastFrame, state, score, fragColor, ipx);\n        }\n        float brain = hash(floor(iTime * 2.));\n        moveRight = brain > .2 ? 1. : 0.;\n        moveLeft = brain < -.2 ? 1. : 0.;\n        pressSpace = brain > -.1 && brain < .1 ? 1. : 0.;\n        if((moveLeft == 1. && paddlePos < -14.5) || (moveRight == 1. && paddlePos > 12.5)) {\n            moveLeft = 1. - moveLeft;\n            moveRight = 1. - moveRight;\n        }\n    }\n    else if(state.x == STATE_READYUP) {\n    \tif(iTime - state.z > 5.) changeState(state, STATE_GAME);   \n    }\n    else if(state.x == STATE_DEATH) {\n    \tif(iTime - state.z > .3) changeState(state, state.w);   \n    }\n    else if(state.x == STATE_GAMEOVER || state.x == STATE_WIN) {\n    \tif(iTime - state.z > 6.) \n        {\n            changeState(state, STATE_ATTRACT);\n        \treset(gameSpeed, bulletPos, saucerPos, invaderPos, lastFrame, state, score, fragColor, ipx);\n        }\n        //score.x = int(iTime - state.z);\n    }\n    else if(state.x == STATE_WIN) {\n    \tif(iTime - state.z > 10.) changeState(state, STATE_ATTRACT);\n        reset(gameSpeed, bulletPos, saucerPos, invaderPos, lastFrame, state, score, fragColor, ipx);\n    }\n    paddlePos += 0.02 * inputSpeed * (moveRight - moveLeft);\n    paddlePos = clamp(paddlePos, -15., 13.);\n    if(saucerPos.x > -20.) {\n        if(saucerPos.z==1.)\n    \t\tsaucerPos.x -= 0.2 + cos(iTime * 12.) * 0.14;   \n        else\n            saucerPos.w -= 1.;\n    }\n    if(bulletPos.y < .0) {\n        if(pressSpace > .5 && state.x <= STATE_GAME) {\n            bulletPos = vec2(paddlePos + .8, 1.0);   \n        }\n    }\n    else if(bulletPos.y > 15.0) {\n    \tbulletPos.y = -2.;   \n    }\n    else {\n    \tbulletPos.y += 0.25;\n\t\tint collision = checkCollisions(score, bulletPos, invaderPos, saucerPos, fragColor, ipx);\n        if(collision > 0) {\n        \tbulletPos.y = -2.;   \n        }\n    }\n    for(int i=0; i<noBombs; i++) {\n        vec2 bombData = loadValue( txBombs.xy + ivec2(i,0)).xy;\n        if(bombData.y > 15.) {\n            \n        }\n        else if(bombData.y > 0.) {\n        \tbombData.y -= .2;\n            int collision = checkBombCollisions(score, bombData, paddlePos, fragColor, ipx);\n            if(collision > 0) {\n            \tbombData.y = 20.;   \n                if(collision == 2 && state.x != STATE_DEATH) {\n                \tscore.y--;\n                    if(score.y < 0) {\n                        if(state.x==STATE_GAME)\n                    \t\tstate.x = STATE_GAMEOVER;  \n                        else\n                            reset(gameSpeed, bulletPos, saucerPos, invaderPos, lastFrame, state, score, fragColor, ipx);\n                    }\n                    if(state.x != STATE_ATTRACT)\n                    \tchangeState(state, STATE_DEATH);\n                }\n            }\n            storeValue(txBombs.xy + ivec2(i, 0), vec4(bombData, 0., 0.), fragColor, ipx);\n        }\n        else {\n        \tbombData.y = 20.;\n            storeValue(txBombs.xy + ivec2(i, 0), vec4(bombData, 0., 0.), fragColor, ipx);\n        }\n    }\n    float noAlive = 0.;\n    vec4 invaderBounds = checkInvaderBounds(noAlive);\n    float speed = noAlive / float(noRows * noCols);\n    if(noAlive==0.) \n    {\n        if(state.x==STATE_GAME)\n        \tchangeState(state, STATE_WIN);\n       \telse\n            reset(gameSpeed, bulletPos, saucerPos, invaderPos, lastFrame, state, score, fragColor, ipx);\n    }\n    state.y = (speed * 2.) + 1.;\n    gameSpeed.x = max(1. -  (  1. - speed * speed * speed), .02);\n    gameSpeed.y = .1 + (2. - gameSpeed.x) * .1;\n    //score.x = int((invaderPos.y - invaderBounds.y) * 100.);\n    if(frame != int(lastFrame.x)) {\n        lastFrame.x = float(frame);\n        lastFrame.y += gameSpeed.x;\n        if(saucerPos.x < -15. || saucerPos.w < 0.) {\n            float saucerChance = hash(iTime * 23.0);\n            if(saucerChance > 0.495) {\n                saucerPos.x = 20.;\n                saucerPos.z = 1.;\n                saucerPos.w = 0.;\n            }\n        }\n    \tinvaderPos.x -= gameSpeed.y * invaderPos.z;\n        if(invaderPos.x - invaderBounds.w < -14.) {\n        \tinvaderPos.z *= -1.;  \n            invaderPos.x = -14. + invaderBounds.w;\n        }\n        else if(invaderPos.x - invaderBounds.x > 14.) {\n        \tinvaderPos.z *= -1.;\n            if(state.x <= STATE_GAME) invaderPos.y += .25;\n            invaderPos.x = 14. + invaderBounds.x;\n            if((invaderPos.y - invaderBounds.y) > 2.) {\n                if(state.x == STATE_ATTRACT)\n                \treset(gameSpeed, bulletPos, saucerPos, invaderPos, lastFrame, state, score, fragColor, ipx);\n               \telse\n                    changeState(state, STATE_GAMEOVER);\n            }\n        }\n        int freeBombSlot = -1;\n        for(int i=0; i<noBombs; i++) {\n            vec2 bombData = loadValue( txBombs.xy + ivec2(i,0)).xy;\n            if(bombData.y > 15.) {\n            \tfreeBombSlot = i;  \n                break;\n            }\n        }\n        if(freeBombSlot > -1 && state.x <= STATE_GAME) {\n            float dropChance = hash(iTime * 5.0);\n            if(dropChance > 0.) {\n                int bombRow = int(floor((hash(iTime * 3.0) + .5) * float(noRows)));\n                int bombCol = int(floor((hash(iTime * 4.0) + .5) * float(noCols)));\n                vec4 invaderState = loadValue( txInvaders.xy + ivec2(bombCol,bombRow));\n                if(invaderState.x > 0.) {\n                    vec4 rowData = loadValue( txRowData.xy + ivec2(bombRow,0));\n                    vec2 bombData = vec2(-invaderPos.x + (float(bombCol) * 2.) + 0.875, rowData.x - 1.);  \n                    storeValue(txBombs.xy + ivec2(freeBombSlot, 0), vec4(bombData, 0., 0.), fragColor, ipx);\n                \t   \n                }\n            }\n        }\n    }\n    //score.x = int((invaderPos.x) * 10.);\n    //score = int((bulletPos.y));\n    //state.y = 0.;\n    \n    storeValue( txPaddlePos, vec4(paddlePos, 0., 0., 0.), fragColor, ipx);\n    storeValue( txBulletPos, vec4(bulletPos, 0., 0.), fragColor, ipx);\n    storeValue( txSaucerPos, vec4(saucerPos), fragColor, ipx);\n    storeValue( txFrame, vec4(float(frame), 0., 0., 0.), fragColor, ipx);\n    storeValue( txGameSpeed, vec4(gameSpeed, 0., 0.), fragColor, ipx);\n    storeValue( txInvaderPos, vec4(invaderPos, 0.), fragColor, ipx);\n    storeValue( txLastFrame, vec4(lastFrame, 0.), fragColor, ipx);\n    storeValue( txScore, vec4(float(score.x), float(score.y), float(score.z), 0.), fragColor, ipx);\n    storeValue( txState, state, fragColor, ipx);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}