{
    "Shader": {
        "info": {
            "date": "1526083714",
            "description": "pathtracing, it runs really slow\nspace clears buffer",
            "flags": 48,
            "hasliked": 0,
            "id": "ls3cDr",
            "likes": 8,
            "name": "my first pathtracing",
            "published": 3,
            "tags": [
                "truchet",
                "pathtracing",
                "mengersponge"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 743
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor /= fragColor.a;\n    fragColor = sqrt(fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n#define samples (20.0+min(iTime,0.0))\n\n//#define static\n\n#define rots mat3(\t\\\n    -1, 0, 1,\t\t\\\n     1,-1, 0,\t\t\\\n     0, 1,-1)\n\nfloat time = 0.0;\n\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\n//hash function by Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//hash function by Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//a sphere intersection function from iq\n//https://www.shadertoy.com/view/4djSDy\nfloat sphIntersect( in vec3 ro, in vec3 rd)\n{\n\t\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro )-0.2*0.2;\n\tfloat h = b*b - c;\n\tif( h<0.0 || b > 0.0) return 9999.0;\n\treturn -b - sqrt(h);\n}\n\nfloat sphIntersect( in vec2 ro, in vec2 rd, float rad)\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro )-rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0||b>0.0) return 9999.0;\n\treturn -b - sqrt( h );\n}\n\n//sphere intersection by iq\n//modified to raycast the inside of a circle\nfloat sphIntersect2( in vec2 ro, in vec2 rd, float rad)\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro )-rad*rad;\n\tfloat h = b*b - c;\n\tif(h<0.0) return 9999.0;\n\treturn -b + sqrt( h );\n}\n\n//raycasts the outside of a square torus\nfloat torus(vec3 ro, vec3 rd, vec3 rdnorm, vec2 area, float rad) {\n    vec3 normal = vec3(-1);\n    float dist;\n    float a = -ro.y/rd.y;\n    if (a < 0.0 && abs(ro.y) > area.y) return 10.0;\n    float b = abs(area.y/rd.y);\n    float len = max(a-b,0.0);\n    \n    ro += rd*len;\n    dist += len;\n    \n    float len3 = length(ro.xz)-rad;\n    \n    if (len3 > area.x) {\n        float len2 = sphIntersect(ro.xz,rd.xz*rdnorm.y, rad+area.x)*rdnorm.y;\n        ro += rd*len2;\n        dist += len2;\n    }\n    \n    else if (len3 < -area.x) {\n        float len2 = sphIntersect2(ro.xz,rd.xz*rdnorm.y, rad-area.x)*rdnorm.y;\n        ro += rd*len2;\n        dist += len2;\n    }\n    \n    if (abs(ro.y) > area.y+0.001) return 10.0;\n    return dist;\n}\n\n//finds the normal of a square torus\nvec3 torusnormal(vec3 ro, vec2 area, float rad) {\n    vec2 p = vec2(length(ro.xz)-rad,ro.y)*area;\n    vec3 normal = vec3(-1);\n    \n    if (abs(p.x) > abs(p.y)) {\n        normal = vec3(normalize(ro.xz),0.0).xzy*sign(p.x);\n    } else {\n        normal = vec3(0,sign(p.y),0);\n    }\n    \n    return normal;\n}\n\nfloat tracetorus(vec3 ro, vec3 rd, float limit) {\n    \n    vec3 rdnorm = 1.0/vec3(\n        length(rd.yz),\n        length(rd.xz),\n        length(rd.xy));\n    \n    vec3 floorro = floor(ro*0.5);\n    vec3 signrd = sign(rd);\n    vec3 invrd = 1.0/(abs(rd)+0.0001);\n    vec3 mask;\n    vec3 dists = abs(-signrd*0.5-0.5+ro*0.5-floorro)*invrd;\n    float colorsize = 0.0;\n    float dist = 0.0;\n    float len2;\n    bool hit = false;\n    vec3 pos;\n    vec3 dir;\n    vec3 normal;\n    int reflects = 0;\n    for (int i = 0; i < 8; i++) {\n        mask = vec3(lessThanEqual(dists,min(dists.yzx,dists.zxy)));\n        if (dist > limit) break;\n        float len = min(min(dists.x,dists.y),dists.z);\n        //float len = dot(dists,mask)/dot(mask,vec3(1.0));\n\t\t\n    \tvec3 flipping = floor(hash33(floorro)+0.5)*2.0-1.0;\n        \n        vec3 d = rd;\n        vec3 p = (ro-floorro*2.0-1.0);\n        \n        len2 = len*2.0;\n        \n        vec3 t = vec3(\n        \ttorus((p-rots[0]*flipping).xyz,rd.xyz,rdnorm.xyz,vec2(0.03),1.0),\n        \ttorus((p-rots[1]*flipping).yzx,rd.yzx,rdnorm.yzx,vec2(0.03),1.0),\n        \ttorus((p-rots[2]*flipping).zxy,rd.zxy,rdnorm.zxy,vec2(0.03),1.0));\n        float closest = min(min(t.x,t.y),t.z);\n        len2 = min(len2,closest);\n        dist += len2;\n        \n        ro += len2*rd;\n        \n        if (len2 < len*2.0) {\n            hit = true;\n            return dist;\n        } else {\n            floorro += mask*signrd;\n            dists -= len;\n            dists += mask*invrd;\n        }\n    }\n    return 99999.0;\n}\n\nfloat mid(vec3 p) {\n    p = min(p,p.yzx);\n    return max(max(p.x,p.y),p.z);\n}\n\nvec4 intersect(vec3 ro2, vec3 rd) {\n    //float sphere = sphIntersect(ro.xy-light.xy,normalize(rd.xy))/length(rd.xy);\n    \n    float size = 0.6666;\n    vec3 ro = ro2;\n    vec3 invrd = 1.0/abs(rd+0.000001);\n    float dist = 0.0;\n    vec3 normal;\n    for (int i = 0; i < 8; i++) {\n        vec3 pos2;\n        float j;\n            \n        for (j = 1.0; j < 30.0; j *= 3.0) {\n            pos2 = mod(ro*j,3.0*size)-1.5*size;\n            if (mid(abs(pos2)) < 0.49999*size)\n                break;\n        }\n        \n        vec3 num = (0.5*size-pos2*sign(rd))\n            \t   *step(abs(pos2),vec3(0.5*size))\n                   *invrd/j;\n        \n        float len = mid(num);\n        \n        if (len < 0.00001) {\n            break;\n        }\n        \n        normal = vec3(equal(vec3(len),num));\n        \n        ro += rd*len;\n        dist += len;\n    }\n    \n    float light = tracetorus(ro2,rd, dist);\n    \n    if (light > dist)\n    \treturn vec4(dist,-dot(normal,vec3(1,2,3))*sign(dot(normal,rd)),0,0);\n    else\n        return vec4(light,0,1,0);\n}\n\nvec3 surfacecolor(vec3 pos, vec3 nor) {\n    return mix(texture(iChannel0, pos).xyz,nor*0.5+0.5,0.4);\n}\n\nvec3 getcolor(vec3 pos, vec3 dir, vec3 nor)\n{\n    vec3 dcol = surfacecolor(pos,nor);\n    return dcol;\n}\n\nvec3 getlight(vec3 p, vec3 rd) {\n    \n    return vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    for (float i = 0.0; i < samples; i++) {\n        vec3 col = vec3(1);\n        \n        vec2 uv = (fragCoord*2.0-iResolution.xy+2.0*hash23(vec3(i+float(iFrame)*0.584,fragCoord)))/iResolution.y;\n        \n        #ifdef static\n        time = 0.0;//+0.02*hash13(vec3(i+float(iFrame)*0.864,fragCoord));\n        vec3 ro = vec3(1.22,0.55,0.6)+8.0;\n        #else\n        time = iTime*0.4;\n        vec3 ro = vec3(1.22,.75,time)+2.0;\n        #endif\n        \n        vec3 rd = normalize(vec3(uv,1.0));\n        bool hitlight = false;\n        for (float j = 0.0; j < 5.0; j++) {\n            vec4 hit = intersect(ro,rd);\n            \n            ro += rd*(hit.x-0.001);\n            \n            if (hit.z == 1.0) {\n                hitlight = true;\n                break;\n            } else {\n                vec3 normal = vec3(equal(vec3(abs(hit.y)),vec3(1,2,3)))*sign(hit.y);\n                bool diffus = hash13(vec3(i+j*0.334+float(iFrame)*0.864,fragCoord))<0.6;\n                vec3 rd2;\n                float spread;\n                mat3 mat;\n                if (diffus) {\n                    rd2 = normal;\n                    spread = 0.98;\n                    \n                    mat = mat3(rd2,\n                               rd2.yzx,\n                               rd2.zxy);\n                } else {\n                    spread = 0.1;\n                \trd2 = reflect(rd,normal);\n                    \n                    mat[0] = rd2;\n                    mat[1] = cross(mat[0],vec3(0,1,0));\n                    mat[2] = cross(mat[0],mat[1]);\n                }\n                \n                col *= getcolor(ro, rd,normal);\n                col /= hit.x*hit.x+1.0;\n                vec2 rando = hash23(vec3(i*3.14+j+float(iFrame),fragCoord))\n                    *vec2(1,spread);\n                \n                vec2 direction = vec2(sin(rando.x*6.28),cos(rando.x*6.28))*rando.y;\n                rd = mat[0]*sqrt(1.0-rando.y*rando.y)+mat[1]*direction.x+mat[2]*direction.y;\n            }\n        }\n        if (hitlight)\n        fragColor.xyz += clamp(col*getlight(ro,rd),0.0,1.0);//getcolor(ro, rd,normal);\n    }\n    fragColor /= samples;\n    fragColor.a = 1.0;\n    \n    #ifdef static\n    if (texelFetch(iChannel2, ivec2(32,0),0).r == 0.0) fragColor += texelFetch(iChannel1,ivec2(fragCoord),0);\n    #endif\n    //fragColor = sqrt(fragColor);\n    \n    //fragColor = mix(fragColor, texelFetch(iChannel1,ivec2(fragCoord),0),0.3);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}