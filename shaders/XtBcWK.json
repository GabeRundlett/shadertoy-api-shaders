{
    "Shader": {
        "info": {
            "date": "1510094824",
            "description": "mouse changes cloud density.\n\nclouds forked\n not even sure if i did this before.\n2 times the charm?\n\nhere i tried 2 things, both with very minor sucess",
            "flags": 1,
            "hasliked": 0,
            "id": "XtBcWK",
            "likes": 13,
            "name": "clouds forked",
            "published": 3,
            "tags": [
                "cloudsforked"
            ],
            "usePreview": 1,
            "username": "ollj",
            "viewed": 1292
        },
        "renderpass": [
            {
                "code": "//this shader sold itself short on render distance.\n//clouds iq forked (testure is noise rgba\n//https://www.shadertoy.com/view/XtBcWK\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Volumetric clouds. It performs level of detail (LOD) for faster rendering\n\n\n#define STEPS 50.\n\n\n#define sat(a) clamp(a,0.,1.)\n\nvec3 sundir=normalize( vec3(-1,0,-1));\n\n//this noise only works for medium-sited texture buffers?\nfloat noise(vec3 x)\n{vec3 p=floor(x),f=fract(x)\n;f*=f*(3.-2.*f)\n#if 0\n ;vec2 u=(p.xy+vec2(37,17)*p.z)+f.xy\n ,i=vec2(textureSize( iChannel0,0))\n ,g=textureLod( iChannel0,(u+.5)/i,0.).yx;\n#else\n ;ivec3 q=ivec3(p)\n ;ivec2 u=q.xy+ivec2(37,17)*q.z,i=ivec2(textureSize(iChannel0,0))-1\n ;vec2 g=mix(mix(texelFetch(iChannel0,(u           )&i.x,0)\n                ,texelFetch(iChannel0,(u+ivec2(1,0))&i.x,0),f.x)\n            ,mix(texelFetch(iChannel0,(u+ivec2(0,1))&i.x,0)\n                ,texelFetch(iChannel0,(u+ivec2(1,1))&i.x,0),f.x),f.y).yx\n#endif    \n ;return -1.+2.*mix(g.x,g.y,f.z);}\n\nfloat mapN(float y,float f){\n    \n    y*=1.-iMouse.y/iResolution.y;//different .y scaling of cloud density than parent shader!\n    return sat(1.5-y-2.+1.75*f);}\n    \n\nfloat map2n(vec3 p)\n{vec3 q=p-vec3(0,.1,1)*iTime\n;float f=.5*noise(q);\n;return f+.25*noise(q*2.02);}\nfloat map2(vec3 p){return mapN(p.y,map2n(p));}\nfloat map3n(vec3 p)\n{vec3 q=p-vec3(0,.1,1)*iTime\n;float f=.5*noise(q);q*=2.02\n;f+=.25*noise(q);\n;return f+.125*noise(q*2.03);}\nfloat map3(vec3 p){return mapN(p.y,map3n(p));}\nfloat map4n(vec3 p)\n{vec3 q=p-vec3(0,.1,1)*iTime\n;float f=.5*noise(q);q*=2.02\n;f+=.25*noise(q);q*=2.03;\n;f+=.125*noise(q);\n;return f+.0625*noise(q*2.01);}\nfloat map4(vec3 p){return mapN(p.y,map4n(p));}\nfloat map5n(vec3 p)\n{vec3 q=p-vec3(0,.1,1)*iTime\n;float f=.5*noise(q);q*=2.02\n;f+=.25*noise(q);q*=2.03;\n;f+=.125*noise(q);q*=2.01\n;f+=.0625*noise(q);\n;return f+.03125*noise(q*2.02);}\nfloat map5(vec3 p){return mapN(p.y,map5n(p));}\n//carrying the q trouugh these \n// makes it inefficient to make them subsets.\n\n\n//sum,difference,density,bgcol,t\nvec4 integrate(vec4 a,float d,float e,vec3 b,float t)\n{vec4 c=vec4(mix(vec3(1,.95,.8),vec3(.25,.3,.35),e),e)\n;c.xyz*=vec3(.65,.7,.75)*1.4+vec3(1,.6,.3)*d\n;c.xyz=mix(c.xyz,b,1.-exp(-.003*t*t))\n;c.a*=1.1\n;c.rgb *= c.a\n;return a+c*(1.-a.a);}\n\n//an alias for a raymarch loop? fo0r real?\n//to march trough 4 fbm fields aat once\n//that are subsets of another?\n//yeah, this is a bit excessive\n//and definitely inefficient\n//ths misses way too many possible shortcuts.\n\n\n//#define MARCH(MAPLOD) for(int i=0;i<STEPS;i++){vec3 pos=ro+t*rd;if(pos.y<-3.||pos.y>2.0||s.a > 0.99 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif =  clamp((den - MAPLOD(pos+0.3*sundir))/0.6, 0.0, 1.0 ); s= integrate( s, dif, den, bgcol, t ); } t += max(0.05,0.02*t); }\n\n#define tplus t+=.006+(t*.014+(t*.015));}\n//above gets \"flickery\" with increasing distance.\n//below does not, simply lacks distance.\n//max(.1,t);}\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 b, in ivec2 px )\n{vec4 s=vec4(0)\n;float t=.0\n//;0.05*texelFetch( iChannel0, px&255, 0 ).x;\n//ollj unwraped the #define, hoping to mix something nicer.\n//but so far that failed.\n;for(float i=0.;i<STEPS;i++\n){vec3 p=ro+t*rd\n ;if(s.a>.99)break\n //;if(p.y<-3.||p.y>2.)break //bounding volume with bad c1 continuity\n ;float d=map5(p)\n ;if(d>.01)s=integrate(s,sat((d-map5(p+.3*sundir))/.6),d,b,t)\n ;tplus\n;for(float i=0.;i<STEPS;i++\n){vec3 p=ro+t*rd\n ;if(s.a>.99)break\n //;if(p.y<-3.||p.y>2.)break //bounding volume with bad c1 continuity\n ;float d=map4(p)\n ;if(d>.01)s=integrate(s,sat((d-map4(p+.3*sundir))/.6),d,b,t)\n ;tplus\n;for(float i=0.;i<STEPS;i++\n){vec3 p=ro+t*rd\n ;if(s.a>.99)break\n //;if(p.y<-3.||p.y>2.)break //bounding volume with bad c1 continuity\n ;float d=map3(p)\n ;if(d>.01)s=integrate(s,sat((d-map3(p+.3*sundir))/.6),d,b,t)\n     /*\n//this mix doesnt work as expected.\n ;tplus\n ;if(s.a>0.99)break\n ;d=map2(p)\n ;if(d>.01)s=integrate(s,sat((d-map2(p+.3*sundir))/.6),d,b,t)\n/**/\n ;tplus\n;for(float i=0.;i<STEPS;i++\n){vec3 p=ro+t*rd\n ;if(s.a>.99)break\n //;if(p.y<-3.||p.y>2.)break //bounding volume with bad c1 continuity\n ;float d=map2( p )\n ;if(d>.01)s=integrate(s,sat((d-map2(p+.3*sundir))/.6),d,b,t)\n ;tplus\n;return sat(s);}\n\nmat3 setCamera(vec3 u,float r){vec3 w=normalize(u)\n;u=normalize(cross(w,vec3(sin(r),cos(r),0)))\n;return mat3(u,normalize(cross(u,w)),w);}\n\n\nvec4 render(vec3 u,vec3 t,ivec2 p ){\n;float s=sat(dot(sundir,t))\n;vec3 c=vec3(.6,.71,.75)-t.y*0.2*vec3(1,.5,1)+.15*.5\n;c+=.2*vec3(1,.6,.1)*pow(s,8.)   // background sky  \n;vec4 r=raymarch(u,t,c,p)// clouds  \n;c*=(1.-r.w)+r.xyz\n;c+=.2*vec3(1,.4,.2)*pow(s,3.)// sun glare    \n;return vec4(c,1);}\n\n  //here is where i got really tired.\n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // camera\n    vec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 0.4*m.y, cos(3.0*m.x)));\n\tvec3 ta = vec3(0.0, -1.0, 0.0);\n    mat3 ca = setCamera( ta-ro, 0.0 );\n    // ray\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n    \n    fragColor = render( ro, rd, ivec2(fragCoord-0.5) );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragColor = render( fragRayOri, fragRayDir, ivec2(fragCoord-0.5) );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}