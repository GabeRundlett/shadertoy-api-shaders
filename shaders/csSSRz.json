{
    "Shader": {
        "info": {
            "date": "1669772538",
            "description": "Something I made for myself when I need to graph something with pretty antialiased lines.\nTrying to cram complex math statements into a single line as required by google's or wolfram's graphing calculator is simply annoying and messy.",
            "flags": 0,
            "hasliked": 0,
            "id": "csSSRz",
            "likes": 2,
            "name": "Hatchling's Graphing Calculator",
            "published": 3,
            "tags": [
                "graph",
                "aa"
            ],
            "usePreview": 0,
            "username": "Hatchling",
            "viewed": 267
        },
        "renderpass": [
            {
                "code": "const vec4 BackgroundColor = vec4(0.0, 0.05, 0.1, 1);\n\nfloat myFunc(float x) \n{ \n    // Write your custom function to plot here.\n    x *= x; \n    return sin(x)/x; \n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gFragCoord = fragCoord;\n    gResolution = iResolution.xy;\n    \n    fragColor = BackgroundColor;\n    \n    // Draw grids.\n    drawGrid(fragColor, vec2(0.1), vec4(1,0.5,0.5,0.02), vec4(0.5, 1, 0.5, 0.02));\n    drawGrid(fragColor, vec2(1), vec4(1,0.5,0.5,0.1), vec4(0.5, 1, 0.5, 0.1));\n    drawGrid(fragColor, vec2(10), vec4(1,0.5,0.5,0.5), vec4(0.5, 1, 0.5, 0.5));\n    \n    // Draw trig functions.\n    drawGraph(fragColor, tf(sin, fragCoord), vec4(1,0,0,1));\n    drawGraph(fragColor, tf(cos, fragCoord), vec4(0,0,1,1));\n    \n    // Draw custom function.\n    drawGraph(fragColor, tf(myFunc, fragCoord), vec4(1,1,0,1));\n    \n    // Add more functions to plot here.\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Displayed range of the graph.\nconst vec2 mini = vec2(-5, -2);\nconst vec2 maxi = vec2(5, 2);\n\n#define StLine 0\n#define StSolid 1\n#define Style StLine\n\n// Global vars used by overloads when you're lazy.\nvec2 gFragCoord;\nvec2 gResolution;\n\nvec2 fragToView(vec2 fragCoord, vec2 resolution)\n{\n    return mix(mini, maxi, fragCoord / resolution);\n}\n\nvec2 viewToFrag(vec2 viewCoord, vec2 resolution)\n{\n    return (viewCoord - mini) / (maxi - mini) * resolution;\n}\n\nvec2 fragToView(vec2 fragCoord)\n{\n    return fragToView(fragCoord, gResolution);\n}\n\nvec2 viewToFrag(vec2 viewCoord)\n{\n    return viewToFrag(viewCoord, gResolution);\n}\n\nfloat fragToViewX(float fragCoordX, float resolutionX)\n{\n    return mix(mini.x, maxi.x, fragCoordX / resolutionX);\n}\n\nfloat viewToFragY(float viewCoordY, float resolutionY)\n{\n    return (viewCoordY - mini.y) / (maxi.y - mini.y) * resolutionY;\n}\n\nfloat fragToViewX(float fragCoordX)\n{\n    return fragToViewX(fragCoordX, gResolution.x);\n}\n\nfloat viewToFragY(float viewCoordY)\n{\n    return viewToFragY(viewCoordY, gResolution.y);\n}\n\n#define tf(func, fragCoord) (viewToFragY(func(fragToViewX(fragCoord.x))))\n\nfloat getGraphOpacity( in float fragHeight, in float graphHeight )\n{\n    if(isnan(graphHeight) || isinf(graphHeight)) \n        return 0.0;\n    \n    float range = (1.0 + abs(dFdx(graphHeight)));\n    \n    #if Style == StLine\n        range *= 2.0;\n    #endif\n    \n    float upper = graphHeight + range;\n    float lower = graphHeight - range;\n    \n    float value = (fragHeight - lower) / (upper - lower);\n    \n    #if Style == StLine\n        value = (abs(value - 0.5) * 2.0);\n    #endif\n    \n    return 1.0 - smoothstep(0., 1., value);\n}\n\nvoid drawGraph( inout vec4 fragColor, in float fragHeight, in float graphHeight, in vec4 color )\n{\n    float opacity = getGraphOpacity(fragHeight, graphHeight);\n    \n    vec4 c = color;\n    c.a *= opacity;\n    \n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    fragColor.a = mix(fragColor.a, 1.0, c.a);\n}\n\nvoid drawGraph( inout vec4 fragColor, in float graphHeight, in vec4 color )\n{\n    drawGraph(fragColor, gFragCoord.y, graphHeight, color);\n}\n\nvec2 getGridOpacity(in vec2 fragCoord, in vec2 resolution, in vec2 gridSpacing)\n{\n    vec2 viewCoord = fragToView(fragCoord, resolution) / gridSpacing;\n    vec2 nearestGridViewCoord = round(viewCoord) * gridSpacing;\n    vec2 nearestGridFragCoord = viewToFrag(nearestGridViewCoord);\n    \n    const vec2 range = vec2(2);\n    \n    vec2 upper = nearestGridFragCoord + range;\n    vec2 lower = nearestGridFragCoord - range;\n    \n    vec2 value = (fragCoord - lower) / (upper - lower);\n    \n    value = (abs(value - 0.5) * 2.0);\n    \n    return 1.0 - smoothstep(0., 1., value);\n}\n\nvoid drawGrid( inout vec4 fragColor, in vec2 fragCoord, in vec2 resolution, in vec2 gridSpacing, in vec4 colorHorizLines, in vec4 colorVertLines )\n{\n    vec2 opacity = getGridOpacity(fragCoord, resolution, gridSpacing);\n    \n    vec4 cH = colorHorizLines;\n    cH.a *= opacity.y;\n    vec4 cV = colorVertLines;\n    cV.a *= opacity.x;\n    \n    float ratio = cV.a / (cV.a + cH.a);\n    \n    if(isnan(ratio) || isinf(ratio)) ratio = 0.5;\n    \n    vec4 c;\n    c.rgb = mix(cH.rgb, cV.rgb, ratio);\n    c.a = mix(cH.a, 1.0, cV.a);\n    \n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    fragColor.a = mix(fragColor.a, 1.0, c.a);\n}\n\nvoid drawGrid( inout vec4 fragColor, in vec2 gridSpacing, in vec4 colorHorizLines, in vec4 colorVertLines )\n{\n    drawGrid(fragColor, gFragCoord, gResolution, gridSpacing, colorHorizLines, colorVertLines);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}