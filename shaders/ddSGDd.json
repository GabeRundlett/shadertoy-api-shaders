{
    "Shader": {
        "info": {
            "date": "1668416226",
            "description": "Question: \n- Is there any way to optimize the raymarching in order to plot a maximum of particles?",
            "flags": 32,
            "hasliked": 0,
            "id": "ddSGDd",
            "likes": 9,
            "name": "Particles RayMarching experiment",
            "published": 3,
            "tags": [
                "raymarching",
                "particles",
                "bloom"
            ],
            "usePreview": 0,
            "username": "rubioh",
            "viewed": 420
        },
        "renderpass": [
            {
                "code": "const int MAX_MARCHING_STEPS = 30;\nconst float MIN_DIST = 6.;\nconst float MAX_DIST = 3.;\nconst float PRECISION = 0.002;\n#define AA 0\n#define PI 3.14159\n\n// iq's palette\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.2, 0.2, 1.);\n    vec3 b = vec3(0.7, 0.7, 0.7);\n    vec3 c = vec3(1., 1., 1.);\n    vec3 d = vec3(0.3, 0.1, 0.8);\n    \n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat Ring(vec3 p, inout vec3 col, inout vec3 col_bloom){\n    float d = 1e10;\n        \n    vec3 p_s = p;\n    \n    float d2;\n    vec3 pos;\n    for (int i=0; i<int(get_NPARTICLES()); i++){\n        vec3 tmp = texelFetch(iChannel0, ivec2(i, 0.), 0).xyz;\n        \n        pos.xy = decode(tmp.x);\n        pos.z = tmp.y;\n        \n        vec3 res = p_s + pos;\n       \n         d2 = sdSphere(res, .01);\n        \n        if (d2<d){\n           col = palette(float(i)/get_NPARTICLES()+iTime/8.);\n           d = d2;\n        }\n        if (iFrame >= 1) col_bloom += palette(float(i)/get_NPARTICLES()+iTime/8.)*.1*exp(-abs(d2*d2)/.005); \n;\n          \n    }\n    return d;\n}\n\n\nfloat map(vec3 p, inout vec3 col, inout vec3 col_bloom){\n    float d = 1e10;    \n    p += vec3(1., 0., 1.);\n    d = Ring(p, col, col_bloom);    \n        \n    return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float start, out vec3 col, inout float min_dist, inout vec3 col_bloom) {\n  float depth = start, min_d = 1e10;\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = map(p, col, col_bloom);\n    depth += d;\n    if (d < PRECISION){\n        break;\n        }\n    if (d>MAX_DIST){\n        break;\n    }\n    if (d<min_d){\n        min_dist = d;\n        min_d = d;\n    }\n    }\n    return depth;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.001;\n    vec3 c, c2;\n    return normalize(\n      e.xyy * map(p + e.xyy,c,c2) +\n      e.yyx * map(p + e.yyx,c,c2) +\n      e.yxy * map(p + e.yxy,c,c2) +\n      e.xxx * map(p + e.xxx,c,c2));\n}\n\n\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, vec3 col, float spec) {\n  // ambient\n  float N = 2.;\n  vec3 ambient = (col*N)/N;\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = (col * dotLN*N)/N;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal)/1.4, -rd), 0., 1.);\n  vec3 specular = 50.*spec*((.5*col+vec3(.5)) * pow(dotRV, 15.)*N)/N;\n\n  return ambient + diffuse; + specular;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.1)*4.;\n  \n  vec3 col;\n  vec3 col_tot = vec3(0.);\n\n  \n    vec3 ro = vec3(-1., 0., 1.); \n    vec3 rd = normalize(vec3(uv, -1)); \n  \n\n  vec3 normal;\n  float d;\n  float L=0.;\n  float depth2 = 1e10;\n  float min_depth = 1e10;\n  vec3 col_bloom;\n                    \n  vec3 rd2 = rd;\n  d = rayMarch(ro, rd2, d+1., col, min_depth, col_bloom); \n  if (d > MAX_DIST) {\n    col_tot = vec3(0.); \n  } else {\n    vec3 p = ro + rd * d;\n    normal = calcNormal(p);\n    vec3 lightPosition = vec3(1, 1, 2);\n    vec3 lightDirection = normalize(lightPosition - p);\n    float lint = 5.;\n    col_tot += lint*phong(lightDirection, normal, rd, col/4., 3.);\n   }\n           \n    \n  col_tot += col_bloom;\n  \n  col_tot = vec3(col_tot)/float(AA+1)/float(AA+1);\n  // Output to screen\n  fragColor = vec4(col_tot*.4, d);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define NPARTICLES 150\n#define PI 3.14159\n\nfloat get_NPARTICLES(){\n    return float(NPARTICLES);\n}\n\nfloat hash11( float x){\n    return fract( sin( float(x)*101.4567)*41.234);\n}\n\n\nvec2 hash22(vec2 p){\n    vec2 a = vec2(10.487,9.4567);\n    vec2 b = vec2(456.775, 150.2467);\n    return fract( sin(vec2(dot(a,p), dot(b,p)))*41.234);\n}\n\nvec3 hash33(vec3 p){\n    vec3 a = vec3(10.487,9.4567, 41.28753);\n    vec3 b = vec3(456.775, 150.2467, 234.4565);\n    vec3 c = vec3(21.125, 15.6754, 23.6125);\n    return fract( sin(vec3(dot(a,p), dot(b,p), dot(c,p)))*41.234);\n}\n\nvec3 hash13(float x){\n    vec3 p = vec3(x,x,x);\n    vec3 a = vec3(10.487,9.4567, 41.28753);\n    vec3 b = vec3(456.775, 150.2467, 234.4565);\n    vec3 c = vec3(21.125, 15.6754, 23.6125);\n    return fract( sin(vec3(dot(a,p), dot(b,p), dot(c,p)))*41.234);\n}\n\n// PACK UNPACK METHODS FROM https://www.shadertoy.com/view/WtfyDj\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\n// iq's sdf\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec3 init_position(vec3 seed){\n    vec3 pos = vec3(seed);\n    return vec3(pos);\n}\n\nvec3 init_velocity(vec3 seed){\n    vec3 vel = vec3(seed.yxz);\n    return vec3(vel);\n}\n\n// found this on: https://www.vertexshaderart.com/art/aqgyqr6ASpcsZTeEu\nvec2 sphere_point(float i) {\n  // golden ratio\n  float phi = (sqrt(5.) + 1.) / 2. - 1.;\n  // golden angle\n  float ga = phi * 2. * PI;\n  \n  vec2 p = vec2(0.);  \n  p.x = ga * i;\n  p.x /= 2. * PI;\n  p.x = fract(p.x);\n  p.x *= 2. * PI;\n    \n  p.y = asin(-1. + 2. * i / get_NPARTICLES());\n  return p;\n}\nvec3 lla2xyz(vec2 latlon, float rad) {\n  float rxz = rad * cos(latlon.y);\n  \n  return vec3(\n    rxz * cos(latlon.x),\n    rad * sin(latlon.y),\n    rxz * sin(latlon.x)\n  );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 uv = ivec2(fragCoord.xy);\n    \n    \n    if (uv.x>int(get_NPARTICLES())){\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    \n    vec3 center_obj = vec3(0.);\n    \n    vec3 pos;\n    vec3 vel;\n    \n    if (iFrame <= 1){\n        float seedx = hash11( float(uv.x)+.1);\n        float seedy = hash11( float(uv.x)+5.);\n        float seedz = hash11(  float(uv.x)+1.);\n        pos = init_position(vec3(seedx, seedy, seedz));\n        vel = init_velocity(vec3(seedx, seedy, seedz));\n        }\n        \n    else{\n        vec4 state = texelFetch(iChannel0, uv, 0);\n        \n        pos.xy = decode(state.x);\n        pos.z = state.y;\n        \n        vec2 tmp = sphere_point(mod(float(uv.x)-10.*floor(iTime), get_NPARTICLES()));\n        vec3 id = lla2xyz(tmp, .5) + .05*(hash13(float(uv.x)+floor(iTime*2.*PI)) -.5)*(.5+.5*cos(iTime));\n               \n        vel.xy = decode(state.z);\n        vel.z = state.w;\n        \n        pos += vel*.2;\n        vel = (.96 * vel + .04 * -(pos-id));\n        \n        /*\n        vec3 pos2;\n        for (int i=-2; i<=2; i++){\n            if (i == 0) continue;\n            vec4 state2 = texelFetch(iChannel0, ivec2(uv.x + i, 0.), 0);\n\n            pos2.xy = decode(state2.x);\n            pos2.z = state2.y;\n            \n            vel += .01*pow((pos-pos2), vec3(1.));\n            \n        }\n        */\n        \n        \n        \n               \n    }\n    \n    vec4 state;\n    \n    state.x = encode(pos.xy);\n    state.y = pos.z;\n    \n    state.z = encode(vel.xy);\n    state.w = vel.z;\n\n    \n    fragColor = state;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}