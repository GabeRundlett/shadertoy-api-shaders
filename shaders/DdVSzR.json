{
    "Shader": {
        "info": {
            "date": "1681055350",
            "description": "Based on my entry for the 4Kb Executable Graphics compo at Revision 2023.\n(Some changes made to improve performance.)\nhttps://demozoo.org/graphics/322475/",
            "flags": 0,
            "hasliked": 0,
            "id": "DdVSzR",
            "likes": 92,
            "name": "RetroVision (Revision 2023)",
            "published": 3,
            "tags": [
                "3d",
                "reflection",
                "raymarch",
                "camera",
                "glass",
                "wood",
                "antique"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 6246
        },
        "renderpass": [
            {
                "code": "// 'RetroVision' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/DdVSzR\n// https://demozoo.org/graphics/322475/\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Based on my entry for the 4Kb Executable Graphics compo at Revision 2023.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST\t.0002\n#define START_DIST\t1.0\n#define MAX_STEPS\t100.\n#define MAX_RDIST\t5.\n#define MAX_RSTEPS\t32.\n#define SHADOW_STEPS\t20.0\n\n#define LIGHT_RGB\tvec3(2, 1.32, 1.16)\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define I0\tmin(iFrame, 0)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0.0, 1.0, a)\n\nbool hitGlass;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 p;\n};\n\nvoid U(inout Hit h, float d, int id, vec3 p) { if (d < h.d) h = Hit(d, id, p); }\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat dot3(vec3 v) { return dot(v, v); }\n\nfloat sum2(vec2 v) { return dot(v, vec2(1)); }\n\n///////////////////////////////////////////////////////////////////////////////\nfloat h31(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 333.3456);\n\treturn fract(sum2(p3.xy) * p3.z);\n}\n\nfloat h21(vec2 p) { return h31(p.xyx); }\n\nfloat n31(vec3 p) {\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, sum2(s.yz)) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\n// roughness: (0.0, 1.0], default: 0.5\n// Returns unsigned noise [0.0, 1.0]\nfloat fbm(vec3 p, int octaves, float roughness) {\n\tfloat sum = 0.0,\n\t      amp = 1.,\n\t      tot = 0.0;\n\troughness = sat(roughness);\n\twhile (octaves-- > 0) {\n\t\tsum += amp * n31(p);\n\t\ttot += amp;\n\t\tamp *= roughness;\n\t\tp *= 2.0;\n\t}\n\treturn sum / tot;\n}\n\nvec3 randomPos(float seed) {\n\tvec4 s = vec4(seed, 0, 1, 2);\n\treturn vec3(h21(s.xy), h21(s.xz), h21(s.xw)) * 100.0 + 100.;\n}\n\n// Returns unsigned noise [0.0, 1.0]\nfloat fbmDistorted(vec3 p, int octaves, float roughness, float distortion) {\n\tp += (vec3(n31(p + randomPos(0.0)), n31(p + randomPos(1.0)), n31(p + randomPos(2.0))) * 2. - 1.) * distortion;\n\treturn fbm(p, octaves, roughness);\n}\n\n// vec3: detail(/octaves), dimension(/inverse contrast), lacunarity\n// Returns signed noise.\nfloat musgraveFbm(vec3 p, float octaves, float dimension, float lacunarity) {\n\tfloat sum = 0.0,\n\t      amp = 1.0;\n\tfloat pwMul = pow(lacunarity, -dimension);\n\twhile (octaves-- > 0.0) {\n\t\tfloat n = n31(p) * 2. - 1.;\n\t\tsum += n * amp;\n\t\tamp *= pwMul;\n\t\tp *= lacunarity;\n\t}\n\treturn sum;\n}\n\n// Wave noise along X axis.\nvec3 waveFbmX(vec3 p, float distort, int detail, float detailScale, float roughness) {\n\tfloat n = p.x * 20.0;\n\tn += distort != 0.0 ? distort * fbm(p * detailScale, detail, roughness) : 0.0;\n\treturn vec3(sin(n) * 0.5 + 0.5, p.yz);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Math\n// Smooth min()\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat remap01(float f, float in1, float in2) { return sat((f - in1) / (in2 - in1)); }\n\n///////////////////////////////////////////////////////////////////////////////\n// Space manipulation.\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 dx(vec3 p, float e) {\n\tp.x += e;\n\treturn p;\n}\n\nvec3 dy(vec3 p, float e) {\n\tp.y += e;\n\treturn p;\n}\n\nvec3 dz(vec3 p, float e) {\n\tp.z += e;\n\treturn p;\n}\n\n// Return abs(p.x) with offset.\nvec3 ax(vec3 p, float d) { return vec3(abs(p.x) - d, p.yz); }\n\n// Return abs(p.y) with offset.\nvec3 ay(vec3 p, float d) { return vec3(p.x, abs(p.y) - d, p.z); }\n\n// Return abs(p.z) with offset.\nvec3 az(vec3 p, float d) { return vec3(p.xy, abs(p.z) - d); }\n\n// Polar/circular repeat.\nvec3 opModPolar(vec3 p, float n, float o) {\n\tfloat angle = 3.141 / n,\n\t      a = mod(atan(p.x, p.y) + angle + o, 2. * angle) - angle;\n\tp.xy = length(p.xy) * vec2(cos(a), sin(a));\n\treturn p;\n}\n\n// Convert 2D sdf into 3D sdf.\nfloat insulate(vec3 p, float sdf2d) {\n\tfloat dp = p.x; // distance to plane\n\treturn sqrt(dp * dp + sdf2d * sdf2d);\n}\n\n// Bend space along the x axis.\nvec3 bend(vec3 p, float k) {\n\tfloat c = cos(k * p.x);\n\tfloat s = sin(k * p.x);\n\tp.xy *= mat2(c, s, -s, c);\n\treturn p;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// SDFs\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat box2d(vec2 p, vec2 b) {\n\tvec2 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max2(q), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nfloat tor(vec3 p, vec2 t) {\n\tvec2 q = vec2(length(p.xy) - t.x, p.z);\n\treturn length(q) - t.y;\n}\n\nfloat arc(vec3 p, float l, float a) {\n\tvec2 sc = vec2(sin(a), cos(a));\n\tfloat ra = 0.5 * l / a;\n\tp.x -= ra;\n\tvec2 q = p.xy - 2.0 * sc * max(0.0, dot(sc, p.xy));\n\tfloat u = abs(ra) - length(q);\n\tfloat d2 = (q.y < 0.0) ? dot(q + vec2(ra, 0.0), q + vec2(ra, 0.0)) : u * u;\n\tfloat s = sign(a);\n\treturn sqrt(d2 + p.z * p.z);\n}\n\nfloat hex3D(vec3 p, vec2 h) {\n\tconst vec3 k = vec3(-.8660254, .5, .57735);\n\tp = abs(p);\n\tp.zy -= 2. * min(dot(k.xy, p.zy), 0.) * k.xy;\n\tvec2 d = vec2(length(p.zy - vec2(clamp(p.z, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x), p.x - h.y);\n\treturn min(max2(d), 0.) + length(max(d, 0.));\n}\n\nvec3 rayDir(vec3 ro, vec2 uv) {\n\tvec3 f = normalize(-ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Environment/textures/materials.\nvec3 skyCol(float y) {\n    return pow(vec3(max(1.0 - y * 0.5, 0.0)), vec3(6, 3, 1.5)) * vec3(1, 0.7, 0.6);\n}\n\n// Sky with clouds.\nvec3 sky(vec3 rd) {\n\treturn skyCol(rd.y);\n}\n\nfloat fakeEnv(vec3 n) {\n\t// Thanks Blackle.\n\treturn length(sin(n * 2.5) * 0.5 + 0.5) * 0.8;\n}\n\n// Wood material. Returns rgb, depth\nvec4 matWood(vec3 p) {\n\tfloat n1 = fbmDistorted(p * vec3(1, .15, .15) * 8., 8, .5, 1.12);\n\tn1 = mix(n1, 1., 0.2);\n\tfloat n2 = musgraveFbm(vec3(n1 * 4.6), 8., 0., 2.5);\n\tfloat n3 = mix(n2, n1, 0.85);\n\tvec3 q = waveFbmX(p * vec3(0.01, .15, .15), .4, 3, 3., 3.);\n\tfloat dirt = 1. - musgraveFbm(q, 15., 0.26, 2.4) * .4;\n\tfloat grain = 1. - S(0.2, 1.0, musgraveFbm(p * vec3(500, 6, 1), 2., 2., 2.5)) * 0.2;\n\tn3 *= dirt * grain;\n\tvec3 c1 = vec3(.032, .012, .004);\n\tvec3 c2 = vec3(.25, .11, .037);\n\tvec3 c3 = vec3(.52, .32, .19);\n\tfloat depth = grain * n3;\n\tvec3 col = mix(c1, c2, remap01(n3, 0.185, 0.565));\n\tcol = mix(col, c3, remap01(n3, 0.565, 1.));\n\treturn vec4(col, depth);\n}\n\n#define SKY_ID\t0\n#define PLANK_ID\t1\n#define CAM_WOOD_ID\t2\n#define LEATHER_ID\t3\n#define LENS_COLOR_BACK_ID\t4\n#define BELOW_ARE_REFLECTIVE\t5\n#define BRASS_ID\t6\n#define DARKER_BRASS_ID\t7\n#define GLASS_ID\t8\n#define INLAY_ID\t9\n\nfloat screw(vec3 p) {\n\tp.xy *= rot(0.6);\n\treturn cyl(p, vec2(.02, 0.01 * S(0.001, 0.003, abs(p.x))));\n}\n\nfloat nutCap(vec3 p) { return min(cap(p, .02, .015), hex3D(p, vec2(.02))); }\n\nfloat knob(vec3 p, float r, float w) {\n\tp.z = abs(p.z + w);\n\tfloat l = length(p.xy),\n\t      a = atan(p.y, p.x);\n\tfloat d = l - r;\n\td += S(0.8, 1., sin(a * 400. * r)) * 0.002 * S(1.5, 0.5, p.z / w);\n\tp.z -= w;\n\td = smin(d, p.z, -0.01);\n\tr *= 0.7;\n\td = min(d, tor(p, vec2(r, r * 0.1)));\n\tp.z -= w * 3.;\n\td = smin(min(d, l - r), p.z, -0.01);\n\tr *= .85;\n\td = smin(d, tor(p, vec2(r, r * 0.05)), 0.01);\n\treturn min(d, length(p) - r * 0.2);\n}\n\nfloat s(vec3 p) {\n\tp = dy(dx(p.zyx, .04), .08);\n\tp.xy *= rot(-0.4);\n\tp.y = p.x < 1.0 ? p.y : -p.y;\n\tp.x = abs(p.x);\n\tp.xy *= rot(-0.707);\n\treturn arc(p, .18, 0.85);\n}\n\nHit sdf(vec3 p) {\n\tp.y -= 0.1;\n\n\t// Planks.\n\tvec3 q = p + vec3(0, 1.5, 0), v3;\n\tq.xz *= rot(0.15);\n\tfloat f = floor(q.x);\n\tq.x = fract(q.x) - 0.5;\n\tq = bend(q, .1 * n31(p * .5));\n\tfloat d = box(q, vec3(0.485, .5, 99));\n    q = p * .016;\n    q.z += f;\n\n\tHit h = Hit(d, PLANK_ID, q);\n\n\t// Camera front box.\n\tp.y += 0.15;\n\tf = .85 - step(0.0, p.y) * (1. - cos(p.z)) * 0.6;\n\tv3 = vec3(0.45, f, 0.64);\n\td = box(p, v3 - .044) - .044;\n\tq = dx(p, -0.83);\n\td = smin(d, -box(q, v3 - 0.06), -0.1);\n\tU(h, d * 0.95, CAM_WOOD_ID, p);\n\n\t// Front box top brass pattern.\n\td = box2d(p.xz, vec2(.23, .5));\n\td = max(d, .17 - length(az(ax(p, .24), .52).xz));\n\td = abs(d) - 0.005;\n\tf = p.y - f - 0.01;\n\td = smin(d, f, -0.01);\n\tf -= abs(sin(atan(p.z, p.x) * 14.)) * 0.006 * S(.07, .09, length(p.xz));\n\td = min(d, box2d(p.xz, vec2(0.07, .28)) - 0.03);\n\td = smin(d, f, -0.005);\n\tU(h, d, BRASS_ID, p);\n\n\t// Front box inlay.\n\tq.x += .78;\n\td = box(q, v3 - 0.08) - 0.02;\n\tU(h, d * 0.94, INLAY_ID, p);\n\n\t// Front box nuts.\n\tv3 = dx(q, -.41);\n\tv3 = az(ay(v3, .65), .53);\n\tv3.yz *= rot(0.5);\n\td = nutCap(v3);\n\td = min(d, s(dx(v3, .017)));\n\tU(h, d, BRASS_ID, p);\n\n\t// Camera back box.\n\tq.zxy = bend(p.zxy, 0.2);\n\tq.x += 0.7;\n\tv3 = vec3(0.2405, .9, 0.6505);\n\td = smin(box(q, v3) - .02, box(q, vec3(.18, .98, .46)), .025);\n\td -= S(0., 1., abs(f)) * 0.001;\n\tU(h, d, LEATHER_ID, q);\n\n\t// Back box dials.\n\tq.y -= .885;\n\td = box(ay(q, 0.014), vec3(0.265, -.002, .675));\n\td = min(d, knob(p.xzy + vec3(.65, .38, -1.025), .1, .01));\n\n\t// Strap bolt.\n\td = min(d, cyl(p + vec3(.5, -.73, 0), vec2(.04 - 0.008 * S(0., 0.02, p.z + .82), .85)));\n\n\t// Side focus wheel.\n\td = min(d, knob(dz(p - vec3(.05, -.1, 0), .67), .25, .01));\n\tU(h, d, BRASS_ID, p);\n\n\t// Main lens barrel.\n\tq = dy(ax(p, 0.), 0.2);\n\tfloat l = length(q.yz);\n\tf = S(.0, .01, p.x - .62);\n\tf -= S(.06, 0., abs(p.x - .69)) * 0.2 * abs(sin(atan(q.y, q.z) * 60.));\n\td = max(l - .3 + 0.01 * f, .23 - l);\n\td = max(d, q.x - .75);\n\tU(h, d, DARKER_BRASS_ID, p);\n\tq.x -= .756;\n\td = min(d, tor(q.zyx, vec2(.21 + 0.096 * step(.25, l), 0)));\n\tU(h, d, BRASS_ID, p);\n\n\t// Lens inside.\n\td = max(l - .2, .15 - l);\n\td = max(d, q.x + 0.16);\n\tU(h, d, DARKER_BRASS_ID, p);\n\td = min(d, q.x + .2);\n\td = max(d, l - .25);\n\tU(h, d, LENS_COLOR_BACK_ID, p);\n\n\t// Lens screws.\n\td = screw(dx(opModPolar(q.zyx, 6., .3), -0.255)) + 0.012;\n\tU(h, d, BRASS_ID, p);\n\n\t// Lens.\n\tif (!hitGlass) {\n\t\tq = dx(q, 1.04);\n\t\td = max(length(q) - 1., l - .21);\n\t\tU(h, d, GLASS_ID, q);\n\t}\n\n\t// Main lens brass surround.\n\tq = dy(dx(p, -0.466), 0.2);\n\tv3 = q;\n\tl = length(q.yz);\n\td = l - .44;\n\tfloat a = atan(q.y, q.z);\n\tf = tor(q.zyx, vec2(.3, 0.03 - 0.0005 * abs(sin(a * 50.)))); // Weld ring.\n\tq = ay(az(q, .3), .3);\n\td = min(d, length(q.yz) - 0.1);\n\tf = min(f, max(insulate(q, d) - 0.008, abs(q.x) - 0.006));\n\ta = sin(a * 8.) * 0.015;\n\tl -= .39;\n\tf = min(f, insulate(v3, abs(l) - abs(a)) - 0.0011); // Intertwines.\n\tf = min(f, nutCap(q - .03));\n\tU(h, f, BRASS_ID, p);\n\td = max(d + 0.01, abs(q.x) - 0.0005);\n\tU(h, d, DARKER_BRASS_ID, p);\n\n\t// View lens barrel.\n\tq = dy(dx(p.zyx, .26), -.5);\n\tl = length(q.xy);\n\td = abs(l - .13) + .005;\n\td = max(d, abs(q.z) - .6);\n\tU(h, d, BRASS_ID, p);\n\td = max(l - .11, abs(q.z) - .46);\n\tU(h, d, LENS_COLOR_BACK_ID, q);\n\tif (!hitGlass) {\n\t\td = max(length(q) - .56, l - .115);\n\t\tU(h, d, GLASS_ID, q);\n\t}\n\n\th.d -= 0.01;\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .1;\n\tvec3 n = vec3(0);\n\tfor (int i = I0; i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdf(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 lp, vec3 ld, vec3 n) {\n\t// Quick abort if light is behind the normal.\n\tif (dot(ld, n) < -.1) return 0.0;\n\tfloat s = 1.,\n\t      t = .002, d;\n\tfor (float i = Z0; i < SHADOW_STEPS; i++) {\n\t\td = sdf(t * ld + p).d;\n\t\ts = min(s, 2.5 * d / t); // tweak sharpness.\n\t\tt += max(0.01, d);\n\t\tif (s < 0.01) break;\n\t}\n\n\treturn sat(s);\n}\n\n// Quick 2-level ambient occlusion.\nfloat ao(vec3 p, vec3 n, vec2 h) {\n\tvec2 ao;\n\tfor (int i = I0; i < 2; i++)\n\t\tao[i] = sdf(h[i] * n + p).d;\n\n\treturn sat(min2(ao / h));\n}\n\n// Sub-surface scattering. (Thanks Evvvvil)\nfloat sss(vec3 p, vec3 ld, float h) { return S01(sdf(h * ld + p).d / h); }\n\nvec3 lights(vec3 p, vec3 ro, vec3 rd, vec3 n, Hit h) {\n\tif (h.id == SKY_ID) return sky(rd);\n\tvec3 lp = vec3(6, 6, 7),\n\t     ld = normalize(lp - p),\n\t     c = vec3(0.06);\n\tfloat spe = 10.0,\n\t      shine = 3.;\n\n\tif (h.id == PLANK_ID) {\n        vec4 m = matWood(h.p * 3.2);\n\t\tc = m.rgb * 0.3;\n        n += (m.w - 0.5) * 0.15;\n\t\tspe = 10.;\n\t}\n\telse {\n        float g = musgraveFbm(p * vec3(700, 70, 70), 2., 1.0, .5);\n        if (h.id == CAM_WOOD_ID) {\n            c = vec3(0.15, .1, .1);\n            n += g * 0.015;\n            shine = 5.;\n            spe = 33.;\n        } else if (h.id == INLAY_ID) {\n            c = vec3(0.7, .7, .6);\n            n += g * 0.01;\n            shine = 1.;\n        }\n        else {\n            if (h.id == BRASS_ID) \n                c = vec3(0.7, 0.6, 0.2);\n            else if (h.id == DARKER_BRASS_ID)\n                c = vec3(0.35, 0.3, 0.1);\n            else shine = 1.;\n            c *= .7 + .3 * n31(p * vec3(300, 25, 25));\n        }\n    }\n\n\tvec3 l = sat(vec3(dot(ld, n),  // Key light.\n\tdot(-ld.xz, n.xz),  // Reverse light.\n\tn.y // Sky light.\n\t));\n    \n\tl *= fakeEnv(ld * 8.);\n\tl.xy = 0.1 + 0.9 * l.xy; // Diffuse.\n\tl.yz *= 0.1 + 0.9 * ao(p, n, vec2(.2, 1)); // Ambient occlusion.\n\tl *= vec3(1., .03, .3); // Light contributions (key, reverse, sky).\n\tl.x += pow(sat(dot(normalize(ld - rd), n)), spe) * shine; // Specular (Blinn-Phong)\n    l.x *= 0.3 + 0.7 * S(3.5, 1.8, length(p.xz));\n\tl.x *= 0.05 + 0.95 * shadow(p, lp, ld, n); // Shadow.\n    l.x *= 0.2 + 0.8 * S(2.8, 2., length(p.xz)); // Spotlight.\n\tl.x *= dot(lp, lp) / (5. + dot(lp - p, lp - p)); // Light falloff\n\tfloat fre = S(.7, 1., 1. + dot(rd, n)) * 0.02;\n\tvec3 sky = skyCol(1.0);\n\tvec3 col = mix((sum2(l.xy) * LIGHT_RGB + l.z * sky) * c, sky, fre);\n\n\t// Distance Fog.\n\tfloat fg = 1.0 - exp(dot3(p - ro) * -0.001);\n\n\treturn mix(vec3(.06, .04, .04), col, 1.0 - sat(fg));\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// March the scene.\n\tvec3 p = ro;\n\tfloat d = START_DIST, i;\n\tHit h;\n\tvec3 n,\n\t     col = vec3(0),\n\t     glassP = col, glassN;\n\thitGlass = false;\n\tfor (i = Z0; i < MAX_STEPS; i++) {\n\t\th = sdf(p);\n\t\tif (abs(h.d) < MIN_DIST * d) {\n\t\t\tif (!hitGlass && h.id == GLASS_ID) {\n\t\t\t\thitGlass = true;\n\t\t\t\tglassP = p;\n\t\t\t\tglassN = normalize(h.p);\n\t\t\t\tvec3 v = normalize(refract(rd, glassN, .65));\n\t\t\t\tp += v * min(sdf(p + v * .02).d, .02);\n\t\t\t\tcol += 0.003;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\tcol += lights(p, ro, rd, n = N(p, d), h);\n\tif (h.id > BELOW_ARE_REFLECTIVE || hitGlass) {\n\t\tif (hitGlass) {\n\t\t\tp = glassP;\n\t\t\tn = glassN;\n\t\t\tcol += vec3(10, 7, 10) * 100. * pow(sat(dot(normalize(vec3(8.86, 4, 8) - rd), n)), 50.);\n\t\t\tcol += vec3(1, 1, 2.5) * .02 * S(0., .01, pow(sat(dot(normalize(vec3(8.86, 4.38, 10) - rd), n)), 35.) * 200.);\n\t\t\tcol += vec3(10, 7, 10) * 50. * pow(sat(dot(normalize(vec3(8.86, -4, -7) - rd), n)), 50.);\n\t\t}\n\n\t\t// We hit a reflective surface, so march reflection.\n\t\trd = reflect(rd, n);\n\t\tp += n * 0.01;\n\t\tro = p;\n\t\td = 0.01;\n\t\tfor (i = Z0; i < MAX_RSTEPS; i++) {\n\t\t\tif (d > MAX_RDIST) {\n\t\t\t\th.id = SKY_ID;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\th = sdf(p);\n\t\t\tif (abs(h.d) < MIN_DIST * d) break;\n\t\t\td += h.d;\n\t\t\tp += h.d * rd;\n\t\t}\n\n\t\t// Add a hint of the reflected color.\n\t\tcol = col + (1. - col) * 0.03 * lights(p, ro, rd, N(p, d), h);\n\t}\n\n\treturn pow(max(vec3(0), col), vec3(0.45));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\tvec3 ro = vec3(1.85 + sin(iTime * 0.2) * 0.2, 1.3, -1.2);\n\tvec3 col = march(ro, rayDir(ro, uv));\n\n    // Vignette.\n\tcol *= 1.0 - 0.5 * dot(uv, uv);\n\t\n\t// Grain\n\tcol += (h21(fc) - 0.5) / 50.;\n\tfragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}