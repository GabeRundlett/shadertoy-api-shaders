{
    "Shader": {
        "info": {
            "date": "1727709198",
            "description": "originals https://www.shadertoy.com/view/4tyfWy",
            "flags": 0,
            "hasliked": 0,
            "id": "X3BcDK",
            "likes": 3,
            "name": "star in pyrmid",
            "published": 3,
            "tags": [
                "star",
                "pyramid"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 44
        },
        "renderpass": [
            {
                "code": "#define PI\t3.14159265359\n#define PI2\tPI * 2.0\n\nfloat time;\n    \nmat2 rotate(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\t\n}\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n    float happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvec2 fold(in vec2 p, in float s)\n{\np.xy*=mat2(cos(iTime),sin(iTime),-sin(iTime), cos(iTime));\n    float a = PI / s - atan(p.x, p.y);\n    float n = PI2 / s;\n    a = floor(a / n) * n;\n    p *= rotate(a);\n    return p;    \n}\n\nfloat prism(in vec3 p)\n{\n\tp.xy = fold(p.xy, 5.0);\n    p.y -= 0.6 ;\n    return max(abs(p.z) - 0.5, dot(p, normalize(vec3(0.0, 1.0, 0.0))));\n}\n    \nfloat twinPyramid(in vec3 p)\n{\n\tp.xy = fold(p.xy, 5.0);\n    p.y -= 0.7 ;\n    p.z = abs(p.z);\n\treturn dot(p, normalize(vec3(0.0, 1.0, 1.0)));\n}\n\nfloat star(in vec3 p)\n{     \n\tp.xy = fold(p.xy, 5.0);\n    p.xz*=mat2(cos(iTime),sin(iTime),-sin(iTime), cos(iTime));\n    p.x = abs(p.x);\n    p.y += p.x * 2.0 - 0.8;\n    p.z = abs(p.z) + p.y * 0.4;\n    return p.y > 0.0 ? length(p.yz) : abs(p.z) - 0.01;\n}\n    \nvec3 transform(in vec3 p)\n{\np.xz*=mat2(cos(iTime),sin(iTime),-sin(iTime), cos(iTime));\n    p.yz *= rotate(iTime * 0.5);\n    p.zx *= rotate(iTime * 0.7);\n    return p;\n}\n\nfloat map(in vec3 p)\n{\n   \n    vec3 q = p;\n    q.xz*=mat2(cos(iTime),sin(iTime),-sin(iTime), cos(iTime));\n    q = transform(q);\n    float de1 = twinPyramid(q);\n   \n    p = transform(p);\n  \n    return min(de1,de1);\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 10.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 64; i++)\n    {\n        if(h < precis || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\n\n#define N 12\n#define time iTime\n#define resolution iResolution.xy\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   float time = mod(iTime, 10.0) - 5.0;\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec2 q = p;\n    p = fold(p, 5.0);\n    if (time < 0.0) p.x = abs(p.x);\n    p *= 2.0;\n    p.y -= 1.0;\n    p.xy*=mat2(cos(iTime),sin(iTime),-sin(iTime), cos(iTime));\n    vec3 col;\n    float size = 0.2;\n\tfloat dist = 0.0;\n\tfloat ang = 0.0;\n\tvec2 pos = vec2(0.0,0.0);\n\tvec3 color = vec3(0.1);;\n\t  vec2 uv = fragCoord/iResolution.xy-.5;\n      uv.xy*=mat2(cos(iTime),sin(iTime),-sin(iTime), cos(iTime));\n\tfor(int i=0; i<N; i++){\n\t\tfloat r = 0.4;\n\t\tang += PI / (float(N)*0.5);\n\t\tpos = vec2(cos(ang),sin(ang))*r*cos(time+ang/.11);\n\t\tdist += size / distance(pos,uv);\n\t\tvec3 c = vec3(0.05);\n\t\tcolor = c*dist;\n\t}\n    col = mix(vec3(0.1), hsv(0.1, 0.8, 0.4), step(0.0, p.x * p.y)); \n    col = mix(col, hsv(0.2, 0.7, 1.0), smoothstep(0.03, 0.0, abs(p.y)));\n    col = mix(col, hsv(0.0, 0.7, 1.0), smoothstep(0.03, 0.0, abs(p.x)));\n    col = mix(col, hsv(0.6, 0.3, 0.15), smoothstep(0.0, 1.5, length(p)));\n    p = q;\n    vec3 rd = normalize(vec3(p, -1.8));\n\tvec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n         pos.xy*=mat2(cos(iTime),sin(iTime),-sin(iTime), cos(iTime));\n        vec3 n = calcNormal(pos);\n\t\tn = reflect(rd, n);\n        float dif = clamp((dot(n, li) + 1.0) * 0.8, 0.4, 1.0);\n        col = hsv(0.6, 0.7, 1.0) * dif*color;\n\t}\n   \tfragColor = vec4(col*color, 1.0);\n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor*= vec4(happy_star(uv, anim) * vec3(0.35,0.2,1.15)*2., 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}