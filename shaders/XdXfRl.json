{
    "Shader": {
        "info": {
            "date": "1497388944",
            "description": "unifies an alpha composition\nhttps://www.shadertoy.com/view/4sXfRl\nof 2d gradient differentiation\nhttps://www.shadertoy.com/view/XdffzB\nand 3d automatic differentiation\nhttps://www.shadertoy.com/view/lsffRX",
            "flags": 0,
            "hasliked": 0,
            "id": "XdXfRl",
            "likes": 1,
            "name": "025 Derivative Arithmetic 5",
            "published": 3,
            "tags": [
                "derivative",
                "alpha",
                "arithmetic",
                "mercury",
                "composition",
                "hgsdf",
                "differential",
                "automaticdifferentiation",
                "calculus",
                "lisp"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 818
        },
        "renderpass": [
            {
                "code": "//\"024 Derivative Arithmetic 4 & 5\" are a variant of\n// https://www.shadertoy.com/view/XdfBzj\n//\"023 Derivative Arithmetic 3\" with one core change:\n//\n//\"023 Derivative Arithmetic 3\" uses vectors and matrices (and a struct for a mat43)\n//\"024 Derivative Arithmetic 4 & 5\" use different structure, to differentiate 2 arithmetics.\n//Explicit structure adds  symmetry, making things simpler.\n//Explicit structure confuses, mostly due to its atomic defines, and counting from 0.\n//Explicit structure creates \"permutation hell\", as usual.\n//Explicit structure does not slow down performance.\n//\n//This defines implicit 3d Surfaces, or 2d curves, \n//... with ChainRule automatic differentiation Arithmetic, \n//This inevitably makes you write in prefixNotation, like Lisp source code.\n//surely this would look much better in Lisp than in Webgl\n//Still waiting for the Lisp gpu API, and openCL or CUDA are not my thing!\n//... there is \"harlan\" for inspiration, but it is a 2007 non-api thing...\n//\n//\"024 Derivative Arithmetic 5\" has 4 modes (patchwork):\n//to be used in 3d, 2d and 1d.\n//[#define domains 4] overlays its 3d and 2d calculations to a composite.\n//\n//\"024 Derivative Arithmetic 4\" possibly fixed the modulo function's errors?\n//\n//general automatic differentiation is:\n// based on    : https://www.shadertoy.com/view/4dVGzw\n// inspired by : https://www.shadertoy.com/view/Mdl3Ws \n//explained at : http://blog.demofox.org/2014/12/30/dual-numbers-automatic-differentiation/\n//wiki         : https://en.m.wikipedia.org/wiki/Automatic_differentiation\n//summary:     : https://www.reddit.com/r/math/comments/68st6p/the_wikipedia_article_on_automatic/\n//\n//dad: https://www.shadertoy.com/view/4dVGzw\n//but with swiveled parameters:\n//dad: has .xyz as Dfdx() Dfdx() Dfdz(), via automatic differentiation\n//THIS has .d   as Dfdx() Dfdx() Dfdz(), via automatic differentiation +structure\n//\n//brother: https://www.shadertoy.com/view/XlV3Dy\n//brother: Has the goursat_surface, C0-discontinuous isosurface example\n//THIS has derivative arithmetic fields of hg_sdf:\n//  mercury.sexy/hg_sdf/\n//But where a hg_sdf_function returns the distance to point [p].\n//THIS returns distance to point [p] as .x \n//...and N_first_derivatives along N_domains as .d\n//...for point [p]\n//\n//sister: https://www.shadertoy.com/view/MsXBRB\n//focuses on simpler implicit surfaces, is a nicer more constrained introduction.\n\n//Here ends the bad habbit of; starting to count at 1! Start counting at 0!:\n\n//domains 0 <-> 1d //black screen\n//domains 1 <-> 2d\n//domains 2 <-> 3d\n//domains 3 <-> overlay(3d,2d)\n#define domains 3\n\n//#if (domains>1)\n //#define SuperPrim\n //optionally show superprim \n //== https://www.shadertoy.com/results?query=superprim\n #define IterRm 64\n //max raymarch iterations|steps\n \n #define IterSh 16\n //softshadow iterations\n \n #define ReciprocalAbsLipschitz .99\n //if(lipschitzConstant>1., distance is overestimated.\n //multiplying by ReciprocalAbsLipschitz is a \n //... lazy fix for that is scaling stepDistance*=ReciprocalAbsLipschitz\n //higher precision with a smaller ReciprocalAbsLipschitz AND epsilon=0.\n //meaning, a surface will NEVER really be reached.\n //maybe todo: eps=log(eps*b)*a\n\n #define camLens 2.\n #define camRoll 0.\n //camera lens and roll for camera projection matrix (is not a quaternion camera)\n\n//#else\n \n #define camLens 2.\n //view scaling\n\n #define thick .1\n //line thickness (it does nice tangential lines for the first derivative visualisazion, \n //... by using the analytic second derivative)\n//#endif\n\n//--------------------------\n//--------------------------\n\n#define pi acos(-1.)\n\n#define m3 mat4\n#define m2 mat3\n#define m1 mat2\n//the below is basically an [m0]==[m]\n#define v3 vec4\n#define v2 vec3\n#define v1 vec2\n#define v0 float\n//dual number arithmetic structure:\nstruct d {v0 x;v0 d;};//+gradient on 1 domain , is a vec2\nstruct d1{v0 x;v1 d;};//+gradient on 2 domains, is a vec3\nstruct d2{v0 x;v2 d;};//+gradient on 3 domains, is a vec4\n//substiduting \"d0\" to \"d\" is worth it here.\n//above namespaces must be short, try not to confuse a [type] with a [label|pointer].\n//short defines tend to kill compatibility. make no single character defines!\n   \n/*todo, ipmplemnt tripple number arithmetic structure, \n//...for second derivaive automatic differentiation:\n//for all the fun that comes with precise double integrals?\nstruct d22{v0 x;v2 d;v2 d1};//d==1stDerivatives==gradient; d1=2ndDerivatives==Curvature\nstruct d11{v0 x;v1 d;v1 d1};\nstruct d00{v0 x;v  d;v  d1};//substituting d00 to something shorter? bad idea!\n*/\n\n//Explicit structure [.x] utilizes simple (non complex number) arithmetic as you know it.\n//Explicit structure [.d] calculates the first derivative as a byproduct, for each domain.\n//...using the chain rule  https://en.wikipedia.org/wiki/Chain_rule\n//ALL functions get a \"*d\" added to it, wrapping them in this new namespace.\n//By differetiating by type, automatic differentiation includes non-automadic arithmetic.\n//v1 addd(v1 a,v1 b){return a+b;}\n//\n//This inlcusion should enable you do #define a distance field\n//...and that will define it for derivative arithmethic AND non derivative arithmetic.\n//...and you neet to say goodbye to the infix_notation with \"+-*/%^\" operands.\n//and replace it with a proper prefix_notation, like writing in Lisp.:\n//  https://en.wikipedia.org/wiki/Polish_notation\n//a+b*pow(c,d) \n//becomes\n//addd(a,muld(b,powd(c,d)))\n//\n//The \"art\" here is to define an implicit isosurface\n//  https://en.wikipedia.org/wiki/Implicit_surface\n//  https://en.wikipedia.org/wiki/Isosurface\n//...as a(n extended) distance_field equivalent with Arithmetic that\n//...automatically calculate its first derivatives for any point (without multisampling)\n//An overview of that is best explained in\n//  https://www.youtube.com/watch?v=qb40J4N1fa4\n//That way you get all the Contour lines, gradients, normals...\n//  https://en.wikipedia.org/wiki/Contour_line\n//  https://en.wikipedia.org/wiki/Gradient\n//  https://en.wikipedia.org/wiki/Surface_normal\n//...along all the domains (dimensions) of a surface\n//  https://en.wikipedia.org/wiki/Surface_%28topology%29\n//...very cheaply, because the contour is orthoogonal to the gradient.\n//\n// The above \"art\" requires a[Derivative Arithmetic] set \n// for [Automatic Differentiation].\n// Derivative arithmetic [DA] is great for\n//-more precise surface normals and curvature. (better normals on corners)\n//-more precise anti-alasing\n//-faster better gradient|contour calculation. (2d ovals. metaballs)\n//- https://en.wikipedia.org/wiki/Contour_integration\n//-Fluid dynamics, pressure waves (With a buffer over time)\n//-EM-fields: https://en.wikipedia.org/wiki/Surface_integral\n//-all that is in the todo list, at the bottom of this file\n//- https://en.wikipedia.org/wiki/Smoothness\n//- shapes with functions that that lack C0-continuity but have C1-continuity.\n//\n//My [DA] uses a simple namespace:\n//All common arithmetic namespaces get a \"*d\" suffix added.\n//That \"*d\" means \"also calculate first derivatives \n//... for all the domains\".\n//That also increases type float to vec4, and vec3 to \"mat4\" for inOut.\n\n//filling lists with zeroes (seems to make more sese than filling them with (a);\nv1 v0tv1(v0 a){return v1(a,0);}\nv2 v0tv2(v0 a){return v2(a,0,0);}\nv3 v0tv3(v0 a){return v3(a,0,0,0);}\nv2 v1tv2(v1 a){return v2(a,0);}//what to put in .z here? .x or .y or.0?\nd  v0td0(v0 a){return d (a,0.);}\nd1 v0td1(v0 a){return d1(a,v1(0));}\nd2 v0td2(v0 a){return d2(a,v2(0));}\n//filling gradient with zeroes to include more domains.\nd1 d0td1(d  a){return d1(a.x,v0tv1(a.d));}\nd2 d0td2(d  a){return d2(a.x,v0tv2(a.d));}\nd2 d1td2(d1 a){return d2(a.x,v1tv2(a.d));}\n//there is an intuitive problem for the above, for 2 different easily mistaken cases:\n//- A 2d gradient has NULL differential along +1 additional domain.\n//- A vector gets all components scaled when multiplying a vector by a float.\n\n//The 3 (or 2) dimensions|domains \n//...are resolved with [struct DAmN{}] and [da_domain(vN  p)]:\n//where N=number of domains, range [0..3]\nstruct DAm2{d2 x;d2 y;d2 z;};//for 3 domains (density/distance field)\nDAm2 da_domain(v2 p){return DAm2(d2(p.x,v2(1,0,0)),\n                                 d2(p.y,v2(0,1,0)),\n                                 d2(p.z,v2(0,0,1)));}\nstruct DAm1{d1 x;d1 y;};//for 2 domains (heightmap, isoline, contour)\n//https://en.wikipedia.org/wiki/Contour_line\nDAm1 da_domain(v1 p){return DAm1(d1(p.x,v1(1,0)),\n                                 d1(p.y,v1(0,1)));}\nstruct DAm0{d x;};//for 1 domain (linear equation)\nDAm0 da_domain(v0 p){return DAm0(d (p  ,   1.));}\n//I will likely replace these with mat4, mat3 mat2.\n//Not sure yet, but it would make things simpler.\n\n#define sat(a) clamp(a,0.,1.)\n//This lets you derive over up to 3 dimensions at once OR seperately, \n//...using very self-similar dual-function variants:\n//#define pow2d(a) d2(muld(a.x,a.x),muld(a,2.))\n#define pow2d(a) muld(a,a)\n//above pow2() is very special and simple derivative arithmetic \n//... that should tell you what is going on with all the other \n//... dual number arithmetic functions below.\n//operations with only 1 input parameter are the simplest.\n\n//special case of component wise multiplication, special because a.x==1:\nd  cmd(d a,v0 b){return d (a.x,a.d*b);}\nd1 cmd(d a,v1 b){return d1(a.x,a.d*b);}\nd2 cmd(d a,v2 b){return d2(a.x,a.d*b);}\n//#define rmd {return cmd\nd  absd(v0 a){return   d(abs (a  ),sign(a  ));}\nd  absd(d  a){return cmd(absd(a.x),a.d);}//d (abs(a.x),sign(a.x)*a.d);}\nd1 absd(d1 a){return cmd(absd(a.x),a.d);}//d1(abs(a.x),sign(a.x)*a.d);}\nd2 absd(d2 a){return cmd(absd(a.x),a.d);}//d2(abs(a.x),sign(a.x)*a.d);}\n\nd  sind(v0 a){return d (sin(a  ),cos(a  ));}\nd  sind(d  a){return d (sin(a.x),cos(a.x)*a.d);}\nd1 sind(d1 a){return d1(sin(a.x),cos(a.x)*a.d);}\nd2 sind(d2 a){return d2(sin(a.x),cos(a.x)*a.d);}\nd  cosd(v0 a){return d (cos(a  ),-sin(a  ));}\nd  cosd(d  a){return d (cos(a.x),-sin(a.x)*a.d);}\nd1 cosd(d1 a){return d1(cos(a.x),-sin(a.x)*a.d);}\nd2 cosd(d2 a){return d2(cos(a.x),-sin(a.x)*a.d);}\nd  logd(d  a){return d (log(a.x),a.d/a.x);}\nd1 logd(d1 a){return d1(log(a.x),a.d/a.x);}\nd2 logd(d2 a){return d2(log(a.x),a.d/a.x);}\nd  expd(d  a){v0 x=exp(a.x);return d (x,x*a.d);}\nd1 expd(d1 a){v0 x=exp(a.x);return d1(x,x*a.d);}\nd2 expd(d2 a){v0 x=exp(a.x);return d2(x,x*a.d);}\n//sqrt() and divisions require a worksave reciprocal operator:\nv0 rec(float a){return (a==0.)?a:1./a;}//return [1/a] , work safe\n//single parameter operations are MUCH simpler here:\nd  sqrtd(d  a){v0 q=sqrt(a.x);return d (q,.5*rec(q)*a.d);}\nd1 sqrtd(d1 a){v0 q=sqrt(a.x);return d1(q,.5*rec(q)*a.d);}\nd2 sqrtd(d2 a){v0 q=sqrt(a.x);return d2(q,.5*rec(q)*a.d);}\n//        pow (x,y) exp (     log (x)*y )//wait till we define muld()\n//#define powd(x,y) expd(muld(logd(x),x))//wait till we define muld()\n\n//i am not too sure about my implementation on fractd();\n//the hell, just use modd() instead, modd() has VERY nice first derivatives!\n//reminder that the fract function's first derivative has a \"kick\" on (mod(a,1)==0.0)\nv0 djum(v0 a){return mix(a,-1.,step(fract(a),0.)*step(0.,fract(a)));}\nv1 djum(v1 a){return v1(djum(a.x),djum(a.y));}\nv2 djum(v2 a){return v2(djum(a.x),djum(a.y),djum(a.z));}\n//i should definitely define this by fract, and not by floor.\n//because fm-modulation taught me that i need fract() a lot more than floor()\nd2 fractd(d2 a){return d2(floor(a.x),djum(a.d));}\nd1 fractd(d1 a){return d1(floor(a.x),djum(a.d));}\nd  fractd(d  a){return d (floor(a.x),djum(a.d));}\n//very slightly lower precision? rarely relevant. fract() has great precision on float!\n#define floord(a) subd(a,fractd(a))\n\n//derivatives of functions with 2 input parameters are trickier:\n//  https://en.wikipedia.org/wiki/Multivariable_calculus\n//There are exponential many permutations of modd() mixd() mind()\n\n//modd ideally should be replaced by fractd(), but that adds 1dvd() and 1muld()\n//... but chain rule division (reciprocal product rule) on a custom type is so bad.\n//... that for derivative arithmetic, modd(a,b) outperforms muld(fractd(divd(a,b)),b)\n//v4 modd(v4 a,v4 b){return v4(mod(a.x,b.x),mod(a.yzw,1.));}\n//v4 modd(v4 a,v1 b){return v4(mod(a.x,b  ),mod(a.yzw,1.));}\n//v4 modd(v1 a,v4 b){return v4(mod(a  ,b.x),0,0,0        );}\n//#define modo(a,b) fract(a/b)*b /*what mod(a,b) actually does*/\n#define may fract(a.d));}\n#define maz mod(a.x,b),may\n#define mab mod(a.x,b.x)\nd2 modd(d2 a,v0 b){return d2(maz\nd1 modd(d1 a,v0 b){return d1(maz\nd  modd(d  a,v0 b){return d (maz\nd  modd(d  a,d  b){return d (mab,may\nd2 modd(d2 a,d  b){return d2(mab,may\nd2 modd(d2 a,d2 b){return d2(mab,may\nd2 modd(d2 a,d1 b){return d2(mab,may\nd2 modd(d  a,d2 b){return d2(mab,v2(0));}\nd2 modd(d1 a,d2 b){return d2(mab,v2(0));}\nd2 modd(v0 a,d2 b){return d2(mod(a,b.x),v2(0));}\nd1 modd(v0 a,d1 b){return d1(mod(a,b.x),v1(0));}\nd  modd(v0 a,d  b){return d (mod(a,b.x),   0.);}\n//mmixd is subroutine for mind(), which is used as branch. mix(n1,n2,step(m,0.))\nv0 mixd(v0 a,v0 b,v0 c){return mix(a,b,c);}\nv1 mixd(v1 a,v1 b,v0 c){return mix(a,b,c);}\nv2 mixd(v2 a,v2 b,v0 c){return mix(a,b,c);}\nv3 mixd(v3 a,v3 b,v0 c){return mix(a,b,c);}\n//v1 mixd(v0 a,v1 b,v0 c){return mix(v0tv1(a),b,c);} oh my permutations...\nd  mixd(d  a,d  b,v0 c){return d (mix(a.x,b.x,c),mix(a.d,b.d,c));}\nd1 mixd(d1 a,d1 b,v0 c){return d1(mix(a.x,b.x,c),mix(a.d,b.d,c));}\nd2 mixd(d2 a,d2 b,v0 c){return d2(mix(a.x,b.x,c),mix(a.d,b.d,c));}\nd1 mixd(d  a,d1 b,v0 c){return mixd(d0td1(a),b,c);}\nd2 mixd(d  a,d2 b,v0 c){return mixd(d0td2(a),b,c);}\nd2 mixd(d1 a,d2 b,v0 c){return mixd(d1td2(a),b,c);}\nd1 mixd(d1 a,d  b,v0 c){return mixd(a,d0td1(b),c);}\nd2 mixd(d2 a,d1 b,v0 c){return mixd(a,d1td2(b),c);}\nd2 mixd(d2 a,d  b,v0 c){return mixd(a,d0td2(b),c);}\n//the return of Fortran's \"XIF(m,n1,n2)===(m==0)?n1:n2===mix(n1,n2,step(m,0.)*step(0.,m))\n//ecept it compares if (a.x>b.x)\n#define min1 {return mixd(b,a,step(a.x,b.x));}\n#define min3 {return mind(b,a);}\n//I define mind() and -maxd(-,-) instead of maxd() and -mind(-,-)\n//because min() is far more common than max(), for z-buffering.\nd2 mind(d2 a,d2 b)min1\nd2 mind(d1 a,d2 b)min1\nd2 mind(d  a,d2 b)min1\nd2 mind(d2 a,d1 b)min1\nd2 mind(d2 a,d  b)min1\nd1 mind(d1 a,d1 b)min1\nd1 mind(d  a,d1 b)min1\nd  mind(d  a,d  b)min1\nd2 mind(v0 a,d2 b){return mixd(v0td2(a),b,step(b.x,a));}\nd2 mind(d2 a,v0 b){return mixd(v0td2(b),a,step(a.x,b));}\nd1 mind(v0 a,d1 b){return mind(v0td1(a),b);}\nd  mind(v0 a,d  b){return mind(v0td0(a),b);}\nd  mind(v0 a,v0 b){return v0td0(min(a,b));}\nd1 mind(d1 a,d  b)min3\nd1 mind(d1 a,v0 b)min3\nd  mind(d  a,v0 b)min3\n//negation identity: max(a,b)=-min(-a,-b), requires struct negation\nd2 negd(d2 a){return d2(-a.x,-a.d);}\nd1 negd(d1 a){return d1(-a.x,-a.d);}\nd  negd(d  a){return d (-a.x,-a.d);}\nv0 negd(v0 a){return -a;}\n#define maxd(a,b) negd(mind(negd(a),negd(b)))\n//3-domain matrix tripples:\nDAm2 maxdm(DAm2 a,v2 p){\n return DAm2(maxd(a.x,p.x),maxd(a.y,p.y),maxd(a.z,p.z));}\nDAm2 mindm(DAm2 a,v2 p){\n return DAm2(mind(a.x,p.x),mind(a.y,p.y),mind(a.z,p.z));}\nDAm2 maxdm(DAm2 a,v0 p){return maxdm(a,v2(p));}\nDAm2 mindm(DAm2 a,v0 p){return mindm(a,v2(p));}//needed for fast clamping\nd2 maxdm(d2 a,d2 b,d2 c){return maxd(maxd(a,b),c);}\nd2 maxdm(DAm2 a){return maxdm(a.x,a.y,a.z);}\n\n/*\nv4 subd(v4 a,v4 b){return a-b;}\nv4 subd(v4 a,v1 b){return v4(a.x-b  , a.yzw);}\nv4 subd(v1 a,v4 b){return v4(a  -b.x,-b.yzw);}\nv4 addd(v4 a,v4 b){return a+b;}\nv4 addd(v4 a,v1 b){return subd(a,-b);}//addition as invrse substraction\nv4 addd(v1 a,v4 b){return subd(a,-b);}\n*/\n//substraction is simple, because \"differentiation equals integration\"\n//  https://en.wikipedia.org/wiki/Cauchy_integral_formula\n//...making the implementation of the chain rule much simpler for:\n//  https://en.wikipedia.org/wiki/Translation_(geometry)\nd2 subd(d2 a,d2 b){return d2(a.x-b.x,a.d-b.d);}//3d translation\nd1 subd(d1 a,d1 b){return d1(a.x-b.x,a.d-b.d);}//2d translation\nd  subd(d  a,d  b){return d (a.x-b.x,a.d-b.d);}//1d translation\nd2 subd(d2 a,v0 b){return d2(a.x-b  ,a.d);}\nd2 subd(d2 a,d  b){return d2(a.x-b.x,a.d);}\nd2 subd(d2 a,d1 b){return d2(a.x-b.x,a.d);}\nd1 subd(d1 a,v0 b){return d1(a.x-b  ,a.d);}\nd1 subd(d1 a,d  b){return d1(a.x-b.x,a.d);}\nd  subd(d  a,v0 b){return d (a.x-b  ,a.d);}                           \nd2 subd(v0 a,d2 b){return d2(a  -b.x,-b.d);}\nd2 subd(d  a,d2 b){return d2(a.x-b.x,-b.d);}\nd2 subd(v3 a,d2 b){return d2(a.x-b.x,-b.d);}\nd1 subd(v0 a,d1 b){return d1(a  -b.x,-b.d);}\nd1 subd(d  a,d1 b){return d1(a.x-b.x,-b.d);}\nd  subd(v0 a,d  b){return d (a  -b.x,-b.d);}\n//glide-translations along multiple domains:\nDAm2 subd(DAm2 p,v2 s){return DAm2(subd(p.x,s.x),\n                                   subd(p.y,s.y),\n                                   subd(p.z,s.z));}\nDAm1 subd(DAm1 p,v1 s){return DAm1(subd(p.x,s.x),\n                                   subd(p.y,s.y));}\nDAm0 subd(DAm0 p,v0 s){return DAm0(subd(p.x,s));}\n//subd(absd(p),s) equals a translation away from the origin by [s]\n//... AND mirroring at origin, via abs() \n//... so it it clamps a an implicit surface to a limited \"thickness\"\n//(in 3 domains),also translating its first derivatives.\nd2 subdabsd(d2 p,float s){return subd(absd(p),s);}\nd1 subdabsd(d1 p,float s){return subd(absd(p),s);}\nd  subdabsd(d  p,float s){return subd(absd(p),s);}\nDAm2 subdabsd(DAm2 p,v2 s){return DAm2(subdabsd(p.x,s.x),\n                                       subdabsd(p.y,s.y),\n                                       subdabsd(p.z,s.z));}\nDAm1 subdabsd(DAm1 p,v1 s){return DAm1(subdabsd(p.x,s.x),\n                                       subdabsd(p.y,s.y));}\nDAm0 subdabsd(DAm0 p,v0 s){return DAm0(subdabsd(p.x,s));}\n//addition is negated substraction.\n#define addd(a,b) subd(a,negd(b))\n#define adddabsd(a,b) subdabsd(a,negd(b))\n\n//automatic_differentiation_multiplication applies the product rule within the chain rule\n//  https://en.wikipedia.org/wiki/Product_rule\n/*\nv4 muld(v4 a,v4 b){return v4(a.x*b.x,a.yzw*b.w+a.x*b.yzw);}\nv4 muld(v4 a,v1 b){return a*b;}\nv4 muld(v1 a,v4 b){return a*b;}\nv4 divd(v4 a,v4 b){return v4(a.x/b.x,(a.yzw*b.x-a.x*b.yzw)/(b.x*b.x));}\nv4 divd(v4 a,v1 b){return a/b;}\nv4 divd(v1 a,v4 b){return v4(a/b.x,(-a*b.yzw)/(b.x*b.x));} \n*/\n#define atb a.x*b,a.d*b);}\n#define mdb b){return muld(b,a);}\nd2 muld(d2 a,v0 b){return d2(atb\nd1 muld(d1 a,v0 b){return d1(atb\nd  muld(d  a,v0 b){return d (atb\nd2 muld(v0 a,d2 mdb //mdb is the commutative inverse of the 3 above ones\nd1 muld(v0 a,d1 mdb\nd  muld(v0 a,d  mdb//scalar multiplication is tautological product_rule.\nd2 muld(d2 a,d2 b){return d2(a.x*b.x,a.d*b.x+a.x*b.d);}\nd1 muld(d1 a,d1 b){return d1(a.x*b.x,a.d*b.x+a.x*b.d);}\nd  muld(d  a,d  b){return d (a.x*b.x,a.d*b.x+a.x*b.d);}\nd1 muld(d  a,d1 b){return d1(a.x*b.x,a.d*b.x+a.x*b.d);}\nd1 muld(d1 a,d  b){return d1(a.x*b.x,a.d*b.x+a.x*b.d);}\n//d2 muld(d2 a,d1 b){return d2(a.x*b.x,a.d*b.x+a.x*b.d);}//nonsense?\nd2 muld(d2 a,d  b){return d2(a.x*b.x,a.d*b.x+a.x*b.d);}\n//d2 muld(d1 a,d2 b){return d2(a.x*b.x,a.d*b.x+a.x*b.d);}//nonsense?\nd2 muld(d  a,d2 b){return d2(a.x*b.x,a.d*b.x+a.x*b.d);}\nDAm2 muld(DAm2 p,v2 s){return DAm2(muld(p.x,s.x),\n                                         muld(p.y,s.y),\n                                         muld(p.z,s.z));}\nDAm1 muld(DAm1 p,v1  s){return DAm1(muld(p.x,s.x),\n                                         muld(p.y,s.y));}\nDAm0 muld(DAm0 p,v0 s){return DAm0(muld(p.x,s));}\n//reciprocal derivatives are most confusing.\n#define atc a.x/b,a.d/b);}\nd2 divd(d2 a,v0 b){return d2(atc\nd1 divd(d1 a,v0 b){return d1(atc\nd  divd(d  a,v0 b){return d (atc//inverse scalar multiplication is a tautolotgy.\n#define bxx /(b.x*b.x));}\nd2 divd(v0 a,d2 b){return d2(a  /b.x,(-a  *b.d)bxx\nd2 divd(d  a,d2 b){return d2(a.x/b.x,(-a.x*b.d)bxx\nd2 divd(d1 a,d2 b){return d2(a.x/b.x,(-a.x*b.d)bxx\nd2 divd(d2 a,d2 b){return d2(a.x/b.x,(a.d*b.x-a.x*b.d)bxx\n//d2 divd(d2 a,d1 b){return d2(a.x/b.x,(a.d*b.x-a.x*b.d)bxx//nonsense?\n//d2 divd(d2 a,d  b){return d2(a.x/b.x,(a.d*b.x-a.x*b.d)bxx//nonsense?\n//All exponential functions utilize their Base_E_identity:\n//...which is still not efficient, but comes doen to O(exp(n*log(n)))\n//      pow (x,y)==exp(     log (x)*y )//baseE exponential and logarythmic functions.\n#define powd(x,y) expd(muld(logd(x),x))\n\n//It gets trickier with functions that take 3 parameters:, applying the\n//  https://en.wikipedia.org/wiki/Triple_product_rule\n//Euclidean distance (pythagorean theorem) with first derivatives.\n#define v0q v0 q=length(v1(x.x,y.x))\n#define ll2 q,(x.d*x.x+y.d*y.x)*rec(q));}\nd  lengthd(d  x,d  y){v0q;return d (ll2\nd1 lengthd(d1 x,d1 y){v0q;return d1(ll2\nd2 lengthd(d2 x,d2 y){v0q;return d2(ll2\nd2 lengthd2(DAm2 u){return lengthd(u.x,u.y);}//2*3domain\n//above is planar length 2 input parameters. below is 3d length.\nd2 lengthd(d2 x,d2 y,d2 z){float q=length(v2(x.x,y.x,z.x));\n return d2(q,(x.d*x.x+y.d*y.x+z.d*z.x)*rec(q));}\nd2 lengthd(DAm2 u){return lengthd(u.x,u.y,u.z);}//3*3domain\n//the utility of a length() function is clear.\n\n//these branchless comparators compare [c] with [0.0] to return [a]==true or [b]==false;\n#define step2 step(c,0.)+step(0.,c)-1.)\n//above is based on   https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n//(a> 0)?b:c\n#define greater(a,b,c)   mix(a,b,step(c,0.))\n//(a< 0)?b:c\n#define less(a,b,c)      mix(a,b,step(0.,c))\n//(a==0)?b:c\n#define equals(a,b,c)    mix(b,a,step2\n//(a!=0)?b:c\n#define unequal(a,b,c)   mix(a,b,step2\n//(a>=0)?b:c  \"unless   \"=not less   ==greater OR equal\n#define unless(a,b,c)    mix(b,a,step(0.,c))\n//(a<=0)?b:c  \"ungreater\"=not greater==less    OR equal\n#define ungreater(a,b,c) mix(b,a,step(c,0.))\n// https://www.shadertoy.com/view/XssfRf\n                                    \n//atan2() is a bit tricky, thankfully commonly only defined for vec2.\nv0 atand(v0 a){return atan(a);}//atan(x/y) has limited range and is non branching.\n//wrapping for namespace sake, for automatic differentiation:\n//first defivative of f(x)=atan(x) is f´(x)=1/x*x+1\nd2 atand(d2 a){\n    float b=atan(a.x);\n    d2 e=pow2d(a);\n    e=addd(e,1.);\n    e=divd(1.,e);\n    //e=divd(1.,addd(pow2d(a),1.));\n    return d2(b,e.d);}\n\n//todo, copy\n//https://www.shadertoy.com/view/MdsBRX\n                                    \n//expliicit atan2() //https://en.wikipedia.org/wiki/Atan2\nv0 atand(v0 x,v0 y){//return atan(y,x);//2 branches, goes full circle.\n if(x >0.)return atan(y/x);\n if(y >0.)return  pi*.5-atan(x/y);\n if(0.>y )return -pi*.5-atan(x/y);\n if(0.>x )return  pi   +atan(y/x);\n return 0.;\n}\nv0 atand(v1 a){return atand(a.y,a.x);}\n//but that means it only cares for 2 domains?\nd1 atand(d1 a,d1 b){return a;\n}\n\n//and then it gets more and more tricky: \n// Chain rule Derivative of dot() appears tricky: this should work, untested:\nd2 dotd(DAm2 a, DAm2 b){d2 t0=muld(a.x,b.x),t1=muld(a.y,b.y),t2=muld(a.z,b.z); \n return addd(addd(t0,t1),t2);}\n\n\n//using the above, we define distance functions \n//...that automatically also return the gradient at [p].\n//the gradient is multiple first derivatives along multiple domains\n//... like Dfdx() and Dfdy(), and we also have Dfdz()...\n//... except much cheaper, due to many things canceling out each other.\n//This makes surfaces that are C0-discontinuous, like y=fract(x), \n//...at least have their first derivate calculated continuously,\n//... as long as they are C1-continuous,\n//which can be useful for raymarching:\n\n//Below are translations of the hg_sdf library\n//...to use the above Derivative Arithmetic\n//...serving as examples. on how to translate between 2 arithmetics.\n\n//return distance to unit sphere\nd2 fSphere(DAm2 p){d2 q=lengthd(p.x,p.y,p.z);return subd(q,1.);;}\n//return distance to infinite line segment\nd2 fRay(DAm2 p){p.x.x=mix(0.,p.x.x,step(p.x.x,0.));\n d2 q=lengthd(p.x,p.y,p.z);return subd(q,1.);}//this might be \"broken\" now.\n//fRay() was an error that I chose to keep.\n\n//return distance to box size (s),\n//... corners extrude, keeping all agngles, underestimating distances.\nfloat fBoxCheap(v2 p,v2 b){\n v2 q=abs(p);q=q-p;//mirror clamp\n return max(max(q.x,q.y),q.z);}\nd2 fBoxCheap(DAm2 p,v2 s){\n DAm2 u=subdabsd(p,s);//mirror clamp\n return maxdm(u);}  \n//return distance to box size (s), corners extrude to rounded spheres.\nfloat fBox(vec3 p,vec3 s){\n v2 d=abs(p)-s;//mirror clamp\n v0 a=length(max(d,0.));//rounded corners\n v2 q=min(d,0.);//clamp\n v0 b=max(max(q.x,q.y),q.z);//keep largest of 3\n return a+b;}//add //hg_sdf\nd2 fBox(DAm2 p,v2 s){//v3 s=v3(1.5,.5,1.5);\n DAm2 d=subdabsd(p,s);//mirror clamp\n d2 a=lengthd(maxdm(d,0.));//rounded corners\n DAm2 q=mindm(d,0.);//clamp\n d2 b=maxdm(q);//keep largest of 3\n return addd(a,b);}//add\n             \n//A more readable version of a very parametric implicit surface.\n//...that does not look as much like LISP code, but at its core is just like that.\n//One operation per line keeps it BASIC and modifiable.\nd2 sdSuperprim(DAm2 p, v3 s,vec2 r) {\n //vec2 r=vec2(.2,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 dx,dy,dz,d,e,f,q,a,b,c;\n //dy=vec4(0);dz=vec4(0);d=vec4(0);\n //e=vec4(0);f=vec4(0);q=vec4(0);\n //a=vec4(0);b=vec4(0);c=vec4(0);\n d2 dx=subdabsd(p.x,s.x);\n d2 dy=subdabsd(p.y,s.y);\n d2 dz=subdabsd(p.z,s.z);\n \n d2 d=addd(dx,r.x);d=maxd(d,0.);\n d2 e=addd(dy,r.x);e=maxd(e,0.);\n d2 q=lengthd(d,e);\n d2 f=maxd(dx,dy);f=mind(-r.x,f);\n \n q=addd(q,f);\n q=addd(q,s.w);\n q=absd(q);\n q=subd(q,s.w);\n ///return...\n d2 a=addd(q ,r.y);a=maxd(a,0.);    \n d2 b=addd(dz,r.y);b=maxd(b,0.);a=lengthd(a,b);\n d2 c=mind(-r.y,maxd(q,dz));c=addd(a,c);\n return c;}\n\n\n\n//getfactor() cycles trough example input parameters for sdSuperprim() \n#define SHAPE_COUNT 10.0\nvoid getfactor (int i,out vec4 s,out vec2 r){\n       if(i==0){s=vec4(1)           ;r=vec2(0)     ;//cube\n }else if(i==1){s=vec4(vec3(1),.25) ;r=vec2(0)     ;//corridor\n }else if(i==2){s=vec4(vec3(1),.25) ;r=vec2(1)     ;//pipe\n }else if(i==3){s=vec4(1)           ;r=vec2(1,0)   ;//cylinder\n }else if(i==4){s=vec4(1,1,2,1)     ;r=vec2(1)     ;//pill\n }else if(i==5){s=vec4(1)           ;r=vec2(1)     ;//sphere\n }else if(i==6){s=vec4(1,1,.25,1)   ;r=vec2(1,.25) ;//pellet\n }else if(i==7){s=vec4(1,1,.25,.25) ;r=vec2(1,.25) ;//torus\n }else if(i==8){s=vec4(2,.5,.25,.25);r=vec2(.5,.25);//sausage mouth\n }else if(i==9){s=vec4(.7,1,1,.25)  ;r=vec2(.125)  ;//beveled O\n}}//  https://www.shadertoy.com/results?query=superprim\n                             \n                             \nfloat fOpUnionRound(float a,float b,float r){\n vec2 u=max(vec2(r-a,r-b),0.);return max(r,min(a,b))-length(u);}     \nd2 fOpUnionRound(d2 a,d2 b,v0 r){\n d2 x=subd(r,a);x=maxd(x,0.);\n d2 y=subd(r,b);y=maxd(y,0.);x=lengthd(x,y);\n d2 m=mind(a,b);m=maxd(r,m);return subd(m,x);}\n//does not seem to have good lipschitz.\nfloat fOpIntersectionRound(float a,float b,float r){\n  vec2 u=max(vec2(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\nd2 fOpIntersectionRound(d2 a, d2 b,float r){\n d2 x=addd(r,a);x=maxd(x,0.);\n d2 y=addd(r,b);y=maxd(y,0.);x=lengthd(x,y);\n d2 m=maxd(a,b);m=mind(-r,m);return addd(m,x);}\n#define fOpDifferenceRound(a,b,r) fOpIntersectionRound(a,negd(b),r)\n\n\nfloat pMod1(inout float p,float s){p/=s;\n float c=floor((p)+.5);p=(fract(p+.5)-.5)*s;return c;}\nd2 pMod1(d2 p,v0 s){p=divd(p,s);\n //vec4 c=floord4(p);//c=subd(c,.5);//float c=floor((p)+.5);\n p=addd(p,.5);p=fractd(p);p=subd(p,.5);p=muld(p,s);//p=(fract(p+.5)-.5)*s;\n return p;}\n\n//#if (domains>1)\n /*\n vec2 pR45(vec2 p){return (p+vec2(p.y,-p.x))*sqrt(.5);}\n mat4 pR45(mat4 p){float s=sqrt(.5);\n  p[0]=addd(p[1],p[0]);p[0]=muld(p[0],s);\n  p[1]=subd(p[1],p[0]);p[1]=muld(p[0],s);return p;}\n                              \n //commented out, because it apperrs broken:\n //my fract() <- mod() is likely nonsense!\n //float fOpDifferenceColumns _M(-1.)\n //                             p.y+=c;p.x-=0.70710678118*(r+c);if(mod(n,2.)==1.)p.y+=c;pMod1(p.y,c*2.);return-min(min(max(-length(p)+c,p.x),a),b);}\n //#define fOpIntersectionColumns(a,b,r,n) fOpDifferenceColumns(a-b,r,n)\n /*\n //unknown error\n float fOpUnionColumns(float a, float b, float r, float n) { \n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n }\n v4 fOpUnionColumns(v4 a, v4 b, float r, float n) {\n  if(a.x<r&&b.x<r){\n   mat4 p=mat4(a,b,0,0,0,0,0,0,0,0);\n   float columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n   p=pR45(p);\n   p[0]=subd(p[0],sqrt(2.)/2.*r);\n   p[0]=addd(p[0],columnradius*sqrt(2.));\n   if (mod(n,2.) == 1.) {\n    p[1]=addd(p[1],columnradius);\n   }\n   p[1]=pMod1(p[1],columnradius*2.);\n   vec4 r=lengthd(p[0],p[1]);\n   r=subd(r,columnradius);\n   r=mind(r,p[0]);\n   r=mind(r,a);\n   r=mind(r,b);\n   return r;\n  }\n  return mind(a,b);\n }\n */\n                             \n                             /*\n //also fails\n // The \"Stairs\" flavour produces n-1 steps of a staircase:\n // much less stupid version by paniq\n float fOpUnionStairs(float a, float b, float r, float n) {\n     float s=r/n; \n     b=b-r; \n     float d=b-a+s;\n     d=mod(d,2.*s);\n     d=d-s;\n     d=abs(d);\n     d=b+a+d;\n     d=d*.5;      \n     return min(min(a,b),d);\n }\n v4 fOpUnionStairs(v4 a, v4 b, float r, float n) {\n     float s=r/n;\n     b=subd(b,r);\n     a=subd(b,a);\n     a=addd(a,s);//float d=b-a+s;\n     vec4 d=modd(a,2.*s);//d=mod(d,2.*s);\n     d=subd(d,s);\n     d=absd(d);\n     d=addd(a,d);\n     d=addd(b,d);\n     d=muld(d,.5);  \n     d=mind(d,a);\n     d=mind(d,b);\n     return d;\n\t return min(min(a,b),d);\n }\n\n // We can just call Union since stairs are symmetric.\n float fOpIntersectionStairs(float a, float b, float r, float n) {\n     return -fOpUnionStairs(-a, -b, r, n);\n }\n\n float fOpDifferenceStairs(float a, float b, float r, float n) {\n     return -fOpUnionStairs(-a, b, r, n);\n }\n */\n\n\n //demo playground for boolean unions of implicit surfaces.\n d2 aBool(DAm2 p){\n  d2 box=fBoxCheap(p,vec3(1));\n  p=subd(p,vec3(-1,1,1));//p.x=addd(p.x,1.);p.y=subd(p.y,1.);p.z=subd(p.z,1.);\n  d2 box2=fBox(p,vec3(1));\n  //return mind(box,box2);//(box or     box2)\n  //return maxd(box,box2);//(box and     box2)\n  //return maxd(box,-box2);//(box and not box2)\n  return fOpUnionRound(box,box2,1.);\n  //return fOpIntersectionRound(box,box2,.3);\n  //return fOpDifferenceRound(box,box2,.5);\n  //return box;\n }\n \n //set camera position & target\n void setCam(out vec3 o,out vec3 i,v0 t,v0 m){\n  o=vec3(4.*sin(t),m*9.-2.,4.*cos(t));i=vec3(0);}\n\n struct DAMValue{d2 d;float m;};//to paint the gradient on a plane.\n DAMValue min2(DAMValue a, DAMValue b){if(a.d.x>b.d.x)return b;return a;}\n DAMValue plane(DAm2 p){return DAMValue(addd(p.y,1.),1.);}\n //DAMValue add_plane(DAVec3 p,DAMValue m){return min2(plane(p),m);}\n \n  #define ss01(a) smoothstep(0.,1.,a) \n  #define imsc(a) int(mod(a,SHAPE_COUNT))\n  //return distance to surface of DistanceField\n  DAMValue df(DAm2 p){d2 r;\n  #ifndef SuperPrim\n   //simpler more static parametric surfaces:\n   r=aBool(p);\n   //r=fSphere(p);\n   //r=fBox(p,vec3(1));\n   //r=fBoxCheap(p,vec3(1));\n   float holesize=mix(.6,5.,sin(iTime*3.)*.5+.5);\n   d2 s=fSphere(muld(p,vec3(holesize)));r=maxd(r,negd(s));\n   //scaling by holesize is bad for lipschitz constant.\n  #else\n   //superprim() is a very parametric implicit surface.\n   float t=iTime,u=ss01(ss01(fract(t)));\n   vec4 a,b;vec2 c,d;\n   getfactor(imsc(t   ),a,c);\n   getfactor(imsc(t+1.),b,d);\n   DAm2 q=DAm2(p.y,p.z,p.x);\n   if(iMouse.z>.5){\n    vec2 m=iMouse.xy/iResolution.xy;\n    r=sdSuperprim(q,vec4(vec3(1.0),mix(a.x,b.x,u)),m);\n   }else\n    r=sdSuperprim(q,mix(a,b,u),mix(c,d,u));\n  #endif\n   //return DAMValue(r,0.);\n   return min2(plane(p),DAMValue(r,0.));}\n \n //return distance & materialID\n vec2 dm(v2 p){DAMValue d=df(da_domain(p));return vec2(d.d.x,d.m);}\n //return material at p with normal n\n vec4 material(v2 p,v2 n ){d2 d=df(da_domain(vec3(p.x,0.,p.z))).d;\n  return mix(vec4(n*.5+.5,.1)\n            ,vec4(d.d*.5 +.5,.0)*abs(mod(d.x,.1)/.1-.5)\n            ,sat(dm(p).y));} \n\n //return soft shadow of light source at [o], \n //... with light direction [i] pointing from [o] to surface point [p]\n float shadow(v2 o,v2 i){\n  const float a=32.;//shadow hardnes\n  float r=1.,h =1.,t=.0005;//t=(self)intersection avoidance distance\n  for(int j=0;j<IterSh;j++){\n   h=dm(o+i*t).x;\n   r=min(r,h*a/t);\n   t+=clamp(h,.02,2.);}//limit max and min stepping distances\n  return clamp(r,0.,1.);}\n //  iquilezles.org/articles/rmshadows\n\n //return p, modified by light , shadow, envMap...\n v2 light(vec3 p,vec3 n,vec3 i,float d,vec4 m){\n  v2 l=normalize(v2(1.,.7,.9));//light direction\n  v0 o=max(0.,dot(n,l)),\n  c=max(0.,dot(n,normalize(l-i))),\n  s;if(c>.01)s=shadow(p+.01*n,l); \n  const v2 LigCol=vec3(1.);//light color\n  v2 r=m.rgb*(LigCol+o*vec3(.8,.7,.6)*s*3.+vec3(.2,.3,.3));  \n  r+=s*c*pow(o,40.);//specular\n  //r+=m.x*texture(iChannel0, reflect(i,n)).rgb;//environment map\n  r*=exp(-.01*d*d);//fog  \n  return r;}\n\n //return distance along ray (raymarch till surface)\n float rm(v2 o,v2 i){\n  const float m=20.;//distance.Max\n  float e=.0,h=e,t=0.;//intersection.precission\n  for(int j=0;j<IterRm;j++){\n   if(h<e)break;if(t>m)return -1.;\n           //wait a moment, do i not have the lipschitz for the point\n      //or at least 3 for 3 domains of the point\n      //by using [DA]?\n      //i mean, i could really insert this here, right?\n      //and substitute ReciprocalAbsLipschitz with \"1/da_length(dm(o+i*t).yzw)\"\n   //i am pretty sure that i am missing a dotproduct here\n   //the gradient must be dorproducted onto the ray direction?\n   DAMValue s=df(da_domain(o+i*t));\n   float r=ReciprocalAbsLipschitz;\n   //r=1./length(dot(s.d.yzw,i));//overwriting with a VERY LOCAL lipschitz constant\n      //its not a good estimate, but it is a LOT better?\n      //nah it totally fails for concave isosurfaces.\n   h=s.d.x*r;t+=h;}return t;}\n \n  //return camera matrix\n  mat3 calcLookAtMatrix(in vec3 o,in vec3 i,in float r ){\n   vec3 w=normalize(i-o);vec3 u=normalize(cross(w,vec3(sin(r),cos(r),0.)) );\n   return mat3(u,normalize(cross(u,w)),w);} \n\n //return surface normal\n vec3 getN(in vec3 p){DAMValue d=df(da_domain(p));return d.d.d;}\n //d.d.d stores the first derivatives on the 3 domains, (is also an awesopme pointer label)\n //this is equivalent to the gradient at p.\n //If (p is near a surface) the gradient is a surface normal\n //d.d.* addresses a vec4. where *.yzw==gradient\n //d.m.* addresses a material\n//#elif (domains==1||domains==3)\n //is a lot like \n //  https://www.shadertoy.com/view/XdffzB\n d getd(v0 u){\n  //function must be defined in prefix-notation;\n  //  https://en.wikipedia.org/wiki/Polish_notation  \n  //return absd(u);//f(x)=abs(x)  //first derivative of abs(x) is always a good start\n  //return sind(u);//f(x)=sin(x) //cos(x) as first derivative of sin(x)\n  return addd(absd(u),sind(u));//f(x) = abs(x)+sin(x) = add(abs(x),sin(x))\n }\n//#elif (domains==0)\n //this mode may insist on using a second domain as deltaTime or deltaMultipleFunctions?\n //so, it basically comes down to Fourier Transform.\n //otherwise one domain of screenspace gets wasted.\n//#endif \n\n//domain independent algebra:\n//return color corrected r\nvec3 ff_filmic_gamma3(vec3 r){vec3 x=max(vec3(0),r-.004);\n return (x*(x*6.2+.5))/(x*(x*6.2+1.7)+.06);}     \n\n //https://en.wikipedia.org/wiki/Alpha_compositing\n vec4 aOverB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a+b*(1.-a));}\n //vec2 aOverB(vec2 a,vec2 b){a.x*=a.y;b.x  *=b.y;return vec2(a+b*(1.-a));}\n //not sure if correct, but looks useful.\n vec4 aXorB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a*(1.-b)+b*(1.-a));}\n //vec2 aXorB(vec2 a,vec2 b){a.x*=a.y;b.x  *=b.y;return vec2(a*(1.-b)+b*(1.-a));}\n #define ssb(a) smoothstep(blur,-blur,a)\n\n//#if (domains>1)         \n vec4 in3d(vec2 u){\n u=(-iResolution.xy+2.*u.xy)/iResolution.y;\n vec2 m=iMouse.xy/iResolution.xy;  //mouse\n vec3 o,i,c=vec3(0);\n setCam(o,i,iTime,m.y+.2);//camMovement\n vec3 d=normalize(calcLookAtMatrix(o,i,camRoll)*vec3(u.xy,camLens));//ray.direction\n float t=rm(o,d);//Distance.raymarched\n if(t>-.5){\n  vec3 p=o+t*d,n=getN(p); //position & normal\n  vec4 m=material(p,n);   //material\n  c=light(p,n,d,t,m);}    //light\n c=ff_filmic_gamma3(c*.6);//gamma\n //c=pow( clamp(col,0.0,1.0), vec3(0.4545) );\n return vec4(c,1.);}\n//#elif (domains==3)\n #define frame(u) camLens*(u-.5*iResolution.xy)/iResolution.y\n //2d domain space parent: https://www.shadertoy.com/view/XdffzB\n vec4 in2d(vec2 u){\n  u=frame(u)*9.;\n  u.y+=2.;\n  vec2 f=abs(fract(u));//green carthesian grid\n  float h=abs(fract(length(u)+thick)-thick);//green polar circles\n  float g=min(min(f.x,f.y),h);\n  d d=getd(u.x);\n  //float div=sqrt(1.+p.y*p.y);\n  float r=abs(d.x-u.y)/(sqrt(1.+d.d*d.d))-thick;    \n  d=getd(u.x);\n  //no analytical 2nd derivative, so this one sucks a bit\n  float b=abs(d.d-u.y)/(sqrt(1.+d.d*d.d))-thick;\n  //this does not work for scaled p, is far from being uder friendly\n  float blur=20./max(iResolution.y,1.);\n  vec4 yellow =vec4(vec3(1,1,0),ssb(r));\n  vec4 cyan   =vec4(vec3(0,1,1),ssb(g));\n  vec4 magenta=vec4(vec3(1,0,1),ssb(b));\n  return aOverB(aOverB(yellow,magenta),cyan);}\n//#elif (domains==0)\n vec4 in1d(vec2 u){\n  return vec4(0);}\n//#endif \n\n\nvoid mainImage( out vec4 O,in vec2 U ){\n #if (domains==3)\n  //this is not 4d, it is 2d overlayed on top of 3d.\n  O=aOverB(in2d(U),in3d(U));}\n  //O=vec4(mix(ass.xyz,poo.xyz,ass.w),1.);}\n #elif (domains==2)\n  O=in3d(U);}\n #elif (domains==1)\n  O=in2d(U);}\n #elif (domains==0)\n  O=in1d(U);}\n #endif \n                             \n//my todo_list;\n//todo, find aliases for common operations, and debug them.\n//I suspect that modulo and 2d rotation seem buggy.\n//\n//todo, merge with hg_sdf, full set\n//to have hg_sdf with first derivatives, in 2 or 3 domains.\n//it already poited at my lack of competence to substitute correctly\n//-> lots of small errors.\n//\n//done, looking good enough:\n//\n//fSphere()\n//fRay() (infinite line segment with radius 1)\n//fBox()\n//fBoxCheap()\n//\n//mind() maxd() unions of 2 distance fields (Boolean AND, boolean OR)\n//fOpUnionRound()\n//fOpIntersectionRound()\n//fOpDifferenceRound()\n//\n//I failed at:\n//fOp*Columns\n//fOP*Staircase\n//\n//\n//todo pModd() , will likely hint me at how to fix stuff.\n//\n//todo: include complex plane transformation math of\n//  https://www.shadertoy.com/view/ls2cDt\n//for anything \"Cauchy\"\n//  https://en.wikipedia.org/wiki/Complex_analysis\n//  https://en.wikipedia.org/wiki/Augustin-Louis_Cauchy\n//\n//todo, antialiasing, merger with: https://www.shadertoy.com/view/MdXczr\n//\n//todo, curvature stuff, because I want a minimal surface !",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}