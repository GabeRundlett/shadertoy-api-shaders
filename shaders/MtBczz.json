{
    "Shader": {
        "info": {
            "date": "1507170452",
            "description": "reflecting Deah Star!\n\narrow and mouse moves. \nhow does this look in VR?\nHow is the scaling\nmy AmbientOcclusion() is off scale!!!! please fix it!\n\nto see what dynamiceps can do, best fly backwards ant up.",
            "flags": 49,
            "hasliked": 0,
            "id": "MtBczz",
            "likes": 3,
            "name": "shiny death star flight",
            "published": 3,
            "tags": [
                "quaternion",
                "vr",
                "marbles",
                "fly",
                "dynamiceps",
                "edynvr",
                "logeps"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1344
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 o, in vec2 u){\n o=texture(iChannel0,u/iResolution.xy, -100.0 );\n  //o+=mainImage2(o,u);\n}\n\n//everything is in BuffA!\n//it needs a buffer for camera position and rotation.",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//sign 3d fly horizon\n//self  : https://www.shadertoy.com/view/4tSyRz\n\n//i need help fixing something\n//the SIZE of my AO is too large.\n//because i scaled the distance field up\n//should look like:  https://www.shadertoy.com/view/Xl2cRR\n//AO is only done for the hexagon prisms\n//, you see their base ans tip has too much of it.\n//i had to, for more epsilon precison for better reflectiosn\n//but scalup ip the gradients messed up my AO function.\n//where ever AmbientOcclusion() is called, its parameters are scaled badly\n//i usually despise AO, so i fail to fix this one\n//but guess what, in a schene where everything is a mirror, AO becomes almost essential\n\n//and yes, the sinusoidial floos causes the whole set to become lipschitz discontinuous. \n//its kind of the point to THEST THAT till i tweaked this more.\n\n//till this shit is fixed, this shader is a composit of like\n//3 scenes (the fractal one started it all, the others are \"for more features\")\n//2 very different raymarchers (the infinite-reflection-horizon one is tricky to tweak)\n\n//this AO problem only affects Scene=3, you can set this to other scenes here:\n#define Scene 3\n//0=Foggy Fractal columns\n//1=Foggy Truchet coaster\n//2=Horizon Ocean of Sticks and balls\n//  texturing is messy\n//3=Horizon Ocean of Sticks and balls + reflections \n//  for Scene3 setup, i gt reflections to work, but AO is broken:\n//  (scaling needs tweaks, with bad scaling either reflections or AO sucks)\n\n//okay, theres a REAL precision issue here, in regards to how small an epsilon can be.\n//and to make rmaller RELATIVE epsilon possible i scaled up the whole setting\n//which in return makes you smaller, and slower.\n//Ocean of Sticks and balls is larger, and you accellerate faster inside of it.\n//so it canels out. its just not compatible with how ou usually do this.\n\n//defunct code (must fix other things before doing shadows in reflections)\n#define MAX_SHADOW_REFLECTIONS 2.\n\n#define doOcclusionShaddow\n//AO really helps the projection, because it is full of mirrors, confusing without AO\n#define doOcclusionAmbient\n\n\n//- - resource hogs and StackHeap Crashers:\n//epsilon  is a break condition for sphere tracking.\n//fractals need smaller eps, IEEE floats lose too much precision below .0000001\n//smaller eps result in slower fps and more convave areas.\n#define eps .001\n//max number of raymarch spheretracking iterations, max number of gradient descents.\n#define iterRm 156.\n//max view distance, far clipping sphere, centred around camera\n#define zFar 80.\n//to veil the horizon or not to veil the horizon, that is the asymptote.\n//#define doFog\n//for the way that TnL is done here, fog is actually quite useful\n//normally i hate distance fog, but the TnL of this shader uses it nicely\n\n//scale all scenes uiformly\n//welcome to wonderland.\n//GoogleMapsVR sets this to \"camera height above nearest ground.y\"\n//which woks better than you would assume!\n//but i do not define a distance.y just for that!\n//you easily could though.\n#define scaleVR 1.\n//doesnt work AT ALL with reflections as oof now\n//too extreme scaleVR can mess up normal approximarion\n//ot texturing, or general shape of fractals\n//vecause this is not yet fully implemented\n\n//scaling factor only for scene9, where precision is trickier!\n#define scaleScene2 1.\n\n//doto, add a death star to scene 2 in various sizes.\n\n //max.iter fractal shapes, parent setting is 4. 5. is a bit \"brighter\"\n #define iterDfFractal 4.\n\n\n//collision epsilon\n#if Scene==3\n //reflections has some issues when camera is too close to surfaces.\n #define TOO_CLOSE 0.5\n#else \n #define TOO_CLOSE 0.01\n#endif\n\n//todo: TOO_CLOSE should internally scale with movement speed\n//controls (i may have swapped left and right here, do not overthing this one)\n#define LEFT_ARROW 39\n#define RIGHT_ARROW 37  \n#define UP_ARROW 38\n#define DOWN_ARROW 40\n\n#if Scene==1\n //truchet setting\n #define doNormals\n //cut off half of the distance field along a plane that that the .y axis as its normal.\n #define cutY\n#elif Scene>1\n #define doNormals\n #undef zFar\n //scene2 benefits from dynamiceps, whee view distance should only constrain light\n #undef fog\n #define zFar 10000.\n //truchet setting\n#else\n //fratal setting\n //cut off half of the distance field along a plane that that the .y axis as its normal.\n #define cutY\n //#define doNormals\n#endif\n\n\n\n#define sat(a) clamp(a,.0,1.)\n\n#define PI acos(-1.)  \n#define PIB asin(1.)\n\n#define skyColor       vec3(.2,.5,1.)\n//#define shadowColor    vec3(.2,.2,.5)\n#define groundColor    vec3(.6,1.,.7)\n#define buildingsColor vec3(.8,.7,.2)\n#define redColor       vec3(.9,.2,.7)\n//these colors visually make sense for contrast, even for red-green blindness.:\n//shadows are blue\n//ground is greener\n//floating objects are red\n//near ground objects are yellow\n#define SKY_MTL 0\n#define GROUND_MTL 1\n#define BUILDINGS_MTL 2\n#define RED_MTL 3\n\n//these defines are not too practiical:\n#define fovyCoefficient 1.\n#define shadowHardness 3.\n#define time iTime\n\n\n//hg_sdf oneliners3:\nfloat fOpPipe(float a,float b,float r){return length(vec2(a,b))-r;}\nfloat fOpEngrave(float a,float b,float r){return max(a,(a+r-abs(b))*sqrt(.5));}\nfloat fOpGroove(float a,float b,float ra,float rb){return max(a,min(a+ra,rb-abs(b)));}\nfloat fOpTongue(float a,float b,float ra,float rb){return min(a,max(a-ra,abs(b)-rb));}\n\nfloat deathstar(vec3 u){\n float a=length(u-vec3(0,50,0))-40.;\n //float b=length(u-vec3(5,11,0))-10.;\n    float b=u.x-1.;\n    a=fOpGroove(a,b,.5,.3);//left is groove depth, right is groove width\n\n return a;\n}\n\n\n\n\n/*\nself  : https://www.shadertoy.com/view/4tSyRz\n- single page, less duped code. trutural sorting \n- less globals, more object oriented.\n- more defines\n- larger render distance.\n- establishing [tiny namespace convention]\n- - mostly in scene()\n- - distance field is called gd() and gd1()for colors (resolves fractal G-buffer stuff?)\nparent: https://www.shadertoy.com/view/lsd3Dl\n  Rocket City by eiffie (although there are no rockets \n   and there is little if any esemblance to a city this is what eiffie called it)\n  eiffie just wanted to make a reusable flight control \n   but then messed that up with collision detection.\n\n\nparent: https://www.shadertoy.com/view/llSyRR\n   truchet mable distance field gradient\n\nThe main hallenge here is to standardize many fhader pipelines\n thisgets messy as soon as you gt a soure with materialIDs\ntill then this is a mess of diferent sets\n ,different marching methods and different TnL occlusion methods.\n but i can fly around in them.\n YAY\n\n\nthe TnL of one parent doesnt work too well with the shape of the other parent.\nThis is a qquck merger that is not too much of an eyesore.\n\nAn odd mix of surface normal and phong?\nits fractal AO (cares for smalles last 4 marches)\n without shadows also makes it look uncanny.\n*/\n\n\n\n//- - shape and TnL:\n//fractals need more iterShadAO at screenspace-edges (edge detecion)\n//, where normals are not pointing towards camera\n//Max.sample soft shadow \n#define iterAO 6.\n//do shading. do calculus operations, sample derivatives of the gradient.\n#define doShade\n//ao on fractals is often odd, it can make things brighter.\n#define doAO\n//do specular light, fake reflectio of sunlight\n#define doSpec\n//this sloppy merger is better doing doNormals AND doThuchetCoaster , or None!\n//mostly because the fractal shape has \"special\" defined \"normals\"\n//otherwise the [texturing and Lighting] does not match the [shape] too well.\n\n\n//- - controls:\n//*scaleVR == the larger you are, the faster you accellerate.\n#if Scene==2\n#define THRUST 0.02*iTimeDelta*scaleVR*99.\n#elif Scene==3\n#define THRUST 0.02*iTimeDelta*scaleVR*99.\n#else\n#define THRUST 0.02*iTimeDelta*scaleVR\n#endif\n#define ROLL 1.0*iTimeDelta\n#define ROTATE 4.0*iTimeDelta\n\n\n\n//now with autopilot, thanks Fabrice!\n//#define USE_AUTO_PILOT \n//looks like i broke it\n\n\n\n//does not have dynamiceps\n\n//does not have any code for reflections.\n\n//these defines are not too practiical:\n#define fovyCoefficient 1.\n#define shadowHardness 3.\n#define time iTime\n\n\n//---lib.core:\n#define sat(a) clamp(a,.0,1.)\n#define u2(a) ((a)*2.-1.)\n#define u5(a) ((a)*.5+.5)\n#define PI acos(-1.)  \n#define PIB asin(1.)\n//for mad()-awareness.\nfloat mad (float b,float c,float d){return b*c+d;}\n\n\n//---lib.buffer, originally from iq, modified\nfloat isInside(vec2 p,vec2 c){vec2 d=abs(p-.5-c)-.5;return -max(d.x,d.y);}\nvec4 load(int re){return texture(iChannel0,(.5+vec2(re,.0))/iChannelResolution[0].xy,-100.);}\nvoid store(in int re, in vec4 va, inout vec4 o, in vec2 u\n){if(isInside(u,vec2(re,0))>.0)o=va;}//o=(isInside(u,vec2(re,0))>.0)?va:o;}\n//bool KeyDown(in int key){return (texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x>0.0);}\nfloat key(in int key){return texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x;}\n//---lib.quaterion\nvec4 qid(){return vec4(0.0,0.0,0.0,1.0);}\n//return q2, rotated by q1, order matters when unsigned(axes) are not identical.\nvec4 qmulq(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz)\n,(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\nvec4 aa2q(vec3 axis, float angle){return vec4(normalize(axis)*sin(angle*0.5),cos(angle*0.5));}\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dot(q,q);}//inverse quaternion\n//return p, rotated by q;\nvec3 qmulv(vec4 q, vec3 p){return qmulq(q,qmulq(vec4(p,.0),qinv(q))).xyz;}\n//rotate pitch,yaw,roll in that order:\nvec4 qpyr(vec3 o){o*=0.5;vec3 s=sin(o),c=cos(o)\n;return vec4(s.x*c.y*c.z+s.y*c.x*s.z,s.y*c.x*c.z-s.x*c.y*s.z\n,s.x*s.y*c.z+s.z*c.x*c.y, c.x*c.y*c.z-s.x*s.y*s.z);}\n//vec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.0);}//assumed q is normalized coverts to axis&angle\n//vec4 qlookat(vec3 v){return aa2q(vec3(-v.y,v.x,0.0),acos(v.z/length(v)));}//point in direction v\n//vec3 vmulq(vec3 p, vec4 q){return qmulq(qinv(q),qmulq(vec4(p,0.0),q)).xyz;}//inverse rotation\n/*\n//[quaternion spherical linear interpolation] between 2 quaterion rotations in 3d space.\nvec4 qslerp(vec4 a,vec4 b,float f)\n{float d=dot(a,b),theta=acos(abs(d)),ost=(1./sin(theta))\n;return normalize(a*sin(theta*(1.-f))*ost*sign(d)+b*sin(theta*f)*ost); }\n*/\n\n\n//---lib.shape:\nvec3 Tile(vec3 p){vec3 a=vec3(8.0);return abs(mod(p,a)-a*0.5)-a*0.25;}\nfloat DERect(vec4 z,vec3 r){return length(max(abs(z.xyz)-r,0.0))/z.w;}\nconst float mr=0.5, mxr=0.975, scale = 2.52;\nconst vec3 rc=vec3(3.31,2.79,4.11),rcL=vec3(2.24,1.88,2.84);\nconst vec4 p0=vec4(4.0,0.0,-4.0,1.0);\nfloat torus(vec3 p,vec2 r){\n return length(vec2(abs(abs(length(p.xy)-r.x)-.1),abs(p.z)-.1))-r.y;}\nfloat square(vec3 p,vec2 r){\n return length(vec2(abs(max(abs(p.x),abs(p.y))-r.x),p.z))-r.y;}\n\n//----lib.color\n#define skyColor       vec3(.2,.5,1.)\n#define shadowColor    vec3(.2,.3,.5)\n#define groundColor    vec3(.6,1.,.7)\n#define buildingsColor vec3(.8,.7,.2)\n#define redColor       vec3(.9,.2,.7)\n//these colors visually make sense for contrast, even for red-green blindness.:\n//shadows are blue\n//ground is greener\n//floating objects are red\n//near ground objects are yellow\n#define SKY_MTL 0\n#define GROUND_MTL 1\n#define BUILDINGS_MTL 2\n#define RED_MTL 3\nconst vec3 sunDir=normalize(vec3(0.7,1.0,-0.7))\n,sunColor=vec3(1.0,0.99,.9)\n//,skyColor=vec3(.25,.26,.27)\n//rainbow tinted cosmic microwave background, makes nice fog.\n;vec3 Backdrop(in vec3 rd){vec3 a= \n+shadowColor\n+.05*(rd+sin(rd.yzx*5.+2.4*sin(rd.zxy*3.0)))\n+sunColor*(max(0.0,dot(rd,sunDir))*0.2+pow(max(0.0,dot(rd,sunDir)),256.));\n;return .7*a;}\n\n//----lib.hash for scatter-noise\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p){p=fract(p*HASHSCALE3)\n;p+=dot(p,p.yxz+19.19);return fract((p.xxy+p.yxx)*p.zyx);}\nfloat h12(in vec2 p){\n return fract(float(iFrame)+sin(dot(p,vec2(13.3145,17.7391)))*317.7654321);}\n\n\n//---lib.setting: (BVHs and fuzzy-boolean mixes of shapes)\n\n\nfloat CubeDistance2 (in vec3 point, in vec3 size){return length(max(abs(point)-size,0.));}\nfloat sdHexPrism(vec3 p,vec2 h){vec3 q=abs(p);return max(q.z-h.y,max(q.x*.866025+q.y*.5,q.y)-h.x);}\nvec3 DistanceRepetition(in vec3 point, in vec3 repetition ){\n    vec3 q = mod(point, repetition)-.5*repetition;return q;}\nfloat CubeRepetition(in vec3 point, in vec3 repetition ){\n  point.x+=sin(point.y*.11+time*5.);\n  point.z+=cos(point.y*.11);\n  vec3 q = mod(point,repetition)\n  -0.5*repetition;q.y = point.y;\n  return sdHexPrism(q.zxy,vec2(10.,50));\n  return CubeDistance2 ( q, vec3 (10., 50.+sin(time)*15.,10.));}\nfloat PlaneDistance(in vec3 point,in vec3 normal,in float pDistance){return dot(point-(normal * pDistance), normal);}\nfloat modA(float x){return mod(time*.1+x+55.,230.)-55.;}\nfloat fSphere       (vec3 p,float r){return length(p)-r;}\nfloat SphereDistance(vec3 point, vec3 center, float radius){\n  point.z = modA(point.z);point.x = modA(point.x);\n  return fSphere(point-center,radius);}\nfloat RedDistance(in vec3 position){return SphereDistance(position,vec3(0.,66.,0.),30.);}\nfloat BuildingsDistance(in vec3 position){\n  return min(CubeRepetition(position                                ,vec3(80.,0., 90.)),\n\t         CubeRepetition(position+vec3(350.,sin(time)*30.,0.) ,vec3(90.,0.,100.)));}\nfloat GroundDistance(in vec3 position){return PlaneDistance(position,vec3(0.,1.,0.),0.);}\n//merging distance functions above to distanceField function below:\nfloat gdHorizon(vec3 position){\n;float sgScale=scaleScene2*scaleVR\n;position.y+=10.;\n;position*=sgScale\n;int mtl//marerials disabled.\n;float radial=length(vec2(position.x,position.z))\n;float radialSine=sin(radial*.05-time*2.)*5.\n;float gndDistance=position.y-radialSine+6.;\n    float bldDistance=BuildingsDistance(position);\n    float redDistance=RedDistance      (position);\n                       float closest=gndDistance;mtl=   GROUND_MTL;\n    if (bldDistance<closest){closest=bldDistance;mtl=BUILDINGS_MTL;}\n    if (redDistance<closest){closest=redDistance;mtl=      RED_MTL;}\n    return closest/sgScale/scaleVR;}\n\n\n//truched3dcoaster\nfloat thuchetCoaster(vec3 u)\n{u*=scaleVR;\n;vec3 p2 = mod(u,2.)-1.\n;vec3 floorpos=floor(u*.5)\n;float len=1e10\n;vec3 orientation = u2(floor(hash33(floorpos)+0.5))\n;vec3 p3 = p2*orientation\n;mat3 truchet=mat3\n(vec3(p3.yz*vec2(1, 1)+vec2(-1,-1),p3.x)\n,vec3(p3.zx*vec2(1, 1)+vec2( 1, 1),p3.y)\n,vec3(p3.yx*vec2(1,-1)+vec2( 1, 1),p3.z))\n;vec3 lens=vec3\n(torus(truchet[0],vec2(1.0,0.02))\n,torus(truchet[1],vec2(1.0,0.02))\n,torus(truchet[2],vec2(1.0,0.02)))\n;vec3 mask = vec3(lessThan(lens,min(lens.yzx,lens.zxy)))\n;vec3 p4 = truchet[int(dot(mask,vec3(0,1,2)))]\n;float dir = u2(mod(dot(floorpos,vec3(1.0)),2.0))//*dot(mask,vec3(-1.0,1.0,-1.0));\n;p4=vec3(fract(dir*(atan(p4.x,p4.y)/6.28*4.0)+iTime*0.5)-0.5,length(p4.xy)-1.0,p4.z)\n;float a=min(dot(lens,mask),length(p4)-0.1);\n#ifdef cutY\n;a=max(a,u.y);\n#endif\n;return a/scaleVR;\n}//https://www.shadertoy.com/view/llSyRR\n\n\nfloat fractal1(vec3 u){\n;u*=scaleVR\n;vec3 p=Tile(u)\n;vec4 z=vec4(p,1)\n;float dG=1e3\n;for(float n=.0;n<iterDfFractal;n++ //fractal\n){z.xyz=clamp(z.xyz,-1.,1.)*2.-z.xyz\n ;z*=scale/clamp(max(dot(z.xy,z.xy),max(dot(z.xz,z.xz),dot(z.yz,z.yz))),mr,mxr)\n ;z+=p0\n ;if(n==2.)dG=DERect(z,rcL);\n}\n;dG=min(dG,DERect(z,rc))\n#ifdef cutY\n;dG=max(dG,u.y);\n#endif\n;return dG/scaleVR;\n}\n\n//return signed euclidean distane of[u] to a surface, gradient3d (imagine static thermodynamics)\n//[d] is \"distance to camera\" for  LOD detail interpolation\n//is not really \"distance to camera\" since reflections...\n//well its more akin to\"age of photon\"\nfloat gd(vec3 u,float d){//gradient differential, signed distance field:\n#if  Scene==1\nfloat a=thuchetCoaster(u);\n#elif Scene==2\nfloat a=gdHorizon(u);\na=min(a,deathstar(u*.1)*10.);\nreturn a;\n#elif Scene==3\nfloat a=gdHorizon(u);//same scene, with differnt raymarcher\na=min(a,deathstar(u*.1)*10.);\nreturn a;\n#else\nfloat a=fractal1(u);\n#endif\na=min(a,deathstar(u));\nreturn a;\n;}\n\n//return first derivative of the gd()\n//FAST non-analytic 3pass estimate of first derivative of map() == normals3d\n\n//t=age of photon, time that the photon has traveled \n//(like distance to camera, but with reflections)\nvec3 normal(vec3 p, float t, float l){vec2 e=vec2(.1,0)\n;return normalize(vec3\n(l-gd(p-e.xyy,t)\n,l-gd(p-e.yxy,t)\n,l-gd(p-e.yyx,t)));}//todo, replace with \"automatic differentiation\"\n//1passPerDoman is less precise than 2passPerDomain variant, but not by much.\n\n//A variant of gd(), that is HERE used to get a color and to derive a surface normal.\n//the inout vec4 mcol is a big difference.\n//gd1 exists because the fractal shape gets \"specual treatment\" for color\n//, due to \"nnormals being tricky within a KIFS\"\nfloat gd1(vec3 p,inout vec4 mcol)\n{p=Tile(p)\n;vec4 z=vec4(p,1)\n;float dG=1e3\n;vec4 mc=vec4(0)\n;for (float n=.0;n<5.;n++ //palette of 5 colors, i sync to abive fractal shape\n){z.xyz=clamp(z.xyz, -1.0, 1.0) *2.0-z.xyz\n ;z*=scale/clamp(max(dot(z.xy,z.xy),max(dot(z.xz,z.xz),dot(z.yz,z.yz))),mr,mxr)\n ;z+=p0\n ;if(n==3.)mc=vec4(vec3(.5,.3,.2)+z.xyz*.05,.25)\n ;else if(n==2.)dG=DERect(z,rcL);\n}float ds=DERect(z,rc)\n;if(dG<ds)mcol+=vec4(0.5,0.6,0.9,0.9)+vec4(z.xyz*0.025,0.0)\n;else mcol+=mc\n;return min(dG,ds);}\n\n//return [c]color, modified by distance fog\n//[ts] DistanceToCamera [is a delta [time since] photon got emmited]\n//there is no such thing as global distance, but there is a global speed if light.\n//[f] FogColor (assume a cosmic microwave background image pixel)\n//,designed for a zFar of 20, scales, but not too well.\nvec3 fog(float ts,vec3 c,vec3 f){\n//;float fog=min(pow(ts*.2,1.33)*.54,1.)//only for zFar=20.\n;float fog=min(pow(ts*20./zFar*.2,1.33)*.54,1.)//optimizd for zFar=20.\n//must be reciprocal log() ?\n;return mix(c,f,fog);}\n\n//iqs famous softshadow, set to low quality\nfloat SoftShadow(in vec3 landPoint, in vec3 lightVector, float mint, float maxt, float iterations ){\n    float penumbraFactor=1.0;vec3 sphereNormal;float t=mint;\n    for(int s=0;s<20;++s){if(t > maxt) break;\n        float nextDist = min(\n            BuildingsDistance(landPoint + lightVector * t )\n            , RedDistance(landPoint + lightVector * t ));\n        if( nextDist < 0.001 ){return 0.0;}\n        penumbraFactor = min( penumbraFactor, iterations * nextDist / t );\n        t += nextDist;}return penumbraFactor;}\n\n//return ambient occlusion\n//[o] LightSourcePosition\n//[d] LightDirection\n//[s] ScatterHash\n//[t] age of photon (time that the phonon traveled since emmited from camera.\nfloat AO(in vec3 p,in vec3 d,float s,float t){\n;float tt=.0,a=1.,f,n=.01+.04*s\n;for(float i=.0;i<iterAO;i++ \n){f=max(gd(p+d*tt,t)*1.5,n)\n ;a=min(a,f/t+t*0.5)\n ;t+=f;\n}return a;}//soft shadow with \"noisy lens\".\n\n#ifdef doShade\n //return occluded specular of [r]\n //[r]accumulator to return, ends up being \"phong glossy\"\n //[o]rigin\n //[d]direction\n //[p]point in space; p=o+d*ts.x\n //[N]surfaceNormal at [p]\n //[s]ScatterHash\n //[t]age of photon (for LOD super sampling, older photons get a lower LOD)\n //[mcol] materialColor (diffuse)\n vec3 SpecOcc(vec3 r,vec3 d,vec3 N,vec3 p,vec3 o,float s,vec4 mcol,float t){\n ;float l=dot(N,sunDir)//sundir must be normalized\n #ifdef doAO\n ,shad=AO(p+N*.001,sunDir,s,t)//shadow\n #else\n ,shad=.5\n #endif\n #ifdef doSpec\n ;float v=dot(-d,N)\n ;vec3 cc=vec3(.6,.8,1)//diffused light. sky color, shorter wavelengths diffuse more\n ,lc=vec3(1,.8,.6)     //undiffused light, direct sun color, long wavelengths\n ;float cd=exp(-distance(o,p))\n ;vec3 R=reflect(d,N)\n ;float spcl=pow(sat(dot(R,sunDir)),10.)\n ,spcc=pow(max(.0,dot(R,-d)),1.+cd)*.25\n ;r=r*(cd*v*cc+shad*l*lc)+(cd*spcc*cc+shad*spcl*lc)*mcol.a\n #endif\n ;r=sat(r)\n ;return r;}\n#endif\n\n//i think THIS version of the shader solved all issues of normals, even normals with small epsilon?\n//by using a different dynamiceps close to the camera than faraway from the camera.\n//and by doing some epsilon twiddeling on the gradient itself.\n//i was tweaking this only to notice that e=0.1 is pretty much the best working value for the scenes scaling.\nvec3 ComputeNormal(vec3 pos, int material,float e){float d; e=eps;//=.1;\n  return vec3(gd(vec3(pos.x+e,pos.y  ,pos.z  ),d)-gd(vec3(pos.x-e,pos.y  ,pos.z  ),d)\n             ,gd(vec3(pos.x  ,pos.y+e,pos.z  ),d)-gd(vec3(pos.x  ,pos.y-e,pos.z  ),d)\n             ,gd(vec3(pos.x  ,pos.y  ,pos.z+e),d)-gd(vec3(pos.x  ,pos.y  ,pos.z-e),d));}\n\n//RayMarch() seems broken in this context. maybe its a scaling thing\n//RayMarch() gets copied into others... () piece by piece...\n//\n//the raimarch loop gets complicated\n//, with  \"reflections till the horizon\" and \"dual dynamicEps\"\n/*dynamiceps Raymarching;\n- started with the idea of draining 2 pools, instead of one.\n- - Let [ee] be an epsilon that increments with each step\n     or that is = log(squaredDistanceToCamera/lastStelLength)\n- - there are 2 modes for epsilon increments.\n- - - the log(squared) mode is worse fror precision of reflections\n- - - the     squared  mode is worse for long distances.\n- - - we use [b] to switch between these modes.\n- - Let n be the distance to a surface, the gradient at p.\n- - maxDist-=ee/n; drains slower for many long steps, (substract normalized gradient)\n     This allows for much larger render distance (initial motivation for this)\n- - maxSteps-=ee*n; dains slower on many short step distances of near-parallel/orbital rays,.\n     This allows for smaller epsilon (secondary motivation for this)\n- - if(one of the pools is draind) assume that our epsilon is good enough.\n- - both pools drain speed (very likely) converges quickly.\n*/\n//main raymarching loop with maxDistance and MaxSteps and epsilon changed a bit.\n//if (hits a surface) reflect!\n//returns color of fragment.\n\n\n//-------------------------main renderer\n//[o]RayOrigin\n//[d]RayDirection\n//[s]ScatterNoise\n//[t]Age of photon (for lod supersampling)\nvec3 RayMarch2(vec3 o,vec3 d,float s){//origin,direction,scattering\n// return RayMarch(o,d);\n//[c]color, to be returned\n//[f]FragmentSpaceScaling, to blur rasterization, against moire;a=smoothstep(s,-s,a);\n//[t]TimeTraveled (implies division by speed of light) == distance to camera \n//[g]gradient, signed distance to surface.\n//[ao]Accumulate Occlusion, may just buffer the last step length\n//[ps]PushSmallest; ps=(g<f*t &&g <ao && ts.w<.0);\n//[ts]TimeSmallest    ,init: ts=vec4(-1 ), if(ps)store the 4 smallest [t>0] (abridged)\n//[gs]gradientSmallest,init: gs=vec4(1e6), if(ps)store the 4 smallest abs(g)\n;float t=0.;\n;float g=gd(o,t)*s*.5\n,tt=g,ao=1.\n    //it appears that tt ang t are conceptually very similar within this functiuon.\n    //but there may be cases where their difference matters.\n,f=2./min(iResolution.x,iResolution.y) //AntiAlias pixel size, of [2] pixels.\n;vec4 gs=vec4(1e6),ts=vec4(-1)//buffer 4 \"smallest values\"\n ;for(float i=.0;i<iterRm;i++\n ){//start.raymarch\n ;g=gd(o+d*tt,t)\n ;bool ps=all(lessThan(vec2(g,ts.w),vec2(min(f*tt,ao),0)))\n       //=(g<min(f*t,ao)&&ts.w<.0);\n       //=(g<f*t&&g<ao&&ts.w<.0);\n ;if(ps //PushSmall, we remember 4*2 smallest values for AO.\n ){gs=vec4(abs(g),gs.xyz)\n  ;ts=vec4(tt,ts.xyz);\n ;}\n ;tt+=g\n ;ao=g\n ;if(tt>zFar)break;//raymarch loop break\n   if(0.<log(g*g*eps/tt))break;  //https://www.shadertoy.com/results?query=logeps \n //;if(g<eps)break;//raymarch loop break\n \n ;}//end__.raymarch loop \n ;if(g<f*tt && g<gs.x){gs.x=g;ts.x=tt;}//one last PushSmall\n ;vec3 c=Backdrop(d)\n     //;return c;\n ;vec3 fcol=c\n ;for(int i=0;i<4;i++ //some AA supersampling shit in here?\n ){//ts and ps values get processed for \"occlusion\"\n  //oh looks like this is just nearSurface() surface stuff.      \n  ;if(ts.x<.0)break\n  ;float px=f*ts.x\n  ;vec3 so=o+d*ts.x\n  ;vec4 mcol=vec4(.0)\n  #define g3(a) vec3(gd1(so+a.xyy,mcol),gd1(so+a.yxy,mcol),gd1(so+a.yyx,mcol))\n  ;vec3 ve=vec3(px,0,0)\n  ;vec3 dp=g3(ve),dn=g3(-ve)//positive normal//negative normal\n  #ifndef doNormals \n  ;float d1=gd1(so,mcol)\n  ;vec3 N=(dp-dn)/(length(dp-vec3(d1))+length(vec3(d1)-dn))//HNF, normalized surface normal.\n  #else\n  ;vec3 N=normal(so,eps,t)*.5+.5\n   #endif\n  //above begs to be inversesqrt?\n  ;vec3 spc=mcol.rgb*0.14//specular set to material\n  #ifdef doShade\n  ;spc=SpecOcc(spc,d,N,so,o,s,mcol,t)\n  #endif\n        //near distance can skip fog.\n  #ifdef doFog\n  ;spc=fog(ts.x,spc,fcol);\n  #else \n  //;spc=fog(ts.x,spc,fcol);\n  #endif  \n  ;c=mix(spc,c,sat(gs.x/px))\n  ;gs=gs.yzwx;ts=ts.yzwx//rotate sampling matrix\n ;}\n//;if(c!=c)c=vec3(1,0,0);//if(NaN)\n;return sat(c*2.)\n;}\n\n\n//[A]RayOriginVR    (offset of the head within the scene)\n//[D]RayDirectionVR (looking direction of the head within the scene)\n/*\nthis is a VR raymarrching loop:\nit is actually a bit more straightforward.\nso why not use it?\n vec3 p=A;//p gets modified in this loop, and used after it, parallel to A\n for(int i=0;i<64;i++){//marching loop\n  if((abs(d)<.001)||(f>maxd))break;\n  f+=d;p=A+D*f;d=groundDistance(p,mat);}\n*/\n\n\n\n//set camera position and rotation. (and meybe some derivatives over time of these?\n//this gts buffered in the lower left fragments.\n//these then get loaded by each fragment to render a camera view.\nvoid steer(out vec4 o,vec2 u){//asll colision detection is in this function!\n;vec4 p,qrot\n;if(iFrame<2){//initialize camera parameters\n ;p=vec4(.1,0,0,.01)\n ;qrot=normalize(vec4(.1,.2,.3,.8));\n}else{//next frame\n ;p=load(0);qrot=load(1)//load state from previous frame\n ;vec3 fw=vec3(0,0,1)\n ;fw=qmulv(qrot,fw) //this can be done simpler\n ;vec3 newp=p.xyz+fw*p.w*.2\n ;float t=1.;\n ;if(gd(newp,t)>TOO_CLOSE)p.xyz=newp\n ;else\n  {if(gd(vec3(p.xy,newp.z),t)>TOO_CLOSE)p.z=newp.z;\n  ;if(gd(vec3(p.x,newp.y,p.z),t)>TOO_CLOSE)p.y=newp.y;\n  ;if(gd(vec3(newp.x,p.yz),t)>TOO_CLOSE)p.x=newp.x;//mkay every domain checked intependently\n }\n ;p.w+=THRUST*(key(UP_ARROW)-key(DOWN_ARROW));\n ;float roll=ROLL*(key(RIGHT_ARROW)-key(LEFT_ARROW));\n ;vec2 m=vec2(0)\n ;if(iMouse.z>.0\n ){\n  ;vec2 n=iMouse.xy-abs(iMouse.zw)\n  ;n.x=-n.x\n  ;m.xy-=(n)/iResolution.xy\n ;}\n #ifdef USE_AUTO_PILOT\n else{//I'm pretty sure this is how google cars steer\n  ;float d=gd(p.xyz)\n  ;newp=qmulv(qrot,vec3(d,0,0))\n  ;float d2=gd(p.xyz+newp)\n  ;m.x=sign(d2-d)*ROTATE/(.1+2.*d*d)\n ;}\n #endif\n ;vec4 qp=qpyr(vec3(m.yx*ROTATE,roll))\n ;qrot=normalize(qmulq(qrot,qp))//normalize before saving\n;}\n;store(0,p,o,u)//position,velocity\n;store(1,qrot,o,u)//rotation\n;}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//self  : https://www.shadertoy.com/view/4lscW2\n//parent: https://www.shadertoy.com/view/4td3Dj\n//many minor improvements. I twiddledand learned a few things\n//hard to describe your progress when you basically just try somewhat random ideas\n//and only let the apparently better ones progress.\n\n//the MAX_ limit range definitions only set upper bounds.\n//that are reached exponentially, so their size barely matters.\n//\n//MAX_SHADOW_REFLECTIONS sets how many reflections will have shadows calculated for them\n//#define MAX_SHADOW_REFLECTIONS 2.0\n//with 2.0, a reflection in a reflection has shadows in it. usually enough.\n//\n///MAX_DIST can easily be 1000000. but may crash in higher resolutions\n#define MAX_DIST          100.\n//note to self , with synamiceps log() , \"MAX_DIST\" changed its meaning \n// into something that is just not \"maximum distance\" of anything non fuzzyanymore.\n\n//MAX_STEPS can easily be 1000000. but may crash in higher resolutions\n#define MAX_STEPS         120.\n//MAX_HARD can be 200 to 2000, depending on hardware, but may crash in higher resolutions\n#define MAX_HARD  500\n//this is the absolute upper limit of steps per ray, including all its reflections.\n//the hardlimit is only reached in extreme cases, \n//like when the camera POSITION is already close to a surface!\n\n\n//every second pixel is skipped and left black. +20% more fps on older hardware?\n//#define doLazyDither\n//not worth it.\n\n\n/*\nThis revision adds 2 LOD modes to how it approaches the surface of a gradient.\nIn a sense, this makes it similar to heavily mixing 2 LOD renders of \"spyro the dragon\"; .\n Close distance has epsilon increase over     distance² , good for mirror, bad for horizon\n Far   distance has epsilon increase over log(distance²), too much distortion for mirrors\nA lot of twiddilng is involved to make the 2 \"overlap\" nicely.\n \"overlap\" in the sense that, a ray may bounce 5 times,\n  and all accumulating precision errors of many rough estimates must be kept small.\n*/\n\n/*\nhard bugs:\n distance to sinusoidial floow is not lipschitz continuousö\n maybe add any texturing to this bland method-demo.\n It could need more parameters to the shadow function \n  to make it look better close up than a far.\n I have incomplete plans to include [Cauchy distribution] \n  to move shadowSamlingPoints closer to the camera.\n \n Not sure why, but shadertoy makes the color depth in reflections within reflections \n  look a lot lower than other boilerplates.\n this is likely a precision issue, unlikely a conversion error.\n*/\n\n\n/*\n Older notes from the parent version:\n\n by ollj\n goal is to allow for high render distance and high detail close to the camera\n goal is to allow for hall of mirror reflections for as long as there are steps left, \n  scatterable non-fake reflections.\n goal is to see the shadow in the reflection of a revflection of a reflection...\n goal is to have any fragment converge in the same linear time\n  where closer surfaces simply get more detail/reflections.\n Idealy a top down perspective gets the same fps than a set with an infinite horizon!\n practically, there is still a difference of 60to5 fps, but i am slowly getting to 40to40; ..\n Ambient Occlusion calculatons are draining most resources.\n\nBelow methods causes raymarching to converge more linearily\n for many very different fragments of very different scenes\n  While it also \"warps space\" towards the ray, the more steps have been taken.\n Surfaces close to the camera have low epsilon, high precision, lots of reflections.\n Surfaces far from the camera have less precision, less reflections, higher epsilon\n Surfaces/hallways that are nearrly coplanar to a ray \n  no longer have the problem of \"running out oof steps\" AT ALL.\n\nLONG RENDER DISTANCE;\nHeuristic root solving either converges too slowly or too quickly.\nif (converges too quickly) you could have more detail == larger distances instead.\nIdeally you want to modify them so that all possible cases converge roughly equally.\nThis is achieved by defining MAX_DIST and MAX_STEPS as non-static float pools\n that diminish with each raymarchng step,\nIf (any pool drains below 0) the raymarching ends before MAX_HARD iterations.\n heuristic root solving is eigher likely [too divergend] or [converging too slowly]\n these 2 extremes are constrained by draining MAX_DIST and MAX_STEPS.\nDoing many small steps drains the 2 pools reciprocally-DIFFERENTLY from, the other \n than doing many large steps!\nBoth with one (reciprocal) factor, both pools converge \"much more equally\" \n depending on \"scene openness\" because they drain by the same factor.\n\nRECURSIVE REFLECTION;\nIf (a ray hits a reflective wall) it keeps raymarching a bounched ray.\n The loop sums up a total color as sum of all reflected rays.\nA reflected ray makes up a smaller fraction of the total color.\nIf (that fraction is too small) no morere flecting of this ray happens,\nFinally, the last reflected fraction of a color is added; \n if (we run out of steps) that is \"sky\" or \"ground\" color.\nTodo, make that =mix(SkyOrGroundColor,gradientColor,reasonablyScaledDistanceToGradient)\n\nBALLACHE OF PRECISION\n (nearby) reflections need high precision of they distort too much.\n DynamicEps methods insist on low precision, tent to be very \"noisy\"\n Depending on a points distance to camera, \n  it use a differet (conditions) to determine if (a point is near a surface).\n p+=SurfaceNormal; is a necessary compromise between fast and good recursive reflections.\n*/\n\n\n\n//i lost my latest cleaned up iprved version of this, \n//leaving us with this older messier version.\n\n//the ugliest thing here is that,\n//if a reflected ray runs out of steps/distance, it aborts\n//meaning it is the last reflection\n//but without dithering this looks a bit ugly\n//\n//in other versions i added fake dithering by modifying RayDirection by +=0.001\n//for each step.\n//this warps space a bit (speudo randomly), which is still fine, we call this \"gravity\" , ya know?\n\n//the main trick here is that some cases are better for (nearby) reflections \n//while others are better for ling distance surfaces.\n//and all combinations can be made almost linearily convergent.\n//the problem here is that it only starts to look good \n//with at least 500 itterations of raymarchoing\n//too much for the average 2014 hardware in useful resolutions/framerates\n\n\nfloat gd1(in vec3 position, out int mtl){\n    float radial=length(vec2(position.x,position.z));\n\tfloat radialSine=sin(radial*.05-time*2.)*5.;\n    float gndDistance=position.y-radialSine+6.;\n    float bldDistance=BuildingsDistance(position);\n    float dsd=deathstar(position*.1)*10.;\n    float redDistance=RedDistance      (position);\n                       float closest=gndDistance;mtl=   GROUND_MTL;\n    if (bldDistance<closest){closest=bldDistance;mtl=BUILDINGS_MTL;}\n    if (dsd        <closest){closest=dsd;mtl=RED_MTL      ;}\n    if (redDistance<closest){closest=redDistance;mtl=      RED_MTL;}\n    \n   \n    return closest;}\n//end of sdf geometry;\n\n\n\n//distance fog is no longer needed, is a relict here.\nvoid applyFog( in float distance, inout vec3 rgb ){\n    //float fogAmount = (1.0 - clamp(distance*0.0015,0.0,1.0) );\n    //float fogAmount = exp( -distance* 0.006 );\n    //vec3 fogColor = vec3(0.9,0.95,1);\n    //if(fogAmount<.6)rgb= vec3(1.,1.,0.);\n    //else rgb=clamp(rgb,0.,1.);\n    //rgb=mix(skyColor,rgb,fogAmount);\n}\n//this is based on old code, with inefficient material handling:\nvec3 MaterialColor(int mtl){\n    if(mtl==      SKY_MTL) return skyColor;\n    if(mtl==BUILDINGS_MTL) return buildingsColor;\n    if(mtl==   GROUND_MTL) return groundColor;\n    if(mtl==      RED_MTL) return redColor;\n    return vec3(1.0,1.0,1.0);}\n\n//i think THIS version of the shader solved all issues of normals, even normals with small epsilon?\n//by using a different dynamiceps close to the camera than faraway from the camera.\n//and by doing some epsilon twiddeling on the gradient itself.\n//i was tweaking this only to notice that e=0.1 is pretty much the best working value for the scenes scaling.\nvec3 ComputeNormal2(vec3 pos, int material,float ep){int d;float e=.1;\n  return vec3(gd1(vec3(pos.x+e,pos.y  ,pos.z  ),d)-gd1(vec3(pos.x-e,pos.y  ,pos.z  ),d)\n             ,gd1(vec3(pos.x  ,pos.y+e,pos.z  ),d)-gd1(vec3(pos.x  ,pos.y-e,pos.z  ),d)\n             ,gd1(vec3(pos.x  ,pos.y  ,pos.z+e),d)-gd1(vec3(pos.x  ,pos.y  ,pos.z-e),d));}\n\n\n//i fucked up the scaling of the ao implementatioin here.\nfloat AmbientOcclusion(vec3 p,vec3 n,float d,float s){float r=1.;int t;\n  for(int i=0;i<5;++i){if(--s<0.)break;r-=(s*d-(gd1(p+n*s*d,t)))/pow(2.,s);}return r;}\n \n\n\n//if (near surface) do surface things\n//[p]Position [d]RayDirection [c]colorAccumulator [e]epsilon [m]materialID \n//[s]shadowReflections \n//this function gets a LOT of revision.\n//it was tricky to seperate it from the loop that it is in, to more easily modify it.\n//this is all about making code easier to edit, and not about fast parsing.\nvec3 onSurface(inout vec3 p,inout vec3 d,vec3 c,\n    int m, float e,inout float s,inout float sg){\n;vec3 n=ComputeNormal(p,m,e);n=normalize(n)\n;vec3 col=MaterialColor(m)\n;if(s>.0//if we stil calculate shadows (for this reflection)\n){vec3 lightpos = vec3(250.*sin(time*.005), 400.+40.*cos(time*.002),250.*cos(time*.005))\n ;lightpos=lightpos-p;vec3 lightVector=normalize(lightpos)\n ;float lightdist=length(lightpos);\n ;p+=n;\n    //this is important for good reflections but \n    // it has side effects:\n    //the gradient is measured with the same offset from surface (good)\n    //the reflection happens at that offset, which leads to a [fold] of reflection space!\n    // and to a \"holographic mirror\"\n    //as if the surface has a thickness of +1.\n    //which is not too useful for fract(), adding differentials of -1 to compensate.\n ;float shadow = SoftShadow(p, lightVector, 0.3, lightdist,shadowHardness)\n #ifdef doOcclusionShaddow\n ;if(m==BUILDINGS_MTL){col=mix(shadowColor,col,sat(p.y/7.));}\n ;float attenuation=sat(dot(n,lightVector))\n ;shadow=min(shadow,attenuation);col=mix(shadowColor,col,shadow)\n #endif\n #ifdef doOcclusionAmbient\n ;float AO=AmbientOcclusion(p,n,1.,9.);col=mix(shadowColor,col,AO)\n #endif\n ;s--;}\n      float refl=.34;//surface reflectiveness\n      if (m==GROUND_MTL)refl=.3;//ground has other reflectiveness\n      c=mix(c,col,sg);//mix the color of the current ray (reflection) with the accumulated total color to be returned.\n      sg=sg*refl;if(sg<.01)return c;\n      d=d-(n*1.5*(dot(d,n)));//direction gets reflected at surface normal. \n        //*1.5 factor means we WILL likely overstp within reflections, accumulatively for each reflection.\n        //this is a reasonable fps booster for less quality in reflections.\n return c;\n}\n\n\n\n\n\n\n\n\n\n//if (near surface) do surface things\n//[p]Position [d]RayDirection [c]colorAccumulator [e]epsilon [m]materialID \n//[s]shadowReflections \n//this function gets a LOT of revision.\n//it was tricky to seperate it from the loop that it is in, to more easily modify it.\n//this is all about making code easier to edit, and not about fast parsing.\nvec3 onSurface(inout vec3 p,inout vec3 d,vec3 c,\n    int m, float e,inout float s,     inout float sg   ,float t ){\n    vec3 n=ComputeNormal(p,m,e);n=normalize(n);\n      vec3 col=vec3(.5);//MaterialColor(m);\n      if(s>.0){//if we stil calculate shadows (for this reflection)\n\t\tvec3 lightpos = vec3(250.0*sin(time*.005), 400.0 + 40.0 *cos(time*.002), 250.0*cos(time*.005));\n        lightpos=lightpos-p;vec3 lightVector=normalize(lightpos);float lightdist=length(lightpos);\n     p+=n;//this is important for good reflections but \n    // it has side effects:\n    //the gradient is measured with the same offset from surface (good)\n    //the reflection happens at that offset, which leads to a [fold] of reflection space!\n    // and to a \"holographic mirror\"\n    //as if the surface has a thickness of +1.\n    //which is not too useful for fract(), adding differentials of -1 to compensate.\n        float shadow = SoftShadow(p, lightVector, 0.3, lightdist,shadowHardness);    \n        #ifdef doOcclusionShaddow\n        if(m==BUILDINGS_MTL){col=mix(shadowColor,col,sat(p.y/7.));}\n\t\tfloat attenuation=sat(dot(n,lightVector));\n\t\tshadow=min(shadow,attenuation);col=mix(shadowColor,col,shadow);\n        #endif\n        #ifdef doOcclusionAmbient\n        float AO=AmbientOcclusion(p,n,1.,7.);col=mix(shadowColor,col,AO);\n        #endif\n         s--;}\n      float refl=.34;//surface reflectiveness\n      if (m==GROUND_MTL)refl=.3;//ground has other reflectiveness\n      c=mix(c,col,sg);//mix the color of the current ray (reflection) with the accumulated total color to be returned.\n      sg=sg*refl;if(sg<.01)return c;\n      d=d-(n*1.5*(dot(d,n)));//direction gets reflected at surface normal. \n        //*1.5 factor means we WILL likely overstp within reflections, accumulatively for each reflection.\n        //this is a reasonable fps booster for less quality in reflections.\n return c;\n}\n\n\n\n\n\n\nvec3 RayMarch5(vec3 o,vec3 t)\n{int mtl=0\n;vec3 hitColor\n;vec3 r;\n  float sg=1.;\n  float n= 1.;\n  float s=MAX_SHADOW_REFLECTIONS;\n  float maxDist =MAX_DIST;\n  float maxSteps=MAX_STEPS;\n  #ifndef DynamicEpsLog\n    maxSteps*=4.;//simpler steps, but more steps\n  #endif\n  int hardLimit =MAX_HARD;\n  float e     =.01;\n //main raymardching loop accumulates a color. can do so over many reflections.\n //the maximum number of sphere-tracking steps is MAX_HARD;\n //the maximum number of reflections is MAX_HARD;\n //the maximum number of surfaces that get shadow and AO calculated for them is MAX_SHADOW_REFLECTIONS\n //because AO is an inner lop, and it makes sense to constrain the O(n*m) compleity\n //by limiting m<=MAX_SHADOW_REFLECTIONS, with n==MAX_HARD;\n for(int ever=0;ever<MAX_HARD;ever++){//the ride (n)ever ends! unless [hardlimit<0] triggers a return. this lets me drain hardlöimit in the loop-\n    n=gd1(o,mtl);\n   float ee=mad(n,.00001,e*1.0001);\n   float l=dot(o,o);\n   o+=t*n;\n   bool b=l<MAX_DIST;//could be =sqrt(l)*2.<MAX_DIST; makes not much of a difference.here\n   if(b)e=ee;               //for long view distance\n   if(b)b=.0<log(l/n*1e-6);//for long view distance\n   else b=n+.5<e*70.;      //for better close up shadows (+<.6 for sharper corners)\n   if(b){hardLimit--;r=onSurface(o,t,r,mtl,e,s,sg);}\n   maxSteps -=ee*n;\n   maxDist  -=ee/n;\n//i am sure this can be improved a lot. but benchmarking this on different scenes takes time.\n//and i lack the theoretical undertanding to model many cases to an optimum.\t\n      if(\n         maxSteps<0.1\n       ||maxDist<=0.\n       ||hardLimit<=0\n      ){\n\t   return mix(r,skyColor,sg);//overwrite horizon noise with sky\n}\n    \n  }\n    //there are some rays that needed more than MAX_HARD steps\n    //but also never exhausted any countdown.\n    //ths hints at lipschitz discontinuity, likely due to fisheye lens transform.\n    //evaluating rays that got lost in discontinuities is never pretty.\n    //trying my best here\n    //return vec3(3);//highlight what never got near a surface\n    r=onSurface(o,t,r,mtl,e,s,sg);\n    return mix(r,skyColor,sg);//overwrite horizon noise with sky\n;}\n\n\n\n///by replacing mainImage() with the below, you can turn a non vr shader into a VR shader\n//and steer() is half decent quaternion-camera controls.\n\n\nvec4 mainImage2(out vec4 o, in vec2 u,vec3 A,vec3 D){\n vec3 d=normalize(vec3((2.0*u-iResolution.xy)/iResolution.y,1.0));\n vec3 l=load(0).xyz;\n vec4 fw=(load(1));//poaded camera position and camera rotation\n //   \n //no, this part below doesnt make sense to me.\n //instead i just overwrite the VR-headset-position and -rotation\n //its simpler and more compatible with non-vr\n #ifdef doVr \n //t=qmulv(fw,A);\n #else\n d=qmulv(fw,d);\n #endif\n //t=qmulv(D,t);//am i doing this right? //2022 me, 5 years later, apparently this is all correct.\n //ro=eye;\n  ;d=normalize(d);\n float s=h12(u);\n   // l.y+=1.;\n #if Scene==3\n return vec4(RayMarch5(l,d),1); //reflective\n #else\n return vec4(RayMarch2(l,d,s),1); //non reflective\n #endif\n}\n\n//shitty VR ignores [A]=HeadSetOrigin and [d]=HeadSetDirection\n//you can only move your view with keyboard and mouse.\nvoid mainImage3(out vec4 o,vec2 u,in vec3 A,in vec3 D){\n;if(all(lessThan(u,vec2(2.5,1.5))))steer(o,u) ;else //update seering (camera properties)\n o=mainImage2(o,u,A,D); }                           //update image segment\n//Outoput,Uv,[A]=RayOrigin,[D]=RayDirection\nvoid mainVR(out vec4 o,in vec2 u,in vec3 a,in vec3 d){\n ;if(all(lessThan(u,vec2(2.5,1.5))))steer(o,u) ;else //update seering (camera properties)\n mainImage3(o,u,a,d);                                //update image segment\n;}\n\n//mainimage translates a camera to map that to ONE vr cam.     \nvoid mainImage(out vec4 O,in vec2 U){\n const vec3 cameraPos=vec3(0);//camPos is simple offset\n const float rad=360./acos(-1.),dar=acos(-1.)/180.;\n vec2 m=u2(iMouse.xy/iResolution.xy); \n m=PI*mix(vec2(1.-m.x,m.y*.35),vec2(1,0),step(iMouse.z,.0));\n vec2 fov=vec2(25.);fov.x=atan(tan(fov.y/rad)*iResolution.x/iResolution.y)*rad;\n mat3 cam;\n cam[0]=vec3(cos(m.x),0,sin(m.x));//camera.right\n m.x=m.x+PI*.5;\n cam[1]=vec3(cos(m.x)*cos(m.y),sin(m.y),sin(m.x)*cos(m.y));//cameraFwd\n //cam[2]=-cross(cam[0],cam[1]));//camUp\n fov=(2.*U/iResolution.xy-1.)*sin(fov*dar)/sin(PI*.5-fov*dar);\n cam[0]=cameraPos-cam[1]+fov.x*cam[0]-fov.y*cross(cam[0],cam[1]);\n cam[1]=normalize(cam[0]-cameraPos);\n // scene is accidentally backwards, ugh\n cam[1]*=vec3(-1,1,-1);cam[0]*=vec3(-1,1,-1);\n mainVR(O,U,cam[0],cam[1])\n;}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}