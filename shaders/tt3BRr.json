{
    "Shader": {
        "info": {
            "date": "1612175237",
            "description": "For iterative rendering (e.g. path-tracing), better to adapt the cost per frame to the user computer ability.\nEasy: see end of  buffA ( illustrated with shader [url]https://shadertoy.com/view/wt2BRK[/url] )\nLeft: proportion of computed pixels per frame.",
            "flags": 48,
            "hasliked": 0,
            "id": "tt3BRr",
            "likes": 5,
            "name": "tuto: adapt cost to computer2",
            "published": 3,
            "tags": [
                "pathtracing",
                "tuto",
                "adaptive"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 301
        },
        "renderpass": [
            {
                "code": "// example shader in buffA adapted from https://shadertoy.com/view/wt2BRK\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = texelFetch(iChannel0, ivec2(U),0);\n#if 0\n    for (float l=0.; l<10.; l++, U/=2.)          // interpolation at undefined places\n        if (O.a==0.) O = texture(iChannel0, U,l);\n#endif\n    O.a > 0. ? O /= O.a : O;                     // normalization \n    O = pow( O, vec4(1./2.2) );                  // to sRGB\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// example shader adapted from https://shadertoy.com/view/wt2BRK\n\n#define R        iResolution.xy\n#define hash(p)  fract(sin( (p)* vec2(12.9898, 78.233) ) * 43758.5453)\n#define rot(a)   mat2(cos(a+vec4(0,11,33,0)))\n\nvec4 f(vec2 U) {\n    U = ( 2.*U - R ) / R.y;                           // normalized centered coords\n    float time = .5, w = 2./R.y,                      // line width\n          t=1.,s,C, v=0.;\n    vec3  D = normalize(vec3(.2*U, -1)),              // ray direction\n          p = vec3(0,0,30), T,a,f,q;                  // marching point along ray \n    for ( ; v < 1e3 && t > 1e-4 ; v++ ) {\n        q = p, \n        q.yz *= rot(-.2),                             // rotations\n        q.xz *= rot(.3*time),\n        T = q,                                      \n        a = abs(T), C = max(a.x,max(a.y,T.z))-8.03;   // big cube\n                                                      // --- tubes\n        q = mod(q+1.,2.)-1.,                          // 3D tiling (staggered compare to cube)\n        t = min(length(q.xy),                         // cylinders in 3 directions\n            min(length(q.yz),                         // ( cross at middle of cells )\n                length(q.xz)))-w,\n                                                      // --- balls\n        f = fract(4e5*sin(ceil(T/2.)*mat3(1,2,3,4,5,6,7,8,9))), // random seed per cell\n        f *= .95+.05*sin(time*40.+63.*f.y),           // shake\n        q = mod(T,2.)-1.,                             // now consider stagered cells (small cubes)\n\n        t = max( t, C );                              // --- intersection with big cube\n\n        p += t*D;                                     // step forward = dist to obj\n    }\n    p.z -= 30.;  vec4 O = vec4( min(1., length(p)/1e3)) ; // exp(-min(1e9,length(p)/1e3)) );\n    O.a = step(0.,O.x);\n    return O;\n}\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = texelFetch(iChannel0, ivec2(U),0);\n    \n// === adapting cost to computer =================================================\n  {  // suggestion: do only for iFrame > 0 so as to start with first guess (if not excessive ).\n    vec4 S = texelFetch(iChannel0,ivec2(0),0);    // stored state\n    float p = iFrame<1 ? .1 : S.w;                // pixel (0,0).w stores the adaptive sampling rate\n    if (U==vec2(.5)) {                            // --- manage adaptive sampling rate\n        if  (R.x != S.x) p *=  (S*S).x/(R*R).x;   // brutal change at resolution change\n        else\n         // p *= .0164/iTimeDelta;                // adapt to target fps\n            p = mix(p, p*.0174/iTimeDelta, .1);   // adapt to target fps with relaxation ( to filter iTimeDelta fluctuations )\n        O = vec4(R.x,0,0,max(.001,p));\n        return;\n    } \n    if (R.x != S.x ) O=vec4(0);                   // reset image at resolution change\n    if (U.x<8.) { O = vec4(U.y/R.y < p,0,0,0); return; }   // demo: show samping on left\n  //vec2 C = fragCoord;                           // render proportion p of random pixels: no gain !\n    vec2 C = floor(U/vec2(4,8));                  // render proportion p of random warps\n    if ( fract( 1e4*sin(dot ( C +iTime, vec2(1,17.761))) ) > p ) \n         return;\n }\n// ===============================================================================        \n    \n    O += f(U+hash(iTime)-.5);                     // cumulate rendering with subpixel jittering\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}