{
    "Shader": {
        "info": {
            "date": "1659814360",
            "description": "procedural cat eye refined",
            "flags": 0,
            "hasliked": 0,
            "id": "NtccWN",
            "likes": 13,
            "name": "procedural cat eye mk2",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Artemis152",
            "viewed": 376
        },
        "renderpass": [
            {
                "code": "//dark mode\n//#define COOOOOL\n\n#define MAX_STEPS 100\n#define MAX_DIST 10.\n#define SURF_DIST 0.0023\n\n#define PI 3.141592\n\n//size 0 to 1\n#define SIZE .9\n//#define DIL 2\n#define BUMP 0.065\n\n//don't change\n#define CORNEA 0.5\n\n\nfloat rand(vec2 n) {     return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\nfloat box(vec3 p, float e)\n{\n    vec3 d = abs(p) - e;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat cust(vec3 p)\n{\n    return length(p) - .5;\n}\n\nvec3 pol2Cart(float rX, float rY, float d)\n{\n    return normalize(vec3(\n        sin(rX),\n        sin(rY),\n        cos(rX)\n    )) * d;\n}\n\nfloat eye(vec3 ro, vec3 rd)\n{\n    float dS, dO;\n    vec3 p;int it = 0;\n    for(; it < MAX_STEPS; it++)\n    {\n        p = ro + rd * dO;\n        p.x -= smoothstep(0.4, 0.8, p.x) * BUMP;\n        //dS = cust(p);\n        dS = sphere(p, 1.);\n                \n        dO += dS;\n                \n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    return dO;\n}\n\nfloat corneaDist(vec3 p)\n{\n    return max(sphere(p, 1.), (CORNEA - p.x \n//        - (smoothstep(0., 0.3, abs(1.-p.y)) + 1.) * 0.12\n    ));\n}\n\nfloat cornea(vec3 ro, vec3 rd, float bump, float d)\n{\n    float dS, dO;\n    vec3 p;int it = 0;\n    for(; it < MAX_STEPS; it++)\n    {\n        p = ro + rd * dO;\n        p.x -= smoothstep(0.4, 0.8, p.x) * BUMP;\n        //p.x = min(p.x, 0.);\n        p.x -= bump;\n        //dS = cust(p);\n        dS = corneaDist(p) * d;\n                \n        dO += dS;\n                \n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    //dO += texture(iChannel1, p.zy).r * 0.02;\n    return dO;\n}\n\n\nvec3 corneaNormal(vec3 p)\n{\n\tfloat d = corneaDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        corneaDist(p-e.xyy),\n        corneaDist(p-e.yxy),\n        corneaDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 eyeNormal(vec3 p)\n{\n\tfloat d = sphere(p, 1.);\n    vec2 e = vec2(.04, 0);\n    \n    vec3 n = d - vec3(\n        sphere(p-e.xyy, 1.),\n        sphere(p-e.yxy, 1.),\n        sphere(p-e.yyx, 1.));\n    \n    return normalize(n);\n}\n\nfloat shade(vec3 n)\n{\n    return dot(n, -normalize(vec3(-1.1,-1.,.5)));\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n\n//veins https://www.shadertoy.com/view/7l3cD4\n#define THIC 0.3\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat getLine(vec2 uv, vec2 offset, float rot)\n{\n    uv = rotate(uv, rot);\n    uv *= 20.;\n    uv += offset;\n    float n = noise(uv*vec2(.9, .4));\n    uv.y += n - .4;\n\n    float col = 1.0;\n    \n    if(abs(uv.y) > THIC)\n        col = 0.;\n        \n    col = smoothstep(THIC, -.1, abs(uv.y));\n        \n    return col;\n}\n\nfloat getVein(vec2 uv)\n{\n    uv *= PI/2.;\n    float f;\n    \n    for(int i = 0; i < 80; ++i)\n    {\n        float fi = float(i);\n        f += getLine(uv, vec2(.5 + fi, noise(fi) * 50. - 25.), (float(i*60))/PI / 2.);\n    }\n    \n    f = min(f, 1.);\n    \n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5* iResolution.xy) / iResolution.y;\n    \n    float zoom = 2.2;\n    \n    vec2 m = iMouse.xy / iResolution.xy * 10.;\n    if(iMouse.z < 0.)\n        m = vec2(1.2, -.8);\n        \n    \n    m.x += iTime / 8.;\n\n    vec3 ro = pol2Cart(m.x, -m.y - 1., 5.),\n         lookat = vec3(0.),\n         f = normalize(lookat - ro),\n         r = normalize(cross(vec3(0., 1., 0.), f)),\n         u = cross(f, r),\n         cc = ro + f * zoom,\n         i = cc + uv.x * r + uv.y * u,\n         rd = normalize(i - ro),\n         col;\n         \n    vec3 cubemap = texture(iChannel0, rd).xyz;\n\n    float d = eye(ro, rd);\n    //d = cornea(ro, rd, 0., 1.);\n    \n    if(d >= MAX_DIST)\n        col = cubemap;\n    else\n    {\n        vec3 p = ro + rd * d;\n        vec2 u = vec2(atan(p.y/p.z) * 3./PI, p.x) * 0.82;\n                \n        float corneaMask = smoothstep(0.5, 0.76, u.y);\n        \n        vec3 n = eyeNormal(p);\n        \n        float s = shade(n);\n        vec3 r = reflect(rd, n);\n        float fren = smoothstep(1.1, 0., -dot(n, rd)) * 0.07;\n        vec3 refl = texture(iChannel0, r).rgb;\n        \n        //iris\n        if(corneaMask > 0.)\n        {\n            float IOR = 1.44,\n                  DIL = sin(iTime / 1.) + PI;\n            \n            vec3 rdIn = refract(rd, n, 1./IOR);\n        \n            vec3 pEnter = p - n * SURF_DIST * 5.;\n            float dIn = cornea(pEnter, rdIn, 0., -1.);\n        \n            vec3 pE = pEnter + rdIn * dIn;\n            vec3 nExit = eyeNormal(pE);\n            \n            float px = pE.x;\n            \n            pE *= mix(1., 0.7, SIZE * SIZE);\n            \n            vec2 u2 = vec2(\n                length(pE.zy),\n                atan(pE.y, pE.z));\n                         \n            float d2 = DIL + DIL,\n                  od = 1. - d2,\n                  im = mix(map(u2.x * 0.78, d2, od, 0., 1.68), abs(u2.x * 0.78), 0.02);\n                  \n            u2.x = im + .4;\n            u2.y = abs(u2.y * 1.1) + PI;\n            //u2.y += .4;\n            \n            pE.z *= DIL;\n            pE.z += texture(iChannel3, pE.zy).g * 0.05 - + 0.05;\n                \n            col = texture(iChannel1, u2).rgb;\n            \n            float pupilMask = smoothstep(0.35, .4, length(pE.yz));\n            \n            col *= pupilMask;\n            //*IOR*1.2\n            vec3 rdOut = refract(rdIn*IOR*2., nExit, IOR);\n            \n            if(length(rdOut)==0.)\n            {\n                rdOut = reflect(rdIn, nExit);\n                col = mix(col, texture(iChannel0, rdOut).rgb * 0.6, 0.9);\n            }\n            \n            //s = shade(nExit);\n            \n            col *= corneaMask;\n            fren += corneaMask * fren * 6.;\n            fren = min(1., fren + (1.0 - pupilMask) * 0.1);\n        }\n        \n        //back\n        /*col += vec3(smoothstep(0.45, 0.55, 1.-u.y) * 0.8);\n        \n        float ven = getVein(u);\n        \n        vec3 blood = mix(vec3(.6, 0.1, .13) * ven, vec3(.4, 0.,0.), smoothstep(0.4, -.55, u.y));*/\n        \n        \n        #ifdef COOOOOL\n        vec3 ven = vec3(.6, 0.1, .13) * getVein(u);\n        #else\n        col += vec3(smoothstep(0.45, 0.55, 1.-u.y) * 0.8);\n        vec3 ven = mix(vec3(1.), vec3(.6, 0.1, .13), getVein(u));\n        #endif\n        \n        vec3 blood = mix(ven, vec3(.5, 0.,0.), smoothstep(0.4, -.35, u.y));\n        \n        col = mix(col, blood, smoothstep(0.39, 0.03, u.y));\n        col = mix(col, vec3(refl), fren);\n        col *= clamp(s*1.5, .7, 1.);\n        col = pow(col, vec3(0.8));\n        \n        col += vec3(pow(max(0., shade(r)), 64.));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}