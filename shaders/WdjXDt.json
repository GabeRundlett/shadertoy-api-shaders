{
    "Shader": {
        "info": {
            "date": "1555353739",
            "description": "First go at a tunnel with SDFs. fbm() makes it costly, but the surface looks nicer with the bumps. Turned out pretty spooky, thus the title of the shader :) Still have to learn about better variations of the paths and wall distortions... too repetitive.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdjXDt",
            "likes": 1,
            "name": "Visiting the alien hive ;)",
            "published": 3,
            "tags": [
                "3d",
                "tunnel",
                "sdf",
                "spooky"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 515
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Visiting the alien hive - Excersice in building and flying through a tunnel.\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 r2d (float deg) {\n    float r = radians (deg);\n    float c = cos (r);\n    float s = sin (r);\n    return mat2 (c, s, -s, c);\n}\n\nfloat smin (float d1, float d2, float k) {\n    float h = clamp (.5 + .5*(d2 - d1)/k, .0, 1.);\n    return mix (d2, d1, h) - h*k*(1. - h);\n}\n\n// pathVariation1() & pathVariation2() are two random functions meant to distort the\n// radius of an endless cylinder in order to create the rough shape of a tunnel/cave\nfloat pathVariation1 (vec3 p) {\n    float v = sin (p.x + p.y + p.z);\n    return sin (v) + cos (v*v);\n}\n\nfloat pathVariation2 (vec3 p) {\n    float v = sin (p.x * p.y - p.z);\n    return sin (v*v) + cos (v+v);\n}\n\n// hash(), noise(), fbm() are from an example by iq and/or Shane\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3. - 2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p ) {\n    float f;\n    mat2 m = r2d (1.1);\n\n    f  = .5*noise( p ); p.xz *= m*2.02;\n    f += .25*noise( p ); p.xy *= m*2.23;\n    f += .125*noise( p ); p.yz *= m*2.71;\n    f += .0625*noise( p );\n\n    return f;\n}\n\nfloat map (vec3 p) {\n    p.xy *= r2d (-6.*cos(iTime));\n    p.z += 4.*iTime;\n\n    float cyl1 = length (p.xy + .3*pathVariation1 (2.*p) + vec2 (-.5, .0)) - (.9 + .05*fbm(7.*p));\n    float cyl2 = length (p.xy + .2*pathVariation2 (3.*p) +vec2 (.5, .0)) - (1.1 + .075*fbm(8.*p));\n\n    float cyl = smin (cyl1, cyl2, .75);\n\n    float d = cyl;\n    return d;\n}\n\nfloat march (vec3 ro, vec3 rd) {\n    float t = .0;\n    float d = .0;\n    for (int i = 0; i < 48; ++i) {\n        t = map (ro+d*rd);\n        if (abs (t) < .0001*(1. + .126*t)) break;\n        d += t*.75;\n    }\n    return  d;\n}\n\nvec3 norm (vec3 p) {\n    float d = map (p);\n    vec2 e = vec2 (.001, .0);\n    return normalize (vec3 (map (p + e.xyy), map (p + e.yxy), map (p + e.yyx))  - d);\n}\n\n// hard shadows\nfloat sha (vec3 p, vec3 n, vec3 ldir, float ldist) {\n    float d2w = march (p  + .01*n, ldir);\n    return ldist < d2w ? 1. : .3;\n}\n\nvec3 shade (vec3 ro, vec3 rd, float d, vec3 p, vec3 n, vec3 lp, vec3 lc) {\n    vec3 mat = vec3 (.3);\n    vec3 am = vec3 (.05);\n    vec3 ldir = normalize (lp - p);\n    vec3 h = normalize (-rd + ldir);\n    float sp = pow (max (.0, dot (n, h)), 80.);\n    float ldist = distance (lp, p);\n    float s = sha (p, n, ldir, ldist);\n    float att = 3. / (ldist*ldist);\n    float li = 2.;\n    float diff = max (.0, dot (n, ldir));\n    return att*s*(am + diff*mat*li*lc + sp*vec3 (1.));\n}\n\nvec3 cam (vec2 uv, vec3 ro, vec3 aim, float z) {\n    vec3 f = normalize (aim - ro);\n    vec3 wu = vec3 (.0, 1., .0);\n    wu.xy *= r2d (65.*iTime);\n    vec3 r = normalize (cross (wu, f));\n    vec3 u = normalize (cross (f, r));\n    vec3 c = ro + f*z;\n    return normalize (c + r*uv.x + u*uv.y - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvRaw = uv;\n    uv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 1. + .5*length (uv);\n\n    vec3 ro = vec3 (-.3*cos (3.*iTime), .1*sin(3.*iTime), 2.);\n    vec3 aim = vec3 (.0);\n    float z = 1.5;\n    vec3 rd = cam (uv, ro, aim, z);\n    float d = march (ro, rd);\n    float fog = 1. / (1. + d*d*.1);\n    vec3 p = ro+d*rd;\n    vec3 n = -norm (p);\n    vec3 lp1 = vec3 (.0, .0, 2.);\n    vec3 lp2 = vec3 (.0, .0, 5.);\n    vec3 lp3 = vec3 (.0, .0, 7.);\n    vec3 lc1 = vec3 (.9, .8, .7);\n    vec3 lc2 = vec3 (.2, .3, .9);\n    vec3 lc3 = vec3 (.9, .3, .2);\n    vec3 col = shade (ro, rd, d, p, n, lp1, lc1);\n    col += shade (ro, rd, d, p, n, lp2, lc2);\n    col += shade (ro, rd, d, p, n, lp3, lc3);\n\n    ro = p +.01*n;\n    rd = normalize (reflect (rd, n));\n    d = march (ro, rd);\n    p = ro+d*rd;\n    n = -norm (p);\n\n    vec3 rcol = shade (ro, rd, d, p, n, lp1, lc1);\n    rcol += shade (ro, rd, d, p, n, lp2, lc2);\n    rcol += shade (ro, rd, d, p, n, lp3, lc3);\n    col += .5*rcol;\n\n    col *= fog;\n    col *= 1. - .25*length (uv);\n    col = col / (.76 + col*1.25);\n    col *= mix (1., .5, cos (500.*uvRaw.y));\n    col = sqrt (col);\n\n    fragColor = vec4 (col, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}