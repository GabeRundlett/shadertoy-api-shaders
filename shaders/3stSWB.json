{
    "Shader": {
        "info": {
            "date": "1572792926",
            "description": "Forever Faster",
            "flags": 32,
            "hasliked": 0,
            "id": "3stSWB",
            "likes": 9,
            "name": "Forever Faster",
            "published": 3,
            "tags": [
                "modeling",
                "raymerching",
                "puma"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 396
        },
        "renderpass": [
            {
                "code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define bend(p,k) mat2(cos(k*p.x),-sin(k*p.x),sin(k*p.x),cos(k*p.x))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCappedCylinder( vec3 p, float r, float h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdLink( in vec3 p, in float le, in float r1, in float r2 )\n{\n    vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nvec2 hash22(vec2 p) {\n    p = p*mat2(127.1,311.7,269.5,183.3);\n    p = -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n    return sin(p*6.283);\n}\n\nfloat perlin_noise(vec2 p) {\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    // interpolation\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    float f00 = dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0));\n    float f01 = dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0));\n    float f10 = dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0));\n    float f11 = dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0));\n    \n    // mixing top & bottom edges\n    float xm1 = mix(f00, f10, w.x);\n    float xm2 = mix(f01, f11, w.x);\n    \n    // mixing to point\n    float ym = mix(xm1, xm2, w.y); \n    \n    return ym;\n}\n\nfloat outSole(vec3 p) {\n    float _soleCut = p.y - .9;\n    \n    float defY = 1.1;\n    vec3 bp = p-vec3(1.1,defY,0.0);\n    vec3 bp2 = p-vec3(-1.1,defY,0.0);\n    \n    float sc = mix(2.8,2.1,smoothstep(-1.0,1.0,bp.x));\n    bp.z *= sc;\n\n    float cyl = sdCappedCylinder(bp, 0.2,1.55)/sc;\n    \n    float sc2 = mix(1.7,2.0,smoothstep(-1.0,1.0,bp2.x));\n    bp2.xyz *= matRotateY(radians(20.0));\n    bp2.z *= sc2;\n    \n    float cyl2 = sdCappedCylinder(bp2, 0.2,1.35);\n    float _soleCut2 = p.y - 1.3;\n\n    return max(max(-_soleCut,smin(cyl*0.9,cyl2*0.9,0.5)),_soleCut2);\n}\n\nfloat outSole2(vec3 p) {\n    float _soleCut = p.y - 0.95;\n    float _soleCut2 = p.y - 1.5;\n    \n    vec3 bp = p-vec3(1.2,1.1,0.0);\n    \n    float sc = mix(2.0,1.8,smoothstep(-1.0,1.0,bp.x));\n    bp.z *= sc;\n    \n    float box = sdCappedCylinder(bp, 0.26,1.3)/sc;\n\n    return max(max(-_soleCut,box*0.9),_soleCut2);\n}\n\nfloat upper(vec3 p) {\n    float _upperCut = p.y - 1.3;\n    float _upperCut2 = p.y - 1.2;\n    \n    float y = 0.35;\n    vec3 bp = p-vec3(1.,1.3+y,0.0);\n    vec3 bp2 = p-vec3(-0.5,1.3+y,0.0);\n    \n    float sc = mix(3.0,1.6,smoothstep(-1.0,1.0,bp.x));\n    float scb = mix(1.8,0.75,smoothstep(-1.0,1.0,bp.x));\n    float scc = mix(0.8,1.1,smoothstep(-1.0,1.0,bp.y));\n    bp.z *= sc;\n    bp.y *= scb;\n    bp.x *= scc;\n    \n    float cyl = sdCappedCylinder(bp, 0.75,1.2)/sc;\n    float _cyl = sdCappedCylinder(bp+vec3(-0.2,-0.4,0.0), 0.8,0.9)/sc;\n    \n    float sc2 = mix(1.3,1.6,smoothstep(-1.0,1.0,bp2.x));\n    bp2.xyz *= matRotateY(radians(10.0))*matRotateZ(radians(-15.0));\n    bp2.z *= sc2;\n    \n    // bending upper portion\n    mat2  m = bend(bp2,0.3);\n    vec3  q = vec3(m*bp2.xy,bp2.z);\n    \n    float cyl2 = sdEllipsoid(q, vec3(1.6,0.7,1.1));\n    float _cyl2 = sdEllipsoid((bp2-vec3(1.2,0.4,0.18))*matRotateY(radians(-8.0)), vec3(1.4,0.88,0.6));\n\n    return  max(-_cyl2*0.5,max(-_cyl*0.6,max(-_upperCut,smin(cyl*0.9,cyl2*0.9,0.6))));\n}\n\n\nfloat toeCap(vec3 p) {\n    \n    float _capCut2 = p.y - 1.2;\n    \n    float y = 0.45;\n    vec3 bp2 = p-vec3(-0.6,1.3+y,0.0);\n    \n    float sc2 = mix(1.3,1.6,smoothstep(-1.0,1.0,bp2.x));\n    bp2.xyz *= matRotateY(radians(10.0))*matRotateZ(radians(-15.0));\n    bp2.z *= sc2;\n    \n    // bending upper portion\n    mat2  m = bend(bp2,0.3);\n    vec3  q = vec3(m*bp2.xy,bp2.z);\n    \n    float cyl2 = sdEllipsoid(q+vec3(0.0,0.05,0.0), vec3(1.53,0.7,1.2));\n    float _cyl2 = sdEllipsoid((bp2-vec3(0.9,0.5,0.2))*matRotateY(radians(-30.0)), vec3(1.9,1.2,1.75));\n\n    p*=matRotateZ(radians(-85.0));\n    float _capCut = p.y - 1.1;\n    \n    return  max(-_capCut,max(-_cyl2,max(-_capCut2,cyl2*0.9)));\n}\n\nfloat Tan(vec3 p) {\n    vec3 bp = p-vec3(0.05,2.6,-0.05);\n    bp*= matRotateZ(radians(-25.0))*matRotateY(radians(93.0));\n    \n    mat2  m =  bend(bp,3.0);\n    bp.xy*=m;\n    \n    float b = sdBox(bp,vec3(0.5,0.05,0.9))-0.05;\n    return b*0.6;\n}\n\nfloat stripe(vec3 p) {\n    float thickness = 0.02;\n    float cut = p.y - 1.35;\n    float z = 0.0;\n    vec3 bp = (p-vec3(0.0,1.6,z))*matRotateZ(radians(-50.0));\n    float sc = mix(0.6,3.5,smoothstep(-1.0,1.0,bp.x));\n    bp.y *= sc;\n    \n    mat2  m =  bend(bp,1.5);\n    bp.xy*=m;\n        \n    vec3 bp2 = (p-vec3(1.42,1.91,z));\n    float sc2 = mix(0.95,2.5,smoothstep(-1.0,1.0,bp2.x));\n    bp2.y*=sc2;\n    \n    float b = sdBox(bp,vec3(0.9,0.6,thickness))-0.05;\n    float b2 = sdBox(bp2,vec3(0.9,0.195,thickness))-0.05;\n    return min(max(-cut,b*0.5),b2);\n}\n\nfloat shoeRaces(vec3 p) {\n    vec3 pref = p;\n    pref*= matRotateX(radians(-2.0));\n    float cut = pref.y - 2.49;\n    vec3 bp = p-vec3(0.0,2.3,0.0);\n    bp *= (matRotateY(radians(93.0))*matRotateZ(radians(90.0)))*matRotateY(radians(-10.0));\n    float l = sdLink(bp, 0.15,0.2,0.07);\n    \n    bp = p-vec3(0.3,2.42,-0.02);\n    bp *= (matRotateY(radians(93.0))*matRotateZ(radians(90.0)))*matRotateY(radians(-10.0));\n    float l2 = sdLink(bp, 0.17,0.2,0.07);\n    \n    bp = p-vec3(0.6,2.55,-0.04);\n    bp *= (matRotateY(radians(93.0))*matRotateZ(radians(90.0)))*matRotateY(radians(-10.0));\n    float l3 = sdLink(bp, 0.17,0.2,0.07);\n\n    bp = p-vec3(0.9,2.6,-0.06);\n    bp *= (matRotateY(radians(93.0))*matRotateZ(radians(90.0)))*matRotateY(radians(-10.0));\n    float l4 = sdLink(bp, 0.13,0.25,0.07);\n    \n    return max(-cut,min(l4,min(l3,min(l,l2))));\n}\n\nvec4 GetDist(vec3 p) {\n    \n    p = (p+vec3(0.0,0.8,0.0))*matRotateZ(radians(-15.0));\n    vec3 pref = p;\n    vec3 pref2 = p;\n    float cut = p.y-0.95;\n    \n    pref*=matRotateZ(radians(17.0));\n    float cut2 = pref.y-0.7;\n    pref = p;\n    pref*=matRotateZ(radians(22.5));\n    float cut3 = pref.y-0.52;\n    \n    mat2  m = bend(p,0.085);\n    vec3  q = vec3(m*p.xy,p.z);\n    \n    float osole = outSole(q);\n    float osole2 = outSole2(p);\n    float upper = upper(p)-0.02;\n    float t = Tan(p);\n    float tc = toeCap(p);\n    \n    vec3 stripeP = (p-vec3(-0.05,-0.01,0.65));\n    m =  bend(stripeP,-0.09);\n    stripeP.xz*= m;\n    float stp = stripe(stripeP*matRotateY(radians(11.0))*matRotateZ(radians(-5.0)))*0.5;\n    \n    vec3 stripeP2 = (p-vec3(-0.05,-0.01,-0.73));\n    m =  bend(stripeP2,0.02);\n    stripeP2.xz*= m;\n    float stp2 = stripe(stripeP2*matRotateY(radians(-6.5))*matRotateZ(radians(-5.0)))*0.5;\n    \n    float osoleDist = max(-cut3,max(-cut2,max(-cut,smin(osole,osole2,0.2))));\n    float sr = shoeRaces(p+vec3(0.4,0.0,0.0));\n    \n    vec3 tanGrad = mix(vec3(0.8),vec3(0.7,0.9,1.0),smoothstep(-3.0,1.0,pref.x));\n    vec3 stripeGrad = mix(vec3(1.0,0.6,0.0),vec3(1.0,0.9,0.3),smoothstep(-3.0,1.0,pref.x));\n    \n    pref.x-= iTime*0.5;\n    pref2.x-= iTime*0.8;\n    float n = perlin_noise(pref2.xz*8.0)*0.7;\n    float n2 = perlin_noise(p.xz*3.0);\n    vec3 upperCol = vec3(0.7,0.9,1.0);\n    upperCol += n;\n    \n    float uvSc = 2.0;\n    pref *= uvSc;\n    pref.xz *= Rot(radians(90.0));\n    pref.x = mod(pref.x,1.1);\n    pref.z = mod(pref.z,0.8);\n    \n    \n    vec3 logoTex = texture(iChannel0,pref.xz).xyz*1.1;\n    vec4 osoleRes = vec4(vec3(0.9),osoleDist);\n    vec4 upperRes = vec4(upperCol*vec3(0.7,0.9,1.0)*logoTex,upper);\n    vec4 tanRes = vec4(tanGrad,t);\n    vec4 stpRes = vec4(stripeGrad,stp);\n    vec4 stp2Res = vec4(stripeGrad,stp2);\n    vec4 race2Res = vec4(vec3(0.5,0.7,1.0),sr);\n    vec4 tcRes = vec4(vec3(0.5,0.7,1.0)+n2,tc);\n    \n    vec4 model = combine(osoleRes,combine(combine(upperRes,tcRes),combine(tanRes,combine(stpRes,combine(stp2Res,race2Res)))));\n\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nfloat GetAmbientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - RayMarch(p + n*d,n).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,8,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n\n    float ao = GetAmbientOcclusion(p,n);\n    \n    float lambert = max(.0, dot( n, l))*0.1;\n    \n    return lambert+dif*ao;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // scan effect\n    float scanline = fract(iTime/3.5)*2.0;\n    float scany = uv.y - 1.0 + scanline;\n    uv.x += .001/scany;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.xz *= Rot(radians(iTime*20.0));\n    ro.yz *= Rot(radians(-20.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n    \n        float dif = GetLight(p);\n        col = vec3(dif)*d.xyz;\n        \n    } else {\n        // background\n        float d = abs(uv.y);\n        float k = 1. / d;\n        uv = uv * k + vec2(0, k);\n        \n        uv.y-= iTime*0.5;\n\n        uv.x = mod(uv.x,1.1);\n        uv.y = mod(uv.y,0.8);\n    \n        vec3 logoTex = texture(iChannel0,uv).xyz*1.5;\n\n        col += vec3(1.0,1.15,1.25);\n        \n        col *= d * d*2.5;\n        col *= logoTex;\n    }\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Generated with https://github.com/rkibria/img2shadertoy\nconst vec2 bitmap_size = vec2(64, 32);\nconst int[] palette = int[] (\n0x00000000,\n0x00ffffff,\n0x00fefefe,\n0x00fdfdfd,\n0x00fcfcfc,\n0x00f9f9f9,\n0x00f8f8f8,\n0x00f3f3f3,\n0x00f2f2f2,\n0x00ededed,\n0x00ececec,\n0x00ebebeb,\n0x00eaeaea,\n0x00e9e9e9,\n0x00e7e7e7,\n0x00e5e5e5,\n0x00e4e4e4,\n0x00e2e2e2,\n0x00e1e1e1,\n0x00dfdfdf,\n0x00dadada,\n0x00d9d9d9,\n0x00d8d8d8,\n0x00d7d7d7,\n0x00d6d6d6,\n0x00d5d5d5,\n0x00d1d1d1,\n0x00cecece,\n0x00cccccc,\n0x00cbcbcb,\n0x00cacaca,\n0x00c9c9c9,\n0x00c8c8c8,\n0x00c6c6c6,\n0x00c5c5c5,\n0x00c4c4c4,\n0x00c3c3c3,\n0x00c2c2c2,\n0x00c0c0c0,\n0x00bfbfbf,\n0x00bebebe,\n0x00bdbdbd,\n0x00bbbbbb,\n0x00bababa,\n0x00b9b9b9,\n0x00b8b8b8,\n0x00b7b7b7,\n0x00b6b6b6,\n0x00b5b5b5,\n0x00b4b4b4,\n0x00b3b3b3,\n0x00b2b2b2,\n0x00b1b1b1\n);\nconst int longs_per_line = 16;\nconst int[] bitmap = int[] (\n0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101,\n0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101,\n0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101,\n0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101,\n0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101,\n0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101,\n0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101,\n0x2e270101, 0x19192d2d, 0x01010101, 0x03010101, 0x2e2d2c1b, 0x2e2f2f2f, 0x05212b2e, 0x2d2e1b01, 0x01012e2d, 0x2e2d2e01, 0x0202052e, 0x2e2d2d2e, 0x2e1f0110, 0x1d2e2e2d, 0x2d2d0101, 0x0101292e,\n0x34330101, 0x1d1d3434, 0x01010101, 0x0b010101, 0x34343434, 0x34343434, 0x16343434, 0x34342201, 0x01013434, 0x34343401, 0x03030634, 0x34343434, 0x34280113, 0x26343434, 0x34340101, 0x01013434,\n0x342d0101, 0x1b1b3434, 0x01010101, 0x0f010101, 0x34343434, 0x34252727, 0x19343434, 0x34341e01, 0x01013434, 0x34343401, 0x03030534, 0x34343434, 0x34230111, 0x22343434, 0x34340101, 0x01012f34,\n0x342d0101, 0x1a1a3434, 0x01010101, 0x0e010101, 0x34343434, 0x34010101, 0x17343434, 0x34341e01, 0x01013434, 0x34343401, 0x03030534, 0x34343434, 0x34230111, 0x20343434, 0x34340101, 0x01012f34,\n0x342c0101, 0x34343434, 0x34343434, 0x0e011330, 0x34343434, 0x34010101, 0x17343434, 0x34341e01, 0x01013434, 0x34343401, 0x03030534, 0x34343434, 0x34230111, 0x34343434, 0x34343434, 0x01012f34,\n0x342c0101, 0x34343434, 0x34343434, 0x0e011330, 0x34343434, 0x34010101, 0x17343434, 0x34341e01, 0x01013434, 0x34343401, 0x03030534, 0x34343434, 0x34230111, 0x34343434, 0x34343434, 0x01012f34,\n0x342c0101, 0x34343434, 0x34343434, 0x0c012d34, 0x34343434, 0x34010101, 0x17343434, 0x34341d01, 0x01013434, 0x34343401, 0x03030534, 0x34343434, 0x34230111, 0x34343434, 0x34343434, 0x01012f34,\n0x342c0101, 0x01013434, 0x34343401, 0x0b012834, 0x34343434, 0x34010101, 0x17343434, 0x34341d01, 0x01013434, 0x34343401, 0x03030534, 0x34343434, 0x34220112, 0x22343434, 0x34340101, 0x01012f34,\n0x342c0101, 0x01013434, 0x34343401, 0x0b012834, 0x34343434, 0x34010101, 0x17343434, 0x34341d01, 0x01013434, 0x34343401, 0x03030534, 0x34343434, 0x34220112, 0x22343434, 0x34340101, 0x01012f34,\n0x342c0101, 0x01013434, 0x34343401, 0x0b012834, 0x34343434, 0x34010101, 0x18343434, 0x34341d01, 0x01013434, 0x34343401, 0x03030534, 0x34343434, 0x34220112, 0x24343434, 0x34340101, 0x01012f34,\n0x342c0101, 0x01013434, 0x34343401, 0x0b012834, 0x34343434, 0x34010101, 0x18343434, 0x34341d01, 0x01013434, 0x34343401, 0x04040534, 0x34343434, 0x34220112, 0x23343434, 0x34340101, 0x01012f34,\n0x342c0101, 0x01013434, 0x34343401, 0x0b012834, 0x34343434, 0x34010101, 0x18343434, 0x34341d01, 0x01013434, 0x34343401, 0x04040534, 0x34343434, 0x34220112, 0x23343434, 0x34340101, 0x01012f34,\n0x342b0101, 0x01013434, 0x34343401, 0x0b012834, 0x34343434, 0x34010101, 0x18343434, 0x34341d01, 0x01013434, 0x34343401, 0x04040534, 0x34343434, 0x34220112, 0x22343434, 0x34340101, 0x01012f34,\n0x342b0101, 0x01013434, 0x34343401, 0x0b012834, 0x34343434, 0x34010101, 0x18343434, 0x34341d01, 0x01013434, 0x34343401, 0x04040534, 0x34343434, 0x34220112, 0x22343434, 0x34340101, 0x01012f34,\n0x342b0101, 0x01013434, 0x34343401, 0x0b012834, 0x34343434, 0x34010101, 0x18343434, 0x34341d01, 0x01013434, 0x34343401, 0x04040534, 0x34343434, 0x34220112, 0x22343434, 0x34340101, 0x01012f34,\n0x342b0101, 0x01013434, 0x34343401, 0x0a012934, 0x34343434, 0x34010101, 0x18343434, 0x34341d01, 0x01013434, 0x34343401, 0x04040634, 0x34343434, 0x34220112, 0x25343434, 0x34341b1b, 0x01012f34,\n0x342b0101, 0x2f2f3434, 0x34343434, 0x09012b34, 0x34343434, 0x34010101, 0x19343434, 0x34341e01, 0x29343434, 0x34343430, 0x2a2a2b34, 0x34343434, 0x34240114, 0x34343434, 0x34343232, 0x01013134,\n0x34300101, 0x34343434, 0x34343434, 0x0d012a34, 0x34343434, 0x34010101, 0x1a343434, 0x34341c01, 0x34343434, 0x34343434, 0x34343434, 0x34343434, 0x3422010f, 0x34343434, 0x34343434, 0x01013234,\n0x2e260101, 0x2d2d2d2e, 0x2c2c2c2c, 0x0c010a27, 0x2e2e2e2f, 0x2c010101, 0x152c2b2c, 0x2f230701, 0x2e2e2e2e, 0x2d2d2d2d, 0x2c2c2c2d, 0x1b2c2c2c, 0x26080102, 0x2d2e2e2f, 0x2c2c2d2d, 0x01010f29,\n0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101,\n0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101,\n0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101,\n0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101,\n0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101,\n0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101\n);\n\nint getPaletteIndexXY(in ivec2 fetch_pos)\n{\n    int palette_index = 0;\n    if(fetch_pos.x >= 0 && fetch_pos.y >= 0\n        && fetch_pos.x < int(bitmap_size.x) && fetch_pos.y < int(bitmap_size.y))\n    {\n        int line_index = fetch_pos.y * longs_per_line;\n\n        int long_index = line_index + (fetch_pos.x >> 2);\n        int bitmap_long = bitmap[long_index];\n\n        int byte_index = fetch_pos.x & 0x03;\n        palette_index = (bitmap_long >> (byte_index << 3)) & 0xff;\n    }\n    return palette_index;\n}\n\n\nint getPaletteIndex(in vec2 uv) {\n    int palette_index = 0;\n    ivec2 fetch_pos = ivec2(uv * bitmap_size);\n    palette_index = getPaletteIndexXY(fetch_pos);\n    return palette_index;\n}\n\nvec4 getColorFromPalette(in int palette_index) {\n    int int_color = palette[palette_index];\n    return vec4(float(int_color & 0xff)/ 255.0,\n                float((int_color >> 8)& 0xff)/ 255.0,\n                float((int_color >> 16)& 0xff)/ 255.0,\n                0);\n}\n\nvec4 getBitmapColor(in vec2 uv) {\n    return getColorFromPalette(getPaletteIndex(uv));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    fragColor = getBitmapColor(uv)+vec4(vec3(0.0),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}