{
    "Shader": {
        "info": {
            "date": "1520685919",
            "description": "Smoothly combining a couple of gyroid objects with a perturbed cylinder to create a cheap lava-tube network. Low budget volumetric noise was added to create a little atmosphere.",
            "flags": 0,
            "hasliked": 0,
            "id": "4ddcWl",
            "likes": 37,
            "name": "Lava Tubes",
            "published": 3,
            "tags": [
                "raymarching",
                "tunnel",
                "volumetric",
                "translucency",
                "gyroid",
                "bumpmap"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1809
        },
        "renderpass": [
            {
                "code": "/*\n    Lava Tubes\n    ----------\n\n\tI put this together for fun, as a means to take a break from other things I'm trying \n\tto code at the moment. It's nothing exciting, just a glorified bump mapped tunnel.\t\n\n\tThe example was aimed toward the 800 by 450 window and built to accommodate mid-range \n\tsystems. I also procedurally textured the scene to keep Dr2 happy. :)\n\t\n\tI started with a perturbed cylindrical tunnel, combined it with a couple of gyroids, \n\tthen bump mapped a cellular surface onto it. It wasn't my intention to go for the \n\tlow-budget 80s sci-fi -- or late 90s demoscene -- look, but that's how it turned out. :) \n\tI'll put together a more sophisticated version at some point.\t\n    \n    Creating volumetric dust, vapor, etc, is simple enough in theory -- just accumulate\n    multiple layers of dust-like noise, then layer it onto to the scene in some way. In \n\tpractice, however, you're trying to do the best you can with just a few iteratios of \n\tcheap FBM noise -- usually consisting of just two value noise octaves. In this case, \n\tI've used 16 iterations of two-octave value-noise FBM, which means there are 32 3D\n\tvalue-noise calls at most. It's not ideal, but I think it gets the job done\n\twell enough.\n\n\n    Related examples: \n\n\t// A much simpler example, but the one I vaguely had in mind when coding this.\n\tNautilus - Weyland\n\thttps://www.shadertoy.com/view/MdXGz4\n\n\t// Better usage of the cellular algorithm and XT95's translucency formula.\n    3D Cellular Tiling - Shane\n    https://www.shadertoy.com/view/ld3Szs\n\n\t// One of my favorite simple coloring jobs.\n    Skin Peeler - Dave Hoskins\n    https://www.shadertoy.com/view/XtfSWX\n    Based on one of my all time favorites:\n\tThis was one of the first volumetric dust examples I saw on Shadertoy.\n    Xyptonjtroz - Nimitz\n\thttps://www.shadertoy.com/view/4ts3z2\n\n\n*/\n\n// A more subtle, slightly less heated, scene.\n//#define COOLER\n\n#define FAR 50.\n\n\n// Standard 1x1 hash functions. Using \"cos\" for non-zero origin result.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n// Non-standard vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n/*\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n*/\n\n\n// More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(113, 157, 1);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\n////////\n// The cellular tile routine. Draw a few objects (four spheres, in this case) using a minumum\n// blend at various 3D locations on a cubic tile. Make the tile wrappable by ensuring the \n// objects wrap around the edges. That's it.\n//\n// Believe it or not, you can get away with as few as three spheres. If you sum the total \n// instruction count here, you'll see that it's way, way lower than 2nd order 3D Voronoi.\n// Not requiring a hash function provides the biggest benefit, but there is also less setup.\n// \n// The result isn't perfect, but 3D cellular tiles can enable you to put a Voronoi looking \n// surface layer on a lot of 3D objects for little cost.\n//\nfloat drawObject(in vec3 p){\n    \n    // Wrap conditions:\n    // Anything that wraps the domain will work.\n    //p = cos(p*6.2831853)*.25 + .25; \n    //p = abs(cos(p*3.14159)*.5);\n    //p = fract(p) - .5; \n    //p = abs(fract(p) - .5); \n  \n    // Distance metrics:\n    // Here are just a few variations. There are way too many to list them all,\n    // but you can try combinations with \"min,\" and so forth, to create some\n    // interesting combinations.\n    \n    // Spherical. (Square root needs to be factored to \"d\" in the cellTile function.)\n    //p = fract(p) - .5;    \n    //return dot(p, p)/1.5;\n    \n    // Octahedral... kind of.\n    //p = abs(fract(p)-.5);\n    //return dot(p, vec3(.333));\n    \n    // Triangular tube - Doesn't wrap, but it's here for completeness.\n    //p = fract(p) - .5;\n    //p = max(abs(p)*.866025 + p.yzx*.5, -p.yzx);\n    //return max(max(p.x, p.y), p.z);    \n    \n    // Cubic.\n    //p = abs(fract(p) - .5); \n    //return max(max(p.x, p.y), p.z);\n    \n    // Cylindrical. (Square root needs to be factored to \"d\" in the cellTile function.)\n    //p = fract(p) - .5; \n    //return max(max(dot(p.xy, p.xy), dot(p.yz, p.yz)), dot(p.xz, p.xz));\n    \n    // Octahedral.\n    //p = abs(fract(p) - .5); \n    //p += p.yzx;\n    //return max(max(p.x, p.y), p.z)*.5;\n\n    // Hexagonal tube.\n    p = abs(fract(p) - .5); \n    p = max(p*.866025 + p.yzx*.5, p.yzx);\n    return max(max(p.x, p.y), p.z);\n    \n    \n}\n\n\n\n// Second order cellular tiled routine - I've explained how it works in detail in other examples.\nfloat cellTile(in vec3 p){\n    \n     \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y - p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z - p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z - p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    d.x =  min(v.z, v.w) - min(v.x, v.y); // First minus second order, for that beveled Voronoi look. Range [0, 1].\n    //d.x =  min(v.x, v.y); // Minimum, for the cellular look.\n        \n    const float scale = 2.;\n    return min(d.x*2.*scale, 1.); // Normalize.\n    \n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n    \n    //return vec2(0); // Straight line.\n    \n    // Curved path.\n    float a = sin(z * 0.11/1.5);\n    float b = cos(z * 0.14/1.5);\n    return vec2(a*4. -b*1.5, b*1.7 + a*1.5)*1.5; \n}\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n\n// Based on the triangle function that Shadertoy user Nimitz has used in various triangle noise \n// demonstrations. See Xyptonjtroz - Very cool.\n// https://www.shadertoy.com/view/4ts3z2\n// Anyway, these have been modified slightly to emulate the sin and cos waves.\nvec3 triS(in vec3 x){ return 1. - abs(fract(x + .25) - .5)*4.; } // Triangle function.\nvec3 triC(in vec3 x){ return 1. - abs(fract(x + .5) - .5)*4.; } // Triangle function.\n\n\n// Tube functions - for the tunnel.\nfloat dist2D(in vec2 p){\n\n    // Other tube shapes to try.\n    /*\n    p = abs(p);\n    return max(max(p.x, p.y), (p.x + p.y)*.7071); // Octagon.\n    return max(p.x, p.y); // Square.\n    return (p.x + p.y)*.7071; // Diamond.\n    return max(p.x*.8660254 + p.y*.5, p.y); // Hexagon.\n    */\n    \n    return length(p); // Round cylinder.\n    \n}\n\n// Perturbed gyroid tunnel function: In essence, it's a couple of smoothly\n// combined gyroid functions, with a cylindrical hole (wrapped around the\n// camera path) smoothly carved out from them.\n//\nfloat map(vec3 p){\n    \n   \n    //float sf = cellTile(p*.25); // Cellular layer.\n    //sf = smoothstep(-.1, .5, sf);\n    \n\n    // Trancendental gyroid functions and a function to perturb\n    // the tunnel. For comparisson, I included a rough triangle\n    // function equivalent option.\n    #if 1\n    vec3 q = p*3.1415926;\n    float cav = dot(cos(q/2.), sin(q.yzx/2.5)); // Gyroid one.\n    float cav2 = dot(cos(q/6.5), sin(q.yzx/4.5)); // Gyroid two.\n    cav = smin(cav, cav2/2., 2.); // Smoothly combine the gyroids.\n    \n    // Transendental function to perturb the walls.\n    float n = dot(sin(q/3. + cos(q.yzx/6.)), vec3(.166));\n    //float n = (-cellTile(p*.125) + .5)*.5;\n    #else\n    vec3 q = p/2.;\n    float cav = dot(triC(q/2.), triS(q.yzx/2.5)); // Triangular gyroid one.\n\tfloat cav2 = dot(triC(q/6.5), -triS(q.yzx/4.5)); // Triangular gyroid two.\n    cav = smin(cav, cav2/2., 2.); // Smoothly combine the gyroids.\n    \n    // Triangular function to perturb the walls.\n    float n = dot(triS(q/3. + triC(q.yzx/6.)), vec3(.166));\n    //float n = (-cellTile(p*.125) + .5)*.5;\n\t#endif\n\n    // Wrap the tunnel around the camera path.\n    p.xy -= path(p.z);\n    \n\n    // Smoothly combining the wrapped cylinder with the gyroids, then \n    // adding a bit of perturbation on the walls.\n    n = smax((2.25 - dist2D(p.xy)), (-cav - .75), 1.) +  n;// - sf*.375;\n    \n    // Return the distance value for the scene. Sinusoids aren't that great\n    // to hone in on, so some ray shortening is a necessary evil.\n    return n*.75;\n \n}\n\n\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p){\n    \n    // Cellular tiling.\n    float sf = cellTile(p*.5);\n    float sf2 = cellTile(p*1.5);\n    float n = sf*.66 + sf2*.34; // FBM.\n    \n    // Noise.\n    float ns = noise3D(p*40.);\n    \n    // Combining the above. Trial and error to achieve a slightly\n    // cracked looking surface crust... or something. :)\n    return n*.45 + smoothstep(-.1, .6, sf*.75 + sf2*.25)*.5 + ns*.05;\n    \n    // Another variation that enhances the cracks.\n    //return smoothstep(-.1, .5, sf)*.8 + n*.2; \n\n}\n\n// Standard function-based bump mapping function. Six taps is usually better, but I'm trying\n// trying to save some cycles.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(.001, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n// Standard raymarching function.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    for(int i = 0; i<80; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*(t*.125 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h;\n        \n    }\n\n    return min(t, FAR);\n}\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\n// XT95's really clever, cheap, SSS function. The way I've used it doesn't do it justice,\n// so if you'd like to really see it in action, have a look at the following:\n//\n// Alien Cocoons - XT95: https://www.shadertoy.com/view/MsdGz2\n//\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst float nbIte = 6.0;\n\tfloat ao = 0.0;\n    \n    for( float i=1.; i< nbIte+.5; i++ ){\n        \n        float l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l + map( p -n*l )) / pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = 0.001*(t*.125 + 1.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .01, .5); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n    return min(max(shade, 0.) + .05, 1.); \n}\n\n/*\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calcAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 4.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n*/\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 3.;\n\tconst float nbIte = 5.;\n\t//const float falloff = .9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + .0)*.5/nbIte*maxDist;        \n        ao += (l - map( p + n*l )); // / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n\n\n\n/////\n// Code block to produce some layers of smokey haze. Not sophisticated at all.\n// If you'd like to see a much more sophisticated version, refer to Nitmitz's\n// Xyptonjtroz example. Incidently, I wrote this off the top of my head, but\n// I did have that example in mind when writing this.\n\n// Hash to return a scalar value from a 3D vector.\nfloat hash31(vec3 p){ return fract(sin(dot(p, vec3(127.1, 311.7, 74.7)))*43758.5453); }\n\n// Four layers of cheap cell tile noise to produce some subtle mist.\n// Start at the ray origin, then take four samples of noise between it\n// and the surface point. Apply some very simplistic lighting along the \n// way. It's not particularly well thought out, but it doesn't have to be.\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 0.;\n    \n    //ro -= vec3(0, 0, iTime*3.);\n    \n    float t0 = 0.;\n    \n    for (int i = 0; i<16; i++){\n        \n        // If we reach the surface, don't accumulate any more values.\n        if (t0>t) break; \n        \n        // Lighting. Technically, a lot of these points would be\n        // shadowed, but we're ignoring that.\n        float sDi = length(lp-ro)/FAR; \n\t    float sAtt = 1./(1. + sDi*.25);\n\t    \n        // Noise layer.\n        vec3 ro2 = (ro + rd*t0)*3.;\n        float c = noise3D(ro2)*.66 + noise3D(ro2*3.)*.34; //cellTile\n        float n = (c - .25);\n        mist += n*sAtt;\n        \n        // Advance the starting point towards the hit point. You can \n        // do this with constant jumps (FAR/8., etc), but I'm using\n        // a variable jump here, because it gave me the aesthetic \n        // results I was after.\n        t0 += max(c*.5, .05);\n        \n    }\n    \n    // Add a little noise, then clamp, and we're done.\n    return max(mist/32., 0.);\n    \n    // A different variation (float n = (c. + 0.);)\n    //return smoothstep(.05, 1., mist/32.);\n\n}\n\n//////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lookAt = vec3(0., 0.0, iTime*4. + 0.1);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.0, -0.1); // Camera position, doubling as the ray origin.\n\n \n    // Light positioning. \n \tvec3 lightPos = camPos + vec3(0, .25, 5); // Placed in front of the camera.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlightPos.xy += path(lightPos.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265/2.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt - camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + (uv.x*right + uv.y*up)*FOV);\n    \n    // A bit of lens mutation to increase the scene peripheral, if that's your thing.\n    //vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - dot(rd.xy, rd.xy)*.25));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2(path(lookAt.z).x/16.)*rd.xy;\n\t\t\n    // Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit. \n\tfloat t = trace(camPos, rd);\n\t\n    // Initialize the scene color.\n    vec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n\t    vec3 sn = getNormal(sp);\n        \n        vec3 oSn = sn; // A copy of the unperturbed (unbumped) normal.        \n        \n        // Function based bump mapping. Comment it out to see the under layer. It's pretty\n        // comparable to regular beveled Voronoi... Close enough, anyway.\n        sn = doBumpMap(sp, sn, .5);\n        \n        // For aesthetic reasons, sometimes you might not want the reflected vector to be\n        // perturbed too much by the bumped surface. The following tone it down a little. \n        //oSn = mix(oSn, sn, .75);\n\t    \n\t    // Ambient occlusion and shadows.\n        float ao = calcAO(sp, sn);\n        float sh = softShadow(sp + sn*.002, lightPos, 4., t); // Set to \"1.,\" if you can do without them.\n        sh = min(sh + ao*.3, 1.);\n    \t\n    \t// Light direction vectors.\n\t    vec3 ld = lightPos - sp;\n\n        // Distance from respective lights to the surface point.\n\t    float distlpsp = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= distlpsp;\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + distlpsp*0.25); // + distlpsp*distlpsp*0.025\n    \t\n    \t// Ambient light.\n\t    float ambience = ao*.5;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n        //diff *= diff;\n   \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd), 0.), 32.);\n\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n        \n        // Refected vector at the surface hit point. \n        vec3 ref = reflect(rd, oSn);\n\n        // Object texturing and coloring: I made this up as I went along. It's just a combination \n        // of value noise and cellular noise. Sometimes, I like to darken crevices, etc, a little \n        // more by applying combinations that match those in the distance field calculations, or \n        // bump map calculations.\n        vec3 texCol = mix(vec3(.5, .4, .3), vec3(0, .1, .2), (noise3D(sp*32.)*.66 + noise3D(sp*64.)*.34));\n        texCol *= mix(vec3(0, .1, .2).zyx, vec3(1, .9, .8), (1. - cellTile(sp*4.5)*.75));\n \n        // Extra shading in the cracked crevices for a slightly more cartoonish look.\n        texCol *= mix(vec3(.9, .95, 1), vec3(.1, 0, 0), .75 - smoothstep(-.1, .5, cellTile(sp*.5))*.75);\n        \n        \n        // Last minute decision to give the rocky surface a blueish charcoal tinge. Still not sure about it. :)\n        texCol *= vec3(.8, 1, 1.2); \n        \n        \n    \t/////////   \n        // Translucency, courtesy of XT95. See the \"thickness\" function.\n        vec3 hf =  normalize(ld + sn);\n        float th = thickness( sp, sn, 1., 1.);\n        float tdiff =  pow( clamp( dot(rd, -hf), 0., 1.), 1.);\n        float trans = (tdiff + .0)*th;  \n        trans = pow(trans, 4.);        \n    \t//////// \n    \t\n    \t\n    \t// Combining the above terms to produce the final color. It's based more on acheiving a\n        // certain aesthetic than science.\n        sceneCol = texCol*(diff + ambience) + vec3(.7, .9, 1.)*spec;\n        sceneCol += texCol*vec3(.8, .95, 1)*pow(fre, 3.)*3.;\n        sceneCol += texCol*vec3(1, .1, .05)*trans*12.;\n        \n        // Fake reflection. Other that using the refected vector, there's very little science \n        // involved, but since the effect is subtle, you can get away with it.\n        vec3 refCol = vec3(1, .05, .075)*smoothstep(.25, 1., noise3D(ref*2.)*.66 + noise3D(ref*4.)*.34 );\n        sceneCol += texCol*refCol*2.;\n\n\t    // Shading.\n        sceneCol *= atten*ao*sh;\n\t   \n\t\n\t}\n    \n   \n       \n    // Blend the scene and the background with some very basic, 16-layered smokey haze.\n    float mist = getMist(camPos, rd, lightPos, t);\n    vec3 sky = vec3(2, 1, .5);\n    sky = mix(sky, sky.xzy, .25 - rd.y*.25);\n    sceneCol = mix(sky, sceneCol, 1./(t*t/FAR/FAR*12. + 1.));\n    \n\n    // Brown mist was too brown, and blue mist was too blue, so I combined the two... Not a lot of thought\n    // went into it. :)\n    //vec3 mistCol = vec3(1.2, 1, .8); // Probably, more realistic, but less interesting.\n    vec3 mistCol = mix(vec3(1.4, 1, .85), vec3(1.4, 1, .85).zyx, dot(sin(rd*9. + cos(rd.yzx*5.)), vec3(.166)) + .5);\n    // Applying the mist to the scene. This particular compositing formula was based on how I wanted\n    // the mist to look when blended in with the background... More Star Trek science. :D\n    sceneCol += (mix(sceneCol, mistCol, .66)*.66 + sceneCol*mistCol*1.5)*mist;\n    \n    #ifdef COOLER\n    // Cooler, more subtle version.\n    sceneCol *= vec3(.85, .95, 1.25);\n    #endif\n    \n    // Vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneCol = mix(sceneCol, vec3(0), (1. - pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.25))*.5);\n\n\n    // Clamp and present the pixel to the screen.\n\tfragColor = vec4(sqrt(max(sceneCol, 0.)), 1.0);\n\t\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}