{
    "Shader": {
        "info": {
            "date": "1587839504",
            "description": "A variation on [url]https://www.shadertoy.com/view/WdXBzH[/url] using rotations through rational angles to get nice symmetric patterns.",
            "flags": 0,
            "hasliked": 0,
            "id": "wdsfRN",
            "likes": 7,
            "name": "Rational 4D Lattice Slice",
            "published": 3,
            "tags": [
                "4d",
                "slices",
                "rational"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 374
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Rational Slices.\n//\n// Matthew Arcus, mla, 2020\n//\n// Slices through a 4 dimensional cubic lattice at rational angles.\n// <mouse-y>: scale\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\n\n// Quaternion left and right multiplication as matrices\n// The two forms commute (this is just associativity).\nmat4 qmat_left(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, t = q.w;\n  return mat4( t, z,-y,-x, \n              -z, t, x,-y,\n               y,-x, t,-z,\n               x, y, z, t );\n}\n\nmat4 qmat_right(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, t = q.w;\n  return mat4( t,-z, y,-x, \n               z, t,-x,-y,\n              -y, x, t,-z,\n               x, y, z, t );\n}\n\n// Farey(10) sequence\nconst int nfarey = 33;\nconst int farray[2*nfarey] =\n  int[](0,1,1,10,1,9,1,8,1,7,1,6,1,5,2,9,1,4,2,7,3,10,\n        1,3,3,8,2,5,3,7,4,9,1,2,5,9,4,7,3,5,5,8,2,3,7,\n        10,5,7,3,4,7,9,4,5,5,6,6,7,7,8,8,9,9,10,1,1);\n\nfloat farey(int i) {\n  i %= nfarey;\n  return float(farray[2*i])/float(farray[2*i+1]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  float size = 4.0*exp(3.0*iMouse.y / iResolution.y);\n  uv *= size;\n\n  float tr,tq;\n  tq = atan(1.0);\n  float t = 1.0*iTime;\n  float i0 = 2.0*floor(0.5*t);\n  float i1 = 2.0*floor(0.5*t+0.5);\n  int mfactor = 256;\n  tr = atan(mix(farey(int(i0)*mfactor),farey(int(i1)*mfactor),fract(t)));\n\n  vec4 q = vec4(sin(tq)*vec3(1,0,0),cos(tq));\n  vec4 r = vec4(sin(tr)*vec3(0,1,0),cos(tr));\n\n  vec4 p = vec4(uv,0,0);\n  mat4 qm = qmat_left(q)*qmat_right(r);\n  float ds = fwidth(p.x);\n  p = qm*p;\n  p = mod(p,2.0);\n  vec4 dp = fract(p);\n  dp = min(dp,1.0-dp);\n  p = floor(p);\n  int parity = int(dot(p,vec4(1)))%2;\n\n  mat4x2 dm = transpose(mat2x4(qm));\n  dp /= vec4(length(dm[0]),length(dm[1]),length(dm[2]),length(dm[3]));\n  float d = min(min(dp.x,dp.y),min(dp.z,dp.w));\n  vec3 color = vec3(smoothstep(-ds,+ds,parity==0?d:-d));\n  color = mix(vec3(1,0,0),color,smoothstep(0.01,0.02+ds,d));\n  color = pow(color,vec3(0.4545));\n  fragColor = vec4(color,1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}