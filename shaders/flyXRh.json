{
    "Shader": {
        "info": {
            "date": "1640126946",
            "description": "shader about boucing animation, space transformation, easing functions, funny shape and colorful vibes.",
            "flags": 0,
            "hasliked": 0,
            "id": "flyXRh",
            "likes": 15,
            "name": "happy bouncing",
            "published": 3,
            "tags": [
                "colorful",
                "animation"
            ],
            "usePreview": 0,
            "username": "leon",
            "viewed": 447
        },
        "renderpass": [
            {
                "code": "// \"happy bouncing\"\n// shader about boucing animation, space transformation, easing functions,\n// funny shape and colorful vibes.\n// by leon denise (2021-12-21)\n// licensed under hippie love conspiracy\n\n// using Inigo Quilez works:\n// arc sdf from https://www.shadertoy.com/view/wl23RK\n// color palette https://iquilezles.org/articles/palettes\n\n// global variable\nfloat bodySize = 0.2;\n\n// shape eyes\nvec2 size = vec2(.07, .05);\nfloat divergence = 0.06;\n\n// easing curves are below\nfloat jump(float);\nfloat walk(float);\nfloat stretch(float);\nfloat bounce(float);\nfloat swing(float);\n\n// list of transformation (fun to tweak)\nvec2 animation(vec2 p, float t)\n{\n    t = fract(t);\n    \n    p.y -= bodySize-0.5;\n    p.y -= jump(t)*0.5;\n    p.x += walk(t)*0.1;\n    p.x *= stretch(t)*-0.2+1.;\n    \n    // bounce stretch with collision\n    float b = bounce(t)*-0.2;\n    p.y *= b+1.;\n    p.y += abs(b)*bodySize;\n    \n    return p;\n}\n\nvoid mainImage( out vec4 color, in vec2 pixel )\n{\n    color = vec4(0,0,0,1);\n    \n    // number of friends\n    const float buddies = 5.;\n    for (float i = 0.; i < buddies; ++i)\n    {\n        // usefull to dissociate instances\n        float ii = i/(buddies-1.);\n        float iii = 1.-ii;\n        \n        // translate instances\n        vec2 pp = (pixel-0.5*iResolution.xy)/iResolution.y;\n        pp.x += (ii*2.-1.)*.4;\n        \n        // time\n        float t = fract(iTime*.5 + ii * .5);\n        \n        // there will be sdf shapes\n        float shape = 1000.;\n        vec2 p;\n        \n        // there will be layers\n        vec3 col = vec3(0);\n        \n        // color palette\n        // Inigo Quilez (https://iquilezles.org/articles/palettes)\n        vec3 tint = .5+.5*cos(vec3(0.,.3,.6)*6.28+i-length(animation(pp,t))*3.);\n        \n        // body shape\n        float body = circle(animation(pp, t), bodySize);\n        col += tint*fill(body);\n        shape = min(shape, body);\n\n        // eyes positions\n        p = animation(pp, t+0.02);\n        p *= rot(swing(t)*-.5);\n        p -= vec2(.03, bodySize+size.x*.2);\n        p.x = abs(p.x)-divergence;\n        \n        // globe shape\n        float eyes = circle(p, size.x);\n        shape = min(shape, eyes);\n        col = mix(col, tint, fill(eyes));\n        \n        // white eye shape\n        eyes = circle(p, size.y);\n        col = mix(col, vec3(1), fill(eyes));\n        shape = min(shape, eyes);\n        \n        // black dot shape\n        eyes = circle(p, 0.02);\n        col = mix(col, vec3(0), fill(eyes));\n        \n        // smile animation\n        float anim = cos(pow(t, .5)*6.28)*.5+.5;\n        \n        // smile position\n        p = animation(pp, t-0.02);\n        p *= rot(swing(t)*-.9);\n        p -= bodySize*vec2(.5, .5+anim*.5);\n        \n        // arc (fun to tweak)\n        float smile = mix(0., 1., anim);//+(.5+.5*sin(ii*12.+iTime*12.*ii));\n        float thin = mix(0.1, 0.02, anim);//+0.04*(.5+.5*sin(ii*12.+iTime*22.*ii));\n        float d = sdArc(p,-3.14/2., smile, 0.1, thin);\n        \n        // mouth shape\n        d = d-mix(.01, .04, anim);\n        shape = min(shape, d);\n        col = mix(col, tint*1.2, fill(d));\n        \n        // black line\n        col = mix(col, tint*.5, fill(d+.05));\n        \n        // add color to frame\n        color.rgb = mix(color.rgb, col, step(shape, 0.));\n    }\n}\n\n// easing curves (not easy to tweak)\n// affect timing of transformations;\n\nfloat jump (float t)\n{\n    t = min(1., t*4.);\n    t = abs(sin(t*3.1415));\n    return pow(sin(t*3.14/2.), 1.9);\n}\n\nfloat walk (float t)\n{\n    t = mix(pow(t,.5), pow(t, 2.0), t);\n    return (cos(t*3.1415*2.));\n}\n\nfloat swing (float t)\n{\n    t = t*2.;\n    t = pow(t, .5);\n    t = sin(t*3.14*2.);\n    return t;\n}\n\nfloat stretch (float t)\n{\n    float tt = cos(pow(t, .2)*30.);\n    return tt;\n}\n\nfloat bounce (float t)\n{\n    float tt = cos(pow(t, .2)*10.);\n    return tt;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdArc( in vec2 p, in float ta, in float tb, in float ra, float rb )\n{\n    vec2 sca = vec2(sin(ta),cos(ta));\n    vec2 scb = vec2(sin(tb),cos(tb));\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p,scb) : length(p);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n// snippets\n#define fill(sdf) (smoothstep(.001, 0., sdf))\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat circle (vec2 p, float size)\n{\n    return length(p)-size;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}