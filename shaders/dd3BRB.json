{
    "Shader": {
        "info": {
            "date": "1697475647",
            "description": "foobar",
            "flags": 0,
            "hasliked": 0,
            "id": "dd3BRB",
            "likes": 9,
            "name": "Bilinear Filtered Gradient",
            "published": 3,
            "tags": [
                "2d",
                "filtering",
                "bilinear",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 1072
        },
        "renderpass": [
            {
                "code": "const vec3 col0 = vec3 (111./255., 204./255., 221./255.);\nconst vec3 col1 = vec3 ( 51./255., 196./255., 243./255.);\nconst vec3 col2 = vec3 ( 67./255., 143./255., 205./255.);\nconst vec3 col3 = vec3 ( 63./255., 116./255., 186./255.);\nconst vec3 col4 = vec3 ( 54./255.,  79./255., 161./255.);\nconst vec3 col5 = vec3 ( 88./255.,  62./255., 153./255.);\nconst vec3 col6 = vec3 (112./255.,  36./255., 111./255.);\nconst vec3 col7 = vec3 (217./255.,  25./255.,  62./255.);\nconst vec3 col8 = vec3 (237./255.,  31./255.,  35./255.);\nconst vec3 col9 = vec3 (247./255., 112./255.,  31./255.);\nconst vec3 colA = vec3 (249./255., 164./255.,  21./255.);\nconst vec3 colB = vec3 (252./255., 204./255.,   8./255.);\nconst vec3 colC = vec3 (255./255., 228./255.,   4./255.);\nconst vec3 colD = vec3 (245./255., 235./255.,  16./255.);\nconst vec3 colE = vec3 (249./255., 244./255., 176./255.);\nconst vec3 colF = vec3 (253./255., 253./255., 253./255.);\n\nvec3 gradient (float v)\n{\n    float steps = 16.;\n    float step = 1./steps;\n    vec3 col = vec3 (1., .0, 1.); // something nasty as default\n\n    if (v >= .0 && v < step) {\n        col = mix (col0, col1, v*steps);\n    } else if (v >= step && v < 2.*step) {\n        col = mix (col1, col2, (v - step)*steps);\n    } else if (v >=  2.*step && v <  3.*step) {\n        col = mix (col2, col3, (v -  2.*step)*steps);\n    } else if (v >=  3.*step && v <  4.*step) {\n        col = mix (col3, col4, (v -  3.*step)*steps);\n    } else if (v >=  4.*step && v <  5.*step) {\n        col = mix (col4, col5, (v -  4.*step)*steps);\n    } else if (v >=  5.*step && v <  6.*step) {\n        col = mix (col5, col6, (v -  5.*step)*steps);\n    } else if (v >=  6.*step && v <  7.*step) {\n        col = mix (col6, col7, (v -  6.*step)*steps);\n    } else if (v >=  7.*step && v <  8.*step) {\n        col = mix (col7, col8, (v -  7.*step)*steps);\n    } else if (v >=  8.*step && v <  9.*step) {\n        col = mix (col8, col9, (v -  8.*step)*steps);\n    } else if (v >=  9.*step && v < 10.*step) {\n        col = mix (col9, colA, (v -  9.*step)*steps);\n    } else if (v >= 10.*step && v < 11.*step) {\n        col = mix (colA, colB, (v - 10.*step)*steps);\n    } else if (v >= 11.*step && v < 12.*step) {\n        col = mix (colB, colC, (v - 11.*step)*steps);\n    } else if (v >= 12.*step && v < 13.*step) {\n        col = mix (colC, colD, (v - 12.*step)*steps);\n    } else if (v >= 13.*step && v < 14.*step) {\n        col = mix (colD, colE, (v - 13.*step)*steps);\n    } else if (v >= 14.*step && v < 15.*step) {\n        col = mix (colE, colF, (v - 14.*step)*steps);\n    } else\n        col = colF;\n\n    return col;\n}\n\nvec2 noise2d (in vec2 p)\n{\n\tvec3 v = fract (p.xyx*vec3(123.34, 234.34, 345.65));\n\tv += dot (v, v + 34.45);\n\treturn fract (vec2 (v.x*v.y, v.y*v.z));\n}\n\nmat3 r3d (float deg)\n{\n\tfloat r = radians (deg);\n    float c = cos (r);\n    float s = sin (r);\n    mat3 m = mat3 (vec3 ( c,  s, .0),\n                   vec3 (-s,  c, .0),\n                   vec3 (.0, .0, .0));\n\n    return m;\n}\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise (in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3. - 2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm (vec3 p)\n{\n    float f;\n    mat3 m = r3d (1.1);\n\n    f  = .5*noise( p ); p = m*p*2.02;\n    f += .25*noise( p ); p = m*p*2.23;\n    f += .125*noise( p ); p = m*p*2.71;\n    f += .0625*noise( p );\n\n    return f;\n}\n\nmat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n    float c = cos (rad);\n    float s = sin (rad);\n    return mat2 (c, s, -s, c);\n}\n\nfloat smoothheavy (float a, float b, float v)\n{\n    float k = .5 + 2.5*(0.5 + .5*sin(iTime)); //.5;\n    float _v = clamp (v, a, b);\n    return 0.5 + 0.5*tanh(k*(_v*6. - 3.));\n}\n// array is interpreted from 0..3 as:\n//\n//   - 0: bottom left value\n//   - 1: bottom right value\n//   - 2: top left value\n//   - 3: top right value\n//\nfloat blerp (vec2 uv, float array[4])\n{\n    float m = smoothstep (.0, 1., uv.x);\n    float a = mix (array[0], array[1], m);\n    float b = mix (array[2], array[3], m);\n    return mix (a, b, smoothstep (.0, 1., uv.y));\n}\n\nfloat blerp2 (vec2 uv, float array[4])\n{\n    float m = smoothheavy (.0, 1., uv.x);\n    float a = mix (array[0], array[1], m);\n    float b = mix (array[2], array[3], m);\n    return mix (a, b, smoothheavy (.0, 1., uv.y));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize 'canvas'\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // rotate 'canvas'\n    uv *= r2d (24.*iTime);\n\n    // scale 'canvas'\n    float scale = 2. + 6.*(.5 + .5*cos (iTime));\n    uv *= scale;\n\n    vec2 grid = fract (uv);\n    vec2 id = floor (uv);\n\n    vec2 p = id + noise2d (id);\n    float m = distance (uv, p) - .01;\n    float l = .7*length (grid);\n    float d = smoothstep (.02, .03, m);\n\n    vec3 col = vec3 (.25);\n\n    col = mix (col, gradient (l), 1. - d);\n\n    const vec2 offsets[4] = vec2[4](\n        vec2(.0, .0),\n        vec2(1., .0),\n        vec2(.0, 1.),\n        vec2(1., 1.));\n\n    float array[4];\n    \n    for (int i = 0; i < 4; i++) {\n        vec2 p = id + offsets[i];\n        //vec2 n = noise2d (p);\n        //float v = n.x*n.y;\n        float v = fbm (vec3 (p, p.x-p.y));\n        array[i] = v;\n        \n    }\n    col = gradient (blerp2 (grid, array));\n\n    /*if (grid.x < .0125 || grid.y < .0125)\n        col *= .85;*/\n\n    fragColor = vec4 (col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}