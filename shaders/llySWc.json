{
    "Shader": {
        "info": {
            "date": "1486153833",
            "description": "SVG viewer.  \non going work. \nTODO: filling , tried here: [url]https://www.shadertoy.com/view/XtKSD3[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "llySWc",
            "likes": 18,
            "name": "svg viewer - contour (test)",
            "published": 3,
            "tags": [
                "bezier",
                "logo",
                "svg",
                "nvidia"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1270
        },
        "renderpass": [
            {
                "code": "// ongoing work. filled version here https://www.shadertoy.com/view/MlVSWc\n\n// Bezier display adapted from revers https://www.shadertoy.com/view/MlGSz3\n// SVG spec: https://www.w3.org/TR/2008/REC-SVGTiny12-20081222/paths.html\n\n#define M(x,y)             x0 = _x = x;   y0 =_y = y;\n#define L(x,y)             d = min(d, line(uv, vec2(_x,_y), vec2(x,y)) ); _x=x,_y=y;\n#define C(x1,y1,x2,y2,x,y) d = min(d, bezier(uv, vec2(_x,_y), vec2(x1,y1),vec2(x2,y2), vec2(x,y)) ); _x=x,_y=y; \n#define z                  d = min(d, line(uv, vec2(_x,_y), vec2(x0,y0)) );\n// other SVG commands easy to implement, but not tested.\n\nfloat bezier(vec2 uv, vec2 A, vec2 B, vec2 C, vec2 D);\nfloat line(vec2 p, vec2 a, vec2 b);\nfloat contrast = 1.;\n\n// === SVG drawing ===============================================================\n\nfloat SVG(vec2 uv) {\n    uv *= 400.; \n    contrast = .75*iResolution.x/ 400.;\n    float d = 1e38, _x, _y, x0, y0;\n\n// nvidia logo from https://upload.wikimedia.org/wikipedia/fr/4/47/Nvidia_%28logo%29.svg\n \n    \n    M( 82.2115,102.414 )\n    C( 82.2115,102.414, 104.7155,69.211, 149.6485,65.777 )\n    L( 149.6485,53.73  )\n    C( 99.8795,57.727, 56.7818,99.879,  56.7818,99.879   )\n    C( 56.7818,99.879, 81.1915,170.445, 149.6485,176.906 )\n    L( 149.6485,164.102 )\n    C( 99.4105,157.781, 82.2115,102.414, 82.2115,102.414 ) \n    // z\n        \n    M( 149.6485,138.637 )\n    L( 149.6485,150.363 )\n    C( 111.6805,143.594, 101.1415,104.125, 101.1415,104.125 )\n    C( 101.1415,104.125, 119.3715,83.93,   149.6485,80.656  )\n    L( 149.6485,93.523 )\n    C( 149.6255,93.523, 149.6095,93.516,  149.5905,93.516   )\n    C( 133.6995,91.609, 121.2855,106.453,  121.2855,106.453 )\n    C( 121.2855,106.453, 128.2425,131.445, 149.6485,138.637 ) \n    // z\n\n    M( 149.6485,31.512 )\n    L( 149.6485,53.73 )\n    C( 151.1095,53.617,  152.5705,53.523,  154.0395,53.473  )\n    C( 210.6215,51.566,  247.4885,99.879,  247.4885,99.879  )\n    C( 247.4885,99.879,  205.1455,151.367, 161.0315,151.367 )\n    C( 156.9885,151.367, 153.2035,150.992, 149.6485,150.363 )\n    L( 149.6485,164.102 )\n    C( 152.6885,164.488, 155.8405,164.715, 159.1295,164.715 )\n    C( 200.1805,164.715, 229.8675,143.75,  258.6135,118.937 )\n    C( 263.3795,122.754, 282.8915,132.039, 286.9025,136.105 )\n    C( 259.5705,158.988, 195.8715,177.434, 159.7585,177.434 )\n    C( 156.2775,177.434, 152.9345,177.223, 149.6485,176.906 )\n    L( 149.6485,196.211 )\n    L( 305.6805,196.211 )\n    L( 305.6805,31.512 )\n    L( 149.6485,31.512 ) \n    // z\n          \n    M( 149.6485,80.656 )\n    L( 149.6485,65.777 )\n    C( 151.0945,65.676, 152.5515,65.598, 154.0395,65.551     )\n    C( 194.7275,64.273, 221.4225,100.516, 221.4225,100.516   )\n    C( 221.4225,100.516, 192.5905,140.559, 161.6765,140.559  )\n    C( 157.2275,140.559, 153.2385,139.844, 149.6485,138.637  )\n    L( 149.6485,93.523 )\n    C( 165.4885,95.437, 168.6765,102.434, 178.1995,118.309   )\n    L( 199.3795,100.449 )\n    C( 199.3795,100.449, 183.9185,80.172, 157.8555,80.172    )\n    C( 155.0205,80.172, 152.3095,80.371, 149.6485,80.656 ) \n    // z\n\n    return d;\n}\n\nconst mat4   M = mat4(-1,  3, -3,   1,         // Bspline Matrix\n                       3, -6,  3,   0,\n                      -3,  3,  0,   0,\n                       1,  0,  0,   0);\n/*\n#define T .5\nconst mat4   M = mat4(-T,   2.-T,  T-2.,    T, //  Catmull-Rom Matrix\n                       2.*T, T-3., 3.-2.*T,-T,\n                      -T,      0,   T,      0,\n                       0,      1,   0,      0);\n*/\n\n// Spline Interpolation\nvec2 interpolate(vec2 G1, vec2 G2, vec2 G3, vec2 G4, float t) {\n    vec2 A = G1 * M[0][0] + G2 * M[0][1] + G3 * M[0][2] + G4 * M[0][3];\n    vec2 B = G1 * M[1][0] + G2 * M[1][1] + G3 * M[1][2] + G4 * M[1][3];\n    vec2 C = G1 * M[2][0] + G2 * M[2][1] + G3 * M[2][2] + G4 * M[2][3];\n    vec2 D = G1 * M[3][0] + G2 * M[3][1] + G3 * M[3][2] + G4 * M[3][3];\n\n    return t * (t * (t * A + B) + C) + D;\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\tvec2 d = pa - ba * h;\n\treturn dot(d,d); //length(d); // optimization by deferring sqrt\n}\n\n\nfloat bezier( vec2 uv, vec2 A, vec2 B, vec2 C, vec2 D)    \n{\n    float d = 1e5;\n    vec2 p = A;\n    for (float t = 0.; t <= 1.01; t += .025) {\n        vec2 q = interpolate(A, B, C, D, t);\n        d = min(d, line(uv, p, q));\n\t\tp = q;\n\t}\n\n\treturn d;\n}\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    vec2 R = iResolution.xy;\n    U.y = R.y-U.y; U /= R.x;\n    \n    float d = sqrt(SVG(U)); // SVG(U); // optimization by deferring sqrt here\n    d *= contrast;\n\tO = vec4(d); // *vec4(1,.2,.05,1);\n\tif (fract(iDate.w/2.)>.5) O = clamp(d,0.,1.) + .05*vec4(0,sin(d),0,0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}