{
    "Shader": {
        "info": {
            "date": "1680211436",
            "description": "Procedural planet made with raycasting and FBM noises.\n\nI made a web page with a GUI to tweak some uniforms (and it's more optimized than this one):\n[url]https://jsulpis.github.io/realtime-planet-shader/procedural[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "Ds3XRl",
            "likes": 53,
            "name": "Procedural Blue Planet",
            "published": 3,
            "tags": [
                "procedural",
                "raycasting",
                "fbm",
                "space",
                "planet"
            ],
            "usePreview": 1,
            "username": "jsulpis",
            "viewed": 1616
        },
        "renderpass": [
            {
                "code": "//=======================================================================================//\n//\n// Procedural Blue Planet\n// by Julien Sulpis (https://twitter.com/jsulpis)      \n// https://www.shadertoy.com/view/Ds3XRl\n//\n//=======================================================================================//\n\n\n// Planets geometry\n#define PLANET_POSITION vec3(0, 0, 0)\n#define PLANET_RADIUS 2.\n#define NOISE_STRENGTH .2\n#define ROTATION_SPEED -.1\n#define PLANET_ROTATION rotateY(iTime * ROTATION_SPEED)\n\n#define MOON_RADIUS .08\n#define MOON_ROTATION_SPEED ROTATION_SPEED * 5.\n#define MOON_OFFSET vec3(PLANET_RADIUS * 1.2, PLANET_RADIUS / 4., 0.)\n#define MOON_ROTATION_AXIS (MOON_OFFSET - PLANET_POSITION) * rotateZ(PI/2.)\n\n// Planet colors\n#define WATER_COLOR_DEEP vec3(0.01, 0.05, 0.15)\n#define WATER_COLOR_SURFACE vec3(0.02, 0.12, 0.27)\n#define SAND_COLOR vec3(1.0, 1.0, 0.85)\n#define TREE_COLOR vec3(.02, .1, .06)\n#define ROCK_COLOR vec3(0.15, 0.12, 0.12)\n#define ICE_COLOR  vec3(0.8, .9, .9)\n#define CLOUD_COLOR  vec3(1., 1., 1.)\n#define ATMOSPHERE_COLOR vec3(0.05, 0.3, 0.9)\n\n#define WATER_SURFACE_LEVEL 0.0\n#define SAND_LEVEL .028\n#define TREE_LEVEL .03\n#define ROCK_LEVEL .1\n#define ICE_LEVEL .15\n#define TRANSITION .02\n\n// Lighting\n#define SUN_DIR normalize(vec3(1.0, 1.0, 0.))\n#define SUN_COLOR vec3(1.0, 1.0, 0.9) * 3.\n#define AMBIENT_LIGHT vec3(.003)\n#define SPACE_BLUE vec3(0., 0., 0.002)\n\n// Ray tracing\n#define MAX_BOUNCES 1 // something's wrong with the normals when using more than one bounce...\n#define EPSILON 1e-3\n#define INFINITY 1e10\n#define CAMERA_POSITION vec3(0., 0., 6.0)\n\n#define PI acos(-1.)\n\n//=========//\n//  Types  //\n//=========//\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\nstruct Material {\n  vec3 color;\n  float diffuse;\n  float specular;\n};\n\nstruct Hit {\n  float len;\n  vec3 normal;\n  Material material;\n};\n\nstruct Sphere {\n  vec3 position;\n  float radius;\n};\n\nHit miss = Hit(INFINITY, vec3(0.), Material(vec3(0.), -1., -1.));\nSphere planet = Sphere(PLANET_POSITION, PLANET_RADIUS);\n\n\n//===============================================//\n//  Generic utilities stolen from smarter people //\n//===============================================//\n\n// https://iquilezles.org/articles/intersectors/\nfloat sphIntersect(in Ray ray, in Sphere sphere) {\n  vec3 oc = ray.origin - sphere.position;\n  float b = dot(oc, ray.direction);\n  float c = dot(oc, oc) - sphere.radius * sphere.radius;\n  float h = b * b - c;\n  if(h < 0.0)\n    return -1.; // no intersection\n  return -b - sqrt(h);\n}\n\nfloat noise(vec3 p) {\n  return texture(iChannel0, p * .05).r;\n}\n\nfloat inverseLerp(float v, float minValue, float maxValue) {\n  return (v - minValue) / (maxValue - minValue);\n}\n\nfloat remap(float v, float inMin, float inMax, float outMin, float outMax) {\n  float t = inverseLerp(v, inMin, inMax);\n  return mix(outMin, outMax, t);\n}\n\n// Comes from a course by SimonDev (https://www.youtube.com/channel/UCEwhtpXrg5MmwlH04ANpL8A)\n// https://simondev.teachable.com/p/glsl-shaders-from-scratch\nfloat fbm(vec3 p, int octaves, float persistence, float lacunarity, float exponentiation) {\n  float amplitude = 0.5;\n  float frequency = 3.0;\n  float total = 0.0;\n  float normalization = 0.0;\n\n  for(int i = 0; i < octaves; ++i) {\n    float noiseValue = noise(p * frequency);\n    total += noiseValue * amplitude;\n    normalization += amplitude;\n    amplitude *= persistence;\n    frequency *= lacunarity;\n  }\n\n  total /= normalization;\n  total = total * 0.8 + 0.1;\n  total = pow(total, exponentiation);\n\n  return total;\n}\n\nmat3 rotateY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(//\n    vec3(c, 0, s),//\n    vec3(0, 1, 0),//\n    vec3(-s, 0, c)//\n  );\n}\n\nmat3 rotateZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(//\n    vec3(c, -s, 0),//\n    vec3(s, c, 0),//\n    vec3(0, 0, 1)//\n  );\n}\n\n// https://github.com/dmnsgn/glsl-rotate/blob/main/rotation-3d.glsl\nmat3 rotate3d(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat3(//\n    oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,//\n    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,//\n    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c//\n  );\n}\n\nvec3 nmzHash33(vec3 q) {\n  uvec3 p = uvec3(ivec3(q));\n  p = p * uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\n  p = p.yzx * (p.zxy ^ (p >> 3U));\n  return vec3(p ^ (p >> 16U)) * (1.0 / vec3(0xffffffffU));\n}\n\n// nimitz - https://www.shadertoy.com/view/XsyGWV\nvec3 stars(in vec3 p) {\n  vec3 c = vec3(0.);\n  float res = iResolution.x * 0.8;\n\n  for(float i = 0.; i < 5.; i++) {\n    vec3 q = fract(p * (.15 * res)) - 0.5;\n    vec3 id = floor(p * (.15 * res));\n    vec2 rn = nmzHash33(id).xy;\n    float c2 = 1. - smoothstep(0., .6, length(q));\n    c2 *= step(rn.x, .0005 + i * 0.002);\n    c += c2 * (mix(vec3(1.0, 0.49, 0.1), vec3(0.75, 0.9, 1.), rn.y) * 0.25 + 0.75);\n    p *= 1.4;\n  }\n  return c * c;\n}\n\n// Comes from a course by SimonDev (https://www.youtube.com/channel/UCEwhtpXrg5MmwlH04ANpL8A)\n// https://simondev.teachable.com/p/glsl-shaders-from-scratch\nfloat domainWarpingFBM(vec3 p) {\n  int octaves = 3;\n  float persistence = .3;\n  float lacunarity = 5.;\n  float expo = 1.;\n\n  vec3 offset = vec3(//\n    fbm(p, octaves, persistence, lacunarity, expo), //\n    fbm(p + vec3(43.235, 23.112, 0.0), octaves, persistence, lacunarity, expo), //\n    0.0//\n  );\n\n  return fbm(p + 1. * offset, 2, persistence, lacunarity, expo);\n}\n\n// Zavie - https://www.shadertoy.com/view/lslGzl\nvec3 simpleReinhardToneMapping(vec3 color) {\n  float exposure = 1.5;\n  color *= exposure / (1. + color / exposure);\n  color = pow(color, vec3(1. / 2.4));\n  return color;\n}\n\n\n//========//\n//  Misc  //\n//========//\n\nfloat planetNoise(vec3 p) {\n  float fbm = fbm(p * .8, 6, .5, 2., 5.) * NOISE_STRENGTH;\n\n  // Flatten the noise on the oceans\n  return mix(//\n    fbm / 3. + NOISE_STRENGTH / 50., //\n    fbm, //\n    smoothstep(SAND_LEVEL, SAND_LEVEL + TRANSITION / 2., fbm * 5.)//\n  );\n}\n\n/**\n* Standard ray-sphere intersection but with fbm noise added on the radius.\n* Probably not exact (especially near the edges), but it looks good enough\n*/\nfloat planetDist(in vec3 ro, in vec3 rd) {\n  Ray ray = Ray(ro, rd);\n  float smoothSphereDist = sphIntersect(ray, planet);\n\n  vec3 intersection = ro + smoothSphereDist * rd;\n  vec3 intersectionWithRotation = (intersection - PLANET_POSITION) * PLANET_ROTATION + PLANET_POSITION;\n\n  return sphIntersect(ray, Sphere(PLANET_POSITION, PLANET_RADIUS + planetNoise(intersectionWithRotation)));\n}\n\nvec3 planetNormal(vec3 p) {\n  vec3 rd = PLANET_POSITION - p;\n  float dist = planetDist(p, rd);\n  vec2 e = vec2(.01, 0);\n\n  vec3 normal = dist - vec3(planetDist(p - e.xyy, rd), planetDist(p - e.yxy, rd), planetDist(p + e.yyx, rd));\n  return normalize(normal);\n}\n\nvec3 currentMoonPosition() {\n  mat3 moonRotation = rotate3d(MOON_ROTATION_AXIS, iTime * MOON_ROTATION_SPEED);\n  return MOON_OFFSET * moonRotation + PLANET_POSITION;\n}\n\nvec3 spaceColor(vec3 direction) {\n  mat3 backgroundRotation = rotateY(-iTime * ROTATION_SPEED / 4.);\n  vec3 backgroundCoord = direction * backgroundRotation;\n  float spaceNoise = fbm(backgroundCoord * 3., 4, .5, 2., 6.);\n\n  return stars(backgroundCoord) + mix(SPACE_BLUE, ATMOSPHERE_COLOR / 4., spaceNoise);\n}\n\n//===============//\n//  Ray Tracing  //\n//===============//\n\nHit intersectPlanet(Ray ray) {\n  float len = sphIntersect(ray, planet);\n\n  if(len < 0.) {\n    return miss;\n  }\n\n  vec3 position = ray.origin + len * ray.direction;\n  vec3 rotatedCoord = (position - PLANET_POSITION) * PLANET_ROTATION + PLANET_POSITION;\n  float altitude = 5. * planetNoise(rotatedCoord);\n\n  vec3 normal = planetNormal(position);\n\n  vec3 color = mix(WATER_COLOR_DEEP, WATER_COLOR_SURFACE, smoothstep(WATER_SURFACE_LEVEL, WATER_SURFACE_LEVEL + TRANSITION, altitude));\n  color = mix(color, SAND_COLOR, smoothstep(SAND_LEVEL, SAND_LEVEL + TRANSITION / 2., altitude));\n  color = mix(color, TREE_COLOR, smoothstep(TREE_LEVEL, TREE_LEVEL + TRANSITION, altitude));\n  color = mix(color, ROCK_COLOR, smoothstep(ROCK_LEVEL, ROCK_LEVEL + TRANSITION, altitude));\n  color = mix(color, ICE_COLOR, smoothstep(ICE_LEVEL, ICE_LEVEL + TRANSITION, altitude));\n\n  vec3 cloudsCoord = rotateY(iTime * -.005) * rotatedCoord + vec3(iTime * .008);\n  float cloudsDensity = remap(domainWarpingFBM(cloudsCoord), -1.0, 1.0, 0.0, 1.0);\n  cloudsDensity *= smoothstep(.75, .85, cloudsDensity);\n  cloudsDensity *= smoothstep(ROCK_LEVEL, (ROCK_LEVEL + TREE_LEVEL) / 2., altitude);\n  color = mix(color, CLOUD_COLOR, cloudsDensity);\n\n  float specular = smoothstep(SAND_LEVEL + TRANSITION, SAND_LEVEL, altitude);\n\n  return Hit(len, normal, Material(color, 1., specular));\n}\n\nHit intersectMoon(Ray ray) {\n  vec3 moonPosition = currentMoonPosition();\n  float length = sphIntersect(ray, Sphere(moonPosition, MOON_RADIUS));\n\n  if(length < 0.) {\n    return miss;\n  }\n\n  vec3 position = ray.origin + length * ray.direction;\n  vec3 originalPosition = position * rotate3d(MOON_ROTATION_AXIS, -iTime * MOON_ROTATION_SPEED);\n  vec3 color = vec3(sqrt(fbm(originalPosition * 12., 6, .5, 2., 5.)));\n  vec3 normal = normalize(position - moonPosition);\n\n  return Hit(length, normal, Material(color, 1., 0.));\n}\n\nHit intersectScene(Ray ray) {\n  Hit planetHit = intersectPlanet(ray);\n  Hit moonHit = intersectMoon(ray);\n\n  if(moonHit.len < planetHit.len) {\n    return moonHit;\n  }\n\n  return planetHit;\n}\n\n\nvec3 radiance(Ray ray, inout float spaceMask) {\n  vec3 color = vec3(0.0);\n  vec3 attenuation = vec3(1.0);\n\n  for(int i = 1; i <= MAX_BOUNCES; i++) {\n    Hit hit = intersectScene(ray);\n\n    if(hit.len < INFINITY) {\n      spaceMask = 0.;\n\n      vec3 hitPosition = ray.origin + hit.len * ray.direction;\n      Hit shadowHit = intersectScene(Ray(hitPosition + EPSILON * SUN_DIR, SUN_DIR));\n      float hitDirectLight = clamp(\n        step(INFINITY, shadowHit.len) \n        + step(length(hitPosition - PLANET_POSITION) - PLANET_RADIUS, .1), // don't cast shadow on the planet, only the moon\n        0., \n        1.\n      );\n\n      // Diffuse\n      float directLightIntensity = pow(clamp(dot(hit.normal, SUN_DIR), 0.0, 1.0), 2.); // the power softens the shadow. Not physically accurate but it looks better to me\n      vec3 diffuseLight = hitDirectLight * directLightIntensity * SUN_COLOR;\n      vec3 diffuseColor = hit.material.color.rgb * (AMBIENT_LIGHT + diffuseLight);\n\n      // Phong specular\n      vec3 reflected = normalize(reflect(-SUN_DIR, hit.normal));\n      float phongValue = pow(max(0.0, dot(ray.direction, reflected)), 10.) * .6;\n      vec3 specularColor = hit.material.specular * vec3(phongValue);\n\n      color += attenuation * (diffuseColor + specularColor);\n\n      // Next bounce\n      attenuation *= hit.material.specular;\n\n      vec3 reflection = reflect(ray.direction, hit.normal);\n      ray = Ray(ray.origin + hit.len * ray.direction + EPSILON * reflection, reflection);\n\n    } else {\n      if(spaceMask == 1.) {\n        color += attenuation * spaceColor(ray.direction);\n      }\n      break;\n    }\n  }\n  return color;\n}\n\n//========//\n//  Main  //\n//========//\n\nvec3 atmosphereColor(vec3 ro, vec3 rd, float spaceMask) {\n  float planetDist = sphIntersect(Ray(ro, rd), planet);\n  float moonDist = sphIntersect(Ray(ro, rd), Sphere(currentMoonPosition(), MOON_RADIUS));\n  float closestHit = planetDist;\n  if (planetDist < 0. || moonDist >= 0. && moonDist < planetDist) {\n    closestHit = moonDist;\n  }\n  vec3 position = ro + closestHit * rd;\n  \n  float distCameraToPlanetOrigin = length(PLANET_POSITION - CAMERA_POSITION);\n  float distCameraToPlanetEdge = sqrt(distCameraToPlanetOrigin * distCameraToPlanetOrigin - PLANET_RADIUS * PLANET_RADIUS);\n  float distCameraToMoon = length(currentMoonPosition() - CAMERA_POSITION);\n  float isMoonInFront = smoothstep(-PLANET_RADIUS/2., PLANET_RADIUS/2., distCameraToPlanetEdge - distCameraToMoon);\n\n  float moonMask = (1.0 - spaceMask) * step(PLANET_RADIUS + EPSILON, length(position - PLANET_POSITION));\n  float planetMask = 1.0 - spaceMask - moonMask;\n\n  vec3 coordFromCenter = (ro + rd * distCameraToPlanetEdge) - PLANET_POSITION;\n  float distFromEdge = abs(length(coordFromCenter) - PLANET_RADIUS);\n  float planetEdge = max(1. - distFromEdge, 0.);\n  float atmosphereDensity = pow(remap(dot(SUN_DIR, coordFromCenter), -2., 1., 0., 1.), 5.);\n\n  vec3 atmosphere = pow(planetEdge, 80.) * ATMOSPHERE_COLOR;\n  atmosphere += pow(planetEdge, 30.) * ATMOSPHERE_COLOR * (1.5 - planetMask);\n  atmosphere += pow(planetEdge, 4.) * ATMOSPHERE_COLOR * .02;\n  atmosphere += pow(planetEdge, 2.) * ATMOSPHERE_COLOR * .1 * planetMask;\n\n  return atmosphere * atmosphereDensity * (1. - moonMask * isMoonInFront);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord / iResolution.xy - 0.5) * iResolution.xy / iResolution.y;\n\n  vec3 ro = vec3(CAMERA_POSITION);\n  vec3 rd = normalize(vec3(uv.x, uv.y, -1));\n  Ray ray = Ray(ro, rd);\n\n  float spaceMask = 1.;\n\n  vec3 color = radiance(ray, spaceMask);\n\n  color += atmosphereColor(ro, rd, spaceMask);\n\n  // color grading\n  color = simpleReinhardToneMapping(color);\n\n  // vignette\n  color *= 1. - 0.5 * pow(length(uv), 3.);\n\n  fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}