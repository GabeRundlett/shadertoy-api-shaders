{
    "Shader": {
        "info": {
            "date": "1582837268",
            "description": "The 5 hexagonal symmetry wallpaper groups.\n\n<mouse>: offset into texture\n<up>,<down>: zoom in/out\na,b,c: enable symmetry ops\nx,y,z: show lines of symmetry\ni: invert at mouse\nf: position dependency",
            "flags": 48,
            "hasliked": 0,
            "id": "WsjXWm",
            "likes": 17,
            "name": "Hexagonal Symmetry Wallpaper",
            "published": 3,
            "tags": [
                "patterns",
                "hexagonal",
                "wallpaper"
            ],
            "usePreview": 1,
            "username": "mla",
            "viewed": 553
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Hexagonal symmetry wallpaper patterns.\n// Matthew Arcus, 2020\n//\n// Map to repeated region of two equilateral triangles\n// Apply various symmetry operations to triangles to get 5 basic groups.\n// See: https://en.wikipedia.org/wiki/Wallpaper_group for more details.\n//\n// Controls:\n// mouse: change offset of texture map\n// a,b,c: apply different symmetry operations\n// x,y,z: show lines of symmetry\n// i: invert at mouse position\n// r: show fundamental region in blue\n// f: vary texture offset by position\n//\n// The \"repeated unit\" for hexagonally symmetric wallpaper is a rhombus,\n// composed of two equilateral triangles, let's call them A and B, and we\n// want to arrange them so A points up, B points down, their bases are on\n// the x-axis and they are centred around the y-axis.\n//\n// For the whole pattern to be rotationally symmetric, A and B must also be,\n// so we first map the plane into A and B with a skew and modulus operation,\n// then map B into A with a rotation (but remember if we did so). Dividing A\n// up into 6 sectors, rotate the top 4 into the bottom 2, then rotate points\n// that came from B back again. Now all points are mapped to a rhomboidal\n// \"basic fundamental region\", centred on the the origin, that by itself\n// gives tiling p3.\n//\n// This region may also itself have symmetry operations applied - rotating\n// points in B back into A gives p6 (key 'a'), reflecting in x-axis gives\n// p3m1 (key 'b'), reflecting in y-axis gives p31m (key 'c'), and combining \n// both reflections gives p6m.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float X = 1.732050808; // sqrt(3)\nconst float Y = 0.577350269; // 1/sqrt(3)\n\nbool alert = false;\nvoid assert(bool x) {\n  if (!x) alert = true;\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_F = 70;\nconst int CHAR_I = 73;\nconst int CHAR_R = 82;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nvec3 getcolor(vec2 z0, vec2 z) {\n  vec2 offset = vec2(0.5);\n  if (iMouse.x > 0.0) {\n    offset += 4.0*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  }\n  z = rotate(z,0.1*iTime);\n  z -= offset;\n  if (keypress(CHAR_F)) z += 0.1*z0;\n  vec3 col = textureLod(iChannel2,z,1.0).xyz;\n  col *= 2.0;\n  col.xyz = col.yzx;\n  return col;\n}\n\n// M maps a square grid to a grid of equilateral triangles\nconst mat2 M = 0.5*mat2(1,-X,1,X);\nconst mat2 Minv = Y*mat2(X,X,-1,1);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  float scale = exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  z *= scale;\n\n  if (keypress(CHAR_I)) {\n    vec2 m = (2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n    z -= m;\n    z /= dot(z,z);\n    z += m;\n  }\n  \n  vec2 z0 = z; // Save the initial position\n  z.x += 0.5;\n  z = Minv*z; // Convert to square grid\n  ivec2 index = ivec2(floor(z)); // Remember cell in grid\n  z -= floor(z);\n  z = M*z; // Back to triangles\n\n  // Map to equilateral triangles [(0,0),(1,0),(0.5,0.866)],[(0,0),(1,0),(0.5,-0.866)]\n  z.x -= 0.5;\n  bool inlower = z.y < 0.0; // Point is in lower triangle,\n  if (inlower) z = -z;      // so rotate to upper triangle\n\n  // All patterns have rotational symmetry about triangle centre, so:\n  // map centre of triangle to origin...\n  z.y -= 0.5*Y;\n\n  // ...and reflect in planes of symmetry of triangle\n  const vec2 A = 0.5*(vec2(1,X));  // normalized\n  const vec2 B = 0.5*(vec2(-1,X)); // normalized\n  float ta = dot(z,A);\n  z -= 2.0*max(ta,0.0)*A;\n  float tb = dot(z,B);\n  z -= 2.0*max(tb,0.0)*B;\n  // If we have done just one reflection, reflect\n  // in y-axis so we always have just a rotation.\n  bool parity = (ta > 0.0) != (tb > 0.0);\n  if (parity) z.x = -z.x;\n\n  vec2 z1 = z; // Save position relative to centre of triangle\n\n  z.y += 0.5*Y;        // Shift origin back to region centre,\n  if (inlower) z = -z; // and rotate bottom half back\n\n  // Now we are in a basic rhomboidal region, centred on the origin.\n  // Apply extra symmetries to basic region\n  if (keypress(CHAR_A) && inlower) z = -z; // Rotate about origin\n  if (keypress(CHAR_B)) z.x = abs(z.x);  // Left-right mirror\n  if (keypress(CHAR_C)) z.y = abs(z.y);  // Up-down mirror - no effect after rotation\n  \n  vec3 col = getcolor(z0,z);\n\n  if (keypress(CHAR_R)) {\n    // If the point hasn't moved (much) we are in the fundamental region\n    bool inregion = length(z-z0) < 1e-4;\n    if (inregion) col.b = 1.0;\n  }\n\n  vec3 linecol = vec3(0.1);\n  if (!keypress(CHAR_X)) {\n    col = mix(linecol,col,smoothstep(0.0,0.02,abs(dot(z1,B))));\n    col = mix(linecol,col,smoothstep(0.0,0.02,abs(dot(z1,A))));\n  }\n  if (keypress(CHAR_Y)) col = mix(linecol,col,smoothstep(0.0,0.02,abs(z.x)));\n  if (keypress(CHAR_Z)) col = mix(linecol,col,smoothstep(0.0,0.02,abs(z.y)));\n\n  if (alert) col.x = 1.0;\n  fragColor = vec4(col,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}