{
    "Shader": {
        "info": {
            "date": "1728110420",
            "description": "originals  https://www.shadertoy.com/view/MdXSzS https://www.shadertoy.com/view/McsXz8https://www.shadertoy.com/view/lXffR4",
            "flags": 1,
            "hasliked": 0,
            "id": "43lfRN",
            "likes": 0,
            "name": " dodecahedron in galaxy warp",
            "published": 3,
            "tags": [
                "dodecahedron",
                "cosmic",
                "fmb"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 13
        },
        "renderpass": [
            {
                "code": "\n\n#define iterations 15\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nfloat focus = 0.;\nfloat focus2 = 0.;\n#define pi  3.14159265\n\nfloat random(vec2 p) {\n    //a random modification of the one and only random() func\n    return fract( sin( dot( p, vec2(12., 90.)))* 1e6 );\n}\n     \n\nfloat noise(vec3 p) {\n    vec2 i = floor(p.yz);\n    vec2 f = fract(p.yz);\n    float a = random(i + vec2(0.,0.));\n    float b = random(i + vec2(1.,0.));\n    float c = random(i + vec2(0.,1.));\n    float d = random(i + vec2(1.,1.));\n    vec2 u = f*f*(3.-2.*f);\n    \n    return mix(a,b,u.x) + (c-a)*u.y*(1.-u.x) + (d-b)*u.x*u.y;\n\n}\n\n\n\n    const int octaves = 6;\n\n\n\n    vec2 random2(vec2 st){\n      vec2 t = vec2(texture(iChannel0, st/1023.).x, texture(iChannel0, st/1023.+.5).x);\n      return t*t*4.;\n    }\n\n    // Value Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/lsf3WH\n    float noise(vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        vec2 u = f*f*(3.0-2.0*f);\n\n        return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                         dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                    mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                         dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    }\n  \n    float fbm1(in vec2 _st) {\n      float v = 0.0;\n      float a = 0.5;\n      vec2 shift = vec2(100.0);\n      // Rotate to reduce axial bias\n      mat2 rot = mat2(cos(0.5), sin(0.5),\n                      -sin(0.5), cos(0.50));\n      for (int i = 0; i < octaves; ++i) {\n          v += a * noise(_st);\n          _st = rot * _st * 2.0 + shift;\n          a *= 0.4;\n      }\n      return v;\n    }\n  \n    float pattern(vec2 uv, float time, inout vec2 q, inout vec2 r) {\n\n      q = vec2( fbm1( uv * .1 + vec2(0.0,0.0) ),\n                     fbm1( uv + vec2(5.2,1.3) ) );\n\n      r = vec2( fbm1( uv * .1 + 4.0*q + vec2(1.7 - time / 2.,9.2) ),\n                     fbm1( uv + 4.0*q + vec2(8.3 - time / 2.,2.8) ) );\n\n      vec2 s = vec2( fbm1( uv + 5.0*r + vec2(21.7 - time / 2.,90.2) ),\n                     fbm1( uv * .05 + 5.0*r + vec2(80.3 - time / 2.,20.8) ) ) * .25;\n\n      return fbm1( uv * .05 + 4.0 * s );\n    }\n\n\n  vec2 getScreenSpace() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n    \n    return uv;\n  }\nfloat fbm3d(vec3 p) {\n    float v = 0.;\n    float a = .5;\n    vec3 shift = vec3(focus - focus2);  //play with this\n    \n    float angle = pi/7. ;\n    float cc=cos(angle), ss=sin(angle);  \n    mat3 rot = mat3( cc,  0., ss, \n                      0., 1., 0.,\n                     -ss, 0., cc );\n                     \n    for (float i=0.; i<4.; i++) {\n        v += a * noise(p);\n        p = rot * p * 2. + shift;\n        a *= .6*(1.+ 4.*(focus+focus2));  //changed from the usual .5\n    }\n    return v;\n}\n\n           \n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; \n            p.xy*=mat2(cos(iTime*0.03),sin(iTime*0.03),-sin(iTime*0.03),cos(iTime*0.03) );// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \n\n#define O(x,a,b) (smoothstep(0., 1., cos(x*6.2832)*.5+.5)*(a-b)+b)  // oscillate x between a & b\n#define A(v) mat2(cos((v*3.1416) + vec4(0, -1.5708, 1.5708, 0)))          // rotate\n#define s(a, b) c = max(c, .006/abs(L( u, K(a, v, h), K(b, v, h) )+.02)); // segment\n\n\n// line\nfloat L(vec2 p, vec3 A, vec3 B)\n{\n    vec2 a = A.xy, \n         b = B.xy - a;\n         p -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return length(p - b*h) + .01*mix(A.z, B.z, h);\n}\n\n// cam\nvec3 K(vec3 p, mat2 v, mat2 h)\n{\n    p.zy *= v; // pitch\n    p.zx *= h; // yaw\n    p *= 5. / (p.z+5.); // perspective view\n    return p;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n\n\n\n float coord_scale = 1.;\n\n    vec2 mm = (2.*iTime-iResolution.xy)/iResolution.y;\n\n   \nvec2 uv2 = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    uv2 *= coord_scale;\n    mm *= coord_scale;\n\n    vec3 rd = normalize( vec3(uv2, -2.) );  \n    vec3 ro = vec3(0);\n // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv3 = getScreenSpace();\n\n      \n      float time3 = iTime / 10.;\n      \n      mat2 rot = mat2(cos(time3 / 10.), sin(time3 / 10.),\n                      -sin(time3 / 10.), cos(time3 / 10.));\n      \n      float t3 = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = sin(t3);\n\tfloat co = cos(t3);\n\tmat2 ma = mat2(co, si, -si, co);\n    uv3*=ma;\n      uv3 = rot * uv3;\n      uv3 *= 0.9 * (sin(time)) + 3.;\n      uv3.x -= time / 5.;\n      \n      vec2 q = vec2(0.,0.);\n      vec2 r = vec2(0.,0.);\n      \n      float _pattern = 0.;\n      \n      \n    _pattern = pattern(uv3, time, q, r);\n    \n      vec3 colour = vec3(_pattern) * 2.;\n      colour.r -= dot(q, r) * 15.;\n      colour = mix(colour, vec3(pattern(r, time, q, r), dot(q, r) * 15., -0.1), .5);\n      colour -= q.y * 1.5;\n      colour = mix(colour, vec3(.2, .2, .2), (clamp(q.x, -1., 0.)) * 3.);\n    ro.z -= iTime*.4;\n    \n    vec3 q2;    \n    \n    float i=0., stepsize2=1.;\n    vec3 cc=vec3(0);\n    vec3 p=ro;\n    for (; i<20.; i++) {\n        \n        p += rd * stepsize2;\n     \n        focus = length(p-vec3(8.*mm.x,6.*mm.y,ro.z-20.));\n        focus = exp(-focus/7.);\n        \n        focus2 = length(p-vec3(-8.*mm.x,-6.*mm.y,ro.z-20.));\n        focus2 = exp(-focus2/7.);\n        \n        \n        q2.x = fbm3d(p);\n        q2.y = fbm3d(p.yzx);\n        q2.z = fbm3d(p.zxy);\n        \n        float f = fbm3d(p + q2);\n       \n        cc += q2 * f * exp(-i*i*1000.);\n    }\n    \n    cc.r += 3.*focus*focus; cc.g+= 2.*focus; cc.b += 2.5*focus2; cc.r +=3.*focus2;    \n    cc /= 2.;\nvec2 U=fragCoord;\nvec2 R = iResolution.xy,\n         u = (U-R/2.)/R.y*5.,\n         m = (iTime*200.-R)/R.y;\n    \n    float t = iTime/180.,\n          o = t*8., // shape shift timer\n          x, y, z;\n  \n    \n    mat2 v = A(m.y), // pitch\n         h = A(m.x); // yaw\n    \n    vec3 c = vec3(0), p3;\n    \n    if (mod(o, 4.) < 2.)  // swap between polyhedra\n    {\n      \n        p3 = vec3(.382, -.618, 1); // dodecahedron\n        //p = vec3(1, .618, .382);  // stellated icosahedron\n        x = p3.x; y = p3.y; z = p3.z;\n\n        s( vec3(-z,  x,  0), vec3(-z, -x,  0) )\n        s( vec3( z,  x,  0), vec3( z, -x,  0) )\n        s( vec3(-z,  x,  0), vec3( y, -y, -y) )\n        s( vec3(-z,  x,  0), vec3( y, -y,  y) )\n        s( vec3(-z, -x,  0), vec3( y,  y, -y) )\n        s( vec3(-z, -x,  0), vec3( y,  y,  y) )\n        s( vec3( z,  x,  0), vec3(-y, -y,  y) )\n        s( vec3( z,  x,  0), vec3(-y, -y, -y) )\n        s( vec3( z, -x,  0), vec3(-y,  y,  y) )\n        s( vec3( z, -x,  0), vec3(-y,  y, -y) )\n        s( vec3( x,  0, -z), vec3(-x,  0, -z) )\n        s( vec3( x,  0,  z), vec3(-x,  0,  z) )\n        s( vec3( x,  0, -z), vec3(-y,  y,  y) )\n        s( vec3( x,  0, -z), vec3(-y, -y,  y) )\n        s( vec3(-x,  0, -z), vec3( y, -y,  y) )\n        s( vec3(-x,  0, -z), vec3( y,  y,  y) )\n        s( vec3( x,  0,  z), vec3(-y,  y, -y) )\n        s( vec3( x,  0,  z), vec3(-y, -y, -y) )\n        s( vec3(-x,  0,  z), vec3( y,  y, -y) )\n        s( vec3(-x,  0,  z), vec3( y, -y, -y) )\n        s( vec3( 0,  z,  x), vec3( 0,  z, -x) )\n        s( vec3( 0, -z,  x), vec3( 0, -z, -x) )\n        s( vec3( 0,  z,  x), vec3( y, -y, -y) )\n        s( vec3( 0,  z,  x), vec3(-y, -y, -y) )\n        s( vec3( 0,  z, -x), vec3( y, -y,  y) )\n        s( vec3( 0,  z, -x), vec3(-y, -y,  y) )\n        s( vec3( 0, -z,  x), vec3( y,  y, -y) )\n        s( vec3( 0, -z,  x), vec3(-y,  y, -y) )\n        s( vec3( 0, -z, -x), vec3(-y,  y,  y) )\n        s( vec3( 0, -z, -x), vec3( y,  y,  y) )\n    }\n    else\n    {\n        //o += .5;\n        p3 = vec3( 0, \n                  O(o, 1., .618), \n                  O(o, -.618, 1.));\n      \n        x = p3.x; y = p3.y; z = p3.z;\n\n        s( vec3(-y,  z,  0), vec3( 0, -y, -z) )\n        s( vec3(-y,  z,  0), vec3( 0, -y,  z) )\n        s( vec3( y,  z,  0), vec3( 0, -y, -z) )\n        s( vec3( y,  z,  0), vec3( 0, -y,  z) )\n        s( vec3(-y, -z,  0), vec3( 0,  y, -z) )\n        s( vec3(-y, -z,  0), vec3( 0,  y,  z) )\n        s( vec3( y, -z,  0), vec3( 0,  y, -z) )\n        s( vec3( y, -z,  0), vec3( 0,  y,  z) )\n        s( vec3(-y,  z,  0), vec3( z,  0, -y) )\n        s( vec3(-y,  z,  0), vec3( z,  0,  y) )\n        s( vec3( y,  z,  0), vec3(-z,  0, -y) )\n        s( vec3( y,  z,  0), vec3(-z,  0,  y) )\n        s( vec3(-y, -z,  0), vec3( z,  0, -y) )\n        s( vec3(-y, -z,  0), vec3( z,  0,  y) )\n        s( vec3( y, -z,  0), vec3(-z,  0, -y) )\n        s( vec3( y, -z,  0), vec3(-z,  0,  y) )\n        s( vec3( y,  z,  0), vec3( y, -z,  0) )\n        s( vec3(-y, -z,  0), vec3(-y,  z,  0) )\n        s( vec3( 0, -y, -z), vec3( 0, -y,  z) )\n        s( vec3( 0,  y, -z), vec3( 0,  y,  z) )\n        s( vec3( 0,  y, -z), vec3( z,  0,  y) )\n        s( vec3( 0,  y, -z), vec3(-z,  0,  y) )\n        s( vec3( 0, -y, -z), vec3( z,  0,  y) )\n        s( vec3( 0, -y, -z), vec3(-z,  0,  y) )\n        s( vec3(-z,  0, -y), vec3( z,  0, -y) )\n        s( vec3(-z,  0,  y), vec3( z,  0,  y) )\n        s( vec3(-z,  0, -y), vec3( 0,  y,  z) )\n        s( vec3(-z,  0, -y), vec3( 0, -y,  z) )\n        s( vec3( z,  0, -y), vec3( 0,  y,  z) )\n        s( vec3( z,  0, -y), vec3( 0, -y,  z) )\n    }\n    c *= pow( O(t*4., 0., 1.), .1 );  // darken at shape swap\n\tvec3 from=vec3(1.,.5,0.5)+cc* colour+c;\n\t\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor*= vec4(happy_star(rd.xy, anim) * vec3(0.35,0.2,0.35)*0.2, 1.0);\n    fragColor+=vec4(cc*c*10.,1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}