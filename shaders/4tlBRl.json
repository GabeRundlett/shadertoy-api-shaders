{
    "Shader": {
        "info": {
            "date": "1512914905",
            "description": "Use Jacobi elliptical function sn for halfplane->rectangle conformal mapping.\n\nUnderlying image is Jos Leys' Kleinian set shader, [url]https://www.shadertoy.com/view/MtKXRh[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "4tlBRl",
            "likes": 25,
            "name": "Jacobi Elliptic Function",
            "published": 3,
            "tags": [
                "kleinian",
                "conformal",
                "elliptic",
                "jacobi"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 1037
        },
        "renderpass": [
            {
                "code": "// Use Jacobi elliptical function sn for halfplane->rectangle conformal\n// mapping.\n// sn is parameterized on k2, which determines the aspect ratio of the\n// rectangle. findk2 function uses bisection of find the appropriate\n// value for the image dimensions. See:\n// http://users.mai.liu.se/hanlu09/complex/elliptic/\n// https://en.wikipedia.org/wiki/Jacobi_elliptic_functions\n// https://en.wikipedia.org/wiki/Arithmetic%E2%80%93geometric_mean\n\n// Underlying image is Jos Leys' Kleinian set shader,\n// https://www.shadertoy.com/view/MtKXRh, with some simple anti-aliasing\n// and texturing added.\n\nconst float PI =  3.141592654;\n\n// Taken from Numerical Recipes, simplified by using a fixed number\n// of iterations and removing negative modulus case.\n// Modulus is passed in as k^2 (not 1-k^2 as in NR).\nvoid sncndn(float u, float k2,\n            out float sn, out float cn, out float dn) {\n  float emc = 1.0-k2;\n  float a,b,c;\n  const int N = 4;\n  float em[N],en[N];\n  a = 1.0;\n  dn = 1.0;\n  for (int i = 0; i < N; i++) {\n    em[i] = a;\n    emc = sqrt(emc);\n    en[i] = emc;\n    c = 0.5*(a+emc);\n    emc = a*emc;\n    a = c;\n  }\n  // Nothing up to here depends on u, so\n  // could be precalculated.\n  u = c*u; sn = sin(u); cn = cos(u);\n  if (sn != 0.0) {\n    a = cn/sn; c = a*c;\n    for(int i = N-1; i >= 0; i--) {\n      b = em[i];\n      a = c*a;\n      c = dn*c;\n      dn = (en[i]+a)/(b+a);\n      a = c/b;\n    }\n    a = 1.0/sqrt(c*c + 1.0);\n    if (sn < 0.0) sn = -a;\n    else sn = a;\n    cn = c*sn;\n  }\n}\n\n// Complex sn. uv are coordinates in a rectangle, map to\n// the upper half plane with a Jacobi elliptic function.\n// Note: uses k^2 as parameter.\nvec2 sn(vec2 z, float k2) {\n  float snu,cnu,dnu,snv,cnv,dnv;\n  sncndn(z.x,k2,snu,cnu,dnu);\n  sncndn(z.y,1.0-k2,snv,cnv,dnv);\n  float a = 1.0/(1.0-dnu*dnu*snv*snv);\n  return a*vec2(snu*dnv, cnu*dnu*snv*cnv);\n}\n\n// We don't use cn and dn, but just for reference:\nvec2 cn(vec2 z, float k2) {\n  float snu,cnu,dnu,snv,cnv,dnv;\n  sncndn(z.x,k2,snu,cnu,dnu);\n  sncndn(z.y,1.0-k2,snv,cnv,dnv);\n  float a = 1.0/(1.0-dnu*dnu*snv*snv);\n  return a*vec2(cnu*cnv,-snu*dnu*snv*dnv);\n}\n\nvec2 dn(vec2 z, float k2) {\n  float snu,cnu,dnu,snv,cnv,dnv;\n  sncndn(z.x,k2,snu,cnu,dnu);\n  sncndn(z.y,1.0-k2,snv,cnv,dnv);\n  float a = 1.0/(1.0-dnu*dnu*snv*snv);\n  return a*vec2(dnu*cnv*dnv,-k2*snu*cnu*snv);\n}\n\n// Arithmetic-geometric mean\nfloat agm(float a, float g) {\n  for (int i = 0; i < 6; i++) {\n    float a1 = 0.5*(a+g);\n    float g1 = sqrt(a*g);\n    a = a1; g = g1;\n  }\n  return a;\n}\n\nfloat eval(float k2) {\n  float yperiod = 0.5*PI/agm(1.0,sqrt(k2));\n  float xperiod = PI/agm(1.0,sqrt(1.0-k2));\n  return xperiod/yperiod;\n}\n\n// a is desired aspect ratio,\n// find appropriate value of k2\nfloat findk2(float a) {\n  float lower = 0.0, upper = 1.0;\n  for (int i = 0; i < 20; i++) {\n    float mid = (upper + lower)/2.0;\n    if (eval(mid) < a) lower = mid;\n    else upper = mid;\n  }\n  return 0.5*(lower+upper);\n}\n\n// This section lightly modified from code by Jos Leys\n// https://www.shadertoy.com/view/MtKXRh\n\nvec3 backgroundColor = vec3(0.1); //vec3(0.1,0.0,0.2);\n\nfloat box_size_x=1.;\n\nfloat wrap(float x, float a, float s){\n        x -= s; \n        return (x-a*floor(x/a)) + s;\n}\n\nvoid TransA(inout vec2 z, float a, float b) {\n        float iR = 1. / dot(z,z);\n        z *= -iR;\n        z.x = -b - z.x; z.y = a + z.y; \n}\n\nvec3 JosKleinian(vec2 z, float KleinR, float KleinI) {\n  vec2 lz=z+vec2(1.), llz=z+vec2(-1.);\n  float flag=0.;\n      \n  float a = KleinR;\n  float b = KleinI;\n  float f = sign(b)*1.0;     \n  for (int i = 0; i < 100 ; i++) {\n      z.x=z.x+f*b/a*z.y;\n      z.x = wrap(z.x, 2. * box_size_x, - box_size_x);\n      z.x=z.x-f*b/a*z.y;\n                       \n      //If above the separation line, rotate by 180Â° about (-b/2, a/2)\n      if  (z.y >= a * 0.5 + f *(2.*a-1.95)/4. * sign(z.x + b * 0.5) *\n           (1. - exp(-(7.2-(1.95-a)*15.)* abs(z.x + b * 0.5)))) {\n        z = vec2(-b, a) - z;\n      }\n        \n      vec2 z0 = z;\n\n      //Apply transformation a\n      TransA(z, a, b);\n                \n      //If the iterated points enters a 2-cycle , bail out.\n      if(dot(z-llz,z-llz) < 1e-6) break;\n      //if the iterated point gets outside z.y = 0 and z.y = a\n      if (z.y < 0.0) {\n        return 0.3+texture(iChannel0,z0+0.5).xyz;\n      } else if (z.y > a) {\n        return 0.3+texture(iChannel0,z0-0.5).xyz;\n      }\n      //Store previous iterates\n      llz=lz; lz=z;\n    }\n\n  return backgroundColor;\n}\n\n\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec2 uv = fragCoord.xy / iResolution.xy;\n  uv = (1.99)*uv-vec2(0.42,.0);\n   \n  uv.x *= iResolution.x/iResolution.y;\n  float hit=JosKleinian(uv);\n  vec3 c =(1.0-hit)*background1Color+hit*color3;\n  \n  fragColor = vec4(c, 1.0);\n}\n#endif\n\n// End of Jos Leys' section.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Magic numbers from JL\n  float KleinR = 1.8462756+(1.958591-1.8462756)*0.5+0.5*(1.958591-1.8462756)*sin(-iTime*0.2);  \n  float KleinI = 0.09627581+(0.0112786-0.09627581)*0.5+0.5*(0.0112786-0.09627581)*sin(-iTime*0.2);\n\n  float k2 = findk2(float(iResolution.x)/float(iResolution.y));\n  float yperiod = 0.5*PI/agm(1.0,sqrt(k2));\n  //float xperiod = PI/agm(1.0,sqrt(1.0-k2)); // Use iResolution.x for this!!!\n  vec3 color = vec3(0);\n  const int AA = 2;\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 aa = vec2(float(i),float(j))/float(AA);\n      aa.y *= iResolution.z; // Fix pixel aspect ratio\n      vec2 z = (fragCoord.xy + aa - 0.5*vec2(iResolution.x,0))/iResolution.y;\n      z *= yperiod;\n      z = sn(z,k2);\n      z.x += 0.1*iTime;\n      // Next 2 lines reflect the (0,a) strip in y direction\n      float a = KleinR;\n      z.y -= 2.0*a*floor(z.y/(2.0*a));\n      z.y = min(z.y,2.0*a-z.y);\n      color += JosKleinian(z, KleinR, KleinI);\n    }\n  }\n  fragColor = vec4(color/(float(AA)*float(AA)),1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}