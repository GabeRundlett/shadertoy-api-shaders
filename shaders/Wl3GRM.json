{
    "Shader": {
        "info": {
            "date": "1575842123",
            "description": "Just some experimenting with noise patterns. Tried replicating the pattern in the cross-section of a cut cabbage. SEIZURE WARNING: Don't stare at it for too long!",
            "flags": 0,
            "hasliked": 0,
            "id": "Wl3GRM",
            "likes": 9,
            "name": " Trippy Cabbage Pattern Thingy",
            "published": 3,
            "tags": [
                "noise",
                "perlin",
                "curl",
                "trippy"
            ],
            "usePreview": 0,
            "username": "piyushslayer",
            "viewed": 574
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926535\n\n// Hash functions by Dave_Hoskins\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * uvec2(1597334673U, 3812015801U);\n\tuint n = (q.x ^ q.y) * 1597334673U;\n\treturn float(n) * (1.0 / float(0xffffffffU));\n}\n\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*uvec2(1597334673U, 3812015801U);\n\tq = (q.x ^ q.y) * uvec2(1597334673U, 3812015801U);\n\treturn -1. + 2. * vec2(q) * (1.0 / float(0xffffffffU));\n}\n\n// Value noise by iq\nfloat valueNoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Curl noise from http://petewerner.blogspot.com/2015/02/intro-to-curl-noise.html\nvec2 curl(vec2 uv)\n{\n    vec2 eps = vec2(0., 1.);\n    \n    float n1, n2, a, b;\n    n1 = valueNoise(uv + eps);\n    n2 = valueNoise(uv - eps);\n    a = (n1 - n2) / (2. * eps.y);\n    \n    n1 = valueNoise(uv + eps.yx);\n    n2 = valueNoise(uv - eps.yx);\n    b = (n1 - n2)/(2. * eps.y);\n    \n    return vec2(a, -b);\n}\n\n// rotate uv based on polar coords\nvec2 swirl(vec2 uv, float tht){\n\tfloat t = atan(uv.y, uv.x) + tht;\n    float d = length(uv);\n    uv.x = cos(t) * d;\n    uv.y = sin(t) * d;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float cabbage = 0., scale = 8., bandingScale = 5., t = iTime * .5;\n    \n    uv = swirl(uv, .4 * length(2. * uv) + sin(t * .2)); // slightly swirly rotate uv;\n    uv *= scale;\n    uv += curl(uv) * 2.; //add curl noise to uv for distortion\n    cabbage += sin(uv.x + t);\n    cabbage += sin((uv.y + t) * .5);\n    cabbage += sin((uv.x * sin(t * .5) + uv.y * cos(t * .334)+ t) * .5); // rotating grid\n    uv += scale * .5 * vec2(sin(t * .334), cos(t * .5));\n    cabbage += sin(sqrt(dot(uv, uv) + 1.) + t);\n    cabbage = .5 + .5 * sin(cabbage * bandingScale * PI); // concentric sinusoid\n\n\tvec3 col = vec3(0.);\n    col += 2. * vec3(cos(PI * (cabbage + .5 * t)), sin(PI * (cabbage + 1.167 * t)),\n                sin(PI * (cabbage + 1.834 * t)));\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}