{
    "Shader": {
        "info": {
            "date": "1413794195",
            "description": "stone generation",
            "flags": 0,
            "hasliked": 0,
            "id": "ldSSzV",
            "likes": 490,
            "name": "Wet stone",
            "published": 3,
            "tags": [
                "procedural",
                "noise",
                "rock",
                "wet",
                "stone"
            ],
            "usePreview": 0,
            "username": "TDM",
            "viewed": 41909
        },
        "renderpass": [
            {
                "code": "/*\n\"Wet stone\" by Alexander Alekseev aka TDM - 2014\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tdmaav@gmail.com\n*/\n\n#define SMOOTH\n//#define AA\n\nconst int NUM_STEPS = 32;\nconst int AO_SAMPLES = 4;\nconst vec2 AO_PARAM = vec2(1.2, 3.5);\nconst vec2 CORNER_PARAM = vec2(0.25, 40.0);\nconst float INV_AO_SAMPLES = 1.0 / float(AO_SAMPLES);\nconst float TRESHOLD \t= 0.1;\nconst float EPSILON \t= 1e-3;\nconst float LIGHT_INTENSITY = 0.25;\nconst vec3 RED \t\t= vec3(1.0,0.7,0.7) * LIGHT_INTENSITY;\nconst vec3 ORANGE \t= vec3(1.0,0.67,0.43) * LIGHT_INTENSITY;\nconst vec3 BLUE \t= vec3(0.54,0.77,1.0) * LIGHT_INTENSITY;\nconst vec3 WHITE \t= vec3(1.2,1.07,0.98) * LIGHT_INTENSITY;\n\nconst float DISPLACEMENT = 0.1;\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nvec3 saturation(vec3 c, float t) {\n    return mix(vec3(dot(c,vec3(0.2126,0.7152,0.0722))),c,t);\n}\nfloat hash11(float p) {\n    return fract(sin(p * 727.1)*435.545);\n}\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*437.545);\n}\nvec3 hash31(float p) {\n\tvec3 h = vec3(127.231,491.7,718.423) * p;\t\n    return fract(sin(h)*435.543);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\n// fBm\nfloat fbm3(vec3 p, float a, float f) {\n    return noise_3(p);\n}\n\nfloat fbm3_high(vec3 p, float a, float f) {\n    float ret = 0.0;    \n    float amp = 1.0;\n    float frq = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float n = pow(noise_3(p * frq),2.0);\n        ret += n * amp;\n        frq *= f;\n        amp *= a * (pow(n,0.2));\n    }\n    return ret;\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(max(dot(n,l),0.0),p); }\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// distance functions\nfloat plane(vec3 gp, vec4 p) {\n\treturn dot(p.xyz,gp+p.xyz*p.w);\n}\nfloat sphere(vec3 p,float r) {\n\treturn length(p)-r;\n}\nfloat capsule(vec3 p,float r,float h) {\n    p.y -= clamp(p.y,-h,h);\n\treturn length(p)-r;\n}\nfloat cylinder(vec3 p,float r,float h) {\n\treturn max(abs(p.y/h),capsule(p,r,h));\n}\nfloat box(vec3 p,vec3 s) {\n\tp = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\nfloat rbox(vec3 p,vec3 s) {\n\tp = abs(p)-s;\n    return length(p-min(p,0.0));\n}\nfloat quad(vec3 p,vec2 s) {\n\tp = abs(p) - vec3(s.x,0.0,s.y);\n    return max(max(p.x,p.y),p.z);\n}\n\n// boolean operations\nfloat boolUnion(float a,float b) { return min(a,b); }\nfloat boolIntersect(float a,float b) { return max(a,b); }\nfloat boolSub(float a,float b) { return max(a,-b); }\n\n// smooth operations. thanks to iq\nfloat boolSmoothIntersect(float a, float b, float k ) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(a,b,h) + k*h*(1.0-h);\n}\nfloat boolSmoothSub(float a, float b, float k ) {\n    return boolSmoothIntersect(a,-b,k);\n}\t\n\n// world\nfloat rock(vec3 p) {    \n    float d = sphere(p,1.0);    \n    for(int i = 0; i < 9; i++) {\n        float ii = float(i);\n        float r = 2.5 + hash11(ii);\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\n        #ifdef SMOOTH\n        d = boolSmoothSub(d,sphere(p+v*r,r * 0.8), 0.03);\n        #else\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));\n        #endif        \n    }\n    return d;\n}\n\nfloat map(vec3 p) {\n    float d = rock(p) + fbm3(p*4.0,0.4,2.96) * DISPLACEMENT;\n    d = boolUnion(d,plane(p,vec4(0.0,1.0,0.0,1.0)));\n    return d;\n}\n\nfloat map_detailed(vec3 p) {\n    float d = rock(p) + fbm3_high(p*4.0,0.4,2.96) * DISPLACEMENT;\n    d = boolUnion(d,plane(p,vec4(0.0,1.0,0.0,1.0)));\n    return d;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float dens) {\n    vec3 n;\n    n.x = map_detailed(vec3(p.x+EPSILON,p.y,p.z));\n    n.y = map_detailed(vec3(p.x,p.y+EPSILON,p.z));\n    n.z = map_detailed(vec3(p.x,p.y,p.z+EPSILON));\n    return normalize(n-map_detailed(p));\n}\nvec2 getOcclusion(vec3 p, vec3 n) {\n    vec2 r = vec2(0.0);\n    for(int i = 0; i < AO_SAMPLES; i++) {\n        float f = float(i)*INV_AO_SAMPLES;\n        float hao = 0.01+f*AO_PARAM.x;\n        float hc = 0.01+f*CORNER_PARAM.x;\n        float dao = map(p + n * hao) - TRESHOLD;\n        float dc = map(p - n * hc) - TRESHOLD;\n        r.x += clamp(hao-dao,0.0,1.0) * (1.0-f);\n        r.y += clamp(hc+dc,0.0,1.0) * (1.0-f);\n    }    \n    r.x = clamp(1.0-r.x*INV_AO_SAMPLES*AO_PARAM.y,0.0,1.0);\n    r.y = clamp(r.y*INV_AO_SAMPLES*CORNER_PARAM.y,0.0,1.0);\n    return r;\n}\nvec2 spheretracing(vec3 ori, vec3 dir, out vec3 p) {\n    vec2 td = vec2(0.0);\n    for(int i = 0; i < NUM_STEPS; i++) {\n        p = ori + dir * td.x;\n        td.y = map(p);\n        if(td.y < TRESHOLD) break;\n        td.x += (td.y-TRESHOLD) * 0.9;\n    }\n    return td;\n}\n\n// stone\nvec3 getStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\n    c = min(c + pow(noise_3(vec3(p.x*20.0,0.0,p.z*20.0)),70.0) * 8.0, 1.0);\n    float ic = pow(1.0-c,0.5);\n    vec3 base = vec3(0.42,0.3,0.2) * 0.35;\n    vec3 sand = vec3(0.51,0.41,0.32)*0.9;\n    vec3 color = mix(base,sand,c);\n        \n    float f = pow(1.0 - max(dot(n,-e),0.0), 5.0) * 0.75 * ic;    \n    color += vec3(diffuse(n,l,0.5) * WHITE);\n    color += vec3(specular(n,l,e,8.0) * WHITE * 1.5 * ic);\n    n = normalize(n - normalize(p) * 0.4);    \n    color += vec3(specular(n,l,e,80.0) * WHITE * 1.5 * ic);    \n    color = mix(color,vec3(1.0),f); \n    \n    color *= sqrt(abs(p.y*0.5+0.5)) * 0.4 + 0.6;\n    color *= (n.y * 0.5 + 0.5) * 0.4 + 0.6; \n    \n    return color;\n}\n\nvec3 getPixel(in vec2 coord, float time) {\n    vec2 iuv = coord / iResolution.xy * 2.0 - 1.0;\n    vec2 uv = iuv;\n    uv.x *= iResolution.x / iResolution.y;\n        \n    // ray\n    vec3 ang = vec3(0.0,0.2,time);\n    if(iMouse.z > 0.0) ang = vec3(0.0,clamp(2.0-iMouse.y*0.01,0.0,3.1415),iMouse.x*0.01);\n\tmat3 rot = fromEuler(ang);\n    \n    vec3 ori = vec3(0.0,0.0,2.8);\n    vec3 dir = normalize(vec3(uv.xy,-2.0));    \n    ori = ori * rot;\n    dir = dir * rot;\n    \n    // tracing\n    vec3 p;\n    vec2 td = spheretracing(ori,dir,p);\n    vec3 n = getNormal(p,td.y);\n    vec2 occ = getOcclusion(p,n);\n    vec3 light = normalize(vec3(0.0,1.0,0.0)); \n         \n    // color\n    vec3 color = vec3(1.0);    \n    if(td.x < 3.5 && p.y > -0.89) color = getStoneColor(p,occ.y,light,n,dir);\n    color *= occ.x;\n    return color;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime * 0.3;\n        \n#ifdef AA\n    vec3 color = vec3(0.0);\n    for(int i = -1; i <= 1; i++)\n    for(int j = -1; j <= 1; j++) {\n        vec2 uv = fragCoord+vec2(i,j)/3.0;\n        color += getPixel(uv, time);\n    }\n    color /= 9.0;\n#else\n    vec3 color = getPixel(fragCoord, time);\n#endif\n    color = sqrt(color);\n    color = saturation(color,1.7);\n               \n    // vignette\n    vec2 iuv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    float vgn = smoothstep(1.2,0.7,abs(iuv.y)) * smoothstep(1.1,0.8,abs(iuv.x));\n    color *= 1.0 - (1.0 - vgn) * 0.15;\t\n    \n\tfragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}