{
    "Shader": {
        "info": {
            "date": "1714293631",
            "description": "I'm not satisfied with distance function in https://www.shadertoy.com/view/MfKGWK\nSo I tried various thing, then I went a bit mad. (One can solve an order-4 poly to find exact distance I think. Me lazy.)",
            "flags": 0,
            "hasliked": 0,
            "id": "4f3Szs",
            "likes": 2,
            "name": "one over x",
            "published": 3,
            "tags": [
                "1x"
            ],
            "usePreview": 0,
            "username": "sedcore",
            "viewed": 114
        },
        "renderpass": [
            {
                "code": "/* 2024-04 - public domain */\n/* trying (too hard) to plot y=-1/x and going crazy */\n\n/* distance from a 2D point (a,b) to y=-1/x leads to\n * the order-4 polynomial:\n * x^4 - a x^3 - b x - 1 = 0\n * take the root (x,y) so that x>0 and dist((a,b),(x,y)) is min\n *\n * overkill\n *\n * let's try y+1/x as an approximation\n * works more or less, but not for small x\n *\n * so to deal with small x, let's try min(y+1/x, x)\n * works better, but still not very good for tiny tiny x\n *\n * so limit for x > .01, gives more or less nice result\n * (we have some noise, you can see in basic mode)\n *\n * then let's forget about all this and put some cos()\n * here and there\n */\n\n/* define BASIC for the basic mode */\n//#define BASIC\n\nfloat map(vec3 p)\n{\n#ifdef BASIC\n  float x = length(p.xz);\n#else\n  /* let's add a bit of cos() madness */\n  float x = length(p.xz)+(cos(iTime*3.)*.5+1.-2.);\n#endif\n  float y = p.y;\n  //those don't work well when x is close to 0 (what a surprise!)\n  //return y +1./x;\n  //return min(y+1./x, x);\n  //this one is better\n  return min(y+1./x, max(x,.01));\n}\n\nvec3 paletteA(vec2 p)\n{\n  vec2 q = vec2(length(p), atan(p.x,p.y)/atan(1.));\n  vec2 qb = abs(fract(4.*q+vec2(iTime*4., iTime*2.)) * 2. - 1.);\n  vec3 blue = vec3(.2,.7,1.);\n  vec2 alpha = exp(-qb*qb*20.);\n  return blue * length(alpha);\n}\n\nvec2 rot(vec2 v, float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c)*v; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n  \n  /* camera */\n  vec3 eye = vec3(0., 1., 3.);\n  vec3 target = vec3(0.,-1.3,0.);\n  float focal = 1.2;\n  vec3 ro = eye;\n  vec3 camera_center = ro + focal * normalize(target-ro);\n  vec3 rdx = vec3(1.,0.,0.);\n\n#ifndef BASIC\n  /* a bit of camera madness */\n  ro.xz = rot(ro.xz, iTime);\n  rdx.xz = rot(rdx.xz, iTime * 2.);\n#endif\n\n  vec3 rdy = normalize(cross(rdx, target-ro));\n  rdx/=1.8; rdy/=1.8;\n\n#ifndef BASIC\n  /* a bit more camera madness */\n  rdx.xy = rot(rdx.xy, iTime*2.);\n  rdy.xy = rot(rdy.xy, iTime*.8);\n#endif\n\n  vec3 rd = normalize(camera_center + rdx * uv.x + rdy * uv.y - ro);\n\n  /* raymarch */\n  float t = 0.;\n  int i;\n  float d;\n  vec3 p;\n  for (i = 0; i < 200; i++) {\n    p = ro + t * rd;\n    d = map(p);\n    if (d < 0.01) break;\n    //if (d > 100.) break;\n    t += d*.3;\n  }\n\n  /* colormap */\n  fragColor = vec4(paletteA(p.xz),1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}