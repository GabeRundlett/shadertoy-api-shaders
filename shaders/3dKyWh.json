{
    "Shader": {
        "info": {
            "date": "1602721140",
            "description": "Slightly modified smin function from the iq's article:\nhttps://iquilezles.org/articles/smin/smin.htm",
            "flags": 0,
            "hasliked": 0,
            "id": "3dKyWh",
            "likes": 13,
            "name": "Materials and smin",
            "published": 3,
            "tags": [
                "materials",
                "smin"
            ],
            "usePreview": 0,
            "username": "thepheer",
            "viewed": 589
        },
        "renderpass": [
            {
                "code": "struct Material {\n\tvec3 color;\n    float kr, kd, ks, kn;\n};\n\nMaterial mmix(Material a, Material b, float t) {\n    return Material(\n        mix(a.color, b.color, t),\n        mix(a.kr, b.kr, t),\n        mix(a.kd, b.kd, t),\n        mix(a.ks, b.ks, t),\n        mix(a.kn, b.kn, t)\n    );\n}\n\nMaterial materials[] = Material[] (\n\tMaterial(vec3(1.0, 2.0, 3.0), 0.2, 0.5, 0.0, 1.0),   // ground\n\tMaterial(vec3(0.1, 0.2, 2.0), 0.8, 1.0, 1.0, 500.0), // blue\n\tMaterial(vec3(2.0, 0.2, 0.1), 0.8, 1.0, 1.0, 500.0)  // red\n);\n\nvec2 mmin(vec2 a, vec2 b) { return a.x < b.x ? a : b; }\nvec2 mmax(vec2 a, vec2 b) { return a.x > b.x ? a : b; }\nvec2 msmin(vec2 a, vec2 b, float k) {\n    float h = clamp(0.5 + 0.5*(a.x - b.x)/k, 0.0, 1.0);\n    return mix(a, b, h) - vec2(k*h*(1.0 - h), 0.0);\n}\n\nvec2 map(vec3 p) {\n    vec2 ground = vec2(sdPlane(p, vec3(0.0, 1.0, 0.0), 1.0), 0.0);\n    vec2 blob = msmin(\n        vec2(sdSphere(p - vec3(1.0, 0.0, 0.0), 1.0), 1.0),\n        vec2(sdSphere(p + vec3(1.0, 0.0, 0.0), 1.0), 2.0),\n        1.0\n    );\n\treturn mmin(ground, blob);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p) {\n    vec3 k = vec3(1.0, -1.0, 1e-5);\n    vec3 a = k.xyy*map(p + k.z*k.xyy).x;\n    vec3 b = k.yyx*map(p + k.z*k.yyx).x;\n    vec3 c = k.yxy*map(p + k.z*k.yxy).x;\n    vec3 d = k.xxx*map(p + k.z*k.xxx).x;\n    return normalize(a + b + c + d);\n}\n\nstruct Raymarcher {\n    int steps;\n    float eps, near, far, t;\n    vec3 ro, rd, p;\n    vec2 m;\n};\n\nbool raymarch(inout Raymarcher rm) {\n    rm.t = rm.near;\n    for (int i = 0; i < rm.steps; i++) {\n        if (rm.t > rm.far) break;\n        rm.p = rm.ro + rm.t*rm.rd;\n        rm.m = map(rm.p);\n        if (rm.m.x < rm.eps) return true;\n        rm.t += rm.m.x;\n    }\n    return false;\n}\n\nvec3 render(vec2 uv) {\n    // camera position, target, forward, left, up\n    vec3 cp = 5.0*vec3(cos(iTime), 0.5, sin(iTime));\n    vec3 ct = vec3(0.0, -0.5, 0.0);\n    vec3 cf = normalize(ct - cp);\n    vec3 cl = normalize(cross(cf, vec3(0.0, 1.0, 0.0)));\n    vec3 cu = normalize(cross(cl, cf));\n    mat3 cm = mat3(cl, cu, cf);\n    \n    Raymarcher rm;\n    rm.steps = 1<<10;\n    rm.near = 1e-3;\n    rm.far = 1e+1;\n    rm.eps = 1e-4;\n    rm.ro = cp;\n    rm.rd = normalize(cm*vec3(uv, 2.5));\n    \n    Raymarcher rml = rm;\n    rml.near = 5e-3;\n    \n    vec3 ambient = 0.05*vec3(0.1, 0.2, 0.3);\n    vec3 light = 15.0*vec3(1.0);\n    vec3 fog = 2.0*ambient;\n    \n    vec3 color = vec3(0.0);\n    float alpha = 1.0;\n    \n    for (int i = 0; i < 5 && alpha > 1e-3; i++) {\n        if (raymarch(rm)) {\n            // blending two materials\n            Material ma = materials[int(floor(rm.m.y))];\n            Material mb = materials[int(ceil(rm.m.y))];\n            Material m = mmix(ma, mb, mod(rm.m.y, 1.0));\n            \n            vec3 n = normal(rm.p);\n            vec3 lp = vec3(-1.0, 3.0, 2.0) - rm.p;\n            vec3 ld = normalize(lp);\n            float ll = length(lp);\n\n            rml.far = ll;\n            rml.ro = rm.p;\n            rml.rd = ld;\n            float la = raymarch(rml) ? 0.0 : 1.0;\n\n            float diff = m.kd*max(0.0, dot(n, ld));\n            float spec = m.ks*pow(max(0.0, dot(rm.rd, reflect(ld, n))), m.kn);\n            vec3 c = ambient + la*(m.color*diff + spec)*light/(ll*ll);\n            c = mix(c, fog, rm.t/rm.far);\n\n            float a = m.kr*alpha;\n            color += a*c;\n            alpha -= a;\n            \n            rm.ro = rm.p;\n            rm.rd = reflect(rm.rd, n);\n        }\n        else {\n            color += alpha*fog;\n            break;\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 rgba, vec2 xy) {\n    vec2 r = iResolution.xy/iResolution.y;\n    vec2 uv = 2.0*xy/iResolution.xy - 1.0;\n    vec3 rgb = render(r*uv);\n    rgba = vec4(srgb(aces(rgb)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// https://iquilezles.org/articles/distfunctions\nfloat sdPlane(vec3 p, vec3 n, float h) {\n    return dot(p, n) + h;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// https://www.shadertoy.com/view/WdGcD1\nvec3 aces(vec3 color) {\t\n    mat3 x = mat3(+0.59719, +0.07600, +0.02840, +0.35458, +0.90834, +0.13383, +0.04823, +0.01566, +0.83777);\n    mat3 y = mat3(+1.60475, -0.10208, -0.00327, -0.53108, +1.10813, -0.07276, -0.07367, -0.00605, +1.07602);\n    vec3 v = x*color;    \n    vec3 a = v*(v + 0.0245786) - 0.000090537;\n    vec3 b = v*(0.983729*v + 0.4329510) + 0.238081;\n    return y*(a/b);\t\n}\n\nvec3 srgb(vec3 c) {\n    vec3 a = 1.055*pow(c, vec3(1.0/2.4)) - 0.055;\n    vec3 b = 12.92*c;\n    return mix(a, b, lessThanEqual(c, vec3(0.0031308)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}