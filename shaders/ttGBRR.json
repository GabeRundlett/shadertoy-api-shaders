{
    "Shader": {
        "info": {
            "date": "1613733684",
            "description": ":)",
            "flags": 0,
            "hasliked": 0,
            "id": "ttGBRR",
            "likes": 28,
            "name": "day 428",
            "published": 3,
            "tags": [
                "dots",
                "mograph",
                "chromab",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 590
        },
        "renderpass": [
            {
                "code": "// :)\n// in the vibe of https://twitter.com/beesandbombs\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define dmin(a,b) a.x < b.x ? a : b\n#define preplim(g,c,l) g-c*clamp(round((g)/c),-l,l)\n#define xor(a,b,c) min(max(a,-b), max(-a,b + c))\n\n\n\nfloat pixSz;\n\n// Hex code from BigWings! He has a tutorial on them.\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    return c;\n}\n\nvec4 HexCoords(vec2 uv, out vec2 gv) {\n\tvec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    gv = dot(a, a) < dot(b,b) ? a : b;\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec4(x, y, id.x,id.y);\n}\n\n\nfloat sdBox(vec2 p, vec2 s){\n    p = abs(p) - s; return max(p.x, p.y);\n}\nvoid getTile( vec2 p, out float d, inout vec3 col, vec2 gv, vec4 hc){\n    vec2 op = p;\n    for(float i = 0.; i < 3.; i++){\n        float t = iTime - i*.05;\n        p = op;\n        \n        float m =   + 0.3*sin( hc.z*1. + sin(hc.w + t)*0.4)*sin(t) + .4*( length(hc.zw) + sin(length(hc.w)*0.));\n        p *= rot(0. \n            + m - length(hc.zw)*0.9\n            + t*3.);\n\n        p.y += 0.5;\n        p.x -= sin(hc.w)*.5*(sin(m*1.14));\n        d = length(p) - sin(m*2. + t)*0.04 - 0.05;\n\n        col[int(i)] = mix( col[int(i)], 1., smoothstep(pixSz*2.,0.,d));\n    \n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 ouv = uv;\n    \n    uv *= 31.;\n    \n    //uv.y += iTime*0.5;\n    \n    pixSz = fwidth(uv.x);\n    \n    vec2 gv;\n    vec4 hc = HexCoords(uv, gv);\n    /*\n    float d = map(gv);\n    col += smoothstep(pixSz,0.,abs(d));\n    */\n    for(float i = 0.; i < 7.; i++){\n        vec2 offs = vec2(0);\n        \n        float ioffs = 0.;\n        if(i < 3. ){\n            float offsIdx = tau*(i + ioffs)/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        } else if( i == 3.) {\n        \n        } else if( i == 4. || i == 5.){\n            float offsIdx = tau*(i + ioffs - 1. + float(i == 5.)  )/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        \n        } else if( i == 6.){\n            float offsIdx = tau*(i + ioffs - 2.)/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        }\n        \n        vec4 hc = HexCoords(uv + offs, gv);\n        \n        float d; \n        getTile(gv - offs, d, col, uv - offs, hc);\n        \n        \n        \n    }\n    \n    \n    \n    col = max(col,0.);\n    col = mix(col,col*col*0.0,pow(smoothstep(0.,1.,dot(ouv,ouv)),1.5));\n\n    col *= vec3(1.,1.,1.);\n    \n    if( mod(iTime/10.,1.) > 0.66)\n        col = 1. - col;\n    if(iMouse.z > 0.5)\n        col = 1. - col;\n    col = pow(col,vec3(0.454545));\n    \n    \n    fragColor.xyz += col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": " \n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\n\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.9;\n    const float lacunarity = 1.5;\n    const int octaves = 6;\n    \n    const float warp = 0.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseMarb(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.75;\n    const int octaves = 9;\n    \n    const float warp = 0.7;    \n    float warpTrk = 2. ;\n    const float warpTrkGain = 1.09;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseMarbB(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.75;\n    const int octaves = 5;\n    \n    const float warp = .9;\n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.09;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}