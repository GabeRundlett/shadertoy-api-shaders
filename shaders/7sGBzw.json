{
    "Shader": {
        "info": {
            "date": "1657987801",
            "description": "Simple 3D Cube Grid Tiling rotated by 30 degree to have nice triangles and hexagons in 2D. ",
            "flags": 0,
            "hasliked": 0,
            "id": "7sGBzw",
            "likes": 6,
            "name": "Cubic Grid Tiling",
            "published": 3,
            "tags": [
                "3d",
                "grid",
                "triangle",
                "cube",
                "honeycomb",
                "tiling",
                "tessellation"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 199
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nSimple 3D Cubic Tiling. It looks like triangles and hexagons, because I rotated \nit a bit. What you see is the Edge Distance.\n\nThis project contains algorithms for the edge distance, center distance, ID and \nUVW coordinates of a cubeic honeycomb grid.\n\nThe caluclation for the cube gird is very fast. I wonder, if this is faster to \ncalculate 3D cubes and rotate them compated to making a 2D triangle grid the \nnormal way. Maybe I'll test that later.\n*/\n\n#define sqrt25 \t\t\t0.6324555320 //sqrt(2./5.)\n#define sqrt35 \t\t\t0.7745966692 //sqrt(3./5.)\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) {\n    vec3 d = abs(uvw); //mirroring along axis\n    return max(d.x, max(d.y, d.z))*2.; //*2. for 0-1 range\n}\n\n// Cube Tiling\nvec4 cubeTile(vec3 uvw) {\n    vec3 grid = fract(uvw)-.5; // centered UVW coords\n    float edist = 1.-cubeDist(grid); // edge distance\n    //float cdist = dot(grid,grid); //squared center distance\n    //vec3 id = uvw-grid; // Cells IDs\n\n    return vec4(grid, edist);\n}\n\n// scaled with offset cube tiling\nvec4 cubeCell(vec3 uvw, vec3 offset, float gridRes) {\n    vec4 cubeTiling = cubeTile(uvw*gridRes + offset);\n    vec3 tiledUV = (cubeTiling.xyz - offset)/gridRes; //cube pixaltion\n    \n    return vec4(tiledUV,cubeTiling.w);\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    // https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n    vec4 q;\n    vec3 c = cos(a * 0.5), s = sin(a * 0.5);\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    \n    // https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    vec3 qt = 2.0 * cross(q.xyz, v);\n    return v + q.w * qt + cross(q.xyz, qt);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) {\n    const vec3 c0 = vec3(0.207621,0.196195,0.618832);\n    const vec3 c1 = vec3(-0.088125,3.196170,-0.353302);\n    const vec3 c2 = vec3(8.261232,-8.366855,14.368787);\n    const vec3 c3 = vec3(-2.922476,33.244294,-43.419173);\n    const vec3 c4 = vec3(-34.085327,-74.476041,37.159352);\n    const vec3 c5 = vec3(50.429790,67.145621,-1.750169);\n    const vec3 c6 = vec3(-21.188828,-20.935464,-6.501427);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y; //square UV pattern\n    float time = (0.05*iTime); // used as z dimension  \n    float gridRes = 2.5; //size of cubes\n    \n    vec3 point = vec3(uv, time); //uvw cords\n    \n    //cosmetic rotate for fun triangles otherwise it looks so square\n    point = rotate(point, (vec3(sqrt25,sqrt35,0.))); //vec3 must be normalized\n    \n    vec4 a = cubeCell(point, vec3(0.), gridRes);  \n    \n    vec3 col = RdYlBu_r(a.w); // cosmetic Colormap\n    \n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}