{
    "Shader": {
        "info": {
            "date": "1692369354",
            "description": "you're awake but you can't move\nweird things start to happen",
            "flags": 40,
            "hasliked": 0,
            "id": "DdKGDV",
            "likes": 25,
            "name": "Sleep Paralysis [SOUND ON]",
            "published": 3,
            "tags": [
                "sound",
                "music",
                "horror",
                "sleep"
            ],
            "usePreview": 0,
            "username": "crocidb",
            "viewed": 439
        },
        "renderpass": [
            {
                "code": "// \n// Sleep Paralysis [SOUND ON]\n// \n// you're awake but you can't move\n// weird things start to happen\n// \n// by Bruno Croci\n// https://crocidb.com/\n// \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // uv distortion\n    uv += vec2(\n        texture(iChannel1, 0.3 * (uv + vec2(iTime * .11, iTime * .1))).r,\n        texture(iChannel1, 0.34 * (uv + vec2(iTime * .14, (iTime + 123.0) * .12))).r) * .02;\n    \n    // chromatic aberration\n    float spread = length(uv) * .009 * pow(sin(iTime * 0.75), 9.0) + .002;\n    vec4 color = vec4(\n        texture(iChannel0, uv - (vec2(spread, 0.0))).r,\n        texture(iChannel0, uv).g,\n        texture(iChannel0, uv + (vec2(spread, 0.0))).b,\n        1.0);\n\n    // grain\n    vec2 guv = uv + noise(vec2(iTime)) + noise(vec2(uv));\n    float h = hash12(guv)*0.3+0.7;\n    color = color * mix(1.0, h, clamp(color.y, 0.7, 1.0));\n    \n    // gamma\n    color.xyz = pow( color.xyz, vec3(0.655) );\n    \n    fragColor = color;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define TWO_PI 6.2831\n\nvec2 pan(float p)\n{\n    vec2 np = vec2(1.0 - p, 1.0 + p);\n    return normalize(np);\n}\n\nfloat FM(float fc, float fm, float iom, float time)\n{\n    return sin(TWO_PI * fc * time + iom * sin(TWO_PI * fm * time));\n}\n\nfloat click(float t)\n{\n    float a = fract( sin( 253.9898 * mod(t * 2.3, 0.5) ) * 19375.5453 );\n    float b = FM(10.0, 20.0, 6.4, t);\n    return (a * b) * exp(-12.0 * t) * .1;\n}\n\nvec2 bell(float t)\n{\n    vec2 b = FM(55.0, 220.0, 3.4, t) * pan(-1.) + FM(60.0, 240.0, 3.4, t) * pan(1.);\n    return b * exp(-1.0 * t) * .5;\n}\n\nvec2 fm_tone(float freq, float time)\n{\n    float fc = freq;\n    float fm = freq * 1.;\n    float iom = 1.0;\n\n    float env = exp(-3.0 * time) * .2;\n\n    vec2 s = vec2(0.0);\n\n    s += FM(fc + 1., fm + 1., iom, time) * env * pan(-0.5f);\n    s += FM(fc - 1., fm - 1., iom, time) * env * pan(0.5f);\n    s += FM(fc * .5, fm * 1.5, .4, time) * exp(-1.0 * time) * .05 * pan(0.0f);\n\n    s += FM(fc * .25, fm, 1.0 + 5.0 * sin(time * 6.0), time) * env * pan(0.0f) * .1;\n\n    s += FM(fc * 1.0, fm * 1.0, 5. + + 5.0 * sin(time * 20.0), time) * exp(-1.5 * time) * pan(0.0f) * .01;\n    s += FM(fc * 1.0, fm, 25., time) * exp(-20.0 * time) * pan(0.0f) * 0.02;\n\n    return s;\n}\n\nfloat interval(float semitones)\n{\n    return pow(2., semitones/12.0);\n}\n\nconst float notes[] = float[30](\n    0.0, 1.0,\n    0.0, 1.0,\n    7.0, 1.0,\n    7.0, 1.0,\n    9.0, 1.0,\n    9.0, 1.0,\n    7.0, 1.0,\n    0.0, 0.0,\n    5.0, 1.0,\n    5.0, 1.0,\n    4.0, 1.0,\n    4.0, 1.0,\n    2.0, 1.0,\n    2.0, 1.0,\n    0.0, 1.0  \n);    \n\nvec2 melody(float time)\n{\n    vec2 signal = vec2(0.0);\n\n    for (int i = 0; i < 15; i++)\n    {\n        float note = notes[i * 2];\n        float fq = 880.0 * interval(note);\n        float t = mod(time - (float(i) * .25), 4.75);\n        signal += fm_tone(fq, t) * normalize(pan(-1.0 + mod(float(i), 3.0)) * .4f) * notes[i * 2 + 1];\n        signal += fm_tone(fq, 4.75 - t) * notes[i * 2 + 1] * .1;\n    }\n\n    return signal;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 s = vec2(0.0);\n\n    // click\n    float t = mod(time, 4.0);\n    float t2 = mod(time - 1.0, 4.0);\n    s += (click(t) + click(t2)) * pan(.5);\n\n    // bell\n    s += bell(mod(time + 4.0, 16.));\n\n    time = mod(time, 180.0);\n\n    // tv static\n    s += vec2(fract( sin( 22353.9898 * mod(time * .1, 0.5) ) * 19375.5453 )) * pan(-.6) * .05;\n\n    // melody\n    time *= .5f;\n    time = time + sin(time * 0.4) * .14f;\n    s += melody(time);\n\n    return s;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "// Rotation\nmat3 rotateX(float phi)\n{\n    float c = cos(phi);\n    float s = sin(phi);\n\n    return mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, c, -s),\n        vec3(0.0, s, c));\n}\n\nmat3 rotateY(float theta)\n{\n\tfloat c = cos(theta);\n    float s = sin(theta);\n\n    return mat3(\n        vec3(c, 0.0, s),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-s, 0.0, c));\n}\n\nmat3 rotateZ(float psi)\n{\n    float c = cos(psi);\n    float s = sin(psi);\n\n    return mat3(\n        vec3(c, -s, 0.0),\n        vec3(s, c, 0.0),\n        vec3(0.0, 0.0, 1.0));\n}\n\n// SDF\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// SDF Operators\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// Noise\nvec2 random(vec2 st)\n{\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise(vec2 st)\n{\n    vec2 f = fract(st);\n    vec2 i = floor(st);\n    \n    vec2 u = f * f * f * (f * (f * 6. - 15.) + 10.);\n    \n    float r = mix( mix( dot( random(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    return r * .5 + .5;\n}\n\nfloat fbm(vec2 st)\n{\n    float value = 0.;\n    float amplitude = .5;\n    float frequency = 0.;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    \n    return value;\n}\n\n// Noise and FBM (as seen on iq tutorials)\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define AA 1\n\n#define ZERO (min(iFrame,0))\n#define MAX_STEPS\t\t\t150\n#define MAX_DIST\t\t\t18.0\n#define SURFACE_DIST\t\t0.006\n\nvec3 ro = vec3(0.2, 3.2, -0.2);\n\nbool light_on = true;\nbool eyes_on = false;\n\nfloat oTime;\n\nvec2 closest(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec2 map(vec3 p)\n{\n    vec3 gp;\n    float gf;\n\n    // wall\n    vec3 wp = vec3(5.0, 0.0, 0.0);\n    vec3 ws = vec3(.2, 5.0, 5.0);\n    float w = sdBox(abs(p) - wp, ws);\n    w = min(w, sdBox(abs(p) - wp.zyx, ws.zyx));\n\n    vec2 wall = vec2(w, 1.0);\n    \n    // drawer\n    gp = vec3(0.0, .83, 4.3);\n    gf = sdBox(p - gp, vec3(1.0, 0.8, 0.4)) - .05;\n    gf = min(gf, sdBox(p - gp - vec3(0.0, 0.5, 0.0), vec3(0.9, 0.15, 0.45)) - .05);\n    gf = min(gf, sdSphere(p - gp - vec3(0.0, 0.5, -0.55), .07));\n\n    gf = min(gf, sdBox(p - gp + vec3(0.0, -0.05, 0.0), vec3(0.9, 0.15, 0.45)) - .05);\n    gf = min(gf, sdSphere(p - gp + vec3(0.0, -0.05, 0.55), .07));\n\n    gf = min(gf, sdBox(p - gp + vec3(0.0, 0.45, 0.0), vec3(0.9, 0.18, 0.45)) - .05);\n    gf = min(gf, sdSphere(p - gp + vec3(0.0, 0.45, 0.55), .07));\n\n    vec2 drawer = vec2(gf, 3.0);\n\n    // tv\n    gp = vec3(0.0, 2.21, 4.3);\n    vec3 rp = (p - gp) * rotateY(-0.7) + gp;\n    gf = sdBox(rp - gp, vec3(0.5, 0.5, 0.23)) - .05;\n    gf = opSmoothUnion(gf, sdBox(rp - gp - vec3(0.0, -0.05, 0.5), vec3(.35, .38 * (1.0 - clamp(rp.z - 4.5, 0., 1.)), .25)) - .07, 0.20);\n    gf = opSmoothSubtraction(sdBox(rp - vec3(0.0, 2.26, 3.29), vec3(0.29, 0.21, 0.95)) - .13, gf, 0.19);\n    vec2 tv = vec2(gf, 4.0);\n\n    // tv screen\n    gp = gp + vec3(-0.04, 0.05, -0.);\n    gf = sdBox(rp - gp, vec3(0.4, 0.29, 0.1)) - .1 + 000.0;\n    vec2 screen = vec2(gf, 5.0);\n\n    // floor\n    float f = dot(p, vec3(0.0, 1.0, 0.0));\n    vec2 flo = vec2(f, 2.0);\n\n    // eyes\n    if (!light_on && eyes_on)\n    {\n        gp = vec3(-1.6, 0.8, 0.6);\n        rp = (p - gp) * rotateY(-0.3) + gp;\n        gf = sdSphere(rp - gp, .027);\n        gf = min(sdSphere(rp - gp + vec3(0.0, 0.0, .12), .027), gf);\n        flo = closest(flo, vec2(gf, 6.0));\n    }\n    \n    return closest(closest(wall, closest(closest(screen, tv), drawer)), flo);\n}\n\nvec3 calcNormal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.0001*e).x;\n    }\n    return normalize(n);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    vec3 p;\n    vec2 obj;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        p = ro + t * rd;\n        obj = map(p);\n        if (obj.x < SURFACE_DIST || t > MAX_DIST) break;\n        t += obj.x;\n    }\n    \n    obj.x = t;\n    return obj;\n}\n\n// Lighting\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n\tfloat stepSize = 0.002f;\n\tfloat t = stepSize;\n\tfloat oc = 0.0f;\n\tfor(int i = 0; i < 10; ++i)\n\t{\n\t\tvec2 obj = map(p + n * t);\n\t\toc += t - obj.x;\n\t\tt += pow(float(i), 2.2) * stepSize;\n\t}\n\n\treturn 1.0 - clamp(oc * 0.2, 0.0, 1.0);\n}\n\nfloat getVisibility(vec3 p0, vec3 p1, float k)\n{\n\tvec3 rd = normalize(p1 - p0);\n\tfloat t = 10.0f * SURFACE_DIST;\n\tfloat maxt = length(p1 - p0);\n\tfloat f = 1.0f;\n\twhile(t < maxt || t < MAX_DIST)\n\t{\n\t\tvec2 o = map(p0 + rd * t);\n\n\t\tif(o.x < SURFACE_DIST)\n\t\t\treturn 0.0f;\n\n\t\tf = min(f, k * o.x / t);\n\n\t\tt += o.x;\n\t}\n\n\treturn f;\n}\n\n// Texturing\nvec2 triplanar(vec3 p, vec3 normal)\n{\n    if (abs(dot(normal, vec3(0.0, 1.0, 0.0))) > .8)\n    {\n        return p.xz;\n    }\n    else if (abs(dot(normal, vec3(1.0, 0.0, 0.0))) > .8)\n    {\n        return p.yz;\n    }\n    else\n    {\n        return p.xy;\n    }\n}\n\nvec3 textureWood(vec2 uv)\n{\n    uv.x *= .6;\n    \n    float no = noise(vec2(1.2, 2.4) + uv * 6.);\n\n    float n0 = .6 + .4 * smoothstep(\n        .24,\n        0.55,\n        fbm(vec2(uv.x * 10., uv.y * 30.) + vec2(15.0, 10.0)));\n    uv += no;\n    float n1 = fbm(vec2(uv.x * 5., uv.y * 20.) + vec2(2.0, 2.0));\n    float n2 = smoothstep(\n        1.0,\n        0.3,\n        fbm(vec2(uv.x * 1., uv.y * 10.)));\n    \n    vec3 col = n0 * n1 * n2 * vec3(0.92, 0.5, 0.2);\n    return pow(col, vec3(1.0));\n}\n\nvec3 textureWall(vec2 uv)\n{\n    vec2 iuv = floor(uv * 10.0);\n    vec3 col = clamp(smoothstep(0.14, 0.65, noise(uv * 10.4) * fbm(uv * 18.0)) + .9, 0.0, 1.0) * vec3(0.85, 0.8, 0.7);\n    return col;\n}\n\nvec3 textureFloor(vec2 uv)\n{\n    uv *= .5;\n    vec2 tiling = vec2(6.0, 80.0);\n    vec2 uv2 = vec2(0.0);\n    uv2.y = floor(uv.y * tiling.y) / tiling.y;\n    uv2.x = (mod(uv2.y * tiling.y, 2.0) == 0.0) ? floor((uv.x * tiling.x)) / tiling.x : floor(((uv.x + .09) * tiling.x)) / tiling.x;\n    uv += uv2 * 2.0;\n    uv *= 10.;\n    \n    float n0 = .6 + .4 * smoothstep(\n        .24,\n        0.52,\n        fbm(vec2(uv.x * 10., uv.y * 60.) + vec2(14.0, 10.0)));\n    \n    vec3 col = n0 * vec3(0.88, 0.64, 0.3) * (noise(uv2*44.0) * .7 + .3);\n    return pow(col, vec3(1.0));\n}\n\nvec3 tvscreen(vec2 uv)\n{\n    vec2 iuv = floor(uv * 10.0);\n    vec3 col = hash1((iTime + 10.) * uv * 1.0) * vec3(4.3, 4.3, 8.0) * 12.0;\n    col *= pow(0.7 - distance(uv, vec2(.5, .5)), 0.8);\n\n    return col;\n}\n\n// Renderer\nvec3 render(vec2 obj, vec3 p, vec3 rd, vec2 uv)\n{\n    vec3 col;\n    \n    vec3 normal = calcNormal(p);\n    float fog;\n    \n    if (obj.x >= MAX_DIST)\n    {\n        col = vec3(1.0, 0.6, 0.4) * (uv.y + .6);\n    }\n    else\n    {\n        fog = pow((obj.x / MAX_DIST), 8.3);\n        float aa = pow(ambientOcclusion(p, normal), 2.0);\n\n        float diff_mask = 1.0;\n        float spec_power = 15.0;\n        float spec_mask = 1.0;\n\n        vec3 albedo = vec3(0.);\n        \n        if (obj.y >= 6.0) // eyes\n        {\n            albedo = vec3(1.0, .1, .1) * 440.;\n            spec_power = 40.0;\n            spec_mask = 1.3;\n        }\n        else if (obj.y >= 5.0) // tv screen\n        {\n            vec2 uv = mod((triplanar(p * rotateY(-.7), normal) + vec2(-.4, 0.42)) * vec2(1.1, 1.3), vec2(1.0, 1.0));\n            albedo = tvscreen(uv);\n            spec_power = 40.0;\n            spec_mask = 1.3;\n        }\n        else if (obj.y >= 4.0) // tv\n        {\n            vec2 uv = triplanar(p, normal) * 0.8;\n            albedo = vec3(.2, .2, .2);\n            spec_power = 10.0;\n            spec_mask = 1.0;\n        }\n        else if (obj.y >= 3.0) // drawer\n        {\n            vec2 uv = triplanar(p, normal) * 0.8;\n            albedo = textureWood(uv) * 1.1;\n        }\n        else if (obj.y >= 2.0) // floor\n        {\n            vec2 uv = triplanar(p, normal) * 0.168 + 1.1;\n            albedo = textureFloor(uv);\n            spec_power = 25.0;\n            spec_mask = 1.0;\n        }\n        else if (obj.y >= 1.0) // walls\n        {\n            vec2 uv = triplanar(p, normal) * 3.0;\n            \n            uv = mod(uv * 0.02 + 0.5, 1.0);\n            albedo = textureWall(uv) * vec3(0.905, 0.854, 0.684);\n            spec_power = 2.0;\n            spec_mask = .5;\n        }\n\n        #if 1\n        col += albedo * aa * .08;\n        #endif\n\n        // top Light\n        if (light_on)\n        {\n            vec3 light_pos = vec3(-2.0, 5.0, 0.4);\n            vec3 light_col = vec3(0.9, 0.6, 0.3) * .7;\n\t\t\tvec3 refd = reflect(rd, normal);\n            vec3 light_dir = normalize(light_pos - p);\n            \n            float diffuse = dot(light_dir, normal);\n            float visibility = getVisibility(p, light_pos, 10.0);\n        \tfloat spec = pow(max(0.0, dot(refd, light_dir)), spec_power);\n\n            if (obj.y < 5.0) col += diff_mask * diffuse * albedo * visibility * light_col * .36 * aa;\n            col += spec * (light_col * albedo) * spec_mask;\n        }\n\n        // TV Light\n        #if 1\n        if (obj.y < 5.0)\n        {\n            vec3 light_pos = vec3(-0.3, 2.93, 3.9);\n            vec3 light_col = vec3(0.15, 0.22, 0.7) * ((.5 + .5 * sin(iTime * 85.)) * .07 + .3);\n\t\t\tvec3 refd = reflect(rd, normal);\n            vec3 light_dir = normalize(light_pos - p);\n            \n            float diffuse = abs(dot(light_dir, normal));\n            float visibility = getVisibility(p, light_pos, 5.0);\n        \tfloat spec = pow(max(0.0, dot(refd, light_dir)), spec_power);\n\n            if (p.z < 4.75) visibility = visibility + smoothstep(visibility, (p.z + 4.0) * .3, 1.0);\n\n            float intensity = 0.8;\n            if (!light_on) intensity = 3.0;\n            \n            col += diff_mask * diffuse * albedo * visibility * light_col * intensity * aa;\n            col += spec * (light_col * albedo) * visibility * spec_mask * 3.0;\n        }\n        #endif\n\n        // eye light\n        #if 1\n        if (!light_on && eyes_on)\n        {\n            vec3 light_pos = vec3(-1.6, 0.8, 0.6);\n            vec3 light_col = vec3(1.0, 0.1, 0.1) * .2;\n\t\t\tvec3 refd = reflect(rd, normal);\n            vec3 light_dir = normalize(light_pos - p);\n            \n            float diffuse = abs(dot(light_dir, normal));\n            float visibility = getVisibility(p, light_pos, 5.0);\n        \tfloat spec = pow(max(0.0, dot(refd, light_dir)), spec_power);\n\n            if (p.z < 4.75) visibility = visibility + smoothstep(visibility, (p.z + 4.0) * .3, 1.0);\n\n            float intensity = 0.8;\n            if (!light_on) intensity = 3.0;\n            \n            col += diff_mask * diffuse * albedo * visibility * light_col * intensity * aa;\n            col += spec * (light_col * albedo) * visibility * spec_mask * 3.0;\n        }\n        #endif\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    oTime = iTime;\n#if 1\n    float d = 0.8;\n    float v = -0.4 + sin(iTime * .4) * .1;\n    float vvv = -0.5;\n    vec3 ta = ro + vec3(sin(v) * d, vvv, cos(v) * d);\n#else \n    float d = 0.8;\n    float v = ((iMouse.x / iResolution.x) - .5) * -5.;\n    vec3 ta = ro + vec3(sin(v) * d, clamp((iMouse.y / iResolution.y) - .5, -0.5, 30.5), cos(v) * d);\n#endif\n\n    light_on = !(mod(iTime, 4.0) < 1.);\n    eyes_on = !(mod(iTime + 4.0, 16.) > 1.0);\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for(int m=ZERO; m<AA; m++)\n    for(int n=ZERO; n<AA; n++)\n    {\n        vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0 * (fragCoord + o) - iResolution.xy) / iResolution.y;\n#else    \n    \tvec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n#endif       \n        // Ray direction\n        vec3 ww = normalize(ta - ro);\n        vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, -0.4)));\n        vec3 vv = normalize(cross(uu, ww));\n        \n        vec3 rd = normalize(uv.x * uu + uv.y * vv + (2.) * ww);\n        \n        // render\t\n        vec2 obj = rayMarch(ro, rd);\n        vec3 p = ro + obj.x * rd;\n    \n   \t\tvec3 col = render(obj, p, rd, uv);\n        \n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n        \n    if (!light_on)\n    {\n        float mask = clamp(1.0 - length((uv + vec2(1.0, -0.5)) * .25), 0.0, 1.0);\n        tot *= pow(mask, 2.0);\n    }\n    \n    fragColor = vec4(tot, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}