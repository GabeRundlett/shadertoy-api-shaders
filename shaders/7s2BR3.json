{
    "Shader": {
        "info": {
            "date": "1646809011",
            "description": "more domain gating and IFS\n\nHD video available here :\n\n https://youtu.be/CT19xGgonyQ",
            "flags": 0,
            "hasliked": 0,
            "id": "7s2BR3",
            "likes": 3,
            "name": "spqr: Paris 3040 AD 4",
            "published": 3,
            "tags": [
                "a"
            ],
            "usePreview": 0,
            "username": "spqr",
            "viewed": 371
        },
        "renderpass": [
            {
                "code": "\n\n#define PI 3.14159265\n#define time iTime\n#define saturate(a) (clamp((a),0.,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n#define BEAT (time*33.0/60.0)\nfloat seed;\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec3 spline(vec3 a, vec3 b, vec3 c, vec3 d, float p)\n{\n    // CatmullRoms are cardinals with a tension of 0.5\n\tvec3 P = -a + (3. * (b - c)) + d;\n    vec3 Q = (2. * a) - (5. * b) + (4. * c) - d;\n    vec3 R = c - a;\n    vec3 S = 2. * b;\n\n\tfloat p2 = p * p;\n    float p3 = p * p2;\n\n    return .5 * ((P * p3) + (Q * p2) + (R * p) + S);\n}\n\n\nfloat tor( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hash(in vec3 p)\n{\n    p = fract(p * vec3(821.35, 356.17, 671.313));\n    p += dot(p, p+23.5);\n    return fract(p.x*p.y*p.z);\n}\n\nfloat noise(in vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    \n    float a = hash(ip + vec3(0, 0, 0));\n    float b = hash(ip + vec3(1, 0, 0));\n    float c = hash(ip + vec3(0, 1, 0));\n    float d = hash(ip + vec3(1, 1, 0));\n    float e = hash(ip + vec3(0, 0, 1));\n    float f = hash(ip + vec3(1, 0, 1));\n    float g = hash(ip + vec3(0, 1, 1));\n    float h = hash(ip + vec3(1, 1, 1));\n    \n    vec3 t = smoothstep(vec3(0), vec3(1), fp);\n    return mix(mix(mix(a, b, t.x), mix(c, d, t.x), t.y),\n               mix(mix(e, f, t.x), mix(g, h, t.x), t.y), t.z);\n}\n\nfloat fbm(in vec3 p)\n{   \n    float res = 0.0;\n    float amp = 0.5;\n    float freq = 2.0;\n    for (int i = 0; i < 5; ++i)\n    {\n        res += amp * noise(freq * p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nfloat bi_fbm(in vec3 p)\n{\n    return 2.0 * fbm(p) - 1.0;\n}\n\nvec3 warp(in vec3 p)\n{\n    p = p + bi_fbm(0.4*p + mod(0.5*iTime, 100.0));\n    p = p + bi_fbm(0.4*p - mod(0.3*iTime, 100.0));\n    return p;\n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\nfloat rnd(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nmat2 rot2d(float t)\n{\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\nfloat wave(vec3 p) {\n\n   float elv = 0.;\n   for (float i = 0.; i < 11.; i++) {\n     p.xz *= rot(rnd(i ));\n     p.yz *= rot(rnd(i+1.)*.32*2.);\n     p.xy *= rot(i*5.);\n    \n     float q = 1.3 + abs(sin(11.1/30.)/10.);\n     elv += cos((p.x + (i *171.9))/(10./pow(q,i))) * (4./pow(q,i));\n     elv += cos((p.z * .61 + (i *61.2))/(10./pow(q,i))) *  (4./pow(q,i));\n  \n   \n\n   }\n   \n   return pow(elv,.3);\n}\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\nvec3 flitfbm(float t) {\n    vec3 z = vec3(0);\n    float amp = 1.;\n    float freq = 1.;\n    for (float a = 0.; a < 5.; a++) {\n      z += flit((t+a) * freq) * amp;\n      freq *= 1.5;\n      amp /=1.4;\n    }\n    \n    return z;;\n}\n\n\nvec3 bezier( float t ){\n  vec3 one = lattice(floor(t));\n  vec3 two = lattice(floor(t+1.));\n  float per = fract(t);\n  \n  return mix(one,two,per);\n  \n}\n\n\nvec3 lofi (vec3 a, float b) {\n  return floor(a/b) * b;\n \n}\n \n\nfloat fractsin(float v)\n{\n  return fract(sin(v*121.445)*34.59);\n}\n\n\n\n\nfloat rand()\n{\n  seed=fractsin(seed);\n  return seed;\n}\n\n\nfloat easeceil(float t, float fac)\n{\n  return floor(t)+.5+.5*cos(PI*exp(fac*fract(t)));\n}\n\n\nfloat pi = 3.141592;\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\nfloat slomo ( float x) {\n  x = mod(x,10.);\n  \n  float z = (pow(x-5.,6.)/( pow(x-5.,6.) + 1. ) );\n  return z;\n}\n\n\n\n\n\n\n\n\nvec3 kifs(vec3 p) \n{\n  \n  float t = surge(time);\n  float s =10.;\n  for ( float i = 0.; i <5.; i++ ) {\n \n    p.yz *= rot((t + i));\n    p.xz *= rot((t - i) * .7);\n    \n   \n    p = abs(p);\n    \n    p -= s;\n    s *= 0.7;\n  }\n  return p;\n}\n\nfloat box(vec3 p,vec3 s)\n{\n  vec3 d=abs(p)-s;\n  return length(max(d,0.));\n}\n/*\nfloat box(vec3 p, vec3 s) {\n  vec3 ap = abs(p)-s;\n  return length(max(vec3(0), ap)) + min(0.0, max(ap.x, max(ap.y,ap.z)));\n}\n*/\n\n\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\n\nfloat sph ( vec3 p, float r) {\n  return length(p) - r;\n}\n\n\nvec3 ifs(vec3 p,vec3 rot,vec3 shift)\n{\n  vec3 pt=abs(p);\n  vec3 t=shift;\n  for(int i=0;i<8;i++)\n  {\n    pt=abs(pt)-abs(lofi(t*pow(1.8,-float(i)),1.0/512.0));\n    t.yz=rot2d(rot.x)*t.yz;\n    t.zx=rot2d(rot.y)*t.zx;\n    t.xy=rot2d(rot.z)*t.xy;\n    pt.xy=pt.x<pt.y?pt.yx:pt.xy;\n    pt.yz=pt.y<pt.z?pt.zy:pt.yz;\n  }\n  return pt;\n}\n\n\n\nfloat chassi (vec3 p) {\n   p.z *= .5;\n   float a = tor(vec3(p.x/1.,p.y/1.,p.z/2.) , vec2(3.,1.)) + box(p,vec3(3.4));\n   return a * .5;\n}\nfloat body (vec3 p) {\n    float a =box(p, vec3(3.,0.9,4.));\n    float b =box(p - vec3(0,0.5,4.), vec3(3.,0.9,4.) * .9);\n    \n    vec3 pa = p;\n    pa.zy *= rot(.3);\n    float c= box(pa - vec3(0,4.4,0), vec3(3.,0.9,4.) * .4);\n    \n    vec3 pb = p;\n    pb.zy *= rot(22.2);\n    float d= sph(pb - vec3(0,0.7,0), 2.2);\n    float e= sph(pb - vec3(0,0.7,-1.5), 3.0);\n    return smin(e,smin(d, smin(c,smin(a,b,2.),5.), 2.),.2);\n}\n\nfloat grav ( vec3 p) {\n  \n  float a = sph(p + vec3(2.,0,8), 1.2);\n  float b = sph(p + vec3(-2.,0,8), 1.2);\n  float c = sph(p + vec3(2.,0,-8), 1.2);\n  float d = sph(p + vec3(-2.,0,-8), 1.2);\n  \n  return min(d,min(c,min(a,b)));\n}\n\nvec3 opId(vec3 p, vec3 c) {\n     return floor(p/c);\n}\n\nvec3 opRep(vec3 p, vec3 c) {\n  return mod(p, c)- 0.5 * c;\n}\nfloat runner (vec3 pt) {\n\n   pt= pt * 4.;\n   pt.z *= 1.;\n   vec3 p = pt + vec3(0,15.,0);\n\n   \n    float ch  = chassi(p);\n    float bo = body(p);\n    float gr = grav(p);\n    return smin(gr,smin(ch,bo,.5),1.4) * .8;\n}\n\n\n\n\n\n\nfloat highway (vec3 p , vec3 shape, vec3 off, vec3 dir, float prob) {\n\n  prob *= .4;\n  dir *= .47;\n  shape *= .11;\n  p += off + dir * iTime * 3.11; \n  vec3 q = opRep(p, vec3(30,30,30)) ;\n  vec3 qid = opId(p, vec3(30,30,30));\n  float lim = fract(hash(qid * 1.7));\n  float s;\n  \n  prob *=1.;\n  \n  if ( lim < prob ) {\n      return runner(q);\n  } else {\n      return 10.;\n  }\n\n\n}\n\n\n\n\nint matter = 0;\n\nfloat artifact(vec3 p, float width) {\n  vec3 pt=p;\n  \n  float halfwidth = width/2.;\n  vec3 haha=lofi(pt,width);\n  \n  float phase=BEAT/8.0;\n  phase+=dot(haha,vec3(2.75,3.625,1.0625));\n  phase=easeceil(phase,-10.0);\n  \n  pt=mod(pt,width)-halfwidth;\n  \n\n  float clampBox=box(pt,vec3(2.));\n  \n  pt=ifs(\n      pt,\n      vec3(3.6,3.0+0.4*phase,3.1),\n      vec3(3.0,2.3,3.5)\n  );\n  \n  pt=mod(pt-.5,1.)-.5;\n  \n  \n  vec3 seed = floor(p/width);\n  float uu = hash13(seed);\n  float dist;\n  \n  \n  dist=box(pt,vec3(.19));\n  dist=box(pt,vec3(.131));\n  \n\n\n  dist=max(dist,clampBox);\n\n \n  return dist;\n  \n}\n\nvec3 hash31(float p) {\n\tvec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n}\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nfloat gatedcyl(vec3 p, vec2 dim, float domain, float prob) {\n\n     prob = prob/=2.;\n     prob = 1.-prob;\n     \n \n    vec3 id = floor((p)/domain);\n    p = mod(p,domain) - domain/2.;\n    float f1 = hash31(id);\n    \n    if (  f1 < prob) {\n\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= domain;\n        float u = cylcap(p,dim.x,dim.y);\n        return u;\n        \n    } else {\n        float u = cylcap(p,dim.x,dim.y);\n       \n        return u;\n    }\n \n}\n\n\nfloat gatedbox(vec3 p, vec3 dim, float domain, float prob) {\n\n     prob = prob/=2.;\n     prob = 1.-prob;\n     \n \n    vec3 id = floor((p)/domain);\n    p = mod(p,domain) - domain/2.;\n    float f1 = hash31(id);\n    \n    if (  f1 < prob) {\n\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= domain;\n        float u = box(p,dim);\n        return u;\n        \n    } else {\n        float u = box(p,dim);\n       \n        return u;\n    }\n \n}\n\nfloat box(vec3 p, float w, float h) {\n\n  vec3 b = vec3(w,w,h);\n  vec3 q = abs(p) - b;\n  return max(q.x,max(q.y,q.z)) ;\n\n}\n\n\nvec2 edge(vec2 p) {\n    vec2 p2 = abs(p);\n    if (p2.x > p2.y) return vec2((p.x < 0.) ? -1. : 1., 0.);\n    else             return vec2(0., (p.y < 0.) ? -1. : 1.);\n}\n\n\n\nfloat hash21(vec2 p) {\n    float a = sin(p.x*1831.424)*9918.3232;\n    float b = sin(p.y*4254.001)*7742.4342;\n\n    float d = fract(a+b);\n    float e = sin(d * 4225.2421) * 9003.131;\n    return fract(e);\n\n}\n\nfloat poles(vec3 p, float widthlimit, float heightlimit) {\n\n   \n    p.yx *= .25;\n    vec2 center = floor(p.xy) + .5;\n    vec2 neighbour = center + edge(p.xy - center);\n   \n    vec2 dom = vec2(1.);\n     \n      \n    vec2 id = floor(p.yx/dom);\n    float f1 = hash21(id);\n    f1 = pow(f1,2.);\n \n   \n  \n    float me   = box(p - vec3(center, 0),    widthlimit, heightlimit * f1) ;\n    float next = box(p - vec3(neighbour, 0), widthlimit, heightlimit);\n    return min(me, next);\n}\n\n\nint material;\n\nfloat map(vec3 p) {\n\n\n    //geo\n  \n    vec3 q = p;\n  \n    float width = 4.;\n\n    float field = artifact(p, width);\n   \n    vec3 p1 = p.xzy;\n    vec3 p2 = p.xzy;\n      p2.xy *= rot(1.);\n    \n    \n    float type1 = poles(p1,                  .3, 17.);\n    float type2 = poles(p2 * vec3(.2,.2,1.), .3, 37.);\n    \n    vec3 impulse = vec3(0,0,1) * iTime *  44.;\n    float aircar = gatedbox(q + impulse,vec3(1.,7.,12.)*.2, 10., .07);\n    aircar = max(aircar, -(p.y + 60.));\n  \n    aircar = max(field,aircar);\n    \n     //return min(type1,type2);\n    \n    type1 = max(field, type1);\n    type2 = max(field, type2);\n   \n    float type = min(type1,type2);\n    float ground = -p.y;\n    \n    ground = smin(ground,cylcap(p - vec3(200.,0.,7800.), 140.,4480.),580.);\n    \n    \n    \n  \n  \n    \n  \n    float final =  min(ground,(min(type,aircar)));\n    \n \n    \n    if ( final == ground) {\n        material = 0;\n    }\n    if ( final == type) {\n        material = 1;\n    }\n   if ( final == aircar) {\n        material = 2;\n    }\n  \n    return final;\n  \n    \n\n    \n}\n\n\nvec3 norm(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx)-map(p-d.yxx),\n    map(p+d.xyx)-map(p-d.xyx),\n    map(p+d.xxy)-map(p-d.xxy)\n  ));\n}\n\n\nvec3 norm3(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\n\n\n\n\nfloat tock (float t){\n  return t + sin(t);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(map(p) - vec3( map(k[0]),map(k[1]),map(k[2]) ));\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\nfloat getsss(vec3 p, vec3 r, float dist) {\n  return clamp(map(p+r*dist)*3.0,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n \n  // nav \n vec3 s,t;\n\n // switch\n                        // bobbing\n float tt = iTime * .03;\nif (false) {//mod(floor(iTime),14.) < 7.){\n\n  tt *= 4.;\n\n\n  \n  s = lattice(tt)*15.1;\n  s.xz *= rot(tick(tt)*.413);\n  s.xy *= rot(tick(tt)*.111);\n\n  t = lattice(tt + 53.)*15.1;\n  t.xz *= rot(tick(-tt)*.31);\n  t.yz *= rot(tick(tt)*.21);\n  \n\n  vec3 arm = vec3(0,0,1);\n  arm.xz *= rot(tt);\n  arm.yz *= rot(tt*.71);\n  arm.xy *= rot(tt*.51);\n  \n  s += arm * 1.;\n  t += arm * 1.;\n  \n  \n  s += tock(tt * 3.) * 3. * arm;\n  t += tock(tt * 3.) * 3. * arm;\n  \n  s.y -=10.;\n  t.y -=10.;\n  \n  s.y = clamp(-10.,-50.,s.y);\n t.y = clamp(-10.,-40.,t.y);\n  \n  \n}\n\n                // hurtling forward\nelse {\n\n\n \n  \n  tt *= 2.;\n  s = vec3(0,0,-40);\n  t = vec3(0);\n  s.y -= 40.;\n  t.y -= 10.;\n  \n  s += flitfbm(tt*20.) * 1.5;\n  t += flitfbm(tt*70. + 8.) * .5;\n  \n  s.y += sin(iTime*1.)*18.;\n  t.y += sin(iTime*1.)*3.;\n  \n  \n  vec3 hurt = vec3(0,0,1);\n  //hurt.yz *= rot(iTime*.02);\n\n  \n  vec3 adv = hurt * 779.1 * tt;\n  s+= adv;\n  t+= adv;\n  \n  vec3 yank = lattice(tick(iTime*7.1)) * 7.1;\n  yank.x = 0.;\n  yank.z = 0.;\n \n  s += yank;\n  t += yank;\n  \n  vec3 arm = t-s;\n  arm.xy *= rot(sin(tt)*1.2);\n  t = s +arm;\n\n\n\n\n}\n\n   \n\n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  cx.xy *= rot(sin(iTime*.57)/9.);\n  vec3 cy=normalize(cross(cz,cx));\n      // fisheye\n  cz += dot(uv,uv)/10.;\n  \n \n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz * .8);\n \n  bool hit = false;\n  float d;\n  float edge = 0.;\n  float dd=0.;\n  float i = 0.;\n  vec3 p=s;\n  vec3 n1,n2;\n \n  \n \n  // march\n \n  for(float z=0.;z<2000.;z++){ \n  \n    i = z;\n    d = map(p);\n    d = abs(d) * .8;\n\n    if ( d < .01 ) {\n      hit = true;\n      break;\n    } \n    if ( dd > 2000.) {\n        break;\n    }\n    \n    dd += d;\n    p += r * d;\n\n  }\n \n  \n  \n  // hue\n  vec3 col;\n  vec3 z = vec3(.8,.5,.4);\n  \n  if ( material == 0) {\n    col = z*z;\n  } \n  if ( material == 1) {\n    col =z;\n   // col = mix(vec3(0),z, 1.-dd/600.);\n   \n   \n  }\n  if ( material == 2) {\n    col = vec3(0);\n    \n  }\n  \n  vec3 n = norm(p);\n  \n  float aodist=.1;\n  vec3 light = normalize(vec3(10,-20,30));\n  light.xz *= rot(iTime * 1.71);\n\n  float ao = getao(p,n,aodist*.2);// * (getao(p,n,aodist*0.35)*0.5+0.5) * (getao(p,n,aodist*0.6)*0.25+0.75);\n  float sss = (getsss(p,r,.2));//+getsss(p,r,0.5)*0.5)*0.9;\n  float diff = max(0., dot(n,light)*.3 +.7);\n  float spec =pow(max(dot(reflect(-light,n),-r),0.),2.) * 1.;\n  float iff = pow(1. - i/3000.,6.);\n  \n  //col *= iff;\n  col *= diff ;\n  col *= ao ;\n  col += sss  * 1.;\n  col += spec * .2;\n  \n \n  //col = pow(col,vec3(.7));\n // vec3 fog = mix(vec3(0.1,0.2,0.7), vec3(0.6,0.6,0.6), pow(max(0.0,dot(r,light)),5.0));\n//  col = mix(fog,col,exp(-.00000003 * dd * dd * dd));\n\n// col = mix(col,vec3(1), pow(clamp(0.,1.,1.-(p.y/-10.)),6.));\n \n\n \n\n  col *= 1.3  ;\n  \n\n  if ( material == 2) {\n    n2 = norm(p, vec2(0.0, 1E-2 ));// + 3E-2*.01) );\n    n1 = norm(p, vec2(0.0, 2.5E-2) );\n    edge = saturate(length(n1-n2)/1.);\n    col += edge * 10.;\n  } else {\n    n2 = norm(p, vec2(0.0, 1E-2 ));// + 3E-2*.01) );\n    n1 = norm(p, vec2(0.0, 5.5E-2) );\n    edge = saturate(length(n1-n2)/1.);\n    col -= edge* 10.;\n  }\n\n  \n\n  \n  if (! hit){\n\n      col = mix(vec3(.6),vec3(0),pow(r.y,.6));\n  }\n  \n  fragColor = vec4(col, 1.0);\n\n}\n\n/*\n//  n2 = norm(p, vec2(0.0, 1E-2+3E-2*.01) );\n//  n1 = norm(p, vec2(0.0, 2E-2) );\n\n*/\n\n\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/\n\n\n/*\n\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}