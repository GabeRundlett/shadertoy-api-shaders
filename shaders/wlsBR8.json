{
    "Shader": {
        "info": {
            "date": "1602248868",
            "description": "toying with this space: https://www.osar.fr/notes/logspherical/",
            "flags": 0,
            "hasliked": 0,
            "id": "wlsBR8",
            "likes": 11,
            "name": "log_polar_thingy_1",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "logspherical"
            ],
            "usePreview": 0,
            "username": "balkhan",
            "viewed": 371
        },
        "renderpass": [
            {
                "code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n\n\n#define I_MAX\t\t400\n#define E\t\t\t0.0001\n#define FAR\t\t\t20.\n\n#define\tFUDGE\t\t1.\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nvoid\trotate(inout vec2 v, float angle);\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\n\n#define PI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\n/*\n* Leon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n/*\n* end mod polar\n*/\n#define SCALE 2.0/PI\n\nfloat sdCy( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 ilogspherical(in vec3 p)\n{\n\tfloat erho = exp(p.x);\n\tfloat sintheta = sin(p.y);\n\treturn vec3(\n\t\terho * sintheta * cos(p.z),\n\t\terho * sintheta * sin(p.z),\n\t\terho * cos(p.y)\n\t);\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat side = .0, shorten = 20.50;\nfloat layer(in vec3 p, in float twost)\n{\n\tfloat ret = 1e5;\n\tpR(p.yz, twost);\n    vec3 op = p;\n\tp.xyz = abs(p.xyz) - 2.750;\n    float a = .0+p.x*.5;\n    /*\n    p.xy= modA(p.xy, 3.);p.x-=5.;\n    p.zy= modA(p.zy, 3.);p.z-=2.;\n    p.yx= modA(p.yx, 3.);p.y-=4.;\n    */\n    ret = length(vec2(max(p.y, p.x), max(p.z, min(p.x,p.y) ) ) )-.25;\n\n    float sf = .1525+-1.5100251010/(length(p)*length(p)*0.015+10.01)-.0;\n    ret = min(ret,\n              length(\n              fract(sf*vec2(p.z, p.x))/sf-.5\n              )-.10105\n              );\n    ret = min(ret,\n              length(\n              fract(sf*vec2(p.y, p.x))/sf-.5\n              )-.10105\n              );\n    ret = min(ret,\n              length(\n              fract(sf*vec2(p.z, p.y))/sf-.5\n              )-.105105\n              );\n    ret = max(ret,\n              -(length(fract(sf*p)/sf-.5)-.5 )\n              );\n    op.xy = modA(op.xy, 50.);\n    op.zx = modA(op.zx, 50.);\n    float shell_cubes = (mylength(op-vec3(.0,-.0,1.0505)+-.00)-0.0251250905125995);\n    ret = min(ret, shell_cubes );\n    ret = min(ret, (length(p+-4.50705)-3.50905995) );\n\n\treturn ret;\n}\n\nfloat sdf(in vec3 pin)\n{\n    float dens = .25;\n    float idens = 1./dens;\n    float twist = 1.5, stepZoom = 1.;\n\tfloat r = length(pin);\n\tvec3 p = vec3(log(r), acos(pin.z / length(pin)), .0+iTime*.1*-1.0+atan(pin.y, pin.x));\n\n\t// Apply rho-translation, which yields zooming\n\tp.x -= iTime*1.2;\n\n\t// find the scaling factor for the current tile\n\tfloat xstep = floor(p.x*dens) + (iTime*1.2)*dens;\n\t\n\t// Turn tiled coordinates into single-tile coordinates\n\tp.x = mod(p.x, idens);\n\n\t// Apply inverse log-spherical map (box tile -> shell tile)\n\tp = ilogspherical(p);\n\n\tfloat ret = 1e5;\n\tret = min(ret, layer(p/stepZoom, (xstep+1.0)*twist)*stepZoom);\n\n\t// Compensate for scaling applied so far\n\tret = ret * exp(xstep*idens) / shorten;\n\n\treturn ret;\n}\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    vec3\tcol = vec3(0., 0., 0.);\n    vec2\tR = iResolution.xy;\n\tvec2\tuv  = vec2((f.xy-.5*R.xy)/R.y);\n\tvec3\tdir = normalize(vec3(uv*vec2(1.,-1.), 1.));\n    vec3\tpos = vec3(-.0, -.2105017501050*.450*.0+.033*.0, -2.0*.0-1.52525045);\n    \n\n    vec4\tinter = march(pos, dir);\n    if (inter.y <= E*1.)\n    {\n        vec3\tv = pos+(inter.w-E*0.)*dir;\n        vec3\tn = calcNormal(v, E*1., dir);\n        vec3\tev = normalize(v - pos);\n\t\tvec3\tref_ev = reflect(ev, n);\n        vec3\tlight_pos   = vec3(-100.0, 60.0, -50.0);\n\t\tvec3\tlight_color = vec3(.1, .4, .7);\n        vec3\tvl = normalize(light_pos - v);\n\t\tfloat\tdiffuse  = max(0.0, 1.-dot(vl, n))+.0*max(0.0, dot(vl, n));\n\t\tfloat\tspecular = pow(max(0.0, dot(vl, ref_ev)), 3.);\n        col.xyz += light_color * (specular*1.0)+ diffuse * vec3(.51,.515, .53);\n    }\n    else\n        col *= .0;\n    c_out =  vec4(col, 1.);\n}\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\tret = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = sdf(p);\n        dist.y += dist.x*FUDGE;\n        if ( dist.x < E || dist.y > FAR)\n            break;\n    }\n    ret.w = dist.y;\n    ret.y = dist.x;\n    return (ret);\n}\n\n// Utilities\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret = 1e5;\n\n    p = abs(p);\n    ret = max(p.x, max(p.y, p.z));\n    \n    return ret;\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret = 1e5;\n\n    p = abs(p);\n    \n    ret = max(p.x, p.y);\n\n    return ret;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           sdf(pos+eps.xyy) - sdf(pos-eps.xyy),\n           sdf(pos+eps.yxy) - sdf(pos-eps.yxy),\n           sdf(pos+eps.yyx) - sdf(pos-eps.yyx) ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}