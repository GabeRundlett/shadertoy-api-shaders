{
    "Shader": {
        "info": {
            "date": "1456311623",
            "description": "This is a 3d version of Racing Concept by Imp5. (link in comments) I tried to keep it close to the original and fast.",
            "flags": 48,
            "hasliked": 0,
            "id": "MsKGWy",
            "likes": 68,
            "name": "Racing Concept (in car)",
            "published": 3,
            "tags": [
                "game"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 10767
        },
        "renderpass": [
            {
                "code": "//This is a 3d version (by eiffie) of Racing Concept originally found @https://www.shadertoy.com/view/lsK3RK by Imp5\n\n//The original header...\n// GLSL Racing Concept\n// Created by Alexey Borisov / 2016\n// License: GPLv2\n\n//v2 with updates from the originator\n\n//change this for speed/quality\nconst int ITERS = 78;\n\nconst float IS_INITED = 0.5;\nconst float CAR_POSE = 1.5;\nconst float CAR_VEL = 2.5;\nconst float DEBUG_DOT = 3.5;\nconst float CAR_PROGRESS = 4.5;\n\nconst float LAPS = 6.0;\n\nconst float carLength = 0.045;\nconst float carWidth = 0.02;\nconst float carHeight = 0.02;\n\nconst vec2 finishDir = vec2(1, 1.5);\n\nvec2 track_distort(vec2 pos)\n{\n    pos *= 0.5;    \n    pos -= vec2(cos(pos.y * 2.4), sin(pos.x * 2.0 - 0.3 * sin(pos.y * 4.0))) * 0.59;\n    return pos;\n}\n\nfloat track_val(vec2 pos)\n{\n    pos = track_distort(pos);\n    return abs(1.0 - length(pos)) * 8.0 - 1.0;\n}\n\nvec4 car_color_from_index(int i)\n{\n    return abs(vec4(cos(float(i) * 6.3) - 0.1, cos(float(i) * 82.0) - 0.1, cos(float(i) * 33.0) - 0.1, 1.0));\n}\n\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\n\nfloat DEC(in vec3 p){\n\tp.z=-p.z;\n\tp/=0.07;\n\tp.y-=0.16;\n\tfloat r=length(p.zy+vec2(0.0,0.73))-0.7;\n\tp.z+=0.05;\n\tfloat d=max(r,length(max(vec3(0.0),abs(p)-vec3(0.27*sqrt(abs(p.y))-0.02,0.26,0.35)))-0.14);\n\tp.z=abs(p.z);\n\tp.yz+=vec2(0.35,-0.26);\n\tr=length(p.zy);\n\td=max(d,0.1-r);\n\tp.x=abs(p.x)-0.25;\n\td=min(d,length(max(vec2(0.0),abs(vec2(r,p.x))-vec2(0.06,0.02)))-0.02);\n\treturn d*0.06;\n}\nvoid CarCol(in vec3 p, float od, inout vec3 col){\n\tp.z=-p.z;\n\tp/=0.07;\n\tp.z+=0.05;\n\tp.z=abs(p.z);\n\tp.yz+=vec2(0.19,-0.26);\n\tfloat r=length(p.zy);\n\tif(r<0.09)col+=smoothstep(0.04,0.06,r);\n\telse col*=(0.5+0.5*smoothstep(0.0,0.01,abs(p.y-0.24)-0.06));\n    p.x=abs(p.x)-0.2;\n    if(length(p.xy)<0.025)col.r+=1.0;\n}\nint id;\nvec3 scar;\nfloat DE(in vec3 z0){\n\tvec2 p=z0.xz*8.0;\n\tfloat g=-0.05+(sin(p.x+sin(p.y*1.7))+sin(p.y+sin(p.x*1.3)))*0.01; // <<<<<<\n    float c=track_val(z0.xz);\n    float dg=(z0.y+g*smoothstep(0.0,3.0,c)) * 6.0; // <<<<<<<<\n\tfloat d=2.0;\n\tscar=vec3(-1.0);//saved car position\n\tfor(int carIdx=1;carIdx<8;carIdx++){\n\t\tvec4 carPose = texture(iChannel0, vec2(CAR_POSE, float(carIdx)+0.5) / iResolution.xy);\n\t\tmat2 mx=mat2(carPose.w,carPose.z,-carPose.z,carPose.w);\n\t\tvec3 v=z0-vec3(carPose.x,carHeight,carPose.y);\n\t\tv.xz=mx*v.xz;\n\t\tfloat d2=length(max(abs(v)-vec3(carWidth,carHeight,carLength),0.0));\n\t\tif(d2<d){d=d2;scar=v;id=carIdx;}\n\t}\n\tif(d<0.025){//now find distance to the actual car model\n\t\td=DEC(scar);\n\t} \n\tif(dg<d){id=0;d=dg;}\n\treturn d;\n}\nvec3 sky(vec3 rd){\n\treturn mix(vec3(0.5,0.4,0.3),vec3(0.4,0.5,0.7),0.5+rd.y+cos(rd.x*3.14159)*0.5);\n}\nvec4 scene(vec3 ro, vec3 rd){\n\tfloat t=0.0,d,od=1.0;\n\tfor(int i=0;i<ITERS;i++){\n\t\tt+=d=DE(ro+rd*t);\n\t\tif(d<0.0001 || t>3.0)break;\n\t\tod=d;\n\t}\n\tt=min(t,3.0);\n\tvec3 col=sky(rd);\n\tif(d<0.1){\n\t\tfloat dif=1.0-clamp(d/od,0.0,0.8);\n\t\tvec3 so=ro+rd*t;\n\t\tvec3 scol=vec3(0.0);\n\t\tif(id==0){\n\t\t\tfloat c=track_val(so.xz);\n\t\t\tvec3 grnd=vec3(0.3+10.0*so.y,1.0,0.7-12.0*so.y)+texture(iChannel1,so.xz*0.1).rgb*0.3;\n\t\t\tif(rd.y<0.0){\n\t\t\t\tfloat tmax=-ro.y/rd.y;\n\t\t\t\tso.xz=ro.xz+rd.xz*tmax;\n\t\t\t}\n\t\t\tvec3 trk=vec3(0.4)+texture(iChannel1,so.xz).rgb*0.1;\n\t\t\ttrk = mix(trk, vec3(1.0), clamp(dot(normalize(finishDir), normalize(so.xz)) * 10000.0 - 9999.0, 0.0, 1.0));\n\t\t\tscol=mix(trk,grnd,clamp(c*20.0,0.0,1.0));\n\t\t\td=DEC(scar);\n\t\t\tscol*=clamp(0.3+d*100.0,0.0,1.0);\n\t\t}else{\n\t\t\tscol=car_color_from_index(id).rgb;\n\t\t\tCarCol(scar,d,scol);\n\t\t}\n\t\tscol*=dif;\n\t\tcol=mix(scol,col,t/3.0);\n\t}\n\treturn vec4(col*1.5,1.0);\n}\n\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    \n\tvec4 carPose=texture(iChannel0, vec2(CAR_POSE, 0.5) / iResolution.xy);\n    vec3 ro=vec3(carPose.x,carHeight*1.1,carPose.y); // <<<<<<<<<<<<<\n\tvec3 rd=vec3((fragCoord-0.5*iResolution.xy)/iResolution.x,1.0);rd.x=-rd.x;\n\trd=lookat(vec3(carPose.z,-0.002,carPose.w))*normalize(rd);\n\tvec4 color = scene(ro,rd);\n    \n    if (fragCoord.y < iResolution.y * 0.08)\n    {            \n        vec2 uv = fragCoord.xy / iResolution.xx;\n        \n        color = mix(color, vec4(0.0, 0.0, 0.0, 1.0),\n                    clamp(1.0 - max(abs(uv.y - 0.02) * 200.0, abs(uv.x - 0.5) * 210.0 - 100.0), 0.0, 1.0));\n        \n        for (int i = 0; i < 8; i++)\n        {\n            float carIdx = float(i) + .5;\n            vec4 carProgress = texture(iChannel0, vec2(CAR_PROGRESS, carIdx) / iResolution.xy);\n            vec2 pos = vec2(0.02 + clamp(carProgress.x / LAPS, 0.0, 1.0) * 0.96, 0.02);\n            vec4 carColor = car_color_from_index(i);\n\n            float rad = (i == 0) ? 80.0 : 150.0;\n            \n            float k = clamp(4.0 - length((uv - pos) * rad) * 3.0, 0.0, 1.0);\n            color = mix(color, vec4(0.0, 0.0, 0.0, 1.0), k);\n            k = clamp(4.0 - length((uv - pos) * rad * 1.15) * 3.0, 0.0, 1.0);\n            color = mix(color, carColor, k);\n\n        }\n    }\n\n    // start lights\n    //{\n    \tvec4 carProgress = texture(iChannel0, vec2(CAR_PROGRESS, 0.5) / iResolution.xy);\n        if (carProgress.w < 1.4)\n        {\n        \tvec2 uv = (iResolution.xy - fragCoord.xy) / iResolution.xx;\n            \n            for (int i = 0; i < 3; i++)\n            {            \n                vec4 lightColor = carProgress.w >= 1.0 ? vec4(0.0, 1.0, 0.0, 1.0) :\n                \tvec4(carProgress.w > float(i + 1) / 3.0 ? 1.0 : 0.0, 0.0, 0.0, 1.0);\n                vec2 pos = vec2(0.5 - float(i - 1) * 0.1, 0.1);\n                float rad = 25.0;\n                float k = clamp(17.0 - length((uv - pos) * rad) * 16.0, 0.0, 1.0);\n                color = mix(color, vec4(0.0, 0.0, 0.0, 1.0), k);\n                k = clamp(17.0 - length((uv - pos) * rad * 1.15) * 16.0, 0.0, 1.0);\n                color = mix(color, lightColor, k);\n            }\n        }\n    //}\n    // vec4 carProgress = texture(iChannel0, vec2(CAR_PROGRESS, 0.5) / iResolution.xy);\n\tif(carProgress.y>0.0){\n\t\tvec2 uv = 5.0*fragCoord.xy / iResolution.xx;\n\t\tvec2 h=sin(2.0*vec2(uv.x,uv.x+uv.y)+iTime);\n\t\tuv+=h*0.1;\n\t\tvec2 p=fract(uv)-vec2(0.5);\n\t\tvec3 chk=mix(vec3(0.25),vec3(1.0),smoothstep(0.0,0.01,sign(p.x*p.y)*min(abs(p.x),abs(p.y))));\n\t\tcolor.rgb=mix(chk,color.rgb,0.8+0.2*(h.x+h.y));\n    \t}\n\tfragColor = color; //vec4(0, is_key_pressed(KEY_A), 0, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//eiffie - This is almost intact from the original https://www.shadertoy.com/view/lsK3RK by Imp5\n//I changed the start/end positions to make it more challenging since driving \"in car\" is easier.\n\n// GLSL Racing Concept\n// Created by Alexey Borisov / 2016\n// License: GPLv2\n\n\nconst float PI = 3.141592653;\n\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_R = 82.5 / 256.0;\nconst float KEY_LEFT = 37.5 / 256.0;\nconst float KEY_UP = 38.5 / 256.0;\nconst float KEY_DOWN = 40.5 / 256.0;\nconst float KEY_RIGHT = 39.5 / 256.0;\n\nconst float LAPS = 6.0;\n\nconst float IS_INITED = 0.5;\nconst float CAR_POSE = 1.5;\nconst float CAR_VEL = 2.5;\nconst float DEBUG_DOT = 3.5;\nconst float CAR_PROGRESS = 4.5;\n\nconst float MAX_SPEED = 1.2;\n\nconst float carLength = 0.045;\nconst float carWidth = 0.02;\n\nfloat is_key_pressed(float key_code)\n{\n    return texture(iChannel1, vec2((key_code), 0.0)).x;\n}\n\nvec2 track_distort(vec2 pos)\n{\n    pos *= 0.5;    \n    pos -= vec2(cos(pos.y * 2.4), sin(pos.x * 2.0 - 0.3 * sin(pos.y * 4.0))) * 0.59;\n    return pos;\n}\n\nfloat track_val(vec2 pos)\n{\n    pos = track_distort(pos);\n    return abs(1.0 - length(pos)) * 8.0 - 1.0;\n}\n\nvec2 track_grad(vec2 pos)\n{\n    const float d = 0.01;\n    float v0 = track_val(pos);\n    return vec2(track_val(pos + vec2(d, 0)) - v0, track_val(pos + vec2(0, d)) - v0) / d;\n}\n\nvec2 get_point_on_track(vec2 pos)\n{\n    for (int i = 8; i >= 0; i--)\n        pos = pos - track_grad(pos) * float(i) * 0.001;\n    \n    return pos;\n}\n\nvec4 get_val(float variable, float index)\n{\n    return texture(iChannel0, vec2(variable, index) / iResolution.xy);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.45, 0.0, 0.0, 1.0);\n    vec4 debugDot = vec4(100.0, 100.0, 1.0, 1.0);\n        \n    if (fragCoord.y <= 8.0 && fragCoord.x <= 10.0)\n    {\n        float carIdx = fragCoord.y;\n        if (get_val(IS_INITED, carIdx).x < 0.99 || is_key_pressed(KEY_R) > 0.5) // not inited\n        {\n            if (fragCoord.x < ceil(IS_INITED))\n                fragColor = vec4(1, 0, 0, 1);\n            else if (fragCoord.x < ceil(CAR_POSE))\n            {\n\t\t\tif(carIdx<0.75)carIdx+=8.0;\n                fragColor = vec4(1.2 + carIdx * 0.094 + (fract(carIdx * 0.5) - 0.2) * 0.2, 1.85 - carIdx * 0.074, -1.0, 0.8);\n                fragColor.zw = normalize(fragColor.zw);\n            }\n            else if (fragCoord.x < ceil(CAR_VEL))\n                fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n            else if (fragCoord.x < ceil(DEBUG_DOT))\n                fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n            else\n                fragColor = vec4(0.0, 0.0, 0.0, 0.0);               \n        }\n        else // inited\n        {\n            vec4 carPose = get_val(CAR_POSE, carIdx);\n            vec2 carPos = carPose.xy;\n            vec2 prevPos = carPos;\n            vec2 carDir = carPose.zw;\n            vec2 carLeft = normalize(vec2(-carDir.y, carDir.x));\n            vec3 carVel3 = get_val(CAR_VEL, carIdx).xyz;\n            vec2 carVel = carVel3.xy;\n            float carOmega = carVel3.z;\n            vec4 carProgress = get_val(CAR_PROGRESS, carIdx);\n            \n            // Detect dt manually,\n            // this is workaround for iTimeDelta issue\n            float timeLoop = mod(iTime, 128.0);\n            float dt = clamp(timeLoop - carProgress.z, 0.01, 1.0 / 30.0);\n            carProgress.z = timeLoop;\n \n                       \n            float timeAfterFinish = min(carProgress.y, 1.0);//clamp(iTime - 3.0, 0.0, 1.0);\n           \n            if (carIdx <= 1.0 && timeAfterFinish <= 0.0)\n            {\n                carOmega *= 0.96 - (dt - 1.0 / 60.0) * 8.0;\n               \n                if (is_key_pressed(KEY_W) > 0.5 || is_key_pressed(KEY_UP) > 0.5)\n                    carVel += 1.0 * carDir * dt;\n                if (is_key_pressed(KEY_S) > 0.5 || is_key_pressed(KEY_DOWN) > 0.5)\n                    carVel -= 1.0 * carDir * dt;\n               \n                if (is_key_pressed(KEY_A) > 0.5 || is_key_pressed(KEY_LEFT) > 0.5)\n                {\n                    carOmega += 1.55 * dt;\n                    carVel *= 0.999;\n                }\n                if (is_key_pressed(KEY_D) > 0.5 || is_key_pressed(KEY_RIGHT) > 0.5)\n                {\n                    carOmega -= 1.55 * dt;\n                    carVel *= 0.999;                \n                }\n            }\n            else\n            {                \n                carOmega *= 0.85 - (dt - 1.0 / 60.0) * 11.0;\n               \n                float accel = min(1.0, 0.9 +\n                    0.1 * sin(carIdx + iTime * (0.25 + carIdx * 0.2)) - (floor(carIdx / 2.0) - 0.85) * 0.13);\n\n                carVel += accel * carDir * dt;\n                \n                carVel *= clamp((5.0 - timeAfterFinish), 0.0, 1.0);\n                //carSpeed = length(carVel);\n                \n                float posOnTrack = sin((carIdx + 2.0) * iTime * 0.2 + carIdx) * 0.025 + 0.97;\n                                \n                vec2 wishPos = posOnTrack * get_point_on_track(carPos + normalize(carDir) * (0.2 + length(carVel) * 0.4));\n                //wishPos += vec2(0.0, 0.5) * timeAfterFinish;\n                vec2 wishDir = normalize(wishPos - carPos);\n                carOmega += 8.0 * dt * clamp(dot(wishDir, carLeft) * (5.0 - carIdx * 0.5), -1.0, 1.0) * min(carProgress.w - 0.8, 1.0);\n                    \n\t\t       \n\t         //   debugDot.xy = wishPos;\n            }\n            \n            if (carProgress.w < 1.0)\n            \tcarVel = vec2(0.0, 0.0);\n            \n            carOmega = clamp(carOmega, -1.0, 1.0);\n            carDir += carLeft * dt * min(length(carVel) * 4.0 * carOmega, 2.0);\n            carDir = normalize(carDir);\n                        \n            float wall =\n                max(track_val(carPos - carLeft * carWidth - carDir * carLength), 0.0) +\n                max(track_val(carPos - carLeft * carWidth + carDir * carLength), 0.0) +\n                max(track_val(carPos + carLeft * carWidth - carDir * carLength), 0.0) +\n                max(track_val(carPos + carLeft * carWidth + carDir * carLength), 0.0);\n\n            // collision with walls\n            if (timeAfterFinish < 0.001)\n            {\n            \tif (wall > 0.0)\n            \t{\n\t                carVel *= 1.0 - 0.04 * min(wall * 10.0, 1.0);\n\t            \tcarPos -= track_grad(carPos) * min(wall * 0.02, 0.02);\n\t                vec2 grad = track_grad(carPos);\n\t                vec2 gradLeft = normalize(vec2(-grad.y, grad.x));\n\t                carDir = normalize(carDir + dot(gradLeft, carDir) * gradLeft * length(carVel) * dt * 5.0);\n\t            }\n            }\n            else\n            {\n                carVel *= 1.0 - clamp((wall - 1.0) * 0.02, 0.0, 1.0);\n            }\n            \n            // collision with cars\n            {\n                for (int i = 0; i < 8; i++)\n                {\n                   \tfloat secondIdx = float(i) + .5;\n                    if (abs(secondIdx - carIdx) > 0.5)\n                    {\n                        vec4 secondPose = get_val(CAR_POSE, secondIdx);\n                        vec2 secondPos = secondPose.xy;\n                        vec2 secondDir = secondPose.wz;\n                        vec2 secondVel = get_val(CAR_VEL, secondIdx).xy;\n                        \n                        vec2 dir = normalize(carPos - secondPos);\n                        float cDist = (carLength - carWidth);\n                        float cWidth = carWidth * 2.1;\n                        float k = 0.0;\n                        k = max(k, (cWidth - length(carPos + cDist * carDir - secondPos - cDist * secondDir)) / cWidth);\n                        k = max(k, (cWidth - length(carPos - cDist * carDir - secondPos - cDist * secondDir)) / cWidth);\n                        k = max(k, (cWidth - length(carPos + cDist * carDir - secondPos + cDist * secondDir)) / cWidth);\n                        k = max(k, (cWidth - length(carPos - cDist * carDir - secondPos + cDist * secondDir)) / cWidth);\n                        k = max(k, (cWidth - length(carPos - cDist * carDir - secondPos)) / cWidth);\n                        k = max(k, (cWidth - length(carPos + cDist * carDir - secondPos)) / cWidth);\n\n                        carPos += dir * 0.02 * k;\n                        carVel += dir * 0.2 * k;\n                        carDir = normalize(carDir + secondDir * 0.1 * k);\n                    }\n                }\n            }\n            \n            // friction\n            {\n                float carSpeed = min(length(carVel), MAX_SPEED * 1.1);\n            \tfloat fr = carSpeed / MAX_SPEED;\n            \tcarSpeed = max(carSpeed - dt * (0.1 + fr * fr * fr), 0.0);\n            \tif (carSpeed > 0.00001)\n\t            \tcarVel = carSpeed * normalize(carVel + carDir * dt * 4.0);\n            }\n                                \n\n            carPos += carVel * dt;\n            \n            //progress\n            {\n                vec2 trackPrev = prevPos;\n                vec2 trackCur = carPos;\n            \tfloat prevAngle = atan(trackPrev.y, trackPrev.x);\n            \tfloat angle = atan(trackCur.y, trackCur.x);\n            \tfloat dAngle = angle - prevAngle;\n            \tdAngle = abs(dAngle) > 1.0 ? 0.0 : dAngle;\n\t                            \n\t            carProgress.x += dAngle / (2.0 * PI);\n                \n                if (carProgress.x > LAPS)\n                    carProgress.y += dt;\n                \n                carProgress.w += dt * 0.3333;\n            }\n            \n                        \n            if (fragCoord.x < ceil(IS_INITED))\n                fragColor = vec4(1, 1, 1, 1);\n            else if (fragCoord.x < ceil(CAR_POSE))\n            {\n                fragColor.xy = carPos;\n                fragColor.zw = carDir;\n            }\n            else if (fragCoord.x < ceil(CAR_VEL))\n                fragColor = vec4(mix(carVel, carVel3.xy, 0.25), carOmega, 0.0);\n            else if (fragCoord.x < ceil(DEBUG_DOT))\n                fragColor = debugDot;\n            else if (fragCoord.x < ceil(CAR_PROGRESS))\n                fragColor = carProgress;\n        }\n    }\n    else\n        fragColor = vec4(0.0, 1.0, 0.0, 1.0);    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}