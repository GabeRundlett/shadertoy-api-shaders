{
    "Shader": {
        "info": {
            "date": "1389008433",
            "description": "Aardman's (from Wallace & Gromit fame) early work. Morph, the plasticine animation from British childhoods in the 70s and 80s.\nEpisode on YouTube: [url]https://www.youtube.com/watch?v=daQfoN_xXIc[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "XdS3Wm",
            "likes": 50,
            "name": "Hello Morph!",
            "published": 3,
            "tags": [
                "morph",
                "hellomorph"
            ],
            "usePreview": 0,
            "username": "Dave_Hoskins",
            "viewed": 7382
        },
        "renderpass": [
            {
                "code": "// Hello Morph! By David Hoskins. Jan 2014.\n// Aardman's (from Wallace & Gromit fame) early work.\n// http://www.youtube.com/watch?v=jSMRPKM1evk\n\n// Morph, the plasticine animation from British childhoods in the 70s and 80s:-\n// https://www.youtube.com/watch?v=daQfoN_xXIc\n\n// COMMENT THE NEXT LINE TO REMOVE STOP MOTION FRAME JUDDER...\n#define STOP_MOTION_EFFECT\n\n// Some often adjusted defines in one place...\n#define elbowR\t\tvec3(1.0, -.1, 0.3)\n#define shoulderR\tvec3(0.4, 0.56,  -.05)\n#define wristR\t\tvec3(.5, -.4, -0.1)\n#define shoulderL\tvec3(-0.4, 0.56, -.05)\n#define sunColour\tvec3(1.0)\n#define skinColour  vec3(.65, .22, 0.14)\n#define sunDir\t\tvec3(.42562, .59588, -.681005)\n#define PI 3.14159265359\n\n// Animation variables.\n// Possibly a bad idea using globals, but it seems OK if there's only a few of them.\n// They make it much quicker and easier than passing everything in functions.\nfloat wave;\nfloat hel;\nfloat low;\nfloat nod;\nfloat time;\n\n//----------------------------------------------------------------------------------------\nfloat Hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(32.3391, 38.5373))) * 74638.5453);\n}\n\n//----------------------------------------------------------------------------------------\n// 2D rotations for 3D vectors make them quicker on axis rotations...\nvec2 Rotate2(vec2 p, float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(co, si, -si, co) * p;\n}\n\n//----------------------------------------------------------------------------------------\nfloat Segment(vec3 p,  vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r1 + r2*h;\n}\n\n//----------------------------------------------------------------------------------------\nfloat Mouth( vec3 p, vec3 a)\n{\n\tfloat curve = cos(p.x*(5.35+sin(-time)*1.25))*.11;\n\tp.y += curve;\n\ta.y += pow(abs(curve), 2.0);\n\treturn length(max(abs(p) - a,0.0)) -.02;\n}\n\n// IÃ±igo's distance functions...\n//----------------------------------------------------------------------------------------\nfloat  Sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n//----------------------------------------------------------------------------------------\nfloat Cylinder( vec3 p, vec2 h )\n{\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------------------------------------------\nfloat RoundBox( vec3 p, vec3 b, float r )\n{\n\t//b.x -= p.y * .08;\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\n//----------------------------------------------------------------------------------------\nfloat Nose(vec3 p, vec3 a, float r )\n{\n\tfloat h = clamp( dot(p,a)/dot(a,a), 0.0, 1.0 );\n\treturn length( p - a*h ) - r;\n}\n\n//----------------------------------------------------------------------------------------\nfloat sMin( float a, float b )\n{\n    float k = .12;\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\n//----------------------------------------------------------------------------------------\nvec2 Map( in vec3 pos )\n{\n    vec2 res = vec2( 1000.0, 3);\n\tfloat d;\n\tpos.y += -1.0;\n\tvec3 elbowL\t\t= vec3(-.95-wave*.05, .2, -0.25);\n\tvec3 wristL\t\t= vec3(elbowL.x+1.0*sin(wave)*.55, elbowL.y+cos(wave)*.55, -.75);\n\t\n\t// Head...\n\tvec3 p = pos;\n\t// Rotate around Y axis for waist movment...\n\tfloat h = sin(time*2.3) * .1 - wave*0.01;\n\tp.xz = Rotate2(p.xz, h);\n\tvec3 p2 = p;\n\t// Rotate head around X axis...\n\tp2.zy = Rotate2(p.zy, nod+hel*2.0+wave*.012);\n\tp2 -= vec3(0.0, 0.0, -0.05);\n\t\n\td = Sphere(p2, .37);\n\tif (d < res.x)\n\t{\n\t\tres.x = d;\n\t\tvec3 p3 = vec3(abs(p2.x), p2.yz);\n\t\tif (dot(normalize(p3*vec3(1.0, .9, 1.0)), normalize(vec3(.32, 0.24, -.7))) > .95) res.y = 4.0;\n\t\tif (dot(normalize(p3), normalize(vec3(.32, 0.18-nod*.2, -.8))) > .993) res.y = 5.0;\n\t}\n\n\t// Mouth and inside colour...\n\tfloat mo = -Mouth(p2-vec3(0.0, -.057-hel, -0.3), vec3(.155-low, -.006+hel, .2));\n\tif (res.x  < mo ) res = vec2(mo, 2.0);\n\n\t// Nose\n\tp2 = p2-vec3(0.0, 0.0, 0.0);\n\tres.x = min(res.x, Nose(p2, vec3(.0,0.0,-.5), 0.06));\n\t\n\t// Neck...\n\tp = p-vec3(0.0, -.4, .1);\n\td = Cylinder(p, vec2(0.171, .17));\n\tres.x = sMin(res.x, d);\n\n\t// Body...\t\n\tp = p-vec3(0.0, -.82, 0.0);\n\td = RoundBox(p, vec3(0.175, .45, 0.0), .26);\n\tres.x = sMin(res.x, d);\n\t\t\t\n\t// Right arm upper...\n\tp = p-vec3(0.0, 0.0, 0.0);\n\td = Segment(p, shoulderR, elbowR, .17, .05);\n\tres.x = sMin(res.x, d);\n\t// Right arm lower...\n\td = Segment(p, elbowR, wristR, .15, .05);\n\tres.x = sMin(res.x, d);\n\t// Right hand...\t\n\td = Segment(p*vec3(1.0, .75, 1.0), wristR+vec3(0, .1, 0.), wristR+vec3(-.15, .05, -.15), .13, .02);\n\tres.x = min(res.x, d);\n\t\n\t// Left arm upper...\n\td = Segment(p, shoulderL, elbowL, .17, .05);\n\tres.x = sMin(res.x, d);\n\t// Left arm lower...\n\td = Segment(p, elbowL, wristL, .15, .05);\n\tres.x = sMin(res.x, d);\n\t\n\t// Left Hand...\t\n\tp = (p-wristL);\n\tp.z -= p.x*.5;\n\tp.yx = Rotate2(p.yx, -wave*1.5);\n\td = Segment(p, vec3(0.0), -vec3(-.25, -0.15, 0.1), .06, .01);\n\tres.x = sMin(res.x, d);\n\td = RoundBox(p-vec3(0.0, .25, 0.0), vec3(.042, .085, -.05), .09);\n\tres.x = sMin(res.x, d);\n\t\n\t// Mirrored legs...\n\tp = pos + vec3(0.0, .35, -.05);\n\tp.y += .8;\n\tp.x = abs(p.x);  // <- does the mirroring.\n\tvec3 ankle  = vec3(0.3, -1.85, 0.0);\n\td = Segment(p, vec3(0.22, -.75, 0.0), ankle, .225, .05);\n\tres.x = sMin(res.x, d);\n\t\n\t// Feet...\n\tankle.y -=.3;\n\td = Segment(p, ankle, ankle + vec3(0.27, -.05, -0.3), .24, .05);\n\td = max((ankle.y-p.y), d);\n\tres.x = sMin(res.x, d);\n\n\t// Do wooden box...\n\td = RoundBox(pos + vec3(-4.2, 2.7, -1.0), vec3(2.0, .5, 1.0), .075);\n\td = min(d, RoundBox(pos + vec3(-4.2, 1.9, -1.0), vec3(2.0, .185, 1.0), .075));\n\tif (d < res.x)\n\t{\n\t\tres = vec2(d, 1.0);\n\t}\n    \n\n    return res;\n}\n\n//----------------------------------------------------------------------------------------\nvec2 RayMarch( in vec3 ro, in vec3 rd, in vec2 fragCoord, out int hit)\n{\n\tconst float precis = 0.01;\n\tfloat t = .5 + .1 * Hash(fragCoord.xy);\n\thit = 0;\n\tvec2 res = vec2(precis*2.0, 0.0);\n    for( int i = 0; i < 73; i++ )\n    {\n\t\tif (hit == 0 && t < 20.0)\n\t\t{\n\t\t\tres = Map(ro + rd * t);\n\t\t\tif(res.x < precis)\n\t\t\t{\n\t\t\t\thit = 1;\n                break;\n\t\t\t}else\n\t\t\t\tt += max(.005, res.x * .5);\n\t\t}\n    }\n\t// Missed scene, so do table with basic ray casting.\n\t// There's no point in ray-marching the flat gound as it's a\n\t// waste of cycles, especially for background location and accuracy.\n\t// (Well, in this case anyway)\n\tif (hit == 0 && rd.y < 0.0)\n\t{\n\t\thit = 2;\n\t\trd.y = min(rd.y, 0.0);\n\t\tt = (-2.3-ro.y) / rd.y;\n\t\tres.y = 6.0;\n\t}\n\t// Return the distance to point and material type.\n\treturn vec2( t, res.y);\t\n}\n\n//----------------------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.1;\n\tfloat h;\n\t\n    for (int i = 0; i < 7; i++)\n\t{\n\t\th = Map( ro + rd*t ).x;\n\t\tres = min(7.0*h / t, res);\n\t\tt += h+.04;\n\t}\n    return max(res, 0.0);\n}\n\n//----------------------------------------------------------------------------------------\nvec3 Normal( in vec3 pos )\n{\n\n\tconst vec2 eps = vec2( 0.015, 0.0);\n\tvec3 nor = vec3(\n\t    Map(pos+eps.xyy).x - Map(pos-eps.xyy).x,\n\t    Map(pos+eps.yxy).x - Map(pos-eps.yxy).x,\n\t    Map(pos+eps.yyx).x - Map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 GetMaterial(vec3 pos, vec3 norm, float mat)\n{\n\t// These teture reads had to be moved out of the 'if' statements as\n\t// Windoes Chrome34 WebGL broke badly in the hands of those ANGLE guys! :p\n\tvec3 col = texture(iChannel0, pos.xz*.3).xyz*.65;\t// Table\n\tvec3 tx1 = texture(iChannel0, pos.xy*vec2(.05, .25)).xyz * abs(norm.z+norm.x);\n\tvec3 tx2 = texture(iChannel0, pos.xz*vec2(.05, .25)).xyz * norm.y;\n\n\tfloat blink = step(mod(time-1.0, 3.0), .11);\n\tif (mat < 1.5)\n\t{\n\t\t// Wooden box is a lighter version of the table texture.\n\t\tcol =  tx1;\n\t\tcol += tx2;\n\t\tcol = sqrt(col);\n\t}else if (mat < 2.5)\n\t{\n\t\t// Inside mouth...\n\t\tcol = skinColour*.5;\n\n\t}else if (mat < 3.5)\n\t{\n\t\t// Plasticine...\n\t\tcol = skinColour;\n\n\t}else if (mat < 4.5)\n\t{\n\t\t// Eye balls...\n\t\tcol = skinColour * .7 * blink + vec3(1.0) * (1.0-blink);\n\t}else if (mat < 5.5)\n\t{\n\t\t// Pupil...\n\t\tcol = skinColour * .7 * blink;// + vec3(0.0) * (1.0-blink);\n\t}\n\treturn col;\n}\n\n//----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Stop motion time...\n#ifdef STOP_MOTION_EFFECT\n\ttime = mod((floor(iTime*30.0) / 30.0), 20.0)-.7;\n#else\n\ttime = mod(iTime, 20.0)-.7;\n#endif\n\n\tvec3 col = vec3(0.85);\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\t// Animation...\n\twave = sin(time*15.0-.8+sin(time)*2.0)*.5+.5;\n\twave = wave*wave*(3.0-2.0*wave)-.7;\n\tfloat m = fract(time*.19);\n\thel = (1.0+sin(m*100.0)) * .02 * (smoothstep(0.0, .015, m) - smoothstep(0.05, .15, m));\n\tlow = (smoothstep(0.05, .1, m)-smoothstep(0.12, .15, m))*.11;\n\tnod = -(smoothstep(0.22, .28, m)-smoothstep(0.28, .31, m))*.5;\n\t\n\t// Camera position...\n\tfloat t = clamp(time-3.5, 0.0, 1.0);\n\tt = t*t*(3.0-2.0*t);\n\tvec3 origin = mix(vec3(0.0, 1.0, -1.275), vec3(-1.0, 1.0, -5.5), t);\n\tvec3 target = mix(vec3(0.0, 1.0, 4.0),  vec3( 0.5, -.4, 0.0), t);\n\torigin = mix(origin, vec3( 1.0, 1.0, -5.0), clamp((time-6.0)*.075, 0.0, 1.0));\n\n\t// Camera matrix...\n\tvec3 cw = normalize( target-origin);\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = cross(cu,cw);\n\tvec3 ray = normalize( p.x*cu + p.y*cv + 2.6*cw );\n\n\t// Do the rendering...\n\tvec3 pos, norm;\n\tint hit = 0;\n\tvec2 res = RayMarch(origin, ray, fragCoord, hit);\n\n\tif (hit > 0)\n\t{\n\t\tpos = origin + res.x * ray;\n\t\t// Is it the ground?...\n\t\thit == 2 ? norm = vec3(0.0, 1.0, 0.0) : norm = Normal(pos);\n\n\t\tcol\t= GetMaterial(pos, norm, res.y);\n\t\t\n\t\tfloat diff = max(dot(norm, sunDir), 0.0);\n\t\tfloat ambi = clamp(.2 + 0.2 * norm.y,0.0, 1.0);\n\t\tfloat shad = Shadow(pos, sunDir);\n\t\tfloat spec = max( 0.0, pow( max( dot(sunDir,reflect(ray, norm)), 0.0), 5.0) ) * .08;\n\t\t// Do the lighting... \n\t\tvec3 lite = diff * sunColour * shad + col*ambi;\n\t\tcol = col * lite + spec * shad;\n\t\t// Fog the background...\n\t\tcol = mix(col, vec3(.85), clamp(res.x*res.x*.001-.2, 0.0, 1.0));\n\t}\t\n\t\n\t// Post effects...\n\tcol = pow(col,vec3(.5));\n\t// Add noise and fake flicker for old animation effect.\n\tfloat flick = max(1.-sin(fract(iTime*1.1) * PI), 0.0) * .03;\n\tcol += Hash(floor(p*iResolution.y*.25)-time) * .035 -flick;\n\tt = 32.0*q.x*q.y*(1.0-q.x)*(1.0-q.y);\n\t// Make screen edge effects to frame the scene and make it look older...\n\tcol   -= (1.0-pow(t, 0.1)) * .25;\n\tcol.y -= (1.0-pow(t, 0.3-flick*3.0)) * .1;\n\tcol.z -= (1.0-pow(t, 0.3)) * .05;\n    fragColor=vec4(clamp(col, 0.0, 1.0), 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}