{
    "Shader": {
        "info": {
            "date": "1637341948",
            "description": "Click to terraform :-)\nImproved version: https://www.shadertoy.com/view/stVGRy",
            "flags": 32,
            "hasliked": 0,
            "id": "tlsSRr",
            "likes": 21,
            "name": "Terraforming",
            "published": 3,
            "tags": [
                "interactive",
                "sphere",
                "diffusion",
                "reaction"
            ],
            "usePreview": 0,
            "username": "hamtarodeluxe",
            "viewed": 414
        },
        "renderpass": [
            {
                "code": "#define RMSTEPS 75\n\nvec2 getData(vec3 p)\n{\n    vec2 v = texture(iChannel0, cartToSm(p) * simResRatio).xy;  \n    return vec2(v.x, 1.-v.y);\n}\n\nfloat hash( uint n ) //iq\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat getHeight(vec2 data, vec3 p)\n{\n    float t = getTypeBlendSS(p, iChannel1, iTime);\n    return 0.9*MAXDISP*(data.y * 0.6 + mix(0.0,0.3, t));\n}\n\nvec3 normals(vec3 p)\n{\n    vec3 n;\n    float EPS = 0.01f;\n    vec3 e = vec3(EPS,0.,0.);\n    float baseR = RADIUS-MAXDISP;\n    n.x = length(p + e) - getHeight(getData(p+e), p+e) - (length(p - e) - getHeight(getData(p-e), p-e));\n    \n    e = vec3(0.,EPS,0.);\n    n.y = length(p + e) - getHeight(getData(p+e), p+e) - (length(p - e) - getHeight(getData(p-e), p-e));\n\n    e = vec3(0.,0., EPS);\n    n.z = length(p + e) - getHeight(getData(p+e), p+e) - (length(p - e) - getHeight(getData(p-e), p-e));\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 dc = (vec2(fragCoord)/iResolution.xy)*2.-1.;\n\tdc.y *= float(iResolution.y)/float(iResolution.x);\n    \n    vec3 ro = cameraPos(iTime);\n\tvec3 rd = cameraRay(dc, ro);\n    \n    float h = hash(uint(fragCoord.x)+uint(fragCoord.y*iResolution.x)+uint(iFrame)*uint(iResolution.x*iResolution.y));\n    \n    vec3 hitSphP = vec3(1000., 1000.,1000.);\n    vec2 hitTs = vec2(1000.,1000.);\n    bool hitSph = isecSphere(ro, rd, vec3(0.), RADIUS, hitTs, hitSphP);\n    bool hitSurf = false;\n    vec3 p = vec3(0.);\n    vec2 data = vec2(1.);\n\n    if (hitSph)\n    {\n        vec3 hitSphPIn = vec3(1.,1.,1.);\n        vec2 hitTsSphIn = vec2(100.);\n        bool hitSphIn = isecSphere(ro, rd, vec3(0.), RADIUS-MAXDISP, hitTsSphIn, hitSphPIn);\n        float maxT = min(hitTs.y, hitTsSphIn.x) - hitTs.x;\n\n        float d = 500.;\n        ro = hitSphP;\n        float tLength = maxT / float(RMSTEPS);\n        float t = tLength * h;\n\n        float prevSurfH = MAXDISP;\n\n        for (int i = 0; i<RMSTEPS; i++)\n        {\n            p = ro + t*rd;\n            data = getData(p);     \n\n            float surfH = getHeight(data, p);\n            float baseR = RADIUS-MAXDISP;\n            float h = length(p) - baseR; \n            \n            if(h<surfH)\n            {           \n                float maxSurfH = prevSurfH;\n                float minSurfH = surfH; \n                float maxT = t - tLength;\n                float minT = t;\n                float maxDelta = (length(ro + maxT*rd) - baseR)-maxSurfH;\n                float minDelta = minSurfH-h;\n\n                t = mix(minT, maxT, minDelta / (maxDelta+minDelta));\n                p = ro + t*rd;\n                h = length(p) - baseR;\n                data = getData(p); \n                surfH = getHeight(data, p);\n\n                for (int j = 0; j < 3; j++)\n                {\n                    if (h < surfH)\n                    {\n                        minT = t;\n                        minSurfH = surfH;\n                    }\n                    else\n                    {\n                        maxT = t;\n                        maxSurfH = surfH;\n                    }\n                    maxDelta = (length(ro + maxT*rd) - baseR)- maxSurfH;\n                    minDelta = minSurfH-(length(ro + minT*rd) - baseR);\n                  \n                    t = mix(minT, maxT, minDelta / (maxDelta+minDelta));\n                    p = ro + t*rd;\n                    h = length(p) - baseR;\n                    data = getData(p); \n                    surfH = getHeight(data, p);\n                }\n\n                hitSurf = true;\n                t = t; \n                break;\n            }\n            prevSurfH = surfH;\n            t+=tLength;\n        }\n\n    }\n    vec3 col = vec3(0.05);\n\n    if (hitSurf)\n    {\n        float typeBlend = getTypeBlendSS(p, iChannel1, iTime);\n        vec3 colB = mix(0.5*vec3(0.15, 0.01, 0.01),vec3(1.,0.5,0.2),pow(data.y,7.));\n        vec3 colA = mix(vec3(0.,0.1,0.1),0.8*vec3(0.1,0.8,1.),pow(data.x,2.));\n        colA += 0.05*vec3(1.,1.,1.)*smoothstep(0.99,1., data.y);\n        float e =0.1f;\n        vec3 n = normals(p);\n        vec3 lightPos = vec3(2.,5.,2.);\n        \n        col = mix(colA, colB,typeBlend); \n        vec3 lightDir = normalize(lightPos-p);\n        \n        vec3 ref = normalize(reflect (lightDir, n));\n        vec3 spec = vec3(1.)*mix(1.,.3,typeBlend)*pow(clamp(dot(ref,rd),0.,1.),mix(60.,5.,typeBlend)); \n\n        col += spec;\n    }\n    \n    // Output to screen\n    float v = 1./pow((pow(sqrt(0.05*h+dot(dc * 2., dc * 2.)*.4),2.)+1.),3.);\n    fragColor = vec4(pow(v*col, vec3(1./2.2)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n          \n    vec2 mouseDc = (vec2(iMouse.xy)/iResolution.xy)*2.-1.;\n\tmouseDc.y *= float(iResolution.y)/float(iResolution.x);\n    \n    vec3 ro = cameraPos(iTime);\n\tvec3 rd = cameraRay(mouseDc, ro);   \n    vec3 hitSphP = vec3(1.);\n    vec2 outT = vec2(1000.);\n    bool hitSph = isecSphere(ro, rd, vec3(0.), RADIUS-MAXDISP*0.5, outT, hitSphP);\n    \n    vec2 C = RUNKERNEL\n\n    if (iMouse.z>0. && hitSph)\n    {\n        vec3 pTex = smToCart(uv/simResRatio);\n        vec3 pMouse = normalize(hitSphP);\n    \tC.y += 00.1*(1.-clamp(length(pTex-pMouse)/0.125,0.,1.));\n    } \n    \n    C = clamp(C,vec2(0.00),vec2(1.));\n\n    if(iFrame == 0) C.xy = vec2(1.);\n   \tif (fract(fragCoord.x*0.5) == 0.) C.xy=vec2(0.,0.);\n\n    fragColor = vec4(C.xy,0.,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define PI 3.14159\n#define RADIUS 0.6\n#define MAXDISP 0.3\n\n#define simRes min(iResolution.xy, vec2(700, 400))\n#define simResRatio (simRes/iResolution.xy)\nvec2 fks[] = vec2[](vec2(0.014, 0.045), vec2(.0545, 0.062));\n\nfloat noise (vec3 x, sampler3D tex)\n{\n    //smoothing distance to texel https://iquilezles.org/articles/texture\n    x*=32.;\n    x += 0.5;\n    \n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\tx = f+i;    \n    x-=0.5;\n    \n    return texture( tex, x/32.0 ).x;\n}\n\nmat2x2 rot(float angle)\n{\n    return mat2x2(cos(angle), -sin(angle),\n\t\t\t\t  sin(angle), cos(angle));\n}\n\nbool isecSphere(vec3 ro, vec3 rd, vec3 pos, float r, out vec2 outT, out vec3 outP)\n{\n    float a = dot(rd,rd);\n    float b = 2.*dot(rd,(ro-pos));\n    float c = dot((ro-pos),(ro-pos))-r*r;\n    float d = b*b-4.*a*c;\n    outP = vec3(0.);\n    outT = vec2(100.);\n    if (d<0.)\n        return false;\n\n    float sd =sqrt(d);\n    outT = vec2((-b-sd)/(2.*a),(-b+sd)/(2.*a)); \n    outT = vec2(min(outT.x, outT.y), max(outT.x, outT.y));\n    outP = ro + rd*outT.x;\n    outT = abs(outT);\n    return true;\n}\n\nvec3 cartToSph(vec3 pos)\n{\n\tfloat r = length(pos);\n\treturn vec3(r,acos(pos.y/r),atan(pos.z,pos.x));//wikipedia physics convention\n}\n\nvec3 sphToCart(vec3 sc) //vec3 (radius, polar, azimuth)\n{\t\n\tfloat x = sc.x * sin(sc.y) * cos(sc.z);\n\tfloat z = sc.x * sin(sc.y) * sin(sc.z);\n\tfloat y = sc.x * cos(sc.y);\n\treturn vec3(x,y,z);\n}\n\nfloat getWidth(float y)\n{  \n\treturn pow(sin(acos(y*2.-1.)),1.) +0.000f;\n}\n\nvec3 cameraPos(float time)\n{\n    time *= 0.5f;\n    return (1.2 +0.2*sin(time))*vec3 (cos(time),1.,sin(time));\n}\nvec3 cameraRay(vec2 dc, vec3 ro)\n{\n    vec3 lookAt = vec3(0.);\n\n\tvec3 fw = normalize(lookAt-ro);\n\tvec3 rg = normalize(vec3(-fw.z,0,fw.x));\n\tvec3 up = normalize(cross(rg,fw));\n\tfloat fo = 1.5;\n\tvec3 rd = normalize(fw * fo + up * dc.y + rg * dc.x);\n\treturn rd;\n}\n\nvec2 sphToSm(vec3 sph)\n{\n    vec2 samp;\n    samp.y = (sph.y/PI);\n      \n    samp.x = ((sph.z+PI)/(2.*PI));\n    samp.x = (samp.x-0.5),\n    samp.x *= getWidth(samp.y);\n                 \n    samp.x +=0.5;\n    return samp;\n}\n\nvec3 smToSph(vec2 sm)\n{\n    vec3 sph;\n    sm.x -= 0.5f;\n    sm.x /= max(0.00000f,getWidth(sm.y));\n    sm.x += 0.5f;\n       \n    sph.z = sm.x*(2.*PI) - PI;\n    sph.y = sm.y * PI;\n    sph.x = 1.;\n    return sph;\n}\n\nvec3 smToCart(vec2 sm)\n{\n    return sphToCart(smToSph(sm));\n}\n\nvec2 cartToSm(vec3 cart)\n{\n    return sphToSm(cartToSph(cart));\n}\n\nvec2 os[8] = vec2[](vec2(0,1),\n                    vec2(0,-1),\n                    vec2(1,0),\n                    vec2(-1,0),  \n                    vec2(1,1),   \n                    vec2(1,-1),  \n                    vec2(-1,1), \n                    vec2(-1,-1));\n                    \n\nfloat myMod(float x, float y)\n{\n    return -y*floor(x/y) + mod(x,y);\n}\n\n#define typeA 0.45\n#define typeB 0.55\nfloat getTypeBlend(vec3 p, sampler3D noiseTex, float offset)\n{\n    p = normalize(p);\n    return noise(0.1*p + offset*0.002, noiseTex);\n}\nfloat getTypeBlendSS(vec3 p, sampler3D noiseTex, float offset)\n{\n\n    return smoothstep(typeA, typeB, getTypeBlend(p, noiseTex, offset));\n}\n\nfloat getTypeBlendLS(vec3 p, sampler3D noiseTex, float offset)\n{\n    float t = getTypeBlend(p, noiseTex, offset);\n    float x = 0.2;\n    return clamp((t-(typeA-x))/((typeB+x)-(typeA-x)),0.,1.);\n}\n\nvec2 runKernel(vec2 fragCoord, vec2 iResolution, sampler2D iChannel0, sampler3D noiseTex, float time)\n{  \n    if (fragCoord.x >= iResolution.x || fragCoord.y >= iResolution.y) return vec2(0.);\n    fragCoord = mod(fragCoord,iResolution.xy);\n    \n    vec2 C = texelFetch(iChannel0, ivec2(fragCoord), 0).xy;  \n    vec2 halfRes = floor(iResolution.xy*0.5);\n    \n    vec3 cPos = smToCart(fragCoord/iResolution.xy);\n    vec2 values[8];\n    vec2 k = vec2(0.);\n    float w = 0.;\n    vec3 debug= vec3(0.);\n    for (int i=0;i<8;i++)\n    {\n        vec2 samp = fragCoord + os[i];\n        samp.x -= halfRes.x;\n        float width = getWidth(samp.y/(iResolution.y));\n        if(samp.x>=0.)samp.x = myMod(samp.x,width*halfRes.x);\n        else samp.x = myMod(samp.x,-width*halfRes.x);\n \n        samp.x += halfRes.x;  \n        \n        vec3 sPos = smToCart(samp/iResolution.xy);\n        float d = 1.;\n        \n    \tk += d*texelFetch(iChannel0, ivec2(samp),0).xy;\n        \n        w +=d;\n    } \n    \n    k/= w;\n    \n    vec2 D = k-C;\n    float s = 1.;\n    vec2 dr = 1.*vec2(1.,0.5);\n    \n    vec2 fk = mix(fks[0], fks[1], getTypeBlendSS(cPos, noiseTex, time)); \n    \n    float feed = fk.x;\n  \tfloat kill = fk.y;\n\n    vec2 nextC;\n\tnextC.x = C.x + (D.x*dr.x-C.x*C.y*C.y + feed*(1.-C.x))*s;\n    nextC.y = C.y + (D.y*dr.y+C.x*C.y*C.y -(kill+feed)*C.y)*s;\n\tC = nextC;\n    \n    return C;\n}\n\n#define RUNKERNEL runKernel(fragCoord.xy, simRes, iChannel0, iChannel1, iTime);      \n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 C = RUNKERNEL\n    fragColor = vec4(C.xy,0.,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 C = RUNKERNEL\n    fragColor = vec4(C.xy,0.,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 C = RUNKERNEL\n    fragColor = vec4(C.xy,0.,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}