{
    "Shader": {
        "info": {
            "date": "1452130756",
            "description": "I loved playing with GrafEq as a kid, so here it is re-implemented in GLSL.\n\nTry changing [code]#define AA 4.[/code] to [code]#define AA 1.[/code] if you have trouble running the shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xs3GWj",
            "likes": 18,
            "name": "GrafEq",
            "published": 3,
            "tags": [
                "2d",
                "graph",
                "implicit",
                "equation",
                "inequality"
            ],
            "usePreview": 0,
            "username": "davidar",
            "viewed": 587
        },
        "renderpass": [
            {
                "code": "// 2016 David A Roberts <https://davidar.io>\n#define AA 4.\n\n#define PI 3.141592653589793\n\n// CRT effects (curvature, vignette, scanlines and CRT grille)\n// from <https://www.shadertoy.com/view/XtlSD7>\nvec2 CRTCurveUV( vec2 uv ) {\n    uv = uv * 2.0 - 1.0;\n    vec2 offset = abs( uv.yx ) / vec2( 6.0, 4.0 );\n    uv = uv + uv * offset * offset;\n    uv = uv * 0.5 + 0.5;\n    return uv;\n}\nvoid DrawVignette( inout vec3 color, vec2 uv ) {    \n    float vignette = uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y );\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\n    color *= vignette;\n}\nvoid DrawScanline( inout vec3 color, vec2 uv ) {\n    float scanline      = clamp( 0.95 + 0.05 * cos( 3.14 * ( uv.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\n    float grille        = 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * uv.x * 640.0 * 1.0 ), 0.0, 1.0 );    \n    color *= scanline * grille * 1.2;\n}\n\nfloat atanp(in vec2 p) { return atan(p.y,p.x); }\nfloat cube_root(float x) { return sign(x) * pow(abs(x), 1./3.); }\nfloat sq(float x) { return x*x; }\n\nvec3 margarita(in vec2 p) {\n    float z = length(p) - 3.5 * atanp(p) + sin(p.x) + cos(p.y);\n    if(mod(z,7.*PI) < PI/2.) return vec3(1,0,0);\n    if(mod(z,1.*PI) < PI/2.) return vec3(0);\n    return vec3(1);\n}\n\nvec3 digital_bacteria(in vec2 p) {\n    p /= 4.;\n    float x = sq(sin(p.x)+p.y) + sq(cos(p.y)+p.x);\n    float y = cos(10.*p.x) + cos(10.*p.y) - sin(p.x*p.y);\n    float z = sq(sin(floor(p.x))+floor(p.y)) + sq(cos(floor(p.y))+floor(p.x));\n    if(17. < x && x < 21. && 17. < z && z < 21. && y < 0.)\n        return vec3(1.,1.,85./256.);\n    if(17. < z && z < 21.) return vec3(85./256.,0.,0.);\n    if(17. < x && x < 21.) return vec3(170./256.,170./256.,0.);\n    return vec3(85./256.,85./256.,0.);\n}\n\nvec3 threesome(in vec2 p) {\n    p /= 3.;\n    float z = 1.;\n    z *= sin(length(p + vec2(5,0))) * cos(8.*atanp(p + vec2(5,0)));\n    z *= sin(length(p - vec2(5,5))) * cos(8.*atanp(p - vec2(5,5)));\n    z *= sin(length(p + vec2(0,5))) * cos(8.*atanp(p + vec2(0,5)));\n    if(-0.1 < z && z < 0. || 0.2 < z) return vec3(0);\n    return vec3(1);\n}\n\nvec3 plaid_meltdown(in vec2 p) {\n    p /= 15.;\n    p += 7.;\n    float a = 2.*sin(p.x*sin(p.y) + p.y*sin(p.x));\n    float b = cube_root(sin(2.5*sqrt(2.) * (p.x - p.y)));\n    float c = cube_root(sin(2.5*sqrt(2.) * (p.x + p.y)));\n    float d = sin(80.*p.x) + sin(80.*p.y);\n    if(0.25 * (a + b + c) > 0.5 * d) return vec3(0);\n    return vec3(1);\n}\n\nvec3 sunlight_revealed(in vec2 p) {\n    p /= 6.;\n    p.x += 2.;\n    float a = length(vec2(3.-p.x,p.y)) + abs(p.y) + abs(1.-p.x);\n    float f = atan(p.y,p.x-1.);\n    float c = atan(p.y,p.x-3.);\n    float R = sq(p.x-1.) + sq(p.y);\n    vec3 col = vec3(0);\n    bool mix = false;\n    if(5. < a && a < 7. && mod(f,PI/7.) < PI/14.) {\n        col += vec3(0.,82./256.,173./256.);\n        if(mix) col /= 2.;\n        mix = true;\n    }\n    if(5. < a && a < 7. && mod(c,PI/9.) < PI/18.) {\n        col += vec3(1,0,0);\n        if(mix) col /= 2.;\n        mix = true;\n    }\n    if(5. < a && a < 7. && mod(f,PI/8.) < PI/16.) {\n        col += vec3(1,1,0);\n        if(mix) col /= 2.;\n        mix = true;\n    }\n    if((45.-3.*p.x)*PI/180. < f && f < (47.-p.x)*PI/180. && p.y > 0.1*p.x\n       && mod(log(R)/log(f),2.) < 1.) {\n        col += vec3(1);\n        if(mix) col /= 2.;\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = mod(iTime,10.);\n    vec3 color = vec3(0);\n    for(float i = 0.; i < AA*AA - 0.5; i += 1.) {\n        vec2 uv = (fragCoord.xy + vec2(floor(i/AA), mod(i,AA))/AA) / iResolution.xy;\n        vec2 crtUV = CRTCurveUV( uv );\n        if ( crtUV.x < 0.0 || crtUV.x > 1.0 || crtUV.y < 0.0 || crtUV.y > 1.0 ) continue;\n        vec2 p = 50.0 * crtUV - 25.0;\n        p *= 0.75 + 0.05*mod(iTime,10.);\n        p += mod(iTime,10.) - 5.;\n        p.x *= iResolution.x / iResolution.y;\n        if(t < 2. || 8. < t) {\n            float fade = smoothstep(0.,2.,t) - smoothstep(8.,10.,t);\n            float scale = iResolution.y/50.*float(AA)*fade + 1.;\n            p = floor(p.xy*scale)/scale;\n        }\n\n        vec3 c;\n        if     (mod(0.1*iTime,5.) < 1.) c = margarita(p);\n        else if(mod(0.1*iTime,5.) < 2.) c = plaid_meltdown(p);\n        else if(mod(0.1*iTime,5.) < 3.) c = sunlight_revealed(p);\n        else if(mod(0.1*iTime,5.) < 4.) c = threesome(p);\n        else if(mod(0.1*iTime,5.) < 5.) c = digital_bacteria(p);\n\n        DrawVignette( c, crtUV );\n        DrawScanline( c, uv );\n        color += c / float(AA*AA);\n    }\n\n    fragColor.xyz = color;\n    fragColor.w = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}