{
    "Shader": {
        "info": {
            "date": "1498389498",
            "description": "Started off as an accumulative path tracing test, ended up as a generative artwork maker ðŸ¤£",
            "flags": 32,
            "hasliked": 0,
            "id": "XdXBDX",
            "likes": 12,
            "name": "Timelapses",
            "published": 3,
            "tags": [
                "raymarching",
                "motionblur",
                "accumulative"
            ],
            "usePreview": 0,
            "username": "kig",
            "viewed": 481
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = (1.0 - exp(-(fragColor / fragColor.a) * 2.0));\n    fragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define THRESHOLD 0.001\n#define MAX_DISTANCE 8.0\n\n#define RAY_STEPS 200\n#define MAX_SAMPLES (max(4.0, 8.0*maxDiffuseSum))\n\nstruct ray\n{\n\tvec3 p; // ray origin\n\tvec3 d; // ray direction\n\n\t// how much light the ray allows to pass at this point\n\tvec3 transmit; // *= material.transmit\n\t\n\t// how much light has passed through the ray\n\tvec3 light;    // += ray.transmit * material.emit\n\n};\n\nstruct mat\n{\n\tvec3 transmit; // how much of the incoming light the material allows to pass\n\tvec3 emit;     // how much light the material emits\n\tfloat diffuse; // how much to scatter the reflections\n};\n\nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nfloat scene(vec3 p)\n{\n    float seed = float(500 + iFrame / 500);\n    vec4 srad = sqrt(vec4(hash2(seed+0.54), hash2(seed+0.58)));\n\tfloat cube = length(max(abs(p+hash3(seed)*4.0) - sqrt(hash3(seed+0.05))*5.0, 0.0)) - 0.05; //vec3(0.95), 0.0)) - 0.05;\n\t//float s1 = length(p+hash3(seed+0.1)*1.0) - srad.x; //vec3(-1.0, -0.5, -1.0)) - 1.3;\n\t//float s2 = length(p+hash3(seed+0.2)*1.0) - srad.y; //vec3(1.15, 1.15, 1.15)) - 0.75;\n\tfloat s1 = length(max(abs(p+hash3(seed+0.1)*5.0) - 4.0*hash3(seed+0.16)*srad.x, 0.0)) - 0.05; //vec3(-2.5, 0.0, 0.2)) - vec3(0.05, 2.95, 2.25), 0.0));\n\tfloat s2 = length(max(abs(p+hash3(seed+0.2)*6.0) - 3.0*hash3(seed+0.27)*srad.y, 0.0)) - 0.05; //vec3(0.0, 0.0, 2.5)) - vec3(2.5, 2.95, 0.05), 0.0));\n\tfloat s3 = length(max(abs(p+hash3(seed+0.3)*7.0) - 2.0*hash3(seed+0.4)*srad.z, 0.0)) - 0.05; //vec3(-2.5, 0.0, 0.2)) - vec3(0.05, 2.95, 2.25), 0.0));\n\tfloat s4 = length(max(abs(p+hash3(seed+0.6)*8.0) - 2.0*hash3(seed+0.7)*srad.w, 0.0)) - 0.05; //vec3(0.0, 0.0, 2.5)) - vec3(2.5, 2.95, 0.05), 0.0));\n\ts4 = min(s4, length(max(abs(p+hash3(seed+0.8)) - hash3(seed+0.9), 0.0))); //vec3(-2.0, 2.0, 0.5)) - vec3(1.75, 0.05, 1.05), 0.0)));\n\treturn min( min( min( min(cube, s1), s2 ), s3 ), s4);\n}\n\nmat material(vec3 p)\n{\n    float seed = float(iFrame / 500);\n    vec4 srad = vec4(hash2(seed+0.52), hash2(seed+0.55));\n\tfloat cube = length(max(abs(p+hash3(seed+0.04)*3.0) - 3.0*hash3(seed+0.08), 0.0)) - 0.05;\n\tfloat s1 = length(p+hash3(seed+0.14)*3.0) - srad.x;\n\tfloat s2 = length(p+hash3(seed+0.24)*3.0) - srad.y;\n\tfloat s5 = length(max(abs(p+hash3(seed+0.34)*3.0) - 3.0*hash3(seed+0.44)*srad.z, 0.0));\n\tmat m;\n\tm.emit = vec3(0.0);\n\tm.transmit = vec3(1.0);\n\tm.diffuse = 0.0;\n    if (cube < s1 && cube < s2 && cube < s5) {\n\t\tm.transmit = hash3(seed+0.952);\n\t\tm.diffuse = fract(srad.x+srad.y+srad.w);\n\t} else\n\t\tif (s1 < s2 && s1 < s5) {\n\t\tm.transmit = hash3(seed+0.62);\n\t\tm.diffuse = srad.w;\n\t} else if (s2 < s5) {\n\t\tm.transmit = hash3(seed+0.72);\n\t\tm.diffuse = srad.x;\n\t} else {\n\t\tm.transmit = hash3(seed+0.82);\n\t\tm.diffuse = srad.y;\n\t\tm.emit = hash3(seed+0.92);\n\t}\n\treturn m;\n}\n\nvec3 normal(ray r, float d)\n{\n\tfloat e = 0.001;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + r.p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + r.p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + r.p) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvec3 shadeBg(vec3 nml, float t)\n{\n    float seed = float(iFrame / 500);\n    vec3 lightPos_ = vec3(\n        -cos(t)*-8.5, \n        sin(t)*3.0 - 4.0, \n        -(sin(t)*4.0)\n    );\n    vec4 srad = vec4(hash2(seed+0.52), hash2(seed+0.55));\n\n    vec3 bgLight = normalize(lightPos_);\n    vec3 lightPos = bgLight * 9999.0;\n    vec3 sun = pow(hash3(seed+0.01), vec3(2.0))*10.0; //vec3(5.0, 3.5, 2.0)*4.0;\n\tvec3 bgCol = pow(hash3(seed+0.98), vec3(2.0)); //vec3(0.2, 0.15, 0.1);\n\tfloat bgDiff = dot(nml, vec3(0.0, 1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tbgCol += 0.1*sun*pow( max(sunPow, 0.0), srad.x*8.0);\n\tbgCol += 2.0*bgCol*pow( max(-sunPow, 0.0), srad.y*8.0);\n\tbgCol += bgDiff*hash3(seed+0.48); //vec3(0.25, 0.5, 0.5);\n\tbgCol += sun*pow( max(sunPow, 0.0), abs(bgLight.y)*1024.0*pow(srad.z, 8.0)*2.0);\n\tbgCol += bgCol*pow( max(sunPow, 0.0), abs(bgLight.y)*1024.0*pow(srad.w, 8.0)*2.0);\n\treturn max(vec3(0.0), bgCol);\n}\n\nfloat shade(inout ray r, vec3 nml, float d)\n{\n\tmat m = material(r.p);\n\tr.light += m.emit * r.transmit;\n\tr.transmit *= m.transmit;\n\treturn m.diffuse;\n}\n\nvec2 xy(float k, float n)\n{\n\treturn vec2(floor(k/n), k-(floor(k/n)*n));\n}\n\nvoid offset(inout vec3 nml, float k, float count, float diffuse) {\n\tvec3  uu  = normalize( cross( nml, vec3(0.01,1.0,1.0) ) );\n\tvec3  vv  = normalize( cross( uu, nml ) );\n\tvec2  aa = hash2( count );\n\tfloat ra = sqrt(aa.y);\n\tfloat rx = ra*cos(6.2831*aa.x); \n\tfloat ry = ra*sin(6.2831*aa.x);\n\tfloat rz = sqrt( sqrt(k)*(1.0-aa.y) );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*nml );\t\n\tnml = normalize(mix(nml, rr, diffuse));\n}\n\n// camera rotation\nmat3 rotationXY( vec2 angle ) {\n\t// pitch\n\tfloat cp = cos( angle.x );\n\tfloat sp = sin( angle.x );\n\t// yaw\n\tfloat cy = cos( angle.y );\n\tfloat sy = sin( angle.y );\n\n\treturn mat3(\n\t\tcy     , 0.0, -sy,\n\t\tsy * sp,  cp,  cy * sp,\n\t\tsy * cp, -sp,  cy * cp\n\t);\n}\n\nray setupRay(vec2 uv, float k, float t) {\n\n\tmat3 rot = rotationXY( vec2( t*0.503, t*0.602 ) );\n\tray r;\n\tr.light = vec3(0.0);\n\tr.transmit = vec3(1.0);\n    float seed = float(iFrame / 500);\n\tr.p = rot * (vec3(uv*-1.0, -7.0) + vec3(3.0, 2.0, 3.0)*(hash3(seed)*2.0-0.5));\n\tr.d = rot * normalize(vec3(uv, 1.0));\n\n\treturn r;\n}\n\nvec3 trace(vec2 fragCoord, vec2 uv, vec2 uvD, inout float rayNumber)\n{\t\n\tfloat minDist = 9999999.0;\n\tfloat count = 0.0;\n\tfloat diffuseSum = 0.0, maxDiffuseSum = 0.0;\n\t\n\tvec3 accum = vec3(0.0);\n    \n    float time = float(iFrame)/60.0;\n    \n    vec2 rc = fragCoord + (5.0+mod(time, 1.73728))*vec2(rayNumber*37.0, rayNumber*63.0);\n    vec4 rand = texelFetch(iChannel0, ivec2(mod(rc, vec2(256.0))), 0);\n\n    float shutterSpeed = 0.1;\n    \n    float t = time + shutterSpeed*rand.x;\n\t\n\tfloat k = 1.0;\n\tray r = setupRay(uv+(uvD*vec2(rand.x, rand.y)), k+rayNumber, t);\n    \n    vec3 sun = vec3(5.0, 3.5, 2.0)*4.0;\n\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tif (k > MAX_SAMPLES) break;\n\t\tfloat dist = scene(r.p);\n\t\tminDist = min(minDist, dist);\n\t\tr.p += dist * r.d;\n\t\tif (dist < THRESHOLD) {\n\t\t\tr.p -= dist * r.d;\n\t\t\tvec3 nml = normal(r, dist);\n\t\t\tfloat diffuse = shade(r, nml, dist);\n\t\t\tdiffuseSum += diffuse;\n\t\t\toffset(r.d, rayNumber+k, rand.x+rayNumber+k+10.0*dot(nml, r.d), diffuse*0.5);\n\t\t\tr.d = reflect(r.d, nml);\n\t\t\tr.p += 4.0*THRESHOLD * r.d;\n\t\t\tcount++;\n            rand = rand.yzwx;\n\t\t\t\n\t\t\tif (dot(r.transmit, sun) < 1.0) {\n\t\t\t\t// if even the brightest light in the scene can't\n\t\t\t\t// make the ray brighter, let's bail.\n\t\t\t\taccum += r.light;\n\t\t\t\tk++;\n\t\t\t    t = time + shutterSpeed*rand.x;\n\t\t\t\tr = setupRay(uv+(uvD*vec2(rand.x, rand.y)), k, t);\n\t\t\t\tmaxDiffuseSum = max(diffuseSum, maxDiffuseSum);\n\t\t\t\tdiffuseSum = 0.0;\n\t\t\t}\t\t\t\n\t\t} else if (dist > MAX_DISTANCE) {\n\t\t\tvec3 bg = shadeBg(-r.d, t);\n\t\t\tif (minDist > THRESHOLD*1.5) {\n\t\t\t\tr.light = bg;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taccum += r.light + r.transmit * bg;\n\t\t\tk++;\n            t = time + shutterSpeed*rand.x;\n\t\t\tr = setupRay(uv+(uvD*vec2(rand.x, rand.y)), k, t);\t\t\t\n\t\t\tmaxDiffuseSum = max(diffuseSum, maxDiffuseSum);\n\t\t\tdiffuseSum = 0.0;\n\t\t}\n\t}\n\trayNumber += k;\n\taccum += r.light;\n\treturn accum / k;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float rayNumber = texelFetch(iChannel1, ivec2(fragCoord), 0).a;\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = (2.0 * uv - 1.0) * aspect;\n\n\tvec2 uvD = ((2.0 * ((fragCoord.xy+vec2(1.0, 1.0)) / iResolution.xy) - 1.0) * aspect) - uv;\n\t\n\tvec3 light = trace(fragCoord, uv, uvD, rayNumber);\n\t\n    if (iMouse.z > 0.0) {\n    \tfragColor = vec4(0);\n\t} else {\n\t\tfragColor = vec4(light, rayNumber+1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 accum = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec4 lastLight = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    accum.rgb += lastLight.rgb;\n    accum.a++;\n    if (iMouse.z > 0.0 || iFrame % 500 == 0) {\n    \tfragColor = vec4(0);\n\t} else {\n\t    fragColor = accum;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}