{
    "Shader": {
        "info": {
            "date": "1706791534",
            "description": "a",
            "flags": 0,
            "hasliked": 0,
            "id": "4csGRf",
            "likes": 1,
            "name": "_Glossy_Balls_Inspired",
            "published": 3,
            "tags": [
                "a"
            ],
            "usePreview": 0,
            "username": "pk1234",
            "viewed": 122
        },
        "renderpass": [
            {
                "code": "\nconst vec3 light_dir = normalize(vec3(0.1,1,0.1));\nconst float balls_scale = 0.1;\n\nconst float EPSDIST = 0.01;\n\nvec3 colors[2] = vec3[2]( \n    vec3(1), \n    vec3(2)\n    );\n\n\nconst float default_mix_ratio = 0.97;\n    \nconst float env_height = 2.;\nconst float env_pow = 2.;\n    \n   \n   \n   \n   \nfloat get_mixture_ratio(){\n    //return iMouse.x / iResolution.x;\n    return default_mix_ratio;\n}  \n    \nfloat smin( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nmat2 rot(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c);\n}\n\n\nfloat simple_distort(vec2 pos){\n\n    pos *= 0.2;\n    \n    pos.x += iTime * 0.1;\n    \n    float x = pos.x;\n    float y = pos.y;\n     \n    float a = sin(x + sin(x));\n    float b = sin(0.5*(x + y) + sin(2.*x + y) - 1.);\n    float c = sin(0.6*(x-y) + sin(x + 2.*y) + 1.);\n    \n    float sum = a+b+c;\n    return sum * 0.;\n}\n\nfloat env_dist(vec3 pos){\n\n    float h = simple_distort(pos.xz);\n    \n    return env_height - pow(abs(pos.y), env_pow);\n    \n    \n    float wave = exp(cos(iTime * 4.+ pos.x / 3.1415 * 2.) - 1.);\n    // wave = sin(pos.x);\n    return env_height - pow(abs(pos.y), env_pow) + wave * 5.50;\n    \n    return env_height + pos.y - h;    \n}\n\nfloat balls_dist(vec3 pos){\n    \n    pos *= balls_scale;\n    pos.y -= iTime * 0.45 * 1.35;\n    \n    // z based offset makes a nice wave\n    pos.y += pos.z * 0.07;\n    \n    //pos.y += length(pos.xz) * 0.04;\n    \n    pos = fract(pos) - 0.5;\n    \n    float dist = length(pos) - 0.11;\n\n    return dist;\n}\n\nfloat smooth_pow(float input_val, float e){\n    float val = input_val;\n    \n    val = pow(abs(val), e);\n    \n    return input_val < 0. ? -val : val;\n}\n\nfloat get_dist(vec3 pos){\n    \n    float env = env_dist(pos);    \n    float balls = balls_dist(pos);\n    float mixture = 0.;\n    \n    /*\n    vec3 ball_pos = pos;\n    ball_pos *= balls_scale;\n    ball_pos = fract(ball_pos) - 0.5;\n    float ball_xz_dist = max(abs(ball_pos.x), abs(ball_pos.z));\n    ball_xz_dist *= 2.;\n    ball_xz_dist = pow(ball_xz_dist, 2.);    \n    mixture_ratio = mix(mixture_ratio, 0.96, ball_xz_dist);\n    */\n    \n    \n    \n    // looks pretty neat, but not super smooth\n    //mixture = mix(env, balls, mixture_ratio);\n    \n    // other method, with a more smooth looking \"shoot\"\n    mixture = mix(env, smooth_pow(balls, 0.75), get_mixture_ratio());    \n    mixture = smin(mixture, balls, 0.1);\n    \n    //this might work too as above, but its UB ?\n    //mixture = mix(env, sqrt(balls), iMouse.x/iResolution.x);\n    //mixture = mix(env, pow((balls), 0.5), iMouse.x/iResolution.x);\n    \n    return mixture;    \n}\n\nint get_mat(vec3 pos){\n    float env = env_dist(pos);   \n    float balls = balls_dist(pos);\n    float mixture = mix(env, smooth_pow(balls, 0.5), get_mixture_ratio());    \n    \n    // robust approach of coloring the \"ball\"\n    return abs(mixture) <  abs(balls) + 0.02 ? 1 : 2;\n    \n    // lot faster, needs to be adjusted if we change parameters\n    return abs(env) <  1.5 ? 2 : 1;\n}\n\nfloat get_smat(vec3 pos){\n    float env = env_dist(pos);   \n    float balls = balls_dist(pos);\n    \n    \n    float mixture = mix(env, smooth_pow(balls, 0.6), get_mixture_ratio());    \n\n    return smoothstep(0.1, -0.05, abs(balls) + 0.1 -abs(mixture));\n}\n\nvec3 get_grad(vec3 pos, float val){\n    float eps = 0.01;\n    \n    vec2 eps_vec = vec2(eps, 0.);\n    \n    return vec3(\n        get_dist(pos + eps_vec.xyy) - get_dist(pos - eps_vec.xyy),\n        get_dist(pos + eps_vec.yxy) - get_dist(pos - eps_vec.xyy),\n        get_dist(pos + eps_vec.yyx) - get_dist(pos - eps_vec.xyy)) / (2.*eps);\n}\n    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    \n    // init pos and dir\n    vec3 ro = vec3(0.,0.,1.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, -1.));\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy) / iResolution.xy;\n    if (iMouse.z > 0.){\n    rd.yz = rot(mouse.y * 3.1415 * 0.5) * rd.yz;   \n    rd.xz = rot(mouse.x * 3.1415) * rd.xz;   \n    }\n    \n    // raymarch, get t\n    float t = 0.;\n    \n    float best_t = 0.;\n    float min_dist = 100.;\n    \n    for (float it = 0.; it<512.; ++it){\n        vec3 pos = ro + rd * t;\n        \n        float dist = get_dist(pos);\n        \n        // keep track of min\n        if (abs(dist) < min_dist){\n            min_dist = abs(dist);\n            best_t = t;\n        }\n        \n        if ((dist) < EPSDIST){\n            break;\n        }       \n        \n        t += dist * 0.55;\n    }\n    \n    //\n    vec3 pos =  ro + rd * t;\n    float dist = get_dist(pos);\n    \n    // \n    vec3 col = vec3(1.);\n    \n    if (t < 100.){\n    \n    \n        vec3 normal = normalize(get_grad(pos, dist));\n        \n        // blend the normal in the grid boundariesfor a smooth look\n        vec3 ball_pos = pos;\n        ball_pos *= balls_scale;\n        ball_pos = fract(ball_pos) - 0.5;\n        float ball_xz_dist = max(abs(ball_pos.x), abs(ball_pos.z));\n        ball_xz_dist *= 2.;\n        ball_xz_dist = smoothstep(0.4, 1.0, ball_xz_dist);\n        ball_xz_dist = pow(ball_xz_dist, 1.);    \n        vec3 mix_normal = pos.y < 0. ? vec3(0,1,0) : vec3(0,-1,0);\n        normal = mix(normal, mix_normal, ball_xz_dist);\n        \n        // lighting\n        float diff = abs(dot(normal, light_dir));\n        diff = pow(diff, 2.);\n        \n        //float spec = clamp(dot(reflect(rd, normal), light_dir), 0.,1.);        \n        vec3 H = normalize(-rd + light_dir);\n        float spec = abs(dot(normal, H));\n        spec = pow(spec, 64.);\n        \n        col = vec3(0.05);\n        col += vec3(diff * 0.3);\n        col += vec3(spec * 0.5);\n        \n        int mat_id = get_mat(pos);\n        //col *= colors[mat_id-1];\n        \n        float smat = get_smat(pos);\n        smat = pow(smat + 1., 1.3);\n        col *= vec3(smat);\n        \n        \n        //if (dist == 0.) col = vec3(1.);\n        \n        float fog_dist = min(exp(-(t - 30.) * 0.05), 1.);\n        \n        col = mix(vec3(1.), col, 1.);\n        \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float rand(vec3 pos){\n    vec3 v = vec3(1234.1234, 2345.2345, 3456.3456);\n    return fract(4567.4567 * sin(dot(pos, v)));\n}\n\n\nfloat val_noise(vec3 pos){\n    vec3 pos_fract = fract(pos);\n    vec3 pos_floor = floor(pos);\n    \n    float e000 = rand(pos_floor + vec3(0.,0.,0.));\n    float e100 = rand(pos_floor + vec3(1.,0.,0.));    \n    float e010 = rand(pos_floor + vec3(0.,1.,0.));\n    float e110 = rand(pos_floor + vec3(1.,1.,0.)); \n    \n    float e001 = rand(pos_floor + vec3(0.,0.,1.));\n    float e101 = rand(pos_floor + vec3(1.,0.,1.));    \n    float e011 = rand(pos_floor + vec3(0.,1.,1.));\n    float e111 = rand(pos_floor + vec3(1.,1.,1.));\n    \n    // interpolate across x axis\n    float eX00 = mix(e000, e100, pos_fract.x);\n    float eX10 = mix(e010, e110, pos_fract.x);\n    float eX01 = mix(e001, e101, pos_fract.x);\n    float eX11 = mix(e011, e111, pos_fract.x);\n    \n    float eXY0 = mix(eX00, eX10, pos_fract.y);\n    float eXY1 = mix(eX01, eX11, pos_fract.y);\n    \n    float eXYZ = mix(eXY0, eXY1, pos_fract.z);\n    \n    return eXYZ;\n}\n\nfloat val_noise_super(vec3 pos){\n    pos *= 10.;\n    float a = val_noise(pos);\n    float b = val_noise(pos + 13.5);\n    return (a+b)*0.5;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}