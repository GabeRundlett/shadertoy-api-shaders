{
    "Shader": {
        "info": {
            "date": "1696704281",
            "description": "Experiment",
            "flags": 0,
            "hasliked": 0,
            "id": "dsycDc",
            "likes": 10,
            "name": "Drunk effect test",
            "published": 3,
            "tags": [
                "3d",
                "ray",
                "effect",
                "fx",
                "march"
            ],
            "usePreview": 1,
            "username": "ianertson",
            "viewed": 239
        },
        "renderpass": [
            {
                "code": "#define R (iResolution.xy)\n#define T (iTime)\n#define ZERO min(iFrame, 0)\n#define M_PI 3.1415\n#define TAU (M_PI*2.0)\n#define adot(v1, v2) abs(dot(v1, v2))\n\n#define STEPS 100\n#define SHADOW_STEPS 24\n#define NEAR 0.003\n#define FAR 128.0\n#define AMBIENT 0.3\n#define FX 1\n#define FX_AMOUNT cos(T*0.5)*0.1\n\n\nvec3 noise(in vec2 p, in float s) {\n    p += s * 256.0;\n    return textureLod(iChannel3, p / 256.0, 0.0).rgb;\n}\n\nvec3 noise(in vec2 p, in float s, in float freq, const in int oct) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < oct; i++) {\n        n += amp * noise(p*freq, s);\n        div += amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\nvec3 snoise(in vec2 p, in float s) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    return mix(\n        mix(noise(id, s), noise(id+vec2(1, 0), s), lv.x),\n        mix(noise(id+vec2(0, 1), s), noise(id+vec2(1, 1), s), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise(in vec2 p, in float s, in float freq, const in int oct) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < oct; i++) {\n        n += amp * snoise(p*freq, s);\n        div += amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\n\nstruct Translation {\n    vec3 p;\n    vec3 r;\n};\n\n#define NEW_TRANSLATION Translation(vec3(0.0), vec3(0.0))\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nvec3 pointRot(in vec3 p, in vec3 r) {\n    p.yz *= rot(r.x);\n    p.xz *= rot(r.y);\n    p.xy *= rot(r.z);\n    return p;\n}\n\nvec3 pointRotInv(in vec3 p, in vec3 r) {\n    p.yz *= inverse(rot(r.x));\n    p.xz *= inverse(rot(r.y));\n    p.xy *= inverse(rot(r.z));\n    return p;\n}\n\nstruct Light {\n    vec3 p;\n    vec3 d;\n    vec3 c;\n    int t;\n    float s;\n};\n\n#define LIGHT_POINT 0\n#define LIGHT_DIR 1\n#define LIGHT_AMB 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.t == LIGHT_POINT ? normalize(light.p - p) : \n        light.t == LIGHT_DIR ? normalize(light.d) : normalize(light.p);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 N) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(0.0, dot(N, L));\n    \n    switch (light.t) {\n        case LIGHT_POINT: {\n            return light.c * NdotL * (pow(light.s, 2.0) / max(0.001, pow(distance(light.p, p), 2.0)));\n        }; break;\n        case LIGHT_DIR: {\n            light.s * light.c * NdotL * smoothstep(0.8, 1.0, dot(\n                normalize(light.p - p),\n                L\n            ));\n        }; break;\n        case LIGHT_AMB: {\n            return NdotL * light.c * light.s;\n        }; break;\n    }\n    \n    return vec3(0.0);\n}\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    float d;\n    int id;\n    Translation t;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, -1, NEW_TRANSLATION)\n\n#define SAMPLE(D, TRANS, T, dist, t, trans) if (D < dist) { dist = D; t = T; trans = TRANS; }\n\n#define ID_GROUND 0\n#define ID_BOX 1\n#define ID_STONE 2\n\nfloat groundSDF(in vec3 p) {\n    return p.y;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat stoneSDF(in vec3 p, in float s) {\n    vec3 n = snoise(p.xz*2.2+p.y, s, 1.1, 4);\n    \n    float d = distance(p, vec3(0.0)) - n.x;\n    \n    return d;\n\n}\n\nfloat sdf(in vec3 p, inout Data data) {\n    float dist = FAR;\n    int t = -1;\n    Translation tr = NEW_TRANSLATION;\n   \n    float ground = groundSDF(p);\n    SAMPLE(ground, tr, ID_GROUND, dist, t, tr);\n    \n    if (p.y < 0.5 && p.x > 1.0) {\n        float stone = stoneSDF(p - vec3(2.3, 0.1, 0), 0.03921);\n        SAMPLE(stone, tr, ID_STONE, dist, t, tr);\n    }\n\n    Translation boxTrans = Translation(vec3(0, -0.69 - 0.333*(0.5+0.5*cos(T)), 0), vec3(sin(T)*0.25, T, 0));\n    float box = boxSDF(pointRot(p + boxTrans.p, boxTrans.r), vec3(0.5))-0.06;\n    vec3 boxP = pointRot(p + boxTrans.p, boxTrans.r);\n    float boxInside = boxSDF(boxP, vec3(1.0, 0.3, 0.3))-0.05;\n    float boxInside2 = boxSDF(boxP, vec3(0.3, 0.3, 1.0))-0.05;\n    boxInside = min(boxInside, boxInside2);\n    box = max(box, -boxInside);\n    SAMPLE(box, boxTrans, ID_BOX, dist, t, tr);\n    \n    \n\n    data.id = t;\n    data.t = tr;\n    return dist;\n}\n\nbool march(in vec3 ro, in vec3 rd, inout Data data) {\n    float d = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(p, data);\n        \n        if (abs(next) <= NEAR) break;\n        if (abs(next) >= FAR) return false;\n        \n        d += next;\n    }\n    \n    d = abs(d);\n    vec3 p = ro+rd*d;\n    data.p = p;\n    data.d = d;\n    vec2 e = vec2(0.001, 0.0);\n    Data tmp = NEW_DATA;\n    data.n = normalize(sdf(p, tmp) - vec3(\n        sdf(p - e.xyy, tmp),\n        sdf(p - e.yxy, tmp),\n        sdf(p - e.yyx, tmp)\n    ));\n    \n    return true;\n\n}\n\n// Modified version of iq's https://www.shadertoy.com/view/lsKcDD\nfloat getShadow(in vec3 ro, in vec3 rd, in vec3 n, in float near, in float far, in int skip) {\n    Data data = NEW_DATA;\n    float NdotL = dot(n, rd);\n    float nl = max(0.0, NdotL);\n    float res = 1.0;\n    float ep = 1e20;\n    float t = NEAR+0.03;\n    float ss = (far/FAR)+0.2;\n    float tot = 0.0;\n    int lastId = -1;\n    float jumps = 0.0;\n    for(int i = ZERO; i < SHADOW_STEPS && t < far; i++){\n        vec3 p = ro + rd*t;\n        float j = float(i);\n        \n        // Move point away from surface\n        float jump = 0.5*clamp(pow(max(0.0, dot(normalize(rd+p), n)), 2.)*clamp(t/far, 0.5, 1.0), 0.0, 0.56)*\n             (1.0 + 0.5*float(lastId == skip)) * (1.0 + 1.5*max(0.0, dot(n, vec3(0, 1, 0))));\n        p += n*jump;\n        jumps += jump;\n        \n        \n        float h = sdf(p, data);\n        lastId = data.id;\n        tot += h;\n        float y = h*h / (2.9 * ep);\n        float d = sqrt(h*h-y*y);\n        res = min(res, d/(ss*max(0.0, t-y)));\n        ep = h;\n        t += h;\n        \n        if (t <= -0.5 || h <= -0.5 || d <= -0.5) break;\n    }\n    jumps /= float(SHADOW_STEPS);\n    float ra = far*0.5; // radius\n    float fe = ra*0.9; // feather\n    res = max(res, 0.0002);\n    res = max(mix(res*res,\n        (1.0-smoothstep(ra-fe, ra+fe, far-tot)),\n        0.8*smoothstep(0.0, 0.63, res+smoothstep(0.0, 0.9, tot / (1.0+tot*6.)))\n    ), 0.);\n    \n    res += (((0.5*res)*res*res) + (max(0.0, (t/far)*0.25*res*res)))*(1.0+(res*0.1));\n    res += max(0.0, 1.0-(res*res))*(res / (1.0 + res));\n    res /= (1.0 + ((jumps*(0.2+(res*res*2.5))) / (1.0+(nl*nl*2.*(1.0+nl)))));\n    res = mix(res, res / (1.0+res), 0.5*jumps*jumps);\n    res += 0.25*(0.5*(0.45+(res*res)));\n    res /= (1.0+((res+0.05)*max(0.0, 0.5-(nl*nl*2.))));\n    return clamp(res, AMBIENT, 1.);\n}\n\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.yz, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0))));\n}\n\nfloat checkerTexture(in vec2 uv, in float s) {\n    vec2 d = max(abs(dFdx(uv)), abs(dFdy(uv))) + s;\n    vec2 t1 = vec2(1.-2.0*abs(fract((uv.x+.5*d.x)*0.5)-0.5), 1.-2.0*abs(fract((uv.y+.5*d.y)*.5)-0.5));\n    vec2 t2 = vec2(1.-2.0*abs(fract((uv.x-.5*d.x)*0.5)-0.5), 1.-2.0*abs(fract((uv.y-.5*d.y)*.5)-0.5));\n    return 0.5 - 0.5*((t1.x-t2.x)/d.x)*(t1.y-t2.y)/d.y;\n}\n\nvec3 grassTexture(in vec2 uv) {\n    vec3 col = vec3(0.2, 0.8, 0.1);\n    vec3 hf = noise(uv, 0.03214, 32.0, 2);\n    vec3 lf = noise(uv, 0.19882, 1.0, 3);\n    vec3 lf2 = noise(uv+0.04, 0.0012455, 1.5, 3);\n    \n    col *= hf.x;\n    col = mix(col, vec3(0.5, 0.2, 0.3), hf.y*lf.z*0.8);\n    col = mix(col, vec3(0.8, 0.5, 0.2), smoothstep(lf.x, 0.02, 0.3+0.1*hf.z));\n    col = mix(col, col*col, smoothstep(0.25, 0.5, lf2.z*hf.y));\n    \n    return col;\n}\n\nvec3 stoneTexture(in vec2 uv) {\n    vec3 col = vec3(0.89, 0.81, 0.91);\n    vec3 hf = noise(uv, 1.49818, 32.0, 2);\n    \n    col *= hf.x;\n    return col;\n}\n\nvec3 getAlbedo(in vec3 p, inout Data data) {\n    vec3 n = data.n;\n    \n    switch (data.id) {\n        case ID_BOX: {\n            \n            \n            p = pointRot(p + data.t.p, data.t.r);\n            n = pointRot(n, data.t.r);\n            vec2 uv = boxUv(p, n);\n            return checkerTexture(uv*9., 0.05) * vec3(1.0);\n        }; break;\n        case ID_GROUND: {\n            vec2 uv = p.xz;\n            return grassTexture(uv);\n        }; break;\n        case ID_STONE: {\n            vec2 uv = boxUv(p, n);\n            return stoneTexture(uv);\n        }; break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.0);\n    \n    Light light = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.96, 0.87, 0.59), LIGHT_AMB, 1.6);\n    \n    Data data = NEW_DATA;\n    float up = max(0.0, dot(rd, vec3(0, 1, 0)));\n    if (march(ro, rd, data)) {\n        vec3 albedo = getAlbedo(data.p, data);\n        vec3 diffuse = albedo / M_PI;\n        vec3 L = getLightDir(light, data.p);\n        vec3 att = getLightAtt(light, data.p, data.n);\n        float shadow = getShadow((data.p+L*0.0001)+data.n*0.0001, L, data.n, data.d, FAR, -1);\n        col += albedo * att * shadow;\n    } else {\n        vec3 sky = vec3(0.02, 0.6, 0.89);\n        sky = pow(sky, 3.0*up*vec3(up));\n        col += sky;\n    }\n    \n    float depth = data.d / FAR;\n    col += light.c*depth*smoothstep(0.15, 0.0, up)*(0.5+0.5*depth);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec2 uv = (fc - R.xy * 0.5) / R.y;\n    vec3 col = vec3(0.0);\n    \n    vec3 ro = vec3(0.0, 1., -4.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec4 m = vec4((iMouse.xy - R.xy * 0.5)/R.y, iMouse.zw);\n    \n    if (m.z > 0.01) {\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    }\n    \n      \n    #if FX > 0\n    vec3 rd2 = rd;\n    rd2.yx *= rot(FX_AMOUNT);\n    col += (render(ro, rd) + render(ro, rd2))*0.5;\n    #else\n    col += render(ro, rd);\n    #endif\n    \n    col += col*col*0.5;\n    \n    col = pow(col, vec3(1.0 / 2.2));\n    \n    O = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}