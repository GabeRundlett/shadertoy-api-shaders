{
    "Shader": {
        "info": {
            "date": "1581723936",
            "description": "This is a modification of https://www.shadertoy.com/view/3ldGRX\n\nThe camera \"bounces\" on this fractal using coliision detection.",
            "flags": 32,
            "hasliked": 0,
            "id": "3ttXDj",
            "likes": 25,
            "name": "Collision detection + gravity",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 1,
            "username": "jarble",
            "viewed": 1008
        },
        "renderpass": [
            {
                "code": "// Fork of \"Fractal terrain generator\" by michael0884. https://shadertoy.com/view/3lcGRX\n// 2019-12-22 20:51:23\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized centered pixel coordinates \n    vec2 pos = (fragCoord - iResolution.xy*0.5)/max(iResolution.x,iResolution.y);\n    \n    LOD = 0.8/max(iResolution.x,iResolution.y);\n    \n    vec2 angles = texelFetch(iChannel3,  ivec2(ANGLE_INDX,0), 0).xy;\n \tvec3 ray = getRay(angles, pos);\n    \n    vec4 cpos = texelFetch(iChannel3,  ivec2(POS_INDX,0), 0);\n    vec4 dir = vec4(ray,0.);\n    \n    vec3 col = render_ray(cpos, dir, LOD);\n    \n    // Output to screen\n    fragColor = vec4(HDRmapping(col, 0.5),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/// UTILITY\n///\n/// Using the GPU as the CPU here, pretty inefficient I guess\n\n//Keyboard constants\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 1)\n    {\n        fragColor = vec4(0.);\n    }\n    \n    if(fragCoord.x <= N_instructions && fragCoord.y <= 1.)\n    {\n        //instruction\n        int I = int(fragCoord.x); \n        fragColor = texelFetch(iChannel0,  ivec2(I,0), 0);\n        vec4 mouse = texelFetch(iChannel0,  ivec2(MOUSE_INDX,0), 0);\n        vec2 mousespeed = texelFetch(iChannel0,  ivec2(MOUSE_INDX,0), 0).xy;\n        vec4 angles = texelFetch(iChannel0,  ivec2(ANGLE_INDX,0), 0);\n        mat3 camera = transpose(getCamera(angles.xy));\n        vec4 posit = texelFetch(iChannel0,  ivec2(POS_INDX,0), 0);\n        vec4 vel = texelFetch(iChannel0,  ivec2(VEL_INDX,0), 0);\n\t\tvec4 speed = texelFetch(iChannel0,  ivec2(SPEED_INDX,0), 0);\n        vec4 norm = calcNormal(posit.xyz, MIN_DIST);\n        norm.xyz = norm.xyz/(length(norm.xyz) + 0.0001);\n        switch(I)\n        {\n        case MOUSE_INDX:  //mouse speed calculation \n            if(length(iMouse.zw - iMouse.xy) > 10.)\n  \t\t    {\n   \t\t\t\tfragColor.xy = iMouse.xy - fragColor.zw; // mouse delta\n                if(iFrame < 1)\n                {\n                    fragColor.xy = vec2(0.);\n                }\n            }\n            else\n            {\n\t\t\t\tfragColor.xy = vec2(0.); // mouse delta\n            }\n    \t\tfragColor.zw = iMouse.xy; // mouse pos\n            break;\n            \n        case ANGLE_INDX:  //angle computation\n           \n   \t\t\tfragColor.xy = fragColor.xy + fragColor.zw*MOUSE_SENSITIVITY; // angle delta\n            fragColor.y = clamp(fragColor.y, -PI*0.5, PI*0.5);\n    \t\tfragColor.zw += vec2(1,-1)*mouse.xy; // mouse pos\n            fragColor.zw *= 0.8;\n            fragColor.y *= 1.- 0.01*clamp(length(vel.xyz),0.,1.);\n             if(iFrame < 1)\n            {\n                fragColor.xy = vec2(0.,0.);\n            }\n            break;\n            \n        case POS_INDX:  //position\n          \n            float DX = length(vel.xyz*speed.x)+0.0001;\n            float MAXDX = DE(fragColor.xyz + vel.xyz*speed.x) + norm.w;\n            if(DX > MAXDX)\n                vel *= 0.25;\n            fragColor.xyz += vel.xyz*speed.x;\n   \t\t\tfragColor.w = vel.w;\n            if(iFrame < 1)\n            {\n                fragColor.xyz = vec3(0.,11.,1.);\n            }\n           \n            break;\n         case VEL_INDX:  //velocity\n          \n            fragColor.w++;\n            if(length(mousespeed) >0. || isKeyPressed(KEY_Z))\n            {\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_UP) || isKeyPressed(KEY_W))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz += camera[1]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_DOWN) || isKeyPressed(KEY_S))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz -= camera[1]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_RIGHT) || isKeyPressed(KEY_D))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz += camera[0]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_LEFT) || isKeyPressed(KEY_A))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz -= camera[0]*speed.x;\n                fragColor.w = 0.;\n            }\n            \n            if(length(norm) > 1.1){\n                fragColor.y -= 0.1; //gravity\n            }\n            else{\n            \tfragColor += norm/20.0; //bounce off the ground\n            }\n            \n            //fractal collision detection, removing the normal velocity component \n          \tfragColor.xyz += norm.xyz*max(dot(fragColor.xyz, -norm.xyz),0.)*exp(-max(norm.w,0.)/0.04);\n            \n\n\n            \n            break;\n          case LIGHT_INDX:  //light\n            if(isKeyPressed(KEY_L))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz = posit.xyz;\n                fragColor.w = .08;\n            }\n            if(iFrame < 1)\n            {\n                fragColor = vec4(12.5,-4,10.5, 0.1);\n            }\n            break; \n          case SPEED_INDX: //camera max speed\n            if(isKeyPressed(KEY_Q))\n   \t   \t\t{\n   \t\t\t\tfragColor.x *= 1.01;\n            }\n            if(isKeyPressed(KEY_E))\n   \t   \t\t{\n   \t\t\t\tfragColor.x *= 0.99;\n            }\n            if(iFrame < 1)\n            {\n                fragColor.x = CAMERA_SPEED;\n            }\n            break; \n        }   \n    } else discard;\n    \n   \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define PI 3.14159265\n#define SQRT2 1.4142135\n#define SQRT3 1.7320508\n#define SQRT5 2.2360679\n#define FOV 2.5\n\n#define MAX_DIST 500.\n#define MIN_DIST 1e-5\n#define MAX_MARCHES 512.\n#define LIGHT_ANGLE 0.04\n\n//how much does the terrain change in large scale\n#define PERLIN_SCALE 2\n\n#define CAMERA_SPEED 5./60.\n#define MOUSE_SENSITIVITY 0.15/60.\n\n#define N_instructions 6.\n\n#define MOUSE_INDX 0\n#define ANGLE_INDX 1\n#define POS_INDX   2\n#define VEL_INDX   3\n#define LIGHT_INDX 4\n#define SPEED_INDX 5\n\n//coefficients are fine-tuned\n//you can get all kinds of weird terrain by carefully setting the coefficients, \n//even forests are possible, but they may look not as realistic as the rock fractals\nconst int FRACTAL_ITER = 22;\nconst float iFracScale = 1.6467;\nconst float iFracAng1 = 2.7315;\nconst float iFracAng2 = -0.2082;\nconst vec3 iFracShift = vec3(-8.92, 3.66, 5.49);\nconst vec3 iFracCol = vec3(0.3, 0.3, -0.2);\nfloat s1 = sin(iFracAng1), c1 = cos(iFracAng1), s2 = sin(iFracAng2), c2 = cos(iFracAng2);\n\nfloat PBR_METALLIC = 0.0;\nfloat PBR_ROUGHNESS = 0.8;\n\nvec3 BACKGROUND_COLOR = vec3(0.);\nvec3 LIGHT_DIRECTION = normalize(vec3(-1.,1.,0.68));\nvec3 LIGHT_COLOR = vec3(1., 0.95, 0.8);\nbool SHADOWS_ENABLED = true; \n\nfloat gamma_material = 0.1;\nfloat gamma_sky = 0.6;\nfloat gamma_camera = 2.2;\n\nfloat LOD;\n\nfloat hash(float p)\n{\n   p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n\n//normally distributed random numbers\nvec3 randn(float p)\n{\n    vec4 rand = hash41(p);\n    vec3 box_muller = sqrt(-2.*log(max(vec3(rand.x,rand.x,rand.z),1e-8)))*vec3(sin(2.*PI*rand.y),cos(2.*PI*rand.y),sin(2.*PI*rand.w));\n    return box_muller;\n}\n\n//uniformly inside a sphere\nvec3 random_sphere(float p)\n{\n    return normalize(randn(p))*pow(hash(p+85.67),0.333333);\n}\n\nvec3 cosdistr(vec3 dir, float seed)\n{\n    vec3 rand_dir = normalize(randn(seed*SQRT2));\n    vec3 norm_dir = normalize(rand_dir - dot(dir,rand_dir)*dir);\n    float u = hash(seed);\n    return normalize(dir*sqrt(u) + norm_dir*sqrt(1.-u));\n}\n\n\nvec4 perlin_octave(vec2 p)\n{\n   vec2 pi = floor(p);\n   vec2 pf = p - pi;\n   vec2 pfc = 0.5 - 0.5*cos(pf*PI);\n   vec2 a = vec2(0.,1.);\n   \n   vec4 a00 = hash42(pi+a.xx);\n   vec4 a01 = hash42(pi+a.xy);\n   vec4 a10 = hash42(pi+a.yx);\n   vec4 a11 = hash42(pi+a.yy);\n   \n   vec4 i1 = mix(a00, a01, pfc.y);\n   vec4 i2 = mix(a10, a11, pfc.y);\n   \n   return mix(i1, i2, pfc.x);  \n}\n\nmat2 rotat = mat2(cos(0.5), -sin(0.5), sin(0.5), cos(0.5));\n\nvec4 perlin4(vec2 p)\n{\n\tfloat a = 1.;\n\tvec4 res = vec4(0.);\n\tfor(int i = 0; i < PERLIN_SCALE; i++)\n\t{\n       \n\t\tres += a*(perlin_octave(p)-0.5);\n        //inverse perlin\n         p *= 0.2*rotat;\n\t\ta *= 15.;\n\t\t\n\t}\n\treturn res;\n}\n\n/////\n/////Code from Marble Marcher Community Edition\n/////\n\n#define COL col_scene\n#define DE de_scene\n#define DEv de_scene_var\n//##########################################\n//   Space folding\n//##########################################\nvoid planeFold(inout vec4 z, vec3 n, float d) {\n\tz.xyz -= 2.0 * min(0.0, dot(z.xyz, n) - d) * n;\n}\nvoid sierpinskiFold(inout vec4 z) {\n\tz.xy -= min(z.x + z.y, 0.0);\n\tz.xz -= min(z.x + z.z, 0.0);\n\tz.yz -= min(z.y + z.z, 0.0);\n}\n\n// Polynomial smooth minimum by iq\nfloat smoothmin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) - k*h*(1.0-h);\n}\n\n/*void mengerFold(inout vec4 z) {\n\tfloat a = smoothmin(z.x - z.y, 0.0, 0.03);\n\tz.x -= a;\n\tz.y += a;\n\ta = smoothmin(z.x - z.z, 0.0, 0.03);\n\tz.x -= a;\n\tz.z += a;\n\ta = smoothmin(z.y - z.z, 0.0, 0.03);\n\tz.y -= a;\n\tz.z += a;\n}*/\n\nvoid mengerFold(inout vec4 z) {\n\tfloat a = min(z.x - z.y, 0.0);\n\tz.x -= a;\n\tz.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a;\n\tz.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a;\n\tz.z += a;\n}\nvoid boxFold(inout vec4 z, vec3 r) {\n\tz.xyz = clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\nvoid rotX(inout vec4 z, float s, float c) {\n\tz.yz = vec2(c*z.y + s*z.z, c*z.z - s*z.y);\n}\nvoid rotY(inout vec4 z, float s, float c) {\n\tz.xz = vec2(c*z.x - s*z.z, c*z.z + s*z.x);\n}\nvoid rotZ(inout vec4 z, float s, float c) {\n\tz.xy = vec2(c*z.x + s*z.y, c*z.y - s*z.x);\n}\nvoid rotX(inout vec4 z, float a) {\n\trotX(z, sin(a), cos(a));\n}\nvoid rotY(inout vec4 z, float a) {\n\trotY(z, sin(a), cos(a));\n}\nvoid rotZ(inout vec4 z, float a) {\n\trotZ(z, sin(a), cos(a));\n}\n\n//##########################################\n//   Primitive DEs\n//##########################################\nfloat de_sphere(vec4 p, float r) {\n\treturn (length(p.xyz) - r) / p.w;\n}\nfloat de_box(vec4 p, vec3 s) {\n\t\n\tvec3 a = abs(p.xyz) - s;\n\treturn (min(max(max(a.x, a.y), a.z), 0.0) + length(max(a, 0.0))) / p.w;\n}\nfloat de_tetrahedron(vec4 p, float r) {\n\tfloat md = max(max(-p.x - p.y - p.z, p.x + p.y - p.z),\n\t\t\t\tmax(-p.x + p.y + p.z, p.x - p.y + p.z));\n\treturn (md - r) / (p.w * sqrt(3.0));\n}\nfloat de_capsule(vec4 p, float h, float r) {\n\tp.y -= clamp(p.y, -h, h);\n\treturn (length(p.xyz) - r) / p.w;\n}\n\n//##########################################\n//   Main DEs\n//##########################################\nfloat de_fractal(vec4 p, float error)\n{\n\tvec3 p0 = p.xyz*2.;\n   \n\tp.xz = mod(p.xz + vec2(2.*p.w), vec2(4.*p.w)) - vec2(2.*p.w); \n\tvec4 perlin1 = 0.08*perlin4(p0.xz);\n\tvec3 shift =iFracShift + perlin1.xyz;\n    \n    //estimating the number of iterations needed to have this error\n    float iter = log(length(shift)/error)/log(iFracScale)-2.;\n    float max_iter = min(float(FRACTAL_ITER)+1e-4, iter);\n    \n    vec4 prev_p;\n\tfor (float i = 0.; i < max_iter; ++i) {\n\t\tprev_p = p;\n\t\tp.xyz = abs(p.xyz);\n\t\trotZ(p, s1, c1);\n\t\tmengerFold(p);\n        if(i == 1.) shift -= perlin1.xyz;\n\t\trotX(p, s2, c2);\n\t\tp *= iFracScale*(1.);\n\t\tp.xyz += shift;\n\t}\n    \n    //interpolate between LOD's\n\tfloat de = mix(de_box(prev_p, vec3(6.0)), de_box(p, vec3(6.0)), fract(max_iter));\n    \n\treturn 0.75*de;\n}\n\nvec4 col_fractal(vec4 p) \n{\n\tvec3 p0 = p.xyz;\n\tvec3 orbit = vec3(0.0);\n\tp.xz = mod(p.xz + vec2(0.5*p.w), vec2(1.*p.w)) - vec2(0.5*p.w); \n\tvec4 perlin1 = perlin4(p0.xz);\n\tvec3 shift =iFracShift + 0.35*(perlin1.xyz - 0.5);\n\tfor (int i = 0; i < FRACTAL_ITER; ++i) {\n\t\tp.xyz = abs(p.xyz);\n\t\trotZ(p, s1, c1);\n\t\tmengerFold(p);\n\t\trotX(p, s2, c2);\n\t\tp *= iFracScale*(1.);\n\t\tp.xyz += shift;\n\t\torbit = max(orbit, p.xyz*iFracCol);\n\t}\n\treturn vec4(orbit, de_box(p, vec3(6.0)));\n}\n\nfloat de_scene(vec3 pos) \n{\n\tvec4 p = vec4(pos,1.f);\n\tfloat d = de_fractal(p, MIN_DIST);\n\treturn d;\n}\n\nfloat de_scene_var(vec3 pos, float error)\n{\n    vec4 p = vec4(pos,1.f);\n\tfloat d = de_fractal(p, error);\n\treturn d;\n}\n\nvec4 col_scene(vec3 pos) \n{\n\tvec4 p = vec4(pos,1.f);\n\tvec4 col = col_fractal(p);\n\treturn vec4(min(col.xyz,1.), 0.0);\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*DEv(p + k.xyy*dx, 2.*dx) +\n\t\t\t k.yyxx*DEv(p + k.yyx*dx, 2.*dx) +\n\t\t\t k.yxyx*DEv(p + k.yxy*dx, 2.*dx) +\n\t\t\t k.xxxx*DEv(p + k.xxx*dx, 2.*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\nvoid scene_material(vec3 pos, inout vec4 color, inout vec2 pbr)\n{\n\t//DE_count = DE_count+1;\n\tvec4 p = vec4(pos,1.f);\n\t\n\tcolor = col_fractal(p);\n\t\n\tpbr = vec2(PBR_METALLIC, PBR_ROUGHNESS);\n\tfloat reflection = 0.;\n\n\tcolor = vec4(min(color.xyz,1.), reflection);\n}\n\n\n#define overrelax 1.35\n\nvoid ray_march(inout vec4 p, inout vec4 ray, inout vec4 var, float angle, float max_d)\n{\n    float prev_h = 0., td = 0.;\n    float omega = overrelax;\n    float candidate_td = 1.;\n    float candidate_error = 1e8;\n    for(; ((ray.w+td) < max_d) && (var.x < MAX_MARCHES);   var.x+= 1.)\n    {\n        p.w = DEv(p.xyz + td*ray.xyz, LOD*td);\n        \n        if(prev_h*omega>max(p.w,0.)+max(prev_h,0.)) //if overtepped\n        {\n            td += (1.-omega)*prev_h; // step back to the safe distance\n            prev_h = 0.;\n            omega = (omega - 1.)*0.6 + 1.; //make the overstepping smaller\n        }\n        else\n        {\n\t\t\tif(p.w < 0.)\n\t\t\t{\n\t\t\t\tcandidate_error = 0.;\n\t\t\t\tcandidate_td = td;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n            if(p.w/td < candidate_error)\n            {\n                candidate_error = p.w/td;\n                candidate_td = td; \n\t\t\t\t\n                if(p.w < (ray.w+td)*angle) //if closer to the surface than the cone radius\n                {\n                    break;\n                }\n            }\n            \n            td += p.w*omega; //continue marching\n            \n            prev_h = p.w;        \n        }\n    }\n    \n    ray.w += candidate_td;\n\tp.xyz = p.xyz + candidate_td*ray.xyz;\n\tp.w = candidate_error*candidate_td;\n}\n\n\nvoid ray_march(inout vec4 p, inout vec4 ray, inout vec4 var, float angle)\n{\n\tray_march(p, ray, var, angle, MAX_DIST);\n}\n\n\n\n#define shadow_steps 256\nfloat shadow_march(vec4 pos, vec4 dir, float distance2light, float light_angle, float dist2cam)\n{\n\tfloat light_visibility = 1.;\n\tfloat ph = 1e5;\n\tfloat dDEdt = 0.;\n\tpos.w = DE(pos.xyz);\n\tint i = 0;\n\tfor (; i < shadow_steps; i++) {\n\t\n\t\tdir.w += pos.w;\n\t\tpos.xyz += pos.w*dir.xyz;\n\t\tpos.w = DEv(pos.xyz, (dist2cam+dir.w)*LOD);\n\t\t\n\t\tfloat y = pos.w*pos.w/(2.0*ph);\n        float d = (pos.w+ph)*0.5*(1.-dDEdt);\n\t\tfloat angle = d/(max(MIN_DIST,dir.w-y)*light_angle);\n\t\t\n        light_visibility = min(light_visibility, angle);\n\t\t\n\t\t//minimizing banding even further\n\t\tdDEdt = dDEdt*0.75 + 0.25*(pos.w-ph)/ph;\n\t\t\n\t\tph = pos.w;\n\t\t\n\t\tif(dir.w >= distance2light)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(dir.w > MAX_DIST || pos.w < max(LOD*dir.w, MIN_DIST))\n\t\t{\n\t\t\treturn 0.;\n\t\t}\n\t}\n\t\n\tif(i >= shadow_steps)\n\t{\n\t\tlight_visibility=0.;\n\t}\n\t//return light_visibility; //bad\n\tlight_visibility = clamp(2.*light_visibility - 1.,-1.,1.);\n\treturn  0.5 + (light_visibility*sqrt(1.-light_visibility*light_visibility) + asin(light_visibility))/3.14159265; //looks better and is more physically accurate(for a circular light source)\n}\n\n\n#define AMBIENT_MARCHES 3\n#define AMBIENT_COLOR 2*vec4(1,1,1,1)\n\n\n///PBR functions \nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}  \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n///END PBR functions\n\nconst float Br = 0.0025;\nconst float Bm = 0.0003;\nconst float g =  0.9800;\nconst vec3 nitrogen = vec3(0.650, 0.570, 0.475);\nconst vec3 Kr = Br / pow(nitrogen, vec3(4.0));\nconst vec3 Km = Bm / pow(nitrogen, vec3(0.84));\n\nvec3 sky_color(in vec3 pos)\n{\n\t// Atmosphere Scattering\n\tvec3 fsun = LIGHT_DIRECTION;\n\tfloat brightnees = exp(-sqrt(pow(abs(min(5.*(pos.y-0.1),0.)),2.)+0.1));\n\tif(pos.y < 0.)\n\t{\n\t\tpos.y = 0.;\n\t\tpos.xyz = normalize(pos.xyz);\n\t}\n    float mu = dot(normalize(pos), normalize(fsun));\n\t\n\tvec3 extinction = mix(exp(-exp(-((pos.y + fsun.y * 4.0) * (exp(-pos.y * 16.0) + 0.1) / 80.0) / Br) * (exp(-pos.y * 16.0) + 0.1) * Kr / Br) * exp(-pos.y * exp(-pos.y * 8.0 ) * 4.0) * exp(-pos.y * 2.0) * 4.0, vec3(1.0 - exp(fsun.y)) * 0.2, -fsun.y * 0.2 + 0.5);\n\tvec3 sky_col = brightnees* 3.0 / (8.0 * 3.14) * (1.0 + mu * mu) * (Kr + Km * (1.0 - g * g) / (2.0 + g * g) / pow(1.0 + g * g - 2.0 * g * mu, 1.5)) / (Br + Bm) * extinction;\n\tsky_col = 0.4*clamp(sky_col,0.,10.);\n\treturn pow(sky_col,vec3(1./gamma_sky)); \n}\n\nvec3 ambient_sky_color(in vec3 pos)\n{\n\tfloat y = pos.y;\n\tpos.xyz = normalize(vec3(1,0,0));\n\treturn sky_color(pos)*exp(-abs(y));\n}\n\nvec4 ambient_occlusion(in vec4 pos, in vec4 norm, in vec4 dir)\n{\t\n\tvec3 pos0 = pos.xyz;\n\t\n\tfloat occlusion_angle = 0.;\n\tvec3 direction = normalize(norm.xyz);\n\tvec3 ambient_color = ambient_sky_color(norm.xyz);\n\t//step out\n\tpos.xyz += 0.05*dir.w*direction;\n\t//march in the direction of the normal\n\tfor(int i = 0; i < AMBIENT_MARCHES; i++)\n\t{\n\t\tpos.xyz += pos.w*direction;\n\t\tpos.w = DEv(pos.xyz, dir.w*LOD);\n\t\t\n\t\tnorm.w = length(pos0 - pos.xyz);\n\t\tocclusion_angle += clamp(pos.w/norm.w,0.,1.);\n\t}\n\t\n\tocclusion_angle /= float(AMBIENT_MARCHES); // average weighted by importance\n\treturn vec4(ambient_color,1.)*(0.5-cos(3.14159265*occlusion_angle)*0.5);\n}\n\n\nvec3 refraction(vec3 rd, vec3 n, float p) {\n\tfloat dot_nd = dot(rd, n);\n\treturn p * (rd - dot_nd * n) + sqrt(1.0 - (p * p) * (1.0 - dot_nd * dot_nd)) * n;\n}\n\nvec3 lighting(vec4 color, vec2 pbr, vec4 pos, vec4 dir, vec4 norm, vec3 refl, vec3 refr, float shadow) \n{\n\tvec3 albedo = color.xyz;\n\talbedo = pow(albedo,vec3(1.f/gamma_material)); //square it to make the fractals more colorfull \n\t\n\tvec4 ambient_color = ambient_occlusion(pos, norm, dir);\n\t\n\tfloat metallic = pbr.x;\n\tvec3 F0 = vec3(0.04); \n\tF0 = mix(F0, albedo, metallic);\n\t\n\t//reflectance equation\n\tvec3 Lo = vec3(0.0);\n\tvec3 V = -dir.xyz;\n\tvec3 N = norm.xyz;\n\t\n\t{ //ambient occlusion contribution\n\t\tfloat roughness = max(pbr.y,0.5);\n\t\tvec3 L = normalize(N);\n\t\tvec3 H = normalize(V + L);\n\t\tvec3 radiance = ambient_color.xyz;        \n\t\t\n\t\t// cook-torrance brdf\n\t\tfloat NDF = DistributionGGX(N, H, roughness);        \n\t\tfloat G   = GeometrySmith(N, V, L, roughness);      \n\t\tvec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n\t\t\n\t\tvec3 kS = F;\n\t\tvec3 kD = vec3(1.0) - kS;\n\t\tkD *= 1.0 - metallic;\t  \n\t\t\n\t\tvec3 numerator    = NDF * G * F;\n\t\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n\t\tvec3 specular     = numerator / max(denominator, 0.001);  \n\t\t\t\n\t\t// add to outgoing radiance Lo\n\t\tfloat NdotL = max(dot(N, L), 0.0);                \n\t\tLo += (kD * albedo / PI + specular) * radiance * NdotL;\n\t}\n\t\n\tif(!SHADOWS_ENABLED)\n\t{\n\t\tshadow = ambient_color.w;\n\t}\n\t\n\tvec3 sun_color = sky_color(LIGHT_DIRECTION);\n\n\t{ //light contribution\n\t\tfloat roughness = pbr.y;\n\t\tvec3 L = normalize(LIGHT_DIRECTION);\n\t\tvec3 H = normalize(V + L);\n\t\tvec3 radiance = sun_color*shadow*(0.65+0.35*ambient_color.w);        \n\t\t\n\t\t// cook-torrance brdf\n\t\tfloat NDF = DistributionGGX(N, H, roughness);        \n\t\tfloat G   = GeometrySmith(N, V, L, roughness);      \n\t\tvec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n\t\t\n\t\tvec3 kS = F;\n\t\tvec3 kD = vec3(1.0) - kS;\n\t\tkD *= 1.0 - metallic;\t  \n\t\t\n\t\tvec3 numerator    = NDF * G * F;\n\t\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n\t\tvec3 specular     = numerator / max(denominator, 0.001);  \n\t\t\t\n\t\t// add to outgoing radiance Lo\n\t\tfloat NdotL = max(dot(N, L), 0.0);                \n\t\tLo += (kD * albedo / PI + specular) * radiance * NdotL;\n\t}\n\t\n\t{ //light reflection, GI imitation\n\t\tfloat roughness = max(PBR_ROUGHNESS,0.8);\n\t\tvec3 L = normalize(-LIGHT_DIRECTION);\n\t\tvec3 H = normalize(V + L);\n\t\tvec3 radiance = 0.5*sun_color*ambient_color.w*(1.-ambient_color.w);        \n\t\t\n\t\t// cook-torrance brdf\n\t\tfloat NDF = DistributionGGX(N, H, roughness);        \n\t\tfloat G   = GeometrySmith(N, V, L, roughness);      \n\t\tvec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n\t\t\n\t\tvec3 kS = F;\n\t\tvec3 kD = vec3(1.0) - kS;\n\t\tkD *= 1.0 - metallic;\t  \n\t\t\n\t\tvec3 numerator    = NDF * G * F;\n\t\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n\t\tvec3 specular     = numerator / max(denominator, 0.001);  \n\t\t\t\n\t\t// add to outgoing radiance Lo\n\t\tfloat NdotL = max(dot(N, L), 0.0);                \n\t\tLo += (kD * albedo / PI + specular) * radiance * NdotL;\n\t}\n\n\tif(color.w>0.5) // if metal\n\t{\n\t\tvec3 n = normalize(norm.xyz);\n\t\tvec3 q = dir.xyz - n*(2.*dot(dir.xyz,n));\n\t\n        //metal\n        vec3 F0 = vec3(0.6); \n        vec3 L = normalize(q);\n        vec3 H = normalize(V + L);\n        vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);  \n\n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        Lo += kS*refl;\n\t}\n\t\n\treturn Lo;\n}\n\nvec3 shading_simple(in vec4 pos, in vec4 dir, float fov)\n{\n\tif(pos.w < max(1.*fov*dir.w, MIN_DIST))\n\t{\n\t\t//calculate the normal\n\t\tfloat error = 0.5*fov*dir.w;\n\t\tvec4 norm = calcNormal(pos.xyz, max(MIN_DIST, error)); \n\t\tnorm.xyz = normalize(norm.xyz);\n        \n        vec4 spos = vec4(pos.xyz, pos.w);\n\t\tfloat shadow = shadow_march(spos, vec4(LIGHT_DIRECTION,0.), 5., LIGHT_ANGLE, dir.w);\n\t\tif(norm.w < -error)\n\t\t{\n\t\t\treturn COL(pos.xyz).xyz;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//optimize color sampling \n\t\t\tvec3 cpos = pos.xyz - pos.w*norm.xyz;\n\t\t\t//cpos = cpos - DE(cpos)*norm.xyz;\n\t\t\t//cpos = cpos - DE(cpos)*norm.xyz;\n\t\t\t\n\t\t\tvec4 color; vec2 pbr;\n\t\t\tscene_material(cpos, color, pbr);\n\t\t\treturn lighting(color, pbr, pos, dir, norm, vec3(0), vec3(0), shadow); \n\t\t}\n\t}\n\telse\n\t{\n\t\treturn sky_color(dir.xyz);\n\t}\n}\n\n\nvec3 render_ray(in vec4 pos, in vec4 dir, float fov)\n{\n\tvec4 var = vec4(0,0,0,1);\n\tray_march(pos, dir, var, fov); \n\treturn shading_simple(pos, dir, fov);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 HDRmapping(vec3 color, float exposure)\n{\n\t// Exposure tone mapping\n    vec3 mapped = ACESFilm(color * exposure);\n    // Gamma correction \n    return pow(mapped, vec3(1.0 / gamma_camera));\n}\n\n\nmat3 getCamera(vec2 angles)\n{\n    angles.y = - angles.y;\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,   sin(angles.y),  cos(angles.y),\n                          0,  -cos(angles.y),  sin(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),  0.,  -sin(angles.x),\n        \t\t       0.,  1., 0.,\n        \t\t        sin(angles.x),              0.,           cos(angles.x)); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}