{
    "Shader": {
        "info": {
            "date": "1631292406",
            "description": "Based on a youtube video i cant find anymore, where a cellular automata was simulated, but the iterations were stacked ontop one another.\n\nMouse dragging can be used to \"brush\" on alive cells onto the state buffer.",
            "flags": 32,
            "hasliked": 0,
            "id": "tttSDn",
            "likes": 21,
            "name": "Time is up",
            "published": 3,
            "tags": [
                "voxel",
                "buffer",
                "cellularautomata"
            ],
            "usePreview": 0,
            "username": "Gegell",
            "viewed": 550
        },
        "renderpass": [
            {
                "code": "/*\n * ToDo:\n * [x] Better shading\n * [x] Better Better shading\n * [x] Shadows\n * [x] Project ro onto top plane before voxelMarch, if not inside the area of automata.\n * [ ] AO\n * [x] Better fog\n *\n */\n\n#define _Voxelsize .3\n#define _Maxdist 64.\n#define _Maxstepcount 512\n\n#define shadows\n\nstruct marchRes {\n\tint iter;\n    float totalDist;\n    int mat;\n    vec3 lastPos;\n    ivec3 lastCellPos;\n    ivec3 lastWall;\n};\n\nuint contained(ivec3 cellIndex) {\n    if (cellIndex == ivec3(0)) return 1u;\n    uvec4 buffer = floatBitsToUint(texelFetch(iChannel0, cellIndex.xz, 0));\n    if (cellIndex.y < 0) return 0u;\n    else if (cellIndex.y <  28) return 1u & (buffer.r >> cellIndex.y);\n    else if (cellIndex.y <  56) return 1u & (buffer.g >> (cellIndex.y - 28));\n    else if (cellIndex.y <  84) return 1u & (buffer.b >> (cellIndex.y - 56));\n    else if (cellIndex.y < 112) return 1u & (buffer.a >> (cellIndex.y - 84));\n    return 0u;\n}\n\nmarchRes voxelMarch(vec3 ro, vec3 rd) {\n    marchRes res;\n    res.lastCellPos = ivec3(floor(ro / _Voxelsize));\n    res.lastPos = ro;\n    res.mat = -1;\n    res.totalDist = 0.;\n    vec3 recRay = 1. / rd;\n    for (res.iter = 0; res.iter < _Maxstepcount && res.totalDist < _Maxdist; res.iter++) {\n    \tuint dist = contained(ivec3(iChannelResolution[0].x, 0, iChannelResolution[0].y)/2 - res.lastCellPos);\n        if (dist != 0u) {\n            res.mat = 0;\n            break;\n        }\n        \n\t\tvec3 nextBorders = (vec3(res.lastCellPos) + vec3(greaterThan(rd, vec3(0.)))) * _Voxelsize;\n        vec3 scalars = (nextBorders - res.lastPos) * recRay;\n        float m = min(scalars.x, min(scalars.y, scalars.z));\n        res.lastPos += m * rd;\n        res.totalDist += m;\n        res.lastWall = ivec3(equal(scalars, vec3(m))) * (ivec3(greaterThan(rd, vec3(0.))) * 2 - 1);\n        res.lastCellPos += res.lastWall;\n    }\n    return res;\n}\n\n/**\n * From https://www.shadertoy.com/view/lt33z7\n *\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * From https://www.shadertoy.com/view/Xtd3z7\n *\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvec3 colorLookup(float val) {\n    vec3 p = vec3(1., 1., 1.);\n    vec3 o = vec3(0., .3, .6);\n    vec3 a = vec3(1.5);\n    vec3 as = vec3(0.);\n\treturn (sin((p * val + o) * 6.283)*.5 + .5) * a + as;\n}\n\nvec3 getSkyColor(vec3 rd) {\n\treturn mix(vec3(.7, .7, .9), vec3(.2, .2, .7), smoothstep(-.2, .3, rd.y));\n}\n\nvec3 getColor(marchRes res, vec3 rd) {\n\tvec3 col = vec3(0.);\n    if (res.mat < 0) {\n    \tcol = getSkyColor(rd);\n    } else {\n        \n        vec3 normal = vec3(res.lastWall);\n        \n        vec3 material = colorLookup(float(res.lastCellPos.y + iFrame / Frames_per_step) * 3. / 112.);\n        material *= .2;\n        \n        vec3 sun_dir = normalize(-vec3(.8, .4, .2));\n        float sun_dif = clamp(dot(normal, sun_dir), 0.0, 1.0);\n        float sky_dif = clamp(.5 - .5 * normal.y, 0.0, 1.0);\n        #ifdef shadows\n        marchRes shadowRes = voxelMarch(res.lastPos - .01 * _Voxelsize * sun_dir, -sun_dir);\n        if (shadowRes.mat >= 0) sun_dif = 0.;\n        #endif\n        \n    \tcol  = material * vec3(8.0, 4.0, 2.0) * sun_dif;\n        col += material * vec3(0.5, 1.0, 2.0) * sky_dif;\n        //Better fog, get skyColor function, based on angle of rd.y\n        col = mix(col, getSkyColor(rd), smoothstep(_Maxdist *.95, _Maxdist*1.2, res.totalDist));\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = .25;\n    vec3 offset = vec3(0., fract(float(iFrame) / float(Frames_per_step)), 0.) * _Voxelsize;\n    \n    vec3 eye = vec3(sin(iTime*.7 * speed)*15.,\n                    4.,\n                    cos(iTime * .7  * speed)*15.);\n    vec3 viewDir = rayDirection(90.0, iResolution.xy, fragCoord);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, -.5, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float param = (_Voxelsize * 2. - eye.y) / worldDir.y;\n    vec3 ro = eye + offset + param * worldDir;\n    \n    marchRes res = voxelMarch(ro, worldDir);\n    res.totalDist += param;\n    \n    vec3 col = getColor(res, worldDir);\n    \n    col = pow(col, vec3(.45));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#if Life_ruleset == 1\n    // Standard GOL rules\n    #define Rule_Begin 0x008\n    #define Rule_Stay  0x00C\n#elif Life_ruleset == 2\n\t// Copying Rules\n    #define Rule_Begin 0x0AA\n    #define Rule_Stay  0x0AA\n#elif Life_ruleset == 3\n\t// Mazelike\n    #define Rule_Begin 0x008\n    #define Rule_Stay  0x03C\n#elif Life_ruleset == 4\n\t// Walls\n    #define Rule_Begin 0x1F0\n    #define Rule_Stay  0x1FA\n#elif Life_ruleset == 5\n\t// Lively City Walls\n    #define Rule_Begin 0x1F0\n    #define Rule_Stay  0x1DA\n#endif\n\n\nbool getInitialState(in vec2 fragCoord) {\n    // Normalized pixel coordinates (from -1 to 1 on y)\n    vec2 p = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    \n    // Randomish initial condition\n    return (floatBitsToInt(cos(3.*p.x+p.y) + sin(p.y)) & 7) < 1;\n    \n\t// Circle in Center\n    //return length(p) < .01; \n}\n\nbool mouseBrush( in vec2 pos ) {\n    // Only brush if mouse is pressed\n    if (iMouse.z <= 0.)\n        return false;\n    // Small perturbation to the circle to achieve more diverse patterns\n    float perturbation = cos(.02*(pos.x+pos.y)) + sin(pos.y*.05+iTime*.2);\n    return length(iMouse.xy - pos) < 15. + perturbation * 5.;\n}\n\nint getBlockState( in ivec2 pos ) {\n    uint state = 0u;\n    int index = 0;\n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++, index++) {\n    \t\tuvec4 cell = floatBitsToUint(texelFetch(iChannel0, pos + ivec2(x, y), 0));\n           \tstate |= (cell.x & 1u) << index;\n        }\t\n    }\n    return int(state);\n}\n\nint bitsSet( in int bits ) {\n\tint a = (bits & 0x5555) + ( (bits >> 1) & 0x5555 );\n    int b = (a & 0x3333) + ( (a >> 2) & 0x3333 );\n    int c = (b & 0x0f0f) + ( (b >> 4) & 0x0f0f );\n    int d = (c & 0x00ff) + ( (c >> 8) & 0x00ff );\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 initVal = vec4(intBitsToFloat(0));\n    initVal.r = intBitsToFloat(getInitialState(fragCoord) ? 0xF0000003 : 0xF0000002);\n    \n    ivec2 ipos = ivec2(fragCoord.x, fragCoord.y);\n    \n    uvec4 currentBufferValue = floatBitsToUint(texelFetch(iChannel0, ipos, 0));\n    \n    int currentBlockState = getBlockState(ipos);\n    bool currentState = ((currentBlockState & 0x10) != 0);\n    \n    int neighbourCount = bitsSet(currentBlockState);\n    \n    bool newState = currentState;\n    if (iFrame % Frames_per_step == 0) {\n        if (!currentState) {\n            newState = ((Rule_Begin >> neighbourCount) & 1) == 1;\n        } else {\n            newState = ((Rule_Stay  >> (neighbourCount - 1)) & 1) == 1;\n        }\n        \n        #ifdef Life_use_mouse_brush\n            newState = newState || mouseBrush(fragCoord);\n        #endif\n    \n        currentBufferValue = ((currentBufferValue << 1) & (0x0FFFFFFFu)) | uvec4(uint(newState), (currentBufferValue.xyz >> 27) & 1u);\n    }\n    \n    vec4 newVal = uintBitsToFloat(currentBufferValue);\n    \n    fragColor = iFrame == 0 ? initVal : newVal;\n    \n    if (fragColor.r > .5) fragColor.g += .01;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define Frames_per_step 20\n#define Life_use_mouse_brush\n#define Life_ruleset 1",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}