{
    "Shader": {
        "info": {
            "date": "1635314093",
            "description": "A figure-8 knot, as described here: [url]https://arxiv.org/pdf/1610.02463.pdf[/url].",
            "flags": 0,
            "hasliked": 0,
            "id": "fdyXWK",
            "likes": 34,
            "name": "Figure-8 Knot (Implicit in R4)",
            "published": 3,
            "tags": [
                "3d",
                "4d",
                "knot",
                "projective"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 969
        },
        "renderpass": [
            {
                "code": "/* Inigo Quilez 2021\n\nAn appoximated SDF for a Figure-8 knot. The idea is described here\nhttps://arxiv.org/pdf/1610.02463.pdf and goes like this:\n\nFrom R3, our regular 3D space, we do an inverse stereographic projection\nto land in a 4D hyper sphere S3, a subset of R4. Here in R4 we define a\nfunction F that returns a R2 field (or two scalar fields, if you want).\nThen we find its zero isosurface (nodal set). Because we are only\nevaluating the subset of R4 that lays on S3, we are really computing the\nintersection of the isosurface of F with the sphere S3. This creates a\ncurve on the sphere, which thanks to the stereographic projection becomes\na curve in R3, our 3D space. That's the curve we are raymarching. Now,\nthe R4 domain of F can be grouped as two complex numbers u and v. In the\ncase of the figure 8 knot,\n\nF(u,v) = 64v³ − 12v(3+2u²−2u*²) − (14u²+14u*²+u⁴-u*⁴)\n\nwhere u* is the conjugate of u. Finally, texturing happens in spherical\ncoordinates on S3 itself, with becomes a regular 3D texturing problem.\n\nYou can change the SHAPE define below to see other shapes. Also, there\nare more than one way to convert F into a R1 scalar field than taking\nits length |F|. For example, you can pass F through any 2D SDF formula\nyou want, such a square. Change the PROFILE define bellow to explore that.\n\nSee also: https://www.shadertoy.com/view/lfSBzt\nSee also: https://www.shadertoy.com/view/tsBGzt\nSee also: https://www.shadertoy.com/view/7sGSRd                        */\n\n// antialiasing. Can set to 2 if you have a fast machine\n#define AA 1\n\n// 0: figure 8\n// 1: torus 5-2\n// 2: clifford torus\n// 3: something I made\n// 4: some other shape I made\n#define SHAPE 0\n\n// 0: circular\n// 1: square\n#define PROFILE 0\n\n// 0: distance estimation in R3 (pos)\n// 1: distance estimation in R1 (t), equivalent to Newtwon-Raphson\n#define METHOD 1\n\n//------------------------------------------------------------\n// oldschool rand() from Visual Studio\n//------------------------------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n//------------------------------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n//------------------------------------------------------------\nint hash( int n )\n{\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n//------------------------------------------------------------\n// complex number operations\n//------------------------------------------------------------\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqr( vec2 a ) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\n//------------------------------------------------------------\n// https://en.wikipedia.org/wiki/Stereographic_projection\nvec4 inversestereographic(vec3 p)\n{\n    float r2 = 1.0+dot(p,p);\n    return vec4(2.0*p,r2-2.0)/r2;\n}\n//------------------------------------------------------------\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRoundSquare( in vec2 p, in float s, in float r ) \n{\n    vec2 q = abs(p)-s+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n//------------------------------------------------------------\n// texture a 4D sphere, |p|=1\nvec3 tex( sampler2D sam, in vec4 p )\n{\n    // https://en.wikipedia.org/wiki/N-sphere#Spherical_coordinates\n    vec3 q = acos(p.xyz/vec3(length(p.xyzw),\n                             length(p.yzw),\n                             length(p.zw) ));\n                             \n    // here we could do actual 3D texturing, but instead,\n    // i hacked three 2D texture projections\n    vec3 col = vec3(0.0);\n    col  = texture(sam,q.xy).xyz;\n    col += texture(sam,q.yz).xyz;\n    col += texture(sam,q.zx).xyz;\n    col = col/3.0;\n    \n    // adjust contrast a bit to match source texture\n    col *= 0.5+col*(1.5-col);\n\n    // srgb to linear\n    return col*col;\n}\n//===============================================================================================\n\nvec4 r3_to_s3( in vec3 p )\n{\n    vec4 q = inversestereographic(p);\n    \n    // rotate in yw\n    float a = iTime*6.283185/6.0;\n    q.yw *= mat2(cos(a),sin(a),-sin(a),cos(a));\n    \n    return q;\n}\n\nvec2 F( in vec2 u, vec2 v )\n{\n    #if SHAPE==0\n    return  64.0*cmul(u,csqr(u)) \n          - 12.0*cmul(u,vec2(3.0,0.0) - 2.0*csqr(v) + 2.0*csqr(conj(v))) \n          + 14.0*cmul(v,v) \n          + 14.0*csqr(conj(v)) \n          -      csqr(csqr(v)) \n          +      csqr(csqr(conj(v)));\n    #endif\n    \n    #if SHAPE==1\n    return 20.0*(cmul(u,csqr(csqr(u))) + csqr(v));\n    #endif    \n    \n    #if SHAPE==2\n    return 32.0*(cmul(u,conj(u))-cmul(v,conj(v)));\n    #endif    \n\n    #if SHAPE==3\n    return  64.0*cmul(v,csqr(csqr(u)))\n          + 32.0*cmul(u,csqr(v))\n          + 32.0*csqr(v) \n          + 8.0;\n    #endif    \n\n    #if SHAPE==4\n    float h = u.x*u.x - u.y*u.y + v.x*v.x - v.y*v.y;\n    return vec2(u.y*u.y*u.y + v.y*v.y*h,  u.x*u.x*v.x + u.y*v.x*h)*32.0;\n    #endif\n\n}\n\nfloat field( in vec4 q )\n{\n    vec2 phi = F(q.xy,q.zw);\n    \n    #if SHAPE==4\n    const float th = 1.0;\n    #else\n    const float th = 10.0;\n    #endif\n    \n    #if PROFILE==0\n    return length(phi) - th;\n    #else\n    return sdRoundSquare( phi, 0.8*th, 0.05*th );\n    #endif\n}\n\nfloat map( in vec3 p )\n{\n    return field(r3_to_s3(p));\n}\n\nfloat distance_map( in vec3 p )\n{\n    float d = field(r3_to_s3(p));\n\n    // could do some automatic differentiation here...\n    float eps = 0.0001;\n    vec3 g = (vec3(field(r3_to_s3(p+vec3(eps,0.0,0.0))),\n                   field(r3_to_s3(p+vec3(0.0,eps,0.0))),\n                   field(r3_to_s3(p+vec3(0.0,0.0,eps))))-d)/eps;\n    \n    // distance estimator\n    return d/length(g);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat shadow( in vec3 ro, in vec3 rd, float k )\n{\n    const float tmax = 5.0;\n    float t = 0.001;\n    float sh = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        #if METHOD==0\n        float f = distance_map(pos);\n        sh = min( sh, clamp(k*f/t,0.0,1.0) );\n        if( sh<0.001 ) break;\n        #else\n        float f = map(pos);\n        sh = min( sh, clamp(0.02*k*f/t,0.0,1.0) );\n        if( sh<0.001 ) break;\n        const float eps = 0.001;\n        float df = (map(ro+rd*(t+eps))-f)/eps;\n        f = f/abs(df);\n        #endif\n        \n\n        t += clamp(f,0.001,0.1);\n        if( t>tmax ) break;\n    }\n    return sh;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\tfloat h = frand();\n        vec3 kv = normalize( vec3(frand(), frand(), frand()) );\n        kv *= sign(dot(kv,nor));\n\t\tao += clamp( distance_map(pos+nor*0.001+kv*h*2.0)*1.0, 0.0, 1.0 );\n\t}\n\tao /= 32.0;\n\t\n\treturn clamp( ao*1.5-0.1, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(iFrame))));\n\n    // camera movement\t\n    float an = -0.0*iTime/20.0;\n    vec3 ro = vec3( 5.0*sin(6.283185*an), 4.0, 5.0*cos(6.283185*an) );\n    #if SHAPE==1\n    ro.xz *= 1.5;\n    ro.y = 0.0;\n    #endif\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n        \n        \n        vec3 col = vec3(0.0);\n        col = vec3(0.05 + 0.05*rd.y);\n        \n        // raymarch\n        if( map(ro)>0.0 )\n        {\n        const float tmax = 15.0;\n        float t = 0.0;\n        for( int i=0; i<8192; i++ )\n        {\n            vec3 pos = ro + rd*t;\n            \n            #if METHOD==0\n            float f = distance_map(pos);\n            if( abs(f)<0.001 ) break;\n            float dt = f;\n            #else\n            float f = map(pos);\n            if( abs(f)<0.001 ) break;\n            const float eps = 0.001;\n            float df = (map(ro+rd*(t+eps))-f)/eps;\n            float dt = f/abs(df);\n            #endif\n            \n            t += clamp(dt,-0.1,0.1);\n            if( t>tmax ) break;\n        }\n            \n\n        if( t<tmax )\n        {\n            vec3  pos = ro + rd*t;\n            vec3  nor = calcNormal( pos, 0.0001 );\n            float occ = calcAO( pos+nor*0.001, nor );\n\n            // we do texturing in R4\n            vec4 pos4 = r3_to_s3(pos);\n            vec3 mate = tex(iChannel0,pos4);\n            mate *= 0.3;\n\n            // sun\n            {\n            vec3 lig = normalize(vec3(1.0,1.0,0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            if( dif>0.001 ) dif *= shadow(pos+nor*0.001, lig, 48.0);\n            vec3 hal = normalize(lig-rd);\n            float spe = pow(clamp(dot(nor,hal),00.,1.0),32.0);\n            spe *= 0.04 + 0.96*pow( clamp(1.0-dot(lig,hal), 0.0, 1.0), 5.0 );\n            spe *= 10.0;\n\n            col  = 0.6*mate*vec3(9.0,8.0,7.0)*dif;\n            col += spe*dif*mate.x*10.0;\n            \n            float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n            col += mate*fre*1.0*(0.25+0.75*dif)*vec3(1.0,0.7,0.4);\n            }\n            \n            // sky\n            {\n            vec3 ref = reflect(rd,nor);\n            float dif = 0.5+0.5*nor.y;\n            float spe = smoothstep(0.3,0.5,ref.y);\n            spe *= dif;\n            spe *= 0.04 + 0.96*pow( clamp(1.0+dot(rd,nor), 0.0, 1.0), 5.0 );\n            if( spe>0.001 ) spe *= shadow(pos+nor*0.001, ref, 8.0);\n            col += 3.0*occ*mate*dif*vec3(0.5,0.6,1.0)*1.5;\n            #if METHOD==1\n            spe *= 2.0;\n            #endif\n            col += 1.0*spe;\n            }\n\n            // sun bounce\n            col += mate*(1.0-occ)*vec3(1.2,0.5,0.2)*0.2;\n        }\n        }\n\n        // gain\n        col = col*1.5/(1.0+col);\n        \n        // to gamma space\n        col = pow( col, vec3(0.4545) );\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // remove color banding through dithering\n    tot += (1.0/255.0)*frand();\n \n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}