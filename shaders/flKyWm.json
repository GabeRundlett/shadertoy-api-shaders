{
    "Shader": {
        "info": {
            "date": "1661612400",
            "description": "I watched a video about transformations and got a bit carried away. \nI used noise to mingle with line widths and colors but other than that, everything is made only using straight lines.\n\nHere's the video: https://www.youtube.com/watch?v=Pp47xzf4wGg",
            "flags": 0,
            "hasliked": 0,
            "id": "flKyWm",
            "likes": 6,
            "name": "Only straight lines",
            "published": 3,
            "tags": [
                "lines",
                "transform"
            ],
            "usePreview": 0,
            "username": "LorenzoFiestas",
            "viewed": 342
        },
        "renderpass": [
            {
                "code": "// Author: Lorenzo Fiestas\n\n//-----------------------------------------------\n//      UTILITIES\n\n#define PI (3.141592)\n\nfloat rand(vec2 st);\n\nfloat rand(vec3 p);\n\nfloat valueNoise(vec2 st);\n\nfloat valueNoise(vec3 p);\n\nfloat valueNoise(vec3 p, int octaves);\n\nvec3 hsv2rgb(vec3 hsv);\n\nvec3 rgb2hsv( in vec3 rgb );\n\nmat2 rotate(float t);\n\n\n\n\n\n//-----------------------------------------------\n\n\n\n\n\n// Draw line trough p0 and p1\nfloat line(vec2 st, vec2 p0, vec2 p1)\n{\n    float width = .15 + .125*(.5*valueNoise(2.*st + iTime) - .5);\n    float dx = p1.x - p0.x;\n    \n    bool divBy0 = dx == 0.;\n    if(divBy0)\n        return smoothstep(width, -width, abs(st.x - p0.x));\n    \n    float m = (p1.y - p0.y)/dx;\n    float b = p0.y - m*p0.x;\n    float wFix = abs(cos(atan(m)));\n    width /= wFix;\n    \n    return smoothstep(width, -width, abs(m*st.x + b - st.y));\n}\n\n// Functions to be used for transformations\nfloat func(float x)\n{    \n    float t = .3*iTime;\n    float ret = 0.;\n    \n    float func0 = 1./x;\n    float func1 = exp(x) + x;\n    float func2 = 1./x + x;\n    float func3 = cos(x);\n    \n//#define SIN_CYCLING\n#ifdef SIN_CYCLING\n    #define SQR(x) ((x)*(x))\n    ret += (SQR(max(0.,  sin(t))) + .01) * func0;\n    ret += (SQR(max(0.,  cos(t))) + .01) * func1;\n    ret += (SQR(max(0., -sin(t))) + .01) * func2;\n    ret += (SQR(max(0., -cos(t))) + .01) * func3;\n#else\n    #define cycle(x) (smoothstep(0., 1., 1.-abs((x)-1.)))\n    ret += (cycle(mod(t + 0., 4.)) +.01) * func0;\n    ret += (cycle(mod(t + 1., 4.)) +.01) * func1;\n    ret += (cycle(mod(t + 2., 4.)) +.01) * func2;\n    ret += (cycle(mod(t + 3., 4.)) +.01) * func3;\n#endif\n\n    float twist = 2.*sin(.1*iTime) + 2.;\n    return ret + twist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1. to 1.)\n    vec2 uv0 = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    const float ZOOM = 4.;\n    vec2 uv  = uv0 * ZOOM * rotate(-.25*iTime);\n    vec2 uvr = rotate(0.*PI/3.) * uv;\n    vec2 uvg = rotate(2.*PI/3.) * uv;\n    vec2 uvb = rotate(4.*PI/3.) * uv;\n\n    // Time varying pixel color\n    float mask = 0.;\n    vec3 col = vec3(0.);\n    const float RANGE = 5.;\n    const float LINES = 100.;\n    \n    // Paint 2.*LINES lines for each color \n    for(float x = -RANGE; x <= RANGE; x += RANGE/LINES)\n    {   \n        #define PAINT_COLOR(C,UV) mask   = line(UV, vec2(x, 1.), vec2(func(x), -1.));  \\\n                                  col.C += /*max(0., cos(PI*x/RANGE)) * */ mask;\n        \n        PAINT_COLOR(r, uvr)\n        PAINT_COLOR(g, uvg)\n        PAINT_COLOR(b, uvb)\n    }\n    // Extra juice to colors\n    col *= atan(length(col))/(length(col) + .001);\n            \n    // Smokify colours\n    vec3 hsv = rgb2hsv(col);\n#define PRONOUNCED_COLOR_BOUNDARIES\n#ifdef PRONOUNCED_COLOR_BOUNDARIES\n    // Change noise based on color to get more defined color sections\n    hsv += .4*valueNoise(vec3(3.*uv0, 5.*(hsv[0] + hsv[1]) + iTime), 5);\n#else\n    hsv += .4*valueNoise(vec3(3.*uv0, iTime), 5);\n#endif\n    hsv[2] *= 1. - smoothstep(1., .5, hsv[1] + .5); // darken bg noise\n    \n    vec3 rgb = hsv2rgb(hsv); \n    fragColor = vec4(rgb, 1.);\n}\n\n\n\n\n\n\n\n\n\n//-----------------------------------------------------------------------------------\n\n\n\n\n\n\n\n\n\n\n\nfloat rand(vec2 st)\n{\n    return fract(6373.35391*st.x*sin(734.255*(st.y-st.x + 35.3)) +\n                 344.872343*st.y*sin(5443.65*(st.y-st.x + 11.2)) + 395.47);\n}\n\nfloat rand(vec3 p)\n{\n    return fract(6373.35391*p.x*sin(734.255*(p.y-p.x-p.z + 35.3)) +\n                 344.872343*p.y*sin(5443.65*(p.y-p.x-p.z + 11.2)) +\n                 -42.349436*p.z*sin(-246.42*(p.y-p.x-p.z + 7.26)) +\n                 395.47);\n}\n\nfloat valueNoise(vec2 st)\n{\n    float x0y0 = rand(floor(st + vec2(0., 0.)));\n    float x0y1 = rand(floor(st + vec2(0., 1.)));\n    float x1y0 = rand(floor(st + vec2(1., 0.)));\n    float x1y1 = rand(floor(st + vec2(1., 1.)));\n    \n    float l = mix(x0y0, x0y1, fract(st.y));\n    float r = mix(x1y0, x1y1, fract(st.y));\n    return mix(l, r, fract(st.x));\n}\n\nfloat valueNoise(vec3 p)\n{\n    float x0y0z0 = rand(floor(p + vec3(0., 0., 0.)));\n    float x0y1z0 = rand(floor(p + vec3(0., 1., 0.)));\n    float x1y0z0 = rand(floor(p + vec3(1., 0., 0.)));\n    float x1y1z0 = rand(floor(p + vec3(1., 1., 0.)));\n    \n    float x0y0z1 = rand(floor(p + vec3(0., 0., 1.)));\n    float x0y1z1 = rand(floor(p + vec3(0., 1., 1.)));\n    float x1y0z1 = rand(floor(p + vec3(1., 0., 1.)));\n    float x1y1z1 = rand(floor(p + vec3(1., 1., 1.)));\n    \n    float l0 = mix(x0y0z0, x0y1z0, fract(p.y));\n    float r0 = mix(x1y0z0, x1y1z0, fract(p.y));\n    \n    float l1 = mix(x0y0z1, x0y1z1, fract(p.y));\n    float r1 = mix(x1y0z1, x1y1z1, fract(p.y));\n    \n    return mix(mix(l0, r0, fract(p.x)),\n               mix(l1, r1, fract(p.x)), fract(p.z));\n}\n\nfloat valueNoise(vec3 p, int octaves)\n{\n    float k = 1.;\n    float f = 1.;\n    float ret = 0.;\n    for(int i = 0; i < octaves; i++)\n    {\n        ret += k*valueNoise(f*p);\n        k *= 1./sqrt(2.);\n        f *= 2.;\n    }\n    return ret/(sqrt(float(octaves)));\n}\n\nvec3 hsv2rgb(vec3 hsv)\n{\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn hsv.z * mix( vec3(1.0), rgb, hsv.y);\n}\n\nvec3 rgb2hsv( in vec3 rgb )\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, K.wz),\n                 vec4(rgb.gb, K.xy),\n                 step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r),\n                 vec4(rgb.r, p.yzx),\n                 step(p.x, rgb.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\nmat2 rotate(float t)\n{\n    return mat2(cos(t), -sin(t),\n                sin(t), cos(t));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}