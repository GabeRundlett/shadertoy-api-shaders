{
    "Shader": {
        "info": {
            "date": "1493239414",
            "description": "[green line]  = distance.y to mouse.y= iMouse.y-u.y, overwritten by a loop\n[red tots]     = closest distance to [green line] intersections with [blue sin()]\n[burplelines] = 90° angle to sin() at red dots.",
            "flags": 0,
            "hasliked": 0,
            "id": "XsByzd",
            "likes": 5,
            "name": "distance to y=sin(x) ,intersect",
            "published": 3,
            "tags": [
                "sin",
                "distance",
                "tangent",
                "offset",
                "parallel",
                "inetrsect"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 846
        },
        "renderpass": [
            {
                "code": "//solve for all intersections \n//uncomment to only sove for the smallest positive intersection.\n#define modMirr\n//display red as rings (or dots)\n#define rings\n\n//show the \"field ot fangents\" by looping trough some of them\n#define loopIt\n\nvec2 frame(vec2 u){u/=iResolution.xy;\n u-=.5;//center\n u*=15.;//zoom\n u.x*=iResolution.x/iResolution.y;return u;}\n\n//above parameters are more customizable than below constants.\n\n//mod(withoffset) , and mirror every other cell.\nfloat pModMirror1(in float p, float s){float h=s*.5;\n return (mod(p+h,s)-h)*(mod(floor((p+h)/s),2.)*2.-1.);}//from hg_sdf by mercury\n\n#define r2(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n\n//rotate p by angle r: p=r(p,r);\n#define rr(p,r) (cos(r)*p+sin(r)*vec2(-p.y,p.x))\n//vec2 r(vec2 p,float t){return cos(r)*p+sin(r)*vec2(-p.y,p.x);\n//}//from https://www.shadertoy.com/view/XlfGzH\n\n\nvoid mainImage( out vec4 o, in vec2 u ){\n\tu=frame(u);\n    vec2 m=frame(iMouse.xy);\n    //end of  viewframe setup.\n    \n    //mm=m.y;\n    \n    vec3 acc=vec3(0);\n    \n    #ifdef loopIt\n    for(float mm=-1.;mm<1.;mm=mm+.05){\n    #else \n     float mm=m.y;\n     //mm=-0.25 ;//force overwrite\n    #endif\n\n    \n    //s is BAD distance.y to sin(), cheap way to draw a sin()\n    float s=sin(u.x)-u.y;\n    s=1.-smoothstep(.0,.1,abs(s));\n    //s=sqrt(s);\n\n    //h is green horizontal line\n    float h=1.-smoothstep(.0,.1,abs(u.y-mm));\n    \n    //i->j is distance to intersection of the above 2, as red rings.\n    vec2 i=vec2(0);\n    //mm=clamp(mm,-1.,1.);//enforce intersections\n    \n    i.x=asin(mm);\n    i.y=sin(i.x);\n    vec2 v=vec2(-pModMirror1(u.x,acos(-1.)),u.y);\n    #ifdef modMirr\n    u.x=-pModMirror1(u.x,acos(-1.));\n    #endif\n\n  //v=distance to line that is perpendicular to sinusoid at intersection\n  //v=rr((u.xy-i),acos(-1.)-acos(-1.)*.5*cos(i.x) )+i.x;\n  //above line is identical to below line\n    v=rr((u.xy-i),acos(-1.)*(1.      -.5*cos(i.x)))+i.x;\n    //l is orthogonal line, 90° angle to sin() at intersection points.\n    float l=1.-smoothstep(.0,.05,abs(u-v).x);\n    //all points on a purple line are closest to the sin() \n    //at the point of intersection???\n    \n    //purple line extreme case adjustments\n    if((mm>= 1.-exp2(-8.))&&u.y<= 1.)l=0.;\n    if((mm<=-1.+exp2(-8.))&&u.y>=-1.)l=0.;\n    \n    //yellow dots should be at corners of purple lines\n    vec2 t=vec2(0);\n    t.x=-acos(0.);\n    t.y= pow(acos(-1.),tan(mm+.195));\n    //doesnt look corect, but gets pretty close to:\n    \n    //  x     -> y=f(x)\n    //<=-1.   -> any value <1.0, is valid.\n    //-0.999  -> 0.001;ish\n    //-0.875  -> 3.14/8.;...\n    //-0.75   -> 3.14/6.;\n    //-0.5    -> 3.14/4.;\n    //-0.25   -> 3.14*sqrt(2.)/4.;\n    //  ==           ==\n    //-0.25   -> pow(acos(-1.),sqrt(2.)/8.0     );\n    // 0.0    -> pow(acos(-1.),sqrt(2.)/4.0     );\n    // 0.25   -> pow(acos(-1.),sqrt(2.)/2.0     );\n    // 0.5    -> pow(acos(-1.),sqrt(2.)/sqrt(2.));\n    // 0.75   -> pow(acos(-1.),sqrt(2.)         );\n    // 0.875  -> pow(acos(-1.),sqrt(2.)         )*3./2.;\n    // 1.0    -> not defined (limes is infinity)\n    \n    //test overwrites:\n    //pow(acos(-1.),sqrt(2.)/8.0     );\n    \n    //yellow dots\n    float  dt=.1-length(t-u);\n    dt=smoothstep(0.,.02,dt);\n    \n\n        \n    //modifying red;\n    float j=length(i-u);\n    #ifdef rings\n    j=.7-fract(j*2.)*j;\n    #else\n    j=step(j,.2);\n    #endif\n        \n        h*=.01;\n        j*=.1;\n    \n    //pink is red ad blue:\n    j=max(j,l);\n    s=max(s,l);   \n    \n    \n    //yellow is red and green\n    j=max(j,dt);\n    h=max(h,dt); \n    \n    \n    t.x=-acos(0.);\n    t.y= pow(acos(-1.),tan(mm+.195));\n    acc+=vec3(j,h,s);\n       #ifdef loopIt\n }\n    #endif\n    \n//i have a continuous set of vectors from an [t] \n//...to intersection point [i]\n//that completely set by m.y;\n    \n    //float dist=length(t-i);\n    \n    \n\to = vec4(acc,1.0);\n    \n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}