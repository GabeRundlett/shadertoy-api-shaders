{
    "Shader": {
        "info": {
            "date": "1475542328",
            "description": "transformed a metaball  loop into a more parallelizable variant, more similar to a smoothUnions-tree,\nusing trigonometry|rotations to hide symmetry.\nalmost makes metaballs fractal, ans still perform (and look) worse than smoothUnions.",
            "flags": 0,
            "hasliked": 0,
            "id": "4tVGzK",
            "likes": 6,
            "name": "symmetrical smootmix mettaballs",
            "published": 3,
            "tags": [
                "2d",
                "metaball",
                "rotation",
                "symmetry",
                "hgsdf",
                "parallel"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 799
        },
        "renderpass": [
            {
                "code": "/*\nblue and green distance fields done in parallel, also for metaballs\n//red is union of blue and red.\n\ntransformed a metaball  loop into a more parallelizable variant, more similar to a smoothUnions-tree,\nusing trigonometry|rotations to hide symmetry.\nalmost makes metaballs fractal, ans still perform (and look) worse than smoothUnions.\n*/\n\n#define roundedUnion\n//roundedUnion uses fOpUnionRound of hg_sdf\n//not good metaballs, but a useful fast approximation of metaballs\n//without roundedUnion\n//is uses smoothstep(0,1,length(a-b)) metaballs\n//onnly useful for 2d textures, as its distanceField is bad.\n\n//roundedUnion likely always performs faster and has a better distanceField\n\n//pi=3.14...=tau*.5=pi2*2.\n#define pi2 asin(+1.)\n#define pi  acos(-1.)\n#define tau (acos(-1.)*2.)\n//1./phi=phi-1.=0.61...\n#define phi (sqrt(5.)*.5+.5)\n\n//return rotated mirror-matrix, reflect at mirror that is rotated by r*.5\n#define rotm(r) mat2(sin(r+vec4(pi2,0,0,-pi2)))\n\n/*\n//https://www.shadertoy.com/view/llG3RV\nfloat metaballs(vec2 p){float v=0.;\n for(float i=0.;i<3.;i++){\n  vec2 c = sin(.5*iTime*1.+vec2(i,.5)+i);\n  v += 1.-smoothstep(0.0,1.,length(p-c));\n }return v;}\n*/\n\n\n//2 more symmetrical metaballs\nfloat metaballsS(vec2 p,float x){\n return 2.-smoothstep(0.,1.,length(p+vec2(x,0.)))\n          -smoothstep(0.,1.,length(p-vec2(x,0.)));}\n\n\n//likely faster if extending on https://www.shadertoy.com/view/ltyGzV instead.\n//https://www.shadertoy.com/view/ltyGzV\nfloat fOpUnionRound(float a,float b, float r){\n vec2 u=max(vec2(r-a,r-b),vec2(0));\n return max(r,min(a,b))-length(u);}\nfloat metaballsU(vec2 p,float x){\n return fOpUnionRound(length(p)-.5,length(p-vec2(x,0.))-.5,1.);}\n//not quite right, \n//because the results of 2 of those can not be summed up meaningfully.\n//it gives a valid distanceField but its not too metaballsy\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n vec2 p=(6.*fragCoord-iResolution.xy)/iResolution.y;\n p-=2.;\n p*=rotm(iTime*(phi-1.));\n //a gets green b gets blue, sum of a and b gets red.\n \n\n#ifdef roundedUnion\n float a=metaballsU( p-vec2(1)                   ,1.1+sin(iTime*phi));\n float b=metaballsU((p+vec2(1))*rotm(iTime),1.1+sin(iTime));\n //both functions are fed the same, below is metaballs, above is rounded unions.\n#else\n float a=metaballsS( p-vec2(1)                   ,1.1+sin(iTime*phi));\n float b=metaballsS((p+vec2(1))*rotm(iTime),1.1+sin(iTime));\n#endif\n const float ss=.3;\n#ifdef roundedUnion\n float m=fOpUnionRound(a,b,3.+sin(iTime));//2.>1., rounder union here.\n float n=mod(m,ss)/ss;\n#else\n //float m=a+b;//without seesaw\n float n=mod(a+b,ss)/ss;//seesaw gradient\n float m=n;\n#endif\n a=mod(a,ss)/ss;b=mod(b,ss)/ss;\n if(m<.5)n+=.5;\n fragColor = vec4(n,a*.5,b*.5,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}