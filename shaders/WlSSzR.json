{
    "Shader": {
        "info": {
            "date": "1564715650",
            "description": "added a 3rd dimension to the complex multiply, like a quaternion with a value chopped off.",
            "flags": 0,
            "hasliked": 0,
            "id": "WlSSzR",
            "likes": 3,
            "name": "Raymarched Mandelbrot",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "mandelbrot"
            ],
            "usePreview": 0,
            "username": "snerp",
            "viewed": 404
        },
        "renderpass": [
            {
                "code": "vec2 complexMult(vec2 a, vec2 b) {\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec3 complexMult3(vec3 a, vec3 b) {\n\treturn vec3(a.x*b.x - a.y*b.y - a.z*b.z, a.x*b.y + a.y*b.x, a.x*b.z + a.z*b.x);\n}\n\nfloat testMandelbrotDist(vec3 coord3d) {\n    // turn this up to reduce visual noise\n    const int iterations = 92;\n\tvec3 testPoint = vec3(0,0,0);\n    vec3 distTest = vec3(0,0,0);\n\tfor (int i = 0; i < iterations; i++){\n        distTest = 2.0*complexMult3(testPoint, distTest) + vec3(1,0,0);\n\t\ttestPoint = complexMult3(testPoint,testPoint) + coord3d;\n        float ndot = dot(testPoint,testPoint);\n\t\tif (ndot > 1024.0) {\n            return 0.5 * sqrt(ndot/dot(distTest,distTest))*log(ndot);\n\t\t}\n\t}\n\treturn -0.1;\n}\n\nmat3 rotmat(vec3 axis, float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec3 getRay(vec2 uv) {\n    uv = (0.1 + 0.6*abs(sin(iTime*0.1)))*(uv * 2.0 - 1.0) * vec2(1.0, iResolution.y / iResolution.x);\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.0));\n    vec2 coord = vec2(6.0 * iMouse.x/ iResolution.x, 3.0 * (0.5+ iMouse.y/iResolution.y));\n    if (iResolution.x < 500.0) {\n        coord = vec2(-4.33,-3.0);\n    }\n\treturn rotmat(\n        vec3(0.0, 1.0, 0.0),\n        coord.x\n    ) * rotmat(\n        vec3(1.0, 0.0, 0.0), \n        coord.y \n    ) * proj;\n}\nconst float minDist = 0.5;\nconst float maxDist = 4.5;\nfloat rayMarchMandelbrot(vec3 eye, vec3 ray) {\n    float iterDval = 0.01;\n    float distance = minDist;\n    const int limit = int(maxDist/0.01);\n    for (int i = 0; i < limit; i++) {\n     \tfloat testval =  testMandelbrotDist(eye + ray*distance);\n        if (iterDval < 0.001 || abs(testval) < 0.000001) {\n         \treturn distance;   \n        }\n        if (testval > 0.0) {\n         \tdistance = distance + iterDval;   \n        } else {\n            iterDval = iterDval * 0.5;\n            distance = distance - iterDval;\n        }\n    }\n    return distance;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    const float es = 0.02;\n    return normalize(vec3(\n        testMandelbrotDist(vec3(p.x + es, p.y, p.z)) - testMandelbrotDist(vec3(p.x - es, p.y, p.z)),\n        testMandelbrotDist(vec3(p.x, p.y + es, p.z)) - testMandelbrotDist(vec3(p.x, p.y - es, p.z)),\n        testMandelbrotDist(vec3(p.x, p.y, p.z  + es)) - testMandelbrotDist(vec3(p.x, p.y, p.z - es))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 fragment = fragCoord/iResolution.xy;\n    vec3 ray = getRay(fragment);\n\tvec3 camPos = getRay(vec2(0.5,0.5)) * -3.0;\n    float dist = rayMarchMandelbrot(camPos, ray);\n    if (dist > minDist && dist < maxDist){\n        vec3 lightpos = vec3(-.5,-1,.5);\n        vec3 lightCol = vec3(.98,.4,.5);\n        vec3 normal = estimateNormal(camPos + ray * dist);\n        float intensity = dot(lightpos, normal);        \n    \tfragColor = vec4(lightCol * intensity, 1.0);\n    } else {\n        fragColor = vec4(vec3(0.3*(dist)), 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}