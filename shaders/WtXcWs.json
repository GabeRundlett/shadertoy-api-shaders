{
    "Shader": {
        "info": {
            "date": "1594970077",
            "description": "Based on the ideas in Nelson and Segerman's \"Visualizing Hyperbolic Honeycombs\": [url]https://arxiv.org/abs/1511.02851[/url]. See also: [url]http://bulatov.org/math/180110/index.html[/url]\n\nSee code header for details & controls.",
            "flags": 48,
            "hasliked": 0,
            "id": "WtXcWs",
            "likes": 21,
            "name": "Hyperbolic Honeycomb Sections",
            "published": 3,
            "tags": [
                "honeycomb",
                "hyperbolic",
                "horosphere"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 744
        },
        "renderpass": [
            {
                "code": "/////////////////////////////////////////////////////////////////////////////////\n//\n// Hyperbolic Honeycomb Sections, mla, 2020.\n//\n// Show a horospheric section through a hyperbolic honeycomb.\n//\n// Based on the ideas in Nelson and Segerman's \"Visualizing Hyperbolic\n// Honeycombs\": [url]https://arxiv.org/abs/1511.02851[/url]. See also:\n// [url]http://bulatov.org/math/180110/index.html[/url]\n//\n// Show a section through the halfspace model of hyperbolic space,\n// parallel to the boundary (so it's a horosphere). Reflect or invert\n// points of the section (after transforming to the ball model) in the\n// sides of a Goursat tetrahedron to form a honeycomb.\n//\n// Coloring just indicates the number of inversion/reflection steps\n// needed to reach the fundamental region. Keys 1-4 ('acontrol' in the\n// code) determine which mirrors count towards the total (so it's\n// roughly which mirrors are activated in the Dynkin diagram).\n//\n// Controls:\n// <mouse>,<up>,<down>: zoom and transform\n// <pageup>,<pagedown>: select tetrahedron type\n// <left>,<right>: select tetrahedron subtype\n// 1-4: active mirrors (see above)\n// 5-8: line selection\n// d: dark edges\n// x: show parameters\n// z: auto zoom\n//\n/////////////////////////////////////////////////////////////////////////////////\n\nint AA = 2;\nfloat scale = 2.2;\nfloat cycletime = 10.0;\n\nbvec4 acontrol = bvec4(1,0,0,0);\nbvec4 bcontrol = bvec4(1,0,0,0);\nbool uselocalscale = false;\n\nvec3 A,B,D; // Planes\nvec4 C;     // Inversion sphere\n\nvoid init(ivec3 PQR) {\n  //   A B C D\n  //   o-o-o-o\n  //    P Q R\n  // Construct the Goursat tetrahedron, faces A,B,C,D, with opposite\n  // vertexes a,b,c,d. Vertex c is at origin with adjacent faces A,B,D\n  // (Euclidean) planes. Face C opposite the origin is spherical with\n  // centre C.xyz, radius C.w. c can't be an ideal point (since it's\n  // the origin), but the other points can be.\n  // Uses x = 0 and z = 0 as planes, so can use a more efficient\n  // fold: p.xz -> abs(p.xz) if we like.\n  // icos(P) = cos(PI/P) etc. for integer P.\n  int P = PQR[0], Q = PQR[1], R = PQR[2];\n  A = vec3(0,0,1);\n  B = vec3(0,isin(P),-icos(P));\n  D = vec3(1,0,0);\n\n  // Construct sphere of inversion with correct dihedral angles.\n  // Plane face through origin, normal n, sphere centre c, radius r:\n  // cos(theta) = c.n/r (proof left to reader).\n  // centre is on z = 0 as must be orthogonal to A (the z-axis).\n  float r = 1.0/icos(R);\n  float k = r*icos(Q)/isin(P);\n  vec3 centre = vec3(1,k,0);\n\n  // And rescale to fit in the unit ball\n  C = vec4(centre,r)/sqrt(dot(centre,centre)-r*r);\n}\n\nbool tryreflect(inout vec3 p, vec3 n) {\n  float k = dot(p,n);\n  if (k >= 0.0) return false;\n  p -= 2.0*k*n;\n  return true;\n}\n\nbool tryreflect(inout vec3 p, vec4 c) {\n  // This reflection is an inversion\n  vec3 centre = c.xyz; float r = c.w;\n  vec3 p1 = p-centre;\n  float k = r*r/dot(p1,p1);\n  if (k < 1.0) return false;\n  p = k*p1;\n  p += centre;\n  return true;\n}\n\nfloat facedist(vec3 p, vec3 n) {\n  return abs(dot(p,n));\n}\n\nfloat facedist(vec3 p, vec4 c) {\n  vec3 centre = c.xyz; float r = c.w;\n  return abs(distance(p,centre)-r);\n}\n\nvec3 palette[] = vec3[](vec3(1,0,0),vec3(1,1,0),vec3(0,1,0),\n                        vec3(0,1,1),vec3(0,0,1),vec3(1,0,1));\n \nvec3 getcolor(int index) {\n  int ncolors = palette.length();\n  if (key(CHAR_M)) return vec3(float(index%ncolors)/float(ncolors-1)); // Monochrome\n  return mix(vec3(1),palette[index%ncolors],0.8);\n}\n\nvec3 pcolor(vec2 z, vec2 mouse) {\n  // Mouse transform\n  invert(z,mouse,1.0);\n  invert(z,vec2(0),1.0);\n\n  // To half plane: p.z is height above ideal boundary\n  float t = 1.0;\n  if (!key(CHAR_Z)) t = fract(iTime/cycletime);\n  vec3 p = vec3(z,exp(-10.0*t));\n  // Invert to the Poincare ball (Cayley transform)\n  invert(p,vec3(0,0,1),2.0);\n  invert(p,vec3(0),1.0);\n\n  int maxsteps = 50, numsteps;\n  for (numsteps = 0; numsteps < maxsteps; numsteps++) {\n    for (int i = 0; i < maxsteps; i++) {\n      // Apply subset of reflections completely first\n      if ((acontrol[0] || !tryreflect(p,A)) &&\n          (acontrol[1] || !tryreflect(p,B)) &&\n          (acontrol[2] || !tryreflect(p,C)) &&\n          (acontrol[3] || !tryreflect(p,D))) break;\n    }\n    // Then the remainder\n    if ((!acontrol[0] || !tryreflect(p,A)) &&\n        (!acontrol[1] || !tryreflect(p,B)) &&\n        (!acontrol[2] || !tryreflect(p,C)) &&\n        (!acontrol[3] || !tryreflect(p,D))) break;\n  }\n  if (numsteps == maxsteps) return vec3(0);\n  vec3 col = getcolor(numsteps);\n  float d = 1e8;\n  if (!bcontrol[0]) d = min(d,facedist(p,A));\n  if (!bcontrol[1]) d = min(d,facedist(p,B));\n  if (!bcontrol[2]) d = min(d,facedist(p,C));\n  if (!bcontrol[3]) d = min(d,facedist(p,D));\n  float localscale = 1.0-dot(p,p);\n  float lwidth = 0.01;\n  if (uselocalscale) lwidth *= localscale;\n  if (key(CHAR_D)) col = mix(vec3(0),col,smoothstep(0.0,2.0*lwidth,d));\n  else col = mix(col,vec3(0),0.4*smoothstep(0.5*lwidth,lwidth,d));\n  return col;\n}\n\nint pmin(int min, int a) {\n  if (a == 0) return a;\n  else return a+min-1;\n}\n\nconst int ntypes = 7;\nconst int nsubtypes = 5;\n// Select a tetrahedron. pmin ensures that an angle parameter is\n// either 0 (meaning infinity) or is >= some minimum value.\nivec3 getPQR(int type, int subtype) {\n  int P,Q,R;\n  int index = 0;\n  if (type == index++) P = 3, Q = 4, R = pmin(4,subtype);\n  else if (type == index++) P = 5, Q = 3, R = pmin(4,subtype);\n  else if (type == index++) P = 3, Q = 6, R = pmin(3,subtype);\n  else if (type == index++) P = 5, Q = 4, R = pmin(3,subtype);\n  else if (type == index++) P = 3+subtype, Q = 0, R = 0; // Infinities all round\n  else if (type == index++) P = 4, Q = 4, R = pmin(3,subtype);\n  else if (type == index++) P = 6, Q = 4, R = pmin(3,subtype);\n  else if (type == index++) P = 3, Q = 5, R = pmin(6,subtype);\n  return ivec3(P,Q,R);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  acontrol[0] = !key(CHAR_0+1);\n  acontrol[1] = key(CHAR_0+2);\n  acontrol[2] = key(CHAR_0+3);\n  acontrol[3] = key(CHAR_0+4);\n  bcontrol[0] = key(CHAR_0+5);\n  bcontrol[1] = key(CHAR_0+6);\n  bcontrol[2] = key(CHAR_0+7);\n  bcontrol[3] = key(CHAR_0+8);\n  float zoom = exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  vec2 mouse = iMouse.x <= 0.0 ? vec2(0)\n    : vec2((2.0*iMouse.xy-iResolution.xy)/iResolution.y);\n  mouse *= scale;\n  int type = imod(keycount(KEY_PAGE_DOWN)-keycount(KEY_PAGE_UP),ntypes+1);\n  int subtype = imod(keycount(KEY_RIGHT)-keycount(KEY_LEFT),nsubtypes);\n  if (type != 0) {\n    type = type-1;\n  } else {\n    int t = int(iTime/cycletime);\n    type = t/nsubtypes%ntypes;\n    subtype = t%nsubtypes;\n  }\n  ivec3 PQR = getPQR(type,subtype);\n  init(PQR);\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = vec2((2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y);\n      z *= scale*zoom;\n      col += pcolor(z,mouse);\n    }\n  }\n  col /= float(AA*AA);\n  if (key(CHAR_X)) {\n    vec2 z = fragCoord.xy;\n    // Show indication of parameters\n    int N = ntypes+1+nsubtypes+1+4;\n    vec2 xy = float(N)*z/iResolution.x;\n    xy.x -= 0.5;\n    float gridx = round(xy.x);\n    int i = int(gridx);\n    vec3 dotcol;\n    if (i == type ||\n        i == ntypes+1+subtype ||\n        i == ntypes+1+nsubtypes+1+0 && acontrol[0] ||\n        i == ntypes+1+nsubtypes+1+1 && acontrol[1] ||\n        i == ntypes+1+nsubtypes+1+2 && acontrol[2] ||\n        i == ntypes+1+nsubtypes+1+3 && acontrol[3]) {\n      dotcol = vec3(1);\n    } else if (i != ntypes && i != ntypes+1+nsubtypes) {\n      dotcol = vec3(0);\n    } else {\n      dotcol = col;\n    }\n    col = mix(dotcol,col,smoothstep(0.3,0.33,distance(xy, vec2(gridx,1.0))));\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }     \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n// common\n////////////////////////////////////////////////////////////////////////////////\n\nfloat PI = 3.141592654;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nint imod(int n, int m) {\n  // glsl % undefined for -ve arguments\n  if (n < 0) return m-1-(-n-1)%m;\n  else return n%m;\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat COS[] =\n  // Don't trust cos on the GPU to be accurate enough: cos(PI/n) for n = 0..31\n  // Note that we have COS[0] = 1 = cos(PI/infinity)\n  float[](1.0,-1.0,0.0,0.5,0.7071067812,0.8090169944,0.8660254038,\n          0.9009688679,0.9238795325,0.9396926208,0.9510565163,0.9594929736,\n          0.9659258263,0.9709418174,0.9749279122,0.9781476007,0.9807852804,\n          0.9829730997,0.984807753,0.9863613034,0.9876883406,0.9888308262,\n          0.9898214419,0.990685946,0.9914448614,0.9921147013,0.9927088741,\n          0.9932383577,0.9937122099,0.9941379572,0.9945218954,0.9948693234);\n\nfloat icos(int p) {\n  if (p >= COS.length()) return cos(PI/float(p));\n  return COS[p];\n}\n                        \nfloat isin(int p) {\n  if (p >= COS.length()) return sin(PI/float(p));\n  return sqrt(1.0-COS[p]*COS[p]); // Let's hope sqrt(0) = 0\n\n}\n\nvoid invert(inout vec2 z, vec2 centre, float r2) {\n  z -= centre; z *= r2/dot(z,z); z += centre;\n}\n\nvoid invert(inout vec3 z, vec3 centre, float r2) {\n  z -= centre; z *= r2/dot(z,z); z += centre;\n}\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}