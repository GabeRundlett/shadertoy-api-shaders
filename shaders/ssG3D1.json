{
    "Shader": {
        "info": {
            "date": "1633545982",
            "description": "My participation in the JFIG 2021 render contest.",
            "flags": 32,
            "hasliked": 0,
            "id": "ssG3D1",
            "likes": 1,
            "name": " [ConcoursJFIG2021] JellyFish",
            "published": 3,
            "tags": [
                "raymarching",
                "spheretracing",
                "jellyfish",
                "outline",
                "concoursjfig2021"
            ],
            "usePreview": 0,
            "username": "PlathC",
            "viewed": 422
        },
        "renderpass": [
            {
                "code": "const float OutlineSize = 3.;\n\n// Blur by mAlk\n// Reference: https://www.shadertoy.com/view/Ms2Xz3\nvec4 blur (in vec2 Coord, in sampler2D Tex, in float MipBias)\n{\n\tvec2 TexelSize = MipBias/iChannelResolution[0].xy;\n    \n    vec4  Color = texture(Tex, Coord, MipBias);\n    Color += texture(Tex, Coord + vec2(TexelSize.x,0.0), MipBias);    \t\n    Color += texture(Tex, Coord + vec2(-TexelSize.x,0.0), MipBias);    \t\n    Color += texture(Tex, Coord + vec2(0.0,TexelSize.y), MipBias);    \t\n    Color += texture(Tex, Coord + vec2(0.0,-TexelSize.y), MipBias);    \t\n    Color += texture(Tex, Coord + vec2(TexelSize.x,TexelSize.y), MipBias);    \t\n    Color += texture(Tex, Coord + vec2(-TexelSize.x,TexelSize.y), MipBias);    \t\n    Color += texture(Tex, Coord + vec2(TexelSize.x,-TexelSize.y), MipBias);    \t\n    Color += texture(Tex, Coord + vec2(-TexelSize.x,-TexelSize.y), MipBias);    \n\n    return Color/9.0;\n}\n\n// Bloom effect by mAlk\n// https://www.shadertoy.com/view/Ms2Xz3    \nvec4 bloom(in vec4 color, in vec2 uv, in sampler2D tex) {\n    const float BlurSize  = 3.;\n    const float Threshold = .5; \n    const float Intensity = .5;\n    vec4 highlight = clamp(blur(uv, iChannel0, BlurSize) - Threshold, 0., 1.) * 1. / (1. - Threshold);    \n    return 1. - (1. - color) * (1. - highlight * Intensity); //Screen Blend Mode\n}\n\n// Outline computation based on background encoding done in Buffer A background function\nfloat outline(vec2 fragCoord) {\n    vec2 uv = fragCoord;\n            \n    float wStep = 1. / iResolution.x;\n    float hStep = 1. / iResolution.y;\n    \n    float finalValue = 0.;\n    vec4 originalColor = texture(iChannel0, uv);\n\n    if (originalColor.a != BackgroundEncodedValue)\n        return 0.f;\n        \n    for(float i = -OutlineSize; i <= OutlineSize; i++) {\n     \tfor(float j = -OutlineSize; j <= OutlineSize; j++) {\n            vec2 newTextureCoordinates = vec2(uv.x + (i * wStep), uv.y + (j * hStep));\n            vec4 otherPixel = texture(iChannel0, newTextureCoordinates);\n            finalValue = max(finalValue, mix(1., 0., float(otherPixel.a == BackgroundEncodedValue)));\n            \n            if(finalValue > 0.) \n                break;\n        }\n    }\n    \n    float vignet = (0.4 - length(uv - 0.5));\n    return finalValue * vignet;\n}\n\nvec4 combineOutline(vec4 color, float outline) {\n    return clamp( outline * (color + vec4(0.3, 0., 0.7, 0.))  + color * (1. - outline), 0., 1.);\n}\n\nvec3 gammaCorrection(vec3 color, float gamma) {\n    return pow(color, vec3(1. / gamma));\n}\n\nvoid mainImage0( out vec4 fragmentColor, in vec2 fragmentCoordinates ) {\n    vec2 uv = fragmentCoordinates/iResolution.xy;\n    \n    float outlineValue = outline(uv);\n    vec4 color = combineOutline(texture(iChannel0, uv), outlineValue);\n    \n    color = bloom(color, uv, iChannel0);\n    \n    float vignet = (1. - length(uv - 0.5));\n    fragmentColor = vignet * color;\n}\n\n// Anti-aliasing By Fabrice Neyret\n// === easy adaptive sampling. === https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n//                           more: https://www.shadertoy.com/results?query=easy+adaptive+sampling\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n      //O.r++;                        // uncomment to see where the oversampling occurs\n    }\n    O = vec4(gammaCorrection(O.rgb, 2.2), 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float Pi                     = 3.1415926;\nconst float MaxDistance            = 10.;\nconst float MaxDistanceInVolume    = 6.;\nconst float StepSize               = 2e-2;\nconst float Threshold              = 1e-3;\nconst float StartingT              = 2.;\nconst float MaxSteps               = 60.;\nconst float BackgroundEncodedValue = 0.123;\n\n// Reference: https://stackoverflow.com/a/61262594\nconst float MaxFloat = intBitsToFloat(0x7F800000);\n\n#define DEG2RAD(deg) ((deg) * Pi / 180.)\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct RayClosestObjectInformation {\n    float d;\n    int matId;\n    bool inVolume;\n};\n\nstruct PhongMaterial {\n    vec3 ambient;\n    vec3 specular;\n    vec3 diffuse;\n    float shininess;\n};\n\nstruct VolumeMaterial {\n    float coefficient;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n    float intensity;\n};\n\nmat3 xRotationMatrix(float angle) {\n    return mat3(1., 0.,          0.,\n                0., cos(angle), -sin(angle),\n                0., sin(angle),  cos(angle));\n}\n\nmat3 yRotationMatrix(float angle) {\n    return mat3( cos(angle), 0., sin(angle),\n                 0.,         1., 0.,\n                -sin(angle), 0., cos(angle));\n}\n\n// Beer-Lambert's law\n// Reference: https://www.scratchapixel.com/lessons/advanced-rendering/volume-rendering-for-artists\nfloat beerLambert(float volumeCoefficient, float lightDistanceInVolume) {\n    return exp(-lightDistanceInVolume * volumeCoefficient);\n}\n\n// Signed distance function defining 3D primitives and operations by Inigo Quilez\n// Reference: https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 point, vec3 spherePosition, float sphereRadius) {\n    return length(point - spherePosition) - sphereRadius;\n}\n\nfloat sdEllipsoid( in vec3 point, in vec3 center, in vec3 radius ) {\n    vec3 p = point - center;\n    float k0 = length(p / radius);\n    float k1 = length(p / (radius * radius));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nvec3 opRepLim(vec3 p, float c, vec3 l) {\n    return p-c*clamp(round(p/c),-l,l);\n}\n\n// Smooth mininum by Inigo Quilez\n// Reference: https://iquilezles.org/articles/smin\nfloat sminCubic(float a, float b, float k){\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// BÃ©zier signed distance by Inigo Quilez\n// Reference: https://www.shadertoy.com/view/ld3Gz2\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) {\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec4 sdBezier(vec3 p, vec3 a, vec3 b, vec3 c) {\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v =          ( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n}\n\n// Blobby Cross SDF by Inigo Quilez\n// Reference: https://www.shadertoy.com/view/NssXWM\nfloat sdBlobbyCross( in vec2 pos)\n{\n    const float he = 1.;\n    const float ra = 0.5;\n\n    pos *= 2.;\n    pos = abs(pos);\n    pos = vec2(abs(pos.x - pos.y), 1.0 - pos.x - pos.y) / sqrt(2.0);\n\n    float p = (he - pos.y - 0.25 / he) / (6.0 * he);\n    float q = pos.x / (he * he * 16.0);\n    float h = q * q - p * p * p;\n    \n    float x;\n    if( h > 0.0 ) { float r = sqrt(h); x = pow(q+r,1.0/3.0)-pow(abs(q-r),1.0/3.0)*sign(r-q); }\n    else          { float r = sqrt(p); x = 2.0*r*cos(acos(q/(p*r))/3.0); }\n    x = min(x, sqrt(2.0) / 2.0);\n    \n    vec2 z = vec2(x, he * (1.0 - 2.0 * x * x)) - pos;\n    return abs(length(z) * sign(z.y) - ra) < 0.1 ? 1. : 0.;\n}\n\n\n// JFIG texture by haqreu\n// https://www.shadertoy.com/view/wsXyD8\n#define JFIGW 32u\n#define JFIGH 18u\nuint[] jfig_bitfield = uint[]( 0x0u,0x0u,0x0u,0xf97800u,0x90900u,0xc91800u,0x890900u,0xf90900u,0x180u,0x0u);\nbool jfigTexture(vec2 pos) {\n    pos = pos * vec2(JFIGW, JFIGH);\n    uint id = uint(pos.x) + (JFIGH-1u-uint(pos.y))*JFIGW;\n    if (id>=JFIGW*JFIGH) return false;\n    return 0u != (jfig_bitfield[id/32u] & (1u << (id&31u)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "Light light = Light(vec3(0., 1.5, 0.), vec3(0.6, 0.3, 0.6), 2.);\n\nVolumeMaterial BellVolumeMaterial = VolumeMaterial(0.2);\nconst float BellTextureDepth = Threshold * 50.F;\n\nconst int bellMatId = 0; \nconst int tentacleMatId = bellMatId + 1;\nconst int subBellMatId = tentacleMatId + 1;\n\nPhongMaterial bellMat     = PhongMaterial(vec3(.4, 1., 1.), vec3(1.), vec3(1.), 100.);\nPhongMaterial tentacleMat = PhongMaterial(vec3(.4, .4, .8), vec3(1.), vec3(1.), 100.);\nPhongMaterial subBellMat  = PhongMaterial(vec3(.9, .3, 1.), vec3(0., .9, .9), vec3(0., 1., 1.), 225.);\n\nRayClosestObjectInformation jellyFish(vec3 point) {\n    RayClosestObjectInformation outInfo;\n    \n    // Bell\n    float xBellSize   = smoothstep(0.f, 1.f, (sin(iTime * 3.) + 1.) * 0.5) * 0.25 + 1.;\n    float yBellSize   = smoothstep(0.f, 1.f, (cos(iTime * 3.) + 1.) * 0.5) * 0.25 + 1.;\n    vec3 bellSize     = vec3(xBellSize, yBellSize, xBellSize);\n    vec3 bellPosition = vec3(0.f, 0.5 * -sin(iTime * 2.5) + 0.3, 0.);\n    \n    float bell = MaxFloat;\n    if( point.y > bellPosition.y - 0.4) {\n        bell  = sdEllipsoid(point, bellPosition - vec3(0., 0.4, 0.),  bellSize);\n        bell += sin(point.x * 5.f) * sin(point.y * 5.) * sin(point.z * 5.) * 0.005;\n    }\n    \n    outInfo.d = bell;\n    outInfo.matId = bellMatId;\n    \n    // Start ray marching to avoid artifacts\n    outInfo.inVolume = (bell < Threshold * 3.);\n\n    // Bell content\n    float subBell = point.y < bellPosition.y - 0.35 ? \n        MaxFloat : \n        sdEllipsoid(point, bellPosition - vec3(0., 0.4, 0.),  bellSize / vec3(1.1, 2., 1.1));\n    \n    subBell -= 0.1 * sin(point.x * 3.) * sin(point.y * 10.)  * sin(point.z * 3.);\n    if((outInfo.inVolume && subBell < Threshold) || subBell < outInfo.d) {\n        outInfo.d = subBell;\n        outInfo.matId = subBellMatId;\n    }\n    \n    if(!outInfo.inVolume){\n        // Small arms\n        const float tentacleNumber = 13.;\n        vec3 tentaclePoint = point - bellPosition;\n\n        float bellRadius = bellSize.x - 0.3;\n        tentaclePoint = point - bellPosition;\n        for (float i = 0.; i < tentacleNumber; i++) {\n            vec3 currentTentacle = vec3(0.);\n            currentTentacle.x += bellRadius * cos((2. * Pi / tentacleNumber) * i);\n            currentTentacle.y -= 0.5;\n            currentTentacle.z += bellRadius * sin((2. * Pi / tentacleNumber) * i);\n\n            vec3 invBellDirection = normalize(tentaclePoint - bellPosition);\n\n            vec3 startingPoint = currentTentacle + vec3(0., 0.1, 0.);\n            vec3 middlePoint   = currentTentacle - vec3(0., 0.1, 0.);\n            vec3 finalPoint    = currentTentacle + 0.3 * vec3(invBellDirection.x, 0.6 * sin(iTime * 2.5) - 0.5, invBellDirection.z);\n            \n            // Based on Inigo Quilez's snail\n            vec4 tentacleBit = sdBezier(tentaclePoint, startingPoint, middlePoint, finalPoint);\n            float d3 = tentacleBit.x;\n            d3 -= 0.04 - 0.01*(tentacleBit.y);\n            float tentacle = d3;\n\n            tentacle = sminCubic(tentacle, sdSphere(tentaclePoint, finalPoint, 0.03), 0.1 );\n\n            if(tentacle < outInfo.d) {\n                outInfo.d = tentacle;\n                outInfo.matId = tentacleMatId;\n            }\n        }\n    }\n    \n    return outInfo;\n}\n\nRayClosestObjectInformation distanceFromScene(vec3 point){\n    return jellyFish(opRepLim(point, 4., vec3(1., 0., 1.)));\n}\n\n// Normal estimation by Inigo Quilez\n// Reference: https://iquilezles.org/articles/normalsSDF\nvec3 estimateNormal(vec3 p ) {\n    const float eps = 0.00001; // or some other value\n    const vec2 h = vec2(eps, 0.);\n    return normalize( vec3(distanceFromScene(p+h.xyy).d - distanceFromScene(p-h.xyy).d,\n                           distanceFromScene(p+h.yxy).d - distanceFromScene(p-h.yxy).d,\n                           distanceFromScene(p+h.yyx).d - distanceFromScene(p-h.yyx).d ) );\n}\n\nvec4 background(vec3 dir) {\n    vec3 topColor    = vec3(0., .1, .5);\n    vec3 bottomColor = vec3(0., 0., .2);\n    vec3 finalColor  = mix(bottomColor, topColor, vec3(dir.y) * 2. );\n    \n    // Encode background hit to perform outline computation\n    return vec4(finalColor, BackgroundEncodedValue);\n}\n\n// Phong shading\nvec4 illuminate(vec3 rayOrigin, vec3 point, vec3 normal, vec4 backgroundColor, PhongMaterial material) {\n    vec3 lightDirection = normalize(light.position - point);\n    vec3 viewerDirection = normalize(rayOrigin - point);\n\n    vec3 halfWay = normalize(viewerDirection + lightDirection);\n    float lightDotNormal = max(dot(lightDirection, normal), 0.);\n    \n    vec3 diffuse = light.color * material.diffuse * lightDotNormal;\n    float specularAngle = max(dot(normal, halfWay), 0.);\n    float scaledSpecular = pow(abs(specularAngle), material.shininess);\n    vec3 specular = light.color * material.specular * scaledSpecular;\n    return vec4(light.intensity * (light.color * material.ambient + diffuse + specular), 1.);\n}\n\nvec4 volumeRender(vec3 rayOrigin, vec3 point, vec3 normal, float distanceInVolume, vec4 backgroundColor, bool onSurface) {\n    vec3 lightDirection = light.position - point;\n    float lightDistance = length(lightDirection); \n    lightDirection = normalize(lightDirection);\n    \n    // Compute light path within the volume at the current point\n    RayClosestObjectInformation handler;\n    handler.inVolume = true;\n    float lightDistanceInVolume = 0.;\n    for(; lightDistanceInVolume < lightDistance && handler.inVolume; lightDistanceInVolume += StepSize) {\n        handler = distanceFromScene(lightDistanceInVolume * lightDirection + point);\n    }\n    \n    float surfaceWeight = max(1., float(onSurface) * 5.);\n    float transmittance = beerLambert(BellVolumeMaterial.coefficient, max(lightDistanceInVolume - distanceInVolume, 0.));\n    \n    vec3 volumeColor = transmittance * light.color * light.intensity * max(dot(lightDirection, normal), 0.);\n    vec3 opaqueColor = surfaceWeight * (1. - transmittance) * illuminate(rayOrigin, point, normal, backgroundColor, bellMat).rgb;\n    return vec4(volumeColor + opaqueColor, 1.);\n}\n\nfloat applyTexture(vec3 normal) {\n    float finalTexturevalue = 0.;\n    vec3 scaledNormal = normal * 1.6;\n    finalTexturevalue += sdBlobbyCross( scaledNormal.xz ) * 0.5;\n\n    const float TextureNumber = 3.;\n    for(float i = 0.; i < TextureNumber; i++) {\n        mat3 yRotation = yRotationMatrix(DEG2RAD(cos(iTime) * 190. + (360. / TextureNumber * i)));\n        scaledNormal = normal * yRotation;\n        if(scaledNormal.z + sin(iTime) * .3 < -.9) {\n            vec2 uv = ((scaledNormal * 1.8 + 1.) / 2.).xy;\n            finalTexturevalue += jfigTexture(uv) ? 1. : 0.;\n        }\n    }\n    \n    return finalTexturevalue;\n}\n\nvec4 shade(vec3 position, Ray ray, RayClosestObjectInformation objInfo, vec4 backgroundColor) {\n    vec3 normal = normalize(estimateNormal(position));\n    vec4 outputColor = backgroundColor;\n    \n    // Volume rendering\n    if(objInfo.matId == bellMatId) {\n        vec3 currentPosition = position;\n        float stepNumber = 0.;\n        bool refracted = false;\n        \n        for(float t = 0.; t < MaxDistanceInVolume && stepNumber++ < MaxSteps * 2.; ) {\n            currentPosition = position + t * ray.direction;\n            objInfo = distanceFromScene(currentPosition);\n            \n            if (objInfo.inVolume) {\n                if(!refracted) {\n                    ray.direction = normalize(refract(ray.direction, normal, 1.05));\n                    refracted = true;\n                }\n                \n                normal = normalize(estimateNormal(currentPosition));\n                \n                if(objInfo.matId == bellMatId) {\n                    float pointWeight = 0.035;\n                    \n                    bool onSurface = abs(objInfo.d) < 0.1;\n                    // Bell texturing\n                    if(abs(objInfo.d) < 0.06) {\n                        outputColor += applyTexture(normal);\n                        pointWeight *= 2.;\n                    }\n                    \n                    vec4 currentColor = volumeRender(ray.origin, currentPosition, normal, t, outputColor, onSurface);\n\n                    outputColor += pointWeight * currentColor;\n                    t += StepSize;\n                } \n                else {\n                    return 0.5 * outputColor + 0.5 * illuminate(ray.origin, currentPosition, normal, outputColor, subBellMat);\n                }\n            }\n            else {\n                t += objInfo.d;\n            }\n        }\n        return outputColor;\n        \n    }\n    else {\n        PhongMaterial material;\n        \n        if(objInfo.matId == tentacleMatId)\n            material = tentacleMat;\n        else if(objInfo.matId == bellMatId)\n            material = bellMat;\n        else if(objInfo.matId == subBellMatId)\n            material = subBellMat;\n            \n        // Opaque rendering\n        vec3 ro = position;\n        vec3 rd = normalize(position - light.position);\n\n        outputColor = (mix(outputColor, illuminate(ray.origin, position, normal, outputColor, material), 1. / length(ray.origin - position)));\n\n        return outputColor;\n    }\n}\n\nRay computeRay(vec2 fragmentCoordinates) {\n\tvec2 uv = (2. * ((fragmentCoordinates.xy) / iResolution.xy) - 1.);\n\n    // Pinhole model\n    vec3 pixelCamera = vec3(\n        uv.x * tan(DEG2RAD(90. / 2.)),\n        uv.y * tan((iResolution.y / iResolution.x) * DEG2RAD(90.) / 2.),\n        1.\n    );\n\n    vec3 target  = vec3(0.);\n    float xAngle = sin(iTime) * (20.);\n    float yAngle = cos(iTime) * (180.);\n    if( iMouse.z > 0.01) {\n        xAngle = iMouse.y;\n        yAngle = iMouse.x;\n    }\n    \n    Ray ray = Ray(vec3(0., .25, -4.), normalize(pixelCamera - target));\n\n    mat3 camRotation  = yRotationMatrix(DEG2RAD(yAngle));\n    camRotation      *= xRotationMatrix(DEG2RAD(xAngle));\n    ray.origin       *= camRotation;\n    ray.direction    *= camRotation;\n    \n    return ray;\n}\n\nvec4 render(vec2 fragmentCoordinates) {\n    Ray ray = computeRay(fragmentCoordinates);\n    \n    vec3 currentPosition = ray.origin;\n    float t              = StartingT;\n    float maxDistance    = StartingT + MaxDistance;\n    \n    bool  hit        = false;\n    float stepNumber = 0.;\n    float radius     = 0.;\n        \n    vec4 backgroundColor = background(ray.direction);\n    vec4 outputColor     = backgroundColor;\n    \n    RayClosestObjectInformation objInfo = RayClosestObjectInformation(MaxFloat, -1, false);\n    while (t < maxDistance && stepNumber++ < MaxSteps) {\n        currentPosition = ray.origin + t * ray.direction;\n        objInfo = distanceFromScene(currentPosition);\n        radius = abs(objInfo.d);\n        if(radius <= Threshold * t || objInfo.inVolume) {\n            hit = true;\n            break;\n        }\n        \n        t += radius;\n    }\n    \n    // Avoid to compute the shade function within the \n    if(hit) outputColor = shade(currentPosition, ray, objInfo, outputColor);\n    \n    // Based on https://www.shadertoy.com/view/MlXGzr\n    return vec4(mix(outputColor.xyz * 1.5, backgroundColor.xyz + .025, 1. - beerLambert(t * t, .08)), outputColor.w);\n}\n\nvoid mainImage( out vec4 fragmentColor, in vec2 fragmentCoordinates ) {\n    fragmentColor = render(fragmentCoordinates);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}