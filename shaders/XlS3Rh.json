{
    "Shader": {
        "info": {
            "date": "1426732345",
            "description": "gems",
            "flags": 0,
            "hasliked": 0,
            "id": "XlS3Rh",
            "likes": 2,
            "name": "#gemsquad",
            "published": 3,
            "tags": [
                "raymarch",
                "sphere",
                "efx"
            ],
            "usePreview": 0,
            "username": "objelisks",
            "viewed": 543
        },
        "renderpass": [
            {
                "code": "const float EPSILON = 0.0001;\nconst float E = 2.71828;\nconst float RT2 = 0.7071067;\nconst float PI = 3.1415;\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n// helper function to create a 3d rotation matrix.\nmat3 rotateX(float angle) {\n    float ca = cos(angle);\n    float sa = sin(angle);\n\treturn mat3(1, 0, 0,  0, ca, -sa,  0, sa, ca);\n}\n\n// helper function to create a 3d rotation matrix.\nmat3 rotateY(float angle) {\n    float ca = cos(angle);\n    float sa = sin(angle);\n\treturn mat3(ca, 0, sa,  0, 1, 0,  -sa, 0, ca);\n}\n\n/*\n\tThis function returns the distance from a specified point (p)\n\tto the edge of a sphere centered on c with radius r.\n\n\tThink of this as a 3d gradient which is black (0.0) at the edge of the sphere and\n\tprogressively brighter as you move away from the sphere. Inside the sphere, the\n\tdistance is negative up to -r at the center.\n*/\nfloat distanceSphere(vec3 p, vec3 c, float r) {\n\treturn length(p - c) - r;\n}\n\n\n// simple function to get the distance from a plane\nfloat plane(vec3 p, vec4 n) {\n    return dot(p,n.xyz) + n.w;\n}\n\n/*\n\tThis function gives the distance to a diamond cut object.\n\th.x specifies the side length, h.y specifies the height\n*/\nfloat distanceDiamond(vec3 p, vec2 h) {\n    // object is symmetrical about x and z axes\n\tvec3 q = vec3(abs(p.x), abs(p.y), abs(p.z));\n    \n    // specify the points that make up the object in the positive octant\n    vec3 p1 = vec3(1.0, 0., 0.);\n    vec3 p2 = vec3(RT2, 0., RT2);\n    vec3 p3 = vec3(0., 1.0, 0.);\n    vec3 p4 = vec3(0., 0., 1.0);\n    \n    // get the plane equations as a vec4 by using cross product on the points\n    vec4 s1 = vec4(normalize(cross(p2-p1, p3-p1)), length(p1)+h.x);\n    vec4 s2 = vec4(normalize(cross(p4-p2, p3-p2)), length(p2)+h.x);\n    \n    // get the farthest distance to one of the planes\n    // p.y - h.y is the flat top of the diamond on one side\n    // the second max gives the distance to one of the sides\n    float dist = max(p.y - h.y, max(plane(q, -s1), plane(q, -s2)));\n\treturn dist;\n}\n\nvec3 crystalDisplacement(vec3 p) {\n\t// voronoi normal displacement\n    return vec3(0.);\n}\n\nfloat dirtMap(vec3 p) {\n\t// smudge\n    float dirt = 1.0 - abs(-1.0+2.0*pow(noise(p * 5.0), 8.0));\n    return dirt;\n}\n\nfloat fakeInternalReflection(vec3 p, vec3 view) {\n\t// cloudiness\n    // far side\n    // bubbles\n    return 0.;\n}\n\nfloat detailMap(vec3 p) {\n\t// scratches\n    float scratches = noise(p * vec3(5.0, 50.0, 100.0));\n    // chips\n    //float chips = 1.0 - abs(-1.0+2.0*pow(noise(p * 5.0), 8.0));\n    return scratches;\n}\n\n/*\n\tScene is a function that combines all the other distance functions and modifications\n\tso that for any given point, it returns the closest distance to something\n\tin the complete scene.\n*/\nfloat scene(vec3 p) {\n    float ft = iTime * 4.0 / PI;\n    float dirt = dirtMap(p);\n    float detail = detailMap(p);\n \treturn distanceDiamond(p, vec2(0.2, 0.4)) - sin(ft) * dirt - detail * 0.001;\n}\n\n/*\n\tGets the normal direction at a given point in space.\n\tCompute the derivative of each spatial direction.\n*/\nvec3 getNormal(vec3 p) {\n\tvec3 n1 = vec3(\n        scene(vec3(p.x + EPSILON, p.y, p.z)),\n        scene(vec3(p.x, p.y + EPSILON, p.z)),\n        scene(vec3(p.x, p.y, p.z + EPSILON))\n    );\n    return normalize(n1 - scene(p));\n}\n\nfloat diffuse(vec3 normal, vec3 lightRay, float intensity) {\n    return clamp(dot(lightRay, normal) * intensity, 0.0, 1.0);\n}\n\nfloat specular(vec3 reflectAngle, vec3 lightRay, float shininess) {\n    return pow(clamp(dot(reflectAngle, lightRay), 0.0, 1.0), shininess);\n}\n\nbool displaySample(vec4 color, int pos, out vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x < 64.0 && fragCoord.y > float(pos)*64.0 && fragCoord.y < float(pos+1)*64.0) {\n    \tfragColor = color;\n        return true;\n    }\n    return false;\n}\n\n// fragCoord is [0, iResolution.xy]\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv is the screen space coordinates stretched by the aspect ratio to give\n    // a relative position between 0.0 and 1.0 for both x and y\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    // camera position starts off to the side of the scene and is rotated based on the mouse pos\n    vec3 cameraPos = vec3(0.0, 0.0, 5.0);\n    mat3 mouseRotation = rotateX(iMouse.y / iResolution.y * 3.1415 * 3.0) * rotateY(iMouse.x / iResolution.x * 3.1415 * 3.0);\n    \n    // rays start from the camera\n    vec3 rayOrigin = cameraPos;\n    vec3 rayDirection = normalize(vec3(uv, -1.0));\n    \n    // multiplying the vector by the matrix rotates it in space\n    // think of this as rotating the camera around the origin point\n    rayOrigin *= mouseRotation;\n    rayDirection *= mouseRotation;\n    \n    float minStep = 0.25;\n    float distance = minStep * 2.0;\n    vec3 currentPos = rayOrigin;\n    const int MAX_STEPS = 100;\n    int stepped = 0;\n    float detail = detailMap(uv.xyy * 2.0);\n    float dirt = dirtMap(uv.xyy * 2.0);\n    \n    // raymarching time!\n    // start at the camera position and head towards the current pixel\n    // (current pixel depends on fov)\n    for(int i=0; i<MAX_STEPS; i++) {\n        // each step, move ahead as far as we can\n        // if we know that the closest object is distance away, we can move at least that far\n     \tcurrentPos += abs(distance - minStep) * rayDirection;\n        // find the distance to the closest edge\n        distance = scene(currentPos);\n        if(distance < minStep) {\n            stepped = i;\n\t\t\tbreak;\n        }\n    }\n    \n    if(displaySample(vec4(vec3(detail), 1.0), 0, fragColor, fragCoord)) {\n        return;\n    }\n    if(displaySample(vec4(vec3(dirt), 1.0), 1, fragColor, fragCoord)) {\n        return;\n    }\n    \n    // if we've stepped all the way and we aren't close to the surface, we've probably gone past it\n    // so default to background and skip lighting calculations\n    if(distance > 1.0) {\n\t\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    detail = detailMap(currentPos);\n    \n    vec3 lightPos = vec3(6.0, 8.0, 10.0);\n    vec3 lightColor = vec3(3.0, 0.0, 0.0);\n    vec3 lightDiff = lightPos - currentPos;\n    \n    vec3 directionToLight = normalize(lightDiff);\n\tfloat distanceToLight = length(lightDiff);\n    \n    vec3 normal = getNormal(currentPos);\n    vec3 reflectAngle = reflect(rayDirection, normal);\n    \n    vec3 color = vec3(0.5, 0.1, 0.5);\n    float diffuseFactor = diffuse(normal, directionToLight, 1.0);\n    float specularFactor = specular(reflectAngle, directionToLight, 32.0*(dirt+0.5));\n    float ambient = 0.3;\n    \n    vec3 final = (clamp(diffuseFactor-dirt*0.1, 0.0, 1.0)) * color +\n        \t\t(clamp(specularFactor-detail, 0.0, 1.0)) * lightColor +\n        \t\tvec3(ambient);\n    \n\tfragColor = vec4(final, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}