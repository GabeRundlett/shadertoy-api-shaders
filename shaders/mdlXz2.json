{
    "Shader": {
        "info": {
            "date": "1669243925",
            "description": "GLSL implementation of RIOW.",
            "flags": 0,
            "hasliked": 0,
            "id": "mdlXz2",
            "likes": 3,
            "name": "Ray Tracer from RIOW [WIP]",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "raianmr",
            "viewed": 265
        },
        "renderpass": [
            {
                "code": "// written for shader toy\n\n// config\n\n#define MAX_DEPTH 5\n#define N_SAMPLES 5\n#define MAX_FLOAT 1e5\n#define MIN_FLOAT 1e-3\n\n#define SPEED     0.25\n#define SCALE_ON  true // not implemented\n#define ROTATE_ON true\n\n\n// constants\n\n#define PI 3.14159265359\n\n// random number generation based on https://www.shadertoy.com/view/Xt3cDn\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U * ((p >> 1U) ^ (p.yx));\n    uint h32 = 1103515245U * ((p.x) ^ (p.y>>3U));\n    return h32 ^ (h32 >> 16);\n}\n\nfloat hash1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=0.1, seed+=0.1)));\n    return float(n) / float(0xffffffffU);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=0.1, seed+=0.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=0.1, seed+=0.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\nfloat global_seed = 0.0;\n\nfloat get_seed(vec2 inp) {\n    return float(base_hash(floatBitsToUint(inp))) / float(0xffffffffU) + iTime;\n}\n\nvec2 random_in_unit_disk(inout float seed) {\n    vec2 h = hash2(seed) * vec2(1.0,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi), cos(phi));\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.0, 6.28318530718, 1.0) - vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1.0/3.0);\n\treturn r * vec3(sqrt(1.0-h.x*h.x) * vec2(sin(phi), cos(phi)), h.x);\n}\n\n// rays\n\nstruct ray {\n    vec3 origin, direction;\n};\n\nfloat schlick_approx(float cosine, float ior) {\n    float r0 = (1.0-ior) / (1.0+ior);\n    r0 = r0*r0;\n    return r0 + (1.0-r0) * pow((1.0-cosine), 5.0);\n}\n\nbool does_refract(\n    const in vec3 v, \n    const in vec3 n, \n    const in float ni_over_nt, \n    out vec3 refracted\n    ) {\n    float dt = dot(v, n);\n    float discriminant = 1.0 - ni_over_nt * ni_over_nt * (1.0 - dt*dt);\n    \n    if (discriminant > 0.0) {\n        refracted = ni_over_nt*(v - n*dt) - n*sqrt(discriminant);\n        return true;\n    } else { \n        return false;\n    }\n}\n\n// materials\n\n#define METAL      0\n#define LAMBERTIAN 1\n#define DIELECTRIC 2\n\nstruct material {\n    int type;\n    vec3 albedo;\n    float v;\n};\n\n// hittable\n\nstruct hit_record {\n    float t;\n    vec3 p, normal;\n    material mat;\n};\n\nstruct hitable { // sphere, for now\n    vec3 center;\n    float radius;\n};\n\nbool hittable_hit( // only for spheres\n    const in hitable h, \n    const in ray r, \n    const in float t_min, \n    const in float t_max, \n    inout hit_record rec\n    ) {\n    vec3 oc = r.origin - h.center;\n    float b = dot(oc, r.direction);\n    float c = dot(oc, oc) - h.radius * h.radius;\n    \n    float discriminant = b * b - c;\n    if (discriminant < 0.0) {\n        return false;\n    }\n\n\tfloat s = sqrt(discriminant);\n\tfloat t1 = -b - s;\n\tfloat t2 = -b + s;\n\t\n\tfloat t = t1 < t_min ? t2 : t1;\n    if (t < t_max && t > t_min) {\n        rec.t = t;\n        rec.p = r.origin + t*r.direction;\n        rec.normal = (rec.p - h.center) / h.radius;\n\n\t    return true;\n    } else {\n        return false;\n    }\n}\n\n// camera and scatter\n\nbool scatter(\n    const in ray r_in, \n    const in hit_record rec, \n    out vec3 attenuation, \n    out ray scattered\n    ) {\n    if(rec.mat.type == LAMBERTIAN) {\n        vec3 scatter_dir = normalize(rec.normal + random_in_unit_sphere(global_seed));\n        scattered = ray(rec.p, scatter_dir);\n        attenuation = rec.mat.albedo;\n\n        return true;\n    } \n    \n    if(rec.mat.type == METAL) {\n        vec3 scatter_dir = reflect(r_in.direction, rec.normal);\n        scattered = ray(rec.p, normalize(scatter_dir + rec.mat.v * random_in_unit_sphere(global_seed)));\n        attenuation = rec.mat.albedo;\n\n        return true;\n    } \n    \n    if(rec.mat.type == DIELECTRIC) {\n        vec3 outward_normal, refracted;\n        vec3 reflected = reflect(r_in.direction, rec.normal);\n        float ni_over_nt, reflect_prob, cosine;\n        \n        attenuation = vec3(1);\n        if (dot(r_in.direction, rec.normal) > 0.0) {\n            outward_normal = -rec.normal;\n            ni_over_nt = rec.mat.v;\n            cosine = dot(r_in.direction, rec.normal);\n            cosine = sqrt(1.0 - rec.mat.v * rec.mat.v * (1.0-cosine*cosine));\n        } else {\n            outward_normal = rec.normal;\n            ni_over_nt = 1.0 / rec.mat.v;\n            cosine = -dot(r_in.direction, rec.normal);\n        }\n        \n        if (does_refract(r_in.direction, outward_normal, ni_over_nt, refracted)) {\n\t        reflect_prob = schlick_approx(cosine, rec.mat.v);\n        } else {\n            reflect_prob = 1.0;\n        }\n        \n        if (hash1(global_seed) < reflect_prob) {\n            scattered = ray(rec.p, reflected);\n        } else {\n            scattered = ray(rec.p, refracted);\n        }\n        return true;\n    }\n    \n    return false;\n}\n\nstruct camera {\n    vec3 origin, lower_left_corner, horizontal, vertical, u, v, w;\n    float lens_radius;\n};\n\ncamera new_camera(\n    const in vec3 lookfrom, \n    const in vec3 lookat, \n    const in vec3 vup, \n    const in float vfov, \n    const in float aspect_ratio, \n    const in float aperture, \n    const in float focus_dist\n    ) {\n    camera cam;    \n    cam.lens_radius = aperture / 2.0;\n    float theta = vfov * PI / 180.0;\n    float half_height = tan(theta / 2.0);\n    float half_width = aspect_ratio * half_height;\n    cam.origin = lookfrom;\n    cam.w = normalize(lookfrom - lookat);\n    cam.u = normalize(cross(vup, cam.w));\n    cam.v = cross(cam.w, cam.u);\n    cam.lower_left_corner = cam.origin  - half_width*focus_dist*cam.u - half_height*focus_dist*cam.v - focus_dist*cam.w;\n    cam.horizontal = 2.0 * half_width * focus_dist * cam.u;\n    cam.vertical = 2.0 * half_height * focus_dist * cam.v;\n\n    return cam;\n}\n    \nray get_ray(camera c, vec2 uv) {\n    vec2 rd = c.lens_radius * random_in_unit_disk(global_seed);\n    vec3 offset = c.u * rd.x + c.v * rd.y;\n    vec3 dir = normalize(c.lower_left_corner + uv.x*c.horizontal + uv.y*c.vertical - c.origin - offset);\n    \n    return ray(c.origin + offset, dir);\n}\n\n// scene\n\nbool world_hit(const in ray r, const in float t_min, \n               const in float t_max, out hit_record rec) {\n    rec.t = t_max;\n    bool hit = false;\n\n  \tif (hittable_hit(hitable(vec3(0,-1000,-1),1000.),r,t_min,rec.t,rec)) {\n        hit = true;\n        rec.mat = material(LAMBERTIAN, vec3(.5),0.);\n    }\n  \tif (hittable_hit(hitable(vec3( 0,1,0),1.),r,t_min,rec.t,rec)) {\n        hit = true;\n        rec.mat = material(DIELECTRIC, vec3(0),1.5);\n    } \n    if (hittable_hit(hitable(vec3(-4,1,0),1.),r,t_min,rec.t,rec)) {\n        hit = true;\n        rec.mat = material(LAMBERTIAN, vec3(.4,.2,.1),0.);\n    }       \n\tif (hittable_hit(hitable(vec3( 4,1,0),1.),r,t_min,rec.t,rec)) {\n        hit = true;\n        rec.mat = material(METAL, vec3(.7,.6,.5),0.);\n    }       \n    \n    for (int a = -4; a < 4; a++) {\n        for (int b = -4; b < 4; b++) {\n            float m_seed = float(a) + float(b)/1000.;\n            vec3 rand1 = hash3(m_seed);            \n            vec3 center = vec3(float(a)+.9*rand1.x,.2,float(b)+.9*rand1.y); \n            float choose_mat = rand1.z;\n            \n            if (distance(center,vec3(4,.2,0)) > .9) {\n                if (choose_mat < .8) { // diffuse\n                    if (hittable_hit(hitable(center,.2),r,t_min,rec.t,rec)) {\n                        hit=true, rec.mat=material(LAMBERTIAN, hash3(m_seed)* hash3(m_seed),0.);\n                    }\n                } else if (choose_mat < 0.95) { // metal\n                    if (hittable_hit(hitable(center,.2),r,t_min,rec.t,rec)) {\n                        hit=true, rec.mat=material(METAL,.5*(hash3(m_seed)+1.),.5*hash1(m_seed));\n                    }\n                } else { // glass\n                    if (hittable_hit(hitable(center,.2),r,t_min,rec.t,rec)) {\n                        hit=true, rec.mat=material(DIELECTRIC,vec3(0),1.5);\n                    }\n                }\n            }\n        }\n    }\n    \n    return hit;\n}\n\nvec3 sky_color(ray r)\n{\n    vec3 unit_direction = normalize(r.direction);\n    float t = 0.5 * (unit_direction.y + 1.0);\n\n    vec3 day = vec3(0.5, 0.7, 1.0);\n    vec3 night = vec3(0.0, 0.2, 0.5);\n\n    return (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * mix(day, night, abs(sin(iTime)) * SPEED);\n}\n\nvec3 ray_color(in ray r, int depth) {\n\thit_record rec;\n    vec3 color = vec3(1.0);  \n    \n    for (int i=0; i<depth; i++) {\n    \tif (world_hit(r, MIN_FLOAT, MAX_FLOAT, rec)) {\n            ray scattered;\n            vec3 attenuation;\n            if (scatter(r, rec, attenuation, scattered)) {\n                color *= attenuation;\n                r = scattered;\n            } else {\n                color *= vec3(0.0);\n                break;\n            }\n\t    } else {\n            color *= sky_color(r);\n            break;\n    \t}\n    }\n\n    return color;\n}\n\nvoid animate(out vec3 lookfrom) {\n    if(ROTATE_ON) {\n        float angle = iTime * SPEED;\n    \tmat4 rotation_mat1 = mat4(\n            cos(angle), 0.0, -sin(angle), 0.0,\n                   0.0, 1.0,         0.0, 0.0,\n            sin(angle), 0.0,  cos(angle), 0.0,\n                   0.0, 0.0,         0.0, 1.0\n        );\n        mat4 rotation_mat2 = mat4(\n             cos(angle), sin(angle), 0.0, 0.0,\n            -sin(angle), cos(angle), 0.0, 0.0,\n                    0.0,        0.0, 1.0, 0.0,\n                    0.0,        0.0, 0.0, 1.0\n        );\n    \n    \tvec3 transformed = vec3(rotation_mat2 * rotation_mat1 * vec4(lookfrom, 1.0));\n        // prevent camera from going through floor\n        lookfrom = vec3(transformed.x, abs(transformed.y), transformed.z); \n    }\n\n    // if(SCALE_ON) {\n    // ...\n    // }\n}   \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    global_seed = get_seed(fragCoord);\n\n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec3 lookfrom = vec3(13, 2, 3);\n    vec3 lookat = vec3(0);\n    vec3 vup = vec3(0, 1, 0);\n    float vfov = 20.0;\n    float aperture = 0.1;\n    float focus_dist = 10.0;\n\n    animate(lookfrom);\n\n    camera cam = new_camera(lookfrom, lookat, vup, vfov, aspect_ratio, aperture, focus_dist);\n\n    vec3 color = vec3(0.0);\n    for (int s=0; s<N_SAMPLES; s++)\n    {\n        vec2 uv = (fragCoord + hash2(global_seed))/iResolution.xy;\n\n        ray r = get_ray(cam, uv);\n        color += ray_color(r, MAX_DEPTH);\n    }\n    color /= float(N_SAMPLES);\n\n    // gamma correction\n    color = sqrt(color);\n\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}