{
    "Shader": {
        "info": {
            "date": "1589854313",
            "description": "playing with 4d modelling and the \"empty domains\" trick. see [url]https://www.shadertoy.com/view/tsjfRw[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "WdjBDz",
            "likes": 8,
            "name": "Asteroid Belt Data Links",
            "published": 3,
            "tags": [
                "asteroids"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 470
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//this is mostly a remix of https://www.shadertoy.com/view/tsjfRw but\n//extending to the 4th dimension so we can do 4d rotations and get neat slices\n\n//returns a vector pointing in the direction of the closest neighbouring cell\nvec3 quadrant(vec3 p) {\n    vec3 ap = abs(p);\n    if (ap.x >= max(ap.y, ap.z)) return vec3(sign(p.x),0.,0.);\n    if (ap.y >= max(ap.x, ap.z)) return vec3(0.,sign(p.y),0.);\n    if (ap.z >= max(ap.x, ap.y)) return vec3(0.,0.,sign(p.z));\n    return vec3(0);\n}\n\nfloat hash(float a, float b) {\n    return fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453);\n}\n\nbool domain_enabled(vec3 id) {\n    //repeat random number along z axis so every active cell has at least one active neighbour\n    id.z = floor(id.z/2.); \n    return hash(id.x, hash(id.y, id.z)) < .5;\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat linedist(vec4 p, vec4 a, vec4 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nvec4 wrot(vec4 p) {\n    return vec4(dot(p,vec4(1)), p.yzw + p.wyz - p.zwy - p.xxx)/2.;\n}\n\nfloat box(vec4 p, vec4 d) {\n    vec4 q = abs(p)-d;\n    return length(max(q,0.))+min(0.,max(max(q.x,q.w),max(q.y,q.z)));\n}\n\nvec4 smin(vec4 a, vec4 b, float k) {\n    vec4 h = max(vec4(0),-abs(a-b)+k)/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat weird_obj(vec4 p) {\n    p.xyz = erot(p.xyz, normalize(sin(p.xyz)), iTime/4.);\n    p = wrot(p);\n    p = sqrt(p*p+0.001);\n    p = wrot(p);\n    p.w+=.5;\n    p = sqrt(p*p+0.001);\n    p = wrot(p);\n    //p = smin(p,wrot(p),0.01);\n    return box(p, vec4(1.2))-.2;\n}\n\nfloat ball;\nfloat pipe;\nfloat scene(vec3 p) {\n    p.x+=sin(p.z/5.); p.y+=cos(p.z/5.);\n    p.y+=sin(p.x/7.); p.z+=cos(p.x/7.);\n    float w = sin(p.x/8.+iTime)*sin(p.y/8.+iTime)*sin(p.z/8.+iTime)*3.;\n    vec4 p4 = vec4(p,w);\n    p4 = mix(p4, wrot(p4), .2);\n    float scale = 8.;\n    vec3 id = floor(p.xyz/scale);\n    p4.xyz = (fract(p.xyz/scale)-.5)*scale;\n    if (!domain_enabled(id)) {\n        //return distance to sphere in adjacent domain\n        p4 = abs(p4);\n        if (p4.x > p4.y) p4.xy = p4.yx;\n        if (p4.y > p4.z) p4.yz = p4.zy;\n        if (p4.x > p4.y) p4.xy = p4.yx;\n        p4.z -= scale;\n        pipe = length(p4)-.2;\n        return weird_obj(p4);\n    }\n    float dist = weird_obj(p4);\n    ball = dist;\n    vec3 quad = quadrant(p4.xyz);\n    if (domain_enabled(id+quad)) {\n        //add pipe\n\t\tpipe = linedist(p4, vec4(0), vec4(quad,0.)*scale)-.2;\n        dist = min(dist, pipe);\n    } else {\n        pipe = length(p4)-.2;\n    }\n    return dist;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.01);\n    return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nfloat stars(vec3 dir) {\n    dir = erot(dir,normalize(vec3(1)),.2);\n    float str = length(sin(dir*vec3(120,120,210)));\n    dir = erot(dir,normalize(vec3(1,2,3)),.4);\n    str += length(sin(dir*vec3(320,230,140)));\n    dir = erot(dir,normalize(vec3(2,3,1)),.3);\n    str += length(sin(dir*vec3(230,280,138)));\n    return smoothstep(2.,1.5,str);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam  = normalize(vec3(1,uv));\n    float time = (floor(iTime/3.)+pow(sin(fract(iTime/3.)*3.14/2.),20.))*5. + iTime*2.; //accelerates every 3 seconds\n    cam = erot(cam, vec3(1,0,0), time/20.);\n    cam = erot(cam, vec3(0,0,1), .4+cos(time/8.)*.1);\n    vec3 init = vec3(time*2.-50.,-time,time)+cam;\n    vec3 p = init;\n    bool hit = false;\n    float dist;\n    float glow = 1000.;\n    float glowdist = 0.;\n    //raymarching\n    for (int i = 0; i < 150; i++) {\n        dist = scene(p);\n        if (pipe < glow) {\n            glow = pipe;\n            glowdist = distance(p,init);\n        }\n        hit = dist*dist < 1e-6;\n        p += cam*dist;\n        if (distance(p,init) > 250.) break;\n    }\n    //shading\n    glow = smoothstep(0.5, 0.,glow);\n    float fog = pow(smoothstep(250.,50.,distance(p,init)),2.);\n    vec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    float diff = max(0., dot(n, normalize(vec3(1,-1,1))))  + length(sin(n*vec3(3,2,1))*.5+.5)/sqrt(3.)*.1;\n    float spec = max(0., dot(r, normalize(vec3(1,-1,1))))  + length(sin(r*vec3(3,2,1))*.5+.5)/sqrt(3.)*.1;\n    float fresnel = 1.-abs(dot(n,r))*.98;\n    vec3 matcol = vec3(0.3,.2,.2);\n    vec3 col = matcol*matcol*diff*diff + pow(spec,2.)*fresnel + .005;\n    vec3 glowcol = glow*.5 + abs(erot(vec3(.7,.4,.2), vec3(0,0,1), glowdist*.1))*glow;\n    float glowfog = pow(smoothstep(250.,50.,glowdist),2.);\n    vec3 bg = vec3(stars(cam));\n    fragColor.xyz = sqrt(hit ? mix(bg, col, fog) : bg) + glowfog*glowcol;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}