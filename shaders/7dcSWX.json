{
    "Shader": {
        "info": {
            "date": "1634047442",
            "description": "在入门一的基础上扩展了一部分。",
            "flags": 0,
            "hasliked": 0,
            "id": "7dcSWX",
            "likes": 2,
            "name": "入门之路-2",
            "published": 3,
            "tags": [],
            "usePreview": 0,
            "username": "jialouluo",
            "viewed": 214
        },
        "renderpass": [
            {
                "code": "vec3 getcolor(float ang) {\n    //传入进来的是一个角度值 我们需要将他进行一定的运算来使得他成为我们需要的结果，这里可以根据自己喜好\n        //return 0.6 + 0.4 * cos(ang + vec3(0.5,.7,.2));\n        //return 0.6 + 0.4 * cos(ang + vec3(0.5,.7,.2)  + iTime );//有 iTime\n        //return .5 + .5 * cos(6.28 * (ang + vec3(0., .33, .67)));\n        return .5 + .5 * cos(6.28 * (ang/6.28 + vec3(0., .33, .67)));//6.28 约等于2Π\n    }\nvec2 getCir(float k,float ant,float dis){//注释掉颜色代码 记得将返回值改为float\n/**\n本人也才刚开始学 ，有不对的一些地方或者理解错误的地方，也希望路过的大佬不吝赐教QAQ\n*/\n    float ir = 2.0*fract((iTime*0.2 + k));//内环半径，将半径区间改变为0-2.0\n    float or = 2.2*fract((iTime*0.2 + k));//外环半径，将半径区间改变为0-2.2\n    //解释一下里面的一些数字的含义 2.0 ,2.2已经解释了\n    //0.2代表圆环的扩展速度 可以改变大小观察圆环的扩展速度\n    float c =0.0;\n    \n    if(max(dis,or)==or){\n        c = smoothstep(ant,-ant,dis-or);\n    }\n    if(max(dis,ir)==ir){\n        c = smoothstep(ant,-ant,abs(dis-ir) );\n    }\n     //return c;\n    //下面的代码是赋色代码，与生成环纹无关\n    float a =1.0;\n    if(max(dis,or)==or){//可以与上面的if块合并 这里分出来是为了区分\n        a = (dis-ir)/(or-ir);//这里分母是圆环有色的范围值，分子依靠着dis与内圈半径的差 差越大表示越不应该被隐藏，以此来实现向内圈虚化\n        //如果你有兴趣 不妨将ir改成or，这时会向外圈虚化\n    }\n    else{\n        a =1.0;\n    }\n    \n    return vec2(c,a*c);//返回值这次设置为一个vec2因为我们需要a的值，当然记得给a乘上c(c除开平滑部分值 只有0，1这可以代表着那些地方需要a的颜色)\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord/iResolution.xy;\n    //uv-=0.5;\n    //uv.x*=(iResolution.x/iResolution.y);//初始时x轴为0到2y轴为0到1,减去0.5计算之后为x轴-1到1 y轴为-0.5到0.5\n    //在查看其他大佬分享的案例中 有另外一种也可以使得长宽比例为1\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;//我们这次选用这种计算方式来使得uv.x处于-1-->1 uv.y也处于-1-->1\n    float dis = length(uv);\n    //今天我们来实现一种动态的圆环波，类似于往水中仍一块石头之后水面出现的那种波纹(当然目前是二维的 TAT~);\n    //首先让我们先写出生成圆环的代码（具体可以参考我的入门一）\n    //float ir =0.2;//内环半径\n    //float or =0.4;//外环半径\n    //这次我们将上次提到的抗锯齿代码加入进来\n    //float antialias = fwidth(dis);//这里内嵌了一个abs所以antialias是正数，偏导宽的具体定义可以先去搜搜，毕竟定义还是得官方说得更清楚详细\n    //float c =0.0;\n    //if(max(dis,or)==or){\n    //    c = smoothstep(antialias,-antialias,dis-or);\n    //}\n    //if(max(dis,ir)==ir){\n    //    c = smoothstep(antialias,-antialias,abs(dis-ir));\n    //}\n    //这次我改了一下，可以正确的调整内环和外环的半径了\n    //下面我们来尝试去实现环波\n    //初步我们可以看作内环和外环都同时被放大，然后新的圆环被生成然后新圆环的内外环又被放大，如此循环下去\n    //下面我们来尝试一下(需要使用到iTime)\n    //让我们来重写11-21行代码,为了后面的效果，这里我们不妨将他封装为一个函数；\n    //float antialias = fwidth(dis);//偏导宽作为参数传入，与之一起传入的还有距离\n    //float c = getCir(0.0,antialias,dis);//第一个参数类似于偏移量(作用是让圆环在生成时处在不同的位置)\n    //c+= getCir(0.4,antialias,dis);//这里为什么 c要加后面的每一个呢，因为我们fragColor里面依靠c来赋色\n    //c+= getCir(0.8,antialias,dis);//同时，如果当区域1(理解为圆环一)的返回值为1的话并且区域2的返回值1，如果不相加，仅取区域1的返回值\n    //c+= getCir(1.2,antialias,dis);//就会导致c的值仅取决于区域1的值 在区域1里的处在区域2返回值为1的区域会被赋值为0给c\n    //c+= getCir(1.6,antialias,dis);//所以我们需要将两个区域的值进行相加 可以理解为求交集 这样就会让我们每个区域的值被正确得赋值给c\n    //到这里我们已经生成了具有黑白颜色的环纹了，接下来我们需要给他赋色;\n    //让我们试试昨天的颜色代码，看看他会有什么效果，当然这些代码应该被写在函数里，或者根据个人需求作为一个参数传入;\n    //使用 atan(uv.y,uv.x)是常用的求uv角度的方法\n    //float angle  =atan(uv.y,uv.x);\n    //vec3 Color = getcolor(angle);\n    //Color = Color *c;\n    //观察效果 感觉似乎还不错(对于我这个萌新来说~);\n    //接下来 我们为什么不给他旋转起来呢;\n    //Color = Color * fract(angle/6.28 - iTime);\n    //看起来 似乎旋转过一统一了，让我们再给他加点偏移量，重写67行代码\n    //Color = Color * fract(angle/6.28 - iTime *0.1 + cos(dis)  );//这里的0.1控制颜色旋转的速度\n    //就先这样吧，我们来实现另外一种效果，代码在22行之后,并且重写63行之后的代码\n    float antialias = fwidth(dis);//偏导宽作为参数传入，与之一起传入的还有距离\n    vec2 c = getCir(0.0,antialias,dis);//第一个参数类似于偏移量(作用是让圆环在生成时处在不同的位置)\n    c+= getCir(0.4,antialias,dis);//这里为什么 c要加后面的每一个呢，因为我们fragColor里面依靠c来赋色\n    c+= getCir(0.8,antialias,dis);//同时，如果当区域1(理解为圆环一)的返回值为1的话并且区域2的返回值1，如果不相加，仅取区域1的返回值\n    c+= getCir(1.2,antialias,dis);//就会导致c的值仅取决于区域1的值 在区域1里的处在区域2返回值为1的区域会被赋值为0给c\n    c+= getCir(1.6,antialias,dis);//所以我们\n    vec3 Color = vec3(c[1]* 0.3,c[1]* 0.5,c[1] * 0.6)*c[1];\n    fragColor = vec4(Color,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}