{
    "Shader": {
        "info": {
            "date": "1713643484",
            "description": "saw [url=https://www.youtube.com/watch?v=CuTQ3j56yP0]this[/url] and wanted to recreate it. Took me long enough ðŸ’€. Got some practice with noise generation in the process.",
            "flags": 0,
            "hasliked": 0,
            "id": "4ctSR4",
            "likes": 4,
            "name": "eclipse but from space",
            "published": 3,
            "tags": [
                "art"
            ],
            "usePreview": 0,
            "username": "01000001",
            "viewed": 125
        },
        "renderpass": [
            {
                "code": "float pi = 3.1415926;\nfloat detail = .9;\nfloat radius = 50.;\nfloat atmosphere = .1;\n#define offset(x) vec3(0, 5, x + 1.)\n\n#define cloud(x) smoothstep(-.5, 1.5, noise(cuv*2. + iTime*.02 \\\n                + vec2(                                         \\\n                    noise(cuv, 2<<2, seed + uvec3(2)),           \\\n                    noise(cuv, 2<<2, seed + uvec3(3))             \\\n                )*.8,                                              \\\n                x, seed+uvec3(1))                                   \\\n    )                                               \n\n#define eclipseCalc euv = cuv; euv.y -= 4.; euv.x -= iTime * .05 + 2.; euv.x = mod(euv.x + 4., 8.) - 4.; \\\n            eclipse = 1.-clamp( .3/(euv.x*euv.x + euv.y*euv.y) ,0.,1.);\n\n\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nmat2 rot(float t){\n    return mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nfloat noise(vec2 p, int d, uvec3 x){\n    p *= 0.002;\n    float sum;\n    vec2 dir;\n    vec3 h;\n    for (int i = 1; i<d+1; i++){\n        h = hash(x + uvec3(i, i*i, 2<<i)) * 2. - 1.;\n        sum  += (texture(iChannel3, p * rot(atan(h.y, h.x)) * float(i)).x*2.-1.)/pow(float(i), 1./detail);\n    }\n    return sum;\n}\n\nfloat dirDeriv(vec2 p, int d, uvec3 x, vec2 dir, float e){\n    return (noise(p,d,x) - noise(p - dir*e, d, x)); \n}\n\nfloat dirDeriv(vec2 p, int d, uvec3 x, float f, vec2 dir, float e){\n    return (f - noise(p - dir*e, d, x)); \n}\n\nvec2 normal(vec2 p, int d, uvec3 x, float f, float e){\n    return vec2(\n        dirDeriv(p,d,x,f,vec2(1,0), e),\n        dirDeriv(p,d,x,f,vec2(0,1), e)\n    );\n}\n\nvec2 sphere( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    vec3 qc = oc - b*rd;\n    float h = ra*ra - dot( qc, qc );\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nfloat linePointDist(vec3 o, vec3 dir, vec3 p){\n    vec3 a = cross(p-o, dir-o);\n    vec3 b = normalize(cross(dir-o, a));\n    return dot(b, p-o);\n}\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    \n    uvec3 seed = uvec3(0,1,3);\n    \n    O = vec4(0);\n    \n    \n    vec3 o = vec3(0);\n    vec2 camuv = (cuv / 1.5) + vec2(0, .2);\n    //vec3 dir = vec3(sin(camuv.x)*cos(camuv.y),cos(camuv.x)*cos(camuv.y), sin(camuv.y));\n    //dir.zy *= rot(.5);\n    vec3 dir = normalize(vec3(camuv.x, 2., camuv.y));\n    vec2 t;\n    t.x = sphere(o, dir, offset(radius), radius).x;\n    t.y = sphere(o, dir, offset(radius), radius + atmosphere).x;\n    float fresnel = t.x>0.?dot(-dir, normalize(o + dir*t.x - offset(radius))):1e10;\n    \n    float x = linePointDist(o, dir, offset(radius)) - radius;\n    O += vec4(.2, .4, .8, 1.) * 1./sqrt(x*2.) * exp(-x*4.); //Help the people without oled screens feel a bit less bad... that includes me\n\n    float eclipse;\n    vec2 euv;\n    o.x += iTime*.2;\n    \n    if (t.y > 0.){\n        if (t.x > 0.){\n            cuv = (o + dir * t.x).xy;\n            \n            eclipseCalc\n\n            float f = noise(cuv*.2, 2<<5, seed);\n            vec3 norm = normal(cuv*.2, 2<<5, seed, f, 1e-2 / t.x).xyy;\n            norm.z = sqrt(1. - norm.x*norm.x - norm.y*norm.y);\n\n            vec3 lightDir = normalize(vec3(sin(1.), cos(1.), 1.));\n            float shading = dot(lightDir, norm);\n\n            O = mix(vec4(.8,.8,.7,1.), vec4(.2, .3,.3,1.), f) * shading;\n\n            if (f < 0.) O *= pow(vec4(.5, .6, .8, 1.), vec4(-f*5.));\n\n            //Cloud Shadows\n            O *= 1.-cloud(2<<3);\n            // By simply doing less FBM we get blurred noise. A rare case of blur being cheaper!\n            \n            O *= eclipse;\n        }\n        \n        cuv = (o + dir * t.y).xy;\n\n        eclipseCalc\n\n        // Cloud Layer\n        O = mix(O, vec4(1), \n            cloud(2<<5) * eclipse\n        );\n    }\n    \n    //O = vec4(0);\n    float f =  1./(sqrt(fresnel*10.)) * exp(-fresnel*5.);\n    O /= (f + 1.);\n    O += vec4(.2, .4, .8, 1.) * f * eclipse;\n    \n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}