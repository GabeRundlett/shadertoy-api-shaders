{
    "Shader": {
        "info": {
            "date": "1682777388",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\nNothing too special - just playing with my refraction loop - thanks @blackle (and @Shane/@iq)",
            "flags": 0,
            "hasliked": 0,
            "id": "mld3zj",
            "likes": 14,
            "name": "Year of Truchets #015",
            "published": 3,
            "tags": [
                "hexagon",
                "truchet",
                "tiles"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 229
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #015\n    04/29/2023  @byt3_m3chanic\n    (it's gonna be may)\n*/\n\n// AA = 1 = OFF else 2 > depending on GPU\n#define ZERO (min(iFrame,0))\n#define AA 1\n\n\n#define R \t\tiResolution\n#define T \t\tiTime\n#define M \t\tiMouse\n\n#define PI          \t3.14159265358\n#define PI2         \t6.28318530718\n\n#define MAX_DIST    100.\n\n\nconst vec2  s = vec2(1, 1.7320508);\n// pre-cal for speed \nconst float radi = .28867514;\nconst float harc = .57735027;\nconst float scale = .4;\n\nvec3 hp=vec3(0),hit=vec3(0);\nvec2 gid=vec2(0),sid=vec2(0);\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);}\n\n//@iq extrude functions \nfloat opx(in float d, in float z, in float h){\n    vec2 w = vec2( d, abs(z) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\n//@Shane hex/grid functions\nfloat hex(in vec2 p) {\n    p = abs(p);\n    return max(dot(p, s*.5), p.x);\n}\n\nvec4 getGrid(vec2 p) {\n    vec4 ip = floor(vec4(p/s, p/s - .5));\n    vec4 q = p.xyxy - vec4(ip.xy + .5, ip.zw + 1.)*s.xyxy;\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n}\n\nvec3 map(vec3 pos) {\n    vec3 res = vec3(1e5,0,0);\n    \n    vec2 uv = pos.xy+(vec2(-.1,.2)*T);\n\n    vec4 h = getGrid(uv*scale);\n    vec2 p = h.xy;\n\n    float f = hex(p)-.465;\n    float rnd = hash21(h.zw + vec2(.09, .04));\n    float rnd2 = hash21(h.zw + vec2(.37, 7.83)); \n    \n    rnd = floor(rnd*144.);\n    p.xy*=rot(rnd*PI/3.);\n\n    vec3 d, py;\n    vec2 p0, p1, p2;\n    float m = 1.;\n    \n    if(rnd2<.25) {\n        p0 = p - vec2(0, -harc);\n        p1 = p - vec2(0, harc);\n        p2 = p;\n        \n        d.x = length(p0) - radi;\n        d.y = length(p1) - radi;\n        d.z = abs(p2.y);\n        \n        py.x = pos.z;\n        py.y = pos.z;\n        py.z = (pos.z-.11)-.11*cos(p0.x*PI2);\n        m = 3.;\n    }\n    else if(rnd2<.75) {\n        p0 = p;\n        p1 = rot(1.04719755)*p;\n        p2 = rot(2.09439510)*p;\n    \n        d.x = abs(p0.y);\n        d.y = abs(p1.y);\n        d.z = abs(p2.y);\n \n        py.x = (pos.z-.22)-.22*cos(p0.x*PI2);\n        py.y = (pos.z-.11)-.11*cos(p1.x*PI2);\n        py.z = pos.z;\n        m = 2.;\n    }\n    else {\n        p0 = p - vec2(-.5, -radi);\n        p1 = p - vec2(.5, -radi);\n        p2 = p - vec2(0, harc);\n        \n        d.x = length(p0) - radi;\n        d.y = length(p1) - radi;\n        d.z = length(p2) - radi;\n        \n        py = vec3(pos.z);\n    }\n  \n    const float ht = .03;\n    d=abs(abs(abs(d)-.1)-.05)-.025;\n    \n    float hx= opx(f,pos.z+.75,.025)-.01; \n    if(hx<res.x) {\n        res =vec3(hx,5.,5.);\n        hp = vec3(p,pos.z);\n        gid=h.zw;\n    }\n    \n    float d1 = opx(d.x,py.x,ht)-.01;\n    if(d1<res.x) {\n        res =vec3(d1,m,1.);\n        hp = vec3(p0,pos.z);\n        gid=h.zw;\n    }\n\n    float d2 = opx(d.y,py.y,ht)-.01;\n    if(d2<res.x) {\n        res =vec3(d2,m,2.);\n        hp = vec3(p1,pos.z);\n        gid=h.zw;\n    }\n    \n    float d3 = opx(d.z,py.z,ht)-.01;\n    if(d3<res.x) {\n        res =vec3(d3,m,3.);\n        hp = vec3(p2,pos.z);\n        gid=h.zw;\n    }\n\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist)\n{\n    float e = mindist*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\n//@iq https://iquilezles.org/articles/palettes/\nvec3 hue(float t){ \n    t+=T*.05;\n    return .3+.3*cos(PI2*t*(vec3(1.,.99,.95)+vec3(0.925,0.631,0.212))); \n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n) {\n    n = normal(p,d,1.);\n    \n    vec3 lpos = vec3(4,-5,7);\n    vec3 l = normalize(lpos-p);\n\n    float diff = clamp(dot(n,l),.0,.9);\n    \n    float py = abs(p.y)-5.;\n    float hs = (m==5.) ? .13 : .15;\n    \n    vec3 h = hue(py*hs);\n\n    return h*diff;\n}\n\nvec3 render(in vec2 uv, in vec2 F ) {\n\n    vec3 C=vec3(.0);\n\n    vec3 ro = vec3(0,0,4.75),\n         rd = normalize(vec3(uv,-1));\n\n    float x = M.xy == vec2(0) ? -.1 : -(M.y/R.y * .25 - .125) * PI;\n    float y = M.xy == vec2(0) ?  .0 :  (M.x/R.x * .125 - .0625) * PI;\n\n    mat2 rx = rot(x),ry = rot(y);\n    ro.yz *= rx,ro.xz *= ry;\n    rd.yz *= rx,rd.xz *= ry;\n    \n    vec3  p = ro + rd * .1;\n    \n    float atten = 1.,k = 1.,v = 1.,b = 3.;\n    \n    // loop inspired/adapted from @blackle's \n    // marcher https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<100;i++)\n    {\n        vec3 ray = map(p);\n        vec3 n=vec3(0);\n\n        float d = ray.x*.8;\n        float m = ray.y;\n        float q = ray.z;\n        sid=gid;\n        hit=hp;\n        p += rd * d *k;\n        \n        if (d*d < 1e-7) {\n\n            C+=shade(p,rd,d,m,n)*atten;\n         \n            if(m==5.||b<1.)break;\n            b--;\n            atten *= .675;\n            p += rd*.0025;\n            k = sign(map(p).x);\n        \n            vec3 rf=refract(rd,n,v > 0. ? .75 : 1.1);\n            v *= -1.;\n            if(length(rf) == 0.) rf = reflect(rd,n);\n            \n            rd = rf;\n            p += -n*.0025;\n        }  \n        if(distance(p,rd)>50.) { break; }\n    }\n    // Output to screen\n    return C;\n}\n\n// AA from @iq https://www.shadertoy.com/view/3lsSzf\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    \n    vec3 C = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (-R.xy + 2.0*(F+o))/max(R.x,R.y);\n#else    \n        vec2 uv = (-R.xy + 2.0*F)/max(R.x,R.y);\n#endif\n        vec3 color = render(uv,F);     \n        color = 1.35*color/(1.0+color);\n        C += color;\n#if AA>1\n    }\n    C /= float(AA*AA);\n#endif\n    \n    C = pow(C, vec3(0.4545) );\n    O = vec4(C,1.);\n}\n//end\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}