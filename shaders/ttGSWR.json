{
    "Shader": {
        "info": {
            "date": "1582508096",
            "description": "This is another edit of the \"Fly Quaternion City\" shader.\n\nUse the mouse and arrow keys to move. The original shader is here: https://www.shadertoy.com/view/4tSyRz",
            "flags": 48,
            "hasliked": 0,
            "id": "ttGSWR",
            "likes": 4,
            "name": "Pulsating iridescent spheres",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "jarble",
            "viewed": 473
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 o, in vec2 u){\n o=texture(iChannel0,u/iResolution.xy, -100.0 );\n  //o+=mainImage2(o,u);\n}\n\n//everything is in BuffA!\n//it needs a buffer for camera position and rotation.",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n#define steps 100\n#define maxdistance 4.0\n#define epsilon 0.003\n\n#define limit 3.0\n\n#define HASHSCALE3 vec3(.6531, .5563, .7498)\n\n#define dot2(p) dot(p,p)\n\n//hash function in hash without sine by Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z*15.3023+0.434);\n}\n\n#define checktree(k)                        \\\nfor (j = 0.0; j < k; j++) {             \\\n    vec3 h = floor(r*exp2(j))*exp2(-j); \\\n    float rand = hash13(h+exp2(-j-1.0));\\\n    if (rand >= 0.5) {                 \\\n        break;                          \\\n    }                                   \\\n}\n\nfloat squarering(vec3 p) {\n    vec2 q = vec2(abs(length(p.xy)-0.5),abs(p.z));\n    float len = length(max(q-0.1667,0.0))+min(max(q.x,q.y)-0.1667,0.0);\n    return len;\n}\n\nfloat truchet(vec3 p, int type) {\n    vec3 q = abs(p-0.5);\n\t\n    vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));\n    q = min(q,q.yzx);\n    q2.y = max(max(q.x,q.y),q.z);\n\n    float inside = length(abs(q2.yz-vec2(0.0,0.5)))-0.1667;\n    float inside2 = length(max(abs(q2.yz-vec2(0.0,0.5)),0.0))-0.1667;\n    float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;\n    \n    float len;\n    //len = min(len, squarering(p.xyz-vec3(0,0,0.5)));\n    //len = min(len, squarering(p.yzx-vec3(1,0,0.5)));\n    //len = min(len, squarering(p.zxy-vec3(1,1,0.5)));\n    if (type == 0) {\n        len = inside;\n    } else if (type == 1) {\n        //\n        len = -outside;\n    } else if (type == 2) {\n        len = inside2;\n    } else if (type == 3) {\n        len = squarering(p.xyz-vec3(0,0,0.5));\n        len = min(len, squarering(p.yzx-vec3(1,0,0.5)));\n        len = min(len, squarering(p.zxy-vec3(1,1,0.5)));\n    }\n    \n    \n    return len;\n}\n\nfloat mapOcreeeTruchet(vec3 p) {\n    \n    vec3 fp;\n    vec3 lp;\n    float len;\n    float i;\n    float size = 1.0;\n    \n    //r is the truchet cell you want the random \n    vec3 r = p;\n    float j;\n    checktree(limit);\n    i = j;\n    \n    //the position in the bottom left corner of the truchet cell\n    fp = floor(p*exp2(i))*exp2(-i);\n\n    //the local position on the truchet cell (always 0-1)\n    lp = fract(p*exp2(i));\n    \n    int type = int(hash13((fp+exp2(-i-1.0))*vec3(0.93,0.89,1.23))*4.0);\n    len = truchet(lp,type)*exp2(-i);\n    while (i <= limit) {\n        //the position in the bottom left corner of the truchet cell\n        fp = floor(p*exp2(i))*exp2(-i);\n        //the local position on the truchet cell (always 0-1)\n        lp = fract(p*exp2(i));\n        //check for the overlapping black dots\n        vec3 p2 = p*exp2(i);\n        vec3 fp2 = floor(p2-0.5);\n        for(int x = -0; x <= 1; x++) {\n            for(int y = -0; y <= 1; y++) {\n                for(int z = -0; z <= 1; z++) {\n                    r = (fp2+vec3(x,y,z))*exp2(-i);\n                    //this branch doesn't do anything, but it skips the random() once\n                    if (r != fp)\n                    {\n                        checktree(i);\n\n                        if (i==j) {\n                            vec3 q = abs(p2-fp2-vec3(x,y,z)-0.5);\n                            \n                            vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));\n                            q = min(q,q.yzx);\n                            q2.y = max(max(q.x,q.y),q.z);\n                            \n                            float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;\n                            \n                            len = max(-outside*exp2(-i),len);\n                        }\n                    }\n                }\n            }\n        }\n        size *= 0.5;\n        len *= -1.0;\n        i++;\n    }\n    //len *= size;\n    return len;\n    \n    /*vec3 q = abs(p-0.5);\n    \n    vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));\n    q = min(q,q.yzx);\n    q2.y = max(max(q.x,q.y),q.z);\n    \n    float inside = length(abs(max(q2.yz-vec2(0.0,0.5),0.0)))-0.1667;\n    float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;\n    \n    if (floor(p) == vec3(0)) {\n    \tlen = -outside;\n    } else {\n        len = inside;\n    }\n    return len;*/\n    //return outside;\n\n}\n\n\n/*\nself  : https://www.shadertoy.com/view/4tSyRz\n- single page, less duped code. trutural sorting \n- less globals, more object oriented.\n- more defines\n- larger render distance.\n- establishing [tiny namespace convention]\n- - mostly in scene()\n- - distance field is called gd() and gd1()for colors (resolves fractal G-buffer stuff?)\nparent: https://www.shadertoy.com/view/lsd3Dl\n  Rocket City by eiffie (although there are no rockets \n   and there is little if any esemblance to a city this is what eiffie called it)\n  eiffie just wanted to make a reusable flight control \n   but then messed that up with collision detection.\n*/\n\n\n\n//cut off half of the distance field along a plane that that the .y axis as its normal.\n#define cutY\n\n//epsilon  is a break condition for sphere tracking.\n//fractals need smaller eps, IEEE floats lose too much precision below .0000001\n//smaller eps result in slower fps and more convave areas.\n#define eps .00001\n//max number of raymarch spheretracking iterations, max number of gradient descents.\n#define iterRm 256\n\n\n//max view distance, far clipping sphere, centred around camera\n#define zFar 80.\n//to veil the horizon or not to veil the horizon, that is the asymptote.\n#define doFog\n\n//do shading. do calculus operations, sample derivatives of the gradient.\n#define doShade\n\n//ao on fractals is often odd, it can make things brighter.\n#define doAO\n\n//do specular light, fake reflectio of sunlight\n#define doSpec\n\n//max.iter fractal shapes, parent setting is 4. 5. is a bit \"brighter\"\n#define iterDfFractal 4.\n\n\n//does not have dynamiceps\n\n//does not have any code for reflections.\n\n\n//fractals need more iterShadAO at screenspace-edges (edge detecion)\n//, where normals are not pointing towards camera\n//Max.sample soft shadow \n#define iterAO 8.\n\n//now with autopilot, thanks Fabrice!\n//#define USE_AUTO_PILOT \n//looks like i broke it\n\n#define THRUST 0.02*iTimeDelta\n#define ROLL 1.0*iTimeDelta\n#define ROTATE 4.0*iTimeDelta\n//collision epsilon\n#define TOO_CLOSE 0.01\n//should scale with movement speed\n\n//controls (i may have swapped left and right here, do not overthing this one)\n#define LEFT_ARROW 39\n#define RIGHT_ARROW 37  \n#define UP_ARROW 38\n#define DOWN_ARROW 40\n\n#define sat(a) clamp(a,.0,1.)\n\n//load and save, originally from iq, modified\nfloat isInside(vec2 p,vec2 c){vec2 d=abs(p-.5-c)-.5;return -max(d.x,d.y);}\nvec4 load(int re){return texture(iChannel0,(.5+vec2(re,.0))/iChannelResolution[0].xy,-100.);}\nvoid store(in int re, in vec4 va, inout vec4 o, in vec2 u\n){if(isInside(u,vec2(re,0))>.0)o=va;}//o=(isInside(u,vec2(re,0))>.0)?va:o;}\n//bool KeyDown(in int key){return (texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x>0.0);}\nfloat key(in int key){return texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x;}\n\n//quaterion math\nvec4 qid(){return vec4(0.0,0.0,0.0,1.0);}\n//return q2, rotated by q1, order matters when unsigned(axes) are not identical.\nvec4 qmulq(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz)\n,(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\nvec4 aa2q(vec3 axis, float angle){return vec4(normalize(axis)*sin(angle*0.5),cos(angle*0.5));}\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dot(q,q);}//inverse quaternion\n//return p, rotated by q;\nvec3 qmulv(vec4 q, vec3 p){return qmulq(q,qmulq(vec4(p,.0),qinv(q))).xyz;}\n//rotate pitch,yaw,roll in that order:\nvec4 qpyr(vec3 o){o*=0.5;vec3 s=sin(o),c=cos(o)\n;return vec4(s.x*c.y*c.z+s.y*c.x*s.z,s.y*c.x*c.z-s.x*c.y*s.z\n,s.x*s.y*c.z+s.z*c.x*c.y, c.x*c.y*c.z-s.x*s.y*s.z);}\n/*\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.0);}//assumed q is normalized coverts to axis&angle\nvec4 qlookat(vec3 v){return aa2q(vec3(-v.y,v.x,0.0),acos(v.z/length(v)));}//point in direction v\nvec3 vmulq(vec3 p, vec4 q){return qmulq(qinv(q),qmulq(vec4(p,0.0),q)).xyz;}//inverse rotation\nvec4 qslerp(vec4 q1, vec4 q2, float f){\n\tfloat d=dot(q1,q2),theta=acos(abs(d)),ost=(1.0/sin(theta)); \n\treturn normalize(q1*sin(theta*(1.0-f))*ost*sign(d)+q2*sin(theta*f)*ost); \n}\n*/\n\n//hash\nfloat h12(in vec2 p){\n return fract(float(iFrame)+sin(dot(p,vec2(13.3145,17.7391)))*317.7654321);}\n//quaterion math, just to be different\n\n//shape:\nvec3 Tile(vec3 p\n){\n ;vec3 a=vec3(8.0)\n ;//return p\n ;return abs(mod(p,a)-a*0.5)-a*0.25\n ;}\nfloat DERect(vec4 z,vec3 r){return length(max(abs(z.xyz)-r,0.0))/z.w;}\nconst float mr=0.5, mxr=0.975, scale = 2.52;\nconst vec3 rc=vec3(3.31,2.79,4.11),rcL=vec3(2.24,1.88,2.84);\nconst vec4 p0=vec4(4.0,0.0,-4.0,1.0);\n//colors\nconst vec3 sunDir=normalize(vec3(0.7,1.0,-0.7))\n,sunColor=vec3(1.0,0.99,.9)\n,skyColor=vec3(.25,.26,.27)\n//rainbow tinted cosmic microwave background, makes nice fog.\n;vec3 Backdrop(in vec3 rd){vec3 a= \n+skyColor\n+.05*(rd+sin(rd.yzx*5.+2.4*sin(rd.zxy*3.0)))\n+sunColor*(max(0.0,dot(rd,sunDir))*0.2+pow(max(0.0,dot(rd,sunDir)),256.));\n;return .7*a;}\n\n//return signed distane of[p] to a surface.\nfloat gd(vec3 u//gradient differential, signed distance field:\n){\n ;//u.z+=1.\n // #define DareOctree  //toggle\n ;vec3 p=u \n  #ifndef DareOctree\n ;p=Tile(p)\n  #endif\n ;vec4 z=vec4(p*(1.0+sin(iTime)/20.0),1.0)*sin(length(p)-1.0+sin(p.x+p.y)/(sin(iTime)*5.0+10.0))\n ;float dG=1e3\n #ifdef DareOctree\n     //slow octree truchet (without octree traversal)\n;dG=mapOcreeeTruchet(u*.01)   //scale big to make navigable (woth collision detection scaling)\n     //https://www.shadertoy.com/view/MlcfRl\n #else    \n ;for(float n=.0;n<iterDfFractal;n++ //fractal\n ){z.xyz=clamp(z.xyz,-1.,1.)*2.-z.xyz\n  ;z*=scale/clamp(max(dot(z.xy,z.xy),max(dot(z.xz,z.xz),dot(z.yz,z.yz))),mr,mxr)\n  ;z+=p0\n  ;if(n==2.)dG=DERect(z,rcL)\n ;}\n #endif\n //;dG=min(dG,DERect(z,rc))\n #ifdef cutY\n //;dG=max(dG,u.y);\n #endif\n ;return dG;\n ;}\n\n\n//a variant of gd(), that is HERE used to get a color and tto derive a surface normal.\n//the inout vec4 mcol is a big difference.\nfloat gd1(vec3 p,inout vec4 mcol\n){p=Tile(p)\n ;vec4 z=vec4(p,1)\n ;float dG=1e3\n ;vec4 mc=vec4(0)\n ;for (float n=.0;n<5.;n++ //palette of 5 colors, i sync to abive fractal shape\n ){z.xyz=clamp(z.xyz, -1.0, 1.0) *2.0-z.xyz\n  ;z*=scale/clamp(max(dot(z.xy,z.xy),max(dot(z.xz,z.xz),dot(z.yz,z.yz))),mr,mxr)\n  ;z+=p0\n  ;if(n==3.)mc=vec4(vec3(.5,.3,.2)+z.xyz*.05,.25)\n  ;else if(n==2.)dG=DERect(z,rcL);\n }float ds=DERect(z,rc)\n ;if(dG<ds)mcol+=vec4(0.5,0.6,0.9,0.9)+vec4(z.xyz*0.025,0.0)\n ;else mcol+=mc\n ;return min(dG,ds);}\n\nvec3 fog(float ts,vec3 spc,vec3 fcol){\n //;float fog=min(pow(ts*.2,1.33)*.54,1.)//optimizd for zzFar=20.\n ;float fog=min(pow(ts*20./zFar*.2,1.33)*.54,1.)//optimizd for zzFar=20.\n //must be reciprocal log() ?\n ;return mix(spc,fcol,fog);}\n\nfloat AO(in vec3 o,in vec3 d,float s){//origin, direction, scatterHash\n ;float t=.0,a=1.,f,n=.01+.04*s\n ;for(float i=.0;i<iterAO;i++ \n ){f=max(gd(o+d*t)*1.5,n)\n  ;a=min(a,f/t+t*0.5)\n  ;t+=f;\n }return a;}//soft shadow with \"noisy lens\".\n\n\n//return occluded specular.\nvec3 SpecOcc(vec3 r,vec3 d,vec3 N,vec3 so,vec3 o,float s,vec4 mcol){\n;float l=dot(N,sunDir)//sundir must be normalized\n#ifdef doAO\n,shad=AO(so+N*.001,sunDir,s)//shadow\n#else\n,shad=.5\n#endif\n#ifdef doSpec\n;float v=dot(-d,N)\n;vec3 cc=vec3(.6,.8,1)//diffused light. sky color, shorter wavelengths diffuse more\n,lc=vec3(1,.8,.6)     //undiffused light, direct sun color, long wavelengths\n;float cd=exp(-distance(o,so))\n;vec3 R=reflect(d,N)\n;float spcl=pow(sat(dot(R,sunDir)),10.)\n,spcc=pow(max(.0,dot(R,-d)),1.+cd)*.25\n;r=r*(cd*v*cc+shad*l*lc)+(cd*spcc*cc+shad*spcl*lc)*mcol.a\n#endif\n;r=sat(r)\n;return r;}\n\n/*\n[o]RayOrigin\n[d]RayDirection\n[s]ScatterNoise\n[c]color, to be returned\n[f]FragmentSpaceScaling, to blur rasterization, against moire;a=smoothstep(s,-s,a);\n[t]TimeTraveled (implies division by speed of light) == distance to camera \n[g]gradient, signed distance to surface.\n[ao]Accumulate Occlusion, may just buffer the last step length\n[ps]PushSmallest; ps=(g<f*t &&g <ao && ts.w<.0);\n[ts]TimeSmallest    ,init: ts=vec4(-1 ), if(ps)store the 4 smallest [t>0] (abridged)\n[gs]gradientSmallest,init: gs=vec4(1e6), if(ps)store the 4 smallest abs(g)\n*/\nvec3 scene(vec3 o,vec3 d,float s){//origin,direction,scattering\n;float g=gd(o)*s*.5\n,t=g,ao=1.\n,f=2./min(iResolution.x,iResolution.y) //AntiAlias pixel size, of [2] pixels.\n;vec4 gs=vec4(1e6),ts=vec4(-1)//buffer 4 \"smallest values\"\n ;for(int i=0;i<iterRm;i++\n ){//start.raymarch\n ;g=gd(o+d*t)\n ;bool ps=all(lessThan(vec2(g,ts.w),vec2(min(f*t,ao),0)))\n       //=(g<min(f*t,ao)&&ts.w<.0);\n       //=(g<f*t&&g<ao&&ts.w<.0);\n ;if(ps //PushSmall, we remember 4*2 smallest values for AO.\n ){gs=vec4(abs(g),gs.xyz)\n  ;ts=vec4(t,ts.xyz);\n ;}\n ;t+=g\n ;ao=g\n ;if(t>zFar||g<eps)break;//raymarch loop break\n ;}//end__.raymarch loop \n ;if(g<f*t && g<gs.x){gs.x=g;ts.x=t;}//one last PushSmall\n ;vec3 c=Backdrop(d)\n     //;return c;\n ;vec3 fcol=c\n ;for(int i=0;i<4;i++ //some AA supersampling shit in here?\n ){//ts and ps values get processed for \"occlusion\"\n  //oh looks like this is just nearSurface() surface stuff.      \n  ;if(ts.x<.0)break\n  ;float px=f*ts.x\n  ;vec3 so=o+d*ts.x\n  ;vec4 mcol=vec4(.0)\n  #define g3(a) vec3(gd1(so+a.xyy,mcol),gd1(so+a.yxy,mcol),gd1(so+a.yyx,mcol))\n  ;vec3 ve=vec3(px,0,0)\n  ;vec3 dp=g3(ve),dn=g3(-ve)//positive normal//negative normal\n  ;float d1=gd1(so,mcol)\n  ;vec3 N=(dp-dn)/(length(dp-vec3(d1))+length(vec3(d1)-dn))//HNF, normalized surface normal.\n  //above begs to be inversesqrt?\n  ;vec3 spc=mcol.rgb*0.14//specular set to material\n  #ifdef doShade\n  ;spc=SpecOcc(spc,d,N,so,o,s,mcol)\n  #endif\n        //near distance can skip fog.\n  #ifdef doFog\n  ;spc=fog(ts.x,spc,fcol);\n  #else \n  //;spc=fog(ts.x,spc,fcol);\n  #endif  \n  ;c=mix(spc,c,sat(gs.x/px))\n  ;gs=gs.yzwx;ts=ts.yzwx//rotate sampling matrix\n ;}\n//;if(c!=c)c=vec3(1,0,0);//if(NaN)\n;return sat(c*2.)\n;}\n\n\nvec4 mainImage2(out vec4 fragColor, in vec2 fragCoord){\n vec3 t=normalize(vec3((2.0*fragCoord-iResolution.xy)/iResolution.y,1.0));\n vec3 o=load(0).xyz;\n vec4 fw=(load(1));\n t=qmulv(fw,t);\n //ro=eye;rd=normalize(dir);\n float s=h12(fragCoord);\n return vec4(scene(o,t,s),1.0);\n}\n\n\nvoid steer( out vec4 o, in vec2 u\n){vec4 p,qrot\n ;if(iFrame<2){//init\n ;p=vec4(.1,0,0,.01)\n ;qrot=normalize(vec4(.1,.2,.3,.8));\n }else{//next frame\n  ;p=load(0);qrot=load(1)//load state from previous frame\n  ;vec3 fw=vec3(0,0,1)\n  ;fw=qmulv(qrot,fw) //this can be done simpler\n  ;vec3 newp=p.xyz+fw*p.w*.2\n  ;if(gd(newp)>TOO_CLOSE)p.xyz=newp\n  ;else{\n   ;if(gd(vec3(p.xy,newp.z))>TOO_CLOSE)p.z=newp.z;\n   ;if(gd(vec3(p.x,newp.y,p.z))>TOO_CLOSE)p.y=newp.y;\n   ;if(gd(vec3(newp.x,p.yz))>TOO_CLOSE)p.x=newp.x;//mkay every domain checked intependently\n  ;}\n ;p.w+=THRUST*(key(UP_ARROW)-key(DOWN_ARROW));\n ;float roll=ROLL*(key(RIGHT_ARROW)-key(LEFT_ARROW));\n ;vec2 m=vec2(0)\n ;if(iMouse.z>.0\n ){\n  ;vec2 n=iMouse.xy-iMouse.zw\n  ;n.x=-n.x\n  ;m.xy-=(n)/iResolution.xy\n ;}\n #ifdef USE_AUTO_PILOT\n else{//I'm pretty sure this is how google cars steer\n  ;float d=gd(p.xyz)\n  ;newp=qmulv(qrot,vec3(d,0,0))\n  ;float d2=gd(p.xyz+newp)\n  ;m.x=sign(d2-d)*ROTATE/(.1+2.*d*d)\n ;}\n #endif\n ;vec4 qp=qpyr(vec3(m.yx*ROTATE,roll))\n ;qrot=normalize(qmulq(qrot,qp))//normalize before saving\n;}\n;store(0,p,o,u)//position,velocity\n;store(1,qrot,o,u)//rotation\n;}\n\nvoid mainImage(out vec4 o,vec2 u){\n;if(all(lessThan(u,vec2(2.5,1.5))))steer(o,u)\n;else o=mainImage2(o,u); \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}