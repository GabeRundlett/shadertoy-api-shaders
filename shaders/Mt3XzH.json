{
    "Shader": {
        "info": {
            "date": "1478103796",
            "description": "I've planned to do a \"write a shader a day\" thing for a while, ideally a whole month. But every month seems to have something in the way :D\n\nSo, let's just do it. I'll miss days. So what.",
            "flags": 0,
            "hasliked": 0,
            "id": "Mt3XzH",
            "likes": 17,
            "name": "The Daily Shade, day 1: Fokeh",
            "published": 3,
            "tags": [
                "bokeh",
                "raytrace",
                "daily"
            ],
            "usePreview": 0,
            "username": "psonice",
            "viewed": 2146
        },
        "renderpass": [
            {
                "code": "// Day 1: Get some basic raymarcher working. \n// Or... no, let's do some kind of fake bokeh thing, I've not done that before.\n\n// A camera. Has a position and a direction. \nstruct Camera {\n    vec3 pos;\n    vec3 dir;\n};\n    \n// A ray. Has origin + direction.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \n// A disk. Has position, size, colour.\nstruct Disk {\n    vec3 pos;\n    float radius;\n    vec3 col;\n};\n        \n    vec4 intersectDisk(in Ray ray, in Disk disk, in float focalPoint) {\n        // Move ray to Z plane of disk\n        ray.origin += ray.dir * disk.pos.z;\n        \n        // Find distance from ray to disk (only xy needs considering since they have equal Z)\n        float dist = length(ray.origin.xy - disk.pos.xy);\n        \n        // blur depends on distance from focal point\n        float blurRadius = abs(focalPoint - disk.pos.z) * 0.1;\n        \n        // Calculate alpha component, using blur radius and disk radius\n        float alpha = 1. - smoothstep(max(0., disk.radius - blurRadius), disk.radius + blurRadius, dist);\n       \n        // Limit to 50% opacity\n        alpha *= 0.3;\n       \t\n        // Pre-multiply by alpha and return\n        return vec4(disk.col * alpha, alpha);\n    }\n\n// Normalised random number, borrowed from Hornet's noise distributions: https://www.shadertoy.com/view/4ssXRX\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We'll need a camera. And some perspective.\n    \n\t// Get some coords for the camera angle from the frag coords. Convert to -1..1 range.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    \n    // Aspect correction so we don't get oval bokeh\n    uv.y *= iResolution.y/iResolution.x;\n    \n    // Make a camera at 0,0,0 pointing forwards\n    Camera cam = Camera(vec3(0, 0, 0.), vec3(0, 0, 1));\n                        \n    // Find the ray direction. Simple in this case.\n    Ray ray = Ray(cam.pos, normalize(cam.dir + vec3(uv, 0)));\n    \n    // Cast the ray into the scene, intersect it with bokeh disks.\n    // I'm using a float since the loop is simple and it avoids a cast (costly on some platforms)\n    const float diskCount = 100.;\n    \n    // Set the focal point\n    float focalPoint = 2.0;\n    \n    // Create an empty colour\n    vec4 col = vec4(0.);\n    \n    float time = iTime * 0.1;\n    \n    for (float i=0.0; i<diskCount; i++) {\n        // random disk position\n        vec3 diskPos = vec3(\n            sin(i*(nrand(vec2(i-3., i + 1.)) + 1.) + time),\n            sin(i*(nrand(vec2(i-2., i + 2.)) + 2.) + time * 0.9), \n            sin(i*(nrand(vec2(i-1., i + 3.)) + 2.) + time * 0.9) * 5. + 5.5\n            );\n        \n        // Scale x+y by z so it fills the space a bit more nicely\n        diskPos.xy *= diskPos.z*0.7;\n        \n        // random disk colour\n        vec3 diskCol = vec3(\n            sin(i) * 0.25 + 0.75,\n            sin(i + 4.) * 0.25 + 0.55,\n            sin(i + 8.) * 0.25 + 0.65\n        );\n        \n        // random disk size\n        float diskSize = nrand(vec2(i)) * 0.2 + 0.1;\n        \n        // create the disk\n        Disk disk = Disk(diskPos, diskSize, diskCol);\n        \n        // Intersect the disk\n        vec4 result = intersectDisk(ray, disk, focalPoint);\n        \n        // Add the colour in\n       col += result;\n    }\n    \n\tfragColor = vec4(col.rgb,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}