{
    "Shader": {
        "info": {
            "date": "1627540859",
            "description": "More 2D physics stuff.",
            "flags": 32,
            "hasliked": 0,
            "id": "slSXDh",
            "likes": 13,
            "name": "Triangle - Moment of Inertia",
            "published": 3,
            "tags": [
                "2d",
                "triangle",
                "physics",
                "inertia",
                "momentofinertia"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 175
        },
        "renderpass": [
            {
                "code": "// See https://www.desmos.com/calculator/l9ipcrouvp\n// I feel like this should be simpler\n\n// My process:\n// 1. Split the triangle into to wedge segments that meet at on a horizontal line\n// 2. Integrate a slice of each wedge along the x axis (bounds vary linearly with the y coordinate)\n// 3. Integrate along the height of the wedge segments in the y axis\n// 4. Combine the inertia for both segments\n\n// SDFs\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nfloat sdTriangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 ba = b - a, cb = c - b, ac = a - c;\n    vec2 pa = p - a, pb = p - b, pc = p - c;\n\n    float abc = ba.x * cb.y - ba.y * cb.x;\n    float abp = ba.x * pa.y - ba.y * pa.x;\n    float bcp = cb.x * pb.y - cb.y * pb.x;\n    float cap = ac.x * pc.y - ac.y * pc.x;\n\n    vec2 ae = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec2 be = pb - cb * clamp(dot(pb, cb) / dot(cb, cb), 0.0, 1.0);\n    vec2 ce = pc - ac * clamp(dot(pc, ac) / dot(ac, ac), 0.0, 1.0);\n\n    float tri = sqrt(min(dot(ae, ae), min(dot(be, be), dot(ce, ce))));\n    return -tri * sign(min(abp, min(bcp, cap)) * max(abp, max(bcp, cap)));\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float ang = texelFetch(iChannel0, ivec2(0), 0).x;\n    float co = cos(ang), si = sin(ang);\n    mat2 rot = mat2(co, si, -si, co);\n\n    vec2 a = A * rot;\n    vec2 b = B * rot;\n    vec2 c = C * rot;\n\n    float tri = sdTriangle(uv, a, b, c);\n    drawSDF(tri, vec3(1.0, 0.0, 0.0));\n    drawSDF(abs(tri), vec3(1.0, 0.8, 0.0));\n    drawSDF(length(uv) - 0.05, vec3(1.0, 0.8, 0.0));\n\n    float aspect = iResolution.x / iResolution.y;\n    color = digitIn(color, vec3(1.0), uv * 0.25 + vec2(0.45 * aspect, 0.45), 100.0, triangleInertia(A, B, C));\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Triangle settings\n#define SCALE (iTime > 13.0 ? 1.0 + 0.5 * cos(iTime - 13.0 - 1.57) : 1.0)\n#define A (vec2(0.799, 2.088) * SCALE)\n#define B (vec2(-1.075, -0.307) * SCALE)\n#define C (vec2(0.405, -0.442) * SCALE)\n#define DENSITY 0.1\n\n// Simulation settings\n#define FRICTION 0.98\n#define GRAVITY 0.2\n\n// cross3D(vec3(a.x, a.y, 0), vec3(b.x, b.y, 0))\n// Since the x and y components of the result are always zero\n// The z component is the only one of interest\nfloat cross2D(in vec2 a, in vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat triangleMass(in vec2 a, in vec2 b, in vec2 c, in float density) {\n    return 0.5 * abs(cross2D(b - a, c - a)) * density;\n}\n\n// Moment of inertia of a triangle with vertices a, b, and c\n// The rotation axis is assumed to be at (0, 0). You can change\n// it by translating the triangle's vertices. Obviously, horizontal\n// and vertical edges pose an issue, this can be avoided by nudging\n// the vertices or rotating them about (0, 0) (such a rotation will\n// not change the moment of inertia)\n#define pow3(x) x * x * x\n#define pow4(x) x * x * x * x\n#define swap(a, b) { tmp = a, a = b, b = tmp; }\nfloat triangleInertia(in vec2 a, in vec2 b, in vec2 c) {\n    vec2 low = a, mid = b, high = c, tmp; // Sort vertices by y coordinate\n    if (mid.y < low.y) swap(low, mid);\n    if (high.y < mid.y) {\n        if (high.y < low.y) swap(low, high);\n        swap(mid, high);\n    }\n\n    vec2 mid2 = low + (high - low) * (mid.y - low.y) / (high.y - low.y); // Point on the edge across from the middle vertex in y\n    vec4 split = mid2.x < mid.x ? vec4(mid2, mid) : vec4(mid, mid2);\n\n    // Lower wedge segment (1 is left, 2 is right) ---> an*y+bn\n    float a1 = (split.x - low.x) / (split.y - low.y);\n    float b1 = low.x - (split.x - low.x) / (split.y - low.y) * low.y;\n    float a2 = (split.z - low.x) / (split.w - low.y);\n    float b2 = low.x - (split.z - low.x) / (split.w - low.y) * low.y;\n\n    // Upper wedge segment (3 is left, 4 is right) ---> an*y+bn\n    float a3 = (high.x - split.x) / (high.y - split.y);\n    float b3 = split.x - (high.x - split.x) / (high.y - split.y) * split.y;\n    float a4 = (high.x - split.z) / (high.y - split.w);\n    float b4 = split.z - (high.x - split.z) / (high.y - split.w) * split.w;\n\n    // Combine both segments' moments of inertia\n    float I  = (1.0 / a2 - 1.0 / a4) * pow4(split.z) + (1.0 / a3 - 1.0 / a1) * pow4(split.x);\n          I += (1.0 / a1 - 1.0 / a2) * pow4(  low.x) + (1.0 / a4 - 1.0 / a3) * pow4( high.x);\n\n    I += 3.0 * ((a2 - a1) * (pow4(mid.y) - pow4(low.y)) + (a4 - a3) * (pow4(high.y) - pow4(mid.y)));\n    I += 4.0 * ((b2 - b1) * (pow3(mid.y) - pow3(low.y)) + (b4 - b3) * (pow3(high.y) - pow3(mid.y)));\n\n    return I / 12.0;\n}\n\n        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"little debugging font\"                                   // //\n     //                                                            //  //\n    //  This utility uses a small bitmapped font (3x5) to render  //   //\n   //  floats, primarily intended for debugging. The code can    //    //\n  //  be copy/pasta'd into the Common tab as needed.            //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\nconst int CHARACTERS[14] = int[14](31599, 9362, 31183, 31207, 23524, 29671, 29679, 30994, 31727, 31719, 1488, 448, 2, 3640);\n\nfloat digitIsOn(in int digit, in vec2 id) {   \n    if (id.x < 0.0 || id.y < 0.0 || id.x > 2.0 || id.y > 4.0 ) return 0.0;\n    return floor(mod(float(CHARACTERS[int(digit)]) / pow(2.0, id.x + id.y * 3.0), 2.0));\n}\n\nfloat digitSign(in float v, in vec2 id) {\n    return digitIsOn(10 - int((sign(v) - 1.0) * 0.5), id);\n}\n\nint digitCount(in float v) {\n    return int(floor(log(max(v, 1.0) ) / log(10.0)));\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v, in int decimalPlaces) {\n    vec2 id = floor(uv * scale);\n\n    if (0.0 < digitSign(v, id)) return 1.0;\n    v = abs(v);\n\n    int digits = digitCount(v);\n    float power = pow(10.0, float(digits));\n    \n    float offset = floor(0.1 * scale);\n    id.x -= offset;\n\n    float n;\n    for (int i = 0; i < 33; i++, id.x -= offset, v -= power * n, power /= 10.0) {\n        n = floor(v / power);\n        if (0.0 < digitIsOn(int(n), id)) return 1.0;   \n        if (i == digits) {\n            id.x -= offset;\n            if (0.0 < digitIsOn(int(12), id)) return 1.0;\n        }\n\n        if (i >= digits + decimalPlaces) return 0.0;\n    }\n\n    return 0.0;\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v) {\n    return digitFirst(uv, scale, v, 3);\n}\n\nvec3 digitIn(in vec3 color, in vec3 toMix, in vec2 uv, in float scale, in float v) {\n    float f = digitFirst(uv, scale, v);\n    return mix(color, toMix, f);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 data, in vec2 addr) {\n    data = vec4(0.0);\n    addr -= 0.5;\n    ivec2 iAddr = ivec2(addr);\n    if (iFrame > 0 && iAddr == ivec2(0)) {\n        data = texelFetch(iChannel0, ivec2(0), 0);\n\n        float ang = texelFetch(iChannel0, ivec2(0), 0).x;\n        float co = cos(ang), si = sin(ang);\n        mat2 rot = mat2(co, si, -si, co);\n\n        vec2 a = A * rot;\n        vec2 b = B * rot;\n        vec2 c = C * rot;\n\n        vec2 centerOfMass = (a + b + c) / 3.0;\n\n        vec2 force = vec2(0.0, -triangleMass(A, B, C, DENSITY) * GRAVITY);\n        float torque = cross2D(-centerOfMass, force);\n\n        data.y += torque / triangleInertia(A, B, C);\n        data.y *= FRICTION;\n        data.x += data.y;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}