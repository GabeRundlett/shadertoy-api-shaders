{
    "Shader": {
        "info": {
            "date": "1466769472",
            "description": ":D\nThanks to cabbio for his nice tutorial! https://www.shadertoy.com/view/Xl2XWt",
            "flags": 0,
            "hasliked": 0,
            "id": "lsVSDK",
            "likes": 5,
            "name": "My first ray marching shader :D",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "simple"
            ],
            "usePreview": 0,
            "username": "Jespertheend",
            "viewed": 825
        },
        "renderpass": [
            {
                "code": "const float FAR_CLIPPING = 10.0;\nconst float HIT_PRECISION = 0.001;\nconst int MAX_RAY_STEPS = 100;\n\nfloat sdSphere(vec3 p, float s){\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU(vec2 d1, vec2 d2){\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map(vec3 pos){\n    float bigColor = (cos(pos.x*40.)*.5)*10.;\n    bigColor = min(1.,max(0.,bigColor));\n    bigColor *= .3-pos.y*.5;\n    vec2 res = vec2( sdSphere(pos, 1.), bigColor);\n    for(int i=0; i<60; i++){\n        float rot = float(i);\n        const float dist = 1.4;\n        vec3 spherePos = vec3(cos(rot)*dist, cos(rot*87.), sin(rot)*dist);\n        res = opU(res, vec2( sdSphere(pos - spherePos, .1), pos.y*.5+.5));\n    }\n    return res;\n}\n\nvec2 checkRayHit(in vec3 pos, in vec3 dir){\n    float h = HIT_PRECISION*2.;\n    float t = 0.;\n    float res = -1.;\n    float id = -1.;\n    \n    for(int i=0; i<MAX_RAY_STEPS; i++){\n        if(h < HIT_PRECISION || t > FAR_CLIPPING) break;\n        vec2 m = map(pos+dir*t);\n        t += m.x;\n        id = m.y;\n    }\n    \n    if(t<FAR_CLIPPING) res = t;\n    if(t>FAR_CLIPPING) id = -1.;\n    \n    return vec2(res,id);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll ){\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nconst float CAM_DIST = 3.;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    float camRot = iTime + iMouse.x*.01;\n    \n    vec3 camPos = vec3(cos(camRot)*CAM_DIST, 0., sin(camRot)*CAM_DIST);\n    mat3 camMat = calcLookAtMatrix(camPos, vec3(0.,0.,0.), 0.);\n    vec3 ray = normalize(camMat * vec3(uv.xy,2.));\n    vec2 res = checkRayHit(camPos, ray);\n    vec3 color = vec3(res.y);\n    fragColor = vec4(color,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}