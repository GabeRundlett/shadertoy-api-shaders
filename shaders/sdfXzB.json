{
    "Shader": {
        "info": {
            "date": "1618781836",
            "description": "Выполненное второе задание по машграфу",
            "flags": 32,
            "hasliked": 0,
            "id": "sdfXzB",
            "likes": 1,
            "name": "Taskkk 2",
            "published": 3,
            "tags": [
                "mashgraph"
            ],
            "usePreview": 0,
            "username": "zhgulden",
            "viewed": 231
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenUV = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, screenUV) / float(iFrame + 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float INF = 1e9;\nconst float SPHERE_R = 1.0;\nconst vec3 CAMERA_POS = vec3(3, 2.2, -6);\nconst vec3 LIGHT_POS = vec3(2, 1.5, 0);\nconst float LIGHT_RADIUS = 0.25;\nconst vec4 LIGHT_COLOR = vec4(1, 1, 1, 1);\n\nconst vec3 LIGHT2_POS = vec3(-2, 0.5, 2);\nconst float LIGHT2_RADIUS = 0.25;\nconst vec4 LIGHT2_COLOR = vec4(0.1, 0.7, 0.1, 1);\n\n\n// TRACE FUNCTIONS\nfloat tracePolygon(vec3 pos, vec3 dir, vec3 v0, vec3 v1, vec3 v2, out vec3 normal)\n{\n    // Polygon interception with v = pos + t*dir\n    // \n    // Read more about method here: \n    // http://masters.donntu.org/2015/frt/yablokov/library/transl.htm\n    // result = (t, u, v) \n    \n    vec3 result;\n    \n    vec3 T  = pos - v0;\n    vec3 E1 = v1  - v0;\n    vec3 E2 = v2  - v0;\n    \n    vec3 P  = cross(dir, E2);\n    vec3 Q  = cross(T,   E1);\n    \n    \n    float det = dot(P, E1);\n    \n    float t = dot(Q, E2) / det;\n    float u = dot(P, T)  / det;\n    float v = dot(Q, dir) /det ;\n    \n    \n    float A = (v1.y-v0.y)*(v2.z-v0.z) - (v2.y-v0.y)*(v1.z-v0.z);\n    float B = (v1.z-v0.z)*(v2.x-v0.x) - (v2.z-v0.z)*(v1.x-v0.x);\n    float C = (v1.x-v0.x)*(v2.y-v0.y) - (v2.x-v0.x)*(v1.y-v0.y);\n    \n    normal.x = A;\n    normal.y = B;\n    normal.z = C;\n    \n    normal = normalize(normal);\n    \n    if( u >= 0.0 && v >= 0.0 && u + v <= 1.0 && t > 0.0)\n        return t;\n    \n    return INF;\n}\nfloat traceCube(vec3 pos, vec3 dir, float size, vec3 shift, out vec3 normal)\n{\n    float scaleCube = size/2.0;\n\n    int minIndex = 0;\n\n    vec3 normal1;\n    vec3 normal2; \n    vec3 normal3; \n    vec3 normal4; \n    vec3 normal5; \n    vec3 normal6; \n    vec3 normal7; \n    vec3 normal8; \n    vec3 normal9;\n    vec3 normal10;\n    vec3 normal11;\n    vec3 normal12;\n    \n    \n    \n    \n    vec3 v1 = vec3(shift.x - scaleCube, shift.y - scaleCube, shift.z + scaleCube);\n    vec3 v2 = vec3(shift.x + scaleCube, shift.y - scaleCube, shift.z + scaleCube);\n    vec3 v3 = vec3(shift.x + scaleCube, shift.y + scaleCube, shift.z + scaleCube);\n    vec3 v4 = vec3(shift.x - scaleCube, shift.y + scaleCube, shift.z + scaleCube);\n    vec3 v5 = vec3(shift.x + scaleCube, shift.y - scaleCube, shift.z - scaleCube);\n    vec3 v6 = vec3(shift.x + scaleCube, shift.y + scaleCube, shift.z - scaleCube);\n    vec3 v7 = vec3(shift.x - scaleCube, shift.y + scaleCube, shift.z - scaleCube);\n    vec3 v8 = vec3(shift.x - scaleCube, shift.y - scaleCube, shift.z - scaleCube);\n    \n    \n    float T1  = tracePolygon (pos, dir, v1, v2, v3, normal1);\n    float T2  = tracePolygon (pos, dir, v1, v3, v4, normal2);\n    \n    float T3  = tracePolygon (pos, dir, v1, v2, v5, normal3);\n    float T4  = tracePolygon (pos, dir, v1, v5, v8, normal4);\n    \n    float T5  = tracePolygon (pos, dir, v2, v3, v5, normal5);\n    float T6  = tracePolygon (pos, dir, v3, v5, v6, normal6);\n    \n    float T7  = tracePolygon (pos, dir, v5, v6, v7, normal7);\n    float T8  = tracePolygon (pos, dir, v5, v7, v8, normal8);\n    \n    float T9  = tracePolygon (pos, dir, v1, v4, v7, normal9);\n    float T10 = tracePolygon (pos, dir, v1, v7, v8, normal10);\n    \n    float T11 = tracePolygon (pos, dir, v3, v4, v6, normal11);\n    float T12 = tracePolygon (pos, dir, v4, v6, v7, normal12);\n    \n    \n    \n    \n    \n    //find min of all this triagles and minIndex\n    vec3[]  arrayN = vec3[] ( normal1,normal2,normal3,normal4,normal5,normal6,normal7,normal8,normal9,normal10,normal11,normal12 );\n    float[] arrayD = float[](   T1,     T2,     T3,     T4,     T5,     T6,     T7,     T8,     T9   ,  T10,     T11,     T12    );\n \n \n    float minT = arrayD[0];\n    \n    for (int i = 1; i < 12; i++)\n \n        if (minT > arrayD[i])\n        {\n            minT = arrayD[i];\n            minIndex = i;\n        }\n    \n    \n    \n    \n    // Output values\n    normal = arrayN[minIndex];\n    return arrayD[minIndex];\n    \n    \n    \n\n    //return INF;\n}\nfloat traceSphere(vec3 pos, vec3 dir, float R, out vec3 normal) {\n    // abs(pos + t * dir) = r\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t = r * r\n    // D = 4 * dot(pos, dir) ^ 2 - 4 * (dot(pos, pos) - r * r)\n    float b = dot(pos, dir);\n    float D = b * b - (dot(pos, pos) - R * R);\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = (-b - sqrt(D));\n    if (t < 0.0)\n        t = (-b + sqrt(D));\n    if (t < 0.0)\n        return INF;\n    vec3 wPos = pos + t * dir;\n    normal = normalize(wPos);\n    return t;\n}\nfloat traceOctahedron(vec3 pos, vec3 dir, float size, vec3 shift, out vec3 normal)\n{\n    float scaleOcta = 1.0/ size;\n    \n    int minIndex = 0;// index of intercepted triagle (from 0 to 7)\n    \n    vec3 normal1;\n    vec3 normal2; \n    vec3 normal3; \n    vec3 normal4; \n    vec3 normal5; \n    vec3 normal6; \n    vec3 normal7; \n    vec3 normal8; \n    \n    \n    \n    ///*\n    vec3 v1 = vec3(shift.x - scaleOcta, shift.y             , shift.z);\n    vec3 v2 = vec3(shift.x            , shift.y - scaleOcta , shift.z);\n    vec3 v3 = vec3(shift.x+scaleOcta  , shift.y             , shift.z);\n    vec3 v4 = vec3(shift.x            , shift.y+scaleOcta   , shift.z);\n    vec3 v5 = vec3(shift.x            , shift.y             , shift.z+scaleOcta);\n    vec3 v6 = vec3(shift.x            , shift.y             , shift.z-scaleOcta);\n    \n    \n    float T1 = tracePolygon (pos, dir, v1, v2, v5, normal1);\n    float T2 = tracePolygon (pos, dir, v2, v3, v5, normal2);\n    float T3 = tracePolygon (pos, dir, v3, v4, v5, normal3);\n    float T4 = tracePolygon (pos, dir, v4, v1, v5, normal4);\n    float T5 = tracePolygon (pos, dir, v1, v2, v6, normal5);\n    float T6 = tracePolygon (pos, dir, v2, v3, v6, normal6);\n    float T7 = tracePolygon (pos, dir, v3, v4, v6, normal7);\n    float T8 = tracePolygon (pos, dir, v4, v1, v6, normal8);\n    //*/\n\n    \n    \n    //find min\n    vec3[]  arrayN = vec3[] ( normal1,normal2,normal3,normal4,normal5,normal6,normal7,normal8 );\n    float[] arrayD = float[](   T1,     T2,     T3,     T4,     T5,     T6,     T7,     T8    );\n \n \n    float minT = arrayD[0];\n    \n    for (int i = 1; i < 8; i++)\n \n        if (minT > arrayD[i])\n        {\n            minT = arrayD[i];\n            minIndex = i;\n        }\n    \n    \n    \n    \n    // Output \n    normal = arrayN[minIndex];\n    return arrayD[minIndex];\n    \n    \n    \n}\nfloat traceCylinder(vec3 pos, vec3 dir, inout vec3 normal) {\n    const float R = 2.0f;\n    const float H = 0.1f;\n    float floorT = (-1.0 - pos.y) / dir.y;\n    if (floorT < 0.0)\n        return INF;\n    vec3 finalPos = pos + dir * floorT;\n    if (dot(finalPos.xz, finalPos.xz) < R * R) {\n        normal = vec3(0, 1, 0);\n        return floorT;\n    }\n    \n    float b = dot(pos.xz, dir.xz);\n    float a = dot(dir.xz, dir.xz);\n    float D = b * b - (dot(pos.xz, pos.xz) - R * R) * a;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = (-b - sqrt(D)) / a;\n    if (pos.y + t * dir.y < -1.0) {\n        vec3 wPos = pos + t * dir;\n        normal = normalize(vec3(wPos.x, 0, wPos.z));\n        return t;\n    }\n    \n    return INF;\n}\n\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nbool isOccluded(vec3 pos, vec3 target) {\n    vec3 rvec = target - pos;\n    float dist = length(rvec);\n    vec3 dir = rvec / dist;\n    \n    vec3 normal = vec3(0, 0, 0);\n    \n    float t = traceSphere(pos, dir, SPHERE_R, normal);\n    if (dist >= t) {\n        return true;\n    }\n    \n    \n    vec3 octahedronNormal;\n    float octahedronT = traceOctahedron(pos, dir, 1.0, vec3(1.0, 0.0, 3.0), octahedronNormal);\n    if(octahedronT < dist)\n        return true;\n    \n    vec3 cylNormal = normal;\n    t = traceCylinder(pos, dir, cylNormal);\n    return (t > 0.0 && dist >= t);\n}\n\nvec3 refraction(vec3 v_in, vec3 normal, float n1, float n2) {\n    if (dot(v_in, normal) < 0.0)\n        normal = -normal;\n    float cosA = dot(v_in, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v_in - cosA * normal);\n    float sinB = n1 * sinA / n2;\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return tang * sinB + normal * cosB;\n}\n\nfloat pow2(float x) {\n    return x * x;\n}\n\nfloat fogSdf(vec3 pos)\n{\n    return length(pos) - 0.75;\n}\n\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled)\n{\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\n\nvec4 sampleFog(vec3 pos, vec3 dir)\n{\n    float t = fogSdf(pos);\n    const float MARCH_SIZE = 0.01;\n    float opacity = 1.0;\n    float absorption = 10.0;\n    float totalAbs = 0.0;\n    for (int i = 0; i < 50; ++i) {\n        vec3 curPos = pos + (float(i) * MARCH_SIZE + t) * dir;\n        float sdf = fogSdf(curPos);\n        if (sdf < 0.0) {\n            float prevOpacity = opacity;\n            opacity *= BeerLambert(absorption * (\n            texture(iChannel3, curPos * 0.2).x\n            + texture(iChannel3, curPos * 0.4).x\n            + texture(iChannel3, curPos * 0.8).x\n            + texture(iChannel3, curPos * 1.6).x\n            ) * 0.25 * abs(sdf), MARCH_SIZE);\n            float absorptionLastStep = prevOpacity - opacity;\n            totalAbs += absorptionLastStep;\n        }\n    }\n    \n    vec3 color;\n    vec3 v = pos + t*dir;\n    \n    float R1 = 0.50;\n    float R2 = 0.74;\n    float R3 = 0.99;\n    \n    \n    int n = 10;\n    float rad;\n    \n    for (int i = 0 ; i < n; i++){\n    \n        rad = R3 - float(i)/float(n-1)*(R3-R1);\n        \n        //if( pow2(v.x) + pow2(v.y) + pow2(v.z) < pow2(rad))\n            color = vec3(1.0, (rad - R1)/(R3-R1), 0  );\n    }\n    return vec4(5.0*color * totalAbs, 1.0 - opacity);\n}\n\nvec3 randVals;\nvec3 randDir;\n\nvec3 computeLighting(vec3 worldPos, vec3 color, vec3 normal, vec3 viewVec) {\n    vec3 lightPos = LIGHT_POS + randDir * LIGHT_RADIUS;\n    vec3 toLight = lightPos - worldPos;\n    bool occl = isOccluded(worldPos + normalize(toLight) * 1e-3, lightPos);\n    float lightAtten = 20.0f / dot(toLight, toLight) * (occl ? 0.0 : 1.0);\n\n    vec3 light2Pos = LIGHT2_POS + randDir * LIGHT2_RADIUS;\n    vec3 toLight2 = light2Pos - worldPos;\n    bool occl2 = isOccluded(worldPos + normalize(toLight2) * 1e-3, light2Pos);\n    float light2Atten = 10.0f / dot(toLight2, toLight2) * (occl2 ? 0.0 : 1.0);\n\n    return color * (\n        max(0.0f, dot(normal, normalize(toLight))) * lightAtten * LIGHT_COLOR\n        + max(0.0f, dot(normal, normalize(toLight2))) * light2Atten * LIGHT2_COLOR\n        + textureLod(iChannel0, viewVec, 10.0) * 0.3\n    ).rgb;\n}\n\n\n\n//FIRE\n\n#define saturate(oo) clamp(oo, 0.0, 1.0)\n\n// Quality Settings\n#define MarchSteps 8\n// Scene Settings\n#define ExpPosition vec3(0.0)\n#define Radius 2.0\n#define Background vec4(0.1, 0.0, 0.0, 1.0)\n// Noise Settings\n#define NoiseSteps 1\n#define NoiseAmplitude 0.06\n#define NoiseFrequency 4.0\n#define Animation vec3(0.0, -3.0, 0.5)\n// Colour Gradient\n#define Color1 vec4(1.0, 1.0, 1.0, 1.0)\n#define Color2 vec4(1.0, 0.8, 0.2, 1.0)\n#define Color3 vec4(1.0, 0.03, 0.0, 1.0)\n#define Color4 vec4(0.05, 0.02, 0.02, 1.0)\n\n\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v)\n{\n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0);\n\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\t// First corner\n\tvec3 i  = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\t// Other corners\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\t// Permutations\n\ti = mod289(i);\n\tvec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3  ns = n_ * D.wyz - D.xzx;\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_);    // mod(j,N)\n\tvec4 x = x_ *ns.x + ns.yyyy;\n\tvec4 y = y_ *ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n\t//Normalise gradients\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\t// Mix final noise value\n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\tm = m * m;\n\treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat Turbulence(vec3 position, float minFreq, float maxFreq, float qWidth)\n{\n\tfloat value = 0.0;\n\tfloat cutoff = clamp(0.5/qWidth, 0.0, maxFreq);\n\tfloat fade;\n\tfloat fOut = minFreq;\n\tfor(int i=NoiseSteps ; i>=0 ; i--)\n\t{\n\t\tif(fOut >= 0.5 * cutoff) break;\n\t\tfOut *= 2.0;\n\t\tvalue += abs(snoise(position * fOut))/fOut;\n\t}\n\tfade = clamp(2.0 * (cutoff-fOut)/cutoff, 0.0, 1.0);\n\tvalue += fade * abs(snoise(position * fOut))/fOut;\n\treturn 1.0-value;\n}\n\nfloat SphereDist(vec3 position)\n{\n\treturn length(position - ExpPosition) - Radius;\n}\n\nvec4 Shade(float distance)\n{\n\tfloat c1 = saturate(distance*5.0 + 0.5);\n\tfloat c2 = saturate(distance*5.0);\n\tfloat c3 = saturate(distance*3.4 - 0.5);\n\tvec4 a = mix(Color1,Color2, c1);\n\tvec4 b = mix(a,     Color3, c2);\n\treturn \t mix(b,     Color4, c3);\n}\n\n// Draws the scene\nfloat RenderScene(vec3 position, out float distance)\n{\n\tfloat noise = Turbulence(position * NoiseFrequency + Animation*iTime, 0.1, 1.5, 0.03) * NoiseAmplitude;\n\tnoise = saturate(abs(noise));\n\tdistance = SphereDist(position) - noise;\n\treturn noise;\n}\n\n// Basic ray marching method.\nvec4 March(vec3 rayOrigin, vec3 rayStep)\n{\n\tvec3 position = rayOrigin;\n\tfloat distance;\n\tfloat displacement;\n\tfor(int step = MarchSteps; step >=0  ; --step)\n\t{\n\t\tdisplacement = RenderScene(position, distance);\n\t\tif(distance < 0.05) break;\n\t\tposition += rayStep * distance;\n\t}\n\treturn mix(Shade(displacement), Background, float(distance >= 0.5));\n}\n\nbool IntersectSphere(vec3 ro, vec3 rd, vec3 pos, float radius, out vec3 intersectPoint)\n{\n\tvec3 relDistance = (ro - pos);\n\tfloat b = dot(relDistance, rd);\n\tfloat c = dot(relDistance, relDistance) - radius*radius;\n\tfloat d = b*b - c;\n\tintersectPoint = ro + rd*(-b - sqrt(d));\n\treturn d >= 0.0;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenUV = fragCoord/iResolution.xy;\n    randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals * 2.0 - 1.0);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5) * 2.0)/iResolution.x;\n\n    vec3 forward = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    vec3 viewVec = normalize(forward + uv.x * right + uv.y * up);\n\n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    float curN = 1.0;\n    float nextN = GLASS_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    float GLASS_T = 1.0 - GLASS_R;\n\n    vec3 currentPos = CAMERA_POS;\n    \n    const int EMISSION = 0;\n    const int DIFFUSE = 1;\n    const int REFLECTION = 2;\n    const int REFRACTION = 3;\n    int iterationType;\n    vec3 color;\n    float mult = 1.0;\n\n    // Output to screen\n    for (int i = 0; i < 7; ++i) {\n        vec3 normal = vec3(0, 0, 0);\n\n        float t = traceSphere(currentPos - LIGHT_POS, viewVec, LIGHT_RADIUS, normal);\n        if (t != INF) {\n            color = LIGHT_COLOR.rgb * 5.0;\n            iterationType = EMISSION;\n        }\n        \n        float l2_t = traceSphere(currentPos - LIGHT2_POS, viewVec, LIGHT2_RADIUS, normal);\n        if (t > l2_t) {\n            t = l2_t;\n            color = LIGHT2_COLOR.rgb;\n            iterationType = EMISSION;\n        }\n\n        float sphere_t = traceSphere(currentPos, viewVec, SPHERE_R, normal);\n        if (sphere_t < t) {\n            /*\n            if (GLASS_R > randVals.y) {\n                iterationType = REFLECTION;\n            } else {\n                iterationType = REFRACTION;\n            }\n            */\n            t = sphere_t;\n            iterationType = EMISSION;\n            color = March(currentPos, viewVec).rgb;\n        }\n        vec3 cylNormal = normal;\n        float cylT = traceCylinder(currentPos, viewVec, cylNormal);\n        if (cylT < t) {\n            t = cylT;\n            vec3 pos = currentPos + t * viewVec;\n            color = texture(iChannel1, pos.xz * pos.y).rgb;\n            normal = cylNormal;\n            iterationType = DIFFUSE;\n        }\n        \n        {\n            vec3 octahedron2Normal;\n\n            float octahedron2T  = traceOctahedron(currentPos, viewVec, 1.0, vec3(1.0, 0.5, 3.0), octahedron2Normal);\n            // If trace is intercept with octahedron then make t shorter and equal to distance between camera and table.\n            if (octahedron2T < t)\n            {\n                t = octahedron2T;\n                color = vec3(1.0,0.5,0.0);\n                normal = octahedron2Normal;\n\n                \n                iterationType = DIFFUSE;\n\n            }\n        }\n        \n        \n        {\n            vec3 cubeNormal;\n\n            float cubeT  = traceCube(currentPos, viewVec, 2.0, vec3(0.0, 0.0, 0.0), cubeNormal);\n            // If trace is intercept with octahedron then make t shorter and equal to distance between camera and table.\n            if (cubeT < t)\n            {\n                t = cubeT;\n                color = vec3(1.0,1.0,1.0);\n                normal = cubeNormal;\n\n                //combine reflection and refraction;\n                if(randVals.x*0.1 < GLASS_R)\n                    iterationType = REFLECTION;\n\n                else{\n                    iterationType = REFRACTION;\n                    // We need to know what is outside the object \n                    if( dot(viewVec, normal) > 0.0 )// they not oppodite directed\n                    {\n                        curN = AIR_N;\n                    }\n                    else // they opposite directed \n                    {\n                        curN = GLASS_N;\n\n                    }\n\n                }\n                //materialType = REFRACTION;\n\n            }\n        }\n        \n        \n        // (c + t * v).y = -1.2\n        // t = (-1.2 -c.y) / v.y\n        float floorT = (-1.2 - currentPos.y) / viewVec.y;\n        if (floorT > 0.0 && floorT < t && length(currentPos + floorT * viewVec) < 10.0f) {\n            t = floorT;\n            vec3 pos = currentPos + t * viewVec;\n            color = texture(iChannel2, pos.xz * 0.2).rgb;\n            normal = vec3(0, 1, 0);\n            iterationType = DIFFUSE;\n            if(randVals.y < 0.29)\n                    iterationType = REFLECTION;\n        }\n        if (t != INF) {\n            if (iterationType == EMISSION) {\n                fragColor.rgb = color;\n                break;\n            } else if (iterationType == DIFFUSE) {\n                fragColor.rgb += mult * computeLighting(currentPos + t * viewVec, color, normal, viewVec);\n                break;\n            } else if (iterationType == REFLECTION) {\n                currentPos += viewVec * t;\n                fragColor.rgb += mult * computeLighting(currentPos + t * viewVec, color, normal, viewVec);\n                viewVec = reflect(viewVec, normal);\n                currentPos += viewVec * 1e-5;\n            } else if (iterationType == REFRACTION) {\n                currentPos += viewVec * t;\n                viewVec = refraction(viewVec, normal, curN, nextN);\n                currentPos += viewVec * 1e-5;\n                vec4 fog = sampleFog(currentPos, viewVec);\n                fragColor.rgb += fog.rgb * fog.a * mult;\n                mult *= 1.0 - fog.a;\n                float tmp = curN;\n                curN = nextN;\n                nextN = tmp;\n            }\n        } else {\n            fragColor += mult * texture(iChannel0, viewVec) * 0.3;\n            break;\n        }\n    }\n}   ",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenUV = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, screenUV) + texture(iChannel1, screenUV);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}