{
    "Shader": {
        "info": {
            "date": "1528584725",
            "description": "This started as a 2D thing with circles that became progressively more 3D as it developed.\n\nLight #1 can be controlled with the mouse.",
            "flags": 0,
            "hasliked": 0,
            "id": "4sKBRD",
            "likes": 4,
            "name": "Orthographic Sphere Shadows",
            "published": 3,
            "tags": [
                "spheres",
                "shadows"
            ],
            "usePreview": 0,
            "username": "ChrisK",
            "viewed": 652
        },
        "renderpass": [
            {
                "code": "//spheres and coloured lights from an orthographic projection, with analytical antialiasing and shadows.\n\n\n\n#define NUMBER_OF_SPHERES   20\n#define NUMBER_OF_LIGHTS    7\n#define SURFACE_BRIGHTNESS\t0.01\n\n\n//Disable SIMPLESCENE for performance gains in scenes with a greater numbers of lights and spheres\n#define SIMPLESCENE\n\n\nstruct light {\n\tvec3 pos;\n    vec3 col;\n};\n\n//hsl to rgb conversion adapted from https://gist.github.com/mjackson/5311256\nfloat hue2rgb( float p, float q, float h ) {\n\th = fract(h);\n    if(h<0.1616) return p+(q-p)*6.0*h;\n    else if(h<0.5) return q;\n    else if(h<0.666) return p+(q-p)*(0.666-h)*6.0;\n    else return p;\n}\n\n\nvec3 hsltorgb( vec3 hsl ) {\n    float h = hsl.x;\n    float s = hsl.y;\n    float l = hsl.z;\n\tfloat q = l<0.5 ? l*(1.0+s) : l+s-l*s;\n    float p = 2.0*l-q;\n    float r = hue2rgb(p, q, h+0.333);\n    float g = hue2rgb(p, q, h);\n    float b = hue2rgb(p, q, h-0.333);\n    return vec3(r,g,b);\n}\n    \n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash( float p ) {\n   vec3 p3 = fract(vec3(p) * vec3(0.1031,0.1030,0.0973));\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\nvec3 getnearestpointonlinesegment( vec3 pa, vec3 pb, vec3 t) {\n    vec3 l = pb-pa;\n    float h = clamp( dot(t-pa,l)/dot(l,l), 0.0, 1.0 );\t\n    return pa+l*h;\n}\n\n\nvec2 orbit( float r, float s, float p ) {\n    r *= sin(iTime*p);\n    s *= iTime;\n    return vec2( sin(s)*r, cos(s)*r );\n}\n\n\nfloat distancetocoverage( float d ) {\n    return clamp(d*iResolution.y, 0.0, 1.0);\n}\n\n\nfloat circle( vec2 uv, vec2 p, float r ) {\n    float d = r-distance(uv,p);\n    return distancetocoverage(d);\n}\n\n\nfloat sphereshadow( vec3 uv, vec3 lp, vec3 cp, float cr ) {\n\tvec3 np = getnearestpointonlinesegment(uv, lp, cp);\n    float d = cr-distance(np,cp);\n  \treturn distancetocoverage(d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec2 center = vec2(0.5*(iResolution.x/iResolution.y), 0.5);\n    \n    vec3 spheres[NUMBER_OF_SPHERES];\n    for (int i = 0; i<spheres.length(); i++ ) {\n        vec3 h = hash(float(i+500));\n        float px = h.x * iResolution.x/iResolution.y;\n        float py = h.y;\n        float r = mix(0.025, 0.1, h.z);\n    \tspheres[i] = vec3( px, py, r );\n    }\n    \n    light lights[NUMBER_OF_LIGHTS];\n    for (int i = 0; i<lights.length(); i++ ) {\n        vec3 h = hash(float(i+200));\n        float d = mix(0.25, 0.8, h.x);\t\t\t\t\t\t\t\t//orbital distance\n        float s = mix(0.12, 0.5, abs(h.y*2.0-1.0))*sign(h.y-0.5);\t//orbital speed\n        float p = mix(0.1, 0.35, h.z);\t\t\t\t\t\t\t\t//occilation speed\n        lights[i].pos = vec3(center+orbit(d,s,p), 0.101+sin(iTime+float(i))*0.1);\n\n        //vec3 hc = hash(float(i)+157.0);\n        //lights[i].col = hc*hc*hc;\n\t\tvec3 hsl = vec3( (float(i)+iTime*0.5)/float(NUMBER_OF_LIGHTS), 0.95, 0.2 );\n        lights[i].col = hsltorgb( hsl );\n    }\n    if(iMouse.w>0.0) lights[0].pos.xy=iMouse.xy/iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    \n    \n    \n    #ifdef SIMPLESCENE\n    \n    \n    \n    for ( int i = 0; i<lights.length(); i++ ) {\n        //get ground lighting\n        float f = dot(normalize(lights[i].pos-vec3(uv,0.0)), vec3(0.0,0.0,1.0));\t//Lambertian reflection from floor\n        for ( int j = 0; j<spheres.length(); j++ ) {\n            f *= 1.0 - sphereshadow( vec3(uv,0.0), lights[i].pos, vec3(spheres[j].xy,0.0), spheres[j].z );\n            if (f==0.0) break;\n        }\n        \n        float c = 0.0;\t\t\t//sphere lighting\n        float pz = 0.0;\t\t\t//height of pixel above floor plane\n        int id = -1;\t\t\t//index of sphere under pixel (-1 if there is none)\n        \n        //get sphere lighting\n        for ( int j = 0; j<spheres.length(); j++ ) {\n            if (distance(lights[i].pos, vec3(spheres[j].xy,0.0)) < spheres[j].z) {\n                break;\t//light is inside sphere\n            }\n            float p = distance(uv, spheres[j].xy);\n            float cz = sqrt(spheres[j].z*spheres[j].z-p*p);\t\t\t//height of pixel on sphere\n            if ( cz>pz ) {\n            \tpz = cz;\n                id = j;\n            \tvec3 nor = normalize(vec3(uv-spheres[j].xy, pz));\t//sphere normal\n        \t\tvec3 rd = normalize(lights[i].pos-vec3(uv,pz));\t\t\t//light ray direction (from surface to light)\n                float r = max(dot(rd, nor),0.0);\t\t\t\t\t//Lambertian reflection\n        \t\tc = r * circle(uv, spheres[j].xy, spheres[j].z);\t//multiply by circle coverage\n            }\n        }\n        \n        //if pixel is on a sphere, search for shadows cast on sphere\n        if ( id!=-1 && c>0.0 ) {\n        \tfor ( int j = 0; j<spheres.length(); j++ ) {\n                c *= 1.0 - sphereshadow( vec3(uv, pz), lights[i].pos, vec3(spheres[j].xy,0.0), spheres[j].z );\n        \t}\n        }\n        \n        col += ( (f + c) * SURFACE_BRIGHTNESS / pow(distance(vec3(uv, pz), lights[i].pos),2.0) ) * lights[i].col;\n    }\n    \n    \n    \n    #else\n    \n    \n    \n    int id = -1;\t\t\t\t\t\t//index of sphere under pixel (-1 if there is none)\n    float pz = 0.0;\t\t\t\t\t\t//height of pixel above floor plane\n    for (int i = 0; i<spheres.length(); i++ ) {\n        vec2 sr = spheres[i].xy-uv;\n        float cz = spheres[i].z*spheres[i].z - dot(sr, sr);\t\t//(pixel height on spheres[i]) ^ 2\n        if ( cz>pz*pz ) {\n        \tpz = sqrt(cz);\n            id = i;\n        }\n    }\n    \n    float coverage = 0.0;\t\t\t\t//sphere coverage of pixel\n    vec3 nor = vec3(0.0,0.0,1.0);\t\t//surface normal\n    if (id!=-1) {\n    \tcoverage = circle(uv, spheres[id].xy, spheres[id].z);\n        nor = normalize( vec3(uv-spheres[id].xy, pz) );\n    }\n    \n    for ( int i = 0; i<lights.length(); i++ ) {      \n        //get shadow coverage\n        float illumination = 1.0;\n        for ( int j = 0; j<spheres.length() && illumination>0.0; j++ ) {\n        \tillumination *= 1.0 - sphereshadow( vec3(uv,pz), lights[i].pos, vec3(spheres[j].xy,0.0), spheres[j].z );\n        }\n        \n        //pz = mix(0.0, pz, coverage);\n        //nor = mix( vec3(0.0,0.0,1.0), nor, coverage );\n        //nor = normalize(nor);\n        \n        vec3 rv = lights[i].pos-vec3(uv,pz);\n        vec3 rd = normalize(rv);\t\t\t\t\t//light ray direction (from surface to light)\n        float gr = max(rd.z,0.0) * (1.0-sphereshadow(vec3(uv,0.0),lights[i].pos,vec3(spheres[id].xy,0.0),spheres[id].z)); //Lambertian reflection from ground plane\n        //float gr = max(rd.z,0.0) * (1.0-coverage);\n        float sr = max(dot(rd, nor),0.0) * coverage;\t//Lambertian reflection from sphere surface\n        \n        float f = gr + sr;\n        f *= illumination * SURFACE_BRIGHTNESS / dot(rv,rv);\n        col += f * lights[i].col;\n    }\n    \n    \n    #endif\n    \n    col *= 2.0;\n    \n    //filmic tone mapping -- http://filmicworlds.com/blog/filmic-tonemapping-operators/\n    col = max(col-0.004, 0.0);\n    col = (col*(6.2*col+0.5))/(col*(6.2*col+1.7)+0.06);\n    \n    col += (hash(uv.x*uv.y*iTime*1000.0)-0.5) / 128.0;\t\t//grain\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}