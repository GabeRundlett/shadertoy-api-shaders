{
    "Shader": {
        "info": {
            "date": "1545519533",
            "description": "Greetings to everyone who make that thing via a simulation. Completely stateless and resolution independent. Count the number of corner hits and bounce. Click on the screen to change box size.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdsGRM",
            "likes": 7,
            "name": "DVD corner thingy",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "Klems",
            "viewed": 855
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n\nvec3 hue( in float c ) {\n    return cos(2.0*PI*c + 2.0*PI/3.0*vec3(3,2,1))*0.5+0.5;\n}\n\nint lcm( in int K, in int M ) {\n    int k = max(K, M);\n    int m = min(K, M);\n    while (m != 0) {\n        int r = k % m;\n        k = m;\n        m = r;\n    }\n    return K * M / k;\n}\n\n// Thanks P_Malin, see https://www.shadertoy.com/view/4sf3RN\nconst float kCharBlank = 12.0;\nconst float kCharMinus = 11.0;\nconst float kCharDecimalPoint = 10.0;\nfloat InRect( const in vec2 vUV, const in vec4 vRect ) {\n\tvec2 vTestMin = step(vRect.xy, vUV.xy);\n\tvec2 vTestMax = step(vUV.xy, vRect.zw);\t\n\tvec2 vTest = vTestMin * vTestMax;\n\treturn vTest.x * vTest.y;\n}\nfloat SampleDigit( const in float fDigit, const in vec2 vUV ) {\n\tconst float x0 = 0.0 / 4.0;\n\tconst float x1 = 1.0 / 4.0;\n\tconst float x2 = 2.0 / 4.0;\n\tconst float x3 = 3.0 / 4.0;\n\tconst float x4 = 4.0 / 4.0;\n\tconst float y0 = 0.0 / 5.0;\n\tconst float y1 = 1.0 / 5.0;\n\tconst float y2 = 2.0 / 5.0;\n\tconst float y3 = 3.0 / 5.0;\n\tconst float y4 = 4.0 / 5.0;\n\tconst float y5 = 5.0 / 5.0;\n\tvec4 vRect0 = vec4(0.0);\n\tvec4 vRect1 = vec4(0.0);\n\tvec4 vRect2 = vec4(0.0);\n\tif(fDigit < 0.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x1, y1, x2, y4);\n\t} else if(fDigit < 1.5) {\n\t\tvRect0 = vec4(x1, y0, x2, y5); \n        vRect1 = vec4(x0, y0, x0, y0);\n\t} else if(fDigit < 2.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x0, y3, x2, y4); \n        vRect2 = vec4(x1, y1, x3, y2);\n\t} else if(fDigit < 3.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x0, y3, x2, y4); \n        vRect2 = vec4(x0, y1, x2, y2);\n\t} else if(fDigit < 4.5) {\n\t\tvRect0 = vec4(x0, y1, x2, y5); \n        vRect1 = vec4(x1, y2, x2, y5); \n        vRect2 = vec4(x2, y0, x3, y3);\n\t} else if(fDigit < 5.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x1, y3, x3, y4); \n        vRect2 = vec4(x0, y1, x2, y2);\n\t} else if(fDigit < 6.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x1, y3, x3, y4); \n        vRect2 = vec4(x1, y1, x2, y2);\n\t} else if(fDigit < 7.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x0, y0, x2, y4);\n\t} else if(fDigit < 8.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x1, y1, x2, y2); \n        vRect2 = vec4(x1, y3, x2, y4);\n\t} else if(fDigit < 9.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x1, y3, x2, y4); \n        vRect2 = vec4(x0, y1, x2, y2);\n\t} else if(fDigit < 10.5) {\n\t\tvRect0 = vec4(x1, y0, x2, y1);\n\t} else if(fDigit < 11.5) {\n\t\tvRect0 = vec4(x0, y2, x3, y3);\n\t}\t\n\tfloat fResult = InRect(vUV, vRect0) + \n        InRect(vUV, vRect1) + InRect(vUV, vRect2);\n\treturn mod(fResult, 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // time multiplier\n    const float mul = 100.0;\n    // size of the box and size of the world\n    ivec2 iboxWidth = max(ivec2(iMouse.xy), ivec2(45, 30));\n    ivec2 iperiod = ivec2(iResolution.xy) - iboxWidth*2;\n    \n    // figure out where the box is\n    vec2 boxWidth = vec2(iboxWidth);\n    vec2 temp = vec2(iperiod);\n    vec2 center = abs(fract(iTime/temp*mul)*2.0-1.0) * temp + boxWidth;\n    \n    // hue shift the box with each bounce\n    vec2 tt = floor(iTime/temp*mul*2.0);\n    vec3 h = hue((tt.x+tt.y)*0.2);\n    \n    // figure out when we reach a corner\n    float period = float(lcm(iperiod.x, iperiod.y)) / mul * 0.5;\n    float corner = floor(iTime/period);\n    \n    // get to the box\n    vec2 uv = fragCoord-center;\n    vec2 d = abs(uv) - boxWidth;\n    float de = max(d.x, d.y);\n    \n    // colorize\n    float digits = SampleDigit(mod(corner, 10.0),\n                               uv / boxWidth.y + vec2(0.38, 0.5));\n    h = mix(h, vec3(1), digits);\n    vec3 col = vec3(0);\n    col = mix(col, h, smoothstep(0.5, -0.5, de));\n    fragColor.rgb = col;\n    fragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}