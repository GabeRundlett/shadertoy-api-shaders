{
    "Shader": {
        "info": {
            "date": "1720102514",
            "description": "capped cylinder intersection function with inside intersect support",
            "flags": 0,
            "hasliked": 0,
            "id": "M3GSzy",
            "likes": 3,
            "name": "cylinder in+out intersect",
            "published": 3,
            "tags": [
                "3d",
                "raycasting",
                "raytrace",
                "intersect",
                "cylinder"
            ],
            "usePreview": 0,
            "username": "silica163",
            "viewed": 107
        },
        "renderpass": [
            {
                "code": "#define R iResolution\n#define MAX 50.\n#define PI 3.14159265\n#define CAM_ROT\n\nstruct Cylinder {\n    vec3 pos;\n    vec2 size; /*x: radius, y: height*/\n};\n\nfloat iCylinder(vec3 ro, vec3 rd, Cylinder c){\n    float bodyNear = MAX, bodyFar = MAX;\n    vec3 co = ro - c.pos;\n \n    vec2 rdxz = normalize(rd.xz);\n    float t = -dot(rdxz, co.xz);\n    vec2 rp = co.xz + rdxz * t;\n    float k = c.size.x*c.size.x - dot(rp,rp);\n\n    float lxz = length(rd.xz);\n    bodyNear = (t - sqrt(k))/lxz;\n    bodyFar  = (t + sqrt(k))/lxz;\n\n    if(k < 0. || bodyFar < 0. || bodyFar < bodyNear)\n        return -1.;\n\n    float capNear = -co.y/rd.y - c.size.y/abs(rd.y);\n    float capFar  = -co.y/rd.y + c.size.y/abs(rd.y);\n    float n = max(bodyNear, capNear);\n    float f = min(bodyFar , capFar);\n\n    if(n < f && n >= 0.)\n        return n;\n    if(n > f)\n        return -1.;\n    return f;\n}\n\n\nvec3 nCylinder(vec3 rp, Cylinder c){\n    vec3 cp = rp - c.pos;\n    vec3 n = vec3(0);\n    if(abs(cp.y)+0.0001 >= c.size.y) n = vec3(0,1,0)*(cp.y/abs(cp.y));\n    else n.xz = normalize(cp.xz);\n    return n;\n}\n\nCylinder cy;\nvec2 intersect(vec3 ro, vec3 rd){\n    int mat = -1;\n    float d = MAX;\n    float cy = iCylinder(ro, rd, cy);\n    if(cy < 0.)cy = MAX;\n    d = min(d,cy);\n    \n    if(d == cy)mat = 0;\n    if(d == MAX)mat = -1;\n    return vec2(d, mat);\n}\n\n// pattern from https://www.shadertoy.com/view/4lcSRn\nvec3 pattern( in vec2 uv )\n{\n    vec3 col = vec3(0.6);\n    col += 0.4*smoothstep(-0.01,0.01,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2.*fragCoord - R.xy)/R.y;\n    vec2 m = (2.*iMouse.xy - R.xy)/R.y;\n    uv = mat2(sin(1.),cos(1.),-cos(1.),sin(1.))*uv;\n    vec3 c = vec3(0),\n         ro = vec3(0,0,5), \n         rd = normalize(vec3(uv/2.,-1)), \n         N = vec3(0);\n#ifdef CAM_ROT\n    if(iMouse.z <= 0.){\n        m.x = sin(iTime*.5)*.25;\n        m.y = sin(iTime*.5)*.5;\n    }\n    //m = mat2(sin(1.),cos(1.),-cos(1.),sin(1.))*m;\n    m *= PI*vec2(-1.,.6);\n    {\n        vec2 c = cos(m),s = sin(m);\n        rd = mat3(\n            c.x    ,   0,-s.x, \n            s.x*s.y, c.y, c.x*s.y, \n            c.y*s.x,-s.y, c.x*c.y\n        ) * rd ;\n        ro = mat3(\n            c.x    ,   0,-s.x, \n            s.x*s.y, c.y, c.x*s.y, \n            c.y*s.x,-s.y, c.x*c.y\n        ) * ro;\n    }\n\n#else\n    if(iMouse.z > 0.)\n        ro.xy += 2.*m;\n#endif\n\n    cy = Cylinder(vec3(0),vec2(1,2));\n\n    vec2 i = intersect(ro, rd);\n    vec3 rp = ro + rd * i.x;\n   \n    switch(int(i.y)){\n        case 0:\n            N = nCylinder(rp, cy);\n            c = pattern( vec2(12.0,12.0)*vec2(atan(rp.z,rp.x),rp.y))*.5;\n        default : \n            c += 0.5;\n            break;\n    }\n    \n    fragColor = vec4(c,1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}