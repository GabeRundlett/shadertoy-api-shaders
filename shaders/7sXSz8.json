{
    "Shader": {
        "info": {
            "date": "1618253699",
            "description": "potatee",
            "flags": 0,
            "hasliked": 0,
            "id": "7sXSz8",
            "likes": 24,
            "name": "Days 480",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 440
        },
        "renderpass": [
            {
                "code": "// it's like the last one but uninspired! \n// lol, still okay looking tho\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\nfloat noise(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,-(iTime + sin(iTime))*0.2);\n    for(float i = 0.; i < 6.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(2.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.+iTime*1.5) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.7;\n        p *= 1.5;\n    }\n    \n    //n = sin(n*1.);\n    return n;\n}\n\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    \n    p.xz *= rot((iTime+sin(iTime))*0.5);\n    float n = noise(p*1.5);\n    d.x = length(p) - 1. + n*0.15;\n    d.x*=0.8;\n    return d;\n}\nvec3 getNormal(vec3 p){\n    vec2 t = vec2(0.001,0.);\n    return normalize(vec3(\n        map(p+t.xyy).x - map(p-t.xyy).x,\n        map(p+t.yxy).x - map(p-t.yxy).x,\n        map(p+t.yyx).x - map(p-t.yyx).x \n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    float pxsz = fwidth(uv.x + uv.y);\n    //vec3 col = vec3(0.1,0.6,0.8)*1. + sin(vec3(0.1,0.3,0.1)*uv.x*4. + vec3(5,2,1) + uv.y + sin(iTime))*0.5;\n    vec3 col = vec3(0.9,1.,1.);\n    \n    \n    bool hit = false;\n    \n    vec3 ro = vec3(0,0,-3.);\n    vec3 rd = normalize(vec3(uv,1. + sin(iTime)*0.));\n    float t = 0.;\n\n    {\n    \n        float modD = 0.2;\n        vec2 p = uv - vec2(0,iTime*0.1 );\n        vec2 id = floor(p/modD);\n        float n = noise(vec3(id,1. + iTime));\n        p = pmod(p,modD);\n        float d = length(p) - 0.00 + n*0.004;\n        \n        col = mix(col,vec3(1.)*pal(n + p.y*144.) + 0.3,smoothstep(pxsz,0.,d));\n        \n    }\n\n    {\n        vec3 p = ro;\n        \n        vec2 d; \n        for(int i = 0; i < 30; i++){\n            d = map(p);\n            if(d.x < 0.009){\n                hit = true;\n                break;\n            }\n            p = ro + rd * ( t += d.x);\n        }\n        \n        if(hit){\n            vec3 n = getNormal(p);\n            vec3 r = reflect(rd,n);\n            vec3 rfr = refract(rd,n,.5);\n            \n            //col = 0.501 + 0.5*sin(r*1.4 + dot(-n,rfr)*2. + vec3(1,4,5.) + length(rfr + n)*6.);\n            //col = pal();\n            col = 0.501 + 0.5*sin(r*.6 + n*vec3(1.5,1.1,0.5)*1. + 0.5*dot(r,n)*13.5 - r*0.5  + vec3(1.5,3.7,5.) + 0.8*length(rfr + n)*4.);\n            #define ao(a) smoothstep(0.,1.,map(p+n*a).x/a)\n            //col *= ao(0.04);\n            //col = max(col,0.);\n            //col = smoothstep(0.,1.,col);\n            col = pow(col,vec3(0.3,0.35,0.26));\n            //col = 0.5 + n*0.5;\n        }\n    }\n\n    {\n        vec2 p = uv;\n        vec2 md = vec2(0.11,0.04);\n        \n        //p.x += 0.67 + md.x*1.;\n        //p.y += md.y*0.5+0.2;\n        \n        vec3 c = vec3(0.1,0.35,0.46)*col*2.5 + (0.4-col*0.5)*1.4 + 0.1*vec3(3,2,1)*sin(p.xyx*14. + iTime);\n        c = max(c,0.1);\n        \n        vec3 oc = c*2.6*(1.-col + 0.4); \n        c = oc;\n        \n        //c =  (pal(uv.y*11. + iTime*1.) + 0.5)*c*1.5*(col*1.);\n    \n            {\n                \n                \n                \n                for(float i = 0.; i < 115.; i++){\n                    float plane = plaIntersect( ro \n                        + vec3(0.,0.,0.6 - .5*sin(i)), rd, vec4(0,0,-1,0) );\n                    vec3 p = ro + rd*plane;\n                    p.x += sin(i*112.)*2.;\n                    p.y += 1.6-mod(0.1*iTime*(1. + sin(i)*0.8),1.)*5.;\n                    float db = 10e5;\n                    \n                \n                    float m = sin(iTime + i*1.17);\n                    m = m + sin(iTime+i*1.05);\n                    \n                    p.xy*=rot(m*11.);\n        \n                vec2 s = 0.5*vec2(0.1*(0.6 + m*0.1) ,0.01+m*0.0255*0.);\n                    db = sdBox(p.xy ,s );\n                    db = xorb(db,sdBox(p.xy*rot(0.5*3.14) , s),-0.0);\n                \n                    //db = xor(db, sdBox(uv*rot(m*1.) , vec2(0.1*(0.6 + m*0.5) ,m*0.0155)));\n                \n                    if(plane < t){\n                        //col = mix(col,(1.-col + 0.35)*(4. + pow(pal(p.y*10.),vec3(0.5)))*0.5,smoothstep(0.03,0.0,db));\n                \n                        col = mix(col,(1.-col + 1.)*pow(pal(p.y*10. + i + iTime),vec3(0.7)),smoothstep(pxsz,0.,db));\n                    }\n                }\n                \n                /*\n                if(plane < t)\n                    col = mix(col,oc,smoothstep(pxsz,0.,db));\n                */\n            }\n        {\n            vec2 omd = md;\n            vec2 id = floor(p/md);\n            \n            \n            p*=rot(0.);\n            md.x *= 2.;\n            vec2 idr = floor(p/md);\n            vec2 q = pmod(p,md);\n            //q.y += sin(idr.y + (iTime + sin(iTime))*2.)*md.y*0.3;\n            float d = sdBox(q, vec2(0.1,0.002));\n            \n            d = xorb(d,0.005+sdBox(q + vec2(+ sin(5.*idr.y + iTime*1. + 3.*sin(idr.y + iTime))*md.x*0.6,0.), vec2(0.5*md.x ,0.01)),0.04);\n            \n            //d = xor(d,0.0+sdBox(p - 0.0 , vec2(0.01 ,0.6)));\n            \n            \n            //vec2 ca = vec2();\n            //cnd += float((id.x) == 6. && abs(id.y - 3.) < 7.);\n            \n            vec2 pa = vec2(0.77,0.3);\n            vec2 pb = - vec2(0.77,0.3);\n            \n            float wa = 0.03;\n            float wb = 0.0001;\n            \n            float outer = sdBox(uv +pa,vec2(omd.x/2.,md.y*3.5));\n            \n            vec2 z = uv + pa;\n            \n            float oo = max(abs(outer - wa) - wb,-sdBox(z - 0.08,vec2(omd.x/2.,md.y*3.5)) ); \n            oo = max(oo,-sdBox(z + 0.08*vec2(0.6,0.45),vec2(omd.x/2.,md.y*3.5)) ); \n            \n            float bb = sdBox(uv +pb,vec2(omd.x/4.,md.y*3.5));\n            outer = min(outer,bb);\n            \n            z = uv + pb;\n            \n            oo = min(oo,max(abs(bb - wa) - wb,-sdBox(z - 0.08,vec2(omd.x*1.,md.y*3.5)) )); \n            oo = max(oo,-sdBox(z + 0.08*vec2(0.1,0.45),vec2(omd.x/2.,md.y*7.5)) ); \n            \n            oo = (oo - 0.00) - 0.0001;\n            \n            \n            \n            \n            float mu = sin(iTime*0.5+sin(iTime))*0.4;\n            \n            float ob = (sdBox(uv,vec2(0.85,0.46)));\n            \n            float cutout = sdBox(uv - vec2(0.5,0.4),vec2(0.6 + sin(iTime)*0.2,0.5));\n            \n            cutout = min(cutout, sdBox(uv + vec2(0.5,0.4),vec2(0.6 + sin(iTime)*0.2,0.5)));\n            \n            float outerBox = max(abs(ob),-cutout);\n            outerBox = min(outerBox, max(abs(ob + 0.04), -cutout + 0.3));\n            \n            outerBox = min(outerBox, max(abs(ob + 0.06), -cutout + 0.3));\n            \n            oo = min(oo,outerBox);\n            \n            \n            col = mix(col,c,smoothstep(pxsz,0., oo));\n            \n            \n               \n           \n            float cnd = smoothstep(pxsz,0., outer);\n            \n            //col = mix(col,col*c,cnd*smoothstep(0.05,0.,d));\n            col = mix(col,c,cnd*smoothstep(pxsz,0.,d));\n            \n            \n            \n            float od = d;\n            \n            d = sdBox(p - vec2(-0.022,0) , vec2(0.01 ,0.2));\n            \n            \n            {\n            \n                float dmu = 10e4;\n                for(float i = 0.; i < 2.; i++){\n                    float plane = plaIntersect( ro \n                        + vec3(0.,0.,+1.4 - .5*sin(iTime + i)), rd, vec4(0,0,-1,0) );\n                    vec3 p = ro + rd*plane;\n                    \n                    \n                    float dmub = length(uv + vec2(sin(i+iTime)*0.1,0.)) - 0.1;\n                    if(plane < t){\n                        dmu = min(xorb(dmu,abs(dmub -0.4) - 0. -0.1*sin(iTime*1.+i*0.3),0.0),0.01);\n                \n                    }     \n                }\n            \n                //oo = min(oo,dmu);\n                col = mix(col,c,smoothstep(pxsz,0., dmu));\n                        \n                //dmu = min(dmu,abs(dmu - 0.02) - 0.01);\n\n                \n            \n            }\n            //d = min(d,xor(d,sdBox(p - vec2(-0.022,0) , vec2(0.001 ,0.5))));\n            //d = min(d,xor(d,sdBox(p - vec2(-0.06,0) , vec2(0.001 ,0.3))));\n            //d = min(d,xor(d,sdBox(p - vec2(-0.05,0) , vec2(0.046 ,0.3))));\n            //d = min(d,xor(d,sdBox(p - vec2(-0.1,0.3) , vec2(0.02 ,0.1))));\n            //d = abs(d) - 0.001;\n            \n            \n        }\n        \n        //d = min(d, sdBox(uv + vec2(0.1), vec2(0.0,0.04)));\n        \n    }\n    \n    float doo = -abs(uv.x ) + 0.55;\n    \n    if(doo <0.){\n        col = (1.-col) + 0.3;\n        col.xz*=rot(0.3 + sin(uv.y+iTime + sin(iTime))*0.4);\n        col = smoothstep(0.,1.,col);\n        col = smoothstep(0.,1.,col);\n        \n    }\n    if(mod(iTime,6.)>5. || iMouse.z > 0.)\n        col = 1. - col;\n        \n    col = pow(col,vec3(0.3545));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\nfloat sdBox(vec2 p, vec2 s){p = abs(p) -s; return max(p.y,p.x);}\n\n\nvec3 pal(float m){\n    vec3 c = 0.5+0.5*sin(m + vec3(1.5,0.,-0.5));\n    c = pow(c, vec3( .5));\n    \n    return c;\n}\n\n#define xor(a,b) min(max(a,-(b)),max(b,-(a)))\n\n#define xorb(a,b,c) min(max(a + c,-(b)),max(b,-(a)))\n\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}