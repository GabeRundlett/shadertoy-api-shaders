{
    "Shader": {
        "info": {
            "date": "1642464333",
            "description": "flying and blinking",
            "flags": 0,
            "hasliked": 0,
            "id": "7slcRX",
            "likes": 21,
            "name": "city fly through",
            "published": 3,
            "tags": [
                "city"
            ],
            "usePreview": 0,
            "username": "leon",
            "viewed": 643
        },
        "renderpass": [
            {
                "code": "// \"are we arrived yet?\"\n// city fly through with blinking rectangles\n// leon denise 2022 01 18\n    \n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n// domain repetition\n#define repeat(p,r) (mod(p+r/2.,r)-r/2.)\n\n// hash by 4tfyW4 and Inigo Quilez https://www.shadertoy.com/view/XlXcW4\nvec3 hash( uvec3 x ) {\n    uint k = 1103515245U;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n// geometry\nvec3 plocal;\nfloat map(vec3 p)\n{\n    vec3 pp = p;\n    float dist = 100.;\n    float tt = iTime * .02; // speed\n    p.z += tt; // translate\n    float cell = 1.; // size of repetition\n    float pz = floor(p.z/cell); // index of cell in line\n    p.z = repeat(p.z, cell); // repeat space z\n    p.z *= mix(-1., 1., step(0., p.z)); // mirror z per cell in line\n    float t = floor(pp.z/cell); // rotation\n    const float count = 9.; // number of shapes\n    float a = 1.; // amplitude of falloff\n    for (float i = 0.; i < count; ++i) { // kifing\n        p.xz *= rot(t/a); // twist\n        p = abs(p)-.15*a; // fold space\n        dist = min(dist, max(p.x, max(p.y, p.z))); // space\n        a /= 1.7; // falloff curve\n    }\n    plocal = p; // for colors\n    dist = -dist; // invert volume\n    dist = max(dist, -(max(abs(pp.x)-.005, abs(pp.y)-.01))); // crop tunnel\n    return dist;\n}\n\nvoid mainImage( out vec4 color, in vec2 coordinate )\n{\n    // coodinates\n    vec2 pixel = (coordinate - iResolution.xy / 2.) / iResolution.y;\n    vec3 eye = vec3(0,.002,-1.);\n    vec3 ray = normalize(vec3(pixel, 1.+.5*sin(iTime/3.)));\n    ray.yz *= rot(-cos(iTime/4.)*.2);\n    ray.xz *= rot(sin(iTime/5.)*.2);\n    vec3 pos = eye;\n    vec3 rng = hash(uvec3(coordinate, mod(iTime, 1000.)*60.));\n    \n    // raymarch\n    const float count = 30.;\n    float i = 0.;\n    for (i = count; i > 0.; --i) {\n        float dist = map(pos);\n        if (dist < .0001) break;\n        dist *= .9 + .1 * rng.z;\n        pos += ray * dist;\n    }\n    \n    // coloring\n    float shade = i/count;\n    float sat = (1.-shade)*smoothstep(1.,0.,length(pixel));\n    \n    // vertical colored lines\n    vec3 rainbow = (1.-sat)+sat*cos(vec3(.0,.3,.6)*6.3+pixel.y*1.+2.);\n    vec3 tint = mix(vec3(0), rainbow, smoothstep(.1, .0, sin(plocal.y*4000.)));\n    \n    // horizontal colored lines\n    rainbow = (1.-sat)+sat*cos(vec3(.0,.3,.6)*6.3+pixel.x*1.+2.5);\n    tint = mix(tint, rainbow, smoothstep(.1, .0, sin(plocal.x*1000.)+.4));\n    \n    // blinking rectangles\n    vec3 mosaic = hash(uvec3(floor(abs(plocal)*1500.)+floor(iTime/.1)));\n    tint += step(.98, mosaic.x);\n    \n    color = vec4(tint*shade, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}