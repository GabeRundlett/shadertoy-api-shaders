{
    "Shader": {
        "info": {
            "date": "1720933311",
            "description": "My first attempt at 3D lighting, again like my other published shaders, thanks to Inigo Quilez who's code I used to try and understand what everything is! Souce: https://www.shadertoy.com/view/XtycD1",
            "flags": 0,
            "hasliked": 0,
            "id": "McXyzM",
            "likes": 1,
            "name": "Raymarching, with LIGHTING",
            "published": 3,
            "tags": [
                "basic",
                "raymarch",
                "lighting"
            ],
            "usePreview": 0,
            "username": "JOEMANFLAME",
            "viewed": 92
        },
        "renderpass": [
            {
                "code": "//-------------------------------------------------------------------------------------------------------------------\n// Credit to Inigo Ouilez, whos code I was able to follow and arive at 'some' sort of understanding of what it does<3\n// This is a very simple raymarched sphere with a PITIFUL attempt at lighting, however I leraned alot in rendering\n// this so I'm excited for what's next :)\n\n// https://www.shadertoy.com/view/XtycD1    - code I followed for understanding\n// https://iquilezles.org/articles/         - also his website for those who have not yet 'seen the light'\n//                                                                                             ^\n//                                                                                             |\n//                                             see what i did there?... because lighting? ----- \n//-------------------------------------------------------------------------------------------------------------------\n\n// functions\n\n// returns a changing color palette (not used in this demo)\nvec3 palette( float t ) {\n    vec3 a = vec3(0.731, 1.098, 0.192);\n    vec3 b = vec3(0.358, 1.09, 0.657);\n    vec3 c = vec3(1.077, 0.360, 0.328);\n    vec3 d = vec3(0.965,2.265,0.837);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// rotates by angle\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n//-------------------------------------------------------------------------------------------------------------------\n\n// SDFs\n\n// I was playing around with this, not used in this code\n// returns SDF of torus\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// returns SDF of sphere\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//-------------------------------------------------------------------------------------------------------------------\n\n// geometry in scene\nfloat map ( vec3 pos ) {\n\n    float sphere = sdSphere(pos, 1.0);\n    return sphere;\n}\n\n// calculates normal given a position                         (don't ask me about the math, I'm in the middle of   \n// https://www.shadertoy.com/view/XtycD1 - copied from here    writing my thesis and I need to brush up on my math skills)\nvec3 calcNormal( in vec3 pos )\n{\n    float kk;\n    float eps = 0.0002;\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx) );\n}\n\n// calculates distance to objects in the scene\nfloat intersect ( vec3 ro, vec3 rd, float mindist, float maxdist ) \n{\n    vec3 d;\n    float t = mindist;\n    for (int i = 0; i < 100; i++) {\n        d = ro + rd * t;\n        float h = map(d);\n        if (abs(h) < (0.0001*t) || t > maxdist){\n            break;\n        }\n        t += h;\n    }\n    return (t<maxdist)?t:-1.0;\n}\n\n// light position in world coords\nvec3 light = vec3(0.8, 0.5, -0.5);\n\n// takes in position matrix and normals and outputs pixel rgb value\nvec3 shadow ( vec3 pos , vec3 nor) {\n    // initialize rgb at 0 for easier calc\n    vec3 rgb = vec3(0.0,0.0,0.0);\n    // first matrix denotes light color, dot product of geom normals and light pos yields value btwn 0-1 giving\n    // amount of light to be drawn (clamp yields value of (function btwn y, z)\n    rgb += vec3(1.0, 0.925, 0.878) * clamp(dot(nor, light), 0.0, 1.0);\n    return rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/ iResolution.y;\n    vec2 m = (fragCoord * 2.0 - iResolution.xy)/ iResolution.y;\n    \n    // Set ray origin (ro) and ray direction (rd)\n    vec3 ro = vec3(0.0,0.0,-3.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    // multiplies by a time factor\n    m = vec2(sin(iTime) - 1.2);\n    \n    // Background color\n    vec3 col = vec3(0.2,0.2,0.2);\n    \n    // Find distance to intersection btw ray and geometry\n    float dist = intersect(ro, rd, 0.001, 50.0);\n        // if the distancce is greater than 0\n        if (dist > 0.0) {\n            // position matrix\n            vec3 pos = ro + rd*dist;\n            \n            pos.xz *= rot2D(dist * m.x);\n            // find normals of position matrix\n            vec3 norm = calcNormal(pos);\n            // calculate lighting\n            col = shadow(pos, norm);\n    }  \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}