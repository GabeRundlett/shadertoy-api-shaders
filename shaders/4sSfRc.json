{
    "Shader": {
        "info": {
            "date": "1501366968",
            "description": "mouse.x =\"ripple gradient\", clamped to range; m.x=clamp(m.x,0.,1.)-15./iResolution;\nmouse.y =\"number of ripples\" to; m.y=abs(m.y)+1.;\n\npurple line shows core \"ripple function\"; sawCos(u.x,m.x);\nother functions are shape or wrappers around sawCos()",
            "flags": 0,
            "hasliked": 0,
            "id": "4sSfRc",
            "likes": 5,
            "name": "so smooth sawCos()",
            "published": 3,
            "tags": [
                "triangle",
                "gradient",
                "sine",
                "smooth",
                "continuity",
                "sawcos",
                "bisymmetry"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 807
        },
        "renderpass": [
            {
                "code": "#define pi acos(-1.)\n\n/*\nsawCos(x,b) is my baby now\n- it seems to be ideal to draw distance fields.\n- it smoothly blends between y=cos(x); and something like y=fract(x); and y=1.-fract(x);\n- - it is a\" smooth seesaw-wave\" like function\n- - it equals y=cos(x*pi)*.5+.5; for b=.5;\n- it has infinite smooth derivatives; f'cos(x)=cos(x+pi) ;except for b=0. or b=1. ;\n*/\n\n//view zoom\n#define viewZoom 9.\n//view scaling\n#define fr(u) (u-.5*iResolution.xy)*viewZoom/iResolution.y\n\n\n\n//return y of f(u.x) which is a triangle wave, slanted sideways by u.x\n//that is also sinusoidial continuity, but not for: 0.!=u.y!=1.\n//looks best if u.y=clamp(m.x,0.,1.)-15./iResolution.y;, \n//... for a \"smoothstepSine() wihin 1/15 subpixel.\nfloat sawCos(vec2 u){u.x=fract(u.x);u+=(1.- 2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0., 1.)*pi)*.5+.5;}\nfloat sawCos(vec2 u,float b){u.y=b;return sawCos(u);}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,1.-15./iResolution.y);}\n\n//return max of components\nfloat maxv(vec2 a){return  max(a.x,a.y);}\n\n// uv to color is the new \"main\"\nvec3 co(vec2 u){\n vec2 m=fr(iMouse.xy);u=fr(u);\n vec3 c=vec3(0);\n float aa=15./iResolution.y;\n   \n c.g=min(length(u),maxv(abs(u-m)))-4.;//yellow circle\n m.x=clamp(m.x,0.,1.)-aa;\n c.r=sawCos(-abs(u.x),m.x)-u.y;//yellow circe illustration\n    \n c.g=abs(c.g+2.)-1.;//offset to outline\n float rpd=abs(m.y)+1.;aa *=rpd;c.g*=rpd;//rpd=riples per distance\n \n c.r=    smoothstep(aa,-aa,abs(c.r));\n //above, putple curve gets \"simpler treatment\" than theyellow shape below.\n c.g=mix(sawCos(-c.g,m.x)//supersmooth sawCos() ripple\n        ,smoothstep(aa,-aa,c.g)//make \"negative inside\" brighter than \"positive outside\"\n        ,.8)////mix the above 2 values\n        /(abs(c.g)+.5);//diminish over distance, and give \"below surface\" an extra glow.\n\n c.g=sqrt(c.g);//increase gamma \n c.b=0.;\n //c.b=fract(u.x*2.)*fract(u.y*2.)*.5;\n return c*.5+c.yzx*.5;}\n\n/*\nnote, this was \"bisymmetry in its infancy\", as in , \n... i knew what i wanted, but not now too implement or call it.\n*/\n\n//#define mainImage(o,u)o=vec4(co(u),1.);\nvoid mainImage(out vec4 o, vec2 u\n){o=vec4(co(u),1.);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}