{
    "Shader": {
        "info": {
            "date": "1725777046",
            "description": "intersection of a ray and a revolved conic section",
            "flags": 48,
            "hasliked": 0,
            "id": "l3lczn",
            "likes": 1,
            "name": "ray-conic intersection",
            "published": 3,
            "tags": [
                "3d",
                "intersector"
            ],
            "usePreview": 0,
            "username": "ArmandB",
            "viewed": 64
        },
        "renderpass": [
            {
                "code": "float conprod3d(vec3 g, vec3 h, float ia2, float ib2, float omc){\n    return g.z*h.z*omc*ia2 + dot(g.xy,h.xy)*ib2;\n}\n\nvec2 rayConic3d(vec3 o, vec3 d, float a, float b, float c){\n    o.z += 1.0;\n    float ia = 1.0/a;\n    float ia2 = ia*ia;\n    float ib2 = 1.0/b;\n    float c2 = c*c;\n    float omc = 1.0 - c2;\n    float h = conprod3d(d,d,ia2,ib2,omc);\n    float g = conprod3d(d,o,ia2,ib2,omc) + c2*d.z*ia;\n    float k = conprod3d(o,o,ia2,ib2,omc) + (2.0*o.z*ia - 1.0)*c2;\n    float det = g*g - h*k;\n    return det >= 0.0 ? vec2((-g - sqrt(det))/h, (-g + sqrt(det))/h) : vec2(1e20);\n}\n\nvec3 conicNormal3d(float a, float b, float c, vec3 p){\n    float ia = 1.0/a;\n    float ib2 = 1.0/(b*b);\n    return normalize(vec3(p.x*ib2, p.y*ib2, p.z*ia*ia - c*c*(p.z*ia - 1.0)*ia));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 position = texelFetch(iChannel0, ivec2(4,0),0).xyz;\n    vec3 rotation = vec3(texelFetch(iChannel0, ivec2(1,0),0).yx*vec2(-1,1),0)*sensitivity;\n    Camera cam = createCamera(fragCoord, iResolution.xy, position, rotation, cameraFrustum);\n    \n    vec3 d = cam.ray.direction;\n    vec3 o = cam.ray.origin;\n    \n    vec3 col = getSkyColor(d);\n\n    // conic parameters\n    float a = 4.0;\n    float b = 2.0;\n    // c < 1 : elipsoid, c = 1 : paraboloid, c > 1 : hyperboloid\n    float c = sin(iTime) + 1.5;\n\n    // intersect conic\n    vec2 hits = rayConic3d(o, d, a, b, c);\n    // get first hit\n    hits.x = hits.x < 0.0 ? 1e20 : hits.x;\n    hits.y = hits.y < 0.0 ? 1e20 : hits.y;\n    float depth = min(hits.x, hits.y);\n    // render if hit\n    if (depth != 1e20){\n        vec3 light = normalize(vec3(0.2,0.9,0.4));\n        float diffuse = dot(conicNormal3d(a, b, c, o + depth*d), light)*0.5 + 0.5;\n        col = mix(vec3(0.082,0.416,0.212), vec3(0.580,1.000,0.608), diffuse);\n    }\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265\n#define cameraFrustum 0.7\n\nconst float sensitivity = 4.0;\nconst float moveSpeed = 0.1;\nconst float moveDamping = 0.7;\n\n// just in case someone wants it\n\nfloat conprod2d(vec2 g, vec2 h, float ia2, float ib2, float ic2, float omc){\n    return (g.x*h.x*omc*ia2 + g.y*h.y*ib2)*ic2;\n}\n\n// derived here: https://www.desmos.com/calculator/8crubo3ub1, 3d version used basically the same setup\nvec2 rayConic2d(vec2 o, vec2 d, float a, float b, float c){\n    o.x += 1.0;\n    float ia = 1.0/a;\n    float ia2 = ia*ia;\n    float ib2 = 1.0/b;\n    float c2 = c*c;\n    float ic2 = 1.0/c2;\n    float omc = 1.0 - c2;\n    float g = conprod2d(d,o,ia2,ib2,ic2,omc) + d.x*ia;\n    float h = conprod2d(d,d,ia2,ib2,ic2,omc);\n    float k = conprod2d(o,o,ia2,ib2,ic2,omc);\n    float det = sqrt(g*g - h*(k + 2.0*o.x*ia - 1.0));\n    return vec2((det - g)/h, (g - det)/h);\n}\n\n\n\n//helpers\n\nmat3 rotationMatrix(vec3 a){\n    //calculate consts\n    float cx = cos(a.x);\n    float sx = sin(a.x);\n    float cy = cos(a.y);\n    float sy = sin(a.y);\n    float cz = cos(a.z);\n    float sz = sin(a.z);\n    //return matrix\n    return mat3(\n        cy*cz, sx*sy*cz - cx*sz, cx*sy*cz + sx*sz,\n        cy*sz, sx*sy*sz + cx*cz, cx*sy*sz - sx*cz,\n        -sy, sx*cy, cx*cy\n    );\n}\n\n//returns a point rotated in 3d (radians)\nvec3 rotate3d(vec3 point, vec3 angle, vec3 origin){ \n    point -= origin; //subtract pivot\n    point *= rotationMatrix(angle); //rotate point\n    point += origin; //add pivot\n    return point;\n}\n\nvec3 getSkyColor(vec3 dir){\n    vec3 skycol = vec3(0);\n    vec3 water = vec3(0.3,0.4,0.8);\n    vec3 sky = vec3(0,0.6,1);\n    vec3 haze = vec3(0.9,0.9,0.9);\n    if (dir.y < 0.0) {\n        skycol = mix(haze, water, clamp(-dir.y,0.0,1.0));\n    } else {\n        skycol = mix(haze, sky, clamp(dir.y,0.0,1.0));\n    }\n    return skycol;\n}\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Camera {\n    vec3 position;\n    Ray ray;\n    vec2 uv;\n};\n\n//camera constructor\nCamera createCamera(vec2 fragCoord, vec2 resolution, vec3 cameraPos, vec3 camRot, float frustumLength){\n    vec3 uv = vec3((fragCoord - resolution*0.5)/resolution.y, frustumLength);\n    vec3 uvd = normalize(uv);\n    mat3 rotmat = rotationMatrix(camRot);\n    vec3 ro = uv*rotmat + cameraPos;\n    vec3 rd = uvd*rotmat;\n    return Camera(cameraPos, Ray(ro, rd), uv.xy);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const int _w = 87;\nconst int _a = 65;\nconst int _s = 83;\nconst int _d = 68;\nconst int _space = 32;\nconst int _shift = 16;\nconst int _c = 67;\nconst int _v = 86;\n\nfloat keyPressed(int key){\n    return float(texelFetch(iChannel1, ivec2(key,0),0).x >= 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    //rotation\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy); //current mouse pos\n        \n        if (iFrame <= 1){\n            col = vec2(0.35,0.09).xyxy;\n        } else {\n            //if mouse button up\n            if (m.z < 0.0 && mp.z >= 0.0){\n                col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n            } else if (m.z >= 0.0){\n                col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n            } else {\n                col = texelFetch(iChannel0, ivec2(1,0), 0);\n            }\n        }\n        \n        if (col.y*sensitivity > PI/2.0){\n            col.y = PI/2.0/sensitivity;\n        }\n        if (col.y*sensitivity < -PI/2.0){\n            col.y = -PI/2.0/sensitivity;\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy);\n    }\n    \n    //velocity\n    if (floor(fragCoord) == vec2(3,0)){\n        vec3 velocity = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n        vec3 position = texelFetch(iChannel0, ivec2(4,0), 0).xyz;\n        vec2 forward = rotate3d(vec3(1,0,0),vec3(0,texelFetch(iChannel0, ivec2(1,0),0).x*sensitivity,0), vec3(0)).xz;\n        vec2 right = vec2(-forward.y,forward.x);\n        vec3 relative = vec3(keyPressed(_d)-keyPressed(_a), 0, keyPressed(_w)-keyPressed(_s));\n        float up = keyPressed(_space) - keyPressed(_shift);\n        vec3 move = vec3(relative.x*forward.x + relative.z*right.x, up, relative.x*forward.y + relative.z*right.y);\n        velocity = move != vec3(0) ? velocity*moveDamping + normalize(move)*moveSpeed : velocity*moveDamping;\n        \n        if (position.y < -1000.0){\n            velocity = vec3(0);\n        }\n        col.xyz = velocity;\n    }\n    \n    //position\n    if (floor(fragCoord) == vec2(4,0)){\n        vec3 velocity = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n        vec3 position = texelFetch(iChannel0, ivec2(4,0), 0).xyz;\n        position += velocity*iTimeDelta*60.0;\n        \n        if (position.y < -500.0){\n            position = vec3(0,24,0);\n        }\n        \n        if (iFrame == 0){\n            position = vec3(0,-40,0);\n        }\n        col.xyz = position;\n    }\n    \n    //resolution\n    if (floor(fragCoord) == vec2(5,0)){\n        col.xy = iResolution.xy;\n    }\n    //light direction\n    if (floor(fragCoord) == vec2(6,0)){\n        float t = texelFetch(iChannel0,ivec2(6,0),0).w;\n        if (iFrame == 0){\n            t = 0.5;\n        }\n        col.xyz = vec3(sin(t*PI*2.0),cos(t*PI*2.0),0);\n        col.w = t + (keyPressed(_c) - keyPressed(_v))*0.01;\n    }\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}