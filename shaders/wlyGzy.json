{
    "Shader": {
        "info": {
            "date": "1579203898",
            "description": "Based on a earlier shader I did that relier but simplified to waves rotation. Detects the intersection of the flat sea surface and computes the wave normal to produce the wave effect. Looks best in FF for me and doesn't work properly in Edge. ",
            "flags": 0,
            "hasliked": 0,
            "id": "wlyGzy",
            "likes": 17,
            "name": "Waves on flat sea surface",
            "published": 3,
            "tags": [
                "raytracing",
                "flat"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 663
        },
        "renderpass": [
            {
                "code": "#define PI  3.141592654\n#define TAU (2.0*PI)\n\nconst float gravity = 1.0;\nconst float waterTension = 0.01;\n\nconst vec3 skyCol1 = vec3(0.6, 0.35, 0.3);\nconst vec3 skyCol2 = vec3(1.0, 0.3, 0.3);\nconst vec3 sunCol1 = vec3(1.0,0.5,0.4);\nconst vec3 sunCol2 = vec3(1.0,0.8,0.7);\nconst vec3 seaCol1 = vec3(0.1,0.2,0.2);\nconst vec3 seaCol2 = vec3(0.8,0.9,0.6);\n\nvec2 wave(in float t, in float a, in float w, in float p) {\n  float x = t;\n  float y = a*sin(t*w + p);\n  return vec2(x, y);\n}\n\nvec2 dwave(in float t, in float a, in float w, in float p) {\n  float dx = 1.0;\n  float dy = a*w*cos(t*w + p);\n  return vec2(dx, dy);\n}\n\nvec2 gravityWave(in float t, in float a, in float k, in float h) {\n  float w = sqrt(gravity*k*tanh(k*h));\n  return wave(t, a ,k, w*iTime);\n}\n\nvec2 capillaryWave(in float t, in float a, in float k, in float h) {\n  float w = sqrt((gravity*k + waterTension*k*k*k)*tanh(k*h));\n  return wave(t, a, k, w*iTime);\n}\n\nvec2 gravityWaveD(in float t, in float a, in float k, in float h) {\n  float w = sqrt(gravity*k*tanh(k*h));\n  return dwave(t, a, k, w*iTime);\n}\n\nvec2 capillaryWaveD(in float t, in float a, in float k, in float h) {\n  float w = sqrt((gravity*k + waterTension*k*k*k)*tanh(k*h));\n  return dwave(t, a, k, w*iTime);\n}\n\nvoid mrot(inout vec2 p, in float a) {\n  // c*c + s*s\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec4 sea(in vec2 p, in float ia) {\n  float y = 0.0;\n  vec3 d = vec3(0.0);\n\n  const int maxIter = 8;\n  const int midIter = 4;\n\n  float kk = 1.0/1.3;\n  float aa = 1.0/(kk*kk);\n  float k = 1.0*pow(kk, -float(maxIter) + 1.0);\n  float a = ia*0.25*pow(aa, -float(maxIter) + 1.0);\n\n  float h = 25.0;\n  p *= 0.5;\n  \n  vec2 waveDir = vec2(0.0, 1.0);\n\n  for (int i = midIter; i < maxIter; ++i) {\n    float t = dot(-waveDir, p) + float(i);\n    y += capillaryWave(t, a, k, h).y;\n    vec2 dw = capillaryWaveD(-t, a, k, h);\n    \n    d += vec3(waveDir.x, dw.y, waveDir.y);\n\n    mrot(waveDir, PI/3.0);\n\n    k *= kk;\n    a *= aa;\n  }\n  \n  waveDir = vec2(0.0, 1.0);\n\n  for (int i = 0; i < midIter; ++i) {\n    float t = dot(waveDir, p) + float(i);\n    y += gravityWave(t, a, k, h).y;\n    vec2 dw = gravityWaveD(t, a, k, h);\n    \n    vec2 d2 = vec2(0.0, dw.x);\n    \n    d += vec3(waveDir.x, dw.y, waveDir.y);\n\n    mrot(waveDir, -step(2.0, float(i)));\n\n    k *= kk;\n    a *= aa;\n  }\n\n  vec3 t = normalize(d);\n  vec3 nxz = normalize(vec3(t.z, 0.0, -t.x));\n  vec3 nor = cross(t, nxz);\n\n  return vec4(y, nor);\n}\n\nvec3 sunDirection() {\n  vec3 dir = normalize(vec3(0, 0.06, 1));\n  return dir;\n}\n\nvec3 skyColor(in vec3 rd) {\n  vec3 sunDir = sunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  \n  vec3 final = vec3(0.0);\n\n  final += mix(skyCol1, skyCol2, rd.y);\n\n  final += 0.5*sunCol1*pow(sunDot, 90.0);\n\n  final += 4.0*sunCol2*pow(sunDot, 900.0);\n    \n  return final;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n  vec3 col = vec3(0.0);\n\n  float dsea = (0.0 - ro.y)/rd.y;\n  \n  vec3 sunDir = sunDirection();\n  \n  vec3 sky = skyColor(rd);\n  \n  if (dsea > 0.0) {\n    vec3 p = ro + dsea*rd;\n    vec4 s = sea(p.xz, 1.0);\n    float h = s.x;    \n    vec3 nor = s.yzw;\n    nor = mix(nor, vec3(0.0, 1.0, 0.0), smoothstep(0.0, 200.0, dsea));\n\n    float fre = clamp(1.0 - dot(-nor,rd), 0.0, 1.0);\n    fre = pow(fre, 3.0);\n    float dif = mix(0.25, 1.0, max(dot(nor,sunDir), 0.0));\n    \n    vec3 refl = skyColor(reflect(rd, nor));\n    vec3 refr = seaCol1 + dif*sunCol1*seaCol2*0.1; \n    \n    col = mix(refr, 0.9*refl, fre);\n    \n    float atten = max(1.0 - dot(dsea,dsea) * 0.001, 0.0);\n    col += seaCol2*(p.y - h) * 2.0 * atten;\n    \n    col = mix(col, sky, 1.0 - exp(-0.01*dsea));\n    \n  } else {\n    col = sky;\n  }\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/iResolution.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  vec3 ro = vec3(0.0, 10.0, 0.0);\n  vec3 ww = normalize(vec3(0.0, -0.1, 1.0));\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n\n  vec3 col = render(ro, rd);\n\n  fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}