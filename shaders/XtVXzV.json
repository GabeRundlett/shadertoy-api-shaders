{
    "Shader": {
        "info": {
            "date": "1485103441",
            "description": "A variant of Stephan Rafler's SmoothLife that uses a separable Gaussian kernel to compute inner and outer fullness. The improvement in performance over full 2D convolution makes it possible to use a much larger kernel in realtime, without using FFT.",
            "flags": 48,
            "hasliked": 0,
            "id": "XtVXzV",
            "likes": 67,
            "name": "Gaussian SmoothLife",
            "published": 3,
            "tags": [
                "diffusion",
                "life",
                "gaussian",
                "gameoflife",
                "reaction",
                "smoothlife"
            ],
            "usePreview": 0,
            "username": "cornusammonis",
            "viewed": 4629
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 col = texture(iChannel0, uv);\n    \n    fragColor = col.x*vec4(1.0) + col.y*vec4(1,0.5,0,0) + col.z*vec4(0,0.5,1,0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ---------------------------------------------\nconst float or = 18.0;         // outer gaussian std dev\nconst float ir = 6.0;         // inner gaussian std dev\nconst float b1 = 0.19;         // birth1\nconst float b2 = 0.212;        // birth2\nconst float s1 = 0.267;        // survival1\nconst float s2 = 0.445;        // survival2\nconst float dt = 0.2;          // timestep\nconst float alpha_n = 0.017;   // sigmoid width for outer fullness\nconst float alpha_m = 0.112;   // sigmoid width for inner fullness\n// ---------------------------------------------\n\nbool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\n// the logistic function is used as a smooth step function\nfloat sigma1(float x,float a,float alpha) \n{ \n    return 1.0 / ( 1.0 + exp( -(x-a)*4.0/alpha ) );\n}\n\nfloat sigma2(float x,float a,float b,float alpha)\n{\n    return sigma1(x,a,alpha) \n        * ( 1.0-sigma1(x,b,alpha) );\n}\n\nfloat sigma_m(float x,float y,float m,float alpha)\n{\n    return x * ( 1.0-sigma1(m,0.5,alpha) ) \n        + y * sigma1(m,0.5,alpha);\n}\n\n// the transition function\n// (n = outer fullness, m = inner fullness)\nfloat s(float n,float m)\n{\n    return sigma2( n, sigma_m(b1,s1,m,alpha_m), \n        sigma_m(b2,s2,m,alpha_m), alpha_n );\n}\n\n#define T(d) texture(iChannel0, fract(uv+d)).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 tx = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord.xy * tx;\n\t\n    const float _K0 = -20.0/6.0; // center weight\n    const float _K1 = 4.0/6.0;   // edge-neighbors\n    const float _K2 = 1.0/6.0;   // vertex-neighbors\n    \n    /* \n\tWe can optionally add a laplacian to the update rule\n\tto decrease the appearance of aliasing, but we also\n\tintroduce subtle anisotropy by doing so.\n        vec4 t = vec4(tx, -tx.y, 0.0);\n        float u =    T( t.ww); float u_n =  T( t.wy); float u_e =  T( t.xw);\n        float u_s =  T( t.wz); float u_w =  T(-t.xw); float u_nw = T(-t.xz);\n        float u_sw = T(-t.xy); float u_ne = T( t.xy); float u_se = T( t.xz);\n        float lapl  = _K0*u + _K1*(u_n + u_e + u_w + u_s) + _K2*(u_nw + u_sw + u_ne + u_se);\n    */    \n\n    vec4 current = texture(iChannel0, uv);\n    vec2 fullness = texture(iChannel1, uv).xy;\n    \n    float delta =  2.0 * s( fullness.x, fullness.y ) - 1.0;\n    float new = clamp( current.x + dt * delta, 0.0, 1.0 );\n    \n    if(iMouse.z > 0.0) {\n        // from chronos' SmoothLife shader https://www.shadertoy.com/view/XtdSDn\n        float dst = length(fragCoord.xy - iMouse.xy);\n        if(dst <= or) {\n        \tnew = step((ir+1.5), dst) * (1.0 - step(or, dst));\n        }\n    }\n    \n    vec4 init = texture(iChannel2, uv);\n    if(iFrame < 10 || reset() || (init != vec4(0) && current.w == 0.0)) {\n    \tfragColor = vec4(2.0*init.xyz,1.0);    \n    } else {\n    \tfragColor = vec4(new, fullness, current.w);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define SQRT_2_PI 2.50662827463\n\n// ---------------------------------------------\nconst float or = 18.0;         // outer gaussian std dev\nconst float ir = 6.0;          // inner gaussian std dev\nconst int   oc = 50;           // sample cutoff\n// ---------------------------------------------\n\n\nvec2 gaussian(float i, vec2 a, vec2 d) {\n     return a * exp( -(i*i) / d );\n}\n\nvec2 gaussian1d(sampler2D sam, vec2 sigma, vec2 uv, vec2 tx) {\n    vec2 a = vec2(1.0 / (sigma * SQRT_2_PI));\n    vec2 d = vec2(2.0 * sigma * sigma);\n    vec2 acc = vec2(0.0);\n    vec2 sum = vec2(0.0);\n    \n    // centermost term\n    acc += a * texture(sam, uv).x;\n    sum += a;\n\n    // sum up remaining terms symmetrically\n    for (int i = 1; i <= oc; i++) {\n        float fi = float(i);\n        vec2 g = gaussian(fi, a, d);\n        vec2 posL = fract(uv - tx * fi);\n        vec2 posR = fract(uv + tx * fi);\n        acc += g * (texture(sam, posL).x + texture(sam, posR).x);\n        sum += 2.0 * g;\n    }\n\n    return acc / sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 tx = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord.xy * tx;\n    tx = (mod(float(iFrame),2.0) < 1.0) ? vec2(tx.x,0) : vec2(0,tx.y);\n    vec2 x_pass = gaussian1d(iChannel0, vec2(or, ir), uv, tx);\n    fragColor = vec4(x_pass,0,0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define SQRT_2_PI 2.50662827463\n\n// ---------------------------------------------\nconst float or = 18.0;         // outer gaussian std dev\nconst float ir = 6.0;          // inner gaussian std dev\nconst int   oc = 50;           // sample cutoff\n// ---------------------------------------------\n\n\nvec2 gaussian(float i, vec2 a, vec2 d) {\n     return a * exp( -(i*i) / d );\n}\n\nvec2 gaussian1d(sampler2D sam, vec2 sigma, vec2 uv, vec2 tx) {\n    vec2 a = vec2(1.0 / (sigma * SQRT_2_PI));\n    vec2 d = vec2(2.0 * sigma * sigma);\n    vec2 acc = vec2(0.0);\n    vec2 sum = vec2(0.0);\n    \n    // centermost term\n    acc += a * texture(sam, uv).x;\n    sum += a;\n\n    // sum up remaining terms symmetrically\n    for (int i = 1; i <= oc; i++) {\n        float fi = float(i);\n        vec2 g = gaussian(fi, a, d);\n        vec2 posL = fract(uv - tx * fi);\n        vec2 posR = fract(uv + tx * fi);\n        acc += g * (texture(sam, posL).xy + texture(sam, posR).xy);\n        sum += 2.0 * g;\n    }\n\n    return acc / sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 tx = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord.xy * tx;\n    tx = (mod(float(iFrame),2.0) < 1.0) ? vec2(0,tx.y) : vec2(tx.x,0);\n    vec2 y_pass = gaussian1d(iChannel0, vec2(or, ir), uv, tx);\n    fragColor = vec4(y_pass,0,0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}