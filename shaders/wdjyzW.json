{
    "Shader": {
        "info": {
            "date": "1586264527",
            "description": "A 16-cell can be truncated to a 24-cell, an interesting polytope wth no regular 3d analogue.\n\nSome keyboard controls added, see code header.",
            "flags": 48,
            "hasliked": 0,
            "id": "wdjyzW",
            "likes": 6,
            "name": "Truncation of 16-Cell to 24-Cell",
            "published": 3,
            "tags": [
                "polytope",
                "24cell",
                "16cell"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 351
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// 16- to 24-cell truncation\n//\n// Matthew Arcus, 2020.\n//\n// A modification of https://www.shadertoy.com/view/WdfcW2, showing a\n// 16-cell being truncated to become a 24-cell (a very interesting\n// regular polytope which has no 3d regular equivalent - Matt Parker\n// likes it: https://www.youtube.com/watch?v=oJ7uOj2LRso).\n//\n// <mouse>: rotation\n// <up>/<down>: move in and out\n// <left>/<right>: select polytope, 0=morph, 1=24-cell, 2=intermediate, 3=16-cell\n// c: clifford translation\n// f: faces\n// x: fold\n// r: rotation\n//\n// Also illustrates adding faces to the polytope (the 24-cell has, as\n// you might guess, 24 octahedral cells, but 16 of them are the\n// truncated cells of the original 16-cell, but 8 are from vertex\n// figure of the 16-cell. We draw faces for the 8 vertex figure so the\n// picture doesn't get too cluttered. Turning off folding with 'x'\n// helps to see what is going on.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// As before. Start off with some global variables.\n\nbool dorotate = false;  // Autorotate scene\nbool doclifford = true; // Do Clifford translation\nbool dofaces = true;\nint ktype = 0; // 0 = morphing, 1 = 24-cell, 2 = ???, 3 = 16-cell\n\n// To see what is going on better, set the 'nofold' option to just see a single\n// tetrahedral hyperface. Reduce eyedist eg. to 2.0 to see this better.\nbool nofold = false;\nfloat eyedist = 2.0;     // Distance of eye from origin\nvec3 light = vec3(0,2,1); // Light direction\nint numsteps = 200;       // Maximum raymarching steps\nfloat precis = 1e-3;      // Raymarching precision\nfloat lfactor = 0.3;      // \"Lipschitz\" factor (note new fudge calculation in march())\nfloat eradius = 0.03;    // Radius of edge\nfloat pradius = 0.1;     // Radius of point\nfloat fradius = 0.01;    // \"Radius\" of face - ie. thickness\n\nfloat PI = 3.1415927;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n//#define assert(x)\n\n// The outer wrapper is the same as the octahedron shader, so let's\n// start with the DE function.\n\n// Auxiliary functions\n// Spherical distance between points on hypersphere\nfloat sdistance(vec4 p, vec4 q);\n// Spherical distance from p to great circle through q and r\nfloat ssegment(vec4 p, vec4 q, vec4 r); \n\nvec4 stereographic(vec3 p3, inout float scale); // Stereographic projection\nvec4 qmul(vec4 p, vec4 q); // Quaternion multiplication\n\n// q should be a normalized normal to face.\nfloat facedist(vec4 p, vec4 q) {\n  vec4 p0 = p - dot(p,q)*q;\n  p0 = normalize(p0);\n  float t = sdistance(p,p0);\n  return t;\n}\n\n// Distance to a triangular face, vertices q,r,s. These define a 3d\n// subspace, map to that subspace and clamp to the bounds of the\n// triangle, which gives the closest point on the triangle, then\n// return the spherical distance to that point.  Note that the inverse\n// matrix could be precalculated if q,r,s are fixed.\nfloat facedist(vec4 p, vec4 q, vec4 r, vec4 s) {\n  mat3 m = mat3(dot(q,q),dot(q,r),dot(q,s),\n                dot(q,r),dot(r,r),dot(r,s),\n                dot(q,s),dot(r,s),dot(s,s));\n  vec3 a = inverse(m)*vec3(dot(p,q),dot(p,r),dot(p,s));\n  a = max(a,0.0);\n  vec4 p0 = a[0]*q+a[1]*r+a[2]*s;\n  p0 = normalize(p0);\n  float t = sdistance(p,p0);\n  return t;\n}\n\nfloat de(vec3 p3, out int type) {\n  float scale = 1.0;\n  vec4 p = stereographic(p3,scale);\n\n  if (doclifford) {\n    float t = 0.1*iTime;\n    // The 'normalize' here shouldn't be necessary, but sin and cos\n    // can be relatively inaccurate.\n    vec4 Q = normalize(vec4(-sin(t)*vec3(0,1,0),cos(t)));\n    p = qmul(Q,p);\n  }\n\n  // Exactly as with the octahedron, set p = abs(p), reflecting\n  // everything into the positive sector and into a single\n  // (tetrahedral) hyperface. Then sort the coordinates to\n  // take everything into a small sector around vertex A(1,0,0,0).\n  if (!nofold) {\n    p = abs(p);\n  }\n  // Sort the coordinates\n  if (p.x < p.y) p.xy = p.yx;\n  if (p.z < p.w) p.zw = p.wz;\n  if (p.x < p.z) p.xz = p.zx;\n  if (p.y < p.w) p.yw = p.wy;\n  if (p.y < p.z) p.yz = p.zy;\n  \n  // Check all is well. On my laptop there is a weird bug where if\n  // these assertions are removed, the sort doesn't get done\n  // properly.\n  assert(p.x >= p.y);\n  assert(p.y >= p.z);\n  assert(p.z >= p.w);\n  \n  // The tetrahedron is on the hyperplane x+y+z+w = 1, but we need to\n  // project everything onto the hypersphere, with |p| = 1, so though\n  // we do our calculations on the hyperplane, we normalize\n  // before drawing anything (we could do this in the drawing\n  // functions, but it's more efficient to do it once and for all\n  // here).\n\n  // The main tetrahedron, (A,B,C,D). Just a normal R3 equilateral\n  // tetrahedron with side length sqrt(2), it just happens to be in\n  // R4 rather than R3 (like the equilateral triangle side of the\n  // octahedron in the earlier shader).\n  vec4 A = vec4(1,0,0,0);\n  vec4 B = vec4(0,1,0,0);\n  vec4 C = vec4(0,0,1,0);\n  vec4 D = vec4(0,0,0,1);\n  // To truncate, slice off the 'corner' tetrahedron, (A1,B1,C1,D1).\n  // We can do this gradually with parameter K - K = 0, no truncation,\n  // K = 0.5, full truncation, K = 1/3, an intermediate uniform\n  // polytope (must look up its name).\n  float t = mod(0.5*iTime,4.0);\n  t = clamp(min(t,3.0-t),0.0,1.0);\n  float K = 0.5*smoothstep(0.0,1.0,t);\n  if (ktype == 1) K = 0.5;\n  if (ktype == 2) K = 0.3333;\n  if (ktype == 3) K = 0.0;\n  float K1 = 1.0-K;\n  vec4 A1 = A;\n  vec4 B1 = K1*A+K*B;\n  vec4 C1 = K1*A+K*C;\n  vec4 D1 = K1*A+K*D;\n\n  // Normalize to hypersphere for drawing. I expect the compiler\n  // can constant fold these.\n  A1 = normalize(A1);\n  B1 = normalize(B1);\n  C1 = normalize(C1);\n\n  // Now draw the points and lines.\n  float d = 1e8, d0 = d;\n  d = min(d,ssegment(p,B1,B)-eradius);\n  if (d < d0) type = 2; d0 = d;\n  d = min(d,ssegment(p,B1,C1)-eradius);\n  if (d < d0) type = 0; d0 = d;\n  d = min(d,sdistance(p,B1)-pradius);\n  if (d < d0) type = 1; d0 = d;\n\n  if (dofaces) {\n    d = min(d,facedist(p,B1,C1,D1)-fradius);\n    if (d < d0) type = 3; d0 = d;\n  }\n  \n  // Finally return the distance, but taking into account the\n  // scaling factor from the stereographic projection.\n  return d/scale;\n}\n\n// The revised raymarcher - this now has a much harder job to do - the\n// surface can now extend out as far as the eye can see and even pass\n// through the eye point itself, and the surface itself is more\n// complex so we must tread carefully. As mentioned above, its a good\n// idea to use a 'Lipschitz' factor to reduce the step size and also\n// keep the step below some limit. To avoid many inefficient small\n// steps when stepping out to a distant point, the limit should be\n// dependent on the distance travelled so far, and the desired\n// precision should also be distance dependent for similar reasons.\n\n// Another problem to deal with here is negative steps, which as our\n// DE function is signed, will happen and are usually a good thing -\n// but if we find ourselves stepping backwards past the eye point,\n// then we should give up - this can easily happen if the surface can\n// passes through the eye point, for example.\n\n// Of course, all these cautious changes means that we might\n// need to do more steps, so increase numsteps accordingly - we can\n// still use our assertion to see how many steps are actually being\n// taken and find that 50 or fewer usually suffice.\n\nfloat de(vec3 p) { int t; return de(p,t); }\n\nfloat maxdist = 10.0;\nfloat march(vec3 q, vec3 r) {\n  float t = 0.01; // Total distance so far.\n  maxdist = eyedist + 10.0;\n  for (int i = 0; i < numsteps; i++) {\n    //assert(i < 50);\n    vec3 p = q+t*r;\n    float d = de(p);\n    if (abs(d) < t*precis) return t;\n    t += d/(1.0+lfactor*d);\n    // We can go backwards!\n    if (t < 0.0 || t > maxdist) break;\n  }\n  return -1.0;\n}\n\n// Measuring distances on the hypersphere: this is done just like on a R3\n// sphere, measuring along a great circle route, so the dot product of\n// the two vectors gives the cosine of the angle between them, and the\n// spherical distance is just that angle.\nfloat sdistance(vec4 p, vec4 q) {\n  // acos gives the correct answer, but the Euclidean distance\n  // is a good approximation, particularly up close. The result is\n  // visually indistinguishable and acos is expensive (the Euclidean\n  // distance is an underestimate of the spherical distance, which is\n  // just what we want for raymarching).\n  //return acos(clamp(dot(p,q),-1.0,1.0));\n  return distance(p,q);\n}\n\n// Find the (spherical) distance from p to the line (great circle)\n// through q and r. Again, this is almost the same calculation as in\n// R3 - find the nearest point on the line to p by projecting p onto\n// the qr-plane and normalizing, then after checking the point is in\n// bounds, return the spherical distance to that point.\nfloat ssegment(vec4 p, vec4 q, vec4 r) {\n  // Map p to the plane defined by q and r (and the origin):\n  // p = aq + br + x, where q.x = r.x = 0 so:\n  // p.q = aq.q + br.q and:\n  // p.r = aq.r + br.r\n  // Solve by inverting a 2x2 matrix.\n  mat2 m = inverse(mat2(dot(q,q),dot(q,r),dot(q,r),dot(r,r)));\n  vec2 ab = m*vec2(dot(p,q),dot(p,r));\n  // p1 in plane of q,r, on hypersphere\n  ab = max(ab,0.0); // Clip to segment\n  vec4 p1 = normalize(ab[0]*q + ab[1]*r);\n  // And return the distance to the closest point.\n  return sdistance(p,p1);\n}\n\n// Get the normal of the surface at point p.\nvec3 getnormal(vec3 p, float t) {\n  float eps = 1e-3;\n  vec2 e = vec2(eps,0);\n  return normalize(vec3(de(p + e.xyy) - de(p - e.xyy),\n                        de(p + e.yxy) - de(p - e.yxy),\n                        de(p + e.yyx) - de(p - e.yyx)));\n}\n\nvec4 invert(vec4 p, vec4 q, float r2, inout float scale) {\n  // Invert p in circle, centre q, radius square r2.\n  // Return inverted point and multiply scale by scaling factor.\n  p -= q;\n  float k = r2/dot(p,p);\n  p *= k;\n  scale *= k;\n  p += q;\n  return p;\n}\n\nvec4 stereographic(vec3 p, inout float scale) {\n  return invert(vec4(p,0),vec4(0,0,0,-1),2.0,scale);\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Quaternion multiplication\n// (p+P)(q+Q) = pq + pQ + qP + PQ\nvec4 qmul(vec4 p, vec4 q) {\n  vec3 P = p.xyz, Q = q.xyz;\n  return vec4(p.w*Q+q.w*P+cross(P,Q),p.w*q.w-dot(P,Q));\n}\n\nvec3 getbackground(vec3 r) {\n  return vec3(0.5);\n  return r; // Colourful fun\n  return vec3(0); // The more sober option.\n}\n\nvec3 getbasecolor(int type) {\n  assert(type >= 0);\n  if (type == 0) return vec3(1,1,0.45);\n  if (type == 1) return vec3(0.2);\n  if (type == 2) return vec3(1,0,0);\n  return vec3(1,0,1);\n}\n\n// Rotate according to mouse position\nvec3 transformframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  // autorotation - we always rotate a little as otherwise nothing can\n  // be seen (since the z-axis is part of the model).\n  float t = 1.0;\n  if (dorotate) t += iTime;\n  p.yz = rotate(p.yz,-t*0.125);\n  p.zx = rotate(p.zx,-t*0.1);\n  return p;\n}\n\n// Follow ray from q, direction r.\nvec3 raycolor(vec3 q, vec3 r) {\n  float t = march(q,r);\n  if (t < 0.0) return getbackground(r);\n  vec3 p = q+t*r;\n  vec3 normal = getnormal(p,t);\n  int type;\n  de(p,type); // Just to get the object type\n  vec3 color = getbasecolor(type);\n  float ambient = 0.3;\n  float specular = type == 0 ? 0.0 : 0.1;\n  vec3 speccolor = type == 1 ? color : vec3(1);\n  float specularpow = 4.0;\n  vec3 lightdir = normalize(light);\n  float diffuse = 0.7*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+ diffuse;\n  float s = pow(max(0.0,dot(reflect(light,normal),r)),specularpow);\n  color += specular*s*speccolor;\n  color = mix(color,getbackground(r),t/maxdist);\n  return color;\n}\n\n// Get the colour for a screen point (with normalized coordinates)\nvec3 screencolor(vec2 z) {\n  vec3 eye = vec3(0,0,eyedist);\n  vec3 ray = vec3(z,-2);\n  eye = transformframe(eye);\n  ray = transformframe(ray);\n  light = transformframe(light);\n  ray = normalize(ray);\n  vec3 col = raycolor(eye,ray);\n  col = pow(col,vec3(0.4545)); // Gamma correction - see elsewhere\n  return col;\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_R = 82;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\n\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nbool keypress(int key) {\n   return texelFetch(iChannel0, ivec2(key,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nint mymod(int n, int m) {\n  // glsl % undefined for -ve arguments\n  if (n < 0) return m-1-(-n-1)%m;\n  else return n%m;\n}\n\n// The main function called by Shadertoy\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  // Set up options\n  dofaces = !keypress(CHAR_F);\n  dorotate = !keypress(CHAR_R);\n  doclifford = !keypress(CHAR_C);\n  nofold = keypress(CHAR_X);\n  eyedist *= 1.0+0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP));\n  ktype = mymod(keycount(KEY_RIGHT)-keycount(KEY_LEFT),4);\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 col = screencolor(z);\n  if (alert) col.r = 1.0; // Check nothing has gone wrong.\n  fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0) {\n      t = vec4(0);\n    } else {\n      t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}