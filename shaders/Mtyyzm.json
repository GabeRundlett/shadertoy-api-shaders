{
    "Shader": {
        "info": {
            "date": "1568213757",
            "description": "Physically based iridescence.\n\nClick mouse to adjust film thickness (x) and randomisation (y)",
            "flags": 0,
            "hasliked": 0,
            "id": "Mtyyzm",
            "likes": 6,
            "name": "Adjustable Iridescence",
            "published": 3,
            "tags": [
                "iridescence"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 229
        },
        "renderpass": [
            {
                "code": "const float tau = 6.283185;\n\nbool gTestFake;\n\n// Smooth perlin-style noise\nfloat Noise( vec3 p )\n{\n    p = floor(p) + smoothstep( 0., 1., fract(p) );\n    return texture(iChannel1,(p+.5)/32.).r;\n}\n\n\nvec4 Triplanar( sampler2D channel, vec3 uvw, vec3 n )\n{\n    vec3 weight = smoothstep(.5,1.,abs(n));\n    weight /= dot(weight,vec3(1));\n    return\tweight.x * texture(iChannel2,uvw.yz) +\n    \t\tweight.y * texture(iChannel2,uvw.zx) +\n    \t\tweight.z * texture(iChannel2,uvw.xy);\n}\n\n\nfloat Trace( vec3 rayStart, vec3 rayDirection )\n{\n    vec3 sphereCentre = vec3(0);\n    float sphereRadius = 1.;\n    vec3 d = vec3(0)-rayStart;\n    float dr = dot(rayDirection,d);\n    float closest2 = dot(d,d) - dr*dr;\n    \n    return ((closest2 > sphereRadius*sphereRadius) ? 1e30 :\n         \tdr - sqrt(sphereRadius*sphereRadius-closest2));\n}\n\nvec3 Normal ( vec3 pos )\n{\n    return normalize(pos);\n}\n\n\n// From https://www.shadertoy.com/view/llKSDz\n\n// based on SebH's https://www.shadertoy.com/view/MdKSzc\n//          h3r2tic's https://www.shadertoy.com/view/4dVSDy\n\n// Spectrum to xyz approx function from Sloan http://jcgt.org/published/0002/02/01/paper.pdf\n// Inputs:  Wavelength in nanometers\nfloat xFit_1931( float wave )\n{\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\nfloat yFit_1931( float wave )\n{\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\nfloat zFit_1931( float wave )\n{\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \n    \nvec3 xyzToRgb(vec3 XYZ)\n{\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\n\t                  -0.969256 , 1.875991,  0.041556,\n\t                   0.055648, -0.204043,  1.057311 );\n}\n\n\nvec3 WavelengthToRGB( float wavelength )\n{\n    return xyzToRgb(vec3(xFit_1931(wavelength),yFit_1931(wavelength),zFit_1931(wavelength)));\n}\n\n/*\n// thickness is in nm - same as wavelength\nvec3 FilmIridescence( float thickness, float ndoti, float idota )\n{\n    float slice = 1./abs(ndoti);\n    \n    // simulate cells/filaments that aren't films\n//    slice = min(slice,1./(1.-idota*idota));\n//    slice = mix(.8,1.,slice); // not sure what physical structure this emulates, but seems like an intuitive way to control it - doesn't really look like anything\n    \n//    slice = mix( 10., 11., abs(ndoti) ); // non-realistic, but very aesthetically pleasing and plausible\n    \n    float phase = thickness*slice;\n    \n    phase *= 2.; // *2 because reflection so passes through thickness twice\n    \n    vec3 modulation = vec3(0);\n    vec3 normalisation = vec3(0);\n    \nif ( (iFrame&64) != 0 )\n{\n    // reference (step of 10 looks identical to step of 1. or .1 for all values)\n    for ( float wavelength = 390.; wavelength <= 700.; wavelength += 10. )\n    {\n        float strength = (1.+cos(tau*phase/wavelength));\n        vec3 rgb = WavelengthToRGB( wavelength );\n        normalisation += rgb;\n        modulation += rgb*strength;\n    }\n}\nelse\n{\n    const float stp = 310./8., phs = stp*.0; // good at all thicknesses\n//    const float stp = 310./4., phs = stp*.25; // v good at low-thicknesses\n    for ( float wavelength = 390.+phs; wavelength <= 700.; wavelength += stp ) // big steps work fine until we get to high thicknesses, where they don't cancel out enough\n    {\n        float strength = (1.+cos(tau*phase/wavelength));\n        vec3 rgb = WavelengthToRGB( wavelength );\n        normalisation += rgb;\n        modulation += rgb*strength;\n    }\n    \n    // add artificial fade to hide artefacts caused by undersampling the spectrum\n    modulation = mix( modulation, normalisation, smoothstep(3000.,5000.,phase) );    \n}\n    \n    return modulation/normalisation;\n}*/\n\n// thickness is in nm - same as wavelength\nvec3 Iridescence( float span )\n{\n    float phase = span*2.; // *2 because reflection so passes through thickness twice\n\n    vec3 modulation = vec3(0);\n    vec3 normalisation = vec3(0);\n    \n    // reference (step of 10 looks identical to step of 1. or .1 for all values)\n    for ( float wavelength = 390.; wavelength <= 700.; wavelength += 1. )\n    {\n        float strength = (.5+.5*cos(tau*phase/wavelength));\n        vec3 rgb = WavelengthToRGB( wavelength );\n        normalisation += rgb;\n        modulation += rgb*strength;\n    }\n    \n    vec3 o = modulation/normalisation;\n    \n    if ( gTestFake ) o = clamp( o, 0., 1. ); // restrict it to just RGB values\n    \n    return o;\n}\n\n\n// emulate a linear-filtered texture lookup\nvec3 FilteredIridescence( float span )\n{\n    const float resolution = 256.; // 128 loses a red mauve colour near the start but is otherwise okay\n    const float range = 5000./resolution;\n    \n    float u = span/range;\n    float u0 = floor(u);\n    \n    float gamma = 2.2; //1.;\n    vec3 c0 = pow( Iridescence(u0*range), vec3(1./gamma) );\n    vec3 c1 = pow( Iridescence((u0+1.)*range), vec3(1./gamma) );\n\n    return pow( mix( c0, c1, fract(u) ), vec3(gamma) );\n}\n\n\nvec3 FakeIridescence( float span )\n{\n    return\n        clamp(\n            mix (\n                vec3(.5),\n                vec3(\n                    cos(span/48.-.1)*.75+.5,\n                    cos(span/43.+.0)*.51+.49,\n                    cos(span/36.+.1)*.5+.5\n                ),\n                vec3(\n                    1./(1.+pow(span/1300.,5.)),\n                    1./(1.+pow(span/1000.,5.)),\n                    1./(1.+pow(span/1000.,4.))\n                )\n            ),\n            0.,1.\n\t\t);\n}\n\n\nvec3 FilmIridescence( float thickness, float ndoti )\n{\n    float slice = 1./abs(ndoti);\n    \n    float span = thickness*slice;\n\n/*    if ( gTestFake )\n    {\n        return FakeIridescence( span );\n    }\n    else*/\n    {\n        return Iridescence( span );\n    }\n}    \n\n\n\nvec3 Sky( vec3 ray )\n{\n\treturn pow( texture(iChannel0,ray).rgb, vec3(2.2) );\n//\treturn 1./( 1.-.9*pow( texture(iChannel0,ray).rgb, vec3(2.2) ) ) - 1.; // reconstruct approx HDR\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n//    gTestFake = (fract(fragCoord.x/iResolution.x + iTime) > .333 );\n    gTestFake = false;//(iMouse.z <= 0.);\n    \n    vec2 a = vec2(0,-.25);//(iMouse.xy/iResolution.xy-.5)*vec2(1,.49)*6.283185;\n    a.x += iTime*.1;\n    vec3 camK = vec2(cos(a.y),sin(a.y)).xyx * vec3(cos(a.x),sin(a.x),1).yzx;\n    \n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n    \n    vec3 camPos = -camK*1.5+camJ*.25;\n    \n    vec3 ray = vec3((fragCoord-.5*iResolution.xy)/iResolution.y,1);\n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\n    ray = normalize(ray);\n    \n    float t = Trace( camPos, ray );\n    \n    if ( t > 1e10 )\n    {\n        fragColour.rgb = Sky(ray);\n    }\n    else\n    {\n        vec3 pos = camPos + t*ray;\n\n        vec3 normal = Normal(pos);\n\n        vec3 reflection = Sky(reflect(ray,normal));\n\n        //float thicknessBase = 50./(iMouse.x/iResolution.x);\n        float thicknessBase = 2000.*(iMouse.x/iResolution.x);\n        float thicknessRange = thicknessBase*iMouse.y/iResolution.y;\n        \n        // thickness in nanometres\n//        float thickness = thicknessBase + thicknessRange*Noise(pos/.1);\n        float thickness = thicknessBase + thicknessRange*Triplanar(iChannel2,pos,normal).r;\n\n        reflection *= 2.*FilmIridescence( thickness, dot(normal,ray) );//, ray.y );//dot(ray,normalize(cross(normal,vec3(0,1,0)))) );\n\n        fragColour.rgb = reflection;\n\n// soap bubble (front-side only!) - fresnel blend with sky background\n//fragColour.rgb = mix( Sky(ray), fragColour.rgb, mix(.02,1.,pow(1.+dot(normal,ray),5.)) );\n// solid ball\nfragColour.rgb = mix( vec3(.01/*,.0,.03*/)*(normal.y*.5+.5), fragColour.rgb, mix(.05,1.,pow(1.+dot(normal,ray),5.)) );\n    }\n    \n    fragColour.rgb = pow(3.*fragColour.rgb,vec3(1./2.2));\n    fragColour.a = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}