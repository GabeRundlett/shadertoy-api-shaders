{
    "Shader": {
        "info": {
            "date": "1525866410",
            "description": "This shader is based on Roice Nelson's work at https://www.shadertoy.com/view/MstcWr",
            "flags": 16,
            "hasliked": 0,
            "id": "4scfR2",
            "likes": 69,
            "name": "Mobius trans in hyper 3-space",
            "published": 3,
            "tags": [
                "mobius",
                "hyperbolic"
            ],
            "usePreview": 0,
            "username": "neozhaoliang",
            "viewed": 30059
        },
        "renderpass": [
            {
                "code": "/*\n    Keyboard control:\n    \n    Key 1 turn on/off applying the Mobius transformation\n    Key 2 turn on/off applying the elliptic rotation\n    Key 3 turn on/off applying the hyperbolic scaling\n    Key 4 turn on/off showing the Riemann sphere\n*/\n\n#define PI  3.1415926536\n#define E_  2.71828118285\n\n// Raymarching constants\n#define AA               1\n#define MIN_TRACE_DIST   0.01\n#define MAX_TRACE_STEPS  255\n#define PRECISION        1e-5\n#define FAR              100.\n\n// Animation speed\n#define anim_speed (iTime * .5)\n#define hue_speed  (iTime * .3)\n\n// grid and cone size\nconst vec2 polar_grid = vec2(0.4, PI / 7.0);\nconst vec2 cone_angle = normalize(vec2(1.5, 1.0));\n\n// Intensity constants\nconst float intensity_divisor = 40000.;\nconst float intensity_factor_max = 7.2;\nconst float center_intensity = 12.;\nconst float dist_factor = 3.;\nconst float ppow = 1.9;\n\n// Color constants\nconst float center_hue = 0.5;\nconst float center_sat = 0.18;\n\n// shape constants\nconst float strong_factor = 7.;\nconst float weak_factor = 1.;\nconst vec2 star_hv_factor = vec2(30, 1);\nconst vec2 star_diag_factor = vec2(30, 1);\n//const vec2 star_hv_factor = vec2(9.0, 0.3);\n//const vec2 star_diag_factor = vec2(12.0, 0.6);\n\n\n// b_apply: apply Mobius transformation or not\n// b_elliptic: apply rotation or not\n// b_hyperbolic: apply scaling or not\n// b_parabolic is true if b_elliptic and b_parabolic are both false\n// b_loxodromic is true if b_elliptic and b_parabolic are both true\nbool b_apply = true;\nbool b_elliptic = true;\nbool b_hyperbolic = true;\nbool b_riemann = true;  // action on Riemman sphere or not\nbool b_parabolic, b_loxodromic;\n\n// hsv to rgb conversion\nvec3 hsv2rgb(vec3 hsv)\n{\n    const vec3 p = vec3(0.0, 2.0/3.0, 1.0/3.0);\n    hsv.yz = clamp(hsv.yz, 0.0, 1.0);\n    return hsv.z*(0.63*hsv.y*(cos(2.*PI*(hsv.x + p)) - 1.0) + 1.0);\n}\n\n// Conversion between Euclidean distance and hyperbolic distance\n// in upper half space. They are inverse of each other.\nfloat eucToHyp(float d) { return log(d); }\nfloat hypToEuc(float d) { return pow(E_, d); }\n\n// 2d rotation\nvec2 rot2d(vec2 p, float a) { return cos(a) * p + sin(a) * vec2(p.y, -p.x); }\n\n// 1d and 2d rectangular grids\nfloat grid1d(float x, float size)\n{\n    return mod(x + 0.5 * size, size) - 0.5 * size;\n}\n\nvec2 grid2d(vec2 p, vec2 size)\n{\n    return mod(p + 0.5 * size, size) - 0.5 * size;\n}\n\n// 2d polar grids\nvec2 polarGrid(vec2 p, vec2 size)\n{\n    float theta = atan(p.y, p.x);\n    float r = eucToHyp(length(p));\n    return grid2d(vec2(r, theta), size);\n}\n\n/*\n * Complex arithmetic\n*/\nvec2 cmul(vec2 z, vec2 w)\n{\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w)\n{\n    return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) / dot(w, w);\n}\n\nvec2 csqrt(vec2 z)\n{\n    float r2 = dot(z, z);\n    float r = sqrt(sqrt(r2));\n    float angle = atan(z.y, z.x);\n    return r * vec2(cos(angle / 2.0), sin(angle / 2.0));\n}\n\n/*\n * Quaternion arithmetic\n*/\nvec4 qmul(vec4 p, vec4 q)\n{\n    return vec4(p.x * q.x - dot(p.yzw, q.yzw),\n                p.x * q.yzw + q.x * p.yzw + cross(p.yzw, q.yzw));\n}\n\nvec4 qdiv(vec4 p, vec4 q)\n{\n    return qmul(p, vec4(q.x, -q.yzw) / dot(q, q));\n}\n\n/*\n * Mobius transformation z --> (Az + B) / (Cz + D)\n*/\nstruct Mobius\n{\n    vec2 A, B, C, D;\n};\n\nconst Mobius mob = Mobius(\n    vec2(1, 0),\n    vec2(-1, 0),\n    vec2(1, 0),\n    vec2(1, 0)\n);\n\n// Apply Mobius transformation on complex plane\nvec2 applyMobius(vec2 z)\n{\n    vec2 z1 = cmul(mob.A, z) + mob.B;\n    vec2 z2 = cmul(mob.C, z) + mob.D;\n    return cdiv(z1, z2);\n}\n\n// Apply Mobius transformation on upper half space as quaternions\n// (x, y, z) --> (x + yi + zj + 0k)\nvec4 applyMobius(vec4 p)\n{\n    vec4 p1 = qmul(vec4(mob.A, 0., 0.), p) + vec4(mob.B, 0., 0.);\n    vec4 p2 = qmul(vec4(mob.C, 0., 0.), p) + vec4(mob.D, 0., 0.);\n    return qdiv(p1, p2);\n}\n\nfloat applyMobius(inout vec3 p)\n{\n    if (!b_apply)\n        return 1.0;\n\n    p = applyMobius(vec4(p, 0)).xyz;\n    float scale = length(p);\n    return scale > 1.0 ? 1.0 / scale : scale;\n}\n\n// A Mobius transformation of hyperbolic type is conjugate to a pure scaling\nvoid trans_hyperbolic(inout vec2 p)\n{\n    float d = eucToHyp(length(p)) - anim_speed * polar_grid.x;\n    // This avoids running out of resolution.\n    d = grid1d(d, polar_grid.x);\n    p = normalize(p) * hypToEuc(d);\n}\n\n// A Mobius transformation of elliptic type is conjugate to a pure rotation\nvoid trans_elliptic(inout vec2 p)\n{\n    p = rot2d(p, anim_speed * polar_grid.y);\n}\n\n// A Mobius transformation of parabolic type is conjugate to a pure translation\nvoid trans_parabolic(inout vec2 p)\n{\n    p.x += iTime * polar_grid.x / 3.;\n}\n\n// signed distance function for sphere kissing at y=0 with radius r\nfloat sdSphere(vec3 p, float r) { p.y -= r; return length(p) - r; }\n// signed distance functions for plane y=0 and y=c\nfloat sdPlane(vec3 p) { return p.y; }\nfloat sdPlane(vec3 p, float c) { return p.y - c; }\n// a cone in the upper hyperbolic space may be a usual cone at the origin\n// or a Dupin cyclide with its two horns on the plane\nfloat sdCone(vec3 p)\n{\n    float t = 1.0;\n    if (b_apply)\n    {\n        t = applyMobius(p);\n        p = normalize(p);\n    }\n    float q = length(p.xz);\n    return dot(cone_angle, vec2(q, -p.y)) * t;\n}\n\n// signed distance function for parabolic case\nfloat sdScene1(vec3 p)\n{\n    return b_apply ? min(sdPlane(p), sdSphere(p, 1.0)) : sdPlane(p, 0.5);\n}\n\n// signed distance function for elliptic/hyperbolic case\nfloat sdScene2(vec3 p)\n{\n    if (b_riemann)\n        return min(sdPlane(p), sdSphere(p, 1.));\n\n    return min(sdPlane(p), sdCone(p));\n}\n\nvec3 getColor(vec2 p, float pint)\n{\n    float sat = 0.75 / pow(pint, 2.5) + center_sat;\n    // change hue by time\n    float hue2 = b_parabolic ?\n        hue_speed - length(p.y) / 5.0 :\n        hue_speed - eucToHyp(length(p)) / 7.0;\n    float hue = center_hue + hue2;\n    return hsv2rgb(vec3(hue, sat, pint)) + pint / 3.;\n}\n\nfloat getIntensity1(vec2 p)\n{\n    float dist = length(p);\n    float disth = length(p * star_hv_factor);\n    float distv = length(p * star_hv_factor.yx);\n\n    vec2 q = 0.7071 * vec2(dot(p, vec2(1.)), dot(p, vec2(1., -1.)));\n    float dist1 = length(q * star_diag_factor);\n    float dist2 = length(q * star_diag_factor.yx);\n\n    // Middle point star intensity\n    float pint1 = .5 / (dist * dist_factor + 0.015)\n        + strong_factor / (distv * dist_factor + 0.01)\n        + weak_factor / (disth * dist_factor + 0.01)\n        + weak_factor / (dist1 * dist_factor + 0.01)\n        + weak_factor / (dist2 * dist_factor + 0.01);\n\n    return center_intensity * intensity_factor_max * pow(pint1, ppow) / intensity_divisor;\n}\n\nfloat getIntensity2(vec2 p)\n{\n    float angle = atan(polar_grid.x, polar_grid.y);\n    float dist  = length(p);\n    float disth = length(p * star_hv_factor);\n    float distv = length(p * star_hv_factor.yx);\n\n    vec2 q1 = rot2d(p, angle);\n    float dist1 = length(q1 * star_diag_factor);\n    vec2 q2 = rot2d(p, -angle);\n    float dist2 = length(q2 * star_diag_factor);\n\n    float pint1 = 1. / (dist * dist_factor  + .5);\n    if (b_loxodromic)\n    {\n        pint1 = strong_factor / (dist2 * dist_factor + 0.01)\n            + weak_factor  / (dist1 * dist_factor + 0.01)\n            + weak_factor / (disth * dist_factor + 0.01)\n            + weak_factor / (distv * dist_factor + 0.01);\n    }\n    else if (b_elliptic)\n    {\n        pint1 += weak_factor / (distv * dist_factor + 0.01) +\n            strong_factor / (disth * dist_factor + 0.01) +\n            weak_factor / (dist1 * dist_factor + 0.01) +\n            weak_factor / (dist2 * dist_factor + 0.01);\n    }\n    else\n    {\n        pint1 += weak_factor / (disth * dist_factor + 1.) +\n            strong_factor / (distv * dist_factor + .01) +\n            weak_factor / (dist1 * dist_factor + 0.01) +\n            weak_factor / (dist2 * dist_factor + 0.01);\n    }\n    return intensity_factor_max * pow(pint1, ppow) / intensity_divisor * center_intensity * 3.;\n}\n\nfloat map(vec3 pos)\n{\n    return b_parabolic ? sdScene1(pos) : sdScene2(pos);\n}\n\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(.003, 0);\n    float d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n    float d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n    float d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    float d = map(p) * 2.;\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k)\n{\n    const int maxShadeIterations = 20;\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < maxShadeIterations; i++)\n    {\n        float h = map(ro + rd * t);\n        res = min(res, smoothstep(0., 1., k * h / t));\n        t += clamp(h, 0.01, 0.2);\n        if (abs(h) < 1e-4 || t > tmax)\n            break;\n    }\n    return clamp(res+0.15, 0.0, 1.0);\n}\n\n\n// iq's ambient occlusion\nfloat calcAO(vec3 p, vec3 n)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n);\n        occ += (h - d) * sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat trace(vec3 ro, vec3 rd, out vec2 p, out float pint)\n{\n    float depth = MIN_TRACE_DIST;\n    float dist;\n    vec3 pos;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++)\n    {\n        pos = ro + rd * depth;\n        dist = map(pos);\n        if (dist < PRECISION || depth >= FAR)\n            break;\n        depth += dist;\n    }\n    if (b_parabolic)\n    {\n        if (b_apply)\n            pos /= dot(pos, pos);\n\n        p = pos.xz;\n        trans_parabolic(pos.xz);\n        pos.xz = grid2d(pos.xz, vec2(polar_grid.x / 2.0));\n        pint = getIntensity1(pos.xz);\n    }\n    else\n    {\n        applyMobius(pos);\n        p = pos.xz;\n        if (b_hyperbolic) trans_hyperbolic(pos.xz);\n        if (b_elliptic)   trans_elliptic(pos.xz);\n        pos.xz = polarGrid(pos.xz, polar_grid);\n        pint = getIntensity2(pos.xz);\n    }\n    return depth;\n}\n\n// ACES tone mapping\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 tonemap(vec3 color)\n{\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\n\nconst int CHAR_1 = 49;\nconst int CHAR_2 = 50;\nconst int CHAR_3 = 51;\nconst int CHAR_4 = 52;\n\n// https://www.shadertoy.com/view/lsXGzf\nbool keypress(int code) \n{\n\treturn texelFetch(iChannel0, ivec2(code,2), 0).x != 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    b_apply = !keypress(CHAR_1);\n    b_elliptic = !keypress(CHAR_2);\n    b_hyperbolic = !keypress(CHAR_3);\n    b_riemann = keypress(CHAR_4);\n\n    b_parabolic = !(b_elliptic || b_hyperbolic);\n    b_loxodromic = b_elliptic && b_hyperbolic;\n    vec3 ro = vec3(-2., 4.2, 5.0);\n    //ro.xz = rot2d(ro.xz, iTime*0.3);\n    vec3 lookat = vec3(0.0, 0.6, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    vec3 tot = vec3(0);\n    vec3 lp = ro + vec3(.2, .8, -0.2);\n    \n\n    for (int ii = 0; ii < AA; ii++)\n    {\n        for (int jj = 0; jj < AA; jj++)\n        {\n            vec2 offset = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (fragCoord + offset) / iResolution.xy;\n            uv = 2.0 * uv - 1.0;\n            uv.x *= iResolution.x / iResolution.y;\n            vec3 rd = normalize(uv.x * r + uv.y * u + 4.0 * f);\n            vec2 p;\n            float pint;\n            float t = trace(ro, rd, p, pint);\n            if (t >= 0.0)\n            {            \n                vec3 col = tonemap(4.0 * getColor(p, pint));\n                vec3 pos = ro + rd * t;\n                vec3 nor = getNormal(pos);\n                vec3 ld = lp - pos;\n                float dist = max(length(ld), 0.001);\n                ld /= dist;\n                float at = 2.2/(1. + dist*.1 + dist*dist*.05); \n                float ao = calcAO(pos, nor);\n                float sh = softShadow(pos, ld, 0.04, dist, 8.);\n         \n                float diff = clamp(dot(nor, ld), 0.0, 1.0);\n                float spec = max( 0.0, dot( reflect(-ld, nor), -rd));\n\t            spec = pow(spec, 50.0);\n                tot += diff * 2.5 * col + vec3(0.6, 0.8, 0.8) * spec * 2.;\n                tot *= ao * sh * at;\n            }\n            if(t >= FAR)\n                lp = normalize(lp - ro - rd*FAR);\n \n            vec3 bg = mix(vec3(.5, .7, 1), vec3(1, .5, .6), .5 - .5*lp.y) * .3;\n            tot = mix(clamp(tot, 0., 1.), bg, smoothstep(0., FAR-2., t));\n        }\n    }\n    tot /= float(AA * AA);\n    fragColor = vec4(sqrt(clamp(tot, 0., 1.)), 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}