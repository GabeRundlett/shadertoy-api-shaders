{
    "Shader": {
        "info": {
            "date": "1633100200",
            "description": "wooo inktober\nthis is basically ink right\n\nwatch me successfully do no more of these haha",
            "flags": 32,
            "hasliked": 0,
            "id": "NsdXD8",
            "likes": 17,
            "name": "i21/1 - Crystal",
            "published": 3,
            "tags": [
                "caustics",
                "inktober"
            ],
            "usePreview": 0,
            "username": "Molive",
            "viewed": 427
        },
        "renderpass": [
            {
                "code": "//uniform sampler2D T;\n//layout(location = 2) uniform vec3 TexCoord;\n#define TexCoord vec3(iResolution.xy,0)\n#define T iChannel0\nconst float a = 3.;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{  \n\tvec2 uv=fragCoord.xy/iResolution.xy;\n    vec4 tex=texture(T,uv);\n    vec3 c= a*tex.rgb/tex.a;\n\n    vec3 color = c;\n    \n    float n = length(color);\n    color*=pow(n,1.1)*6.;\n\n\tcolor=color*(1.+(color/10.))/(1.+color);\n\n\tuv-=.5;   \n    // gamma correction and a slight blue color grading\n\tcolor=pow(color, .45*vec3(1.0,1.1,1.2))*(1.-dot(uv,uv)*.75);\n    \n\tfragColor.rgb=color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi (acos(-1.))\n\nconst int matDiffuse=0;\nconst int matMirror=1;\nconst int matBlack=2;\nconst int matLiquid=3;\nconst int matLight=4;\nconst vec3 lightpos=vec3(24.,12.,-29.);\n//const vec3 lightpos=vec3(19.,12.,-23.);\n#define Epsilon 1.000001\n#define pixelRadius 0.0001\n\n//A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nvec2 random( uvec2  v ) {return vec2(floatConstruct(hash( v.x ^ hash(v.y))),floatConstruct(hash( v.y ^ hash(v.x))));}\n\nvec2 uv;\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\n    /// Returns a point on a sphere, r is in 0..1 range\nvec3 pointOnSphere(vec2 r) {\n    r=vec2(6.283185*r.x,2.*r.y-1.);\n    return vec3(sqrt(Epsilon-r.y*r.y)*vec2(cos(r.x),sin(r.x)),r.y); // 1.001 required to avoid NaN\n}\n \n    /// Returns a cosine weighted sample\nvec3 lambertSample(vec3 n,vec2 r) {\n    return normalize(n*Epsilon+pointOnSphere(r)); // 1.001 required to avoid NaN\n}\n\n// plane degined by p (p.xyz must be normalized)\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// sphere of size ra centered at point ce\nvec4 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec4(-1.0); // no intersection\n    h = sqrt( h );\n    float t = (-b-h);\n    return vec4( t, (oc+t*rd)/ra );\n}\n\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n#if 0\n    // Cramer's rule for solcing p(t) = ro+t·rd = p(u,v) = vo + u·(v1-v0) + v·(v2-v1)\n    float d = 1.0/determinant(mat3(v1v0, v2v0, -rd ));\n    float u =   d*determinant(mat3(rov0, v2v0, -rd ));\n    float v =   d*determinant(mat3(v1v0, rov0, -rd ));\n    float t =   d*determinant(mat3(v1v0, v2v0, rov0));\n#else\n    // The four determinants above have lots of terms in common. Knowing the changing\n    // the order of the columns/rows doesn't change the volume/determinant, and that\n    // the volume is dot(cross(a,b,c)), we can precompute some common terms and reduce\n    // it all to:\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n#endif    \n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return vec3( t, u, v );\n}\n\nvec4 octahedronIntersect( in vec3 ro, in vec3 rd)\n{\n    vec3 sro = sign(ro);\n    rd = rd*sro;\n    ro = ro*sro;\n    \n    const vec3 v0 = vec3(5,0,0);\n    const vec3 v1 = vec3(0,0,5);\n    const vec3 v2 = vec3(0,5,0);\n    const vec3 v3 = vec3(0,0,-5);\n    const vec3 v4 = vec3(0,-5,0);\n    const vec3 v5 = vec3(-5,0,0);\n    const vec3 v1v0 = v1 - v0;\n    const vec3 v2v0 = v2 - v0;\n    const vec3 v3v0 = v3 - v0;\n    const vec3 v4v0 = v4 - v0;\n    const vec3 v1v5 = v1 - v5;\n    const vec3 v2v5 = v2 - v5;\n    const vec3 v3v5 = v3 - v5;\n    const vec3 v4v5 = v4 - v5;\n    vec3 rov0 = ro - v0;\n    vec3 rov5 = ro - v5;\n\n    const vec3 t1n = cross( v2v0, v1v0 );\n    const vec3 t2n = cross( v3v0, v2v0 );\n    const vec3 t3n = cross( v4v0, v3v0 );\n    const vec3 t4n = cross( v1v0, v4v0 );\n    const vec3 t5n = cross( v1v5, v2v5 );\n    const vec3 t6n = cross( v2v5, v3v5 );\n    const vec3 t7n = cross( v3v5, v4v5 );\n    const vec3 t8n = cross( v4v5, v1v5 );\n    vec3  q = cross( rov0, rd );\n    float d,t,u,v;\n    \n    d = 1.0/dot( rd, t1n );\n    u = d*dot( -q, v1v0 );\n    v = d*dot(  q, v2v0 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 ) return vec4( d*dot( -t1n, rov0 ), normalize(t1n*sro));\n    \n    d = 1.0/dot( rd, t2n );\n    u = d*dot( -q, v2v0 );\n    v = d*dot(  q, v3v0 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 ) return vec4( d*dot( -t2n, rov0 ), normalize(t2n*sro));\n    \n    d = 1.0/dot( rd, t4n );\n    u = d*dot( -q, v4v0 );\n    v = d*dot(  q, v1v0 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 ) return vec4( d*dot( -t4n, rov0 ), normalize(t4n*sro));\n    \n    d = 1.0/dot( rd, t3n );\n    u = d*dot( -q, v3v0 );\n    v = d*dot(  q, v4v0 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 ) return vec4( d*dot( -t3n, rov0 ), normalize(t3n*sro));\n    \n    q = cross( rov5, rd );\n    \n    d = 1.0/dot( rd, t5n );\n    u = d*dot( -q, v2v5 );\n    v = d*dot(  q, v1v5 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 ) return vec4( d*dot( -t5n, rov5 ), normalize(t5n*sro));\n    \n    d = 1.0/dot( rd, t6n );\n    u = d*dot( -q, v3v5 );\n    v = d*dot(  q, v2v5 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 ) return vec4( d*dot( -t6n, rov5 ), normalize(t6n*sro));\n    \n    d = 1.0/dot( rd, t8n );\n    u = d*dot( -q, v1v5 );\n    v = d*dot(  q, v4v5 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 ) return vec4( d*dot( -t8n, rov5 ), normalize(t8n*sro));\n    \n    // You can never see this face\n    /*d = 1.0/dot( rd, t7n );\n    u = d*dot( -q, v4v5 );\n    v = d*dot(  q, v3v5 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 ) return vec4( d*dot( -t7n, rov5 ), normalize(t7n*sro));*/\n    \n    return vec4(-1,1,0,0);\n}\n\nbool inside;\n\nvec4 octahedronIntersectInternal( in vec3 ro, in vec3 rd)\n{\n    vec3 sro = sign(ro);\n    rd = rd*sro;\n    ro = ro*sro;\n        \n    const vec3 v0 = vec3(5,0,0);\n    const vec3 v1 = vec3(0,0,5);\n    const vec3 v2 = vec3(0,5,0);\n    const vec3 v3 = vec3(0,0,-5);\n    const vec3 v4 = vec3(0,-5,0);\n    const vec3 v5 = vec3(-5,0,0);\n    const vec3 v1v0 = v1 - v0;\n    const vec3 v2v0 = v2 - v0;\n    const vec3 v3v0 = v3 - v0;\n    const vec3 v4v0 = v4 - v0;\n    const vec3 v1v5 = v1 - v5;\n    const vec3 v2v5 = v2 - v5;\n    const vec3 v3v5 = v3 - v5;\n    const vec3 v4v5 = v4 - v5;\n    vec3 rov0 = ro - v0;\n    vec3 rov5 = ro - v5;\n\n    const vec3 t1n = cross( v1v0, v2v0 );\n    const vec3 t2n = cross( v2v0, v3v0 );\n    const vec3 t3n = cross( v3v0, v4v0 );\n    const vec3 t4n = cross( v4v0, v1v0 );\n    const vec3 t5n = cross( v2v5, v1v5 );\n    const vec3 t6n = cross( v3v5, v2v5 );\n    const vec3 t7n = cross( v4v5, v3v5 );\n    const vec3 t8n = cross( v1v5, v4v5 );\n    float d,t,u,v;\n    \n    vec3 q = cross( rov5, rd );\n    vec4 side;\n    \n    d = 1.0/dot( rd, t7n );\n    u = d*dot(  q, v4v5 );\n    v = d*dot( -q, v3v5 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 && d < 0.) return vec4( d*dot( -t7n, rov5 ), normalize(t7n*sro));\n    \n    d = 1.0/dot( rd, t8n );\n    u = d*dot(  q, v1v5 );\n    v = d*dot( -q, v4v5 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 && d < 0.) return vec4( d*dot( -t8n, rov5 ), normalize(t8n*sro));\n    \n    d = 1.0/dot( rd, t6n );\n    u = d*dot(  q, v3v5 );\n    v = d*dot( -q, v2v5 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 && d < 0.) return vec4( d*dot( -t6n, rov5 ), normalize(t6n*sro));\n\n    d = 1.0/dot( rd, t5n );\n    u = d*dot(  q, v2v5 );\n    v = d*dot( -q, v1v5 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 && d < 0.) return vec4( d*dot( -t5n, rov5 ), normalize(t5n*sro));\n    \n    q = cross( rov0, rd );\n    vec4 side2;\n    \n    d = 1.0/dot( rd, t3n );\n    u = d*dot(  q, v3v0 );\n    v = d*dot( -q, v4v0 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 && d < 0.) return vec4( d*dot( -t3n, rov0 ), normalize(t3n*sro));\n    \n    d = 1.0/dot( rd, t4n );\n    u = d*dot(  q, v4v0 );\n    v = d*dot( -q, v1v0 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 && d < 0.) return vec4( d*dot( -t4n, rov0 ), normalize(t4n*sro));\n    \n    d = 1.0/dot( rd, t2n );\n    u = d*dot(  q, v2v0 );\n    v = d*dot( -q, v3v0 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 && d < 0.) return vec4( d*dot( -t2n, rov0 ), normalize(t2n*sro));\n    \n    d = 1.0/dot( rd, t1n );\n    u = d*dot(  q, v1v0 );\n    v = d*dot( -q, v2v0 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 && d < 0.) return vec4( d*dot( -t1n, rov0 ), normalize(t1n*sro));\n    \n    return vec4(-1,1,0,0);\n}\n\nvec2 hash2( float p ) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// hacky parameter to control the size\nfloat T=4.;\n\nint mat;\nfloat inv;\n\n// intersection function\nvec4 iScene(vec3 ro, vec3 rd)\n{\n    mat = matLiquid;\n    vec4 innerScene;\n    if (inside) {\n    innerScene = octahedronIntersectInternal(ro,rd);\n    } else {\n    innerScene = octahedronIntersect(ro,rd);\n    }\n    if (innerScene.x > 0.) return innerScene;\n    mat = matLight;\n    vec4 light = sphIntersect(ro,rd,lightpos,10.);\n    if (light.x > 0.) return light;\n    mat = matDiffuse;\n    float plane = plaIntersect(ro, rd, vec4(0,1,0,5));\n    if (plane > 0.) return vec4(plane, 0.,1.,0.);\n    //vec4 curve = iCylinderInverse(ro,rd, vec3(-10.,11.,0.), vec3(0.,0.,1.),15.);\n    //if (curve.x > 0. && ro.x+rd.x*curve.x <= -10.) return curve;\n    return vec4(0);\n}\n\nvec2 rv2;\nint bounce = 0;\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    const vec3 lightdir = normalize(vec3(.7,.4,-1));\n    \n    const float THRESHOLD = .02;\n\n    vec3 accum = vec3(1);\n    inside = false;\n    for(bounce = 0;bounce<3;bounce++)\n    {\n        float t = 0.;\n        float k = 0.;\n        vec3 n = vec3(1,0,0);\n        vec3 h = vec3(0);\n        rv2 = random(uvec2(abs(rv2*2000.)));\n\n        t = 0.;\n        k = 0.;\n        n = vec3(1,0,0);\n        h = vec3(0);\n        mat = matBlack;\n        vec4 scene = iScene(cam,dir);\n        if (scene.x > 0.) \n        {\n            t = scene.x;\n            n = scene.yzw;\n            h = cam+dir*t;\n            k = THRESHOLD;\n            \n            /*if (inside) {\n                n= n*-1.;\n            }*/\n\n            // if we hit something\n\n            float fresnel = pow(1.-dot(-dir,n),5.);\n            fresnel*=1.-step(.99,fresnel);\n            \n            // debug normals visualization\n            //if (inside)\n            //if (mat != matBound)\n            //if (mat != matLiquid)\n            //return vec3(n*.1+0.1);\n            //return (n*.5+.5) * (.7+.3*step(1.4,length(step(.1,fract(h.xz-.5)))));\n\n            if (mat == matDiffuse)\n            {\n                // bounce the ray in a random direction\n                if (rv2.x > 0.) {\n                    dir = lambertSample(n,rv2);\n                } else {\n                    dir = normalize(lightpos + lambertSample(n,rv2) * 6. - cam);\n                }\n                accum *= dot(dir,n);\n            }\n            else if (mat == matLight)\n            {\n                return accum * vec3(6.,5.5,5.) * step(.8,dot(dir,lightdir));\n            }\n            else if (mat == matMirror)\n            {\n                n += sin(h*4.).bgr*.001;\n                n += sin(h*3.77).bgr*.001;\n                n += sin(h*.737).bgr*.001;\n                \n                accum *= fresnel*.7+.3;\n                dir = reflect(dir,n);\n            }\n            else if (mat == matLiquid)\n            {\n                // Randomly reflect or refract, probability based on fresnel term\n                // If non-fresnel, refract\n                if (rv2.x > fresnel) {\n                    // refraction\n                    // Index of refraction\n                    float ior = inside ? 1.364 : 1./1.364;\n        \n                    // Find refraction angle, accounting for surface roughness\n                    vec3 rayDir = normalize( // Ray dir must be normalised\n                          mix( // Mix between...\n                              refract(dir, n, ior), // the refracted angle\n                              lambertSample(-n, rv2), // and a random angle projected into the surface\n                              0.01 // based on how smooth the glass surface is\n                              )\n                          );\n        \n                    // Test for total internal reflection\n                    if(dot(n, dir) < 0.0) {\n                        // Not TIR, we're OK to refract\n            \n                        // Set the ray direction\n                        dir=rayDir;\n            \n                        // Flip the inside value as we pass through the surface\n                        inside=!inside;\n                        bounce--;\n                        cam = h + dir * 2. * max(THRESHOLD * 4.,abs(k));\n\n                        if (!inside) {\n                        accum *= vec3(1.) - t * vec3(0.1,0., 0.01);\n                        }\n                        continue;\n                    }\n                }\n    \n                // Ray failed to refract, therefore reflection\n                accum *= fresnel*.7+.3;\n                dir = reflect(dir,n);\n            } else {\n            return vec3(0,0,1);\n            }\n            \n            cam = h + dir * THRESHOLD * 1.1 / dot(dir,n);\n        }\n        else {\n        bounce++;\n        break;\n        }\n    }\n    return vec3(0);\n}\n\nvec2 ringDof(vec2 seed)\n{\n    seed=fract(seed);\n    if (seed.y>seed.x)\n        seed=1.-seed;\n    float r=seed.x;\n    float a=(seed.y/seed.x)*pi*2.;\n    return vec2(cos(a),sin(a))*r;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // grab the previous color so we can iteratively render.\n    // in the actual executable I just rendered additively to a single framebuffer instead\n   \tfragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    \n    uv = fragCoord.xy/iResolution.xy-.5;\n\n    // random function borrowed from I can't remember where\n    float seed = float(((int(iFrame*73856093))^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n\trv2 = hash2( 24.4316544311+float(iFrame)+seed );\n    //rv2 = random(uvec2(normalize(abs(vec2(seed, 24.4316544311+iFrame+seed)))*20000.0));\n\n    \n    // jitter camera for antialiasing\n    uv += (rv2-.5)/iResolution.xy;\n    \n    // correct UVs for aspect ratio\n    uv.x*=iResolution.x/iResolution.y;\n    \n    // make a camera\n\tvec3 cam = vec3(1.,1.,-80.);\n    //vec3 cam = vec3(0.1,0.1,0.1);\n    vec3 dir = normalize(vec3(uv,2.5));\n\n    // slight jitter for dof\n    //const float dofScale = .05 ;\n    //const float dofDist = 10.;\n    //vec2 dofJitter = ringDof(rv2);\n    //cam.xy += dofJitter*dofScale;\n    //dir.xy -= dofJitter*dofScale/dofDist;\n\n    // spin it to an isometric angle\n    cam.yz = rotate(cam.yz, pi/12.);\n    dir.yz = rotate(dir.yz, pi/12.);\n    \n    // debug camera rotation\n    if (iMouse.z > 0.) {\n        float a = .8-3.*(iMouse.y/iResolution.y);\n    \tcam.yz = rotate(cam.yz, a);\n    \tdir.yz = rotate(dir.yz, a);\n    }\n\n    // spin it to an isometric angle\n    cam.xz = rotate(cam.xz, pi/1.8);\n    dir.xz = rotate(dir.xz, pi/1.8);\n    \n    // debug camera rotation\n    if (iMouse.z > 0.) {\n        float a = 1.-8.*(iMouse.x/iResolution.x);\n    \tcam.xz = rotate(cam.xz, a);\n    \tdir.xz = rotate(dir.xz, a);\n    }\n    \n    // compute the pixel color\n    vec3 pixel = vec3(0);\n    for (int i = 0; i < 8; i++) {\n        pixel += trace(cam,dir);\n    }\n    pixel /= 8.;\n   \n    // reset buffer if we're clicking\n     if (iMouse.z > 0.) fragColor *= .1;\n\n    // accumulate the pixel\n    //if(pixel.r >= 0.)\n    fragColor += vec4(pixel,1);\n    \n    //gl_FragColor = vec4(random(uvec2(abs(uv*1000.))),1.0,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}