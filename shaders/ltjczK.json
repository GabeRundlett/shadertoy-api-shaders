{
    "Shader": {
        "info": {
            "date": "1509395286",
            "description": "Just a study on complex functions and a visualisation technique called [url=https://en.wikipedia.org/wiki/Domain_coloring]domain coloring[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "ltjczK",
            "likes": 33,
            "name": "Visual Complex",
            "published": 3,
            "tags": [
                "2d",
                "domain",
                "plane",
                "complex",
                "functions",
                "coloring"
            ],
            "usePreview": 0,
            "username": "rigel",
            "viewed": 1283
        },
        "renderpass": [
            {
                "code": "// Author: Rigel \n// licence: https://creativecommons.org/licenses/by/4.0/\n// link: https://www.shadertoy.com/view/ltjczK\n\n\n/*\nWhen you graph a real function y=f(x) you need a plane (2D). When you \ngraph a complex function w=f(z), to see the relationship between \nthe input complex plane (2D) and the output complex plane (2D), you need 4D. \nBecause humans are not able to see in 4D one technique to visualize \nthese functions is to use color hue, and saturation as the two extra \ndimensions. This technique is called domain coloring. \nhttps://en.wikipedia.org/wiki/Domain_coloring\n\nIn case you know nothing about complex numbers, or need a refresher\nthis youtube serie is very good !\nhttps://www.youtube.com/watch?v=T647CGsuOVU\n*/\n\n#define speed iTime*.05\n\nvec2 toCarte(vec2 z) { return z.x*vec2(cos(z.y),sin(z.y)); }\nvec2 toPolar(vec2 z) { return vec2(length(z),atan(z.y,z.x)); }\n\n// All the following complex operations are defined for the polar form \n// of a complex number. So, they expect a complex number with the \n// format vec2(radius,theta) -> radius*eˆ(i*theta).\n// The polar form makes the operations *,/,pow,log very light and simple\n// The price to pay is that +,- become costly :/ \n// So I switch back to cartesian in those cases.\nvec2 zmul(vec2 z1,vec2 z2) { return vec2(z1.x*z2.x,z1.y+z2.y); }\nvec2 zdiv(vec2 z1, vec2 z2) { return vec2(z1.x/z2.x,z1.y-z2.y); }\nvec2 zlog(vec2 z) { return toPolar(vec2(log(z.x),z.y)); }\nvec2 zpow(vec2 z, float n) { return vec2(exp(log(z.x)*n),z.y*n); }\nvec2 zpow(float n, vec2 z) { return vec2(exp(log(n)*z.x*cos(z.y)),log(n)*z.x*sin(z.y)); }\nvec2 zpow(vec2 z1, vec2 z2) { return zpow(exp(1.),zmul(zlog(z1),z2)); }\nvec2 zadd(vec2 z1, vec2 z2) { return toPolar(toCarte(z1) + toCarte(z2)); }\nvec2 zsub(vec2 z1, vec2 z2) { return toPolar(toCarte(z1) - toCarte(z2)); }\n\n//sinz, cosz and tanz came from -> https://www.shadertoy.com/view/Mt2GDV\nvec2 zsin(vec2 z) {\n   z = toCarte(z);\n   float e1 = exp(z.y);\n   float e2 = exp(-z.y);\n   float sinh = (e1-e2)*.5;\n   float cosh = (e1+e2)*.5;\n   return toPolar(vec2(sin(z.x)*cosh,cos(z.x)*sinh));\n}\n\nvec2 zcos(vec2 z) {\n   z = toCarte(z);\n   float e1 = exp(z.y);\n   float e2 = exp(-z.y);\n   float sinh = (e1-e2)*.5;\n   float cosh = (e1+e2)*.5;\n   return toPolar(vec2(cos(z.x)*cosh,-sin(z.x)*sinh));\n}\n\nvec2 ztan(vec2 z) {\n    z = toCarte(z);\n    float e1 = exp(z.y);\n    float e2 = exp(-z.y);\n    float cosx = cos(z.x);\n    float sinh = (e1 - e2)*0.5;\n    float cosh = (e1 + e2)*0.5;\n    return toPolar(vec2(sin(z.x)*cosx, sinh*cosh)/(cosx*cosx + sinh*sinh));\n}\n\nvec2 zeta(vec2 z) {\n   vec2 sum = vec2(.0);\n   for (int i=1; i<20; i++) \n       sum += toCarte(zpow(float(i),-z));\n   return toPolar(sum);\n}\n\nvec2 lambert(vec2 z) {\n   vec2 sum = vec2(.0);\n   for (int i=1; i<15; i++)\n      sum += toCarte(zdiv(zpow(z,float(i)),zsub(vec2(1.,.0),zpow(z,float(i)))));\n   return toPolar(sum);\n}\n\nvec2 mandelbrot(vec2 z) {\n   vec2 sum = vec2(.0);\n   vec2 zc = toCarte(z);\n   for (int i=1; i<11; i++) \n       sum += toCarte(zpow(toPolar(sum),2.)) + zc;\n   return toPolar(sum);\n}\n\nvec2 julia(vec2 z) {\n    vec2 sum = toCarte(zpow(z,2.));\n    // the julia set is connected if C is in the mandelbrot set and disconnected otherwise\n    // to make it interesting, C is animated on the boundary of the main bulb\n    // the formula for the boundary is 0.5*eˆ(i*theta) - 0.25*eˆ(i*2*theta) and came from iq\n    // https://iquilezles.org/articles/mset1bulb\n    float theta = fract(speed)*2.*6.2830;\n    vec2 c = toCarte(vec2(0.5,.5*theta)) - toCarte(vec2(0.25,theta)) - vec2(.25,.0);\n    for (int i=0; i<7; i++) sum += toCarte(zpow(toPolar(sum),2.)) + c;\n    return toPolar(sum);\n}\n\nvec2 map(vec2 uv) {\n  \n\tfloat t = floor(mod(speed,10.));\n  \n\t//t = 7.;\n\tfloat s = t == 1.? 4.  : t==5.? .6: t==4.? 6. : t==5.? 2.5 : t== 9. ? 13. : 3.;  \n   \n    uv *= s + s*.2*cos(fract(speed)*6.2830);\n    \n    vec2 fz, z = toPolar(uv); \n    \t\n    \t // z + 1 / z - 1\n\tfz = t == 0. ? zdiv(zadd(z,vec2(1.0)),zsub(z,vec2(1.0,.0)) ) :\n         // formula from wikipedia https://en.m.wikipedia.org/wiki/Complex_analysis\n\t\t // fz = (zˆ2 - 1)(z + (2-i))ˆ2 / zˆ2 + (2+2i)\n\t\t t == 1. ? zdiv(zmul(zsub(zpow(z,2.),vec2(1.,0)),zpow(zadd(z,toPolar(vec2(2.,-1.))),2.)),zadd(zpow(z,2.),toPolar(vec2(2.,-2.)))) :\n\t\t // z^(3-i) + 1.\n\t\t t == 2. ? zadd(zpow(z,vec2(3.,acos(-1.))),vec2(1.,.0)) :\n\t\t // tan(z^3) / z^2\n\t\t t == 3. ? zdiv(ztan(zpow(z,3.)),zpow(z,2.)) :\n\t\t // tan ( sin (z) )\n\t\t t == 4. ? ztan(zsin(z)) :\n\t\t // sin ( 1 / z )\n\t\t t == 5. ? zsin(zdiv(vec2(1.,.0),z)) :\n\t\t // the usual coloring methods for the mandelbrot show the outside. \n\t\t // this technique allows to see the structure of the inside.\n\t\t t == 6. ? mandelbrot(zsub(z,vec2(1.,.0))) : \n         // the julia set \n\t\t t == 7. ? julia(z) :\n\t\t //https://en.m.wikipedia.org/wiki/Lambert_series\n\t\t t == 8. ? lambert(z) :\n\t\t // this is the Riemman Zeta Function (well, at least part of it... :P)\n\t\t // if you can prove that all the zeros of this function are \n    \t // in the 0.5 + iy line, you will win:\n\t\t // a) a million dollars ! (no, really...)\n\t\t // b) eternal fame and your name will be worshiped in history books\n\t\t // c) you will uncover the deep and misterious connection between PI and the primes\n\t\t // https://en.m.wikipedia.org/wiki/Riemann_hypothesis\n    \t // https://www.youtube.com/watch?v=rGo2hsoJSbo\n         zeta(zadd(z,vec2(8.,.0)));\n   \n \n\treturn toCarte(fz);  \n}\n\nvec3 color(vec2 uv) {\n    float a = atan(uv.y,uv.x);\n    float r = length(uv);\n    \n    vec3 c = .5 * ( cos(a*vec3(2.,2.,1.) + vec3(.0,1.4,.4)) + 1. );\n\n    return c * smoothstep(1.,0.,abs(fract(log(r)-iTime*.1)-.5)) // modulus lines\n             * smoothstep(1.,0.,abs(fract((a*7.)/3.14+(iTime*.1))-.5)) // phase lines\n             * smoothstep(11.,0.,log(r)) // infinity fades to black\n             * smoothstep(.5,.4,abs(fract(speed)-.5)); // scene switch\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t vec2 uv = (fragCoord.xy - iResolution.xy *.5)/iResolution.y;\n     fragColor = vec4( color(map(uv)), 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}