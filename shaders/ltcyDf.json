{
    "Shader": {
        "info": {
            "date": "1534369104",
            "description": "Coded live on twitch stream in Bonzomatic, and tidied/ported to shadertoy.\nUnedited Bonzomatic shader here: [url]https://gist.github.com/willkirkby/6e8fe226982fa18998a796ae72a7ad68[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "ltcyDf",
            "likes": 16,
            "name": "[twitch] Ferrofluid",
            "published": 3,
            "tags": [
                "ferrofluid"
            ],
            "usePreview": 0,
            "username": "yx",
            "viewed": 1323
        },
        "renderpass": [
            {
                "code": "//#define CHROMAB\n\nfloat height(vec2 uv)\n{\n    float curve = smoothstep(1.,0.,length(uv)) * .5;\n    float sinus = .8-length(fract(uv*6.+iTime*4.)-.5);\n    return curve * sinus;\n}\n\nfloat funnysphere(vec3 p)\n{\n    p.y *= 1.5;\n    vec3 n = normalize(p);\n    vec2 sg = p.xz / (1. + p.y);\n\n    float offset = length(fract(sg*6.+iTime*4.)-.5)*.35;\n\n    return length(p+vec3(0,.4,0))-1. + offset;\n}\n\nfloat _smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat smin( float a, float b)\n{\n    return _smin(a,b,25.);\n}\n\nfloat metaballs(vec3 p)\n{\n    p -= vec3(0,.65,0);\n\n    vec3 p0 = p + sin(vec3(2.13, 2.17, 2.37)*iTime)*.2;\n    vec3 p1 = p + sin(vec3(2.15, 2.87, 2.57)*iTime)*.2;\n    vec3 p2 = p + sin(vec3(2.11, 2.47, 2.97)*iTime)*.2;\n\n    return smin(\n        smin(\n        \tlength(p0)-.13,\n        \tlength(p1)-.13\n      \t),\n      \tlength(p2)-.13\n    );\n}\n\nfloat scene(vec3 p)\n{\n\treturn smin(\n\t    smin(\n\t\t\tp.y,\n\t\t\tfunnysphere(p)\n    \t),\n    \tmetaballs(p)\n  \t);\n}\n\nvec2 rotate(vec2 a, float b)\n{\n  \tfloat c = cos(b);\n  \tfloat s = sin(b);\n  \treturn vec2(\n\t    a.x * c - a.y * s,\n\t    a.x * s + a.y * c\n  \t);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n  \tvec2 uv = (fragCoord / iResolution.xy) - .5;\n  \tuv.x *= iResolution.x / iResolution.y;\n\n#if defined(CHROMAB)\n  \tfor (int c = 0; c < 3; ++c)\n  \t{\n#endif\n\t  \tvec3 cam = vec3(0,0,-5);\n\t  \tvec3 dir = normalize(vec3(uv, 4));\n\n  \t\tcam.xz = rotate(cam.xz, iTime*.2);\n  \t\tdir.xz = rotate(dir.xz, iTime*.2);\n\n  \t\tcam.y = .45;\n\n\t\tfloat t = 0.;\n\t\tint i = 0;\n    \tfor (i = 0; i< 100; ++i)\n    \t{\n\t    \tfloat k = scene(cam + dir * t);\n\t        t += k * .3;\n\t        if(k < .001)\n\t        \tbreak;\n\t    }\n\t\n\t  \tvec3 h = cam + dir * t;\n\t\n\t  \tvec2 o = vec2(.001, 0);\n\t  \tvec3 n = normalize(vec3(\n\t\t    scene(h+o.xyy)-scene(h-o.xyy),\n\t\t    scene(h+o.yxy)-scene(h-o.yxy),\n\t\t    scene(h+o.yyx)-scene(h-o.yyx)\n\t  \t));\n\t\n\t  \tfloat fresnel = pow(1.-max(0.,dot(n,-dir)),5.)*.96+.04;\n\t  \t#if defined(CHROMAB)\n\t  \t\tout_color[c] = fresnel;\n\t\t#else\n\t  \t\tout_color = vec4(fresnel);\n\t\t#endif\n\n#if defined(CHROMAB)\n        uv *= 1.02;\n    }\n#endif\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}