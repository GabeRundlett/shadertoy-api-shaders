{
    "Shader": {
        "info": {
            "date": "1632078616",
            "description": "Cinema 180°",
            "flags": 32,
            "hasliked": 0,
            "id": "sdyGDy",
            "likes": 0,
            "name": "Cinema 180°",
            "published": 3,
            "tags": [
                "screen",
                "seats",
                "roof"
            ],
            "usePreview": 0,
            "username": "Sergeindamix",
            "viewed": 249
        },
        "renderpass": [
            {
                "code": "\n// Created by SergeInDaMix\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nmat2 rot(float a) {\treturn mat2(cos(a), sin(a), -sin(a), cos(a)); }\n#define T iTime\n#define S(a,b,t) smoothstep(a,b,t)\n#define pi 3.1415926535898\n\n/////////////////////////\n\n\n// signed distance to a regular octogon\nfloat sdOctogon(in vec2 p, in float r)\n{\n    // >>>>>> (iestyn) <<<<<<  This is IQ's original version (https://www.shadertoy.com/view/llGfDG)\n    if (mod(T*0., 2.0) < 1.0)\n    {\n        // pi/8: cos, sin, tan.\n        const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2  // COS\n            0.3826834323,   // sqrt(2-sqrt(2))/2  // SIN\n            0.4142135623); // sqrt(2)-1          // TAN\n// reflections\n        p = abs(p);\n        p -= 2.0*min(dot(vec2(k.x, k.y), p), 0.0)*vec2(k.x, k.y);\n        p -= 2.0*min(dot(vec2(-k.x, k.y), p), 0.0)*vec2(-k.x, k.y);\n        // Polygon side.\n        p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n        return length(p)*sign(p.y);\n    }\n    // >>>>>> (iestyn) <<<<<<  This is my modified version, rotated by pi/8\n    else\n    {\n        // The tradeoff is swapping a reflection (dot, min, mul) for a 2D rotation (dot, dot)\n        // The two dot products are independent and can thus be pipelined, so it's possible that\n        // this version is marginally faster... though frankly it probably depends upon which GPU you use :)\n\n        // pi/8: cos, sin, tan (plus sin pi/4)\n        const vec4 k = vec4(-0.9238795325,   // sqrt(2+sqrt(2))/2  // COS PI/8\n            0.3826834323,   // sqrt(2-sqrt(2))/2  // SIN PI/8\n            0.4142135623,   // sqrt(2)-1          // TAN PI/8\n            0.7071067812); // 1/sqrt(2)          // SIN PI/4\n        p = abs(p);\n        p -= 2.0*min(dot(vec2(k.w, -k.w), p), 0.0)*vec2(k.w, -k.w);    // Reflect about pi/4 plane\n        p = vec2(dot(p, vec2(-k.y, -k.x)), dot(p, vec2(-k.x, k.y)));   // Rotate by 22.5 degrees\n        p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);                   // Collapse the polygon edge to a point\n        return length(p)*sign(p.y);\n    }\n}\nvec3 sdgBox(in vec2 p, in vec2 b)\n{\n    vec2 w = abs(p) - b;\n    vec2 s = vec2(p.x < 0.0 ? -1 : 1, p.y < 0.0 ? -1 : 1);\n    float g = max(w.x, w.y);\n    vec2  q = max(w, 0.0);\n    float l = length(q);\n    return vec3((g > 0.0) ? l : g,\n        s*((g > 0.0) ? q / l : ((w.x > w.y) ? vec2(1, 0) : vec2(0, 1))));\n}\nfloat smax(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5*(d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h*(1.0 - h);\n}\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\nvec3 opRepLim(in vec3 p, in float c, in vec3 l)\n{\n    vec3 q = p - c * clamp(round(p / c), -l, l);\n    return q;\n}\n\nfloat column(vec3 p)\n{\n    float box = sdBox(p, vec3(1, 1, .25));\n    float d = box;\n    vec2 h = vec2(1., 1.1);\n\n    float oct = sdOctogon(p.xy - vec2(-.7, .10), h.x);\n\n    d = smax(oct, d, .05);\n\n\n\n\n    return d;\n}\n\nfloat sdBoundingBox(vec3 p, vec3 b, float e)\n{\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n\n    return min(min(\n        length(max(vec3(p.x, q.y, q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0),\n        length(max(vec3(q.x, p.y, q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)),\n        length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0));\n}\n\n\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz)*p3.zy);\n}\n\nfloat hash(vec2 p) { return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\nvec4 circ(vec2 uv)\n{\n    //uv += 1;//\n    //uv *= .5;\n    vec4 col = vec4(1.0);\n    uv.x += iTime * 0.1;\n    uv += 12.0;\n    vec2 id = floor(uv*8.0);\n    vec2 ruv = fract(uv*8.0) - 0.5;\n\n    vec2 n = vec2(pow(sin(iTime*0.4 + hash22(id).x*1.5), 2.0),\n        pow(cos(iTime*1.2 + hash22(id*3.0 + 2.0).y*5.0), 2.0));\n\n    float d = max(dot(vec2(0.9, -0.8), n), 0.01);\n    float c = smoothstep(0.51, 0.3, length(ruv));\n    vec3 mcol = mix(vec3(1.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), d)*c*d;\n\n    col.xyz = mcol;\n    float w = 0.1;\n    vec2 a = vec2(uv.x - 0.5, uv.y - 0.66);\n    vec2 b = a * 0.15 / float(10.0);\n\n    uv += b * (hash(uv.xy + fract(iTime))*2.0);\n\n    for (float i = 1.0; i > 0.0; i -= 0.02)\n    {\n        uv -= 0.5;\n        uv *= i;\n        uv += 0.5;\n\n        col.rgb += mcol * w * 1.5;\n        w *= 0.97;\n    }\n    col *= 0.9;\n\n    return col;\n\n}\n//////////////////\n\n////////////////////////////\n//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define FK(k) int(k)^int(cos(k))\nfloat hash(float a, float b) {\n    int x = FK(a); int y = FK(b);\n    return float((x*x - y)*(y*y + x) + x) / 2.14e9;\n}\n\nfloat noise(vec2 uv) {\n    vec2 crds = smoothstep((0.), (1.), fract(uv));\n    uv = floor(uv);\n    float h1 = hash(uv.x, uv.y);\n    float h2 = hash(uv.x + 1., uv.y);\n    float h3 = hash(uv.x, uv.y + 1.);\n    float h4 = hash(uv.x + 1., uv.y + 1.);\n    return mix(mix(h1, h2, crds.x), mix(h3, h4, crds.x), crds.y);\n}\n\nvec2 map(vec2 uv) {\n    return (uv + vec2(0.7, 0.4))*vec2(1., iResolution.x / iResolution.y)*0.7;\n}\n\nvec4 projector(vec2 fragCoord)\n{\n    vec4 fragColor;\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    float rot = cos(sin(cos(iTime*0.01)*8.)*8.)*0.5;\n    uv*=mat2(cos(0.01*rot), sin(0.01*rot), -sin(0.01*rot), cos(0.01*rot));\n\n    float ntime = floor(iTime*25.) / 25.;\n    float trackingy = hash(ntime, ntime);\n    float trackingx = hash(trackingy, ntime);\n    float trackinglight = hash(trackingx, ntime)*0.05 + 1.;\n    uv.y += trackingy / iResolution.y*0.4;\n    uv.x += trackingx / iResolution.y*0.1;\n\n    vec4 color = vec4(0.0);\n    for (int i = -2; i < 3; i++) {\n        for (int j = -2; j < 3; j++) {\n            vec2 off = vec2(i, j) / iResolution.y / 4.*2.2;\n            float dispersion = hash(hash(hash(uv.x, uv.y), iTime), hash(float(i), float(j)))*0.02 + 1.;\n            float red = texture(iChannel0, map(uv*dispersion*1.03 + off)).x;\n            float green = texture(iChannel0, map(uv*dispersion*1.01 + off)).y;\n            float blue = texture(iChannel0, map(uv*dispersion*1.0 + off)).z;\n            color += pow(vec4(red, green, blue, 1.), vec4(2.));\n        }\n    }\n\n    vec3 satstr = vec3(0.1);\n    mat3 desaturate = (1. - satstr.x*2.) + mat3(satstr, satstr, satstr);\n\n    float bounds = smoothstep(0.02, -0.02, max(abs(uv.x) - 0.7, abs(uv.y) - 0.4)) * smoothstep(2., 0., length(uv));\n    float filmgrain = (noise((uv + mod(floor(ntime*60.), 100.))*iResolution.y / 1.5)*0.5 + 0.5)*0.05;\n    float shotnoise = abs(hash(hash(uv.x, uv.y), ntime))*0.05;\n    fragColor.xyz = smoothstep(-0.4, 2., desaturate*bounds*sqrt(color.xyz / color.w)*trackinglight);\n    fragColor.xyz += pow(1. / (1. + length(uv*vec2(2, 1) - vec2(1., .7))), 3.)*0.25*(sign(trackingy + 0.99)*0.5 + 0.5);\n    fragColor.xyz += pow(1. / (1. + length(uv*vec2(2, 1) - vec2(-1., .7))), 3.)*0.5;\n    fragColor.xyz += filmgrain * mix(0.3, 1.2, bounds) + shotnoise * mix(1.5, 0.5, bounds) + smoothstep(0.06, -0.06, max(abs(uv.x) - 0.7, abs(uv.y) - 0.4))*0.02;\n    fragColor.xyz *= smoothstep(2., 0.2, length(uv));\n    return fragColor;\n}\n/////////////////////////\nvec4 isom(vec2 fragCoord)\n{\n    vec4 fragColor;\n    vec2 I = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    vec2 a = vec2(2.0*I.x, I.x + I.y);\n    vec2 b = vec2(-2.0*I.x, -I.x + I.y);\n    vec2 c = vec2(-I.x - I.y, I.x - I.y);\n\n    fragColor = vec4(.0);\n\n    if (max(max(max(a.x, a.y), max(b.x, b.y)), max(c.x, c.y)) <= 1.0)\n        if (I.x >= 0.0 && I.x + I.y >= 0.0)\n            //fragColor = vec4(a,0.0,1.0);\n            fragColor = texture(iChannel0, a);\n        else if (I.x <= 0.0 && -I.x + I.y >= 0.0)\n            //fragColor = vec4(b,0.0,1.0);\n            fragColor = texture(iChannel1, b);\n        else\n            // fragColor = vec4(c,0.0,1.0);\n            fragColor = texture(iChannel2, c);\n    return fragColor;\n}\n\nvec4 lines(vec2 uv)\n{\t\t\t\t\n\n    float thickness = 0.21;\n    float speed = 0.5 * 0.;\n\n    float xPhase = mod(6.0*uv.x, 1.0) * 0.;\n    float yPhase = mod(1.09375*uv.y - speed * iTime, 1.0);\n    if (uv.y < 0.0)\n    {\n        yPhase = mod(.5*uv.y, 1.0);\n\n    }\n    float xIntensity = max(0.0, 1.0 - abs(0.5 - xPhase) / thickness);\n    float yIntensity = S(0.0, .1, 1. - yPhase / thickness);//**max(0.0, 1.0 - abs(0.5 - yPhase) / thickness);\n\n    vec4 color = vec4(0.3, 0.7, 1.0, 1.0);\n\n    vec4 result = (yIntensity + xIntensity)*color;\n\n    return result;\n}\n\nfloat cylix(vec3 p, float width, float height)\n{\n    float d = max(sdBox(p, vec3(width,height, width)),length(p.xz) - width);//cilindro\n\n    return d;\n}\n\nfloat arena(vec3 p, float width, float height)\n{\n\n    float d = cylix(p + vec3(0, 1. - height, 0), width, height);//width, height\n\n\n    return d;\n}\n\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat onion(in float d, in float h)\n{\n    return abs(d) - h;\n}\n\n//-------------------------------------------------\n\nfloat sdCappedCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat estadio(vec3 p)\n{\n    float c = 1e10;\n    // single onion cylinder\n    for (int i = 0; i < 10; i++)\n    {\n        float height = .1*float(i) + 1.;\n        float width = float(i) + 1.;\n        float addc = sdCappedCylinder(p, vec2(width, height));\n        //c = onion(addc, 0.02);\n        c = min(c, onion(addc, 0.52));\n        c = max(-arena(p + vec3(0, -height, 0), width, height), c);\n\n        c = max(c, -sdBox(p + vec3(0, -2.1, -6), vec3(11, 2, 6)));\n\n        //c = max(c, pos.y+.02*i);\n    }\n\n    return c;\n}\nfloat smin(float a, float b, float k)\n{\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h*h*k*(1.0 / 6.0);\n}\nfloat cabeza(vec3 p)\n{\n    float d = 1e10;\n    float r = .2;\n    vec3 q = p;\n    //q.xz = opRepLim(p.xz - vec2(0, 0), 3, vec2(0, -3), vec2(0, 1));\n\n    q.xy *= rot(.12);\n    q.y += .3;\n    d = min(d, length(q.xz) - r);//cilindro\n    d = max(d, q.y - .0);//cortar altura del cilindro\n    d = max(d, -q.y - .5);//cortar base del cilindro*/\n    q.xy *= rot(.54324);\n    d = smin(d, sdBox(q - vec3(.325, .1, 0), vec3(.2, .2, .2)), .6);\n    q = p;\n    //q.xz = opRepLim(p.xz - vec2(0, 0), 3, vec2(0, -3), vec2(0, 1));\n\n    d = smin(d, length(q) - .5, .515);\n\n    return d;\n}\nvec3 RotateY(vec3 v, float degree)\n{\n    float rad = 0.0174532925*degree;\n    float cosY = cos(rad);\n    float sinY = sin(rad);\n    return vec3(cosY*v.x - sinY * v.z, v.y, sinY*v.x + cosY * v.z);\n}\n\nvec3 map(vec3 p)\n{\n    float mid = 0.;\n\n    vec3 q = p;\n    vec3 pos = p;\n\n    q = opRepLim(p, 5.0, vec3(1, 0, 1));\n    q.x = abs(p.x);\n    float d0 = column(q - vec3(2, 0, 0));\n    float box = sdBox(p + vec3(0, 0, 0), vec3(3, 1, 10));\n    box = abs(box) - .1;\n\n    float d = box;\n\n\n    vec3 quad = sdgBox(p.xy - vec2(-.25, .1), vec2(4, .5));\n    quad = abs(quad) - .0125;\n\n    d = max(d, d - quad.x);\n\n    q.y += .5;\n    float sph = length(q) - .5;\n    float cyl = sdBox(q, vec3(.35));//length(q.xz) - .4;//cilindro\n    //cyl=max(-box,cyl);\n    sph = max(-sph, cyl);\n\n    q.y -= .5;\n    q *= 1.021;\n    float d1 = column(q - vec3(2, 0, 0));\n    float box2 = sdBox(p + vec3(0, -0, 0), vec3(3, 1, 10));\n    box2 = abs(box2) - .11;\n\n    float box3 = sdBox(p + vec3(0, -.1, -9.875), vec3(3, .5, .010));\n\n    float bobb = sdBoundingBox(p, vec3(.5), .035);\n    float bobc = sdBox(p+vec3(0,-.0,0), vec3(.45));\n\n\n    float c = estadio(p);\n    float c1 = sdCylinder(p, vec2(10.));\n    c1 = abs(c1) - .1;\n    float roof = arena(p + vec3(0, -10, 0), 10., 1.);\n    float c2 = arena(p + vec3(0, -0, 0), 1., .6);\n    float head = cabeza(p+vec3(0,1,0));\n    for (int i = 0; i < 9; i++)\n    {\n        q = p/.5;\n        float headAdd = cabeza(RotateY(q, -22.5 * float(i)) + vec3(5, -2, float(i)*pi));\n        head = smin(head, headAdd, .1);\n    }\n    //q= RotateY(q, -22.5*T);\n    float stnd = sdBoundingBox(p + vec3(0, -.75, 0), vec3(.5), .035);\n    \n    q = opRepLim(p, 5.0, vec3(1, 0, 1));\n    float screen = sdBox(q-vec3(0,4,0),vec3(1.5,2.,.01));\n\n    d = 1e10;\n\n\n    //if(d > sph){d = sph; mid = 2.;}\n    //if (d > d1) { d = d1; mid = 8.; }\n    //if (d > box2) { d = box2; mid = 9.; }\n    //if (d > box3) { d = box3; mid = 6.; }\n    //if (d > bobb) { d = bobb; mid = 8.; }\n    //if (d > bobc) { d = bobc; mid = 9.; }\n    if (d > c) { d = c; mid = 3.; }\n    if (d > c1) { d = c1; mid = 6.; }\n    if (d > c2) { d = c2; mid = 2.; }\n    if (d > roof) { d = roof; mid = 9.; }\n    //if (d > screen) { d = screen; mid = 6.; }\n    //if (d > stnd) { d = stnd; mid = 3.; }\n    //if (d > head) { d = head; mid = 3.; }\n\n\n    return vec3(d, mid, 0.);\n}\n\nvec3 get_normal(vec3 p) {\n    const vec2 e = vec2(0.002, 0);\n    return normalize(vec3(map(p + e.xyy).x-map(p - e.xyy).x, \n                          map(p + e.yxy).x-map(p - e.yxy).x,    \n                          map(p + e.yyx).x-map(p - e.yyx).x));\n}\n\nvec3 intersect(vec3 ro, vec3 rd)\n{\n    vec3 res;\n    float t = 0.01;\n    for(int i = 0; i < 124; ++i)\n    {\n        vec3 p = ro + rd * t;\n        res = map(p);\n        if(res.x < 0.005 * t || res.x > 20.)\n            break;\n        t += res.x;\n    }\n    \n    if(res.x > 20.) t = -1.;\n    return vec3(t, res.y, res.z);\n}\n\nvec3 remap(vec3 p)\n{\n    p.xy = (p.xy + vec2(0.7, 0.4))*vec2(1., iResolution.x / iResolution.y)*0.7;\n    return p;\n}\nvec3 remap2(vec3 p)\n{\n    p.xy *= .5 + .5;\n    return p;\n}vec3 remap3(vec3 p)\n{\n    p = remap2(p)/10.;\n\n    return p;\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    //6 faces texturing\n    p = remap3(p);\n    vec4 colXZ = projector(p.xz) * 5. * circ(p.xz);//texture(_Tex6, p.xz*.5 + .5)*5;\n    vec4 colYZ = projector(p.yz) * 5. * lines(p.yz) * 5.;//texture(sam, p.yz*.5 + .5)*5;\n\n    vec4 colXY = texture(iChannel2, p.xy*.5 + .5)*5.; //\n\n    n = abs(n);\n\n\n    n *= pow(n, vec3(2));\n    n /= n.x + n.y + n.z;\n\n    return colYZ * n.x + colXZ * n.y + colXY * n.z;\n    //return p1 * abs(n.z) + p2 * abs(n.y) + p3 * abs(n.x);\n}\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel0, 0.25*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r = 0.0, w = 1.0, d;\n    for(float i=1.; i<5.0+1.1; i++)\n    {\n        d = i/5.0;\n        r += w*(d - map(p + n*d).x);\n        w *= 0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\nfloat direct_light(vec3 p, vec3 lpos, vec3 n, float radius)\n{\n    vec3 ldir = (lpos - p);\n    float r = length(ldir);\n    ldir /= r;\n    float res = 1.;\n    res *= max(0., dot(ldir,  n))/r;\n    return (3.4-p.y)/3.4*res * (1. - smoothstep(0., radius, r));\n}\n\n\nfloat refl;\n\nvec3 lighting(vec3 ro, vec3 rd, vec3 p, vec3 n, float mid, float dist)\n\t\t\t{\n    vec3 l0_pos = vec3(0., 3, 0);//0., 2.4, floor((p.z+5.)/10.)*10.);\n    vec3 l0_dir = normalize(l0_pos - p);\n    vec3 l0_col = vec3(1.);\n\n    vec3 mc = vec3(1., 1.02, 0.92);\n\n    refl = 0.;\n\n\n    if (mid > 8.)\n    {\n        mc = texcube(iChannel0, p.xyz*2., n).xyz;\n    }\n    else if (mid > 7.)\n    {\n        mc = vec3(.996, .945, .882)*.2;\n    }\n    else if (mid > 6.)\n    {\n        mc = vec3(1., 1., 1.1)*1.1;\n        mc.yz -= pow(texcube(iChannel3, p.yxz*.8, n).x, 3.5)*3.5;\n        mc = max(vec3(0.), mc);\n    }\n    else if (mid > 5.)\n    {\n        p += 10.;//\n        p.x *= .5;\n        p.y -= 10.;\n\n        p *= .1;\n\n        mc = texture(iChannel0, p.xy).xyz*2.;\n    }\n    else if (mid > 4.)\n    {\n\n        mc = vec3(0.1);\n    }\n    else if (mid > 3.)\n    {\n        mc = vec3(0.9, 0.0, 0.);\n        if (abs(p.y + 0.4) < 0.1)\n            mc = vec3(1.);\n    }\n    else if (mid > 2.)\n    {\n        mc = texture(iChannel1, p.xz*.1).xyz * 0.5;\n        refl = 1.;\n    }\n    else if (mid > 1.)\n    {\n        mc = vec3(20.0);\n    }\n    else if (mid > 0.)\n    {\n        mc = vec3(0.3, 0.9, 1.) * 0.4;\n\n    }\n    /*else\n    {\n        if(p.y<2.9)\n        {\n            n=bump_mapping(p, n, 0.2/(1.+dist*0.4));\n        }\n\n        if(p.y>0.5 && (abs(abs(p.y)-2.2)<0.67))\n            mc=vec3(0.3, 0.9, 1.) * 0.5;\n\n    }\n\n    if(p.y < 0.5 && abs(p.x)>2.2 && (abs(abs(p.y)-3.)<0.18))\n    {\n        mc=vec3(0.3, 0.9, 1.) * 0.2;\n        refl = 0.8;\n    }\n\n    // bloody\n    {\n        vec3 q = p;\n        if(q.x<0.&&q.y>-2.9)\n           q.z += 1.;\n\n        mc.yz -= pow(texcube(iChannel3, q.xyz*.08, n).x,3.5)*3.5;\n        mc = max(vec3(0.),mc);\n\n    }*/\n\n\n    float occ = get_ao(p, n);\n    float dif = 8.*direct_light(p, l0_pos, n, 8.3);\n    float bac = max(0., dot(-l0_dir, n));\n    float bce = clamp(n.y * 0.8 + 0.2, 0.0, 1.0);\n    float spe = max(0.0, pow(clamp(dot(-rd, reflect(-l0_dir, n)), 0.0, 1.0), 20.0));\n\n    float env = 1.;\n\n    vec3 lin = vec3(0.);\n\n    lin += 4. * dif * occ;\n    lin += 0.5 * bac * (1.) * occ;\n    lin += 1.0 * bce * (1.) * occ;\n    lin += 1.0 * env * occ;\n    lin += 2.0* spe * (1.);\n    lin = lin * 0.2 * mc * (.5 + .5*occ);\n    return lin;\n}\n\n\nvec3 calc_reflection(vec3 ro, vec3 prev_rd, vec3 n, vec2 screen)\n{         \n    vec3 rd = reflect(prev_rd, n);\n    ro += 0.1 * n;\n\n    \n    vec3 res;\n    float t = 0.01;\n    for(int i = 0; i < 32; ++i)\n    {\n        vec3 p = ro + rd * t;\n        res = map(p);\n        if(res.x < 0.005 * t || res.x > 20.)\n            break;\n        t += res.x;\n    }\n    \n    if(res.x > 20.) t = -1.;\n    res = vec3(t, res.y, res.z);\n    \n    vec3 col = vec3(0.);\n    if(res.x > -.5)\n    {\n        vec3 pos = ro + res.x * rd;\n        n = get_normal(pos);\n        col = lighting(ro, rd, pos, n, res.y, res.x);\n    }\n    return col;\n}\n    \nvoid camera(inout vec3 ro, inout vec3 rd, in vec2 p)\n{\n    float v = 2.;\n    float fov = 1.3;\n    \n    vec3 look_at;\n    float yoffset=sin(iTime*2.)*0.02;\n    \n    if(iTime < 7.)\n    {\n   \t\tlook_at = vec3(0., 0., v);\n    \tro = look_at + vec3(0., -1.3, -23.+iTime*0.1);     \n    }\n    else if(iTime < 15.)\n    {\n        look_at = vec3(0., 0., v);\n    \tro = look_at + vec3(0., -1.3, -13.+iTime*0.1);\n    }\n    else\n    {\n        look_at = vec3(0., 0., v);\n    \tro = look_at + vec3(0., -1.3, -23.+iTime*0.1);     \n        /*look_at = vec3(5., 0., v);\n\n        ro = look_at + vec3(-6., -1.3+yoffset, -12.);*/\n\n    }\n      \n    vec3 f = normalize(look_at - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n    \n    rd = normalize(p.x * r + p.y * u + fov * f);\n}\n\t\t\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 q = fragCoord / iResolution.xy;\n    vec2 p = 2. * q - 1.;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 ro, rd;\n\tcamera(ro, rd, p); \n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    ro = vec3(0, 3, -3);\n       \n    ro.yz *= rot(-m.y*3.14+1.);\n    ro.xz *= rot(-m.x*6.2831);\n    vec3 res = intersect(ro, rd);\n    \n    vec3 col = vec3(0.);\n    \n    if(res.x > -0.5)\n    {\n        vec3 pos = ro + res.x * rd;\n        vec3 n = get_normal(pos);\n\n        col = lighting(ro, rd, pos, n, res.y, res.x);\n        if(refl > 0.)\n        {\n            float f = .04 + (1.-.04)*pow(1.-max(dot(n,-rd),0.),5.);\n            col += f*refl*calc_reflection(pos, rd, n, fragCoord);\n            //col += 0.2*refl*calc_reflection(pos, rd, n, fragCoord);\n             // bloody\n    \t\t{ \n        \t\tcol.yz -= pow(texcube(iChannel3, pos.xyz*.08, n).x,4.5)*4.5;\n        \t\tcol = max(vec3(0.),col);\n        \n    \t\t}\n        }\n        col=mix(col, 0.15*vec3(0.4,0.75,1.0), 1.0-exp(-0.0015*res.x*res.x) );\n\n    }\n    \n    fragColor.xyz = col;\n    fragColor.xyz = mix(fragColor.xyz, vec3(0.), smoothstep(1.,0., iTime));\n    /*if(iTime > 6.)\n    {\n        //fragColor.xyz = mix(fragColor.xyz, vec3(0.), smoothstep(0.,1., iTime-6.));\n        fragColor.xyz = mix(fragColor.xyz, vec3(0.), smoothstep(1.,0., iTime-7.));\n\n    }\n    if(iTime > 14.)\n    {\n        fragColor.xyz = mix(fragColor.xyz, vec3(0.), smoothstep(1.,0., iTime-15.));\n\n    }*/\n\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    },
                    {
                        "channel": 3,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Created by SergeInDaMix\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nmat2 rot(float a) {\treturn mat2(cos(a), sin(a), -sin(a), cos(a)); }\n#define T iTime\n#define S(a,b,t) smoothstep(a,b,t)\n#define pi 3.1415926535898\n\n/////////////////////////\n\n\n// signed distance to a regular octogon\nfloat sdOctogon(in vec2 p, in float r)\n{\n    // >>>>>> (iestyn) <<<<<<  This is IQ's original version (https://www.shadertoy.com/view/llGfDG)\n    if (mod(T*0., 2.0) < 1.0)\n    {\n        // pi/8: cos, sin, tan.\n        const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2  // COS\n            0.3826834323,   // sqrt(2-sqrt(2))/2  // SIN\n            0.4142135623); // sqrt(2)-1          // TAN\n// reflections\n        p = abs(p);\n        p -= 2.0*min(dot(vec2(k.x, k.y), p), 0.0)*vec2(k.x, k.y);\n        p -= 2.0*min(dot(vec2(-k.x, k.y), p), 0.0)*vec2(-k.x, k.y);\n        // Polygon side.\n        p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n        return length(p)*sign(p.y);\n    }\n    // >>>>>> (iestyn) <<<<<<  This is my modified version, rotated by pi/8\n    else\n    {\n        // The tradeoff is swapping a reflection (dot, min, mul) for a 2D rotation (dot, dot)\n        // The two dot products are independent and can thus be pipelined, so it's possible that\n        // this version is marginally faster... though frankly it probably depends upon which GPU you use :)\n\n        // pi/8: cos, sin, tan (plus sin pi/4)\n        const vec4 k = vec4(-0.9238795325,   // sqrt(2+sqrt(2))/2  // COS PI/8\n            0.3826834323,   // sqrt(2-sqrt(2))/2  // SIN PI/8\n            0.4142135623,   // sqrt(2)-1          // TAN PI/8\n            0.7071067812); // 1/sqrt(2)          // SIN PI/4\n        p = abs(p);\n        p -= 2.0*min(dot(vec2(k.w, -k.w), p), 0.0)*vec2(k.w, -k.w);    // Reflect about pi/4 plane\n        p = vec2(dot(p, vec2(-k.y, -k.x)), dot(p, vec2(-k.x, k.y)));   // Rotate by 22.5 degrees\n        p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);                   // Collapse the polygon edge to a point\n        return length(p)*sign(p.y);\n    }\n}\nvec3 sdgBox(in vec2 p, in vec2 b)\n{\n    vec2 w = abs(p) - b;\n    vec2 s = vec2(p.x < 0.0 ? -1 : 1, p.y < 0.0 ? -1 : 1);\n    float g = max(w.x, w.y);\n    vec2  q = max(w, 0.0);\n    float l = length(q);\n    return vec3((g > 0.0) ? l : g,\n        s*((g > 0.0) ? q / l : ((w.x > w.y) ? vec2(1, 0) : vec2(0, 1))));\n}\nfloat smax(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5*(d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h*(1.0 - h);\n}\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\nvec3 opRepLim(in vec3 p, in float c, in vec3 l)\n{\n    vec3 q = p - c * clamp(round(p / c), -l, l);\n    return q;\n}\n\nfloat column(vec3 p)\n{\n    float box = sdBox(p, vec3(1, 1, .25));\n    float d = box;\n    vec2 h = vec2(1., 1.1);\n\n    float oct = sdOctogon(p.xy - vec2(-.7, .10), h.x);\n\n    d = smax(oct, d, .05);\n\n\n\n\n    return d;\n}\n\nfloat sdBoundingBox(vec3 p, vec3 b, float e)\n{\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n\n    return min(min(\n        length(max(vec3(p.x, q.y, q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0),\n        length(max(vec3(q.x, p.y, q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)),\n        length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0));\n}\n\n\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz)*p3.zy);\n}\n\nfloat hash(vec2 p) { return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\nvec4 circ(vec2 uv)\n{\n    //uv += 1;//\n    //uv *= .5;\n    vec4 col = vec4(1.0);\n    uv.x += iTime * 0.1;\n    uv += 12.0;\n    vec2 id = floor(uv*8.0);\n    vec2 ruv = fract(uv*8.0) - 0.5;\n\n    vec2 n = vec2(pow(sin(iTime*0.4 + hash22(id).x*1.5), 2.0),\n        pow(cos(iTime*1.2 + hash22(id*3.0 + 2.0).y*5.0), 2.0));\n\n    float d = max(dot(vec2(0.9, -0.8), n), 0.01);\n    float c = smoothstep(0.51, 0.3, length(ruv));\n    vec3 mcol = mix(vec3(1.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), d)*c*d;\n\n    col.xyz = mcol;\n    float w = 0.1;\n    vec2 a = vec2(uv.x - 0.5, uv.y - 0.66);\n    vec2 b = a * 0.15 / float(10.0);\n\n    uv += b * (hash(uv.xy + fract(iTime))*2.0);\n\n    for (float i = 1.0; i > 0.0; i -= 0.02)\n    {\n        uv -= 0.5;\n        uv *= i;\n        uv += 0.5;\n\n        col.rgb += mcol * w * 1.5;\n        w *= 0.97;\n    }\n    col *= 0.9;\n\n    return col;\n\n}\n//////////////////\n\n////////////////////////////\n//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define FK(k) int(k)^int(cos(k))\nfloat hash(float a, float b) {\n    int x = FK(a); int y = FK(b);\n    return float((x*x - y)*(y*y + x) + x) / 2.14e9;\n}\n\nfloat noise(vec2 uv) {\n    vec2 crds = smoothstep((0.), (1.), fract(uv));\n    uv = floor(uv);\n    float h1 = hash(uv.x, uv.y);\n    float h2 = hash(uv.x + 1., uv.y);\n    float h3 = hash(uv.x, uv.y + 1.);\n    float h4 = hash(uv.x + 1., uv.y + 1.);\n    return mix(mix(h1, h2, crds.x), mix(h3, h4, crds.x), crds.y);\n}\n\nvec2 map(vec2 uv) {\n    return (uv + vec2(0.7, 0.4))*vec2(1., iResolution.x / iResolution.y)*0.7;\n}\n\nvec4 projector(vec2 fragCoord)\n{\n    vec4 fragColor;\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    float rot = cos(sin(cos(iTime*0.01)*8.)*8.)*0.5;\n    uv*=mat2(cos(0.01*rot), sin(0.01*rot), -sin(0.01*rot), cos(0.01*rot));\n\n    float ntime = floor(iTime*25.) / 25.;\n    float trackingy = hash(ntime, ntime);\n    float trackingx = hash(trackingy, ntime);\n    float trackinglight = hash(trackingx, ntime)*0.05 + 1.;\n    uv.y += trackingy / iResolution.y*0.4;\n    uv.x += trackingx / iResolution.y*0.1;\n\n    vec4 color = vec4(0.0);\n    for (int i = -2; i < 3; i++) {\n        for (int j = -2; j < 3; j++) {\n            vec2 off = vec2(i, j) / iResolution.y / 4.*2.2;\n            float dispersion = hash(hash(hash(uv.x, uv.y), iTime), hash(float(i), float(j)))*0.02 + 1.;\n            float red = texture(iChannel0, map(uv*dispersion*1.03 + off)).x;\n            float green = texture(iChannel0, map(uv*dispersion*1.01 + off)).y;\n            float blue = texture(iChannel0, map(uv*dispersion*1.0 + off)).z;\n            color += pow(vec4(red, green, blue, 1.), vec4(2.));\n        }\n    }\n\n    vec3 satstr = vec3(0.1);\n    mat3 desaturate = (1. - satstr.x*2.) + mat3(satstr, satstr, satstr);\n\n    float bounds = smoothstep(0.02, -0.02, max(abs(uv.x) - 0.7, abs(uv.y) - 0.4)) * smoothstep(2., 0., length(uv));\n    float filmgrain = (noise((uv + mod(floor(ntime*60.), 100.))*iResolution.y / 1.5)*0.5 + 0.5)*0.05;\n    float shotnoise = abs(hash(hash(uv.x, uv.y), ntime))*0.05;\n    fragColor.xyz = smoothstep(-0.4, 2., desaturate*bounds*sqrt(color.xyz / color.w)*trackinglight);\n    fragColor.xyz += pow(1. / (1. + length(uv*vec2(2, 1) - vec2(1., .7))), 3.)*0.25*(sign(trackingy + 0.99)*0.5 + 0.5);\n    fragColor.xyz += pow(1. / (1. + length(uv*vec2(2, 1) - vec2(-1., .7))), 3.)*0.5;\n    fragColor.xyz += filmgrain * mix(0.3, 1.2, bounds) + shotnoise * mix(1.5, 0.5, bounds) + smoothstep(0.06, -0.06, max(abs(uv.x) - 0.7, abs(uv.y) - 0.4))*0.02;\n    fragColor.xyz *= smoothstep(2., 0.2, length(uv));\n    return fragColor;\n}\n/////////////////////////\nvec4 isom(vec2 fragCoord)\n{\n    vec4 fragColor;\n    vec2 I = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    vec2 a = vec2(2.0*I.x, I.x + I.y);\n    vec2 b = vec2(-2.0*I.x, -I.x + I.y);\n    vec2 c = vec2(-I.x - I.y, I.x - I.y);\n\n    fragColor = vec4(.0);\n\n    if (max(max(max(a.x, a.y), max(b.x, b.y)), max(c.x, c.y)) <= 1.0)\n        if (I.x >= 0.0 && I.x + I.y >= 0.0)\n            //fragColor = vec4(a,0.0,1.0);\n            fragColor = texture(iChannel0, a);\n        else if (I.x <= 0.0 && -I.x + I.y >= 0.0)\n            //fragColor = vec4(b,0.0,1.0);\n            fragColor = texture(iChannel1, b);\n        else\n            // fragColor = vec4(c,0.0,1.0);\n            fragColor = texture(iChannel2, c);\n    return fragColor;\n}\n\nvec4 lines(vec2 uv)\n{\t\t\t\t\n\n    float thickness = 0.21;\n    float speed = 0.5 * 0.;\n\n    float xPhase = mod(6.0*uv.x, 1.0) * 0.;\n    float yPhase = mod(1.09375*uv.y - speed * iTime, 1.0);\n    if (uv.y < 0.0)\n    {\n        yPhase = mod(.5*uv.y, 1.0);\n\n    }\n    float xIntensity = max(0.0, 1.0 - abs(0.5 - xPhase) / thickness);\n    float yIntensity = S(0.0, .1, 1. - yPhase / thickness);//**max(0.0, 1.0 - abs(0.5 - yPhase) / thickness);\n\n    vec4 color = vec4(0.3, 0.7, 1.0, 1.0);\n\n    vec4 result = (yIntensity + xIntensity)*color;\n\n    return result;\n}\n\nfloat cylix(vec3 p, float width, float height)\n{\n    float d = max(sdBox(p, vec3(width,height, width)),length(p.xz) - width);//cilindro\n\n    return d;\n}\n\nfloat arena(vec3 p, float width, float height)\n{\n\n    float d = cylix(p + vec3(0, 1. - height, 0), width, height);//width, height\n\n\n    return d;\n}\n\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat onion(in float d, in float h)\n{\n    return abs(d) - h;\n}\n\n//-------------------------------------------------\n\nfloat sdCappedCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat estadio(vec3 p)\n{\n    float c = 1e10;\n    // single onion cylinder\n    for (int i = 0; i < 10; i++)\n    {\n        float height = .1*float(i) + 1.;\n        float width = float(i) + 1.;\n        float addc = sdCappedCylinder(p, vec2(width, height));\n        //c = onion(addc, 0.02);\n        c = min(c, onion(addc, 0.52));\n        c = max(-arena(p + vec3(0, -height, 0), width, height), c);\n\n        c = max(c, -sdBox(p + vec3(0, -2.1, -6), vec3(11, 2, 6)));\n\n        //c = max(c, pos.y+.02*i);\n    }\n\n    return c;\n}\nfloat smin(float a, float b, float k)\n{\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h*h*k*(1.0 / 6.0);\n}\nfloat cabeza(vec3 p)\n{\n    float d = 1e10;\n    float r = .2;\n    vec3 q = p;\n    //q.xz = opRepLim(p.xz - vec2(0, 0), 3, vec2(0, -3), vec2(0, 1));\n\n    q.xy *= rot(.12);\n    q.y += .3;\n    d = min(d, length(q.xz) - r);//cilindro\n    d = max(d, q.y - .0);//cortar altura del cilindro\n    d = max(d, -q.y - .5);//cortar base del cilindro*/\n    q.xy *= rot(.54324);\n    d = smin(d, sdBox(q - vec3(.325, .1, 0), vec3(.2, .2, .2)), .6);\n    q = p;\n    //q.xz = opRepLim(p.xz - vec2(0, 0), 3, vec2(0, -3), vec2(0, 1));\n\n    d = smin(d, length(q) - .5, .515);\n\n    return d;\n}\nvec3 RotateY(vec3 v, float degree)\n{\n    float rad = 0.0174532925*degree;\n    float cosY = cos(rad);\n    float sinY = sin(rad);\n    return vec3(cosY*v.x - sinY * v.z, v.y, sinY*v.x + cosY * v.z);\n}\n\nvec3 map(vec3 p)\n{\n    float mid = 0.;\n\n    vec3 q = p;\n    vec3 pos = p;\n\n    q = opRepLim(p, 5.0, vec3(1, 0, 1));\n    q.x = abs(p.x);\n    float d0 = column(q - vec3(2, 0, 0));\n    float box = sdBox(p + vec3(0, 0, 0), vec3(3, 1, 10));\n    box = abs(box) - .1;\n\n    float d = box;\n\n\n    vec3 quad = sdgBox(p.xy - vec2(-.25, .1), vec2(4, .5));\n    quad = abs(quad) - .0125;\n\n    d = max(d, d - quad.x);\n\n    q.y += .5;\n    float sph = length(q) - .5;\n    float cyl = sdBox(q, vec3(.35));//length(q.xz) - .4;//cilindro\n    //cyl=max(-box,cyl);\n    sph = max(-sph, cyl);\n\n    q.y -= .5;\n    q *= 1.021;\n    float d1 = column(q - vec3(2, 0, 0));\n    float box2 = sdBox(p + vec3(0, -0, 0), vec3(3, 1, 10));\n    box2 = abs(box2) - .11;\n\n    float box3 = sdBox(p + vec3(0, -.1, -9.875), vec3(3, .5, .010));\n\n    float bobb = sdBoundingBox(p, vec3(.5), .035);\n    float bobc = sdBox(p+vec3(0,-.0,0), vec3(.45));\n\n\n    float c = estadio(p);\n    float c1 = sdCylinder(p, vec2(10.));\n    c1 = abs(c1) - .1;\n    float roof = arena(p + vec3(0, -10, 0), 10., 1.);\n    float c2 = arena(p + vec3(0, -0, 0), 1., .6);\n    float head = cabeza(p+vec3(0,1,0));\n    for (int i = 0; i < 9; i++)\n    {\n        q = p/.5;\n        float headAdd = cabeza(RotateY(q, -22.5 * float(i)) + vec3(5, -2, float(i)*pi));\n        head = smin(head, headAdd, .1);\n    }\n    //q= RotateY(q, -22.5*T);\n    float stnd = sdBoundingBox(p + vec3(0, -.75, 0), vec3(.5), .035);\n\n\n    d = 1e10;\n\n\n    //if(d > sph){d = sph; mid = 2.;}\n    //if (d > d1) { d = d1; mid = 8.; }\n    //if (d > box2) { d = box2; mid = 9.; }\n    //if (d > box3) { d = box3; mid = 6.; }\n    //if (d > bobb) { d = bobb; mid = 8.; }\n    //if (d > bobc) { d = bobc; mid = 9.; }\n    if (d > c) { d = c; mid = 3.; }\n    if (d > c1) { d = c1; mid = 6.; }\n    if (d > c2) { d = c2; mid = 2.; }\n    if (d > roof) { d = roof; mid = 9.; }\n    //if (d > stnd) { d = stnd; mid = 3.; }\n    //if (d > head) { d = head; mid = 3.; }\n\n\n    return vec3(d, mid, 0.);\n}\n\nvec3 get_normal(vec3 p) {\n    const vec2 e = vec2(0.002, 0);\n    return normalize(vec3(map(p + e.xyy).x-map(p - e.xyy).x, \n                          map(p + e.yxy).x-map(p - e.yxy).x,    \n                          map(p + e.yyx).x-map(p - e.yyx).x));\n}\n\nvec3 intersect(vec3 ro, vec3 rd)\n{\n    vec3 res;\n    float t = 0.01;\n    for(int i = 0; i < 124; ++i)\n    {\n        vec3 p = ro + rd * t;\n        res = map(p);\n        if(res.x < 0.005 * t || res.x > 20.)\n            break;\n        t += res.x;\n    }\n    \n    if(res.x > 20.) t = -1.;\n    return vec3(t, res.y, res.z);\n}\n\nvec3 remap(vec3 p)\n{\n    p.xy = (p.xy + vec2(0.7, 0.4))*vec2(1., iResolution.x / iResolution.y)*0.7;\n    return p;\n}\nvec3 remap2(vec3 p)\n{\n    p.xy *= .5 + .5;\n    return p;\n}vec3 remap3(vec3 p)\n{\n    p = remap2(p)/10.;\n\n    return p;\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    //6 faces texturing\n    p = remap3(p);\n    vec4 colXZ = projector(p.xz) * 5. * circ(p.xz);//texture(_Tex6, p.xz*.5 + .5)*5;\n    vec4 colYZ = projector(p.yz) * 5. * lines(p.yz) * 5.;//texture(sam, p.yz*.5 + .5)*5;\n\n    vec4 colXY = texture(iChannel2, p.xy*.5 + .5)*5.; //\n\n    n = abs(n);\n\n\n    n *= pow(n, vec3(2));\n    n /= n.x + n.y + n.z;\n\n    return colYZ * n.x + colXZ * n.y + colXY * n.z;\n    //return p1 * abs(n.z) + p2 * abs(n.y) + p3 * abs(n.x);\n}\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel0, 0.25*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r = 0.0, w = 1.0, d;\n    for(float i=1.; i<5.0+1.1; i++)\n    {\n        d = i/5.0;\n        r += w*(d - map(p + n*d).x);\n        w *= 0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\nfloat direct_light(vec3 p, vec3 lpos, vec3 n, float radius)\n{\n    vec3 ldir = (lpos - p);\n    float r = length(ldir);\n    ldir /= r;\n    float res = 1.;\n    res *= max(0., dot(ldir,  n))/r;\n    return (3.4-p.y)/3.4*res * (1. - smoothstep(0., radius, r));\n}\n\n\nfloat refl;\n\nvec3 lighting(vec3 ro, vec3 rd, vec3 p, vec3 n, float mid, float dist)\n\t\t\t{\n    vec3 l0_pos = vec3(0., 3, 0);//0., 2.4, floor((p.z+5.)/10.)*10.);\n    vec3 l0_dir = normalize(l0_pos - p);\n    vec3 l0_col = vec3(1.);\n\n    vec3 mc = vec3(1., 1.02, 0.92);\n\n    refl = 0.;\n\n\n    if (mid > 8.)\n    {\n        mc = texcube(iChannel0, p.xyz*2., n).xyz;\n    }\n    else if (mid > 7.)\n    {\n        mc = vec3(.996, .945, .882)*.2;\n    }\n    else if (mid > 6.)\n    {\n        mc = vec3(1., 1., 1.1)*1.1;\n        mc.yz -= pow(texcube(iChannel3, p.yxz*.8, n).x, 3.5)*3.5;\n        mc = max(vec3(0.), mc);\n    }\n    else if (mid > 5.)\n    {\n        p += 10.;//\n        p.x *= .5;\n        p.y -= 10.;\n\n        p *= .1;\n\n        mc = texture(iChannel0, p.xy).xyz*2.;\n    }\n    else if (mid > 4.)\n    {\n\n        mc = vec3(0.1);\n    }\n    else if (mid > 3.)\n    {\n        mc = vec3(0.9, 0.0, 0.);\n        if (abs(p.y + 0.4) < 0.1)\n            mc = vec3(1.);\n    }\n    else if (mid > 2.)\n    {\n        mc = texture(iChannel1, p.xz*.1).xyz * 0.5;\n        refl = 1.;\n    }\n    else if (mid > 1.)\n    {\n        mc = vec3(20.0);\n    }\n    else if (mid > 0.)\n    {\n        mc = vec3(0.3, 0.9, 1.) * 0.4;\n\n    }\n    /*else\n    {\n        if(p.y<2.9)\n        {\n            n=bump_mapping(p, n, 0.2/(1.+dist*0.4));\n        }\n\n        if(p.y>0.5 && (abs(abs(p.y)-2.2)<0.67))\n            mc=vec3(0.3, 0.9, 1.) * 0.5;\n\n    }\n\n    if(p.y < 0.5 && abs(p.x)>2.2 && (abs(abs(p.y)-3.)<0.18))\n    {\n        mc=vec3(0.3, 0.9, 1.) * 0.2;\n        refl = 0.8;\n    }\n\n    // bloody\n    {\n        vec3 q = p;\n        if(q.x<0.&&q.y>-2.9)\n           q.z += 1.;\n\n        mc.yz -= pow(texcube(iChannel3, q.xyz*.08, n).x,3.5)*3.5;\n        mc = max(vec3(0.),mc);\n\n    }*/\n\n\n    float occ = get_ao(p, n);\n    float dif = 8.*direct_light(p, l0_pos, n, 8.3);\n    float bac = max(0., dot(-l0_dir, n));\n    float bce = clamp(n.y * 0.8 + 0.2, 0.0, 1.0);\n    float spe = max(0.0, pow(clamp(dot(-rd, reflect(-l0_dir, n)), 0.0, 1.0), 20.0));\n\n    float env = 1.;\n\n    vec3 lin = vec3(0.);\n\n    lin += 4. * dif * occ;\n    lin += 0.5 * bac * (1.) * occ;\n    lin += 1.0 * bce * (1.) * occ;\n    lin += 1.0 * env * occ;\n    lin += 2.0* spe * (1.);\n    lin = lin * 0.2 * mc * (.5 + .5*occ);\n    return lin;\n}\n\n\nvec3 calc_reflection(vec3 ro, vec3 prev_rd, vec3 n, vec2 screen)\n{         \n    vec3 rd = reflect(prev_rd, n);\n    ro += 0.1 * n;\n\n    \n    vec3 res;\n    float t = 0.01;\n    for(int i = 0; i < 32; ++i)\n    {\n        vec3 p = ro + rd * t;\n        res = map(p);\n        if(res.x < 0.005 * t || res.x > 20.)\n            break;\n        t += res.x;\n    }\n    \n    if(res.x > 20.) t = -1.;\n    res = vec3(t, res.y, res.z);\n    \n    vec3 col = vec3(0.);\n    if(res.x > -.5)\n    {\n        vec3 pos = ro + res.x * rd;\n        n = get_normal(pos);\n        col = lighting(ro, rd, pos, n, res.y, res.x);\n    }\n    return col;\n}\n    \nvoid camera(inout vec3 ro, inout vec3 rd, in vec2 p)\n{\n    float v = 2.;\n    float fov = 1.3;\n    \n    vec3 look_at;\n    float yoffset=sin(iTime*2.)*0.02;\n    \n    if(iTime < 7.)\n    {\n   \t\tlook_at = vec3(0., 0., v);\n    \tro = look_at + vec3(0., -1.3, -23.+iTime*0.1);     \n    }\n    else if(iTime < 15.)\n    {\n        look_at = vec3(0., 0., v);\n    \tro = look_at + vec3(0., -1.3, -13.+iTime*0.1);\n    }\n    else\n    {\n        look_at = vec3(0., 0., v);\n    \tro = look_at + vec3(0., -1.3, -23.+iTime*0.1);     \n        /*look_at = vec3(5., 0., v);\n\n        ro = look_at + vec3(-6., -1.3+yoffset, -12.);*/\n\n    }\n      \n    vec3 f = normalize(look_at - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n    \n    rd = normalize(p.x * r + p.y * u + fov * f);\n}\n\t\t\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 q = fragCoord / iResolution.xy;\n    vec2 p = 2. * q - 1.;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 ro, rd;\n\tcamera(ro, rd, p); \n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    ro = vec3(0, 3, -3);\n       \n    ro.yz *= rot(-m.y*3.14+1.);\n    ro.xz *= rot(-m.x*6.2831);\n    vec3 res = intersect(ro, rd);\n    \n    vec3 col = vec3(0.);\n    \n    if(res.x > -0.5)\n    {\n        vec3 pos = ro + res.x * rd;\n        vec3 n = get_normal(pos);\n\n        col = texture(iChannel2, vec2(0.22, 0.3) * (pos.zy + vec2(18.25, -5.6))).xyz;//col = lighting(ro, rd, pos, n, res.y, res.x);\n        if(refl > 0.)\n        {\n            float f = .04 + (1.-.04)*pow(1.-max(dot(n,-rd),0.),5.);\n            col += f*refl*calc_reflection(pos, rd, n, fragCoord);\n            //col += 0.2*refl*calc_reflection(pos, rd, n, fragCoord);\n             // bloody\n    \t\t{ \n        \t\tcol.yz -= pow(texcube(iChannel3, pos.xyz*.08, n).x,4.5)*4.5;\n        \t\tcol = max(vec3(0.),col);\n        \n    \t\t}\n        }\n        col=mix(col, 0.15*vec3(0.4,0.75,1.0), 1.0-exp(-0.0015*res.x*res.x) );\n\n    }\n    \n    fragColor.xyz = col;\n    fragColor.xyz = mix(fragColor.xyz, vec3(0.), smoothstep(1.,0., iTime));\n    /*if(iTime > 6.)\n    {\n        //fragColor.xyz = mix(fragColor.xyz, vec3(0.), smoothstep(0.,1., iTime-6.));\n        fragColor.xyz = mix(fragColor.xyz, vec3(0.), smoothstep(1.,0., iTime-7.));\n\n    }\n    if(iTime > 14.)\n    {\n        fragColor.xyz = mix(fragColor.xyz, vec3(0.), smoothstep(1.,0., iTime-15.));\n\n    }*/\n\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    },
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}