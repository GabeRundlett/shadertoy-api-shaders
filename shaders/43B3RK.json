{
    "Shader": {
        "info": {
            "date": "1708615169",
            "description": "Twisty FBM marble noise inspired by the background in the game Balatro.",
            "flags": 0,
            "hasliked": 0,
            "id": "43B3RK",
            "likes": 16,
            "name": "Spinnnnny",
            "published": 3,
            "tags": [
                "spin"
            ],
            "usePreview": 0,
            "username": "kaliuresis",
            "viewed": 547
        },
        "renderpass": [
            {
                "code": "\n#define halfsqrt3 0.86602540\n#define invsqrt3 0.57735026\n#define tau 6.28318530\n#define pi 3.14159265358979323846264338327950\n\nfloat hash1D(vec2 x)\n{\n    // hash by Inigo Quilez, Integer Hash - III, 2017\n    uvec2 q = uvec2(x * 65536.0);\n    q = 1103515245u * ((q >> 1u) ^ q.yx);\n    uint n = 1103515245u * (q.x ^ (q.y >> 3u));\n    return float(n) * (1.0 / float(0xffffffffu));\n}\n\nvec2 hash2D(vec2 x)\n{\n    // based on: Inigo Quilez, Integer Hash - III, 2017\n    uvec4 q = uvec2(x * 65536.0).xyyx + uvec2(0u, 3115245u).xxyy;\n    q = 1103515245u * ((q >> 1u) ^ q.yxwz);\n    uvec2 n = 1103515245u * (q.xz ^ (q.yw >> 3u));\n    return vec2(n) * (1.0 / float(0xffffffffu));\n}\n\nfloat hash(vec2 x, float time)\n{\n    return 0.5+0.5*sin(tau*hash1D(x)+time);\n}\n\n//value noise on a triangular lattice\nfloat tri_noise(vec2 p, float time)\n{\n    vec2 q = vec2(p.x-p.y*invsqrt3, p.y*2.0*invsqrt3);\n    vec2 iq = floor(q);\n    vec2 fq = fract(q);\n    float v = 0.0;\n    \n    float h = step(1.0, fq.x+fq.y); //which half of the unit cell does this triangle lie in\n    vec2 c = iq+h;\n    vec2 r = p-vec2(c.x+0.5*c.y, halfsqrt3*c.y);\n    float s = 1.0-2.0*h;\n    r *= s;\n    \n    //compute barycentric coordinates\n    vec3 lambda = vec3(1.0-r.x-invsqrt3*r.y, r.x-invsqrt3*r.y, 2.0*invsqrt3*r.y);\n    //quintic////////////////////\n    vec3 lambda2 = lambda*lambda;\n    vec3 a = 15.0*lambda2*lambda2.zxy*lambda.yzx;\n    \n    //weights set to be quintic smoothstep along edges, with extra terms to set gradients in the normal direction to 0\n    //these magically add up to 1 without correction\n    vec3 w = lambda*lambda2*(10.0-15.0*lambda+6.0*lambda2)+a+a.yzx;\n        \n    v += w.x*hash(abs(c), time);\n    v += w.y*hash(abs(iq+vec2(1.0-h,h)), time);\n    v += w.z*hash(abs(iq+vec2(h,1.0-h)), time);\n    \n    return v;\n}\n\nfloat fbm(vec2 p, int octaves, float decay, float time)\n{\n    vec2 fwp = fwidth(p);\n    float w = dot(step(fwp.xy, fwp.yx), fwp);\n    vec2 v = vec2(0.0);\n    float weight = 1.0;\n    for(int i = 0; i < octaves; i++)\n    {\n        //time = mod(time, tau);\n        v += weight*vec2(tri_noise(p, time)*smoothstep(1.0,0.5,w), 1.0);\n        p *= 2.0*mat2(4.0/5.0, -3.0/5.0, 3.0/5.0, 4.0/5.0);\n        w *= 2.0;\n        weight *= decay;        \n        //time += 0.5*iTime;\n        time *= 1.6;\n    }\n    return v.x/v.y;\n}\n\nfloat fcos(float x)\n{\n    float w = fwidth(x);\n    return cos(x)*sin(0.5*w)/(0.5*w);\n    //return cos(x)*smoothstep(2.0*pi, 0.0, w);\n}\n\nfloat get_val(vec2 p)\n{\n    float l = length(p);\n    float wavf = 0.02;\n    float w = fbm(5.0*p+vec2(7.0), 3, 0.6, 0.01*iTime);\n    \n    float angle = 0.12*iTime-1.0/wavf*0.005*fcos(100.0*l+wavf*iTime)-2.5*log(l+0.01)-0.5*w;\n    vec2 cs = vec2(cos(angle), sin(angle));\n    p = vec2(p.x*cs.x-p.y*cs.y, p.x*cs.y+p.y*cs.x);\n    \n    vec2 up = 5.0*p+vec2(7.0);\n    float u = fbm(up, 6, 0.6, 0.01*iTime)-0.5;\n    u = fcos(10.0*u);\n    vec2 vp = 2.0*u+vec2(1.0);\n    float v = fbm(vp, 3, 0.3, 10.0+0.1*iTime);\n    \n    //v = cos(10.0*v);\n    v += 20.0*l*smoothstep(0.0, 0.02, l);\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec2 p = 0.1*uv;\n    float l = length(p);\n    float v = get_val(p);\n    \n    fragColor = mix(vec4(0.3,0.55,1.0,1.0), \n                    vec4(0.8,0.22,0.3,1.0),\n                    smoothstep(1.0, 1.3, v));\n    \n    //vec3 grad = normalize(vec3(2.0*du*(vxyz.y+vxyz.z)+2.0*normalize(uv)*dFdx(uv.x), dFdx(uv.x)));\n    vec2 e = vec2(2.0*dFdx(p.x),0.0);\n    vec3 grad = normalize(0.5*vec3((get_val(p+e.xy)-get_val(p-e.xy)), 0.5*(get_val(p+e.yx)-get_val(p-e.yx)), 10.0*e.x));\n    //grad = normalize(vec3(dFdx(v), dFdy(v), dFdx(uv.x)));\n    fragColor.rgb += vec3(0.5)*pow(clamp(dot(grad, normalize(vec3(1.0, 1.0, 1.0))), 0.0, 1.0), 10.0);\n    fragColor.rgb += vec3(0.25,0.0,0.0)*pow(clamp(dot(grad, normalize(vec3(-1.0, 1.0, 1.0))), 0.0, 1.0), 10.0);\n    fragColor.rgb *= smoothstep(-1.0,0.0, 1.0-v+13.0*l-0.7);\n    fragColor.rgb *= smoothstep(-0.1,0.4, abs(v-1.0));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}