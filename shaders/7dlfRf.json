{
    "Shader": {
        "info": {
            "date": "1645171570",
            "description": "Complex plot of the Jacobi theta functions.\n[url=https://mathworld.wolfram.com/JacobiThetaFunctions.html]https://mathworld.wolfram.com/JacobiThetaFunctions.html[/url]\nDrag with the mouse to change the nome (q).",
            "flags": 0,
            "hasliked": 0,
            "id": "7dlfRf",
            "likes": 16,
            "name": "Jacobi Theta Functions",
            "published": 3,
            "tags": [
                "complex",
                "jacobi",
                "theta",
                "thetafunction"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 248
        },
        "renderpass": [
            {
                "code": "/*\nOddly enough, I found out about the Jacobi theta functions\nwhen I was trying to find the \"exact\" value of the infinite\ndecimal 0.1010010001000010000010000001...\n\nBy expanding the decimal into an infinite sum of powers of ten\n(specifically, triangular number powers because of the constant\nincrease in the gaps between ones) and manipulating it a bit, it\ncan be expressed in terms of the second Jacobi theta function:\n10^(1/8) * ϑ2(0, 1/10^(1/2)) / 2 - 1\n*/\n\n#define k 24.0\n\n// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 uv, in vec2 pos, in vec2 size, in int char) {\n    uv = (uv - pos) / size + 0.5;\n    vec2 charUv = uv / 16.0;\n    vec2 dfdx = dFdx(charUv);\n    vec2 dfdy = dFdy(charUv);\n    if (all(lessThan(abs(uv - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel0, charUv + fract(vec2(char, 15 - char / 16) / 16.0), dfdx, dfdy).r;\n        color = mix(color, charColor, val);\n    }\n}\n\n// Jacobi theta function 1, 2, 3, and 4\nvec2 theta1(in vec2 z, in vec2 q) {\n    vec2 w = vec2(0.0);\n    float s = 1.0;\n    for (float n=0.0; n <= k; n++) {\n        w += s * cmul(cpow(q, sqr(n + 0.5)), csin((2.0 * n + 1.0) * z));\n        s = -s;\n    }\n\n    return 2.0 * w;\n}\n\nvec2 theta2(in vec2 z, in vec2 q) {\n    vec2 w = vec2(0.0);\n    for (float n=0.0; n <= k; n++) {\n        w += cmul(cpow(q, sqr(n + 0.5)), ccos((2.0 * n + 1.0) * z));\n    }\n\n    return 2.0 * w;\n}\n\nvec2 theta3(in vec2 z, in vec2 q) {\n    vec2 w = vec2(0.0);\n    for (float n=1.0; n <= k; n++) {\n        w += cmul(cpow(q, n * n), ccos(2.0 * n * z));\n    }\n\n    return 2.0 * w + 1.0;\n}\n\nvec2 theta4(in vec2 z, in vec2 q) {\n    vec2 w = vec2(0.0);\n    float s = 1.0;\n    for (float n=1.0; n <= k; n++) {\n        w += s * cmul(cpow(q, n * n), ccos(2.0 * n * z));\n        s = -s;\n    }\n\n    return 2.0 * w + 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    vec2 mouse = 2.0 * iMouse.xy / iResolution.xy - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(0.62, 0.74);\n\n    vec2 q = mouse;\n    vec2 w = vec2(0.0);\n\n    // ϑ1(z, q) in lower left quadrant\n    if (uv.x < 0.0 && uv.y < 0.0) {\n        vec2 z = 2.0 * uv + 1.0;\n        z.x *= aspect;\n        w = theta1(z, q);\n    }\n\n    // ϑ2(z, q) in lower right quadrant\n    if (uv.x > 0.0 && uv.y < 0.0) {\n        vec2 z = 2.0 * uv + vec2(-1.0, 1.0);\n        z.x *= aspect;\n        w = theta2(z, q);\n    }\n\n    // ϑ3(z, q) in upper right quadrant\n    if (uv.x > 0.0 && uv.y > 0.0) {\n        vec2 z = 2.0 * uv - 1.0;\n        z.x *= aspect;\n        w = theta3(z, q);\n    }\n\n    // ϑ4(z, q) in upper left quadrant\n    if (uv.x < 0.0 && uv.y > 0.0) {\n        vec2 z = 2.0 * uv + vec2(1.0, -1.0);\n        z.x *= aspect;\n        w = theta4(z, q);\n    }\n\n    // Domain coloring\n    color = hue2rgb(carg(w) / tau + 0.5);\n\n    // Dividers\n    if (abs(fragCoord.x - 0.5 * iResolution.x) < 2.0) color = vec3(0.0);\n    if (abs(fragCoord.y - 0.5 * iResolution.y) < 2.0) color = vec3(0.0);\n\n    // Label quadrants\n    uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 corner = vec2(0.5 * iResolution.x / iResolution.y, 0.5);\n\n    // θ1\n    drawChar(color, vec3(0.0), uv, -corner + 0.1, vec2(0.1), 133);\n    drawChar(color, vec3(0.0), uv, -corner + vec2(0.15, 0.1), vec2(0.1), 49);\n\n    // θ2\n    drawChar(color, vec3(0.0), uv, vec2(0.0, -corner.y) + 0.1, vec2(0.1), 133);\n    drawChar(color, vec3(0.0), uv, vec2(0.0, -corner.y) + vec2(0.15, 0.1), vec2(0.1), 50);\n\n    // θ3\n    drawChar(color, vec3(0.0), uv, vec2(0.1), vec2(0.1), 133);\n    drawChar(color, vec3(0.0), uv, vec2(0.15, 0.1), vec2(0.1), 51);\n\n    // θ4\n    drawChar(color, vec3(0.0), uv, vec2(-corner.x, 0.0) + 0.1, vec2(0.1), 133);\n    drawChar(color, vec3(0.0), uv, vec2(-corner.x, 0.0) + vec2(0.15, 0.1), vec2(0.1), 52);\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float sqr(in float x) { return x * x; }\n\n// Constants\n#define pi 3.1415926536\n#define rho 1.5707963268\n#define tau 6.2831853072\n\n// Hue to RGB conversion (https://www.desmos.com/calculator/amac5m7utl)\nvec3 hue2rgb(in float hue) {\n    //return clamp(abs(6.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue - 2.0 / 3.0)) - 3.0) - 1.0, 0.0, 1.0);\n    return smoothstep(0.0, 1.0, clamp(abs(6.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue - 2.0 / 3.0)) - 3.0) - 1.0, 0.0, 1.0));\n}\n\n// ------------------------ Complex math (minified) ------------------------\n\n// Miscellaneous\nfloat carg(in vec2 z) { return atan(z.y, z.x); }\n\n// Elementary operations (+, -, *, /)\nvec2 cmul(in vec2 z, in vec2 w) { return mat2(z, -z.y, z.x) * w; }\n\n// Powers\nvec2 cpow(in vec2 z, in float w) {\n    float a = carg(z) * w;\n    return vec2(cos(a), sin(a)) * pow(dot(z, z), 0.5 * w);\n}\n\n// Hyperbolic functions\nvec2 csinh(in vec2 z) { return vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y)); }\nvec2 ccosh(in vec2 z) { return vec2(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y)); }\n\n// Trigonometric functions\nvec2 csin(in vec2 z) { return csinh(z.yx).yx; }\nvec2 ccos(in vec2 z) { return ccosh(vec2(z.y, -z.x)); }",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}