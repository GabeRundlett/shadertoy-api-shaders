{
    "Shader": {
        "info": {
            "date": "1642805256",
            "description": "I have no clue if this is actually correct... I just used the \"Schrödinger Equation\" section on the \"Hydrogen atom\" Wikipedia article (aaaaand ~~stole~~ made use of Inigo Quilez's Spherical Harmonics shader...)",
            "flags": 0,
            "hasliked": 0,
            "id": "fsfyWf",
            "likes": 25,
            "name": "Hydrogen Orbitals (scuffed)",
            "published": 3,
            "tags": [
                "wave",
                "function",
                "quantum",
                "wavefunction",
                "schrodinger",
                "ign"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 684
        },
        "renderpass": [
            {
                "code": "// ####### Hydrogen Orbitals #######\n// Made by Jacob Bingham (Zi7ar21) on January 21st, 2022\n\n// Last Updated on January 22nd, 2022 at 03:05 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, you can find the original and possibly updated version at:\n// https://www.shadertoy.com/view/fsfyWf\n\n// based on https://en.wikipedia.org/wiki/Hydrogen_atom#Schr%C3%B6dinger_equation\n\n/*\nI have no clue if this is actually correct...\nI just used the \"Schrodinger Equation\" section on the \"Hydrogen atom\" Wikipedia\narticle (aaaaand ~~stole~~ made use of Inigo Quilez's Spherical Harmonics shader...)\n*/\n\n/*\n## Features\n\n- Arbitrary (n, l, m) ( scroll down to Parameters to adjust, the default is (3, 2, 0) )\n- Volumetrics\n  - Ray-Marching\n  - Scattering\n  - Dithering with Interleaved Gradient Noise\n\n## Limitations/TODO\n\n- Generalized Laguerre Polynomial not taken into account\n  - I have no idea what this is and how to use it, it seems to not be\n    neccesary and so it's currently ommited\n- Spherical Harmonics Problems\n  - This only supports Real Spherical Harmonics\n  - Pre-solved Spherical Harmonics only up to l = 3\n    - Solving arbitrary spherical harmonics for l and m would be cool...\n      of course, it probably wouldn't perform very great and so it would\n      only be used for l > 3\n*/\n\n/*\n# Zi7ar21's Epic License\n\nThis applies to...\n\n- Code I wrote\n  - You must respect the individual licenses of any snippets in the source that aren't mine\n\nYou are free to...\n\n- Use this code however you want (as long as it complies with this license)\n  - e.g. personal and commercial projects\n  - Especially open-source projects\n\nAs long as...\n\n- You use it ethically\n  - e.g. no using it for NFT's, which are unsustainable and stupid\n- You keep comments in the source that credit and link to snippets of code that aren't mine\n  - e.g. Comments such as \"PCG Random: https://www.pcg-random.org/\"\n  - Of course, you must also respect whatever licenses they use\n\nRemember, we are programmers, not lawyers! :)\n*/\n\n// Check out some of my friends!\n// Dumb_Psycho\n// https://www.shadertoy.com/user/Dumb_Psycho\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// peabrainiac\n// https://www.shadertoy.com/user/peabrainiac\n// skythedragon\n// https://www.shadertoy.com/user/skythedragon\n\n// We have a Discord Server focused on STEM and Memes, DM me (@Zi7ar21#2168) if you're interested.\n\n// ##### Preprocessor #####\n\n/*\n#pragma debug(on)\n#pragma optimize(off)\n*/\n\n/*\n#pragma debug(off)\n#pragma optimize(on)\n*/\n\n// ##### Parameters #####\n\n// n = principal quantum number\n// l = azimuthal quantum number\n// m = magnetic quantum number\n#define n 3\n#define l 2\n#define m 0\n\n#define EXPOSURE 1.0\n\n// uncomment for orthographic camera\n//#define ORTHO\n\n#define FOV 1.5\n\n#define STEP_SIZE 4.0\n\n#define STEP_SIZE_SHADOW 0.4\n\n#define CUTOFF 0.008\n#define DENSITY 16.0\n\n#define POSITIVE_COL vec3(0.250, 1.000, 0.500)\n#define NEGATIVE_COL vec3(1.000, 0.500, 0.250)\n\n// ##### Configuration Validation #####\n\n// ### make sure n is valid ###\n\n#if n < 1\n#error n must be greater than 0\n#endif\n\n// ### make sure l is valid ###\n\n#if l < 0\n#error l must be greater than or equal to 0\n#endif\n\n#if l >= n\n#error l must be less than n\n#endif\n\n// ### make sure m is valid ###\n\n#if m > l || -m > l\n#error m must be less than or equal to abs(l)\n#endif\n\n// ##### Constants #####\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\nconst float pi     = 3.141592653589793; // Pi\nconst float two_pi = 6.283185307179586; // 2 * Pi\nconst float inv_pi = 0.318309886183790; // 1 / Pi\n\n// Reduced Bohr Radius\n// 5.2946541 * 10 ^ -11 meters\n// 0.52946541 angstrom\n// https://en.wikipedia.org/wiki/Bohr_radius#Hydrogen_atom_and_similar_systems\nconst float a0 = 0.52946541;\n\n// ##### Maths #####\n\n//#define dot_product(x) dot(x, x)\n\nfloat dot_product(vec2 x) { return dot(x, x); }\nfloat dot_product(vec3 x) { return dot(x, x); }\nfloat dot_product(vec4 x) { return dot(x, x); }\n\nvec2 rotate(vec2 vector, float theta)\n{\n    float s = sin(theta), c = cos(theta);\n    return vec2(vector.x * c - vector.y * s, vector.x * s + vector.y * c);\n}\n\nint factorial(int x)\n{\n    int f = 1;\n\n    for(int i = 1; i <= x; i++)\n    {\n        f = f * i;\n    }\n\n    return f;\n}\n\n// (x, y, z) -> (r, theta, phi)\nvec3 cartesian2spherical(vec3 p)\n{\n    return vec3(\n    length(p), // r\n    atan(p.y, p.x), // theta\n    atan(length(p.xy), p.z) // phi\n    );\n}\n\n// (r, theta, phi) -> (x, y, z)\nvec3 spherical2cartesian(vec3 p)\n{\n    float r     = p.x;\n    float theta = p.y;\n    float phi   = p.z;\n\n    return vec3(\n    cos(theta) * sin(phi),\n    sin(theta) * sin(phi),\n    cos(phi)\n    );\n}\n\n/*\n*/\n// modified from https://www.shadertoy.com/view/lsfXWH\n\n// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n// Four bands of Spherical Harmonics functions (or atomic orbitals if you want). For\n// reference and fun.\n\n// Constants, see here: http://en.wikipedia.org/wiki/Table_of_spherical_harmonics\nconst float k01 = 0.2820947918; // sqrt(  1 / PI) / 2\nconst float k02 = 0.4886025119; // sqrt(  3 / PI) / 2\nconst float k03 = 1.0925484306; // sqrt( 15 / PI) / 2\nconst float k04 = 0.3153915652; // sqrt(  5 / PI) / 4\nconst float k05 = 0.5462742153; // sqrt( 15 / PI) / 4\nconst float k06 = 0.5900435860; // sqrt( 70 / PI) / 8\nconst float k07 = 2.8906114210; // sqrt(105 / PI) / 2\nconst float k08 = 0.4570214810; // sqrt( 42 / PI) / 8\nconst float k09 = 0.3731763300; // sqrt(  7 / PI) / 4\nconst float k10 = 1.4453057110; // sqrt(105 / PI) / 4\n\n// Y_l_m(s), where l is the band and m the range in [-l..l] \n//float SH( in int l, in int m, in vec3 s )\nfloat SH( in vec3 s )\n{ \n    vec3 n_ = s.zxy;\n\n    //----------------------------------------------------------\n    if( l==0 )          return  k01;\n    //----------------------------------------------------------\n    if( l==1 && m==-1 ) return -k02 * n_.y;\n    if( l==1 && m== 0 ) return  k02 * n_.z;\n    if( l==1 && m== 1 ) return -k02 * n_.x;\n    //----------------------------------------------------------\n\tif( l==2 && m==-2 ) return  k03 * n_.x * n_.y;\n    if( l==2 && m==-1 ) return -k03 * n_.y * n_.z;\n    if( l==2 && m== 0 ) return  k04 * (3.0 * n_.z * n_.z - 1.0);\n    if( l==2 && m== 1 ) return -k03 * n_.x * n_.z;\n    if( l==2 && m== 2 ) return  k05 * (n_.x * n_.x - n_.y * n_.y);\n    //----------------------------------------------------------\n    if( l==3 && m==-3 ) return -k06 * n_.y * (3.0 * n_.x * n_.x - n_.y * n_.y);\n    if( l==3 && m==-2 ) return  k07 * n_.z * n_.y * n_.x;\n    if( l==3 && m==-1 ) return -k08 * n_.y * (5.0 * n_.z * n_.z - 1.0);\n    if( l==3 && m== 0 ) return  k09 * n_.z * (5.0 * n_.z * n_.z - 3.0);\n    if( l==3 && m== 1 ) return -k08 * n_.x * (5.0 * n_.z * n_.z - 1.0);\n    if( l==3 && m== 2 ) return  k10 * n_.z * (n_.x * n_.x - n_.y * n_.y);\n    if( l==3 && m== 3 ) return -k06 * n_.x * (n_.x * n_.x - 3.0 * n_.y * n_.y);\n    //----------------------------------------------------------\n\n    return 0.0;\n}\n/*\n*/\n\n// Generalized Laguerre Polynomial (not neccesary, I think?)\nfloat L(float rho)\n{\n    return 1.0;\n}\n\n// Spherical Harminic Function\n// Wikipedia: \"Spherical Harmonic Function of Degree l and Order m\"\nfloat Y(float theta, float phi)\n{\n    vec3 p = spherical2cartesian( vec3(1.0, theta, phi) );\n\n    return SH(p);\n}\n\n// Normalized Position Wavefunction\nfloat wavefunction(float r, float theta, float phi)\n{\n    float rho = (2.0 * r) / (float(n) * a0);\n\n    float f0 = 2.0 / (float(n) * a0);\n    float f1 = float( factorial(n - l - 1) ) / float( 2 * n * factorial(n + l) );\n\n    return sqrt(f0 * f0 * f0 * f1) * exp(-rho / 2.0) * pow( rho, float(l) ) * L(rho) * Y(theta, phi);\n}\n\n// ##### Rendering #####\n\nvec3 sky(vec3 dir)\n{\n    return vec3(0);\n    return vec3(1) * 0.8 * smoothstep(0.0, 1.0, dir.y) + 0.2;\n}\n\nfloat sample_volume(in vec3 p, out vec3 col)\n{\n    col = vec3(0.100, 0.250, 1.000);\n\n    if(dot_product(p) > 32.0 * 32.0)\n    {\n        return 0.0;\n    }\n\n    //return 10.0 * smoothstep( 0.0, 1.0, 1.0 - length(p) );\n\n    /*\n    if(abs(p.x) > 1.2 || abs(p.y) > 1.2 || abs(p.z) > 1.2)\n    {\n        return 0.0;\n    }\n    */\n    /*\n    if(dot_product(p) < 0.8 * 0.8)\n    {\n        return 8.0;\n    }\n    if(dot_product(p) > 1.2 * 1.2)\n    {\n        return 0.0;\n    }\n\n    // https://en.wikipedia.org/wiki/Mandelbulb\n\n    vec3 c = p.xzy;\n    vec3 z = c;\n    float power = 8.0;\n\n    for(int i = 0; i < 8; i++)\n    {\n        float r = length(z);\n\n        if(r > 2.0)\n        {\n            return 8.0 * max( max(float(i - 2), 0.0) / 6.0, 0.0 );\n        }\n\n        // convert to polar coordinates\n        float theta = acos(z.z / r );\n        float phi   = atan(z.y, z.x);\n\n        // scale and rotate the point\n        //float zr = pow(r, power);\n        float zr = r * r * r * r  *r * r * r * r;\n        theta *= power;\n        phi   *= power;\n\n        float sin_theta = sin(theta);\n        float cos_theta = cos(theta);\n        float sin_phi = sin(phi);\n        float cos_phi = cos(phi);\n\n        z = ( zr * vec3(sin_theta * cos_phi, sin_phi * sin_theta, cos_theta) ) + c;\n    }\n\n    return 8.0;\n    */\n\n    p = vec3(rotate(p.xy, 1.0 * (0.1 / 3.0) * two_pi * iTime), p.z).xyz;\n    p = vec3(rotate(p.xz, 2.0 * (0.1 / 3.0) * two_pi * iTime), p.y).xzy;\n    p = vec3(rotate(p.yz, 3.0 * (0.1 / 3.0) * two_pi * iTime), p.x).yzx;\n\n    p = cartesian2spherical(p);\n    float r     = p.x;\n    float theta = p.y;\n    float phi   = p.z;\n\n    float w = wavefunction(r, theta, phi);\n\n    if(w > 0.0)\n    {\n        col = POSITIVE_COL;\n    }\n    else\n    {\n        col = NEGATIVE_COL;\n    }\n\n    return DENSITY * max(abs(w) - CUTOFF, 0.0);\n}\n\nvec3 sample_light(vec3 ro, vec3 rd)\n{\n    vec3 a = vec3(1);\n\n    for(int i = 0; i < 10; i++)\n    {\n        float t = STEP_SIZE_SHADOW * float(i);\n\n        vec3 p = ro + rd * t;\n\n        vec3 c;\n        float d = sample_volume(p, c);\n\n        if(d > 0.0)\n        {\n            a *= exp(-STEP_SIZE_SHADOW * c * d);\n        }\n    }\n\n    return a;\n}\n\n// https://blog.demofox.org/2022/01/01/interleaved-gradient-noise-a-different-kind-of-low-discrepancy-sequence/\n// http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\nfloat IGN(vec2 pixel_coord, int frame)\n{\n    frame = frame % 64;\n\n    pixel_coord += 5.588238 * float(frame);\n\n    return fract( 52.9829189 * fract(0.06711056 * pixel_coord.x + 0.00583715 * pixel_coord.y) );\n}\n\n/*\n// ##### Main #####\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec2 uv = 2.0 * (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    vec3 p = 10.0 * vec3( uv, sin(0.125 * two_pi * iTime) );\n\n    float r = length(p);\n    float theta = atan(p.y, p.x);\n    float phi = atan(length(p.xy), p.z);\n\n    fragColor.rgb = vec3( 10.0 * abs( wavefunction(r, theta, phi) ) );\n}\n*/\n\n// ##### Main #####\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec2 uv = 2.0 * (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    #ifdef ORTHO\n    vec3 ro = vec3( FOV * uv ,  16.0);\n    vec3 rd = vec3( 0.0,  0.0,  -1.0);\n    #else\n    //vec3 ro = vec3( 0.0, 0.0, 0.2 * sin( (1.0 / 3.0) * two_pi * iTime ) + 16.0 );\n    vec3 ro = vec3( 0.0, 0.0, 16.0);\n    vec3 rd = normalize( vec3(FOV * uv, -1.0) );\n    #endif\n\n    //float theta = 0.125 * two_pi * iTime;\n\n    //ro = vec3(rotate(ro.xz, theta), ro.y).xzy;\n    //rd = vec3(rotate(rd.xz, theta), rd.y).xzy;\n\n    vec3 att = vec3(1);\n    vec3 col = vec3(0);\n\n    float dither = STEP_SIZE * IGN(floor(fragCoord), iFrame);\n\n    for(int i = 0; i < 40; i++)\n    {\n        float t = ( STEP_SIZE * float(i) ) + dither;\n\n        vec3 p = ro + rd * t;\n\n        #ifndef ORTHO\n        if(dot_product(p) > 16.0 * 16.0)\n        {\n            break;\n        }\n        #else\n        if(dot_product(p) > 32.0 * 32.0)\n        {\n            break;\n        }\n        #endif\n\n        vec3 c;\n        float d = sample_volume(p, c);\n\n        if(d > 0.0)\n        {\n            col += STEP_SIZE * att * d * sample_light( p, normalize( vec3(1, 1, 0) ) );\n\n            //att *= exp(-STEP_SIZE * c * d);\n            att *= exp(-STEP_SIZE * d);\n        }\n    }\n\n    fragColor.rgb = col + att * sky(rd);\n\n    #ifdef EXPOSURE\n    fragColor.rgb = smoothstep( 0.0, 1.0, 1.0 - exp(-max(fragColor.rgb, 0.0) * EXPOSURE) );\n    #endif\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}