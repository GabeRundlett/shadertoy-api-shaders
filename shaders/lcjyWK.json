{
    "Shader": {
        "info": {
            "date": "1723022003",
            "description": "Parametric Medial Axis taken from this paper: https://www.sciencedirect.com/science/article/pii/S0097849324000876",
            "flags": 0,
            "hasliked": 0,
            "id": "lcjyWK",
            "likes": 0,
            "name": "Polygonal Parametric Medial Axis",
            "published": 3,
            "tags": [
                "convex",
                "barycentric",
                "polygon",
                "coordinates",
                "parametric",
                "medialaxis",
                "nonconvex",
                "gbc"
            ],
            "usePreview": 0,
            "username": "Reynolds",
            "viewed": 63
        },
        "renderpass": [
            {
                "code": "#define N 7\n\nfloat cr2(vec2 A, vec2 B) {\n    return A.x*B.y-A.y*B.x;\n}\n\nfloat getAngle(vec2 A, vec2 B) {\n    return atan(cr2(A,B), dot(A,B));\n}\n\nfloat[N] meanvalue(vec2 p, vec2[N] poly) {\n    float[N] weights;\n    vec2 vi, vi_min1, vi_plus1;\n    float sumweights = 0.0;\n    float ang1, ang2;\n    float t1, t2;\n    vec2 vi_p;\n    \n    for(int i = 0; i < N; i++) {\n        vi = poly[i];\n        vi_min1 = poly[(i-1 + N) % N];\n        vi_plus1 = poly[(i+1) % N];\n        vi_p = normalize(vi-p);\n        \n        \n        //ang1 = acos(dot(normalize(vi_min1-p), vi_p));\n        //ang2 = acos(dot(normalize(vi_plus1-p), vi_p));\n        ang1 = getAngle(vi_min1-p, vi_p);\n        ang2 = getAngle(vi_p, vi_plus1-p);\n        \n        \n        t1 = tan(ang1*0.5);\n        t2 = tan(ang2*0.5);\n        weights[i] = (t1 + t2) / distance(vi, p);\n        sumweights += weights[i];\n    }\n    \n    //normalize\n    float recp = 1.0/sumweights;\n    for(int i = 0; i < N; i++) {\n        weights[i] *= recp;\n    }\n    return weights;\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float A = dot(pa,ba)/dot(ba,ba);\n    float h = clamp( A, 0.0, 1.0 );\n\n    return length( pa - ba*h);\n}\n\nfloat sdScene(vec2 p,     vec2[N] poly) {\n    float d = sdSegment(p, poly[0], poly[1]);\n    \n    for(int i = 0; i < N; ++i) {\n       d = min(d, sdSegment(p, poly[i], poly[(i+1) % N])); \n    }\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y - vec2(0.25, 0.0);\n\n    vec3 col = vec3(1.0);\n\n    //create a polygon\n    vec2[N] poly;\n    float R = 0.5;\n    float tpi = 2.0*3.14159;\n    \n    float incr = 1.0/float(N);\n    float phi = 0.0;\n    for(int i = 0; i < N; ++i) {\n        poly[i] = vec2(0.5) + R * vec2(cos(tpi * phi), sin(tpi * phi));\n        \n        phi += incr;\n    }\n\n    for(int i = 0; i < N; ++i) {\n        poly[i] += 0.25*vec2(sin(iTime*float(i + 1)), 0.0);\n    }\n    \n    float[N] weights = meanvalue(uv, poly);\n    \n    //determine parametric edge distance parameters:\n    float[N] hi;\n    for(int i = 0; i < N; ++i) {\n        int m1 = (i-1+N) % N;\n        hi[i] = 1.0 - weights[i] - weights[m1];\n    }\n    \n    \n    float d = sdScene(uv, poly);\n    \n    //change v to [0,..,N-1] to show the other coordinate functions    \n    int v = 0;\n    \n    //render isolines\n    float linewidth = 0.005;\n    float z = 0.001;\n    //simple check to see if we are inside the polygon\n    if(weights[0] > 0.0 && weights[1] > 0.0 && weights[2] > 0.0 && weights[3] > 0.0) {\n        //to change number of isolines    \n        float w = 0.1;\n        for(int i = 0; i < 9; ++i) {\n            float f = weights[v] - (w - linewidth);\n            f /= 2.0 * linewidth;\n            col = mix( vec3(0), col, smoothstep(0., 1.5, abs(f - 0.5)/fwidth(f)));\n            w += 0.1;\n            linewidth += z;\n        }\n    }\n    \n    float D = 10000.0;\n    for(int i = 0; i < N; ++i) {\n        if(hi[i] < D) {\n            D = hi[i];\n            col = vec3(0.5) + 0.5 * vec3(sin(float(i)*1000.0), sin(float(i)*3000.0), sin(float(i)*5000.0));\n        }\n    }\n    \n   \n    //draw polygon through segments\n    linewidth = 0.005;\n    fragColor.rgb  = mix(vec3(0), col, smoothstep(0.0, 1.0, d / linewidth));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}