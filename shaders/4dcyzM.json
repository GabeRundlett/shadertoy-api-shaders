{
    "Shader": {
        "info": {
            "date": "1518126074",
            "description": "Procedural generator of volcanic archipelagos.\nChange seed in code to generate another random terrrain.\nMove camera with mouse.\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4dcyzM",
            "likes": 7,
            "name": "Volcanic archipelagus",
            "published": 3,
            "tags": [
                "distancefields",
                "water",
                "reflections",
                "softshadows",
                "raymarcing",
                "volcano",
                "sunreflection"
            ],
            "usePreview": 1,
            "username": "cyanpencil",
            "viewed": 1268
        },
        "renderpass": [
            {
                "code": "//#version 330 core\n#define PI 3.1415926535897932384626433832795\n#define inf 9e100\n\n/**\n\tGenerates terrain with fbm noise.\n\tVolcano is always centered in the origin.\n\tVolcano elevation is calculated as e^(-sqrt(x^2+y^2)), and summed to fbm.\n\tChangingin the seed generates a new archipelagus.\n\tDrag the mouse to move the camera.\n\tAll the variables declared here at the start are parameters that can be \n\tchanged, I hope they are not that obscure.\n\n\tSpecial thanks to Inigo Quielez, his awesome work is truly inspiring,\n\tand his tutorials are amazing.\n\tThanks also to Frankenburg's water shader, and nimitz's lens flare shader.\n\tFinally, thanks also to my sister who gave some fundamental artistic advice.\n\n\tHere is a short pdf I made to explain a bit better how this was made:\n\thttps://drive.google.com/open?id=1U4zynGm8o4i8VodnaWTOjgoayj9rhega\n\n\tThis is my first shader so please understand if it's not\n\tthat orignal or well done...\n*/\n\n\n\nfloat seed = 104.0;             //input a float < 10000.0 to generate terrain \n\n\n// --------- TERRAIN GENERATION OPTIONS\nint fbm_octaves = 11;            //octaves for the terrain generator. More octaves = more details\nfloat elevate = 2.0;             //height of volcano\nfloat crater_width = 0.05;       //width and depth of the crater\nfloat large = 1.5;               //width of volcano (higher = thinner)\nfloat water_level = 130.0;       //starting height of water. Set to a very low number to remove water\nfloat wavegain = 0.3;            //roughness of the water\n\n\n// ----------- RENDERING OPTIONS -----------\nint AA = 1;                      //antialias\nfloat camera_distance = 250.0;   //distance of camera from origin\nfloat jitter_factor = 2.0;       //jitter when too close to object\nint max_raymarching_steps = 128; //increase if you see artifacts near object edges\nfloat max_distance = 5000.0;     //max rendering distance\nfloat step_size = 0.75;          //decrease if you see artifacts near slopes\n\n\n//toggle between 0 and 1\nint shadows = 1; \nint water_refl = 1; \nint clouds = 0;\nint gamma = 0;\nint lens_flare = 0;\nint hq_water = 1;\nint lava = 0;\t\t\t\t\t //just a red light on the crater \n\nint sha_octaves = 6;             //octaves for shadows\nfloat sha_stepsize = 3.0;        //shadow step size. Decrease if there are artifacts in shadows \nfloat softshadows = 7.0;         //Increase to have harder shadows\n\nfloat fog = 0.3;                 //fog level. Set between 0 and 1\nfloat sun_dispersion = 0.5;\t     //sun dispersion in fog\n\n\n\n\nconst vec3  kSunDir = normalize(vec3(-0.624695,0.168521,-0.624695)); \nvec3 _LightDir = kSunDir*100000.0; \nvec3 _CameraDir = normalize(vec3(7,1.2,5))*5.00;\n\nfloat ka = 0.05;                 //ambient light\nfloat kd = 0.2;\t\t\t         //diffuse light\n\n\n\n\n\n// --  Value noise by Inigo Quielez: https://iquilezles.org/articles/morenoise\nfloat hash2( vec2 p ) {\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    float a = hash2(p+vec2(0,0));\n    float b = hash2(p+vec2(1,0));\n    float c = hash2(p+vec2(0,1));\n    float d = hash2(p+vec2(1,1));\n\n    return -1.0+2.0*( a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y );\n}\n\nvec3 noised2( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float a = hash2(p+vec2(0,0));\n    float b = hash2(p+vec2(1,0));\n    float c = hash2(p+vec2(0,1));\n    float d = hash2(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return vec3( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k4*u.x*u.y), \n                      2.0* du * vec2( k1 + k4*u.y,\n                                      k2 + k4*u.x ) );\n}\n\n\nmat2 m2 = mat2(  0.80,  0.60, -0.60,  0.80 );\nmat2 m2i = mat2( 0.80, -0.60, 0.60,  0.80 );\n\nfloat fbm( in vec2 x, int octaves) {\n    float f = 1.9;\n    float s = 0.50;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i< octaves; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n\treturn a;\n}\n\n//returns fbm with derivatives\nvec3 fbmd( in vec2 x , int octaves) {\n    float f = 1.9;\n    float s = 0.50;\n    float a = 0.0;\n    float b = 0.5;\n    vec2  d = vec2(0.0);\n    mat2  m = mat2(1.0,0.0,0.0,1.0);\n    for( int i=0; i< octaves; i++ )\n    {\n        vec3 n = noised2(x);\n        a += b*n.x;          // accumulate values\t\t\n        d += b*m*n.yz;       // accumulate derivatives\n        b *= s;\n        x = f*m2*x;\n        m = f*m2i*m;\n    }\n\treturn vec3( a, d );\n}\n\n\n// -- Sky adapted from Inigo quielez's shader: https://www.shadertoy.com/view/4ttSWf\nvec3 renderSky( in vec3 ro, in vec3 rd ) {\n    vec3 col = vec3(0);\n\n\n    // clouds\n    if (clouds > 0) {\n        float t = (1000.0-ro.y)/rd.y;\n        if( t>0.0 ) {\n            vec2 uv = (ro+t*rd).xz;\n            float cl = fbm( uv*0.001 + vec2(-100.0, 20.0) , fbm_octaves);\n            float dl = smoothstep(-0.2,0.6,cl);\n            col = mix( col, vec3(1.0), 0.4*dl );\n        }\n    }\n\n    float sundot = clamp(dot(kSunDir,rd), 0.0, 1.0 );\n    col += mix(vec3(1.0,0.1,0.1)*1.1, normalize(vec3(172, 133, 102)), rd.y*rd.y + 0.588*(1.0 - sundot));\n\n    col += normalize(vec3(250,206,150))*pow(sundot,2048.0)*20.0;\n    col += normalize(vec3(250,206,14)) *pow(sundot,64.0);\n    col += normalize(vec3(244,162,5))  *pow(sundot,5.0);\n\n    //horizon\n    col = mix( col, 0.5*normalize(vec3(118,34,8)), pow( 1.0-max(rd.y + 0.1,0.0), 10.0 ) );\n\n    return col;\n}\n\n\n\n//length of a vector with derivatives\nvec3 length_d(vec2 p) {\n    vec3 res = vec3(0);\n    float size = p.x*p.x + p.y*p.y;\n    res.x = pow(size, 0.5);\n    res.y = pow(size, -0.5)*p.x;\n    res.z = pow(size, -0.5)*p.y;\n    return res;\n}\n\n\nfloat length_n(vec2 p, float exponent) {\n    float size = pow(p.x, exponent) + pow(p.y, exponent);\n    return pow(size, 1.0/exponent);\n}\n\nfloat terrainMap(in vec2 p, int octaves) {\n    float sca = 0.0010;\n    float amp = 300.0;\n    p *= sca;\n    float e = fbm(p + vec2(1.0, -2.0)*(1.0 + seed), octaves);\n\n    float length2 = length(p);\n    e += elevate*exp(-large*(max(length2, crater_width))); //volcano\n    if (length2 < crater_width) {\n        e -= 2.0 * (crater_width - length2); //crater\n    }\n\n    e *= amp;\n    return e;\n}\n\n//return terrain map with normal coordinates \nvec4 terrainMapD( in vec2 p ) {\n    float sca = 0.0010;\n    float amp = 300.0;\n    p *= sca;\n    vec3 e = fbmd( p + vec2(1.0,-2.0)*(1.0 + seed) , fbm_octaves);\n\n\n    vec3 length2 = length_d(p);\n    e.x += elevate*exp(-large*(max(length2.x, crater_width))); //volcano\n    if (length2.x < crater_width) {\n        e.x -= 2.0 * (crater_width - length2.x); //crater\n        //crater derivatives\n        e.y -= 2.0 * -length2.y;\n        e.z -= 2.0 * -length2.z;\n    }\n    else {\n        //volcano derivatives\n        e.y += elevate*exp(-large*(max(length2.x, crater_width)))*(-large*length2.y);\n        e.z += elevate*exp(-large*(max(length2.x, crater_width)))*(-large*length2.z);\n    }\n\n    e.x *= amp;\n    e.yz *= amp*sca;\n    return vec4( e.x, normalize( vec3(-e.y,1.0,-e.z) ) );\n}\n\n\n\n// -- Fog function adapted from Inigo's tutorial: https://iquilezles.org/articles/fog\nvec3 applyFog(in vec3 rgb, in float dist, in vec3 ro, in vec3  rayDir, in vec3  sunDir )\n{\n    float fogAmount = 1.0 - exp( -(dist*dist/max_distance)*((fog*fog) / 200.0) );\n    float sunAmount = clamp( dot( rayDir, sunDir ), 0.0, 1.0 );\n    vec3 fogColor  = mix( 0.5*normalize(vec3(118,34,8)), vec3(1.0,0.9,0.1), \n            pow(sunAmount, (0.5/(sun_dispersion)) * 8.0 * ((dist) / 1000.0)) );\n    return mix(rgb, fogColor, fogAmount );\n}\n\n\n// -- Lens Flare adapted from nimitz's shader: https://www.shadertoy.com/view/XtS3DD\nfloat pent(in vec2 p) {\n    vec2 q = abs(p);\n    return max(max(q.x*1.176-p.y*0.385, q.x*0.727+p.y), -p.y*1.237)*1.;\n}\n\nfloat circle(in vec2 p){\n    return length(p);\n}\n\nvec3 flare(vec2 p, vec2 pos) \n{\n\tvec2 q = p-pos;\n    vec2 pds = p*(length(p))*0.75;\n\tfloat a = atan(q.x,q.y);\n    float rz = 0.0;\n\n    vec2 p2 = mix(p,pds,-.5); //Reverse distort\n    rz += max(0.01-pow(circle(p2 - 0.2*pos),1.7),.0)*3.0;\n    rz += max(0.01-pow(pent(p2 + 0.4*pos),2.2),.0)*3.0;\n    rz += max(0.01-pow(pent(-(p2 + 1.*pos)),2.5),.0)*5.0;\n    rz += max(0.01-pow(pent(-(p2 - .5*pos)),2.),.0)*4.0;\n    rz += max(0.01-pow(circle(-(p2 + 1.8*pos)),3.0),.0)*3.0;\n\n    rz *= (1.0 - length(q));\n    rz *= 5.0;\n\n    return vec3(clamp(rz,0.,1.));\n}\n\n\n// -- Water adapted from frankenburg's shader: https://www.shadertoy.com/view/4sXGRM\nfloat large_waveheight = 0.7; \nfloat small_waveheight = 1.0; \nvec3 watercolor  = vec3(0.2, 0.25, 0.3);\nfloat water( vec2 p ) {\n    vec2 shift2 = 0.0003*vec2( iTime*190.0*2.0, -iTime*130.0*2.0 );\n\n    float wave = 0.0;\n    wave += sin(p.x * 0.021  +                     shift2.x)         * 4.5;\n    wave += sin(p.x * 0.0172 +p.y        * 0.010 + shift2.x * 1.121) * 4.0;\n    wave -= sin(p.x * 0.00104+p.y        * 0.005 + shift2.x * 0.121) * 4.0;\n    wave += sin(p.x * 0.02221+p.y        * 0.01233+shift2.x * 3.437) * 5.0;\n    wave += sin(p.x * 0.03112+p.y        * 0.01122+shift2.x * 4.269) * 2.5 ;\n    wave *= large_waveheight;\n    wave -= fbm(p*0.004-shift2*.5 + vec2(1.0, -2.0), fbm_octaves)*small_waveheight*24.;\n\n    return water_level + wave;\n}\n\n\n// Pseudo-random number generator adapted from: lumina.sourceforge.net/Tutorials/Noise.html\nfloat rand(vec2 co){\n    return fract(cos(dot(co,vec2(4.898,7.23))) * 23421.631);\n}\n\n\nvec4 raymarch_terrain(vec3 ro, vec3 rd) {\n    vec4 ret = vec4(0,0,0,0);\n\n    float t = 0.01; // current distance traveled along ray\n    for (int i = 0; i < max_raymarching_steps; ++i) {\n        if (t > max_distance) break;\n        vec3 p = ro + rd * t; //point hit on the surface\n        float terrain = terrainMap(p.xz, fbm_octaves);\n        float d = p.y - terrain;\n\n\n        if (p.y < water_level) {\n            if (hq_water == 0) return vec4(0,0,1,0);\n            t = ((water_level - ro.y) / rd.y); //adjust position to remove water artefacts\n            p = ro + rd * t;\n            vec3 col = vec3(0.0);\n\n            // calculate water-mirror\n            vec2 xdiff = vec2(0.1, 0.0)*wavegain*4.;\n            vec2 ydiff = vec2(0.0, 0.1)*wavegain*4.;\n\n            // get the reflected ray direction\n            vec3 rd_bis = reflect(rd, normalize(vec3(water(p.xz-xdiff) - water(p.xz+xdiff), 1.0, water(p.xz-ydiff) - water(p.xz+ydiff))));\n            float refl = 1.0-clamp(dot(rd_bis,vec3(0.0, 1.0, 0.0)),0.0,1.0);\n\n\n            //reflection\n            vec3 refl_col = renderSky(p, rd_bis);\n            // raymarch to see if the sky is visible\n            if (rd_bis.y > 0.0 && water_refl > 0) {\n                vec3 myro = p;\n                vec3 myrd = rd_bis;\n                float tt = 0.1;\n                vec3 pp = p;\n                for (int j = 0; j < max_raymarching_steps; j++) {\n                    if (tt > max_distance)  break;\n                    pp = myro + myrd * tt; \n                    terrain = terrainMap(pp.xz, sha_octaves);\n                    d = pp.y - terrain;\n                    if (d < 0.001*tt) {\n                        refl_col = normalize(vec3(114, 53, 6))/2.0;\n                        break;\n                    }\n                    tt += sha_stepsize*step_size * d;\n                }\n            }\n\n\n\n            col = refl*0.5*refl_col;\n            col += watercolor;\n\n            col -= vec3(.3,.3,.3);\n\n            terrain = terrainMap(p.xz, fbm_octaves);\n\n            col += vec3(.15,.15,.15)*(clamp(20.0 / (water_level - terrain), 0.0, 1.0));\n            col = applyFog(col, t, ro, rd, kSunDir);\n\n            //fading away in the distance\n            float alpha = pow(t / max_distance, 3.0);\n            if (alpha > 0.2) \n                col = mix(col, renderSky(ro, rd), alpha - 0.2);\n\n\n            return vec4(col, 1);\n\n        }\n\n\n        if (d < 0.002 * t) { \n            vec3 n = terrainMapD(p.xz).yzw;\n            vec3 col = vec3(ka);\n\n            //lights\n            float diffuse_sun = clamp(kd * dot(kSunDir, n), 0.0, 1.0);\n            float indirect_sun = clamp(dot(n, normalize(kSunDir*vec3(-1.0, 0.0, -1.0))), 0.0, 1.0);\n            float diffuse_sky = clamp(0.5 + 0.5*n.y, 0.0, 1.0);\n\n            //shadows\n            float shadow = 1.0;\n            if (diffuse_sun > 0.01 && shadows > 0) {\n                vec3 myro = p + kSunDir*15.0; //Start a bit higher than terrain. Helps when sha_octaves is low (< 5)\n                vec3 myrd = kSunDir;\n                float tt = 0.1;\n                for (int j = 0; j < max_raymarching_steps; j++) {\n                    if (tt > max_distance) break;\n                    p = myro + myrd * tt; \n                    terrain = terrainMap(p.xz, sha_octaves);\n                    d = p.y - terrain;\n                    if (d < 0.001*tt) {\n                        shadow = 0.0;\n                        break;\n                    }\n                    shadow = min(shadow, softshadows*(d/tt));\n                    tt += sha_stepsize*step_size * d;\n                }\n            }\n\n\n\n            col += diffuse_sun * normalize(vec3(250,206,14))* pow(vec3(shadow), vec3(1.0, 1.2, 1.5));\n            col += indirect_sun *  vec3(0.40, 0.28, 0) * 0.14; \n            col += diffuse_sky * vec3(0.596, 0.182, 0.086) * 0.2;\n\n            if (lava > 0) {\n                float lava_height = terrainMap(vec2(0), fbm_octaves) + 50.0;\n                float diffuse_lava = 0.031*clamp(dot(n, normalize(vec3(0.0,lava_height, 0.0))), 0.0, 1.0);\n                col += 100000.0 * 0.013 * vec3(1,.1,.1) / (p.x*p.x + (p.y-lava_height)*(p.y-lava_height) + p.z*p.z);\n            }\n\n            // far away terrain fades away\n            float alpha = pow(t / max_distance, 3.0);\n            if (alpha > 0.2) \n                col = mix(col, renderSky(ro, rd), alpha - 0.2);\n            \n            col = applyFog(col, t, ro, rd, kSunDir);\n\n            return vec4(col, 1);\n        }\n\n        t += d*step_size;\n    }\n\n    vec3 sky = renderSky(ro, rd); \n    return vec4(sky.xyz, 1.0);\n}\n\n//Adapted from: https://github.com/zackpudil/raymarcher/blob/master/src/shaders/scenes/earf_day.frag\nmat3 camera(vec3 e, vec3 l) {\n    vec3 f = normalize(l - e);\n    vec3 r = cross(vec3(0, 1, 0), f);\n    vec3 u = cross(f, r);\n    \n    return mat3(r, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //camera movement\n    if (iMouse.y != 0.0) {\n        _CameraDir.y =  max(5.0*(iMouse.y / iResolution.y - 0.5)*3.0,0.70); // to avoid going underwater\n        _CameraDir.z = -5.0*cos(iMouse.x / iResolution.x * 2.0 * PI);\n        _CameraDir.x = -5.0*sin(iMouse.x / iResolution.x * 2.0 * PI);\n    }\n    _CameraDir *= camera_distance;\n\n    fragColor = vec4(0);\n\n    for (int m = 0; m < AA; m++) {\n        for (int n = 0; n < AA; n++) {\n            vec2 uv = -1.0 + 2.0*(fragCoord.xy/iResolution.xy) + vec2(float(n) * (1.0/(iResolution.x * float(AA))), float(m) * (1.0/(iResolution.y * float(AA))));\n            uv.x *= iResolution.x/iResolution.y;\n\n            vec3 rd = camera(_CameraDir, vec3(0.0, 200.0, 0.0))*normalize(vec3(uv, 2.0));\n\n            fragColor += raymarch_terrain(_CameraDir, rd);\n\n            if (lens_flare > 0) {\n                vec3 sunpos = inverse(camera(_CameraDir, vec3(0)))*kSunDir;\n                if (sunpos.z > 0.0) fragColor += vec4(flare(uv, sunpos.xy), 1);\n            }\n        }\n    }\n\n    fragColor /= float(AA*AA);\n    if (gamma > 0) fragColor = pow(fragColor, vec4(1.0 / 2.2));\n}    \n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}