{
    "Shader": {
        "info": {
            "date": "1526882754",
            "description": "My implementation of Coding Challenge #103: Fire Effect from The Coding Train. https://www.youtube.com/watch?v=X0kjv0MozuY",
            "flags": 48,
            "hasliked": 0,
            "id": "lsdBD2",
            "likes": 12,
            "name": "CC103 Fire Effect",
            "published": 3,
            "tags": [
                "2d",
                "flame",
                "fire",
                "codingchallenge",
                "thecodingtrain"
            ],
            "usePreview": 0,
            "username": "stellartux",
            "viewed": 2341
        },
        "renderpass": [
            {
                "code": "/**\n\nCoding Challenge #103: Fire Effect\nThis is a fire effect shader based on Dan Shiffman's Coding Challenge #103\nhttp://thecodingtrain.com/CodingChallenges/103-fire-effect.html\nhttps://www.youtube.com/watch?v=X0kjv0MozuY\nwhich was in turn based off of the fire effect found at \nhttps://web.archive.org/web/20160418004150/http://freespace.virgin.net/hugo.elias/models/m_fire.htm\n\npress SPACE to toggle blue in the flames\nclick around the screen to change the size and speed of the flames\n\nCreated by Danny Robinson 2018\nReleased under the MIT license\n\n**/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // Display the flame buffer to the screen\n    fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n    \n    // Uncomment this line to display the cooling map instead of the fire\n    // fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This buffer uses a noise function to generate a scrolling heatmap\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// set how zoomed in the scale of the noise is and\n\t// map the level of detail to the x-coord of the mouse\n    vec4 m = iMouse / iResolution.xyxy;\n    float detail = pow(mix(3., 6., m.x), 2.) / iResolution.x; \n    \n    // Get the current screen coordinate and scale it by our detail level\n    vec2 noiseCoord = fragCoord.xy * vec2(detail);\n    \n    // wobble the x coord to create some unpredictability\n    noiseCoord.x += sin(iTime * 0.4) * 0.1;\n    \n    // map the speed of the rising flames to the y-coord of the mouse\n    float speed = mix(7., 18., m.y);\n    \n    // Scroll the cooling map\n   \tnoiseCoord.y -= iTime * speed;\n        \n    // Set our image's color with the output our noise function gives\n    // given the calculated coordinates, then scale the brightness\n    // depending on the color to get the red-orange-yellow effect\n    // see Common tab for noise function\n    float n = noise(noiseCoord);\n\tfragColor.rgb = vec3(n / 0.8, n / 2.5, n / 6.5);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This is the buffer where the fire effect is created. Reading from \n// texture(iChannel1) gives the color of this buffer during the previous \n// frame. Writing to fragColor.xyz draws the color to the current frame.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // uv are the normalised coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // frag is the size of a single fragment in our shader\n    // this is equivalent to one pixel in the original code\n    vec2 frag = vec2(iResolution.z) / iResolution.xy;\n    \n    // make the bottom row orange\n    // setting the values higher than 1 creates\n    // a gradient over the bottom few rows\n    if (uv.y < 1. * frag.y) {\n        fragColor.xyz = vec3(4., 1.5, 0.7);\n    }\n    else {\n        // average the colors of the four adjacent fragments\n        // since we are accessing the previous frame's pixels\n        // we need to take the colors of the current coordinate\n        // the pixel down 1px left 1px, the pixel down 1px right 1px,\n        // and the pixel down 2px\n        \n        vec3 c = texture(iChannel1, uv).rgb;\n        c += texture(iChannel1, uv + vec2(-frag.x, -frag.y)).rgb;\n        c += texture(iChannel1, uv + vec2(frag.x, -frag.y)).rgb;\n        c += texture(iChannel1, uv + vec2(0., -2. * frag.y)).rgb;\n        c /= 4.;\n\n        // subtract the value of the pixel from the cooling map\n        c -= texture(iChannel0, uv).rgb;\n\n        // Clamping the min and max values to 0.0 and 1.0\n        // seems to add some blue. It's pretty, but not fiery.\n        // Press space to toggle the blue\n        if (texelFetch(iChannel2, ivec2(32,2), 0).x > 0.5) {\n            c = clamp(c, vec3(0.), vec3(1.));\n            // make it a bit less green\n            c.g *= 0.977;\n        }\n\n        // fade pixels higher up the screen to black\n        c /= 1.042 + 115. * pow(uv.y, 7.5 + 3.5 * pow(abs(cos(iTime)), 3.));\n\n        // draw the fire in the buffer\n        fragColor.rgb = c;\n\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 hash( vec2 p ) {  \t\t\t\t\t\t\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor(p), f = fract(p);\n\tvec2 u = f*f*(3.-2.*f);\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}