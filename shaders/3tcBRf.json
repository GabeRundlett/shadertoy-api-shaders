{
    "Shader": {
        "info": {
            "date": "1613152330",
            "description": "Fancy 1D cellular automatas in raytraced box.\nExplore different rules by moving mouse\n\nkeybinds:\nspace - init automata with random values\nc - init with a single \"on\" state\nv - init with a single \"off\" state",
            "flags": 48,
            "hasliked": 0,
            "id": "3tcBRf",
            "likes": 6,
            "name": "1D cellular automata explorer",
            "published": 3,
            "tags": [
                "raytracing",
                "automata",
                "cellular"
            ],
            "usePreview": 0,
            "username": "kostik1337",
            "viewed": 301
        },
        "renderpass": [
            {
                "code": "float fetch_aut(vec2 p) {\n    if (p.x < 0. || p.x > 1. || p.y < 0. || p.y > 1.) return 0.;\n    p = p * CELLULAR_SIZE / iResolution.xy;\n    return texture(iChannel0, p).r;\n}\n\nvec3 lookAt(vec3 O, vec3 p, vec2 uv, float z) {\n    vec3 f = normalize(p - O);\n    vec3 r = vec3(1., 0., 0.);\n    vec3 u = normalize(cross(f, r));\n    r = cross(u, f);\n    return normalize(r*uv.x + u*uv.y + f * z);\n}\n\n#define INF 1e10\n\nfloat printRule(vec2 uv) {\n    ivec2 rule = getMouseRule(iMouse, iResolution).yz;\n    float v = PrintValue(uv, float(rule.x), 3., 0.);\n    v = max(v, PrintValue(uv + vec2(0., 1.4), float(rule.y), 3., 0.));\n    return v;\n}\n\nfloat box2(vec2 p, vec2 s) {\n    p = abs(p) - s;\n    return max(p.x, p.y);\n}\n\nfloat drawRuleGraphic(vec2 uv) {\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) return 0.;\n    int rule = getMouseRule(iMouse, iResolution).x;\n    vec2 patternFloor = floor(uv * 4.), patternUV = fract(uv*4.);\n\n    patternUV *= 1.2;\n    vec2 cellSize = vec2(3., 2.);\n    vec2 cellUV = fract(patternUV * cellSize) - .5;\n    vec2 cellFloor = floor(patternUV * cellSize);\n\n    int cellId = int(cellFloor.y * cellSize.x + cellFloor.x);\n    if(cellId == 4) cellId = 3;\n    else if(cellId == 0) cellId = 2;\n    else if(cellId == 1) cellId = 1;\n    else if(cellId == 2) cellId = 0;\n    else cellId = -1;\n\n    if (cellId != -1) {\n        int patternIndex = int(patternFloor.y * 4. + patternFloor.x);\n        int filled = (patternIndex >> cellId) & 1;\n        int isPatternInRuleTrue = (rule >> patternIndex) & 1;\n        \n        float m = box2(cellUV, vec2(.4));\n        if (filled == 0) m = max(m, -box2(cellUV, vec2(.3)));\n        float col = step(m, 0.);\n        if (isPatternInRuleTrue == 0) col *= .1;\n        return col;\n    }\n    return 0.;\n}\n\nvec3 raytrace(vec2 uv) {\n    vec3 col = vec3(0.);\n    \n    float planeZ = 1.3;\n\n    for (float ray = 0.; ray < RAYS; ++ray) {\n        vec3 rayCol = vec3(0.);\n        float rayInd = floor(ray/RAYS * 3.)-1.;\n        vec2 rgOffset = vec2(rayInd, 0.) / CELLULAR_SIZE * .5;\n\n        vec2 uvOff = vec2(hash2(uv+ray+iTime), hash2(uv.yx+ray*1.321+iTime)) / iResolution.xy;\n        vec2 camOffset = vec2(sin(iTime * vec2(.7, .86)))*.01;\n        vec3 O = vec3(camOffset,-.4);\n        vec3 D = lookAt(O, vec3(0., 0., 0.), uv + uvOff, .4);\n        //vec3 D = normalize(vec3(uv + uvOff, 0.)-O);\n        float refl = 1.;\n\n        for (float r = 0.; r < REFLECTIONS; ++r) {\n            vec2 Dsign = sign(D.xy);\n        \n            // Z Plane with cellular\n            float planeD = (planeZ - O.z) / D.z;\n            if (planeD < 0.) planeD = INF;\n            vec3 planeN = vec3(0., 0., -1.);\n\n            // Floor and walls\n            vec2 wXY = vec2(2.);\n            float floorD = (Dsign.y * wXY.y - O.y) / D.y;\n            vec3 floorN = vec3(0., -Dsign.y, 0.);\n            \n            float wallD = (Dsign.x * wXY.x - O.x) / D.x;\n            vec3 wallN = vec3(-Dsign.x, 0., 0.);\n\n            float wD = min(floorD, wallD);\n            float d = min(planeD, wD);\n            vec3 n = planeD < wD ? planeN : wallD < floorD ? wallN : floorN;\n\n            vec3 p = O+D*d;\n            \n            vec2 planeUV = planeD < wD ? p.xy : p.xy - 1./iResolution.xy;\n            planeUV += rgOffset;\n            vec3 c = vec3(0.);\n            if (planeD < wD) {\n                vec2 gridUv = fract(planeUV * CELLULAR_SIZE / 2. / wXY) - .5;\n                gridUv = abs(gridUv);\n                vec2 st = smoothstep(vec2(.5-.05), vec2(.5-.1), gridUv);\n                float cellDist = st.x * st.y;\n                c += cellDist * fetch_aut(planeUV/2./wXY + vec2(.5, .5));\n            } else if (wallD < floorD) {\n                if (Dsign.x < 0.) c += printRule(p.zy * 6. - vec2(planeZ+1.1, 0.));\n                else c += drawRuleGraphic(p.zy * vec2(-1., 1.) * 1.3 + vec2(1.6, .5));\n            }\n\n            rayCol += (c * refl) / RAYS;\n            D = reflect(D, n);\n            \n            float seed = r * .345 + ray + iTime;\n            vec3 randdir = vec3(hash2(p.yz+seed), hash2(p.xz + seed*1.423), hash2(p.yx + seed*0.313));\n            \n            float rough = .1;\n            D = normalize(D + (randdir-.5)*rough);\n            if(dot(D, n) < 0.) D = -D;\n            O = p + n*0.001;\n            refl *= .2;\n        }\n        \n        col += rayCol * vec3(rayInd == -1., rayInd == 0., rayInd == 1.);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    vec3 col = raytrace(uv);\n    col *= 2.5 * vec3(1.4, 1.1, 1.);\n    \n    fragColor = vec4(sqrt(col), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float RAYS = 16.;\nconst float RAYS_SQRT = floor(sqrt(RAYS));\nconst float REFLECTIONS = 3.;\n\nconst int FRAME_MOD = 3;\nconst vec2 CELLULAR_SIZE = vec2(70.);\n\nfloat hash(float n) { \n\treturn fract(sin(n) * 43758.5453);\n}\n\nfloat hash2(vec2 n) { \n\treturn hash(dot(n, vec2(12.9898, 4.1414)));\n}\n\nivec3 getMouseRule(vec4 iMouse, vec3 res) {\n    ivec2 ruleV = ivec2(iMouse.xy / (res.xy-1.) * 255.0);\n    ruleV = clamp(ivec2(0), ivec2(255), ruleV);\n    return ivec3(ruleV.x | (ruleV.y << 8), ruleV);\n}\n\n// from https://www.shadertoy.com/view/4sBSWW\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);\n    \n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "int fetch_state(vec2 p) {\n    p = mod(p + CELLULAR_SIZE, CELLULAR_SIZE);\n    return int(texture(iChannel0, p / iResolution.xy).r);\n}\n\nint calc_next(float x) {\n    int t_prev = fetch_state(vec2(x, 1.));\n    int t0 = fetch_state(vec2(x-1., 0.));\n    int t1 = fetch_state(vec2(x, 0.));\n    int t2 = fetch_state(vec2(x+1., 0.));\n    int encoded = (t0 << 0)|(t1 << 1) | (t2 << 2) | (t_prev << 3);\n    int rule = getMouseRule(iMouse, iResolution).x;\n    return (rule >> encoded) & 1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int state;\n    vec2 uv = fragCoord;\n    if (iFrame % FRAME_MOD != 0) {\n        state = fetch_state(fragCoord);\n    } else if (uv.x > CELLULAR_SIZE.x || uv.y > CELLULAR_SIZE.y) {\n        state = 0;\n    } else {\n        if (uv.y < 1.) {\n            bool keyPressed = texelFetch(iChannel1, ivec2(32, 0), 0).x > 0.;\n            bool cPressed = texelFetch(iChannel1, ivec2(67, 0), 0).x > 0.;\n            bool vPressed = texelFetch(iChannel1, ivec2(86, 0), 0).x > 0.;\n            if (iFrame == 0 || keyPressed) state = int(step(.5, hash(iTime + uv.x +131.3)));\n            else if (cPressed || vPressed) state = floor(uv.x) == CELLULAR_SIZE.x/2.? int(cPressed) : int(vPressed);\n            else state = calc_next(fragCoord.x);\n        }\n        else state = fetch_state(fragCoord - vec2(0., 1.));\n    }\n    \n    fragColor = vec4(float(state));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}