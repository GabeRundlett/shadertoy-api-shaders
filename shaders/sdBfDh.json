{
    "Shader": {
        "info": {
            "date": "1646792588",
            "description": "Simulates a putt shot at various ball speeds & angles.\nSee code comments for details.\nBased on this video by AlphaPhoenix: https://youtu.be/b-pLRX3L-fg\n",
            "flags": 48,
            "hasliked": 0,
            "id": "sdBfDh",
            "likes": 9,
            "name": "Golf Phase Space",
            "published": 3,
            "tags": [
                "simulation",
                "physics",
                "golf",
                "phasespace"
            ],
            "usePreview": 0,
            "username": "Flyguy",
            "viewed": 313
        },
        "renderpass": [
            {
                "code": "/*\nGolf putt shot phase space visualization\nBased on this video by AlphaPhoenix: https://youtu.be/b-pLRX3L-fg\n\nControls:\nClick -------> Location in phase space to visualize\nUp arrow ----> Show/hide phase space\nDown arrow --> Reset simulation\n\nPhase space details:\nX-axis = initial angle (ball_angle in center +/- ball_angle_range)\nY-axis = initial speed (bottom = 0, top = ball_max_speed)\nRed   = ball far from hole\nBlue  = ball close to hole\nWhite = ball in hole\n*/\n\nvec3 HeatmapGrad(float x)\n{\n    x = clamp(x,0.0,1.0);\n    return clamp(1.5-abs((x-vec3(0.75,0.50,0.25))*4.0),0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.y;\n    \n    //Initial mouse position\n    if(m == vec2(0))\n    {\n        m = vec2(0.551,0.582);\n    }\n    \n    //Map coloring\n    vec4 map = texture(iChannel0,uv/res,0.);\n    map.a = (map.a-map_flat_height)/(1.0-map_flat_height);\n    fragColor = vec4(mix(vec3(0.1,0.5,0.1),vec3(0.8,1.0,0.8), floor(map.a*15.)/15.), 0);\n    \n    float dist_hole = distance(texelFetch(iChannel1,ivec2(fragCoord),0).xy,hole_pos);\n    vec2 ball_pos = texelFetch(iChannel1,ivec2(m*iResolution.y),0).xy;\n    \n    //Ball/Hole/Start position drawing\n    StartCanvas(uv, 1.0/iResolution.y, fragColor);\n    {\n        //Hole\n        Color(vec3(0));\n        Circle(hole_pos, hole_size);\n        Color(vec3(0.3));\n        Ring(hole_pos, hole_size,ps*4.);\n        \n        //Ball at cursor pos in phase space\n        Color(vec3(1));\n        Circle(ball_pos, hole_size*0.5);\n        Color(vec3(0));\n        Ring(ball_pos, hole_size*0.5,ps);\n        \n        //Balls around the cursor in phase space\n        for(int i=-num_samples;i<=num_samples;i++)\n        {\n            for(int j=-num_samples;j<=num_samples;j++)\n            {\n                    vec2 offs = sample_range * vec2(i,j)/float(num_samples);\n                    ball_pos = texelFetch(iChannel1,ivec2(m*iResolution.y + offs), 0).xy;\n\n                    Color(vec3(1));\n                    Circle(ball_pos, hole_size*0.5);\n                    Color(vec3(0));\n                    Ring(ball_pos, hole_size*0.5,ps);\n            }\n        }\n        \n\n        //Initial angle range\n        Color(vec3(0)); \n        Ring(ball_start, hole_size*0.5,ps);\n        Line(ball_start,(ball_start+cossin(radians(ball_angle))*0.1),ps);\n        Line(ball_start,(ball_start+cossin(radians(ball_angle+ball_angle_range))*0.1),ps);\n        Line(ball_start,(ball_start+cossin(radians(ball_angle-ball_angle_range))*0.1),ps);\n        \n        //Ball start position\n        Color(vec3(1,0,0));\n        Circle(ball_start, hole_size*0.5);\n        Color(vec3(0));\n        Ring(ball_start, hole_size*0.5,ps);\n    }\n    EndCanvas(fragColor);\n    \n    if(checkKey(iChannel2, 38).z) //Up arrow to show/hide phase space\n    {\n        float csize = 0.03;\n        fragColor = vec4(HeatmapGrad(dist_hole),0);\n        fragColor += step(-hole_size,-dist_hole); //White = in hole\n        \n        //Cursor\n        StartCanvas(uv, 1.0/iResolution.y, fragColor);\n        {        \n            Color(vec3(0.5-c.rgb)*2.);//Invert colors under cursor\n            Line(m+vec2(0,csize*0.5), m+vec2(0,csize), ps);\n            Line(m+vec2(0,-csize*0.5), m+vec2(0,-csize), ps);\n            Line(m+vec2( csize*0.5,0), m+vec2( csize,0), ps);\n            Line(m+vec2(-csize*0.5,0), m+vec2(-csize,0), ps);\n            Circle(m, 1.*ps);\n        }\n        \n        EndCanvas(fragColor);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Height map and normal map\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nvec4 noise2D(vec2 uv)\n{\n    ivec2 tres = textureSize(iChannel0,0);\n    uv = fract(uv);\n    uv *= vec2(tres);\n    vec4 s0 = texelFetch(iChannel0, ivec2(uv.x+0.,uv.y+0.)%tres,0);\n    vec4 s1 = texelFetch(iChannel0, ivec2(uv.x+1.,uv.y+0.)%tres,0);\n    vec4 s2 = texelFetch(iChannel0, ivec2(uv.x+0.,uv.y+1.)%tres,0);\n    vec4 s3 = texelFetch(iChannel0, ivec2(uv.x+1.,uv.y+1.)%tres,0);\n    \n    uv -= floor(uv);\n    vec4 nh0 = mix(s0,s1,-0.5*cos(uv.x*3.14159)+0.5);\n    vec4 nh1 = mix(s2,s3,-0.5*cos(uv.x*3.14159)+0.5);\n    return   mix(nh0,nh1,-0.5*cos(uv.y*3.14159)+0.5);\n}\n\nfloat heightmap(vec2 uv)\n{   \n    float h = noise2D(uv*map_scale-map_offs).x;\n    h = -smin(-h,-map_flat_height,11.);\n    \n    return h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Initialize heightmap & normal map on frame 0/down arrow pressed\n    if(iFrame == 0 || checkKey(iChannel2, 40).x) \n    {\n        vec2 ps = 1.0 / iResolution.xy;\n        vec2 uv = fragCoord / iResolution.xy;\n\n        float h = heightmap(uv);\n\n        float u = heightmap(uv + ps.xy*vec2( 0, 1));\n        float d = heightmap(uv + ps.xy*vec2( 0,-1));\n        float l = heightmap(uv + ps.xy*vec2(-1, 0));\n        float r = heightmap(uv + ps.xy*vec2( 1, 0));\n\n        vec3 dx = vec3(ps.x*3., 0, r-l);\n        vec3 dy = vec3(0, ps.y*3., u-d);\n        vec3 n = normalize(cross(dx,dy));\n\n        fragColor = vec4(n,h);\n    }\n    else\n    {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float inf = 1e4;\nconst float tau = 6.283185307;\n\n//Display settings\nconst int num_samples = 0; // > 0 to show multiple balls at different locations in phase space around the cursor\nfloat sample_range = 25.0; // Range to sample around the cursor (pixels)\n\n//Physics Settings\nfloat dt = 0.002; //Time delta per frame\nfloat gravity = 9.0; //Gravitational acceleration.\n\n//Initial condition settings\nvec2  ball_start = vec2(0.05,0.65); //Ball starting position on screen\nfloat ball_angle = -10.0; //Ball starting angle\nfloat ball_angle_range = 60.0; //Starting angle range (ball_angle +/- ball_angle_range)\nfloat ball_max_speed = 7.; //Max inital speed\nfloat ball_min_vel = 0.1; //Minimum velocity to consider the ball stopped\nfloat ball_min_acc = 0.1; //Minimum acceleration to consider the ball stopped\nfloat ball_drag = 2.0; //Air drag coeffient\n\nvec2  hole_pos = vec2(1.3,0.6); //Hole position on screen\nfloat hole_size = 0.025; //Hole size\n\n//Map settings\nvec2  map_offs = vec2(0.124,0.330); //X,Y offset of map in the noise texture \nfloat map_scale = 0.020; //Scale of the noise texture\nfloat map_flat_height = 0.5; //Flat ground level blended with noise\n\n//Misc functions\nvec2 cossin(float x)\n{\n    return vec2(cos(x),sin(x));\n}\n\nbvec3 checkKey(sampler2D tex, int key)\n{\n    return bvec3(\n        texelFetch(tex,ivec2(key, 0), 0).x == 1.0,\n        texelFetch(tex,ivec2(key, 1), 0).x == 1.0,\n        texelFetch(tex,ivec2(key, 2), 0).x == 1.0\n    );\n}\n\n//Debug drawing canvas functions\nfloat dfCircle(float r, vec2 uv)\n{\n    return length(uv)-r;\n}\n\nfloat dfRing(float r, float w, vec2 uv)\n{\n    return abs(length(uv)-r)-w/2.0;\n}\n\nfloat dfLine(vec2 start, vec2 end, float w, vec2 uv)\n{\n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv)-w/2.0;\n}\n\nmat2 Rotate(float angle)\n{\n\treturn mat2(cos(angle), sin(angle), -sin(angle), cos(angle));   \n}\n\n#define StartCanvas(p, s, b) {vec2 uv=p; float ps=s; vec4 c=b; vec4 oc=vec4(0,0,0,1);\n#define Color(v) oc.rgb = vec3(v);\n#define Alpha(v) oc.a = float(v);\n#define Circle(p,d) c=mix(c,oc,smoothstep(ps,0.,dfCircle(d,uv-(p))));\n#define Ring(p,d,w) c=mix(c,oc,smoothstep(ps,0.,dfRing(d,w,uv-(p))));\n#define Line(a,b,w) c=mix(c,oc,smoothstep(ps,0.,dfLine(a,b,w,uv)));\n#define EndCanvas(o) o=mix(o,c,c.w);}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//Ball simulation\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n    ivec2 iuv = ivec2(fragCoord);\n    \n    vec4 state = texelFetch(iChannel1,iuv,0);\n    \n    vec2 cur_pos = state.xy;\n    vec2 pre_pos = state.zw;\n    \n    vec2 vel = (cur_pos - pre_pos)/dt;\n   \n    vec2 accel = gravity*texture(iChannel0,cur_pos/res,0.).xy;\n    accel += -ball_drag*vel;\n    \n    vec2 next_pos = (2.0*cur_pos - pre_pos) + accel*(dt*dt);\n\n    if(pre_pos != vec2(inf)) //pre_pos = vec2(-inf)\n    {\n        //Ball hit the border\n        if(any(lessThan(cur_pos,vec2(0))) || any(greaterThan(cur_pos,res)))\n        {\n            next_pos = cur_pos;\n            cur_pos = vec2(inf);\n        }\n        \n        //Ball is in the hole\n        if(distance(cur_pos,hole_pos) < hole_size)\n        {\n            next_pos = hole_pos;\n            cur_pos = vec2(inf);\n        }\n        \n        //Ball has stopped\n        if(length(vel) < ball_min_vel && length(accel) < ball_min_acc)\n        {\n            next_pos = cur_pos;\n            cur_pos = vec2(inf);\n        }\n    }\n    else\n    {\n        next_pos = cur_pos;\n        cur_pos = vec2(inf);\n    }\n    \n    //Initialize ball position & speed on frame 0/down arrow pressed\n    if(iFrame == 0 || checkKey(iChannel2, 40).x) \n    {\n        vec2 uv = fragCoord/iResolution.xy;\n\n        ball_angle = ball_angle + (2.*uv.x-1.)*ball_angle_range;\n        ball_max_speed = ball_max_speed * uv.y;\n        \n        next_pos = ball_start + ball_max_speed * cossin(radians(ball_angle)) * dt;\n        cur_pos = ball_start;\n    }\n    \n    fragColor = vec4(next_pos,cur_pos);;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}