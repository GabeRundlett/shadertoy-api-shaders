{
    "Shader": {
        "info": {
            "date": "1564674219",
            "description": "based on [url=https://www.shadertoy.com/view/tslXWX]Round Voronoi Border : Fork[/url]\n\nuse mouse x for see shape rounded/straight",
            "flags": 0,
            "hasliked": 0,
            "id": "ttlSDl",
            "likes": 36,
            "name": "Iridescent Rounded Voronoi",
            "published": 3,
            "tags": [
                "voronoi",
                "iridescent"
            ],
            "usePreview": 1,
            "username": "aiekick",
            "viewed": 1005
        },
        "renderpass": [
            {
                "code": "// base code from shane : https://www.shadertoy.com/view/4sdcDN\n// fork of my : https://www.shadertoy.com/view/tslXWX\n\nconst float _threshold = 0.0;\nconst vec3 _cellColor = vec3(0.2,0.6,0.7);\nconst float _zoom = 1.0;\n\nfloat objID; // The rounded web lattice, or the individual Voronoi cells.\nvec2 cellID;\n\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nfloat smin2(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\nvec2 hash22H(vec2 p) \n{ \n    float n = sin(dot(p, vec2(41, 289)));\n    p = fract(vec2(262144, 32768)*n);\n    return sin( p*6.2831853 + iTime )*.3660254 + .5; \n}\n\nvec2 pixToHex(vec2 p)\n{\n    return floor(vec2(p.x + .57735*p.y, 1.1547*p.y));\n}\n\nvec2 hexPt(vec2 p) \n{\n    return vec2(p.x - p.y*.5, .866025*p.y) + (hash22H(p) - .5)*.866025/2.;\n    \n}\n\nvec3 Voronoi(vec2 p)\n{\n    vec2 pH = pixToHex(p); // Map the pixel to the hex grid.\n\tconst vec2 hp[7] = vec2[7](vec2(-1), vec2(0, -1), vec2(-1, 0), vec2(0), vec2(1), vec2(1, 0), vec2(0, 1)); \n    vec2 minCellID = vec2(0); // Redundant initialization, but I've done it anyway.\n\tvec2 mo, o;\n    float md = 8., lMd = 8., lMd2 = 8., lnDist, d;\n    for (int i=0; i<7; i++)\n\t{\n        vec2 h = hexPt(pH + hp[i]) - p;\n    \td = dot(h, h);\n    \tif( d<md )\n\t\t{\n            md = d;  // Update the minimum distance.\n            mo = h; \n            minCellID = hp[i]; // Record the minimum distance cell ID.\n        }\n    }\n\n\tfloat r = mix(0.0,0.4,sin(iTime * 0.5)*0.5+0.5);\n    \n\tif (iMouse.z > 0.0)\n\t\tr = mix(0.0,0.4,iMouse.x/iResolution.x);\n    \n    for (int i=0; i<7; i++)\n\t{\n        vec2 h = hexPt(pH + hp[i] + minCellID) - p - mo; // Note the \"-mo\" to save some operations. \n        if(dot(h, h)>.00001){\n            lnDist = dot(mo + h*.5, normalize(h));\n            lMd = smin2(lMd, lnDist, (lnDist*.5 + .5)*r);\n            lMd2 = min(lMd2, lnDist);\n\t\t\tcellID = vec2(lMd);\n        }\n    }\n\n    float t = iTime * 5.;\n    d = lMd * 25.;\n    mo -= vec2(cos(d + t),sin(d + t)) / d;\n    lMd2 = length(mo);\n\t\n    return max(vec3(lMd, lMd2, md), 0.);\n}\n\nfloat bumpFunc(vec2 p)\n{\n    vec3 v = Voronoi(p);\n    float c = v.x; // Rounded edge value.\n    float ew = _threshold; // Border threshold value. Bigger numbers mean thicker borders.\n    if(c<ew)\n\t{ \n        objID = 1.; // Voronoi web border ID.\n        c = abs(c - ew)/ew; // Normalize the domain to a range of zero to one.\n        c = smoothstep(0., .25, c)/4. + clamp(-cos(c*6.283*1.5) - .5, 0., 1.);\n    }\n    else \n\t{ // Over the threshold? Use the regular Voronoi cell value.\n        objID = 0.;\n        c = mix(v.x,  v.y, .75); // A mixture of rounded and straight edge values.\n        c = (c - ew)/(1. - ew); // Normalize the domain to a range of zero to one.\n        c = clamp(c + cos(c*6.283*24.)*.002, 0., 1.); // Add some ridges.\n    }\n    return c; // Return the object (bordered Voronoi) value.\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tcellID = vec2(0);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/min(iResolution.y, 800.) * _zoom;\n    vec2 aspect = vec2(iResolution.y/iResolution.x, 1);\n    uv *= 1. + dot(uv*aspect, uv*aspect)*.05;\n    vec3 r = normalize(vec3(uv.xy, 1.));\n    vec2 p = uv*3.5 + vec2(0, iTime*.5);\n    float c = bumpFunc(p);\n    float svObjID = objID; \n    vec3 sp = vec3(p, 0.);\n    vec3 lp = sp + vec3(-1.3*sin(iTime/2.), .8*cos(iTime/2.), -.5);\n    vec3 lp2 = sp + vec3(1.3*sin(iTime/2.), -.8*cos(iTime/2.), -.5);\n    sp.z -= c*.1;\n    vec2 e = vec2(8./iResolution.y, 0); // Sample spred.\n    float bf = .4; // Bump factor.\n    if (svObjID>.5) { e.x = 2./iResolution.y; }\n    float fx = (bumpFunc(p - e) - bumpFunc(p + e)); // Nearby horizontal samples.\n    float fy = (bumpFunc(p - e.yx) - bumpFunc(p + e.yx)); // Nearby vertical samples.\n\tvec3 n = normalize(vec3(fx, fy, -e.x/bf)); // Bumped normal.\n    float edge = abs(c*2. - fx) + abs(c*2. - fy); // Edge value.\n    vec3 tx = texture(iChannel0, (p + n.xy*.125)*.25).xyz; tx *= tx; // sRGB to linear.\n    tx = smoothstep(0., .5, tx); // Accentuating the color a bit.\n    vec3 oCol = tx; \n    if(svObjID>.5)\n\t{\n        oCol *= 1.-_cellColor;\n    }   \n    else\n\t{\n        oCol *= _cellColor; \n    }\n\t\n\toCol.xy *= cellID * 10.;\n\t\n    float lDist = length(lp - sp); // Light distance one.\n    float atten = 1./(1. + lDist*lDist*.5); // Light one attenuation.\n    vec3 l = (lp - sp)/max(lDist, .001); // Light one direction (normalized).\n\tfloat diff = max(max(dot(l, n), 0.), 0.); // Diffuse value one.\n    float spec = pow(max(dot(reflect(l, n), r), 0.), 64.); // Specular value one.\n    \n    float lDist2 = length(lp2 - sp); // Light distance two.\n    float atten2 = 1./(1. + lDist2*lDist2*.5); // Light two attenuation.\n    vec3 l2 = (lp2 - sp)/max(lDist2, .001); // Light two direction (normalized).\n\tfloat diff2 = max(max(dot(l2, n), 0.), 0.); // Diffuse value two.\n    float spec2 = pow(max(dot(reflect(l2, n), r), 0.), 64.); // Specular value twp.\n    \n    diff = pow(diff, 4.)*2.;\n    diff2 = pow(diff2, 4.)*2.;\n\n    vec3 col = oCol*(diff*vec3(.5, .7, 1) + .25 + vec3(.25, .5, 1)*spec*32.)*atten*.5;\n    \n    col += oCol*(diff2*vec3(1, .7, .5) + .25 + vec3(1, .3, .1)*spec2*32.)*atten2*.5;\n\n\tif(svObjID>.5)\n\t{\n        col *= edge;\n    }   \n    else \n\t{\n        col /= edge;\n    }\n        \n    vec2 u = fragCoord/iResolution.xy;\n    col *= pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .125);\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}