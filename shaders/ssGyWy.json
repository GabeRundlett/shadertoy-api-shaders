{
    "Shader": {
        "info": {
            "date": "1655476042",
            "description": "Sold out!",
            "flags": 0,
            "hasliked": 0,
            "id": "ssGyWy",
            "likes": 12,
            "name": "Shader Cap",
            "published": 3,
            "tags": [
                "cap"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 274
        },
        "renderpass": [
            {
                "code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 256\n#define MAX_DIST 128.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define MATERIAL 0\n#define MATERIAL1 1\n#define NAVY vec3(0.0,0.2,0.3)\n#define RED vec3(0.5,0.1,0.1)\n#define GREEN vec3(0.0,0.3,0.2)\n#define GALAXY vec3(0.75,0.75,0.8)\n#define PI 3.141592653589793\n\n#define ZERO (min(iFrame,0))\n\nconst vec3 colors[4] = vec3[](NAVY,RED,GREEN,GALAXY);\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nvec3 bend(vec3 p, float k){\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t ) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdHexPrism( vec3 p, vec2 h ) {\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 hash(vec2 p){\n    vec2 rand = fract(sin(p*123.456)*567.89);\n    rand += dot(rand,rand*34.56);\n    return fract(rand);\n}\n\nvec4 voronoi(vec2 uv, float scale){\n    uv*=scale;\n    \n    vec2 id = floor(uv);\n    vec2 gv = fract(uv);\n    \n    vec4 m_col = vec4(0.1);\n    float vd = 1.0;\n    for(int y = -1; y<=1; y++){\n        for(int x = -1; x<=1; x++){\n            vec2 n = vec2(float(x),float(y));\n            vec2 p = hash(id+n);\n            vec2 prevP = p;\n            p = 0.5 + 0.5*sin(iTime + 6.2831*p);\n            vec2 diff = n + p - gv;\n            float d = length(diff);\n            float ptd = length(diff)-(0.1*abs(prevP.x));\n\n            if ( d < vd ) {\n                vd = d;\n                m_col.xy = diff+hash(id+n);\n                m_col.w = ptd;\n            }\n            \n        }\n    }\n    \n    return m_col;\n}\n\nfloat perlin_noise(vec2 p) {\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    // interpolation\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    float f00 = dot(hash(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0));\n    float f01 = dot(hash(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0));\n    float f10 = dot(hash(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0));\n    float f11 = dot(hash(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0));\n    \n    // mixing top & bottom edges\n    float xm1 = mix(f00, f10, w.x);\n    float xm2 = mix(f01, f11, w.x);\n    \n    // mixing to point\n    float ym = mix(xm1, xm2, w.y); \n    \n    return ym;\n}\n\nvec3 getVoronoiCol(vec2 p){\n    vec3 c = vec3(0.7);\n\n    vec2 vd = voronoi(p,5.0).xy;\n    c.rb=vd;\n    return c;\n}\n\nvec3 pnoiseCol(vec2 p){\n    p.y-=iTime*0.3;\n    vec3 c1 = vec3(perlin_noise(p*3.0),0.2,0.0);\n    vec3 c3 = vec3(0.5,0.0,perlin_noise(p));\n    return vec3(1.)+c1+c3; \n}\n\nvec3 getColor(vec2 p, int num){\n    vec3 c = vec3(1.);\n    int len = colors.length();\n    if(num<len){\n        c = colors[num];\n    } else {\n        if(num == len){\n            c = getVoronoiCol(p);\n        } else {\n            c = pnoiseCol(p);\n        }\n    }\n    return c;\n}\n\nfloat capDist(vec3 p){\n    vec3 prevP = p;\n    \n    p.yz*=Rot(radians(90.));\n    p.xy*=Rot(radians(90.));\n    p.x*=1.05;\n    float d = abs(sdHexPrism(p,vec2(0.5,0.2))-2.0)-0.1;\n    p = prevP;\n    d = max(-p.y-0.6,d);\n    \n    p.z+=2.46;\n    \n    vec3  q = bend(p,-0.12);\n    float d2 = sdBox(q,vec3(1.5,-2.3,0.7))-2.5;\n    \n    q.y+=0.5;\n    float mask = sdBox(q,vec3(2.5,0.5,1.57));\n    \n    d = max(-mask,d);\n    \n    d = smin(d,d2,0.2);\n    \n    p = prevP;\n    p.y-=2.3;\n    p.y*=2.;\n    d2 = length(p)-0.22;\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y-=1.92;\n    p.xz = DF(p.xz,1.5);\n    p.xz -= vec2(1.2,1.2);\n    p.xy*=Rot(radians(30.));\n    p.yz*=Rot(radians(-30.));\n    \n    d2 = sdTorus(p,vec2(0.1,0.05));\n    \n    d = min(d,d2);\n   \n    return d;\n}\n\n/*\nI always wanted to do the displacement to add elements to the surface of the model nicely, \nbut I have no clue what is the simplet way to approach this kinda stuff.\n*/\nfloat capLogo(vec3 p) {\n    p.y*=1.5;\n    p.y-=1.9;\n    p.z+=2.1;\n    \n    p.x*=-1.;\n    p.xy*=Rot(radians(80.));\n    p.xz*=Rot(radians(22.));\n    p*=0.8;\n    vec3 prevP = p;\n    p.x+=0.3;\n    p.xy*=Rot(radians(-20.));\n    float r = radians(100.0);\n    vec2 c = vec2(sin(r),cos(r));\n    float d = sdCappedTorus(p,c,0.3,0.2);\n    \n    p = prevP;\n    p.x-=0.3;\n    p.xy*=Rot(radians(160.));\n    r = radians(100.0);\n    c = vec2(sin(r),cos(r));\n    float d2 = sdCappedTorus(p,c,0.3,0.2);\n    \n    return smin(d,d2,0.05);\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    p+=noise3d(p*500.0)*0.001;\n    float d = capDist(p);\n    float d2 = capLogo(p);\n    \n    vec2 model = vec2(d*0.6,MATERIAL);\n    vec2 model2 = vec2(d2,MATERIAL1);\n    \n    return combine(model,model2);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(10,10,-10));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.)*occ; // spec\n        \n    return diffCol;\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat backOut(float t) {\n  float f = 1.0 - t;\n  return 1.0 - (pow(f, 3.0) - f * sin(f * PI));\n}\n\nfloat getTime(float t, float duration){\n    return clamp(t,0.0,duration)/duration;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    vec3 prevP = p;\n    if(mat == MATERIAL){\n        float frame = mod(iTime,30.);\n        int num = 0;\n        float time = frame;\n        vec3 c = vec3(1.0);\n        if(frame<5.){\n            c = getColor(p.xz,5);\n            time = getTime(time,1.5);\n        } else if(frame>=5.0 && frame<10.){\n            num = 1;\n            c = getColor(p.xz,0);\n            time = getTime(time-5.0,1.5);\n        } else if(frame>=10.0 && frame<15.) {\n            num = 2;\n            c = getColor(p.xz,1);\n            time = getTime(time-10.0,1.5);\n        } else if(frame>=15.0 && frame<20.) {\n            num = 3;\n            c = getColor(p.xz,2);\n            time = getTime(time-15.0,1.5);\n        } else if(frame>=20.0 && frame<25.) {\n            num = 4;\n            c = getColor(p.xz,3);\n            time = getTime(time-20.0,1.5);\n        } else if(frame>=25.0 && frame<30.) {\n            num = 5;\n            c = getColor(p.xz,4);\n            time = getTime(time-25.0,1.5);\n        }\n        \n        vec3 pos = p;\n        pos.y-=1.2;\n        float d = length(pos.xy)-(cubicInOut(time)*5.0);\n        c = mix(c,getColor(p.xz,num),S(d,-0.9));\n        \n        col = diffuseMaterial(n,rd,p,c);\n    } else if(mat == MATERIAL1){\n        vec3 c = vec3(0.9);\n        col = diffuseMaterial(n,rd,p,c);\n    }\n    return col;\n}\n\nvec3 drawUI(vec2 uv, vec3 col){\n    vec2 prevUV = uv;\n    float size = 0.035;\n    float y = -0.4;\n    \n    float frame = mod(iTime,30.);\n    vec2 selectedPos = vec2(-0.375,y);\n    float time = frame;\n    float ptime = frame;\n    float interval = 5.;\n    if(frame<5.){\n        time = getTime(time,0.6);\n    } else if(frame>=5.0 && frame<10.){\n        selectedPos = vec2(-0.225,y);\n        time = getTime(time-5.0,0.6);\n        ptime = ptime-5.0;\n    } else if(frame>=10.0 && frame<15.) {\n        selectedPos = vec2(-0.075,y);\n        time = getTime(time-10.0,0.6);\n        ptime = ptime-10.0;\n    } else if(frame>=15.0 && frame<20.) {\n        selectedPos = vec2(0.075,y);\n        time = getTime(time-15.0,0.6);\n        ptime = ptime-15.0;\n    } else if(frame>=20.0 && frame<25.) {\n        selectedPos = vec2(0.225,y);\n        time = getTime(time-20.0,0.6);\n        ptime = ptime-20.0;\n    } else if(frame>=25.0 && frame<30.) {\n        selectedPos = vec2(0.375,y);\n        time = getTime(time-25.0,0.6);\n        ptime = ptime-25.0;\n    }\n    \n    float dd = abs(length(uv-selectedPos)-(backOut(time)*(size+0.01)))-0.002;\n    col = mix(col, vec3(1.0),S(dd,0.0));\n    \n    dd = length(uv-vec2(-0.375,y))-size;\n    col = mix(col, getColor(uv,0),S(dd,0.0));\n    dd = length(uv-vec2(-0.225,y))-size;\n    col = mix(col, getColor(uv,1),S(dd,0.0));\n    dd = length(uv-vec2(-0.075,y))-size;\n    col = mix(col, getColor(uv,2),S(dd,0.0));\n    dd = length(uv-vec2(0.075,y))-size;\n    col = mix(col, getColor(uv,3),S(dd,0.0));\n    dd = length(uv-vec2(0.225,y))-size;\n    col = mix(col, getColor(uv,4),S(dd,0.0));\n    dd = length(uv-vec2(0.375,y))-size;\n    col = mix(col, getColor(uv,5)-vec3(0.55),S(dd,0.0)); \n    \n    // icon\n    uv.x-=0.07;\n    dd = abs(B(uv-vec2(0.3,0.4),vec2(0.04,0.025)))-0.002;\n    float dd2 = abs(B(uv-vec2(0.3,0.435),vec2(0.02,0.01)))-0.002;\n    dd = min(dd,dd2);\n    uv.x*=1.5;\n    dd2 = abs(length(uv-vec2(0.45,0.4))-0.01)-0.002;\n    dd = min(dd,dd2);\n    col = mix(col, vec3(0.0),S(dd,0.0));\n    \n    // progress\n    uv = prevUV;\n    uv-=selectedPos;\n    dd = abs(length(uv)-size)-0.003;\n    dd2 = abs(length(uv)-size)-0.003;\n    float deg = mod((ptime/interval*360.), 360.);\n    float r = radians(deg);\n    float cmask = dot(uv,vec2(cos(r),sin(r)));\n    \n    if(deg<180.){\n        dd = max(cmask,dd);\n        dd2 = max(-uv.x,dd2);\n        dd = min(dd,dd2);    \n    } else {\n        dd = max(cmask,dd);\n        dd = max(-uv.x,dd);\n    }\n    \n    col = mix(col, vec3(0.5,0.8,0.5),S(dd,0.0));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0.0, -10.);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.yz *= Rot(radians(20.0));\n        ro.xz *= Rot(radians(sin(iTime*0.3)*60.0));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(0.8);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    } else {\n        col = mix(col,vec3(0.6),smoothstep(0.1, -0.5, uv.y));\n        uv.y-=iTime*0.2;\n        float ptd = voronoi(uv,7.0).w;\n        col = mix(col,vec3(0.9),S(ptd,-0.1));\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    // UI\n    uv = prevUV;\n    col = drawUI(uv,col);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}