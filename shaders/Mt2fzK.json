{
    "Shader": {
        "info": {
            "date": "1516576341",
            "description": "Brute-force ray tracing a list of triangles stored in a texture (generated in Buffer A).\nChange sub2 (in Common) to change the number of subdivisions of the mesh, then rewind to regenerate the mesh.",
            "flags": 32,
            "hasliked": 0,
            "id": "Mt2fzK",
            "likes": 21,
            "name": "Geodesic Mesh",
            "published": 3,
            "tags": [
                "mesh"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 1012
        },
        "renderpass": [
            {
                "code": "// Triangle Mesh Renderer\n// by Hazel Quantock 2018\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\nconst float FLT_MIN = 1e-30;\nconst float FLT_MAX = 1e30;\n\nivec2 address( int offset )\n{\n    // invert d = int(fragCoord.x)+int(fragCoord.y)*256; from Buf A\n    return ivec2(offset&255,offset>>8);\n}\n\nvoid IntersectTriangle( inout float _t, inout vec3 _n, vec3 pos, vec3 ray, int c )\n{\n    vec4 nd = texelFetch(iChannel0,address(c*4+0),0);\n    \n    float rn = dot(ray,nd.xyz);\n//    if ( abs(rn) < FLT_MIN ) return; // cull faces in plane of ray\n    if ( -rn < FLT_MIN ) return; // back face cull\n    \n    // find intersection on plane\n    float t = (nd.w-dot(pos,nd.xyz))/rn;\n    \n    // if it's behind camera, or farther than current intersection, ignore\n    if ( t < 0. || t >= _t ) return;\n    \n    // test if it's within edges\n    pos += t*ray;\n    \n    vec4 e0 = texelFetch(iChannel0,address(c*4+1),0);\n    vec4 e1 = texelFetch(iChannel0,address(c*4+2),0);\n    vec4 e2 = texelFetch(iChannel0,address(c*4+3),0);\n    \n    if ( dot(pos,e0.xyz)-e0.w > 0. ||\n         dot(pos,e1.xyz)-e1.w > 0. ||\n         dot(pos,e2.xyz)-e2.w > 0. )\n        return;\n    \n    _t = t;\n    _n = nd.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ray = normalize( vec3(\n        \t\t\t(fragCoord-iResolution.xy*.5)/iResolution.y,\n        \t\t\t1.5 ) );\n    float a = iTime*1.;\n    vec3 pos = vec3(sin(a),.5,-cos(a))*3.5;\n    \n    vec3 k = normalize(vec3(0)-pos);\n    vec3 i = normalize(cross(vec3(0,1,0),k));\n    vec3 j = cross(k,i);\n    ray = ray.x*i+ray.y*j+ray.z*k;\n\n    vec3 n = vec3(0);\n    float t = 1e30;\n    for ( int c=0; c < triangleCount; c++ )\n    {\n        IntersectTriangle(t,n,pos,ray,c);\n    }\n    \n    if ( t < 1e30 )\n    {\n        pos = pos+ray*t+.001;\n        //fragColor.rgb = n*.5+.5; // direction from normal\n        a += -1.5;\n        fragColor.rgb = max(0.,dot(n,normalize(vec3(sin(a),1,-cos(a)))))*vec3(1)+.0;\n\n        // reflection strength at (steep,shallow) angles\n        //vec2 fres = vec2(1,1); // mirrorball\n        vec2 fres = vec2(.02,1); // diffuse with slight sheen\n        fragColor.rgb = mix(fragColor.rgb,texture(iChannel1,reflect(ray,n)).rgb,\n                            mix(fres.x,fres.y,pow(dot(ray,n)+1.,5.)));\n\n        // signature   \n        #define L(m,n,u,v,l,f) min(f,max(abs(dot(fragCoord-vec2(m,n),vec2(u,v)))-l,abs(dot(fragCoord-vec2(m,n),vec2(-v,u)))-1.))\n        float sig=L(3,7,0,1,3.5,L(7,7,0,1,3.5,L(5,7,1,0,2.,L(14.5,5,.7071,-.7071,2.5,abs(length(fragCoord-vec2(12.7,7))-3.)-1.))));\n        fragColor.rgb = mix( 1.-fragColor.rgb, fragColor.rgb, .5+.5*sig/(.1+abs(sig)) );\n    }\n    else\n    {\n        fragColor.rgb = texture(iChannel1,ray).rgb;\n    }\n    \n    fragColor.rgb = pow(fragColor.rgb,vec3(1./2.2));\n    \n\t//fragColor.rgb = fract(n*1.618*vec3(1,2,3)); // random colour (no gamma correction ~= perceptually equal)\n    \n    fragColor.a = 1.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Geodesic Mesh Generator\n// by Hazel Quantock 2018\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\nuvec4 Hash( uint seed ) \n{\n    // integer hash from Hugo Elias\n\tseed = (seed << 13U) ^ seed;\n    seed = seed * (seed * seed * 15731U + 789221U) + 1376312589U;\n    return seed * uvec4(seed,seed*16807U,seed*48271U,seed*31713U);\n}\n\n\nvec3 VRand( uint seed )\n{\n    return vec3(Hash(seed).xyz&0x7fffffffU)/float(0x7fffffffU);\n}\n\n\nvec4[4] Triangle( in vec3 p0, in vec3 p1, in vec3 p2 )\n{\n    vec3 n = normalize(cross(p1-p0,p2-p0));\n    vec3 a = normalize(cross(p1-p0,n));\n    vec3 b = normalize(cross(p2-p1,n));\n    vec3 c = normalize(cross(p0-p2,n));\n    return vec4[](\n        vec4(n,dot(n,p0)),\n        vec4(a,dot(a,p0)),\n        vec4(b,dot(b,p1)),\n        vec4(c,dot(c,p2))\n        );\n}\n\n\nfloat Height( vec3 v )\n{\n    v *= 6.283*1.5+vec3(0.,.618,1.618);\n    float h = (sin(v.x)+sin(v.y)+sin(v.z))/3.;\n    return h*.2+1.;\n    \t\t//+pow(abs(h),6.)*1.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int subs = 1<<(sub2*2);\n    if ( iFrame >= subs+1 ) discard; // +1 because we need to fill both double-buffers\n    \n    \n    // vertices of an icosahedron (or face normals of a dodecahedron)\n    float tau = 1.618;\n    vec4 s = vec4(tau,1,-1,0); // so can do s.xy,s.xz,-s.xz,-s.xy to hit all 4 signs\n    vec3 points[] = vec3[](\n        s.xyw, s.xzw, -s.xzw, -s.xyw,\n        s.ywx, s.zwx, -s.zwx, -s.ywx,\n        s.wxy, s.wxz, -s.wxz, -s.wxy\n    );\n    \n    \n    // connect the vertices\n    int triangleList[] = int[](\n        \t\t\t0,8,4, 0,6,9, 2,5,8, 2,9,7, 1,4,10, 1,11,6, 3,10,5, 3,7,11, \n                    1,0,4, 0,1,6, 2,3,5, 3,2,7,\n                    5,4,8, 4,5,10, 6,7,9, 7,6,11,\n                    9,8,0, 8,9,2, 10,11,1, 11,10,3 );\n\n    int d = 0;\n    vec4 data[triangleList.length()*4/3];\n\n    // the compiler will choke if we try to generate all this in one pass\n    // so only do one sub-triangle of each face at a time\n    int sub = min(iFrame,subs);\n    // iFrame/2 because double buffering was causing me some problems with discard\n    // not sure this is still a problem but I like the slowed down generations\n    \n    float r = 1./float(1<<sub2);\n    float a = float(sub&((1<<sub2)-1))*r;\n    float b = float(sub>>sub2)*r;\n    if ( a + b >= 1. )\n    {\n        r = -r;\n        a = 1.-a;\n        b = 1.-b;\n    }\n\n    for ( int tri = 0; tri < triangleList.length(); tri += 3 )\n    {\n        vec3 u[] = vec3[]( points[triangleList[tri+0]], points[triangleList[tri+1]], points[triangleList[tri+2]] );\n        vec3 v[3];\n\n        // output a sub triangle using barycoords\n        v[0] = u[0]*(1.-a-b)+u[1]*a+u[2]*b;\n        v[1] = u[0]*(1.-a-b-r)+u[1]*(a+r)+u[2]*b;\n        v[2] = u[0]*(1.-a-b-r)+u[1]*a+u[2]*(b+r);\n\n        vec3 off = vec3(0);//float(tri)*.1);\n        v[0] = normalize(v[0]);\n        v[1] = normalize(v[1]);\n        v[2] = normalize(v[2]);\n        v[0] = v[0]*Height(v[0]) + off;\n        v[1] = v[1]*Height(v[1]) + off;\n        v[2] = v[2]*Height(v[2]) + off;\n        vec4 p[] = Triangle(v[0],v[1],v[2]);\n        data[d++] = p[0];\n        data[d++] = p[1];\n        data[d++] = p[2];\n        data[d++] = p[3];\n    }\n\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n\n    // store the data\n    if ( int(fragCoord.x) < 256 )\n    {\n        d = int(fragCoord.x)+int(fragCoord.y)*256;\n        if ( d >= sub*data.length() && d < (sub+1)*data.length() )\n        {\n            fragColor = data[d-sub*data.length()];\n        }\n        else\n        {\n            fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n        }\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const int sub2 = 4; // shared\nconst int triangleCount = (1<<(2*sub2))*20;\n/*\nsub2=3 -> 1280 triangles\nsub2=4 -> 5120 triangles\nsub2=5 -> 20480 triangles\n*/\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}