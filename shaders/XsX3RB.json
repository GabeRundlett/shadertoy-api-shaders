{
    "Shader": {
        "info": {
            "date": "1372830991",
            "description": "An alien volcanic landscape. It started as an experiment on 2d-texture based 3d noise. But then I played with the noise shape, the added some shading, put lighting in it, etc..., until I got this.",
            "flags": 32,
            "hasliked": 0,
            "id": "XsX3RB",
            "likes": 726,
            "name": "Volcanic",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "noise",
                "distancefield"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 198628
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 data = textureLod( iChannel0, uv, 0.0 );\n\n    vec3 col = vec3(0.0);\n    \n    if( data.w < 0.0 )\n    {\n        col = textureLod( iChannel0, uv, 0.0 ).xyz;\n    }\n    else\n    {\n        // decompress velocity vector\n        float ss =   mod(data.w,1024.0)/1023.0;\n        float st = floor(data.w/1024.0)/1023.0;\n\n        // motion blur (linear blur across velocity vectors)\n        vec2 dir = (2.0*vec2(ss,st)-1.0)*0.25;\n        float tot = 0.0;\n        for( int i=0; i<32; i++ )\n        {\n            float h = float(i)/31.0;\n            vec2  p = uv + dir*h;\n            float w = 1.0-h;\n            col += w*textureLod( iChannel0, p, 0.0 ).xyz;\n            tot += w;\n        }\n        col /= tot;\n    }\n\n    // vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define HIGH_QUALITY_NOISE\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n#else\n\tvec2 uv  = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = textureLod( iChannel0, (uv+ vec2(0.5,0.5))/256.0, 0.0 ).yx;\n\tvec2 rg2 = textureLod( iChannel0, (uv+ vec2(1.5,0.5))/256.0, 0.0 ).yx;\n\tvec2 rg3 = textureLod( iChannel0, (uv+ vec2(0.5,1.5))/256.0, 0.0 ).yx;\n\tvec2 rg4 = textureLod( iChannel0, (uv+ vec2(1.5,1.5))/256.0, 0.0 ).yx;\n\tvec2 rg  = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn textureLod( iChannel0, (uv+118.4)/256.0, 0.0 ).x;\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat fbm4( in vec3 q )\n{\n    float f  = 0.5000*noise( q ); q = m*q*2.02;\n          f += 0.2500*noise( q ); q = m*q*2.03;\n          f += 0.1250*noise( q ); q = m*q*2.01;\n          f += 0.0625*noise( q );\n    return f;\n}\n    \nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\treturn texture( sam, p.yz )*abs(n.x) +\n           texture( sam, p.zx )*abs(n.y) +\n           texture( sam, p.xy )*abs(n.z);\n}\n\n//=====================================================================\n\nfloat lava( in vec2 p )\n{\n\tp += vec2(2.0,4.0);\n    float f  = 0.5000*noise( p ); p = p*2.02;\n          f += 0.2500*noise( p ); p = p*2.03;\n          f += 0.1250*noise( p ); p = p*2.01;\n          f += 0.0625*noise( p );\n    return f;\n}\n\nfloat displacement( in vec3 p )\n{\n    float dis = textureLod( iChannel2, p.xz, 0.0 ).x;\n    return fbm4(p+vec3(1.0,0.0,0.8)) - dis*0.01;\n}\n\nfloat mapTerrain( in vec3 pos )\n{\n\treturn pos.y*0.1 + (displacement(pos*vec3(0.8,1.0,0.8)) - 0.4)*(1.0-smoothstep(1.0,3.0,pos.y));\n}\n\nfloat raymarchTerrain( in vec3 ro, in vec3 rd )\n{\n    // bounding plane\n    const float hmax = 1.9;\n    float tp = (hmax-ro.y)/rd.y;\n    float tmax = (tp<0.0)?30.0:tp;\n\n    // raymarch\n    float t = 0.1;\n    for( int i=0; i<350; i++ )\n    {\n\t    float h = mapTerrain( ro+rd*t );\n        if( abs(h)<(0.00025*t) || t>tmax ) break;\n        t += h*0.8;\n    }\n    return (t>tmax) ? -1.0 : t;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    // bounding plane\n    const float hmax = 1.9;\n    float tp = (hmax-ro.y)/rd.y;\n    float tmax = (tp<0.0)?30.0:tp;\n\n    // raymarch\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<100; i++ )\n    {\n        float h = mapTerrain(ro + rd*t);\n        res = min( res, k*max(h,0.0)/t );\n        t += clamp( h, 0.01, 0.4 );\n\t\tif( res<0.001 || t>tmax ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    float eps = max(0.02,0.001*t);\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapTerrain(pos+e.xyy) + \n\t\t\t\t\t  e.yyx*mapTerrain(pos+e.yyx) + \n\t\t\t\t\t  e.yxy*mapTerrain(pos+e.yxy) + \n\t\t\t\t\t  e.xxx*mapTerrain(pos+e.xxx) );\n}\n\nconst vec3 lig = normalize( vec3(-0.3,0.4,0.7) );\n\nvec4 mapClouds( in vec3 pos )\n{\n\tvec3 q = pos*0.5 + vec3(0.0,-iTime,0.0);\n\t\n\tfloat d = clamp( fbm4(q)-0.55, 0.0, 1.0 );\n\td *= smoothstep( 0.5, 0.55, lava(0.1*pos.xz)+0.01 );\n\t\n\tvec4 res = vec4( d );\n\tres.xyz  = 0.25*mix( vec3(1.0,0.8,0.7), 0.2*vec3(0.4,0.4,0.4), d );\n\tres.xyz *= 0.5 + 0.5*smoothstep(-2.0, 1.0, pos.y);\n\treturn res;\n}\n\nvec4 raymarchClouds( in vec3 ro, in vec3 rd, in vec3 bcol, float tmax, in vec2 px )\n{\n\tvec4 sum = vec4( 0.0 );\n\tfloat sun = pow( clamp( dot(rd,lig), 0.0, 1.0 ), 6.0 );\n\tfloat t = texture(iChannel0,px/256.0).x*0.1;\n\tfor( int i=0; i<60; i++ )\n\t{\n\t\tvec4 col = mapClouds( ro + t*rd );\n\t\t\n        col.xyz += vec3(1.0,0.7,0.4)*0.4*sun*(1.0-col.w);\n\t\tcol.xyz = mix( col.xyz, bcol, 1.0-exp(-0.00006*t*t*t) );\n        col.a *= 2.0;\n\t\tcol.rgb *= col.a;\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n\t\tt += max(0.1,0.05*t);\n\t\tif( t>tmax || sum.w>0.95 ) break;\n\t}\n\tsum.xyz /= (0.001+sum.w);\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nvec3 path( float time )\n{\n\treturn vec3( 16.0*cos(0.2+0.075*time), 1.5, 16.0*sin(0.1+0.0825*time) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid moveCamera( in float time, out vec3 oRo, out vec3 oTa, out float oCr, out float oFl )\n{\n    oFl = 2.1;\n    oCr = 0.3*sin(1.0+0.07*time);\n    oRo = path( time+0.0 );\n    oTa = path( time+1.6 );\n\toTa.y *= 0.35 + 0.25*sin(0.09*time);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\t\n    // camera\t\n\tfloat off = step( 0.001, iMouse.z )*6.0*iMouse.x/iResolution.x;\n    float time = 3.4 + iTime + off;\n    vec3 ro, ta; float cr, fl;\n    moveCamera( time, ro, ta, cr, fl );\n    \n\t// camera2world transform\n    mat3 cam = setCamera( ro, ta, cr );\n\n    // ray    \n    vec3 rd = cam * normalize(vec3(p.xy,fl));\n\n    // sky\t \n    vec3  col = vec3(0.36,0.43,0.54) - rd.y*0.5;\n    float sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tcol += vec3(1.0,0.8,0.4)*0.24*pow( sun, 6.0 );\n\n\tvec3 bcol = col;\n    \n    // terrain\t\n\tfloat t = raymarchTerrain(ro, rd);\n    float st = t;\n    if( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos, t );\n\t\tvec3 ref = reflect( rd, nor );\n\t\t\n        // lighting\n\t\tfloat hhh = 1.0 - smoothstep(-2.0, 1.0, pos.y);\n\t\tfloat sun = clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\tfloat sha = 0.0; if( sun>0.01) sha=softshadow(pos,lig,0.001,32.0);\n\t\tfloat bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\t\tfloat sky = 0.5 + 0.5*nor.y;\n        float lav = smoothstep( 0.5, 0.55, lava(0.1*pos.xz) )*hhh*clamp(0.5-0.5*nor.y,0.0,1.0);\n\t\tfloat occ = pow( (1.0-displacement(pos*vec3(0.8,1.0,0.8)))*1.6-0.5, 2.0 );\n\t\tfloat amb = 1.0;\n        float fre = 1.0+dot(nor,rd); fre = fre*fre;\n\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 1.3*sun*vec3(1.80,1.27,0.99)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += 1.0*sky*vec3(0.16,0.20,0.40)*occ;\n\t\tlin += 1.0*bac*vec3(0.40,0.28,0.20)*occ;\n\t\tlin += 1.0*amb*vec3(0.15,0.17,0.20)*occ;\n\t\tlin += lav*vec3(3.00,0.61,0.00);\n\n        // surface shading/material\t\t\n        vec3 te = texcube( iChannel1, 0.5*pos, nor ).xyz;\n\t\tcol = te;\n\t\tcol = col*(0.2+0.8*texcube( iChannel2, 4.0*vec3(2.0,8.0,2.0)*pos, nor ).x);\n\n\t\tvec3 lava = vec3(1.0,0.9,0.2);\n\t\tlava *= texture( iChannel2, pos.xz ).xyz;\n\t\tcol = mix( col, 0.8*lava, hhh );\n\t\t\n\t\tvec3 verde = vec3(0.2,0.2,0.05);\n\t\tverde *= 0.2+1.6*texture( iChannel1, 7.1*pos.xz ).xyz;\n\t\tverde += 0.1*texture( iChannel1, 1.0*pos.xz ).xyz;\n        verde *= 1.0+fre*fre;\n\t\tcol = mix( col, verde, smoothstep(0.0, 0.8, nor.y)*smoothstep(0.0, 0.1, pos.y-0.8 ) );\n\t\t\n\t\tcol = lin * col;\n\n        // sun spec\n        vec3 hal = normalize(lig-rd);\n        col += (te.x*te.x)*vec3(11.0,8.0,5.0)*sun*sha*\n               pow( clamp(dot(nor,hal),0.0,1.0), 8.0 ) *\n               (0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n            \n\t\t// atmospheric\n        vec3 ext = exp2(-t*t*0.001*vec3(0.5,1.0,2.0) );\n        col = col*ext + 0.6*(1.0-ext)*(1.0-0.7*hhh);\n    }\n\n    // sun glow\n    col += vec3(1.0,0.6,0.2)*0.2*sun*sun*clamp( (rd.y+0.4)/(0.0+0.4),0.0,1.0);\n\t\n    // smoke\t\n    vec4 res = raymarchClouds( ro, rd, bcol, (t<0.0)?600.0:t, fragCoord );\n\tcol = mix( col, res.xyz, res.w );\n\n    // gain\n    col *= 1.6/(1.0+col);\n    col *= vec3(1.02,1.04,1.0);\n\n    // gamma\t\n\tcol = pow( clamp( col, 0.0, 1.0 ), vec3(0.45) );\n\n    // contrast, desat, tint and vignetting\t\n\tcol = col*col*(3.0-2.0*col);\n\tcol = mix( col, vec3(col.x+col.y+col.z)*0.33, 0.2 );\n      \n    //-------------------------------------\n\t// velocity vectors\n    //-------------------------------------\n    float vel = -1.0;\n    if( st>0.0 )\n    {\n        // old camera position\n        float oldTime = time - 1.0/30.0; // 1/30 of a second blur\n        vec3 oldRo, oldTa; float oldCr, oldFl;\n        moveCamera( oldTime, oldRo, oldTa, oldCr, oldFl );\n        mat3 oldCam = setCamera( oldRo, oldTa, oldCr );\n        // world space\n        vec3 wpos = ro + rd*st;\n        // camera space\n        vec3 cpos = vec3( dot( wpos - oldRo, oldCam[0] ),\n                          dot( wpos - oldRo, oldCam[1] ),\n                          dot( wpos - oldRo, oldCam[2] ) );\n        // ndc space\n        vec2 npos = oldFl * cpos.xy / cpos.z;\n        // screen space\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0);\n        // compress velocity vector in a single float\n        vec2 uv = fragCoord/iResolution.xy;\n        spos = clamp( 0.5 + 0.5*(spos - uv)/0.25, 0.0, 1.0 );\n        vel = floor(spos.x*1023.0) + floor(spos.y*1023.0)*1024.0;\n    }\n\n    fragColor = vec4( col, vel );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}