{
    "Shader": {
        "info": {
            "date": "1464947226",
            "description": "Create landscapes; if control panel not visible click on ring; see source for more details. ",
            "flags": 32,
            "hasliked": 0,
            "id": "MdyXRG",
            "likes": 24,
            "name": "Terrain Explorer",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "interactive",
                "landscape"
            ],
            "usePreview": 1,
            "username": "dr2",
            "viewed": 1634
        },
        "renderpass": [
            {
                "code": "// \"Terrain Explorer\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Control panel appears when yellow ring (or a hidden control) clicked; panel fades\n  automatically; use mouse to look around.\n\n  Height functions based on the following (1-3 have additional spatial modulation):\n    1) Basic fBm.\n    2) Modified fBm in 'Elevated' by iq.\n    3) Inverted abs(sin & cos) waves simplified from 'Seascape' by TDM.\n    4) Weird forms from 'Sirenian Dawn' by nimitz.\n\n  Sliders (from left):\n    Overall height scale.\n    Lacunarity - rate of fBm length scale change per iteration.\n    Persistence - rate of fBm amplitude change per iteration.\n    Variable spatial modulation (shaders 1 & 2), or feature sharpness (3 & 4).\n    Flight speed.\n\n  Buttons (from left):\n    Height function choice.\n    Distance marching accuracy and range (affects update rate).\n    Shadows and sun elevation.\n\n  There is no end to the functionality that can be added...\n  (NB Shader length is under 0.1 KTweet.)\n*/\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nfloat Noisefv2 (vec2 p);\nvec3 Noisev3v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nmat3 AxToRMat (vec3 vz, vec3 vy);\nvec2 Rot2D (vec2 q, float a);\nvec4 Loadv4 (int idVar);\n\nconst float pi = 3.14159;\n\nvec3 sunDir;\nfloat tCur, dstFar, hFac, fWav, aWav, smFac, stepFac;\nint grType, qType, shType, stepLim;\nconst mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n\nvec3 SkyBg (vec3 rd)\n{\n  return vec3 (0.2, 0.3, 0.55) + 0.25 * pow (1. - max (rd.y, 0.), 8.);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float f;\n  ro.xz += 0.5 * tCur;\n  f = Fbm2 (0.1 * (ro + rd * (50. - ro.y) / rd.y).xz);\n  return mix (SkyBg (rd) + 0.35 * pow (max (dot (rd, sunDir), 0.), 16.),\n     vec3 (0.85), clamp (0.8 * f * rd.y + 0.1, 0., 1.));\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (20. * sin (0.07 * t) * sin (0.022 * t) * cos (0.018 * t) +\n     13. * sin (0.0061 * t), 0., t);\n}\n\nfloat GrndHt1 (vec2 p)\n{\n  vec2 q;\n  float f, wAmp;\n  q = 0.1 * p;\n  f = 0.;\n  wAmp = 1.;\n  for (int j = 0; j <= 4; j ++) {\n    f += wAmp * Noisefv2 (q);\n    wAmp *= aWav;\n    q *= fWav * qRot;\n  }\n  return min (5. * Noisefv2 (0.033 * smFac * p) + 0.5, 4.) * f;\n}\n\nfloat GrndHt2 (vec2 p)\n{\n  vec3 v;\n  vec2 q, t;\n  float wAmp, f;\n  q = 0.1 * p;\n  wAmp = 1.;\n  t = vec2 (0.);\n  f = 0.;\n  for (int j = 0; j <= 3; j ++) {\n    v = Noisev3v2 (q);\n    t += v.yz;\n    f += wAmp * v.x / (1. + dot (t, t));\n    wAmp *= aWav;      \n    q *= fWav * qRot;\n  }\n  return min (5. * Noisefv2 (0.033 * smFac * p) + 0.5, 4.) * f;\n}\n\nfloat GrndHt3 (vec2 p)\n{\n  vec2 q, t, ta, v;\n  float wAmp, pRough, f;\n  q = 0.1 * p;\n  wAmp = 0.3;\n  pRough = 1.;\n  f = 0.;\n  for (int j = 0; j <= 2; j ++) {\n    t = q + 2. * Noisefv2 (q) - 1.;\n    ta = abs (sin (t));\n    v = (1. - ta) * (ta + abs (cos (t)));\n    v = pow (1. - v, vec2 (pRough));\n    f += (v.x + v.y) * wAmp;\n    q *= fWav * qRot;\n    wAmp *= aWav;\n    pRough = smFac * pRough + 0.2;\n  }\n  return min (5. * Noisefv2 (0.033 * p) + 0.5, 4.) * f;\n}\n\nfloat GrndHt4 (vec2 p)\n{\n  vec3 v;\n  vec2 q, t;\n  float wAmp, b, sp, f;\n  q = 0.1 * p;\n  wAmp = 1.;\n  t = vec2 (0.);\n  f = 0.;\n  sp = 0.;\n  for (int j = 0; j <= 3; j ++) {\n    v = Noisev3v2 (q);\n    t += pow (abs (v.yz), vec2 (5. - 0.5 * sp)) - smoothstep (0., 1., v.yz);\n    f += wAmp * v.x / (1. + dot (t, t));\n    wAmp *= - aWav * pow (smFac, sp);\n    q *= fWav * qRot;\n    ++ sp;\n  }\n  b = 0.5 * (0.5 + clamp (f, -0.5, 1.5));\n  return 3. * f / (b * b * (3. - 2. * b) + 0.5) + 1.;\n}\n\nfloat GrndHt (vec2 p)\n{\n  float ht;\n  if      (grType == 1) ht = GrndHt1 (p);\n  else if (grType == 2) ht = GrndHt2 (p);\n  else if (grType == 3) ht = GrndHt3 (p);\n  else if (grType == 4) ht = GrndHt4 (p);\n  return hFac * ht;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j <= 300; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += stepFac * (max (0.4, 0.6 * h) + 0.008 * s);\n    if (s > dstFar || j == stepLim) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j <= 4; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - GrndHt (p.xz));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  float ht;\n  e = vec2 (0.01, 0);\n  ht = GrndHt (p.xz);\n  return normalize (vec3 (ht - GrndHt (p.xz + e.xy), e.x,\n     ht - GrndHt (p.xz + e.yx)));\n}\n\nfloat GrndSShadow (vec3 p, vec3 vs)\n{\n  vec3 q;\n  float sh, d;\n  sh = 1.;\n  d = 0.4;\n  for (int j = 0; j <= 25; j ++) {\n    q = p + vs * d; \n    sh = min (sh, smoothstep (0., 0.02 * d, q.y - GrndHt (q.xz)));\n    d += max (0.4, 0.1 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstGrnd, f, spec, sh;\n  dstGrnd = GrndRay (ro, rd);\n  if (dstGrnd < dstFar) {\n    ro += dstGrnd * rd;\n    vn = GrndNf (ro);\n    f = 0.2 + 0.8 * smoothstep (0.7, 1.1, Fbm2 (1.7 * ro.xz));\n    col = mix (mix (vec3 (0.2, 0.35, 0.1), vec3 (0.1, 0.3, 0.15), f),\n       mix (vec3 (0.3, 0.25, 0.2), vec3 (0.35, 0.3, 0.3), f),\n       smoothstep (1., 3., ro.y));\n    col = mix (vec3 (0.4, 0.3, 0.2), col, smoothstep (0.2, 0.6, abs (vn.y)));\n    col = mix (col, vec3 (0.75, 0.7, 0.7), smoothstep (5., 8., ro.y));\n    col = mix (col, vec3 (0.9), smoothstep (7., 9., ro.y) *\n       smoothstep (0., 0.5, abs (vn.y)));\n    spec = mix (0.1, 0.5, smoothstep (8., 9., ro.y));\n    vn = VaryNf (2. * ro, vn, 1.5);\n    sh = (shType > 1) ? GrndSShadow (ro, sunDir) : 1.;\n    col *= 0.2 + 0.1 * vn.y + 0.7 * sh * max (0., max (dot (vn, sunDir), 0.)) +\n       spec * sh * pow (max (0., dot (sunDir, reflect (rd, vn))), 16.);\n    f = dstGrnd / dstFar;\n    f *= f;\n    col = mix (col, SkyBg (rd), clamp (f * f, 0., 1.));\n  } else col = SkyCol (ro, rd);\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nmat3 EvalOri (vec3 v, vec3 a)\n{\n  vec3 g, w;\n  float f, c, s;\n  v = normalize (v);\n  g = cross (v, vec3 (0., 1., 0.));\n  if (g.y != 0.) {\n    g.y = 0.;\n    w = normalize (cross (g, v));\n  } else w = vec3 (0., 1., 0.);\n  f = v.z * a.x - v.x * a.z;\n  f = - clamp (2. * f, -0.2 * pi, 0.2 * pi);\n  c = cos (f);\n  s = sin (f);\n  return mat3 (c, - s, 0., s, c, 0., 0., 0., 1.) * AxToRMat (v, w);\n}\n\nvec4 ShowWg (vec2 uv, vec2 canvas, vec4 parmV1, vec4 parmV2)\n{\n  vec4 wgBx[8];\n  vec3 col, cc;\n  vec2 ut, ust;\n  float vW[8], asp, s;\n  cc = vec3 (1., 0., 0.);\n  asp = canvas.x / canvas.y;\n  for (int k = 0; k <= 4; k ++)\n     wgBx[k] = vec4 ((0.25 + 0.05 * float (k)) * asp, 0., 0.014 * asp, 0.18);\n  for (int k = 5; k <= 7; k ++)\n     wgBx[k] = vec4 ((0.3 + 0.05 * float (k - 5)) * asp, -0.3, 0.024, 0.024);\n  vW[0] = parmV1.x;  vW[1] = parmV1.y;  vW[2] = parmV1.z;  vW[3] = parmV1.w;\n  vW[4] = parmV2.x;  vW[5] = parmV2.y;  vW[6] = parmV2.z;  vW[7] = parmV2.w;\n  col = vec3 (0.);\n  for (int k = 0; k <= 4; k ++) {\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw * vec2 (0.7, 1.);\n    if (max (ust.x, ust.y) < 0.) {\n      if  (min (abs (ust.x), abs (ust.y)) * canvas.y < 2.) col = 0.3 * cc.xxy;\n      else col = (mod (0.5 * ((0.5 * uv.y - wgBx[k].y) / wgBx[k].w - 0.99), 0.1) *\n         canvas.y < 6.) ? 0.3 * cc.xxy : 0.6 * cc.xxy;\n    }\n    ut.y -= (vW[k] - 0.5) * 2. * wgBx[k].w;\n    s = ShowInt (ut - vec2 (0.018, -0.01), 0.02 * vec2 (asp, 1.), 2.,\n       clamp (floor (100. * vW[k]), 0., 99.));\n    if (s > 0.) col = (k < 4) ? cc.yxy : cc;\n    ut = abs (ut) * vec2 (1., 1.5);\n    if (max (abs (ut.x), abs (ut.y)) < 0.025 && max (ut.x, ut.y) > 0.02) col = cc.xxy;\n  }\n  for (int k = 5; k <= 7; k ++) {\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw;\n    if (max (ust.x, ust.y) < 0.) {\n      if  (min (abs (ust.x), abs (ust.y)) * canvas.y < 2.) col = cc.xxy;\n      else col = 0.6 * cc.xxy;\n    }\n    s = ShowInt (ut - vec2 (0.015, -0.01), 0.02 * vec2 (asp, 1.), 1., vW[k]);\n    if (s > 0.) col = (k == 5) ? cc.yxy : ((k == 6) ? cc : cc.yyx);;\n  }\n  return vec4 (col, step (0.001, length (col)));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 flMat, vuMat;\n  vec4 stDat, wgBxC, parmV1, parmV2, c4;\n  vec3 ro, rd, col, flPos, fpF, fpB, cw;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, asp, dt, tCur, tCurM, mvTot, h, hSum, nhSum, cm;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  asp = canvas.x / canvas.y;\n  wgBxC = vec4 (0.45 * asp, -0.4, 0.022, 0.);\n  parmV1 = Loadv4 (0);\n  hFac = 1. + parmV1.x;\n  fWav = 1.5 + 0.7 * parmV1.y;\n  aWav = 0.1 + 0.5 * parmV1.z;\n  smFac = 0.3 + 0.7 * parmV1.w;\n  parmV2 = Loadv4 (1);\n  grType = int (parmV2.y);\n  qType = int (parmV2.z);\n  shType = int (parmV2.w);\n  stDat = Loadv4 (2);\n  el = stDat.x;\n  az = stDat.y;\n  tCur = stDat.z;\n  tCurM = stDat.w;\n  stDat = Loadv4 (3);\n  mvTot = stDat.x;\n  if (qType == 1) {\n    dstFar = 170.;\n    stepLim = 100;\n    stepFac = 1.;\n  } else if (qType == 2) {\n    dstFar = 200.;\n    stepLim = 200;\n    stepFac = 0.5;\n  } else if (qType == 3) {\n    dstFar = 240.;\n    stepLim = 300;\n    stepFac = 0.33;\n  }\n  if (shType == 1) sunDir = normalize (vec3 (1., 2., 1.));\n  else if (shType == 2) sunDir = normalize (vec3 (1., 1.5, 1.));\n  else if (shType == 3) sunDir = normalize (vec3 (1., 1., 1.));\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 3.));\n  flPos = TrackPath (mvTot);\n  dt = 1.;\n  fpF = TrackPath (mvTot + dt);\n  fpB = TrackPath (mvTot - dt);\n  flMat = EvalOri ((fpF - fpB) / (2. * dt), (fpF - 2. * flPos + fpB) / (dt * dt));\n  ro.xz = flPos.xz;\n  hSum = 0.;\n  nhSum = 0.;\n  dt = 0.3;\n  for (float fk = -2.; fk <= 10.; fk ++) {\n    hSum += GrndHt (TrackPath (mvTot + fk * dt).xz);\n    ++ nhSum;\n  }\n  ro.y = 4. * hFac + hSum / nhSum;\n  rd = rd * flMat;\n  col = ShowScene (ro, rd);\n  if (canvas.y < 200. || tCur - tCurM < 5.) {\n    c4 = ShowWg (uv, canvas, parmV1, parmV2);\n    cw = mix (col, c4.rgb, c4.a);\n    cm = (canvas.y < 200.) ? 0.3 : 0.2 + 0.8 * smoothstep (4., 5., tCur - tCurM);\n  } else {\n    cw = vec3 (0.7, 0.7, 0.);\n    cm = 0.3 + 0.7 * step (2., abs (length (0.5 * uv - wgBxC.xy) -\n       wgBxC.z) * canvas.y);\n  }\n  fragColor = vec4 (mix (cw, col, cm), 1.);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv < 5) {\n    if (iv == -1) k = 8;\n    else if (iv == 0) k = 119;\n    else if (iv == 1) k = 36;\n    else if (iv == 2) k = 93;\n    else if (iv == 3) k = 109;\n    else k = 46;\n  } else {\n    if (iv == 5) k = 107;\n    else if (iv == 6) k = 122;\n    else if (iv == 7) k = 37;\n    else if (iv == 8) k = 127;\n    else k = 47;\n  }\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx - vo);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy - vp);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy - vm);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy + vm);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy + vp);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (sgn < 0.) {\n      if (idChar == mxChar - nDig - 1.) s = ShowDig (q, -1);\n      else ++ v;\n    }\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i <= 4; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec4 s, t;\n  vec2 ip, fp, u;\n  ip = floor (p);\n  fp = fract (p);\n  u = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  s = vec4 (t.y - t.x, t.w - t.z, t.z - t.x, t.x - t.y + t.w - t.z);\n  return vec3 (t.x + s.x * u.x + s.z * u.y + s.w * u.x * u.y,\n     30. * fp * fp * (fp * fp - 2. * fp + 1.) * (s.xz + s.w * u.yx));\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i <= 4; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nmat3 AxToRMat (vec3 vz, vec3 vy)\n{\n  vec3 vx;\n  vx = normalize (cross (vy, vz));\n  vy = cross (vz, vx);\n  return mat3 (vec3 (vx.x, vy.x, vz.x), vec3 (vx.y, vy.y, vz.y),\n     vec3 (vx.z, vy.z, vz.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Terrain Explorer\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst float pi = 3.14159;\nconst float txRow = 32.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[9], mPtr, mPtrP, stDat, parmV1, parmV2;\n  vec2 iFrag, canvas, ust;\n  float tCur, tCurP, tCurM, vW, asp, el, az, flyVel, mvTot;\n  int pxId, wgSel, wgReg, kSel, grType, qType, shType;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 5) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  wgSel = -1;\n  wgReg = -2;\n  asp = canvas.x / canvas.y;\n  el = -0.1;\n  az = 0.;\n  if (iFrame <= 5) {\n    parmV1 = vec4 (0.6, 0.6, 0.7, 0.5);\n    parmV2 = vec4 (0.3, 1., 2., 1.);\n    mvTot = 0.;\n    mPtrP = mPtr;\n    tCurP = tCur;\n    tCurM = tCur;\n  } else {\n    parmV1 = Loadv4 (0);\n    parmV2 = Loadv4 (1);\n    flyVel = parmV2.x;\n    stDat = Loadv4 (2);\n    tCurP = stDat.z;\n    tCurM = stDat.w;\n    stDat = Loadv4 (3);\n    mvTot = stDat.x;\n    mvTot += 8. * flyVel * (tCur - tCurP);\n    stDat = Loadv4 (4);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n  }\n  if (mPtr.z > 0.) {\n    for (int k = 0; k <= 4; k ++)\n       wgBx[k] = vec4 ((0.25 + 0.05 * float (k)) * asp, 0., 0.014 * asp, 0.18);\n    for (int k = 5; k <= 7; k ++)\n       wgBx[k] = vec4 ((0.3 + 0.05 * float (k - 5)) * asp, -0.3, 0.024, 0.024);\n    wgBx[8] = vec4 (0.45 * asp, -0.4, 0.022, 0.);\n    for (int k = 0; k <= 7; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    ust = mPtr.xy * vec2 (asp, 1.) - wgBx[8].xy;\n    if (length (ust) < wgBx[8].z) wgReg = 8;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n    if (wgSel >= 0) tCurM = tCur;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      az = 2. * pi * mPtr.x;\n      el = 0.8 * pi * mPtr.y;\n    }\n  } else {\n    if (wgSel < 5) {\n      for (int k = 0; k <= 4; k ++) {\n        if (wgSel == k) {\n          kSel = k;\n          vW = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0., 0.99);\n          break;\n        }\n      }\n      if      (kSel == 0) parmV1.x = vW;\n      else if (kSel == 1) parmV1.y = vW;\n      else if (kSel == 2) parmV1.z = vW;\n      else if (kSel == 3) parmV1.w = vW;\n      else if (kSel == 4) parmV2.x = vW;\n    } else if (mPtrP.z <= 0.) {\n      if (wgSel == 5) {\n        grType = int (parmV2.y);\n        if (++ grType >= 5) grType = 1;\n        parmV2.y = float (grType);\n      } else if (wgSel == 6) {\n        qType = int (parmV2.z);\n        if (++ qType >= 4) qType = 1;\n        parmV2.z = float (qType);\n      } else if (wgSel == 7) {\n        shType = int (parmV2.w);\n        if (++ shType >= 4) shType = 1;\n        parmV2.w = float (shType);\n      }\n    }\n  }\n  if (canvas.y < 200.) parmV2.y = floor (mod (tCur, 40.) / 10.) + 1.;\n  if      (pxId == 0) stDat = parmV1;\n  else if (pxId == 1) stDat = parmV2;\n  else if (pxId == 2) stDat = vec4 (el, az, tCur, tCurM);\n  else if (pxId == 3) stDat = vec4 (mvTot, 0., 0., 0.);\n  else if (pxId == 4) stDat = vec4 (mPtr.xyz, float (wgSel));\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}