{
    "Shader": {
        "info": {
            "date": "1507404465",
            "description": "TLW countdown",
            "flags": 0,
            "hasliked": 0,
            "id": "MlBcz1",
            "likes": 5,
            "name": "The Long Way Countdown",
            "published": 3,
            "tags": [
                "nixiecountdown"
            ],
            "usePreview": 0,
            "username": "Sgw32",
            "viewed": 674
        },
        "renderpass": [
            {
                "code": "#define SHOW_GRID\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\nconst float scale = 1.0 / 6.0;\n\nvec2 digitSize = vec2(1.0,1.5) * scale;\nvec2 digitSpacing = vec2(1.1,1.6) * scale;\n\n\n\n\n#define PI\t3.14159265359\n#define SIZE 3.\n\n#define S(t) tan(t.x*0.4+0.7)\n\nfloat hash(in vec3 p)\n{\n\treturn fract(sin(dot(p,vec3(283.6,127.1,311.7))) * 43758.5453);\n}\n\nfloat noise(vec3 p, vec3 fft, vec3 wav){\n\tp.y -= iTime * 2. + 2. * fft.x * fft.y;\n\tp.z += iTime * .4 - fft.z;\n\tp.x += 2. * cos(wav.y);\n\t\n    vec3 i = floor(p);\n\tvec3 f = fract(p); \n\tf *= f * (3.-2.*f);\n    \n    vec2 c = vec2(0,1);\n\n    return mix(\n\t\tmix(mix(hash(i + c.xxx), hash(i + c.yxx),f.x),\n\t\t\tmix(hash(i + c.xyx), hash(i + c.yyx),f.x),\n\t\t\tf.y),\n\t\tmix(mix(hash(i + c.xxy), hash(i + c.yxy),f.x),\n\t\t\tmix(hash(i + c.xyy), hash(i + c.yyy),f.x),\n\t\t\tf.y),\n\t\tf.z);\n}\n\nfloat fbm(vec3 p, vec3 fft, vec3 wav)\n{\n\treturn .5000 * noise(1. * p, fft, wav) \n\t\t + .2500 * noise(2. * p, fft, wav)\n\t     + .1250 * noise(4. * p, fft, wav)\n\t     + .0625 * noise(8. * p, fft, wav);\n}\n\nfloat rand2(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise2(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand2(b), rand2(b + d.yx), f.x), mix(rand2(b + d.xy), rand2(b + d.yy), f.x), f.y);\n}\n\nfloat fbm2(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i < 7; i++) {\n        total += noise2(n) * amplitude;\n        n += n;\n        amplitude *= 0.5;\n    }\n    return total;\n}\n\n\n//Distance to a line segment,\nfloat dfLine(vec2 start, vec2 end, vec2 uv)\n{\n\tstart *= scale;\n\tend *= scale;\n    \n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\n\n//Distance to the edge of a circle.\nfloat dfCircle(vec2 origin, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\treturn abs(length(uv - origin) - radius);\n}\n\n//Distance to an arc.\nfloat dfArc(vec2 origin, float start, float sweep, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\tuv -= origin;\n\tuv *= mat2(cos(start), sin(start),-sin(start), cos(start));\n\t\n\tfloat offs = (sweep / 2.0 - pi);\n\tfloat ang = mod(atan(uv.y, uv.x) - offs, tau) + offs;\n\tang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n\t\n\treturn distance(radius * vec2(cos(ang), sin(ang)), uv);\n}\n\n//Distance to the digit \"d\" (0-9).\nfloat dfDigit(vec2 origin, float d, vec2 uv)\n{\n\tuv -= origin;\n\td = floor(d);\n\tfloat dist = 1e6;\n\t\n\tif(d == 0.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.000), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,1.000), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 3.142, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 1.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.500,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 2.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,0.000), vec2(0.000,0.000), uv));\n\t\tdist = min(dist, dfLine(vec2(0.388,0.561), vec2(0.806,0.719), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.700,1.000),5.074, 1.209, 0.300, uv));\n\t\tdist = min(dist, dfArc(vec2(0.600,0.000),1.932, 1.209, 0.600, uv));\n\t\treturn dist;\n\t}\n\tif(d == 3.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,1.000), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 4.712, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 4.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.700,1.500), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,0.500), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.700,1.200), vec2(0.700,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 5.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.300,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.300,1.500), vec2(0.200,0.900), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 5.356, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 6.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.067,0.750), vec2(0.500,1.500), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.500), 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 7.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 8.0)\n\t{\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.400), 0.400, uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.150), 0.350, uv));\n\t\treturn dist;\n\t}\n\tif(d == 9.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.933,0.750), vec2(0.500,0.000), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.000), 0.500, uv));\n\t\treturn dist;\n\t}\n\n\treturn dist;\n}\n\n//Distance to a number\nfloat dfNumber(vec2 origin, float num, vec2 uv)\n{\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 1.0;\n\t\n\tfor(float i = 5.0;i > -1.0;i--)\n\t{\t\n\t\tfloat d = floor(mod(num / pow(10.000001,i),10.));\n\t\t\n\t\tvec2 pos = digitSpacing * vec2(offs,0.0);\n\n\t\tif(i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfCircle(vec2(offs+0.9,0.1)*1.1, 0.04,uv));\n\t\t}\n\t\t\n\t\tif(num > pow(10.0,i) || i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfDigit(pos, d, uv));\n\t\t\toffs++;\n\t\t}\t\n\t}\n\treturn dist;\t\n}\n\n//Length of a number in digits\nfloat numberLength(float n)\n{\n\treturn floor(max(log(n) / log(10.0), 0.0) + 1.0) + 2.0;\n}\n\n\nvec4 tlwnoise(vec2 fragCoord)\n{\n    vec3 fft = vec3(S(vec2(.0,.25)),S(vec2(.5,.25)),S(vec2(1.,.25)));\n\tvec3 wav = vec3(S(vec2(.0,.75)),S(vec2(.5,.75)),S(vec2(1.,.75)));\n\tfloat t  = cos(fft.x * 2. / PI);\n\tfloat ct = cos(t);\n\tfloat st = sin(t);\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 vc = (2. * uv - 1.) * vec2(iResolution.x / iResolution.y, 1.);\n\t\n\tvc = vec2(vc.x * ct - vc.y * st\n\t\t\t ,vc.y * ct + vc.x * st);\n\n\tvec3 rd = normalize(vec3(.5, vc.x, vc.y));\n\tvec3 c = 2. * vec3(fbm(rd, fft, wav)) * fft.xyz;\n\tc += hash(hash(uv.xyy) * uv.xyx * iTime) * .2;;\n\tc *= .2 * smoothstep(length(uv * .5 - .25), .7, .4);\n\tc = c.xyz*1.;\n    c.x*=2.;\n    c.x*=1.5;\n    c.z*=0.1;\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n    // calculate angle of current pixel from origin\n    // atan return values are in [-pi/2, pi/2]\n    // original tutorial uses function atan(p.y, p.x) which gives a horizontal line\n    // in left middle as artefact so i will keep this\n    \n    float a = 0.;\n    if (abs(p.y)<abs(p.x))\n    \ta = acos(p.y/p.x);\n    \n    // distance of point from origin\n    float r = length(p);\n\n    // note that uv are from lower left corner and should be in 0-1\n    // r is in range [0, sqrt(2)]\n    // a is in range [-pi/2, pi/2] so y will be in range [-1/2, 1/2]\n    // 3.1416 = pi\n    // note that texture is mapped twice devided by a horizontal line\n    // spent hours trying to visualize below two line.. no luck ! :-/ :'(\n    uv.x = .2/r; \n    uv.y = a/(3.1416);\n    \n    // add global time for a moving tunnel\n    uv.x = uv.x + iTime/2.0;\n    \n    \n    \n    vec4 col = vec4(0,0,0,1);\n    //vec2 uv = (vec2(atan(p.y,p.x), .2/cc.w))*cc.w;\n   //uv = fragCoord.xy * 1.0 / iResolution.xy;\n   \n    // draw a line, left side is fixed\n    vec2 tq = uv * vec2(2.0,1.0) - iTime*3.0;\n    vec2 t2 = (vec2(1,-1) + uv) * vec2(2.0,1.0) - iTime*3.0; // a second strand\n   \n    // draw the lines,\n//  this make the left side fixed, can be useful\n//  float ycenter = mix( 0.5, 0.25 + 0.25*fbm( t ), uv.x*4.0);\n//    float ycenter2 = mix( 0.5, 0.25 + 0.25*fbm( t2 ), uv.x*4.0);\n    float ycenter = fbm2(tq)*0.5;\n    float ycenter2= fbm2(t2)*0.5;\n\n    // falloff\n    float diff = abs(uv.y - ycenter);\n    float c1 = 0.;\n    c1 = 1.0 - mix(diff*10.0,1.0,0.5);\n   \n    float diff2 = abs(uv.y - ycenter2);\n    float c2 = 1.0 - mix(0.,1.0,diff2*20.0);\n   \n    float c3 = max(c1,c2);\n    if (c3<0.)\n        c3=0.;\n    if (c2<0.)\n        c2=0.;\n    if (c1<0.)\n        c1=0.;\n    \n    col = vec4(c3*0.7,0.4*c3,0.1*c3,1.0); // purple color\n    \n    float time = iTime;\n    time = mod(time, 5.);\n    uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n    \n    \n\tfloat piikit  = 0.5+asin(sin(SIZE*uv.x*6.28))/5.;\n    \n    \n    if (uv.x<(1./(SIZE)))\n    {\n            piikit=0.5;\n    }  \n    \n    \n    if (uv.x>(1.-1./(SIZE)))\n    {\n            piikit=0.5;\n    }    \n    \n    float x1 = uv.x*2.;\n    //float xt = time/10.;\n    float pos = 2.+8.*pow(time,4.);\n   \n    //xx=-pow(xx,2.);\n    \n    //piikit=1.-exp(xx);\n    \n\tfloat flash = 1.;\n                \n\tfloat glow = (flash*0.02)/abs(piikit - uv.y);\n                \n\tcolor = vec3(glow*0.5, glow*0.5, 0);\n\tcolor += vec3(sqrt(glow*0.2));\n    return col + vec4(c,1.)+vec4(color,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y - aspect/2.0;\n\t\n\tfloat n = 27.-iDate.z;//+max(0.,0.24-iDate.w/100000.)-1.;\n\t\n\tfloat nsize = numberLength(n);\n\t\n\tvec2 pos = -digitSpacing * vec2(nsize,1.0)/2.0;\n\n\tfloat dist = 1e6;\n\tdist = min(dist, dfNumber(pos, n, uv));\n\t\n\tvec3 color = vec3(0);\n\t\n\tfloat shade = 0.0;\n\t\n\tshade = 0.004 / (dist);\n\t\n\tcolor += vec3(1,0.2,0) * shade;\n    \n    #ifdef SHOW_GRID\n    float grid = 0.5-max(abs(mod(uv.x*64.0,1.0)-0.5), abs(mod(uv.y*64.0,1.0)-0.5));\n    \n    color *= 0.25+vec3(smoothstep(0.0,64.0 / iResolution.y,grid))*0.75;\n    #endif\n\t\n\tfragColor = tlwnoise(fragCoord)+vec4( color , 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}