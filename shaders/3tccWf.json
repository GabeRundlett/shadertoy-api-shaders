{
    "Shader": {
        "info": {
            "date": "1609987591",
            "description": "3D Wythoffian uniform honeycombs and their duals in Euclidean space, a flythrough version.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tccWf",
            "likes": 27,
            "name": "Uniform 3D Euclidean Honeycombs",
            "published": 3,
            "tags": [
                "3d",
                "geometry",
                "honeycomb",
                "coxeter",
                "group",
                "tiling",
                "euclidean",
                "symmetry",
                "lattice"
            ],
            "usePreview": 1,
            "username": "neozhaoliang",
            "viewed": 2207
        },
        "renderpass": [
            {
                "code": "/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nUniform honeycombs and their duals\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis program draws uniform honeycombs and their duals in 3D Euclidean space.\n\nYou can learn more about these honeycombs on the Wikipedia page for convex\nuniform honeycombs:\n\n    https://en.wikipedia.org/wiki/Convex_uniform_honeycomb\n\nThe main rendering procedure is based on the work of @shane:\n\n    https://www.shadertoy.com/view/4l2cD3.\n    \nI particularly like the metallic effects in many of his examples.\n\nThe honeycomb data is taken from @mla's work at\n\n    https://www.shadertoy.com/view/WsfcRn.\n    \nI'm also grateful to @mla for helpful discussions.\n\n@mla's code is a great reference for the general Wythoff construction,\nwhich saved me a lot of hard (and even boring) computations.\nIf you have any difficulty understanding this code, I recommend referring to\n@mla's version, as the ideas are the same.\n\nThe trickiest part of this program is to render the octagonal edges\n(or other prism-like shapes) instead of just cylinder edges.\nThis is due to the fact that Wythoff construction may change the distance\nbetwwen a point and the cell edges: In the Wythoff construction, one need to\nreflect a point P across the mirrors repeatly until it falls within a certain\nregion, known as the \"fundamental domain\". Say its final location in the fundamental\ndomain is Q. In the cases that edges have prism-like shapes, the distances d(P, edges)\nand d(Q, edges) may not be equal. This results in annoying artifacts in the final image.\nIt took me 90% of the time to figure out how to tackle this. My solution is\nbrute-force: just render more copies of the fundamental domain. This made the\ncode look ugly and the program take a bit long time to compile, but it worked and\nlooked right in the end.\n*/\n\n// Honeycomb type. 0 for affine A3, 1 for affine B3, 2 for affine C3\n#define LATTICE   1\n\n// Barycentric coordinates of the initial vertex v0 in the fundamental tetrahedron.\n// This determines the truncation type of the honeycomb.\nconst vec4 T = vec4(1, 1, 1, 0);\n\nconst float tbsize = 0.055;\n\n// use another color style\n#define GOLD_STYLE\n\n// render the dual honeycomb?\n//#define DUAL\n\n// initial vertex\nvec3 v0;\n\n// M is the four reflection mirrors of the fundamental tetrahedron,\n// M_inv is the inverse of M.\nmat4 M, M_inv;\n\n// The four vertices of the fundamental tetrahedron and the four mirror images of v0 about\n// the four mirrors\nmat4x3 V, E;\n\n// object id\nvec3 objIDs;\n\nfloat glow;\n\nvec3 do_reflect(vec3 p, vec4 n) {\n    vec4 q = vec4(p, 1.);\n    return p - 2. * dot(q, n) * n.xyz;\n}\n\nvec3 rA(vec3 p) { return do_reflect(p, M[0]); }\nvec3 rB(vec3 p) { return do_reflect(p, M[1]); }\nvec3 rC(vec3 p) { return do_reflect(p, M[2]); }\nvec3 rD(vec3 p) { return do_reflect(p, M[3]); }\n\n\nvoid init() {\n\n    const float s = 0.70710678;    // sqrt(2) / 2\n\n#if LATTICE == 0\n    // affine A3 lattice\n    //\n    // A     C\n    //  o---o\n    //  |   |\n    //  o---o\n    // D     B\n    M = mat4(vec4(-s, -s, 0, 2.*s),\n             vec4(s, -s, 0, 0),\n             vec4(0, s, -s, 0),\n             vec4(0, s, s, 0));\n             \n    V = mat4x3(vec3(0, 0, 0),\n               vec3(2, 0, 0),\n               vec3(1, 1, -1),\n               vec3(1, 1, 1));\n\n#elif LATTICE == 1\n    // affine B3 lattice\n    //          C\n    //         o\n    //     4  /\n    // A o---o B\n    //        \\\n    //         o\n    //          D\n    M = mat4(vec4(0, 0, 1, 0),\n             vec4(0, s, -s, 0),\n             vec4(s, -s, 0, 0),\n             vec4(-s, -s, 0, 2.*s));\n             \n    V = mat4x3(vec3(1, 1, 1),\n               vec3(1, 1, 0),\n               vec3(2, 0, 0),\n               vec3(0, 0, 0));\n\n// affine C3 lattice\n#else\n    //   4       4\n    // o---o---o---o\n    // A   B   C   D\n    M = mat4(vec4(0, 0, 1, 0),\n             vec4(0, s, -s, 0),\n             vec4(s, -s, 0, 0),\n             vec4(-1, 0, 0, 1));\n    \n    V = mat4x3(vec3(0, 0, 0),\n               vec3(1, 0, 0),\n               vec3(1, 1, 0),\n               vec3(1, 1, 1));\n\n#endif\n\n    M_inv = inverse(M);\n    vec4 v4 = T * M_inv;\n    v4 /= v4.w;\n    v0 = v4.xyz;\n    for (int i = 0; i < 4; i++) {\n        E[i] = v0 - 2. * dot(v4, M[i]) * M[i].xyz;\n    }\n}\n\n\n#define FAR     80.\n#define PI      3.141592654\n\nfloat sgn(float x) { return x > 0. ? 1. : -1.; }\n\n// Camera path as a function of time t.\n// I think it's unlikely to devise an universal path that flies through all\n// honeycombs without hitting the lattice.\nvec3 camPath(float t) { return vec3(t, 0, 0); }\n\n// A mirror is active if and only if the initial vertex v0 is not on it,\n// or equivalently, the barycentric coordinate with respect to this mirror is non-zero.\nbool isActive(int k) { return T[k] != 0.0; }\n\n// try to reflect a point p about mirror with normal `n`, if p and the fundamental domain\n// are on the different sides of the mirror\nvec4 try_reflect(vec4 p, vec4 n, inout int flips) {\n    float k = dot(p, n);\n    if (k < 0.) {\n        flips += 1;\n        p.xyz -= 2. * k * n.xyz;\n    }\n    return p;\n}\n\nvec2 rot2d(vec2 p, float a) { return cos(a) * p + sin(a) * vec2(p.y, -p.x); }\n\n\n// fold a point p into the fundamental domain.\n// we return the final position of p, but also track an intermediate state of p for\n// handling dual cases.\nvec3 fold(inout vec3 p, inout int flips) {\n    \n    vec4 q;\n\n#if LATTICE == 0\n\n    p = mod(p + 2., 4.) - 2.;\n    q = vec4(p, 1);\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            q = try_reflect(q, M[j], flips);\n        }\n    }\n\n#elif LATTICE == 1\n   \n    p = mod(p + 2., 4.) - 2.;\n    flips += int(p.x < 0.0) + int(p.y < 0.0) + int(p.z < 0.0);\n    p = abs(p);\n    q = vec4(p, 1);\n    for (int i = 0; i < 2; i++) {\n        q = try_reflect(q, M[3], flips);\n        q = try_reflect(q, M[2], flips);\n        q = try_reflect(q, M[1], flips);\n    }\n    \n#else\n\n    p = mod(p + 1., 2.) - 1.;\n    flips += int(p.x < 0.0) + int(p.y < 0.0) + int(p.z < 0.0);\n    p = abs(p);\n    q = vec4(p, 1.);\n    q = try_reflect(q, M[1], flips);\n    q = try_reflect(q, M[2], flips);\n    q = try_reflect(q, M[1], flips);\n\n#endif\n\n    return q.xyz;\n}\n\n\n// Shane's tex3D function\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n) {\n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n// I hacked this function to rotate any edge (a, b) to z-axis\nmat3 rotAxis(vec3 n) {\n    n = normalize(n);\n    vec3 x;\n    if (n.x == 0.)\n        x = vec3(1, 0, 0);\n    else\n        x = normalize(vec3(-n.y, n.x, 0.));\n    vec3 y = cross(n, x);\n    return mat3(x, y, n);\n}\n\n\nfloat tube(vec2 p, float sc, float rad) {\n    return max(max(p.x, p.y), (p.x + p.y)*sc) - rad;\n}\n\n\n// draw an edge with two ends at a, b.\nvec3 dSegment(vec3 p, vec3 a, vec3 b) {\n    // set local origin at middle point of the edge\n    vec3 m = (a + b) / 2.;\n    p -= m;\n    b -= m;\n    a -= m;\n    vec3 h = (b - a) / 2.;\n    float L = length(h); // length of half the edge\n\n    p = p * rotAxis(h);  // reorient the edge along with z-axis\n    p = abs(p);\n\n    // the main tube, currently this has infinite length\n    float tb;\n    tb = tube(p.xy, 0.75, tbsize);\n\n    float band = 1e5;\n    float innerTb = 1e5;\n    \n    // add a band of 1/4 length of the edge\n    band = max(tb - 0.0075, p.z - L/4.);\n    \n    // trick: rotate p to make two smaller tubes\n    // remove them from the main tube to make the holes\n    float psize = tbsize  / 1.5;\n    vec2 peg = vec2(tube(p.xz, .64, psize), tube(p.yz, .64, psize));\n    float hole = min(peg.x, peg.y);\n    \n    // use planes to cut the band\n    float dp1 = max(peg.x, p.y - tbsize - .0095); dp1 = max(dp1, p.y - L / 4.);\n    float dp2 = max(peg.y, p.x - tbsize - .0095); dp2 = max(dp2, p.x - L / 4.);\n    band = min(band, min(dp1, dp2));\n    \n    // make holes on the main tube\n    tb = max(tb, -(hole - .015));\n    \n    // cut the infinite main tube at the two ends\n    tb = max(tb, p.z - L);\n    \n    // make holes on the band\n    band = max(band, -(hole + .0125));\n    \n    // use sphere to create a fake inner tube\n    innerTb = length(p) - tbsize;\n    \n    return vec3(tb, band, innerTb);\n}\n\n// This function is only used for handling dual of A3 honeycombs.\n// verts[4] are four non-adjacent vertices of a cube, so each face of the cube\n/// contains exactly one pair of vertices in verts[4].\n// For p a point in the cube, we find this pair of vertices so that p is nearest to\n// the face contains this pair among all six faces.\nvoid findVertexPair(vec3 p, vec3 verts[4], out int i1, out int j1) {\n    float d = 1e5;\n    float d1;\n    for (int i = 0; i < 4; i++) {\n        for (int j = i+1; j < 4; j++) {\n            // (verts[i] + verts[j]) / 2. is the center of the face since they form a diagonal pair.\n            d1 = length(p - (verts[i] + verts[j]) / 2.);\n            if (d1 < d) {\n                i1 = i;\n                j1 = j;\n                d = d1;\n            }\n        }\n    }\n}\n\n\nfloat map(vec3 p) {\n    vec3 dedge = vec3(1e5);\n    vec3 p0 = p;\n    int flips = 0;\n    p = fold(p0, flips);\n\n// For the usual uniform honeycomb just render the edges, that's safe since they lie inside\n// the fundamental tetrahedron.\n#ifndef DUAL\n\n    for (int i = 0; i < 4; i++) {\n         dedge = min(dedge, dSegment(p, v0, E[i]));\n    }\n   \n#else\n    /*\n    Render the dual honeycomb.\n\n    In the dual honeycomb two cells are adjacent if and only if they share a common face.\n        \n    For two mirrors A, B they generate a non-degenerate face if and only if either\n    of below holds:\n        \n        1. A, B are perpendicular and they are both active\n        2. A, B are not perpendicular and at least one of them is active\n        \n    For such a face we further check if {A, B, C} and {A, B, D} both generate non-degenerate cells.\n\n    1. If {A, B, C} and {A, B, D} are both non-degenerate, (C, D) form an edge in the dual honeycomb.\n    2. If {A, B, D} degenerates to a face, (D, 2*C-D) form an edge in the dual honeycomb.\n    3. If both {A, B, C} and {A, B, D} are degenerate, no edge between C and D.\n    */\n\n    // The C3 honeycomb is the easiest, handle this case first.\n    //   4       4\n    // o---o---o---o\n    // A   B   C   D\n    #if LATTICE == 2\n        // if either A or B is active, then {A, B} generate a face and {A, B, C} is a\n        // non-degenerate cell. {A, B, D} is non-degenerate iff D is active.\n        // Other procedures below are all similar.\n        if (isActive(0) || isActive(1)) {\n            if (isActive(3))\n                dedge = min(dedge, dSegment(p, V[2], V[3]));\n            else\n                dedge = min(dedge, dSegment(p, V[3], 2.*V[2]-V[3]));\n        }\n        if (isActive(0) && isActive(2)) dedge = min(dedge, dSegment(p, V[1], V[3]));\n        if (isActive(1) || isActive(2)) dedge = min(dedge, dSegment(p0, V[0], V[3]));\n        if (isActive(0) && isActive(3)) dedge = min(dedge, dSegment(p, V[1], V[2]));\n        if (isActive(1) && isActive(3)) dedge = min(dedge, dSegment(p, V[0], V[2]));\n        if (isActive(2) || isActive(3)) {\n            if (isActive(0))\n                dedge = min(dedge, dSegment(p, V[1], V[0]));\n            else\n                dedge = min(dedge, dSegment(p, V[0], 2.*V[1]-V[0]));\n        }\n \n    #elif LATTICE == 1\n\n        if (isActive(0) || isActive(1)) dedge = min(dedge, dSegment(p, V[2], V[3]));\n        if (isActive(0) && isActive(2)) {\n            if (isActive(3))\n                dedge = min(dedge, dSegment(p, V[1], V[3]));\n            else\n                dedge = min(dedge, dSegment(p, V[3], 2.*V[1]-V[3]));\n        }\n        // trick: the edge (V[0], V[3]) does not lie inside the fundamental domain hence octahedral\n        // shapes won't work. we render its 4 copies in the cube [0, 0, 0] x [2, 2, 2].\n        if (isActive(1) || isActive(2)) {\n            dedge = min(dedge, dSegment(p0, V[0], V[3]));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(2, 2, 0)));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(2, 0, 2)));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(0, 2, 2)));\n        }\n        \n        if (isActive(0) && isActive(3)) {\n            if (isActive(2))\n                dedge = min(dedge, dSegment(p, V[1], V[2]));\n            else\n                dedge = min(dedge, dSegment(p, V[2], 2.*V[1]-V[2]));\n        }\n        if (isActive(1) || isActive(3)) {\n            dedge = min(dedge, dSegment(p0, V[0], V[2]));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(0, 2, 0)));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(0, 0, 2)));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(2, 2, 2)));\n        }\n        if (isActive(2) && isActive(3)) {\n            if (isActive(1))\n                dedge = min(dedge, dSegment(p, V[1], V[0]));\n            else\n                dedge = min(dedge, dSegment(p, V[0], 2.*V[1]-V[0]));\n        } \n    \n    #else\n        // The duals of A3 honeycombs are the most difficult. Recall p0 is now in [-2, -2, -2] x [2, 2, 2].\n        // We use a completely different way to render them. The idea is, vertices of the A3 regular honeycombs\n        // are integer lattices points (i, j, k) with:\n        // i + j + k = 0 mod 4 for V0\n        // i + j + k = 2 mod 4 for V1\n        // i + j + k = 1 mod 4 for V2\n        // i + j + k = 3 mod 4 for V3\n     \n        // find the center of the 2x2x2 cube that p belongs to\n        vec3 C = vec3(sgn(p0.x), sgn(p0.y), sgn(p0.z));\n        \n        float k = mod(C.x + C.y + C.z, 4.);\n        // if k = 1 mod 4, then the center of this cube is congruent to V[2] of the fundamental tetrahedron.\n        // else k = 3 mod 4 and the center is congruent to V[3].\n        int type = (k == 1.) ? 2 : 3;\n        \n        vec3 V0[4];  // holds the vertices of this 2x2x2 cube that are congruent to V[0]\n        vec3 V1[4];  // holds the vertices of this 2x2x2 cube that are congruent to V[1]\n        \n        if (type == 2) {\n            V0[0] = C + vec3(1, 1, 1);\n            V0[1] = C + vec3(-1, -1, 1);\n            V0[2] = C + vec3(1, -1, -1);\n            V0[3] = C + vec3(-1, 1, -1);\n            V1[0] = C + vec3(1, -1, 1);\n            V1[1] = C + vec3(-1, 1, 1);\n            V1[2] = C + vec3(1, 1, -1);\n            V1[3] = C + vec3(-1, -1, -1);\n        }\n        else {  // switch the role of V0, V1 above\n            V1[0] = C + vec3(1, 1, 1);\n            V1[1] = C + vec3(-1, -1, 1);\n            V1[2] = C + vec3(1, -1, -1);\n            V1[3] = C + vec3(-1, 1, -1);\n            V0[0] = C + vec3(1, -1, 1);\n            V0[1] = C + vec3(-1, 1, 1);\n            V0[2] = C + vec3(1, 1, -1);\n            V0[3] = C + vec3(-1, -1, -1);\n        }\n        \n        int r0, s0, r1, s1;\n        findVertexPair(p0, V0, r0, s0);\n        findVertexPair(p0, V1, r1, s1);\n        vec3 P0 = V0[r0] + V0[s0] - C;\n        vec3 P1 = V1[r1] + V1[s1] - C;\n\n        if (isActive(2) && isActive(3)) dedge = min(dedge, dSegment(p, V[0], V[1]));\n        if (isActive(1) || isActive(3)) {\n            if (type == 2) {\n                dedge = min(dedge, dSegment(p0, C, V0[r0]));\n                dedge = min(dedge, dSegment(p0, C, V0[s0]));\n            }\n            else {\n                dedge = min(dedge, dSegment(p0, P0, V0[r0]));\n                dedge = min(dedge, dSegment(p0, P0, V0[s0]));\n            }\n        }\n        if (isActive(1) || isActive(2)) {\n            if (type == 3) {\n                dedge = min(dedge, dSegment(p0, C, V0[r0]));\n                dedge = min(dedge, dSegment(p0, C, V0[s0]));            \n            }\n            else {\n                dedge = min(dedge, dSegment(p0, P0, V0[r0]));\n                dedge = min(dedge, dSegment(p0, P0, V0[s0]));\n            }\n        }\n        if (isActive(0) || isActive(3)) {\n            if (type == 2) {\n                dedge = min(dedge, dSegment(p0, C, V1[r1]));\n                dedge = min(dedge, dSegment(p0, C, V1[s1]));\n            }\n            else {\n                dedge = min(dedge, dSegment(p0, P1, V1[r1]));\n                dedge = min(dedge, dSegment(p0, P1, V1[s1]));\n            }\n        }\n        if (isActive(0) || isActive(2)) {\n            if (type == 3) {\n                dedge = min(dedge, dSegment(p0, C, V1[r1]));\n                dedge = min(dedge, dSegment(p0, C, V1[s1]));\n            }\n            else {\n                dedge = min(dedge, dSegment(p0, P1, V1[r1]));\n                dedge = min(dedge, dSegment(p0, P1, V1[s1]));\n            }\n        }\n        if (isActive(0) && isActive(1)) dedge = min(dedge, dSegment(p, V[2], V[3]));\n\n    #endif\n#endif\n\n    // store the object ids.\n    objIDs = dedge;\n    return min(dedge.x, min(dedge.y, dedge.z));\n}\n\n\n// This reduces the compiling time to about 7x times faster\nvec3 calcNormal(vec3 p, inout float edge, float t) {\n    float eps = 1./mix(400., iResolution.y, .5)*(1. + t*.5);\n    float d = map(p);\n    vec3 e = vec3(eps, 0, 0);\n    vec3 da = vec3(-2.*d);\n    for(int i = min(iFrame, 0); i < 3; i++ ) {\n        for(int j = min(iFrame, 0); j < 2; j++)\n            da[i] += map(p + e * float(1 - 2*j));\n        e = e.zxy;\n    }\n    da = abs(da);\n\n    edge = da.x + da.y + da.z;\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame, 0); i<4; i++) {\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        n += e*map(p + .001*e);\n    }\n    return normalize(n);\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float tmin, float tmax, float k) {\n    const int maxShadeIterations = 32;\n    vec3 rd = lp - ro;\n    rd /= max(length(rd), 1e-4);\n    float shade = 1.0;\n    float t = tmin;\n    for (int i = 0; i < maxShadeIterations; i++) {\n        float h = map(ro + rd * t);\n        t += clamp(h, 0.01, 0.2);\n        shade = min(shade, smoothstep(0., 1., k * h / t));\n        if (abs(h) < 1e-4 || t > tmax)\n            break;\n    }\n    return min(max(shade, 0.) + .1, 1.);\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n);\n        occ += (h - d) * sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0.0, 1.0);\n}\n\n\nfloat trace(in vec3 ro, in vec3 rd) {\n    glow = 0.;\n    float ah;\n    const float precis = 1e-3;\n    float t = 0.0;\n    for (int i = 0; i < 128; i++) {\n        float h = map(ro + rd * t);\n        ah = abs(h);\n        glow += 1./(1. + ah*ah*8.);\n        if (ah < (t * 0.125 + 1.) * precis || t > FAR)\n            break;\n        t += h;\n    }\n    return min(t, FAR);\n}\n\n\nvec3 transform(in vec3 p) {\n    if (iMouse.x > 0.0) {\n        float phi =  2.0*iMouse.x / iResolution.x * PI - PI;\n        float theta = iMouse.y / iResolution.y * PI - 0.5*PI;\n        p.xz = rot2d(p.xz, phi / 6.);\n        p.yx = rot2d(p.yx, theta / 4.);\n       \n    }\n    return p;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    init();\n\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 up = vec3(0, 1, 0);\n    vec3 ro = camPath(iTime * 1.1);\n    vec3 lookat = camPath(iTime * 1.1 + 0.1);\n    \n    vec3 forward = normalize(lookat - ro);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    vec3 rd = normalize(uv.x * right + uv.y * up + forward * 2.);\n    ro = transform(ro);\n    rd = transform(rd);\n    vec3 lp = ro + vec3(-1, 2, -1);\n    vec3 col = vec3(0);\n    \n    float t = trace(ro, rd);\n    \n    float objID = (objIDs.x < objIDs.y && objIDs.x < objIDs.z) ? 0. : (objIDs.y < objIDs.z) ? 1. : 2.;\n    \n    if (t < FAR) {\n        float ed;\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos, ed, t);\n\n        vec3 oCol;\n        #ifndef GOLD_STYLE\n        vec3 bCol = mix(vec3(1, .1, .5).zyx,\n                        vec3(1, .3, .1).zyx,\n                        dot(sin(pos*8. - cos(pos.yzx*4. + iTime*4.)), vec3(.166)) + .5);\n        #else\n        vec3 bCol = mix(vec3(1, .5, .1),\n                        vec3(1, .1, .2),\n                        dot(sin(pos*8. - cos(pos.yzx*4. + iTime*4.)), vec3(.166)) + .5);\n        #endif\n        if(objID < .5)\n            oCol = mix(bCol, vec3(1), .97);\n        \n        else if (objID > 1.5)\n            oCol = mix(bCol, vec3(1), .05) + bCol*2.;\n        \n        else\n            oCol = mix(bCol, vec3(1.35), .97)*vec3(1.1, 1, .9);\n\n        vec3 tx = tex3D(iChannel0, pos*2., nor);\n        tx = smoothstep(.0, .5, tx)*2.;\n\n        if(objID < 1.5)\n            oCol *= tx;\n        else\n            oCol *= mix(vec3(1), tx, .5);\n\n        float ao = calcAO(pos, nor);\n        float sh = softShadow(pos + nor*.002, lp, 0.001, 16., t);\n\n        vec3 ld = lp - pos;\n        float dist = max(length(ld), 0.001);\n        ld /= dist;\n\n        float atten = 3./(1. + dist*0.05 + dist*dist*0.025);\n\n        float diff = max(dot(ld, nor), 0.);\n        if (objID < 1.5)\n            diff = pow(diff, 4.)*2.;\n        float spec = pow(max(dot( reflect(ld, nor), rd), 0.0 ), 32.0);\n\n        col = oCol*(diff + .25) + mix(bCol.zyx, vec3(1, .7, .3), .5)*spec*4.;\n\n        col += .015/max(abs(.05 - map(pos*1.5 + sin(iTime/6.))), .01)*oCol*mix(bCol, vec3(1, .8, .5), .35);\n\n        // Adding a bit of glow. It was tempting to get my money's worth, but I kept it subtle. :)\n        if(objID < 1.5)\n            col += bCol*glow*.02;\n        else\n            col += bCol*glow*1.5;\n\n        // Applying the dark edges, attenuation, shadows and ambient occlusion.\n        col *= (1. - ed*.7);\n        col *= atten*(sh + ao*.25)*ao;\n\n    }\n\n    float fog = 1./(1. + t*.125 + t*t*.01);\n    col = mix(vec3(0), col, fog);//\n\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125);\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}