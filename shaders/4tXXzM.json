{
    "Shader": {
        "info": {
            "date": "1450883092",
            "description": "Test case for PBR GGX lighting formula",
            "flags": 0,
            "hasliked": 0,
            "id": "4tXXzM",
            "likes": 21,
            "name": "PBR GGX Materials",
            "published": 3,
            "tags": [
                "ggxmaterialsamples"
            ],
            "usePreview": 0,
            "username": "BiiG",
            "viewed": 2982
        },
        "renderpass": [
            {
                "code": "const float cDetailNormalPower = 0.3;\n\nvec3 gv3View = vec3(0.0,0.0,-1.0);\nvec3 gv3LightDir = vec3(0.0,0.0,-1.0);\nvec3 gv3LightColor = vec3(1.0,1.0,1.0);\n\n\nfloat G1V(float NdotV, float k)\n{\n\treturn 1.0/(NdotV*(1.0-k)+k);\n}\n\nfloat SpecGGX(vec3 N, vec3 V, vec3 L, float roughness, float F0 )\n{\n\tfloat SqrRoughness = roughness*roughness;\n\n\tvec3 H = normalize(V+L);\n\n\tfloat NdotL = clamp(dot(N,L),0.0,1.0);\n\tfloat NdotV = clamp(dot(N,V),0.0,1.0);\n\tfloat NdotH = clamp(dot(N,H),0.0,1.0);\n\tfloat LdotH = clamp(dot(L,H),0.0,1.0);\n\n\t// Geom term\n\tfloat RoughnessPow4 = SqrRoughness*SqrRoughness;\n\tfloat pi = 3.14159;\n\tfloat denom = NdotH * NdotH *(RoughnessPow4-1.0) + 1.0;\n\tfloat D = RoughnessPow4/(pi * denom * denom);\n\n\t// Fresnel term \n\tfloat LdotH5 = 1.0-LdotH;\n    LdotH5 = LdotH5*LdotH5*LdotH5*LdotH5*LdotH5;\n\tfloat F = F0 + (1.0-F0)*(LdotH5);\n\n\t// Vis term \n\tfloat k = SqrRoughness/2.0;\n\tfloat Vis = G1V(NdotL,k)*G1V(NdotV,k);\n\n\tfloat specular = NdotL * D * F * Vis;\n    \n\treturn specular;\n}\n\nvec3 GetGIReflexion(in vec3 Normal, in float Roughness)\n{\n    vec3 R0 = texture (iChannel1,reflect(-Normal,gv3View) ).rgb;\n    vec3 R1 = texture (iChannel2,reflect(-Normal,gv3View) ).rgb;\n    return mix ( R0, R1, Roughness );\n}\n\nvec3 Sphere( in vec2 uv, in vec2 center, in float radius, in float roughness, in float Metallicness )\n{        \n    vec2 delta = center-uv;\n    \n    float l = dot ( delta, delta);     \n    \n    float sqrRadius = radius*radius;\n        \n    l = ((sqrRadius - l) / sqrRadius);\n    l = max ( l, 0.0 );     \n    \n    float IsInSphere = 1.0-step(l,0.0);\n    delta = delta;\n    \n    // Compute normal\n    vec3 normal = vec3(delta.xy/radius,radius-sqrt(l));\n    normal = normalize ( normal );   \n    \n    // Generate UV from normal\n    vec2 texUV = normal.xy/normal.z;    \n    texUV = texUV+vec2(0.5,0.5);        \n    vec3 textureColor = texture(iChannel0,texUV).rgb;\n    \n    // Use albedo R as a tangent space normal map\n    normal.xyz += textureColor.r * cDetailNormalPower;\n    normal = normalize ( normal );    \n\n    // Compute light contribution\n    float Diffuse = dot ( normal, gv3LightDir );\n    float Spec = SpecGGX(normal,gv3View,gv3LightDir,roughness,Metallicness);\n     \n    // Fresnel\n    float NdotV = clamp(dot(normal,gv3View),0.0,1.0);\n\tNdotV = pow(1.0-NdotV,5.0);    \n\tfloat Fresnel = Metallicness + (1.0-Metallicness)*(NdotV);\n\n    // Tint lights\n    vec3 SpecColor = Spec * gv3LightColor;\n    vec3 DiffColor = Diffuse * gv3LightColor * (1.0 - Fresnel);\n    \n    // Add GI\n    const float\tcAmbientMin = 0.04;    \n    float\t\tambient = cAmbientMin * (IsInSphere);    \n    vec3\t\tColorAmbient = vec3(ambient,ambient,ambient);\n    vec3\t\tGIReflexion = GetGIReflexion ( normal, roughness );\n    \n    \n    ColorAmbient = GIReflexion * cAmbientMin;\n        \n    vec3 lightSum = max(((DiffColor + SpecColor)*(1.0-cAmbientMin) ),vec3(0.0,0.0,0.0));\n       \n    return ( lightSum + ColorAmbient + ( Fresnel * GIReflexion ) ) * IsInSphere;\n      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t    \n    // Compute normalized UV\n    vec2 uv = fragCoord.xy / iResolution.xy;    \n    // Adapt coord to aspect ratio\n    uv = uv * vec2(1.0,iResolution.y/iResolution.x);\n    \n    \n    // Rotate light\n    gv3LightDir = vec3(sin(iTime),cos(iTime)+0.2,cos(iTime));\n    gv3LightDir = normalize (gv3LightDir);\n        \n    // Compute all spheres lighting\n    vec3 color = vec3(0.0,0.0,0.0);\t\n    for ( float Roughness=0.05; Roughness<1.0; Roughness+=0.1)\n    {\n        for ( float Metallicness=0.05; Metallicness<1.0; Metallicness+=0.1)\n        {\n            const float Radius = 0.04;\n            color += Sphere ( uv,vec2( Roughness , Metallicness*0.8 ), Radius, Roughness, Metallicness );\n        }\n    }    \n    \n    \n\tfragColor = vec4 (color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}