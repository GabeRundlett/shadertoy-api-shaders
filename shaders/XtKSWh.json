{
    "Shader": {
        "info": {
            "date": "1484167781",
            "description": "Terrain with thermal erosion. Hold space to erode. Press R to reset terrain. Must reset after fullscreening or it'll look messed up. Use arrow keys to move, mouse to look (credit to Tempally for free fly). Try playing with MAXSLOPE in Buf B.",
            "flags": 48,
            "hasliked": 0,
            "id": "XtKSWh",
            "likes": 5,
            "name": "Thermal erosion - free fly",
            "published": 3,
            "tags": [
                "noise",
                "terrain",
                "erosion"
            ],
            "usePreview": 0,
            "username": "kev7774",
            "viewed": 1118
        },
        "renderpass": [
            {
                "code": "float pi = 3.14159;\n\nvec2 cheapstep2(vec2 x)\n{\n    x = vec2(1.0) - x*x;\t// MAD\n    x = vec2(1.0) - x*x;\t// MAD\n    return x;\n}\n\nfloat curve(float x)\n{\n     return x * (x*x + 3.0);\n}\n\nfloat hash(vec2 p){\n\tp = fract(p*(.1*.4142));\n\treturn fract(curve( p.x + p.y * .618034) * 43758.5453);\n}\n\n\nfloat noise(vec2 p){\n    vec2 fp = fract(p);\n    fp = cheapstep2(fp);\n    p = floor(p);\n    \n    float sw = hash(p);\n    float se = hash(vec2(p.x+1.,p.y));\n    float ne = hash(vec2(p.x+1.,p.y+1.));\n    float nw = hash(vec2(p.x,p.y+1.));\n    \n    return mix( mix(sw, se, fp.x), mix(nw, ne, fp.x), fp.y);\n}\n\n\n/*\nfloat noise(vec2 c){\n    \n}\n*/\n\nvec2 smoothUV(vec2 uv){\n    uv = uv * iResolution.xy + vec2(.5);\n    uv = (uv-fract(uv)) + cheapstep2(fract(uv));\n    uv = (uv - vec2(.5)) / iResolution.xy;\n    return uv;\n}\n\nfloat terrainh(vec2 pos){\n    pos = pos*.5+.5;\n    pos.x *= iResolution.y/iResolution.x;\n     if(pos.x<0.||pos.y<0.||pos.x>1.||pos.y>1.) return 0.;\n    //pos = smoothUV(pos);\n    return .5* texture(iChannel0, pos).x;\n}\n\nvec3 intersect(vec3 raystart, vec3 raydir) {\n    \n   vec3 pos = raystart;\n   raydir = normalize(raydir);\n    \n    for(int i=0; i<256; i++){\n        float h = terrainh(pos.xy);\n        float dif = pos.z - h;\n        if(dif<.0002) break;\n        pos += raydir * dif *.25;\n    }\n    return pos;\n}\n\nvec3 normal (vec2 pos){\n    float delta = 1./iResolution.y;   \n    \n    vec2 posx1 = vec2(pos.x+delta, pos.y);\n    vec2 posx2 = vec2(pos.x-delta, pos.y);\n    \n    vec2 posy1 = vec2(pos.x, pos.y+delta);\n    vec2 posy2 = vec2(pos.x, pos.y-delta);\n    \n    float hx1 = terrainh(posx1);\n    float hx2 = terrainh(posx2);\n    float hy1 = terrainh(posy1);\n    float hy2 = terrainh(posy2);\n    \n    float dhdx = (hx1-hx2)/delta/2.;\n    float dhdy = (hy1-hy2)/delta/2.;\n    \n    vec3 norm = cross( normalize(vec3(1.,0.,dhdx)), normalize(vec3(0.,1.,dhdy)));\n    return norm;\n}\n\nfloat phi = (sqrt(5.)+1.)/2.;\n\nvec2 complexMul(vec2 a, vec2 b) {\n\treturn vec2( a.x*b.x -  a.y*b.y,a.x*b.y + a.y * b.x);\n}\n\nvec3 shade(vec3 pos){\n    \n   float noi = noise(pos.xy*40.);// texture(iChannel1, smoothUV(pos.xy*.4)).x;\n    \n   vec2 coord2 = phi *complexMul(pos.yx, vec2(cos(phi*pi*2.),sin(phi*pi*2.))); \n    \n   vec3 tex1 = vec3(.05,.15,.03) + .6*vec3(.5,.85,.4)*texture(iChannel2, pos.yx*16.0).grb;\n   vec3 tex2 = 2.2*vec3(.86,.9,.9)*texture(iChannel3, coord2*4.0).rgb - vec3(.25);\n    tex2 = max(vec3(.22,.22,.22),tex2);\n    \n   vec3 n = normal(pos.xy);\n    \n   float fade = clamp( 2.5*(length(n.xy)*.5 + pos.z*1.5 + .35*noi-.25)-1.5, 0.,1.);\n    \n    vec3 col =  mix(tex1,tex2,fade);\n    \n   return sqrt(col.rgb * ( clamp(dot(vec3(.6,0.,.6), n),0.,1.) + .13));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n   // vec2 uv = fragCoord / iResolution.xy;\n    \n   //fragColor = texture(iChannel0, uv);\n   // return;\n    \n    //vec2 mouse = iMouse.xy / iResolution.xy;\n   // mouse = mouse*pi - pi/2.;\n   // mouse.x*=2.;\n    \n    /*\n\tvec3 campos = vec3(0.0,0.0,.6);\n    vec3 camright = vec3(cos(mouse.x),sin(mouse.x),0.);\n    vec3 camup = vec3(sin(mouse.y)*vec2(-camright.y,camright.x), cos(mouse.y));\n    vec3 camforw = cross(camup, camright);\n    \n    vec2 coord = fragCoord.xy / iResolution.xy;\n    coord = coord*2. - vec2(1.);\n    coord.x *= (iResolution.x/iResolution.y);\n    \n    vec3 raydir = vec3(coord.x*camright + coord.y*camup + 1.6 * camforw);\n    */\n     const float FOV = 3.14159/3.;\n    \n    vec3 rd = normalize(vec3( (fragCoord.xy*2. - iResolution.xy)/iResolution.x, FOV )); \n    vec4 tm = texture( iChannel1, vec2(1.5,.5)/iResolution.xy); \n    rd.zy = rd.zy * tm.x + rd.yz * vec2(tm.z, -tm.z);\n    rd.xz = rd.xz * tm.y + rd.zx * vec2(tm.w, -tm.w);\n\tvec3 ro = texture( iChannel1, vec2(3.5,.5)/iResolution.xy).xyz;\n    \n    vec3 campos = ro.xzy/10.;\n    campos.z += .6;\n    vec3 raydir = rd.xzy;\n    \n    vec3 hit = intersect(campos, raydir);\n    \n   fragColor.xyz = shade(hit);\n   fragColor.a = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Slop threshold for erosion. Larger values give steeper, jagged mountains. Smaller values give smooth mountains.\n#define MAXSLOPE 3.6\n\n#define KEY_R 0.322265625\n#define KEY_SPACE 0.126953125\t\n\nfloat getKey(float key) {return texture(iChannel0, vec2(key, .25)).x;}\n\nvec2 cheapstep2(vec2 x)\n{\n    x = vec2(1.0) - x*x;\t// MAD\n    x = vec2(1.0) - x*x;\t// MAD\n    return x;\n}\n\nvec2 complexMul(vec2 a, vec2 b) {\n\treturn vec2( a.x*b.x -  a.y*b.y,a.x*b.y + a.y * b.x);\n}\n\nvec2 smoothUV(vec2 uv){\n    uv = uv * 64. + vec2(.5);\n    uv = (uv-fract(uv)) + cheapstep2(fract(uv));\n    uv = (uv - vec2(.5)) / 64.;\n    return uv;\n}\n\nfloat ridge(float x){\n    return 1. - abs(x*2.-1.);\n}\n\nfloat curve(float x)\n{\n     return x * (x*x + 3.0);\n}\n\nfloat hash(vec2 p){\n\tp = fract(p*(.1*.4142));\n\treturn fract(curve( p.x + p.y * .618034) * 43758.5453);\n}\n\n\nfloat noise(vec2 p){\n    vec2 fp = p - floor(p);\n    fp = cheapstep2(fp);\n    p = floor(p);\n    \n    float sw = hash(p);\n    float se = hash(vec2(p.x+1.,p.y));\n    float ne = hash(vec2(p.x+1.,p.y+1.));\n    float nw = hash(vec2(p.x,p.y+1.));\n    \n    return mix( mix(sw, se, fp.x), mix(nw, ne, fp.x), fp.y);\n}\n\n\n\nfloat drainAmt(float greater, float lesser){\n    return normalize(vec2(1./iResolution.y,.25*(greater-lesser))).y;\n}\n\n//Making this smaller doesn't change much, making it larger causes instability\n#define RATE .146 \n\nfloat exchange(float self, float other, float dist) {\n    float maxdif = dist * MAXSLOPE/iResolution.y;    \n    if(self > other){\n        if(self-other > maxdif) return -RATE * ((self-other) - maxdif) / dist;\n        else return 0.;\n    }else{\n        if(other-self > maxdif) return  RATE * ((other-self) - maxdif) / dist;\n        else return 0.;\n    }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0 || getKey(KEY_R) == 1.){\n        vec2 uv = fragCoord.xy / iResolution.yy;\n        if(uv.x > 1.0){ fragColor = vec4(0.); return;}\n\t\t//uv += + vec2(floor(iResolution.y*iTime/32.)/iResolution.y);\n        uv += vec2(.5);\n        uv *= .04;\n\n        float mul = 1.0;\n        float sum =  0.;\n        float mulsum = 0.0;\n        for(int i=0; i<11; i++){\n            float t = sqrt(ridge(noise(uv*64.+vec2(260.))) * ridge(noise(uv*96.+vec2(260.))));\n            sum += (mulsum > 0.) ? t*mul*(1.+0.*sum/mulsum) : t*mul;\n            mulsum += mul;\n\n            const float phi = (sqrt(5.)+1.)/2.;\n            const float pi = 3.14159;\n            uv = complexMul(uv, 3.1 * vec2(cos(phi*pi*2.),sin(phi*pi*2.)));\n            mul *= .35;\n        }\n\n        sum /= mulsum;\n        fragColor = vec4(sum,sum,sum,1.);\n   }else if(getKey(KEY_SPACE) == 1.){\n       vec2 m = texture(iChannel1, fragCoord.xy / iResolution.xy).xy; \n       \n       vec2 n = texture(iChannel1, (fragCoord.xy + vec2(0.,1.)) / iResolution.xy).xy; \n       vec2 e = texture(iChannel1, (fragCoord.xy + vec2(1.,0.)) / iResolution.xy).xy; \n       vec2 s = texture(iChannel1, (fragCoord.xy + vec2(0.,-1.)) / iResolution.xy).xy; \n       vec2 w = texture(iChannel1, (fragCoord.xy + vec2(-1.,0.)) / iResolution.xy).xy; \n        \n       vec2 ne = texture(iChannel1, (fragCoord.xy + vec2(1.,1.)) / iResolution.xy).xy; \n       vec2 se = texture(iChannel1, (fragCoord.xy + vec2(1.,-1.)) / iResolution.xy).xy; \n       vec2 sw = texture(iChannel1, (fragCoord.xy + vec2(-1.,-1.)) / iResolution.xy).xy; \n       vec2 nw = texture(iChannel1, (fragCoord.xy + vec2(-1.,1.)) / iResolution.xy).xy; \n       \n        if(fragCoord.x >= iResolution.y-1.) {\n            ne = m;\n            se = m;\n            e = m;\n        }\n       \n       float mdif = 0.;\n       float maxdif = MAXSLOPE/iResolution.y;\n       \n       mdif += exchange(m.x, n.x, 1.0);\n       mdif += exchange(m.x, e.x, 1.0);\n       mdif += exchange(m.x, s.x, 1.0);\n       mdif += exchange(m.x, w.x, 1.0);\n        \n       mdif += exchange(m.x, ne.x, sqrt(2.));\n       mdif += exchange(m.x, se.x, sqrt(2.));\n       mdif += exchange(m.x, sw.x, sqrt(2.));\n       mdif += exchange(m.x, nw.x, sqrt(2.));\n       /*\n       float water = m.y;\n       \n       \n       if(n.x+n.y > m.x+m.y){\n           drainAmt(n.x+n.y, m.x+n.y);\n           \n       }\n\t\t*/\n       \n       m.x += mdif;\n       \n       fragColor = vec4(m.x, 0., 0., 0.);\n    }else{\n       fragColor = texture(iChannel1, fragCoord.xy / iResolution.xy); \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Free fly by Tempally: https://www.shadertoy.com/view/MtGSzD\n\n// [A]=65 ... [Z]=90, [0]=48 ... [9]=57, [space]=32, [<]=37, [^]=38, [>]=39, [v]=40\n\n#define KEY_LEFT 0.146484375\n#define KEY_RIGHT 0.154296875\n#define KEY_DOWN 0.158203125\n#define KEY_UP 0.150390625\n\n\n//Use these defines for WASD controls (not the default because not everyone has a qwerty keyboard)\n/*\n#define KEY_LEFT 0.255859375\n#define KEY_RIGHT 0.267578125\n#define KEY_DOWN 0.326171875\n#define KEY_UP 0.341796875\n*/\n\n//change velocity per frame:\n#define ACCEL .02\n#define BRAKE .9;\n\nconst vec2 mouseSens = vec2(-.6, 1.); //mouse sensivity, change signs to invert axis \n\nfloat getKey(float key) {return texture(iChannel1, vec2(key, .25)).x;}\n\nvec4 getVar(int key) {return texture(iChannel0, vec2(.05 + float(key), .5)/iResolution.xy);}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.y > .9) discard;\n    int idx=int(fragCoord.x);\n    if (idx <= 1) // orientation\n    {\n        fragColor = getVar(0);\n        fragColor.xy += (float(fragColor.w>.0) - float(iMouse.z>.0 && idx==0)) * \n                        (iMouse.yx/iResolution.yx - .5) * mouseSens;\n        vec4 cr = fragColor*6.28318530718;\n        if (idx == 0) fragColor.w = iMouse.z; \n        else fragColor = vec4(cos(cr.x), cos(cr.y), sin(cr.x), sin(cr.y));\n    }\n    else if (idx == 2) // velocity\n    {\n        vec4 camV = getVar(idx--);\n        vec4 tm = getVar(idx);\n        camV.xyz += ACCEL * (\n          \t\t\t(getKey(KEY_UP) - getKey(KEY_DOWN)) * vec3(tm.x*tm.w, -tm.z, tm.x*tm.y) +\n          \t\t\t(getKey(KEY_RIGHT) - getKey(KEY_LEFT)) * vec3(tm.y, 0, -tm.w) );\n        fragColor = camV * BRAKE;\n    }\n    else if (idx == 3) fragColor = getVar(idx--) + getVar(idx); // position\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}