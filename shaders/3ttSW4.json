{
    "Shader": {
        "info": {
            "date": "1580949881",
            "description": "here I develop my style of writing shaders in OOP way.\nthis shader demonstrates that 2 different graphics (circle and ring) that are build from 1 geometry of ring.\nand a little bit animation for fun\nto stop animation uncomment 14th line `#define time 0.`",
            "flags": 0,
            "hasliked": 0,
            "id": "3ttSW4",
            "likes": 1,
            "name": "2 graphics from single geometry",
            "published": 3,
            "tags": [
                "circle",
                "glsl",
                "oop"
            ],
            "usePreview": 0,
            "username": "dmitrykolesnikovich",
            "viewed": 327
        },
        "renderpass": [
            {
                "code": "/*\nThe idea here is to demonstrate that like in SQL tables are designed in order to\nplays nicely with specific queries in GLSL geometry is also designed specifically\nto further graphics procedure to use in.\n\nI mean that circle graphics is based on ring geometry not circle geometry.\n\nSo, in real life geometry and graphics are tight coupled unfortunately\n(https://en.wikipedia.org/wiki/Loose_coupling)\n*/\n\n/*support*/\n\n// #define time 0.\n#define time iTime\n#define RED vec3(1, 0, 0)\n#define BLUE vec3(0, 0, 1)\n#define BOUNCE1 abs(sin(time * 3.))\n#define BOUNCE2 abs(sin(time * 10.))\nvec2 normalization(vec2 p) { return (2. * p - iResolution.xy)/ iResolution.y; }\n\n/*objects*/\n\n// below is Circle constructor that defines new circle instance in following steps:\n//   origin in Cartesian\n//   converts Cartesian to polar \n//   geometry in polar \n//   graphics in polar \n//   coloring \n//   one to one mapping to instance without post-production effects\nvec3 Circle(vec2 p, vec3 color) \n{\n\tvec2 origin = vec2(0);\n    float radius = .3;\n    float antialiasing = .05 + BOUNCE1 * .4;\n    p -= origin;\t\t\t\t       // define origin in Cartesian cs\t\n    float polarCoordinate = length(p); // transform Cartesian cs to polar cs\n    \n    // define ring geometry in polar cs by mapping [0..Inf] to [radius..radius * 1.025]\n    float ringGeometry = smoothstep(radius, radius * (1. + antialiasing), polarCoordinate); \n    \n    // \"graphics query\" as I call it that defines circle graphics based on ring geometry\n    vec3 smoothCircleGraphics = vec3(1. - ringGeometry);\n    \n    vec3 coloring = smoothCircleGraphics * color; \n    \n    vec3 instance = coloring; // no post-production effects\n    return instance; // the nice little thing here is that I semantically return new instance of object like it's not glsl function but real constructor in real programming language\n}\n\nvec3 Ring(vec2 p, vec3 color) \n{\n\tvec2 origin = vec2(0);\n    float radius = .4 + BOUNCE2 * .02;\n    p -= origin;\t\t\t\t       \n    float polarCoordinate = length(p); \n    float ringGeometryOutside = smoothstep(radius, radius * 1.05, polarCoordinate); \n    float ringGeometryInside = 1. - smoothstep(radius * 0.95, radius, polarCoordinate); \n    float ringGeometry = ringGeometryInside + ringGeometryOutside;\n    vec3 smoothCircleGraphics = vec3(1. - ringGeometry);\n    vec3 coloring = smoothCircleGraphics * color; \n    vec3 instance = coloring;\n    return instance;\n}\n\n/*canvas*/\n\nvoid mainImage(out vec4 canvas, in vec2 pixel)\n{\n\n    vec2 p = normalization(pixel); // normalization\n    canvas = vec4(0); // init\t\n    canvas += vec4(Circle(p, RED), 1); // append Circle\n    canvas += vec4(Ring(p, BLUE), 1); // append Ring\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}