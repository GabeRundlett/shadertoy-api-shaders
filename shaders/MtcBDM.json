{
    "Shader": {
        "info": {
            "date": "1540231457",
            "description": "just like [url=https://www.shadertoy.com/view/4t3BW4]shane's quadtree truchet shader[/url].",
            "flags": 0,
            "hasliked": 0,
            "id": "MtcBDM",
            "likes": 18,
            "name": "truchet quadtree distance",
            "published": 3,
            "tags": [
                "2d",
                "truchet",
                "quadtree"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 1028
        },
        "renderpass": [
            {
                "code": "//i made this shader because shane's shader looked so fancy\n//https://www.shadertoy.com/view/4t3BW4\n//\n//Multi-Scale Truchet Patterns  - Christopher Carlson\n//https://christophercarlson.com/portfolio/multi-scale-truchet-patterns/\n//Linking paper containing more detail:\n//http://archive.bridgesmathart.org/2018/bridges2018-39.pdf\n\n//some macros\n#define subs 0.4\n#define limit 5.0\n//#define grid\n\n//some constant macros\n#define HASHSCALE3 vec3(.6531, .5563, .7498)\n\n//hash function in hash without sine by Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW\n//it seems to make a weird truchet pattern\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z*15.3023+0.434);\n}\n\nfloat checktree(float i, vec2 r) {\n    for (float j = 0.0; j < i; j++) {\n        vec2 h = floor(r*exp2(j))*exp2(-j);\n        float rand = hash13(vec3(h,int(j)));\n        if (rand >= subs) {\n            return j;\n        }\n    }\n    return i;\n}\n\nfloat truchet(vec2 p, int type) {\n    float len;\n    if (type == 0)\n    {\n        p = p+step(p.x+p.y,0.0)-0.5;\n        len = abs(length(p)-0.5)-0.1667;\n    }\n    else if (type == 1)\n    {\n        len = -length(abs(p)-0.5)+0.3333;\n    }\n    else if (type == 2)\n    {\n        vec2 dir;\n        if (abs(p.x) > abs(p.y)) {\n            dir = vec2(sign(p.x),0.0);\n        } else {\n            dir = vec2(0.0,sign(p.y));\n        }\n        len = abs(length(p-dir*0.5))-0.1667;\n    }\n    else if (type == 3)\n    {\n        vec2 dir;\n        if (abs(p.x) > abs(p.y)) {\n            dir = vec2(sign(p.x),0.0);\n        } else {\n            dir = vec2(0.0,sign(p.y));\n        }\n        len = min(abs(length(p-0.5)-0.5),abs(length(p-dir*0.5)))-0.1667;\n    }\n    else if (type == 4)\n    {\n        p = abs(p)-0.1667;\n\n        len = -length(min(p,0.0))+max(min(p.x,p.y),0.0);\n    }\n    else if (type == 5)\n    {\n        p.y = abs(p.y);\n\n        len = min(p.y,length(p-vec2(0,0.5)))-0.1667;\n    }\n    else if (type == 6)\n    {\n        p.x = abs(p.x);\n        len = min(max(-p.y-0.1667,-length(p-0.5)+0.3333),length(p+vec2(0,0.5))-0.1667);      \n    }\n    return len;\n}\n\nfloat quadtruchet(vec2 p) {\n    float len = 0.0;\n    \n    float j = checktree(limit, p);\n    float i = j;\n    \n    //the position in the bottom left corner of the truchet cell\n    vec2 fp = floor(p*exp2(i))*exp2(-i);\n\n    //the local position on the truchet cell (always 0-1)\n    vec2 lp = (p-fp)*exp2(i);\n    \n    float rand = fract(hash13(vec3(fp,-i))*10.0);\n    vec2 q = lp-0.5;\n\n    int celltype = int(rand*7.0);\n    int rots = int(fract(rand*7.0)*4.0);\n\n    for (int i = 0; i < rots; i++) {\n        q = vec2(q.y,-q.x);\n    }\n    \n    float l = truchet(q,celltype);\n    \n    len = l*exp2(-i)*(1.0-mod(i,2.0)*2.0);\n    //len = l*exp2(-i);\n    \n    for (i = i; i <= limit; i++) {\n        \n        //the position in the bottom left corner of the truchet cell\n        fp = floor(p*exp2(i))*exp2(-i);\n\t\t\n        //the local position on the truchet cell (always 0-1)\n        lp = (p-fp)*exp2(i);\n\n        //check for the overlapping black dots\n        vec2 p2 = p*exp2(i);\n        vec2 fp2 = floor(p2-0.5);\n        for(int x = -1; x <= 2; x++) {\n            for(int y = -1; y <= 2; y++) {\n                vec2 r = (fp2+vec2(x,y))*exp2(-i);\n                //this branch doesn't do anything, but it skips the random() once\n                if (r != fp)\n                {\n                    j = checktree(i, r);\n\n                    if (i==j) {\n                        float l = length(abs(p2-fp2-vec2(x,y)-0.5)-0.5)-0.3333;\n                        float s = mod(i,2.0)*2.0-1.0;\n                        len = min(l*exp2(-i),len*s)*s;\n                    }\n                }\n            }\n        }\n\t}\n    return len;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates (from -1 to 1)\n    float scale = 1.0;\n    vec2 uv = scale*(fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    //\"world space\" coordinates, always moves up to the right.\n    vec2 p = uv+iTime*0.1+vec2(-24,21);\n    \n    float len = quadtruchet(p);\n    \n    float a = exp2(checktree(limit,p));\n    \n    #ifdef grid\n    vec2 lp = abs(fract(p*a)*2.0-1.0);\n    float b = max(lp.x,lp.y);\n    a /= iResolution.y*0.2;\n    b = max(b-1.0+1.0*a,0.0)/a;\n    #endif\n    \n    //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n    vec3 col = 1.0 - sign(len)*vec3(0.1,0.4,0.7);\n\tcol *= min(1.0 - exp(-6.0*abs(len)),0.8);\n\tcol *= 0.8 + 0.2*cos(200.0*abs(len));\n\tcol = mix( col, vec3(1), 1.0-min(abs(len)*0.25*iResolution.y,1.0) );\n    \n    #ifdef grid\n    col += b;\n    #endif\n    \n    fragColor = vec4(col,1);\n    \n\t//fragColor = vec4(vec3(sqrt(len*iResolution.y/scale*0.5)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}