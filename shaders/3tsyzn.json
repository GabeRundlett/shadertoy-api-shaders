{
    "Shader": {
        "info": {
            "date": "1591280029",
            "description": "Generate a generalized penrose tiling through the cut method.\n\nThis has been a work in progress for so much time that I decided to release this version as is and start from scratch ':D",
            "flags": 0,
            "hasliked": 0,
            "id": "3tsyzn",
            "likes": 0,
            "name": "Quasicrystals â€“ The Cut Method",
            "published": 3,
            "tags": [
                "tiling",
                "tessellation",
                "penrose",
                "quasicrystals",
                "nonperiodic"
            ],
            "usePreview": 0,
            "username": "natpbs",
            "viewed": 134
        },
        "renderpass": [
            {
                "code": "/* ==== Types ====*/\n\nstruct vec5 {\n    // first 2 entries\n    vec2 a;\n    // last 3 entries\n    vec3 b;\n};\n    \nstruct mat5 {\n    // first 2 columns\n\tmat2 a; mat2x3 b;\n    // last 3 columns\n    mat3x2 c; mat3 d;\n};\n    \n/* ==== Constants ====*/\n\nconst float tau = 2.*acos(-1.);\nconst float a = sqrt(2./5.);\nconst float b = 2.*acos(-1.)/5.;\nconst mat5 B = mat5(\n a * mat2(\n  1.,cos(b),\n  0.,sin(b)\n ),\n a * mat2x3(\n  cos(2.*b),cos(3.*b),cos(4.*b),\n  sin(2.*b),sin(3.*b),sin(4.*b)\n ),\n a * mat3x2(\n  1.,cos(2.*b),\n  0.,sin(2.*b),\n  sqrt(.5),sqrt(.5)\n ),\n a * mat3(\n  cos(4.*b),cos(b),cos(3.*b),\n  sin(4.*b),sin(b),sin(3.*b),\n  sqrt(.5),sqrt(.5),sqrt(.5)\n )\n);\n\nconst mat5 Bt = mat5(\n    transpose(B.a), transpose(B.c),\n    transpose(B.b), transpose(B.d)\n    );\n\n#define wedgeTwo(u) vec2(u.y, -u.x)\n#define wedgeThree(v1, v2) cross(v1, v2)\n\nconst vec2 Z[5] = vec2[5](\n    wedgeTwo(Bt.a[0]),\n    wedgeTwo(Bt.a[1]),\n    wedgeTwo(Bt.c[0]),\n    wedgeTwo(Bt.c[1]),\n    wedgeTwo(Bt.c[2])\n);\n\nconst float detF[10] = float[10](\n    dot(Bt.a[0], Z[1]), // 0,1\n\tdot(Bt.a[0], Z[2]), // 0,2\n\tdot(Bt.a[0], Z[3]), // 0,3\n\tdot(Bt.a[0], Z[4]), // 0,4\n\tdot(Bt.a[1], Z[2]), // 1,2\n\tdot(Bt.a[1], Z[3]), // 1,3\n\tdot(Bt.a[1], Z[4]), // 1,4\n\tdot(Bt.c[0], Z[3]), // 2,3\n\tdot(Bt.c[0], Z[4]), // 2,4\n\tdot(Bt.c[1], Z[4]) // 3,4 \n);\n\nconst ivec2 indexF[10] = ivec2[10](\n    ivec2(1,0),\n    ivec2(2,0),\n    ivec2(3,0),\n    ivec2(4,0),\n    ivec2(2,1),\n    ivec2(3,1),\n    ivec2(4,1),\n    ivec2(3,2),\n    ivec2(4,2),\n    ivec2(4,3)\n);\n\nconst vec3 W[10] = vec3[10](\n    wedgeThree(Bt.b[0], Bt.b[1]), // 0 - 0,1\n    wedgeThree(Bt.b[0], Bt.d[0]), // 1 - 0,2\n    wedgeThree(Bt.b[0], Bt.d[1]), // 2 - 0,3\n    wedgeThree(Bt.b[0], Bt.d[2]), // 3 - 0,4\n    wedgeThree(Bt.b[1], Bt.d[0]), // 4 - 1,2\n    wedgeThree(Bt.b[1], Bt.d[1]), // 5 - 1,3\n    wedgeThree(Bt.b[1], Bt.d[2]), // 6 - 1,4\n    wedgeThree(Bt.d[0], Bt.d[1]), // 7 - 2,3\n    wedgeThree(Bt.d[0], Bt.d[2]), // 8 - 2,4\n    wedgeThree(Bt.d[1], Bt.d[2]) // 9 - 3,4\n);\n\nconst float detG[10] = float[10](\n\tdot(Bt.d[0], W[9]), // 0 - 2,3,4\n\tdot(Bt.b[1], W[9]), // 1 - 1,3,4\n\tdot(Bt.b[1], W[8]), // 2 - 1,2,4\n\tdot(Bt.b[1], W[7]), // 3 - 1,2,3\n\tdot(Bt.b[0], W[9]), // 4 - 0,3,4\n\tdot(Bt.b[0], W[8]), // 5 - 0,2,4\n\tdot(Bt.b[0], W[7]), // 6 - 0,2,3\n\tdot(Bt.b[0], W[6]), // 7 - 0,1,4\n\tdot(Bt.b[0], W[5]), // 8 - 0,1,3\n\tdot(Bt.b[0], W[4]) // 9 - 0,1,2\n);\n\nconst ivec3 indexG[10] = ivec3[10](\n\tivec3(9,8,7), // 0\n\tivec3(9,6,5), // 1\n\tivec3(8,6,4), // 2\n\tivec3(7,5,4), // 3\n\tivec3(9,3,2), // 4\n\tivec3(8,3,1), // 5\n\tivec3(7,2,1), // 6\n\tivec3(6,3,0), // 7\n\tivec3(5,2,0), // 8\n\tivec3(4,1,0) // 9\n);\n\n#define translate 2\nconst vec3 bin = vec3(0,-1,1);\nconst vec5 K[] = vec5[](\n\tvec5(bin.xx, bin.xxx)\n    #if translate>0\n    ,\n\tvec5(bin.yx, bin.xxx),\n\tvec5(bin.xy, bin.xxx),\n\tvec5(bin.xx, bin.yxx),\n\tvec5(bin.xx, bin.xyx),\n\tvec5(bin.xx, bin.xxy)\n    #endif\n    #if translate>1\n    ,\n\tvec5(bin.zx, bin.xxx),\n\tvec5(bin.xz, bin.xxx),\n\tvec5(bin.xx, bin.zxx),\n\tvec5(bin.xx, bin.xzx),\n\tvec5(bin.xx, bin.xxz)\n    #endif\n);\n\n/* ==== Functions ==== */\n\nvec5 fract5(vec5 x) {\n    x.a = fract(x.a);\n    x.b = fract(x.b);\n    return x;\n}\n\nvec5 plus(vec5 x, vec5 y) {\n    x.a += y.a;\n    x.b += y.b;\n    return x;\n}\n\nvec5 fiveFromTwo(vec2 u) {\n    vec5 x = vec5(\n        B.a * u,\n        B.b * u\n    );\n    return x;\n}\n\nvec5 fiveFromThree(vec3 v) {\n    vec5 x = vec5(\n        B.c * v,\n        B.d * v\n    );\n    return x;\n}\n\nvec2 twoFromFive(vec5 x) {\n    vec2 u = x.a * B.a + x.b * B.b;\n    return u;\n}\n\nvec3 threeFromFive(vec5 x) {\n    vec3 v = x.a * B.c + x.b * B.d;\n    return v;\n}\n\nfloat [5] getZed(vec2 u) {\n    float z[5];\n    for (int j=0; j<5; j++) {\n        z[j] = dot(Z[j], u);\n    }\n    return z;\n}\n\nfloat [10] getWiu(vec3 v) {\n    float w[10];\n    for (int j=0; j<10; j++) {\n        w[j] = dot(W[j], v);\n    }\n    return w;\n}\n\nvec5 getTile(float z[5], float w[10]) {\n    for (int j=0; j<10; j++) {\n        ivec2 iF = indexF[j];\n        float dF = detF[j];\n        vec2 aF = vec2(z[iF.x],-z[iF.y])/dF;\n        vec2 bin = vec2(0,1);\n        if( any(lessThan(aF,bin.xx)) || any(greaterThan(aF,bin.yy)) ) {\n            continue;\n        }\n        ivec3 iG = indexG[j];\n        float dG = detG[j];\n        vec3 aG = -vec3(w[iG.x],-w[iG.y],w[iG.z])/dG;\n        # define noGCheck 0\n        # if noGCheck\n        \taG = vec3(.1);\n        # endif\n        if( all(greaterThanEqual(aG,bin.xxx)) && all(lessThanEqual(aG,bin.yyy)) ) {\n  \t\t    vec5 a = vec5(aF, aG);\n            return a;\n        }\n    }\n    vec5 a = vec5(vec2(2),vec3(2));\n    return a;\n}\n/* ==== Main ==== */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0);\n    vec3 offset3 = vec3(\n        (iMouse.xy - .5*iResolution.xy) / iResolution.x,\n        .2*(fract(iTime / 60.) - .5)\n    );\n    vec5 offset5 = fiveFromThree(offset3);\n    vec2 u = 4.*(fragCoord - iResolution.xy / 2.) / iResolution.x;\n    vec5 x = fiveFromTwo(u);\n    x = plus(x, offset5);\n    \n    // x = fract5(x);\n    // x = plus(x, vec5(bin.xx, bin.xxx));\n    for (int j = 0; j<K.length(); j++) {\n            vec5 k = K[j];\n            vec5 xk = plus(x, k);\n        vec2 u = twoFromFive(xk);\n        vec3 v = threeFromFive(xk);\n\n        float z[5] = getZed(u);\n        float w[10] = getWiu(v);\n\n        vec5 a = getTile(z, w);\n        if (a.a.x != 2.) {\n        \tfragColor.rgb = .5*a.b + .5*vec3(0, a.a);\n            return;\n        }\n    }\n    \n    ivec2 iCoord = ivec2(fragCoord/iResolution.xy*255.);\n    fragColor.rgb = 1. / 255. * vec3(\n        iCoord.x,\n        iCoord.y,\n        iCoord.x ^ iCoord.y\n    ).brg;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}