{
    "Shader": {
        "info": {
            "date": "1632278469",
            "description": "Experimenting with Segments. Feels a lot like a Byt3_m3chanic knock off and that's ok with me.\nThe trace, doColor and getSky routines are from shane. Copied, pasted, and modified a bit.\nDistance to line segment derivation is commented in common tab.\nmouse",
            "flags": 0,
            "hasliked": 0,
            "id": "ssy3WV",
            "likes": 17,
            "name": "Segment Park",
            "published": 3,
            "tags": [
                "segment"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 338
        },
        "renderpass": [
            {
                "code": "\nfloat mid = 0.;\n\nfloat cyl(vec3 p, float r, float h){\n    return max(length(p.xz) - r, abs(p.y)-h);\n}\n\nfloat spinnerCage(vec3 p, float id){\n\n   // p.xz +=0.5;\n    //unit of rotation \n    float a0 = float(floor(8. + 6.*(1.-id))) / pi; \n    //create an id for each \n    float a = round(atan(p.z, p.x) * a0) / a0;\n    \n    //push p to a new location along the vector (c,0,s) \n    //scaled by whatever\n    p = p - vec3(cos(a), 0.0, sin(a))/2.6 ;\n\n    \n    float segs = seggy(p-vec3(0.,-0.0,0.), vec3(0.), vec3(0.,0.14,0.));\n\n    \n    return segs;\n}\n\n\nfloat spinner(vec3 p){\n    float dist;\n    \n    vec3 sp = p;\n    \n    //T\n    sp.xz += +0.5;\n    sp.y += 0.3;\n    \n    \n    vec2 id = floor(sp.xz);\n    float ii = noise(id);\n    sp.y += ii*0.4+sin(iTime*ii)*0.3;\n    \n    sp.xz = mod(sp.xz+0.5,2.)-1.;//fract(sp.xz)-0.5;\n    \n    //R\n    sp.xz *= rot(iTime*(0.3+ii)*3.);\n    dist = cyl(sp,0.4,0.01);\n    \n    float node = cyl(sp-vec3(0.2,0.05,0.2),0.05,0.01);;//length(sp-vec3(0.2,0.05,0.2))-0.05;\n    dist = min(dist,node);\n    \n    float base = cyl(sp-vec3(0.,-0.4,0.),0.05, 0.4);\n    dist = min(dist,base);\n    \n    float cage = spinnerCage(sp,ii);\n    dist = min(dist,cage);\n    \n    float top = cyl(sp-vec3(0.,0.14,0.),0.4,0.01);\n    float cut = cyl(sp-vec3(0.,0.14,0.),0.36,0.014);\n    top = max(top, -cut);\n    dist = min(dist,top);\n    return dist;\n\n}\n\nfloat glow = 0.;\nfloat map(vec3 p){  \n\t\n    p.y+=0.9;\n    \n    float sphere_radius = 0.35;\n    vec3 sp = p;\n    float alle  = 1000.;\n    \n    sp = p;\n    sp.y += 0.5;\n    vec3 csp = sp;\n    sp.xz = fract(p.xz)-0.5;\n    \n    ////////////////////CYL!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    float ride = spinner(p);\n    \n    \n    /////////////////////SEGS////////////////////////////\n    vec2 id = floor(p.xz);\n    float ball_gross = fract(sin(dot(vec2(12.55,74.2),id))*452354.);\n    float t =  iTime/6.;\n    \n    \n    float gross = 1.3;\n    float depth = 0.6;\n    \n    float height = fbm2(id+t)*gross+depth;\n    float heightL = fbm2((id + vec2(0.,1.))+t)*gross+depth;\n    float heightR = fbm2((id + vec2(0.,-1.))+t)*gross+depth;\n    float heightV = fbm2((id + vec2(-1.,0.))+t)*gross+depth;\n    float heightH = fbm2((id + vec2(1.,0.))+t)*gross+depth;\n    \n    vec3 vor = vec3(-1.,heightV,0.);\n    vec3 hin = vec3(1.0,heightH,0.0);\n    vec3 links = vec3(0.,heightR,-1.);\n    vec3 rechts = vec3(0., heightL,1.0);\n    vec3 zentrum = vec3(0.,height,0.);\n    \n    \n    float k = seggy(sp, zentrum, vor);\n    float segs = k;\n    k = seggy(sp, zentrum, links);\n    segs = min(segs, k);\n    k = seggy(sp, zentrum, rechts);\n    segs = min(segs, k);\n    k = seggy(sp, zentrum, hin);\n    segs = min(segs, k);\n    \n    k = seggy(sp, zentrum, vec3(0.,-depth,0.));\n    segs = min(segs, k);\n    \n    alle = min(segs,alle);\n    \n    //#######################BALL0000000000000000000000000000000000\n    \n    \n    float ball = length(sp - vec3(0.,height,0.))-0.03-ball_gross*0.02;\n    \n    \n    \n    alle = min(alle, ball);\n    \n    ////////////////PLANE_____________________________________\n    float plane = sp.y+0.6;\n    \n    ////////////////////ID@!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    if(plane < alle && plane < segs && plane < ride)mid = 2.;\n    else if(ball < plane && ball < segs && ball < ride){\n        mid = 1.;\n        //glow += (0.00001/(0.75*pow((ball),2.)));\n        }\n    else if (segs < plane && segs < ball && segs < ride)mid = 0.;\n    else if (ride < plane && ride < ball)mid = 3.;\n    \n    //float ride = \n    alle = min(alle,ride);\n    return min(alle, plane);//-fbm4(p.xz));\n}\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = 0; i < 196; i++){\n\n        d = map(ro + rd*t);\n        if(abs(d)<.001 || t>FAR) break;        \n        t += d*0.5;\n    }\n    \n    return t;\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 14; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .02, .25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist>end) break; \n        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + .25, 1.); \n}\n/*\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(\n    vec3(map(p + e.xyy) - map(p - e.xyy), \n    map(p + e.yxy) - map(p - e.yxy),\t\n    map(p + e.yyx) - map(p - e.yyx)));\n}*/\n\nvec3 getNormal(vec3 p){\n    \n    float d = map(p);\n    vec2 e = vec2(0.001,0.);\n    \n    vec3 n = d - vec3(\n            map(p-e.xyy),\n            map(p-e.yxy),\n            map(p-e.yyx));\n            \n    return normalize(n);\n}\n\n//doColor routine from Shane\nvec4 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    vec3 ld = lp-sp; // Light direction vector.\n    float lDist = max(length(ld), .001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    // Attenuating the light, based on distance.\n    float atten = 1. / (1. + lDist*.2 + lDist*lDist*.1);\n    \n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 8.);\n    \n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = 0.5+0.5*cos(vec3(1.,2.,4.)+hash13(floor(sp.xzx+0.54))*10.);//getObjectColor(sp);\n    if(mid == 1.)objCol = vec3(.3,0.,0.7);\n    else if(mid == 2.){\n        float checkX = floor(sp.x*2.+0.5);\n        float checkY = floor(sp.z*2.+0.5);\n    \n        objCol = vec3(mod(checkX+checkY,2.))*0.5+0.25;\n        }\n    else if(mid == 3.)objCol = 0.5+0.5*cos(vec3(7.,4.,2.)+hash13(floor(sp.xzx+0.5))*10.);\n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = (objCol*(diff*3. + .15) + vec3(1., 0.95,1.)*spec*3.) * atten;\n    \n    \n    // Fog factor -- based on the distance from the camera.\n    float fogF = smoothstep(0., .95, t/FAR);\n    //\n    // Applying the background fog. Just black, in this case, but you could\n    // render sky, etc, as well.\n    vec3 sky = mix(vec3(0.8,0.3,0.0),vec3(0.),clamp(sp.y,0.,3.));\n    \n    \n    // Return the color. Performed once every pass... of which there are\n    // only two, in this particular instance.\n    return vec4(sceneCol,fogF);\n    \n}\n\n//Sky routine from Shane\nvec3 getSky(vec3 ro, vec3 rd){\n\n    vec3 sunDir = normalize(vec3(0.,-.5,1.));\n    float sun = max(dot(rd,sunDir),0.);\n    float horiz = pow(1.-max(rd.y,0.), 3.)*0.35;\n    \n    vec3 col = mix(vec3(0.09, 0.2, 0.5), \n                   vec3(0.7, 0.37, 0.035), \n                       sun*0.75);\n                       \n   col =  mix(col, vec3(1, 0.9,0.7), horiz);\n   //col =  mix(col, vec3(0.3,0.,0.), rd.y+0.1);\n   \n   col += 0.25*vec3(1.,0.7,0.4)*pow(sun,5.);\n   col += 0.25*vec3(1.,0.8,0.6)*pow(sun,64.);\n   col += 0.25*vec3(1.,0.9,0.7)*max(pow(sun,512.),0.3);\n   \n    vec3 sc = ro + rd*FAR*100.; \n    sc.y *= 3.;\n    \n    \n   return mix(col,vec3(1.,0.95,1.),\n              0.95*smoothstep(0.,1.,fbm4(.001*sc.xy))\n              *clamp(rd.y*4.,0.,1.));\n                   \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n\n    // Some cheap camera movement, for a bit of a look around. I use this far\n    // too often. I'm even beginning to bore myself at this point. :)\n    float cs = cos(iTime * .25), si = sin(iTime * .25);\n    float PosX = 1.0 - iMouse.x/iResolution.x*4. + .5;//0.2*2.*(rechts - links);\n    float PosY = 1.0 - iMouse.y/iResolution.y*4. + 0.5;\n    cs = cos(PosX), si = sin(PosX);\n    //rd.xy = mat2(cs, si, -si, cs)*rd.xy;\n    rd.xz = mat2(cs, si, -si, cs)*rd.xz;\n    //cs = cos(PosY), si = sin(PosY);\n    //rd.yz = mat2(cs, si, -si, cs)*rd.yz;\n    \n    // Ray origin. Doubling as the surface position, in this particular example.\n    // I hope that doesn't confuse anyone.\n    vec3 ro = vec3(0., 0., -2.+iTime);\n    \n    // Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0., 5., -0.5);\n    \n    \n    // FIRST PASS.\n    \n    float t = trace(ro, rd);\n    \n   \n    \n    // Advancing the ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n    \n    // Retrieving the normal at the hit point.\n    vec3 sn = getNormal(ro);\n\n\n    vec4 stuff = doColor(ro, rd, sn, lp, t);\n    vec3 sceneColor = stuff.xyz;\n    float fog = stuff.w;\n    \n    vec2 st = (fragCoord.xy)/iResolution.y;\n    float vig = st.x*st.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15);\n    \n    \n    vec3 sky = getSky(ro,rd);\n    \n    float sh = softShadow(ro +  sn*.0015, lp, 16.);\n    \n   sceneColor *= sh;\n    \n    rd = reflect(rd,sn);\n    vec3 reflected_stuff = texture(iChannel1,rd).rgb;\n    \n    sceneColor += reflected_stuff*0.13;\n    \n\n    \n    sceneColor = mix(sceneColor, sky, fog);\n    \n   // sceneColor = acesFilm(sceneColor);\n    //sceneColor += glow*0.003;\n\tfragColor = vec4(sqrt(clamp(sceneColor*vig, 0., 1.)), 1);\n  \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi acos(-1.)\n#define FAR 20.\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p ); \n    return f/0.9375;\n}\nfloat fbm2( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    //f += 0.1250*noise( p ); p = m*p*2.01;\n    //f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat seggy( vec3 P, vec3 A, vec3 B){\n    \n    //A point along a line segement from a to b\n    //P = A + t*(B-A);\n    \n    //the fact that the closest dstance from a point\n    //to te line will make a vector perpendicular\n    //that meansthe dot of that vector and the original\n    //line will be 0 (P-P3) is a vector from the best \n    //point on the line P3, to point in question P\n    //dot((P-P3),(B-A)) = 0\n    \n    //So we want to find the point on the line\n    //that is also the end point to a perpendicular\n    //line leading to out point in question\n    //so we substitute the point in question P\n    //with what P is in the first equation:\n    \n    //(A+t*(B-A)-P3)*(B-A)) = 0;\n    \n    //we expand by dotting (B-A) with everything in the\n    //first pair of bracekts:\n    //A*(B-A)+t*(B-A)*(B-A)-P3*(B-A) = 0\n    \n    //Rearrange\n    //A*(B-A) - P3*(B-A) + t*(B-A)*(B-A)\n    //(A-P3)*(B-A) + t*(B-A)*(B-A)\n    \n    //get t by it's self. That's the t value that leads to\n    //the Point on the third line that will give us\n    //a perp line to the point in question P\n    //t = dot((A-P3),(B-A)) / dot((B-A),(B-A));\n    \n    //from our derivation we know we'll use\n    //these two vectors in our calculation\n    vec3 AP = P-A;\n    vec3 BA = B-A;\n    \n    //getting t\n    float t = clamp(dot(AP,BA)/\n                    dot(BA,BA), \n                    0., 1.);\n    \n    //getting point 3\n    vec3 P3 = A + t*BA;       \n    \n    //getting the dist from point in question to\n    //the best point on line and subtracting some stuff\n    //to get the right radius\n    float dist = length(P - P3) - 0.003 - 0.01;\n    //returning dist\n    return dist;\n    \n    //nothing else happends in this function...\n    \n    //still nothing...\n    \n    //and then suddenly!...\n    \n    //nope still nothing.\n}\nmat2 rot(float a){\n    float cs = cos(a),si = sin(a);\n    return mat2(cs, si, -si, cs);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}