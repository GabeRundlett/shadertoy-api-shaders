{
    "Shader": {
        "info": {
            "date": "1635174616",
            "description": "A figure-8 knot, as described by François Guéritaud, Saul Schleimer, and Henry Segerman here: [url]http://gallery.bridgesmathart.org/exhibitions/2019-icerm-illustrating-mathematics/henrys[/url].",
            "flags": 0,
            "hasliked": 0,
            "id": "7sGSRd",
            "likes": 100,
            "name": "Figure-8 Knot",
            "published": 3,
            "tags": [
                "3d",
                "knot",
                "projective"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 2731
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2021 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n// This is a figure-8 knot, as described by François Guéritaud, Saul\n// Schleimer, and Henry Segerman here:\n//\n// http://gallery.bridgesmathart.org/exhibitions/2019-icerm-illustrating-mathematics/henrys\n// \n// It's defined in S3 (ie, the surface of a 4-dimensional hypersphere),\n// and then projected to R3 (regular 3D space) through a stereographic\n// projection. The extrussion of the path into a tube is done in R3.\n// I Tried adaptive subdivision, and worked well, but not completely.\n\n#define AA 1              // make 2 on fast machines\n\nconst int   kNum = 256;   // subdivisions. make 1024 on fast machines\nconst float kRad = 0.06;  // thickness\n\n\n// knot\nvec3 knot( in float t )\n{\n    t *= 6.283185;\n\n    // knot in S3\n    const float e = 0.16;\n    const float h = 0.25;\n    float a = e*sin(4.0*t);\n    float b = 1.0-a*a;\n    vec4 q = vec4 ( \n      b*(h*cos(t)+(1.0-h)*cos(3.0*t)),\n      b*(2.0*sqrt(h-h*h)*sin(2.0*t)),\n      a*(2.0),\n      b*(h*sin(t)-(1.0-h)*sin(3.0*t))\n      )\n      / (1.0+a*a);\n    \n    // rotate in the xw plane (in S3)\n    float a1 = iTime*6.283185/10.0;\n    q.xw *= mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n    \n    // stereographic projection from S3 to R3\n    vec3 p = q.xyz/(1.0-q.w);\n  \n    // scale\n    return p * 0.25;\n}\n\n//-------------------------------------------------------\n\n// intersects a capsule (single cap)\n// https://iquilezles.org/articles/intersectors\nvec4 iCylinder( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, float ra, \n                out float v )\n{\n    vec4 res = vec4(-1.0);\n\n    v = 0.0;\n    vec3 ba = pb-pa;\n    vec3 oc = ro-pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    float ocrd = dot(oc,rd);\n    float ococ = dot(oc,oc);\n      \n    float a = baba - bard*bard;\n    float b = baba*ocrd - baoc*bard;\n    float c = baba*ococ - baoc*baoc - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h>0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        // body\n        float y = baoc + t*bard;\n        if( y>0.0 && y<baba )\n        {\n            v = y/baba;\n            res = vec4(t,(oc+t*rd-ba*v)/ra);\n        }\n        // sphere cap\n        else \n        {\n            h = ocrd*ocrd - ococ + ra*ra;\n            if( h>0.0 )\n            {\n                t = -ocrd - sqrt(h);\n                res = vec4(t,(oc+t*rd)/ra);\n            }\n        }\n    }\n    \n    return res;\n}\n\n// intersects a capsule\n// https://iquilezles.org/articles/intersectors\nbool sCylinder( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, float ra )\n{\n    vec3 ba = pb-pa;\n    vec3 oc = ro-pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    float ocrd = dot(oc,rd);\n    float ococ = dot(oc,oc);\n    \n    float a = baba - bard*bard;\n    float b = baba*ocrd - baoc*bard;\n    float c = baba*ococ - baoc*baoc - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h>0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        // body\n        float y = baoc + t*bard;\n        if( t>0.0 && y>0.0 && y<baba ) return true;\n        // sphere cap\n        h = ocrd*ocrd - ococ + ra*ra;\n        if( h>0.0 )\n        {\n            //if( h*h<-ocrd*abs(ocrd) ) return true;\n            t = -ocrd - sqrt(h);\n            if( t>0.0 ) return true;\n        }\n    }\n    \n    return false;\n}\n\n// intersects the knot\nvec4 intersect( in vec3 ro, in vec3 rd, out float resV )\n{\n    // subdivide the knot, and find intersections\n    float   v = 0.0;\n    vec4 tnor = vec4(1e20);\n    vec3   op = knot(0.0);\n    for( int i=1; i<=kNum; i++ )\n    {\n        // parameter\n        float t = float(i)/float(kNum);\n\n        // evaluate knot\n        vec3 p = knot(t);\n\n        // segments\n        float tmpv;\n        vec4 tmp = iCylinder( ro, rd, op, p, kRad, tmpv );\n        if( tmp.x>0.0 && tmp.x<tnor.x ) { tnor = tmp; v=t+(tmpv-1.0)/float(kNum); }\n\n        op = p;\n    }\n    \n    resV = v;\n\n    return tnor;\n}\n\n// intersects the knot\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    // subdivide the knot, and find intersections\n    vec3 op = knot(0.0);\n    for( int i=1; i<=kNum; i++ )\n    {\n        // parameter\n        float t = float(i)/float(kNum);\n        \n        // evaluate knot\n        vec3 p = knot(t);\n        \n        // segments\n        if( sCylinder( ro, rd, op, p, kRad ) ) return 0.0;\n\n        op = p;\n    }\n    \n    return 1.0;\n}\n\n// do coloring and lighting\nvec3 shade( in vec3 pos, in vec3 nor, in vec3 rd, in float hm )\n{\n    // material - base color\n    vec3 mate = 0.5 + 0.5*cos(hm*6.283185+vec3(0.0,2.0,4.0));\n\n    // material - white stripes\n    vec3 cen = knot(hm); \n    vec3 w = normalize(knot(hm+0.001)-cen);\n    vec3 v = vec3(w.y,-w.x,0.0)/length(w.xy);\n    vec3 u = normalize(cross(v,w));\n    float an = atan( dot(pos-cen,u), dot(pos-cen,v) );\n    float ar = an - 30.0*hm + iTime;\n    mate += 1.5*smoothstep(-0.3,0.8,sin(6.283185*ar));\n\n    // sky lighting\n    vec3 ref = reflect(rd,nor);\n    float dif = 0.5+0.5*nor.y;\n    float spe = smoothstep(0.1,0.2,ref.y);\n    spe *= dif;\n    spe *= 0.04 + 0.96*pow( clamp(1.0+dot(rd,nor), 0.0, 1.0), 5.0 );\n    if( spe>0.001 ) spe *= shadow(pos+nor*0.001, ref);\n    vec3 col = 0.6*mate*vec3(1.0)*dif + spe*6.0;\n\n    // sss\n    float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n    col += fre*fre*(0.5+0.5*mate)*(0.2+0.8*dif);\n\n    // self occlusion\n    float occ = 0.0;\n    for( int i=1; i<=kNum/4; i++ )\n    {\n        float h = float(i)/float(kNum/4);\n        vec3  d = knot(h) - pos;\n        float l2 = dot(d,d);\n        float l = sqrt(l2);\n        float f = dot(d/l,nor);\n        occ = max(occ, f*exp2(-l2*8.0) );\n        occ = max(occ, f*1.5*kRad*kRad/l2 );\n    }\n    col *= 1.0-occ;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.0*iTime;\n\tvec3 ro = vec3( 1.0*sin(6.283185*an), 0.0, 1.0*cos(6.283185*an) );\n    vec3 ta = vec3( 0.0, 0.02, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // background\n        vec3 col = vec3(0.17*(1.0-0.15*dot(p,p))*smoothstep(-1.0,1.0,rd.y));\n\n        // raytrace knot\n        float hm;\n        vec4 tnor = intersect( ro, rd, hm );\n        if( tnor.x<1e19 )\n        {\n            col = shade( ro+tnor.x*rd, tnor.yzw, rd, hm );\n        }\n        \n        // gain\n        col *= 1.4/(1.0+col);\n        // tint\n        col = pow( col, vec3(0.8,0.95,1.0) );\n        \n        // color to perceptual space\t\n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n \n    // remove color banding through dithering\n    tot += (1.0/255.0)*fract(sin(fragCoord.x*7.0+17.0*fragCoord.y)*1.317);\n\n\tfragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}