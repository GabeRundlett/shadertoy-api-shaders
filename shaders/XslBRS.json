{
    "Shader": {
        "info": {
            "date": "1496717089",
            "description": "I am happy with what I have done yesterday, so keep playing with it little bit.\nI used code from @patriciogv http://patriciogonzalezvivo.com in bufA for cloud.\nAnd some ugly hardcoded numbers here and there... \nYes, love sea, cloud, moon and that's it..:D",
            "flags": 96,
            "hasliked": 0,
            "id": "XslBRS",
            "likes": 28,
            "name": "27/100",
            "published": 3,
            "tags": [
                "wave",
                "sea",
                "cloud",
                "moon"
            ],
            "usePreview": 1,
            "username": "yahe",
            "viewed": 1125
        },
        "renderpass": [
            {
                "code": "// Based on Dessert Chase https://www.shadertoy.com/view/Msf3DB\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\n//  1 out, 2 in...\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n    \nfloat pn(vec3 p) {\n\t//noise function by CPU https://www.shadertoy.com/view/4sfGRH\n    vec3 i = floor(p); \n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n    vec3 f = cos((p-i)*3.141592653589793)*(-.5) + .5;  \n\ta = mix(sin(cos(a)*a), sin(cos(1.+a)*(1.+a)), f.x);\n    a.xy = mix(a.xz, a.yw, f.y) + sin(iTime);   \n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat getNoise(vec2 pos, float pulse) {\n\tvec3 q = vec3(pos * 2., pos.x-pos.y + iTime * 0.3);\n\tfloat b = (pulse * 1.6) + pn(q * 2.) + 2.8;\n\tb +=  .25 * pn(q * 4.);\n\tb +=  .25  * pn(q * 8.);\n\tb +=  .5  * pn(vec3(pos, pos.x-pos.y + iTime * 0.3) * 12.23);\n\tb = pow(b,0.5);\t\n\treturn b;\n}\n\nvec2 rotate(vec2 uv, float d)\n{\n\tvec2 tuv = uv;\t\t\n\tuv.x = tuv.x*cos(d)-tuv.y*sin(d);\n\tuv.y = tuv.x*sin(d)+tuv.y*cos(d);\n\treturn uv;\n}\n\n\nfloat stars(vec2 uv, float t) {\n    t*=3.;\n    \n    float n1 = hash12(uv*10000.);\n    float n2 = hash12(uv*11234.);\n    float alpha1 = pow(n1, 20.);\n    float alpha2 = pow(n2, 20.);\n    \n    float twinkle = sin((uv.x-t+cos(uv.y*20.+t))*10.);\n    twinkle *= cos((uv.y*.234-t*3.24+sin(uv.x*12.3+t*.243))*7.34);\n    twinkle = (twinkle + 1.)/2.;\n    return alpha1 * alpha2 * twinkle;\n}\n\n\nvec3 sky(vec2 uv)\n{\n    vec3 pix = vec3(texture(iChannel1, uv.xy/4. + .5).xyz);\n    \n    vec2 s = vec2(.0),c0 = vec2(.0);\n    vec3 pixel = vec3(0.);\n    float t = iTime * 0.007,d0 = 0.0,r = 0.0;\n\tfor(float i=0.0; i<10.0; i+=1.0) {\n       s = vec2(t + fract(sin(i*0.9)*37.0),t + fract(cos(i*2.5)*37.0));\n       c0.x = cos(t*50.);\n       c0.y = sin(t*50.);\n       r = fract(sin((i*0.6))*5.0) * 0.8;\n       d0 = length(uv - c0);\n       pixel[int( mod(i,3.0))] += smoothstep(d0*0.05,d0,r*r)*0.47;\n    }\n    vec3 co = vec3(pixel);\n    \n\treturn mix(co * min(.3, (uv.y+50.)/300.), max(pix * min(.5, (uv.y+50.)/200.), 0.), .7);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y + 0.06*(sin(iTime)+2.) - 0.2;\n}\n\nfloat dunes(in vec3 pos)\n{\n\treturn 0.25 * sin(pos.x + pn(pos))* sin(pos.x);\n}\n\nvec2 map(in vec3 pos)\n{\n\treturn vec2(sdPlane(pos) + dunes(pos) , 1.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<60; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<30; i++ )\n    {\n\t\tif( t<maxt )\n\t\t{\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += 0.02;\n\t\t}\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nvec3 render(in vec3 ro, in vec3 rd, in vec2 uv)\n{\n\tvec3 col = sky(uv);\n\tvec2 res = castRay(ro, rd, 20.0);\t\n\tfloat t = res.x;\n\tfloat m = res.y;\n\tif(m>-0.5)\n\t{\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n\n\t\tvec3 newcol = vec3(texture(iChannel0, res.xy).xyz);//vec3(0.25, 0.22, 0.1);\n\t\t\n        float ao = calcAO( pos, nor );\n\n\t\tvec3 lig = normalize( vec3(-sin(iTime)*0.8, 0.8, -4.7) );\n\t\tfloat amb = clamp( 0.5+0.2*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n\t\tfloat sh = 1.0;\n\t\tif( dif>0.001 ) { sh = softshadow( pos, lig, 0.02, 10.0, 7.0 ); dif *= sh; }\n\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 0.20*amb*vec3(0.10,0.11,0.13)*ao;\n        brdf += 0.20*bac*vec3(0.15,0.15,0.15)*ao;\n        brdf += 1.20*dif*vec3(1.00,0.90,0.70);\n\n\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 0.2 );\n\t\tfloat spe = sh*pow(pp,32.0);\n\t\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\t\tfloat fog = exp(-0.05 * res.x*res.x);\n\t\tnewcol = newcol*brdf + vec3(1.0)*newcol*spe + 0.2*fre*(0.5+0.5*newcol) ;\t\n\t\tcol = mix(col, newcol, fog);\n\t}\n\t//col *= exp( -0.01*t*t );\n\treturn clamp(col, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    //p.y = -abs(p.y);\n\tvec3 ro = vec3( sin(iTime)*0.2- iTime, 0.5, 2.5 - 0.);\n\tvec3 ta = vec3( -0.0, -0.0, 0.0 - iTime);\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n\t\n    vec3 col = render( ro, rd, p );\n\t\n\tcol = sqrt( col )*1.9;\n\n    fragColor=vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 9650,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/tapesandtubes/sunmoonstars"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (in vec2 _st) { \n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))* \n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nfloat fbm ( in vec2 _st) {\n    int numOctaves = int(min(10.0, log2(iResolution.x))) - 3;\n    \n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), \n                    -sin(0.5), cos(0.50));\n    \n    // Unrolled loop; because GL won't let me compare against a non-constant.\n    if (numOctaves >= 1) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    if (numOctaves >= 2) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    if (numOctaves >= 3) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    if (numOctaves >= 4) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    if (numOctaves >= 5) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    if (numOctaves >= 6) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    if (numOctaves >= 7) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    if (numOctaves >= 8) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    if (numOctaves >= 9) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    if (numOctaves >= 10) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy*3.;\n    // st += st * abs(sin(u_time*0.1)*3.0);\n    vec3 color = vec3(0.0);\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st + 0.00*iTime);\n    q.y = fbm( st + vec2(1.0));\n\n    vec2 r = vec2(0.);\n    r.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ 0.15*iTime );\n    r.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ 0.126*iTime);\n\n    float f = fbm(st+r);\n\n    color = mix(vec3(0.201961,0.619608,0.666667),\n                vec3(0.666667,0.666667,0.498039),\n                clamp((f*f)*4.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0,0,0.164706),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.8,1,1),\n                clamp(length(r.x),0.0,1.0));\n\n    fragColor = vec4((f*f*f+.3*f*f+.1*f)*color,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}