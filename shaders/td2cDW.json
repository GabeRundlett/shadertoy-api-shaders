{
    "Shader": {
        "info": {
            "date": "1586696921",
            "description": "My first public shader, I'm playing around with twists and lattices at the moment, want to do 3D fractally stuff next, if you have any resources I'll gladly accept to read them :)\n\nPlease roast me in an educative way, I'm willing to learn :)",
            "flags": 0,
            "hasliked": 0,
            "id": "td2cDW",
            "likes": 13,
            "name": "Collapse",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "raymarching",
                "ray",
                "cube",
                "cubes",
                "marching"
            ],
            "usePreview": 0,
            "username": "WaifuFarmer",
            "viewed": 671
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 1280\n#define MAX_DIST 1280.\n#define E 0.01\n#define PI 3.141592\n#define MYTIME iTime * 1.\n\n// Turn to 1 to activate displacement mapping\n#define DISPLACEMENT_MAPPING 1\n\nvec3 rotX(vec3 v, float a)\n{\n    return vec3(v.x, v.y * cos(a) - v.z * sin(a), v.y * sin(a) + v.z * cos(a));\n}\n\nvec3 rotY(vec3 v, float a)\n{\n    return vec3(v.x * cos(a) + v.z * sin(a), v.y, v.z * cos(a) - v.x * sin(a));\n}\n\nvec3 rotZ(vec3 v, float a)\n{\n    return vec3(v.x * cos(a) - v.y * sin(a), v.x * sin(a) + v.y * cos(a), v.z);\n}\n\nvec3 modSDF(vec3 p, vec3 c)\n{\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\nvec3 modSDFlim( in vec3 p, in float c, in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nvec3 twistSDF(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\nfloat sdfBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\n\nfloat scene(vec3 p)\n{\n    float d = 10000.;\n    float bd1 = sdfBox(\n        twistSDF(\n            modSDFlim(\n                twistSDF(p - vec3(0., 12., 0.), smoothstep(0.30, 0.20, abs(sin(MYTIME))) * 0.02),\n                12., vec3(1. + smoothstep(0.45, 0.55, abs(sin(MYTIME))) * floor(abs(mod(MYTIME / (PI), 16.) - 8.)), 1. + smoothstep(0.45, 0.55, abs(sin(MYTIME))) * floor(abs(mod(MYTIME / (PI), 16.) - 8.)), 1. + smoothstep(0.45, 0.55, abs(sin(MYTIME))))), smoothstep(0.70, 0.80, abs(sin(MYTIME))) * -0.1),\n                       vec3(4. + smoothstep(0.25, 0.75, abs(sin(MYTIME * 2.))),4. + smoothstep(0.25, 0.75, abs(sin(MYTIME * 2.))),4. + smoothstep(0.25, 0.75, abs(sin(MYTIME * 2.)))));\n    if (DISPLACEMENT_MAPPING == 1)\n    \tbd1 += sin(p.x / 2. * abs(mod(iTime, 6.) - 3.)) * 1. * sin(p.y / 2. * abs(mod(iTime, 6.) - 3.)) * 1. * sin(p.z / 2. * abs(mod(iTime, 6.) - 3.)) * 1.;\n    float bd2 = sdfBox(modSDF(p - vec3(0., -24., 0.), vec3(10., 0., 10.)), vec3(4.5,4.5,4.5)) * 1.;\n    d = min(bd1, d);\n    d = min(bd2, d);\n    return d;\n}\n\n\nvec2 march(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n    float mind = 10000.;\n    for (int steps = 0; steps < MAX_STEPS; steps++)\n    {\n        vec3 p = ro + rd * dO;\n        float dS = scene(p);\n        if (steps == 3)\n            mind = dS;\n        dO += dS;\n        if (dS < E || dO > MAX_DIST)\n            break;\n    }\n    return vec2(dO, mind);\n}\n\nvec3 normal(vec3 p)\n{\n    float d = scene(p);\n    vec2 e = vec2(0.001, 0);\n    \n    vec3 n = d - vec3(\n        \t\tscene(p - e.xyy),\n                scene(p - e.yxy),\n                scene(p - e.yyx));\n    return (normalize(n));\n}\n\nfloat light(vec3 p, vec3 n)\n{\n    vec3 lightPos = vec3(-250. * sin(MYTIME), 75., -250. * cos(MYTIME));\n    vec3 l = normalize(lightPos - p);\n    \n    float dif = clamp(dot(l, n), 0., 1.);\n    vec2 d = march(p+n*E * 30., l);\n    if (d.x < length(lightPos - p))\n        \tdif *= 0.1;\n    \n    return (dif*0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / iResolution.y);\n    \n    vec3 ro = vec3(-235. * sin(iTime / 2.), 15. + sin(iTime / 2.) * 15., -235. * cos(iTime / 2.));\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    //rd = rotX(rd, PI / 8.);\n    rd = rotY(rd, iTime / 2.);\n    \n    vec2 d = march(ro, rd);\n    \n    vec3 p = ro + rd * d.x;\n    vec3 n = normal(p);\n    p += n * E * 10.;\n    float dif = light(p, n);\n\tvec3 col = vec3(0);\n    if (d.x < MAX_DIST * 0.9)\n    {\n    \tcol = blackbody(d.y* (p.y + 19.2) * 2. * (50. - abs(mod(p.y + MYTIME * 50., 100.) - 50.)));\n        col.xyz = col.zyx;\n        col.xy *= 0.5;\n        col.x *= uv.x;\n        col.y *= uv.y;\n        if (col.z > 0.001)\n        {\n        \tcol = 0.5 * (1. - col);\n            col = vec3(col.z, col.z, (col.x + col.y) / 2.);\n      \t    col.x = col.x / 2. + col.z * uv.x;\n      \t    col.y = col.y / 2. + col.z * uv.y;\n        }\n        col /= 2.;\n    }\n    col +=  vec3(dif / 2.,dif / 2., dif / 2.);\n    vec3 rr = rd - (2. * n * (dot(rd, n)));\n    vec2 d2 = march(p, rr);\n    vec3 p2 = p + rr * d2.x;\n    vec3 n2 = normal(p2);\n    dif = light(p2, n2);\n    if (d.x < MAX_DIST * 0.9)\n    {\n    \tvec3 col2 = blackbody(d2.y* (p.y + 19.2) * 2. * (50. - abs(mod(p.x * p.z / 30. + 25. + MYTIME * 50., 100.) - 50.)));\n        col2 /= 1.2;\n        col += col2;\n    }\n    col += vec3(dif / 2., dif / 2., dif / 2.);\n    //col = pow(col, vec3(0.454545));\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}