{
    "Shader": {
        "info": {
            "date": "1684845941",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!\n(mouseable)\nHave you tried full screen?\n",
            "flags": 0,
            "hasliked": 0,
            "id": "dlG3WK",
            "likes": 19,
            "name": "Year of Truchets #023",
            "published": 3,
            "tags": [
                "3d",
                "truchet",
                "rainbow",
                "flyby",
                "path"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 261
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #023\n    05/23/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    Unstyled, unbothered, moisturized, happy, in my lane, flourishing.\n\n    https://soundcloud.com/monster-magnet-433718279/premiere-cypherpunx-feat-sian\n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.141592653\n#define PI2        6.283185307\n\n#define MAX_DIST   60.\n#define MIN_DIST   1e-4\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.73,59.71)+iDate.z))*4832.3234);}\n\n//@iq sdf's + extrude\nfloat opx(in float d, in float z, in float h){\n    vec2 w = vec2( d, abs(z) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\nfloat box(vec2 p,vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.)) + min(max(d.x,d.y),0.);\n}\n\n//@Shane - path function\nvec2 path(in float z){\n    vec2 p1 =vec2(7.38*sin(z *.15)+5.38*cos(z *.075),2.4*cos(z *.0945));\n    vec2 p2 =vec2(5.2*sin(z *.089),2.31*sin(z *.127)+3.5*cos(z *.095));\n    return (p1 - p2)*.3;\n}\n\nmat2 r90;\nfloat tspeed = 0.;\n\nvec3 lp = vec3(0);\nconst float sz = 2.65;\nconst float hf = sz/2.;\nconst float rd = .025;\n\nvec2 map (in vec3 p) {\n \tvec2 res = vec2(1e5,0);\n    p.xy += hf;\n\n \tvec2 tun = p.xy - path(p.z);\n    vec3 q = vec3(tun,p.z),\n        id = floor((q + hf)/sz);\n\n    float thick  = .0825+.0625*sin(p.z*.75);\n          thick -= .0125*cos(p.y*.62)+.0125*sin(p.x*1.25);\n    \n    float chk = mod(id.y+mod(id.z+id.x,2.),2.)*2.-1.;\n    q = mod(q+hf,sz)-hf;\n    \n    float hs = hash21(id.xz+id.y);\n    float xhs = fract(2.33*hs+id.y);\n\n    if (hs >.5) q.xz *= r90;\n    if (chk>.5) q.zy *= r90;\n\n    vec3 q1,q2,q3;\n    float trh,trx,jre;\n\n    if(xhs>.65) {\n        q1 = q;\n        q2 = q + vec3(0,hf,hf);\n        q3 = q - vec3(0,hf,hf);\n   \n        trh = opx(box(q1.xz,vec2(sz,thick)),q1.y,thick)-rd;\n        trx = opx(abs(length(q2.yz)-hf)-thick,q.x,thick)-rd;\n        jre = opx(abs(length(q3.yz)-hf)-thick,q.x,thick)-rd;\n    } else {\n        q1 = q + vec3(hf,0,-hf);\n        q2 = q + vec3(0,hf,hf);\n        q3 = q - vec3(hf,hf,0);\n \n        trh = opx(abs(length(q1.xz)-hf)-thick,q.y,thick)-rd;\n        trx = opx(abs(length(q2.yz)-hf)-thick,q.x,thick)-rd;\n        jre = opx(abs(length(q3.xy)-hf)-thick,q.z,thick)-rd;\n    }\n    \n    if(trh<res.x ) res = vec2(trh,2.);\n    if(trx<res.x ) res = vec2(trx,3.);\n    if(jre<res.x ) res = vec2(jre,4.);\n\n \treturn res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*1.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\n//@iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1., 0., 1.0 );\n    return c.z * mix( vec3(1), rgb, c.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // precal\n    tspeed = iTime*1.25;\n    r90=rot(1.5707);\n\n    vec3 C =vec3(0);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 ro = vec3(0,0,.1);\n    vec3 rd = normalize(vec3(uv,-1.));\n\n    // mouse //\n    float x = M.xy==vec2(0)||(M.z<1.) ? (T*.0095)*PI2 : -(M.y/R.y*.8-.4)*PI2;\n    float y = M.xy==vec2(0)||(M.z<1.) ? (T*-.0125)*PI2 : -(M.x/R.x*2.-1.)*PI2;\n\n    mat2 rx = rot(x), ry = rot(y);\n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n\n    ro.z -= tspeed;\n    ro.xy += path(ro.z);\n\n    float d,m;\n    vec3 p = vec3(0);\n\n    for(int i=0;i<98;i++) {\n        p = ro+rd*d;\n        vec2 ray = map(p);\n        d += i<32? ray.x*.35 : ray.x * .85;\n        m = ray.y;\n        if(ray.x<MIN_DIST*d||d>MAX_DIST)break;\n    }\n\n    if(d<MAX_DIST) {\n        C = hsv2rgb(vec3(clamp(d*.035,0.,1.)+T*.05,1.,.5));\n    } \n    \n    // fog level\n    C = mix(vec3(.01), C, exp(-.00125*d*d*d));\n\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}