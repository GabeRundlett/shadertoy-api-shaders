{
    "Shader": {
        "info": {
            "date": "1587071271",
            "description": "Concentric spheres, inspired by [url]https://www.shadertoy.com/view/wd2cWW[/url] by ZiMMaBuE.\n\nMouse moves things around, eg. changes the lighting and the lurid background.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdByR3",
            "likes": 4,
            "name": "Concentricity",
            "published": 3,
            "tags": [
                "escher",
                "concentric",
                "octahedral",
                "rinds"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 402
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Concentricity\n// Matthew Arcus, mla, 2020\n//\n// Octahedral symmetry again.\n//\n// Inspired by: https://www.shadertoy.com/view/wd2cWW\n//\n// Nested spherical disdyakis dodecahedrons (this is actually what they are\n// called: https://en.wikipedia.org/wiki/Disdyakis_dodecahedron)\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint AA = 1; // Set to 2 for quality\n\nvec3 light = vec3(0,-2,1); // Position of light\nfloat eradius = 0.03; // Thickness of an edge\nfloat eyedist = 2.5;  // Eye is at (0,0,eyedist);\nfloat PI = 3.1415927; \n\n// Raymarching configuration.\nint maxsteps = 100;\nfloat precis = 1e-3; \n\nbool dorotate = false;\n\n// Find the distance to a spherical segment, encapsulated in m.\n// m maps p to nearest point in some subspace (ie. a plane).\nfloat ssegment(vec3 p, mat3 m) {\n  vec3 p1 = normalize(m*p);\n  // And return the 'distance' to the closest point.\n  float len = length(p);\n  float x = distance(p/len,p1);    // Distance on surface\n  float y = len-1.0; // Radial distance\n  return max(x,abs(y))-eradius;\n}\n\n// Matrix for segment through q and r - take a point p,\n// Use q and r as basis vectors for subspace, so first\n// take dot products with q and r, then map to coordinates\n// in that basis (matrix m), then map back to R3. This is\n// then the nearest point to p in the subspace.\n// Assumes q and r normalized\nmat3 mkmatrix(vec3 q, vec3 r) {\n  mat2 m = inverse(mat2(1,dot(q,r),dot(q,r),1));\n  return mat2x3(q,r)*m*transpose(mat2x3(q,r));\n}\n\nmat3 m0,m1,m2;\nvec4 q0,q1,q2,qbg,qlight;\n\nvoid init() {\n  vec3 A = vec3(1,0,0);\n  vec3 B = vec3(0,1,0);\n  vec3 C = vec3(0,0,1);\n  // The midpoints of the sides, named for opposites\n  vec3 A1 = normalize(0.5*(B+C));\n  vec3 B1 = normalize(0.5*(C+A));\n  vec3 C1 = normalize(0.5*(A+B));\n  m0 = mkmatrix(A,B);\n  m1 = mkmatrix(A,A1);\n  m2 = mkmatrix(C,C1);\n\n  float t = 0.1*iTime;\n  q0 = vec4(sin(t)*normalize(vec3(1,1,0)),cos(t));\n  q1 = vec4(sin(t)*normalize(-vec3(1,1,1)),cos(t));\n  q2 = vec4(sin(t)*normalize(vec3(0,1,1)),cos(t));\n  qbg = vec4(sin(t)*normalize(vec3(1,0,1)),cos(t));\n  qlight = vec4(sin(t)*normalize(vec3(0,1,0.5)),cos(t));\n}\n\nfloat de0(vec3 p, float k) {\n  p *= k;\n  p = abs(p); // Map to single face - skip this to see single face.\n  // Sort the coordinates to map to fundamental region.\n  if (p.x < p.y) p.xy = p.yx;\n  if (p.y < p.z) p.yz = p.zy;\n  if (p.x < p.y) p.xy = p.yx;\n\n  float d = 1e8;\n  d = min(d,ssegment(p,m0));\n  d = min(d,ssegment(p,m1));\n  d = min(d,ssegment(p,m2));\n  return d/k;\n}\n\n// Quaternion multiplication\nvec4 qmul(vec4 p, vec4 q) {\n  vec3 P = p.xyz, Q = q.xyz;\n  return vec4(p.w*Q+q.w*P+cross(P,Q),p.w*q.w-dot(P,Q));\n}\n\nvec4 qconj(vec4 p) {\n  return vec4(-p.xyz,p.w);\n}\n\n// Might be better to turn into a matrix.\nvec3 qrot(vec3 p, vec4 q) {\n  vec4 r = qmul(qconj(q),qmul(vec4(p,0),q));\n  return r.xyz;\n}\n\nfloat de(vec3 p) {\n  float d = 1e8;\n  float k = 1.2;\n  d = min(d,de0(qrot(p,q0),k));\n  d = min(d,de0(qrot(p,q1),1.0));\n  d = min(d,de0(qrot(p,q2),1.0/k));\n  return d;\n}\n\n// Get the normal of the surface at point p.\nvec3 getnormal(vec3 p) {\n  float eps = 0.001;\n  vec2 e = vec2(eps,0);\n  return normalize(vec3(de(p + e.xyy) - de(p - e.xyy),\n                        de(p + e.yxy) - de(p - e.yxy),\n                        de(p + e.yyx) - de(p - e.yyx)));\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Rotate according to mouse position\nvec3 transformframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  // autorotation\n  if (dorotate) {\n    p.yz = rotate(p.yz,-iTime*0.125);\n    p.zx = rotate(p.zx,iTime*0.1);\n  }\n  return p;\n}\n\nvec3 getbasecolor(int type) {\n  return vec3(0.75,1,0.75);\n}\n\nvec3 getbackground(vec3 r) {\n  vec3 col = qrot(r,qbg);\n  col = abs(col);\n  col = pow(col,vec3(1.5));\n  return col; // Colourful fun\n  return vec3(0,0,0.1); // The more sober option.\n}\n\nfloat maxdist = 10.0;\nfloat march(vec3 q, vec3 r) {\n  float t = 0.0;\n  for (int i = 0; i < maxsteps; i++) {\n    vec3 p = q+t*r;\n    float d = de(p);\n    if (abs(d) < precis) return t; // Close enough to the surface.\n    t += d;\n    if (t > maxdist) break;\n  }\n  return -1.0;\n}\n\nvec3 raycolor(vec3 q, vec3 r) {\n  float t = march(q,r);\n  if (t < 0.0) return getbackground(r);\n  // Get the surface point that has been hit,\n  vec3 p = q+t*r;\n  // and the normal at that point.\n  vec3 normal = getnormal(p);\n  if (dot(normal,r) > 0.0) normal = vec3(0);\n  \n  // Apply lighting. This is a basic \"Lambertian\" model.\n  vec3 lightdir = normalize(light-p);\n  vec3 color = getbasecolor(0);\n  float ambient = 0.3;\n  float diffuse = 0.7*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+ diffuse;\n  color = mix(color,getbackground(r),t/maxdist); // Fog\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  init();\n  maxdist = eyedist + 1.0;\n  vec3 eye = vec3(0,0,eyedist);\n  eye = transformframe(eye);\n  light = qrot(light,qlight);\n  light = transformframe(light);\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n      vec3 ray = vec3(z,-2);\n      ray = transformframe(ray);\n      ray = normalize(ray);\n      col += raycolor(eye,ray);\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545)); // Gamma\n  fragColor = vec4(col,1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}