{
    "Shader": {
        "info": {
            "date": "1563567704",
            "description": "bicubic on the left, bilinear on the right.\n4 samples instead of 16 using tex-filtering.\ncalculates mipmapping/bias (control with LMB)\nFor more details, See http://vec3.ca/bicubic-filtering-in-fewer-taps/",
            "flags": 0,
            "hasliked": 0,
            "id": "tlXSR2",
            "likes": 3,
            "name": "Tex-Filtering: Higher Order Bias",
            "published": 3,
            "tags": [
                "texture",
                "sampling",
                "catmullrom",
                "catmull",
                "rom"
            ],
            "usePreview": 0,
            "username": "hornet",
            "viewed": 577
        },
        "renderpass": [
            {
                "code": "vec4 sampleTex( vec2 uv, float lambda )\n{\n    return textureLod( iChannel0, uv, lambda );\n}\n\n\n\n////////////////////////////////////\n//note: range [-2;2]\n//note: not normalized\nfloat Mitchell1D(float x)\n{\n    //const float B = 0.0; //Catmull-Rom?\n\tconst float B = 1.0/3.0; //Mitchell\n\tconst float C = 0.5 * (1.0-B);\n\tx = abs( 2.0 * x );\n    if ( x > 2.0 )\n        return 0.0;\n\tif (x > 1.0)\n\t\treturn ((-B - 6.0*C) * x*x*x + (6.0*B + 30.0*C) * x*x + (-12.0*B - 48.0*C) * x + (8.0*B + 24.0*C)) * (1.0/6.0);\n\telse\n\t\treturn ((12.0 - 9.0*B - 6.0*C) * x*x*x + (-18.0 + 12.0*B + 6.0*C) * x*x + (6.0 - 2.0*B)) * (1.0/6.0);\n}\nfloat FilterMitchell(vec2 p, vec2 r)\n{\n    p /= r; //TODO: fails at radius0\n    #if defined( USE_RADIUS_VERSIONS )\n    return Mitchell1D( length(p) ); //note: radius version...\n    #else\n    return Mitchell1D(p.x) * Mitchell1D(p.y);\n    #endif\n}\n\nfloat Sinc(float x)\n{\n    const float PI = 3.14159265;\n    x = abs(x);\n    if ( x < 1e-5)\n        return 1.0;\n    return sin(PI*x) / (PI*x);\n}\nfloat WindowedSinc( float x )\n{\n    const float tau = 2.0;\n    x = abs(x);\n\tif ( x > 2.0 ) //note: was x>radius, 2.0 is filtersize\n        return 0.0;\n\tfloat lanczos = Sinc( x / tau );\n\treturn Sinc(x) * lanczos;\n}\nfloat FilterLanczosSinc( vec2 p, vec2 dummy_r )\n{\n    #if defined( USE_RADIUS_VERSIONS )\n    return WindowedSinc( length(p) );\n    #else\n    return WindowedSinc( p.x ) * WindowedSinc( p.y );\n\t#endif\n}\n\n\nfloat Gaussian( float x, float alpha /*=2.0*/ )\n{\n\tfloat expv = exp(-alpha); //note: radius = 1.0\n    //return max(0.0, exp(-alpha*x*x) );\n    return max(0.0, (exp(-alpha * x * x) - expv) / (1.0-expv)); //note: normalisation-factor to always get f(0)=1\n}\nfloat FilterGaussian(vec2 p, vec2 radius, float alpha )\n{\n    radius = max(vec2(0.00001), radius );\n    p /= radius;\n    //return Gaussian( length(p), alpha );\n    return Gaussian(p.x, alpha )*Gaussian(p.y, alpha );\n}\n\n///////////////////\n\n//note: generic bruteforce filter\n//TODO: float filtersiz\n//vec3 reconstruct_gaussian( vec2 p_px, int filterwidth, float gauss_alpha )\nvec4 SampleTextureGenericFilter( vec2 uv, vec2 texsiz, float lambda )\n{\n    const int filtersiz = 4;\n    const float gauss_alpha = 2.0;\n    \n    vec2 p = uv * texsiz;\n    ivec2 pq = ivec2(p)+1;\n    \n    vec4 sum_c = vec4(0);\n    float sum_w = 0.0;\n    for ( int y=0,yn=filtersiz; y<yn; ++y)\n    {\n        for ( int x=0,xn=filtersiz; x<xn; ++x)\n        {\n            ivec2 ofs = ivec2(x,y) - filtersiz/2;\n            ivec2 sp = pq + ofs;\n            vec4 c = texelFetch( iChannel0, sp, 0 );\n\n            float w = FilterGaussian( vec2(sp) - p, vec2(filtersiz/2), gauss_alpha );\n            \n            sum_c += w * c;\n            sum_w += w;\n        }\n    }\n    return sum_c / sum_w;\n}\n\n//note: see http://vec3.ca/bicubic-filtering-in-fewer-taps/ for more details\n//note: also http://mate.tue.nl/mate/pdfs/10318.pdf ( https://web.archive.org/web/20210506134417/http://mate.tue.nl/mate/pdfs/10318.pdf )\n//note: polynomials converted to hornerform using wolfram-alpha hornerform()\nvec4 SampleTextureCubic( vec2 uv, vec2 texSize, float lambda )\n{\n    vec2 iTc = uv * texSize;\n    vec2 tc = floor(iTc - 0.5) + 0.5;\n\n    vec2 f = iTc - tc;\n    \n    vec2 f2 = vec2( f * f );\n\tvec2 w0 = f * ( f * ( 0.5 - (1.0/6.0) * f ) - 0.5 ) + (1.0/6.0);\n\tvec2 w1 = (0.5 * f - 1.0) * f2 + (2.0/3.0);\n\tvec2 w2 = f * ( f * (0.5 - 0.5 * f) + 0.5) + (1.0/6.0);\n\tvec2 w3 = (1.0/6.0) * f*f2;\n\n   \tvec2 s0 = w0 + w1;\n    vec2 s1 = w2 + w3;\n \n    vec2 f0 = w1 / s0;\n    vec2 f1 = w3 / s1;\n \n    vec2 t0 = tc - 1.0 + f0;\n    vec2 t1 = tc + 1.0 + f1;\n \n    vec2 rcp_texsiz = 1.0 / texSize;\n    t0 *= rcp_texsiz;\n    t1 *= rcp_texsiz;\n \n    return\n        (sampleTex( vec2( t0.x, t0.y ), lambda) * s0.x\n      +  sampleTex( vec2( t1.x, t0.y ), lambda) * s1.x) * s0.y\n      + (sampleTex( vec2( t0.x, t1.y ), lambda) * s0.x\n      +  sampleTex( vec2( t1.x, t1.y ), lambda) * s1.x ) * s1.y;\n}\n\n//note: https://web.archive.org/web/20210506134417/http://mate.tue.nl/mate/pdfs/10318.pdf\n//      identical to above\n/*\nvec4 interpolate_bicubic(sampler2D tex, vec2 uv, float lambda )\n{\n    vec2 texsiz = vec2(textureSize(tex,0).xy);\n    uv *= texsiz;\n\n\t// transform the coordinate from [0,extent] to [-0.5, extent-0.5]\n\tvec2 coord_grid = vec2(uv.x - 0.5, uv.y - 0.5);\n\tvec2 index = floor(coord_grid);\n\tvec2 fraction = coord_grid - index;\n\tvec2 one_frac = 1.0 - fraction;\n\tvec2 one_frac2 = one_frac * one_frac;\n\tvec2 fraction2 = fraction * fraction;\n\n\tvec2 w0 = 1.0/6.0 * one_frac2 * one_frac;\n\tvec2 w1 = 2.0/3.0 - 0.5 * fraction2 * (2.0-fraction);\n\tvec2 w2 = 2.0/3.0 - 0.5 * one_frac2 * (2.0-one_frac);\n\tvec2 w3 = 1.0/6.0 * fraction2 * fraction;\n\tvec2 g0 = w0 + w1;\n\tvec2 g1 = w2 + w3;\n\n\t// h0 = w1/g0 - 1, move from [-0.5, extent-0.5] to [0, extent]\n\tvec2 h0 = (w1 / g0) - 0.5 + index;\n\tvec2 h1 = (w3 / g1) + 1.5 + index;\n\n    h0 /= texsiz;\n    h1 /= texsiz;\n\n\n\t// fetch the four linear interpolations\n\tvec4 tex00 = textureLod(tex, vec2(h0.x, h0.y), lambda );\n\tvec4 tex10 = textureLod(tex, vec2(h1.x, h0.y), lambda );\n\tvec4 tex01 = textureLod(tex, vec2(h0.x, h1.y), lambda );\n\tvec4 tex11 = textureLod(tex, vec2(h1.x, h1.y), lambda );\n\n\t// weigh along the y-direction\n\ttex00 = mix(tex01, tex00, g0.y);\n\ttex10 = mix(tex11, tex10, g0.y);\n\n\t// weigh along the x-direction\n\treturn mix(tex10, tex00, g0.x);\n}\n*/\n\n\n// note: entirely stolen from https://gist.github.com/TheRealMJP/c83b8c0f46b63f3a88a5986f4fa982b1\n//\n// Samples a texture with Catmull-Rom filtering, using 9 texture fetches instead of 16.\n// See http://vec3.ca/bicubic-filtering-in-fewer-taps/ for more details\nvec4 SampleTextureCatmullRom( vec2 uv, vec2 texSize, float lambda )\n{\n    // We're going to sample a a 4x4 grid of texels surrounding the target UV coordinate. We'll do this by rounding\n    // down the sample location to get the exact center of our \"starting\" texel. The starting texel will be at\n    // location [1, 1] in the grid, where [0, 0] is the top left corner.\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n    // Compute the fractional offset from our starting texel to our original sample location, which we'll\n    // feed into the Catmull-Rom spline function to get our filter weights.\n    vec2 f = samplePos - texPos1;\n\n    // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.\n    // These equations are pre-expanded based on our knowledge of where the texels will be located,\n    // which lets us avoid having to evaluate a piece-wise function.\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    \n    // Work out weighting factors and sampling offsets that will let us use bilinear filtering to\n    // simultaneously evaluate the middle 2 samples from the 4x4 grid.\n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / w12;\n\n    // Compute the final UV coordinates we'll use for sampling the texture\n    vec2 texPos0 = texPos1 - vec2(1,1);\n    vec2 texPos3 = texPos1 + vec2(2,2);\n    vec2 texPos12 = texPos1 + offset12;\n\n    texPos0 /= texSize;\n    texPos3 /= texSize;\n    texPos12 /= texSize;\n\n    vec4 result = vec4(0,0,0,0);\n    result += sampleTex( vec2(texPos0.x,  texPos0.y), lambda) * w0.x * w0.y;\n    result += sampleTex( vec2(texPos12.x, texPos0.y), lambda) * w12.x * w0.y;\n    result += sampleTex( vec2(texPos3.x,  texPos0.y), lambda) * w3.x * w0.y;\n\n    result += sampleTex( vec2(texPos0.x,  texPos12.y), lambda) * w0.x * w12.y;\n    result += sampleTex( vec2(texPos12.x, texPos12.y), lambda) * w12.x * w12.y;\n    result += sampleTex( vec2(texPos3.x,  texPos12.y), lambda) * w3.x * w12.y;\n\n    result += sampleTex( vec2(texPos0.x,  texPos3.y), lambda) * w0.x * w3.y;\n    result += sampleTex( vec2(texPos12.x, texPos3.y), lambda) * w12.x * w3.y;\n    result += sampleTex( vec2(texPos3.x,  texPos3.y), lambda) * w3.x * w3.y;\n\n    return result;\n}\n\n\n//=======================================================================================\n//note: from https://www.shadertoy.com/view/MllSzX\nvec4 CubicHermite (vec4 A, vec4 B, vec4 C, vec4 D, float t)\n{\n\tfloat t2 = t*t;\n    float t3 = t*t*t;\n    vec4 a = -A/2.0 + (3.0*B)/2.0 - (3.0*C)/2.0 + D/2.0;\n    vec4 b = A - (5.0*B)/2.0 + 2.0*C - D / 2.0;\n    vec4 c = -A/2.0 + C/2.0;\n   \tvec4 d = B;\n    \n    return a*t3 + b*t2 + c*t + d;\n}\nvec4 BicubicHermiteTextureSample( vec2 P, float lambda )\n{\n\n    float c_textureSize = float( textureSize(iChannel0,0).x ); //note: assumes square texture\n    float c_onePixel = (1.0 / c_textureSize);\n    float c_twoPixels = (2.0 / c_textureSize);\n\n    vec2 pixel = P * c_textureSize + 0.5;\n    \n    vec2 frac = fract(pixel);\n    pixel = floor(pixel) / c_textureSize - vec2(c_onePixel/2.0);\n    \n    vec4 C00 = textureLod(iChannel0, pixel + vec2(-c_onePixel ,-c_onePixel), lambda);\n    vec4 C10 = textureLod(iChannel0, pixel + vec2( 0.0        ,-c_onePixel), lambda);\n    vec4 C20 = textureLod(iChannel0, pixel + vec2( c_onePixel ,-c_onePixel), lambda);\n    vec4 C30 = textureLod(iChannel0, pixel + vec2( c_twoPixels,-c_onePixel), lambda);\n    \n    vec4 C01 = textureLod(iChannel0, pixel + vec2(-c_onePixel , 0.0), lambda);\n    vec4 C11 = textureLod(iChannel0, pixel + vec2( 0.0        , 0.0), lambda);\n    vec4 C21 = textureLod(iChannel0, pixel + vec2( c_onePixel , 0.0), lambda);\n    vec4 C31 = textureLod(iChannel0, pixel + vec2( c_twoPixels, 0.0), lambda); \n    \n    vec4 C02 = textureLod(iChannel0, pixel + vec2(-c_onePixel , c_onePixel), lambda);\n    vec4 C12 = textureLod(iChannel0, pixel + vec2( 0.0        , c_onePixel), lambda);\n    vec4 C22 = textureLod(iChannel0, pixel + vec2( c_onePixel , c_onePixel), lambda);\n    vec4 C32 = textureLod(iChannel0, pixel + vec2( c_twoPixels, c_onePixel), lambda);\n    \n    vec4 C03 = textureLod(iChannel0, pixel + vec2(-c_onePixel , c_twoPixels), lambda);\n    vec4 C13 = textureLod(iChannel0, pixel + vec2( 0.0        , c_twoPixels), lambda);\n    vec4 C23 = textureLod(iChannel0, pixel + vec2( c_onePixel , c_twoPixels), lambda);\n    vec4 C33 = textureLod(iChannel0, pixel + vec2( c_twoPixels, c_twoPixels), lambda);\n    \n    vec4 CP0X = CubicHermite(C00, C10, C20, C30, frac.x);\n    vec4 CP1X = CubicHermite(C01, C11, C21, C31, frac.x);\n    vec4 CP2X = CubicHermite(C02, C12, C22, C32, frac.x);\n    vec4 CP3X = CubicHermite(C03, C13, C23, C33, frac.x);\n    \n    return CubicHermite(CP0X, CP1X, CP2X, CP3X, frac.y);\n}\n\n\n////////////////////////////////////////////\n//TODO: see also https://www.shadertoy.com/view/wsByzh\n\n\n//TODO: filter-index\n//note: https://registry.khronos.org/OpenGL/specs/gl/glspec32.core.pdf#page=177\nvec4 SampleTexture( vec2 uv, float bias )\n{\n    vec2 texSize = vec2(textureSize(iChannel0,0).xy);\n\n\tfloat rho = max( length(texSize*dFdx(uv.xy)),\n\t                 length(texSize*dFdy(uv.xy)) );\n\tfloat lambda = log2(rho);\n    lambda += bias;\n    lambda = clamp( lambda, 0.0, 16.0 ); //note: assuming max-miplevels\n    \n    float lambda0 = floor(lambda);\n    float lambda1 = ceil(lambda);\n    vec2 texSize0 = texSize / exp2( lambda0 );\n    vec2 texSize1 = texSize / exp2( lambda1 );\n\n    //return texture( iChannel0, uv, bias ); //linear\n    \n    \n    //vec4 s0 = SampleTextureCatmullRom( uv, texSize0, lambda0 );\n    //vec4 s1 = SampleTextureCatmullRom( uv, texSize1, lambda1 );\n\n    //vec4 s0 = SampleTextureCubic( uv, texSize0, lambda0 );\n    //vec4 s1 = SampleTextureCubic( uv, texSize1, lambda1 );\n\nreturn SampleTextureGenericFilter( uv, texSize0, lambda0 );\n    \n    vec4 s0 = SampleTextureGenericFilter( uv, texSize0, lambda0 );\n    vec4 s1 = SampleTextureGenericFilter( uv, texSize1, lambda1 );\n\n    //vec4 s0 = BicubicHermiteTextureSample(uv, lambda0);\n    //vec4 s1 = BicubicHermiteTextureSample(uv, lambda1);\n\n    \n    float t = fract(lambda);\n    return mix( s0, s1, t );\n    \n\t//return textureLod(iChannel0, uv, lambda );\n}\n\n//note: uniform pdf rand [0;1[\nvec3 hash32n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec3(p.x * p.y * 95.4307, p.x * p.y * 97.5901, p.x * p.y * 93.8369));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 sample_uv = uv;\n    sample_uv.x = mod( sample_uv.x, 0.5 );\n   \tsample_uv += 0.01 * vec2( cos(iTime), sin(iTime) );\n    sample_uv *= 0.06125;\n    //sample_uv *= (iMouse.z>0.0) ? iMouse.x / iResolution.x*2.5 : 1.0;\n    \n    float texbias = (iMouse.z > 0.5 ) ? iMouse.x / iResolution.x * 0.5 : 0.0;\n    //float texbias = 0.0;\n    texbias *= 25.0;\n    \n    vec4 smpl;\n    if ( uv.x < 0.5 )\n    {\n        smpl = SampleTexture( sample_uv, texbias );\n    }\n    else\n    {\n        smpl = texture( iChannel0, sample_uv, texbias );\n    }\n\n    fragColor = smpl;\n    fragColor -= step(abs(uv.x-0.5), 0.001);\n\n    fragColor.rgb += (hash32n(uv+fract(iTime))+hash32n(uv+0.1337*fract(iTime))-1.0)/255.0; //dither output\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}