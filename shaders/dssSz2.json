{
    "Shader": {
        "info": {
            "date": "1669242661",
            "description": "Click and drag to orbit the camera - Pausing before orbiting the camera is less disorienting\n\nI was working on a different shader and I encountered a glitch that I thought looked cool so I leaned into it a bit further and made this (Anti-Aliasing is on)\n",
            "flags": 32,
            "hasliked": 0,
            "id": "dssSz2",
            "likes": 5,
            "name": "Rainbow Bubble Cube",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Aurcereal",
            "viewed": 912
        },
        "renderpass": [
            {
                "code": "//THIS CODE IS REALLY UNORGANIZED SORRY\n\n//Camera\n//vec3 cameraPos = vec3(0.0, 0., -19.0);\nvec3 cameraPos;\nvec3 cameraForward;\n\n//Camera transforms\nvec3 SS2WS(vec2 p, vec3 forward, vec3 up, float fovY)\n{\n    //to view space\n    float z = 1.0;\n    \n    float y = z * tan(fovY*.5);\n    float x = y * iResolution.x/iResolution.y;\n\n    //to world space\n    vec3 right = cross(up, forward);\n    \n    return normalize(right*p.x*x + up*p.y*y + forward*z);\n}\n\nvec3 SS2WS(vec2 p, float fovY) //choose cam specs in method\n{\n    return SS2WS(p, cameraForward, normalize(proj(vec3(0.0, 1.0, 0.0), cameraForward)), fovY);\n}\n\n//Raymarch + SDF\n/*#define boxPos vec3(0.0, 0.0, 5.0)\n\n#define boxForward  vec3(0.0, 0.0, 1.0)\n#define boxUp vec3(0.0, 1.0, 0.0)\n#define boxRight vec3(1.0, 0.0, 0.0)\n\n#define boxScale vec3(5.0, 5.0, 5.0)*/\n\nmat4 transform;\n\nfloat sdf(vec3 p)\n{\n    return sdEdgedCube(p, transform, 0.3);\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e = vec2(NORMALEPS, 0.0);\n    \n    return normalize(vec3(\n        sdf(p + e.xyy) - sdf(p - e.xyy),\n        sdf(p + e.yxy) - sdf(p - e.yxy),\n        sdf(p + e.yyx) - sdf(p - e.yyx)\n        ));\n}\n\nfloat trace(vec3 ro, vec3 rd, out int steps)\n{\n    float sd,dist = 0.0;\n\n    for(int i=0; i<MAXSTEPS; i++)\n    {\n        sd = sdf(ro+rd*dist);\n        dist += sd;\n        \n        if(abs(sd) < SDEPS) {steps = i; return dist;}\n    }\n    \n    steps = MAXSTEPS;\n    return dist;\n}\n\nvec4 render(vec2 fragCoord)\n{\n    vec2 rdSS = (fragCoord/iResolution.xy)*2.0-1.0;\n    \n    vec3 roWS = cameraPos;\n    vec3 rdWS = SS2WS(rdSS, 60.*D2R);\n    \n    int steps = 0;\n    float dist = trace(roWS, rdWS, steps);\n    \n    vec3 col = vec3(0.2, 0.1, 0.4) * (1.0-acos(rdWS.y)/PI);\n    \n    if(dist < MAXDIST)\n    {\n        col = norm(roWS + rdWS*dist)*0.5+0.5 + step(55., dist);\n    }\n    \n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //camera specs\n    cameraPos = texelFetch(iChannel0, ivec2(0,1), 0).xyz;\n    cameraForward = texelFetch(iChannel0, ivec2(1,1), 0).xyz;\n    \n    //box specs\n    vec3 boxPos = vec3(0.0, 0.0, 0.0); //z = -5.\n\n    //vec3 boxForward = vec3(0.0, sin(iTime), cos(iTime));\n    vec3 boxForward = normalize(vec3(cos(iTime)*sin(iTime*1.4), sin(iTime), cos(iTime)*cos(iTime*1.4)));\n    vec3 boxUp = vec3(0.0, 1.0, 0.0);//vec3(0.0, sin(iTime+PI*.5), cos(iTime+PI*.5));\n    boxUp = normalize(boxUp - dot(boxForward, boxUp) * boxForward);\n    vec3 boxRight = cross(boxUp, boxForward);\n\n    vec3 boxScale = vec3(5.0, 5.0, 5.0)*.95;\n\n    //setup cube transform\n    transform =\n        mat4(1.0, 0.0, 0.0, -boxPos.x,\n             0.0, 1.0, 0.0, -boxPos.y,\n             0.0, 0.0, 1.0, -boxPos.z,\n             0.0, 0.0, 0.0, 1.0) *\n        mat4(boxRight.x,   boxRight.y,   boxRight.z,   0.0,\n             boxUp.x,      boxUp.y,      boxUp.z,      0.0,\n             boxForward.x, boxForward.y, boxForward.z, 0.0,\n             0.0, 0.0, 0.0, 1.0) *\n        mat4(1.0/boxScale.x, 0.0, 0.0, 0.0,\n             0.0, 1.0/boxScale.y, 0.0, 0.0,\n             0.0, 0.0, 1.0/boxScale.z, 0.0,\n             0.0, 0.0, 0.0, 1.0);\n\n    vec3 pDim = vec3(vec2(1.0), 0.0); //was 1./iResolution.xy not right\n    \n    fragColor = (render(fragCoord) + render(fragCoord + pDim.xz) + render(fragCoord + pDim.zy) + render(fragCoord + pDim.xy)) * .25;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265\n#define IPI .318309886\n#define D2R .0174532925\n#define R2D 57.2957795\n\n#define MAXDIST 60.\n#define MAXSTEPS 30 //Bandaid - deal with corners that make steps tiny - will only be used for few rays\n\n#define SDEPS 0.007\n#define NORMALEPS 0.001\n\n//HELP\n\nvec3 arot(vec3 vec, vec3 axis, float theta) //axis rotation\n{\n    vec3 proj = vec - dot(axis, vec) * axis;\n    vec3 up = normalize(cross(proj, axis));\n    \n    return dot(vec, axis) * vec + normalize(proj) * cos(theta) * length(proj) + up * sin(theta) * length(proj);\n}\n\nvec3 crot(vec3 vec, vec3 pole, float minTheta) //clamp rotation\n{\n    float correctTheta = max(0., minTheta - acos(dot(normalize(vec), pole)));\n    vec3 axis = normalize(cross(vec, pole));\n    \n    return arot(vec, axis, correctTheta);\n}\n\nvec3 crotdoubleend(vec3 vec, vec3 pole, float minTheta) //clamp rotation on both ends of the pole\n{\n    return crot(crot(vec, pole, minTheta), -pole, minTheta);\n}\n\nvec3 proj(vec3 vec, vec3 axis)\n{\n    return vec - dot(vec, axis) * axis;\n}\n\n//SDFs\n\nfloat sdRectPrism(vec3 p, vec3 forward, vec3 up, float thickness, float len) //origin = vec3(0.0)\n{\n    vec3 right = cross(forward, up);\n\n    p = vec3(dot(p, right), dot(p, up), dot(p, forward));\n    p = vec3(p.x - .5*thickness, p.y - .5*thickness, p.z - len * .5);\n    p = abs(p);\n    \n    float dist2D = 0.0;\n    \n    float distX = p.x - .5*thickness;\n    float distY = p.y - .5*thickness;\n    float distZ = p.z - .5 * len;\n    \n    if(distX > 0. && distY > 0.)\n    {\n        dist2D = sqrt(distX*distX + distY*distY);\n    }\n    else if(distY > 0.)\n    {\n        dist2D = distY;\n    }\n    else if(distX > 0.)\n    {\n        dist2D = distX;\n    }\n    else\n    {\n        return max(distZ, max(distX, distY));\n    }\n    \n    return sqrt(pow(dist2D,2.) + pow(max(0., distZ),2.));\n    \n}\nfloat sdEdgedCube(vec3 p, mat4 transform, float thickness) //column order -> p(rows) * transform(columns)\n{\n    //cube is in (-1, 1) after transformation\n    p = abs(vec4(p, 1.0) * transform).xyz;\n    \n    //3 distances to the edges\n    p = p - vec3(1., 1., 1.);\n    \n    float distX = sdRectPrism(p, vec3(-1.0, 0.0, 0.0), vec3(0.0, 0.0, -1.0), thickness, 1.);\n    float distY = sdRectPrism(p, vec3(0.0, -1.0, 0.0), vec3(-1.0, 0.0, 0.0), thickness, 1.);\n    float distZ = sdRectPrism(p, vec3(0.0, 0.0, -1.0), vec3(0.0, -1.0, 0.0), thickness, 1.);\n    \n    return min(distX, min(distY, distZ));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "ivec2 dataOffset = ivec2(0);\nfloat startWait = .1;\n\nvec3 SS2WS(vec2 p, vec3 forward, float fovY)\n{\n    //to view space\n    float y = tan(fovY*.5);\n    float x = y * iResolution.x/iResolution.y;\n\n    //to world space\n    vec3 up = normalize(vec3(0.0, 1.0, 0.0) - dot(forward, vec3(0.0, 1.0, 0.0)) * forward);\n    vec3 right = cross(up, forward);\n    \n    return normalize(right*p.x*x + up*p.y*y + forward);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 mouseCurr = iMouse;\n    vec4 mousePrev = iTime > startWait ? texelFetch(iChannel0, dataOffset+ivec2(1,0), 0) : mouseCurr;\n    \n    //Get camera data\n    vec3 camPos = iTime > startWait ? texelFetch(iChannel0, dataOffset+ivec2(0,1), 0).xyz : vec3(0.0, 0.0, -24.0);\n    vec3 camForward = iTime > startWait ? texelFetch(iChannel0, dataOffset+ivec2(1,1), 0).xyz : vec3(0.0, 0.0, 1.0);\n    \n    //get previous slide data\n    //vec4 slideOld = iTime > startWait ? texelFetch(iChannel0, dataOffset+ivec2(0,2), 0) : vec4(0.0);\n    \n    vec3 slide = SS2WS((mouseCurr.xy/iResolution.xy)*2.0-1.0, camForward, 60.*D2R) - SS2WS((mousePrev.xy/iResolution.xy)*2.0-1.0, camForward, 60.*D2R);\n    vec3 slideAxis = (sign(mousePrev.z) == 1.0 && sign(mouseCurr.z) == 1.0) ? normalize(cross(slide, camPos)) : vec3(0.);\n    \n    camPos = (length(slideAxis) >= 1.) ? crotdoubleend(arot(camPos, slideAxis, -length(slide)*10.0), vec3(0.0, 1.0, 0.0), PI*.2) : camPos;\n    camForward = normalize(-camPos);\n\n    //Store data\n    if(ivec2(fragCoord) == dataOffset + ivec2(0,0)) {fragColor = mousePrev;}\n    if(ivec2(fragCoord) == dataOffset + ivec2(1,0)) {fragColor = mouseCurr;}\n    \n    if(ivec2(fragCoord) == dataOffset + ivec2(0,1)) {fragColor = vec4(camPos, 1.0);}\n    if(ivec2(fragCoord) == dataOffset + ivec2(1,1)) {fragColor = vec4(camForward, 1.0);}\n    \n    //if(ivec2(fragCoord) == dataOffset + ivec2(0,2)) {fragColor = vec4(slideAxis, slideMag);}\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}