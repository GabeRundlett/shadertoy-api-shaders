{
    "Shader": {
        "info": {
            "date": "1710887804",
            "description": "A rework of a previous shader done last year.  (mouseable)\nhttps://www.shadertoy.com/view/clG3RR",
            "flags": 96,
            "hasliked": 0,
            "id": "mtKGRR",
            "likes": 25,
            "name": "Path Tunnel Audio Demo",
            "published": 3,
            "tags": [
                "raymarching",
                "cube",
                "audio",
                "path"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 396
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    @byt3_m3chanic 03/19/2024\n    \n    so I wandered off and made this based off my previous shader\n    https://www.shadertoy.com/view/clG3RR\n    \n    Thanks to @Shane for his path shaders!\n    https://www.shadertoy.com/view/MlXSWX\n\n*/\n\n#define COLOR(COORD) texture(iChannel0,(COORD))\n\n// chroma \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n\tvec2 uv = fragCoord.xy/iResolution.xy;    \n    vec3 color = COLOR(uv).rgb;\n    // effect sample\n    vec3 fgclr = vec3(0);\n    float f = length(uv  - 1.95);\n    fgclr.x = COLOR(uv - vec2(f*0.001,.001)).x;\n    fgclr.y = COLOR(uv + vec2(f*0.002,.002)).y;\n    fgclr.z = COLOR(uv - vec2(f*0.004,.004)).z;\n \n    // mask for effect / mixdown \n    float dt = length(uv-.5)-.2125;\n    vec3 C = mix(color,fgclr,smoothstep(0.,.275,dt));\n    \n    // output & gamma correct\n    fragColor = vec4(pow(C,vec3(.4545)),1.);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    @byt3_m3chanic 03/19/2024\n    \n    so I wandered off and made this based off my previous shader\n    https://www.shadertoy.com/view/clG3RR\n    \n    Thanks to @Shane for his path shaders!\n    https://www.shadertoy.com/view/MlXSWX\n\n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.141592653\n#define PI2        6.283185307\n\n#define MAX_DIST   80.\n#define MIN_DIST   1e-3\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(27.609, 57.583)))*43758.5453); }\n\nfloat sampleFreq(float freq) { \n    float a = texture(iChannel0, vec2(freq, .25)).x;\n    return a;\n}\n\n//@iq SDF's\nfloat box( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n//@Shane - path function\nvec2 path(in float z){\n    vec2 p1 =vec2(2.38*sin(z * .075)+5.38*cos(z * .15), 2.4*cos(z * .245));\n    vec2 p2 =vec2(3.2*sin(z * .179),3.31*sin(z * .052)+5.38*cos(z * .175));\n    return (p1 - p2)*.3;\n}\n\n//@MercurySexy\nvec2 pModPolar(inout vec2 p) {\n    float angle = 0.26179938779;//hardcoded for speed 2.*PI/24;\n    float a = atan(p.y, p.x) + angle/2.,\n          r = length(p),\n          c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    if (abs(c) >= (12.)) c = abs(c);\n    return vec2(c,angle);\n}\n\n// consts\nconst float sz = 1.2, hf = sz/2.;\n\n// globals\nfloat time=0.,tspeed=0.,glow = 0.,glow2 = 0.,gwave=0.;\nvec3 hp,hit,lp,gid,sid;\nmat2 rxa,rxb;\n\nvec2 map (in vec3 pos, float sg) {\n \tvec2 res = vec2(1e5,0);\n \tvec3 p = pos;\n    \n \tvec2 tun = p.xy - path(p.z);\n    vec3 px = vec3(tun+vec2(0.,-.1),pos.z+tspeed+1.5+gwave);\n    vec3 q = vec3(tun,p.z);\n\n    float iz = floor((q.z+hf)/sz);\n    q.z = mod(q.z+hf,sz)-hf;\n    vec3 r = q;\n    r.z*=1.2;\n    \n    float zhs=hash21(vec2(iz,0.));\n    if(zhs<.65) r.xy *= rxa;\n    if(zhs>.85) r.xy *= rxb;\n\n    vec2 id = pModPolar(r.xy);\n    r -= vec3(4.7,0,0);\n    r.xy *= rot(id.y*6.);\n\n    vec2 mid = vec2(id.x,iz);\n    float hs = hash21(mid);\n    float ct = box(r,vec3(hf,hs>.7?.2:.1,hf)*.8)-.075;\n\n    if(ct<res.x) {\n        res = vec2(ct,1.);\n        hit=q;\n        sid=vec3(mid,iz);\n    }\n\n    float modt = mod(T,8.);\n    if(modt<4.) hs = hash21(id);\n   \n    float ns = sampleFreq(hs*.1)*.75;\n    if(sg==1.&&ns>.625) { glow += .005/(.0001+ct*ct);}\n\n    res.x /=1.2;\n \treturn res;\n}\n\nvec3 normal(vec3 p, float t) {\n    t*=MIN_DIST;\n    float d = map(p,0.).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d - vec3(\n        map(p-e.xyy,0.).x,\n        map(p-e.yxy,0.).x,\n        map(p-e.yyx,0.).x\n        );\n    return normalize(n);\n}\n\n//@iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);\n    return c.z * mix( vec3(1), rgb, c.y);\n}\nvec4 FC = vec4(vec3(.75),.0);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, float last, inout float d, vec2 uv) {\n\n    vec3 C = FC.rgb;\n    vec3 p = vec3(0);\n\n    float m;\n    \n    for(int i=0;i<80;i++) {\n        p=ro+rd*d;\n        vec2 ray = map(p,last<1.?1.:2.);//stop glow on second bounce - gets to be too much..\n        if(ray.x<MIN_DIST*d||d>MAX_DIST)break;\n        d+= i<25? ray.x*.5 : ray.x;\n        m = ray.y;\n    }\n    \n    gid=sid;\n\n    if(d<MAX_DIST) {\n        vec3 n = normal(p,d);\n\n        vec3 lpos = vec3(0,0,-6);\n        lpos.z -= tspeed;\n        lpos.xy += path(lpos.z);\n        vec3 l = normalize(lpos-p);\n        float diff = clamp(dot(n,l),.1,.9);\n\n        float hs = hash21(gid.xy);\n        vec3 h = vec3(hs>.75?hs*.5:hs*.15);\n    \n        if(hs<.45) {\n           h = hsv2rgb(vec3(p.z*.05,1.,.5));\n        } \n\n        if(m==5.) {h=vec3(.9);ref=vec3(0);}\n\n        ref = h*.75;\n        C = h * diff;\n        if (last==0.) FC.a = 1.-exp(-.0002*d*d*d);\n        \n        ro = p+n*1e-4;\n        rd = reflect(rd,n);\n    } \n\n    return vec4(C,1);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    // precal\n    time = iTime;\n    tspeed = time*5.;\n    gwave = 10.+9.*sin(time*.3);\n    rxa=rot(T*.3);\n    rxb=rot(-T*.25);\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    uv *= (200.*R.x/R.y)/(80.*R.x/R.y);\n    \n    vec3 ro = vec3(0,0,.1);\n    vec3 rd = normalize(vec3(uv,-1.));\n\n    // mouse //\n    float x = M.xy==vec2(0) || M.z<0. ? 0. : -(M.y/R.y*.5-.25)*PI;\n    float y = M.xy==vec2(0) || M.z<0. ? 0. : -(M.x/R.x*2.-1.)*PI;\n\n    mat2 rx = rot(x), ry = rot(y);\n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n\n    ro.z -= tspeed;\n    ro.xy += path(ro.z);\n\n    // center tracking\n    rd.xy = rot( (.2*sin(time*.3))-path(lp.z).x/ 24. )*rd.xy;\n    rd.xz = rot( path(lp.z+1.).y/ 14. )*rd.xz;\n\n    // reflection loop (@BigWings)\n    vec3 C = vec3(0), ref = vec3(0), fil = vec3(1);\n    float d = 0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i, d, uv);\n        C += pass.rgb*fil;\n        fil *= ref;\n    }\n    float px = 2./R.x;\n\n    C = mix(C,FC.rgb,FC.a);\n    C = mix(C,vec3(.95),clamp(glow*.5,0.,1.));\n    O = vec4(C,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 36701,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/when-we-dip/premiere-guy-j-illusion-lost-found"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}