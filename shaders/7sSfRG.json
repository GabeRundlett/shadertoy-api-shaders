{
    "Shader": {
        "info": {
            "date": "1646512521",
            "description": "License CC0: Voronoi Glass Panes\n Tinkering with the voronoi pattern by Shane on saturday evening\n Kind of hackish overall but that never stopped me from sharing a shader before\n",
            "flags": 0,
            "hasliked": 0,
            "id": "7sSfRG",
            "likes": 39,
            "name": "Voronoi Glass Panes",
            "published": 3,
            "tags": [
                "voronoi"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 882
        },
        "renderpass": [
            {
                "code": "// License CC0: Voronoi Glass Panes\n//  Tinkering with the voronoi pattern from a Shane shader on saturday evening\n//  Kind of hackish overall but that never stopped me from sharing a shader before\n//  Shane shader, it's worth a look: https://www.shadertoy.com/view/Mld3Rn\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define PI_2        (0.5*3.141592654)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define DOT2(x)     dot(x,x)\n\nconst float planeDist = 1.0-0.25;\n\nfloat g_hmul = 1.0;\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float zoomOuter = 1.0;\nconst float zoomInner = 0.2;\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract (sin (p)*43758.5453123);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r ) {\n  const vec3 k  = 0.5*vec3(-sqrt(3.0), 1.0, sqrt(4.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.1*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\nvec3 doffset(float z) {\n  float eps = 0.05;\n  return (offset(z + eps) - offset(z - eps))/(2.0*eps);\n}\n\nvec3 ddoffset(float z) {\n  float eps = 0.05;\n  return (doffset(z + eps) - doffset(z - eps))/(2.0*eps);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld = max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0);\n  vec3 scol = HSV2RGB(vec3(0.1, 0.25, 0.9));\n  return scol*tanh_approx(3.0*pow(ld, 100.0));\n}\n\nfloat voronoi2(vec2 p){\n  vec2 g = floor(p), o; p -= g;\n  \n  vec3 d = vec3(1);\n    \n  for(int y = -1; y <= 1; y++){\n    for(int x = -1; x <= 1; x++){\n      o = vec2(x, y);\n      o += hash2(g + o) - p;\n      d.z = dot(o, o); \n      d.y = max(d.x, min(d.y, d.z));\n      d.x = min(d.x, d.z); \n    }\n  }\n  \n  return max(d.y/1.2 - d.x, 0.0)/1.2;\n}\n\nfloat hf2(vec2 p) {\n  const float zo = zoomOuter;\n  const float zi = zoomInner;\n  \n  p /= zo;\n  p /= zi;\n  \n  float d = -voronoi2(p);\n  d *= zi*zo;\n  \n  float h = 0.2*tanh_approx(3.0*smoothstep(0.0, 1.0*zo*zi, -d));\n  \n  return h*zo*zi;\n}\n\nfloat height(vec2 p) {\n  return -hf2(p)*g_hmul;\n}\n\nvec3 normal(vec2 p, float eps) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(0.00001, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = height(p + e.yx) - height(p - e.yx);\n  n.z = -2.0*e.x;\n  \n  return normalize(n);\n}\n\nvec4 plane(vec3 pro, vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n_, out vec3 pnor) {\n  float h0 = hash(n_);\n  float h1 = fract(7793.0*h0);\n  float h2 = fract(6337.0*h0);\n  \n  vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;\n  const float s = 1.0;\n  vec3 lp1 = vec3(5.0,  1.0, 0.0)*vec3(s, 1.0, s)+pro;\n  vec3 lp2 = vec3(-5.0, 1.0, 0.0)*vec3(s, 1.0, s)+pro;\n  const float hsz = 0.2;\n  float hd = hex(p.yx, hsz);\n\n  g_hmul = smoothstep(0.0, 0.125, (hd-hsz/2.0));\n\n  p += vec2(h0,h1)*20.0;\n  p *= mix(0.5, 1.0, h2);\n  float he  = height(p);\n  vec3  nor = normal(p,2.0*aa);\n  vec3 po   = pp;\n\n  pnor = nor;\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(nor, ld1), 0.0);\n  float diff2 = max(dot(nor, ld2), 0.0);\n  diff1 = ld1.z*nor.z;;\n\n  vec3  ref   = reflect(rd, nor);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  const vec3 mat   = HSV2RGB(vec3(0.55, 0.45, 0.05));\n  const vec3 lcol1 = HSV2RGB(vec3(0.6, 0.5, 0.9));\n  const vec3 lcol2 = HSV2RGB(vec3(0.1, 0.65, 0.9));\n  \n  float hf = smoothstep(0.0, 0.0002, -he);\n  vec3 lpow1 = 1.0*lcol1/DOT2(ld1);\n  vec3 lpow2 = 1.0*lcol2/DOT2(ld2);\n  vec3 col = vec3(0.0);\n  col += hf*mat*diff1*diff1*lpow1;\n  col += hf*mat*diff2*diff2*lpow2;\n  float spes = 20.0;\n  col += pow(ref1, spes)*lcol1;\n  col += pow(ref2, spes)*lcol2;\n\n  float t = 1.0;\n  t *= smoothstep(aa, -aa, -(hd-hsz/4.0));\n  t *= mix(1.0, 0.75, hf);\n  \n  return vec4(col, t);\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 pro, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = 2.0+tanh_approx(length(0.25*p));\n  \n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const int furthest = 5;\n  const int fadeFrom = max(furthest-2, 0);\n\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.98;\n  bool cutOut = false;\n\n  // Steps from nearest to furthest plane and accumulates the color \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec3 pnor = vec3(0.0);\n      vec4 pcol = plane(pro, ro, rd, pp, off, aa, nz+float(i), pnor);\n      \n      vec3 refr = refract(rd, pnor, 1.0-0.075);\n      if (pcol.w > (1.0-cutOff)&&refr != vec3(0.0)) {\n        rd = refr;\n      }\n\n      float dz = pp.z-ro.z;\n      const float fi = -0.; \n      float fadeIn = smoothstep(planeDist*(float(furthest)+fi), planeDist*(float(fadeFrom)-fi), dz);\n      float fadeOut = smoothstep(0.0, planeDist*0.1, dz);\n      pcol.w *= fadeOut*fadeIn;\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      acol.w = acol.w > cutOff ? 1.0 : acol.w;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float z   = 0.33*planeDist*TIME;\n  vec3 pro  = offset(z-1.0);\n  vec3 ro   = offset(z);\n  vec3 dro  = doffset(z);\n  vec3 ddro = ddoffset(z);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = cross(ww, uu);\n\n  vec3 col = color(ww, uu, vv, pro, ro, p);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, q);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = sRGB(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}