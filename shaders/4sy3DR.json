{
    "Shader": {
        "info": {
            "date": "1454635701",
            "description": "here's a fullscreen rendering http://i.imgur.com/BHNq2IH.jpg",
            "flags": 32,
            "hasliked": 0,
            "id": "4sy3DR",
            "likes": 1,
            "name": "blue crystal monte carlo",
            "published": 3,
            "tags": [
                "blue",
                "monte",
                "carlo",
                "crystal"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 1032
        },
        "renderpass": [
            {
                "code": "const int nFramesPerShot = 9999999;\nconst int nCameraShots = 1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = pow( texture(iChannel0, fragCoord/iResolution.xy)/float(iFrame-120),\n                     vec4(1./2.2) );\n    //fragColor =  texture(iChannel0, fragCoord/iResolution.xy);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Ethan Shulman/public_int_i 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//thanks to iq for the great tutorials, code and information\n//thanks to XT95 for the ambient occlusion function\n\n\n\n\n\n#define FOV_SCALE 2.\n#define ITERATIONS 1024\n#define EPSILON .002\n#define NORMAL_EPSILON .002\n#define BACKGROUND_EPSILON EPSILON\n\n#define VIEW_DISTANCE 128.\n\n#define PATH_TRACE\n\n#define pi 3.141592\n\n#define AIR_REFR_INDEX 1.000293\n\n\n\nvec3 cameraLocation;\nvec2 cameraRotation;\n\n\nstruct material {\n    vec3 diffuse,specular,emissive;\n    float metallic,roughness, opacity, refrIndex;\n};\n\n\n\nconst int nFramesPerShot = 999999999;\nconst int nCameraShots = 1;\nvec3 cameraLocations[nCameraShots];\nvec2 cameraRotations[nCameraShots];\n\nvoid initCamera() {\n    \n    cameraLocations[0] = vec3(0., -5., 25.);\n    cameraRotations[0] = vec2(4.7, 1.3);\n    \n    \n    int shot = int(mod(float((iFrame-120)/nFramesPerShot),float(nCameraShots)));\n    for (int i = 0; i < nCameraShots; i++) {\n        if (shot == i) {\n            cameraLocation = cameraLocations[i];\n            cameraRotation = cameraRotations[i];\n            return;\n        }\n    }\n}\n\n\n\n//distance functions from iq's site\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*.5,-p.y)-h.x*0.5);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat ffract(float p) {\n    return fract(p)*2.-1.;\n}\nvec3 ffract(vec3 p) {\n    return fract(p)*2.-1.;\n}\n\nfloat hash3(in vec3 p) {\n    return fract(fract(p.x)*128.234+fract(p.y)*124.234+fract(fract(p.z)*128.234)+\n                 fract(p.x*128.234)*18.234+fract(p.y*128.234)*18.234+fract(fract(p.z*128.234)*18.234));\n}\n    \nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\nfloat light(in vec3 rp) {\n    return length(rp)-2.;\n}\n\nconst vec3 boxSize = vec3(13.,10.,9.);\nvec3 boxSizeNormalized = normalize(boxSize);\n\nfloat box(in vec3 rp) {\n    return max( -sdBox(rp-vec3(0.,0.,1.), boxSize-vec3(1.,1.,0.)),\n                sdBox(rp,boxSize));\n}\nfloat crystal(in vec3 rp) {\n    vec3 mp = rp-vec3(0.,-1.1,2.);\n    mp.xz = rot(mp.xz,.8);\n    for (int i = 0; i < 2; i++) {\n        mp.xy = rot(abs(mp.xy), float(i)*4.89+.84);\n        float old = mp.x;\n        mp.xy = mp.yz;\n        mp.z = old;\n        mp = abs(mp)-(1.+float(i));\n    }\n    return sdBox(mp, vec3(1.,3.,2.4));\n}\nfloat ground(in vec3 rp) {\n    return -rp.y+7.;\n}\n\nfloat df(in vec3 rp) {\n    float l = light(rp);\n\treturn min(ground(rp), min(max(-(l-1.), crystal(rp)), min(l, box(rp))));\n}\nfloat df_hq(in vec3 rp) {\n    float l = light(rp),\n        g = ground(rp),\n        c = crystal(rp),\n        b = box(rp);\n\t\n    c = max(-(l-1.), c);\n    \n    #define dc(v,i) if (v < dst) {dst = v;cid = i;}\n    float dst = l;\n    int cid = 0;\n    dc(g,1);\n    dc(c,2);\n    dc(b,3);\n  \n    if (cid == 1) {\n        dst += texture(iChannel2,rp.xz*.07).x*.5;\n    }\n    if (cid == 2) {\n        dst += texture(iChannel1, vec2(rp.x,abs(rp.y)+abs(rp.z)/14.)*.03).x*.2;\n    }\n    \n    return dst;\n}\n\n\n\nconst vec3 ne = vec3(NORMAL_EPSILON,0.,0.);\nvec3 normal2(in vec3 rp) {\n    return normalize(vec3(df(rp+ne)-df(rp-ne),\n                          df(rp+ne.yxz)-df(rp-ne.yxz),\n                          df(rp+ne.yzx)-df(rp-ne.yzx)));\n}\n\n\nvec3 normal(in vec3 rp) {\n    return normalize(vec3(df_hq(rp+ne)-df_hq(rp-ne),\n                          df_hq(rp+ne.yxz)-df_hq(rp-ne.yxz),\n                          df_hq(rp+ne.yzx)-df_hq(rp-ne.yzx)));\n}\n\nfloat mlength(vec3 p) {\n    return abs(p.x)+abs(p.y)+abs(p.z);\n}\n\nmaterial mat(vec3 rp) {\n    if (rp.y > 7.-EPSILON*2.) {\n        return material(vec3(1., .92, .43),\n                        vec3(1., .92, .43),\n                        vec3(0.),\n                        0.,\n                        1.,\n                        1., 1.);\n    }\n    \n    if (light(rp) < EPSILON) {\n        return material(vec3(1.), vec3(1.), vec3(8.), 0., 1., 1., 1.);\n    }\n    \n    if (crystal(rp) < EPSILON) {\n        return material(vec3(.2,.45,.95),\n                    vec3(.9,.93,.97),\n                    vec3(0.),\n                         .4,\n                         .54,\n                         .08,\n                         1.24);\n    }\n\n    vec3 arp = abs(rp-vec3(0.,0.,.5))/boxSizeNormalized;\n    float sd = arp.x;\n    int sx = 0;\n    if (arp.y > sd) {\n        sx = 1;\n        sd = arp.y;\n    }\n    if (arp.z > sd) {\n        sx = 2;\n        sd = arp.z;\n    }\n    \n    vec3 c = texture(iChannel3, (sx==0 ? rp.zy : ( sx==1 ? rp.xz : rp.xy ))*.1 ).xyz;\n    return material(c*vec3(.9,1.2,.8)*.75+.25,\n                    vec3(.82),\n                    vec3(0.),//vec3(10.)*max(0., 1.-udBox(abs(rp-vec3(0.,-8.1,2.))-vec3(10.,0.,7.),vec3(1.,0.2,1.))),\n                         0.,\n                         .14,\n                         1.,\n                         1.);\n\n}\n\nvec3 background(in vec3 rd) {\n    return vec3(0.);\n}\n\n\nfloat trace(in vec3 rp, inout vec3 rd, float maxDist) {\n    \n    float d,s = 0.;\n    for (int i = 0; i < ITERATIONS; i++) {\n        d = df(rp+rd*s);\n        if (d < EPSILON || s > maxDist) break;\n        s += d;\n    }\n    \n    if (d < EPSILON) return s;\n    \n    return -1.0;\n}\n\nvec3 randomHemiRay(in vec3 d, in vec3 p, in float amount) {\n    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));\n    return mix(d, rand*sign(dot(d,rand)), amount);\n}\n//ambient occlusion function is XT95's from https://www.shadertoy.com/view/4sdGWN\nfloat ambientOcclusion(in vec3 rp, in vec3 norm) {\n    float sum = 0., s = 0.5;\n    vec3 lastp;\n    \n    for (int i = 0; i < 32; i++) {\n        vec3 p = rp+randomHemiRay(norm,lastp,.4)*s;\n        sum += max(0., (s-df(p))/(s*s));//randomHemiRay(norm,rp,.5)*s);\n        lastp = p;\n        s += .2;\n    }\n    \n    return clamp(1.-sum*.05, 0., 1.);\n}\n\nvoid lighting(in vec3 td, in vec3 sd, in vec3 norm, in vec3 reflDir, in material m, inout vec3 dif, inout vec3 spec) {\n    float ao = ambientOcclusion(td,norm);\n    dif = vec3(.5*ao);\n    spec = vec3(0.);\n        \n\tdif += .5*max(0.,dot(normalize(vec3(1.,4.,3.)), norm));\n}\n\n\nvec3 shade(in vec3 rp, in vec3 rd, in vec3 norm, material m) {\n    vec3 sd = rp+normal2(rp-rd*EPSILON*40.)*EPSILON*10.;//locateSurface(rp)-rd*EPSILON*2.;\n    \n    //lighting\n    vec3 dlc = vec3(0.);\n    \n   \n    vec3 slc = vec3(0.);\n    vec3 reflDir = reflect(rd,norm);\n    vec3 tReflDir = normalize(reflDir+cos(rp*245.245-rd*cos(rp*9954.345)*3532.423)*m.roughness*0.25);\n    tReflDir *= sign(dot(tReflDir,reflDir));\n    \n    #ifdef REFLECTIONS\n    float rtd = trace(sd,tReflDir,VIEW_DISTANCE);\n    if (rtd < 0.) {\n        slc = background(tReflDir);\n    } else {\n        vec3 rhp = sd+tReflDir*rtd;\n        slc = shadeNoReflection(rhp,reflDir,normal(rhp),mat(rhp));\n    }\n    #endif\n    \n    vec3 lightDif,lightSpec;\n    lighting(rp,sd,norm,reflDir,m,lightDif,lightSpec);\n    dlc += lightDif;\n    slc += lightSpec;\n    \n    float fres = 1.-max(0., dot(-rd,norm));\n    \n    return dlc*m.diffuse +\n        \tslc*m.specular +\n        \tm.emissive ;\n}\n\n\nvec3 pathtrace(vec3 rp, vec3 rd) {\n    material m;\n    vec3 norm;\n    vec3 sd = rp;//locateSurface(rp)-rd*EPSILON*2.;\n    \n\n    //lighting\n    vec3 c = vec3(0.),\n         nextCMult = vec3(1.);\n\n    float ifrm = float(iFrame);\n    #define rndifrm (fract(vec3(ifrm*.0004923)+sd)*2.-1.)*1024.2479\n    \n\n    float d,s = 0.,lastD = EPSILON;\n    for (int i = 0; i < ITERATIONS; i++) {\n    \td = df(sd+rd*s);\n        if (d < EPSILON && lastD > EPSILON) {\n                        \n        \tvec3 tp = sd+rd*s;\n            m = mat(tp);\n            norm = normal(tp);\n            tp -= (.5+.5*abs(dot(rd,norm)))*rd*EPSILON*2.;\n            if (hash3(tp+(rndifrm).yzx)-.0001 < max(m.opacity,m.metallic*.5)) {\n                c += nextCMult*m.emissive;\n                if (hash3(tp+rndifrm)-.0001 < m.opacity*.5*(1.-m.metallic)) {\n                    nextCMult *= m.diffuse;\n                    rd = randomHemiRay(norm,tp+rndifrm,1.);\n                } else {\n                    nextCMult *= m.specular;\n                    rd = mix(reflect(rd,norm),\n                             randomHemiRay(norm,tp+rndifrm,1.),\n                              m.roughness);\n                }\n                d = EPSILON;\n            } else {\n                tp += rd*EPSILON*4.;\n                rd = refract( rd, mix(norm,randomHemiRay(norm,tp+rndifrm,1.),m.roughness), AIR_REFR_INDEX/m.refrIndex);\n\n                nextCMult = (nextCMult*m.specular)*(1.+(1.-m.opacity)*m.metallic*.5);\n            }\n            sd = tp;\n            s = 0.;\n       \n        } else {\n            if (d > EPSILON && lastD < EPSILON) {\n\n                sd += rd*s;\n                norm = normal(sd);\n                rd = refract( rd, mix(-norm,randomHemiRay(-norm,sd+rndifrm,1.),m.roughness), m.refrIndex/AIR_REFR_INDEX);\n                /*rd = mix(refract(rd,-norm,m.refrIndex/AIR_REFR_INDEX),\n                             randomHemiRay(norm,sd+rndifrm,1.),\n                              m.roughness);\n                  */\n                nextCMult *= pow(m.diffuse, vec3(1.+s*m.opacity));\n               s = 0.;\n            }\n        }\n        lastD = d;\n        s += max(EPSILON*2.,abs(d));\n        if (s > VIEW_DISTANCE) break;\n     }\n    if (d > BACKGROUND_EPSILON) {\n        c = c+nextCMult*background(rd);\n    }\n    \n    return c;\n}\n\nvec2 randUv(vec2 uv) {\n    return cos(float(iFrame)*.10924+abs(cos(float(iFrame)*2.345+uv)*128.345)+abs(cos(uv.yx*32.345)*16.234));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n\tvec2 uv = (fragCoord - R*.5)/R.x;\n\n    initCamera();\n  \n    #ifndef PATH_TRACE\n        vec3 rp = cameraLocation;\n    vec3 rd = normalize(vec3(uv*vec2(1.,-1.)*FOV_SCALE,1.));\n\n    rd.yz = rot(rd.yz,cameraRotation.y);\n    rd.xz = rot(rd.xz,cameraRotation.x);\n        \n\tfloat itd = trace(rp,rd,VIEW_DISTANCE);\n    if (itd < 0.) {\n        fragColor = vec4(background(rd),1.);\n        return;\n    }\n    \n\n    vec3 hp = rp+itd*rd;\n    fragColor = vec4(shade(hp,\n                      rd,\n                      normal(hp),\n                      mat(hp)),1.);\n\t#else\n    if (iFrame < 120) {\n        fragColor = vec4(0.);\n        return;\n    }\n\tinitCamera();\n    \n    vec3 rp = cameraLocation;\n    vec3 rd = normalize(vec3((uv+randUv(uv)*(1./iResolution.y)*.333333)*vec2(1.,-1.)*FOV_SCALE,1.));\n\n    rd.yz = rot(rd.yz,cameraRotation.y);\n    rd.xz = rot(rd.xz,cameraRotation.x);\n    \n\tfragColor = vec4(texture(iChannel0, fragCoord/R).xyz+pathtrace(rp,rd), 1.);\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}