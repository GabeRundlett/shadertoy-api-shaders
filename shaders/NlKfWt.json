{
    "Shader": {
        "info": {
            "date": "1665837598",
            "description": "Using a triangle grid to create and raymarch an animated extruded rounded asymmetric hexagon jigsaw pattern in realtime.",
            "flags": 0,
            "hasliked": 0,
            "id": "NlKfWt",
            "likes": 46,
            "name": "Extruded Asymmetric Jigsaw",
            "published": 3,
            "tags": [
                "raymarching",
                "grid",
                "triangle",
                "jigsaw",
                "extrude",
                "asymmetric"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 647
        },
        "renderpass": [
            {
                "code": "/*\n\n    Extruded Asymmetric Jigsaw\n    --------------------------\n    \n    This is an animated extruded asymmetric hexagonal jigsaw pattern,\n    created and rendered in realtime.\n    \n    I came up with the idea to do this when investigating ways to extract\n    vertex lists from Voronoi cells within the confines of a pixel shader\n    program, which I managed using half space methods, but it was not fast.\n    \n    I realized later that I could construct a pretty good approximation to \n    hexagonal Voronoi by using packed hexagons with offset vertices -- The \n    added benefit was access to vertex lists. However, as efficient as it \n    was, it wasn't fast enough to raymarch in realtime without resorting to \n    overly complicated backbuffer tricks -- I have an example on Shadertoy\n    somewhere. Thankfully, I stumbled across a really fast way to render \n    extruded asymmetric hexagons when playing around with various patterns \n    on an icosahedral grid and realized it'd work on a flat plane.\n    \n    The process is quite simple: Partition space into equilateral triangles,\n    then render three lines from a randomly offset central point to the \n    random offset central points of each of the neighboring edge triangles.\n    After you've done that, you can use these three lines to construct\n    parts of three offset hexagons -- Uncomment the \"GRID\" define, then \n    refer to the image, if you're having trouble visualizing that. By the \n    way, the same technique can produce packed asymmetic quadrilateral \n    polygons on a square grid.\n    \n    Designwise there's not much to this; Just some 2D rendering on the\n    rounded extruded faces, basic lighting and specular reflection. All of \n    it is simple to implement, and cheap, which always helps. Anyway, I \n    have some icosahedral examples along similar lines that I'll post later.\n    \n\n\n    Other examples:\n    \n    // A regular extruded square jigsaw pattern.\n    Jigsaw - Shane\n    https://www.shadertoy.com/view/XdGBDW\n    \n    // An animated asymmetric hexagon-based random stringy woven \n    // Truchet jigsaw pattern.\n    Animated Hexagon Truchet Chords - Shane\n    https://www.shadertoy.com/view/WsGyDz\n\n\n*/\n\n\n/////////\n\n// Attempting not to unroll loops.\n#define ZERO min(0, iFrame)\n\n// Maximum ray distance.\n#define FAR 10.\n\n// Subtle textured lines.\n#define LINES\n\n// Display the jigsaw pattern, or not.\n#define JIGSAW\n\n// Display the offset triangle grid vertices -- which double as central\n// offset polygon vertices.\n#define SHOW_VERTICES\n\n// Display the offset triangle grid that the jigsaw pieces are constructed from.\n//#define GRID\n\n/////////\n\n\n// Object ID: Either the back plane, extruded object or beacons.\nint objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's hash.\nfloat hash11(float x){ \n    \n    //return texture(iChannel1, vec2(64)*x).x;\n    return fract(sin(x)*43758.5453); \n}\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ \n    \n    return texture(iChannel1, p/64.).x;\n    //return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); \n}\n\n// IQ's vec2 to float hash.\nvec2 hash21A(vec2 p){  \n    vec4 p4 = texture(iChannel1, p/64.);\n    //p.x = fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); \n    return sin(p4.xy*6.2831 + iTime*(p4.zw - .5)*2.)*.5 + .5;\n}\n\n/*\n// IQ's translation of Hugo Elias's old hash routine and\n// Fabrice Neyret's float-to-uint translation.\nfloat hash11(float f){ \n\n    uint n = floatBitsToUint(f*16384.);\n    // Integer hash copied from Hugo Elias.\n\tn = (n<<13U)^n;\n    n = n*(n*n*15731U + 789221U) + 20170906U; // 1376312589U;\n    return float( n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n*/\n\n\n// Polygon face color.\nvec3 getColor(float x){\n\n    vec3 col;\n    \n    // Pink and blue.\n    float rx = hash11(x + .13);\n    col = .5 + .45*cos(x*6.2831/6. + vec3(0, 1, 2).zyx*1.15);\n    //col = mix(cCol, vec3(x*.75 + .1)*vec3(.95, .95, 1.1), 1.); // Greu and pink.\n    if(rx<.25) col = .5 + .45*cos(x*6.2831/16. + vec3(0, 1.5, 2)*2. + .35);\n    \n    \n    // Grey tones.\n    //col = vec3(.7*x + .2);\n \n \n    // Grey and green pastel.\n    //col = .5 + .45*cos(6.2831*x/3. + vec3(0, 1, 2)*1.5 + 3.5);\n    //if(hash11(x)>.65) col = mix(col, vec3(x*.4 + .5)*vec3(.95, .95, 1.1), .95);\n\n\n    // Earthtones.\n    //col = .5 + .45*cos(6.2831*x/4. + vec3(0, 1, 2)*1.35 - .5);\n \n    \n    // Multicolored.\n    //col = .5 + .45*cos(6.2831*x + vec3(0, 1, 2));\n    //col /= (.5 + dot(col, vec3(.299, .587, .114))*.75);\n    \n       \n    return col;\n}\n\n\n// These globals have been hastily put here. Globals don't always represent good\n// practice, but sometimes, it makes life easier. These particular ones don't seem\n// to effect program efficiency too much anyway.\n//\nmat3x2 gVert2D; // The three offset vertices.\n//mat3x2 gCtrN2D; // The three offset neighboring edge triangle vertices.\nvec4 gP4; // Local 2D triangle grid coordinates and triangle ID.\nvec3 gRc; // Unique random polygon number... I might rearrange this one later. \n\n// A standard square grid 2D blobby Truchet routine: Render circles\n// in opposite corners of a tile, reverse the pattern on alternate\n// checker tiles, and randomly rotate.\nvec3 poly(vec2 p, inout mat3x2 vID, inout mat3x2 v){\n\n\n    // Returns the local coordinates (centered on zero), cellID, the \n    // triangle vertex ID and relative coordinates.\n    //scale = 1./2.5; //1./2.\n    vec4 p4 = getTriVerts(p, vID, v);\n    // Local cell coordinates\n    p = p4.xy;\n    // Unique triangle ID (cell position based).\n    vec2 ctrID = p4.zw; \n    \n    gP4 = p4; // Saving the triangle data.\n\n    // Equilateral triangle cell side length.\n    float sL = length(v[0] - v[1]);\n \n    float oFctr = sL/4.; // Offset factor, based on the cell's side length.\n\n    // Distance field holders. One slot for each of the three polygons we'll\n    // be creating. Line (later used to hold the polygon data), jigsaw nodule\n    // distance (not sure why I called it mp), and the random values used for\n    // height and nodule direction (one side of the edge or the other).\n    vec3 ln, mp, rc, rc2;\n    \n   \n    mat3x2 vertOffs; // The offset points.\n\n    \n    for(int i = 0; i<3; i++){\n        // Nearest offset vertex point.\n        vertOffs[i] = v[i] - (hash21A(ctrID + vID[i]) - .5)*oFctr;\n    }\n    \n    // Using the offset vertices to calculate the offset center.\n    //ctrOffs = inCircle(vertOffs[0], vertOffs[1], vertOffs[2]);\n    vec2 ctrOffs = (vertOffs[0] + vertOffs[1] + vertOffs[2])/3.;\n    vec2 ctr = vec2(0); // Local center. //(v[0] + v[1] + v[2])/3.;\n    \n     \n    // If you look at some of the variables, you'll see that I've used a vector shuffling\n    // technique to avoid array indexing, which compilers don't like at all... I'd imagine\n    // it might effect GPU utilization as well. I can thank Shadertoy user, Cyberjax, for\n    // that tip. You'll note that there is some degree of array indexing also, but that was \n    // hard to avoid. In fact, I experimented with substituting \"vec2[3]\" for \"mat3x2\", but\n    // that seemed to slow things down... Although, I might try again later.\n    //\n    // Calculating the three lines eminating from the offset center point, and the nodule\n    // point positions on those lines.\n    for(int i = ZERO; i<3; i++){\n    \n        // The next two indices.\n        int ip1 = (i + 1)%3, ip2 = (i + 2)%3;\n\n\n        // Mid edge point and ID.\n        vec2 midID = mix(vID[i], vID[ip1], .5);\n        vec2 mid = mix(v[i], v[ip1], .5);\n\n        // Use the unique center ID to generate a random polygon height. By \n        // the way, it could be anything you want, like a texture height, etc.\n        rc.x = hash21(ctrID + vID[i] + .1);\n\n        // Random number associated with the triangle edge midpoint. It will \n        // be used to test which side of the edge the nodule will exist upon.\n        // Based on this random number, we'lladd the nodule to one side, and \n        // take away from the other.\n        rc2.x = hash21(ctrID + midID);\n\n\n        // The center ID and position of the triangle neighboring this edge.\n        vec2 ctrNgbrID = ctrID + midID*2.; \n        vec2 ctrNgbr = ctr + mid*2.;\n        // Using the above to create a the third offset vertex in the neighboring triangle.\n        // The first two vertices will be the edge vertices, since the neighboring triangle\n        // cell will share that edge.\n        //\n        // Neighbor center minus the third vertex from this side (symmetry), then \n        // using that ID to offset the vertex.\n        vec2 vertNOffs = (ctrNgbr - v[ip2]) - (hash21A(ctrNgbrID - vID[ip2]) - .5)*oFctr;\n       \n        // The neighboring offset center point for this edge.\n        //vec2 ctrNOffs = inCircle(vertOffs[i], vertOffs[ip1], vertNOffs);\n        vec2 ctrNOffs = (vertOffs[i] + vertOffs[ip1] + vertNOffs)/3.; // Neighbor triangle offsset center.\n        //gCtrN2D[i] = ctrNOffs; // Saving the point for later usage.\n\n\n        // The signed distance to the line connecting this triangle's offset center\n        // to the offset center of the neighboring triangle to this particular edge.\n        ln.x = distLineS(p, ctrOffs, ctrNOffs);\n      \n\n\n        ///////////////\n        // Creating the jigsaw edge nodules.\n        #ifdef JIGSAW\n        // Perpendicular vector and random based direction.\n        vec2 tn = normalize((ctrOffs - ctrNOffs).yx*vec2(1, -1)); \n        float dir = gTri*(rc2.x - .5<0.? -1. : 1.);\n        // Midpoint minus perpendicul direction to that point the make\n        // the nodule stick out a bit.\n        vec2 mOffs = mix(ctrOffs, ctrNOffs, .5);\n        // Round nodule distance... Other shapes are possible, but we're\n        // keeping things simple.\n        mp.x = length(p - mOffs - dir*tn*.013);\n        #endif\n        ///////////////////\n\n\n        // Cyberjax's trick to shuffle the vector entries along one place.\n        // It's extra work, but it cuts down on compile time considerably.\n        // I'm pretty sure it runs faster too, but I can't be certain of that.\n        rc = rc.yzx;\n        rc2 = rc2.yzx;\n        ln = ln.yzx;\n        mp = mp.yzx;\n\n    } \n  \n    // Recording the three offset vertices.\n    gVert2D = vertOffs;\n\n    \n     \n    float smF = .025;//.025;\n    ln = smax(ln, -ln.zxy, smF);//.zxy\n  \n    \n    // Use CSG to apply the jigsaw pattern nodules to the asymmetric hexagon pattern.\n    #ifdef JIGSAW\n    // JIGSAW\n    // Offset lines.\n    vec3 rnd3 = gTri*(rc2 - .5); \n    rnd3 = vec3(rnd3.x<0.? -1 : 1, rnd3.y<0.? -1 : 1, rnd3.z<0.? -1 : 1);\n\n \n    // For positive random numbers, take away a nodule from one side of the\n    // line, and take it away from the other.\n    mp -= .11; // Nodule size.\n    ln = rnd3*smax(rnd3*ln, -mp, smF);\n    ln = rnd3.zxy*smin(rnd3.zxy*ln, mp.zxy, smF);\n    #endif\n\n    gRc = rc; // Record the random polygon value for usage in the map function below.\n    //gPoly2D = ln; // Record the 2D polygon distance for usage in the map function below\n     \n    return ln; \n}\n \n\n// The scene's distance function: There'd be faster ways to do this, but it's\n// more readable this way. Plus, this  is a pretty simple scene, so it's \n// efficient enough.\nfloat m(vec3 p){\n    \n    // Cell coordinate, ID and triangle orientation id.\n    // Cell vertices and vertex ID.\n    mat3x2 v, vID;\n    \n    // 2D Truchet distance -- for the extrusion cross section.\n    vec3 pol = poly(p.xy, vID, v);\n   \n    // Rescaling the random heights.\n    vec3 nRc = gRc*.15 + .05;\n    \n    // 2D distance to offset vertex points.\n    vec3 v3 = vec3(length(gP4.xy - gVert2D[0]), length(gP4.xy - gVert2D[1]), length(gP4.xy - gVert2D[2]));\n    \n    \n    // Extruding the polygons.\n    vec3 s = pol + .008;\n    vec3 r = abs(p.z + nRc) - nRc;\n    pol = max(s, r) + (v3 - scale/2.)*.05; // + s*.05;\n    // Bevel.\n    //pol = max(s, r) - smoothstep(.05, .09, -s)*.015;\n \n    // Proper extrusion formula for comparisson.\n    /*\n    vec3 s = pol + .008;\n    vec3 r = abs(p.z + nRc) - nRc;\n    pol = min(max(s, r), 0.);\n    pol += vec3(length(max(vec2(s.x, r.x), 0.)), length(max(vec2(s.y, r.y), 0.)), \n                         length(max(vec2(s.z, r.z), 0.)));\n    pol += (v3 - scale/2.)*.05;\n    */\n\n    // The closest of the three extruded polygons.\n    float obj = min(min(pol.x, pol.y), pol.z); \n    \n    \n    // Back plane. Not really necessary, but it's there.\n    float fl = -p.z;\n    \n    // Object ID.\n    objID = fl<obj? 0 : 1;\n    \n    // Minimum distance for the scene.\n    //return min(min(fl, obj), vert);\n    return min(fl, obj);\n    \n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float d, t = 0.; //hash21(r.xy*57. + fract(iTime + r.z))*.5;\n    \n    for(int i = ZERO; i<64; i++){\n    \n        d = m(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not affordable for slower machines.\n    const int iter = 24; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = ZERO; i<iter; i++){\n\n        float d = m(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // IQ's subtle refinement.\n        t += clamp(d, .01, .15); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = ZERO; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = m(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n  \n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(in vec3 p) {\n\t\n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += m(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\nvoid mainImage(out vec4 c, vec2 u){\n\n    \n    // Aspect correct coordinates. Only one line necessary.\n    u = (u - iResolution.xy*.5)/iResolution.y;    \n    \n    // Unit direction vector, camera origin and light position.\n    vec3 r = normalize(vec3(u, 1)), o = vec3(0, iTime/6., -3), l = o + vec3(.25, .5, 2);\n    \n    // Rotating the camera about the XY plane.\n    r.yz = rot2(.15)*r.yz;\n    r.xz = rot2(-cos(iTime*3.14159/32.)/8.)*r.xz;\n    r.xy = rot2(sin(iTime*3.14159/32.)/8.)*r.xy; \n  \n    \n    // Raymarch to the scene.\n    float t = trace(o, r);\n \n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int gObjID = objID;\n \n \n    // Very basic lighting.\n    // Hit point and normal.\n    vec3 p = o + r*t, n = nr(p); \n    \n    \n        // Basic point lighting.   \n    vec3 ld = l - p;\n    float lDist = length(ld);\n    ld /= lDist; // Light direction vector.\n    float at = 1./(1. + lDist*lDist*.125); // Attenuation.\n    \n    // Very, very cheap shadows -- Not used here.\n    //float sh = min(min(m(p + ld*.08), m(p + ld*.16)), min(m(p + ld*.24), m(p + ld*.32)))/.08*1.5;\n    //sh = clamp(sh, 0., 1.);\n    float sh = softShadow(p, l, n, 8.); // Shadows.\n    float ao = calcAO(p, n); // Ambient occlusion.\n    \n    float df = max(dot(n, ld), 0.); // Diffuse.\n    float sp = pow(max(dot(reflect(r, n), ld), 0.), 32.); // Specular.\n    //df = pow(df, 4.)*2.;\n   \n    \n    \n    // UV texture coordinate holder.\n    vec2 uv = p.xy;\n    \n\n    \n    ////////////\n    // Cell coordinate, ID and triangle orientation id.\n    // Cell vertices and vertex ID.\n    mat3x2 v, vID;\n    // Returns the three 2D polygons that surround the three vertices of the triangle.\n    vec3 poly2D = poly(p.xy, vID, v);\n    vec2 p2 = gP4.xy;\n    /////////////\n    \n    \n    vec4 col1 = vec4(1, .15, .4, 0);\n    vec4 col2 = vec4(.4, .7, 1, 0);\n\n    \n    // Object color.\n    vec4 oCol;\n  \n    \n    // Use whatever logic to color the individual scene components. I made it\n    // all up as I went along, but things like edges, textured line patterns,\n    // etc, seem to look OK.\n    //\n    if(gObjID == 0){\n    \n       // The floor. Redundant here, but it might be needed later.\n       oCol = vec4(0);\n      \n    }\n    else {\n    \n        // Extruded offset hexagons:\n        vec4 cCol;\n        vec3 nRc = gRc*.15 + .05;\n        // The distance surrounding the three  offset triangle vertices.\n        vec3 d3 = vec3(length(gP4.xy - gVert2D[0]), length(gP4.xy - gVert2D[1]), \n                       length(gP4.xy - gVert2D[2]));\n        vec3 poly3D = max(abs(p.z + nRc) - nRc, poly2D.xyz + .008) + (d3 - scale/2.)*.05; // svPoly2D*.05;\n        int gPID = poly3D.x<poly3D.y && poly3D.x<poly3D.z? 0 : poly3D.y<poly3D.z? 1 : 2;\n        // Random polygon value - The polygon surrounds the vertex point, so the unique ID is\n        // the triangle ID plus the vertex ID.\n        float rnd = hash21(gP4.zw + vID[gPID] + .1);\n        // Generating a random color based on the random value above.\n        cCol.xyz = getColor(rnd);\n        \n        // Random offset value, based on the side length and the polygon ID.\n        // There values match the ones used by the raymarched distance funtion.\n        float oFctr = length(v[0] - v[1])/4.;\n        vec2 cOffs = (hash21A(gP4.zw + vID[gPID]) - .5)*oFctr;\n        \n        // A bluish white color.\n        //cCol = vec4(.7, .8, .9, 0);\n        // Diffuse color... Kind of interesting looking.\n        //cCol = vec4(df);\n         \n        // Make some polygons a different color.\n        //if(cCol.x<.5) if(hash11(rnd)<.85) cCol = cCol.yzxw*cCol.yzxw;\n        \n        // Trim color -- Bluish white.\n        vec4 trimCol = vec4(.7, .8, .9, 0); \n        \n        vec4 svCol = cCol; // Save the face color.\n        \n        // 2D polygon distance. Used to decorate the polygon face with edges, etc. \n        float d = poly2D[gPID]; \n        \n        // Using difference diffuse values on the face or edges, etc.\n        //df = mix(pow(df, 4.)*2., df, 1. - smoothstep(0., .01, d + .06));\n        \n        vec2 ctrOffs = (gVert2D[0] + gVert2D[1] + gVert2D[2])/3.;\n         \n        float ln = 1e5;\n         \n        // Offset triangle edge lines, used to display the grid.\n        #ifdef GRID\n        for(int i = 0; i<3; i++){\n            ln = min(ln, abs(distLineS(p2, gVert2D[i], gVert2D[(i + 1)%3])));\n        }\n         \n        /*  \n        // This one confused me for a while. You need to render lines from the\n        // closest point to the following three points: \n        // Tri center and the centers of the neighboring triangles of the vertex's\n        // joining edges. You'd need to commment \"gCtrN2D\" back in wherever it appears.\n        ln = min(ln, abs(distLineS(p2, ctrOffs, gVert2D[gPID])));\n        ln = min(ln, abs(distLineS(p2, gCtrN2D[gPID], gVert2D[gPID])));\n        ln = min(ln, abs(distLineS(p2, gCtrN2D[(gPID + 2)%3], gVert2D[gPID]))); \n        */ \n \n        // Hacky dashed lines.\n        ln = smax(ln, -(d3[gPID] - .1), .025);\n        ln = smax(ln, -(abs(fract(d3[gPID]*8.) - .5) - .1)/8., .025);\n        ln = smax(ln, (d + .08),.025);\n   \n        // Render the lines onto the face.\n        cCol = mix(cCol, cCol*1.15 + .075, (1. - smoothstep(0., .02, ln - .015)));\n        cCol = mix(cCol, vec4(0), 1. - smoothstep(0., .01, ln - .004));\n        #endif\n        \n       \n        // Subtle line pattern.\n        // Pinning the pattern to the offset point. I prefer it this way, but you\n        // could let the point float above a fixed pattern instead.\n        float lSc = 36.;\n        vec2 txP = p.xy + cOffs;\n        #ifdef LINES\n        float pat = (abs(fract((txP.x - txP.y)*.7071*lSc - .5) - .5) - .25)/lSc;\n        cCol = mix(cCol, vec4(0), (1. - smoothstep(0., .01, pat))*.35);\n        #else\n        cCol *= .85;\n        #endif\n        \n        \n        // White sides with a dark edge. \n        oCol = trimCol;\n        oCol = mix(oCol, vec4(0), 1. - smoothstep(0., .01, d + .04));\n        oCol = mix(oCol, cCol, 1. - smoothstep(0., .01, d + .06));\n        \n        //df = mix(df, pow(df, 2.)*1.2, 1. - smoothstep(0., .01, d + .05));\n     \n        ////\n        \n        #ifdef SHOW_VERTICES\n        // Rendering the offset central node.\n        float d2 = d3[gPID] - .07; // Closest distance.\n        oCol = mix(oCol, vec4(0), 1. - smoothstep(0., .01, d2));//.016=5\n        oCol = mix(oCol, trimCol, 1. - smoothstep(0., .01, d2 + .02));//.016=5\n        oCol = mix(oCol, vec4(0), 1. - smoothstep(0., .01, d2 + .04));//.016=5\n        oCol = mix(oCol, svCol, 1. - smoothstep(0., .01, d2 + .06));//.016=5\n        #endif\n        \n        /*\n        float rim = -(p.z + nRc[gPID]*2.) + .05;\n        oCol = mix(oCol, vec4(0), 1. - smoothstep(0., .01, rim));\n        oCol = mix(oCol, vec4(.7, .8, .9, 0)*.7, 1. - smoothstep(0., .01, rim + .025));\n        */\n        \n        \n        /*\n        // Corrugation on the sides -- Interesting, but a bit much, I think.\n        lSc = 24.;\n        pat = (abs(fract((rim)*lSc - .5) - .5) - .1)/lSc;\n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, max(pat, rim)))*.5);\n        */\n        \n        \n    }\n\n\n\n    // Specular reflection.\n    vec3 hv = normalize(-r + ld); // Half vector.\n    vec3 ref = reflect(r, n); // Surface reflection.\n    vec4 refTx = texture(iChannel0, ref); refTx *= refTx;\n    refTx = (oCol*1.5 + .66)*refTx;//smoothstep(.2, .5, refTx);\n    float spRef = pow(max(dot(hv, n), 0.), 8.); // Specular reflection.\n    float rf = (gObjID == 0)? .1 : 1.;//mix(.5, 1., 1. - smoothstep(0., .01, d + .08));\n    oCol += spRef*refTx*rf*.5; //smoothstep(.03, 1., spRef) \n\n      \n    // Apply the lighting and shading. \n    c = oCol*(df*sh + sp*sh + .5)*at*ao;\n    \n     \n \n    // Rough gamma correction.\n    c = sqrt(max(c, 0.));  \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning. By the way, this\n// will partition all repeat grid triangles, not just equilateral ones.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nconst float scale = 1./1.6;\n \nfloat gTri;\n\nvec4 getTriVerts(in vec2 p, inout mat3x2 vID, inout mat3x2 v){\n\n    // Rectangle scale.\n    const vec2 rect = (vec2(1./.8660254, 1))*scale;\n\n    // Skewing half way along X, and not skewing in the Y direction.\n    const vec2 sk = vec2(rect.x*.5, 0)/scale; // 12 x .2\n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //gTri = p.x/rect.x < -p.y/rect.y? 1. : -1.;\n    // Base on the bottom (-1.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n    \n    // Vertex IDs for each partitioned triangle: The numbers are inflated\n    // by a factor of 3 to ensure vertex IDs are precisely the same. The\n    // reason behind it is that \"1. - 1./3.\" is not always the same as\n    // \"2./3\" on a GPU, which can mess up hash logic. However, \"3. - 2.\"\n    // is always the same as \"1.\". Yeah, incorporating hacks is annoying, \n    // but GPUs don't work as nicely as our brains do, unfortunately. :)\n    if(gTri<0.){\n        vID = mat3x2(vec2(-1.5, 1.5), vec2(1.5, -1.5), vec2(1.5));\n    }\n    else {\n        vID = mat3x2(vec2(1.5, -1.5), vec2(-1.5, 1.5), vec2(-1.5));\n    }\n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect/3., sk); // Unskew.\n    \n    // Centering at the zero point.\n    vec2 ctr = v[2]/3.; // Equilateral equivalent to: (v[0] + v[1] + v[2])/3;\n    p -= ctr;\n    v[0] -= ctr; v[1] -= ctr; v[2] -= ctr;\n    \n     // Centered ID, taking the inflation factor of three into account.\n    vec2 ctrID = vID[2]; //(vID[0] + vID[1] + vID[2])/3.;//vID[2]/2.; //\n    id = id*3. + ctrID;   \n    // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n    vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n\n\n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, id);\n}\n\n/*\n// IQ;s signed distance to an equilateral triangle.\n// https://www.shadertoy.com/view/Xl2yDW\nfloat sdEqTri(in vec2 p, in float r){\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if(p.x + k*p.y>0.) p = vec2(p.x - k*p.y, -k*p.x - p.y)/2.;\n    p.x -= clamp(p.x, -2.*r, 0.);\n    return -length(p)*sign(p.y);\n}\n*/\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n   \n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nvec3 smin(vec3 a, vec3 b, float k){\n   vec3 f = max(vec3(0), 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\nvec3 smax(vec3 a, vec3 b, float k){\n   vec3 f = max(vec3(0), 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n/////////\n  \n// Triangle's incenter: The center of the inscribed circle, which in essence is\n// the largest circle that you can fit into a triangle.\nvec2 inCircle(in vec2 v0, in vec2 v1, in vec2 v2){\n    \n    // Side lengths.\n    vec3 len = vec3(length(v2 - v1), length(v0 - v2), length(v1 - v0));\n    //return (bc*p0 + ac*p1 + ab*p2)/dot(len, vec3(1));\n    return mat3x2(v0, v1, v2)*len/dot(len, vec3(1));\n}\n\n\n// Signed distance to a line passing through A and B.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}