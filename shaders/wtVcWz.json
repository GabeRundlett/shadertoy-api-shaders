{
    "Shader": {
        "info": {
            "date": "1621086543",
            "description": "Using a hexagon grid to create a packed random heart pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtVcWz",
            "likes": 28,
            "name": "Geometric Heart Pattern",
            "published": 3,
            "tags": [
                "hexagon",
                "heart",
                "geometry",
                "hash"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 789
        },
        "renderpass": [
            {
                "code": "/*\n\n    Geometric Heart Pattern\n    -----------------------\n    \n    I must be a romantic at heart, because I love heart examples. This is a\n    very abstract version, but there's some really nice examples on here for\n    anyone interested. I coded it up a while back after playing around with \n    hexagonal grids. In fact, it's just a hexagonal grid example in disguise. \n    \n    Producing the geometry didn't pose too many problems, but I made everything \n    up as I went along, so there'd definitely be cleverer ways to go about it. \n    If it were not for the slightly randomized vertex points, this would be a \n    much simpler and faster example.\n    \n    The hash pattern overlay was made up on the spot also, so I wouldn't pay \n    too much attention to its construction either. It wasn't difficult to make: \n    Obtain the pixel's greyscale value, then render overlapped rotated lines. \n    Darker shades require more rotated line layers and lighter ones require \n    fewer. I had hoped to put the pattern in extruded form, but ran out of \n    steam making the 2D version, so maybe at a later date. :)\n    \n    \n    \n    // Other heart examples:\n    \n    Pixel Heart - Fizzer\n    https://www.shadertoy.com/view/MlByzh    \n    \n    Heart - 2D - iq\n    https://www.shadertoy.com/view/XsfGRn\n    \n    Zeta heart for my wife - Logos\n    https://www.shadertoy.com/view/3lKXzt\n\n*/\n\n\n// If you want a better idea of how the pattern was created, uncomment this.\n//#define SHOW_GRID_CELLS\n\n// Rounded hearts: This complicates things, but it looks cool.\n//#define ROUNDED\n\n// Offset vertices.\n#define OFFSET\n\n// Pink: 0, Golden Brown: 1, Mix: 2.\n#define COLOR 2\n\n\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n \n// Global vertices and local coordinates of the triangle cell.\n// It's lazy putting them here, but I'll tidy them up later.\nvec2[8] gV;\nvec2 gP;\nfloat d2D;\n\n\nvec4 blocks(vec3 q){\n    \n    \n    // Brick dimension: Length to height ratio with additional scaling.\n    #ifdef FLAT_TOP\n    const vec2 dim = scale*vec2(1.732/2., 1);\n    #else\n    const vec2 dim = scale*vec2(1, 1.732/2.);\n    #endif\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;//*vec2(1, .5); \n    \n\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // Four block corner postions.\n    //const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    //vec2[4] ps4 = vec2[4](vec2(1, -.5), vec2(0, -.5), vec2(-.5, .5), vec2(.5));\n    // Four block corner postions.\n    const vec2 ll = vec2(.5);//vec2(.5, 1);// \n    //vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll, vec2(ll.x, -ll.y));\n    // Pointed top.\n    #ifdef FLAT_TOP\n    // Flat top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll + vec2(0., ll.y), -ll, \n                          vec2(ll.x, -ll.y) + vec2(0., ll.y));\n    #else\n    // Pointed top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll + vec2(ll.x, 0), \n                          vec2(ll.x, -ll.y) + vec2(ll.x, 0));\n    #endif   \n  \n\n    d2D = 1e5;\n    \n        \n    float triID = 0.; // Triangle ID. Not used in this example, but helpful.\n\n\n\n\n    // Initializing the global vertices and local coordinates of the triangle cell.\n    //gV = vec2[6](vec2(0), vec2(0), vec2(0), vec2(0), vec2(0), vec2(0));\n    gP = p;\n    \n    // Hexagon vertices. \n    vec2[6] vert = vID;  \n \n    vert[0] *= dim;\n    vert[1] *= dim;\n    vert[2] *= dim;\n    vert[3] *= dim;\n    vert[4] *= dim;\n    vert[5] *= dim;\n    \n    for(int i = min(0, iFrame); i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.;\n        \n        // Local coordinates.\n        p = q.xy;\n        \n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        \n        \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n \n        //vec2 inC = (vert[0] + vert[1] + vert[2] + vert[3] + vert[4] + vert[5])/6.;\n        \n        float face1 = sdPoly(p, vert); \n        vec2 offs = vec2(0);//inC.xy;\n        vec2 idi1 = idi + offs;\n         \n         \n         \n        // For each hexagon, render three heart shapes.\n        // Uncomment \"SHOW_GRID_CELLS\" for a visual guide.\n      \n        // Randomly offsetting the index for a random rotation effect.\n        int rI = hash21(idi)<.5? 1 : 0;\n        \n        // Random angle. \n        \n        #ifdef OFFSET\n        const float ra = -atan(sqrt(3.)/5.) - .075; // .333473172\n        //const float ra = -6.2831/19.;//24.;\n        const float len = sqrt(4./7.)/1.03;\n        #else\n        const float ra = -atan(sqrt(3.)/5.);\n        const float len = sqrt(4./7.);\n        #endif\n        \n        for(int jj = min(0, iFrame); jj<6; jj+=2){\n        \n            int j = jj + rI;\n            j = j%6; \n\n            // Use the hexagonal cell geometry to determine the eight polygon\n            // vertices for each heart shape.\n            vec2[8] vJ;\n            vJ[0] = vec2(0);\n            vJ[1] = rot2(ra)*vert[j]*len;\n            vJ[2] = vert[j];\n            //vJ[3] = vert[j] - rot2(-6.2831/3.)*(vJ[2] - vJ[1]);\n            vJ[3] = eID[j]*s + rot2(ra)*vert[(j + 4)%6]*len;\n            vJ[4] = rot2(ra)*vert[(j + 1)%6]*len;\n\n\n            vJ[5] = vert[(j + 1)%6];\n            // vJ[5] = vert[(j + 1)%6] - rot2(-6.2831/3.)*(vJ[6] - vJ[5]);\n            vJ[6] = eID[(j + 1)%6]*s + rot2(ra)*vert[(j + 5)%6]*len;\n            vJ[7] = rot2(ra)*vert[(j + 2)%6]*len;\n          \n            //// \n            #ifdef ROUNDED\n            // Moving the vertices in to help create rounded polygons. Rounded offset \n            // polygons can be created by simply adding a factor to the distance field. \n            // Unfortunately, in a packed grid, that would create overlap, so it's necessary \n            // to move the points in first, then add the amount. This is less trivial, as \n            // you can see, but is just a bit of trigonometry. The following is robust, but \n            // was something I came up with on the spot, so if anyone knows of a more \n            // elegant way, feel free to let me know. Remember that this is just a one-off \n            // precalculation, so speed isn't a factor.\n            const float ndg = .125*GSCALE.x;\n            vec2[8] tmpV;\n\n            //tmpV[0] = vJ[0];\n            for(int k = min(iFrame, 0); k<8; k++){\n\n                // Vertices and flanking neighbors.\n                vec2 g = vJ[k];\n                vec2 g1 = vJ[(k + 1)%8];\n                vec2 g2 = vJ[(k + 7)%8];\n\n                // Move the vertices in the direction of the tangent vector\n                // by the nudge factor.\n                vec2 v1 = g1 - g;\n                vec2 v2 = g - g2;\n\n                vec2 tng1 = normalize(v1); // Tangent vector.\n                vec2 tng2 = normalize(v2); // Tangent vector.\n                vec2 n1 = tng1.yx*vec2(1, -1); // Normal vector.\n                vec2 n2 = tng2.yx*vec2(1, -1); // Normal vector.\n\n                vec2 interP;\n                lineIntersection(g - tng1 + n1*ndg, g + tng1 + n1*ndg, \n                                 g - tng2 + n2*ndg, g + tng2 + n2*ndg, interP);\n\n                // Angle between vectors.\n                //float ang = acos(dot(v1, v2)/length(v1)/length(v2));\n                //float sl = ndg/tan(ang/2.);\n                tmpV[k] = interP;//g + sl*nj + ndg*nj.yx*vec2(1, -1);\n\n\n                //if(ang>1e5) break; // Fake break.\n            }\n\n            vJ = tmpV;\n            #endif\n            /////       \n            \n            \n            // Construct this particular heart polygon.\n            float faceJ = sdPoly(p, vJ);\n            #ifdef ROUNDED\n            faceJ -= ndg;\n            #endif\n            \n            vec4 di = vec4(faceJ, idi1, float(j/2));\n            \n            // Fake break to trick the compiler into not being ridiculously slow.\n            if(di.x>1e6) break; \n\n            // If applicable, update the overall minimum distance value,\n            // ID, and box ID. \n            if(di.x<d){\n            \n                d = di.x;\n                id = di.yz;\n                triID = di.w;\n\n                // Setting the vertices and local coordinates.\n                gV = vJ;\n                gP = p;\n\n                d2D = face1; \n\n            }\n        \n        }\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return vec4(d, id, triID);\n}\n\n\n\n // IQ's float to float hash.\nfloat hash11(float x){  return fract(sin(x)*43758.5453); }\n\n\n\nvoid swap(inout int a, inout int b){ int tmp = a; a = b; b = tmp; }\n// A swap without the extra declaration -- It works fine on my machine, but I'm\n// not game  enough to use it, yet. :)\n//void swap(inout int a, inout int b){ a = a + b; b = a - b; a = a - b; }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling, rotation and translation.\n    const float gSc = 1.;\n    float sf = gSc/iResolution.y;\n    float ra = -atan(sqrt(3.)/5.);\n    vec2 p = rot2((ra + 3.14159))*(uv*gSc + vec2(1, .5)*iTime/16.);\n    \n    // The heart tiles offset -- for highlighting.\n    vec4 d4Hi = blocks(vec3(p - normalize(vec2(1, 2))*.003, 0));\n    vec4 svGIDHi = d4Hi;//.yzw; // Individual block ID.\n    \n     // The heart tiles.\n    vec4 d4 = blocks(vec3(p, 0));\n    vec4 svGID = d4; // Individual block ID.\n    vec2 svP = gP;\n    vec2[gV.length()] svV = gV;\n    //float svH = gH;\n    float svD2D = d2D;\n    \n    // Bump value.\n    float bump = max(d4Hi.x - d4.x, 0.)/.003*.7;\n    \n    // Scene color.\n    vec3 col = vec3(0);\n    \n    // Cell center.\n    vec2 ctr = vec2(0);\n    //for(int i = 0; i<svV.length(); i++) ctr += svV[i]/float(svV.length());\n    ctr += normalize(mix(svV[5], svV[6], .5))*scale.x*.35;\n    \n    // Some random values.\n    float rnd = hash21((svGID.yz + ctr));\n    float rnd2 = hash21(svGID.yz + ctr + .35);\n    float rnd3 = hash21(svGID.yz + ctr + .65);\n    \n    // Use the above to produce a cell color.\n    vec3 cCol = .6 + .4*cos(6.2831853*rnd/4. + vec3(0, 1, 2));\n    vec3 gCol = .6 + .4*cos(6.2831853*rnd/4. + vec3(0));\n    float gr = dot(cCol/4., vec3(.299, .587, .114));\n    //cCol = vec3(.7, .8, 1)*(rnd*.05 + .05);\n    //cCol = vec3(1)*dot(cCol/4., vec3(.299, .587, .114));\n    \n    // Pink coloring.\n    vec3 hCol = mix(vec3(1, .05, .5), vec3(1, .15, .4), rnd3);\n    //vec3 hCol = mix(vec3(1, .05, .15), vec3(1, .1, .05), rnd3);\n    //hCol *= mix(vec3(.25, .5, 1), vec3(1, .8, .2), bump);\n    \n    #if COLOR == 2\n    // Color half of them with golden brown shades.\n    if(hash21(svGID.yz + ctr + .25)<.5) hCol = cCol/3.;\n    #elif COLOR == 1\n    // All golden brown\n    hCol = cCol/3.;\n    #endif\n    \n    // Bump based coloring.\n    hCol *= mix(vec3(1, .4, .2), vec3(1, .7, .3), bump);\n    \n    // Coloring and shading.\n    d4.x += .005; \n    float sh = max(.25 - d4.x/.03, 0.);\n    //if(mod(svGID.w, 3.)!=2.) \n    //cCol = mix(cCol.zyx, cCol.yxz, step(.5, fract(rnd*57. + .5)));\n    cCol = mix(gCol, min(hCol*5., 1.8), \n               smoothstep(.9, .95, sin(rnd2*6.2831 + iTime*1.)*.5 + .5));\n \n    // Render the heart.\n    col = mix(col, vec3(1), 1. - smoothstep(0., sf, d4.x));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d4.x + .0075));\n    col = mix(col, cCol, 1. - smoothstep(0., sf, d4.x + .0125));\n    \n    // Add highlighting.\n    col = col*(vec3(.5, .7, 1)*bump*bump*2. + .5);    \n    \n    \n    \n    // Hatch algorithm.\n    //////\n    float gry = dot(col, vec3(.299, .587, .114)); // Greyscale pixel value.\n    //gry = sqrt(gry);\n    float pat = 1.;\n      \n    // Perturb the pixel slightly. \n    vec2 q = p + (vec2(n2D3G(p*8.), n2D3G(p*8. + .5)) - .5)*.02; \n    \n    // Add five layers of rotated lines over the top, depending on how dark\n    // the greyscale pixel value is.\n    const int NN = 5;\n    const float fn = float(NN);\n    float lns = 150.*iResolution.y/450.;\n    for(int i = 0; i<NN; i++){\n        \n        vec2 rp = rot2(-ra - 3.14159/3. - float(i)*6.2831/(fn)/2.)*q;\n        rp += float(i)/fn;\n        float patL = abs(fract((rp.x)*lns) - .5)*2. - .05;\n        \n        if(gry<(fn - float(i))/(fn + 1.)) pat = min(pat, patL);\n    }\n    \n    // Apply the hatch pattern.\n    pat = smoothstep(0., sf*lns*2., pat);\n    col = mix(col, col*vec3(pat*.8 + .4), 1. - smoothstep(0., sf, d4.x + .0125));\n    /////\n     \n    \n    // More highlighting.\n    //float dt = length(svP - ctr) - .015;\n    //col = mix(col, col*2., (1. - smoothstep(0., sf*8., dt))*.5);\n    \n    \n    #ifdef SHOW_GRID_CELLS\n    // Hexagon cells.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., abs(svD2D) - .006))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(svD2D) - .006));\n    col = mix(col, vec3(2, .9, .25), 1. - smoothstep(0., sf, abs(svD2D) - .001));\n    #endif\n                      \n\n    // Rough gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Grid pattern repeat scale. Baking wrapped distance fields into textures can be \n// a little fiddly. Basically, the pattern is wrapped on a 64 by 64 unit basis.\nfloat repSc = 1024./4.;\n\n// This sets the scale of the extruded shapes. Because of the way I've calculated\n// things, the scale needs to be even divisors and each term needs to be equal --\n// I use it in other applications where I can use two different numbers though. \n// As above, if you choose this option, a reset will be necessary. Ie. Hit the \n// back button.\n#define GSCALE vec2(1./3.)\n\n\nconst vec2 scale = GSCALE;\n\n\n//#define FLAT_TOP\n#ifdef FLAT_TOP\n// Vertices: Clockwise from the left.\nvec2[6] vID = vec2[6](vec2(-2./3., 0), vec2(-2./6., .5), vec2(2./6., .5), \n                      vec2(2./3., 0), vec2(2./6., -.5), vec2(-2./6., -.5)); \nvec2[6] eID = vec2[6](vec2(-.5, .25), vec2(0, .5), vec2(.5, .25), \n                      vec2(.5, -.25), vec2(0, -.5), vec2(-.5, -.25));\n#else\n// Vertices: Clockwise from the bottom left. -- Basically, the ones \n// above rotated anticlockwise. :)\nvec2[6] vID = vec2[6](vec2(-.5, -2./6.), vec2(-.5, 2./6.), vec2(0, 2./3.), \n                      vec2(.5, 2./6.), vec2(.5, -2./6.), vec2(0, -2./3.));\nvec2[6] eID = vec2[6](vec2(-.5, 0), vec2(-.25, .5), vec2(.25, .5), vec2(.5, 0), \n                      vec2(.25, -.5), vec2(-.25, -.5));\n#endif\n\n////////\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// vec2 to vec2 hash.\nvec2 hash22C(vec2 p) { \n\n    p = mod(p, repSc);\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    vec2 n = sin(vec2(dot(p, vec2(27.29, 57.81)), dot(p, vec2(7.14, 113.43))));\n    return fract(vec2(262144.1397, 32768.8793)*n)*2. - 1.; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n);\n    //return sin(p*6.2831853 + gTime); \n    \n}\n\n\n// IQ's distance to a regular pentagon, without trigonometric functions. \n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22C(i), p);\n    v.y = dot(hash22C(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22C(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22C(i + 1.), p - 1.);\n\n#if 1\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \n} \n\n\n// IQ's irregular polygon distance function. \n// Other distances here:\n// https://iquilezles.org/articles/distfunctions2d\n//\n#define NV 6\n//\nfloat sdPoly(in vec2 p, in vec2[NV] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // Distance.\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // Winding number from: http://geomalgorithms.com/a03-_inclusion.html.\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n// IQ's irregular polygon distance function. \n// Other distances here:\n// https://iquilezles.org/articles/distfunctions2d\n//\n#define NV8 8\n//\nfloat sdPoly(in vec2 p, in vec2[NV8] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // Distance.\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // Winding number from: http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n//Cross product of 2d vectors returns scalar\n//1 = perpendicular, 0 = colinear\nfloat cross2D(vec2 v1, vec2 v2){\n    return v1.x * v2.y - v1.y * v2.x;\n}\n\n//Line intersection algorithm\n//Based off Andre LaMothe's algorithm in \"Tricks of the Windows Game Programming Gurus\".\nbool lineIntersection(vec2 L1A, vec2 L1B, vec2 L2A, vec2 L2B, out vec2 p){\n\n    //Line 1 Vector\n    vec2 v1 = L1B - L1A;\n    \n    //Line 2 Vector\n    vec2 v2 = L2B - L2A;\n    \n    //Cross of vectors\n    float d = cross2D(v1,v2);\n    \n    //Difference between start points\n    vec2 LA_delta = L1A - L2A;\n    \n    //Percentage v1 x LA_delta is along v1 x v2\n    float s = cross2D(v1,LA_delta) / d;\n    \n    //Percentage v2 x LA_delta is along v1 x v2\n    float t = cross2D(v2,LA_delta) / d;\n\n    p = vec2(1e6);\n    \n    //Do segments intersect?\n    //Bounds test\n    if (s >= 0.0 && s <= 1.0 && t >= 0.0 && t <= 1.0)\n    {\n        //Projection\n        p = vec2(L1A.x + (t * v1.x), L1A.y + (t * v1.y)); \n        return true;\n    }\n    return false;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}