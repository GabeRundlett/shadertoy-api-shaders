{
    "Shader": {
        "info": {
            "date": "1676398097",
            "description": "Pathtracer with better materials",
            "flags": 32,
            "hasliked": 0,
            "id": "ctSSRV",
            "likes": 7,
            "name": "Better Materials pt",
            "published": 3,
            "tags": [
                "3d",
                "materials",
                "pathtracer"
            ],
            "usePreview": 0,
            "username": "RubberDuck55",
            "viewed": 267
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    fragColor = vec4(data.rgb / data.a, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Loosely Based off of methods described here:\n// https://blog.demofox.org/#Graphics\n\n// Raymaracher Settings\n#define MAX_DIST   100.\n#define MAX_STEP   250\n#define SURF_DIST  0.01\n\n// Pathtracer Settings\n#define BOUNCES    4\n#define SAMPLES    2 // Increase this number if it is still running at 60fps\n\n// Surface Settings\n#define COLR       0\n#define CHEK       1\n\n\nfloat seed;\n\nstruct MaterialInfo {\n    vec3 albedo;\n    vec3 emissive;\n    vec3 specular;\n    float specPercent;\n    float specRough;\n    vec3 refraction;\n    float refrPercent;\n    float refrRough;\n    float IOR;\n    int surface;\n};\n\nMaterialInfo zeroed_mat () {\n    return MaterialInfo (\n        vec3(0.05),\n        vec3(0.),\n        vec3(0.),\n        0.,\n        0.,\n        vec3(0.),\n        0.,\n        0.,\n        0.,\n        COLR\n    );\n}\n\nstruct HitInfo {\n    float dist;\n    vec3 pos, n, ro, rd;\n    bool hit;\n    bool fromIn;\n    MaterialInfo mat;\n};\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, -s, s, c);\n}\n\nvoid init_rand (vec2 p) {\n    p = vec2(mod(p.x, 32.321), mod(p.y, 526.834));\n    float s = sin(p.x * 453.432) * 342.324 - cos(p.y * 345.468) * 732.345;\n    seed = s;\n}\n\nfloat rand () {\n    seed += fract(sin(seed * 0.523454) * 5773.7327);\n    return fract(sin(seed * 0.493732) * 3427.6872);\n}\n\nvec3 rand_hemisphere (vec3 n) {\n    float phi = (rand()-0.5) * 3.1416 * 4.;\n    float theta = (rand()-0.5) * 3.1416 * 4.;\n    \n    vec3 vec = vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));\n    return dot(vec, n) < 0. ? vec*-1. : vec;\n}\n\nfloat dist_mat (vec3 p, out MaterialInfo m) {\n\n    float dg = p.y+1.0;\n    float dsr = length(p-vec3(0,.1,0))-1.;\n    float ds1 = length(p-vec3(1., 0., 2.))-1.0;\n    float ds2 = length(p-vec3(3., 0., 0.))-1.;\n    float ds3 = length(p-vec3(-2., 0., 2.))-1.;\n    \n    float minD = min(dg, min(min(ds1, ds2), min(ds3, dsr)));\n    \n    m = zeroed_mat();\n    \n    if(minD == dg) {\n        m.albedo = vec3(1.);\n        m.surface = CHEK;\n    }\n    if(minD == ds1) {\n        m.albedo = vec3(0.9, 0.9, 0.5);\n        m.specPercent = 0.1;\n        m.specRough = 0.;\n        m.specular = vec3(.9);\n    }\n    if(minD == ds2) {\n        m.albedo = vec3(0.9, 0.2, 0.2);\n        m.specPercent = 0.5;\n        m.specRough = 0.4;\n        m.specular = vec3(0.2, 0.2, 0.9);\n    }\n    if(minD == ds3) {\n        m.albedo = vec3(0.9);\n        m.specPercent = 1.;\n        m.specRough = 0.7;\n        m.specular = vec3(0.5, 0.9, 0.5);\n    }\n    if(minD == dsr) {\n        m.albedo = vec3(1.);\n        m.refrPercent = 1.;\n        m.IOR = 1.5;\n    }\n    \n    return minD;\n}\n\nfloat dist (vec3 p) {\n    MaterialInfo m;\n    return dist_mat(p, m);\n}\n\nvec3 normal(vec3 p){\n  float d = dist(p);\n  vec2 e = vec2(.001, 0);\n  \n  vec3 n = d - vec3(\n    dist(p-e.xyy),\n    dist(p-e.yxy),\n    dist(p-e.yyx));\n  \n  return normalize(n);\n}\n\nHitInfo raymarch (vec3 ro, vec3 rd) {\n    \n    float dO = 0.0;\n    \n    bool hit = false;\n    \n    for (int i = 0; i < MAX_STEP; i++) {\n        vec3 p = ro + rd * dO;\n        \n        float d = abs(dist(p));\n        \n        if(d <= SURF_DIST) {\n            hit = true;\n            break;\n        }\n        if(dO >= MAX_DIST) {\n            hit = false;\n            break;\n        }\n        \n        dO += d;\n    }\n    \n    vec3 p = ro + rd * dO;\n    \n    MaterialInfo m;\n    dist_mat(p, m);\n    \n    bool inside = dist(p) < 0.0;\n    \n    return HitInfo (dO, p, normal(p), ro, rd, hit, inside, m);\n}\n\nvec3 color ( in vec3 ro, in vec3 rd ) {\n    \n    vec3 throughput = vec3(1.0);\n    vec3 final = vec3(0.0);\n    \n    for(int i = 0; i < BOUNCES; i++) {\n        \n        vec3 col = vec3(0.);\n        \n        HitInfo h = raymarch(ro, rd);\n        \n        if(h.hit == false) {\n            col = texture(iChannel1, h.pos).rgb*3.;\n            throughput  *=  col;\n            final += throughput;\n            break;\n        }\n        \n        float isSpec = rand() < h.mat.specPercent ? 1.0 : 0.0;\n        \n        vec3 diffrd = rand_hemisphere(h.n);\n        vec3 specrd = reflect(h.rd, h.n);\n        specrd = normalize(mix(specrd, diffrd, h.mat.specRough*h.mat.specRough));\n        \n        rd = mix(diffrd, specrd, isSpec);\n        ro = h.pos + h.n * SURF_DIST*2.0;\n        \n        // TEMP\n        if(h.mat.refrPercent == 1. ){\n            if (h.fromIn) {\n                rd = refract(h.rd, -h.n, h.mat.IOR);\n            }\n            else {\n                rd = refract(h.rd, h.n, 1./h.mat.IOR);\n            }\n        \n            if(!h.fromIn) {\n                ro = h.pos - h.n * SURF_DIST*2.0;\n            }\n        }\n        // TEMP\n        \n        if (h.mat.surface == COLR)\n            col = mix(h.mat.albedo, h.mat.specular, isSpec);\n        if (h.mat.surface == CHEK) {\n            col = mix(vec3(0.6),vec3(0.5),round(0.5+0.25*(sin(h.pos.x*3.)+sin(h.pos.z*3.))));\n        }\n        \n        final += throughput * h.mat.emissive;\n        throughput *= col;\n    }\n    \n    return final;\n}\n\nvec3 aces_filmic (vec3 x) {\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(ivec2(fragCoord) == ivec2(0)) {\n        fragColor = vec4(iResolution.xy, iMouse.xy);\n        return;\n    }\n    \n    vec2 res = iResolution.xy;\n    \n    init_rand(fragCoord + iTime * res.x);\n    \n    vec2 tv = ( ( ( fragCoord + vec2( rand(), rand() ) ) / res) -.5 ) / vec2(res.y / res.x, 1.0);\n    \n    vec3 ro = vec3(0., 0., -5.);\n    vec3 rd = normalize(vec3(tv, 1.));\n    \n    // Rotations\n    vec2 m = iMouse.xy / iResolution.xy - 0.5;\n    \n    rd.yz *= rot(-m.y);\n    rd.xz *= rot(-m.x);\n    ro.yz *= rot(-m.y);\n    ro.xz*= rot(-m.x);\n    \n    vec3 col = vec3(0.);\n    \n    for(int i = 0; i < SAMPLES; i++) {\n    \n        col += color(ro, rd);\n    \n    }\n    \n    col /= float(SAMPLES);\n    \n    //col = aces_filmic(col);\n    \n    if(texelFetch(iChannel0, ivec2(0), 0) == vec4(iResolution.xy, iMouse.xy)) {\n        fragColor = vec4(col, 1.0) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n    else {\n        fragColor = vec4(col, 1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}