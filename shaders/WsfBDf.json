{
    "Shader": {
        "info": {
            "date": "1589171663",
            "description": "Showing how blue noise can be used to make up for low step count ray marching through participating media.\nhttps://blog.demofox.org/2020/05/10/ray-marching-fog-with-blue-noise/\nDrag mouse to control camera.\nLL = no noise\nLR = white\nUL = blue\nUR = IGN",
            "flags": 0,
            "hasliked": 0,
            "id": "WsfBDf",
            "likes": 89,
            "name": "Blue Noise Fog",
            "published": 3,
            "tags": [
                "fog",
                "bluenoise",
                "stochastic"
            ],
            "usePreview": 0,
            "username": "demofox",
            "viewed": 6075
        },
        "renderpass": [
            {
                "code": "#define ANIMATE_NOISE 1\n\nconst float c_pi = 3.14159265359f;\nconst float c_goldenRatioConjugate = 0.61803398875f; // also just fract(goldenRatio)\n\nconst float c_FOV = 90.0f; // in degrees\nconst float c_cameraDistance = 80.0f;\nconst float c_minCameraAngle = 0.0f;\nconst float c_maxCameraAngle = c_pi;\nconst vec3 c_cameraAt = vec3(0.0f, 40.0f, 0.0f);\nconst float c_rayMaxDist = 10000.0f;\n\n#define c_lightDir normalize(vec3(0.0f, 0.0f, 0.2f))\nconst vec3 c_lightColor = vec3(1.0f, 0.8f, 0.5f);\nconst vec3 c_lightAmbient = vec3(0.05f, 0.05f, 0.05f);\n\nconst vec2 c_defaultMousePos = vec2(200.0f / 800.0f, 275.0f / 450.0f);\n\nconst float c_hitNormalNudge = 0.1f;\n\nconst int c_numRayMarchSteps = 16;\n\nconst float c_fogDensity = 0.002f;\nconst vec3 c_fogColorLit = vec3(1.0f, 1.0f, 1.0f);\nconst vec3 c_fogColorUnlit = vec3(0.0f, 0.0f, 0.0f);\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb * 1.055f, vec3(1.f / 2.4f)) - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\n// this noise, including the 5.58... scrolling constant are from Jorge Jimenez\nfloat InterleavedGradientNoise(vec2 pixel, int frame) \n{\n    pixel += (float(frame) * 5.588238f);\n    return fract(52.9829189f * fract(0.06711056f*float(pixel.x) + 0.00583715f*float(pixel.y)));  \n}\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid GetCameraVectors(out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraUp, out vec3 cameraRight)\n{   \n    vec2 mouse = iMouse.xy;\n    if (dot(mouse, vec2(1.0f, 1.0f)) == 0.0f)\n        mouse = c_defaultMousePos * iResolution.xy;    \n    \n    float angleX = -mouse.x * 16.0f / float(iResolution.x);\n    float angleY = mix(c_minCameraAngle, c_maxCameraAngle, mouse.y / float(iResolution.y));\n    \n    cameraPos.x = sin(angleX) * sin(angleY) * c_cameraDistance;\n    cameraPos.y = -cos(angleY) * c_cameraDistance;\n    cameraPos.z = cos(angleX) * sin(angleY) * c_cameraDistance;\n    \n    cameraPos += c_cameraAt;\n    \n    cameraFwd = normalize(c_cameraAt - cameraPos);\n    cameraRight = normalize(cross(cameraFwd, vec3(0.0f, 1.0f, 0.0f)));\n    cameraUp = normalize(cross(cameraRight, cameraFwd));   \n}\n\nstruct SRayHitInfo\n{\n    float dist;\n    vec3 normal;\n    vec3 diffuse;\n};\n    \nbool RayVsSphere(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere, in vec3 diffuse)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > 0.0f && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n\t\tinfo.diffuse = diffuse;        \n        return true;\n    }\n    \n    return false;\n}\n    \nbool RayVsPlane(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 plane, in vec3 diffuse)\n{\n    float dist = -1.0f;\n    float denom = dot(plane.xyz, rayDir);\n    if (abs(denom) > 0.001f)\n    {\n        dist = (plane.w - dot(plane.xyz, rayPos)) / denom;\n    \n        if (dist > 0.0f && dist < info.dist)\n        {\n            info.dist = dist;        \n            info.normal = plane.xyz;\n            info.diffuse = diffuse;\n            return true;\n        }\n    }\n    return false;\n}\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nbool RayVsQuad(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 diffuse, bool doubleSided)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (doubleSided && dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > 0.0f && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;\n\t\tinfo.diffuse = diffuse;        \n        return true;\n    }    \n    \n    return false;\n}\n\nSRayHitInfo RayVsScene(in vec3 rayPos, in vec3 rayDir)\n{\n    SRayHitInfo hitInfo;\n    hitInfo.dist = c_rayMaxDist;\n\n    // the floor\n    if(RayVsPlane(rayPos, rayDir, hitInfo, vec4(0.0f, 1.0f, 0.0f, 0.0f), vec3(0.2f, 0.2f, 0.2f)))\n    {\n        // uncomment this for a checkerboard floor\n        /*\n        vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n        vec2 uv = floor(hitPos.xz / 100.0f);\n        float shade = mix(0.6f, 0.2f, mod(uv.x + uv.y, 2.0f));\n        hitInfo.diffuse = vec3(shade, shade, shade);\n\t\t*/\n    }\n    \n    // some floating spheres to cast shadows\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(-60.0f, 40.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 1.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(-30.0f, 40.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 0.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(0.0f, 40.0f, 0.0f, 10.0f), vec3(0.0f, 1.0f, 0.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(30.0f, 40.0f, 0.0f, 10.0f), vec3(0.0f, 0.0f, 1.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(60.0f, 40.0f, 0.0f, 10.0f), vec3(1.0f, 1.0f, 0.0f));\n    \n    // back wall\n    {\n        vec3 scale = vec3(100.0f, 40.0f, 1.0f);\n        vec3 offset = vec3(0.0f, 0.0f, 10.0f);\n        vec3 A = vec3(-1.0f, 0.0f, 0.0f) * scale + offset;\n        vec3 B = vec3(-1.0f, 1.0f, 0.0f) * scale + offset;\n        vec3 C = vec3( 1.0f, 1.0f, 0.0f) * scale + offset;\n        vec3 D = vec3( 1.0f, 0.0f, 0.0f) * scale + offset;\n    \tRayVsQuad(rayPos, rayDir, hitInfo, A, B, C, D, vec3(1.0f, 0.0f, 1.0f), true);\n\t}     \n    \n    return hitInfo;\n}\n\n\nvec3 GetColorForRay(in vec3 rayPos, in vec3 rayDir, out float hitDistance)\n{\n    // trace primary ray\n\tSRayHitInfo hitInfo = RayVsScene(rayPos, rayDir);\n    \n    // set the hitDistance out parameter\n    hitDistance = hitInfo.dist;\n    \n    if (hitInfo.dist == c_rayMaxDist)\n        return texture(iChannel0, rayDir).rgb;\n    \n    // trace shadow ray\n    vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n    hitPos += hitInfo.normal * c_hitNormalNudge;\n    SRayHitInfo shadowHitInfo = RayVsScene(hitPos, c_lightDir);\n    float shadowTerm = (shadowHitInfo.dist == c_rayMaxDist) ? 1.0f : 0.0f;\n    \n    // do diffuse lighting\n    float dp = clamp(dot(hitInfo.normal, c_lightDir), 0.0f, 1.0f);\n\treturn c_lightAmbient * hitInfo.diffuse + dp * hitInfo.diffuse * c_lightColor * shadowTerm;\n}\n\n// ray march from the camera to the depth of what the ray hit to do some simple scattering\nvec3 ApplyFog(in vec3 rayPos, in vec3 rayDir, in vec3 pixelColor, in float rayHitTime, in int panel, in vec2 pixelPos)\n{         \n    // Offset the start of the ray between 0 and 1 ray marching steps.\n    // This turns banding into noise.\n    int frame = 0;\n    #if ANIMATE_NOISE\n    \tframe = iFrame % 64;\n    #endif\n    \n    float startRayOffset = 0.0f;\n    if (panel == 0)\n    {\n        startRayOffset = 0.5f;\n    }\n    else if (panel == 1)\n    {\n        // white noise\n        startRayOffset = hash13(vec3(pixelPos, float(frame)));\n    }\n    else if (panel == 2)\n    {\n        // blue noise\n        startRayOffset = texture(iChannel1, pixelPos / 1024.0f).r;\n        startRayOffset = fract(startRayOffset + float(frame) * c_goldenRatioConjugate);\n    }    \n    else if (panel == 3)\n    {\n        // interleaved gradient noise\n        startRayOffset = InterleavedGradientNoise(pixelPos, frame);\n    }\n    \n    // calculate how much of the ray is in direct light by taking a fixed number of steps down the ray\n    // and calculating the percent.\n    // Note: in a rasterizer, you'd replace the RayVsScene raytracing with a shadow map lookup!\n    float fogLitPercent = 0.0f;\n    for (int i = 0; i < c_numRayMarchSteps; ++i)\n    {\n        vec3 testPos = rayPos + rayDir * rayHitTime * ((float(i)+startRayOffset) / float(c_numRayMarchSteps));\n        SRayHitInfo shadowHitInfo = RayVsScene(testPos, c_lightDir);\n        fogLitPercent = mix(fogLitPercent, (shadowHitInfo.dist == c_rayMaxDist) ? 1.0f : 0.0f, 1.0f / float(i+1));\n    }\n    \n    vec3 fogColor = mix(c_fogColorUnlit, c_fogColorLit, fogLitPercent);\n    float absorb = exp(-rayHitTime * c_fogDensity);\n    return mix(fogColor, pixelColor, absorb);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get the camera vectors\n    vec3 cameraPos, cameraFwd, cameraUp, cameraRight;\n    GetCameraVectors(cameraPos, cameraFwd, cameraUp, cameraRight);    \n    \n    // calculate the ray direction for this pixel\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n    int panel = 0;\n    vec3 rayDir;\n    {   \n        panel = int(dot(floor(uv*2.0f), vec2(1.0f, 2.0f)));\n        \n\t\tvec2 screen = fract(uv*2.0f) * 2.0f - 1.0f;\n        screen.y /= aspectRatio;\n                \n        float cameraDistance = tan(c_FOV * 0.5f * c_pi / 180.0f);       \n        rayDir = vec3(screen, cameraDistance);\n        rayDir = normalize(mat3(cameraRight, cameraUp, cameraFwd) * rayDir);\n    }\n    \n    // do rendering for this pixel\n    float rayHitTime;\n    vec3 pixelColor = GetColorForRay(cameraPos, rayDir, rayHitTime);\n    \n    // apply fog\n    pixelColor = ApplyFog(cameraPos, rayDir, pixelColor, rayHitTime, panel, fragCoord);\n    \n    // tone map the color to bring it from unbound HDR levels to SDR levels\n    pixelColor = ACESFilm(pixelColor);\n    \n    // convert to sRGB, then output\n    pixelColor = LinearToSRGB(pixelColor);\n    fragColor = vec4(pixelColor, 1.0f);        \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}