{
    "Shader": {
        "info": {
            "date": "1558631749",
            "description": "Inspired by that synthwave meme.",
            "flags": 0,
            "hasliked": 0,
            "id": "ttBGRD",
            "likes": 19,
            "name": "Shaderwave",
            "published": 3,
            "tags": [
                "80s",
                "retro",
                "synthwave"
            ],
            "usePreview": 1,
            "username": "kosua20",
            "viewed": 2535
        },
        "renderpass": [
            {
                "code": "/* \n\tShaderWave - A recreation of a 80's nostalgia-fueled meme image.\n\tSimon Rodriguez, 2019.\n\tFeel free to reuse this code for any non-commercial purpose.\n*/\n\n/// Noise helpers.\n\n// 1-D noise.\nfloat noise(float p){\n\tfloat fl = floor(p);\n\tfloat fc = fract(p);\n\tfloat rand0 = fract(sin(fl) * 43758.5453123);\n\tfloat rand1 = fract(sin(fl+1.0) * 43758.5453123);\n\treturn mix(rand0, rand1, fc);\n}\n\n// 4 channels 1-D noise.\nvec4 noise(vec4 p){\n\tvec4 fl = floor(p);\n\tvec4 fc = fract(p);\n\tvec4 rand0 = fract(sin(fl) * 43758.5453123);\n\tvec4 rand1 = fract(sin(fl+1.0) * 43758.5453123);\n\treturn mix(rand0, rand1, fc);\n}\n\n// 2D to 1D hash, by Dave Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat hash(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * 0.2831);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n\n/// Background utilities.\n\n// Generate starfield.\nfloat stars(vec2 localUV, float starsDens, float starsDist){\n\t// Cenetr and scale UVs.\n\tvec2 p = (localUV-0.5) * starsDist;\n\t// Use thresholded high-frequency noise.\n\tfloat brigthness = smoothstep(1.0 - starsDens, 1.0, hash(floor(p)));\n\t// Apply soft transition between the stars and the background.\n\tconst float startsTh = 0.5;\n\treturn smoothstep(startsTh, 0.0, length(fract(p) - 0.5)) * brigthness;\n}\n\n// Distance from point to line segment.\nfloat segmentDistance(vec2 p, vec2 a, vec2 b){\n\t// Project the point on the segment.\n\tvec2 dir = b - a;\n\tfloat len2 = dot(dir, dir);\n\tfloat t = clamp(dot(p-a, dir)/len2,0.0,1.0);\n\tvec2 proj = a + t * dir;\n\t// Distance between the point and its projection.\n\treturn distance(p, proj);\n}\n\n// Distance from point to triangle edges.\nfloat triangleDistance(vec2 p, vec4 tri, float width){\n\t// Point at the bottom center, shared by all triangles.\n\tvec2 point0 = vec2(0.5, 0.37);\n\t// Distance to each segment.\n\tfloat minDist = \t   segmentDistance(p, point0, tri.xy) ;\n\tminDist = min(minDist, segmentDistance(p, tri.xy, tri.zw));\n\tminDist = min(minDist, segmentDistance(p, tri.zw, point0));\n\t// Smooth result for transition.\n\treturn 1.0-smoothstep(0.0, width, minDist);\n}\n\n/// Text utilities.\n\nfloat getLetter(int lid, vec2 uv){\n\t// If outside, return arbitrarily high distance.\n\tif(uv.x < 0.0 || uv.y < 0.0 || uv.x > 1.0 || uv.y > 1.0){\n\t\treturn 1000.0;\n\t}\n\t// The font texture is 16x16 glyphs.\n\tint vlid = lid/16;\n\tint hlid = lid - 16*vlid;\n\tvec2 fontUV = (vec2(hlid, vlid) + uv)/16.0;\n\t// Fetch in a 3x3 neighborhood to box blur\n\tfloat accum = 0.0;\n\tfor(int i = -1; i < 2; ++i){\n\t\tfor(int j = -1; j < 2; ++j){\n\t\t\tvec2 offset = vec2(i,j)/1024.0;\n\t\t\taccum += texture(iChannel0, fontUV+offset, 0.0).a;\n\t\t}\n\t}\n\treturn accum/9.0;\n}\n\nvec3 textGradient(float interior, float top, vec2 alphas){\n\t// Use squared blend for the interior gradients. \n\tvec2 alphas2 = alphas*alphas;\n\t// Generate the four possible gradients (interior/edge x upper/lower)\n\tvec3 bottomInterior = mix(vec3(0.987,0.746,0.993), vec3(0.033,0.011,0.057), alphas2.x);\n\tvec3 bottomExterior = mix(vec3(0.633,0.145,0.693), vec3(0.977,1.000,1.000),  alphas.x);\n\tvec3 topInterior \t= mix(vec3(0.024,0.811,0.924), vec3(0.600,0.960,1.080), alphas2.y);\n\tvec3 topExterior \t= mix(vec3(0.494,0.828,0.977), vec3(0.968,0.987,0.999),  alphas.y);\n\t// Blend based on current location.\n\tvec3 gradInterior \t= mix(bottomInterior, topInterior, top);\n\tvec3 gradExterior \t= mix(bottomExterior, topExterior, top);\n\treturn mix(gradExterior, gradInterior, interior);\n}\n\n\n/// Main render.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates.\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvCenter = 2.0 * uv - 1.0; \n\n\t/// Background.\n\t// Color gradient.\n\tvec3 finalColor = 1.5*mix(vec3(0.308,0.066,0.327), vec3(0.131,0.204,0.458), uv.x);\n\t\n\tconst float gridHeight = 0.3;\n\tif(uv.y < gridHeight){\n\n\t\t/// Bottom grid.\n\t\t// Compute local cflipped oordinates for the grid.\n\t\tvec2 localUV = uv*vec2(2.0, -1.0/gridHeight) + vec2(-1.0, 1.0);\n\t\t// Perspective division, scaling, foreshortening and alignment.\n        localUV.x = localUV.x/(localUV.y+0.8);\n\t\tlocalUV *= vec2(10.0, 20.0);\n\t\tlocalUV.y = sqrt(localUV.y);\n\t\tlocalUV.x += 0.5;\n\t\t// Generate grid smooth lines (translate along time).\n\t\tvec2 unitUV = fract(localUV-vec2(0.0, 0.3*iTime));\n\t\tvec2 gridAxes = smoothstep(0.02, 0.07, unitUV) * (1.0 - smoothstep(0.93, 0.98, unitUV));\n\t\tfloat gridAlpha = 1.0-clamp(gridAxes.x*gridAxes.y, 0.0, 1.0);\n\n\t\t/// Fixed star halos.\n\t\t// Loop UVs.\n\t\tvec2 cyclicUV = mod(localUV-vec2(0.0, 0.3*iTime), vec2(9.0, 5.0));\n\t\t// Distance to some fixed grid vertices.\n\t\tconst float haloTh = 0.6;\n\t\tfloat isBright1 = 1.0-min(distance(cyclicUV, vec2(6.0,3.0)), haloTh)/haloTh;\n\t\tfloat isBright2 = 1.0-min(distance(cyclicUV, vec2(1.0,2.0)), haloTh)/haloTh;\n\t\tfloat isBright3 = 1.0-min(distance(cyclicUV, vec2(3.0,4.0)), haloTh)/haloTh;\n\t\tfloat isBright4 = 1.0-min(distance(cyclicUV, vec2(2.0,1.0)), haloTh)/haloTh;\n\t\t// Halos brightness.\n\t\tfloat spotLight = isBright1+isBright2+isBright3+isBright4;\n\t\tspotLight *= spotLight;\n\t\t// Composite grid lines and halos.\n\t\tfinalColor += 0.15*gridAlpha*(1.0+5.0*spotLight);\n\t\t\n\t} else {\n\t\t/// Starfield.\n\t\t// Compensate aspect ratio for circular stars.\n\t\tvec2 ratioUVs = uv*vec2(1.0, iResolution.y / iResolution.x);\n\t\t// Decrease density towards the bottom of the screen.\n\t\tfloat baseDens = clamp(uv.y-0.3, 0.0, 1.0);\n\t\t// Three layers of stars with varying density, cyclic animation.\n        float deltaDens = 20.0*(sin(0.05*iTime-1.5)+1.0);\n\t\tfinalColor += 0.50*stars(ratioUVs, 0.10*baseDens, 150.0-deltaDens);\n\t\tfinalColor += 0.75*stars(ratioUVs, 0.05*baseDens,  80.0-deltaDens);\n\t\tfinalColor += 1.00*stars(ratioUVs, 0.01*baseDens,  30.0-deltaDens);\n\t}\n\t\n\t/// Triangles.\n\t// Triangles upper points.\n\tvec4 points1 = vec4(0.30,0.85,0.70,0.85);\n\tvec4 points2 = vec4(0.33,0.83,0.73,0.88);\n\tvec4 points3 = vec4(0.35,0.80,0.66,0.82);\n\tvec4 points4 = vec4(0.38,0.91,0.66,0.87);\n\tvec4 points5 = vec4(0.31,0.89,0.72,0.83);\n\t// Randomly perturb based on time.\n\tpoints2 += 0.04*noise(10.0*points2+0.4*iTime);\n\tpoints3 += 0.04*noise(10.0*points3+0.4*iTime);\n\tpoints4 += 0.04*noise(10.0*points4+0.4*iTime);\n\tpoints5 += 0.04*noise(10.0*points5+0.4*iTime);\n\t// Intensity of the triangle edges.\n\tfloat tri1 = triangleDistance(uv, points1, 0.010);\n\tfloat tri2 = triangleDistance(uv, points2, 0.005);\n\tfloat tri3 = triangleDistance(uv, points3, 0.030);\n\tfloat tri4 = triangleDistance(uv, points4, 0.005);\n\tfloat tri5 = triangleDistance(uv, points5, 0.003);\t\n\tfloat intensityTri = 0.9*tri1+0.5*tri2+0.2*tri3+0.6*tri4+0.5*tri5;\n\t// Triangles color gradient, from left to right.\n\tfloat alphaTriangles = clamp((uv.x-0.3)/0.4, 0.0, 1.0);\n\tvec3 baseTriColor = mix(vec3(0.957,0.440,0.883), vec3(0.473,0.548,0.919), alphaTriangles);\n\t// Additive blending.\n\tfinalColor += intensityTri*baseTriColor;\n\n\t/// Horizon gradient.\n\tconst float horizonHeight = 0.025;\n\tfloat horizonIntensity = 1.0-min(abs(uv.y - gridHeight), horizonHeight)/horizonHeight;\n\t// Modulate base on distance to screen edges.\n\thorizonIntensity *= (1.0 - 0.7*abs(uvCenter.x)+0.5);\n\tfinalColor += 2.0*horizonIntensity*baseTriColor;\n\t\n\t/// Letters.\n\t// Centered UVs for text box.\n\tvec2 textUV = uvCenter*2.2-vec2(0.0, 0.5);\n\tif(abs(textUV.x) < 1.0 && abs(textUV.y) < 1.0){\n\t\t// Rescale UVs.\n\t\ttextUV = textUV*0.5+0.5;\n\t\ttextUV.x *= 3.5;\n\t\t// Per-sign UV, manual shifts for kerning.\n\t\tconst vec2 letterScaling = vec2(0.47,0.93);\n\t\tvec2 uvLetter1 = (textUV - vec2(0.60,0.50)) * letterScaling + 0.5;\n\t\tvec2 uvLetter2 = (textUV - vec2(1.50,0.50)) * letterScaling + 0.5;\n\t\tvec2 uvLetter3 = (textUV - vec2(2.15,0.54)) * letterScaling * 1.2 + 0.5;\n\t\tvec2 uvLetter4 = (textUV - vec2(2.70,0.50)) * letterScaling + 0.5;\n\t\t// Get letters distance to edge, merge.\n\t\tfloat let1 = getLetter(200, uvLetter1);\n\t\tfloat let2 = getLetter(192, uvLetter2);\n\t\tfloat let3 = getLetter(215, uvLetter3);\n\t\tfloat let4 = getLetter(131, uvLetter4);\n\t\t// Merge and threshold.\n\t\tfloat finalDist = 0.52 - min(let1, min(let2, min(let3, let4)));\n\t\t// Split between top and bottom gradients (landscape in the reflection).\n\t\tfloat localTh = 0.49+0.03*noise(70.0*uv.x+iTime);\n\t\tfloat isTop = smoothstep(localTh-0.01, localTh+0.01, textUV.y);\n\t\t// Split between interior and edge gradients.\n\t\tfloat isInt = smoothstep(0.018, 0.022, finalDist); \n\t\t// Compute relative heights along the color gradients (both bottom and up (shifted)), rescale.\n\t\tvec2 localUBYs = vec2(1.8*(textUV.y-0.5)+0.5);\n\t\tlocalUBYs.y -= isTop*0.5;\n\t\tvec2 gradientBlend = localUBYs / localTh;\n\t\t// Evaluate final mixed color gradient.\n\t\tvec3 textColor = textGradient(isInt, isTop, gradientBlend);\n\t\t// Add sharp reflection along a flat diagonal.\n\t\tif(textUV.x-20.0*textUV.y < -14.0 || textUV.x-20.0*textUV.y > -2.5){\n\t\t\ttextColor += 0.1;\n\t\t}\n\t\t// Soft letter edges.\n\t\tfloat finalDistSmooth = smoothstep(-0.0025, 0.0025,finalDist);\n\t\tfinalColor = mix(finalColor, textColor, finalDistSmooth);\n\t}\n\t\n\t/// Vignetting.\n\tconst float radiusMin = 0.8;\n\tconst float radiusMax = 1.8;\n\tfloat vignetteIntensity = (length(uvCenter)-radiusMin)/(radiusMax-radiusMin);\n\tfinalColor *= clamp(1.0-vignetteIntensity, 0.0, 1.0);\n\n\t/// Exposure tweak, output.\n\tfragColor = vec4(pow(finalColor, vec3(1.2)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}