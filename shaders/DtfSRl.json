{
    "Shader": {
        "info": {
            "date": "1675174053",
            "description": "A raytracer.",
            "flags": 32,
            "hasliked": 0,
            "id": "DtfSRl",
            "likes": 4,
            "name": "Raytracer  (Release)",
            "published": 3,
            "tags": [
                "raytracing",
                "raytracer",
                "pathtracing",
                "pathtracer"
            ],
            "usePreview": 0,
            "username": "raymarchingenthusiast",
            "viewed": 193
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 c,in vec2 i){\n    c = texelFetch(iChannel0,ivec2(i),0);\n    c /= c.w;\n    irand(float(iFrame),i);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define sat(a) clamp(a,0.,1.)\nstruct Material {\n    float roughness;\n    float shininess;\n    float glossiness;\n    vec3 color;\n};\n\nstruct PLight {\n    float intensity;\n    vec3 color;\n    vec3 pos;\n};\n\n#define A vec3(29.,11.,17.)\nfloat seed;\nfloat rand(void){\n  seed = mod(seed*A.x+A.y,A.z)/A.z;\n  return seed;\n}\nvec2 rand2(void){return\nvec2(rand(),rand());}\nfloat srand(float s) {\n  return mod(s*A.x+A.y,A.z)/A.z;\n}\nvoid irand(float t, vec2 p) {\n  seed = abs(-t*p.y*sin(p.y)+t*p.x*cos(p.x));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define R iResolution.xy\n#define F float(iFrame)\n#define Inf 9999.\n#define IG 2.2\n#define G 1./IG\n\nvec3 cosDir(in vec3 nor){\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    float u = rand();\n    float a = 6.283185 * rand();\n\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n//Above and below are from Ingo Quilezles\nvec3 uniformVector()\n{\n    float a = 3.141593*rand();\n    float b = 6.283185*rand();\n    return vec3( sin(b)*sin(a), cos(b)*sin(a), cos(a) );\n}\n\nvec3 getSky(vec3 rd,float t) {\n    return vec3(.7,.9,1.);\n}\n\nfloat planeInt( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\nvec2 sphInt( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\nvec2 boxInt( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\nvec2 worldInt(in vec3 ro, in vec3 rd,int lId,float t) {\n    float d0 = sphInt(ro,rd,vec3(0.,0.,3.),1.).x;\n    if(d0 < 0.) d0 = Inf;\n    float d1 = planeInt(ro,rd,vec4(0.,1.,0.,1.));\n    if(d1 < 0.) d1 = Inf;\n    float d2 = sphInt(ro,rd,vec3(-2.5,0.,2.5),1.).x;\n    if(d2 < 0.) d2 = Inf;\n    float d3 = sphInt(ro,rd,vec3(2.5,0.,3.5),1.).x;\n    if(d3 < 0.) d3 = Inf;\n    \n    float d = min(min(min(d3,d2),d0),d1);\n    if(d==Inf) return vec2(-1.,0.);\n    \n    float m;\n    if(d==d0) m = 1.;\n    if(d==d2) m = 1.;\n    if(d==d3) m = 1.;\n    if(d==d1) m = 2.;\n    \n    return vec2(d,m);\n}\n\nPLight genLight(float i,vec3 c,vec3 p,float r){\n    vec3 o = r*normalize(-1.+2.*vec3(rand2(),rand()));\n    return PLight(i,c,p+o);\n}\n\nvec3 getCam(float t,out vec3 uu,out vec3 vv,out vec3 ww) {\n    uu = vec3(1.,0.,0.);\n    vv = vec3(0.,1.,0.);\n    ww = vec3(0.,0.,1.);\n    //Keep above\n    \n    //Write below\n    \n    \n    \n    //Keep below\n    uu = normalize(uu);\n    vv = normalize(vv);\n    ww = normalize(ww);\n    return vec3(0.,1.,0.);\n}\n\nvec3 getObjectNorm(vec3 p, float id,float t) {\n    if(id==1.) return normalize(vec3(0.,0.,3.)-p);\n    if(id==2.) return normalize(vec3(0.,-1.,0.));\n    return vec3(0.,1.,0.);\n}\n\nMaterial getObjectData(vec3 pos,float id,float t) {\n    if(id==1.) return Material(.85,35.,.05,vec3(.2,.2,.2));\n    if(id==2.) return Material(.1,15.,.05,vec3(.2,.2,.2));\n}\n//Glossiness (3rd comp) and Roughness (1st comp) should NEVER be 0.\nvoid getRay(out vec3 ro,inout vec3 rd,float r,float s,vec3 p,vec3 n){\n    ro = p;\n    if(rand()<r){\n        rd = cosDir(n);\n    }else{\n        rd = normalize(reflect(rd,n)+uniformVector()*s);\n    }\n}\n\nbool inLight(vec3 ro,vec4 ld,int lID,float t){\n    vec2 tres = worldInt(ro,-ld.xyz,lID,t);\n    return tres.x>=ld.w||tres.y<1.;\n    return true;\n}\n\n//Lower this if rt is false?\n#define spp 1.\n#define rt false\n//Set to true if the camera or \n//objects can move\n\nvec3 getPixCol(vec2 I) {\n    float frame = F*spp;\n    float ftime = rt?iTime:0.;\n    vec3 ttcol = vec3(0.);\n    for(float i=0.;i<spp;i++) {\n    irand(frame,I);\n    vec2 p = (-R + 2.*(I+rand2()))/R.y;\n    \n    //.6 is shutter aperture\n    float ctime = ftime + (.6/24.)*rand();\n    \n    vec3 uu;vec3 vv;vec3 ww;\n    vec3 ro = getCam(ctime,uu,vv,ww);\n    \n    vec3 er = normalize(vec3( p.xy, 1. ));\n    vec3 rd = er.x*uu+er.y*vv+er.z*ww;\n    \n    //.0015 is blur amount\n    vec3 go = .0015*vec3( -1. + 2.*rand2(), 0.);\n    //1.3 is focus distance\n    vec3 gd = normalize( er*1.3 - go );\n    \n    ro += go.x*uu+go.y*vv;\n    rd += gd.x*uu+gd.y*vv;\n    rd = normalize(rd);\n    \n    vec3 tcol = vec3(0.);\n    vec3 fcol = vec3(1.);\n    //3 is number of levels\n    for(int i = 0; i < 10; i++){\n        vec2 tres = worldInt(ro,rd,-1,ctime);\n    \n        if(tres.y<=0.) {tcol+=fcol*getSky(rd,ctime);break;}\n    \n        vec3 pos = ro + rd * tres.x;\n     \n        vec3 nor     = getObjectNorm(pos,tres.y,ctime);\n        vec3 ofp     = pos - nor*.001;\n        Material dat = getObjectData(pos,tres.y,ctime);\n        dat.shininess = 2./(dat.glossiness*(1.-dat.roughness));\n        \n        vec3 color = vec3(0.);\n        {\n            PLight l = genLight(1100.,vec3(1.,0.,0.),vec3(-10.,15.,.0),1.1);\n            vec4 ld = vec4(normalize(pos-l.pos),length(pos-l.pos));\n            if(inLight(ofp,ld,0,ctime)){\n                float i = l.intensity/(ld.w*ld.w);\n                color += dat.color*dat.roughness*l.color*i*fcol*max(dot(nor,ld.xyz),0.);\n                vec3 h = normalize(ld.xyz+rd);\n                color += (1.-dat.roughness)*fcol*i*l.color*pow(max(0.,dot(h,nor)),dat.shininess);\n            }\n        }\n        {\n            PLight l = genLight(1100.,vec3(0.,1.,0.),vec3(0.,15.,.5),1.1);\n            vec4 ld = vec4(normalize(pos-l.pos),length(pos-l.pos));\n            if(inLight(ofp,ld,1,ctime)){\n                float i = l.intensity/(ld.w*ld.w);\n                color += dat.color*dat.roughness*l.color*i*fcol*max(dot(nor,ld.xyz),0.);\n                vec3 h = normalize(ld.xyz+rd);\n                color += (1.-dat.roughness)*fcol*i*l.color*pow(max(0.,dot(h,nor)),dat.shininess);\n            }\n        }\n        {\n            PLight l = genLight(1100.,vec3(0.,0.,1.),vec3(10.,15.,1.),1.1);\n            vec4 ld = vec4(normalize(pos-l.pos),length(pos-l.pos));\n            if(inLight(ofp,ld,2,ctime)){\n                float i = l.intensity/(ld.w*ld.w);\n                color += dat.color*dat.roughness*l.color*i*fcol*max(dot(nor,ld.xyz),0.);\n                vec3 h = normalize(ld.xyz+rd);\n                color += (1.-dat.roughness)*fcol*i*l.color*pow(max(0.,dot(h,nor)),dat.shininess);\n            }\n        }\n        fcol *= dat.color;\n        tcol += color;\n        getRay(ro,rd,1./dat.shininess,dat.glossiness,pos,nor);\n    }\n    ttcol += tcol;\n    frame++;\n    }\n    return ttcol/spp;\n}\n\nvoid mainImage( out vec4 O, in vec2 I ){\n    O = vec4(sat(getPixCol(I)),1.);\n    O.xyz = pow(O.xyz,vec3(G));\n    if(iFrame>0&&!rt) O += texelFetch(iChannel0,ivec2(I),0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}