{
    "Shader": {
        "info": {
            "date": "1647441371",
            "description": "An extruded irregular pinwheel tile pattern consisting of hexagons and triangle wedges.",
            "flags": 32,
            "hasliked": 0,
            "id": "sd2BRV",
            "likes": 38,
            "name": "3D Hexagon Triangle Pinwheel",
            "published": 3,
            "tags": [
                "triangle",
                "hexagon",
                "tile",
                "pinwheel",
                "extrude",
                "irregular"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 664
        },
        "renderpass": [
            {
                "code": "/*\n\n    3D Hexagon Triangle Pinwheel\n    ----------------------------\n\n    See Buffer A.\n    \n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Rendering the buffer. \n     \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy);\n\n    // Gamma correction and screen presentation.\n    // \"col\" should already be above zero.\n    fragColor = pow(col, vec4(1./2.2));\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n    3D Hexagon Triangle Pinwheel\n    ----------------------------\n\n\tYou'll see a lot of path traced extruded stock imagery around. Depending\n    on your taste, you'll either like it, or you'll be one of those people who \n    are happy to leave it to the abstract computer art crowd. :) For whatever\n    reason, I've always liked geometrical wallpapers, so it's right up my alley.\n    I even like the incredibly cliche square grid pylons that everyone makes.\n    \n    Sometimes, I'll see an interesting pattern, then wonder what it'd look like\n    in extruded form, so that's what is happening here. These things are better\n    path traced as a static image, but on Shadertoy there's a certain amount of \n    pressure to render it in realtime. I've done my best, but it can be \n    difficult rendering something on the cheap whilst also maintaining quality.\n    \n    Things like this need antialiasing, but it's hard enough rendering one pass\n    at full frame rate, let along several. Therefore, I've done the next best\n    thing and accumulated a few frames to the buffer for a bit of temporal \n    depixelization. With just three frames, ghosting isn't too bad, provided \n    things are running at full frame rate, which should be the case on mid-range\n    to good systems. Things could be improved with camera reprojection, but I\n    left that out to simplify the code.\n    \n    In regard to the pattern algorithm itself, I've taken a brute force approach\n    to keep the logic simple, but it could be improved. I could also do a heap\n    of precalculation on an offscreen buffer, which I might do at a later date.\n    Therefore, apologies in advance for those with slower machines that are\n    experiencing ghosting; I'll attempt to speed things up in due course. In\n    the meantime, just comment out the TEMPORAL_AA define.\n    \n\n\tBased on:\n    \n\t// Much easier to understand, and would render much faster too.\n    Hexagon Triangle Wedge Pattern - Shane\n\thttps://www.shadertoy.com/view/ss2BDc\n\n\n*/\n\n\n\n// Max ray distance.\n#define FAR 20.\n\n\n// A pinwheel arrangement with wedge looking triangles. Commenting this \n// out will result in a regular hexagon triangle pinwheel arrangement.\n#define WEDGE\n\n// Very rough temporal anitaliasing. If you have a slow machine and are\n// experiencing too much ghosting, turn this off. By the way, I've disabled\n// this for resolutions over a certain amount, since I'm getting fullscreen\n// ghosting.\n#define TEMPORAL_AA\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\n//float hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(sampler2D iCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iCh, p/iChannelResolution[0].xy*2.).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){\n\n    //return hash21(p/4.)/2.;\n\n    vec3 tx = texture(iChannel1, p/iChannelResolution[0].xy*4.).xyz; tx *= tx;\n    return dot(tx, vec3(.299, .587, .114)); \n}\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) + sdf*.5;\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .01;\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    */\n}\n\n/* \n// This is a bound. Technically, it's not a proper distance field, but for\n// this example, no one will notice. :)\nfloat sHexS(in vec2 p, in vec2 b){\n    \n    p = abs(p);\n    return max(p.x*.8660254 + p.y*.5 - b.x, p.y - b.y);\n    //return max(p.y*.8660254 + p.x*.5, p.x) - b.x;;\n}\n*/\n\n// Signed distance to a regular hexagon, with a hacky smoothing variable thrown\n// in. -- It's based off of IQ's more exact pentagon method, which is here:\nfloat sHexS(in vec2 p, float r, in float sf){\n    \n  const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n\n  // X and Y reflection.  \n  p = abs(p); \n  p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n   \n \n  r -= sf;\n  // Polygon side.\n  return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r) - sf;\n    \n}\n\nfloat tri(vec2 p){\n\n    return max(abs(p.x)*.8660254 + p.y*.5, -p.y);\n}\n\n/////////////////////////\n// Scaling.\n#ifdef WEDGE \nconst float sc = 1./2.5;\n#else\nconst float sc = 1./3.75;\n#endif\n\n// Flat top hexagon scaling.\nconst vec2 s = vec2(1.7320508, 1)*sc;\n\n// Hexagon edge and vertex IDs. They're useful for neighboring edge comparisons,\n// etc. Multiplying them by \"s\" gives the actual vertex postion.\n//\n// Vertices and edges: Clockwise from the left.\n//\n// Note that these are all six times larger than usual. We're doing this to \n// get rid of decimal places, especially those that involve division by three.\n// I't a common accuracy hack. Unfortunately, \"1. - 1./3.\" is not always the \n// same as \"2./3.\" on a GPU.\n\n// Multiplied by 12 to give integer entries only.  \nconst vec2[6] vID = vec2[6](vec2(-4, 0), vec2(-2, 6), vec2(2, 6), \n                      vec2(4, 0), vec2(2, -6), vec2(-2, -6)); \n\nconst vec2[6] eID = vec2[6](vec2(-3, 3), vec2(0, 6), vec2(3), \n                      vec2(3, -3), vec2(0, -6), vec2(-3));\n                    \n\n/*\nconst vec2[6] vID = vec2[6](vec2(-1./3., 0), vec2(-1./6., .5), vec2(1./6., .5), \n                      vec2(1./3., 0), vec2(1./6., -.5), vec2(-1./6., -.5)); \n\nconst vec2[6] eID = vec2[6](vec2(-.25, .25), vec2(0, .5), vec2(.25), \n                      vec2(.25, -.25), vec2(0, -.5), vec2(-.25));\n*/                       \n\n// Hexagonal grid coordinates. This returns the local coordinates and the cell's center.\n// The process is explained in more detail here:\n//\n// Minimal Hexagon Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n//\nvec4 getGrid(vec2 p){\n   \n    vec4 ip = floor(vec4(p/s, p/s - .5)) + .5;\n    vec4 q = p.xyxy - vec4(ip.xy, ip.zw + .5)*s.xyxy;\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n   \n}                      \n//////////////////////////\n\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID = vec4(1e5);\n\n// The extruded blocks. This was written in a rush, so with more thought\n// put into it, you could make it faster. The code could also be neater.\n// However, if you're interested in how the 2D field value comes together,\n// you can reference my 2D example, here: https://www.shadertoy.com/view/ss2BDc\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z + 1.;\n \n    // Hexagonal grid coordinates.\n    vec4 p4 = getGrid(p.xy);\n\n    // Edge width. Set to zero for this example.\n    const float ew = 0.;//.015*sc;\n    \n    // Height factor.\n    const float hFact = .15;//.15;\n    \n    // Object scaling dimension.\n    #ifdef WEDGE \n    float sz = sc/6. - ew;\n    vec2 ip = p4.zw*18.; // Central object ID.\n    #else\n    float sz = sc/4. - ew;\n    vec2 ip = p4.zw*12.; // Central object ID.\n    #endif\n    \n    // Central hexagon 2D field value.\n    float di2D = sHexS(p4.xy, sz - sz*.02, sz*.02);\n    // Block height.\n    float h = hm(ip)*hFact;\n    gID.w = di2D; // Saved 2D field value.\n\n    // The extruded distance function value.\n    float di = opExtrusion(di2D, (p.z + h - 1.), h + 1.);\n    //di = max(di, -opExtrusion(di2D + sc*.1, (p.z + h + .02), h));\n    \n    // Overall object distance, set to the central block.\n    float d = di;\n    \n    // Hexagon arrangement ID -- The rest range from zero to five.\n    float id = 6.;\n    \n    // Iterate through all six sides of the hexagon cell.\n    for(int i = min(0, iFrame); i<6; i++){\n     \n            #ifdef WEDGE \n             // Triangle central offset index.\n            vec2 indx1 = vID[i];\n            mat2 qR = rot2(6.2831/6.*float(i)); // Local rotation.\n            vec2 q = qR*(p4.xy - indx1*s/18.); // Local rotated coordinates.\n            di2D = tri(q) - sz; // Inner triangle distance.\n            \n            // Neighbor triangle central offset index.\n            vec2 indx2 = (eID[i]*3. + vID[(i+4)%6]);\n            q = qR*(p4.xy - indx2*s/18.); // Local rotated coordinates.\n            float di2D2 = tri(q) - sz; // Outer triangle distance.\n            \n            // Overal index for the inner object.\n            vec2 ipt = p4.zw*18. + indx1;\n            h = hm(ipt)*hFact; // Block height.\n            di2D = max(di2D, -(di2D2 - ew*2.));\n            di = opExtrusion(di2D, (p.z + h - 1.), h + 1.); // Extruded inner block distance.\n            // Extra detail.\n            //di = max(di, -opExtrusion(di2D + sc*.05, (p.z + h + .02), h));\n            \n            // Set the minimum distance and IDs for the inner object.\n            if(di<d) {\n                d = di;\n                id = float(i);\n                ip = ipt;\n                gID.w = di2D;\n            }\n            \n            // Overal index for the outer object.\n            ipt = p4.zw*18. + indx2; // Offset indices.\n            h = hm(ipt)*hFact; // Block height.\n            di = opExtrusion(di2D2, (p.z + h - 1.), h + 1.); // Extruded outer block distance.\n            // Extra detail.\n            //di = max(di, -opExtrusion(di2D2 + sc*.05, (p.z + h + .02), h));\n            \n            // Set the minimum distance and IDs for the outer object.\n            if(di<d) {\n                d = di;\n                id = mod(float(i + 4), 6.);\n                ip = ipt;\n                gID.w = di2D2;\n            }\n            \n            #else\n            \n            vec2 indx1 = vID[i]; // Offset indices.\n            vec2 q = p4.xy - indx1*s/12.; // Local coordinates.\n            q *= rot2(-6.2831/6.*float(i)); // Rotation.\n            di2D = tri(q) - sz; //1./.8660254+1.; // Triangle distance.\n            \n            vec2 ipt = p4.zw*12. + indx1;  // Offset indices.\n            h = hm(ipt)*hFact; // Block height.\n            di = opExtrusion(di2D, (p.z + h - 1.), h + 1.); // Extruded block distance.          \n            //di = min(di, opExtrusion(di2D + sc*.1, (p.z + h + .01), h));\n            \n            // Set the minimum distance and IDs.\n            if(di<d) {\n                d = di;\n                id = float(i);\n                ip = ipt;\n                gID.w = di2D;\n            }\n            \n            #endif\n            \n            \n    }\n    \n    // Save the ID for the nearest block.\n    gID.yz = ip; \n    gID.x = id; // Arrangement ID. Not really important, but useful for pattern colors.\n \n    \n \n    // Overall object ID.\n    objID = fl<d? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<96; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<40? d*.5 : d*.8; \n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t){\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function. \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n \n    // Initial values.\n    float shade = 1.;\n    float t = 1e-6;  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .1); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.1/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .85;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n// Block face pattern field. Just some animated\n// rising bubbles.\nvec3 df(vec2 p){\n   \n    // Upward movement, rotation and scaling.\n    p -= iTime/128.;\n    p *= rot2(3.14159/12.);\n    float sc = 1./9.;\n    p /= sc;\n    \n    // Row offset and grid partitioning.\n    if(mod(floor(p.y/s.y), 2.)>.5) p.x += s.x/2.;\n    vec2 ip = floor(p/s);\n    p -= (ip + .5)*s;\n    \n    // Rendering an offset circle in each cell.\n    vec2 offs = vec2(hash21(ip + .16), hash21(ip + .2)) - .5;\n    offs = sin(offs*6.2831+ iTime)*.5;\n    float d = length(p - offs*.15) - .16;\n    \n    // Distand and cell ID.\n    return vec3(d*sc, ip);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n   \n    #ifdef TEMPORAL_AA\n    if(iResolution.y<650.){\n        vec2 jit = vec2(hash21(uv + .5 + fract(iTime*.07)), hash21(uv + .35 + fract(iTime*.17)));\n        uv += (jit - .5)/iResolution.y;\n    }\n   \t#endif\n    \n\t// Camera Setup.\n\tvec3 ro = vec3(iTime/16., 0, -2); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(-.08, .05, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(-.75, 1.25, 1.25);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .5; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2(sin(iTime)/16.);\n\t//rd.xy *= rot2(3.14159/6.);\n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    vec4 svGID = gID;\n    \n    // Saving the scene object.\n    float svObjID = objID;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;\n        vec3 tx4 = vec3(0);\n\n        // The extruded grid.\n        if(svObjID<.5){\n        \n             // Height.\n            float h = hm(svGID.yz);\n            // Smoothing factor for 2D face decoration.\n            float sf = .001; //1./iResolution.y;  \n            \n            // Coloring the individual blocks with the saved ID.\n            //vec3 tx = getTex(iChannel1, svGID.yz);\n            //tx = smoothstep(-.05, .5, tx);\n            //tx = mix(tx, tx.xzy, -rd.y*1.5 + .5);\n            \n            // Using the ID to produce a 2D sinusoidal pattern.\n            vec2 id = rot2(3.14159/6.)*svGID.yz/8.; // Position based ID.\n            float rnd = hash21(svGID.yz); // Random ID.\n            // Sinusoidal pattern.\n            float fn = dot(sin(id - cos(id*2.)*1.5), vec2(.25)) + .5;\n            // Sprinkling in some random noise.\n            fn = mix(fn, rnd, .2);\n            // Using IQ's palette formular to produce a limited range golden palette.\n            vec3 tx = .5 + .5*cos(6.2831*fn/10. + vec3(0, 1, 2)*.8 + 1.25);\n            // Other palette variations.\n            //vec3 tx = vec3((1.-step(.5, svGID.x - 5.))*.7 + .05);\n            //vec3 tx = .5 + .45*cos(6.2831*svGID.x/7. + vec3(0, 1, 2));\n            //vec3 tx = .5 + .45*cos(6.2831*rnd + vec3(0, 1, 2)*1.5);\n            //if(svGID.x<5.5 && mod(svGID.x + mod(svGID.y+svGID.z, 2.), 2.)<.5) tx = tx.xxx;\n            \n            // Pearl centers.\n            //if(svGID.x>5.5) tx = tx.xxx;\n            \n            // Top to bottom gradient coloring.\n            tx = mix(tx, tx.xzy, clamp((-sp.y + .25) + .5, 0., 1.)*.9);\n            \n            // Using the cell object normal to produce some UV coordinates for texturing.\n            // Normals pointing up, versus side normals.\n            vec2 uv = abs(sn.z)>.5? sp.xy : vec2(dot(normalize(sn.yx), sp.xy), sp.z);\n            // Loading in the trusty metallic texture... That, along with the timber texture,\n            // are the only two fine grained textures on here. If Shadertoy had a wider choice\n            // of textures, we could make some pretty awesome things. From a logistics standpoint,\n            // I'm not seeing the problem with supplying more textures, but there could be \n            // something I'm overlooking, like extra server costs, etc.\n            vec3 tx2 = texture(iChannel0, uv).xyz; tx2 *= tx2;\n            tx2 = .1 + tx2*2.5;//.25 + tx2*2.25;//vec3(.7);//\n            \n\n            // Overall color.\n            texCol = tx*tx2*.75;\n            \n            /*\n            // Line overlays. Interesting, but a bit much.\n            const float lNum = 100.;\n            vec2 rUV = rot2(-3.14159/3.)*uv;\n            float pat = (abs(fract(rUV.x*lNum) - .5)*2. - .5)/lNum/2.;\n            pat = smoothstep(0., .001, pat)*.5 + .65;\n            tx *= pat;\n            */ \n            \n            // Face and sides.\n            float hd = sp.z + h*.15*2.; // Rim height.\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, hd - .005)));\n            texCol = mix(texCol, tx2*.9, (1. - smoothstep(0., sf, svGID.w + .005)));\n\n            // Overall object color.\n            vec3 tCol = tx*tx2*1.5;\n\n            // Bubble overlay field and application.\n            vec3 d3 = df(uv);\n            tCol = mix(tCol, tCol/1.5, (1. - smoothstep(0., sf, d3.x)));\n            //float sh = clamp(.25 - d3.x/.01, 0., 1.15);\n            tCol = mix(tCol, mix(tx*tx2*2., vec3(1), .1), (1. - smoothstep(0., sf, d3.x + .006)));\n            \n            // Applying the face color and border.\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, svGID.w + .0125)));\n            texCol = mix(texCol, tCol, (1. - smoothstep(0., sf, svGID.w + .0125 + .005)));\n\n              \n        }\n        else {\n            \n            // The dark floor in the background. Hiddent behind the pylons, but\n            // you still need it.\n            texCol = vec3(0);\n        }\n       \n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n      \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 16.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        //float fre = pow(clamp(1. + dot(sn, rd), 0., 1.), 2.);\n        \n        // IQ's rim lighting snippet: For anyone not familiar, he's using \n        // the Fresnel factor for some silhouette lighting.\n        //float rim = pow(clamp(1. + dot(rd, sn), 0., 1.), 5.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\t//float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\t//float freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .3 + vec3(1, .8, .5)*spec*4.*sh);\n        //col += tx4*tx4*(sh*.7 + .3)*rim*8.;\n        //col += texCol*(sh*.7 + .3)*rim*8.;\n        \n        vec3 refTx = texture(iChannel2, reflect(rd, sn)).xyz; refTx *= refTx;\n        //col += dot(col, vec3(.299, .587, .114))*refTx*(sh*.7 + .3);\n        //col += texCol*refTx*1.;\n        col += (dot(texCol, vec3(.299, .587, .114))*(sh*.7 + .3))*refTx*.25;\n\n        // Shading.\n        col *= ao*atten;\n        \n        \n\t\n\t}\n    \n    // Sprinkles.\n    //float rnd = hash21(rd.xy + fract(iTime));\n    //col = clamp(col + (rnd*rnd - .5)*.1, 0., 1.);\n    \n    #ifdef TEMPORAL_AA\n    if(iResolution.y<650.){\n        // No camera reprojection. However, I'm roughly estimating where the camera\n        // would have been for the previous frame... Very hacky, but it'll do. :)\n        vec3 prevCol = texture(iChannel3, (fragCoord + vec2(1./3., 0))/iResolution.xy).xyz;\n        col = mix(prevCol, col, 1./3.);\n    }\n    #endif\n    \n    // Rough gamma correction.\n\tfragColor = vec4(max(col, 0.), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}