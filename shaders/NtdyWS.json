{
    "Shader": {
        "info": {
            "date": "1663127659",
            "description": "playing with buffers and worley noise",
            "flags": 32,
            "hasliked": 0,
            "id": "NtdyWS",
            "likes": 3,
            "name": "worley tileworks",
            "published": 3,
            "tags": [
                "feedback",
                "buffer"
            ],
            "usePreview": 0,
            "username": "ufffd",
            "viewed": 212
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI = 3.1415926535897932384626433832795;\nconst float PI_2 = 1.57079632679489661923;\nconst float PI_4 = 0.785398163397448309616;\n\nfloat PHI = (1.0+sqrt(5.0))/2.0;\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 permute(vec4 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec4 dist(vec4 x, vec4 y,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) :  (x * x + y * y);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2 search window instead of 3x3,\n// at the expense of some strong pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a smooth F2, use the slower 3x3 version.\n// F1 is sometimes wrong, too, but OK for most purposes.\nvec2 worley(vec2 P, float jitter, bool manhattanDistance) {\nfloat K =  0.142857142857;// 1/7\nfloat K2= 0.0714285714285; // K/2\n\tvec2 Pi = mod(floor(P), 289.0);\n \tvec2 Pf = fract(P);\n\tvec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n\tvec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n\tvec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n\tp = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n\tvec4 ox = mod(p, 7.0)*K+K2;\n\tvec4 oy = mod(floor(p*K),7.0)*K+K2;\n\tvec4 dx = Pfx + jitter*ox;\n\tvec4 dy = Pfy + jitter*oy;\n\tvec4 d =  dist(dx, dy, manhattanDistance); // d11, d12, d21 and d22, squared\n\t// Sort out the two smallest distances\n\n\t// Do it right and find both F1 and F2\n\td.xy = (d.x < d.y) ? d.xy : d.yx; // Swap if smaller\n\td.xz = (d.x < d.z) ? d.xz : d.zx;\n\td.xw = (d.x < d.w) ? d.xw : d.wx;\n\td.y = min(d.y, d.z);\n\td.y = min(d.y, d.w);\n\treturn sqrt(d.xy);\n}\n\nfloat cubicPulse( float c, float w, float x ) {\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec3 worleyTiles(in vec2 uv, in vec3 col) {\n    vec2 R = iResolution.xy;\n    vec2 px = 1./R,\n         pxc = 2./R.yy;          // [-1,1] vertically\n    \n    uv.x += iTime*0.000001;\n    uv.y += sin(iTime*1.1+uv.x)*0.0005;\n    \n    float worls = 0.;\n    for (int i=0;i<8;i++) {\n        float worl = worley(uv*(4.+sin(iTime*0.1)*3.)+iTime*0.1,1.5+sin(iTime*0.5)-float(i)/8.,true).x;\n        float worlstep = float(i)*0.15;\n        worls += smoothstep(-0.01,0.01,worl-worlstep);\n    }\n    worls = mod(worls,2.);\n    col *= worls;\n    \n    vec3 lp = texture(iChannel0,uv).rgb;\n    col = mix(col,lp, 0.96);\n    \n    vec3 lpn = texture(iChannel0,uv+vec2(0.,pxc.y)).rgb;\n    vec3 lps = texture(iChannel0,uv-vec2(0.,pxc.y)).rgb;\n    vec3 lpe = texture(iChannel0,uv+vec2(pxc.x,0.)).rgb;\n    vec3 lpw = texture(iChannel0,uv-vec2(pxc.x,0.)).rgb;\n    \n    vec3 newcol = vec3(lpn.r,lpe.g,lps.b);\n    \n    float mixer = mix(lps.r,lps.b,sin(iTime)*0.5+0.5);\n    col = mix(col,newcol,mixer);\n    \n    // color adjustments\n    vec3 hsv = rgb2hsv(col);\n    col = hsv2rgb(hsv);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy,\n         uv = fragCoord / R,\n         uvc = ( 2.*fragCoord - R ) / R.y;\n         \n         // uvc *= 1.001;\n         \n    vec2 bguv = uvc * 2.5;\n\n    // Time varying pixel color\n    vec3 col = vec3(1.);\n    \n    \n    float input_bright = texture(iChannel1,uv).r;\n         \n    col = worleyTiles(uv, col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}