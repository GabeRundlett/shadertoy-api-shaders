{
    "Shader": {
        "info": {
            "date": "1656769206",
            "description": "Emulating a Voronoi pattern in under a tweet. While being readable and letting you pick the parameters with the mouse",
            "flags": 0,
            "hasliked": 0,
            "id": "sscfRj",
            "likes": 4,
            "name": "Fake Voronoi 3D Param Visualizer",
            "published": 3,
            "tags": [
                "voronoi",
                "mouse",
                "fast",
                "fake",
                "cellular"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 294
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is a variant of Shane's Cellular Tiling \n(https://www.shadertoy.com/view/4scXz2, https://www.shadertoy.com/view/MdKXDD).\nHis versions are pretty extensively commented so give it a read. The main \nfeature of the celluar tiling is it looks very similar to Voronoi noise, \nbut it is much faster, because it does not use hash. It essentiall rotates \na number of sphere grids around to create the illusion of randomness.\n\nIf you want to see if this is faster than a texture lookup see here \n(https://www.shadertoy.com/view/sd3fDM).\n\nI changed a number of things to make it simpler and easier to understand. \nYou can also select a number of parameters with the mouse.\n- GridRes controls the size of the first grid sample\n- Level controls the number of grids added 3-4 looks pretty good.\n- Degree is controlled by the y-axis of the mouse. It selects the degree of \n    rotation around the x and z axis of each grid is offset to each other. You \n    should avoid multiple of 45 degrees and a few degrees around it.\n- Scale selects the size difference for each grid layer. Note that values \ngreater than about +-10% will make the edges rounded.\n\nI have made a number of comments to make it clear what is happening and why. \nThis probably only for myself, when I forgot how to do this in a year. \n*/\n\n// Text on Screen from Piperoman https://www.shadertoy.com/view/XllSWl\nfloat DigitBin(const in int x) {\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces) {\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) \n    {\n\t\tif(fDigitIndex > fBiggestIndex) \n        {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} \n        else \n        {\t\t\n\t\t\tif(fDigitIndex == -1.0) \n            {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} \n            else \n            {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// makes afmhot colormap with poly6 from me (https://www.shadertoy.com/view/Nd3fR2)\nvec3 afmhot(float t) {\n    const vec3 c0 = vec3(-0.020390,0.009557,0.018508);\n    const vec3 c1 = vec3(3.108226,-0.106297,-1.105891);\n    const vec3 c2 = vec3(-14.539061,-2.943057,14.548595);\n    const vec3 c3 = vec3(71.394557,22.644423,-71.418400);\n    const vec3 c4 = vec3(-152.022488,-31.024563,152.048692);\n    const vec3 c5 = vec3(139.593599,12.411251,-139.604042);\n    const vec3 c6 = vec3(-46.532952,-0.000874,46.532928);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// creates a sphere grid of the squared distance to the center\nfloat sphereGrid(vec3 uv) {\n    vec3 squaregrid = fract(uv) - .5; //rectangular grid with center in the middle\n    float spheregrid = dot(squaregrid, squaregrid); //squared distance form scenter\n    return spheregrid;\n}\n\n#define pi              3.1415926536\n// makes a tiling cell pattern\nfloat cellTiling3D(vec3 uvw, float degree, float scale, int level) {\n    float c = sphereGrid(uvw); // first grid\n    \n    // choose a deg/scale and calculate it here desmos.com/calculator/refsu6mvlj\n    float rad = (pi* degree)/180.; //degree to radians   \n    // This is rotation matrix X * Z, because symtery no 3. rot needed\n    mat3 m = mat3(cos(rad), -cos(rad)*sin(rad), pow(sin(rad),2.),\n                 sin(rad), pow(cos(rad),2.), -cos(rad)*sin(rad),\n                 0., sin(rad), cos(rad));\n    m *= scale;\n    \n    //If you want two indepented seperate rotations for X,Z use this\n    /*mat3 mZ = mat3(cos(rad), -sin(rad), 0.,\n                  sin(rad), cos(rad), 0.,\n                  0., 0., 1.); // rotation matric Z Axis\n    mat3 mX = mat3(1., 0., 0.,\n                   0., cos(rad), -sin(rad),\n                   0., sin(rad), cos(rad)); // rotation matric X Axis                                      \n    mat3 m = mX * mZ * scale; //scale and rotate. */\n    \n    // precalculate the m*m for perfromance\n    for (int i = 0; i < level-1; i++){    \n        uvw *= m; //each iteration gets rotated and scaled one addional time\n        c = min(c, sphereGrid(uvw)); // blending the voronoi with \n    }\n    \n    return sqrt(c); //sqrt for center distance, 1.5 for 0-1 range\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float gridRes = 6.0; //Hex Grid Size\n    int level = 4; //number of point grids, should be above 1. \n    \n    // mouse controls\n    float scale = 1.07; //default values for preview\n    float degree = 33.; // default values for preview\n    if(iMouse.x > 0.0)\t{\n        vec4 mouse = iMouse / iResolution.y;\n        scale = .17 * mouse.x +.85;  // value range .85-1.15\n        degree = mouse.y  * 90.; // it's a square gird going going larger than 90 is pointless\n    }\n        \n    //UV needs to be offset by a large vector from the 0,0, and avoiding 120/90/60 ... deg\n    vec2 offset = vec2(379., 769.); // two arbitrary large prime numbers\n    vec2 uv = vec2(fragCoord/iResolution.y - offset)*gridRes; // uv scaled and offset\n    vec3 uvw = vec3(uv, iTime * 0.5);\n            \n    float vor = cellTiling3D(uvw, degree, scale, level); // generating cell Tilling    \n    \n    vec3 vColour = afmhot(vor); // applying cosmetic colormap\n    \n    // Text portion\n    float fDigits = 1.0;\n\tfloat fDecimalPlaces = 3.0;\t\n    vec2 vFontSize = vec2(8.0, 15.0); // Multiples of 4x5 work best\n    \n    if(iMouse.x > 0.0)\t{\n        // Plot Mouse Pos Point\n\t    float fDistToPointB = length( vec2(iMouse.x, iMouse.y) - fragCoord.xy) - 4.0;\n\t    vColour = mix(vColour, vec3(0.0, 1.0, 0.0), (1.0 - clamp(fDistToPointB, 0.0, 1.0)));\n        \n\t\t// Print Mouse X\n\t\tvec2 vPixelCoord2 = iMouse.xy + vec2(-62.0, 6.0);\n\t\tfloat fValue2 = scale;\n\t\tfDigits = 1.0;\n\t\tfloat fIsDigit2 = PrintValue(fragCoord, vPixelCoord2, vFontSize, fValue2, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit2);\n\t\t\n\t\t// Print Mouse Y\n\t\tvec2 vPixelCoord3 = iMouse.xy + vec2(0.0, 6.0);\n\t\tfloat fValue3 = degree;\n\t\tfDigits = 1.0;\n\t\tfloat fIsDigit3 = PrintValue(fragCoord, vPixelCoord3, vFontSize, fValue3, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit3);\n\t}\n    \n    fragColor = vec4(vColour,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}