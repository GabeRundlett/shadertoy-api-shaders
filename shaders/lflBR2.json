{
    "Shader": {
        "info": {
            "date": "1724157968",
            "description": "Explicit expression for gaussian-filtered gaussian function (see also [url=https://www.shadertoy.com/view/lfsBRB]axis-aligned box-filter[/url]).\nMouse-click to select filter size.",
            "flags": 0,
            "hasliked": 0,
            "id": "lflBR2",
            "likes": 7,
            "name": "Gaussian-filtered gaussian",
            "published": 3,
            "tags": [
                "antialiasing",
                "filtering",
                "analytical",
                "gaussian"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 130
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Explicit expression for gaussian-filtered gaussian function,\n// in 2D (see https://www.shadertoy.com/view/lfsBRB for\n// axis-aligned box-filter version).\n// Mouse-click to select filter size.\n//\n// Consider a gaussian function, with quadratic form M (positive\n// (semi-)definite matrix, which, in probability terms, is the\n// precision matrix, i.e. inverse of the covariance matrix)\n// and center c (using notation x'=transpose(x)):\n//     f(M,c,r)=exp(-(r-c)'*M*(r-c)/2)\n// For example, a 2D case is\n//     f(x,y)=exp(-(A*x^2+2*B*x*y+C*y^2)/2)\n// where M=[A,B;B,C] (for isotropic normal distribution\n// with standard deviation σ, we have A=C=1/σ^2, B=0), and\n// x,y are components of (r-c).\n// It is well-known (see e.g. http://web.ist.utl.pt/susanavinga/renyi/convolution_normal.pdf\n// for derivation) that the convolution of 2 such functions\n// is of the same form (up to a constant multiplier), specifically:\n//     conv(f(A,a,r),f(B,b,r))=W*f(C,a+b,r)\n// where\n//     C=inv(inv(A)+inv(B))=A*inv(A+B)*B\n//     W=(2*π)^(n/2)*sqrt(det(C)/(det(A)*det(B)))=(2*π)^(n/2)/sqrt(det(A+B))\n// and n is dimension of r (NOTE: if both functions are\n// normalized, so is the result).\n// As an aside, a product of 2 such functions is, of course,\n// also a function of the same form (again, up to a constant\n// multiplier).\n// This can be immediately applied to gaussian filter, which\n// has kernel of the same form (up to a normalization constant).\n// This means that gauss-filtering a gaussian function is equivalent\n// to point sampling a different gaussain function (namely,\n// result of the convolution).\n// Rather than a present general case, this shader provides a\n// hard-coded implementation for a common practical case of filtering\n// with isotropic 2D gaussian kernel, centered at origin\n//     g(σ,r)=exp(-r^2/(2*σ^2))/(2*π*σ^2)\n// written purely in scalar form.\n// NOTE: gaussian filtering converges to point sampling as σ->0.\n//\n// Note that (unlike e.g. box filter) such filtering is not\n// energy-preserving when discretizing a function: total value\n// of all samples on a grid does not, in general, equal exact\n// energy (i.e. integral), and varies with grid offset (the average\n// across all offsets *is* exact).\n// However, the error shrinks rapidly for wider gaussians, and even\n// a modestly wide filter can ensure a small error.\n// We can illustrate it with a 1D example. Using a Fourier transform,\n// it is reasonably straightforward to show that a sum of samples of\n// a gaussian (which is a convolution of the gaussian with a Dirac\n// comb), with offset x, can be expressed as (summation is for\n// k from -∞ to +∞):\n//     Σ exp(-(x-k)^2/w^2) = |w|*sqrt(π) * Σ exp(-(π*k*w)^2)*cos(2*π*k*x)\n//                         = |w|*sqrt(π)*(1 + 2*(exp(-(π*w)^2)*cos(2*π*x)+exp(-4*(π*w)^2)*cos(4*π*x)+...))\n// whereas the integral is |w|*sqrt(π). Already for w=1 the absolute error\n// is less than 1.1e-4 (and the relative error is less than 6.3e-5).\n\n//==============================================================================\n\nconst float pi=3.14159265358979;\n\n//==============================================================================\n\n// Evaluate a gaussian function\n//     f(A,B,C,x,y)=exp(-(A*x^2+2*B*x*y+C*y^2)/2)\n// at point r.\nfloat f_point(float A,float B,float C,vec2 r)\n{\n    return exp(-0.5*(A*r.x*r.x+2.0*B*r.x*r.y+C*r.y*r.y));\n}\n\n// Evaluate a convolution of a gaussian function\n//     f(A,B,C,x,y)=exp(-(A*x^2+2*B*x*y+C*y^2)/2)\n// with a gaussian kernel\n//     g(σ,x,y)=exp(-(x^2+y^2)/(2*σ^2))/(2*π*σ^2)\n// at point r.\nfloat f_gauss(float A,float B,float C,float sigma,vec2 r)\n{\n    float x2=r.x*r.x,y2=r.y*r.y,s2=sigma*sigma;\n    float Q=A*C-B*B;\n    float I=1.0+s2*(A+C+s2*Q);\n    return exp(-0.5*(A*x2+2.0*B*r.x*r.y+C*y2+s2*Q*(x2+y2))/I)/sqrt(I);\n}\n\n// Slightly more general version (not actually used in this shader).\n\n// Evaluate a convolution of a gaussian function\n//     f(A,B,C,D,E,F,x,y)=exp(-(A*x^2+2*B*x*y+C*y^2+D*x+E*y+F)/2)\n// with a gaussian kernel\n//     g(σ,x,y)=exp(-(x^2+y^2)/(2*σ^2))/(2*π*σ^2)\n// at point (x,y).\nfloat f_gauss(float A,float B,float C,float D,float E,float F,float sigma,float x,float y)\n{\n    float x2=x*x,y2=y*y,s2=sigma*sigma;\n    float Q=A*C-B*B;\n    float I=1.0+s2*(A+C+s2*Q);\n    float P=A*x2+2.0*B*x*y+C*y2+D*x+E*y+F+\n             s2*(Q*(x2+y2)+(C*D-B*E)*x+(A*E-B*D)*y+(A+C)*F-0.25*(D*D+E*E)+\n                 s2*(F*Q-0.25*(A*E*E-2.0*B*D*E+C*D*D)));\n    return exp(-0.5*P/I)/sqrt(I);\n}\n\n//==============================================================================\n\n// https://www.shadertoy.com/view/dllSW7\nuint hash(uint x)\n{\n    x ^= x >> 15;\n    x ^= (x * x) | 1u;\n    x ^= x >> 17;\n    x *= 0x9E3779B9u;\n    x ^= x >> 13;\n    return x;\n}\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 p=fragCoord;\n    vec3 col=vec3(0.005,0.01,0.2);\n    float s=1.0/25.0;\n    float w=0.5;\n    if(length(iMouse.xy)>10.0) w=2.0*abs(iMouse.x)/iResolution.x;\n    s*=1.01+sin(0.1*iTime);\n    mat2 R=mat2(0.6,-0.8,0.8,0.6);\n    vec2 T=256.0*vec2(sin(vec2(0.037,0.073)*iTime));\n    // Several layers of procedural gaussian ellipses.\n    // Note: the stars are clumped towards cell centers\n    // in attempt to mitigate truncation at cell edges,\n    // which can be fairly noticeable for a single layer,\n    // but less of a problem for multiple layers.\n    for(int k=0;k<7;++k)\n    {\n        vec2 r=s*R*(p-T);                                       // Convert to layer coordinates.\n        ivec2 c=ivec2(floor(r));                                // Cell in layer.\n        uint h=hash(uint(k^(c.x<<8)^(c.y<<24)));                // Cell hash.\n        vec2 P=vec2(c)+0.25+0.5*vec2(h&31u,(h>>5)&31u)/32.0;    // Center.\n        float Rx=pow(float(1u+((h>>10)&15u))/16.0,2.0);         // x-extent.\n        float Ry=pow(float(1u+((h>>14)&15u))/16.0,2.0);         // y-extent.\n        float I=pow((float(1u+((h>>18)&15u))/16.0),1.0);        // Intensity.\n        float a=float((h>>22)&31u);                             // Rotation, in screen space.\n        vec3 COL=0.5+0.375*sin(float(h>>27)+vec3(0,2,4));       // Color.\n        P=transpose(R)*P/s+T;                                   // Convert position to screen-space.\n        Rx*=1e-1/s; Ry*=1e-1/s;                                 // Convert extents to screen-space.\n        I=4.0*I/(2.0*pi*Rx*Ry);                                 // Normalize intensity.\n        float A=(Rx*Rx*sin(a)*sin(a)+Ry*Ry*cos(a)*cos(a))/(Rx*Rx*Ry*Ry);\n        float B=((Ry*Ry-Rx*Rx)*sin(a)*cos(a))/(Rx*Rx*Ry*Ry);\n        float C=(Rx*Rx*cos(a)*cos(a)+Ry*Ry*sin(a)*sin(a))/(Rx*Rx*Ry*Ry);\n        if(fragCoord.x<0.5*iResolution.x) col+=I*COL*f_point(A,B,C,p-P);   // Point sampling.\n        else                              col+=I*COL*f_gauss(A,B,C,w,p-P); // Gaussian filter.\n        // Compute parameters for the next layer.\n        R*=R;\n    }\n    float g=abs(fragCoord.x-0.5*iResolution.x);\n    col=mix(col,vec3(exp(-g*g)),exp(-0.5*g*g));\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}