{
    "Shader": {
        "info": {
            "date": "1557005803",
            "description": "The robot will try to reach the green goal. At the bottom is the robot's point of view, which it uses to construct a map.\ndraw obstacles, or a maze, and he'll (eventually) navigate as long as there's a path. Hold E while drawing to erase.",
            "flags": 48,
            "hasliked": 0,
            "id": "3tXGR2",
            "likes": 36,
            "name": "Robot Navigation Sandbox",
            "published": 3,
            "tags": [
                "distance",
                "robot",
                "maze",
                "pathfinding",
                "pde",
                "fastmarching"
            ],
            "usePreview": 0,
            "username": "ShnitzelKiller",
            "viewed": 1214
        },
        "renderpass": [
            {
                "code": "#define freq 0.4\n#define view_height 0.18\n#define light_intensity 1000.\n//width of the robot view\n#define margin 0.3\n\nfloat height(in vec2 uv) {\n    return sin(texture(iChannel0, uv)*freq).x;\n}\n\nvec2 gradient(in vec2 uv) {\n    vec3 offset = vec3(-1.0, 0.0, 1.0);\n    vec2 invres = 1.0/iResolution.xy;\n    float dx0 = height((uv+offset.xy)*invres);\n    float dxf = height((uv+offset.zy)*invres);\n    float dy0 = height((uv+offset.yx)*invres);\n    float dyf = height((uv+offset.yz)*invres);\n    return vec2(dxf - dx0, dyf - dy0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 P = fragCoord/iResolution.xy;\n    vec4 color = texture(iChannel0, P);\n    \n    //vec2 rg = vec2(sin(color.x*freq), cos(color.x*freq));\n    //vec3 col = vec3(0.2+(max(vec2(0.5), rg)-0.5)*0.25, 0.2);\n    \n    vec4 pose = texture(iChannel1, vec2(0, 0));\n    \n    //lighting\n    vec3 col = vec3(0.2);\n    \n    \n    float s = sin(pose.z);\n    float c = cos(pose.z);\n    mat2 rot = mat2(c, -s, s, c);\n    vec2 disp = rot*(fragCoord-pose.xy);\n    \n    float disp2 = length(pose.xy + vec2(cos(pose.z), sin(pose.z))*5.-fragCoord);\n\n    float disp3 = length(pose.xy-fragCoord);\n    if (disp3 < 5.0) {\n        col = vec3(1.0);\n    } else if (disp2 < 4.0) {\n        col.r = 1.0;\n    } else if (fragCoord.y <= view_height*iResolution.y && P.x >= margin && P.x <= 1.-margin) {\n        //render robot's perspective\n        float scale = 1./(1.-2.*margin);\n        float propx = ((P.x-margin)*scale);\n  \t\tfloat px = (1.-propx) * float(obs_dim);\n        float x = px / iResolution.x;\n        float py = fragCoord.y/(view_height*iResolution.y);\n        float y = (py+1.0) / iResolution.y;\n        vec2 record = texture(iChannel1, vec2(x, y)).xw;\n        float depth = record.x;\n        float size = 5./depth;\n        if (abs(py-0.5) < size) {\n            if (record.y < 0.5) {\n                float fac = 1.-depth/far_clip;\n                col = vec3(fac*0.8, 0.2, 1.0-fac);\n            } else {\n                //col = vec3(0.,1.,0.);\n                col = texture(iChannel3, vec2((propx)/size*0.5,(py-0.5)/size*0.5+0.5)).xyz;\n                col.rb -= 1.;\n            }\n        } else if (py < 0.5) {\n            col = vec3(1.-py);\n        } else {\n            col = vec3(1.03-py*0.5, 1.31-py*0.5, 0.98);\n        }\n    } else {\n        //render map\n        vec4 map = texture(iChannel2, P);\n        \n        if (map.z > 1.5) {\n        \tcol.r = pow(1.0-map.w/mouse_radius*0.5,2.0);\n        } else if (map.z > 0.5) {\n            vec2 goalpos = texture(iChannel1, vec2(0.,4.5)/iResolution.xy).xy;\n            vec2 goalvec = fragCoord - goalpos;\n            col.g = 0.75+0.25*normalize(goalvec).x;\n        }\n        col = col+clamp(map.g/5.*sign(map.r), 0.0, 0.9);\n        col.b += max(0.0, map.r*0.1);\n        \n        //render field of view\n        float obsbound = tan(fov/2.0);\n        if (abs(disp.y/disp.x) < obsbound && disp.x > 0. && length(disp) < far_clip) {\n            float obs_ind = (disp.y/disp.x/obsbound + 1.0) / 2.0 * float(obs_dim-1);\n        \tfloat depth = texture(iChannel1, vec2(obs_ind+0.5, 1.5)/iResolution.xy).x;\n            if (disp.x < depth) {\n                //col.b += 0.5;\n                vec2 grad = gradient(fragCoord);\n                vec3 lightvec = vec3(pose.xy-fragCoord,50.0);\n\t\t\t\tvec3 lightdir = normalize(lightvec);\n                float fac = max(0.,dot(normalize(vec3(grad,1.)), lightdir)+1.);\n                col += fac*light_intensity*pow(disp.x/length(disp), 10.0)/ dot(lightvec, lightvec);\n            }\n        }\n    }\n    fragColor = vec4(col, 1.0);\n    //fragColor = texture(iChannel1, fragCoord/iResolution.xy/10.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//shortest path algorithm buffer\n//distance computation based on fast marching algorithm by sethian\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invres = vec2(1.0) / iResolution.xy;\n\tvec4 knownstate = texture(iChannel2, fragCoord*invres);\n    if (iFrame == 0) {\n        fragColor = vec4(INF, 0., 0., 1.0);\n     \treturn;\n    }\n    \n    if (knownstate.x > 0.0 && knownstate.y > min_weight) {\n        fragColor = vec4(INF, 0.0, 0.0, 1.0);\n        return;\n    } else if(knownstate.z > 0.5 && knownstate.z < 1.5) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    vec3 offsets = vec3(-1.0, 0.0, 1.0);\n   \n    float Un = texture(iChannel0, (fragCoord + offsets.yz)*invres).x;\n    float Ue = texture(iChannel0, (fragCoord + offsets.zy)*invres).x;\n    float Us = texture(iChannel0, (fragCoord + offsets.yx)*invres).x;\n    float Uw = texture(iChannel0, (fragCoord + offsets.xy)*invres).x;\n    \n    float Uh = min(Ue, Uw);\n    float Uv = min(Un, Us);\n    \n    if (Uh < INF && Uv < INF) {\n        float Uhmv = Uh - Uv;\n        float disc = 2.0 - Uhmv*Uhmv;\n        if (disc >= 0.0) {\n            fragColor = vec4(0.5*(Uh+Uv)+0.5*sqrt(disc), 0.0, 1., 1.0);\n            return;\n        }\n    }\n    \n    fragColor = vec4(min(Uh, Uv)+1.0, 0.0, 0.0, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//shortest path algorithm buffer\n//distance computation based on fast marching algorithm by sethian\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invres = vec2(1.0) / iResolution.xy;\n\tvec4 knownstate = texture(iChannel2, fragCoord*invres);\n    if (iFrame == 0) {\n        fragColor = vec4(INF, 0., 0., 1.0);\n     \treturn;\n    }\n    \n    if (knownstate.x > 0.0 && knownstate.y > min_weight) {\n        fragColor = vec4(INF, 0.0, 0.0, 1.0);\n        return;\n    } else if(knownstate.z > 0.5 && knownstate.z < 1.5) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    vec3 offsets = vec3(-1.0, 0.0, 1.0);\n   \n    float Un = texture(iChannel0, (fragCoord + offsets.yz)*invres).x;\n    float Ue = texture(iChannel0, (fragCoord + offsets.zy)*invres).x;\n    float Us = texture(iChannel0, (fragCoord + offsets.yx)*invres).x;\n    float Uw = texture(iChannel0, (fragCoord + offsets.xy)*invres).x;\n    \n    float Uh = min(Ue, Uw);\n    float Uv = min(Un, Us);\n    \n    if (Uh < INF && Uv < INF) {\n        float Uhmv = Uh - Uv;\n        float disc = 2.0 - Uhmv*Uhmv;\n        if (disc >= 0.0) {\n            fragColor = vec4(0.5*(Uh+Uv)+0.5*sqrt(disc), 0.0, 1., 1.0);\n            return;\n        }\n    }\n    \n    fragColor = vec4(min(Uh, Uv)+1.0, 0.0, 0.0, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//ROBOT AND SENSOR SIMULATION BUFFER\n\n//buf.xy = robot position\n//buf.z = robot angle\n//buf.w = robot angular velocity\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x >= float(obs_dim) || fragCoord.y >= 5.0 || (fragCoord.y >= 2.0 && fragCoord.x >= 1.0) || (fragCoord.y < 1.0 && fragCoord.x >= 1.0)) discard;    \n    vec4 state = texture(iChannel0, vec2(0, 0));\n    if (iFrame == 0) {\n        //initialization\n        state = vec4(x0, y0, a0, 0.0);\n        fragColor = state;\n        return;\n    }\n    vec2 invres = 1.0/iResolution.xy;\n    if (fragCoord.y < 1.0) {\n        //robot movement\n        vec3 offset = vec3(-1.0, 0.0, 1.0);\n        vec2 grad;\n        //goal direction\n        {\n            float navx0 = texture(iChannel1, (state.xy+offset.xy)*invres).x;\n            float navxf = texture(iChannel1, (state.xy+offset.zy)*invres).x;\n            float navy0 = texture(iChannel1, (state.xy+offset.yx)*invres).x;\n            float navyf = texture(iChannel1, (state.xy+offset.yz)*invres).x;\n            grad.x = navxf - navx0;\n            grad.y = navyf - navy0;\n        }\n        float mag = length(grad);\n        //wall penalty gradients\n        vec2 realgrad;\n        {\n            float navx0 = texture(iChannel2, (state.xy+offset.xy)*invres).w;\n            float navxf = texture(iChannel2, (state.xy+offset.zy)*invres).w;\n            float navy0 = texture(iChannel2, (state.xy+offset.yx)*invres).w;\n            float navyf = texture(iChannel2, (state.xy+offset.yz)*invres).w;\n            realgrad.x = navxf - navx0;\n            realgrad.y = navyf - navy0;\n        }\n\t\t//update robot pose to follow shortest path\n        float target_angle = atan(-grad.y, -grad.x);\n        float diff = target_angle - state.z;\n        if (diff > PI) diff -= TWO_PI;\n        if (diff < -PI) diff += TWO_PI;\n        float angspeed = state.w;\n        float torque = diff*torque_factor*min(1.,mag);\n        angspeed += torque - angspeed*angular_damping_coefficient;\n        //if (mag < 0.5) angspeed += 0.02;\n        state.z = mod(state.z+angspeed, TWO_PI);\n        state.w = angspeed;\n        vec2 dir = vec2(cos(state.z), sin(state.z));\n        float effectivespeed = speed * clamp(mag, 0.3,1.0);\n        if (mag > 0.1) {\n            effectivespeed *= max(0.,cos(diff));\n        }\n        state.xy += effectivespeed * dir;\n        //apply wall forces\n        state.xy -= realgrad;\n        if (state.x >= iResolution.x) {\n            state.x = iResolution.x-1.;\n        }\n        if (state.y >= iResolution.y) {\n            state.y = iResolution.y-1.;\n        }\n        if (state.y <= 0.) {\n            state.y = 1.;\n        }\n        if (state.x <= 0.) {\n            state.x = 1.;\n        }\n        fragColor = state;\n        \n    } else if (fragCoord.y < 2.0) {\n        //sensor simulation\n        mat2 rot = mat2(cos(state.z), sin(state.z), -sin(state.z), cos(state.z));\n        vec2 ray = normalize(vec2(0.5, (fragCoord.x - float(obs_dim)/2.0) / float(obs_dim) * tan(fov/2.0)));\n        float angcos = ray.x;\n        ray = rot * ray;\n        float d = 0.;\n        int i;\n        bool goal = false;\n        for (i=0; i<steps; i++) {\n            d += step_size;\n            vec2 uv = (state.xy+d*ray)*invres;\n            vec2 observation = texture(iChannel2, uv).zw;\n            if (observation.x > 0.5){\n                int j;\n                d -= observation.y;\n                if (observation.x < 1.5) {\n                \tgoal = true;\n                }\n                break;\n            }\n        }\n        //fragColor = vec4(vec3(d * angcos) + 5.*random(fragCoord.x+iTime), 1.);\n        fragColor = vec4(vec3(d * angcos), goal ? 1.0 : 0.0);\n    } else if (fragCoord.y < 3.0) {\n        vec4 laststate = texture(iChannel0, vec2(0.,2.5)/iResolution.xy);\n        fragColor = vec4(iMouse.xy, laststate.xy);\n    } else if (fragCoord.y < 4.0) {\n        vec4 laststate = texture(iChannel0, vec2(0.,3.5)/iResolution.xy);\n        fragColor = vec4(iMouse.zw, laststate.xy);\n    } else {\n        vec4 sdf = texture(iChannel2, state.xy*invres);\n        vec4 lastval = texture(iChannel0, vec2(0.,4.5)/iResolution.xy);\n        if (sdf.z > 0.5 && sdf.z < 1.5 || iFrame == 0) {\n            float seed = float(iFrame);\n            vec2 randompos = (vec2(random(seed), random(seed))*0.8+0.5)*iResolution.xy;\n        \tfragColor = vec4(randompos, lastval.xy);\n        } else {\n            fragColor = lastval;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//MAPPING BUFFER\n//the current known map that the robot uses to navigate is updated\n//based only on the robot's observations as it explores.\n\n//buf.x = current known map\n//buf.z = actual map\n\nfloat capsule(vec2 pos, vec2 a, vec2 b) {\n    vec2 dir = b - a;\n    vec2 view = pos - a;\n    float h = clamp(dot(dir, view) / dot(dir, dir), 0., 1.);\n    return length(view - h * dir) - mouse_radius;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec4 pose = texture(iChannel0, vec2(0, 0));\n    vec4 mouse_state = texture(iChannel0, vec2(0, 2.5)/iResolution.xy);\n    vec4 click_state = texture(iChannel0, vec2(0, 3.5)/iResolution.xy);\n    float robostate = texture(iChannel1, pose.xy/iResolution.xy).z;\n    float keystate = texelFetch(iChannel2, ivec2(69.,0),0).x;\n\n    vec4 sdf = texture(iChannel1, fragCoord/iResolution.xy);\n    if (iFrame == 0) {\n        \n\t\tsdf = vec4(0., 0., 0., -penalty_dist);\n        robostate = 1.0;\n    }\n\t//if goal is reached\n    if (robostate > 0.5 && robostate < 1.5) {\n        //read next random goal position, use the last one to update penalty values\n        vec4 randompos = texture(iChannel0, vec2(0.,4.5)/iResolution.xy);\n        float randlen1 = length(fragCoord - randompos.xy);\n        float randlenlast = length(fragCoord - randompos.zw);\n        float newpenalty = max(-penalty_dist, randlenlast-goal_radius);\n        //if (randlenlast > goal_radius) {\n        \tnewpenalty = min(sdf.w, newpenalty);\n        //}\n        if (randlen1 < goal_radius) {\n            fragColor = vec4(0.,0.,1.,sdf.w);\n        } else if (sdf.z < 1.5) {\n            fragColor = vec4(sdf.x,sdf.y,0.,newpenalty);\n        } else {\n            fragColor = vec4(sdf.x,sdf.y,2.,newpenalty);\n        }\n        return;\n    }\n    \n    //float mousedist = length(fragCoord - iMouse.xy);\n    float penalty = sdf.w;\n    float realstate = sdf.z;\n    if (click_state.z > 1. && iMouse.z > 1.) {\n        float mousedist = capsule(fragCoord, iMouse.xy, mouse_state.zw);\n        //float mousedist = length(fragCoord - iMouse.xy) - mouse_radius;\n        if (mousedist < mouse_radius && (sdf.z > 1.5 || sdf.z < 0.5)) {\n            if (keystate > 0.5) {\n\t\t\t\trealstate = 0.0;\n            } else {\n                realstate = 2.0;\n                penalty = max(sdf.w, mouse_radius - mousedist);\n            }\n        }\n        if (keystate > 0.5) {\n            penalty = min(sdf.w, max(-penalty_dist, mousedist-mouse_radius));\n        }\n    }\n    pose.z -= pose.w; // extrapolate to cancel out lag between sensor reading and current pose\n    float s = sin(pose.z);\n    float c = cos(pose.z);\n    mat2 rot = mat2(c, -s, s, c);\n    vec2 disp = fragCoord - pose.xy;\n    disp = rot * disp;\n    float obsbound = tan(fov/2.0);\n    if (length(disp) < 10.0) {\n        //update map due to physical collision\n        fragColor = vec4(sdf.z - 1.5, sdf.y+weight, realstate, penalty);\n    } else \n    if (abs(disp.y/disp.x) < obsbound && disp.x > 0.) {\n        //update map using vision sensor\n        float obs_ind = (disp.y/disp.x/obsbound + 1.0) / 2.0 * float(obs_dim-1);\n        vec2 record = texture(iChannel0, vec2(obs_ind+0.5, 1.5)/iResolution.xy).xw;\n        float depth = record.x;\n        float dist = disp.x - depth;\n        if (dist > far_trunc) {\n        \t//out of range\n        \tfragColor = vec4(sdf.x, max(0.,sdf.y-decay_rate), realstate, penalty);\n        } else if (-dist > near_trunc) {\n            //space carving\n            fragColor = vec4(0.0, 0.0, realstate, penalty);\n        } else{\n            float range = depth / disp.x * length(disp);\n            if (range < far_clip && record.y < 0.5) {\n            \t//update with new observations\n            \tfragColor = vec4((sdf.x*sdf.y + dist*weight)/(sdf.y+weight), sdf.y+weight, realstate, penalty);\n            } else {\n                //out of range\n            \tfragColor = vec4(sdf.x, max(0.,sdf.y-decay_rate), realstate, penalty);\n            }\n        } \n    } else {\n        //cull\n        //discard?\n        fragColor = vec4(sdf.x, max(0.,sdf.y-decay_rate), realstate, penalty);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//set the decay _rate to 0. if you don't want the robot to ever \"forget\" things.\n//However, this means it will not re-explore old areas, which can cause it to get stuck if you erase stuff later to make a path.\n\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n//ROBOT SENSOR\n//field of view\n#define fov 1.7\n//range sensor resolution\n#define obs_dim 128\n//raycasting steps\n#define steps 100\n//raycasting step size\n#define step_size 2.75\n//maximum distance to consider (must be smaller than steps * step_size\n#define far_clip 270.\n\n\n//ROBOT MOVEMENT\n//initial pose\n#define x0 100.\n#define y0 iResolution.y/2.0\n#define a0 0.0\n#define speed 0.75\n#define angular_damping_coefficient 0.25\n#define torque_factor 0.01\n\n\n//MAPPING\n\n#define min_weight 0.2\n#define decay_rate 0.001\n#define INF 99999.0\n\n#define near_trunc 10.\n#define far_trunc 5.\n#define weight 0.05\n#define mouse_radius 5.0\n#define goal_radius 20.\n\n#define penalty_dist 1.\n\nfloat random(float x) {\n    return mod(fract(sin(x)*100000.), 1.0)-0.5;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}