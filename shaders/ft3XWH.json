{
    "Shader": {
        "info": {
            "date": "1638983768",
            "description": "Space cubes!",
            "flags": 0,
            "hasliked": 0,
            "id": "ft3XWH",
            "likes": 2,
            "name": "eindacor_spacecubes",
            "published": 3,
            "tags": [
                "kaleidoscope"
            ],
            "usePreview": 0,
            "username": "Eindacor_DS",
            "viewed": 189
        },
        "renderpass": [
            {
                "code": "\n\n#define TWOPI 6.28318530718f\n#define PI 3.14159f\n#define AA 0.001f\n#define SIXTY_DEGREES 1.0471975512f\n#define RENDER_VERTICES false\n\n#define CYAN vec3(0., 1., 1.)\n#define MAGENTA vec3(1., 0., 1.)\n#define YELLOW vec3(1., 1., 0.)\n#define RED vec3(1., 0., 0.)\n#define GREEN vec3(0., 1., 0.)\n#define BLUE vec3(0., 0., 1.)\n#define ORANGE vec3(1., .75, .25)\n#define PINK vec3(1., .25, .75)\n#define WHITE vec3(1.)\n#define BLACK vec3(0.)\n\n#define u_TimeScaleModifier 0.1f\n#define u_HexRadius .15f\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n    float val = sin(dot(p, vec2(12.9898f, 78.233f))) * 43758.5453f;\n    return val - floor(val);\n}\n\nvec3 getRandomColor(float seed) {\n    seed = clamp(seed, 0., 1.);\n    float colorCount = 6.;\n    float colorIncrement = 1.f / colorCount;\n    float seedFloor = floor(seed / colorIncrement) * colorIncrement;\n    float lerpVal = smoothstep(seedFloor, seedFloor + colorIncrement, seed);\n\n    if (seed <= colorIncrement * 1.) {\n        return mix(RED, YELLOW, lerpVal);\n    } else if (seed <= colorIncrement * 2.) {\n        return mix(YELLOW, GREEN, lerpVal);\n    } else if (seed <= colorIncrement * 3.) {\n        return mix(GREEN, CYAN, lerpVal);\n    } else if (seed <= colorIncrement * 4.) {\n        return mix(CYAN, BLUE, lerpVal);\n    } else if (seed <= colorIncrement * 5.) {\n        return mix(BLUE, MAGENTA, lerpVal);\n    } else {\n        return mix(MAGENTA, vec3(1.), lerpVal);\n    }\n}\n\nstruct AspectRatioData {\n    mat2x2 scaleMatrix;\n    mat2x2 inverseScaleMatrix;\n    float aspectRatio;\n};\n\nAspectRatioData getAspectRatioData(vec2 uvSize) {\n    float aspectRatio = uvSize.x / uvSize.y;\n    AspectRatioData aspectRatioData;\n    aspectRatioData.aspectRatio = aspectRatio;\n    aspectRatioData.scaleMatrix = mat2x2(\n        aspectRatio, 0.f,\n        0.f, 1.f\n    );\n    \n    aspectRatioData.inverseScaleMatrix = mat2x2(\n        1.f / aspectRatio, 0.f,\n        0.f, 1.f\n    );\n\n    return aspectRatioData;\n}\n\nbool isHexCenter(vec2 pos, float hexXIncrement, float hexYIncrement) {\n    float columnIndex = round(pos.x / hexXIncrement);\n    float rowIndex = round(pos.y / hexYIncrement);\n    return int(round(mod(abs(columnIndex), 2.f))) == int(round(mod(abs(rowIndex), 2.f)));\n}\n\nfloat getOffsetAngle(vec2 first, vec2 second) {\n    vec2 offsetVec = second - first;\n    float angle = atan(offsetVec.y / offsetVec.x);\n    \n    \n    if (first.x < second.x) {\n        angle = TWOPI / 2.f + angle;\n    } else if (first.y > second.y) {\n        angle = TWOPI + angle;\n    }\n    \n    return angle;\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nvec3 vec2Tovec3(vec2 vec) {\n    return vec3(vec.x, vec.y, 0.f);\n}\n\nstruct HexData {\n    float radialVal;\n    float distFromHexCenter; // float representing approximity to center compared to hex radius\n    vec2 hexCenter;\n    vec2[6] hexVertices;\n    float edgeCoefficient; // float representing approximity to center compared to hex edge\n    float radialLerp; // linear interpolation or radians between local triangle vertices\n    float sumDistCoefficient;\n};\n\nvec2 getHexCenter(vec2 aspectUV, \n                    vec2 leftBottom, \n                    vec2 leftTop, \n                    vec2 rightBottom, \n                    vec2 rightTop,\n                    float aspectHexGridXIncrement, \n                    float hexGridYIncrement,\n                    float aspectHexRadius) {\n    vec2 hexCenter = vec2(-1.f, -1.f); \n\n    if (isHexCenter(leftBottom, aspectHexGridXIncrement, hexGridYIncrement)) {\n        vec2 hexDiagRight = leftBottom + vec2(aspectHexRadius, 0.f);\n        vec2 hexDiagLeft = leftTop + vec2(aspectHexRadius / 2.f, 0.f);\n        vec2 sharedEdgeVector = normalize(vec2(hexDiagLeft - hexDiagRight));\n        vec2 sharedToRightTopVector = normalize(vec2(rightTop - hexDiagRight));\n        vec2 sharedToUVVector = normalize(vec2(aspectUV - hexDiagRight));\n\n        vec3 crossRightTop = cross(vec2Tovec3(sharedEdgeVector), \n                                    vec2Tovec3(sharedToRightTopVector));\n        vec3 crossUV = cross(vec2Tovec3(sharedEdgeVector), \n                                vec2Tovec3(sharedToUVVector));\n\n        hexCenter = (crossRightTop.z == crossUV.z) || \n            (crossRightTop.z < 0.f && crossUV.z < 0.f) || \n            (crossRightTop.z > 0.f && crossUV.z > 0.f) ? rightTop : leftBottom;\n    } else {\n        vec2 hexDiagRight = leftTop + vec2(aspectHexRadius, 0.f);\n        vec2 hexDiagLeft = rightBottom - vec2(aspectHexRadius, 0.f);\n        vec2 sharedEdgeVector = normalize(vec2(hexDiagRight - hexDiagLeft));\n        vec2 sharedToRightBottomVector = normalize(vec2(rightBottom - hexDiagLeft));\n        vec2 sharedToUVVector = normalize(vec2(aspectUV - hexDiagLeft));\n\n        vec3 crossRightBottom = cross(vec2Tovec3(sharedEdgeVector), \n                                        vec2Tovec3(sharedToRightBottomVector));\n        vec3 crossUV = cross(vec2Tovec3(sharedEdgeVector), \n                                vec2Tovec3(sharedToUVVector));\n\n        hexCenter = crossRightBottom.z == crossUV.z || \n            (crossRightBottom.z < 0.f && crossUV.z < 0.f) || \n            (crossRightBottom.z > 0.f && crossUV.z > 0.f) ? rightBottom : leftTop;\n    }\n\n    return hexCenter;\n}\n\nvec2[6] getHexVertices(vec2 hexCenter, float hexRadius) {\n    vec2[6] hexVertices;\n    \n    float rotationIncrement = TWOPI / 6.;\n    \n    vec2 firstVertex = vec2(hexRadius, 0.) * createRotationMatrix(rotationIncrement * 2.);\n    \n    for (int i=0; i<6; ++i) {\n        hexVertices[i] = firstVertex * createRotationMatrix(rotationIncrement * float(i)) + hexCenter;\n    }\n    \n    return hexVertices;\n}\n\nfloat getEdgeCoefficient(vec2 uv, vec2 hexCenter, float hexRadius, float radialVal) {\n    vec2 adjustedUv = uv - hexCenter;\n    float adjustmentRotation = mod(radialVal, TWOPI / 6.);\n    mat2x2 adjsutmentRotationMatrix = createRotationMatrix(adjustmentRotation);\n    adjustedUv = adjustedUv * adjsutmentRotationMatrix;\n    \n    float radialLerp = mod(radialVal, 1./6.) / (1./6.);\n    radialLerp = .5 - (radialLerp > .5 ? 1. - radialLerp : radialLerp);\n    float operativeAngle = radialLerp * TWOPI / 6.;\n    \n    float tangentDistance = cos(TWOPI / 12.) * hexRadius;\n    \n    float maxToEdge = tangentDistance / cos(operativeAngle);\n    return distance(uv, hexCenter) / maxToEdge;\n}\n\nfloat getRadialVal(vec2 hexCenter, vec2 p) {\n    float offsetAngle = getOffsetAngle(hexCenter, p);\n    offsetAngle = mod(TWOPI - offsetAngle + 5.f * TWOPI / 6.f, TWOPI);\n    return offsetAngle / TWOPI;\n}\n\nHexData getHexData(\n    vec2 uv, \n    float hexRadius, \n    float hexGridXIncrement,\n    float hexGridYIncrement) \n{\n    float aspectHexGridXIncrement = hexGridXIncrement;\n\n    float leftEdge = floor(uv.x / aspectHexGridXIncrement) * aspectHexGridXIncrement;\n    float rightEdge = leftEdge + aspectHexGridXIncrement;\n    float bottomEdge = floor(uv.y / hexGridYIncrement) * hexGridYIncrement;\n    float topEdge = bottomEdge + hexGridYIncrement;\n\n    \n    vec2 leftBottom = vec2(leftEdge, bottomEdge);\n    vec2 leftTop = vec2(leftEdge, topEdge);\n    vec2 rightTop = vec2(rightEdge, topEdge);\n    vec2 rightBottom = vec2(rightEdge, bottomEdge);\n\n    float aspectHexRadius = hexRadius;\n    vec2 hexCenter = getHexCenter(uv,\n                            leftBottom, \n                            leftTop, \n                            rightBottom, \n                            rightTop, \n                            aspectHexGridXIncrement, \n                            hexGridYIncrement,\n                            aspectHexRadius);\n\n    float offsetAngle = getOffsetAngle(hexCenter, uv);\n    // mulitplying by 5 rotates the uv so the default orientation (0 radians) is facing downward\n    offsetAngle = mod(TWOPI - offsetAngle + 5.f * TWOPI / 6.f, TWOPI);\n    \n    float distMin = 6. * u_HexRadius;\n    float distMax = 4. * u_HexRadius + 4. * cos(SIXTY_DEGREES / 2.) * u_HexRadius;\n    \n    HexData hexData;\n    hexData.radialVal = getRadialVal(hexCenter, uv);\n    hexData.hexCenter = hexCenter;\n    hexData.distFromHexCenter = distance(uv, hexCenter) / hexRadius;\n    hexData.hexVertices = getHexVertices(hexCenter, hexRadius);\n    hexData.edgeCoefficient = getEdgeCoefficient(uv, hexCenter, hexRadius, hexData.radialVal);\n    hexData.radialLerp = mod(hexData.radialVal, 1./6.) / (1./6.);\n     \n    float distTotal = 0.;\n    for (int i=0; i<6; ++i) {\n        distTotal += distance(uv, hexData.hexVertices[i]);\n    }\n    hexData.sumDistCoefficient = (distTotal - distMin) / (distMax - distMin);\n    \n    return hexData;\n}\n\nvec2 getRandomVector(float seed) {\n    vec2 outVec;\n    if (seed < .25) {\n        outVec = vec2(1., 1.);\n    } else if (seed < .5) {\n        outVec = vec2(-1., 1.);\n    } else if (seed < .75) {\n        outVec = vec2(1., -1.);\n    } else {\n        outVec = vec2(-1., -1.);\n    }\n    \n    return outVec;\n}\n\nfloat getHexVertexHash(vec2 hexVertex) {\n    return hash(vec2(floor(hexVertex.x * 100.), floor(hexVertex.y * 100.)));\n}\n\nfloat getAngleBetweenPoints(vec2 first, vec2 second) {\n    return atan(abs(second.y - first.y)/abs(second.x - first.x));\n}\n\nvec2 getAxisMixAndProximity(vec2 first, vec2 second, vec2 p) {\n    vec2 A = second - first;\n    vec2 B = p - first;\n    \n    float cosAngle = dot(A, B) / dot(length(A), length(B));\n\n    float targetLength = cosAngle * length(B);\n    float mixVal = targetLength / length(A);\n    \n    float shortRadius = u_HexRadius * sin(SIXTY_DEGREES);\n    \n    float deviation = 1. - (sin(acos(cosAngle)) * length(B) / shortRadius);\n    return vec2(mixVal, deviation);\n}\n\nfloat getHexLerp(vec2[6] hexVertices, vec2 hexCenter, vec2 uv) {\n    return 1.;   \n}\n\nfloat dotToNormal(float dotVal) {\n    return (dotVal + 1.) / 2.;\n}\n\nfloat getTriangleArea(vec2 first, vec2 second, vec2 third) {\n    return abs(.5 * (first.x * (second.y - third.y) + second.x * (third.y - first.y) + third.x * (first.y - second.y)));\n}\n\nvec3 getBarycentricValue(vec2 A, vec2 B, vec2 C, vec2 p) {\n    float totalArea = getTriangleArea(A, B, C);\n    float alpha = getTriangleArea(B, C, p) / totalArea;\n    float beta = getTriangleArea(A, C, p) / totalArea;\n    float gamma = getTriangleArea(A, B, p) / totalArea;\n\n    return vec3(alpha, beta, gamma);\n}\n\nfloat getHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\nfloat biLerp(float f0, float f1, float f2, float f3, float lerpX, float lerpY) {\n    float upper = mix(f1, f2, lerpX);\n    float lower = mix(f0, f3, lerpX);\n    \n    return mix(lower, upper, lerpY);\n}\n\nfloat getModifiedDot(vec2 uv, vec2 p, float gridDimension, float pHash) {\n    return dot((uv - p) / gridDimension, getRandomVector(pHash));\n}\n\nfloat getPerlinValue(vec2 uv, float gridDimension) {\n    float xCoord = floor(uv.x / gridDimension) * gridDimension;\n    float yCoord = floor(uv.y / gridDimension) * gridDimension;\n    \n    float xIndex = floor(uv.x / gridDimension);\n    float yIndex = floor(uv.y / gridDimension);\n    \n    float p0Hash = hash(vec2(xIndex, yIndex));\n    float p1Hash = hash(vec2(xIndex, yIndex + 1.));\n    float p2Hash = hash(vec2(xIndex + 1., yIndex + 1.));\n    float p3Hash = hash(vec2(xIndex + 1., yIndex));\n    \n    vec2 p0 = vec2(xCoord, yCoord);\n    vec2 p1 = vec2(xCoord, yCoord + gridDimension);\n    vec2 p2 = vec2(xCoord + gridDimension, yCoord + gridDimension);\n    vec2 p3 = vec2(xCoord + gridDimension, yCoord);\n\n    float dot0 = getModifiedDot(uv, p0, gridDimension, p0Hash);\n    float dot1 = getModifiedDot(uv, p1, gridDimension, p1Hash);\n    float dot2 = getModifiedDot(uv, p2, gridDimension, p2Hash);\n    float dot3 = getModifiedDot(uv, p3, gridDimension, p3Hash);\n    \n    float xInterp = smoothstep(p0.x, p2.x, uv.x);\n    float yInterp = smoothstep(p0.y, p2.y, uv.y);\n    \n    return biLerp(dot0, dot1, dot2, dot3, xInterp, yInterp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    AspectRatioData aspectRatioData = getAspectRatioData(iResolution.xy);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * aspectRatioData.scaleMatrix;\n    uv += vec2(5., iTime * .075);\n    uv = uv * createRotationMatrix(TWOPI / 12.);\n    \n    vec2 parallaxUv = fragCoord/iResolution.xy * aspectRatioData.scaleMatrix + vec2(5., iTime * .01);\n    vec2 starUv = fragCoord/iResolution.xy * aspectRatioData.scaleMatrix + vec2(5., iTime * .01);\n    \n    float shortRadius = u_HexRadius * sin(SIXTY_DEGREES);\n\n    float hexGridXIncrement = 1.5f * u_HexRadius;\n    float hexGridYIncrement = shortRadius;\n    \n    HexData hexData = getHexData(\n        uv, \n        u_HexRadius, \n        hexGridXIncrement,\n        hexGridYIncrement);\n \n    vec3 averageColor = vec3((sin(iTime * .5 + hexData.distFromHexCenter) + 1.) / 2.);\n    for (int i=0; i<6; ++i) {\n        float vertexHash = getHexVertexHash(hexData.hexVertices[i]);\n        //averageColor += getRandomColor(vertexHash) / 6.;\n    }\n\n    float centerToEdgeCoeff = 1.6;\n    float centerToEdgeFactor = hexData.edgeCoefficient; // TODO change back to edgeCoeff to fix\n    float radialBlendCoeff = mix(.8, 1., hexData.edgeCoefficient);\n    \n    \n    vec3 color = vec3(0.);\n    \n    //color *= step(.01, starHash);\n    \n    for (int i=0; i<6; ++i) {\n        int firstIndex = i;\n        int secondIndex = (i + 1) % 6;\n        \n        vec2 firstVertex = hexData.hexVertices[firstIndex];\n        vec2 secondVertex = hexData.hexVertices[secondIndex];\n        \n        float firstHash = getHexVertexHash(hexData.hexVertices[firstIndex]);\n        float secondHash = getHexVertexHash(hexData.hexVertices[secondIndex]);\n        \n        vec3 firstColor =  getRandomColor(firstHash);\n        vec3 secondColor =  getRandomColor(secondHash);\n        \n        vec3 baryCoords = getBarycentricValue(firstVertex, secondVertex, hexData.hexCenter, uv);\n        if (baryCoords.x + baryCoords.y + baryCoords.z > 1.0001) {\n            continue;\n        }\n        \n        if (i == 0) {\n            //fragColor = vec4(1.);\n            //return;\n        }\n\n        float radialLerp = 1. - hexData.radialLerp;\n        vec3 combinedColor = mix(firstColor, secondColor, .5);\n        vec3 outColor;\n        if (radialLerp < .5) {\n            float localLerp = radialLerp / .5;\n            outColor = mix(firstColor, combinedColor, pow(localLerp, radialBlendCoeff));\n        } else {\n            float inverseLerp = (1. - radialLerp) / .5;\n            outColor = mix(secondColor, combinedColor, pow(inverseLerp, radialBlendCoeff));\n        }\n\n        color = mix(averageColor, outColor, pow(centerToEdgeFactor, centerToEdgeCoeff));\n        vec3 baryColor = baryCoords.x * firstColor + baryCoords.y * secondColor + baryCoords.z * averageColor;\n        break;\n    }\n\n    if (RENDER_VERTICES) {\n        for (int i=0; i<6; i++) {\n            vec2 hexVertex = hexData.hexVertices[i];\n\n            float distFromVert = distance(uv, hexVertex);\n            float vertexSize = .01;\n            if (distFromVert < vertexSize) {\n                float distVal = smoothstep(vertexSize, vertexSize - AA * 4., distFromVert);\n                color = mix(vec3(0.), vec3(getRandomColor(getHexVertexHash(hexVertex))), distVal);\n                fragColor = vec4(color, 1.);\n                return;\n            }   \n        }\n    }\n    \n    int hexColumnIndex = int(hexData.hexCenter.x / (u_HexRadius + shortRadius / 2.));\n    int hexRowIndex = int(hexData.hexCenter.y / (u_HexRadius * 2.));\n    hexColumnIndex += hexRowIndex % 2 == 0 ? 0 : 1;\n    \n    float offsetCoeff = getHoldTransitionValue(0., 1., 10., 3., iTime);\n    float offsetVal = mix(.0, 1., hexColumnIndex % 2 == 0 ? 1. - offsetCoeff : offsetCoeff);\n    float dropoff = .05 * (1. - offsetVal);\n    float edgeVal = smoothstep(offsetVal + AA, offsetVal - AA, hexData.edgeCoefficient);\n \n    vec3 outColor1 = color * vec3(1., .25, .25);\n    vec3 cubeColor = mix(1. - outColor1, outColor1, (sin(iTime * .086) + 1.) / 2.) * edgeVal;\n\n    int shadeIndex = int(mod(hexData.radialVal + .5, 1.) * 3.);\n    \n    float shadeValue;\n    switch(shadeIndex) {\n        case 0: shadeValue = 1.; break;\n        case 1: shadeValue = .75; break;\n        case 2: shadeValue = .5; break;\n        default: shadeValue = -1.; break;\n    }\n    \n    cubeColor *= shadeValue;\n    \n    float starGridDimension = .005;\n    vec2 starCoords = vec2(floor(parallaxUv.x / starGridDimension), floor(parallaxUv.y / starGridDimension));\n    vec2 starValVec = vec2(fract(parallaxUv.x / starGridDimension), fract(parallaxUv.y / starGridDimension));\n    vec2 starCoordCenter = starCoords + starValVec * starGridDimension;\n    float starHash = hash(starCoords);\n    float maxStarRadius = .5;\n    float starVariation = .35;\n    float starRadius = mix(maxStarRadius, maxStarRadius - starVariation, hash(vec2(starCoords.y, starCoords.x)));\n    float starVal = smoothstep(\n        starRadius, \n        starRadius - AA, \n        distance(starValVec, vec2(.5)));\n        \n    float starBrightness = mix(.2, .7, hash(vec2(starHash * 100., starHash - 10.))); \n    float starNoise = mix(.8, 1., (sin(iTime * 50. + hash(vec2(-starCoords.y, starCoords.x)) * 100.) + 1.) / 2.);\n\n    float starAppearance = 1. - step(.001, starHash);\n    vec3 starColor = vec3(starVal) * starAppearance;\n\n    starColor *= starNoise * starBrightness;\n    float perlinSize = .3;\n    vec3 perlinColor = vec3(getPerlinValue(starUv, perlinSize)) * vec3(0.1, 0., .05);\n    perlinColor += vec3(getPerlinValue(vec2(starUv.y, starUv.x), perlinSize)) * vec3(0.02, 0., .12);\n    \n    cubeColor = mix(mix(perlinColor, starColor, starAppearance), cubeColor, edgeVal);\n    \n    fragColor = vec4(cubeColor, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}