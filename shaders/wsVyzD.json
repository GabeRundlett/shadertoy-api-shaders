{
    "Shader": {
        "info": {
            "date": "1611691976",
            "description": "A separable Poisson solver method computed using singular value decomposition",
            "flags": 48,
            "hasliked": 0,
            "id": "wsVyzD",
            "likes": 40,
            "name": "Fast Separable Poisson SVD",
            "published": 3,
            "tags": [
                "poisson",
                "normal",
                "depth",
                "value",
                "decomposition",
                "vein",
                "melter",
                "svd",
                "singular"
            ],
            "usePreview": 0,
            "username": "cornusammonis",
            "viewed": 1077
        },
        "renderpass": [
            {
                "code": "/* \n\tCreated by Cornus Ammonis (2021)\n\tCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n    Fork of \"Perceptual Depth Poisson Solver\" by cornusammonis. https://shadertoy.com/view/MlByW3\n    2020-10-10 22:58:33\n\n\tThis is an update of my previously-posted \"Perceptual Depth Poisson Solver\" shader.\n\tAs in the previous technique, a Poisson solver kernel is generated by recursively \n    solving multiple Jacobi iterations. See this shader (https://www.shadertoy.com/view/MdSczK)\n    by Robert Schuetze for another example of a multi-step kernel Poisson solver method. \n    \n    This approach sacrifices some accuracy for greatly improved performance by precomputing\n    separable Poisson solver kernels using singular value decomposition.\n    \n    Here, the Laplacian calculation step and Poisson solver step are combined together by \n    convolution, resulting in a single step with two kernels, one each for the x and y \n    components of the input vector field. The combined kernels are then decomposed into separable \n    kernels using singular value decomposition. Here, the 3 largest singular values are taken, \n    and the sum of the 3 resulting separable convolutions is used to approximate the 2 full \n    Poisson kernels. \n    \n    The result of the first pass (Buffer C) is packed to half floats in order to store each of the 6\n    values (3 each for x and y components) from the first convolution pass in a single buffer.\n    \n    I have also made some general performance improvements to the original shader by offloading\n    some computation in the dynamical system in Buffer A to a second pass in Buffer B. These \n    changes are ancillary to the Poisson-SVD method demonstrated here.\n\n\tComment out \"#define POISSON\" below to render using the original vector map without using the\n    Poisson solver.\n*/\n\n// displacement (for texturing)\n#define DISP 0.02\n\n// bump mapping scale\n#define BUMP 1.5\n\n// mip level\n#define MIP 0.0\n\n// comment to use the original vector field without running through the Poisson solver\n#define POISSON\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 texel = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 n  = vec2(0.0, texel.y);\n    vec2 e  = vec2(texel.x, 0.0);\n    vec2 s  = vec2(0.0, -texel.y);\n    vec2 w  = vec2(-texel.x, 0.0);\n\n    #ifdef POISSON\n        float d   = texture(iChannel0, uv).x;\n        float d_n = texture(iChannel0, fract(uv+n)).x;\n        float d_e = texture(iChannel0, fract(uv+e)).x;\n        float d_s = texture(iChannel0, fract(uv+s)).x;\n        float d_w = texture(iChannel0, fract(uv+w)).x; \n\n        float d_ne = texture(iChannel0, fract(uv+n+e)).x;\n        float d_se = texture(iChannel0, fract(uv+s+e)).x;\n        float d_sw = texture(iChannel0, fract(uv+s+w)).x;\n        float d_nw = texture(iChannel0, fract(uv+n+w)).x; \n\n        float dxn[3];\n        float dyn[3];\n\n        dyn[0] = d_nw - d_sw;\n        dyn[1] = d_n  - d_s; \n        dyn[2] = d_ne - d_se;\n\n        dxn[0] = d_ne - d_nw; \n        dxn[1] = d_e  - d_w; \n        dxn[2] = d_se - d_sw; \n    #else\n        vec2 d   = texture(iChannel2, uv).xy;\n        vec2 d_n = texture(iChannel2, fract(uv+n)).xy;\n        vec2 d_e = texture(iChannel2, fract(uv+e)).xy;\n        vec2 d_s = texture(iChannel2, fract(uv+s)).xy;\n        vec2 d_w = texture(iChannel2, fract(uv+w)).xy; \n\n        vec2 d_ne = texture(iChannel2, fract(uv+n+e)).xy;\n        vec2 d_se = texture(iChannel2, fract(uv+s+e)).xy;\n        vec2 d_sw = texture(iChannel2, fract(uv+s+w)).xy;\n        vec2 d_nw = texture(iChannel2, fract(uv+n+w)).xy; \n\n        float dxn[3];\n        float dyn[3];\n\n        dyn[0] = d_n.y;\n        dyn[1] = d.y; \n        dyn[2] = d_s.y;\n\n        dxn[0] = d_e.x; \n        dxn[1] = d.x; \n        dxn[2] = d_w.x; \n    #endif\n    \n    #define I(d_x,d_y) texture(iChannel1, fract(vec2(0.5) + DISP * vec2(d_x,d_y)), MIP).xyz\n\n    vec3 i   = I(dxn[0],dyn[0]);\n    vec3 i_n = I(dxn[1],dyn[1]);\n    vec3 i_e = I(dxn[2],dyn[2]);\n    vec3 i_s = I(dxn[1],dyn[2]);\n    vec3 i_w = I(dxn[2],dyn[0]);\n    \n    vec3 ib = 0.4 * i + 0.15 * (i_n+i_e+i_s+i_w);\n\n    vec3 ld = normz(vec3(0.5+0.5*vec2(cos(iTime/2.0), sin(iTime/2.0)) - uv, -1.));\n    \n    float spec = 0.0;    \n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            vec3 dxy = normalize(vec3(-BUMP*vec2(dxn[i], dyn[j]), -1.0));\n            spec += ggx(dxy, vec3(0,0,-1), ld, 0.4, 0.1) / 9.0;\n        }\n    }\n\n    // end bumpmapping section\n\n    vec3 tc = 0.9*contrast(0.9*ib);\n\n    fragColor = vec4((tc + vec3(0.9, 0.85, 0.8)*spec),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define STEPS 40  // advection steps\n\n#define ts 0.25    // advection curl\n#define cs -2.0   // curl scale\n#define ls 0.05   // laplacian scale\n#define ps -2.0   // laplacian of divergence scale\n#define ds -0.4   // divergence scale\n#define dp -0.03  // divergence update scale\n#define pl 0.3    // divergence smoothing\n#define amp 1.0   // self-amplification\n#define upd 0.4   // update smoothing\n\n#define _D 0.6    // diagonal weight\n\n#define _K0 -20.0/6.0 // laplacian center weight\n#define _K1 4.0/6.0   // laplacian edge-neighbors\n#define _K2 1.0/6.0   // laplacian vertex-neighbors\n\n#define _G0 0.25      // gaussian center weight\n#define _G1 0.125     // gaussian edge-neighbors\n#define _G2 0.0625    // gaussian vertex-neighbors\n\nbool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0) ? vec2(0.0) : normalize(x);\n}\n\n#define T(d) texture(iChannel0, fract(aUv+d)).xyz\n\nvec3 advect(vec2 ab, vec2 vUv, vec2 texel, out float curl, out float div, out vec3 lapl, out vec3 blur) {\n    \n    vec2 aUv = vUv - ab * texel;\n    vec4 t = vec4(texel, -texel.y, 0.0);\n\n    vec3 uv =    T( t.ww); vec3 uv_n =  T( t.wy); vec3 uv_e =  T( t.xw);\n    vec3 uv_s =  T( t.wz); vec3 uv_w =  T(-t.xw); vec3 uv_nw = T(-t.xz);\n    vec3 uv_sw = T(-t.xy); vec3 uv_ne = T( t.xy); vec3 uv_se = T( t.xz);\n    \n    curl = uv_n.x - uv_s.x - uv_e.y + uv_w.y + _D * (uv_nw.x + uv_nw.y + uv_ne.x - uv_ne.y + uv_sw.y - uv_sw.x - uv_se.y - uv_se.x);\n    div  = uv_s.y - uv_n.y - uv_e.x + uv_w.x + _D * (uv_nw.x - uv_nw.y - uv_ne.x - uv_ne.y + uv_sw.x + uv_sw.y + uv_se.y - uv_se.x);\n    lapl = _K0*uv + _K1*(uv_n + uv_e + uv_w + uv_s) + _K2*(uv_nw + uv_sw + uv_ne + uv_se);\n    blur = _G0*uv + _G1*(uv_n + uv_e + uv_w + uv_s) + _G2*(uv_nw + uv_sw + uv_ne + uv_se);\n    \n    return uv;\n}\n\nvec2 rot(vec2 v, float th) {\n\treturn vec2(dot(v, vec2(cos(th), -sin(th))), dot(v, vec2(sin(th), cos(th)))); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    vec3 lapl, blur;\n    float curl, div;\n    \n    vec3 uv = advect(vec2(0), vUv, texel, curl, div, lapl, blur);\n\n    float sp = ps * lapl.z;\n    float sc = cs * curl;\n\tfloat sd = uv.z + dp * div + pl * lapl.z;\n    vec2 norm = normz(uv.xy);\n\n    vec2 off = uv.xy;\n    vec2 offd = off;\n    vec3 ab = vec3(0);\n\n    for(int i = 0; i < STEPS; i++) {\n        //advect(off, vUv, texel, curl, div, lapl, blur);\n        vec4 samp = texture(iChannel2, fract(vUv - off * texel));\n        curl = samp.w;\n        blur = samp.xyz;\n        offd = rot(offd,ts*curl);\n        off += offd;\n    \tab += blur / float(STEPS);  \n    }\n    \n    vec2 tab = amp * ab.xy + ls * lapl.xy + norm * sp + uv.xy * ds * sd;    \n    vec2 rab = rot(tab,sc);\n    \n    vec3 abd = mix(vec3(rab,sd), uv, upd);\n    \n    if (iMouse.z > 0.0) {\n    \tvec2 d = (fragCoord.xy - iMouse.xy) / iResolution.x;\n        vec2 m = 0.1 * normz(d) * exp(-length(d) / 0.02);\n        abd.xy += m;\n        uv.xy += m;\n    }\n    \n    // initialize with noise\n    if(uv == vec3(0) || reset()) {\n        vec3 rnd = vec3(noise(8.0 * vUv + 1.1), noise(8.0 * vUv + 2.2), noise(8.0 * vUv + 3.3));\n        fragColor = vec4(rnd, 0);\n    } else {\n        abd.z = clamp(abd.z, -1.0, 1.0);\n        abd.xy = clamp(length(abd.xy) > 1.0 ? normz(abd.xy) : abd.xy, -1.0, 1.0);\n        fragColor = vec4(abd, 0.0);\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This computes the laplacian of the input\n\n#define _G0 0.25      // gaussian center weight\n#define _G1 0.125     // gaussian edge-neighbors\n#define _G2 0.0625    // gaussian vertex-neighbors\n\n#define _D 0.6    // diagonal weight\n\n#define T(d) texture(iChannel0, fract(vUv+d)).xyz\n\nvec4 curl_gaussian(vec2 fragCoord, vec2 iResolution) {\n    vec2 texel = 1.0 / iResolution;\n    vec2 vUv = fragCoord * texel;\n    vec4 t = vec4(texel, -texel.y, 0.0);\n\n    vec3 uv =    T( t.ww); vec3 uv_n =  T( t.wy); vec3 uv_e =  T( t.xw);\n    vec3 uv_s =  T( t.wz); vec3 uv_w =  T(-t.xw); vec3 uv_nw = T(-t.xz);\n    vec3 uv_sw = T(-t.xy); vec3 uv_ne = T( t.xy); vec3 uv_se = T( t.xz);\n    \n    float curl = uv_n.x - uv_s.x - uv_e.y + uv_w.y + _D * (uv_nw.x + uv_nw.y + uv_ne.x - uv_ne.y + uv_sw.y - uv_sw.x - uv_se.y - uv_se.x);\n    vec3 gaussian = _G0*uv + _G1*(uv_n + uv_e + uv_w + uv_s) + _G2*(uv_nw + uv_sw + uv_ne + uv_se);\n    \n    return vec4(gaussian, curl);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = curl_gaussian(fragCoord, iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "bool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 texel = 1.0 / iResolution.xy;\n    \n    \n/*\nU:\n 1.9000778e-006   2.6484959e-003  -1.0391083e-001\n-2.0540590e-003  -4.4125709e-003  -3.4489894e-001\n-1.3499238e-002  -6.8390049e-002  -4.8179728e-001\n-5.1257182e-002  -2.5511910e-001  -3.1508410e-001\n-1.5871959e-001  -5.5398879e-001   1.1805352e-001\n-4.7194022e-001  -1.2936001e-001   1.1920299e-001\n-7.0606907e-001   4.6167731e-001  -1.4625093e-001\n-4.7194022e-001  -1.2936001e-001   1.1920299e-001\n-1.5871959e-001  -5.5398879e-001   1.1805352e-001\n-5.1257182e-002  -2.5511910e-001  -3.1508410e-001\n-1.3499238e-002  -6.8390049e-002  -4.8179728e-001\n-2.0540590e-003  -4.4125709e-003  -3.4489894e-001\n 1.9000778e-006   2.6484959e-003  -1.0391083e-001\n\nV:\n 6.2750203e-003  5.2398670e-002  3.7276962e-001  \n-1.6414278e-003  4.2486224e-002  5.4995743e-001\n-4.3498466e-002 -1.0892533e-001  2.4023362e-001\n-1.3135171e-001 -3.3953004e-001 -7.8265086e-004\n-3.0484343e-001 -5.0984393e-001  1.8311873e-002\n-6.2280256e-001  3.2918550e-001 -2.3270335e-002\n-5.8224388e-076  3.2916004e-064 -1.0109051e-055\n 6.2280256e-001 -3.2918550e-001  2.3270335e-002\n 3.0484343e-001  5.0984393e-001 -1.8311873e-002\n 1.3135171e-001  3.3953004e-001  7.8265088e-004  \n 4.3498466e-002  1.0892533e-001 -2.4023362e-001\n 1.6414278e-003 -4.2486224e-002 -5.4995743e-001\n-6.2750203e-003 -5.2398670e-002 -3.7276962e-001\n\ndiag(S):\n\n  5.2045614e-001\n  4.5787111e-002\n  5.3607463e-003\n  1.3379961e-003\n  2.4305267e-005\n  6.5520767e-008\n  2.7241624e-013\n  1.8098574e-013\n  4.2556708e-014\n  3.2104951e-014\n  5.6655005e-016\n  2.1958056e-018\n  1.0637097e-030\n\n*/\n\n    float p_y3[13] = float[](-1.0391083e-001, -3.4489894e-001, -4.8179728e-001, -3.1508410e-001,  1.1805352e-001,  1.1920299e-001, -1.4625093e-001,  1.1920299e-001,  1.1805352e-001, -3.1508410e-001, -4.8179728e-001, -3.4489894e-001, -1.0391083e-001);\n \tfloat p_y2[13] = float[](2.6484959e-003, -4.4125709e-003, -6.8390049e-002, -2.5511910e-001, -5.5398879e-001, -1.2936001e-001, 4.6167731e-001, -1.2936001e-001, -5.5398879e-001, -2.5511910e-001, -6.8390049e-002, -4.4125709e-003, 2.6484959e-003);\n    float p_y1[13] = float[](1.9000778e-006, -2.0540590e-003, -1.3499238e-002, -5.1257182e-002, -1.5871959e-001, -4.7194022e-001, -7.0606907e-001, -4.7194022e-001, -1.5871959e-001, -5.1257182e-002, -1.3499238e-002, -2.0540590e-003,  1.9000778e-006);\n\n    float p_x3[13] = float[](3.7276962e-001,  5.4995743e-001,  2.4023362e-001, -7.8265086e-004,  1.8311873e-002, -2.3270335e-002, -1.0109051e-055,  2.3270335e-002, -1.8311873e-002,  7.8265088e-004, -2.4023362e-001, -5.4995743e-001, -3.7276962e-001);\n    float p_x2[13] = float[](5.2398670e-002,  4.2486224e-002, -1.0892533e-001, -3.3953004e-001, -5.0984393e-001,  3.2918550e-001,  0.0, -3.2918550e-001,  5.0984393e-001,  3.3953004e-001,  1.0892533e-001, -4.2486224e-002, -5.2398670e-002);\n    float p_x1[13] = float[](6.2750203e-003, -1.6414278e-003, -4.3498466e-002, -1.3135171e-001, -3.0484343e-001, -6.2280256e-001, 0.0, 6.2280256e-001, 3.0484343e-001, 1.3135171e-001, 4.3498466e-002, 1.6414278e-003, -6.2750203e-003);\n        \n    float s_i[3] = float[](  5.2045614e-001, 4.5787111e-002, 5.3607463e-003);\n    \n    float g_x[13] = float[](1.8154960e-002, 5.1439053e-002, 1.1757498e-001, 2.2045309e-001, 3.4292702e-001, 4.4580513e-001, \n         4.8633287e-001, 4.4580513e-001, 3.4292702e-001, 2.2045309e-001, 1.1757498e-001, 5.1439053e-002, 1.8154960e-002);  \n\n    #define RANGE 6\n    \n    #define Po(m,n) texture(iChannel0, fract(uv + texel * vec2(m,n)))\n    \n    vec2 P1 = vec2(0);\n    vec2 P2 = vec2(0);\n    vec2 P3 = vec2(0);\n    float G = 0.0;\n    float Gw = 0.0;\n    for (int i = -RANGE; i <= RANGE; i++) {\n        int index = RANGE + i;\n\n        vec2 t = Po(i,0).xy;\n        float g = texture(iChannel1, fract(uv + texel * vec2(i,0))).x;\n        \n        P1 += vec2(p_x1[index], p_y1[index]) * t;\n        P2 += vec2(p_x2[index], p_y2[index]) * t;\n        P3 += vec2(p_x3[index], p_y3[index]) * t;\n        \n        Gw += g_x[index];\n        G  += g_x[index] * g;\n    }\n    \n    G /= Gw;\n    \n    if(reset()) {\n        fragColor = vec4(0);\n    } else {\n        fragColor = vec4(pack(P1),pack(P2),pack(P3), G);\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "bool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 texel = 1.0 / iResolution.xy;\n    \n    float p_y3[13] = float[](-1.0391083e-001, -3.4489894e-001, -4.8179728e-001, -3.1508410e-001,  1.1805352e-001,  1.1920299e-001, -1.4625093e-001,  1.1920299e-001,  1.1805352e-001, -3.1508410e-001, -4.8179728e-001, -3.4489894e-001, -1.0391083e-001);\n \tfloat p_y2[13] = float[](2.6484959e-003, -4.4125709e-003, -6.8390049e-002, -2.5511910e-001, -5.5398879e-001, -1.2936001e-001, 4.6167731e-001, -1.2936001e-001, -5.5398879e-001, -2.5511910e-001, -6.8390049e-002, -4.4125709e-003, 2.6484959e-003);\n    float p_y1[13] = float[](1.9000778e-006, -2.0540590e-003, -1.3499238e-002, -5.1257182e-002, -1.5871959e-001, -4.7194022e-001, -7.0606907e-001, -4.7194022e-001, -1.5871959e-001, -5.1257182e-002, -1.3499238e-002, -2.0540590e-003,  1.9000778e-006);\n\n    float p_x3[13] = float[](3.7276962e-001,  5.4995743e-001,  2.4023362e-001, -7.8265086e-004,  1.8311873e-002, -2.3270335e-002, -1.0109051e-055,  2.3270335e-002, -1.8311873e-002,  7.8265088e-004, -2.4023362e-001, -5.4995743e-001, -3.7276962e-001);\n    float p_x2[13] = float[](5.2398670e-002,  4.2486224e-002, -1.0892533e-001, -3.3953004e-001, -5.0984393e-001,  3.2918550e-001,  0.0, -3.2918550e-001,  5.0984393e-001,  3.3953004e-001,  1.0892533e-001, -4.2486224e-002, -5.2398670e-002);\n    float p_x1[13] = float[](6.2750203e-003, -1.6414278e-003, -4.3498466e-002, -1.3135171e-001, -3.0484343e-001, -6.2280256e-001, 0.0, 6.2280256e-001, 3.0484343e-001, 1.3135171e-001, 4.3498466e-002, 1.6414278e-003, -6.2750203e-003);\n        \n    float s_i[3] = float[](  5.2045614e-001, 4.5787111e-002, 5.3607463e-003);\n    \n    float g_x[13] = float[](1.8154960e-002, 5.1439053e-002, 1.1757498e-001, 2.2045309e-001, 3.4292702e-001, 4.4580513e-001, \n         4.8633287e-001, 4.4580513e-001, 3.4292702e-001, 2.2045309e-001, 1.1757498e-001, 5.1439053e-002, 1.8154960e-002);  \n\n    #define RANGE 6\n    \n    #define Po(m,n) texture(iChannel0, fract(uv + texel * vec2(m,n)))\n    \n    vec2 P = vec2(0);\n    float G = 0.0;\n    float Gw = 0.0;\n    for (int i = -RANGE; i <= RANGE; i++) {\n        int index = RANGE + i;\n        \n        vec4 tx = Po(0,i);\n        vec2 t1 = unpack(tx.x);\n        vec2 t2 = unpack(tx.y);\n        vec2 t3 = unpack(tx.z);\n\n        float g = tx.w;\n        \n        P += s_i[0] * vec2(p_x1[index], p_y1[index]).yx * t1;\n        P += s_i[1] * vec2(p_x2[index], p_y2[index]).yx * t2;\n        P += s_i[2] * vec2(p_x3[index], p_y3[index]).yx * t3;\n        Gw += g_x[index];\n        G  += g_x[index] * g;\n    }\n    \n    G /= Gw;\n\n    if(reset()) {\n        fragColor = vec4(0);\n    } else {\n        fragColor = vec4(-(P.x + P.y) + G);\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// For normalized fixed-point packing\n//#define unpack(x) unpackSnorm2x16(floatBitsToUint(x))\n//#define pack(x) uintBitsToFloat(packSnorm2x16(x))\n\n#define pack(d) uintBitsToFloat(packHalf2x16(d))\n#define unpack(d) unpackHalf2x16(floatBitsToUint(d))\n\n\n// contrast\n#define SIGMOID_CONTRAST 20.0\n\nvec3 contrast(vec3 x) {\n\treturn 1.0 / (1.0 + exp(-SIGMOID_CONTRAST * (x - 0.5)));    \n}\n\nvec3 normz(vec3 x) {\n\treturn x == vec3(0) ? vec3(0) : normalize(x);\n}\n\n// Begin IQ's simplex noise:\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\n// End IQ's simplex noise\n\n\n// GGX from noby's Goo shader https://www.shadertoy.com/view/lllBDM\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\nfloat ggx(vec3 n, vec3 v, vec3 l, float rough, float f0){\n    float alpha = rough*rough;\n    vec3 h = normalize(v+l);\n    float dnl = clamp(dot(n,l), 0.0, 1.0);\n    float dnv = clamp(dot(n,v), 0.0, 1.0);\n    float dnh = clamp(dot(n,h), 0.0, 1.0);\n    float dlh = clamp(dot(l,h), 0.0, 1.0);\n    float f, d, vis;\n    float asqr = alpha*alpha;\n    const float pi = 3.14159;\n    float den = dnh*dnh*(asqr-1.0)+1.0;\n    d = asqr/(pi * den * den);\n    dlh = pow(1.0-dlh, 5.0);\n    f = f0 + (1.0-f0)*dlh;\n    float k = alpha/1.0;\n    vis = G1V(dnl, k)*G1V(dnv, k);\n    float spec = dnl * d * f * vis;\n    return spec;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}