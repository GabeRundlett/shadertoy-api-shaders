{
    "Shader": {
        "info": {
            "date": "1587482652",
            "description": "I referenced Truchet Tiling from The Art of Code.\nhttps://www.youtube.com/watch?v=2R7h76GoIJM",
            "flags": 0,
            "hasliked": 0,
            "id": "WsSyDt",
            "likes": 23,
            "name": "unconnected pipes",
            "published": 3,
            "tags": [
                "raymarching",
                "truchet",
                "pipes"
            ],
            "usePreview": 0,
            "username": "yuntaRobo",
            "viewed": 642
        },
        "renderpass": [
            {
                "code": "const float PI = 3.1415926;\nconst float E = 0.005;\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3 = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\nmat2 rotate2D(float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(c, s, -s, c);\n}\n\nvec3 rotate(vec3 p)\n{\n    p.xz *= rotate2D(iTime * 0.2);\n    p.yz *= rotate2D(0.5);\n    return p;\n}\n\nfloat deBlock(vec3 p)\n{\n    vec3 pb = p;\n\n    p.xz += 0.5;\n\tvec2 q = vec2(length(p.xz) - 0.5, p.y);\n\tfloat d = length(q) - 0.12;\n\t\n\tp = pb;\n\tp.yz -= 0.5;\n\tq = vec2(length(p.yz) - 0.5, p.x);\n\td = min(d, length(q) - 0.12);\n\t\n\tp = pb;\n\tp.xy -= vec2(0.5, -0.5);\n\tq = vec2(length(p.xy) - 0.5, p.z);\n\td = min(d, length(q) - 0.12);\n\t\n\td = abs(d) - 0.0125;\n\t\n\treturn d;\n}\n\nvec2 de(vec3 p)\n{\n    p = rotate(p);\n    \n    vec3 pb = p;\n    \n    vec3 id = floor(p);\n    p = fract(p) - 0.5;\n    \n    vec3 r = hash33(id);\n    if (r.x < 0.5)  p.x *= -1.0;\n\tif (r.y < 0.5)\tp.y *= -1.0;\n\tif (r.z < 0.5)\tp.z *= -1.0;\n\n    float d = deBlock(p);\n\tfloat offset = smoothstep(0.45, 0.5, length(p));\n\td -= offset * 0.03;\n    \n    p = pb;\n    d = max(max(d, abs(p.x) - 5.0), abs(p.z) - 5.0);\n    \n    return vec2(d * 0.75, offset);\n}\n\n// iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p)\n{\n    float h = E;\n    vec2 k = vec2(1.0, -1.0);\n    return normalize(\n            k.xyy * de(p + k.xyy * h).x + \n            k.yyx * de(p + k.yyx * h).x + \n            k.yxy * de(p + k.yxy * h).x + \n            k.xxx * de(p + k.xxx * h).x\n        );\n}\n\nfloat ao(Ray ray)\n{\n    float d = 0.0;\n    d += de(ray.pos + ray.dir * 1.0).x;\n    d += de(ray.pos + ray.dir * 2.0).x;\n    d += de(ray.pos + ray.dir * 3.0).x;\n    d += de(ray.pos + ray.dir * 4.0).x;\n    d += de(ray.pos + ray.dir * 5.0).x;\n    return pow(d / 15.0, 2.0);\n}\n\nfloat noiseValue3D(vec3 p, float div)\n{\n    p *= div;\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    float r1 = hash13((i + vec3(0.0, 0.0, 0.0)));\n    float r2 = hash13((i + vec3(1.0, 0.0, 0.0)));\n    float r3 = hash13((i + vec3(0.0, 1.0, 0.0)));\n    float r4 = hash13((i + vec3(1.0, 1.0, 0.0)));\n    float r5 = hash13((i + vec3(0.0, 0.0, 1.0)));\n    float r6 = hash13((i + vec3(1.0, 0.0, 1.0)));\n    float r7 = hash13((i + vec3(0.0, 1.0, 1.0)));\n    float r8 = hash13((i + vec3(1.0, 1.0, 1.0)));\n    return mix(\n            mix(mix(r1, r2, smoothstep(0.0, 1.0, f.x)), mix(r3, r4, smoothstep(0.0, 1.0, f.x)), smoothstep(0.0, 1.0, f.y)),\n            mix(mix(r5, r6, smoothstep(0.0, 1.0, f.x)), mix(r7, r8, smoothstep(0.0, 1.0, f.x)), smoothstep(0.0, 1.0, f.y)),\n            smoothstep(0.0, 1.0, f.z)\n        );\n}\nfloat noiseValueFbm3D(vec3 p, float div, int octaves, float amplitude)\n{\n    float o = 0.0;\n    float fbm_max = 0.0;\n    for(int i = 0; i >= 0; i++)\n    {\n        if(i >= octaves)    break;\n        float a = pow(amplitude, float(i));\n        o += a * noiseValue3D(p, div * pow(2.0, float(i)));\n        fbm_max += a;\n    }\n    return o / fbm_max;\n}\n\nvoid trace(Ray ray, inout vec3 color, float md)\n{\n    vec3 or = ray.pos;\n    \n    float ad = 0.0;\n    for (float i = 1.0; i > 0.0; i -= 1.0 / 120.0)\n    {\n        vec2 o = de(ray.pos);\n        if (o.x < E)\n        {\n            vec3 n = normal(ray.pos);\n\n            // diffuse\n            vec3 ld = normalize(vec3(1.0, 0.75, 0.5));\n            float l = pow(dot(n, ld) * 0.5 + 0.5, 3.0) * 3.0;\n            \n            // specular\n            vec3 h = normalize(ld + normalize(or - ray.pos));\n            float hn = max(dot(h, n), 0.0);\n            float s1 = pow(hn, 15.0) * 0.75;\n            float s2 = pow(hn, 50.0) * 15.0;\n            \n            // ao\n            Ray rayAo;\n            rayAo.pos = ray.pos;\n            rayAo.dir = n;\n            float a = ao(rayAo);\n            \n            // noise\n            vec3 p = rotate(ray.pos);\n            float ns = noiseValueFbm3D(p, 10.0, 4, 0.5);\n            ns = noiseValueFbm3D(p + vec3(ns), 10.0, 4, 0.5);\n\n            // color\n            color += mix(\n                    vec3(0.01, 0.1, 1.0) + s2 * ns * ns * ns, \n                    (mix(vec3(0.2, 0.2, 0.2), vec3(0.15, 0.15, 0.3), ns) + s1) * max(ns, 0.35), \n                    smoothstep(0.8, 1.0, 1.0 - o.y)\n                ) * l * a;\n            \n//            color = n * 0.5 + 0.5;\n//            color = vec3(a);\n\n            return;\n        }\n\n        ray.pos += ray.dir * o.x;\n        ad = ad + o.x;\n        if (ad > md)\n        {\n            break;\n        }\n    }\n\n    // background\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // view\n    vec3 view = vec3(0.0, 0.0, 10.0);\n    vec3 at = normalize(vec3(0.0, 0.0, 0.0) - view);\n    vec3 right = normalize(cross(at, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, at);\n    float focallength = 1.75;\n    \n    // ray\n    Ray ray;\n    ray.pos = view;\n    ray.dir = normalize(right * p.x + up * p.y + at * focallength);\n\n    // ray marching\n    trace(ray, color, 20.0);\n\n    // cheap tonemapping\n    // https://www.desmos.com/calculator/adupt0spl8\n    float k = 0.75;\n    color = mix(color, 1.0 - exp(-(color - k) / (1.0 - k)) * (1.0 - k), step(k, color));\n\n    // gamma correction\n    color = pow(color, vec3(0.454545));\n\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}