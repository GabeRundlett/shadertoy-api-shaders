{
    "Shader": {
        "info": {
            "date": "1615498263",
            "description": "I counldn't resist to merge these two amazing shaders. Where the River Goes by P_Malin https://www.shadertoy.com/view/Xl2XRW  and a modified version of Gijs Demo : Shadertoy Music Channel: https://www.shadertoy.com/view/4dc3zH",
            "flags": 96,
            "hasliked": 0,
            "id": "wlVyWG",
            "likes": 16,
            "name": "FFT -  where the river flows 2",
            "published": 3,
            "tags": [
                "fft",
                "music",
                "piano",
                "soundcloud"
            ],
            "usePreview": 1,
            "username": "MaxGraph",
            "viewed": 716
        },
        "renderpass": [
            {
                "code": "#define FFT_GAIN 2.5;\n//#define FFT_CONTRAST_VIEW\n\nconst float Piano_height = .15;\nconst float Intensity_height = .03;\n\n//Post-processing options\nconst float Sharpness = 25.;\n\n//Blue Key : 261.6 Hz (Key 40,                Middle C)\n//Red  Key : 440   Hz (Key 49, First  A after Middle C)\n\nconst float ATone     = 0.0370;       //so 0.0370 texture space is 440Hz(found by trial-and-error)\nconst float ATone2     = 0.0390;       //so 0.0370 texture space is 440Hz(found by trial-and-error)\nconst float ATone3     = 0.0420;       //so 0.0370 texture space is 440Hz(found by trial-and-error)\n\nconst float Semitone  = 1.05946309436; //12 notes between an octave, octave is 2, so a semitone is 2^(1/12)\n\nfloat KeyToFrequency(int n){\n    return pow(Semitone,float(n-49))*440.;\n}\n\nfloat FrequencyToTexture(float Frequency){\n    if (Frequency>=300.0) {\n        return Frequency/440.*ATone;\n    } else if ((Frequency>=130.0) && (Frequency<300.0)) {\n        return Frequency/440.*ATone2;\n    } else{\n        return Frequency/440.*ATone3;\n    }\n}\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nmat3 get_formants(int key){\n    float Frequency = KeyToFrequency(key);\n    float Frequency_up1 = KeyToFrequency(key+1);\n    float Frequency_up2 = KeyToFrequency(key+2);\n    float Frequency_down1 = KeyToFrequency(key-1);\n    float Frequency_down2 = KeyToFrequency(key-2);\n    float Frequency_over1 = KeyToFrequency(key+12);\n    float Frequency_over2 = KeyToFrequency(key+17);\n    float Frequency_lower1 = KeyToFrequency(key-12);\n\n    float Amplitude = texture(iChannel0,vec2(FrequencyToTexture(Frequency),.05)).x;\n    float Amplitude_up1 = texture(iChannel0,vec2(FrequencyToTexture(Frequency_up1),.05)).x;\n    float Amplitude_up2 = texture(iChannel0,vec2(FrequencyToTexture(Frequency_up2),.05)).x;\n    float Amplitude_down1 = texture(iChannel0,vec2(FrequencyToTexture(Frequency_down1),.05)).x;\n    float Amplitude_down2 = texture(iChannel0,vec2(FrequencyToTexture(Frequency_down2),.05)).x;\n    float Amplitude_over1 = texture(iChannel0,vec2(FrequencyToTexture(Frequency_over1),.05)).x;\n    float Amplitude_over2 = texture(iChannel0,vec2(FrequencyToTexture(Frequency_over2),.05)).x;\n    float Amplitude_lower1 = texture(iChannel0,vec2(FrequencyToTexture(Frequency_lower1),.05)).x;\n\n    float Perceived = log(1. + Amplitude*Amplitude*1.)*.3;\n    float Perceived_up1 = log(1. + Amplitude_up1*Amplitude_up1*1.)*.3;\n    float Perceived_up2 = log(1. + Amplitude_up2*Amplitude_up2*1.)*.3;\n    float Perceived_down1 = log(1. + Amplitude_down1*Amplitude_down1*1.)*.3;\n    float Perceived_down2 = log(1. + Amplitude_down2*Amplitude_down2*1.)*.3;\n    float Perceived_over1 = log(1. + Amplitude_over1*Amplitude_over1*1.)*.3;\n    float Perceived_over2 = log(1. + Amplitude_over2*Amplitude_over2*1.)*.3; \n    float Perceived_lower1 = log(1. + Amplitude_lower1*Amplitude_lower1*1.)*.3; \n    return mat3(vec3(Amplitude, Perceived, Perceived_up1),\n                vec3(Perceived_up2, Perceived_over1,Perceived_over2),\n                vec3(Perceived_down1, Perceived_down2, Perceived_lower1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n        vec3 Color = vec3(0.0);\n        vec3 color2 = vec3(0.0);\n\t\tvec2 Scaled     = fragCoord.xy/iResolution.xy;\n        #ifdef RIVER_BACKGROUND\n        Color = texture(iChannel1,Scaled.xy).rgb;\n        #else\n        Color = hsv2rgb_smooth((0.25+vec3(0.45*Scaled.y)));\n        #endif\n    //Piano\n        int   Key       = 1+int(Scaled.x*87.);//1 to 88 (full piano)\n        int   Note      = Key%12;//A to G(Octave)\n\n    //Sound\n\n    \n    //Music Visualization\n      //vec3  Color     = vec3(Amplitude/(Scaled.y-Piano_height));\n      //vec3  Color     = vec3(.01/abs(Scaled.y-Piano_height-Amplitude));\n      //vec3  Color     = vec3(0.4,0.3,0.7)*smoothstep(0.01,0.,Scaled.y-Piano_height-Perceived);\n      //vec3  Color     = vec3(Amplitude);\n      //vec3  Color     = vec3(Amplitude-Scaled.y+Piano_height);\n      mat3 formants = get_formants(Key);\n      float amp = formants[0].x;\n      float org = formants[0].y;\n      float up1 = formants[0].z;\n      float up2 = formants[1].x;\n      float over1 = formants[1].y;\n      float over2 = formants[1].z;\n      float down1 = formants[2].x;\n      float down2 = formants[2].y;\n      float lower1 = formants[2].z;\n      \n      vec3 amp3 = vec3(smoothstep(0.0,1.0,1.0-amp),0.75,0.75);\n      float perceived_color = org*FFT_GAIN;\n      color2 = 1.95*hsv2rgb_smooth((amp3))*smoothstep(0.01,0.,Scaled.y-Piano_height-perceived_color*0.85)-Intensity_height;\n            \n      \n      float threshold = 1.0-0.75*cos(fragCoord.x*0.0075-0.75);\n    //Piano Drawing\n        bool second_filter = false;\n        bool octave_filter = false;\n        if (Key>=40){\n            second_filter =(org>up1+org*0.05*Scaled.x/4.0)&&(org>down1+org*0.05*Scaled.x/4.0)&&(org>0.05);\n        } else {\n            second_filter =(org>up1)&&(org>down1);\n        }\n        if (Key>=60){\n            octave_filter =(org>over1+org*0.8*Scaled.x/4.0)&&(org>over2+org*0.8*Scaled.x/4.0)&&(org>lower1+org*0.8*Scaled.x/4.0)&&(over1>0.06);\n        } else if (Key>=40){\n            octave_filter =(org>over1+org*0.2*Scaled.x/4.0)&&(org>over2+org*0.2*Scaled.x/4.0)&&(org>lower1+org*0.2*Scaled.x/4.0)&&(over1>0.06);\n        } else {\n            octave_filter = (org>over1+org*0.1*Scaled.x/4.0)&&(org>over2+org*0.1*Scaled.x/4.0)&&(over1>0.04);\n        }\n        if(Scaled.y<Piano_height){\n            //white keys\n            Color = vec3(1);\n\n            //black keys\n            if(Note==0||Note==2||Note==5||Note==7||Note==10){\n                if ((Scaled.y<Piano_height)&&(Scaled.y>Piano_height/4.0)){\n                    Color = vec3(.1);\n                } else {\n                    Color = vec3(1.);\n                }\n            }\n\n            //special keys\n            if (second_filter && octave_filter) {\n                vec3 rgb_color = hsv2rgb_smooth(vec3(amp,1.0,amp));\n                //Color = rgb_color;\n                if(Note==0||Note==2||Note==5||Note==7||Note==10){\n                    if ((Scaled.y<Piano_height)&&(Scaled.y>Piano_height/4.0)){\n                        Color = rgb_color;\n                    } else {\n                        Color = vec3(1.);\n                    }\n                } else {\n                    Color = rgb_color;\n                }\n            }\n            //if(Key==40) Color = vec3(.5, .5, 1.);\n            //if(Key==49) Color = vec3(1., .5, .5);\n        } else if (Scaled.y<Intensity_height+Piano_height){\n            if (second_filter && octave_filter) {\n                Color = vec3(.5, .5, 1.0);\n            } else {\n                Color = vec3(.2, .2, .7);\n            }\n        } else {\n            //if (Key==60){\n            //    Color = max(0.5*Color,0.5*color2);\n            //}\n            if (second_filter && octave_filter){\n                Color = max(Color,color2);\n            } else {\n                #ifdef FFT_CONTRAST_VIEW\n                Color = max(Color,0.5*color2);\n                #else\n                Color = max(Color,color2);\n                #endif\n            }\n        }\n\n        //float threshold = 1.0-0.75*cos(fragCoord.x*0.0075-0.75);\n        //Color += vec3(threshold);\n\tfragColor = vec4(Color,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 25316,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/awfulpianosound/yiruma-river-flows-in-you"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Where the River Goes\n// @P_Malin\n\n// What started as a hacked flow and advection experiment turned into something nice.\n\n// Placeholder audio https://www.youtube.com/watch?v=gmar4gh5nIw suggested by @qthund on twitter\n\n//#define ENABLE_ULTRA_QUALITY\n\n#define ENABLE_WATER\n//#define ENABLE_FOAM\n#define ENABLE_WATER_RECEIVE_SHADOW\n//#define ENABLE_CONE_STEPPING\n\n\n// Textureless version\n//#define ENABLE_NIMITZ_TRIANGLE_NOISE\n\n//#define ENABLE_LANDSCAPE_RECEIVE_SHADOW\n\n//#define ENABLE_SCREENSHOT_MODE\nconst float k_screenshotTime = 13.0;\n\n#if defined(ENABLE_SCREENSHOT_MODE) || defined(ENABLE_ULTRA_QUALITY)\n#define ENABLE_SUPERSAMPLE_MODE\n#endif\n\n#ifndef ENABLE_SCREENSHOT_MODE\n#ifdef ENABLE_ULTRA_QUALITY\nconst int k_raymarchSteps = 96;\nconst int k_fmbSteps = 6;\nconst int k_superSampleCount = 6;\n#else\nconst int k_raymarchSteps = 64;\nconst int k_fmbSteps = 3;\n#endif\n#else\nconst int k_raymarchSteps = 96;\nconst int k_fmbSteps = 5;\nconst int k_superSampleCount = 10;\n#endif\n\nconst int k_fmbWaterSteps = 4;\n\n#define OBJ_ID_SKY 0.0\n#define OBJ_ID_GROUND 1.0\n\nfloat g_fTime;\n\nconst vec3 g_vSunDir = vec3( -1.0, 0.7, 0.25 );\nvec3 GetSunDir() { return normalize( g_vSunDir ); }\n\nconst vec3 g_sunColour = vec3( 1.0, 0.85, 0.5 ) * 5.0;\nconst vec3 g_skyColour = vec3( 0.1, 0.5, 1.0 ) * 1.0;\n\nconst vec3 k_bgSkyColourUp = g_skyColour * 4.0;\nconst vec3 k_bgSkyColourDown = g_skyColour * 6.0;\n\nconst vec3 k_envFloorColor = vec3(0.3, 0.2, 0.2);\n\nconst vec3 k_vFogExt = vec3(0.01, 0.015, 0.015) * 3.0;\nconst vec3 k_vFogIn = vec3(1.0, 0.9, 0.8) * 0.015;\n\n\nconst float k_fFarClip = 20.0;\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    // https://www.shadertoy.com/view/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n\t//return fract(sin(n)*43758.5453);\n}\n\nvec2 Hash2( float p ) \n{\n    // https://www.shadertoy.com/view/4djSRW - Dave Hoskins\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\nfloat FBM( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<k_fmbSteps; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\nfloat FBM_Simple( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<3; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\nvec3 SmoothNoise_DXY(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tvec2 dt = 6.0 * f - 6.0 * f2;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\tfloat du = dt.x;\t\n\tfloat dv = dt.y;\t\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n\tfloat dx = (b-a)*du + (a-b+d-c)*du*v;\n\tfloat dy = (c-a)*dv + (a-b+d-c)*u*dv;    \n    \n    return vec3(dx, dy, res);\n}\n\nvec3 FBM_DXY( vec2 p, vec2 flow, float ps, float df ) {\n\tvec3 f = vec3(0.0);\n    float tot = 0.0;\n    float a = 1.0;\n    //flow *= 0.6;\n    for( int i=0; i<k_fmbWaterSteps; i++)\n    {\n        p += flow;\n        flow *= -0.75; // modify flow for each octave - negating this is fun\n        vec3 v = SmoothNoise_DXY( p );\n        f += v * a;\n        p += v.xy * df;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\nfloat GetRiverMeander( const float x )\n{\n    return sin(x * 0.3) * 1.5;\n}\n\nfloat GetRiverMeanderDx( const float x )\n{\n    return cos(x * 0.3) * 1.5 * 0.3;\n}\n\nfloat GetRiverBedOffset( const vec3 vPos )\n{\n    float fRiverBedDepth = 0.3 + (0.5 + 0.5 * sin( vPos.x * 0.001 + 3.0)) * 0.4;\n    float fRiverBedWidth = 2.0 + cos( vPos.x * 0.1 ) * 1.0;;\n    \n    float fRiverBedAmount = smoothstep( fRiverBedWidth, fRiverBedWidth * 0.5, abs(vPos.z - GetRiverMeander(vPos.x)) );\n        \n    return fRiverBedAmount * fRiverBedDepth;    \n}\n\nfloat GetTerrainHeight( const vec3 vPos )\n{    \n    float fbm = FBM( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    \n    fTerrainHeight -= GetRiverBedOffset(vPos);\n        \n    return fTerrainHeight;\n}\n\nfloat GetTerrainHeightSimple( const vec3 vPos )\n{    \n    float fbm = FBM_Simple( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    \n    fTerrainHeight -= GetRiverBedOffset(vPos);\n        \n    return fTerrainHeight;\n}\n\n\nfloat GetSceneDistance( const vec3 vPos )\n{\n    return vPos.y - GetTerrainHeight( vPos );\n}\n\nfloat GetFlowDistance( const vec2 vPos )\n{\n    return -GetTerrainHeightSimple( vec3( vPos.x, 0.0, vPos.y ) );\n}\n\nvec2 GetBaseFlow( const vec2 vPos )\n{\n    return vec2( 1.0, GetRiverMeanderDx(vPos.x) );\n}\n\nvec2 GetGradient( const vec2 vPos )\n{\n    vec2 vDelta = vec2(0.01, 0.00);\n    float dx = GetFlowDistance( vPos + vDelta.xy ) - GetFlowDistance( vPos - vDelta.xy );\n    float dy = GetFlowDistance( vPos + vDelta.yx ) - GetFlowDistance( vPos - vDelta.yx );\n    return vec2( dx, dy );\n}\n\nvec3 GetFlowRate( const vec2 vPos )\n{\n    vec2 vBaseFlow = GetBaseFlow( vPos );\n\n    vec2 vFlow = vBaseFlow;\n    \n    float fFoam = 0.0;\n\n\tfloat fDepth = -GetTerrainHeightSimple( vec3(vPos.x, 0.0, vPos.y) );\n    float fDist = GetFlowDistance( vPos );\n    vec2 vGradient = GetGradient( vPos );\n    \n    vFlow += -vGradient * 40.0 / (1.0 + fDist * 1.5);\n    vFlow *= 1.0 / (1.0 + fDist * 0.5);\n\n#if 1\n    float fBehindObstacle = 0.5 - dot( normalize(vGradient), -normalize(vFlow)) * 0.5;\n    float fSlowDist = clamp( fDepth * 5.0, 0.0, 1.0);\n    fSlowDist = mix(fSlowDist * 0.9 + 0.1, 1.0, fBehindObstacle * 0.9);\n    //vFlow += vGradient * 10.0 * (1.0 - fSlowDist);\n    fSlowDist = 0.5 + fSlowDist * 0.5;\n    vFlow *= fSlowDist;\n#endif    \n    \n    float fFoamScale1 =0.5;\n    float fFoamCutoff = 0.4;\n    float fFoamScale2 = 0.35;\n    \n    fFoam = abs(length( vFlow )) * fFoamScale1;// - length( vBaseFlow ));\n\tfFoam += clamp( fFoam - fFoamCutoff, 0.0, 1.0 );\n    //fFoam = fFoam* fFoam;\n    fFoam = 1.0 - pow( fDist, fFoam * fFoamScale2 );\n    //fFoam = fFoam / fDist;\n    return vec3( vFlow * 0.6, fFoam  );\n}\n\nvec4 SampleWaterNormal( vec2 vUV, vec2 vFlowOffset, float fMag, float fFoam )\n{    \n    vec2 vFilterWidth = max(abs(dFdx(vUV)), abs(dFdy(vUV)));\n  \tfloat fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);\n    \n    float fScale = (1.0 / (1.0 + fFilterWidth * fFilterWidth * 2000.0));\n    float fGradientAscent = 0.25 + (fFoam * -1.5);\n    vec3 dxy = FBM_DXY(vUV * 20.0, vFlowOffset * 20.0, 0.75 + fFoam * 0.25, fGradientAscent);\n    fScale *= max(0.25, 1.0 - fFoam * 5.0); // flatten normal in foam\n    vec3 vBlended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, fMag, dxy.y) ), fScale );\n    return vec4( normalize( vBlended ), dxy.z * fScale );\n}\n\nfloat SampleWaterFoam( vec2 vUV, vec2 vFlowOffset, float fFoam )\n{\n    float f =  FBM_DXY(vUV * 30.0, vFlowOffset * 50.0, 0.8, -0.5 ).z;\n    float fAmount = 0.2;\n    f = max( 0.0, (f - fAmount) / fAmount );\n    return pow( 0.5, f );\n}\n    \n\nvec4 SampleFlowingNormal( const vec2 vUV, const vec2 vFlowRate, const float fFoam, const float time, out float fOutFoamTex )\n{\n    float fMag = 2.5 / (1.0 + dot( vFlowRate, vFlowRate ) * 5.0);\n    float t0 = fract( time );\n    float t1 = fract( time + 0.5 );\n    \n    float i0 = floor( time );\n    float i1 = floor( time + 0.5 );\n    \n    float o0 = t0 - 0.5;\n    float o1 = t1 - 0.5;\n    \n    vec2 vUV0 = vUV + Hash2(i0);\n    vec2 vUV1 = vUV + Hash2(i1);\n    \n    vec4 sample0 = SampleWaterNormal( vUV0, vFlowRate * o0, fMag, fFoam );\n    vec4 sample1 = SampleWaterNormal( vUV1, vFlowRate * o1, fMag, fFoam );\n\n    float weight = abs( t0 - 0.5 ) * 2.0;\n    //weight = smoothstep( 0.0, 1.0, weight );\n\n    float foam0 = SampleWaterFoam( vUV0, vFlowRate * o0 * 0.25, fFoam );\n    float foam1 = SampleWaterFoam( vUV1, vFlowRate * o1 * 0.25, fFoam );\n    \n    vec4 result=  mix( sample0, sample1, weight );\n    result.xyz = normalize(result.xyz);\n\n    fOutFoamTex = mix( foam0, foam1, weight );\n\n    return result;\n}\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 2.0);\n\n\treturn vDir;\n}\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.8;\n\t\n\tfloat fShade = mix( 1.0, 1.0 - kStrength, fDist );\t\n\n\treturn vInput * fShade;\n}\n\nvec3 Tonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );\n}\n\nstruct Intersection\n{\n    float m_dist;\n    float m_objId;\n    vec3 m_pos;\n};\n    \nvoid RaymarchScene( vec3 vRayOrigin, vec3 vRayDir, out Intersection intersection )\n{\n    float stepScale = 1.0;\n#ifdef ENABLE_CONE_STEPPING\n    vec2 vRayProfile = vec2( sqrt(dot(vRayDir.xz, vRayDir.xz) ), vRayDir.y );\n    vec2 vGradVec = normalize( vec2( 1.0, 2.0 ) ); // represents the biggest gradient in our heightfield\n    vec2 vGradPerp = vec2( vGradVec.y, -vGradVec.x );\n\n    float fRdotG = dot( vRayProfile, vGradPerp );\n    float fOdotG = dot( vec2(0.0, 1.0), vGradPerp );\n\n    stepScale = -fOdotG / fRdotG;\n\n    if ( stepScale < 0.0 )\n    {\n        intersection.m_objId = OBJ_ID_SKY;\n        intersection.m_dist = k_fFarClip;\n        return;\n    }\n#endif\n    \n    intersection.m_dist = 0.01;\n    intersection.m_objId = OBJ_ID_SKY;\n    \n    float fSceneDist = 0.0;\n    \n    float oldT = 0.01;\n    for( int iter = 0; iter < k_raymarchSteps; iter++ )\n    {\n        vec3 vPos = vRayOrigin + vRayDir * intersection.m_dist;\n      \n        // into sky - early out\n        if ( vRayDir.y > 0.0 )\n        {\n            if( vPos.y > 1.0 )\n            {\n                intersection.m_objId = OBJ_ID_SKY;\n                intersection.m_dist = k_fFarClip;\n                break;\n            }\n        }\n\n      \n        fSceneDist = GetSceneDistance( vPos );\n\n        oldT = intersection.m_dist;\n        intersection.m_dist += fSceneDist * stepScale;\n                \n        intersection.m_objId = OBJ_ID_GROUND;\n        if ( fSceneDist <= 0.01 )\n        {\n            break;\n        }\n\n        if ( intersection.m_dist > k_fFarClip )\n        {\n            intersection.m_objId = OBJ_ID_SKY;\n            intersection.m_dist = k_fFarClip;\n            break;\n        }        \n\n        \n    }    \n    \n    intersection.m_pos = vRayOrigin + vRayDir * intersection.m_dist;\n}\n\nvec3 GetSceneNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n\n    vec3 vDir1 = vec3( 1.0, 0.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, 0.0,  1.0);\n    vec3 vDir3 = vec3(-1.0, 0.0, -1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n\n    vec3 vPos1 = vPos + vOffset1;\n    vec3 vPos2 = vPos + vOffset2;\n    vec3 vPos3 = vPos + vOffset3;\n \n    float f1 = GetSceneDistance( vPos1 );\n    float f2 = GetSceneDistance( vPos2 );\n    float f3 = GetSceneDistance( vPos3 );\n    \n    vPos1.y -= f1;\n    vPos2.y -= f2;\n    vPos3.y -= f3;\n    \n    vec3 vNormal = cross( vPos1 - vPos2, vPos3 - vPos2 );\n    \n    return normalize( vNormal );\n}\n\n\nvoid TraceWater( vec3 vRayOrigin, vec3 vRayDir, out Intersection intersection )\n{\n \tintersection.m_dist = k_fFarClip;\n    \n    float t = -vRayOrigin.y / vRayDir.y;\n    if ( t > 0.0 )\n    {\n        intersection.m_dist = t;\n    }\n    \n    intersection.m_pos = vRayOrigin + vRayDir * intersection.m_dist;\n}\n\nstruct Surface\n{\n    vec3 m_pos;\n    vec3 m_normal;\n    vec3 m_albedo;\n    vec3 m_specR0;\n    float m_gloss;\n    float m_specScale;\n};\n    \n#ifdef ENABLE_NIMITZ_TRIANGLE_NOISE\n// https://www.shadertoy.com/view/4ts3z2\n\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y)), tri(p.z+tri(p.x)), tri(p.y+tri(p.x)));}\n\nfloat triNoise(in vec3 p)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=4.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += dg;\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n           \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}    \n#endif\n    \nvoid GetSurfaceInfo( Intersection intersection, out Surface surface )\n{\n    surface.m_pos = intersection.m_pos;\n    surface.m_normal = GetSceneNormal(intersection.m_pos);\n\n#ifdef ENABLE_NIMITZ_TRIANGLE_NOISE\n    vec3 vNoisePos = surface.m_pos * vec3(0.4, 0.3, 1.0);\n\tsurface.m_normal = normalize(surface.m_normal +triNoise(vNoisePos));\n    float fNoise = triNoise(vNoisePos);\n    fNoise = pow( fNoise, 0.15);\n    surface.m_albedo = mix(vec3(.7,.8,.95), vec3(.1, .1,.05), fNoise );    \n#else\n    #if 0\n    surface.m_albedo = texture( iChannel0, intersection.m_pos.xz ).rgb;\n    surface.m_albedo = surface.m_albedo * surface.m_albedo;\n    #else\n    vec3 vWeights = surface.m_normal * surface.m_normal;\n    vec3 col = vec3(0.0);\n    vec3 _sample;\n    _sample = texture( iChannel0, intersection.m_pos.xz ).rgb;\n    col += _sample * _sample * vWeights.y;\n    _sample = texture( iChannel0, intersection.m_pos.xy ).rgb;\n    col += _sample * _sample * vWeights.z;\n    _sample = texture( iChannel0, intersection.m_pos.yz ).rgb;\n    col += _sample * _sample * vWeights.x;\n    col /= vWeights.x + vWeights.y + vWeights.z;\n    surface.m_albedo = col;\n    #endif\n#endif    \n    \n    surface.m_specR0 = vec3(0.001);\n    surface.m_gloss = 0.0;\n    surface.m_specScale = 1.0;\n}\n   \nfloat GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nfloat GetSunShadow( const vec3 vPos )\n{\n    vec3 vSunDir = GetSunDir();\n\n    Intersection shadowInt;\n    float k_fShadowDist = 2.0;\n    RaymarchScene( vPos + vSunDir * k_fShadowDist, -vSunDir, shadowInt );\n    \n    float fShadowFactor = 1.0;\n    if( shadowInt.m_dist < (k_fShadowDist - 0.1) )\n    {\n        fShadowFactor = 0.0;\n    }\n\n    return fShadowFactor;\n}\n\nvoid AddSunLight( Surface surf, const vec3 vViewDir, const float fShadowFactor, inout vec3 vDiffuse, inout vec3 vSpecular )\n{\n    vec3 vSunDir = GetSunDir();\n\n\tvec3 vH = normalize( vViewDir + vSunDir );\n\tfloat fNdotL = clamp(dot(GetSunDir(), surf.m_normal), 0.0, 1.0);\n\tfloat fNdotV = clamp(dot(vViewDir, surf.m_normal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surf.m_normal, vH), 0.0, 1.0);\n    \n    float diffuseIntensity = fNdotL;\n    \n    vDiffuse += g_sunColour * diffuseIntensity * fShadowFactor;\n\t//vDiffuse = fShadowFactor * vec3(100.0);\n\t\n\tfloat alpha = 1.0 - surf.m_gloss;\n\t// D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr / (pi * denom * denom);\n\n\tfloat k = alpha / 2.0;\n\tfloat vis = GIV(fNdotL, k) * GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNdotL;\n\tvSpecular += g_sunColour * fSpecularIntensity * fShadowFactor;\n}\n    \nvoid AddSkyLight( Surface surf, inout vec3 vDiffuse, inout vec3 vSpecular )\n{\n    float skyIntensity = max( 0.0, surf.m_normal.y * 0.3 + 0.7 );\n    vDiffuse += g_skyColour * skyIntensity;       \n}\n\nvec3 GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvec3 GetWaterExtinction( float dist )\n{\n    float fOpticalDepth = dist * 6.0;\n\n    vec3 vExtinctCol = 1.0 - vec3(0.5, 0.4, 0.1);           \n    vec3 vExtinction = exp2( -fOpticalDepth * vExtinctCol );\n    \n    return vExtinction;\n}\n\nvec3 GetSkyColour( vec3 vRayDir )\n{    \n\tvec3 vSkyColour = mix( k_bgSkyColourDown, k_bgSkyColourUp, clamp( vRayDir.y, 0.0, 1.0 ) );\n    float fSunDotV = dot(GetSunDir(), vRayDir);    \n    float fDirDot = clamp(fSunDotV * 0.5 + 0.5, 0.0, 1.0);\n    vSkyColour += g_sunColour * (1.0 - exp2(fDirDot * -0.5)) * 2.0;\n    \n    return vSkyColour;\n}\n\nvec3 GetEnvColour( vec3 vRayDir, float fGloss )\n{\n\treturn mix( k_envFloorColor, k_bgSkyColourUp, clamp( vRayDir.y * (1.0 - fGloss * 0.5) * 0.5 + 0.5, 0.0, 1.0 ) );\n}\n\n\nvec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir, out Intersection intersection )\n{\n    RaymarchScene( vRayOrigin, vRayDir, intersection );        \n\n    if ( intersection.m_objId == OBJ_ID_SKY )\n    {\n        return GetSkyColour( vRayDir );\n    }\n    \n    Surface surface;\n    GetSurfaceInfo( intersection, surface );\n\n    vec3 vIgnore = vec3(0.0);\n    vec3 vResult = vec3(0.0);\n    float fSunShadow = 1.0;\n    AddSunLight( surface, -vRayDir, fSunShadow, vResult, vIgnore );\n    AddSkyLight( surface, vResult, vIgnore);\n    return vResult * surface.m_albedo;\n}\n\nvec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir )\n{\n\tIntersection intersection;\n    return GetRayColour( vRayOrigin, vRayDir, intersection );\n}\n\nvec3 GetSceneColour( const in vec3 vRayOrigin,  const in vec3 vRayDir )\n{\n\tIntersection primaryInt;\n    RaymarchScene( vRayOrigin, vRayDir, primaryInt );\n\n     float fFogDistance = 0.0;\n    vec3 vResult = vec3( 0.0 );\n    \n    float fSunDotV = dot(GetSunDir(), vRayDir);    \n\n    if ( primaryInt.m_objId == OBJ_ID_SKY )\n    {\n        vResult = GetSkyColour( vRayDir );\n        fFogDistance = k_fFarClip;\n    }\n    else\n    {\n        Intersection waterInt;\n        TraceWater( vRayOrigin, vRayDir, waterInt );\n\n        vec3 vReflectRayOrigin;\n        vec3 vSpecNormal;\n        vec3 vTransmitLight;\n\n        Surface specSurface;\n        vec3 vSpecularLight = vec3(0.0);\n\n    #ifdef ENABLE_WATER\n        vec3 vFlowRateAndFoam = GetFlowRate( waterInt.m_pos.xz );\n        vec2 vFlowRate = vFlowRateAndFoam.xy;\n        #ifdef ENABLE_FOAM\n        float fFoam = vFlowRateAndFoam.z;\n        float fFoamScale = 1.5;\n        float fFoamOffset = 0.2;\n        fFoam = clamp( (fFoam - fFoamOffset) * fFoamScale, 0.0, 1.0 );\n        fFoam = fFoam * fFoam * 0.5;\n        #else\n        float fFoam = 0.0;\n        #endif            \n\n        float fWaterFoamTex = 1.0;\n        vec4 vWaterNormalAndHeight = SampleFlowingNormal( waterInt.m_pos.xz, vFlowRate, fFoam, g_fTime, fWaterFoamTex );\n        \n        if( vRayDir.y < -0.01 )\n        {\n            // lie about the water intersection depth\n            waterInt.m_dist -= (0.04 * (1.0 - vWaterNormalAndHeight.w) / vRayDir.y);\n        }\n        \n        if( waterInt.m_dist < primaryInt.m_dist )\n        {\n            fFogDistance = waterInt.m_dist;\n            vec3 vWaterNormal = vWaterNormalAndHeight.xyz;\n\n            vReflectRayOrigin = waterInt.m_pos;\n            vSpecNormal = vWaterNormal;\n\n            vec3 vRefractRayOrigin = waterInt.m_pos;\n            vec3 vRefractRayDir = refract( vRayDir, vWaterNormal, 1.0 / 1.3333 );\n\n            Intersection refractInt;\n            vec3 vRefractLight = GetRayColour( vRefractRayOrigin, vRefractRayDir, refractInt ); // note : dont need sky\n\n            float fEdgeAlpha = clamp( (1.0 + vWaterNormalAndHeight.w * 0.25) - refractInt.m_dist * 10.0, 0.0, 1.0 );\n            fFoam *= 1.0 - fEdgeAlpha;\n            \n            // add extra extinction for the light travelling to the point underwater\n            vec3 vExtinction = GetWaterExtinction( refractInt.m_dist + abs( refractInt.m_pos.y ) );\n\n            specSurface.m_pos = waterInt.m_pos;\n            specSurface.m_normal = normalize( vWaterNormal + GetSunDir() * fFoam ); // would rather have SSS for foam\n            specSurface.m_albedo = vec3(1.0);\n            specSurface.m_specR0 = vec3( 0.01, 0.01, 0.01 );\n\n            vec2 vFilterWidth = max(abs(dFdx(waterInt.m_pos.xz)), abs(dFdy(waterInt.m_pos.xz)));\n  \t\t\tfloat fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);\n            float fGlossFactor = exp2( -fFilterWidth * 0.3 );\n            specSurface.m_gloss = 0.99 * fGlossFactor;            \n            specSurface.m_specScale = 1.0;\n            \n            vec3 vSurfaceDiffuse = vec3(0.0);\n\n            float fSunShadow = 1.0;\n        #ifdef ENABLE_WATER_RECEIVE_SHADOW\n            fSunShadow = GetSunShadow( waterInt.m_pos );\n        #endif\n            AddSunLight( specSurface, -vRayDir, fSunShadow, vSurfaceDiffuse, vSpecularLight);\n            AddSkyLight( specSurface, vSurfaceDiffuse, vSpecularLight);\n\n            vec3 vInscatter = vSurfaceDiffuse * (1.0 - exp( -refractInt.m_dist * 0.1 )) * (1.0 + fSunDotV);\n            vTransmitLight = vRefractLight.rgb;\n            vTransmitLight += vInscatter;\n            vTransmitLight *= vExtinction;   \n\n\n    #ifdef ENABLE_FOAM\n            float fFoamBlend = 1.0 - pow( fWaterFoamTex, fFoam * 5.0);// * (1.0 - fWaterFoamTex));\n            vTransmitLight = mix(vTransmitLight, vSurfaceDiffuse * 0.8, fFoamBlend );\n            specSurface.m_specScale = clamp(1.0 - fFoamBlend * 4.0, 0.0, 1.0);\n    #endif\n        }\n        else\n    #endif // #ifdef ENABLE_WATER\n        {\n            fFogDistance = primaryInt.m_dist;\n\n            Surface primarySurface;\n            GetSurfaceInfo( primaryInt, primarySurface );\n\n            vSpecNormal = primarySurface.m_normal;\n            vReflectRayOrigin = primaryInt.m_pos;\n            \n            float fWetness = 1.0 - clamp( (vReflectRayOrigin.y + 0.025) * 5.0, 0.0, 1.0);\n            primarySurface.m_gloss = mix( primarySurface.m_albedo.r, 1.0, fWetness );\n            primarySurface.m_albedo = mix( primarySurface.m_albedo, primarySurface.m_albedo * 0.8, fWetness );\n\n            vTransmitLight = vec3(0.0);\n            float fSunShadow = 1.0;\n       #ifdef ENABLE_LANDSCAPE_RECEIVE_SHADOW\n            fSunShadow = GetSunShadow( primaryInt.m_pos );\n       #endif\n            AddSunLight( primarySurface, -vRayDir, fSunShadow, vTransmitLight, vSpecularLight);\n            AddSkyLight( primarySurface, vTransmitLight, vSpecularLight);\n            vTransmitLight *= primarySurface.m_albedo;\n            specSurface = primarySurface;\n        }\n\n        vec3 vReflectRayDir = reflect( vRayDir, vSpecNormal );\n        vec3 vReflectLight = GetRayColour( vReflectRayOrigin, vReflectRayDir );\n\n        vReflectLight = mix( GetEnvColour(vReflectRayDir, specSurface.m_gloss), vReflectLight, pow( specSurface.m_gloss, 40.0) );\n        \n        vec3 vFresnel = GetFresnel( -vRayDir, vSpecNormal, specSurface.m_specR0, specSurface.m_gloss );\n\n        vSpecularLight += vReflectLight;\n        vResult = mix(vTransmitLight, vSpecularLight, vFresnel * specSurface.m_specScale );\n    }\n    \n    \n    if ( fFogDistance >= k_fFarClip )\n    {\n        fFogDistance = 100.0;\n        vResult = smoothstep( 0.9995, 0.9999, fSunDotV ) * g_sunColour * 200.0;\n    }    \n    \n    vec3 vFogColour = GetSkyColour(vRayDir);\n    \n    vec3 vFogExtCol = exp2( k_vFogExt * -fFogDistance );\n    vec3 vFogInCol = exp2( k_vFogIn * -fFogDistance );\n    vResult = vResult*(vFogExtCol) + vFogColour*(1.0-vFogInCol);\n    \n    return vResult;\n}\n\n// Code from https://www.shadertoy.com/view/ltlSWf \nvoid BlockRender(in vec2 fragCoord)\n{\n    const float blockRate = 15.0;\n    const float blockSize = 64.0;\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef RIVER_BACKGROUND\n    g_fTime = iTime;\n\n#ifdef ENABLE_SCREENSHOT_MODE\n    BlockRender( fragCoord.xy );\n    float fBaseTime = k_screenshotTime;\n#else\n    float fBaseTime = iTime;\n#endif\n    g_fTime = fBaseTime;\n    \n    float fCameraTime = g_fTime;\n    \n\t// Static camera locations\n    //fCameraTime = 146.0; // some rocks\n    \n    vec2 vUV = fragCoord.xy / iResolution.xy;\n\n\tvec3 vCameraTarget = vec3(0.0, -0.5, 0.0);\n\n    vCameraTarget.x -= fCameraTime * 0.5;\n    \n    vec3 vCameraPos = vCameraTarget + vec3(0.0, 0.0, 0.0);\n    \n    float fHeading = fCameraTime * 0.1;\n    float fDist = 1.5 - cos(fCameraTime * 0.1 + 2.0) * 0.8;\n    \n    if( iMouse.z > 0.0 )\n    {\n        fHeading = iMouse.x * 10.0 / iResolution.x;\n        fDist = 5.0 - iMouse.y * 5.0 / iResolution.y;\n    }\n    \n    vCameraPos.y += 1.0 + fDist * fDist * 0.01;\n        \n    vCameraPos.x += sin( fHeading ) * fDist;\n    vCameraPos.z += cos( fHeading ) * fDist;\n    \n    vCameraTarget.z += GetRiverMeander( vCameraTarget.x );\n    vCameraPos.z += GetRiverMeander( vCameraPos.x );\n\n    vCameraPos.y = max( vCameraPos.y, GetTerrainHeightSimple( vCameraPos ) + 0.2 );\n    \n    vec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n#ifndef ENABLE_SUPERSAMPLE_MODE\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n#else\n\tvec3 vResult = vec3(0.0);\n    float fTot = 0.0;\n    for(int i=0; i<k_superSampleCount; i++)\n    {\n        g_fTime = fBaseTime + (fTot / 10.0) / 30.0;\n        vec3 vCurrRayDir = vRayDir;\n        vec3 vRandom = vec3( SmoothNoise( fragCoord.xy + fTot ), \n                        SmoothNoise( fragCoord.yx + fTot + 42.0 ),\n                        SmoothNoise( fragCoord.xx + fragCoord.yy + fTot + 42.0 ) ) * 2.0 - 1.0;\n        vRandom = normalize( vRandom );\n        vCurrRayDir += vRandom * 0.001;\n        vCurrRayDir = normalize(vCurrRayDir);\n    \tvResult += GetSceneColour(vRayOrigin, vCurrRayDir);\n        fTot += 1.0;\n    }\n    vResult /= fTot;\n#endif    \n    \n\tvResult = ApplyVignetting( vUV, vResult );\t\n\t\n\tvec3 vFinal = Tonemap(vResult * 3.0);\n\t\n    vFinal = vFinal * 1.1 - 0.1;\n    \n\tfragColor = vec4(vFinal, 1.0);\n    #else\n    fragColor = vec4(vec3(0.0), 1.0);\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define RIVER_BACKGROUND\n\n// the river flows in you: https://soundcloud.com/awfulpianosound/yiruma-river-flows-in-you\n// bach - praeludium: https://soundcloud.com/neilbalfour/prelude-no-1-in-c-major-j-s",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}