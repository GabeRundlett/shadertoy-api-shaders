{
    "Shader": {
        "info": {
            "date": "1463850738",
            "description": "Another view on https://www.shadertoy.com/view/4dVSWR",
            "flags": 0,
            "hasliked": 0,
            "id": "4sVXDz",
            "likes": 22,
            "name": "Candy core  2",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "tdhooper",
            "viewed": 2343
        },
        "renderpass": [
            {
                "code": "// Author: \n// Title: \n\n\n#define PI 3.14159265359\n\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\n\nfloat t;\n//vec2 iResolution = u_resolution;\n//vec2 iMouse = u_mouse;\n\n// #define t u_time\n//#define iResolution u_resolution\n//#define iMouse u_mouse\n\n\n// HG_SDF\n\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n    return dot(p, n) + distanceFromOrigin;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tfloat m = min(a, b);\n\tif ((a < r) && (b < r) ) {\n\t\treturn min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n\t} else {\n\t return m;\n\t}\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif ((-a < r) && (-b < r)) {\n\t\treturn max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n\t} else {\n\t\treturn m;\n\t}\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n// Knighty https://www.shadertoy.com/view/XlX3zB\n\nint Type=5;\n\nvec3 nc,pab,pbc,pca;\nvoid initIcosahedron() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n\tpab=vec3(0.,0.,1.);\n\tpbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n\tpca=vec3(0.,scospin,cospin);\n\tpbc=normalize(pbc);\tpca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n}\n\n// Barycentric to Cartesian \nvec3 bToC(vec3 A, vec3 B, vec3 C, vec3 barycentric) {\n\treturn barycentric.x * A + barycentric.y * B + barycentric.z * C;\n}\n\nvec3 pModIcosahedron(inout vec3 p, int subdivisions) {\n    p = abs(p);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    \n    if (subdivisions > 0) {\n\n        vec3 A = pbc;\n       \tvec3 C = reflect(A, normalize(cross(pab, pca)));\n        vec3 B = reflect(C, normalize(cross(pbc, pca)));\n       \n        vec3 n;\n\n        // Fold in corner A \n        \n        vec3 p1 = bToC(A, B, C, vec3(.5, .0, .5));\n        vec3 p2 = bToC(A, B, C, vec3(.5, .5, .0));\n        n = normalize(cross(p1, p2));\n        pReflect(p, n, 0.);\n        \n        if (subdivisions > 1) {\n\n            // Get corners of triangle created by fold\n\n            A = reflect(A, n);\n            B = p1;\n            C = p2;\n            \n            // Fold in corner A\n\n            p1 = bToC(A, B, C, vec3(.5, .0, .5));\n            p2 = bToC(A, B, C, vec3(.5, .5, .0));\n            n = normalize(cross(p1, p2));\n            pReflect(p, n, 0.);\n            \n\n            // Fold in corner B\n            \n\t\t\tp2 = bToC(A, B, C, vec3(.0, .5, .5));\n            p1 = bToC(A, B, C, vec3(.5, .5, .0));\n            n = normalize(cross(p1, p2));\n            pReflect(p, n, 0.);\n        }\n    }\n\n    return p;\n}\n\nvec3 pRoll(inout vec3 p) {\n    //return p;\n    float s = 5.;\n    float d = 0.01;\n    float a = sin(t * s) * d;\n    float b = cos(t * s) * d;\n    pR(p.xy, a);\n    pR(p.xz, a + b);\n    pR(p.yz, b);\n    return p;\n}\n\nvec3 lerp(vec3 a, vec3 b, float s) {\n\treturn a + (b - a) * s;\n}\n\nfloat face(vec3 p) {\n    // Align face with the xy plane\n\tvec3 rn = normalize(lerp(pca, vec3(0,0,1), 0.5));\n    p = reflect(p, rn);\n\treturn min(\n        fPlane(p, vec3(0,0,-1), -1.4),\n        length(p + vec3(0,0,1.4)) - 0.02\n    );\n}\n\nvec3 planeNormal(vec3 p) {\n    // Align face with the xy plane\n\tvec3 rn = normalize(lerp(pca, vec3(0,0,1), 0.5));\n    return reflect(p, rn);  \n}\nvec3 pSpin(vec3 p) {\n    pR(p.xz, t/2.);\n    pR(p.yz, t/4. + 10.);\n    pR(p.xy, t);\n    return p;\n}\n\nfloat spinningBox(vec3 p) {\n    p = pSpin(p);\n    return fBox(p, vec3(1., 1., 1.));\n}\n\n// float inner(vec3 p) {\n//     //float t = 1.;\n//     int i = int(mod(t/4., 2.));\n// \tpModIcosahedron(p, i+1);\n//     p = planeNormal(p);\n//     p.z += 1.;\n//     //p.z += sin(t*PI/2. + .2) * 0.5;\n//     //pR(p.xy, t*1.5);\n//     //pR(p.zy, t/2.);\n    \n//     pR(p.zy, PI*t/4.);\n//     pR(p.zy, PI*.5);\n\t\n//     //return fBox(p, vec3(9.,.05,(float(i)/3.)+.1));\n//     return fBox(p, vec3(9., .05, .2));\n// }\n\nfloat inner(vec3 p) {\n    // float t = 0.;\n\tpModIcosahedron(p, 2);\n    p = planeNormal(p);\n    p.z += 2.;\n    pR(p.zy, PI*t/4.);\n    pR(p.zy, PI*.5);\n    return fBox(p, vec3(9., .1, .1));\n}\n\nfloat other(vec3 p) {\n    //pR(p.xz, t*.3);\n    //pR(p.zy, t*.3);\n    pModIcosahedron(p, 1);\n    p = planeNormal(p);\n    p += vec3(0.,0.,2.);\n    pR(p.xz, t*1.5 * 1.);\n    pR(p.zy, t/2. + 2.);\n\treturn fBox(p, vec3(.5,.1,.2));\n}\n\nfloat exampleModelC(vec3 p) {\n    pR(p.xy, 2.832);\n    \n    // pR(p.xz, t/3.);\n\n    // pR(p.yz, t*PI/2.);\n    // pR(p.xy, t*PI/4.);\n\t //pModIcosahedron(p, 2);\n     //pR(p.xy, t/8.);\n     // pR(p.yz, t/16.);\n\t//pModIcosahedron(p, 1);\n    //p = planeNormal(p);\n    float b = inner(p);\n    float a = other(p);\n    return b;\n    return fOpDifferenceRound(a, b, 0.3);\n}\n\nfloat exampleModel(vec3 p) {\n    //pRoll(p);\n\treturn exampleModelC(p);\n}\n\nvec3 doBackground(vec3 rayVec) {\n    return vec3(.13);\n}\n\n// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 20.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n    return (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 p ){  \n    \n    vec2 res = vec2(exampleModel(p) ,1.); \n    // vec2 res2 = vec2(core(p) ,2.); \n    return res;\n    // return opU(res, res2);\n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n    float res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n        vec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse) {\n    \n    float x = .366 + (mouse.x * 0.5);\n    float y = .4 + (mouse.y * 0.33);\n    \n    float an = 10.0 * x + PI / 2.;\n    //an = 10.;\n    float roll = .6;\n    //roll = 0.;\n    \n    //float d = 2. + sin(an) * 1.6;\n    float d = 2. + (1. - y) * 10.;\n    camPos = vec3(\n        sin(an),\n        sin(y * PI / 2.) - roll,\n        cos(an) - roll\n    ) * d;\n    \n    camPos = vec3(1.,0.,0.)*5.5;\n\n    camTar = vec3(0);\n}\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\n\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n   \n\n  vec3 color = doBackground(rd);\n  \n    if (res.y == 2.) {\n        return vec3(0.987,0.257,1.000);\n    }\n    \n  if( res.y > -.5 ){\n      \n\tfloat mult = (sin(PI*t/2. + 4.408) + .5) / 2.;\n\t// mult = pow(mult, 2.);\n    vec3 pos = ro + rd * res.x;\n    vec3 norm = calcNormal( pos );\n    vec3 ref = reflect(rd, norm);\n\tcolor = norm * 0.5 + 0.5;\n    float split = .7 - (dot(pos, norm) / PI);\n\t// split = 1. - split;\n    // split = clamp(split + mult, 0., 1.);\n\tsplit = pow(split, 4.);\n    float light = dot(ref, normalize(vec3(0,1,1)));\n    light *= 1. - split;\n    // float mult = (sin(PI*t/2. + -2.966) + 1.) / 2.;\n\tcolor *= split;\n    color += light * 0.3;\n\t// color = vec3(split);\n    \n  }\n   \n  return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime;\n    initIcosahedron();\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 ro = vec3( 0., 0., 2.);\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    // camera movement\n    doCamera(ro, ta, t, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n    \n    vec3 color = render( res , ro , rd );\n    \n    fragColor = vec4(color,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}