{
    "Shader": {
        "info": {
            "date": "1474040643",
            "description": "You can move the scene/canvas around by using your mouse / finger.\nThis scene has a:\nLight box roaming around the whole scene xD,\nA sea,\nA sky,\nSome Clouds,\nReflection,\nMoon,\nCurved horizon (Coming soon).\n\nPlz like & comment!",
            "flags": 40,
            "hasliked": 0,
            "id": "4ty3Wz",
            "likes": 2,
            "name": "Light Box And Sea v2",
            "published": 3,
            "tags": [
                "sea",
                "light",
                "sky",
                "canvas"
            ],
            "usePreview": 0,
            "username": "Imsure1200q_1UWE130",
            "viewed": 809
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float X = iMouse.x / iResolution.x / 2.0;\n    float Y = iMouse.y / iResolution.y / 2.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    if(uv.y < 0.51+Y)\n    {\n        fragColor = vec4(sin(uv.y+0.4))+vec4(-0.025, 0.025, 1.0, 1.0)+\n        (texture(iChannel1, vec2(uv.x/4.0-(iTime/48.0)-X, -uv.y*-uv.y-Y))-0.2)+(texture(iChannel2,\n                                                                            vec2(uv.x/4.0+\n                                                                                 (iTime/12.0)-X,\n                                                                                 uv.y*uv.y-Y))\n                                                           -0.9)\n            ;\n    }\n    else\n    {\n        fragColor = vec4(cos(uv.y))+vec4(-0.025, 0.025, 0.6, 1.0)+(texture(iChannel1,\n                                                                            vec2(uv.x/4.0-\n                                                                                 (iTime / 48.0)-X,\n                                                                                 uv.y-Y))-0.2)+\n            (texture(iChannel3, uv)+0.3);\n        ;\n    }\n\tfragColor += texture(iChannel0, uv) * (sin(iTime-0.9)+5.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float sd(vec3 p)\n{\n    float s1 = length(sqrt(abs(p)))-0.5;\n    float s2 = length(floor(abs(p)))+0.3;\n    return s1*sqrt(sqrt(s2));\n}\nfloat trace(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < 24; i++)\n    {\n        vec3 p = ro+t*rd;\n        float shape = sd(p);\n        t += shape * 0.5;\n    }\n    return t;\n}\nmat2 rot(float t)\n{\n    return mat2(-cos(t), sin(t), sin(t), cos(t));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float X = iMouse.x / iResolution.x;\n    float Y = iMouse.y / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    float time = iTime;\n    rd.xz *= mat2(-cos(time+X), sin(time+X), sin(time+X), cos(time+X));\n    rd.xy *= mat2(cos(time+X+Y), -sin(time+X+Y), sin(time+X+Y), cos(time+X+Y));\n    rd.yx *= mat2(cos(time+Y+X), sin(time+Y+X), -sin(time+Y+X), cos(time+Y+X));\n    vec3 ro = vec3(sin(time), sin(iTime/2.0), -1.0);\n    float t = trace(ro, rd);\n    float fog = 1.0/(1.0+t*t*0.1);\n    vec3 fc = vec3(fog);\n    fragColor = vec4(fc, 1.0) - 0.15;\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//G.E.MD.AS. IS USED IN WEBGL :(\nfloat sd(vec3 p)\n{\n    return length(p) - 1.0;\n}\nfloat trace(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < 24; i++)\n    {\n        vec3 p = ro+t*rd;\n        float shape = sd(p);\n        t += shape * 0.5;\n    }\n    return t;\n}\nfloat scramble(vec4 col)\n{\n    return length(col + length(col) * sqrt(sqrt(col)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float X = iMouse.x / iResolution.x / 2.0;\n    float Y = iMouse.y / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 ro = vec3(0.0-X, -0.9-Y, -3.0);\n    float t = trace(ro, rd);\n    float fog = 1.0/(1.0+t*t*0.1);\n    vec3 fc = vec3(fog);\n    fragColor = vec4((vec4(fc,1.0)))*scramble(texture(iChannel0, vec2(\n        uv.x*2.0-sin(uv.y-2.0)+sd(rd)-X,\n    uv.y*2.0-sin(uv.y-2.0)+sd(rd)-Y))-0.7);\n    vec4 stars = texture(iChannel1, sqrt(uv*2.0-1.0)*6.0);\n    if(stars.r <= 0.2)\n    {\n        stars.rgb -= 0.2;\n    }\n    else if(stars.r > 0.2 || stars.r <= 0.6)\n    {\n        stars.rgb -= 0.6;\n    }\n    else\n    {\n        stars.rgb += 1.0;\n    }\n    fragColor += stars;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//psytrance 2 \nconst float TAU = 3.141592653589*2.0;\n\n\n//psytrance lol\n\nfloat kick(float time, float mult)\n{\n    float length = 1.0;\n    float sampleTime = min(1.0, (time*mult) / length);\n    return sin(time*TAU*mix(50.0,200.0, exp(-16.0*sampleTime/2.0))) * exp(-1.0 * sampleTime*10.0);\n    return sin(length*sampleTime*TAU*mix(500.0,50.0,sampleTime)) * exp(-4.0 * sampleTime);\n}\n\nfloat bass(float time, float mult)\n{\n    float length = 1.0;\n    float sampleTime = min(1.0, (time*mult) / length);\n    return (sin(time*TAU*110.0/2.0)) * exp(-1.0 * sampleTime*10.0);\n    return sin(length*sampleTime*TAU*mix(500.0,50.0,sampleTime)) * exp(-4.0 * sampleTime);\n}\n\nfloat bass(float time, float mult, float freq)\n{\n    float length = 1.0;\n    float sampleTime = min(1.0, (time*mult) / length);\n    return (sin(time*TAU*freq)) * exp(-1.0 * sampleTime*10.0);\n    return sin(length*sampleTime*TAU*mix(500.0,50.0,sampleTime)) * exp(-4.0 * sampleTime);\n}\n\n// TANH Function (Hyperbolic Tangent)\nfloat tanh(float val)\n{\n    float tmp = exp(val);\n    float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);\n    return tanH;\n}\n\nfloat limiter(float x,float y)\n{\n    return tanh(x * y ) / tanh(y);\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    float bpm = 158.0;\n  float bpmult = bpm/60.0;\n    \n    float bpm2 = bpm + ( sin(time*TAU/7.0 ) - 0.8)*4.0;\n  float bpmult2 = bpm2/60.0;\n    \n    float outp = 0.0;\n    \n    if(fract(time * bpmult/4.0)*4.0 > 3.0 && fract(time * bpmult/4.0)*4.0 < 4.0)\n    {\n           outp += ( kick(fract(time*bpmult)/bpmult, 2.0 ) * 1.0 \n                + bass(fract(time*bpmult + 0.25)/bpmult, 3.0) *0.5\n                + bass(fract(time*bpmult2 + 0.5)/bpmult2, 3.0, 110.0) *0.5\n                + bass(fract(time*bpmult + 0.75)/bpmult, 3.0)*0.5 )\n        ;\n    }else{\n      outp += ( kick(fract(time*bpmult)/bpmult, 2.0 ) * 1.0 \n                + bass(fract(time*bpmult + 0.25)/bpmult, 3.0) *0.5\n                + bass(fract(time*bpmult2 + 0.5)/bpmult2, 3.0) *0.5\n                + bass(fract(time*bpmult + 0.75)/bpmult, 3.0)*0.5 )\n        ;\n    }\n    \n    float t = mod(time*bpmult,16.0)/bpmult;\n    outp += 0.05*sin(800.0*t*TAU + 80.14 * (cos(t*TAU*20.0) ))*exp(-t*3.0);\n    outp += 0.01*sin(6000.0*time*TAU);\n    \n    outp = limiter(outp,8.0);\n\n    return vec2(outp,outp);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 38
                    }
                ],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}