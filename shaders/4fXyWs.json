{
    "Shader": {
        "info": {
            "date": "1721821792",
            "description": "i have created a small website https://shaderclock.deno.dev/ where i want to have multiple shader clocks , and one gets loaded randomly \nif you want to participate make sure to add the tag 'shaderclockdenodev'",
            "flags": 0,
            "hasliked": 0,
            "id": "4fXyWs",
            "likes": 4,
            "name": "daily shader clock 1",
            "published": 3,
            "tags": [
                "daily",
                "shaderclockdenodev"
            ],
            "usePreview": 0,
            "username": "jonasfrey",
            "viewed": 182
        },
        "renderpass": [
            {
                "code": "//IMPORTANT START, keep the lines with and between IMPORTANT START and \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//IMPORTANT END\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_trn = (fragCoord.xy-iResolution.xy*.5)/min(iResolution.y, iResolution.x);\n    o_trn*=1.2;\n\n    float n_sec = iDate.w;\n    float n_sec_mod = mod(n_sec , 60.);\n    float n_sec_mod_nor = n_sec_mod / 60.;\n    float n_min_mod = floor(mod(n_sec, 60.*60.));\n    float n_min_mod_nor = n_min_mod / (60.*60.);\n    float n_hou_mod = floor(mod(n_sec, 60.*60.*12.));\n    float n_hou_mod_nor = n_hou_mod / (60.*60.*12.);\n    \n    float n_aa = (1./(iResolution.x+iResolution.y)/2.)*8.;\n    float n_its = 3.;\n    float n_it_nor_one = 1./n_its;\n    \n    vec4 o_col = vec4(0.);\n    float n_min = 1.;\n    float n_tau = 6.2831;\n    for(float n_it_nor = 0.; n_it_nor < 1.; n_it_nor+=n_it_nor_one){\n        float n_it = floor(n_it_nor*n_its);\n        float n_radius = 0.5-(n_it_nor*(.5));\n\n        float n = abs(length(o_trn)-n_radius);\n        float n_mod_nor = n_sec_mod_nor;\n        if(n_it == 1.){\n            n_mod_nor = n_min_mod_nor;\n        }\n        if(n_it == 2.){\n            n_mod_nor = n_hou_mod_nor;\n        }\n        \n        float n_p = length(o_trn-vec2(0, n_radius));\n        float n_p2 = length(\n            o_trn - \n            vec2(\n                sin(n_mod_nor*n_tau),\n                cos(n_mod_nor*n_tau)\n            )*n_radius\n        );\n        float n_ang_nor = 1.-fract(.75+atan(o_trn.y, o_trn.x)/n_tau);\n        \n        float n_ang_nor_12 = fract(floor((n_ang_nor+(1./12./2.))*12.)/12.);\n        float n3 = length(\n            o_trn - \n            vec2(\n                sin(n_ang_nor_12*n_tau),\n                cos(n_ang_nor_12*n_tau)\n            )*n_radius\n        );\n        \n        if(n_ang_nor > n_mod_nor){\n            n = min(n_p, n_p2);\n        }\n        n_min = min(n, n_min);\n        n = 1.-pow(n,1./11.);\n        \n        n3 *= 2.;\n        o_col += vec4(n);\n        o_col += vec4(1.-pow(n3, 1./11.));\n    }\n    \n    fragColor = o_col*(1.-n_min);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}