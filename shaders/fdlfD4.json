{
    "Shader": {
        "info": {
            "date": "1644972319",
            "description": "This is an animated version of an album cover of Half Moon Run's EP \"Inwards and Onwards\".\nI kinda hacked the math, it's actually full 2d but looks 3d.\nTurn FSAA up for more anti-aliasing, down for better perf.",
            "flags": 0,
            "hasliked": 0,
            "id": "fdlfD4",
            "likes": 5,
            "name": "Inwards and Onwards",
            "published": 3,
            "tags": [
                "retro",
                "cover",
                "album"
            ],
            "usePreview": 0,
            "username": "nyri0",
            "viewed": 306
        },
        "renderpass": [
            {
                "code": "const int FSAA = 4;\nconst float GRID_DIM = 1.0;\nconst float R = 0.8;\n\nfloat jTime;\n\n\nfloat sq(float x) {\n    return x*x;\n}\n\n// From https://www.shadertoy.com/view/4sc3z2\n// and https://www.shadertoy.com/view/XsX3zB\n#define MOD3 vec3(.1031,.11369,.13787)\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat simplexNoise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nfloat length_sq(vec2 x) {\n    return dot(x, x);\n}\n\nfloat segment_df(vec2 uv, vec2 p0, vec2 p1) {\n  float l2 = length_sq(p1 - p0);\n  float t = clamp(dot(uv - p0, p1 - p0) / l2, 0.0, 1.0);\n  vec2 projection = p0 + t * (p1 - p0);\n  return distance(uv, projection);\n}\n\nfloat semi_circle_sdf(vec2 uv, vec2 c, float r) {\n    return max((length(uv - c) - r), -(uv.y-c.y));\n}\n\nfloat frame_sdf(vec2 uv, vec2 pf) {\n    // Factor by which to multiply the distance at max depth for cheap 3d look.\n    const float fm = 5.0;\n    \n    const vec2 A = vec2(-R, 0.0);\n    const vec2 B = vec2(R, 0.0);\n\n    // Two segments towards pf\n    float sdf = min(segment_df(uv, A, pf), segment_df(uv, B, pf)) * mix(1., fm, smoothstep(0., pf.y, uv.y));\n    \n    // Semi-circles\n    const int n_steps = 15;\n    for(int i = 0; i < n_steps; i++) {\n        float t = 1. - exp(-0.3*float(i));\n        float fmi = mix(1., fm, t);\n        // sdf = min(sdf, segment_df(uv, mix(A, pf, t), mix(B, pf, t)) * fmi);\n        sdf = min(sdf, abs(semi_circle_sdf(uv, mix(vec2(0,0), pf, t), R*(1.-t))) * fmi);\n    }\n    \n    return sdf;\n}\n\nvec4 sampleColor(in vec2 sampleCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Normalized pixel coordinates (from -1 to 1)\n    //vec2 uv = 2.0 * sampleCoord / iResolution.xy - 1.0;\n    \n    // Pixel coordinates fixed with correct aspect ratio\n    vec2 uvf = 2.0* (sampleCoord - iResolution.xy / 2.0) / iResolution.y;\n    \n    vec2 pf = vec2(0.55 * cos(0.7*iTime), 0.4);\n    vec2 pfl = pf + vec2(0, -0.1);\n    \n    vec3 col;\n    \n    float my_noise = simplexNoise(vec3(500.0*uvf, iTime));\n    \n    // Black noisy background\n    vec3 bg_col = mix(vec3(0,0,0), vec3(0.9, 0.3, 1), smoothstep(0.2, 1.0, my_noise));\n    col = bg_col;\n    \n    // Very visible noise in lower part of the circle\n    if(uvf.y < 0.0) col = mix(vec3(0,0,0), vec3(0.9, 0.3, 1.), 0.1+0.9*smoothstep(0., 1., my_noise));\n    \n    // Bright lines with glow\n    const float fm = 1.7;\n\n    const vec2 po0 = vec2(-0.6*R, 0.);\n    const vec2 po1 = vec2(-0.1*R, 0.);\n    vec2 po0a = pfl + 0.5 * (po0-pf);\n    vec2 po1a = pfl + 0.2 * (po1-pf);\n    vec2 po0b = pfl + 3. * (po0-pf);\n    vec2 po1b = pfl + 3. * (po1-pf);\n    vec3 outer_col_orange = uvf.y > 0. ? vec3(1, 0.35, 0.) : vec3(1, .1, 0);\n    vec3 inner_col_orange = vec3(.95, 1, .8);\n    float df_orange = min(segment_df(uvf, po0b, po0a), segment_df(uvf, po1b, po1a)) * mix(1.0, fm, smoothstep(-R, pf.y, uvf.y));\n    col = mix(outer_col_orange, col, smoothstep(0.1, 0.2, df_orange+0.1*my_noise));\n    col = mix(col, inner_col_orange, step(smoothstep(0., 0.35, df_orange), my_noise));\n    \n    const vec2 pp0 = vec2(0.4*R, 0.);\n    const vec2 pp1 = vec2(0.75*R, 0.);\n    vec2 pp0b = pfl + 3. * (pp0-pf);\n    vec2 pp1b = pfl + 3. * (pp1-pf);\n    vec3 outer_col_blue = uvf.y > 0. ? vec3(0.5, .8, .9) : vec3(0.3, 0.3, 1);\n    vec3 inner_col_blue = vec3(0.95, 1, 1);\n    float df_purple = min(segment_df(uvf, pp0b, pfl), segment_df(uvf, pp1b, pfl)) * mix(1.0, fm, smoothstep(-R, pf.y, uvf.y));\n    col = mix(outer_col_blue, col, smoothstep(0.1, 0.2, df_purple+0.1*my_noise));\n    col = mix(col, inner_col_blue, step(smoothstep(0., 0.35, df_purple), my_noise));\n    \n    // Mask\n    if(length(uvf) > R) col = bg_col;\n    \n    // Frame\n    col = mix(vec3(1,1,1), col, smoothstep(0., 0.007, frame_sdf(uvf, pf)));\n    \n\n    // Output to screen\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 colSum = vec4(0);\n    for(int i = 0; i < FSAA; i++) {\n        for(int j = 0; j < FSAA; j++) {\n            colSum += sampleColor(fragCoord + vec2(float(i) / float(FSAA), float(j) / float(FSAA)));\n        }\n    }\n    fragColor = colSum / colSum.w;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}