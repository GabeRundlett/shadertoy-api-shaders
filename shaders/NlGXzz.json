{
    "Shader": {
        "info": {
            "date": "1640559722",
            "description": "Mouse to rotate camera.\n\nSpectral path tracing of a rayleigh volume, using delta tracking instead of raymarching (slower, but unbiased). My first go at wavelength importance sampling and low discrepency sequences.",
            "flags": 32,
            "hasliked": 0,
            "id": "NlGXzz",
            "likes": 88,
            "name": "Path traced Rayleigh scattering",
            "published": 3,
            "tags": [
                "fractal",
                "volume",
                "mandelbulb",
                "volumetric",
                "pathtracing",
                "tracing",
                "rayleigh",
                "path",
                "spectral"
            ],
            "usePreview": 0,
            "username": "loicvdb",
            "viewed": 2254
        },
        "renderpass": [
            {
                "code": "vec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nconst mat3 xyz2rgb = mat3(\n     3.2404542,-0.9692660, 0.0556434,\n    -1.5371385, 1.8760108,-0.2040259,\n    -0.4985314, 0.0415560, 1.0572252\n);\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    vec3 x = max(texelFetch(iChannel0, ivec2(u), 0).xyz, 0.0);\n    \n    float r = floor(log2(iResolution.y) - 4.5) + 0.5;\n    for(int i = 0; i < 2; i++)\n        x += texture(iChannel0, u/iResolution.xy, r + float(i * 2)).xyz * 0.1;\n        \n    o = vec4(ACESFilm(max(xyz2rgb * x, 0.0)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// spp per frame\nconst int SPP = 1;\n\nconst float PI = 3.141592653589793;\n\n// Spectrum with its integral\nconst vec3 cie[48] = vec3[48](\n    vec3( 0.000000f, 0.000000f, 0.000001f ),    // 360 nm\n    vec3( 0.000006f, 0.000001f, 0.000026f ),    // 370 nm\n    vec3( 0.000160f, 0.000017f, 0.000705f ),    // 380 nm\n    vec3( 0.002362f, 0.000253f, 0.010482f ),    // 390 nm\n    vec3( 0.019110f, 0.002004f, 0.086011f ),    // 400 nm\n    vec3( 0.084736f, 0.008756f, 0.389366f ),    // 410 nm\n    vec3( 0.204492f, 0.021391f, 0.972542f ),    // 420 nm\n    vec3( 0.314679f, 0.038676f, 1.553480f ),    // 430 nm\n    vec3( 0.383734f, 0.062077f, 1.967280f ),    // 440 nm\n    vec3( 0.370702f, 0.089456f, 1.994800f ),    // 450 nm\n    vec3( 0.302273f, 0.128201f, 1.745370f ),    // 460 nm\n    vec3( 0.195618f, 0.185190f, 1.317560f ),    // 470 nm\n    vec3( 0.080507f, 0.253589f, 0.772125f ),    // 480 nm\n    vec3( 0.016172f, 0.339133f, 0.415254f ),    // 490 nm\n    vec3( 0.003816f, 0.460777f, 0.218502f ),    // 500 nm\n    vec3( 0.037465f, 0.606741f, 0.112044f ),    // 510 nm\n    vec3( 0.117749f, 0.761757f, 0.060709f ),    // 520 nm\n    vec3( 0.236491f, 0.875211f, 0.030451f ),    // 530 nm\n    vec3( 0.376772f, 0.961988f, 0.013676f ),    // 540 nm\n    vec3( 0.529826f, 0.991761f, 0.003988f ),    // 550 nm\n    vec3( 0.705224f, 0.997340f, 0.000000f ),    // 560 nm\n    vec3( 0.878655f, 0.955552f, 0.000000f ),    // 570 nm\n    vec3( 1.014160f, 0.868934f, 0.000000f ),    // 580 nm\n    vec3( 1.118520f, 0.777405f, 0.000000f ),    // 590 nm\n    vec3( 1.123990f, 0.658341f, 0.000000f ),    // 600 nm\n    vec3( 1.030480f, 0.527963f, 0.000000f ),    // 610 nm\n    vec3( 0.856297f, 0.398057f, 0.000000f ),    // 620 nm\n    vec3( 0.647467f, 0.283493f, 0.000000f ),    // 630 nm\n    vec3( 0.431567f, 0.179828f, 0.000000f ),    // 640 nm\n    vec3( 0.268329f, 0.107633f, 0.000000f ),    // 650 nm\n    vec3( 0.152568f, 0.060281f, 0.000000f ),    // 660 nm\n    vec3( 0.081261f, 0.031800f, 0.000000f ),    // 670 nm\n    vec3( 0.040851f, 0.015905f, 0.000000f ),    // 680 nm\n    vec3( 0.019941f, 0.007749f, 0.000000f ),    // 690 nm\n    vec3( 0.009577f, 0.003718f, 0.000000f ),    // 700 nm\n    vec3( 0.004553f, 0.001768f, 0.000000f ),    // 710 nm\n    vec3( 0.002175f, 0.000846f, 0.000000f ),    // 720 nm\n    vec3( 0.001045f, 0.000407f, 0.000000f ),    // 730 nm\n    vec3( 0.000508f, 0.000199f, 0.000000f ),    // 740 nm\n    vec3( 0.000251f, 0.000098f, 0.000000f ),    // 750 nm\n    vec3( 0.000126f, 0.000050f, 0.000000f ),    // 760 nm\n    vec3( 0.000065f, 0.000025f, 0.000000f ),    // 770 nm\n    vec3( 0.000033f, 0.000013f, 0.000000f ),    // 780 nm\n    vec3( 0.000018f, 0.000007f, 0.000000f ),    // 790 nm\n    vec3( 0.000009f, 0.000004f, 0.000000f ),    // 800 nm\n    vec3( 0.000005f, 0.000002f, 0.000000f ),    // 810 nm\n    vec3( 0.000003f, 0.000001f, 0.000000f ),    // 820 nm\n    vec3( 0.000002f, 0.000001f, 0.000000f )     // 830 nm\n);\n\nconst float invSpecIntegral = 1.0 / 116.643;\n\nfloat uintRangeToFloat(uint i)\n{\n    return float(i) / float(0xFFFFFFFFu);\n}\n\n// low-ish discrepency sequences\n\nconst uint LAMBDA = 0u;\nconst uint DOF_U = 1u;\nconst uint DOF_V = 2u;\nconst uint AA_U = 3u;\nconst uint AA_V = 4u;\nconst uint BASE = 5u;\n\nconst uint BRDF_U = 0u;\nconst uint BRDF_V = 1u;\nconst uint BOUNCE = 2u;\n\nuint bounce;\nuint frame;\nuint pixel;\nuint seed;\n\n\nuint hash(uint i)\n{\n\ti ^= i >> 12u;\n\ti *= 0xB5297A4Du;\n\ti ^= i >> 12u;\n\ti += 0x68E31DA4u;\n\ti ^= i >> 12u;\n\ti *= 0x1B56C4E9u;\n\treturn i;\n}\n\nfloat random()\n{\n    return uintRangeToFloat(hash(seed++));\n}\n\n\nfloat prng(uint dimension)\n{\n    // 32 dimensional noise\n    const int nDim = 32;\n    \n    // additive recurrence, using square roots of primes (some have been modified to not be too small)\n    const uint sqPrimes[nDim] = uint[nDim](\n        0x6a09e667u, 0xbb67ae84u, 0x3c6ef372u, 0xa54ff539u, 0x510e527fu, 0x9b05688au, 0x1f83d9abu, 0x5be0cd18u,\n        0xcbbb9d5cu, 0x629a2929u, 0x91590159u, 0x452fecd8u, 0x67332667u, 0x8eb44a86u, 0xdb0c2e0bu, 0x47b5481du,\n        0xae5f9155u, 0xcf6c85d1u, 0x2f73477du, 0x6d1826cau, 0x8b43d455u, 0xe360b595u, 0x1c456002u, 0x6f196330u,\n        0xd94ebeafu, 0x9cc4a611u, 0x261dc1f2u, 0x5815a7bdu, 0x70b7ed67u, 0xa1513c68u, 0x44f93634u, 0x720dcdfcu\n    );\n    \n    // low disrepency for dimensions < 32\n    if (dimension < uint(nDim))\n    {\n        return uintRangeToFloat((frame + pixel) * sqPrimes[dimension]);\n    }\n    // noise after that\n    else\n    {\n        return uintRangeToFloat(hash(frame + pixel));\n    }\n}\n\n\n// implicit volume\n\nfloat density(vec3 p)\n{\n    p = -p;\n\tvec3 w = p;\n\tfloat m = dot(w, w);\n    \n\tfor(int j = 0; j < 4; j++)\n    {\n\t\tif(m > 1.2) break;\n        \n        #if 0\n        \n        // trig\n        float a = 8.0 * acos(w.y * inversesqrt(m));\n        float i = 8.0 * atan(w.x, w.z);\n        w = m*m*m*m * vec3(sin(a) * sin(i), cos(a), sin(a) * cos(i)) + p;\n        \n        #elif 0\n        \n        // IQs\n\t\tfloat x = w.x;\n\t\tfloat y = w.y;\n\t\tfloat z = w.z;\n        float x2 = x * x;\n        float y2 = y * y;\n        float z2 = z * z;\n        float x4 = x2 * x2;\n        float y4 = y2 * y2;\n        float z4 = z2 * z2;\n\t\tfloat k3 = x2 + z2;\n\t\tfloat k2 = inversesqrt(k3 * k3 * k3 * k3 * k3 * k3 * k3);\n\t\tfloat k1 = x4 + y4 + z4 - 6.0 * y2 * z2 - 6.0 * x2 * y2 + 2.0 * z2 * x2;\n\t\tfloat k4 = x2 - y2 + z2;\n\t\tw.x = p.x +  64.0 * x * y * z * (x2 - z2) * k4 * (x4 - 6.0 * x2 * z2 + z4) * k1 * k2;\n\t\tw.y = p.y + -16.0 * y2 * k3 * k4 * k4 + k1 * k1;\n\t\tw.z = p.z + -8.0 * y * k4 * (x4 * x4 - 28.0 * x4 * x2 * z2 + 70.0 * x4 * z4 - 28.0 * x2 * z2 * z4 + z4 * z4) * k1 * k2;\n        \n        #else\n        \n        // faster version\n\t\tfloat x2 = w.x * w.x;\n\t\tfloat y2 = w.y * w.y;\n\t\tfloat z2 = w.z * w.z;\n        float x4 = x2 * x2;\n        float z4 = z2 * z2;\n        float k1 = x2 * z2;\n\t\tfloat k2 = x2 + z2;\n\t\tfloat k3 = x4 + z4 + y2 * (y2 - 6.0 * k2) + 2.0 * k1;\n        float k4 = k2 * k2 * k2;\n\t\tfloat k5 = k3 * inversesqrt(k4 * k4 * k2);\n\t\tfloat k6 = w.y * (k2 - y2);\n\t\tw.x = p.x + 64.0 * k6 * k5 * w.x * w.z * (x2 - z2) * (x4 - 6.0 * k1 + z4);\n\t\tw.y = p.y - 16.0 * k6 * k6 * k2 + k3 * k3;\n\t\tw.z = p.z - 8.0 * k6 * k5 * (x4 * (x4 - 28.0 * k1 + 70.0 * z4) + z4 * (z4 - 28.0 * k1));\n        \n        #endif\n        \n\t\tm = dot(w, w);\n\t}\n    \n\treturn mix(1.0, 0.005, step(1.2, m));\n}\n\n\n// volume tracing using detla tracking\n\nfloat trace(vec3 ro, vec3 rd, float l)\n{\n   \n    float b = -dot(ro, rd);\n    float d = b * b - dot(ro, ro) + 1.3;\n    \n    if(d < 0.0) return -1.0;\n    \n    float s = sqrt(d);\n    \n    float t = max(b - s, 0.0);\n    float mt = b + s;\n    \n    float invMaxDensity = l*l*l*l * 2.0e-13;\n    bool hit = false;\n    for (int i = 0; i < 256 && !hit && t < mt; i++)\n    {\n        t -= log(1.0 - random()) * invMaxDensity;\n        hit = random() < density(ro + rd * t);\n    }\n     \n    return hit && t < mt ? t : -1.0;\n}\n\n// brdf importance sampling\n\nvec3 brdfSample()\n{\n    vec2 r = vec2(2.0 * PI * prng(BASE + bounce * BOUNCE + BRDF_U),\n                  acos(2.0 * prng(BASE + bounce * BOUNCE + BRDF_V) - 1.0));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(s.y * s.x, s.y * c.x, c.y);\n}\n\nfloat brdfPdf(vec3 wi)\n{\n    return 0.25 / PI;\n}\n\n\nfloat brdf(vec3 wi)\n{\n    return 3.0 * (1.0 + wi.z * wi.z) / (PI * 16.0);\n}\n\n// wavelength importance sampling (proportional to luminance)\n\nfloat lambdaSample()\n{\n    float y = prng(LAMBDA), g;\n    \n    int i;\n    for (i = 0; i < 47 && y >= 0.0; i++)\n    {\n        g = cie[i].y * invSpecIntegral;\n        y -= g * 10.0;\n    }\n    \n    return float(355 + i * 10) + y / g;\n}\n\n\nfloat lambdaPdf(float l)\n{\n    int index = int(l * 0.1 - 35.5);\n    if(index < 0 || index > 47) \n    {\n        return 0.0;\n    }\n    return cie[index].y * invSpecIntegral;\n}\n\n\nvec3 wavelength2xyz(float l)\n{\n\tfloat x = l * 0.1 - 36.0;\n    int index = int(x);\n    if(index < 0 || index >= 47) \n    {\n        return vec3(0.0);\n    }\n    return mix(cie[index], cie[index + 1], fract(x)) * invSpecIntegral;\n}\n\n\nvec3 ortho(vec3 v)\n{\n    return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y,v.x,0.) : vec3(0.,-v.z,v.y));\n}\n\n\nfloat blackbody(float l, float t)\n{\n    const float h = 6.62607004e-16;\n    const float k = 1.38064852e-5;\n    const float c = 299792458e9;\n    \n    float a = 2.0 * h * c * c;\n    float b = h * c / (l * k * t);\n    return a / (l*l*l*l*l  * (exp(b) - 1.0));\n}\n\n\nfloat background(vec3 rd, float l)\n{\n    return 0.0;\n}\n\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    pixel = hash(uint(gl_FragCoord.x) + uint(gl_FragCoord.y) * 0x452fecd8u);\n    frame = iFrame == 0  || iMouse.z > 0.0 ? 0u : uint(texelFetch(iChannel0, ivec2(u), 0).a);\n    seed = hash(frame) ^ pixel;\n    \n    o.rgb = iFrame == 0 ? vec3(0) : texelFetch(iChannel0, ivec2(u), 0).rgb;\n    \n    vec2 rot = PI * (iMouse.yx - iResolution.yx * 0.5) / iResolution.y;\n    vec2 c = cos(rot), s = sin(rot);\n    mat3 rx = mat3(1, 0, 0, 0, c.x, -s.x, 0, s.x, c.x);\n    mat3 ry = mat3(c.y, 0, -s.y, 0, 1, 0, s.y, 0, c.y);\n    mat3 r = ry * rx;\n    \n    for (int i = 0; i < SPP; i++)\n    {\n        float a = prng(DOF_U) * PI * 2.0;\n        vec2 aperture = 0.05 * sqrt(prng(DOF_V)) * vec2(cos(a), sin(a));\n        vec2 uv = (floor(u) + vec2(prng(AA_U), prng(AA_V)) - iResolution.xy * 0.5) / iResolution.y;\n        vec3 ro = vec3(aperture, -4.0);\n        vec3 rd = normalize(vec3(uv * 3.9 / 6.0 - aperture, 3.9));\n        \n        ro = r * ro;\n        rd = r * rd;\n        \n        ro += vec3(0.0, 0.8, 0.0);\n        \n        float li = 0.0;\n        float att = 1.0;\n        \n        float l = lambdaSample();\n        \n        for (bounce = 0u; bounce < 8u; bounce++)\n        {\n            float t = trace(ro, rd, l);\n            \n            if (t < 0.0)\n            {\n                li += att * background(rd, l);\n                break;\n            }\n            \n            ro += rd * t;\n            \n            vec3 b = ortho(rd);\n            mat3 brdf2World = mat3(cross(b, rd), b, rd);\n            mat3 world2Brdf = transpose(brdf2World);\n            \n            const vec3 lDir = normalize(vec3(1.0));\n            \n            if (trace(ro, lDir, l) < 0.0)\n            {\n                li += att * brdf(world2Brdf * lDir) * blackbody(l, 6400.0) * 0.0003;\n            }\n            \n            rd = brdfSample();\n            att *= brdf(rd) / brdfPdf(rd);\n            \n            rd = brdf2World * rd;\n        }\n        \n        vec3 col = li / lambdaPdf(l) * wavelength2xyz(l);\n        \n        frame++;\n        \n        o = vec4(mix(o.rgb, col, 1.0 / float(frame)), frame);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}