{
    "Shader": {
        "info": {
            "date": "1561933091",
            "description": "My first ray tracing test.  It looks fine but not as correct as I expected. Anyways, two beautiful spheres are left on their own in a very charming space. ",
            "flags": 0,
            "hasliked": 0,
            "id": "ttjGWt",
            "likes": 21,
            "name": "Get out!",
            "published": 3,
            "tags": [
                "raytracing",
                "reflection"
            ],
            "usePreview": 0,
            "username": "zxxuan1001",
            "viewed": 1047
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926\n#define EPSILON 0.001\n#define MAX_STEPS 100\n#define MAX_DISTANCE 80.0\n#define AA 1\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n};\n\nstruct Material {\n    vec3 albedo;\n    float metallic;\n    float roughness;\n    vec3 reflection;\n    vec3 refraction;\n};\n    \nstruct Hit {\n    float dist;\n    int matIndex; //material info at the intersection point\n};\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p, n.xyz) + n.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nHit unionSDF(Hit d1, Hit d2) \n{\n    if (d1.dist < d2.dist) {\n        return d1;\n    } else {\n        return d2;\n    }  \n}\n\nvec3 doTranslate(vec3 p, vec3 offset) \n{\n    return p - offset;\n}\n\nHit sceneSDF(vec3 p) {\n    Hit rst;\n    \n    vec3 p1 = doTranslate(p, vec3(10.0*cos(iTime), 1.0, 10.0*sin(iTime)));\n    Hit is0 = Hit(sphereSDF(p1, 1.0), 1);\n    p1 = doTranslate(p, vec3(1.0, 1.5, -2.0));\n    Hit is1 = Hit(sphereSDF(p1, 1.5 ), 2);\n    \n    /*\n    Hit is2 = Hit(sdPlane(p, vec4(0.0, 1.0, 0.0, 0.0)), 3);\n    Hit is3 = Hit(sdPlane( p, vec4(0.0, 0.0, 1.0, 20.0)), 3);\n    Hit is4 = Hit(sdPlane( p, vec4(1.0, 0.0, 0.0, 20.0)), 3);\n    Hit is5 = Hit(sdPlane( p, vec4(-1.0, 0.0, 0.0, 20.0)), 3);\n    Hit is6 = Hit(sdPlane( p, vec4(0.0, 0.0, -1.0, 20.0)), 3);\n    Hit is7 = Hit(sdPlane( p, vec4(0.0, -1.0, 0.0, 30.0)), 3);\n    */\n    \n    Hit outerBox = Hit(sdBox(p-vec3(0.0,25.0,0.0), vec3(25.0,25.0,25.0)), 3); \n    outerBox.dist = -outerBox.dist-0.1;\n    \n    rst = unionSDF(is0, is1);\n    rst = unionSDF(rst, outerBox);\n    \n    /*\n    rst = unionSDF(rst, is2);\n    rst = unionSDF(rst, is3);\n    rst = unionSDF(rst, is4);\n    rst = unionSDF(rst, is5);\n    rst = unionSDF(rst, is6);\n    rst = unionSDF(rst, is7);\n\t*/\n    return rst;\n}\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).dist - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).dist,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).dist - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).dist,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).dist - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).dist\n    ));\n}\n\nHit marching(vec3 ro, vec3 rd) \n{\n    float tmax = MAX_DISTANCE;\n    float t = 0.001;\n    Hit result = Hit(-1.0, -1);\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * t;\n        Hit res = sceneSDF(p);\n        if (res.dist < EPSILON)\n        {\n            return result;\n        }\n        else if (t > tmax)\n        {\n            result.matIndex = -1;\n            result.dist = tmax;\n            break;\n        }\n        t += res.dist;\n        result.dist = t;\n        result.matIndex = res.matIndex;\n    }\n    \n    return result;\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd) {\n    float mint = 0.1;\n    float t = mint;\n    float res = 1.0;\n    float k = 4.0;\n    for (int i = 0; i < 40; i++)\n    {\n        float h = sceneSDF(ro + rd * t).dist;\n        \n\t\tres = min( res, k * h / t );\n        t += clamp( h, 0.02, 0.20 );\n     \n        if ( h < EPSILON ) \n        {\n            res = min(res, 0.0);\n            break;\n        } \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    float h = 0.001;\n    for( float i = 0.0; i < 5.0; i++ )\n    {\n        float d = sceneSDF( pos + h * nor ).dist;\n        occ += ( h - d ) * sca;\n        sca *= 0.85;\n        h += 0.45 * i / 5.0;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n//Fresnel/reflectivity\nvec3 Fs(vec3 h, vec3 v, vec3 f0)\n{\n    float dothv = max(dot(h, v), 0.0);\n    return max(f0 + (1.0 - f0) * pow((1.0 - dothv), 5.0), 0.0);\n}\n\n//Distribution/concentration\nfloat D_GGX(float dotnh, float roughness) \n{\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float dotnh2 = dotnh * dotnh;\n    float denom =  max(dotnh2 * (a2 - 1.0) + 1.0, EPSILON);\n    return a2 /(PI * denom * denom);\n}\n\nfloat G_SGGX(float dotnv, float roughness)\n{\n    float r = roughness + 1.0; \n    float k = (r * r) / 8.0;\n    return dotnv / (dotnv * (1.0 - k) + k);\n}\n\n//Geometry/shadowing masking\nfloat G_Smith(float dotnv, float dotnl, float roughness)\n{\n    \n    float ggx1 = G_SGGX(dotnv, roughness);\n    float ggx2 = G_SGGX(dotnl, roughness);\n    return ggx1 * ggx2;\n}\n\n//Fresnel/reflectivity\nvec3 Fs(float dothv, vec3 f0)\n{\n    vec3 F = f0 + (1.0 - f0) * pow((1.0 - dothv), 5.0);\n    return max(F, 0.0);\n}\n\nvec3 shading(vec3 ro, vec3 p, vec3 normal, Light lightInfo, inout Material mat) \n{\n    vec3 Lo = vec3(0.0);\n    \n    //material and light\n    vec3 albedo = mat.albedo; //vec3(0.2, 0.87, 0.6);\n    float roughness = mat.roughness;\n    float metallic = mat.metallic;\n    vec3 lightDir = lightInfo.position - p;\n    vec3 lightColor = lightInfo.color; \n    \n    //calculating vectors\n    vec3 viewDir = ro - p;\n    vec3 V = normalize(viewDir);\n    vec3 N = normal;\n    vec3 L = normalize(lightDir);\n    vec3 H = normalize(V + L);\n    \n    float dist = length(lightDir);\n\n    float sd = calcShadow(p, L);\n    float att = 1.0 / ( dist);\n    vec3 radiance = lightColor * att * sd;\n\n    float dothv = max(dot(H, V), 0.0);\n    float dotnh = max(dot(N, H), 0.0);\n    float dotnv = max(dot(N, V), 0.0);\n    float dotnl = max(dot(N, L), 0.0);\n      \n    //fresnel\n    vec3 f0 = vec3(0.04); \n    f0 = mix(f0, albedo, metallic);\n    vec3 F = Fs(dothv, f0);\n    \n    //cook-torrance specualr term\n    float D = D_GGX(dotnh, roughness);\n    float GS = G_Smith(dotnv, dotnl, roughness);\n    vec3 nom = D * GS * F;\n    float denom = 4.0 * dotnv * dotnl;\n    vec3 Fct = nom / max(denom, EPSILON); //avoid zero denom\n\n    vec3 Ks = F; //reflect\n    vec3 Kd = 1.0 - Ks; \n    Kd *= 1.0 - metallic; //diffuse\n    vec3 Fl = albedo/PI; //lambert\n    \n    mat.reflection = Ks;\n    \n    Lo += (Kd * Fl + Fct) * radiance * dotnl; \n    \n    float ao = calcAO(p, N);\n    vec3 ambient = vec3(0.01) * albedo * ao;\n    return ambient + Lo;\n}\n\nmat3 getCamera( in vec3 ro, in vec3 ta) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//hacks for non-constant index expression\nMaterial getMaterial(int index) {\n    Material mat[4];\n    mat[0] = Material(vec3(1.0), 0.5, 0.1, vec3(0.0), vec3(0.0)); //white\n    mat[1] = Material(vec3(0.5, 0.8, 0.5), 0.9, 0.2, vec3(0.0), vec3(0.0)); //green\n    mat[2] = Material(vec3(0.9, 0.9, 0.2), 0.9, 0.2, vec3(0.0), vec3(0.0)); //yellow\n    mat[3] = Material(vec3(0.8, 0.5, 0.5), 0.5, 0.3, vec3(0.0), vec3(0.0)); //pink\n    if (index == 0) {\n        return mat[0];\n    } else if (index == 1) {\n        return mat[1];\n    } else if (index == 2) {\n        return mat[2];\n    } else if (index == 3) {\n        return mat[3];\n    }\n}\n\nvec3 render(in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5; \n    uv.x *= iResolution.x/iResolution.y; \n    \n    vec3 col = vec3(0.0);\n    vec2 mouse = vec2(0.01) + iMouse.xy  / iResolution.xy ;\n    mouse -= 0.5;\n    \n    vec3 ro = vec3(10.0 * cos(mouse.x * 2.0 * PI), 6.0 + 5.0 * mouse.y, 10.0 * sin(mouse.x * 2.0 * PI));\n    vec3 ta = vec3(0.0, 4.0, 0.0);\n    mat3 cam = getCamera(ro, ta);\n    vec3 rd = normalize(cam * vec3(uv, 1.0));\n     \n    Light lightInfo = Light(vec3(5.0 * sin(iTime), 10.0, 2.0), vec3(200.0));\n    \n    Hit icp;\n    vec3 nor = vec3(0.0);  \n    vec3 ori = ro;\n    vec3 dir = rd;\n    vec3 interP = vec3(0.0);\n    vec3 mask = vec3(1.0);\n    float travelDist = 0.0; //calculate how far a ray travels\n     \n    for (float i = 0.0; i < 3.0; i++) {\n        icp = marching(ori, dir);\n        interP = ori + (icp.dist) * dir; //interception point\n        travelDist += length(ori - interP);\n        nor = getNormal(interP);\n        if (icp.dist >= MAX_DISTANCE) {\n            col += vec3(0.0);\n        } else {\n            Material mat = getMaterial(icp.matIndex);\n            col += mask * shading(ori, interP, nor, lightInfo, mat);\n            \n            vec3 ref = reflect(dir, nor);\n            ori = interP + EPSILON*ref;\n            dir = ref;\n            mask *= mat.reflection * 0.8;\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 col = vec3(0.0);\n    vec2 offset = vec2(0.0);\n#if AA>1\n    for (int y = 0; y < AA; ++y)\n    {\n        for (int x = 0; x < AA; ++x)\n        {\n            offset = -0.5+vec2(float(x), float(y))/float(AA);\n\n        \tcol += render(fragCoord+offset);\n        }\n    }\n    col /= float(AA*AA);\n#else\n    col += render(fragCoord);\n#endif\n    \n    //col = col/(col + vec3(1.0)); //Reinhard tone mapping\n    col = vec3(1.0) - exp(-col * 0.5);//exposure\n\tcol = pow(col, vec3(1.0/2.2)); \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}