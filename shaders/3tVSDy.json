{
    "Shader": {
        "info": {
            "date": "1583573132",
            "description": "Some tartans from [url]https://www.tartanregister.gov.uk[/url]",
            "flags": 48,
            "hasliked": 0,
            "id": "3tVSDy",
            "likes": 14,
            "name": "Tartans",
            "published": 3,
            "tags": [
                "tartan",
                "sett",
                "fbi"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 447
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Tartans\n//\n// Various tartans from the Scottish Register of Tartans:\n// https://www.tartanregister.gov.uk\n//\n// Current sequence: Buchanan (1850), Hunting Stewart, Macbeth, Macleod,\n// Fraser (1745), Thomson Dress Blue, Black Watch Plaid of Pipers, St.\n// Piran's Cornish Flag and the FBI.\n//\n// <mouse>: pan image or modify colours (depending on 'm' key)\n// <left>/<right>: select tartan\n// <up>/<down>: scale\n// <page up>/<page down>: multiply threadcount\n// m: select mouse mode - pan or colouring\n// h: only modify colours on LHS.\n// \n// Display currently just solid blocks of colour (threads 1 pixel wide\n// by default, <up>/<down> scales, and <page up>/<page down>\n// multiplies threadcount).\n//\n// RGB for colours taken from the Register. Use mouse to modify\n// colours (press 'm' key to enable) - x axis controls brightness, y\n// axis mixes in a dull tan for an attempt at a \"weathered\" look.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Colors from Register\nconst int K  = 0x101010; //BLACK\nconst int R  = 0xC80000; //RED;\nconst int Y  = 0xE8C000; //YELLOW;\nconst int Y2 = 0xD8B000; //YELLOW (Macleod)\nconst int G  = 0x006818; //GREEN;\nconst int WW = 0xFCFCFC; //WILSON WHITE;\nconst int B  = 0x2C2C80; //BLUE;\nconst int DG = 0x003820; //DARK GREEN;\nconst int BL = 0x1474B4; //BALMORAL BLUE;\nconst int WG = 0x408060; //WTHRD GREEN;\nconst int HG = 0x285800; //HUNTING GREEN;\nconst int DR = 0x880000; //DARK RED;\nconst int P  = 0x780078; //PURPLE;\nconst int DB = 0x1C1C50; //DARK BLUE;\nconst int W  = 0xE0E0E0; //WHITE;\nconst int H  = 0x006428; //BOTTLE;\nconst int DB2 = 0x202060; //DARK BLUE;\nconst int LG = 0x289C18; //LIGHT GREEN;\nconst int AB = 0x1870A4; //ANC BLUE;\nconst int LN = 0xC0C0C0; //LIGHT GREY;\nconst int RB = 0x1C0070; //ROYAL BLUE;\n\nint tfactor = 1; // Multiply threadcount\nint scale = 1;\n\n// The setts\n\n// Buchanan (1850) - an asymmetric sett\n// B18G46K6B18K6Y40K6Y40K6B18K6R40W6R40K6B18K6G46\n// Pallet:\n// K=101010BLACK;B=2C2C80BLUE;G=006818GREEN;R=C80000RED;W=E0E0E0WHITE;Y=E8C000YELLOW;\nconst int buchanan[] =\n  int [](B,18,G,46,K,6,B,18,K,6,Y,40,K,6,Y,40,K,6,B,18,K,6,R,40,W,6,R,40,K,6,B,18,K,6,G,46);\n\n// Hunting Stewart - an asymmetric sett.\n// B9HG4B9K3B3K3B3K8HG27R4HG27K8HG5K13HG4K13HG5K8HG27Y4HG27K8B3K3B3K3\n// G=006818GREEN;K=101010BLACK;B=2C2C80BLUE;DG=003820DARK GREEN;\n// R=C80000RED;Y=E8C000YELLOW;BL=1474B4BALMORAL BLUE;\n// WG=408060WTHRD GREEN;HG=285800HUNTING GREEN;\n\n// No reflection and odd threadcounts.\nconst int huntingstewart[] = int[](B,9,HG,4,B,9,K,3,B,3,K,3,B,3,K,8,HG,27,R,4,HG,27,K,8,HG,5,\n                                   K,13,HG,4,K,13,HG,5,K,8,HG,27,Y,4,HG,27,K,8,B,3,K,3,B,3,K,3);\n\n// Most other tartans are reflected: halve end threadcounts to get correct reflection\n\n// Fraser (1745)\n// R4B24R4G24R48WW2\n// G=006818GREEN;WW=FCFCFCWILSON WHITE;B=2C2C80BLUE;R=C80000RED;\n\nconst int fraser[] = int[](R,4/2,B,24,R,4,G,24,R,48,WW,2/1);\n\n// Macbeth\n// B144 Y16 K20 WW4 K4 WW4 K8 G32 R24 K4 R12 WW4\nconst int macbeth[] = int[](B,144/2,Y,16,K,20,WW,4,K,4,WW,4,K,8,G,32,R,24,K,4,R,12,WW,4/2);\n\n// Farquharson\n// R4 B16 K4 B4 K4 B4 K32 G32 Y8 G32 K32 B32 K4 R8\nconst int farquharson[] = int[](R,4/2,B,16,K,4,B,4,K,4,B,4,K,32,G,32,Y,8,G,32,K,32,B,32,K,4,R,8/2);\n\n// \"Loud MacLeod\"\n// K32Y4K32Y48R4\n// K=101010BLACK;R=C80000RED;Y=D8B000YELLOW;\nconst int macleod[] = int[](K,32/2,Y2,4,K,32,Y2,48,R,4/2);\n\n// Fujitsu\n// Y2K12G64K24DR24P18DB12W2\n// Y=E8C000YELLOW;K=101010BLACK;G=006818GREEN;DR=880000DARK RED;P=780078PURPLE;DB=1C1C50DARK BLUE;W=E0E0E0WHITE;\nconst int fujitsu[] = int[](Y,2/2,K,12,G,64,K,24,DR,24,P,18,DB,12,W,2/2);\n\n// Asda\n// \"Winning design in a competition run by ASDA Wal-mart in Elgin,\n// Morayshire. The winner, Angela Dean, was aged nine. Different warp\n// and weft.\"\n//\n// LG136R8LG12DB8H68DB8LG12R8LG136DB8H32R8H38DB8.LG248Y12H28Y12\n// H=006428BOTTLE;DB=202060DARK BLUE;R=C80000RED;Y=E8C000YELLOW;LG=289C18LIGHT GREEN;\n// Not doing this one (yet) as warp and weft are different.\nconst int asda0[] = int[](LG,136,R,8,LG,12,DB2,8,H,68,DB,8,LG,12,R,8,LG,136,DB2,8,H,32,R,8,H,38,DB,8);\nconst int asda1[] = int[](LG,248,Y,12,H,28,Y,12);\n\n// The FBI Tartan\n// \"Commissioned for use for the FBI Pipe Band from Thomas\n// Gordon & Sons of Glasgow but now regarded as being the FBI\n// tartan\".\n\n// DR4AB52RB32LN6RB4LN4RB12\n// AB=1870A4ANC BLUE;DR=880000DARK RED;LN=C0C0C0LIGHT GREY;RB=1C0070ROYAL BLUE;\n\nconst int fbi[] = int[](DR,4/2,AB,52,RB,32,LN,6,RB,4,LN,4,RB,12/2);\n\n// Black Watch Plaid of Pipers\n// DB24K4R4K4R4K24DG22Y4DG22K24DB22K4R4\n// K=101010BLACK; DG=006818GREEN; R=C80000RED; Y=E8C000YELLOW; DB=202060DARK BLUE;\n// DG here is just G, DB is DB2\nconst int blackwatchpiper[] = int[](DB2,24/2,K,4,R,4,K,4,R,4,K,24,G,22,Y,4,G,22,K,24,DB2,22,K,4,R,4/2);\n\n// Thomson Dress Blue\n// R6AB60K12W24K24Y6\n// AB=1870A4ANC BLUE;K=101010BLACK;R=C80000RED;W=E0E0E0WHITE;Y=E8C000YELLOW;\nconst int thomson[] = int[](R,6/2,AB,60,K,12,W,24,K,24,Y,6/2);\n\n// St. Piran's Cornish Flag\n// R4K2W20K40W10K40W20K2 - full sett\n// K=101010BLACK;R=C80000RED;W=E0E0E0WHITE;\nconst int stpirans[] = int[](R,4,K,2,W,20,K,40,W,10,K,40,W,20,K,2);\n\nint settlength = 0;  // Total number of bands\nint settsize = 0;    // Total number of threads\nbool reflect = true; // Is sett reflected?\n\nconst int NSETTS = 9;\n\n// Index into the sett.\nint sett(int settid,int i) {\n  int k = 0;\n  if (settid == k++) return buchanan[i];\n  if (settid == k++) return huntingstewart[i];\n  if (settid == k++) return macbeth[i];\n  if (settid == k++) return macleod[i];\n  if (settid == k++) return fraser[i];\n  if (settid == k++) return thomson[i];\n  //if (settid == k++) return farquharson[i];\n  if (settid == k++) return blackwatchpiper[i];\n  //if (settid == k++) return fujitsu[i];\n  if (settid == k++) return stpirans[i];\n  if (settid == k++) return fbi[i];\n  return 0;\n}\n\n// Set up the sett.\nbool setupsett(int settid) {\n  if (settid < 0 || settid >= NSETTS) return false;\n  // Keep list of tartans in the two blocks consistent.\n  int k = 0;\n  if (settid == k++) settlength = buchanan.length(),reflect = false;\n  if (settid == k++) settlength = huntingstewart.length(),reflect = false;\n  if (settid == k++) settlength = macbeth.length();\n  if (settid == k++) settlength = macleod.length();\n  if (settid == k++) settlength = fraser.length();\n  if (settid == k++) settlength = thomson.length();\n  //if (settid == k++) settlength = farquharson.length();\n  if (settid == k++) settlength = blackwatchpiper.length();\n  //if (settid == k++) settlength = fujitsu.length();\n  if (settid == k++) settlength = stpirans.length(),reflect = false;\n  if (settid == k++) settlength = fbi.length();\n  if (k != NSETTS) return false;\n\n  for (int i = 0; i < settlength; i += 2) {\n    settsize += tfactor*sett(settid,i+1);\n  }\n  return true;\n}\n\nint mymod(int n, int m) {\n  // glsl % undefined for -ve arguments\n  if (n < 0) return m-1-(-n-1)%m;\n  else return n%m;\n}\n\nint getsettcol(int settid,int n) {\n  if (reflect) {\n    n = mymod(n,2*settsize);\n    n = min(n,2*settsize-n-1);\n  } else {\n    n = mymod(n,settsize);\n  }\n  int total = 0;\n  for (int i = 0; i < settlength; i += 2) {\n    total += tfactor*sett(settid,i+1);\n    if (n < total) return sett(settid,i);\n  }\n  return 0;\n}\n\nvec3 hex2rgb(int n) {\n  return vec3((n>>16)&0xFF,(n>>8)&0xFF,(n>>0)&0xFF)/256.0;\n}\n\nvec3 getcol(int settid,ivec2 a) {\n  // Determine if we have a warp or weft thread at this location\n  bool warp = mymod(a.x-a.y,4) < 2;\n  int n =  warp ? a.x : a.y;\n  // And look up in the sett.\n  vec3 col = hex2rgb(getsettcol(settid,n));\n  if (!warp) col *= 0.9;\n  return col;\n}\n\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_H = 72;\nconst int CHAR_M = 77;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nbool keypress(int key) {\n  return texelFetch(iChannel0,ivec2(key,2),0).x != 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  tfactor = 1+max(0,keycount(KEY_PAGE_UP)-keycount(KEY_PAGE_DOWN));\n  scale = 1+max(0,keycount(KEY_UP)-keycount(KEY_DOWN));\n\n  int settid = keycount(KEY_RIGHT)-keycount(KEY_LEFT);\n  settid = mymod(settid,NSETTS+1);\n  if (settid == 0) settid = mymod(int(0.5*iTime),NSETTS);\n  else settid--;\n\n  if (!setupsett(settid)) {\n    fragColor = vec4(1);\n    return;\n  }\n  vec2 p = fragCoord-0.5*iResolution.xy;\n  if (!keypress(CHAR_M) && iMouse.x > 0.0) {\n    p -= iMouse.xy-0.5*iResolution.xy;\n  }\n  p /= float(scale);\n  vec3 col = getcol(settid,ivec2(floor(p)));\n  float value = 1.0;\n  float saturation = 1.0;\n  if (keypress(CHAR_M) && iMouse.x > 0.0) {\n    value = iMouse.x/iResolution.y;\n    saturation = iMouse.y/iResolution.y;\n  }\n  // Unsaturate by mixing with tan for a \"weathered\" look.\n  vec3 satcol = hex2rgb(0xD2B48C);//hex2rgb(0x4A412A);\n  if (!keypress(CHAR_H) || fragCoord.x < 0.5*iResolution.x) {\n    col = value*(mix(satcol,col,saturation));\n  }\n  fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}