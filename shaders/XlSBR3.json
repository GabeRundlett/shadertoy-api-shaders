{
    "Shader": {
        "info": {
            "date": "1517215546",
            "description": "A basic 2D snake game. Uses multi-pass rendering; Buf A runs the game and saves out values to predefined pixels which are then read in by the main Image for display.\n\nInspired by https://www.shadertoy.com/view/MddGzf",
            "flags": 48,
            "hasliked": 0,
            "id": "XlSBR3",
            "likes": 4,
            "name": "[5] 2D Snake Game",
            "published": 3,
            "tags": [
                "2d",
                "game",
                "snake",
                "multipass"
            ],
            "usePreview": 0,
            "username": "emr4378",
            "viewed": 673
        },
        "renderpass": [
            {
                "code": "// Rendering logic.\n\nconst int GAME_STATE_END   = 3;\n\nconst ivec2 k_game_state_slot              = ivec2(0, 0);\nconst ivec2 k_game_board_size_slot         = ivec2(0, 3);\nconst ivec2 k_snake_head_position_slot     = ivec2(0, 5);\nconst ivec2 k_snake_body_list_size_slot    = ivec2(0, 7);\nconst ivec2 k_fruit_position_slot          = ivec2(0, 8);\n\nvec4 load_value(ivec2 slot)\n{\n    return texelFetch(iChannel0, slot, 0);\n}\n\nvec4 load_snake_body_list_value(int index)\n{\n    ivec2 resolution = ivec2(iChannelResolution[0].xy);\n    int resolution_area = resolution.x * resolution.y;\n\n    index = resolution_area - 1 - index;\n    \n    ivec2 slot = ivec2(\n        index % resolution.x,\n        index / resolution.x);\n    \n    return load_value(slot);        \n}\n\n// Source: https://stackoverflow.com/a/4275343\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    int game_state = int(load_value(k_game_state_slot).x);\n    ivec2 game_board_size = ivec2(load_value(k_game_board_size_slot).xy);\n    ivec2 snake_head_position = ivec2(load_value(k_snake_head_position_slot).xy);\n    ivec2 fruit_position = ivec2(load_value(k_fruit_position_slot).xy);\n\n    ivec2 game_tile_size = ivec2(iResolution.xy) / game_board_size;\n    ivec2 game_board_coord = ivec2(fragCoord.xy) / game_tile_size;\n\n    if (game_board_coord == snake_head_position)\n    {\n        fragColor = vec4(1.0);\n\t}\n    else if (game_board_coord == fruit_position)\n    {\n        fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n    }\n    else\n    {        \n        int snake_body_list_size = int(load_value(k_snake_body_list_size_slot).x);\n\n        for (int i = 0; i < snake_body_list_size; i++)\n        {\n            ivec2 snake_body_position = ivec2(load_snake_body_list_value(i).xy);\n\n            if (snake_body_position == game_board_coord.xy)\n            {\n                if (game_state == GAME_STATE_END)\n                {\n                    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n                }\n                else\n                {\n                    fragColor = vec4(\n                        rand(vec2(game_board_coord.xx)),\n                        rand(vec2(game_board_coord.yy)),\n                        rand(vec2(game_board_coord.xy)),\n                        1.0);\n                }\n                break;\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Gameplay logic. Runs the entire game for every pixel. If the current pixel is\n// one of the save \"slots\" the appropriate value will be output to its fragColor.\n//\n// Controls:\n// - Arrow keys to change direction.\n// - Space to (un)pause or restart.\n\nconst int KEY_NONE  = 0;\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int GAME_STATE_RESET = 0;\nconst int GAME_STATE_PAUSE = 1;\nconst int GAME_STATE_PLAY  = 2;\nconst int GAME_STATE_END   = 3;\n\n// Stored variable initial values (used on GAME_STATE_RESET)\nconst int k_initial_game_state             = GAME_STATE_PLAY;\nconst float k_initial_game_speed           = 7.5;\nconst ivec2 k_initial_game_board_size      = ivec2(32, 18);\nconst ivec2 k_initial_snake_head_position  = k_initial_game_board_size / 2;\nconst ivec2 k_initial_snake_head_velocity  = ivec2(1, 0);\nconst int k_initial_snake_body_list_size   = 5;\nconst ivec2 k_initial_fruit_position       = k_initial_snake_head_position + k_initial_snake_head_velocity * 5;\n\n// Stored variable slots\nconst ivec2 k_game_state_slot              = ivec2(0, 0);\nconst ivec2 k_game_speed_slot              = ivec2(0, 1);\nconst ivec2 k_game_last_tick_time_slot     = ivec2(0, 2);\nconst ivec2 k_game_board_size_slot         = ivec2(0, 3);\nconst ivec2 k_game_queued_key_slot         = ivec2(0, 4);\nconst ivec2 k_snake_head_position_slot     = ivec2(0, 5);\nconst ivec2 k_snake_head_velocity_slot     = ivec2(0, 6);\nconst ivec2 k_snake_body_list_size_slot    = ivec2(0, 7);\nconst ivec2 k_fruit_position_slot          = ivec2(0, 8);\n// NOTE: Snake body segments are stored at end of buffer.\n\nvec4 load_value(ivec2 slot)\n{\n    return texelFetch(iChannel0, slot, 0);\n}\n\nvoid save_value(ivec2 slot, vec4 value, vec2 fragCoord, inout vec4 fragColor)\n{\n    if (slot == ivec2(fragCoord))\n\t{\n\t\tfragColor = value;\n\t}\n}\n\nvec4 load_snake_body_list_value(int index)\n{\n    ivec2 resolution = ivec2(iChannelResolution[0].xy);\n    int resolution_area = resolution.x * resolution.y;\n\n    index = resolution_area - 1 - index;\n    \n    ivec2 slot = ivec2(\n        index % resolution.x,\n        index / resolution.x);\n    \n    return load_value(slot);        \n}\n\nvoid save_snake_body_list_value(int index, vec4 value, vec2 fragCoord, inout vec4 fragColor)\n{\n    ivec2 resolution = ivec2(iChannelResolution[0].xy);\n    int resolution_area = resolution.x * resolution.y;\n\n    index = resolution_area - 1 - index;\n    \n    ivec2 slot = ivec2(\n        index % resolution.x,\n        index / resolution.x);\n\n    save_value(slot, value, fragCoord, fragColor);\n}\n\n// Source: https://www.shadertoy.com/view/lsXGzf\nbool is_key_pressed(int key_code)\n{\n    return texelFetch(iChannel1, ivec2(key_code, 1), 0).x > 0.5;\n}\n\n// Source: https://stackoverflow.com/a/4275343\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nivec2 get_next_fruit_position(ivec2 prev_position, ivec2 game_board_size)\n{\n    vec2 temp = vec2(\n        rand(vec2(prev_position.xy * game_board_size.yx) * iTime),\n        rand(vec2(prev_position.yx * game_board_size.xy) * iTime));\n    \n    return ivec2(temp * vec2(game_board_size));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Load all of the stored variables.\n    int game_state = int(load_value(k_game_state_slot).x);\n    float game_speed = load_value(k_game_speed_slot).x;\n    float game_last_tick_time = load_value(k_game_last_tick_time_slot).x;\n    ivec2 game_board_size = ivec2(load_value(k_game_board_size_slot).xy);\n    int game_queued_key = int(load_value(k_game_queued_key_slot).x);\n    ivec2 snake_head_position = ivec2(load_value(k_snake_head_position_slot).xy);\n    ivec2 snake_head_velocity = ivec2(load_value(k_snake_head_velocity_slot).xy);\n    int snake_body_list_size = int(load_value(k_snake_body_list_size_slot).x);\n    ivec2 fruit_position = ivec2(load_value(k_fruit_position_slot).xy);\n\n    int prev_game_state = game_state;\n    ivec2 prev_snake_head_position = snake_head_position;\n    \n    if (game_state == GAME_STATE_RESET)\n    {\n        // Re-initialize all stored variables on reset.\n        game_state = k_initial_game_state;\n\t\tgame_speed = k_initial_game_speed;\n        game_last_tick_time = 0.0;\n        game_board_size = k_initial_game_board_size;\n        game_queued_key = KEY_NONE;\n\t\tsnake_head_position = k_initial_snake_head_position;\n\t\tsnake_head_velocity = k_initial_snake_head_velocity;\n        snake_body_list_size = k_initial_snake_body_list_size;\n        fruit_position = k_initial_fruit_position;\n    }\n    else if (game_state == GAME_STATE_PAUSE)\n    {\n        // Only check for the unpause key when paused.\n        if (is_key_pressed(KEY_SPACE))\n        {\n            game_state = GAME_STATE_PLAY;\n        }\n    }\n    else if (game_state == GAME_STATE_END)\n    {\n        // Only check for the reset key when the game is over.\n        if (is_key_pressed(KEY_SPACE))\n        {\n            game_state = GAME_STATE_RESET;\n        }\n    }\n    else if (game_state == GAME_STATE_PLAY)\n    {\n        // Check for the pause key.\n        if (is_key_pressed(KEY_SPACE))\n        {\n            game_state = GAME_STATE_PAUSE;\n        }\n        else\n        {\n            // Queue pressed direction keys to process on game tick.\n            if (snake_head_velocity.x == 0)\n            {\n                if (is_key_pressed(KEY_LEFT))\n                {\n                    game_queued_key = KEY_LEFT;\n                }\n                else if (is_key_pressed(KEY_RIGHT))\n                {\n                    game_queued_key = KEY_RIGHT;\n                }\n            }\n            else if (snake_head_velocity.y == 0)\n            {\n                if (is_key_pressed(KEY_UP))\n                {\n                    game_queued_key = KEY_UP;\n                }\n                else if (is_key_pressed(KEY_DOWN))\n                {\n                    game_queued_key = KEY_DOWN;\n                }\n            }\n            \n            // Check for game tick.\n            if (iTime - game_last_tick_time > (1.0 / game_speed))\n            {\n                // Process the queued direction key.\n                if (game_queued_key == KEY_LEFT)\n                {\n                    snake_head_velocity = ivec2(-1, 0);\n                }\n                else if (game_queued_key == KEY_RIGHT)\n                {\n                    snake_head_velocity = ivec2(1, 0);\n                }\n                else if (game_queued_key == KEY_UP)\n                {\n                    snake_head_velocity = ivec2(0, 1);\n                }\n                else if (game_queued_key == KEY_DOWN)\n                {\n                    snake_head_velocity = ivec2(0, -1);\n                }\n                game_queued_key = KEY_NONE;\n                \n                // Update the head's position.\n                snake_head_position = (snake_head_position + snake_head_velocity + game_board_size) % game_board_size;\n\n                // Check for collision with fruit.\n                if (snake_head_position == fruit_position)\n                {\n                    snake_body_list_size++;\n                    \n                    fruit_position = get_next_fruit_position(fruit_position, game_board_size);\n                    game_speed += 0.5;\n                }\n                \n                game_last_tick_time = iTime;\n            }\n        }\n\t}\n\t\n    // Update all the body segment positions.\n    ivec2 prev_position = prev_snake_head_position;\n    \n    for (int i = 0; i < snake_body_list_size; i++)\n    {\n        ivec2 prev_body_position = ivec2(load_snake_body_list_value(i).xy);\n        ivec2 curr_body_position = prev_body_position;\n        \n        if (prev_game_state == GAME_STATE_RESET)\n        {\n            curr_body_position = snake_head_position;\n        }\n        else if (game_state == GAME_STATE_PLAY &&\n            \t prev_snake_head_position != snake_head_position)\n        {\n            // Check for collision with body.\n            if (curr_body_position == snake_head_position)\n            {\n                game_state = GAME_STATE_END;\n            }\n\n            // Check for collision with fruit.\n            if (curr_body_position == fruit_position)\n            {\n                fruit_position = get_next_fruit_position(fruit_position, game_board_size);\n            }\n            \n            curr_body_position = prev_position;\n            prev_position = prev_body_position;\n        }\n        \n        save_snake_body_list_value(i, vec4(curr_body_position, vec2(0)), fragCoord, fragColor);\n    }\n    \n\t// Save out the variable for the current fragCoord.\n\tsave_value(k_game_state_slot, vec4(game_state, vec3(0)), fragCoord, fragColor);\n\tsave_value(k_game_speed_slot, vec4(game_speed, vec3(0)), fragCoord, fragColor);\n    save_value(k_game_last_tick_time_slot, vec4(game_last_tick_time, vec3(0)), fragCoord, fragColor);\n    save_value(k_game_board_size_slot, vec4(game_board_size, vec2(0)), fragCoord, fragColor);\n    save_value(k_game_queued_key_slot, vec4(game_queued_key, vec3(0)), fragCoord, fragColor);\n\tsave_value(k_snake_head_position_slot, vec4(snake_head_position, vec2(0)), fragCoord, fragColor);\n\tsave_value(k_snake_head_velocity_slot, vec4(snake_head_velocity, vec2(0)), fragCoord, fragColor);\n    save_value(k_snake_body_list_size_slot, vec4(snake_body_list_size, vec3(0)), fragCoord, fragColor);\n    save_value(k_fruit_position_slot, vec4(fruit_position, vec2(0)), fragCoord, fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}